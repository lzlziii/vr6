using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using Common;
using DG.Tweening;
using DG.Tweening.Core;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core.PathCore;
using DG.Tweening.Plugins.Options;
using DearVR;
using Kaine;
using Oculus.Platform;
using StackableDecorator;
using TMPro;
using UTJ;
using UTJ.GameObjectExtensions;
using UTJ.StringQueueExtensions;
using UniRx;
using UniRx.Triggers;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Analytics;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Playables;
using UnityEngine.Profiling;
using UnityEngine.SceneManagement;
using UnityEngine.Timeline;
using UnityEngine.UI;
using UnityEngine.Video;
using UnityEngine.XR;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyVersion("0.0.0.0")]
[AttributeUsage(AttributeTargets.Field)]
public class EnumLabelAttribute : PropertyAttribute
{
	public string[] EnumNames { get; private set; }

	public EnumLabelAttribute(Type enumType)
	{
		EnumNames = Enum.GetNames(enumType);
	}
}
public class NotEditableAttribute : PropertyAttribute
{
}
public class PrefabFieldAttribute : PropertyAttribute
{
}
public static class Matrix4x4Extension
{
	public static Vector3 MultiplyPoint3x4(this Matrix4x4 self, ref Vector3 point)
	{
		Vector3 result = default(Vector3);
		result.x = self.m00 * point.x + self.m01 * point.y + self.m02 * point.z + self.m03;
		result.y = self.m10 * point.x + self.m11 * point.y + self.m12 * point.z + self.m13;
		result.z = self.m20 * point.x + self.m21 * point.y + self.m22 * point.z + self.m23;
		return result;
	}

	public static Vector3 MultiplyVector(this Matrix4x4 self, ref Vector3 vector)
	{
		Vector3 result = default(Vector3);
		result.x = self.m00 * vector.x + self.m01 * vector.y + self.m02 * vector.z;
		result.y = self.m10 * vector.x + self.m11 * vector.y + self.m12 * vector.z;
		result.z = self.m20 * vector.x + self.m21 * vector.y + self.m22 * vector.z;
		return result;
	}
}
public static class PlayableDirectorExt
{
	public static IObservable<PlayableDirector> PlayedAsObservable(this PlayableDirector src)
	{
		return Observable.FromEvent(delegate(Action<PlayableDirector> h)
		{
			src.played += h;
		}, delegate(Action<PlayableDirector> h)
		{
			src.played -= h;
		});
	}

	public static IObservable<PlayableDirector> PausedAsObservable(this PlayableDirector src)
	{
		return Observable.FromEvent(delegate(Action<PlayableDirector> h)
		{
			src.paused += h;
		}, delegate(Action<PlayableDirector> h)
		{
			src.paused -= h;
		});
	}

	public static IObservable<PlayableDirector> StoppedAsObservable(this PlayableDirector src)
	{
		return Observable.FromEvent(delegate(Action<PlayableDirector> h)
		{
			src.stopped += h;
		}, delegate(Action<PlayableDirector> h)
		{
			src.stopped -= h;
		});
	}

	public static IObservable<PlayableDirector> PlayAsStream(this PlayableDirector src)
	{
		return Observable.Create(delegate(IObserver<PlayableDirector> observer)
		{
			if (src.state == PlayState.Playing)
			{
				src.Stop();
			}
			src.Play();
			IDisposable disposable = src.StoppedAsObservable().Subscribe(delegate(PlayableDirector x)
			{
				observer.OnNext(x);
				observer.OnCompleted();
			});
			return Disposable.Create(delegate
			{
				disposable.Dispose();
				if (src.state == PlayState.Playing)
				{
					src.Stop();
				}
			});
		});
	}
}
public class DropdownSortingLayer : MonoBehaviour
{
	[SerializeField]
	private bool _overrideSort;

	[SerializeField]
	private string _sortingLayerName = "Front";

	[SerializeField]
	private bool _sortBlocker;

	private void Awake()
	{
		Canvas component = GetComponent<Canvas>();
		if (component != null)
		{
			component.overrideSorting = _overrideSort;
			component.sortingLayerName = _sortingLayerName;
		}
	}

	private void Start()
	{
		GameObject gameObject = GameObject.Find("Blocker");
		if (!(gameObject != null))
		{
			return;
		}
		Canvas component = gameObject.GetComponent<Canvas>();
		if (component != null)
		{
			if (_sortBlocker)
			{
				component.sortingLayerName = _sortingLayerName;
			}
			else
			{
				component.sortingLayerName = "Default";
			}
		}
	}
}
[Serializable]
public class LightControlBehaviour : PlayableBehaviour
{
	public Color color = Color.white;

	public float intensity = 1f;

	public float bounceIntensity = 1f;

	public float range = 10f;
}
[Serializable]
public class LightControlClip : PlayableAsset, ITimelineClipAsset
{
	public LightControlBehaviour template = new LightControlBehaviour();

	public ClipCaps clipCaps => ClipCaps.Blending;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		return ScriptPlayable<LightControlBehaviour>.Create(graph, template);
	}
}
public class LightControlMixerBehaviour : PlayableBehaviour
{
	private Color m_DefaultColor;

	private float m_DefaultIntensity;

	private float m_DefaultBounceIntensity;

	private float m_DefaultRange;

	private Light m_TrackBinding;

	private bool m_FirstFrameHappened;

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		m_TrackBinding = playerData as Light;
		if (m_TrackBinding == null)
		{
			return;
		}
		if (!m_FirstFrameHappened)
		{
			m_DefaultColor = m_TrackBinding.color;
			m_DefaultIntensity = m_TrackBinding.intensity;
			m_DefaultBounceIntensity = m_TrackBinding.bounceIntensity;
			m_DefaultRange = m_TrackBinding.range;
			m_FirstFrameHappened = true;
		}
		int inputCount = playable.GetInputCount();
		Color clear = Color.clear;
		float num = 0f;
		float num2 = 0f;
		float num3 = 0f;
		float num4 = 0f;
		float num5 = 0f;
		int num6 = 0;
		for (int i = 0; i < inputCount; i++)
		{
			float inputWeight = playable.GetInputWeight(i);
			LightControlBehaviour behaviour = ((ScriptPlayable<LightControlBehaviour>)playable.GetInput(i)).GetBehaviour();
			clear += behaviour.color * inputWeight;
			num += behaviour.intensity * inputWeight;
			num2 += behaviour.bounceIntensity * inputWeight;
			num3 += behaviour.range * inputWeight;
			num4 += inputWeight;
			if (inputWeight > num5)
			{
				num5 = inputWeight;
			}
			if (!Mathf.Approximately(inputWeight, 0f))
			{
				num6++;
			}
		}
		m_TrackBinding.color = clear + m_DefaultColor * (1f - num4);
		m_TrackBinding.intensity = num + m_DefaultIntensity * (1f - num4);
		m_TrackBinding.bounceIntensity = num2 + m_DefaultBounceIntensity * (1f - num4);
		m_TrackBinding.range = num3 + m_DefaultRange * (1f - num4);
	}

	public override void OnPlayableDestroy(Playable playable)
	{
		m_FirstFrameHappened = false;
		if (!(m_TrackBinding == null))
		{
			m_TrackBinding.color = m_DefaultColor;
			m_TrackBinding.intensity = m_DefaultIntensity;
			m_TrackBinding.bounceIntensity = m_DefaultBounceIntensity;
			m_TrackBinding.range = m_DefaultRange;
		}
	}
}
[TrackColor(0.9454092f, 0.9779412f, 0.3883002f)]
[TrackClipType(typeof(LightControlClip))]
[TrackBindingType(typeof(Light))]
public class LightControlTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<LightControlMixerBehaviour>.Create(graph, inputCount);
	}

	public override void GatherProperties(PlayableDirector director, IPropertyCollector driver)
	{
		base.GatherProperties(director, driver);
	}
}
[Serializable]
public class NavMeshAgentControlBehaviour : PlayableBehaviour
{
	public Transform destination;

	public bool destinationSet;

	public override void OnPlayableCreate(Playable playable)
	{
		destinationSet = false;
	}
}
[Serializable]
public class NavMeshAgentControlClip : PlayableAsset, ITimelineClipAsset
{
	public ExposedReference<Transform> destination;

	[HideInInspector]
	public NavMeshAgentControlBehaviour template = new NavMeshAgentControlBehaviour();

	public ClipCaps clipCaps => ClipCaps.None;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		ScriptPlayable<NavMeshAgentControlBehaviour> scriptPlayable = ScriptPlayable<NavMeshAgentControlBehaviour>.Create(graph, template);
		scriptPlayable.GetBehaviour().destination = destination.Resolve(graph.GetResolver());
		return scriptPlayable;
	}
}
public class NavMeshAgentControlMixerBehaviour : PlayableBehaviour
{
	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		NavMeshAgent navMeshAgent = playerData as NavMeshAgent;
		if (!navMeshAgent)
		{
			return;
		}
		int inputCount = playable.GetInputCount();
		for (int i = 0; i < inputCount; i++)
		{
			float inputWeight = playable.GetInputWeight(i);
			NavMeshAgentControlBehaviour behaviour = ((ScriptPlayable<NavMeshAgentControlBehaviour>)playable.GetInput(i)).GetBehaviour();
			if (inputWeight > 0.5f && !behaviour.destinationSet && (bool)behaviour.destination && navMeshAgent.isOnNavMesh)
			{
				navMeshAgent.SetDestination(behaviour.destination.position);
				behaviour.destinationSet = true;
			}
		}
	}
}
[TrackColor(0.855f, 0.8623f, 0.87f)]
[TrackClipType(typeof(NavMeshAgentControlClip))]
[TrackBindingType(typeof(NavMeshAgent))]
public class NavMeshAgentControlTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<NavMeshAgentControlMixerBehaviour>.Create(graph, inputCount);
	}
}
[Serializable]
public class ScreenFaderBehaviour : PlayableBehaviour
{
	public Color color = Color.black;
}
[Serializable]
public class ScreenFaderClip : PlayableAsset, ITimelineClipAsset
{
	public ScreenFaderBehaviour template = new ScreenFaderBehaviour();

	public ClipCaps clipCaps => ClipCaps.Blending;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		return ScriptPlayable<ScreenFaderBehaviour>.Create(graph, template);
	}
}
public class ScreenFaderMixerBehaviour : PlayableBehaviour
{
	private Color m_DefaultColor;

	private Image m_TrackBinding;

	private bool m_FirstFrameHappened;

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		m_TrackBinding = playerData as Image;
		if (m_TrackBinding == null)
		{
			return;
		}
		if (!m_FirstFrameHappened)
		{
			m_DefaultColor = m_TrackBinding.color;
			m_FirstFrameHappened = true;
		}
		int inputCount = playable.GetInputCount();
		Color clear = Color.clear;
		float num = 0f;
		float num2 = 0f;
		int num3 = 0;
		for (int i = 0; i < inputCount; i++)
		{
			float inputWeight = playable.GetInputWeight(i);
			ScreenFaderBehaviour behaviour = ((ScriptPlayable<ScreenFaderBehaviour>)playable.GetInput(i)).GetBehaviour();
			clear += behaviour.color * inputWeight;
			num += inputWeight;
			if (inputWeight > num2)
			{
				num2 = inputWeight;
			}
			if (!Mathf.Approximately(inputWeight, 0f))
			{
				num3++;
			}
		}
		m_TrackBinding.color = clear + m_DefaultColor * (1f - num);
	}

	public override void OnPlayableDestroy(Playable playable)
	{
		m_FirstFrameHappened = false;
		if (!(m_TrackBinding == null))
		{
			m_TrackBinding.color = m_DefaultColor;
		}
	}
}
[TrackColor(0.875f, 0.5944853f, 0.1737132f)]
[TrackClipType(typeof(ScreenFaderClip))]
[TrackBindingType(typeof(Image))]
public class ScreenFaderTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<ScreenFaderMixerBehaviour>.Create(graph, inputCount);
	}

	public override void GatherProperties(PlayableDirector director, IPropertyCollector driver)
	{
		base.GatherProperties(director, driver);
	}
}
[Serializable]
public class TextSwitcherBehaviour : PlayableBehaviour
{
	public Color color = Color.white;

	public int fontSize = 14;

	public string text;
}
[Serializable]
public class TextSwitcherClip : PlayableAsset, ITimelineClipAsset
{
	public TextSwitcherBehaviour template = new TextSwitcherBehaviour();

	public ClipCaps clipCaps => ClipCaps.Blending;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		return ScriptPlayable<TextSwitcherBehaviour>.Create(graph, template);
	}
}
public class TextSwitcherMixerBehaviour : PlayableBehaviour
{
	private Color m_DefaultColor;

	private int m_DefaultFontSize;

	private string m_DefaultText;

	private Text m_TrackBinding;

	private bool m_FirstFrameHappened;

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		m_TrackBinding = playerData as Text;
		if (m_TrackBinding == null)
		{
			return;
		}
		if (!m_FirstFrameHappened)
		{
			m_DefaultColor = m_TrackBinding.color;
			m_DefaultFontSize = m_TrackBinding.fontSize;
			m_DefaultText = m_TrackBinding.text;
			m_FirstFrameHappened = true;
		}
		int inputCount = playable.GetInputCount();
		Color clear = Color.clear;
		float num = 0f;
		float num2 = 0f;
		float num3 = 0f;
		int num4 = 0;
		for (int i = 0; i < inputCount; i++)
		{
			float inputWeight = playable.GetInputWeight(i);
			TextSwitcherBehaviour behaviour = ((ScriptPlayable<TextSwitcherBehaviour>)playable.GetInput(i)).GetBehaviour();
			clear += behaviour.color * inputWeight;
			num += (float)behaviour.fontSize * inputWeight;
			num2 += inputWeight;
			if (inputWeight > num3)
			{
				m_TrackBinding.text = behaviour.text;
				num3 = inputWeight;
			}
			if (!Mathf.Approximately(inputWeight, 0f))
			{
				num4++;
			}
		}
		m_TrackBinding.color = clear + m_DefaultColor * (1f - num2);
		m_TrackBinding.fontSize = Mathf.RoundToInt(num + (float)m_DefaultFontSize * (1f - num2));
		if (num4 != 1 && 1f - num2 > num3)
		{
			m_TrackBinding.text = m_DefaultText;
		}
	}

	public override void OnPlayableDestroy(Playable playable)
	{
		m_FirstFrameHappened = false;
		if (!(m_TrackBinding == null))
		{
			m_TrackBinding.color = m_DefaultColor;
			m_TrackBinding.fontSize = m_DefaultFontSize;
			m_TrackBinding.text = m_DefaultText;
		}
	}
}
[TrackColor(0.1394896f, 0.4411765f, 0.3413077f)]
[TrackClipType(typeof(TextSwitcherClip))]
[TrackBindingType(typeof(Text))]
public class TextSwitcherTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<TextSwitcherMixerBehaviour>.Create(graph, inputCount);
	}

	public override void GatherProperties(PlayableDirector director, IPropertyCollector driver)
	{
		base.GatherProperties(director, driver);
	}
}
[Serializable]
public class TimeDilationBehaviour : PlayableBehaviour
{
	public float timeScale = 1f;
}
[Serializable]
public class TimeDilationClip : PlayableAsset, ITimelineClipAsset
{
	public TimeDilationBehaviour template = new TimeDilationBehaviour();

	public ClipCaps clipCaps => ClipCaps.Extrapolation | ClipCaps.Blending;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		return ScriptPlayable<TimeDilationBehaviour>.Create(graph, template);
	}
}
public class TimeDilationMixerBehaviour : PlayableBehaviour
{
	private float m_OldTimeScale = 1f;

	public override void OnPlayableCreate(Playable playable)
	{
		m_OldTimeScale = Time.timeScale;
	}

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		int inputCount = playable.GetInputCount();
		float num = 0f;
		float num2 = 0f;
		for (int i = 0; i < inputCount; i++)
		{
			float inputWeight = playable.GetInputWeight(i);
			num2 += inputWeight;
			TimeDilationBehaviour behaviour = ((ScriptPlayable<TimeDilationBehaviour>)playable.GetInput(i)).GetBehaviour();
			num += inputWeight * behaviour.timeScale;
		}
		Time.timeScale = num + m_OldTimeScale * (1f - num2);
	}

	public override void OnPlayableDestroy(Playable playable)
	{
		Time.timeScale = m_OldTimeScale;
	}
}
[TrackColor(0.855f, 0.8623f, 0.87f)]
[TrackClipType(typeof(TimeDilationClip))]
public class TimeDilationTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<TimeDilationMixerBehaviour>.Create(graph, inputCount);
	}
}
[Serializable]
public class TransformTweenBehaviour : PlayableBehaviour
{
	public enum TweenType
	{
		Linear,
		Deceleration,
		Harmonic,
		Custom
	}

	public Transform startLocation;

	public Transform endLocation;

	public bool tweenPosition = true;

	public bool tweenRotation = true;

	public TweenType tweenType;

	public AnimationCurve customCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public Vector3 startingPosition;

	public Quaternion startingRotation = Quaternion.identity;

	private AnimationCurve m_LinearCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	private AnimationCurve m_DecelerationCurve = new AnimationCurve(new Keyframe(0f, 0f, -(float)Math.PI / 2f, (float)Math.PI / 2f), new Keyframe(1f, 1f, 0f, 0f));

	private AnimationCurve m_HarmonicCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	private const float k_RightAngleInRads = (float)Math.PI / 2f;

	public override void PrepareFrame(Playable playable, FrameData info)
	{
		if ((bool)startLocation)
		{
			startingPosition = startLocation.position;
			startingRotation = startLocation.rotation;
		}
	}

	public float EvaluateCurrentCurve(float time)
	{
		if (tweenType == TweenType.Custom && !IsCustomCurveNormalised())
		{
			UnityEngine.Debug.LogError("Custom Curve is not normalised.  Curve must start at 0,0 and end at 1,1.");
			return 0f;
		}
		return tweenType switch
		{
			TweenType.Linear => m_LinearCurve.Evaluate(time), 
			TweenType.Deceleration => m_DecelerationCurve.Evaluate(time), 
			TweenType.Harmonic => m_HarmonicCurve.Evaluate(time), 
			_ => customCurve.Evaluate(time), 
		};
	}

	private bool IsCustomCurveNormalised()
	{
		if (!Mathf.Approximately(customCurve[0].time, 0f))
		{
			return false;
		}
		if (!Mathf.Approximately(customCurve[0].value, 0f))
		{
			return false;
		}
		if (!Mathf.Approximately(customCurve[customCurve.length - 1].time, 1f))
		{
			return false;
		}
		return Mathf.Approximately(customCurve[customCurve.length - 1].value, 1f);
	}
}
[Serializable]
public class TransformTweenClip : PlayableAsset, ITimelineClipAsset
{
	public TransformTweenBehaviour template = new TransformTweenBehaviour();

	public ExposedReference<Transform> startLocation;

	public ExposedReference<Transform> endLocation;

	public ClipCaps clipCaps => ClipCaps.Blending;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		ScriptPlayable<TransformTweenBehaviour> scriptPlayable = ScriptPlayable<TransformTweenBehaviour>.Create(graph, template);
		TransformTweenBehaviour behaviour = scriptPlayable.GetBehaviour();
		behaviour.startLocation = startLocation.Resolve(graph.GetResolver());
		behaviour.endLocation = endLocation.Resolve(graph.GetResolver());
		return scriptPlayable;
	}
}
public class TransformTweenMixerBehaviour : PlayableBehaviour
{
	private bool m_FirstFrameHappened;

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		Transform transform = playerData as Transform;
		if (transform == null)
		{
			return;
		}
		Vector3 position = transform.position;
		Quaternion rotation = transform.rotation;
		int inputCount = playable.GetInputCount();
		float num = 0f;
		float num2 = 0f;
		Vector3 zero = Vector3.zero;
		Quaternion quaternion = new Quaternion(0f, 0f, 0f, 0f);
		for (int i = 0; i < inputCount; i++)
		{
			ScriptPlayable<TransformTweenBehaviour> playable2 = (ScriptPlayable<TransformTweenBehaviour>)playable.GetInput(i);
			TransformTweenBehaviour behaviour = playable2.GetBehaviour();
			if (behaviour.endLocation == null)
			{
				continue;
			}
			float inputWeight = playable.GetInputWeight(i);
			if (!m_FirstFrameHappened && !behaviour.startLocation)
			{
				behaviour.startingPosition = position;
				behaviour.startingRotation = rotation;
			}
			float time = (float)(playable2.GetTime() / playable2.GetDuration());
			float t = behaviour.EvaluateCurrentCurve(time);
			if (behaviour.tweenPosition)
			{
				num += inputWeight;
				zero += Vector3.Lerp(behaviour.startingPosition, behaviour.endLocation.position, t) * inputWeight;
			}
			if (behaviour.tweenRotation)
			{
				num2 += inputWeight;
				Quaternion rotation2 = Quaternion.Lerp(behaviour.startingRotation, behaviour.endLocation.rotation, t);
				rotation2 = NormalizeQuaternion(rotation2);
				if (Quaternion.Dot(quaternion, rotation2) < 0f)
				{
					rotation2 = ScaleQuaternion(rotation2, -1f);
				}
				rotation2 = ScaleQuaternion(rotation2, inputWeight);
				quaternion = AddQuaternions(quaternion, rotation2);
			}
		}
		zero += position * (1f - num);
		Quaternion second = ScaleQuaternion(rotation, 1f - num2);
		quaternion = AddQuaternions(quaternion, second);
		transform.position = zero;
		transform.rotation = quaternion;
		m_FirstFrameHappened = true;
	}

	public override void OnPlayableDestroy(Playable playable)
	{
		m_FirstFrameHappened = false;
	}

	private static Quaternion AddQuaternions(Quaternion first, Quaternion second)
	{
		first.w += second.w;
		first.x += second.x;
		first.y += second.y;
		first.z += second.z;
		return first;
	}

	private static Quaternion ScaleQuaternion(Quaternion rotation, float multiplier)
	{
		rotation.w *= multiplier;
		rotation.x *= multiplier;
		rotation.y *= multiplier;
		rotation.z *= multiplier;
		return rotation;
	}

	private static float QuaternionMagnitude(Quaternion rotation)
	{
		return Mathf.Sqrt(Quaternion.Dot(rotation, rotation));
	}

	private static Quaternion NormalizeQuaternion(Quaternion rotation)
	{
		float num = QuaternionMagnitude(rotation);
		if (num > 0f)
		{
			return ScaleQuaternion(rotation, 1f / num);
		}
		UnityEngine.Debug.LogWarning("Cannot normalize a quaternion with zero magnitude.");
		return Quaternion.identity;
	}
}
[TrackColor(0.855f, 0.8623f, 0.87f)]
[TrackClipType(typeof(TransformTweenClip))]
[TrackBindingType(typeof(Transform))]
public class TransformTweenTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<TransformTweenMixerBehaviour>.Create(graph, inputCount);
	}

	public override void GatherProperties(PlayableDirector director, IPropertyCollector driver)
	{
		base.GatherProperties(director, driver);
	}
}
public class LaserController : MonoBehaviour
{
	public enum HandType
	{
		Left,
		Right
	}

	public delegate bool DelegeteGetInput();

	public delegate Vector2 DelegeteGetScrollDelta();

	public delegate void DelegeteVibrate(float length, float power);

	[Header("Hand")]
	[SerializeField]
	private HandType m_handType;

	[Header("Components")]
	[SerializeField]
	private GameObject cursorModel;

	[SerializeField]
	private LineRenderer laserRenderer;

	[Header("Parameters")]
	[SerializeField]
	private float laserCutLength;

	[SerializeField]
	private float laserMaxLength = 100f;

	[SerializeField]
	private float scaleStartDistance = 1f;

	[SerializeField]
	private float scalePerMeter = 0.5f;

	private bool _isLaserPointed = true;

	private bool _isVisibleLaser = true;

	private bool _isAutoDisappear = true;

	private bool _isPointered;

	private float _lineDefaultWidth = 1f;

	private float _currentLength;

	private Vector3 _pointerDefaultScale;

	public DelegeteGetInput InputTriggerDown { get; set; }

	public DelegeteGetInput InputTriggerUp { get; set; }

	public DelegeteGetScrollDelta InputScrollDelta { get; set; }

	public DelegeteVibrate InputVibrate { get; set; }

	private bool FlagVisibleLaser
	{
		get
		{
			if ((_isLaserPointed || !_isAutoDisappear) && _isVisibleLaser)
			{
				return base.enabled;
			}
			return false;
		}
	}

	public bool IsVisibleLaser
	{
		get
		{
			return _isVisibleLaser;
		}
		set
		{
			_isVisibleLaser = value;
			UpdateLaserVisible();
		}
	}

	public bool IsAutoDisappear
	{
		get
		{
			return _isAutoDisappear;
		}
		set
		{
			_isAutoDisappear = value;
		}
	}

	public float CurrentLength => _currentLength;

	public static LaserInputModule module => LaserInputModule.module;

	private void Awake()
	{
		_lineDefaultWidth = laserRenderer.endWidth;
		_pointerDefaultScale = cursorModel.transform.localScale;
	}

	private void Start()
	{
		CreateLaserPointer();
	}

	private void OnDisable()
	{
		AdjustLaserDistance(0f);
	}

	private void OnDestroy()
	{
		module.RemoveLaser(this);
	}

	protected void CreateLaserPointer()
	{
		module.AddLaser(this);
		AdjustLaserDistance(0f);
	}

	public void AdjustLaserDistance(float distance)
	{
		if (!(laserRenderer == null))
		{
			_isLaserPointed = distance > 0f;
			if (distance <= 0f || distance > laserMaxLength)
			{
				distance = laserMaxLength;
				_isPointered = false;
			}
			else
			{
				_isPointered = true;
			}
			UpdateLaserVisible();
			distance -= 0.01f;
			Vector3 position = new Vector3(0f, 0f, distance);
			float distanceScale = GetDistanceScale(distance);
			laserRenderer.SetPosition(1, position);
			laserRenderer.endWidth = distanceScale * _lineDefaultWidth;
			if (laserCutLength > 0f)
			{
				float num = Mathf.Max(laserCutLength, 0f);
				Vector3 position2 = new Vector3(0f, 0f, num);
				laserRenderer.SetPosition(0, position2);
				laserRenderer.startWidth = GetDistanceScale(num) * _lineDefaultWidth;
			}
			cursorModel.transform.localPosition = new Vector3(0f, 0f, distance);
			cursorModel.transform.localScale = _pointerDefaultScale * distanceScale;
			_currentLength = distance;
		}
	}

	private void UpdateLaserVisible()
	{
		bool flagVisibleLaser = FlagVisibleLaser;
		laserRenderer.enabled = flagVisibleLaser;
		cursorModel.SetActive(flagVisibleLaser && _isPointered);
	}

	private float GetDistanceScale(float distance)
	{
		if (distance < scaleStartDistance)
		{
			return 1f;
		}
		return 1f + (distance - scaleStartDistance) * scalePerMeter;
	}

	public bool GetTriggerDown()
	{
		return InputTriggerDown();
	}

	public bool GetTriggerUp()
	{
		return InputTriggerUp();
	}

	public Vector2 GetScrollDelta()
	{
		return Vector2.zero;
	}

	public void Vibrate(float length, float power)
	{
		InputVibrate(length, power);
	}

	public HandType GetHandType()
	{
		return m_handType;
	}
}
public class LaserInputModule : BaseInputModule
{
	public const int LAZER_MAX = 4;

	[SerializeField]
	private float _dragThreshould = 0.2f;

	public static LaserInputModule module;

	private Camera UICamera;

	private List<LaserController> lasers;

	private LaserPointerEventData[] pointEvents;

	public static Camera moduleCamera
	{
		get
		{
			if (module == null)
			{
				return null;
			}
			return module.UICamera;
		}
	}

	protected override void Awake()
	{
		base.Awake();
		module = this;
		lasers = new List<LaserController>();
		pointEvents = new LaserPointerEventData[4];
		MakeUICamera();
	}

	protected override void Start()
	{
		base.Start();
	}

	private void MakeUICamera()
	{
		GameObject gameObject = new GameObject("UICamera");
		UICamera = gameObject.AddComponent<Camera>();
		UICamera.transform.SetParent(base.transform);
		UICamera.nearClipPlane = 0.01f;
		UICamera.stereoTargetEye = StereoTargetEyeMask.None;
		UICamera.clearFlags = CameraClearFlags.Nothing;
		UICamera.allowDynamicResolution = false;
		UICamera.allowHDR = false;
		UICamera.allowMSAA = false;
		UICamera.enabled = false;
		gameObject.AddComponent<PhysicsRaycaster>();
	}

	public void SetUICameraMask(int mask)
	{
		UICamera.cullingMask = mask;
	}

	public void AddLaser(LaserController l)
	{
		lasers.Add(l);
	}

	public void RemoveLaser(LaserController l)
	{
		lasers.Remove(l);
	}

	private bool GUIRaycast(int index)
	{
		Vector3 vector;
		if (pointEvents[index] == null)
		{
			vector = Vector3.zero;
			pointEvents[index] = new LaserPointerEventData(base.eventSystem);
		}
		else
		{
			vector = pointEvents[index].dim3Position;
			pointEvents[index].Reset();
		}
		if (!lasers[index].enabled)
		{
			if (pointEvents[index].pointerCurrentRaycast.gameObject != null)
			{
				pointEvents[index].pointerCurrentRaycast = default(RaycastResult);
			}
			return false;
		}
		pointEvents[index].pointerId = index;
		pointEvents[index].laserController = lasers[index];
		UICamera.transform.position = lasers[index].gameObject.transform.position;
		UICamera.transform.forward = lasers[index].gameObject.transform.forward;
		pointEvents[index].delta = Vector2.zero;
		pointEvents[index].position = new Vector2(Screen.width / 2, Screen.height / 2);
		pointEvents[index].scrollDelta = Vector2.zero;
		base.eventSystem.RaycastAll(pointEvents[index], m_RaycastResultCache);
		pointEvents[index].pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache);
		m_RaycastResultCache.Clear();
		if (pointEvents[index].pointerCurrentRaycast.gameObject != null)
		{
			pointEvents[index].dim3Position = GetHitPosition(pointEvents[index]);
			pointEvents[index].delta = pointEvents[index].dim3Position - vector;
			return true;
		}
		return false;
	}

	private Vector3 GetHitPosition(PointerEventData pointerEvent)
	{
		Vector3 vector = UICamera.ScreenToWorldPoint(pointerEvent.position) + UICamera.transform.forward * pointerEvent.pointerCurrentRaycast.distance;
		return Quaternion.FromToRotation(pointerEvent.pointerCurrentRaycast.gameObject.transform.forward, Vector3.forward) * vector;
	}

	public override void Process()
	{
		for (int i = 0; i < lasers.Count; i++)
		{
			ClearSelection();
			bool num = GUIRaycast(i);
			HandlePointerExitAndEnter(newEnterTarget: num ? pointEvents[i].pointerCurrentRaycast.gameObject : null, currentPointerData: pointEvents[i]);
			if (!num)
			{
				lasers[i].AdjustLaserDistance(0f);
			}
			else if (pointEvents[i].pointerCurrentRaycast.distance > 0f)
			{
				lasers[i].AdjustLaserDistance(pointEvents[i].pointerCurrentRaycast.distance);
			}
			ProcessPress(i);
			ProcessDrag(i);
			ProcessScroll(i);
		}
	}

	private void ProcessPress(int index)
	{
		LaserPointerEventData laserPointerEventData = pointEvents[index];
		GameObject gameObject = laserPointerEventData.pointerCurrentRaycast.gameObject;
		if (IsPressDown(index))
		{
			laserPointerEventData.pressPosition = laserPointerEventData.position;
			laserPointerEventData.dim3PressPosition = laserPointerEventData.dim3Position;
			laserPointerEventData.pointerPressRaycast = laserPointerEventData.pointerCurrentRaycast;
			laserPointerEventData.pointerPress = null;
			laserPointerEventData.useDragThreshold = true;
			laserPointerEventData.delta = Vector2.zero;
			laserPointerEventData.dragging = false;
			if (gameObject != null)
			{
				laserPointerEventData.eligibleForClick = true;
				GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(gameObject, laserPointerEventData, ExecuteEvents.pointerDownHandler);
				if (gameObject2 == null)
				{
					gameObject2 = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				}
				if (gameObject2 != null)
				{
					float unscaledTime = Time.unscaledTime;
					if (gameObject2 == laserPointerEventData.lastPress)
					{
						if (unscaledTime - laserPointerEventData.clickTime < 0.3f)
						{
							laserPointerEventData.clickCount++;
						}
						else
						{
							laserPointerEventData.clickCount = 1;
						}
						laserPointerEventData.clickTime = unscaledTime;
					}
					else
					{
						laserPointerEventData.clickCount = 1;
					}
					laserPointerEventData.pointerPress = gameObject2;
					laserPointerEventData.rawPointerPress = gameObject;
					laserPointerEventData.clickTime = unscaledTime;
					Select(gameObject2);
				}
				laserPointerEventData.pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(gameObject);
				if (laserPointerEventData.pointerDrag != null)
				{
					ExecuteEvents.Execute(laserPointerEventData.pointerDrag, laserPointerEventData, ExecuteEvents.initializePotentialDrag);
				}
			}
		}
		if (IsPressUp(index))
		{
			ExecuteEvents.Execute(laserPointerEventData.pointerPress, laserPointerEventData, ExecuteEvents.pointerUpHandler);
			GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
			if (laserPointerEventData.pointerPress == eventHandler && laserPointerEventData.eligibleForClick)
			{
				ExecuteEvents.Execute(laserPointerEventData.pointerPress, laserPointerEventData, ExecuteEvents.pointerClickHandler);
			}
			else if (laserPointerEventData.pointerDrag != null)
			{
				ExecuteEvents.ExecuteHierarchy(gameObject, laserPointerEventData, ExecuteEvents.dropHandler);
			}
			laserPointerEventData.eligibleForClick = false;
			laserPointerEventData.pointerPress = null;
			laserPointerEventData.rawPointerPress = null;
			if (laserPointerEventData.pointerDrag != null && laserPointerEventData.dragging)
			{
				ExecuteEvents.Execute(laserPointerEventData.pointerDrag, laserPointerEventData, ExecuteEvents.endDragHandler);
			}
			laserPointerEventData.dragging = false;
			laserPointerEventData.pointerDrag = null;
			if (gameObject != laserPointerEventData.pointerEnter)
			{
				HandlePointerExitAndEnter(laserPointerEventData, null);
				HandlePointerExitAndEnter(laserPointerEventData, gameObject);
			}
		}
	}

	private bool IsPressDown(int index)
	{
		return lasers[index].GetTriggerDown();
	}

	private bool IsPressUp(int index)
	{
		return lasers[index].GetTriggerUp();
	}

	private void ProcessDrag(int index)
	{
		LaserPointerEventData laserPointerEventData = pointEvents[index];
		bool flag = laserPointerEventData.IsPointerMoving();
		if (flag && laserPointerEventData.pointerDrag != null && !laserPointerEventData.dragging && ShouldStartDrag(laserPointerEventData.dim3PressPosition, laserPointerEventData.dim3Position, _dragThreshould, laserPointerEventData.useDragThreshold))
		{
			ExecuteEvents.Execute(laserPointerEventData.pointerDrag, laserPointerEventData, ExecuteEvents.beginDragHandler);
			laserPointerEventData.dragging = true;
		}
		if (laserPointerEventData.dragging && flag && laserPointerEventData.pointerDrag != null)
		{
			if (laserPointerEventData.pointerPress != laserPointerEventData.pointerDrag)
			{
				ExecuteEvents.Execute(laserPointerEventData.pointerPress, laserPointerEventData, ExecuteEvents.pointerUpHandler);
				laserPointerEventData.eligibleForClick = false;
				laserPointerEventData.pointerPress = null;
				laserPointerEventData.rawPointerPress = null;
			}
			ExecuteEvents.Execute(laserPointerEventData.pointerDrag, laserPointerEventData, ExecuteEvents.dragHandler);
		}
	}

	private bool ShouldStartDrag(Vector3 pressPos, Vector3 currentPos, float threshold, bool useDragThreshold)
	{
		if (!useDragThreshold)
		{
			return true;
		}
		return (pressPos - currentPos).sqrMagnitude >= threshold * threshold;
	}

	private void ProcessScroll(int index)
	{
		LaserPointerEventData laserPointerEventData = pointEvents[index];
		if (!Mathf.Approximately((laserPointerEventData.scrollDelta = GetScrollDelta(index)).sqrMagnitude, 0f))
		{
			ExecuteEvents.ExecuteHierarchy(ExecuteEvents.GetEventHandler<IScrollHandler>(laserPointerEventData.pointerCurrentRaycast.gameObject), laserPointerEventData, ExecuteEvents.scrollHandler);
		}
	}

	private Vector2 GetScrollDelta(int index)
	{
		return Vector2.zero;
	}

	private void Vibrate(int index, float length, float power)
	{
		lasers[index].Vibrate(length, power);
	}

	public void ClearSelection()
	{
		if ((bool)base.eventSystem.currentSelectedGameObject)
		{
			base.eventSystem.SetSelectedGameObject(null);
		}
	}

	private void Select(GameObject go)
	{
		ClearSelection();
		if ((bool)ExecuteEvents.GetEventHandler<ISelectHandler>(go))
		{
			base.eventSystem.SetSelectedGameObject(go);
		}
	}
}
public class LaserTargetCanvas : MonoBehaviour
{
	private void Start()
	{
		if (LaserInputModule.moduleCamera == null)
		{
			StartCoroutine(ReserveAddUICamera());
		}
		else
		{
			GetComponent<Canvas>().worldCamera = LaserInputModule.moduleCamera;
		}
	}

	private IEnumerator ReserveAddUICamera()
	{
		yield return new WaitForEndOfFrame();
		while (LaserInputModule.moduleCamera == null)
		{
			yield return new WaitForSeconds(1f);
		}
		GetComponent<Canvas>().worldCamera = LaserInputModule.moduleCamera;
	}
}
public class EnableSwitch : MonoBehaviour
{
	public GameObject[] SwitchTargets;

	public bool SetActive(int target)
	{
		if (target < 0 || target >= SwitchTargets.Length)
		{
			return false;
		}
		for (int i = 0; i < SwitchTargets.Length; i++)
		{
			SwitchTargets[i].SetActive(value: false);
		}
		SwitchTargets[target].SetActive(value: true);
		return true;
	}
}
public class LipSyncDemo_SetCurrentTarget : MonoBehaviour
{
	public EnableSwitch[] SwitchTargets;

	private int targetSet;

	private void Start()
	{
		OVRMessenger.AddListener<OVRTouchpad.TouchEvent>("Touchpad", LocalTouchEventCallback);
		targetSet = 0;
		SwitchTargets[0].SetActive(0);
		SwitchTargets[1].SetActive(0);
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Alpha1))
		{
			targetSet = 0;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha2))
		{
			targetSet = 1;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha3))
		{
			targetSet = 2;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha4))
		{
			targetSet = 3;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha5))
		{
			targetSet = 4;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha6))
		{
			targetSet = 5;
			SetCurrentTarget();
		}
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			UnityEngine.Application.Quit();
		}
	}

	private void SetCurrentTarget()
	{
		switch (targetSet)
		{
		case 0:
			SwitchTargets[0].SetActive(0);
			SwitchTargets[1].SetActive(0);
			break;
		case 1:
			SwitchTargets[0].SetActive(0);
			SwitchTargets[1].SetActive(1);
			break;
		case 2:
			SwitchTargets[0].SetActive(1);
			SwitchTargets[1].SetActive(2);
			break;
		case 3:
			SwitchTargets[0].SetActive(1);
			SwitchTargets[1].SetActive(3);
			break;
		case 4:
			SwitchTargets[0].SetActive(2);
			SwitchTargets[1].SetActive(4);
			break;
		case 5:
			SwitchTargets[0].SetActive(2);
			SwitchTargets[1].SetActive(5);
			break;
		}
	}

	private void LocalTouchEventCallback(OVRTouchpad.TouchEvent touchEvent)
	{
		switch (touchEvent)
		{
		case OVRTouchpad.TouchEvent.Left:
			targetSet--;
			if (targetSet < 0)
			{
				targetSet = 3;
			}
			SetCurrentTarget();
			break;
		case OVRTouchpad.TouchEvent.Right:
			targetSet++;
			if (targetSet > 3)
			{
				targetSet = 0;
			}
			SetCurrentTarget();
			break;
		}
	}
}
public class OVRLipSyncDebugConsole : MonoBehaviour
{
	public ArrayList messages = new ArrayList();

	public int maxMessages = 15;

	public Text textMsg;

	private static OVRLipSyncDebugConsole s_Instance;

	private bool clearTimeoutOn;

	private float clearTimeout;

	public static OVRLipSyncDebugConsole instance
	{
		get
		{
			if (s_Instance == null)
			{
				s_Instance = UnityEngine.Object.FindObjectOfType(typeof(OVRLipSyncDebugConsole)) as OVRLipSyncDebugConsole;
				if (s_Instance == null)
				{
					GameObject obj = new GameObject();
					obj.AddComponent<OVRLipSyncDebugConsole>();
					obj.name = "OVRLipSyncDebugConsole";
					s_Instance = UnityEngine.Object.FindObjectOfType(typeof(OVRLipSyncDebugConsole)) as OVRLipSyncDebugConsole;
				}
			}
			return s_Instance;
		}
	}

	private void Awake()
	{
		s_Instance = this;
		Init();
	}

	private void Update()
	{
		if (clearTimeoutOn)
		{
			clearTimeout -= Time.deltaTime;
			if (clearTimeout < 0f)
			{
				Clear();
				clearTimeout = 0f;
				clearTimeoutOn = false;
			}
		}
	}

	public void Init()
	{
		if (textMsg == null)
		{
			UnityEngine.Debug.LogWarning("DebugConsole Init WARNING::UI text not set. Will not be able to display anything.");
		}
		Clear();
	}

	public static void Log(string message)
	{
		instance.AddMessage(message, Color.white);
	}

	public static void Log(string message, Color color)
	{
		instance.AddMessage(message, color);
	}

	public static void Clear()
	{
		instance.ClearMessages();
	}

	public static void ClearTimeout(float timeToClear)
	{
		instance.SetClearTimeout(timeToClear);
	}

	public void AddMessage(string message, Color color)
	{
		messages.Add(message);
		if (textMsg != null)
		{
			textMsg.color = color;
		}
		Display();
	}

	public void ClearMessages()
	{
		messages.Clear();
		Display();
	}

	public void SetClearTimeout(float timeout)
	{
		clearTimeout = timeout;
		clearTimeoutOn = true;
	}

	private void Prune()
	{
		if (messages.Count > maxMessages)
		{
			int count = ((messages.Count > 0) ? (messages.Count - maxMessages) : 0);
			messages.RemoveRange(0, count);
		}
	}

	private void Display()
	{
		if (messages.Count > maxMessages)
		{
			Prune();
		}
		if (textMsg != null)
		{
			textMsg.text = "";
			for (int i = 0; i < messages.Count; i++)
			{
				textMsg.text += (string)messages[i];
				textMsg.text += "\n";
			}
		}
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncTestAudio : MonoBehaviour
{
	public AudioSource audioSource;

	private void Start()
	{
		if (!audioSource)
		{
			audioSource = GetComponent<AudioSource>();
		}
		if ((bool)audioSource)
		{
			string dataPath = UnityEngine.Application.dataPath;
			dataPath += "/../";
			dataPath += "TestViseme.wav";
			WWW wWW = new WWW("file:///" + dataPath);
			while (!wWW.isDone)
			{
				UnityEngine.Debug.Log(wWW.progress);
			}
			if (wWW.GetAudioClip() != null)
			{
				audioSource.clip = wWW.GetAudioClip();
				audioSource.loop = true;
				audioSource.mute = false;
				audioSource.Play();
			}
		}
	}
}
public delegate void OVRCallback();
public delegate void OVRCallback<T>(T arg1);
public delegate void OVRCallback<T, U>(T arg1, U arg2);
public delegate void OVRCallback<T, U, V>(T arg1, U arg2, V arg3);
internal static class OVRMessenger
{
	public class BroadcastException : Exception
	{
		public BroadcastException(string msg)
			: base(msg)
		{
		}
	}

	public class ListenerException : Exception
	{
		public ListenerException(string msg)
			: base(msg)
		{
		}
	}

	private static MessengerHelper messengerHelper = new GameObject("MessengerHelper").AddComponent<MessengerHelper>();

	public static Dictionary<string, Delegate> eventTable = new Dictionary<string, Delegate>();

	public static List<string> permanentMessages = new List<string>();

	public static void MarkAsPermanent(string eventType)
	{
		permanentMessages.Add(eventType);
	}

	public static void Cleanup()
	{
		List<string> list = new List<string>();
		foreach (KeyValuePair<string, Delegate> item in eventTable)
		{
			bool flag = false;
			foreach (string permanentMessage in permanentMessages)
			{
				if (item.Key == permanentMessage)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				list.Add(item.Key);
			}
		}
		foreach (string item2 in list)
		{
			eventTable.Remove(item2);
		}
	}

	public static void PrintEventTable()
	{
		UnityEngine.Debug.Log("\t\t\t=== MESSENGER PrintEventTable ===");
		foreach (KeyValuePair<string, Delegate> item in eventTable)
		{
			UnityEngine.Debug.Log("\t\t\t" + item.Key + "\t\t" + item.Value);
		}
		UnityEngine.Debug.Log("\n");
	}

	public static void OnListenerAdding(string eventType, Delegate listenerBeingAdded)
	{
		if (!eventTable.ContainsKey(eventType))
		{
			eventTable.Add(eventType, null);
		}
		Delegate @delegate = eventTable[eventType];
		if ((object)@delegate != null && @delegate.GetType() != listenerBeingAdded.GetType())
		{
			throw new ListenerException($"Attempting to add listener with inconsistent signature for event type {eventType}. Current listeners have type {@delegate.GetType().Name} and listener being added has type {listenerBeingAdded.GetType().Name}");
		}
	}

	public static void OnListenerRemoving(string eventType, Delegate listenerBeingRemoved)
	{
		if (eventTable.ContainsKey(eventType))
		{
			Delegate @delegate = eventTable[eventType];
			if ((object)@delegate == null)
			{
				throw new ListenerException($"Attempting to remove listener with for event type \"{eventType}\" but current listener is null.");
			}
			if (@delegate.GetType() != listenerBeingRemoved.GetType())
			{
				throw new ListenerException($"Attempting to remove listener with inconsistent signature for event type {eventType}. Current listeners have type {@delegate.GetType().Name} and listener being removed has type {listenerBeingRemoved.GetType().Name}");
			}
			return;
		}
		throw new ListenerException($"Attempting to remove listener for type \"{eventType}\" but Messenger doesn't know about this event type.");
	}

	public static void OnListenerRemoved(string eventType)
	{
		if ((object)eventTable[eventType] == null)
		{
			eventTable.Remove(eventType);
		}
	}

	public static void OnBroadcasting(string eventType)
	{
	}

	public static BroadcastException CreateBroadcastSignatureException(string eventType)
	{
		return new BroadcastException($"Broadcasting message \"{eventType}\" but listeners have a different signature than the broadcaster.");
	}

	public static void AddListener(string eventType, OVRCallback handler)
	{
		OnListenerAdding(eventType, handler);
		eventTable[eventType] = (OVRCallback)Delegate.Combine((OVRCallback)eventTable[eventType], handler);
	}

	public static void AddListener<T>(string eventType, OVRCallback<T> handler)
	{
		OnListenerAdding(eventType, handler);
		eventTable[eventType] = (OVRCallback<T>)Delegate.Combine((OVRCallback<T>)eventTable[eventType], handler);
	}

	public static void AddListener<T, U>(string eventType, OVRCallback<T, U> handler)
	{
		OnListenerAdding(eventType, handler);
		eventTable[eventType] = (OVRCallback<T, U>)Delegate.Combine((OVRCallback<T, U>)eventTable[eventType], handler);
	}

	public static void AddListener<T, U, V>(string eventType, OVRCallback<T, U, V> handler)
	{
		OnListenerAdding(eventType, handler);
		eventTable[eventType] = (OVRCallback<T, U, V>)Delegate.Combine((OVRCallback<T, U, V>)eventTable[eventType], handler);
	}

	public static void RemoveListener(string eventType, OVRCallback handler)
	{
		OnListenerRemoving(eventType, handler);
		eventTable[eventType] = (OVRCallback)Delegate.Remove((OVRCallback)eventTable[eventType], handler);
		OnListenerRemoved(eventType);
	}

	public static void RemoveListener<T>(string eventType, OVRCallback<T> handler)
	{
		OnListenerRemoving(eventType, handler);
		eventTable[eventType] = (OVRCallback<T>)Delegate.Remove((OVRCallback<T>)eventTable[eventType], handler);
		OnListenerRemoved(eventType);
	}

	public static void RemoveListener<T, U>(string eventType, OVRCallback<T, U> handler)
	{
		OnListenerRemoving(eventType, handler);
		eventTable[eventType] = (OVRCallback<T, U>)Delegate.Remove((OVRCallback<T, U>)eventTable[eventType], handler);
		OnListenerRemoved(eventType);
	}

	public static void RemoveListener<T, U, V>(string eventType, OVRCallback<T, U, V> handler)
	{
		OnListenerRemoving(eventType, handler);
		eventTable[eventType] = (OVRCallback<T, U, V>)Delegate.Remove((OVRCallback<T, U, V>)eventTable[eventType], handler);
		OnListenerRemoved(eventType);
	}

	public static void Broadcast(string eventType)
	{
		OnBroadcasting(eventType);
		if (eventTable.TryGetValue(eventType, out var value))
		{
			if (!(value is OVRCallback oVRCallback))
			{
				throw CreateBroadcastSignatureException(eventType);
			}
			oVRCallback();
		}
	}

	public static void Broadcast<T>(string eventType, T arg1)
	{
		OnBroadcasting(eventType);
		if (eventTable.TryGetValue(eventType, out var value))
		{
			if (!(value is OVRCallback<T> oVRCallback))
			{
				throw CreateBroadcastSignatureException(eventType);
			}
			oVRCallback(arg1);
		}
	}

	public static void Broadcast<T, U>(string eventType, T arg1, U arg2)
	{
		OnBroadcasting(eventType);
		if (eventTable.TryGetValue(eventType, out var value))
		{
			if (!(value is OVRCallback<T, U> oVRCallback))
			{
				throw CreateBroadcastSignatureException(eventType);
			}
			oVRCallback(arg1, arg2);
		}
	}

	public static void Broadcast<T, U, V>(string eventType, T arg1, U arg2, V arg3)
	{
		OnBroadcasting(eventType);
		if (eventTable.TryGetValue(eventType, out var value))
		{
			if (!(value is OVRCallback<T, U, V> oVRCallback))
			{
				throw CreateBroadcastSignatureException(eventType);
			}
			oVRCallback(arg1, arg2, arg3);
		}
	}
}
public sealed class MessengerHelper : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	public void OnDisable()
	{
		OVRMessenger.Cleanup();
	}
}
internal static class OVRTouchpad
{
	public enum TouchEvent
	{
		SingleTap,
		DoubleTap,
		Left,
		Right,
		Up,
		Down
	}

	private static Vector3 moveAmountMouse;

	private static float minMovMagnitudeMouse = 25f;

	private static OVRTouchpadHelper touchpadHelper = new GameObject("OVRTouchpadHelper").AddComponent<OVRTouchpadHelper>();

	public static void Create()
	{
	}

	public static void Update()
	{
		if (Input.GetMouseButtonDown(0))
		{
			moveAmountMouse = Input.mousePosition;
		}
		else if (Input.GetMouseButtonUp(0))
		{
			moveAmountMouse -= Input.mousePosition;
			HandleInputMouse(ref moveAmountMouse);
		}
	}

	public static void OnDisable()
	{
	}

	private static void HandleInputMouse(ref Vector3 move)
	{
		if (move.magnitude < minMovMagnitudeMouse)
		{
			OVRMessenger.Broadcast("Touchpad", TouchEvent.SingleTap);
			return;
		}
		move.Normalize();
		if (Mathf.Abs(move.x) > Mathf.Abs(move.y))
		{
			if (move.x > 0f)
			{
				OVRMessenger.Broadcast("Touchpad", TouchEvent.Left);
			}
			else
			{
				OVRMessenger.Broadcast("Touchpad", TouchEvent.Right);
			}
		}
		else if (move.y > 0f)
		{
			OVRMessenger.Broadcast("Touchpad", TouchEvent.Down);
		}
		else
		{
			OVRMessenger.Broadcast("Touchpad", TouchEvent.Up);
		}
	}
}
public sealed class OVRTouchpadHelper : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void Start()
	{
		OVRMessenger.AddListener<OVRTouchpad.TouchEvent>("Touchpad", LocalTouchEventCallback);
	}

	private void Update()
	{
		OVRTouchpad.Update();
	}

	public void OnDisable()
	{
		OVRTouchpad.OnDisable();
	}

	private void LocalTouchEventCallback(OVRTouchpad.TouchEvent touchEvent)
	{
		switch (touchEvent)
		{
		}
	}
}
public class OVRLipSync : MonoBehaviour
{
	public enum Result
	{
		Success = 0,
		Unknown = -2200,
		CannotCreateContext = -2201,
		InvalidParam = -2202,
		BadSampleRate = -2203,
		MissingDLL = -2204,
		BadVersion = -2205,
		UndefinedFunction = -2206
	}

	public enum Viseme
	{
		sil,
		PP,
		FF,
		TH,
		DD,
		kk,
		CH,
		SS,
		nn,
		RR,
		aa,
		E,
		ih,
		oh,
		ou
	}

	public enum Flags
	{
		None,
		DelayCompensateAudio
	}

	public enum Signals
	{
		VisemeOn,
		VisemeOff,
		VisemeAmount,
		VisemeSmoothing
	}

	public enum ContextProviders
	{
		Main,
		Other
	}

	[Serializable]
	public class Frame
	{
		public int frameNumber;

		public int frameDelay;

		public float[] Visemes = new float[VisemeCount];

		public void CopyInput(Frame input)
		{
			if (input != null)
			{
				frameNumber = input.frameNumber;
				frameDelay = input.frameDelay;
				input.Visemes.CopyTo(Visemes, 0);
			}
		}
	}

	public static readonly int VisemeCount = Enum.GetNames(typeof(Viseme)).Length;

	public static readonly int SignalCount = Enum.GetNames(typeof(Signals)).Length;

	public const string strOVRLS = "OVRLipSync";

	private static Result sInitialized = Result.Unknown;

	public static OVRLipSync sInstance = null;

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_Initialize(int samplerate, int buffersize);

	[DllImport("OVRLipSync")]
	private static extern void ovrLipSyncDll_Shutdown();

	[DllImport("OVRLipSync")]
	private static extern IntPtr ovrLipSyncDll_GetVersion(ref int Major, ref int Minor, ref int Patch);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_CreateContext(ref uint context, ContextProviders provider);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_DestroyContext(uint context);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_ResetContext(uint context);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_SendSignal(uint context, Signals signal, int arg1, int arg2);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_ProcessFrame(uint context, float[] audioBuffer, Flags flags, ref int frameNumber, ref int frameDelay, float[] visemes, int visemeCount);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_ProcessFrameInterleaved(uint context, float[] audioBuffer, Flags flags, ref int frameNumber, ref int frameDelay, float[] visemes, int visemeCount);

	private void Awake()
	{
		if (sInstance == null)
		{
			sInstance = this;
			int outputSampleRate = AudioSettings.outputSampleRate;
			AudioSettings.GetDSPBufferSize(out var bufferLength, out var _);
			UnityEngine.Debug.LogWarning($"OvrLipSync Awake: Queried SampleRate: {outputSampleRate:F0} BufferSize: {bufferLength:F0}");
			sInitialized = Initialize(outputSampleRate, bufferLength);
			if (sInitialized != 0)
			{
				UnityEngine.Debug.LogWarning($"OvrLipSync Awake: Failed to init Speech Rec library");
			}
		}
		else
		{
			UnityEngine.Debug.LogWarning($"OVRLipSync Awake: Only one instance of OVRPLipSync can exist in the scene.");
		}
	}

	private void OnDestroy()
	{
		if (sInstance != this)
		{
			UnityEngine.Debug.LogWarning("OVRLipSync OnDestroy: This is not the correct OVRLipSync instance.");
		}
	}

	public static Result Initialize(int sampleRate, int bufferSize)
	{
		sInitialized = (Result)ovrLipSyncDll_Initialize(sampleRate, bufferSize);
		return sInitialized;
	}

	public static void Shutdown()
	{
		ovrLipSyncDll_Shutdown();
		sInitialized = Result.Unknown;
	}

	public static Result IsInitialized()
	{
		return sInitialized;
	}

	public static Result CreateContext(ref uint context, ContextProviders provider)
	{
		if (IsInitialized() != 0)
		{
			return Result.CannotCreateContext;
		}
		return (Result)ovrLipSyncDll_CreateContext(ref context, provider);
	}

	public static Result DestroyContext(uint context)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_DestroyContext(context);
	}

	public static Result ResetContext(uint context)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_ResetContext(context);
	}

	public static Result SendSignal(uint context, Signals signal, int arg1, int arg2)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_SendSignal(context, signal, arg1, arg2);
	}

	public static Result ProcessFrame(uint context, float[] audioBuffer, Flags flags, Frame frame)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_ProcessFrame(context, audioBuffer, flags, ref frame.frameNumber, ref frame.frameDelay, frame.Visemes, frame.Visemes.Length);
	}

	public static Result ProcessFrameInterleaved(uint context, float[] audioBuffer, Flags flags, Frame frame)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_ProcessFrameInterleaved(context, audioBuffer, flags, ref frame.frameNumber, ref frame.frameDelay, frame.Visemes, frame.Visemes.Length);
	}
}
public class OVRLipSyncContext : OVRLipSyncContextBase
{
	public float gain = 1f;

	public bool audioMute;

	public KeyCode loopback = KeyCode.L;

	public KeyCode debugVisemes = KeyCode.D;

	public bool showVisemes;

	public bool delayCompensate;

	private OVRLipSync.Frame debugFrame = new OVRLipSync.Frame();

	private float debugFrameTimer;

	private float debugFrameTimeoutValue = 0.1f;

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnAudioFilterRead(float[] data, int channels)
	{
		if (OVRLipSync.IsInitialized() != 0)
		{
			return;
		}
		for (int i = 0; i < data.Length; i++)
		{
			data[i] *= gain;
		}
		lock (this)
		{
			if (base.Context != 0)
			{
				OVRLipSync.Flags flags = OVRLipSync.Flags.None;
				if (delayCompensate)
				{
					flags |= OVRLipSync.Flags.DelayCompensateAudio;
				}
				OVRLipSync.Frame frame = base.Frame;
				OVRLipSync.ProcessFrameInterleaved(base.Context, data, flags, frame);
			}
		}
		if (audioMute)
		{
			for (int j = 0; j < data.Length; j++)
			{
				data[j] *= 0f;
			}
		}
	}

	private void DebugShowVisemes()
	{
		if (!showVisemes)
		{
			return;
		}
		debugFrameTimer -= Time.deltaTime;
		if (debugFrameTimer < 0f)
		{
			debugFrameTimer += debugFrameTimeoutValue;
			debugFrame.CopyInput(base.Frame);
		}
		string text = "";
		for (int i = 0; i < debugFrame.Visemes.Length; i++)
		{
			if (i < 10)
			{
				text += "0";
			}
			text += i;
			text += ":";
			int num = (int)(50f * debugFrame.Visemes[i]);
			for (int j = 0; j < num; j++)
			{
				text += "*";
			}
			text += "\n";
		}
		OVRLipSyncDebugConsole.Clear();
		OVRLipSyncDebugConsole.Log(text);
	}
}
public class OVRLipSyncContextBase : MonoBehaviour
{
	public AudioSource audioSource;

	public OVRLipSync.ContextProviders provider;

	private OVRLipSync.Frame frame = new OVRLipSync.Frame();

	private uint context;

	public int Smoothing
	{
		set
		{
			OVRLipSync.SendSignal(context, OVRLipSync.Signals.VisemeSmoothing, value, 0);
		}
	}

	public uint Context => context;

	protected OVRLipSync.Frame Frame => frame;

	private void Awake()
	{
		lock (this)
		{
			if (context == 0 && OVRLipSync.CreateContext(ref context, provider) != 0)
			{
				UnityEngine.Debug.Log("OVRPhonemeContext.Start ERROR: Could not create Phoneme context.");
			}
		}
	}

	private void OnDestroy()
	{
		lock (this)
		{
			if (context != 0 && OVRLipSync.DestroyContext(context) != 0)
			{
				UnityEngine.Debug.Log("OVRPhonemeContext.OnDestroy ERROR: Could not delete Phoneme context.");
			}
		}
	}

	public OVRLipSync.Frame GetCurrentPhonemeFrame()
	{
		return frame;
	}

	public void SetVisemeBlend(int viseme, int amount)
	{
		OVRLipSync.SendSignal(context, OVRLipSync.Signals.VisemeAmount, viseme, amount);
	}

	public OVRLipSync.Result ResetContext()
	{
		return OVRLipSync.ResetContext(context);
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncContextCanned : OVRLipSyncContextBase
{
	public OVRLipSyncSequence currentSequence;

	private void Start()
	{
	}

	private void Update()
	{
		if (audioSource.isPlaying && currentSequence != null)
		{
			OVRLipSync.Frame frameAtTime = currentSequence.GetFrameAtTime(audioSource.time);
			base.Frame.CopyInput(frameAtTime);
		}
	}
}
public class OVRLipSyncContextMorphTarget : MonoBehaviour
{
	public SkinnedMeshRenderer skinnedMeshRenderer;

	public int[] VisemeToBlendTargets = new int[OVRLipSync.VisemeCount];

	public bool enableVisemeSignals;

	public int[] KeySendVisemeSignal = new int[10];

	public int SmoothAmount = 100;

	[SerializeField]
	private OVRLipSyncContextBase lipsyncContext;

	private void Start()
	{
		if (skinnedMeshRenderer == null)
		{
			UnityEngine.Debug.Log("LipSyncContextMorphTarget.Start WARNING: Please set required public components!");
			return;
		}
		if (lipsyncContext == null)
		{
			lipsyncContext = GetComponent<OVRLipSyncContextBase>();
		}
		if (lipsyncContext == null)
		{
			UnityEngine.Debug.Log("LipSyncContextMorphTarget.Start WARNING: No phoneme context component set to object");
		}
		lipsyncContext.Smoothing = SmoothAmount;
	}

	private void LateUpdate()
	{
		if (lipsyncContext != null && skinnedMeshRenderer != null)
		{
			OVRLipSync.Frame currentPhonemeFrame = lipsyncContext.GetCurrentPhonemeFrame();
			if (currentPhonemeFrame != null)
			{
				SetVisemeToMorphTarget(currentPhonemeFrame);
			}
			CheckForKeys();
		}
	}

	private void CheckForKeys()
	{
		if (enableVisemeSignals)
		{
			CheckVisemeKey(KeyCode.Alpha1, 0, 100);
			CheckVisemeKey(KeyCode.Alpha2, 1, 100);
			CheckVisemeKey(KeyCode.Alpha3, 2, 100);
			CheckVisemeKey(KeyCode.Alpha4, 3, 100);
			CheckVisemeKey(KeyCode.Alpha5, 4, 100);
			CheckVisemeKey(KeyCode.Alpha6, 5, 100);
			CheckVisemeKey(KeyCode.Alpha7, 6, 100);
			CheckVisemeKey(KeyCode.Alpha8, 7, 100);
			CheckVisemeKey(KeyCode.Alpha9, 8, 100);
			CheckVisemeKey(KeyCode.Alpha0, 9, 100);
			CheckVisemeKey(KeyCode.Q, 10, 100);
			CheckVisemeKey(KeyCode.W, 11, 100);
			CheckVisemeKey(KeyCode.E, 12, 100);
			CheckVisemeKey(KeyCode.R, 13, 100);
			CheckVisemeKey(KeyCode.T, 14, 100);
		}
	}

	private void SetVisemeToMorphTarget(OVRLipSync.Frame frame)
	{
		for (int i = 0; i < VisemeToBlendTargets.Length; i++)
		{
			if (VisemeToBlendTargets[i] != -1)
			{
				skinnedMeshRenderer.SetBlendShapeWeight(VisemeToBlendTargets[i], frame.Visemes[i] * 100f);
			}
		}
	}

	private void CheckVisemeKey(KeyCode key, int viseme, int amount)
	{
		if (Input.GetKeyDown(key))
		{
			lipsyncContext.SetVisemeBlend(KeySendVisemeSignal[viseme], amount);
		}
		if (Input.GetKeyUp(key))
		{
			lipsyncContext.SetVisemeBlend(KeySendVisemeSignal[viseme], 0);
		}
	}
}
public class OVRLipSyncContextTextureFlip : MonoBehaviour
{
	public Material material;

	public Texture[] Textures = new Texture[OVRLipSync.VisemeCount];

	public float smoothing;

	private OVRLipSyncContextBase lipsyncContext;

	private OVRLipSync.Frame oldFrame = new OVRLipSync.Frame();

	private void Start()
	{
		lipsyncContext = GetComponent<OVRLipSyncContextBase>();
		if (lipsyncContext == null)
		{
			UnityEngine.Debug.Log("LipSyncContextTextureFlip.Start WARNING: No lip sync context component set to object");
		}
	}

	private void Update()
	{
		if (!(lipsyncContext != null) || !(material != null))
		{
			return;
		}
		OVRLipSync.Frame currentPhonemeFrame = lipsyncContext.GetCurrentPhonemeFrame();
		if (currentPhonemeFrame != null)
		{
			for (int i = 0; i < currentPhonemeFrame.Visemes.Length; i++)
			{
				oldFrame.Visemes[i] = oldFrame.Visemes[i] * smoothing + currentPhonemeFrame.Visemes[i] * (1f - smoothing);
			}
			SetVisemeToTexture();
		}
	}

	private void SetVisemeToTexture()
	{
		int num = -1;
		float num2 = 0f;
		for (int i = 0; i < oldFrame.Visemes.Length; i++)
		{
			if (oldFrame.Visemes[i] > num2)
			{
				num = i;
				num2 = oldFrame.Visemes[i];
			}
		}
		if (num != -1 && num < Textures.Length)
		{
			Texture texture = Textures[num];
			if (texture != null)
			{
				material.SetTexture("_MainTex", texture);
			}
		}
	}
}
[Serializable]
public class OVRLipSyncSequence : ScriptableObject
{
	public List<OVRLipSync.Frame> entries = new List<OVRLipSync.Frame>();

	public float length;

	public OVRLipSync.Frame GetFrameAtTime(float time)
	{
		OVRLipSync.Frame result = null;
		if (time < length && entries.Count > 0)
		{
			float num = time / length;
			result = entries[(int)((float)entries.Count * num)];
		}
		return result;
	}
}
public class AsImageSample : MonoBehaviour
{
	[OnDragDrop(order = 1)]
	[HelpBox("Drop image here.", below = false, messageType = MessageType.None)]
	[AsImage]
	public Texture2D asImage;
}
public class BoxSample : MonoBehaviour
{
	[Box(0f, 0f, 0f, 0f)]
	[StackableField]
	public string box1 = "Simple Box";

	[Box(4f, 4f, 4f, 4f)]
	[StackableField]
	public string box2 = "Padding 4";

	[Box(-4f, -4f, -4f, -4f)]
	[StackableField]
	public string box3 = "Padding -4";

	[Box(2f, 2f, 2f, 2f, style = "ShurikenEffectBg")]
	[StackableField]
	public string box4 = "Style";
}
public class ButtonsSample : MonoBehaviour
{
	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[Buttons(0f, 0f, 0f, 0f, titles = "Button1,Button2,Button3", actions = "Button1,Button2,Button3", below = true)]
	[StackableField]
	public string button1;

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 2)]
	[IconSize(16, 16, order = 1)]
	[Buttons(0f, 0f, 0f, 0f, titles = "GameObject,Prefab,Scene", icons = "GameObject Icon,PrefabNormal Icon,SceneAsset Icon", actions = "Button1,Button2,Button3", alignment = TextAlignment.Center)]
	[StackableField]
	public string button2;

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[SideButtons(0f, 0f, 0f, 0f, titles = "+,-", actions = "Inc,Dec", onLeft = true, height = 1f)]
	[StackableField]
	public int num1;

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[SideButtons(0f, 0f, 0f, 0f, titles = ",", icons = "ol plus,ol minus", actions = "Inc,Dec")]
	[StackableField]
	public int num2;

	public void Button1()
	{
		button1 = (button2 = "GameObject");
	}

	public void Button2()
	{
		button1 = (button2 = "Prefab");
	}

	public void Button3()
	{
		button1 = (button2 = "Scene");
	}

	public void Inc()
	{
		num2 = ++num1;
	}

	public void Dec()
	{
		num2 = --num1;
	}
}
public class ColorSample : MonoBehaviour
{
	[Color(1f, 0.5f, 0.5f, 1f)]
	[StackableField]
	public string color1 = "Simple Color";

	[Color(0.5f, 0.5f, 1f, 1f, order = 1)]
	[Box(4f, 4f, 4f, 4f)]
	[StackableField]
	public string color2 = "Colored Box";
}
public class DrawerSample : MonoBehaviour
{
	[Box(0f, 0f, 0f, 0f)]
	[StackableField]
	public string box1 = "Simple Box";

	[TextField(placeHolder = "Please enter the text.")]
	public string textField;

	[TextField(3, placeHolder = "Please enter the text.")]
	public string textField2;

	[Color(1f, 0.5f, 0.5f, 1f)]
	[Slider(0f, 100f)]
	public int slider;

	[Color(0.5f, 0.5f, 1f, 1f)]
	[RangeSlider(0f, 100f)]
	public Vector2 rangeSlider = new Vector2(25f, 50f);

	[ToggleLeft]
	public bool toggleLeft;

	[Expandable]
	public string expandable;

	[LabelOnly]
	public string labelOnly;

	[Label(icon = "GameObject Icon")]
	[AsString(label = false, icon = true)]
	public string asString = "As String Sample";

	[ColorField(showEyedropper = false)]
	public Color color;

	[CurveField(1f, 0f, 1f, -1f, -1f, 1f, 1f)]
	public AnimationCurve curve;

	[ProgressBar(100f, decimalPlaces = 0)]
	public int progress = 53;

	[ProgressBar(22f, 88f, showLabel = false, prefix = true)]
	public int progress2 = 39;
}
public class EnableIfSample : MonoBehaviour
{
	public bool enable1;

	public int enable2;

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[EnableIf("$enable1")]
	[StackableField]
	public string enableIf1 = "Enable if Enable1 is true";

	[EnableIf("$enable1", inverted = true)]
	[StackableField]
	public string enableIf1b = "Enable if Enable1 is false";

	[EnableIf("#Active")]
	[StackableField]
	public string enableIf2 = "Enable if Enable2 is positive";

	[EnableIf("#Active", order = 1)]
	[EnableIf("$enable1", disable = false)]
	[StackableField]
	public string enableIf3 = "EnableIf1 or EnableIf2";

	[EnableIf("#Active", order = 1)]
	[EnableIf("$enable1", enable = false)]
	[StackableField]
	public string enableIf4 = "EnableIf1 and EnableIf2";

	public bool Active()
	{
		return enable2 >= 0;
	}
}
public class EnumButtonSample : MonoBehaviour
{
	public enum Alignment
	{
		Left,
		Center,
		Right
	}

	public enum ColorMask
	{
		R = 1,
		G = 2,
		B = 4,
		A = 8,
		RGB = 7,
		RGBA = 15
	}

	public enum Axis
	{
		X = 1,
		Y = 2,
		Z = 4
	}

	[HorizontalGroup("Main", false, "key", new float[] { -1f, 80f }, order = 1)]
	[Group("Left", 3, new float[] { })]
	[EnumButton]
	public Alignment alignment;

	[InGroup("Left")]
	[EnumButton(exclude = "RGB,RGBA")]
	public ColorMask color;

	[InGroup("Left")]
	[EnumMaskButton(all = false, column = 3)]
	public ColorMask colorMask;

	[InGroup("Left")]
	[EnumMaskButton(styles = "toggle")]
	public Axis axis;

	[InGroup("Main", order = 1)]
	[Label(0f)]
	[EnumButton(column = 1, vOffset = -3)]
	public EventModifiers key;
}
public class EnumPopupSample : MonoBehaviour
{
	public enum Alignment
	{
		Left,
		Center,
		Right
	}

	public enum ColorMask
	{
		R = 1,
		G = 2,
		B = 4,
		A = 8,
		RGB = 7,
		RGBA = 15
	}

	public enum Axis
	{
		X = 1,
		Y = 2,
		Z = 4
	}

	[Heading(0f, 0f, 0f, 0f, title = "Enum Popup")]
	[EnumPopup]
	public Alignment alignment;

	[EnumPopup(exclude = "RGB,RGBA", placeHolder = "Please select a channel.")]
	public ColorMask color1;

	[EnumPopup(names = "Red,Green,Blue,Alpha", placeHolder = "Please select a channel.")]
	public ColorMask color2;

	[EnumPopup(placeHolder = "Please select an axis.")]
	public Axis axis;

	[EnumPopup]
	public EventModifiers key1;

	[EnumPopup(exclude = "None", placeHolder = "Please select modifiers key.")]
	public EventModifiers key2;

	[Heading(0f, 0f, 8f, 0f, title = "Enum Mask Popup")]
	[EnumMaskPopup]
	public ColorMask mask1;

	[EnumMaskPopup(showAll = false, showCombined = true)]
	public ColorMask mask2;

	[EnumMaskPopup(names = "Shift,Alt,Ctrl,Command")]
	public EventModifiers key3;

	[Heading(0f, 0f, 8f, 0f)]
	[DropdownValue("#values", names = "#names", placeHolder = "Please select value.")]
	public int dropdownValue;

	[DropdownMask("#names", "#values", sortCombined = false, showCombined = true)]
	public int dropdownMask;

	[LayerMaskPopup]
	public LayerMask layerMask;

	private string[] names
	{
		get
		{
			return new string[8] { "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight" };
		}
		set
		{
		}
	}

	private int[] values
	{
		get
		{
			return new int[8] { 1, 2, 3, 4, 5, 6, 7, 8 };
		}
		set
		{
		}
	}
}
public class EventSample : MonoBehaviour
{
	[HelpBox("Value Changed", "#showHelpBox", order = 2)]
	[OnValueChanged("OnValueChanged", order = 1)]
	[Group("OnValueChanged", 2, new float[] { })]
	[StackableField]
	public string data1 = "Data1";

	[InGroup("OnValueChanged")]
	[Slider(0f, 100f)]
	public int data2;

	[InGroup("OnValueChanged")]
	[StackableField]
	public Color data3;

	[OnClick("#OnClick", order = 1)]
	[Box(2f, 2f, 2f, 2f)]
	[AsString]
	public string onClick = "Click to hide the help box.";

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 2)]
	[OnDragDrop(autoDrop = false, after = true, order = 1)]
	[HelpBox("Drag image out.", below = false, messageType = MessageType.None)]
	[StackableField]
	public Texture2D dragOnly;

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 2)]
	[OnDragDrop(order = 1)]
	[HelpBox("Drag image out or drop image here.", below = false, messageType = MessageType.None)]
	[AsImage]
	public Texture2D dragDrop;

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 2)]
	[OnDragDrop(autoDrag = false, order = 1)]
	[HelpBox("Drop image here.", below = false, messageType = MessageType.None)]
	[AsImage]
	public Texture2D dropOnly;

	public bool showHelpBox { get; set; }

	public void OnClick()
	{
		showHelpBox = false;
	}

	public void OnValueChanged()
	{
		showHelpBox = true;
	}
}
public class FoldoutSample : MonoBehaviour
{
	[Foldout(title = "Foldout")]
	[StackableField]
	public string foldout1 = "Simple Foldout";

	[Foldout(title = "Foldout Group", order = 2)]
	[Group("Foldout Group", 1, new float[] { })]
	[StackableField]
	public string foldout2a = "Foldout with group";

	[InGroup("Foldout Group")]
	[StackableField]
	public string foldout2b;

	[Box(0f, 0f, 4f, 6f, style = "label", order = 3)]
	[Foldout(title = "Foldout with style", hierarchyMode = false, indentChildren = false, style2 = "flow overlay header lower left", order = 2)]
	[Box(2f, 4f, 2f, 4f, style = "flow overlay box", order = 1)]
	[Group("Foldout with style", 2, new float[] { })]
	[StackableField]
	public string foldout3a = "Foldout with style";

	[InGroup("Foldout with style")]
	[StackableField]
	public string foldout3b;

	[InGroup("Foldout with style")]
	[StackableField]
	public string foldout3c;
}
public class GroupSample : MonoBehaviour
{
	[Serializable]
	public class Children
	{
		public string group3a = "Group with all children but group3c";

		public string group3b;

		public string group3c;

		public string group3d;
	}

	[Box(2f, 2f, 2f, 2f, order = 1)]
	[Group("Group 1", 2, new float[] { })]
	[StackableField]
	public string group1a = "Group with 2 following properties";

	[InGroup("Group 1")]
	[StackableField]
	public string group1b;

	[InGroup("Group 1")]
	[StackableField]
	public string group1c;

	[Box(2f, 2f, 2f, 2f, order = 1)]
	[Group("Group 2", false, "group2b,group2c", new float[] { })]
	[StackableField]
	public string group2a = "Group with 2 selected properties";

	[InGroup("Group 2")]
	[StackableField]
	public string group2b;

	[InGroup("Group 2")]
	[StackableField]
	public string group2c;

	[Box(2f, 2f, 2f, 2f, order = 1)]
	[Group("Group 3", true, ".group3c", new float[] { 0f })]
	[StackableField]
	public Children group3;
}
public class HeadingSample : MonoBehaviour
{
	[Heading(0f, 0f, 0f, 0f, title = "Header")]
	[StackableField]
	public string heading1 = "Simple Heading";

	[Heading(0f, 0f, 0f, 0f, title = "Footer", below = true)]
	[StackableField]
	public string heading2 = "Below";

	[Heading(4f, 4f, 4f, 4f, title = "Header", alignment = TextAlignment.Right)]
	[StackableField]
	public string heading3 = "Padding and right alignment";

	[Heading(4f, 4f, 4f, 4f, title = "Footer", below = true, alignment = TextAlignment.Center, style = "box")]
	[StackableField]
	public string heading4 = "Style, padding and center alignment";

	[Heading(0f, 0f, 0f, 0f, title = "Header", icon = "console.infoicon.sml", width = 0.5f, height = 24f, alignment = TextAlignment.Center, style = "box")]
	[StackableField]
	public string heading5 = "Icon, Width(%) and height";

	[Heading(4f, 0f, -12f, 0f, width = 1f, height = 22f, style = "PR Insertion")]
	[StackableField]
	public string heading6 = "Style and bottom padding -12";

	[Heading(-14f, -5f, 0f, 2f, width = 1f, title = "Header", style = "box")]
	[StackableField]
	public string heading7 = "Negative padding";
}
public class HelpBoxSample : MonoBehaviour
{
	[HelpBox("Helpbox message on top.", below = false, messageType = MessageType.None)]
	[StackableField]
	public string HelpBox1;

	[HelpBox("Helpbox information.", messageType = MessageType.Info)]
	[StackableField]
	public string HelpBox2;

	[HelpBox("Helpbox warning.", messageType = MessageType.Warning)]
	[StackableField]
	public string HelpBox3;

	[HelpBox("Helpbox error.", messageType = MessageType.Error)]
	[StackableField]
	public string HelpBox4;
}
public class HelpBoxSample2 : MonoBehaviour
{
	public bool show1;

	public int show2;

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[HelpBox("Show if Show1 is true", "$show1")]
	[StackableField]
	public string HelpBox1;

	[HelpBox("Show if Show1 is false", "$show1", inverted = true)]
	[StackableField]
	public string HelpBox1b;

	[HelpBox("Show if Show2 is positive", "#Visible")]
	[StackableField]
	public string HelpBox2;

	[HelpBox("Show if self is positive", "#CheckValue")]
	[StackableField]
	public int HelpBox2b;

	public bool Visible()
	{
		return show2 >= 0;
	}

	public bool CheckValue(int value)
	{
		return value >= 0;
	}
}
public class HierarchyModeSample : MonoBehaviour
{
	[Serializable]
	public class On
	{
		public string hierarchyMode = "HierarchyMode On";
	}

	[Serializable]
	public class Off
	{
		public string hierarchyMode = "HierarchyMode Off";
	}

	public On hierarchyModeOn;

	[HierarchyMode(false)]
	[StackableField]
	public Off hierarchyModeOff;
}
public class HorizontalGroupSample : MonoBehaviour
{
	[Serializable]
	public class Children
	{
		[Label(0f)]
		[StackableField]
		public string group3a;

		[Label(0f)]
		[StackableField]
		public string group3b;

		[Label(0f)]
		[StackableField]
		public string group3c;

		[Label(0f)]
		[StackableField]
		public string group3d;
	}

	[HorizontalGroup("Group 1", 2, new float[] { -1f, 65f, 65f })]
	[StackableField]
	public string group1a;

	[InGroup("Group 1", order = 1)]
	[Label(-1f, title = "B")]
	[StackableField]
	public string group1b;

	[InGroup("Group 1", order = 1)]
	[Label(-1f, title = "C")]
	[StackableField]
	public string group1c;

	[HorizontalGroup("Group 2", false, "group2b,group2c", new float[] { }, order = 1)]
	[Label(25f, title = "A")]
	[StackableField]
	public string group2a;

	[InGroup("Group 2", order = 1)]
	[Label(25f, title = "B")]
	[StackableField]
	public string group2b;

	[InGroup("Group 2", order = 1)]
	[Label(25f, title = "C")]
	[StackableField]
	public string group2c;

	[HorizontalGroup("Group 3", true, ".group3c", new float[] { 0f }, prefix = true)]
	[StackableField]
	public Children group3;
}
public class IconSizeSample : MonoBehaviour
{
	[Heading(0f, 0f, 0f, 0f, title = "GameObject", icon = "GameObject Icon")]
	[StackableField]
	public string IconSizeOff = "IconSize Off";

	[IconSize(16, 16, order = 1)]
	[Heading(0f, 0f, 0f, 0f, title = "GameObject", icon = "GameObject Icon")]
	[StackableField]
	public string IconSize = "IconSize 16";
}
public class ImageSample : MonoBehaviour
{
	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[Image(0f, 0f, 0f, 0f, image = "GameObject Icon")]
	[StackableField]
	public string image1 = "Using internal resource";

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[Image(0f, 0f, 0f, 0f, image = "Assets/StackableDecorator/Sample/logo.png", alignment = TextAlignment.Right)]
	[StackableField]
	public string image2 = "Using file path";

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[Image(0f, 0f, 0f, 0f, image = "31929cbaa6b12f441b2d2f5d23cbb8ce", GUID = true, alignment = TextAlignment.Center)]
	[StackableField]
	public string image3 = "Using GUID";

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[Image(0f, 0f, 0f, 0f, texture = "$texture")]
	[StackableField]
	public string image4 = "Using texture";

	public Texture2D texture;

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[SideImage(0f, 0f, 0f, 0f, image = "GameObject Icon", onLeft = true, height = 1f)]
	[StackableField]
	public string side1;

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[SideImage(0f, 0f, 0f, 0f, texture = "$texture", height = 48f)]
	[StackableField]
	public string side2;
}
public class IncludeChildrenSample : MonoBehaviour
{
	[Serializable]
	public class On
	{
		public string includeChildren = "IncludeChildren On";
	}

	[Serializable]
	public class Off
	{
		public string includeChildren = "IncludeChildren Off";
	}

	public On includeChildrenOn;

	[IncludeChildren(false)]
	[StackableField]
	public Off includeChildrenOff;
}
public class IndentLevelSample : MonoBehaviour
{
	[Serializable]
	public class Children
	{
		public string indentLevel1 = "IndentLevel Off";

		[IndentLevel(-1)]
		[StackableField]
		public string indentLevel2 = "IndentLevel -1";

		[IndentLevel(-2)]
		[StackableField]
		public string indentLevel3 = "IndentLevel -2";

		[IndentLevel(0, absolute = true)]
		[StackableField]
		public string indentLevel4 = "IndentLevel 0 (absolute)";

		[IndentLevel(3, absolute = true)]
		[StackableField]
		public string indentLevel5 = "IndentLevel 3 (absolute)";
	}

	public string indentLevel1 = "IndentLevel Off";

	[IndentLevel(1)]
	[StackableField]
	public string indentLevel2 = "IndentLevel +1";

	[IndentLevel(2)]
	[StackableField]
	public string indentLevel3 = "IndentLevel +2";

	public Children children;
}
public class InlinePropertySample : MonoBehaviour
{
	[InlineProperty(3f, 3f, 3f, 3f)]
	[Expandable]
	public Transform trans;

	[InlineProperty(3f, 3f, 3f, 3f)]
	[Expandable]
	public Material material;

	[InlineProperty(3f, 3f, 3f, 3f)]
	[Expandable]
	public UnityEngine.Object obj;
}
public class LabelSample : MonoBehaviour
{
	[Label(title = "Title")]
	[StackableField]
	public string label1 = "Change Title";

	[Label(title = "GameObject", icon = "GameObject Icon", tooltip = "Tooltip")]
	[StackableField]
	public string label2 = "Change Title, Icon and Tooltip";

	[Label(100f)]
	[StackableField]
	public string label3 = "Change Width";

	[Label(0f)]
	[StackableField]
	public string label4 = "Hide Label";

	[Label(-1f)]
	[StackableField]
	public string label5 = "Auto Width";

	[Label(-1f, title = "Auto Width")]
	[StackableField]
	public string label6 = "Auto Width with title";
}
public class ListSample : MonoBehaviour
{
	[Serializable]
	public class NestedList
	{
		[List(expandable = true)]
		public List<DataList> list;
	}

	[Serializable]
	public class DataList
	{
		[Label(-1f, order = 1)]
		[HorizontalGroup("info", true, "", new float[] { 0f, 15f, -1f, 50f }, prefix = true)]
		[StackableField]
		public List<Data> list;
	}

	[Serializable]
	public class Data
	{
		[Label(0f)]
		[StackableField]
		public bool enable;

		[Label(0f)]
		[Slider(0f, 100f, showField = false)]
		public int value;

		[Label(0f)]
		[StackableField]
		public Color color;
	}

	[List]
	[SerializeField]
	private DataList m_DataList;

	[Heading(0f, 0f, 0f, 0f, title = "Nested List")]
	[List]
	[SerializeField]
	public NestedList nestedList;

	[Heading(0f, 0f, 0f, 0f, title = "SimpleList")]
	[SimpleList("m_DataList.list")]
	public string placeholder1;

	[Heading(0f, 0f, 8f, 0f, title = "SimpleGrid")]
	[SimpleGrid("m_DataList.list", column = 2, cellHeight = 16f)]
	public string placeholder2;

	public List<Data> dataList => m_DataList.list;
}
public class Logo : MonoBehaviour
{
	[Heading(0f, 0f, 8f, 0f, order = 7)]
	[HorizontalGroup("Logo", 0, new float[] { 98f }, order = 6)]
	[Box(4f, 4f, 4f, 4f, style = "flow node 1 on", order = 5)]
	[Heading(0f, 0f, 2f, 6f, title = "Stackable", width = -1f, style = "WarningOverlay", order = 4)]
	[Color(1f, 1f, 0.5f, 1f, order = 3)]
	[Box(4f, 4f, 4f, 4f, style = "flow overlay box", order = 2)]
	[Label(-1f)]
	[StackableField]
	public bool Decorator = true;
}
public class PopupEditorSample : MonoBehaviour
{
	[PopupEditor]
	[StackableField]
	public Transform trans;

	[PopupEditor]
	[StackableField]
	public Material material;

	[PopupEditor(width = -1f, title = "Popup", style = "minibutton")]
	[StackableField]
	public UnityEngine.Object obj;
}
public class PopupSample : MonoBehaviour
{
	[TagPopup]
	public string tag1 = "Untagged";

	[TagPopup(placeHolder = "Please select a tag.", exclude = "Untagged")]
	public string tag2;

	[LayerPopup]
	public int layer1;

	[LayerPopup(placeHolder = "Please select a layer.", exclude = "Default")]
	public string layer2;

	[SortingLayerPopup]
	public int sortingLayer1;

	[SortingLayerPopup(placeHolder = "Please select a layer.", exclude = "Default")]
	public string sortingLayer2;

	[InputAxisPopup(placeHolder = "Please select a input.")]
	public string input1;

	[InputAxisPopup(placeHolder = "Please select a input.", mouseMovement = false, joystickAxis = false, negativeButton = false)]
	public string input2;

	[AnimatorParameterPopup(placeHolder = "Please select a parameter.")]
	public string parameter1;

	[AnimatorParameterPopup(placeHolder = "Please select a parameter.", triggerType = false)]
	public string parameter2;
}
public class PreviewSample : MonoBehaviour
{
	[Preview]
	[Expandable]
	public GameObject prefab;

	[Preview]
	[Expandable]
	public Material material;

	[Preview]
	[Expandable]
	public Texture texture;
}
public class Sample : MonoBehaviour
{
	[Heading(0f, 0f, 0f, 0f, title = "Heading", order = 3)]
	[Color(0.5f, 0.5f, 1f, 1f, order = 2)]
	[Box(2f, 2f, 2f, 2f)]
	[StackableField]
	public string field;
}
public class ShowIfSample : MonoBehaviour
{
	public bool show1;

	public int show2;

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[ShowIf("$show1")]
	[StackableField]
	public string showIf1 = "Show if Show1 is true";

	[ShowIf("$show1", inverted = true)]
	[StackableField]
	public string showIf1b = "Show if Show1 is false";

	[ShowIf("#Visible")]
	[StackableField]
	public string showIf2 = "Show if Show2 is positive";

	[ShowIf("#Visible", order = 1)]
	[ShowIf("$show1", disable = false)]
	[StackableField]
	public string enableIf3 = "ShowIf1 or ShowIf2";

	[ShowIf("#Visible", order = 1)]
	[ShowIf("$show1", enable = false)]
	[StackableField]
	public string enableIf4 = "ShowIf1 and ShowIf2";

	public bool Visible()
	{
		return show2 >= 0;
	}
}
public class TabGroupSample : MonoBehaviour
{
	[Serializable]
	public class Children
	{
		public string group3a = "Group with all children but group3c";

		public string group3b;

		public string group3c;

		public string group3d;
	}

	[TabGroup("Tab Group", "Tab1,Tab2,Tab3", "group2a,group3", 0f, 0f, 0f, 2f, order = 1)]
	[Group("Group 1", 2, new float[] { })]
	[StackableField]
	public string group1a = "Group with 2 following properties";

	[InGroup("Group 1")]
	[StackableField]
	public string group1b;

	[InGroup("Group 1")]
	[StackableField]
	public string group1c;

	[InGroup("Tab Group", order = 1)]
	[Group("Group 2", false, "group2b,group2c", new float[] { })]
	[StackableField]
	public string group2a = "Group with 2 selected properties";

	[InGroup("Group 2")]
	[StackableField]
	public string group2b;

	[InGroup("Group 2")]
	[StackableField]
	public string group2c;

	[InGroup("Tab Group", order = 1)]
	[Group("Group 3", true, ".group3c", new float[] { 0f })]
	[StackableField]
	public Children group3;
}
public class TabGroupSample2 : MonoBehaviour
{
	[Serializable]
	public class Children
	{
		public string group3a = "Group with all children but group3c";

		public string group3b;

		public string group3c;

		public string group3d;
	}

	[IconSize(16, 16, order = 2)]
	[TabGroup("Tab Group", "GameObject,Prefab,Scene", "group2a,group3", -14f, -5f, 2f, 0f, icons = "GameObject Icon,PrefabNormal Icon,SceneAsset Icon", alignment = TextAlignment.Center, width = 0.8f, style = "toolbarbutton", style2 = "Toolbar", order = 1)]
	[Group("Group 1", 2, new float[] { })]
	[StackableField]
	public string group1a = "Group with 2 following properties";

	[InGroup("Group 1")]
	[StackableField]
	public string group1b;

	[InGroup("Group 1")]
	[StackableField]
	public string group1c;

	[InGroup("Tab Group", order = 1)]
	[Group("Group 2", false, "group2b,group2c", new float[] { })]
	[StackableField]
	public string group2a = "Group with 2 selected properties";

	[InGroup("Group 2")]
	[StackableField]
	public string group2b;

	[InGroup("Group 2")]
	[StackableField]
	public string group2c;

	[InGroup("Tab Group", order = 1)]
	[Group("Group 3", true, ".group3c", new float[] { 0f })]
	[StackableField]
	public Children group3;
}
public class ValidateObjectSample : MonoBehaviour
{
	[NotNull]
	[StackableField]
	public GameObject notNull1;

	[NotNull]
	[StackableField]
	public GameObject notNull2;

	[AssetOnly]
	[StackableField]
	public GameObject assetOnly1;

	[AssetOnly]
	[StackableField]
	public GameObject assetOnly2;

	[SceneOnly]
	[StackableField]
	public GameObject sceneOnly1;

	[SceneOnly]
	[StackableField]
	public GameObject sceneOnly2;
}
public class ValidateValueSample : MonoBehaviour
{
	public int referenceValue = 100;

	[ValidateValue("%1 cannot larger than Reference Value.", "#CheckValue")]
	[StackableField]
	public int validateValue1;

	[ValidateValue("%1 cannot larger than Reference Value.", "#CheckValue")]
	[StackableField]
	public int validateValue2 = 200;

	[ValidateValue("%1 require ValidateValueSample.", "#CheckObject")]
	[StackableField]
	public GameObject validateObject1;

	[ValidateValue("%1 require ValidateValueSample.", "#CheckObject")]
	[StackableField]
	public GameObject validateObject2;

	[ValidateValue("%1 require ValidateValueSample.", "#CheckObject")]
	[StackableField]
	public GameObject validateObject3;

	[ValidateValue("More than 2 elements.", "#CheckArray")]
	[StackableField]
	public int[] validateArray;

	public bool CheckValue(int value)
	{
		return value <= referenceValue;
	}

	public bool CheckObject(GameObject go)
	{
		if (go != null)
		{
			return go.GetComponent<ValidateValueSample>() != null;
		}
		return false;
	}
}
public class BgmData : ScriptableObject
{
	[Serializable]
	public class Param
	{
		public int ID;

		public int Layer;

		public int Parts;

		public int Bpm;

		public int Bars;

		public int Beats;

		public int UnitPerBar;

		public bool Intro;

		public bool Outro;

		public bool SingleClip;

		public int FadeBars;
	}

	public List<Param> param = new List<Param>();

	public Param FindByID(int id)
	{
		int count = param.Count;
		for (int i = 0; i < count; i++)
		{
			if (param[i].ID == id)
			{
				return param[i];
			}
		}
		UnityEngine.Debug.Log("Cannnot Find Bgm Data! id = " + id);
		return null;
	}
}
public class Entity_CharaName : ScriptableObject
{
	[Serializable]
	public class Param
	{
		public int id;

		public string name;

		public string ja;

		public string en;

		public string ch;
	}

	public List<Param> param = new List<Param>();
}
public class Entity_ScenarioRelatedData : ScriptableObject
{
	[Serializable]
	public class Param
	{
		public int Sqid;

		public int Related;

		public bool Skippable;
	}

	public List<Param> param = new List<Param>();
}
public class LocalizeData : ScriptableObject
{
	[Serializable]
	public class Param
	{
		public string KEY;

		public string Japanese;

		public string English;

		public string German;

		public string French;

		public string Chinese;
	}

	public List<Param> param = new List<Param>();
}
public class ScenarioTableData : ScriptableObject
{
	[Serializable]
	public class Param
	{
		public int Chara;

		public string TextJp;

		public string TextEg;

		public string TextCh;

		public string Voice;

		public string TextGe;
	}

	public List<Param> param = new List<Param>();
}
public class Compression
{
	private class Node
	{
		public int mNext;

		public int mPrev;

		public int mPos;
	}

	private class Index
	{
		private Node[] mNodes = new Node[2304];

		private int[] mStack = new int[2048];

		private int mStackPos;

		public Index()
		{
			for (int i = 0; i < 2304; i++)
			{
				mNodes[i] = new Node();
			}
			for (int j = 2048; j < 2304; j++)
			{
				mNodes[j].mNext = (mNodes[j].mPrev = j);
			}
			for (int k = 0; k < 2048; k++)
			{
				mStack[k] = k;
			}
			mStackPos = 2048;
		}

		public int getFirst(byte c)
		{
			return mNodes[2048 + c].mNext;
		}

		public Node getNode(int i)
		{
			return mNodes[i];
		}

		public void add(byte c, int pos)
		{
			mStackPos--;
			int num = mStack[mStackPos];
			Node obj = mNodes[num];
			Node node = mNodes[2048 + c];
			obj.mNext = node.mNext;
			obj.mPrev = 2048 + c;
			obj.mPos = pos;
			mNodes[node.mNext].mPrev = num;
			node.mNext = num;
		}

		public void remove(byte c, int pos)
		{
			int mPrev = mNodes[2048 + c].mPrev;
			Node node = mNodes[mPrev];
			if (node.mPos != pos)
			{
				UnityEngine.Debug.LogError("n.mPos != pos");
			}
			mStack[mStackPos] = mNodes[node.mPrev].mNext;
			mStackPos++;
			mNodes[node.mPrev].mNext = node.mNext;
			mNodes[node.mNext].mPrev = node.mPrev;
		}

		public bool isEnd(int idx)
		{
			return idx >= 2048;
		}
	}

	private const int DIC_BITS = 11;

	private const int LENGTH_BITS = 4;

	private const int DIC_MASK = 2047;

	private const int DIC_MASK_HIGH = 1792;

	private const int DIC_MASK_SHIFTED = 112;

	private const int LENGTH_MASK = 15;

	private const int DIC_SIZE = 2048;

	private const int MAX_LENGTH = 18;

	public static byte[] Compress(byte[] bytes)
	{
		int num = bytes.Length;
		byte[] bytes2 = BitConverter.GetBytes(num);
		int num2 = bytes2.Length;
		byte[] array = new byte[num + num / 128 + 1];
		Compress(array, out var oSize, bytes);
		byte[] array2 = new byte[oSize + 4];
		Buffer.BlockCopy(bytes2, 0, array2, 0, num2);
		Buffer.BlockCopy(array, 0, array2, num2, oSize);
		return array2;
	}

	public static byte[] Decompress(byte[] bytes)
	{
		int oSize = BitConverter.ToInt32(bytes, 0);
		byte[] array = new byte[oSize];
		Decompress(array, out oSize, bytes);
		return array;
	}

	private static int min(int a, int b)
	{
		if (a >= b)
		{
			return b;
		}
		return a;
	}

	private static int max(int a, int b)
	{
		if (a <= b)
		{
			return b;
		}
		return a;
	}

	private static void Compress(byte[] oData, out int oSize, byte[] iData)
	{
		int num = iData.Length;
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		Index index = new Index();
		while (num3 < num)
		{
			int num5 = 0;
			int num6 = 0;
			int num7 = min(18, num - num3);
			int num8 = index.getFirst(iData[num3]);
			while (!index.isEnd(num8))
			{
				Node node = index.getNode(num8);
				int mPos = node.mPos;
				int i;
				for (i = 1; i < num7 && iData[mPos + i] == iData[num3 + i]; i++)
				{
				}
				if (num5 < i)
				{
					num6 = mPos;
					num5 = i;
					if (num5 == num7)
					{
						break;
					}
				}
				num8 = node.mNext;
			}
			if (num5 >= 3)
			{
				for (int j = 0; j < num5; j++)
				{
					int num9 = num3 + j - 2048;
					if (num9 >= 0)
					{
						index.remove(iData[num9], num9);
					}
					index.add(iData[num3 + j], num3 + j);
				}
				if (num4 < num3)
				{
					oData[num2] = (byte)(num3 - num4 - 1);
					num2++;
					for (int k = num4; k < num3; k++)
					{
						oData[num2] = iData[k];
						num2++;
					}
				}
				int num10 = num5 - 3;
				int num11 = num3 - num6 - 1;
				int num12 = 0x80 | num10;
				num12 |= (num11 & 0x700) >> 4;
				oData[num2] = (byte)num12;
				oData[num2 + 1] = (byte)((uint)num11 & 0xFFu);
				num2 += 2;
				num3 += num5;
				num4 = num3;
				continue;
			}
			int num13 = num3 - 2048;
			if (num13 >= 0)
			{
				index.remove(iData[num13], num13);
			}
			index.add(iData[num3], num3);
			num3++;
			if (num3 - num4 == 128)
			{
				oData[num2] = (byte)(num3 - num4 - 1);
				num2++;
				for (int l = num4; l < num3; l++)
				{
					oData[num2] = iData[l];
					num2++;
				}
				num4 = num3;
			}
		}
		if (num4 < num3)
		{
			oData[num2] = (byte)(num3 - num4 - 1);
			num2++;
			for (int m = num4; m < num3; m++)
			{
				oData[num2] = iData[m];
				num2++;
			}
		}
		oSize = num2;
	}

	private static void Decompress(byte[] oData, out int oSize, byte[] iData)
	{
		int num = 0;
		int num2 = iData.Length;
		int num3;
		for (num3 = 4; num3 < num2; num3++)
		{
			int num4;
			if ((iData[num3] & 0x80u) != 0)
			{
				num4 = iData[num3] & 0xF;
				num4 += 3;
				int num5 = ((iData[num3] & 0x70) << 4) | iData[num3 + 1];
				num5++;
				for (int i = 0; i < num4; i++)
				{
					oData[num + i] = oData[num - num5 + i];
				}
				num3++;
			}
			else
			{
				num4 = iData[num3] + 1;
				for (int j = 0; j < num4; j++)
				{
					oData[num + j] = iData[num3 + 1 + j];
				}
				num3 += num4;
			}
			num += num4;
		}
		oSize = num;
	}
}
public class Crypt
{
	public static void EncryptXor(byte[] key, byte[] buffer)
	{
		EncryptXor(key, buffer, 0, buffer.Length);
	}

	public static void EncryptXor(byte[] key, byte[] buffer, int offset, int count)
	{
		if (key == null || key.Length == 0)
		{
			return;
		}
		int num = key.Length;
		for (int i = offset; i < offset + count; i++)
		{
			if (buffer[i] != 0)
			{
				byte b = key[i % num];
				buffer[i] ^= b;
				if (buffer[i] == 0)
				{
					buffer[i] = b;
				}
			}
		}
	}

	public static void DecryptXor(byte[] key, byte[] buffer)
	{
		DecryptXor(key, buffer, 0, buffer.Length);
	}

	public static void DecryptXor(byte[] key, byte[] buffer, int offset, int count)
	{
		if (key == null || key.Length == 0)
		{
			return;
		}
		int num = key.Length;
		for (int i = offset; i < offset + count; i++)
		{
			byte b = key[i % num];
			if (buffer[i] != 0 && buffer[i] != b)
			{
				buffer[i] ^= key[i % num];
			}
		}
	}
}
public class FileIOManager : FileIOManagerBase
{
	private byte[] cryptKeyBytes;

	[SerializeField]
	private string cryptKey = "InputOriginalKey";

	public byte[] CryptKeyBytes
	{
		get
		{
			if (cryptKeyBytes == null || cryptKeyBytes.Length == 0)
			{
				cryptKeyBytes = Encoding.UTF8.GetBytes(cryptKey);
			}
			return cryptKeyBytes;
		}
	}

	private void OnValidate()
	{
		cryptKeyBytes = Encoding.UTF8.GetBytes(cryptKey);
	}

	public override byte[] Decode(byte[] bytes)
	{
		return FileIOManagerBase.CustomDecode(CryptKeyBytes, bytes);
	}

	public override void DecodeNoCompress(byte[] bytes)
	{
		FileIOManagerBase.CustomDecodeNoCompress(CryptKeyBytes, bytes, 0, bytes.Length);
	}

	public override byte[] Encode(byte[] bytes)
	{
		return FileIOManagerBase.CustomEncode(CryptKeyBytes, bytes);
	}

	public override byte[] EncodeNoCompress(byte[] bytes)
	{
		int num = 0;
		do
		{
			int num2 = Math.Min(262144, bytes.Length - num);
			Buffer.BlockCopy(bytes, num, FileIOManagerBase.workBufferArray, 0, num2);
			FileIOManagerBase.CustomEncodeNoCompress(CryptKeyBytes, FileIOManagerBase.workBufferArray, 0, num2);
			Buffer.BlockCopy(FileIOManagerBase.workBufferArray, 0, bytes, num, num2);
			num += num2;
		}
		while (num < bytes.Length);
		return bytes;
	}

	public override bool Write(string path, byte[] bytes)
	{
		try
		{
			using (FileStream fileStream = new FileStream(path, FileMode.Create, FileAccess.Write))
			{
				int num = 0;
				do
				{
					int num2 = Math.Min(262144, bytes.Length - num);
					fileStream.Write(bytes, num, num2);
					num += num2;
				}
				while (num < bytes.Length);
			}
			return true;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(ex.ToString());
			return false;
		}
	}

	public override bool ReadBinaryDecode(string path, Action<BinaryReader> callbackRead)
	{
		try
		{
			if (!Exists(path))
			{
				return false;
			}
			using (MemoryStream input = new MemoryStream(FileIOManagerBase.CustomDecode(CryptKeyBytes, FileReadAllBytes(path))))
			{
				using BinaryReader obj = new BinaryReader(input);
				callbackRead(obj);
			}
			return true;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogErrorFormat(this, "REALLY OOPS: '{1}' on read PATH = {0} ({2})", path, ex.GetType(), ex.Message);
			return false;
		}
	}

	public override bool WriteBinaryEncode(string path, Action<BinaryWriter> callbackWrite)
	{
		try
		{
			using (MemoryStream memoryStream = new MemoryStream())
			{
				using (BinaryWriter obj = new BinaryWriter(memoryStream))
				{
					callbackWrite(obj);
				}
				FileWriteAllBytes(path, FileIOManagerBase.CustomEncode(CryptKeyBytes, memoryStream.ToArray()));
			}
			return true;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("Error - Failed to write file, " + ex.ToString());
			return false;
		}
	}

	public override bool WriteEncode(string path, byte[] bytes)
	{
		try
		{
			FileWriteAllBytes(path, FileIOManagerBase.CustomEncode(CryptKeyBytes, bytes));
			return true;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("Error - Failed to write file, " + ex.ToString());
			return false;
		}
	}

	public override bool WriteEncodeNoCompress(string path, byte[] bytes)
	{
		try
		{
			using (FileStream fileStream = new FileStream(path, FileMode.Create, FileAccess.Write))
			{
				int num = 0;
				do
				{
					int num2 = Math.Min(262144, bytes.Length - num);
					Buffer.BlockCopy(bytes, num, FileIOManagerBase.workBufferArray, 0, num2);
					FileIOManagerBase.CustomEncodeNoCompress(CryptKeyBytes, FileIOManagerBase.workBufferArray, 0, num2);
					fileStream.Write(FileIOManagerBase.workBufferArray, 0, num2);
					num += num2;
				}
				while (num < bytes.Length);
			}
			return true;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(ex.ToString());
			return false;
		}
	}

	public override bool WriteSound(string path, AudioClip audioClip)
	{
		try
		{
			FileIOManagerBase.audioHeader[0] = audioClip.samples;
			FileIOManagerBase.audioHeader[2] = audioClip.frequency;
			FileIOManagerBase.audioHeader[1] = audioClip.channels;
			int num = audioClip.samples * audioClip.channels;
			using (FileStream fileStream = new FileStream(path, FileMode.Create, FileAccess.Write))
			{
				Buffer.BlockCopy(FileIOManagerBase.audioHeader, 0, FileIOManagerBase.workBufferArray, 0, 12);
				FileIOManagerBase.CustomEncodeNoCompress(CryptKeyBytes, FileIOManagerBase.workBufferArray, 0, 12);
				fileStream.Write(FileIOManagerBase.workBufferArray, 0, 12);
				int num2 = 0;
				do
				{
					int num3 = Math.Min(FileIOManagerBase.audioSamplesWorkArray.Length, num - num2);
					audioClip.GetData(FileIOManagerBase.audioSamplesWorkArray, num2 / audioClip.channels);
					for (int i = 0; i < num3; i++)
					{
						FileIOManagerBase.audioShortWorkArray[i] = (short)(32767f * FileIOManagerBase.audioSamplesWorkArray[i]);
					}
					int num4 = num3 * 2;
					Buffer.BlockCopy(FileIOManagerBase.audioShortWorkArray, 0, FileIOManagerBase.workBufferArray, 0, num4);
					FileIOManagerBase.CustomEncodeNoCompress(CryptKeyBytes, FileIOManagerBase.workBufferArray, 0, num4);
					fileStream.Write(FileIOManagerBase.workBufferArray, 0, num4);
					num2 += num3;
				}
				while (num2 < num);
			}
			return true;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(ex.ToString());
			return false;
		}
	}

	public override bool CreateDirectory(string path)
	{
		string directoryName = System.IO.Path.GetDirectoryName(path);
		if (!Directory.Exists(directoryName))
		{
			Directory.CreateDirectory(directoryName);
			return true;
		}
		return false;
	}

	public override bool Exists(string path)
	{
		return File.Exists(path);
	}

	protected byte[] FileReadAllBytes(string path)
	{
		return File.ReadAllBytes(path);
	}

	protected void FileWriteAllBytes(string path, byte[] bytes)
	{
		File.WriteAllBytes(path, bytes);
	}

	public override void Delete(string path)
	{
		File.Delete(path);
	}
}
public abstract class FileIOManagerBase : MonoBehaviour
{
	protected enum SoundHeader
	{
		Samples,
		Channels,
		Frequency,
		Max
	}

	private const string sdkDirectoryName = "GameFile/";

	private static Func<byte[], byte[], byte[]> customEncode = DefaultEncode;

	private static Func<byte[], byte[], byte[]> customDecode = DefaultDecode;

	private static Action<byte[], byte[], int, int> customEncodeNoCompress = DefaultEncodeNoCompress;

	private static Action<byte[], byte[], int, int> customDecodeNoCompress = DefaultDecodeNoCompress;

	protected static int[] audioHeader = new int[3];

	protected const int audioHeaderSize = 12;

	protected const int maxWorkBufferSize = 262144;

	protected const int maxAudioWorkSize = 131072;

	protected static byte[] workBufferArray = new byte[262144];

	protected static short[] audioShortWorkArray = new short[131072];

	protected static float[] audioSamplesWorkArray = new float[131072];

	public static string SdkPersistentDataPath => FilePathUtil.Combine(UnityEngine.Application.persistentDataPath, "GameFile/");

	public static string SdkTemporaryCachePath => FilePathUtil.Combine(UnityEngine.Application.temporaryCachePath, "GameFile/");

	public static Func<byte[], byte[], byte[]> CustomEncode
	{
		get
		{
			return customEncode;
		}
		set
		{
			customEncode = value;
		}
	}

	public static Func<byte[], byte[], byte[]> CustomDecode
	{
		get
		{
			return customDecode;
		}
		set
		{
			customDecode = value;
		}
	}

	public static Action<byte[], byte[], int, int> CustomEncodeNoCompress
	{
		get
		{
			return customEncodeNoCompress;
		}
		set
		{
			customEncodeNoCompress = value;
		}
	}

	public static Action<byte[], byte[], int, int> CustomDecodeNoCompress
	{
		get
		{
			return customDecodeNoCompress;
		}
		set
		{
			customDecodeNoCompress = value;
		}
	}

	public static int ToMagicID(char id0, char id1, char id2, char id3)
	{
		return (int)(((uint)id3 << 24) + ((uint)id2 << 16) + ((uint)id1 << 8) + id0);
	}

	private static byte[] DefaultEncode(byte[] keyBytes, byte[] bytes)
	{
		byte[] array = Compression.Compress(bytes);
		Crypt.EncryptXor(keyBytes, array);
		return array;
	}

	private static byte[] DefaultDecode(byte[] keyBytes, byte[] bytes)
	{
		Crypt.DecryptXor(keyBytes, bytes);
		return Compression.Decompress(bytes);
	}

	private static void DefaultEncodeNoCompress(byte[] keyBytes, byte[] bytes, int offset, int count)
	{
		Crypt.EncryptXor(keyBytes, bytes, offset, count);
	}

	private static void DefaultDecodeNoCompress(byte[] keyBytes, byte[] bytes, int offset, int count)
	{
		Crypt.DecryptXor(keyBytes, bytes, offset, count);
	}

	public abstract byte[] Decode(byte[] bytes);

	public abstract void DecodeNoCompress(byte[] bytes);

	public abstract byte[] Encode(byte[] bytes);

	public abstract byte[] EncodeNoCompress(byte[] bytes);

	public abstract bool Write(string path, byte[] bytes);

	public abstract bool ReadBinaryDecode(string path, Action<BinaryReader> callbackRead);

	public abstract bool WriteBinaryEncode(string path, Action<BinaryWriter> callbackWrite);

	public abstract bool WriteEncode(string path, byte[] bytes);

	public abstract bool WriteEncodeNoCompress(string path, byte[] bytes);

	public abstract bool WriteSound(string path, AudioClip audioClip);

	public abstract bool CreateDirectory(string path);

	public abstract bool Exists(string path);

	public abstract void Delete(string path);
}
public class FilePathUtil
{
	public static string GetDirectoryNameOnly(string path)
	{
		return System.IO.Path.GetFileName(System.IO.Path.GetDirectoryName(path));
	}

	public static string GetDirectoryPath(string path)
	{
		int num = Mathf.Max(path.LastIndexOf('/'), path.LastIndexOf('\\'));
		if (num > 0)
		{
			path = path.Substring(0, num);
		}
		return path;
	}

	public static string Format(string path)
	{
		path = path.Replace("\\", "/");
		if (!path.Contains("://"))
		{
			path = path.Replace(":/", "://");
		}
		return path;
	}

	public static string GetFileName(string path)
	{
		return System.IO.Path.GetFileName(path);
	}

	public static string GetFileNameWithoutExtension(string path)
	{
		return System.IO.Path.GetFileNameWithoutExtension(path);
	}

	public static string GetPathWithoutExtension(string path)
	{
		int num = path.LastIndexOf('.');
		if (num > 0)
		{
			path = path.Substring(0, num);
		}
		return path;
	}

	public static string GetExtension(string path)
	{
		return System.IO.Path.GetExtension(path);
	}

	public static string ChangeExtension(string path, string extenstion)
	{
		return System.IO.Path.ChangeExtension(path, extenstion);
	}

	public static bool CheckExtention(string path, string ext)
	{
		return string.Compare(GetExtension(path), ext, ignoreCase: true) == 0;
	}

	public static bool CheckExtentionWithOutDouble(string path, string ext, string doubleExtension)
	{
		return CheckExtention(GetExtenstionWithOutDouble(path, doubleExtension), ext);
	}

	public static string GetExtenstionWithOutDouble(string path, string doubleExtension)
	{
		string extension = System.IO.Path.GetExtension(path);
		if (string.Compare(extension, doubleExtension, ignoreCase: true) != 0)
		{
			return extension;
		}
		path = path.Substring(0, path.Length - doubleExtension.Length);
		return System.IO.Path.GetExtension(path);
	}

	public static string AddDoubleExtensiton(string path, string doubleExtension)
	{
		if (!CheckExtention(path, doubleExtension))
		{
			path += doubleExtension;
		}
		return path;
	}

	public static string GetFileNameWithoutDoubleExtensiton(string path)
	{
		string fileNameWithoutExtension = System.IO.Path.GetFileNameWithoutExtension(path);
		if (fileNameWithoutExtension.Contains("."))
		{
			fileNameWithoutExtension = System.IO.Path.GetFileNameWithoutExtension(fileNameWithoutExtension);
		}
		return fileNameWithoutExtension;
	}

	public static bool IsAbsoluteUri(string path)
	{
		if (string.IsNullOrEmpty(path))
		{
			return false;
		}
		if (path.Length <= 1)
		{
			return false;
		}
		try
		{
			return new Uri(path, UriKind.RelativeOrAbsolute).IsAbsoluteUri;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(path + ":" + ex.Message);
			return false;
		}
	}

	public static string EncodeUrl(string url)
	{
		try
		{
			return new Uri(url.Replace('\\', '/')).AbsoluteUri;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(url + ":" + ex.Message);
			return url;
		}
	}

	public static string ToCacheClearUrl(string url)
	{
		return $"{url}?datetime={DateTime.Now.ToFileTime()}";
	}

	public static string ToStreamingAssetsUrl(string path)
	{
		if (UnityEngine.Application.platform == RuntimePlatform.Android)
		{
			return Combine(UnityEngine.Application.streamingAssetsPath, path);
		}
		return "file://" + Combine(UnityEngine.Application.streamingAssetsPath, path);
	}

	public static string Combine(params string[] args)
	{
		string text = "";
		foreach (string text2 in args)
		{
			if (!string.IsNullOrEmpty(text2))
			{
				text = System.IO.Path.Combine(text, text2);
			}
		}
		return text.Replace("\\", "/");
	}

	public static string RemoveDirectory(string path, string directoryPath)
	{
		path = Format(path);
		directoryPath = Format(directoryPath);
		if (!TryRemoveDirectory(path, directoryPath, out var newPath))
		{
			UnityEngine.Debug.LogError("RemoveDirectoryPath Error [" + path + "]  [" + directoryPath + "] ");
		}
		return newPath;
	}

	public static bool TryRemoveDirectory(string path, string directoryPath, out string newPath)
	{
		newPath = path;
		if (!path.StartsWith(directoryPath))
		{
			return false;
		}
		int num = directoryPath.Length;
		if (path.Length > num)
		{
			char c = path[num];
			if (c == '/' || c == '\\')
			{
				num++;
			}
		}
		newPath = path.Remove(0, num);
		return true;
	}

	internal static bool IsUnderDirectory(string path, string directoryPath)
	{
		path = Format(path);
		directoryPath = Format(directoryPath);
		return path.StartsWith(directoryPath);
	}
}
public class kageyamaDefine
{
	public enum AnimationIndex
	{
		KG_f011 = 10,
		KG_f012 = 11,
		KG_f013 = 12,
		KG_f014 = 13,
		SIZE = 4
	}
}
public class kamiyaDefine
{
	public enum AnimationIndex
	{
		KM_f021 = 20,
		SIZE = 1
	}
}
public class machikojiDefine
{
	public enum AnimationIndex
	{
		MC_059 = 58,
		SIZE = 1
	}
}
public class momonoDefine
{
	public enum AnimationIndex
	{
		MM_102 = 101,
		SIZE = 1
	}
}
public class morozumiDefine
{
	public enum AnimationIndex
	{
		MR_f012 = 11,
		MR_f013 = 12,
		MR_f014 = 13,
		MR_f015 = 14,
		SIZE = 4
	}
}
public class nikaidoDefine
{
	public enum AnimationIndex
	{
		NK_f015 = 14,
		NK_f016 = 15,
		NK_f017 = 16,
		SIZE = 3
	}
}
public class rouDefine
{
	public enum AnimationIndex
	{
		RU_f011 = 11,
		SIZE = 1
	}
}
public class sakuraiDefine
{
	public enum AnimationIndex
	{
		SK_060 = 58,
		SK_059 = 59,
		SIZE = 2
	}
}
public class togokuDefine
{
	public enum AnimationIndex
	{
		TG_f018 = 17,
		TG_f019 = 18,
		TG_f020 = 19,
		TG_f021 = 20,
		TG_f022 = 21,
		TG_f023 = 22,
		SIZE = 6
	}
}
public class AnimationController : MonoBehaviour
{
	private Animator animator;

	[SerializeField]
	private int animNum;

	private int lastNum;

	private void Start()
	{
		animator = GetComponentInChildren<Animator>();
		lastNum = 0;
	}

	private void Update()
	{
		if (animNum != lastNum)
		{
			animator.SetInteger("motion", animNum);
			animator.SetTrigger("startAnim");
			lastNum = animNum;
		}
	}

	public void SetAnimId(int id)
	{
		animNum = id;
	}
}
[ExecuteInEditMode]
public class AnimationUpdaterInEditor : MonoBehaviour
{
	private void Update()
	{
		UpdateAnimator();
	}

	private void OnGUI()
	{
		UpdateAnimator();
	}

	private void OnRenderObject()
	{
		UpdateAnimator();
	}

	private void UpdateAnimator()
	{
		base.transform.GetChild(0).GetComponent<Animator>().Update(1f);
	}
}
public class TextProFader : MonoBehaviour
{
	public float waitTime = 0.03f;

	public int omitLastNum;

	private TextMeshPro _textComponent;

	private bool _fading;

	private int _currentCharacter;

	private int _characterCount;

	private TMP_TextInfo _textInfo;

	private TMP_MeshInfo[] _cachedMeshInfo;

	private UnityAction _onEndAction;

	private IDisposable _currentFade;

	private Subject<Unit> _subjectBeforeFadeDelay = new Subject<Unit>();

	private Subject<Unit> _subjectStartFade = new Subject<Unit>();

	private Subject<Unit> _subjectEndFade = new Subject<Unit>();

	private Subject<Unit> _subjectTextChanged = new Subject<Unit>();

	private Func<IEnumerator> m_fadeEnumeratorFunction;

	private float m_fadeDelay;

	private Color32[] sourceVertexColors;

	private Color32[] newVertexColors;

	public IObservable<Unit> OnBeforeFadeDelay => _subjectBeforeFadeDelay;

	public IObservable<Unit> OnStartFade => _subjectStartFade;

	public IObservable<Unit> OnEndFade => _subjectEndFade;

	public IObservable<Unit> OnTextMeshChanged => _subjectTextChanged;

	public Vector3 LastCharacterPosition { get; private set; }

	public bool IsFinishedFade => _currentCharacter >= _characterCount - omitLastNum;

	private int RealCharacterCount => _characterCount - omitLastNum;

	private void Awake()
	{
		_textComponent = GetComponent<TextMeshPro>();
		_textInfo = _textComponent.textInfo;
		_currentCharacter = _textInfo.characterCount;
		TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		m_fadeEnumeratorFunction = () => RoutineTextFade();
	}

	private void OnDisable()
	{
		ForceEndFade();
	}

	private void OnDestroy()
	{
		if (_currentFade != null)
		{
			_currentFade.Dispose();
			_currentFade = null;
		}
		TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
	}

	private void ON_TEXT_CHANGED(UnityEngine.Object obj)
	{
		if (obj == _textComponent)
		{
			OnChangeText();
		}
	}

	public void StartFade(float delay)
	{
		if (_currentFade != null)
		{
			_currentFade.Dispose();
			_currentFade = null;
		}
		_currentCharacter = 0;
		m_fadeDelay = delay;
		_currentFade = Observable.FromMicroCoroutine(m_fadeEnumeratorFunction).Subscribe();
	}

	private void ForceEndFade()
	{
		if (_currentFade != null)
		{
			_currentFade.Dispose();
			_currentFade = null;
		}
		if (_fading)
		{
			ProcessEndFade();
		}
	}

	private void UpdateCacheVertex()
	{
		_cachedMeshInfo = _textInfo.CopyMeshInfoVertexData();
		_characterCount = _textInfo.characterCount;
		UpdateLastCharacterPosition();
	}

	private void UpdateLastCharacterPosition()
	{
		int num = _textInfo.characterCount - 1;
		if (num < 0)
		{
			LastCharacterPosition = Vector2.zero;
			return;
		}
		Vector3 lastCharacterPosition = _textInfo.characterInfo[num].topLeft + _textInfo.characterInfo[num].topRight + _textInfo.characterInfo[num].bottomRight + _textInfo.characterInfo[num].bottomLeft;
		lastCharacterPosition /= 4f;
		LastCharacterPosition = lastCharacterPosition;
	}

	private void OnChangeText()
	{
		UpdateCacheVertex();
		ResetAllText();
		_subjectTextChanged.OnNext(Unit.Default);
	}

	private void ProcessEndFade()
	{
		_fading = false;
		_subjectEndFade.OnNext(Unit.Default);
	}

	private IEnumerator RoutineTextFade()
	{
		_ = (Color32)_textComponent.color;
		_fading = true;
		yield return null;
		ToggleAllText(flag: false);
		_subjectBeforeFadeDelay.OnNext(Unit.Default);
		float delayCount = m_fadeDelay;
		while (delayCount > 0f)
		{
			delayCount -= Time.deltaTime;
			yield return null;
		}
		_subjectStartFade.OnNext(Unit.Default);
		if (RealCharacterCount <= 0)
		{
			ProcessEndFade();
			yield break;
		}
		while (_currentCharacter < RealCharacterCount)
		{
			if (_textInfo.characterInfo[_currentCharacter].isVisible)
			{
				int materialReferenceIndex = _textInfo.characterInfo[_currentCharacter].materialReferenceIndex;
				int vertexIndex = _textInfo.characterInfo[_currentCharacter].vertexIndex;
				sourceVertexColors = _cachedMeshInfo[materialReferenceIndex].colors32;
				newVertexColors = _textInfo.meshInfo[materialReferenceIndex].colors32;
				Color32 color = sourceVertexColors[vertexIndex];
				newVertexColors[vertexIndex] = color;
				newVertexColors[vertexIndex + 1] = color;
				newVertexColors[vertexIndex + 2] = color;
				newVertexColors[vertexIndex + 3] = color;
				_textComponent.UpdateVertexData(TMP_VertexDataUpdateFlags.Colors32);
			}
			_currentCharacter++;
			delayCount += waitTime;
			while (delayCount > 0f)
			{
				delayCount -= Time.deltaTime;
				yield return null;
			}
		}
		ProcessEndFade();
	}

	public void ToggleAllText(bool flag)
	{
		if (flag)
		{
			_currentCharacter = RealCharacterCount;
			ResetAllText();
			ForceEndFade();
		}
		else
		{
			_currentCharacter = 0;
			ResetAllText();
		}
	}

	private void ResetAllText()
	{
		Color32 color = _textComponent.color;
		for (int i = 0; i < _characterCount; i++)
		{
			if (_textInfo.characterInfo[i].isVisible)
			{
				int materialReferenceIndex = _textInfo.characterInfo[i].materialReferenceIndex;
				int vertexIndex = _textInfo.characterInfo[i].vertexIndex;
				newVertexColors = _textInfo.meshInfo[materialReferenceIndex].colors32;
				if (i < _currentCharacter)
				{
					sourceVertexColors = _cachedMeshInfo[materialReferenceIndex].colors32;
					color = sourceVertexColors[vertexIndex];
				}
				else
				{
					color = new Color32(0, 0, 0, 0);
				}
				newVertexColors[vertexIndex] = color;
				newVertexColors[vertexIndex + 1] = color;
				newVertexColors[vertexIndex + 2] = color;
				newVertexColors[vertexIndex + 3] = color;
				_textComponent.UpdateVertexData(TMP_VertexDataUpdateFlags.Colors32);
			}
		}
	}
}
public class DebugLogger : MonoBehaviour
{
	[Header("Prefabs")]
	[SerializeField]
	private DebugLogComponent _prefabLogComponent;

	[Header("Components")]
	[SerializeField]
	private Canvas m_canvas;

	[SerializeField]
	private RectTransform _logParent;

	[Header("Parameters - Text")]
	[SerializeField]
	private int m_maxLines = 10;

	[SerializeField]
	private float m_DecayPower = 0.92f;

	[Header("Parameters - Type Settings")]
	[SerializeField]
	[EnumLabel(typeof(LogType))]
	private bool[] m_showFlags;

	[SerializeField]
	[EnumLabel(typeof(LogType))]
	private Color[] m_typeColor;

	[SerializeField]
	[EnumLabel(typeof(LogType))]
	private bool[] m_typeIsBold;

	[SerializeField]
	[EnumLabel(typeof(LogType))]
	private Sprite[] m_typeSprite;

	private Stack<DebugLogComponent> _unusedObjects = new Stack<DebugLogComponent>();

	private LinkedList<DebugLogComponent> _logObjects = new LinkedList<DebugLogComponent>();

	private int _logCount;

	public bool IsVisible { get; set; }

	public Color GetTypeColor(LogType tp)
	{
		return m_typeColor[(int)tp];
	}

	public bool GetTypeBold(LogType tp)
	{
		return m_typeIsBold[(int)tp];
	}

	public Sprite GetTypeSprite(LogType tp)
	{
		return m_typeSprite[(int)tp];
	}

	private void Awake()
	{
		UnityEngine.Application.logMessageReceived += OnLogMessage;
	}

	private void OnDestroy()
	{
		UnityEngine.Application.logMessageReceived -= OnLogMessage;
	}

	private void OnLogMessage(string text, string stackTrace, LogType type)
	{
		Observable.NextFrame().Subscribe(delegate
		{
			OutputLogMessage(text, stackTrace, type);
		});
	}

	private void OutputLogMessage(string text, string stackTrace, LogType type)
	{
		if (!m_showFlags[(int)type])
		{
			return;
		}
		if (_logCount > 0)
		{
			DebugLogComponent value = _logObjects.Last.Value;
			value.DecayAlpha(m_DecayPower);
			if (type == value.DisplayType && text == value.DisplayText)
			{
				value.StackCount();
				return;
			}
		}
		DebugLogComponent debugLogComponent = FindUnusedOrInstantiate();
		debugLogComponent.Init(this, text, stackTrace, type);
		_logObjects.AddLast(debugLogComponent);
		_logCount++;
		OmitOverflow();
	}

	private DebugLogComponent FindUnusedOrInstantiate()
	{
		if (_unusedObjects.Count <= 0)
		{
			return UnityEngine.Object.Instantiate(_prefabLogComponent, _logParent, worldPositionStays: false);
		}
		DebugLogComponent debugLogComponent = _unusedObjects.Pop();
		debugLogComponent.gameObject.SetActive(value: true);
		debugLogComponent.transform.SetSiblingIndex(99);
		return debugLogComponent;
	}

	private void OmitOverflow()
	{
		int num = _logCount - m_maxLines;
		if (num > 0)
		{
			for (int i = 0; i < num; i++)
			{
				DebugLogComponent value = _logObjects.First.Value;
				value.gameObject.SetActive(value: false);
				_unusedObjects.Push(value);
				_logObjects.RemoveFirst();
				_logCount--;
			}
		}
	}

	public void ToggleVisible(bool flag)
	{
		IsVisible = flag;
		m_canvas.enabled = flag;
		_logParent.gameObject.SetActive(flag);
	}
}
public class DebugMemory : MonoBehaviour
{
	[SerializeField]
	private TextMeshProUGUI m_unityMemoryText;

	public bool IsVisible { get; set; }

	private void Update()
	{
		long monoUsedSizeLong = Profiler.GetMonoUsedSizeLong();
		long monoHeapSizeLong = Profiler.GetMonoHeapSizeLong();
		long totalAllocatedMemoryLong = Profiler.GetTotalAllocatedMemoryLong();
		long totalReservedMemoryLong = Profiler.GetTotalReservedMemoryLong();
		m_unityMemoryText.text = $"mono:{monoUsedSizeLong / 1024}/{monoHeapSizeLong / 1024} kb({100.0 * (double)monoUsedSizeLong / (double)monoHeapSizeLong:f1}%)\ntotal:{totalAllocatedMemoryLong / 1024}/{totalReservedMemoryLong / 1024} kb({100.0 * (double)totalAllocatedMemoryLong / (double)totalReservedMemoryLong:f1}%)";
	}

	public void ToggleVisible(bool flag)
	{
		IsVisible = flag;
		base.enabled = flag;
		m_unityMemoryText.enabled = flag;
	}
}
public class DebugLogComponent : MonoBehaviour
{
	[SerializeField]
	private CanvasGroup _group;

	[SerializeField]
	private Image _icon;

	[SerializeField]
	private TextMeshProUGUI _textHeader;

	[SerializeField]
	private TextMeshProUGUI _textMini;

	[SerializeField]
	private TextMeshProUGUI _textBadge;

	private int _stackCount = 1;

	private string _text;

	private LogType _type;

	private IObservable<int> _onChangeBadge;

	public string DisplayText => _text;

	public LogType DisplayType => _type;

	public void Init(DebugLogger parent, string text, string stackTrace, LogType type)
	{
		Color typeColor = parent.GetTypeColor(type);
		bool typeBold = parent.GetTypeBold(type);
		_textHeader.text = text;
		_textHeader.color = typeColor;
		if (typeBold)
		{
			_textHeader.fontStyle = FontStyles.Bold;
		}
		else
		{
			_textHeader.fontStyle = FontStyles.Normal;
		}
		string value = stackTrace;
		if (string.IsNullOrEmpty(value))
		{
			_textMini.gameObject.SetActive(value: false);
		}
		else
		{
			value = GetFirstStackTrace(stackTrace);
			_textMini.gameObject.SetActive(value: true);
			_textMini.text = value;
			_textMini.color = typeColor;
		}
		_icon.sprite = parent.GetTypeSprite(type);
		_text = text;
		_type = type;
		_stackCount = 1;
		SetAlpha(1f);
		MakeObservable();
	}

	private void MakeObservable()
	{
		if (_onChangeBadge == null)
		{
			_onChangeBadge = this.ObserveEveryValueChanged((DebugLogComponent x) => x._stackCount);
			_onChangeBadge.Subscribe(delegate(int cnt)
			{
				UpdateBadge(cnt);
			});
		}
	}

	private string GetFirstStackTrace(string trace)
	{
		string[] array = trace.Split('\n');
		if (array.Length <= 1)
		{
			return trace;
		}
		string text = "";
		for (int i = 0; i < 2; i++)
		{
			if (i != 0 || !Regex.Match(array[i], "^UnityEngine\\.Debug").Success)
			{
				if (!string.IsNullOrEmpty(text))
				{
					text += Environment.NewLine;
				}
				Match match = Regex.Match(array[i], ".+[.:](.+) \\(at .+/(.+):(.+)\\)");
				if (match.Success)
				{
					text += $"  Src: <b>{match.Groups[2].Value}</b> / Func: <b>{match.Groups[1].Value}</b> / Line: <b>{match.Groups[3].Value}</b>";
					break;
				}
				text += array[i];
			}
		}
		return text;
	}

	public void StackCount()
	{
		_stackCount++;
	}

	private void UpdateBadge(int cnt)
	{
		if (cnt < 2)
		{
			_textBadge.text = "";
			return;
		}
		if (cnt > 99)
		{
			_textBadge.text = "99+";
			return;
		}
		_textBadge.text = cnt.ToString();
		SetAlpha(1f);
	}

	public void SetAlpha(float a)
	{
		_group.alpha = a;
	}

	public void DecayAlpha(float pow)
	{
		_group.alpha *= pow;
	}
}
public class DemoTimeChecker
{
	public static readonly DateTime m_startTime = new DateTime(2018, 10, 22, 20, 0, 0);

	public static readonly DateTime m_deadline = new DateTime(2018, 10, 23, 1, 0, 0);

	public static bool IsValid()
	{
		DateTime now = DateTime.Now;
		if (now <= m_deadline)
		{
			return now >= m_startTime;
		}
		return false;
	}

	public static bool IsBeforeStart()
	{
		return DateTime.Now < m_startTime;
	}

	public static bool IsAfterDeadline()
	{
		return DateTime.Now > m_deadline;
	}
}
public static class DefineValue
{
}
public static class KeyDefine
{
	public const string Horizontal = "Horizontal";

	public const string Vertical = "Vertical";

	public const string TriggerLeft = "TriggerLeft";

	public const string TriggerRight = "TriggerRight";

	public const string Button1 = "Button1";

	public const string MouseX = "Mouse X";

	public const string MouseY = "Mouse Y";

	public const string MouseScrollWheel = "Mouse ScrollWheel";

	public const string HorizontalLeft = "HorizontalLeft";

	public const string VerticalLeft = "VerticalLeft";

	public const string StickPushLeft = "StickPushLeft";

	public const string StickPushRight = "StickPushRight";

	public const string Button2 = "Button2";

	public const string Button3 = "Button3";

	public const string Button4 = "Button4";

	public const string ButtonStart = "ButtonStart";

	public const string Escape = "Escape";
}
public static class LayerDefine
{
	public const string Default = "Default";

	public const string TransparentFX = "TransparentFX";

	public const string IgnoreRaycast = "Ignore Raycast";

	public const string Water = "Water";

	public const string UI = "UI";

	public const string RayTarget = "RayTarget";

	public const string Chara = "Chara";

	public const string Environment = "Environment";

	public const string SelectionTarget = "SelectionTarget";

	public const string MirrorChara = "MirrorChara";

	public const string MirrorOnly = "MirrorOnly";

	public const string BokeSphere = "BokeSphere";

	public const string ImportantProp = "ImportantProp";
}
public enum SceneDefine
{
	SplashScreen,
	Title,
	Permanent,
	MainMenu,
	InGame,
	AdvBoot,
	Memory,
	ChangeChara,
	Backstreet,
	Crossing,
	TownA,
	TownB,
	Building,
	BuildingRoof,
	ConvinientStore,
	FancyShop,
	HotelRoom,
	EndProto,
	Flashback,
	SchoolRoof,
	TownC,
	BuildingF,
	MainTitle,
	Debug,
	CrossingEvening,
	CrossingNight,
	BackstreetEvening,
	BuildingNight,
	BuildingFNight,
	TougokuLivingNight,
	Bookstore,
	HotelNight,
	HotelNightLight,
	TownTougoku,
	Blank,
	EndOfChapter,
	TownANight,
	TougokuLiving,
	PlayDome,
	Uyuni,
	TougokuLibrary,
	ShibuyaRoad,
	BuildingStairs,
	ThemePark,
	TheBeginning,
	StartOfChapter,
	BuildingRoofMono,
	BuildingsElevatorHall,
	TougokuLibraryEvening,
	TougokuLibraryNight,
	BuildingRoofCrack,
	Opening,
	OpeningSecond,
	MMEnding,
	TGEnding,
	KGEnding,
	MZEnding,
	MCEnding,
	Ending,
	aTitleBack,
	bTitleBack,
	cTitleBack,
	BuildingRoofCatScene,
	SchoolRoofMono,
	FusionCatScene,
	EndingSecond,
	Dream
}
public static class SceneNameDefine
{
	public static string[] Names = new string[67]
	{
		"SplashScreen", "Title", "000Permanent", "001MainMenu", "002InGame", "010AdvBoot", "011Memory", "012ChangeChara", "100Backstreet", "110Crossing",
		"120TownA", "130TownB", "200Building", "210BuildingRoof", "300ConvinientStore", "310FancyShop", "320HotelRoom", "EndProto", "003Flashback", "500SchoolRoof",
		"140TownC", "220Building8F", "020MainTitle", "004Debug", "111CrossingEvening", "112CrossingNight", "101BackstreetEvening", "202BuildingNight", "222Building8FNight", "352TougokuLivingNight",
		"360Bookstore", "322HotelNight", "323HotelNightLight", "150TownTougoku", "021Blank", "022EndOfChapter", "122TownANight", "350TougokuLiving", "370PlayDome", "400Uyuni",
		"340TougokuLibrary", "160ShibuyaRoad", "230BuildingStairs", "380ThemePark", "099TheBeginning", "023StartOfChapter", "213BuildingRoofMono", "240BuildingsElevatorHall", "341TougokuLibraryEvening", "342TougokuLibraryNight",
		"214BuildingRoofCrack", "Opening", "OpeningSecond", "MMEnding", "TGEnding", "KGEnding", "MZEnding", "MCEnding", "024Ending1", "020aTitleBack1",
		"020bTitleBack2", "020cTitleBack3", "215BuildingRoofCatScene", "501SchoolRoofMono", "FusionCatScene", "025EndingSecond", "410Dream"
	};
}
public static class TagDefine
{
	public const string Untagged = "Untagged";

	public const string Respawn = "Respawn";

	public const string Finish = "Finish";

	public const string EditorOnly = "EditorOnly";

	public const string MainCamera = "MainCamera";

	public const string Player = "Player";

	public const string GameController = "GameController";
}
[Serializable]
public class FadeCatSceneBehaviour : PlayableBehaviour
{
	public Color StartColor = new Color(0f, 0f, 0f, 1f);

	public Color EndColor = new Color(0f, 0f, 0f, 0f);

	public override void OnPlayableCreate(Playable playable)
	{
	}
}
[Serializable]
public class FadeCatSceneClip : PlayableAsset, ITimelineClipAsset
{
	public FadeCatSceneBehaviour template = new FadeCatSceneBehaviour();

	public ClipCaps clipCaps => ClipCaps.Blending;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		return ScriptPlayable<FadeCatSceneBehaviour>.Create(graph, template);
	}
}
public class FadeCatSceneMixerBehaviour : PlayableBehaviour
{
	private UIFader m_TrackBinding;

	private Color start = new Color(0f, 0f, 0f, 1f);

	private Color end = new Color(0f, 0f, 0f, 1f);

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		m_TrackBinding = playerData as UIFader;
		if (m_TrackBinding == null)
		{
			return;
		}
		int inputCount = playable.GetInputCount();
		float t = 0f;
		bool flag = false;
		for (int i = 0; i < inputCount; i++)
		{
			float inputWeight = playable.GetInputWeight(i);
			ScriptPlayable<FadeCatSceneBehaviour> playable2 = (ScriptPlayable<FadeCatSceneBehaviour>)playable.GetInput(i);
			FadeCatSceneBehaviour behaviour = playable2.GetBehaviour();
			if (inputWeight == 1f)
			{
				flag = true;
				t = (float)playable2.GetTime() / (float)playable2.GetDuration();
				start = behaviour.StartColor;
				end = behaviour.EndColor;
			}
		}
		if (!flag)
		{
			t = 1f;
		}
		m_TrackBinding.SetColour(Color.Lerp(start, end, t));
	}
}
[TrackColor(0f, 0.5f, 1f)]
[TrackClipType(typeof(FadeCatSceneClip))]
[TrackBindingType(typeof(UIFader))]
public class FadeCatSceneTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<FadeCatSceneMixerBehaviour>.Create(graph, inputCount);
	}

	public override void GatherProperties(PlayableDirector director, IPropertyCollector driver)
	{
		base.GatherProperties(director, driver);
	}
}
[Serializable]
public class FadeObjectBehaviour : PlayableBehaviour
{
	public enum FadeType
	{
		fadein,
		fadeout
	}

	public FadeType mFadeType;

	public override void OnPlayableCreate(Playable playable)
	{
	}
}
[Serializable]
public class FadeObjectClip : PlayableAsset, ITimelineClipAsset
{
	public FadeObjectBehaviour template = new FadeObjectBehaviour();

	public ClipCaps clipCaps => ClipCaps.None;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		return ScriptPlayable<FadeObjectBehaviour>.Create(graph, template);
	}
}
public class FadeObjectMixerBehaviour : PlayableBehaviour
{
	protected List<Material> m_materials = new List<Material>();

	protected List<Material> m_originalMaterials = new List<Material>();

	private float alphaWaight;

	private FadeObjectBehaviour.FadeType LastFadeType = FadeObjectBehaviour.FadeType.fadeout;

	private Renderer[] m_renderers;

	protected const string _PARAM_ALPHA = "_Alpha";

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		GameObject gameObject = playerData as GameObject;
		if (!gameObject)
		{
			return;
		}
		if (m_materials.Count == 0)
		{
			m_renderers = gameObject.GetComponentsInChildren<Renderer>();
			AddMaterials(m_renderers);
		}
		int inputCount = playable.GetInputCount();
		float num = 0f;
		float num2 = 0f;
		for (int i = 0; i < inputCount; i++)
		{
			float inputWeight = playable.GetInputWeight(i);
			ScriptPlayable<FadeObjectBehaviour> playable2 = (ScriptPlayable<FadeObjectBehaviour>)playable.GetInput(i);
			FadeObjectBehaviour behaviour = playable2.GetBehaviour();
			float num3 = (float)playable2.GetTime() / (float)playable2.GetDuration();
			num += ((behaviour.mFadeType == FadeObjectBehaviour.FadeType.fadein) ? num3 : (1f - num3)) * inputWeight;
			if (inputWeight == 1f)
			{
				LastFadeType = behaviour.mFadeType;
			}
			num2 += inputWeight;
		}
		if (num2 == 0f)
		{
			num = ((LastFadeType == FadeObjectBehaviour.FadeType.fadein) ? 1 : 0);
		}
		int count = m_materials.Count;
		for (int j = 0; j < count; j++)
		{
			m_materials[j].SetFloat("_Alpha", num);
		}
	}

	private void AddMaterials(Renderer[] renderers)
	{
		foreach (Renderer renderer in renderers)
		{
			Material[] sharedMaterials = renderer.sharedMaterials;
			Material[] array = new Material[sharedMaterials.Length];
			for (int j = 0; j < sharedMaterials.Length; j++)
			{
				Material material = sharedMaterials[j];
				int num = m_originalMaterials.IndexOf(material);
				Material material2 = null;
				if (num < 0)
				{
					m_originalMaterials.Add(material);
					material2 = new Material(material);
					m_materials.Add(material2);
				}
				else
				{
					material2 = m_materials[num];
				}
				array[j] = material2;
			}
			renderer.materials = array;
		}
	}
}
[TrackColor(0f, 0.5f, 1f)]
[TrackClipType(typeof(FadeObjectClip))]
[TrackBindingType(typeof(GameObject))]
public class FadeObjectTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<FadeObjectMixerBehaviour>.Create(graph, inputCount);
	}
}
public class DisableOnStart : MonoBehaviour
{
	[SerializeField]
	private bool m_isDisableOnFirstUpdate;

	private GameObject m_gameObject;

	private void Start()
	{
		m_gameObject = base.gameObject;
		if (!m_isDisableOnFirstUpdate)
		{
			SetActive();
		}
	}

	private void SetActive(bool isActive = false)
	{
		m_gameObject.SetActive(isActive);
		base.enabled = isActive;
	}

	private void Update()
	{
		if (m_isDisableOnFirstUpdate)
		{
			SetActive();
		}
	}
}
namespace UTJ
{
	[Serializable]
	public class AngleLimits
	{
		public bool active;

		[Range(-180f, 0f)]
		public float min;

		[Range(0f, 180f)]
		public float max;

		public static Vector3 GetAngleVector(Vector3 sideVector, Vector3 forwardVector, float degrees)
		{
			float f = (float)Math.PI / 180f * degrees;
			Vector3 a = Vector3Extension.Multiply(ref sideVector, Mathf.Sin(f));
			Vector3 b = Vector3Extension.Multiply(ref forwardVector, Mathf.Cos(f));
			return Vector3Extension.Add(ref a, ref b);
		}

		public void CopyTo(AngleLimits target)
		{
			target.active = active;
			target.min = min;
			target.max = max;
		}

		private static float ComputeFalloff(float value, float range)
		{
			if (MathHelper.Abs(ref range) <= 0.0001f)
			{
				return 0f;
			}
			float num = Mathf.Clamp01(value / range);
			return Mathf.Min(num, (float)Math.Sqrt(num));
		}

		public bool ConstrainVector(ref Vector3 basisSide, ref Vector3 basisUp, ref Vector3 basisForward, float springStrength, float deltaTime, ref Vector3 vector)
		{
			Vector3 b = Vector3Extension.Project(ref vector, ref basisUp);
			Vector3 a = Vector3Extension.Subtract(ref vector, ref b);
			float num = a.Length();
			Vector3 lhs = Vector3Extension.Divide(ref a, num);
			float value = Vector3Extension.DotProduct(ref lhs, ref basisSide);
			value = Mathf.Clamp(value, -1f, 1f);
			float num2 = 57.29578f * Mathf.Asin(value);
			float num3 = (0f - num2) * springStrength;
			num2 += num3 * deltaTime * deltaTime;
			float num4 = min;
			float num5 = max;
			float num6 = num2;
			num2 = Mathf.Clamp(num2, num4, num5);
			float num7 = ((num2 < 0f) ? num4 : num5);
			num2 = ComputeFalloff(num2, num7) * num7;
			float f = (float)Math.PI / 180f * num2;
			Vector3 a2 = Vector3Extension.Multiply(ref basisSide, Mathf.Sin(f));
			Vector3 b2 = Vector3Extension.Multiply(ref basisForward, Mathf.Cos(f));
			Vector3 target = Vector3Extension.Add(ref a2, ref b2);
			Vector3Extension.MultiplyTarget(num, ref target);
			Vector3Extension.Add(ref target, ref b, out vector);
			return num2 != num6;
		}
	}
	public struct Circle3
	{
		public Vector3 origin;

		public Vector3 upVector;

		public float radius;
	}
	public class SpringCapsuleCollider : MonoBehaviour
	{
		public float radius = 0.075f;

		public float height = 0.3f;

		public Renderer linkedRenderer;

		public Transform MyTransform;

		private void Start()
		{
			MyTransform = base.transform;
		}

		public SpringBone.CollisionStatus CheckForCollisionAndReact(ref Vector3 moverHeadPosition, ref Vector3 moverPosition, float moverRadius, ref Vector3 hitNormal)
		{
			if (radius <= 0.0001f)
			{
				return SpringBone.CollisionStatus.NoCollision;
			}
			Matrix4x4 worldToLocalMatrix = MyTransform.worldToLocalMatrix;
			float num = worldToLocalMatrix.MultiplyVector(ref Vector3Extension.Right).Length();
			Vector3 localHeadPosition = worldToLocalMatrix.MultiplyPoint3x4(ref moverHeadPosition);
			Vector3 localSpherePosition = worldToLocalMatrix.MultiplyPoint3x4(ref moverPosition);
			float num2 = moverRadius * num;
			bool flag = localSpherePosition.y >= height;
			if (localSpherePosition.y <= 0f || flag)
			{
				Vector3 b = new Vector3(0f, flag ? height : 0f, 0f);
				float num3 = num2 + radius;
				if (Vector3Extension.DistanceSquared(ref localSpherePosition, ref b) >= num3 * num3)
				{
					return SpringBone.CollisionStatus.NoCollision;
				}
				if (Vector3Extension.DistanceSquared(ref localHeadPosition, ref b) <= radius * radius)
				{
					Vector3 a = Vector3Extension.Direction(ref localSpherePosition, ref b);
					Vector3 a2 = Vector3Extension.Multiply(ref a, num3);
					Vector3Extension.Add(ref a2, ref b, out localSpherePosition);
					moverPosition = MyTransform.TransformPoint(localSpherePosition);
					hitNormal = MyTransform.TransformDirection(a);
					Vector3Extension.Normalize(ref hitNormal);
					return SpringBone.CollisionStatus.HeadIsEmbedded;
				}
				float radiusA = Vector3Extension.Distance(ref localSpherePosition, ref localHeadPosition);
				Circle3 intersection = default(Circle3);
				if (SpringSphereCollider.ComputeIntersection(ref localHeadPosition, radiusA, ref b, num3, ref intersection))
				{
					localSpherePosition = SpringSphereCollider.ComputeNewTailPosition(ref intersection, ref localSpherePosition);
					moverPosition = MyTransform.TransformPoint(localSpherePosition);
					Vector3 direction = Vector3Extension.Direction(ref localSpherePosition, ref b);
					hitNormal = MyTransform.TransformDirection(direction);
					Vector3Extension.Normalize(ref hitNormal);
				}
				return SpringBone.CollisionStatus.TailCollision;
			}
			return CheckForCylinderCollisionAndReact(ref localHeadPosition, ref moverPosition, num2, ref localSpherePosition, ref hitNormal);
		}

		private SpringBone.CollisionStatus CheckForCylinderCollisionAndReact(ref Vector3 localHeadPosition, ref Vector3 worldMoverPosition, float localMoverRadius, ref Vector3 localSpherePosition, ref Vector3 hitNormal)
		{
			Vector2 vector = new Vector2(localSpherePosition.x, localSpherePosition.z);
			float num = radius + localMoverRadius;
			SpringBone.CollisionStatus result = SpringBone.CollisionStatus.NoCollision;
			if (vector.sqrMagnitude <= num * num)
			{
				Vector2 normalized = vector.normalized;
				vector = num * normalized;
				Vector3 position = new Vector3(vector.x, localSpherePosition.y, vector.y);
				worldMoverPosition = MyTransform.TransformPoint(position);
				hitNormal = MyTransform.TransformDirection(new Vector3(normalized.x, 0f, normalized.y));
				Vector3Extension.Normalize(ref hitNormal);
				result = ((new Vector2(localHeadPosition.x, localHeadPosition.z).sqrMagnitude <= radius * radius) ? SpringBone.CollisionStatus.HeadIsEmbedded : SpringBone.CollisionStatus.TailCollision);
			}
			return result;
		}
	}
	public class SpringPanelCollider : MonoBehaviour
	{
		public enum Axis
		{
			X,
			Y,
			Z,
			AxisCount
		}

		public float width = 0.25f;

		public float height = 0.25f;

		public Renderer linkedRenderer;

		public Vector3 GetPlaneNormal()
		{
			return base.transform.forward;
		}

		public SpringBone.CollisionStatus CheckForCollisionAndReact(ref Vector3 headPosition, float length, ref Vector3 tailPosition, float tailRadius, ref Vector3 hitNormal)
		{
			if (linkedRenderer != null && !linkedRenderer.enabled)
			{
				return SpringBone.CollisionStatus.NoCollision;
			}
			Vector3 localTailPosition = base.transform.InverseTransformPoint(tailPosition);
			float magnitude = base.transform.InverseTransformDirection(tailRadius, 0f, 0f).magnitude;
			if (localTailPosition.z >= magnitude)
			{
				return SpringBone.CollisionStatus.NoCollision;
			}
			Vector3 localHeadPosition = base.transform.InverseTransformPoint(headPosition);
			float magnitude2 = base.transform.InverseTransformDirection(length, 0f, 0f).magnitude;
			float num = 0.5f * width;
			float num2 = 0.5f * height;
			float num3 = num + magnitude;
			float num4 = num2 + magnitude;
			if (Mathf.Abs(localTailPosition.y) >= num4 || Mathf.Abs(localTailPosition.x) >= num3)
			{
				return SpringBone.CollisionStatus.NoCollision;
			}
			SpringBone.CollisionStatus collisionStatus = SpringBone.CollisionStatus.TailCollision;
			if (localHeadPosition.z <= 0f && localTailPosition.z <= 0f)
			{
				if (Mathf.Abs(localHeadPosition.y) > num2)
				{
					num2 = ((localTailPosition.y < 0f) ? (0f - num2) : num2);
					localTailPosition = new Vector3(localTailPosition.x, num2, localTailPosition.z);
				}
				else if (Mathf.Abs(localHeadPosition.x) > num)
				{
					num = ((localTailPosition.x < 0f) ? (0f - num) : num);
					localTailPosition = new Vector3(num, localTailPosition.y, localTailPosition.z);
				}
				else
				{
					collisionStatus = SpringBone.CollisionStatus.HeadIsEmbedded;
					localTailPosition = localHeadPosition;
					localTailPosition.z = magnitude;
				}
			}
			else if (Mathf.Abs(localTailPosition.y) > num2)
			{
				num2 = ((localTailPosition.y < 0f) ? (0f - num2) : num2);
				Vector3 normalized = new Vector3(0f, localTailPosition.y - num2, localTailPosition.z).normalized;
				localTailPosition = new Vector3(localTailPosition.x, num2, 0f) + magnitude * normalized;
			}
			else if (Mathf.Abs(localTailPosition.x) > num)
			{
				num = ((localTailPosition.x < 0f) ? (0f - num) : num);
				Vector3 normalized2 = new Vector3(localTailPosition.x - num, 0f, localTailPosition.z).normalized;
				localTailPosition = new Vector3(num, localTailPosition.y, 0f) + magnitude * normalized2;
			}
			else
			{
				collisionStatus = CheckForCollisionWithAlignedPlaneAndReact(ref localHeadPosition, magnitude2, ref localTailPosition, magnitude, Axis.Z);
			}
			if (collisionStatus != 0)
			{
				tailPosition = base.transform.TransformPoint(localTailPosition);
				hitNormal = base.transform.forward.normalized;
			}
			return collisionStatus;
		}

		public static SpringBone.CollisionStatus CheckForCollisionWithAlignedPlaneAndReact(ref Vector3 localHeadPosition, float localLength, ref Vector3 localTailPosition, float localTailRadius, Axis upAxis)
		{
			if (localTailPosition[(int)upAxis] >= localTailRadius)
			{
				return SpringBone.CollisionStatus.NoCollision;
			}
			SpringBone.CollisionStatus result = SpringBone.CollisionStatus.TailCollision;
			Vector3 vector = localHeadPosition;
			if (localHeadPosition[(int)upAxis] + localLength <= localTailRadius)
			{
				vector[(int)upAxis] += localLength;
				result = SpringBone.CollisionStatus.HeadIsEmbedded;
			}
			else
			{
				int index = (int)(upAxis + 1) % 3;
				int index2 = (int)(upAxis + 2) % 3;
				float num = localHeadPosition[(int)upAxis] - localTailRadius;
				float num2 = Mathf.Sqrt(localLength * localLength - num * num);
				Vector3 vector2 = Vector3Extension.Subtract(ref localTailPosition, ref localHeadPosition);
				Vector2 vector3 = new Vector2(vector2[index], vector2[index2]);
				float magnitude = vector3.magnitude;
				if (magnitude > 0.001f)
				{
					Vector2 vector4 = num2 / magnitude * vector3;
					vector[index] += vector4.x;
					vector[index2] += vector4.y;
					vector[(int)upAxis] = localTailRadius;
				}
			}
			localTailPosition = vector;
			return result;
		}
	}
	public class SpringSphereCollider : MonoBehaviour
	{
		private Vector3 m_localOrigin = Vector3.zero;

		public float radius = 0.1f;

		public Renderer linkedRenderer;

		public Transform MyTransform;

		private void Start()
		{
			MyTransform = base.transform;
		}

		public SpringBone.CollisionStatus CheckForCollisionAndReact(ref Vector3 headPosition, ref Vector3 tailPosition, float tailRadius, ref Vector3 hitNormal)
		{
			Vector3 localHeadPosition = MyTransform.InverseTransformPoint(headPosition);
			Vector3 localTailPosition = MyTransform.InverseTransformPoint(tailPosition);
			float localTailRadius = MyTransform.InverseTransformDirection(tailRadius, 0f, 0f).Length();
			SpringBone.CollisionStatus num = CheckForCollisionAndReact(ref localHeadPosition, ref localTailPosition, localTailRadius, ref m_localOrigin, radius);
			if (num != 0)
			{
				tailPosition = MyTransform.TransformPoint(localTailPosition);
				Vector3Extension.Normalize(ref localTailPosition);
				hitNormal = MyTransform.TransformDirection(localTailPosition);
				Vector3Extension.Normalize(ref hitNormal);
			}
			return num;
		}

		public static SpringBone.CollisionStatus CheckForCollisionAndReact(ref Vector3 localHeadPosition, ref Vector3 localTailPosition, float localTailRadius, ref Vector3 sphereLocalOrigin, float sphereRadius)
		{
			float num = sphereRadius + localTailRadius;
			if (Vector3Extension.DistanceSquared(ref localTailPosition, ref sphereLocalOrigin) >= num * num)
			{
				return SpringBone.CollisionStatus.NoCollision;
			}
			if (Vector3Extension.DistanceSquared(ref localHeadPosition, ref sphereLocalOrigin) >= sphereRadius * sphereRadius)
			{
				Vector3 target = Vector3Extension.Direction(ref localTailPosition, ref sphereLocalOrigin);
				Vector3Extension.MultiplyTarget(num, ref target);
				Vector3Extension.Add(ref sphereLocalOrigin, ref target, out localTailPosition);
				return SpringBone.CollisionStatus.HeadIsEmbedded;
			}
			float radiusA = Vector3Extension.Distance(ref localTailPosition, ref localHeadPosition);
			Circle3 intersection = default(Circle3);
			if (ComputeIntersection(ref localHeadPosition, radiusA, ref sphereLocalOrigin, num, ref intersection))
			{
				localTailPosition = ComputeNewTailPosition(ref intersection, ref localTailPosition);
			}
			return SpringBone.CollisionStatus.TailCollision;
		}

		public static bool ComputeIntersection(ref Vector3 originA, float radiusA, ref Vector3 originB, float radiusB, ref Circle3 intersection)
		{
			Vector3 v = Vector3Extension.Subtract(ref originB, ref originA);
			float num = Vector3Extension.LengthSquared(ref v);
			float num2 = (float)Math.Sqrt(num);
			if (num2 <= 0f)
			{
				return false;
			}
			float num3 = radiusA * radiusA;
			float num4 = radiusB * radiusB;
			float num5 = 0.5f / num2;
			float num6 = num - num4 + num3;
			float num7 = num6 * num5;
			float num8 = num6 * num6;
			float num9 = Mathf.Sqrt(4f * num * num3 - num8) * num5;
			Vector3 vector = Vector3Extension.Divide(ref v, num2);
			Vector3 origin = originA + num7 * vector;
			intersection.origin = origin;
			intersection.upVector = vector;
			intersection.radius = num9;
			return true;
		}

		public static Vector3 ComputeNewTailPosition(ref Circle3 intersection, ref Vector3 tailPosition)
		{
			Vector3 result = Vector3Extension.Subtract(ref tailPosition, ref intersection.origin);
			float d = Vector3.Dot(intersection.upVector, result);
			Vector3Extension.Multiply(ref intersection.upVector, d, out result);
			Vector3 a = Vector3Extension.Subtract(ref tailPosition, ref result);
			Vector3 v = Vector3Extension.Subtract(ref a, ref intersection.origin);
			Vector3Extension.Normalize(ref v);
			Vector3Extension.MultiplyTarget(intersection.radius, ref v);
			return Vector3Extension.Add(ref intersection.origin, ref v);
		}
	}
	public class DynamicsNull : MonoBehaviour
	{
	}
	public class HighLeg : MonoBehaviour
	{
		[Serializable]
		public class TransformPair
		{
			public Transform start;

			public Transform end;

			public Vector3 GetDirection()
			{
				return (end.position - start.position).normalized;
			}
		}

		public Transform hipPivot;

		public TransformPair[] legs;

		private void LateUpdate()
		{
			Vector3 forward = hipPivot.forward;
			Vector3 up = hipPivot.up;
			int num = legs.Length;
			float num2 = -1f;
			for (int i = 0; i < num; i++)
			{
				Vector3 direction = legs[i].GetDirection();
				if (Vector3.Dot(direction, forward) >= 0f)
				{
					num2 = Mathf.Max(Vector3.Dot(direction, up), num2);
				}
			}
			float num3 = Mathf.Sqrt(Mathf.Clamp01(1f - num2 * num2));
			Vector3 vector = up * num2 + forward * num3;
			Vector3 worldPosition = base.transform.position + vector;
			base.transform.LookAt(worldPosition, (num2 > -0.5f) ? up : forward);
		}
	}
	public class ForceProvider : MonoBehaviour
	{
		public virtual Vector3 GetForceOnBone(SpringBone springBone)
		{
			return Vector3.zero;
		}
	}
	public class ForceVolume : ForceProvider
	{
		public float strength = 0.01f;

		public override Vector3 GetForceOnBone(SpringBone springBone)
		{
			return strength * base.transform.forward;
		}

		private void OnDrawGizmos()
		{
			Vector3 position = base.transform.position;
			Vector3 destination = position + strength * 10f * base.transform.forward;
			GizmoUtil.DrawArrow(position, destination, Color.gray, 0.1f);
		}
	}
	public class WindVolume : ForceProvider
	{
		[Range(0f, 1f)]
		public float weight;

		public float strength = 100f;

		public float amplitude = 1f;

		public float period = 1.5f;

		public float spinPeriod = 1.5f;

		public float peakDistance = 0.2f;

		private const float PI2 = (float)Math.PI * 2f;

		private float positionalMultiplier;

		private float currentTime;

		private float timeFactor;

		private float spinTime;

		private Vector3 offsetVector;

		public override Vector3 GetForceOnBone(SpringBone springBone)
		{
			float num = weight * strength;
			if ((num <= 0.0001f) | (period <= 0.001f))
			{
				return Vector3.zero;
			}
			Vector3 vector = base.transform.InverseTransformPoint(springBone.transform.position);
			float positionalFactor = GetPositionalFactor(vector.x, vector.z);
			float num2 = Mathf.Sin(timeFactor + positionalFactor);
			Vector3 vector2 = num * (base.transform.forward + num2 * offsetVector).normalized;
			return springBone.windInfluence * vector2;
		}

		private float GetPositionalFactor(float x, float y)
		{
			return Mathf.Sin(positionalMultiplier * x) + Mathf.Cos(positionalMultiplier * y);
		}

		private float AddPeriodically(float currentValue, float deltaValue, float period)
		{
			float num;
			for (num = currentValue + deltaValue; num >= period; num -= period)
			{
			}
			return num;
		}

		private void Update()
		{
			if (!(weight <= 0.0001f) && !(period <= 0.001f))
			{
				peakDistance = Mathf.Max(peakDistance, 0.0001f);
				positionalMultiplier = (float)Math.PI * 2f / peakDistance;
				float deltaTime = Time.deltaTime;
				currentTime = AddPeriodically(currentTime, deltaTime, period);
				timeFactor = currentTime * ((float)Math.PI * 2f) / period;
				offsetVector = base.transform.up;
				if (Mathf.Abs(spinPeriod) > 0.001f)
				{
					spinTime = AddPeriodically(spinTime, deltaTime, spinPeriod);
					float f = spinTime * ((float)Math.PI * 2f) / spinPeriod;
					offsetVector = Mathf.Cos(f) * base.transform.right + Mathf.Sin(f) * base.transform.up;
				}
				offsetVector = amplitude * offsetVector;
			}
		}

		private void OnDrawGizmos()
		{
			Vector3 position = base.transform.position;
			float num = Mathf.Clamp(strength, 0.1f, 1f);
			Vector3 vector = position + num * base.transform.forward;
			Vector3[] array = new Vector3[3]
			{
				Vector3.zero,
				0.02f * base.transform.up,
				-0.02f * base.transform.up
			};
			foreach (Vector3 vector2 in array)
			{
				GizmoUtil.DrawArrow(position + vector2, vector + vector2, Color.gray, 0.1f);
			}
		}
	}
	public class DynamicsSetup
	{
		public class ImportSettings
		{
			public bool ImportSpringBones { get; set; }

			public bool ImportCollision { get; set; }

			public ImportSettings()
			{
				ImportSpringBones = true;
				ImportCollision = true;
			}

			public ImportSettings(ImportSettings sourceSettings)
			{
				ImportSpringBones = sourceSettings.ImportSpringBones;
				ImportCollision = sourceSettings.ImportCollision;
			}
		}

		public class ParseMessage
		{
			public string Message { get; private set; }

			public string SourceLine { get; private set; }

			public string Exception { get; private set; }

			public UnityEngine.Object Context { get; private set; }

			public ParseMessage(string message, string sourceLine = "", string exception = "", UnityEngine.Object context = null)
			{
				Message = message;
				SourceLine = sourceLine;
				Exception = exception;
				Context = context;
			}

			public ParseMessage(string message, IEnumerable<string> sourceLineItems, string exception = "", UnityEngine.Object context = null)
			{
				Message = message;
				SourceLine = ((sourceLineItems != null) ? (string.Join(", ", sourceLineItems.ToArray()) + "\n") : "");
				Exception = exception;
				Context = context;
			}

			public string ToLogMessage()
			{
				string text = Message;
				if (!string.IsNullOrEmpty(SourceLine))
				{
					text = text + "\n" + SourceLine;
				}
				if (!string.IsNullOrEmpty(Exception))
				{
					text = text + "\n\n" + Exception;
				}
				return text;
			}
		}

		public class ParseResults
		{
			public DynamicsSetup Setup { get; private set; }

			public List<ParseMessage> Errors { get; private set; }

			public bool HasErrors => Errors.Count > 0;

			public ParseResults()
			{
				Setup = null;
				Errors = new List<ParseMessage>(0);
			}

			public ParseResults(DynamicsSetup setup, IEnumerable<ParseMessage> errors)
			{
				Setup = setup;
				Errors = errors.ToList();
			}

			public static ParseResults Failure(string error)
			{
				return new ParseResults(null, new List<ParseMessage>
				{
					new ParseMessage(error)
				});
			}

			public static ParseResults Failure(IEnumerable<ParseMessage> errors)
			{
				return new ParseResults(null, errors);
			}

			public void LogErrors()
			{
				foreach (ParseMessage error in Errors)
				{
					UnityEngine.Debug.LogError(error.ToLogMessage(), error.Context);
				}
			}
		}

		private const int UnknownVersion = -1;

		private ImportSettings importSettings;

		private GameObject springBoneRoot;

		private GameObject colliderRoot;

		private SpringBoneSerialization.ParsedSpringBoneSetup springBoneSetup;

		private SpringColliderSerialization.ParsedColliderSetup colliderSetup;

		public static bool BuildFromRecordText(GameObject springBoneRoot, GameObject colliderRoot, string recordText, ImportSettings importSettings = null, IEnumerable<string> requiredBones = null)
		{
			ParseResults parseResults = ParseFromRecordText(springBoneRoot, colliderRoot, recordText, importSettings);
			bool num = parseResults.Setup != null;
			if (num)
			{
				parseResults.Setup.Build(requiredBones);
			}
			return num;
		}

		public static ParseResults ParseFromRecordText(GameObject springBoneRoot, GameObject colliderRoot, string recordText, ImportSettings importSettings = null)
		{
			if (springBoneRoot == null)
			{
				throw new ArgumentNullException("springBoneRoot");
			}
			if (colliderRoot == null)
			{
				throw new ArgumentNullException("colliderRoot");
			}
			if (recordText == null)
			{
				throw new ArgumentNullException("recordText");
			}
			ParseResults parseResults = InternalParseFromRecordText(springBoneRoot, colliderRoot, recordText, importSettings);
			parseResults.LogErrors();
			return parseResults;
		}

		public void Build(IEnumerable<string> requiredBones = null)
		{
			if (importSettings.ImportCollision && colliderSetup != null)
			{
				colliderSetup.BuildObjects(colliderRoot);
			}
			if (importSettings.ImportSpringBones && springBoneSetup != null)
			{
				springBoneSetup.BuildObjects(springBoneRoot, colliderRoot, requiredBones);
			}
		}

		public static int GetVersionFromSetupRecords(List<TextRecordParsing.Record> sourceRecords, out TextRecordParsing.Record versionRecord)
		{
			int output = -1;
			versionRecord = sourceRecords.FirstOrDefault((TextRecordParsing.Record item) => item.GetString(0).ToLowerInvariant() == "version");
			if (versionRecord != null)
			{
				versionRecord.TryGetInt(1, ref output);
			}
			return output;
		}

		public static object SerializeObjectFromStrings(Type type, IEnumerable<string> sourceItems, string firstOptionalField, ref ParseMessage error)
		{
			try
			{
				return new Queue<string>(sourceItems).DequeueObject(type, firstOptionalField);
			}
			catch (Exception ex)
			{
				error = new ParseMessage("Error building " + type.ToString(), sourceItems, ex.ToString());
			}
			return null;
		}

		public static T SerializeObjectFromStrings<T>(IEnumerable<string> sourceItems, string firstOptionalField, ref ParseMessage error) where T : class
		{
			return SerializeObjectFromStrings(typeof(T), sourceItems, firstOptionalField, ref error) as T;
		}

		private static int GetVersionFromSetupRecords(List<TextRecordParsing.Record> sourceRecords)
		{
			TextRecordParsing.Record versionRecord;
			return GetVersionFromSetupRecords(sourceRecords, out versionRecord);
		}

		private static bool VerifyVersionAndDetectContents(string recordText, ImportSettings importSettings, out string errorMessage)
		{
			errorMessage = "";
			int num = -1;
			try
			{
				num = GetVersionFromSetupRecords(TextRecordParsing.ParseRecordsFromText(recordText));
			}
			catch (Exception ex)
			{
				errorMessage = $"SpringBoneSetup: \n\n{ex.ToString()}";
				return false;
			}
			switch (num)
			{
			case -1:
				if (!recordText.ToLowerInvariant().Contains("[springbones]"))
				{
					importSettings.ImportSpringBones = false;
				}
				break;
			default:
				errorMessage = $"SpringBoneSetup: \nVersion: {num}";
				return false;
			case 3:
				importSettings.ImportCollision = false;
				break;
			case 4:
				break;
			}
			return true;
		}

		private static ParseResults InternalParseFromRecordText(GameObject springBoneRoot, GameObject colliderRoot, string recordText, ImportSettings importSettings)
		{
			if (recordText.Length == 0)
			{
				return new ParseResults();
			}
			ImportSettings importSettings2 = ((importSettings != null) ? new ImportSettings(importSettings) : new ImportSettings());
			if (!VerifyVersionAndDetectContents(recordText, importSettings2, out var errorMessage))
			{
				return ParseResults.Failure(errorMessage);
			}
			List<ParseMessage> list = new List<ParseMessage>();
			SpringColliderSerialization.ParsedColliderSetup parsedColliderSetup = null;
			if (importSettings2.ImportCollision)
			{
				parsedColliderSetup = SpringColliderSerialization.ParsedColliderSetup.ReadColliderSetupFromText(colliderRoot, recordText);
				if (parsedColliderSetup == null)
				{
					list.Add(new ParseMessage(""));
					return ParseResults.Failure(list);
				}
				list.AddRange(parsedColliderSetup.Errors);
			}
			SpringBoneSerialization.ParsedSpringBoneSetup parsedSpringBoneSetup = null;
			if (importSettings2.ImportSpringBones)
			{
				IEnumerable<string> inputValidColliderNames = parsedColliderSetup?.GetColliderNames();
				parsedSpringBoneSetup = SpringBoneSerialization.ParsedSpringBoneSetup.ReadSpringBoneSetupFromText(springBoneRoot, colliderRoot, recordText, inputValidColliderNames);
				if (parsedSpringBoneSetup == null)
				{
					list.Add(new ParseMessage(""));
					return ParseResults.Failure(list);
				}
				list.AddRange(parsedSpringBoneSetup.Errors);
			}
			return new ParseResults(new DynamicsSetup
			{
				importSettings = importSettings2,
				springBoneRoot = springBoneRoot,
				colliderRoot = colliderRoot,
				springBoneSetup = parsedSpringBoneSetup,
				colliderSetup = parsedColliderSetup
			}, list);
		}
	}
	public static class SpringBoneSerialization
	{
		public class ExportSettings
		{
			public bool ExportSpringBones { get; set; }

			public bool ExportCollision { get; set; }

			public ExportSettings()
			{
				ExportSpringBones = true;
				ExportCollision = true;
			}
		}

		public class ParsedSpringBoneSetup
		{
			private IEnumerable<PivotSerializer> pivotRecords;

			private IEnumerable<SpringBoneSerializer> springBoneRecords;

			public IEnumerable<DynamicsSetup.ParseMessage> Errors { get; set; }

			public static ParsedSpringBoneSetup ReadSpringBoneSetupFromText(GameObject springBoneRoot, GameObject colliderRoot, string recordText, IEnumerable<string> inputValidColliderNames)
			{
				List<TextRecordParsing.Record> list = null;
				List<TextRecordParsing.Record> list2 = null;
				try
				{
					List<TextRecordParsing.Record> sourceRecords = TextRecordParsing.ParseRecordsFromText(recordText);
					TextRecordParsing.Record versionRecord = null;
					DynamicsSetup.GetVersionFromSetupRecords(sourceRecords, out versionRecord);
					list = TextRecordParsing.GetSectionRecords(sourceRecords, "SpringBones");
					if (list == null || list.Count == 0)
					{
						list = (from item in TextRecordParsing.GetSectionRecords(sourceRecords, null)
							where item != versionRecord
							select item).ToList();
					}
					list2 = TextRecordParsing.GetSectionRecords(sourceRecords, "Pivots");
				}
				catch (Exception ex)
				{
					UnityEngine.Debug.LogError("SpringBoneSetup: \n\n" + ex.ToString());
					return null;
				}
				List<DynamicsSetup.ParseMessage> list3 = new List<DynamicsSetup.ParseMessage>();
				IEnumerable<PivotSerializer> sourceRecords2 = SerializePivotRecords(list2, list3);
				IEnumerable<SpringBoneSerializer> sourceRecords3 = SerializeSpringBoneRecords(list, list3);
				List<string> list4 = (from item in springBoneRoot.GetComponentsInChildren<Transform>(includeInactive: true)
					select item.name).Distinct().ToList();
				List<PivotSerializer> list5 = new List<PivotSerializer>();
				VerifyPivotRecords(sourceRecords2, list4, list5, list3);
				List<string> list6 = new List<string>(list4);
				list6.AddRange(list5.Select((PivotSerializer record) => record.name));
				List<string> list7 = new List<string>();
				IEnumerable<Type> colliderTypes = SpringColliderSetup.GetColliderTypes();
				list7.AddRange(from item in colliderTypes.SelectMany((Type type) => colliderRoot.GetComponentsInChildren(type, includeInactive: true))
					select item.name);
				if (inputValidColliderNames != null)
				{
					list7.AddRange(inputValidColliderNames);
				}
				List<SpringBoneSerializer> validRecords = new List<SpringBoneSerializer>();
				VerifySpringBoneRecords(sourceRecords3, list4, list6, list7, validRecords, out var hasMissingColliders, list3);
				if (hasMissingColliders)
				{
					UnityEngine.Debug.LogWarning("");
				}
				return new ParsedSpringBoneSetup
				{
					pivotRecords = list5,
					springBoneRecords = validRecords,
					Errors = list3
				};
			}

			public void BuildObjects(GameObject springBoneRoot, GameObject colliderRoot, IEnumerable<string> requiredBones)
			{
				PersistentSpringManagerProperties persistentSpringManagerProperties = PersistentSpringManagerProperties.Create(springBoneRoot.GetComponentInChildren<SpringManager>());
				SpringBoneSetup.DestroySpringManagersAndBones(springBoneRoot);
				if (requiredBones != null)
				{
					FilterBoneRecordsByRequiredBonesAndCreateUnrecordedBones(springBoneRoot, requiredBones);
				}
				Dictionary<string, Transform> transforms = springBoneRoot.BuildNameToComponentMap<Transform>(includeInactive: true);
				foreach (PivotSerializer pivotRecord in pivotRecords)
				{
					BuildPivotFromSerializer(transforms, pivotRecord);
				}
				SpringBoneSetupMaps setupMaps = SpringBoneSetupMaps.Build(springBoneRoot, colliderRoot);
				foreach (SpringBoneSerializer springBoneRecord in springBoneRecords)
				{
					BuildSpringBoneFromSerializer(setupMaps, springBoneRecord);
				}
				SpringManager springManager = springBoneRoot.AddComponent<SpringManager>();
				persistentSpringManagerProperties?.ApplyTo(springManager);
				SpringBoneSetup.FindAndAssignSpringBones(springManager);
			}

			private void FilterBoneRecordsByRequiredBonesAndCreateUnrecordedBones(GameObject springBoneRoot, IEnumerable<string> requiredBones)
			{
				IEnumerable<SpringBoneSerializer> enumerable = springBoneRecords.Where((SpringBoneSerializer record) => requiredBones.Contains(record.baseData.boneName));
				IEnumerable<string> second = enumerable.Select((SpringBoneSerializer record) => record.baseData.boneName);
				foreach (GameObject item in from boneName in requiredBones.Except(second)
					select springBoneRoot.FindChildByName(boneName) into item
					where item != null
					select item.gameObject)
				{
					SpringBoneSetup.CreateSpringPivotNode(item.AddComponent<SpringBone>());
				}
				foreach (SpringBoneSerializer item2 in springBoneRecords.Except(enumerable))
				{
					UnityEngine.Debug.LogWarning(item2.baseData.boneName + "\n");
				}
				springBoneRecords = enumerable;
			}
		}

		private class PersistentSpringManagerProperties
		{
			private bool automaticUpdates;

			private int simulationFrameRate;

			private float dynamicRatio;

			private Vector3 gravity;

			private bool collideWithGround;

			private float groundHeight;

			private float bounce;

			private float friction;

			public static PersistentSpringManagerProperties Create(SpringManager sourceManager)
			{
				if (sourceManager == null)
				{
					return null;
				}
				return new PersistentSpringManagerProperties
				{
					automaticUpdates = sourceManager.automaticUpdates,
					simulationFrameRate = sourceManager.simulationFrameRate,
					dynamicRatio = sourceManager.dynamicRatio,
					gravity = sourceManager.gravity,
					collideWithGround = sourceManager.collideWithGround,
					groundHeight = sourceManager.groundHeight,
					bounce = sourceManager.bounce,
					friction = sourceManager.friction
				};
			}

			public void ApplyTo(SpringManager targetManager)
			{
				targetManager.automaticUpdates = automaticUpdates;
				targetManager.simulationFrameRate = simulationFrameRate;
				targetManager.dynamicRatio = dynamicRatio;
				targetManager.gravity = gravity;
				targetManager.collideWithGround = collideWithGround;
				targetManager.groundHeight = groundHeight;
				targetManager.bounce = bounce;
				targetManager.friction = friction;
			}
		}

		private class SpringBoneSetupMaps
		{
			public Dictionary<string, Transform> allChildren;

			public Dictionary<string, SpringSphereCollider> sphereColliders;

			public Dictionary<string, SpringCapsuleCollider> capsuleColliders;

			public Dictionary<string, SpringPanelCollider> panelColliders;

			public static SpringBoneSetupMaps Build(GameObject springBoneRoot, GameObject colliderRoot)
			{
				return new SpringBoneSetupMaps
				{
					allChildren = springBoneRoot.BuildNameToComponentMap<Transform>(includeInactive: true),
					sphereColliders = colliderRoot.BuildNameToComponentMap<SpringSphereCollider>(includeInactive: true),
					capsuleColliders = colliderRoot.BuildNameToComponentMap<SpringCapsuleCollider>(includeInactive: true),
					panelColliders = colliderRoot.BuildNameToComponentMap<SpringPanelCollider>(includeInactive: true)
				};
			}
		}

		private class PivotSerializer
		{
			public string name;

			public string parentName;

			public Vector3 eulerAngles;
		}

		private class AngleLimitSerializer
		{
			public bool enabled;

			public float min;

			public float max;
		}

		private class LengthLimitSerializer
		{
			public string objectName;

			public float ratio;
		}

		private class SpringBoneBaseSerializer
		{
			public string boneName;

			public float radius;

			public float stiffness;

			public float drag;

			public Vector3 springForce;

			public float windInfluence;

			public string pivotName;

			public AngleLimitSerializer yAngleLimits;

			public AngleLimitSerializer zAngleLimits;

			public float angularStiffness;

			public LengthLimitSerializer[] lengthLimits;
		}

		private class SpringBoneSerializer
		{
			public SpringBoneBaseSerializer baseData;

			public string[] colliderNames;
		}

		public static string BuildDynamicsSetupString(GameObject rootObject, ExportSettings exportSettings = null)
		{
			if (exportSettings == null)
			{
				exportSettings = new ExportSettings();
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("version,");
			stringBuilder.Append(4);
			stringBuilder.AppendLine();
			if (exportSettings.ExportSpringBones)
			{
				stringBuilder.Append(BuildSpringBoneSetupString(rootObject));
			}
			if (exportSettings.ExportCollision)
			{
				stringBuilder.Append(SpringColliderSerialization.BuildCollisionSetupString(rootObject));
			}
			return stringBuilder.ToString();
		}

		private static AngleLimitSerializer AngleLimitsToSerializer(AngleLimits sourceLimits)
		{
			return new AngleLimitSerializer
			{
				enabled = sourceLimits.active,
				min = sourceLimits.min,
				max = sourceLimits.max
			};
		}

		private static SpringBoneBaseSerializer SpringBoneToBaseSerializer(SpringBone sourceBone)
		{
			return new SpringBoneBaseSerializer
			{
				boneName = sourceBone.name,
				radius = sourceBone.radius,
				stiffness = sourceBone.stiffnessForce,
				drag = sourceBone.dragForce,
				springForce = sourceBone.springForce,
				windInfluence = sourceBone.windInfluence,
				pivotName = ((sourceBone.pivotNode != null) ? sourceBone.pivotNode.name : ""),
				yAngleLimits = AngleLimitsToSerializer(sourceBone.yAngleLimits),
				zAngleLimits = AngleLimitsToSerializer(sourceBone.zAngleLimits),
				angularStiffness = sourceBone.angularStiffness,
				lengthLimits = (from item in sourceBone.lengthLimitTargets
					where item != null
					select new LengthLimitSerializer
					{
						objectName = item.name,
						ratio = 1.01f
					}).ToArray()
			};
		}

		private static PivotSerializer PivotToSerializer(Transform sourcePivot)
		{
			return new PivotSerializer
			{
				name = sourcePivot.name,
				parentName = ((sourcePivot.parent != null) ? sourcePivot.parent.name : ""),
				eulerAngles = sourcePivot.localEulerAngles
			};
		}

		private static void AppendSpringBones(CSVBuilder builder, IEnumerable<SpringBone> springBones)
		{
			if (!springBones.Any())
			{
				return;
			}
			string[] list = new string[20]
			{
				"// bone", "radius", "stiffnessForce", "dragForce", "springForce x", "springForce y", "springForce z", "wind influence", "pivot node", "use y angle limit",
				"y angle min", "y angle max", "use z angle limit", "z angle min", "z angle max", "angle stiffness", "length limit count", "length limit target", "length limit ratio x N", "collider x N"
			};
			builder.AppendLine();
			builder.AppendLine("[SpringBones]");
			builder.AppendLine(list);
			foreach (SpringBone springBone in springBones)
			{
				SpringBoneBaseSerializer item2 = SpringBoneToBaseSerializer(springBone);
				builder.Append(item2);
				List<string> list2 = new List<string>();
				list2.AddRange(from item in springBone.sphereColliders
					where item != null
					select item.name);
				list2.AddRange(from item in springBone.capsuleColliders
					where item != null
					select item.name);
				list2.AddRange(from item in springBone.panelColliders
					where item != null
					select item.name);
				builder.AppendLine(list2.Distinct());
			}
		}

		private static void AppendPivots(CSVBuilder builder, IEnumerable<SpringBone> springBones)
		{
			IEnumerable<PivotSerializer> enumerable = from pivot in (from bone in springBones
					where bone.pivotNode != null && bone.pivotNode != bone.transform.parent && bone.pivotNode.parent != null
					select bone.pivotNode).Distinct()
				select PivotToSerializer(pivot);
			if (!enumerable.Any())
			{
				return;
			}
			string[] list = new string[5] { "// PivotName", "ParentName", "local rotation x", "y", "z" };
			builder.AppendLine();
			builder.AppendLine("[Pivots]");
			builder.AppendLine(list);
			foreach (PivotSerializer item in enumerable)
			{
				builder.Append(item);
				builder.AppendLine();
			}
		}

		private static string BuildSpringBoneSetupString(GameObject rootObject)
		{
			CSVBuilder cSVBuilder = new CSVBuilder();
			SpringBone[] componentsInChildren = rootObject.GetComponentsInChildren<SpringBone>(includeInactive: true);
			AppendSpringBones(cSVBuilder, componentsInChildren);
			AppendPivots(cSVBuilder, componentsInChildren);
			return cSVBuilder.ToString();
		}

		private static IEnumerable<PivotSerializer> SerializePivotRecords(IEnumerable<TextRecordParsing.Record> sourceRecords, List<DynamicsSetup.ParseMessage> errorRecords)
		{
			List<PivotSerializer> list = new List<PivotSerializer>(sourceRecords.Count());
			foreach (TextRecordParsing.Record sourceRecord in sourceRecords)
			{
				DynamicsSetup.ParseMessage error = null;
				PivotSerializer pivotSerializer = DynamicsSetup.SerializeObjectFromStrings<PivotSerializer>(sourceRecord.Items, null, ref error);
				if (pivotSerializer != null)
				{
					list.Add(pivotSerializer);
				}
				else
				{
					errorRecords.Add(error);
				}
			}
			return list;
		}

		private static IEnumerable<SpringBoneSerializer> SerializeSpringBoneRecords(IEnumerable<TextRecordParsing.Record> sourceRecords, List<DynamicsSetup.ParseMessage> errorRecords)
		{
			List<SpringBoneSerializer> list = new List<SpringBoneSerializer>(sourceRecords.Count());
			foreach (TextRecordParsing.Record sourceRecord in sourceRecords)
			{
				Queue<string> queue = sourceRecord.ToQueue();
				SpringBoneBaseSerializer springBoneBaseSerializer = null;
				DynamicsSetup.ParseMessage item2 = null;
				try
				{
					springBoneBaseSerializer = queue.DequeueObject<SpringBoneBaseSerializer>();
				}
				catch (Exception ex)
				{
					item2 = new DynamicsSetup.ParseMessage("Error building SpringBoneBaseSerializer", sourceRecord.Items, ex.ToString());
				}
				if (springBoneBaseSerializer != null)
				{
					IEnumerable<string> source = new List<string>(queue).Where((string item) => item.Length > 0);
					SpringBoneSerializer item3 = new SpringBoneSerializer
					{
						baseData = springBoneBaseSerializer,
						colliderNames = source.ToArray()
					};
					list.Add(item3);
				}
				else
				{
					errorRecords.Add(item2);
				}
			}
			return list;
		}

		private static bool VerifyPivotRecords(IEnumerable<PivotSerializer> sourceRecords, IEnumerable<string> validParentNames, List<PivotSerializer> validRecords, List<DynamicsSetup.ParseMessage> errors)
		{
			List<PivotSerializer> list = new List<PivotSerializer>(sourceRecords.Count());
			foreach (PivotSerializer sourceRecord in sourceRecords)
			{
				DynamicsSetup.ParseMessage parseMessage = null;
				if (sourceRecord.name.Length == 0)
				{
					parseMessage = new DynamicsSetup.ParseMessage("");
				}
				string parentName = sourceRecord.parentName;
				if (parentName.Length == 0)
				{
					parseMessage = new DynamicsSetup.ParseMessage(sourceRecord.name + " : ");
				}
				else if (!validParentNames.Contains(parentName))
				{
					parseMessage = new DynamicsSetup.ParseMessage(sourceRecord.name + " : : " + parentName);
				}
				if (parseMessage == null)
				{
					list.Add(sourceRecord);
				}
				else
				{
					errors.Add(parseMessage);
				}
			}
			validRecords.AddRange(list);
			return sourceRecords.Count() == list.Count();
		}

		private static bool VerifySpringBoneRecords(IEnumerable<SpringBoneSerializer> sourceRecords, IEnumerable<string> validBoneNames, IEnumerable<string> validPivotNames, IEnumerable<string> validColliderNames, List<SpringBoneSerializer> validRecords, out bool hasMissingColliders, List<DynamicsSetup.ParseMessage> errors)
		{
			hasMissingColliders = false;
			List<SpringBoneSerializer> list = new List<SpringBoneSerializer>(sourceRecords.Count());
			foreach (SpringBoneSerializer sourceRecord in sourceRecords)
			{
				DynamicsSetup.ParseMessage parseMessage = null;
				SpringBoneBaseSerializer baseData = sourceRecord.baseData;
				if (baseData.boneName.Length == 0)
				{
					parseMessage = new DynamicsSetup.ParseMessage("");
				}
				else if (!validBoneNames.Contains(baseData.boneName))
				{
					parseMessage = new DynamicsSetup.ParseMessage(baseData.boneName + " : ");
				}
				string pivotName = baseData.pivotName;
				if (pivotName.Length == 0)
				{
					parseMessage = new DynamicsSetup.ParseMessage(baseData.boneName + " : ");
				}
				else if (!validPivotNames.Contains(pivotName))
				{
					parseMessage = new DynamicsSetup.ParseMessage(baseData.boneName + " : : " + pivotName);
				}
				IEnumerable<string> source = sourceRecord.colliderNames.Where((string name) => !validColliderNames.Contains(name));
				if (source.Any())
				{
					hasMissingColliders = true;
					UnityEngine.Debug.LogWarning(baseData.boneName + " : :\n" + string.Join(" ", source.ToArray()));
				}
				if (parseMessage == null)
				{
					list.Add(sourceRecord);
				}
				else
				{
					errors.Add(parseMessage);
				}
			}
			validRecords.AddRange(list);
			return sourceRecords.Count() == list.Count();
		}

		private static AngleLimits BuildAngleLimitsFromSerializer(AngleLimitSerializer serializer)
		{
			return new AngleLimits
			{
				active = serializer.enabled,
				min = serializer.min,
				max = serializer.max
			};
		}

		private static Transform FindChildByName(Transform parent, string name)
		{
			for (int i = 0; i < parent.childCount; i++)
			{
				Transform child = parent.GetChild(i);
				if (child.name.ToLowerInvariant() == name.ToLowerInvariant())
				{
					return child;
				}
			}
			return null;
		}

		private static bool BuildPivotFromSerializer(Dictionary<string, Transform> transforms, PivotSerializer serializer)
		{
			Transform value;
			bool flag = transforms.TryGetValue(serializer.parentName, out value);
			if (flag)
			{
				Transform transform = FindChildByName(value, serializer.name);
				if (transform == null)
				{
					transform = new GameObject(serializer.name, typeof(SpringBonePivot)).transform;
					transform.parent = value;
				}
				transform.localScale = Vector3.one;
				transform.localEulerAngles = serializer.eulerAngles;
				transform.localPosition = Vector3.zero;
			}
			return flag;
		}

		private static bool BuildSpringBoneFromSerializer(SpringBoneSetupMaps setupMaps, SpringBoneSerializer serializer)
		{
			SpringBoneBaseSerializer baseData = serializer.baseData;
			Transform value = null;
			if (!setupMaps.allChildren.TryGetValue(baseData.boneName, out value))
			{
				UnityEngine.Debug.LogError(": " + baseData.boneName);
				return false;
			}
			SpringBone springBone = value.gameObject.AddComponent<SpringBone>();
			springBone.stiffnessForce = baseData.stiffness;
			springBone.dragForce = baseData.drag;
			springBone.springForce = baseData.springForce;
			springBone.windInfluence = baseData.windInfluence;
			springBone.angularStiffness = baseData.angularStiffness;
			springBone.yAngleLimits = BuildAngleLimitsFromSerializer(baseData.yAngleLimits);
			springBone.zAngleLimits = BuildAngleLimitsFromSerializer(baseData.zAngleLimits);
			springBone.radius = baseData.radius;
			string pivotName = baseData.pivotName;
			Transform value2 = null;
			if (pivotName.Length > 0 && !setupMaps.allChildren.TryGetValue(pivotName, out value2))
			{
				UnityEngine.Debug.LogError("Pivot: " + pivotName);
				value2 = null;
			}
			if (value2 == null)
			{
				value2 = springBone.transform.parent ?? springBone.transform;
			}
			else
			{
				IEnumerable<Transform> allBones = springBone.transform.root.gameObject.GetAllBones();
				if ((bool)value2.GetComponent<SpringBonePivot>() && SpringBoneSetup.IsPivotProbablySafeToDestroy(value2, allBones))
				{
					value2.position = springBone.transform.position;
				}
			}
			springBone.pivotNode = value2;
			springBone.lengthLimitTargets = (from lengthLimit in baseData.lengthLimits
				where setupMaps.allChildren.ContainsKey(lengthLimit.objectName)
				select setupMaps.allChildren[lengthLimit.objectName]).ToArray();
			springBone.sphereColliders = (from name in serializer.colliderNames
				where setupMaps.sphereColliders.ContainsKey(name)
				select setupMaps.sphereColliders[name]).ToArray();
			springBone.capsuleColliders = (from name in serializer.colliderNames
				where setupMaps.capsuleColliders.ContainsKey(name)
				select setupMaps.capsuleColliders[name]).ToArray();
			springBone.panelColliders = (from name in serializer.colliderNames
				where setupMaps.panelColliders.ContainsKey(name)
				select setupMaps.panelColliders[name]).ToArray();
			return true;
		}
	}
	public static class SpringBoneSetup
	{
		public static void DestroyUnityObject(UnityEngine.Object objectToDestroy)
		{
			UnityEngine.Object.DestroyImmediate(objectToDestroy);
		}

		public static void DestroySpringManagersAndBones(GameObject rootObject)
		{
			DestroyPivotObjects(rootObject);
			SpringManager[] componentsInChildren = rootObject.GetComponentsInChildren<SpringManager>(includeInactive: true);
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				DestroyUnityObject(componentsInChildren[i]);
			}
			SpringBone[] componentsInChildren2 = rootObject.GetComponentsInChildren<SpringBone>(includeInactive: true);
			for (int i = 0; i < componentsInChildren2.Length; i++)
			{
				DestroyUnityObject(componentsInChildren2[i]);
			}
		}

		public static void FindAndAssignSpringBones(SpringManager springManager, bool includeInactive = false)
		{
			if (springManager != null)
			{
				List<SpringBone> springBonesSortedByDepth = GetSpringBonesSortedByDepth(springManager.gameObject, includeInactive);
				springManager.springBones = springBonesSortedByDepth.ToArray();
			}
		}

		public static void AssignSpringBonesRecursively(Transform rootObject)
		{
			if (rootObject.childCount != 0)
			{
				if (rootObject.gameObject.GetComponent<SpringBone>() == null)
				{
					rootObject.gameObject.AddComponent<SpringBone>();
				}
				for (int i = 0; i < rootObject.childCount; i++)
				{
					AssignSpringBonesRecursively(rootObject.GetChild(i));
				}
			}
		}

		public static Dictionary<Transform, List<SpringBone>> GetPivotToSpringBoneMap(GameObject rootObject)
		{
			IEnumerable<Transform> skinBones = rootObject.GetAllBones();
			IEnumerable<SpringBone> enumerable = from bone in rootObject.GetComponentsInChildren<SpringBone>(includeInactive: true)
				where bone.pivotNode != null && !skinBones.Contains(bone.pivotNode)
				select bone;
			Dictionary<Transform, List<SpringBone>> dictionary = new Dictionary<Transform, List<SpringBone>>();
			foreach (SpringBone item in enumerable)
			{
				List<SpringBone> value = null;
				if (!dictionary.TryGetValue(item.pivotNode, out value))
				{
					value = new List<SpringBone>();
				}
				value.Add(item);
				dictionary[item.pivotNode] = value;
			}
			return dictionary;
		}

		public static void FixAllPivotNodePositions(GameObject rootObject)
		{
			foreach (KeyValuePair<Transform, List<SpringBone>> item in GetPivotToSpringBoneMap(rootObject))
			{
				Vector3 zero = Vector3.zero;
				List<SpringBone> value = item.Value;
				foreach (SpringBone item2 in value)
				{
					zero += item2.transform.position;
				}
				zero /= (float)value.Count;
				item.Key.position = zero;
			}
		}

		public static GameObject CreateSpringPivotNode(SpringBone springBone)
		{
			GameObject gameObject = new GameObject(springBone.name + "_Pivot");
			gameObject.transform.parent = springBone.transform.parent;
			gameObject.transform.rotation = GetPivotRotation(springBone);
			gameObject.transform.position = springBone.transform.position;
			gameObject.AddComponent<SpringBonePivot>();
			Transform pivotNode = springBone.pivotNode;
			if (pivotNode != null)
			{
				IEnumerable<Transform> allBones = springBone.transform.root.gameObject.GetAllBones();
				if (IsPivotProbablySafeToDestroy(pivotNode, allBones))
				{
					DestroyUnityObject(pivotNode.gameObject);
				}
			}
			springBone.pivotNode = gameObject.transform;
			springBone.yAngleLimits.active = true;
			if (springBone.yAngleLimits.min > -0.5f && springBone.yAngleLimits.max < 0.5f)
			{
				springBone.yAngleLimits.min = -20f;
				springBone.yAngleLimits.max = 20f;
			}
			springBone.zAngleLimits.active = true;
			if (springBone.zAngleLimits.min > -0.5f && springBone.zAngleLimits.max < 0.5f)
			{
				springBone.zAngleLimits.min = 0f;
				springBone.zAngleLimits.max = 20f;
			}
			return gameObject;
		}

		public static bool IsPivotProbablySafeToDestroy(Transform pivot, IEnumerable<Transform> skinBones)
		{
			if (skinBones.Contains(pivot) || pivot.childCount > 0 || pivot.GetComponent<Renderer>() != null)
			{
				return false;
			}
			if (pivot.GetComponent<SpringBonePivot>() != null)
			{
				return true;
			}
			return pivot.name.ToLowerInvariant().EndsWith("_pivot");
		}

		private static void DestroyPivotObjects(GameObject rootObject)
		{
			if (!(rootObject == null))
			{
				IEnumerable<Transform> source = from springBone in rootObject.GetComponentsInChildren<SpringBone>(includeInactive: true)
					where springBone.pivotNode != null
					select springBone.pivotNode;
				IEnumerable<Transform> skinBones = rootObject.GetAllBones();
				List<GameObject> list = (from pivot in source
					where IsPivotProbablySafeToDestroy(pivot, skinBones)
					select pivot.gameObject).ToList();
				int count = list.Count;
				for (int i = 0; i < count; i++)
				{
					DestroyUnityObject(list[i]);
				}
			}
		}

		private static bool IsPivotSideDirectionValid(Vector3 lookDirection, Vector3 sideDirection)
		{
			if (sideDirection.sqrMagnitude >= 0.1f)
			{
				return Mathf.Abs(Vector3.Dot(lookDirection, sideDirection)) < 0.99f;
			}
			return false;
		}

		private static Vector3 FindClosestMeshNormalToPoint(Transform rootObject, Vector3 sourcePoint)
		{
			IEnumerable<Mesh> enumerable = from renderer in rootObject.GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true)
				select renderer.sharedMesh into mesh
				where mesh != null && mesh.vertexCount > 0
				select mesh;
			float num = 1000000f;
			Vector3 result = Vector3.up;
			foreach (Mesh item in enumerable)
			{
				Vector3[] vertices = item.vertices;
				Vector3[] normals = item.normals;
				if (vertices == null || normals == null || vertices.Length != normals.Length)
				{
					continue;
				}
				int num2 = -1;
				int num3 = vertices.Length;
				for (int i = 0; i < num3; i++)
				{
					float sqrMagnitude = (vertices[i] - sourcePoint).sqrMagnitude;
					if (sqrMagnitude < num)
					{
						num2 = i;
						num = sqrMagnitude;
					}
				}
				if (num2 != -1)
				{
					result = item.normals[num2];
				}
			}
			return result;
		}

		private static bool TryToGetPivotSideDirection(SpringBone springBone, Vector3 lookDirection, out Vector3 sideDirection)
		{
			sideDirection = Vector3.up;
			Vector3 normalized = Vector3.Cross(FindClosestMeshNormalToPoint(springBone.transform.root, springBone.transform.position), lookDirection).normalized;
			Vector3 normalized2 = Vector3.Cross(lookDirection, normalized).normalized;
			bool num = IsPivotSideDirectionValid(lookDirection, normalized2);
			if (num)
			{
				sideDirection = normalized2;
			}
			return num;
		}

		private static Quaternion GetPivotRotation(SpringBone springBone)
		{
			Vector3 vector = springBone.ComputeChildPosition() - springBone.transform.position;
			vector.Normalize();
			if (!TryToGetPivotSideDirection(springBone, vector, out var sideDirection))
			{
				sideDirection = springBone.transform.position;
				sideDirection.y = 0f;
				sideDirection.Normalize();
				if (!IsPivotSideDirectionValid(vector, sideDirection))
				{
					sideDirection = Vector3.up;
					if (!IsPivotSideDirectionValid(vector, sideDirection))
					{
						sideDirection = Vector3.forward;
					}
				}
			}
			Vector3 position = springBone.transform.position;
			position.y = 0f;
			if (Vector3.Dot(sideDirection, position) < 0f)
			{
				sideDirection = -sideDirection;
			}
			Vector3 normalized = Vector3.Cross(vector, sideDirection).normalized;
			Quaternion quaternion = Quaternion.LookRotation(vector, normalized);
			Quaternion quaternion2 = Quaternion.Euler(180f, 90f, 0f);
			return quaternion * quaternion2;
		}

		private static List<SpringBone> GetSpringBonesSortedByDepth(GameObject rootObject, bool includeInactive)
		{
			var list = (from bone in rootObject.GetComponentsInChildren<SpringBone>(includeInactive)
				select new
				{
					bone = bone,
					depth = GameObjectUtil.GetTransformDepth(bone.transform)
				}).ToList();
			list.Sort((a, b) => a.depth.CompareTo(b.depth));
			return list.Select(item => item.bone).ToList();
		}
	}
	public static class SpringColliderSerialization
	{
		public class ParsedColliderSetup
		{
			private IEnumerable<IColliderSerializer> colliderRecords;

			private IEnumerable<TransformSerializer> dynamicsNullRecords;

			private List<TextRecordParsing.Record> componentRecords;

			public IEnumerable<DynamicsSetup.ParseMessage> Errors { get; set; }

			public static ParsedColliderSetup ReadColliderSetupFromText(GameObject colliderRoot, string recordText)
			{
				List<TextRecordParsing.Record> list = null;
				List<TextRecordParsing.Record> list2 = null;
				List<TextRecordParsing.Record> list3 = null;
				try
				{
					List<TextRecordParsing.Record> sourceRecords = TextRecordParsing.ParseRecordsFromText(recordText);
					TextRecordParsing.Record versionRecord = null;
					DynamicsSetup.GetVersionFromSetupRecords(sourceRecords, out versionRecord);
					list = TextRecordParsing.GetSectionRecords(sourceRecords, "Colliders");
					if (versionRecord == null && (list == null || list.Count == 0))
					{
						list = TextRecordParsing.GetSectionRecords(sourceRecords, null);
					}
					list2 = TextRecordParsing.GetSectionRecords(sourceRecords, "DynamicsNulls");
					list3 = TextRecordParsing.GetSectionRecords(sourceRecords, "Components");
				}
				catch (Exception ex)
				{
					UnityEngine.Debug.LogError("SpringColliderSetup: \n\n" + ex.ToString());
					return null;
				}
				List<DynamicsSetup.ParseMessage> list4 = new List<DynamicsSetup.ParseMessage>();
				IEnumerable<IColliderSerializer> enumerable = SerializeColliderRecords(list, list4);
				IEnumerable<TransformSerializer> sourceRecords2 = SerializeTransformRecords(list2, list4);
				List<string> list5 = (from item in colliderRoot.GetComponentsInChildren<Transform>(includeInactive: true)
					select item.name).ToList();
				List<TransformSerializer> list6 = new List<TransformSerializer>();
				VerifyTransformRecords(sourceRecords2, list5, list6, list4);
				list5.AddRange(list6.Select((TransformSerializer item) => item.name));
				List<IColliderSerializer> validRecords = new List<IColliderSerializer>();
				VerifyColliderRecords(enumerable, colliderRoot, list5, validRecords, list4);
				return new ParsedColliderSetup
				{
					colliderRecords = validRecords,
					dynamicsNullRecords = list6,
					componentRecords = list3,
					Errors = list4
				};
			}

			public void BuildObjects(GameObject colliderRoot)
			{
				SpringColliderSetup.DestroySpringColliders(colliderRoot);
				Dictionary<string, Transform> objectMap = colliderRoot.BuildNameToComponentMap<Transform>(includeInactive: true);
				BuildDynamicsNulls(objectMap, dynamicsNullRecords);
				objectMap = colliderRoot.BuildNameToComponentMap<Transform>(includeInactive: true);
				foreach (IColliderSerializer colliderRecord in colliderRecords)
				{
					BuildColliderFromRecord(objectMap, colliderRecord);
				}
				objectMap = colliderRoot.BuildNameToComponentMap<Transform>(includeInactive: true);
				BuildComponents(objectMap, componentRecords);
			}

			public IEnumerable<string> GetColliderNames()
			{
				return colliderRecords.Select((IColliderSerializer item) => item.GetBaseInfo().transform.name);
			}
		}

		private class TransformSerializer
		{
			public string name;

			public string parentName;

			public Vector3 position;

			public Vector3 eulerAngles;

			public Vector3 scale;
		}

		private class ColliderSerializerBaseInfo
		{
			public TransformSerializer transform;

			public string colliderType;
		}

		private interface IColliderSerializer
		{
			ColliderSerializerBaseInfo GetBaseInfo();

			Component BuildColliderComponent(GameObject gameObject);

			string GetLinkedRendererName();
		}

		private class SphereColliderSerializer : IColliderSerializer
		{
			public ColliderSerializerBaseInfo baseInfo;

			public float radius;

			public string linkedRenderer;

			public ColliderSerializerBaseInfo GetBaseInfo()
			{
				return baseInfo;
			}

			public Component BuildColliderComponent(GameObject gameObject)
			{
				SpringSphereCollider springSphereCollider = gameObject.AddComponent<SpringSphereCollider>();
				springSphereCollider.radius = radius;
				if (!string.IsNullOrEmpty(linkedRenderer))
				{
					springSphereCollider.linkedRenderer = TryToFindComponent<Renderer>(gameObject, linkedRenderer);
				}
				return springSphereCollider;
			}

			public string GetLinkedRendererName()
			{
				return linkedRenderer;
			}
		}

		private class CapsuleColliderSerializer : IColliderSerializer
		{
			public ColliderSerializerBaseInfo baseInfo;

			public float radius;

			public float height;

			public string linkedRenderer;

			public ColliderSerializerBaseInfo GetBaseInfo()
			{
				return baseInfo;
			}

			public Component BuildColliderComponent(GameObject gameObject)
			{
				SpringCapsuleCollider springCapsuleCollider = gameObject.AddComponent<SpringCapsuleCollider>();
				springCapsuleCollider.radius = radius;
				springCapsuleCollider.height = height;
				if (!string.IsNullOrEmpty(linkedRenderer))
				{
					springCapsuleCollider.linkedRenderer = TryToFindComponent<Renderer>(gameObject, linkedRenderer);
				}
				return springCapsuleCollider;
			}

			public string GetLinkedRendererName()
			{
				return linkedRenderer;
			}
		}

		private class PanelColliderSerializer : IColliderSerializer
		{
			public ColliderSerializerBaseInfo baseInfo;

			public float width;

			public float height;

			public string linkedRenderer;

			public ColliderSerializerBaseInfo GetBaseInfo()
			{
				return baseInfo;
			}

			public Component BuildColliderComponent(GameObject gameObject)
			{
				SpringPanelCollider springPanelCollider = gameObject.AddComponent<SpringPanelCollider>();
				springPanelCollider.width = width;
				springPanelCollider.height = height;
				if (!string.IsNullOrEmpty(linkedRenderer))
				{
					springPanelCollider.linkedRenderer = TryToFindComponent<Renderer>(gameObject, linkedRenderer);
				}
				return springPanelCollider;
			}

			public string GetLinkedRendererName()
			{
				return linkedRenderer;
			}
		}

		private const string SphereColliderToken = "sp";

		private const string CapsuleColliderToken = "cp";

		private const string PanelColliderToken = "pa";

		public static string BuildCollisionSetupString(GameObject colliderRoot)
		{
			CSVBuilder cSVBuilder = new CSVBuilder();
			AppendColliders(cSVBuilder, colliderRoot);
			AppendDynamicsNulls(cSVBuilder, colliderRoot);
			return cSVBuilder.ToString() + BuildComponentDefinitionString(colliderRoot);
		}

		private static void AppendColliders(CSVBuilder builder, GameObject colliderRoot)
		{
			IEnumerable<SphereColliderSerializer> enumerable = from item in colliderRoot.GetComponentsInChildren<SpringSphereCollider>(includeInactive: true)
				select SphereColliderToSerializer(item);
			IEnumerable<CapsuleColliderSerializer> enumerable2 = from item in colliderRoot.GetComponentsInChildren<SpringCapsuleCollider>(includeInactive: true)
				select CapsuleColliderToSerializer(item);
			IEnumerable<PanelColliderSerializer> enumerable3 = from item in colliderRoot.GetComponentsInChildren<SpringPanelCollider>(includeInactive: true)
				select PanelColliderToSerializer(item);
			if (!enumerable.Any() && !enumerable2.Any() && !enumerable3.Any())
			{
				return;
			}
			string[][] obj = new string[4][]
			{
				new string[13]
				{
					"// ColliderName", "ParentName", "pos x", "y", "z", "rot x", "y", "z", "scale x", "y",
					"z", "ColliderType", "Parameters"
				},
				new string[14]
				{
					"//", "", "", "", "", "", "", "", "", "",
					"", "Sp (Sphere)", "radius", "linkedRenderer"
				},
				new string[15]
				{
					"//", "", "", "", "", "", "", "", "", "",
					"", "Cp (Capsule)", "radius", "height", "linkedRenderer"
				},
				new string[15]
				{
					"//", "", "", "", "", "", "", "", "", "",
					"", "Pa (Panel)", "width", "height", "linkedRenderer"
				}
			};
			builder.AppendLine();
			builder.AppendLine("[Colliders]");
			string[][] array = obj;
			foreach (string[] list in array)
			{
				builder.AppendLine(list);
			}
			foreach (SphereColliderSerializer item in enumerable)
			{
				builder.Append(item);
				builder.AppendLine();
			}
			foreach (CapsuleColliderSerializer item2 in enumerable2)
			{
				builder.Append(item2);
				builder.AppendLine();
			}
			foreach (PanelColliderSerializer item3 in enumerable3)
			{
				builder.Append(item3);
				builder.AppendLine();
			}
		}

		private static string GetComponentName(Component component)
		{
			if (!(component != null))
			{
				return "";
			}
			return component.name;
		}

		private static TransformSerializer TransformToSerializer(Transform sourceTransform)
		{
			return new TransformSerializer
			{
				name = sourceTransform.name,
				parentName = GetComponentName(sourceTransform.parent),
				position = sourceTransform.localPosition,
				eulerAngles = sourceTransform.localEulerAngles,
				scale = sourceTransform.localScale
			};
		}

		private static ColliderSerializerBaseInfo TransformToColliderSerializerBaseInfo(Transform sourceTransform, string colliderType)
		{
			return new ColliderSerializerBaseInfo
			{
				transform = TransformToSerializer(sourceTransform),
				colliderType = colliderType
			};
		}

		private static SphereColliderSerializer SphereColliderToSerializer(SpringSphereCollider sourceCollider)
		{
			return new SphereColliderSerializer
			{
				baseInfo = TransformToColliderSerializerBaseInfo(sourceCollider.transform, "sp"),
				radius = sourceCollider.radius,
				linkedRenderer = GetComponentName(sourceCollider.linkedRenderer)
			};
		}

		private static CapsuleColliderSerializer CapsuleColliderToSerializer(SpringCapsuleCollider sourceCollider)
		{
			return new CapsuleColliderSerializer
			{
				baseInfo = TransformToColliderSerializerBaseInfo(sourceCollider.transform, "cp"),
				radius = sourceCollider.radius,
				height = sourceCollider.height,
				linkedRenderer = GetComponentName(sourceCollider.linkedRenderer)
			};
		}

		private static PanelColliderSerializer PanelColliderToSerializer(SpringPanelCollider sourceCollider)
		{
			return new PanelColliderSerializer
			{
				baseInfo = TransformToColliderSerializerBaseInfo(sourceCollider.transform, "pa"),
				width = sourceCollider.width,
				height = sourceCollider.height,
				linkedRenderer = GetComponentName(sourceCollider.linkedRenderer)
			};
		}

		private static void AppendDynamicsNulls(CSVBuilder builder, GameObject rootObject)
		{
			IEnumerable<TransformSerializer> enumerable = from item in rootObject.GetComponentsInChildren<DynamicsNull>(includeInactive: true)
				select TransformToSerializer(item.transform);
			if (!enumerable.Any())
			{
				return;
			}
			builder.AppendLine();
			builder.AppendLine("[DynamicsNulls]");
			foreach (TransformSerializer item in enumerable)
			{
				builder.Append(item);
				builder.AppendLine();
			}
		}

		private static string BuildComponentDefinitionString(GameObject colliderRoot)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("\n");
			stringBuilder.Append("[Components]");
			stringBuilder.Append("\n");
			IEnumerable<SpringSetupComponentDefiners.ComponentDefiner> componentDefiners = SpringSetupComponentDefiners.GetComponentDefiners();
			Transform[] componentsInChildren = colliderRoot.GetComponentsInChildren<Transform>(includeInactive: true);
			bool flag = false;
			Transform[] array = componentsInChildren;
			foreach (Transform transform in array)
			{
				bool flag2 = false;
				StringBuilder stringBuilder2 = new StringBuilder();
				foreach (SpringSetupComponentDefiners.ComponentDefiner item in componentDefiners)
				{
					if (item.TryToAppendDefinition(stringBuilder2, transform.gameObject))
					{
						flag2 = true;
					}
				}
				if (flag2)
				{
					AppendRecordItem(stringBuilder, transform.name);
					AppendRecordItem(stringBuilder, stringBuilder2.ToString());
					stringBuilder.Append("\n");
					flag = true;
				}
			}
			if (!flag)
			{
				return "";
			}
			return stringBuilder.ToString();
		}

		private static void AppendRecordItem<T>(StringBuilder builder, T item, char separator = ',')
		{
			builder.Append(item);
			builder.Append(separator);
		}

		private static Transform CreateNewGameObject(Transform parent, string name)
		{
			GameObject gameObject = new GameObject(name);
			if (gameObject == null)
			{
				UnityEngine.Debug.LogError(": " + name);
				return null;
			}
			gameObject.transform.parent = parent;
			return gameObject.transform;
		}

		private static Transform GetChildByName(Transform parent, string name)
		{
			return (from index in Enumerable.Range(0, parent.childCount)
				select parent.GetChild(index) into child
				where child.name == name
				select child).FirstOrDefault();
		}

		private static T TryToFindComponent<T>(GameObject gameObject, string name) where T : Component
		{
			T result = null;
			if (name.Length > 0)
			{
				return gameObject.transform.root.gameObject.FindChildComponentByName<T>(name);
			}
			return result;
		}

		private static IEnumerable<IColliderSerializer> SerializeColliderRecords(IEnumerable<TextRecordParsing.Record> sourceRecords, List<DynamicsSetup.ParseMessage> errorRecords)
		{
			Dictionary<string, Type> dictionary = new Dictionary<string, Type>
			{
				{
					"sp",
					typeof(SphereColliderSerializer)
				},
				{
					"cp",
					typeof(CapsuleColliderSerializer)
				},
				{
					"pa",
					typeof(PanelColliderSerializer)
				}
			};
			List<IColliderSerializer> list = new List<IColliderSerializer>(sourceRecords.Count());
			foreach (TextRecordParsing.Record sourceRecord in sourceRecords)
			{
				IColliderSerializer colliderSerializer = null;
				DynamicsSetup.ParseMessage error = null;
				ColliderSerializerBaseInfo colliderSerializerBaseInfo = DynamicsSetup.SerializeObjectFromStrings<ColliderSerializerBaseInfo>(sourceRecord.Items, null, ref error);
				if (colliderSerializerBaseInfo != null)
				{
					if (dictionary.TryGetValue(colliderSerializerBaseInfo.colliderType, out var value))
					{
						colliderSerializer = DynamicsSetup.SerializeObjectFromStrings(value, sourceRecord.Items, "linkedRenderer", ref error) as IColliderSerializer;
					}
					else
					{
						error = new DynamicsSetup.ParseMessage("Invalid collider type: " + colliderSerializerBaseInfo.colliderType, sourceRecord.Items);
					}
				}
				if (colliderSerializer != null)
				{
					list.Add(colliderSerializer);
				}
				else
				{
					errorRecords.Add(error);
				}
			}
			return list;
		}

		private static IEnumerable<TransformSerializer> SerializeTransformRecords(IEnumerable<TextRecordParsing.Record> sourceRecords, List<DynamicsSetup.ParseMessage> errorRecords)
		{
			List<TransformSerializer> list = new List<TransformSerializer>(sourceRecords.Count());
			foreach (TextRecordParsing.Record sourceRecord in sourceRecords)
			{
				DynamicsSetup.ParseMessage error = null;
				TransformSerializer transformSerializer = DynamicsSetup.SerializeObjectFromStrings<TransformSerializer>(sourceRecord.Items, null, ref error);
				if (transformSerializer != null)
				{
					list.Add(transformSerializer);
				}
				else
				{
					errorRecords.Add(error);
				}
			}
			return list;
		}

		private static bool VerifyTransformRecord(TransformSerializer transformSerializer, IEnumerable<string> validParentNames, out DynamicsSetup.ParseMessage error)
		{
			error = null;
			string name = transformSerializer.name;
			if (name.Length == 0)
			{
				error = new DynamicsSetup.ParseMessage("");
			}
			string parentName = transformSerializer.parentName;
			if (parentName.Length == 0)
			{
				error = new DynamicsSetup.ParseMessage(name + " : ");
			}
			else if (!validParentNames.Contains(parentName))
			{
				error = new DynamicsSetup.ParseMessage(name + " : : " + parentName);
			}
			return error == null;
		}

		private static bool VerifyTransformRecords(IEnumerable<TransformSerializer> sourceRecords, IEnumerable<string> validParentNames, List<TransformSerializer> validRecords, List<DynamicsSetup.ParseMessage> errors)
		{
			List<TransformSerializer> list = new List<TransformSerializer>(sourceRecords.Count());
			foreach (TransformSerializer sourceRecord in sourceRecords)
			{
				DynamicsSetup.ParseMessage error = null;
				bool flag = VerifyTransformRecord(sourceRecord, validParentNames, out error);
				if (flag && list.Any((TransformSerializer item) => item.name == sourceRecord.name))
				{
					error = new DynamicsSetup.ParseMessage(sourceRecord.name + " : ");
					flag = false;
				}
				if (flag)
				{
					list.Add(sourceRecord);
				}
				else
				{
					errors.Add(error);
				}
			}
			validRecords.AddRange(list);
			return sourceRecords.Count() == list.Count;
		}

		private static bool VerifyColliderRecords(IEnumerable<IColliderSerializer> colliderRecords, GameObject rootObject, IEnumerable<string> validParentNames, List<IColliderSerializer> validRecords, List<DynamicsSetup.ParseMessage> errors)
		{
			List<IColliderSerializer> list = new List<IColliderSerializer>(colliderRecords.Count());
			foreach (IColliderSerializer colliderRecord in colliderRecords)
			{
				DynamicsSetup.ParseMessage error = null;
				string objectName = colliderRecord.GetBaseInfo().transform.name;
				bool flag = true;
				if (!VerifyTransformRecord(colliderRecord.GetBaseInfo().transform, validParentNames, out error))
				{
					flag = false;
				}
				string linkedRendererName = colliderRecord.GetLinkedRendererName();
				if (!string.IsNullOrEmpty(linkedRendererName) && rootObject.FindChildComponentByName<Renderer>(linkedRendererName) == null)
				{
					error = new DynamicsSetup.ParseMessage(objectName + " : linkedRenderer: " + linkedRendererName);
					flag = false;
				}
				if (list.Any((IColliderSerializer item) => item.GetBaseInfo().transform.name == objectName))
				{
					error = new DynamicsSetup.ParseMessage(objectName + " : ");
					flag = false;
				}
				if (flag)
				{
					list.Add(colliderRecord);
				}
				else
				{
					errors.Add(error);
				}
			}
			validRecords.AddRange(list);
			return colliderRecords.Count() == list.Count;
		}

		private static GameObject BuildTransformFromRecord(Dictionary<string, Transform> objectMap, TransformSerializer serializer)
		{
			Transform value = null;
			if (!objectMap.TryGetValue(serializer.parentName, out value))
			{
				UnityEngine.Debug.LogError(": " + serializer.parentName);
				return null;
			}
			Transform transform = GetChildByName(value, serializer.name);
			if (transform == null)
			{
				transform = CreateNewGameObject(value, serializer.name);
				if (transform == null)
				{
					return null;
				}
			}
			transform.localScale = serializer.scale;
			transform.localEulerAngles = serializer.eulerAngles;
			transform.localPosition = serializer.position;
			return transform.gameObject;
		}

		private static bool BuildColliderFromRecord(Dictionary<string, Transform> objectMap, IColliderSerializer colliderSerializer)
		{
			GameObject gameObject = BuildTransformFromRecord(objectMap, colliderSerializer.GetBaseInfo().transform);
			bool num = gameObject != null;
			if (num)
			{
				colliderSerializer.BuildColliderComponent(gameObject);
			}
			return num;
		}

		private static void BuildDynamicsNulls(Dictionary<string, Transform> objectMap, IEnumerable<TransformSerializer> records)
		{
			foreach (Transform value in objectMap.Values)
			{
				DynamicsNull[] components = value.gameObject.GetComponents<DynamicsNull>();
				for (int i = 1; i < components.Length; i++)
				{
					UnityEngine.Object.DestroyImmediate(components[i]);
				}
			}
			foreach (TransformSerializer record in records)
			{
				GameObject gameObject = BuildTransformFromRecord(objectMap, record);
				if (gameObject != null && gameObject.GetComponent<DynamicsNull>() == null)
				{
					gameObject.AddComponent<DynamicsNull>();
				}
			}
		}

		private static void BuildComponents(Dictionary<string, Transform> objectMap, IEnumerable<TextRecordParsing.Record> records)
		{
			IEnumerable<SpringSetupComponentDefiners.ComponentDefiner> componentDefiners = SpringSetupComponentDefiners.GetComponentDefiners();
			foreach (TextRecordParsing.Record record in records)
			{
				Transform value = null;
				if (!objectMap.TryGetValue(record.GetString(0), out value))
				{
					continue;
				}
				GameObject gameObject = value.gameObject;
				Queue<string> definitionItems = new Queue<string>(record.Items.Skip(1));
				foreach (SpringSetupComponentDefiners.ComponentDefiner item in componentDefiners)
				{
					item.BuildFromDefinition(gameObject, definitionItems);
				}
			}
		}
	}
	public static class SpringColliderSetup
	{
		public static IEnumerable<Type> GetColliderTypes()
		{
			return new Type[3]
			{
				typeof(SpringSphereCollider),
				typeof(SpringCapsuleCollider),
				typeof(SpringPanelCollider)
			};
		}

		public static void DestroySpringColliders(GameObject colliderRoot)
		{
			DestroyComponentsOfType<SpringSphereCollider>(colliderRoot);
			DestroyComponentsOfType<SpringCapsuleCollider>(colliderRoot);
			DestroyComponentsOfType<SpringPanelCollider>(colliderRoot);
			SpringBone[] componentsInChildren = colliderRoot.GetComponentsInChildren<SpringBone>(includeInactive: true);
			foreach (SpringBone obj in componentsInChildren)
			{
				obj.sphereColliders = obj.sphereColliders.Where((SpringSphereCollider collider) => collider != null).ToArray();
				obj.capsuleColliders = obj.capsuleColliders.Where((SpringCapsuleCollider collider) => collider != null).ToArray();
				obj.panelColliders = obj.panelColliders.Where((SpringPanelCollider collider) => collider != null).ToArray();
			}
		}

		private static void DestroyComponentsOfType<T>(GameObject rootObject) where T : Component
		{
			T[] componentsInChildren = rootObject.GetComponentsInChildren<T>(includeInactive: true);
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				DestroyUnityObject(componentsInChildren[i]);
			}
		}

		private static void DestroyUnityObject(UnityEngine.Object objectToDestroy)
		{
			UnityEngine.Object.DestroyImmediate(objectToDestroy);
		}
	}
	public class SpringSetupComponentDefiners
	{
		public class ComponentDefiner
		{
			protected Type componentType;

			public ComponentDefiner(Type newType)
			{
				componentType = newType;
			}

			public bool TryToAppendDefinition(StringBuilder builder, GameObject rootObject)
			{
				Component component = rootObject.GetComponent(componentType);
				bool num = component != null;
				if (num)
				{
					AppendDefinition(builder, component);
				}
				return num;
			}

			public void AppendDefinition(StringBuilder builder, Component component)
			{
				AppendRecordItem(builder, GetTypeToken());
				AppendProperties(builder, component);
			}

			public Component BuildFromDefinition(GameObject owner, Queue<string> definitionItems)
			{
				if (definitionItems.Peek() != GetTypeToken())
				{
					return null;
				}
				definitionItems.Dequeue();
				Component result = null;
				try
				{
					InternalBuildFromDefinition(owner, definitionItems);
				}
				catch (Exception ex)
				{
					UnityEngine.Debug.LogError(GetTypeToken() + " \n\n" + ex.ToString());
					result = null;
				}
				return result;
			}

			protected virtual string GetTypeToken()
			{
				return componentType.ToString();
			}

			protected virtual void AppendProperties(StringBuilder builder, Component component)
			{
				IEnumerable<string> source = UnityComponentStringListBuilder.BuildBuilderStringList(component);
				builder.Append(string.Join(",", source.ToArray()));
				builder.Append(",");
			}

			protected static void AppendRecordItem<T>(StringBuilder builder, T item, char separator = ',')
			{
				builder.Append(item);
				builder.Append(separator);
			}

			protected static string GetComponentName(Component component)
			{
				if (!(component != null))
				{
					return "";
				}
				return component.name;
			}

			protected virtual Component InternalBuildFromDefinition(GameObject owner, Queue<string> definitionItems)
			{
				Component[] components = owner.GetComponents(componentType);
				Component component = owner.AddComponent(componentType);
				GameObject gameObject = owner.transform.root.gameObject;
				if (definitionItems.DequeueComponent(component, gameObject))
				{
					Component[] array = components;
					for (int i = 0; i < array.Length; i++)
					{
						UnityEngine.Object.DestroyImmediate(array[i]);
					}
				}
				else
				{
					UnityEngine.Object.DestroyImmediate(component);
					component = null;
				}
				return component;
			}
		}

		public static IEnumerable<ComponentDefiner> GetComponentDefiners()
		{
			return new ComponentDefiner[1]
			{
				new ComponentDefiner(typeof(HighLeg))
			};
		}
	}
	public class SpringBone : MonoBehaviour
	{
		public enum CollisionStatus
		{
			NoCollision,
			HeadIsEmbedded,
			TailCollision
		}

		[Range(0f, 5000f)]
		public float stiffnessForce = 0.01f;

		[Range(0f, 1f)]
		public float dragForce = 0.4f;

		public Vector3 springForce = new Vector3(0f, -0.0001f, 0f);

		[Range(0f, 1f)]
		public float windInfluence = 1f;

		public Transform pivotNode;

		public float angularStiffness = 100f;

		public AngleLimits yAngleLimits = new AngleLimits();

		public AngleLimits zAngleLimits = new AngleLimits();

		public Transform[] lengthLimitTargets;

		[Range(0f, 0.5f)]
		public float radius = 0.05f;

		public SpringSphereCollider[] sphereColliders;

		public SpringCapsuleCollider[] capsuleColliders;

		public SpringPanelCollider[] panelColliders;

		public Transform MyTransform;

		public Transform MyParent;

		private SpringManager manager;

		private Vector3 boneAxis = new Vector3(-1f, 0f, 0f);

		private float springLength;

		private Quaternion skinAnimationLocalRotation;

		private Quaternion initialLocalRotation;

		private Quaternion actualLocalRotation;

		private Vector3 currTipPos;

		private Vector3 prevTipPos;

		private float[] lengthsToLimitTargets;

		private static Vector3 hitNormal = new Vector3(0f, 0f, 1f);

		public Vector3 CurrentTipPosition => currTipPos;

		public void Initialize(SpringManager owner)
		{
			manager = owner;
			MyTransform = base.transform;
			MyParent = MyTransform.parent;
			Vector3 position = ComputeChildPosition();
			boneAxis = MyTransform.InverseTransformPoint(position).normalized;
			initialLocalRotation = MyTransform.localRotation;
			actualLocalRotation = initialLocalRotation;
			sphereColliders = sphereColliders.Where((SpringSphereCollider item) => item != null).ToArray();
			capsuleColliders = capsuleColliders.Where((SpringCapsuleCollider item) => item != null).ToArray();
			panelColliders = panelColliders.Where((SpringPanelCollider item) => item != null).ToArray();
			lengthLimitTargets = ((lengthLimitTargets != null) ? lengthLimitTargets.Where((Transform target) => target != null).ToArray() : new Transform[0]);
			InitializeSpringLengthAndTipPosition();
			if ((object)pivotNode == null)
			{
				pivotNode = MyParent ?? MyTransform;
			}
		}

		public Vector3 ComputeChildPosition()
		{
			IList<Transform> validChildren = GetValidChildren(MyTransform);
			int count = validChildren.Count;
			switch (count)
			{
			case 0:
				UnityEngine.Debug.LogWarning("SpringBone" + base.name + "");
				return MyTransform.position + MyTransform.right * -0.1f;
			case 1:
				return validChildren[0].position;
			default:
			{
				Vector3 result = new Vector3(0f, 0f, 0f);
				float num = 0f;
				Vector3 right = MyTransform.position;
				for (int i = 0; i < count; i++)
				{
					Vector3 left = validChildren[i].position;
					result += left;
					num += Vector3Extension.Distance(ref left, ref right);
				}
				num /= (float)count;
				Vector3Extension.DivideOut(count, ref result);
				Vector3 v = Vector3Extension.Subtract(ref result, ref right);
				Vector3Extension.Normalize(ref v);
				Vector3Extension.MultiplyTarget(num, ref v);
				Vector3Extension.Add(ref right, ref v, out result);
				return result;
			}
			}
		}

		public void RemoveAllColliders()
		{
			sphereColliders = new SpringSphereCollider[0];
			capsuleColliders = new SpringCapsuleCollider[0];
			panelColliders = new SpringPanelCollider[0];
		}

		public void UpdateSpring(float deltaTime, Vector3 externalForce)
		{
			skinAnimationLocalRotation = MyTransform.localRotation;
			Vector3 a = MyTransform.position;
			Quaternion rotation = MyParent.rotation * initialLocalRotation;
			Vector3 target = Vector3Extension.Multiply(ref boneAxis, springLength);
			Vector3Extension.MultiplyTarget(ref rotation, ref target);
			Vector3 a2 = Vector3Extension.Add(ref a, ref target);
			Vector3Extension.Subtract(ref a2, ref currTipPos, out target);
			Vector3 result = default(Vector3);
			Vector3Extension.Multiply(ref target, stiffnessForce, out result);
			AddVectors(ref springForce, ref externalForce, ref result);
			float num = deltaTime * deltaTime;
			Vector3Extension.Multiply(ref result, 0.5f * num, out result);
			Vector3 vector = currTipPos;
			Vector3Extension.Subtract(ref currTipPos, ref prevTipPos, out target);
			target.Multiply(1f - dragForce);
			result.Add(ref target);
			currTipPos = Vector3Extension.Add(ref currTipPos, ref result);
			prevTipPos = vector;
			Vector3 a3 = Vector3Extension.Subtract(ref currTipPos, ref a);
			float num2 = a3.Length();
			a3 = ((num2 <= 0.001f) ? MyTransform.TransformDirection(boneAxis) : Vector3Extension.Divide(ref a3, num2));
			a3 = Vector3Extension.Multiply(ref a3, springLength);
			Vector3Extension.Add(ref a, ref a3, out currTipPos);
		}

		private void AddVectors(ref Vector3 left, ref Vector3 right, ref Vector3 target)
		{
			target.x += left.x + right.x;
			target.y += left.y + right.y;
			target.z += left.z + right.z;
		}

		public void SatisfyConstraintsAndComputeRotation(float deltaTime, float dynamicRatio)
		{
			if (manager.enableLengthLimits)
			{
				currTipPos = ApplyLengthLimits(deltaTime);
			}
			bool flag = false;
			if (manager.collideWithGround)
			{
				flag = CheckForGroundCollision();
			}
			if (manager.enableCollision && !flag)
			{
				flag = CheckForCollision();
			}
			if (manager.enableAngleLimits)
			{
				ApplyAngleLimits(deltaTime);
			}
			if (float.IsNaN(currTipPos.x) | float.IsNaN(currTipPos.y) | float.IsNaN(currTipPos.z))
			{
				Vector3 b = MyParent.rotation * initialLocalRotation * boneAxis * springLength;
				Vector3 a = MyTransform.position;
				Vector3Extension.Add(ref a, ref b, out currTipPos);
				prevTipPos = currTipPos;
			}
			actualLocalRotation = ComputeRotation(ref currTipPos);
			MyTransform.localRotation = Quaternion.Lerp(skinAnimationLocalRotation, actualLocalRotation, dynamicRatio);
		}

		public void ComputeRotation(float dynamicRatio)
		{
			if (float.IsNaN(currTipPos.x) | float.IsNaN(currTipPos.y) | float.IsNaN(currTipPos.z))
			{
				Quaternion quaternion = MyParent.rotation * initialLocalRotation;
				currTipPos = MyTransform.position + quaternion * Vector3Extension.Multiply(ref boneAxis, springLength);
				prevTipPos = currTipPos;
			}
			actualLocalRotation = ComputeRotation(ref currTipPos);
			MyTransform.localRotation = Quaternion.Lerp(skinAnimationLocalRotation, actualLocalRotation, dynamicRatio);
		}

		public Transform GetPivotTransform()
		{
			if ((object)pivotNode == null)
			{
				pivotNode = MyParent ?? MyTransform;
			}
			return pivotNode;
		}

		private static IList<Transform> GetValidChildren(Transform parent)
		{
			int childCount = parent.childCount;
			List<Transform> list = new List<Transform>(childCount);
			for (int i = 0; i < childCount; i++)
			{
				Transform child = parent.GetChild(i);
				if (child.GetComponent<SpringBonePivot>() == null)
				{
					list.Add(child);
				}
			}
			return list;
		}

		private void ApplyAngleLimits(float deltaTime)
		{
			if (yAngleLimits.active || zAngleLimits.active)
			{
				Vector3 b = MyTransform.position;
				Vector3 vector = Vector3Extension.Subtract(ref currTipPos, ref b);
				Quaternion rotation = pivotNode.rotation;
				Vector3 a = rotation.CreateRight();
				Vector3 basisForward = Vector3Extension.Multiply(ref a, -1f);
				Vector3 target = rotation.CreateUp();
				Vector3Extension.MultiplyTarget(-1f, ref target);
				Vector3 target2 = rotation.CreateForward();
				Vector3Extension.MultiplyTarget(-1f, ref target2);
				if (yAngleLimits.active)
				{
					yAngleLimits.ConstrainVector(ref target, ref target2, ref basisForward, angularStiffness, deltaTime, ref vector);
				}
				if (zAngleLimits.active)
				{
					zAngleLimits.ConstrainVector(ref target2, ref target, ref basisForward, angularStiffness, deltaTime, ref vector);
				}
				Vector3Extension.Add(ref b, ref vector, out currTipPos);
			}
		}

		private bool CheckForCollision()
		{
			Vector3 a = currTipPos;
			Vector3 headPosition = MyTransform.position;
			float num = MyTransform.TransformDirection(radius, 0f, 0f).Length();
			bool flag = IsCapsuleCollision(ref headPosition, ref currTipPos, num, ref hitNormal);
			if (!flag)
			{
				flag = IsSphereCollision(ref headPosition, ref currTipPos, num, ref hitNormal);
				if (!flag)
				{
					flag = IsPanelCollision(ref headPosition, springLength, ref currTipPos, num, ref hitNormal);
				}
			}
			if (flag)
			{
				Vector3 inDirection = Vector3Extension.Subtract(ref a, ref prevTipPos);
				Vector3 a2 = Vector3Extension.Reflect(ref inDirection, ref hitNormal);
				float d = Vector3.Dot(a2, hitNormal);
				Vector3 b = Vector3Extension.Multiply(ref hitNormal, d);
				Vector3 target = Vector3Extension.Subtract(ref a2, ref b);
				Vector3Extension.MultiplyTarget(1f - manager.friction, ref target);
				Vector3Extension.MultiplyTarget(manager.bounce, ref b);
				Vector3 b2 = Vector3Extension.Add(ref b, ref target);
				if (b2.LengthSquared() > 0.0001f)
				{
					float num2 = Vector3Extension.Distance(ref currTipPos, ref prevTipPos);
					prevTipPos = Vector3Extension.Subtract(ref currTipPos, ref b2);
					float amount = b2.Length() - num2;
					Vector3Extension.Normalize(ref b2);
					Vector3Extension.MultiplyTarget(amount, ref b2);
					Vector3Extension.AddTarget(ref currTipPos, ref b2);
				}
				else
				{
					prevTipPos = currTipPos;
				}
			}
			return flag;
		}

		private bool IsCapsuleCollision(ref Vector3 headPosition, ref Vector3 currTipPos, float scaledRadius, ref Vector3 hitNormal)
		{
			int num = capsuleColliders.Length;
			for (int i = 0; i < num; i++)
			{
				SpringCapsuleCollider springCapsuleCollider = capsuleColliders[i];
				if (springCapsuleCollider.enabled && springCapsuleCollider.CheckForCollisionAndReact(ref headPosition, ref currTipPos, scaledRadius, ref hitNormal) != 0)
				{
					return true;
				}
			}
			return false;
		}

		private bool IsSphereCollision(ref Vector3 headPosition, ref Vector3 currTipPos, float scaledRadius, ref Vector3 hitNormal)
		{
			int num = sphereColliders.Length;
			for (int i = 0; i < num; i++)
			{
				SpringSphereCollider springSphereCollider = sphereColliders[i];
				if (springSphereCollider.enabled && springSphereCollider.CheckForCollisionAndReact(ref headPosition, ref currTipPos, scaledRadius, ref hitNormal) != 0)
				{
					return true;
				}
			}
			return false;
		}

		private bool IsPanelCollision(ref Vector3 headPosition, float length, ref Vector3 tailPosition, float tailRadius, ref Vector3 hitNormal)
		{
			int num = panelColliders.Length;
			for (int i = 0; i < num; i++)
			{
				SpringPanelCollider springPanelCollider = panelColliders[i];
				if (springPanelCollider.enabled && springPanelCollider.CheckForCollisionAndReact(ref headPosition, springLength, ref currTipPos, tailRadius, ref hitNormal) != 0)
				{
					return true;
				}
			}
			return false;
		}

		private bool CheckForGroundCollision()
		{
			Vector3 headPosition = MyTransform.position;
			Vector3 right = headPosition;
			Vector3 tailPosition = currTipPos;
			float localTailRadius = MyTransform.TransformDirection(radius, 0f, 0f).Length();
			float localLength = Vector3Extension.Distance(ref currTipPos, ref right);
			float groundHeight = manager.groundHeight;
			right.y -= groundHeight;
			tailPosition.y -= groundHeight;
			CollisionStatus num = SpringPanelCollider.CheckForCollisionWithAlignedPlaneAndReact(ref right, localLength, ref tailPosition, localTailRadius, SpringPanelCollider.Axis.Y);
			if (num != 0)
			{
				tailPosition.y += groundHeight;
				currTipPos = FixBoneLength(ref headPosition, ref tailPosition, 0.5f * springLength, springLength);
				prevTipPos = currTipPos;
			}
			return num != CollisionStatus.NoCollision;
		}

		private Vector3 FixBoneLength(ref Vector3 headPosition, ref Vector3 tailPosition, float minLength, float maxLength)
		{
			Vector3 a = Vector3Extension.Subtract(ref tailPosition, ref headPosition);
			float num = a.Length();
			if (num <= 0.001f)
			{
				Vector3 target = MyTransform.TransformDirection(boneAxis);
				Vector3Extension.MultiplyTarget(minLength, ref target);
				return Vector3Extension.Add(ref headPosition, ref target);
			}
			float num2 = ((num < minLength) ? minLength : num);
			num2 = ((num2 > maxLength) ? maxLength : num2);
			Vector3 addTo = Vector3Extension.Multiply(ref a, num2 / num);
			Vector3Extension.AddTarget(ref addTo, ref headPosition);
			return addTo;
		}

		private void InitializeSpringLengthAndTipPosition()
		{
			Vector3 left = MyTransform.position;
			Vector3 right = ComputeChildPosition();
			springLength = Vector3Extension.Distance(ref left, ref right);
			currTipPos = right;
			prevTipPos = right;
			int num = lengthLimitTargets.Length;
			lengthsToLimitTargets = new float[num];
			for (int i = 0; i < num; i++)
			{
				Vector3 left2 = lengthLimitTargets[i].position;
				lengthsToLimitTargets[i] = Vector3Extension.Distance(ref left2, ref right);
			}
		}

		private Quaternion ComputeRotation(ref Vector3 tipPosition)
		{
			Vector3 b = MyTransform.position;
			Quaternion rotation = MyParent.rotation * initialLocalRotation;
			Vector3 vector = Vector3Extension.Subtract(ref tipPosition, ref b);
			Vector3 v = Quaternion.Inverse(rotation) * vector;
			Vector3Extension.Normalize(ref v);
			Quaternion quaternion = Quaternion.FromToRotation(boneAxis, v);
			return initialLocalRotation * quaternion;
		}

		private Vector3 ApplyLengthLimits(float deltaTime)
		{
			int num = lengthLimitTargets.Length;
			if (num == 0)
			{
				return currTipPos;
			}
			float num2 = 0.5f * deltaTime * deltaTime;
			Vector3 target = new Vector3(0f, 0f, 0f);
			for (int i = 0; i < num; i++)
			{
				Vector3 b = lengthLimitTargets[i].position;
				float num3 = lengthsToLimitTargets[i];
				Vector3 v = Vector3Extension.Subtract(ref currTipPos, ref b);
				float num4 = (float)Math.Sqrt(v.LengthSquared()) - num3;
				Vector3Extension.Normalize(ref v);
				Vector3Extension.MultiplyTarget(num2 * num4, ref v);
				Vector3Extension.SubtractTarget(ref target, ref v);
			}
			return Vector3Extension.Add(ref currTipPos, ref target);
		}
	}
	public class SpringBonePivot : MonoBehaviour
	{
	}
	public class SpringManager : MonoBehaviour
	{
		[Header("Properties")]
		public bool automaticUpdates = true;

		public bool isPaused;

		public int simulationFrameRate = 60;

		[Range(0f, 1f)]
		public float dynamicRatio = 0.5f;

		public Vector3 gravity = new Vector3(0f, -10f, 0f);

		[Range(0f, 1f)]
		public float bounce;

		[Range(0f, 1f)]
		public float friction = 1f;

		[Header("Constraints")]
		public bool enableAngleLimits = true;

		public bool enableCollision = true;

		public bool enableLengthLimits = true;

		[Header("Ground Collision")]
		public bool collideWithGround = true;

		public float groundHeight;

		[Header("Bones")]
		public SpringBone[] springBones;

		private bool[] boneIsAnimatedStates;

		private ForceProvider[] forceProviders;

		public void CleanUpBoneColliders()
		{
			SpringBone[] array = springBones;
			foreach (SpringBone obj in array)
			{
				obj.sphereColliders = obj.sphereColliders.Where((SpringSphereCollider collider) => collider != null).ToArray();
				obj.capsuleColliders = obj.capsuleColliders.Where((SpringCapsuleCollider collider) => collider != null).ToArray();
				obj.panelColliders = obj.panelColliders.Where((SpringPanelCollider collider) => collider != null).ToArray();
			}
		}

		public void FindSpringBones(bool includeInactive = false)
		{
			var list = (from bone in GetComponentsInChildren<SpringBone>(includeInactive)
				select new
				{
					bone = bone,
					depth = GetObjectDepth(bone.transform)
				}).ToList();
			list.Sort((a, b) => a.depth.CompareTo(b.depth));
			springBones = list.Select(item => item.bone).ToArray();
		}

		public void UpdateBoneIsAnimatedStates(IList<string> animatedBoneNames)
		{
			if (boneIsAnimatedStates == null || boneIsAnimatedStates.Length != springBones.Length)
			{
				boneIsAnimatedStates = new bool[springBones.Length];
			}
			int num = springBones.Length;
			for (int i = 0; i < num; i++)
			{
				boneIsAnimatedStates[i] = animatedBoneNames.Contains(springBones[i].name);
			}
		}

		public void UpdateDynamics()
		{
			int num = springBones.Length;
			if (isPaused)
			{
				for (int i = 0; i < num; i++)
				{
					SpringBone springBone = springBones[i];
					if (springBone.enabled)
					{
						springBone.ComputeRotation(boneIsAnimatedStates[i] ? dynamicRatio : 1f);
					}
				}
				return;
			}
			float deltaTime = ((simulationFrameRate > 0) ? (1f / (float)simulationFrameRate) : Time.deltaTime);
			for (int j = 0; j < num; j++)
			{
				SpringBone springBone2 = springBones[j];
				if (springBone2.enabled)
				{
					Vector3 sumOfForcesOnBone = GetSumOfForcesOnBone(springBone2);
					springBone2.UpdateSpring(deltaTime, sumOfForcesOnBone);
					springBone2.SatisfyConstraintsAndComputeRotation(deltaTime, boneIsAnimatedStates[j] ? dynamicRatio : 1f);
				}
			}
		}

		private static int GetObjectDepth(Transform inObject)
		{
			int num = 0;
			Transform transform = inObject;
			while (transform != null)
			{
				transform = transform.parent;
				num++;
			}
			return num;
		}

		private Vector3 GetSumOfForcesOnBone(SpringBone springBone)
		{
			Vector3 result = gravity;
			int num = forceProviders.Length;
			for (int i = 0; i < num; i++)
			{
				ForceProvider forceProvider = forceProviders[i];
				if (forceProvider.isActiveAndEnabled)
				{
					result += forceProvider.GetForceOnBone(springBone);
				}
			}
			return result;
		}

		private void Awake()
		{
			FindSpringBones(includeInactive: true);
			int num = springBones.Length;
			for (int i = 0; i < num; i++)
			{
				springBones[i].Initialize(this);
			}
			if (boneIsAnimatedStates == null || boneIsAnimatedStates.Length != num)
			{
				boneIsAnimatedStates = new bool[num];
			}
		}

		private void Start()
		{
			forceProviders = GameObjectUtil.FindComponentsOfType<ForceProvider>().ToArray();
		}

		private void LateUpdate()
		{
			if (automaticUpdates)
			{
				UpdateDynamics();
			}
		}
	}
	public class CSVBuilder
	{
		private StringBuilder builder;

		private char separatorCharacter;

		private string currentSeparator;

		public CSVBuilder(char newSeparatorCharacter = ',')
		{
			builder = new StringBuilder();
			separatorCharacter = newSeparatorCharacter;
			currentSeparator = "";
		}

		public void Append(string item)
		{
			builder.Append(currentSeparator);
			if (item == null)
			{
				item = "";
			}
			builder.Append(CSVUtilities.BuildCSVItem(item));
			currentSeparator = separatorCharacter.ToString();
		}

		public void Append(GameObject gameObject)
		{
			if (!(gameObject == null))
			{
				Append(gameObject.name);
				Component[] components = gameObject.GetComponents<Component>();
				Append(components.Length.ToString());
				Component[] array = components;
				foreach (Component component in array)
				{
					Append(component.GetType().ToString());
					Append(component);
				}
			}
		}

		public void Append(object item)
		{
			if (item == null)
			{
				return;
			}
			Type type = item.GetType();
			if (type == typeof(Transform))
			{
				Append(item as Transform);
			}
			else if (!type.IsPrimitive && !type.IsEnum)
			{
				BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Public;
				FieldInfo[] fields = type.GetFields(bindingAttr);
				foreach (FieldInfo fieldInfo in fields)
				{
					InternalAppend(fieldInfo.FieldType, fieldInfo.GetValue(item));
				}
			}
			else
			{
				InternalAppend(type, item);
			}
		}

		public void Append(Vector3 vector)
		{
			Append(vector.x);
			Append(vector.y);
			Append(vector.z);
		}

		public void Append(Transform transform)
		{
			if (!(transform == null))
			{
				Append((transform.parent != null) ? transform.parent.name : "");
				Append(transform.localPosition);
				Append(transform.localRotation.eulerAngles);
				Append(transform.localScale);
			}
		}

		public void Append(IEnumerable<string> list)
		{
			foreach (string item in list)
			{
				Append(item);
			}
		}

		public void AppendLine()
		{
			builder.AppendLine();
			currentSeparator = "";
		}

		public void AppendLine(string item)
		{
			Append(item);
			AppendLine();
		}

		public void AppendLine(IEnumerable<string> list)
		{
			Append(list);
			AppendLine();
		}

		public override string ToString()
		{
			return builder.ToString();
		}

		private void InternalAppend(Type itemType, object item)
		{
			if (itemType.IsPrimitive || itemType.IsEnum || itemType == typeof(string))
			{
				Append(item.ToString());
			}
			else if (itemType.IsSubclassOf(typeof(UnityEngine.Object)))
			{
				UnityEngine.Object @object = item as UnityEngine.Object;
				Append((@object != null) ? @object.name : "");
			}
			else if (itemType.IsArray)
			{
				if (item is Array array && itemType.GetArrayRank() <= 1)
				{
					List<object> list = new List<object>();
					foreach (object item2 in array)
					{
						if (item2 != null)
						{
							list.Add(item2);
						}
					}
					Append(list.Count.ToString());
					{
						foreach (object item3 in list)
						{
							InternalAppend(itemType.GetElementType(), item3);
						}
						return;
					}
				}
				Append("0");
			}
			else
			{
				BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Public;
				FieldInfo[] fields = itemType.GetFields(bindingAttr);
				foreach (FieldInfo fieldInfo in fields)
				{
					InternalAppend(fieldInfo.FieldType, fieldInfo.GetValue(item));
				}
			}
		}
	}
	public static class CSVUtilities
	{
		private const string DefaultSeparators = ",\t";

		public static string BuildCSVItem(string source)
		{
			return BuildCSVItem(source, ",\t");
		}

		public static string BuildCSVItem(string source, string separatorCharacters)
		{
			if (("\"\r\n" + separatorCharacters).ToCharArray().Any((char token) => source.Contains(token)))
			{
				return "\"" + source.Replace("\"", "\"\"") + "\"";
			}
			return source;
		}

		public static IList<string> ReadNextCSVRow(TextReader reader)
		{
			return ReadNextCSVRow(reader, ",\t");
		}

		public static IList<string> ReadNextCSVRow(TextReader reader, string separatorCharacters)
		{
			if (reader.Peek() == -1)
			{
				return new List<string>();
			}
			List<string> list = new List<string>();
			StringBuilder stringBuilder = new StringBuilder();
			bool flag = false;
			bool flag2 = false;
			while (!flag2)
			{
				flag2 = reader.Peek() == -1;
				bool flag3 = flag2;
				if (!flag2)
				{
					char c = (char)reader.Read();
					if (!flag)
					{
						flag2 = c == '\r' || c == '\n';
						if (c == '\r' && (ushort)reader.Peek() == 10)
						{
							reader.Read();
						}
						flag3 = flag2 || separatorCharacters.Contains(c);
						if (!flag3)
						{
							if (c == '"')
							{
								flag = true;
							}
							else
							{
								stringBuilder.Append(c);
							}
						}
					}
					else if (c == '"')
					{
						int num = reader.Peek();
						if (num != -1 && (ushort)num == 34)
						{
							stringBuilder.Append('"');
							reader.Read();
						}
						else
						{
							flag = false;
						}
					}
					else
					{
						stringBuilder.Append(c);
					}
				}
				bool flag4 = flag2 && list.Count == 0 && stringBuilder.Length == 0;
				if (flag3 && !flag4)
				{
					list.Add(stringBuilder.ToString());
					stringBuilder.Length = 0;
				}
			}
			return list;
		}
	}
	public class DirectoryUtil
	{
		public static string[] GetDirectories(string path, string searchPattern = "*")
		{
			string[] array = null;
			try
			{
				array = Directory.GetDirectories(path, searchPattern);
			}
			catch (DirectoryNotFoundException ex)
			{
				UnityEngine.Debug.LogError(path + "\n\n\n" + ex.ToString());
			}
			catch (PathTooLongException ex2)
			{
				UnityEngine.Debug.LogError(path + "\n\n\n" + ex2.ToString());
			}
			catch (IOException ex3)
			{
				UnityEngine.Debug.LogError(path + "\n\n\n" + ex3.ToString());
			}
			catch (UnauthorizedAccessException ex4)
			{
				UnityEngine.Debug.LogError(path + "\n\n\n" + ex4.ToString());
			}
			if (array == null)
			{
				array = new string[0];
			}
			return array;
		}

		public static IEnumerable<string> GetFilesRecursively(string path, string searchPattern = "*.*")
		{
			List<string> list = new List<string>();
			GetFilesRecursively(path, searchPattern, list);
			return list;
		}

		public static void GetFilesRecursively(string path, string searchPattern, List<string> files)
		{
			files.AddRange(GetFiles(path, searchPattern));
			string[] directories = GetDirectories(path);
			for (int i = 0; i < directories.Length; i++)
			{
				GetFilesRecursively(directories[i], searchPattern, files);
			}
		}

		public static string[] GetFiles(string path, string searchPattern = "*.*")
		{
			string[] array = null;
			try
			{
				array = Directory.GetFiles(path, searchPattern);
			}
			catch (DirectoryNotFoundException ex)
			{
				UnityEngine.Debug.LogError(path + "\n\n\n" + ex.ToString());
			}
			catch (PathTooLongException ex2)
			{
				UnityEngine.Debug.LogError(path + "\n\n\n" + ex2.ToString());
			}
			catch (IOException ex3)
			{
				UnityEngine.Debug.LogError(path + "\n\n\n" + ex3.ToString());
			}
			catch (UnauthorizedAccessException ex4)
			{
				UnityEngine.Debug.LogError(path + "\n\n\n" + ex4.ToString());
			}
			if (array == null)
			{
				array = new string[0];
			}
			return array;
		}

		public static bool TryToCreateDirectory(string directoryName)
		{
			directoryName = PathUtil.NormalizePath(directoryName);
			if (Directory.Exists(directoryName))
			{
				return true;
			}
			bool flag = false;
			string text = "";
			try
			{
				Directory.CreateDirectory(directoryName);
				flag = true;
			}
			catch (IOException)
			{
				text = "Path is invalid";
			}
			catch (UnauthorizedAccessException)
			{
				text = "Access denied";
			}
			catch (ArgumentException)
			{
				text = ((directoryName.Length == 0) ? "Path is empty" : "Path contains invalid characters");
			}
			catch (NotSupportedException)
			{
				text = "Path is not supported";
			}
			if (!flag)
			{
				UnityEngine.Debug.LogError("Unable to create directory: " + directoryName + "\n" + text);
			}
			return flag;
		}
	}
	public class FileUtil
	{
		public static string ReadAllText(string inFilePath, Encoding inDefaultEncoding)
		{
			string text = "";
			Encoding encoding = TryToDetectEncoding(inFilePath, inDefaultEncoding);
			try
			{
				return File.ReadAllText(inFilePath, encoding);
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError("ReadAllText failed\n" + inFilePath + "\n\n" + ex.ToString());
				return "";
			}
		}

		public static string ReadAllText(string inFilePath)
		{
			return ReadAllText(inFilePath, TryToDetectEncoding(inFilePath, Encoding.Default));
		}

		public static string[] ReadAllLines(string inFilePath, Encoding inDefaultEncoding)
		{
			string[] array = new string[0];
			Encoding encoding = TryToDetectEncoding(inFilePath, inDefaultEncoding);
			try
			{
				return File.ReadAllLines(inFilePath, encoding);
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError("ReadAllLines failed\n" + inFilePath + "\n\n" + ex.ToString());
				return new string[0];
			}
		}

		public static string[] ReadAllLines(string inFilePath)
		{
			return ReadAllLines(inFilePath, TryToDetectEncoding(inFilePath, Encoding.Default));
		}

		public static bool WriteAllText(string filePath, string text, Encoding encoding = null)
		{
			if (encoding == null)
			{
				encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
			}
			bool flag = false;
			try
			{
				File.WriteAllText(filePath, text, encoding);
				return true;
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError(": " + filePath + "\n" + ex.ToString());
				return false;
			}
		}

		public static Encoding TryToDetectEncoding(string inFilePath, Encoding inDefaultEncoding)
		{
			byte[] key = new byte[3] { 239, 187, 191 };
			byte[] key2 = new byte[2] { 255, 254 };
			byte[] key3 = new byte[2] { 254, 255 };
			byte[] key4 = new byte[4] { 60, 63, 120, 109 };
			byte[] key5 = new byte[2] { 60, 0 };
			byte[] key6 = new byte[2] { 0, 60 };
			Dictionary<byte[], Encoding> obj = new Dictionary<byte[], Encoding>
			{
				[key] = Encoding.UTF8,
				[key2] = Encoding.Unicode,
				[key3] = Encoding.BigEndianUnicode,
				[key4] = Encoding.UTF8,
				[key5] = Encoding.Unicode,
				[key6] = Encoding.BigEndianUnicode
			};
			byte[] inBuffer = ReadFirstBytesOfFile(inFilePath, 4);
			foreach (KeyValuePair<byte[], Encoding> item in obj)
			{
				if (CheckIfBufferStartsWithHeader(inBuffer, item.Key))
				{
					return item.Value;
				}
			}
			return inDefaultEncoding;
		}

		public static Encoding TryToDetectEncoding(string inFilePath)
		{
			return TryToDetectEncoding(inFilePath, Encoding.Default);
		}

		public static void ExploreToDirectory(string directory)
		{
		}

		private static byte[] ReadFirstBytesOfFile(string inFilePath, int inNumBytesToRead)
		{
			byte[] array = new byte[inNumBytesToRead];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = 0;
			}
			FileStream fileStream = null;
			try
			{
				fileStream = new FileStream(inFilePath, FileMode.Open, FileAccess.Read);
				fileStream.Read(array, 0, inNumBytesToRead);
			}
			catch
			{
			}
			fileStream?.Dispose();
			return array;
		}

		private static bool CheckIfBufferStartsWithHeader(byte[] inBuffer, byte[] inHeader)
		{
			if (inBuffer.Length < inHeader.Length)
			{
				return false;
			}
			for (int i = 0; i < inHeader.Length; i++)
			{
				if (inBuffer[i] != inHeader[i])
				{
					return false;
				}
			}
			return true;
		}
	}
	public class GizmoUtil
	{
		public static void DrawArrow(Vector3 origin, Vector3 destination, Color color, float headRatio = 0.05f)
		{
			Gizmos.color = color;
			Gizmos.DrawLine(origin, destination);
			Vector3 vector = destination - origin;
			Vector3 vector2 = destination - headRatio * vector;
			Vector3 vector3 = 0.5f * headRatio * new Vector3(vector.y, vector.z, vector.x);
			Gizmos.DrawLine(destination, vector2 + vector3);
			Gizmos.DrawLine(destination, vector2 - vector3);
		}

		public static void DrawTransform(Transform transform, float drawScale, float headRatio = 0.05f)
		{
			if (transform != null)
			{
				DrawTransform(transform.position, transform.right, transform.up, transform.forward, drawScale, headRatio);
			}
		}

		public static void DrawTransform(Vector3 origin, Transform orientation, float drawScale, float headRatio = 0.05f)
		{
			if (orientation != null)
			{
				DrawTransform(origin, orientation.right, orientation.up, orientation.forward, drawScale, headRatio);
			}
		}

		public static void DrawTransform(Vector3 origin, Vector3 right, Vector3 up, Vector3 forward, float drawScale, float headRatio = 0.05f)
		{
			Color red = Color.red;
			Color green = Color.green;
			Color color = new Color(0f, 0.9f, 1f);
			DrawArrow(origin, origin + drawScale * right, red, headRatio);
			DrawArrow(origin, origin + drawScale * up, green, headRatio);
			DrawArrow(origin, origin + drawScale * forward, color, headRatio);
		}
	}
	public class TypedStringToValueMap
	{
		private Dictionary<string, object> map;

		public Type Type { get; private set; }

		public object DefaultValue { get; private set; }

		public object this[string key]
		{
			get
			{
				object value = DefaultValue;
				if (!map.TryGetValue(key, out value))
				{
					value = DefaultValue;
					UnityEngine.Debug.LogError("Value not found: " + key);
				}
				return value;
			}
		}

		public TypedStringToValueMap(Type inputType, Dictionary<string, object> inputMap, object inputDefaultValue)
		{
			Type = inputType;
			map = inputMap;
			DefaultValue = inputDefaultValue;
		}

		public static TypedStringToValueMap Create<T>(Dictionary<string, T> inputMap, T inputDefaultValue)
		{
			Dictionary<string, object> inputMap2 = ((IEnumerable<KeyValuePair<string, T>>)inputMap).ToDictionary((Func<KeyValuePair<string, T>, string>)((KeyValuePair<string, T> item) => item.Key), (Func<KeyValuePair<string, T>, object>)((KeyValuePair<string, T> item) => item.Value));
			return new TypedStringToValueMap(typeof(T), inputMap2, inputDefaultValue);
		}

		public static TypedStringToValueMap Create<T>(Dictionary<string, T> inputMap)
		{
			Dictionary<string, object> inputMap2 = ((IEnumerable<KeyValuePair<string, T>>)inputMap).ToDictionary((Func<KeyValuePair<string, T>, string>)((KeyValuePair<string, T> item) => item.Key), (Func<KeyValuePair<string, T>, object>)((KeyValuePair<string, T> item) => item.Value));
			return new TypedStringToValueMap(typeof(T), inputMap2, default(T));
		}

		public string GetKey(object value)
		{
			string text = (from item in map
				where item.Value == value
				select item.Key).FirstOrDefault();
			if (text == null)
			{
				return "";
			}
			return text;
		}
	}
	public static class UnityComponentStringListBuilder
	{
		public static void BuildBuilderStringList(object sourceObject, List<string> outputStrings, IEnumerable<TypedStringToValueMap> valueMaps = null)
		{
			Type type = sourceObject.GetType();
			if (type.IsSubclassOf(typeof(Component)))
			{
				ConvertFieldsToStrings(sourceObject, type, valueMaps, outputStrings);
			}
			else
			{
				ConvertObjectToStrings(sourceObject, type, valueMaps, outputStrings);
			}
		}

		public static IEnumerable<string> BuildBuilderStringList(object sourceObject, IEnumerable<TypedStringToValueMap> valueMaps = null)
		{
			List<string> list = new List<string>();
			BuildBuilderStringList(sourceObject, list, valueMaps);
			return list;
		}

		public static IEnumerable<string> BuildBuilderStringList(object sourceObject, TypedStringToValueMap valueMap)
		{
			return BuildBuilderStringList(sourceObject, new TypedStringToValueMap[1] { valueMap });
		}

		private static void ConvertFieldsToStrings(object sourceObject, Type type, IEnumerable<TypedStringToValueMap> valueMaps, List<string> outputStrings)
		{
			BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Public;
			FieldInfo[] fields = type.GetFields(bindingAttr);
			foreach (FieldInfo fieldInfo in fields)
			{
				ConvertObjectToStrings(fieldInfo.GetValue(sourceObject), fieldInfo.FieldType, valueMaps, outputStrings);
			}
		}

		private static void ConvertObjectToStrings(object sourceObject, Type type, IEnumerable<TypedStringToValueMap> valueMaps, List<string> outputStrings)
		{
			if (valueMaps != null)
			{
				TypedStringToValueMap typedStringToValueMap = valueMaps.Where((TypedStringToValueMap map) => map.Type == type).FirstOrDefault();
				if (typedStringToValueMap != null)
				{
					outputStrings.Add(typedStringToValueMap.GetKey(sourceObject));
					return;
				}
			}
			if (type.IsArray)
			{
				if (sourceObject != null)
				{
					MethodInfo[] methods = type.GetMethods(BindingFlags.Instance | BindingFlags.Public);
					int num = (int)methods.Where((MethodInfo method) => method.Name == "GetLength").First().Invoke(sourceObject, new object[1] { 0 });
					MethodInfo methodInfo = methods.Where((MethodInfo method) => method.Name == "GetValue" && method.GetParameters().Count() == 1 && method.GetParameters()[0].ParameterType == typeof(int)).First();
					List<object> list = new List<object>(num);
					for (int i = 0; i < num; i++)
					{
						object obj = methodInfo.Invoke(sourceObject, new object[1] { i });
						if (obj != null)
						{
							list.Add(obj);
						}
					}
					outputStrings.Add(list.Count.ToString());
					Type elementType = type.GetElementType();
					{
						foreach (object item in list)
						{
							ConvertObjectToStrings(item, elementType, valueMaps, outputStrings);
						}
						return;
					}
				}
				outputStrings.Add(0.ToString());
			}
			else if (sourceObject == null)
			{
				outputStrings.Add("");
			}
			else if (type.IsPrimitive)
			{
				outputStrings.Add(sourceObject.ToString());
			}
			else if (type.IsEnum)
			{
				outputStrings.Add(sourceObject.ToString());
			}
			else if (type == typeof(string))
			{
				outputStrings.Add((string)sourceObject);
			}
			else if (type == typeof(GameObject))
			{
				GameObject gameObject = sourceObject as GameObject;
				outputStrings.Add((gameObject != null) ? gameObject.name : "");
			}
			else if (type.IsSubclassOf(typeof(Component)))
			{
				Component component = sourceObject as Component;
				outputStrings.Add((component != null) ? component.name : "");
			}
			else
			{
				ConvertFieldsToStrings(sourceObject, type, valueMaps, outputStrings);
			}
		}
	}
	public class PathUtil
	{
		public static string NormalizePath(string path)
		{
			path = path.Trim();
			if (System.IO.Path.IsPathRooted(path))
			{
				path = System.IO.Path.GetFullPath(path);
			}
			return path.Replace('\\', '/');
		}

		public static string CombinePath(string parent, string child)
		{
			return NormalizePath(System.IO.Path.Combine(parent, child));
		}

		public static string CombinePaths(IEnumerable<string> paths)
		{
			string text = "";
			foreach (string path in paths)
			{
				text = System.IO.Path.Combine(text, path);
			}
			return NormalizePath(text);
		}

		public static string SystemPathToAssetPath(string inSystemPath)
		{
			Uri uri = new Uri(UnityEngine.Application.dataPath);
			Uri uri2 = new Uri(inSystemPath);
			return uri.MakeRelativeUri(uri2).ToString().Replace('\\', '/');
		}

		public static string AssetPathToSystemPath(string assetPath)
		{
			string directoryName = System.IO.Path.GetDirectoryName(UnityEngine.Application.dataPath);
			if (!assetPath.ToLowerInvariant().StartsWith("Assets".ToLowerInvariant()))
			{
				assetPath = CombinePath("Assets", assetPath);
			}
			return CombinePath(directoryName, assetPath);
		}

		public static string PathToResourcePath(string sourcePath)
		{
			sourcePath = sourcePath.Replace('\\', '/').Trim();
			string text = sourcePath.ToLowerInvariant();
			if (text.StartsWith("resources/"))
			{
				return sourcePath.Substring("resources/".Length);
			}
			int num = text.IndexOf("/resources/");
			if (num != -1)
			{
				return sourcePath.Substring(num + "/resources/".Length);
			}
			return "";
		}

		public static IEnumerable<string> GetUniquePaths(IEnumerable<string> inputPaths)
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			foreach (string inputPath in inputPaths)
			{
				string key = inputPath.ToLowerInvariant().Replace('\\', '/');
				dictionary[key] = inputPath;
			}
			return dictionary.Values;
		}
	}
	public class StringUtil
	{
		public static bool GlobMatch(string stringToCheck, string pattern)
		{
			return new Regex("^" + Regex.Escape(pattern).Replace("\\*", ".*").Replace("\\?", ".") + "$", RegexOptions.IgnoreCase | RegexOptions.Singleline).IsMatch(stringToCheck);
		}

		public static string GlobFind(IEnumerable<string> stringsToCheck, string pattern)
		{
			foreach (string item in stringsToCheck)
			{
				if (GlobMatch(item, pattern))
				{
					return item;
				}
			}
			return null;
		}

		public static List<string> GlobFindAll(IEnumerable<string> stringsToCheck, string pattern)
		{
			List<string> list = new List<string>();
			foreach (string item in stringsToCheck)
			{
				if (GlobMatch(item, pattern))
				{
					list.Add(item);
				}
			}
			return list;
		}
	}
	public class TextRecordParsing
	{
		public class Record
		{
			private List<string> items = new List<string>();

			public int Count => items.Count;

			public IEnumerable<string> Items => items;

			public Record(IEnumerable<string> initialItems)
			{
				items = initialItems.ToList();
			}

			public string GetString(int index)
			{
				return TextRecordParsing.GetString(items, index);
			}

			public bool GetBool(int index)
			{
				return TextRecordParsing.GetBool(items, index);
			}

			public bool TryGetInt(int index, ref int output)
			{
				return GetInt(items, index, ref output);
			}

			public bool TryGetFloat(int index, ref float output)
			{
				return GetFloat(items, index, ref output);
			}

			public bool TryGetVector3(int startIndex, ref Vector3 output)
			{
				return GetVector3(items, startIndex, ref output);
			}

			public Queue<string> ToQueue()
			{
				return new Queue<string>(items);
			}
		}

		public const string DefaultSeparators = "\t,";

		public static IEnumerable<string> DefaultCommentPrefixes => new string[3] { "//", "#", ";" };

		public static string GetString(List<string> items, int index)
		{
			if (index < 0 || index >= items.Count)
			{
				return "";
			}
			return items[index];
		}

		public static bool GetBool(List<string> items, int index)
		{
			List<string> list = new List<string> { "0", "false" };
			string text = GetString(items, index).Trim().ToLowerInvariant();
			if (text.Length > 0)
			{
				return !list.Contains(text);
			}
			return false;
		}

		public static bool GetInt(List<string> items, int index, ref int output)
		{
			int result;
			bool num = int.TryParse(GetString(items, index), out result);
			if (num)
			{
				output = result;
			}
			return num;
		}

		public static bool GetFloat(List<string> items, int index, ref float output)
		{
			float result;
			bool num = float.TryParse(GetString(items, index), out result);
			if (num)
			{
				output = result;
			}
			return num;
		}

		public static bool GetVector3(List<string> items, int startIndex, ref Vector3 output)
		{
			bool flag = false;
			if (startIndex >= 0 && startIndex + 2 < items.Count)
			{
				float result = 0f;
				float result2 = 0f;
				float result3 = 0f;
				flag = float.TryParse(items[startIndex], out result) && float.TryParse(items[startIndex + 1], out result2) && float.TryParse(items[startIndex + 2], out result3);
				if (flag)
				{
					output.Set(result, result2, result3);
				}
			}
			return flag;
		}

		public static List<Record> ParseRecordsFromReader(TextReader reader, string entrySeparators = "\t,", IEnumerable<string> commentPrefixes = null)
		{
			commentPrefixes = commentPrefixes ?? DefaultCommentPrefixes;
			List<Record> list = new List<Record>();
			while (reader.Peek() != -1)
			{
				IEnumerable<string> enumerable = from item in CSVUtilities.ReadNextCSVRow(reader, entrySeparators)
					select item.Trim();
				if (enumerable.Any() && !LineIsCommentedOut(enumerable.First(), commentPrefixes))
				{
					list.Add(new Record(enumerable));
				}
			}
			return list;
		}

		public static List<Record> ParseRecordsFromFile(string sourcePath, Encoding encoding, string entrySeparators = "\t,", IEnumerable<string> commentPrefixes = null)
		{
			List<Record> result = null;
			try
			{
				using StreamReader reader = new StreamReader(sourcePath, encoding);
				result = ParseRecordsFromReader(reader, entrySeparators, commentPrefixes);
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError("TextRecordParsing : " + sourcePath + "\n" + ex.ToString());
				result = new List<Record>();
			}
			return result;
		}

		public static List<Record> ParseRecordsFromText(string sourceText, string entrySeparators = "\t,", IEnumerable<string> commentPrefixes = null)
		{
			List<Record> result = null;
			try
			{
				using StringReader reader = new StringReader(sourceText);
				result = ParseRecordsFromReader(reader, entrySeparators, commentPrefixes);
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError("TextRecordParsing \n" + ex.ToString());
				result = new List<Record>();
			}
			return result;
		}

		public static List<Record> GetSectionRecords(List<Record> sourceRecords, string sectionName)
		{
			int count = 0;
			if (!string.IsNullOrEmpty(sectionName))
			{
				sectionName = "[" + sectionName.ToLowerInvariant() + "]";
				count = sourceRecords.FindIndex((Record item) => item.GetString(0).Trim().ToLowerInvariant() == sectionName);
				if (count == -1)
				{
					return new List<Record>(0);
				}
				count++;
			}
			return sourceRecords.Skip(count).TakeWhile((Record item) => !item.GetString(0).Trim().StartsWith("[")).ToList();
		}

		private static bool LineIsCommentedOut(string trimmedLine, IEnumerable<string> commentPrefixes)
		{
			return commentPrefixes.Any((string prefix) => prefix.Length > 0 && trimmedLine.StartsWith(prefix));
		}
	}
}
namespace UTJ.StringQueueExtensions
{
	public static class ObjectBuilder
	{
		public static float DequeueFloat(this Queue<string> queue)
		{
			return float.Parse(queue.Dequeue());
		}

		public static int DequeueInt(this Queue<string> queue)
		{
			return int.Parse(queue.Dequeue());
		}

		public static Vector3 DequeueVector3(this Queue<string> queue)
		{
			float x = float.Parse(queue.Dequeue());
			float y = float.Parse(queue.Dequeue());
			float z = float.Parse(queue.Dequeue());
			return new Vector3(x, y, z);
		}

		public static Transform DequeueTransform(this Queue<string> queue, GameObject gameObject)
		{
			string parentName = queue.Dequeue();
			Transform transform = null;
			if (parentName.Length > 0)
			{
				Transform[] children = gameObject.GetComponentsInChildren<Transform>(includeInactive: true);
				transform = (from item in UnityEngine.Object.FindObjectsOfType<Transform>()
					where item.name == parentName && !children.Contains(item)
					select item).FirstOrDefault();
				if (transform == null)
				{
					UnityEngine.Debug.LogError("Valid parent not found: " + parentName);
				}
			}
			Transform transform2 = gameObject.transform;
			transform2.parent = transform;
			Vector3 localPosition = queue.DequeueVector3();
			Vector3 euler = queue.DequeueVector3();
			Vector3 localScale = queue.DequeueVector3();
			transform2.localRotation = Quaternion.Euler(euler);
			transform2.localScale = localScale;
			transform2.localPosition = localPosition;
			return transform2;
		}

		public static bool DequeueComponent(this Queue<string> queue, Component component, GameObject rootObject = null, IEnumerable<TypedStringToValueMap> valueMaps = null)
		{
			Type type = component.GetType();
			bool result = true;
			try
			{
				queue.DequeueFields(type, component, rootObject, valueMaps);
			}
			catch (InvalidOperationException ex)
			{
				result = false;
				UnityEngine.Debug.LogError("Error dequeueing fields for " + type.ToString() + ":\nInsufficient data in source fields\n\n" + ex.ToString());
			}
			catch (Exception ex2)
			{
				result = false;
				UnityEngine.Debug.LogError("Error dequeueing fields for " + type.ToString() + "\n\n" + ex2.ToString());
			}
			return result;
		}

		public static void DequeueFields(this Queue<string> queue, Type classType, object item, GameObject rootObject = null, IEnumerable<TypedStringToValueMap> valueMaps = null)
		{
			BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Public;
			FieldInfo[] fields = classType.GetFields(bindingAttr);
			foreach (FieldInfo fieldInfo in fields)
			{
				object valueByType = queue.GetValueByType(fieldInfo.FieldType, rootObject, valueMaps);
				fieldInfo.SetValue(item, valueByType);
			}
		}

		public static void DequeueFields<T>(this Queue<string> queue, T item, string firstOptionalField = null) where T : class
		{
			queue.DequeueFields(typeof(T), item, firstOptionalField);
		}

		public static void DequeueFields(this Queue<string> queue, Type classType, object item, string firstOptionalField = null)
		{
			BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Public;
			FieldInfo[] fields = classType.GetFields(bindingAttr);
			foreach (FieldInfo fieldInfo in fields)
			{
				if (queue.Count == 0 && !string.IsNullOrEmpty(firstOptionalField) && fieldInfo.Name == firstOptionalField)
				{
					break;
				}
				object valueByType = queue.GetValueByType(fieldInfo.FieldType, null, null);
				fieldInfo.SetValue(item, valueByType);
			}
		}

		public static T DequeueObject<T>(this Queue<string> queue, string firstOptionalField = null) where T : class, new()
		{
			T val = new T();
			queue.DequeueFields(typeof(T), val, firstOptionalField);
			return val;
		}

		public static object DequeueObject(this Queue<string> queue, Type type, string firstOptionalField = null)
		{
			object obj = Activator.CreateInstance(type);
			queue.DequeueFields(type, obj, firstOptionalField);
			return obj;
		}

		private static object ParsePrimitiveType(Type type, string valueSource)
		{
			MethodInfo methodInfo = (from method in type.GetMethods()
				where method.Name == "Parse" && method.IsStatic && method.GetParameters().Length == 1
				select method).FirstOrDefault();
			if (methodInfo != null)
			{
				return methodInfo.Invoke(null, new object[1] { valueSource });
			}
			UnityEngine.Debug.LogError("Parse not found: " + type.ToString());
			return null;
		}

		private static object ParseEnum(Type type, string valueSource)
		{
			object obj = null;
			try
			{
				obj = Enum.Parse(type, valueSource, ignoreCase: true);
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError("Enum value not found: " + type.ToString() + " : " + valueSource + "\n\n" + ex.ToString());
				obj = null;
			}
			if (obj == null)
			{
				obj = Enum.GetValues(type).GetValue(0);
			}
			return obj;
		}

		private static object GetValueByType(this Queue<string> queue, Type type, GameObject rootObject, IEnumerable<TypedStringToValueMap> valueMaps)
		{
			if (valueMaps != null)
			{
				TypedStringToValueMap typedStringToValueMap = valueMaps.Where((TypedStringToValueMap map) => map.Type == type).FirstOrDefault();
				if (typedStringToValueMap != null)
				{
					return typedStringToValueMap[queue.Dequeue()];
				}
			}
			if (type.IsPrimitive)
			{
				return ParsePrimitiveType(type, queue.Dequeue());
			}
			if (type.IsEnum)
			{
				return ParseEnum(type, queue.Dequeue());
			}
			if (type == typeof(string))
			{
				return queue.Dequeue();
			}
			if (type == typeof(GameObject))
			{
				Component component = FindComponent(typeof(Transform), rootObject, queue.Dequeue());
				if (component != null)
				{
					return component.gameObject;
				}
				return null;
			}
			if (type.IsSubclassOf(typeof(Component)))
			{
				return FindComponent(type, rootObject, queue.Dequeue());
			}
			if (type.IsArray)
			{
				return queue.BuildArray(type.GetElementType(), rootObject, valueMaps);
			}
			object obj = Activator.CreateInstance(type);
			queue.DequeueFields(type, obj, rootObject, valueMaps);
			return obj;
		}

		private static Array BuildArray(this Queue<string> queue, Type elementType, GameObject rootObject, IEnumerable<TypedStringToValueMap> valueMaps)
		{
			int num = int.Parse(queue.Dequeue());
			Array array = Array.CreateInstance(elementType, num);
			for (int i = 0; i < num; i++)
			{
				object valueByType = queue.GetValueByType(elementType, rootObject, valueMaps);
				array.SetValue(valueByType, i);
			}
			return array;
		}

		private static Component FindComponent(Type type, GameObject root, string objectName)
		{
			IEnumerable<Component> source;
			if (!(root == null))
			{
				IEnumerable<Component> componentsInChildren = root.GetComponentsInChildren(type, includeInactive: true);
				source = componentsInChildren;
			}
			else
			{
				source = from item in UnityEngine.Object.FindObjectsOfType(type)
					select item as Component into item
					where item != null
					select item;
			}
			Component component = source.FirstOrDefault((Component child) => child.name == objectName);
			if (component == null)
			{
				UnityEngine.Debug.LogError("Component not found: " + objectName + "  Type: " + type.ToString());
			}
			return component;
		}
	}
}
namespace UTJ.GameObjectExtensions
{
	public static class GameObjectUtil
	{
		public enum SearchOptions
		{
			None,
			IgnoreNamespace
		}

		public static IEnumerable<T> FindComponentsOfType<T>() where T : Component
		{
			GameObject[] rootGameObjects = SceneManager.GetActiveScene().GetRootGameObjects();
			List<T> list = new List<T>();
			GameObject[] array = rootGameObjects;
			foreach (GameObject gameObject in array)
			{
				list.AddRange(gameObject.GetComponentsInChildren<T>(includeInactive: true));
			}
			return list;
		}

		public static IEnumerable<GameObject> GetAllGameObjects()
		{
			return from item in FindComponentsOfType<Transform>()
				select item.gameObject;
		}

		public static Dictionary<string, T> BuildNameToComponentMap<T>(this GameObject rootObject, bool includeInactive) where T : Component
		{
			T[] componentsInChildren = rootObject.GetComponentsInChildren<T>(includeInactive);
			Dictionary<string, T> dictionary = new Dictionary<string, T>(componentsInChildren.Length);
			T[] array = componentsInChildren;
			foreach (T val in array)
			{
				dictionary[val.name] = val;
			}
			return dictionary;
		}

		public static IEnumerable<Transform> GetAllBones(this GameObject rootObject)
		{
			SkinnedMeshRenderer[] componentsInChildren = rootObject.GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
			HashSet<Transform> hashSet = new HashSet<Transform>();
			SkinnedMeshRenderer[] array = componentsInChildren;
			for (int i = 0; i < array.Length; i++)
			{
				Transform[] bones = array[i].bones;
				foreach (Transform item in bones)
				{
					hashSet.Add(item);
				}
			}
			return hashSet;
		}

		public static Transform FindChildByName(this GameObject inRoot, string inName, SearchOptions searchOptions = SearchOptions.IgnoreNamespace)
		{
			return inRoot.FindChildComponentByName<Transform>(inName, searchOptions);
		}

		public static T FindChildComponentByName<T>(this GameObject inRoot, string inName, SearchOptions searchOptions = SearchOptions.IgnoreNamespace) where T : Component
		{
			string text = inName.ToLowerInvariant();
			if (searchOptions == SearchOptions.IgnoreNamespace)
			{
				text = RemoveNamespaceFromName(text);
			}
			T[] componentsInChildren = inRoot.GetComponentsInChildren<T>();
			int num = componentsInChildren.Length;
			for (int i = 0; i < num; i++)
			{
				T val = componentsInChildren[i];
				string text2 = val.gameObject.name.ToLowerInvariant();
				if (searchOptions == SearchOptions.IgnoreNamespace)
				{
					text2 = RemoveNamespaceFromName(text2);
				}
				if (text2 == text)
				{
					return val;
				}
			}
			return null;
		}

		public static T[] FindChildComponentsByName<T>(this GameObject inRoot, string[] inNames, SearchOptions searchOptions = SearchOptions.IgnoreNamespace) where T : Component
		{
			T[] componentsInChildren = inRoot.GetComponentsInChildren<T>();
			List<T> list = new List<T>();
			int num = componentsInChildren.Length;
			for (int i = 0; i < num; i++)
			{
				T val = componentsInChildren[i];
				string childName = val.gameObject.name.ToLowerInvariant();
				if (searchOptions == SearchOptions.IgnoreNamespace)
				{
					childName = RemoveNamespaceFromName(childName);
					if (Array.Exists(inNames, (string searchName) => RemoveNamespaceFromName(searchName.ToLowerInvariant()) == childName))
					{
						list.Add(val);
					}
				}
				else if (Array.Exists(inNames, (string searchName) => searchName.ToLowerInvariant() == childName))
				{
					list.Add(val);
				}
			}
			return list.ToArray();
		}

		public static string RemoveNamespaceFromName(string inName)
		{
			string[] array = inName.Split(new char[1] { ':' }, StringSplitOptions.None);
			if (array.Length == 0)
			{
				return "";
			}
			return array[^1];
		}

		public static int GetTransformDepth(Transform inObject)
		{
			int num = 0;
			Transform transform = inObject;
			while (transform != null)
			{
				transform = transform.parent;
				num++;
			}
			return num;
		}

		public static string GetUniqueName(string desiredName)
		{
			IEnumerable<string> source = from item in FindComponentsOfType<Transform>()
				select item.name;
			if (!source.Contains(desiredName))
			{
				return desiredName;
			}
			string text = desiredName;
			for (int i = 1; i <= 10000; i++)
			{
				text = desiredName + "_" + i;
				if (!source.Contains(text))
				{
					return text;
				}
			}
			UnityEngine.Debug.LogError("Too many similar names exist: " + desiredName);
			return text;
		}
	}
}
namespace StackableDecorator
{
	[AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = true)]
	public abstract class StackableDecoratorAttribute : Attribute
	{
		public bool visible = true;

		public int order;

		public string byPass = string.Empty;
	}
	public abstract class Styled2DecoratorAttribute : StyledDecoratorAttribute
	{
		public string style2;
	}
	public abstract class StyledDecoratorAttribute : StackableDecoratorAttribute
	{
		public string style;

		public string title;

		public string icon;

		public string tooltip;
	}
	public abstract class ConditionalAttribute : StackableDecoratorAttribute
	{
		public bool inverted;

		public ConditionalAttribute(bool condition)
		{
		}

		public ConditionalAttribute(string condition)
		{
		}
	}
	public class EnableIfAttribute : ConditionalAttribute
	{
		public bool enable = true;

		public bool disable = true;

		public bool all = true;

		public EnableIfAttribute(bool condition)
			: base(condition)
		{
		}

		public EnableIfAttribute(string condition)
			: base(condition)
		{
		}
	}
	public class HelpBoxAttribute : ConditionalAttribute
	{
		public bool indented = true;

		public MessageType messageType = MessageType.Info;

		public bool below = true;

		public float height = -1f;

		public bool all = true;

		public HelpBoxAttribute(string message)
			: base(condition: true)
		{
		}

		public HelpBoxAttribute(string message, string condition)
			: base(condition)
		{
		}
	}
	public class ShowIfAttribute : ConditionalAttribute
	{
		public bool enable = true;

		public bool disable = true;

		public bool all = true;

		public ShowIfAttribute(bool condition)
			: base(condition)
		{
		}

		public ShowIfAttribute(string condition)
			: base(condition)
		{
		}
	}
	public class ClampValueAttribute : StackableDecoratorAttribute
	{
		public ClampValueAttribute(float min, float max)
		{
		}
	}
	public class MaxValueAttribute : StackableDecoratorAttribute
	{
		public MaxValueAttribute(float value)
		{
		}
	}
	public class MinValueAttribute : StackableDecoratorAttribute
	{
		public MinValueAttribute(float value)
		{
		}
	}
	public class RepeatValueAttribute : StackableDecoratorAttribute
	{
		public bool lowerInclusive = true;

		public bool upperInclusive;

		public RepeatValueAttribute(float min, float max)
		{
		}
	}
	public class AnimatorParameterPopupAttribute : StackableFieldAttribute
	{
		public bool floatType = true;

		public bool intType = true;

		public bool boolType = true;

		public bool triggerType = true;

		public string exclude = string.Empty;

		public string placeHolder = string.Empty;

		public AnimatorParameterPopupAttribute()
		{
		}

		public AnimatorParameterPopupAttribute(string animator)
		{
		}
	}
	public class AsImageAttribute : StackableFieldAttribute, INoCacheInspectorGUI
	{
		public float width = -1f;

		public float height = -1f;

		public string sizeGetter;
	}
	public class AsStringAttribute : StackableFieldAttribute
	{
		public bool label;

		public bool icon;

		public bool tooltip;
	}
	public class ColorFieldAttribute : StackableFieldAttribute
	{
		public bool showEyedropper = true;

		public bool showAlpha = true;

		public bool hdr;

		public float minBrightness;

		public float maxBrightness = 8f;

		public float minExposureValue = 0.125f;

		public float maxExposureValue = 3f;
	}
	public class CurveFieldAttribute : StackableFieldAttribute
	{
		public CurveFieldAttribute()
		{
		}

		public CurveFieldAttribute(float r, float g, float b)
		{
		}

		public CurveFieldAttribute(float xMin, float yMin, float xMax, float yMax)
		{
		}

		public CurveFieldAttribute(float r, float g, float b, float xMin, float yMin, float xMax, float yMax)
		{
		}
	}
	public class DropdownMaskAttribute : StackableFieldAttribute
	{
		public string placeHolder = string.Empty;

		public bool showAll = true;

		public bool showCombined;

		public bool sortCombined = true;

		public DropdownMaskAttribute(string names, string values)
		{
		}
	}
	public class DropdownValueAttribute : StackableFieldAttribute
	{
		public string names;

		public string placeHolder = string.Empty;

		public DropdownValueAttribute(string values)
		{
		}
	}
	public class EnumButtonAttribute : StackableFieldAttribute
	{
		public string styles;

		public string exclude = string.Empty;

		public int column = -1;

		public int hOffset;

		public int vOffset;
	}
	public class EnumMaskButtonAttribute : StackableFieldAttribute
	{
		public string styles;

		public bool all = true;

		public string exclude = string.Empty;

		public int column = -1;

		public int hOffset;

		public int vOffset;
	}
	public class EnumMaskPopupAttribute : StackableFieldAttribute
	{
		public string names;

		public string exclude = string.Empty;

		public string placeHolder = string.Empty;

		public bool showAll = true;

		public bool showCombined;

		public bool sortCombined = true;
	}
	public class EnumPopupAttribute : StackableFieldAttribute
	{
		public string names;

		public string exclude = string.Empty;

		public string placeHolder = string.Empty;
	}
	public class ExpandableAttribute : StackableFieldAttribute
	{
	}
	public class InputAxisPopupAttribute : StackableFieldAttribute
	{
		public bool keyOrMouseButton = true;

		public bool mouseMovement = true;

		public bool joystickAxis = true;

		public bool negativeButton = true;

		public string exclude = string.Empty;

		public string placeHolder = string.Empty;
	}
	public class LabelOnlyAttribute : StackableFieldAttribute
	{
	}
	public class LayerMaskPopupAttribute : StackableFieldAttribute
	{
		public string placeHolder = string.Empty;

		public bool showAll = true;
	}
	public class LayerPopupAttribute : StackableFieldAttribute
	{
		public string exclude = string.Empty;

		public string placeHolder = string.Empty;
	}
	public class ListAttribute : StackableFieldAttribute
	{
		public bool expandable;

		public ListAttribute()
		{
		}

		public ListAttribute(string list)
		{
		}
	}
	public class ProgressBarAttribute : StackableFieldAttribute
	{
		public bool prefix;

		public bool showLabel = true;

		public bool showPercentage = true;

		public int decimalPlaces = 1;

		public bool clampPercentage = true;

		public ProgressBarAttribute(float max)
		{
		}

		public ProgressBarAttribute(float min, float max)
		{
		}
	}
	public class RangeSliderAttribute : StackableFieldAttribute
	{
		public bool integer;

		public bool showInLabel;

		public RangeSliderAttribute(float min, float max)
		{
		}
	}
	public class SimpleGridAttribute : StackableFieldAttribute, INoCacheInspectorGUI
	{
		public int column = 4;

		public float cellWidth = -1f;

		public float cellHeight = 16f;

		public float spacing = 2f;

		public float maxHeight = -1f;

		public string columnGetter;

		public string cellSizeGetter;

		public string maxHeightGetter;

		public SimpleGridAttribute()
		{
		}

		public SimpleGridAttribute(string list)
		{
		}
	}
	public class SimpleListAttribute : StackableFieldAttribute, INoCacheInspectorGUI
	{
		public float spacing = 2f;

		public float fixedHeight = -1f;

		public float maxHeight = -1f;

		public string maxHeightGetter;

		public SimpleListAttribute()
		{
		}

		public SimpleListAttribute(string list)
		{
		}
	}
	public class SliderAttribute : StackableFieldAttribute
	{
		public bool showField = true;

		public SliderAttribute(float min, float max)
		{
		}
	}
	public class SortingLayerPopupAttribute : StackableFieldAttribute
	{
		public string exclude = string.Empty;

		public string placeHolder = string.Empty;
	}
	[AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
	public class StackableFieldAttribute : PropertyAttribute
	{
	}
	public class TagPopupAttribute : StackableFieldAttribute
	{
		public string exclude = string.Empty;

		public string placeHolder = string.Empty;
	}
	public class TextFieldAttribute : StackableFieldAttribute
	{
		private const int kLineHeight = 13;

		public string placeHolder = string.Empty;

		public TextFieldAttribute()
		{
		}

		public TextFieldAttribute(int lines)
		{
		}
	}
	public class ToggleLeftAttribute : StackableFieldAttribute
	{
	}
	public class OnClickAttribute : StackableDecoratorAttribute
	{
		public int button;

		public bool use = true;

		public bool after;

		public OnClickAttribute(string action)
		{
		}
	}
	public class OnDragDropAttribute : StackableDecoratorAttribute
	{
		public int button;

		public bool autoDrag = true;

		public bool autoDrop = true;

		public string drag = string.Empty;

		public string accept = string.Empty;

		public string drop = string.Empty;

		public bool use = true;

		public bool after;
	}
	public class OnValueChangedAttribute : StackableDecoratorAttribute
	{
		public OnValueChangedAttribute(string action)
		{
		}
	}
	public class FoldoutAttribute : Styled2DecoratorAttribute
	{
		public bool indented = true;

		public bool hierarchyMode = true;

		public bool indentChildren = true;
	}
	public class GroupAttribute : StackableDecoratorAttribute
	{
		public bool indented;

		public bool indentChildren;

		public float spacing = 2f;

		public bool fixedCell = true;

		public GroupAttribute(string name, bool children, string properties, params float[] heights)
		{
		}

		public GroupAttribute(string name, int properties, params float[] heights)
		{
		}
	}
	public class HorizontalGroupAttribute : StyledDecoratorAttribute
	{
		public bool indented = true;

		public bool prefix;

		public float spacing = 2f;

		public bool fixedCell = true;

		public HorizontalGroupAttribute(string name, bool children, string properties, params float[] widths)
		{
		}

		public HorizontalGroupAttribute(string name, int properties, params float[] widths)
		{
		}
	}
	public class InGroupAttribute : StackableDecoratorAttribute
	{
		public InGroupAttribute(string name)
		{
		}
	}
	public class TabGroupAttribute : Styled2DecoratorAttribute
	{
		public bool indented = true;

		public float width = -1f;

		public string icons = string.Empty;

		public string tooltips = string.Empty;

		public TextAlignment alignment = TextAlignment.Center;

		public string buttonStyles;

		public TabGroupAttribute(string name, string tabs, string properties, float left = 0f, float right = 0f, float top = 0f, float bottom = 0f)
		{
		}
	}
	public class BoxAttribute : StyledDecoratorAttribute
	{
		public bool indented = true;

		public BoxAttribute(float left = 0f, float right = 0f, float top = 0f, float bottom = 0f)
		{
		}
	}
	public class ButtonsAttribute : StyledDecoratorAttribute
	{
		public string titles = string.Empty;

		public string icons = string.Empty;

		public string tooltips = string.Empty;

		public string actions = string.Empty;

		public string buttonStyles;

		public int column = -1;

		public int hOffset;

		public int vOffset;

		public float width = -1f;

		public float height = -1f;

		public bool indented = true;

		public bool below;

		public TextAlignment alignment;

		public ButtonsAttribute(float left = 0f, float right = 0f, float top = 0f, float bottom = 0f)
		{
		}
	}
	public class HeadingAttribute : StyledDecoratorAttribute
	{
		public float width = -1f;

		public float height = -1f;

		public bool indented = true;

		public bool below;

		public TextAlignment alignment;

		public HeadingAttribute(float left = 0f, float right = 0f, float top = 0f, float bottom = 0f)
		{
		}
	}
	public class ImageAttribute : StackableDecoratorAttribute, INoCacheInspectorGUI
	{
		public string image = string.Empty;

		public string texture = string.Empty;

		public float width = -1f;

		public float height = -1f;

		public bool GUID;

		public bool indented = true;

		public bool below;

		public TextAlignment alignment;

		public ImageAttribute(float left = 0f, float right = 0f, float top = 0f, float bottom = 0f)
		{
		}
	}
	public class SideButtonsAttribute : StyledDecoratorAttribute
	{
		public string titles = string.Empty;

		public string icons = string.Empty;

		public string tooltips = string.Empty;

		public string actions = string.Empty;

		public string buttonStyles;

		public int column = -1;

		public int hOffset;

		public int vOffset;

		public float width = -1f;

		public float height = -1f;

		public float margin = 2f;

		public bool indented = true;

		public bool onLeft;

		public TextAlignment alignment;

		public SideButtonsAttribute(float left = 0f, float right = 0f, float top = 0f, float bottom = 0f)
		{
		}
	}
	public class SideImageAttribute : StyledDecoratorAttribute, INoCacheInspectorGUI
	{
		public string image = string.Empty;

		public string texture = string.Empty;

		public float width = -1f;

		public float height = -1f;

		public float margin = 2f;

		public bool GUID;

		public bool indented = true;

		public bool onLeft;

		public bool reserveWidth;

		public TextAlignment alignment;

		public SideImageAttribute(float left = 0f, float right = 0f, float top = 0f, float bottom = 0f)
		{
		}
	}
	public class ColorAttribute : StackableDecoratorAttribute
	{
		public ColorAttribute(float r, float g, float b, float a)
		{
		}
	}
	public class DegToRadAttribute : StackableDecoratorAttribute
	{
	}
	public class HierarchyModeAttribute : StackableDecoratorAttribute
	{
		public HierarchyModeAttribute(bool hierarchyMode)
		{
		}
	}
	public class IconSizeAttribute : StackableDecoratorAttribute
	{
		public IconSizeAttribute(int width, int height)
		{
		}
	}
	public class IncludeChildrenAttribute : StackableDecoratorAttribute
	{
		public IncludeChildrenAttribute(bool includeChildren)
		{
		}
	}
	public class IndentLevelAttribute : StackableDecoratorAttribute
	{
		public bool absolute;

		public IndentLevelAttribute(int indentLevel)
		{
		}
	}
	public class LabelAttribute : StyledDecoratorAttribute
	{
		public LabelAttribute()
		{
		}

		public LabelAttribute(float width)
		{
		}
	}
	public class RadToDegAttribute : StackableDecoratorAttribute
	{
	}
	public class InlinePropertyAttribute : StyledDecoratorAttribute, INoCacheInspectorGUI
	{
		public bool indented = true;

		public bool always;

		public bool indentChildren = true;

		public float maxHeight = -1f;

		public string maxHeightGetter;

		public InlinePropertyAttribute(float left = 3f, float right = 3f, float top = 3f, float bottom = 3f)
		{
		}
	}
	public class PopupEditorAttribute : StyledDecoratorAttribute
	{
		public float width = 16f;

		public float height = 16f;
	}
	public class PreviewAttribute : StackableDecoratorAttribute, INoCacheInspectorGUI
	{
		public bool indented = true;

		public bool always;

		public float height = 100f;
	}
	public interface INoCacheInspectorGUI
	{
	}
	public interface IValidateProperty
	{
		MessageType messageType { get; }
	}
	public static class RectUtils
	{
		public static float defaultSpacing = 2f;

		public static Rect X(this Rect rect, float x)
		{
			rect.x = x;
			return rect;
		}

		public static Rect Y(this Rect rect, float y)
		{
			rect.y = y;
			return rect;
		}

		public static Rect Position(this Rect rect, float x, float y)
		{
			rect.x = x;
			rect.y = y;
			return rect;
		}

		public static Rect Size(this Rect rect, float width, float height)
		{
			rect.width = width;
			rect.height = height;
			return rect;
		}

		public static Rect Width(this Rect rect, float width)
		{
			rect.width = width;
			return rect;
		}

		public static Rect WidthFromRight(this Rect rect, float width)
		{
			rect.xMin = rect.xMax - width;
			return rect;
		}

		public static Rect Height(this Rect rect, float height)
		{
			rect.height = height;
			return rect;
		}

		public static Rect HeightFromBottom(this Rect rect, float height)
		{
			rect.yMin = rect.yMax - height;
			return rect;
		}

		public static Rect Left(this Rect rect, float width)
		{
			rect.width = Mathf.Min(rect.width, width);
			return rect;
		}

		public static Rect Right(this Rect rect, float width)
		{
			rect.xMin = rect.xMax - Mathf.Min(rect.width, width);
			return rect;
		}

		public static Rect Top(this Rect rect, float height)
		{
			rect.height = Mathf.Min(rect.height, height);
			return rect;
		}

		public static Rect Bottom(this Rect rect, float height)
		{
			rect.yMin = rect.yMax - Mathf.Min(rect.height, height);
			return rect;
		}

		public static Rect CutLeft(this Rect rect, float width)
		{
			rect.xMin = Mathf.Min(rect.xMin + width, rect.xMax);
			return rect;
		}

		public static Rect CutRight(this Rect rect, float width)
		{
			rect.xMax = Mathf.Max(rect.xMin, rect.xMax - width);
			return rect;
		}

		public static Rect CutTop(this Rect rect, float height)
		{
			rect.yMin = Mathf.Min(rect.yMin + height, rect.yMax);
			return rect;
		}

		public static Rect CutBottom(this Rect rect, float height)
		{
			rect.yMax = Mathf.Max(rect.yMin, rect.yMax - height);
			return rect;
		}

		public static Rect MoveLeft(this Rect rect)
		{
			return rect.MoveLeft(defaultSpacing);
		}

		public static Rect MoveLeft(this Rect rect, float spacing)
		{
			if (rect.width > 0f)
			{
				rect.x -= rect.width + spacing;
			}
			return rect;
		}

		public static Rect MoveRight(this Rect rect)
		{
			return rect.MoveRight(defaultSpacing);
		}

		public static Rect MoveRight(this Rect rect, float spacing)
		{
			if (rect.width > 0f)
			{
				rect.x += rect.width + spacing;
			}
			return rect;
		}

		public static Rect MoveUp(this Rect rect)
		{
			return rect.MoveUp(defaultSpacing);
		}

		public static Rect MoveUp(this Rect rect, float spacing)
		{
			if (rect.height > 0f)
			{
				rect.y -= rect.height + spacing;
			}
			return rect;
		}

		public static Rect MoveDown(this Rect rect)
		{
			return rect.MoveDown(defaultSpacing);
		}

		public static Rect MoveDown(this Rect rect, float spacing)
		{
			if (rect.height > 0f)
			{
				rect.y += rect.height + spacing;
			}
			return rect;
		}

		public static Rect Enlarge(this Rect rect, float size)
		{
			rect.xMin -= size;
			rect.xMax += size;
			rect.yMin -= size;
			rect.yMax += size;
			return rect;
		}

		public static Rect Enlarge(this Rect rect, float hsize, float vsize)
		{
			rect.xMin -= hsize;
			rect.xMax += hsize;
			rect.yMin -= vsize;
			rect.yMax += vsize;
			return rect;
		}

		public static Rect Enlarge(this Rect rect, float left, float right, float top, float bottom)
		{
			rect.xMin -= left;
			rect.xMax += right;
			rect.yMin -= top;
			rect.yMax += bottom;
			return rect;
		}

		public static Rect Shrink(this Rect rect, float size)
		{
			rect.xMin += size;
			rect.xMax -= size;
			rect.yMin += size;
			rect.yMax -= size;
			return rect;
		}

		public static Rect Shrink(this Rect rect, float hsize, float vsize)
		{
			rect.xMin += hsize;
			rect.xMax -= hsize;
			rect.yMin += vsize;
			rect.yMax -= vsize;
			return rect;
		}

		public static Rect Shrink(this Rect rect, float left, float right, float top, float bottom)
		{
			rect.xMin += left;
			rect.xMax -= right;
			rect.yMin += top;
			rect.yMax -= bottom;
			return rect;
		}

		public static IEnumerable<Rect> HorizontalDistribute(this Rect rect, int count)
		{
			return rect.HorizontalDistribute(defaultSpacing, Enumerable.Repeat(-1f, count));
		}

		public static IEnumerable<Rect> HorizontalDistribute(this Rect rect, int count, float spacing)
		{
			return rect.HorizontalDistribute(spacing, Enumerable.Repeat(-1f, count));
		}

		public static IEnumerable<Rect> RowDistribute(this Rect rect, IEnumerable<float> widths)
		{
			return rect.HorizontalDistribute(defaultSpacing, widths);
		}

		public static IEnumerable<Rect> HorizontalDistribute(this Rect rect, float spacing, IEnumerable<float> widths)
		{
			List<float> list = widths.ToList();
			float total = rect.width - spacing * (float)(list.Count((float w) => w != 0f) - 1);
			float num = 0f;
			for (int j = 0; j < list.Count; j++)
			{
				if (list[j] < 0f)
				{
					num += 0f - list[j];
					continue;
				}
				if (list[j] <= 1f)
				{
					list[j] *= rect.width;
				}
				list[j] = Mathf.Clamp(list[j], 0f, total);
				total -= list[j];
			}
			total /= num;
			Rect current = new Rect(rect);
			for (int i = 0; i < list.Count; i++)
			{
				float width = ((list[i] < 0f) ? (list[i] *= 0f - total) : list[i]);
				current.width = width;
				yield return current;
				current = current.MoveRight(spacing);
			}
		}

		public static IEnumerable<Rect> VerticalDistribute(this Rect rect, int count)
		{
			return rect.VerticalDistribute(defaultSpacing, Enumerable.Repeat(-1f, count));
		}

		public static IEnumerable<Rect> VerticalDistribute(this Rect rect, int count, float spacing)
		{
			return rect.VerticalDistribute(spacing, Enumerable.Repeat(-1f, count));
		}

		public static IEnumerable<Rect> VerticalDistribute(this Rect rect, IEnumerable<float> heights)
		{
			return rect.VerticalDistribute(defaultSpacing, heights);
		}

		public static IEnumerable<Rect> VerticalDistribute(this Rect rect, float spacing, IEnumerable<float> heights)
		{
			rect = new Rect(rect.y, rect.x, rect.height, rect.width);
			return from r in rect.HorizontalDistribute(spacing, heights)
				select new Rect(r.y, r.x, r.height, r.width);
		}

		public static IEnumerable<Rect> GridDistribute(this Rect rect, int row, int column)
		{
			return rect.GridDistribute(-1f, -1f, row, column, defaultSpacing);
		}

		public static IEnumerable<Rect> GridDistribute(this Rect rect, int row, int column, float spacing)
		{
			return rect.GridDistribute(-1f, -1f, row, spacing, column, spacing);
		}

		public static IEnumerable<Rect> GridDistribute(this Rect rect, int row, float vSpacing, int column, float hSpacing)
		{
			return rect.GridDistribute(-1f, -1f, row, vSpacing, column, hSpacing);
		}

		public static IEnumerable<Rect> GridDistribute(this Rect rect, float width, float height, int row, int column, float spacing)
		{
			return rect.GridDistribute(width, height, row, spacing, column, spacing);
		}

		public static IEnumerable<Rect> GridDistribute(this Rect rect, float width, float height, int row, float vSpacing, int column, float hSpacing)
		{
			IEnumerable<Rect> enumerable = ((height < 0f) ? rect.VerticalDistribute(row, vSpacing) : rect.VerticalDistribute(vSpacing, Enumerable.Repeat(height, row)));
			foreach (Rect item in enumerable)
			{
				IEnumerable<Rect> enumerable2 = ((width < 0f) ? item.HorizontalDistribute(column, hSpacing) : item.HorizontalDistribute(hSpacing, Enumerable.Repeat(width, column)));
				foreach (Rect item2 in enumerable2)
				{
					yield return item2;
				}
			}
		}
	}
	public static class ReflectionUtils
	{
		public static T MakeFunc<T>(this MethodInfo method) where T : class
		{
			return Delegate.CreateDelegate(typeof(T), method) as T;
		}

		public static T MakeStaticFunc<T>(this MethodInfo method) where T : class
		{
			return Delegate.CreateDelegate(typeof(T), null, method) as T;
		}

		public static T MakeFuncGenericThis<T>(this MethodInfo method) where T : class
		{
			ParameterExpression parameterExpression = Expression.Parameter(typeof(object), "obj");
			return Expression.Lambda<T>(Expression.Call(Expression.Convert(parameterExpression, method.DeclaringType), method), new ParameterExpression[1] { parameterExpression }).Compile();
		}

		public static T MakeStaticFuncGenericInput<T>(this MethodInfo method) where T : class
		{
			ParameterExpression parameterExpression = Expression.Parameter(typeof(object), "input");
			UnaryExpression arg = Expression.Convert(parameterExpression, method.GetParameters()[0].ParameterType);
			return Expression.Lambda<T>(Expression.Call(method, arg), new ParameterExpression[1] { parameterExpression }).Compile();
		}

		public static T MakeFuncGenericInput<T>(this MethodInfo method) where T : class
		{
			ParameterExpression parameterExpression = Expression.Parameter(typeof(object), "obj");
			UnaryExpression instance = Expression.Convert(parameterExpression, method.DeclaringType);
			ParameterExpression parameterExpression2 = Expression.Parameter(typeof(object), "input");
			UnaryExpression unaryExpression = Expression.Convert(parameterExpression2, method.GetParameters()[0].ParameterType);
			return Expression.Lambda<T>(Expression.Call(instance, method, unaryExpression), new ParameterExpression[2] { parameterExpression, parameterExpression2 }).Compile();
		}
	}
	public static class TransformUtils
	{
		public static IEnumerable<Transform> GetAncestors(this Transform transform, bool self = true)
		{
			Transform current = (self ? transform : transform.parent);
			while (current != null)
			{
				yield return current;
				current = current.parent;
			}
		}

		public static IEnumerable<Transform> GetChildren(this Transform transform, bool self = true)
		{
			if (self)
			{
				yield return transform;
			}
			int count = transform.childCount;
			for (int i = 0; i < count; i++)
			{
				yield return transform.GetChild(i);
			}
		}

		public static IEnumerable<Transform> GetDescendants(this Transform transform, bool self = true)
		{
			if (self)
			{
				yield return transform;
			}
			foreach (Transform child in transform.GetChildren(self: false))
			{
				foreach (Transform descendant in child.GetDescendants())
				{
					yield return descendant;
				}
			}
		}

		public static GameObject GetRoot(this GameObject gameObject)
		{
			return gameObject.transform.root.gameObject;
		}

		public static IEnumerable<GameObject> GetAncestors(this GameObject gameObject, bool self = true)
		{
			return from t in gameObject.transform.GetAncestors(self)
				select t.gameObject;
		}

		public static IEnumerable<GameObject> GetChildren(this GameObject gameObject, bool self = true)
		{
			return from t in gameObject.transform.GetChildren(self)
				select t.gameObject;
		}

		public static IEnumerable<GameObject> GetDescendants(this GameObject gameObject, bool self = true)
		{
			return from t in gameObject.transform.GetDescendants(self)
				select t.gameObject;
		}
	}
	public enum MessageType
	{
		None,
		Info,
		Warning,
		Error
	}
	public static class Utils
	{
		public static bool IsPowerOfTwo(this long number)
		{
			if (number != 0L)
			{
				return (number & (number - 1)) == 0;
			}
			return false;
		}

		public static IEnumerable<T> Yield<T>(this T item)
		{
			yield return item;
		}

		public static TValue Get<TKey, TValue>(this Dictionary<TKey, TValue> dict, TKey key, TValue def) where TValue : struct
		{
			if (!dict.TryGetValue(key, out var value))
			{
				value = (dict[key] = def);
			}
			return value;
		}

		public static TValue Get<TKey, TValue>(this Dictionary<TKey, TValue> dict, TKey key) where TValue : new()
		{
			if (!dict.TryGetValue(key, out var value))
			{
				value = (dict[key] = new TValue());
			}
			return value;
		}
	}
	public class AssetOnlyAttribute : ValidateObjectAttribute
	{
		public AssetOnlyAttribute()
		{
		}

		public AssetOnlyAttribute(string message)
		{
		}
	}
	public class NotNullAttribute : ValidateObjectAttribute
	{
		public NotNullAttribute()
		{
		}

		public NotNullAttribute(string message)
		{
		}
	}
	public class SceneOnlyAttribute : ValidateObjectAttribute
	{
		public SceneOnlyAttribute()
		{
		}

		public SceneOnlyAttribute(string message)
		{
		}
	}
	public abstract class ValidateAttribute : StackableDecoratorAttribute, IValidateProperty
	{
		public bool indented = true;

		public MessageType messageType = MessageType.Error;

		public bool below = true;

		public float height = -1f;

		MessageType IValidateProperty.messageType => messageType;
	}
	public abstract class ValidateObjectAttribute : ValidateAttribute
	{
	}
	public class ValidateValueAttribute : ValidateAttribute
	{
		public bool inverted;

		public ValidateValueAttribute(string message, string condition)
		{
		}
	}
}
namespace DG.Tweening
{
	public static class DOTweenModuleSprite
	{
		public static Tweener DOColor(this SpriteRenderer target, Color endValue, float duration)
		{
			return DOTween.To(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOFade(this SpriteRenderer target, float endValue, float duration)
		{
			return DOTween.ToAlpha(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Sequence DOGradientColor(this SpriteRenderer target, Gradient gradient, float duration)
		{
			Sequence sequence = DOTween.Sequence();
			GradientColorKey[] colorKeys = gradient.colorKeys;
			int num = colorKeys.Length;
			for (int i = 0; i < num; i++)
			{
				GradientColorKey gradientColorKey = colorKeys[i];
				if (i == 0 && gradientColorKey.time <= 0f)
				{
					target.color = gradientColorKey.color;
					continue;
				}
				float duration2 = ((i == num - 1) ? (duration - sequence.Duration(includeLoops: false)) : (duration * ((i == 0) ? gradientColorKey.time : (gradientColorKey.time - colorKeys[i - 1].time))));
				sequence.Append(target.DOColor(gradientColorKey.color, duration2).SetEase(Ease.Linear));
			}
			return sequence;
		}

		public static Tweener DOBlendableColor(this SpriteRenderer target, Color endValue, float duration)
		{
			endValue -= target.color;
			Color to = new Color(0f, 0f, 0f, 0f);
			return DOTween.To(() => to, delegate(Color x)
			{
				Color color = x - to;
				to = x;
				target.color += color;
			}, endValue, duration).Blendable().SetTarget(target);
		}
	}
	public static class DOTweenModuleUI
	{
		public static class Utils
		{
			public static Vector2 SwitchToRectTransform(RectTransform from, RectTransform to)
			{
				Vector2 vector = new Vector2(from.rect.width * 0.5f + from.rect.xMin, from.rect.height * 0.5f + from.rect.yMin);
				Vector2 screenPoint = RectTransformUtility.WorldToScreenPoint(null, from.position);
				screenPoint += vector;
				RectTransformUtility.ScreenPointToLocalPointInRectangle(to, screenPoint, null, out var localPoint);
				Vector2 vector2 = new Vector2(to.rect.width * 0.5f + to.rect.xMin, to.rect.height * 0.5f + to.rect.yMin);
				return to.anchoredPosition + localPoint - vector2;
			}
		}

		public static Tweener DOFade(this CanvasGroup target, float endValue, float duration)
		{
			return DOTween.To(() => target.alpha, delegate(float x)
			{
				target.alpha = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOColor(this Graphic target, Color endValue, float duration)
		{
			return DOTween.To(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOFade(this Graphic target, float endValue, float duration)
		{
			return DOTween.ToAlpha(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOColor(this Image target, Color endValue, float duration)
		{
			return DOTween.To(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOFade(this Image target, float endValue, float duration)
		{
			return DOTween.ToAlpha(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOFillAmount(this Image target, float endValue, float duration)
		{
			if (endValue > 1f)
			{
				endValue = 1f;
			}
			else if (endValue < 0f)
			{
				endValue = 0f;
			}
			return DOTween.To(() => target.fillAmount, delegate(float x)
			{
				target.fillAmount = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Sequence DOGradientColor(this Image target, Gradient gradient, float duration)
		{
			Sequence sequence = DOTween.Sequence();
			GradientColorKey[] colorKeys = gradient.colorKeys;
			int num = colorKeys.Length;
			for (int i = 0; i < num; i++)
			{
				GradientColorKey gradientColorKey = colorKeys[i];
				if (i == 0 && gradientColorKey.time <= 0f)
				{
					target.color = gradientColorKey.color;
					continue;
				}
				float duration2 = ((i == num - 1) ? (duration - sequence.Duration(includeLoops: false)) : (duration * ((i == 0) ? gradientColorKey.time : (gradientColorKey.time - colorKeys[i - 1].time))));
				sequence.Append(target.DOColor(gradientColorKey.color, duration2).SetEase(Ease.Linear));
			}
			return sequence;
		}

		public static Tweener DOFlexibleSize(this LayoutElement target, Vector2 endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => new Vector2(target.flexibleWidth, target.flexibleHeight), delegate(Vector2 x)
			{
				target.flexibleWidth = x.x;
				target.flexibleHeight = x.y;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOMinSize(this LayoutElement target, Vector2 endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => new Vector2(target.minWidth, target.minHeight), delegate(Vector2 x)
			{
				target.minWidth = x.x;
				target.minHeight = x.y;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOPreferredSize(this LayoutElement target, Vector2 endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => new Vector2(target.preferredWidth, target.preferredHeight), delegate(Vector2 x)
			{
				target.preferredWidth = x.x;
				target.preferredHeight = x.y;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOColor(this Outline target, Color endValue, float duration)
		{
			return DOTween.To(() => target.effectColor, delegate(Color x)
			{
				target.effectColor = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOFade(this Outline target, float endValue, float duration)
		{
			return DOTween.ToAlpha(() => target.effectColor, delegate(Color x)
			{
				target.effectColor = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOScale(this Outline target, Vector2 endValue, float duration)
		{
			return DOTween.To(() => target.effectDistance, delegate(Vector2 x)
			{
				target.effectDistance = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOAnchorPos(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.anchoredPosition, delegate(Vector2 x)
			{
				target.anchoredPosition = x;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOAnchorPosX(this RectTransform target, float endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.anchoredPosition, delegate(Vector2 x)
			{
				target.anchoredPosition = x;
			}, new Vector2(endValue, 0f), duration).SetOptions(AxisConstraint.X, snapping).SetTarget(target);
		}

		public static Tweener DOAnchorPosY(this RectTransform target, float endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.anchoredPosition, delegate(Vector2 x)
			{
				target.anchoredPosition = x;
			}, new Vector2(0f, endValue), duration).SetOptions(AxisConstraint.Y, snapping).SetTarget(target);
		}

		public static Tweener DOAnchorPos3D(this RectTransform target, Vector3 endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.anchoredPosition3D, delegate(Vector3 x)
			{
				target.anchoredPosition3D = x;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOAnchorPos3DX(this RectTransform target, float endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.anchoredPosition3D, delegate(Vector3 x)
			{
				target.anchoredPosition3D = x;
			}, new Vector3(endValue, 0f, 0f), duration).SetOptions(AxisConstraint.X, snapping).SetTarget(target);
		}

		public static Tweener DOAnchorPos3DY(this RectTransform target, float endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.anchoredPosition3D, delegate(Vector3 x)
			{
				target.anchoredPosition3D = x;
			}, new Vector3(0f, endValue, 0f), duration).SetOptions(AxisConstraint.Y, snapping).SetTarget(target);
		}

		public static Tweener DOAnchorPos3DZ(this RectTransform target, float endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.anchoredPosition3D, delegate(Vector3 x)
			{
				target.anchoredPosition3D = x;
			}, new Vector3(0f, 0f, endValue), duration).SetOptions(AxisConstraint.Z, snapping).SetTarget(target);
		}

		public static Tweener DOAnchorMax(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.anchorMax, delegate(Vector2 x)
			{
				target.anchorMax = x;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOAnchorMin(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.anchorMin, delegate(Vector2 x)
			{
				target.anchorMin = x;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOPivot(this RectTransform target, Vector2 endValue, float duration)
		{
			return DOTween.To(() => target.pivot, delegate(Vector2 x)
			{
				target.pivot = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOPivotX(this RectTransform target, float endValue, float duration)
		{
			return DOTween.To(() => target.pivot, delegate(Vector2 x)
			{
				target.pivot = x;
			}, new Vector2(endValue, 0f), duration).SetOptions(AxisConstraint.X).SetTarget(target);
		}

		public static Tweener DOPivotY(this RectTransform target, float endValue, float duration)
		{
			return DOTween.To(() => target.pivot, delegate(Vector2 x)
			{
				target.pivot = x;
			}, new Vector2(0f, endValue), duration).SetOptions(AxisConstraint.Y).SetTarget(target);
		}

		public static Tweener DOSizeDelta(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.sizeDelta, delegate(Vector2 x)
			{
				target.sizeDelta = x;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOPunchAnchorPos(this RectTransform target, Vector2 punch, float duration, int vibrato = 10, float elasticity = 1f, bool snapping = false)
		{
			return DOTween.Punch(() => target.anchoredPosition, delegate(Vector3 x)
			{
				target.anchoredPosition = x;
			}, punch, duration, vibrato, elasticity).SetTarget(target).SetOptions(snapping);
		}

		public static Tweener DOShakeAnchorPos(this RectTransform target, float duration, float strength = 100f, int vibrato = 10, float randomness = 90f, bool snapping = false, bool fadeOut = true)
		{
			return DOTween.Shake(() => target.anchoredPosition, delegate(Vector3 x)
			{
				target.anchoredPosition = x;
			}, duration, strength, vibrato, randomness, ignoreZAxis: true, fadeOut).SetTarget(target).SetSpecialStartupMode(SpecialStartupMode.SetShake)
				.SetOptions(snapping);
		}

		public static Tweener DOShakeAnchorPos(this RectTransform target, float duration, Vector2 strength, int vibrato = 10, float randomness = 90f, bool snapping = false, bool fadeOut = true)
		{
			return DOTween.Shake(() => target.anchoredPosition, delegate(Vector3 x)
			{
				target.anchoredPosition = x;
			}, duration, strength, vibrato, randomness, fadeOut).SetTarget(target).SetSpecialStartupMode(SpecialStartupMode.SetShake)
				.SetOptions(snapping);
		}

		public static Sequence DOJumpAnchorPos(this RectTransform target, Vector2 endValue, float jumpPower, int numJumps, float duration, bool snapping = false)
		{
			if (numJumps < 1)
			{
				numJumps = 1;
			}
			float startPosY = 0f;
			float offsetY = -1f;
			bool offsetYSet = false;
			Sequence s = DOTween.Sequence();
			Tween t = DOTween.To(() => target.anchoredPosition, delegate(Vector2 x)
			{
				target.anchoredPosition = x;
			}, new Vector2(0f, jumpPower), duration / (float)(numJumps * 2)).SetOptions(AxisConstraint.Y, snapping).SetEase(Ease.OutQuad)
				.SetRelative()
				.SetLoops(numJumps * 2, LoopType.Yoyo)
				.OnStart(delegate
				{
					startPosY = target.anchoredPosition.y;
				});
			s.Append(DOTween.To(() => target.anchoredPosition, delegate(Vector2 x)
			{
				target.anchoredPosition = x;
			}, new Vector2(endValue.x, 0f), duration).SetOptions(AxisConstraint.X, snapping).SetEase(Ease.Linear)).Join(t).SetTarget(target)
				.SetEase(DOTween.defaultEaseType);
			s.OnUpdate(delegate
			{
				if (!offsetYSet)
				{
					offsetYSet = true;
					offsetY = (s.isRelative ? endValue.y : (endValue.y - startPosY));
				}
				Vector2 anchoredPosition = target.anchoredPosition;
				anchoredPosition.y += DOVirtual.EasedValue(0f, offsetY, s.ElapsedDirectionalPercentage(), Ease.OutQuad);
				target.anchoredPosition = anchoredPosition;
			});
			return s;
		}

		public static Tweener DONormalizedPos(this ScrollRect target, Vector2 endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => new Vector2(target.horizontalNormalizedPosition, target.verticalNormalizedPosition), delegate(Vector2 x)
			{
				target.horizontalNormalizedPosition = x.x;
				target.verticalNormalizedPosition = x.y;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOHorizontalNormalizedPos(this ScrollRect target, float endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.horizontalNormalizedPosition, delegate(float x)
			{
				target.horizontalNormalizedPosition = x;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOVerticalNormalizedPos(this ScrollRect target, float endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.verticalNormalizedPosition, delegate(float x)
			{
				target.verticalNormalizedPosition = x;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOValue(this Slider target, float endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.value, delegate(float x)
			{
				target.value = x;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOColor(this Text target, Color endValue, float duration)
		{
			return DOTween.To(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOFade(this Text target, float endValue, float duration)
		{
			return DOTween.ToAlpha(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOText(this Text target, string endValue, float duration, bool richTextEnabled = true, ScrambleMode scrambleMode = ScrambleMode.None, string scrambleChars = null)
		{
			return DOTween.To(() => target.text, delegate(string x)
			{
				target.text = x;
			}, endValue, duration).SetOptions(richTextEnabled, scrambleMode, scrambleChars).SetTarget(target);
		}

		public static Tweener DOBlendableColor(this Graphic target, Color endValue, float duration)
		{
			endValue -= target.color;
			Color to = new Color(0f, 0f, 0f, 0f);
			return DOTween.To(() => to, delegate(Color x)
			{
				Color color = x - to;
				to = x;
				target.color += color;
			}, endValue, duration).Blendable().SetTarget(target);
		}

		public static Tweener DOBlendableColor(this Image target, Color endValue, float duration)
		{
			endValue -= target.color;
			Color to = new Color(0f, 0f, 0f, 0f);
			return DOTween.To(() => to, delegate(Color x)
			{
				Color color = x - to;
				to = x;
				target.color += color;
			}, endValue, duration).Blendable().SetTarget(target);
		}

		public static Tweener DOBlendableColor(this Text target, Color endValue, float duration)
		{
			endValue -= target.color;
			Color to = new Color(0f, 0f, 0f, 0f);
			return DOTween.To(() => to, delegate(Color x)
			{
				Color color = x - to;
				to = x;
				target.color += color;
			}, endValue, duration).Blendable().SetTarget(target);
		}
	}
	public static class DOTweenModuleUnityVersion
	{
		public static Sequence DOGradientColor(this Material target, Gradient gradient, float duration)
		{
			Sequence sequence = DOTween.Sequence();
			GradientColorKey[] colorKeys = gradient.colorKeys;
			int num = colorKeys.Length;
			for (int i = 0; i < num; i++)
			{
				GradientColorKey gradientColorKey = colorKeys[i];
				if (i == 0 && gradientColorKey.time <= 0f)
				{
					target.color = gradientColorKey.color;
					continue;
				}
				float duration2 = ((i == num - 1) ? (duration - sequence.Duration(includeLoops: false)) : (duration * ((i == 0) ? gradientColorKey.time : (gradientColorKey.time - colorKeys[i - 1].time))));
				sequence.Append(target.DOColor(gradientColorKey.color, duration2).SetEase(Ease.Linear));
			}
			return sequence;
		}

		public static Sequence DOGradientColor(this Material target, Gradient gradient, string property, float duration)
		{
			Sequence sequence = DOTween.Sequence();
			GradientColorKey[] colorKeys = gradient.colorKeys;
			int num = colorKeys.Length;
			for (int i = 0; i < num; i++)
			{
				GradientColorKey gradientColorKey = colorKeys[i];
				if (i == 0 && gradientColorKey.time <= 0f)
				{
					target.color = gradientColorKey.color;
					continue;
				}
				float duration2 = ((i == num - 1) ? (duration - sequence.Duration(includeLoops: false)) : (duration * ((i == 0) ? gradientColorKey.time : (gradientColorKey.time - colorKeys[i - 1].time))));
				sequence.Append(target.DOColor(gradientColorKey.color, property, duration2).SetEase(Ease.Linear));
			}
			return sequence;
		}

		public static CustomYieldInstruction WaitForCompletion(this Tween t, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForCompletion(t);
		}

		public static CustomYieldInstruction WaitForRewind(this Tween t, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForRewind(t);
		}

		public static CustomYieldInstruction WaitForKill(this Tween t, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForKill(t);
		}

		public static CustomYieldInstruction WaitForElapsedLoops(this Tween t, int elapsedLoops, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForElapsedLoops(t, elapsedLoops);
		}

		public static CustomYieldInstruction WaitForPosition(this Tween t, float position, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForPosition(t, position);
		}

		public static CustomYieldInstruction WaitForStart(this Tween t, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForStart(t);
		}
	}
	public static class DOTweenCYInstruction
	{
		public class WaitForCompletion : CustomYieldInstruction
		{
			private readonly Tween t;

			public override bool keepWaiting
			{
				get
				{
					if (t.active)
					{
						return !t.IsComplete();
					}
					return false;
				}
			}

			public WaitForCompletion(Tween tween)
			{
				t = tween;
			}
		}

		public class WaitForRewind : CustomYieldInstruction
		{
			private readonly Tween t;

			public override bool keepWaiting
			{
				get
				{
					if (t.active)
					{
						if (t.playedOnce)
						{
							return t.position * (float)(t.CompletedLoops() + 1) > 0f;
						}
						return true;
					}
					return false;
				}
			}

			public WaitForRewind(Tween tween)
			{
				t = tween;
			}
		}

		public class WaitForKill : CustomYieldInstruction
		{
			private readonly Tween t;

			public override bool keepWaiting => t.active;

			public WaitForKill(Tween tween)
			{
				t = tween;
			}
		}

		public class WaitForElapsedLoops : CustomYieldInstruction
		{
			private readonly Tween t;

			private readonly int elapsedLoops;

			public override bool keepWaiting
			{
				get
				{
					if (t.active)
					{
						return t.CompletedLoops() < elapsedLoops;
					}
					return false;
				}
			}

			public WaitForElapsedLoops(Tween tween, int elapsedLoops)
			{
				t = tween;
				this.elapsedLoops = elapsedLoops;
			}
		}

		public class WaitForPosition : CustomYieldInstruction
		{
			private readonly Tween t;

			private readonly float position;

			public override bool keepWaiting
			{
				get
				{
					if (t.active)
					{
						return t.position * (float)(t.CompletedLoops() + 1) < position;
					}
					return false;
				}
			}

			public WaitForPosition(Tween tween, float position)
			{
				t = tween;
				this.position = position;
			}
		}

		public class WaitForStart : CustomYieldInstruction
		{
			private readonly Tween t;

			public override bool keepWaiting
			{
				get
				{
					if (t.active)
					{
						return !t.playedOnce;
					}
					return false;
				}
			}

			public WaitForStart(Tween tween)
			{
				t = tween;
			}
		}
	}
	public static class DOTweenModuleUtils
	{
		public static class Physics
		{
			public static void SetOrientationOnPath(PathOptions options, Tween t, Quaternion newRot, Transform trans)
			{
				trans.rotation = newRot;
			}

			public static bool HasRigidbody2D(Component target)
			{
				return false;
			}

			public static bool HasRigidbody(Component target)
			{
				return false;
			}

			public static TweenerCore<Vector3, DG.Tweening.Plugins.Core.PathCore.Path, PathOptions> CreateDOTweenPathTween(MonoBehaviour target, bool tweenRigidbody, bool isLocal, DG.Tweening.Plugins.Core.PathCore.Path path, float duration, PathMode pathMode)
			{
				if (!isLocal)
				{
					return target.transform.DOPath(path, duration, pathMode);
				}
				return target.transform.DOLocalPath(path, duration, pathMode);
			}
		}

		private static bool _initialized;

		public static void Init()
		{
			if (!_initialized)
			{
				_initialized = true;
				DOTweenExternalCommand.SetOrientationOnPath += Physics.SetOrientationOnPath;
			}
		}
	}
}
namespace UnityEngine.EventSystems
{
	public class LaserPointerEventData : PointerEventData
	{
		public LaserController laserController;

		public Vector3 dim3Position;

		public Vector3 dim3PressPosition;

		public LaserPointerEventData(EventSystem eventSystem)
			: base(eventSystem)
		{
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine("<b>Position</b>: " + base.position);
			stringBuilder.AppendLine("<b>delta</b>: " + base.delta);
			stringBuilder.AppendLine("<b>scrollDelta</b>: " + base.scrollDelta);
			stringBuilder.AppendLine("<b>pointerEnter</b>: " + base.pointerEnter);
			stringBuilder.AppendLine("<b>pointerPress</b>: " + base.pointerPress);
			stringBuilder.AppendLine("<b>lastPointerPress</b>: " + base.lastPress);
			stringBuilder.AppendLine("<b>pointerDrag</b>: " + base.pointerDrag);
			return stringBuilder.ToString();
		}
	}
	public static class LaserPointerEventDataExtension
	{
		public static bool IsLaserPointer(this PointerEventData pointerEventData)
		{
			return pointerEventData is LaserPointerEventData;
		}

		public static LaserController GetLaserController(this PointerEventData pointerEventData)
		{
			return (pointerEventData as LaserPointerEventData).laserController;
		}
	}
}
namespace UnityEngine.Timeline
{
	public class VideoPlayableBehaviour : PlayableBehaviour
	{
		public VideoPlayer videoPlayer;

		public VideoClip videoClip;

		public bool mute;

		public bool loop = true;

		public double preloadTime = 0.3;

		public double clipInTime;

		private bool playedOnce;

		private bool preparing;

		public void PrepareVideo()
		{
			if (videoPlayer == null || videoClip == null)
			{
				return;
			}
			videoPlayer.targetCameraAlpha = 0f;
			if (videoPlayer.clip != videoClip)
			{
				StopVideo();
			}
			if (videoPlayer.isPrepared || preparing)
			{
				return;
			}
			videoPlayer.source = VideoSource.VideoClip;
			videoPlayer.clip = videoClip;
			videoPlayer.playOnAwake = false;
			videoPlayer.waitForFirstFrame = true;
			videoPlayer.isLooping = loop;
			for (ushort num = 0; num < videoClip.audioTrackCount; num++)
			{
				if (videoPlayer.audioOutputMode == VideoAudioOutputMode.Direct)
				{
					videoPlayer.SetDirectAudioMute(num, mute || !Application.isPlaying);
				}
				else if (videoPlayer.audioOutputMode == VideoAudioOutputMode.AudioSource)
				{
					AudioSource targetAudioSource = videoPlayer.GetTargetAudioSource(num);
					if (targetAudioSource != null)
					{
						targetAudioSource.mute = mute || !Application.isPlaying;
					}
				}
			}
			videoPlayer.loopPointReached += LoopPointReached;
			videoPlayer.time = clipInTime;
			videoPlayer.Prepare();
			preparing = true;
		}

		private void LoopPointReached(VideoPlayer vp)
		{
			playedOnce = !loop;
		}

		public override void PrepareFrame(Playable playable, FrameData info)
		{
			if (!(videoPlayer == null) && !(videoClip == null))
			{
				videoPlayer.timeReference = (Application.isPlaying ? VideoTimeReference.ExternalTime : VideoTimeReference.Freerun);
				if (videoPlayer.isPlaying && Application.isPlaying)
				{
					videoPlayer.externalReferenceTime = playable.GetTime();
				}
				else if (!Application.isPlaying)
				{
					SyncVideoToPlayable(playable);
				}
			}
		}

		public override void OnBehaviourPlay(Playable playable, FrameData info)
		{
			if (!(videoPlayer == null) && !playedOnce)
			{
				PlayVideo();
				SyncVideoToPlayable(playable);
			}
		}

		public override void OnBehaviourPause(Playable playable, FrameData info)
		{
			if (!(videoPlayer == null))
			{
				if (Application.isPlaying)
				{
					PauseVideo();
				}
				else
				{
					StopVideo();
				}
			}
		}

		public override void ProcessFrame(Playable playable, FrameData info, object playerData)
		{
			if (videoPlayer == null || videoPlayer.clip == null)
			{
				return;
			}
			videoPlayer.targetCameraAlpha = info.weight;
			if (!Application.isPlaying)
			{
				return;
			}
			for (ushort num = 0; num < videoPlayer.clip.audioTrackCount; num++)
			{
				if (videoPlayer.audioOutputMode == VideoAudioOutputMode.Direct)
				{
					videoPlayer.SetDirectAudioVolume(num, info.weight);
				}
				else if (videoPlayer.audioOutputMode == VideoAudioOutputMode.AudioSource)
				{
					AudioSource targetAudioSource = videoPlayer.GetTargetAudioSource(num);
					if (targetAudioSource != null)
					{
						targetAudioSource.volume = info.weight;
					}
				}
			}
		}

		public override void OnGraphStart(Playable playable)
		{
			playedOnce = false;
		}

		public override void OnGraphStop(Playable playable)
		{
			if (!Application.isPlaying)
			{
				StopVideo();
			}
		}

		public override void OnPlayableDestroy(Playable playable)
		{
			StopVideo();
		}

		public void PlayVideo()
		{
			if (!(videoPlayer == null))
			{
				videoPlayer.Play();
				preparing = false;
				if (!Application.isPlaying)
				{
					PauseVideo();
				}
			}
		}

		public void PauseVideo()
		{
			if (!(videoPlayer == null))
			{
				videoPlayer.Pause();
				preparing = false;
			}
		}

		public void StopVideo()
		{
			if (!(videoPlayer == null))
			{
				playedOnce = false;
				videoPlayer.Stop();
				preparing = false;
			}
		}

		private void SyncVideoToPlayable(Playable playable)
		{
			if (!(videoPlayer == null) && !(videoPlayer.clip == null))
			{
				videoPlayer.time = (clipInTime + playable.GetTime() * (double)videoPlayer.playbackSpeed) % videoPlayer.clip.length;
			}
		}
	}
	public sealed class VideoSchedulerPlayableBehaviour : PlayableBehaviour
	{
		private IEnumerable<TimelineClip> m_Clips;

		private PlayableDirector m_Director;

		internal PlayableDirector director
		{
			get
			{
				return m_Director;
			}
			set
			{
				m_Director = value;
			}
		}

		internal IEnumerable<TimelineClip> clips
		{
			get
			{
				return m_Clips;
			}
			set
			{
				m_Clips = value;
			}
		}

		public override void ProcessFrame(Playable playable, FrameData info, object playerData)
		{
			if (m_Clips == null)
			{
				return;
			}
			int num = 0;
			foreach (TimelineClip clip in m_Clips)
			{
				VideoPlayableBehaviour behaviour = ((ScriptPlayable<VideoPlayableBehaviour>)playable.GetInput(num)).GetBehaviour();
				if (behaviour != null)
				{
					double num2 = Math.Max(0.0, behaviour.preloadTime);
					if (m_Director.time >= clip.start + clip.duration || m_Director.time <= clip.start - num2)
					{
						behaviour.StopVideo();
					}
					else if (m_Director.time > clip.start - num2)
					{
						behaviour.PrepareVideo();
					}
				}
				num++;
			}
		}
	}
	[Serializable]
	public class VideoScriptPlayableAsset : PlayableAsset
	{
		public ExposedReference<VideoPlayer> videoPlayer;

		[SerializeField]
		[NotKeyable]
		public VideoClip videoClip;

		[SerializeField]
		[NotKeyable]
		public bool mute;

		[SerializeField]
		[NotKeyable]
		public bool loop = true;

		[SerializeField]
		[NotKeyable]
		public double preloadTime = 0.3;

		[SerializeField]
		[NotKeyable]
		public double clipInTime;

		public override Playable CreatePlayable(PlayableGraph graph, GameObject go)
		{
			ScriptPlayable<VideoPlayableBehaviour> scriptPlayable = ScriptPlayable<VideoPlayableBehaviour>.Create(graph);
			VideoPlayableBehaviour behaviour = scriptPlayable.GetBehaviour();
			behaviour.videoPlayer = videoPlayer.Resolve(graph.GetResolver());
			behaviour.videoClip = videoClip;
			behaviour.mute = mute;
			behaviour.loop = loop;
			behaviour.preloadTime = preloadTime;
			behaviour.clipInTime = clipInTime;
			return scriptPlayable;
		}
	}
	[Serializable]
	[TrackClipType(typeof(VideoScriptPlayableAsset))]
	[TrackColor(0.008f, 0.698f, 0.655f)]
	public class VideoScriptPlayableTrack : TrackAsset
	{
		public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
		{
			PlayableDirector component = go.GetComponent<PlayableDirector>();
			ScriptPlayable<VideoSchedulerPlayableBehaviour> scriptPlayable = ScriptPlayable<VideoSchedulerPlayableBehaviour>.Create(graph, inputCount);
			VideoSchedulerPlayableBehaviour behaviour = scriptPlayable.GetBehaviour();
			if (behaviour != null)
			{
				behaviour.director = component;
				behaviour.clips = GetClips();
			}
			return scriptPlayable;
		}
	}
}
namespace MaxNeet
{
	public class SensitivityChecker : MonoBehaviour
	{
		public enum CalclateAXIS
		{
			X,
			Y,
			Z
		}

		private const float DEFAULT_FPS = 60f;

		[SerializeField]
		private CalclateAXIS currentAxis;

		[SerializeField]
		private float m_latestValue = 1000f;

		[SerializeField]
		private int m_secondsToCount = 6;

		[SerializeField]
		[Tooltip("700")]
		private float m_sensitivity = 700f;

		public Action OnPausedAction;

		private Transform m_mainCamera;

		private List<float> m_chachedEulerAngles = new List<float>();

		private float m_frameRate = 60f;

		public float LatestValue => m_latestValue;

		private void OnEnable()
		{
			if (m_mainCamera == null)
			{
				m_mainCamera = Camera.main.transform;
			}
			if (m_mainCamera == null)
			{
				UnityEngine.Debug.LogError("");
				UnityEngine.Object.Destroy(this);
				return;
			}
			m_frameRate = UnityEngine.Application.targetFrameRate;
			if (m_frameRate < 0f)
			{
				m_frameRate = 60f;
			}
			StartCoroutine(CheckSensitivity());
		}

		private void OnDisable()
		{
			StopAllCoroutines();
		}

		private IEnumerator CheckSensitivity()
		{
			yield return new WaitForSeconds(1f);
			while (true)
			{
				yield return new WaitForSeconds(2f);
				if ((float)m_chachedEulerAngles.Count <= m_frameRate * (float)m_secondsToCount - 2f)
				{
					continue;
				}
				float num = (m_latestValue = GetVariance());
				UnityEngine.Debug.Log(":" + num);
				if (m_sensitivity > num)
				{
					UnityEngine.Debug.Log("");
					if (OnPausedAction != null)
					{
						OnPausedAction();
					}
					m_chachedEulerAngles.Clear();
				}
			}
		}

		private float GetVariance()
		{
			float num = m_chachedEulerAngles.Average();
			float num2 = 0f;
			int count = m_chachedEulerAngles.Count;
			for (int i = 0; i < count; i++)
			{
				num2 += Mathf.Pow(m_chachedEulerAngles[i] - num, 2f);
			}
			return num2 / (float)m_secondsToCount;
		}

		private void Update()
		{
			UpdateEularAngleChach();
		}

		private void UpdateEularAngleChach()
		{
			float currentAngle = GetCurrentAngle();
			m_chachedEulerAngles.Add(currentAngle);
			if ((float)m_chachedEulerAngles.Count > m_frameRate * (float)m_secondsToCount)
			{
				m_chachedEulerAngles.RemoveAt(0);
			}
		}

		private float GetCurrentAngle()
		{
			return currentAxis switch
			{
				CalclateAXIS.X => m_mainCamera.eulerAngles.x * 100f, 
				CalclateAXIS.Y => m_mainCamera.eulerAngles.y * 100f, 
				CalclateAXIS.Z => m_mainCamera.eulerAngles.z * 100f, 
				_ => m_mainCamera.eulerAngles.x * 100f, 
			};
		}
	}
}
namespace Common
{
	public static class AudioSourceExtension
	{
		public static bool Play(this AudioSource source, AudioClip clip = null, float volume = 1f)
		{
			if (clip == null || volume <= 0f)
			{
				return false;
			}
			source.clip = clip;
			source.volume = volume;
			source.Play();
			return true;
		}
	}
	public static class CameraExtensions
	{
		public static void LayerCullingShow(this Camera cam, int layerMask)
		{
			cam.cullingMask |= layerMask;
		}

		public static void LayerCullingShow(this Camera cam, string layer)
		{
			cam.LayerCullingShow(1 << LayerMask.NameToLayer(layer));
		}

		public static void LayerCullingHide(this Camera cam, int layerMask)
		{
			cam.cullingMask &= ~layerMask;
		}

		public static void LayerCullingHide(this Camera cam, string layer)
		{
			cam.LayerCullingHide(1 << LayerMask.NameToLayer(layer));
		}

		public static void LayerCullingToggle(this Camera cam, int layerMask)
		{
			cam.cullingMask ^= layerMask;
		}

		public static void LayerCullingToggle(this Camera cam, string layer)
		{
			cam.LayerCullingToggle(1 << LayerMask.NameToLayer(layer));
		}

		public static bool LayerCullingIncludes(this Camera cam, int layerMask)
		{
			return (cam.cullingMask & layerMask) > 0;
		}

		public static bool LayerCullingIncludes(this Camera cam, string layer)
		{
			return cam.LayerCullingIncludes(1 << LayerMask.NameToLayer(layer));
		}

		public static void LayerCullingToggle(this Camera cam, int layerMask, bool isOn)
		{
			bool flag = cam.LayerCullingIncludes(layerMask);
			if (isOn && !flag)
			{
				cam.LayerCullingShow(layerMask);
			}
			else if (!isOn && flag)
			{
				cam.LayerCullingHide(layerMask);
			}
		}

		public static void LayerCullingToggle(this Camera cam, string layer, bool isOn)
		{
			cam.LayerCullingToggle(1 << LayerMask.NameToLayer(layer), isOn);
		}
	}
	public static class ColorExtension
	{
		public static Color WithAlpha(this Color color, float alpha)
		{
			return new Color(color.r, color.g, color.b, alpha);
		}
	}
	public static class GameObjectExtension
	{
		public static void Destroy(this GameObject self)
		{
			UnityEngine.Object.Destroy(self);
		}

		public static bool HasComponent<T>(this GameObject self) where T : Component
		{
			return self.GetComponent<T>() != null;
		}

		public static T GetOrAddComponent<T>(this GameObject self) where T : Component
		{
			return self.GetComponent<T>() ?? self.AddComponent<T>();
		}

		public static bool IsNull(GameObject obj)
		{
			return (object)obj == null;
		}
	}
	public static class MonoBehaviourExtension
	{
		public static void Destroy(this Component self)
		{
			UnityEngine.Object.Destroy(self);
		}

		public static void DestroyImmediate(this Component self)
		{
			UnityEngine.Object.DestroyImmediate(self);
		}

		public static bool HasComponent<T>(this Component self) where T : Component
		{
			return self.GetComponent<T>() != null;
		}
	}
	public static class QuaternionExtension
	{
		public static readonly Quaternion IDENTITY = new Quaternion(0f, 0f, 0f, 1f);

		private static Matrix4x4 _tempMatrix = Matrix4x4.identity;

		private static float[] _calculationFloats = new float[4];

		private static float[] _cauculattionMaterixElements = new float[4];

		public static Vector3 CreateUp(this Quaternion rotation)
		{
			return Vector3Extension.Multiply(ref Vector3Extension.Up, ref rotation);
		}

		public static Vector3 CreateUp(ref Quaternion rotation)
		{
			return Vector3Extension.Multiply(ref Vector3Extension.Up, ref rotation);
		}

		public static Vector3 CreateRight(ref Quaternion rotation)
		{
			return Vector3Extension.Multiply(ref Vector3Extension.Right, ref rotation);
		}

		public static Vector3 CreateRight(this Quaternion rotation)
		{
			return Vector3Extension.Multiply(ref Vector3Extension.Right, ref rotation);
		}

		public static Vector3 CreateForward(ref Quaternion rotation)
		{
			return Vector3Extension.Multiply(ref Vector3Extension.Forward, ref rotation);
		}

		public static Vector3 CreateForward(this Quaternion rotation)
		{
			return Vector3Extension.Multiply(ref Vector3Extension.Forward, ref rotation);
		}

		public static Quaternion GetLookAt(ref Vector3 position, ref Vector3 target)
		{
			Vector3 rhs = Vector3Extension.Direction(ref target, ref position);
			Vector3 v = Vector3Extension.CrossProduct(ref Vector3Extension.Up, ref rhs);
			Vector3Extension.Normalize(ref v);
			Vector3 v2 = Vector3Extension.CrossProduct(ref rhs, ref v);
			Vector3Extension.Normalize(ref v2);
			Matrix4x4 m = Matrix4x4.identity;
			m[0, 0] = v.x;
			m[0, 1] = v2.x;
			m[0, 2] = rhs.x;
			m[1, 0] = v.y;
			m[1, 1] = v2.y;
			m[1, 2] = rhs.y;
			m[2, 0] = v.z;
			m[2, 1] = v2.z;
			m[2, 2] = rhs.z;
			return GetRotation(ref m);
		}

		public static void CreateLookAt(ref Vector3 position, ref Vector3 target, ref Quaternion rotation)
		{
			Vector3 rhs = Vector3Extension.Direction(ref target, ref position);
			Vector3 v = Vector3Extension.CrossProduct(ref Vector3Extension.Up, ref rhs);
			Vector3Extension.Normalize(ref v);
			Vector3 v2 = Vector3Extension.CrossProduct(ref rhs, ref v);
			Vector3Extension.Normalize(ref v2);
			_tempMatrix = Matrix4x4.identity;
			_tempMatrix[0, 0] = v.x;
			_tempMatrix[0, 1] = v2.x;
			_tempMatrix[0, 2] = rhs.x;
			_tempMatrix[1, 0] = v.y;
			_tempMatrix[1, 1] = v2.y;
			_tempMatrix[1, 2] = rhs.y;
			_tempMatrix[2, 0] = v.z;
			_tempMatrix[2, 1] = v2.z;
			_tempMatrix[2, 2] = rhs.z;
			SetRotation(ref _tempMatrix, ref rotation);
		}

		public static Quaternion Slerp(ref Quaternion a, ref Quaternion b, float t)
		{
			t = Mathf.Clamp(t, 0f, 1f);
			return SlerpUnclamped(ref a, ref b, t);
		}

		private static Quaternion SlerpUnclamped(ref Quaternion a, ref Quaternion b, float t)
		{
			if (LengthSquared(ref a) == 0f)
			{
				if (LengthSquared(ref b) == 0f)
				{
					return IDENTITY;
				}
				return b;
			}
			if (LengthSquared(ref b) == 0f)
			{
				return a;
			}
			Vector3 lhs = new Vector3(a.x, a.y, a.z);
			Vector3 rhs = new Vector3(b.x, b.y, b.z);
			float w = a.w;
			float w2 = b.w;
			float num = w * w2 + Vector3Extension.DotProduct(ref lhs, ref rhs);
			if (num >= 1f || num <= -1f)
			{
				return a;
			}
			if (num < 0f)
			{
				Vector3 target = rhs;
				Vector3Extension.MultiplyTarget(-1f, ref target);
				b.x = target.x;
				b.y = target.y;
				b.z = target.z;
				w2 = 0f - w2;
				b.w = w2;
				num = 0f - num;
			}
			float num5;
			float num6;
			if (num < 0.99f)
			{
				float num2 = (float)Math.Acos(num);
				float num3 = (float)Math.Sin(num2);
				float num4 = 1f / num3;
				num5 = (float)Math.Sin(num2 * (1f - t)) * num4;
				num6 = (float)Math.Sin(num2 * t) * num4;
			}
			else
			{
				num5 = 1f - t;
				num6 = t;
			}
			float x = num5 * a.x + num6 * b.x;
			float y = num5 * a.y + num6 * b.y;
			float z = num5 * a.z + num6 * b.z;
			float w3 = num5 * a.w + num6 * b.w;
			Quaternion a2 = new Quaternion(x, y, z, w3);
			if (LengthSquared(ref a2) > 0f)
			{
				Normalize(ref a2);
				return a2;
			}
			return IDENTITY;
		}

		public static float LengthSquared(ref Quaternion a)
		{
			return a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
		}

		public static float LengthSquared(this Quaternion a)
		{
			return a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
		}

		public static void Normalize(ref Quaternion a)
		{
			float num = 1f / Length(ref a);
			a.x *= num;
			a.y *= num;
			a.z *= num;
			a.w *= num;
		}

		public static float Length(ref Quaternion a)
		{
			return (float)Math.Sqrt(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
		}

		private static void SetRotation(ref Matrix4x4 m, ref Quaternion result)
		{
			_cauculattionMaterixElements[0] = m.m00 - m.m11 - m.m22 + 1f;
			_cauculattionMaterixElements[1] = 0f - m.m00 + m.m11 - m.m22 + 1f;
			_cauculattionMaterixElements[2] = 0f - m.m00 - m.m11 + m.m22 + 1f;
			_cauculattionMaterixElements[3] = m.m00 + m.m11 + m.m22 + 1f;
			int num = _cauculattionMaterixElements.Length;
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				if (_cauculattionMaterixElements[i] > _cauculattionMaterixElements[num2])
				{
					num2 = i;
				}
			}
			if (_cauculattionMaterixElements[num2] < 0f)
			{
				result = IDENTITY;
				return;
			}
			float num3 = Mathf.Sqrt(_cauculattionMaterixElements[num2]) * 0.5f;
			_calculationFloats[num2] = num3;
			float num4 = 0.25f / num3;
			switch (num2)
			{
			case 0:
				_calculationFloats[1] = (m.m10 + m.m01) * num4;
				_calculationFloats[2] = (m.m02 + m.m20) * num4;
				_calculationFloats[3] = (m.m21 - m.m12) * num4;
				break;
			case 1:
				_calculationFloats[0] = (m.m10 + m.m01) * num4;
				_calculationFloats[2] = (m.m21 + m.m12) * num4;
				_calculationFloats[3] = (m.m02 - m.m20) * num4;
				break;
			case 2:
				_calculationFloats[0] = (m.m02 + m.m20) * num4;
				_calculationFloats[1] = (m.m21 + m.m12) * num4;
				_calculationFloats[3] = (m.m10 - m.m01) * num4;
				break;
			case 3:
				_calculationFloats[0] = (m.m21 - m.m12) * num4;
				_calculationFloats[1] = (m.m02 - m.m20) * num4;
				_calculationFloats[2] = (m.m10 - m.m01) * num4;
				break;
			}
			result.x = _calculationFloats[0];
			result.y = _calculationFloats[1];
			result.z = _calculationFloats[2];
			result.w = _calculationFloats[3];
		}

		private static Quaternion GetRotation(ref Matrix4x4 m)
		{
			_cauculattionMaterixElements[0] = m.m00 - m.m11 - m.m22 + 1f;
			_cauculattionMaterixElements[1] = 0f - m.m00 + m.m11 - m.m22 + 1f;
			_cauculattionMaterixElements[2] = 0f - m.m00 - m.m11 + m.m22 + 1f;
			_cauculattionMaterixElements[3] = m.m00 + m.m11 + m.m22 + 1f;
			int num = _cauculattionMaterixElements.Length;
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				if (_cauculattionMaterixElements[i] > _cauculattionMaterixElements[num2])
				{
					num2 = i;
				}
			}
			if (_cauculattionMaterixElements[num2] < 0f)
			{
				return default(Quaternion);
			}
			float num3 = Mathf.Sqrt(_cauculattionMaterixElements[num2]) * 0.5f;
			_calculationFloats[num2] = num3;
			float num4 = 0.25f / num3;
			switch (num2)
			{
			case 0:
				_calculationFloats[1] = (m.m10 + m.m01) * num4;
				_calculationFloats[2] = (m.m02 + m.m20) * num4;
				_calculationFloats[3] = (m.m21 - m.m12) * num4;
				break;
			case 1:
				_calculationFloats[0] = (m.m10 + m.m01) * num4;
				_calculationFloats[2] = (m.m21 + m.m12) * num4;
				_calculationFloats[3] = (m.m02 - m.m20) * num4;
				break;
			case 2:
				_calculationFloats[0] = (m.m02 + m.m20) * num4;
				_calculationFloats[1] = (m.m21 + m.m12) * num4;
				_calculationFloats[3] = (m.m10 - m.m01) * num4;
				break;
			case 3:
				_calculationFloats[0] = (m.m21 - m.m12) * num4;
				_calculationFloats[1] = (m.m02 - m.m20) * num4;
				_calculationFloats[2] = (m.m10 - m.m01) * num4;
				break;
			}
			return new Quaternion(_calculationFloats[0], _calculationFloats[1], _calculationFloats[2], _calculationFloats[3]);
		}
	}
	public static class RectTransformExtension
	{
		public static float GetWidth(this RectTransform self)
		{
			return self.sizeDelta.x;
		}

		public static float GetHeight(this RectTransform self)
		{
			return self.sizeDelta.y;
		}

		public static void SetWidth(this RectTransform self, float width)
		{
			Vector2 sizeDelta = self.sizeDelta;
			sizeDelta.x = width;
			self.sizeDelta = sizeDelta;
		}

		public static void SetHeight(this RectTransform self, float height)
		{
			Vector2 sizeDelta = self.sizeDelta;
			sizeDelta.y = height;
			self.sizeDelta = sizeDelta;
		}

		public static void SetSize(this RectTransform self, float width, float height)
		{
			self.sizeDelta = new Vector2(width, height);
		}

		private static int CountCornersVisibleFrom(RectTransform rectTransform, Rect windowRect)
		{
			Vector3[] array = new Vector3[4];
			rectTransform.GetWorldCorners(array);
			int num = 0;
			foreach (Vector3 point in array)
			{
				if (windowRect.Contains(point))
				{
					num++;
				}
			}
			return num;
		}

		public static Rect GetWorldRect(this RectTransform rt, Vector2 scale)
		{
			Vector3[] array = new Vector3[4];
			rt.GetWorldCorners(array);
			Vector3 vector = array[0];
			Vector3 vector2 = array[2];
			float width = Mathf.Abs(vector2.x - vector.x);
			float height = Mathf.Abs(vector.y - vector2.y);
			return new Rect(vector.x, vector.y, width, height);
		}

		public static bool IsFullyVisibleFrom(this RectTransform rectTransform, Rect windowRect)
		{
			return CountCornersVisibleFrom(rectTransform, windowRect) == 4;
		}

		public static bool IsVisibleFrom(this RectTransform rectTransform, Rect windowRect)
		{
			return CountCornersVisibleFrom(rectTransform, windowRect) > 0;
		}
	}
	public static class StringExtension
	{
		public static bool FastStartsWith(this string a, string b)
		{
			int length = a.Length;
			int length2 = b.Length;
			int num = 0;
			int num2 = 0;
			while (num < length && num2 < length2 && a[num] == b[num2])
			{
				num++;
				num2++;
			}
			if (num2 != length2 || length < length2)
			{
				if (num == length)
				{
					return length2 >= length;
				}
				return false;
			}
			return true;
		}

		public static bool FastEndsWith(this string a, string b)
		{
			int num = a.Length - 1;
			int num2 = b.Length - 1;
			while (num >= 0 && num2 >= 0 && a[num] == b[num2])
			{
				num--;
				num2--;
			}
			if (num2 >= 0 || a.Length < b.Length)
			{
				if (num < 0)
				{
					return b.Length >= a.Length;
				}
				return false;
			}
			return true;
		}
	}
	public static class TransformExtension
	{
		public static Transform FindDeep(this Component self, string name, bool isIncludeInactive = false)
		{
			Transform[] componentsInChildren = self.GetComponentsInChildren<Transform>(isIncludeInactive);
			foreach (Transform transform in componentsInChildren)
			{
				if (transform.name == name)
				{
					return transform;
				}
			}
			return null;
		}

		public static void ResetLocal(this Transform transform)
		{
			transform.localPosition = Vector3.zero;
			transform.localRotation = Quaternion.identity;
			transform.localScale = Vector3.one;
		}

		public static void ResetLocal(this Transform transform, bool isResetPosition, bool isResetRotation, bool isResetScale)
		{
			if (isResetPosition)
			{
				transform.localPosition = Vector3.zero;
			}
			if (isResetRotation)
			{
				transform.localRotation = Quaternion.identity;
			}
			if (isResetScale)
			{
				transform.localScale = Vector3.one;
			}
		}

		public static void ResetWorld(this Transform transform)
		{
			transform.position = Vector3.zero;
			transform.rotation = Quaternion.identity;
		}

		public static void ResetWorld(this Transform transform, bool isResetPosition, bool isResetRotation)
		{
			if (isResetPosition)
			{
				transform.position = Vector3.zero;
			}
			if (isResetRotation)
			{
				transform.rotation = Quaternion.identity;
			}
		}

		public static void TranslateX(this Transform self, float x)
		{
			self.Translate(x, 0f, 0f);
		}

		public static void TranslateY(this Transform self, float y)
		{
			self.Translate(0f, y, 0f);
		}

		public static void TranslateZ(this Transform self, float z)
		{
			self.Translate(0f, 0f, z);
		}

		public static void AddChildren(this Transform self, GameObject[] children)
		{
			Array.ForEach(children, delegate(GameObject child)
			{
				child.transform.parent = self;
			});
		}

		public static Vector3 CreateUp(this Transform self)
		{
			Quaternion rotation = self.rotation;
			return Vector3Extension.Multiply(ref Vector3Extension.Up, ref rotation);
		}

		public static Vector3 CreateRight(this Transform self)
		{
			Quaternion rotation = self.rotation;
			return Vector3Extension.Multiply(ref Vector3Extension.Right, ref rotation);
		}

		public static Vector3 CreateForward(this Transform self)
		{
			Quaternion rotation = self.rotation;
			return Vector3Extension.Multiply(ref Vector3Extension.Forward, ref rotation);
		}
	}
	public static class Vector2Extension
	{
		public static float Length(this Vector2 v)
		{
			return (float)Math.Sqrt(v.x * v.x + v.y * v.y);
		}

		public static float Length(ref Vector2 v)
		{
			return (float)Math.Sqrt(v.x * v.x + v.y * v.y);
		}
	}
	public static class Vector3Extension
	{
		public const float kEpsilon = 1E-05f;

		public const float kEpsilonNormalSqrt = 1E-15f;

		public static Vector3 Zero = Vector3.zero;

		public static Vector3 Up = Vector3.up;

		public static Vector3 Right = Vector3.right;

		public static Vector3 Forward = Vector3.forward;

		public static void Add(this Vector3 a, ref Vector3 b)
		{
			a.x += b.x;
			a.y += b.y;
			a.z += b.z;
		}

		public static Vector3 Add(ref Vector3 a, ref Vector3 b)
		{
			Vector3 result = default(Vector3);
			result.x = a.x + b.x;
			result.y = a.y + b.y;
			result.z = a.z + b.z;
			return result;
		}

		public static void Add(ref Vector3 a, ref Vector3 b, out Vector3 result)
		{
			result.x = a.x + b.x;
			result.y = a.y + b.y;
			result.z = a.z + b.z;
		}

		public static void AddTarget(ref Vector3 addTo, ref Vector3 addAmount)
		{
			addTo.x += addAmount.x;
			addTo.y += addAmount.y;
			addTo.z += addAmount.z;
		}

		public static void Subtract(this Vector3 a, ref Vector3 b)
		{
			a.x -= b.x;
			a.y -= b.y;
			a.z -= b.z;
		}

		public static Vector3 Subtract(ref Vector3 a, ref Vector3 b)
		{
			Vector3 result = default(Vector3);
			result.x = a.x - b.x;
			result.y = a.y - b.y;
			result.z = a.z - b.z;
			return result;
		}

		public static void Subtract(ref Vector3 a, ref Vector3 b, out Vector3 result)
		{
			result.x = a.x - b.x;
			result.y = a.y - b.y;
			result.z = a.z - b.z;
		}

		public static void SubtractTarget(ref Vector3 target, ref Vector3 subtractAmount)
		{
			target.x -= subtractAmount.x;
			target.y -= subtractAmount.y;
			target.z -= subtractAmount.z;
		}

		public static Vector3 Multiply(this Vector3 a, float d)
		{
			Vector3 result = default(Vector3);
			result.x = a.x * d;
			result.y = a.y * d;
			result.z = a.z * d;
			return result;
		}

		public static Vector3 Multiply(this Vector3 a, ref Vector3 b)
		{
			Vector3 result = default(Vector3);
			result.x = a.x * b.x;
			result.y = a.y * b.y;
			result.z = a.z * b.z;
			return result;
		}

		public static Vector3 Multiply(ref Vector3 a, float d)
		{
			Vector3 result = default(Vector3);
			result.x = a.x * d;
			result.y = a.y * d;
			result.z = a.z * d;
			return result;
		}

		public static void Multiply(ref Vector3 a, float d, out Vector3 result)
		{
			result.x = a.x * d;
			result.y = a.y * d;
			result.z = a.z * d;
		}

		public static Vector3 Multiply(ref Vector3 a, ref Vector3 b)
		{
			Vector3 result = default(Vector3);
			result.x = a.x * b.x;
			result.y = a.y * b.y;
			result.z = a.z * b.z;
			return result;
		}

		public static void Multiply(ref Vector3 a, ref Vector3 b, out Vector3 result)
		{
			result.x = a.x * b.x;
			result.y = a.y * b.y;
			result.z = a.z * b.z;
		}

		public static Vector3 Multiply(ref Vector3 point, ref Quaternion rotation)
		{
			float num = rotation.x * 2f;
			float num2 = rotation.y * 2f;
			float num3 = rotation.z * 2f;
			float num4 = rotation.x * num;
			float num5 = rotation.y * num2;
			float num6 = rotation.z * num3;
			float num7 = rotation.x * num2;
			float num8 = rotation.x * num3;
			float num9 = rotation.y * num3;
			float num10 = rotation.w * num;
			float num11 = rotation.w * num2;
			float num12 = rotation.w * num3;
			Vector3 result = default(Vector3);
			result.x = (1f - (num5 + num6)) * point.x + (num7 - num12) * point.y + (num8 + num11) * point.z;
			result.y = (num7 + num12) * point.x + (1f - (num4 + num6)) * point.y + (num9 - num10) * point.z;
			result.z = (num8 - num11) * point.x + (num9 + num10) * point.y + (1f - (num4 + num5)) * point.z;
			return result;
		}

		public static void MultiplyTarget(float amount, ref Vector3 target)
		{
			target.x *= amount;
			target.y *= amount;
			target.z *= amount;
		}

		public static void MultiplyTarget(ref Vector3 amount, ref Vector3 target)
		{
			target.x *= amount.x;
			target.y *= amount.y;
			target.z *= amount.z;
		}

		public static void MultiplyTarget(ref Quaternion rotation, ref Vector3 target)
		{
			float num = rotation.x * 2f;
			float num2 = rotation.y * 2f;
			float num3 = rotation.z * 2f;
			float num4 = rotation.x * num;
			float num5 = rotation.y * num2;
			float num6 = rotation.z * num3;
			float num7 = rotation.x * num2;
			float num8 = rotation.x * num3;
			float num9 = rotation.y * num3;
			float num10 = rotation.w * num;
			float num11 = rotation.w * num2;
			float num12 = rotation.w * num3;
			target.x = (1f - (num5 + num6)) * target.x + (num7 - num12) * target.y + (num8 + num11) * target.z;
			target.y = (num7 + num12) * target.x + (1f - (num4 + num6)) * target.y + (num9 - num10) * target.z;
			target.z = (num8 - num11) * target.x + (num9 + num10) * target.y + (1f - (num4 + num5)) * target.z;
		}

		public static void Divide(this Vector3 a, float d)
		{
			a.x /= d;
			a.y /= d;
			a.z /= d;
		}

		public static Vector3 Divide(ref Vector3 a, float d)
		{
			Vector3 result = default(Vector3);
			result.x = a.x / d;
			result.y = a.y / d;
			result.z = a.z / d;
			return result;
		}

		public static void DivideOut(float d, ref Vector3 result)
		{
			result.x /= d;
			result.y /= d;
			result.z /= d;
		}

		public static void Divide(ref Vector3 a, float d, out Vector3 result)
		{
			result.x = a.x / d;
			result.y = a.y / d;
			result.z = a.z / d;
		}

		public static void Divide(ref Vector3 a, ref Vector3 b, out Vector3 result)
		{
			result.x = a.x / b.x;
			result.y = a.y / b.y;
			result.z = a.z / b.z;
		}

		public static Vector3 GetClosest(this Vector3 position, IEnumerable<Vector3> otherPositions)
		{
			Vector3 result = Vector3.zero;
			float num = float.PositiveInfinity;
			foreach (Vector3 otherPosition in otherPositions)
			{
				float sqrMagnitude = (position - otherPosition).sqrMagnitude;
				if (sqrMagnitude < num)
				{
					result = otherPosition;
					num = sqrMagnitude;
				}
			}
			return result;
		}

		public static void RotateAroundPivot(this Vector3 point, Vector3 pivot, Quaternion angle)
		{
			point = angle * (point - pivot) + pivot;
		}

		public static void RotateAroundPivot(this Vector3 point, Vector3 pivot, Vector3 euler)
		{
			point.RotateAroundPivot(pivot, Quaternion.Euler(euler));
		}

		public static void RotateAround(this Vector3 pos, ref Quaternion rotation, Vector3 point, Vector3 axis, float angle)
		{
			Vector3 vector = pos;
			Quaternion quaternion = Quaternion.AngleAxis(angle, axis);
			Vector3 vector2 = vector - point;
			vector2 = quaternion * vector2;
			pos = point + vector2;
			Quaternion quaternion2 = rotation;
			rotation *= Quaternion.Inverse(quaternion2) * quaternion * quaternion2;
		}

		public static float Normalize(ref Vector3 v, out Vector3 vv)
		{
			float num = (float)Math.Sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
			vv.x = v.x / num;
			vv.y = v.y / num;
			vv.z = v.z / num;
			return num;
		}

		public static float NormalizeXZ(ref Vector3 v)
		{
			float num = (float)Math.Sqrt(v.x * v.x + v.z * v.z);
			v.x /= num;
			v.z /= num;
			v.y = 0f;
			return num;
		}

		public static void Normalize(ref Vector3 v)
		{
			float num = v.Length();
			if (num <= 1E-05f)
			{
				v.x = 0f;
				v.y = 0f;
				v.z = 0f;
			}
			else
			{
				v.x /= num;
				v.y /= num;
				v.z /= num;
			}
		}

		public static float Angle(ref Vector3 a, ref Vector3 b)
		{
			float num = a.x * b.x + a.y * b.y + a.z * b.z;
			if (num < -1f)
			{
				num = -1f;
			}
			else if (num > 1f)
			{
				num = 1f;
			}
			return (float)Math.Acos(num) * 57.29578f;
		}

		public static float Length(this Vector3 v)
		{
			return (float)Math.Sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
		}

		public static float Length(ref Vector3 v)
		{
			return (float)Math.Sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
		}

		public static float LengthSquared(this Vector3 v)
		{
			return v.x * v.x + v.y * v.y + v.z * v.z;
		}

		public static float LengthSquared(ref Vector3 v)
		{
			return v.x * v.x + v.y * v.y + v.z * v.z;
		}

		public static float Distance(ref Vector3 left, ref Vector3 right)
		{
			float num = left.x - right.x;
			float num2 = left.y - right.y;
			float num3 = left.z - right.z;
			return (float)Math.Sqrt(num * num + num2 * num2 + num3 * num3);
		}

		public static float DistanceSquared(ref Vector3 left, ref Vector3 right)
		{
			float num = left.x - right.x;
			float num2 = left.y - right.y;
			float num3 = left.z - right.z;
			return num * num + num2 * num2 + num3 * num3;
		}

		public static float DotProduct(ref Vector3 lhs, ref Vector3 rhs)
		{
			return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;
		}

		public static Vector3 CrossProduct(ref Vector3 lhs, ref Vector3 rhs)
		{
			return new Vector3(lhs.y * rhs.z - lhs.z * rhs.y, lhs.z * rhs.x - lhs.x * rhs.z, lhs.x * rhs.y - lhs.y * rhs.x);
		}

		public static void CrossProduct(ref Vector3 lhs, ref Vector3 rhs, out Vector3 result)
		{
			result.x = lhs.y * rhs.z - lhs.z * rhs.y;
			result.y = lhs.z * rhs.x - lhs.x * rhs.z;
			result.z = lhs.x * rhs.y - lhs.y * rhs.x;
		}

		public static Vector3 Direction(ref Vector3 left, ref Vector3 right)
		{
			float num = left.x - right.x;
			float num2 = left.y - right.y;
			float num3 = left.z - right.z;
			float num4 = (float)Math.Sqrt(num * num + num2 * num2 + num3 * num3);
			return new Vector3(num / num4, num2 / num4, num3 / num4);
		}

		public static Vector3 Project(ref Vector3 vector, ref Vector3 onNormal)
		{
			float num = DotProduct(ref onNormal, ref onNormal);
			if (num < Mathf.Epsilon)
			{
				return new Vector3(0f, 0f, 0f);
			}
			float d = DotProduct(ref vector, ref onNormal);
			Vector3 a = Multiply(ref onNormal, d);
			Divide(ref a, num);
			return a;
		}

		public static void Project(ref Vector3 vector, ref Vector3 onNormal, out Vector3 result)
		{
			float num = DotProduct(ref onNormal, ref onNormal);
			if (num < Mathf.Epsilon)
			{
				result = Zero;
				return;
			}
			float d = DotProduct(ref vector, ref onNormal);
			Multiply(ref onNormal, d, out result);
			Divide(ref result, num, out result);
		}

		public static Vector3 Reflect(ref Vector3 inDirection, ref Vector3 inNormal)
		{
			float d = -2f * DotProduct(ref inNormal, ref inDirection);
			Vector3 a = Multiply(ref inNormal, d);
			return Add(ref a, ref inDirection);
		}

		public static Vector3 Lerp(ref Vector3 a, ref Vector3 b, float t)
		{
			t = Mathf.Clamp01(t);
			return new Vector3(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t);
		}

		public static void Lerp(ref Vector3 a, ref Vector3 b, float t, out Vector3 result)
		{
			t = Mathf.Clamp01(t);
			result.x = a.x + (b.x - a.x) * t;
			result.y = a.y + (b.y - a.y) * t;
			result.z = a.z + (b.z - a.z) * t;
		}
	}
	public class Message
	{
		public string Type;

		public Message()
		{
			Type = GetType().Name;
		}
	}
	public delegate bool MessageHandlerDelegate(Message message);
	public class MessagingSystem : SingletonMonoBehaviour<MessagingSystem>
	{
		private const int _MAX_QUEUE_PROCESSING_TIME = 16667;

		private Dictionary<string, List<MessageHandlerDelegate>> m_listenerDict = new Dictionary<string, List<MessageHandlerDelegate>>();

		private Queue<Message> m_messageQueue = new Queue<Message>();

		private Stopwatch m_timer = new Stopwatch();

		public bool AttachListener(Type type, MessageHandlerDelegate handler)
		{
			if (type == null)
			{
				UnityEngine.Debug.Log("MessagingSystem: AttachListener failed due to having no message type specified");
				return false;
			}
			string key = type.Name;
			if (!m_listenerDict.ContainsKey(key))
			{
				m_listenerDict.Add(key, new List<MessageHandlerDelegate>());
			}
			List<MessageHandlerDelegate> list = m_listenerDict[key];
			if (list.Contains(handler))
			{
				UnityEngine.Debug.Log("Listner is already in list");
				return false;
			}
			list.Add(handler);
			return true;
		}

		public bool DetachListener(Type type, MessageHandlerDelegate handler)
		{
			if (type == null)
			{
				UnityEngine.Debug.Log("MessagingSystem: DetachListener failed due to having no message type specified");
				return false;
			}
			string key = type.Name;
			if (!m_listenerDict.ContainsKey(type.Name))
			{
				return false;
			}
			List<MessageHandlerDelegate> list = m_listenerDict[key];
			if (!list.Contains(handler))
			{
				return false;
			}
			list.Remove(handler);
			return true;
		}

		public bool QueueMessage(Message msg)
		{
			if (!m_listenerDict.ContainsKey(msg.Type))
			{
				return false;
			}
			m_messageQueue.Enqueue(msg);
			return true;
		}

		public bool TriggetMessageJustNow(Message msg)
		{
			return TriggerMessage(msg);
		}

		private bool TriggerMessage(Message msg)
		{
			string type = msg.Type;
			if (!m_listenerDict.ContainsKey(type))
			{
				UnityEngine.Debug.Log("MessagingSystem: Message \"" + type + "\" has no listeners!");
				return false;
			}
			List<MessageHandlerDelegate> list = m_listenerDict[type];
			for (int i = 0; i < list.Count; i++)
			{
				if (!list[i](msg))
				{
					UnityEngine.Debug.LogWarning(":" + msg.Type);
				}
			}
			return true;
		}

		private void Update()
		{
			m_timer.Start();
			while (m_messageQueue.Count > 0)
			{
				UpdateMessage();
			}
		}

		private void UpdateMessage()
		{
			if (m_timer.Elapsed.Milliseconds > 16667)
			{
				m_timer.Stop();
				return;
			}
			Message message = m_messageQueue.Dequeue();
			if (!TriggerMessage(message))
			{
				UnityEngine.Debug.LogWarning("Error when processing message: " + message.Type);
			}
		}
	}
	public class DummyGraphic : Graphic
	{
		public override void SetMaterialDirty()
		{
		}

		public override void SetVerticesDirty()
		{
		}

		protected override void OnPopulateMesh(VertexHelper vh)
		{
			vh.Clear();
		}
	}
	public static class ColorDefine
	{
		public static Color TransparentBlack = new Color(0f, 0f, 0f, 0f);

		public static Color TransparentWhite = new Color(1f, 1f, 1f, 0f);

		public static Color White = Rgb(255, 255, 255);

		public static Color Whitesmoke = Rgb(245, 245, 245);

		public static Color Gainsboro = Rgb(220, 220, 220);

		public static Color Lightgrey = Rgb(211, 211, 211);

		public static Color Silver = Rgb(192, 192, 192);

		public static Color Darkgray = Rgb(169, 169, 169);

		public static Color Gray = Rgb(128, 128, 128);

		public static Color Dimgray = Rgb(105, 105, 105);

		public static Color Black = Rgb(0, 0, 0);

		public static Color Red = Rgb(255, 0, 0);

		public static Color Orangered = Rgb(255, 69, 0);

		public static Color Tomato = Rgb(255, 99, 71);

		public static Color Coral = Rgb(255, 127, 80);

		public static Color Salmon = Rgb(250, 128, 114);

		public static Color Lightsalmon = Rgb(255, 160, 122);

		public static Color Darksalmon = Rgb(233, 150, 122);

		public static Color Peru = Rgb(205, 133, 63);

		public static Color Saddlebrown = Rgb(139, 69, 19);

		public static Color Sienna = Rgb(160, 82, 45);

		public static Color Chocolate = Rgb(210, 105, 30);

		public static Color Sandybrown = Rgb(244, 164, 96);

		public static Color Darkred = Rgb(139, 0, 0);

		public static Color Maroon = Rgb(128, 0, 0);

		public static Color Brown = Rgb(165, 42, 42);

		public static Color Firebrick = Rgb(178, 34, 34);

		public static Color Crimson = Rgb(188, 6, 12);

		public static Color Indianred = Rgb(205, 92, 92);

		public static Color Lightcoral = Rgb(240, 128, 128);

		public static Color Rosybrown = Rgb(188, 143, 143);

		public static Color Palevioletred = Rgb(219, 112, 147);

		public static Color Deeppink = Rgb(255, 20, 147);

		public static Color Hotpink = Rgb(255, 105, 180);

		public static Color Lightpink = Rgb(255, 182, 193);

		public static Color Pink = Rgb(255, 192, 203);

		public static Color Mistyrose = Rgb(255, 228, 225);

		public static Color Linen = Rgb(250, 240, 230);

		public static Color Seashell = Rgb(255, 245, 238);

		public static Color Lavenderblush = Rgb(255, 240, 245);

		public static Color Snow = Rgb(255, 250, 250);

		public static Color Yellow = Rgb(255, 255, 0);

		public static Color Gold = Rgb(255, 215, 0);

		public static Color Orange = Rgb(255, 165, 0);

		public static Color Darkorange = Rgb(255, 140, 0);

		public static Color Goldenrod = Rgb(218, 165, 32);

		public static Color Darkgoldenrod = Rgb(184, 134, 11);

		public static Color Darkkhaki = Rgb(189, 183, 107);

		public static Color Burlywood = Rgb(222, 184, 135);

		public static Color Tan = Rgb(210, 180, 140);

		public static Color Khaki = Rgb(240, 230, 140);

		public static Color Peachpuff = Rgb(255, 218, 185);

		public static Color Navajowhite = Rgb(255, 222, 173);

		public static Color Palegoldenrod = Rgb(238, 232, 170);

		public static Color Moccasin = Rgb(255, 228, 181);

		public static Color Wheat = Rgb(245, 222, 179);

		public static Color Bisque = Rgb(255, 228, 196);

		public static Color Blanchedalmond = Rgb(255, 235, 205);

		public static Color Papayawhip = Rgb(255, 239, 213);

		public static Color Cornsilk = Rgb(255, 248, 220);

		public static Color Lightyellow = Rgb(255, 255, 224);

		public static Color Lightgoldenrodyellow = Rgb(250, 250, 210);

		public static Color Lemonchiffon = Rgb(255, 250, 205);

		public static Color Antiquewhite = Rgb(250, 235, 215);

		public static Color Beige = Rgb(245, 245, 220);

		public static Color Oldlace = Rgb(253, 245, 230);

		public static Color Ivory = Rgb(255, 255, 240);

		public static Color Floralwhite = Rgb(255, 250, 240);

		public static Color Greenyellow = Rgb(173, 255, 47);

		public static Color Yellowgreen = Rgb(154, 205, 50);

		public static Color Olive = Rgb(128, 128, 0);

		public static Color Darkolivegreen = Rgb(85, 107, 47);

		public static Color Olivedrab = Rgb(107, 142, 35);

		public static Color Chartreuse = Rgb(127, 255, 0);

		public static Color Lawngreen = Rgb(124, 252, 0);

		public static Color Lime = Rgb(0, 255, 0);

		public static Color Limegreen = Rgb(50, 205, 50);

		public static Color Forestgreen = Rgb(34, 139, 34);

		public static Color Green = Rgb(0, 128, 0);

		public static Color Darkgreen = Rgb(0, 100, 0);

		public static Color Seagreen = Rgb(46, 139, 87);

		public static Color Mediumseagreen = Rgb(60, 179, 113);

		public static Color Darkseagreen = Rgb(143, 188, 143);

		public static Color Lightgreen = Rgb(144, 238, 144);

		public static Color Palegreen = Rgb(152, 251, 152);

		public static Color Springgreen = Rgb(0, 255, 127);

		public static Color Mediumspringgreen = Rgb(0, 250, 154);

		public static Color Honeydew = Rgb(240, 255, 240);

		public static Color Mintcream = Rgb(245, 255, 250);

		public static Color Azure = Rgb(240, 255, 255);

		public static Color Lightcyan = Rgb(224, 255, 255);

		public static Color Aliceblue = Rgb(240, 248, 255);

		public static Color Darkslategray = Rgb(47, 79, 79);

		public static Color Darkslatenavy = Rgb(47, 47, 79);

		public static Color Darkslatered = Rgb(147, 47, 47);

		public static Color Steelblue = Rgb(70, 130, 180);

		public static Color Mediumaquamarine = Rgb(102, 205, 170);

		public static Color Aquamarine = Rgb(127, 255, 212);

		public static Color Mediumturquoise = Rgb(72, 209, 204);

		public static Color Turquoise = Rgb(64, 224, 208);

		public static Color Lightseagreen = Rgb(32, 178, 170);

		public static Color Darkcyan = Rgb(0, 139, 139);

		public static Color Teal = Rgb(0, 128, 128);

		public static Color Cadetblue = Rgb(95, 158, 160);

		public static Color Darkturquoise = Rgb(0, 206, 209);

		public static Color Aqua = Rgb(0, 255, 255);

		public static Color Cyan = Rgb(0, 255, 255);

		public static Color Lightblue = Rgb(173, 216, 230);

		public static Color Powderblue = Rgb(176, 224, 230);

		public static Color Paleturquoise = Rgb(175, 238, 238);

		public static Color Skyblue = Rgb(135, 206, 235);

		public static Color Lightskyblue = Rgb(135, 206, 250);

		public static Color Deepskyblue = Rgb(0, 191, 255);

		public static Color Dodgerblue = Rgb(30, 144, 255);

		public static Color Ghostwhite = Rgb(248, 248, 255);

		public static Color Lavender = Rgb(230, 230, 250);

		public static Color Lightsteelblue = Rgb(176, 196, 222);

		public static Color Slategray = Rgb(112, 128, 144);

		public static Color Lightslategray = Rgb(119, 136, 153);

		public static Color Indigo = Rgb(75, 0, 130);

		public static Color Darkslateblue = Rgb(72, 61, 139);

		public static Color Midnightblue = Rgb(25, 25, 112);

		public static Color Navy = Rgb(0, 0, 128);

		public static Color Darkblue = Rgb(0, 0, 139);

		public static Color Slateblue = Rgb(106, 90, 205);

		public static Color Mediumslateblue = Rgb(123, 104, 238);

		public static Color Cornflowerblue = Rgb(100, 149, 237);

		public static Color Royalblue = Rgb(65, 105, 225);

		public static Color Mediumblue = Rgb(0, 0, 205);

		public static Color Blue = Rgb(0, 0, 255);

		public static Color Thistle = Rgb(216, 191, 216);

		public static Color Plum = Rgb(221, 160, 221);

		public static Color Orchid = Rgb(218, 112, 214);

		public static Color Violet = Rgb(238, 130, 238);

		public static Color Fuchsia = Rgb(255, 0, 255);

		public static Color Magenta = Rgb(255, 0, 255);

		public static Color Mediumpurple = Rgb(147, 112, 219);

		public static Color Mediumorchid = Rgb(186, 85, 211);

		public static Color Darkorchid = Rgb(153, 50, 204);

		public static Color Blueviolet = Rgb(138, 43, 226);

		public static Color Darkviolet = Rgb(148, 0, 211);

		public static Color Purple = Rgb(128, 0, 128);

		public static Color Darkmagenta = Rgb(139, 0, 139);

		public static Color Mediumvioletred = Rgb(199, 21, 133);

		public static Color Midnightblack = Rgb(50, 50, 50);

		public static Color Midnightgray = Rgb(75, 75, 75);

		public static Color OutlineDay = Rgb(51, 51, 51);

		public static Color OutlineNight = Rgb(10, 10, 10);

		public static Color Rgb(int red, int green, int blue)
		{
			return new Color((float)red / 255f, (float)green / 255f, (float)blue / 255f);
		}
	}
	public class DontDestroyOnLoad : MonoBehaviour
	{
		private void Awake()
		{
		}
	}
	public static class Easing
	{
		public static float Linear(float start, float end, float value)
		{
			return Mathf.Lerp(start, end, value);
		}

		public static Vector2 Linear(Vector2 start, Vector2 end, float value)
		{
			return Vector2.Lerp(start, end, value);
		}

		public static Vector3 Linear(Vector3 start, Vector3 end, float value)
		{
			return Vector3.Lerp(start, end, value);
		}

		public static Vector4 Linear(Vector4 start, Vector4 end, float value)
		{
			return Vector4.Lerp(start, end, value);
		}

		public static Quaternion Linear(Quaternion start, Quaternion end, float value)
		{
			return Quaternion.Lerp(start, end, value);
		}

		public static float Clerp(float start, float end, float value)
		{
			float num = 0f;
			float num2 = 360f;
			float num3 = Mathf.Abs((num2 - num) * 0.5f);
			float num4 = 0f;
			float num5 = 0f;
			if (end - start < 0f - num3)
			{
				num5 = (num2 - start + end) * value;
				return start + num5;
			}
			if (end - start > num3)
			{
				num5 = (0f - (num2 - end + start)) * value;
				return start + num5;
			}
			return start + (end - start) * value;
		}

		public static float Spring(float start, float end, float value)
		{
			value = GetSpringValue(value);
			return start + (end - start) * value;
		}

		public static Vector2 Spring(Vector2 start, Vector2 end, float value)
		{
			value = GetSpringValue(value);
			return start + (end - start) * value;
		}

		public static Vector3 Spring(Vector3 start, Vector3 end, float value)
		{
			value = GetSpringValue(value);
			return start + (end - start) * value;
		}

		public static Vector4 Spring(Vector4 start, Vector4 end, float value)
		{
			value = GetSpringValue(value);
			return start + (end - start) * value;
		}

		public static Color Spring(Color start, Color end, float value)
		{
			value = GetSpringValue(value);
			return start + (end - start) * value;
		}

		private static float GetSpringValue(float value)
		{
			value = Mathf.Clamp01(value);
			return (Mathf.Sin(value * (float)Math.PI * (0.2f + 2.5f * value * value * value)) * Mathf.Pow(1f - value, 2.2f) + value) * (1f + 1.2f * (1f - value));
		}

		public static float EaseInQuad(float start, float end, float value)
		{
			end -= start;
			return end * value * value + start;
		}

		public static Vector2 EaseInQuad(Vector2 start, Vector2 end, float value)
		{
			end -= start;
			return end * value * value + start;
		}

		public static Vector3 EaseInQuad(Vector3 start, Vector3 end, float value)
		{
			end -= start;
			return end * value * value + start;
		}

		public static Vector4 EaseInQuad(Vector4 start, Vector4 end, float value)
		{
			end -= start;
			return end * value * value + start;
		}

		public static Color EaseInQuad(Color start, Color end, float value)
		{
			end -= start;
			return end * value * value + start;
		}

		public static float EaseOutQuad(float start, float end, float value)
		{
			end -= start;
			return (0f - end) * value * (value - 2f) + start;
		}

		public static Vector2 EaseOutQuad(Vector2 start, Vector2 end, float value)
		{
			end -= start;
			return -end * value * (value - 2f) + start;
		}

		public static Vector3 EaseOutQuad(Vector3 start, Vector3 end, float value)
		{
			end -= start;
			return -end * value * (value - 2f) + start;
		}

		public static Vector4 EaseOutQuad(Vector4 start, Vector4 end, float value)
		{
			end -= start;
			return -end * value * (value - 2f) + start;
		}

		public static Color EaseOutQuad(Color start, Color end, float value)
		{
			end -= start;
			return end * -1f * value * (value - 2f) + start;
		}

		public static float EaseInOutQuad(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end * 0.5f * value * value + start;
			}
			value -= 1f;
			return (0f - end) * 0.5f * (value * (value - 2f) - 1f) + start;
		}

		public static float EaseInCubic(float start, float end, float value)
		{
			end -= start;
			return end * value * value * value + start;
		}

		public static float EaseOutCubic(float start, float end, float value)
		{
			value -= 1f;
			end -= start;
			return end * (value * value * value + 1f) + start;
		}

		public static float EaseInOutCubic(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end * 0.5f * value * value * value + start;
			}
			value -= 2f;
			return end * 0.5f * (value * value * value + 2f) + start;
		}

		public static float EaseInQuart(float start, float end, float value)
		{
			end -= start;
			return end * value * value * value * value + start;
		}

		public static float EaseOutQuart(float start, float end, float value)
		{
			value -= 1f;
			end -= start;
			return (0f - end) * (value * value * value * value - 1f) + start;
		}

		public static float EaseInOutQuart(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end * 0.5f * value * value * value * value + start;
			}
			value -= 2f;
			return (0f - end) * 0.5f * (value * value * value * value - 2f) + start;
		}

		public static float EaseInQuint(float start, float end, float value)
		{
			end -= start;
			return end * value * value * value * value * value + start;
		}

		public static float EaseOutQuint(float start, float end, float value)
		{
			value -= 1f;
			end -= start;
			return end * (value * value * value * value * value + 1f) + start;
		}

		public static float EaseInOutQuint(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end * 0.5f * value * value * value * value * value + start;
			}
			value -= 2f;
			return end * 0.5f * (value * value * value * value * value + 2f) + start;
		}

		public static float EaseInSine(float start, float end, float value)
		{
			end -= start;
			return (0f - end) * Mathf.Cos(value * ((float)Math.PI / 2f)) + end + start;
		}

		public static Vector2 EaseInSine(Vector2 start, Vector2 end, float value)
		{
			end -= start;
			return -end * Mathf.Cos(value * ((float)Math.PI / 2f)) + end + start;
		}

		public static Vector3 EaseInSine(Vector3 start, Vector3 end, float value)
		{
			end -= start;
			return -end * Mathf.Cos(value * ((float)Math.PI / 2f)) + end + start;
		}

		public static Vector4 EaseInSine(Vector4 start, Vector4 end, float value)
		{
			end -= start;
			return -end * Mathf.Cos(value * ((float)Math.PI / 2f)) + end + start;
		}

		public static Color EaseInSine(Color start, Color end, float value)
		{
			end -= start;
			return end * -1f * Mathf.Cos(value * ((float)Math.PI / 2f)) + end + start;
		}

		public static float EaseOutSine(float start, float end, float value)
		{
			end -= start;
			return end * Mathf.Sin(value * ((float)Math.PI / 2f)) + start;
		}

		public static Vector2 EaseOutSine(Vector2 start, Vector2 end, float value)
		{
			end -= start;
			return end * Mathf.Sin(value * ((float)Math.PI / 2f)) + start;
		}

		public static Vector3 EaseOutSine(Vector3 start, Vector3 end, float value)
		{
			end -= start;
			return end * Mathf.Sin(value * ((float)Math.PI / 2f)) + start;
		}

		public static Vector4 EaseOutSine(Vector4 start, Vector4 end, float value)
		{
			end -= start;
			return end * Mathf.Sin(value * ((float)Math.PI / 2f)) + start;
		}

		public static Color EaseOutSine(Color start, Color end, float value)
		{
			end -= start;
			return end * Mathf.Sin(value * ((float)Math.PI / 2f)) + start;
		}

		public static float EaseInOutSine(float start, float end, float value)
		{
			end -= start;
			return (0f - end) * 0.5f * (Mathf.Cos((float)Math.PI * value) - 1f) + start;
		}

		public static Vector2 EaseInOutSine(Vector2 start, Vector2 end, float value)
		{
			end -= start;
			return -end * 0.5f * (Mathf.Cos((float)Math.PI * value) - 1f) + start;
		}

		public static Vector3 EaseInOutSine(Vector3 start, Vector3 end, float value)
		{
			end -= start;
			return -end * 0.5f * (Mathf.Cos((float)Math.PI * value) - 1f) + start;
		}

		public static Vector4 EaseInOutSine(Vector4 start, Vector4 end, float value)
		{
			end -= start;
			return -end * 0.5f * (Mathf.Cos((float)Math.PI * value) - 1f) + start;
		}

		public static Color EaseInOutSine(Color start, Color end, float value)
		{
			end -= start;
			return end * -1f * 0.5f * (Mathf.Cos((float)Math.PI * value) - 1f) + start;
		}

		public static float EaseInExpo(float start, float end, float value)
		{
			end -= start;
			return end * Mathf.Pow(2f, 10f * (value - 1f)) + start;
		}

		public static float EaseOutExpo(float start, float end, float value)
		{
			end -= start;
			return end * (0f - Mathf.Pow(2f, -10f * value) + 1f) + start;
		}

		public static float EaseInOutExpo(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end * 0.5f * Mathf.Pow(2f, 10f * (value - 1f)) + start;
			}
			value -= 1f;
			return end * 0.5f * (0f - Mathf.Pow(2f, -10f * value) + 2f) + start;
		}

		public static float EaseInCirc(float start, float end, float value)
		{
			end -= start;
			return (0f - end) * (Mathf.Sqrt(1f - value * value) - 1f) + start;
		}

		public static float EaseOutCirc(float start, float end, float value)
		{
			value -= 1f;
			end -= start;
			return end * Mathf.Sqrt(1f - value * value) + start;
		}

		public static float EaseInOutCirc(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return (0f - end) * 0.5f * (Mathf.Sqrt(1f - value * value) - 1f) + start;
			}
			value -= 2f;
			return end * 0.5f * (Mathf.Sqrt(1f - value * value) + 1f) + start;
		}

		public static float EaseInBounce(float start, float end, float value)
		{
			end -= start;
			float num = 1f;
			return end - EaseOutBounce(0f, end, num - value) + start;
		}

		public static float EaseOutBounce(float start, float end, float value)
		{
			value /= 1f;
			end -= start;
			if (value < 0.36363637f)
			{
				return end * (7.5625f * value * value) + start;
			}
			if (value < 0.72727275f)
			{
				value -= 0.54545456f;
				return end * (7.5625f * value * value + 0.75f) + start;
			}
			if ((double)value < 0.9090909090909091)
			{
				value -= 0.8181818f;
				return end * (7.5625f * value * value + 0.9375f) + start;
			}
			value -= 21f / 22f;
			return end * (7.5625f * value * value + 63f / 64f) + start;
		}

		public static float EaseInOutBounce(float start, float end, float value)
		{
			end -= start;
			float num = 1f;
			if (value < num * 0.5f)
			{
				return EaseInBounce(0f, end, value * 2f) * 0.5f + start;
			}
			return EaseOutBounce(0f, end, value * 2f - num) * 0.5f + end * 0.5f + start;
		}

		public static float EaseInBack(float start, float end, float value)
		{
			end -= start;
			value /= 1f;
			float num = 1.70158f;
			return end * value * value * ((num + 1f) * value - num) + start;
		}

		public static float EaseOutBack(float start, float end, float value)
		{
			float num = 1.70158f;
			end -= start;
			value -= 1f;
			return end * (value * value * ((num + 1f) * value + num) + 1f) + start;
		}

		public static float EaseInOutBack(float start, float end, float value)
		{
			float num = 1.70158f;
			end -= start;
			value /= 0.5f;
			if (value < 1f)
			{
				num *= 1.525f;
				return end * 0.5f * (value * value * ((num + 1f) * value - num)) + start;
			}
			value -= 2f;
			num *= 1.525f;
			return end * 0.5f * (value * value * ((num + 1f) * value + num) + 2f) + start;
		}

		public static float Punch(float amplitude, float value)
		{
			float num = 9f;
			if (value == 0f)
			{
				return 0f;
			}
			if (value == 1f)
			{
				return 0f;
			}
			float num2 = 0.3f;
			num = num2 / ((float)Math.PI * 2f) * Mathf.Asin(0f);
			return amplitude * Mathf.Pow(2f, -10f * value) * Mathf.Sin((value * 1f - num) * ((float)Math.PI * 2f) / num2);
		}

		public static float EaseInElastic(float start, float end, float value)
		{
			end -= start;
			float num = 1f;
			float num2 = num * 0.3f;
			float num3 = 0f;
			float num4 = 0f;
			if (value == 0f)
			{
				return start;
			}
			if ((value /= num) == 1f)
			{
				return start + end;
			}
			if (num4 == 0f || num4 < Mathf.Abs(end))
			{
				num4 = end;
				num3 = num2 / 4f;
			}
			else
			{
				num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
			}
			return 0f - num4 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) + start;
		}

		public static float EaseOutElastic(float start, float end, float value)
		{
			end -= start;
			float num = 1f;
			float num2 = num * 0.3f;
			float num3 = 0f;
			float num4 = 0f;
			if (value == 0f)
			{
				return start;
			}
			if ((value /= num) == 1f)
			{
				return start + end;
			}
			if (num4 == 0f || num4 < Mathf.Abs(end))
			{
				num4 = end;
				num3 = num2 * 0.25f;
			}
			else
			{
				num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
			}
			return num4 * Mathf.Pow(2f, -10f * value) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) + end + start;
		}

		public static float EaseInOutElastic(float start, float end, float value)
		{
			end -= start;
			float num = 1f;
			float num2 = num * 0.3f;
			float num3 = 0f;
			float num4 = 0f;
			if (value == 0f)
			{
				return start;
			}
			if ((value /= num * 0.5f) == 2f)
			{
				return start + end;
			}
			if (num4 == 0f || num4 < Mathf.Abs(end))
			{
				num4 = end;
				num3 = num2 / 4f;
			}
			else
			{
				num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
			}
			if (value < 1f)
			{
				return -0.5f * (num4 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2)) + start;
			}
			return num4 * Mathf.Pow(2f, -10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) * 0.5f + end + start;
		}
	}
	public class FPSCounter3DText : MonoBehaviour
	{
		protected const float m_fpsMeasurePeriod = 0.5f;

		[SerializeField]
		private TextMesh m_text;

		[SerializeField]
		private int m_errorFps = 55;

		[SerializeField]
		protected Color m_errorColour = Color.red;

		[SerializeField]
		protected int m_errorFontSize = 50;

		[SerializeField]
		private Vector3 m_errorPosition = Vector3.zero;

		[SerializeField]
		protected string m_displayText = "{0}";

		[SerializeField]
		protected bool m_isShowErrorText;

		private int m_fpsAccumulator;

		private float m_fpsNextPeriod;

		private int m_currentFps;

		private Transform m_transform;

		private Vector3 m_startPos;

		protected int m_startFontSize;

		protected Color m_startColour;

		private bool m_isError;

		private bool IsUpdateFps => Time.realtimeSinceStartup > m_fpsNextPeriod;

		private bool IsErrorFps => m_currentFps <= m_errorFps;

		private bool IsSlowFps => UnityEngine.Application.targetFrameRate < 60;

		private void Start()
		{
			m_isError = false;
			m_transform = base.transform;
			m_startPos = m_transform.localPosition;
			m_fpsNextPeriod = Time.realtimeSinceStartup + 0.5f;
			if (m_text == null)
			{
				m_text = GetComponent<TextMesh>();
			}
			Setup();
		}

		protected virtual void Setup()
		{
		}

		private void Update()
		{
			m_fpsAccumulator++;
			if (IsUpdateFps)
			{
				UpdateFps();
				UpdateFpsChange();
			}
		}

		private void UpdateFps()
		{
			m_currentFps = (int)((float)m_fpsAccumulator / 0.5f);
			m_fpsAccumulator = 0;
			m_fpsNextPeriod += 0.5f;
			SetFPSText(string.Format(m_displayText, m_currentFps));
			m_text.text = string.Format(m_displayText, m_currentFps);
		}

		protected virtual void SetFPSText(string text)
		{
		}

		private void UpdateFpsChange()
		{
			if (m_isShowErrorText && m_isError)
			{
				UpdateError();
			}
			else
			{
				UpdateNormal();
			}
		}

		private void UpdateError()
		{
			if (IsSlowFps)
			{
				ResetNormal();
			}
			else if (m_currentFps >= m_errorFps)
			{
				ResetNormal();
			}
		}

		protected virtual void ResetNormal()
		{
			m_transform.localPosition = m_startPos;
			m_text.color = Color.white;
			m_text.fontSize = m_startFontSize;
			m_isError = false;
		}

		private void UpdateNormal()
		{
			if (!IsSlowFps && IsErrorFps)
			{
				ChangeToError();
			}
		}

		protected virtual void ChangeToError()
		{
			m_transform.localPosition = m_errorPosition;
			m_isError = true;
			m_text.color = m_errorColour;
			m_text.fontSize = m_errorFontSize;
		}
	}
	[RequireComponent(typeof(TextMeshProUGUI))]
	public class FPSCounterTMPro : MonoBehaviour
	{
		protected const float m_fpsMeasurePeriod = 0.5f;

		[SerializeField]
		[NotEditable]
		private TextMeshProUGUI m_text;

		[SerializeField]
		protected Color m_normalColour = Color.white;

		[SerializeField]
		private int m_warnFps = 59;

		[SerializeField]
		protected Color m_warnColour = Color.yellow;

		[SerializeField]
		private int m_errorFps = 50;

		[SerializeField]
		protected Color m_errorColour = Color.red;

		[SerializeField]
		protected string m_displayText = "{0}";

		private int m_fpsAccumulator;

		private float m_fpsNextPeriod;

		private int m_currentFps;

		protected int m_startFontSize;

		protected Color m_startColour;

		public bool IsVisible { get; set; }

		private bool IsUpdateFps => Time.realtimeSinceStartup > m_fpsNextPeriod;

		private bool IsErrorFps => m_currentFps <= m_errorFps;

		private bool IsSlowFps => UnityEngine.Application.targetFrameRate < 60;

		private void OnValidate()
		{
			if (m_text == null)
			{
				m_text = GetComponent<TextMeshProUGUI>();
			}
		}

		private void Start()
		{
			m_fpsNextPeriod = Time.realtimeSinceStartup + 0.5f;
		}

		private void Update()
		{
			m_fpsAccumulator++;
			if (IsUpdateFps)
			{
				UpdateFps();
				UpdateFpsChange();
			}
		}

		private void UpdateFps()
		{
			m_currentFps = (int)((float)m_fpsAccumulator / 0.5f);
			m_fpsAccumulator = 0;
			m_fpsNextPeriod += 0.5f;
			m_text.text = StringUtility.Format(m_displayText, m_currentFps);
		}

		private void UpdateFpsChange()
		{
			if (m_currentFps <= m_errorFps)
			{
				m_text.color = m_errorColour;
			}
			else if (m_currentFps <= m_warnFps)
			{
				m_text.color = m_warnColour;
			}
			else
			{
				m_text.color = m_normalColour;
			}
		}

		public void ToggleVisible(bool flag)
		{
			IsVisible = flag;
			m_text.enabled = flag;
		}
	}
	[RequireComponent(typeof(Text))]
	public class FPSCounterUgui : MonoBehaviour
	{
		protected const float m_fpsMeasurePeriod = 0.5f;

		[SerializeField]
		private Text m_text;

		[SerializeField]
		private int m_errorFps = 55;

		[SerializeField]
		protected Color m_errorColour = Color.red;

		[SerializeField]
		protected int m_errorFontSize = 50;

		[SerializeField]
		protected string m_displayText = "{0}";

		[SerializeField]
		protected bool m_isShowErrorText;

		private int m_fpsAccumulator;

		private float m_fpsNextPeriod;

		private int m_currentFps;

		protected int m_startFontSize;

		protected Color m_startColour;

		private bool m_isError;

		public bool IsVisible { get; set; }

		private bool IsUpdateFps => Time.realtimeSinceStartup > m_fpsNextPeriod;

		private bool IsErrorFps => m_currentFps <= m_errorFps;

		private bool IsSlowFps => UnityEngine.Application.targetFrameRate < 60;

		private void Start()
		{
			m_isError = false;
			m_fpsNextPeriod = Time.realtimeSinceStartup + 0.5f;
			if (m_text == null)
			{
				m_text = GetComponent<Text>();
			}
			Setup();
		}

		protected virtual void Setup()
		{
		}

		private void Update()
		{
			m_fpsAccumulator++;
			if (IsUpdateFps)
			{
				UpdateFps();
				UpdateFpsChange();
			}
		}

		private void UpdateFps()
		{
			m_currentFps = (int)((float)m_fpsAccumulator / 0.5f);
			m_fpsAccumulator = 0;
			m_fpsNextPeriod += 0.5f;
			m_text.text = StringUtility.Format(m_displayText, m_currentFps);
		}

		protected virtual void SetFPSText(string text)
		{
		}

		private void UpdateFpsChange()
		{
			if (m_isShowErrorText && m_isError)
			{
				UpdateError();
			}
			else
			{
				UpdateNormal();
			}
		}

		private void UpdateError()
		{
			if (IsSlowFps)
			{
				ResetNormal();
			}
			else if (m_currentFps >= m_errorFps)
			{
				ResetNormal();
			}
		}

		protected virtual void ResetNormal()
		{
			m_text.color = Color.white;
			m_text.fontSize = m_startFontSize;
			m_isError = false;
		}

		private void UpdateNormal()
		{
			if (!IsSlowFps && IsErrorFps)
			{
				ChangeToError();
			}
		}

		protected virtual void ChangeToError()
		{
			m_isError = true;
			m_text.color = m_errorColour;
			m_text.fontSize = m_errorFontSize;
		}

		public void ToggleVisible(bool flag)
		{
			IsVisible = flag;
			m_text.enabled = flag;
		}
	}
	public class GameLogic : SingletonMonoBehaviour<GameLogic>
	{
		private IObservable<Unit> _obUpdate;

		public IObservable<Unit> UpdateObservable => _obUpdate;

		protected override void InitializeOnAwake()
		{
			_obUpdate = this.UpdateAsObservable();
		}

		public void RegisterUpdateableObject(IUpdateable obj)
		{
			_obUpdate.Where((Unit _) => obj.IsActive).Subscribe(delegate
			{
				obj.OnUpdate(Time.deltaTime);
			}).AddTo(obj.MyComponent);
		}

		public void DeregisterUpdateableObject(IUpdateable obj)
		{
		}
	}
	public abstract class IFader : MonoBehaviour
	{
		public const float DEFAULT_FADE_DURATION = 0.65f;

		[SerializeField]
		protected float m_fadeDuration = 0.65f;

		[SerializeField]
		protected bool m_isFadeOnStart = true;

		[SerializeField]
		protected Color m_startColour = Color.black;

		[SerializeField]
		protected Color m_targetColour = ColorDefine.TransparentBlack;

		[SerializeField]
		protected UnityEvent m_onStartFadeEnd;

		[SerializeField]
		protected UnityEvent m_onStartFadeEvents;

		[SerializeField]
		protected int m_waitFrameOnStart;

		[SerializeField]
		protected bool m_isDeactivateOnEnd;

		protected Tweener<Color> m_colourTweener = new Tweener<Color>(Color.Lerp);

		protected int m_frameCount;

		protected GameObject m_gameObject;

		protected Transform m_transform;

		public bool IsFading => m_colourTweener.IsActive;

		public float RemainingTime => m_colourTweener.RemainingTime;

		public virtual bool IsFadeVisible => false;

		public virtual Color CurrentColour => m_colourTweener.CurrentValue;

		private void Awake()
		{
			m_gameObject = base.gameObject;
			m_transform = base.transform;
			Initialize();
		}

		protected void Initialize()
		{
			OnInitialize();
		}

		private void OnDisable()
		{
			m_isFadeOnStart = false;
		}

		protected abstract void OnInitialize();

		public void StartFade(Color end)
		{
			StartFade(CurrentColour, end, m_fadeDuration, isDeactivateOnEnd: false);
		}

		public void StartFade(Color start, Color end)
		{
			StartFade(start, end, m_fadeDuration, isDeactivateOnEnd: false);
		}

		public void StartFade(Color end, Action onTweenEndMethod)
		{
			StartFade(CurrentColour, end, m_fadeDuration, isDeactivateOnEnd: false, onTweenEndMethod);
		}

		public void StartFade(Color start, Color end, Action onTweenEndMethod)
		{
			StartFade(start, end, m_fadeDuration, isDeactivateOnEnd: false, onTweenEndMethod);
		}

		public void StartFade(Color end, float duration, bool isDeactivateOnEnd, Action onTweenEndMethod = null)
		{
			StartFade(CurrentColour, end, duration, isDeactivateOnEnd, onTweenEndMethod);
		}

		public void StartFade(Color start, Color end, float duration, bool isDeactivateOnEnd, Action onTweenEndMethod = null)
		{
			if (start.a <= 0f)
			{
				start = end.WithAlpha(0f);
			}
			else if (end.a <= 0f)
			{
				end = start.WithAlpha(0f);
			}
			m_startColour = start;
			m_targetColour = end;
			m_isFadeOnStart = false;
			m_isDeactivateOnEnd = isDeactivateOnEnd;
			m_colourTweener.Start(start, end, duration, onTweenEndMethod);
			UpdateColour();
			OnFade();
			if (duration <= 0f)
			{
				OnFadeEnd();
			}
		}

		public void StartReverseFade(Action onTweenEndMethod = null, bool isActivateGameObject = true, bool isDeactivateOnEnd = false)
		{
			m_isDeactivateOnEnd = isDeactivateOnEnd;
			m_gameObject.SetActive(isActivateGameObject);
			m_colourTweener.StartReverse(onTweenEndMethod);
			UpdateColour();
			OnFade();
			if (!m_colourTweener.IsActive)
			{
				OnFadeEnd();
			}
		}

		public void StartReverseFade(float duration, bool isDeactivateOnEnd, Action onTweenEndMethod = null)
		{
			m_isDeactivateOnEnd = isDeactivateOnEnd;
			m_colourTweener.Duration = duration;
			m_colourTweener.StartReverse(onTweenEndMethod);
			UpdateColour();
			OnFade();
			if (!m_colourTweener.IsActive)
			{
				OnFadeEnd();
			}
		}

		protected virtual void OnFade()
		{
		}

		private void Update()
		{
			if (m_isFadeOnStart)
			{
				if (m_waitFrameOnStart > m_frameCount)
				{
					m_frameCount++;
					return;
				}
				m_isFadeOnStart = false;
				StartFade(m_startColour, m_targetColour, m_fadeDuration, isDeactivateOnEnd: true, OnStartFadeEnd);
				if (m_onStartFadeEvents != null)
				{
					m_onStartFadeEvents.Invoke();
				}
			}
			else if (m_colourTweener.IsActive)
			{
				m_colourTweener.Update(Time.deltaTime);
				UpdateColour();
				if (!m_colourTweener.IsActive)
				{
					OnFadeEnd();
				}
			}
		}

		protected virtual void OnFadeEnd()
		{
			if (m_isDeactivateOnEnd)
			{
				m_gameObject.SetActive(value: false);
			}
		}

		protected virtual void UpdateColour()
		{
		}

		protected virtual void OnStartFadeEnd()
		{
			if (m_onStartFadeEnd != null)
			{
				m_onStartFadeEnd.Invoke();
			}
			m_isFadeOnStart = false;
		}

		public virtual void SetColour(Color colour)
		{
		}

		public void SkipToEnd()
		{
			Initialize();
			m_colourTweener.Start(m_startColour, m_targetColour, 0.65f);
			m_colourTweener.Update(m_colourTweener.Duration);
			UpdateColour();
			if (m_isFadeOnStart)
			{
				OnStartFadeEnd();
			}
		}

		public void Dispose()
		{
			m_colourTweener.Dispose();
			m_isFadeOnStart = false;
		}

		public virtual void SetActive(bool isActive)
		{
			m_gameObject.SetActive(isActive);
		}
	}
	public interface IUpdateable
	{
		int Priority { get; set; }

		bool IsActive { get; set; }

		Component MyComponent { get; }

		void OnUpdate(float delta);
	}
	internal class ListPosition
	{
		protected int m_count;

		protected int m_height;

		protected int m_top;

		protected int m_end;

		public int Index { get; protected set; }

		public int Count
		{
			get
			{
				return m_count;
			}
			set
			{
				m_count = Math.Max(0, value);
				Select(Index, isLoop: false);
			}
		}

		public int Height
		{
			get
			{
				if (m_height <= 0)
				{
					return m_count;
				}
				return m_height;
			}
			set
			{
				m_height = Math.Max(0, value);
				Reform();
			}
		}

		public int Offset => Math.Max(0, Index - m_top);

		public int Top => m_top;

		public ListPosition()
		{
			m_count = 0;
			m_height = 0;
			Index = 0;
			m_top = 0;
			m_end = 0;
		}

		private void Reform()
		{
			int height = Height;
			if (Index < m_top)
			{
				m_top = Math.Max(0, Index);
			}
			m_end = Math.Min(m_top + height, m_count);
			if (Index + 1 >= m_end)
			{
				m_end = Index + 1;
				if (m_end > m_count)
				{
					m_end = m_count;
				}
			}
			m_top = Math.Max(0, m_end - height);
		}

		public void Select(int index, bool isLoop = true)
		{
			if (m_count > 0)
			{
				if (isLoop)
				{
					Index = (Clamp(index, -1, m_count) + m_count) % m_count;
				}
				else
				{
					Index = Clamp(index, 0, m_count - 1);
				}
				Reform();
			}
			else
			{
				Index = 0;
				m_top = 0;
				m_end = 0;
			}
		}

		private int Clamp(int value, int min, int max)
		{
			value = ((value > max) ? max : value);
			value = ((value < min) ? min : value);
			return value;
		}

		public void Next(int steps = 1, bool isLoop = true)
		{
			Select(Index + steps, isLoop && Index >= m_count - 1);
		}

		public void Back(int steps = 1, bool isLoop = true)
		{
			Select(Index - steps, isLoop && Index == 0);
		}

		public void Scroll(int step)
		{
			if (m_count > 0)
			{
				Index = Clamp(Index + step, 0, m_count - 1);
				if (step < 0)
				{
					step = Math.Max(m_top + step, 0) - m_top;
				}
				else if (step > 0)
				{
					step = Math.Min(m_end + step, m_count) - m_end;
				}
				m_top = Clamp(m_top + step, Index, m_count);
				m_end = Clamp(m_end + step, m_top, m_count);
			}
		}

		public void GetRange(ref int start, ref int end)
		{
			start = m_top;
			end = m_end;
		}
	}
	public static class MathHelper
	{
		public const float PI = (float)Math.PI;

		public const float PI_OVER_2 = (float)Math.PI / 2f;

		public const float PI_OVER_4 = (float)Math.PI / 4f;

		public const float TWO_PI = (float)Math.PI * 2f;

		public const float RADIAN_TO_DEGREE = 57.29578f;

		public const float DEGREE_TO_RADIAN = (float)Math.PI / 180f;

		public static readonly Vector3 RIGHT = new Vector3(1f, 0f, 0f);

		public static float Abs(ref float a)
		{
			if (!(a < 0f))
			{
				return a;
			}
			return 0f - a;
		}

		public static float Clamp01(float a)
		{
			a = ((a > 1f) ? 1f : a);
			if (!(a < 0f))
			{
				return a;
			}
			return 0f;
		}

		public static void Clamp01(ref float a)
		{
			a = ((a > 1f) ? 1f : a);
			a = ((a < 0f) ? 0f : a);
		}

		public static bool GetRandomBool()
		{
			return UnityEngine.Random.Range(0, 2) > 0;
		}

		public static float GetRate(float current, float target)
		{
			return Mathf.Clamp(current / target, 0f, 1f);
		}

		public static float GetPercentage(float start, float target, float current)
		{
			return (current - start) / (target - start);
		}

		public static float Pow2(float x)
		{
			return Mathf.Pow(x, 2f);
		}

		public static int CountDigit(int num)
		{
			if (num != 0)
			{
				return (int)Mathf.Log10(num) + 1;
			}
			return 1;
		}

		public static float GetAngle(Vector3 from, Vector3 to)
		{
			float x = to.x - from.x;
			return Mathf.Atan2(to.z - from.z, x);
		}

		public static Vector2 ContactPoint(Vector2 from, float radius)
		{
			float x = radius * ((from.x * radius + from.y * Mathf.Sqrt(Pow2(from.x) + Pow2(from.y) - Pow2(radius))) / (Pow2(from.x) + Pow2(from.y)));
			float y = radius * ((from.y * radius - from.x * Mathf.Sqrt(Pow2(from.x) + Pow2(from.y) - Pow2(radius))) / (Pow2(from.x) + Pow2(from.y)));
			return new Vector2(x, y);
		}

		public static Vector2 ContactPointLeft(Vector2 from, float radius, Vector2 circleP)
		{
			Vector2 vector = from - circleP;
			float x = radius * ((vector.x * radius + vector.y * Mathf.Sqrt(Pow2(vector.x) + Pow2(vector.y) - Pow2(radius))) / (Pow2(vector.x) + Pow2(vector.y))) + circleP.x;
			float y = radius * ((vector.y * radius - vector.x * Mathf.Sqrt(Pow2(vector.x) + Pow2(vector.y) - Pow2(radius))) / (Pow2(vector.x) + Pow2(vector.y))) + circleP.y;
			return new Vector2(x, y);
		}

		public static Vector2 ContactPointRight(Vector2 from, float radius, Vector2 circleP)
		{
			Vector2 vector = from - circleP;
			float x = radius * ((vector.x * radius - vector.y * Mathf.Sqrt(Pow2(vector.x) + Pow2(vector.y) - Pow2(radius))) / (Pow2(vector.x) + Pow2(vector.y))) + circleP.x;
			float y = radius * ((vector.y * radius + vector.x * Mathf.Sqrt(Pow2(vector.x) + Pow2(vector.y) - Pow2(radius))) / (Pow2(vector.x) + Pow2(vector.y))) + circleP.y;
			return new Vector2(x, y);
		}

		public static Vector3 ContactPointLeftXY(Vector3 from, float radius, Vector3 circleP, Transform local)
		{
			Vector3 vector = local.InverseTransformPoint(from);
			Vector3 vector2 = local.InverseTransformPoint(circleP);
			Vector2 vector3 = ContactPointLeft(vector, radius, vector2);
			Vector3 position = new Vector3(vector3.x, vector3.y, vector.z);
			return local.TransformPoint(position);
		}

		public static Vector3 ContactPointRightXY(Vector3 from, float radius, Vector3 circleP, Transform local)
		{
			Vector3 vector = local.InverseTransformPoint(from);
			Vector3 vector2 = local.InverseTransformPoint(circleP);
			Vector2 vector3 = ContactPointRight(vector, radius, vector2);
			Vector3 position = new Vector3(vector3.x, vector3.y, vector.z);
			return local.TransformPoint(position);
		}

		public static Vector3 ContactPointLeftYZ(Vector3 from, float radius, Vector3 circleP, Transform local)
		{
			Vector3 vector = local.InverseTransformPoint(from);
			Vector3 vector2 = local.InverseTransformPoint(circleP);
			Vector2 from2 = new Vector2(vector.z, vector.y);
			Vector2 circleP2 = new Vector2(vector2.z, vector2.y);
			Vector2 vector3 = ContactPointLeft(from2, radius, circleP2);
			Vector3 position = new Vector3(vector.x, vector3.y, vector3.x);
			return local.TransformPoint(position);
		}

		public static Vector3 ContactPointRightYZ(Vector3 from, float radius, Vector3 circleP, Transform local)
		{
			Vector3 vector = local.InverseTransformPoint(from);
			Vector3 vector2 = local.InverseTransformPoint(circleP);
			Vector2 from2 = new Vector2(vector.z, vector.y);
			Vector2 circleP2 = new Vector2(vector2.z, vector2.y);
			Vector2 vector3 = ContactPointRight(from2, radius, circleP2);
			Vector3 position = new Vector3(vector.x, vector3.y, vector3.x);
			return local.TransformPoint(position);
		}
	}
	[Serializable]
	public struct Point : IEquatable<Point>
	{
		private static readonly Point zeroPoint;

		public int X;

		public int Y;

		public static Point Zero => zeroPoint;

		internal string DebugDisplayString => X + "  " + Y;

		public Point(int x, int y)
		{
			X = x;
			Y = y;
		}

		public Point(int value)
		{
			X = value;
			Y = value;
		}

		public static Point operator +(Point value1, Point value2)
		{
			return new Point(value1.X + value2.X, value1.Y + value2.Y);
		}

		public static Point operator -(Point value1, Point value2)
		{
			return new Point(value1.X - value2.X, value1.Y - value2.Y);
		}

		public static Point operator *(Point value1, Point value2)
		{
			return new Point(value1.X * value2.X, value1.Y * value2.Y);
		}

		public static Point operator /(Point source, Point divisor)
		{
			return new Point(source.X / divisor.X, source.Y / divisor.Y);
		}

		public static bool operator ==(Point a, Point b)
		{
			return a.Equals(b);
		}

		public static bool operator !=(Point a, Point b)
		{
			return !a.Equals(b);
		}

		public override bool Equals(object obj)
		{
			if (obj is Point)
			{
				return Equals((Point)obj);
			}
			return false;
		}

		public bool Equals(Point other)
		{
			if (X == other.X)
			{
				return Y == other.Y;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return X ^ Y;
		}

		public override string ToString()
		{
			return "{X:" + X + " Y:" + Y + "}";
		}

		public Vector2 ToVector2()
		{
			return new Vector2(X, Y);
		}
	}
	public abstract class Singleton<T> where T : class, new()
	{
		private static T m_instance;

		public static T Instance
		{
			get
			{
				return m_instance ?? (m_instance = new T());
			}
			protected set
			{
				m_instance = value;
			}
		}

		protected Singleton()
		{
			m_instance = this as T;
		}

		public virtual void Shutdown()
		{
			m_instance = null;
		}
	}
	public class SingletonMonoBehaviour<T> : MonoBehaviour where T : MonoBehaviour
	{
		protected const bool IsSearchObjectOnNullInstance = true;

		protected static T m_instance;

		public static bool HasInstance => m_instance != null;

		public static T Instance
		{
			get
			{
				if (m_instance == null && UnityEngine.Object.FindObjectsOfType(typeof(T)) is T[] array)
				{
					int num = array.Length;
					if (num == 1)
					{
						m_instance = array[0];
						return m_instance;
					}
					if (num > 1)
					{
						for (int i = 0; i < num; i++)
						{
							UnityEngine.Object.Destroy(array[i].gameObject);
						}
					}
				}
				return m_instance;
			}
		}

		public virtual void Shutdown(bool isDestroyObject = true)
		{
			m_instance = null;
			if (isDestroyObject)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void OnApplicationQuit()
		{
			m_instance = null;
		}

		private void OnDestroy()
		{
			if (m_instance == this)
			{
				m_instance = null;
				ShutdownOnDestroy();
			}
		}

		private void Awake()
		{
			OnAwake();
		}

		private void OnAwake()
		{
			if (m_instance == null)
			{
				m_instance = this as T;
				InitializeOnAwake();
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		protected virtual void InitializeOnAwake()
		{
		}

		protected virtual void ShutdownOnDestroy()
		{
		}
	}
	public class SingletonUpdatableComponent<T> : UpdateableComponent where T : UpdateableComponent
	{
		protected const bool IsSearchObjectOnNullInstance = true;

		protected static T m_instance;

		public static bool HasInstance => m_instance != null;

		public static T Instance
		{
			get
			{
				if (m_instance == null)
				{
					return UnityEngine.Object.FindObjectOfType(typeof(T)) as T;
				}
				return m_instance;
			}
		}

		public virtual void Destroy(bool isDestroyObject = true)
		{
			m_instance = null;
			if (isDestroyObject)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void OnApplicationQuit()
		{
			m_instance = null;
		}

		protected override void OnShutdown()
		{
			if (m_instance == this)
			{
				m_instance = null;
			}
		}

		protected override void Initialize()
		{
			if (m_instance == null)
			{
				m_instance = this as T;
				InitializeOnStart();
			}
			else
			{
				Destroy(base.gameObject);
			}
		}

		protected virtual void InitializeOnStart()
		{
		}
	}
	public static class StringUtility
	{
		public static string Format<T1>(string format, T1 arg1)
		{
			return string.Format(format, arg1.ToString());
		}

		public static string Format<T1, T2>(string format, T1 arg1, T2 arg2)
		{
			return string.Format(format, arg1.ToString(), arg2.ToString());
		}

		public static string Format<T1, T2, T3>(string format, T1 arg1, T2 arg2, T3 arg3)
		{
			return string.Format(format, arg1.ToString(), arg2.ToString(), arg3.ToString());
		}

		public static string Format<T1, T2, T3, T4>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
		{
			return string.Format(format, arg1.ToString(), arg2.ToString(), arg3.ToString(), arg4.ToString());
		}
	}
	public class Timer
	{
		private float m_currentTime;

		private float m_duration;

		public bool IsTimeUp => m_currentTime >= m_duration;

		public float RemainingTime => Mathf.Max(0f, m_duration - m_currentTime);

		public float RemainingMin => RemainingTime / 60f;

		public float Duration => m_duration;

		public float CurrentTime => m_currentTime;

		public float Rate
		{
			get
			{
				return Mathf.Clamp(m_currentTime / m_duration, 0f, 1f);
			}
			set
			{
				m_currentTime = Mathf.Clamp(m_duration * value, 0f, 1f);
			}
		}

		public Timer(float duration)
		{
			m_currentTime = 0f;
			m_duration = duration;
		}

		public void SetDuration(float duration, bool isReset = true)
		{
			m_duration = duration;
			if (isReset)
			{
				m_currentTime = 0f;
			}
		}

		public void SetToTimeup()
		{
			m_currentTime = m_duration;
		}

		public void Reset()
		{
			m_currentTime = 0f;
		}

		public void AddRemainingTime(float amonuntToAdd)
		{
			m_duration += amonuntToAdd;
		}

		public void Update(float delta)
		{
			m_currentTime = Mathf.Clamp(m_currentTime + delta, 0f, m_duration);
		}
	}
	public class Tweener<T>
	{
		public delegate T TweenMethod<TLerp>(T start, T end, float amount);

		private TweenMethod<T> m_lerpFunction;

		private List<Action> m_onTweenEndActions;

		private T m_start;

		private T m_target;

		private Timer m_timer;

		public T CurrentValue { get; private set; }

		public bool IsActive { get; private set; }

		public T StartValue => m_start;

		public T TargetValue => m_target;

		public float Duration
		{
			get
			{
				return m_timer.Duration;
			}
			set
			{
				m_timer.SetDuration(Mathf.Clamp(value, 0f, float.MaxValue));
			}
		}

		public float RemainingTime => m_timer.RemainingTime;

		public Tweener(TweenMethod<T> tweenMethod)
		{
			m_onTweenEndActions = new List<Action>(10);
			m_lerpFunction = tweenMethod;
			CurrentValue = default(T);
			m_start = default(T);
			m_target = default(T);
			m_timer = new Timer(0f);
			IsActive = false;
		}

		public Tweener(TweenMethod<T> tweenMethod, T initialValue)
		{
			m_onTweenEndActions = new List<Action>(10);
			m_lerpFunction = tweenMethod;
			CurrentValue = initialValue;
			m_start = initialValue;
			m_target = initialValue;
			m_timer = new Timer(0f);
			IsActive = false;
		}

		public void Start(T start, T end, float duration, Action onTweenEndMethod = null)
		{
			m_start = start;
			m_target = end;
			m_timer.SetDuration(duration);
			CurrentValue = m_start;
			if (onTweenEndMethod != null)
			{
				m_onTweenEndActions.Add(onTweenEndMethod);
			}
			if (duration <= 0f)
			{
				IsActive = false;
				CurrentValue = m_target;
				PlayActions();
			}
			else
			{
				IsActive = true;
			}
		}

		public void StartReverse(Action onTweenEndMethod = null)
		{
			Start(m_target, m_start, m_timer.Duration, onTweenEndMethod);
		}

		public void Update(float delta)
		{
			if (IsActive)
			{
				m_timer.Update(delta);
				if (m_timer.IsTimeUp)
				{
					m_timer.SetToTimeup();
					CurrentValue = m_target;
					IsActive = false;
					PlayActions();
				}
				ProcessInterpolation(m_timer.Rate);
			}
		}

		private void ProcessInterpolation(float percentage)
		{
			CurrentValue = m_lerpFunction(m_start, m_target, percentage);
		}

		public void SetCurrentValue(T current)
		{
			CurrentValue = current;
		}

		public void SetCurrentRate(float rate)
		{
			m_timer.Rate = rate;
		}

		public void AddAction(Action toAdd)
		{
			if (toAdd != null)
			{
				m_onTweenEndActions.Add(toAdd);
			}
		}

		private void PlayActions()
		{
			int count = m_onTweenEndActions.Count;
			for (int i = 0; i < count; i++)
			{
				m_onTweenEndActions[i]();
			}
			m_onTweenEndActions.RemoveRange(0, count);
		}

		public void Dispose()
		{
			IsActive = false;
			m_onTweenEndActions.Clear();
		}
	}
	public class UIFader : IFader
	{
		[SerializeField]
		private Graphic m_graphic;

		public Color StartColour => m_startColour;

		public Color EndColour => m_targetColour;

		public override bool IsFadeVisible => m_graphic.enabled;

		protected override void OnInitialize()
		{
			if (m_graphic == null)
			{
				m_graphic = GetComponent<Graphic>();
			}
		}

		protected override void OnFade()
		{
			Initialize();
			m_graphic.enabled = true;
			if (m_colourTweener.IsActive)
			{
				m_graphic.color = m_colourTweener.StartValue;
			}
			else
			{
				m_graphic.color = m_colourTweener.TargetValue;
			}
		}

		protected override void OnFadeEnd()
		{
			if (m_isDeactivateOnEnd)
			{
				m_graphic.enabled = false;
			}
		}

		protected override void UpdateColour()
		{
			m_graphic.color = m_colourTweener.CurrentValue;
		}

		public override void SetColour(Color colour)
		{
			if (m_graphic == null)
			{
				m_graphic = GetComponent<Graphic>();
			}
			m_graphic.color = colour;
			m_graphic.enabled = colour.a > 0f;
		}

		public void ResetColour(Color start, Color end)
		{
			m_startColour = start;
			m_targetColour = end;
			SetColour(start);
		}

		public override void SetActive(bool isActive)
		{
			m_graphic.enabled = isActive;
		}
	}
	public class UpdateableComponent : MonoBehaviour, IUpdateable
	{
		protected bool m_isActive;

		protected GameObject m_thisGameObject;

		public int Priority { get; set; }

		public bool IsActive
		{
			get
			{
				if (m_isActive && base.enabled)
				{
					return m_thisGameObject.activeInHierarchy;
				}
				return false;
			}
			set
			{
				m_isActive = value;
			}
		}

		public Component MyComponent => this;

		public GameObject Object => m_thisGameObject;

		protected IObservable<Unit> UpdateObservable => SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable;

		private void Start()
		{
			m_thisGameObject = base.gameObject;
			Priority = 0;
			IsActive = true;
			if (SingletonMonoBehaviour<GameLogic>.HasInstance)
			{
				SingletonMonoBehaviour<GameLogic>.Instance.RegisterUpdateableObject(this);
			}
			Initialize();
		}

		private void OnDestroy()
		{
			if (SingletonMonoBehaviour<GameLogic>.HasInstance)
			{
				SingletonMonoBehaviour<GameLogic>.Instance.DeregisterUpdateableObject(this);
			}
			OnShutdown();
		}

		public virtual void OnUpdate(float delta)
		{
		}

		protected virtual void Initialize()
		{
		}

		protected virtual void OnShutdown()
		{
		}
	}
	public class VRDebugInput : MonoBehaviour
	{
		[SerializeField]
		private KeyCode m_recenterKey = KeyCode.R;

		[SerializeField]
		private KeyCode m_showDebugKey = KeyCode.D;

		[SerializeField]
		private List<GameObject> m_debugDisplayObjects;

		private void Update()
		{
			if (Input.GetKeyDown(m_recenterKey))
			{
				InputTracking.Recenter();
			}
			if (Input.GetKeyDown(m_showDebugKey))
			{
				ToggleShowDebug();
			}
		}

		public void ToggleShowDebug()
		{
			int count = m_debugDisplayObjects.Count;
			for (int i = 0; i < count; i++)
			{
				m_debugDisplayObjects[i].SetActive(!m_debugDisplayObjects[i].activeSelf);
			}
		}
	}
	public static class VRDeviceTypes
	{
		public const string _NONE = "None";

		public const string _OCULUS = "Oculus";

		public const string _OPEN_VR = "OpenVR";

		public const string _CARDBOARD = "cardboard";

		public const string _DAYDREAM = "daydream";

		public static bool IsVRMode()
		{
			if (!XRSettings.enabled || !XRSettings.isDeviceActive)
			{
				return false;
			}
			return XRSettings.loadedDeviceName != "None";
		}
	}
	public class VRUIMovement : MonoBehaviour
	{
		[SerializeField]
		private bool m_LookatCamera = true;

		[SerializeField]
		private Transform m_UIElement;

		[SerializeField]
		private Transform m_Camera;

		[SerializeField]
		private bool m_RotateWithCamera = true;

		[SerializeField]
		private float m_FollowSpeed = 10f;

		[SerializeField]
		private bool m_isLockY;

		private float m_DistanceFromCamera;

		private void Start()
		{
			m_DistanceFromCamera = Vector3.Distance(m_UIElement.position, m_Camera.position);
		}

		private void Update()
		{
			if (m_LookatCamera)
			{
				m_UIElement.rotation = Quaternion.LookRotation(m_UIElement.position - m_Camera.position);
			}
			if (m_RotateWithCamera)
			{
				Vector3 vector = ((!m_isLockY) ? m_Camera.forward : Vector3.ProjectOnPlane(m_Camera.forward, Vector3.up).normalized);
				Vector3 b = m_Camera.position + vector * m_DistanceFromCamera;
				b = Vector3.Lerp(m_UIElement.position, b, m_FollowSpeed * Time.deltaTime);
				if (m_isLockY)
				{
					b.y = m_UIElement.position.y;
				}
				m_UIElement.position = b;
			}
		}
	}
}
namespace Notte
{
	public static class ActionExtensions
	{
		public static void Call(this Action action)
		{
			action?.Invoke();
		}

		public static void Call<T>(this Action<T> action, T arg)
		{
			action?.Invoke(arg);
		}

		public static void Call<T1, T2>(this Action<T1, T2> action, T1 arg1, T2 arg2)
		{
			action?.Invoke(arg1, arg2);
		}

		public static void Call<T1, T2, T3>(this Action<T1, T2, T3> action, T1 arg1, T2 arg2, T3 arg3)
		{
			action?.Invoke(arg1, arg2, arg3);
		}
	}
}
namespace TkChronos
{
	public class KaineLoader
	{
		public class PartsData : SimpleSoundLoader.SoundData
		{
			public int PartsID;

			public int Layer;

			public int Frequency = 44100;

			public PartsData(int id, int partsID, int layer, AudioClip clip, bool isStoreFrequency = false)
				: base(id, clip)
			{
				Layer = layer;
				PartsID = partsID;
				if (isStoreFrequency)
				{
					Frequency = clip.frequency;
				}
			}
		}

		public class ClipData
		{
			public List<AudioClip> Clips;

			public int Frequency;

			public ClipData()
			{
				Clips = null;
				Frequency = 0;
			}
		}

		private const string _FILE_PATH = "Audio/BGM/{0:D2}/{1:D2}_{2}_{3:D2}";

		private const int _ID_INTRO = 0;

		private const int _ID_OUTRO = 1;

		private const int _ID_PARTS_START = 2;

		private const int _DEFAULT_LIST_SIZE = 5;

		private BgmData m_data;

		private List<AsyncOperation> m_introRequests;

		private List<AsyncOperation> m_partsRequests;

		private List<AsyncOperation> m_outroRequests;

		private List<PartsData> m_introData;

		private List<PartsData> m_outroData;

		private List<PartsData>[] m_partsData;

		private List<AudioClip> m_introList;

		private List<AudioClip> m_outroList;

		private List<PartsData> m_outputPartsList;

		private ClipData m_clipData;

		public int FirstBgmID { get; private set; }

		public bool IsLoading { get; private set; }

		public bool HasRequest
		{
			get
			{
				if (m_introRequests.Count <= 0 && m_partsRequests.Count <= 0)
				{
					return m_outroRequests.Count > 0;
				}
				return true;
			}
		}

		public KaineLoader(BgmData data, int layerCount)
		{
			IsLoading = false;
			m_data = data;
			FirstBgmID = -1;
			m_introRequests = new List<AsyncOperation>();
			m_partsRequests = new List<AsyncOperation>();
			m_outroRequests = new List<AsyncOperation>();
			m_introData = new List<PartsData>();
			m_outroData = new List<PartsData>();
			m_introList = new List<AudioClip>(5);
			m_outroList = new List<AudioClip>(5);
			m_outputPartsList = new List<PartsData>(20);
			m_clipData = new ClipData();
			m_partsData = new List<PartsData>[layerCount];
			for (int i = 0; i < layerCount; i++)
			{
				m_partsData[i] = new List<PartsData>();
			}
		}

		public void Clear()
		{
			IsLoading = false;
			FirstBgmID = -1;
			m_introList.Clear();
			m_outroList.Clear();
			m_outputPartsList.Clear();
			ClearSoundData(m_introData);
			ClearSoundData(m_outroData);
			int num = m_partsData.Length;
			for (int i = 0; i < num; i++)
			{
				ClearSoundData(m_partsData[i]);
			}
			ClearRequestData(m_introRequests);
			ClearRequestData(m_partsRequests);
			ClearRequestData(m_outroRequests);
			Resources.UnloadUnusedAssets();
		}

		private void ClearSoundData(List<PartsData> list)
		{
			int count = list.Count;
			for (int i = 0; i < count; i++)
			{
				Resources.UnloadAsset(list[i].Clip);
				list[i].Clip = null;
			}
			list.Clear();
		}

		private void ClearRequestData(List<AsyncOperation> list)
		{
			list.Clear();
		}

		public void ClearUnusedBgm(List<ISoundCommand> nextBgmList)
		{
			ClearUnusedData(nextBgmList, m_introData);
			ClearUnusedData(nextBgmList, m_outroData);
			int num = m_partsData.Length;
			for (int i = 0; i < num; i++)
			{
				ClearUnusedData(nextBgmList, m_partsData[i]);
			}
		}

		private void ClearUnusedData(List<ISoundCommand> nextList, List<PartsData> dataList)
		{
			if (nextList.Count <= 0)
			{
				return;
			}
			for (int i = 0; i < dataList.Count; i++)
			{
				bool flag = RemoveCommandWithID(nextList, dataList[i].ID);
				if (nextList.Count <= 0)
				{
					break;
				}
			}
			Resources.UnloadUnusedAssets();
		}

		private bool RemoveCommandWithID(List<ISoundCommand> list, int id)
		{
			bool result = false;
			for (int i = 0; i < list.Count; i++)
			{
				if (list[i].ID == id)
				{
					list.RemoveAt(i);
					i--;
					result = true;
				}
			}
			return result;
		}

		public void Load(List<ISoundCommand> bgmList, ISoundCommand firstBgm)
		{
			if (bgmList == null)
			{
				return;
			}
			ClearUnusedBgm(bgmList);
			int count = bgmList.Count;
			for (int i = 0; i < count; i++)
			{
				int iD = bgmList[i].ID;
				BgmData.Param param = m_data.FindByID(iD);
				LoadAllParts(iD, param);
				if (param.Intro)
				{
					LoadIntro(iD, param.Layer);
				}
				if (param.Outro)
				{
					LoadOutro(iD, param.Layer);
				}
				IsLoading = true;
			}
			FirstBgmID = -1;
			if (firstBgm != null)
			{
				FirstBgmID = firstBgm.ID;
			}
		}

		private void LoadAllParts(int id, BgmData.Param data)
		{
			int parts = data.Parts;
			for (int i = 0; i < data.Layer; i++)
			{
				for (int j = 0; j < parts; j++)
				{
					int partsID = j + 2;
					LoadParts(id, partsID, i, m_partsData[i], m_partsRequests);
				}
			}
		}

		private void LoadParts(int baseID, int partsID, int layer, List<PartsData> dataList, List<AsyncOperation> requestList)
		{
			string path = $"Audio/BGM/{baseID:D2}/{baseID:D2}_{layer}_{partsID:D2}";
			ResourceRequest resourceRequest = Resources.LoadAsync<AudioClip>(path);
			resourceRequest.completed += delegate(AsyncOperation obj)
			{
				OnLoadDataComplete(obj, dataList, baseID, partsID, layer, requestList, path);
			};
			requestList.Add(resourceRequest);
		}

		private void LoadIntro(int baseID, int numLayers)
		{
			LoadUniqueParts(baseID, 0, numLayers, m_introData, m_introRequests);
		}

		private void LoadOutro(int baseID, int numLayers)
		{
			LoadUniqueParts(baseID, 1, numLayers, m_outroData, m_outroRequests);
		}

		private void LoadUniqueParts(int baseID, int partsID, int numLayers, List<PartsData> dataList, List<AsyncOperation> requestList)
		{
			for (int i = 0; i < numLayers; i++)
			{
				LoadParts(baseID, partsID, i, dataList, requestList);
			}
		}

		private void OnLoadDataComplete(AsyncOperation obj, List<PartsData> soundList, int baseID, int partsID, int layer, List<AsyncOperation> requestList, string path)
		{
			requestList.Remove(obj);
			IsLoading = HasRequest;
			AudioClip audioClip = (obj as ResourceRequest).asset as AudioClip;
			if (!(audioClip == null))
			{
				soundList.Add(new PartsData(baseID, partsID, layer, audioClip, isStoreFrequency: true));
			}
		}

		public List<AudioClip> FindIntros(int baseID, int layer)
		{
			m_introList.Clear();
			return FindTracks(baseID, layer, m_introData, m_introList).Clips;
		}

		public List<AudioClip> FindOutros(int baseID, int layer)
		{
			m_outroList.Clear();
			return FindTracks(baseID, layer, m_outroData, m_outroList).Clips;
		}

		private ClipData FindTracks(int baseID, int layer, List<PartsData> dataList, List<AudioClip> list)
		{
			m_clipData.Clips = null;
			int count = dataList.Count;
			for (int i = 0; i < count; i++)
			{
				if (dataList[i].ID == baseID && dataList[i].Layer == layer)
				{
					list.Add(dataList[i].Clip);
					m_clipData.Frequency = dataList[i].Frequency;
				}
			}
			m_clipData.Clips = list;
			return m_clipData;
		}

		public List<PartsData> FindPartsList(int baseID, int layer)
		{
			m_outputPartsList.Clear();
			int count = m_partsData[layer].Count;
			for (int i = 0; i < count; i++)
			{
				if (m_partsData[layer][i].ID == baseID && m_partsData[layer][i].Layer == layer)
				{
					m_outputPartsList.Add(m_partsData[layer][i]);
				}
			}
			return m_outputPartsList;
		}

		public int FindFrequency(int baseID)
		{
			int count = m_partsData[0].Count;
			for (int i = 0; i < count; i++)
			{
				if (m_partsData[0][i].ID == baseID)
				{
					return m_partsData[0][i].Frequency;
				}
			}
			return -1;
		}
	}
	[CreateAssetMenu(menuName = "Chronos/Create Debug Settings", fileName = "DebugSettings")]
	public class DebugSettings : ScriptableObject
	{
		[SerializeField]
		public int ScenarioID;

		[SerializeField]
		public int SkipDestinationIndex = -1;
	}
	public class AvaterBodyObject : BaseAvaterObject
	{
		protected override bool InitialRenderEnabled => false;
	}
	public class AvaterHandObject : BaseAvaterObject
	{
		public enum Node
		{
			RightHand,
			LeftHand
		}

		[SerializeField]
		private Animator _animator;

		[SerializeField]
		[EnumLabel(typeof(Node))]
		private Transform[] _nodes;

		private int m_idParamIndex;

		private int m_startAnimationParamIndex;

		public override Animator AvaterAnimator => _animator;

		protected override bool InitialRenderEnabled => false;

		protected override void OnAwakeInitialize()
		{
			m_idParamIndex = Animator.StringToHash("motion");
			m_startAnimationParamIndex = Animator.StringToHash("motionTrigger");
		}

		public override void PlayAnimation(int id, bool isFade, bool isSkipAnimation)
		{
			if (id < 300 && !(AvaterAnimator == null))
			{
				AvaterAnimator.SetInteger(m_idParamIndex, id);
				AvaterAnimator.SetTrigger(m_startAnimationParamIndex);
			}
		}

		public Transform GetNodeTransform(Node index)
		{
			return _nodes[(int)index];
		}
	}
	public class AvaterMaterialController : MonoBehaviour
	{
		private void Start()
		{
		}

		private void Update()
		{
		}
	}
	public class AvaterTrackedHandObject : BaseAvaterObject
	{
		public enum Node
		{
			TrackedGrabPivot
		}

		[SerializeField]
		private Animator _animator;

		[SerializeField]
		[EnumLabel(typeof(Node))]
		private Transform[] _nodes;

		private int m_idParamIndex;

		private int m_startAnimationParamIndex;

		private bool IsShowMenu;

		private Vector3 lastTrackedHandPosition;

		private float HideTimer;

		public override Animator AvaterAnimator => _animator;

		protected override bool InitialRenderEnabled => false;

		public bool IsTrackedHandShowing { get; set; }

		public bool SleepTrackedHandShowing { get; set; }

		public bool IsPreventSleeping { get; set; }

		public bool TrackedHandShowSetting { get; set; }

		public bool IsForceTrackedHandHiding { get; set; }

		public bool IsForceTrackedHandFadeHiding { get; set; }

		protected override void OnAwakeInitialize()
		{
			m_idParamIndex = Animator.StringToHash("motion");
			m_startAnimationParamIndex = Animator.StringToHash("motionTrigger");
			IsTrackedHandShowing = MainPosition.Avater.AvaterResources.TrackedHandRightLoader.IsFadeInOnNew;
			TrackedHandShowSetting = true;
			IsForceTrackedHandHiding = false;
			lastTrackedHandPosition = base.transform.position;
		}

		private void Start()
		{
			if (SingletonMonoBehaviour<MainMenuManager>.HasInstance)
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.OnToggleMenu.Subscribe(delegate(bool opened)
				{
					ShowMenu(opened);
				}).AddTo(base.gameObject);
			}
		}

		public override void PlayAnimation(int id, bool isFade, bool isSkipAnimation)
		{
			if (id < 300 && !(AvaterAnimator == null))
			{
				AvaterAnimator.SetInteger(m_idParamIndex, id);
				AvaterAnimator.SetTrigger(m_startAnimationParamIndex);
			}
		}

		public Transform GetNodeTransform(Node index)
		{
			return _nodes[(int)index];
		}

		public void ChangeTrackedHandShowing(float duration = 0.2f)
		{
			if (IsTrackedHandShowing && TrackedHandShowSetting && !IsForceTrackedHandHiding && !IsForceTrackedHandFadeHiding)
			{
				StartFadeIn(duration, delegate
				{
				});
			}
		}

		public void ChangeTrackedHandHiding(float duration = 0.2f)
		{
			StartFadeOut(duration, delegate
			{
			});
		}

		public void TrackedHandMoveCheck()
		{
			if (!IsShowMenu)
			{
				if (IsPreventSleeping)
				{
					if (!SleepTrackedHandShowing)
					{
						ChangeTrackedHandShowing();
						SleepTrackedHandShowing = true;
						HideTimer = 0f;
					}
				}
				else
				{
					float num = Vector3.Distance(base.transform.position, lastTrackedHandPosition);
					if (!SleepTrackedHandShowing)
					{
						if ((double)num > 0.02)
						{
							ChangeTrackedHandShowing();
							SleepTrackedHandShowing = true;
							HideTimer = 0f;
						}
					}
					else if ((double)num < 0.005)
					{
						if (HideTimer > 3f)
						{
							ChangeTrackedHandHiding();
							SleepTrackedHandShowing = false;
						}
						else
						{
							HideTimer += 0.1f;
						}
					}
					else
					{
						HideTimer = 0f;
					}
				}
			}
			lastTrackedHandPosition = base.transform.position;
		}

		public void ShowMenu(bool isHandFade)
		{
			if (isHandFade)
			{
				IsShowMenu = true;
				ChangeTrackedHandHiding();
			}
			else
			{
				IsShowMenu = false;
				ChangeTrackedHandShowing();
			}
		}

		public void ForceHideTrackedHand(bool fide)
		{
			if (fide)
			{
				IsForceTrackedHandHiding = true;
				ChangeTrackedHandHiding();
			}
			else
			{
				IsForceTrackedHandHiding = false;
				ChangeTrackedHandShowing();
			}
		}

		public void ForceFadeHideTrackedHand(bool fide)
		{
			if (fide)
			{
				IsForceTrackedHandFadeHiding = true;
				ChangeTrackedHandHiding();
			}
			else
			{
				IsForceTrackedHandFadeHiding = false;
				ChangeTrackedHandShowing();
			}
		}

		public void ForceFadeHideTrackedHand(bool fide, float duration)
		{
			if (fide)
			{
				IsForceTrackedHandFadeHiding = true;
				ChangeTrackedHandHiding(duration);
			}
			else
			{
				IsForceTrackedHandFadeHiding = false;
				ChangeTrackedHandShowing(duration);
			}
		}
	}
	public class AvaterTrackedHandObjectTimer : MonoBehaviour
	{
		private AvaterTrackedHandObject TrackedHandObject;

		private void Start()
		{
			TrackedHandObject = GetComponent<AvaterTrackedHandObject>();
			Observable.Interval(TimeSpan.FromMilliseconds(100.0)).Subscribe(delegate
			{
				TrackedHandObject.TrackedHandMoveCheck();
			}).AddTo(base.gameObject);
		}
	}
	public abstract class BaseAvaterObject : MonoBehaviour
	{
		private const float AVATER_MATERIAL_FADE_DURATION = 0.25f;

		private const float AVATER_DEFAULT_OUTLINE = 0f;

		private const string _PARAM_ALPHA = "_Alpha";

		private const string _PARAM_OUTLINE_SIZE = "_Outline";

		private const string _PARAM_OUTLINE_COLOR = "_OutlineColor";

		[SerializeField]
		private List<AdvCharaTextureData> _textures = new List<AdvCharaTextureData>();

		private List<Renderer> _renderers;

		private Material _currentMaterial;

		private Dictionary<int, Material> _fixedMaterials = new Dictionary<int, Material>();

		private bool _renderEnabled;

		private bool _isFading;

		private Color _defaultOutlineColor;

		private float _defaultOutlineSize;

		private Coroutine _currentFadeRoutine;

		private IDisposable _disposeSmoothOutlineColorChange;

		private IDisposable _disposeSmoothOutlineSizeChange;

		public bool IsFading => _isFading;

		public virtual Animator AvaterAnimator => null;

		public bool IsVisible => _renderEnabled;

		protected virtual bool InitialRenderEnabled => true;

		private float MaterialAlpha
		{
			get
			{
				if (!_renderEnabled)
				{
					return 0f;
				}
				return _currentMaterial.GetFloat("_Alpha");
			}
		}

		private void Awake()
		{
			FineRenderers();
			SetDefaultValues();
			OnAwakeInitialize();
		}

		private void FineRenderers()
		{
			_renderers = new List<Renderer>();
			_renderers.AddRange(GetComponents<Renderer>());
			_renderers.AddRange(GetComponentsInChildren<Renderer>());
			FindFixedMaterials();
			SetRenderEnabled(InitialRenderEnabled, force: true);
		}

		protected virtual void OnAwakeInitialize()
		{
		}

		private void FindFixedMaterials()
		{
			_renderers.ForEach(delegate(Renderer renderer)
			{
				Material[] sharedMaterials = renderer.sharedMaterials;
				Material[] array = new Material[sharedMaterials.Length];
				for (int i = 0; i < sharedMaterials.Length; i++)
				{
					Material material = sharedMaterials[i];
					if (!(material == null))
					{
						if (!_fixedMaterials.TryGetValue(material.GetHashCode(), out var value))
						{
							value = new Material(material);
							value.SetFloat("_Alpha", 0f);
							_fixedMaterials.Add(material.GetHashCode(), value);
							if (_currentMaterial == null)
							{
								_currentMaterial = value;
							}
						}
						array[i] = value;
					}
				}
				renderer.materials = array;
			});
		}

		private void SetMaterialsAlpha(float alpha)
		{
			foreach (KeyValuePair<int, Material> fixedMaterial in _fixedMaterials)
			{
				fixedMaterial.Value.SetFloat("_Alpha", alpha);
			}
		}

		public void SetRenderEnabled(bool flag, bool force = false)
		{
			if (force || flag != _renderEnabled)
			{
				_renderEnabled = flag;
				int count = _renderers.Count;
				for (int i = 0; i < count; i++)
				{
					_renderers[i].enabled = _renderEnabled;
				}
			}
		}

		private void SetDefaultValues()
		{
			_defaultOutlineSize = 0f;
			_defaultOutlineColor = GetMaterialOutlineColor();
			SetOutlineSize(_defaultOutlineSize);
		}

		public void RevertToDefault()
		{
			SetOutlineSize(_defaultOutlineSize);
			SetOutlineColor(_defaultOutlineColor);
		}

		public Coroutine StartFadeIn()
		{
			return StartFadeIn(0.25f, delegate
			{
			});
		}

		public Coroutine StartFadeIn(Action onEnd)
		{
			return StartFadeIn(0.25f, onEnd);
		}

		public Coroutine StartFadeIn(float duration, Action onEnd)
		{
			if (MaterialAlpha >= 1f)
			{
				onEnd?.Invoke();
				return null;
			}
			float materialAlpha = MaterialAlpha;
			SetRenderEnabled(flag: true);
			if (_currentFadeRoutine != null)
			{
				StopCoroutine(_currentFadeRoutine);
			}
			_currentFadeRoutine = StartCoroutine(CoroutineFade(materialAlpha, 1f, duration, onEnd));
			return _currentFadeRoutine;
		}

		public Coroutine StartFadeOut()
		{
			return StartFadeOut(0.25f, delegate
			{
			});
		}

		public Coroutine StartFadeOut(Action onEnd)
		{
			return StartFadeOut(0.25f, onEnd);
		}

		public Coroutine StartFadeOut(float duration, Action onEnd)
		{
			if (!_renderEnabled || MaterialAlpha <= 0f)
			{
				onEnd?.Invoke();
				return null;
			}
			if (_currentFadeRoutine != null)
			{
				StopCoroutine(_currentFadeRoutine);
			}
			_currentFadeRoutine = StartCoroutine(CoroutineFade(MaterialAlpha, 0f, duration, onEnd));
			return _currentFadeRoutine;
		}

		private IEnumerator CoroutineFade(float fromA, float toA, float duration, Action onEnd)
		{
			_isFading = true;
			Tweener<float> _alphaTweener = new Tweener<float>(Mathf.Lerp);
			_alphaTweener.Start(fromA, toA, duration);
			while (_alphaTweener.IsActive)
			{
				yield return new WaitForEndOfFrame();
				_alphaTweener.Update(Time.deltaTime);
				SetMaterialsAlpha(_alphaTweener.CurrentValue);
			}
			_isFading = false;
			onEnd?.Invoke();
		}

		public void SetOutlineSize(float value)
		{
			DisposeSmoothOutlineSize();
			SetMaterialOutlineSize(value);
		}

		private void SetMaterialOutlineSize(float value)
		{
			foreach (Material value2 in _fixedMaterials.Values)
			{
				value2.SetFloat("_Outline", value);
			}
		}

		public void SetOutlineColor(Color value)
		{
			DisposeSmoothOutlineColor();
			SetMaterialOutlineColor(value);
		}

		private void SetMaterialOutlineColor(Color value)
		{
			foreach (Material value2 in _fixedMaterials.Values)
			{
				value2.SetColor("_OutlineColor", value);
			}
		}

		private float GetMaterialOutlineSize()
		{
			using (Dictionary<int, Material>.ValueCollection.Enumerator enumerator = _fixedMaterials.Values.GetEnumerator())
			{
				if (enumerator.MoveNext())
				{
					return enumerator.Current.GetFloat("_Outline");
				}
			}
			return 0f;
		}

		private Color GetMaterialOutlineColor()
		{
			using (Dictionary<int, Material>.ValueCollection.Enumerator enumerator = _fixedMaterials.Values.GetEnumerator())
			{
				if (enumerator.MoveNext())
				{
					return enumerator.Current.GetColor("_OutlineColor");
				}
			}
			return Color.clear;
		}

		public void DisposeSmoothOutlineSize()
		{
			if (_disposeSmoothOutlineSizeChange != null)
			{
				_disposeSmoothOutlineSizeChange.Dispose();
				_disposeSmoothOutlineSizeChange = null;
			}
		}

		public void StartSmoothOutlineSizeChange(float duration, float after)
		{
			DisposeSmoothOutlineSize();
			_disposeSmoothOutlineSizeChange = Observable.FromMicroCoroutine((CancellationToken _) => RoutineSmoothOutlineSizeChange(duration, after)).Subscribe().AddTo(base.gameObject);
		}

		private IEnumerator RoutineSmoothOutlineSizeChange(float duration, float after)
		{
			float tick = 0f;
			float before = GetMaterialOutlineSize();
			while (tick < duration)
			{
				tick += Time.deltaTime;
				SetMaterialOutlineSize(Mathf.Lerp(before, after, tick / duration));
				yield return null;
			}
			SetMaterialOutlineSize(after);
		}

		public void DisposeSmoothOutlineColor()
		{
			if (_disposeSmoothOutlineColorChange != null)
			{
				_disposeSmoothOutlineColorChange.Dispose();
				_disposeSmoothOutlineColorChange = null;
			}
		}

		public void StartSmoothOutlineColorChange(float duration, Color after)
		{
			DisposeSmoothOutlineColor();
			_disposeSmoothOutlineColorChange = Observable.FromMicroCoroutine((CancellationToken _) => RoutineSmoothOutlineColorChange(duration, after)).Subscribe().AddTo(base.gameObject);
		}

		private IEnumerator RoutineSmoothOutlineColorChange(float duration, Color after)
		{
			float tick = 0f;
			Color before = GetMaterialOutlineColor();
			while (tick < duration)
			{
				tick += Time.deltaTime;
				SetMaterialOutlineColor(Color.Lerp(before, after, tick / duration));
				yield return null;
			}
			SetMaterialOutlineColor(after);
		}

		private Texture FindTextureByType(AdvCharaTextureData.TextureType type)
		{
			return _textures.Find((AdvCharaTextureData param) => param.Type == type)?.Texture;
		}

		private void SetTextureToMaterials(Texture texture)
		{
			foreach (Material value in _fixedMaterials.Values)
			{
				value.mainTexture = texture;
			}
		}

		public void ChangeTextureType(AdvCharaTextureData.TextureType type)
		{
			Texture texture = FindTextureByType(type);
			if (!(texture == null))
			{
				SetTextureToMaterials(texture);
			}
		}

		public virtual void PlayAnimation(int id, bool isFade, bool isSkipAnimation)
		{
		}
	}
	[CreateAssetMenu(menuName = "Chronos/Avater Setting", fileName = "AvaterSetting")]
	public class DataAvaterSetting : ScriptableObject
	{
		[EnumLabel(typeof(PlayerAvater.AvaterParts))]
		public int[] MaxTypes = new int[2] { 1, 1 };
	}
	public class AvaterVanishEffect : MonoBehaviour
	{
		[SerializeField]
		private float _defaultFadeTime = 0.3f;

		[SerializeField]
		private float _defaultRemainTime = 0.5f;

		private Renderer[] _myRenderers;

		private SortedList<int, Material> _instancedMaterials;

		private IDisposable _dispoceEffect;

		private void Awake()
		{
			FindRenderer();
			CreateMaterialInstance();
			SetMaterialAlpha(0f);
			SetRendererEnable(flag: false);
		}

		private void FindRenderer()
		{
			_myRenderers = GetComponentsInChildren<Renderer>();
		}

		private void CreateMaterialInstance()
		{
			_instancedMaterials = new SortedList<int, Material>();
			Renderer[] myRenderers = _myRenderers;
			foreach (Renderer renderer in myRenderers)
			{
				Material[] sharedMaterials = renderer.sharedMaterials;
				Material[] array = new Material[sharedMaterials.Length];
				for (int j = 0; j < sharedMaterials.Length; j++)
				{
					Material material = sharedMaterials[j];
					if (!_instancedMaterials.TryGetValue(material.GetHashCode(), out var value))
					{
						value = new Material(material);
						_instancedMaterials.Add(material.GetHashCode(), value);
					}
					array[j] = value;
				}
				renderer.materials = array;
			}
		}

		private void SetMaterialAlpha(float a)
		{
			foreach (Material value in _instancedMaterials.Values)
			{
				value.SetFloat("_Alpha", a);
			}
		}

		private void SetRendererEnable(bool flag)
		{
			Renderer[] myRenderers = _myRenderers;
			for (int i = 0; i < myRenderers.Length; i++)
			{
				myRenderers[i].enabled = flag;
			}
		}

		public void StartVanishEffect()
		{
			if (_dispoceEffect != null)
			{
				_dispoceEffect.Dispose();
				_dispoceEffect = null;
			}
			SetRendererEnable(flag: true);
			_dispoceEffect = Observable.FromMicroCoroutine((CancellationToken _) => CoroutineFade(0f, 1f, _defaultFadeTime)).SelectMany((Unit _) => CoroutineWait(_defaultRemainTime)).SelectMany((Unit _) => CoroutineFade(1f, 0f, _defaultFadeTime))
				.Subscribe(delegate
				{
					SetRendererEnable(flag: false);
					_dispoceEffect = null;
				})
				.AddTo(base.gameObject);
		}

		private IEnumerator CoroutineFade(float start, float end, float duration)
		{
			Tweener<float> _tweener = new Tweener<float>(Mathf.Lerp, start);
			_tweener.Start(start, end, duration);
			while (_tweener.IsActive)
			{
				_tweener.Update(Time.deltaTime);
				SetMaterialAlpha(_tweener.CurrentValue);
				yield return null;
			}
		}

		private IEnumerator CoroutineWait(float duration)
		{
			Common.Timer timer = new Common.Timer(duration);
			while (!timer.IsTimeUp)
			{
				timer.Update(Time.deltaTime);
				yield return null;
			}
		}
	}
	public class AvaterBodyLoader : BaseAvaterLoader
	{
		protected override string LoadFolderFormat => "Prefabs/Avaters/{0}/Body{0}";

		protected override bool DefaultFadeInOnNew => true;
	}
	public class AvaterHandLoader : BaseAvaterLoader
	{
		protected override string LoadFolderFormat => "Prefabs/Avaters/{0}/Hand{0}Type{1}";

		protected override bool DefaultFadeInOnNew => false;
	}
	public class AvaterTrackedHandLoader : BaseAvaterLoader
	{
		[SerializeField]
		private VRDeviceDefine.HandType _handType;

		private Transform _thisTrans;

		protected override bool DisabledToLoad => !SingletonMonoBehaviour<PlayAreaManager>.Instance.InputVR.UseTrackedHands;

		protected override string LoadFolderFormat
		{
			get
			{
				if (_handType != 0)
				{
					return "Prefabs/Avaters/{0}/TrackedHandRight{0}";
				}
				return "Prefabs/Avaters/{0}/TrackedHandLeft{0}";
			}
		}

		protected override bool DefaultFadeInOnNew => true;

		private Transform ThisTrans
		{
			get
			{
				if (_thisTrans == null)
				{
					_thisTrans = base.transform;
				}
				return _thisTrans;
			}
		}

		public override void OnStartAvater()
		{
			if (DisabledToLoad)
			{
				base.gameObject.SetActive(value: false);
				return;
			}
			SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable.Where((Unit _) => base.IsLoaded && !base.IsPausedTracking).Subscribe(delegate
			{
				ThisTrans.localPosition = SingletonMonoBehaviour<PlayAreaManager>.Instance.InputVR.GetHandPosition(_handType);
				ThisTrans.localRotation = SingletonMonoBehaviour<PlayAreaManager>.Instance.InputVR.GetHandRotation(_handType);
			}).AddTo(base.gameObject);
		}
	}
	public abstract class BaseAvaterLoader : MonoBehaviour
	{
		protected const string FOLDER_BODY_FORMAT = "Prefabs/Avaters/{0}/Body{0}";

		protected const string FOLDER_HAND_FORMAT = "Prefabs/Avaters/{0}/Hand{0}Type{1}";

		protected const string FOLDER_TRACKEDHAND_LEFT_FORMAT = "Prefabs/Avaters/{0}/TrackedHandLeft{0}";

		protected const string FOLDER_TRACKEDHAND_RIGHT_FORMAT = "Prefabs/Avaters/{0}/TrackedHandRight{0}";

		private int _currentAvaterIndex;

		private BaseAvaterObject _currentAvaterObject;

		private SortedList<int, BaseAvaterObject> _loadedAvaters = new SortedList<int, BaseAvaterObject>();

		public bool IsFadeInOnNew { get; set; }

		public int InitialFadeInIndex { get; set; }

		public int AvaterTypeMax { get; set; }

		public bool IsPausedTracking { get; set; }

		public bool IsBusy { get; private set; }

		public bool IsLoaded { get; private set; }

		public BaseAvaterObject AvaterObject => _currentAvaterObject;

		protected virtual bool DisabledToLoad => false;

		protected virtual string LoadFolderFormat => "";

		protected virtual bool DefaultFadeInOnNew => true;

		private void Awake()
		{
			IsFadeInOnNew = DefaultFadeInOnNew;
			InitialFadeInIndex = 0;
			AvaterTypeMax = 1;
		}

		private void Start()
		{
			OnStartAvater();
		}

		public virtual void OnStartAvater()
		{
		}

		public Coroutine LoadAvater(GameDefine.CharaID charaId)
		{
			if (DisabledToLoad)
			{
				return null;
			}
			if (charaId == GameDefine.CharaID.NONE)
			{
				DestroyAvater();
				return null;
			}
			return StartCoroutine(CoroutineLoadAvater(charaId));
		}

		private IEnumerator CoroutineLoadAvater(GameDefine.CharaID charaId)
		{
			yield return new WaitUntil(() => !IsBusy);
			IsBusy = true;
			DestroyAvater();
			for (int i = 0; i < AvaterTypeMax; i++)
			{
				ResourceRequest request = Resources.LoadAsync<BaseAvaterObject>(string.Format(LoadFolderFormat, (int)charaId, i));
				yield return request;
				if (!(request.asset == null))
				{
					BaseAvaterObject baseAvaterObject = UnityEngine.Object.Instantiate(request.asset as BaseAvaterObject);
					baseAvaterObject.transform.SetParent(base.transform, worldPositionStays: false);
					_loadedAvaters.Add(i, baseAvaterObject);
				}
			}
			_currentAvaterIndex = InitialFadeInIndex;
			if (!_loadedAvaters.TryGetValue(_currentAvaterIndex, out _currentAvaterObject))
			{
				_currentAvaterObject = null;
			}
			IsBusy = false;
			IsLoaded = _loadedAvaters.Count != 0;
		}

		public void ChangeCurrentAvaterType(int type)
		{
			if (_currentAvaterObject != null && _currentAvaterIndex != type)
			{
				_currentAvaterObject.StartFadeOut();
			}
			_currentAvaterIndex = type;
			_currentAvaterObject = _loadedAvaters[_currentAvaterIndex];
			if (_currentAvaterObject != null)
			{
				_currentAvaterObject.StartFadeIn();
			}
		}

		public void DestroyAvater()
		{
			if (_loadedAvaters.Count == 0)
			{
				return;
			}
			foreach (BaseAvaterObject value in _loadedAvaters.Values)
			{
				UnityEngine.Object.Destroy(value.gameObject);
			}
			_currentAvaterObject = null;
			_loadedAvaters.Clear();
			IsLoaded = false;
		}
	}
	public class PlayerAvater : UpdateableComponent
	{
		public enum AvaterParts
		{
			Body,
			Hand,
			TrackedHandLeft,
			TrackedHandRight
		}

		public enum AvaterTrackTypes
		{
			CameraPositon,
			NeckPosition,
			HeadPositionAndRotation,
			HandPositionAndRotation
		}

		public enum FadeModes
		{
			None,
			Smooth,
			Dither
		}

		[Header("Components - Pivots")]
		[SerializeField]
		private Transform messagePivot;

		[SerializeField]
		private Transform bodyPivot;

		[SerializeField]
		private Transform handPivot;

		[Header("Components - Targets")]
		[SerializeField]
		private Transform positionPivot;

		[SerializeField]
		private Transform headRotationPivot;

		[SerializeField]
		private Transform handRotationPivot;

		[Header("Components - Loaders")]
		[SerializeField]
		private PlayerAvaterResourceController resources;

		[Header("Components - Misc")]
		[SerializeField]
		private AvaterVanishEffect vanishEffect;

		[Header("Parameters")]
		[SerializeField]
		private float threshouldStopLookingDegree = 80f;

		[SerializeField]
		private float speedFetchHead = 5f;

		[SerializeField]
		private float speedFetchHand = 10f;

		[SerializeField]
		private bool emitEffectOnVanish = true;

		private bool _isHandRotateAvailable;

		private Transform _fetchHeadTarget;

		private Transform _fetchHandTarget;

		private Quaternion _headLookQuat;

		private Quaternion _handLookQuat;

		public Transform MessagePivot => messagePivot;

		public PlayerAvaterResourceController AvaterResources => resources;

		public bool IsSkipSmooth { get; set; }

		public bool EmitEffectOnVanish
		{
			get
			{
				return emitEffectOnVanish;
			}
			set
			{
				emitEffectOnVanish = value;
			}
		}

		protected override void Initialize()
		{
			_fetchHeadTarget = SingletonMonoBehaviour<PlayAreaManager>.Instance.HeadObject.NeckAnchor;
			resources.OnBeforeUnloadAvater.Where((Unit _) => EmitEffectOnVanish).Subscribe(delegate
			{
				EmitVanishEffect();
			});
			SingletonMonoBehaviour<GameInputManager>.Instance.OnChangeMainHand.Subscribe(delegate(VRDeviceDefine.HandType handType)
			{
				switch (handType)
				{
				case VRDeviceDefine.HandType.Left:
					_fetchHandTarget = SingletonMonoBehaviour<PlayAreaManager>.Instance.LeftHandObject.ThisTransform;
					break;
				case VRDeviceDefine.HandType.Right:
					_fetchHandTarget = SingletonMonoBehaviour<PlayAreaManager>.Instance.RightHandObject.ThisTransform;
					break;
				}
			}).AddTo(base.gameObject);
		}

		public override void OnUpdate(float delta)
		{
			UpdateHeadPivotTransform(delta);
			if (_isHandRotateAvailable)
			{
				UpdateHandPivotTransform(delta);
			}
		}

		private void UpdateHeadPivotTransform(float deltaTime)
		{
			Vector3 position = _fetchHeadTarget.position;
			Quaternion rotation = _fetchHeadTarget.rotation;
			positionPivot.position = position;
			float num = Mathf.DeltaAngle(90f, Vector3.SignedAngle(Vector3.up, rotation * Vector3.forward, rotation * Vector3.right));
			if (num < threshouldStopLookingDegree)
			{
				_headLookQuat = Quaternion.Euler(0f, (rotation * Quaternion.Euler(0f - num, 0f, 0f)).eulerAngles.y, 0f);
			}
			if (IsSkipSmooth)
			{
				headRotationPivot.rotation = _headLookQuat;
			}
			else
			{
				headRotationPivot.rotation = Quaternion.Slerp(headRotationPivot.rotation, _headLookQuat, speedFetchHead * deltaTime);
			}
		}

		private void UpdateHandPivotTransform(float deltaTime)
		{
			Quaternion rotation = _fetchHandTarget.rotation;
			float num = Mathf.DeltaAngle(90f, Vector3.SignedAngle(Vector3.up, rotation * Vector3.forward, rotation * Vector3.right));
			_handLookQuat = Quaternion.Euler(0f, (rotation * Quaternion.Euler(0f - num, 0f, 0f)).eulerAngles.y, 0f);
			if (IsSkipSmooth)
			{
				handRotationPivot.rotation = _handLookQuat;
			}
			else
			{
				handRotationPivot.rotation = Quaternion.Slerp(handRotationPivot.rotation, _handLookQuat, speedFetchHand * deltaTime);
			}
		}

		public void SetRotationEnabled(AvaterParts partType, AvaterTrackTypes trackType)
		{
			Transform parent = trackType switch
			{
				AvaterTrackTypes.NeckPosition => positionPivot, 
				AvaterTrackTypes.HeadPositionAndRotation => headRotationPivot, 
				AvaterTrackTypes.HandPositionAndRotation => handRotationPivot, 
				_ => SingletonMonoBehaviour<PlayAreaManager>.Instance.CameraAnchorTransform, 
			};
			switch (partType)
			{
			case AvaterParts.Body:
				bodyPivot.SetParent(parent, worldPositionStays: false);
				break;
			case AvaterParts.Hand:
				handPivot.SetParent(parent, worldPositionStays: false);
				_isHandRotateAvailable = trackType == AvaterTrackTypes.HandPositionAndRotation;
				break;
			}
		}

		public void SetRotationEnableWithFade(AvaterParts partType, AvaterTrackTypes trackType, float duration)
		{
			BaseAvaterObject avaterObjectByIndex = AvaterResources.GetAvaterObjectByIndex(partType);
			if ((object)avaterObjectByIndex == null)
			{
				return;
			}
			if (!avaterObjectByIndex.IsVisible)
			{
				SetRotationEnabled(partType, trackType);
				return;
			}
			StartAvaterFade(partType, IsFadeIn: false, duration, delegate
			{
				SetRotationEnabled(partType, trackType);
				StartAvaterFade(partType, IsFadeIn: true, duration);
			});
		}

		public void SetOutlineParameters(AvaterParts partType, CommandAvaterOutline command)
		{
			BaseAvaterObject obj = AvaterResources.GetAvaterObjectByIndex(partType);
			if ((object)obj == null)
			{
				return;
			}
			switch (command.FadeMode)
			{
			case FadeModes.Smooth:
				if (command.FlagChangeSize)
				{
					obj.StartSmoothOutlineSizeChange(command.FadeDuration, command.OutlineSize);
				}
				if (command.FlagChangeColor)
				{
					obj.StartSmoothOutlineColorChange(command.FadeDuration, command.OutlineColor);
				}
				break;
			case FadeModes.Dither:
				StartAvaterFade(partType, IsFadeIn: false, command.FadeDuration / 2f, delegate
				{
					if (command.FlagChangeSize)
					{
						obj.SetOutlineSize(command.OutlineSize);
					}
					if (command.FlagChangeColor)
					{
						obj.SetOutlineColor(command.OutlineColor);
					}
					StartAvaterFade(partType, IsFadeIn: true, command.FadeDuration / 2f);
				});
				break;
			default:
				if (command.FlagChangeSize)
				{
					obj.SetOutlineSize(command.OutlineSize);
				}
				if (command.FlagChangeColor)
				{
					obj.SetOutlineColor(command.OutlineColor);
				}
				break;
			}
		}

		public Coroutine StartAvaterFade(AvaterParts partType, bool IsFadeIn, float duration, Action onEnd = null)
		{
			BaseAvaterObject avaterObjectByIndex = AvaterResources.GetAvaterObjectByIndex(partType);
			if ((object)avaterObjectByIndex == null)
			{
				return null;
			}
			if (IsFadeIn)
			{
				return avaterObjectByIndex.StartFadeIn(duration, onEnd);
			}
			return avaterObjectByIndex.StartFadeOut(duration, onEnd);
		}

		public void EmitVanishEffect()
		{
			vanishEffect.StartVanishEffect();
		}

		public void ClearScquenceRelations()
		{
			SetRotationEnabled(AvaterParts.Body, AvaterTrackTypes.HeadPositionAndRotation);
			SetRotationEnabled(AvaterParts.Hand, AvaterTrackTypes.HeadPositionAndRotation);
			if (AvaterResources.HasBody)
			{
				AvaterResources.BodyObject.RevertToDefault();
			}
			if (AvaterResources.HasHand)
			{
				AvaterResources.HandObject.RevertToDefault();
			}
		}
	}
	public class PlayerAvaterResourceController : MonoBehaviour
	{
		protected const string FOLDER_SETTING_FORMAT = "Prefabs/Avaters/{0}/AvaterSetting{0}";

		[Header("Components - Loader")]
		[SerializeField]
		[EnumLabel(typeof(PlayerAvater.AvaterParts))]
		private BaseAvaterLoader[] _avaterLoaders;

		private DataAvaterSetting _currentSetting;

		private Material[] _avaterMaterials;

		private GameDefine.CharaID _currentCharaId;

		private GameDefine.CharaID _fadeNextCharaId;

		private AdvCharaTextureSettings _currentAvaterSetting;

		private Subject<Unit> _subjectBeforeUnloadAvater = new Subject<Unit>();

		private Subject<Unit> _subjectAfterAvaterLoaded = new Subject<Unit>();

		public bool IsBusyLoading { get; private set; }

		public bool IsBusyChangingFade { get; private set; }

		public bool HasBody => BodyLoader.AvaterObject != null;

		public AvaterBodyLoader BodyLoader => GetLoaderByIndex(PlayerAvater.AvaterParts.Body) as AvaterBodyLoader;

		public AvaterBodyObject BodyObject => GetAvaterObjectByIndex(PlayerAvater.AvaterParts.Body) as AvaterBodyObject;

		public AvaterHandLoader HandLoader => GetLoaderByIndex(PlayerAvater.AvaterParts.Hand) as AvaterHandLoader;

		public AvaterHandObject HandObject => GetAvaterObjectByIndex(PlayerAvater.AvaterParts.Hand) as AvaterHandObject;

		public bool HasHand => HandLoader.AvaterObject != null;

		public AvaterTrackedHandLoader TrackedHandLeftLoader => GetLoaderByIndex(PlayerAvater.AvaterParts.TrackedHandLeft) as AvaterTrackedHandLoader;

		public AvaterTrackedHandLoader TrackedHandRightLoader => GetLoaderByIndex(PlayerAvater.AvaterParts.TrackedHandRight) as AvaterTrackedHandLoader;

		public bool HasTrackedLeftHand => TrackedHandLeftLoader.AvaterObject != null;

		public bool HasTrackedRightHand => TrackedHandRightLoader.AvaterObject != null;

		public bool HasTrackedHands
		{
			get
			{
				if (!HasTrackedLeftHand)
				{
					return HasTrackedRightHand;
				}
				return true;
			}
		}

		public AvaterTrackedHandObject TrackedHandLeftObject => GetAvaterObjectByIndex(PlayerAvater.AvaterParts.TrackedHandLeft) as AvaterTrackedHandObject;

		public AvaterTrackedHandObject TrackedHandRightObject => GetAvaterObjectByIndex(PlayerAvater.AvaterParts.TrackedHandRight) as AvaterTrackedHandObject;

		public IObservable<Unit> OnBeforeUnloadAvater => _subjectBeforeUnloadAvater;

		public IObservable<Unit> OnAfterAvaterLoaded => _subjectAfterAvaterLoaded;

		public BaseAvaterLoader GetLoaderByIndex(PlayerAvater.AvaterParts index)
		{
			return _avaterLoaders[(int)index];
		}

		public BaseAvaterObject GetAvaterObjectByIndex(PlayerAvater.AvaterParts index)
		{
			return GetLoaderByIndex(index).AvaterObject;
		}

		private void Start()
		{
			SingletonMonoBehaviour<LocalData>.Instance.OnChangeCharacter.Subscribe(delegate(GameDefine.CharaID charaId)
			{
				ChangeCharacterWithFades(charaId);
			}).AddTo(base.gameObject);
			OnAfterAvaterLoaded.Subscribe(delegate
			{
				ApplyTextureSetting();
			});
		}

		private void ChangeCharacterWithFades(GameDefine.CharaID charaId)
		{
			_fadeNextCharaId = charaId;
			if (IsBusyChangingFade && !IsBusyLoading)
			{
				_subjectAfterAvaterLoaded.OnNext(Unit.Default);
			}
			else
			{
				StartCoroutine(CoroutineChangeChacater());
			}
		}

		private IEnumerator CoroutineChangeChacater()
		{
			yield return new WaitUntil(() => !IsBusyChangingFade);
			yield return new WaitUntil(() => !IsBusyLoading);
			IsBusyChangingFade = true;
			if (_currentSetting != null)
			{
				yield return StartCoroutine(CoroutineUnloadFade());
			}
			GameDefine.CharaID fadeNextCharaId = _fadeNextCharaId;
			if (fadeNextCharaId == GameDefine.CharaID.NONE || fadeNextCharaId == GameDefine.CharaID.UNKNOWN)
			{
				IsBusyChangingFade = false;
				_subjectAfterAvaterLoaded.OnNext(Unit.Default);
				yield break;
			}
			yield return StartCoroutine(CoroutineLoadAvater(fadeNextCharaId));
			_subjectAfterAvaterLoaded.OnNext(Unit.Default);
			yield return StartCoroutine(CoroutineFadeIn());
			IsBusyChangingFade = false;
		}

		private void ChangeCharacter(GameDefine.CharaID charaId)
		{
			if (charaId == GameDefine.CharaID.NONE || charaId == GameDefine.CharaID.UNKNOWN)
			{
				UnloadAvater();
			}
			else
			{
				LoadAvaterComponents(charaId);
			}
		}

		private void LoadAvaterComponents(GameDefine.CharaID charaId)
		{
			_ = IsBusyLoading;
			StartCoroutine(CoroutineLoadAvater(charaId));
		}

		private IEnumerator CoroutineLoadAvater(GameDefine.CharaID charaId)
		{
			yield return new WaitUntil(() => !IsBusyLoading);
			IsBusyLoading = true;
			yield return StartCoroutine(CoroutineLoadAvaterSetting(charaId));
			Queue<Coroutine> _pendings = new Queue<Coroutine>();
			for (int i = 0; i < _avaterLoaders.Length; i++)
			{
				BaseAvaterLoader baseAvaterLoader = _avaterLoaders[i];
				baseAvaterLoader.AvaterTypeMax = _currentSetting.MaxTypes[i];
				_pendings.Enqueue(baseAvaterLoader.LoadAvater(charaId));
			}
			while (_pendings.Count > 0)
			{
				yield return _pendings.Dequeue();
			}
			_currentCharaId = charaId;
			IsBusyLoading = false;
		}

		private IEnumerator CoroutineLoadAvaterSetting(GameDefine.CharaID charaId)
		{
			ResourceRequest request = Resources.LoadAsync<DataAvaterSetting>(string.Format("Prefabs/Avaters/{0}/AvaterSetting{0}", (int)charaId));
			yield return request;
			if (!(request.asset == null))
			{
				_currentSetting = request.asset as DataAvaterSetting;
			}
		}

		private void UnloadAvater()
		{
			int num = _avaterLoaders.Length;
			for (int i = 0; i < num; i++)
			{
				BaseAvaterLoader baseAvaterLoader = _avaterLoaders[i];
				if (baseAvaterLoader.IsLoaded)
				{
					baseAvaterLoader.DestroyAvater();
				}
			}
			_currentSetting = null;
		}

		private IEnumerator CoroutineUnloadFade()
		{
			yield return new WaitUntil(() => !IsBusyLoading);
			_subjectBeforeUnloadAvater.OnNext(Unit.Default);
			_currentCharaId = GameDefine.CharaID.NONE;
			int num = _avaterLoaders.Length;
			Queue<Coroutine> _pendings = new Queue<Coroutine>();
			for (int i = 0; i < num; i++)
			{
				BaseAvaterLoader loader = _avaterLoaders[i];
				if (loader.IsLoaded && !(loader.AvaterObject == null))
				{
					_pendings.Enqueue(loader.AvaterObject.StartFadeOut(delegate
					{
						loader.DestroyAvater();
					}));
				}
			}
			while (_pendings.Count > 0)
			{
				yield return _pendings.Dequeue();
			}
			_currentSetting = null;
		}

		private IEnumerator CoroutineFadeIn()
		{
			yield return new WaitUntil(() => !IsBusyLoading);
			int num = _avaterLoaders.Length;
			Queue<Coroutine> _pendings = new Queue<Coroutine>();
			for (int i = 0; i < num; i++)
			{
				BaseAvaterLoader baseAvaterLoader = _avaterLoaders[i];
				if (baseAvaterLoader.IsLoaded && baseAvaterLoader.IsFadeInOnNew)
				{
					_pendings.Enqueue(baseAvaterLoader.AvaterObject.StartFadeIn());
				}
			}
			while (_pendings.Count > 0)
			{
				yield return _pendings.Dequeue();
			}
		}

		public void SetTextureSetting(AdvCharaTextureSettings setting)
		{
			_currentAvaterSetting = setting;
			ApplyTextureSetting();
		}

		private void ApplyTextureSetting()
		{
			if (_currentAvaterSetting == null)
			{
				SetDefaultSettings();
				return;
			}
			AdvCharaTextureData.TextureType type = _currentAvaterSetting.FindExceptionSettings(_currentCharaId)?.Type ?? _currentAvaterSetting.CharaTextureType;
			ChangeTextureType(type, PlayerAvater.AvaterParts.Body);
			ChangeTextureType(type, PlayerAvater.AvaterParts.Hand);
			ChangeTextureType(type, PlayerAvater.AvaterParts.TrackedHandLeft);
			ChangeTextureType(type, PlayerAvater.AvaterParts.TrackedHandRight);
		}

		public void ChangeTextureType(AdvCharaTextureData.TextureType type, PlayerAvater.AvaterParts partType)
		{
			GetAvaterObjectByIndex(partType)?.ChangeTextureType(type);
		}

		private void SetDefaultSettings()
		{
			ChangeTextureType(AdvCharaTextureData.TextureType.Normal, PlayerAvater.AvaterParts.Body);
			ChangeTextureType(AdvCharaTextureData.TextureType.Normal, PlayerAvater.AvaterParts.Hand);
			ChangeTextureType(AdvCharaTextureData.TextureType.Normal, PlayerAvater.AvaterParts.TrackedHandLeft);
			ChangeTextureType(AdvCharaTextureData.TextureType.Normal, PlayerAvater.AvaterParts.TrackedHandRight);
		}
	}
	public class TrackedHandsComponent
	{
		public AvaterTrackedHandObject Left;

		public AvaterTrackedHandObject Right;
	}
	[RequireComponent(typeof(AdvCharaModel))]
	public class AdvChara : UpdateableComponent, IChara
	{
		[SerializeField]
		private GameDefine.CharaID m_id = GameDefine.CharaID.BASE;

		[SerializeField]
		private Transform m_headNode;

		[SerializeField]
		private Transform m_rightHandNode;

		[SerializeField]
		private Transform m_leftHandNode;

		[SerializeField]
		private GameObject m_boneRoot;

		[SerializeField]
		private List<AdvCharaOffCameraDisabler> m_disablers;

		[SerializeField]
		private string m_faceNodeName = "face";

		[SerializeField]
		private bool m_isDeactivateOnStart = true;

		public Vector3 NextPosition;

		private SpringManager m_springManager;

		private GenericLookTargetIK m_lookTarget;

		private GameObject m_gameObject;

		private GameObject m_headObject;

		private SkinnedMeshRenderer m_faceRenderer;

		private bool m_isAttached;

		private bool m_isForcusReserved;

		private Transform m_parent;

		private bool m_isVisible = true;

		private bool m_wasVisible;

		private bool m_isCheckDisabler;

		private DynamicProp[] m_propsAttached;

		public AdvCharaModel Model { get; private set; }

		public GenericLookTargetIK Look => m_lookTarget;

		public AdvCharaStyleChange StyleChange { get; private set; }

		public Transform Head => m_headNode;

		public Transform RightHand => m_rightHandNode;

		public Transform LeftHand => m_leftHandNode;

		public GameObject HeadObject => m_headObject;

		public GameObject BoneRoot => m_boneRoot;

		public GameDefine.CharaID ID => m_id;

		public SkinnedMeshRenderer FaceRenderer => m_faceRenderer;

		public Transform Transform { get; set; }

		public bool IsForcused { get; private set; }

		public bool IsRootBoneActive { get; private set; }

		public bool HasInitialLookAt { get; set; }

		public bool HasInitialMotion { get; set; }

		public bool HasInitialFacial { get; set; }

		protected override void Initialize()
		{
			m_wasVisible = m_isVisible;
			m_isAttached = false;
			m_gameObject = base.gameObject;
			m_headObject = m_headNode.gameObject;
			Transform = base.transform;
			m_parent = Transform.parent;
			IsForcused = true;
			ResetSaftyFlags();
			m_springManager = GetComponent<SpringManager>();
			m_lookTarget = GetComponent<GenericLookTargetIK>();
			InitializeProps();
			m_isCheckDisabler = m_disablers != null && m_disablers.Count > 0;
		}

		private void InitializeProps()
		{
			m_propsAttached = new DynamicProp[3];
			ResetProps();
		}

		private void ResetProps()
		{
			int num = m_propsAttached.Length;
			for (int i = 0; i < num; i++)
			{
				m_propsAttached[i] = null;
			}
		}

		public void Destroy()
		{
			if (m_gameObject != null)
			{
				UnityEngine.Object.Destroy(m_gameObject);
				m_gameObject = null;
			}
		}

		public override void OnUpdate(float delta)
		{
			if (m_isDeactivateOnStart)
			{
				Disable();
				m_isDeactivateOnStart = false;
				base.IsActive = false;
				SetRootBoneActive(isActive: false);
			}
			else if (m_isForcusReserved)
			{
				m_isForcusReserved = false;
				SetForcusedComponentActive(IsForcused);
			}
		}

		private void UpdateVisible()
		{
			if (!m_isCheckDisabler)
			{
				return;
			}
			bool flag = false;
			int count = m_disablers.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_disablers[i].IsVisible)
				{
					flag = true;
					break;
				}
			}
			if (flag != m_wasVisible)
			{
				m_disablers[0].SetEnables(flag);
			}
			m_wasVisible = flag;
		}

		public void SetVisible(bool isVisible)
		{
			m_isVisible |= isVisible;
		}

		public void Setup(GameDefine.CharaID id)
		{
			m_id = id;
			Transform = base.transform;
			StyleChange = GetComponent<AdvCharaStyleChange>();
			Model = GetComponent<AdvCharaModel>();
			Model.Setup(this);
			Transform transform = Transform.FindDeep(m_faceNodeName);
			m_faceRenderer = transform.GetComponent<SkinnedMeshRenderer>();
		}

		public void SetupNodes()
		{
		}

		public Transform GetNode(AdvCharaModel.Node node)
		{
			return node switch
			{
				AdvCharaModel.Node.Head => Head, 
				AdvCharaModel.Node.RightHand => RightHand, 
				AdvCharaModel.Node.LeftHand => LeftHand, 
				_ => Head, 
			};
		}

		public void Enable()
		{
			SetEnable(isEnable: true);
		}

		public void Disable()
		{
			SetEnable(isEnable: false);
		}

		public void SetEnable(bool isEnable)
		{
			m_isActive = isEnable;
			m_gameObject.SetActive(isEnable);
			m_wasVisible = isEnable;
			m_isVisible = isEnable;
		}

		public void AttachTo(Transform target, Vector3 offset, Vector3 rotation, Vector3 scale)
		{
			Transform.SetParent(target, worldPositionStays: false);
			Transform.localPosition = offset;
			Transform.localRotation = Quaternion.Euler(rotation);
			Transform.localScale = scale;
			m_isAttached = true;
		}

		public void Detach()
		{
			if (m_isAttached)
			{
				m_isAttached = false;
				Transform.SetParent(m_parent, worldPositionStays: false);
				Transform.localScale = Vector3.one;
			}
		}

		public void AttachMirroring(Vector3 scale, bool isMirroring, bool isTrackingHead)
		{
			if (!m_isAttached)
			{
				if (m_springManager != null)
				{
					m_springManager.enabled = !isMirroring;
				}
				Transform.localScale = scale;
				if (isMirroring && m_lookTarget != null)
				{
					m_lookTarget.IsPlayerMirrorAttach = isTrackingHead;
				}
				else
				{
					m_lookTarget.IsPlayerMirrorAttach = false;
				}
			}
		}

		public void DetachMirroring()
		{
			if (!m_isAttached)
			{
				Transform.localScale = Vector3.one;
				if (m_lookTarget != null)
				{
					m_lookTarget.IsPlayerMirrorAttach = false;
				}
				if (m_springManager != null)
				{
					m_springManager.enabled = true;
				}
			}
		}

		private void ResetSaftyFlags()
		{
			HasInitialLookAt = false;
			HasInitialMotion = false;
			HasInitialFacial = false;
		}

		public void OnEndSequence()
		{
			ResetSaftyFlags();
			if (!(m_gameObject == null))
			{
				if (m_lookTarget != null)
				{
					SetEnable(isEnable: true);
					SetForcus(isForcus: true);
					m_lookTarget.SetLookAtTransform(null, isSkip: true);
					m_lookTarget.UpdateLookAtProcess();
					m_lookTarget.IsUpdate = false;
					SetEnable(isEnable: false);
				}
				if (StyleChange != null)
				{
					StyleChange.CharaStyleChange(style: false);
				}
				OnNonForccus();
				DetachMirroring();
				Detach();
				Model.OnEndSequence();
				Disable();
			}
		}

		public void OnPlayVoice()
		{
			if (SingletonMonoBehaviour<CharactersManager>.Instance.IsLimitAnimatableChara && !IsForcused)
			{
				ReserveForcus(isForcusd: true);
			}
		}

		public void OnNonForccus()
		{
			if (SingletonMonoBehaviour<CharactersManager>.Instance.IsLimitAnimatableChara && IsForcused)
			{
				if (!base.Object.activeSelf)
				{
					IsForcused = false;
					return;
				}
				ReserveForcus(isForcusd: false);
				Model.SkipAnimation();
			}
		}

		public void ReserveForcus(bool isForcusd)
		{
			m_isForcusReserved = true;
			IsForcused = isForcusd;
		}

		private void SetForcusedComponentActive(bool isActive)
		{
			Model.Animator.enabled = isActive;
			if (m_springManager != null)
			{
				m_springManager.enabled = isActive;
			}
			if (m_lookTarget != null)
			{
				m_lookTarget.IsAnimatorEnable = isActive;
			}
		}

		public void SetForcus(bool isForcus)
		{
			IsForcused = isForcus;
			SetForcusedComponentActive(isForcus);
		}

		public void SetRootBoneActive(bool isActive)
		{
			IsRootBoneActive = isActive;
			if (m_boneRoot != null)
			{
				m_boneRoot.SetActive(isActive);
			}
		}

		public void OnAttachProp(DynamicProp prop, AdvCharaModel.Node node)
		{
			m_propsAttached[(int)node] = prop;
			SetRootBoneActive(isActive: true);
		}

		public void OnDettachProp(DynamicProp prop, AdvCharaModel.Node node)
		{
			if (m_propsAttached[(int)node] == prop)
			{
				m_propsAttached[(int)node] = null;
			}
			CheckDisableBoneRoot();
		}

		private void CheckDisableBoneRoot()
		{
			int num = m_propsAttached.Length;
			for (int i = 0; i < num; i++)
			{
				if (m_propsAttached[i] != null)
				{
					return;
				}
			}
			SetRootBoneActive(isActive: false);
		}

		public void ApplySafetySettings()
		{
			if (base.IsActive)
			{
				if (!HasInitialMotion)
				{
					Model.PlayAnimation(100, isFade: false, !HasInitialFacial);
				}
				if (!HasInitialFacial && !GameDefine.IsShadow(ID))
				{
					Model.PlayAnimation(300, isFade: false, !HasInitialMotion);
				}
				if (!HasInitialLookAt && Look != null)
				{
					Look.SetLookAtTransform(null, isSkip: true);
					Look.BodyLookAtTrigger = true;
					Look.UpdateLookAtProcess();
				}
				else if (Look != null)
				{
					Look.BodyLookAtTrigger = true;
					Look.UpdateLookAtProcess();
				}
			}
		}
	}
	public class AdvCharaAnimation
	{
		public const int _INVALID_LAYER_ID = -1;

		public const string _PARAM_ID_STRING = "motion";

		public const string _PARAM_START_ANIMATION_STRING = "motionTrigger";

		public const string _PARAM_FACE_ID_STRING = "faceNo";

		public const string _PARAM_START_FACE_ANIMATION_STRING = "facialTrigger";

		private const string _LAYER_BASE = "Base Layer";

		private const string _LAYER_FACIAL = "Facial Layer";

		private const string _LAYER_HAIR = "Hair Layer";

		private Animator m_animator;

		private Transform m_transform;

		private int m_idParamIndex;

		private int m_startAnimationParamIndex;

		private int m_faceidParamIndex;

		private int m_faceStartAnimationParamIndex;

		private int m_layerFacial;

		private int m_layerHair;

		public int CurrentID { get; private set; }

		public AdvCharaAnimation(Animator animator, Transform transform)
		{
			CurrentID = 0;
			m_animator = animator;
			m_transform = transform;
			m_idParamIndex = Animator.StringToHash("motion");
			m_startAnimationParamIndex = Animator.StringToHash("motionTrigger");
			m_faceidParamIndex = Animator.StringToHash("faceNo");
			m_faceStartAnimationParamIndex = Animator.StringToHash("facialTrigger");
			m_layerFacial = m_animator.GetLayerIndex("Facial Layer");
			m_layerHair = m_animator.GetLayerIndex("Hair Layer");
			m_animator.keepAnimatorControllerStateOnDisable = true;
		}

		public void PlayAnimation(int id, bool isSkip = false)
		{
			CurrentID = id;
			if (IsFacialAnimation(id))
			{
				PlayFacialAnimation(id);
			}
			else
			{
				PlayBaseAnimation(id);
			}
			if (isSkip)
			{
				SkipAnimation();
			}
		}

		public static bool IsFacialAnimation(int id)
		{
			if (id >= 300)
			{
				return id < 400;
			}
			return false;
		}

		private void PlayFacialAnimation(int id)
		{
			m_animator.SetInteger(m_faceidParamIndex, id);
			m_animator.SetTrigger(m_faceStartAnimationParamIndex);
		}

		private void PlayBaseAnimation(int id)
		{
			m_animator.SetInteger(m_idParamIndex, id);
			m_animator.SetTrigger(m_startAnimationParamIndex);
			m_transform.localPosition = Vector3.zero;
			m_transform.localRotation = Quaternion.identity;
		}

		public void SkipAnimation()
		{
			if (m_animator.gameObject.activeInHierarchy)
			{
				m_animator.Update(100f);
				m_animator.Update(100f);
			}
			if (!IsInvalidLayer(m_layerHair))
			{
				ForceSkipLayerAnimation(m_layerHair);
				ForceSkipLayerAnimation(m_layerFacial);
			}
		}

		private void ForceSkipLayerAnimation(int layer)
		{
			AnimatorStateInfo currentAnimatorStateInfo = m_animator.GetCurrentAnimatorStateInfo(layer);
			m_animator.Play(currentAnimatorStateInfo.shortNameHash, layer, 0f);
		}

		private bool IsInvalidLayer(int layerID)
		{
			return layerID == -1;
		}

		public void PlayFacialAnimationWithAnimatorUpdate(string animationName)
		{
			m_animator.Play(animationName, m_layerFacial, 1f);
			SkipAnimation();
		}

		public void PlayAnimationWithAnimatorUpdate(string animationName)
		{
			m_transform.localPosition = Vector3.zero;
			m_transform.localRotation = Quaternion.identity;
			m_animator.Play(animationName, 0, 1f);
			SkipAnimation();
		}
	}
	public class AdvCharaHairControll : MonoBehaviour
	{
		private const string ANIMATION_MOTION_STR = "motion";

		protected int[] NkOmitMotionList = new int[2] { 143, 159 };

		[SerializeField]
		private Transform BodyTransform;

		[SerializeField]
		private Transform HeadTransform;

		[SerializeField]
		private Transform[] HairCenterTransforms;

		[SerializeField]
		private Transform[] HairRightTransforms;

		[SerializeField]
		private Transform[] HairLeftTransforms;

		private Vector3[] LastHairCenterRotation;

		private Vector3[] LastHairRightRotation;

		private Vector3[] LastHairLeftRotation;

		protected AdvChara Chara;

		[SerializeField]
		private float limitRotate;

		[SerializeField]
		private float[] aditionalValues;

		private float defaultBodyRotation;

		private void Start()
		{
			Chara = GetComponent<AdvChara>();
			_ = base.transform.forward;
			Vector3 forward = BodyTransform.forward;
			forward = base.transform.InverseTransformDirection(forward);
			Vector3Extension.Normalize(ref forward);
			defaultBodyRotation = Mathf.Atan2(x: new Vector2(forward.x, forward.z).Length(), y: forward.y) * 57.29578f;
			if (HairCenterTransforms != null)
			{
				LastHairCenterRotation = new Vector3[HairCenterTransforms.Length];
				for (int i = 0; i < HairCenterTransforms.Length; i++)
				{
					LastHairCenterRotation[i] = HairCenterTransforms[i].localRotation.eulerAngles;
				}
			}
			if (HairRightTransforms != null)
			{
				LastHairRightRotation = new Vector3[HairRightTransforms.Length];
				for (int j = 0; j < HairRightTransforms.Length; j++)
				{
					LastHairRightRotation[j] = HairRightTransforms[j].localRotation.eulerAngles;
				}
			}
			if (HairLeftTransforms != null)
			{
				LastHairLeftRotation = new Vector3[HairLeftTransforms.Length];
				for (int k = 0; k < HairLeftTransforms.Length; k++)
				{
					LastHairLeftRotation[k] = HairLeftTransforms[k].localRotation.eulerAngles;
				}
			}
		}

		public void SupportHairControll(bool isAnim)
		{
			if (CheckNkMotion())
			{
				return;
			}
			_ = BodyTransform.forward;
			Vector3 forward = HeadTransform.forward;
			forward = BodyTransform.InverseTransformDirection(forward);
			Vector3Extension.Normalize(ref forward);
			float num = Mathf.Atan2(x: new Vector2(forward.x, forward.z).Length(), y: forward.y) * 57.29578f;
			float num2 = Mathf.Atan2(forward.x, forward.z) * 57.29578f;
			num /= 2.5f;
			num2 /= 6f;
			if (HairCenterTransforms != null)
			{
				for (int i = 0; i < HairCenterTransforms.Length; i++)
				{
					Vector3 vector = LastHairCenterRotation[i];
					HairCenterTransforms[i].localRotation = Quaternion.Euler(vector.x - num / (float)(i + 1) - defaultBodyRotation, vector.y, vector.z);
				}
			}
			if (HairRightTransforms != null)
			{
				for (int j = 0; j < HairRightTransforms.Length; j++)
				{
					Vector3 vector2 = LastHairRightRotation[j];
					HairRightTransforms[j].localRotation = Quaternion.Euler(vector2.x + (0f - num + num2) / (float)(j + 1) - defaultBodyRotation, vector2.y, vector2.z);
				}
			}
			if (HairLeftTransforms != null)
			{
				for (int k = 0; k < HairLeftTransforms.Length; k++)
				{
					Vector3 vector3 = LastHairLeftRotation[k];
					HairLeftTransforms[k].localRotation = Quaternion.Euler(vector3.x + (0f - num - num2) / (float)(k + 1) - defaultBodyRotation, vector3.y, vector3.z);
				}
			}
		}

		private bool CheckNkMotion()
		{
			if (Chara.ID != GameDefine.CharaID.NIKAIDOU)
			{
				return false;
			}
			int integer = Chara.Model.Animator.GetInteger("motion");
			for (int i = 0; i < NkOmitMotionList.Length; i++)
			{
				if (NkOmitMotionList[i] == integer)
				{
					return true;
				}
			}
			return false;
		}
	}
	[CreateAssetMenu(menuName = "Chronos/Create LookAt Morpth TargetData", fileName = "LookAtMorpthTargets")]
	public class AdvCharaLookAtMorpthTargetData : ScriptableObject
	{
		[Serializable]
		public class Data
		{
			public GameDefine.CharaID Chara;

			public int[] MorpthTargetIndex;
		}

		public Data[] DataList;

		public Data FindData(GameDefine.CharaID chara)
		{
			int num = DataList.Length;
			for (int i = 0; i < num; i++)
			{
				if (DataList[i].Chara == chara)
				{
					return DataList[i];
				}
			}
			return null;
		}
	}
	public class AdvCharaModel : UpdateableComponent
	{
		public enum AnimationMode
		{
			Pause,
			Action,
			None
		}

		public enum Node
		{
			Head,
			RightHand,
			LeftHand,
			Count
		}

		public const int _DEFAULT_MOTION_ID = 100;

		public const int _DEFAULT_FACIAL_ID = 300;

		public const float _DEFAULT_ALPHA = 0.2f;

		public const float _FADE_DURATION = 0.3f;

		public const float _OUTLINE_DURATION = 0.2f;

		public const float _MAX_FADE_ALPHA = 1f;

		public const float _MIN_FADE_ALPHA = 0.3f;

		protected const string _PARAM_ALPHA = "_Alpha";

		protected const string _PARAM_OUTLINE_SIZE = "_Outline";

		protected const string _PARAM_OUTLINE_COLOR = "_OutlineColor";

		private const int _HAIR_WAIT_FRAMES = 2;

		[SerializeField]
		private List<AdvCharaTextureData> m_textures;

		protected List<Material> m_originalMaterials = new List<Material>();

		protected List<Material> m_materials = new List<Material>();

		protected Tweener<float> m_alphaTweener;

		protected Tweener<float> m_threasholdTweener;

		protected Tweener<Color> m_ColorTweener;

		private Renderer[] m_renderers;

		private AdvCharaTextureData.TextureType m_currentTextureType;

		protected AdvCharaAnimation m_animation;

		protected GenericLookTargetIK m_lookTarget;

		protected AdvChara m_chara;

		protected float m_actionFadeDuration;

		protected float m_actionTargetAlpha;

		protected float m_actionStartAlpha;

		protected int m_actionID;

		protected bool m_actionFlag;

		protected Color m_actionColour;

		private Action m_onStartFadeEnd;

		private Action m_onEndFade;

		protected Action m_onAnimationWithFadeEndAction;

		protected Action m_onPingpongFadeStartEndAction;

		private Action m_onOutlineChangeColourFadeEnd;

		private Action m_onOutlineChangeSizeFadeEnd;

		private Action m_onOutlineChangeAllFadeEnd;

		private Action<long> m_onSkipHairUpdate;

		public Animator Animator { get; private set; }

		public bool IsFading => m_alphaTweener.IsActive;

		public bool IsOutlineSizeChanging => m_threasholdTweener.IsActive;

		public bool IsOutlineColorChanging => m_ColorTweener.IsActive;

		public int CurrentAnimationID => m_animation.CurrentID;

		public void Setup(AdvChara chara)
		{
			m_renderers = GetComponentsInChildren<Renderer>();
			AddMaterials(m_renderers);
			GetAdditionalMaterials();
			m_lookTarget = GetComponent<GenericLookTargetIK>();
			Transform child = base.transform.GetChild(0);
			Animator = child.GetComponent<Animator>();
			m_animation = new AdvCharaAnimation(Animator, child);
			m_alphaTweener = new Tweener<float>(Mathf.Lerp);
			m_threasholdTweener = new Tweener<float>(Mathf.Lerp);
			m_ColorTweener = new Tweener<Color>(Color.Lerp);
			m_chara = chara;
			InitializeActions();
			SetModelAlpha(0.3f);
		}

		private void InitializeActions()
		{
			CreateAnimationWithFadeAction();
			CreatePingpongFadeStartEndAction();
			m_onOutlineChangeColourFadeEnd = delegate
			{
				ChangeOutlineColourFromAction();
			};
			m_onOutlineChangeSizeFadeEnd = delegate
			{
				ChangeOutlineSizeFromAction();
			};
			m_onOutlineChangeAllFadeEnd = delegate
			{
				ChangeOutlineAllFromAction();
			};
			m_onSkipHairUpdate = delegate
			{
				m_lookTarget.UpdateLookAtProcess();
			};
		}

		protected virtual void CreateAnimationWithFadeAction()
		{
			m_onAnimationWithFadeEndAction = delegate
			{
				EnableAnimatorForFrame();
				PlayAnimationFromAction();
				StartFadeFromAction();
				SkipAnimationOnNonForcus();
			};
		}

		protected virtual void CreatePingpongFadeStartEndAction()
		{
			m_onPingpongFadeStartEndAction = delegate
			{
				PlayOnStartFadeEndAction();
				StartReverseAlphaTweenFromAction();
			};
		}

		private void PlayOnStartFadeEndAction()
		{
			if (m_onStartFadeEnd != null)
			{
				m_onStartFadeEnd();
				m_onStartFadeEnd = null;
			}
		}

		private void StartAlphaTweenFromAction()
		{
			m_alphaTweener.Start(1f, 0.3f, m_actionFadeDuration, m_onEndFade);
		}

		private void StartReverseAlphaTweenFromAction()
		{
			m_alphaTweener.Start(0.3f, 1f, m_actionFadeDuration, m_onEndFade);
		}

		private void ChangeOutlineColourFromAction()
		{
			StartOutlineColorChange(m_actionColour, 0f);
			StartFade(m_actionTargetAlpha, m_actionFadeDuration);
		}

		private void ChangeOutlineSizeFromAction()
		{
			StartOutlineSizeChange(m_actionStartAlpha, 0f);
			StartFade(m_actionTargetAlpha, m_actionFadeDuration);
		}

		private void ChangeOutlineAllFromAction()
		{
			StartOutlineColorChange(m_actionColour, 0f);
			StartOutlineSizeChange(m_actionStartAlpha, 0f);
			StartFade(m_actionTargetAlpha, m_actionFadeDuration);
		}

		private void PlayAnimationFromAction()
		{
			m_animation.PlayAnimation(m_actionID, m_actionFlag);
		}

		private void StartFadeFromAction()
		{
			StartFade(m_actionTargetAlpha, m_actionFadeDuration);
		}

		private void AddMaterials(Renderer[] renderers)
		{
			foreach (Renderer renderer in renderers)
			{
				Material[] sharedMaterials = renderer.sharedMaterials;
				Material[] array = new Material[sharedMaterials.Length];
				for (int j = 0; j < sharedMaterials.Length; j++)
				{
					Material material = sharedMaterials[j];
					int num = m_originalMaterials.IndexOf(material);
					Material material2 = null;
					if (num < 0)
					{
						m_originalMaterials.Add(material);
						material2 = new Material(material);
						m_materials.Add(material2);
					}
					else
					{
						material2 = m_materials[num];
					}
					array[j] = material2;
				}
				renderer.sharedMaterials = array;
			}
		}

		protected virtual void GetAdditionalMaterials()
		{
		}

		public override void OnUpdate(float delta)
		{
			if (m_alphaTweener.IsActive)
			{
				m_alphaTweener.Update(delta);
				SetModelAlpha(m_alphaTweener.CurrentValue);
			}
			if (m_ColorTweener.IsActive)
			{
				m_ColorTweener.Update(delta);
				SetModelOutlineColor(m_ColorTweener.CurrentValue);
			}
			if (m_threasholdTweener.IsActive)
			{
				m_threasholdTweener.Update(delta);
				SetModelOutlineSize(m_threasholdTweener.CurrentValue);
			}
		}

		public virtual void SetModelAlpha(float alpha)
		{
			int count = m_materials.Count;
			for (int i = 0; i < count; i++)
			{
				m_materials[i].SetFloat("_Alpha", alpha);
			}
		}

		public virtual void SetModelOutlineSize(float size)
		{
			int count = m_materials.Count;
			for (int i = 0; i < count; i++)
			{
				m_materials[i].SetFloat("_Outline", size);
			}
		}

		public virtual void SetModelOutlineColor(Color color)
		{
			int count = m_materials.Count;
			for (int i = 0; i < count; i++)
			{
				m_materials[i].SetColor("_OutlineColor", color);
			}
		}

		public virtual void StartFade(float targetAlpha, float duration = 0.3f, Action onTweenEnd = null)
		{
			if (IsFading)
			{
				m_alphaTweener.AddAction(onTweenEnd);
			}
			else if (duration <= 0f)
			{
				m_alphaTweener.SetCurrentValue(targetAlpha);
				SetModelAlpha(targetAlpha);
				onTweenEnd?.Invoke();
			}
			else
			{
				m_alphaTweener.Start(m_materials[0].GetFloat("_Alpha"), targetAlpha, duration, onTweenEnd);
				SetModelAlpha(m_alphaTweener.CurrentValue);
			}
		}

		public void StartOutlineColorChange(Color targetColor, float duration = 0.2f, Action onTweenEnd = null)
		{
			if (IsOutlineColorChanging)
			{
				m_ColorTweener.AddAction(onTweenEnd);
			}
			else if (duration <= 0f)
			{
				SetModelOutlineColor(targetColor);
				onTweenEnd?.Invoke();
			}
			else
			{
				m_ColorTweener.Start(m_materials[0].GetColor("_OutlineColor"), targetColor, duration, onTweenEnd);
				SetModelOutlineColor(m_ColorTweener.CurrentValue);
			}
		}

		public void StartOutlineSizeChange(float targetSize, float duration = 0.2f, Action onTweenEnd = null)
		{
			if (IsOutlineSizeChanging)
			{
				m_threasholdTweener.AddAction(onTweenEnd);
			}
			else if (duration <= 0f)
			{
				SetModelOutlineSize(targetSize);
				onTweenEnd?.Invoke();
			}
			else
			{
				m_threasholdTweener.Start(m_materials[0].GetFloat("_Outline"), targetSize, duration, onTweenEnd);
				SetModelOutlineSize(m_threasholdTweener.CurrentValue);
			}
		}

		public void StartOutlineChangeWithFade(Color targetColor, float targetAlpha = 0.2f, float duration = 0.3f)
		{
			m_actionTargetAlpha = 1f;
			m_actionFadeDuration = duration;
			m_actionColour = targetColor;
			StartFade(targetAlpha, duration, m_onOutlineChangeColourFadeEnd);
		}

		public void StartOutlineChangeWithFade(float targetSize, float targetAlpha = 0.2f, float duration = 0.3f)
		{
			m_actionStartAlpha = targetSize;
			m_actionTargetAlpha = 1f;
			m_actionFadeDuration = duration;
			StartFade(targetAlpha, duration, m_onOutlineChangeSizeFadeEnd);
		}

		public void StartOutlineChangeWithFade(Color targetColor, float targetSize, float targetAlpha = 0.2f, float duration = 0.3f)
		{
			m_actionStartAlpha = targetSize;
			m_actionTargetAlpha = 1f;
			m_actionColour = targetColor;
			m_actionFadeDuration = duration;
			StartFade(targetAlpha, duration, m_onOutlineChangeAllFadeEnd);
		}

		public void PlayPingPongFade(float targetAlpha, float duration = 0.3f, Action onStartFadeEnd = null, Action onFadeEnd = null)
		{
			PlayPingPongFade(m_alphaTweener.CurrentValue, targetAlpha, duration, onStartFadeEnd, onFadeEnd);
		}

		public void PlayPingPongFade(float startAlpha, float targetAlpha, float duration = 0.3f, Action onStartFadeEnd = null, Action onFadeEnd = null)
		{
			if (IsFading)
			{
				m_alphaTweener.AddAction(onStartFadeEnd);
				return;
			}
			m_actionStartAlpha = startAlpha;
			m_actionTargetAlpha = targetAlpha;
			m_actionFadeDuration = duration;
			m_onStartFadeEnd = onStartFadeEnd;
			m_onEndFade = onFadeEnd;
			m_alphaTweener.Start(startAlpha, targetAlpha, duration, m_onPingpongFadeStartEndAction);
			SetModelAlpha(m_alphaTweener.CurrentValue);
		}

		public virtual void PlayAnimation(int id, bool isFade, bool isSkipAnimation)
		{
			if (isFade)
			{
				PlayAnimationWithFade(id, isSkipAnimation);
				return;
			}
			EnableAnimatorForFrame();
			m_animation.PlayAnimation(id, isSkipAnimation);
			SkipAnimationOnNonForcus();
		}

		public virtual void PlayAnimationWithFade(int id, bool isSkipAnimation, float targetAlpha = 0.2f, float duration = 0.3f)
		{
			m_actionFlag = isSkipAnimation;
			m_actionID = id;
			m_actionFadeDuration = duration;
			m_actionTargetAlpha = 1f;
			StartFade(targetAlpha, duration, m_onAnimationWithFadeEndAction);
		}

		public void EnableAnimatorForFrame()
		{
			if (!m_chara.IsForcused)
			{
				m_chara.ReserveForcus(isForcusd: false);
				Animator.enabled = true;
			}
		}

		public void SkipAnimationOnNonForcus()
		{
			if (m_chara.IsForcused)
			{
				return;
			}
			m_animation.SkipAnimation();
			if (!(m_lookTarget == null))
			{
				if (m_lookTarget.HasHair)
				{
					Observable.TimerFrame(2).Subscribe(m_onSkipHairUpdate);
				}
				m_lookTarget.BodyLookAtTrigger = true;
			}
		}

		public void Hide()
		{
			SetRenderEnable(isEnable: false);
			base.IsActive = false;
		}

		public void Show()
		{
			SetRenderEnable(isEnable: true);
			base.IsActive = true;
		}

		public void SetRenderEnable(bool isEnable)
		{
			int num = m_renderers.Length;
			for (int i = 0; i < num; i++)
			{
				m_renderers[i].enabled = isEnable;
			}
		}

		public void SkipAnimation()
		{
			m_animation.SkipAnimation();
		}

		public void OnEndSequence()
		{
			SetModelOutlineSize(0.1f);
			SetModelOutlineColor(ColorDefine.OutlineDay);
		}

		public void SetTexture(AdvCharaTextureData.TextureType type)
		{
			if (m_textures != null && m_materials != null && type != m_currentTextureType)
			{
				Texture texture = FindTexture(type);
				if (!(texture == null))
				{
					SetTextureToMaterials(texture);
					m_currentTextureType = type;
				}
			}
		}

		private Texture FindTexture(AdvCharaTextureData.TextureType type)
		{
			int count = m_textures.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_textures[i].Type == type)
				{
					return m_textures[i].Texture;
				}
			}
			return null;
		}

		private void SetTextureToMaterials(Texture texture)
		{
			m_materials.ForEach(delegate(Material material)
			{
				material.mainTexture = texture;
			});
		}
	}
	public class AdvCharaModelPatty : AdvCharaModel
	{
		[SerializeField]
		private GameObject m_bodyObject;

		[SerializeField]
		private GameObject m_pattyObject;

		private Material m_bodyMaterial;

		private Material m_pattyMaterial;

		private int[] pattyShowMotionList = new int[21]
		{
			102, 104, 109, 114, 115, 119, 120, 121, 122, 123,
			126, 127, 128, 134, 138, 139, 140, 141, 153, 154,
			155
		};

		public const float _FADE_PATTY_DURATION = 0.05f;

		protected override void GetAdditionalMaterials()
		{
			m_bodyMaterial = m_bodyObject.GetComponent<SkinnedMeshRenderer>().sharedMaterial;
			m_pattyMaterial = m_pattyObject.GetComponent<SkinnedMeshRenderer>().sharedMaterial;
		}

		protected override void CreateAnimationWithFadeAction()
		{
			m_onAnimationWithFadeEndAction = delegate
			{
				if (!m_chara.IsForcused)
				{
					m_chara.ReserveForcus(isForcusd: false);
					base.Animator.enabled = true;
				}
				m_animation.PlayAnimation(m_actionID, m_actionFlag);
				SetPattyEnable(m_actionID);
				StartFade(1f, m_actionID, m_actionFadeDuration);
				if (!m_chara.IsForcused)
				{
					m_animation.SkipAnimation();
					m_lookTarget.BodyLookAtTrigger = true;
				}
			};
		}

		public void StartPattyFade(float targetAlpha, float duration = 0.05f, Action onTweenEnd = null)
		{
			if (base.IsFading)
			{
				m_alphaTweener.AddAction(onTweenEnd);
				return;
			}
			m_alphaTweener.Start(m_pattyMaterial.GetFloat("_Alpha"), targetAlpha, duration, onTweenEnd);
			SetModelAlpha(m_alphaTweener.CurrentValue);
		}

		public void SetPattyModelAlpha(float alpha)
		{
			m_pattyMaterial.SetFloat("_Alpha", alpha);
		}

		public override void PlayAnimation(int id, bool isFade, bool isSkipAnimation)
		{
			if (isFade)
			{
				PlayAnimationWithFade(id, isSkipAnimation);
				return;
			}
			SetPattyEnable(id);
			m_animation.PlayAnimation(id, isSkipAnimation);
		}

		public override void PlayAnimationWithFade(int id, bool isSkipAnimation, float targetAlpha = 0.2f, float duration = 0.3f)
		{
			m_actionFlag = isSkipAnimation;
			m_actionID = id;
			m_actionFadeDuration = duration;
			m_actionTargetAlpha = 1f;
			StartFade(targetAlpha, id, duration, m_onAnimationWithFadeEndAction);
		}

		public void StartFade(float targetAlpha, int id, float duration = 0.3f, Action onTweenEnd = null)
		{
			if (base.IsFading)
			{
				m_alphaTweener.AddAction(onTweenEnd);
			}
			else if (duration <= 0f)
			{
				SetModelAlpha(targetAlpha);
				onTweenEnd?.Invoke();
			}
			else
			{
				m_alphaTweener.Start(m_bodyMaterial.GetFloat("_Alpha"), targetAlpha, duration, onTweenEnd);
				SetModelAlpha(m_alphaTweener.CurrentValue, id);
			}
		}

		public void SetModelAlpha(float alpha, int id)
		{
			int count = m_materials.Count;
			for (int i = 0; i < count; i++)
			{
				m_materials[i].SetFloat("_Alpha", alpha);
			}
			SetPattyEnable(id);
		}

		private void SetPattyEnable(int id)
		{
			if (id < 300 || id >= 400)
			{
				bool flag = CheckPattyEnable(id);
				if (flag)
				{
					SetPattyModelAlpha(m_bodyMaterial.GetFloat("_Alpha"));
				}
				else
				{
					SetPattyModelAlpha(0f);
				}
				m_pattyObject.SetActive(flag);
			}
		}

		private bool CheckPattyEnable(int id)
		{
			int num = pattyShowMotionList.Length;
			for (int i = 0; i < num; i++)
			{
				if (id == pattyShowMotionList[i])
				{
					return true;
				}
			}
			return false;
		}
	}
	[CreateAssetMenu(menuName = "Chronos/Create Morpth TargetData", fileName = "MorpthTargets")]
	public class AdvCharaMorpthTargetData : ScriptableObject
	{
		[Serializable]
		public class Data
		{
			public GameDefine.CharaID Chara;

			public int[] MorpthTargetIndex;
		}

		public Data[] DataList;

		public Data FindData(GameDefine.CharaID chara)
		{
			int num = DataList.Length;
			for (int i = 0; i < num; i++)
			{
				if (DataList[i].Chara == chara)
				{
					return DataList[i];
				}
			}
			return null;
		}
	}
	public class AdvCharaOffCameraDisabler : MonoBehaviour
	{
		[SerializeField]
		private List<GameObject> m_diableObjectTargets;

		[SerializeField]
		private List<MonoBehaviour> m_disableComponetTargets;

		public bool IsVisible { get; private set; }

		private void Start()
		{
			IsVisible = true;
		}

		private void OnBecameVisible()
		{
			IsVisible = true;
		}

		private void OnBecameInvisible()
		{
			IsVisible = false;
		}

		public void SetActive(bool isActive)
		{
		}

		public void SetEnables(bool isEnabled)
		{
			int count = m_disableComponetTargets.Count;
			for (int i = 0; i < count; i++)
			{
				m_disableComponetTargets[i].enabled = isEnabled;
			}
			count = m_diableObjectTargets.Count;
			for (int j = 0; j < count; j++)
			{
				m_diableObjectTargets[j].SetActive(isEnabled);
			}
		}
	}
	public class AdvCharaStyleChange : MonoBehaviour
	{
		[Serializable]
		private struct ChangeBlendShapes
		{
			public SkinnedMeshRenderer skinnedMesh;

			public int blendShapeId;

			public bool reverse;

			public ChangeBlendShapes(SkinnedMeshRenderer renderer, int id, bool rev)
			{
				skinnedMesh = renderer;
				blendShapeId = id;
				reverse = rev;
			}
		}

		[SerializeField]
		private ChangeBlendShapes[] ChangeParams;

		[SerializeField]
		private SkinnedMeshRenderer[] SwitchSkinnedMeshs;

		private bool isChangeStyle;

		private void LateUpdate()
		{
			if (isChangeStyle && ChangeParams != null)
			{
				for (int i = 0; i < ChangeParams.Length; i++)
				{
					int num = 0;
					num = ((!ChangeParams[i].reverse) ? ((!isChangeStyle) ? 100 : 0) : (isChangeStyle ? 100 : 0));
					ChangeParams[i].skinnedMesh.SetBlendShapeWeight(ChangeParams[i].blendShapeId, num);
				}
			}
		}

		public void CharaStyleChange(bool style)
		{
			if (SwitchSkinnedMeshs != null)
			{
				for (int i = 0; i < SwitchSkinnedMeshs.Length; i++)
				{
					SwitchSkinnedMeshs[i].enabled = !style;
				}
			}
			if (ChangeParams != null)
			{
				for (int j = 0; j < ChangeParams.Length; j++)
				{
					int num = 0;
					num = ((!ChangeParams[j].reverse) ? ((!style) ? 100 : 0) : (style ? 100 : 0));
					ChangeParams[j].skinnedMesh.SetBlendShapeWeight(ChangeParams[j].blendShapeId, num);
				}
				isChangeStyle = style;
			}
		}
	}
	[Serializable]
	public class AdvCharaTextureData
	{
		public enum TextureType
		{
			Normal,
			Night,
			Room,
			Mono,
			Blood,
			BloodDark,
			MAX
		}

		public Texture Texture;

		public TextureType Type;
	}
	[Serializable]
	public class AdvCharaTextureSettings
	{
		[Serializable]
		public class UniqueSetting
		{
			public GameDefine.CharaID Chara = GameDefine.CharaID.NIKAIDOU;

			public AdvCharaTextureData.TextureType Type;
		}

		public AdvCharaTextureData.TextureType CharaTextureType;

		public List<UniqueSetting> Exceptions;

		public UniqueSetting FindExceptionSettings(GameDefine.CharaID chara)
		{
			if (Exceptions == null)
			{
				return null;
			}
			int count = Exceptions.Count;
			for (int i = 0; i < count; i++)
			{
				if (Exceptions[i].Chara == chara)
				{
					return Exceptions[i];
				}
			}
			return null;
		}

		public bool IsInException(GameDefine.CharaID chara)
		{
			if (Exceptions == null)
			{
				return false;
			}
			int count = Exceptions.Count;
			for (int i = 0; i < count; i++)
			{
				if (Exceptions[i].Chara == chara)
				{
					return true;
				}
			}
			return false;
		}
	}
	public class AdvCopyLipSync : MonoBehaviour
	{
		[SerializeField]
		private AdvCharaMorpthTargetData MorpthTargetData;

		private AdvCharaMorpthTargetData.Data AdvCharaMorpthData;

		[SerializeField]
		private SkinnedMeshRenderer skinnedMesh;

		private SkinnedMeshRenderer BaseSkinnedMesh;

		private AdvChara BaseChara;

		[SerializeField]
		private GameDefine.CharaID BaseCharaID = GameDefine.CharaID.BASE;

		private void Start()
		{
			skinnedMesh = GetComponent<AdvChara>().FaceRenderer;
			BaseChara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(BaseCharaID);
			if (BaseChara != null)
			{
				BaseSkinnedMesh = BaseChara.FaceRenderer;
			}
			AdvCharaMorpthData = MorpthTargetData.FindData(BaseCharaID);
		}

		private void LateUpdate()
		{
			if (BaseChara.Model.IsActive)
			{
				for (int i = 10; i <= 14; i++)
				{
					skinnedMesh.SetBlendShapeWeight(AdvCharaMorpthData.MorpthTargetIndex[i], BaseSkinnedMesh.GetBlendShapeWeight(AdvCharaMorpthData.MorpthTargetIndex[i]));
				}
			}
		}
	}
	public class CharactersManager : SingletonMonoBehaviour<CharactersManager>
	{
		[Serializable]
		public class Data
		{
			public AdvChara CharaPrefab;

			public GameDefine.CharaID ID;
		}

		private const string _PATH_PREFAB = "Prefabs/Characters/{0}";

		public const int _FORCUS_CHARA_COUNT = 2;

		private const bool IS_APPLY_ANIMATION_LIMIT = true;

		[SerializeField]
		private List<Data> m_charaPrefabList;

		private List<AdvChara> m_characters;

		private List<GameDefine.CharaID> m_lastVoiceCharas;

		private int m_voiceCharaCount;

		public Transform m_transform;

		public bool IsLimitAnimatableChara { get; set; }

		public bool IsIgnoreAnimationLimit { get; set; }

		protected override void InitializeOnAwake()
		{
			base.InitializeOnAwake();
			IsIgnoreAnimationLimit = false;
			IsLimitAnimatableChara = true;
			m_transform = base.transform;
			m_characters = new List<AdvChara>(10);
			m_voiceCharaCount = 0;
			m_lastVoiceCharas = new List<GameDefine.CharaID>(2);
			for (int i = 0; i < 2; i++)
			{
				m_lastVoiceCharas.Add(GameDefine.CharaID.BASE);
			}
			LoadCharaAtStart();
		}

		private void LoadCharaAtStart()
		{
			int count = m_charaPrefabList.Count;
			for (int i = 0; i < count; i++)
			{
				LoadChara(m_charaPrefabList[i].ID, m_charaPrefabList[i].CharaPrefab);
			}
		}

		public AdvChara LoadChara(GameDefine.CharaID id, AdvChara prefab)
		{
			if (prefab == null)
			{
				return null;
			}
			AdvChara advChara = UnityEngine.Object.Instantiate(prefab, m_transform, worldPositionStays: false);
			advChara.Setup(id);
			m_characters.Add(advChara);
			return advChara;
		}

		public void RemoveChara(GameDefine.CharaID id)
		{
			AdvChara chara = GetChara(id);
			if (!(chara == null))
			{
				m_characters.Remove(chara);
				UnityEngine.Object.Destroy(chara.gameObject);
				chara = null;
				Resources.UnloadUnusedAssets();
			}
		}

		public AdvChara GetChara(GameDefine.CharaID id)
		{
			if (GameDefine.IsUnknownChara(id))
			{
				id = GameDefine.UnknownToCharaID(id);
			}
			int count = m_characters.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_characters[i].ID == id)
				{
					return m_characters[i];
				}
			}
			return null;
		}

		public void AddActiveCharaToList(List<AdvChara> list)
		{
			int count = m_charaPrefabList.Count;
			for (int i = 0; i < count; i++)
			{
				AdvChara chara = GetChara(m_charaPrefabList[i].ID);
				if (!(chara == null) && chara.IsActive)
				{
					list.Add(chara);
				}
			}
		}

		public void OnEndSequence()
		{
			IsLimitAnimatableChara = true;
			IsIgnoreAnimationLimit = false;
			int count = m_characters.Count;
			for (int i = 0; i < count; i++)
			{
				m_characters[i].OnEndSequence();
			}
			ResetEndVoiceSequence();
		}

		private void ResetEndVoiceSequence()
		{
			for (int i = 0; i < m_voiceCharaCount; i++)
			{
				m_lastVoiceCharas[i] = GameDefine.CharaID.BASE;
			}
			m_voiceCharaCount = 0;
		}

		public void SetupInitialTalkCharaForcus(List<GameDefine.CharaID> list)
		{
			ResetEndVoiceSequence();
			int count = list.Count;
			for (int i = 0; i < count; i++)
			{
				AdvChara chara = GetChara(list[i]);
				if (!(chara == null))
				{
					chara.OnPlayVoice();
					m_lastVoiceCharas[m_voiceCharaCount++] = list[i];
				}
			}
		}

		public void OnPlayVoice(GameDefine.CharaID chara)
		{
			if (IsLimitAnimatableChara && !IsCurrentChara(chara))
			{
				CheckLastSpeakRecords(chara);
				int count = m_characters.Count;
				for (int i = 0; i < count; i++)
				{
					ApplyOnSpeakForcus(chara, m_characters[i]);
				}
				m_lastVoiceCharas[m_voiceCharaCount++] = chara;
			}
		}

		private void CheckLastSpeakRecords(GameDefine.CharaID chara)
		{
			if (m_lastVoiceCharas.Count >= 2)
			{
				int index = -1;
				if (IsContainCharaInLastVoice(chara, ref index))
				{
					RemoveIndexFromCharaList(index);
				}
				else
				{
					RemoveFirstCharaFromVoiceList();
				}
			}
		}

		private void RemoveIndexFromCharaList(int index)
		{
			bool flag = false;
			int count = m_lastVoiceCharas.Count;
			for (int i = index; i < count - 1; i++)
			{
				m_lastVoiceCharas[i] = m_lastVoiceCharas[i + 1];
				flag = true;
			}
			if (!flag)
			{
				m_lastVoiceCharas[index] = GameDefine.CharaID.BASE;
			}
			m_voiceCharaCount = Mathf.Max(0, m_voiceCharaCount - 1);
		}

		private void RemoveFirstCharaFromVoiceList()
		{
			int count = m_lastVoiceCharas.Count;
			for (int i = 0; i < count - 1; i++)
			{
				m_lastVoiceCharas[i] = m_lastVoiceCharas[i + 1];
			}
			m_voiceCharaCount = Mathf.Max(0, m_voiceCharaCount - 1);
		}

		public void SetAnimationLimitation(bool isLimit)
		{
			IsLimitAnimatableChara = isLimit;
			int count = m_characters.Count;
			for (int i = 0; i < count; i++)
			{
				m_characters[i].SetForcus(!isLimit);
			}
		}

		private void ApplyOnSpeakForcus(GameDefine.CharaID speakChara, AdvChara chara)
		{
			if (!IsContainCharaInLastVoice(chara.ID))
			{
				if (chara.ID == speakChara)
				{
					chara.OnPlayVoice();
				}
				else
				{
					chara.OnNonForccus();
				}
			}
		}

		private bool IsContainCharaInLastVoice(GameDefine.CharaID id)
		{
			int count = m_lastVoiceCharas.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_lastVoiceCharas[i] == id)
				{
					return true;
				}
			}
			return false;
		}

		private bool IsContainCharaInLastVoice(GameDefine.CharaID id, ref int index)
		{
			int count = m_lastVoiceCharas.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_lastVoiceCharas[i] == id)
				{
					index = i;
					return true;
				}
			}
			return false;
		}

		public static bool IsCurrentChara(GameDefine.CharaID chara)
		{
			if (chara != GameDefine.CharaID.BASE)
			{
				return chara == SingletonMonoBehaviour<LocalData>.Instance.CurrentCharaID;
			}
			return true;
		}

		public void SetCharaTextures(AdvCharaTextureSettings settings)
		{
			int count = m_characters.Count;
			for (int i = 0; i < count; i++)
			{
				AdvCharaTextureSettings.UniqueSetting uniqueSetting = settings.FindExceptionSettings(m_characters[i].ID);
				if (uniqueSetting == null)
				{
					m_characters[i].Model.SetTexture(settings.CharaTextureType);
				}
				else
				{
					m_characters[i].Model.SetTexture(uniqueSetting.Type);
				}
			}
		}

		public void OnPrepareFistFade(List<GameDefine.CharaID> list, bool isMemoryMode)
		{
			Observable.NextFrame().Subscribe(delegate
			{
				_ApplyFirstFadeSettings(list, isMemoryMode);
			});
		}

		private void _ApplyFirstFadeSettings(List<GameDefine.CharaID> list, bool isMemoryMode)
		{
			bool flag = !IsIgnoreAnimationLimit && !isMemoryMode;
			int count = m_characters.Count;
			for (int i = 0; i < count; i++)
			{
				m_characters[i].ApplySafetySettings();
				if (flag)
				{
					m_characters[i].SetForcus(isForcus: false);
				}
			}
			if (flag)
			{
				IsLimitAnimatableChara = true;
				SetupInitialTalkCharaForcus(list);
			}
		}
	}
	public static class CharaDefine
	{
		public const int FACIAL_START = 300;

		public const int FACIAL_END = 400;
	}
	public class FaceAnimationManager : MonoBehaviour
	{
		private Animator animator;

		public const string BLINK_TRIGGER_NAME = "blinkTrigger";

		public const string BLINK_PARAM_NAME = "blinkNo";

		private float m_BlinkTimer;

		private float m_NextBlink;

		private void Start()
		{
			animator = GetComponentInChildren<Animator>();
			m_BlinkTimer = 0f;
			m_NextBlink = UnityEngine.Random.Range(4f, 10f);
		}

		private void Update()
		{
			m_BlinkTimer += Time.deltaTime;
			if (m_BlinkTimer > m_NextBlink)
			{
				m_BlinkTimer = 0f;
				if ((double)UnityEngine.Random.Range(0f, 1f) > 0.3)
				{
					StartBlinkEye();
					m_NextBlink = UnityEngine.Random.Range(5.5f, 10f);
				}
			}
		}

		public void StartBlinkEye()
		{
			if ((double)UnityEngine.Random.Range(0f, 1f) > 0.08)
			{
				animator.SetInteger("blinkNo", 0);
			}
			else
			{
				animator.SetInteger("blinkNo", 1);
			}
			animator.SetTrigger("blinkTrigger");
		}
	}
	public class GenericLookTargetIK : MonoBehaviour
	{
		public struct WaightFreeze
		{
			public bool fleezeHeadWaight;

			public bool fleezeNeckWaight;

			public bool fleezeBodyWaight;

			public WaightFreeze(bool head, bool neck, bool body)
			{
				fleezeHeadWaight = head;
				fleezeNeckWaight = neck;
				fleezeBodyWaight = body;
			}
		}

		public struct WaightSettingData
		{
			public float headWaight;

			public float neckWaight;

			public float bodyWaight;

			public WaightSettingData(float head, float neck, float body)
			{
				headWaight = head;
				neckWaight = neck;
				bodyWaight = body;
			}
		}

		public static readonly WaightFreeze WaightFreezeAll = new WaightFreeze(head: true, neck: true, body: true);

		public static readonly WaightFreeze WaightFreezeNone = new WaightFreeze(head: false, neck: false, body: false);

		[SerializeField]
		private AdvCharaLookAtMorpthTargetData LookAtMorpthTargetData;

		private AdvCharaLookAtMorpthTargetData.Data MorpthTargetList;

		private Animator animator;

		private FaceAnimationManager faceAnimator;

		[SerializeField]
		public Transform m_HeadTransform;

		[SerializeField]
		public Transform m_NeckTransform;

		[SerializeField]
		public Transform m_bodyTransform;

		[SerializeField]
		private Transform lookAtObject;

		[SerializeField]
		private bool isChangeTarget;

		[SerializeField]
		private float m_ChangeTime = 1f;

		private float changeTimer;

		private float timer;

		private float rand;

		[SerializeField]
		private Transform LeftEyeTransform;

		[SerializeField]
		private Transform RightEyeTransform;

		private Vector3 defaultRotateL;

		private Quaternion defaultRotateLQuaternion;

		private Quaternion defaultRotateRQuaternion;

		[SerializeField]
		private float EyeLinitYMax = 30f;

		[SerializeField]
		private float EyeLimitYMin = -22f;

		[SerializeField]
		private float EyeLinitXInside = 35f;

		[SerializeField]
		private float EyeLimitXOutside = -35f;

		private Transform TargetTransform;

		private Transform NextTargetTransform;

		private Vector3 TargetPosition;

		[SerializeField]
		private Vector3 m_NextTargetPosition;

		private Vector3 m_OldTargetPosition;

		[SerializeField]
		private Transform m_DefaultLookTarget;

		private Transform m_transform;

		private Transform m_calculationTransform;

		[SerializeField]
		private SkinnedMeshRenderer faceMesh;

		[SerializeField]
		private GameDefine.CharaID m_id = GameDefine.CharaID.BASE;

		private string mLookupFaceMeshR;

		private string mLookupFaceMeshL;

		private string mLookdownFaceMeshR;

		private string mLookdownFaceMeshL;

		private string mLookdownTopFaceMeshR;

		private string mLookdownTopFaceMeshL;

		[SerializeField]
		[Range(0f, 100f)]
		private float mDefaultHeadWaight;

		[SerializeField]
		[Range(0f, 100f)]
		private float mDefaultNeckWaight;

		[SerializeField]
		[Range(0f, 100f)]
		private float mDefaultBodyWaight;

		[SerializeField]
		private float m_blinkWaitDuration = 0.005f;

		[SerializeField]
		private bool m_IsEyeLookAt = true;

		private float mWaightTimer;

		private float mWaightChangeTime = 1f;

		private bool isWaightChange;

		private float mHeadWaight;

		private float mNeckWaight;

		private float mBodyWaight;

		private float mNextHeadWaight;

		private float mNextNeckWaight;

		private float mNextBodyWaight;

		private float mLastHeadWaight;

		private float mLastNeckWaight;

		private float mLastBodyWaight;

		private bool mIsHeadWaightFreeze;

		private bool mIsNeckWaightFreeze;

		private bool mIsBodyWaightFreeze;

		private Quaternion lastHeadRotate;

		private Quaternion lastNeckRotate;

		private Quaternion lastBodyRotate;

		private AdvCharaHairControll HairController;

		private Quaternion m_tempLookRotation = QuaternionExtension.IDENTITY;

		private Quaternion m_tempPartsRotation = QuaternionExtension.IDENTITY;

		private TimeSpan m_blinkWaitTimeSpan;

		private Action<long> m_onBlinkWaitEndAction;

		public bool BodyLookAtTrigger { get; set; }

		public bool IsAnimatorEnable { get; set; }

		public bool IsPlayerMirrorAttach { get; set; }

		public bool IsUpdate { get; set; }

		public bool HasHair => HairController != null;

		private void Start()
		{
			m_transform = base.transform;
			SetupCalculationTransform(ref m_calculationTransform);
			faceAnimator = GetComponentInChildren<FaceAnimationManager>();
			m_OldTargetPosition = m_DefaultLookTarget.position;
			m_NextTargetPosition = m_OldTargetPosition;
			TargetTransform = m_DefaultLookTarget;
			TargetPosition = m_OldTargetPosition;
			IsUpdate = true;
			isChangeTarget = false;
			defaultRotateLQuaternion = LeftEyeTransform.localRotation;
			defaultRotateRQuaternion = RightEyeTransform.localRotation;
			defaultRotateL = defaultRotateLQuaternion.eulerAngles;
			MorpthTargetList = LookAtMorpthTargetData.FindData(m_id);
			mIsHeadWaightFreeze = false;
			mIsNeckWaightFreeze = false;
			mIsBodyWaightFreeze = false;
			mHeadWaight = mDefaultHeadWaight;
			mNeckWaight = mDefaultNeckWaight;
			mBodyWaight = mDefaultBodyWaight;
			IsPlayerMirrorAttach = false;
			IsAnimatorEnable = true;
			BodyLookAtTrigger = false;
			lastHeadRotate = m_HeadTransform.localRotation;
			lastNeckRotate = m_NeckTransform.localRotation;
			lastBodyRotate = m_bodyTransform.localRotation;
			HairController = GetComponent<AdvCharaHairControll>();
			m_blinkWaitTimeSpan = TimeSpan.FromSeconds(m_blinkWaitDuration);
			m_onBlinkWaitEndAction = delegate
			{
				OnEndChangeEyeTarget();
			};
		}

		private void SetupCalculationTransform(ref Transform target)
		{
			GameObject gameObject = new GameObject();
			gameObject.SetActive(value: false);
			target = gameObject.transform;
			target.SetParent(m_transform);
		}

		private void Update()
		{
			if (isWaightChange && mWaightChangeTime > 0f)
			{
				mWaightTimer += Time.deltaTime;
				mHeadWaight = Mathf.Lerp(mLastHeadWaight, mNextHeadWaight, mWaightTimer / mWaightChangeTime);
				mNeckWaight = Mathf.Lerp(mLastNeckWaight, mNextNeckWaight, mWaightTimer / mWaightChangeTime);
				mBodyWaight = Mathf.Lerp(mLastBodyWaight, mNextBodyWaight, mWaightTimer / mWaightChangeTime);
				if (mWaightTimer > mWaightChangeTime)
				{
					mLastHeadWaight = mNextHeadWaight;
					mLastNeckWaight = mNextNeckWaight;
					mLastBodyWaight = mNextBodyWaight;
					isWaightChange = false;
				}
			}
		}

		private void LateUpdate()
		{
			if (!IsUpdate)
			{
				UpdateHairControl();
			}
			else
			{
				UpdateLookAtProcess();
			}
		}

		public void UpdateLookAtProcess()
		{
			Vector3 lookAtPosition = Vector3.zero;
			RecordLastRotation();
			UpdateLookAt(ref lookAtPosition);
			UpdateChangeLookAt(ref lookAtPosition);
			UpdateHairControl();
		}

		private void RecordLastRotation()
		{
			if (IsAnimatorEnable || BodyLookAtTrigger)
			{
				lastHeadRotate = m_HeadTransform.localRotation;
				lastNeckRotate = m_NeckTransform.localRotation;
				lastBodyRotate = m_bodyTransform.localRotation;
			}
		}

		private void UpdateLookAt(ref Vector3 lookAtPosition)
		{
			if (isChangeTarget)
			{
				if (NextTargetTransform != null)
				{
					TargetPosition = NextTargetTransform.position;
				}
				changeTimer += Time.deltaTime;
				lookAtPosition = Vector3.Lerp(lookAtObject.position, TargetPosition, changeTimer / m_ChangeTime);
				GenericLookAtAnimation(ref lookAtPosition);
				if (changeTimer / m_ChangeTime >= 1f)
				{
					TargetTransform = NextTargetTransform;
					isChangeTarget = false;
				}
			}
			else
			{
				if (TargetTransform != null)
				{
					TargetPosition = TargetTransform.position;
				}
				lookAtPosition = TargetPosition;
				GenericLookAtAnimation(ref lookAtPosition);
			}
			lookAtObject.position = lookAtPosition;
		}

		private void UpdateChangeLookAt(ref Vector3 lookAtPosition)
		{
			if (m_NextTargetPosition != m_OldTargetPosition)
			{
				Vector3 b = m_HeadTransform.position;
				Vector3 a = m_NextTargetPosition;
				Vector3 from = Vector3Extension.Subtract(ref a, ref b);
				Vector3 to = Vector3Extension.Subtract(ref lookAtPosition, ref b);
				float num = Vector3.Angle(from, to);
				StartChangeLookAt(num >= 60f);
			}
		}

		public void UpdateHairControl()
		{
			if (HairController != null)
			{
				HairController.SupportHairControll(IsAnimatorEnable || BodyLookAtTrigger);
			}
		}

		private void StartChangeLookAt(bool isBlinkFlag)
		{
			if (isBlinkFlag && IsAnimatorEnable)
			{
				faceAnimator.StartBlinkEye();
			}
			ChangeEyeTarget(isBlinkFlag);
		}

		private void ChangeEyeTarget(bool isBlinkFlag)
		{
			m_OldTargetPosition = m_NextTargetPosition;
			if (isBlinkFlag)
			{
				Observable.Timer(m_blinkWaitTimeSpan).Subscribe(m_onBlinkWaitEndAction);
			}
			else
			{
				OnEndChangeEyeTarget();
			}
		}

		private void OnEndChangeEyeTarget()
		{
			isChangeTarget = true;
			changeTimer = 0f;
			TargetPosition = m_NextTargetPosition;
		}

		private void GenericLookAtAnimation(ref Vector3 lookAtPosition)
		{
			if (!IsAnimatorEnable && !BodyLookAtTrigger)
			{
				m_bodyTransform.localRotation = lastBodyRotate;
				m_NeckTransform.localRotation = lastNeckRotate;
				m_HeadTransform.localRotation = lastHeadRotate;
			}
			BodyLookAtTrigger = false;
			RotateHeadParts(m_bodyTransform, mBodyWaight, ref lookAtPosition);
			RotateHeadParts(m_NeckTransform, mNeckWaight, ref lookAtPosition);
			RotateHeadParts(m_HeadTransform, mHeadWaight, ref lookAtPosition);
			if (IsPlayerMirrorAttach)
			{
				float num = MainPosition.CameraTransform.rotation.eulerAngles.y;
				if (Mathf.Abs(num) > 180f)
				{
					float num2 = num % 180f;
					num = ((!(num2 >= 0f)) ? (num2 + 180f) : (num2 - 180f));
				}
				m_bodyTransform.Rotate(Vector3.up, (0f - num) / 2f);
				m_HeadTransform.Rotate(Vector3.up, (0f - num) / 2f);
			}
			timer += Time.deltaTime;
			if (timer >= 4f)
			{
				timer = 0f;
				if (UnityEngine.Random.value > 0.2f)
				{
					rand = (UnityEngine.Random.Range(-1f, 1f) + UnityEngine.Random.Range(-1f, 1f) + UnityEngine.Random.Range(-1f, 1f) + UnityEngine.Random.Range(-1f, 1f) + UnityEngine.Random.Range(-1f, 1f)) / 5f;
				}
			}
			if (!m_IsEyeLookAt)
			{
				LeftEyeTransform.localRotation = defaultRotateLQuaternion;
				RightEyeTransform.localRotation = defaultRotateRQuaternion;
				return;
			}
			Vector3 inverseHeadLookAt = m_HeadTransform.InverseTransformDirection(lookAtPosition);
			CalculateEyeRotation(LeftEyeTransform, ref inverseHeadLookAt, EyeLimitXOutside, EyeLinitXInside);
			float rotateY = CalculateEyeRotation(RightEyeTransform, ref inverseHeadLookAt, 0f - EyeLinitXInside, 0f - EyeLimitXOutside);
			LookingMorph(rotateY);
		}

		private void RotateHeadParts(Transform parts, float weight, ref Vector3 lookAtPosition)
		{
			if (weight != 0f)
			{
				Vector3 position = parts.position;
				QuaternionExtension.CreateLookAt(ref position, ref lookAtPosition, ref m_tempLookRotation);
				m_tempPartsRotation = parts.rotation;
				m_tempPartsRotation = Quaternion.Slerp(m_tempPartsRotation, m_tempLookRotation, weight / 100f);
				parts.rotation = m_tempPartsRotation;
			}
		}

		private float CalculateEyeRotation(Transform eye, ref Vector3 inverseHeadLookAt, float eyeLimitOutside, float eyeLimitInside)
		{
			Vector3 b = m_HeadTransform.InverseTransformDirection(eye.position);
			Vector3 v = Vector3Extension.Subtract(ref inverseHeadLookAt, ref b);
			Vector3Extension.Normalize(ref v);
			float num = Mathf.Clamp(Mathf.Atan2(x: new Vector2(v.x, v.z).Length(), y: v.y) * 57.29578f + rand, EyeLimitYMin, EyeLinitYMax);
			float num2 = Mathf.Clamp(Mathf.Atan2(v.x, v.z) * 57.29578f + rand, eyeLimitOutside, eyeLimitInside);
			eye.localRotation = Quaternion.Euler(defaultRotateL.x + num, defaultRotateL.y + num2, defaultRotateL.z);
			return num;
		}

		private float ChangeEffectiveValue(float rotate)
		{
			if (rotate > 180f)
			{
				rotate -= 360f;
			}
			else if (rotate < -180f)
			{
				rotate += 360f;
			}
			return rotate;
		}

		public void SetLookAtTransform(Transform lookat, bool isSkip)
		{
			if (lookat != null)
			{
				if (TargetTransform != lookat)
				{
					changeTimer = 0f;
					NextTargetTransform = lookat;
					m_NextTargetPosition = lookat.position;
					TargetTransform = null;
				}
			}
			else
			{
				changeTimer = 0f;
				NextTargetTransform = m_DefaultLookTarget;
				m_NextTargetPosition = m_DefaultLookTarget.position;
				TargetTransform = null;
			}
			if (isSkip)
			{
				TargetPosition = m_NextTargetPosition;
				lookAtObject.position = m_NextTargetPosition;
			}
		}

		public void SetLookAtPosition(Vector3 lookAtPosition, bool isSkip)
		{
			if (m_NextTargetPosition != lookAtPosition)
			{
				changeTimer = 0f;
				TargetTransform = null;
				NextTargetTransform = null;
				m_NextTargetPosition = lookAtPosition;
			}
			if (isSkip)
			{
				TargetPosition = m_NextTargetPosition;
				lookAtObject.position = m_NextTargetPosition;
			}
		}

		public void SetChangeWaight(WaightFreeze waightFreeze, float changeTime = 1f)
		{
			bool flag = false;
			if (waightFreeze.fleezeBodyWaight ^ mIsBodyWaightFreeze)
			{
				mIsBodyWaightFreeze = waightFreeze.fleezeBodyWaight;
				mLastBodyWaight = mBodyWaight;
				if (mIsBodyWaightFreeze)
				{
					mNextBodyWaight = 0f;
				}
				else
				{
					mNextBodyWaight = mDefaultBodyWaight;
				}
				flag = true;
			}
			if (waightFreeze.fleezeNeckWaight ^ mIsNeckWaightFreeze)
			{
				mIsNeckWaightFreeze = waightFreeze.fleezeNeckWaight;
				mLastNeckWaight = mNeckWaight;
				if (mIsNeckWaightFreeze)
				{
					mNextNeckWaight = 0f;
				}
				else
				{
					mNextNeckWaight = mDefaultNeckWaight;
				}
				flag = true;
			}
			if (waightFreeze.fleezeHeadWaight ^ mIsHeadWaightFreeze)
			{
				mIsHeadWaightFreeze = waightFreeze.fleezeHeadWaight;
				mLastHeadWaight = mHeadWaight;
				if (mIsHeadWaightFreeze)
				{
					mNextHeadWaight = 0f;
				}
				else
				{
					mNextHeadWaight = mDefaultHeadWaight;
				}
				flag = true;
			}
			if (flag)
			{
				mWaightChangeTime = changeTime;
				mWaightTimer = 0f;
				isWaightChange = true;
			}
		}

		public void LookingMorph(float rotateY)
		{
			if (MorpthTargetList != null)
			{
				if (rotateY >= EyeLinitYMax / 10f)
				{
					float value = 100f * rotateY / EyeLinitYMax;
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[1], value);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[0], value);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[5], value);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[4], value);
				}
				else if (rotateY < EyeLimitYMin / 10f)
				{
					float value2 = 100f * rotateY / EyeLimitYMin;
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[7], value2);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[6], value2);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[3], value2);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[2], value2);
				}
				else
				{
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[1], 0f);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[0], 0f);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[3], 0f);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[2], 0f);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[5], 0f);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[4], 0f);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[7], 0f);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[6], 0f);
				}
			}
		}
	}
	public interface IChara
	{
		Transform Head { get; }

		Transform Transform { get; set; }

		GameDefine.CharaID ID { get; }

		void Destroy();

		void Enable();

		void Disable();

		void SetEnable(bool isEnable);
	}
	public class BaseProp : MonoBehaviour
	{
		[Header("Prop")]
		[SerializeField]
		[Tooltip("Prop")]
		private string _propAliasName = "";

		[SerializeField]
		[Tooltip("ON\n")]
		private bool _showAlways;

		[Header("")]
		[SerializeField]
		[Tooltip("Transform")]
		private Transform[] _anchors;

		[Header(" ()")]
		[SerializeField]
		[Tooltip("Transform")]
		private Transform _anchorOverride;

		[SerializeField]
		[Tooltip("")]
		private Transform _audioAnchorOverride;

		private GameObject _gameObject;

		private Transform _thisTransform;

		private Transform _parentTransform;

		private bool _isVisible;

		private BehaviorSubject<bool> _subjectOnChangeVisible;

		public Transform ThisTransform
		{
			get
			{
				if (_thisTransform == null)
				{
					_thisTransform = base.transform;
				}
				return _thisTransform;
			}
		}

		public GameObject ThisObject => _gameObject;

		public Transform ParentTransform => _parentTransform;

		public Transform AnchorTransform
		{
			get
			{
				if (!(_anchorOverride != null))
				{
					return ThisTransform;
				}
				return _anchorOverride;
			}
		}

		public Transform AudioAnchorTransform
		{
			get
			{
				if (!(_audioAnchorOverride != null))
				{
					return AnchorTransform;
				}
				return _audioAnchorOverride;
			}
		}

		public string PropName
		{
			get
			{
				if (!string.IsNullOrEmpty(_propAliasName))
				{
					return _propAliasName;
				}
				return base.gameObject.name;
			}
		}

		public int AnchorCount => _anchors.Length;

		public bool IsVisible => _isVisible;

		public bool ShowAlways => _showAlways;

		public virtual PropDefines.PropType ThisPropType => PropDefines.PropType.Static;

		public IObservable<bool> ChangeVisibleObservable
		{
			get
			{
				if (_subjectOnChangeVisible == null)
				{
					_subjectOnChangeVisible = new BehaviorSubject<bool>(_isVisible);
				}
				return _subjectOnChangeVisible;
			}
		}

		public virtual IObservable<PropActionParam> OnAction => null;

		private void Awake()
		{
			_gameObject = base.gameObject;
			_thisTransform = base.transform;
			_parentTransform = AnchorTransform.parent;
			OnAwakeInitialize();
		}

		protected virtual void OnAwakeInitialize()
		{
		}

		public virtual void SetInitial()
		{
		}

		private void Start()
		{
			OnStart();
			_gameObject.SetActive(_isVisible);
		}

		protected virtual void OnStart()
		{
		}

		public void SetVisible(bool flag)
		{
			if (_isVisible != flag)
			{
				_isVisible = flag;
				OnChangeVisible(_isVisible);
				if (_subjectOnChangeVisible != null)
				{
					_subjectOnChangeVisible.OnNext(_isVisible);
				}
			}
		}

		protected virtual void OnChangeVisible(bool flag)
		{
		}

		public virtual void SetAlpha(float alpha)
		{
		}

		public virtual void SetOutlineSize(float size)
		{
		}

		public virtual void SetOutlineColor(Color color)
		{
		}

		public virtual void StartSmoothOutlineSizeChange(float duration, float after)
		{
		}

		public virtual void StartSmoothOutlineColorChange(float duration, Color after)
		{
		}

		public virtual void ActionPropAnimation(int index)
		{
		}

		public virtual void ActionPropAnimation(string triggerName)
		{
		}

		public virtual void ActionPropAnimation(PropActionParam action)
		{
		}

		public virtual PropActionParam GetPropAction(int index)
		{
			return new PropActionParam();
		}

		public virtual PropActionParam GetPropAction(string triggerName)
		{
			return new PropActionParam();
		}

		public virtual void ResetPropTransform()
		{
		}

		public virtual void MoveProp(Vector3 position, Quaternion rotation, Vector3 scale)
		{
		}

		public virtual void MovePropAdditive(Vector3 position, Quaternion rotation, Vector3 scale)
		{
		}

		public virtual void MovePropOnLocal(Vector3 position, Quaternion rotation)
		{
		}

		public virtual void MovePropOnLocal(Vector3 position, Quaternion rotation, Vector3 scale)
		{
		}

		public virtual void MovePropRelation(Transform relationTransform, Vector3 position, Quaternion rotation, Vector3 scale)
		{
		}

		public virtual void AttachToTransform(Transform target, bool isStay)
		{
		}

		public virtual void SetAttachToChara(AdvChara chara, AdvCharaModel.Node nodeToAttach)
		{
		}

		public virtual void ActionBetweenDither(float fadeDuration, Action onBetween, Action onEnd)
		{
		}

		public virtual void ReadyToSmooth(float duration)
		{
		}

		public Transform GetAnchor(int index)
		{
			if (index <= -1)
			{
				return ThisTransform;
			}
			if (index >= _anchors.Length)
			{
				return ThisTransform;
			}
			return _anchors[index];
		}

		public virtual void ResetPropEverything()
		{
			ResetPropTransform();
			SetVisible(_showAlways);
		}
	}
	public class DynamicProp : BaseProp
	{
		private struct DestinationCoord
		{
			public Vector3 Position;

			public Quaternion Rotation;

			public Vector3 Scale;

			public static DestinationCoord identity
			{
				get
				{
					DestinationCoord result = default(DestinationCoord);
					result.Position = Vector3.zero;
					result.Rotation = Quaternion.identity;
					result.Scale = Vector3.one;
					return result;
				}
			}

			public DestinationCoord(Transform tf)
			{
				Position = tf.localPosition;
				Rotation = tf.localRotation;
				Scale = tf.localScale;
			}

			public DestinationCoord(Vector3 pos, Quaternion rot, Vector3 sca)
			{
				Position = pos;
				Rotation = rot;
				Scale = sca;
			}

			public static DestinationCoord Lerp(DestinationCoord a, DestinationCoord b, float t)
			{
				DestinationCoord result = default(DestinationCoord);
				result.Position = Vector3.Lerp(a.Position, b.Position, t);
				result.Rotation = Quaternion.Lerp(a.Rotation, b.Rotation, t);
				result.Scale = Vector3.Lerp(a.Scale, b.Scale, t);
				return result;
			}
		}

		private BehaviorSubject<PropActionParam> _subjectAction;

		[Header("Dynamic Prop")]
		[SerializeField]
		[Tooltip("")]
		private Animator _propAnimator;

		[Header(" (Animation) ")]
		[SerializeField]
		[Tooltip("")]
		private PropActionParam[] _propActions;

		private bool _isMoved;

		private Vector3 _initialPosition;

		private Quaternion _initialRotation;

		private Vector3 _initialScale;

		private List<Renderer> _targetRenderer;

		private SortedDictionary<string, PropActionParam> _dictAction = new SortedDictionary<string, PropActionParam>();

		private SortedDictionary<int, Material> _instancedMaterials;

		private AdvChara _attachedChara;

		private AdvCharaModel.Node _nodeToAttach;

		private DestinationCoord _smoothFrom;

		private DestinationCoord _smoothTo;

		private float _smoothDuration;

		private bool _isReadySmooth;

		private DitherFade _ditherfade;

		private IDisposable _disposeUpdate;

		private IDisposable _disposeSmoothMove;

		private IDisposable _disposeSmoothOutlineColorChange;

		private IDisposable _disposeSmoothOutlineSizeChange;

		private Action m_onStartDitherFadeEnd;

		private Action m_onBetween;

		private Action m_onEnd;

		private Action m_onEndMethodAction;

		private float m_fadeDuration;

		public override PropDefines.PropType ThisPropType => PropDefines.PropType.Dynamic;

		public override IObservable<PropActionParam> OnAction => _subjectAction;

		private bool IsAnimatorAvailable => _propAnimator != null;

		private IObservable<Unit> ObserverGameUpdate => SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable;

		public PropActionParam[] PropActions => _propActions;

		protected override void OnAwakeInitialize()
		{
			_subjectAction = new BehaviorSubject<PropActionParam>(new PropActionParam());
			SetInitial();
			SetActionIndex();
			FindRenderer();
			InitializeActions();
			MakeRendererMaterials();
			MakeDitherFade();
		}

		public override void SetInitial()
		{
			_initialPosition = base.AnchorTransform.localPosition;
			_initialRotation = base.AnchorTransform.localRotation;
			_initialScale = base.AnchorTransform.localScale;
		}

		public void SetActionIndex()
		{
			if (PropActions == null)
			{
				return;
			}
			for (int i = 0; i < PropActions.Length; i++)
			{
				PropActionParam propActionParam = PropActions[i];
				if (propActionParam != null)
				{
					propActionParam.Index = i;
					_dictAction.Add(propActionParam.TriggerName, propActionParam);
				}
			}
		}

		private void InitializeActions()
		{
			m_onStartDitherFadeEnd = delegate
			{
				OnStartDitherFadeEnd();
			};
			m_onEndMethodAction = delegate
			{
				OnFadeAllEnd();
			};
		}

		private void OnStartDitherFadeEnd()
		{
			if (m_onBetween != null)
			{
				m_onBetween();
				m_onBetween = null;
			}
			if (base.IsVisible)
			{
				OnBetweenDitherEnd(m_fadeDuration, m_onEnd);
			}
		}

		protected override void OnStart()
		{
			if (IsAnimatorAvailable)
			{
				_propAnimator.enabled = false;
			}
		}

		private void FindRenderer()
		{
			_targetRenderer = new List<Renderer>();
			Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
			_targetRenderer.AddRange(componentsInChildren);
		}

		private void MakeRendererMaterials()
		{
			_instancedMaterials = new SortedDictionary<int, Material>();
			_targetRenderer.ForEach(delegate(Renderer renderer)
			{
				if (!(renderer == null))
				{
					Material[] sharedMaterials = renderer.sharedMaterials;
					Material[] array = new Material[sharedMaterials.Length];
					for (int i = 0; i < sharedMaterials.Length; i++)
					{
						Material material = sharedMaterials[i];
						if ((object)material != null)
						{
							if (!_instancedMaterials.TryGetValue(material.GetHashCode(), out var value))
							{
								value = new Material(material);
								value.name += " (IS)";
								_instancedMaterials.Add(material.GetHashCode(), value);
							}
							array[i] = value;
						}
					}
					renderer.sharedMaterials = array;
				}
			});
		}

		private void MakeDitherFade()
		{
			_ditherfade = new DitherFade(base.gameObject, new List<Material>(_instancedMaterials.Values));
		}

		private void OnEnable()
		{
			if (SingletonMonoBehaviour<GameLogic>.HasInstance)
			{
				_disposeUpdate = ObserverGameUpdate.Subscribe(delegate
				{
					OnGameUpdate();
				}).AddTo(base.gameObject);
			}
			else
			{
				_disposeUpdate = this.UpdateAsObservable().Subscribe(delegate
				{
					OnGameUpdate();
				}).AddTo(base.gameObject);
			}
		}

		private void OnDisable()
		{
			if (_disposeUpdate != null)
			{
				_disposeUpdate.Dispose();
				_disposeUpdate = null;
			}
			if (_disposeSmoothMove != null)
			{
				_disposeSmoothMove.Dispose();
				_disposeSmoothMove = null;
			}
		}

		private void OnGameUpdate()
		{
			if (IsAnimatorAvailable)
			{
				_propAnimator.Update(Time.deltaTime);
			}
		}

		protected override void OnChangeVisible(bool flag)
		{
			base.ThisObject.SetActive(flag);
			if (!flag)
			{
				CheckDettachFromChara();
			}
		}

		public override void ActionPropAnimation(int index)
		{
			PropActionParam propAction = GetPropAction(index);
			ActionPropAnimation(propAction);
		}

		public override void ActionPropAnimation(string triggerName)
		{
			PropActionParam propAction = GetPropAction(triggerName);
			ActionPropAnimation(propAction);
		}

		public override void ActionPropAnimation(PropActionParam action)
		{
			if (_propAnimator != null)
			{
				string triggerName = action.TriggerName;
				_propAnimator.SetTrigger(triggerName);
			}
			if (_subjectAction != null)
			{
				_subjectAction.OnNext(action);
			}
		}

		public override PropActionParam GetPropAction(int index)
		{
			if (index < 0 || index >= PropActions.Length)
			{
				return new PropActionParam();
			}
			PropActionParam propActionParam = PropActions[index];
			if (propActionParam == null)
			{
				return new PropActionParam();
			}
			return propActionParam;
		}

		public override PropActionParam GetPropAction(string triggerName)
		{
			if (!_dictAction.TryGetValue(triggerName, out var value))
			{
				return new PropActionParam();
			}
			return value;
		}

		public override void ResetPropTransform()
		{
			if (_isMoved)
			{
				AttachToTransform(null, isStay: true);
				OnBeforeMovement();
				base.AnchorTransform.localPosition = _initialPosition;
				base.AnchorTransform.localRotation = _initialRotation;
				base.AnchorTransform.localScale = _initialScale;
				_isMoved = false;
				CheckDettachFromChara();
				OnAfterMovement();
			}
		}

		public override void MoveProp(Vector3 position, Quaternion rotation, Vector3 scale)
		{
			OnBeforeMovement();
			scale.Scale(_initialScale);
			base.AnchorTransform.position = position;
			base.AnchorTransform.rotation = rotation * _initialRotation;
			base.AnchorTransform.localScale = scale;
			_isMoved = true;
			OnAfterMovement();
		}

		public override void MovePropAdditive(Vector3 position, Quaternion rotation, Vector3 scale)
		{
			OnBeforeMovement();
			base.AnchorTransform.localPosition += position;
			base.AnchorTransform.localRotation = rotation * base.AnchorTransform.localRotation;
			base.AnchorTransform.localScale.Scale(scale);
			_isMoved = true;
			OnAfterMovement();
		}

		public override void MovePropOnLocal(Vector3 position, Quaternion rotation)
		{
			OnBeforeMovement();
			base.AnchorTransform.localPosition = position;
			base.AnchorTransform.localRotation = rotation * _initialRotation;
			_isMoved = true;
			OnAfterMovement();
		}

		public override void MovePropOnLocal(Vector3 position, Quaternion rotation, Vector3 scale)
		{
			OnBeforeMovement();
			scale.Scale(_initialScale);
			base.AnchorTransform.localPosition = position;
			base.AnchorTransform.localRotation = rotation * _initialRotation;
			base.AnchorTransform.localScale = scale;
			_isMoved = true;
			OnAfterMovement();
		}

		public override void MovePropRelation(Transform relationTransform, Vector3 position, Quaternion rotation, Vector3 scale)
		{
			position = relationTransform.TransformPoint(position);
			rotation = relationTransform.rotation * rotation;
			MoveProp(position, rotation, scale);
		}

		private void OnBeforeMovement()
		{
			if (_isReadySmooth)
			{
				_smoothFrom = new DestinationCoord(base.ThisTransform);
			}
		}

		private void OnAfterMovement()
		{
			if (_isReadySmooth)
			{
				_smoothTo = new DestinationCoord(base.ThisTransform);
				_isReadySmooth = false;
				if (_disposeSmoothMove != null)
				{
					_disposeSmoothMove.Dispose();
				}
				_disposeSmoothMove = Observable.FromMicroCoroutine(CoroutineSmoothMove).Subscribe().AddTo(this);
			}
		}

		private IEnumerator CoroutineSmoothMove()
		{
			Tweener<DestinationCoord> tweener = new Tweener<DestinationCoord>(DestinationCoord.Lerp);
			tweener.Start(_smoothFrom, _smoothTo, _smoothDuration);
			while (tweener.IsActive)
			{
				base.AnchorTransform.localPosition = tweener.CurrentValue.Position;
				base.AnchorTransform.localRotation = tweener.CurrentValue.Rotation;
				base.AnchorTransform.localScale = tweener.CurrentValue.Scale;
				tweener.Update(Time.deltaTime);
				yield return null;
			}
			base.AnchorTransform.localPosition = tweener.CurrentValue.Position;
			base.AnchorTransform.localRotation = tweener.CurrentValue.Rotation;
			base.AnchorTransform.localScale = tweener.CurrentValue.Scale;
			yield return null;
		}

		public override void AttachToTransform(Transform target, bool isStay)
		{
			if (target == null)
			{
				target = base.ParentTransform;
				SetLayerRecursively(base.gameObject, LayerMask.NameToLayer("Environment"));
			}
			else
			{
				SetLayerRecursively(base.gameObject, LayerMask.NameToLayer("ImportantProp"));
			}
			base.AnchorTransform.SetParent(target, isStay);
			_isMoved = true;
		}

		private void SetLayerRecursively(GameObject obj, int newLayer)
		{
			if (null == obj)
			{
				return;
			}
			obj.layer = newLayer;
			foreach (Transform item in obj.transform)
			{
				if (!(null == item))
				{
					SetLayerRecursively(item.gameObject, newLayer);
				}
			}
		}

		public override void ActionBetweenDither(float fadeDuration, Action onBetween, Action onEnd)
		{
			if (base.IsVisible)
			{
				m_onBetween = onBetween;
				m_onEnd = onEnd;
				m_fadeDuration = fadeDuration;
				_ditherfade.StartFadeCoroutine(1f, 0f, fadeDuration, m_onStartDitherFadeEnd);
			}
			else
			{
				onBetween?.Invoke();
				if (base.IsVisible)
				{
					OnBetweenDitherEnd(fadeDuration, onEnd);
				}
			}
		}

		private void OnBetweenDitherEnd(float fadeDuration, Action onEnd)
		{
			_ditherfade.StartFadeCoroutine(0f, 1f, fadeDuration, m_onEndMethodAction);
		}

		private void OnFadeAllEnd()
		{
			if (m_onEnd != null)
			{
				m_onEnd();
				m_onEnd = null;
			}
		}

		public override void ReadyToSmooth(float duration)
		{
			_isReadySmooth = true;
			_smoothDuration = duration;
		}

		public override void SetAlpha(float alpha)
		{
			_ditherfade.SetModelAlpha(alpha);
		}

		public override void SetOutlineSize(float size)
		{
			_ditherfade.SetModelOutlineSize(size);
		}

		public override void SetOutlineColor(Color color)
		{
			_ditherfade.SetModelOutlineColor(color);
		}

		private float GetOutlineSize()
		{
			return _ditherfade.GetModelOutlineSize();
		}

		private Color GetOutlineColor()
		{
			return _ditherfade.GetModelOutlineColor();
		}

		private void DisposeSmoothOutlineSize()
		{
			if (_disposeSmoothOutlineSizeChange != null)
			{
				_disposeSmoothOutlineSizeChange.Dispose();
				_disposeSmoothOutlineSizeChange = null;
			}
		}

		public override void StartSmoothOutlineSizeChange(float duration, float after)
		{
			DisposeSmoothOutlineSize();
			_disposeSmoothOutlineSizeChange = Observable.FromMicroCoroutine((CancellationToken _) => RoutineSmoothOutlineSizeChange(duration, after)).Subscribe().AddTo(base.gameObject);
		}

		private IEnumerator RoutineSmoothOutlineSizeChange(float duration, float after)
		{
			float tick = 0f;
			float before = GetOutlineSize();
			while (tick < duration)
			{
				tick += Time.deltaTime;
				SetOutlineSize(Mathf.Lerp(before, after, tick / duration));
				yield return null;
			}
			SetOutlineSize(after);
		}

		private void DisposeSmoothOutlineColor()
		{
			if (_disposeSmoothOutlineColorChange != null)
			{
				_disposeSmoothOutlineColorChange.Dispose();
				_disposeSmoothOutlineColorChange = null;
			}
		}

		public override void StartSmoothOutlineColorChange(float duration, Color after)
		{
			DisposeSmoothOutlineColor();
			_disposeSmoothOutlineColorChange = Observable.FromMicroCoroutine((CancellationToken _) => RoutineSmoothOutlineColorChange(duration, after)).Subscribe().AddTo(base.gameObject);
		}

		private IEnumerator RoutineSmoothOutlineColorChange(float duration, Color after)
		{
			float tick = 0f;
			Color before = GetOutlineColor();
			while (tick < duration)
			{
				tick += Time.deltaTime;
				SetOutlineColor(Color.Lerp(before, after, tick / duration));
				yield return null;
			}
			SetOutlineColor(after);
		}

		public override void SetAttachToChara(AdvChara chara, AdvCharaModel.Node nodeToAttach)
		{
			_nodeToAttach = nodeToAttach;
			_attachedChara = chara;
			chara.OnAttachProp(this, nodeToAttach);
		}

		private void CheckDettachFromChara()
		{
			if (_attachedChara != null)
			{
				_attachedChara.OnDettachProp(this, _nodeToAttach);
				_attachedChara = null;
			}
		}
	}
	public class StaticProp : BaseProp
	{
		public override PropDefines.PropType ThisPropType => PropDefines.PropType.Static;

		protected override void OnChangeVisible(bool flag)
		{
			base.gameObject.SetActive(flag);
		}

		public override void ActionPropAnimation(int index)
		{
		}
	}
	public class BaseScenePropController : MonoBehaviour
	{
		[Header(" Prefab ")]
		[SerializeField]
		[PrefabField]
		private BaseProp[] _prefabPropsList = new BaseProp[0];

		private Transform _thisTransform;

		private Dictionary<int, BaseProp> _instancePropsList;

		public virtual PropDefines.PropType ManagePropType => PropDefines.PropType.Static;

		public int PropCount => _prefabPropsList.Length;

		public BaseProp[] PrefabPropsList
		{
			get
			{
				return _prefabPropsList;
			}
			set
			{
				_prefabPropsList = value;
			}
		}

		private void Awake()
		{
			_thisTransform = base.transform;
			_instancePropsList = new Dictionary<int, BaseProp>();
		}

		public BaseProp GetPropByIndex(int index)
		{
			if (!_instancePropsList.TryGetValue(index, out var value))
			{
				return MakeInstancePropByIndex(index);
			}
			return value;
		}

		private BaseProp MakeInstancePropByIndex(int index)
		{
			BaseProp baseProp = _prefabPropsList[index];
			if (baseProp == null)
			{
				return null;
			}
			BaseProp baseProp2 = UnityEngine.Object.Instantiate(baseProp, _thisTransform, worldPositionStays: false);
			_instancePropsList.Add(index, baseProp2);
			return baseProp2;
		}

		public void MakeInstancePropByList(List<int> indexes)
		{
			if (_instancePropsList.Count > 0)
			{
				ClearAllProps();
			}
			if (_prefabPropsList != null)
			{
				for (int i = 0; i < _prefabPropsList.Length; i++)
				{
					BaseProp baseProp = _prefabPropsList[i];
					if (!(baseProp == null) && baseProp.ShowAlways)
					{
						GetPropByIndex(i).SetVisible(flag: true);
					}
				}
			}
			if (indexes == null)
			{
				return;
			}
			foreach (int index in indexes)
			{
				GetPropByIndex(index);
			}
		}

		public void ClearAllProps()
		{
			foreach (BaseProp value in _instancePropsList.Values)
			{
				UnityEngine.Object.Destroy(value.gameObject);
			}
			_instancePropsList.Clear();
		}

		public void MakeAllInstance()
		{
			for (int i = 0; i < _prefabPropsList.Length; i++)
			{
				GetPropByIndex(i);
			}
		}

		public void SetAllVisible(bool flag)
		{
			foreach (BaseProp value in _instancePropsList.Values)
			{
				value.gameObject.SetActive(flag);
				value.ResetPropTransform();
			}
		}

		public void ResetInstancedProps()
		{
			foreach (BaseProp value in _instancePropsList.Values)
			{
				if (!(value == null))
				{
					value.ResetPropEverything();
				}
			}
		}

		private bool IsValidIndex(int index)
		{
			if (index >= 0)
			{
				return index < _prefabPropsList.Length;
			}
			return false;
		}
	}
	public class DynamicScenePropController : BaseScenePropController
	{
		public override PropDefines.PropType ManagePropType => PropDefines.PropType.Dynamic;
	}
	public class StaticScenePropController : BaseScenePropController
	{
		public override PropDefines.PropType ManagePropType => PropDefines.PropType.Static;
	}
	[Serializable]
	public class PropActionParam
	{
		[NonSerialized]
		public int Index = -1;

		public string TriggerName = "";

		public bool IsValid => Index != -1;
	}
	public static class PropDefines
	{
		public enum PropType
		{
			Static,
			Dynamic
		}

		public enum RelativeModes
		{
			World = 0,
			WorldAdditive = 1,
			Self = 10,
			Player = 20,
			PlayerAvaterBody = 21,
			PlayerAvaterHand = 22,
			Chara = 30,
			CharaNode = 31,
			OtherProp = 40,
			OtherPropAnchor = 41,
			RealHead = 50,
			RealHand = 51,
			RealFoot = 52
		}

		public enum FadeModes
		{
			None,
			Smooth,
			Dither
		}
	}
	public class MirrorPlane : UpdateableComponent
	{
		[SerializeField]
		private Camera _mirrorCamera;

		private Transform _thisTransform;

		private Transform _mirrorCameraTransform;

		private Transform MainCameraTransform => SingletonMonoBehaviour<PlayAreaManager>.Instance.EyeCamera.transform;

		protected override void Initialize()
		{
			_thisTransform = base.transform;
			_mirrorCameraTransform = _mirrorCamera.transform;
		}

		private void OnEnable()
		{
			_mirrorCamera.enabled = true;
		}

		private void OnDisable()
		{
			_mirrorCamera.enabled = false;
		}

		public override void OnUpdate(float delta)
		{
		}

		private void MoveMirrorCamera()
		{
			Vector3 position = MainCameraTransform.position;
			Vector3 localPosition = _thisTransform.InverseTransformPoint(position);
			localPosition.z = 0f;
			_mirrorCameraTransform.localPosition = localPosition;
		}
	}
	public class LoadingObject : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private Transform _targetFetch;

		[SerializeField]
		private Animator _animator;

		[SerializeField]
		private Renderer _renderer;

		[SerializeField]
		private SpriteRenderer _specificRenderer;

		[Header("Parameters")]
		[SerializeField]
		private bool _specificMode;

		[SerializeField]
		private float _delayToShow = 0.5f;

		[SerializeField]
		private float _minimumShowingTime = 0.5f;

		[Header("Parameters - Specific Mode")]
		[SerializeField]
		private Sprite _defaultSprite;

		[Header("Parameters - Random Mode")]
		[SerializeField]
		private Sprite[] _randomSpriteList;

		private bool _isVisible;

		private void Start()
		{
			base.transform.SetParent(SingletonMonoBehaviour<PlayAreaManager>.Instance.VRAreaTransform);
			IObservable<bool> source = SingletonMonoBehaviour<MasterManager>.Instance.OnToggleBusyProcess.Where((bool flag) => flag);
			IObservable<bool> observable = SingletonMonoBehaviour<MasterManager>.Instance.OnToggleBusyProcess.Where((bool flag) => !flag);
			if (_delayToShow > 0f)
			{
				source.SelectMany((bool _) => Observable.Timer(TimeSpan.FromSeconds(_delayToShow))).TakeUntil(observable).Subscribe(delegate
				{
					if (!_isVisible)
					{
						RefreshSprite();
						EmitBusy();
					}
					SetVisible(flag: true);
				})
					.AddTo(base.gameObject);
			}
			else
			{
				source.Subscribe(delegate
				{
					if (!_isVisible)
					{
						RefreshSprite();
						EmitBusy();
					}
					SetVisible(flag: true);
				}).AddTo(base.gameObject);
			}
			observable.Subscribe(delegate
			{
				SetVisible(flag: false);
			}).AddTo(base.gameObject);
		}

		private void EmitBusy()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.AddBusy(this);
			Observable.Timer(TimeSpan.FromSeconds(_minimumShowingTime)).Subscribe(delegate
			{
				SingletonMonoBehaviour<MasterManager>.Instance.RemoveBusy(this);
			}).AddTo(base.gameObject);
		}

		private void RefreshSprite()
		{
			if (_specificMode)
			{
				_specificRenderer.sprite = FindSpecificLoadingSprite(SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID);
			}
			else
			{
				_specificRenderer.sprite = GetRandomLoadingSprite();
			}
		}

		private void SetVisible(bool flag)
		{
			if (_isVisible != flag)
			{
				_isVisible = flag;
				_renderer.enabled = flag;
				_animator.enabled = flag;
				_specificRenderer.enabled = flag;
			}
		}

		private Sprite GetRandomLoadingSprite()
		{
			return _randomSpriteList[UnityEngine.Random.Range(0, _randomSpriteList.Length)];
		}

		private Sprite FindSpecificLoadingSprite(int id)
		{
			Sprite sprite = SingletonMonoBehaviour<DataManager>.Instance.FindLoadingSprite(id);
			if (sprite == null)
			{
				return _defaultSprite;
			}
			return sprite;
		}
	}
	[DisallowMultipleComponent]
	public class MainMenuManager : SingletonMonoBehaviour<MainMenuManager>, ISoundableMenu
	{
		public enum MenuMode
		{
			Closed = -2,
			Blank,
			Home,
			SkipMode,
			Note,
			Save,
			Load,
			Config,
			Help,
			Title,
			MAX
		}

		[Header("Components - Base")]
		[SerializeField]
		private Animator menuAnimator;

		[SerializeField]
		private Canvas menuCanvas;

		[SerializeField]
		private AudioSource uiSoundSource;

		[SerializeField]
		private GraphicRaycaster _thisRaycaster;

		[SerializeField]
		private GraphicRaycaster _mainMenuRaycaster;

		[Header("Components - UI")]
		[SerializeField]
		private MainMenuPositioner positioner;

		[SerializeField]
		private MenuButtonFloater backButton;

		[SerializeField]
		private MenuClock clockUI;

		[Header("Parameters")]
		[Tooltip("")]
		[SerializeField]
		private Color menuFadeColor = Color.black;

		private bool _isOpen;

		private bool _isOnlySub;

		private bool _prohibitByCommand;

		private bool _prohibitByBusyLag;

		private SubMenuManager _subMenuManager;

		private List<bool> m_prohibitions;

		private Subject<bool> _subjectToggleMenu = new Subject<bool>();

		public MenuMode Mode { get; private set; }

		public MenuMode FixedMode { get; set; }

		public bool IsProhibitByCommand
		{
			get
			{
				return _prohibitByCommand;
			}
			set
			{
				_prohibitByCommand = value;
			}
		}

		public bool IsProhibitByTimeline
		{
			get
			{
				if (!SingletonMonoBehaviour<InGameManager>.HasInstance)
				{
					return false;
				}
				if (!InGameManager.Timeline.IsHardSkip)
				{
					return InGameManager.Timeline.MessageProcessor.ForceMode == MessagePlayer.ForceModes.ForceAuto;
				}
				return true;
			}
		}

		public bool IsMenuAvailable
		{
			get
			{
				if (InGameManager.IsReadyInGame && !SingletonMonoBehaviour<MasterManager>.Instance.IsBusy)
				{
					return !_prohibitByBusyLag;
				}
				return false;
			}
		}

		public bool IsOpened => _isOpen;

		public bool IsRootMenu => Mode == MenuMode.Home;

		private UIFader menuFader
		{
			get
			{
				if (!SingletonMonoBehaviour<FadeManager>.HasInstance)
				{
					return null;
				}
				return SingletonMonoBehaviour<FadeManager>.Instance.menuFader;
			}
		}

		private IObservable<Unit> UpdateObserbable => SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable;

		public IObservable<bool> OnToggleMenu => _subjectToggleMenu;

		protected override void InitializeOnAwake()
		{
			_subMenuManager = GetComponent<SubMenuManager>();
			InitProhibitions();
		}

		private void Start()
		{
			menuCanvas.enabled = false;
			menuAnimator.Update(9f);
			menuAnimator.enabled = false;
			_subMenuManager.InitSubmenuByMainMenu(this);
			_subMenuManager.DisableAllSubMenu();
			MakeSubscribes();
			_thisRaycaster.enabled = false;
			_mainMenuRaycaster.enabled = false;
			_isOpen = false;
			Mode = MenuMode.Closed;
		}

		private void InitProhibitions()
		{
			FixedMode = MenuMode.Home;
			IsProhibitByCommand = false;
			m_prohibitions = new List<bool>(8);
			for (int i = 0; i < 8; i++)
			{
				m_prohibitions.Add(item: false);
			}
		}

		public void ResetProhibitions()
		{
			FixedMode = MenuMode.Home;
			IsProhibitByCommand = false;
			for (int i = 0; i < 8; i++)
			{
				m_prohibitions[i] = false;
			}
		}

		private void MakeSubscribes()
		{
			SingletonMonoBehaviour<GameInputManager>.Instance.OnPositionReset.Subscribe(delegate
			{
				Observable.NextFrame().Subscribe(delegate
				{
					ForceSetPositionToMainCamera();
				}).AddTo(base.gameObject);
			}).AddTo(base.gameObject);
			backButton.ClickObservable.Subscribe(delegate
			{
				OnPressBackButton();
			}).AddTo(base.gameObject);
			backButton.AcceptedForcusObservable.Subscribe(delegate
			{
				PlaySeSelect();
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeStartInGame.Subscribe(delegate
			{
				ResetProhibitions();
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeEndInGame.Subscribe(delegate
			{
				ResetProhibitions();
			}).AddTo(base.gameObject);
			IObservable<bool> observable = SingletonMonoBehaviour<MasterManager>.Instance.OnToggleBusyProcess.Where((bool flag) => flag).Share();
			observable.Subscribe(delegate
			{
				_prohibitByBusyLag = true;
				ForceDisappearMenu();
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MasterManager>.Instance.OnToggleBusyProcess.Where((bool flag) => !flag).SelectMany((bool _) => Observable.TimerFrame(40)).TakeUntil(observable)
				.RepeatUntilDestroy(base.gameObject)
				.Subscribe(delegate
				{
					_prohibitByBusyLag = false;
				})
				.AddTo(base.gameObject);
			IObservable<Unit> source = UpdateObserbable.Where((Unit _) => base.enabled).Share();
			source.Where((Unit _) => _isOpen).Subscribe(delegate
			{
				OnUpdateAnimation();
			}).AddTo(base.gameObject);
			source.Where((Unit _) => !_isOpen).Subscribe(delegate
			{
				OnUpdateClosing();
			}).AddTo(base.gameObject);
			OnToggleMenu.Subscribe(delegate(bool flag)
			{
				if (flag)
				{
					SingletonMonoBehaviour<PlayAreaManager>.Instance.AddLaserNeed(this);
				}
				else
				{
					SingletonMonoBehaviour<PlayAreaManager>.Instance.RemoveLaserNeed(this);
				}
			}).AddTo(base.gameObject);
		}

		private void OnEnable()
		{
			menuCanvas.enabled = true;
			clockUI.enabled = true;
		}

		private void OnDisable()
		{
			_subMenuManager.DisableAllSubMenu();
			menuCanvas.enabled = false;
			clockUI.enabled = false;
		}

		private void OnUpdateAnimation()
		{
			if (SetPositionToMainCamera())
			{
				menuAnimator.Play("Close");
				menuAnimator.Update(9f);
				menuAnimator.Play("Open");
			}
			menuAnimator.Update(Time.deltaTime);
		}

		private void OnUpdateClosing()
		{
			if (IsFinishedClose())
			{
				base.enabled = false;
			}
			else
			{
				menuAnimator.Update(Time.deltaTime);
			}
		}

		private bool IsFinishedClose()
		{
			if (_isOpen)
			{
				return false;
			}
			AnimatorStateInfo currentAnimatorStateInfo = menuAnimator.GetCurrentAnimatorStateInfo(0);
			if (!currentAnimatorStateInfo.IsName("Close"))
			{
				return false;
			}
			return currentAnimatorStateInfo.normalizedTime >= 1f;
		}

		public void OpenMenu(MenuMode initialMode = MenuMode.Home)
		{
			if (initialMode == MenuMode.Home)
			{
				if (!IsMenuAvailable)
				{
					return;
				}
				if (IsProhibitByCommand || IsProhibitByTimeline)
				{
					PlaySeErrorCannotOpen();
					return;
				}
				if (FixedMode != 0)
				{
					initialMode = FixedMode;
				}
			}
			ForceSetPositionToMainCamera();
			menuAnimator.SetBool("Open", value: true);
			_thisRaycaster.enabled = true;
			_mainMenuRaycaster.enabled = true;
			_isOpen = true;
			base.enabled = true;
			SetMenuMode(initialMode);
			_isOnlySub = initialMode != MenuMode.Home;
			ToggleMenuFade(flag: true);
			PlaySeOpen();
			_subjectToggleMenu.OnNext(value: true);
		}

		public void CloseMenu()
		{
			_subMenuManager.ForceCloseSubMenu();
			menuAnimator.SetBool("Open", value: false);
			_thisRaycaster.enabled = false;
			_mainMenuRaycaster.enabled = false;
			_isOpen = false;
			Mode = MenuMode.Closed;
			ToggleMenuFade(flag: false);
			PlaySeClose();
			_subjectToggleMenu.OnNext(value: false);
		}

		public void ForceDisappearMenu()
		{
			if (base.enabled)
			{
				_subMenuManager.ForceCloseSubMenu();
				menuAnimator.SetBool("Open", value: false);
				menuAnimator.Update(9f);
				_thisRaycaster.enabled = false;
				_mainMenuRaycaster.enabled = false;
				_isOpen = false;
				Mode = MenuMode.Closed;
				ToggleMenuFade(flag: false);
				_subjectToggleMenu.OnNext(value: false);
				base.enabled = false;
			}
		}

		private void ToggleMenuFade(bool flag)
		{
			if (!(menuFader == null))
			{
				if (flag)
				{
					menuFader.StartFade(menuFadeColor, 0.2f, isDeactivateOnEnd: false);
				}
				else
				{
					menuFader.StartFade(ColorDefine.TransparentBlack, 0.2f, isDeactivateOnEnd: true);
				}
			}
		}

		private void OnPressBackButton()
		{
			if (Mode == MenuMode.Home)
			{
				CloseMenu();
			}
			else
			{
				if (Mode == MenuMode.Closed)
				{
					return;
				}
				if (_subMenuManager.IsOpenedConfirm)
				{
					_subMenuManager.ForceCloseConfirm();
				}
				else if (OnCancelSubMenu())
				{
					if (_isOnlySub)
					{
						CloseMenu();
						return;
					}
					PlaySeCancel();
					SetMenuMode(MenuMode.Home);
				}
			}
		}

		public void OnPressHardwareBackButton()
		{
			OnPressBackButton();
		}

		public void SetMenuMode(MenuMode mode)
		{
			Mode = mode;
			OnChangeMode();
		}

		public void BackToHome()
		{
			if (_isOnlySub)
			{
				CloseMenu();
			}
			else
			{
				SetMenuMode(MenuMode.Home);
			}
		}

		private void OnChangeMode()
		{
			if (Mode == MenuMode.Home)
			{
				OpenHomeMenu();
			}
			else
			{
				OpenSubMenu();
			}
		}

		private void OpenHomeMenu()
		{
			menuAnimator.SetBool("Wipe", value: false);
			menuAnimator.SetBool("Ring", value: true);
			_subMenuManager.ToggleSubMenu(MenuMode.Home);
		}

		private void OpenSubMenu()
		{
			_subMenuManager.ToggleSubMenu(Mode);
			menuAnimator.SetBool("Wipe", value: true);
			if (_subMenuManager.IsCurrentWipesRing())
			{
				menuAnimator.SetBool("Ring", value: false);
			}
		}

		private bool OnCancelSubMenu()
		{
			return _subMenuManager.OnCancelButton();
		}

		public void OpenConfirm(string text, Action<bool> func)
		{
			_subMenuManager.OpenConfirm(new SubMenuBase.ConfirmParam(text, func));
		}

		public bool GetProhibitions(MenuMode target)
		{
			if (target == MenuMode.Closed)
			{
				return false;
			}
			return m_prohibitions[(int)target];
		}

		public void SetProhibitions(MenuMode target, bool flag)
		{
			if (target != MenuMode.Closed)
			{
				m_prohibitions[(int)target] = flag;
			}
		}

		private bool SetPositionToMainCamera()
		{
			return positioner.SetPositionToMainCamera();
		}

		private void ForceSetPositionToMainCamera()
		{
			positioner.SetPositionToMainCamera(forceAdjust: true);
		}

		public void AttachTo(Transform tf)
		{
			positioner.AttachTo(tf);
		}

		public void RevertToParent()
		{
			positioner.RevertToParent();
		}

		public void PlaySeOpen()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Open, uiSoundSource);
		}

		public void PlaySeClose()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Close, uiSoundSource);
		}

		public void PlaySeSelect()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Select, uiSoundSource);
		}

		public void PlaySeDecide()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Decide, uiSoundSource);
		}

		public void PlaySeConfirm()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Confirm, uiSoundSource);
		}

		public void PlaySeCancel()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Cancel, uiSoundSource);
		}

		public void PlaySeError()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Error, uiSoundSource);
		}

		public void PlaySePaging()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Message_Log, uiSoundSource);
		}

		public void PlaySeScrolling()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Message_Log, uiSoundSource);
		}

		private void PlaySeErrorCannotOpen()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Error);
		}
	}
	public class MainMenuPositioner : MonoBehaviour
	{
		[SerializeField]
		private float _autoRotateDegree = 20f;

		private Transform _contentTransform;

		private bool _isAttachedMain;

		public bool IsFixedToFront
		{
			get
			{
				if (!SingletonMonoBehaviour<MainPosition>.HasInstance)
				{
					return false;
				}
				return MainPosition.WindowPositioner.IsFixedToFront;
			}
		}

		public float FrontFixYaw
		{
			get
			{
				if (!SingletonMonoBehaviour<MainPosition>.HasInstance)
				{
					return 0f;
				}
				return MainPosition.WindowPositioner.FrontFixYaw;
			}
		}

		public float FrontFixPitch
		{
			get
			{
				if (!SingletonMonoBehaviour<MainPosition>.HasInstance)
				{
					return 0f;
				}
				return MainPosition.WindowPositioner.FrontFixPitch;
			}
		}

		public bool IsFixVertical
		{
			get
			{
				if (!SingletonMonoBehaviour<MainPosition>.HasInstance)
				{
					return false;
				}
				return MainPosition.WindowPositioner.IsFixVertical;
			}
		}

		private void Awake()
		{
			_contentTransform = base.transform.GetChild(0);
		}

		public void AttachTo(Transform tf)
		{
			_contentTransform.SetParent(tf, worldPositionStays: false);
		}

		public void RevertToParent()
		{
			_contentTransform.SetParent(base.transform, worldPositionStays: false);
		}

		public bool SetPositionToMainCamera(bool forceAdjust = false)
		{
			Transform headTransform = SingletonMonoBehaviour<PlayAreaManager>.Instance.HeadTransform;
			Vector3 position = headTransform.position;
			Quaternion rotation = headTransform.rotation;
			float num = Mathf.DeltaAngle(90f, Vector3.SignedAngle(Vector3.up, rotation * Vector3.forward, rotation * Vector3.right));
			Quaternion quaternion;
			if (IsFixedToFront)
			{
				if (IsFixVertical)
				{
					num = FrontFixPitch;
				}
				quaternion = Quaternion.Euler(num, MainPosition.MainTransform.eulerAngles.y + FrontFixYaw, 0f);
			}
			else
			{
				quaternion = Quaternion.Euler(num, (rotation * Quaternion.Euler(0f - num, 0f, 0f)).eulerAngles.y, 0f);
			}
			if (forceAdjust || Quaternion.Angle(_contentTransform.rotation, quaternion) > _autoRotateDegree)
			{
				_contentTransform.position = position;
				_contentTransform.rotation = quaternion;
				return true;
			}
			return false;
		}
	}
	public class MainMenuButton : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private Transform visualTrans;

		[SerializeField]
		private Button button;

		[SerializeField]
		private Animator anim;

		[SerializeField]
		private Image buttonImage;

		[Header("Parameters")]
		[SerializeField]
		private MainMenuManager.MenuMode targetMode;

		[SerializeField]
		private Sprite _spriteNormal;

		[SerializeField]
		private Sprite _spriteFocused;

		[SerializeField]
		private Sprite _spriteDisabled;

		private bool m_isVisible = true;

		private bool m_isProhivited;

		private bool m_isButtonDown;

		private int m_buttonIndex;

		private Transform m_trans;

		private MainMenuButtonPositioner m_parent;

		private Vector3 m_originPos;

		private float m_floatCount;

		private float m_titleCount;

		public MainMenuManager.MenuMode TargetMode => targetMode;

		private float selectFloatDist => m_parent.selectFloatDist;

		private float selectFloatSpeed => m_parent.selectFloatSpeed;

		private float buttonDownDist => m_parent.buttonDownDist;

		private float titleFloatSpeed => m_parent.titleFloatSpeed;

		private Transform titleTarget => m_parent.titleTarget;

		private int focusIndex => m_parent.GetFocusIndex();

		private void Awake()
		{
			m_trans = base.transform;
			m_originPos = m_trans.localPosition;
			buttonImage.sprite = _spriteNormal;
			UpdateSpriteState();
		}

		private void UpdateSpriteState()
		{
			SpriteState spriteState = button.spriteState;
			spriteState.highlightedSprite = _spriteFocused;
			spriteState.disabledSprite = (m_isProhivited ? _spriteDisabled : _spriteFocused);
			button.spriteState = spriteState;
		}

		public void SetButtonIndex(int i)
		{
			m_buttonIndex = i;
		}

		public void SetParent(MainMenuButtonPositioner p)
		{
			m_parent = p;
		}

		public void Init()
		{
			MakeTriggers();
		}

		private void MakeTriggers()
		{
			ObservableEventTrigger observableEventTrigger = base.gameObject.AddComponent<ObservableEventTrigger>();
			observableEventTrigger.OnPointerEnterAsObservable().Subscribe(delegate(PointerEventData data)
			{
				OnChangeFocused(data, isEntered: true);
			}).AddTo(base.gameObject);
			observableEventTrigger.OnPointerExitAsObservable().Subscribe(delegate(PointerEventData data)
			{
				OnChangeFocused(data, isEntered: false);
			}).AddTo(base.gameObject);
			observableEventTrigger.OnPointerDownAsObservable().Subscribe(delegate(PointerEventData data)
			{
				OnChangePressed(data, isEntered: true);
			}).AddTo(base.gameObject);
			observableEventTrigger.OnPointerUpAsObservable().Subscribe(delegate(PointerEventData data)
			{
				OnChangePressed(data, isEntered: false);
			}).AddTo(base.gameObject);
			button.OnClickAsObservable().Subscribe(delegate
			{
				OnClickButton();
			}).AddTo(base.gameObject);
		}

		private void ChangeFocusIndex()
		{
			m_parent.ChangeFocusIndex(m_buttonIndex);
		}

		private void RemoveFocusIndex()
		{
			if (m_parent.GetFocusIndex() == m_buttonIndex)
			{
				m_parent.ChangeFocusIndex(-1);
			}
		}

		public void UpdateAll()
		{
			UpdatePosition();
			UpdateVisualPosition(Time.deltaTime);
		}

		private void UpdatePosition()
		{
			Vector3 originPos = m_originPos;
			Vector3 localPosition = originPos;
			float num = Time.deltaTime * titleFloatSpeed;
			if (m_parent.isTitled && m_isVisible)
			{
				m_titleCount = Mathf.Min(m_titleCount + num, 1f);
			}
			else
			{
				m_titleCount = Mathf.Max(m_titleCount - num, 0f);
			}
			if (m_titleCount > 0f)
			{
				localPosition = titleTarget.localPosition * m_titleCount + originPos * (1f - m_titleCount);
			}
			m_trans.localPosition = localPosition;
		}

		private void UpdateVisualPosition(float delta)
		{
			Vector3 localPosition = Vector3.zero;
			float num = Mathf.Min(delta * selectFloatSpeed, 1f);
			float num2 = 0f;
			if (m_parent.isTitled)
			{
				m_floatCount = 0f;
			}
			else
			{
				if (focusIndex >= 0)
				{
					num2 = 1f / (1f + (float)Mathf.Abs(focusIndex - m_buttonIndex) * 2f);
					if (m_isButtonDown)
					{
						num2 -= buttonDownDist;
					}
				}
				m_floatCount = num2 * num + m_floatCount * (1f - num);
				localPosition = new Vector3(0f, 0f, (0f - selectFloatDist) * m_floatCount);
			}
			visualTrans.localPosition = localPosition;
		}

		public void ForcePosition()
		{
			UpdateVisualPosition(100f);
		}

		public void ToggleVisible(bool flag)
		{
			anim.SetBool("Visible", flag);
			m_isVisible = flag;
		}

		public void ToggleInteractable(bool flag)
		{
			button.interactable = flag;
		}

		public void ToggleProhibitState(bool flag)
		{
			if (m_isProhivited != flag)
			{
				m_isProhivited = flag;
				UpdateSpriteState();
			}
		}

		private void OnChangeFocused(PointerEventData pointer, bool isEntered)
		{
			if (isEntered)
			{
				ChangeFocusIndex();
			}
			else
			{
				RemoveFocusIndex();
			}
			if (isEntered && button.interactable && !m_isButtonDown)
			{
				GameInputHelper.VibrateLaserForFocus(pointer.GetLaserController());
				SingletonMonoBehaviour<MainMenuManager>.Instance.PlaySeSelect();
			}
		}

		private void OnChangePressed(PointerEventData pointer, bool isEntered)
		{
			m_isButtonDown = isEntered;
			if (isEntered)
			{
				GameInputHelper.VibrateLaserForPress(pointer.GetLaserController());
				if (!button.interactable)
				{
					SingletonMonoBehaviour<MainMenuManager>.Instance.PlaySeError();
				}
			}
		}

		private void OnClickButton()
		{
			SingletonMonoBehaviour<MainMenuManager>.Instance.PlaySeDecide();
			SingletonMonoBehaviour<MainMenuManager>.Instance.SetMenuMode(TargetMode);
		}
	}
	public class MainMenuButtonPositioner : UpdateableComponent
	{
		[SerializeField]
		private float _selectFloatDist = 0.15f;

		[SerializeField]
		private float _selectFloatSpeed = 10f;

		[SerializeField]
		private float _buttonDownDist = 0.05f;

		[SerializeField]
		private float _titleFloatSpeed = 4f;

		[SerializeField]
		private Transform _titleTarget;

		private MainMenuButton[] m_buttons;

		private int m_focusIndex = -1;

		public bool isTitled { get; private set; }

		public float selectFloatDist => _selectFloatDist;

		public float selectFloatSpeed => _selectFloatSpeed;

		public float buttonDownDist => _buttonDownDist;

		public float titleFloatSpeed => _titleFloatSpeed;

		public Transform titleTarget => _titleTarget;

		protected override void Initialize()
		{
			InitButtons();
		}

		private void InitButtons()
		{
			m_buttons = GetComponentsInChildren<MainMenuButton>();
			int num = 0;
			MainMenuButton[] buttons = m_buttons;
			foreach (MainMenuButton obj in buttons)
			{
				obj.SetParent(this);
				obj.SetButtonIndex(num);
				obj.Init();
				num++;
			}
		}

		public void ChangeFocusIndex(int i)
		{
			m_focusIndex = i;
		}

		public int GetFocusIndex()
		{
			return m_focusIndex;
		}

		public void SetTitle(int id)
		{
			isTitled = id != -1;
			for (int i = 0; i < m_buttons.Length; i++)
			{
				MainMenuButton mainMenuButton = m_buttons[i];
				mainMenuButton.ToggleVisible(!isTitled || i == id);
				mainMenuButton.ToggleProhibitState(!GetButtonAllowed(mainMenuButton));
				mainMenuButton.ToggleInteractable(GetButtonAvailable(mainMenuButton));
			}
		}

		public void SetTitleImmediete(int id)
		{
			isTitled = id != -1;
			for (int i = 0; i < m_buttons.Length; i++)
			{
				MainMenuButton mainMenuButton = m_buttons[i];
				mainMenuButton.ToggleVisible(!isTitled || i == id);
				mainMenuButton.ToggleProhibitState(!GetButtonAllowed(mainMenuButton));
				mainMenuButton.ToggleInteractable(GetButtonAvailable(mainMenuButton));
				mainMenuButton.ForcePosition();
			}
		}

		public bool GetButtonAvailable(MainMenuButton button)
		{
			if (isTitled)
			{
				return false;
			}
			return GetButtonAllowed(button);
		}

		public bool GetButtonAllowed(MainMenuButton button)
		{
			MainMenuManager.MenuMode targetMode = button.TargetMode;
			if (SingletonMonoBehaviour<MainMenuManager>.Instance.GetProhibitions(targetMode))
			{
				return false;
			}
			switch (targetMode)
			{
			case MainMenuManager.MenuMode.SkipMode:
				if (SingletonMonoBehaviour<MasterManager>.Instance.IsInGame && InGameManager.Timeline.IsScenarioSkippable)
				{
					return InGameManager.Timeline.IsSkipAllowed;
				}
				return false;
			case MainMenuManager.MenuMode.Note:
				return SingletonMonoBehaviour<MasterManager>.Instance.IsInGame;
			case MainMenuManager.MenuMode.Save:
				return SingletonMonoBehaviour<MasterManager>.Instance.IsInGame;
			case MainMenuManager.MenuMode.Title:
				return !SingletonMonoBehaviour<MasterManager>.Instance.IsTitleScene;
			default:
				return true;
			}
		}

		public override void OnUpdate(float delta)
		{
			MainMenuButton[] buttons = m_buttons;
			for (int i = 0; i < buttons.Length; i++)
			{
				buttons[i].UpdateAll();
			}
		}
	}
	public class MenuButtonFloater : UpdateableComponent
	{
		[Header("Components")]
		[SerializeField]
		private Button buttonComponent;

		[SerializeField]
		private Transform floatTarget;

		[Header("Parameters")]
		[SerializeField]
		private float floatDistFocus = 20f;

		[SerializeField]
		private float floatDistPress = 10f;

		[SerializeField]
		private float floatDistDisabled = 15f;

		[SerializeField]
		private float floatSpeed = 10f;

		[SerializeField]
		private bool hideIfDisabled;

		[Header("Parameters - Text")]
		[SerializeField]
		private TextMeshProUGUI _textLabel;

		[SerializeField]
		private Color _textColorNormal = Color.white;

		[SerializeField]
		private Color _textColorHighlight = Color.white;

		[SerializeField]
		private Color _textColorPressed = Color.white;

		[SerializeField]
		private Color _textColorDisabled = Color.white;

		private Vector3 _originPos;

		private bool _buttonEnabled;

		private bool _focused;

		private bool _pressed;

		private float _floatCount;

		private Graphic _raycastGraphic;

		private IDisposable _disposerFade;

		private Subject<Unit> _subjectAcceptedForcus = new Subject<Unit>();

		private Subject<Unit> _subjectPressDownError = new Subject<Unit>();

		private IObservable<Unit> _onClick;

		public Button ButtonComponent => buttonComponent;

		public bool IsButtonEnabled => _buttonEnabled;

		public bool HideIfDisabled
		{
			get
			{
				return hideIfDisabled;
			}
			set
			{
				hideIfDisabled = value;
			}
		}

		public IObservable<Unit> AcceptedForcusObservable => _subjectAcceptedForcus;

		public IObservable<Unit> PressDownErrorObservable => _subjectPressDownError;

		public IObservable<Unit> ClickObservable => GetObservableClick();

		public IObservable<PointerEventData> OnFocusStart { get; private set; }

		public IObservable<PointerEventData> OnFocusEnd { get; private set; }

		public IObservable<PointerEventData> OnPressStart { get; private set; }

		public IObservable<PointerEventData> OnPressEnd { get; private set; }

		private void Awake()
		{
			_originPos = floatTarget.localPosition;
			_buttonEnabled = buttonComponent.interactable;
			_raycastGraphic = GetComponent<Graphic>();
			MakePointerEvents();
		}

		private void MakePointerEvents()
		{
			ObservableEventTrigger observableEventTrigger = base.gameObject.AddComponent<ObservableEventTrigger>();
			OnFocusStart = observableEventTrigger.OnPointerEnterAsObservable();
			OnFocusEnd = observableEventTrigger.OnPointerExitAsObservable();
			OnPressStart = observableEventTrigger.OnPointerDownAsObservable();
			OnPressEnd = observableEventTrigger.OnPointerUpAsObservable();
			OnFocusStart.Subscribe(delegate(PointerEventData data)
			{
				OnChangeFocus(data, isEntered: true);
			});
			OnFocusEnd.Subscribe(delegate(PointerEventData data)
			{
				OnChangeFocus(data, isEntered: false);
			});
			OnPressStart.Subscribe(delegate(PointerEventData data)
			{
				OnChangePress(data, isEntered: true);
			});
			OnPressEnd.Subscribe(delegate(PointerEventData data)
			{
				OnChangePress(data, isEntered: false);
			});
			base.gameObject.OnEnableAsObservable().Subscribe(delegate
			{
				base.enabled = true;
				UpdateTextColor();
			});
			base.gameObject.OnDisableAsObservable().Subscribe(delegate
			{
				_focused = (_pressed = false);
			});
		}

		public override void OnUpdate(float deltaTime)
		{
			UpdateVisualPosition(deltaTime);
		}

		private void UpdateVisualPosition(float deltaTime)
		{
			Vector3 zero = Vector3.zero;
			float num = Mathf.Min(deltaTime * floatSpeed, 1f);
			float num2 = 0f;
			if (!_buttonEnabled)
			{
				num2 = floatDistDisabled / floatDistFocus;
			}
			else if (_focused && _pressed)
			{
				num2 = floatDistPress / floatDistFocus;
			}
			else if (_focused || _pressed)
			{
				num2 = 1f;
			}
			_floatCount = num2 * num + _floatCount * (1f - num);
			zero = new Vector3(0f, 0f, (0f - floatDistFocus) * _floatCount);
			floatTarget.localPosition = _originPos + zero;
			if (Mathf.Abs(_floatCount - num2) < 0.005f)
			{
				base.enabled = false;
			}
		}

		private void ToggleFocused(bool flag)
		{
			if (_focused != flag)
			{
				_focused = flag;
				base.enabled = true;
				UpdateTextColor();
			}
		}

		private void TogglePressed(bool flag)
		{
			if (_pressed != flag)
			{
				_pressed = flag;
				base.enabled = true;
				UpdateTextColor();
			}
		}

		public void ToggleEnabled(bool flag)
		{
			if (_buttonEnabled != flag)
			{
				_buttonEnabled = flag;
				buttonComponent.interactable = flag;
				if (!flag)
				{
					ToggleFocused(flag: false);
					TogglePressed(flag: false);
				}
				base.enabled = true;
				if (HideIfDisabled)
				{
					AnimateSpriteFade();
				}
				UpdateTextColor();
			}
		}

		private IObservable<Unit> GetObservableClick()
		{
			if (_onClick == null)
			{
				_onClick = buttonComponent.OnClickAsObservable();
			}
			return _onClick;
		}

		private void OnChangeFocus(PointerEventData pointer, bool isEntered)
		{
			ToggleFocused(isEntered);
			if (isEntered && _buttonEnabled && !_pressed)
			{
				GameInputHelper.VibrateLaserForFocus(pointer.GetLaserController());
				_subjectAcceptedForcus.OnNext(Unit.Default);
			}
		}

		private void OnChangePress(PointerEventData pointer, bool isEntered)
		{
			TogglePressed(isEntered);
			if (isEntered)
			{
				GameInputHelper.VibrateLaserForPress(pointer.GetLaserController());
				if (!_buttonEnabled)
				{
					_subjectPressDownError.OnNext(Unit.Default);
				}
			}
		}

		private void UpdateTextColor()
		{
			if (!(_textLabel == null))
			{
				if (!_buttonEnabled)
				{
					_textLabel.color = _textColorDisabled;
				}
				else if (_pressed)
				{
					_textLabel.color = _textColorPressed;
				}
				else if (_focused)
				{
					_textLabel.color = _textColorHighlight;
				}
				else
				{
					_textLabel.color = _textColorNormal;
				}
			}
		}

		private void AnimateSpriteFade()
		{
			if (_disposerFade != null)
			{
				_disposerFade.Dispose();
			}
			if (_raycastGraphic != null)
			{
				_raycastGraphic.raycastTarget = _buttonEnabled;
			}
			if (buttonComponent.targetGraphic != null)
			{
				buttonComponent.targetGraphic.raycastTarget = _buttonEnabled;
			}
			float targetAlpha = (_buttonEnabled ? 1f : 0f);
			_disposerFade = Observable.FromMicroCoroutine((CancellationToken _) => RoutineSpriteFade(targetAlpha)).Subscribe(delegate
			{
				_disposerFade = null;
			});
		}

		private IEnumerator RoutineSpriteFade(float alpha)
		{
			Graphic image = buttonComponent.targetGraphic;
			Color end = image.color.WithAlpha(alpha);
			Tweener<Color> tweener = new Tweener<Color>(Color.Lerp);
			tweener.Start(image.color, end, 0.2f);
			while (tweener.IsActive)
			{
				tweener.Update(Time.deltaTime);
				image.color = tweener.CurrentValue;
				yield return null;
			}
		}

		protected override void OnShutdown()
		{
			if (_disposerFade != null)
			{
				_disposerFade.Dispose();
			}
		}

		public void SetWidth(float w)
		{
			GetComponent<RectTransform>().SetWidth(w);
		}

		public void SetSprites(Sprite normal, Sprite selected)
		{
			Image image = buttonComponent.targetGraphic as Image;
			if (image != null)
			{
				image.sprite = normal;
			}
			SpriteState spriteState = buttonComponent.spriteState;
			spriteState.highlightedSprite = selected;
			spriteState.disabledSprite = selected;
			buttonComponent.spriteState = spriteState;
		}
	}
	public class ToggleButtonSet : MonoBehaviour
	{
		private int _currentValue = -1;

		private List<MenuButtonFloater> _buttonsList = new List<MenuButtonFloater>();

		private ISoundableMenu _soundableMenu;

		private Subject<int> _subjectToggleClick = new Subject<int>();

		public int CurrentValue
		{
			get
			{
				return _currentValue;
			}
			set
			{
				SetToggle(value);
			}
		}

		public IObservable<int> OnClickToggle => _subjectToggleClick;

		public ISoundableMenu SoundableMenu
		{
			set
			{
				_soundableMenu = value;
			}
		}

		public void AddToggleButton(MenuButtonFloater button)
		{
			int index = _buttonsList.Count;
			_buttonsList.Add(button);
			button.ClickObservable.Subscribe(delegate
			{
				if (_soundableMenu != null)
				{
					_soundableMenu.PlaySeDecide();
				}
				SetToggle(index);
				_subjectToggleClick.OnNext(index);
			}).AddTo(base.gameObject);
			button.AcceptedForcusObservable.Subscribe(delegate
			{
				if (_soundableMenu != null)
				{
					_soundableMenu.PlaySeSelect();
				}
			}).AddTo(base.gameObject);
		}

		public void SetToggle(int index)
		{
			_currentValue = index;
			for (int i = 0; i < _buttonsList.Count; i++)
			{
				_buttonsList[i].ToggleEnabled(i != index);
			}
		}
	}
	public interface ISoundableMenu
	{
		void PlaySeOpen();

		void PlaySeClose();

		void PlaySeSelect();

		void PlaySeDecide();

		void PlaySeConfirm();

		void PlaySeCancel();

		void PlaySeError();

		void PlaySePaging();

		void PlaySeScrolling();
	}
	public class APMImage : MonoBehaviour
	{
		[SerializeField]
		private Image image;

		[SerializeField]
		private Sprite spriteAM;

		[SerializeField]
		private Sprite spritePM;

		public void ChangeImage(bool isPM)
		{
			image.sprite = (isPM ? spritePM : spriteAM);
		}

		public void SetVisible(bool visible)
		{
			if (image.enabled != visible)
			{
				image.enabled = visible;
			}
		}
	}
	public class BacklogPanel : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private RectTransform _thisRect;

		[SerializeField]
		private Image _backImage;

		[SerializeField]
		private TextMeshProUGUI _TMPName;

		[SerializeField]
		private TextMeshProUGUI _TMPMessage;

		[SerializeField]
		private LayoutElement _layout;

		private bool _isActive;

		private bool _isVisible;

		private float _defaultHeight;

		private bool IsPhisicallyVisible
		{
			get
			{
				if (_isActive)
				{
					return _isVisible;
				}
				return false;
			}
		}

		public bool IsActive => _isActive;

		private void Awake()
		{
			_defaultHeight = _layout.preferredHeight;
		}

		public void SetVisible(bool flag)
		{
			_isVisible = flag;
			UpdateVisible();
		}

		public void CheckVisibility(RectTransform viewTrans, RectTransform parentTrans)
		{
			Rect rect = _thisRect.rect;
			Rect rect2 = viewTrans.rect;
			rect.y += parentTrans.localPosition.y + _thisRect.localPosition.y;
			SetVisible(rect.yMin <= rect2.yMax && rect.yMax >= rect2.yMin);
		}

		public void SetMessageActive(bool flag)
		{
			_isActive = flag;
			_layout.ignoreLayout = !flag;
			_layout.preferredHeight = (flag ? _defaultHeight : 0f);
			UpdateVisible();
		}

		public void UpdateVisible()
		{
			bool isPhisicallyVisible = IsPhisicallyVisible;
			_backImage.enabled = isPhisicallyVisible;
			_TMPName.enabled = isPhisicallyVisible;
			_TMPMessage.enabled = isPhisicallyVisible;
		}

		public void SetNameText(string str)
		{
			_TMPName.text = str;
		}

		public void SetMessageText(string str)
		{
			_TMPMessage.text = str;
		}

		public void Clear()
		{
			_TMPName.text = "";
			_TMPMessage.text = "";
			SetMessageActive(flag: false);
		}
	}
	public abstract class BaseConfigPart : MonoBehaviour
	{
		[Header("Components - Labels")]
		[SerializeField]
		private TextMeshProUGUI _labelComponent;

		[Header("Base Parameters")]
		[SerializeField]
		private SubMenuConfig.ConfigTypes type;

		public SubMenuConfig.ConfigTypes ConfigType => type;

		public string LabelText
		{
			set
			{
				if (_labelComponent != null)
				{
					_labelComponent.text = value;
				}
			}
		}

		public virtual IObservable<int> ValueSelectedObservable => null;

		public virtual int CurrentValueInt
		{
			get
			{
				return -1;
			}
			set
			{
			}
		}

		public virtual void SetSoundableMenu(ISoundableMenu ism)
		{
		}

		private void Start()
		{
			SubMenuConfig.ConfigTypes configTypes = type;
			if (configTypes == SubMenuConfig.ConfigTypes.PreferredHand && SingletonMonoBehaviour<GameInputManager>.Instance.IsOneSideController)
			{
				base.gameObject.SetActive(value: false);
			}
		}
	}
	public class ConfigPartToggles : BaseConfigPart
	{
		[Serializable]
		public class ToggleParam
		{
			public float Width = 16f;

			public Sprite SpriteNormal;

			public Sprite SpriteSelected;
		}

		[Header("Prefabs - Button")]
		[SerializeField]
		private MenuButtonFloater _prefabButton;

		[Header("Components - Toggle")]
		[SerializeField]
		private ToggleButtonSet _toggleButtonSet;

		[Header("Parameters - Toggle Setting")]
		[SerializeField]
		private ToggleParam[] _toggleParams;

		public override IObservable<int> ValueSelectedObservable => _toggleButtonSet.OnClickToggle;

		public override int CurrentValueInt
		{
			get
			{
				return _toggleButtonSet.CurrentValue;
			}
			set
			{
				_toggleButtonSet.CurrentValue = value;
			}
		}

		private void Awake()
		{
			Transform parent = _toggleButtonSet.transform;
			ToggleParam[] toggleParams = _toggleParams;
			foreach (ToggleParam toggleParam in toggleParams)
			{
				MenuButtonFloater menuButtonFloater = UnityEngine.Object.Instantiate(_prefabButton, parent, worldPositionStays: false);
				menuButtonFloater.SetSprites(toggleParam.SpriteNormal, toggleParam.SpriteSelected);
				menuButtonFloater.SetWidth(toggleParam.Width);
				_toggleButtonSet.AddToggleButton(menuButtonFloater);
			}
		}

		public override void SetSoundableMenu(ISoundableMenu ism)
		{
			_toggleButtonSet.SoundableMenu = ism;
		}
	}
	public class DegitImage : MonoBehaviour
	{
		[SerializeField]
		private Image image;

		[SerializeField]
		private Sprite[] spritesNum = new Sprite[10];

		private int _prevDegit = -1;

		public void ChangeImage(int degit)
		{
			if (_prevDegit != degit)
			{
				_prevDegit = degit;
				image.sprite = spritesNum[degit];
			}
		}
	}
	public class FileInfoPage : MonoBehaviour
	{
		[SerializeField]
		private MultiPagePart multiPage;

		[SerializeField]
		private Transform contentsTransform;

		private SubMenuFile _fileMenu;

		private List<FileInfoUI> _fileInfos;

		public MultiPagePart pagePart => multiPage;

		public ISoundableMenu SoundableMenu
		{
			set
			{
				for (int i = 0; i < _fileInfos.Count; i++)
				{
					_fileInfos[i].SoundableMenu = value;
				}
			}
		}

		public void SetParentFileMenu(SubMenuFile parent)
		{
			_fileMenu = parent;
		}

		public void MakeFileInfoUI(FileInfoUI prefab, int amount)
		{
			if (_fileInfos == null)
			{
				_fileInfos = new List<FileInfoUI>();
			}
			for (int i = _fileInfos.Count; i < amount; i++)
			{
				FileInfoUI fileInfoUI = UnityEngine.Object.Instantiate(prefab, contentsTransform, worldPositionStays: false);
				fileInfoUI.SetParentFileMenu(_fileMenu);
				_fileInfos.Add(fileInfoUI);
			}
		}

		public void UpdateInfos(List<GameFileSave.Header> headers, int idStart, bool isLoad)
		{
			for (int i = 0; i < _fileInfos.Count; i++)
			{
				int index = i + idStart;
				_fileInfos[i].InitByHeader(headers[index], isLoad);
			}
		}
	}
	public class FileInfoUI : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private MenuButtonFloater buttonComponent;

		[SerializeField]
		private Image imageThumbnail;

		[SerializeField]
		private TextMeshProUGUI textIndex;

		[SerializeField]
		private TextMeshProUGUI textChapter;

		[SerializeField]
		private TextMeshProUGUI textDate;

		[Header("Parameters")]
		[SerializeField]
		private Color _textColorNormal;

		[SerializeField]
		private Color _textColorFocused;

		private int _fileID;

		private SubMenuFile _fileMenu;

		public ISoundableMenu SoundableMenu { get; set; }

		private void Start()
		{
			MakeSubscribes();
		}

		private void OnEnable()
		{
			SetTextsColor(_textColorNormal);
		}

		public void SetParentFileMenu(SubMenuFile parent)
		{
			_fileMenu = parent;
		}

		public void InitByHeader(GameFileSave.Header head, bool isLoad)
		{
			_fileID = head.fileIndex;
			bool flag = _fileID == 0;
			if (flag)
			{
				textIndex.text = "Auto Save";
			}
			else
			{
				textIndex.text = "File " + _fileID;
			}
			if (head.IsEmpty)
			{
				textChapter.text = "";
				textDate.text = "";
				imageThumbnail.enabled = false;
				buttonComponent.ToggleEnabled(!flag && !isLoad);
			}
			else if (head.IsCorrupted || !SingletonMonoBehaviour<DataManager>.Instance.GeneralData.GetScenarioInfo(head.SequenceID).IsValid)
			{
				textChapter.text = "<sprite=0><sprite=0><sprite=0><sprite=0><sprite=0>";
				textDate.text = "<sprite=0><sprite=0><sprite=0><sprite=0><sprite=0><sprite=0><sprite=0><sprite=0><sprite=0><sprite=0><sprite=0>";
				imageThumbnail.enabled = false;
				buttonComponent.ToggleEnabled(!flag && !isLoad);
			}
			else
			{
				textChapter.text = ChapterChecker.GetFormattedChapterNumber(head.SequenceID);
				textDate.text = head.SavedTime.ToString(GetDateTimeFormat());
				imageThumbnail.enabled = true;
				imageThumbnail.sprite = FindSaveThumbnailSprite(head.SequenceID);
				buttonComponent.ToggleEnabled(!flag || isLoad);
			}
		}

		private Sprite FindSaveThumbnailSprite(int id)
		{
			Sprite sprite = SingletonMonoBehaviour<DataManager>.Instance.FindSaveThumbnailSprite(id);
			if (sprite == null)
			{
				return null;
			}
			return sprite;
		}

		private void MakeSubscribes()
		{
			buttonComponent.ClickObservable.Subscribe(delegate
			{
				OnClickUIButton();
			}).AddTo(base.gameObject);
			buttonComponent.AcceptedForcusObservable.Subscribe(delegate
			{
				if (SoundableMenu != null)
				{
					SoundableMenu.PlaySeSelect();
				}
			}).AddTo(base.gameObject);
			buttonComponent.PressDownErrorObservable.Subscribe(delegate
			{
				if (SoundableMenu != null)
				{
					SoundableMenu.PlaySeError();
				}
			}).AddTo(base.gameObject);
			buttonComponent.OnFocusStart.Subscribe(delegate
			{
				OnChangeFocused(focused: true);
			}).AddTo(base.gameObject);
			buttonComponent.OnFocusEnd.Subscribe(delegate
			{
				OnChangeFocused(focused: false);
			}).AddTo(base.gameObject);
		}

		private string GetDateTimeFormat()
		{
			return "yyyy/MM/dd HH:mm:ss";
		}

		private void OnClickUIButton()
		{
			_fileMenu.OnSelectFile(_fileID);
		}

		private void OnChangeFocused(bool focused)
		{
			if (!buttonComponent.IsButtonEnabled)
			{
				SetTextsColor(_textColorNormal);
			}
			else if (focused)
			{
				SetTextsColor(_textColorFocused);
			}
			else
			{
				SetTextsColor(_textColorNormal);
			}
		}

		private void SetTextsColor(Color color)
		{
			textIndex.color = color;
			textChapter.color = color;
			textDate.color = color;
		}
	}
	public class MenuClock : UpdateableComponent
	{
		[SerializeField]
		private DegitImage[] degits = new DegitImage[4];

		[SerializeField]
		private Image imageColon;

		[SerializeField]
		private APMImage objectAPM;

		[SerializeField]
		private bool is24Hour;

		private void UpdateImagesByTime(DateTime time)
		{
			int num = time.Hour;
			int minute = time.Minute;
			int millisecond = time.Millisecond;
			if (!is24Hour)
			{
				objectAPM.SetVisible(visible: true);
				ChangeAPMImage(num);
				if (num > 12)
				{
					num -= 12;
				}
			}
			else
			{
				objectAPM.SetVisible(visible: false);
			}
			ChangeDegitNumber(0, num / 10);
			ChangeDegitNumber(1, num % 10);
			ChangeDegitNumber(2, minute / 10);
			ChangeDegitNumber(3, minute % 10);
			ChangeColonAppearance(millisecond);
		}

		private void ChangeDegitNumber(int degitId, int degitNumber)
		{
			degits[degitId].ChangeImage(degitNumber);
		}

		private void ChangeColonAppearance(int ms)
		{
			if (ms < 500)
			{
				imageColon.color = Color.white;
			}
			else
			{
				imageColon.color = Color.clear;
			}
		}

		private void ChangeAPMImage(int hour)
		{
			objectAPM.ChangeImage(hour >= 12);
		}

		public override void OnUpdate(float deltaTime)
		{
			UpdateImagesByTime(DateTime.Now);
		}
	}
	public class MultiPageContent : UpdateableComponent
	{
		[SerializeField]
		private List<MultiPagePart> pages;

		[SerializeField]
		private MenuButtonFloater buttonPrev;

		[SerializeField]
		private MenuButtonFloater buttonNext;

		private int _currentPageIndex;

		public ISoundableMenu SoundableMenu { get; set; }

		public int CurrentPageIndex => _currentPageIndex;

		private int pageMax => pages.Count - 1;

		protected override void Initialize()
		{
			InitContent(_currentPageIndex);
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			buttonPrev.ClickObservable.Subscribe(delegate
			{
				PagePrev();
			}).AddTo(base.gameObject);
			buttonPrev.AcceptedForcusObservable.Subscribe(delegate
			{
				if (SoundableMenu != null)
				{
					SoundableMenu.PlaySeSelect();
				}
			}).AddTo(base.gameObject);
			buttonNext.ClickObservable.Subscribe(delegate
			{
				PageNext();
			}).AddTo(base.gameObject);
			buttonNext.AcceptedForcusObservable.Subscribe(delegate
			{
				if (SoundableMenu != null)
				{
					SoundableMenu.PlaySeSelect();
				}
			}).AddTo(base.gameObject);
		}

		public override void OnUpdate(float deltaTime)
		{
			if (SingletonMonoBehaviour<GameInputManager>.Instance.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.Left))
			{
				PagePrev();
			}
			if (SingletonMonoBehaviour<GameInputManager>.Instance.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.Right))
			{
				PageNext();
			}
		}

		public void InitContent(int firstPage = -1)
		{
			if (pages == null)
			{
				pages = new List<MultiPagePart>();
				return;
			}
			_currentPageIndex = firstPage;
			for (int i = 0; i < pages.Count; i++)
			{
				MultiPagePart multiPagePart = pages[i];
				if (i == firstPage)
				{
					multiPagePart.ToggleVisible(flag: true, isNext: false, isInstant: true);
				}
				else
				{
					multiPagePart.ToggleVisible(flag: false, isNext: false, isInstant: true);
				}
			}
			UpdatePageButton();
		}

		public void AddPage(MultiPagePart page)
		{
			pages.Add(page);
		}

		public void GoToPage(int destPage, bool isInstant = false)
		{
			if (destPage != _currentPageIndex && destPage >= 0 && destPage <= pageMax)
			{
				bool isNext = _currentPageIndex < destPage;
				MultiPagePart multiPagePart = pages[_currentPageIndex];
				MultiPagePart multiPagePart2 = pages[destPage];
				_currentPageIndex = destPage;
				if (multiPagePart != null)
				{
					multiPagePart.ToggleVisible(flag: false, isNext, isInstant);
				}
				if (multiPagePart2 != null)
				{
					multiPagePart2.ToggleVisible(flag: true, isNext, isInstant);
				}
				UpdatePageButton();
			}
		}

		public void PagePrev()
		{
			if (_currentPageIndex > 0)
			{
				GoToPage(_currentPageIndex - 1);
				PageSound();
			}
		}

		public void PageNext()
		{
			if (_currentPageIndex < pageMax)
			{
				GoToPage(_currentPageIndex + 1);
				PageSound();
			}
		}

		private void UpdatePageButton()
		{
			bool flag = _currentPageIndex > 0;
			bool flag2 = _currentPageIndex < pageMax;
			buttonPrev.ToggleEnabled(flag);
			buttonNext.ToggleEnabled(flag2);
		}

		private void PageSound()
		{
			if (SoundableMenu != null)
			{
				SoundableMenu.PlaySePaging();
			}
		}
	}
	public class MultiPageFader : UpdateableComponent
	{
		[SerializeField]
		private Transform moveTarget;

		[SerializeField]
		private CanvasGroup canvasGroup;

		[SerializeField]
		private Vector3 fadeDistance = new Vector3(50f, 0f, 0f);

		[SerializeField]
		private float fadeSpeed = 4f;

		private bool _fading;

		private Vector3 _originPosition;

		private float _fadeValue;

		private float _targetFade;

		private UnityAction _onEndFade;

		private void Awake()
		{
			_originPosition = moveTarget.localPosition;
		}

		private void OnEnable()
		{
			_fading = true;
		}

		private void OnDisable()
		{
			_fading = false;
		}

		public override void OnUpdate(float deltaTime)
		{
			UpdateFadeTick();
			UpdateVisual();
			if (!_fading)
			{
				if (_onEndFade != null)
				{
					_onEndFade();
				}
				base.enabled = false;
			}
		}

		private void UpdateFadeTick()
		{
			bool flag = _fadeValue < _targetFade;
			float num = Time.deltaTime * fadeSpeed * (float)(flag ? 1 : (-1));
			_fadeValue += num;
			if (_fadeValue >= _targetFade == flag)
			{
				_fadeValue = _targetFade;
				_fading = false;
			}
		}

		private void UpdateVisual()
		{
			float num = _fadeValue * _fadeValue * (float)((_fadeValue > 0f) ? 1 : (-1));
			Vector3 localPosition = _originPosition + fadeDistance * num;
			float alpha = 1f - Mathf.Abs(_fadeValue);
			moveTarget.localPosition = localPosition;
			canvasGroup.alpha = alpha;
		}

		public void StartFade(float target)
		{
			base.enabled = true;
			_fading = true;
			_targetFade = target;
		}

		public void StartFade(float target, float start)
		{
			base.enabled = true;
			_fading = true;
			_targetFade = target;
			_fadeValue = start;
		}

		public void SetOnFadeEnd(UnityAction func)
		{
			_onEndFade = func;
		}

		public void ForceSetFade(float fade)
		{
			_fadeValue = fade;
			UpdateVisual();
		}
	}
	public class MultiPagePart : MonoBehaviour
	{
		[SerializeField]
		private CanvasGroup canvasGroup;

		[SerializeField]
		private MultiPageFader fader;

		private bool _visible = true;

		public void ResetPageState()
		{
			ToggleVisible(flag: false, isNext: false, isInstant: true);
		}

		public void ToggleVisible(bool flag, bool isNext, bool isInstant = false)
		{
			if (flag == _visible)
			{
				return;
			}
			if (!_visible)
			{
				OnStartVisible();
			}
			_visible = flag;
			if (isInstant)
			{
				if (_visible)
				{
					fader.ForceSetFade(0f);
				}
				else
				{
					OnEndVisible();
				}
			}
			else if (_visible)
			{
				canvasGroup.alpha = 0f;
				fader.StartFade(0f, isNext ? 1 : (-1));
				fader.SetOnFadeEnd(null);
			}
			else
			{
				fader.StartFade((!isNext) ? 1 : (-1));
				fader.SetOnFadeEnd(OnEndVisible);
			}
		}

		private void OnStartVisible()
		{
			base.gameObject.SetActive(value: true);
			canvasGroup.interactable = true;
		}

		private void OnEndVisible()
		{
			base.gameObject.SetActive(value: false);
			canvasGroup.interactable = false;
		}
	}
	public class SubMenuBacklog : SubMenuBase
	{
		private const int INITIAL_PANEL_INSTANCE = 64;

		private const int INITIALIZE_NUMBER_PER_RESERVE = 16;

		[Header("Prefabs")]
		[SerializeField]
		private BacklogPanel _prefabBacklogPanel;

		[Header("Components")]
		[SerializeField]
		private RectTransform _viewRect;

		[SerializeField]
		private RectTransform _backlogPanelParent;

		[SerializeField]
		private ScrollRect _scrollRect;

		private int _currentIndex = -1;

		private Stack<BacklogPanel> _unusedInstances = new Stack<BacklogPanel>();

		private List<BacklogPanel> _panelInstances = new List<BacklogPanel>();

		private IObservable<Vector2> _observableScroll;

		protected override void SubmenuStart()
		{
			MakeSubscribes();
			MakeInitialInstances();
		}

		private void MakeSubscribes()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.OnLoadCompleteInGame.Subscribe(delegate
			{
				MakeInGameSubscribes();
			}).AddTo(base.gameObject);
			_observableScroll = _scrollRect.OnValueChangedAsObservable();
			_observableScroll.Subscribe(delegate
			{
				foreach (BacklogPanel panelInstance in _panelInstances)
				{
					if (panelInstance.IsActive)
					{
						panelInstance.CheckVisibility(_viewRect, _backlogPanelParent);
					}
				}
			}).AddTo(base.gameObject);
			_observableScroll.ThrottleFirst(TimeSpan.FromSeconds(0.25)).Subscribe(delegate(Vector2 scrolls)
			{
				PlayScrollSound(scrolls);
			}).AddTo(base.gameObject);
			base.UpdateObserbable.Where((Unit _) => base.IsVisible).Subscribe(delegate
			{
				Vector2 vRScrollDelta = SingletonMonoBehaviour<GameInputManager>.Instance.GetVRScrollDelta(SingletonMonoBehaviour<GameInputManager>.Instance.CurrentMainHand);
				if (vRScrollDelta.sqrMagnitude > 0.001f)
				{
					_scrollRect.velocity = vRScrollDelta * -500f;
				}
			});
		}

		private void MakeInGameSubscribes()
		{
			if (SingletonMonoBehaviour<InGameManager>.HasInstance)
			{
				InGameManager.Timeline.PreloadRequestedObservable.Subscribe(delegate(TimelineDataReader dataReader)
				{
					PreMakeBacklog(dataReader.TextMessageList);
				});
				InGameManager.Timeline.MessageProcessor.OnAddMessageLog.Subscribe(delegate
				{
					AddBacklog();
				});
			}
		}

		private void MakeInitialInstances()
		{
			for (int i = 0; i < 64; i++)
			{
				_unusedInstances.Push(MakePanelInstance());
			}
		}

		private void MakeReserveInstances()
		{
			for (int i = 0; i < 16; i++)
			{
				_unusedInstances.Push(MakePanelInstance());
			}
		}

		private BacklogPanel MakePanelInstance()
		{
			BacklogPanel backlogPanel = UnityEngine.Object.Instantiate(_prefabBacklogPanel);
			backlogPanel.transform.SetParent(_backlogPanelParent, worldPositionStays: false);
			backlogPanel.Clear();
			backlogPanel.SetMessageActive(flag: false);
			return backlogPanel;
		}

		private BacklogPanel FindEmptyPanel()
		{
			if (_unusedInstances.Count <= 0)
			{
				MakeReserveInstances();
			}
			BacklogPanel backlogPanel = _unusedInstances.Pop();
			backlogPanel.transform.SetSiblingIndex(_panelInstances.Count);
			_panelInstances.Add(backlogPanel);
			return backlogPanel;
		}

		private void DisableAllPanel()
		{
			foreach (BacklogPanel panelInstance in _panelInstances)
			{
				panelInstance.Clear();
				_unusedInstances.Push(panelInstance);
			}
			_panelInstances.Clear();
			_currentIndex = -1;
		}

		private void AddBacklog()
		{
			_currentIndex++;
			_panelInstances[_currentIndex].SetMessageActive(flag: true);
		}

		public void PreMakeBacklog(List<CommandText> dataList)
		{
			DisableAllPanel();
			foreach (CommandText data in dataList)
			{
				BacklogPanel backlogPanel = FindEmptyPanel();
				backlogPanel.SetMessageText(data.Text);
				backlogPanel.SetNameText(data.CharaFullName);
			}
		}

		private void PlayScrollSound(Vector2 scrolls)
		{
		}

		protected override void OnOpenMenu()
		{
			_scrollRect.verticalScrollbar.value = 0f;
		}
	}
	public abstract class SubMenuBase : MonoBehaviour
	{
		public class ConfirmParam
		{
			public string Message;

			public Action<bool> OnDecide;

			public ConfirmParam(string message, Action<bool> onDecide)
			{
				Message = message;
				OnDecide = onDecide;
			}
		}

		[Header("Components - Base")]
		[SerializeField]
		private Canvas _submenuCanvas;

		[Header("Parameters - Base")]
		[SerializeField]
		private bool wipeRing;

		[SerializeField]
		private int _layerActive;

		[SerializeField]
		private int _layerInactive = -1;

		private bool _isVisible;

		private bool _isEnabled;

		private Animator _anim;

		private GraphicRaycaster _thisRaycaster;

		private Subject<Unit> _subjectEndSubmenu = new Subject<Unit>();

		private Subject<Unit> _subjectMenuCloseRequested = new Subject<Unit>();

		private Subject<ConfirmParam> _subjectConfirmRequested = new Subject<ConfirmParam>();

		private Subject<Unit> _subjectForceCancelConfirmeRequested = new Subject<Unit>();

		public bool isWipeRing => wipeRing;

		public bool IsVisible => _isVisible;

		public bool IsInitedBySubmenu { get; set; }

		public ISoundableMenu SoundableMenu { get; private set; }

		protected IObservable<Unit> UpdateObserbable => SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable;

		public IObservable<Unit> EndSubmenuObservable => _subjectEndSubmenu;

		public IObservable<Unit> MenuCloseRequestedObservable => _subjectMenuCloseRequested;

		public IObservable<ConfirmParam> ConfirmRequestedObservable => _subjectConfirmRequested;

		public IObservable<Unit> ForceCancelConfirmeRequestedObservable => _subjectForceCancelConfirmeRequested;

		private void Awake()
		{
			_thisRaycaster = GetComponent<GraphicRaycaster>();
			_anim = GetComponent<Animator>();
			_anim.enabled = false;
			_isEnabled = base.enabled;
			SubmenuAwake();
		}

		protected virtual void SubmenuAwake()
		{
		}

		private void Start()
		{
			MakeBaseSubscribes();
			SubmenuStart();
		}

		protected virtual void SubmenuStart()
		{
		}

		private void MakeBaseSubscribes()
		{
			UpdateObserbable.Where((Unit _) => base.enabled).Subscribe(delegate
			{
				_anim.Update(Time.deltaTime);
			}).AddTo(base.gameObject);
		}

		public void SetSoundableMenu(ISoundableMenu sound)
		{
			SoundableMenu = sound;
			OnSetSoundableMenu(sound);
		}

		public void ToggleEnable(bool flag)
		{
			if (flag != _isEnabled)
			{
				base.enabled = (_isEnabled = flag);
				base.gameObject.SetActive(flag);
				if (flag)
				{
					_anim.Update(9f);
				}
			}
		}

		public void SetVisible(bool visible)
		{
			if (_isVisible != visible)
			{
				_isVisible = visible;
				ToggleInterractable(visible);
				if (_isVisible)
				{
					ToggleEnable(flag: true);
					OnOpenMenu();
				}
				else
				{
					OnCloseMenu();
				}
				if (_submenuCanvas != null && _submenuCanvas.overrideSorting)
				{
					_submenuCanvas.sortingOrder = (_isVisible ? _layerActive : _layerInactive);
				}
				_anim.SetBool("Visible", _isVisible);
			}
		}

		protected void ToggleInterractable(bool flag)
		{
			_thisRaycaster.enabled = flag;
		}

		protected void BackToHome()
		{
			_subjectEndSubmenu.OnNext(Unit.Default);
		}

		protected void CloseMenu()
		{
			_subjectMenuCloseRequested.OnNext(Unit.Default);
		}

		protected void OpenConfirm(string text, Action<bool> func)
		{
			_subjectConfirmRequested.OnNext(new ConfirmParam(text, func));
		}

		protected void ForceCloseConfirm()
		{
			_subjectForceCancelConfirmeRequested.OnNext(Unit.Default);
		}

		protected virtual void OnOpenMenu()
		{
		}

		protected virtual void OnCloseMenu()
		{
		}

		public virtual bool OnCancelButton()
		{
			return true;
		}

		protected virtual void OnSetSoundableMenu(ISoundableMenu soundMenu)
		{
		}
	}
	public class SubMenuConfig : SubMenuBase
	{
		public enum ConfigTypes
		{
			PlayerHeight,
			MessageHeight,
			MessageSpeed,
			PreferredHand,
			VerticalFollow,
			MAX
		}

		[Header("Components")]
		[SerializeField]
		[EnumLabel(typeof(ConfigTypes))]
		private BaseConfigPart[] _configParts;

		[SerializeField]
		private MultiPageContent multiPage;

		private bool _isConfigValueChanged;

		private ConfigSave ConfigData => SingletonMonoBehaviour<GameData>.Instance.ConfigData;

		protected override void SubmenuStart()
		{
			ToggleEnablePage(flag: false);
			InitConfigStrings();
			MakeSubscribes();
		}

		private void ToggleEnablePage(bool flag)
		{
			multiPage.enabled = flag;
		}

		private void MakeSubscribes()
		{
			BaseConfigPart[] configParts = _configParts;
			foreach (BaseConfigPart baseConfigPart in configParts)
			{
				ConfigTypes type = baseConfigPart.ConfigType;
				baseConfigPart.ValueSelectedObservable.Subscribe(delegate(int index)
				{
					switch (type)
					{
					case ConfigTypes.PlayerHeight:
						ConfigData.PlayerHeight.Value = index - 2;
						break;
					case ConfigTypes.MessageHeight:
						ConfigData.MessageHeight.Value = index - 2;
						break;
					case ConfigTypes.MessageSpeed:
						ConfigData.MessageSpeed.Value = index - 2;
						break;
					case ConfigTypes.PreferredHand:
						if (index == 0)
						{
							ConfigData.PrefferedHand.Value = VRDeviceDefine.HandType.Left;
						}
						else
						{
							ConfigData.PrefferedHand.Value = VRDeviceDefine.HandType.Right;
						}
						break;
					case ConfigTypes.VerticalFollow:
						ConfigData.IsMessageFollowVertical.Value = index == 0;
						break;
					}
					_isConfigValueChanged = true;
				}).AddTo(base.gameObject);
			}
		}

		private void InitConfigStrings()
		{
			for (int i = 0; i < 5; i++)
			{
				BaseConfigPart baseConfigPart = _configParts[i];
				if (!(baseConfigPart == null))
				{
					ConfigTypes configType = baseConfigPart.ConfigType;
					baseConfigPart.LabelText = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString("Config." + configType);
				}
			}
		}

		private void InitButtonToggles()
		{
			for (int i = 0; i < 5; i++)
			{
				BaseConfigPart baseConfigPart = _configParts[i];
				if (!(baseConfigPart == null))
				{
					SetButtonToggles(baseConfigPart);
				}
			}
		}

		private void SetButtonToggles(BaseConfigPart buttonSet)
		{
			ConfigTypes configType = buttonSet.ConfigType;
			int currentValueInt = -1;
			switch (configType)
			{
			case ConfigTypes.PlayerHeight:
				currentValueInt = ConfigData.PlayerHeight.Value + 2;
				break;
			case ConfigTypes.MessageHeight:
				currentValueInt = ConfigData.MessageHeight.Value + 2;
				break;
			case ConfigTypes.MessageSpeed:
				currentValueInt = ConfigData.MessageSpeed.Value + 2;
				break;
			case ConfigTypes.PreferredHand:
				if (ConfigData.PrefferedHand.Value == VRDeviceDefine.HandType.Left)
				{
					currentValueInt = 0;
				}
				if (ConfigData.PrefferedHand.Value == VRDeviceDefine.HandType.Right)
				{
					currentValueInt = 1;
				}
				break;
			case ConfigTypes.VerticalFollow:
				currentValueInt = ((!ConfigData.IsMessageFollowVertical.Value) ? 1 : 0);
				break;
			}
			buttonSet.CurrentValueInt = currentValueInt;
		}

		protected override void OnOpenMenu()
		{
			ToggleEnablePage(flag: true);
			_isConfigValueChanged = false;
			InitButtonToggles();
		}

		protected override void OnCloseMenu()
		{
			ToggleEnablePage(flag: false);
			if (_isConfigValueChanged)
			{
				SingletonMonoBehaviour<GameData>.Instance.SaveConfigData();
				_isConfigValueChanged = false;
			}
		}

		protected override void OnSetSoundableMenu(ISoundableMenu soundMenu)
		{
			multiPage.SoundableMenu = soundMenu;
			BaseConfigPart[] configParts = _configParts;
			for (int i = 0; i < configParts.Length; i++)
			{
				configParts[i].SetSoundableMenu(soundMenu);
			}
		}
	}
	public class SubMenuConfirm : SubMenuBase
	{
		[Header("Components")]
		[SerializeField]
		private TextMeshProUGUI _textComponent;

		[SerializeField]
		private MenuButtonFloater _buttonYes;

		[SerializeField]
		private MenuButtonFloater _buttonNo;

		private Action<bool> _onDecide;

		protected override void SubmenuStart()
		{
			_buttonYes.ClickObservable.Subscribe(delegate
			{
				OnChoose(isOk: true);
			}).AddTo(this);
			_buttonYes.AcceptedForcusObservable.Subscribe(delegate
			{
				if (base.SoundableMenu != null)
				{
					base.SoundableMenu.PlaySeSelect();
				}
			}).AddTo(base.gameObject);
			_buttonNo.ClickObservable.Subscribe(delegate
			{
				OnChoose(isOk: false);
			}).AddTo(this);
			_buttonNo.AcceptedForcusObservable.Subscribe(delegate
			{
				if (base.SoundableMenu != null)
				{
					base.SoundableMenu.PlaySeSelect();
				}
			}).AddTo(base.gameObject);
		}

		private void OnChoose(bool isOk)
		{
			_onDecide(isOk);
			SetVisible(visible: false);
			if (isOk)
			{
				base.SoundableMenu.PlaySeDecide();
			}
			else
			{
				base.SoundableMenu.PlaySeCancel();
			}
		}

		public void SetParam(ConfirmParam param)
		{
			SetDialogText(param.Message);
			SetDecideCallback(param.OnDecide);
		}

		public void SetDialogText(string text)
		{
			_textComponent.text = text;
		}

		public void SetDecideCallback(Action<bool> func)
		{
			_onDecide = func;
		}

		public override bool OnCancelButton()
		{
			OnChoose(isOk: false);
			return true;
		}
	}
	public class SubMenuFile : SubMenuBase
	{
		private const int FILEINFO_PER_PAGE = 3;

		[Header("Prefabs")]
		[SerializeField]
		private FileInfoPage prefabInfoPage;

		[SerializeField]
		private FileInfoUI prefabInfoUI;

		[Header("Components")]
		[SerializeField]
		private Transform infoPageTransform;

		[SerializeField]
		private MultiPageContent multiPage;

		[Header("Parameters")]
		[SerializeField]
		private string _keyConfirmLoad = "ConfirmFileLoad";

		[SerializeField]
		private string _keyConfirmSave = "ConfirmFileOverride";

		private bool _isOpenedConfirm;

		private int _selectedId;

		private List<FileInfoPage> _infoPages;

		private int fileCountMax => 30;

		private bool IsMenuLoad => !IsMenuSave;

		private bool IsMenuSave => SingletonMonoBehaviour<MainMenuManager>.Instance.Mode == MainMenuManager.MenuMode.Save;

		protected override void SubmenuAwake()
		{
			ToggleEnablePage(flag: false);
			MakeAllComponents();
		}

		protected override void SubmenuStart()
		{
		}

		private void ToggleEnablePage(bool flag)
		{
			multiPage.enabled = flag;
		}

		private void MakeAllComponents()
		{
			int num = Mathf.CeilToInt(fileCountMax / 3);
			_infoPages = new List<FileInfoPage>();
			for (int i = 0; i < num; i++)
			{
				FileInfoPage fileInfoPage = UnityEngine.Object.Instantiate(prefabInfoPage, infoPageTransform, worldPositionStays: false);
				fileInfoPage.SetParentFileMenu(this);
				fileInfoPage.MakeFileInfoUI(prefabInfoUI, 3);
				multiPage.AddPage(fileInfoPage.pagePart);
				_infoPages.Add(fileInfoPage);
			}
		}

		protected override void OnOpenMenu()
		{
			_isOpenedConfirm = false;
			ToggleEnablePage(flag: true);
			UpdateFileInfos();
			multiPage.InitContent(SingletonMonoBehaviour<GameData>.Instance.SystemData.LastShowedFilePage);
		}

		protected override void OnCloseMenu()
		{
			SingletonMonoBehaviour<GameData>.Instance.SystemData.LastShowedFilePage = multiPage.CurrentPageIndex;
			ToggleEnablePage(flag: false);
		}

		private void UpdateFileInfos()
		{
			List<GameFileSave.Header> headers = SingletonMonoBehaviour<GameData>.Instance.FindHeaders();
			for (int i = 0; i < _infoPages.Count; i++)
			{
				FileInfoPage fileInfoPage = _infoPages[i];
				int idStart = 3 * i;
				fileInfoPage.UpdateInfos(headers, idStart, IsMenuLoad);
			}
		}

		public void OnSelectFile(int fileID)
		{
			if (_isOpenedConfirm)
			{
				return;
			}
			_isOpenedConfirm = true;
			ToggleInterractable(flag: false);
			_selectedId = fileID;
			if (IsMenuLoad)
			{
				OpenConfirm(string.Format(SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_keyConfirmLoad), GetFileName(fileID)), OnDecideLoad);
			}
			else if (IsMenuSave)
			{
				if (SingletonMonoBehaviour<GameData>.Instance.FindHeaders()[fileID].IsEmpty)
				{
					base.SoundableMenu.PlaySeDecide();
					OnDecideSave(decide: true);
				}
				else
				{
					OpenConfirm(string.Format(SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_keyConfirmSave), GetFileName(fileID)), OnDecideSave);
				}
			}
		}

		private void OnDecideLoad(bool decide)
		{
			_isOpenedConfirm = false;
			if (!decide)
			{
				ToggleInterractable(flag: true);
			}
			else
			{
				StartLoadGame(_selectedId);
			}
		}

		private void OnDecideSave(bool decide)
		{
			_isOpenedConfirm = false;
			if (!decide)
			{
				ToggleInterractable(flag: true);
				return;
			}
			SingletonMonoBehaviour<MasterManager>.Instance.SaveGame(_selectedId);
			BackToHome();
		}

		private string GetFileName(int fileID)
		{
			if (fileID == 0)
			{
				return "Auto Save";
			}
			return "File " + fileID;
		}

		protected virtual void StartLoadGame(int fileId)
		{
			SingletonMonoBehaviour<LocalData>.Instance.ChangeCharacter(GameDefine.CharaID.NONE);
			SingletonMonoBehaviour<MasterManager>.Instance.StartScenarioFromFileWithFade(fileId);
			CloseMenu();
		}

		protected override void OnSetSoundableMenu(ISoundableMenu soundMenu)
		{
			multiPage.SoundableMenu = soundMenu;
			for (int i = 0; i < _infoPages.Count; i++)
			{
				FileInfoPage fileInfoPage = _infoPages[i];
				if (!(fileInfoPage == null))
				{
					fileInfoPage.SoundableMenu = base.SoundableMenu;
				}
			}
		}
	}
	public class SubMenuHelp : SubMenuBase
	{
		[Header("Components")]
		[SerializeField]
		private Image _targetImage;

		[Header("Parameters - Key")]
		[SerializeField]
		private string _keyPrefix = "Help.";

		protected override void OnOpenMenu()
		{
			string key = _keyPrefix + SingletonMonoBehaviour<PlayAreaManager>.Instance.CurrentDeviceType;
			_targetImage.sprite = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeSprite(key);
		}
	}
	public class SubMenuManager : MonoBehaviour
	{
		[Header("Submenu Components")]
		[EnumLabel(typeof(MainMenuManager.MenuMode))]
		[SerializeField]
		private SubMenuBase[] _subMenus;

		[Header("Dialog Components")]
		[SerializeField]
		private SubMenuConfirm _subMenuConfirm;

		[Header("Other Components")]
		[SerializeField]
		private MainMenuButtonPositioner _menuPoser;

		private SubMenuBase _currentSub;

		public bool IsOpenedConfirm => _subMenuConfirm.IsVisible;

		public void InitSubmenuByMainMenu(MainMenuManager mm)
		{
			SubMenuBase[] subMenus = _subMenus;
			foreach (SubMenuBase subMenuBase in subMenus)
			{
				if (!(subMenuBase == null) && !subMenuBase.IsInitedBySubmenu)
				{
					subMenuBase.IsInitedBySubmenu = true;
					subMenuBase.SetSoundableMenu(mm);
					subMenuBase.EndSubmenuObservable.Subscribe(delegate
					{
						mm.BackToHome();
					});
					subMenuBase.MenuCloseRequestedObservable.Subscribe(delegate
					{
						mm.CloseMenu();
					});
					subMenuBase.ConfirmRequestedObservable.Subscribe(delegate(SubMenuBase.ConfirmParam conf)
					{
						OpenConfirm(conf);
					});
				}
			}
			_subMenuConfirm.SetSoundableMenu(mm);
		}

		public void ToggleSubMenu(MainMenuManager.MenuMode tp)
		{
			if (tp != MainMenuManager.MenuMode.Closed)
			{
				SetMenuTitle(tp);
				CloseCurrentSubMenu();
				if (tp != 0 && tp != MainMenuManager.MenuMode.Blank)
				{
					ShowSubMenu(tp);
				}
			}
		}

		private void ShowSubMenu(MainMenuManager.MenuMode tp)
		{
			SubMenuBase subMenuBase = _subMenus[(int)tp];
			if (!(subMenuBase == null))
			{
				subMenuBase.SetVisible(visible: true);
				_currentSub = subMenuBase;
			}
		}

		private void CloseCurrentSubMenu()
		{
			if (!(_currentSub == null))
			{
				_currentSub.SetVisible(visible: false);
				_currentSub = null;
			}
		}

		public void DisableAllSubMenu()
		{
			SubMenuBase[] subMenus = _subMenus;
			foreach (SubMenuBase subMenuBase in subMenus)
			{
				if (!(subMenuBase == null))
				{
					subMenuBase.ToggleEnable(flag: false);
				}
			}
			_subMenuConfirm.ToggleEnable(flag: false);
		}

		public void ForceCloseSubMenu()
		{
			CloseCurrentSubMenu();
		}

		public void OpenConfirm(SubMenuBase.ConfirmParam conf)
		{
			SingletonMonoBehaviour<MainMenuManager>.Instance.PlaySeConfirm();
			_subMenuConfirm.SetVisible(visible: true);
			_subMenuConfirm.SetParam(conf);
		}

		public void ForceCloseConfirm()
		{
			_subMenuConfirm.OnCancelButton();
		}

		private void SetMenuTitle(MainMenuManager.MenuMode tp)
		{
			int title = (int)(tp - 1);
			_menuPoser.SetTitle(title);
		}

		public void SetMenuTitleImmediete(MainMenuManager.MenuMode tp)
		{
			int titleImmediete = (int)(tp - 1);
			_menuPoser.SetTitleImmediete(titleImmediete);
		}

		public bool IsCurrentWipesRing()
		{
			if (_currentSub == null)
			{
				return false;
			}
			return _currentSub.isWipeRing;
		}

		public bool OnCancelButton()
		{
			if (_currentSub == null)
			{
				return true;
			}
			return _currentSub.OnCancelButton();
		}
	}
	public class SubMenuNote : SubMenuBase
	{
	}
	public class SubMenuSkip : SubMenuBase
	{
		[Header("Texts")]
		[SerializeField]
		private string _keyConfirmText = "ConfirmSkip";

		private void OnDecide(bool decide)
		{
			if (decide)
			{
				InGameManager.Timeline.StartHardSkip();
				CloseMenu();
			}
			else
			{
				BackToHome();
			}
		}

		protected override void OnOpenMenu()
		{
			string localizeString = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_keyConfirmText);
			OpenConfirm(localizeString, OnDecide);
		}
	}
	public class SubMenuTitle : SubMenuBase
	{
		[Header("Texts")]
		[SerializeField]
		private string _keyConfirmText = "ConfirmBackTitle";

		[SerializeField]
		private string _keyConfirmTextInGame = "ConfirmBackTitleInGame";

		private void OnDecide(bool decide)
		{
			if (decide)
			{
				SingletonMonoBehaviour<LocalData>.Instance.ChangeCharacter(GameDefine.CharaID.NONE);
				SingletonMonoBehaviour<MasterManager>.Instance.AutoSave();
				SingletonMonoBehaviour<MasterManager>.Instance.ExitInGameWithFade();
				CloseMenu();
			}
			else
			{
				BackToHome();
			}
		}

		protected override void OnOpenMenu()
		{
			string text = ((!SingletonMonoBehaviour<MasterManager>.Instance.IsInGame) ? SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_keyConfirmText) : SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_keyConfirmTextInGame));
			OpenConfirm(text, OnDecide);
		}
	}
	public class EmotionImage : MonoBehaviour
	{
		public enum Types
		{
			Angry0,
			Angry1,
			Angry2,
			Ase0,
			Attention,
			Doyo,
			Explanation,
			Guru,
			Heart,
			Impatience,
			Kirakira,
			MAgazine,
			O,
			Smile,
			Surprised,
			Count
		}

		[SerializeField]
		private Ease m_scaleEaseType = Ease.OutBounce;

		[SerializeField]
		private float m_fadeOutDuration = 1f;

		private Tweener m_scaleTween;

		private Tweener m_fadeTween;

		private GameObject m_gameObject;

		private Transform m_transform;

		private SpriteRenderer m_sprite;

		private Vector3 m_startScale;

		private float m_scaleY;

		private float m_monoScale;

		private Transform m_attachTarget;

		private Transform m_lookAt;

		private float m_offsetY;

		private float m_offsetX;

		private bool m_isInitialized;

		private void Start()
		{
			Initialize();
			m_gameObject.SetActive(value: false);
		}

		public void Setup(EmotionImageGenerator.Data data, float tweenDuration, float monoScale)
		{
			m_monoScale = monoScale;
			Initialize();
			SetupTween(tweenDuration);
		}

		private void SetupTween(float duration)
		{
			m_fadeTween = m_sprite.DOFade(0f, m_fadeOutDuration).OnComplete(delegate
			{
				m_gameObject.SetActive(value: false);
			});
			m_fadeTween.SetAutoKill(autoKillOnCompletion: false);
			m_scaleTween = m_transform.DOScaleY(m_transform.localScale.y, duration).SetEase(m_scaleEaseType).OnComplete(delegate
			{
				StartFadeOut();
			});
			m_scaleTween.SetAutoKill(autoKillOnCompletion: false);
		}

		private void Initialize()
		{
			if (!m_isInitialized)
			{
				m_isInitialized = true;
				m_gameObject = base.gameObject;
				m_transform = base.transform;
				m_sprite = GetComponent<SpriteRenderer>();
				m_startScale = m_transform.localScale;
				m_scaleY = m_startScale.y;
				m_startScale.y = 0f;
			}
		}

		public void Open(Transform attachTarget, EmotionImageGenerator.Data data, float duration, ref Vector3 offset, bool isMono, Transform lookAt = null)
		{
			Color color = m_sprite.color;
			color.a = 1f;
			m_sprite.color = color;
			m_lookAt = lookAt;
			m_attachTarget = attachTarget;
			m_offsetY = data.Offset.y;
			m_offsetX = data.Offset.x;
			m_gameObject.SetActive(value: true);
			Vector3 target = m_startScale;
			if (isMono)
			{
				target.y = m_scaleY;
				Vector3Extension.MultiplyTarget(m_monoScale, ref target);
				m_sprite.sprite = data.SpriteMono;
				m_scaleTween.ChangeEndValue(target);
				m_offsetY += target.y - m_scaleY;
				target.y = 0f;
			}
			else
			{
				m_sprite.sprite = data.Sprite;
				m_scaleTween.ChangeEndValue(m_scaleY);
			}
			m_transform.localScale = target;
			UpdateLookAt();
			UpdatePosition(ref offset);
			m_scaleTween.ChangeStartValue(target);
			m_scaleTween.Restart();
		}

		public void StartFadeOut()
		{
			m_fadeTween.Restart();
		}

		private void UpdatePosition(ref Vector3 offset)
		{
			if (!(m_attachTarget == null))
			{
				Vector3 position = m_attachTarget.position;
				m_transform.position = position;
				m_transform.Translate(m_offsetX + offset.x, m_offsetY + offset.y, offset.z, Space.Self);
			}
		}

		private void UpdateLookAt()
		{
			if (m_lookAt != null)
			{
				m_transform.LookAt(m_transform.position + m_lookAt.rotation * Vector3.forward, m_lookAt.rotation * Vector3.up);
			}
		}
	}
	public class EmotionImageGenerator : MonoBehaviour
	{
		[Serializable]
		public class Data
		{
			public Sprite Sprite;

			public Sprite SpriteMono;

			public Vector3 Offset = new Vector3(0f, 1.5f, 0f);
		}

		private const int _POOL_LIST_SIZE = 5;

		[Header("Emotion Sprite Parameters")]
		[SerializeField]
		private List<Data> m_dataList;

		[Header("Misc. Parameters")]
		[SerializeField]
		private float m_emotionDuration = 1f;

		[SerializeField]
		private float m_emotionMonoScale = 2.083f;

		private List<EmotionImage> m_emotions;

		private ListPosition m_emotionListPos;

		private void Awake()
		{
			m_emotions = new List<EmotionImage>(5);
			InitializeTween();
			InitializeListPosition();
		}

		private void InitializeTween()
		{
			Data data = m_dataList[0];
			EmotionImage[] componentsInChildren = GetComponentsInChildren<EmotionImage>();
			int num = componentsInChildren.Length;
			for (int i = 0; i < num; i++)
			{
				componentsInChildren[i].Setup(data, m_emotionDuration, m_emotionMonoScale);
				m_emotions.Add(componentsInChildren[i]);
			}
		}

		private void InitializeListPosition()
		{
			m_emotionListPos = new ListPosition();
			m_emotionListPos.Count = m_emotions.Count;
			m_emotionListPos.Height = 1;
		}

		public void Generate(EmotionImage.Types type, GameDefine.CharaID charaID, ref Vector3 offset)
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(charaID);
			if (!(chara == null))
			{
				Generate(type, chara.Head, ref offset, isMono: false);
			}
		}

		public void GenerateMono(MemoryModeManager memoryModeManager, EmotionImage.Types type, GameDefine.CharaID charaID, ref Vector3 offset)
		{
			AdvMemoryChara advMemoryChara = memoryModeManager.FindCharaType(charaID);
			if (!(advMemoryChara == null))
			{
				Generate(type, advMemoryChara.Head, ref offset, isMono: true);
			}
		}

		public void Generate(EmotionImage.Types type, Transform chara, ref Vector3 offset, bool isMono)
		{
			Data data = m_dataList[(int)type];
			m_emotions[m_emotionListPos.Index].Open(chara, data, m_emotionDuration, ref offset, isMono, MainPosition.MainTransform);
			m_emotionListPos.Next();
		}
	}
	public class AdvBackground : MonoBehaviour
	{
		public const float _DEFAULT_BLEND_WEIGHT = 100f;

		[Header("Scene Properties")]
		[SerializeField]
		private SkinnedMeshRenderer m_skinnedMesh;

		[SerializeField]
		private AudioSource m_ambientSource;

		[SerializeField]
		private GameObject m_background;

		[SerializeField]
		private StaticScenePropController m_propsStatic;

		[SerializeField]
		private DynamicScenePropController m_propsDynamic;

		[Header("Boundary")]
		[Tooltip("")]
		[SerializeField]
		private bool m_overrideBoundary;

		[SerializeField]
		private float m_boundaryRadius = 2f;

		[Header("Clear Color")]
		[Tooltip("")]
		[SerializeField]
		private bool m_forceSetClearColor;

		[SerializeField]
		private Color m_clearColor = ColorDefine.Black;

		[Header("Character Specifics")]
		[SerializeField]
		private AdvCharaTextureSettings m_charaTexture;

		private GameObject m_gameobject;

		public bool HasStaticProps
		{
			get
			{
				if (m_propsStatic != null)
				{
					return m_propsStatic.PropCount > 0;
				}
				return false;
			}
		}

		public bool HasDynamicProps
		{
			get
			{
				if (m_propsDynamic != null)
				{
					return m_propsDynamic.PropCount > 0;
				}
				return false;
			}
		}

		public StaticScenePropController StaticProps
		{
			get
			{
				return m_propsStatic;
			}
			set
			{
				m_propsStatic = value;
			}
		}

		public DynamicScenePropController DynamicProps
		{
			get
			{
				return m_propsDynamic;
			}
			set
			{
				m_propsDynamic = value;
			}
		}

		public AdvCharaTextureSettings CharaTextureSettings => m_charaTexture;

		public AudioSourceFader Audio { get; private set; }

		public bool HasAudioSource => Audio != null;

		private IObservable<Unit> UpdateObserbable => SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable;

		private void Start()
		{
			if (m_forceSetClearColor)
			{
				SingletonMonoBehaviour<PlayAreaManager>.Instance.SetClearColor(m_clearColor);
			}
			if (m_ambientSource != null)
			{
				Audio = new AudioSourceFader(m_ambientSource);
			}
			m_gameobject = base.gameObject;
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			UpdateObserbable.Where((Unit _) => HasAudioSource).Subscribe(delegate
			{
				Audio.Update(Time.deltaTime);
			}).AddTo(base.gameObject);
			base.gameObject.SetActive(SingletonMonoBehaviour<TransitionManager>.Instance.CurrentSceneId == (SceneDefine)base.gameObject.scene.buildIndex);
			SingletonMonoBehaviour<TransitionManager>.Instance.OnCompleteTransition.Subscribe(delegate(Scene scene)
			{
				base.gameObject.SetActive(scene.buildIndex == base.gameObject.scene.buildIndex);
				if (m_overrideBoundary)
				{
					SingletonMonoBehaviour<PlayAreaManager>.Instance.BoundaryRange = m_boundaryRadius;
				}
			}).AddTo(base.gameObject);
		}

		private void OnDestroy()
		{
			if (HasStaticProps)
			{
				StaticProps.ClearAllProps();
			}
			else if (HasDynamicProps)
			{
				DynamicProps.ClearAllProps();
			}
		}

		public void SetBlendShape(CommandEnvironmentBlendShape command)
		{
			SetBlendShape(command.Index, command.Weight);
		}

		public void SetBlendShape(int index, float weight)
		{
			if (!(m_skinnedMesh == null))
			{
				m_skinnedMesh.SetBlendShapeWeight(index, weight);
			}
		}

		public void ProcessPreloadProps(PropDefines.PropType type, List<int> indexes)
		{
			if (type == PropDefines.PropType.Static && HasStaticProps)
			{
				StaticProps.MakeInstancePropByList(indexes);
			}
			else if (type == PropDefines.PropType.Dynamic && HasDynamicProps)
			{
				DynamicProps.MakeInstancePropByList(indexes);
			}
		}

		public BaseScenePropController GetPropControllerByType(PropDefines.PropType type)
		{
			if (type == PropDefines.PropType.Static)
			{
				return StaticProps;
			}
			return DynamicProps;
		}

		public void SetActive(bool isActive)
		{
			if (m_background == null)
			{
				m_gameobject.SetActive(isActive);
			}
			else
			{
				m_background.SetActive(isActive);
			}
		}

		public void ClearScenarioRelations()
		{
			if (HasStaticProps)
			{
				StaticProps.ResetInstancedProps();
			}
			if (HasDynamicProps)
			{
				DynamicProps.ResetInstancedProps();
			}
			if (HasAudioSource)
			{
				Audio.Stop();
			}
		}

		public void ResetAll()
		{
			if (m_skinnedMesh != null)
			{
				m_skinnedMesh.SetBlendShapeWeight(0, 0f);
			}
		}
	}
	public class BokeSphereManager
	{
		public class Data<T>
		{
			public int ID;

			public T Content;

			public Data(int id, T content)
			{
				ID = id;
				Content = content;
			}
		}

		private List<Data<GameObject>> m_prefabss = new List<Data<GameObject>>();

		private List<AsyncOperation> m_requests = new List<AsyncOperation>();

		private GameObject m_sphere;

		public bool IsLoading => m_requests.Count > 0;

		public BokeSphereManager()
		{
			m_sphere = null;
			m_prefabss = new List<Data<GameObject>>();
			m_requests = new List<AsyncOperation>();
		}

		public void LoadAll(List<int> preloadIndexes)
		{
			preloadIndexes?.ForEach(delegate(int id)
			{
				ResourceRequest resourceRequest = Resources.LoadAsync<GameObject>("Prefabs/" + id);
				resourceRequest.completed += delegate(AsyncOperation obj)
				{
					OnLoadComplete(obj, id);
				};
				m_requests.Add(resourceRequest);
			});
		}

		private void OnLoadComplete(AsyncOperation obj, int id)
		{
			m_requests.Remove(obj);
			GameObject gameObject = (obj as ResourceRequest).asset as GameObject;
			if (!(gameObject == null))
			{
				m_prefabss.Add(new Data<GameObject>(id, gameObject));
			}
		}

		private GameObject FindData(int id)
		{
			int count = m_prefabss.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_prefabss[i].ID == id)
				{
					return m_prefabss[i].Content;
				}
			}
			return null;
		}

		public void Play(CommandBokeSphere command)
		{
			GameObject gameObject = FindData((int)command.Envrionment);
			if (!(gameObject == null))
			{
				if (m_sphere != null)
				{
					UnityEngine.Object.Destroy(m_sphere);
					m_sphere = null;
				}
				m_sphere = UnityEngine.Object.Instantiate(gameObject);
				PlaceSphere(command);
				SingletonMonoBehaviour<PlayAreaManager>.Instance.RequestLayerMode(this, PlayAreaManager.LayerModes.BokeSphere);
			}
		}

		private void PlaceSphere(CommandBokeSphere command)
		{
			PlaceSphere(m_sphere.transform, command, SingletonMonoBehaviour<PlayAreaManager>.Instance.CameraAnchorTransform);
		}

		public static void PlaceSphere(Transform sphere, CommandBokeSphere command, Transform anchor)
		{
			if (command.IsPlaceAtPlayer)
			{
				SetParentTransform(sphere, anchor, command.Position);
				SetYawRotation(sphere, command.Rotation);
			}
			else
			{
				sphere.localPosition = command.Position;
				SetYawRotation(sphere, command.Rotation);
			}
		}

		private void SetParentTransform(Transform target, Vector3 offset)
		{
			SetParentTransform(m_sphere.transform, target, offset);
		}

		private static void SetParentTransform(Transform sphere, Transform target, Vector3 offset)
		{
			sphere.SetParent(target, worldPositionStays: false);
			sphere.localPosition = offset;
		}

		private static void SetYawRotation(Transform sphere, float rotation)
		{
			Vector3 localEulerAngles = sphere.localEulerAngles;
			localEulerAngles.y = rotation;
			sphere.localEulerAngles = localEulerAngles;
		}

		public void End(CommandBokeSphereEnd command)
		{
			SingletonMonoBehaviour<PlayAreaManager>.Instance.DisposeLayerMode(this, PlayAreaManager.LayerModes.BokeSphere);
			DestroySphere();
		}

		public void DestroySphere()
		{
			if (m_sphere != null)
			{
				UnityEngine.Object.Destroy(m_sphere);
				m_sphere = null;
			}
		}

		public void Clear()
		{
			SingletonMonoBehaviour<PlayAreaManager>.Instance.DisposeLayerMode(this, PlayAreaManager.LayerModes.BokeSphere);
			DestroySphere();
			int count = m_prefabss.Count;
			for (int i = 0; i < count; i++)
			{
				m_prefabss[i].Content = null;
				m_prefabss[i] = null;
			}
			m_prefabss.Clear();
			Resources.UnloadUnusedAssets();
		}
	}
	public class FocusUpWindowGroup : MonoBehaviour
	{
		[Header("Components - Windows")]
		[SerializeField]
		private ForcusUpWindow[] m_windows;

		public ForcusUpWindow[] Windows => m_windows;

		private void Start()
		{
			if (m_windows == null || m_windows.Length == 0)
			{
				FindWindowFromChild();
				if (m_windows == null || m_windows.Length == 0)
				{
					UnityEngine.Debug.LogWarning("FocusUpGroup: I have no windows so I'm trying to find windows.");
					FindWindowFromChild();
				}
			}
		}

		private void FindWindowFromChild()
		{
			Transform transform = base.transform;
			int childCount = transform.childCount;
			List<ForcusUpWindow> list = new List<ForcusUpWindow>();
			for (int i = 0; i < childCount; i++)
			{
				ForcusUpWindow component = transform.GetChild(i).GetComponent<ForcusUpWindow>();
				if (component != null)
				{
					list.Add(component);
				}
			}
			m_windows = list.ToArray();
		}

		public ForcusUpWindow GetWindow(int id)
		{
			int num = m_windows.Length;
			for (int i = 0; i < num; i++)
			{
				if (m_windows[i].ID == id)
				{
					return m_windows[i];
				}
			}
			return null;
		}

		public ForcusUpWindow FindNextWindow()
		{
			int num = m_windows.Length;
			for (int i = 0; i < num; i++)
			{
				if (!m_windows[i].HasID)
				{
					return m_windows[i];
				}
			}
			return m_windows[0];
		}

		public bool IsBusy()
		{
			int num = m_windows.Length;
			for (int i = 0; i < num; i++)
			{
				if (m_windows[i].IsBusy)
				{
					return true;
				}
			}
			return false;
		}

		public void ForEachAll(Action<ForcusUpWindow> callback)
		{
			int num = m_windows.Length;
			for (int i = 0; i < num; i++)
			{
				callback(m_windows[i]);
			}
		}

		public void ForEachActives(Action<ForcusUpWindow> callback)
		{
			int num = m_windows.Length;
			for (int i = 0; i < num; i++)
			{
				if (m_windows[i].HasID)
				{
					callback(m_windows[i]);
				}
			}
		}

		public void ResetAll()
		{
			int num = m_windows.Length;
			for (int i = 0; i < num; i++)
			{
				m_windows[i].ResetSetting();
				m_windows[i].SetVisible(isVisible: false);
			}
		}

		public void Clear()
		{
			int num = m_windows.Length;
			for (int i = 0; i < num; i++)
			{
				m_windows[i].ClearTexture();
			}
		}
	}
	public class ForcusUpWindow : UpdateableComponent
	{
		public enum FadeType
		{
			Popup,
			Dither,
			Move
		}

		public const float DEFAULT_DISTANCE = 5f;

		[SerializeField]
		private bool m_isDisableOnStart = true;

		[SerializeField]
		private bool m_isResetLocalOnStart = true;

		[SerializeField]
		private Ease m_easeType = Ease.OutBounce;

		[SerializeField]
		private Vector3 m_defaultScale = Vector3.one;

		private GameObject m_gameObject;

		private Transform m_tranform;

		private Material m_material;

		private bool m_isOpen;

		private Vector3 m_target;

		private DitherFade m_ditherFade;

		private Material _editorMaterial;

		public int ID { get; private set; }

		public bool IsBusy { get; private set; }

		public bool HasID => ID != -1;

		protected override void Initialize()
		{
			IsBusy = false;
			m_gameObject = base.gameObject;
			m_tranform = base.transform;
			ID = -1;
			m_target = Vector3Extension.Zero;
			m_material = GetComponent<MeshRenderer>().material;
			m_ditherFade = new DitherFade(base.gameObject);
			if (m_isResetLocalOnStart)
			{
				m_tranform.ResetLocal(isResetPosition: true, isResetRotation: true, isResetScale: false);
			}
			if (m_isDisableOnStart)
			{
				base.gameObject.SetActive(value: false);
			}
		}

		public override void OnUpdate(float delta)
		{
			m_ditherFade.Update(Time.deltaTime);
		}

		public void ClearTexture()
		{
			m_material.mainTexture = null;
		}

		public void OpenWorldPoint(Texture sprite, FadeType fadeType, float duration, int id, Vector3 pos, Vector3 scale, bool isAutoPosition, Ease moveEase = Ease.InOutSine, Action onEndAction = null)
		{
			OnOpen(sprite, pos, id);
			SetupWorldPosition(pos, MainPosition.MainTransform.position);
			Vector3Extension.MultiplyTarget(ref m_defaultScale, ref scale);
			switch (fadeType)
			{
			case FadeType.Popup:
				Popup(duration, scale, onEndAction);
				break;
			case FadeType.Dither:
				OpenDither(duration, scale, onEndAction);
				break;
			case FadeType.Move:
				MoveIn(duration, pos, moveEase, scale, onEndAction);
				break;
			}
		}

		public void Open(Texture sprite, FadeType fadeType, float duration, int id, Vector3 target, float distance, Vector3 offset, Vector3 scale, bool isAutoPosition, Ease moveEase = Ease.InOutSine, Action onEndAction = null)
		{
			OnOpen(sprite, target, id);
			CalculatePosition(target, MainPosition.MainTransform.position, 0f - distance, ref offset);
			Vector3Extension.MultiplyTarget(ref m_defaultScale, ref scale);
			switch (fadeType)
			{
			case FadeType.Popup:
				Popup(duration, scale, onEndAction);
				break;
			case FadeType.Dither:
				OpenDither(duration, scale, onEndAction);
				break;
			case FadeType.Move:
				MoveIn(duration, target, moveEase, scale, onEndAction);
				break;
			}
		}

		public void OnOpen(Texture sprite, Vector3 target, int id = 0)
		{
			ID = id;
			m_isOpen = true;
			IsBusy = true;
			m_gameObject.SetActive(value: true);
			m_material.mainTexture = sprite;
			m_target = target;
		}

		public void SetupWorldPosition(Vector3 pos, Vector3 viewrPosition)
		{
			m_tranform.position = pos;
			m_tranform.LookAt(viewrPosition);
			m_tranform.Rotate(Vector3.up, 180f);
		}

		public void CalculatePosition(Vector3 target, Vector3 viewrPosition, float distance, ref Vector3 offset)
		{
			m_tranform.localRotation = Quaternion.identity;
			Vector3 left = viewrPosition;
			Vector3 a = Vector3Extension.Direction(ref left, ref target);
			Vector3 addAmount = Vector3Extension.Multiply(ref a, distance);
			Vector3Extension.AddTarget(ref left, ref addAmount);
			Vector3Extension.AddTarget(ref left, ref offset);
			m_tranform.position = left;
			m_tranform.LookAt(viewrPosition);
			m_tranform.Rotate(Vector3.up, 180f);
		}

		private void Popup(float duration, Vector3 targetScale, Action onEndAction = null)
		{
			m_ditherFade.SetModelAlpha(1f);
			m_tranform.localScale = Vector3.zero;
			m_tranform.DOScale(targetScale, duration).SetEase(m_easeType).OnComplete(delegate
			{
				IsBusy = false;
				if (onEndAction != null)
				{
					onEndAction();
				}
			});
		}

		public void OpenDither(Texture sprite, Vector3 scale, float duration, Action onEndAction = null)
		{
			OpenDither(duration, scale, onEndAction);
		}

		private void OpenDither(float duration, Vector3 scale, Action onEndAction = null)
		{
			m_tranform.localScale = scale;
			m_ditherFade.SetModelAlpha(0f);
			m_ditherFade.StartFade(1f, duration, delegate
			{
				IsBusy = false;
				if (onEndAction != null)
				{
					onEndAction();
				}
			});
		}

		private void MoveIn(float duration, Vector3 target, Ease moveEase, Vector3 scale, Action onEndAction = null)
		{
			Vector3 localPosition = m_tranform.localPosition;
			m_target = target;
			m_tranform.position = m_target;
			m_tranform.localScale = scale;
			m_ditherFade.SetModelAlpha(1f);
			m_tranform.DOLocalMove(localPosition, duration).SetEase(moveEase).OnComplete(delegate
			{
				IsBusy = false;
				if (onEndAction != null)
				{
					onEndAction();
				}
			});
		}

		public void Close(float duration, FadeType fadeType, Ease moveEase, Action onEndAction = null)
		{
			if (!m_isOpen)
			{
				return;
			}
			m_isOpen = false;
			ID = -1;
			if (duration <= 0f)
			{
				OnClosed();
				return;
			}
			switch (fadeType)
			{
			case FadeType.Popup:
				PopClose(duration, onEndAction);
				break;
			case FadeType.Dither:
				DitherFadeOut(duration, onEndAction);
				break;
			case FadeType.Move:
				MoveOut(duration, moveEase, onEndAction);
				break;
			}
		}

		private void PopClose(float duration, Action onEndAction = null)
		{
			m_tranform.DOScale(Vector3.zero, duration).SetEase(m_easeType).OnComplete(delegate
			{
				if (onEndAction != null)
				{
					onEndAction();
				}
				OnClosed();
			});
		}

		private void DitherFadeOut(float duration, Action onEndAction = null)
		{
			if (duration <= 0f)
			{
				m_ditherFade.SetModelAlpha(0f);
				if (onEndAction != null)
				{
					onEndAction();
				}
				OnClosed();
				return;
			}
			m_ditherFade.StartFade(0f, duration, delegate
			{
				if (onEndAction != null)
				{
					onEndAction();
				}
				OnClosed();
			});
		}

		private void MoveOut(float duration, Ease moveEase, Action onEndAction = null)
		{
			m_tranform.DOMove(m_target, duration).SetEase(moveEase).OnComplete(delegate
			{
				if (onEndAction != null)
				{
					onEndAction();
				}
				OnClosed();
			});
			m_tranform.DOScale(Vector3.zero, duration).SetEase(moveEase);
		}

		public void ChangeTexture(Texture texture, float fadeDuration)
		{
			m_ditherFade.StartFade(0f, fadeDuration, delegate
			{
				m_material.mainTexture = texture;
				m_ditherFade.StartFade(1f, fadeDuration, delegate
				{
					IsBusy = false;
				});
			});
		}

		private void OnClosed()
		{
			ID = -1;
			IsBusy = false;
			m_target = Vector3Extension.Zero;
			m_gameObject.SetActive(value: false);
		}

		public void SetSprite(Texture texture)
		{
			Renderer component = GetComponent<Renderer>();
			if (_editorMaterial == null)
			{
				_editorMaterial = new Material(component.sharedMaterial);
				component.material = _editorMaterial;
			}
			_editorMaterial.mainTexture = texture;
		}

		public void Show()
		{
			SetVisible(isVisible: true);
		}

		public void Hide()
		{
			SetVisible(isVisible: false);
		}

		public void SetVisible(bool isVisible)
		{
			if (m_gameObject != null)
			{
				m_gameObject.SetActive(isVisible);
			}
			else if (base.gameObject != null)
			{
				base.gameObject.SetActive(isVisible);
			}
		}

		public void ResetSetting()
		{
			if (m_gameObject == null && base.gameObject != null)
			{
				m_gameObject = base.gameObject;
			}
			if (m_tranform == null && base.transform != null)
			{
				m_tranform = base.transform;
			}
			if (m_gameObject == null && base.gameObject != null)
			{
				m_gameObject = base.gameObject;
			}
			if (m_tranform == null && base.transform != null)
			{
				m_tranform = base.transform;
			}
			m_tranform.ResetLocal(isResetPosition: true, isResetRotation: true, isResetScale: false);
			m_tranform.localScale = m_defaultScale;
			OnClosed();
		}

		public void SetID(int id)
		{
			ID = id;
		}

		public void SetScale(Vector3 scale)
		{
			base.transform.localScale = Vector3Extension.Multiply(ref scale, ref m_defaultScale);
		}
	}
	public class ForcusUpWindowController : MonoBehaviour
	{
		public class Data<T>
		{
			public int ID;

			public T Content;

			public Data(int id, T content)
			{
				ID = id;
				Content = content;
			}
		}

		public enum SourceType
		{
			Point,
			Chara
		}

		private const string FILE_PATH = "{0}{1:D4}";

		[Header("Externals - Window group")]
		[SerializeField]
		private FocusUpWindowGroup m_windowGroup;

		[Header("Parameters")]
		[SerializeField]
		private float m_windowAnimationDuration = 0.6f;

		[SerializeField]
		private float m_windowCloseAnimationDuration = 0.6f;

		[SerializeField]
		private float m_ditherFadeDuration = 0.3f;

		[SerializeField]
		private float m_windowMoveDuration = 1.25f;

		private List<Data<Texture>> m_textures = new List<Data<Texture>>();

		private List<AsyncOperation> m_requests = new List<AsyncOperation>();

		public bool IsLoading => m_requests.Count > 0;

		public ForcusUpWindow GetWindow(int id)
		{
			return m_windowGroup.GetWindow(id);
		}

		public ForcusUpWindow FindNextWindow()
		{
			return m_windowGroup.FindNextWindow();
		}

		public void LoadAllTextures(List<int> preloadIndexes)
		{
			preloadIndexes?.ForEach(delegate(int id)
			{
				ResourceRequest resourceRequest = Resources.LoadAsync<Texture>(string.Format("{0}{1:D4}", "Textures/Event/", id));
				int currentID = id;
				resourceRequest.completed += delegate(AsyncOperation obj)
				{
					OnLoadComplete(obj, currentID);
				};
				m_requests.Add(resourceRequest);
			});
		}

		private void OnLoadComplete(AsyncOperation obj, int id)
		{
			m_requests.Remove(obj);
			Texture texture = (obj as ResourceRequest).asset as Texture;
			if (!(texture == null))
			{
				m_textures.Add(new Data<Texture>(id, texture));
			}
		}

		public bool IsBusy()
		{
			if (IsLoading)
			{
				return true;
			}
			return m_windowGroup.IsBusy();
		}

		public void OpenWindow(CommandForcusUpWindow command)
		{
			ForcusUpWindow forcusUpWindow = FindNextWindow();
			Texture texture = FindTexture(command.ID);
			if (!(texture == null))
			{
				float fadeDuration = GetFadeDuration(command.FadeType, isOpen: false);
				if (command.Source == SourceType.Chara)
				{
					OpenWindowAtChara(command, forcusUpWindow, fadeDuration, texture);
				}
				else if (command.Source == SourceType.Point)
				{
					forcusUpWindow.OpenWorldPoint(texture, command.FadeType, fadeDuration, command.WindowID, command.TargetPoint, command.Scale, isAutoPosition: true, command.MoveEaseType);
				}
			}
		}

		private void OpenWindowAtChara(CommandForcusUpWindow command, ForcusUpWindow window, float duration, Texture texture)
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(command.Chara);
			if (!(chara == null))
			{
				PrepareChara(chara);
				Transform head = chara.Head;
				window.Open(texture, command.FadeType, duration, command.WindowID, head.position, command.Distance, command.Offset, command.Scale, isAutoPosition: true, command.MoveEaseType);
			}
		}

		private void PrepareChara(AdvChara chara)
		{
			if (!chara.IsActive)
			{
				chara.SetEnable(isEnable: true);
				chara.Model.PlayAnimation(100, isFade: false, isSkipAnimation: true);
				chara.SetEnable(isEnable: false);
			}
		}

		public Texture FindTexture(int id)
		{
			int count = m_textures.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_textures[i].ID == id)
				{
					return m_textures[i].Content;
				}
			}
			return null;
		}

		public void ChangeTexture(int windowID, int id, float fadeDuration)
		{
			ForcusUpWindow window = GetWindow(windowID);
			Texture texture = FindTexture(id);
			if (!(window == null) && !(texture == null))
			{
				window.ChangeTexture(texture, fadeDuration);
			}
		}

		public void CloseAll(bool isSkip, Ease moveEase = Ease.InOutCubic)
		{
			m_windowGroup.ForEachActives(delegate(ForcusUpWindow window)
			{
				CloseWindow(ForcusUpWindow.FadeType.Dither, window, moveEase, isSkip);
			});
		}

		public void CloseWindowByID(ForcusUpWindow.FadeType fadeType, int windowID, Ease moveEase, bool isSkip)
		{
			ForcusUpWindow window = GetWindow(windowID);
			if (!(window == null))
			{
				CloseWindow(fadeType, window, moveEase, isSkip);
			}
		}

		public void CloseWindow(ForcusUpWindow.FadeType fadeType, ForcusUpWindow window, Ease moveEase, bool isSkip)
		{
			if (!(window == null))
			{
				float duration = 0f;
				if (!isSkip)
				{
					duration = GetFadeDuration(fadeType, isOpen: false);
				}
				window.Close(duration, fadeType, moveEase);
			}
		}

		public float GetFadeDuration(ForcusUpWindow.FadeType type, bool isOpen)
		{
			switch (type)
			{
			case ForcusUpWindow.FadeType.Dither:
				return m_ditherFadeDuration;
			case ForcusUpWindow.FadeType.Move:
				return m_windowMoveDuration;
			default:
				if (isOpen)
				{
					return m_windowAnimationDuration;
				}
				return m_windowCloseAnimationDuration;
			}
		}

		public void SetAllWindowVisible(bool isVisible)
		{
			m_windowGroup.ForEachAll(delegate(ForcusUpWindow window)
			{
				window.SetVisible(isVisible);
			});
		}

		public void ResetAll()
		{
			m_windowGroup.ResetAll();
		}

		public void Clear()
		{
			m_windowGroup.Clear();
			int count = m_textures.Count;
			for (int i = 0; i < count; i++)
			{
				Resources.UnloadAsset(m_textures[i].Content);
				m_textures[i].Content = null;
				m_textures[i] = null;
			}
			m_textures.Clear();
			Resources.UnloadUnusedAssets();
		}
	}
	public class GameWindowPositioner : UpdateableComponent
	{
		public enum RotateFixType
		{
			None,
			Yaw,
			Pitch,
			Both
		}

		private const float PITCH_MIN = -100f;

		[Header("Components")]
		[SerializeField]
		private MessageWindowController messageWindows;

		[SerializeField]
		private Transform pitchTransform;

		[Header("Parameters")]
		[SerializeField]
		private float fetchSpeed = 3f;

		[SerializeField]
		private float accelSpeed = 0.5f;

		[SerializeField]
		private float threshouldDegree = 15f;

		[SerializeField]
		private float threshouldPitchChange = 5f;

		[SerializeField]
		private float pitchBetween = 45f;

		[SerializeField]
		private float pitchBase = 5f;

		[SerializeField]
		private float pitchAboveAdd = -10f;

		[SerializeField]
		private bool isTrackPosition;

		private Transform _thisTransform;

		private Quaternion _quatPitch;

		private Quaternion _quatYaw;

		private float _multFetch;

		private float _targetPitch;

		private float _targetYaw;

		public bool IsFixedToFront { get; set; }

		public bool IsFixVertical { get; set; }

		public float FrontFixYaw { get; set; }

		public float FrontFixPitch { get; set; }

		private bool IsFollowVertical => SingletonMonoBehaviour<GameData>.Instance.ConfigData.IsMessageFollowVertical.Value;

		protected override void Initialize()
		{
			_thisTransform = base.transform;
			ResetYaw();
			SingletonMonoBehaviour<GameInputManager>.Instance.OnPositionReset.Subscribe(delegate
			{
				ResetYaw();
			}).AddTo(base.gameObject);
		}

		public override void OnUpdate(float delta)
		{
			if (isTrackPosition)
			{
				MoveToCamera();
			}
			RotateToCamera();
		}

		private void ResetYaw()
		{
			_targetYaw = 0f;
			_quatYaw = Quaternion.Euler(0f, _targetYaw, 0f);
		}

		private void MoveToCamera()
		{
			Transform transform = SingletonMonoBehaviour<PlayAreaManager>.Instance.EyeCamera.transform;
			_thisTransform.position = transform.position;
		}

		private void RotateToCamera()
		{
			float num = Mathf.Clamp01(fetchSpeed * Time.deltaTime);
			Quaternion localRotation = SingletonMonoBehaviour<PlayAreaManager>.Instance.EyeCamera.transform.localRotation;
			float num2 = Mathf.DeltaAngle(90f, Vector3.SignedAngle(Vector3.up, localRotation * Vector3.forward, localRotation * Vector3.right));
			Quaternion quaternion = localRotation * Quaternion.Euler(0f - num2, 0f, 0f);
			float num3 = ((IsFollowVertical && !IsFixVertical) ? Mathf.Clamp(num2, -100f, 0.5f + pitchBase + threshouldPitchChange) : 0f);
			if (Mathf.Abs(Mathf.DeltaAngle(_targetPitch, num3) - pitchBase) >= pitchBetween / 2f + threshouldPitchChange)
			{
				float num4 = Mathf.Round((num3 - pitchBase) / pitchBetween) * pitchBetween;
				if (_targetPitch != num4)
				{
					_targetPitch = num4;
					_quatPitch = Quaternion.Euler(_targetPitch + ((_targetPitch < 0f) ? pitchAboveAdd : 0f), 0f, 0f);
					messageWindows.StartFadeIn();
				}
			}
			float y = quaternion.eulerAngles.y;
			float num5 = Mathf.DeltaAngle(_targetYaw, y);
			if (IsFixedToFront)
			{
				num *= 4f;
				_targetYaw = FrontFixYaw;
			}
			else if (Mathf.Abs(num5) >= threshouldDegree)
			{
				if (_multFetch < 1f)
				{
					_multFetch += Time.deltaTime * accelSpeed;
					if (_multFetch > 1f)
					{
						_multFetch = 1f;
					}
					_targetYaw += num5 * _multFetch;
				}
				else
				{
					_targetYaw = y;
				}
			}
			else if (_multFetch > 0f)
			{
				_multFetch -= Time.deltaTime * accelSpeed;
				if (_multFetch > 0f)
				{
					_targetYaw += num5 * _multFetch;
				}
				else
				{
					_multFetch = 0f;
				}
			}
			_quatYaw = Quaternion.Slerp(_quatYaw, Quaternion.Euler(0f, _targetYaw, 0f), num);
			_thisTransform.localRotation = _quatYaw;
			pitchTransform.localRotation = _quatPitch;
		}

		public void ClearScenarioRelations()
		{
			IsFixedToFront = false;
			IsFixVertical = false;
		}
	}
	public class InGameManager : SingletonMonoBehaviour<InGameManager>
	{
		[Header("Components")]
		[SerializeField]
		private TimelinePlayer _timelinePlayer;

		public static bool IsReadyInGame
		{
			get
			{
				if (SingletonMonoBehaviour<InGameManager>.HasInstance)
				{
					return SingletonMonoBehaviour<InGameManager>.Instance.IsReady;
				}
				return false;
			}
		}

		public static TimelinePlayer Timeline => SingletonMonoBehaviour<InGameManager>.Instance._timelinePlayer;

		public bool IsReady { get; private set; }

		protected override void InitializeOnAwake()
		{
			IsReady = false;
		}

		private void Start()
		{
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeStartInGame.Subscribe(delegate
			{
				SingletonMonoBehaviour<TransitionManager>.Instance.DisposeAllReservedScene();
				DisableReady();
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeEndInGame.Subscribe(delegate
			{
				SingletonMonoBehaviour<TransitionManager>.Instance.DisposeAllReservedScene();
			}).AddTo(base.gameObject);
		}

		public void ReadyOnStart()
		{
			IsReady = true;
			SingletonMonoBehaviour<MasterManager>.Instance.AddBusy(_timelinePlayer);
			_timelinePlayer.ReserveLoadScenerio(SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID);
		}

		public void DisableReady()
		{
			IsReady = false;
		}
	}
	[DisallowMultipleComponent]
	public class MainPosition : SingletonMonoBehaviour<MainPosition>
	{
		[Header("Components")]
		[SerializeField]
		private Transform _contentsTransform;

		[SerializeField]
		private Transform _attachTransform;

		[SerializeField]
		private Transform _frontVoiceLocator;

		[SerializeField]
		private AudioSource _audioSourceEffect;

		[SerializeField]
		private AudioSource _audioSourceVoice;

		[SerializeField]
		private PlayerAvater _playerAvater;

		[SerializeField]
		private GameWindowPositioner _windowPositioner;

		[Header("Parameters")]
		[SerializeField]
		private float _playerHeightMultiply = 0.2f;

		private Transform _myTransform;

		private Transform _cameraTarnsform;

		private Camera _mainCamera;

		private ReactiveProperty<bool> _prohibitHeightChange = new ReactiveProperty<bool>(initialValue: false);

		public static Transform MainTransform => SingletonMonoBehaviour<MainPosition>.Instance._myTransform;

		public static Transform ContentsTransform => SingletonMonoBehaviour<MainPosition>.Instance._contentsTransform;

		public static Transform AttachTransform => SingletonMonoBehaviour<MainPosition>.Instance._attachTransform;

		public static Transform CameraTransform => SingletonMonoBehaviour<MainPosition>.Instance._cameraTarnsform;

		public static Transform FrontVoiceLocator => SingletonMonoBehaviour<MainPosition>.Instance._frontVoiceLocator;

		public static AudioSource AudioSourceEffect => SingletonMonoBehaviour<MainPosition>.Instance._audioSourceEffect;

		public static AudioSource AudioSourceVoice => SingletonMonoBehaviour<MainPosition>.Instance._audioSourceVoice;

		public static Camera MainCamera => SingletonMonoBehaviour<MainPosition>.Instance._MainCamera;

		public static PlayerAvater Avater => SingletonMonoBehaviour<MainPosition>.Instance._playerAvater;

		public static GameWindowPositioner WindowPositioner => SingletonMonoBehaviour<MainPosition>.Instance._windowPositioner;

		private Camera _MainCamera
		{
			get
			{
				if (_mainCamera == null)
				{
					if (SingletonMonoBehaviour<PlayAreaManager>.HasInstance)
					{
						_mainCamera = SingletonMonoBehaviour<PlayAreaManager>.Instance.EyeCamera;
					}
					else
					{
						_mainCamera = Camera.main;
					}
				}
				return _mainCamera;
			}
		}

		private ConfigSave ConfigData => SingletonMonoBehaviour<GameData>.Instance.ConfigData;

		private float PlayerHeight => (float)ConfigData.PlayerHeight.Value * _playerHeightMultiply;

		public bool ProhibitHeightChange
		{
			get
			{
				return _prohibitHeightChange.Value;
			}
			set
			{
				_prohibitHeightChange.Value = value;
			}
		}

		protected override void InitializeOnAwake()
		{
			_myTransform = base.transform;
			base.InitializeOnAwake();
		}

		private void Start()
		{
			if (SingletonMonoBehaviour<MainMenuManager>.HasInstance)
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.AttachTo(_attachTransform);
			}
			_cameraTarnsform = _MainCamera.transform;
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			SetPlayerHeight(ConfigData.PlayerHeight.Value, skipFade: true);
			_prohibitHeightChange.Subscribe(delegate(bool flag)
			{
				if (flag)
				{
					SetPlayerHeight(0);
				}
				else
				{
					SetPlayerHeight(ConfigData.PlayerHeight.Value);
				}
			});
			(from _ in ConfigData.PlayerHeight.SkipLatestValueOnSubscribe()
				where !_prohibitHeightChange.Value
				select _).Subscribe(delegate(int height)
			{
				SetPlayerHeight(height);
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeEndInGame.Subscribe(delegate
			{
				OnBeforeEndGame();
			}).AddTo(base.gameObject);
		}

		private void OnBeforeEndGame()
		{
			if (SingletonMonoBehaviour<MainMenuManager>.HasInstance)
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.RevertToParent();
			}
			SingletonMonoBehaviour<PlayAreaManager>.Instance.BackToInitialParent();
		}

		private void SetPlayerHeight(int heightParam, bool skipFade = false)
		{
			float multipliedPlayerHeight = GetMultipliedPlayerHeight(heightParam);
			Vector3 localPosition = new Vector3(0f, multipliedPlayerHeight, 0f);
			_contentsTransform.localPosition = localPosition;
			if (!skipFade && SingletonMonoBehaviour<FadeManager>.HasInstance)
			{
				SingletonMonoBehaviour<FadeManager>.Instance.FlashFade();
			}
		}

		private float GetMultipliedPlayerHeight(int heightParam)
		{
			return (float)heightParam * _playerHeightMultiply;
		}

		public void ClearScenarioRelations()
		{
			_prohibitHeightChange.Value = false;
			WindowPositioner.ClearScenarioRelations();
			Avater.ClearScquenceRelations();
		}
	}
	public class ChapterChecker
	{
		public const int _CHAPTER_START = 1;

		private static readonly string[] AlphabetCountings = new string[8] { "", "A", "B", "C", "D", "E", "F", "G" };

		public static bool IsHiddenChapterRevealed => SingletonMonoBehaviour<GameData>.Instance.GetFlag(SingletonMonoBehaviour<DataManager>.Instance.GeneralData.NewGameLists.ConditionToRevealHidden);

		public static int GetCurrentChapter()
		{
			return GetChapter(SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID);
		}

		public static int GetChapter(int sequenceID)
		{
			return SingletonMonoBehaviour<DataManager>.Instance.GeneralData.GetScenarioInfo(sequenceID).ChapterNumber;
		}

		public static string GetChapterLocalizeKey(int sequenceID)
		{
			ScenarioListData.Info scenarioInfo = SingletonMonoBehaviour<DataManager>.Instance.GeneralData.GetScenarioInfo(sequenceID);
			ScenarioListData.Categories category = scenarioInfo.Category;
			int chapterNumber = scenarioInfo.ChapterNumber;
			if (category == ScenarioListData.Categories.Special)
			{
				ScenarioListData.SpecialTypes specialType = scenarioInfo.SpecialType;
				if (specialType == ScenarioListData.SpecialTypes.ChapterStart)
				{
					if (chapterNumber <= 19)
					{
						return GetChapterLocalizeKey(1, chapterNumber - 10);
					}
					return GetChapterLocalizeKey(2, chapterNumber - 20);
				}
				return "ChapterNameUnknown";
			}
			return GetChapterLocalizeKey((int)category, chapterNumber);
		}

		public static string GetChapterLocalizeKey(int category, int chapter)
		{
			return $"ChapterName.{category}.{chapter}";
		}

		public static string GetSpecialSceneLocalizeKey(int index)
		{
			return "ChapterNameBonus." + index;
		}

		public static string GetChapterNumberFormatLocalizeKey(ScenarioListData.Categories category)
		{
			return "ChapterFormat." + (int)category;
		}

		public static string GetChapterNumber(ScenarioListData.Categories category, int chapter)
		{
			return category switch
			{
				ScenarioListData.Categories.RouteFirst => chapter.ToString(), 
				ScenarioListData.Categories.RouteSecond => chapter.ToString(), 
				ScenarioListData.Categories.Character => AlphabetCountings[chapter], 
				_ => string.Empty, 
			};
		}

		public static string GetFormattedChapterNumber(int sequenceID)
		{
			ScenarioListData.Info scenarioInfo = SingletonMonoBehaviour<DataManager>.Instance.GeneralData.GetScenarioInfo(sequenceID);
			ScenarioListData.Categories categories = scenarioInfo.Category;
			int num = scenarioInfo.ChapterNumber;
			if (categories == ScenarioListData.Categories.Special)
			{
				ScenarioListData.SpecialTypes specialType = scenarioInfo.SpecialType;
				if (specialType != ScenarioListData.SpecialTypes.Selection)
				{
					return "ChapterNameUnknown";
				}
				switch (num)
				{
				case 0:
					categories = ScenarioListData.Categories.RouteFirst;
					num = 4;
					break;
				case 10:
					categories = ScenarioListData.Categories.RouteSecond;
					num = 2;
					break;
				case 20:
					categories = ScenarioListData.Categories.RouteSecond;
					num = 3;
					break;
				case 30:
					categories = ScenarioListData.Categories.RouteSecond;
					num = 5;
					break;
				case 40:
					categories = ScenarioListData.Categories.RouteSecond;
					num = 6;
					break;
				case 50:
					categories = ScenarioListData.Categories.RouteFirst;
					num = 7;
					break;
				case 60:
					categories = ScenarioListData.Categories.RouteSecond;
					num = 8;
					break;
				}
			}
			string localizeString = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(GetChapterNumberFormatLocalizeKey(categories));
			string chapterNumber = GetChapterNumber(categories, num);
			return string.Format(localizeString, chapterNumber);
		}

		public static string GetChapterCategoryString(ScenarioListData.Categories category)
		{
			return category switch
			{
				ScenarioListData.Categories.RouteFirst => "Chapters", 
				ScenarioListData.Categories.RouteSecond => "Re: Chapters", 
				ScenarioListData.Categories.Character => "Sub Chapters", 
				ScenarioListData.Categories.Special => "Extra", 
				_ => "Unknown", 
			};
		}

		public static NewGameData.ChapterSetting[] GetChapterListData(ScenarioListData.Categories category)
		{
			return category switch
			{
				ScenarioListData.Categories.RouteFirst => SingletonMonoBehaviour<DataManager>.Instance.GeneralData.NewGameLists.ChaptersFirst, 
				ScenarioListData.Categories.RouteSecond => SingletonMonoBehaviour<DataManager>.Instance.GeneralData.NewGameLists.ChaptersSecond, 
				ScenarioListData.Categories.Character => SingletonMonoBehaviour<DataManager>.Instance.GeneralData.NewGameLists.ChaptersCharacter, 
				ScenarioListData.Categories.Special => SingletonMonoBehaviour<DataManager>.Instance.GeneralData.NewGameLists.ChaptersSpecial, 
				_ => new NewGameData.ChapterSetting[0], 
			};
		}
	}
	public class SelectionController : MonoBehaviour
	{
		[Header("Prefabs")]
		[SerializeField]
		private SelectionObject _prefabCharaSelection;

		[SerializeField]
		private SelectionObject _prefabPropSelection;

		[SerializeField]
		private SelectionObject _prefabFocusupSelection;

		[SerializeField]
		private SelectionObject _prefabSelfSelection;

		[Header("Parameters - Durations")]
		[SerializeField]
		private float _fadeStartDuration = 0.5f;

		[SerializeField]
		private float _fadeEndDuration = 1.2f;

		[Header("Parameters - Outlines")]
		[SerializeField]
		private float _outlineSize = 0.25f;

		[Header("Parameters - Colors")]
		[SerializeField]
		private Color _colorWaiting1 = ColorDefine.TransparentBlack;

		[SerializeField]
		private Color _colorWaiting2 = ColorDefine.TransparentWhite;

		[SerializeField]
		private Color _colorHover = ColorDefine.TransparentWhite;

		private List<SelectionObject> _selections;

		private Queue<IDisposable> _disposes;

		private CommandSelection _currentData;

		private int _selectedIndex;

		private bool _isDecided;

		private bool _isSelecting;

		private Subject<int> _subjectPointerEnterSelection = new Subject<int>();

		private Subject<int> _subjectPointerExitSelection = new Subject<int>();

		private AsyncSubject<int> _subjectEndSelection = new AsyncSubject<int>();

		public IObservable<int> PointerEnterSelectionObservable => _subjectPointerEnterSelection;

		public IObservable<int> PointerExitSelectionObservable => _subjectPointerExitSelection;

		public IObservable<int> EndSelectionObservable => _subjectEndSelection;

		private IFader Fader => SingletonMonoBehaviour<FadeManager>.Instance.sceneFader;

		private bool IsNeedSelectionLaser
		{
			get
			{
				if (_currentData != null)
				{
					return _currentData.SelectionMode != SelectionDefines.Modes.Finale;
				}
				return true;
			}
		}

		private bool IsNeedGeneralEffects => _currentData.SelectionMode != SelectionDefines.Modes.Finale;

		public bool IsDecided => _isDecided;

		public bool IsSelecting => _isSelecting;

		public bool ProhibitLaserInterraction { get; set; }

		private void Start()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeExitFade.Where((Unit _) => _isSelecting).Subscribe(delegate
			{
				DisposeSelection();
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MainMenuManager>.Instance.OnToggleMenu.Where((bool _) => _isSelecting && !_isDecided).Subscribe(delegate(bool isMenu)
			{
				SingletonMonoBehaviour<PlayAreaManager>.Instance.ToggleLaserVisible(isMenu);
				foreach (SelectionObject selection in _selections)
				{
					selection.SetInterractable(!isMenu && !ProhibitLaserInterraction);
					selection.SetLaserVibisle(!isMenu && IsNeedSelectionLaser);
				}
			}).AddTo(base.gameObject);
		}

		public void StartSelection(CommandSelection command)
		{
			_isSelecting = true;
			_isDecided = false;
			_currentData = command;
			_disposes = new Queue<IDisposable>();
			if (Fader.IsFadeVisible)
			{
				OnEndIntroFade();
			}
			else
			{
				Fader.StartFade(ColorDefine.Black, _fadeStartDuration, isDeactivateOnEnd: false, OnEndIntroFade);
			}
		}

		private void OnEndIntroFade()
		{
			InitSelections();
			Fader.StartFade(ColorDefine.TransparentBlack, _fadeStartDuration, isDeactivateOnEnd: true);
			PlaySeOpen();
		}

		private void InitSelections()
		{
			_selections = new List<SelectionObject>();
			PrepareData();
			SingletonMonoBehaviour<PlayAreaManager>.Instance.ToggleLaserVisible(flag: false);
			if (!ProhibitLaserInterraction)
			{
				return;
			}
			foreach (SelectionObject selection in _selections)
			{
				selection.SetInterractable(flag: false);
			}
		}

		private void PrepareData()
		{
			for (int i = 0; i < _currentData.SelectionCount; i++)
			{
				CommandSelection.SelectionOptions selectionOptions = _currentData.SelectionList[i];
				switch (selectionOptions.SelectType)
				{
				case SelectionDefines.TargetTypes.Chara:
				{
					GameDefine.CharaID targetChara = selectionOptions.TargetChara;
					AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(targetChara);
					if (!(chara == null))
					{
						MakeCharaSelection(i, chara);
					}
					break;
				}
				case SelectionDefines.TargetTypes.Prop:
				{
					PropDefines.PropType targetPropType = selectionOptions.TargetPropType;
					int targetPropIndex = selectionOptions.TargetPropIndex;
					BaseScenePropController propControllerByType = InGameManager.Timeline.CurrentBackground.GetPropControllerByType(targetPropType);
					if (!(propControllerByType == null))
					{
						BaseProp propByIndex = propControllerByType.GetPropByIndex(targetPropIndex);
						if (!(propByIndex == null))
						{
							MakePropSelection(i, propByIndex);
						}
					}
					break;
				}
				case SelectionDefines.TargetTypes.FocusUp:
				{
					int targetFocusWindowIndex = selectionOptions.TargetFocusWindowIndex;
					ForcusUpWindow window = InGameManager.Timeline.FocusUpProcessor.GetWindow(targetFocusWindowIndex);
					if (!(window == null))
					{
						MakeFocusUpWindowSelection(i, window);
					}
					break;
				}
				case SelectionDefines.TargetTypes.Yourself:
					MakeSelfSelection(i);
					break;
				}
			}
		}

		private SelectionObject MakeSelection(int index, SelectionObject prefab)
		{
			SelectionObject selectionObject = UnityEngine.Object.Instantiate(prefab);
			selectionObject.SelectionIndex = index;
			selectionObject.ColorWaiting1 = _colorWaiting1;
			selectionObject.ColorWaiting2 = _colorWaiting2;
			_selections.Add(selectionObject);
			MakeSelectionSubscribes(selectionObject, index);
			selectionObject.SetLaserVibisle(IsNeedSelectionLaser);
			return selectionObject;
		}

		private void MakeCharaSelection(int index, AdvChara charaObject)
		{
			SelectionObject selectionObject = MakeSelection(index, _prefabCharaSelection);
			charaObject.Model.SetModelOutlineSize(_outlineSize);
			selectionObject.SetParentTransform(charaObject.Transform);
			selectionObject.SetLaserToTransform(charaObject.GetNode(AdvCharaModel.Node.Head));
			selectionObject.OnSelectionEnter.Subscribe(delegate
			{
				charaObject.Model.SetModelOutlineColor(_colorHover);
			}).AddTo(base.gameObject);
			selectionObject.GradiateColorObservable.Subscribe(delegate(Color color)
			{
				charaObject.Model.SetModelOutlineColor(color);
			});
			selectionObject.EndSelectionObservable.Subscribe(delegate(bool selected)
			{
				if (selected)
				{
					charaObject.Model.SetModelOutlineColor(_colorHover);
				}
				else
				{
					charaObject.Model.SetModelOutlineSize(0f);
					charaObject.Model.SetModelOutlineColor(ColorDefine.Black);
				}
			}).AddTo(base.gameObject);
		}

		private void MakePropSelection(int index, BaseProp obj)
		{
			SelectionObject selectionObject = MakeSelection(index, _prefabPropSelection);
			selectionObject.SetParentTransform(obj.AnchorTransform);
			selectionObject.SetLaserToTransform(obj.AnchorTransform);
		}

		private void MakeFocusUpWindowSelection(int index, ForcusUpWindow obj)
		{
			SelectionObject selectionObject = MakeSelection(index, _prefabFocusupSelection);
			selectionObject.SetParentTransform(obj.transform);
			selectionObject.SetLaserToTransform(obj.transform);
			selectionObject.OnSelectionEnter.Subscribe(delegate
			{
				selectionObject.SetOutlineColor(_colorHover);
			}).AddTo(base.gameObject);
			selectionObject.GradiateColorObservable.Subscribe(delegate(Color color)
			{
				selectionObject.SetOutlineColor(color);
			});
			selectionObject.EndSelectionObservable.Subscribe(delegate(bool selected)
			{
				if (selected)
				{
					selectionObject.SetOutlineColor(_colorHover);
				}
				else
				{
					selectionObject.SetOutlineColor(ColorDefine.TransparentBlack);
				}
			}).AddTo(base.gameObject);
		}

		private void MakeSelfSelection(int index)
		{
			PlayerAvater avater = MainPosition.Avater;
			SelectionObject selectionObject = MakeSelection(index, _prefabSelfSelection);
			selectionObject.SetParentTransform(avater.MessagePivot);
			selectionObject.SetLaserToTransform(avater.MessagePivot);
			if (MainPosition.Avater.AvaterResources.HasBody)
			{
				MainPosition.Avater.AvaterResources.BodyObject.SetOutlineSize(_outlineSize);
			}
			if (MainPosition.Avater.AvaterResources.HasHand)
			{
				MainPosition.Avater.AvaterResources.HandObject.SetOutlineSize(_outlineSize);
			}
			if (MainPosition.Avater.AvaterResources.HasTrackedHands)
			{
				MainPosition.Avater.AvaterResources.TrackedHandLeftObject.SetOutlineSize(_outlineSize);
				MainPosition.Avater.AvaterResources.TrackedHandRightObject.SetOutlineSize(_outlineSize);
			}
			selectionObject.OnSelectionEnter.Subscribe(delegate
			{
				if (MainPosition.Avater.AvaterResources.HasBody)
				{
					MainPosition.Avater.AvaterResources.BodyObject.SetOutlineColor(_colorHover);
				}
				if (MainPosition.Avater.AvaterResources.HasHand)
				{
					MainPosition.Avater.AvaterResources.HandObject.SetOutlineColor(_colorHover);
				}
			}).AddTo(base.gameObject);
			selectionObject.GradiateColorObservable.Subscribe(delegate(Color color)
			{
				if (MainPosition.Avater.AvaterResources.HasBody)
				{
					MainPosition.Avater.AvaterResources.BodyObject.SetOutlineColor(color);
				}
				if (MainPosition.Avater.AvaterResources.HasHand)
				{
					MainPosition.Avater.AvaterResources.HandObject.SetOutlineColor(color);
				}
				if (MainPosition.Avater.AvaterResources.HasTrackedHands)
				{
					MainPosition.Avater.AvaterResources.TrackedHandLeftObject.SetOutlineColor(color);
					MainPosition.Avater.AvaterResources.TrackedHandRightObject.SetOutlineColor(color);
				}
			}).AddTo(base.gameObject);
			selectionObject.EndSelectionObservable.Subscribe(delegate
			{
				if (MainPosition.Avater.AvaterResources.HasBody)
				{
					MainPosition.Avater.AvaterResources.BodyObject.RevertToDefault();
				}
				if (MainPosition.Avater.AvaterResources.HasHand)
				{
					MainPosition.Avater.AvaterResources.HandObject.RevertToDefault();
				}
				if (MainPosition.Avater.AvaterResources.HasTrackedHands)
				{
					MainPosition.Avater.AvaterResources.TrackedHandLeftObject.RevertToDefault();
					MainPosition.Avater.AvaterResources.TrackedHandRightObject.RevertToDefault();
				}
			}).AddTo(base.gameObject);
		}

		private void MakeSelectionSubscribes(SelectionObject selection, int index)
		{
			_disposes.Enqueue(selection.OnSelectionEnter.Subscribe(delegate(PointerEventData pointer)
			{
				PlaySeSelect(selection.SelectionAudioSource);
				GameInputHelper.VibrateLaserForFocus(pointer.GetLaserController());
				_subjectPointerEnterSelection.OnNext(index);
			}).AddTo(base.gameObject));
			_disposes.Enqueue(selection.OnSelectionExit.Subscribe(delegate
			{
				_subjectPointerExitSelection.OnNext(index);
			}).AddTo(base.gameObject));
			_disposes.Enqueue(selection.OnSelectionDown.Subscribe(delegate(PointerEventData pointer)
			{
				GameInputHelper.VibrateLaserForPress(pointer.GetLaserController());
			}).AddTo(base.gameObject));
			_disposes.Enqueue(selection.OnSelectionClick.Subscribe(delegate
			{
				PlaySeDecide(selection.SelectionAudioSource);
				OnSelected(index);
			}).AddTo(base.gameObject));
		}

		private void OnSelected(int index)
		{
			_selectedIndex = index;
			SingletonMonoBehaviour<LocalData>.Instance.LastSelectionIndex = _selectedIndex;
			_isDecided = true;
			OnBeforeEndSelection();
			if (IsNeedGeneralEffects)
			{
				Fader.StartFade(ColorDefine.Black, _fadeEndDuration, isDeactivateOnEnd: false, EndSelection);
			}
			else
			{
				EndSelection();
			}
		}

		public void ForceSelect(int index)
		{
			if (_isSelecting && !_isDecided)
			{
				OnSelected(index);
			}
		}

		private void DisposeSelection()
		{
			_selectedIndex = -1;
			SingletonMonoBehaviour<LocalData>.Instance.LastSelectionIndex = _selectedIndex;
			OnBeforeEndSelection();
			EndSelection();
		}

		private void OnBeforeEndSelection()
		{
			DisposeSelectEvents();
			SendSelectionEnd();
			Observable.NextFrame().Subscribe(delegate
			{
				SingletonMonoBehaviour<PlayAreaManager>.Instance.ToggleLaserVisible(flag: true);
			}).AddTo(base.gameObject);
		}

		private void DisposeSelectEvents()
		{
			while (_disposes.Count > 0)
			{
				_disposes.Dequeue().Dispose();
			}
		}

		private void SendSelectionEnd()
		{
			foreach (SelectionObject selection in _selections)
			{
				selection.EndSelection(selection.SelectionIndex == _selectedIndex);
			}
		}

		private void EndSelection()
		{
			ReleaseAllSelections();
			ProhibitLaserInterraction = false;
			_isSelecting = false;
			_currentData = null;
			_subjectEndSelection.OnNext(_selectedIndex);
			_subjectEndSelection.OnCompleted();
			_subjectEndSelection = new AsyncSubject<int>();
		}

		private void ReleaseAllSelections()
		{
			if (_selections == null)
			{
				return;
			}
			foreach (SelectionObject selection in _selections)
			{
				selection.gameObject.Destroy();
			}
			_selections.Clear();
		}

		public void PlaySeOpen()
		{
			if (IsNeedGeneralEffects)
			{
				SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Selection_Show);
			}
		}

		public void PlaySeSelect(AudioSource uiSoundSource)
		{
			if (IsNeedGeneralEffects)
			{
				SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Selection_Select, uiSoundSource);
			}
		}

		public void PlaySeDecide(AudioSource uiSoundSource)
		{
			if (IsNeedGeneralEffects)
			{
				SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Selection_Decide, uiSoundSource);
			}
		}
	}
	public static class SelectionDefines
	{
		public enum Modes
		{
			Normal,
			Finale
		}

		public enum TargetTypes
		{
			Chara,
			Prop,
			FocusUp,
			Yourself
		}

		public enum CollisionTypes
		{
			NoMake,
			MakeCollision
		}
	}
	public class SelectionLaser : UpdateableComponent
	{
		private const float LaserOffset = 0.05f;

		private const float LaserLength = 0.9f;

		[Header("Components")]
		[SerializeField]
		private LineRenderer _line;

		[Header("Parameters")]
		[SerializeField]
		private float _positionFadeTime = 2f;

		[SerializeField]
		private float _laserLength = 2f;

		private float laserTimer;

		private HandObject FromHand { get; set; }

		public Transform ToTransform { get; set; }

		private bool IsValid
		{
			get
			{
				if (FromHand != null)
				{
					return ToTransform != null;
				}
				return false;
			}
		}

		public bool Visible
		{
			get
			{
				return _line.enabled;
			}
			set
			{
				_line.enabled = value;
			}
		}

		protected override void Initialize()
		{
			laserTimer = 0f;
			SingletonMonoBehaviour<GameInputManager>.Instance.OnChangeMainHand.DelayFrame(1).Subscribe(delegate(VRDeviceDefine.HandType handType)
			{
				switch (handType)
				{
				case VRDeviceDefine.HandType.Left:
					FromHand = SingletonMonoBehaviour<PlayAreaManager>.Instance.LeftHandObject;
					break;
				case VRDeviceDefine.HandType.Right:
					FromHand = SingletonMonoBehaviour<PlayAreaManager>.Instance.RightHandObject;
					break;
				default:
					FromHand = null;
					break;
				}
			}).AddTo(base.gameObject);
		}

		public override void OnUpdate(float delta)
		{
			if (IsValid && _line.enabled)
			{
				int positionCount = _line.positionCount;
				Vector3 position = FromHand.ThisTransform.position;
				Vector3 b = position + FromHand.ThisTransform.forward * _laserLength;
				Vector3 b2 = Vector3.Lerp(ToTransform.position, b, Easing.EaseInOutCubic(0f, 1f, laserTimer / _positionFadeTime));
				for (int i = 0; i < positionCount; i++)
				{
					float t = (float)i / ((float)positionCount - 1f) * 0.9f + 0.05f;
					Vector3 position2 = Vector3.Lerp(position, b2, t);
					_line.SetPosition(i, position2);
				}
				laserTimer += delta;
			}
		}

		public void SetLaserColor(Color col)
		{
			LineRenderer line = _line;
			Color startColor = (_line.endColor = col);
			line.startColor = startColor;
		}
	}
	public class SelectionObject : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private AudioSource _audioSource;

		[SerializeField]
		private SelectionLaser _selectionLaser;

		[SerializeField]
		private Collider _collider;

		[Header("Components - Outline")]
		[SerializeField]
		private Renderer _colorRenderer;

		private Queue<IDisposable> _disposes;

		private bool _isHovered;

		private bool _interractable = true;

		private float _startTime;

		private Material _colorMaterial;

		private Subject<Color> _subjectGradiateColor = new Subject<Color>();

		private Subject<bool> _subjectEndSelection = new Subject<bool>();

		public int SelectionIndex { get; set; }

		public AudioSource SelectionAudioSource => _audioSource;

		public bool Interractable
		{
			get
			{
				return _interractable;
			}
			set
			{
				_interractable = value;
			}
		}

		public Color ColorWaiting1 { get; set; }

		public Color ColorWaiting2 { get; set; }

		public IObservable<PointerEventData> OnSelectionEnter { get; private set; }

		public IObservable<PointerEventData> OnSelectionExit { get; private set; }

		public IObservable<PointerEventData> OnSelectionDown { get; private set; }

		public IObservable<PointerEventData> OnSelectionUp { get; private set; }

		public IObservable<PointerEventData> OnSelectionClick { get; private set; }

		private IObservable<Unit> UpdateObserbable => SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable;

		public IObservable<Color> GradiateColorObservable => _subjectGradiateColor;

		public IObservable<bool> EndSelectionObservable => _subjectEndSelection;

		private float LiveTime => Time.time - _startTime;

		private void Awake()
		{
			_disposes = new Queue<IDisposable>();
			ObservableEventTrigger observableEventTrigger = base.gameObject.AddComponent<ObservableEventTrigger>();
			OnSelectionEnter = observableEventTrigger.OnPointerEnterAsObservable();
			OnSelectionExit = observableEventTrigger.OnPointerExitAsObservable();
			OnSelectionDown = observableEventTrigger.OnPointerDownAsObservable();
			OnSelectionUp = observableEventTrigger.OnPointerUpAsObservable();
			OnSelectionClick = observableEventTrigger.OnPointerClickAsObservable();
			if (_colorRenderer != null)
			{
				_colorMaterial = new Material(_colorRenderer.sharedMaterial);
				_colorRenderer.sharedMaterial = _colorMaterial;
			}
			_startTime = Time.time;
			GeneralSubscribes();
		}

		public void SetParentTransform(Transform t)
		{
			base.transform.SetParent(t, worldPositionStays: false);
		}

		public void SetLaserToTransform(Transform t)
		{
			_selectionLaser.ToTransform = t;
		}

		private void GeneralSubscribes()
		{
			_disposes.Enqueue(OnSelectionEnter.Subscribe(delegate
			{
				_isHovered = true;
			}));
			_disposes.Enqueue(OnSelectionExit.Subscribe(delegate
			{
				_isHovered = false;
			}));
			_disposes.Enqueue(UpdateObserbable.Where((Unit _) => Interractable && !_isHovered).Subscribe(delegate
			{
				float t = Mathf.Sin(LiveTime * (float)Math.PI) * 0.5f + 0.5f;
				Color value = Color.Lerp(ColorWaiting1, ColorWaiting2, t);
				_subjectGradiateColor.OnNext(value);
			}).AddTo(base.gameObject));
		}

		public void SetInterractable(bool flag)
		{
			_collider.enabled = flag;
		}

		public void SetLaserVibisle(bool flag)
		{
			_selectionLaser.Visible = flag;
		}

		public void SetOutlineColor(Color color)
		{
			if (_colorMaterial != null)
			{
				_colorMaterial.SetColor("_Color", color);
			}
		}

		public void EndSelection(bool selected)
		{
			DisposeSelectEvents();
			_isHovered = false;
			SetLaserVibisle(flag: false);
			SetInterractable(flag: false);
			_subjectEndSelection.OnNext(selected);
			_subjectEndSelection.OnCompleted();
		}

		private void DisposeSelectEvents()
		{
			while (_disposes.Count > 0)
			{
				_disposes.Dequeue().Dispose();
			}
		}
	}
	public abstract class BaseCommandEnable : BaseCommandToggleFlag
	{
		public BaseCommandEnable()
		{
		}

		public BaseCommandEnable(SequenceData.Param data)
			: base(data)
		{
		}

		protected override string GetFlagText()
		{
			if (!ToggleFlag)
			{
				return "";
			}
			return "";
		}
	}
	public abstract class BaseCommandProhibit : BaseCommandToggleFlag
	{
		public BaseCommandProhibit()
		{
		}

		public BaseCommandProhibit(SequenceData.Param data)
			: base(data)
		{
		}

		protected override string GetFlagText()
		{
			if (!ToggleFlag)
			{
				return "";
			}
			return "";
		}
	}
	public abstract class BaseCommandSceneProp : ISequenceCommand
	{
		public PropDefines.PropType PropType;

		public int PropIndex;

		public bool IsDynamicProp => PropType == PropDefines.PropType.Dynamic;

		protected void LoadFromData(SequenceData.Param data)
		{
			PropType = (PropDefines.PropType)data.DataInt[0];
			PropIndex = data.DataInt[1];
		}

		protected bool GetPropAvailable(TimelinePlayer player)
		{
			if (player == null)
			{
				return false;
			}
			return PropType switch
			{
				PropDefines.PropType.Static => player.CurrentBackground.HasStaticProps, 
				PropDefines.PropType.Dynamic => player.CurrentBackground.HasDynamicProps, 
				_ => false, 
			};
		}

		protected BaseProp GetPropObject(TimelinePlayer player)
		{
			return GetPropObject(player, PropType, PropIndex);
		}

		protected BaseProp GetPropObject(TimelinePlayer player, PropDefines.PropType type, int index)
		{
			return type switch
			{
				PropDefines.PropType.Static => player.CurrentBackground.StaticProps.GetPropByIndex(index), 
				PropDefines.PropType.Dynamic => player.CurrentBackground.DynamicProps.GetPropByIndex(index), 
				_ => null, 
			};
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (!GetPropAvailable(player))
			{
				throw new CommandFailedException(this, $"{PropType} ");
			}
			BaseProp propObject = GetPropObject(player);
			if (propObject == null)
			{
				throw new CommandFailedException(this, $" {PropType}.{PropIndex} ");
			}
			return PlayCommandWithProp(player, propObject);
		}

		protected virtual bool PlayCommandWithProp(TimelinePlayer player, BaseProp prop)
		{
			throw new CommandFailedException(this, "Prop");
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)PropType);
			data.DataInt.Add(PropIndex);
		}
	}
	public abstract class BaseCommandSceneTo : ISequenceCommand
	{
		public int NextScquenceID = 10000;

		public bool IgnoreAutoSave;

		protected virtual SceneDefine SceneTransitionTo => SceneDefine.Blank;

		public override PreloadTypes PreloadType => PreloadTypes.UnityScene;

		public override int PreloadIndex => (int)SceneTransitionTo;

		public override bool PlayInHardSkip => true;

		public BaseCommandSceneTo()
		{
		}

		public BaseCommandSceneTo(SequenceData.Param data, int version)
		{
			NextScquenceID = data.GetInt(0);
			IgnoreAutoSave = IntToBool(data.GetInt(1));
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.CompleteScenario();
			SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID = NextScquenceID;
			if (!IgnoreAutoSave)
			{
				player.ResolveReservedAutoSave();
			}
			player.ChangeSceneToSpecial(SceneTransitionTo);
			return false;
		}

		public override void OnEnd(TimelinePlayer player)
		{
			if (SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID == -1)
			{
				player.QuitToTitle();
			}
			else
			{
				player.ReserveLoadScenerio(SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID);
			}
		}

		public override ISequenceCommand Clone()
		{
			return (BaseCommandSceneTo)MemberwiseClone();
		}

		protected string GetNextScquenceString()
		{
			string text = ((NextScquenceID < 0) ? "" : $"SqID: {NextScquenceID:00000}");
			if (IgnoreAutoSave)
			{
				text += " () ";
			}
			return text;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(NextScquenceID);
			data.DataInt.Add(BoolToInt(IgnoreAutoSave));
		}
	}
	public abstract class BaseCommandToggleFlag : ISequenceCommand
	{
		public bool ToggleFlag = true;

		public BaseCommandToggleFlag()
		{
			ToggleFlag = true;
		}

		public BaseCommandToggleFlag(SequenceData.Param data)
		{
			ToggleFlag = data.DataInt[0] != 0;
		}

		protected virtual string GetFlagText()
		{
			if (!ToggleFlag)
			{
				return "";
			}
			return "";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(BoolToInt(ToggleFlag));
		}
	}
	public abstract class BaseLogicCommand : ISequenceCommand
	{
		public bool IsLogicTrue { get; protected set; }

		public override bool IsLogic => true;
	}
	public class CommandAmbient : CommandSe2D
	{
		public const string NAME = "{0:D3}";

		public const string PATH = "{0}{1:D3}";

		public override Types Type => Types.PlayAmbient;

		public override PreloadTypes PreloadType => PreloadTypes.AmbientEffect;

		public override int PreloadIndex => base.ID;

		public CommandAmbient()
		{
		}

		public CommandAmbient(int id, float volume, bool isRepeat)
			: base(id, volume, isRepeat)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public override string GetFilePath()
		{
			return string.Format("{0}{1:D3}", "Audio/Ambient/", base.ID);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandAmbient)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"ID = {base.ID},  = {IsRepeat}";
		}
	}
	public class CommandAmbientOff : CommandSe2DOff
	{
		public override Types Type => Types.StopAmbient;

		public CommandAmbientOff()
		{
		}

		public CommandAmbientOff(int id)
		{
			ID = id;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandAmbientOff)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "";
		}
	}
	public class CommandAutoWaitOverride : ISequenceCommand
	{
		public bool Enabled = true;

		public int MessageSpeed;

		public float Duration = 10f;

		public override Types Type => Types.CommandAutoWaitOverride;

		public CommandAutoWaitOverride()
		{
		}

		public CommandAutoWaitOverride(SequenceData.Param data, int version)
			: base(data, version)
		{
			Enabled = IntToBool(data.GetInt(0));
			MessageSpeed = data.GetInt(1);
			Duration = data.GetFloat(0);
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MessageProcessor.IsAutoWaitOverrided = Enabled;
			if (Enabled)
			{
				player.MessageProcessor.AutoWaitOverride = Duration;
				player.MessageProcessor.MessageSpeedOverride = MessageSpeed;
			}
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandAutoWaitOverride)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			if (!Enabled)
			{
				return ": ";
			}
			return $": {Duration:F2} ,  {MessageSpeed}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(BoolToInt(Enabled));
			data.DataInt.Add(MessageSpeed);
			data.DataFloat.Add(Duration);
		}
	}
	public class CommandAvaterOutline : ISequenceCommand
	{
		public PlayerAvater.AvaterParts TargetPart;

		public PlayerAvater.FadeModes FadeMode;

		public float FadeDuration = 0.3f;

		public float OutlineSize = 0.1f;

		public Color OutlineColor = new Color(0.75f, 0.75f, 0.75f);

		public bool FlagChangeSize = true;

		public bool FlagChangeColor = true;

		public override Types Type => Types.AvaterOutline;

		public CommandAvaterOutline()
		{
		}

		public CommandAvaterOutline(SequenceData.Param data, int saveVersion)
		{
			TargetPart = (PlayerAvater.AvaterParts)data.GetInt(0);
			FadeMode = (PlayerAvater.FadeModes)data.GetInt(1);
			FlagChangeSize = IntToBool(data.GetInt(2));
			FlagChangeColor = IntToBool(data.GetInt(3));
			OutlineSize = data.GetFloat(0);
			OutlineColor.r = data.GetFloat(1);
			OutlineColor.g = data.GetFloat(2);
			OutlineColor.b = data.GetFloat(3);
			OutlineColor.a = data.GetFloat(4);
			FadeDuration = data.GetFloat(5);
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			MainPosition.Avater.SetOutlineParameters(TargetPart, this);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandAvaterOutline)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string text = "<b></b>:";
			text += $" [<b>{TargetPart}</b>]";
			switch (FadeMode)
			{
			case PlayerAvater.FadeModes.None:
				text += " []";
				break;
			case PlayerAvater.FadeModes.Smooth:
				text += $" [ {FadeDuration:F1} s]";
				break;
			case PlayerAvater.FadeModes.Dither:
				text += $" [ {FadeDuration:F1} s]";
				break;
			}
			text = ((!FlagChangeSize) ? (text + " []") : (text + $" [{OutlineSize:F2}]"));
			if (FlagChangeColor)
			{
				return text + $" [<color=#{ColorUtility.ToHtmlStringRGB(OutlineColor)}></color>]";
			}
			return text + " []";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)TargetPart);
			data.DataInt.Add((int)FadeMode);
			data.DataInt.Add(BoolToInt(FlagChangeSize));
			data.DataInt.Add(BoolToInt(FlagChangeColor));
			data.DataFloat.Add(OutlineSize);
			data.DataFloat.Add(OutlineColor.r);
			data.DataFloat.Add(OutlineColor.g);
			data.DataFloat.Add(OutlineColor.b);
			data.DataFloat.Add(OutlineColor.a);
			data.DataFloat.Add(FadeDuration);
		}
	}
	public class CommandAvaterTexture : ISequenceCommand
	{
		public PlayerAvater.AvaterParts TargetPart;

		public AdvCharaTextureData.TextureType TextureType;

		public override Types Type => Types.AvaterTexture;

		public CommandAvaterTexture()
		{
		}

		public CommandAvaterTexture(SequenceData.Param data, int version)
			: base(data, version)
		{
			TargetPart = (PlayerAvater.AvaterParts)data.DataInt[0];
			TextureType = (AdvCharaTextureData.TextureType)data.DataInt[1];
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			MainPosition.Avater.AvaterResources.ChangeTextureType(TextureType, TargetPart);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandAvaterTexture)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "<b></b>: " + TargetPart.ToString() + "  " + TextureType;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)TargetPart);
			data.DataInt.Add((int)TextureType);
		}
	}
	public class CommandBackgroundActive : ISequenceCommand
	{
		public bool IsActive;

		public SceneDefine Scene = SceneDefine.Crossing;

		private int m_layer;

		public override Types Type => Types.BackgroundActive;

		public CommandBackgroundActive()
		{
		}

		public CommandBackgroundActive(SequenceData.Param data, int version)
		{
			IsActive = IntToBool(data.DataInt[0]);
			Scene = (SceneDefine)data.DataInt[1];
			m_layer = LayerMask.NameToLayer("Environment");
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (Scene == SingletonMonoBehaviour<TransitionManager>.Instance.CurrentSceneId)
			{
				if (player.CurrentBackground != null)
				{
					player.CurrentBackground.SetActive(IsActive);
					return true;
				}
				FindAndActivateBackground(SingletonMonoBehaviour<TransitionManager>.Instance.CurrentScene);
				return true;
			}
			FindAndActivateBackground(SceneManager.GetSceneByBuildIndex((int)Scene));
			return true;
		}

		private void FindAndActivateBackground(Scene scene)
		{
			GameObject[] rootGameObjects = scene.GetRootGameObjects();
			int num = rootGameObjects.Length;
			for (int i = 0; i < num; i++)
			{
				if (rootGameObjects[i].layer == m_layer && !(rootGameObjects[i].GetComponent<AdvBackground>() == null))
				{
					rootGameObjects[i].SetActive(IsActive);
					break;
				}
			}
		}

		public override ISequenceCommand Clone()
		{
			return (CommandBackgroundActive)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			if (!IsActive)
			{
				return " : " + Scene;
			}
			return " : " + Scene;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(BoolToInt(IsActive));
			data.DataInt.Add((int)Scene);
		}
	}
	public class CommandBgm : ISequenceCommand, ISoundCommand
	{
		private const int _MEMORY_AMBIENT_FADE_BARS = 4;

		public KainePlayer.Layers Layer;

		public bool IsStopMemoryAmbient = true;

		private bool m_hasPlayedBgm = true;

		public override Types Type => Types.PlayBgm;

		public override PreloadTypes PreloadType => PreloadTypes.BgmAdvanced;

		public override int PreloadIndex => ID;

		public int ID { get; set; }

		public AudioClip Clip { get; set; }

		public CommandBgm()
		{
		}

		public CommandBgm(int id, KainePlayer.Layers layer)
		{
			ID = id;
			Layer = layer;
		}

		public CommandBgm(SequenceData.Param data)
		{
			ID = data.DataInt[0];
			Layer = (KainePlayer.Layers)data.DataInt[1];
			if (data.DataInt.Count > 2)
			{
				IsStopMemoryAmbient = IntToBool(data.DataInt[2]);
			}
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			m_hasPlayedBgm = !SoundManager.Bgm.PreparePlay(ID, Layer);
			if (!IsStopMemoryAmbient || player.CurrentBackground == null || !player.CurrentBackground.HasAudioSource)
			{
				return m_hasPlayedBgm;
			}
			AudioSourceFader audio = player.CurrentBackground.Audio;
			if (!audio.IsPlaying)
			{
				return m_hasPlayedBgm;
			}
			audio.StopWithFade(SoundManager.Bgm.GetIntroDuration());
			return m_hasPlayedBgm;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			if (!m_hasPlayedBgm)
			{
				m_hasPlayedBgm = true;
				SoundManager.Bgm.StartPlay(Layer);
			}
			return true;
		}

		public string GetFilePath()
		{
			return string.Empty;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandBgm)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"BGM : BGMID {ID},  {Layer}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(ID);
			data.DataInt.Add((int)Layer);
			data.DataInt.Add(BoolToInt(IsStopMemoryAmbient));
		}
	}
	public class CommandBgmChangeLayer : ISequenceCommand
	{
		public KainePlayer.Layers Layer;

		public override Types Type => Types.BgmChangeLayer;

		public CommandBgmChangeLayer()
		{
			Layer = KainePlayer.Layers.Ambient;
		}

		public CommandBgmChangeLayer(KainePlayer.Layers layer)
		{
			Layer = layer;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SoundManager.Bgm.SetLayer(Layer);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandBgmChangeLayer)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"BGM {Layer} ";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Layer);
		}
	}
	public class CommandBgmOff : ISequenceCommand
	{
		public BgmPlayer.StopMode StopMode = BgmPlayer.StopMode.Outro;

		public override Types Type => Types.StopBgm;

		public CommandBgmOff()
		{
			StopMode = BgmPlayer.StopMode.Outro;
		}

		public CommandBgmOff(BgmPlayer.StopMode mode)
		{
			StopMode = mode;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SoundManager.Bgm.Stop(StopMode);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandBgmOff)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"BGM : {CreateModeTypeText()}";
		}

		protected string CreateModeTypeText()
		{
			return StopMode switch
			{
				BgmPlayer.StopMode.Fade => "", 
				BgmPlayer.StopMode.Outro => "", 
				BgmPlayer.StopMode.Immidiate => "", 
				_ => string.Empty, 
			};
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)StopMode);
		}
	}
	public class CommandBgmSimple : ISequenceCommand, ISoundCommand
	{
		public const string FILENAME = "Audio/BgmSimple/{0:D4}";

		public float Volume = 1f;

		public float FadeDuration = 0.6f;

		public override Types Type => Types.PlayBgmSimple;

		public override PreloadTypes PreloadType => PreloadTypes.BgmSimple;

		public override int PreloadIndex => ID;

		public int ID { get; set; }

		public AudioClip Clip { get; set; }

		public CommandBgmSimple()
		{
		}

		public CommandBgmSimple(int id, float volume, float fadeDuration)
		{
			ID = id;
			Volume = volume;
			FadeDuration = fadeDuration;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SoundManager.Bgm.PlaySimple(ID, Volume, FadeDuration);
			return true;
		}

		public virtual string GetFilePath()
		{
			return $"Audio/BgmSimple/{ID:D4}";
		}

		public override ISequenceCommand Clone()
		{
			return (CommandBgmSimple)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"BGMID {ID},  {Volume},  {FadeDuration}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(ID);
			data.DataFloat.Add(Volume);
			data.DataFloat.Add(FadeDuration);
		}
	}
	public class CommandBgmSimpleOff : ISequenceCommand
	{
		public float FadeDuration = 0.6f;

		public override Types Type => Types.StopBgmSimple;

		public CommandBgmSimpleOff()
		{
		}

		public CommandBgmSimpleOff(float fadeDuration)
		{
			FadeDuration = fadeDuration;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SoundManager.Bgm.StopSimple(FadeDuration);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandBgmSimpleOff)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"Bgm : {FadeDuration}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataFloat.Add(FadeDuration);
		}
	}
	public class CommandBgmSimpleVolume : ISequenceCommand
	{
		public float Volume;

		public float FadeDuration;

		public override Types Type => Types.BgmSimpleVolumeChange;

		public CommandBgmSimpleVolume()
		{
		}

		public CommandBgmSimpleVolume(float volume, float fadeDuration)
		{
			Volume = volume;
			FadeDuration = fadeDuration;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SoundManager.Bgm.SetSimpleVolume(Volume, FadeDuration);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandBgmSimpleVolume)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"Bgm :  {Volume},  {FadeDuration}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataFloat.Add(Volume);
			data.DataFloat.Add(FadeDuration);
		}
	}
	public class CommandBokeSphere : ISequenceCommand
	{
		public enum Environment
		{
			Crossing,
			Building,
			ElevatorHole,
			Hotel,
			BuildingRoofMono,
			BuildingRoof,
			PlayDome
		}

		public Environment Envrionment;

		public bool IsPlaceAtPlayer = true;

		public Vector3 Position;

		public float Rotation;

		public override Types Type => Types.BokeSphereStart;

		public override PreloadTypes PreloadType => PreloadTypes.BokeSphere;

		public override int PreloadIndex => (int)Envrionment;

		public CommandBokeSphere()
		{
		}

		public CommandBokeSphere(Environment environment, bool isPlaceAtChara, Vector3 pos, float rotationY)
		{
			Envrionment = environment;
			IsPlaceAtPlayer = isPlaceAtChara;
			Position = pos;
			Rotation = rotationY;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.BokeSphereProcessor.Play(this);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandBokeSphere)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $" {Envrionment.ToString()},  {Position.ToString()}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Envrionment);
			data.DataInt.Add(BoolToInt(IsPlaceAtPlayer));
			data.DataFloat.Add(Position.x);
			data.DataFloat.Add(Position.y);
			data.DataFloat.Add(Position.z);
			data.DataFloat.Add(Rotation);
		}
	}
	public class CommandBokeSphereEnd : ISequenceCommand
	{
		public bool IsKeepCullingSetting;

		public override Types Type => Types.BokeSphereEnd;

		public CommandBokeSphereEnd()
		{
		}

		public CommandBokeSphereEnd(SequenceData.Param data)
		{
			if (data.DataInt.Count > 0)
			{
				IsKeepCullingSetting = IntToBool(data.DataInt[0]);
			}
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.BokeSphereProcessor.End(this);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandBokeSphereEnd)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $": {IsKeepCullingSetting}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(BoolToInt(IsKeepCullingSetting));
		}
	}
	public class CommandChangeForcusUp : ISequenceCommand
	{
		public int WindowID;

		public int ID;

		public float FadeDuration = 0.4f;

		public override Types Type => Types.ForcusUpChange;

		public override PreloadTypes PreloadType => PreloadTypes.FocusUp;

		public override int PreloadIndex => ID;

		public CommandChangeForcusUp()
		{
		}

		public CommandChangeForcusUp(int windowID, int id, float fadeDuration)
		{
			WindowID = windowID;
			ID = id;
			FadeDuration = fadeDuration;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandChangeForcusUp)MemberwiseClone();
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.FocusUpProcessor.ChangeTexture(WindowID, ID, FadeDuration);
			return true;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(WindowID);
			data.DataInt.Add(ID);
			data.DataFloat.Add(FadeDuration);
		}

		public override string CreateDescriptionText()
		{
			return $": ID:{WindowID}, ID{ID}, {FadeDuration}";
		}
	}
	public class CommandChangeScene : ISequenceCommand
	{
		public SceneDefine NextScene = SceneDefine.Title;

		public override Types Type => Types.Scene;

		public override PreloadTypes PreloadType => PreloadTypes.UnityScene;

		public override int PreloadIndex => (int)NextScene;

		public CommandChangeScene()
		{
			NextScene = SceneDefine.Title;
		}

		public CommandChangeScene(SceneDefine nextScene)
		{
			NextScene = nextScene;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.ChangeScene(NextScene);
			player.Fader.StartFade(ColorDefine.TransparentBlack, ColorDefine.Black, 0f, isDeactivateOnEnd: false);
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandChangeScene)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"Unity : {NextScene.ToString()}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)NextScene);
		}
	}
	public class CommandChangeSequence : ISequenceCommand
	{
		public int ID = -1;

		public override Types Type => Types.Sequence;

		public override bool PlayInHardSkip => true;

		public CommandChangeSequence()
		{
			ID = -1;
		}

		public CommandChangeSequence(int nextID)
		{
			ID = nextID;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.Fader.StartFade(ColorDefine.TransparentBlack, ColorDefine.Black, 0f, isDeactivateOnEnd: false);
			player.ReserveLoadScenerioWithComplete(ID);
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandChangeSequence)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $" : SID {ID:00000}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(ID);
		}
	}
	public class CommandCharaAttachPlayer : ICharaCommand
	{
		public static readonly Vector3 _ATTACHED_SCALE = new Vector3(0.5f, 0.5f, 0.5f);

		public Vector3 Position;

		public Vector3 Rotation;

		public bool IsBasePosition;

		public bool IsRotateWithPlayer;

		public bool IsAvoidScaling;

		public override Types Type => Types.CharaAttachPlayer;

		public CommandCharaAttachPlayer()
		{
		}

		public CommandCharaAttachPlayer(GameDefine.CharaID charaID)
			: base(charaID)
		{
		}

		public CommandCharaAttachPlayer(GameDefine.CharaID charaID, Vector3 pos, Vector3 rot)
			: base(charaID)
		{
			Position = pos;
			Rotation = rot;
		}

		public CommandCharaAttachPlayer(GameDefine.CharaID charaID, Vector3 pos, Vector3 rot, int flags)
			: base(charaID)
		{
			Position = pos;
			Rotation = rot;
			IsBasePosition = (flags & 1) != 0;
			IsRotateWithPlayer = (flags & 2) != 0;
			IsAvoidScaling = (flags & 4) != 0;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
			if (chara == null)
			{
				SayOops("I couldn't find Character: " + Chara);
				return true;
			}
			Transform target = SingletonMonoBehaviour<PlayAreaManager>.Instance.CameraAnchorTransform;
			Vector3 position = Position;
			Vector3 scale = _ATTACHED_SCALE;
			if (IsBasePosition)
			{
				position.y -= 5.17f;
			}
			if (IsRotateWithPlayer)
			{
				target = MainPosition.Avater.MessagePivot;
			}
			if (IsAvoidScaling)
			{
				scale = Vector3.one;
			}
			chara.AttachTo(target, Position, Rotation, scale);
			if (MainPosition.Avater.AvaterResources.HasTrackedHands)
			{
				MainPosition.Avater.AvaterResources.TrackedHandLeftObject.ForceHideTrackedHand(fide: true);
				MainPosition.Avater.AvaterResources.TrackedHandRightObject.ForceHideTrackedHand(fide: true);
			}
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaAttachPlayer)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"{Chara}  (: {Position.ToString()})";
		}

		public override void Save(SequenceData.Param data)
		{
			int num = 0;
			if (IsBasePosition)
			{
				num++;
			}
			if (IsRotateWithPlayer)
			{
				num += 2;
			}
			if (IsAvoidScaling)
			{
				num += 4;
			}
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(num);
			data.DataFloat.Add(Position.x);
			data.DataFloat.Add(Position.y);
			data.DataFloat.Add(Position.z);
			data.DataFloat.Add(Rotation.x);
			data.DataFloat.Add(Rotation.y);
			data.DataFloat.Add(Rotation.z);
		}
	}
	public class CommandCharaChange : ICharaCommand
	{
		public int NextScenarioID;

		public override Types Type => Types.CharaChange;

		public override bool PlayInHardSkip => true;

		public CommandCharaChange()
		{
		}

		public CommandCharaChange(GameDefine.CharaID nextChara, int nextScenarioID)
			: base(nextChara)
		{
			NextScenarioID = nextScenarioID;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.CompleteScenario();
			SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID = NextScenarioID;
			SingletonMonoBehaviour<LocalData>.Instance.NextCharaID = Chara;
			player.ResolveReservedAutoSave();
			player.ChangeSceneToSpecial(SceneDefine.ChangeChara);
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaChange)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $" - {Chara}, SID {NextScenarioID:0000}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(NextScenarioID);
		}
	}
	public class CommandCharaCircularPosition : ICharaCommand
	{
		public bool IsFade = true;

		public float Radius = 7f;

		public float Angle;

		private AdvChara m_chara;

		private Action m_onStartFadeEnd;

		public override Types Type => Types.CharaCircularPosition;

		public CommandCharaCircularPosition()
			: base(GameDefine.CharaID.MOMONO)
		{
		}

		public CommandCharaCircularPosition(GameDefine.CharaID chara, float radius, float angle, bool isFade)
			: base(chara)
		{
			Radius = radius;
			Angle = angle;
			IsFade = isFade;
			if (SingletonMonoBehaviour<CharactersManager>.HasInstance)
			{
				m_chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
				m_onStartFadeEnd = delegate
				{
					m_chara.Transform.localPosition = m_chara.NextPosition;
				};
			}
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
			if (chara == null)
			{
				SayOops("I couldn't find Character: " + Chara);
				return true;
			}
			if (!IsFade || !chara.IsActive)
			{
				SetCharaPosition(chara.Transform, MainPosition.MainTransform);
				return true;
			}
			chara.NextPosition = CauclateCharaPosition(MainPosition.MainTransform);
			chara.Model.PlayPingPongFade(0.3f, 0.3f, m_onStartFadeEnd);
			return true;
		}

		public void SetCharaPosition(Transform chara, Transform player)
		{
			chara.position = CauclateCharaPosition(player);
		}

		public Vector3 CauclateCharaPosition(Transform player)
		{
			return CauclateCharaPosition(player, Angle, Radius);
		}

		public static Vector3 CauclateCharaPosition(Transform player, float angle, float radius)
		{
			Vector3 position = player.position;
			float num = angle + player.rotation.eulerAngles.y;
			position.x += Mathf.Sin((float)Math.PI / 180f * num) * radius;
			position.z += Mathf.Cos((float)Math.PI / 180f * num) * radius;
			position.y = 0f;
			return position;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaCircularPosition)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return string.Format("{0} :  {1:0.0},  {2:0.0}{3}", Chara.ToString(), Radius, Angle, IsFade ? "" : " ()");
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(BoolToInt(IsFade));
			data.DataFloat.Add(Radius);
			data.DataFloat.Add(Angle);
		}
	}
	public class CommandCharaDetachPlayer : ICharaCommand
	{
		public override Types Type => Types.CharaDetachPlayer;

		public CommandCharaDetachPlayer()
		{
		}

		public CommandCharaDetachPlayer(GameDefine.CharaID chara)
			: base(chara)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
			if (chara == null)
			{
				SayOops("I couldn't find Character: " + Chara);
				return true;
			}
			chara.Detach();
			if (MainPosition.Avater.AvaterResources.HasTrackedHands)
			{
				MainPosition.Avater.AvaterResources.TrackedHandLeftObject.ForceHideTrackedHand(fide: false);
				MainPosition.Avater.AvaterResources.TrackedHandRightObject.ForceHideTrackedHand(fide: false);
			}
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaDetachPlayer)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"{Chara} ";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
		}
	}
	public class CommandCharaFacial : CommandCharaMotion
	{
		public const int _DEFAULT_ID = 301;

		public override Types Type => Types.CharaFace;

		public CommandCharaFacial()
		{
			Motion = 301;
		}

		public CommandCharaFacial(GameDefine.CharaID chara, int motion, bool isFade, bool isPlayAnimation)
			: base(chara, motion, isFade: false, isPlayAnimation)
		{
		}

		protected override void SetCharaSafetyFlag(AdvChara chara)
		{
			chara.HasInitialFacial = true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaFacial)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"{Chara} {Motion} : {IsPlayAnimation}";
		}
	}
	public class CommandCharaLookAt : ICharaCommand
	{
		public enum SourceType
		{
			Chara,
			Point,
			Prop,
			PropNode
		}

		public SourceType Source;

		public Vector3 Position;

		public GameDefine.CharaID Target = GameDefine.CharaID.BASE;

		public PropDefines.PropType Props;

		public int PropsId;

		public int PropsAnchorId;

		public bool IsPlayAnimation = true;

		public override Types Type => Types.CharaLootAt;

		public CommandCharaLookAt()
		{
		}

		public CommandCharaLookAt(GameDefine.CharaID chara, GameDefine.CharaID target, bool isPlayAnimation, SourceType source)
			: base(chara)
		{
			Target = target;
			IsPlayAnimation = isPlayAnimation;
			Source = source;
		}

		public CommandCharaLookAt(GameDefine.CharaID chara, bool isPlayAnimation, Vector3 targetPosition, SourceType sourceType = SourceType.Point)
			: base(chara)
		{
			Position = targetPosition;
			IsPlayAnimation = isPlayAnimation;
			Source = sourceType;
		}

		public CommandCharaLookAt(GameDefine.CharaID chara, bool isPlayAnimation, PropDefines.PropType propsType, int propsId, SourceType source = SourceType.Prop)
			: base(chara)
		{
			IsPlayAnimation = isPlayAnimation;
			Props = propsType;
			PropsId = propsId;
			Source = source;
		}

		public CommandCharaLookAt(GameDefine.CharaID chara, bool isPlayAnimation, PropDefines.PropType propsType, int propsId, int propsAnchorId, SourceType source = SourceType.Prop)
			: base(chara)
		{
			IsPlayAnimation = isPlayAnimation;
			Props = propsType;
			PropsId = propsId;
			PropsAnchorId = propsAnchorId;
			Source = source;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
			if (chara == null)
			{
				return true;
			}
			chara.HasInitialLookAt = true;
			chara.Look.IsUpdate = true;
			if (Source == SourceType.Point)
			{
				chara.Look.SetLookAtPosition(Position, IsPlayAnimation);
			}
			else if (Source == SourceType.Prop)
			{
				chara.Look.SetLookAtTransform(GetPropTransform(player), !IsPlayAnimation);
			}
			else
			{
				if (Target == GameDefine.CharaID.BASE)
				{
					chara.Look.SetLookAtTransform(MainPosition.CameraTransform, !IsPlayAnimation);
					return true;
				}
				if (Target == GameDefine.CharaID.UNKNOWN)
				{
					chara.Look.SetLookAtTransform(null, !IsPlayAnimation);
					return true;
				}
				AdvChara chara2 = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Target);
				if (chara2 == null)
				{
					return true;
				}
				chara.Look.SetLookAtTransform(chara2.Head, !IsPlayAnimation);
			}
			if (!player.HasPlayedFirstFade)
			{
				chara.Look.UpdateLookAtProcess();
			}
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaLookAt)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string text = (IsPlayAnimation ? "" : " ()");
			switch (Source)
			{
			case SourceType.Point:
				return $"{Chara}   {Position} " + text;
			case SourceType.Prop:
				return $"{Chara}   {Props}.{PropsId} " + text;
			case SourceType.PropNode:
				return $"{Chara}   {Props}.{PropsId}.Anchor{PropsAnchorId} " + text;
			default:
				if (Target == GameDefine.CharaID.BASE)
				{
					return $"{Chara}   " + text;
				}
				if (Target == GameDefine.CharaID.UNKNOWN)
				{
					return $"{Chara} " + text;
				}
				return $"{Chara}   {Target} " + text;
			}
		}

		private Transform GetPropTransform(TimelinePlayer player)
		{
			BaseProp propObject = GetPropObject(player, Props, PropsId);
			if (propObject == null)
			{
				return null;
			}
			return propObject.AnchorTransform;
		}

		private Transform GetPropAnchorTransform(TimelinePlayer player)
		{
			BaseProp propObject = GetPropObject(player, Props, PropsId);
			if (propObject == null)
			{
				return null;
			}
			return propObject.GetAnchor(PropsAnchorId);
		}

		private BaseProp GetPropObject(TimelinePlayer player, PropDefines.PropType type, int index)
		{
			return type switch
			{
				PropDefines.PropType.Static => player.CurrentBackground.StaticProps.GetPropByIndex(index), 
				PropDefines.PropType.Dynamic => player.CurrentBackground.DynamicProps.GetPropByIndex(index), 
				_ => null, 
			};
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add((int)Target);
			data.DataInt.Add(BoolToInt(IsPlayAnimation));
			data.DataInt.Add((int)Source);
			if (Source == SourceType.Point)
			{
				data.DataFloat.Add(Position.x);
				data.DataFloat.Add(Position.y);
				data.DataFloat.Add(Position.z);
			}
			else if (Source == SourceType.Prop)
			{
				data.DataInt.Add((int)Props);
				data.DataInt.Add(PropsId);
			}
			else if (Source == SourceType.PropNode)
			{
				data.DataInt.Add((int)Props);
				data.DataInt.Add(PropsId);
				data.DataInt.Add(PropsAnchorId);
			}
		}
	}
	public class CommandCharaMotion : ICharaCommand
	{
		public int Motion;

		public bool IsFade = true;

		public bool IsPlayAnimation = true;

		public override Types Type => Types.CharaMotion;

		public CommandCharaMotion()
		{
		}

		public CommandCharaMotion(GameDefine.CharaID chara, int motion, bool isFade, bool isPlayAnimation)
			: base(chara)
		{
			Motion = motion;
			IsFade = isFade;
			IsPlayAnimation = isPlayAnimation;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
			if (chara == null)
			{
				return true;
			}
			SetCharaSafetyFlag(chara);
			if (!chara.IsActive && !player.HasPlayedFirstFade)
			{
				ForceUpdateAnimation(chara);
				return true;
			}
			chara.Model.PlayAnimation(Motion, IsFade, !IsPlayAnimation);
			return true;
		}

		private void ForceUpdateAnimation(AdvChara chara)
		{
			chara.SetForcus(isForcus: true);
			chara.SetEnable(isEnable: true);
			chara.Model.PlayAnimation(Motion, IsFade, isSkipAnimation: true);
			chara.SetEnable(isEnable: false);
		}

		protected virtual void SetCharaSafetyFlag(AdvChara chara)
		{
			chara.HasInitialMotion = true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaMotion)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"{Chara}  {Motion} ";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(Motion);
			data.DataInt.Add(BoolToInt(IsFade));
			data.DataInt.Add(BoolToInt(IsPlayAnimation));
		}
	}
	public class CommandCharaOff : CommandCharaOn
	{
		public override Types Type => Types.CharaOff;

		protected override bool IsActivateChara => false;

		public CommandCharaOff()
		{
		}

		public CommandCharaOff(SequenceData.Param data, int version, bool isFade)
			: base(data, version, isFade)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SetCharaInListActive(player, isActive: false);
			return true;
		}

		public override string CreateDescriptionText()
		{
			return $":{FadeDuration}";
		}
	}
	public class CommandCharaOn : ICharaCommand
	{
		private class PlayData
		{
			public AdvChara Chara;

			public Action EnableAction;

			public PlayData(AdvChara chara, Action onFade)
			{
				Chara = chara;
				EnableAction = onFade;
			}
		}

		public float FadeDuration = 0.3f;

		public List<GameDefine.CharaID> CharaList;

		private List<PlayData> m_charaData;

		public override Types Type => Types.CharaOn;

		protected virtual bool IsActivateChara => true;

		public CommandCharaOn()
		{
			CharaList = new List<GameDefine.CharaID>();
			CharaList.Add(GameDefine.CharaID.NIKAIDOU);
		}

		public CommandCharaOn(SequenceData.Param data, int version, bool isFade)
		{
			CharaList = new List<GameDefine.CharaID>();
			int startIndex = 0;
			IsMemoryMode = false;
			if (version > 5)
			{
				IsMemoryMode = IntToBool(data.DataInt[startIndex++]);
			}
			CreateCharaEnableListFromData(data, startIndex);
			if (data.DataFloat.Count > 0)
			{
				FadeDuration = data.DataFloat[0];
				if (!isFade)
				{
					FadeDuration = 0f;
				}
				InitializeCharaList();
			}
		}

		protected virtual void InitializeCharaList()
		{
			if (!SingletonMonoBehaviour<CharactersManager>.HasInstance)
			{
				return;
			}
			m_charaData = new List<PlayData>();
			int count = CharaList.Count;
			for (int i = 0; i < count; i++)
			{
				AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(CharaList[i]);
				m_charaData.Add(new PlayData(chara, delegate
				{
					chara.SetEnable(IsActivateChara);
				}));
			}
		}

		private void CreateCharaEnableListFromData(SequenceData.Param data, int startIndex)
		{
			int count = data.DataInt.Count;
			for (int i = startIndex; i < count; i++)
			{
				CharaList.Add((GameDefine.CharaID)data.DataInt[i]);
			}
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaOn)MemberwiseClone();
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SetCharaInListActive(player, isActive: true);
			return true;
		}

		protected virtual void SetCharaInListActive(TimelinePlayer player, bool isActive)
		{
			int count = CharaList.Count;
			for (int i = 0; i < count; i++)
			{
				SetCharaActive(player, i, isActive);
			}
		}

		protected virtual void SetCharaActive(TimelinePlayer player, int index, bool isActive)
		{
			AdvChara chara = m_charaData[index].Chara;
			if (isActive != chara.IsActive)
			{
				float targetAlpha = 0f;
				if (isActive)
				{
					targetAlpha = 1f;
					chara.SetEnable(isActive);
					chara.Model.SetModelAlpha(0f);
				}
				chara.Model.StartFade(targetAlpha, FadeDuration, m_charaData[index].EnableAction);
			}
		}

		public override string CreateDescriptionText()
		{
			string arg = ((FadeDuration <= 0f) ? "()" : $"( {FadeDuration:0.0} )");
			return $" {arg}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(BoolToInt(IsMemoryMode));
			int count = CharaList.Count;
			for (int i = 0; i < count; i++)
			{
				data.DataInt.Add((int)CharaList[i]);
			}
			data.DataFloat.Add(FadeDuration);
		}
	}
	public class CommandCharaOutlineChange : ICharaCommand
	{
		private const float DEFAULT_ALPHA = 0.2f;

		public Color NextColor = new Color(0.75f, 0.75f, 0.75f);

		public float Duration = 0.5f;

		public float Threshold = 0.1f;

		public bool ChangeColor = true;

		public bool ChangeSize = true;

		public float FadeDuration = 0.3f;

		public override Types Type => Types.OutlineChange;

		public CommandCharaOutlineChange()
		{
		}

		public CommandCharaOutlineChange(SequenceData.Param data, int version)
		{
			Chara = (GameDefine.CharaID)data.DataInt[0];
			NextColor = new Color(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2], data.DataFloat[3]);
			Duration = data.DataFloat[4];
			Threshold = data.DataFloat[5];
			ChangeColor = IntToBool(data.DataInt[1]);
			ChangeSize = IntToBool(data.DataInt[2]);
			FadeDuration = data.DataFloat[6];
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SetCharaOutlineChange(player, Chara, NextColor, Duration, Threshold, ChangeColor, ChangeSize, FadeDuration);
			return true;
		}

		protected void SetCharaOutlineChange(TimelinePlayer player, GameDefine.CharaID charaID, Color color, float duration, float threashold, bool changeColor, bool changeSize, float fadeDuration)
		{
			if (charaID == GameDefine.CharaID.BASE || charaID == GameDefine.CharaID.NONE)
			{
				return;
			}
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
			if (fadeDuration > 0f)
			{
				if (changeColor && changeSize)
				{
					chara.Model.StartOutlineChangeWithFade(color, 0.2f, fadeDuration);
				}
				else if (changeColor)
				{
					chara.Model.StartOutlineChangeWithFade(threashold, 0.2f, fadeDuration);
				}
				else if (changeSize)
				{
					chara.Model.StartOutlineChangeWithFade(color, threashold, 0.2f, fadeDuration);
				}
			}
			else
			{
				if (changeColor)
				{
					chara.Model.StartOutlineColorChange(color, Duration);
				}
				if (changeSize)
				{
					chara.Model.StartOutlineSizeChange(threashold, Duration);
				}
			}
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaOutlineChange)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return ", :" + Threshold;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataFloat.Add(NextColor.r);
			data.DataFloat.Add(NextColor.g);
			data.DataFloat.Add(NextColor.b);
			data.DataFloat.Add(NextColor.a);
			data.DataFloat.Add(Duration);
			data.DataFloat.Add(Threshold);
			data.DataInt.Add(BoolToInt(ChangeColor));
			data.DataInt.Add(BoolToInt(ChangeSize));
			data.DataFloat.Add(FadeDuration);
		}
	}
	public class CommandCharaPosition : ICharaCommand
	{
		public Vector3 Position = Vector3.zero;

		public bool IsFade = true;

		public bool IsReletiveToPlayer = true;

		public bool IsLockY = true;

		private AdvChara m_chara;

		private Action m_onStartFadeEnd;

		public override Types Type => Types.CharaPosition;

		public CommandCharaPosition()
		{
		}

		public CommandCharaPosition(GameDefine.CharaID chara, Vector3 pos, bool isReletiveToPlayer, bool isFade, bool isLockY)
		{
			Position = pos;
			Chara = chara;
			IsReletiveToPlayer = isReletiveToPlayer;
			IsFade = isFade;
			IsLockY = isLockY;
			if (SingletonMonoBehaviour<CharactersManager>.HasInstance)
			{
				m_chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
				m_onStartFadeEnd = delegate
				{
					SetCharaPosition(m_chara);
				};
			}
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaPosition)MemberwiseClone();
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
			if (chara == null)
			{
				SayOops("I couldn't find Character: " + Chara);
				return true;
			}
			if (!IsFade || !chara.IsActive || chara.Transform.position == Position)
			{
				SetCharaPosition(chara);
				return true;
			}
			SetNextPosition(chara);
			chara.Model.PlayPingPongFade(0.3f, 0.3f, m_onStartFadeEnd);
			return true;
		}

		protected virtual void SetNextPosition(AdvChara chara)
		{
			chara.NextPosition = Position;
		}

		protected virtual void SetCharaPosition(AdvChara chara)
		{
			if (IsReletiveToPlayer)
			{
				SetCharaPositionReletiveToPlayer(MainPosition.MainTransform, chara);
			}
			else
			{
				chara.Transform.localPosition = Position;
			}
		}

		public void SetCharaPositionReletiveToPlayer(Transform player, AdvChara chara)
		{
			SetCharaPositionReletiveToPlayer(player, chara.Transform);
		}

		public void SetCharaPositionReletiveToPlayer(Transform player, Transform chara)
		{
			chara.localPosition = GetPositionReletiveToTarget(player);
		}

		public static void SetCharaPositionReletiveToPlayer(Transform player, AdvChara chara, ref Vector3 pos, bool isLockY)
		{
			chara.Transform.localPosition = GetPositionReletiveToTarget(player, ref pos, isLockY);
		}

		public static void SetCharaNextPositionReletiveToPlayer(Transform player, AdvChara chara, ref Vector3 pos, bool isLockY)
		{
			chara.NextPosition = GetPositionReletiveToTarget(player, ref pos, isLockY);
		}

		public Vector3 GetPositionReletiveToTarget(Transform target)
		{
			return GetPositionReletiveToTarget(target, ref Position, IsLockY);
		}

		public static Vector3 GetPositionReletiveToTarget(Transform target, ref Vector3 position, bool isLockY)
		{
			Vector3 position2 = target.position;
			Vector3 forward = target.forward;
			float y = position2.y;
			position2 += forward * position.z;
			position2 += target.right * position.x;
			if (isLockY)
			{
				position2.y += position.y - y;
			}
			else
			{
				position2.y -= 5.17f;
			}
			return position2;
		}

		public Vector3 GetCharaPosition(Transform player)
		{
			if (IsReletiveToPlayer)
			{
				return GetPositionReletiveToTarget(player);
			}
			return Position;
		}

		public override string CreateDescriptionText()
		{
			string text = (IsFade ? "" : " ()");
			if (IsReletiveToPlayer)
			{
				return $"{Chara} :  {Position.ToString()}" + text;
			}
			return $"{Chara} :  {Position.ToString()}" + text;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(BoolToInt(IsReletiveToPlayer));
			data.DataInt.Add(BoolToInt(IsFade));
			data.DataFloat.Add(Position.x);
			data.DataFloat.Add(Position.y);
			data.DataFloat.Add(Position.z);
			data.DataInt.Add(BoolToInt(IsLockY));
		}
	}
	public class CommandCharaPositionReletive : CommandCharaPosition
	{
		public override Types Type => Types.CharaPositionReletive;

		public CommandCharaPositionReletive()
		{
		}

		public CommandCharaPositionReletive(GameDefine.CharaID chara, Vector3 position, bool isFade)
			: base(chara, position, isReletiveToPlayer: false, isFade, isLockY: false)
		{
		}

		protected override void SetCharaPosition(AdvChara chara)
		{
			chara.Transform.Translate(Position, Space.Self);
		}

		protected override void SetNextPosition(AdvChara chara)
		{
			Vector3 a = chara.Transform.localPosition;
			Vector3Extension.Add(ref a, ref Position, out chara.NextPosition);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaPositionReletive)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $": {Position}";
		}
	}
	public class CommandCharaRotation : ICharaCommand
	{
		public Vector3 Rotation = Vector3.zero;

		public bool IsReletiveToPlayer = true;

		public bool IsFade = true;

		private AdvChara m_chara;

		private Action m_onFade;

		public override Types Type => Types.CharaRotate;

		public CommandCharaRotation()
		{
		}

		public CommandCharaRotation(GameDefine.CharaID chara, Vector3 rotation, bool isReletiveToPlayer, bool isFade)
		{
			Rotation = rotation;
			Chara = chara;
			IsReletiveToPlayer = isReletiveToPlayer;
			IsFade = isFade;
			if (SingletonMonoBehaviour<CharactersManager>.HasInstance)
			{
				m_chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
				m_onFade = delegate
				{
					SetCharaRotation(m_chara);
				};
			}
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaRotation)MemberwiseClone();
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
			if (chara == null)
			{
				SayOops("I couldn't find Character: " + Chara);
				return true;
			}
			if (!IsFade || !chara.IsActive)
			{
				SetCharaRotation(chara);
				return true;
			}
			chara.Model.PlayPingPongFade(0.3f, 0.3f, m_onFade);
			return true;
		}

		protected virtual void SetCharaRotation(AdvChara chara)
		{
			if (IsReletiveToPlayer)
			{
				SetCharaRotationReletiveToPlayer(MainPosition.MainTransform, chara);
			}
			else
			{
				chara.Transform.localEulerAngles = Rotation;
			}
		}

		public void SetCharaRotationReletiveToPlayer(Transform player, AdvChara chara)
		{
			SetCharaRotationReletiveToPlayer(player, chara.Transform, ref Rotation);
		}

		public static void SetCharaRotationReletiveToPlayer(Transform player, Transform chara, ref Vector3 rotation)
		{
			chara.eulerAngles = player.rotation.eulerAngles;
			chara.Rotate(rotation);
		}

		public override string CreateDescriptionText()
		{
			string text = (IsFade ? "" : " ()");
			if (IsReletiveToPlayer)
			{
				return $"{Chara} :  {Rotation.ToString()}" + text;
			}
			return $"{Chara} :  {Rotation.ToString()}" + text;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(BoolToInt(IsReletiveToPlayer));
			data.DataInt.Add(BoolToInt(IsFade));
			data.DataFloat.Add(Rotation.x);
			data.DataFloat.Add(Rotation.y);
			data.DataFloat.Add(Rotation.z);
		}
	}
	public class CommandCharaRotationReletive : CommandCharaRotation
	{
		public override Types Type => Types.CharaRotateReletive;

		public CommandCharaRotationReletive()
		{
		}

		public CommandCharaRotationReletive(GameDefine.CharaID chara, Vector3 rotation, bool isReletiveToPlayer, bool isFade)
			: base(chara, rotation, isReletiveToPlayer, isFade)
		{
		}

		protected override void SetCharaRotation(AdvChara chara)
		{
			chara.Transform.Rotate(Rotation, Space.Self);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaRotationReletive)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return string.Format("{0}  : {1}{2}", Chara, Rotation, IsFade ? "" : " ()");
		}
	}
	public class CommandCharaSetMirrorMode : ICharaCommand
	{
		public enum MirrorModeTypes
		{
			NoMirror,
			DrawOnlyMirror
		}

		public MirrorModeTypes MirrorMode;

		public bool isTrackingPlayerHead;

		public override Types Type => Types.CharaSetMirrorMode;

		public CommandCharaSetMirrorMode()
		{
		}

		public CommandCharaSetMirrorMode(GameDefine.CharaID chara, int modeInt, bool isTrackingHead = false)
		{
			Chara = chara;
			MirrorMode = (MirrorModeTypes)modeInt;
			isTrackingPlayerHead = isTrackingHead;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaSetMirrorMode)MemberwiseClone();
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SetCharaMirrorMode();
			return true;
		}

		protected void SetCharaMirrorMode()
		{
			Vector3 scale = Vector3.one;
			bool isMirroring = false;
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
			if (MirrorMode == MirrorModeTypes.DrawOnlyMirror)
			{
				scale = new Vector3(-1f, 1f, 1f);
				isMirroring = true;
			}
			chara.AttachMirroring(scale, isMirroring, isTrackingPlayerHead);
		}

		public override string ToString()
		{
			return $"{Type.ToString()} : {Chara.ToString()}";
		}

		public override string CreateDescriptionText()
		{
			string arg = "";
			string arg2 = "";
			switch (MirrorMode)
			{
			case MirrorModeTypes.NoMirror:
				arg = "";
				break;
			case MirrorModeTypes.DrawOnlyMirror:
				arg = "";
				break;
			}
			if (isTrackingPlayerHead)
			{
				arg2 = "";
			}
			return $"{Chara} {arg} {arg2}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add((int)MirrorMode);
			data.DataInt.Add(BoolToInt(isTrackingPlayerHead));
		}
	}
	public class CommandCharaStyleChange : ICharaCommand
	{
		public bool IsChange;

		public override Types Type => Types.CharaStyleChange;

		public CommandCharaStyleChange()
		{
		}

		public CommandCharaStyleChange(SequenceData.Param data, int version)
		{
			Chara = (GameDefine.CharaID)data.DataInt[0];
			IsChange = IntToBool(data.DataInt[1]);
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SetCharaStyleChange(player, Chara, IsChange);
			return true;
		}

		protected void SetCharaStyleChange(TimelinePlayer player, GameDefine.CharaID charaID, bool isChange)
		{
			SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara).StyleChange.CharaStyleChange(isChange);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaStyleChange)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string arg = "";
			string arg2 = "";
			if (!IsChange)
			{
				arg2 = "";
			}
			switch (Chara)
			{
			case GameDefine.CharaID.SAKURAI:
			case GameDefine.CharaID.TOUGOKU:
			case GameDefine.CharaID.KAGEYAMA:
				arg = "";
				break;
			case GameDefine.CharaID.HITOKAGE:
				arg = "";
				break;
			}
			return $"{Chara} {arg}{arg2}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(BoolToInt(IsChange));
		}
	}
	public class CommandCharaTexture : ICharaCommand
	{
		public AdvCharaTextureData.TextureType TextureType;

		private AdvChara m_chara;

		public override Types Type => Types.CharaTexture;

		public CommandCharaTexture()
		{
		}

		public CommandCharaTexture(SequenceData.Param data, int version)
		{
			Chara = (GameDefine.CharaID)data.DataInt[0];
			TextureType = (AdvCharaTextureData.TextureType)data.DataInt[1];
			if (SingletonMonoBehaviour<CharactersManager>.HasInstance)
			{
				m_chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
			}
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			m_chara.Model.SetTexture(TextureType);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaTexture)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"{TextureType}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add((int)TextureType);
		}
	}
	public class CommandCharaTransform : ICharaCommand
	{
		public enum MoveType
		{
			World,
			Self,
			ReletivePlayer,
			Radius
		}

		public enum RotationType
		{
			World,
			Self,
			ReletivePlayer
		}

		public Vector3 Position = Vector3Extension.Zero;

		public Vector3 Rotation = Vector3Extension.Zero;

		public int Motion;

		public int Facial = 301;

		public float Radius = 7f;

		public float Angle;

		public MoveType MoveMode;

		public RotationType RotationMode;

		public bool IsMove;

		public bool IsRotate;

		public bool IsMotion;

		public bool IsFacial;

		public bool IsFade = true;

		public bool IsPlayAnimationMotion = true;

		public bool IsPlayAnimationFace = true;

		public bool IsLockY = true;

		private AdvChara m_chara;

		private Action m_onStartFadeEnd;

		public override Types Type => Types.CharaTransform;

		public CommandCharaTransform()
		{
		}

		public CommandCharaTransform(GameDefine.CharaID chara, bool isMove, bool isRotate, bool isMotion, bool isFacial, bool isFade)
			: base(chara)
		{
			IsMove = isMove;
			IsRotate = isRotate;
			IsMotion = isMotion;
			IsFacial = isFacial;
			IsFade = isFade;
			if (SingletonMonoBehaviour<CharactersManager>.HasInstance)
			{
				m_chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
				m_onStartFadeEnd = delegate
				{
					ApplyTransform(m_chara, MainPosition.MainTransform, isFade: true);
				};
			}
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (m_chara == null)
			{
				return true;
			}
			if (!IsFade || !m_chara.IsActive)
			{
				PlayNow(player.HasPlayedFirstFade);
				return true;
			}
			SetCharaNextPosition(m_chara, MainPosition.MainTransform);
			m_chara.Model.PlayPingPongFade(1f, 0.3f, 0.3f, m_onStartFadeEnd);
			return true;
		}

		private void PlayNow(bool hasPlayedFirstFade)
		{
			if (!m_chara.IsActive && (!hasPlayedFirstFade || !m_chara.IsForcused))
			{
				m_chara.SetForcus(isForcus: true);
				m_chara.SetEnable(isEnable: true);
				ApplyTransform(m_chara, MainPosition.MainTransform, isFade: false);
				if (hasPlayedFirstFade)
				{
					m_chara.SetForcus(isForcus: false);
				}
				m_chara.SetEnable(isEnable: false);
			}
			else
			{
				ApplyTransform(m_chara, MainPosition.MainTransform, isFade: false);
			}
		}

		public void ApplyTransform(AdvChara chara, Transform player, bool isFade)
		{
			SetCharaPosition(chara, player, isFade);
			SetCharaRotation(chara.Transform, player);
			PlayMotion(chara);
			PlayFacial(chara);
		}

		private void SetCharaNextPosition(AdvChara chara, Transform player)
		{
			if (IsMove)
			{
				if (MoveMode == MoveType.Self)
				{
					Vector3 a = chara.Transform.position;
					Vector3Extension.Add(ref a, ref Position, out chara.NextPosition);
				}
				else if (MoveMode == MoveType.ReletivePlayer)
				{
					CommandCharaPosition.SetCharaNextPositionReletiveToPlayer(player, chara, ref Position, IsLockY);
				}
				else if (MoveMode == MoveType.Radius)
				{
					chara.NextPosition = CommandCharaCircularPosition.CauclateCharaPosition(player, Angle, Radius);
				}
				else
				{
					chara.NextPosition = Position;
				}
			}
		}

		private void SetCharaPosition(AdvChara chara, Transform player, bool isFade)
		{
			if (IsMove)
			{
				if (isFade)
				{
					chara.Transform.position = chara.NextPosition;
				}
				else if (MoveMode == MoveType.Self)
				{
					chara.Transform.Translate(Position, Space.Self);
				}
				else if (MoveMode == MoveType.ReletivePlayer)
				{
					CommandCharaPosition.SetCharaPositionReletiveToPlayer(player, chara, ref Position, IsLockY);
				}
				else if (MoveMode == MoveType.Radius)
				{
					chara.Transform.position = CommandCharaCircularPosition.CauclateCharaPosition(player, Angle, Radius);
				}
				else
				{
					chara.Transform.position = Position;
				}
			}
		}

		private void SetCharaRotation(Transform chara, Transform player)
		{
			if (IsRotate)
			{
				SetCharaRotation(RotationMode, chara, player, ref Rotation);
			}
		}

		public static void SetCharaRotation(RotationType mode, Transform chara, Transform player, ref Vector3 rotation)
		{
			switch (mode)
			{
			case RotationType.Self:
				chara.Rotate(rotation, Space.Self);
				break;
			case RotationType.ReletivePlayer:
				CommandCharaRotation.SetCharaRotationReletiveToPlayer(player, chara, ref rotation);
				break;
			default:
				chara.localEulerAngles = rotation;
				break;
			}
		}

		private void PlayMotion(AdvChara chara)
		{
			if (IsMotion)
			{
				chara.HasInitialMotion = true;
				PlayAnimation(chara, Motion, IsPlayAnimationMotion);
			}
		}

		private void PlayFacial(AdvChara chara)
		{
			if (IsFacial)
			{
				chara.HasInitialFacial = true;
				PlayAnimation(chara, Facial, IsPlayAnimationFace);
			}
		}

		private void PlayAnimation(AdvChara chara, int animation, bool isPlay)
		{
			chara.Model.EnableAnimatorForFrame();
			chara.Model.PlayAnimation(animation, isFade: false, !isPlay);
			chara.Model.SkipAnimationOnNonForcus();
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaTransform)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $":{Chara}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(BoolToInt(IsMove));
			data.DataInt.Add(BoolToInt(IsRotate));
			data.DataInt.Add(BoolToInt(IsMotion));
			data.DataInt.Add(BoolToInt(IsFacial));
			data.DataInt.Add(BoolToInt(IsFade));
			SavePosition(data);
			SaveRotation(data);
			SaveMotion(data);
			SaveFacial(data);
		}

		private void SavePosition(SequenceData.Param data)
		{
			if (IsMove)
			{
				data.DataInt.Add((int)MoveMode);
				if (MoveMode == MoveType.Radius)
				{
					data.DataFloat.Add(Angle);
					data.DataFloat.Add(Radius);
					return;
				}
				data.DataFloat.Add(Position.x);
				data.DataFloat.Add(Position.y);
				data.DataFloat.Add(Position.z);
				data.DataInt.Add(BoolToInt(IsLockY));
			}
		}

		private void SaveRotation(SequenceData.Param data)
		{
			if (IsRotate)
			{
				data.DataInt.Add((int)RotationMode);
				data.DataFloat.Add(Rotation.x);
				data.DataFloat.Add(Rotation.y);
				data.DataFloat.Add(Rotation.z);
			}
		}

		private void SaveMotion(SequenceData.Param data)
		{
			if (IsMotion)
			{
				data.DataInt.Add(Motion);
				data.DataInt.Add(BoolToInt(IsPlayAnimationMotion));
			}
		}

		private void SaveFacial(SequenceData.Param data)
		{
			if (IsFacial)
			{
				data.DataInt.Add(Facial);
				data.DataInt.Add(BoolToInt(IsPlayAnimationFace));
			}
		}

		public void ApplyPositionRotation(AdvChara chara, Transform player)
		{
			SetCharaPosition(chara, player, isFade: false);
			SetCharaRotation(chara.Transform, player);
		}
	}
	public class CommandClearColour : ISequenceCommand
	{
		public Color ClearColour;

		public override Types Type => Types.CameraClearColour;

		public CommandClearColour()
		{
		}

		public CommandClearColour(Color col)
		{
			ClearColour = col;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SingletonMonoBehaviour<PlayAreaManager>.Instance.SetClearColor(ClearColour);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandClearColour)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"{ClearColour}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataFloat.Add(ClearColour.r);
			data.DataFloat.Add(ClearColour.g);
			data.DataFloat.Add(ClearColour.b);
		}
	}
	public class CommandCpuGpuLevel : ISequenceCommand
	{
		public int CpuLevel = 2;

		public int GpuLevel = 2;

		public override Types Type => Types.CpuGpuLevel;

		public CommandCpuGpuLevel()
		{
		}

		public CommandCpuGpuLevel(SequenceData.Param data, int version)
		{
			CpuLevel = data.DataInt[0];
			GpuLevel = data.DataInt[1];
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			OVRManager.cpuLevel = CpuLevel;
			OVRManager.gpuLevel = GpuLevel;
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCpuGpuLevel)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"CpuGpuGOCpu = {CpuLevel}, Gpu = {GpuLevel}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(CpuLevel);
			data.DataInt.Add(GpuLevel);
		}
	}
	public class CommandEditorNote : ISequenceCommand
	{
		public string Text = "";

		public override Types Type => Types.EditorNote;

		public CommandEditorNote()
		{
		}

		public CommandEditorNote(string text)
		{
			Text = text;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandEditorNote)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			int num = Text.IndexOf('\n');
			string result = Text;
			if (num >= 0)
			{
				result = Text.Substring(0, num);
			}
			return result;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataString.Add(Text);
		}
	}
	public class CommandEmotion : ICharaCommand
	{
		public EmotionImage.Types Emotion = EmotionImage.Types.Attention;

		public Vector3 Offset = Vector3Extension.Zero;

		public override Types Type => Types.Emotion;

		public CommandEmotion()
		{
		}

		public CommandEmotion(GameDefine.CharaID chara, EmotionImage.Types emotion, Vector3 offset)
			: base(chara)
		{
			Emotion = emotion;
			Offset = offset;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.EmotionProcessor.Generate(Emotion, Chara, ref Offset);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandEmotion)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"{Chara}  {Emotion}  ({Offset.ToString()})";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add((int)Emotion);
			data.DataFloat.Add(Offset.x);
			data.DataFloat.Add(Offset.y);
			data.DataFloat.Add(Offset.z);
		}
	}
	public class CommandEnableTypingSound : BaseCommandEnable
	{
		public override Types Type => Types.EnableTypingSound;

		public CommandEnableTypingSound()
		{
		}

		public CommandEnableTypingSound(SequenceData.Param data)
			: base(data)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MessageProcessor.IsEmitSoundOnMessage = ToggleFlag;
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandEnableTypingSound)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return ": " + GetFlagText();
		}

		protected override string GetFlagText()
		{
			if (!ToggleFlag)
			{
				return "";
			}
			return "";
		}
	}
	public class CommandEndDemo : ISequenceCommand
	{
		public override Types Type => Types.EndDemo;

		public override bool IsDeprecated => true;

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.EndDemo();
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandEndDemo)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return " ()";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandEndInGame : ISequenceCommand
	{
		public enum EndTypes
		{
			ToTitle = 0,
			NewGame = 1,
			NewGameSecond = 2,
			OnlyForDemo = 126,
			ToEndDemo = 127,
			InstantExit = 255
		}

		public EndTypes EndType;

		public int NextScenarioAfterContinue = 10000;

		public override Types Type => Types.EndInGame;

		public override bool PlayInHardSkip => true;

		public CommandEndInGame()
		{
		}

		public CommandEndInGame(SequenceData.Param data)
		{
			EndType = (EndTypes)data.GetInt(0);
			NextScenarioAfterContinue = data.GetInt(1);
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.CompleteScenario();
			if (NextScenarioAfterContinue >= 0)
			{
				SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID = NextScenarioAfterContinue;
				player.ResolveReservedAutoSave();
			}
			switch (EndType)
			{
			case EndTypes.ToTitle:
				player.QuitToTitle();
				break;
			case EndTypes.InstantExit:
				player.QuitApplication();
				break;
			case EndTypes.ToEndDemo:
				player.EndDemo();
				break;
			default:
				throw new CommandFailedException(this, EndType.ToString() + " is not implement!");
			case EndTypes.OnlyForDemo:
				break;
			}
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandEndInGame)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string text = "";
			switch (EndType)
			{
			case EndTypes.ToTitle:
				text = "";
				break;
			case EndTypes.NewGame:
				text = "";
				break;
			case EndTypes.NewGameSecond:
				text = "2";
				break;
			case EndTypes.OnlyForDemo:
				text = " ()";
				break;
			case EndTypes.ToEndDemo:
				text = "";
				break;
			case EndTypes.InstantExit:
				text = "";
				break;
			}
			if (NextScenarioAfterContinue >= 0)
			{
				text += $"(ContinueSqid: {NextScenarioAfterContinue:00000})";
			}
			return " -> " + text;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)EndType);
			data.DataInt.Add(NextScenarioAfterContinue);
		}
	}
	public class CommandEnvironmentBlendShape : ISequenceCommand
	{
		public int Index;

		public float Weight = 100f;

		public override Types Type => Types.EnvrionmentBlendShape;

		public CommandEnvironmentBlendShape()
		{
		}

		public CommandEnvironmentBlendShape(int index, float weight)
		{
			Index = index;
			Weight = weight;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			AdvBackground currentBackground = player.CurrentBackground;
			if (currentBackground == null)
			{
				SayOops("I cannot find AdvBackground.");
				return true;
			}
			currentBackground.SetBlendShape(this);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandEnvironmentBlendShape)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "Index = " + Index + ", Weight = " + Weight;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(Index);
			data.DataFloat.Add(Weight);
		}
	}
	public class CommandEnvironmentPropsOff : CommandEnvironmentPropsOn
	{
		public override Types Type => Types.EnvironmentPropsOff;

		public override bool IsDeprecated => true;

		public CommandEnvironmentPropsOff()
		{
			IsActive = false;
		}

		public CommandEnvironmentPropsOff(int index)
			: base(index, isActive: false)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			return base.PlayCommand(player);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandEnvironmentPropsOff)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "Props: ID = " + Index;
		}
	}
	public class CommandEnvironmentPropsOn : ISequenceCommand
	{
		public int Index;

		public bool IsActive;

		public override Types Type => Types.EnvironmentPropsOn;

		public override bool IsDeprecated => true;

		public CommandEnvironmentPropsOn()
		{
		}

		public CommandEnvironmentPropsOn(int index, bool isActive)
		{
			Index = index;
			IsActive = isActive;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandEnvironmentPropsOn)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "Props: ID = " + Index;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(Index);
			data.DataInt.Add(BoolToInt(IsActive));
		}
	}
	public class CommandEnvironmentPropsPosition : ISequenceCommand
	{
		public int Index;

		public Vector3 Position = Vector3.zero;

		public override Types Type => Types.EnvironmentPropsPosition;

		public override bool IsDeprecated => true;

		public CommandEnvironmentPropsPosition()
		{
		}

		public CommandEnvironmentPropsPosition(int index, Vector3 pos)
		{
			Index = index;
			Position = pos;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandEnvironmentPropsPosition)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "Props: ID = " + Index + ", Pos = " + Position;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(Index);
			data.DataFloat.Add(Position.x);
			data.DataFloat.Add(Position.y);
			data.DataFloat.Add(Position.z);
		}
	}
	public class CommandEnvironmentPropsRotation : ISequenceCommand
	{
		public int Index;

		public Vector3 Rotation = Vector3.zero;

		public override Types Type => Types.EnvironmentPropsRotation;

		public override bool IsDeprecated => true;

		public CommandEnvironmentPropsRotation()
		{
		}

		public CommandEnvironmentPropsRotation(int index, Vector3 rotation)
		{
			Index = index;
			Rotation = rotation;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandEnvironmentPropsRotation)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "Props: ID = " + Index + ",  = " + Rotation;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(Index);
			data.DataFloat.Add(Rotation.x);
			data.DataFloat.Add(Rotation.y);
			data.DataFloat.Add(Rotation.z);
		}
	}
	public class CommandFadeIn : ISequenceCommand
	{
		public Color StartColour = ColorDefine.TransparentBlack;

		public Color EndColour = ColorDefine.Black;

		public float Duration = 0.6f;

		public bool IsDeactivateOnEnd;

		public override Types Type => Types.FadeIn;

		public CommandFadeIn()
		{
		}

		public CommandFadeIn(Color start, Color end, float duration, bool isDeactivateOnEnd)
		{
			StartColour = start;
			EndColour = end;
			Duration = duration;
			IsDeactivateOnEnd = isDeactivateOnEnd;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandFadeIn)MemberwiseClone();
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			float duration = Duration;
			player.Fader.StartFade(StartColour, EndColour, duration, IsDeactivateOnEnd, player.ReleaseCommandWait);
			if (!player.HasPlayedFirstFade && duration <= 0f)
			{
				return true;
			}
			if (!player.HasPlayedFirstFade)
			{
				player.PrepareOnFirstFade();
			}
			if (MainPosition.Avater.AvaterResources.HasTrackedHands)
			{
				MainPosition.Avater.AvaterResources.TrackedHandLeftObject.ForceFadeHideTrackedHand(EndColour.a == 1f, duration);
				MainPosition.Avater.AvaterResources.TrackedHandRightObject.ForceFadeHideTrackedHand(EndColour.a == 1f, duration);
			}
			return duration <= 0f;
		}

		public override string CreateDescriptionText()
		{
			if (StartColour.a <= 0f)
			{
				return $" ({Duration:0.0} )";
			}
			if (StartColour.a >= 1f)
			{
				return $" ({Duration:0.0} )";
			}
			return $" ({Duration:0.0} )";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataFloat.Add(StartColour.r);
			data.DataFloat.Add(StartColour.g);
			data.DataFloat.Add(StartColour.b);
			data.DataFloat.Add(StartColour.a);
			data.DataFloat.Add(EndColour.r);
			data.DataFloat.Add(EndColour.g);
			data.DataFloat.Add(EndColour.b);
			data.DataFloat.Add(EndColour.a);
			data.DataFloat.Add(Duration);
			data.DataInt.Add(BoolToInt(IsDeactivateOnEnd));
		}
	}
	public class CommandFadeWithoutText : ISequenceCommand
	{
		public Color StartColour = ColorDefine.TransparentBlack;

		public Color EndColour = ColorDefine.Black;

		public float Duration = 0.2f;

		public override Types Type => Types.FadeWithoutText;

		public CommandFadeWithoutText()
		{
		}

		public CommandFadeWithoutText(Color start, Color end, float duration)
		{
			StartColour = start;
			EndColour = end;
			Duration = duration;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandFadeWithoutText)MemberwiseClone();
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MoverFader.Play(this);
			if (!player.HasPlayedFirstFade)
			{
				player.PrepareOnFirstFade();
				return false;
			}
			if (MainPosition.Avater.AvaterResources.HasTrackedHands)
			{
				MainPosition.Avater.AvaterResources.TrackedHandLeftObject.ForceHideTrackedHand(fide: true);
				MainPosition.Avater.AvaterResources.TrackedHandRightObject.ForceHideTrackedHand(fide: true);
			}
			return Duration <= 0f;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			if (!player.MoverFader.IsBusy)
			{
				return true;
			}
			return false;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataFloat.Add(StartColour.r);
			data.DataFloat.Add(StartColour.g);
			data.DataFloat.Add(StartColour.b);
			data.DataFloat.Add(StartColour.a);
			data.DataFloat.Add(EndColour.r);
			data.DataFloat.Add(EndColour.g);
			data.DataFloat.Add(EndColour.b);
			data.DataFloat.Add(EndColour.a);
			data.DataFloat.Add(Duration);
		}

		public override string CreateDescriptionText()
		{
			return $"";
		}
	}
	public class CommandFadeWithoutTextEnd : CommandFadeWithoutText
	{
		public override Types Type => Types.FadeWithoutTextEnd;

		public CommandFadeWithoutTextEnd()
		{
		}

		public CommandFadeWithoutTextEnd(Color start, Color end, float duration)
			: base(start, end, duration)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MoverFader.End(this);
			if (MainPosition.Avater.AvaterResources.HasTrackedHands)
			{
				MainPosition.Avater.AvaterResources.TrackedHandLeftObject.ForceHideTrackedHand(fide: false);
				MainPosition.Avater.AvaterResources.TrackedHandRightObject.ForceHideTrackedHand(fide: false);
			}
			return false;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			if (!player.MoverFader.IsBusy)
			{
				return true;
			}
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandFadeWithoutTextEnd)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"";
		}
	}
	public class CommandFixWindow : ISequenceCommand
	{
		public bool FixVertical;

		public float TargetFixYaw;

		public float TargetFixPitch;

		public override Types Type => Types.FixWindowStart;

		public CommandFixWindow()
		{
		}

		public CommandFixWindow(SequenceData.Param data)
		{
			FixVertical = IntToBool(data.GetInt(0));
			TargetFixYaw = data.GetFloat(0);
			TargetFixPitch = data.GetFloat(1);
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			MainPosition.WindowPositioner.IsFixedToFront = true;
			MainPosition.WindowPositioner.FrontFixYaw = TargetFixYaw;
			MainPosition.WindowPositioner.IsFixVertical = FixVertical;
			MainPosition.WindowPositioner.FrontFixPitch = TargetFixPitch;
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandFixWindow)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"<b></b>: [{TargetFixYaw:0.00}] [{FixVertical}]";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(BoolToInt(FixVertical));
			data.DataFloat.Add(TargetFixYaw);
			data.DataFloat.Add(TargetFixPitch);
		}
	}
	public class CommandFixWindowEnd : ISequenceCommand
	{
		public override Types Type => Types.FixWindowEnd;

		public override bool PlayCommand(TimelinePlayer player)
		{
			MainPosition.WindowPositioner.IsFixedToFront = false;
			MainPosition.WindowPositioner.IsFixVertical = false;
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandFixWindowEnd)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandFlashbackChange : CommandFlashbackStart
	{
		public override Types Type => Types.FlashBackChange;

		public CommandFlashbackChange()
		{
		}

		public CommandFlashbackChange(int id)
			: base(id)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.FlashbackProcessor.ChangeSprite(ID);
			return false;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			if (!player.FlashbackProcessor.IsBusy)
			{
				return true;
			}
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandFlashbackChange)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return ": ID = " + ID;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(ID);
		}
	}
	public class CommandFlashbackEnd : ISequenceCommand
	{
		public override Types Type => Types.FlashBackEnd;

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.FlashbackProcessor.Close();
			return false;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			if (!player.FlashbackProcessor.IsBusy)
			{
				return true;
			}
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandFlashbackEnd)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandFlashbackStart : ISequenceCommand
	{
		public const int _DEFAULT_ID = 0;

		public int ID;

		public float EndDistance = 40f;

		public override Types Type => Types.FlashBackStart;

		public override PreloadTypes PreloadType => PreloadTypes.FlashBack;

		public override int PreloadIndex => ID;

		public CommandFlashbackStart()
		{
		}

		public CommandFlashbackStart(int id)
		{
			ID = id;
		}

		public CommandFlashbackStart(SequenceData.Param data)
		{
			ID = data.DataInt[0];
			if (data.DataFloat.Count > 0)
			{
				EndDistance = data.DataFloat[0];
			}
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.FlashbackProcessor.Play(player.MainPositionTransform, player.Fader, this);
			return false;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			if (!player.FlashbackProcessor.IsBusy)
			{
				return true;
			}
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandFlashbackStart)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "ID = " + ID + ",  " + EndDistance;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(ID);
			data.DataFloat.Add(EndDistance);
		}
	}
	public class CommandForcusUpOff : ISequenceCommand
	{
		public int WindowID;

		public ForcusUpWindow.FadeType FadeType = ForcusUpWindow.FadeType.Move;

		public bool IsSkip;

		public Ease MoveEaseType = Ease.InOutCubic;

		public override Types Type => Types.ForcusUpOff;

		public CommandForcusUpOff()
		{
		}

		public CommandForcusUpOff(int windowID, ForcusUpWindow.FadeType fadeType, bool isSkip, Ease moveEaseType)
		{
			WindowID = windowID;
			FadeType = fadeType;
			IsSkip = isSkip;
			MoveEaseType = moveEaseType;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.FocusUpProcessor.CloseWindowByID(FadeType, WindowID, MoveEaseType, IsSkip);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandForcusUpOff)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $": ID:{WindowID}, {FadeType}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(WindowID);
			data.DataInt.Add((int)FadeType);
			data.DataInt.Add(BoolToInt(IsSkip));
			data.DataInt.Add((int)MoveEaseType);
		}
	}
	public class CommandForcusUpWindow : ICharaCommand
	{
		public int ID;

		public int WindowID;

		public ForcusUpWindowController.SourceType Source = ForcusUpWindowController.SourceType.Chara;

		public ForcusUpWindow.FadeType FadeType = ForcusUpWindow.FadeType.Move;

		public float Distance = 5f;

		public Vector3 Offset = Vector3Extension.Zero;

		public Vector3 Scale = Vector3.one;

		public Vector3 TargetPoint = Vector3Extension.Zero;

		public Ease MoveEaseType = Ease.OutCubic;

		public int PropsID;

		public override Types Type => Types.ForcusUp;

		public override PreloadTypes PreloadType => PreloadTypes.FocusUp;

		public override int PreloadIndex => ID;

		public CommandForcusUpWindow()
		{
		}

		public CommandForcusUpWindow(int id, int windowID, ForcusUpWindowController.SourceType source, ForcusUpWindow.FadeType fade, GameDefine.CharaID chara, float distance, Vector3 offset, Vector3 scale, Vector3 targetPos, Ease moveEaseType, int propsID = -1)
		{
			ID = id;
			WindowID = windowID;
			FadeType = fade;
			Chara = chara;
			Source = source;
			Distance = distance;
			Offset = offset;
			MoveEaseType = moveEaseType;
			Scale = scale;
			TargetPoint = targetPos;
			PropsID = propsID;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.FocusUpProcessor.OpenWindow(this);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandForcusUpWindow)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $": ID:{WindowID}, ID:{ID}, {FadeType}, {Chara}, {Offset}, {Scale}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(ID);
			data.DataInt.Add(WindowID);
			data.DataInt.Add((int)FadeType);
			data.DataInt.Add((int)Chara);
			data.DataInt.Add((int)MoveEaseType);
			data.DataInt.Add((int)Source);
			data.DataInt.Add(PropsID);
			data.DataFloat.Add(Distance);
			data.DataFloat.Add(Offset.x);
			data.DataFloat.Add(Offset.y);
			data.DataFloat.Add(Offset.z);
			data.DataFloat.Add(Scale.x);
			data.DataFloat.Add(Scale.y);
			data.DataFloat.Add(Scale.z);
			data.DataFloat.Add(TargetPoint.x);
			data.DataFloat.Add(TargetPoint.y);
			data.DataFloat.Add(TargetPoint.z);
		}
	}
	public class CommandLogicElse : BaseLogicCommand
	{
		public override Types Type => Types.LogicElse;

		public CommandLogicElse()
		{
		}

		public CommandLogicElse(SequenceData.Param data)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			base.IsLogicTrue = !player.RemoveLastLogicStack();
			if (!player.IsLastLogicTrue())
			{
				base.IsLogicTrue = false;
			}
			player.AddLogicStack(this);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandLogicElse)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "} ELSE {";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandLogicEndIf : BaseLogicCommand
	{
		public override Types Type => Types.LogicEndIf;

		public CommandLogicEndIf()
		{
		}

		public CommandLogicEndIf(SequenceData.Param data)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.RemoveLastLogicStack();
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandLogicEndIf)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "} ENDIF";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandLogicIfFlag : BaseLogicCommand
	{
		public CommandParameters.Conditions ConditionType;

		public int FlagIndex;

		public bool FlagEquals;

		public override Types Type => Types.LogicIfFlag;

		public CommandLogicIfFlag()
		{
			ConditionType = CommandParameters.Conditions.Switch;
			FlagEquals = true;
		}

		public CommandLogicIfFlag(SequenceData.Param data)
		{
			ConditionType = (CommandParameters.Conditions)data.DataInt[0];
			FlagIndex = data.DataInt[1];
			FlagEquals = data.DataInt[2] != 0;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (player.IsLastLogicTrue())
			{
				switch (ConditionType)
				{
				case CommandParameters.Conditions.Enum:
					SayOops("Enum ");
					break;
				case CommandParameters.Conditions.False:
					base.IsLogicTrue = !FlagEquals;
					break;
				case CommandParameters.Conditions.True:
					base.IsLogicTrue = FlagEquals;
					break;
				case CommandParameters.Conditions.Switch:
					base.IsLogicTrue = SingletonMonoBehaviour<GameData>.Instance.SystemData.GetFlag(FlagIndex) == FlagEquals;
					break;
				case CommandParameters.Conditions.Readed:
					if (FlagIndex < 0)
					{
						base.IsLogicTrue = SingletonMonoBehaviour<GameData>.Instance.SystemData.IsScenarioReaded(player.LoadedScenarioID) == FlagEquals;
					}
					else
					{
						base.IsLogicTrue = SingletonMonoBehaviour<GameData>.Instance.SystemData.IsScenarioReaded(FlagIndex) == FlagEquals;
					}
					break;
				case CommandParameters.Conditions.LastSelection:
					base.IsLogicTrue = SingletonMonoBehaviour<LocalData>.Instance.LastSelectionIndex == FlagIndex;
					break;
				}
			}
			else
			{
				base.IsLogicTrue = false;
			}
			player.AddLogicStack(this);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandLogicIfFlag)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $": {GetConditionTargetString()} == {FlagEquals} {{";
		}

		private string GetConditionTargetString()
		{
			switch (ConditionType)
			{
			case CommandParameters.Conditions.Enum:
				return "ENUM ";
			case CommandParameters.Conditions.False:
				return "FALSE";
			case CommandParameters.Conditions.True:
				return "TRUE";
			case CommandParameters.Conditions.Switch:
				return $"ID[{(GameFlags)FlagIndex}]";
			case CommandParameters.Conditions.Readed:
				if (FlagIndex < 0)
				{
					return string.Format("ID[{0}]", "");
				}
				return $"ID[{FlagIndex:D5}]";
			case CommandParameters.Conditions.LastSelection:
				return $" {FlagIndex} ";
			default:
				return "UNKNOWN";
			}
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)ConditionType);
			data.DataInt.Add(FlagIndex);
			data.DataInt.Add(FlagEquals ? 1 : 0);
		}
	}
	public class CommandMemoryAmbient : CommandBgmSimple
	{
		public override Types Type => Types.MemoryAmbient;

		public CommandMemoryAmbient()
		{
		}

		public CommandMemoryAmbient(int id, float volume, float fadeDuration)
			: base(id, volume, fadeDuration)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (!player.CurrentBackground.HasAudioSource)
			{
				return true;
			}
			SoundManager.Bgm.PlaySimple(player.CurrentBackground.Audio, base.ID, Volume, FadeDuration);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMemoryAmbient)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"ID {base.ID},  {Volume},  {FadeDuration}";
		}
	}
	public class CommandMemoryAmbientOff : CommandBgmSimpleOff
	{
		public override Types Type => Types.MemoryAmbientOff;

		public CommandMemoryAmbientOff()
		{
		}

		public CommandMemoryAmbientOff(SequenceData.Param data, int version)
			: base(data.DataFloat[0])
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (!player.CurrentBackground.HasAudioSource)
			{
				return true;
			}
			SoundManager.Bgm.StopSimpleBgm(player.CurrentBackground.Audio, FadeDuration);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMemoryAmbientOff)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $" : {FadeDuration}";
		}
	}
	public class CommandMemoryAmbientVolume : CommandBgmSimpleVolume
	{
		public override Types Type => Types.MemoryAmbientVolume;

		public CommandMemoryAmbientVolume()
		{
		}

		public CommandMemoryAmbientVolume(SequenceData.Param data, int version)
			: base(data.DataFloat[0], data.DataFloat[1])
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (!player.CurrentBackground.HasAudioSource)
			{
				return true;
			}
			SoundManager.Bgm.SetSimpleVolume(player.CurrentBackground.Audio, Volume, FadeDuration);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMemoryAmbientVolume)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"  :  {Volume},  {FadeDuration}";
		}
	}
	public class CommandMemoryCharaOff : CommandMemoryCharaOn
	{
		public override Types Type => Types.MemoryCharaOff;

		public CommandMemoryCharaOff()
		{
		}

		public CommandMemoryCharaOff(SequenceData.Param data, int version, bool isFade)
			: base(data, version, isFade)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SetCharaInListActive(player, isActive: false);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMemoryCharaOff)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string arg = ((FadeDuration <= 0f) ? "()" : $"( {FadeDuration:0.0} )");
			return $" {arg}";
		}
	}
	public class CommandMemoryCharaOn : CommandCharaOn
	{
		private bool m_isActivate;

		public override Types Type => Types.MemoryCharaOn;

		public override PreloadTypes PreloadType => PreloadTypes.MemoryChara;

		public override int PreloadIndex => (int)CharaList[0];

		public CommandMemoryCharaOn()
		{
		}

		public CommandMemoryCharaOn(SequenceData.Param data, int version, bool isFade)
			: base(data, version, isFade)
		{
		}

		protected override void SetCharaInListActive(TimelinePlayer player, bool isActive)
		{
			m_isActivate = isActive;
			int count = CharaList.Count;
			for (int i = 0; i < count; i++)
			{
				SetCharaActive(player, CharaList[i], isActive);
			}
		}

		private void SetCharaActive(TimelinePlayer player, GameDefine.CharaID charaID, bool isActive)
		{
			AdvMemoryChara advMemoryChara = player.MemoryModeProcessor.FindChara(charaID);
			float targetAlpha = 0f;
			if (isActive)
			{
				targetAlpha = 1f;
				advMemoryChara.SetEnable(isActive);
				advMemoryChara.SetAlpha(0f);
			}
			advMemoryChara.StartFadeWithChangeActive(targetAlpha, isActive, FadeDuration);
		}

		private void OnFadeEnd(AdvMemoryChara chara)
		{
			chara.SetEnable(m_isActivate);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMemoryCharaOn)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string arg = ((FadeDuration <= 0f) ? "()" : $"( {FadeDuration:0.0} )");
			return $" {arg}";
		}
	}
	public class CommandMemoryCharaTransform : ICharaCommand
	{
		public CommandCharaTransform.RotationType RotationMode;

		public bool IsMove;

		public bool IsRotate;

		public bool IsFade = true;

		public float Radius = 7f;

		public float Angle;

		public Vector3 Offset = Vector3Extension.Zero;

		public Vector3 Rotation = Vector3Extension.Zero;

		private AdvMemoryChara m_chara;

		private Action m_onFadeEndAction;

		public override Types Type => Types.MemoryCharaTransform;

		public CommandMemoryCharaTransform()
		{
			Chara = GameDefine.CharaID.TOUGOKU_C;
		}

		public CommandMemoryCharaTransform(SequenceData.Param data, int version, bool hasPassedFirstFade)
		{
			int intIndex = 0;
			int index = 0;
			Chara = (GameDefine.CharaID)data.DataInt[intIndex++];
			IsFade = IntToBool(data.DataInt[intIndex++]);
			IsMove = IntToBool(data.DataInt[intIndex++]);
			IsRotate = IntToBool(data.DataInt[intIndex++]);
			LoadPosition(data, ref index);
			LoadRotation(data, ref intIndex, ref index);
			if (!hasPassedFirstFade)
			{
				IsFade = false;
			}
			m_onFadeEndAction = delegate
			{
				_ApplyTransform();
			};
		}

		private void LoadPosition(SequenceData.Param data, ref int index)
		{
			if (IsMove)
			{
				Angle = data.DataFloat[index++];
				Radius = data.DataFloat[index++];
				Offset = new Vector3(data.DataFloat[index++], data.DataFloat[index++], data.DataFloat[index++]);
			}
		}

		private void LoadRotation(SequenceData.Param data, ref int intIndex, ref int floatIndex)
		{
			if (IsRotate)
			{
				RotationMode = (CommandCharaTransform.RotationType)data.DataInt[intIndex++];
				Rotation = new Vector3(data.DataFloat[floatIndex++], data.DataFloat[floatIndex++], data.DataFloat[floatIndex++]);
			}
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			m_chara = player.MemoryModeProcessor.FindChara(Chara);
			if (m_chara == null)
			{
				SayOops("I couldn't find Character: " + Chara);
				return true;
			}
			if (!IsFade || !m_chara.IsActive)
			{
				ApplyTransform(m_chara, m_chara.Transform, MainPosition.MainTransform);
				return true;
			}
			m_chara.PlayPingPongFade(0.3f, m_onFadeEndAction);
			return true;
		}

		private void _ApplyTransform()
		{
			ApplyTransform(m_chara, m_chara.Transform, MainPosition.MainTransform);
		}

		public void ApplyTransform(AdvMemoryChara chara, Transform charaTransform, Transform player)
		{
			if (IsMove)
			{
				SetCharaPosition(chara, charaTransform, player);
			}
			if (IsRotate)
			{
				CommandCharaTransform.SetCharaRotation(RotationMode, charaTransform, player, ref Rotation);
			}
		}

		public void SetCharaPosition(AdvMemoryChara chara, Transform charaTransform, Transform player)
		{
			if (chara != null)
			{
				chara.SetMoveFlag();
			}
			charaTransform.localPosition = CommandCharaCircularPosition.CauclateCharaPosition(player, Angle, Radius);
			charaTransform.Translate(Offset, Space.Self);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMemoryCharaTransform)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return string.Format("{0}{1}", Chara.ToString(), IsFade ? "" : " ()");
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(BoolToInt(IsFade));
			data.DataInt.Add(BoolToInt(IsMove));
			data.DataInt.Add(BoolToInt(IsRotate));
			SavePosition(data);
			SaveRotation(data);
		}

		private void SavePosition(SequenceData.Param data)
		{
			if (IsMove)
			{
				data.DataFloat.Add(Angle);
				data.DataFloat.Add(Radius);
				data.DataFloat.Add(Offset.x);
				data.DataFloat.Add(Offset.y);
				data.DataFloat.Add(Offset.z);
			}
		}

		private void SaveRotation(SequenceData.Param data)
		{
			if (IsRotate)
			{
				data.DataInt.Add((int)RotationMode);
				data.DataFloat.Add(Rotation.x);
				data.DataFloat.Add(Rotation.y);
				data.DataFloat.Add(Rotation.z);
			}
		}
	}
	public class CommandMemoryEmotion : CommandEmotion
	{
		public override Types Type => Types.MemoryEmotion;

		public CommandMemoryEmotion()
		{
		}

		public CommandMemoryEmotion(GameDefine.CharaID chara, EmotionImage.Types emotion, Vector3 offset)
			: base(chara, emotion, offset)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.EmotionProcessor.GenerateMono(player.MemoryModeProcessor, Emotion, Chara, ref Offset);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMemoryEmotion)MemberwiseClone();
		}
	}
	public class CommandMemoryModeEnd : ISequenceCommand
	{
		public override Types Type => Types.MemoryEnd;

		public override bool PlayInHardSkip => true;

		public CommandMemoryModeEnd()
		{
		}

		public CommandMemoryModeEnd(SequenceData.Param data, int version)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MemoryModeProcessor.End();
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMemoryModeEnd)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandMemoryModeStart : ISequenceCommand
	{
		public AdvBackgroundMemory.SpotlightTypes SpotlightType;

		public override Types Type => Types.MemoryStart;

		public override bool PlayInHardSkip => true;

		public override PreloadTypes PreloadType => PreloadTypes.MemoryModeStart;

		public override int PreloadIndex => 0;

		public CommandMemoryModeStart()
		{
		}

		public CommandMemoryModeStart(SequenceData.Param data, int version)
		{
			if (data.DataInt.Count > 0)
			{
				SpotlightType = (AdvBackgroundMemory.SpotlightTypes)data.DataInt[0];
			}
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MemoryModeProcessor.Play(SpotlightType);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMemoryModeStart)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)SpotlightType);
		}
	}
	public class CommandMenuFixMode : ISequenceCommand
	{
		public MainMenuManager.MenuMode TargetMenuMode = MainMenuManager.MenuMode.SkipMode;

		public override Types Type => Types.MenuFixMode;

		public CommandMenuFixMode()
		{
		}

		public CommandMenuFixMode(SequenceData.Param data, int version)
			: base(data, version)
		{
			TargetMenuMode = (MainMenuManager.MenuMode)data.DataInt[0];
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SingletonMonoBehaviour<MainMenuManager>.Instance.FixedMode = TargetMenuMode;
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMenuFixMode)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "<b></b>: " + TargetMenuMode;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)TargetMenuMode);
		}
	}
	public class CommandMessageForceMode : ISequenceCommand
	{
		public MessagePlayer.ForceModes TargetMode;

		public override Types Type => Types.MessageForceMode;

		public CommandMessageForceMode()
		{
		}

		public CommandMessageForceMode(SequenceData.Param data)
		{
			TargetMode = (MessagePlayer.ForceModes)data.GetInt(0);
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MessageProcessor.ForceMode = TargetMode;
			if (TargetMode == MessagePlayer.ForceModes.ForceAuto && SingletonMonoBehaviour<MainMenuManager>.Instance.IsOpened)
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.CloseMenu();
			}
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMessageForceMode)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string text = "";
			switch (TargetMode)
			{
			case MessagePlayer.ForceModes.Freedom:
				text = "";
				break;
			case MessagePlayer.ForceModes.NoAuto:
				text = "";
				break;
			case MessagePlayer.ForceModes.NoSkip:
				text = "";
				break;
			case MessagePlayer.ForceModes.NoAutoSkip:
				text = "";
				break;
			case MessagePlayer.ForceModes.ForceAuto:
				text = "";
				break;
			}
			return " -> " + text;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)TargetMode);
		}
	}
	public class CommandNoAnimationLimit : ISequenceCommand
	{
		public override Types Type => Types.NoAnimationLimit;

		public CommandNoAnimationLimit()
		{
		}

		public CommandNoAnimationLimit(SequenceData.Param data, int version)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SingletonMonoBehaviour<CharactersManager>.Instance.IsIgnoreAnimationLimit = true;
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandNoAnimationLimit)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public static class CommandParameters
	{
		public enum Fade
		{
			START_R,
			START_G,
			START_B,
			START_A,
			END_R,
			END_G,
			END_B,
			END_A,
			DURATION
		}

		public enum CharaPosition
		{
			X,
			Y,
			Z
		}

		public enum ForcusOff
		{
			Window,
			Fade
		}

		public enum Transform
		{
			PositionX,
			PositionY,
			PositionZ,
			RotationX,
			RotationY,
			RotationZ
		}

		public enum Bgm
		{
			Volume,
			Fade
		}

		public enum Conditions
		{
			Enum = -1,
			False,
			True,
			Switch,
			Readed,
			LastSelection
		}

		public const int TEXT_CHARA = 0;

		public const int TEXT_TEXT_INDEX = 1;

		public const int TEXT_VOICE_INDEX = 2;

		public const int CHARA_CHARA = 0;

		public const int CHARA_EMOTION = 1;

		public const int SCENE_NEXT_SCENE = 0;

		public const int SEQUENCE_NEXT_ID = 0;

		public const int CHARA_POSITION_IS_RELETIVE = 1;

		public const int CHARA_POSITION_IS_SKIP_FADE = 2;

		public const int WAIT_TIME = 0;

		public const int FORCUS_UP_ID = 0;

		public const int FORCUS_UP_WINDOW = 1;

		public const int FORCUS_UP_FADE = 2;

		public const int FORCUS_UP_CHARA = 3;

		public const int PROPS_TYPE = 0;

		public const int PROPS_ID = 1;

		public const int PROPS_CHARA = 2;

		public const int PROPS_NODE = 3;

		public const int ID = 0;

		public const int LOOP = 1;

		public const int BGM_FADE_DURATION = 0;

		public const int SE_SOURCE = 2;

		public const int SE_PARAM_ONE = 3;

		public const int SE_PARAM_TWO = 4;

		public const int SE_PARAM_THREE = 5;

		public const int LOOKAT_SKIP_ANIM = 2;

		public const int LOOKAT_SOURCE = 3;

		public const int LOOKAT_PROPTYPE = 4;

		public const int LOOKAT_PROPID = 5;

		public const int LOOKAT_PROPNODEID = 6;
	}
	public class CommandPlayAreaBoundary : ISequenceCommand
	{
		public bool IsOverride = true;

		public float OverrideRange = 2f;

		public override Types Type => Types.PlayAreaBoundary;

		public CommandPlayAreaBoundary()
		{
		}

		public CommandPlayAreaBoundary(SequenceData.Param data, int version)
			: base(data, version)
		{
			IsOverride = IntToBool(data.GetInt(0));
			OverrideRange = data.GetFloat(0);
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (IsOverride)
			{
				SingletonMonoBehaviour<PlayAreaManager>.Instance.BoundaryRange = OverrideRange;
			}
			else
			{
				SingletonMonoBehaviour<PlayAreaManager>.Instance.ResetBoundaryRange();
			}
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandPlayAreaBoundary)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			if (IsOverride)
			{
				return ":  " + OverrideRange.ToString("F2") + " m";
			}
			return ": ";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(BoolToInt(IsOverride));
			data.DataFloat.Add(OverrideRange);
		}
	}
	public class CommandPlayerArmMotion : ISequenceCommand
	{
		public int Motion;

		public bool IsFade = true;

		public bool IsPlayAnimation = true;

		public override Types Type => Types.PlayerArmMotion;

		public CommandPlayerArmMotion()
		{
		}

		public CommandPlayerArmMotion(int motion, bool isFade, bool PlayAnimation)
		{
			Motion = motion;
			IsFade = isFade;
			IsPlayAnimation = PlayAnimation;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			MainPosition.Avater.AvaterResources.HandObject.PlayAnimation(Motion, IsFade, IsPlayAnimation);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandPlayerArmMotion)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $" {Motion} ";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(Motion);
			data.DataInt.Add(BoolToInt(IsFade));
			data.DataInt.Add(BoolToInt(IsPlayAnimation));
		}
	}
	public class CommandPlayerAvaterTrack : ISequenceCommand
	{
		public PlayerAvater.AvaterParts TargetPart;

		public PlayerAvater.AvaterTrackTypes TrackType;

		public float FadeDuration = 0.3f;

		public override Types Type => Types.PlayerAvaterTrack;

		public CommandPlayerAvaterTrack()
		{
		}

		public CommandPlayerAvaterTrack(SequenceData.Param data, int saveVersion)
		{
			TargetPart = (PlayerAvater.AvaterParts)data.GetInt(0);
			TrackType = (PlayerAvater.AvaterTrackTypes)data.GetInt(1);
			FadeDuration = data.GetFloat(0);
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			MainPosition.Avater.SetRotationEnableWithFade(TargetPart, TrackType, FadeDuration);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandPlayerAvaterTrack)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"{TargetPart} = {TrackType}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)TargetPart);
			data.DataInt.Add((int)TrackType);
			data.DataFloat.Add(FadeDuration);
		}
	}
	public class CommandPlayerAvaterVisible : ISequenceCommand
	{
		public bool IsVisible;

		public override Types Type => Types.AvaterVisible;

		public CommandPlayerAvaterVisible()
		{
		}

		public CommandPlayerAvaterVisible(SequenceData.Param data, int version)
		{
			IsVisible = IntToBool(data.DataInt[0]);
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			MainPosition.Avater.Object.SetActive(IsVisible);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandPlayerAvaterVisible)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			if (!IsVisible)
			{
				return "<b></b>";
			}
			return "<b></b>";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(BoolToInt(IsVisible));
		}
	}
	public class CommandPlayerPosition : ISequenceCommand
	{
		public Vector3 Position = Vector3.zero;

		public override Types Type => Types.PlayerPosition;

		public CommandPlayerPosition()
		{
		}

		public CommandPlayerPosition(Vector3 pos)
		{
			Position = pos;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			Vector3 position = Position;
			position.y += 5.17f;
			MainPosition.MainTransform.localPosition = position;
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandPlayerPosition)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $": {Position}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataFloat.Add(Position.x);
			data.DataFloat.Add(Position.y);
			data.DataFloat.Add(Position.z);
		}
	}
	public class CommandPlayerRotation : ISequenceCommand
	{
		public Vector3 Rotation;

		public override Types Type => Types.PlayerRotation;

		public CommandPlayerRotation()
		{
		}

		public CommandPlayerRotation(Vector3 rot)
		{
			Rotation = rot;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			MainPosition.MainTransform.eulerAngles = Rotation;
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandPlayerRotation)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $": {Rotation}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataFloat.Add(Rotation.x);
			data.DataFloat.Add(Rotation.y);
			data.DataFloat.Add(Rotation.z);
		}
	}
	public class CommandPlayerSetChara : ICharaCommand
	{
		public bool ShowHands;

		public int HandModelIndex;

		public bool ShowTrackingHands;

		public override Types Type => Types.SetPlayerChara;

		public override PreloadTypes PreloadType => PreloadTypes.Avater;

		public override int PreloadIndex => (int)Chara;

		public CommandPlayerSetChara()
			: base(GameDefine.CharaID.SAKURAI)
		{
			ShowHands = false;
		}

		public CommandPlayerSetChara(GameDefine.CharaID chara, bool showHands = false, int HandModelIndex = 0, bool showTrackingHands = true)
			: base(chara)
		{
			ShowHands = showHands;
			this.HandModelIndex = HandModelIndex;
			if (ShowHands)
			{
				ShowTrackingHands = false;
			}
			else
			{
				ShowTrackingHands = showTrackingHands;
			}
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (SingletonMonoBehaviour<LocalData>.Instance.CurrentCharaID == Chara)
			{
				if (MainPosition.Avater.AvaterResources.HasTrackedHands)
				{
					if (ShowTrackingHands)
					{
						MainPosition.Avater.AvaterResources.TrackedHandLeftObject.StartFadeIn();
						MainPosition.Avater.AvaterResources.TrackedHandRightObject.StartFadeIn();
					}
					else
					{
						MainPosition.Avater.AvaterResources.TrackedHandLeftObject.StartFadeOut();
						MainPosition.Avater.AvaterResources.TrackedHandRightObject.StartFadeOut();
					}
					MainPosition.Avater.AvaterResources.TrackedHandLeftObject.IsTrackedHandShowing = ShowTrackingHands;
					MainPosition.Avater.AvaterResources.TrackedHandRightObject.IsTrackedHandShowing = ShowTrackingHands;
				}
				if (MainPosition.Avater.AvaterResources.HasHand)
				{
					if (ShowHands)
					{
						MainPosition.Avater.AvaterResources.HandLoader.ChangeCurrentAvaterType(HandModelIndex);
					}
					else
					{
						MainPosition.Avater.AvaterResources.HandObject.StartFadeOut();
					}
				}
				return true;
			}
			MainPosition.Avater.AvaterResources.OnAfterAvaterLoaded.First().Subscribe(delegate
			{
				OnEndAvaterLoad(player);
			});
			MainPosition.Avater.AvaterResources.HandLoader.IsFadeInOnNew = ShowHands;
			MainPosition.Avater.AvaterResources.HandLoader.InitialFadeInIndex = HandModelIndex;
			MainPosition.Avater.AvaterResources.TrackedHandLeftLoader.IsFadeInOnNew = ShowTrackingHands;
			MainPosition.Avater.AvaterResources.TrackedHandRightLoader.IsFadeInOnNew = ShowTrackingHands;
			SingletonMonoBehaviour<LocalData>.Instance.ChangeCharacter(Chara);
			return false;
		}

		public void OnEndAvaterLoad(TimelinePlayer player)
		{
			player.ReleaseCommandWait();
		}

		public override ISequenceCommand Clone()
		{
			return (CommandPlayerSetChara)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $" {Chara} ";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(BoolToInt(ShowHands));
			data.DataInt.Add(HandModelIndex);
			data.DataInt.Add(BoolToInt(ShowTrackingHands));
		}
	}
	public class CommandProhibitHeightChange : BaseCommandProhibit
	{
		public override Types Type => Types.ProhibitHeightChange;

		public CommandProhibitHeightChange()
		{
		}

		public CommandProhibitHeightChange(SequenceData.Param data)
			: base(data)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MessageProcessor.ProhibitHeightChange = ToggleFlag;
			SingletonMonoBehaviour<MainPosition>.Instance.ProhibitHeightChange = ToggleFlag;
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandProhibitHeightChange)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return ": " + GetFlagText();
		}
	}
	public class CommandProhibitMenuSelection : BaseCommandProhibit
	{
		public MainMenuManager.MenuMode TargetMenuMode = MainMenuManager.MenuMode.SkipMode;

		public override Types Type => Types.ProhibitMenuSelection;

		public CommandProhibitMenuSelection()
		{
		}

		public CommandProhibitMenuSelection(SequenceData.Param data)
			: base(data)
		{
			TargetMenuMode = (MainMenuManager.MenuMode)data.DataInt[1];
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SingletonMonoBehaviour<MainMenuManager>.Instance.SetProhibitions(TargetMenuMode, ToggleFlag);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandProhibitMenuSelection)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $" {TargetMenuMode} : " + GetFlagText();
		}

		public override void Save(SequenceData.Param data)
		{
			base.Save(data);
			data.DataInt.Add((int)TargetMenuMode);
		}
	}
	public class CommandProhibitMessageSound : BaseCommandProhibit
	{
		public override Types Type => Types.ProhibitMessageSound;

		public CommandProhibitMessageSound()
		{
		}

		public CommandProhibitMessageSound(SequenceData.Param data)
			: base(data)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MessageProcessor.IsPlayPageSound = !ToggleFlag;
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandProhibitMessageSound)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return ": " + GetFlagText();
		}
	}
	public class CommandProhibitOpenMenu : BaseCommandProhibit
	{
		public override Types Type => Types.ProhibitOpenMenu;

		public CommandProhibitOpenMenu()
		{
		}

		public CommandProhibitOpenMenu(SequenceData.Param data)
			: base(data)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SingletonMonoBehaviour<MainMenuManager>.Instance.IsProhibitByCommand = ToggleFlag;
			if (SingletonMonoBehaviour<MainMenuManager>.Instance.IsOpened)
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.CloseMenu();
			}
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandProhibitOpenMenu)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return ": " + GetFlagText();
		}
	}
	public class CommandProps : ISequenceCommand
	{
		public override Types Type => Types.Props;

		public override bool IsDeprecated => true;

		public override bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandProps)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "Deprecated";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandPropsChara : ICharaCommand
	{
		public override Types Type => Types.PropsChara;

		public override bool IsDeprecated => true;

		public override bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandPropsChara)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "Deprecated";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandPropsCharaOff : CommandPropsOff
	{
		public override Types Type => Types.PropsCharaOff;

		public override bool IsDeprecated => true;

		public override bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandPropsOff : ISequenceCommand
	{
		public override Types Type => Types.PropsOff;

		public override bool IsDeprecated => true;

		public override bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandPropsOff)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "Deprecated";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandSceneProp : BaseCommandSceneProp
	{
		public bool Visible = true;

		public bool IsOverrideTransform;

		public bool IsAttachTo;

		public PropDefines.RelativeModes RelativeMode;

		public PropDefines.FadeModes FadeMode;

		public int OptionIntOne;

		public int OptionIntTwo;

		public int OptionIntThree;

		public float FadeDuration = 0.3f;

		public float Delay;

		public Vector3 Position = Vector3.zero;

		public Vector3 Rotation = Vector3.zero;

		public Vector3 Scale = Vector3.one;

		private BaseProp m_prop;

		private TimelinePlayer m_player;

		private AdvChara m_chara;

		private Action m_onBetweenDitherAction;

		private TimeSpan m_delaySpan;

		public override Types Type => Types.SceneProp;

		public override PreloadTypes PreloadType
		{
			get
			{
				if (PropType != 0)
				{
					return PreloadTypes.PropDynamic;
				}
				return PreloadTypes.PropStatic;
			}
		}

		public override int PreloadIndex => PropIndex;

		private bool IsWillAttach
		{
			get
			{
				if (base.IsDynamicProp && IsAttachTo)
				{
					return IsOverrideTransform;
				}
				return false;
			}
		}

		public GameDefine.CharaID RelationCharaID
		{
			get
			{
				return (GameDefine.CharaID)OptionIntOne;
			}
			set
			{
				OptionIntOne = (int)value;
			}
		}

		public AdvCharaModel.Node RelationCharaNode
		{
			get
			{
				return (AdvCharaModel.Node)OptionIntTwo;
			}
			set
			{
				OptionIntTwo = (int)value;
			}
		}

		public AvaterHandObject.Node RelationAvaterHandNode
		{
			get
			{
				return (AvaterHandObject.Node)OptionIntTwo;
			}
			set
			{
				OptionIntTwo = (int)value;
			}
		}

		public PropDefines.PropType RelationPropType
		{
			get
			{
				return (PropDefines.PropType)OptionIntOne;
			}
			set
			{
				OptionIntOne = (int)value;
			}
		}

		public int RelationPropIndex
		{
			get
			{
				return OptionIntTwo;
			}
			set
			{
				OptionIntTwo = value;
			}
		}

		public int RelationPropAnchorIndex
		{
			get
			{
				return OptionIntThree;
			}
			set
			{
				OptionIntThree = value;
			}
		}

		public VRDeviceDefine.HandType RelationRealHand
		{
			get
			{
				return (VRDeviceDefine.HandType)OptionIntOne;
			}
			set
			{
				OptionIntOne = (int)value;
			}
		}

		public CommandSceneProp()
		{
			PropType = PropDefines.PropType.Static;
		}

		public CommandSceneProp(SequenceData.Param data)
		{
			LoadFromData(data);
			int flagsFromInt = data.DataInt[2];
			SetFlagsFromInt(flagsFromInt);
			RelativeMode = (PropDefines.RelativeModes)data.DataInt[3];
			FadeMode = (PropDefines.FadeModes)data.DataInt[4];
			OptionIntOne = data.DataInt[5];
			OptionIntTwo = data.DataInt[6];
			OptionIntThree = data.DataInt[7];
			FadeDuration = data.DataFloat[0];
			Position = new Vector3(data.DataFloat[1], data.DataFloat[2], data.DataFloat[3]);
			Rotation = new Vector3(data.DataFloat[4], data.DataFloat[5], data.DataFloat[6]);
			Scale = new Vector3(data.DataFloat[7], data.DataFloat[8], data.DataFloat[9]);
			if (data.DataFloat.Count >= 11)
			{
				Delay = data.DataFloat[10];
				if (Delay > 0f)
				{
					m_delaySpan = TimeSpan.FromSeconds(Delay);
				}
			}
			if (SingletonMonoBehaviour<CharactersManager>.HasInstance)
			{
				m_chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(RelationCharaID);
			}
			m_onBetweenDitherAction = delegate
			{
				OnBetweenDither();
			};
		}

		private void OnBetweenDither()
		{
			if (!(m_prop == null))
			{
				m_prop.SetVisible(Visible);
				MoveProp(m_player, m_prop);
				m_prop = null;
				m_player = null;
			}
		}

		protected override bool PlayCommandWithProp(TimelinePlayer player, BaseProp prop)
		{
			m_player = player;
			m_prop = prop;
			if (Delay > 0f)
			{
				OnDelay(prop);
				Observable.Timer(m_delaySpan).Subscribe(delegate
				{
					RunCommand();
				}).AddTo(player.gameObject);
				return true;
			}
			RunCommand();
			return true;
		}

		private void OnDelay(BaseProp prop)
		{
			if (FadeMode == PropDefines.FadeModes.Dither && (RelativeMode == PropDefines.RelativeModes.Chara || RelativeMode == PropDefines.RelativeModes.CharaNode))
			{
				prop.SetAlpha(0f);
			}
		}

		private void RunCommand()
		{
			if (PropType == PropDefines.PropType.Dynamic)
			{
				if (FadeMode == PropDefines.FadeModes.Dither)
				{
					m_prop.ActionBetweenDither(FadeDuration, m_onBetweenDitherAction, null);
				}
				else if (FadeMode == PropDefines.FadeModes.Smooth)
				{
					m_prop.SetVisible(Visible);
					m_prop.ReadyToSmooth(FadeDuration);
					MoveProp(m_player, m_prop);
				}
				else
				{
					m_prop.SetVisible(Visible);
					MoveProp(m_player, m_prop);
				}
			}
			else
			{
				m_prop.SetVisible(Visible);
			}
		}

		private void MoveProp(TimelinePlayer player, BaseProp prop)
		{
			if (!IsOverrideTransform)
			{
				prop.ResetPropTransform();
				return;
			}
			if (RelativeMode == PropDefines.RelativeModes.Self)
			{
				prop.MovePropAdditive(Position, Quaternion.Euler(Rotation), Scale);
				return;
			}
			Transform anchorTransform = prop.AnchorTransform;
			Transform transform = null;
			switch (RelativeMode)
			{
			case PropDefines.RelativeModes.WorldAdditive:
				Position += anchorTransform.position;
				break;
			case PropDefines.RelativeModes.Player:
				transform = MainPosition.AttachTransform;
				break;
			case PropDefines.RelativeModes.PlayerAvaterBody:
				SayOops(RelativeMode.ToString() + "");
				break;
			case PropDefines.RelativeModes.PlayerAvaterHand:
				transform = MainPosition.Avater.AvaterResources.HandObject.GetNodeTransform(RelationAvaterHandNode);
				break;
			case PropDefines.RelativeModes.Chara:
			{
				AdvChara chara2 = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(RelationCharaID);
				if (chara2 == null)
				{
					throw new CommandFailedException(this, $" {RelationCharaID} ");
				}
				transform = chara2.Transform;
				prop.SetAttachToChara(m_chara, RelationCharaNode);
				break;
			}
			case PropDefines.RelativeModes.CharaNode:
			{
				AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(RelationCharaID);
				if (chara == null)
				{
					throw new CommandFailedException(this, $" {RelationCharaID} ");
				}
				Transform node = chara.GetNode(RelationCharaNode);
				if (node == null)
				{
					throw new CommandFailedException(this, $" {RelationCharaID}  {RelationCharaNode} ");
				}
				transform = node;
				prop.SetAttachToChara(m_chara, RelationCharaNode);
				break;
			}
			case PropDefines.RelativeModes.OtherProp:
			{
				BaseProp propObject = GetPropObject(player, RelationPropType, RelationPropIndex);
				if (propObject == null)
				{
					throw new CommandFailedException(this, $" {RelationPropType}.{RelationPropIndex} ");
				}
				transform = propObject.AnchorTransform;
				break;
			}
			case PropDefines.RelativeModes.OtherPropAnchor:
			{
				BaseProp propObject2 = GetPropObject(player, RelationPropType, RelationPropIndex);
				if (propObject2 == null)
				{
					throw new CommandFailedException(this, $" {RelationPropType}.{RelationPropIndex} ");
				}
				transform = propObject2.GetAnchor(RelationPropAnchorIndex);
				break;
			}
			case PropDefines.RelativeModes.RealHead:
				transform = SingletonMonoBehaviour<PlayAreaManager>.Instance.HeadTransform;
				break;
			case PropDefines.RelativeModes.RealHand:
				if (SingletonMonoBehaviour<PlayAreaManager>.Instance.InputVR.UseTrackedHands)
				{
					AvaterTrackedHandObject avaterTrackedHandObject = ((RelationRealHand == VRDeviceDefine.HandType.Left) ? MainPosition.Avater.AvaterResources.TrackedHandLeftObject : ((RelationRealHand != VRDeviceDefine.HandType.Right) ? ((SingletonMonoBehaviour<GameInputManager>.Instance.PrefferdHand == VRDeviceDefine.HandType.Left) ? MainPosition.Avater.AvaterResources.TrackedHandLeftObject : MainPosition.Avater.AvaterResources.TrackedHandRightObject) : MainPosition.Avater.AvaterResources.TrackedHandRightObject));
					transform = avaterTrackedHandObject.GetNodeTransform(AvaterTrackedHandObject.Node.TrackedGrabPivot);
				}
				else
				{
					transform = ((RelationRealHand != 0) ? ((RelationRealHand != VRDeviceDefine.HandType.Right) ? ((SingletonMonoBehaviour<GameInputManager>.Instance.PrefferdHand == VRDeviceDefine.HandType.Left) ? SingletonMonoBehaviour<PlayAreaManager>.Instance.LeftHandObject.transform : SingletonMonoBehaviour<PlayAreaManager>.Instance.RightHandObject.transform) : SingletonMonoBehaviour<PlayAreaManager>.Instance.RightHandObject.transform) : SingletonMonoBehaviour<PlayAreaManager>.Instance.LeftHandObject.transform);
				}
				break;
			case PropDefines.RelativeModes.RealFoot:
				throw new CommandFailedException(this, "");
			default:
				SayOops(RelativeMode.ToString() + "");
				break;
			case PropDefines.RelativeModes.World:
				break;
			}
			Quaternion rotation = Quaternion.Euler(Rotation);
			if (transform == null)
			{
				prop.AttachToTransform(null, isStay: true);
				prop.MoveProp(Position, rotation, Scale);
			}
			else if (IsAttachTo)
			{
				prop.AttachToTransform(transform, isStay: true);
				prop.MovePropOnLocal(Position, rotation, Scale);
			}
			else
			{
				prop.AttachToTransform(null, isStay: true);
				prop.MovePropRelation(transform, Position, rotation, Scale);
			}
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSceneProp)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string text = (IsWillAttach ? "" : "") + (Visible ? "" : "");
			string text2 = "";
			if (base.IsDynamicProp)
			{
				text2 = " - ";
				text2 = ((!IsOverrideTransform) ? (text2 + "Prefab") : (RelativeMode switch
				{
					PropDefines.RelativeModes.World => text2 + "" + Position.ToString(), 
					PropDefines.RelativeModes.WorldAdditive => text2 + "[]" + Position.ToString(), 
					PropDefines.RelativeModes.Self => text2 + "" + Position.ToString(), 
					PropDefines.RelativeModes.Player => text2 + "" + Position.ToString(), 
					PropDefines.RelativeModes.PlayerAvaterBody => text2 + "TODO" + Position.ToString(), 
					PropDefines.RelativeModes.PlayerAvaterHand => text2 + "TODO" + Position.ToString(), 
					PropDefines.RelativeModes.Chara => text2 + $"{RelationCharaID}" + Position.ToString(), 
					PropDefines.RelativeModes.CharaNode => text2 + $"{RelationCharaID}{RelationCharaNode}" + Position.ToString(), 
					PropDefines.RelativeModes.OtherProp => text2 + $"{RelationPropType}.{RelationPropIndex}" + Position.ToString(), 
					PropDefines.RelativeModes.OtherPropAnchor => text2 + $"{RelationPropType}.{RelationPropIndex}{RelationPropAnchorIndex}" + Position.ToString(), 
					PropDefines.RelativeModes.RealHead => text2 + "" + Position.ToString(), 
					PropDefines.RelativeModes.RealHand => (RelationRealHand != 0) ? ((RelationRealHand != VRDeviceDefine.HandType.Right) ? (text2 + "" + Position.ToString()) : (text2 + "" + Position.ToString())) : (text2 + "" + Position.ToString()), 
					PropDefines.RelativeModes.RealFoot => text2 + "" + Position.ToString(), 
					_ => text2 + "" + Position.ToString(), 
				}));
			}
			return $" '{PropType}.{PropIndex}'  {text}{text2}";
		}

		public override void Save(SequenceData.Param data)
		{
			base.Save(data);
			int flagInt = GetFlagInt();
			data.DataInt.Add(flagInt);
			data.DataInt.Add((int)RelativeMode);
			data.DataInt.Add((int)FadeMode);
			data.DataInt.Add(OptionIntOne);
			data.DataInt.Add(OptionIntTwo);
			data.DataInt.Add(OptionIntThree);
			data.DataFloat.Add(FadeDuration);
			data.DataFloat.Add(Position.x);
			data.DataFloat.Add(Position.y);
			data.DataFloat.Add(Position.z);
			data.DataFloat.Add(Rotation.x);
			data.DataFloat.Add(Rotation.y);
			data.DataFloat.Add(Rotation.z);
			data.DataFloat.Add(Scale.x);
			data.DataFloat.Add(Scale.y);
			data.DataFloat.Add(Scale.z);
			data.DataFloat.Add(Delay);
		}

		private int GetFlagInt()
		{
			return (Visible ? 1 : 0) + (IsOverrideTransform ? 2 : 0) + (IsAttachTo ? 4 : 0);
		}

		private void SetFlagsFromInt(int flags)
		{
			Visible = (flags & 1) != 0;
			IsOverrideTransform = (flags & 2) != 0;
			IsAttachTo = (flags & 4) != 0;
		}
	}
	public class CommandScenePropAction : BaseCommandSceneProp
	{
		public int ActionIndex;

		public override Types Type => Types.ScenePropAction;

		public CommandScenePropAction()
		{
			PropType = PropDefines.PropType.Dynamic;
		}

		public CommandScenePropAction(SequenceData.Param data)
		{
			LoadFromData(data);
			PropType = PropDefines.PropType.Dynamic;
			ActionIndex = data.DataInt[2];
		}

		protected override bool PlayCommandWithProp(TimelinePlayer player, BaseProp prop)
		{
			prop.ActionPropAnimation(ActionIndex);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandScenePropAction)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $" '{PropType}.{PropIndex}'  'Index.{ActionIndex}' ";
		}

		public override void Save(SequenceData.Param data)
		{
			base.Save(data);
			data.DataInt.Add(ActionIndex);
		}
	}
	public class CommandScenePropOutline : BaseCommandSceneProp
	{
		public PropDefines.FadeModes FadeMode;

		public float FadeDuration = 0.3f;

		public float OutlineSize = 0.1f;

		public Color OutlineColor = new Color(0.75f, 0.75f, 0.75f);

		public bool FlagChangeSize = true;

		public bool FlagChangeColor = true;

		public override Types Type => Types.ScenePropOutline;

		public CommandScenePropOutline()
		{
			PropType = PropDefines.PropType.Dynamic;
		}

		public CommandScenePropOutline(SequenceData.Param data, int version)
		{
			LoadFromData(data);
			int @int = data.GetInt(2);
			SetFlagsFromInt(@int);
			FadeMode = (PropDefines.FadeModes)data.GetInt(3);
			FadeDuration = data.GetFloat(0);
			OutlineSize = data.GetFloat(1);
			OutlineColor.r = data.GetFloat(2);
			OutlineColor.g = data.GetFloat(3);
			OutlineColor.b = data.GetFloat(4);
			OutlineColor.a = data.GetFloat(5);
		}

		protected override bool PlayCommandWithProp(TimelinePlayer player, BaseProp prop)
		{
			switch (FadeMode)
			{
			case PropDefines.FadeModes.Smooth:
				if (FlagChangeSize)
				{
					prop.StartSmoothOutlineSizeChange(FadeDuration, OutlineSize);
				}
				if (FlagChangeColor)
				{
					prop.StartSmoothOutlineColorChange(FadeDuration, OutlineColor);
				}
				break;
			case PropDefines.FadeModes.Dither:
				prop.ActionBetweenDither(FadeDuration, delegate
				{
					if (FlagChangeSize)
					{
						prop.SetOutlineSize(OutlineSize);
					}
					if (FlagChangeColor)
					{
						prop.SetOutlineColor(OutlineColor);
					}
				}, null);
				break;
			default:
				if (FlagChangeSize)
				{
					prop.SetOutlineSize(OutlineSize);
				}
				if (FlagChangeColor)
				{
					prop.SetOutlineColor(OutlineColor);
				}
				break;
			}
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandScenePropOutline)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string text = "<b></b>:";
			text += $" [<b>{PropType}.{PropIndex}</b>]";
			switch (FadeMode)
			{
			case PropDefines.FadeModes.None:
				text += " []";
				break;
			case PropDefines.FadeModes.Smooth:
				text += $" [ {FadeDuration:F1} s]";
				break;
			case PropDefines.FadeModes.Dither:
				text += $" [ {FadeDuration:F1} s]";
				break;
			}
			text = ((!FlagChangeSize) ? (text + " []") : (text + $" [{OutlineSize:F2}]"));
			if (FlagChangeColor)
			{
				return text + $" [<color=#{ColorUtility.ToHtmlStringRGB(OutlineColor)}></color>]";
			}
			return text + " []";
		}

		public override void Save(SequenceData.Param data)
		{
			base.Save(data);
			int flagInt = GetFlagInt();
			data.DataInt.Add(flagInt);
			data.DataInt.Add((int)FadeMode);
			data.DataFloat.Add(FadeDuration);
			data.DataFloat.Add(OutlineSize);
			data.DataFloat.Add(OutlineColor.r);
			data.DataFloat.Add(OutlineColor.g);
			data.DataFloat.Add(OutlineColor.b);
			data.DataFloat.Add(OutlineColor.a);
		}

		private int GetFlagInt()
		{
			return (FlagChangeSize ? 1 : 0) + (FlagChangeColor ? 2 : 0);
		}

		private void SetFlagsFromInt(int flags)
		{
			FlagChangeSize = (flags & 1) != 0;
			FlagChangeColor = (flags & 2) != 0;
		}
	}
	public class CommandSceneToChapterEnd : BaseCommandSceneTo
	{
		public bool ForceBackToTitle;

		public bool SkipSubtitle;

		public bool SkipConfirm;

		private bool m_hasProcessed;

		public override Types Type => Types.SceneToChapterEnd;

		protected override SceneDefine SceneTransitionTo => SceneDefine.EndOfChapter;

		public CommandSceneToChapterEnd()
		{
		}

		public CommandSceneToChapterEnd(SequenceData.Param data, int version)
			: base(data, version)
		{
			ForceBackToTitle = IntToBool(data.GetInt(2));
			SkipSubtitle = IntToBool(data.GetInt(3));
			SkipConfirm = IntToBool(data.GetInt(4));
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SingletonMonoBehaviour<MainMenuManager>.Instance.IsProhibitByCommand = true;
			if (SingletonMonoBehaviour<MainMenuManager>.Instance.IsOpened)
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.CloseMenu();
			}
			return base.PlayCommand(player);
		}

		public override void OnEnd(TimelinePlayer player)
		{
			if (!m_hasProcessed)
			{
				m_hasProcessed = true;
				if (ForceBackToTitle && !SingletonMonoBehaviour<MasterManager>.Instance.IsSuperAutoMode)
				{
					player.QuitToTitle();
				}
				else
				{
					base.OnEnd(player);
				}
			}
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSceneToChapterEnd)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string text = " -> " + GetNextScquenceString();
			if (ForceBackToTitle)
			{
				text += " ()";
			}
			return text;
		}

		public override void Save(SequenceData.Param data)
		{
			base.Save(data);
			data.DataInt.Add(BoolToInt(ForceBackToTitle));
			data.DataInt.Add(BoolToInt(SkipSubtitle));
			data.DataInt.Add(BoolToInt(SkipConfirm));
		}
	}
	public class CommandSceneToChapterStart : BaseCommandSceneTo
	{
		public override Types Type => Types.SceneToChapterStart;

		protected override SceneDefine SceneTransitionTo => SceneDefine.StartOfChapter;

		public CommandSceneToChapterStart()
		{
		}

		public CommandSceneToChapterStart(SequenceData.Param data, int version)
			: base(data, version)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			return base.PlayCommand(player);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSceneToChapterStart)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return " -> " + GetNextScquenceString();
		}

		public override void Save(SequenceData.Param data)
		{
			base.Save(data);
		}
	}
	public class CommandSceneToOpening : BaseCommandSceneTo
	{
		public int RouteCount = 1;

		public override Types Type => Types.SceneToOpening;

		protected override SceneDefine SceneTransitionTo => GetSceneTo();

		public CommandSceneToOpening()
		{
		}

		public CommandSceneToOpening(SequenceData.Param data, int version)
			: base(data, version)
		{
			RouteCount = data.GetInt(2);
		}

		private SceneDefine GetSceneTo()
		{
			return RouteCount switch
			{
				1 => SceneDefine.Opening, 
				2 => SceneDefine.OpeningSecond, 
				_ => SceneDefine.Opening, 
			};
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSceneToOpening)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $" No.{RouteCount}  -> " + GetNextScquenceString();
		}

		public override void Save(SequenceData.Param data)
		{
			base.Save(data);
			data.DataInt.Add(RouteCount);
		}
	}
	public class CommandSceneToSpecial : BaseCommandSceneTo
	{
		public SceneDefine NextScene = SceneDefine.Blank;

		public override Types Type => Types.SceneToSpecial;

		protected override SceneDefine SceneTransitionTo => NextScene;

		public CommandSceneToSpecial()
		{
		}

		public CommandSceneToSpecial(SequenceData.Param data, int version)
			: base(data, version)
		{
			NextScene = (SceneDefine)data.GetInt(2);
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			return base.PlayCommand(player);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSceneToSpecial)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $" {SceneTransitionTo.ToString()}  -> {GetNextScquenceString()}";
		}

		public override void Save(SequenceData.Param data)
		{
			base.Save(data);
			data.DataInt.Add((int)NextScene);
		}
	}
	public class CommandSceneUnload : ISequenceCommand
	{
		public override Types Type => Types.SceneUnload;

		public override PreloadTypes PreloadType => PreloadTypes.UnityScene;

		public override int PreloadIndex => 34;

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.ChangeScene(SceneDefine.Blank);
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSceneUnload)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "Unity";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandSe2D : ISequenceCommand, ISoundCommand
	{
		public const string FILENAME = "Audio/SE/{0:D4}";

		public float Volume = 1f;

		public bool IsRepeat;

		public override Types Type => Types.PlaySE2D;

		public override PreloadTypes PreloadType => PreloadTypes.SoundEffect;

		public override int PreloadIndex => ID;

		public int ID { get; set; }

		public int SoundID => ID;

		public AudioClip Clip { get; set; }

		public CommandSe2D()
		{
		}

		public CommandSe2D(int id, float volume, bool isRepeat)
		{
			ID = id;
			Volume = volume;
			IsRepeat = isRepeat;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (IsSakuraiFootStep(ID))
			{
				Volume = 0.35f;
			}
			SoundManager.SE.PlayClip(Clip, Volume, null, IsRepeat);
			return true;
		}

		private bool IsSakuraiFootStep(int id)
		{
			if (id != 6 && id != 9 && id != 10 && id != 41 && id != 46 && id != 55)
			{
				return id == 73;
			}
			return true;
		}

		public virtual string GetFilePath()
		{
			return $"Audio/SE/{ID:D4}";
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSe2D)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return string.Format("2D: SoundID:{0}, :{1:p1} {2}", ID, Volume, IsRepeat ? "(Loop)" : "");
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(ID);
			data.DataInt.Add(BoolToInt(IsRepeat));
			data.DataFloat.Add(Volume);
		}
	}
	public class CommandSe2DOff : ISequenceCommand
	{
		public int ID;

		public override Types Type => Types.StopSE2D;

		public CommandSe2DOff()
		{
		}

		public CommandSe2DOff(int id)
		{
			ID = id;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SoundManager.SE.Stop();
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSe2DOff)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"2DID {ID} ";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(ID);
		}
	}
	public class CommandSe3D : CommandSe2D
	{
		public enum SourceType
		{
			Point,
			Chara,
			CharaNode,
			Prop,
			PropNode
		}

		public SourceType Source;

		public Vector3 Position;

		public int FirstIndex;

		public int SecondIndex;

		public int ThirdIndex;

		public override Types Type => Types.PlaySE3D;

		public override PreloadTypes PreloadType => PreloadTypes.SoundEffect;

		public override int PreloadIndex => base.ID;

		public GameDefine.CharaID TargetChara => (GameDefine.CharaID)FirstIndex;

		public AdvCharaModel.Node TargetCharaNode => (AdvCharaModel.Node)SecondIndex;

		public PropDefines.PropType TargetPropType
		{
			get
			{
				return (PropDefines.PropType)FirstIndex;
			}
			set
			{
				FirstIndex = (int)value;
			}
		}

		public int TargetPropIndex => SecondIndex;

		public int TargetPropNodeIndex => ThirdIndex;

		public CommandSe3D()
		{
		}

		public CommandSe3D(SequenceData.Param data)
		{
			base.ID = data.DataInt[0];
			FlagToParams(data.DataInt[1]);
			Source = (SourceType)data.DataInt[2];
			FirstIndex = TryGetDataInt(data.DataInt, 3);
			SecondIndex = TryGetDataInt(data.DataInt, 4);
			ThirdIndex = TryGetDataInt(data.DataInt, 5);
			Volume = data.DataFloat[0];
			Position = new Vector3(TryGetDataFloat(data.DataFloat, 1), TryGetDataFloat(data.DataFloat, 2), TryGetDataFloat(data.DataFloat, 3));
		}

		private int TryGetDataInt(List<int> list, int index, int defaultValue = 0)
		{
			if (list.Count <= index)
			{
				return defaultValue;
			}
			return list[index];
		}

		private float TryGetDataFloat(List<float> list, int index, float defaultValue = 0f)
		{
			if (list.Count <= index)
			{
				return defaultValue;
			}
			return list[index];
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (Source == SourceType.Chara)
			{
				MoveToCharaPosition();
			}
			else if (Source == SourceType.Prop)
			{
				MoveToPropPosition(player.CurrentBackground);
			}
			else if (Source == SourceType.PropNode)
			{
				MoveToPropAnchorPosition(player.CurrentBackground);
			}
			SoundManager.SE.PlayClip3D(base.Clip, base.ID, Volume, ref Position, IsRepeat);
			return true;
		}

		private void MoveToCharaPosition()
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara((GameDefine.CharaID)FirstIndex);
			if (!(chara == null))
			{
				if (chara.Model.IsFading)
				{
					Position = chara.NextPosition;
					return;
				}
				Vector3 addAmount = chara.Transform.localPosition;
				Vector3Extension.AddTarget(ref Position, ref addAmount);
			}
		}

		private void MoveToPropPosition(AdvBackground bg)
		{
			BaseProp propByIndex = bg.GetPropControllerByType(TargetPropType).GetPropByIndex(TargetPropIndex);
			if (!(propByIndex == null))
			{
				Vector3 addAmount = propByIndex.AudioAnchorTransform.position;
				Vector3Extension.AddTarget(ref Position, ref addAmount);
			}
		}

		private void MoveToPropAnchorPosition(AdvBackground bg)
		{
			BaseProp propByIndex = bg.GetPropControllerByType(TargetPropType).GetPropByIndex(TargetPropIndex);
			if (!(propByIndex == null))
			{
				Transform anchor = propByIndex.GetAnchor(TargetPropNodeIndex);
				if (!(anchor == null))
				{
					Position = anchor.TransformPoint(Position);
				}
			}
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSe3D)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string text = "";
			switch (Source)
			{
			case SourceType.Point:
				text = $"{Position.ToString()}";
				break;
			case SourceType.Chara:
				text = $"{TargetChara}";
				break;
			case SourceType.Prop:
				text = $"{TargetPropType}.{TargetPropIndex}";
				break;
			case SourceType.PropNode:
				text = $"{TargetPropType}.{TargetPropIndex}.Anchor{TargetPropNodeIndex}";
				break;
			}
			return string.Format("3D: SoundID:{0}, :{1}, :{2:p1} {3}", base.ID, text, Volume, IsRepeat ? "(Loop)" : "");
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(base.ID);
			data.DataInt.Add(ParamsToFlag());
			data.DataInt.Add((int)Source);
			data.DataInt.Add(FirstIndex);
			data.DataInt.Add(SecondIndex);
			data.DataInt.Add(ThirdIndex);
			data.DataFloat.Add(Volume);
			data.DataFloat.Add(Position.x);
			data.DataFloat.Add(Position.y);
			data.DataFloat.Add(Position.z);
		}

		private void FlagToParams(int flags)
		{
			IsRepeat = (flags & 1) != 0;
		}

		private int ParamsToFlag()
		{
			if (!IsRepeat)
			{
				return 0;
			}
			return 1;
		}
	}
	public class CommandSe3DOff : CommandSe2DOff
	{
		public override Types Type => Types.StopSE3D;

		public CommandSe3DOff()
		{
		}

		public CommandSe3DOff(int id)
			: base(id)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SoundManager.SE.Stop3D(ID);
			return true;
		}

		public override string CreateDescriptionText()
		{
			return $"3DID {ID} ";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(ID);
		}
	}
	public class CommandSelection : ISequenceCommand
	{
		public class SelectionOptions
		{
			public const int PARAM_MAX = 6;

			public SelectionDefines.CollisionTypes MakeCollisionType;

			public int TypeInt;

			public int TargetIndexOne;

			public int TargetIndexTwo;

			public int TargetIndexThree;

			public int NextSequenceIndex;

			public SelectionDefines.TargetTypes SelectType
			{
				get
				{
					return (SelectionDefines.TargetTypes)TypeInt;
				}
				set
				{
					TypeInt = (int)value;
				}
			}

			public GameDefine.CharaID TargetChara
			{
				get
				{
					return (GameDefine.CharaID)TargetIndexOne;
				}
				set
				{
					TargetIndexOne = (int)value;
				}
			}

			public PropDefines.PropType TargetPropType
			{
				get
				{
					return (PropDefines.PropType)TargetIndexOne;
				}
				set
				{
					TargetIndexOne = (int)value;
				}
			}

			public int TargetPropIndex
			{
				get
				{
					return TargetIndexTwo;
				}
				set
				{
					TargetIndexTwo = value;
				}
			}

			public int TargetFocusWindowIndex
			{
				get
				{
					return TargetIndexOne;
				}
				set
				{
					TargetIndexOne = value;
				}
			}

			public void Save(SequenceData.Param data)
			{
				data.DataInt.Add((int)MakeCollisionType);
				data.DataInt.Add(TypeInt);
				data.DataInt.Add(TargetIndexOne);
				data.DataInt.Add(TargetIndexTwo);
				data.DataInt.Add(TargetIndexThree);
				data.DataInt.Add(NextSequenceIndex);
			}

			public static SelectionOptions Load(SequenceData.Param data, int startIndex)
			{
				SelectionOptions selectionOptions = new SelectionOptions();
				if (data.DataInt.Count < startIndex + 6)
				{
					return selectionOptions;
				}
				selectionOptions.MakeCollisionType = (SelectionDefines.CollisionTypes)data.GetInt(startIndex);
				selectionOptions.TypeInt = data.GetInt(startIndex + 1);
				selectionOptions.TargetIndexOne = data.GetInt(startIndex + 2);
				selectionOptions.TargetIndexTwo = data.GetInt(startIndex + 3);
				selectionOptions.TargetIndexThree = data.GetInt(startIndex + 4);
				selectionOptions.NextSequenceIndex = data.GetInt(startIndex + 5);
				return selectionOptions;
			}
		}

		public const int MIN_OPTIION = 1;

		public const int MAX_OPTIION = 4;

		private int _selectionCount = 2;

		private int _selectionMode;

		public List<SelectionOptions> SelectionList = new List<SelectionOptions>();

		public override Types Type => Types.Selection;

		public override bool PlayInHardSkip => true;

		public int SelectionCount
		{
			get
			{
				return _selectionCount;
			}
			set
			{
				_selectionCount = Mathf.Clamp(value, 1, 4);
			}
		}

		public SelectionDefines.Modes SelectionMode
		{
			get
			{
				return (SelectionDefines.Modes)_selectionMode;
			}
			set
			{
				_selectionMode = (int)value;
			}
		}

		public CommandSelection()
		{
			for (int i = 0; i < 4; i++)
			{
				SelectionList.Add(new SelectionOptions());
			}
		}

		public CommandSelection(SequenceData.Param data, int version)
		{
			int num = 2;
			SelectionCount = data.GetInt(0);
			if (version <= 6)
			{
				num = 1;
			}
			else
			{
				_selectionMode = data.GetInt(1);
			}
			for (int i = 0; i < 4; i++)
			{
				if (i < SelectionCount)
				{
					int startIndex = num + i * 6;
					SelectionOptions item = SelectionOptions.Load(data, startIndex);
					SelectionList.Add(item);
				}
				else
				{
					SelectionList.Add(new SelectionOptions());
				}
			}
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SelectionController selectionProcessor = player.SelectionProcessor;
			selectionProcessor.EndSelectionObservable.Where((int index) => index > -1).Subscribe(delegate(int index)
			{
				OnEndSelection(player, index);
			});
			selectionProcessor.StartSelection(this);
			player.MessageProcessor.ForceMode = MessagePlayer.ForceModes.NoAutoSkip;
			SingletonMonoBehaviour<MainMenuManager>.Instance.SetProhibitions(MainMenuManager.MenuMode.SkipMode, flag: true);
			SingletonMonoBehaviour<MainMenuManager>.Instance.SetProhibitions(MainMenuManager.MenuMode.Note, flag: true);
			return false;
		}

		private void OnEndSelection(TimelinePlayer player, int index)
		{
			SingletonMonoBehaviour<LocalData>.Instance.IsOmitNextAutoSave = true;
			if (SelectionMode == SelectionDefines.Modes.Finale)
			{
				player.ReleaseCommandWait();
				return;
			}
			int nextSequenceIndex = SelectionList[index].NextSequenceIndex;
			player.ReserveLoadScenerioWithComplete(nextSequenceIndex);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSelection)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string text = "";
			if (SelectionMode == SelectionDefines.Modes.Finale)
			{
				text = "";
			}
			else
			{
				for (int i = 0; i < SelectionCount; i++)
				{
					if (i > 0)
					{
						text += " or ";
					}
					text += $"SID[{SelectionList[i].NextSequenceIndex:00000}]";
				}
			}
			return ": " + text;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(SelectionCount);
			data.DataInt.Add(_selectionMode);
			for (int i = 0; i < SelectionCount; i++)
			{
				SelectionList[i].Save(data);
			}
		}
	}
	public class CommandSetGameFlag : ISequenceCommand
	{
		public GameFlags TargetFlag;

		public bool ValueToSet;

		public override Types Type => Types.SetGameFlag;

		public override bool PlayInHardSkip => true;

		public CommandSetGameFlag()
		{
			ValueToSet = true;
		}

		public CommandSetGameFlag(SequenceData.Param data)
			: this()
		{
			TargetFlag = (GameFlags)data.DataInt[0];
			ValueToSet = data.DataInt[1] != 0;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			AnalyticsUtility.SendFlagEvent(TargetFlag, ValueToSet);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(TargetFlag, ValueToSet);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSetGameFlag)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $" [{TargetFlag}] = {ValueToSet}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)TargetFlag);
			data.DataInt.Add(ValueToSet ? 1 : 0);
		}
	}
	public class CommandShakeWindow : ISequenceCommand
	{
		public float Duration = 0.35f;

		public override Types Type => Types.ShakeWindow;

		public CommandShakeWindow()
		{
			Duration = 0.35f;
		}

		public CommandShakeWindow(float duration)
		{
			Duration = duration;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MessageProcessor.ShakeNextWindow(Duration);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandShakeWindow)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataFloat.Add(Duration);
		}
	}
	public class CommandStartCutscene : ISequenceCommand
	{
		public override Types Type => Types.StartCutscene;

		public CommandStartCutscene()
		{
		}

		public CommandStartCutscene(SequenceData.Param data, int version)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (player.CurrentCutScene == null)
			{
				player.ForceFindCutScene();
			}
			player.CurrentCutScene.PrepareTimeline();
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandStartCutscene)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandTest : ISequenceCommand
	{
		public override Types Type => Types.Test;

		public override bool PlayCommand(TimelinePlayer player)
		{
			UnityEngine.Debug.Log("WOW it's a test command!");
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandTest)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandText : ISequenceCommand
	{
		public bool Is2DVoice;

		private MemoryModeManager m_memoryModeManager;

		public override Types Type => Types.Text;

		public GameDefine.CharaID Chara { get; set; }

		public GameDefine.CharaID CharaType { get; private set; }

		public int TextIndex { get; set; }

		public int VoiceIndex { get; set; }

		public string Text { get; set; }

		public string VoiceFile { get; private set; }

		public bool IsMemoryMode { get; private set; }

		public bool IsMonologue => Chara == GameDefine.CharaID.BASE;

		public string CharaFullName
		{
			get
			{
				if (!IsMonologue)
				{
					return SingletonMonoBehaviour<DataManager>.Instance.CharaData.FindName(Chara);
				}
				return string.Empty;
			}
		}

		public CommandText()
		{
		}

		public CommandText(GameDefine.CharaID chara, string text, int textIndex, string voiceFile, int voiceIndex = -1, bool is2DVoice = false)
		{
			Chara = chara;
			Text = text;
			TextIndex = textIndex;
			VoiceIndex = voiceIndex;
			Is2DVoice = is2DVoice;
			VoiceFile = voiceFile;
			CharaType = chara;
			if (GameDefine.IsUnknownChara(CharaType))
			{
				CharaType = GameDefine.UnknownToCharaID(CharaType);
			}
			CharaType = GameDefine.GetOriginalCharaID(CharaType);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandText)MemberwiseClone();
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			ProcessMemoryMode(player);
			player.MessageProcessor.AddMessageLog(this);
			return false;
		}

		private void ProcessMemoryMode(TimelinePlayer player)
		{
			m_memoryModeManager = player.MemoryModeProcessor;
			IsMemoryMode = player.IsMemoryMode;
			if (IsMemoryMode)
			{
				m_memoryModeManager.SetTalkChara(Chara);
			}
		}

		public Data_Character.Param FindCharacterData()
		{
			if (Chara == GameDefine.CharaID.BASE)
			{
				return SingletonMonoBehaviour<DataManager>.Instance.CharaTextData.FindDataByID(GameDefine.CharaID.BASE);
			}
			if (GameDefine.IsModChara(Chara))
			{
				return SingletonMonoBehaviour<DataManager>.Instance.CharaTextData.FindDataByID(GameDefine.CharaID.BASE);
			}
			if (GameDefine.IsUnknownChara(Chara))
			{
				return SingletonMonoBehaviour<DataManager>.Instance.CharaTextData.FindDataByID(GameDefine.UnknownToCharaID(Chara));
			}
			return SingletonMonoBehaviour<DataManager>.Instance.CharaTextData.FindDataByID(Chara);
		}

		public IChara FindCharacter()
		{
			if (Chara == GameDefine.CharaID.BASE)
			{
				return null;
			}
			if (IsMemoryMode)
			{
				return m_memoryModeManager.FindCharaType(Chara);
			}
			return SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			player.UpdateMessageInput();
			return false;
		}

		public override string CreateDescriptionText()
		{
			return string.Format("{1}  (ID = {0})", TextIndex, Chara);
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(TextIndex);
			data.DataInt.Add(VoiceIndex);
			data.DataInt.Add(BoolToInt(Is2DVoice));
		}
	}
	public class CommandWaitBgmBar : ISequenceCommand
	{
		public int WaitBars = 1;

		private Common.Timer m_waitTimer;

		public override Types Type => Types.WaitBgmBar;

		public CommandWaitBgmBar()
		{
			m_waitTimer = null;
		}

		public CommandWaitBgmBar(int waitBars)
			: this()
		{
			WaitBars = waitBars;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (player.IsSkipMode)
			{
				return true;
			}
			float bgmBarDuration = SingletonMonoBehaviour<SoundManager>.Instance.GetBgmBarDuration(WaitBars, isCountCurrentBar: true);
			if (bgmBarDuration <= 0f)
			{
				return true;
			}
			m_waitTimer = new Common.Timer(bgmBarDuration);
			return false;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			if (m_waitTimer == null)
			{
				SayOops("I cannot find timer for waiting.");
				return true;
			}
			m_waitTimer.Update(timeDelta);
			if (m_waitTimer.IsTimeUp)
			{
				m_waitTimer = null;
				return true;
			}
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandWaitBgmBar)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "BGM " + WaitBars + " ";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(WaitBars);
		}
	}
	public class CommandWaitBgmEnd : ISequenceCommand
	{
		public override Types Type => Types.WaitBgmEnd;

		public override bool PlayCommand(TimelinePlayer player)
		{
			bool num = IsEnd();
			if (!num && !SoundManager.Bgm.IsKaineStopping)
			{
				SoundManager.Bgm.Stop(BgmPlayer.StopMode.Fade);
			}
			return num;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			return IsEnd();
		}

		private bool IsEnd()
		{
			return !SingletonMonoBehaviour<SoundManager>.Instance.IsPlayingBgm();
		}

		public override ISequenceCommand Clone()
		{
			return (CommandWaitBgmEnd)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "BGM";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandWaitInput : ISequenceCommand
	{
		public override Types Type => Types.WaitInput;

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (player.IsSkipMode)
			{
				return true;
			}
			return false;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			player.UpdateMessageInput();
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandWaitInput)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandWaitSE : ISequenceCommand
	{
		public override Types Type => Types.WaitSE;

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			return !SoundManager.SE.IsPlayingAny();
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			return !SoundManager.SE.IsPlayingAny();
		}

		public override ISequenceCommand Clone()
		{
			return (CommandWaitSE)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandWaitTime : ISequenceCommand
	{
		public float Duration = 0.5f;

		private Common.Timer m_waitTimer;

		public override Types Type => Types.Wait;

		public CommandWaitTime()
		{
			Duration = 0.5f;
		}

		public CommandWaitTime(float time)
		{
			Duration = time;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (player.IsSkipMode)
			{
				return true;
			}
			m_waitTimer = new Common.Timer(Duration);
			return false;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			if (m_waitTimer == null)
			{
				SayOops("I cannot find timer for waiting.");
				return true;
			}
			m_waitTimer.Update(timeDelta);
			if (m_waitTimer.IsTimeUp)
			{
				m_waitTimer = null;
				return true;
			}
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandWaitTime)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $": {Duration} ";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataFloat.Add(Duration);
		}
	}
	public class CommandWaitTimeline : ISequenceCommand
	{
		public override Types Type => Types.WaitTimeline;

		public CommandWaitTimeline()
		{
		}

		public CommandWaitTimeline(SequenceData.Param data, int version)
			: base(data, version)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MessageProcessor.SetIndigaterVisible(flag: false);
			SingletonMonoBehaviour<MainMenuManager>.Instance.SetProhibitions(MainMenuManager.MenuMode.Note, flag: true);
			return player.CurrentCutScene.IsFinished;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			if (!player.IsSkipMode)
			{
				return player.CurrentCutScene.IsFinished;
			}
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandWaitTimeline)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandWindowThroughEffect : ISequenceCommand
	{
		public override Types Type => Types.WindowThroughEffect;

		public CommandWindowThroughEffect()
		{
		}

		public CommandWindowThroughEffect(SequenceData.Param data, int version)
			: base(data, version)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MessageProcessor.EffectThroughNextWindow();
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandWindowThroughEffect)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public abstract class ICharaCommand : ISequenceCommand
	{
		public GameDefine.CharaID Chara = GameDefine.CharaID.NIKAIDOU;

		public bool IsMemoryMode;

		public ICharaCommand()
		{
		}

		public ICharaCommand(GameDefine.CharaID chara)
		{
			Chara = chara;
		}
	}
	[Serializable]
	public abstract class ISequenceCommand
	{
		public enum Types
		{
			Text = 0,
			CharaActive = 1,
			CharaOn = 2,
			CharaOff = 3,
			CharaPosition = 4,
			CharaRotate = 5,
			PlaySE2D = 6,
			StopSE2D = 7,
			PlayBgm = 8,
			StopBgm = 9,
			Wait = 10,
			WaitInput = 11,
			FadeIn = 12,
			FadeOut = 13,
			CharaMotion = 14,
			CharaFace = 15,
			PlayerPosition = 16,
			PlayerRotation = 17,
			Emotion = 18,
			ShakeWindow = 19,
			Selection = 20,
			ForcusUp = 21,
			ForcusUpOff = 22,
			Environment = 23,
			Scene = 24,
			Sequence = 25,
			Props = 26,
			PropsOff = 27,
			PropsChara = 28,
			PropsCharaOff = 29,
			PlaySE3D = 30,
			StopSE3D = 31,
			EndDemo = 32,
			PlayAmbient = 33,
			StopAmbient = 34,
			CharaLootAt = 35,
			CharaChange = 36,
			FlashBackStart = 37,
			FlashBackEnd = 38,
			FlashBackChange = 39,
			ForcusUpChange = 40,
			FadeWithoutText = 41,
			FadeWithoutTextEnd = 42,
			CharaAttachPlayer = 43,
			CharaDetachPlayer = 44,
			BokeSphereStart = 45,
			BokeSphereEnd = 46,
			FixWindowStart = 47,
			FixWindowEnd = 48,
			SetPlayerChara = 49,
			CharaCircularPosition = 50,
			BgmChangeLayer = 51,
			EnvrionmentBlendShape = 52,
			EnvironmentPropsPosition = 53,
			EnvironmentPropsRotation = 54,
			EnvironmentPropsOn = 55,
			EnvironmentPropsOff = 56,
			WaitBgmBar = 57,
			LogicIfFlag = 58,
			LogicElse = 59,
			LogicEndIf = 60,
			SetGameFlag = 61,
			WaitBgmEnd = 62,
			CharaRotateReletive = 63,
			CharaPositionReletive = 64,
			CharaSetMirrorMode = 65,
			CameraClearColour = 66,
			PlayBgmSimple = 67,
			StopBgmSimple = 68,
			BgmSimpleVolumeChange = 69,
			SceneProp = 70,
			ScenePropAction = 71,
			CharaTransform = 72,
			PlayerArmMotion = 73,
			WaitSE = 74,
			ProhibitOpenMenu = 75,
			ProhibitMenuSelection = 76,
			ProhibitMessageSound = 77,
			SceneToChapterStart = 78,
			SceneToChapterEnd = 79,
			EndInGame = 80,
			MessageForceMode = 81,
			SceneUnload = 82,
			MemoryCharaOn = 83,
			MemoryCharaOff = 84,
			MemoryCharaTransform = 85,
			MemoryStart = 86,
			MemoryEnd = 87,
			EnableTypingSound = 88,
			MemoryEmotion = 89,
			MemoryAmbient = 90,
			MemoryAmbientOff = 91,
			MemoryAmbientVolume = 92,
			PlayerAvaterTrack = 93,
			SceneToOpening = 94,
			SceneToSpecial = 95,
			WaitTimeline = 96,
			NoAnimationLimit = 97,
			OutlineChange = 98,
			WindowThroughEffect = 99,
			CpuGpuLevel = 100,
			StartCutscene = 101,
			BackgroundActive = 102,
			CharaStyleChange = 103,
			AvaterVisible = 104,
			CommandAutoWaitOverride = 105,
			AvaterOutline = 106,
			CharaTexture = 107,
			PlayAreaBoundary = 108,
			AvaterTexture = 109,
			ScenePropOutline = 110,
			MenuFixMode = 111,
			ProhibitHeightChange = 112,
			EditorNote = 999999,
			Test = 1000000,
			Undefined = 1000001
		}

		public enum PreloadTypes
		{
			None = -1,
			TextVoice,
			BgmSimple,
			BgmAdvanced,
			SoundEffect,
			AmbientEffect,
			FocusUp,
			FlashBack,
			BokeSphere,
			PropStatic,
			PropDynamic,
			Avater,
			MemoryChara,
			UnityScene,
			CpuGpuLevel,
			MemoryModeStart,
			MAX
		}

		public virtual Types Type => Types.Undefined;

		public virtual bool IsDeprecated => false;

		public virtual bool IsLogic => false;

		public virtual bool PlayInHardSkip => false;

		public virtual PreloadTypes PreloadType => PreloadTypes.None;

		public virtual int PreloadIndex => -1;

		public bool IsNeedPreload
		{
			get
			{
				if (PreloadType != PreloadTypes.None)
				{
					return PreloadIndex != -1;
				}
				return false;
			}
		}

		public ISequenceCommand()
		{
		}

		public ISequenceCommand(SequenceData.Param data, int version)
			: this()
		{
		}

		public abstract ISequenceCommand Clone();

		public override string ToString()
		{
			return Type.ToString();
		}

		public virtual bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public virtual void OnStart(TimelinePlayer player)
		{
		}

		public virtual void OnEnd(TimelinePlayer player)
		{
		}

		public virtual bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			return false;
		}

		public abstract string CreateDescriptionText();

		public abstract void Save(SequenceData.Param data);

		protected int BoolToInt(bool flag)
		{
			if (!flag)
			{
				return 0;
			}
			return 1;
		}

		protected bool IntToBool(int value)
		{
			if (value != 0)
			{
				return true;
			}
			return false;
		}

		protected int BoolListToInt(List<bool> flags)
		{
			int num = 0;
			for (int i = 0; i < flags.Count; i++)
			{
				if (flags[i])
				{
					num += 1 << i;
				}
			}
			return num;
		}

		protected List<bool> IntToBoolList(int flags, int max)
		{
			List<bool> list = new List<bool>(max);
			for (int i = 0; i < max; i++)
			{
				list.Add((flags & (1 << i)) != 0);
			}
			return list;
		}

		protected void SayOops(string text)
		{
		}
	}
	public interface ISoundCommand
	{
		int ID { get; set; }

		AudioClip Clip { get; set; }

		string GetFilePath();
	}
	public class MessagePlayer : MonoBehaviour
	{
		public enum PlayModes
		{
			Normal,
			Auto,
			Skip,
			Log,
			None
		}

		public enum ForceModes
		{
			Freedom,
			NoAuto,
			NoSkip,
			NoAutoSkip,
			ForceAuto
		}

		[Header("Components - External")]
		[SerializeField]
		private MessageWindowController m_messageController;

		[SerializeField]
		private MessageIndigaterComponents m_indigaters;

		private PlayModes m_mode;

		private ForceModes m_forceMode;

		private Subject<Unit> _subjectMessagePaged = new Subject<Unit>();

		private Subject<CommandText> _subjectAddMessageLog = new Subject<CommandText>();

		private Subject<Unit> _subjectFlushMessageLog = new Subject<Unit>();

		private ReactiveProperty<bool> _reactiveIsRemoveInterface = new ReactiveProperty<bool>(initialValue: false);

		private MessageWindowController windowController => m_messageController;

		public bool IsPlayPageSound { get; set; }

		public bool IsMemoryMode { get; set; }

		public bool IsAutoMode => m_mode == PlayModes.Auto;

		public bool IsSkipMode => m_mode == PlayModes.Skip;

		public bool IsEmitSoundOnMessage
		{
			get
			{
				return m_messageController.IsEmitSoundOnMessage;
			}
			set
			{
				m_messageController.IsEmitSoundOnMessage = value;
			}
		}

		public ForceModes ForceMode
		{
			get
			{
				return m_forceMode;
			}
			set
			{
				ChangeForceMode(value);
			}
		}

		public bool CanInterract => m_forceMode != ForceModes.ForceAuto;

		public bool IsAutoWaitOverrided { get; set; }

		public float AutoWaitOverride { get; set; }

		public int MessageSpeedOverride { get; set; }

		public bool IsAutoWaitNeedOverride
		{
			get
			{
				if (IsAutoWaitOverrided)
				{
					return AutoWaitOverride >= 0f;
				}
				return false;
			}
		}

		public bool ProhibitHeightChange
		{
			get
			{
				return windowController.ProhibitHeightChange;
			}
			set
			{
				windowController.ProhibitHeightChange = value;
			}
		}

		public bool IsSuperAutoMode => false;

		public IObservable<Unit> OnMessagePaged => _subjectMessagePaged;

		public IObservable<CommandText> OnAddMessageLog => _subjectAddMessageLog;

		public IObservable<Unit> OnFlushMessageLog => _subjectFlushMessageLog;

		public IReadOnlyReactiveProperty<bool> RemoveInterfaceReactive => _reactiveIsRemoveInterface;

		public bool IsRemoveInterface
		{
			get
			{
				return _reactiveIsRemoveInterface.Value;
			}
			set
			{
				_reactiveIsRemoveInterface.Value = value;
			}
		}

		private void Start()
		{
			windowController.SetPlayer(this);
			InitStates();
			MakeSubscribe();
		}

		private void MakeSubscribe()
		{
			RemoveInterfaceReactive.Subscribe(delegate
			{
				UpdateIndigater();
			});
		}

		public void ClearScenarioRelations()
		{
			FlushMessageLog();
			InitStates();
			windowController.ClearScenarioRelations();
		}

		private void InitStates()
		{
			IsPlayPageSound = true;
			IsMemoryMode = false;
			IsEmitSoundOnMessage = false;
			IsAutoWaitOverrided = false;
			ForceMode = ForceModes.Freedom;
			if (IsSuperAutoMode && m_mode == PlayModes.Normal)
			{
				SetPlayMode(PlayModes.Auto);
			}
			SetIndigaterVisible(flag: true);
			UpdateIndigater();
		}

		public void FlushMessageLog()
		{
			windowController.FlushWindows();
			_subjectFlushMessageLog.OnNext(Unit.Default);
		}

		public void AddMessageLog(CommandText data)
		{
			windowController.NewTextMessage(data);
			_subjectAddMessageLog.OnNext(data);
		}

		public void AddMessageEmergency(CommandText data)
		{
			windowController.NewTextMessage(data);
			windowController.ShowLastWindowAllText();
		}

		public void OnPushMainButton()
		{
			if (CanInterract)
			{
				if (!IsFinishText())
				{
					ShowAllText();
				}
				else
				{
					PlayNextText();
				}
			}
		}

		public void OnProcessAuto()
		{
			PlayNextText();
		}

		private void PlayNextText()
		{
			SoundManager.Voice.StopCurrentVoice();
			if (IsPlayPageSound)
			{
				PlayNextPageSE();
			}
			windowController.OnNextPageInput();
			_subjectMessagePaged.OnNext(Unit.Default);
		}

		private void PlayNextPageSE()
		{
			if (IsMemoryMode)
			{
				SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Message_TypeNext, windowController.MessageAudioSource);
			}
			else
			{
				SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Message_Next, windowController.MessageAudioSource);
			}
		}

		public void ShowAllText()
		{
			windowController.ShowLastWindowAllText();
		}

		public bool IsAutoCounterOk()
		{
			if (!IsAutoWaitNeedOverride)
			{
				if (IsFinishText())
				{
					return IsFinishVoice();
				}
				return false;
			}
			return true;
		}

		private bool IsFinishText()
		{
			return windowController.IsLastWindowAllVisible();
		}

		private bool IsFinishVoice()
		{
			return !SoundManager.Voice.IsPlayingVoice();
		}

		public void ShakeWindow(float duration)
		{
			windowController.ShakeLastWindow(duration);
		}

		public void ShakeNextWindow(float duration)
		{
			_subjectAddMessageLog.First().Subscribe(delegate
			{
				ShakeWindow(duration);
			});
		}

		public void EffectThroughWindow()
		{
			windowController.StartThroughEffect();
		}

		public void EffectThroughNextWindow()
		{
			_subjectAddMessageLog.First().Subscribe(delegate
			{
				EffectThroughWindow();
			});
		}

		public void ResetPlayMode()
		{
			SetPlayMode(PlayModes.Normal);
		}

		public void SetPlayMode(PlayModes m)
		{
			if (m_mode != m)
			{
				m_mode = m;
				UpdateIndigater();
			}
		}

		public bool GetCanToggleModeTo(PlayModes m)
		{
			if (!CanInterract)
			{
				return false;
			}
			switch (m)
			{
			case PlayModes.Normal:
				return true;
			case PlayModes.Auto:
				if (ForceMode != ForceModes.NoAuto)
				{
					return ForceMode != ForceModes.NoAutoSkip;
				}
				return false;
			case PlayModes.Skip:
				if (ForceMode != ForceModes.NoSkip)
				{
					return ForceMode != ForceModes.NoAutoSkip;
				}
				return false;
			default:
				return true;
			}
		}

		public void SetIndigaterVisible(bool flag)
		{
			m_indigaters.ToggleEnabled(flag);
		}

		private void UpdateIndigater()
		{
			m_indigaters.ToggleVisibleAutoPlay(!IsRemoveInterface && m_mode == PlayModes.Auto && ForceMode != ForceModes.ForceAuto);
		}

		private void ChangeForceMode(ForceModes nextMode)
		{
			if (!IsSuperAutoMode && nextMode != m_forceMode)
			{
				ForceModes forceMode = m_forceMode;
				m_forceMode = nextMode;
				OnEndForceMode(forceMode);
				OnStartForceMode(m_forceMode);
				UpdateIndigater();
			}
		}

		private void OnEndForceMode(ForceModes oldMode)
		{
			if (oldMode == ForceModes.ForceAuto && IsAutoMode)
			{
				ResetPlayMode();
			}
		}

		private void OnStartForceMode(ForceModes nextMode)
		{
			switch (nextMode)
			{
			case ForceModes.NoAuto:
				if (IsAutoMode)
				{
					ResetPlayMode();
				}
				break;
			case ForceModes.NoSkip:
				if (IsSkipMode)
				{
					ResetPlayMode();
				}
				break;
			case ForceModes.NoAutoSkip:
				if (IsAutoMode || IsSkipMode)
				{
					ResetPlayMode();
				}
				break;
			case ForceModes.ForceAuto:
				SetPlayMode(PlayModes.Auto);
				break;
			}
		}
	}
	public class MoverFadeSequencer
	{
		private IFader m_fader;

		private Camera m_camera;

		private Color m_backgroundColour;

		private bool m_isBusy;

		private Color m_previousBackgroundColour;

		private float m_fadeDurationAction;

		private Action m_onStartFadeEndAction;

		private Action m_onStartReverseFadeEndAction;

		private Action m_onEndAction;

		public bool IsPlaying { get; private set; }

		public Color BackgroundColor => m_backgroundColour;

		public Color PreviousBackgroundColor => m_previousBackgroundColour;

		public bool IsBusy
		{
			get
			{
				if (!m_isBusy)
				{
					return m_fader.IsFading;
				}
				return true;
			}
		}

		public MoverFadeSequencer(IFader fader, Camera camera, Color backgroundColour)
		{
			m_isBusy = false;
			IsPlaying = fader;
			m_fader = fader;
			m_backgroundColour = backgroundColour;
			m_camera = camera;
			m_onStartFadeEndAction = delegate
			{
				OnStartFadeEnd();
			};
			m_onStartReverseFadeEndAction = delegate
			{
				m_isBusy = false;
				m_fader.SetActive(isActive: false);
			};
			m_onEndAction = delegate
			{
				m_isBusy = false;
				IsPlaying = false;
			};
		}

		public void Play(CommandFadeWithoutText command)
		{
			m_isBusy = true;
			IsPlaying = true;
			m_fadeDurationAction = command.Duration;
			m_backgroundColour = command.EndColour;
			if (m_fadeDurationAction <= 0f)
			{
				SetupStates();
				m_fader.SetColour(command.StartColour);
				m_onStartReverseFadeEndAction();
			}
			else
			{
				m_fader.StartFade(command.StartColour, command.EndColour, m_fadeDurationAction, isDeactivateOnEnd: false, m_onStartFadeEndAction);
			}
		}

		private void OnStartFadeEnd()
		{
			SetupStates();
			m_fader.StartReverseFade(m_fadeDurationAction, isDeactivateOnEnd: false, m_onStartReverseFadeEndAction);
		}

		private void SetupStates()
		{
			m_previousBackgroundColour = m_camera.backgroundColor;
			m_camera.backgroundColor = m_backgroundColour;
			SingletonMonoBehaviour<PlayAreaManager>.Instance.RequestLayerMode(this, PlayAreaManager.LayerModes.InFade);
		}

		public void End(CommandFadeWithoutTextEnd command)
		{
			m_isBusy = true;
			m_fadeDurationAction = command.Duration;
			m_fader.SetColour(command.EndColour);
			ResetCameraSettings();
			m_fader.StartFade(command.EndColour, command.StartColour, m_fadeDurationAction, isDeactivateOnEnd: true, m_onEndAction);
		}

		private void OnEndFadeEnd()
		{
			ResetCameraSettings();
		}

		public void ResetCameraSettings()
		{
			m_camera.backgroundColor = m_previousBackgroundColour;
			SingletonMonoBehaviour<PlayAreaManager>.Instance.DisposeLayerMode(this, PlayAreaManager.LayerModes.InFade);
		}

		public void Reset()
		{
			m_isBusy = false;
			IsPlaying = false;
			ResetCameraSettings();
		}
	}
	public class NotFoundScenarioException : Exception
	{
		public int failedIndex = -1;

		public NotFoundScenarioException()
			: base("")
		{
		}

		public NotFoundScenarioException(int index)
			: base($" '{index:00000}' ")
		{
			failedIndex = index;
		}
	}
	public class NotFoundSequenceException : Exception
	{
		public int failedIndex = -1;

		public NotFoundSequenceException()
			: base("")
		{
		}

		public NotFoundSequenceException(int index)
			: base($" '{index:00000}' ")
		{
			failedIndex = index;
		}
	}
	public class CommandFailedException : Exception
	{
		public ISequenceCommand failedCommand;

		public CommandFailedException()
			: base("")
		{
		}

		public CommandFailedException(ISequenceCommand command)
			: base($" {command.Type} ")
		{
			failedCommand = command;
		}

		public CommandFailedException(ISequenceCommand command, string message)
			: base(string.Format(" {0} : " + message, command.Type))
		{
			failedCommand = command;
		}
	}
	public class SequenceOverflowException : Exception
	{
		public SequenceOverflowException()
			: base("")
		{
		}
	}
	public class SequenceDataConverter
	{
		public enum Versions
		{
			_VERSION_SKIP_REVERSE,
			_VERSION_FACIAL_SKIP_REVERSE,
			_VERSION_FORCUS_UP_SCALE,
			_FORCUS_UP_SOURCES,
			_TEXT_2D_VOICE,
			_MEMORY_MODE,
			_SELECTION_MODE,
			Current
		}

		private int m_voiceIndex;

		private SequenceTable m_sequenceTable;

		private ScenarioTextTable m_textTable;

		private int m_version;

		private bool m_isEditor;

		private bool m_isConverted;

		private bool m_hasPassesFirstFade;

		private List<ISequenceCommand> m_commandList;

		private Subject<ISequenceCommand> _subjectLoadCommand = new Subject<ISequenceCommand>();

		public IObservable<ISequenceCommand> OnLoadCommand => _subjectLoadCommand;

		private bool IsDebugPlay => false;

		public SequenceDataConverter(ScenarioTextTable textTable, SequenceTable sequenceTable, bool isEditor = false)
		{
			m_isEditor = isEditor;
			m_hasPassesFirstFade = isEditor;
			m_voiceIndex = 0;
			m_textTable = textTable;
			m_sequenceTable = sequenceTable;
			m_version = m_sequenceTable.GetVersion();
		}

		public List<ISequenceCommand> Convert()
		{
			if (m_isConverted)
			{
				return m_commandList;
			}
			if (!m_isEditor)
			{
				m_hasPassesFirstFade = false;
			}
			int count = m_sequenceTable.GetCount();
			m_commandList = new List<ISequenceCommand>(count);
			for (int i = 0; i < count; i++)
			{
				ISequenceCommand sequenceCommand = ConvertCommand(m_sequenceTable.GetData(i));
				if (sequenceCommand != null)
				{
					if (sequenceCommand.IsDeprecated)
					{
						UnityEngine.Debug.LogWarningFormat("Command '{0}' is Deprecated (index: {1}). Please remove that command.", sequenceCommand.Type, i);
					}
					m_commandList.Add(sequenceCommand);
					_subjectLoadCommand.OnNext(sequenceCommand);
				}
			}
			CheckUnusedTexts();
			_subjectLoadCommand.OnCompleted();
			m_isConverted = true;
			return m_commandList;
		}

		private ISequenceCommand ConvertCommand(SequenceData.Param data)
		{
			switch (data.CommandType)
			{
			case ISequenceCommand.Types.Text:
				return CreateTextCommand(data);
			case ISequenceCommand.Types.CharaOn:
				return CreateCharaOnCommand(data);
			case ISequenceCommand.Types.CharaOff:
				return CreateCharaOffCommand(data);
			case ISequenceCommand.Types.CharaPosition:
				return CreateCharaPositionCommand(data);
			case ISequenceCommand.Types.CharaRotate:
				return CreateCharaRotationCommand(data);
			case ISequenceCommand.Types.CharaMotion:
				return CreateCharaMotionCommand(data);
			case ISequenceCommand.Types.CharaFace:
				return CreateCharaFacialCommand(data);
			case ISequenceCommand.Types.CharaLootAt:
				return CreateCharaLookAtCommand(data);
			case ISequenceCommand.Types.PlayerPosition:
				return CreatePlayerPositionCommand(data);
			case ISequenceCommand.Types.PlayerRotation:
				return CreatePlayerRotationCommand(data);
			case ISequenceCommand.Types.Scene:
				return CreateChangeSceneCommand(data);
			case ISequenceCommand.Types.Sequence:
				return CreateChangeSequenceCommand(data);
			case ISequenceCommand.Types.FadeIn:
				return CreateFadeInCommand(data);
			case ISequenceCommand.Types.Wait:
				return CreateWaitTimeCommand(data);
			case ISequenceCommand.Types.WaitInput:
				return new CommandWaitInput();
			case ISequenceCommand.Types.ForcusUp:
				return CreateForcusUpCommand(data);
			case ISequenceCommand.Types.ForcusUpOff:
				return CreateForcusUpOffCommand(data);
			case ISequenceCommand.Types.ShakeWindow:
				return CreateShakeWindowCommand(data);
			case ISequenceCommand.Types.Emotion:
				return CreateEmotionCommand(data);
			case ISequenceCommand.Types.Props:
				return CreatePropsCommand(data);
			case ISequenceCommand.Types.PropsOff:
				return CreatePropsOffCommand(data);
			case ISequenceCommand.Types.PropsChara:
				return CreatePropsCharaCommand(data);
			case ISequenceCommand.Types.PropsCharaOff:
				return CreatePropsCharaOffCommand(data);
			case ISequenceCommand.Types.PlayBgm:
				return CreateBgmCommand(data);
			case ISequenceCommand.Types.StopBgm:
				return CreateBgmOffCommand(data);
			case ISequenceCommand.Types.PlaySE2D:
				return CreateSe2DCommand(data);
			case ISequenceCommand.Types.StopSE2D:
				return CreateSe2DOffCommand(data);
			case ISequenceCommand.Types.StopSE3D:
				return CreateSe3DOffCommand(data);
			case ISequenceCommand.Types.PlaySE3D:
				return CreateSe3DCommand(data);
			case ISequenceCommand.Types.PlayAmbient:
				return CreatePlayAmbientCommand(data);
			case ISequenceCommand.Types.StopAmbient:
				return CreateStopAmbientCommand(data);
			case ISequenceCommand.Types.Selection:
				return CreateSelectionCommand(data);
			case ISequenceCommand.Types.Environment:
				return null;
			case ISequenceCommand.Types.EndDemo:
				return new CommandEndDemo();
			case ISequenceCommand.Types.CharaChange:
				return CreateCharaChangeCommand(data);
			case ISequenceCommand.Types.FlashBackStart:
				return CreateFlashbackStartCommand(data);
			case ISequenceCommand.Types.FlashBackEnd:
				return CreateFlashbackEndCommand(data);
			case ISequenceCommand.Types.FlashBackChange:
				return CreateFlashbackChangeCommand(data);
			case ISequenceCommand.Types.ForcusUpChange:
				return CreateChangeForcusUpCommand(data);
			case ISequenceCommand.Types.FadeWithoutText:
				return CreateFadeWithoutTextCommand(data);
			case ISequenceCommand.Types.FadeWithoutTextEnd:
				return CreateFadeWithoutTextEndCommand(data);
			case ISequenceCommand.Types.CharaAttachPlayer:
				return CreateCharaAttachPlayerCommand(data);
			case ISequenceCommand.Types.CharaDetachPlayer:
				return CreateCharaDetachPlayerCommand(data);
			case ISequenceCommand.Types.BokeSphereStart:
				return CreateBokeSphereCommand(data);
			case ISequenceCommand.Types.BokeSphereEnd:
				return CreateBokeSphereEndCommand(data);
			case ISequenceCommand.Types.FixWindowStart:
				return CreateFixWindowCommand(data);
			case ISequenceCommand.Types.FixWindowEnd:
				return CreateFixWindowEndCommand(data);
			case ISequenceCommand.Types.SetPlayerChara:
				return CreatePlayerSetCharaCommand(data);
			case ISequenceCommand.Types.CharaCircularPosition:
				return CreateCharaCircularPositionCommand(data);
			case ISequenceCommand.Types.BgmChangeLayer:
				return CreateBgmChangeLayerCommand(data);
			case ISequenceCommand.Types.EnvrionmentBlendShape:
				return CreateEnvironmentBlendShapeCommand(data);
			case ISequenceCommand.Types.EnvironmentPropsPosition:
				return CreateEnvironmentPropsPositionCommand(data);
			case ISequenceCommand.Types.EnvironmentPropsRotation:
				return CreateEnvironmentPropsRotationCommand(data);
			case ISequenceCommand.Types.EnvironmentPropsOn:
				return CreateEnvironmentPropsOnCommand(data);
			case ISequenceCommand.Types.EnvironmentPropsOff:
				return CreateEnvironmentPropsOffCommand(data);
			case ISequenceCommand.Types.WaitBgmBar:
				return CreateWaitBgmBarCommand(data);
			case ISequenceCommand.Types.LogicIfFlag:
				return CreateLogicIfFlagCommand(data);
			case ISequenceCommand.Types.LogicElse:
				return CreateLogicElseCommand(data);
			case ISequenceCommand.Types.LogicEndIf:
				return CreateLogicEndIfCommand(data);
			case ISequenceCommand.Types.SetGameFlag:
				return CreateSetGameFlagCommand(data);
			case ISequenceCommand.Types.WaitBgmEnd:
				return CreateWaitBgmEndCommand(data);
			case ISequenceCommand.Types.CharaRotateReletive:
				return CreateCharaRotationReletiveCommand(data);
			case ISequenceCommand.Types.CharaPositionReletive:
				return CreateCharaPositionReletiveCommand(data);
			case ISequenceCommand.Types.CharaSetMirrorMode:
				return CreateCharaSetMirrorModeCommand(data);
			case ISequenceCommand.Types.CameraClearColour:
				return CreateCameraClearColourCommand(data);
			case ISequenceCommand.Types.PlayBgmSimple:
				return CreateBgmSimpleCommand(data);
			case ISequenceCommand.Types.StopBgmSimple:
				return CreateBgmSimpleOffCommand(data);
			case ISequenceCommand.Types.BgmSimpleVolumeChange:
				return CreateBgmSimpleVolumeCommand(data);
			case ISequenceCommand.Types.SceneProp:
				return CreateScenePropCommand(data);
			case ISequenceCommand.Types.ScenePropAction:
				return CreateScenePropActionCommand(data);
			case ISequenceCommand.Types.EditorNote:
				return CreateEditorNoteCommand(data);
			case ISequenceCommand.Types.CharaTransform:
				return CreateCharaTransformCommand(data);
			case ISequenceCommand.Types.PlayerArmMotion:
				return CreatePlayerArmMotionCommand(data);
			case ISequenceCommand.Types.WaitSE:
				return CreateWaitSECommand(data);
			case ISequenceCommand.Types.ProhibitOpenMenu:
				return CreateProhibitOpenMenuCommand(data);
			case ISequenceCommand.Types.ProhibitMenuSelection:
				return CreateProhibitMenuSelectionCommand(data);
			case ISequenceCommand.Types.ProhibitMessageSound:
				return CreateProhibitMessageSoundCommand(data);
			case ISequenceCommand.Types.SceneToChapterStart:
				return CreateSceneToChapterStartCommand(data);
			case ISequenceCommand.Types.SceneToChapterEnd:
				return CreateSceneToChapterEndCommand(data);
			case ISequenceCommand.Types.EndInGame:
				return CreateEndInGameCommand(data);
			case ISequenceCommand.Types.MessageForceMode:
				return CreateMessageForceModeCommand(data);
			case ISequenceCommand.Types.SceneUnload:
				return CreateSceneUnloadCommand(data);
			case ISequenceCommand.Types.EnableTypingSound:
				return CreateEnableTypingSoundCommand(data);
			case ISequenceCommand.Types.MemoryCharaOn:
				return CreateMemoryCharaOnCommand(data);
			case ISequenceCommand.Types.MemoryCharaOff:
				return CreateMemoryCharaOffCommand(data);
			case ISequenceCommand.Types.MemoryCharaTransform:
				return CreateMemoryCharaTransformCommand(data);
			case ISequenceCommand.Types.MemoryStart:
				return CreateMemoryModeStartCommand(data);
			case ISequenceCommand.Types.MemoryEnd:
				return CreateMemoryModeEndCommand(data);
			case ISequenceCommand.Types.MemoryEmotion:
				return CreateMemoryEmotionCommand(data);
			case ISequenceCommand.Types.MemoryAmbient:
				return CreateMemoryAmbientCommand(data);
			case ISequenceCommand.Types.MemoryAmbientOff:
				return CreateMemoryAmbientOffCommand(data);
			case ISequenceCommand.Types.MemoryAmbientVolume:
				return CreateMemoryAmbientVolumeCommand(data);
			case ISequenceCommand.Types.PlayerAvaterTrack:
				return CreatePlayerAvaterTrackCommand(data);
			case ISequenceCommand.Types.SceneToOpening:
				return CreateSceneToOpeningCommand(data);
			case ISequenceCommand.Types.SceneToSpecial:
				return CreateSceneToSpecialCommand(data);
			case ISequenceCommand.Types.WaitTimeline:
				return CreateWaitTimelineCommand(data);
			case ISequenceCommand.Types.NoAnimationLimit:
				return CreateNoAnimationLimitCommand(data);
			case ISequenceCommand.Types.OutlineChange:
				return CreateCharaOutlineChangeCommand(data);
			case ISequenceCommand.Types.WindowThroughEffect:
				return CreateWindowThroughEffectCommand(data);
			case ISequenceCommand.Types.CpuGpuLevel:
				return CreateCpuGpuLevelCommand(data);
			case ISequenceCommand.Types.StartCutscene:
				return CreateStartCutsceneCommand(data);
			case ISequenceCommand.Types.BackgroundActive:
				return CreateBackgroundActiveCommand(data);
			case ISequenceCommand.Types.CharaStyleChange:
				return CreateCharaStyleChangeCommand(data);
			case ISequenceCommand.Types.AvaterVisible:
				return CreatePlayerAvaterVisibleCommand(data);
			case ISequenceCommand.Types.CommandAutoWaitOverride:
				return CreateAutoWaitOverrideCommand(data);
			case ISequenceCommand.Types.AvaterOutline:
				return CreateAvaterOutlineCommand(data);
			case ISequenceCommand.Types.CharaTexture:
				return CreateCharaTextureCommand(data);
			case ISequenceCommand.Types.PlayAreaBoundary:
				return CreatePlayAreaBoundaryCommand(data);
			case ISequenceCommand.Types.AvaterTexture:
				return CreateAvaterTextureCommand(data);
			case ISequenceCommand.Types.ScenePropOutline:
				return CreateScenePropOutlineCommand(data);
			case ISequenceCommand.Types.MenuFixMode:
				return CreateMenuFixModeCommand(data);
			case ISequenceCommand.Types.ProhibitHeightChange:
				return CreateProhibitHeightChangeCommand(data);
			default:
				UnityEngine.Debug.LogErrorFormat("OOPS: I couldn't convert command '{0}'!", data.CommandType);
				return null;
			}
		}

		private bool IntToBool(int value)
		{
			if (value != 0)
			{
				return true;
			}
			return false;
		}

		private CommandText CreateTextCommand(SequenceData.Param data)
		{
			int num = data.DataInt[1];
			ScenarioTableData.Param data2 = m_textTable.GetData(num);
			if (data2 == null)
			{
				UnityEngine.Debug.Log($"Missing scenario index: {num}");
				return null;
			}
			GameDefine.CharaID charaID = ((data2.Chara == 0) ? GameDefine.CharaID.BASE : ((GameDefine.CharaID)data2.Chara));
			int voiceIndex = -1;
			if (m_isEditor)
			{
				if (data2 != null)
				{
					charaID = GameDefine.GetCharaID(data2.Chara);
				}
				if (data.DataInt.Count > 2)
				{
					voiceIndex = data.DataInt[2];
				}
				else if (charaID != GameDefine.CharaID.BASE)
				{
					voiceIndex = m_voiceIndex++;
				}
			}
			else if (data.DataInt.Count > 2)
			{
				voiceIndex = data.DataInt[2];
			}
			string text = ((data2 == null) ? $"Missing scenario index: {num}" : GetMessageText(data2));
			bool is2DVoice = false;
			int num2 = 3;
			if (m_version > 4 && data.DataInt.Count > num2)
			{
				is2DVoice = IntToBool(data.DataInt[num2]);
			}
			return new CommandText(charaID, text, data.DataInt[1], data2.Voice, voiceIndex, is2DVoice);
		}

		private void CheckUnusedTexts()
		{
		}

		private void AddUnusedText(List<int> unusedList)
		{
			int count = unusedList.Count;
			for (int i = 0; i < count; i++)
			{
				ScenarioTableData.Param data = m_textTable.GetData(unusedList[i]);
				if (data != null)
				{
					GameDefine.CharaID chara = GameDefine.CharaID.BASE;
					if (data.Chara != 0 && data.Chara != 100)
					{
						chara = (GameDefine.CharaID)data.Chara;
					}
					CommandText commandText = new CommandText(chara, data.TextJp, unusedList[i], data.Voice);
					m_commandList.Add(commandText);
					_subjectLoadCommand.OnNext(commandText);
				}
			}
		}

		private string GetMessageText(ScenarioTableData.Param textData)
		{
			if (m_isEditor || SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value == GameDefine.Languages.Japanese)
			{
				return textData.TextJp;
			}
			if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value == GameDefine.Languages.Chinese)
			{
				return textData.TextCh;
			}
			if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value == GameDefine.Languages.German)
			{
				return textData.TextGe;
			}
			return textData.TextEg;
		}

		private CommandCharaOn CreateCharaOnCommand(SequenceData.Param data)
		{
			return new CommandCharaOn(data, m_version, m_hasPassesFirstFade);
		}

		private CommandCharaOff CreateCharaOffCommand(SequenceData.Param data)
		{
			return new CommandCharaOff(data, m_version, m_hasPassesFirstFade);
		}

		private List<GameDefine.CharaID> CreateCharaEnableListFromData(SequenceData.Param data, int startIndex)
		{
			List<GameDefine.CharaID> list = new List<GameDefine.CharaID>();
			int count = data.DataInt.Count;
			for (int i = startIndex; i < count; i++)
			{
				list.Add((GameDefine.CharaID)data.DataInt[i]);
			}
			return list;
		}

		private CommandCharaPosition CreateCharaPositionCommand(SequenceData.Param data)
		{
			bool isLockY = true;
			if (data.DataInt.Count > 3)
			{
				isLockY = IntToBool(data.DataInt[3]);
			}
			bool flag = IntToBool(data.DataInt[2]);
			if (m_version == 0)
			{
				flag = !flag;
			}
			if (!m_hasPassesFirstFade)
			{
				flag = false;
			}
			return new CommandCharaPosition((GameDefine.CharaID)data.DataInt[0], new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]), IntToBool(data.DataInt[1]), flag, isLockY);
		}

		private CommandCharaRotation CreateCharaRotationCommand(SequenceData.Param data)
		{
			bool flag = false;
			if (data.DataInt.Count > 2)
			{
				flag = IntToBool(data.DataInt[2]);
			}
			if (m_version == 0)
			{
				flag = !flag;
			}
			if (!m_hasPassesFirstFade)
			{
				flag = false;
			}
			return new CommandCharaRotation((GameDefine.CharaID)data.DataInt[0], new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]), IntToBool(data.DataInt[1]), flag);
		}

		private CommandCharaMotion CreateCharaMotionCommand(SequenceData.Param data)
		{
			int num = 0;
			bool flag = false;
			if (data.DataInt.Count > 3)
			{
				flag = IntToBool(data.DataInt[3]);
			}
			bool flag2 = IntToBool(data.DataInt[2]);
			if (m_version == 0)
			{
				flag = !flag;
				flag2 = !flag2;
			}
			if (!m_hasPassesFirstFade)
			{
				flag2 = false;
			}
			return new CommandCharaMotion((GameDefine.CharaID)data.DataInt[num++], data.DataInt[num++], flag2, flag);
		}

		private CommandCharaFacial CreateCharaFacialCommand(SequenceData.Param data)
		{
			int num = 0;
			bool flag = false;
			if (data.DataInt.Count > 3)
			{
				flag = IntToBool(data.DataInt[3]);
			}
			int version = m_version;
			if (version == 0 || version == 1)
			{
				flag = !flag;
			}
			return new CommandCharaFacial((GameDefine.CharaID)data.DataInt[num++], data.DataInt[num++], IntToBool(data.DataInt[num++]), flag);
		}

		private CommandCharaLookAt CreateCharaLookAtCommand(SequenceData.Param data)
		{
			int num = 0;
			int count = data.DataInt.Count;
			if (count < 3)
			{
				return new CommandCharaLookAt((GameDefine.CharaID)data.DataInt[num++], (GameDefine.CharaID)data.DataInt[num++], isPlayAnimation: false, CommandCharaLookAt.SourceType.Chara);
			}
			bool flag = IntToBool(data.DataInt[2]);
			if (m_version == 0)
			{
				flag = !flag;
			}
			CommandCharaLookAt.SourceType sourceType = CommandCharaLookAt.SourceType.Chara;
			if (count >= 4)
			{
				sourceType = (CommandCharaLookAt.SourceType)data.DataInt[3];
			}
			return sourceType switch
			{
				CommandCharaLookAt.SourceType.Point => new CommandCharaLookAt((GameDefine.CharaID)data.DataInt[num++], flag, new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]), sourceType), 
				CommandCharaLookAt.SourceType.Prop => new CommandCharaLookAt((GameDefine.CharaID)data.DataInt[num++], flag, (PropDefines.PropType)data.DataInt[4], data.DataInt[5], sourceType), 
				CommandCharaLookAt.SourceType.PropNode => new CommandCharaLookAt((GameDefine.CharaID)data.DataInt[num++], flag, (PropDefines.PropType)data.DataInt[4], data.DataInt[5], data.DataInt[6], sourceType), 
				_ => new CommandCharaLookAt((GameDefine.CharaID)data.DataInt[num++], (GameDefine.CharaID)data.DataInt[num++], flag, sourceType), 
			};
		}

		private CommandPlayerPosition CreatePlayerPositionCommand(SequenceData.Param data)
		{
			return new CommandPlayerPosition(new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]));
		}

		private CommandPlayerRotation CreatePlayerRotationCommand(SequenceData.Param data)
		{
			return new CommandPlayerRotation(new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]));
		}

		private CommandChangeScene CreateChangeSceneCommand(SequenceData.Param data)
		{
			return new CommandChangeScene((SceneDefine)data.DataInt[0]);
		}

		private CommandChangeSequence CreateChangeSequenceCommand(SequenceData.Param data)
		{
			return new CommandChangeSequence(data.DataInt[0]);
		}

		private CommandFadeIn CreateFadeInCommand(SequenceData.Param data)
		{
			m_hasPassesFirstFade = true;
			bool isDeactivateOnEnd = false;
			if (data.DataInt.Count >= 1)
			{
				isDeactivateOnEnd = IntToBool(data.DataInt[0]);
			}
			return new CommandFadeIn(new Color(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2], data.DataFloat[3]), new Color(data.DataFloat[4], data.DataFloat[5], data.DataFloat[6], data.DataFloat[7]), data.DataFloat[8], isDeactivateOnEnd);
		}

		private CommandWaitTime CreateWaitTimeCommand(SequenceData.Param data)
		{
			return new CommandWaitTime(data.DataFloat[0]);
		}

		private CommandForcusUpWindow CreateForcusUpCommand(SequenceData.Param data)
		{
			Vector3 scale = Vector3.one;
			if (m_version > 2)
			{
				int num = 4;
				scale = new Vector3(data.DataFloat[num++], data.DataFloat[num++], data.DataFloat[num++]);
			}
			ForcusUpWindowController.SourceType source = ForcusUpWindowController.SourceType.Chara;
			int propsID = -1;
			Vector3 zero = Vector3.zero;
			if (m_version > 3)
			{
				int num2 = 7;
				zero.x = data.DataFloat[num2++];
				zero.y = data.DataFloat[num2++];
				zero.z = data.DataFloat[num2++];
				num2 = 5;
				source = (ForcusUpWindowController.SourceType)data.DataInt[num2++];
				propsID = data.DataInt[num2++];
			}
			return new CommandForcusUpWindow(data.DataInt[0], data.DataInt[1], source, (ForcusUpWindow.FadeType)data.DataInt[2], (GameDefine.CharaID)data.DataInt[3], data.DataFloat[0], new Vector3(data.DataFloat[1], data.DataFloat[2], data.DataFloat[3]), scale, zero, (Ease)data.DataInt[4], propsID);
		}

		private CommandForcusUpOff CreateForcusUpOffCommand(SequenceData.Param data)
		{
			bool isSkip = false;
			if (data.DataInt.Count >= 3)
			{
				isSkip = IntToBool(data.DataInt[2]);
			}
			if (data.DataInt.Count >= 4)
			{
				return new CommandForcusUpOff(data.DataInt[0], (ForcusUpWindow.FadeType)data.DataInt[1], isSkip, (Ease)data.DataInt[3]);
			}
			return new CommandForcusUpOff(data.DataInt[0], (ForcusUpWindow.FadeType)data.DataInt[1], isSkip, Ease.InOutCubic);
		}

		private CommandShakeWindow CreateShakeWindowCommand(SequenceData.Param data)
		{
			return new CommandShakeWindow(data.DataFloat[0]);
		}

		private CommandEmotion CreateEmotionCommand(SequenceData.Param data)
		{
			if (data.DataFloat.Count <= 0)
			{
				return new CommandEmotion((GameDefine.CharaID)data.DataInt[0], (EmotionImage.Types)data.DataInt[1], Vector3Extension.Zero);
			}
			return new CommandEmotion((GameDefine.CharaID)data.DataInt[0], (EmotionImage.Types)data.DataInt[1], new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]));
		}

		private CommandProps CreatePropsCommand(SequenceData.Param data)
		{
			return new CommandProps();
		}

		private CommandPropsOff CreatePropsOffCommand(SequenceData.Param data)
		{
			return new CommandPropsOff();
		}

		private CommandPropsChara CreatePropsCharaCommand(SequenceData.Param data)
		{
			return new CommandPropsChara();
		}

		private CommandPropsCharaOff CreatePropsCharaOffCommand(SequenceData.Param data)
		{
			return new CommandPropsCharaOff();
		}

		private CommandBgm CreateBgmCommand(SequenceData.Param data)
		{
			return new CommandBgm(data);
		}

		private CommandBgmOff CreateBgmOffCommand(SequenceData.Param data)
		{
			return new CommandBgmOff((BgmPlayer.StopMode)data.DataInt[0]);
		}

		private CommandSe2D CreateSe2DCommand(SequenceData.Param data)
		{
			return new CommandSe2D(data.DataInt[0], data.DataFloat[0], IntToBool(data.DataInt[1]));
		}

		private CommandSe2DOff CreateSe2DOffCommand(SequenceData.Param data)
		{
			return new CommandSe2DOff(data.DataInt[0]);
		}

		private CommandSe3D CreateSe3DCommand(SequenceData.Param data)
		{
			return new CommandSe3D(data);
		}

		private CommandSe3DOff CreateSe3DOffCommand(SequenceData.Param data)
		{
			return new CommandSe3DOff(data.DataInt[0]);
		}

		private CommandAmbient CreatePlayAmbientCommand(SequenceData.Param data)
		{
			return new CommandAmbient(data.DataInt[0], data.DataFloat[0], IntToBool(data.DataInt[1]));
		}

		private CommandAmbientOff CreateStopAmbientCommand(SequenceData.Param data)
		{
			return new CommandAmbientOff(data.DataInt[0]);
		}

		private CommandSelection CreateSelectionCommand(SequenceData.Param data)
		{
			m_hasPassesFirstFade = true;
			return new CommandSelection(data, m_version);
		}

		private CommandCharaChange CreateCharaChangeCommand(SequenceData.Param data)
		{
			return new CommandCharaChange((GameDefine.CharaID)data.DataInt[0], data.DataInt[1]);
		}

		private CommandFlashbackStart CreateFlashbackStartCommand(SequenceData.Param data)
		{
			return new CommandFlashbackStart(data);
		}

		private CommandFlashbackEnd CreateFlashbackEndCommand(SequenceData.Param data)
		{
			return new CommandFlashbackEnd();
		}

		private CommandFlashbackChange CreateFlashbackChangeCommand(SequenceData.Param data)
		{
			return new CommandFlashbackChange(data.DataInt[0]);
		}

		private CommandChangeForcusUp CreateChangeForcusUpCommand(SequenceData.Param data)
		{
			return new CommandChangeForcusUp(data.DataInt[0], data.DataInt[1], data.DataFloat[0]);
		}

		private CommandFadeWithoutText CreateFadeWithoutTextCommand(SequenceData.Param data)
		{
			m_hasPassesFirstFade = true;
			return new CommandFadeWithoutText(new Color(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2], data.DataFloat[3]), new Color(data.DataFloat[4], data.DataFloat[5], data.DataFloat[6], data.DataFloat[7]), data.DataFloat[8]);
		}

		private CommandFadeWithoutTextEnd CreateFadeWithoutTextEndCommand(SequenceData.Param data)
		{
			return new CommandFadeWithoutTextEnd(new Color(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2], data.DataFloat[3]), new Color(data.DataFloat[4], data.DataFloat[5], data.DataFloat[6], data.DataFloat[7]), data.DataFloat[8]);
		}

		private CommandCharaAttachPlayer CreateCharaAttachPlayerCommand(SequenceData.Param data)
		{
			if (data.DataFloat.Count <= 0)
			{
				return new CommandCharaAttachPlayer((GameDefine.CharaID)data.DataInt[0]);
			}
			int flags = ((data.DataInt.Count > 1) ? data.DataInt[1] : 0);
			return new CommandCharaAttachPlayer((GameDefine.CharaID)data.DataInt[0], new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]), new Vector3(data.DataFloat[3], data.DataFloat[4], data.DataFloat[5]), flags);
		}

		private CommandCharaDetachPlayer CreateCharaDetachPlayerCommand(SequenceData.Param data)
		{
			return new CommandCharaDetachPlayer((GameDefine.CharaID)data.DataInt[0]);
		}

		private CommandBokeSphere CreateBokeSphereCommand(SequenceData.Param data)
		{
			return new CommandBokeSphere((CommandBokeSphere.Environment)data.DataInt[0], IntToBool(data.DataInt[1]), new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]), data.DataFloat[3]);
		}

		private CommandBokeSphereEnd CreateBokeSphereEndCommand(SequenceData.Param data)
		{
			return new CommandBokeSphereEnd(data);
		}

		private CommandFixWindow CreateFixWindowCommand(SequenceData.Param data)
		{
			return new CommandFixWindow(data);
		}

		private CommandFixWindowEnd CreateFixWindowEndCommand(SequenceData.Param data)
		{
			return new CommandFixWindowEnd();
		}

		private CommandPlayerSetChara CreatePlayerSetCharaCommand(SequenceData.Param data)
		{
			if (data.DataInt.Count <= 1)
			{
				return new CommandPlayerSetChara((GameDefine.CharaID)data.DataInt[0]);
			}
			if (data.DataInt.Count <= 2)
			{
				return new CommandPlayerSetChara((GameDefine.CharaID)data.DataInt[0], IntToBool(data.DataInt[1]));
			}
			if (data.DataInt.Count <= 3)
			{
				return new CommandPlayerSetChara((GameDefine.CharaID)data.DataInt[0], IntToBool(data.DataInt[1]), data.DataInt[2]);
			}
			return new CommandPlayerSetChara((GameDefine.CharaID)data.DataInt[0], IntToBool(data.DataInt[1]), data.DataInt[2], IntToBool(data.DataInt[3]));
		}

		private CommandCharaCircularPosition CreateCharaCircularPositionCommand(SequenceData.Param data)
		{
			bool flag = IntToBool(data.DataInt[1]);
			if (m_version == 0)
			{
				flag = !flag;
			}
			if (!m_hasPassesFirstFade)
			{
				flag = false;
			}
			return new CommandCharaCircularPosition((GameDefine.CharaID)data.DataInt[0], data.DataFloat[0], data.DataFloat[1], flag);
		}

		private CommandBgmChangeLayer CreateBgmChangeLayerCommand(SequenceData.Param data)
		{
			return new CommandBgmChangeLayer((KainePlayer.Layers)data.DataInt[0]);
		}

		private CommandEnvironmentBlendShape CreateEnvironmentBlendShapeCommand(SequenceData.Param data)
		{
			return new CommandEnvironmentBlendShape(data.DataInt[0], data.DataFloat[0]);
		}

		private CommandEnvironmentPropsPosition CreateEnvironmentPropsPositionCommand(SequenceData.Param data)
		{
			return new CommandEnvironmentPropsPosition(data.DataInt[0], new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]));
		}

		private CommandEnvironmentPropsRotation CreateEnvironmentPropsRotationCommand(SequenceData.Param data)
		{
			return new CommandEnvironmentPropsRotation(data.DataInt[0], new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]));
		}

		private CommandEnvironmentPropsOn CreateEnvironmentPropsOnCommand(SequenceData.Param data)
		{
			return new CommandEnvironmentPropsOn(data.DataInt[0], IntToBool(data.DataInt[1]));
		}

		private CommandEnvironmentPropsOff CreateEnvironmentPropsOffCommand(SequenceData.Param data)
		{
			return new CommandEnvironmentPropsOff(data.DataInt[0]);
		}

		private CommandWaitBgmBar CreateWaitBgmBarCommand(SequenceData.Param data)
		{
			return new CommandWaitBgmBar(data.DataInt[0]);
		}

		private CommandLogicIfFlag CreateLogicIfFlagCommand(SequenceData.Param data)
		{
			return new CommandLogicIfFlag(data);
		}

		private CommandLogicElse CreateLogicElseCommand(SequenceData.Param data)
		{
			return new CommandLogicElse(data);
		}

		private CommandLogicEndIf CreateLogicEndIfCommand(SequenceData.Param data)
		{
			return new CommandLogicEndIf(data);
		}

		private CommandSetGameFlag CreateSetGameFlagCommand(SequenceData.Param data)
		{
			return new CommandSetGameFlag(data);
		}

		private CommandWaitBgmEnd CreateWaitBgmEndCommand(SequenceData.Param data)
		{
			return new CommandWaitBgmEnd();
		}

		private CommandCharaRotationReletive CreateCharaRotationReletiveCommand(SequenceData.Param data)
		{
			bool flag = IntToBool(data.DataInt[2]);
			if (m_version == 0)
			{
				flag = !flag;
			}
			if (!m_hasPassesFirstFade)
			{
				flag = false;
			}
			return new CommandCharaRotationReletive((GameDefine.CharaID)data.DataInt[0], new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]), IntToBool(data.DataInt[1]), flag);
		}

		private CommandCharaPositionReletive CreateCharaPositionReletiveCommand(SequenceData.Param data)
		{
			return new CommandCharaPositionReletive((GameDefine.CharaID)data.DataInt[0], new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]), IntToBool(data.DataInt[2]));
		}

		private CommandCharaSetMirrorMode CreateCharaSetMirrorModeCommand(SequenceData.Param data)
		{
			if (data.DataInt.Count <= 2)
			{
				return new CommandCharaSetMirrorMode((GameDefine.CharaID)data.DataInt[0], data.DataInt[1]);
			}
			return new CommandCharaSetMirrorMode((GameDefine.CharaID)data.DataInt[0], data.DataInt[1], IntToBool(data.DataInt[2]));
		}

		private CommandClearColour CreateCameraClearColourCommand(SequenceData.Param data)
		{
			return new CommandClearColour(new Color(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]));
		}

		private CommandBgmSimple CreateBgmSimpleCommand(SequenceData.Param data)
		{
			return new CommandBgmSimple(data.DataInt[0], data.DataFloat[0], data.DataFloat[1]);
		}

		private CommandBgmSimpleOff CreateBgmSimpleOffCommand(SequenceData.Param data)
		{
			return new CommandBgmSimpleOff(data.DataFloat[0]);
		}

		private CommandBgmSimpleVolume CreateBgmSimpleVolumeCommand(SequenceData.Param data)
		{
			return new CommandBgmSimpleVolume(data.DataFloat[0], data.DataFloat[1]);
		}

		private CommandSceneProp CreateScenePropCommand(SequenceData.Param data)
		{
			return new CommandSceneProp(data);
		}

		private CommandScenePropAction CreateScenePropActionCommand(SequenceData.Param data)
		{
			return new CommandScenePropAction(data);
		}

		private CommandEditorNote CreateEditorNoteCommand(SequenceData.Param data)
		{
			if (!IsDebugPlay && !m_isEditor)
			{
				return null;
			}
			return new CommandEditorNote(data.DataString[0]);
		}

		private CommandCharaTransform CreateCharaTransformCommand(SequenceData.Param data)
		{
			int index = 0;
			int intIndex = 0;
			int chara = data.DataInt[intIndex++];
			bool isMove = IntToBool(data.DataInt[intIndex++]);
			bool isRotate = IntToBool(data.DataInt[intIndex++]);
			bool isMotion = IntToBool(data.DataInt[intIndex++]);
			bool isFacial = IntToBool(data.DataInt[intIndex++]);
			bool isFade = IntToBool(data.DataInt[intIndex++]);
			if (!m_hasPassesFirstFade)
			{
				isFade = false;
			}
			CommandCharaTransform commandCharaTransform = new CommandCharaTransform((GameDefine.CharaID)chara, isMove, isRotate, isMotion, isFacial, isFade);
			LoadPosition(data, commandCharaTransform, ref intIndex, ref index);
			LoadRotation(data, commandCharaTransform, ref intIndex, ref index);
			LoadMotion(data, commandCharaTransform, ref intIndex, ref index);
			LoadFacial(data, commandCharaTransform, ref intIndex, ref index);
			return commandCharaTransform;
		}

		private void LoadPosition(SequenceData.Param data, CommandCharaTransform command, ref int intIndex, ref int index)
		{
			if (command.IsMove)
			{
				command.MoveMode = (CommandCharaTransform.MoveType)data.DataInt[intIndex++];
				if (command.MoveMode == CommandCharaTransform.MoveType.Radius)
				{
					command.Angle = data.DataFloat[index++];
					command.Radius = data.DataFloat[index++];
				}
				else
				{
					command.Position = new Vector3(data.DataFloat[index++], data.DataFloat[index++], data.DataFloat[index++]);
					command.IsLockY = IntToBool(data.DataInt[intIndex++]);
				}
			}
		}

		private void LoadRotation(SequenceData.Param data, CommandCharaTransform command, ref int intIndex, ref int index)
		{
			if (command.IsRotate)
			{
				command.RotationMode = (CommandCharaTransform.RotationType)data.DataInt[intIndex++];
				command.Rotation = new Vector3(data.DataFloat[index++], data.DataFloat[index++], data.DataFloat[index++]);
			}
		}

		private void LoadMotion(SequenceData.Param data, CommandCharaTransform command, ref int intIndex, ref int index)
		{
			if (command.IsMotion)
			{
				command.Motion = data.DataInt[intIndex++];
				command.IsPlayAnimationMotion = IntToBool(data.DataInt[intIndex++]);
			}
		}

		private void LoadFacial(SequenceData.Param data, CommandCharaTransform command, ref int intIndex, ref int index)
		{
			if (command.IsFacial)
			{
				command.Facial = data.DataInt[intIndex++];
				command.IsPlayAnimationFace = IntToBool(data.DataInt[intIndex++]);
			}
		}

		private CommandPlayerArmMotion CreatePlayerArmMotionCommand(SequenceData.Param data)
		{
			return new CommandPlayerArmMotion(data.DataInt[0], IntToBool(data.DataInt[1]), IntToBool(data.DataInt[2]));
		}

		private CommandWaitSE CreateWaitSECommand(SequenceData.Param data)
		{
			return new CommandWaitSE();
		}

		private CommandProhibitOpenMenu CreateProhibitOpenMenuCommand(SequenceData.Param data)
		{
			return new CommandProhibitOpenMenu(data);
		}

		private CommandProhibitMenuSelection CreateProhibitMenuSelectionCommand(SequenceData.Param data)
		{
			return new CommandProhibitMenuSelection(data);
		}

		private CommandProhibitMessageSound CreateProhibitMessageSoundCommand(SequenceData.Param data)
		{
			return new CommandProhibitMessageSound(data);
		}

		private CommandSceneToChapterStart CreateSceneToChapterStartCommand(SequenceData.Param data)
		{
			return new CommandSceneToChapterStart(data, m_version);
		}

		private CommandSceneToChapterEnd CreateSceneToChapterEndCommand(SequenceData.Param data)
		{
			return new CommandSceneToChapterEnd(data, m_version);
		}

		private CommandEndInGame CreateEndInGameCommand(SequenceData.Param data)
		{
			return new CommandEndInGame(data);
		}

		private CommandMessageForceMode CreateMessageForceModeCommand(SequenceData.Param data)
		{
			return new CommandMessageForceMode(data);
		}

		private CommandSceneUnload CreateSceneUnloadCommand(SequenceData.Param data)
		{
			return new CommandSceneUnload();
		}

		private CommandMemoryCharaOn CreateMemoryCharaOnCommand(SequenceData.Param data)
		{
			return new CommandMemoryCharaOn(data, m_version, m_hasPassesFirstFade);
		}

		private CommandEnableTypingSound CreateEnableTypingSoundCommand(SequenceData.Param data)
		{
			return new CommandEnableTypingSound(data);
		}

		private CommandMemoryCharaOff CreateMemoryCharaOffCommand(SequenceData.Param data)
		{
			return new CommandMemoryCharaOff(data, m_version, m_hasPassesFirstFade);
		}

		private CommandMemoryCharaTransform CreateMemoryCharaTransformCommand(SequenceData.Param data)
		{
			return new CommandMemoryCharaTransform(data, m_version, m_hasPassesFirstFade);
		}

		private CommandMemoryModeStart CreateMemoryModeStartCommand(SequenceData.Param data)
		{
			return new CommandMemoryModeStart(data, m_version);
		}

		private CommandMemoryModeEnd CreateMemoryModeEndCommand(SequenceData.Param data)
		{
			return new CommandMemoryModeEnd(data, m_version);
		}

		private CommandMemoryEmotion CreateMemoryEmotionCommand(SequenceData.Param data)
		{
			return new CommandMemoryEmotion((GameDefine.CharaID)data.DataInt[0], (EmotionImage.Types)data.DataInt[1], new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]));
		}

		private CommandMemoryAmbient CreateMemoryAmbientCommand(SequenceData.Param data)
		{
			return new CommandMemoryAmbient(data.DataInt[0], data.DataFloat[0], data.DataFloat[1]);
		}

		private CommandMemoryAmbientOff CreateMemoryAmbientOffCommand(SequenceData.Param data)
		{
			return new CommandMemoryAmbientOff(data, m_version);
		}

		private CommandMemoryAmbientVolume CreateMemoryAmbientVolumeCommand(SequenceData.Param data)
		{
			return new CommandMemoryAmbientVolume(data, m_version);
		}

		private CommandPlayerAvaterTrack CreatePlayerAvaterTrackCommand(SequenceData.Param data)
		{
			return new CommandPlayerAvaterTrack(data, m_version);
		}

		private CommandSceneToOpening CreateSceneToOpeningCommand(SequenceData.Param data)
		{
			return new CommandSceneToOpening(data, m_version);
		}

		private CommandSceneToSpecial CreateSceneToSpecialCommand(SequenceData.Param data)
		{
			return new CommandSceneToSpecial(data, m_version);
		}

		private CommandWaitTimeline CreateWaitTimelineCommand(SequenceData.Param data)
		{
			return new CommandWaitTimeline(data, m_version);
		}

		private CommandNoAnimationLimit CreateNoAnimationLimitCommand(SequenceData.Param data)
		{
			return new CommandNoAnimationLimit(data, m_version);
		}

		private CommandCharaOutlineChange CreateCharaOutlineChangeCommand(SequenceData.Param data)
		{
			return new CommandCharaOutlineChange(data, m_version);
		}

		private CommandWindowThroughEffect CreateWindowThroughEffectCommand(SequenceData.Param data)
		{
			return new CommandWindowThroughEffect(data, m_version);
		}

		private CommandCpuGpuLevel CreateCpuGpuLevelCommand(SequenceData.Param data)
		{
			return new CommandCpuGpuLevel(data, m_version);
		}

		private CommandStartCutscene CreateStartCutsceneCommand(SequenceData.Param data)
		{
			return new CommandStartCutscene(data, m_version);
		}

		private CommandBackgroundActive CreateBackgroundActiveCommand(SequenceData.Param data)
		{
			return new CommandBackgroundActive(data, m_version);
		}

		private CommandCharaStyleChange CreateCharaStyleChangeCommand(SequenceData.Param data)
		{
			return new CommandCharaStyleChange(data, m_version);
		}

		private CommandPlayerAvaterVisible CreatePlayerAvaterVisibleCommand(SequenceData.Param data)
		{
			return new CommandPlayerAvaterVisible(data, m_version);
		}

		private CommandAutoWaitOverride CreateAutoWaitOverrideCommand(SequenceData.Param data)
		{
			return new CommandAutoWaitOverride(data, m_version);
		}

		private CommandAvaterOutline CreateAvaterOutlineCommand(SequenceData.Param data)
		{
			return new CommandAvaterOutline(data, m_version);
		}

		private CommandCharaTexture CreateCharaTextureCommand(SequenceData.Param data)
		{
			return new CommandCharaTexture(data, m_version);
		}

		private CommandPlayAreaBoundary CreatePlayAreaBoundaryCommand(SequenceData.Param data)
		{
			return new CommandPlayAreaBoundary(data, m_version);
		}

		private CommandAvaterTexture CreateAvaterTextureCommand(SequenceData.Param data)
		{
			return new CommandAvaterTexture(data, m_version);
		}

		private CommandScenePropOutline CreateScenePropOutlineCommand(SequenceData.Param data)
		{
			return new CommandScenePropOutline(data, m_version);
		}

		private CommandMenuFixMode CreateMenuFixModeCommand(SequenceData.Param data)
		{
			return new CommandMenuFixMode(data, m_version);
		}

		private CommandProhibitHeightChange CreateProhibitHeightChangeCommand(SequenceData.Param data)
		{
			return new CommandProhibitHeightChange(data);
		}
	}
	public class SequencePreSetupper
	{
		private TimelineDataReader m_dataReader;

		public SequencePreSetupper(TimelineDataReader reader)
		{
			m_dataReader = reader;
		}

		public void PreloadAudioData()
		{
			List<CommandSe2D> seCommandList = m_dataReader.SeCommandList;
			int count = seCommandList.Count;
			for (int i = 0; i < count; i++)
			{
				if (!(seCommandList[i].Clip != null))
				{
					seCommandList[i].Clip = SoundManager.SE.FindClip(seCommandList[i].ID);
				}
			}
		}
	}
	public static class SpecialSceneHelper
	{
		public static void EndSpecialScene()
		{
			if (!SingletonMonoBehaviour<InGameManager>.HasInstance)
			{
				SingletonMonoBehaviour<MasterManager>.Instance.ExitInGame();
			}
			else
			{
				InGameManager.Timeline.EndSpecialScene();
			}
		}
	}
	public class TimelineDataReader
	{
		private const int _START_INDEX = -1;

		private SequenceTable m_sequenceTable;

		private ScenarioTextTable m_scenarioTextTable;

		private List<ISequenceCommand> m_commandList;

		private List<CommandText> m_textMessageList = new List<CommandText>();

		private Dictionary<ISequenceCommand.PreloadTypes, List<int>> m_generalPreloadList;

		private Dictionary<ISequenceCommand.PreloadTypes, List<ISoundCommand>> m_soundPreloadList;

		private GameDefine.CharaID m_playerChara = GameDefine.CharaID.BASE;

		private List<CommandSe2D> m_seCommandList;

		private ISoundCommand m_firstBgm;

		public int ScenarioID { get; private set; }

		public int CurrentIndex { get; private set; }

		public bool IsInitialized { get; set; }

		public bool HasMemoryMode { get; private set; }

		public ISequenceCommand CurrentCommand => m_commandList[CurrentIndex];

		public List<ISequenceCommand> CommandList => m_commandList;

		public List<CommandText> TextMessageList => m_textMessageList;

		public List<CommandSe2D> SeCommandList => m_seCommandList;

		public List<GameDefine.CharaID> InitialTalkChara { get; private set; }

		public ISoundCommand FirstBgmCommand => m_firstBgm;

		public bool IsOverflowed => CurrentIndex >= m_commandList.Count;

		public GameDefine.CharaID PlayerChara => m_playerChara;

		public TimelineDataReader()
		{
			IsInitialized = false;
			HasMemoryMode = false;
			m_firstBgm = null;
			m_scenarioTextTable = new ScenarioTextTable();
			m_sequenceTable = new SequenceTable();
			InitialTalkChara = new List<GameDefine.CharaID>();
			m_generalPreloadList = new Dictionary<ISequenceCommand.PreloadTypes, List<int>>();
			m_soundPreloadList = new Dictionary<ISequenceCommand.PreloadTypes, List<ISoundCommand>>();
			m_seCommandList = new List<CommandSe2D>();
			ResetCurrentIndex();
		}

		public void ResetCurrentIndex()
		{
			CurrentIndex = -1;
		}

		public void Clear()
		{
			HasMemoryMode = false;
			m_firstBgm = null;
			m_scenarioTextTable.Clear();
			m_sequenceTable.Clear();
			if (m_commandList != null)
			{
				m_commandList.Clear();
			}
			if (m_textMessageList != null)
			{
				m_textMessageList.Clear();
			}
			if (m_seCommandList != null)
			{
				m_seCommandList.Clear();
			}
			InitialTalkChara.Clear();
			m_generalPreloadList.Clear();
			m_soundPreloadList.Clear();
			ResetCurrentIndex();
		}

		public void IncrementIndex()
		{
			CurrentIndex++;
		}

		public void LoadScenrario(int id)
		{
			Clear();
			ScenarioID = id;
			m_scenarioTextTable.Load(id);
			m_sequenceTable.Load(id);
			if (!m_scenarioTextTable.isValid)
			{
				throw new NotFoundScenarioException(id);
			}
			if (!m_sequenceTable.isValid)
			{
				throw new NotFoundSequenceException(id);
			}
			SequenceDataConverter sequenceDataConverter = new SequenceDataConverter(m_scenarioTextTable, m_sequenceTable);
			IObservable<CommandText> source = sequenceDataConverter.OnLoadCommand.OfType<ISequenceCommand, CommandText>().Share();
			source.Where((CommandText command) => GetIsNeedToAddInitialTalk(command)).Take(2).Subscribe(delegate(CommandText command)
			{
				AddTalkCharaList(command);
			});
			source.Subscribe(delegate(CommandText command)
			{
				m_textMessageList.Add(command);
			});
			sequenceDataConverter.OnLoadCommand.Where((ISequenceCommand command) => command.IsNeedPreload).Subscribe(delegate(ISequenceCommand command)
			{
				OnLoadPreloadCommand(command);
			});
			sequenceDataConverter.OnLoadCommand.Where((ISequenceCommand command) => command.Type == ISequenceCommand.Types.SetPlayerChara).Take(1).Subscribe(delegate(ISequenceCommand command)
			{
				OnLoadFirstPlayerChara(command);
			});
			try
			{
				m_commandList = sequenceDataConverter.Convert();
			}
			catch (Exception)
			{
				throw;
			}
			IsInitialized = true;
			sequenceDataConverter = null;
			GC.Collect();
		}

		private void OnLoadPreloadCommand(ISequenceCommand command)
		{
			int preloadIndex = command.PreloadIndex;
			if (preloadIndex <= -1)
			{
				return;
			}
			switch (command.PreloadType)
			{
			case ISequenceCommand.PreloadTypes.BgmSimple:
			case ISequenceCommand.PreloadTypes.BgmAdvanced:
			case ISequenceCommand.PreloadTypes.SoundEffect:
			case ISequenceCommand.PreloadTypes.AmbientEffect:
			{
				if (!m_soundPreloadList.TryGetValue(command.PreloadType, out var value2))
				{
					value2 = new List<ISoundCommand>();
				}
				if (value2.Find((ISoundCommand scmd) => scmd.ID == preloadIndex) == null)
				{
					value2.Add(command as ISoundCommand);
					m_soundPreloadList[command.PreloadType] = value2;
				}
				if (command.PreloadType == ISequenceCommand.PreloadTypes.SoundEffect)
				{
					m_seCommandList.Add(command as CommandSe2D);
				}
				else if (command.PreloadType == ISequenceCommand.PreloadTypes.BgmAdvanced && m_firstBgm == null)
				{
					m_firstBgm = command as ISoundCommand;
				}
				break;
			}
			case ISequenceCommand.PreloadTypes.MemoryModeStart:
				HasMemoryMode = true;
				break;
			case ISequenceCommand.PreloadTypes.MemoryChara:
			{
				List<int> list = null;
				if (!m_generalPreloadList.TryGetValue(command.PreloadType, out list))
				{
					list = new List<int>();
				}
				(command as CommandMemoryCharaOn).CharaList.ForEach(delegate(GameDefine.CharaID id)
				{
					if (!list.Contains((int)id))
					{
						list.Add((int)id);
					}
				});
				m_generalPreloadList[command.PreloadType] = list;
				break;
			}
			default:
			{
				if (!m_generalPreloadList.TryGetValue(command.PreloadType, out var value))
				{
					value = new List<int>();
				}
				if (!value.Contains(preloadIndex))
				{
					value.Add(preloadIndex);
					m_generalPreloadList[command.PreloadType] = value;
				}
				break;
			}
			case ISequenceCommand.PreloadTypes.None:
				break;
			}
		}

		public List<int> GetGeneralPreloadList(ISequenceCommand.PreloadTypes type)
		{
			if (!m_generalPreloadList.TryGetValue(type, out var value))
			{
				return null;
			}
			return value;
		}

		public List<ISoundCommand> GetPreloadBgmAdvancedList()
		{
			if (!m_soundPreloadList.TryGetValue(ISequenceCommand.PreloadTypes.BgmAdvanced, out var value))
			{
				return null;
			}
			return value;
		}

		public List<ISoundCommand> GetPreloadBgmSimpleList()
		{
			if (!m_soundPreloadList.TryGetValue(ISequenceCommand.PreloadTypes.BgmSimple, out var value))
			{
				return null;
			}
			return value;
		}

		public List<ISoundCommand> GetPreloadSeList()
		{
			if (!m_soundPreloadList.TryGetValue(ISequenceCommand.PreloadTypes.SoundEffect, out var value))
			{
				return null;
			}
			return value;
		}

		public List<ISoundCommand> GetPreloadAmbientList()
		{
			if (!m_soundPreloadList.TryGetValue(ISequenceCommand.PreloadTypes.AmbientEffect, out var value))
			{
				return null;
			}
			return value;
		}

		private void OnLoadFirstPlayerChara(ISequenceCommand command)
		{
			m_playerChara = (command as CommandPlayerSetChara).Chara;
		}

		private void AddTalkCharaList(CommandText command)
		{
			InitialTalkChara.Add(command.Chara);
		}

		private bool GetIsNeedToAddInitialTalk(CommandText command)
		{
			if (command.Chara == m_playerChara || command.Chara == GameDefine.CharaID.BASE || InitialTalkChara.Contains(command.Chara))
			{
				return false;
			}
			return true;
		}
	}
	public class TimelinePlayer : UpdateableComponent
	{
		public enum WaitMode
		{
			None,
			Infinity,
			Time,
			Loading,
			AfterLoad,
			HardSkip,
			SpecialScene,
			Emergency,
			Exit
		}

		private const SceneDefine INITIAL_SCENE = SceneDefine.AdvBoot;

		private WaitMode m_wait;

		[Header("External Components")]
		[SerializeField]
		private MessagePlayer m_messagePlayer;

		[SerializeField]
		private EmotionImageGenerator m_emotions;

		[SerializeField]
		private ForcusUpWindowController m_forcusUpWindow;

		[SerializeField]
		private FlashbackRoot m_flashbackRoot;

		[SerializeField]
		private SelectionController m_selectionController;

		private int _scenarioToLoad = -1;

		private SceneDefine m_initialScene;

		private TimelineDataReader m_dataReader;

		private SequencePreSetupper m_preSetupper;

		private AdvBackground m_background;

		private AdvCutScene m_cutScene;

		private TimelineInput m_playerInput;

		private MoverFadeSequencer m_moverFader;

		private BokeSphereManager m_bokeSphere;

		private ISequenceCommand m_waitingCommand;

		private LinkedList<BaseLogicCommand> m_commandLogicStacks = new LinkedList<BaseLogicCommand>();

		private ScenarioListData.Info _currentInfo;

		private Subject<int> _subjectScenarioCompleted = new Subject<int>();

		private Subject<TimelineDataReader> _subjectPreloadRequested = new Subject<TimelineDataReader>();

		private bool IsScenarioLoaded
		{
			get
			{
				if (m_dataReader != null)
				{
					return m_dataReader.IsInitialized;
				}
				return false;
			}
		}

		private bool IsScenarioReserved => _scenarioToLoad != -1;

		private bool IsWaitingCommand => m_waitingCommand != null;

		private bool IsWaitingSceneLoad { get; set; }

		private bool IsReservedAutoSave { get; set; }

		public IObservable<int> OnScenarioCompleted => _subjectScenarioCompleted;

		public IObservable<TimelineDataReader> PreloadRequestedObservable => _subjectPreloadRequested;

		public bool IsWaiting
		{
			get
			{
				if (IsScenarioLoaded && !IsScenarioReserved && m_wait == WaitMode.None && !IsWaitingSceneLoad)
				{
					return IsWaitingCommand;
				}
				return true;
			}
		}

		public bool IsScenarioSkippable
		{
			get
			{
				if (_currentInfo == null)
				{
					return false;
				}
				if (!SingletonMonoBehaviour<GameData>.Instance.GetFlag(GameFlags.EndingNormal))
				{
					return false;
				}
				switch (_currentInfo.SkipMode)
				{
				case ScenarioListData.SkipModes.Normal:
					return SingletonMonoBehaviour<GameData>.Instance.SystemData.IsScenarioReaded(SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID);
				case ScenarioListData.SkipModes.Related:
					if (!SingletonMonoBehaviour<GameData>.Instance.SystemData.IsScenarioReaded(SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID))
					{
						return SingletonMonoBehaviour<GameData>.Instance.SystemData.IsScenarioReaded(RelatedScenarioID);
					}
					return true;
				case ScenarioListData.SkipModes.Flag:
					if (!SingletonMonoBehaviour<GameData>.Instance.SystemData.IsScenarioReaded(SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID))
					{
						return SingletonMonoBehaviour<GameData>.Instance.SystemData.GetFlag(_currentInfo.FlagToSkip);
					}
					return true;
				case ScenarioListData.SkipModes.Always:
					return true;
				default:
					return false;
				}
			}
		}

		public bool IsSkipAllowed => m_messagePlayer.GetCanToggleModeTo(MessagePlayer.PlayModes.Skip);

		public bool IsSkipMode => MessageProcessor.IsSkipMode;

		public bool IsHardSkip => m_wait == WaitMode.HardSkip;

		public bool IsMemoryMode => MemoryModeProcessor.IsPlaying;

		public bool HasPlayedFirstFade { get; set; }

		public Transform MainPositionTransform => MainPosition.MainTransform;

		public UIFader Fader => SingletonMonoBehaviour<FadeManager>.Instance.sceneFader;

		public MoverFadeSequencer MoverFader => m_moverFader;

		public MessagePlayer MessageProcessor => m_messagePlayer;

		public EmotionImageGenerator EmotionProcessor => m_emotions;

		public ForcusUpWindowController FocusUpProcessor => m_forcusUpWindow;

		public FlashbackRoot FlashbackProcessor => m_flashbackRoot;

		public BokeSphereManager BokeSphereProcessor => m_bokeSphere;

		public SelectionController SelectionProcessor => m_selectionController;

		public AdvBackground CurrentBackground => m_background;

		public AdvCutScene CurrentCutScene => m_cutScene;

		public MemoryModeManager MemoryModeProcessor { get; private set; }

		public int LoadedScenarioID
		{
			get
			{
				if (!IsScenarioLoaded)
				{
					return -1;
				}
				return m_dataReader.ScenarioID;
			}
		}

		public int RelatedScenarioID
		{
			get
			{
				if (_currentInfo == null)
				{
					return -1;
				}
				return _currentInfo.RelatedSqid;
			}
		}

		public int SequenceCurrentIndex
		{
			get
			{
				if (!IsScenarioLoaded)
				{
					return -1;
				}
				return m_dataReader.CurrentIndex;
			}
		}

		public WaitMode LegacyWait => m_wait;

		public ISequenceCommand WaitingCommand => m_waitingCommand;

		protected override void Initialize()
		{
			GC.Collect();
			Resources.UnloadUnusedAssets();
			HasPlayedFirstFade = false;
			m_bokeSphere = new BokeSphereManager();
			m_wait = WaitMode.None;
			m_dataReader = new TimelineDataReader();
			m_preSetupper = new SequencePreSetupper(m_dataReader);
			m_playerInput = GetComponent<TimelineInput>();
			FindFlashback();
			m_moverFader = new MoverFadeSequencer(SingletonMonoBehaviour<FadeManager>.Instance.sceneFader, MainPosition.MainCamera, Color.black);
			MemoryModeProcessor = new MemoryModeManager(this);
			MakeSubscribes();
		}

		private void FindFlashback()
		{
			if (m_flashbackRoot == null)
			{
				m_flashbackRoot = UnityEngine.Object.FindObjectOfType<FlashbackRoot>();
			}
		}

		private void FindBackground()
		{
			m_background = UnityEngine.Object.FindObjectOfType<AdvBackground>();
			if (m_background != null)
			{
				SingletonMonoBehaviour<CharactersManager>.Instance.SetCharaTextures(m_background.CharaTextureSettings);
				MainPosition.Avater.AvaterResources.SetTextureSetting(m_background.CharaTextureSettings);
			}
		}

		private void StopBackgroundAmbient()
		{
			if (m_background != null && m_background.HasAudioSource)
			{
				m_background.Audio.Stop();
			}
		}

		private void FindCutScene()
		{
			m_cutScene = UnityEngine.Object.FindObjectOfType<AdvCutScene>();
			if (m_cutScene != null)
			{
				m_cutScene.ForwardCommandObservable.Where((Unit _) => IsWaitingCommand && m_waitingCommand.Type == ISequenceCommand.Types.WaitTimeline).Subscribe(delegate
				{
					ReleaseCommandWait();
				}).AddTo(base.gameObject);
			}
		}

		public void ForceFindCutScene()
		{
			FindCutScene();
		}

		private void MakeSubscribes()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeExitFade.Subscribe(delegate
			{
				m_wait = WaitMode.Emergency;
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeStartInGame.Subscribe(delegate
			{
				ClearScenarioRelations();
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeEndInGame.Subscribe(delegate
			{
				ClearInGameObjects();
			}).AddTo(base.gameObject);
			m_messagePlayer.OnMessagePaged.Subscribe(delegate
			{
				ReleaseCommandWait();
			}).AddTo(base.gameObject);
			OnScenarioCompleted.Subscribe(delegate(int id)
			{
				SingletonMonoBehaviour<GameData>.Instance.SystemData.AddReadFlag(id);
			}).AddTo(base.gameObject);
		}

		public override void OnUpdate(float delta)
		{
			if (m_wait == WaitMode.Loading)
			{
				UpdateLoading();
				return;
			}
			if (SingletonMonoBehaviour<MasterManager>.Instance.IsBusy || !SingletonMonoBehaviour<InGameManager>.Instance.IsReady || m_wait == WaitMode.Emergency)
			{
				UpdateEmergency();
				return;
			}
			try
			{
				m_playerInput.UpdateInputModeChange();
				if (IsWaitingCommand && m_waitingCommand.UpdateCommand(this, delta))
				{
					ReleaseCommandWait();
				}
				while (!IsWaiting)
				{
					NextPage();
				}
				if (IsScenarioReserved)
				{
					LoadReservedScenario();
				}
			}
			catch (Exception e)
			{
				EmergencyStop(e);
				throw;
			}
		}

		public void UpdateMessageInput()
		{
			m_playerInput.UpdateMessageInput();
		}

		public void UpdateWaitInput()
		{
			if (SingletonMonoBehaviour<GameInputManager>.Instance.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.MainAction))
			{
				ReleaseCommandWait();
			}
		}

		private void UpdateLoading()
		{
			if (!SingletonMonoBehaviour<SoundManager>.Instance.IsLoading && !m_forcusUpWindow.IsLoading && !m_flashbackRoot.IsLoading && !MemoryModeProcessor.IsLoading && !m_bokeSphere.IsLoading && !SingletonMonoBehaviour<TransitionManager>.Instance.IsSceneReservedAndLoading(m_initialScene))
			{
				if (IsWaitingSceneLoad)
				{
					ReleaseSceneWait();
				}
				else
				{
					OnScenarioLoadComplete();
				}
			}
		}

		private void UpdateEmergency()
		{
			if (IsScenarioReserved)
			{
				try
				{
					LoadReservedScenario();
				}
				catch (Exception e)
				{
					EmergencyStop(e);
					throw;
				}
			}
		}

		private void NextPage()
		{
			m_dataReader.IncrementIndex();
			CheckSkipMode();
			SetupCurrentPage();
		}

		private void CheckSkipMode()
		{
			if (IsSkipMode && SingletonMonoBehaviour<LocalData>.Instance.SkipDestinationIndex != -1 && m_dataReader.CurrentIndex >= SingletonMonoBehaviour<LocalData>.Instance.SkipDestinationIndex)
			{
				EndSkipMode();
			}
		}

		private void EndSkipMode()
		{
			SingletonMonoBehaviour<LocalData>.Instance.SkipDestinationIndex = -1;
			m_messagePlayer.ResetPlayMode();
		}

		public void SetupCurrentPage()
		{
			if (m_dataReader.IsOverflowed)
			{
				throw new SequenceOverflowException();
			}
			ISequenceCommand currentCommand = m_dataReader.CurrentCommand;
			if ((currentCommand.IsLogic || IsLastLogicTrue()) && !currentCommand.PlayCommand(this))
			{
				m_waitingCommand = currentCommand;
				m_waitingCommand.OnStart(this);
			}
		}

		public void StartHardSkip()
		{
			if (IsHardSkip)
			{
				return;
			}
			m_wait = WaitMode.HardSkip;
			float num = 0.5f;
			SingletonMonoBehaviour<SoundManager>.Instance.StopAll(BgmPlayer.StopMode.Fade, num);
			if (m_background != null && m_background.HasAudioSource)
			{
				m_background.Audio.StopWithFade(num);
			}
			AnalyticsUtility.SendSkipEvent();
			if (CurrentCutScene != null)
			{
				CurrentCutScene.DisposeTimeline();
			}
			Fader.Dispose();
			Fader.StartFade(ColorDefine.Black, num, isDeactivateOnEnd: false, delegate
			{
				Observable.NextFrame().Subscribe(delegate
				{
					HardSkipSequence();
				});
			});
		}

		private void HardSkipSequence()
		{
			while (IsHardSkip)
			{
				m_dataReader.IncrementIndex();
				if (m_dataReader.IsOverflowed)
				{
					throw new SequenceOverflowException();
				}
				ISequenceCommand currentCommand = m_dataReader.CurrentCommand;
				if ((currentCommand.IsLogic || (IsLastLogicTrue() && currentCommand.PlayInHardSkip)) && !currentCommand.PlayCommand(this))
				{
					m_waitingCommand = currentCommand;
					m_waitingCommand.OnStart(this);
					if (IsHardSkip)
					{
						ReleaseLegacyWait();
					}
				}
			}
		}

		public void ReleaseCommandWait()
		{
			if (m_waitingCommand != null)
			{
				ISequenceCommand waitingCommand = m_waitingCommand;
				m_waitingCommand = null;
				waitingCommand.OnEnd(this);
			}
		}

		public void ReleaseLegacyWait()
		{
			if (m_wait != 0)
			{
				m_wait = WaitMode.None;
			}
		}

		public void StartLegacyWait(float duration)
		{
			m_wait = WaitMode.Time;
			Observable.Timer(TimeSpan.FromSeconds(duration)).Subscribe(delegate
			{
				ReleaseLegacyWait();
			}).AddTo(base.gameObject);
		}

		public void StartInfinityWait()
		{
			m_wait = WaitMode.Infinity;
		}

		public void PrepareOnFirstFade()
		{
			if (!HasPlayedFirstFade)
			{
				SingletonMonoBehaviour<CharactersManager>.Instance.OnPrepareFistFade(m_dataReader.InitialTalkChara, IsMemoryMode);
				HasPlayedFirstFade = true;
			}
		}

		private void ClearLogicStack()
		{
			m_commandLogicStacks.Clear();
		}

		public void AddLogicStack(BaseLogicCommand command)
		{
			m_commandLogicStacks.AddLast(command);
		}

		public bool RemoveLastLogicStack()
		{
			if (m_commandLogicStacks.Last == null)
			{
				EmergencyStop("IFELSEENDIF");
				return true;
			}
			bool isLogicTrue = m_commandLogicStacks.Last.Value.IsLogicTrue;
			m_commandLogicStacks.RemoveLast();
			return isLogicTrue;
		}

		public bool IsLastLogicTrue()
		{
			if (m_commandLogicStacks.Last == null)
			{
				return true;
			}
			return m_commandLogicStacks.Last.Value.IsLogicTrue;
		}

		public void ReserveLoadScenerioWithComplete(int id)
		{
			CompleteScenario();
			ReserveLoadScenerio(id);
		}

		public void CompleteScenario()
		{
			_subjectScenarioCompleted.OnNext(SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID);
			if (SingletonMonoBehaviour<LocalData>.Instance.IsOmitNextAutoSave)
			{
				SingletonMonoBehaviour<LocalData>.Instance.IsOmitNextAutoSave = false;
			}
			else
			{
				ReserveAutoSave();
			}
		}

		public void ReserveLoadScenerio(int id)
		{
			if (!IsScenarioReserved)
			{
				OnScenarioReserved();
			}
			SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID = id;
			_scenarioToLoad = id;
		}

		private void OnScenarioReserved()
		{
			SoundManager.Voice.StopCurrentVoice();
		}

		public void ResolveReservedAutoSave()
		{
			if (IsReservedAutoSave)
			{
				IsReservedAutoSave = false;
				SingletonMonoBehaviour<MasterManager>.Instance.AutoSave();
			}
		}

		private void LoadReservedScenario()
		{
			int nextSqid = _scenarioToLoad;
			_scenarioToLoad = -1;
			SingletonMonoBehaviour<MasterManager>.Instance.AddBusy(this);
			Observable.NextFrame().Subscribe(delegate
			{
				try
				{
					ResolveReservedAutoSave();
					if (IsScenarioLoaded)
					{
						ClearScenarioRelations();
					}
					m_dataReader.LoadScenrario(nextSqid);
					if (!IsScenarioLoaded)
					{
						EmergencyStop($" {nextSqid:00000} ");
					}
					else
					{
						OnLoadScenario();
					}
				}
				catch (Exception e)
				{
					EmergencyStop(e);
					throw;
				}
			}).AddTo(base.gameObject);
		}

		private void ClearScenarioRelations()
		{
			ReleaseLegacyWait();
			ReleaseCommandWait();
			ClearLogicStack();
			if (m_background != null)
			{
				m_background.ClearScenarioRelations();
				m_background = null;
			}
			m_messagePlayer.ClearScenarioRelations();
			m_forcusUpWindow.CloseAll(isSkip: true);
			m_forcusUpWindow.Clear();
			m_flashbackRoot.OnScenarioEnd();
			m_bokeSphere.Clear();
			MemoryModeProcessor.OnScenarioEnd();
			SingletonMonoBehaviour<CharactersManager>.Instance.OnEndSequence();
			SingletonMonoBehaviour<MainPosition>.Instance.ClearScenarioRelations();
			SingletonMonoBehaviour<SoundManager>.Instance.StopSimpleBgm();
			SoundManager.SE.Stop();
			SoundManager.SE.StopAll3D();
			DisposeFades();
			HasPlayedFirstFade = false;
		}

		private void DisposeFades()
		{
			if (MoverFader.IsPlaying)
			{
				MoverFader.Reset();
			}
			if (SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.IsFading)
			{
				SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.Dispose();
			}
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.SetColour(ColorDefine.Black);
			SingletonMonoBehaviour<PlayAreaManager>.Instance.SetClearColor(ColorDefine.Black);
			SingletonMonoBehaviour<PlayAreaManager>.Instance.ResetBoundaryRange();
		}

		private void OnLoadScenario()
		{
			m_wait = WaitMode.Loading;
			_currentInfo = SingletonMonoBehaviour<DataManager>.Instance.GeneralData.GetScenarioInfo(m_dataReader.ScenarioID);
			ValidateMode();
			PreloadScenarioAssets();
			SingletonMonoBehaviour<CharactersManager>.Instance.SetAnimationLimitation(isLimit: false);
			if (IsSkipMode)
			{
				m_messagePlayer.ResetPlayMode();
			}
		}

		private void ValidateMode()
		{
			if (MemoryModeProcessor.IsPlaying && !m_dataReader.HasMemoryMode)
			{
				MemoryModeProcessor.End();
			}
		}

		private void PreloadScenarioAssets()
		{
			SoundManager.SE.LoadAllSE(m_dataReader.GetPreloadSeList());
			SoundManager.Voice.LoadAllVoices(m_dataReader.ScenarioID, m_dataReader.TextMessageList, m_dataReader.PlayerChara, m_dataReader.HasMemoryMode);
			SoundManager.Bgm.Load(m_dataReader.GetPreloadBgmAdvancedList(), m_dataReader.GetPreloadBgmSimpleList(), m_dataReader.FirstBgmCommand);
			m_forcusUpWindow.LoadAllTextures(m_dataReader.GetGeneralPreloadList(ISequenceCommand.PreloadTypes.FocusUp));
			m_flashbackRoot.LoadAllTextures(m_dataReader.GetGeneralPreloadList(ISequenceCommand.PreloadTypes.FlashBack));
			m_bokeSphere.LoadAll(m_dataReader.GetGeneralPreloadList(ISequenceCommand.PreloadTypes.BokeSphere));
			MemoryModeProcessor.Load(m_dataReader.GetGeneralPreloadList(ISequenceCommand.PreloadTypes.MemoryChara));
			List<int> generalPreloadList = m_dataReader.GetGeneralPreloadList(ISequenceCommand.PreloadTypes.UnityScene);
			m_initialScene = ((generalPreloadList != null && generalPreloadList.Count > 0) ? ((SceneDefine)generalPreloadList[0]) : SceneDefine.Blank);
			SingletonMonoBehaviour<TransitionManager>.Instance.ReserveSceneFromList(generalPreloadList);
			_subjectPreloadRequested.OnNext(m_dataReader);
		}

		private void PreloadSceneProps()
		{
			if (m_background != null)
			{
				m_background.ProcessPreloadProps(PropDefines.PropType.Static, m_dataReader.GetGeneralPreloadList(ISequenceCommand.PreloadTypes.PropStatic));
				m_background.ProcessPreloadProps(PropDefines.PropType.Dynamic, m_dataReader.GetGeneralPreloadList(ISequenceCommand.PreloadTypes.PropDynamic));
			}
		}

		private void OnScenarioLoadComplete()
		{
			m_wait = WaitMode.AfterLoad;
			ResetPlayerPosition();
			SingletonMonoBehaviour<SoundManager>.Instance.PrepareFirstBgm();
			GC.Collect();
			Resources.UnloadUnusedAssets();
			(from _ in Observable.NextFrame()
				where m_wait == WaitMode.AfterLoad
				select _).Subscribe(delegate
			{
				ReleaseLegacyWait();
				SingletonMonoBehaviour<MasterManager>.Instance.RemoveBusy(this);
				SingletonMonoBehaviour<MainMenuManager>.Instance.ResetProhibitions();
				Fader.StartFade(Color.black, 0f, isDeactivateOnEnd: false);
			}).AddTo(base.gameObject);
		}

		private void ResetPlayerPosition()
		{
			MainPositionTransform.localPosition = GameDefine.PLAYER_DEFAULT_POSITION;
		}

		private void ReserveAutoSave()
		{
			IsReservedAutoSave = true;
		}

		public void ChangeScene(SceneDefine nextScene)
		{
			IsWaitingSceneLoad = true;
			SingletonMonoBehaviour<TransitionManager>.Instance.ChangeActiveSceneAsync(nextScene, OnSceneLoaded);
		}

		private void OnSceneLoaded()
		{
			FindBackground();
			FindCutScene();
			PreloadSceneProps();
			m_preSetupper.PreloadAudioData();
			if (!SingletonMonoBehaviour<SoundManager>.Instance.IsLoading)
			{
				ReleaseSceneWait();
			}
			else
			{
				m_wait = WaitMode.Loading;
			}
		}

		private void ReleaseSceneWait()
		{
			IsWaitingSceneLoad = false;
			ReleaseLegacyWait();
			ReleaseCommandWait();
			GC.Collect();
			Resources.UnloadUnusedAssets();
		}

		public void ChangeSceneToSpecial(SceneDefine scene)
		{
			IsWaitingSceneLoad = true;
			SingletonMonoBehaviour<TransitionManager>.Instance.ChangeActiveSceneAsync(scene, OnSpecialSceneLoaded);
		}

		private void OnSpecialSceneLoaded()
		{
			FindBackground();
			FindCutScene();
			m_wait = WaitMode.SpecialScene;
			IsWaitingSceneLoad = false;
			m_messagePlayer.ClearScenarioRelations();
			SingletonMonoBehaviour<CharactersManager>.Instance.OnEndSequence();
			DisposeFades();
		}

		public void EndSpecialScene()
		{
			if (m_wait == WaitMode.SpecialScene)
			{
				ReleaseCommandWait();
			}
		}

		public void QuitToTitle()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.ExitInGame();
		}

		public void EndDemo()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.ExitInGame(SceneDefine.EndProto);
		}

		public void QuitApplication()
		{
			UnityEngine.Application.Quit();
		}

		private void ClearInGameObjects()
		{
			if (m_wait != WaitMode.Exit)
			{
				m_wait = WaitMode.Exit;
				ClearScenarioRelations();
				SingletonMonoBehaviour<SoundManager>.Instance.ClearAllExceptBgm();
			}
		}

		private void EmergencyStop()
		{
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.SetColour(new Color(1f, 0f, 0f, 0.5f));
			SingletonMonoBehaviour<SoundManager>.Instance.StopAll();
			m_wait = WaitMode.Emergency;
			_scenarioToLoad = -1;
		}

		public void EmergencyStop(string message)
		{
			EmergencyStop();
		}

		public void EmergencyStop(Exception e)
		{
			EmergencyStop($"{e.GetType()} \n{e.Message}");
		}
	}
	public class MessageIndigaterComponents : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private SpriteRenderer _spriteAutoPlay;

		private bool _visibleAll = true;

		private bool _visibleAutoplay;

		public void ToggleEnabled(bool flag)
		{
			_visibleAll = flag;
			UpdateVisibility();
		}

		public void ToggleVisibleAutoPlay(bool flag)
		{
			_visibleAutoplay = flag;
			UpdateVisibility();
		}

		private void UpdateVisibility()
		{
			_spriteAutoPlay.enabled = _visibleAll && _visibleAutoplay;
		}
	}
	public class MessageWindow : MonoBehaviour
	{
		private const float MAX_TIME_THROUGH_EFFECT = 1f;

		public MessageWindowData data;

		[Header("Components")]
		[SerializeField]
		private Transform contentsTransform;

		[SerializeField]
		private MessageWindowText messageText;

		[SerializeField]
		private MessageWindowText nameText;

		[SerializeField]
		private MessageWindowWaitIcon waitIcon;

		[SerializeField]
		private MessageWindowWave[] waves;

		[SerializeField]
		private MessageWindowSkin skin;

		private MessageWindowController _parent;

		private Common.Timer _shakeTimer = new Common.Timer(0f);

		private bool _isVisible = true;

		private bool _isMonorogue;

		private bool _isThroughEffect;

		private float _timeSinceThrough;

		private bool isDataAvailable
		{
			get
			{
				if (data != null)
				{
					return data.enabled;
				}
				return false;
			}
		}

		private bool isShake => !_shakeTimer.IsTimeUp;

		private float windowGlobalAlpha
		{
			get
			{
				if (_parent == null)
				{
					return 1f;
				}
				return _parent.windowGlobalAlpha;
			}
		}

		private bool IsEmitSoundOnMessage
		{
			get
			{
				if (_parent != null)
				{
					return _parent.IsEmitSoundOnMessage;
				}
				return false;
			}
		}

		private AudioSource MessageAudioSource => _parent.MessageAudioSource;

		public bool IsSkipMode => _parent.IsSkipMode;

		public bool IsTextAllVisible => messageText.IsAllVisible;

		public MessageWindowText MessageText => messageText;

		public void SetController(MessageWindowController mane)
		{
			_parent = mane;
		}

		private void Start()
		{
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			IObservable<Unit> source = SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable.Where((Unit _) => base.enabled).Share();
			source.Where((Unit _) => !_isMonorogue).Subscribe(delegate
			{
				UpdateWaves();
			}).AddTo(base.gameObject);
			source.Where((Unit _) => isShake).Subscribe(delegate
			{
				ProcessLegacyShake(Time.deltaTime);
			}).AddTo(base.gameObject);
			source.Where((Unit _) => _isThroughEffect).ThrottleFirst(TimeSpan.FromSeconds(0.05)).Subscribe(delegate
			{
				ProcessThroughShake(0.05f);
			})
				.AddTo(base.gameObject);
			source.Where((Unit _) => isDataAvailable).Subscribe(delegate
			{
				data.UpdateWindowPosition();
			}).AddTo(base.gameObject);
			source.Where((Unit _) => skin.IsNeedUpdate).Subscribe(delegate
			{
				skin.UpdateAll();
			}).AddTo(base.gameObject);
			messageText.OnBeforeFadeDelay.Subscribe(delegate
			{
				ToggleWaitingIcon(flag: false);
			}).AddTo(base.gameObject);
			messageText.OnStartFade.Where((Unit _) => data.IsMonologue && IsEmitSoundOnMessage).Subscribe(delegate
			{
				SoundManager.SE.PlaySystemLoop(SoundDefine.SystemSE.Message_TypeLoop, MessageAudioSource);
			}).AddTo(base.gameObject);
			messageText.OnEndFade.Subscribe(delegate
			{
				ToggleWaitingIcon(flag: true);
			}).AddTo(base.gameObject);
			messageText.OnEndFade.Where((Unit _) => data.IsMonologue && IsEmitSoundOnMessage).Subscribe(delegate
			{
				SoundManager.SE.StopSystemLoop(MessageAudioSource);
				SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Message_TypeEnd, MessageAudioSource);
			}).AddTo(base.gameObject);
		}

		private void OnEnable()
		{
			if (_isVisible)
			{
				contentsTransform.gameObject.SetActive(value: true);
			}
		}

		private void OnDisable()
		{
			contentsTransform.gameObject.SetActive(value: false);
		}

		public void InstantActivate()
		{
			SetVisible(flag: true);
		}

		private void SetVisible(bool flag)
		{
			if (_isVisible != flag)
			{
				_isVisible = flag;
				contentsTransform.gameObject.SetActive(_isVisible);
			}
		}

		public void SetMessageText(string text)
		{
			messageText.SetText(text);
			ToggleWaitingIcon(flag: false);
		}

		public void SetNameText(string text)
		{
			nameText.SetText(text);
		}

		public void SetLineLength(float numByJp)
		{
			messageText.SetLineLength(numByJp);
		}

		public void SetLineLengthDiff(float diffByJp)
		{
			messageText.SetLineLengthDiff(diffByJp);
		}

		public void SetTextSpeed(int toggleValue)
		{
			messageText.SetTextSpeed(toggleValue);
		}

		public void ToggleMonorogue(bool flag)
		{
			if (_isMonorogue != flag)
			{
				_isMonorogue = flag;
				if (_isMonorogue)
				{
					nameText.gameObject.SetActive(value: false);
					messageText.ToggleCentering(flag: true);
					skin.ToggleSkinVisible(flag: false);
				}
				else
				{
					nameText.gameObject.SetActive(value: true);
					messageText.ToggleCentering(flag: false);
					skin.ToggleSkinVisible(flag: true);
				}
			}
		}

		public void ToggleWaitingIcon(bool flag)
		{
			waitIcon.gameObject.SetActive(flag);
			if (flag)
			{
				waitIcon.SetPosition(messageText.LastCharacterPosition);
			}
		}

		private void OnEndMessageShowing()
		{
			ToggleWaitingIcon(flag: true);
		}

		private void UpdateWaves()
		{
			for (int i = 0; i < waves.Length; i++)
			{
				MessageWindowWave messageWindowWave = waves[i];
				messageWindowWave.UpdateScale();
				if (isDataAvailable)
				{
					messageWindowWave.WaveByTarget(data.GetWaveTarget());
				}
			}
		}

		public void SetMessageAlpga(float alpha)
		{
			if (alpha <= 0.01f)
			{
				SetVisible(flag: false);
				return;
			}
			float num = alpha * windowGlobalAlpha;
			SetVisible(flag: true);
			skin.SetMessageAlpha(num);
			waitIcon.SetAlpha(num);
		}

		public void SetSkinColor(Color skinColor)
		{
			skin.SetSkinColor(skinColor);
		}

		private void ProcessLegacyShake(float timeDelta)
		{
			Vector3 zero = Vector3.zero;
			Vector3 one = Vector3.one;
			_shakeTimer.Update(timeDelta);
			if (isShake)
			{
				zero.x = RandomPow4() * 0.2f;
				zero.y = RandomPow4() * 0.2f;
			}
			contentsTransform.localPosition = zero;
			contentsTransform.localScale = one;
		}

		private void ProcessThroughShake(float timeDelta)
		{
			Vector3 zero = Vector3.zero;
			Vector3 one = Vector3.one;
			if (Time.time > _timeSinceThrough + 1f)
			{
				_isThroughEffect = false;
			}
			else
			{
				float num = (Time.time - _timeSinceThrough) / 1f;
				float num2 = 1f - num;
				float num3 = 0.1f * num2;
				float num4 = 0.4f * num2;
				zero.x = RandomPow4() * num3;
				zero.y = RandomPow4() * num3;
				zero.z = -0.1f * num2 * num2;
				one += new Vector3(RandomPow4() * num4, RandomPow4() * num4, 0f);
				if (num <= 0.6f)
				{
					SetMessageAlpga(0.5f);
				}
				else
				{
					SetMessageAlpga(1f);
				}
			}
			contentsTransform.localPosition = zero;
			contentsTransform.localScale = one;
		}

		private float RandomPow4()
		{
			return (UnityEngine.Random.Range(0f, 1f) + UnityEngine.Random.Range(0f, 1f) + UnityEngine.Random.Range(0f, 1f) + UnityEngine.Random.Range(0f, 1f)) / 4f - 0.5f;
		}

		public void StartShake(float time = 1f)
		{
			_shakeTimer.SetDuration(time);
			SingletonMonoBehaviour<GameInputManager>.Instance.Vibrate(VRDeviceDefine.HandType.Both, time, 1f);
		}

		public void StartShakeOnFade(float time = 1f)
		{
			messageText.OnStartFade.Merge(messageText.OnEndFade).Take(1).Subscribe(delegate
			{
				StartShake(time);
			})
				.AddTo(base.gameObject);
		}

		public void StartTextFade(float delay)
		{
			messageText.StartFade(delay);
		}

		public void InstantShow()
		{
			messageText.SetTextVisible(flag: true);
		}

		public void StartThroughEffect()
		{
			_isThroughEffect = true;
			_timeSinceThrough = Time.time;
		}
	}
	public class MessageWindowController : UpdateableComponent
	{
		private enum FadeMode
		{
			FadeOutEnd = -10,
			FadeOut = -1,
			NoFade = 0,
			FadeIn = 1
		}

		private const int NUM_RESERVE_WINDOWS = 3;

		private const int MAX_SHOW_WINDOWS = 2;

		private const float FADE_DURATION = 0.2f;

		[Header("Prefabs")]
		[SerializeField]
		[PrefabField]
		private MessageWindow prefabTextWindow;

		[Header("Components")]
		[SerializeField]
		private AudioSource messageAudioSource;

		[Header("Parameters")]
		[SerializeField]
		private float delayMessageShow = 0.25f;

		[SerializeField]
		private float heightConfigChange = 0.125f;

		[SerializeField]
		private float heightChangeTime = 0.2f;

		private Transform _thisTransform;

		private MessagePlayer _messagePlayer;

		private List<MessageWindow> m_objectWindows;

		private List<MessageWindow> m_usedWindows;

		private MessageWindow m_lastTextWindow;

		private FadeMode _fadeMode;

		private float _timeSinceFadeStart = -999f;

		private Vector3 _defaultPosition;

		private float _viewHeight;

		private bool m_isEmitSoundOnMessage;

		private Coroutine _crHeightChange;

		private ReactiveProperty<bool> _prohibitHeightChange = new ReactiveProperty<bool>(initialValue: false);

		private ConfigSave ConfigData => SingletonMonoBehaviour<GameData>.Instance.ConfigData;

		public float windowGlobalAlpha { get; private set; }

		public bool IsSkipMode
		{
			get
			{
				if (_messagePlayer != null)
				{
					return _messagePlayer.IsSkipMode;
				}
				return false;
			}
		}

		public bool IsEmitSoundOnMessage
		{
			get
			{
				return m_isEmitSoundOnMessage;
			}
			set
			{
				m_isEmitSoundOnMessage = value;
			}
		}

		public AudioSource MessageAudioSource => messageAudioSource;

		public bool IsAutoWaitOverrided => _messagePlayer.IsAutoWaitOverrided;

		public int MessageSpeedOverride => _messagePlayer.MessageSpeedOverride;

		public bool ProhibitHeightChange
		{
			get
			{
				return _prohibitHeightChange.Value;
			}
			set
			{
				_prohibitHeightChange.Value = value;
			}
		}

		public int CurrentMessageSpeed
		{
			get
			{
				if (!IsAutoWaitOverrided)
				{
					return ConfigData.MessageSpeed.Value;
				}
				return MessageSpeedOverride;
			}
		}

		protected override void Initialize()
		{
			_thisTransform = base.transform;
			m_objectWindows = new List<MessageWindow>();
			m_usedWindows = new List<MessageWindow>();
			windowGlobalAlpha = 1f;
			InitDefaultHeight();
			MakeWindowInstances();
			MakeSubscribes();
		}

		public void SetPlayer(MessagePlayer player)
		{
			_messagePlayer = player;
		}

		private void InitDefaultHeight()
		{
			_defaultPosition = _thisTransform.localPosition;
		}

		private void MakeWindowInstances()
		{
			if (m_objectWindows.Count < 3)
			{
				for (int i = m_objectWindows.Count; i < 3; i++)
				{
					MakwNewWindow();
				}
			}
		}

		private void MakeSubscribes()
		{
			_prohibitHeightChange.Subscribe(delegate(bool flag)
			{
				if (flag)
				{
					OnChangeMessageHeight(0);
				}
				else
				{
					OnChangeMessageHeight(ConfigData.MessageHeight.Value);
				}
			});
			_messagePlayer.RemoveInterfaceReactive.Where((bool flag) => flag).Subscribe(delegate
			{
				StartFadeOut();
			}).AddTo(base.gameObject);
			_messagePlayer.RemoveInterfaceReactive.Where((bool flag) => !flag).Subscribe(delegate
			{
				StartFadeIn();
			}).AddTo(base.gameObject);
			ConfigData.MessageHeight.Where((int _) => !_prohibitHeightChange.Value).Subscribe(delegate(int height)
			{
				OnChangeMessageHeight(height);
			}).AddTo(base.gameObject);
			ConfigData.MessageSpeed.Where((int _) => !IsAutoWaitOverrided).Subscribe(delegate(int height)
			{
				ChangeMessageSpeed(height);
			}).AddTo(base.gameObject);
		}

		private void OnChangeMessageHeight(int height)
		{
			if (_crHeightChange != null)
			{
				StopCoroutine(_crHeightChange);
				_crHeightChange = null;
			}
			_crHeightChange = StartCoroutine(ProcessHeightAnimation(_viewHeight, height));
		}

		private IEnumerator ProcessHeightAnimation(float from, float to)
		{
			Tweener<float> tweener = new Tweener<float>(Easing.EaseOutCubic);
			tweener.Start(from, to, heightChangeTime);
			while (tweener.IsActive)
			{
				yield return new WaitForEndOfFrame();
				tweener.Update(Time.deltaTime);
				SetWindowPosition(tweener.CurrentValue);
			}
		}

		private void SetWindowPosition(float height)
		{
			_viewHeight = height;
			_thisTransform.localPosition = _defaultPosition + new Vector3(0f, heightConfigChange * _viewHeight, 0f);
		}

		private void ChangeMessageSpeed(int speed)
		{
			if (m_lastTextWindow != null)
			{
				m_lastTextWindow.SetTextSpeed(speed);
				m_lastTextWindow.StartTextFade(0f);
			}
		}

		public override void OnUpdate(float delta)
		{
			UpdateFade();
		}

		private void UpdateFade()
		{
			if (_fadeMode == FadeMode.NoFade)
			{
				return;
			}
			float num = Time.time - _timeSinceFadeStart;
			if (num >= 0.2f)
			{
				StopFade();
				return;
			}
			float num2 = num / 0.2f;
			switch (_fadeMode)
			{
			case FadeMode.FadeIn:
				windowGlobalAlpha = num2;
				break;
			case FadeMode.FadeOut:
				windowGlobalAlpha = 1f - num2;
				break;
			}
		}

		private MessageWindow MakwNewWindow()
		{
			MessageWindow messageWindow = UnityEngine.Object.Instantiate(prefabTextWindow, _thisTransform);
			messageWindow.enabled = false;
			messageWindow.SetController(this);
			m_objectWindows.Add(messageWindow);
			return messageWindow;
		}

		private MessageWindow FindEmptyWindow()
		{
			for (int i = 0; i < m_objectWindows.Count; i++)
			{
				MessageWindow messageWindow = m_objectWindows[i];
				if (!messageWindow.enabled)
				{
					return messageWindow;
				}
			}
			return MakwNewWindow();
		}

		private void PageNextWindow()
		{
			for (int i = 0; i < m_usedWindows.Count; i++)
			{
				MessageWindow messageWindow = m_usedWindows[i];
				MessageWindowData data = messageWindow.data;
				int num = data.GetOrder() + 1;
				if (num > 3)
				{
					messageWindow.enabled = false;
					m_usedWindows.RemoveAt(i);
					i--;
				}
				else
				{
					data.SetOrder(num);
				}
			}
		}

		private void CreateNewWindow(CommandText data)
		{
			MessageWindow messageWindow = FindEmptyWindow();
			MessageWindowData data2 = messageWindow.data;
			data2.InitWindowByData(data);
			messageWindow.SetTextSpeed(CurrentMessageSpeed);
			if (IsSkipMode)
			{
				data2.SetPositionToOrder(1);
				data2.SetOrder(1);
				data2.PlayVoice();
				messageWindow.InstantShow();
				messageWindow.ToggleWaitingIcon(flag: true);
			}
			else
			{
				data2.SetPositionToOrder(0);
				messageWindow.StartTextFade(delayMessageShow);
				data2.SetOrder(1);
				data2.PlayVoice();
			}
			m_lastTextWindow = messageWindow;
			m_usedWindows.Add(messageWindow);
			messageWindow.enabled = true;
		}

		public void FlushWindows()
		{
			foreach (MessageWindow usedWindow in m_usedWindows)
			{
				usedWindow.enabled = false;
			}
			m_usedWindows.Clear();
		}

		public void NewTextMessage(CommandText data)
		{
			CreateNewWindow(data);
		}

		public void OnNextPageInput()
		{
			HideWaitingIcon();
			PageNextWindow();
		}

		public bool IsLastWindowAllVisible()
		{
			if (!m_lastTextWindow)
			{
				return true;
			}
			return m_lastTextWindow.IsTextAllVisible;
		}

		public void ShowLastWindowAllText()
		{
			if ((bool)m_lastTextWindow)
			{
				m_lastTextWindow.InstantShow();
			}
		}

		public void ShakeLastWindow(float duration)
		{
			if ((bool)m_lastTextWindow)
			{
				m_lastTextWindow.StartShakeOnFade(duration);
			}
		}

		public void StartThroughEffect()
		{
			if ((bool)m_lastTextWindow)
			{
				m_lastTextWindow.StartThroughEffect();
			}
		}

		public void HideWaitingIcon()
		{
			if ((bool)m_lastTextWindow)
			{
				m_lastTextWindow.ToggleWaitingIcon(flag: false);
			}
		}

		public void StopFade()
		{
			switch (_fadeMode)
			{
			case FadeMode.FadeIn:
				windowGlobalAlpha = 1f;
				break;
			case FadeMode.FadeOut:
				windowGlobalAlpha = 0f;
				break;
			}
			_fadeMode = FadeMode.NoFade;
		}

		public void StartFadeIn()
		{
			if (!_messagePlayer.IsRemoveInterface)
			{
				_fadeMode = FadeMode.FadeIn;
				_timeSinceFadeStart = Time.time;
				windowGlobalAlpha = 0f;
			}
		}

		public void StartFadeOut()
		{
			_fadeMode = FadeMode.FadeOut;
			_timeSinceFadeStart = Time.time;
		}

		public void SetLineLength(float numByJp)
		{
			for (int i = 0; i < m_objectWindows.Count; i++)
			{
				m_objectWindows[i].SetLineLength(numByJp);
			}
		}

		public void ClearScenarioRelations()
		{
			_prohibitHeightChange.Value = false;
		}
	}
	public class MessageWindowData : MonoBehaviour
	{
		[Header("Parameters")]
		[SerializeField]
		private float fadeSpeed = 10f;

		[SerializeField]
		private float alphaMultiply = 0.9f;

		private Transform _thisTransform;

		private Transform _parentTransform;

		private MessageWindow _message;

		private CommandText _textData;

		private Data_Character.Param _charaData;

		private IChara _charaObject;

		private int _messageOrder;

		private float _fadeOrder;

		private Vector3 _originPos;

		private bool _isOriginGlobal;

		private Transform _originTrans;

		public bool IsMonologue
		{
			get
			{
				if (_textData != null)
				{
					return _textData.IsMonologue;
				}
				return true;
			}
		}

		private bool IsSkipMode => _message.IsSkipMode;

		private void Awake()
		{
			_thisTransform = GetComponent<Transform>();
			_message = GetComponent<MessageWindow>();
		}

		private void Start()
		{
			_parentTransform = _thisTransform.parent;
			base.enabled = false;
		}

		public void InitWindowByData(CommandText data)
		{
			_textData = data;
			_charaData = data.FindCharacterData();
			_charaObject = data.FindCharacter();
			_message.SetMessageText(_textData.Text);
			_message.SetNameText(_textData.CharaFullName);
			_message.ToggleMonorogue(_textData.IsMonologue);
			if (_charaData != null && !data.IsMonologue)
			{
				_message.SetSkinColor(_charaData.colorBackground.WithAlpha(alphaMultiply));
			}
			if (_textData.IsMonologue)
			{
				SetOriginPosition(new Vector3(0f, -1f, 0f), isGlobal: false);
			}
			else if (_charaObject == null || data.CharaType == SingletonMonoBehaviour<LocalData>.Instance.CurrentCharaID)
			{
				Transform messagePivot = MainPosition.Avater.MessagePivot;
				SetOriginTransform(messagePivot);
			}
			else
			{
				Transform head = _charaObject.Head;
				SetOriginTransform(head);
			}
			_message.ToggleWaitingIcon(flag: false);
			base.enabled = true;
		}

		public void UpdateWindowPosition()
		{
			float num = (float)_messageOrder - _fadeOrder;
			if (!Mathf.Approximately(0f, num))
			{
				float num2 = Time.deltaTime * fadeSpeed;
				if (IsSkipMode)
				{
					_fadeOrder = _messageOrder;
				}
				else
				{
					_fadeOrder += num * num2;
				}
				_thisTransform.localPosition = GetFadePosition();
				_message.SetMessageAlpga(GetFadeAlpha());
			}
		}

		private Vector3 GetFadePosition()
		{
			float fadeOrder = _fadeOrder;
			if (fadeOrder < 1f)
			{
				float num = Mathf.Clamp(fadeOrder, 0f, 1f);
				Vector3 vector = new Vector3(0f, 0f, 0f);
				Vector3 vector2 = ((_originTrans != null) ? _parentTransform.InverseTransformPoint(_originTrans.position) : ((!_isOriginGlobal) ? _originPos : _parentTransform.InverseTransformPoint(_originPos)));
				return vector2 * (1f - num) + vector * num;
			}
			return new Vector3(0f, (fadeOrder - 1f) * -0.6f, (fadeOrder - 1f) * -0.6f);
		}

		private float GetFadeAlpha()
		{
			float fadeOrder = _fadeOrder;
			if (fadeOrder < 1f)
			{
				return fadeOrder;
			}
			return 1f - (fadeOrder - 1f);
		}

		public void SetPositionToOrder()
		{
			_fadeOrder = _messageOrder;
			_thisTransform.localPosition = GetFadePosition();
			_message.SetMessageAlpga(GetFadeAlpha());
		}

		public void SetPositionToOrder(int order)
		{
			_messageOrder = order;
			SetPositionToOrder();
		}

		public void SetOrder(int o)
		{
			_messageOrder = o;
		}

		public int GetOrder()
		{
			return _messageOrder;
		}

		private void SetOriginPosition(Vector3 pos, bool isGlobal)
		{
			_originPos = pos;
			_isOriginGlobal = isGlobal;
			_originTrans = null;
		}

		private void SetOriginTransform(Transform trans)
		{
			_originTrans = trans;
		}

		public Transform GetWaveTarget()
		{
			if (_charaObject != null)
			{
				if (_charaObject.ID == SingletonMonoBehaviour<LocalData>.Instance.CurrentCharaID)
				{
					return _thisTransform;
				}
				if (_charaObject.Transform != null)
				{
					return _charaObject.Transform;
				}
				return _thisTransform;
			}
			return _thisTransform;
		}

		public void PlayVoice()
		{
			if (_textData.Chara != GameDefine.CharaID.BASE)
			{
				SoundManager.Voice.PlayVoiceByData(_textData);
			}
		}

		public void StopVoice()
		{
		}
	}
	public class MessageWindowSkin : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private TextMeshPro messageText;

		[SerializeField]
		private SpriteRenderer[] skinSprites;

		[SerializeField]
		private TextMeshPro[] skinTexts;

		private bool _isSkinDirty;

		private Color _messageColor = Color.white;

		private float _messageAlpha = 1f;

		private Color _skinColor = Color.white;

		public bool IsNeedUpdate => _isSkinDirty;

		public void UpdateAll()
		{
			if (_isSkinDirty)
			{
				UpdateMessageColor();
				UpdateSkinColor();
				_isSkinDirty = false;
			}
		}

		private void UpdateMessageColor()
		{
			Color messageColor = _messageColor;
			messageColor.a *= _messageAlpha;
			messageText.color = messageColor;
		}

		private void UpdateSkinColor()
		{
			Color skinColor = _skinColor;
			skinColor.a *= _messageAlpha;
			for (int i = 0; i < skinSprites.Length; i++)
			{
				skinSprites[i].color = skinColor;
			}
			for (int j = 0; j < skinTexts.Length; j++)
			{
				skinTexts[j].color = skinColor;
			}
		}

		private float GetRisanAlpha(float alpha, int parts)
		{
			return Mathf.Round(alpha * (float)parts) / (float)parts;
		}

		public void SetMessageAlpha(float alpha)
		{
			alpha = Mathf.Clamp01(GetRisanAlpha(alpha, 8));
			_isSkinDirty = _isSkinDirty || _messageAlpha != alpha;
			_messageAlpha = alpha;
		}

		public void SetSkinColor(Color color)
		{
			_skinColor = color;
			_isSkinDirty = true;
		}

		public void ToggleSkinVisible(bool flag)
		{
			for (int i = 0; i < skinSprites.Length; i++)
			{
				skinSprites[i].gameObject.SetActive(flag);
			}
			for (int j = 0; j < skinTexts.Length; j++)
			{
				skinTexts[j].gameObject.SetActive(flag);
			}
		}
	}
	public class MessageWindowText : MonoBehaviour
	{
		[Header("Parameters")]
		[SerializeField]
		private float defaultMessageLength = -1f;

		[SerializeField]
		private float defaultWaitTime = 0.03f;

		[SerializeField]
		private float difftimePerToggle = 0.009f;

		[SerializeField]
		private string dummyCharacter = "";

		private Vector2 _defaultSize;

		private RectTransform _thisTransform;

		private TextMeshPro _textComponent;

		private TextProFader _fader;

		public IObservable<Unit> OnBeforeFadeDelay => _fader.OnBeforeFadeDelay;

		public IObservable<Unit> OnStartFade => _fader.OnStartFade;

		public IObservable<Unit> OnEndFade => _fader.OnEndFade;

		public Vector3 LastCharacterPosition => _fader.LastCharacterPosition;

		public bool IsAllVisible
		{
			get
			{
				if (HasFader)
				{
					return _fader.IsFinishedFade;
				}
				return true;
			}
		}

		private bool HasFader => _fader != null;

		private void Awake()
		{
			_thisTransform = GetComponent<RectTransform>();
			_textComponent = GetComponent<TextMeshPro>();
			_fader = GetComponent<TextProFader>();
			_defaultSize = _thisTransform.sizeDelta;
			if (HasFader)
			{
				_fader.omitLastNum = 1;
			}
		}

		public void SetText(string str)
		{
			if (HasFader)
			{
				str += dummyCharacter;
			}
			_textComponent.text = str;
		}

		public void SetTextVisible(bool flag)
		{
			if (HasFader)
			{
				_fader.ToggleAllText(flag);
			}
		}

		public void StartFade(float delay)
		{
			if (HasFader)
			{
				_fader.StartFade(delay);
			}
		}

		public void SetLineLength(float numByJp)
		{
			if (!(defaultMessageLength <= 0f))
			{
				float num = _defaultSize.x / defaultMessageLength;
				Vector2 defaultSize = _defaultSize;
				defaultSize.x = num * numByJp;
				_thisTransform.sizeDelta = defaultSize;
			}
		}

		public void SetLineLengthDiff(float diffByJp)
		{
			if (!(defaultMessageLength <= 0f))
			{
				SetLineLength(defaultMessageLength + diffByJp);
			}
		}

		public void ToggleCentering(bool flag)
		{
			_textComponent.alignment = TextAlignmentOptions.Top;
		}

		public void SetTextSpeed(int toggleValue)
		{
			_fader.waitTime = defaultWaitTime - difftimePerToggle * (float)toggleValue;
		}
	}
	public class MessageWindowWaitIcon : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private SpriteRenderer _sprite;

		[Header("Parameter")]
		[SerializeField]
		private Vector3 offset = new Vector3(0.055f, 0.045f, 0f);

		private Transform _thisTrans;

		private Animator _thisAnimator;

		private void Awake()
		{
			_thisTrans = base.transform;
			_thisAnimator = GetComponent<Animator>();
		}

		private void OnEnable()
		{
			_thisAnimator.enabled = true;
			_thisAnimator.Play(0);
		}

		private void OnDisable()
		{
			_thisAnimator.enabled = false;
		}

		public void SetPosition(Vector3 pos)
		{
			if (!(_thisTrans == null))
			{
				_thisTrans.localPosition = pos + offset;
			}
		}

		public void SetAlpha(float alpha)
		{
			_sprite.color = _sprite.color.WithAlpha(alpha);
		}
	}
	public class MessageWindowWave : MonoBehaviour
	{
		private const float THRESHOULD_ANGLE_SCALE = 30f;

		[SerializeField]
		private bool isLeft;

		private Transform thisTrans;

		private float _scaleBase = 1f;

		private float _scaleAngle = 1f;

		private bool _wayIsLeft = true;

		private void Awake()
		{
			thisTrans = base.transform;
		}

		public void UpdateScale()
		{
			Vector3 localScale = thisTrans.localScale;
			float y = _scaleBase * _scaleAngle;
			localScale.y = y;
			thisTrans.localScale = localScale;
		}

		public void ChangeWaveSize(float length)
		{
			_scaleBase = length;
		}

		public void WaveByTarget(Transform target)
		{
			if (!(target == null))
			{
				Vector3 position = MainPosition.CameraTransform.position;
				Vector3 to = thisTrans.position - position;
				Vector3 from = target.position - position;
				to.y = (from.y = 0f);
				float num = Vector3.SignedAngle(from, to, Vector3.up);
				float num2 = Mathf.Abs(num);
				bool flag = num <= 0f;
				if (_wayIsLeft != flag)
				{
					_wayIsLeft = flag;
					thisTrans.localEulerAngles = new Vector3(0f, (!_wayIsLeft) ? 180 : 0, 0f);
				}
				if (isLeft)
				{
					_scaleAngle = ((0f - num <= 30f) ? 1f : (15f / (15f + num2 - 30f)));
				}
				else
				{
					_scaleAngle = ((num <= 30f) ? 1f : (15f / (15f + num2 - 30f)));
				}
			}
		}
	}
	public class SpriteScroller : UpdateableComponent
	{
		[SerializeField]
		private SpriteRenderer thisRenderer;

		[SerializeField]
		private Vector2 scrollSpeed = new Vector2(1f, 0f);

		[SerializeField]
		private Vector2 scrollSize = new Vector2(1f, 1f);

		private Transform _thisTransform;

		private Vector2 _texPos = new Vector2(0f, 0f);

		private void Awake()
		{
			_thisTransform = base.transform;
		}

		public override void OnUpdate(float deltaTime)
		{
			Vector2 vector = scrollSpeed * deltaTime;
			_texPos.x = Mathf.Repeat(_texPos.x + vector.x, 1f);
			_texPos.y = Mathf.Repeat(_texPos.y + vector.y, 1f);
			Vector3 localPosition = new Vector3(_texPos.x * scrollSize.x - scrollSize.x / 2f, _texPos.y * scrollSize.y, 0f);
			_thisTransform.localPosition = localPosition;
		}
	}
	public class FlashbackImage : MonoBehaviour
	{
		private const string _PARAM_COLOUR = "Color";

		private Material m_material;

		private Tweener<float> m_alphaTween;

		private void Start()
		{
			m_material = GetComponent<Renderer>().material;
		}

		public void SetSprite(Texture sp)
		{
			m_material.mainTexture = sp;
		}

		public void Clear()
		{
			m_material.mainTexture = null;
		}
	}
	public class FlashbackRoot : MonoBehaviour
	{
		public class Data<T>
		{
			public int ID;

			public T Content;

			public Data(int id, T content)
			{
				ID = id;
				Content = content;
			}
		}

		private const string FILE_PATH = "{0}{1:D4}";

		[Header("Components")]
		[SerializeField]
		private ForcusUpWindow m_imageWindow;

		[Header("Parameters - Image")]
		[SerializeField]
		private float m_imageFadeDuration = 0.15f;

		[Header("Parameters - Fog")]
		[SerializeField]
		private float m_fogFadeDuration = 1f;

		[SerializeField]
		private float m_fogEndFadeDuration = 3f;

		[SerializeField]
		private float m_fogStartDistance;

		[SerializeField]
		private float m_fogEndDistance = 1000f;

		[SerializeField]
		private float m_fogDistanceOnEnd = 40000f;

		[SerializeField]
		private Color m_fogColour = Color.black;

		[SerializeField]
		private FogMode m_fogMode = FogMode.Linear;

		private GameObject m_gameObject;

		private Transform m_transform;

		private Transform m_playerRoot;

		private List<Data<Texture>> m_textures = new List<Data<Texture>>();

		private List<AsyncOperation> m_requests = new List<AsyncOperation>();

		private List<AdvChara> m_enabledCharas = new List<AdvChara>();

		private Vector3 m_imageScale = Vector3.one;

		public Transform Transform => m_transform;

		public bool IsFading { get; private set; }

		public bool IsLoading => m_requests.Count > 0;

		public bool IsBusy
		{
			get
			{
				if (!IsLoading && !IsFading)
				{
					return m_imageWindow.IsBusy;
				}
				return true;
			}
		}

		public bool IsPlaying { get; private set; }

		public bool HasImage { get; private set; }

		private void Start()
		{
			HasImage = false;
			IsPlaying = false;
			IsFading = false;
			m_gameObject = base.gameObject;
			m_transform = base.transform;
			m_imageScale = m_imageWindow.transform.localScale;
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeStartInGame.Where((int _) => IsPlaying || IsLoading).Subscribe(delegate
			{
				OnEndFogEnd();
			}).AddTo(base.gameObject);
		}

		public void LoadAllTextures(List<int> preloadIndexes)
		{
			preloadIndexes?.ForEach(delegate(int id)
			{
				ResourceRequest resourceRequest = Resources.LoadAsync<Texture>(string.Format("{0}{1:D4}", "Textures/Event/", id));
				resourceRequest.completed += delegate(AsyncOperation obj)
				{
					OnLoadComplete(obj, id);
				};
				m_requests.Add(resourceRequest);
			});
		}

		private void OnLoadComplete(AsyncOperation obj, int id)
		{
			m_requests.Remove(obj);
			Texture texture = (obj as ResourceRequest).asset as Texture;
			if (!(texture == null))
			{
				m_textures.Add(new Data<Texture>(id, texture));
			}
		}

		public void Clear()
		{
			int count = m_textures.Count;
			for (int i = 0; i < count; i++)
			{
				Resources.UnloadAsset(m_textures[i].Content);
				m_textures[i].Content = null;
				m_textures[i] = null;
			}
			m_textures.Clear();
			Resources.UnloadUnusedAssets();
		}

		public void SetActive(bool isActive)
		{
			m_gameObject.SetActive(isActive);
		}

		public void Play(Transform playerRoot, IFader fader, CommandFlashbackStart command)
		{
			Play(playerRoot, fader, command.ID, command.EndDistance);
		}

		public void Play(Transform playerRoot, IFader fader, int id, float fogEndTargetDistance)
		{
			HasImage = id != -1;
			IsPlaying = true;
			IsFading = true;
			m_playerRoot = playerRoot;
			SoundManager.Voice.IsForce2DMode = true;
			RecordActiveChara();
			FadeAllChara(0f, 0.3f, isActivate: false);
			InitializeFogState(m_fogEndDistance);
			StartFogFadeIn(id, fogEndTargetDistance);
			MoveToPlayer();
		}

		private void InitializeFogState(float fogEndDistance)
		{
			RenderSettings.fog = true;
			RenderSettings.fogColor = m_fogColour;
			RenderSettings.fogMode = m_fogMode;
			RenderSettings.fogStartDistance = m_fogStartDistance;
			RenderSettings.fogEndDistance = fogEndDistance;
		}

		private void StartFogFadeIn(int id, float fogEndTargetDistance)
		{
			DOTween.To(() => RenderSettings.fogEndDistance, delegate(float density)
			{
				RenderSettings.fogEndDistance = density;
			}, fogEndTargetDistance, m_fogFadeDuration).OnComplete(delegate
			{
				OnStartFadeInEnd(id);
			});
		}

		private void RecordActiveChara()
		{
			m_enabledCharas.Clear();
			SingletonMonoBehaviour<CharactersManager>.Instance.AddActiveCharaToList(m_enabledCharas);
		}

		private void FadeAllChara(float targetAlpha, float duration, bool isActivate)
		{
			int count = m_enabledCharas.Count;
			for (int i = 0; i < count; i++)
			{
				AdvChara chara = m_enabledCharas[i];
				if (isActivate)
				{
					chara.SetEnable(isActivate);
					chara.Model.StartFade(targetAlpha, duration);
				}
				else
				{
					chara.Model.StartFade(targetAlpha, duration, delegate
					{
						chara.SetEnable(isActivate);
					});
				}
			}
		}

		private void MoveToPlayer()
		{
			m_transform.position = m_playerRoot.position;
			m_transform.rotation = m_playerRoot.rotation;
		}

		private Texture FindImage(int id)
		{
			int count = m_textures.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_textures[i].ID == id)
				{
					return m_textures[i].Content;
				}
			}
			return null;
		}

		private void OnStartFadeInEnd(int id)
		{
			SetActive(isActive: true);
			if (!HasImage)
			{
				OnStartImageFadeEnd();
			}
			else
			{
				ShowFlashbackImage(id);
			}
		}

		private void ShowFlashbackImage(int id)
		{
			Texture sprite = FindImage(id);
			m_imageWindow.OnOpen(sprite, Vector3Extension.Zero);
			m_imageWindow.OpenDither(sprite, m_imageScale, m_imageFadeDuration, delegate
			{
				OnStartImageFadeEnd();
			});
		}

		private void OnStartImageFadeEnd()
		{
			IsFading = false;
		}

		public void ChangeSprite(int id)
		{
			m_imageWindow.ChangeTexture(FindImage(id), m_imageFadeDuration);
		}

		public void Close()
		{
			IsFading = true;
			if (HasImage)
			{
				m_imageWindow.Close(m_imageFadeDuration, ForcusUpWindow.FadeType.Dither, Ease.InOutSine);
			}
			FadeAllChara(1f, 0.3f, isActivate: true);
			DOTween.To(() => RenderSettings.fogEndDistance, delegate(float density)
			{
				RenderSettings.fogEndDistance = density;
			}, m_fogDistanceOnEnd, m_fogEndFadeDuration).OnComplete(delegate
			{
				OnEndFogEnd();
			});
		}

		private void OnEndFogEnd()
		{
			RenderSettings.fog = false;
			IsFading = false;
			IsPlaying = false;
			HasImage = false;
			SoundManager.Voice.IsForce2DMode = false;
			SetActive(isActive: false);
			m_enabledCharas.Clear();
		}

		public void OnScenarioEnd()
		{
			m_imageWindow.Close(0f, ForcusUpWindow.FadeType.Move, Ease.InOutSine);
			RenderSettings.fogEndDistance = m_fogDistanceOnEnd;
			OnEndFogEnd();
			Clear();
		}
	}
	public class DebugConsole : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private GameObject _consoleParent;

		[SerializeField]
		private GameObject _consoleContents;

		[SerializeField]
		private TextMeshProUGUI m_versionText;

		private ObservableEventTrigger _rootEventTrigger;

		private bool _isVisible;

		public bool IsVisible => _isVisible;

		private void Awake()
		{
			ToggleVisible(flag: false);
			_rootEventTrigger = _consoleParent.AddComponent<ObservableEventTrigger>();
		}

		private void Start()
		{
			_rootEventTrigger.OnPointerEnterAsObservable().Subscribe(delegate
			{
				ToggleVisible(flag: true);
			}).AddTo(this);
			_rootEventTrigger.OnPointerExitAsObservable().Subscribe(delegate
			{
				ToggleVisible(flag: false);
			}).AddTo(this);
			m_versionText.text = $"Version:{UnityEngine.Application.version}";
		}

		private void ToggleVisible(bool flag)
		{
			_isVisible = flag;
			_consoleContents.SetActive(flag);
		}
	}
	public class DebugIngameStatus : MonoBehaviour
	{
		[SerializeField]
		private TextMeshProUGUI _textComponent;

		public bool IsVisible { get; set; }

		private void Awake()
		{
			_textComponent.text = "";
			(from _ in this.UpdateAsObservable()
				where IsVisible
				select _).Subscribe(delegate
			{
				OnUpdate();
			});
		}

		private void OnUpdate()
		{
			string text = "";
			text += $"Active Scene: <b>{SceneManager.GetActiveScene().name}</b>\n";
			if (SingletonMonoBehaviour<MasterManager>.HasInstance)
			{
				if (SingletonMonoBehaviour<MasterManager>.Instance.IsBusy)
				{
					text += "Busy [";
					foreach (Component value in SingletonMonoBehaviour<MasterManager>.Instance.BusyComponentList.Values)
					{
						text = text + value.ToString() + ", ";
					}
					text += "]\n";
				}
				else
				{
					text += "Active\n";
				}
				if (SingletonMonoBehaviour<MasterManager>.Instance.IsInGame)
				{
					if (SingletonMonoBehaviour<InGameManager>.HasInstance)
					{
						TimelinePlayer timeline = InGameManager.Timeline;
						text += $"SQID: <b>{timeline.LoadedScenarioID:00000}</b>\n";
						text += $"CmdLine Index: <b>{timeline.SequenceCurrentIndex}</b>\n";
						ISequenceCommand waitingCommand = timeline.WaitingCommand;
						string arg = ((waitingCommand != null) ? waitingCommand.Type.ToString() : "None");
						text += $"Wait: Leg <b>{timeline.LegacyWait}</b> - Cmd <b>{arg}</b>";
					}
					else
					{
						text += " (Not Initialized)";
					}
				}
				else
				{
					text += "Not InGame";
				}
			}
			else
			{
				text += "Game Not Initialized";
			}
			_textComponent.text = text;
		}

		public void ToggleVisible(bool flag)
		{
			IsVisible = flag;
			base.enabled = flag;
			_textComponent.enabled = flag;
		}
	}
	public class DebugManager : SingletonMonoBehaviour<DebugManager>
	{
		[Serializable]
		public class SuperAutoSelectionState
		{
			public int sqid = -1;

			public int nextSelection = -1;
		}

		[Header("Components - Displays")]
		[SerializeField]
		private FPSCounterTMPro _fpsCounter;

		[SerializeField]
		private DebugMemory _memoryDispley;

		[SerializeField]
		private DebugLogger _logDisplay;

		[SerializeField]
		private DebugIngameStatus _gameStatusDisplay;

		[Header("Components - Others")]
		[SerializeField]
		private DebugConsole _console;

		[Header("Parameter - Defaults")]
		[SerializeField]
		private bool _startShowFps;

		[SerializeField]
		private bool _startShowMemory;

		[SerializeField]
		private bool _startShowLog;

		[SerializeField]
		private bool _startShowGameStatus;

		[Header("Parameter - Selection")]
		[SerializeField]
		private List<SuperAutoSelectionState> _selectionState;

		public bool IsSuperAutoMode { get; set; }

		public bool IsVisibleFps => _fpsCounter.IsVisible;

		public bool IsVisibleMemory => _memoryDispley.IsVisible;

		public bool IsVisibleLog => _logDisplay.IsVisible;

		public bool IsVisibleGameStatus => _gameStatusDisplay.IsVisible;

		public bool IsVisibleConsole => _console.IsVisible;

		protected override void InitializeOnAwake()
		{
			_fpsCounter.ToggleVisible(_startShowFps);
			_memoryDispley.ToggleVisible(_startShowMemory);
			_logDisplay.ToggleVisible(_startShowLog);
			_gameStatusDisplay.ToggleVisible(_startShowGameStatus);
		}

		private void Start()
		{
			if (SingletonMonoBehaviour<PlayAreaManager>.HasInstance)
			{
				base.transform.SetParent(SingletonMonoBehaviour<PlayAreaManager>.Instance.transform, worldPositionStays: false);
			}
			else
			{
				UnityEngine.Debug.LogWarning("OOPS: DebugManager couldn't find PlayAreaManager.");
			}
		}

		public void ToggleVisibleFps(bool flag)
		{
			_fpsCounter.ToggleVisible(flag);
		}

		public void ToggleVisibleMemory(bool flag)
		{
			_memoryDispley.ToggleVisible(flag);
		}

		public void ToggleVisibleLog(bool flag)
		{
			_logDisplay.ToggleVisible(flag);
		}

		public void ToggleVisibleGameStatus(bool flag)
		{
			_gameStatusDisplay.ToggleVisible(flag);
		}

		private SuperAutoSelectionState FindSelectionState(int sqid)
		{
			SuperAutoSelectionState superAutoSelectionState = _selectionState.Find((SuperAutoSelectionState state) => state.sqid == sqid);
			if (superAutoSelectionState == null)
			{
				superAutoSelectionState = new SuperAutoSelectionState();
				superAutoSelectionState.sqid = sqid;
				_selectionState.Add(superAutoSelectionState);
			}
			return superAutoSelectionState;
		}

		public int GetNextAutoSelection(int sqid, int selectionMax)
		{
			SuperAutoSelectionState superAutoSelectionState = FindSelectionState(sqid);
			if (superAutoSelectionState.nextSelection < 0)
			{
				superAutoSelectionState.nextSelection = selectionMax - 1;
			}
			int nextSelection = superAutoSelectionState.nextSelection;
			superAutoSelectionState.nextSelection--;
			if (superAutoSelectionState.nextSelection < 0)
			{
				superAutoSelectionState.nextSelection = selectionMax - 1;
			}
			return nextSelection;
		}
	}
	public abstract class DebugBaseSelectToggle<T> : MonoBehaviour
	{
		[SerializeField]
		private Toggle _toggle;

		[SerializeField]
		protected TextMeshProUGUI _label;

		public IObservable<bool> OnChangeToggle { get; private set; }

		private void Awake()
		{
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			if (OnChangeToggle == null)
			{
				OnChangeToggle = _toggle.OnValueChangedAsObservable();
			}
		}

		public void Initialize(T myValue, ToggleGroup group, bool isSelected)
		{
			_toggle.group = group;
			_toggle.isOn = isSelected;
			SetText(myValue);
			Color white = Color.white;
			_label.color = white;
			MakeSubscribes();
		}

		protected abstract void SetText(T text);
	}
	public class DebugChapterPage : MonoBehaviour
	{
		public int MajorCategoryInt { get; set; }

		public void SetVisible(bool flag)
		{
			base.gameObject.SetActive(flag);
		}
	}
	public class DebugMSAASelectToggle : DebugBaseSelectToggle<int>
	{
		protected override void SetText(int text)
		{
			_label.text = text.ToString();
		}
	}
	public class DebugResolutionSelectToggle : DebugBaseSelectToggle<float>
	{
		protected override void SetText(float text)
		{
			_label.text = text.ToString();
		}
	}
	public class DebugScenarioInfo : MonoBehaviour
	{
		[SerializeField]
		private Image _imageThumbnail;

		[SerializeField]
		private TextMeshProUGUI _textHeader;

		[SerializeField]
		private TextMeshProUGUI _textContents;

		[SerializeField]
		private Sprite _defaultThumbnail;

		private int CurrentSqid
		{
			get
			{
				if (!SingletonMonoBehaviour<MasterManager>.Instance.IsInGame)
				{
					return -1;
				}
				return InGameManager.Timeline.LoadedScenarioID;
			}
		}

		private void Start()
		{
			_textHeader.fontStyle = FontStyles.Bold;
			this.ObserveEveryValueChanged((DebugScenarioInfo _) => CurrentSqid).Subscribe(delegate(int sqid)
			{
				UpdateInfo(sqid);
			});
		}

		private void UpdateInfo(int sqid)
		{
			if (sqid <= -1)
			{
				_imageThumbnail.sprite = _defaultThumbnail;
				_textHeader.text = "Scenario Not Loaded";
				_textContents.text = "";
				return;
			}
			ScenarioListData.Info scenarioInfo = SingletonMonoBehaviour<DataManager>.Instance.GeneralData.GetScenarioInfo(sqid);
			if (scenarioInfo.Index <= -1)
			{
				_imageThumbnail.sprite = _defaultThumbnail;
				_textHeader.text = "Unknown Scenario: " + sqid.ToString("D5");
				_textContents.text = "";
				return;
			}
			_imageThumbnail.sprite = ((scenarioInfo.SaveThumbnail == null) ? _defaultThumbnail : scenarioInfo.SaveThumbnail);
			_textHeader.text = scenarioInfo.FileName;
			if (scenarioInfo.Category == ScenarioListData.Categories.Special)
			{
				_textContents.text = "Special Type: " + scenarioInfo.SpecialType;
			}
			else
			{
				_textContents.text = "Category: " + scenarioInfo.Category;
			}
			TextMeshProUGUI textContents = _textContents;
			textContents.text = textContents.text + " (Chapter " + scenarioInfo.ChapterNumber + ")";
			if (scenarioInfo.RelatedSqid >= 0)
			{
				TextMeshProUGUI textContents2 = _textContents;
				textContents2.text = textContents2.text + "\nRelated SQID: " + scenarioInfo.RelatedSqid.ToString("D5");
			}
			else
			{
				_textContents.text += "\nRelated SQID: (Not Related)";
			}
			TextMeshProUGUI textContents3 = _textContents;
			textContents3.text = textContents3.text + "\nSkip Mode: " + scenarioInfo.SkipMode;
			TextMeshProUGUI textContents4 = _textContents;
			textContents4.text = textContents4.text + "\nReaded: " + YesNoString(SingletonMonoBehaviour<GameData>.Instance.SystemData.IsScenarioReaded(sqid));
		}

		private string YesNoString(bool flag)
		{
			if (!flag)
			{
				return "No";
			}
			return "Yes";
		}
	}
	public class DebugUIFlags : MonoBehaviour
	{
		[Header("Prefabs")]
		[SerializeField]
		private SceneSelectToggle _prefabToggle;

		[Header("Components")]
		[SerializeField]
		private Transform _toggleParent;

		[SerializeField]
		private Button _buttonAllOn;

		[SerializeField]
		private Button _buttonAllOff;

		[SerializeField]
		private Button _buttonReadedOn;

		[SerializeField]
		private Button _buttonReadedOff;

		[SerializeField]
		private Button _buttonR1On;

		[SerializeField]
		private Button _buttonR2On;

		[SerializeField]
		private Button _buttonSubOn;

		[SerializeField]
		private Button _buttonSubmit;

		private List<SceneSelectToggle> _toggles = new List<SceneSelectToggle>();

		private void Start()
		{
			MakeScenarioToggles();
			MakeSubscribes();
		}

		private void OnEnable()
		{
			RefreshToggles();
		}

		private void OnDestroy()
		{
			_toggles.Clear();
		}

		private void MakeScenarioToggles()
		{
			foreach (GameFlags flagName in Enum.GetValues(typeof(GameFlags)))
			{
				if (flagName != GameFlags.Max)
				{
					SceneSelectToggle sceneSelectToggle = UnityEngine.Object.Instantiate(_prefabToggle, _toggleParent, worldPositionStays: false);
					sceneSelectToggle.InitForFlag(flagName);
					sceneSelectToggle.OnChangeToggle.Subscribe(delegate(bool flag)
					{
						OnSelectToggle(flagName, flag);
					}).AddTo(this);
					_toggles.Add(sceneSelectToggle);
				}
			}
		}

		private void MakeSubscribes()
		{
			_buttonSubmit.OnClickAsObservable().Subscribe(delegate
			{
				SaveSystemFile();
			}).AddTo(this);
			_buttonAllOn.OnClickAsObservable().Subscribe(delegate
			{
				ToggleAll(flag: true);
			}).AddTo(this);
			_buttonAllOff.OnClickAsObservable().Subscribe(delegate
			{
				ToggleAll(flag: false);
			}).AddTo(this);
			_buttonReadedOn.OnClickAsObservable().Subscribe(delegate
			{
				ToggleReadedAll(flag: true);
			}).AddTo(this);
			_buttonReadedOff.OnClickAsObservable().Subscribe(delegate
			{
				ToggleReadedAll(flag: false);
			}).AddTo(this);
			_buttonR1On.OnClickAsObservable().Subscribe(delegate
			{
				FlanEnableForR1();
			}).AddTo(this);
			_buttonR2On.OnClickAsObservable().Subscribe(delegate
			{
				FlanEnableForR2();
			}).AddTo(this);
			_buttonSubOn.OnClickAsObservable().Subscribe(delegate
			{
				FlanEnableForSubChap();
			}).AddTo(this);
		}

		private void OnSelectToggle(GameFlags flagName, bool flag)
		{
			if (flag != SingletonMonoBehaviour<GameData>.Instance.GetFlag(flagName))
			{
				UnityEngine.Debug.LogFormat("DebugFlag: {0} = <b>{1}</b>", flagName, flag);
				SingletonMonoBehaviour<GameData>.Instance.SetFlag(flagName, flag);
			}
		}

		private void SaveSystemFile()
		{
			SingletonMonoBehaviour<GameData>.Instance.SaveSystemData();
			UnityEngine.Debug.Log("System File Saved!");
		}

		public void RefreshToggles()
		{
			foreach (SceneSelectToggle toggle in _toggles)
			{
				toggle.RefreshForFlag();
			}
		}

		public void ToggleAll(bool flag)
		{
			foreach (GameFlags value in Enum.GetValues(typeof(GameFlags)))
			{
				if (value != GameFlags.Max)
				{
					SingletonMonoBehaviour<GameData>.Instance.SetFlag(value, flag);
				}
			}
			UnityEngine.Debug.LogFormat("DebugFlag:  <b>{0}</b> ", flag);
			RefreshToggles();
		}

		public void ToggleReadedAll(bool flag)
		{
			if (flag)
			{
				SingletonMonoBehaviour<GameData>.Instance.SystemData.MakeAllReaded();
			}
			else
			{
				SingletonMonoBehaviour<GameData>.Instance.SystemData.ClearReadedFlag();
			}
			UnityEngine.Debug.LogFormat("DebugFlag:  <b>{0}</b> ", flag);
		}

		public void FlanEnableForR1()
		{
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route1Chapter0, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route1Chapter1, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route1Chapter2, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route1Chapter3, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route1Chapter4, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route1Chapter5, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route1Chapter6, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route1Chapter7, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter1_0, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter1_1, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter1_2, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter1_3, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter1_4, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter1_5, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter1_6, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter1_7, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.EndingNormal, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.SkipNoifyShowed, value: true);
			foreach (ScenarioListData.Info value in SingletonMonoBehaviour<DataManager>.Instance.GeneralData.ScenarioList.Values)
			{
				if (value.Category == ScenarioListData.Categories.RouteFirst)
				{
					SingletonMonoBehaviour<GameData>.Instance.SystemData.AddReadFlag_Debug(value.Index);
				}
			}
			UnityEngine.Debug.Log("DebugFlag: 1ED1 <b>True</b> ");
			RefreshToggles();
		}

		public void FlanEnableForR2()
		{
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter0, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter1, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter2, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter3, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter4, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter5, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter6, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter7, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter8, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter9, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter10, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_0, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_1, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_2, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_3, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_4, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_5, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_6, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_7, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_8, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_9, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_10, value: true);
			foreach (ScenarioListData.Info value in SingletonMonoBehaviour<DataManager>.Instance.GeneralData.ScenarioList.Values)
			{
				if (value.Category == ScenarioListData.Categories.RouteSecond)
				{
					SingletonMonoBehaviour<GameData>.Instance.SystemData.AddReadFlag_Debug(value.Index);
				}
			}
			UnityEngine.Debug.Log("DebugFlag: 2 <b>True</b> ");
			RefreshToggles();
		}

		public void FlanEnableForSubChap()
		{
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.ChapterKageyama, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.ChapterMachikouji, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.ChapterMomono, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.ChapterMorozumi, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.ChapterTougoku, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.EndingAlternate, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.EndingKageyama, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.EndingMachikouji, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.EndingMomono, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.EndingMorozumi, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.EndingTougoku, value: true);
			foreach (ScenarioListData.Info value in SingletonMonoBehaviour<DataManager>.Instance.GeneralData.ScenarioList.Values)
			{
				if (value.Category == ScenarioListData.Categories.Character)
				{
					SingletonMonoBehaviour<GameData>.Instance.SystemData.AddReadFlag_Debug(value.Index);
				}
			}
			UnityEngine.Debug.Log("DebugFlag:  <b>True</b> ");
			RefreshToggles();
		}
	}
	public class DebugUIMSAA : MonoBehaviour
	{
		[Header("Prefabs")]
		[SerializeField]
		private DebugMSAASelectToggle _prefabToggle;

		[Header("Components - General")]
		[SerializeField]
		private Transform _toggleParent;

		[SerializeField]
		private ToggleGroup _toggleGroup;

		[SerializeField]
		private int[] m_msaaLevels;

		private void Start()
		{
			MakeToggles();
		}

		private void MakeToggles()
		{
			int num = m_msaaLevels.Length;
			for (int i = 0; i < num; i++)
			{
				DebugMSAASelectToggle debugMSAASelectToggle = UnityEngine.Object.Instantiate(_prefabToggle, _toggleParent, worldPositionStays: false);
				debugMSAASelectToggle.Initialize(m_msaaLevels[i], _toggleGroup, m_msaaLevels[i] == QualitySettings.antiAliasing);
				int index = i;
				debugMSAASelectToggle.OnChangeToggle.Where((bool flag) => flag).Subscribe(delegate
				{
					OnSelectToggle(index);
				}).AddTo(this);
			}
		}

		private void OnSelectToggle(int index)
		{
			UnityEngine.Debug.Log("Selected MSAA Toggle! index = " + index + ", level = " + m_msaaLevels[index]);
			QualitySettings.antiAliasing = m_msaaLevels[index];
		}
	}
	public class DebugUIOptions : MonoBehaviour
	{
		[SerializeField]
		private Toggle _toggleFps;

		[SerializeField]
		private Toggle _toggleMemory;

		[SerializeField]
		private Toggle _toggleLog;

		[SerializeField]
		private Toggle _toggleGameStatus;

		[SerializeField]
		private Toggle _toggleSuperAuto;

		[SerializeField]
		private Button _buttonLanguage;

		[SerializeField]
		private Button _buttonClearStatButton;

		[SerializeField]
		private Button _buttonReset;

		[SerializeField]
		private TextMeshProUGUI _labelLanguage;

		[SerializeField]
		private TextMeshProUGUI _labelClearStatButton;

		private ReactiveProperty<int> _clearPressedCount = new ReactiveProperty<int>(4);

		private void Start()
		{
			_toggleFps.isOn = SingletonMonoBehaviour<DebugManager>.Instance.IsVisibleFps;
			_toggleMemory.isOn = SingletonMonoBehaviour<DebugManager>.Instance.IsVisibleMemory;
			_toggleLog.isOn = SingletonMonoBehaviour<DebugManager>.Instance.IsVisibleLog;
			_toggleGameStatus.isOn = SingletonMonoBehaviour<DebugManager>.Instance.IsVisibleGameStatus;
			_toggleSuperAuto.isOn = SingletonMonoBehaviour<DebugManager>.Instance.IsSuperAutoMode;
			_toggleFps.OnValueChangedAsObservable().Subscribe(delegate(bool flag)
			{
				SingletonMonoBehaviour<DebugManager>.Instance.ToggleVisibleFps(flag);
			});
			_toggleMemory.OnValueChangedAsObservable().Subscribe(delegate(bool flag)
			{
				SingletonMonoBehaviour<DebugManager>.Instance.ToggleVisibleMemory(flag);
			});
			_toggleLog.OnValueChangedAsObservable().Subscribe(delegate(bool flag)
			{
				SingletonMonoBehaviour<DebugManager>.Instance.ToggleVisibleLog(flag);
			});
			_toggleGameStatus.OnValueChangedAsObservable().Subscribe(delegate(bool flag)
			{
				SingletonMonoBehaviour<DebugManager>.Instance.ToggleVisibleGameStatus(flag);
			});
			_toggleSuperAuto.OnValueChangedAsObservable().Subscribe(delegate(bool flag)
			{
				SingletonMonoBehaviour<DebugManager>.Instance.IsSuperAutoMode = flag;
			});
			_buttonLanguage.OnClickAsObservable().Subscribe(delegate
			{
				ToggleNextLanguage();
			});
			_buttonReset.OnClickAsObservable().Subscribe(delegate
			{
				ResetGame();
			});
			_buttonClearStatButton.OnClickAsObservable().Subscribe(delegate
			{
				StatClearButtonPressed();
			});
			SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Subscribe(delegate(GameDefine.Languages lang)
			{
				_labelLanguage.text = lang.ToString();
			}).AddTo(base.gameObject);
			_clearPressedCount.Where((int count) => count > 0).Subscribe(delegate(int count)
			{
				_labelClearStatButton.text = ": " + count;
			});
			_clearPressedCount.Where((int count) => count == 0).DelayFrame(1).Subscribe(delegate
			{
				_clearPressedCount.Value = 4;
			});
		}

		private void ToggleNextLanguage()
		{
			int num = (int)(SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value + 1);
			if (num >= 5)
			{
				num = 0;
			}
			SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value = (GameDefine.Languages)num;
		}

		private void StatClearButtonPressed()
		{
			if (_clearPressedCount.Value > 0)
			{
				_clearPressedCount.Value--;
			}
		}

		private void ResetGame()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.ForceToTitle();
		}
	}
	public class DebugUIResolution : MonoBehaviour
	{
		[Header("Prefabs")]
		[SerializeField]
		private DebugResolutionSelectToggle _prefabToggle;

		[Header("Components - General")]
		[SerializeField]
		private Transform _toggleParent;

		[SerializeField]
		private ToggleGroup _toggleGroup;

		[SerializeField]
		private float[] m_resolutions;

		private void Start()
		{
			MakeToggles();
		}

		private void MakeToggles()
		{
			int num = m_resolutions.Length;
			for (int i = 0; i < num; i++)
			{
				DebugResolutionSelectToggle debugResolutionSelectToggle = UnityEngine.Object.Instantiate(_prefabToggle, _toggleParent, worldPositionStays: false);
				debugResolutionSelectToggle.Initialize(m_resolutions[i], _toggleGroup, m_resolutions[i] == XRSettings.eyeTextureResolutionScale);
				int index = i;
				debugResolutionSelectToggle.OnChangeToggle.Where((bool flag) => flag).Subscribe(delegate
				{
					OnSelectToggle(index);
				}).AddTo(this);
			}
		}

		private void OnSelectToggle(int index)
		{
			UnityEngine.Debug.Log("Selected Resolution Toggle! index = " + index + ", resolution = " + m_resolutions[index]);
			XRSettings.eyeTextureResolutionScale = m_resolutions[index];
		}
	}
	public class DebugUIScenario : MonoBehaviour
	{
		[Header("Prefabs")]
		[SerializeField]
		private SceneSelectToggle _prefabToggle;

		[SerializeField]
		private DebugChapterPage _prefabPageComponent;

		[Header("Components - General")]
		[SerializeField]
		private Transform _toggleParent;

		[SerializeField]
		private ToggleGroup _toggleGroup;

		[SerializeField]
		private Button _buttonSubmit;

		[SerializeField]
		private TextMeshProUGUI _buttonLabel;

		[Header("Components - Paging")]
		[SerializeField]
		private Button _buttonPagePrev;

		[SerializeField]
		private Button _buttonPageNext;

		[SerializeField]
		private TextMeshProUGUI _labelCurrentPage;

		[Header("Parameters")]
		[SerializeField]
		private string _labelFormat = ": {0:00000}";

		private int _sceneToLoad = -1;

		private int _currentPage;

		private SortedList<int, DebugChapterPage> _instancePage = new SortedList<int, DebugChapterPage>();

		private BehaviorSubject<int> _subjectPaged;

		private IObservable<int> OnPaged => _subjectPaged;

		private void Start()
		{
			MakeSubscribes();
			MakeScenarioToggles();
		}

		private void MakeSubscribes()
		{
			_subjectPaged = new BehaviorSubject<int>(_currentPage);
			_buttonSubmit.OnClickAsObservable().Subscribe(delegate
			{
				OnPushLoad();
			}).AddTo(this);
			_buttonPagePrev.OnClickAsObservable().Subscribe(delegate
			{
				PageCategory(-1);
			});
			_buttonPageNext.OnClickAsObservable().Subscribe(delegate
			{
				PageCategory(1);
			});
			OnPaged.Subscribe(delegate(int pageInt)
			{
				_labelCurrentPage.text = $"Chap. {pageInt:00}";
			});
		}

		private void MakeScenarioToggles()
		{
			int num = -1;
			DebugChapterPage debugChapterPage = null;
			_currentPage = -1;
			foreach (ScenarioListData.Info info in SingletonMonoBehaviour<DataManager>.Instance.GeneralData.ScenarioList.Values)
			{
				int num2 = info.Index / 1000;
				if (num != num2)
				{
					num = num2;
					if (_currentPage == -1)
					{
						_currentPage = num2;
					}
					debugChapterPage = MakeScenarioPage(num2);
				}
				SceneSelectToggle sceneSelectToggle = UnityEngine.Object.Instantiate(_prefabToggle, debugChapterPage.transform, worldPositionStays: false);
				sceneSelectToggle.InitForScenario(info, _toggleGroup);
				sceneSelectToggle.OnChangeToggle.Where((bool flag) => flag).Subscribe(delegate
				{
					OnSelectToggle(info.Index);
				}).AddTo(this);
			}
			_subjectPaged.OnNext(_currentPage);
		}

		private DebugChapterPage MakeScenarioPage(int majorCategoryInt)
		{
			DebugChapterPage obj = UnityEngine.Object.Instantiate(_prefabPageComponent, _toggleParent, worldPositionStays: false);
			obj.MajorCategoryInt = majorCategoryInt;
			_instancePage.Add(majorCategoryInt, obj);
			OnPaged.Subscribe(delegate(int pageInt)
			{
				bool visible = obj.MajorCategoryInt == pageInt;
				obj.SetVisible(visible);
			});
			return obj;
		}

		private void OnSelectToggle(int index)
		{
			_sceneToLoad = index;
			_buttonLabel.text = string.Format(_labelFormat, index);
		}

		private void OnPushLoad()
		{
			if (_sceneToLoad == -1)
			{
				UnityEngine.Debug.LogError("REALLY OOPS: Scenario not selected");
				return;
			}
			UnityEngine.Debug.LogFormat("Debug console loads scenario '{0}'", _sceneToLoad);
			SingletonMonoBehaviour<MasterManager>.Instance.StartScenarioWithFade(_sceneToLoad);
		}

		private void PageCategory(int diff)
		{
			int num = _instancePage.IndexOfKey(_currentPage);
			num += diff;
			if (num < 0)
			{
				num = _instancePage.Count - 1;
			}
			if (num >= _instancePage.Count)
			{
				num = 0;
			}
			_currentPage = _instancePage.Keys[num];
			_subjectPaged.OnNext(_currentPage);
		}
	}
	public class SceneSelectToggle : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private Toggle _toggle;

		[SerializeField]
		private TextMeshProUGUI _label;

		private GameFlags _flagId;

		public IObservable<bool> OnChangeToggle { get; private set; }

		private void Awake()
		{
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			if (OnChangeToggle == null)
			{
				OnChangeToggle = _toggle.OnValueChangedAsObservable();
			}
		}

		public void InitForScenario(ScenarioListData.Info info, ToggleGroup group)
		{
			MakeSubscribes();
			int index = info.Index;
			_toggle.group = group;
			_label.text = index.ToString("00000");
			Color color = Color.HSVToRGB(Mathf.Repeat(1f / 64f * Mathf.Floor(index / 100), 1f), 0.7f - 0.4f * ((float)(index % 100) / 100f), 1f);
			if (!info.IsValid)
			{
				color.a = 0.25f;
			}
			_label.color = color;
			ToggleInterractable(info.IsValid);
		}

		public void InitForFlag(GameFlags flag)
		{
			MakeSubscribes();
			_flagId = flag;
			int num = (int)flag;
			_label.text = $"{num:00}: {flag.ToString()}";
			_label.color = Color.HSVToRGB(Mathf.Repeat(0.071f * Mathf.Floor(num / 10), 1f), 0.7f - 0.5f * ((float)(num % 10) / 10f), 1f);
			_toggle.isOn = SingletonMonoBehaviour<GameData>.Instance.GetFlag(flag);
		}

		public void RefreshForFlag()
		{
			_toggle.isOn = SingletonMonoBehaviour<GameData>.Instance.GetFlag(_flagId);
		}

		public void ToggleInterractable(bool flag)
		{
			_toggle.interactable = flag;
		}
	}
	public class AdvBoot : MonoBehaviour
	{
		[SerializeField]
		private bool m_isDestroyOnStart = true;

		private void Start()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.StartInGame();
			if (m_isDestroyOnStart)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
	public class AdvBackgroundMemory : AdvBackground
	{
		public enum SpotlightTypes
		{
			Day,
			Evening,
			Night
		}

		[Serializable]
		public class TextureData
		{
			public Texture Texture;

			public SpotlightTypes Type;
		}

		[SerializeField]
		private MeshRenderer m_spotLight;

		[SerializeField]
		private List<TextureData> m_spotLightTextures;

		public void SetSpotlightType(SpotlightTypes type)
		{
			m_spotLight.sharedMaterial.mainTexture = m_spotLightTextures.Find((TextureData data) => data.Type == type).Texture;
		}
	}
	public class AdvMemoryChara : UpdateableComponent, IChara
	{
		[SerializeField]
		private int m_charaID;

		private const float _SHAKE_DURATION = 1.05f;

		private readonly Vector3 _SHAKE_AMOUNT = new Vector3(0.05f, 0.05f, 0f);

		private DitherFade m_fader;

		private Material m_material;

		private Tweener m_shakeTweener;

		private bool m_hasMoved;

		private bool m_isHoldShakeOnFade;

		private Action m_onEndFade;

		private Action m_onEndFadeSentAction;

		private Action m_onEndFadeSetEnable;

		private Action m_onStartFadeEnd;

		private Action m_onStartFadeEndSentAction;

		private float m_fadeDurationOnAction;

		private bool m_isEnableOnFadeEnd = true;

		public Transform Transform { get; set; }

		public Transform Head { get; private set; }

		public GameDefine.CharaID ID => (GameDefine.CharaID)(Mathf.Ceil(m_charaID / 100) * 100f);

		public int CharaID => m_charaID;

		public bool IsReady { get; private set; }

		protected override void Initialize()
		{
			if (Transform == null)
			{
				Transform = base.transform;
			}
			Head = Transform.GetChild(0);
			m_shakeTweener = null;
			m_thisGameObject = base.gameObject;
			CreateMaterial();
			m_fader = new DitherFade(m_thisGameObject, m_material);
			IsReady = true;
			m_isHoldShakeOnFade = false;
			InitializeShake();
			StopShake();
			Disable();
			m_onEndFade = delegate
			{
				OnFadeEnd();
			};
			m_onStartFadeEnd = delegate
			{
				OnStartFadeEnd();
			};
			m_onStartFadeEndSentAction = null;
			m_onEndFadeSetEnable = delegate
			{
				OnFadeEndSetEnable();
			};
			m_onEndFadeSentAction = null;
			m_fadeDurationOnAction = 0f;
			base.Initialize();
		}

		private void CreateMaterial()
		{
			Renderer component = GetComponent<Renderer>();
			if (!(component == null))
			{
				Material sharedMaterial = component.sharedMaterial;
				if (!(sharedMaterial == null))
				{
					m_material = new Material(sharedMaterial);
					component.sharedMaterial = m_material;
				}
			}
		}

		public void Destroy()
		{
			m_onEndFadeSentAction = null;
			m_onStartFadeEnd = null;
			m_material = null;
			UnityEngine.Object.Destroy(m_material);
			if (m_thisGameObject != null)
			{
				Transform.SetParent(null);
				UnityEngine.Object.Destroy(m_thisGameObject);
				m_thisGameObject = null;
			}
		}

		public void Setup(int id = -1)
		{
			if (id != -1)
			{
				m_charaID = id;
			}
			if (Transform == null)
			{
				Transform = base.transform;
			}
		}

		public override void OnUpdate(float delta)
		{
			if (IsReady)
			{
				m_fader.Update(delta);
				base.OnUpdate(delta);
			}
		}

		public void Enable()
		{
			SetEnable(isEnable: true);
		}

		public void Disable()
		{
			SetEnable(isEnable: false);
		}

		public void SetEnable(bool isEnable)
		{
			m_isActive = isEnable;
			m_thisGameObject.SetActive(isEnable);
		}

		public void SetAlpha(float alpha)
		{
			m_fader.SetModelAlpha(alpha);
		}

		public void StartFade(float targetAlpha, float duration = 0.3f, Action onFadeEnd = null)
		{
			if (duration <= 0f)
			{
				m_fader.SetModelAlpha(targetAlpha);
				onFadeEnd?.Invoke();
			}
			else
			{
				m_onEndFadeSentAction = onFadeEnd;
				m_fader.StartFade(targetAlpha, duration, m_onEndFade);
				StopShake();
			}
		}

		public void StartFadeWithChangeActive(float targetAlpha, bool isActivate, float duration = 0.3f)
		{
			if (duration <= 0f)
			{
				m_fader.SetModelAlpha(targetAlpha);
				SetEnable(isActivate);
			}
			else
			{
				m_isEnableOnFadeEnd = isActivate;
				m_fader.StartFade(targetAlpha, duration, m_onEndFadeSetEnable);
				StopShake();
			}
		}

		private void OnFadeEndSetEnable()
		{
			SetEnable(m_isEnableOnFadeEnd);
		}

		public void PlayPingPongFade(float duration = 0.3f, Action onStartFadeEnd = null, Action onFadeEnd = null)
		{
			StopShake();
			m_onStartFadeEndSentAction = onStartFadeEnd;
			m_onEndFadeSentAction = onFadeEnd;
			m_fadeDurationOnAction = duration;
			m_fader.StartFade(0.3f, duration, m_onStartFadeEnd);
		}

		private void OnStartFadeEnd()
		{
			if (m_onStartFadeEndSentAction != null)
			{
				m_onStartFadeEndSentAction();
			}
			m_fader.StartFade(1f, m_fadeDurationOnAction, m_onEndFade);
		}

		private void OnFadeEnd()
		{
			if (m_onEndFadeSentAction != null)
			{
				m_onEndFadeSentAction();
				m_onEndFadeSentAction = null;
			}
			if (m_isHoldShakeOnFade)
			{
				ProcessShake();
				m_isHoldShakeOnFade = false;
			}
		}

		public void InitializeShake()
		{
			StopShake();
			m_hasMoved = false;
			m_shakeTweener = Transform.DOShakePosition(1.05f, _SHAKE_AMOUNT, 1, 90f, snapping: false, fadeOut: false).SetLoops(-1, LoopType.Incremental);
		}

		public void Shake()
		{
			if (m_fader.IsFading)
			{
				m_isHoldShakeOnFade = true;
				StopShake();
			}
			else
			{
				ProcessShake();
			}
		}

		private void ProcessShake()
		{
			if (m_shakeTweener == null || m_hasMoved)
			{
				InitializeShake();
			}
			else
			{
				TweenExtensions.Play(m_shakeTweener);
			}
		}

		public void StopShake()
		{
			if (m_shakeTweener != null)
			{
				TweenExtensions.Pause(m_shakeTweener);
			}
		}

		public void SetMoveFlag()
		{
			m_hasMoved = true;
		}
	}
	public class MemoryCharaManager : ResourceDataLoader<AdvMemoryChara>
	{
		private List<AdvMemoryChara> m_charaList;

		public override bool IsLoading
		{
			get
			{
				if (base.IsLoading)
				{
					return true;
				}
				return m_charaList.Exists((AdvMemoryChara chara) => !chara.IsReady);
			}
		}

		public MemoryCharaManager()
			: base(isUnload: false)
		{
			m_charaList = new List<AdvMemoryChara>();
		}

		protected override string CreateFilePath(int id)
		{
			return StringUtility.Format("{0}{1}", "MemoryChara/", id);
		}

		protected override void OnDataRemoved(int id)
		{
			IChara chara = FindChara(id);
			m_charaList.Remove(chara as AdvMemoryChara);
			chara.Destroy();
			chara = null;
			base.OnDataRemoved(id);
		}

		protected override void OnLoadComplete(Data data)
		{
			AdvMemoryChara advMemoryChara = UnityEngine.Object.Instantiate(data.LoadData);
			advMemoryChara.Setup(data.ID);
			advMemoryChara.transform.SetParent(SingletonMonoBehaviour<CharactersManager>.Instance.m_transform);
			m_charaList.Add(advMemoryChara);
		}

		public override void Clear()
		{
			int count = m_charaList.Count;
			for (int i = 0; i < count; i++)
			{
				UnityEngine.Object.Destroy(m_charaList[i].Object);
			}
			m_charaList.Clear();
			base.Clear();
		}

		public AdvMemoryChara FindChara(GameDefine.CharaID id)
		{
			return FindCharaByID(id);
		}

		public AdvMemoryChara FindChara(int id)
		{
			return FindCharaByID((GameDefine.CharaID)id);
		}

		public AdvMemoryChara FindCharaType(GameDefine.CharaID id)
		{
			if (GameDefine.IsUnknownChara(id))
			{
				id = GameDefine.UnknownToCharaID(id);
			}
			return FindCharaByID(id);
		}

		private AdvMemoryChara FindCharaByID(GameDefine.CharaID id)
		{
			int count = m_charaList.Count;
			for (int i = 0; i < count; i++)
			{
				if (IsSamePerson(m_charaList[i].ID, id))
				{
					return m_charaList[i];
				}
			}
			return null;
		}

		private bool IsSamePerson(GameDefine.CharaID left, GameDefine.CharaID right)
		{
			int num = Mathf.CeilToInt((int)left / 100);
			int num2 = Mathf.CeilToInt((int)right / 100);
			return num == num2;
		}

		public void SetTalkChara(GameDefine.CharaID id)
		{
			int count = m_charaList.Count;
			for (int i = 0; i < count; i++)
			{
				if (IsSamePerson(id, m_charaList[i].ID))
				{
					m_charaList[i].Shake();
				}
				else
				{
					m_charaList[i].StopShake();
				}
			}
		}
	}
	public class MemoryModeManager
	{
		private MemoryCharaManager m_charaManager;

		private TimelinePlayer m_timeline;

		private bool m_wasAnimationLimit;

		public bool IsPlaying { get; private set; }

		public bool IsLoading => m_charaManager.IsLoading;

		public MemoryModeManager(TimelinePlayer owner)
		{
			m_wasAnimationLimit = false;
			IsPlaying = false;
			m_timeline = owner;
			m_charaManager = new MemoryCharaManager();
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeStartInGame.Where((int _) => IsPlaying || IsLoading).Subscribe(delegate
			{
				End();
			}).AddTo(owner.gameObject);
		}

		public void Load(List<int> preloadIndexes)
		{
			m_charaManager.Load(preloadIndexes);
		}

		public void Clear()
		{
			m_charaManager.Clear();
		}

		public void OnScenarioEnd()
		{
		}

		public void Play(AdvBackgroundMemory.SpotlightTypes spotlightType)
		{
			if (!IsPlaying)
			{
				IsPlaying = true;
			}
			m_timeline.MessageProcessor.IsMemoryMode = true;
			m_timeline.MessageProcessor.IsEmitSoundOnMessage = IsPlaying;
			SetupSpotlight(spotlightType);
			m_wasAnimationLimit = SingletonMonoBehaviour<CharactersManager>.Instance.IsLimitAnimatableChara;
			SingletonMonoBehaviour<CharactersManager>.Instance.SetAnimationLimitation(isLimit: false);
		}

		private void SetupSpotlight(AdvBackgroundMemory.SpotlightTypes spotlightType)
		{
			if (!(m_timeline.CurrentBackground == null))
			{
				(m_timeline.CurrentBackground as AdvBackgroundMemory).SetSpotlightType(spotlightType);
			}
		}

		public void End()
		{
			IsPlaying = false;
			m_timeline.MessageProcessor.IsMemoryMode = false;
			m_timeline.MessageProcessor.IsEmitSoundOnMessage = IsPlaying;
			m_charaManager.Clear();
			SingletonMonoBehaviour<CharactersManager>.Instance.SetAnimationLimitation(m_wasAnimationLimit);
		}

		public AdvMemoryChara FindChara(GameDefine.CharaID id)
		{
			return m_charaManager.FindChara(id);
		}

		public AdvMemoryChara FindCharaType(GameDefine.CharaID id)
		{
			return m_charaManager.FindCharaType(id);
		}

		public void SetTalkChara(GameDefine.CharaID id)
		{
			m_charaManager.SetTalkChara(id);
		}
	}
	public class CharaChangeSequence : MonoBehaviour
	{
		[SerializeField]
		private TextMesh m_text;

		private Transform m_transform;

		private IFader m_fader;

		private void Start()
		{
			m_fader = SingletonMonoBehaviour<FadeManager>.Instance.sceneFader;
			m_transform = base.transform;
			m_text.text = SingletonMonoBehaviour<LocalData>.Instance.CurrentCharaID.ToString();
			m_fader.StartFade(ColorDefine.Black, ColorDefine.TransparentBlack, 1.5f, isDeactivateOnEnd: false, delegate
			{
				ChangeChara();
			});
		}

		private void ChangeChara()
		{
			SingletonMonoBehaviour<LocalData>.Instance.ChangeCharacterToNext();
			m_text.text = SingletonMonoBehaviour<LocalData>.Instance.NextCharaID.ToString();
			m_transform.DOLocalMove(m_transform.localPosition, 1f).OnComplete(delegate
			{
				m_fader.StartReverseFade(delegate
				{
					End();
				});
			});
		}

		private void End()
		{
			SpecialSceneHelper.EndSpecialScene();
		}
	}
	public class VideoPreloader : MonoBehaviour
	{
		[Header("External Components")]
		[SerializeField]
		private AdvCutScene _cutScene;

		[SerializeField]
		private VideoPlayer _videoPlayer;

		private void Start()
		{
			StartPrepareVideo();
			_cutScene.StartTimelineObservable.Subscribe(delegate
			{
				OnStartTimeline();
			});
		}

		private void StartPrepareVideo()
		{
			if (!_videoPlayer.isPrepared)
			{
				_videoPlayer.Prepare();
			}
		}

		private void OnStartTimeline()
		{
			if (!_videoPlayer.isPrepared)
			{
				_cutScene.AddPauseRequest(this);
				Observable.FromEvent<VideoPlayer.EventHandler, VideoPlayer>((Action<VideoPlayer> h) => h.Invoke, delegate(VideoPlayer.EventHandler h)
				{
					_videoPlayer.prepareCompleted += h;
				}, delegate(VideoPlayer.EventHandler h)
				{
					_videoPlayer.prepareCompleted -= h;
				}).Take(1).Subscribe(delegate
				{
					OnEndPrepareVideo();
				})
					.AddTo(base.gameObject);
			}
		}

		private void OnEndPrepareVideo()
		{
			_cutScene.RemovePauseRequest(this);
		}
	}
	public class TitleBackground : MonoBehaviour
	{
		[Header("Parameters - Camera")]
		[SerializeField]
		private Color _clearColor = Color.white;

		[Header("Parameters - Fog")]
		[SerializeField]
		private bool _enableFog;

		[SerializeField]
		private Color _fogColor = Color.white;

		[SerializeField]
		private float _fogStart;

		[SerializeField]
		private float _fogEnd;

		private void Start()
		{
			if (SingletonMonoBehaviour<MasterManager>.Instance.IsBusy)
			{
				SingletonMonoBehaviour<MasterManager>.Instance.OnToggleBusyProcess.Where((bool flag) => !flag).Take(1).Subscribe(delegate
				{
					ApplyBackgroundParameters();
				})
					.AddTo(base.gameObject);
			}
			else
			{
				ApplyBackgroundParameters();
			}
		}

		private void ApplyBackgroundParameters()
		{
			SingletonMonoBehaviour<PlayAreaManager>.Instance.SetClearColor(_clearColor);
			RenderSettings.fog = _enableFog;
			if (_enableFog)
			{
				RenderSettings.fogColor = _fogColor;
				RenderSettings.fogStartDistance = _fogStart;
				RenderSettings.fogEndDistance = _fogEnd;
			}
		}
	}
	public class ChapterSelectButton : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private MenuButtonFloater _buttonComponent;

		[SerializeField]
		private TextMeshProUGUI _textComponent;

		[SerializeField]
		private LocalizerChapterText _localizer;

		[Header("Parameters")]
		[SerializeField]
		private Material _fontNormal;

		[SerializeField]
		private Material _fontFocused;

		public MenuButtonFloater Button => _buttonComponent;

		public TextMeshProUGUI Label => _textComponent;

		public int StartSequence { get; set; }

		private void Start()
		{
			_buttonComponent.OnFocusStart.Subscribe(delegate
			{
				_textComponent.fontSharedMaterial = _fontFocused;
			});
			_buttonComponent.OnFocusEnd.Subscribe(delegate
			{
				_textComponent.fontSharedMaterial = _fontNormal;
			});
		}

		public void SetPrefixText(string str)
		{
			_localizer.PrefixText = str;
		}

		public void SetLocalizeKey(string key)
		{
			_localizer.LocalizeKey = key;
		}
	}
	public class ChapterSelectGroup : MonoBehaviour
	{
		[Header("Prefabs")]
		[SerializeField]
		[PrefabField]
		private ChapterSelectButton _prefabButton;

		[Header("Components")]
		[SerializeField]
		private TextMeshProUGUI _headerText;

		[Header("Parameters")]
		[SerializeField]
		private ScenarioListData.Categories _category;

		private NewGameData.ChapterSetting[] _chapterSettings;

		private Subject<NewGameData.ChapterSetting> _subjectChapterSelected = new Subject<NewGameData.ChapterSetting>();

		public ISoundableMenu SoundableMenu { get; set; }

		public IObservable<NewGameData.ChapterSetting> ChapterSelectedObservable => _subjectChapterSelected;

		private void Start()
		{
			if (CheckAvailable())
			{
				MakeInstances();
			}
			else
			{
				base.gameObject.SetActive(value: false);
			}
		}

		private bool CheckAvailable()
		{
			if (_prefabButton == null)
			{
				return false;
			}
			_chapterSettings = ChapterChecker.GetChapterListData(_category);
			if (ChapterChecker.IsHiddenChapterRevealed)
			{
				return true;
			}
			NewGameData.ChapterSetting[] chapterSettings = _chapterSettings;
			foreach (NewGameData.ChapterSetting chapterSetting in chapterSettings)
			{
				if (SingletonMonoBehaviour<GameData>.Instance.GetFlag(chapterSetting.ConditionToSelect))
				{
					return true;
				}
			}
			return false;
		}

		private void MakeInstances()
		{
			if (_headerText != null)
			{
				_headerText.text = ChapterChecker.GetChapterCategoryString(_category);
			}
			NewGameData.ChapterSetting[] chapterSettings = _chapterSettings;
			foreach (NewGameData.ChapterSetting chapterSetting in chapterSettings)
			{
				ChapterSelectButton chapterSelectButton = UnityEngine.Object.Instantiate(_prefabButton, base.transform, worldPositionStays: false);
				if (!chapterSetting.IgnoreListUp && (ChapterChecker.IsHiddenChapterRevealed || SingletonMonoBehaviour<GameData>.Instance.GetFlag(chapterSetting.ConditionToSelect)))
				{
					NewGameData.ChapterSetting chapScoped = chapterSetting;
					if (!SingletonMonoBehaviour<GameData>.Instance.GetFlag(chapterSetting.ConditionToSelect))
					{
						chapterSelectButton.SetLocalizeKey("ChapterNameHidden");
						chapterSelectButton.Button.HideIfDisabled = false;
						chapterSelectButton.Button.ToggleEnabled(flag: false);
						chapterSelectButton.Button.PressDownErrorObservable.Subscribe(delegate
						{
							if (SoundableMenu != null)
							{
								SoundableMenu.PlaySeError();
							}
						}).AddTo(base.gameObject);
						continue;
					}
					if (_category == ScenarioListData.Categories.Special)
					{
						chapterSelectButton.SetLocalizeKey(ChapterChecker.GetSpecialSceneLocalizeKey(chapterSetting.Index));
					}
					else
					{
						chapterSelectButton.SetPrefixText(ChapterChecker.GetChapterNumber(chapterSetting.Category, chapterSetting.Index) + ". ");
						chapterSelectButton.SetLocalizeKey(ChapterChecker.GetChapterLocalizeKey((int)_category, chapterSetting.Index));
					}
					chapterSelectButton.StartSequence = chapterSetting.StartSqid;
					chapterSelectButton.Button.ClickObservable.Subscribe(delegate
					{
						_subjectChapterSelected.OnNext(chapScoped);
					});
					chapterSelectButton.Button.AcceptedForcusObservable.Subscribe(delegate
					{
						if (SoundableMenu != null)
						{
							SoundableMenu.PlaySeSelect();
						}
					}).AddTo(base.gameObject);
				}
				else
				{
					chapterSelectButton.Button.ToggleEnabled(flag: false);
				}
			}
		}

		public void MoveByLocalPosition(float rotateFactor, float posZFactor)
		{
			Vector3 localPosition = base.transform.localPosition;
			Quaternion localRotation = Quaternion.Euler(0f, localPosition.x * rotateFactor, 0f);
			localPosition.z = (Mathf.Cos(localPosition.x * rotateFactor * ((float)Math.PI / 180f)) - 1f) * posZFactor;
			base.transform.localRotation = localRotation;
			base.transform.localPosition = localPosition;
		}
	}
	public class LanguageSelectButton : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private MenuButtonFloater _buttonComponent;

		[SerializeField]
		private TextMeshProUGUI _textComponent;

		public MenuButtonFloater Button => _buttonComponent;

		public TextMeshProUGUI Label => _textComponent;

		public GameDefine.Languages targetLang { get; set; }

		private void Start()
		{
			SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Subscribe(delegate(GameDefine.Languages lang)
			{
				_buttonComponent.ToggleEnabled(targetLang != lang);
			}).AddTo(base.gameObject);
		}
	}
	public class LocalizerChapterText : LocalizerUGUIText
	{
		public string PrefixText { get; set; }

		protected override void UpdateLocalize(GameDefine.Languages lang)
		{
			_target.text = PrefixText + base.LocalizeParent.GetLocalizeString(base.LocalizeKey, lang);
		}
	}
	public class TitleAudioComponent : MonoBehaviour
	{
		public enum ClipName
		{
			GameStart,
			Select,
			Decide,
			Cancel,
			MAX
		}

		[SerializeField]
		private AudioSource _source;

		[SerializeField]
		private AudioClip _bgmClip;

		[SerializeField]
		[EnumLabel(typeof(ClipName))]
		private AudioClip[] _clips;

		[SerializeField]
		private float _bgmVolume = 1f;

		public void PlayTitleBGM()
		{
			SoundManager.Bgm.PlaySimple(_bgmClip, _bgmVolume, _bgmClip.length * 0.5f);
		}

		public void PlayBGM(AudioClip bgmClip)
		{
			SoundManager.Bgm.PlaySimple(bgmClip, _bgmVolume, bgmClip.length * 0.5f);
		}

		public void StopTitleBGM(float fadeTime = -1f)
		{
			SoundManager.Bgm.StopSimple(fadeTime);
		}

		public void PlaySound(ClipName cname)
		{
			AudioClip clip = _clips[(int)cname];
			SoundManager.SE.PlayClip(clip, SingletonMonoBehaviour<GameData>.Instance.ConfigData.SeVolume.Value, _source);
		}
	}
	[DisallowMultipleComponent]
	public class TitleBackgroundLoader : MonoBehaviour
	{
		[Serializable]
		public class TitleBackParam
		{
			public GameFlags TargetFlag;

			public bool FlagEquals;

			public SceneDefine SceneToLoad;

			[Expandable]
			[Preview]
			public AudioClip TitleBGM;

			public Sprite LogoSprite;
		}

		[SerializeField]
		private TitleAudioComponent _audio;

		[SerializeField]
		private List<TitleBackParam> _backgrounds;

		private TitleBackParam _targetParam;

		private bool _backgroundLoaded;

		private AsyncSubject<TitleBackParam> _subjectLoadedBackground = new AsyncSubject<TitleBackParam>();

		public IObservable<TitleBackParam> OnLoadedBackground => _subjectLoadedBackground;

		private void Start()
		{
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			SingletonMonoBehaviour<TransitionManager>.Instance.OnBeforeTransition.Where((Scene scene) => _backgroundLoaded && scene.buildIndex == base.gameObject.scene.buildIndex).Subscribe(delegate
			{
				SingletonMonoBehaviour<TransitionManager>.Instance.UnloadSceneAsync(_targetParam.SceneToLoad, delegate
				{
				});
				_backgroundLoaded = false;
			}).AddTo(base.gameObject);
			OnLoadedBackground.Where((TitleBackParam param) => param != null && param.TitleBGM != null).Subscribe(delegate(TitleBackParam param)
			{
				PlayTitleBGM(param.TitleBGM);
			});
		}

		public void StartTitleBackLoad()
		{
			_targetParam = _backgrounds.FindLast((TitleBackParam param) => SingletonMonoBehaviour<GameData>.Instance.GetFlag(param.TargetFlag) == param.FlagEquals);
			if (_targetParam == null)
			{
				Observable.NextFrame().Subscribe(delegate
				{
					_subjectLoadedBackground.OnNext(null);
					_subjectLoadedBackground.OnCompleted();
				});
				return;
			}
			SingletonMonoBehaviour<TransitionManager>.Instance.AddSceneAsyncAsObservable(_targetParam.SceneToLoad).Subscribe(delegate
			{
				_backgroundLoaded = true;
				_subjectLoadedBackground.OnNext(_targetParam);
				_subjectLoadedBackground.OnCompleted();
			});
		}

		private void PlayTitleBGM(AudioClip bgmClip)
		{
			_audio.PlayBGM(bgmClip);
		}
	}
	[DisallowMultipleComponent]
	public class MainTitleManager : SingletonMonoBehaviour<MainTitleManager>
	{
		private enum TitleState
		{
			Initalize,
			IntroFadeIn,
			FadeOutToScene,
			Main,
			WaitForMenu,
			End,
			MAX
		}

		[Header("Components - Genaral")]
		[SerializeField]
		private TitleMenuController _menuManager;

		[SerializeField]
		private TitleAudioComponent _audioComponent;

		[SerializeField]
		private TitleBackgroundLoader _background;

		[SerializeField]
		private SpriteRenderer _logoSprite;

		[Header("Parameters - Fades")]
		[SerializeField]
		private float _fadeInTime = 0.5f;

		[SerializeField]
		private float _fadeOutTime = 2.25f;

		[SerializeField]
		private float _bgmFadeTime = 1.5f;

		private TitleState _state;

		public TitleAudioComponent AudioComponent => _audioComponent;

		private UIFader Fader => SingletonMonoBehaviour<FadeManager>.Instance.sceneFader;

		private void Start()
		{
			TitleInitialize();
			MakeSubscribe();
		}

		private void TitleInitialize()
		{
			SingletonMonoBehaviour<PlayAreaManager>.Instance.AddLaserNeed(this);
			_background.StartTitleBackLoad();
		}

		private void OnBeforeEndMenu()
		{
			_menuManager.ToggleInteractable(flag: false);
			SingletonMonoBehaviour<PlayAreaManager>.Instance.RemoveLaserNeed(this);
		}

		protected override void ShutdownOnDestroy()
		{
			SingletonMonoBehaviour<PlayAreaManager>.Instance.RemoveLaserNeed(this);
		}

		private void MakeSubscribe()
		{
			SingletonMonoBehaviour<MainMenuManager>.Instance.OnToggleMenu.Subscribe(delegate(bool flag)
			{
				OnMenuToggled(flag);
			}).AddTo(base.gameObject);
			_background.OnLoadedBackground.Subscribe(delegate(TitleBackgroundLoader.TitleBackParam param)
			{
				_logoSprite.sprite = param.LogoSprite;
				if (SingletonMonoBehaviour<MasterManager>.Instance.IsBusy)
				{
					SingletonMonoBehaviour<MasterManager>.Instance.OnToggleBusyProcess.Where((bool flag) => !flag).Take(1).Subscribe(delegate
					{
						TitleInitializeDelay();
					})
						.AddTo(base.gameObject);
				}
				else
				{
					TitleInitializeDelay();
				}
			});
		}

		private void OnMenuToggled(bool flag)
		{
			_menuManager.ToggleInteractable(!flag);
		}

		private void TitleInitializeDelay()
		{
			Fader.StartFade(ColorDefine.Black, ColorDefine.TransparentBlack, _fadeInTime, isDeactivateOnEnd: true);
			_menuManager.ToggleInteractable(flag: true);
		}

		public void PlaySound(TitleAudioComponent.ClipName clipname)
		{
			_audioComponent.PlaySound(clipname);
		}

		public void ReserveNewGame()
		{
			_audioComponent.PlaySound(TitleAudioComponent.ClipName.GameStart);
			_audioComponent.StopTitleBGM(_bgmFadeTime);
			Fader.StartFade(ColorDefine.TransparentBlack, ColorDefine.Black, _fadeOutTime, isDeactivateOnEnd: false, StartNewGame);
			OnBeforeEndMenu();
		}

		public void ReserveContinueGame()
		{
			_audioComponent.PlaySound(TitleAudioComponent.ClipName.GameStart);
			_audioComponent.StopTitleBGM(_bgmFadeTime);
			Fader.StartFade(ColorDefine.TransparentBlack, ColorDefine.Black, _fadeOutTime, isDeactivateOnEnd: false, StartContinueGame);
			OnBeforeEndMenu();
		}

		public void ReserveSqidGame(int sqid)
		{
			_audioComponent.PlaySound(TitleAudioComponent.ClipName.GameStart);
			_audioComponent.StopTitleBGM(_bgmFadeTime);
			Fader.StartFade(ColorDefine.TransparentBlack, ColorDefine.Black, _fadeOutTime, isDeactivateOnEnd: false, delegate
			{
				SingletonMonoBehaviour<MasterManager>.Instance.StartScenario(sqid);
			});
			OnBeforeEndMenu();
		}

		public void ReserveLoadGame(int fileId)
		{
			_audioComponent.PlaySound(TitleAudioComponent.ClipName.GameStart);
			_audioComponent.StopTitleBGM(_bgmFadeTime);
			Fader.StartFade(ColorDefine.TransparentBlack, ColorDefine.Black, _fadeOutTime, isDeactivateOnEnd: false, delegate
			{
				SingletonMonoBehaviour<MasterManager>.Instance.StartScenarioFromFile(fileId);
			});
			OnBeforeEndMenu();
		}

		public void ReserveBonusScene(SceneDefine scene)
		{
			_audioComponent.PlaySound(TitleAudioComponent.ClipName.GameStart);
			_audioComponent.StopTitleBGM(_bgmFadeTime);
			Fader.StartFade(ColorDefine.TransparentBlack, ColorDefine.Black, _fadeOutTime, isDeactivateOnEnd: false, delegate
			{
				SingletonMonoBehaviour<TransitionManager>.Instance.ChangeActiveSceneAsync(scene);
			});
			OnBeforeEndMenu();
		}

		public void ReserveEndGame()
		{
			_audioComponent.PlaySound(TitleAudioComponent.ClipName.GameStart);
			_audioComponent.StopTitleBGM(_bgmFadeTime);
			Fader.StartFade(ColorDefine.TransparentBlack, ColorDefine.Black, _fadeOutTime, isDeactivateOnEnd: false, QuitGame);
			OnBeforeEndMenu();
		}

		public void OpenLoadMenu()
		{
			SingletonMonoBehaviour<MainMenuManager>.Instance.OpenMenu(MainMenuManager.MenuMode.Load);
		}

		public void OpenConfigMenu()
		{
			SingletonMonoBehaviour<MainMenuManager>.Instance.OpenMenu(MainMenuManager.MenuMode.Config);
		}

		private void StartNewGame()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.StartScenario(SingletonMonoBehaviour<DataManager>.Instance.GeneralData.GetNewGameSqid());
		}

		private void StartContinueGame()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.StartScenarioFromAutoSave();
		}

		private void QuitGame()
		{
			UnityEngine.Application.Quit();
		}
	}
	public class SubTitleMenuChapter : SubMenuBase
	{
		[Header("Components")]
		[SerializeField]
		private ChapterSelectGroup[] _chapterSelectGroups;

		[Header("Parameters")]
		[SerializeField]
		private float _posZFactor;

		[SerializeField]
		private float _rotateFactor;

		[SerializeField]
		private string _confirmKeyNormal = "ConfirmChapter";

		[SerializeField]
		private string _confirmKeyExtra = "ConfirmExtra";

		private IObservable<NewGameData.ChapterSetting> _obChapterSelected;

		protected override void SubmenuStart()
		{
			ChapterSelectGroup[] chapterSelectGroups = _chapterSelectGroups;
			foreach (ChapterSelectGroup chapterSelectGroup in chapterSelectGroups)
			{
				if (_obChapterSelected == null)
				{
					_obChapterSelected = chapterSelectGroup.ChapterSelectedObservable;
				}
				else
				{
					_obChapterSelected = _obChapterSelected.Merge(chapterSelectGroup.ChapterSelectedObservable);
				}
				chapterSelectGroup.SoundableMenu = base.SoundableMenu;
			}
			_obChapterSelected = _obChapterSelected.Share();
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			_obChapterSelected.Subscribe(delegate(NewGameData.ChapterSetting chap)
			{
				string localizeString;
				string localizeString2;
				if (chap.Category == ScenarioListData.Categories.Special)
				{
					localizeString = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(ChapterChecker.GetSpecialSceneLocalizeKey(chap.Index));
					localizeString2 = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_confirmKeyExtra);
				}
				else
				{
					localizeString = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(ChapterChecker.GetChapterLocalizeKey((int)chap.Category, chap.Index));
					localizeString2 = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_confirmKeyNormal);
				}
				ToggleInterractable(flag: false);
				OpenConfirm(string.Format(localizeString2, localizeString), delegate(bool flag)
				{
					if (!flag)
					{
						ToggleInterractable(flag: true);
					}
					else
					{
						OnConfirmed(chap);
					}
				});
			});
		}

		protected override void OnOpenMenu()
		{
			ChapterSelectGroup[] chapterSelectGroups = _chapterSelectGroups;
			for (int i = 0; i < chapterSelectGroups.Length; i++)
			{
				chapterSelectGroups[i].MoveByLocalPosition(_rotateFactor, _posZFactor);
			}
		}

		private void OnConfirmed(NewGameData.ChapterSetting chap)
		{
			if (chap.StartSqid == -1)
			{
				SingletonMonoBehaviour<MainTitleManager>.Instance.ReserveBonusScene(chap.BonusScene);
			}
			else
			{
				SingletonMonoBehaviour<MainTitleManager>.Instance.ReserveSqidGame(chap.StartSqid);
			}
		}
	}
	public class SubTitleMenuConfirm : SubMenuConfirm
	{
	}
	public class SubTitleMenuContinue : SubMenuBase
	{
		[Header("Components")]
		[SerializeField]
		private MenuButtonFloater _buttonContinue;

		[SerializeField]
		private TextMeshProUGUI _textLabel;

		[SerializeField]
		private Image _imageThumgnail;

		private bool _uiInitialized;

		protected override void SubmenuStart()
		{
			_buttonContinue.ClickObservable.Subscribe(delegate
			{
				SingletonMonoBehaviour<MainTitleManager>.Instance.ReserveContinueGame();
			});
			_buttonContinue.AcceptedForcusObservable.Subscribe(delegate
			{
				if (base.SoundableMenu != null)
				{
					base.SoundableMenu.PlaySeSelect();
				}
			}).AddTo(base.gameObject);
			_buttonContinue.PressDownErrorObservable.Subscribe(delegate
			{
				if (base.SoundableMenu != null)
				{
					base.SoundableMenu.PlaySeError();
				}
			}).AddTo(base.gameObject);
		}

		protected override void OnOpenMenu()
		{
			if (!_uiInitialized)
			{
				_uiInitialized = true;
				UpdateFileInfos();
			}
		}

		private void UpdateFileInfos()
		{
			GameFileSave.Header header = SingletonMonoBehaviour<GameData>.Instance.FindHeaders()[0];
			if (header.IsEmpty || header.IsCorrupted)
			{
				if (header.IsCorrupted)
				{
					_textLabel.text = "<sprite=0><sprite=0><sprite=0><sprite=0><sprite=0>";
				}
				else
				{
					_textLabel.text = "No Auto Save";
				}
				_imageThumgnail.enabled = false;
				_buttonContinue.ToggleEnabled(flag: false);
				_buttonContinue.ButtonComponent.targetGraphic.color = ColorDefine.White.WithAlpha(0.5f);
			}
			else
			{
				_textLabel.text = ChapterChecker.GetFormattedChapterNumber(header.SequenceID);
				if (IsNoThumbSequence(header.SequenceID))
				{
					_imageThumgnail.enabled = false;
					return;
				}
				_imageThumgnail.sprite = FindSaveThumbnailSprite(header.SequenceID);
				_imageThumgnail.enabled = _imageThumgnail.sprite != null;
			}
		}

		private Sprite FindSaveThumbnailSprite(int id)
		{
			Sprite sprite = SingletonMonoBehaviour<DataManager>.Instance.FindSaveThumbnailSprite(id);
			if (sprite == null)
			{
				return null;
			}
			return sprite;
		}

		private bool IsNoThumbSequence(int sqid)
		{
			if (sqid != 10000)
			{
				return sqid == 20000;
			}
			return true;
		}
	}
	public class SubTitleMenuFile : SubMenuFile
	{
		protected override void StartLoadGame(int fileId)
		{
			SingletonMonoBehaviour<MainTitleManager>.Instance.ReserveLoadGame(fileId);
		}
	}
	public class SubTitleMenuLanguage : SubMenuBase
	{
		private const string KeyLanguage = "Language";

		[Header("Prefabs")]
		[SerializeField]
		[PrefabField]
		private LanguageSelectButton _prefabButton;

		[Header("Components")]
		[SerializeField]
		private Transform _targetAttach;

		private bool _isConfigValueChanged;

		private IObservable<GameDefine.Languages> _obSelected;

		protected override void SubmenuStart()
		{
			for (int i = 0; i < 5; i++)
			{
				GameDefine.Languages language = (GameDefine.Languages)i;
				if (!CheckAvailableLanguage(language))
				{
					continue;
				}
				LanguageSelectButton languageSelectButton = UnityEngine.Object.Instantiate(_prefabButton, _targetAttach, worldPositionStays: false);
				languageSelectButton.targetLang = language;
				languageSelectButton.Label.text = GetLanguageString(language);
				IObservable<GameDefine.Languages> observable = languageSelectButton.Button.ClickObservable.Select((Unit _) => language);
				if (_obSelected == null)
				{
					_obSelected = observable;
				}
				else
				{
					_obSelected = _obSelected.Merge(observable);
				}
				languageSelectButton.Button.ClickObservable.Subscribe(delegate
				{
					if (base.SoundableMenu != null)
					{
						base.SoundableMenu.PlaySeDecide();
					}
				}).AddTo(base.gameObject);
				languageSelectButton.Button.AcceptedForcusObservable.Subscribe(delegate
				{
					if (base.SoundableMenu != null)
					{
						base.SoundableMenu.PlaySeSelect();
					}
				}).AddTo(base.gameObject);
			}
			_obSelected = _obSelected.Share();
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			_obSelected.Subscribe(delegate(GameDefine.Languages language)
			{
				SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value = language;
				_isConfigValueChanged = true;
			});
		}

		private bool CheckAvailableLanguage(GameDefine.Languages lang)
		{
			if (GameDefine.IsLanguageImplemented(lang))
			{
				return !SingletonMonoBehaviour<PlayAreaManager>.Instance.IsLanguageProhibited(lang);
			}
			return false;
		}

		private string GetLanguageString(GameDefine.Languages lang)
		{
			return SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString("Language", lang);
		}

		protected override void OnCloseMenu()
		{
			if (_isConfigValueChanged)
			{
				SingletonMonoBehaviour<GameData>.Instance.SaveConfigData();
				_isConfigValueChanged = false;
			}
		}
	}
	public class SubTitleMenuNewGame : SubMenuBase
	{
		[Header("Components")]
		[SerializeField]
		private MenuButtonFloater _theButton;

		private bool IsFirstBoot => !SingletonMonoBehaviour<GameData>.Instance.GetFlag(GameFlags.Route1Chapter0);

		protected override void SubmenuStart()
		{
			if (IsFirstBoot)
			{
				_theButton.ClickObservable.Subscribe(delegate
				{
					SingletonMonoBehaviour<MainTitleManager>.Instance.ReserveNewGame();
					CloseMenu();
				});
				_theButton.AcceptedForcusObservable.Subscribe(delegate
				{
					if (base.SoundableMenu != null)
					{
						base.SoundableMenu.PlaySeSelect();
					}
				}).AddTo(base.gameObject);
			}
			else
			{
				_theButton.gameObject.SetActive(value: false);
			}
		}
	}
	public class SubTitleMenuQuit : SubMenuBase
	{
		[Header("Components")]
		[SerializeField]
		private MenuButtonFloater _theButton;

		protected override void SubmenuStart()
		{
			_theButton.ClickObservable.Subscribe(delegate
			{
				SingletonMonoBehaviour<MainTitleManager>.Instance.ReserveEndGame();
				CloseMenu();
			});
			_theButton.AcceptedForcusObservable.Subscribe(delegate
			{
				if (base.SoundableMenu != null)
				{
					base.SoundableMenu.PlaySeSelect();
				}
			}).AddTo(base.gameObject);
		}
	}
	public class SubTitleMenuSkipNotify : SubMenuBase
	{
		[Header("Components")]
		[SerializeField]
		private MenuButtonFloater _theButton;

		protected override void SubmenuStart()
		{
			_theButton.ClickObservable.Subscribe(delegate
			{
				if (base.SoundableMenu != null)
				{
					base.SoundableMenu.PlaySeDecide();
				}
				SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.SkipNoifyShowed, value: true);
				SingletonMonoBehaviour<MainTitleManager>.Instance.ReserveContinueGame();
			});
			_theButton.AcceptedForcusObservable.Subscribe(delegate
			{
				if (base.SoundableMenu != null)
				{
					base.SoundableMenu.PlaySeSelect();
				}
			}).AddTo(base.gameObject);
		}

		protected override void OnCloseMenu()
		{
		}
	}
	public class TitleMenuController : MonoBehaviour, ISoundableMenu
	{
		private enum TitleMenuType
		{
			Continue,
			Load,
			Chapter,
			Config,
			Language,
			Quit,
			NewGame,
			Help,
			SkipNotify,
			MAX
		}

		[Header("Components - General")]
		[SerializeField]
		private MainTitleManager _mainTitle;

		[SerializeField]
		private CanvasGroup _canvasGroup;

		[SerializeField]
		private AudioSource _uiSoundSource;

		[SerializeField]
		private Animator _animatorLogo;

		[Header("Components - Submenus")]
		[SerializeField]
		[EnumLabel(typeof(TitleMenuType))]
		private MenuButtonFloater[] _titleButtons;

		[SerializeField]
		[EnumLabel(typeof(TitleMenuType))]
		private SubMenuBase[] _submenus;

		[Header("Components - Confirm")]
		[SerializeField]
		private SubMenuConfirm _subMenuConfirm;

		[Header("Components - Special")]
		[SerializeField]
		private GameObject _primaryMenuSetNormal;

		[SerializeField]
		private GameObject _primaryMenuSetFirst;

		[SerializeField]
		private GameObject _secondaryMenuSetNormal;

		[Header("Marameters")]
		[SerializeField]
		private TitleMenuType _initialSubMenu;

		[SerializeField]
		private TitleMenuType _initialSubMenuFirst;

		[SerializeField]
		private TitleMenuType _initialSubMenuContinuous;

		[SerializeField]
		private TitleMenuType _initialSubMenuSkipNotify;

		private TitleMenuType _currentInitialMenu = TitleMenuType.MAX;

		private TitleMenuType _currentSubMenu = TitleMenuType.MAX;

		private bool IsFirstBoot => !SingletonMonoBehaviour<GameData>.Instance.GetFlag(GameFlags.Route1Chapter0);

		private bool IsSkipNotifyNeeded
		{
			get
			{
				if (SingletonMonoBehaviour<GameData>.Instance.GetFlag(GameFlags.EndingNormal))
				{
					return !SingletonMonoBehaviour<GameData>.Instance.GetFlag(GameFlags.SkipNoifyShowed);
				}
				return false;
			}
		}

		private bool IsSessionTitleShowed
		{
			get
			{
				return SingletonMonoBehaviour<LocalData>.Instance.IsSessionTitleShowed;
			}
			set
			{
				SingletonMonoBehaviour<LocalData>.Instance.IsSessionTitleShowed = value;
			}
		}

		public bool IsOpenedConfirm => _subMenuConfirm.IsVisible;

		public bool IsRootMenu
		{
			get
			{
				if (_currentSubMenu != TitleMenuType.NewGame && _currentSubMenu != TitleMenuType.SkipNotify)
				{
					return _currentSubMenu == _currentInitialMenu;
				}
				return true;
			}
		}

		private void Start()
		{
			for (int i = 0; i < _titleButtons.Length; i++)
			{
				MenuButtonFloater menuButtonFloater = _titleButtons[i];
				if (!(menuButtonFloater == null) && i < 9)
				{
					TitleMenuType type = (TitleMenuType)i;
					menuButtonFloater.ClickObservable.Subscribe(delegate
					{
						PlaySeDecide();
						OnSelectMenu(type);
					}).AddTo(base.gameObject);
					menuButtonFloater.AcceptedForcusObservable.Subscribe(delegate
					{
						PlaySeSelect();
					}).AddTo(base.gameObject);
				}
			}
			SubMenuBase[] submenus = _submenus;
			foreach (SubMenuBase subMenuBase in submenus)
			{
				if (!(subMenuBase == null))
				{
					subMenuBase.SetSoundableMenu(this);
					subMenuBase.EndSubmenuObservable.Subscribe(delegate
					{
						ToggleSubMenu(_currentInitialMenu);
					});
					subMenuBase.ConfirmRequestedObservable.Subscribe(delegate(SubMenuBase.ConfirmParam conf)
					{
						OpenConfirm(conf);
					});
				}
			}
			_subMenuConfirm.SetSoundableMenu(this);
			if (IsFirstBoot)
			{
				_primaryMenuSetNormal.SetActive(value: false);
				_primaryMenuSetFirst.SetActive(value: true);
				_currentInitialMenu = _initialSubMenuFirst;
				Observable.NextFrame().Subscribe(delegate
				{
					ToggleSubMenu(_initialSubMenuFirst);
				});
			}
			else if (IsSkipNotifyNeeded)
			{
				IsSessionTitleShowed = true;
				_primaryMenuSetNormal.SetActive(value: false);
				_primaryMenuSetFirst.SetActive(value: false);
				_secondaryMenuSetNormal.SetActive(value: false);
				_currentInitialMenu = _initialSubMenuSkipNotify;
				Observable.NextFrame().Subscribe(delegate
				{
					ToggleSubMenu(_initialSubMenuSkipNotify);
				});
			}
			else if (!IsSessionTitleShowed)
			{
				IsSessionTitleShowed = true;
				_primaryMenuSetNormal.SetActive(value: true);
				_primaryMenuSetFirst.SetActive(value: false);
				_currentInitialMenu = _initialSubMenuContinuous;
				Observable.NextFrame().Subscribe(delegate
				{
					ToggleSubMenu(_initialSubMenu);
				});
			}
			else
			{
				_primaryMenuSetNormal.SetActive(value: true);
				_primaryMenuSetFirst.SetActive(value: false);
				_currentInitialMenu = _initialSubMenuContinuous;
				Observable.NextFrame().Subscribe(delegate
				{
					ToggleSubMenu(_initialSubMenuContinuous);
				});
			}
		}

		private void OnSelectMenu(TitleMenuType type)
		{
			if (HasSubMenu(type))
			{
				ToggleSubMenu(type);
			}
			else if (type == TitleMenuType.Config)
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.OpenMenu(MainMenuManager.MenuMode.Config);
			}
		}

		private void ToggleSubMenu(TitleMenuType type)
		{
			if (_currentSubMenu == type)
			{
				return;
			}
			if (_subMenuConfirm.IsVisible)
			{
				ForceCloseConfirm();
			}
			if (_currentSubMenu != TitleMenuType.MAX)
			{
				MenuButtonFloater selectButton = GetSelectButton(_currentSubMenu);
				if (selectButton != null)
				{
					selectButton.ToggleEnabled(flag: true);
				}
				GetSubMenu(_currentSubMenu).SetVisible(visible: false);
			}
			_currentSubMenu = type;
			_animatorLogo.SetInteger("MenuIndex", (int)type);
			if (_currentSubMenu != TitleMenuType.MAX)
			{
				MenuButtonFloater selectButton2 = GetSelectButton(_currentSubMenu);
				if (selectButton2 != null)
				{
					selectButton2.ToggleEnabled(flag: false);
				}
				GetSubMenu(_currentSubMenu).SetVisible(visible: true);
			}
		}

		private SubMenuBase GetSubMenu(TitleMenuType type)
		{
			return _submenus[(int)type];
		}

		private bool HasSubMenu(TitleMenuType type)
		{
			return _submenus[(int)type] != null;
		}

		private MenuButtonFloater GetSelectButton(TitleMenuType type)
		{
			return _titleButtons[(int)type];
		}

		public void ToggleInteractable(bool flag)
		{
			_canvasGroup.interactable = flag;
			_canvasGroup.blocksRaycasts = flag;
		}

		public void OpenConfirm(SubMenuBase.ConfirmParam conf)
		{
			PlaySeConfirm();
			_subMenuConfirm.SetVisible(visible: true);
			_subMenuConfirm.SetParam(conf);
		}

		public void ForceCloseConfirm()
		{
			_subMenuConfirm.OnCancelButton();
		}

		public void OnPressBackButton()
		{
			if (!IsRootMenu)
			{
				if (IsOpenedConfirm)
				{
					ForceCloseConfirm();
				}
				else if (OnCancelSubMenu())
				{
					PlaySeCancel();
					ToggleSubMenu(_currentInitialMenu);
				}
			}
		}

		private bool OnCancelSubMenu()
		{
			SubMenuBase subMenu = GetSubMenu(_currentSubMenu);
			if (subMenu == null)
			{
				return true;
			}
			return subMenu.OnCancelButton();
		}

		public void PlaySeOpen()
		{
		}

		public void PlaySeClose()
		{
		}

		public void PlaySeSelect()
		{
			_mainTitle.AudioComponent.PlaySound(TitleAudioComponent.ClipName.Select);
		}

		public void PlaySeDecide()
		{
			_mainTitle.AudioComponent.PlaySound(TitleAudioComponent.ClipName.Decide);
		}

		public void PlaySeConfirm()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Confirm, _uiSoundSource);
		}

		public void PlaySeCancel()
		{
			_mainTitle.AudioComponent.PlaySound(TitleAudioComponent.ClipName.Cancel);
		}

		public void PlaySeError()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Error, _uiSoundSource);
		}

		public void PlaySePaging()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Message_Log, _uiSoundSource);
		}

		public void PlaySeScrolling()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Message_Log, _uiSoundSource);
		}
	}
	public class TitleMenuInput : UpdateableComponent
	{
		[SerializeField]
		private TitleMenuController _controller;

		public bool IsRootMenu => _controller.IsRootMenu;

		private GameInputManager input => SingletonMonoBehaviour<GameInputManager>.Instance;

		public override void OnUpdate(float delta)
		{
			if (input.IsMovileDevice)
			{
				if (input.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.DeviceBack))
				{
					if (IsRootMenu)
					{
						input.OnBackFromRoot();
					}
					else
					{
						OnCancelButtonPressed();
					}
				}
				else if (input.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.Cancel))
				{
					OnCancelButtonPressed();
				}
			}
			else if (input.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.Cancel))
			{
				OnCancelButtonPressed();
			}
		}

		public void OnCancelButtonPressed()
		{
			_controller.OnPressBackButton();
		}
	}
	public class TitleVersionText : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private TextMeshProUGUI m_textMesh;

		[Header("Parameters")]
		[SerializeField]
		private string m_textCopyright = string.Empty;

		[SerializeField]
		private string m_textVersionPrefix = string.Empty;

		private void Start()
		{
			m_textMesh.text = m_textCopyright + "\n" + m_textVersionPrefix + UnityEngine.Application.version;
		}
	}
	public class ChapterEndController : MonoBehaviour
	{
		[Header("External Components")]
		[SerializeField]
		private ChapterEndObject _endObject;

		[Header("Parameters - Time")]
		[SerializeField]
		private float _timeFirstWait = 1.5f;

		[SerializeField]
		private float _timeStartFade = 0.5f;

		[SerializeField]
		private float _timeShowing = 5f;

		[SerializeField]
		private float _timeEndFade = 2f;

		[SerializeField]
		private double _waitBeforeConfirm = 1.0;

		[SerializeField]
		private double _waitAfterSave = 1.0;

		[Header("Parameters - Texts")]
		[SerializeField]
		private string _keyConfirm = "ConfirmEndChapterSave";

		public bool SkipSubtitle;

		public bool SkipConfirm;

		private Subject<Unit> _subjectCompleteStartFade = new Subject<Unit>();

		private Subject<Unit> _subjectCompleteEndFade = new Subject<Unit>();

		private Subject<Unit> _subjectEndConfirm = new Subject<Unit>();

		private void Start()
		{
			_endObject.SetAlpha(0f);
			if (SingletonMonoBehaviour<TransitionManager>.Instance.CurrentScene.buildIndex == base.gameObject.scene.buildIndex)
			{
				EnterSceneDoing();
				Observable.TimerFrame(6).Delay(TimeSpan.FromSeconds(_timeFirstWait)).Subscribe(delegate
				{
					FirstPrepare();
				})
					.AddTo(base.gameObject);
			}
			else
			{
				IObservable<Scene> source = SingletonMonoBehaviour<TransitionManager>.Instance.OnCompleteTransition.Where((Scene scene) => scene.buildIndex == base.gameObject.scene.buildIndex).Share();
				source.Subscribe(delegate
				{
					EnterSceneDoing();
				}).AddTo(base.gameObject);
				source.DelayFrame(6).Delay(TimeSpan.FromSeconds(_timeFirstWait)).Subscribe(delegate
				{
					FirstPrepare();
				})
					.AddTo(base.gameObject);
			}
			_subjectCompleteStartFade.SelectMany(Observable.FromMicroCoroutine((CancellationToken _) => RoutineWaitingShowing())).Subscribe(delegate
			{
				EndFade();
			}).AddTo(base.gameObject);
			_subjectCompleteEndFade.Delay(TimeSpan.FromSeconds(_waitBeforeConfirm)).Subscribe(delegate
			{
				OpenSaveConfirm();
			}).AddTo(base.gameObject);
			_subjectEndConfirm.Delay(TimeSpan.FromSeconds(_waitAfterSave)).Subscribe(delegate
			{
				CleanUp();
			}).AddTo(base.gameObject);
		}

		private void EnterSceneDoing()
		{
			SingletonMonoBehaviour<PlayAreaManager>.Instance.SetClearColor(ColorDefine.Black);
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.SetColour(ColorDefine.Black);
			SingletonMonoBehaviour<MainMenuManager>.Instance.IsProhibitByCommand = true;
			SingletonMonoBehaviour<LocalData>.Instance.ChangeCharacter(GameDefine.CharaID.UNKNOWN);
			if (SingletonMonoBehaviour<MainPosition>.HasInstance)
			{
				MainPosition.MainTransform.position = Vector3.zero;
				MainPosition.MainTransform.rotation = Quaternion.identity;
				MainPosition.WindowPositioner.IsFixedToFront = true;
				MainPosition.WindowPositioner.FrontFixYaw = 0f;
				MainPosition.WindowPositioner.IsFixVertical = false;
			}
			if (SingletonMonoBehaviour<InGameManager>.HasInstance)
			{
				FindParameter();
				if (!SkipSubtitle)
				{
					_endObject.SetChapterTextBySqid(InGameManager.Timeline.LoadedScenarioID);
				}
			}
		}

		private void FindParameter()
		{
			if (!(InGameManager.Timeline.WaitingCommand is CommandSceneToChapterEnd commandSceneToChapterEnd))
			{
				UnityEngine.Debug.LogWarning("OOPS: Chapter End Command Not Found");
				return;
			}
			SkipSubtitle = commandSceneToChapterEnd.SkipSubtitle;
			SkipConfirm = commandSceneToChapterEnd.SkipConfirm;
		}

		private void FirstPrepare()
		{
			if (SingletonMonoBehaviour<InGameManager>.HasInstance)
			{
				InGameManager.Timeline.MessageProcessor.SetIndigaterVisible(flag: false);
			}
			if (SkipSubtitle)
			{
				OpenSaveConfirm();
			}
			else
			{
				StartFade();
			}
		}

		private void StartFade()
		{
			_endObject.SetAlpha(1f);
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.StartFade(ColorDefine.Black, ColorDefine.TransparentBlack, _timeStartFade, isDeactivateOnEnd: true, delegate
			{
				_subjectCompleteStartFade.OnNext(Unit.Default);
			});
		}

		private IEnumerator RoutineWaitingShowing()
		{
			Common.Timer _timer = new Common.Timer(_timeShowing);
			while (!_timer.IsTimeUp)
			{
				yield return null;
				_timer.Update(Time.deltaTime);
				if (SingletonMonoBehaviour<GameInputManager>.Instance.GetVRButtonDown(SingletonMonoBehaviour<GameInputManager>.Instance.CurrentMainHand, VRDeviceDefine.Buttons.MainAction))
				{
					_timer.SetToTimeup();
				}
			}
		}

		private void EndFade()
		{
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.StartFade(ColorDefine.Black, _timeEndFade, isDeactivateOnEnd: false, delegate
			{
				_subjectCompleteEndFade.OnNext(Unit.Default);
			});
		}

		private void OpenSaveConfirm()
		{
			if (SkipConfirm)
			{
				CleanUp();
				return;
			}
			SingletonMonoBehaviour<MainMenuManager>.Instance.OpenMenu(MainMenuManager.MenuMode.Blank);
			SingletonMonoBehaviour<MainMenuManager>.Instance.OpenConfirm(SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_keyConfirm), OnDecideConfirm);
			SingletonMonoBehaviour<MainMenuManager>.Instance.OnToggleMenu.Select((bool flag) => !flag).First().Subscribe(delegate
			{
				OnCloseMenu();
			})
				.AddTo(base.gameObject);
		}

		private void OnDecideConfirm(bool isOk)
		{
			if (isOk)
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.SetMenuMode(MainMenuManager.MenuMode.Save);
			}
			else
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.CloseMenu();
			}
		}

		private void OnCloseMenu()
		{
			_subjectEndConfirm.OnNext(Unit.Default);
		}

		private void CleanUp()
		{
			if (SingletonMonoBehaviour<MainMenuManager>.HasInstance)
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.IsProhibitByCommand = false;
			}
			if (SingletonMonoBehaviour<MainPosition>.HasInstance)
			{
				MainPosition.WindowPositioner.IsFixedToFront = false;
			}
			_endObject.SetAlpha(0f);
			SpecialSceneHelper.EndSpecialScene();
		}
	}
	public class ChapterEndObject : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private TextMeshPro _chapterText;

		[SerializeField]
		private SpriteRenderer[] _skinSprite;

		public void SetChapterTextBySqid(int sqid)
		{
			_chapterText.text = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(ChapterChecker.GetChapterLocalizeKey(sqid));
		}

		public void SetAlpha(float alpha)
		{
			int num = _skinSprite.Length;
			for (int i = 0; i < num; i++)
			{
				SpriteRenderer obj = _skinSprite[i];
				obj.color = obj.color.WithAlpha(alpha);
			}
			_chapterText.color = _chapterText.color.WithAlpha(alpha);
		}
	}
	public class ChapterStartController : MonoBehaviour
	{
		[Header("Parameters - Time")]
		[SerializeField]
		private float _intervalShake = 0.08f;

		[SerializeField]
		private float _timeToFadeOut = 5f;

		[SerializeField]
		private float _timeToEnd = 2f;

		private AdvBackground _thisBackground;

		private BaseProp _prop;

		private void Start()
		{
			_thisBackground = GetComponent<AdvBackground>();
			_prop = _thisBackground.DynamicProps.GetPropByIndex(0);
			_prop.SetVisible(flag: true);
			if (SingletonMonoBehaviour<MainPosition>.HasInstance)
			{
				MainPosition.MainTransform.position = Vector3.zero;
				MainPosition.MainTransform.rotation = Quaternion.identity;
			}
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.StartFade(ColorDefine.TransparentBlack, 0f, isDeactivateOnEnd: true);
			Observable.NextFrame().Subscribe(delegate
			{
				StartAnimations();
			}).AddTo(base.gameObject);
		}

		private void StartAnimations()
		{
			int shakeActionIndex = _prop.GetPropAction("StartShake").Index;
			if (SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID == -1)
			{
				_prop.ActionPropAnimation(1);
			}
			else
			{
				_prop.ActionPropAnimation(ChapterChecker.GetChapter(SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID));
			}
			_prop.ActionPropAnimation("FadeIn");
			Observable.Interval(TimeSpan.FromSeconds(_intervalShake)).Subscribe(delegate
			{
				_prop.ActionPropAnimation(shakeActionIndex);
			}).AddTo(base.gameObject);
			Observable.Timer(TimeSpan.FromSeconds(_timeToFadeOut)).First().Subscribe(delegate
			{
				FadeOutToNext();
			})
				.AddTo(base.gameObject);
		}

		private void FadeOutToNext()
		{
			_prop.ActionPropAnimation("FadeOut");
			Observable.Timer(TimeSpan.FromSeconds(_timeToEnd)).First().Subscribe(delegate
			{
				SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.SetColour(ColorDefine.Black);
				SpecialSceneHelper.EndSpecialScene();
			})
				.AddTo(base.gameObject);
		}
	}
	public class ChapterTextProp : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private Transform _targetMove;

		[SerializeField]
		private TextMeshPro _textComponent;

		[Header("Parameters - Shake")]
		[SerializeField]
		private float _shakeSize = 1.2f;

		private DynamicProp _prop;

		private void Awake()
		{
			_prop = GetComponent<DynamicProp>();
		}

		private void Start()
		{
			int shakeActionIndex = _prop.GetPropAction("StartShake").Index;
			_prop.OnAction.Where((PropActionParam action) => action.Index <= 9).Subscribe(delegate(PropActionParam action)
			{
				_textComponent.text = $"{action.Index}";
			}).AddTo(this);
			_prop.OnAction.Where((PropActionParam action) => action.Index == shakeActionIndex).Subscribe(delegate
			{
				_targetMove.localPosition = new Vector3(_shakeSize * RandomPow4(), _shakeSize * RandomPow4(), 0f);
			}).AddTo(this);
		}

		private float RandomPow4()
		{
			return (UnityEngine.Random.Range(0f, 1f) + UnityEngine.Random.Range(0f, 1f) + UnityEngine.Random.Range(0f, 1f) + UnityEngine.Random.Range(0f, 1f)) / 4f - 0.5f;
		}
	}
	public class StartFirstEnding : MonoBehaviour
	{
		[SerializeField]
		private float EndingCameraFarClipPlane = 3000f;

		private Camera MainCamera;

		private float DefaultFarClipPlane;

		private void Start()
		{
			MainCamera = SingletonMonoBehaviour<PlayAreaManager>.Instance.EyeCamera;
			DefaultFarClipPlane = MainCamera.farClipPlane;
			MainCamera.farClipPlane = EndingCameraFarClipPlane;
		}

		private void OnDestroy()
		{
			MainCamera.farClipPlane = DefaultFarClipPlane;
		}
	}
	public class FirstHelpPropController : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		[NotEditable]
		private DynamicProp _prop;

		[SerializeField]
		private Image _targetImage;

		[SerializeField]
		private TextMeshProUGUI _targetText;

		[Header("Parameters - Key")]
		[SerializeField]
		private string _spriteKeyPrefix = "Help.";

		[SerializeField]
		private string _triggerKey = "Help.TriggerNext";

		private void Start()
		{
			_prop.ChangeVisibleObservable.Where((bool flag) => flag).Take(1).Subscribe(delegate
			{
				string key = _spriteKeyPrefix + SingletonMonoBehaviour<PlayAreaManager>.Instance.CurrentDeviceType;
				_targetImage.sprite = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeSprite(key);
				_targetText.text = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_triggerKey);
			})
				.AddTo(base.gameObject);
		}
	}
	public class FinalKnifeController : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		[NotEditable]
		private BaseProp _prop;

		[SerializeField]
		private Collider _knifeCollider;

		private void Awake()
		{
			if (_knifeCollider == null)
			{
				UnityEngine.Debug.LogError("Knife Collider is not defined");
				return;
			}
			_prop.OnAction.Take(1).Subscribe(delegate
			{
				SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.SkipLatestValueOnSubscribe().Subscribe(delegate(VRDeviceDefine.HandType handType)
				{
					AvaterTrackedHandObject avaterTrackedHandObject = null;
					avaterTrackedHandObject = ((handType != 0) ? MainPosition.Avater.AvaterResources.TrackedHandRightObject : MainPosition.Avater.AvaterResources.TrackedHandLeftObject);
					Transform nodeTransform = avaterTrackedHandObject.GetNodeTransform(AvaterTrackedHandObject.Node.TrackedGrabPivot);
					_prop.AttachToTransform(nodeTransform, isStay: false);
				}).AddTo(base.gameObject);
			});
			_prop.OnAction.Take(1).Subscribe(delegate
			{
				_knifeCollider.gameObject.name = "KNIFECOLLIDER";
				Rigidbody rigidbody = base.gameObject.AddComponent<Rigidbody>();
				rigidbody.useGravity = false;
				rigidbody.isKinematic = true;
			});
			if (SingletonMonoBehaviour<MainMenuManager>.HasInstance)
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.OnToggleMenu.Subscribe(delegate(bool isOpen)
				{
					_prop.SetVisible(!isOpen);
				}).AddTo(base.gameObject);
			}
		}
	}
	public class FinalSelectionController : MonoBehaviour
	{
		public enum SelfColliderTypes
		{
			Body,
			HandLeft,
			HandRight
		}

		[Header("Prefabs")]
		[SerializeField]
		[PrefabField]
		private GameObject _prefabNKCollider;

		[SerializeField]
		[PrefabField]
		[EnumLabel(typeof(SelfColliderTypes))]
		private GameObject[] _prefabSelfColliders;

		[Header("Components")]
		[SerializeField]
		[NotEditable]
		private BaseProp _prop;

		[Header("Parameters - Hand Motion")]
		[SerializeField]
		private int _motionIdNormal;

		[SerializeField]
		private int _motionIdSelf;

		[SerializeField]
		private int _motionIdUnequipped;

		[Header("Parameters - For Quest")]
		[SerializeField]
		private float _nkYOffset = -1.6f;

		[SerializeField]
		private float _nkDistance = 0.2f;

		[SerializeField]
		private float _nkScale = 0.2857143f;

		[SerializeField]
		private float _handScale = 0.71428573f;

		[SerializeField]
		private float _motionToggleAngle = 75f;

		private bool _isSelfStabbable;

		private GameObject _obNKCollider;

		private GameObject[] _obSelfColliders;

		private ReactiveProperty<bool> _reactiveSelfPointing;

		private bool IsTrueRouteAvailable
		{
			get
			{
				if (SingletonMonoBehaviour<GameData>.Instance.GetFlag(GameFlags.EndingTougoku) && SingletonMonoBehaviour<GameData>.Instance.GetFlag(GameFlags.EndingKageyama) && SingletonMonoBehaviour<GameData>.Instance.GetFlag(GameFlags.EndingMorozumi) && SingletonMonoBehaviour<GameData>.Instance.GetFlag(GameFlags.EndingMachikouji))
				{
					return SingletonMonoBehaviour<GameData>.Instance.GetFlag(GameFlags.EndingMomono);
				}
				return false;
			}
		}

		private AvaterTrackedHandObject _trackedHandPrefferedObject
		{
			get
			{
				if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.Value != 0)
				{
					return MainPosition.Avater.AvaterResources.TrackedHandRightObject;
				}
				return MainPosition.Avater.AvaterResources.TrackedHandLeftObject;
			}
		}

		private AvaterTrackedHandObject _trackedHandOppositeObject
		{
			get
			{
				if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.Value != 0)
				{
					return MainPosition.Avater.AvaterResources.TrackedHandLeftObject;
				}
				return MainPosition.Avater.AvaterResources.TrackedHandRightObject;
			}
		}

		private AvaterTrackedHandLoader _trackedHandPrefferedLoader
		{
			get
			{
				if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.Value != 0)
				{
					return MainPosition.Avater.AvaterResources.TrackedHandRightLoader;
				}
				return MainPosition.Avater.AvaterResources.TrackedHandLeftLoader;
			}
		}

		private AvaterTrackedHandLoader _trackedHandOppositeLoader
		{
			get
			{
				if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.Value != 0)
				{
					return MainPosition.Avater.AvaterResources.TrackedHandLeftLoader;
				}
				return MainPosition.Avater.AvaterResources.TrackedHandRightLoader;
			}
		}

		private void Awake()
		{
			_prop.OnAction.Where((PropActionParam param) => param.Index == 0).Subscribe(delegate
			{
				_isSelfStabbable = IsTrueRouteAvailable;
				SingletonMonoBehaviour<LocalData>.Instance.LastSelectionIndex = (_isSelfStabbable ? 1 : 0);
			});
			(from param in _prop.OnAction
				where param.Index == 1
				select param into _
				where !SingletonMonoBehaviour<PlayAreaManager>.Instance.InputVR.UseTrackedHands
				select _).Subscribe(delegate
			{
				(from index in InGameManager.Timeline.SelectionProcessor.PointerEnterSelectionObservable.TakeUntil(InGameManager.Timeline.SelectionProcessor.EndSelectionObservable)
					where index == 1
					select index).Subscribe(delegate
				{
					MainPosition.Avater.SetRotationEnableWithFade(PlayerAvater.AvaterParts.Hand, PlayerAvater.AvaterTrackTypes.HeadPositionAndRotation, 0.2f);
					MainPosition.Avater.AvaterResources.TrackedHandRightObject.PlayAnimation(_motionIdSelf, isFade: false, isSkipAnimation: true);
				}).AddTo(base.gameObject);
				(from index in InGameManager.Timeline.SelectionProcessor.PointerExitSelectionObservable.TakeUntil(InGameManager.Timeline.SelectionProcessor.EndSelectionObservable)
					where index == 1
					select index).Subscribe(delegate
				{
					MainPosition.Avater.SetRotationEnableWithFade(PlayerAvater.AvaterParts.Hand, PlayerAvater.AvaterTrackTypes.HandPositionAndRotation, 0.2f);
					MainPosition.Avater.AvaterResources.TrackedHandRightObject.PlayAnimation(_motionIdNormal, isFade: false, isSkipAnimation: true);
				}).AddTo(base.gameObject);
			});
			IObservable<PropActionParam> source = (from param in _prop.OnAction
				where param.Index == 2
				select param into _
				where SingletonMonoBehaviour<PlayAreaManager>.Instance.InputVR.UseTrackedHands
				select _).Take(1);
			source.Subscribe(delegate
			{
				_reactiveSelfPointing = new ReactiveProperty<bool>(initialValue: false);
				InitNikaidouForQuest();
				InitHandForQuest();
				if (_isSelfStabbable)
				{
					InitKnifePosingUpdationForQuest();
				}
				InGameManager.Timeline.SelectionProcessor.ProhibitLaserInterraction = true;
			});
			source.Delay(TimeSpan.FromSeconds(1.0)).TakeUntilDestroy(base.gameObject).Subscribe(delegate
			{
				InitNKColliderForQuest();
				if (_isSelfStabbable)
				{
					InitSelfColliderForQuest();
				}
			});
		}

		private void InitNikaidouForQuest()
		{
			AdvChara charaNK = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(GameDefine.CharaID.NIKAIDOU);
			if (charaNK == null)
			{
				UnityEngine.Debug.LogError("I cannot find character Nikaidoh");
				return;
			}
			charaNK.Transform.localScale *= _nkScale;
			charaNK.Transform.position = GetNKSpot(_nkYOffset);
			SingletonMonoBehaviour<GameInputManager>.Instance.OnPositionReset.TakeUntil(this.OnDestroyAsObservable()).Subscribe(delegate
			{
				charaNK.Transform.position = GetNKSpot(_nkYOffset);
			});
			(from _ in this.OnDestroyAsObservable()
				where charaNK != null
				select _).Subscribe(delegate
			{
				charaNK.Transform.localScale = Vector3.one;
			});
		}

		private void InitHandForQuest()
		{
			MainPosition.Avater.AvaterResources.TrackedHandLeftObject.transform.localScale *= _handScale;
			MainPosition.Avater.AvaterResources.TrackedHandLeftObject.IsPreventSleeping = true;
			MainPosition.Avater.AvaterResources.TrackedHandRightObject.transform.localScale *= _handScale;
			MainPosition.Avater.AvaterResources.TrackedHandRightObject.IsPreventSleeping = true;
			SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.Where((VRDeviceDefine.HandType handType) => handType == VRDeviceDefine.HandType.Left).Subscribe(delegate
			{
				MainPosition.Avater.AvaterResources.TrackedHandLeftObject.PlayAnimation(GetCurrentMotionId(_reactiveSelfPointing.Value), isFade: false, isSkipAnimation: true);
				MainPosition.Avater.AvaterResources.TrackedHandRightObject.PlayAnimation(_motionIdUnequipped, isFade: false, isSkipAnimation: true);
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.Where((VRDeviceDefine.HandType handType) => handType == VRDeviceDefine.HandType.Right).Subscribe(delegate
			{
				MainPosition.Avater.AvaterResources.TrackedHandLeftObject.PlayAnimation(_motionIdUnequipped, isFade: false, isSkipAnimation: true);
				MainPosition.Avater.AvaterResources.TrackedHandRightObject.PlayAnimation(GetCurrentMotionId(_reactiveSelfPointing.Value), isFade: false, isSkipAnimation: true);
			}).AddTo(base.gameObject);
			(from _ in this.OnDestroyAsObservable()
				where SingletonMonoBehaviour<MainPosition>.HasInstance && MainPosition.Avater.AvaterResources.HasTrackedHands
				select _).Subscribe(delegate
			{
				MainPosition.Avater.AvaterResources.TrackedHandLeftObject.transform.localScale = Vector3.one;
				MainPosition.Avater.AvaterResources.TrackedHandLeftObject.IsPreventSleeping = false;
				MainPosition.Avater.AvaterResources.TrackedHandRightObject.transform.localScale = Vector3.one;
				MainPosition.Avater.AvaterResources.TrackedHandRightObject.IsPreventSleeping = false;
			});
		}

		private void InitNKColliderForQuest()
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(GameDefine.CharaID.NIKAIDOU);
			_obNKCollider = UnityEngine.Object.Instantiate(_prefabNKCollider, chara.Transform, worldPositionStays: false);
			(from collider in _obNKCollider.OnTriggerEnterAsObservable()
				where collider.gameObject.name == "KNIFECOLLIDER"
				select collider).TakeUntil(InGameManager.Timeline.SelectionProcessor.EndSelectionObservable).Subscribe(delegate
			{
				InGameManager.Timeline.SelectionProcessor.ForceSelect(0);
				MainPosition.Avater.AvaterResources.TrackedHandLeftLoader.IsPausedTracking = true;
				MainPosition.Avater.AvaterResources.TrackedHandRightLoader.IsPausedTracking = true;
				StabVibrate();
			}).AddTo(_obNKCollider);
			this.OnDestroyAsObservable().Subscribe(delegate
			{
				if (_obNKCollider != null)
				{
					UnityEngine.Object.Destroy(_obNKCollider);
				}
				if (SingletonMonoBehaviour<MainPosition>.HasInstance)
				{
					MainPosition.Avater.AvaterResources.TrackedHandLeftLoader.IsPausedTracking = false;
					MainPosition.Avater.AvaterResources.TrackedHandRightLoader.IsPausedTracking = false;
				}
			});
		}

		private void InitSelfColliderForQuest()
		{
			int selfLn = _prefabSelfColliders.Length;
			_obSelfColliders = new GameObject[selfLn];
			for (int i = 0; i < selfLn; i++)
			{
				Transform parent = null;
				SelfColliderTypes selfColliderTypes = (SelfColliderTypes)i;
				switch (selfColliderTypes)
				{
				case SelfColliderTypes.Body:
					parent = MainPosition.Avater.AvaterResources.BodyObject.transform;
					break;
				case SelfColliderTypes.HandLeft:
					parent = MainPosition.Avater.AvaterResources.TrackedHandLeftObject.transform;
					break;
				case SelfColliderTypes.HandRight:
					parent = MainPosition.Avater.AvaterResources.TrackedHandRightObject.transform;
					break;
				}
				GameObject instance = UnityEngine.Object.Instantiate(_prefabSelfColliders[i], parent, worldPositionStays: false);
				switch (selfColliderTypes)
				{
				case SelfColliderTypes.Body:
					_reactiveSelfPointing.Subscribe(delegate(bool isSelf)
					{
						instance.SetActive(isSelf);
					});
					break;
				case SelfColliderTypes.HandLeft:
					SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.Select((VRDeviceDefine.HandType handType) => handType != VRDeviceDefine.HandType.Left).Subscribe(delegate(bool isNotKnifeHand)
					{
						instance.SetActive(isNotKnifeHand);
					}).AddTo(base.gameObject);
					break;
				case SelfColliderTypes.HandRight:
					SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.Select((VRDeviceDefine.HandType handType) => handType != VRDeviceDefine.HandType.Right).Subscribe(delegate(bool isNotKnifeHand)
					{
						instance.SetActive(isNotKnifeHand);
					}).AddTo(base.gameObject);
					break;
				}
				(from collider in instance.OnTriggerEnterAsObservable()
					where collider.gameObject.name == "KNIFECOLLIDER"
					select collider).TakeUntil(InGameManager.Timeline.SelectionProcessor.EndSelectionObservable).Subscribe(delegate
				{
					InGameManager.Timeline.SelectionProcessor.ForceSelect(1);
					MainPosition.Avater.AvaterResources.TrackedHandLeftLoader.IsPausedTracking = true;
					MainPosition.Avater.AvaterResources.TrackedHandRightLoader.IsPausedTracking = true;
					StabVibrate();
				}).AddTo(instance);
				_obSelfColliders[i] = instance;
			}
			this.OnDestroyAsObservable().Subscribe(delegate
			{
				for (int j = 0; j < selfLn; j++)
				{
					if (!(_obSelfColliders[j] == null))
					{
						UnityEngine.Object.Destroy(_obSelfColliders[j]);
					}
				}
			});
		}

		private void StabVibrate()
		{
			SingletonMonoBehaviour<GameInputManager>.Instance.Vibrate(SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.Value, 0.4f, 1f);
		}

		private void InitKnifePosingUpdationForQuest()
		{
			SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable.TakeUntil(InGameManager.Timeline.SelectionProcessor.EndSelectionObservable).Subscribe(delegate
			{
				UpdateCheckingSelf();
			}).AddTo(base.gameObject);
			_reactiveSelfPointing.Subscribe(delegate(bool isSelf)
			{
				_trackedHandPrefferedObject.PlayAnimation(GetCurrentMotionId(isSelf), isFade: false, isSkipAnimation: true);
			});
		}

		private void UpdateCheckingSelf()
		{
			Transform headTransform = SingletonMonoBehaviour<PlayAreaManager>.Instance.HeadTransform;
			Transform transform = _trackedHandPrefferedLoader.transform;
			_reactiveSelfPointing.Value = Quaternion.Angle(headTransform.rotation, transform.rotation) >= _motionToggleAngle;
		}

		private Vector3 GetNKSpot(float yOffset)
		{
			Vector3 vector = SingletonMonoBehaviour<MainPosition>.Instance.transform.position + SingletonMonoBehaviour<MainPosition>.Instance.transform.forward * _nkDistance;
			return new Vector3(vector.x, vector.y + yOffset, vector.z);
		}

		private int GetCurrentMotionId(bool isSelf)
		{
			if (!isSelf)
			{
				return _motionIdNormal;
			}
			return _motionIdSelf;
		}
	}
	public class SetLookAtPlayer : MonoBehaviour
	{
		[SerializeField]
		private GenericLookTargetIK genericLookAt;

		private void Start()
		{
			genericLookAt.SetLookAtTransform(MainPosition.MainCamera.transform, isSkip: true);
		}
	}
	public class MomonoShowerGuard : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		[NotEditable]
		private BaseProp _prop;
	}
	[RequireComponent(typeof(SpriteRenderer))]
	public class DemoSpriteSwitcher : MonoBehaviour
	{
		[SerializeField]
		private Sprite m_jpSprite;

		[SerializeField]
		private Sprite m_egSprite;

		private void Start()
		{
			SpriteRenderer component = GetComponent<SpriteRenderer>();
			if (!(component == null))
			{
				if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value == GameDefine.Languages.Japanese)
				{
					component.sprite = m_jpSprite;
				}
				else
				{
					component.sprite = m_egSprite;
				}
			}
		}
	}
	public class EndProto : MonoBehaviour
	{
		private void Start()
		{
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.StartFade(ColorDefine.Black, ColorDefine.TransparentBlack);
		}

		private void MakeSubscribes()
		{
			SingletonMonoBehaviour<GameInputManager>.Instance.OnPositionReset.Subscribe(delegate
			{
				ExitToTitle();
			}).AddTo(base.gameObject);
		}

		private void ExitToTitle()
		{
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.StartFade(ColorDefine.TransparentBlack, ColorDefine.Black, delegate
			{
				SingletonMonoBehaviour<MasterManager>.Instance.ForceToTitle();
			});
		}
	}
	public class SplashScreen : MonoBehaviour
	{
		[SerializeField]
		private Animator _splashAnimator;

		private void Start()
		{
			Observable.NextFrame().Subscribe(delegate
			{
				SingletonMonoBehaviour<PlayAreaManager>.Instance.CheckLanguage();
				SingletonMonoBehaviour<PlayAreaManager>.Instance.StartApplicationPlatformValidate(delegate(bool validated)
				{
					if (!validated)
					{
						UnityEngine.Debug.LogError("<b>FATAL: Platform Validation Failed</b>");
						UnityEngine.Application.Quit();
					}
					else
					{
						StartSplashScreen();
					}
				});
			});
		}

		private void StartSplashScreen()
		{
			VrUtility.OnLoadEnd();
			IObservable<Unit> source = this.UpdateAsObservable().Skip(6).Share();
			source.Take(1).Subscribe(delegate
			{
				SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.SetColour(ColorDefine.TransparentBlack);
				SingletonMonoBehaviour<GameData>.Instance.SystemData.ResetTimeCaches();
			}).AddTo(base.gameObject);
			source.Subscribe(delegate
			{
				_splashAnimator.Update(Time.deltaTime);
			}).AddTo(base.gameObject);
		}

		public void OnEndAnimation()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.ForceToTitle();
		}
	}
	public class Title : MonoBehaviour
	{
		private enum States
		{
			Initalize,
			FadeIn,
			Play,
			FadeOut,
			End
		}

		[Header("Components - Genaral")]
		[SerializeField]
		private TitleAudioComponent _audioComponent;

		[Header("Parameter - Scenario")]
		[SerializeField]
		private int m_scenarioToLoad;

		[Header("Parameter - Other")]
		[SerializeField]
		private float m_fadeoutDuration = 2.25f;

		[Header("Parameter - Text")]
		[SerializeField]
		private TextMeshPro m_subtitleText;

		[SerializeField]
		private string m_subtitleJp = "";

		[SerializeField]
		private string m_subtitleEg = "";

		private States m_state;

		private UIFader Fader => SingletonMonoBehaviour<FadeManager>.Instance.sceneFader;

		private bool IsMenuOpened
		{
			get
			{
				if (SingletonMonoBehaviour<MainMenuManager>.HasInstance)
				{
					return SingletonMonoBehaviour<MainMenuManager>.Instance.IsOpened;
				}
				return false;
			}
		}

		private void Start()
		{
			if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value == GameDefine.Languages.Japanese)
			{
				m_subtitleText.text = m_subtitleJp;
			}
			else
			{
				m_subtitleText.text = m_subtitleEg;
			}
			SingletonMonoBehaviour<TransitionManager>.Instance.SetActiveScene(SceneDefine.Title);
		}

		private void Update()
		{
			switch (m_state)
			{
			case States.Initalize:
				Fader.StartFade(ColorDefine.Black, ColorDefine.TransparentBlack, 0.6f, isDeactivateOnEnd: true, OnFadeInEnd);
				m_state = States.FadeIn;
				_audioComponent.PlayTitleBGM();
				break;
			case States.Play:
				if (SingletonMonoBehaviour<GameInputManager>.HasInstance && !IsMenuOpened && SingletonMonoBehaviour<GameInputManager>.Instance.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.MainAction))
				{
					_audioComponent.PlaySound(TitleAudioComponent.ClipName.GameStart);
					_audioComponent.StopTitleBGM(0.6f);
					FadeOut();
				}
				break;
			case States.FadeIn:
			case States.FadeOut:
			case States.End:
				break;
			}
		}

		public void OnFadeInEnd()
		{
			m_state = States.Play;
		}

		private void FadeOut()
		{
			Fader.StartReverseFade(m_fadeoutDuration, isDeactivateOnEnd: false, OnFadeOutEnd);
			m_state = States.FadeOut;
		}

		private void OnFadeOutEnd()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.StartScenario(m_scenarioToLoad);
		}
	}
	public class DataManager : SingletonMonoBehaviour<DataManager>
	{
		public GeneralDataController GeneralData { get; private set; }

		public CharaTable CharaData { get; private set; }

		public CharaTextDataTable CharaTextData { get; private set; }

		public SequenceTable SequenceData { get; private set; }

		protected override void InitializeOnAwake()
		{
			base.InitializeOnAwake();
			GeneralData = new GeneralDataController();
			CharaData = new CharaTable();
			CharaTextData = new CharaTextDataTable();
			SequenceData = new SequenceTable();
			GeneralData.Load();
			CharaData.Load();
			CharaTextData.Load();
		}

		public void Clear()
		{
			GeneralData.Clear();
			CharaData.Clear();
			CharaTextData.Clear();
			SequenceData.Clear();
			GeneralData = null;
			CharaData = null;
			CharaTextData = null;
			SequenceData = null;
		}

		public override void Shutdown(bool isDestroyObject = true)
		{
			Clear();
			base.Shutdown(isDestroyObject);
		}

		public Sprite FindLoadingSprite(int sqid)
		{
			if (sqid <= -1)
			{
				return null;
			}
			return GetChapterData(sqid)?.SpriteLoadScreen;
		}

		public Sprite FindSaveThumbnailSprite(int sqid)
		{
			if (sqid <= -1)
			{
				return null;
			}
			return GeneralData.GetScenarioInfo(sqid).SaveThumbnail;
		}

		private NewGameData.ChapterSetting GetChapterData(int sqid)
		{
			if (!GeneralData.ScenarioList.TryGetValue(sqid, out var seqData))
			{
				return null;
			}
			return Array.Find(ChapterChecker.GetChapterListData(seqData.Category), (NewGameData.ChapterSetting info) => info.Category == seqData.Category && info.Index == seqData.ChapterNumber);
		}
	}
	public static class AchievementDefine
	{
		public enum Keys
		{
			ACH_CHRONOS_COMPLETE_01_01 = 0,
			ACH_CHRONOS_COMPLETE_01_02 = 1,
			ACH_CHRONOS_COMPLETE_01_03 = 2,
			ACH_CHRONOS_COMPLETE_01_04 = 3,
			ACH_CHRONOS_COMPLETE_01_05 = 4,
			ACH_CHRONOS_COMPLETE_01_06 = 5,
			ACH_CHRONOS_COMPLETE_01_07 = 6,
			ACH_CHRONOS_COMPLETE_02_01 = 7,
			ACH_CHRONOS_COMPLETE_02_02 = 8,
			ACH_CHRONOS_COMPLETE_02_03 = 9,
			ACH_CHRONOS_COMPLETE_02_04 = 10,
			ACH_CHRONOS_COMPLETE_02_05 = 11,
			ACH_CHRONOS_COMPLETE_02_06 = 12,
			ACH_CHRONOS_COMPLETE_02_07 = 13,
			ACH_CHRONOS_COMPLETE_02_08 = 14,
			ACH_CHRONOS_COMPLETE_02_09 = 15,
			ACH_CHRONOS_COMPLETE_02_10 = 16,
			ACH_CHRONOS_COMPLETE_02_11 = 17,
			ACH_CHRONOS_COMPLETE_MOMONO = 18,
			ACH_CHRONOS_COMPLETE_TOUGOKU = 19,
			ACH_CHRONOS_COMPLETE_KAGEYAMA = 20,
			ACH_CHRONOS_COMPLETE_MOROZUMI = 21,
			ACH_CHRONOS_COMPLETE_MACHIKOUJI = 22,
			ACH_CHRONOS_MOMONO_SHOWER = 23,
			NULL = 1023
		}

		public static IObservable<Keys> FlagToKeys(this IObservable<GameFlags> flagObservable)
		{
			return flagObservable.Select((GameFlags flag) => flag switch
			{
				GameFlags.CompleteChapter1_1 => Keys.ACH_CHRONOS_COMPLETE_01_01, 
				GameFlags.CompleteChapter1_2 => Keys.ACH_CHRONOS_COMPLETE_01_02, 
				GameFlags.CompleteChapter1_3 => Keys.ACH_CHRONOS_COMPLETE_01_03, 
				GameFlags.CompleteChapter1_4 => Keys.ACH_CHRONOS_COMPLETE_01_04, 
				GameFlags.CompleteChapter1_5 => Keys.ACH_CHRONOS_COMPLETE_01_05, 
				GameFlags.CompleteChapter1_6 => Keys.ACH_CHRONOS_COMPLETE_01_06, 
				GameFlags.CompleteChapter1_7 => Keys.ACH_CHRONOS_COMPLETE_01_07, 
				GameFlags.CompleteChapter2_1 => Keys.ACH_CHRONOS_COMPLETE_02_01, 
				GameFlags.CompleteChapter2_2 => Keys.ACH_CHRONOS_COMPLETE_02_02, 
				GameFlags.CompleteChapter2_3 => Keys.ACH_CHRONOS_COMPLETE_02_03, 
				GameFlags.CompleteChapter2_4 => Keys.ACH_CHRONOS_COMPLETE_02_04, 
				GameFlags.CompleteChapter2_5 => Keys.ACH_CHRONOS_COMPLETE_02_05, 
				GameFlags.CompleteChapter2_6 => Keys.ACH_CHRONOS_COMPLETE_02_06, 
				GameFlags.CompleteChapter2_7 => Keys.ACH_CHRONOS_COMPLETE_02_07, 
				GameFlags.CompleteChapter2_8 => Keys.ACH_CHRONOS_COMPLETE_02_08, 
				GameFlags.CompleteChapter2_9 => Keys.ACH_CHRONOS_COMPLETE_02_09, 
				GameFlags.CompleteChapter2_10 => Keys.ACH_CHRONOS_COMPLETE_02_10, 
				GameFlags.CompleteChapter2_11 => Keys.ACH_CHRONOS_COMPLETE_02_11, 
				GameFlags.EndingMomono => Keys.ACH_CHRONOS_COMPLETE_MOMONO, 
				GameFlags.EndingTougoku => Keys.ACH_CHRONOS_COMPLETE_TOUGOKU, 
				GameFlags.EndingKageyama => Keys.ACH_CHRONOS_COMPLETE_KAGEYAMA, 
				GameFlags.EndingMorozumi => Keys.ACH_CHRONOS_COMPLETE_MOROZUMI, 
				GameFlags.EndingMachikouji => Keys.ACH_CHRONOS_COMPLETE_MACHIKOUJI, 
				_ => Keys.NULL, 
			});
		}
	}
	public static class CharaAnimDefine
	{
		public enum AnimID
		{

		}

		public enum SkAnimID
		{

		}

		public enum RuAnimID
		{

		}

		public enum MmAnimID
		{

		}

		public enum TgAnimID
		{

		}

		public enum KmAnimID
		{

		}

		public enum MrAnimID
		{

		}

		public enum McAnimID
		{

		}

		public enum KgAnimID
		{

		}
	}
	public static class GameDefine
	{
		public enum Languages
		{
			Japanese,
			English,
			German,
			French,
			Chinese,
			Max
		}

		public enum CharaIndex
		{
			NONE = 0,
			BASE = 1,
			SAKURAI = 2,
			NIKAIDOU = 3,
			ROU = 4,
			MOMONO = 5,
			TOUGOKU = 6,
			KAMIYA = 7,
			MOROZUMI = 8,
			MACHIKOUJI = 9,
			KAGEYAMA = 10,
			RIN = 11,
			HITOKAGE = 12,
			UNKNOWN = 13,
			SAKURAI_MIRROR = 14,
			TOGOKU_MIRROR = 15,
			TOUGOKU_SISTER = 20,
			TOUGOKU_PAPA = 21,
			NIKAIDOU_MAMA = 22,
			MACHIKOUJI_MAMA = 23,
			YANKEEEE = 24,
			HITTAKURI = 25,
			TEACHER = 26,
			DOG = 27,
			CLASSMATE_M_S_A = 30,
			CLASSMATE_M_S_B = 31,
			CLASSMATE_M_S_C = 32,
			CLASSMATE_F_S_A = 33,
			CLASSMATE_F_S_B = 34,
			CLASSMATE_F_S_C = 35,
			CLASSMATE_M_C_A = 36,
			CLASSMATE_M_C_B = 37,
			CLASSMATE_M_C_C = 38,
			CLASSMATE_F_C_A = 39,
			CLASSMATE_F_C_B = 40,
			CLASSMATE_F_C_C = 41,
			Count = 42
		}

		public enum CharaID
		{
			NONE = 0,
			BASE = 100,
			SAKURAI = 200,
			SAKURAI_S = 201,
			SAKURAI_C = 202,
			NIKAIDOU = 300,
			NIKAIDOU_S = 301,
			NIKAIDOU_C = 302,
			ROU = 400,
			ROU_MEMORY = 401,
			MOMONO = 500,
			MOMONO_S = 501,
			MOMONO_C = 502,
			TOUGOKU = 600,
			TOUGOKU_S = 601,
			TOUGOKU_C = 602,
			KAMIYA = 700,
			KAMIYA_S = 701,
			KAMIYA_C = 702,
			MOROZUMI = 800,
			MOROZUMI_S = 801,
			MOROZUMI_C = 802,
			MACHIKOUJI = 900,
			MACHIKOUJI_S = 901,
			MACHIKOUJI_C = 902,
			KAGEYAMA = 1000,
			KAGEYAMA_S = 1001,
			KAGEYAMA_C = 1002,
			RIN = 1100,
			RIN_S = 1101,
			RIN_C = 1102,
			HITOKAGE = 1200,
			SAKURAI_MIRROR = 1400,
			TOGOKU_MIRROR = 1500,
			TOUGOKU_SISTER = 2000,
			TOUGOKU_PAPA = 2100,
			NIKAIDOU_MAMA = 2200,
			MACHIKOUJI_MAMA = 2300,
			YANKEEEE = 2400,
			HITTAKURI = 2500,
			TEACHER = 2600,
			DOG = 2700,
			CLASSMATE_M_S_A = 3000,
			CLASSMATE_M_S_B = 3100,
			CLASSMATE_M_S_C = 3200,
			CLASSMATE_F_S_A = 3300,
			CLASSMATE_F_S_B = 3400,
			CLASSMATE_F_S_C = 3500,
			CLASSMATE_M_C_A = 3600,
			CLASSMATE_M_C_B = 3700,
			CLASSMATE_M_C_C = 3800,
			CLASSMATE_F_C_A = 3900,
			CLASSMATE_F_C_B = 4000,
			CLASSMATE_F_C_C = 4100,
			UNKNOWN_SAKURAI = 10200,
			UNKNOWN_NIKAIDOU = 10300,
			UNKNOWN_ROU = 10400,
			UNKNOWN_MOMONO = 10500,
			UNKNOWN_TOUGOKU = 10600,
			UNKNOWN_KAMIYA = 10700,
			UNKNOWN_MOROZUMI = 10800,
			UNKNOWN_MACHIKOUJI = 10900,
			UNKNOWN_KAGEYAMA = 11000,
			UNKNOWN_RIN = 11100,
			UNKNOWN_HITOKAGE = 11200,
			MOMONO_RIN = 100500,
			UNKNOWN = 99999
		}

		public const int TEMP_SCENARIO_ID = -99999;

		public const int INVALID_VALUE = -1;

		public const float FADE_DURATION = 0.6f;

		public const float MODEL_SCALE = 3.5f;

		public const float PLAYER_Y_ADJUSTMENT = 5.17f;

		public static readonly Vector3 PLAYER_DEFAULT_POSITION = new Vector3(0f, 5.17f, 0f);

		public const string NAME_UNKNOWN = "???";

		public const float CHARA_SCALER = 3.5f;

		public static readonly Vector3 CHARA_SCALE = new Vector3(0.2857143f, 0.2857143f, 0.2857143f);

		public const int CHARA_ID_ADJUSTMENT = 100;

		public const int CHARA_UNKNOWN_ADJUSTMENT = 10000;

		public const int CHARA_SPECIAL_ADJUSTMENT = 100000;

		public static readonly int CHARA_UNKNOWN_DIGITS = (int)Mathf.Log10(10000f) + 1;

		public static CharaID CharaIndexToID(CharaIndex index)
		{
			return (CharaID)((int)index * 100);
		}

		public static CharaIndex CharaIDToIndex(CharaID charaID)
		{
			return (CharaIndex)((int)charaID / 100);
		}

		public static bool IsUnknownChara(CharaID charaID)
		{
			return MathHelper.CountDigit((int)charaID) == CHARA_UNKNOWN_DIGITS;
		}

		public static bool IsAnotherVersion(CharaID id)
		{
			return (int)id % 10 > 0;
		}

		public static CharaID GetOriginalCharaID(CharaID id)
		{
			return (CharaID)(Mathf.CeilToInt((int)id / 100) * 100);
		}

		public static CharaID UnknownToCharaID(CharaID charaID)
		{
			return charaID - 10000;
		}

		public static CharaID GetCharaID(int id)
		{
			if (id == 0)
			{
				return CharaID.BASE;
			}
			return (CharaID)id;
		}

		public static bool IsModChara(CharaID id)
		{
			if (id >= CharaID.TOUGOKU_SISTER)
			{
				return id < CharaID.UNKNOWN_SAKURAI;
			}
			return false;
		}

		public static bool IsShadow(CharaID id)
		{
			if (id != CharaID.HITOKAGE)
			{
				return id == CharaID.UNKNOWN_HITOKAGE;
			}
			return true;
		}

		public static bool IsSpecialChara(CharaID id)
		{
			return id > (CharaID)100000;
		}

		public static CharaID ConvertSpecialToNormal(CharaID id)
		{
			if (id < (CharaID)100000)
			{
				return id;
			}
			return id - 100000;
		}

		public static bool IsLanguageImplemented(Languages lang)
		{
			if ((uint)lang <= 2u || lang == Languages.Chinese)
			{
				return true;
			}
			return false;
		}
	}
	public static class PathDefine
	{
		public const string _GENERAL = "General/";

		public const string _NEWGAME_DATA = "General/NewGameData";

		public const string _SCENARIO_LIST_DATA = "General/ScenarioList";

		public const string _TABLES = "Tables/";

		public const string _SETTINGS = "Settings/";

		public const string _SETTINGS_SOUND = "Settings/Sound/";

		public const string _PREFABS = "Prefabs/";

		public const string _PROPS = "Prefabs/Props/";

		public const string _TEXTURES = "Textures/";

		public const string _EVENT_IMAGE = "Textures/Event/";

		public const string _CHARA_PREFABS = "Prefabs/Characters/";

		public const string _PLAYER_AVATER = "Prefabs/Avaters/";

		public const string _AUDIO = "Audio/";

		public const string _AUDIO_BGM = "Audio/BGM/";

		public const string _AUDIO_BGM_SIMPLE = "Audio/BgmSimple/";

		public const string _AUDIO_SE = "Audio/SE/";

		public const string _AUDIO_AMBIENT = "Audio/Ambient/";

		public const string _AUDIO_VOICE = "Audio/Voice/";

		public const string _AUDIO_VOICE_MOB = "Audio/Voice/Mob/";

		public const string _MEMORY_CHARA = "MemoryChara/";
	}
	public static class SoundDefine
	{
		public enum SystemSE
		{
			Null,
			Message_Next,
			Message_Log,
			Selection_Show,
			Selection_Select,
			Selection_Decide,
			Selection_Cancel,
			Menu_Open,
			Menu_Close,
			Menu_Select,
			Menu_Decide,
			Menu_Confirm,
			Menu_Cancel,
			Menu_Error,
			Message_TypeLoop,
			Message_TypeEnd,
			Message_TypeNext
		}

		public enum SE
		{
			Footstep = 10000
		}

		public enum Bgm
		{
			IF = 100
		}
	}
	public static class VRDeviceDefine
	{
		public enum PlatformType
		{
			Disabled,
			Unsupported,
			OpenVR,
			Oculus,
			Playstation
		}

		public enum DeviceType
		{
			Disabled,
			Unsupported,
			Vive,
			OculusRift,
			OculusGo,
			OculusQuest,
			GearVR,
			OtherOpenVRDevice,
			Playstation
		}

		public enum HandType
		{
			Left,
			Right,
			Both,
			None
		}

		public enum Buttons
		{
			DeviceSystem,
			DeviceBack,
			SubAction,
			Cancel,
			MainAction,
			PositionReset,
			RemoveInterface,
			SkipScene,
			Up,
			Down,
			Left,
			Right
		}

		public class NotSupportedDeviceException : Exception
		{
			public NotSupportedDeviceException()
				: base("Detected VR device that is not implemented.")
			{
			}

			public NotSupportedDeviceException(string s)
				: base($"Detected VR device '{s}' that is not implemented.")
			{
			}

			public NotSupportedDeviceException(DeviceType type)
				: this(type.ToString())
			{
			}
		}
	}
	public class GameData : SingletonMonoBehaviour<GameData>
	{
		public const int _SAVE_FILE_SLOTS = 30;

		public const int INDEX_AUTOSAVE = 0;

		[Header("Components")]
		[SerializeField]
		private FileIOManager m_fileIOManager;

		[Header("Parameters - Filename")]
		[SerializeField]
		private string m_directoryName = "Save";

		[SerializeField]
		private string m_saveFileName = "save";

		[SerializeField]
		private string m_systemFileName = "system";

		[SerializeField]
		private string m_configFileName = "config";

		private bool _needsRefreshHeaders = true;

		private List<GameFileSave.Header> _headerList;

		private Subject<GameFlags> _subjectFlagActivated = new Subject<GameFlags>();

		public GameFileSave CurrentSaveData { get; private set; }

		public SystemSave SystemData { get; private set; }

		public ConfigSave ConfigData { get; private set; }

		public bool IsHeaderCreated => !_needsRefreshHeaders;

		public IObservable<GameFlags> FlagActivatedObservable => _subjectFlagActivated;

		protected override void InitializeOnAwake()
		{
			string path = ToDirPath();
			m_fileIOManager.CreateDirectory(path);
			CurrentSaveData = new GameFileSave(ToFilePath(m_saveFileName));
			SystemData = new SystemSave(ToFilePath(m_systemFileName));
			ConfigData = new ConfigSave(ToFilePath(m_configFileName));
			LoadSystemData();
			LoadConfigData();
			FindHeaders();
			base.InitializeOnAwake();
		}

		private void Start()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.OnQuitApplication.Subscribe(delegate
			{
				SaveSystemData();
			});
		}

		private string ToFilePath(string fileName)
		{
			return FilePathUtil.Combine(ToDirPath(), fileName);
		}

		private string ToDirPath()
		{
			return FilePathUtil.Combine(FileIOManagerBase.SdkPersistentDataPath, m_directoryName + "/");
		}

		public bool LoadSaveData(int loadFileIndex)
		{
			return LoadSaveData(CurrentSaveData, loadFileIndex);
		}

		private bool LoadSaveData(GameFileSave loadTo, int loadFileIndex)
		{
			loadTo.SetPath(ToFilePath(m_saveFileName) + loadFileIndex);
			if (!m_fileIOManager.Exists(loadTo.Path))
			{
				return false;
			}
			return m_fileIOManager.ReadBinaryDecode(loadTo.Path, loadTo.Load);
		}

		public bool IsExistSaveData(int loadFileIndex)
		{
			return m_fileIOManager.Exists(ToFilePath(m_saveFileName) + loadFileIndex);
		}

		public void LoadSystemData()
		{
			LoadData(SystemData);
		}

		public void LoadConfigData()
		{
			LoadData(ConfigData);
		}

		private void LoadData(BaseSave data)
		{
			if (m_fileIOManager.Exists(data.Path))
			{
				if (!m_fileIOManager.ReadBinaryDecode(data.Path, data.Load))
				{
					data.Clear();
				}
			}
			else
			{
				data.Clear();
			}
		}

		public void Save(int slotIndex)
		{
			SaveSystemData();
			SetupSaveDataToSave();
			SaveToSlot(slotIndex);
		}

		private void SetupSaveDataToSave()
		{
			CurrentSaveData.SequenceID = SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID;
		}

		public void SaveSystemData()
		{
			SaveDataToFile(SystemData);
		}

		public void SaveConfigData()
		{
			SaveDataToFile(ConfigData);
		}

		private void SaveDataToFile(BaseSave data)
		{
			m_fileIOManager.WriteBinaryEncode(data.Path, data.Save);
		}

		public void SaveToSlot(int slotIndex)
		{
			CurrentSaveData.SetPath(ToFilePath(m_saveFileName + slotIndex));
			SaveDataToFile(CurrentSaveData);
			_needsRefreshHeaders = true;
		}

		public void DeleteAll()
		{
			DeleteAllSaveFiles();
			DeleteFile(ToFilePath(m_configFileName));
			DeleteFile(ToFilePath(m_systemFileName));
		}

		public void DeleteAllWithoutConfig()
		{
			DeleteAllSaveFiles();
			DeleteFile(ToFilePath(m_systemFileName));
		}

		public void DeleteAllSaveFiles()
		{
			string text = ToFilePath(m_saveFileName);
			for (int i = 0; i < 30; i++)
			{
				DeleteFile(text + i);
			}
		}

		public void DeleteFile(string path)
		{
			m_fileIOManager.Delete(path);
		}

		public bool GetFlag(GameFlags gameFlag)
		{
			return SystemData.GetFlag(gameFlag);
		}

		public void SetFlag(GameFlags gameFlag, bool value)
		{
			SystemData.SetFlag(gameFlag, value);
			if (value)
			{
				_subjectFlagActivated.OnNext(gameFlag);
			}
		}

		public List<GameFileSave.Header> FindHeaders()
		{
			if (_needsRefreshHeaders)
			{
				return CreateHeaders();
			}
			return _headerList;
		}

		public List<GameFileSave.Header> CreateHeaders()
		{
			_headerList = new List<GameFileSave.Header>();
			for (int i = 0; i < 30; i++)
			{
				GameFileSave gameFileSave = new GameFileSave(ToFilePath(m_saveFileName));
				if (!IsExistSaveData(i))
				{
					_headerList.Add(gameFileSave.CreateEmptyHeader(i));
				}
				else if (LoadSaveData(gameFileSave, i))
				{
					_headerList.Add(gameFileSave.CreateHeader(i));
				}
				else
				{
					_headerList.Add(gameFileSave.CreateCorruptedHeader(i));
				}
			}
			_needsRefreshHeaders = false;
			return _headerList;
		}
	}
	public enum GameFlags
	{
		Route1Chapter0,
		Route1Chapter1,
		Route1Chapter2,
		Route1Chapter3,
		Route1Chapter4,
		Route1Chapter5,
		Route1Chapter6,
		Route1Chapter7,
		Route1Chapter8,
		Route1Chapter9,
		Route2Chapter0,
		Route2Chapter1,
		Route2Chapter2,
		Route2Chapter3,
		Route2Chapter4,
		Route2Chapter5,
		Route2Chapter6,
		Route2Chapter7,
		Route2Chapter8,
		Route2Chapter9,
		ChapterTougoku,
		ChapterKageyama,
		ChapterMomono,
		ChapterMorozumi,
		ChapterMachikouji,
		EndingNormal,
		EndingTougoku,
		EndingKageyama,
		EndingMomono,
		EndingMorozumi,
		EndingMachikouji,
		EndingTrue,
		EndingAlternate,
		Route2Chapter10,
		Route2Chapter11,
		Route2Chapter12,
		Route2Chapter13,
		Route2Chapter14,
		CompleteChapter1_0,
		CompleteChapter1_1,
		CompleteChapter1_2,
		CompleteChapter1_3,
		CompleteChapter1_4,
		CompleteChapter1_5,
		CompleteChapter1_6,
		CompleteChapter1_7,
		CompleteChapter1_8,
		CompleteChapter1_9,
		CompleteChapter2_0,
		CompleteChapter2_1,
		CompleteChapter2_2,
		CompleteChapter2_3,
		CompleteChapter2_4,
		CompleteChapter2_5,
		CompleteChapter2_6,
		CompleteChapter2_7,
		CompleteChapter2_8,
		CompleteChapter2_9,
		CompleteChapter2_10,
		CompleteChapter2_11,
		CompleteChapter2_12,
		SkipNoifyShowed,
		Max
	}
	public class GeneralDataController
	{
		private Dictionary<int, ScenarioListData.Info> _scenarioList;

		public NewGameData NewGameLists { get; private set; }

		public Dictionary<int, ScenarioListData.Info> ScenarioList => _scenarioList;

		public void Load()
		{
			NewGameLists = Resources.Load<NewGameData>("General/NewGameData");
			MakeScenarioList();
		}

		private void MakeScenarioList()
		{
			ScenarioListData scenarioListData = Resources.Load<ScenarioListData>("General/ScenarioList");
			if (scenarioListData == null)
			{
				return;
			}
			_scenarioList = new Dictionary<int, ScenarioListData.Info>();
			foreach (ScenarioListData.Info info in scenarioListData.InfoList)
			{
				_scenarioList.Add(info.Index, info);
			}
		}

		public void Clear()
		{
			_scenarioList = null;
		}

		public ScenarioListData.Info GetScenarioInfo(int squid)
		{
			if (!_scenarioList.TryGetValue(squid, out var value))
			{
				value = new ScenarioListData.Info();
				value.IgnoreFileSave = true;
			}
			return value;
		}

		public int GetNewGameSqid()
		{
			return NewGameLists.SqidNewGame;
		}
	}
	[CreateAssetMenu(menuName = "Chronos/New Game Data", fileName = "NewGameData")]
	public class NewGameData : ScriptableObject
	{
		[Serializable]
		public class ChapterSetting
		{
			public ScenarioListData.Categories Category = ScenarioListData.Categories.RouteFirst;

			public int Index;

			public int StartSqid = -1;

			public SceneDefine BonusScene = SceneDefine.Title;

			public GameFlags ConditionToSelect;

			public Sprite SpriteSaveThumbnail;

			public Sprite SpriteLoadScreen;

			public bool IgnoreListUp;
		}

		public int SqidNewGame = -1;

		public GameFlags ConditionToRevealHidden = GameFlags.EndingNormal;

		public ChapterSetting[] ChaptersFirst;

		public ChapterSetting[] ChaptersSecond;

		public ChapterSetting[] ChaptersCharacter;

		public ChapterSetting[] ChaptersSpecial;
	}
	public class ScenarioListData : ScriptableObject
	{
		public enum Categories
		{
			Test,
			RouteFirst,
			RouteSecond,
			Character,
			Special,
			Other
		}

		public enum SpecialTypes
		{
			NotSpecial = -1,
			Null,
			ChangeCharacter,
			Selection,
			ChapterStart,
			NullFour,
			NullFive,
			NullSix,
			NullSeven,
			NullEight,
			NullNine
		}

		public enum SkipModes
		{
			Normal,
			Related,
			Flag,
			Always,
			Never
		}

		[Serializable]
		public class Info
		{
			[HideInInspector]
			public string FileName = "";

			[NotEditable]
			public int Index = -1;

			[SerializeField]
			private bool _customChapter;

			[EnableIf("$_customChapter")]
			[StackableField]
			public Categories Category;

			[EnableIf("$_customChapter")]
			[StackableField]
			public SpecialTypes SpecialType = SpecialTypes.NotSpecial;

			[EnableIf("$_customChapter")]
			[StackableField]
			public int ChapterNumber;

			[NotEditable]
			public bool HasTextData;

			[NotEditable]
			public bool HasSequenceData;

			[EnumButton]
			public SkipModes SkipMode;

			[ShowIf("#_isFlagToSkip")]
			[StackableField]
			public GameFlags FlagToSkip;

			public bool IgnoreFileSave;

			public int RelatedSqid = -1;

			public string ScenarioName = "";

			[Preview]
			[Expandable]
			public Sprite SaveThumbnail;

			public bool IsExists
			{
				get
				{
					if (!HasTextData)
					{
						return HasSequenceData;
					}
					return true;
				}
			}

			public bool IsValid
			{
				get
				{
					if (HasTextData)
					{
						return HasSequenceData;
					}
					return false;
				}
			}

			public void ResetExistFlags()
			{
				HasTextData = false;
				HasSequenceData = false;
			}

			public void CalculateIndex()
			{
				if (_customChapter)
				{
					UpdateFileName();
					return;
				}
				switch (Index / 10000)
				{
				case 0:
					Category = Categories.Test;
					ChapterNumber = Index;
					break;
				case 1:
					Category = Categories.RouteFirst;
					ChapterNumber = Index / 1000 % 10;
					break;
				case 2:
					Category = Categories.RouteSecond;
					if (Index < 27000)
					{
						ChapterNumber = Index / 1000 % 10;
					}
					else if (Index <= 27119)
					{
						ChapterNumber = 7;
					}
					else if (Index <= 27999)
					{
						ChapterNumber = 8;
					}
					else if (Index <= 28039)
					{
						ChapterNumber = 9;
					}
					else if (Index <= 28279)
					{
						ChapterNumber = 10;
					}
					else
					{
						ChapterNumber = 11;
					}
					break;
				case 4:
					Category = Categories.Character;
					ChapterNumber = 2;
					break;
				case 5:
					Category = Categories.Character;
					ChapterNumber = 3;
					break;
				case 6:
					Category = Categories.Character;
					ChapterNumber = 4;
					break;
				case 7:
					Category = Categories.Character;
					ChapterNumber = 5;
					break;
				case 8:
					Category = Categories.Character;
					ChapterNumber = 1;
					break;
				case 9:
					Category = Categories.Special;
					CalctSpecialCategoryChapter();
					break;
				default:
					Category = Categories.Other;
					ChapterNumber = Index;
					break;
				}
				UpdateFileName();
			}

			private void UpdateFileName()
			{
				if (Category == Categories.Special)
				{
					FileName = $"{Index:D5} ({Category}.{SpecialType}.{ChapterNumber})";
				}
				else
				{
					FileName = $"{Index:D5} ({Category}.{ChapterNumber})";
				}
			}

			private void CalctSpecialCategoryChapter()
			{
				int num = Index % 1000;
				SpecialType = (SpecialTypes)((Index - 90000) / 1000);
				switch (SpecialType)
				{
				case SpecialTypes.ChangeCharacter:
				case SpecialTypes.Selection:
					ChapterNumber = num;
					break;
				case SpecialTypes.ChapterStart:
					ChapterNumber = num / 10;
					break;
				default:
					ChapterNumber = num;
					break;
				}
			}

			private bool _isFlagToSkip()
			{
				return SkipMode == SkipModes.Flag;
			}
		}

		public List<Info> InfoList = new List<Info>();

		public void ResetExistFlags()
		{
			InfoList.ForEach(delegate(Info info)
			{
				info.ResetExistFlags();
			});
		}

		public void RecalcAll()
		{
			InfoList.ForEach(delegate(Info info)
			{
				info.CalculateIndex();
			});
		}

		public int RemoveUnused()
		{
			return InfoList.RemoveAll((Info i) => !i.IsExists);
		}

		public void SortListByIndex()
		{
			InfoList.Sort((Info a, Info b) => a.Index - b.Index);
		}

		public Info FindByIndex(int index)
		{
			return InfoList.Find((Info info) => info.Index == index);
		}

		public Info InsertNewInfo()
		{
			Info info = new Info();
			InfoList.Add(info);
			return info;
		}
	}
	public class LocalData : SingletonMonoBehaviour<LocalData>
	{
		public int ProgressID;

		public int LastSelectionIndex = -1;

		private Subject<GameDefine.CharaID> _subjectOnChangeCharacter = new Subject<GameDefine.CharaID>();

		public int NextScenarioID { get; set; }

		public int SkipDestinationIndex { get; set; }

		public GameDefine.CharaID CurrentCharaID { get; private set; }

		public GameDefine.CharaID NextCharaID { get; set; }

		public bool IsSessionTitleShowed { get; set; }

		public bool IsOmitNextAutoSave { get; set; }

		public IObservable<GameDefine.CharaID> OnChangeCharacter => _subjectOnChangeCharacter;

		protected override void InitializeOnAwake()
		{
			Reset();
			base.InitializeOnAwake();
		}

		private void Start()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeStartInGame.Subscribe(delegate(int scenarioId)
			{
				Reset();
				NextScenarioID = scenarioId;
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeEndInGame.Subscribe(delegate
			{
				Reset();
			}).AddTo(base.gameObject);
		}

		public void Reset()
		{
			NextScenarioID = -1;
			SkipDestinationIndex = -1;
			CurrentCharaID = GameDefine.CharaID.NONE;
			NextCharaID = GameDefine.CharaID.NONE;
			ProgressID = 0;
			LastSelectionIndex = -1;
			IsOmitNextAutoSave = false;
		}

		public void ChangeCharacter(GameDefine.CharaID target)
		{
			if (CurrentCharaID != target)
			{
				CurrentCharaID = target;
				_subjectOnChangeCharacter.OnNext(CurrentCharaID);
			}
		}

		public void ChangeCharacterToNext()
		{
			ChangeCharacter(NextCharaID);
			NextCharaID = GameDefine.CharaID.NONE;
		}
	}
	public abstract class BaseLocalizerComponent : MonoBehaviour
	{
		[Header("Parameters - Base")]
		[SerializeField]
		private string _localizeKey;

		[SerializeField]
		private bool _lockLanguage;

		[SerializeField]
		private GameDefine.Languages _lockTarget;

		private bool _initialized;

		public string LocalizeKey
		{
			get
			{
				return _localizeKey;
			}
			set
			{
				_localizeKey = value;
				if (_initialized && !string.IsNullOrEmpty(_localizeKey))
				{
					UpdateLocalize(CurrentLanguage);
				}
			}
		}

		protected LocalizeManager LocalizeParent => SingletonMonoBehaviour<LocalizeManager>.Instance;

		protected IReadOnlyReactiveProperty<GameDefine.Languages> ChangeLanguageObservable => SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language;

		protected GameDefine.Languages CurrentLanguage
		{
			get
			{
				if (!_lockLanguage)
				{
					return SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value;
				}
				return _lockTarget;
			}
		}

		private void OnValidate()
		{
			ValidateComponent();
		}

		private void Start()
		{
			if (_lockLanguage)
			{
				(from _ in ChangeLanguageObservable.First()
					select _lockTarget into _
					where !string.IsNullOrEmpty(_localizeKey)
					select _).Subscribe(UpdateLocalize);
			}
			else
			{
				ChangeLanguageObservable.Where((GameDefine.Languages _) => !string.IsNullOrEmpty(_localizeKey)).Subscribe(UpdateLocalize).AddTo(base.gameObject);
			}
			_initialized = true;
		}

		protected abstract void ValidateComponent();

		protected abstract void UpdateLocalize(GameDefine.Languages lang);
	}
	public class LocalizerTextMesh : BaseLocalizerComponent
	{
		[Header("Parameters - Text Mesh")]
		[SerializeField]
		[NotEditable]
		private TextMeshPro _target;

		protected override void ValidateComponent()
		{
			if (_target == null)
			{
				_target = GetComponent<TextMeshPro>();
			}
		}

		protected override void UpdateLocalize(GameDefine.Languages lang)
		{
			_target.text = base.LocalizeParent.GetLocalizeString(base.LocalizeKey, lang);
		}
	}
	public class LocalizerUGUIText : BaseLocalizerComponent
	{
		[Header("Parameters - Text Mesh")]
		[SerializeField]
		[NotEditable]
		protected TextMeshProUGUI _target;

		protected override void ValidateComponent()
		{
			if (_target == null)
			{
				_target = GetComponent<TextMeshProUGUI>();
			}
		}

		protected override void UpdateLocalize(GameDefine.Languages lang)
		{
			_target.text = base.LocalizeParent.GetLocalizeString(base.LocalizeKey, lang);
		}
	}
	public class LocalizeManager : SingletonMonoBehaviour<LocalizeManager>
	{
		private const string PathToTextData = "Localize/LocalizeData";

		private const string PathToSpriteSet = "Localize/LocalizeSpriteSet";

		private Dictionary<string, LocalizeData.Param> _stringTranslates;

		private Dictionary<string, LocalizeSpriteSet.Param> _spriteTranslates;

		public IReadOnlyReactiveProperty<GameDefine.Languages> ChangeLanguageObservable => SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language;

		protected override void InitializeOnAwake()
		{
			base.InitializeOnAwake();
			LoadStringLocalizeData();
			LoadSpriteLocalizeData();
		}

		private void LoadStringLocalizeData()
		{
			LocalizeData localizeData = Resources.Load<LocalizeData>("Localize/LocalizeData");
			if (localizeData == null)
			{
				return;
			}
			_stringTranslates = new Dictionary<string, LocalizeData.Param>();
			foreach (LocalizeData.Param item in localizeData.param)
			{
				_stringTranslates.Add(item.KEY, item);
			}
		}

		private void LoadSpriteLocalizeData()
		{
			LocalizeSpriteSet localizeSpriteSet = Resources.Load<LocalizeSpriteSet>("Localize/LocalizeSpriteSet");
			if (localizeSpriteSet == null)
			{
				return;
			}
			_spriteTranslates = new Dictionary<string, LocalizeSpriteSet.Param>();
			foreach (LocalizeSpriteSet.Param item in localizeSpriteSet.param)
			{
				_spriteTranslates.Add(item.KEY, item);
			}
		}

		public string GetLocalizeString(string key)
		{
			return GetLocalizeString(key, ChangeLanguageObservable.Value);
		}

		public string GetLocalizeString(string key, GameDefine.Languages lang)
		{
			if (!_stringTranslates.TryGetValue(key, out var value))
			{
				return string.Empty;
			}
			return lang switch
			{
				GameDefine.Languages.Japanese => value.Japanese, 
				GameDefine.Languages.English => value.English, 
				GameDefine.Languages.German => value.German, 
				GameDefine.Languages.French => value.French, 
				GameDefine.Languages.Chinese => value.Chinese, 
				_ => string.Empty, 
			};
		}

		public Sprite GetLocalizeSprite(string key)
		{
			return GetLocalizeSprite(key, ChangeLanguageObservable.Value);
		}

		public Sprite GetLocalizeSprite(string key, GameDefine.Languages lang)
		{
			if (!_spriteTranslates.TryGetValue(key, out var value))
			{
				return null;
			}
			return value.Sprites[(int)lang];
		}
	}
	[CreateAssetMenu(menuName = "Chronos/Sprite Localize Set", fileName = "LocalizeSpriteSet")]
	public class LocalizeSpriteSet : ScriptableObject
	{
		[Serializable]
		public class Param
		{
			public string KEY;

			[EnumLabel(typeof(GameDefine.Languages))]
			public Sprite[] Sprites;
		}

		public List<Param> param = new List<Param>();
	}
	[Serializable]
	public abstract class BaseSave
	{
		public class LoadingErrorException : Exception
		{
			public LoadingErrorException()
				: base("OOPS: Loading is failed by some reason.")
			{
			}

			public LoadingErrorException(string message)
				: base($"Loading says OOPS: {message}")
			{
			}
		}

		public class LoadingGameVersionErrorException : LoadingErrorException
		{
			public LoadingGameVersionErrorException()
				: base("Invalid version")
			{
			}

			public LoadingGameVersionErrorException(int current, int old)
				: base($"Game version fail (current = '{current}', got '{old}'.)")
			{
			}
		}

		public class LoadingFileVersionErrorException : LoadingErrorException
		{
			public LoadingFileVersionErrorException()
				: base("Invalid version")
			{
			}

			public LoadingFileVersionErrorException(int current, int old)
				: base($"File version fail (current = '{current}', got '{old}'.)")
			{
			}
		}

		private static readonly int MagicID = FileIOManagerBase.ToMagicID('S', 'a', 'v', 'e');

		protected int m_fileVersion;

		protected int m_gameVersion;

		public virtual int GameVersion => 0;

		public virtual int FileVersion { get; private set; }

		public string Path { get; protected set; }

		public BaseSave(string path)
		{
			Path = path;
		}

		public virtual void Clear()
		{
			m_gameVersion = GameVersion;
			m_fileVersion = FileVersion;
		}

		public void Load(BinaryReader reader)
		{
			Clear();
			if (reader.ReadInt32() != MagicID)
			{
				throw new LoadingErrorException("Wrong Magic ID");
			}
			m_gameVersion = reader.ReadInt32();
			if (GameVersion < m_gameVersion)
			{
				throw new LoadingGameVersionErrorException(GameVersion, m_gameVersion);
			}
			if (GameVersion > m_gameVersion)
			{
				OnLoadOldGameVersion(m_gameVersion, reader);
			}
			m_fileVersion = reader.ReadInt32();
			if (FileVersion < m_fileVersion)
			{
				throw new LoadingFileVersionErrorException(FileVersion, m_fileVersion);
			}
			if (FileVersion > m_fileVersion)
			{
				OnLoadOldFileVersion(m_fileVersion, reader);
			}
			LoadDataFromFile(m_fileVersion, reader);
		}

		protected abstract void LoadDataFromFile(int oldFileVersion, BinaryReader reader);

		protected virtual void OnLoadOldGameVersion(int oldVersion, BinaryReader reader)
		{
		}

		protected virtual void OnLoadOldFileVersion(int oldVersion, BinaryReader reader)
		{
			throw new LoadingFileVersionErrorException(FileVersion, oldVersion);
		}

		public void Save(BinaryWriter writer)
		{
			writer.Write(MagicID);
			writer.Write(GameVersion);
			writer.Write(FileVersion);
			SaveDataToFile(writer);
		}

		protected abstract void SaveDataToFile(BinaryWriter writer);
	}
	[Serializable]
	public class ConfigSave : BaseSave
	{
		public const float _DEFAULT_BGM_VOLUME = 1f;

		public const float _DEFAULT_SE_VOLUME = 1f;

		public const float _DEFAULT_VOICE_VOLUME = 1f;

		private const int _VERSION = 2;

		public override int FileVersion => 2;

		public ReactiveProperty<GameDefine.Languages> Language { get; private set; }

		public ReactiveProperty<float> BgmVolume { get; private set; }

		public ReactiveProperty<float> SeVolume { get; private set; }

		public ReactiveProperty<float> VoiceVolume { get; private set; }

		public ReactiveProperty<int> PlayerHeight { get; private set; }

		public ReactiveProperty<int> MessageHeight { get; private set; }

		public ReactiveProperty<int> MessageLength { get; private set; }

		public ReactiveProperty<int> MessageSpeed { get; private set; }

		public ReactiveProperty<VRDeviceDefine.HandType> PrefferedHand { get; private set; }

		public ReactiveProperty<bool> IsMessageFollowVertical { get; private set; }

		public ConfigSave(string path)
			: base(path)
		{
			Language = new ReactiveProperty<GameDefine.Languages>();
			BgmVolume = new ReactiveProperty<float>(1f);
			SeVolume = new ReactiveProperty<float>(1f);
			VoiceVolume = new ReactiveProperty<float>(1f);
			PlayerHeight = new ReactiveProperty<int>();
			MessageHeight = new ReactiveProperty<int>();
			MessageLength = new ReactiveProperty<int>();
			MessageSpeed = new ReactiveProperty<int>();
			PrefferedHand = new ReactiveProperty<VRDeviceDefine.HandType>(VRDeviceDefine.HandType.Right);
			IsMessageFollowVertical = new ReactiveProperty<bool>(initialValue: true);
			Language.Value = GetDeviceLanguage();
		}

		public static GameDefine.Languages GetDeviceLanguage()
		{
			if (UnityEngine.Application.systemLanguage == SystemLanguage.Japanese)
			{
				return GameDefine.Languages.Japanese;
			}
			if (UnityEngine.Application.systemLanguage == SystemLanguage.Chinese || UnityEngine.Application.systemLanguage == SystemLanguage.ChineseSimplified || UnityEngine.Application.systemLanguage == SystemLanguage.ChineseTraditional)
			{
				return GameDefine.Languages.Chinese;
			}
			if (UnityEngine.Application.systemLanguage == SystemLanguage.German)
			{
				return GameDefine.Languages.German;
			}
			return GameDefine.Languages.English;
		}

		public override void Clear()
		{
			base.Clear();
			BgmVolume.Value = 1f;
			SeVolume.Value = 1f;
			VoiceVolume.Value = 1f;
			PlayerHeight.Value = 0;
			MessageHeight.Value = 0;
			MessageLength.Value = 0;
			MessageSpeed.Value = 0;
			PrefferedHand.Value = VRDeviceDefine.HandType.Right;
			IsMessageFollowVertical.Value = true;
			Language.Value = GetDeviceLanguage();
		}

		protected override void LoadDataFromFile(int oldFileVersion, BinaryReader reader)
		{
			try
			{
				BgmVolume.Value = reader.ReadSingle();
				SeVolume.Value = reader.ReadSingle();
				VoiceVolume.Value = reader.ReadSingle();
				PlayerHeight.Value = reader.ReadInt32();
				MessageHeight.Value = reader.ReadInt32();
				MessageLength.Value = reader.ReadInt32();
				MessageSpeed.Value = reader.ReadInt32();
				PrefferedHand.Value = (VRDeviceDefine.HandType)reader.ReadInt32();
				IsMessageFollowVertical.Value = reader.ReadBoolean();
				Language.Value = (GameDefine.Languages)reader.ReadInt32();
			}
			catch (EndOfStreamException)
			{
			}
		}

		protected override void SaveDataToFile(BinaryWriter writer)
		{
			writer.Write(BgmVolume.Value);
			writer.Write(SeVolume.Value);
			writer.Write(VoiceVolume.Value);
			writer.Write(PlayerHeight.Value);
			writer.Write(MessageHeight.Value);
			writer.Write(MessageLength.Value);
			writer.Write(MessageSpeed.Value);
			writer.Write((int)PrefferedHand.Value);
			writer.Write(IsMessageFollowVertical.Value);
			writer.Write((int)Language.Value);
		}

		public void ResetLanguageToSafe()
		{
			Language.Value = GameDefine.Languages.English;
		}
	}
	[Serializable]
	public class GameFileSave : BaseSave
	{
		[Serializable]
		public class Header
		{
			public int fileIndex;

			public bool IsEmpty;

			public bool IsCorrupted;

			public int SequenceID;

			public DateTimeOffset SavedTime;

			public Header(int id, bool isEmpty = false)
			{
				fileIndex = id;
				IsEmpty = isEmpty;
			}
		}

		private const int _VERSION = 1;

		public int SequenceID;

		public DateTimeOffset SavedTime;

		public override int FileVersion => 1;

		public GameFileSave(string path)
			: base(path)
		{
		}

		public override void Clear()
		{
			base.Clear();
			SequenceID = 0;
		}

		public void SetPath(string path)
		{
			base.Path = path;
		}

		protected override void LoadDataFromFile(int oldFileVersion, BinaryReader reader)
		{
			try
			{
				SequenceID = reader.ReadInt32();
				long ticks = reader.ReadInt64();
				TimeSpan offset = new TimeSpan(reader.ReadInt64());
				SavedTime = new DateTimeOffset(ticks, offset);
			}
			catch (EndOfStreamException)
			{
			}
		}

		protected override void SaveDataToFile(BinaryWriter writer)
		{
			SavedTime = DateTimeOffset.Now;
			writer.Write(SequenceID);
			writer.Write(SavedTime.Ticks);
			writer.Write(SavedTime.Offset.Ticks);
		}

		public Header CreateHeader(int fileIndex)
		{
			return new Header(fileIndex)
			{
				SequenceID = SequenceID,
				SavedTime = SavedTime
			};
		}

		public Header CreateEmptyHeader(int fileIndex)
		{
			return new Header(fileIndex, isEmpty: true);
		}

		public Header CreateCorruptedHeader(int fileIndex)
		{
			return new Header(fileIndex)
			{
				IsCorrupted = true
			};
		}
	}
	[Serializable]
	public class SystemSave : BaseSave
	{
		private const int _VERSION = 3;

		[SerializeField]
		private bool[] _gameFlags = new bool[62];

		[SerializeField]
		private List<int> _scenarioReaded = new List<int>();

		[SerializeField]
		private TimeSpan _totalPlayTime = TimeSpan.Zero;

		[SerializeField]
		private int _lastShowedFilePage;

		private DateTimeOffset _timeLastSaveModified;

		public override int FileVersion => 3;

		public TimeSpan TotalPlayTime
		{
			get
			{
				UpdatePlayTime();
				return _totalPlayTime;
			}
		}

		public int PlayTimeMin
		{
			get
			{
				UpdatePlayTime();
				return (int)Math.Floor(_totalPlayTime.TotalMinutes);
			}
		}

		public int LastShowedFilePage
		{
			get
			{
				return _lastShowedFilePage;
			}
			set
			{
				_lastShowedFilePage = value;
			}
		}

		public SystemSave(string path)
			: base(path)
		{
		}

		public override void Clear()
		{
			base.Clear();
			ResetAllFlags();
			ResetTime();
		}

		private void ResetAllFlags()
		{
			int num = _gameFlags.Length;
			for (int i = 0; i < num; i++)
			{
				_gameFlags[i] = false;
			}
			_scenarioReaded.Clear();
		}

		private void ResetTime()
		{
			_timeLastSaveModified = DateTimeOffset.Now;
			_totalPlayTime = TimeSpan.Zero;
		}

		public bool GetFlag(GameFlags flag)
		{
			return _gameFlags[(int)flag];
		}

		public bool GetFlag(int flagId)
		{
			return _gameFlags[flagId];
		}

		public void SetFlag(GameFlags flag, bool value)
		{
			_gameFlags[(int)flag] = value;
		}

		public bool AddReadFlag(int scenarioId)
		{
			if (IsScenarioReaded(scenarioId))
			{
				return false;
			}
			_scenarioReaded.Add(scenarioId);
			return true;
		}

		public bool IsScenarioReaded(int scenarioId)
		{
			return _scenarioReaded.Exists((int id) => id == scenarioId);
		}

		public void MakeAllReaded()
		{
			foreach (int key in SingletonMonoBehaviour<DataManager>.Instance.GeneralData.ScenarioList.Keys)
			{
				if (!IsScenarioReaded(key))
				{
					_scenarioReaded.Add(key);
				}
			}
		}

		public void ClearReadedFlag()
		{
			_scenarioReaded.Clear();
		}

		public void AddReadFlag_Debug(int scenarioId)
		{
		}

		protected override void LoadDataFromFile(int oldFileVersion, BinaryReader reader)
		{
			try
			{
				int num = reader.ReadInt32();
				for (int i = 0; i < num; i++)
				{
					_gameFlags[i] = reader.ReadBoolean();
				}
				int num2 = reader.ReadInt32();
				for (int j = 0; j < num2; j++)
				{
					int item = reader.ReadInt32();
					_scenarioReaded.Add(item);
				}
				_totalPlayTime = new TimeSpan(reader.ReadInt64());
				ResetTimeCaches();
				_lastShowedFilePage = reader.ReadInt32();
			}
			catch (EndOfStreamException)
			{
			}
		}

		protected override void OnLoadOldFileVersion(int oldVersion, BinaryReader reader)
		{
		}

		protected override void SaveDataToFile(BinaryWriter writer)
		{
			int num = _gameFlags.Length;
			writer.Write(num);
			for (int i = 0; i < num; i++)
			{
				writer.Write(_gameFlags[i]);
			}
			int count = _scenarioReaded.Count;
			writer.Write(count);
			for (int j = 0; j < count; j++)
			{
				int value = _scenarioReaded[j];
				writer.Write(value);
			}
			UpdatePlayTime();
			writer.Write(_totalPlayTime.Ticks);
			writer.Write(_lastShowedFilePage);
		}

		public void ResetTimeCaches()
		{
			_timeLastSaveModified = DateTimeOffset.Now;
		}

		private void UpdatePlayTime()
		{
			DateTimeOffset now = DateTimeOffset.Now;
			TimeSpan timeSpan = now - _timeLastSaveModified;
			_totalPlayTime += timeSpan;
			_timeLastSaveModified = now;
		}
	}
	public class SceneSoundData : ScriptableObject
	{
		[Serializable]
		public class DataSet
		{
			public GameDefine.CharaID Chara;

			public List<Data> Data;
		}

		[Serializable]
		public class Data
		{
			public float DistanceFromCenter;

			public DearVRSource.RoomList RoomList = DearVRSource.RoomList.Direct_Signal;

			public float GainLevel;

			public float ReflectionLP;

			public float ReflectionLevel;

			public float ReverbLevel;

			public float DirectLevel;

			public float AzimuthCorrection;

			public float DistanceCorrection;
		}

		public List<DataSet> DataList;

		public DataSet FindDataSet(GameDefine.CharaID chara)
		{
			int count = DataList.Count;
			for (int i = 0; i < count; i++)
			{
				if (DataList[i].Chara == chara)
				{
					return DataList[i];
				}
			}
			return null;
		}

		public bool TryFindDataSet(GameDefine.CharaID chara, ref DataSet data)
		{
			int count = DataList.Count;
			for (int i = 0; i < count; i++)
			{
				if (DataList[i].Chara == chara)
				{
					data = DataList[i];
					return true;
				}
			}
			return false;
		}
	}
	public class CharaTable : IExcelTable<Entity_CharaName>
	{
		private const string _FILE_NAME = "CharaName";

		public override int GetCount()
		{
			return m_data.param.Count;
		}

		public override void Load()
		{
			m_data = Resources.Load<Entity_CharaName>("Settings/CharaName");
		}

		public Entity_CharaName.Param GetData(int index)
		{
			return m_data.param[index];
		}

		public Entity_CharaName.Param FindDataByID(GameDefine.CharaID charaID)
		{
			int count = m_data.param.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_data.param[i].id == (int)charaID)
				{
					return m_data.param[i];
				}
			}
			return null;
		}

		public Entity_CharaName.Param FindDataByName(string name)
		{
			int count = m_data.param.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_data.param[i].name == name)
				{
					return m_data.param[i];
				}
			}
			return null;
		}

		public string FindName(GameDefine.CharaID charaID)
		{
			if (GameDefine.IsUnknownChara(charaID))
			{
				charaID = GameDefine.CharaID.UNKNOWN;
			}
			Entity_CharaName.Param param = FindDataByID(charaID);
			if (param == null)
			{
				return string.Empty;
			}
			if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value == GameDefine.Languages.Japanese)
			{
				return param.ja;
			}
			if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value == GameDefine.Languages.Chinese)
			{
				return param.ch;
			}
			return param.en;
		}

		public GameDefine.CharaID NameToID(string name)
		{
			return (GameDefine.CharaID)(FindDataByName(name)?.id ?? 100);
		}
	}
	public class CharaTextDataTable : IExcelTable<Data_Character>
	{
		private const string _FILE_NAME = "DataCharacter";

		public override int GetCount()
		{
			return m_data.param.Count;
		}

		public override void Load()
		{
			m_data = Resources.Load<Data_Character>("Settings/DataCharacter");
		}

		public Data_Character.Param GetData(int index)
		{
			return m_data.param[index];
		}

		public Data_Character.Param FindDataByID(GameDefine.CharaID charaID)
		{
			if (GameDefine.IsUnknownChara(charaID))
			{
				charaID = GameDefine.UnknownToCharaID(charaID);
			}
			int count = m_data.param.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_data.param[i].id == charaID)
				{
					return m_data.param[i];
				}
			}
			return null;
		}

		public Data_Character.Param FindDataByName(string name)
		{
			int count = m_data.param.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_data.param[i].name == name)
				{
					return m_data.param[i];
				}
			}
			return null;
		}
	}
	[CreateAssetMenu(menuName = "Chronos/Create Character Data", fileName = "DataCharacter")]
	public class Data_Character : ScriptableObject
	{
		[Serializable]
		public class Param
		{
			public GameDefine.CharaID id;

			public string name;

			public Color colorBackground = Color.white;

			public Color colorText = Color.black;
		}

		public List<Param> param;
	}
	public abstract class IExcelTable<T> where T : ScriptableObject
	{
		protected T m_data;

		public bool isValid => m_data != null;

		public IExcelTable()
		{
			m_data = null;
		}

		public abstract void Load();

		public abstract int GetCount();

		public virtual void Clear()
		{
			if (m_data != null)
			{
				Resources.UnloadAsset(m_data);
				m_data = null;
			}
		}

		public virtual void ClearImmediate()
		{
			if (m_data != null)
			{
				UnityEngine.Object.DestroyImmediate(m_data, allowDestroyingAssets: true);
				m_data = null;
			}
		}
	}
	public class ScenarioTextTable : IExcelTable<ScenarioTableData>
	{
		private const string _FILE_NAME = "ScenarioData{0:D5}";

		private const string _PATH = "Tables/ScenarioData{0:D5}";

		public ScenarioTextTable()
		{
		}

		public ScenarioTextTable(ScenarioTableData data)
		{
			m_data = data;
		}

		public override int GetCount()
		{
			if (m_data == null)
			{
				return 0;
			}
			return m_data.param.Count;
		}

		public override void Load()
		{
			throw new NotImplementedException();
		}

		public void Load(int scenarioID)
		{
			Clear();
			m_data = Resources.Load<ScenarioTableData>($"Tables/ScenarioData{scenarioID:D5}");
		}

		public void Load(string fullPath)
		{
			Clear();
			m_data = Resources.Load<ScenarioTableData>(fullPath);
		}

		public ScenarioTableData.Param GetData(int index)
		{
			if (index < 0 || index >= m_data.param.Count)
			{
				return null;
			}
			return m_data.param[index];
		}

		public string GetText(int index)
		{
			if (index < 0 || index >= m_data.param.Count)
			{
				return string.Empty;
			}
			if (SingletonMonoBehaviour<GameData>.Instance == null || SingletonMonoBehaviour<GameData>.Instance.ConfigData == null)
			{
				return m_data.param[index].TextJp;
			}
			if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value == GameDefine.Languages.Japanese)
			{
				return m_data.param[index].TextJp;
			}
			if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value == GameDefine.Languages.Chinese)
			{
				return m_data.param[index].TextCh;
			}
			if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value == GameDefine.Languages.German)
			{
				return m_data.param[index].TextGe;
			}
			return m_data.param[index].TextEg;
		}
	}
	[CreateAssetMenu(menuName = "Chronos/Create SequenceData", fileName = "SequenceData00000")]
	public class SequenceData : ScriptableObject
	{
		[Serializable]
		public class Param
		{
			public ISequenceCommand.Types CommandType;

			public List<int> DataInt = new List<int>();

			public List<float> DataFloat = new List<float>();

			public List<string> DataString = new List<string>();

			public int GetInt(int index, int defaultValue = 0)
			{
				if (index < DataInt.Count)
				{
					return DataInt[index];
				}
				return defaultValue;
			}

			public float GetFloat(int index, float defaultValue = 0f)
			{
				if (index < DataFloat.Count)
				{
					return DataFloat[index];
				}
				return defaultValue;
			}

			public string GetString(int index, string defaultValue = "")
			{
				if (index < DataString.Count)
				{
					return DataString[index];
				}
				return defaultValue;
			}

			public Vector3 GetVector3(int startIndex)
			{
				if (startIndex < DataFloat.Count + 2)
				{
					return new Vector3(DataFloat[startIndex], DataFloat[startIndex + 1], DataFloat[startIndex + 2]);
				}
				return Vector3.zero;
			}

			public Vector3 GetVector3(int startIndex, Vector3 defaultValue)
			{
				if (startIndex < DataFloat.Count + 2)
				{
					return new Vector3(DataFloat[startIndex], DataFloat[startIndex + 1], DataFloat[startIndex + 2]);
				}
				return defaultValue;
			}
		}

		public int Version;

		public List<Param> param;
	}
	public class SequenceTable : IExcelTable<SequenceData>
	{
		public const string _FILE_NAME = "SequenceData{0:D5}";

		private const string _PATH = "Tables/SequenceData{0:D5}";

		public SequenceTable()
		{
		}

		public SequenceTable(SequenceData data)
		{
			m_data = data;
		}

		public override int GetCount()
		{
			if (m_data == null || m_data.param == null)
			{
				return 0;
			}
			return m_data.param.Count;
		}

		public override void Load()
		{
		}

		public void Load(int scenarioID)
		{
			Clear();
			m_data = Resources.Load<SequenceData>($"Tables/SequenceData{scenarioID:D5}");
		}

		public void Load(string fullPath)
		{
			Clear();
			m_data = Resources.Load<SequenceData>(fullPath);
		}

		public SequenceData.Param GetData(int index)
		{
			return m_data.param[index];
		}

		public int GetVersion()
		{
			return m_data.Version;
		}

		public void SetData(SequenceData data)
		{
			m_data = data;
		}
	}
	public class AdvCutScene : MonoBehaviour
	{
		[Header("Components - Timeline")]
		[SerializeField]
		private PlayableDirector _playableDirector;

		[SerializeField]
		private bool m_isForceCpuThrottle;

		[SerializeField]
		private int m_startWaitFrames = 2;

		private bool _isPlayStarted;

		private bool _isFinished;

		private bool _pauseRequested;

		private IDisposable _disposeTimeline;

		private HashSet<Component> _pauseRequestList = new HashSet<Component>();

		private Subject<Unit> _subjectStartTimeline = new Subject<Unit>();

		private Subject<Unit> _subjectCompleteTimeline = new Subject<Unit>();

		private Subject<Unit> _subjectForwardCommand = new Subject<Unit>();

		public bool IsFinished => _isFinished;

		public PlayableDirector Director => _playableDirector;

		public IObservable<Unit> StartTimelineObservable => _subjectStartTimeline;

		public IObservable<Unit> CompleteTimelineObservable => _subjectCompleteTimeline;

		public IObservable<Unit> ForwardCommandObservable => _subjectForwardCommand;

		private void Start()
		{
			_isFinished = false;
			BindFader(SingletonMonoBehaviour<FadeManager>.Instance.sceneFader);
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			SingletonMonoBehaviour<TransitionManager>.Instance.OnBeforeTransition.Take(1).Subscribe(delegate
			{
				DisposeTimeline();
			});
			if (!SingletonMonoBehaviour<MasterManager>.Instance.IsInGame)
			{
				SingletonMonoBehaviour<PlayAreaManager>.Instance.SetClearColor(ColorDefine.TransparentBlack);
				SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.StartFade(ColorDefine.TransparentBlack, 0f, isDeactivateOnEnd: true);
				CompleteTimelineObservable.Take(1).Subscribe(delegate
				{
					SingletonMonoBehaviour<MasterManager>.Instance.ForceToTitle();
				});
				IObservable<Unit> source = SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable.Where((Unit _) => SingletonMonoBehaviour<GameInputManager>.Instance.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.Cancel));
				Observable.TakeUntil(other: SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable.Where((Unit _) => SingletonMonoBehaviour<GameInputManager>.Instance.GetVRButtonUp(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.Cancel)), source: source.SelectMany((Unit _) => Observable.Timer(TimeSpan.FromSeconds(1.0)))).RepeatUntilDestroy(base.gameObject).Subscribe(delegate
				{
					SingletonMonoBehaviour<MasterManager>.Instance.ForceToTitle();
				});
			}
			int buildIndex = base.gameObject.scene.buildIndex;
			if (SingletonMonoBehaviour<TransitionManager>.Instance.CurrentSceneId == (SceneDefine)buildIndex)
			{
				PrepareTimeline();
			}
			else
			{
				SingletonMonoBehaviour<TransitionManager>.Instance.OnCompleteTransition.Where((Scene scene) => scene.buildIndex == buildIndex).Take(1).Subscribe(delegate
				{
					PrepareTimeline();
				})
					.AddTo(base.gameObject);
			}
			SingletonMonoBehaviour<MainMenuManager>.Instance.OnToggleMenu.Where((bool flag) => _isPlayStarted && !_isFinished && flag).Subscribe(delegate
			{
				AddPauseRequest(this);
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MainMenuManager>.Instance.OnToggleMenu.Where((bool flag) => _isPlayStarted && !_isFinished && !flag).Subscribe(delegate
			{
				RemovePauseRequest(this);
			}).AddTo(base.gameObject);
		}

		public void PrepareTimeline()
		{
			if (m_isForceCpuThrottle)
			{
				VrUtility.OnLoadStart(isChangeGraphics: false);
			}
			if (m_startWaitFrames <= 0)
			{
				StartTimeline();
				return;
			}
			Observable.TimerFrame(m_startWaitFrames).Subscribe(delegate
			{
				StartTimeline();
			});
		}

		private void StartTimeline()
		{
			_disposeTimeline = _playableDirector.PlayAsStream().Subscribe(delegate
			{
				_isFinished = true;
				_subjectForwardCommand.OnNext(Unit.Default);
				_subjectCompleteTimeline.OnNext(Unit.Default);
			});
			_isPlayStarted = true;
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeExitFade.Subscribe(delegate
			{
				DisposeTimeline();
			}).AddTo(base.gameObject);
			_subjectStartTimeline.OnNext(Unit.Default);
		}

		public void AddPauseRequest(Component comp)
		{
			if (_pauseRequestList.Add(comp) && !_pauseRequested)
			{
				_pauseRequested = true;
				UpdatePause();
			}
		}

		public void RemovePauseRequest(Component comp)
		{
			if (_pauseRequestList.Remove(comp) && _pauseRequestList.Count == 0 && _pauseRequested)
			{
				_pauseRequested = false;
				UpdatePause();
			}
		}

		private void UpdatePause()
		{
			if (_isPlayStarted && !_isFinished)
			{
				if (_pauseRequested)
				{
					_playableDirector.Pause();
				}
				else
				{
					_playableDirector.Play();
				}
			}
		}

		public void DisposeTimeline()
		{
			if (_disposeTimeline != null)
			{
				if (m_isForceCpuThrottle)
				{
					VrUtility.OnLoadEnd(isChangeGraphics: false);
				}
				_isPlayStarted = false;
				_disposeTimeline.Dispose();
			}
		}

		private void OnDestroy()
		{
			DisposeTimeline();
		}

		private void OnApplicationQuit()
		{
			DisposeTimeline();
		}

		private void BindFader(UIFader uiFader)
		{
			PlayableBinding playableBinding = _playableDirector.playableAsset.outputs.FirstOrDefault((PlayableBinding c) => c.streamName == "Fade Cat Scene Track");
			if (playableBinding.sourceObject != null)
			{
				_playableDirector.SetGenericBinding(playableBinding.sourceObject, uiFader);
			}
		}
	}
	public static class AnalyticsUtility
	{
		private const string _KEY_FLAG_FIRST = "Flag: {0}";

		private const string _KEY_FLAG_AGAIN = "Flag Again: {0}";

		private const string _KEY_PLAYTIME = "Playtime: {0}";

		private const string _KEY_SKIP = "Skip";

		private const string _PARAM_SCENARIO_ID = "Scenario ID";

		private const string _PARAM_FLAGS = "Flags";

		private const string _PARAM_TIME = "PlayTime";

		private static Dictionary<string, object> _flagParameters = new Dictionary<string, object>();

		private static Dictionary<string, object> _skipParameters = new Dictionary<string, object>();

		public static void Initialize()
		{
			_flagParameters.Add("Flags", 0);
			_flagParameters.Add("PlayTime", 0);
			_skipParameters.Add("Scenario ID", 0);
			_skipParameters.Add("Flags", 0);
			_skipParameters.Add("PlayTime", 0);
		}

		public static void SendSkipEvent()
		{
			SetupFlagParamToSend(_skipParameters);
			SetupPlaytimeParamToSend(_skipParameters);
			SetupScenarioIDParamToSend(_skipParameters);
			AnalyticsEvent.Custom("Skip", _skipParameters);
		}

		public static void SendFlagEvent(GameFlags flag, bool flagValue)
		{
			if (IsSendFlagData(flag, flagValue))
			{
				SetupFlagParamToSend(_flagParameters);
				SetupPlaytimeParamToSend(_flagParameters);
				if (SingletonMonoBehaviour<GameData>.Instance.SystemData.GetFlag(flag))
				{
					AnalyticsEvent.Custom($"Flag Again: {flag}", _flagParameters);
				}
				else
				{
					AnalyticsEvent.Custom($"Flag: {flag}", _flagParameters);
				}
			}
		}

		private static bool IsSendFlagData(GameFlags flag, bool flagValue)
		{
			return flagValue;
		}

		private static void SetupParamToSend()
		{
		}

		private static void SetupFlagParamToSend(Dictionary<string, object> param)
		{
			long num = 0L;
			int num2 = 62;
			for (int i = 0; i < num2; i++)
			{
				if (SingletonMonoBehaviour<GameData>.Instance.GetFlag((GameFlags)i))
				{
					num += 1 << i;
				}
			}
			param["Flags"] = num;
		}

		private static void SetupPlaytimeParamToSend(Dictionary<string, object> param)
		{
			param["PlayTime"] = SingletonMonoBehaviour<GameData>.Instance.SystemData.PlayTimeMin;
		}

		private static void SetupScenarioIDParamToSend(Dictionary<string, object> param)
		{
			if (param.ContainsKey("Scenario ID"))
			{
				param["Scenario ID"] = SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID;
			}
		}
	}
	public class AudioFader : UpdateableComponent
	{
		[SerializeField]
		private AudioSource source;

		[SerializeField]
		private float defaultFadeTime = 1.5f;

		private Common.Timer m_fadeTimer;

		private UnityAction m_onEndFade;

		private AudioClip m_autoNextClip;

		private float m_initialVolume;

		protected override void Initialize()
		{
			if (source == null)
			{
				source = GetComponent<AudioSource>();
			}
			InitFade(source, defaultFadeTime);
		}

		public override void OnUpdate(float delta)
		{
			if (m_fadeTimer == null)
			{
				base.enabled = false;
				return;
			}
			m_fadeTimer.Update(delta);
			if (m_fadeTimer.IsTimeUp)
			{
				source.Stop();
				source.volume = m_initialVolume;
				if (m_onEndFade != null)
				{
					m_onEndFade();
				}
				base.enabled = false;
			}
			else
			{
				float rate = m_fadeTimer.Rate;
				source.volume = m_initialVolume * (1f - rate);
			}
		}

		public void InitFade(AudioSource s, float time)
		{
			m_fadeTimer = new Common.Timer(time);
			source = s;
			ResetVolumeToSource();
			base.enabled = false;
		}

		public void ResetVolumeToSource()
		{
			m_initialVolume = source.volume;
		}

		public void SetVolume(float v)
		{
			m_initialVolume = v;
		}

		public void SetOnEndFade(UnityAction ev)
		{
			m_onEndFade = ev;
		}

		public void SetAutoNextClip(AudioClip clip)
		{
			m_autoNextClip = clip;
			if (clip != null)
			{
				SetOnEndFade(PlayNextClip);
			}
		}

		public void StartFade(float time = -1f)
		{
			if (!base.enabled && source.isPlaying)
			{
				if (time >= 0f)
				{
					m_fadeTimer.SetDuration(time, isReset: false);
				}
				m_fadeTimer.Reset();
				base.enabled = true;
			}
		}

		public void PlayNextClip()
		{
			if (!(m_autoNextClip == null))
			{
				source.clip = m_autoNextClip;
				m_autoNextClip = null;
				source.Play();
			}
		}
	}
	public class BgmPlayer
	{
		public enum StopMode
		{
			Immidiate,
			Fade,
			Outro
		}

		private const int _LAYERS = 3;

		private const int _INITIAL_CLIP_LIST_SIZE = 12;

		private KainePlayer m_player;

		private KaineLoader m_loader;

		private SimpleSoundLoader m_simpleLoader;

		private BgmData m_data;

		private int m_currentID;

		private int m_reservedID;

		private KainePlayer.Layers m_reservedLayer;

		private bool m_isTrackPrepared;

		private List<AudioClip>[] m_clips;

		private AudioSourceFader m_actionSource;

		private Action m_onSimpleBgmEnd;

		public bool IsPlaying => m_player.IsPlaying;

		public bool IsLoading => m_loader.IsLoading;

		public bool IsKaineStopping => m_player.IsStopping;

		public bool IsBgmReserved => m_reservedID != -1;

		public BgmPlayer(KainePlayer kaine, BgmData data)
		{
			m_actionSource = null;
			m_currentID = -1;
			m_reservedID = -1;
			m_player = kaine;
			m_data = data;
			m_isTrackPrepared = false;
			m_loader = new KaineLoader(data, 3);
			m_simpleLoader = new SimpleSoundLoader();
			m_clips = new List<AudioClip>[3];
			for (int i = 0; i < 3; i++)
			{
				m_clips[i] = new List<AudioClip>(12);
			}
			m_player.OnEndPlay = delegate
			{
				OnEndBgm();
			};
			m_onSimpleBgmEnd = delegate
			{
				OnSimpleBgmStopFadeEnd();
			};
		}

		public void InitialLoad()
		{
			List<ISoundCommand> list = new List<ISoundCommand>();
			List<ISoundCommand> simpleBgmList = new List<ISoundCommand>();
			list.Add(new CommandBgm(0, KainePlayer.Layers.Lead));
			Load(list, simpleBgmList, null);
		}

		public void Clear()
		{
			m_isTrackPrepared = false;
			int num = m_clips.Length;
			for (int i = 0; i < num; i++)
			{
				m_clips[i].Clear();
			}
			m_player.Clear();
			m_loader.Clear();
			m_simpleLoader.Clear();
			m_currentID = -1;
			m_reservedID = -1;
			m_actionSource = null;
		}

		public void Load(List<ISoundCommand> bgmList, List<ISoundCommand> simpleBgmList, ISoundCommand firstBgm)
		{
			m_loader.Load(bgmList, firstBgm);
			m_simpleLoader.Load(simpleBgmList);
		}

		public void Play(int id, KainePlayer.Layers layer)
		{
			if (id == m_currentID)
			{
				if (layer != m_player.CurrentLayer)
				{
					SetLayer(layer);
				}
			}
			else if (m_player.IsPlaying)
			{
				m_reservedID = id;
				m_reservedLayer = layer;
				if (!m_player.IsStopping)
				{
					m_player.StopAllLayersWithFade();
				}
			}
			else
			{
				PrepareTrack(id);
				m_currentID = id;
				m_isTrackPrepared = false;
				m_player.PlayBgm(layer);
			}
		}

		public bool PreparePlay(int id, KainePlayer.Layers layer)
		{
			if (id == m_currentID)
			{
				if (layer != m_player.CurrentLayer)
				{
					SetLayer(layer);
				}
				return false;
			}
			if (m_player.IsPlaying)
			{
				m_reservedID = id;
				m_reservedLayer = layer;
				if (!m_player.IsStopping)
				{
					m_player.StopAllLayersWithFade();
				}
				return false;
			}
			PrepareTrack(id);
			m_currentID = id;
			m_isTrackPrepared = false;
			return true;
		}

		public void StartPlay(KainePlayer.Layers layer)
		{
			m_player.PlayBgm(layer);
		}

		public void PrepareFirstTrack()
		{
			if (m_loader.FirstBgmID != -1 && !IsPlaying)
			{
				m_isTrackPrepared = false;
				PrepareTrack(m_loader.FirstBgmID);
			}
		}

		private void PrepareTrack(int id)
		{
			if (m_isTrackPrepared || (id == m_currentID && m_currentID != -1))
			{
				m_isTrackPrepared = true;
				return;
			}
			SetupTrackInfo(id);
			SetupClipsToLayers(id);
			m_isTrackPrepared = true;
		}

		private void SetupTrackInfo(int id)
		{
			BgmData.Param param = m_data.FindByID(id);
			m_player.SetupTrackInfo(param.Bpm, param.Bars, param.Beats, param.UnitPerBar, param.FadeBars, param.Layer, param.Intro, param.SingleClip);
		}

		private void SetupClipsToLayers(int id)
		{
			m_player.Clear();
			int frequency = m_loader.FindFrequency(id);
			for (int i = 0; i < m_player.NumberOfLayers; i++)
			{
				m_player.SetupPartsClips(i, ConvertToClipList(m_loader.FindPartsList(id, i), i));
				m_player.SetupIntroClips(i, frequency, m_loader.FindIntros(id, i));
				m_player.SetupOutroClips(i, m_loader.FindOutros(id, i));
			}
		}

		private List<AudioClip> ConvertToClipList(List<KaineLoader.PartsData> dataList, int layer)
		{
			m_clips[layer].Clear();
			int count = dataList.Count;
			for (int i = 0; i < count; i++)
			{
				m_clips[layer].Add(dataList[i].Clip);
			}
			return m_clips[layer];
		}

		public void Stop(StopMode mode)
		{
			switch (mode)
			{
			case StopMode.Fade:
				m_player.StopAllLayersWithFade();
				break;
			case StopMode.Immidiate:
				m_player.StopAllLayers();
				break;
			case StopMode.Outro:
				m_player.ReserveOutro();
				break;
			}
		}

		private void OnEndBgm()
		{
			m_currentID = -1;
			m_actionSource = null;
			if (IsBgmReserved)
			{
				Play(m_reservedID, m_reservedLayer);
				m_reservedID = -1;
			}
		}

		public void SetLayer(KainePlayer.Layers layer)
		{
			m_player.ChangeLayer(layer);
		}

		public float GetSecondsFromBars(int numBars, bool isCountCurrentBar, bool isCheckPlaying = true)
		{
			return m_player.GetTimeFromBars(numBars, isCountCurrentBar, isCheckPlaying);
		}

		public float GetIntroDuration()
		{
			return m_player.GetIntroDuration();
		}

		public void PlaySimple(int id, float volume, float fadeDuration = 0.6f)
		{
			AudioClip audioClip = m_simpleLoader.FindAudio(id);
			if (!(audioClip == null))
			{
				PlaySimple(audioClip, volume, fadeDuration);
			}
		}

		public void PlaySimple(AudioClip clip, float volume, float fadeDuration = 0.6f)
		{
			m_player.PlaySimpleBgm(clip, volume, fadeDuration);
		}

		public void StopSimple(float fadeDuration)
		{
			m_player.StopSimpleBgm(fadeDuration);
		}

		public void SetSimpleVolume(float volume, float fadeDuration)
		{
			m_player.SetSimpleVolume(volume, fadeDuration);
		}

		public void PlaySimple(AudioSourceFader source, int id, float volume, float fadeDuration = 0.6f)
		{
			AudioClip audioClip = m_simpleLoader.FindAudio(id);
			if (!(audioClip == null))
			{
				source.PlayWithFade(volume, 0f, fadeDuration, audioClip);
			}
		}

		public void StopSimpleBgm(AudioSourceFader source, float fadeDuration)
		{
			if (fadeDuration <= 0f)
			{
				source.Stop();
				return;
			}
			m_actionSource = source;
			source.StopWithFade(fadeDuration, m_onSimpleBgmEnd);
		}

		private void OnSimpleBgmStopFadeEnd()
		{
			m_actionSource.SetClip(null);
			m_actionSource = null;
		}

		public void SetSimpleVolume(AudioSourceFader source, float volume, float fadeDuration)
		{
			source.FadeVolume(fadeDuration, volume);
		}
	}
	public class CharaVoiceSource : MonoBehaviour
	{
		[SerializeField]
		private AudioSource m_audioSource;

		[SerializeField]
		private DearVRSource m_dearVr;

		[SerializeField]
		private OVRLipSyncContextCanned m_lipSyncContext;

		[SerializeField]
		private OVRLipSyncContextMorphTarget m_lipSyncContextMorph;

		[SerializeField]
		private GameDefine.CharaID m_charaID = GameDefine.CharaID.TOUGOKU;

		[SerializeField]
		private int[] m_mouthMorphIndex;

		private Transform m_target;

		private Transform m_transform;

		private GameObject m_targetObject;

		private SkinnedMeshRenderer m_skinnedMeshRenderer;

		private bool m_isPlaying;

		private bool m_isClipPlaying;

		private bool m_isLipsync;

		public AudioSource AudioSource => m_audioSource;

		public DearVRSource DearVr => m_dearVr;

		public GameDefine.CharaID CharaID => m_charaID;

		public OVRLipSyncContextCanned LipSyncContext => m_lipSyncContext;

		public OVRLipSyncContextMorphTarget LipSyncContextMorph => m_lipSyncContextMorph;

		private void Start()
		{
			m_isLipsync = false;
			m_isPlaying = false;
			m_isClipPlaying = false;
			m_transform = base.transform;
		}

		private void Update()
		{
			if (m_isPlaying)
			{
				if (m_isClipPlaying && !m_audioSource.isPlaying)
				{
					m_isClipPlaying = false;
					ResetLipsync();
				}
				if (!m_dearVr.clipIsPlaying)
				{
					StopVoice();
				}
				else if (!(m_target == null) && !(m_targetObject == null) && m_targetObject.activeSelf)
				{
					m_transform.position = m_target.position;
					m_transform.rotation = m_target.rotation;
				}
			}
		}

		public void SetupToLocator(GameDefine.CharaID charaID, Transform targetLocator)
		{
			m_charaID = charaID;
			m_targetObject = null;
			m_target = targetLocator;
			m_transform.position = targetLocator.position;
		}

		public void SetupChara(GameDefine.CharaID charaID)
		{
			m_charaID = charaID;
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(charaID);
			m_target = chara.Head;
			if (m_target != null)
			{
				m_targetObject = chara.HeadObject;
				m_transform.position = m_target.position;
			}
			SetSkinnedMesh(chara.FaceRenderer);
		}

		public void SetSkinnedMesh(SkinnedMeshRenderer renderer)
		{
			m_lipSyncContextMorph.skinnedMeshRenderer = renderer;
			m_skinnedMeshRenderer = renderer;
		}

		public void Play(bool isLipsync)
		{
			m_isLipsync = isLipsync;
			m_isPlaying = true;
			m_isClipPlaying = true;
			m_dearVr.DearVRPlay();
			if (isLipsync)
			{
				m_lipSyncContext.enabled = true;
				m_lipSyncContextMorph.enabled = true;
			}
		}

		public void StopVoice()
		{
			m_isClipPlaying = false;
			m_isPlaying = false;
			m_dearVr.DearVRStop();
			ResetLipsync();
		}

		private void ResetLipsync()
		{
			if (m_isLipsync)
			{
				m_isLipsync = false;
				ResetMouthMorph(m_skinnedMeshRenderer);
				m_lipSyncContext.enabled = false;
				m_lipSyncContextMorph.enabled = false;
			}
		}

		public void ResetMouthMorph(SkinnedMeshRenderer renderer)
		{
			if (!(renderer == null) && m_mouthMorphIndex != null)
			{
				int num = m_mouthMorphIndex.Length;
				for (int i = 0; i < num; i++)
				{
					renderer.SetBlendShapeWeight(m_mouthMorphIndex[i], 0f);
				}
				LipSyncContext.ResetContext();
			}
		}

		public void SetupDearVR(ref SceneSoundData settingData)
		{
			if (!(settingData == null))
			{
				SceneSoundData.DataSet dataSet = settingData.FindDataSet(m_charaID);
				if (dataSet != null)
				{
					SceneSoundData.Data data = FindSoundData(dataSet);
					m_dearVr.RoomPreset = data.RoomList;
					m_dearVr.GainLevel = data.GainLevel;
					m_dearVr.ReflectionLP = data.ReflectionLP;
					m_dearVr.ReflectionLevel = data.ReflectionLevel;
					m_dearVr.ReverbLevel = data.ReverbLevel;
					m_dearVr.DirectLevel = data.DirectLevel;
					m_dearVr.AzimuthCorrection = data.AzimuthCorrection;
					m_dearVr.DistanceCorrection = data.DistanceCorrection;
				}
			}
		}

		private SceneSoundData.Data FindSoundData(SceneSoundData.DataSet data)
		{
			Vector3 left = MainPosition.MainTransform.position;
			Vector3 right = m_target.position;
			float num = Vector3Extension.DistanceSquared(ref left, ref right);
			int count = data.Data.Count;
			for (int i = 0; i < count; i++)
			{
				if (num <= data.Data[i].DistanceFromCenter * data.Data[i].DistanceFromCenter)
				{
					return data.Data[i];
				}
			}
			return data.Data[count - 1];
		}

		public void SetupMorphTarget(AdvCharaMorpthTargetData dataList, VoiceLoader.Data voiceData)
		{
			AdvCharaMorpthTargetData.Data data = dataList.FindData(m_charaID);
			m_mouthMorphIndex = data.MorpthTargetIndex;
			m_lipSyncContextMorph.VisemeToBlendTargets = data.MorpthTargetIndex;
			m_lipSyncContext.currentSequence = voiceData.LipSyncData;
		}
	}
	public class DearVrPlayer : MonoBehaviour
	{
		[SerializeField]
		private DearVRSource m_dearVRSource;

		[SerializeField]
		private AudioSource m_audioSource;

		private Transform m_transform;

		public int CurrentID { get; private set; }

		public bool IsPlaying => m_audioSource.isPlaying;

		private void Start()
		{
			CurrentID = -1;
			m_transform = base.transform;
		}

		public void SetupPosition(ref Vector3 position)
		{
			m_transform.localPosition = position;
		}

		public void Setup(SceneSoundData settingData, ref Vector3 position, GameDefine.CharaID charaID = GameDefine.CharaID.BASE)
		{
			m_transform.localPosition = position;
			SceneSoundData.DataSet data = null;
			if (settingData.TryFindDataSet(charaID, ref data))
			{
				SceneSoundData.Data data2 = FindSoundData(data);
				m_dearVRSource.RoomPreset = data2.RoomList;
				m_dearVRSource.GainLevel = data2.GainLevel;
				m_dearVRSource.ReflectionLP = data2.ReflectionLP;
				m_dearVRSource.ReflectionLevel = data2.ReflectionLevel;
				m_dearVRSource.ReverbLevel = data2.ReverbLevel;
				m_dearVRSource.DirectLevel = data2.DirectLevel;
				m_dearVRSource.AzimuthCorrection = data2.AzimuthCorrection;
				m_dearVRSource.DistanceCorrection = data2.DistanceCorrection;
			}
		}

		private SceneSoundData.Data FindSoundData(SceneSoundData.DataSet data)
		{
			Vector3 left = SingletonMonoBehaviour<MainPosition>.Instance.transform.position;
			Vector3 right = m_transform.position;
			left.y = 0f;
			right.y = 0f;
			float num = Vector3Extension.DistanceSquared(ref left, ref right);
			int count = data.Data.Count;
			for (int i = 0; i < count; i++)
			{
				if (num <= data.Data[i].DistanceFromCenter * data.Data[i].DistanceFromCenter)
				{
					return data.Data[i];
				}
			}
			return data.Data[count - 1];
		}

		public void Play(AudioClip clip, int soundID, float volume, bool isLoop = false)
		{
			CurrentID = soundID;
			m_audioSource.loop = isLoop;
			m_audioSource.clip = clip;
			m_audioSource.volume = volume;
			m_dearVRSource.DearVRPlay();
		}

		public void Stop()
		{
			m_dearVRSource.DearVRStop();
		}
	}
	public class SePlayer
	{
		private AudioSource m_sourceSystemSe;

		private DearVrPlayer[] m_dearVrSourceSE;

		private ListPosition m_3dSEIndex;

		private SceneSoundData m_sceneSettings;

		private SimpleSoundLoader m_loader;

		private List<AudioClip> m_systemSoundClips;

		private bool m_hasValidSceneData;

		public bool IsLoading => m_loader.IsLoading;

		public float Volume => SingletonMonoBehaviour<GameData>.Instance.ConfigData.SeVolume.Value;

		private AudioSource SourceMain => MainPosition.AudioSourceEffect;

		public SePlayer(AudioSource sourceSystemSe, List<AudioClip> systemSoundClips, DearVrPlayer[] dearVrSource)
		{
			m_loader = new SimpleSoundLoader();
			m_dearVrSourceSE = dearVrSource;
			m_sourceSystemSe = sourceSystemSe;
			m_systemSoundClips = systemSoundClips;
			m_3dSEIndex = new ListPosition
			{
				Count = dearVrSource.Length
			};
			m_3dSEIndex.Height = m_3dSEIndex.Count;
			m_3dSEIndex.Select(0);
		}

		public void Clear()
		{
			m_loader.Clear();
		}

		public AudioClip FindClip(int id)
		{
			return m_loader.FindAudio(id);
		}

		public void SetSceneSettings(SceneSoundData data)
		{
			m_sceneSettings = data;
			m_hasValidSceneData = data != null;
		}

		public bool IsPlaying2D()
		{
			return SourceMain.isPlaying;
		}

		public bool IsPlayingAny()
		{
			if (SourceMain.isPlaying)
			{
				return true;
			}
			int num = m_dearVrSourceSE.Length;
			for (int i = 0; i < num; i++)
			{
				if (m_dearVrSourceSE[i].IsPlaying)
				{
					return true;
				}
			}
			return false;
		}

		public void PlaySystem(SoundDefine.SystemSE se, AudioSource source = null)
		{
			if (source == null)
			{
				source = m_sourceSystemSe;
			}
			if ((int)se < m_systemSoundClips.Count)
			{
				AudioClip clip = m_systemSoundClips[(int)se];
				source.PlayOneShot(clip);
			}
		}

		public void PlaySystemLoop(SoundDefine.SystemSE se, AudioSource source = null)
		{
			if (source == null)
			{
				source = m_sourceSystemSe;
			}
			if ((int)se < m_systemSoundClips.Count)
			{
				AudioClip clip = m_systemSoundClips[(int)se];
				source.loop = true;
				source.clip = clip;
				source.Play();
			}
		}

		public void StopSystemLoop(AudioSource source = null)
		{
			if (source == null)
			{
				source = m_sourceSystemSe;
			}
			source.Stop();
			source.clip = null;
			source.loop = false;
		}

		public void PlayClip(AudioClip clip, float volume, AudioSource source = null, bool loop = false)
		{
			if (source == null)
			{
				source = SourceMain;
			}
			source.volume = volume;
			if (!loop)
			{
				source.PlayOneShot(clip);
				return;
			}
			source.loop = true;
			source.clip = clip;
			source.Play();
		}

		public void Play(int id, float volume, AudioSource source = null, bool loop = false)
		{
			AudioClip audioClip = m_loader.FindAudio(id);
			if (!(audioClip == null))
			{
				PlayClip(audioClip, volume, source, loop);
			}
		}

		public void Stop(AudioSource source = null)
		{
			if (source == null)
			{
				source = SourceMain;
			}
			source.Stop();
			source.clip = null;
			source.loop = false;
		}

		public void LoadAllSE(List<ISoundCommand> seList)
		{
			m_loader.Load(seList);
		}

		public void Play3D(int id, float volume, ref Vector3 position, bool isLoop = false)
		{
			AudioClip clip = null;
			if (m_loader.TryFindAudio(id, ref clip))
			{
				PlayClip3D(clip, id, volume, ref position, isLoop);
			}
		}

		public void PlayClip3D(AudioClip clip, int id, float volume, ref Vector3 position, bool isLoop = false)
		{
			DearVrPlayer dearVrPlayer = m_dearVrSourceSE[m_3dSEIndex.Index];
			if (m_hasValidSceneData)
			{
				dearVrPlayer.Setup(m_sceneSettings, ref position);
			}
			else
			{
				dearVrPlayer.SetupPosition(ref position);
			}
			dearVrPlayer.Play(clip, id, volume, isLoop);
			m_3dSEIndex.Next();
		}

		public void Stop3D(int id)
		{
			DearVrPlayer dearVrPlayer = Find3DPlayer(id);
			if (!(dearVrPlayer == null))
			{
				dearVrPlayer.Stop();
			}
		}

		private DearVrPlayer Find3DPlayer(int soundID)
		{
			int num = m_dearVrSourceSE.Length;
			for (int i = 0; i < num; i++)
			{
				if (m_dearVrSourceSE[i].CurrentID == soundID)
				{
					return m_dearVrSourceSE[i];
				}
			}
			return null;
		}

		public void StopAll3D()
		{
			int num = m_dearVrSourceSE.Length;
			for (int i = 0; i < num; i++)
			{
				m_dearVrSourceSE[i].Stop();
			}
		}
	}
	public class SimpleSoundLoader
	{
		public class SoundData
		{
			public int ID;

			public AudioClip Clip;

			public SoundData(int id, AudioClip clip)
			{
				ID = id;
				Clip = clip;
			}
		}

		private const int _DEFAULT_LIST_SIZE = 10;

		private List<SoundData> m_soundDataList;

		private List<AsyncOperation> m_requests;

		public bool IsLoading { get; private set; }

		public bool HasRequest => m_requests.Count > 0;

		public SimpleSoundLoader()
		{
			IsLoading = false;
			m_soundDataList = new List<SoundData>(10);
			m_requests = new List<AsyncOperation>(10);
		}

		public void Clear()
		{
			IsLoading = false;
			ClearSoundData(m_soundDataList);
			ClearRequestData(m_requests);
		}

		public AudioClip FindAudio(int id)
		{
			return FindAudio(m_soundDataList, id);
		}

		public AudioClip FindAudio(List<SoundData> list, int id)
		{
			int count = list.Count;
			for (int i = 0; i < count; i++)
			{
				if (list[i].ID == id)
				{
					return list[i].Clip;
				}
			}
			return null;
		}

		public bool TryFindAudio(int id, ref AudioClip clip)
		{
			int count = m_soundDataList.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_soundDataList[i].ID == id)
				{
					clip = m_soundDataList[i].Clip;
					return true;
				}
			}
			return false;
		}

		public void ClearUnusedData(List<ISoundCommand> nextList, List<SoundData> dataList)
		{
			for (int i = 0; i < dataList.Count; i++)
			{
				bool flag = RemoveCommandWithID(nextList, dataList[i].ID);
				if (nextList.Count <= 0)
				{
					break;
				}
				if (!flag)
				{
					Resources.UnloadAsset(dataList[i].Clip);
					dataList[i].Clip = null;
					dataList.RemoveAt(i);
					i--;
				}
			}
			Resources.UnloadUnusedAssets();
		}

		private bool IsContainSound(List<ISoundCommand> list, int idToCheck)
		{
			int count = list.Count;
			for (int i = 0; i < count; i++)
			{
				if (list[i].ID == idToCheck)
				{
					return true;
				}
			}
			return false;
		}

		private bool RemoveCommandWithID(List<ISoundCommand> list, int id)
		{
			bool result = false;
			for (int i = 0; i < list.Count; i++)
			{
				if (list[i].ID == id)
				{
					list.RemoveAt(i);
					i--;
					result = true;
				}
			}
			return result;
		}

		private void ClearSoundData(List<SoundData> list)
		{
			int count = list.Count;
			for (int i = 0; i < count; i++)
			{
				Resources.UnloadAsset(list[i].Clip);
				list[i].Clip = null;
			}
			list.Clear();
			Resources.UnloadUnusedAssets();
		}

		private void ClearRequestData(List<AsyncOperation> list)
		{
			list.Clear();
		}

		public void Load(List<ISoundCommand> soundList)
		{
			if (soundList != null)
			{
				LoadAll(soundList, m_soundDataList);
			}
		}

		private void LoadAll(List<ISoundCommand> soundCommands, List<SoundData> soundList)
		{
			ClearUnusedData(soundCommands, soundList);
			int count = soundCommands.Count;
			for (int i = 0; i < count; i++)
			{
				int id = soundCommands[i].ID;
				ResourceRequest resourceRequest = Resources.LoadAsync<AudioClip>(soundCommands[i].GetFilePath());
				resourceRequest.completed += delegate(AsyncOperation obj)
				{
					OnLoadSoundDataComplete(obj, soundList, id);
				};
				m_requests.Add(resourceRequest);
			}
			IsLoading = HasRequest;
		}

		private void OnLoadSoundDataComplete(AsyncOperation obj, List<SoundData> soundList, int id)
		{
			m_requests.Remove(obj);
			IsLoading = HasRequest;
			AudioClip audioClip = (obj as ResourceRequest).asset as AudioClip;
			if (!(audioClip == null))
			{
				soundList.Add(new SoundData(id, audioClip));
			}
		}
	}
	public class SoundManager : SingletonMonoBehaviour<SoundManager>
	{
		[Header("Scriptable Data")]
		[SerializeField]
		private AdvCharaMorpthTargetData m_charaMorphData;

		[SerializeField]
		private BgmData m_bgmData;

		[Header("Components - Kaine")]
		[SerializeField]
		private KainePlayer m_kaine;

		[Header("Components - Sources")]
		[SerializeField]
		private AudioSource sourceSystemSe;

		[SerializeField]
		private CharaVoiceSource m_charaVoiceSource;

		[SerializeField]
		private DearVrPlayer[] m_dearVrSourceSE;

		[Header("Components - Sound Clips")]
		[SerializeField]
		[EnumLabel(typeof(SoundDefine.SystemSE))]
		private List<AudioClip> systemSoundClips;

		[Header("Parameters - Other")]
		[SerializeField]
		[Range(0f, 1f)]
		private float m_playerVolume = 1f;

		private List<AsyncOperation> m_requests;

		private SceneSoundData m_sceneSettings;

		private BgmPlayer m_bgmPlayer;

		private VoicePlayer m_voicePlayer;

		private SePlayer m_sePlayer;

		private AudioSource sourceMain => MainPosition.AudioSourceEffect;

		private float volumeBgm => SingletonMonoBehaviour<GameData>.Instance.ConfigData.BgmVolume.Value;

		private float volumeSe => SingletonMonoBehaviour<GameData>.Instance.ConfigData.SeVolume.Value;

		private float volumeVoice => SingletonMonoBehaviour<GameData>.Instance.ConfigData.VoiceVolume.Value;

		public static SePlayer SE => SingletonMonoBehaviour<SoundManager>.Instance.m_sePlayer;

		public static BgmPlayer Bgm => SingletonMonoBehaviour<SoundManager>.Instance.m_bgmPlayer;

		public static VoicePlayer Voice => SingletonMonoBehaviour<SoundManager>.Instance.m_voicePlayer;

		public bool IsLoading
		{
			get
			{
				if (!m_bgmPlayer.IsLoading && !m_voicePlayer.IsLoading && !m_sePlayer.IsLoading)
				{
					return m_requests.Count > 0;
				}
				return true;
			}
		}

		protected override void InitializeOnAwake()
		{
			m_requests = new List<AsyncOperation>();
			m_bgmPlayer = new BgmPlayer(m_kaine, m_bgmData);
			m_voicePlayer = new VoicePlayer(m_charaVoiceSource, m_charaMorphData, m_playerVolume);
			m_sePlayer = new SePlayer(sourceSystemSe, systemSoundClips, m_dearVrSourceSE);
			base.InitializeOnAwake();
		}

		private void Start()
		{
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			SingletonMonoBehaviour<TransitionManager>.Instance.OnCompleteTransition.Subscribe(delegate(Scene scene)
			{
				LoadSceneSetting(scene.name);
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeStartInGame.Subscribe(delegate
			{
				StopAll();
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeEndInGame.Subscribe(delegate
			{
				StopAll();
			}).AddTo(base.gameObject);
		}

		public void StopAll(BgmPlayer.StopMode stopMode = BgmPlayer.StopMode.Immidiate, float simpleBgmFadeDuration = 0f, AudioSource seSource = null)
		{
			StopBgm(stopMode);
			StopSimpleBgm(simpleBgmFadeDuration);
			if (SingletonMonoBehaviour<MainPosition>.HasInstance)
			{
				m_sePlayer.Stop(seSource);
			}
		}

		public void ClearAll()
		{
			m_requests.Clear();
			m_voicePlayer.Clear();
			ClearBgm();
			m_sePlayer.Clear();
			ClearSceneSetting();
		}

		public void ClearAllExceptBgm()
		{
			m_requests.Clear();
			m_voicePlayer.Clear();
			m_sePlayer.Clear();
			ClearSceneSetting();
		}

		public void PlayBgm(int id, KainePlayer.Layers layer)
		{
			m_bgmPlayer.Play(id, layer);
		}

		public void StopBgm(BgmPlayer.StopMode mode)
		{
			m_bgmPlayer.Stop(mode);
		}

		public void StopSimpleBgm(float fadeDuration = -1f)
		{
			m_bgmPlayer.StopSimple(fadeDuration);
		}

		public void SetBgmLayer(KainePlayer.Layers layer)
		{
			m_bgmPlayer.SetLayer(layer);
		}

		public void ClearBgm()
		{
			m_bgmPlayer.Clear();
		}

		public float GetBgmBarDuration(int numBars, bool isCountCurrentBar)
		{
			return m_bgmPlayer.GetSecondsFromBars(numBars, isCountCurrentBar);
		}

		public bool IsPlayingBgm()
		{
			return m_bgmPlayer.IsPlaying;
		}

		public void PrepareFirstBgm()
		{
			m_bgmPlayer.PrepareFirstTrack();
		}

		public void LoadSceneSetting(string name)
		{
			ClearSceneSetting();
			ResourceRequest resourceRequest = Resources.LoadAsync<SceneSoundData>(string.Format("{0}{1}", "Settings/Sound/", name));
			resourceRequest.completed += delegate(AsyncOperation obj)
			{
				m_requests.Remove(obj);
				m_sceneSettings = (obj as ResourceRequest).asset as SceneSoundData;
				m_voicePlayer.SetSceneSettings(m_sceneSettings);
				m_sePlayer.SetSceneSettings(m_sceneSettings);
				_ = m_sceneSettings == null;
			};
			m_requests.Add(resourceRequest);
		}

		public void ClearSceneSetting()
		{
			if (m_sceneSettings != null)
			{
				Resources.UnloadAsset(m_sceneSettings);
				m_sceneSettings = null;
			}
		}
	}
	public class VoiceLoader
	{
		public class Data
		{
			public AudioClip Clip;

			public OVRLipSyncSequence LipSyncData;

			public Data(int id, AudioClip clip, OVRLipSyncSequence lipSyncData = null)
			{
				Clip = clip;
				LipSyncData = lipSyncData;
			}
		}

		private class PlayData
		{
			private List<Data> m_data;

			public GameDefine.CharaID Chara { get; private set; }

			public int Index { get; private set; }

			public AudioClip CurrentVoice => m_data[Index].Clip;

			public PlayData(GameDefine.CharaID chara)
			{
				Chara = chara;
				m_data = new List<Data>(30);
				Reset();
			}

			public void Reset()
			{
				Index = 0;
				int count = m_data.Count;
				for (int i = 0; i < count; i++)
				{
					Resources.UnloadAsset(m_data[i].Clip);
					Resources.UnloadAsset(m_data[i].LipSyncData);
					m_data[i].Clip = null;
					m_data[i].LipSyncData = null;
				}
				m_data.Clear();
			}

			public void Next()
			{
				Index++;
			}

			public Data NextData()
			{
				if (Index >= m_data.Count)
				{
					return null;
				}
				return m_data[Index++];
			}

			public void AddData(int id, AudioClip clip, OVRLipSyncSequence lipSyncData)
			{
				m_data.Add(new Data(id, clip, lipSyncData));
			}

			public void AddData(Data data)
			{
				m_data.Add(data);
			}
		}

		private const string _UNKNOWN_VOICE_PATH = "{0}";

		private const string _CHARA_VOICE_PATH = "{0}/{1}";

		private const string _VOICE_PATH = "{0}{1}/{2}";

		private const string _LIPSYNC_FILENAME = "{0}_lipSync";

		private const GameDefine.CharaIndex _MOD_INDEX = GameDefine.CharaIndex.HITOKAGE;

		private const GameDefine.CharaID _MOB_ID = GameDefine.CharaID.HITOKAGE;

		private List<AsyncOperation> m_requests = new List<AsyncOperation>();

		private List<PlayData> m_playData;

		public bool IsLoading => m_requests.Count > 0;

		public VoiceLoader()
		{
			m_playData = new List<PlayData>();
			for (int i = 2; i <= 12; i++)
			{
				m_playData.Add(new PlayData(GameDefine.CharaIndexToID((GameDefine.CharaIndex)i)));
			}
			m_playData.Add(new PlayData(GameDefine.CharaID.MOMONO_RIN));
		}

		public void Clear()
		{
			int count = m_playData.Count;
			for (int i = 0; i < count; i++)
			{
				m_playData[i].Reset();
			}
			Resources.UnloadUnusedAssets();
		}

		private GameDefine.CharaID ConvertCharaID(GameDefine.CharaID chara)
		{
			if (GameDefine.IsModChara(chara))
			{
				return GameDefine.CharaID.HITOKAGE;
			}
			if (GameDefine.IsUnknownChara(chara))
			{
				chara = GameDefine.UnknownToCharaID(chara);
			}
			return GameDefine.GetOriginalCharaID(chara);
		}

		private PlayData FindPlayData(GameDefine.CharaID chara)
		{
			chara = ConvertCharaID(chara);
			int count = m_playData.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_playData[i].Chara == chara)
				{
					return m_playData[i];
				}
			}
			return null;
		}

		public Data GetData(GameDefine.CharaID chara)
		{
			return FindPlayData(chara)?.NextData();
		}

		private void AddData(GameDefine.CharaID chara, Data data)
		{
			PlayData playData = FindPlayData(chara);
			if (data != null)
			{
				playData.AddData(data);
			}
		}

		private string GetVoicePath(CommandText data, int index)
		{
			return string.Format("{0}{1}/{2}", "Audio/Voice/", SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID, index);
		}

		public void Load(int scenarioID, List<CommandText> commandList, GameDefine.CharaID charaID, bool isMemoryMode)
		{
			Clear();
			int count = commandList.Count;
			for (int i = 0; i < count; i++)
			{
				CommandText command = commandList[i];
				if (command.Chara == GameDefine.CharaID.BASE || command.Chara == GameDefine.CharaID.NONE)
				{
					continue;
				}
				int index = i;
				Data data = new Data(index, null);
				string path = CreateFilePath(command);
				ResourceRequest resourceRequest = Resources.LoadAsync<AudioClip>(path);
				resourceRequest.completed += delegate(AsyncOperation obj)
				{
					OnLoadClipComplete(obj, data, command.Chara, path, command, scenarioID, index);
				};
				m_requests.Add(resourceRequest);
				if (!isMemoryMode && command.Chara != charaID)
				{
					ResourceRequest resourceRequest2 = Resources.LoadAsync<OVRLipSyncSequence>($"{path}_lipSync");
					resourceRequest2.completed += delegate(AsyncOperation obj)
					{
						OnLoadSyncDataComplete(obj, data, command, scenarioID, index);
					};
					m_requests.Add(resourceRequest2);
				}
				AddData(command.Chara, data);
			}
			Resources.UnloadUnusedAssets();
		}

		private string CreateFilePath(CommandText command)
		{
			GameDefine.CharaID charaID = command.Chara;
			if (GameDefine.IsModChara(charaID))
			{
				return string.Format("{0}{1}", "Audio/Voice/Mob/", command.VoiceFile);
			}
			if (GameDefine.IsSpecialChara(charaID))
			{
				return string.Format("{0}{1}/{2}", "Audio/Voice/", (int)GameDefine.ConvertSpecialToNormal(charaID), command.VoiceFile);
			}
			if (GameDefine.IsUnknownChara(charaID))
			{
				charaID = GameDefine.UnknownToCharaID(charaID);
			}
			int num = (int)charaID % 10;
			int num2 = (int)(charaID - num);
			return string.Format("{0}{1}/{2}", "Audio/Voice/", num2, command.VoiceFile);
		}

		private Dictionary<GameDefine.CharaID, int> CreateIndexDictionary()
		{
			Dictionary<GameDefine.CharaID, int> dictionary = new Dictionary<GameDefine.CharaID, int>();
			for (int i = 2; i < 11; i++)
			{
				dictionary.Add(GameDefine.CharaIndexToID((GameDefine.CharaIndex)i), 0);
			}
			return dictionary;
		}

		private void OnLoadClipComplete(AsyncOperation obj, Data data, GameDefine.CharaID chara, string path, CommandText command, int scenarioID, int commandIndex)
		{
			m_requests.Remove(obj);
			AudioClip audioClip = (obj as ResourceRequest).asset as AudioClip;
			if (!(audioClip == null))
			{
				data.Clip = audioClip;
			}
		}

		private void OnLoadSyncDataComplete(AsyncOperation obj, Data data, CommandText command, int scenarioID, int commandIndex)
		{
			m_requests.Remove(obj);
			OVRLipSyncSequence oVRLipSyncSequence = (obj as ResourceRequest).asset as OVRLipSyncSequence;
			if (!(oVRLipSyncSequence == null))
			{
				data.LipSyncData = oVRLipSyncSequence;
			}
		}
	}
	public class VoicePlayer
	{
		private VoiceLoader m_loader;

		private CharaVoiceSource m_charaVoiceSource;

		private AdvCharaMorpthTargetData m_charaMorphData;

		private SceneSoundData m_sceneSettings;

		private float m_playerVolume;

		private AudioSource m_currentVoice;

		private AudioSource SourceMainVoice => MainPosition.AudioSourceVoice;

		public float Volume => SingletonMonoBehaviour<GameData>.Instance.ConfigData.VoiceVolume.Value;

		public bool IsLoading => m_loader.IsLoading;

		public bool IsForce2DMode { get; set; }

		public VoicePlayer(CharaVoiceSource charaVoiceSource, AdvCharaMorpthTargetData charaMorphData, float playerVolume)
		{
			IsForce2DMode = false;
			m_charaVoiceSource = charaVoiceSource;
			m_charaMorphData = charaMorphData;
			m_sceneSettings = null;
			m_playerVolume = playerVolume;
			m_loader = new VoiceLoader();
			m_currentVoice = null;
		}

		public void SetSceneSettings(SceneSoundData data)
		{
			m_sceneSettings = data;
		}

		public void Clear()
		{
			IsForce2DMode = false;
			m_loader.Clear();
		}

		public void LoadAllVoices(int scenarioID, List<CommandText> commandList, GameDefine.CharaID charaID, bool isMemoryMode)
		{
			m_loader.Load(scenarioID, commandList, charaID, isMemoryMode);
		}

		public bool IsPlayingVoice()
		{
			if (m_currentVoice == null)
			{
				return false;
			}
			return m_currentVoice.isPlaying;
		}

		public void PlayVoice(AudioClip clip, AudioSource source = null, bool loop = false)
		{
			float volume = Volume;
			if (source == null)
			{
				source = SourceMainVoice;
				volume = m_playerVolume;
			}
			source.volume = volume;
			source.loop = loop;
			m_currentVoice = source;
			source.clip = clip;
			source.Play();
		}

		public void PlayVoice(GameDefine.CharaID chara, AudioSource source = null, bool loop = false)
		{
			VoiceLoader.Data data = m_loader.GetData(chara);
			if (data != null)
			{
				PlayVoice(data.Clip, source, loop);
			}
		}

		public void PlayVoiceDearVr(GameDefine.CharaID charaID, CharaVoiceSource source, bool loop = false)
		{
			VoiceLoader.Data data = m_loader.GetData(charaID);
			if (data != null && !(data.Clip == null))
			{
				source.AudioSource.volume = Volume;
				source.AudioSource.loop = loop;
				m_currentVoice = source.AudioSource;
				source.AudioSource.clip = data.Clip;
				if (GameDefine.IsSpecialChara(charaID))
				{
					charaID = GameDefine.ConvertSpecialToNormal(charaID);
				}
				source.SetupChara(charaID);
				source.SetupDearVR(ref m_sceneSettings);
				source.SetupMorphTarget(m_charaMorphData, data);
				source.Play(isLipsync: true);
			}
		}

		public void PlayVoiceDearVrInMemoryMode(GameDefine.CharaID charaID, CharaVoiceSource source, Transform locator, VoiceLoader.Data data, bool loop = false)
		{
			if (data != null)
			{
				source.AudioSource.volume = Volume;
				source.AudioSource.loop = loop;
				m_currentVoice = source.AudioSource;
				source.AudioSource.clip = data.Clip;
				source.SetupToLocator(charaID, locator);
				source.SetupDearVR(ref m_sceneSettings);
				source.Play(isLipsync: false);
			}
		}

		public void PlayVoiceByData(CommandText data, bool loop = false)
		{
			GameDefine.CharaID charaID = data.Chara;
			if (GameDefine.IsUnknownChara(charaID))
			{
				charaID = GameDefine.UnknownToCharaID(charaID);
			}
			if (data.IsMemoryMode)
			{
				PlayMemoryModeVoice(data, loop);
				return;
			}
			if (charaID == GameDefine.CharaID.BASE || data.Is2DVoice || charaID == SingletonMonoBehaviour<LocalData>.Instance.CurrentCharaID)
			{
				PlayVoice(data.Chara, null, loop);
				return;
			}
			GameDefine.CharaID id = charaID;
			if (GameDefine.IsSpecialChara(id))
			{
				id = GameDefine.ConvertSpecialToNormal(id);
			}
			if (SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(id) == null)
			{
				PlayVoice(data.Chara, null, loop);
				return;
			}
			if (IsForce2DMode)
			{
				PlayVoice(data.Chara, null, loop);
				return;
			}
			PlayVoiceDearVr(charaID, m_charaVoiceSource, loop);
			SingletonMonoBehaviour<CharactersManager>.Instance.OnPlayVoice(charaID);
		}

		private void PlayMemoryModeVoice(CommandText data, bool loop)
		{
			IChara chara = data.FindCharacter();
			if (chara == null)
			{
				PlayVoice(data.Chara, null, loop);
				return;
			}
			AdvMemoryChara advMemoryChara = chara as AdvMemoryChara;
			PlayVoiceDearVrInMemoryMode((GameDefine.CharaID)advMemoryChara.CharaID, m_charaVoiceSource, MainPosition.FrontVoiceLocator, m_loader.GetData(data.Chara));
		}

		public void StopCurrentVoice()
		{
			if (SourceMainVoice.isPlaying)
			{
				SourceMainVoice.Stop();
			}
			SourceMainVoice.clip = null;
			if (IsPlayingVoice())
			{
				m_charaVoiceSource.StopVoice();
				m_currentVoice.Stop();
			}
		}
	}
	public class DitherFade
	{
		public const float _DEFAULT_FADE_DURATION = 0.3f;

		private const string _PARAM_ALPHA = "_Alpha";

		private const string _PARAM_OUTLINE_SIZE = "_Outline";

		private const string _PARAM_OUTLINE_COLOR = "_OutlineColor";

		private List<Material> m_materials;

		private Tweener<float> m_alphaTweener;

		private GameObject m_owner;

		private Func<IEnumerator> m_fadeCoroutineFunc;

		private float m_fromAlpha;

		private float m_targetAlpha;

		private float m_duration;

		public bool IsFading => m_alphaTweener.IsActive;

		public DitherFade(GameObject owner)
		{
			m_owner = owner;
			Renderer[] componentsInChildren = m_owner.GetComponentsInChildren<Renderer>();
			FindRendererMaterials(componentsInChildren);
			MakeTweener();
			CreateActions();
		}

		public DitherFade(GameObject owner, Material mat)
		{
			m_owner = owner;
			m_materials = new List<Material>(1);
			m_materials.Add(mat);
			MakeTweener();
			CreateActions();
		}

		public DitherFade(GameObject owner, Material[] mats)
		{
			m_owner = owner;
			m_materials = new List<Material>(mats);
			MakeTweener();
			CreateActions();
		}

		public DitherFade(GameObject owner, List<Material> mats)
		{
			m_owner = owner;
			m_materials = mats;
			MakeTweener();
			CreateActions();
		}

		private void CreateActions()
		{
			m_fadeCoroutineFunc = () => CoroutineFade();
		}

		private void FindRendererMaterials(Renderer[] renderers)
		{
			m_materials = new List<Material>();
			int num = renderers.Length;
			for (int i = 0; i < num; i++)
			{
				Material[] materials = renderers[i].materials;
				int num2 = materials.Length;
				for (int j = 0; j < num2; j++)
				{
					m_materials.Add(materials[j]);
				}
			}
		}

		private void MakeTweener()
		{
			m_alphaTweener = new Tweener<float>(Mathf.Lerp);
		}

		public void Update(float delta)
		{
			if (m_alphaTweener.IsActive)
			{
				m_alphaTweener.Update(delta);
				SetModelAlpha(m_alphaTweener.CurrentValue);
			}
		}

		public void SetModelAlpha(float alpha)
		{
			int count = m_materials.Count;
			for (int i = 0; i < count; i++)
			{
				m_materials[i].SetFloat("_Alpha", alpha);
			}
		}

		public void SetModelOutlineSize(float size)
		{
			int count = m_materials.Count;
			for (int i = 0; i < count; i++)
			{
				m_materials[i].SetFloat("_Outline", size);
			}
		}

		public void SetModelOutlineColor(Color color)
		{
			int count = m_materials.Count;
			for (int i = 0; i < count; i++)
			{
				m_materials[i].SetColor("_OutlineColor", color);
			}
		}

		public float GetModelOutlineSize()
		{
			return m_materials[0].GetFloat("_Outline");
		}

		public Color GetModelOutlineColor()
		{
			return m_materials[0].GetColor("_OutlineColor");
		}

		public void StartFade(float targetAlpha, float duration = 0.3f, Action onTweenEnd = null)
		{
			m_alphaTweener.Start(m_materials[0].GetFloat("_Alpha"), targetAlpha, duration, onTweenEnd);
		}

		public IDisposable StartFadeCoroutine(float targetAlpha, float duration = 0.3f, Action onTweenEnd = null)
		{
			return StartFadeCoroutine(m_materials[0].GetFloat("_Alpha"), targetAlpha, duration, onTweenEnd);
		}

		public IDisposable StartFadeCoroutine(float fromAlpha, float targetAlpha, float duration = 0.3f, Action onTweenEnd = null)
		{
			m_fromAlpha = fromAlpha;
			m_targetAlpha = targetAlpha;
			m_duration = duration;
			return Observable.FromMicroCoroutine(m_fadeCoroutineFunc).Subscribe(delegate
			{
				if (onTweenEnd != null)
				{
					onTweenEnd();
				}
			}).AddTo(m_owner);
		}

		private IEnumerator CoroutineFade()
		{
			while (m_alphaTweener.IsActive)
			{
				yield return null;
			}
			m_alphaTweener.Start(m_fromAlpha, m_targetAlpha, m_duration);
			SetModelAlpha(m_alphaTweener.CurrentValue);
			while (m_alphaTweener.IsActive)
			{
				yield return null;
				m_alphaTweener.Update(Time.deltaTime);
				SetModelAlpha(m_alphaTweener.CurrentValue);
			}
			yield return null;
		}

		public void AddOnFadeEndAction(Action action)
		{
			m_alphaTweener.AddAction(action);
		}
	}
	public class FadeManager : SingletonMonoBehaviour<FadeManager>
	{
		public UIFader sceneFader;

		public UIFader menuFader;

		public UIFader importantFader;

		public void FlashFade()
		{
			bool isDeactivateOnEnd = menuFader.EndColour.a <= 0.1f;
			menuFader.StartFade(ColorDefine.Black, menuFader.EndColour, 0.2f, isDeactivateOnEnd);
		}
	}
	public class GameInputHelper
	{
		public static void VibrateLaser(LaserController laser, float length, float power)
		{
			laser.Vibrate(length, power);
		}

		public static void VibrateLaserForFocus(LaserController laser)
		{
			VibrateLaser(laser, 0.05f, 0.2f);
		}

		public static void VibrateLaserForPress(LaserController laser)
		{
			VibrateLaser(laser, 0.1f, 0.6f);
		}
	}
	public class GameInputManager : SingletonMonoBehaviour<GameInputManager>
	{
		[Header("Parameters")]
		[SerializeField]
		private float _touchScrollSensivility = 4f;

		private TouchpadScroller[] _scrollers = new TouchpadScroller[3];

		private VRDeviceDefine.HandType _currentMainHand = VRDeviceDefine.HandType.None;

		private Subject<Unit> _subjectPositionReset = new Subject<Unit>();

		private BehaviorSubject<VRDeviceDefine.HandType> _subjectChangeMainHand = new BehaviorSubject<VRDeviceDefine.HandType>(VRDeviceDefine.HandType.None);

		private IObservable<Unit> _update;

		private IObservable<bool> _onToggleTrackedLeft;

		private IObservable<bool> _onToggleTrackedRight;

		public bool IsMenuOpened
		{
			get
			{
				if (!SingletonMonoBehaviour<MainMenuManager>.HasInstance)
				{
					return false;
				}
				return SingletonMonoBehaviour<MainMenuManager>.Instance.IsOpened;
			}
		}

		public bool IsMovileDevice => inputVR.IsMovileDevice;

		public bool IsRecenteredController => inputVR.IsRecenteredController;

		public VRDeviceDefine.HandType CurrentMainHand => _currentMainHand;

		public VRDeviceDefine.HandType PrefferdHand => SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.Value;

		public IObservable<VRDeviceDefine.HandType> PrefferdHandObservable => SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand;

		public bool IsMainHandAvailable => _currentMainHand != VRDeviceDefine.HandType.None;

		public VRDeviceDefine.HandType AvailableHand => inputVR.AvailableHand;

		public bool IsTwoSideController => AvailableHand == VRDeviceDefine.HandType.Both;

		public bool IsOneSideController
		{
			get
			{
				if (AvailableHand != 0)
				{
					return AvailableHand == VRDeviceDefine.HandType.Right;
				}
				return true;
			}
		}

		public IObservable<Unit> OnPositionReset => _subjectPositionReset;

		public IObservable<bool> OnToggleTrackedLeft => _onToggleTrackedLeft;

		public IObservable<bool> OnToggleTrackedRight => _onToggleTrackedRight;

		public IObservable<VRDeviceDefine.HandType> OnChangeMainHand => _subjectChangeMainHand;

		private BaseVRPlatform inputVR => SingletonMonoBehaviour<PlayAreaManager>.Instance.InputVR;

		protected override void InitializeOnAwake()
		{
			for (int i = 0; i < _scrollers.Length; i++)
			{
				TouchpadScroller touchpadScroller = new TouchpadScroller();
				touchpadScroller.Manager = this;
				touchpadScroller.TargetHand = (VRDeviceDefine.HandType)i;
				touchpadScroller.Sensivility = _touchScrollSensivility;
				touchpadScroller.StartOffset = 0.1f;
				_scrollers[i] = touchpadScroller;
			}
			_update = this.UpdateAsObservable();
			_update.Where((Unit _) => inputVR.IsTouchpadAvailable).Subscribe(delegate
			{
				UpdateAxisDelta();
			}).AddTo(base.gameObject);
			_update.Where((Unit _) => IsRecenteredController).ThrottleFirstFrame(30).Subscribe(delegate
			{
				RecenterPosition();
			})
				.AddTo(base.gameObject);
			_onToggleTrackedLeft = this.ObserveEveryValueChanged((GameInputManager x) => x.IsHandTracked(VRDeviceDefine.HandType.Left));
			_onToggleTrackedRight = this.ObserveEveryValueChanged((GameInputManager x) => x.IsHandTracked(VRDeviceDefine.HandType.Right));
		}

		private void Start()
		{
			SetUIMask();
			InitMainHandProcess();
			RecenterPositionWithoutFade();
		}

		private void SetUIMask()
		{
			LaserInputModule.module.SetUICameraMask((1 << LayerMask.NameToLayer("UI")) | (1 << LayerMask.NameToLayer("SelectionTarget")));
		}

		private void InitMainHandProcess()
		{
			PrefferdHandObservable.Where((VRDeviceDefine.HandType type) => IsTwoSideController && !IsMainHand(type)).Subscribe(delegate(VRDeviceDefine.HandType type)
			{
				SetMainHand(type);
			});
			_update.Where((Unit _) => IsOneSideController && !IsMainHand(inputVR.AvailableHand)).Subscribe(delegate
			{
				SetMainHand(inputVR.AvailableHand);
			});
		}

		private void SetMainHand(VRDeviceDefine.HandType type)
		{
			if (_currentMainHand != type)
			{
				_currentMainHand = type;
				_subjectChangeMainHand.OnNext(_currentMainHand);
			}
		}

		private void CheckMainHand()
		{
			if (!IsTwoSideController)
			{
				if (IsHandTracked(VRDeviceDefine.HandType.Right))
				{
					SetMainHand(VRDeviceDefine.HandType.Right);
				}
				else if (IsHandTracked(VRDeviceDefine.HandType.Left))
				{
					SetMainHand(VRDeviceDefine.HandType.Left);
				}
				else
				{
					SetMainHand(VRDeviceDefine.HandType.None);
				}
			}
		}

		public bool IsMainHand(VRDeviceDefine.HandType checkType)
		{
			if (!IsMainHandAvailable)
			{
				return false;
			}
			if (_currentMainHand == VRDeviceDefine.HandType.Both)
			{
				return true;
			}
			return checkType == _currentMainHand;
		}

		private void UpdateAxisDelta()
		{
			for (int i = 0; i < _scrollers.Length; i++)
			{
				_scrollers[i].UpdateAxisDelta(Time.deltaTime);
			}
		}

		public void RecenterPositionWithoutFade()
		{
			SingletonMonoBehaviour<PlayAreaManager>.Instance.InputVR.Recenter();
			_subjectPositionReset.OnNext(Unit.Default);
		}

		public void RecenterPosition()
		{
			SingletonMonoBehaviour<FadeManager>.Instance.FlashFade();
			SingletonMonoBehaviour<PlayAreaManager>.Instance.InputVR.Recenter();
			_subjectPositionReset.OnNext(Unit.Default);
		}

		public void MoveToController(Transform tf, VRDeviceDefine.HandType hand)
		{
			tf.localPosition = GetHandPosition(hand);
			tf.localRotation = GetHandRotation(hand);
		}

		public bool IsHandTracked(VRDeviceDefine.HandType hand)
		{
			return inputVR.IsHandTracked(hand);
		}

		public Vector3 GetHandPosition(VRDeviceDefine.HandType hand)
		{
			return inputVR.GetHandPosition(hand);
		}

		public Quaternion GetHandRotation(VRDeviceDefine.HandType hand)
		{
			return inputVR.GetHandRotation(hand);
		}

		public bool GetVRButton(VRDeviceDefine.HandType hand, VRDeviceDefine.Buttons button)
		{
			return inputVR.GetVRButton(hand, button);
		}

		public bool GetVRButtonDown(VRDeviceDefine.HandType hand, VRDeviceDefine.Buttons button)
		{
			return inputVR.GetVRButtonDown(hand, button);
		}

		public bool GetVRButtonUp(VRDeviceDefine.HandType hand, VRDeviceDefine.Buttons button)
		{
			return inputVR.GetVRButtonUp(hand, button);
		}

		public bool GetAxisPadStartTouch(VRDeviceDefine.HandType hand)
		{
			return inputVR.GetAxisPadStartTouch(hand);
		}

		public bool GetAxisPadTouching(VRDeviceDefine.HandType hand)
		{
			return inputVR.GetAxisPadTouching(hand);
		}

		public Vector2 GetAxisPad2D(VRDeviceDefine.HandType hand)
		{
			return inputVR.GetAxisPad2D(hand);
		}

		public Vector2 GetAxisStick2D(VRDeviceDefine.HandType hand)
		{
			return inputVR.GetAxisStick2D(hand);
		}

		public Vector2 GetVRScrollDelta(VRDeviceDefine.HandType hand)
		{
			Vector2 axisStick2D = GetAxisStick2D(hand);
			if (inputVR.IsTouchpadAvailable)
			{
				axisStick2D += _scrollers[(int)hand].AxisDelta;
			}
			return axisStick2D;
		}

		public void Vibrate(VRDeviceDefine.HandType hand, float length, float power)
		{
			inputVR.Vibrate(hand, length, power);
		}

		public void OnBackFromRoot()
		{
			inputVR.OnBackFromRoot();
		}
	}
	public class TouchpadScroller
	{
		public GameInputManager Manager;

		public VRDeviceDefine.HandType TargetHand;

		public float Sensivility;

		public float StartOffset;

		private Vector2 _axisDelta;

		private Vector2 _oldAxis;

		private Vector2 _lastSpeed;

		private Common.Timer _timerSmooth = new Common.Timer(0f);

		public bool IsTouching { get; private set; }

		public bool IsScrolling { get; private set; }

		public Vector2 AxisDelta => _axisDelta;

		public void UpdateAxisDelta(float deltaTime)
		{
			if (Manager.GetAxisPadTouching(TargetHand))
			{
				Vector2 axisPad2D = Manager.GetAxisPad2D(TargetHand);
				if (IsTouching)
				{
					Vector2 vector = axisPad2D - _oldAxis;
					if (IsScrolling)
					{
						if (!Manager.GetAxisPadStartTouch(TargetHand))
						{
							_axisDelta = (axisPad2D - _oldAxis) * (0f - Sensivility);
							_lastSpeed = _axisDelta;
						}
						_oldAxis = axisPad2D;
					}
					else
					{
						_lastSpeed = Vector2.zero;
						if (vector.sqrMagnitude >= StartOffset * StartOffset)
						{
							IsScrolling = true;
						}
					}
				}
				else
				{
					IsTouching = true;
					_oldAxis = axisPad2D;
				}
			}
			else
			{
				_ = IsScrolling;
				IsTouching = false;
				IsScrolling = false;
				if (_timerSmooth.IsTimeUp)
				{
					_axisDelta = (_oldAxis = Vector2.zero);
					return;
				}
				_oldAxis = Vector2.zero;
				_timerSmooth.Update(deltaTime);
				_axisDelta = Vector2.Lerp(_lastSpeed, Vector2.zero, _timerSmooth.Rate);
			}
		}
	}
	public class TriggerValueWatcher
	{
		private Func<float> _triggerValueCallback;

		private float _threshould;

		public bool IsDown { get; private set; }

		public bool IsPressing { get; private set; }

		public bool IsUp { get; private set; }

		public float Value { get; private set; }

		public TriggerValueWatcher(Func<float> triggerValue, float threshould)
		{
			_triggerValueCallback = triggerValue;
			_threshould = threshould;
		}

		public void StartWatch(GameObject updateObject)
		{
			updateObject.UpdateAsObservable().Subscribe(delegate
			{
				UpdateTrigger();
			}).AddTo(updateObject);
		}

		public void UpdateTrigger()
		{
			IsDown = false;
			IsUp = false;
			Value = _triggerValueCallback();
			bool flag = Value >= _threshould;
			if (flag != IsPressing)
			{
				IsPressing = flag;
				if (IsPressing)
				{
					IsDown = true;
				}
				else
				{
					IsUp = true;
				}
			}
		}
	}
	public class MainMenuCaller : UpdateableComponent
	{
		[Header("Parameters")]
		[Tooltip("")]
		[SerializeField]
		private bool canOpenManually = true;

		[Tooltip("UITrue ()")]
		[SerializeField]
		private bool useDeviceMenu = true;

		public bool IsMenuOpened
		{
			get
			{
				if (!SingletonMonoBehaviour<MainMenuManager>.HasInstance)
				{
					return false;
				}
				return SingletonMonoBehaviour<MainMenuManager>.Instance.IsOpened;
			}
		}

		private GameInputManager input => SingletonMonoBehaviour<GameInputManager>.Instance;

		public override void OnUpdate(float delta)
		{
			if (SingletonMonoBehaviour<MasterManager>.Instance.IsTitleScene || SingletonMonoBehaviour<MasterManager>.Instance.IsBusy)
			{
				return;
			}
			if (input.IsMovileDevice)
			{
				if (canOpenManually)
				{
					if (input.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.DeviceBack))
					{
						if (!useDeviceMenu || !IsMenuOpened)
						{
							input.OnBackFromRoot();
						}
						else
						{
							OnCancelButtonPressed();
						}
					}
					else if (input.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.Cancel))
					{
						OnCancelButtonPressed();
					}
				}
				else if (useDeviceMenu && input.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.DeviceBack))
				{
					input.OnBackFromRoot();
				}
			}
			else if (canOpenManually && input.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.Cancel))
			{
				OnCancelButtonPressed();
			}
		}

		public void OnCancelButtonPressed()
		{
			if (SingletonMonoBehaviour<MainMenuManager>.HasInstance)
			{
				if (IsMenuOpened)
				{
					SingletonMonoBehaviour<MainMenuManager>.Instance.OnPressHardwareBackButton();
				}
				else
				{
					SingletonMonoBehaviour<MainMenuManager>.Instance.OpenMenu();
				}
			}
		}
	}
	public class TimelineInput : MonoBehaviour
	{
		private Common.Timer m_autoTimer;

		private Common.Timer m_autoStartTimer;

		private bool m_horzToggle;

		private bool _isPageOk;

		private bool _isPageReadyOk;

		private bool _preventedByMenu;

		[Header("Parameters - Auto Mode")]
		[SerializeField]
		private float m_autoWaitMonologue = 1f;

		[SerializeField]
		private float m_autoWaitSelif = 0.2f;

		[SerializeField]
		private float m_autoWaitStartPress = 1f;

		private TimelinePlayer m_player;

		private bool IsAutoWaitNeedOverride => m_messagePlayer.IsAutoWaitNeedOverride;

		private float AutoWaitOverride => m_messagePlayer.AutoWaitOverride;

		private MessagePlayer m_messagePlayer => m_player.MessageProcessor;

		private GameInputManager input => SingletonMonoBehaviour<GameInputManager>.Instance;

		private bool IsAutoMode => m_messagePlayer.IsAutoMode;

		private bool IsSkipMode => m_messagePlayer.IsSkipMode;

		private bool IsChangingAuto => m_autoStartTimer.CurrentTime > 0f;

		private bool IsPlayable
		{
			get
			{
				if (SingletonMonoBehaviour<InGameManager>.HasInstance && SingletonMonoBehaviour<InGameManager>.Instance.IsReady)
				{
					return !_preventedByMenu;
				}
				return false;
			}
		}

		private bool CanInterract => m_messagePlayer.CanInterract;

		private bool IsOpenedDebugConsole => false;

		private void Start()
		{
			m_player = GetComponent<TimelinePlayer>();
			m_autoTimer = new Common.Timer(m_autoWaitMonologue);
			m_autoStartTimer = new Common.Timer(m_autoWaitStartPress);
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			m_messagePlayer.OnAddMessageLog.Subscribe(delegate(CommandText message)
			{
				if (IsAutoWaitNeedOverride)
				{
					m_autoTimer.SetDuration(AutoWaitOverride);
				}
				else
				{
					m_autoTimer.SetDuration(message.IsMonologue ? m_autoWaitMonologue : m_autoWaitSelif);
				}
			});
			SingletonMonoBehaviour<MainMenuManager>.Instance.OnToggleMenu.Where((bool flag) => flag).Subscribe(delegate
			{
				_preventedByMenu = true;
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MainMenuManager>.Instance.OnToggleMenu.Where((bool flag) => !flag).DelayFrame(1).Subscribe(delegate
			{
				_preventedByMenu = false;
			})
				.AddTo(base.gameObject);
		}

		public void UpdateInputModeChange()
		{
			if (!IsAutoMode && IsPlayable && input.GetVRButton(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.MainAction))
			{
				UpdateAutoModeStartInput();
			}
			else if (IsChangingAuto)
			{
				m_autoStartTimer.Reset();
			}
			if (IsPlayable)
			{
				if (input.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.MainAction))
				{
					if (IsOpenedDebugConsole)
					{
						_isPageOk = false;
						_isPageReadyOk = false;
					}
					else if (m_messagePlayer.IsRemoveInterface)
					{
						m_messagePlayer.IsRemoveInterface = false;
						_isPageOk = false;
						_isPageReadyOk = false;
					}
					else if (!CanInterract)
					{
						if (m_messagePlayer.IsPlayPageSound)
						{
							SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Error);
						}
						_isPageOk = false;
						_isPageReadyOk = false;
					}
					else if (IsAutoMode || IsSkipMode)
					{
						m_messagePlayer.SetPlayMode(MessagePlayer.PlayModes.Normal);
						_isPageOk = false;
						_isPageReadyOk = false;
					}
					else
					{
						_isPageReadyOk = true;
					}
				}
			}
			else if (IsSkipMode)
			{
				m_messagePlayer.SetPlayMode(MessagePlayer.PlayModes.Normal);
			}
			if (input.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.RemoveInterface))
			{
				m_messagePlayer.IsRemoveInterface = !m_messagePlayer.IsRemoveInterface;
			}
		}

		public void UpdateMessageInput()
		{
			if (!IsPlayable)
			{
				if (IsAutoWaitNeedOverride)
				{
					m_autoTimer.Update(Time.deltaTime);
				}
				else if (IsAutoMode && m_autoTimer.CurrentTime > 0f)
				{
					m_autoTimer.Reset();
				}
				return;
			}
			if (IsSkipMode)
			{
				m_messagePlayer.OnProcessAuto();
				return;
			}
			if (input.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.MainAction))
			{
				_isPageOk = _isPageReadyOk;
			}
			if (input.GetVRButtonUp(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.MainAction))
			{
				if (!IsSkipMode && !_isPageOk)
				{
					_isPageOk = true;
				}
				else
				{
					m_messagePlayer.OnPushMainButton();
				}
			}
			else if (IsAutoWaitNeedOverride)
			{
				m_autoTimer.Update(Time.deltaTime);
				if (IsAutoMode && m_autoTimer.IsTimeUp && !SingletonMonoBehaviour<PlayAreaManager>.Instance.IsOutOfBoundary.Value)
				{
					m_autoTimer.Reset();
					m_messagePlayer.OnProcessAuto();
				}
			}
			else
			{
				if (!IsAutoMode)
				{
					return;
				}
				if (SingletonMonoBehaviour<PlayAreaManager>.Instance.IsOutOfBoundary.Value)
				{
					if (m_autoTimer.CurrentTime > 0f)
					{
						m_autoTimer.Reset();
					}
				}
				else if (!IsChangingAuto && m_messagePlayer.IsAutoCounterOk())
				{
					m_autoTimer.Update(Time.deltaTime);
					if (m_autoTimer.IsTimeUp)
					{
						m_autoTimer.Reset();
						m_messagePlayer.OnProcessAuto();
					}
				}
			}
		}

		private void UpdateAutoModeStartInput()
		{
			if (m_autoStartTimer.IsTimeUp)
			{
				return;
			}
			m_autoStartTimer.Update(Time.deltaTime);
			if (!m_autoStartTimer.IsTimeUp)
			{
				return;
			}
			_isPageOk = false;
			if (!CanInterract || !m_messagePlayer.GetCanToggleModeTo(MessagePlayer.PlayModes.Auto))
			{
				SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Error);
				return;
			}
			if (!IsAutoWaitNeedOverride)
			{
				m_autoTimer.Reset();
			}
			m_messagePlayer.SetPlayMode(MessagePlayer.PlayModes.Auto);
		}
	}
	public class PlayAreaPositioner : MonoBehaviour
	{
		[Header("Parameters - Positioning")]
		[Tooltip("Start()PlayArea")]
		[SerializeField]
		private bool _positionOnStart = true;

		[Tooltip("FalsePlayArea")]
		[SerializeField]
		private bool _ignoreParentize;

		[Header("Parameters - Color")]
		[SerializeField]
		private bool _setColorOnAttach;

		[SerializeField]
		private Color _clearColor = ColorDefine.Black;

		private void Start()
		{
			if (_positionOnStart)
			{
				AttachPlayArea();
			}
		}

		public void AttachPlayArea()
		{
			if (SingletonMonoBehaviour<PlayAreaManager>.HasInstance)
			{
				Transform myTransform = SingletonMonoBehaviour<PlayAreaManager>.Instance.MyTransform;
				if (_ignoreParentize)
				{
					myTransform.position = base.transform.position;
					myTransform.rotation = base.transform.rotation;
				}
				else
				{
					myTransform.SetParent(base.transform, worldPositionStays: false);
					myTransform.ResetLocal();
				}
				if (_setColorOnAttach)
				{
					SingletonMonoBehaviour<PlayAreaManager>.Instance.SetClearColor(_clearColor);
				}
			}
		}

		public void Detach()
		{
			if (!_ignoreParentize && SingletonMonoBehaviour<PlayAreaManager>.HasInstance)
			{
				SingletonMonoBehaviour<PlayAreaManager>.Instance.MyTransform.SetParent(null);
			}
		}
	}
	public abstract class ResourceDataLoader<T> where T : UnityEngine.Object
	{
		public class Data
		{
			public int ID;

			public T LoadData;

			public Data(int id, T data)
			{
				ID = id;
				LoadData = data;
			}
		}

		private List<AsyncOperation> m_requests = new List<AsyncOperation>();

		private List<Data> m_dataList = new List<Data>();

		private bool m_isUnload;

		public virtual bool IsLoading => m_requests.Count > 0;

		public ResourceDataLoader(bool isUnload)
		{
			m_isUnload = isUnload;
			m_dataList = new List<Data>();
		}

		public virtual void Clear()
		{
			int count = m_dataList.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_isUnload)
				{
					Resources.UnloadAsset(m_dataList[i].LoadData);
				}
				m_dataList[i].LoadData = null;
				m_dataList[i] = null;
			}
			m_dataList.Clear();
			m_requests.Clear();
			Resources.UnloadUnusedAssets();
		}

		public virtual void Load(List<int> preloadIndexes)
		{
			if (preloadIndexes == null)
			{
				return;
			}
			UnloadUnusedData(preloadIndexes);
			preloadIndexes.ForEach(delegate(int id)
			{
				ResourceRequest resourceRequest = Resources.LoadAsync<T>(CreateFilePath(id));
				resourceRequest.completed += delegate(AsyncOperation obj)
				{
					OnLoadEnd(obj, id);
				};
				m_requests.Add(resourceRequest);
			});
		}

		private void UnloadUnusedData(List<int> preloadIndexes)
		{
			if (preloadIndexes.Count <= 0)
			{
				return;
			}
			for (int i = 0; i < m_dataList.Count; i++)
			{
				bool flag = RemoveCommandWithID(preloadIndexes, m_dataList[i].ID);
				if (preloadIndexes.Count <= 0)
				{
					break;
				}
				if (!flag)
				{
					Resources.UnloadAsset(m_dataList[i].LoadData);
					m_dataList[i].LoadData = null;
					OnDataRemoved(m_dataList[i].ID);
					m_dataList.RemoveAt(i);
					i--;
				}
			}
			Resources.UnloadUnusedAssets();
		}

		private bool RemoveCommandWithID(List<int> list, int id)
		{
			return list.RemoveAll((int i) => i == id) > 0;
		}

		protected virtual void OnDataRemoved(int id)
		{
		}

		protected abstract string CreateFilePath(int id);

		private void OnLoadEnd(AsyncOperation obj, int id)
		{
			m_requests.Remove(obj);
			T val = (obj as ResourceRequest).asset as T;
			if (!(val == null))
			{
				m_dataList.Add(new Data(id, val));
				OnLoadComplete(m_dataList[m_dataList.Count - 1]);
			}
		}

		protected virtual void OnLoadComplete(Data data)
		{
		}
	}
	public class MasterManager : SingletonMonoBehaviour<MasterManager>
	{
		[Header("Parameters - Scenes")]
		[SerializeField]
		private SceneDefine _titleScene = SceneDefine.Title;

		[SerializeField]
		private SceneDefine _blankScene = SceneDefine.Blank;

		[SerializeField]
		private List<SceneDefine> _ingameSceneDefines = new List<SceneDefine>();

		[Header("Parameters - Others")]
		[SerializeField]
		private float _fadeDurationExit = 1f;

		private List<Scene> _loadedInGameScenes = new List<Scene>();

		private SortedDictionary<int, Component> _busyComponentList = new SortedDictionary<int, Component>();

		private int _loadedCount;

		private SceneDefine _unloadToScene;

		private Subject<Unit> _subjectLoadCompleteInGame = new Subject<Unit>();

		private Subject<Unit> _subjectBeforeExitFade = new Subject<Unit>();

		private Subject<Unit> _subjectBeforeEndInGame = new Subject<Unit>();

		private Subject<int> _subjectBeforeStartInGame = new Subject<int>();

		private Subject<bool> _subjectToggleBusyProcess = new Subject<bool>();

		private AsyncSubject<Unit> _subjectQuitApplication = new AsyncSubject<Unit>();

		public bool IsInGame { get; private set; }

		public bool IsBusy { get; private set; }

		public bool IsTitleScene => SingletonMonoBehaviour<TransitionManager>.Instance.CurrentSceneId == TitleScene;

		public SceneDefine TitleScene => _titleScene;

		public bool IsSuperAutoMode => false;

		public SortedDictionary<int, Component> BusyComponentList => _busyComponentList;

		public IObservable<Unit> OnLoadCompleteInGame => _subjectLoadCompleteInGame;

		public IObservable<Unit> OnBeforeExitFade => _subjectBeforeExitFade;

		public IObservable<Unit> OnBeforeEndInGame => _subjectBeforeEndInGame;

		public IObservable<int> OnBeforeStartInGame => _subjectBeforeStartInGame;

		public IObservable<bool> OnToggleBusyProcess => _subjectToggleBusyProcess;

		public IObservable<Unit> OnQuitApplication => _subjectQuitApplication;

		private void Start()
		{
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			OnBeforeExitFade.Subscribe(delegate
			{
				SingletonMonoBehaviour<SoundManager>.Instance.StopAll(BgmPlayer.StopMode.Fade, _fadeDurationExit);
				SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.Dispose();
			});
		}

		public void ForceToTitle()
		{
			SingletonMonoBehaviour<SoundManager>.Instance.StopAll();
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.Dispose();
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.SetColour(ColorDefine.Black);
			if (IsInGame)
			{
				ExitInGame();
			}
			else if (IsTitleScene)
			{
				SingletonMonoBehaviour<TransitionManager>.Instance.ChangeActiveSceneAsync(_blankScene, (TransitionManager.OnComplete)delegate
				{
					SingletonMonoBehaviour<TransitionManager>.Instance.ChangeActiveSceneAsync(TitleScene);
				});
			}
			else
			{
				SingletonMonoBehaviour<TransitionManager>.Instance.ChangeActiveSceneAsync(TitleScene);
			}
		}

		public void StartInGame(int scenarioId = -1)
		{
			AddBusy(this);
			_subjectBeforeStartInGame.OnNext(scenarioId);
			SingletonMonoBehaviour<TransitionManager>.Instance.ChangeActiveSceneAsync(_blankScene, (TransitionManager.OnComplete)delegate
			{
				if (IsInGame)
				{
					OnLoadedAllInGame();
				}
				else
				{
					int count = _ingameSceneDefines.Count;
					for (int i = 0; i < count; i++)
					{
						SceneDefine sceneId = _ingameSceneDefines[i];
						SingletonMonoBehaviour<TransitionManager>.Instance.AddSceneAsync(sceneId, OnLoadedInGameScene);
					}
				}
			});
		}

		private void OnLoadedInGameScene(Scene scene)
		{
			_loadedCount++;
			_loadedInGameScenes.Add(scene);
			if (_loadedCount >= _ingameSceneDefines.Count)
			{
				_subjectLoadCompleteInGame.OnNext(Unit.Default);
				OnLoadedAllInGame();
			}
		}

		private void OnLoadedAllInGame()
		{
			RenderSettings.fog = false;
			IsInGame = true;
			RemoveBusy(this);
			SingletonMonoBehaviour<InGameManager>.Instance.ReadyOnStart();
		}

		public void ExitFade(Action onFadeEnd)
		{
			_subjectBeforeExitFade.OnNext(Unit.Default);
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.StartFade(ColorDefine.Black, _fadeDurationExit, isDeactivateOnEnd: false, onFadeEnd);
		}

		public void ExitInGameWithFade()
		{
			ExitInGameWithFade(TitleScene);
		}

		public void ExitInGameWithFade(SceneDefine nextScene)
		{
			if (IsInGame)
			{
				SingletonMonoBehaviour<InGameManager>.Instance.DisableReady();
			}
			ExitFade(delegate
			{
				ExitInGame(nextScene);
			});
		}

		public void ExitInGame()
		{
			ExitInGame(TitleScene);
		}

		public void ExitInGame(SceneDefine nextScene)
		{
			_subjectBeforeEndInGame.OnNext(Unit.Default);
			_unloadToScene = nextScene;
			if (IsInGame)
			{
				IsInGame = false;
				for (int num = _loadedInGameScenes.Count - 1; num >= 0; num--)
				{
					_ = _loadedInGameScenes[num];
					SingletonMonoBehaviour<TransitionManager>.Instance.UnloadSceneAsync(SceneDefine.InGame, delegate
					{
						OnUnloadInGame();
					});
				}
				_loadedInGameScenes.Clear();
			}
			else
			{
				OnUnLoadedAllInGame();
			}
		}

		private void OnUnloadInGame()
		{
			_loadedCount--;
			if (_loadedCount <= 0)
			{
				OnUnLoadedAllInGame();
			}
		}

		private void OnUnLoadedAllInGame()
		{
			SingletonMonoBehaviour<TransitionManager>.Instance.ChangeActiveSceneAsync(_unloadToScene);
		}

		public void StartScenarioWithFade(int scenarioToLoad)
		{
			if (IsInGame)
			{
				SingletonMonoBehaviour<InGameManager>.Instance.DisableReady();
			}
			ExitFade(delegate
			{
				StartScenario(scenarioToLoad);
			});
		}

		public void StartScenario(int scenarioToLoad)
		{
			StartInGame(scenarioToLoad);
		}

		public void StartScenarioFromFileWithFade(int fileIndex)
		{
			if (IsInGame)
			{
				SingletonMonoBehaviour<InGameManager>.Instance.DisableReady();
			}
			ExitFade(delegate
			{
				StartScenarioFromFile(fileIndex);
			});
		}

		public void StartScenarioFromFile(int fileIndex)
		{
			SingletonMonoBehaviour<GameData>.Instance.LoadSaveData(fileIndex);
			StartInGame(SingletonMonoBehaviour<GameData>.Instance.CurrentSaveData.SequenceID);
		}

		public void StartScenarioFromAutoSave()
		{
			StartScenarioFromFile(0);
		}

		public void SaveGame(int fileIndex)
		{
			if (IsInGame)
			{
				SingletonMonoBehaviour<GameData>.Instance.Save(fileIndex);
			}
		}

		public void AutoSave()
		{
			if (!SingletonMonoBehaviour<DataManager>.Instance.GeneralData.GetScenarioInfo(SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID).IgnoreFileSave)
			{
				SaveGame(0);
			}
		}

		public void AddBusy(Component comp)
		{
			int hashCode = comp.GetHashCode();
			if (!_busyComponentList.ContainsKey(hashCode))
			{
				_busyComponentList.Add(hashCode, comp);
				ToggleBusy(flag: true);
			}
		}

		public void RemoveBusy(Component comp)
		{
			int hashCode = comp.GetHashCode();
			if (_busyComponentList.Remove(hashCode) && _busyComponentList.Count == 0)
			{
				ToggleBusy(flag: false);
			}
		}

		private void ToggleBusy(bool flag)
		{
			if (flag != IsBusy)
			{
				IsBusy = flag;
				_subjectToggleBusyProcess.OnNext(flag);
			}
		}

		private void OnApplicationQuit()
		{
			_subjectQuitApplication.OnNext(Unit.Default);
			_subjectQuitApplication.OnCompleted();
		}
	}
	public class PermanentObjectLoader : MonoBehaviour
	{
		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void LoadPermanentObjects()
		{
			UnityEngine.Debug.unityLogger.logEnabled = false;
			AnalyticsUtility.Initialize();
			VrUtility.OnLoadStart(isChangeGraphics: false);
			InitializeDoTween();
			SceneDefine[] array = new SceneDefine[2]
			{
				SceneDefine.Permanent,
				SceneDefine.MainMenu
			};
			for (int i = 0; i < array.Length; i++)
			{
				int num = (int)array[i];
				if (!SceneManager.GetSceneByBuildIndex(num).IsValid())
				{
					SceneManager.LoadScene(num, LoadSceneMode.Additive);
				}
			}
		}

		private static bool IsBootScene(Scene scene)
		{
			return false;
		}

		private static bool IsGameScene(SceneDefine scene)
		{
			return !IsNonGameScene(scene);
		}

		private static bool IsNonGameScene(SceneDefine scene)
		{
			if (scene != SceneDefine.Backstreet)
			{
				return scene != SceneDefine.Crossing;
			}
			return false;
		}

		private static bool IsInGamePermanentScene(SceneDefine scene)
		{
			if (scene != SceneDefine.InGame)
			{
				return scene == SceneDefine.MainMenu;
			}
			return true;
		}

		private static void InitializeDoTween()
		{
			DOTween.Init();
		}
	}
	public class TransitionManager : SingletonMonoBehaviour<TransitionManager>
	{
		public delegate void OnComplete();

		public delegate void OnCompleteScene(Scene loadedScene);

		private Scene _currentScene;

		private AsyncOperation _asyncLoad;

		private bool _isChangeingScene;

		private Dictionary<int, AsyncOperation> _loadReservedScenes = new Dictionary<int, AsyncOperation>();

		private Subject<Scene> _subjectBeforeTransition = new Subject<Scene>();

		private Subject<Scene> _subjectCompleteTransition = new Subject<Scene>();

		public float ProgressChange
		{
			get
			{
				if (_asyncLoad == null)
				{
					if (!_isChangeingScene)
					{
						return 1f;
					}
					return 0f;
				}
				return _asyncLoad.progress;
			}
		}

		public Scene CurrentScene => _currentScene;

		public SceneDefine CurrentSceneId => GetSceneIdByScene(_currentScene);

		public IObservable<Scene> OnBeforeTransition => _subjectBeforeTransition;

		public IObservable<Scene> OnCompleteTransition => _subjectCompleteTransition;

		protected override void InitializeOnAwake()
		{
			ResetCurrentScene();
			OnBeforeTransition.Where((Scene _) => !SingletonMonoBehaviour<MasterManager>.Instance.IsInGame).Subscribe(delegate
			{
				SingletonMonoBehaviour<MasterManager>.Instance.AddBusy(this);
			});
			OnCompleteTransition.Subscribe(delegate
			{
				SingletonMonoBehaviour<MasterManager>.Instance.RemoveBusy(this);
			});
		}

		private void OnDestroy()
		{
			_subjectCompleteTransition.OnCompleted();
		}

		public void ResetCurrentScene()
		{
			_currentScene = SceneManager.GetActiveScene();
		}

		public void SetActiveScene(SceneDefine sceneId)
		{
			SetActiveScene((int)sceneId);
		}

		public void SetActiveScene(int sceneId)
		{
			Scene sceneByBuildIndex = SceneManager.GetSceneByBuildIndex(sceneId);
			if (sceneByBuildIndex.IsValid())
			{
				SetActiveScene(sceneByBuildIndex);
			}
		}

		public void SetActiveScene(Scene scene)
		{
			SceneManager.SetActiveScene(scene);
			ResetCurrentScene();
		}

		public void ChangeActiveSceneAsync(SceneDefine sceneId)
		{
			ChangeActiveSceneAsync((int)sceneId);
		}

		public void ChangeActiveSceneAsync(int sceneId)
		{
			Observable.FromCoroutine((IObserver<Scene> ob) => CoroutineSceneTransition(ob, sceneId)).Subscribe(delegate
			{
			});
		}

		public void ChangeActiveSceneAsync(SceneDefine sceneId, OnComplete onLoaded)
		{
			ChangeActiveSceneAsync((int)sceneId, onLoaded);
		}

		public void ChangeActiveSceneAsync(int sceneId, OnComplete onLoaded)
		{
			Observable.FromCoroutine((IObserver<Scene> ob) => CoroutineSceneTransition(ob, sceneId)).Subscribe(delegate
			{
				onLoaded();
			});
		}

		public void ChangeActiveSceneAsync(SceneDefine sceneId, OnCompleteScene onLoaded)
		{
			ChangeActiveSceneAsync((int)sceneId, onLoaded);
		}

		public void ChangeActiveSceneAsync(int sceneId, OnCompleteScene onLoaded)
		{
			Observable.FromCoroutine((IObserver<Scene> ob) => CoroutineSceneTransition(ob, sceneId)).Subscribe(delegate(Scene scene)
			{
				onLoaded(scene);
			});
		}

		private IEnumerator CoroutineSceneTransition(IObserver<Scene> ob, int sceneId)
		{
			if (_currentScene.IsValid() && sceneId == _currentScene.buildIndex)
			{
				yield return null;
				_currentScene = SceneManager.GetSceneByBuildIndex(sceneId);
				ob.OnNext(_currentScene);
				ob.OnCompleted();
				yield break;
			}
			if (_isChangeingScene)
			{
				ob.OnCompleted();
				yield break;
			}
			_subjectBeforeTransition.OnNext(_currentScene);
			_isChangeingScene = true;
			if (_currentScene.IsValid())
			{
				yield return SceneManager.UnloadSceneAsync(_currentScene);
			}
			if (_loadReservedScenes.ContainsKey(sceneId))
			{
				yield return _loadReservedScenes[sceneId];
				_loadReservedScenes.Remove(sceneId);
			}
			else
			{
				_asyncLoad = SceneManager.LoadSceneAsync(sceneId, LoadSceneMode.Additive);
				yield return _asyncLoad;
			}
			Scene scene = (_currentScene = SceneManager.GetSceneByBuildIndex(sceneId));
			SceneManager.SetActiveScene(scene);
			GC.Collect();
			Resources.UnloadUnusedAssets();
			_isChangeingScene = false;
			_subjectCompleteTransition.OnNext(scene);
			ob.OnNext(scene);
			ob.OnCompleted();
		}

		public void AddScene(SceneDefine sceneId)
		{
			AddScene((int)sceneId);
		}

		public void AddScene(int sceneId)
		{
			SceneManager.LoadScene(sceneId, LoadSceneMode.Additive);
		}

		public void AddSceneAsync(SceneDefine sceneId, OnCompleteScene onLoaded)
		{
			AddSceneAsync((int)sceneId, onLoaded);
		}

		public void AddSceneAsync(int sceneId, OnCompleteScene onLoaded)
		{
			Observable.FromCoroutine((IObserver<Scene> ob) => CoroutineAddScene(ob, sceneId)).Subscribe(delegate(Scene scene)
			{
				onLoaded(scene);
			});
		}

		public IObservable<Scene> AddSceneAsyncAsObservable(SceneDefine sceneId)
		{
			return AddSceneAsyncAsObservable((int)sceneId);
		}

		public IObservable<Scene> AddSceneAsyncAsObservable(int sceneId)
		{
			return Observable.FromCoroutine((IObserver<Scene> ob) => CoroutineAddScene(ob, sceneId));
		}

		private IEnumerator CoroutineAddScene(IObserver<Scene> ob, int sceneId)
		{
			if (_loadReservedScenes.ContainsKey(sceneId))
			{
				yield return _loadReservedScenes[sceneId];
			}
			else
			{
				yield return SceneManager.LoadSceneAsync(sceneId, LoadSceneMode.Additive);
			}
			Scene sceneByBuildIndex = SceneManager.GetSceneByBuildIndex(sceneId);
			ob.OnNext(sceneByBuildIndex);
			ob.OnCompleted();
		}

		public void UnloadSceneAsync(SceneDefine sceneId, OnComplete onUnloaded)
		{
			UnloadSceneAsync((int)sceneId, onUnloaded);
		}

		public void UnloadSceneAsync(int sceneId, OnComplete onUnloaded)
		{
			Observable.FromCoroutine((CancellationToken _) => CoroutineUnloadScene(sceneId)).Subscribe(delegate
			{
				if (onUnloaded != null)
				{
					onUnloaded();
				}
			});
		}

		public IObservable<Unit> UnloadSceneAsyncAsObservable(int sceneId, OnComplete onUnloaded)
		{
			return Observable.FromCoroutine((CancellationToken _) => CoroutineUnloadScene(sceneId));
		}

		private IEnumerator CoroutineUnloadScene(int sceneId)
		{
			yield return SceneManager.UnloadSceneAsync(sceneId);
		}

		public void ReserveSceneFromList(List<int> sceneList)
		{
			if (sceneList == null || sceneList.Count <= 0)
			{
				return;
			}
			foreach (int scene in sceneList)
			{
				ReserveScene(scene);
			}
		}

		public void ReserveScene(SceneDefine sceneId)
		{
			ReserveScene((int)sceneId);
		}

		private void ReserveScene(int sceneId)
		{
			if (!SceneManager.GetSceneByBuildIndex(sceneId).IsValid() && !_loadReservedScenes.ContainsKey(sceneId))
			{
				AsyncOperation asyncOperation = SceneManager.LoadSceneAsync(sceneId, LoadSceneMode.Additive);
				_loadReservedScenes.Add(sceneId, asyncOperation);
				asyncOperation.priority = -128;
				asyncOperation.completed += delegate
				{
				};
			}
		}

		public void DisposeAllReservedScene()
		{
			foreach (KeyValuePair<int, AsyncOperation> loadReservedScene in _loadReservedScenes)
			{
				UnloadSceneAsync(loadReservedScene.Key, null);
			}
			_loadReservedScenes.Clear();
		}

		public bool IsSceneReservedAndLoading(SceneDefine sceneId)
		{
			return IsSceneReservedAndLoading((int)sceneId);
		}

		public bool IsSceneReservedAndLoading(int sceneId)
		{
			if (_loadReservedScenes.ContainsKey(sceneId))
			{
				return !_loadReservedScenes[sceneId].isDone;
			}
			return false;
		}

		public SceneDefine GetSceneIdByScene(Scene scene)
		{
			return (SceneDefine)scene.buildIndex;
		}
	}
	public abstract class BaseVRPlatform : MonoBehaviour
	{
		public virtual bool IsMovileDevice => false;

		public virtual bool IsTouchpadAvailable => false;

		public virtual bool UseTrackedHands => false;

		public virtual bool IsAvailableRecenter => true;

		public virtual int AntiAiliasRate => 8;

		public virtual float EyeTextureScale => 1.25f;

		public virtual float TargetFPS => 90f;

		public virtual float PitchControllerOffset => 0f;

		public virtual VRDeviceDefine.HandType AvailableHand => VRDeviceDefine.HandType.None;

		public virtual VRDeviceDefine.DeviceType CurrentDeviceType => VRDeviceDefine.DeviceType.Unsupported;

		public virtual bool IsRecenteredController => false;

		public virtual void OnInitialize()
		{
			throw new NotImplementedVRPlatformException();
		}

		public virtual bool IsHandTracked(VRDeviceDefine.HandType hand)
		{
			return false;
		}

		public virtual Vector3 GetHandPosition(VRDeviceDefine.HandType hand)
		{
			return Vector3.zero;
		}

		public virtual Quaternion GetHandRotation(VRDeviceDefine.HandType hand)
		{
			return Quaternion.identity;
		}

		public virtual bool GetVRButton(VRDeviceDefine.HandType hand, VRDeviceDefine.Buttons button)
		{
			return false;
		}

		public virtual bool GetVRButtonDown(VRDeviceDefine.HandType hand, VRDeviceDefine.Buttons button)
		{
			return false;
		}

		public virtual bool GetVRButtonUp(VRDeviceDefine.HandType hand, VRDeviceDefine.Buttons button)
		{
			return false;
		}

		public virtual bool GetAxisPadStartTouch(VRDeviceDefine.HandType hand)
		{
			return false;
		}

		public virtual bool GetAxisPadTouching(VRDeviceDefine.HandType hand)
		{
			return false;
		}

		public virtual Vector2 GetAxisPad2D(VRDeviceDefine.HandType hand)
		{
			return Vector2.zero;
		}

		public virtual Vector2 GetAxisStick2D(VRDeviceDefine.HandType hand)
		{
			return Vector2.zero;
		}

		public virtual void Vibrate(VRDeviceDefine.HandType hand, float length, float power)
		{
		}

		public virtual bool IsLanguageProhibited(GameDefine.Languages lang)
		{
			return false;
		}

		public virtual void OnBackFromRoot()
		{
		}

		public virtual void OnStartBusy()
		{
		}

		public virtual void OnEndBusy()
		{
		}

		public virtual void UnlockAchievement(AchievementDefine.Keys key)
		{
		}

		public virtual void ClearAllAchievements()
		{
		}

		public virtual void Recenter()
		{
			InputTracking.Recenter();
		}

		public virtual void StartApplicationPlatformValidate(Action<bool> OnEndValidate)
		{
			OnEndValidate(obj: true);
		}
	}
	public class HandObject : MonoBehaviour
	{
		[SerializeField]
		private GameObject _handModel;

		private bool _isTracked;

		private bool _isMainHand;

		private bool _isControllerVisible;

		private bool _isLaserVisible = true;

		private Transform _thisTransform;

		private LaserController _laser;

		private VRDeviceDefine.HandType _handType;

		public Transform ThisTransform => _thisTransform;

		public float CurrentLaserLength => _laser.CurrentLength;

		private VRDeviceDefine.HandType HandType => _handType;

		private void Awake()
		{
			_thisTransform = base.transform;
			_laser = GetComponent<LaserController>();
			_laser.InputTriggerDown = GetTriggerDown;
			_laser.InputTriggerUp = GetTriggerUp;
			_laser.InputVibrate = Vibrate;
			_handType = ((_laser.GetHandType() != 0) ? VRDeviceDefine.HandType.Right : VRDeviceDefine.HandType.Left);
		}

		private void Start()
		{
			if (HandType == VRDeviceDefine.HandType.Left)
			{
				SingletonMonoBehaviour<GameInputManager>.Instance.OnToggleTrackedLeft.Subscribe(delegate(bool tracked)
				{
					ToggleTracked(tracked);
				}).AddTo(base.gameObject);
			}
			else if (HandType == VRDeviceDefine.HandType.Right)
			{
				SingletonMonoBehaviour<GameInputManager>.Instance.OnToggleTrackedRight.Subscribe(delegate(bool tracked)
				{
					ToggleTracked(tracked);
				}).AddTo(base.gameObject);
			}
			SingletonMonoBehaviour<GameInputManager>.Instance.OnChangeMainHand.DelayFrame(1).Subscribe(delegate(VRDeviceDefine.HandType type)
			{
				if (type == HandType)
				{
					_isMainHand = true;
					Vibrate(0.1f, 0.5f);
					UpdateLaserEnable();
				}
				else
				{
					_isMainHand = false;
					UpdateLaserEnable();
				}
			}).AddTo(base.gameObject);
		}

		private void UpdateLaserEnable()
		{
			_laser.enabled = _isTracked && _isMainHand;
		}

		private void ToggleTracked(bool flag)
		{
			_isTracked = flag;
			UpdateLaserEnable();
			UpdateVisibleController();
		}

		public void ToggleVisible(bool flag)
		{
			_isControllerVisible = flag;
			UpdateLaserEnable();
			UpdateVisibleController();
		}

		public void ToggleLaserVisible(bool flag)
		{
			_isLaserVisible = flag;
			_laser.IsVisibleLaser = _isLaserVisible;
		}

		public void ToggleLaserAutoDisappear(bool flag)
		{
			_laser.IsAutoDisappear = flag;
		}

		private void UpdateVisibleController()
		{
			bool active = _isTracked && _isControllerVisible;
			_handModel.SetActive(active);
		}

		private bool GetTriggerDown()
		{
			return SingletonMonoBehaviour<GameInputManager>.Instance.GetVRButtonDown(HandType, VRDeviceDefine.Buttons.MainAction);
		}

		private bool GetTriggerUp()
		{
			return SingletonMonoBehaviour<GameInputManager>.Instance.GetVRButtonUp(HandType, VRDeviceDefine.Buttons.MainAction);
		}

		private Vector2 GetScrollDelta()
		{
			return SingletonMonoBehaviour<GameInputManager>.Instance.GetVRScrollDelta(HandType);
		}

		public void Vibrate(float length, float power)
		{
			SingletonMonoBehaviour<GameInputManager>.Instance.Vibrate(HandType, length, power);
		}
	}
	public class HeadObject : MonoBehaviour
	{
		[SerializeField]
		private Transform _neckAnchor;

		public Transform NeckAnchor => _neckAnchor;
	}
	public class VRPlatformNone : BaseVRPlatform
	{
		public override void StartApplicationPlatformValidate(Action<bool> OnEndValidate)
		{
			UnityEngine.Debug.LogError("Non-VR Mode not supported.");
			OnEndValidate(obj: false);
		}
	}
	public class VRPlatformOculus : BaseVRPlatform
	{
		private const float VIBRATION_MIN_VALUE = 40f;

		private const float VIBRATION_MAX_VALUE = 255f;

		private const float VIBRATION_BYTE_PER_SECOND = 320f;

		private const int GO_MAX_CPU_LEVEL = 4;

		private const int GO_MIN_CPU_LEVEL = 2;

		private bool recenterEmitted;

		private VRDeviceDefine.DeviceType _currentDeviceType;

		public override bool IsMovileDevice => isOculusGo;

		public override bool IsTouchpadAvailable => isOculusGo;

		public override bool UseTrackedHands => isOculusQuest;

		public override bool IsAvailableRecenter => false;

		public override bool IsRecenteredController => recenterEmitted;

		public override int AntiAiliasRate
		{
			get
			{
				if (!isOculusGo)
				{
					return 8;
				}
				return 4;
			}
		}

		public override float EyeTextureScale => 1.25f;

		public override float TargetFPS
		{
			get
			{
				if (!isOculusGo)
				{
					return 90f;
				}
				return 60f;
			}
		}

		public override float PitchControllerOffset => 0f;

		public override VRDeviceDefine.HandType AvailableHand
		{
			get
			{
				if (IsMovileDevice)
				{
					return VRDeviceDefine.HandType.None;
				}
				return VRDeviceDefine.HandType.Both;
			}
		}

		public override VRDeviceDefine.DeviceType CurrentDeviceType => _currentDeviceType;

		private bool isOculusGo => _currentDeviceType == VRDeviceDefine.DeviceType.OculusGo;

		private bool isOculusQuest => _currentDeviceType == VRDeviceDefine.DeviceType.OculusQuest;

		public override void OnInitialize()
		{
			OVRPlugin.SystemHeadset systemHeadsetType = OVRPlugin.GetSystemHeadsetType();
			if ((uint)(systemHeadsetType - 8) <= 1u)
			{
				_currentDeviceType = VRDeviceDefine.DeviceType.OculusQuest;
			}
			else
			{
				_currentDeviceType = VRDeviceDefine.DeviceType.OculusRift;
			}
			if (isOculusGo)
			{
				InitWithGo();
			}
			else
			{
				MakeSubscribePositionReset();
			}
			OVRManager.display.displayFrequency = TargetFPS;
		}

		private void MakeSubscribePositionReset()
		{
			(from _ in this.UpdateAsObservable()
				where IsTouchRecenterDown()
				select _).Subscribe(delegate
			{
				StartCoroutine(CoroutineEmitRecenter());
			}).AddTo(base.gameObject);
		}

		private void InitWithGo()
		{
			OVRManager.tiledMultiResLevel = OVRManager.TiledMultiResLevel.LMSHigh;
		}

		private bool IsTouchRecenterPushing()
		{
			if (!OVRInput.Get(OVRInput.Button.PrimaryHandTrigger))
			{
				return OVRInput.Get(OVRInput.Button.SecondaryHandTrigger);
			}
			return true;
		}

		private bool IsTouchRecenterDown()
		{
			if (!OVRInput.GetDown(OVRInput.Button.PrimaryHandTrigger))
			{
				return OVRInput.GetDown(OVRInput.Button.SecondaryHandTrigger);
			}
			return true;
		}

		private IEnumerator CoroutineEmitRecenter()
		{
			for (float emitTime = 0f; emitTime <= 0.5f; emitTime += Time.deltaTime)
			{
				if (!IsTouchRecenterPushing())
				{
					yield break;
				}
				yield return new WaitForEndOfFrame();
			}
			recenterEmitted = true;
			yield return new WaitForEndOfFrame();
			recenterEmitted = false;
		}

		public override bool IsHandTracked(VRDeviceDefine.HandType hand)
		{
			OVRInput.Controller controllerType = ((hand == VRDeviceDefine.HandType.Left) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
			return OVRInput.GetControllerPositionTracked(controllerType);
		}

		public override Vector3 GetHandPosition(VRDeviceDefine.HandType hand)
		{
			OVRInput.Controller controllerType = ((hand == VRDeviceDefine.HandType.Left) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
			return OVRInput.GetLocalControllerPosition(controllerType);
		}

		public override Quaternion GetHandRotation(VRDeviceDefine.HandType hand)
		{
			OVRInput.Controller controllerType = ((hand == VRDeviceDefine.HandType.Left) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
			return OVRInput.GetLocalControllerRotation(controllerType);
		}

		public override bool GetVRButton(VRDeviceDefine.HandType hand, VRDeviceDefine.Buttons button)
		{
			if (IsMovileDevice)
			{
				return OVRInput.Get(DefineToOVRButton(button));
			}
			if (hand == VRDeviceDefine.HandType.Both)
			{
				if (IsNeedBothRaw(button))
				{
					if (!GetVRButton(VRDeviceDefine.HandType.Left, button))
					{
						return GetVRButton(VRDeviceDefine.HandType.Right, button);
					}
					return true;
				}
				return OVRInput.Get(DefineToOVRButton(button));
			}
			return OVRInput.Get(DefineToOVRRawButton(hand, button));
		}

		public override bool GetVRButtonDown(VRDeviceDefine.HandType hand, VRDeviceDefine.Buttons button)
		{
			if (IsMovileDevice)
			{
				return OVRInput.GetDown(DefineToOVRButton(button));
			}
			if (hand == VRDeviceDefine.HandType.Both)
			{
				if (IsNeedBothRaw(button))
				{
					if (!GetVRButtonDown(VRDeviceDefine.HandType.Left, button))
					{
						return GetVRButtonDown(VRDeviceDefine.HandType.Right, button);
					}
					return true;
				}
				return OVRInput.GetDown(DefineToOVRButton(button));
			}
			return OVRInput.GetDown(DefineToOVRRawButton(hand, button));
		}

		public override bool GetVRButtonUp(VRDeviceDefine.HandType hand, VRDeviceDefine.Buttons button)
		{
			if (IsMovileDevice)
			{
				return OVRInput.GetUp(DefineToOVRButton(button));
			}
			if (hand == VRDeviceDefine.HandType.Both)
			{
				if (IsNeedBothRaw(button))
				{
					if (!GetVRButtonUp(VRDeviceDefine.HandType.Left, button))
					{
						return GetVRButtonUp(VRDeviceDefine.HandType.Right, button);
					}
					return true;
				}
				return OVRInput.GetUp(DefineToOVRButton(button));
			}
			return OVRInput.GetUp(DefineToOVRRawButton(hand, button));
		}

		private OVRInput.Button DefineToOVRButton(VRDeviceDefine.Buttons button)
		{
			if (isOculusGo)
			{
				switch (button)
				{
				case VRDeviceDefine.Buttons.DeviceBack:
					return OVRInput.Button.Back;
				case VRDeviceDefine.Buttons.Cancel:
					return OVRInput.Button.One;
				case VRDeviceDefine.Buttons.MainAction:
					return OVRInput.Button.PrimaryIndexTrigger;
				case VRDeviceDefine.Buttons.Up:
					return OVRInput.Button.Down;
				case VRDeviceDefine.Buttons.Down:
					return OVRInput.Button.Up;
				case VRDeviceDefine.Buttons.Left:
					return OVRInput.Button.Right;
				case VRDeviceDefine.Buttons.Right:
					return OVRInput.Button.Left;
				}
			}
			else
			{
				switch (button)
				{
				case VRDeviceDefine.Buttons.DeviceBack:
					return OVRInput.Button.Back;
				case VRDeviceDefine.Buttons.Cancel:
					return OVRInput.Button.Two | OVRInput.Button.Start;
				case VRDeviceDefine.Buttons.MainAction:
					return OVRInput.Button.One | OVRInput.Button.PrimaryIndexTrigger;
				case VRDeviceDefine.Buttons.PositionReset:
					return OVRInput.Button.PrimaryHandTrigger;
				case VRDeviceDefine.Buttons.RemoveInterface:
					return OVRInput.Button.PrimaryThumbstick;
				case VRDeviceDefine.Buttons.Up:
					return OVRInput.Button.Up;
				case VRDeviceDefine.Buttons.Down:
					return OVRInput.Button.Down;
				case VRDeviceDefine.Buttons.Left:
					return OVRInput.Button.Left;
				case VRDeviceDefine.Buttons.Right:
					return OVRInput.Button.Right;
				}
			}
			return OVRInput.Button.None;
		}

		private OVRInput.RawButton DefineToOVRRawButton(VRDeviceDefine.HandType hand, VRDeviceDefine.Buttons button)
		{
			switch (hand)
			{
			case VRDeviceDefine.HandType.Left:
				switch (button)
				{
				case VRDeviceDefine.Buttons.Cancel:
					return OVRInput.RawButton.Y | OVRInput.RawButton.Start;
				case VRDeviceDefine.Buttons.MainAction:
					return OVRInput.RawButton.X | OVRInput.RawButton.LIndexTrigger;
				case VRDeviceDefine.Buttons.PositionReset:
					if (!isOculusQuest)
					{
						return OVRInput.RawButton.LHandTrigger;
					}
					return OVRInput.RawButton.None;
				case VRDeviceDefine.Buttons.RemoveInterface:
					return OVRInput.RawButton.LThumbstick;
				case VRDeviceDefine.Buttons.Up:
					return OVRInput.RawButton.LThumbstickUp;
				case VRDeviceDefine.Buttons.Down:
					return OVRInput.RawButton.LThumbstickDown;
				case VRDeviceDefine.Buttons.Left:
					return OVRInput.RawButton.LThumbstickLeft;
				case VRDeviceDefine.Buttons.Right:
					return OVRInput.RawButton.LThumbstickRight;
				}
				break;
			case VRDeviceDefine.HandType.Right:
				switch (button)
				{
				case VRDeviceDefine.Buttons.Cancel:
					return OVRInput.RawButton.B;
				case VRDeviceDefine.Buttons.MainAction:
					return OVRInput.RawButton.A | OVRInput.RawButton.RIndexTrigger;
				case VRDeviceDefine.Buttons.PositionReset:
					if (!isOculusQuest)
					{
						return OVRInput.RawButton.RHandTrigger;
					}
					return OVRInput.RawButton.None;
				case VRDeviceDefine.Buttons.RemoveInterface:
					return OVRInput.RawButton.RThumbstick;
				case VRDeviceDefine.Buttons.Up:
					return OVRInput.RawButton.RThumbstickUp;
				case VRDeviceDefine.Buttons.Down:
					return OVRInput.RawButton.RThumbstickDown;
				case VRDeviceDefine.Buttons.Left:
					return OVRInput.RawButton.RThumbstickLeft;
				case VRDeviceDefine.Buttons.Right:
					return OVRInput.RawButton.RThumbstickRight;
				}
				break;
			}
			return OVRInput.RawButton.None;
		}

		private bool IsNeedBothRaw(VRDeviceDefine.Buttons button)
		{
			if (IsMovileDevice)
			{
				return false;
			}
			if ((uint)(button - 3) <= 3u || (uint)(button - 8) <= 3u)
			{
				return true;
			}
			return false;
		}

		public override bool GetAxisPadStartTouch(VRDeviceDefine.HandType hand)
		{
			if (isOculusGo)
			{
				return OVRInput.GetDown(OVRInput.Touch.PrimaryTouchpad);
			}
			return false;
		}

		public override bool GetAxisPadTouching(VRDeviceDefine.HandType hand)
		{
			if (isOculusGo)
			{
				return OVRInput.Get(OVRInput.Touch.PrimaryTouchpad);
			}
			return false;
		}

		public override Vector2 GetAxisPad2D(VRDeviceDefine.HandType hand)
		{
			if (isOculusGo)
			{
				return OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad);
			}
			return Vector2.zero;
		}

		public override Vector2 GetAxisStick2D(VRDeviceDefine.HandType hand)
		{
			if (isOculusGo)
			{
				return Vector2.zero;
			}
			return hand switch
			{
				VRDeviceDefine.HandType.Left => OVRInput.Get(OVRInput.RawAxis2D.LThumbstick), 
				VRDeviceDefine.HandType.Right => OVRInput.Get(OVRInput.RawAxis2D.RThumbstick), 
				_ => OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick), 
			};
		}

		public override void Vibrate(VRDeviceDefine.HandType hand, float length, float power)
		{
			if (!IsMovileDevice && !(length <= 0f) && OVRHaptics.Config.SampleSizeInBytes != 0)
			{
				int num = Mathf.FloorToInt(320f * length);
				byte b = (byte)Mathf.Lerp(40f, 255f, power);
				byte[] array = new byte[num];
				for (int i = 0; i < num; i++)
				{
					array[i] = b;
				}
				OVRHapticsClip clip = new OVRHapticsClip(array, array.Length);
				switch (hand)
				{
				case VRDeviceDefine.HandType.Left:
					OVRHaptics.LeftChannel.Mix(clip);
					break;
				case VRDeviceDefine.HandType.Right:
					OVRHaptics.RightChannel.Mix(clip);
					break;
				default:
					OVRHaptics.LeftChannel.Mix(clip);
					OVRHaptics.RightChannel.Mix(clip);
					break;
				}
			}
		}

		public override bool IsLanguageProhibited(GameDefine.Languages lang)
		{
			if (lang == GameDefine.Languages.Chinese)
			{
				return true;
			}
			return false;
		}

		public override void OnBackFromRoot()
		{
			if (IsMovileDevice)
			{
				OVRManager.PlatformUIConfirmQuit();
			}
		}

		public override void OnStartBusy()
		{
			OVRManager.cpuLevel = 4;
		}

		public override void OnEndBusy()
		{
			OVRManager.cpuLevel = 2;
		}

		public override void Recenter()
		{
			OVRManager.display.RecenterPose();
		}

		public override void StartApplicationPlatformValidate(Action<bool> OnEndValidate)
		{
			try
			{
				Core.AsyncInitialize();
				Entitlements.IsUserEntitledToApplication().OnComplete(delegate(Oculus.Platform.Message msg)
				{
					if (msg.IsError)
					{
						UnityEngine.Debug.LogError("OVRPlatform: You are NOT entitled to use this app.");
						OnEndValidate(obj: false);
					}
					else
					{
						UnityEngine.Debug.Log("OVRPlatform: You are entitled to use this app.");
						OnEndValidate(obj: true);
					}
				});
			}
			catch (UnityException exception)
			{
				UnityEngine.Debug.LogError("OVRPlatform: Platform failed to initialize due to exception.");
				UnityEngine.Debug.LogException(exception);
				OnEndValidate(obj: false);
			}
		}
	}
	public class VRPlatformOpenVR : BaseVRPlatform
	{
	}
	public class VRPlatformPlaystation : BaseVRPlatform
	{
	}
	public class NotImplementedVRPlatformException : Exception
	{
		public NotImplementedVRPlatformException()
		{
		}

		public NotImplementedVRPlatformException(string message)
			: base(message)
		{
		}
	}
	public class FailedVRPlatformInitializationException : Exception
	{
		public FailedVRPlatformInitializationException()
		{
		}

		public FailedVRPlatformInitializationException(string message)
			: base(message)
		{
		}
	}
	public class PlayAreaManager : SingletonMonoBehaviour<PlayAreaManager>
	{
		public enum LayerModes
		{
			Normal,
			BokeSphere,
			InFade,
			Minimum,
			Nothing,
			MAX
		}

		[Header("Prefabs - Platform Components")]
		[SerializeField]
		[EnumLabel(typeof(VRDeviceDefine.PlatformType))]
		private BaseVRPlatform[] _prefabPlatforms;

		[Header("Components - VR Component")]
		[SerializeField]
		private TrackingObjectComponents userTrackComponent;

		[Header("Parameters")]
		[SerializeField]
		private float _cameraFarClip = 2000f;

		[SerializeField]
		[EnumLabel(typeof(LayerModes))]
		private LayerMask[] _layerSettings = new LayerMask[5];

		private Transform _initialParent;

		private TrackingObjectComponents _currentComponent;

		private HeadObject _headObject;

		private HandObject _leftHandObject;

		private HandObject _rightHandObject;

		private PlayAreaMover _mover;

		private LayerModes _currentLayerMode;

		private HashSet<object>[] _changeLayerRequestLists = new HashSet<object>[5];

		private HashSet<object> _needLaserList;

		public Transform MyTransform { get; private set; }

		public VRDeviceDefine.PlatformType LoadedVR { get; private set; }

		public VRDeviceDefine.DeviceType CurrentDeviceType => InputVR.CurrentDeviceType;

		public bool IsVRLoaded
		{
			get
			{
				VRDeviceDefine.PlatformType loadedVR = LoadedVR;
				if ((uint)loadedVR <= 1u)
				{
					return false;
				}
				return true;
			}
		}

		public bool IsSucceedInitialize { get; set; }

		public BaseVRPlatform InputVR { get; private set; }

		public Transform CameraAnchorTransform => _mover.Anchor;

		public Transform VRAreaTransform => _currentComponent.transform;

		public Transform HeadTransform => _currentComponent.headComponent;

		public HeadObject HeadObject
		{
			get
			{
				if (_headObject != null)
				{
					return _headObject;
				}
				_headObject = userTrackComponent.headComponent.GetComponent<HeadObject>();
				return _headObject;
			}
		}

		public HandObject LeftHandObject
		{
			get
			{
				if (_leftHandObject != null)
				{
					return _leftHandObject;
				}
				_leftHandObject = userTrackComponent.leftHandComponent.GetComponent<HandObject>();
				return _leftHandObject;
			}
		}

		public HandObject RightHandObject
		{
			get
			{
				if (_rightHandObject != null)
				{
					return _rightHandObject;
				}
				_rightHandObject = userTrackComponent.rightHandComponent.GetComponent<HandObject>();
				return _rightHandObject;
			}
		}

		public Camera EyeCamera => _currentComponent.eyeCameraComponent;

		public IReadOnlyReactiveProperty<bool> IsOutOfBoundary => _mover.IsOutOfBoundary;

		public float BoundaryRange
		{
			get
			{
				return _mover.BoundaryRange;
			}
			set
			{
				_mover.BoundaryRange = value;
			}
		}

		protected override void InitializeOnAwake()
		{
			MyTransform = base.transform;
			_initialParent = MyTransform.parent;
			_mover = GetComponent<PlayAreaMover>();
			MakeList();
			ActivateVRDevice();
		}

		private void MakeList()
		{
			_needLaserList = new HashSet<object>();
			int num = _changeLayerRequestLists.Length;
			for (int i = 0; i < num; i++)
			{
				_changeLayerRequestLists[i] = new HashSet<object>();
			}
		}

		private void ActivateVRDevice()
		{
			SetLoadedVRFromString();
			if (!IsVRLoaded)
			{
				UnityEngine.Debug.LogError("No VR Loaded!");
				return;
			}
			try
			{
				BaseVRPlatform original = _prefabPlatforms[(int)LoadedVR];
				InputVR = UnityEngine.Object.Instantiate(original, base.transform, worldPositionStays: false);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogErrorFormat("VR Platform '<b>{0}</b>' Instantiating Error.", LoadedVR);
				UnityEngine.Debug.LogException(exception);
				throw;
			}
			if (InputVR == null)
			{
				UnityEngine.Debug.LogErrorFormat("Component for VR Platform '<b>{0}</b>' is missing.", LoadedVR);
				return;
			}
			try
			{
				InputVR.OnInitialize();
			}
			catch (NotImplementedVRPlatformException ex)
			{
				UnityEngine.Debug.LogErrorFormat("VR Platform '<b>{0}</b>' is not implemented.\n{1}", LoadedVR, ex.StackTrace);
				throw;
			}
			catch (Exception ex2)
			{
				UnityEngine.Debug.LogErrorFormat("VR Platform '<b>{0}</b>'  Initialization Error by {1}\n{2}", LoadedVR, ex2.GetType().ToString(), ex2.StackTrace);
				throw;
			}
			AttachTrackingObjects();
			InitMover();
			InitMisc();
			IsSucceedInitialize = true;
		}

		private void SetLoadedVRFromString()
		{
			if (!XRSettings.enabled)
			{
				LoadedVR = VRDeviceDefine.PlatformType.Disabled;
				return;
			}
			VRDeviceDefine.PlatformType loadedVR = VRDeviceDefine.PlatformType.Unsupported;
			string loadedDeviceName = XRSettings.loadedDeviceName;
			if (loadedDeviceName == "Oculus")
			{
				loadedVR = VRDeviceDefine.PlatformType.Oculus;
			}
			else if (loadedDeviceName == "OpenVR")
			{
				loadedVR = VRDeviceDefine.PlatformType.OpenVR;
			}
			LoadedVR = loadedVR;
		}

		private void AttachTrackingObjects()
		{
			TrackingObjectComponents component = InputVR.GetComponent<TrackingObjectComponents>();
			if (!(component == null))
			{
				_currentComponent = component;
				userTrackComponent.headComponent.SetParent(component.headComponent, worldPositionStays: false);
				userTrackComponent.leftHandComponent.SetParent(component.leftHandComponent, worldPositionStays: false);
				userTrackComponent.leftHandComponent.Rotate(InputVR.PitchControllerOffset, 0f, 0f);
				userTrackComponent.rightHandComponent.SetParent(component.rightHandComponent, worldPositionStays: false);
				userTrackComponent.rightHandComponent.Rotate(InputVR.PitchControllerOffset, 0f, 0f);
			}
		}

		private void InitMover()
		{
			_mover.InitTransforms(VRAreaTransform, _currentComponent.eyeCameraComponent.transform);
		}

		private void InitMisc()
		{
			QualitySettings.antiAliasing = InputVR.AntiAiliasRate;
			XRSettings.eyeTextureResolutionScale = InputVR.EyeTextureScale;
			EyeCamera.farClipPlane = _cameraFarClip;
		}

		private void Start()
		{
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.OnToggleBusyProcess.Subscribe(delegate(bool busy)
			{
				if (busy)
				{
					InputVR.OnStartBusy();
					RequestLayerMode(this, LayerModes.Minimum);
				}
				else
				{
					InputVR.OnEndBusy();
					DisposeLayerMode(this, LayerModes.Minimum);
				}
				ToggleLaserVisible(!busy);
			}).AddTo(this);
			(from key in SingletonMonoBehaviour<GameData>.Instance.FlagActivatedObservable.FlagToKeys()
				where key != AchievementDefine.Keys.NULL
				select key).Subscribe(delegate(AchievementDefine.Keys key)
			{
				InputVR.UnlockAchievement(key);
			}).AddTo(this);
		}

		public void SetClearColor(Color color)
		{
			_currentComponent.eyeCameraComponent.backgroundColor = color;
		}

		public void ToggleLaserVisible(bool flag)
		{
			LeftHandObject.ToggleLaserVisible(flag);
			RightHandObject.ToggleLaserVisible(flag);
		}

		public void AddLaserNeed(object comp)
		{
			if (!_needLaserList.Contains(comp) && _needLaserList.Add(comp))
			{
				LeftHandObject.ToggleLaserAutoDisappear(flag: false);
				RightHandObject.ToggleLaserAutoDisappear(flag: false);
			}
		}

		public void RemoveLaserNeed(object comp)
		{
			if (_needLaserList.Remove(comp))
			{
				bool flag = _needLaserList.Count == 0;
				LeftHandObject.ToggleLaserAutoDisappear(flag);
				RightHandObject.ToggleLaserAutoDisappear(flag);
			}
		}

		public void BackToInitialParent()
		{
			MyTransform.SetParent(_initialParent);
		}

		private void SetLayerMode(LayerModes mode)
		{
			_currentLayerMode = mode;
			_currentComponent.eyeCameraComponent.cullingMask = _layerSettings[(int)mode];
		}

		public void RequestLayerMode(object comp, LayerModes mode)
		{
			if (_changeLayerRequestLists[(int)mode].Add(comp) && _currentLayerMode < mode)
			{
				_currentLayerMode = mode;
				SetLayerMode(_currentLayerMode);
			}
		}

		public void DisposeLayerMode(object comp, LayerModes mode)
		{
			if (_changeLayerRequestLists[(int)mode].Remove(comp) && _currentLayerMode <= mode)
			{
				while (_currentLayerMode != 0 && _changeLayerRequestLists[(int)_currentLayerMode].Count <= 0)
				{
					_currentLayerMode--;
				}
				SetLayerMode(_currentLayerMode);
			}
		}

		public void ResetBoundaryRange()
		{
			_mover.ResetBoundaryRange();
		}

		public void CheckLanguage()
		{
			if (IsLanguageProhibited(SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value))
			{
				SingletonMonoBehaviour<GameData>.Instance.ConfigData.ResetLanguageToSafe();
			}
		}

		public bool IsLanguageProhibited(GameDefine.Languages lang)
		{
			return InputVR.IsLanguageProhibited(lang);
		}

		public void UnlockAchievement(AchievementDefine.Keys key)
		{
			InputVR.UnlockAchievement(key);
		}

		public void ClearAllAchievements()
		{
		}

		public void StartApplicationPlatformValidate(Action<bool> OnEndValidate)
		{
			InputVR.StartApplicationPlatformValidate(OnEndValidate);
		}
	}
	public class PlayAreaMover : UpdateableComponent
	{
		[Header("Components")]
		[SerializeField]
		private Transform _anchorTransform;

		[SerializeField]
		private PlayAreaWarnObject _warnObject;

		[Header("Parameters - Main Switch")]
		[SerializeField]
		private bool _useSmmothFetch = true;

		[SerializeField]
		private bool _usePositionWarning = true;

		[Header("Parameters - Smooth Centering")]
		[SerializeField]
		private Vector3 _positionTarget = Vector3.zero;

		[SerializeField]
		private float _closeDistance = 0.2f;

		[SerializeField]
		private float _trackSpeed = 0.5f;

		[SerializeField]
		private float _trackBrake = 2.5f;

		[SerializeField]
		private float _trackPercent = 0.001f;

		[Header("Parameters - Position Warning")]
		[SerializeField]
		private float _defaultRange = 0.15f;

		[SerializeField]
		private bool _forceResentering = true;

		[SerializeField]
		private float _recenterTimeout = 20f;

		[SerializeField]
		private Color _warnFadeColor;

		private float _boundaryRange;

		private Vector2 _flattedPosition;

		private Vector3 _moveVelocity;

		private Transform _areaTransform;

		private Transform _cameraTransform;

		private Common.Timer _oobTimer = new Common.Timer(1f);

		private ReactiveProperty<bool> _isOutOfBoundary = new ReactiveProperty<bool>(initialValue: false);

		public Transform Anchor => _anchorTransform;

		public IReadOnlyReactiveProperty<bool> IsOutOfBoundary => _isOutOfBoundary;

		public float BoundaryRange
		{
			get
			{
				return _boundaryRange;
			}
			set
			{
				_boundaryRange = value;
			}
		}

		public void InitTransforms(Transform playarea, Transform camtrans)
		{
			_areaTransform = playarea;
			_cameraTransform = camtrans;
			_boundaryRange = _defaultRange;
		}

		protected override void Initialize()
		{
			SingletonMonoBehaviour<GameInputManager>.Instance.OnPositionReset.Subscribe(delegate
			{
				ResetToRoot();
			}).AddTo(base.gameObject);
			if (!_usePositionWarning)
			{
				return;
			}
			if (!SingletonMonoBehaviour<PlayAreaManager>.Instance.InputVR.IsAvailableRecenter)
			{
				_forceResentering = false;
				_warnObject.IsTimerVisible = false;
			}
			_isOutOfBoundary.Subscribe(delegate(bool flag)
			{
				_warnObject.SetVisible(flag);
				_oobTimer.SetDuration(_recenterTimeout);
				SingletonMonoBehaviour<FadeManager>.Instance.importantFader.SetColour(flag ? _warnFadeColor : ColorDefine.TransparentBlack);
			});
			_isOutOfBoundary.Where((bool flag) => flag).Subscribe(delegate
			{
				SingletonMonoBehaviour<PlayAreaManager>.Instance.RequestLayerMode(this, PlayAreaManager.LayerModes.Minimum);
			});
			_isOutOfBoundary.Where((bool flag) => !flag).Subscribe(delegate
			{
				SingletonMonoBehaviour<PlayAreaManager>.Instance.DisposeLayerMode(this, PlayAreaManager.LayerModes.Minimum);
			});
			base.UpdateObservable.Where((Unit _) => base.IsActive && _isOutOfBoundary.Value && _forceResentering && !_oobTimer.IsTimeUp).Subscribe(delegate
			{
				_oobTimer.Update(Time.deltaTime);
				if (_oobTimer.IsTimeUp)
				{
					SingletonMonoBehaviour<GameInputManager>.Instance.RecenterPosition();
				}
				else
				{
					_warnObject.SetTimeRemainingText(Mathf.CeilToInt(_oobTimer.RemainingTime));
					_warnObject.SetProgressValue(1f - _oobTimer.Rate);
				}
			});
		}

		public override void OnUpdate(float deltaTime)
		{
			if (_useSmmothFetch)
			{
				UpdateSmoothCentering(deltaTime);
			}
			UpdateAnchor();
		}

		private void UpdateAnchor()
		{
			_anchorTransform.localPosition = _cameraTransform.localPosition + _areaTransform.localPosition;
			_flattedPosition = new Vector2(_anchorTransform.localPosition.x, _anchorTransform.localPosition.z);
			_isOutOfBoundary.Value = _flattedPosition.sqrMagnitude > _boundaryRange * _boundaryRange;
		}

		private void UpdateSmoothCentering(float deltaTime)
		{
			Vector3 vector = _positionTarget - (_areaTransform.localPosition + _cameraTransform.localPosition);
			Vector3 zero = Vector3.zero;
			if (vector.sqrMagnitude >= _closeDistance * _closeDistance)
			{
				zero = vector * deltaTime * _trackSpeed;
				_moveVelocity = Vector3.Lerp(_moveVelocity, zero, _trackPercent);
			}
			else
			{
				_moveVelocity = Vector3.Lerp(_moveVelocity, zero, _trackPercent * _trackBrake);
			}
			_areaTransform.localPosition += _moveVelocity;
		}

		private void ResetToRoot()
		{
			_areaTransform.localPosition = Vector3.zero;
			_moveVelocity = Vector3.zero;
		}

		public void ResetBoundaryRange()
		{
			_boundaryRange = _defaultRange;
		}
	}
	public class PlayAreaWarnObject : MonoBehaviour
	{
		[Header("Components - Skin")]
		[SerializeField]
		private TextMeshPro _textTitle;

		[SerializeField]
		private TextMeshPro _textDespriction;

		[SerializeField]
		private ProgressBarSpriteSet _progress;

		[Header("Components - Key")]
		[SerializeField]
		private string _keyTitle = "OutOfAreaTitle";

		[SerializeField]
		private string _keyDesp = "OutOfAreaDesp";

		private Transform _targetFetch;

		private string _despCache = "";

		private int _lastSecond = -1;

		public bool IsTimerVisible { get; set; }

		private void Awake()
		{
			_targetFetch = base.transform;
			IsTimerVisible = true;
			SetVisible(flag: false);
		}

		private void Start()
		{
			SingletonMonoBehaviour<LocalizeManager>.Instance.ChangeLanguageObservable.Subscribe(delegate(GameDefine.Languages lang)
			{
				_textTitle.text = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_keyTitle, lang);
				_despCache = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_keyDesp, lang);
				_lastSecond = -1;
			});
		}

		public void SetVisible(bool flag)
		{
			_textTitle.enabled = flag;
			_textDespriction.enabled = flag;
			_progress.SetVisible(IsTimerVisible && flag);
			if (flag)
			{
				if (!IsTimerVisible)
				{
					_textDespriction.text = _despCache;
				}
				SetPositionToMainCamera();
			}
		}

		public void SetProgressValue(float value)
		{
			_progress.SetValue(value);
		}

		public void SetTimeRemainingText(int remainSecond)
		{
			if (remainSecond != _lastSecond)
			{
				_lastSecond = remainSecond;
				_textDespriction.text = string.Format(_despCache, remainSecond);
			}
		}

		private bool SetPositionToMainCamera()
		{
			Transform headTransform = SingletonMonoBehaviour<PlayAreaManager>.Instance.HeadTransform;
			Vector3 position = headTransform.position;
			Quaternion rotation = headTransform.rotation;
			float num = Mathf.DeltaAngle(90f, Vector3.SignedAngle(Vector3.up, rotation * Vector3.forward, rotation * Vector3.right));
			Quaternion quaternion = rotation * Quaternion.Euler(0f - num, 0f, 0f);
			Quaternion rotation2 = Quaternion.Euler(Mathf.Clamp(num, -25f, 25f), quaternion.eulerAngles.y, 0f);
			_targetFetch.position = position;
			_targetFetch.rotation = rotation2;
			return false;
		}
	}
	public class ProgressBarSpriteSet : MonoBehaviour
	{
		public enum StretchModes
		{
			Horizontal,
			Vertical
		}

		[Header("Components")]
		[SerializeField]
		private SpriteRenderer _backSprite;

		[SerializeField]
		private SpriteRenderer _frontSprite;

		[Header("Parameters")]
		[SerializeField]
		private StretchModes _stretchMode;

		private Vector2 MaxSize => _backSprite.size;

		public void SetVisible(bool flag)
		{
			_backSprite.enabled = flag;
			_frontSprite.enabled = flag;
		}

		public void SetValue(float percentage)
		{
			Vector2 maxSize = MaxSize;
			switch (_stretchMode)
			{
			case StretchModes.Horizontal:
				maxSize.x *= percentage;
				break;
			case StretchModes.Vertical:
				maxSize.y *= percentage;
				break;
			}
			_frontSprite.size = maxSize;
		}
	}
	public class TrackingObjectComponents : MonoBehaviour
	{
		public Camera eyeCameraComponent;

		public Transform headComponent;

		public Transform leftHandComponent;

		public Transform rightHandComponent;
	}
	public class VRSpaceCanvas : MonoBehaviour
	{
		private void Start()
		{
			GetComponent<Canvas>().worldCamera = SingletonMonoBehaviour<PlayAreaManager>.Instance.EyeCamera;
		}
	}
	public static class VrUtility
	{
		private const int _MAX_CPU_LEVEL = 4;

		private const int _MIN_CPU_LEVEL = 2;

		public static void SetToMaxCpuLevel()
		{
			OVRManager.cpuLevel = 4;
		}

		public static void SetToMinCpuLevel()
		{
			OVRManager.cpuLevel = 2;
		}

		public static void OnLoadStart(bool isChangeGraphics = true)
		{
			OVRManager.cpuLevel = 4;
		}

		public static void OnLoadEnd(bool isChangeGraphics = true)
		{
			OVRManager.cpuLevel = 2;
		}
	}
}
namespace Kaine
{
	[Serializable]
	public class AudioLayer : IAudioLayer
	{
		[SerializeField]
		private AudioSource[] m_audioSources;

		private List<AudioClip> m_clips;

		private AudioClip m_introClip;

		private AudioClip m_outroClip;

		private AudioSourceFader[] m_players;

		private int m_indexCurrent;

		private int m_indexNext;

		private bool m_isFadeIntro;

		private bool m_isLoop;

		public AudioSource Current => m_audioSources[m_indexCurrent];

		public AudioSource Next => m_audioSources[m_indexNext];

		public AudioSourceFader CurrentPlayer => m_players[m_indexCurrent];

		public AudioSourceFader NextPlayer => m_players[m_indexNext];

		public bool IsPlaying
		{
			get
			{
				if (!Current.isPlaying)
				{
					return Next.isPlaying;
				}
				return true;
			}
		}

		public bool HasIntro => m_introClip != null;

		public bool HasOutro => m_outroClip != null;

		public AudioLayer()
		{
			m_isLoop = false;
			m_isFadeIntro = false;
			m_clips = new List<AudioClip>();
			m_indexCurrent = 0;
			m_indexNext = 1;
		}

		public void Initialize()
		{
			int num = m_audioSources.Length;
			m_players = new AudioSourceFader[num];
			for (int i = 0; i < num; i++)
			{
				m_players[i] = new AudioSourceFader(m_audioSources[i]);
			}
		}

		public void Clear()
		{
			int num = m_audioSources.Length;
			for (int i = 0; i < num; i++)
			{
				m_audioSources[i].loop = false;
				m_audioSources[i].clip = null;
			}
			m_isFadeIntro = false;
			m_isLoop = false;
			m_clips.Clear();
			m_introClip = null;
			m_outroClip = null;
			m_indexCurrent = 0;
			m_indexNext = 1;
		}

		public void PlayScheduled(double time, int sample = 0)
		{
			Current.timeSamples = sample;
			Current.PlayScheduled(time);
		}

		public void PlayScheduledWithFade(double time, float fadeDuration)
		{
			CurrentPlayer.PlayScheduledWithFade(time, fadeDuration);
		}

		public void PlayNextScheduled(double time, int sample = 0)
		{
			Next.timeSamples = sample;
			Next.PlayScheduled(time);
		}

		public void PlayIntro(int nextClipIndex, double time, float fadeDuration = 1.25f)
		{
			Current.clip = m_introClip;
			if (!m_isLoop)
			{
				SetupNextClip(nextClipIndex);
			}
			if (m_isFadeIntro)
			{
				CurrentPlayer.PlayScheduledWithFade(time, fadeDuration);
			}
			else
			{
				Current.PlayScheduled(time);
			}
		}

		public void Stop()
		{
			if (Current.isPlaying)
			{
				Current.Stop();
			}
			if (Next.isPlaying)
			{
				Next.Stop();
			}
		}

		public void StopWithFade(float duration)
		{
			if (Current.isPlaying)
			{
				CurrentPlayer.StopWithFade(duration);
			}
			if (Next.isPlaying)
			{
				NextPlayer.StopWithFade(duration);
			}
		}

		public void Swap()
		{
			int indexCurrent = m_indexCurrent;
			m_indexCurrent = m_indexNext;
			m_indexNext = indexCurrent;
		}

		public void SetupIntroClips(List<AudioClip> clips)
		{
			m_introClip = null;
			m_isFadeIntro = false;
			if (clips.Count > 0)
			{
				m_introClip = clips[0];
				Current.clip = m_introClip;
			}
			else if (m_clips.Count > 0)
			{
				m_introClip = m_clips[0];
				m_isFadeIntro = true;
				Current.clip = m_introClip;
			}
		}

		public void SetupPartsClips(List<AudioClip> clips)
		{
			m_clips = clips;
		}

		public void SetupOutroClips(List<AudioClip> clips)
		{
			m_outroClip = null;
			if (clips.Count > 0)
			{
				m_outroClip = clips[0];
			}
		}

		public void SetupNextClip(int clipIndex)
		{
			if (clipIndex == -1)
			{
				Next.clip = m_introClip;
			}
			else
			{
				Next.clip = m_clips[clipIndex];
			}
		}

		public void SetNextClipToOutro()
		{
			Next.clip = m_outroClip;
		}

		public void SetTimeSample(int sample)
		{
			Current.timeSamples = sample;
		}

		public void SetVolume(float volume, float fadeDuration = 0.5f)
		{
			if (Current.isPlaying)
			{
				CurrentPlayer.FadeVolume(fadeDuration, volume);
				NextPlayer.FadeVolume(fadeDuration, volume);
			}
			else
			{
				Current.volume = volume;
				Next.volume = volume;
			}
		}

		public void Update(float delta)
		{
			int num = m_players.Length;
			for (int i = 0; i < num; i++)
			{
				m_players[i].Update(delta);
			}
		}

		public void SetLoop(bool isLoop)
		{
			m_isLoop = isLoop;
			Current.loop = isLoop;
			Next.loop = isLoop;
		}
	}
	[CreateAssetMenu(menuName = "Kaine/Create Layer Volume Data", fileName = "AudioLayerVolueme")]
	public class AudioLayerVolumeData : ScriptableObject
	{
		[Serializable]
		public class Data
		{
			[Range(0f, 1f)]
			public float[] Volume;
		}

		public Data[] DataList;
	}
	public class AudioSourceFader
	{
		private AudioSource m_source;

		private Tweener<float> m_volumeFader;

		public bool IsPlaying => m_source.isPlaying;

		public AudioSourceFader(AudioSource source)
		{
			m_source = source;
			m_volumeFader = new Tweener<float>(Mathf.Lerp);
		}

		public void Update(float delta)
		{
			if (m_volumeFader.IsActive)
			{
				m_volumeFader.Update(delta);
				m_source.volume = m_volumeFader.CurrentValue;
			}
		}

		public void Fade(float targetVolume, float duration, Action onFadeEnd = null)
		{
			m_volumeFader.Start(m_source.volume, targetVolume, duration, onFadeEnd);
		}

		public void Fade(float startVolume, float targetVolume, float duration, Action onFadeEnd = null)
		{
			m_volumeFader.Start(startVolume, targetVolume, duration, onFadeEnd);
			m_source.volume = startVolume;
		}

		public void PlayWithFade(float targetVolume, float startVolume = 0f, float fadeDuration = 0.5f, AudioClip clip = null)
		{
			if (clip != null)
			{
				m_source.clip = clip;
			}
			if (m_source.Play(clip))
			{
				if (fadeDuration <= 0f)
				{
					m_source.volume = targetVolume;
				}
				else
				{
					Fade(startVolume, targetVolume, fadeDuration);
				}
			}
		}

		public void PlayScheduledWithFade(double time, float fadeDuration = 0.5f, AudioClip clip = null)
		{
			PlayScheduledWithFade(m_source.volume, time, fadeDuration, clip);
		}

		public void PlayScheduledWithFade(float targetVolume, double time, float fadeDuration = 0.5f, AudioClip clip = null)
		{
			if (clip != null)
			{
				m_source.clip = clip;
			}
			m_source.PlayScheduled(time);
			if (fadeDuration > 0f)
			{
				Fade(0f, targetVolume, fadeDuration);
			}
		}

		public void Stop()
		{
			m_source.Stop();
			m_volumeFader.Dispose();
		}

		public void StopWithFade(float fadeDutation = 0.5f, Action onComplete = null)
		{
			if (!m_source.isPlaying)
			{
				return;
			}
			if (fadeDutation >= 0f)
			{
				Fade(m_source.volume, 0f, fadeDutation, delegate
				{
					m_source.Stop();
					if (onComplete != null)
					{
						onComplete();
					}
				});
			}
			else
			{
				Stop();
			}
		}

		public void SetVolume(float volume)
		{
			m_source.volume = volume;
		}

		public void FadeVolume(float fadeDuration, float targetVolume)
		{
			if (fadeDuration <= 0f)
			{
				m_source.volume = targetVolume;
			}
			else
			{
				Fade(targetVolume, fadeDuration);
			}
		}

		public void FadeVolume(float fadeDuration, float targetVolume, float startVolume)
		{
			if (fadeDuration <= 0f)
			{
				m_source.volume = targetVolume;
			}
			else
			{
				Fade(startVolume, targetVolume, fadeDuration);
			}
		}

		public void SetClip(AudioClip clip)
		{
			m_source.clip = clip;
		}

		public void SetLoop(bool loop)
		{
			m_source.loop = loop;
		}
	}
	[Serializable]
	public class CoreAudioLayer : IAudioLayer
	{
		[SerializeField]
		private Music[] m_musicEngines;

		private List<AudioClip> m_clips;

		private AudioClip m_introClip;

		private AudioClip m_outroClip;

		private int m_indexCurrent;

		private int m_indexNext;

		private bool m_isLoopIntro;

		public Music Current => m_musicEngines[m_indexCurrent];

		public Music Next => m_musicEngines[m_indexNext];

		public int ClipCount => m_clips.Count;

		public bool IsPlaying
		{
			get
			{
				if (!Current.IsPlaying)
				{
					return Next.IsPlaying;
				}
				return true;
			}
		}

		public bool HasIntro => m_introClip != null;

		public bool HasOutro => m_outroClip != null;

		public CoreAudioLayer()
		{
			m_isLoopIntro = false;
			m_clips = new List<AudioClip>();
			m_indexCurrent = 0;
			m_indexNext = 1;
		}

		public void Clear()
		{
			int num = m_musicEngines.Length;
			for (int i = 0; i < num; i++)
			{
				m_musicEngines[i].enabled = true;
				m_musicEngines[i].CurrentSource.clip = null;
				m_musicEngines[i].CurrentSource.loop = false;
			}
			m_clips.Clear();
			m_introClip = null;
			m_outroClip = null;
			m_isLoopIntro = false;
			m_indexCurrent = 0;
			m_indexNext = 1;
		}

		public void SetupSectionSettings(int bpm, int beats, int unitPerBar)
		{
			int num = m_musicEngines.Length;
			for (int i = 0; i < num; i++)
			{
				m_musicEngines[i].CurrentSection.Tempo = bpm;
				m_musicEngines[i].CurrentSection.UnitPerBeat = beats;
				m_musicEngines[i].CurrentSection.UnitPerBar = unitPerBar;
			}
		}

		public void SetupIntroClips(List<AudioClip> clips, int frequency)
		{
			int num = m_musicEngines.Length;
			for (int i = 0; i < num; i++)
			{
				m_musicEngines[i].SampleRate = ((frequency <= 0) ? 44100 : frequency);
			}
			SetupIntroClips(clips);
		}

		public void SetupIntroClips(List<AudioClip> clips)
		{
			m_introClip = null;
			if (clips.Count > 0)
			{
				m_introClip = clips[0];
			}
			else if (m_clips.Count > 0)
			{
				m_introClip = m_clips[0];
			}
		}

		public void SetupPartsClips(List<AudioClip> clips)
		{
			m_clips = clips;
		}

		public void SetupOutroClips(List<AudioClip> clips)
		{
			m_outroClip = null;
			if (clips.Count > 0)
			{
				m_outroClip = clips[0];
			}
		}

		public void PlayScheduled(double time, int sample = 0)
		{
			Current.CurrentSource.timeSamples = sample;
			Current.PlayScheduled(time);
		}

		public void PlayScheduledWithFade(double time, float fadeDuration)
		{
			Current.PlayScheduledWithFade(time, fadeDuration);
		}

		public void PlayNextScheduled(double time, int sample = 0)
		{
			Next.CurrentSource.timeSamples = sample;
			Next.PlayScheduled(time);
		}

		public void PlayIntro(int nextClipIndex, double time, float fadeDuration = 1.25f)
		{
			Current.CurrentSource.clip = m_introClip;
			Current.SetupClips();
			if (m_isLoopIntro)
			{
				Current.PlayScheduledWithFade(time, fadeDuration);
				return;
			}
			SetupNextClip(nextClipIndex);
			Next.SetupClips();
			if (fadeDuration > 0f)
			{
				Current.PlayScheduledWithFade(time, fadeDuration);
			}
			else
			{
				Current.PlayScheduled(time);
			}
		}

		public void Stop()
		{
			StopWithFade(0f);
		}

		public void StopWithFade(float duration)
		{
			if (Current.IsPlaying)
			{
				Current.Player.StopWithFade(duration);
			}
			if (Next.IsPlaying)
			{
				Next.Player.StopWithFade(duration);
			}
		}

		public void Swap()
		{
			int indexCurrent = m_indexCurrent;
			m_indexCurrent = m_indexNext;
			m_indexNext = indexCurrent;
		}

		public void SetupNextClip(int clipIndex)
		{
			if (clipIndex == -1)
			{
				Next.SetupClips(m_introClip);
			}
			else
			{
				Next.SetupClips(m_clips[clipIndex]);
			}
		}

		public void SetNextClipToOutro()
		{
			Next.SetupClips(m_outroClip);
		}

		public void SetVolume(float volume, float fadeDuration = 0.5f)
		{
			if (Current.IsPlaying)
			{
				Current.Player.FadeVolume(fadeDuration, volume);
				Next.Player.FadeVolume(fadeDuration, volume);
			}
			else
			{
				Current.SetVolume(volume);
				Next.SetVolume(volume);
			}
		}

		public void SetTimeSample(int sample)
		{
			Current.CurrentSource.timeSamples = sample;
		}

		public void Update(float delta)
		{
			int num = m_musicEngines.Length;
			for (int i = 0; i < num; i++)
			{
				m_musicEngines[i].UpdateFade(delta);
			}
		}

		public void SetLoop(bool isLoop)
		{
			m_isLoopIntro = isLoop;
			int num = m_musicEngines.Length;
			for (int i = 0; i < num; i++)
			{
				m_musicEngines[i].CurrentSource.loop = isLoop;
			}
		}

		public void SetEngineEnable(bool isEnable)
		{
			int num = m_musicEngines.Length;
			for (int i = 0; i < num; i++)
			{
				m_musicEngines[i].enabled = isEnable;
			}
		}
	}
	public interface IAudioLayer
	{
		bool IsPlaying { get; }

		bool HasIntro { get; }

		bool HasOutro { get; }

		void Clear();

		void PlayIntro(int nextClipIndex, double time, float fadeDuration);

		void PlayScheduled(double time, int sample);

		void PlayScheduledWithFade(double time, float fadeDuration);

		void PlayNextScheduled(double time, int sample);

		void Stop();

		void StopWithFade(float duration);

		void Swap();

		void SetupIntroClips(List<AudioClip> clips);

		void SetupPartsClips(List<AudioClip> clips);

		void SetupOutroClips(List<AudioClip> clips);

		void SetupNextClip(int clipIndex);

		void SetNextClipToOutro();

		void SetVolume(float volume, float fadeDuration);

		void SetTimeSample(int sample);

		void SetLoop(bool isLoop);
	}
	public class KainePlayer : MonoBehaviour
	{
		public enum Indexs
		{
			Main,
			Next
		}

		public enum Layers
		{
			Ambient,
			Base,
			Lead
		}

		public enum States
		{
			Play,
			Stop,
			ReserveOutro,
			WaitPlayOutro,
			PlayingOutro
		}

		private const double _MEASURE_BAR_COUNT = 1.0;

		private const int _INTRO_FADE_BARS = 4;

		public const float _DEFAULT_FADE_DURATION = 1.25f;

		public const int _DEFAULT_FREQUENCY = 44100;

		public const Layers _CORE_LAYER = Layers.Ambient;

		public const int _INTRO_CLIP_INDEX = -1;

		[Header("Components")]
		[SerializeField]
		private CoreAudioLayer m_coreLayer;

		[SerializeField]
		private AudioLayer[] m_layers;

		[SerializeField]
		private AudioLayerVolumeData m_voluemeData;

		[Header("Parts Settings")]
		[SerializeField]
		private int m_changeClipBar = 8;

		[SerializeField]
		private int m_barLength = 9;

		[SerializeField]
		private int m_revurbLenght = 1;

		[SerializeField]
		private bool m_isConnectSameClip;

		[SerializeField]
		[Tooltip("")]
		private int m_reserveProcessBar = 1;

		public Action OnEndPlay;

		private GameObject m_gameObject;

		private int m_scheduleBar;

		private int m_currentClipIndex;

		private int m_nextClipIndex;

		private int m_numLayers;

		private Layers m_nextLayer;

		private bool m_isWaitChangeClip;

		private bool m_isReserveLayerChange;

		private States m_state;

		private bool m_isSingleClipMode;

		private bool m_isSimpleMode;

		private AudioSourceFader m_simpleSource;

		private Action m_onEndSimpleBgmFade;

		public bool IsPlaying
		{
			get
			{
				if (!m_coreLayer.IsPlaying)
				{
					return m_simpleSource.IsPlaying;
				}
				return true;
			}
		}

		public bool IsPlayingParts => m_coreLayer.IsPlaying;

		public double TimePerBar => 60.0 * (double)m_coreLayer.Current.CurrentSection.UnitPerBeat * 1.0 / m_coreLayer.Current.CurrentSection.Tempo;

		public bool IsReserveOutro => m_state == States.ReserveOutro;

		public bool IsWaitOutro => m_state == States.WaitPlayOutro;

		public bool IsPlayingOutro => m_state == States.PlayingOutro;

		public bool IsStopped => m_state == States.Stop;

		public bool IsStopping
		{
			get
			{
				if (!IsStopped && !IsReserveOutro && !IsWaitOutro)
				{
					return IsPlayingOutro;
				}
				return true;
			}
		}

		public bool IsNearConnection => m_coreLayer.Current.Just.Bar >= m_scheduleBar;

		public Layers CurrentLayer { get; private set; }

		public int NumberOfLayers => m_numLayers;

		public int NumberOfAdditionalLayers => m_numLayers - 1;

		private bool IsSinglePartTrack => m_coreLayer.ClipCount == 1;

		private void Start()
		{
			m_isSimpleMode = false;
			m_gameObject = base.gameObject;
			m_isSingleClipMode = false;
			m_state = States.Play;
			m_scheduleBar = m_changeClipBar - 1;
			m_isWaitChangeClip = false;
			m_isReserveLayerChange = false;
			if (m_layers.Length != 0)
			{
				m_simpleSource = new AudioSourceFader(m_layers[0].Current);
			}
			int num = m_layers.Length;
			for (int i = 0; i < num; i++)
			{
				m_layers[i].Initialize();
			}
			CreateActions();
		}

		private void CreateActions()
		{
			m_onEndSimpleBgmFade = delegate
			{
				m_isSimpleMode = false;
				m_simpleSource.SetClip(null);
				m_simpleSource.SetLoop(loop: false);
			};
		}

		public void Clear()
		{
			m_isSimpleMode = false;
			m_coreLayer.Clear();
			int num = m_layers.Length;
			for (int i = 0; i < num; i++)
			{
				m_layers[i].Clear();
			}
		}

		public static bool IsCoreLayer(Layers layer)
		{
			return layer == Layers.Ambient;
		}

		public IAudioLayer GetLayer(Layers layer)
		{
			if (layer == Layers.Ambient)
			{
				return m_coreLayer;
			}
			return m_layers[(int)(layer - 1)];
		}

		public void SetupTrackInfo(int bpm, int bars, int beats, int unitPerBar, int fadeBars, int layers, bool hasIntro, bool isSingleClip)
		{
			SetBarLength(bars);
			m_coreLayer.SetupSectionSettings(bpm, beats, unitPerBar);
			m_numLayers = layers;
			m_isSingleClipMode = isSingleClip;
		}

		public void SetBarLength(int bars)
		{
			m_barLength = bars;
			m_changeClipBar = m_barLength - m_revurbLenght;
			m_scheduleBar = m_changeClipBar - 1;
		}

		public void SetupIntroClips(int layer, int frequency, List<AudioClip> clips)
		{
			if (IsCoreLayer((Layers)layer))
			{
				m_coreLayer.SetupIntroClips(clips, frequency);
			}
			else
			{
				GetLayer((Layers)layer).SetupIntroClips(clips);
			}
		}

		public void SetupOutroClips(int layer, List<AudioClip> clips)
		{
			GetLayer((Layers)layer).SetupOutroClips(clips);
		}

		public void SetupPartsClips(int layer, List<AudioClip> clips)
		{
			GetLayer((Layers)layer).SetupPartsClips(clips);
		}

		public void PlayBgm(Layers layer)
		{
			m_isSimpleMode = false;
			CurrentLayer = layer;
			if (m_isSingleClipMode)
			{
				SetupSinglePartsTrack();
			}
			else
			{
				SetLoop(isLoop: false);
				SetupNextClipIndex();
				SetNextClipsInAllLayers(m_nextClipIndex);
			}
			PlayLayers(layer, 0, 0.0, isPlaySound: false);
			PlayIntro();
		}

		private void SetupSinglePartsTrack()
		{
			SetLoop(isLoop: true);
		}

		public void SetLoop(bool isLoop)
		{
			m_coreLayer.SetLoop(isLoop);
			int num = m_layers.Length;
			for (int i = 0; i < num; i++)
			{
				m_layers[i].SetLoop(isLoop);
			}
		}

		private void PlayIntro()
		{
			float fadeDuration = (IsSinglePartTrack ? ((float)TimePerBar * 4f) : 0f);
			double dspTime = AudioSettings.dspTime;
			m_coreLayer.PlayIntro(m_nextClipIndex, dspTime, fadeDuration);
			int currentLayer = (int)CurrentLayer;
			for (int i = 0; i < currentLayer; i++)
			{
				m_layers[i].PlayIntro(m_nextClipIndex, dspTime, fadeDuration);
			}
			m_state = States.Play;
		}

		public void PlaySimpleBgm(AudioClip clip, float volume = 1f, float fadeDuration = 0.5f)
		{
			m_isSimpleMode = true;
			m_simpleSource.PlayWithFade(volume, 0f, fadeDuration, clip);
			m_simpleSource.SetLoop(loop: true);
		}

		public void SetSimpleVolume(float volume, float fadeDuration)
		{
			m_simpleSource.FadeVolume(fadeDuration, volume);
		}

		private void Update()
		{
			if (!m_coreLayer.IsPlaying)
			{
				if (m_isSimpleMode && m_simpleSource.IsPlaying)
				{
					UpdateSimpleBgm();
				}
			}
			else
			{
				UpdateFade();
				UpdateWaitBar();
				UpdateChangeClip();
			}
		}

		private void UpdateSimpleBgm()
		{
			if (m_isSimpleMode && m_simpleSource.IsPlaying)
			{
				m_simpleSource.Update(Time.deltaTime);
			}
		}

		private void UpdateFade()
		{
			float deltaTime = Time.deltaTime;
			m_coreLayer.Update(deltaTime);
			int num = m_layers.Length;
			for (int i = 0; i < num; i++)
			{
				m_layers[i].Update(deltaTime);
			}
		}

		private void UpdateWaitBar()
		{
			if (!m_coreLayer.Current.IsJustChangedBar() || IsPlayingOutro || IsStopped || m_isSingleClipMode)
			{
				return;
			}
			int bar = m_coreLayer.Current.Just.Bar;
			if (bar == m_scheduleBar)
			{
				PlayNext();
			}
			else if (bar == m_changeClipBar)
			{
				SwapMusic();
				if (m_isReserveLayerChange)
				{
					PlayLayers(m_nextLayer, m_coreLayer.Current.TimeSamples, AudioSettings.dspTime, isPlaySound: true, CalculateLayerChangeDuration());
				}
			}
			if (IsReserveOutro && bar == m_reserveProcessBar)
			{
				SetOutroClip();
			}
		}

		private void PlayNext()
		{
			if (IsWaitOutro)
			{
				m_state = States.PlayingOutro;
				float waitDuration = (float)TimePerBar * (float)(m_barLength + m_revurbLenght + 1);
				SubscribeOnEndEvent(waitDuration);
			}
			PlayNextScheduled();
		}

		private void PlayNextScheduled()
		{
			double time = AudioSettings.dspTime + TimePerBar;
			m_coreLayer.Next.PlayScheduled(time);
			PlayScheduledLayers(time);
		}

		private void PlayLayers(Layers layer, int sample, double time, bool isPlaySound, float fadeDuration = 0f)
		{
			AudioLayerVolumeData.Data data = m_voluemeData.DataList[(int)layer];
			int num = m_layers.Length;
			int volumeDataCount = data.Volume.Length;
			m_coreLayer.SetVolume(data.Volume[0], fadeDuration);
			for (int i = 0; i < num; i++)
			{
				SetupLayerOnPlay(data, layer, i, volumeDataCount, sample, time, isPlaySound, fadeDuration);
			}
			CurrentLayer = layer;
			m_isReserveLayerChange = false;
			UpdateLayerText();
		}

		private void SetupLayerOnPlay(AudioLayerVolumeData.Data volumeData, Layers layer, int index, int volumeDataCount, int sample, double time, bool isPlaySound, float fadeDuration = 0f)
		{
			int num = index + 1;
			IAudioLayer layer2 = GetLayer((Layers)num);
			if (index >= (int)layer)
			{
				if (layer2.IsPlaying)
				{
					layer2.StopWithFade(fadeDuration);
				}
				return;
			}
			SetLayerVolume(m_layers[index], num, volumeDataCount, volumeData.Volume[num], fadeDuration);
			if (isPlaySound && !layer2.IsPlaying)
			{
				layer2.SetTimeSample(sample);
				layer2.PlayScheduledWithFade(time, fadeDuration);
			}
		}

		private void SetLayerVolume(IAudioLayer layer, int layerIndex, int volumeDataCount, float volume, float fadeDuration)
		{
			if (layerIndex < volumeDataCount)
			{
				layer.SetVolume(volume, fadeDuration);
			}
		}

		private void PlayScheduledLayers(double time)
		{
			int currentLayer = (int)CurrentLayer;
			for (int i = 0; i < currentLayer; i++)
			{
				m_layers[i].PlayNextScheduled(time);
			}
		}

		private void UpdateChangeClip()
		{
			if (m_isWaitChangeClip && !m_isSingleClipMode)
			{
				bool isPlaying = m_coreLayer.Next.IsPlaying;
				if ((!isPlaying || m_coreLayer.Next.IsJustChangedBar()) && (!isPlaying || m_coreLayer.Next.Just.Bar == m_barLength))
				{
					ChangeClip();
				}
			}
		}

		private void ChangeClip()
		{
			m_isWaitChangeClip = false;
			if (!IsWaitOutro)
			{
				SetNextClip();
			}
		}

		private void SetNextClip()
		{
			SetupNextClipIndex();
			m_coreLayer.SetupNextClip(m_nextClipIndex);
			SetNextClipsInAllLayers(m_nextClipIndex);
		}

		private void SetOutroClip()
		{
			m_coreLayer.SetNextClipToOutro();
			SetNextToOutroClipsInAllLayers();
			m_state = States.WaitPlayOutro;
		}

		private void SwapMusic()
		{
			m_coreLayer.Swap();
			SwapSourcesInAllLayers();
			m_isWaitChangeClip = !IsPlayingOutro && !IsWaitOutro;
		}

		private void SwapSourcesInAllLayers()
		{
			int num = m_layers.Length;
			for (int i = 0; i < num; i++)
			{
				m_layers[i].Swap();
			}
		}

		private void SetNextClipsInAllLayers(int clipIndex)
		{
			for (int i = 0; i < NumberOfAdditionalLayers; i++)
			{
				m_layers[i].SetupNextClip(clipIndex);
			}
		}

		private void SetNextToOutroClipsInAllLayers()
		{
			for (int i = 0; i < NumberOfAdditionalLayers; i++)
			{
				m_layers[i].SetNextClipToOutro();
			}
		}

		private int GetNextClipIndex()
		{
			int clipCount = m_coreLayer.ClipCount;
			if (clipCount <= 0)
			{
				return -1;
			}
			if (m_isSingleClipMode || clipCount <= 1)
			{
				return 0;
			}
			int num = UnityEngine.Random.Range(0, clipCount);
			while (!m_isConnectSameClip && num == m_currentClipIndex)
			{
				num = UnityEngine.Random.Range(0, clipCount);
			}
			return num;
		}

		private void SetupNextClipIndex()
		{
			m_currentClipIndex = m_nextClipIndex;
			m_nextClipIndex = GetNextClipIndex();
		}

		private void UpdateClipNameText()
		{
		}

		private void UpdateLayerText()
		{
		}

		public void StopSimpleBgm(float fadeDuration)
		{
			if (m_isSimpleMode)
			{
				if (fadeDuration <= 0f)
				{
					m_simpleSource.Stop();
					m_simpleSource.SetClip(null);
					m_simpleSource.SetLoop(loop: false);
					m_isSimpleMode = false;
				}
				else
				{
					m_simpleSource.StopWithFade(fadeDuration, m_onEndSimpleBgmFade);
				}
			}
		}

		public void StopAllLayers()
		{
			if (IsPlayingParts)
			{
				m_coreLayer.Stop();
				int num = m_layers.Length;
				for (int i = 0; i < num; i++)
				{
					m_layers[i].Stop();
				}
				Observable.NextFrame(FrameCountType.EndOfFrame).Subscribe(delegate
				{
					OnEndBgm();
				});
				m_state = States.Stop;
			}
		}

		public void StopAllLayersWithFade()
		{
			if (IsPlayingParts)
			{
				float timeUntilNextBarEnd = GetTimeUntilNextBarEnd();
				m_coreLayer.StopWithFade(timeUntilNextBarEnd);
				int num = m_layers.Length;
				for (int i = 0; i < num; i++)
				{
					m_layers[i].StopWithFade(timeUntilNextBarEnd);
				}
				SubscribeOnEndEvent(timeUntilNextBarEnd);
				m_state = States.Stop;
			}
		}

		private void SubscribeOnEndEvent(float waitDuration)
		{
			Observable.Timer(TimeSpan.FromSeconds(waitDuration)).Subscribe(delegate
			{
				OnEndBgm();
			}).AddTo(m_gameObject);
		}

		private void OnEndBgm()
		{
			m_state = States.Stop;
			if (OnEndPlay != null)
			{
				OnEndPlay();
			}
		}

		public float GetTimeUntilNextBarEnd()
		{
			double deltaTimePastFromBar = m_coreLayer.Current.DeltaTimePastFromBar;
			double timePerBar = TimePerBar;
			return (float)(timePerBar - deltaTimePastFromBar + timePerBar);
		}

		public float GetTimeFromBars(int numBars, bool isCountCurrentBar, bool isCheckPlaying = true)
		{
			if (isCheckPlaying && !IsPlayingParts)
			{
				return 0f;
			}
			double timePerBar = TimePerBar;
			if (isCountCurrentBar)
			{
				double deltaTimePastFromBar = m_coreLayer.Current.DeltaTimePastFromBar;
				return (float)(timePerBar - deltaTimePastFromBar + timePerBar * (double)numBars);
			}
			return (float)(timePerBar * (double)numBars);
		}

		public float GetIntroDuration()
		{
			return GetTimeFromBars(m_changeClipBar, isCountCurrentBar: true, isCheckPlaying: false);
		}

		public void ReserveOutro()
		{
			if (IsPlayingParts)
			{
				if (IsReserveOutro || IsNearConnection || m_coreLayer.Next.IsPlaying)
				{
					m_state = States.ReserveOutro;
				}
				else
				{
					SetOutroClip();
				}
			}
		}

		public void ChangeLayer(Layers nextLayer)
		{
			if (IsPlayingParts)
			{
				if (m_isSingleClipMode)
				{
					m_nextLayer = nextLayer;
					PlayLayers(m_nextLayer, m_coreLayer.Current.TimeSamples, AudioSettings.dspTime, isPlaySound: true, (float)TimePerBar * 4f);
				}
				else
				{
					m_nextLayer = nextLayer;
					m_isReserveLayerChange = true;
				}
			}
		}

		public bool IsRemainingBarIsLonger(int barsToCheck)
		{
			return m_changeClipBar - m_coreLayer.Current.Just.Bar >= barsToCheck;
		}

		public float CalculateLayerChangeDuration()
		{
			return GetTimeFromBars(m_changeClipBar, isCountCurrentBar: false);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(AudioSource))]
	public class Music : UpdateableComponent
	{
		[Serializable]
		public class Section
		{
			public enum ClipType
			{
				None,
				Loop,
				Through,
				End
			}

			public string Name;

			public int UnitPerBeat;

			public int UnitPerBar;

			public double Tempo;

			public int StartBar;

			public int StartTimeSamples;

			public ClipType LoopType;

			public Section(int startBar, int mtBeat = 4, int mtBar = 16, double tempo = 120.0)
			{
				StartBar = startBar;
				UnitPerBeat = mtBeat;
				UnitPerBar = mtBar;
				Tempo = tempo;
			}

			public void OnValidate(int startTimeSample)
			{
				StartTimeSamples = startTimeSample;
			}

			public override string ToString()
			{
				return $"\"{Name}\" StartBar:{StartBar}, Tempo:{Tempo}";
			}
		}

		public enum SyncType
		{
			NextBeat,
			Next2Beat,
			NextBar,
			Next2Bar,
			Next4Bar,
			Next8Bar,
			SectionEnd
		}

		public List<Section> Sections;

		public bool IsLoop;

		public int EntryPointSample;

		public TextMesh DebugText;

		public bool CreateSectionClips;

		private MusicTiming just_;

		private MusicTiming near_;

		private bool isJustChanged_;

		private bool isNearChanged_;

		private bool isFormerHalf_;

		private double timeSecFromJust_;

		private int numRepeat_;

		private double musicTimeUnit_;

		private AudioSource musicSource_;

		private AudioSourceFader m_fader;

		private int sectionIndex_;

		private int currentSample_;

		private int samplingRate_;

		private int samplesPerUnit_;

		private int samplesPerBeat_;

		private int samplesPerBar_;

		private int samplesInLoop_;

		private MusicTiming oldNear_;

		private MusicTiming oldJust_;

		private int numLoopBar_ = -1;

		private List<AudioSource> quantizedCue_ = new List<AudioSource>();

		private readonly float PITCH_UNIT = Mathf.Pow(2f, 1f / 12f);

		private List<AudioSource> sectionSources_ = new List<AudioSource>();

		private bool isTransitioning_;

		private MusicTiming transitionTiming_ = new MusicTiming(0, 0, 0);

		public Section this[int index]
		{
			get
			{
				if (0 <= index && index < SectionCount_)
				{
					return Sections[index];
				}
				return null;
			}
		}

		public int SamplePerBar => samplesPerBar_;

		public int SamplePerBeat => samplesPerBeat_;

		public int SamplePerUnit => samplesPerUnit_;

		public int SampleRate
		{
			get
			{
				return samplingRate_;
			}
			set
			{
				samplingRate_ = value;
			}
		}

		public bool IsPlaying => IsPlaying_;

		public MusicTiming Just => just_;

		public MusicTiming Near => near_;

		public bool IsJustChanged => isJustChanged_;

		public bool IsNearChanged => isNearChanged_;

		public bool IsFormerHalf => isFormerHalf_;

		public double TimeSecFromJust => timeSecFromJust_;

		public int NumRepeat => numRepeat_;

		public double Lag => Lag_;

		public double LagAbs => LagAbs_;

		public double LagUnit => LagUnit_;

		public double MusicTimeUnit => musicTimeUnit_;

		public float MusicalTime => MusicalTime_;

		public float MusicalTimeBar => MusicalTimeBar_;

		public double DeltaTimePerBar => 60.0 * (double)CurrentSection_.UnitPerBeat * 1.0 / CurrentSection_.Tempo;

		public double DeltaTimePastFromBar => (double)(TimeSamples_ - just_.Bar * samplesPerBar_) / (double)samplingRate_;

		public double DeltaTimeUntilNextBar => DeltaTimePerBar - DeltaTimePastFromBar;

		public float AudioTimeSec => AudioTimeSec_;

		public int TimeSamples => TimeSamples_;

		public int UnitPerBar => UnitPerBar_;

		public int UnitPerBeat => UnitPerBeat_;

		public AudioSource CurrentSource => musicSource_;

		public AudioSourceFader Player => m_fader;

		public Section CurrentSection => CurrentSection_;

		public int CurrentSectionIndex => sectionIndex_;

		public int SectionCount => SectionCount_;

		public string CurrentMusicName => base.name;

		public bool IsTransitioning => isTransitioning_;

		private double Lag_
		{
			get
			{
				if (isFormerHalf_)
				{
					return timeSecFromJust_;
				}
				return timeSecFromJust_ - musicTimeUnit_;
			}
		}

		private double LagAbs_
		{
			get
			{
				if (isFormerHalf_)
				{
					return timeSecFromJust_;
				}
				return musicTimeUnit_ - timeSecFromJust_;
			}
		}

		private double LagUnit_ => Lag / musicTimeUnit_;

		private float MusicalTime_ => (float)((double)just_.GetMusicalTime(CurrentSection_) + timeSecFromJust_ / musicTimeUnit_);

		private float MusicalTimeBar_ => MusicalTime_ / (float)CurrentSection_.UnitPerBar;

		private float AudioTimeSec_ => musicSource_.time;

		private int TimeSamples_ => musicSource_.timeSamples;

		private int SectionCount_ => Sections.Count;

		private int UnitPerBar_ => CurrentSection.UnitPerBar;

		private int UnitPerBeat_ => CurrentSection.UnitPerBeat;

		private bool IsPlaying_ => musicSource_.isPlaying;

		private Section CurrentSection_ => Sections[sectionIndex_];

		public float MusicalTimeFrom(MusicTiming timing)
		{
			int a = 0;
			for (int i = 0; i < SectionCount; i++)
			{
				if (i + 1 < SectionCount)
				{
					if (timing.Bar < Sections[i + 1].StartBar)
					{
						a = i;
						break;
					}
				}
				else
				{
					a = i;
				}
			}
			int num = Mathf.Min(a, sectionIndex_);
			int num2 = Mathf.Max(a, sectionIndex_);
			MusicTiming musicTiming = new MusicTiming((timing < Just) ? timing : Just);
			MusicTiming musicTiming2 = ((timing > Just) ? timing : Just);
			int num3 = 0;
			for (int j = num; j <= num2; j++)
			{
				if (j < num2)
				{
					num3 += Sections[j + 1].StartBar * Sections[j].UnitPerBar - musicTiming.GetMusicalTime(Sections[j]);
					musicTiming.Set(Sections[j + 1].StartBar);
				}
				else
				{
					num3 += musicTiming2.GetMusicalTime(Sections[j]) - musicTiming.GetMusicalTime(Sections[j]);
				}
			}
			return (float)((double)(((!(timing > Just)) ? 1 : (-1)) * num3) + TimeSecFromJust / MusicTimeUnit);
		}

		public float MusicalCos(float cycle = 16f, float offset = 0f, float min = 0f, float max = 1f)
		{
			return Mathf.Lerp(min, max, ((float)Math.Cos(Math.PI * 2.0 * (double)(MusicalTime + offset) / (double)cycle) + 1f) / 2f);
		}

		public Section GetSection(int index)
		{
			return Sections[index];
		}

		public bool IsJustChangedWhen(Predicate<MusicTiming> pred)
		{
			return IsJustChangedWhen_(pred);
		}

		public bool IsJustChangedBar()
		{
			return IsJustChangedBar_();
		}

		public bool IsJustChangedBeat()
		{
			return IsJustChangedBeat_();
		}

		public bool IsJustChangedAt(int bar = 0, int beat = 0, int unit = 0)
		{
			return IsJustChangedAt_(bar, beat, unit);
		}

		public bool IsJustChangedAt(MusicTiming t)
		{
			return IsJustChangedAt_(t.Bar, t.Beat, t.Unit);
		}

		public bool IsJustChangedSection()
		{
			return IsJustChangedAt(CurrentSection_.StartBar);
		}

		public bool IsNearChangedWhen(Predicate<MusicTiming> pred)
		{
			return IsNearChangedWhen_(pred);
		}

		public bool IsNearChangedBar()
		{
			return IsNearChangedBar_();
		}

		public bool IsNearChangedBeat()
		{
			return IsNearChangedBeat_();
		}

		public bool IsNearChangedAt(int bar, int beat = 0, int unit = 0)
		{
			return IsNearChangedAt_(bar, beat, unit);
		}

		public bool IsNearChangedAt(MusicTiming t)
		{
			return IsNearChangedAt_(t.Bar, t.Beat, t.Unit);
		}

		public void QuantizePlay(AudioSource source, int transpose = 0, float allowRange = 0.3f)
		{
			source.pitch = Mathf.Pow(PITCH_UNIT, transpose);
			if (IsFormerHalf && LagUnit < (double)allowRange)
			{
				source.Play();
			}
			else
			{
				quantizedCue_.Add(source);
			}
		}

		public void Pause()
		{
			musicSource_.Pause();
		}

		public void Resume()
		{
			musicSource_.Play();
		}

		public void Stop()
		{
			musicSource_.Stop();
		}

		public void Seek(MusicTiming timing)
		{
			Section section = null;
			for (int i = 0; i < SectionCount; i++)
			{
				if (i + 1 < SectionCount)
				{
					if (timing.Bar < Sections[i + 1].StartBar)
					{
						section = Sections[i];
					}
				}
				else
				{
					section = Sections[i];
				}
			}
			int num = timing.GetMusicalTime(section) - section.StartBar * section.UnitPerBar;
			musicSource_.timeSamples = section.StartTimeSamples + (int)((double)num * MusicTimeUnit * (double)samplingRate_);
		}

		public void SetVolume(float volume)
		{
			musicSource_.volume = volume;
		}

		public void SetNextSection(int sectionIndex, SyncType syncType = SyncType.NextBar)
		{
			SetNextSection_(sectionIndex, syncType);
		}

		public void SetNextSection(string name, SyncType syncType = SyncType.NextBar)
		{
			SetNextSection(Sections.FindIndex((Section s) => s.Name == name), syncType);
		}

		private bool IsNearChangedWhen_(Predicate<MusicTiming> pred)
		{
			if (isNearChanged_)
			{
				return pred(near_);
			}
			return false;
		}

		private bool IsNearChangedBar_()
		{
			if (isNearChanged_ && near_.Beat == 0)
			{
				return near_.Unit == 0;
			}
			return false;
		}

		private bool IsNearChangedBeat_()
		{
			if (isNearChanged_)
			{
				return near_.Unit == 0;
			}
			return false;
		}

		private bool IsNearChangedAt_(int bar, int beat = 0, int unit = 0)
		{
			if (isNearChanged_ && near_.Bar == bar && near_.Beat == beat)
			{
				return near_.Unit == unit;
			}
			return false;
		}

		private bool IsJustChangedWhen_(Predicate<MusicTiming> pred)
		{
			if (isJustChanged_)
			{
				return pred(just_);
			}
			return false;
		}

		private bool IsJustChangedBar_()
		{
			if (isJustChanged_ && just_.Beat == 0)
			{
				return just_.Unit == 0;
			}
			return false;
		}

		private bool IsJustChangedBeat_()
		{
			if (isJustChanged_)
			{
				return just_.Unit == 0;
			}
			return false;
		}

		private bool IsJustChangedAt_(int bar = 0, int beat = 0, int unit = 0)
		{
			if (isJustChanged_ && just_.Bar == bar && just_.Beat == beat)
			{
				return just_.Unit == unit;
			}
			return false;
		}

		private void Awake()
		{
			musicSource_ = GetComponent<AudioSource>();
			m_fader = new AudioSourceFader(musicSource_);
			near_ = new MusicTiming(0, 0, -1);
			just_ = new MusicTiming(near_);
			oldNear_ = new MusicTiming(near_);
			oldJust_ = new MusicTiming(just_);
			SetupClips();
		}

		public void SetupClips(AudioClip clip)
		{
			musicSource_.clip = clip;
			SetupClips();
		}

		public void SetupClips()
		{
			if (!(musicSource_.clip == null))
			{
				SetupLoop();
				ResetSettings();
				OnSectionChanged();
			}
		}

		private void SetupLoop()
		{
			if (IsLoop && musicSource_.loop)
			{
				samplesInLoop_ = musicSource_.clip.samples;
				Section section = Sections[Sections.Count - 1];
				double num = 60.0 / section.Tempo;
				int num2 = (int)((double)(samplingRate_ * section.UnitPerBar) * (num / (double)section.UnitPerBeat));
				numLoopBar_ = section.StartBar + Mathf.RoundToInt((float)(samplesInLoop_ - section.StartTimeSamples) / (float)num2);
			}
		}

		private void CreateAudioFromSections()
		{
		}

		public override void OnUpdate(float delta)
		{
			if (IsPlaying_)
			{
				UpdateTiming();
			}
		}

		private void OnValidate()
		{
			if (musicSource_ == null)
			{
				musicSource_ = GetComponent<AudioSource>();
			}
			if (samplingRate_ == 0)
			{
				samplingRate_ = ((musicSource_ != null && musicSource_.clip != null) ? musicSource_.clip.frequency : 44100);
			}
			if (Sections == null || Sections.Count == 0)
			{
				Sections = new List<Section>();
				Sections.Add(new Section(0));
				Sections[0].OnValidate(EntryPointSample);
				return;
			}
			bool flag = true;
			int num = EntryPointSample;
			for (int i = 0; i < Sections.Count; i++)
			{
				if (Sections[i].StartTimeSamples != num)
				{
					flag = false;
				}
				if (!flag)
				{
					Sections[i].OnValidate(num);
				}
				if (i + 1 < Sections.Count)
				{
					if (Sections[i + 1].StartBar < Sections[i].StartBar)
					{
						Sections[i + 1].StartBar = Sections[i].StartBar + 1;
					}
					int num2 = (Sections[i + 1].StartBar - Sections[i].StartBar) * Sections[i].UnitPerBar;
					num += (int)((double)(num2 / Sections[i].UnitPerBeat) * (60.0 / Sections[i].Tempo) * (double)samplingRate_);
				}
			}
		}

		private void OnDestroy()
		{
		}

		private void ResetSettings()
		{
			isJustChanged_ = false;
			isNearChanged_ = false;
			near_.Set(0, 0, -1);
			just_.Set(0, 0, -1);
			oldNear_.Set(0, 0, -1);
			oldJust_.Set(0, 0, -1);
			timeSecFromJust_ = 0.0;
			isFormerHalf_ = true;
			numRepeat_ = 0;
			sectionIndex_ = 0;
		}

		private void OnSectionChanged()
		{
			if (Sections != null && Sections.Count != 0)
			{
				if (CurrentSection_.Tempo <= 0.0)
				{
					samplesPerUnit_ = 0;
					samplesPerBeat_ = 0;
					samplesPerBar_ = 0;
					musicTimeUnit_ = 0.0;
				}
				else
				{
					double num = 60.0 / CurrentSection_.Tempo;
					samplesPerUnit_ = (int)((double)samplingRate_ * (num / (double)CurrentSection_.UnitPerBeat));
					samplesPerBeat_ = (int)((double)samplingRate_ * num);
					samplesPerBar_ = (int)((double)(samplingRate_ * CurrentSection_.UnitPerBar) * (num / (double)CurrentSection_.UnitPerBeat));
					musicTimeUnit_ = (double)samplesPerUnit_ / (double)samplingRate_;
				}
			}
		}

		public void Play()
		{
			OnPlayStart();
			musicSource_.Play();
		}

		public void PlayScheduled(double time)
		{
			OnPlayStart();
			musicSource_.PlayScheduled(time);
		}

		public void PlayScheduledWithFade(double time, float fadeDuration)
		{
			OnPlayStart();
			m_fader.PlayScheduledWithFade(time, fadeDuration);
		}

		private void OnPlayStart()
		{
			if (IsPlaying)
			{
				Stop();
			}
			ResetSettings();
		}

		private void SetNextSection_(int sectionIndex, SyncType syncType = SyncType.NextBar)
		{
			if (CreateSectionClips && !isTransitioning_ && sectionIndex >= 0 && SectionCount > sectionIndex && sectionIndex != sectionIndex_)
			{
				int num = 0;
				transitionTiming_.Copy(just_);
				switch (syncType)
				{
				case SyncType.NextBeat:
					num = samplesPerBeat_;
					transitionTiming_.Beat++;
					transitionTiming_.Unit = 0;
					break;
				case SyncType.Next2Beat:
					num = samplesPerBeat_ * 2;
					transitionTiming_.Beat += 2;
					transitionTiming_.Unit = 0;
					break;
				case SyncType.NextBar:
					num = samplesPerBar_;
					transitionTiming_.Bar++;
					transitionTiming_.Beat = (transitionTiming_.Unit = 0);
					break;
				case SyncType.Next2Bar:
					num = samplesPerBar_ * 2;
					transitionTiming_.Bar += 2;
					transitionTiming_.Beat = (transitionTiming_.Unit = 0);
					break;
				case SyncType.Next4Bar:
					num = samplesPerBar_ * 4;
					transitionTiming_.Bar += 4;
					transitionTiming_.Beat = (transitionTiming_.Unit = 0);
					break;
				case SyncType.Next8Bar:
					num = samplesPerBar_ * 8;
					transitionTiming_.Bar += 8;
					transitionTiming_.Beat = (transitionTiming_.Unit = 0);
					break;
				case SyncType.SectionEnd:
					num = samplesInLoop_;
					transitionTiming_.Bar = CurrentSection_.StartBar + numLoopBar_;
					transitionTiming_.Beat = (transitionTiming_.Unit = 0);
					break;
				}
				transitionTiming_.Fix(CurrentSection_);
				if (CurrentSection_.LoopType == Section.ClipType.Loop && transitionTiming_.Bar >= CurrentSection_.StartBar + numLoopBar_)
				{
					transitionTiming_.Bar -= numLoopBar_;
				}
				if (num > 0)
				{
					double num2 = AudioSettings.dspTime + (double)(num - musicSource_.timeSamples % num) / (double)samplingRate_ / (double)musicSource_.pitch;
					sectionSources_[sectionIndex].PlayScheduled(num2);
					sectionSources_[sectionIndex_].SetScheduledEndTime(num2);
					isTransitioning_ = true;
				}
			}
		}

		private void UpdateTiming()
		{
			currentSample_ = musicSource_.timeSamples;
			isNearChanged_ = false;
			isJustChanged_ = false;
			int num = currentSample_ - ((!CreateSectionClips) ? CurrentSection_.StartTimeSamples : 0);
			if (num >= 0)
			{
				just_.Bar = num / samplesPerBar_ + CurrentSection_.StartBar;
				just_.Beat = num % samplesPerBar_ / samplesPerBeat_;
				just_.Unit = num % samplesPerBar_ % samplesPerBeat_ / samplesPerUnit_;
				just_.Fix(CurrentSection_);
				just_.Bar -= CurrentSection_.StartBar;
				timeSecFromJust_ = (double)(num - just_.Bar * samplesPerBar_ - just_.Beat * samplesPerBeat_ - just_.Unit * samplesPerUnit_) / (double)samplingRate_;
				isFormerHalf_ = timeSecFromJust_ * (double)samplingRate_ < (double)(samplesPerUnit_ / 2);
				just_.Bar += CurrentSection_.StartBar;
				near_.Copy(just_);
				if (!isFormerHalf_)
				{
					near_.Increment(CurrentSection_);
				}
				if (samplesInLoop_ != 0 && currentSample_ + samplesPerUnit_ / 2 >= samplesInLoop_)
				{
					near_.Init();
				}
				isNearChanged_ = !near_.Equals(oldNear_);
				isJustChanged_ = !just_.Equals(oldJust_);
				oldNear_.Copy(near_);
				oldJust_.Copy(just_);
			}
		}

		private void OnJustChanged()
		{
			int count = quantizedCue_.Count;
			for (int i = 0; i < count; i++)
			{
				quantizedCue_[i].Play();
			}
			quantizedCue_.Clear();
		}

		private void OnBeat()
		{
		}

		private void OnBar()
		{
		}

		private void OnRepeated()
		{
			numRepeat_++;
		}

		public void UpdateFade(float delta)
		{
			m_fader.Update(delta);
		}
	}
	[Serializable]
	public class MusicTiming : IComparable<MusicTiming>, IEquatable<MusicTiming>
	{
		public int Bar;

		public int Beat;

		public int Unit;

		public MusicTiming(int bar = 0, int beat = 0, int unit = 0)
		{
			Bar = bar;
			Beat = beat;
			Unit = unit;
		}

		public MusicTiming(MusicTiming copy)
		{
			Copy(copy);
		}

		public MusicTiming()
		{
			Init();
		}

		public void Init()
		{
			Bar = 0;
			Beat = 0;
			Unit = 0;
		}

		public void Copy(MusicTiming copy)
		{
			Bar = copy.Bar;
			Beat = copy.Beat;
			Unit = copy.Unit;
		}

		public void Set(int bar, int beat = 0, int unit = 0)
		{
			Bar = bar;
			Beat = beat;
			Unit = unit;
		}

		public int GetCurrentMusicalTime(Music music)
		{
			return GetMusicalTime(music.CurrentSection);
		}

		public int GetMusicalTime(Music.Section section)
		{
			return Bar * section.UnitPerBar + Beat * section.UnitPerBeat + Unit;
		}

		public void Fix(Music.Section section)
		{
			int num = Bar * section.UnitPerBar + Beat * section.UnitPerBeat + Unit;
			Bar = num / section.UnitPerBar;
			Beat = (num - Bar * section.UnitPerBar) / section.UnitPerBeat;
			Unit = num - Bar * section.UnitPerBar - Beat * section.UnitPerBeat;
		}

		public void Increment(Music.Section section)
		{
			Unit++;
			Fix(section);
		}

		public void Decrement(Music.Section section)
		{
			Unit--;
			Fix(section);
		}

		public void IncrementBeat(Music.Section section)
		{
			Beat++;
			Fix(section);
		}

		public void Add(MusicTiming t, Music.Section section)
		{
			Bar += t.Bar;
			Beat += t.Beat;
			Unit += t.Unit;
			Fix(section);
		}

		public void Subtract(MusicTiming t, Music.Section section)
		{
			Bar -= t.Bar;
			Beat -= t.Beat;
			Unit -= t.Unit;
			Fix(section);
		}

		public static bool operator >(MusicTiming t, MusicTiming t2)
		{
			if (t.Bar <= t2.Bar && (t.Bar != t2.Bar || t.Beat <= t2.Beat))
			{
				if (t.Bar == t2.Bar && t.Beat == t2.Beat)
				{
					return t.Unit > t2.Unit;
				}
				return false;
			}
			return true;
		}

		public static bool operator <(MusicTiming t, MusicTiming t2)
		{
			if (!(t > t2))
			{
				return !t.Equals(t2);
			}
			return false;
		}

		public static bool operator <=(MusicTiming t, MusicTiming t2)
		{
			return !(t > t2);
		}

		public static bool operator >=(MusicTiming t, MusicTiming t2)
		{
			if (!(t > t2))
			{
				return t.Equals(t2);
			}
			return true;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (obj == this)
			{
				return true;
			}
			if (GetType() != obj.GetType())
			{
				return false;
			}
			return Equals(obj as MusicTiming);
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		public bool Equals(MusicTiming other)
		{
			if (Bar == other.Bar && Beat == other.Beat)
			{
				return Unit == other.Unit;
			}
			return false;
		}

		public int CompareTo(MusicTiming tother)
		{
			if (Equals(tother))
			{
				return 0;
			}
			if (this > tother)
			{
				return 1;
			}
			return -1;
		}

		public override string ToString()
		{
			return Bar + " " + Beat + " " + Unit;
		}
	}
}
