using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using AnimationOrTween;
using CapturePanorama.Internals;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using UnityEngine.VR;

[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: AssemblyVersion("0.0.0.0")]
namespace CapturePanorama
{
	public class CapturePanorama : MonoBehaviour
	{
		public enum ImageFormat
		{
			PNG,
			JPEG,
			BMP
		}

		public enum AntiAliasing
		{
			_1 = 1,
			_2 = 2,
			_4 = 4,
			_8 = 8
		}

		public string panoramaName;

		public string qualitySetting;

		public KeyCode captureKey = KeyCode.P;

		public ImageFormat imageFormat;

		public bool captureStereoscopic;

		public float interpupillaryDistance = 0.0635f;

		public int numCirclePoints = 128;

		public int panoramaWidth = 8192;

		public AntiAliasing antiAliasing = AntiAliasing._8;

		public int ssaaFactor = 1;

		public string saveImagePath = string.Empty;

		public bool saveCubemap;

		public bool uploadImages;

		public bool useDefaultOrientation;

		public bool useGpuTransform = true;

		public float cpuMillisecondsPerFrame = 8.333333f;

		public bool captureEveryFrame;

		public int frameRate = 30;

		public int maxFramesToRecord;

		public int frameNumberDigits = 6;

		public AudioClip startSound;

		public AudioClip doneSound;

		public AudioClip failSound;

		public bool fadeDuringCapture = true;

		public float fadeTime = 0.25f;

		public UnityEngine.Color fadeColor = new UnityEngine.Color(0f, 0f, 0f, 1f);

		public Material fadeMaterial;

		public ComputeShader convertPanoramaShader;

		public ComputeShader convertPanoramaStereoShader;

		public ComputeShader textureToBufferShader;

		public bool enableDebugging;

		private string apiUrl = "http://alpha.vrchive.com/api/1/";

		private string apiKey = "0b26e4dca20793a83fd92ad83e3e859e";

		private GameObject[] camGos;

		private Camera cam;

		private ImageEffectCopyCamera copyCameraScript;

		private bool capturingEveryFrame;

		private bool usingGpuTransform;

		private CubemapFace[] faces;

		private int panoramaHeight;

		private int cameraWidth;

		private int cameraHeight;

		private RenderTexture cubemapRenderTexture;

		private Texture2D forceWaitTexture;

		private int convertPanoramaKernelIdx = -1;

		private int convertPanoramaYPositiveKernelIdx = -1;

		private int convertPanoramaYNegativeKernelIdx = -1;

		private int textureToBufferIdx = -1;

		private int renderStereoIdx = -1;

		private int[] convertPanoramaKernelIdxs;

		private byte[] imageFileBytes;

		private string videoBaseName = string.Empty;

		private int frameNumber;

		private const int ResultBufferSlices = 8;

		private float hFov = -1f;

		private float vFov = -1f;

		private float hFovAdjustDegrees = -1f;

		private float vFovAdjustDegrees = -1f;

		private float circleRadius = -1f;

		private int threadsX = 32;

		private int threadsY = 32;

		private int numCameras;

		private const int CamerasPerCirclePoint = 4;

		private uint[] cameraPixels;

		private uint[] resultPixels;

		private float tanHalfHFov;

		private float tanHalfVFov;

		private float hFovAdjust;

		private float vFovAdjust;

		private int overlapTextures;

		private bool initializeFailed = true;

		private AudioSource audioSource;

		private const uint BufferSentinelValue = 1419455993u;

		private int lastConfiguredPanoramaWidth;

		private int lastConfiguredNumCirclePoints;

		private int lastConfiguredSsaaFactor;

		private float lastConfiguredInterpupillaryDistance;

		private bool lastConfiguredCaptureStereoscopic;

		private bool lastConfiguredSaveCubemap;

		private bool lastConfiguredUseGpuTransform;

		private AntiAliasing lastConfiguredAntiAliasing = AntiAliasing._1;

		private static CapturePanorama instance;

		internal bool Capturing;

		private static List<Process> resizingProcessList = new List<Process>();

		private static List<string> resizingFilenames = new List<string>();

		private System.Drawing.Imaging.ImageFormat FormatToDrawingFormat(ImageFormat format)
		{
			return format switch
			{
				ImageFormat.PNG => System.Drawing.Imaging.ImageFormat.Png, 
				ImageFormat.JPEG => System.Drawing.Imaging.ImageFormat.Jpeg, 
				ImageFormat.BMP => System.Drawing.Imaging.ImageFormat.Bmp, 
				_ => System.Drawing.Imaging.ImageFormat.Png, 
			};
		}

		private string FormatMimeType(ImageFormat format)
		{
			return format switch
			{
				ImageFormat.PNG => "image/png", 
				ImageFormat.JPEG => "image/jpeg", 
				ImageFormat.BMP => "image/bmp", 
				_ => string.Empty, 
			};
		}

		private string FormatToExtension(ImageFormat format)
		{
			return format switch
			{
				ImageFormat.PNG => "png", 
				ImageFormat.JPEG => "jpg", 
				ImageFormat.BMP => "bmp", 
				_ => string.Empty, 
			};
		}

		public void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Debug.LogError("More than one CapturePanorama instance detected.");
			}
			UnityEngine.Object.DontDestroyOnLoad(this);
		}

		public void Start()
		{
			base.gameObject.SetActive(value: false);
			UnityEngine.Object.Destroy(base.gameObject);
		}

		private float IpdScaleFunction(float latitudeNormalized)
		{
			return 1.5819767f * Mathf.Exp((0f - latitudeNormalized) * latitudeNormalized) - 0.5819767f;
		}

		public void OnDestroy()
		{
			Cleanup();
		}

		private void Cleanup()
		{
			faces = null;
			UnityEngine.Object.Destroy(copyCameraScript);
			UnityEngine.Object.Destroy(cam);
			if (camGos != null)
			{
				for (int num = camGos.Length - 1; num >= 0; num--)
				{
					if (camGos[num] != null)
					{
						UnityEngine.Object.Destroy(camGos[num]);
					}
				}
			}
			camGos = null;
			numCameras = -1;
			hFov = (vFov = -1f);
			if (cubemapRenderTexture != null)
			{
				UnityEngine.Object.Destroy(cubemapRenderTexture);
			}
			cubemapRenderTexture = null;
			convertPanoramaKernelIdx = (renderStereoIdx = (textureToBufferIdx = -1));
			convertPanoramaKernelIdxs = null;
			resultPixels = (cameraPixels = null);
			if (forceWaitTexture != null)
			{
				UnityEngine.Object.Destroy(forceWaitTexture);
			}
			forceWaitTexture = new Texture2D(1, 1);
		}

		private void Reinitialize()
		{
			try
			{
				ReinitializeBody();
			}
			catch (Exception)
			{
				Cleanup();
				throw;
			}
		}

		private void ReinitializeBody()
		{
			Log("Settings changed, calling Reinitialize()");
			initializeFailed = true;
			if (!SystemInfo.supportsComputeShaders)
			{
				UnityEngine.Debug.LogWarning("CapturePanorama requires compute shaders. Your system does not support them. On PC, compute shaders require DirectX 11, Windows Vista or later, and a GPU capable of Shader Model 5.0.");
				return;
			}
			lastConfiguredCaptureStereoscopic = captureStereoscopic;
			lastConfiguredPanoramaWidth = panoramaWidth;
			lastConfiguredInterpupillaryDistance = interpupillaryDistance;
			lastConfiguredNumCirclePoints = numCirclePoints;
			lastConfiguredSsaaFactor = ssaaFactor;
			lastConfiguredAntiAliasing = antiAliasing;
			lastConfiguredSaveCubemap = saveCubemap;
			lastConfiguredUseGpuTransform = useGpuTransform;
			Cleanup();
			faces = new CubemapFace[6]
			{
				CubemapFace.PositiveX,
				CubemapFace.NegativeX,
				CubemapFace.PositiveY,
				CubemapFace.NegativeY,
				CubemapFace.PositiveZ,
				CubemapFace.NegativeZ
			};
			for (int i = 0; i < faces.Length; i++)
			{
			}
			panoramaHeight = panoramaWidth / 2;
			camGos = new GameObject[3];
			for (int j = 0; j < 3; j++)
			{
				camGos[j] = new GameObject("PanoramaCaptureCamera" + j);
				camGos[j].hideFlags = HideFlags.HideAndDontSave;
				if (j > 0)
				{
					camGos[j].transform.parent = camGos[j - 1].transform;
				}
			}
			camGos[2].AddComponent<Camera>();
			cam = camGos[2].GetComponent<Camera>();
			cam.enabled = false;
			camGos[2].AddComponent<ImageEffectCopyCamera>();
			copyCameraScript = camGos[2].GetComponent<ImageEffectCopyCamera>();
			copyCameraScript.enabled = false;
			numCameras = faces.Length;
			hFov = (vFov = 90f);
			if (captureStereoscopic)
			{
				float num = 360f / (float)numCirclePoints;
				float num2 = 0.001f;
				float b = 2f * ((float)Math.PI / 2f - Mathf.Acos(IpdScaleFunction(0.5f))) * 360f / ((float)Math.PI * 2f);
				hFov = Mathf.Max(90f + num, b) + num2;
				vFov = 90f;
				numCameras = 2 + numCirclePoints * 4;
				circleRadius = interpupillaryDistance / 2f;
				hFovAdjustDegrees = hFov / 2f;
				vFovAdjustDegrees = vFov / 2f;
			}
			double num3 = (double)panoramaWidth * 90.0 / 360.0;
			cameraWidth = (int)Math.Ceiling(Math.Tan(hFov * ((float)Math.PI * 2f) / 360f / 2f) * num3 * (double)ssaaFactor);
			cameraHeight = (int)Math.Ceiling(Math.Tan(vFov * ((float)Math.PI * 2f) / 360f / 2f) * num3 * (double)ssaaFactor);
			Log("Number of cameras: " + numCameras);
			Log("Camera dimensions: " + cameraWidth + "x" + cameraHeight);
			usingGpuTransform = useGpuTransform && convertPanoramaShader != null;
			cubemapRenderTexture = new RenderTexture(cameraWidth, cameraHeight, 24, RenderTextureFormat.ARGB32);
			cubemapRenderTexture.antiAliasing = (int)antiAliasing;
			cubemapRenderTexture.Create();
			if (usingGpuTransform)
			{
				convertPanoramaKernelIdx = convertPanoramaShader.FindKernel("CubeMapToEquirectangular");
				convertPanoramaYPositiveKernelIdx = convertPanoramaShader.FindKernel("CubeMapToEquirectangularPositiveY");
				convertPanoramaYNegativeKernelIdx = convertPanoramaShader.FindKernel("CubeMapToEquirectangularNegativeY");
				convertPanoramaKernelIdxs = new int[3] { convertPanoramaKernelIdx, convertPanoramaYPositiveKernelIdx, convertPanoramaYNegativeKernelIdx };
				convertPanoramaShader.SetInt("equirectangularWidth", panoramaWidth);
				convertPanoramaShader.SetInt("equirectangularHeight", panoramaHeight);
				convertPanoramaShader.SetInt("ssaaFactor", ssaaFactor);
				convertPanoramaShader.SetInt("cameraWidth", cameraWidth);
				convertPanoramaShader.SetInt("cameraHeight", cameraHeight);
				int num4 = (panoramaHeight + 8 - 1) / 8;
				int num5 = panoramaWidth;
				int num6 = ((!captureStereoscopic) ? num4 : (2 * panoramaHeight));
				resultPixels = new uint[num5 * num6 + 1];
			}
			textureToBufferIdx = textureToBufferShader.FindKernel("TextureToBuffer");
			textureToBufferShader.SetInt("width", cameraWidth);
			textureToBufferShader.SetInt("height", cameraHeight);
			textureToBufferShader.SetFloat("gamma", (QualitySettings.activeColorSpace != ColorSpace.Linear) ? 1f : 0.45454544f);
			renderStereoIdx = convertPanoramaStereoShader.FindKernel("RenderStereo");
			if ((saveCubemap || !usingGpuTransform) && (cameraPixels == null || cameraPixels.Length != numCameras * cameraWidth * cameraHeight))
			{
				cameraPixels = new uint[numCameras * cameraWidth * cameraHeight + 1];
			}
			tanHalfHFov = Mathf.Tan(hFov * ((float)Math.PI * 2f) / 360f / 2f);
			tanHalfVFov = Mathf.Tan(vFov * ((float)Math.PI * 2f) / 360f / 2f);
			hFovAdjust = hFovAdjustDegrees * ((float)Math.PI * 2f) / 360f;
			vFovAdjust = vFovAdjustDegrees * ((float)Math.PI * 2f) / 360f;
			if (captureStereoscopic && usingGpuTransform)
			{
				convertPanoramaStereoShader.SetFloat("tanHalfHFov", tanHalfHFov);
				convertPanoramaStereoShader.SetFloat("tanHalfVFov", tanHalfVFov);
				convertPanoramaStereoShader.SetFloat("hFovAdjust", hFovAdjust);
				convertPanoramaStereoShader.SetFloat("vFovAdjust", vFovAdjust);
				convertPanoramaStereoShader.SetFloat("interpupillaryDistance", interpupillaryDistance);
				convertPanoramaStereoShader.SetFloat("circleRadius", circleRadius);
				convertPanoramaStereoShader.SetInt("numCirclePoints", numCirclePoints);
				convertPanoramaStereoShader.SetInt("equirectangularWidth", panoramaWidth);
				convertPanoramaStereoShader.SetInt("equirectangularHeight", panoramaHeight);
				convertPanoramaStereoShader.SetInt("cameraWidth", cameraWidth);
				convertPanoramaStereoShader.SetInt("cameraHeight", cameraHeight);
				convertPanoramaStereoShader.SetInt("ssaaFactor", ssaaFactor);
			}
			initializeFailed = false;
		}

		private void Log(string s)
		{
			if (enableDebugging)
			{
				UnityEngine.Debug.Log(s, this);
			}
		}

		public void Update()
		{
			bool keyDown = Input.GetKeyDown(captureKey);
			if (initializeFailed || panoramaWidth < 4 || (captureStereoscopic && numCirclePoints < 8))
			{
				if (keyDown)
				{
					if (panoramaWidth < 4)
					{
						UnityEngine.Debug.LogError("Panorama Width must be at least 4. No panorama captured.");
					}
					if (captureStereoscopic && numCirclePoints < 8)
					{
						UnityEngine.Debug.LogError("Num Circle Points must be at least 8. No panorama captured.");
					}
					if (initializeFailed)
					{
						UnityEngine.Debug.LogError("Initialization of Capture Panorama script failed. Cannot capture content.");
					}
					if (failSound != null && Camera.main != null)
					{
						audioSource.PlayOneShot(failSound);
					}
				}
				return;
			}
			if (captureStereoscopic != lastConfiguredCaptureStereoscopic || panoramaWidth != lastConfiguredPanoramaWidth || interpupillaryDistance != lastConfiguredInterpupillaryDistance || numCirclePoints != lastConfiguredNumCirclePoints || ssaaFactor != lastConfiguredSsaaFactor || antiAliasing != lastConfiguredAntiAliasing || saveCubemap != lastConfiguredSaveCubemap || useGpuTransform != lastConfiguredUseGpuTransform)
			{
				Reinitialize();
			}
			if (capturingEveryFrame)
			{
				if ((captureKey != 0 && keyDown) || (maxFramesToRecord > 0 && frameNumber >= maxFramesToRecord))
				{
					StopCaptureEveryFrame();
					return;
				}
				CaptureScreenshotSync(videoBaseName + "_" + frameNumber.ToString(new string('0', frameNumberDigits)));
				frameNumber++;
			}
			else if (captureKey != 0 && keyDown && !Capturing)
			{
				if (captureEveryFrame)
				{
					StartCaptureEveryFrame();
					return;
				}
				string text = $"{panoramaName}_{DateTime.Now:yyyy-MM-dd_HH-mm-ss-fff}";
				Log("Panorama capture key pressed, capturing " + text);
				CaptureScreenshotAsync(text);
			}
		}

		public void StartCaptureEveryFrame()
		{
			Time.captureFramerate = frameRate;
			videoBaseName = $"{panoramaName}_{DateTime.Now:yyyy-MM-dd_HH-mm-ss-fff}";
			frameNumber = 0;
			capturingEveryFrame = true;
		}

		public void StopCaptureEveryFrame()
		{
			Time.captureFramerate = 0;
			capturingEveryFrame = false;
		}

		public void CaptureScreenshotSync(string filenameBase)
		{
			IEnumerator enumerator = CaptureScreenshotAsyncHelper(filenameBase, async: false);
			while (enumerator.MoveNext())
			{
			}
		}

		public void CaptureScreenshotAsync(string filenameBase)
		{
			StartCoroutine(CaptureScreenshotAsyncHelper(filenameBase, async: true));
		}

		private void SetFadersEnabled(IEnumerable<ScreenFadeControl> fadeControls, bool value)
		{
			foreach (ScreenFadeControl fadeControl in fadeControls)
			{
				fadeControl.enabled = value;
			}
		}

		public IEnumerator FadeOut(IEnumerable<ScreenFadeControl> fadeControls)
		{
			Log("Doing fade out");
			float elapsedTime = 0f;
			UnityEngine.Color color = fadeColor;
			color.a = 0f;
			fadeMaterial.color = color;
			SetFadersEnabled(fadeControls, value: true);
			while (elapsedTime < fadeTime)
			{
				yield return new WaitForEndOfFrame();
				elapsedTime += Time.deltaTime;
				color.a = Mathf.Clamp01(elapsedTime / fadeTime);
				fadeMaterial.color = color;
			}
		}

		public IEnumerator FadeIn(IEnumerable<ScreenFadeControl> fadeControls)
		{
			Log("Fading back in");
			float elapsedTime = 0f;
			UnityEngine.Color color2 = fadeColor;
			fadeMaterial.color = color2;
			UnityEngine.Color color = color2;
			while (elapsedTime < fadeTime)
			{
				yield return new WaitForEndOfFrame();
				elapsedTime += Time.deltaTime;
				color.a = 1f - Mathf.Clamp01(elapsedTime / fadeTime);
				fadeMaterial.color = color;
			}
			SetFadersEnabled(fadeControls, value: false);
		}

		public IEnumerator CaptureScreenshotAsyncHelper(string filenameBase, bool async)
		{
			if (async)
			{
				while (Capturing)
				{
					yield return null;
				}
			}
			Capturing = true;
			if (!OnCaptureStart())
			{
				audioSource.PlayOneShot(failSound);
				Capturing = false;
				yield break;
			}
			Camera[] cameras = GetCaptureCameras();
			Array.Sort(cameras, (Camera x, Camera y) => x.depth.CompareTo(y.depth));
			if (cameras.Length == 0)
			{
				UnityEngine.Debug.LogWarning("No cameras found to capture");
				audioSource.PlayOneShot(failSound);
				Capturing = false;
				yield break;
			}
			if (antiAliasing != AntiAliasing._1)
			{
				Camera[] array = cameras;
				foreach (Camera camera in array)
				{
					if (camera.actualRenderingPath == RenderingPath.DeferredLighting || camera.actualRenderingPath == RenderingPath.DeferredShading)
					{
						UnityEngine.Debug.LogWarning("CapturePanorama: Setting Anti Aliasing=1 because at least one camera in deferred mode. Use SSAA setting or Antialiasing image effect if needed.");
						antiAliasing = AntiAliasing._1;
						Reinitialize();
						break;
					}
				}
			}
			Log("Starting panorama capture");
			if (!captureEveryFrame && startSound != null && Camera.main != null)
			{
				audioSource.PlayOneShot(startSound);
			}
			List<ScreenFadeControl> fadeControls = new List<ScreenFadeControl>();
			Camera[] allCameras = Camera.allCameras;
			foreach (Camera camera2 in allCameras)
			{
				if (camera2.isActiveAndEnabled && camera2.targetTexture == null)
				{
					ScreenFadeControl screenFadeControl = camera2.gameObject.AddComponent<ScreenFadeControl>();
					screenFadeControl.fadeMaterial = fadeMaterial;
					fadeControls.Add(screenFadeControl);
				}
			}
			SetFadersEnabled(fadeControls, value: false);
			if (fadeDuringCapture && async)
			{
				yield return StartCoroutine(FadeOut(fadeControls));
			}
			for (int j = 0; j < 2; j++)
			{
				yield return new WaitForEndOfFrame();
			}
			ComputeBuffer convertPanoramaResultBuffer2 = null;
			ComputeBuffer forceWaitResultConvertPanoramaStereoBuffer = null;
			if (usingGpuTransform)
			{
				if (captureStereoscopic)
				{
					convertPanoramaResultBuffer2 = new ComputeBuffer(panoramaWidth * panoramaHeight * 2 + 1, 4);
					convertPanoramaStereoShader.SetBuffer(renderStereoIdx, "result", convertPanoramaResultBuffer2);
					forceWaitResultConvertPanoramaStereoBuffer = new ComputeBuffer(1, 4);
					convertPanoramaStereoShader.SetBuffer(renderStereoIdx, "forceWaitResultBuffer", forceWaitResultConvertPanoramaStereoBuffer);
				}
				else
				{
					int num = (panoramaHeight + 8 - 1) / 8;
					convertPanoramaResultBuffer2 = new ComputeBuffer(panoramaWidth * num + 1, 4);
					int[] array2 = convertPanoramaKernelIdxs;
					foreach (int kernelIndex in array2)
					{
						convertPanoramaShader.SetBuffer(kernelIndex, "result", convertPanoramaResultBuffer2);
					}
				}
			}
			int cameraPixelsBufferNumTextures = numCameras;
			overlapTextures = 0;
			int circlePointCircularBufferSize = 0;
			if (captureStereoscopic && usingGpuTransform)
			{
				overlapTextures = ((ssaaFactor == 1) ? 1 : 2);
				circlePointCircularBufferSize = 1 + overlapTextures;
				cameraPixelsBufferNumTextures = Math.Min(numCameras, 2 + 2 * circlePointCircularBufferSize);
			}
			ComputeBuffer cameraPixelsBuffer = new ComputeBuffer(cameraPixelsBufferNumTextures * cameraWidth * cameraHeight + 1, 4);
			textureToBufferShader.SetBuffer(textureToBufferIdx, "result", cameraPixelsBuffer);
			textureToBufferShader.SetInt("sentinelIdx", cameraPixelsBuffer.count - 1);
			if (usingGpuTransform && !captureStereoscopic)
			{
				convertPanoramaShader.SetInt("cameraPixelsSentinelIdx", cameraPixelsBuffer.count - 1);
				convertPanoramaShader.SetInt("sentinelIdx", convertPanoramaResultBuffer2.count - 1);
				int[] array3 = convertPanoramaKernelIdxs;
				foreach (int kernelIndex2 in array3)
				{
					convertPanoramaShader.SetBuffer(kernelIndex2, "cameraPixels", cameraPixelsBuffer);
				}
			}
			if (usingGpuTransform && captureStereoscopic)
			{
				convertPanoramaStereoShader.SetInt("cameraPixelsSentinelIdx", cameraPixelsBuffer.count - 1);
				convertPanoramaStereoShader.SetBuffer(renderStereoIdx, "cameraPixels", cameraPixelsBuffer);
			}
			ComputeBuffer forceWaitResultTextureToBufferBuffer = new ComputeBuffer(1, 4);
			textureToBufferShader.SetBuffer(textureToBufferIdx, "forceWaitResultBuffer", forceWaitResultTextureToBufferBuffer);
			float startTime = Time.realtimeSinceStartup;
			Quaternion headOrientation = Quaternion.identity;
			Log("Rendering camera views");
			Camera[] array4 = cameras;
			foreach (Camera camera3 in array4)
			{
				Log("Camera name: " + camera3.gameObject.name);
			}
			Dictionary<Camera, List<ImageEffectCopyCamera.InstanceMethodPair>> methodMap = new Dictionary<Camera, List<ImageEffectCopyCamera.InstanceMethodPair>>();
			Camera[] array5 = cameras;
			foreach (Camera camera4 in array5)
			{
				methodMap[camera4] = ImageEffectCopyCamera.GenerateMethodList(camera4);
			}
			string suffix = "." + FormatToExtension(imageFormat);
			string filePath = string.Empty;
			string imagePath = saveImagePath;
			if (imagePath == null || imagePath == string.Empty)
			{
				imagePath = Application.dataPath + "/..";
			}
			convertPanoramaStereoShader.SetInt("circlePointCircularBufferSize", circlePointCircularBufferSize);
			int nextCirclePointCircularBufferStart = 0;
			int nextCirclePointStart = 0;
			int writeIdx = 0;
			int ilimit = ((!usingGpuTransform) ? numCameras : (numCameras + overlapTextures * 4));
			int leftRightPhaseEnd = (ilimit - 2) / 2 + 2;
			int circlePointsRendered = 0;
			int saveCubemapImageNum = 0;
			Log("Changing quality level");
			int saveQualityLevel = QualitySettings.GetQualityLevel();
			bool qualitySettingWasChanged = false;
			string[] qualitySettingNames = QualitySettings.names;
			if (qualitySetting != qualitySettingNames[saveQualityLevel])
			{
				for (int num4 = 0; num4 < qualitySettingNames.Length; num4++)
				{
					string text = qualitySettingNames[num4];
					if (text == qualitySetting)
					{
						QualitySettings.SetQualityLevel(num4, applyExpensiveChanges: false);
						qualitySettingWasChanged = true;
					}
				}
				if (qualitySetting != string.Empty && !qualitySettingWasChanged)
				{
					UnityEngine.Debug.LogError("Quality setting specified for CapturePanorama is invalid, ignoring.", this);
				}
			}
			BeforeRenderPanorama();
			RenderTexture.active = null;
			for (int num5 = 0; num5 < ilimit; num5++)
			{
				if (captureStereoscopic)
				{
					if (num5 < 2)
					{
						camGos[1].transform.localPosition = Vector3.zero;
						camGos[1].transform.localRotation = Quaternion.Euler((num5 != 0) ? (-90f) : 90f, 0f, 0f);
					}
					else
					{
						int num6;
						int num7;
						if (num5 < leftRightPhaseEnd)
						{
							num6 = num5 - 2;
							num7 = 0;
						}
						else
						{
							num6 = num5 - leftRightPhaseEnd;
							num7 = 2;
						}
						int num8 = num6 / 2 % numCirclePoints;
						int num9 = num6 % 2 + num7;
						float num10 = 360f * (float)num8 / (float)numCirclePoints;
						camGos[1].transform.localPosition = Quaternion.Euler(0f, num10, 0f) * Vector3.forward * circleRadius;
						if (num9 < 2)
						{
							camGos[1].transform.localRotation = Quaternion.Euler(0f, num10 + ((num9 != 0) ? hFovAdjustDegrees : (0f - hFovAdjustDegrees)), 0f);
						}
						else
						{
							camGos[1].transform.localRotation = Quaternion.Euler((num9 != 2) ? vFovAdjustDegrees : (0f - vFovAdjustDegrees), num10, 0f);
						}
						if (num9 == 1 || num9 == 3)
						{
							circlePointsRendered++;
						}
					}
				}
				else
				{
					switch ((CubemapFace)num5)
					{
					case CubemapFace.PositiveX:
						camGos[1].transform.localRotation = Quaternion.Euler(0f, 90f, 0f);
						break;
					case CubemapFace.NegativeX:
						camGos[1].transform.localRotation = Quaternion.Euler(0f, -90f, 0f);
						break;
					case CubemapFace.PositiveY:
						camGos[1].transform.localRotation = Quaternion.Euler(90f, 0f, 0f);
						break;
					case CubemapFace.NegativeY:
						camGos[1].transform.localRotation = Quaternion.Euler(-90f, 0f, 0f);
						break;
					case CubemapFace.PositiveZ:
						camGos[1].transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
						break;
					case CubemapFace.NegativeZ:
						camGos[1].transform.localRotation = Quaternion.Euler(0f, 180f, 0f);
						break;
					}
				}
				Camera[] array6 = cameras;
				foreach (Camera camera5 in array6)
				{
					camGos[2].transform.parent = null;
					cam.CopyFrom(camera5);
					camGos[0].transform.localPosition = cam.transform.localPosition;
					camGos[0].transform.localRotation = cam.transform.localRotation;
					camGos[2].transform.parent = camGos[1].transform;
					cam.transform.localPosition = Vector3.zero;
					cam.transform.localRotation = Quaternion.identity;
					copyCameraScript.enabled = methodMap[camera5].Count > 0;
					copyCameraScript.onRenderImageMethods = methodMap[camera5];
					cam.fieldOfView = vFov;
					camGos[0].transform.rotation *= Quaternion.Inverse(headOrientation);
					if (useDefaultOrientation)
					{
						camGos[0].transform.rotation = Quaternion.identity;
					}
					cam.targetTexture = cubemapRenderTexture;
					cam.ResetAspect();
					Vector3 position = camera5.transform.position;
					Quaternion rotation = camera5.transform.rotation;
					float fieldOfView = camera5.fieldOfView;
					RenderTexture targetTexture = camera5.targetTexture;
					camera5.transform.position = cam.transform.position;
					camera5.transform.rotation = cam.transform.rotation;
					camera5.fieldOfView = cam.fieldOfView;
					cam.Render();
					camera5.transform.position = position;
					camera5.transform.rotation = rotation;
					camera5.fieldOfView = fieldOfView;
					camera5.targetTexture = targetTexture;
				}
				RenderTexture.active = cubemapRenderTexture;
				forceWaitTexture.ReadPixels(new Rect(cameraWidth - 1, cameraHeight - 1, 1f, 1f), 0, 0);
				int num12 = 1000000 + num5;
				textureToBufferShader.SetInt("forceWaitValue", num12);
				textureToBufferShader.SetTexture(textureToBufferIdx, "source", cubemapRenderTexture);
				textureToBufferShader.SetInt("startIdx", writeIdx * cameraWidth * cameraHeight);
				textureToBufferShader.Dispatch(textureToBufferIdx, (cameraWidth + threadsX - 1) / threadsX, (cameraHeight + threadsY - 1) / threadsY, 1);
				uint[] array7 = new uint[1];
				forceWaitResultTextureToBufferBuffer.GetData(array7);
				if (array7[0] != num12)
				{
					UnityEngine.Debug.LogError("TextureToBufferShader: Unexpected forceWaitResult value " + array7[0] + ", should be " + num12);
				}
				if (saveCubemap && (num5 < 2 || (num5 >= 2 && num5 < 2 + numCirclePoints * 2) || (num5 >= leftRightPhaseEnd && num5 < leftRightPhaseEnd + numCirclePoints * 2)))
				{
					cameraPixelsBuffer.GetData(cameraPixels);
					if (cameraPixels[cameraPixelsBuffer.count - 1] != 1419455993)
					{
						ReportOutOfGraphicsMemory();
					}
					SaveCubemapImage(cameraPixels, filenameBase, suffix, imagePath, saveCubemapImageNum, writeIdx);
					saveCubemapImageNum++;
				}
				writeIdx++;
				if (writeIdx >= cameraPixelsBufferNumTextures)
				{
					writeIdx = 2;
				}
				if (captureStereoscopic && usingGpuTransform && (num5 - 2 + 1) % 2 == 0 && (circlePointsRendered - nextCirclePointStart >= circlePointCircularBufferSize || num5 + 1 == 2 + (ilimit - 2) / 2 || num5 + 1 == ilimit))
				{
					num12 = 2000000 + num5;
					convertPanoramaStereoShader.SetInt("forceWaitValue", num12);
					convertPanoramaStereoShader.SetInt("leftRightPass", (num5 < leftRightPhaseEnd) ? 1 : 0);
					convertPanoramaStereoShader.SetInt("circlePointStart", nextCirclePointStart);
					convertPanoramaStereoShader.SetInt("circlePointEnd", (cameraPixelsBufferNumTextures >= numCameras) ? (circlePointsRendered + 1) : circlePointsRendered);
					convertPanoramaStereoShader.SetInt("circlePointCircularBufferStart", nextCirclePointCircularBufferStart);
					convertPanoramaStereoShader.Dispatch(renderStereoIdx, (panoramaWidth + threadsX - 1) / threadsX, (panoramaHeight + threadsY - 1) / threadsY, 2);
					forceWaitResultConvertPanoramaStereoBuffer.GetData(array7);
					if (array7[0] != num12)
					{
						UnityEngine.Debug.LogError("ConvertPanoramaStereoShader: Unexpected forceWaitResult value " + array7[0] + ", should be " + num12);
					}
					if (num5 + 1 == leftRightPhaseEnd)
					{
						nextCirclePointCircularBufferStart = (nextCirclePointCircularBufferStart + circlePointCircularBufferSize) % circlePointCircularBufferSize;
						nextCirclePointStart = 0;
						circlePointsRendered = 0;
					}
					else
					{
						nextCirclePointStart = circlePointsRendered - overlapTextures;
						nextCirclePointCircularBufferStart = (nextCirclePointCircularBufferStart + circlePointCircularBufferSize - overlapTextures) % circlePointCircularBufferSize;
					}
				}
				RenderTexture.active = null;
			}
			AfterRenderPanorama();
			Log("Resetting quality level");
			if (qualitySettingWasChanged)
			{
				QualitySettings.SetQualityLevel(saveQualityLevel, applyExpensiveChanges: false);
			}
			if (saveCubemap || !usingGpuTransform)
			{
				cameraPixelsBuffer.GetData(cameraPixels);
				if (cameraPixels[cameraPixelsBuffer.count - 1] != 1419455993)
				{
					ReportOutOfGraphicsMemory();
				}
			}
			RenderTexture.active = null;
			if (saveCubemap && (!captureStereoscopic || !usingGpuTransform))
			{
				for (int num13 = 0; num13 < numCameras; num13++)
				{
					int bufferIdx = num13;
					SaveCubemapImage(cameraPixels, filenameBase, suffix, imagePath, num13, bufferIdx);
				}
			}
			for (int i = 0; i < 2; i++)
			{
				yield return new WaitForEndOfFrame();
			}
			if (async && !usingGpuTransform && fadeDuringCapture)
			{
				yield return StartCoroutine(FadeIn(fadeControls));
			}
			filePath = imagePath + "/" + filenameBase + suffix;
			bool producedImageSuccess2 = false;
			Bitmap bitmap = new Bitmap(panoramaWidth, panoramaHeight * ((!captureStereoscopic) ? 1 : 2), PixelFormat.Format32bppArgb);
			BitmapData bmpData = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height), ImageLockMode.WriteOnly, bitmap.PixelFormat);
			IntPtr ptr = bmpData.Scan0;
			byte[] pixelValues = new byte[Math.Abs(bmpData.Stride) * bitmap.Height];
			if (async)
			{
				yield return StartCoroutine(CubemapToEquirectangular(cameraPixelsBuffer, cameraPixels, convertPanoramaResultBuffer2, cameraWidth, cameraHeight, pixelValues, bmpData.Stride, panoramaWidth, panoramaHeight, ssaaFactor, async));
			}
			else
			{
				IEnumerator enumerator = CubemapToEquirectangular(cameraPixelsBuffer, cameraPixels, convertPanoramaResultBuffer2, cameraWidth, cameraHeight, pixelValues, bmpData.Stride, panoramaWidth, panoramaHeight, ssaaFactor, async);
				while (enumerator.MoveNext())
				{
				}
			}
			producedImageSuccess2 = pixelValues[3] == byte.MaxValue;
			yield return null;
			Marshal.Copy(pixelValues, 0, ptr, pixelValues.Length);
			bitmap.UnlockBits(bmpData);
			yield return null;
			Log("Time to take panorama screenshot: " + (Time.realtimeSinceStartup - startTime) + " sec");
			if (producedImageSuccess2)
			{
				Thread thread = new Thread((ThreadStart)delegate
				{
					Log("Saving equirectangular image");
					bitmap.Save(filePath, FormatToDrawingFormat(imageFormat));
				});
				thread.Start();
				while (thread.ThreadState == System.Threading.ThreadState.Running)
				{
					if (async)
					{
						yield return null;
					}
					else
					{
						Thread.Sleep(0);
					}
				}
			}
			bitmap.Dispose();
			ComputeBuffer[] array8 = new ComputeBuffer[4] { convertPanoramaResultBuffer2, cameraPixelsBuffer, forceWaitResultConvertPanoramaStereoBuffer, forceWaitResultTextureToBufferBuffer };
			for (int num14 = 0; num14 < array8.Length; num14++)
			{
				array8[num14]?.Release();
			}
			ComputeBuffer computeBuffer = null;
			convertPanoramaResultBuffer2 = computeBuffer;
			if (async && usingGpuTransform && fadeDuringCapture)
			{
				yield return StartCoroutine(FadeIn(fadeControls));
			}
			foreach (ScreenFadeControl item in fadeControls)
			{
				UnityEngine.Object.Destroy(item);
			}
			fadeControls.Clear();
			if (producedImageSuccess2 && uploadImages && !captureEveryFrame)
			{
				Log("Uploading image");
				imageFileBytes = File.ReadAllBytes(filePath);
				string mimeType = FormatMimeType(imageFormat);
				if (async)
				{
					yield return StartCoroutine(UploadImage(imageFileBytes, filenameBase + suffix, mimeType, async));
					yield break;
				}
				IEnumerator enumerator3 = UploadImage(imageFileBytes, filenameBase + suffix, mimeType, async);
				while (enumerator3.MoveNext())
				{
				}
				yield break;
			}
			if (!producedImageSuccess2)
			{
				if (failSound != null && Camera.main != null)
				{
					audioSource.PlayOneShot(failSound);
				}
			}
			else if (!captureEveryFrame && doneSound != null && Camera.main != null)
			{
				audioSource.PlayOneShot(doneSound);
			}
			Capturing = false;
		}

		public virtual bool OnCaptureStart()
		{
			return true;
		}

		public virtual Camera[] GetCaptureCameras()
		{
			Camera[] allCameras = Camera.allCameras;
			List<Camera> list = new List<Camera>();
			Camera[] array = allCameras;
			foreach (Camera item in array)
			{
				list.Add(item);
			}
			return list.ToArray();
		}

		public virtual void BeforeRenderPanorama()
		{
		}

		public virtual void AfterRenderPanorama()
		{
		}

		private static void ReportOutOfGraphicsMemory()
		{
			throw new OutOfMemoryException("Exhausted graphics memory while capturing panorama. Lower Panorama Width, increase Num Circle Points for stereoscopic images, disable Anti Aliasing, or disable Stereoscopic Capture.");
		}

		private void SaveCubemapImage(uint[] cameraPixels, string filenameBase, string suffix, string imagePath, int i, int bufferIdx)
		{
			Bitmap bitmap = new Bitmap(cameraWidth, cameraHeight, PixelFormat.Format32bppArgb);
			BitmapData bitmapData = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height), ImageLockMode.WriteOnly, bitmap.PixelFormat);
			IntPtr scan = bitmapData.Scan0;
			byte[] array = new byte[Math.Abs(bitmapData.Stride) * bitmap.Height];
			int stride = bitmapData.Stride;
			int height = bitmapData.Height;
			int num = bufferIdx * cameraWidth * cameraHeight;
			for (int j = 0; j < cameraHeight; j++)
			{
				int num2 = stride * (height - 1 - j);
				for (int k = 0; k < cameraWidth; k++)
				{
					uint num3 = cameraPixels[num];
					array[num2] = (byte)(num3 & 0xFFu);
					array[num2 + 1] = (byte)((num3 >> 8) & 0xFFu);
					array[num2 + 2] = (byte)(num3 >> 16);
					array[num2 + 3] = byte.MaxValue;
					num2 += 4;
					num++;
				}
			}
			Marshal.Copy(array, 0, scan, array.Length);
			bitmap.UnlockBits(bitmapData);
			string text;
			if (captureStereoscopic)
			{
				text = i.ToString();
				Log("Saving lightfield camera image number " + text);
			}
			else
			{
				CubemapFace cubemapFace = (CubemapFace)i;
				text = cubemapFace.ToString();
				Log("Saving cubemap image " + text);
			}
			string filename = imagePath + "/" + filenameBase + "_" + text + suffix;
			bitmap.Save(filename, FormatToDrawingFormat(imageFormat));
			bitmap.Dispose();
		}

		private Color32 GetCameraPixelBilinear(uint[] cameraPixels, int cameraNum, float u, float v)
		{
			u *= (float)cameraWidth;
			v *= (float)cameraHeight;
			int num = (int)Math.Floor(u);
			int num2 = Math.Min(cameraWidth - 1, num + 1);
			int num3 = (int)Math.Floor(v);
			int num4 = Math.Min(cameraHeight - 1, num3 + 1);
			float t = u - (float)num;
			float t2 = v - (float)num3;
			int num5 = cameraNum * cameraWidth * cameraHeight;
			int num6 = num5 + num3 * cameraWidth;
			int num7 = num5 + num4 * cameraWidth;
			uint num8 = cameraPixels[num6 + num];
			uint num9 = cameraPixels[num6 + num2];
			uint num10 = cameraPixels[num7 + num];
			uint num11 = cameraPixels[num7 + num2];
			float num12 = Mathf.Lerp(Mathf.Lerp(num8 >> 16, num10 >> 16, t2), Mathf.Lerp(num9 >> 16, num11 >> 16, t2), t);
			float num13 = Mathf.Lerp(Mathf.Lerp((num8 >> 8) & 0xFFu, (num10 >> 8) & 0xFFu, t2), Mathf.Lerp((num9 >> 8) & 0xFFu, (num11 >> 8) & 0xFFu, t2), t);
			float num14 = Mathf.Lerp(Mathf.Lerp(num8 & 0xFFu, num10 & 0xFFu, t2), Mathf.Lerp(num9 & 0xFFu, num11 & 0xFFu, t2), t);
			return new UnityEngine.Color(num12 / 255f, num13 / 255f, num14 / 255f, 1f);
		}

		internal void ClearProcessQueue()
		{
			while (resizingProcessList.Count > 0)
			{
				resizingProcessList[0].WaitForExit();
				File.Delete(resizingFilenames[0]);
				resizingProcessList.RemoveAt(0);
				resizingFilenames.RemoveAt(0);
			}
		}

		private IEnumerator UploadImage(byte[] imageFileBytes, string filename, string mimeType, bool async)
		{
			float startTime = Time.realtimeSinceStartup;
			WWWForm form = new WWWForm();
			form.AddField("key", apiKey);
			form.AddField("action", "upload");
			form.AddBinaryData("source", imageFileBytes, filename, mimeType);
			WWW w = new WWW(apiUrl + "upload", form);
			yield return w;
			if (!string.IsNullOrEmpty(w.error))
			{
				UnityEngine.Debug.LogError("Panorama upload failed: " + w.error, this);
				if (failSound != null && Camera.main != null)
				{
					audioSource.PlayOneShot(failSound);
				}
			}
			else
			{
				Log("Time to upload panorama screenshot: " + (Time.realtimeSinceStartup - startTime) + " sec");
				if (!captureEveryFrame && doneSound != null && Camera.main != null)
				{
					audioSource.PlayOneShot(doneSound);
				}
			}
			Capturing = false;
		}

		private IEnumerator CubemapToEquirectangular(ComputeBuffer cameraPixelsBuffer, uint[] cameraPixels, ComputeBuffer convertPanoramaResultBuffer, int cameraWidth, int cameraHeight, byte[] pixelValues, int stride, int panoramaWidth, int panoramaHeight, int ssaaFactor, bool async)
		{
			if (captureStereoscopic && usingGpuTransform)
			{
				convertPanoramaResultBuffer.GetData(resultPixels);
				if (resultPixels[convertPanoramaResultBuffer.count - 1] != 1419455993)
				{
					ReportOutOfGraphicsMemory();
				}
				writeOutputPixels(pixelValues, stride, panoramaWidth, panoramaHeight * 2, panoramaHeight * 2, 0);
			}
			else if (captureStereoscopic && !usingGpuTransform)
			{
				float startTime = Time.realtimeSinceStartup;
				float processingTimePerFrame = cpuMillisecondsPerFrame / 1000f;
				for (int y = 0; y < panoramaHeight; y++)
				{
					for (int x = 0; x < panoramaWidth; x++)
					{
						float xcoord = (float)x / (float)panoramaWidth;
						float ycoord = (float)y / (float)panoramaHeight;
						float latitude = (ycoord - 0.5f) * (float)Math.PI;
						float sinLat = Mathf.Sin(latitude);
						float cosLat = Mathf.Cos(latitude);
						float longitude = (xcoord * 2f - 1f) * (float)Math.PI;
						float sinLong = Mathf.Sin(longitude);
						float cosLong = Mathf.Cos(longitude);
						float latitudeNormalized = latitude / ((float)Math.PI / 2f);
						float ipdScale = IpdScaleFunction(latitudeNormalized);
						float scaledEyeRadius = ipdScale * interpupillaryDistance / 2f;
						float ipdScaleLerp = 1f - ipdScale * 5f;
						UnityEngine.Color colorCap = new UnityEngine.Color(0f, 0f, 0f, 0f);
						if (ipdScaleLerp > 0f)
						{
							Vector3 vector = new Vector3(cosLat * sinLong, sinLat, cosLat * cosLong);
							float num = 1f / vector.y;
							float u4 = vector.x * num;
							float v4 = vector.z * num;
							if (u4 * u4 <= 1f && v4 * v4 <= 1f)
							{
								int cameraNum2;
								if (vector.y > 0f)
								{
									cameraNum2 = 0;
								}
								else
								{
									u4 = 0f - u4;
									cameraNum2 = 1;
								}
								u4 = (u4 + 1f) * 0.5f;
								v4 = (v4 + 1f) * 0.5f;
								colorCap = GetCameraPixelBilinear(cameraPixels, cameraNum2, u4, v4);
							}
						}
						for (int i = 0; i < 2; i++)
						{
							Vector3 vector2 = new Vector3(sinLong, 0f, cosLong);
							float num2 = (float)Math.PI / 2f - Mathf.Acos(scaledEyeRadius / circleRadius);
							if (i == 0)
							{
								num2 = 0f - num2;
							}
							float num3 = longitude + num2;
							if (num3 < 0f)
							{
								num3 += (float)Math.PI * 2f;
							}
							if (num3 >= (float)Math.PI * 2f)
							{
								num3 -= (float)Math.PI * 2f;
							}
							float num4 = num3 / ((float)Math.PI * 2f) * (float)numCirclePoints;
							int num5 = (int)Mathf.Floor(num4) % numCirclePoints;
							UnityEngine.Color a = default(UnityEngine.Color);
							UnityEngine.Color b = default(UnityEngine.Color);
							for (int j = 0; j < 2; j++)
							{
								int num6 = ((j != 0) ? ((num5 + 1) % numCirclePoints) : num5);
								float f = (float)Math.PI * 2f * (float)num6 / (float)numCirclePoints;
								float num7 = Mathf.Sin(f);
								float num8 = Mathf.Cos(f);
								float num9 = Mathf.Sign(vector2.x * num8 - vector2.z * num7) * Mathf.Acos(vector2.z * num8 + vector2.x * num7);
								float num10 = Mathf.Cos(num9);
								float num11 = Mathf.Sin(num9);
								int cameraNum2 = 2 + num6 * 2 + ((num9 >= 0f) ? 1 : 0);
								float num12 = ((!(num9 >= 0f)) ? hFovAdjust : (0f - hFovAdjust));
								float f2 = num9 + num12;
								Vector3 vector3 = new Vector3(cosLat * Mathf.Sin(f2), sinLat, cosLat * Mathf.Cos(f2));
								float u4 = vector3.x / vector3.z / tanHalfHFov;
								float v4 = (0f - vector3.y) / vector3.z / tanHalfVFov;
								if (!(vector3.z > 0f) || !(u4 * u4 <= 1f) || !(v4 * v4 <= 0.9f))
								{
									cameraNum2 = 2 + numCirclePoints * 2 + num6 * 2 + ((latitude >= 0f) ? 1 : 0);
									float f3 = ((!(latitude >= 0f)) ? (0f - vFovAdjust) : vFovAdjust);
									float num13 = Mathf.Cos(f3);
									float num14 = Mathf.Sin(f3);
									vector3 = new Vector3(cosLat * num11, num13 * sinLat - cosLat * num10 * num14, num14 * sinLat + cosLat * num10 * num13);
									u4 = vector3.x / vector3.z / tanHalfHFov;
									v4 = (0f - vector3.y) / vector3.z / tanHalfVFov;
								}
								u4 = (u4 + 1f) * 0.5f;
								v4 = (v4 + 1f) * 0.5f;
								UnityEngine.Color color = GetCameraPixelBilinear(cameraPixels, cameraNum2, u4, v4);
								if (j == 0)
								{
									a = color;
								}
								else
								{
									b = color;
								}
							}
							Color32 color2 = UnityEngine.Color.Lerp(a, b, num4 - Mathf.Floor(num4));
							if (colorCap.a > 0f && ipdScaleLerp > 0f)
							{
								color2 = UnityEngine.Color.Lerp(color2, colorCap, ipdScaleLerp);
							}
							int num15 = stride * (y + panoramaHeight * i) + x * 4;
							pixelValues[num15] = color2.b;
							pixelValues[num15 + 1] = color2.g;
							pixelValues[num15 + 2] = color2.r;
							pixelValues[num15 + 3] = byte.MaxValue;
						}
						if ((x & 0xFF) == 0 && Time.realtimeSinceStartup - startTime > processingTimePerFrame)
						{
							yield return null;
							startTime = Time.realtimeSinceStartup;
						}
					}
				}
			}
			else if (!captureStereoscopic && usingGpuTransform)
			{
				int num16 = (panoramaHeight + 8 - 1) / 8;
				Log("Invoking GPU shader for equirectangular reprojection");
				int num17 = (int)Mathf.Floor((float)panoramaHeight * 0.25f);
				int num18 = (int)Mathf.Ceil((float)panoramaHeight * 0.75f);
				for (int k = 0; k < 8; k++)
				{
					int num19 = k * num16;
					int num20 = Math.Min(num19 + num16, panoramaHeight);
					convertPanoramaShader.SetInt("startY", k * num16);
					convertPanoramaShader.SetInt("sliceHeight", num20 - num19);
					if (num20 <= num17)
					{
						convertPanoramaShader.Dispatch(convertPanoramaYNegativeKernelIdx, (panoramaWidth + threadsX - 1) / threadsX, (num16 + threadsY - 1) / threadsY, 1);
					}
					else if (num19 >= num18)
					{
						convertPanoramaShader.Dispatch(convertPanoramaYPositiveKernelIdx, (panoramaWidth + threadsX - 1) / threadsX, (num16 + threadsY - 1) / threadsY, 1);
					}
					else
					{
						convertPanoramaShader.Dispatch(convertPanoramaKernelIdx, (panoramaWidth + threadsX - 1) / threadsX, (panoramaHeight + threadsY - 1) / threadsY, 1);
					}
					convertPanoramaResultBuffer.GetData(resultPixels);
					if (resultPixels[convertPanoramaResultBuffer.count - 1] != 1419455993)
					{
						ReportOutOfGraphicsMemory();
					}
					writeOutputPixels(pixelValues, stride, panoramaWidth, num16, panoramaHeight, num19);
				}
			}
			else if (async)
			{
				yield return StartCoroutine(CubemapToEquirectangularCpu(cameraPixels, cameraWidth, cameraHeight, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, async));
			}
			else
			{
				IEnumerator enumerator = CubemapToEquirectangularCpu(cameraPixels, cameraWidth, cameraHeight, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, async);
				while (enumerator.MoveNext())
				{
				}
			}
		}

		private void writeOutputPixels(byte[] pixelValues, int stride, int bitmapWidth, int inHeight, int outHeight, int yStart)
		{
			int num = 0;
			for (int i = yStart; i < yStart + inHeight && i < outHeight; i++)
			{
				int num2 = stride * i;
				for (int j = 0; j < bitmapWidth; j++)
				{
					uint num3 = resultPixels[num];
					pixelValues[num2] = (byte)((num3 >> 0) & 0xFFu);
					pixelValues[num2 + 1] = (byte)((num3 >> 8) & 0xFFu);
					pixelValues[num2 + 2] = (byte)((num3 >> 16) & 0xFFu);
					pixelValues[num2 + 3] = byte.MaxValue;
					num2 += 4;
					num++;
				}
			}
		}

		private IEnumerator CubemapToEquirectangularCpu(uint[] cameraPixels, int cameraWidth, int cameraHeight, byte[] pixelValues, int stride, int panoramaWidth, int panoramaHeight, int ssaaFactor, bool async)
		{
			Log("Converting to equirectangular");
			yield return null;
			float startTime = Time.realtimeSinceStartup;
			float processingTimePerFrame = cpuMillisecondsPerFrame / 1000f;
			float maxWidth = 1f - 1f / (float)cameraWidth;
			float maxHeight = 1f - 1f / (float)cameraHeight;
			int numPixelsAveraged = ssaaFactor * ssaaFactor;
			int endYPositive = (int)Mathf.Floor((float)panoramaHeight * 0.25f);
			int startYNegative = (int)Mathf.Ceil((float)panoramaHeight * 0.75f);
			int endTopMixedRegion = (int)Mathf.Ceil((float)panoramaHeight * 0.30408698f);
			int startBottomMixedRegion = (int)Mathf.Floor((float)panoramaHeight * 0.695913f);
			int startXNegative = (int)Mathf.Ceil((float)panoramaWidth * 1f / 8f);
			int endXNegative = (int)Mathf.Floor((float)panoramaWidth * 3f / 8f);
			int startZPositive = (int)Mathf.Ceil((float)panoramaWidth * 3f / 8f);
			int endZPositive = (int)Mathf.Floor((float)panoramaWidth * 5f / 8f);
			int startXPositive = (int)Mathf.Ceil((float)panoramaWidth * 5f / 8f);
			int endXPositive = (int)Mathf.Floor((float)panoramaWidth * 7f / 8f);
			int startZNegative = (int)Mathf.Ceil((float)panoramaWidth * 7f / 8f);
			int endZNegative = (int)Mathf.Floor((float)panoramaWidth * 1f / 8f);
			if (async)
			{
				yield return StartCoroutine(CubemapToEquirectangularCpuPositiveY(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, 0, 0, panoramaWidth, endYPositive));
				yield return StartCoroutine(CubemapToEquirectangularCpuNegativeY(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, 0, startYNegative, panoramaWidth, panoramaHeight));
				yield return StartCoroutine(CubemapToEquirectangularCpuPositiveX(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, startXPositive, endTopMixedRegion, endXPositive, startBottomMixedRegion));
				yield return StartCoroutine(CubemapToEquirectangularCpuNegativeX(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, startXNegative, endTopMixedRegion, endXNegative, startBottomMixedRegion));
				yield return StartCoroutine(CubemapToEquirectangularCpuPositiveZ(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, startZPositive, endTopMixedRegion, endZPositive, startBottomMixedRegion));
				yield return StartCoroutine(CubemapToEquirectangularCpuNegativeZ(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, startZNegative, endTopMixedRegion, panoramaWidth, startBottomMixedRegion));
				yield return StartCoroutine(CubemapToEquirectangularCpuNegativeZ(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, 0, endTopMixedRegion, endZNegative, startBottomMixedRegion));
				yield return StartCoroutine(CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, 0, endYPositive, panoramaWidth, endTopMixedRegion));
				yield return StartCoroutine(CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, 0, startBottomMixedRegion, panoramaWidth, startYNegative));
				if (endZNegative < startXNegative)
				{
					yield return StartCoroutine(CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, endZNegative, endTopMixedRegion, startXNegative, startBottomMixedRegion));
				}
				if (endXNegative < startZPositive)
				{
					yield return StartCoroutine(CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, endXNegative, endTopMixedRegion, startZPositive, startBottomMixedRegion));
				}
				if (endZPositive < startXPositive)
				{
					yield return StartCoroutine(CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, endZPositive, endTopMixedRegion, startXPositive, startBottomMixedRegion));
				}
				if (endXPositive < startZNegative)
				{
					yield return StartCoroutine(CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, endXPositive, endTopMixedRegion, startZNegative, startBottomMixedRegion));
				}
			}
			else
			{
				IEnumerator enumerator = CubemapToEquirectangularCpuPositiveY(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, 0, 0, panoramaWidth, endYPositive);
				while (enumerator.MoveNext())
				{
				}
				enumerator = CubemapToEquirectangularCpuNegativeY(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, 0, startYNegative, panoramaWidth, panoramaHeight);
				while (enumerator.MoveNext())
				{
				}
				enumerator = CubemapToEquirectangularCpuPositiveX(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, startXPositive, endTopMixedRegion, endXPositive, startBottomMixedRegion);
				while (enumerator.MoveNext())
				{
				}
				enumerator = CubemapToEquirectangularCpuNegativeX(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, startXNegative, endTopMixedRegion, endXNegative, startBottomMixedRegion);
				while (enumerator.MoveNext())
				{
				}
				enumerator = CubemapToEquirectangularCpuPositiveZ(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, startZPositive, endTopMixedRegion, endZPositive, startBottomMixedRegion);
				while (enumerator.MoveNext())
				{
				}
				enumerator = CubemapToEquirectangularCpuNegativeZ(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, startZNegative, endTopMixedRegion, panoramaWidth, startBottomMixedRegion);
				while (enumerator.MoveNext())
				{
				}
				enumerator = CubemapToEquirectangularCpuNegativeZ(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, numPixelsAveraged, 0, endTopMixedRegion, endZNegative, startBottomMixedRegion);
				while (enumerator.MoveNext())
				{
				}
				enumerator = CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, 0, endYPositive, panoramaWidth, endTopMixedRegion);
				while (enumerator.MoveNext())
				{
				}
				enumerator = CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, 0, startBottomMixedRegion, panoramaWidth, startYNegative);
				while (enumerator.MoveNext())
				{
				}
				if (endZNegative < startXNegative)
				{
					enumerator = CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, endZNegative, endTopMixedRegion, startXNegative, startBottomMixedRegion);
					while (enumerator.MoveNext())
					{
					}
				}
				if (endXNegative < startZPositive)
				{
					enumerator = CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, endXNegative, endTopMixedRegion, startZPositive, startBottomMixedRegion);
					while (enumerator.MoveNext())
					{
					}
				}
				if (endZPositive < startXPositive)
				{
					enumerator = CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, endZPositive, endTopMixedRegion, startXPositive, startBottomMixedRegion);
					while (enumerator.MoveNext())
					{
					}
				}
				if (endXPositive < startZNegative)
				{
					enumerator = CubemapToEquirectangularCpuGeneralCase(cameraPixels, pixelValues, stride, panoramaWidth, panoramaHeight, ssaaFactor, startTime, processingTimePerFrame, maxWidth, maxHeight, numPixelsAveraged, endXPositive, endTopMixedRegion, startZNegative, startBottomMixedRegion);
					while (enumerator.MoveNext())
					{
					}
				}
			}
			yield return null;
		}

		private IEnumerator CubemapToEquirectangularCpuPositiveY(uint[] cameraPixels, byte[] pixelValues, int stride, int panoramaWidth, int panoramaHeight, int ssaaFactor, float startTime, float processingTimePerFrame, int numPixelsAveraged, int startX, int startY, int endX, int endY)
		{
			for (int y = startY; y < endY; y++)
			{
				for (int x = startX; x < endX; x++)
				{
					int rTotal = 0;
					int gTotal = 0;
					int bTotal = 0;
					int aTotal = 0;
					for (int i = y * ssaaFactor; i < (y + 1) * ssaaFactor; i++)
					{
						for (int j = x * ssaaFactor; j < (x + 1) * ssaaFactor; j++)
						{
							float num = (float)j / (float)(panoramaWidth * ssaaFactor);
							float num2 = (float)i / (float)(panoramaHeight * ssaaFactor);
							float f = (num2 - 0.5f) * (float)Math.PI;
							float f2 = (num * 2f - 1f) * (float)Math.PI;
							float num3 = Mathf.Cos(f);
							Vector3 vector = new Vector3(num3 * Mathf.Sin(f2), 0f - Mathf.Sin(f), num3 * Mathf.Cos(f2));
							float num4 = 1f / vector.y;
							float num5 = vector.x * num4;
							float num6 = vector.z * num4;
							num5 = (num5 + 1f) / 2f;
							num6 = (num6 + 1f) / 2f;
							Color32 cameraPixelBilinear = GetCameraPixelBilinear(cameraPixels, 2, num5, num6);
							rTotal += cameraPixelBilinear.r;
							gTotal += cameraPixelBilinear.g;
							bTotal += cameraPixelBilinear.b;
							aTotal += cameraPixelBilinear.a;
						}
					}
					int baseIdx = stride * (panoramaHeight - 1 - y) + x * 4;
					pixelValues[baseIdx] = (byte)(bTotal / numPixelsAveraged);
					pixelValues[baseIdx + 1] = (byte)(gTotal / numPixelsAveraged);
					pixelValues[baseIdx + 2] = (byte)(rTotal / numPixelsAveraged);
					pixelValues[baseIdx + 3] = (byte)(aTotal / numPixelsAveraged);
					if ((x & 0xFF) == 0 && Time.realtimeSinceStartup - startTime > processingTimePerFrame)
					{
						yield return null;
						startTime = Time.realtimeSinceStartup;
					}
				}
			}
		}

		private IEnumerator CubemapToEquirectangularCpuNegativeY(uint[] cameraPixels, byte[] pixelValues, int stride, int panoramaWidth, int panoramaHeight, int ssaaFactor, float startTime, float processingTimePerFrame, int numPixelsAveraged, int startX, int startY, int endX, int endY)
		{
			for (int y = startY; y < endY; y++)
			{
				for (int x = startX; x < endX; x++)
				{
					int rTotal = 0;
					int gTotal = 0;
					int bTotal = 0;
					int aTotal = 0;
					for (int i = y * ssaaFactor; i < (y + 1) * ssaaFactor; i++)
					{
						for (int j = x * ssaaFactor; j < (x + 1) * ssaaFactor; j++)
						{
							float num = (float)j / (float)(panoramaWidth * ssaaFactor);
							float num2 = (float)i / (float)(panoramaHeight * ssaaFactor);
							float f = (num2 - 0.5f) * (float)Math.PI;
							float f2 = (num * 2f - 1f) * (float)Math.PI;
							float num3 = Mathf.Cos(f);
							Vector3 vector = new Vector3(num3 * Mathf.Sin(f2), 0f - Mathf.Sin(f), num3 * Mathf.Cos(f2));
							float num4 = 1f / vector.y;
							float num5 = vector.x * num4;
							float num6 = vector.z * num4;
							num5 = 0f - num5;
							num5 = (num5 + 1f) / 2f;
							num6 = (num6 + 1f) / 2f;
							Color32 cameraPixelBilinear = GetCameraPixelBilinear(cameraPixels, 3, num5, num6);
							rTotal += cameraPixelBilinear.r;
							gTotal += cameraPixelBilinear.g;
							bTotal += cameraPixelBilinear.b;
							aTotal += cameraPixelBilinear.a;
						}
					}
					int baseIdx = stride * (panoramaHeight - 1 - y) + x * 4;
					pixelValues[baseIdx] = (byte)(bTotal / numPixelsAveraged);
					pixelValues[baseIdx + 1] = (byte)(gTotal / numPixelsAveraged);
					pixelValues[baseIdx + 2] = (byte)(rTotal / numPixelsAveraged);
					pixelValues[baseIdx + 3] = (byte)(aTotal / numPixelsAveraged);
					if ((x & 0xFF) == 0 && Time.realtimeSinceStartup - startTime > processingTimePerFrame)
					{
						yield return null;
						startTime = Time.realtimeSinceStartup;
					}
				}
			}
		}

		private IEnumerator CubemapToEquirectangularCpuPositiveX(uint[] cameraPixels, byte[] pixelValues, int stride, int panoramaWidth, int panoramaHeight, int ssaaFactor, float startTime, float processingTimePerFrame, int numPixelsAveraged, int startX, int startY, int endX, int endY)
		{
			for (int y = startY; y < endY; y++)
			{
				for (int x = startX; x < endX; x++)
				{
					int rTotal = 0;
					int gTotal = 0;
					int bTotal = 0;
					int aTotal = 0;
					for (int i = y * ssaaFactor; i < (y + 1) * ssaaFactor; i++)
					{
						for (int j = x * ssaaFactor; j < (x + 1) * ssaaFactor; j++)
						{
							float num = (float)j / (float)(panoramaWidth * ssaaFactor);
							float num2 = (float)i / (float)(panoramaHeight * ssaaFactor);
							float f = (num2 - 0.5f) * (float)Math.PI;
							float f2 = (num * 2f - 1f) * (float)Math.PI;
							float num3 = Mathf.Cos(f);
							Vector3 vector = new Vector3(num3 * Mathf.Sin(f2), 0f - Mathf.Sin(f), num3 * Mathf.Cos(f2));
							float num4 = 1f / vector.x;
							float num5 = (0f - vector.z) * num4;
							float num6 = vector.y * num4;
							num6 = 0f - num6;
							num5 = (num5 + 1f) / 2f;
							num6 = (num6 + 1f) / 2f;
							Color32 cameraPixelBilinear = GetCameraPixelBilinear(cameraPixels, 0, num5, num6);
							rTotal += cameraPixelBilinear.r;
							gTotal += cameraPixelBilinear.g;
							bTotal += cameraPixelBilinear.b;
							aTotal += cameraPixelBilinear.a;
						}
					}
					int baseIdx = stride * (panoramaHeight - 1 - y) + x * 4;
					pixelValues[baseIdx] = (byte)(bTotal / numPixelsAveraged);
					pixelValues[baseIdx + 1] = (byte)(gTotal / numPixelsAveraged);
					pixelValues[baseIdx + 2] = (byte)(rTotal / numPixelsAveraged);
					pixelValues[baseIdx + 3] = (byte)(aTotal / numPixelsAveraged);
					if ((x & 0xFF) == 0 && Time.realtimeSinceStartup - startTime > processingTimePerFrame)
					{
						yield return null;
						startTime = Time.realtimeSinceStartup;
					}
				}
			}
		}

		private IEnumerator CubemapToEquirectangularCpuNegativeX(uint[] cameraPixels, byte[] pixelValues, int stride, int panoramaWidth, int panoramaHeight, int ssaaFactor, float startTime, float processingTimePerFrame, int numPixelsAveraged, int startX, int startY, int endX, int endY)
		{
			for (int y = startY; y < endY; y++)
			{
				for (int x = startX; x < endX; x++)
				{
					int rTotal = 0;
					int gTotal = 0;
					int bTotal = 0;
					int aTotal = 0;
					for (int i = y * ssaaFactor; i < (y + 1) * ssaaFactor; i++)
					{
						for (int j = x * ssaaFactor; j < (x + 1) * ssaaFactor; j++)
						{
							float num = (float)j / (float)(panoramaWidth * ssaaFactor);
							float num2 = (float)i / (float)(panoramaHeight * ssaaFactor);
							float f = (num2 - 0.5f) * (float)Math.PI;
							float f2 = (num * 2f - 1f) * (float)Math.PI;
							float num3 = Mathf.Cos(f);
							Vector3 vector = new Vector3(num3 * Mathf.Sin(f2), 0f - Mathf.Sin(f), num3 * Mathf.Cos(f2));
							float num4 = 1f / vector.x;
							float num5 = (0f - vector.z) * num4;
							float num6 = vector.y * num4;
							num5 = (num5 + 1f) / 2f;
							num6 = (num6 + 1f) / 2f;
							Color32 cameraPixelBilinear = GetCameraPixelBilinear(cameraPixels, 1, num5, num6);
							rTotal += cameraPixelBilinear.r;
							gTotal += cameraPixelBilinear.g;
							bTotal += cameraPixelBilinear.b;
							aTotal += cameraPixelBilinear.a;
						}
					}
					int baseIdx = stride * (panoramaHeight - 1 - y) + x * 4;
					pixelValues[baseIdx] = (byte)(bTotal / numPixelsAveraged);
					pixelValues[baseIdx + 1] = (byte)(gTotal / numPixelsAveraged);
					pixelValues[baseIdx + 2] = (byte)(rTotal / numPixelsAveraged);
					pixelValues[baseIdx + 3] = (byte)(aTotal / numPixelsAveraged);
					if ((x & 0xFF) == 0 && Time.realtimeSinceStartup - startTime > processingTimePerFrame)
					{
						yield return null;
						startTime = Time.realtimeSinceStartup;
					}
				}
			}
		}

		private IEnumerator CubemapToEquirectangularCpuPositiveZ(uint[] cameraPixels, byte[] pixelValues, int stride, int panoramaWidth, int panoramaHeight, int ssaaFactor, float startTime, float processingTimePerFrame, int numPixelsAveraged, int startX, int startY, int endX, int endY)
		{
			for (int y = startY; y < endY; y++)
			{
				for (int x = startX; x < endX; x++)
				{
					int rTotal = 0;
					int gTotal = 0;
					int bTotal = 0;
					int aTotal = 0;
					for (int i = y * ssaaFactor; i < (y + 1) * ssaaFactor; i++)
					{
						for (int j = x * ssaaFactor; j < (x + 1) * ssaaFactor; j++)
						{
							float num = (float)j / (float)(panoramaWidth * ssaaFactor);
							float num2 = (float)i / (float)(panoramaHeight * ssaaFactor);
							float f = (num2 - 0.5f) * (float)Math.PI;
							float f2 = (num * 2f - 1f) * (float)Math.PI;
							float num3 = Mathf.Cos(f);
							Vector3 vector = new Vector3(num3 * Mathf.Sin(f2), 0f - Mathf.Sin(f), num3 * Mathf.Cos(f2));
							float num4 = 1f / vector.z;
							float num5 = vector.x * num4;
							float num6 = vector.y * num4;
							num6 = 0f - num6;
							num5 = (num5 + 1f) / 2f;
							num6 = (num6 + 1f) / 2f;
							Color32 cameraPixelBilinear = GetCameraPixelBilinear(cameraPixels, 4, num5, num6);
							rTotal += cameraPixelBilinear.r;
							gTotal += cameraPixelBilinear.g;
							bTotal += cameraPixelBilinear.b;
							aTotal += cameraPixelBilinear.a;
						}
					}
					int baseIdx = stride * (panoramaHeight - 1 - y) + x * 4;
					pixelValues[baseIdx] = (byte)(bTotal / numPixelsAveraged);
					pixelValues[baseIdx + 1] = (byte)(gTotal / numPixelsAveraged);
					pixelValues[baseIdx + 2] = (byte)(rTotal / numPixelsAveraged);
					pixelValues[baseIdx + 3] = (byte)(aTotal / numPixelsAveraged);
					if ((x & 0xFF) == 0 && Time.realtimeSinceStartup - startTime > processingTimePerFrame)
					{
						yield return null;
						startTime = Time.realtimeSinceStartup;
					}
				}
			}
		}

		private IEnumerator CubemapToEquirectangularCpuNegativeZ(uint[] cameraPixels, byte[] pixelValues, int stride, int panoramaWidth, int panoramaHeight, int ssaaFactor, float startTime, float processingTimePerFrame, int numPixelsAveraged, int startX, int startY, int endX, int endY)
		{
			for (int y = startY; y < endY; y++)
			{
				for (int x = startX; x < endX; x++)
				{
					int rTotal = 0;
					int gTotal = 0;
					int bTotal = 0;
					int aTotal = 0;
					for (int i = y * ssaaFactor; i < (y + 1) * ssaaFactor; i++)
					{
						for (int j = x * ssaaFactor; j < (x + 1) * ssaaFactor; j++)
						{
							float num = (float)j / (float)(panoramaWidth * ssaaFactor);
							float num2 = (float)i / (float)(panoramaHeight * ssaaFactor);
							float f = (num2 - 0.5f) * (float)Math.PI;
							float f2 = (num * 2f - 1f) * (float)Math.PI;
							float num3 = Mathf.Cos(f);
							Vector3 vector = new Vector3(num3 * Mathf.Sin(f2), 0f - Mathf.Sin(f), num3 * Mathf.Cos(f2));
							float num4 = 1f / vector.z;
							float num5 = vector.x * num4;
							float num6 = vector.y * num4;
							num5 = (num5 + 1f) / 2f;
							num6 = (num6 + 1f) / 2f;
							Color32 cameraPixelBilinear = GetCameraPixelBilinear(cameraPixels, 5, num5, num6);
							rTotal += cameraPixelBilinear.r;
							gTotal += cameraPixelBilinear.g;
							bTotal += cameraPixelBilinear.b;
							aTotal += cameraPixelBilinear.a;
						}
					}
					int baseIdx = stride * (panoramaHeight - 1 - y) + x * 4;
					pixelValues[baseIdx] = (byte)(bTotal / numPixelsAveraged);
					pixelValues[baseIdx + 1] = (byte)(gTotal / numPixelsAveraged);
					pixelValues[baseIdx + 2] = (byte)(rTotal / numPixelsAveraged);
					pixelValues[baseIdx + 3] = (byte)(aTotal / numPixelsAveraged);
					if ((x & 0xFF) == 0 && Time.realtimeSinceStartup - startTime > processingTimePerFrame)
					{
						yield return null;
						startTime = Time.realtimeSinceStartup;
					}
				}
			}
		}

		private IEnumerator CubemapToEquirectangularCpuGeneralCase(uint[] cameraPixels, byte[] pixelValues, int stride, int panoramaWidth, int panoramaHeight, int ssaaFactor, float startTime, float processingTimePerFrame, float maxWidth, float maxHeight, int numPixelsAveraged, int startX, int startY, int endX, int endY)
		{
			for (int y = startY; y < endY; y++)
			{
				for (int x = startX; x < endX; x++)
				{
					int rTotal = 0;
					int gTotal = 0;
					int bTotal = 0;
					int aTotal = 0;
					for (int i = y * ssaaFactor; i < (y + 1) * ssaaFactor; i++)
					{
						for (int j = x * ssaaFactor; j < (x + 1) * ssaaFactor; j++)
						{
							float num = (float)j / (float)(panoramaWidth * ssaaFactor);
							float num2 = (float)i / (float)(panoramaHeight * ssaaFactor);
							float f = (num2 - 0.5f) * (float)Math.PI;
							float f2 = (num * 2f - 1f) * (float)Math.PI;
							float num3 = Mathf.Cos(f);
							Vector3 vector = new Vector3(num3 * Mathf.Sin(f2), 0f - Mathf.Sin(f), num3 * Mathf.Cos(f2));
							float num4 = 1f / vector.y;
							float num5 = vector.x * num4;
							float num6 = vector.z * num4;
							CubemapFace cameraNum;
							if (vector.y > 0f)
							{
								cameraNum = CubemapFace.PositiveY;
							}
							else
							{
								cameraNum = CubemapFace.NegativeY;
								num5 = 0f - num5;
							}
							if (Mathf.Abs(num5) > 1f || Mathf.Abs(num6) > 1f)
							{
								num4 = 1f / vector.x;
								num5 = (0f - vector.z) * num4;
								num6 = vector.y * num4;
								if (vector.x > 0f)
								{
									cameraNum = CubemapFace.PositiveX;
									num6 = 0f - num6;
								}
								else
								{
									cameraNum = CubemapFace.NegativeX;
								}
							}
							if (Mathf.Abs(num5) > 1f || Mathf.Abs(num6) > 1f)
							{
								num4 = 1f / vector.z;
								num5 = vector.x * num4;
								num6 = vector.y * num4;
								if (vector.z > 0f)
								{
									cameraNum = CubemapFace.PositiveZ;
									num6 = 0f - num6;
								}
								else
								{
									cameraNum = CubemapFace.NegativeZ;
								}
							}
							num5 = (num5 + 1f) / 2f;
							num6 = (num6 + 1f) / 2f;
							num5 = Mathf.Min(num5, maxWidth);
							num6 = Mathf.Min(num6, maxHeight);
							Color32 cameraPixelBilinear = GetCameraPixelBilinear(cameraPixels, (int)cameraNum, num5, num6);
							rTotal += cameraPixelBilinear.r;
							gTotal += cameraPixelBilinear.g;
							bTotal += cameraPixelBilinear.b;
							aTotal += cameraPixelBilinear.a;
						}
					}
					int baseIdx = stride * (panoramaHeight - 1 - y) + x * 4;
					pixelValues[baseIdx] = (byte)(bTotal / numPixelsAveraged);
					pixelValues[baseIdx + 1] = (byte)(gTotal / numPixelsAveraged);
					pixelValues[baseIdx + 2] = (byte)(rTotal / numPixelsAveraged);
					pixelValues[baseIdx + 3] = (byte)(aTotal / numPixelsAveraged);
					if ((x & 0xFF) == 0 && Time.realtimeSinceStartup - startTime > processingTimePerFrame)
					{
						yield return null;
						startTime = Time.realtimeSinceStartup;
					}
				}
			}
		}
	}
	public static class Icosphere
	{
		public static Mesh BuildIcosphere(float radius, int iterations)
		{
			Mesh mesh = BuildIcosahedron(radius);
			for (int i = 0; i < iterations; i++)
			{
				Refine(mesh);
			}
			return mesh;
		}

		public static Mesh BuildIcosahedron(float radius)
		{
			Mesh mesh = new Mesh();
			float num = (float)((1.0 + Math.Sqrt(5.0)) / 2.0);
			Vector3[] array = new Vector3[12]
			{
				new Vector3(-1f, num, 0f),
				new Vector3(1f, num, 0f),
				new Vector3(-1f, 0f - num, 0f),
				new Vector3(1f, 0f - num, 0f),
				new Vector3(0f, -1f, num),
				new Vector3(0f, 1f, num),
				new Vector3(0f, -1f, 0f - num),
				new Vector3(0f, 1f, 0f - num),
				new Vector3(num, 0f, -1f),
				new Vector3(num, 0f, 1f),
				new Vector3(0f - num, 0f, -1f),
				new Vector3(0f - num, 0f, 1f)
			};
			float num2 = radius / new Vector3(1f, num, 0f).magnitude;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] *= num2;
			}
			mesh.vertices = array;
			mesh.triangles = new int[60]
			{
				0, 11, 5, 0, 5, 1, 0, 1, 7, 0,
				7, 10, 0, 10, 11, 1, 5, 9, 5, 11,
				4, 11, 10, 2, 10, 7, 6, 7, 1, 8,
				3, 9, 4, 3, 4, 2, 3, 2, 6, 3,
				6, 8, 3, 8, 9, 4, 9, 5, 2, 4,
				11, 6, 2, 10, 8, 6, 7, 9, 8, 1
			};
			return mesh;
		}

		private static void Refine(Mesh m)
		{
			throw new Exception("TODO");
		}
	}
}
namespace CapturePanorama.Internals
{
	internal class ImageEffectCopyCamera : MonoBehaviour
	{
		public struct InstanceMethodPair
		{
			public object Instance;

			public MethodInfo Method;
		}

		public List<InstanceMethodPair> onRenderImageMethods = new List<InstanceMethodPair>();

		private RenderTexture[] temp = new RenderTexture[2];

		public static List<InstanceMethodPair> GenerateMethodList(Camera camToCopy)
		{
			List<InstanceMethodPair> list = new List<InstanceMethodPair>();
			MonoBehaviour[] components = camToCopy.gameObject.GetComponents<MonoBehaviour>();
			foreach (MonoBehaviour monoBehaviour in components)
			{
				if (monoBehaviour.enabled)
				{
					Type type = monoBehaviour.GetType();
					MethodInfo method = type.GetMethod("OnRenderImage", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
					{
						typeof(RenderTexture),
						typeof(RenderTexture)
					}, null);
					if (method != null)
					{
						InstanceMethodPair item = default(InstanceMethodPair);
						item.Instance = monoBehaviour;
						item.Method = method;
						list.Add(item);
					}
				}
			}
			return list;
		}

		private void OnDestroy()
		{
			for (int i = 0; i < temp.Length; i++)
			{
				if (temp[i] != null)
				{
					UnityEngine.Object.Destroy(temp[i]);
				}
				temp[i] = null;
			}
		}

		private void OnRenderImage(RenderTexture src, RenderTexture dest)
		{
			int num = Math.Max(src.depth, dest.depth);
			for (int i = 0; i < temp.Length; i++)
			{
				if (onRenderImageMethods.Count > i + 1)
				{
					if (temp[i] != null && (temp[i].width != dest.width || temp[i].height != dest.height || temp[i].depth != num || temp[i].format != dest.format))
					{
						UnityEngine.Object.Destroy(temp[i]);
						temp[i] = null;
					}
					if (temp[i] == null)
					{
						temp[i] = new RenderTexture(dest.width, dest.height, num, dest.format);
					}
				}
			}
			List<RenderTexture> list = new List<RenderTexture>();
			list.Add(src);
			for (int j = 0; j < onRenderImageMethods.Count - 1; j++)
			{
				list.Add((j % 2 != 0) ? temp[1] : temp[0]);
			}
			list.Add(dest);
			for (int k = 0; k < onRenderImageMethods.Count; k++)
			{
				onRenderImageMethods[k].Method.Invoke(onRenderImageMethods[k].Instance, new object[2]
				{
					list[k],
					list[k + 1]
				});
			}
		}
	}
}
namespace CapturePanorama
{
	public class ReadPanoConfig : MonoBehaviour
	{
		public string iniPath;

		private void Start()
		{
			if (Application.isEditor)
			{
				return;
			}
			CapturePanorama component = GetComponent<CapturePanorama>();
			string text = iniPath;
			if (text == string.Empty)
			{
				string text2 = "CapturePanorama.ini";
				text = Application.dataPath + "/" + text2;
			}
			if (!File.Exists(text))
			{
				WriteConfig(text, component);
				return;
			}
			string[] array = File.ReadAllLines(text);
			foreach (string text3 in array)
			{
				if (!(text3.Trim() == string.Empty))
				{
					string[] array2 = text3.Split(new char[1] { '=' }, 2);
					string text4 = array2[0].Trim();
					string text5 = array2[1].Trim();
					switch (text4)
					{
					case "Panorama Name":
						component.panoramaName = text5;
						break;
					case "Capture Key":
						component.captureKey = (KeyCode)Enum.Parse(typeof(KeyCode), text5);
						break;
					case "Image Format":
						component.imageFormat = (CapturePanorama.ImageFormat)Enum.Parse(typeof(CapturePanorama.ImageFormat), text5);
						break;
					case "Capture Stereoscopic":
						component.captureStereoscopic = bool.Parse(text5);
						break;
					case "Interpupillary Distance":
						component.interpupillaryDistance = float.Parse(text5);
						break;
					case "Num Circle Points":
						component.numCirclePoints = int.Parse(text5);
						break;
					case "Panorama Width":
						component.panoramaWidth = int.Parse(text5);
						break;
					case "Anti Aliasing":
						component.antiAliasing = (CapturePanorama.AntiAliasing)int.Parse(text5);
						break;
					case "Ssaa Factor":
						component.ssaaFactor = int.Parse(text5);
						break;
					case "Save Image Path":
						component.saveImagePath = text5;
						break;
					case "Save Cubemap":
						component.saveCubemap = bool.Parse(text5);
						break;
					case "Upload Images":
						component.uploadImages = bool.Parse(text5);
						break;
					case "Use Default Orientation":
						component.useDefaultOrientation = bool.Parse(text5);
						break;
					case "Use Gpu Transform":
						component.useGpuTransform = bool.Parse(text5);
						break;
					case "Cpu Milliseconds Per Frame":
						component.cpuMillisecondsPerFrame = (float)double.Parse(text5);
						break;
					case "Capture Every Frame":
						component.captureEveryFrame = bool.Parse(text5);
						break;
					case "Frame Rate":
						component.frameRate = int.Parse(text5);
						break;
					case "Max Frames To Record":
						component.maxFramesToRecord = ((!(text5 == string.Empty)) ? int.Parse(text5) : 0);
						break;
					case "Frame Number Digits":
						component.frameNumberDigits = int.Parse(text5);
						break;
					case "Fade During Capture":
						component.fadeDuringCapture = bool.Parse(text5);
						break;
					case "Fade Time":
						component.fadeTime = float.Parse(text5);
						break;
					case "Enable Debugging":
						component.enableDebugging = bool.Parse(text5);
						break;
					default:
						UnityEngine.Debug.LogError("Unrecognized key in line in CapturePanorama.ini: " + text3);
						break;
					}
				}
			}
		}

		private void WriteConfig(string path, CapturePanorama pano)
		{
			using StreamWriter streamWriter = new StreamWriter(path);
			streamWriter.WriteLine("Panorama Name=" + pano.panoramaName);
			streamWriter.WriteLine("Capture Key=" + pano.captureKey);
			streamWriter.WriteLine("Image Format=" + pano.imageFormat);
			streamWriter.WriteLine("Capture Stereoscopic=" + pano.captureStereoscopic);
			streamWriter.WriteLine("Interpupillary Distance=" + pano.interpupillaryDistance);
			streamWriter.WriteLine("Num Circle Points=" + pano.numCirclePoints);
			streamWriter.WriteLine("Panorama Width=" + pano.panoramaWidth);
			streamWriter.WriteLine("Anti Aliasing=" + (int)pano.antiAliasing);
			streamWriter.WriteLine("Ssaa Factor=" + pano.ssaaFactor);
			streamWriter.WriteLine("Save Image Path=" + pano.saveImagePath);
			streamWriter.WriteLine("Save Cubemap=" + pano.saveCubemap);
			streamWriter.WriteLine("Upload Images=" + pano.uploadImages);
			streamWriter.WriteLine("Use Default Orientation=" + pano.useDefaultOrientation);
			streamWriter.WriteLine("Use Gpu Transform=" + pano.useGpuTransform);
			streamWriter.WriteLine("Cpu Milliseconds Per Frame=" + pano.cpuMillisecondsPerFrame);
			streamWriter.WriteLine("Capture Every Frame=" + pano.captureEveryFrame);
			streamWriter.WriteLine("Frame Rate=" + pano.frameRate);
			streamWriter.WriteLine("Max Frames To Record=" + pano.maxFramesToRecord);
			streamWriter.WriteLine("Frame Number Digits=" + pano.frameNumberDigits);
			streamWriter.WriteLine("Fade During Capture=" + pano.fadeDuringCapture);
			streamWriter.WriteLine("Fade Time=" + pano.fadeTime);
			streamWriter.WriteLine("Enable Debugging=" + pano.enableDebugging);
		}
	}
}
namespace CapturePanorama.Internals
{
	public class ScreenFadeControl : MonoBehaviour
	{
		public Material fadeMaterial;

		private void OnCustomPostRender()
		{
			fadeMaterial.SetPass(0);
			GL.PushMatrix();
			GL.LoadOrtho();
			GL.Color(fadeMaterial.color);
			GL.Begin(7);
			GL.Vertex3(0f, 0f, -12f);
			GL.Vertex3(0f, 1f, -12f);
			GL.Vertex3(1f, 1f, -12f);
			GL.Vertex3(1f, 0f, -12f);
			GL.End();
			GL.PopMatrix();
		}
	}
}
[AddComponentMenu("NGUI/Examples/Equip Items")]
public class EquipItems : MonoBehaviour
{
	public int[] itemIDs;

	private void Start()
	{
		if (itemIDs != null && itemIDs.Length > 0)
		{
			InvEquipment invEquipment = GetComponent<InvEquipment>();
			if (invEquipment == null)
			{
				invEquipment = base.gameObject.AddComponent<InvEquipment>();
			}
			int max = 12;
			int i = 0;
			for (int num = itemIDs.Length; i < num; i++)
			{
				int num2 = itemIDs[i];
				InvBaseItem invBaseItem = InvDatabase.FindByID(num2);
				if (invBaseItem != null)
				{
					InvGameItem invGameItem = new InvGameItem(num2, invBaseItem);
					invGameItem.quality = (InvGameItem.Quality)UnityEngine.Random.Range(0, max);
					invGameItem.itemLevel = NGUITools.RandomRange(invBaseItem.minItemLevel, invBaseItem.maxItemLevel);
					invEquipment.Equip(invGameItem);
				}
				else
				{
					UnityEngine.Debug.LogWarning("Can't resolve the item ID of " + num2);
				}
			}
		}
		UnityEngine.Object.Destroy(this);
	}
}
[AddComponentMenu("NGUI/Examples/Equip Random Item")]
public class EquipRandomItem : MonoBehaviour
{
	public InvEquipment equipment;

	private void OnClick()
	{
		if (!(equipment == null))
		{
			List<InvBaseItem> items = InvDatabase.list[0].items;
			if (items.Count != 0)
			{
				int max = 12;
				int num = UnityEngine.Random.Range(0, items.Count);
				InvBaseItem invBaseItem = items[num];
				InvGameItem invGameItem = new InvGameItem(num, invBaseItem);
				invGameItem.quality = (InvGameItem.Quality)UnityEngine.Random.Range(0, max);
				invGameItem.itemLevel = NGUITools.RandomRange(invBaseItem.minItemLevel, invBaseItem.maxItemLevel);
				equipment.Equip(invGameItem);
			}
		}
	}
}
[RequireComponent(typeof(UISprite))]
[AddComponentMenu("NGUI/Examples/UI Cursor")]
public class UICursor : MonoBehaviour
{
	public static UICursor instance;

	public Camera uiCamera;

	private Transform mTrans;

	private UISprite mSprite;

	private UIAtlas mAtlas;

	private string mSpriteName;

	private void Awake()
	{
		instance = this;
	}

	private void OnDestroy()
	{
		instance = null;
	}

	private void Start()
	{
		mTrans = base.transform;
		mSprite = GetComponentInChildren<UISprite>();
		if (uiCamera == null)
		{
			uiCamera = NGUITools.FindCameraForLayer(base.gameObject.layer);
		}
		if (mSprite != null)
		{
			mAtlas = mSprite.atlas;
			mSpriteName = mSprite.spriteName;
			if (mSprite.depth < 100)
			{
				mSprite.depth = 100;
			}
		}
	}

	private void Update()
	{
		Vector3 mousePosition = Input.mousePosition;
		if (uiCamera != null)
		{
			mousePosition.x = Mathf.Clamp01(mousePosition.x / (float)Screen.width);
			mousePosition.y = Mathf.Clamp01(mousePosition.y / (float)Screen.height);
			mTrans.position = uiCamera.ViewportToWorldPoint(mousePosition);
			if (uiCamera.orthographic)
			{
				Vector3 localPosition = mTrans.localPosition;
				localPosition.x = Mathf.Round(localPosition.x);
				localPosition.y = Mathf.Round(localPosition.y);
				mTrans.localPosition = localPosition;
			}
		}
		else
		{
			mousePosition.x -= (float)Screen.width * 0.5f;
			mousePosition.y -= (float)Screen.height * 0.5f;
			mousePosition.x = Mathf.Round(mousePosition.x);
			mousePosition.y = Mathf.Round(mousePosition.y);
			mTrans.localPosition = mousePosition;
		}
	}

	public static void Clear()
	{
		if (instance != null && instance.mSprite != null)
		{
			Set(instance.mAtlas, instance.mSpriteName);
		}
	}

	public static void Set(UIAtlas atlas, string sprite)
	{
		if (instance != null && (bool)instance.mSprite)
		{
			instance.mSprite.atlas = atlas;
			instance.mSprite.spriteName = sprite;
			instance.mSprite.MakePixelPerfect();
			instance.Update();
		}
	}
}
[AddComponentMenu("NGUI/Examples/UI Equipment Slot")]
public class UIEquipmentSlot : UIItemSlot
{
	public InvEquipment equipment;

	public InvBaseItem.Slot slot;

	protected override InvGameItem observedItem => (!(equipment != null)) ? null : equipment.GetItem(slot);

	protected override InvGameItem Replace(InvGameItem item)
	{
		return (!(equipment != null)) ? item : equipment.Replace(slot, item);
	}
}
public abstract class UIItemSlot : MonoBehaviour
{
	public UISprite icon;

	public UIWidget background;

	public UILabel label;

	public AudioClip grabSound;

	public AudioClip placeSound;

	public AudioClip errorSound;

	private InvGameItem mItem;

	private string mText = string.Empty;

	private static InvGameItem mDraggedItem;

	protected abstract InvGameItem observedItem { get; }

	protected abstract InvGameItem Replace(InvGameItem item);

	private void OnTooltip(bool show)
	{
		InvGameItem invGameItem = ((!show) ? null : mItem);
		if (invGameItem != null)
		{
			InvBaseItem baseItem = invGameItem.baseItem;
			if (baseItem != null)
			{
				string text = "[" + NGUIText.EncodeColor(invGameItem.color) + "]" + invGameItem.name + "[-]\n";
				string text2 = text;
				text = text2 + "[AFAFAF]Level " + invGameItem.itemLevel + " " + baseItem.slot;
				List<InvStat> list = invGameItem.CalculateStats();
				int i = 0;
				for (int count = list.Count; i < count; i++)
				{
					InvStat invStat = list[i];
					if (invStat.amount != 0)
					{
						text = ((invStat.amount >= 0) ? (text + "\n[00FF00]+" + invStat.amount) : (text + "\n[FF0000]" + invStat.amount));
						if (invStat.modifier == InvStat.Modifier.Percent)
						{
							text += "%";
						}
						text = text + " " + invStat.id;
						text += "[-]";
					}
				}
				if (!string.IsNullOrEmpty(baseItem.description))
				{
					text = text + "\n[FF9900]" + baseItem.description;
				}
				UITooltip.Show(text);
				return;
			}
		}
		UITooltip.Hide();
	}

	private void OnClick()
	{
		if (mDraggedItem != null)
		{
			OnDrop(null);
		}
		else if (mItem != null)
		{
			mDraggedItem = Replace(null);
			if (mDraggedItem != null)
			{
				NGUITools.PlaySound(grabSound);
			}
			UpdateCursor();
		}
	}

	private void OnDrag(Vector2 delta)
	{
		if (mDraggedItem == null && mItem != null)
		{
			UICamera.currentTouch.clickNotification = UICamera.ClickNotification.BasedOnDelta;
			mDraggedItem = Replace(null);
			NGUITools.PlaySound(grabSound);
			UpdateCursor();
		}
	}

	private void OnDrop(GameObject go)
	{
		InvGameItem invGameItem = Replace(mDraggedItem);
		if (mDraggedItem == invGameItem)
		{
			NGUITools.PlaySound(errorSound);
		}
		else if (invGameItem != null)
		{
			NGUITools.PlaySound(grabSound);
		}
		else
		{
			NGUITools.PlaySound(placeSound);
		}
		mDraggedItem = invGameItem;
		UpdateCursor();
	}

	private void UpdateCursor()
	{
		if (mDraggedItem != null && mDraggedItem.baseItem != null)
		{
			UICursor.Set(mDraggedItem.baseItem.iconAtlas, mDraggedItem.baseItem.iconName);
		}
		else
		{
			UICursor.Clear();
		}
	}

	private void Update()
	{
		InvGameItem invGameItem = observedItem;
		if (mItem == invGameItem)
		{
			return;
		}
		mItem = invGameItem;
		InvBaseItem invBaseItem = invGameItem?.baseItem;
		if (label != null)
		{
			string text = invGameItem?.name;
			if (string.IsNullOrEmpty(mText))
			{
				mText = label.text;
			}
			label.text = ((text == null) ? mText : text);
		}
		if (icon != null)
		{
			if (invBaseItem == null || invBaseItem.iconAtlas == null)
			{
				icon.enabled = false;
			}
			else
			{
				icon.atlas = invBaseItem.iconAtlas;
				icon.spriteName = invBaseItem.iconName;
				icon.enabled = true;
				icon.MakePixelPerfect();
			}
		}
		if (background != null)
		{
			background.color = invGameItem?.color ?? UnityEngine.Color.white;
		}
	}
}
[AddComponentMenu("NGUI/Examples/UI Item Storage")]
public class UIItemStorage : MonoBehaviour
{
	public int maxItemCount = 8;

	public int maxRows = 4;

	public int maxColumns = 4;

	public GameObject template;

	public UIWidget background;

	public int spacing = 128;

	public int padding = 10;

	private List<InvGameItem> mItems = new List<InvGameItem>();

	public List<InvGameItem> items
	{
		get
		{
			while (mItems.Count < maxItemCount)
			{
				mItems.Add(null);
			}
			return mItems;
		}
	}

	public InvGameItem GetItem(int slot)
	{
		return (slot >= items.Count) ? null : mItems[slot];
	}

	public InvGameItem Replace(int slot, InvGameItem item)
	{
		if (slot < maxItemCount)
		{
			InvGameItem result = items[slot];
			mItems[slot] = item;
			return result;
		}
		return item;
	}

	private void Start()
	{
		if (!(template != null))
		{
			return;
		}
		int num = 0;
		Bounds bounds = default(Bounds);
		for (int i = 0; i < maxRows; i++)
		{
			for (int j = 0; j < maxColumns; j++)
			{
				GameObject gameObject = NGUITools.AddChild(base.gameObject, template);
				Transform transform = gameObject.transform;
				transform.localPosition = new Vector3((float)padding + ((float)j + 0.5f) * (float)spacing, (float)(-padding) - ((float)i + 0.5f) * (float)spacing, 0f);
				UIStorageSlot component = gameObject.GetComponent<UIStorageSlot>();
				if (component != null)
				{
					component.storage = this;
					component.slot = num;
				}
				bounds.Encapsulate(new Vector3((float)padding * 2f + (float)((j + 1) * spacing), (float)(-padding) * 2f - (float)((i + 1) * spacing), 0f));
				if (++num >= maxItemCount)
				{
					if (background != null)
					{
						background.transform.localScale = bounds.size;
					}
					return;
				}
			}
		}
		if (background != null)
		{
			background.transform.localScale = bounds.size;
		}
	}
}
[AddComponentMenu("NGUI/Examples/UI Storage Slot")]
public class UIStorageSlot : UIItemSlot
{
	public UIItemStorage storage;

	public int slot;

	protected override InvGameItem observedItem => (!(storage != null)) ? null : storage.GetItem(slot);

	protected override InvGameItem Replace(InvGameItem item)
	{
		return (!(storage != null)) ? item : storage.Replace(slot, item);
	}
}
[AddComponentMenu("NGUI/Examples/Item Attachment Point")]
public class InvAttachmentPoint : MonoBehaviour
{
	public InvBaseItem.Slot slot;

	private GameObject mPrefab;

	private GameObject mChild;

	public GameObject Attach(GameObject prefab)
	{
		if (mPrefab != prefab)
		{
			mPrefab = prefab;
			if (mChild != null)
			{
				UnityEngine.Object.Destroy(mChild);
			}
			if (mPrefab != null)
			{
				Transform transform = base.transform;
				mChild = UnityEngine.Object.Instantiate(mPrefab, transform.position, transform.rotation);
				Transform transform2 = mChild.transform;
				transform2.parent = transform;
				transform2.localPosition = Vector3.zero;
				transform2.localRotation = Quaternion.identity;
				transform2.localScale = Vector3.one;
			}
		}
		return mChild;
	}
}
[Serializable]
public class InvBaseItem
{
	public enum Slot
	{
		None,
		Weapon,
		Shield,
		Body,
		Shoulders,
		Bracers,
		Boots,
		Trinket,
		_LastDoNotUse
	}

	public int id16;

	public string name;

	public string description;

	public Slot slot;

	public int minItemLevel = 1;

	public int maxItemLevel = 50;

	public List<InvStat> stats = new List<InvStat>();

	public GameObject attachment;

	public UnityEngine.Color color = UnityEngine.Color.white;

	public UIAtlas iconAtlas;

	public string iconName = string.Empty;
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/Examples/Item Database")]
public class InvDatabase : MonoBehaviour
{
	private static InvDatabase[] mList;

	private static bool mIsDirty = true;

	public int databaseID;

	public List<InvBaseItem> items = new List<InvBaseItem>();

	public UIAtlas iconAtlas;

	public static InvDatabase[] list
	{
		get
		{
			if (mIsDirty)
			{
				mIsDirty = false;
				mList = NGUITools.FindActive<InvDatabase>();
			}
			return mList;
		}
	}

	private void OnEnable()
	{
		mIsDirty = true;
	}

	private void OnDisable()
	{
		mIsDirty = true;
	}

	private InvBaseItem GetItem(int id16)
	{
		int i = 0;
		for (int count = items.Count; i < count; i++)
		{
			InvBaseItem invBaseItem = items[i];
			if (invBaseItem.id16 == id16)
			{
				return invBaseItem;
			}
		}
		return null;
	}

	private static InvDatabase GetDatabase(int dbID)
	{
		int i = 0;
		for (int num = list.Length; i < num; i++)
		{
			InvDatabase invDatabase = list[i];
			if (invDatabase.databaseID == dbID)
			{
				return invDatabase;
			}
		}
		return null;
	}

	public static InvBaseItem FindByID(int id32)
	{
		InvDatabase database = GetDatabase(id32 >> 16);
		return (!(database != null)) ? null : database.GetItem(id32 & 0xFFFF);
	}

	public static InvBaseItem FindByName(string exact)
	{
		int i = 0;
		for (int num = list.Length; i < num; i++)
		{
			InvDatabase invDatabase = list[i];
			int j = 0;
			for (int count = invDatabase.items.Count; j < count; j++)
			{
				InvBaseItem invBaseItem = invDatabase.items[j];
				if (invBaseItem.name == exact)
				{
					return invBaseItem;
				}
			}
		}
		return null;
	}

	public static int FindItemID(InvBaseItem item)
	{
		int i = 0;
		for (int num = list.Length; i < num; i++)
		{
			InvDatabase invDatabase = list[i];
			if (invDatabase.items.Contains(item))
			{
				return (invDatabase.databaseID << 16) | item.id16;
			}
		}
		return -1;
	}
}
[AddComponentMenu("NGUI/Examples/Equipment")]
public class InvEquipment : MonoBehaviour
{
	private InvGameItem[] mItems;

	private InvAttachmentPoint[] mAttachments;

	public InvGameItem[] equippedItems => mItems;

	public InvGameItem Replace(InvBaseItem.Slot slot, InvGameItem item)
	{
		InvBaseItem invBaseItem = item?.baseItem;
		if (slot != 0)
		{
			if (invBaseItem != null && invBaseItem.slot != slot)
			{
				return item;
			}
			if (mItems == null)
			{
				int num = 8;
				mItems = new InvGameItem[num];
			}
			InvGameItem result = mItems[(int)(slot - 1)];
			mItems[(int)(slot - 1)] = item;
			if (mAttachments == null)
			{
				mAttachments = GetComponentsInChildren<InvAttachmentPoint>();
			}
			int i = 0;
			for (int num2 = mAttachments.Length; i < num2; i++)
			{
				InvAttachmentPoint invAttachmentPoint = mAttachments[i];
				if (invAttachmentPoint.slot != slot)
				{
					continue;
				}
				GameObject gameObject = invAttachmentPoint.Attach(invBaseItem?.attachment);
				if (invBaseItem != null && gameObject != null)
				{
					Renderer component = gameObject.GetComponent<Renderer>();
					if (component != null)
					{
						component.material.color = invBaseItem.color;
					}
				}
			}
			return result;
		}
		if (item != null)
		{
			UnityEngine.Debug.LogWarning("Can't equip \"" + item.name + "\" because it doesn't specify an item slot");
		}
		return item;
	}

	public InvGameItem Equip(InvGameItem item)
	{
		if (item != null)
		{
			InvBaseItem baseItem = item.baseItem;
			if (baseItem != null)
			{
				return Replace(baseItem.slot, item);
			}
			UnityEngine.Debug.LogWarning("Can't resolve the item ID of " + item.baseItemID);
		}
		return item;
	}

	public InvGameItem Unequip(InvGameItem item)
	{
		if (item != null)
		{
			InvBaseItem baseItem = item.baseItem;
			if (baseItem != null)
			{
				return Replace(baseItem.slot, null);
			}
		}
		return item;
	}

	public InvGameItem Unequip(InvBaseItem.Slot slot)
	{
		return Replace(slot, null);
	}

	public bool HasEquipped(InvGameItem item)
	{
		if (mItems != null)
		{
			int i = 0;
			for (int num = mItems.Length; i < num; i++)
			{
				if (mItems[i] == item)
				{
					return true;
				}
			}
		}
		return false;
	}

	public bool HasEquipped(InvBaseItem.Slot slot)
	{
		if (mItems != null)
		{
			int i = 0;
			for (int num = mItems.Length; i < num; i++)
			{
				InvBaseItem baseItem = mItems[i].baseItem;
				if (baseItem != null && baseItem.slot == slot)
				{
					return true;
				}
			}
		}
		return false;
	}

	public InvGameItem GetItem(InvBaseItem.Slot slot)
	{
		if (slot != 0)
		{
			int num = (int)(slot - 1);
			if (mItems != null && num < mItems.Length)
			{
				return mItems[num];
			}
		}
		return null;
	}
}
[Serializable]
public class InvGameItem
{
	public enum Quality
	{
		Broken,
		Cursed,
		Damaged,
		Worn,
		Sturdy,
		Polished,
		Improved,
		Crafted,
		Superior,
		Enchanted,
		Epic,
		Legendary,
		_LastDoNotUse
	}

	[SerializeField]
	private int mBaseItemID;

	public Quality quality = Quality.Sturdy;

	public int itemLevel = 1;

	private InvBaseItem mBaseItem;

	public int baseItemID => mBaseItemID;

	public InvBaseItem baseItem
	{
		get
		{
			if (mBaseItem == null)
			{
				mBaseItem = InvDatabase.FindByID(baseItemID);
			}
			return mBaseItem;
		}
	}

	public string name
	{
		get
		{
			if (baseItem == null)
			{
				return null;
			}
			return quality.ToString() + " " + baseItem.name;
		}
	}

	public float statMultiplier
	{
		get
		{
			float num = 0f;
			switch (quality)
			{
			case Quality.Cursed:
				num = -1f;
				break;
			case Quality.Broken:
				num = 0f;
				break;
			case Quality.Damaged:
				num = 0.25f;
				break;
			case Quality.Worn:
				num = 0.9f;
				break;
			case Quality.Sturdy:
				num = 1f;
				break;
			case Quality.Polished:
				num = 1.1f;
				break;
			case Quality.Improved:
				num = 1.25f;
				break;
			case Quality.Crafted:
				num = 1.5f;
				break;
			case Quality.Superior:
				num = 1.75f;
				break;
			case Quality.Enchanted:
				num = 2f;
				break;
			case Quality.Epic:
				num = 2.5f;
				break;
			case Quality.Legendary:
				num = 3f;
				break;
			}
			float num2 = (float)itemLevel / 50f;
			return num * Mathf.Lerp(num2, num2 * num2, 0.5f);
		}
	}

	public UnityEngine.Color color
	{
		get
		{
			UnityEngine.Color result = UnityEngine.Color.white;
			switch (quality)
			{
			case Quality.Cursed:
				result = UnityEngine.Color.red;
				break;
			case Quality.Broken:
				result = new UnityEngine.Color(0.4f, 0.2f, 0.2f);
				break;
			case Quality.Damaged:
				result = new UnityEngine.Color(0.4f, 0.4f, 0.4f);
				break;
			case Quality.Worn:
				result = new UnityEngine.Color(0.7f, 0.7f, 0.7f);
				break;
			case Quality.Sturdy:
				result = new UnityEngine.Color(1f, 1f, 1f);
				break;
			case Quality.Polished:
				result = NGUIMath.HexToColor(3774856959u);
				break;
			case Quality.Improved:
				result = NGUIMath.HexToColor(2480359935u);
				break;
			case Quality.Crafted:
				result = NGUIMath.HexToColor(1325334783u);
				break;
			case Quality.Superior:
				result = NGUIMath.HexToColor(12255231u);
				break;
			case Quality.Enchanted:
				result = NGUIMath.HexToColor(1937178111u);
				break;
			case Quality.Epic:
				result = NGUIMath.HexToColor(2516647935u);
				break;
			case Quality.Legendary:
				result = NGUIMath.HexToColor(4287627519u);
				break;
			}
			return result;
		}
	}

	public InvGameItem(int id)
	{
		mBaseItemID = id;
	}

	public InvGameItem(int id, InvBaseItem bi)
	{
		mBaseItemID = id;
		mBaseItem = bi;
	}

	public List<InvStat> CalculateStats()
	{
		List<InvStat> list = new List<InvStat>();
		if (baseItem != null)
		{
			float num = statMultiplier;
			List<InvStat> stats = baseItem.stats;
			int i = 0;
			for (int count = stats.Count; i < count; i++)
			{
				InvStat invStat = stats[i];
				int num2 = Mathf.RoundToInt(num * (float)invStat.amount);
				if (num2 == 0)
				{
					continue;
				}
				bool flag = false;
				int j = 0;
				for (int count2 = list.Count; j < count2; j++)
				{
					InvStat invStat2 = list[j];
					if (invStat2.id == invStat.id && invStat2.modifier == invStat.modifier)
					{
						invStat2.amount += num2;
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					InvStat invStat3 = new InvStat();
					invStat3.id = invStat.id;
					invStat3.amount = num2;
					invStat3.modifier = invStat.modifier;
					list.Add(invStat3);
				}
			}
			list.Sort(InvStat.CompareArmor);
		}
		return list;
	}
}
[Serializable]
public class InvStat
{
	public enum Identifier
	{
		Strength,
		Constitution,
		Agility,
		Intelligence,
		Damage,
		Crit,
		Armor,
		Health,
		Mana,
		Other
	}

	public enum Modifier
	{
		Added,
		Percent
	}

	public Identifier id;

	public Modifier modifier;

	public int amount;

	public static string GetName(Identifier i)
	{
		return i.ToString();
	}

	public static string GetDescription(Identifier i)
	{
		return i switch
		{
			Identifier.Strength => "Strength increases melee damage", 
			Identifier.Constitution => "Constitution increases health", 
			Identifier.Agility => "Agility increases armor", 
			Identifier.Intelligence => "Intelligence increases mana", 
			Identifier.Damage => "Damage adds to the amount of damage done in combat", 
			Identifier.Crit => "Crit increases the chance of landing a critical strike", 
			Identifier.Armor => "Armor protects from damage", 
			Identifier.Health => "Health prolongs life", 
			Identifier.Mana => "Mana increases the number of spells that can be cast", 
			_ => null, 
		};
	}

	public static int CompareArmor(InvStat a, InvStat b)
	{
		int num = (int)a.id;
		int num2 = (int)b.id;
		if (a.id == Identifier.Armor)
		{
			num -= 10000;
		}
		else if (a.id == Identifier.Damage)
		{
			num -= 5000;
		}
		if (b.id == Identifier.Armor)
		{
			num2 -= 10000;
		}
		else if (b.id == Identifier.Damage)
		{
			num2 -= 5000;
		}
		if (a.amount < 0)
		{
			num += 1000;
		}
		if (b.amount < 0)
		{
			num2 += 1000;
		}
		if (a.modifier == Modifier.Percent)
		{
			num += 100;
		}
		if (b.modifier == Modifier.Percent)
		{
			num2 += 100;
		}
		if (num < num2)
		{
			return -1;
		}
		if (num > num2)
		{
			return 1;
		}
		return 0;
	}

	public static int CompareWeapon(InvStat a, InvStat b)
	{
		int num = (int)a.id;
		int num2 = (int)b.id;
		if (a.id == Identifier.Damage)
		{
			num -= 10000;
		}
		else if (a.id == Identifier.Armor)
		{
			num -= 5000;
		}
		if (b.id == Identifier.Damage)
		{
			num2 -= 10000;
		}
		else if (b.id == Identifier.Armor)
		{
			num2 -= 5000;
		}
		if (a.amount < 0)
		{
			num += 1000;
		}
		if (b.amount < 0)
		{
			num2 += 1000;
		}
		if (a.modifier == Modifier.Percent)
		{
			num += 100;
		}
		if (b.modifier == Modifier.Percent)
		{
			num2 += 100;
		}
		if (num < num2)
		{
			return -1;
		}
		if (num > num2)
		{
			return 1;
		}
		return 0;
	}
}
[RequireComponent(typeof(UIInput))]
[AddComponentMenu("NGUI/Examples/Chat Input")]
public class ChatInput : MonoBehaviour
{
	public UITextList textList;

	public bool fillWithDummyData;

	private UIInput mInput;

	private void Start()
	{
		mInput = GetComponent<UIInput>();
		mInput.label.maxLineCount = 1;
		if (fillWithDummyData && textList != null)
		{
			for (int i = 0; i < 30; i++)
			{
				textList.Add(((i % 2 != 0) ? "[AAAAAA]" : "[FFFFFF]") + "This is an example paragraph for the text list, testing line " + i + "[-]");
			}
		}
	}

	public void OnSubmit()
	{
		if (textList != null)
		{
			string text = NGUIText.StripSymbols(mInput.value);
			if (!string.IsNullOrEmpty(text))
			{
				textList.Add(text);
				mInput.value = string.Empty;
				mInput.isSelected = false;
			}
		}
	}
}
[RequireComponent(typeof(UITexture))]
public class DownloadTexture : MonoBehaviour
{
	public string url = "http://www.yourwebsite.com/logo.png";

	public bool pixelPerfect = true;

	private Texture2D mTex;

	private IEnumerator Start()
	{
		WWW www = new WWW(url);
		yield return www;
		mTex = www.texture;
		if (mTex != null)
		{
			UITexture component = GetComponent<UITexture>();
			component.mainTexture = mTex;
			if (pixelPerfect)
			{
				component.MakePixelPerfect();
			}
		}
		www.Dispose();
	}

	private void OnDestroy()
	{
		if (mTex != null)
		{
			UnityEngine.Object.Destroy(mTex);
		}
	}
}
[RequireComponent(typeof(UIWidget))]
[AddComponentMenu("NGUI/Examples/Envelop Content")]
public class EnvelopContent : MonoBehaviour
{
	public Transform targetRoot;

	public int padLeft;

	public int padRight;

	public int padBottom;

	public int padTop;

	private bool mStarted;

	private void Start()
	{
		mStarted = true;
		Execute();
	}

	private void OnEnable()
	{
		if (mStarted)
		{
			Execute();
		}
	}

	[ContextMenu("Execute")]
	public void Execute()
	{
		if (targetRoot == base.transform)
		{
			UnityEngine.Debug.LogError("Target Root object cannot be the same object that has Envelop Content. Make it a sibling instead.", this);
			return;
		}
		if (NGUITools.IsChild(targetRoot, base.transform))
		{
			UnityEngine.Debug.LogError("Target Root object should not be a parent of Envelop Content. Make it a sibling instead.", this);
			return;
		}
		Bounds bounds = NGUIMath.CalculateRelativeWidgetBounds(base.transform.parent, targetRoot, considerInactive: false);
		float num = bounds.min.x + (float)padLeft;
		float num2 = bounds.min.y + (float)padBottom;
		float num3 = bounds.max.x + (float)padRight;
		float num4 = bounds.max.y + (float)padTop;
		UIWidget component = GetComponent<UIWidget>();
		component.SetRect(num, num2, num3 - num, num4 - num2);
		BroadcastMessage("UpdateAnchors", SendMessageOptions.DontRequireReceiver);
	}
}
[AddComponentMenu("NGUI/Examples/Drag and Drop Item (Example)")]
public class ExampleDragDropItem : UIDragDropItem
{
	public GameObject prefab;

	protected override void OnDragDropRelease(GameObject surface)
	{
		if (surface != null)
		{
			ExampleDragDropSurface component = surface.GetComponent<ExampleDragDropSurface>();
			if (component != null)
			{
				GameObject gameObject = NGUITools.AddChild(component.gameObject, prefab);
				gameObject.transform.localScale = component.transform.localScale;
				Transform transform = gameObject.transform;
				transform.position = UICamera.lastWorldPosition;
				if (component.rotatePlacedObject)
				{
					transform.rotation = Quaternion.LookRotation(UICamera.lastHit.normal) * Quaternion.Euler(90f, 0f, 0f);
				}
				NGUITools.Destroy(base.gameObject);
				return;
			}
		}
		base.OnDragDropRelease(surface);
	}
}
[AddComponentMenu("NGUI/Examples/Drag and Drop Surface (Example)")]
public class ExampleDragDropSurface : MonoBehaviour
{
	public bool rotatePlacedObject;
}
[AddComponentMenu("NGUI/Examples/Lag Position")]
public class LagPosition : MonoBehaviour
{
	public Vector3 speed = new Vector3(10f, 10f, 10f);

	public bool ignoreTimeScale;

	private Transform mTrans;

	private Vector3 mRelative;

	private Vector3 mAbsolute;

	public void OnRepositionEnd()
	{
		Interpolate(1000f);
	}

	private void Interpolate(float delta)
	{
		Transform parent = mTrans.parent;
		if (parent != null)
		{
			Vector3 vector = parent.position + parent.rotation * mRelative;
			mAbsolute.x = Mathf.Lerp(mAbsolute.x, vector.x, Mathf.Clamp01(delta * speed.x));
			mAbsolute.y = Mathf.Lerp(mAbsolute.y, vector.y, Mathf.Clamp01(delta * speed.y));
			mAbsolute.z = Mathf.Lerp(mAbsolute.z, vector.z, Mathf.Clamp01(delta * speed.z));
			mTrans.position = mAbsolute;
		}
	}

	private void OnEnable()
	{
		mTrans = base.transform;
		mAbsolute = mTrans.position;
		mRelative = mTrans.localPosition;
	}

	private void Update()
	{
		Interpolate((!ignoreTimeScale) ? Time.deltaTime : RealTime.deltaTime);
	}
}
[AddComponentMenu("NGUI/Examples/Lag Rotation")]
public class LagRotation : MonoBehaviour
{
	public float speed = 10f;

	public bool ignoreTimeScale;

	private Transform mTrans;

	private Quaternion mRelative;

	private Quaternion mAbsolute;

	public void OnRepositionEnd()
	{
		Interpolate(1000f);
	}

	private void Interpolate(float delta)
	{
		Transform parent = mTrans.parent;
		if (parent != null)
		{
			mAbsolute = Quaternion.Slerp(mAbsolute, parent.rotation * mRelative, delta * speed);
			mTrans.rotation = mAbsolute;
		}
	}

	private void OnEnable()
	{
		mTrans = base.transform;
		mRelative = mTrans.localRotation;
		mAbsolute = mTrans.rotation;
	}

	private void Update()
	{
		Interpolate((!ignoreTimeScale) ? Time.deltaTime : RealTime.deltaTime);
	}
}
[AddComponentMenu("NGUI/Examples/Load Level On Click")]
public class LoadLevelOnClick : MonoBehaviour
{
	public string levelName;

	private void OnClick()
	{
		if (!string.IsNullOrEmpty(levelName))
		{
			SceneManager.LoadScene(levelName);
		}
	}
}
[AddComponentMenu("NGUI/Examples/Look At Target")]
public class LookAtTarget : MonoBehaviour
{
	public int level;

	public Transform target;

	public float speed = 8f;

	private Transform mTrans;

	private void Start()
	{
		mTrans = base.transform;
	}

	private void LateUpdate()
	{
		if (target != null)
		{
			Vector3 forward = target.position - mTrans.position;
			float magnitude = forward.magnitude;
			if (magnitude > 0.001f)
			{
				Quaternion b = Quaternion.LookRotation(forward);
				mTrans.rotation = Quaternion.Slerp(mTrans.rotation, b, Mathf.Clamp01(speed * Time.deltaTime));
			}
		}
	}
}
public class OpenURLOnClick : MonoBehaviour
{
	private void OnClick()
	{
		UILabel component = GetComponent<UILabel>();
		if (component != null)
		{
			string urlAtPosition = component.GetUrlAtPosition(UICamera.lastWorldPosition);
			if (!string.IsNullOrEmpty(urlAtPosition))
			{
				Application.OpenURL(urlAtPosition);
			}
		}
	}
}
[AddComponentMenu("NGUI/Examples/Pan With Mouse")]
public class PanWithMouse : MonoBehaviour
{
	public Vector2 degrees = new Vector2(5f, 3f);

	public float range = 1f;

	private Transform mTrans;

	private Quaternion mStart;

	private Vector2 mRot = Vector2.zero;

	private void Start()
	{
		mTrans = base.transform;
		mStart = mTrans.localRotation;
	}

	private void Update()
	{
		float deltaTime = RealTime.deltaTime;
		Vector3 mousePosition = Input.mousePosition;
		float num = (float)Screen.width * 0.5f;
		float num2 = (float)Screen.height * 0.5f;
		if (range < 0.1f)
		{
			range = 0.1f;
		}
		float x = Mathf.Clamp((mousePosition.x - num) / num / range, -1f, 1f);
		float y = Mathf.Clamp((mousePosition.y - num2) / num2 / range, -1f, 1f);
		mRot = Vector2.Lerp(mRot, new Vector2(x, y), deltaTime * 5f);
		mTrans.localRotation = mStart * Quaternion.Euler((0f - mRot.y) * degrees.y, mRot.x * degrees.x, 0f);
	}
}
[AddComponentMenu("NGUI/Examples/Play Idle Animations")]
public class PlayIdleAnimations : MonoBehaviour
{
	private Animation mAnim;

	private AnimationClip mIdle;

	private List<AnimationClip> mBreaks = new List<AnimationClip>();

	private float mNextBreak;

	private int mLastIndex;

	private void Start()
	{
		mAnim = GetComponentInChildren<Animation>();
		if (mAnim == null)
		{
			UnityEngine.Debug.LogWarning(NGUITools.GetHierarchy(base.gameObject) + " has no Animation component");
			UnityEngine.Object.Destroy(this);
			return;
		}
		foreach (AnimationState item in mAnim)
		{
			if (item.clip.name == "idle")
			{
				item.layer = 0;
				mIdle = item.clip;
				mAnim.Play(mIdle.name);
			}
			else if (item.clip.name.StartsWith("idle"))
			{
				item.layer = 1;
				mBreaks.Add(item.clip);
			}
		}
		if (mBreaks.Count == 0)
		{
			UnityEngine.Object.Destroy(this);
		}
	}

	private void Update()
	{
		if (!(mNextBreak < Time.time))
		{
			return;
		}
		if (mBreaks.Count == 1)
		{
			AnimationClip animationClip = mBreaks[0];
			mNextBreak = Time.time + animationClip.length + UnityEngine.Random.Range(5f, 15f);
			mAnim.CrossFade(animationClip.name);
			return;
		}
		int num = UnityEngine.Random.Range(0, mBreaks.Count - 1);
		if (mLastIndex == num)
		{
			num++;
			if (num >= mBreaks.Count)
			{
				num = 0;
			}
		}
		mLastIndex = num;
		AnimationClip animationClip2 = mBreaks[num];
		mNextBreak = Time.time + animationClip2.length + UnityEngine.Random.Range(2f, 8f);
		mAnim.CrossFade(animationClip2.name);
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(UIWidget))]
[AddComponentMenu("NGUI/Examples/Set Color on Selection")]
public class SetColorOnSelection : MonoBehaviour
{
	private UIWidget mWidget;

	public void SetSpriteBySelection()
	{
		if (!(UIPopupList.current == null))
		{
			if (mWidget == null)
			{
				mWidget = GetComponent<UIWidget>();
			}
			switch (UIPopupList.current.value)
			{
			case "White":
				mWidget.color = UnityEngine.Color.white;
				break;
			case "Red":
				mWidget.color = UnityEngine.Color.red;
				break;
			case "Green":
				mWidget.color = UnityEngine.Color.green;
				break;
			case "Blue":
				mWidget.color = UnityEngine.Color.blue;
				break;
			case "Yellow":
				mWidget.color = UnityEngine.Color.yellow;
				break;
			case "Cyan":
				mWidget.color = UnityEngine.Color.cyan;
				break;
			case "Magenta":
				mWidget.color = UnityEngine.Color.magenta;
				break;
			}
		}
	}
}
[AddComponentMenu("NGUI/Examples/Spin")]
public class Spin : MonoBehaviour
{
	public Vector3 rotationsPerSecond = new Vector3(0f, 0.1f, 0f);

	public bool ignoreTimeScale;

	private Rigidbody mRb;

	private Transform mTrans;

	private void Start()
	{
		mTrans = base.transform;
		mRb = GetComponent<Rigidbody>();
	}

	private void Update()
	{
		if (mRb == null)
		{
			ApplyDelta((!ignoreTimeScale) ? Time.deltaTime : RealTime.deltaTime);
		}
	}

	private void FixedUpdate()
	{
		if (mRb != null)
		{
			ApplyDelta(Time.deltaTime);
		}
	}

	public void ApplyDelta(float delta)
	{
		delta *= 360f;
		Quaternion quaternion = Quaternion.Euler(rotationsPerSecond * delta);
		if (mRb == null)
		{
			mTrans.rotation *= quaternion;
		}
		else
		{
			mRb.MoveRotation(mRb.rotation * quaternion);
		}
	}
}
[AddComponentMenu("NGUI/Examples/Spin With Mouse")]
public class SpinWithMouse : MonoBehaviour
{
	public Transform target;

	public float speed = 1f;

	private Transform mTrans;

	private void Start()
	{
		mTrans = base.transform;
	}

	private void OnDrag(Vector2 delta)
	{
		UICamera.currentTouch.clickNotification = UICamera.ClickNotification.None;
		if (target != null)
		{
			target.localRotation = Quaternion.Euler(0f, -0.5f * delta.x * speed, 0f) * target.localRotation;
		}
		else
		{
			mTrans.localRotation = Quaternion.Euler(0f, -0.5f * delta.x * speed, 0f) * mTrans.localRotation;
		}
	}
}
public class Tutorial5 : MonoBehaviour
{
	public void SetDurationToCurrentProgress()
	{
		UITweener[] componentsInChildren = GetComponentsInChildren<UITweener>();
		UITweener[] array = componentsInChildren;
		foreach (UITweener uITweener in array)
		{
			uITweener.duration = Mathf.Lerp(2f, 0.5f, UIProgressBar.current.value);
		}
	}
}
[AddComponentMenu("NGUI/Examples/Slider Colors")]
public class UISliderColors : MonoBehaviour
{
	public UISprite sprite;

	public UnityEngine.Color[] colors = new UnityEngine.Color[3]
	{
		UnityEngine.Color.red,
		UnityEngine.Color.yellow,
		UnityEngine.Color.green
	};

	private UIProgressBar mBar;

	private UIBasicSprite mSprite;

	private void Start()
	{
		mBar = GetComponent<UIProgressBar>();
		mSprite = GetComponent<UIBasicSprite>();
		Update();
	}

	private void Update()
	{
		if (sprite == null || colors.Length == 0)
		{
			return;
		}
		float num = ((!(mBar != null)) ? mSprite.fillAmount : mBar.value);
		num *= (float)(colors.Length - 1);
		int num2 = Mathf.FloorToInt(num);
		UnityEngine.Color color = colors[0];
		if (num2 >= 0)
		{
			if (num2 + 1 >= colors.Length)
			{
				color = ((num2 >= colors.Length) ? colors[colors.Length - 1] : colors[num2]);
			}
			else
			{
				float t = num - (float)num2;
				color = UnityEngine.Color.Lerp(colors[num2], colors[num2 + 1], t);
			}
		}
		color.a = sprite.color.a;
		sprite.color = color;
	}
}
[AddComponentMenu("NGUI/Examples/Window Auto-Yaw")]
public class WindowAutoYaw : MonoBehaviour
{
	public int updateOrder;

	public Camera uiCamera;

	public float yawAmount = 20f;

	private Transform mTrans;

	private void OnDisable()
	{
		mTrans.localRotation = Quaternion.identity;
	}

	private void OnEnable()
	{
		if (uiCamera == null)
		{
			uiCamera = NGUITools.FindCameraForLayer(base.gameObject.layer);
		}
		mTrans = base.transform;
	}

	private void Update()
	{
		if (uiCamera != null)
		{
			Vector3 vector = uiCamera.WorldToViewportPoint(mTrans.position);
			mTrans.localRotation = Quaternion.Euler(0f, (vector.x * 2f - 1f) * yawAmount, 0f);
		}
	}
}
[AddComponentMenu("NGUI/Examples/Window Drag Tilt")]
public class WindowDragTilt : MonoBehaviour
{
	public int updateOrder;

	public float degrees = 30f;

	private Vector3 mLastPos;

	private Transform mTrans;

	private float mAngle;

	private void OnEnable()
	{
		mTrans = base.transform;
		mLastPos = mTrans.position;
	}

	private void Update()
	{
		Vector3 vector = mTrans.position - mLastPos;
		mLastPos = mTrans.position;
		mAngle += vector.x * degrees;
		mAngle = NGUIMath.SpringLerp(mAngle, 0f, 20f, Time.deltaTime);
		mTrans.localRotation = Quaternion.Euler(0f, 0f, 0f - mAngle);
	}
}
[RequireComponent(typeof(UIPopupList))]
[AddComponentMenu("NGUI/Interaction/Language Selection")]
public class LanguageSelection : MonoBehaviour
{
	private UIPopupList mList;

	private void Start()
	{
		mList = GetComponent<UIPopupList>();
		if (Localization.knownLanguages != null)
		{
			mList.items.Clear();
			int i = 0;
			for (int num = Localization.knownLanguages.Length; i < num; i++)
			{
				mList.items.Add(Localization.knownLanguages[i]);
			}
			mList.value = Localization.language;
		}
		EventDelegate.Add(mList.onChange, OnChange);
	}

	private void OnChange()
	{
		Localization.language = UIPopupList.current.value;
	}
}
[RequireComponent(typeof(UILabel))]
[AddComponentMenu("NGUI/Interaction/Typewriter Effect")]
public class TypewriterEffect : MonoBehaviour
{
	private struct FadeEntry
	{
		public int index;

		public string text;

		public float alpha;
	}

	public static TypewriterEffect current;

	public int charsPerSecond = 20;

	public float fadeInTime;

	public float delayOnPeriod;

	public float delayOnNewLine;

	public UIScrollView scrollView;

	public bool keepFullDimensions;

	public List<EventDelegate> onFinished = new List<EventDelegate>();

	private UILabel mLabel;

	private string mFullText = string.Empty;

	private int mCurrentOffset;

	private float mNextChar;

	private bool mReset = true;

	private bool mActive;

	private BetterList<FadeEntry> mFade = new BetterList<FadeEntry>();

	public bool isActive => mActive;

	public void ResetToBeginning()
	{
		Finish();
		mReset = true;
		mActive = true;
		mNextChar = 0f;
		mCurrentOffset = 0;
	}

	public void Finish()
	{
		if (mActive)
		{
			mActive = false;
			if (!mReset)
			{
				mCurrentOffset = mFullText.Length;
				mFade.Clear();
				mLabel.text = mFullText;
			}
			if (keepFullDimensions && scrollView != null)
			{
				scrollView.UpdatePosition();
			}
			current = this;
			EventDelegate.Execute(onFinished);
			current = null;
		}
	}

	private void OnEnable()
	{
		mReset = true;
		mActive = true;
	}

	private void Update()
	{
		if (!mActive)
		{
			return;
		}
		if (mReset)
		{
			mCurrentOffset = 0;
			mReset = false;
			mLabel = GetComponent<UILabel>();
			mFullText = mLabel.processedText;
			mFade.Clear();
			if (keepFullDimensions && scrollView != null)
			{
				scrollView.UpdatePosition();
			}
		}
		while (mCurrentOffset < mFullText.Length && mNextChar <= RealTime.time)
		{
			int num = mCurrentOffset;
			charsPerSecond = Mathf.Max(1, charsPerSecond);
			while (NGUIText.ParseSymbol(mFullText, ref mCurrentOffset))
			{
			}
			mCurrentOffset++;
			if (mCurrentOffset >= mFullText.Length)
			{
				break;
			}
			float num2 = 1f / (float)charsPerSecond;
			char c = ((num >= mFullText.Length) ? '\n' : mFullText[num]);
			if (c == '\n')
			{
				num2 += delayOnNewLine;
			}
			else if (num + 1 == mFullText.Length || mFullText[num + 1] <= ' ')
			{
				switch (c)
				{
				case '.':
					if (num + 2 < mFullText.Length && mFullText[num + 1] == '.' && mFullText[num + 2] == '.')
					{
						num2 += delayOnPeriod * 3f;
						num += 2;
					}
					else
					{
						num2 += delayOnPeriod;
					}
					break;
				case '!':
				case '?':
					num2 += delayOnPeriod;
					break;
				}
			}
			if (mNextChar == 0f)
			{
				mNextChar = RealTime.time + num2;
			}
			else
			{
				mNextChar += num2;
			}
			if (fadeInTime != 0f)
			{
				FadeEntry item = default(FadeEntry);
				item.index = num;
				item.alpha = 0f;
				item.text = mFullText.Substring(num, mCurrentOffset - num);
				mFade.Add(item);
			}
			else
			{
				mLabel.text = ((!keepFullDimensions) ? mFullText.Substring(0, mCurrentOffset) : (mFullText.Substring(0, mCurrentOffset) + "[00]" + mFullText.Substring(mCurrentOffset)));
				if (!keepFullDimensions && scrollView != null)
				{
					scrollView.UpdatePosition();
				}
			}
		}
		if (mFade.size != 0)
		{
			int num3 = 0;
			while (num3 < mFade.size)
			{
				FadeEntry value = mFade[num3];
				value.alpha += RealTime.deltaTime / fadeInTime;
				if (value.alpha < 1f)
				{
					mFade[num3] = value;
					num3++;
				}
				else
				{
					mFade.RemoveAt(num3);
				}
			}
			if (mFade.size == 0)
			{
				if (keepFullDimensions)
				{
					mLabel.text = mFullText.Substring(0, mCurrentOffset) + "[00]" + mFullText.Substring(mCurrentOffset);
				}
				else
				{
					mLabel.text = mFullText.Substring(0, mCurrentOffset);
				}
				return;
			}
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < mFade.size; i++)
			{
				FadeEntry fadeEntry = mFade[i];
				if (i == 0)
				{
					stringBuilder.Append(mFullText.Substring(0, fadeEntry.index));
				}
				stringBuilder.Append('[');
				stringBuilder.Append(NGUIText.EncodeAlpha(fadeEntry.alpha));
				stringBuilder.Append(']');
				stringBuilder.Append(fadeEntry.text);
			}
			if (keepFullDimensions)
			{
				stringBuilder.Append("[00]");
				stringBuilder.Append(mFullText.Substring(mCurrentOffset));
			}
			mLabel.text = stringBuilder.ToString();
		}
		else if (mCurrentOffset == mFullText.Length)
		{
			current = this;
			EventDelegate.Execute(onFinished);
			current = null;
			mActive = false;
		}
	}
}
[AddComponentMenu("NGUI/Interaction/Button")]
public class UIButton : UIButtonColor
{
	public static UIButton current;

	public bool dragHighlight;

	public string hoverSprite;

	public string pressedSprite;

	public string disabledSprite;

	public Sprite hoverSprite2D;

	public Sprite pressedSprite2D;

	public Sprite disabledSprite2D;

	public bool pixelSnap;

	public List<EventDelegate> onClick = new List<EventDelegate>();

	[NonSerialized]
	private UISprite mSprite;

	[NonSerialized]
	private UI2DSprite mSprite2D;

	[NonSerialized]
	private string mNormalSprite;

	[NonSerialized]
	private Sprite mNormalSprite2D;

	public override bool isEnabled
	{
		get
		{
			if (!base.enabled)
			{
				return false;
			}
			Collider component = GetComponent<Collider>();
			if ((bool)component && component.enabled)
			{
				return true;
			}
			Collider2D component2 = GetComponent<Collider2D>();
			return (bool)component2 && component2.enabled;
		}
		set
		{
			if (isEnabled == value)
			{
				return;
			}
			Collider component = GetComponent<Collider>();
			if (component != null)
			{
				component.enabled = value;
				SetState((!value) ? State.Disabled : State.Normal, immediate: false);
				return;
			}
			Collider2D component2 = GetComponent<Collider2D>();
			if (component2 != null)
			{
				component2.enabled = value;
				SetState((!value) ? State.Disabled : State.Normal, immediate: false);
			}
			else
			{
				base.enabled = value;
			}
		}
	}

	public string normalSprite
	{
		get
		{
			if (!mInitDone)
			{
				OnInit();
			}
			return mNormalSprite;
		}
		set
		{
			if (mSprite != null && !string.IsNullOrEmpty(mNormalSprite) && mNormalSprite == mSprite.spriteName)
			{
				mNormalSprite = value;
				SetSprite(value);
				NGUITools.SetDirty(mSprite);
				return;
			}
			mNormalSprite = value;
			if (mState == State.Normal)
			{
				SetSprite(value);
			}
		}
	}

	public Sprite normalSprite2D
	{
		get
		{
			if (!mInitDone)
			{
				OnInit();
			}
			return mNormalSprite2D;
		}
		set
		{
			if (mSprite2D != null && mNormalSprite2D == mSprite2D.sprite2D)
			{
				mNormalSprite2D = value;
				SetSprite(value);
				NGUITools.SetDirty(mSprite);
				return;
			}
			mNormalSprite2D = value;
			if (mState == State.Normal)
			{
				SetSprite(value);
			}
		}
	}

	protected override void OnInit()
	{
		base.OnInit();
		mSprite = mWidget as UISprite;
		mSprite2D = mWidget as UI2DSprite;
		if (mSprite != null)
		{
			mNormalSprite = mSprite.spriteName;
		}
		if (mSprite2D != null)
		{
			mNormalSprite2D = mSprite2D.sprite2D;
		}
	}

	protected override void OnEnable()
	{
		if (isEnabled)
		{
			if (mInitDone)
			{
				if (UICamera.currentScheme == UICamera.ControlScheme.Controller)
				{
					OnHover(UICamera.selectedObject == gameObject);
				}
				else if (UICamera.currentScheme == UICamera.ControlScheme.Mouse)
				{
					OnHover(UICamera.hoveredObject == gameObject);
				}
				else
				{
					SetState(State.Normal, immediate: false);
				}
			}
		}
		else
		{
			SetState(State.Disabled, immediate: true);
		}
	}

	protected override void OnDragOver()
	{
		if (isEnabled && (dragHighlight || UICamera.currentTouch.pressed == gameObject))
		{
			base.OnDragOver();
		}
	}

	protected override void OnDragOut()
	{
		if (isEnabled && (dragHighlight || UICamera.currentTouch.pressed == gameObject))
		{
			base.OnDragOut();
		}
	}

	protected virtual void OnClick()
	{
		if (current == null && isEnabled)
		{
			current = this;
			EventDelegate.Execute(onClick);
			current = null;
		}
	}

	public override void SetState(State state, bool immediate)
	{
		base.SetState(state, immediate);
		if (mSprite != null)
		{
			switch (state)
			{
			case State.Normal:
				SetSprite(mNormalSprite);
				break;
			case State.Hover:
				SetSprite((!string.IsNullOrEmpty(hoverSprite)) ? hoverSprite : mNormalSprite);
				break;
			case State.Pressed:
				SetSprite(pressedSprite);
				break;
			case State.Disabled:
				SetSprite(disabledSprite);
				break;
			}
		}
		else if (mSprite2D != null)
		{
			switch (state)
			{
			case State.Normal:
				SetSprite(mNormalSprite2D);
				break;
			case State.Hover:
				SetSprite((!(hoverSprite2D == null)) ? hoverSprite2D : mNormalSprite2D);
				break;
			case State.Pressed:
				SetSprite(pressedSprite2D);
				break;
			case State.Disabled:
				SetSprite(disabledSprite2D);
				break;
			}
		}
	}

	protected void SetSprite(string sp)
	{
		if (mSprite != null && !string.IsNullOrEmpty(sp) && mSprite.spriteName != sp)
		{
			mSprite.spriteName = sp;
			if (pixelSnap)
			{
				mSprite.MakePixelPerfect();
			}
		}
	}

	protected void SetSprite(Sprite sp)
	{
		if (sp != null && mSprite2D != null && mSprite2D.sprite2D != sp)
		{
			mSprite2D.sprite2D = sp;
			if (pixelSnap)
			{
				mSprite2D.MakePixelPerfect();
			}
		}
	}
}
[AddComponentMenu("NGUI/Interaction/Button Activate")]
public class UIButtonActivate : MonoBehaviour
{
	public GameObject target;

	public bool state = true;

	private void OnClick()
	{
		if (target != null)
		{
			NGUITools.SetActive(target, state);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/Interaction/Button Color")]
public class UIButtonColor : UIWidgetContainer
{
	public enum State
	{
		Normal,
		Hover,
		Pressed,
		Disabled
	}

	public GameObject tweenTarget;

	public UnityEngine.Color hover = new UnityEngine.Color(0.88235295f, 40f / 51f, 0.5882353f, 1f);

	public UnityEngine.Color pressed = new UnityEngine.Color(61f / 85f, 0.6392157f, 41f / 85f, 1f);

	public UnityEngine.Color disabledColor = UnityEngine.Color.grey;

	public float duration = 0.2f;

	[NonSerialized]
	[HideInInspector]
	public new GameObject gameObject;

	[NonSerialized]
	protected UnityEngine.Color mStartingColor;

	[NonSerialized]
	protected UnityEngine.Color mDefaultColor;

	[NonSerialized]
	protected bool mInitDone;

	[NonSerialized]
	protected UIWidget mWidget;

	[NonSerialized]
	protected State mState;

	public State state
	{
		get
		{
			return mState;
		}
		set
		{
			SetState(value, instant: false);
		}
	}

	public UnityEngine.Color defaultColor
	{
		get
		{
			if (!mInitDone)
			{
				OnInit();
			}
			return mDefaultColor;
		}
		set
		{
			if (!mInitDone)
			{
				OnInit();
			}
			mDefaultColor = value;
			State state = mState;
			mState = State.Disabled;
			SetState(state, instant: false);
		}
	}

	public virtual bool isEnabled
	{
		get
		{
			return base.enabled;
		}
		set
		{
			base.enabled = value;
		}
	}

	public void ResetDefaultColor()
	{
		defaultColor = mStartingColor;
	}

	private void Awake()
	{
		if (!mInitDone)
		{
			OnInit();
		}
	}

	private void Start()
	{
		if (!isEnabled)
		{
			SetState(State.Disabled, instant: true);
		}
	}

	protected virtual void OnInit()
	{
		gameObject = base.gameObject;
		mInitDone = true;
		if (tweenTarget == null)
		{
			tweenTarget = gameObject;
		}
		mWidget = tweenTarget.GetComponent<UIWidget>();
		if (mWidget != null)
		{
			mDefaultColor = mWidget.color;
			mStartingColor = mDefaultColor;
			return;
		}
		Renderer component = tweenTarget.GetComponent<Renderer>();
		if (component != null)
		{
			mDefaultColor = ((!Application.isPlaying) ? component.sharedMaterial.color : component.material.color);
			mStartingColor = mDefaultColor;
			return;
		}
		Light component2 = tweenTarget.GetComponent<Light>();
		if (component2 != null)
		{
			mDefaultColor = component2.color;
			mStartingColor = mDefaultColor;
		}
		else
		{
			tweenTarget = null;
			mInitDone = false;
		}
	}

	protected virtual void OnEnable()
	{
		if (mInitDone)
		{
			OnHover(UICamera.IsHighlighted(gameObject));
		}
		if (UICamera.currentTouch != null)
		{
			if (UICamera.currentTouch.pressed == gameObject)
			{
				OnPress(isPressed: true);
			}
			else if (UICamera.currentTouch.current == gameObject)
			{
				OnHover(isOver: true);
			}
		}
	}

	protected virtual void OnDisable()
	{
		if (mInitDone && tweenTarget != null)
		{
			SetState(State.Normal, instant: true);
			TweenColor component = tweenTarget.GetComponent<TweenColor>();
			if (component != null)
			{
				component.value = mDefaultColor;
				component.enabled = false;
			}
		}
	}

	protected virtual void OnHover(bool isOver)
	{
		if (isEnabled)
		{
			if (!mInitDone)
			{
				OnInit();
			}
			if (tweenTarget != null)
			{
				SetState(isOver ? State.Hover : State.Normal, instant: false);
			}
		}
	}

	protected virtual void OnPress(bool isPressed)
	{
		if (!isEnabled || UICamera.currentTouch == null)
		{
			return;
		}
		if (!mInitDone)
		{
			OnInit();
		}
		if (!(tweenTarget != null))
		{
			return;
		}
		if (isPressed)
		{
			SetState(State.Pressed, instant: false);
		}
		else if (UICamera.currentTouch.current == gameObject)
		{
			if (UICamera.currentScheme == UICamera.ControlScheme.Controller)
			{
				SetState(State.Hover, instant: false);
			}
			else if (UICamera.currentScheme == UICamera.ControlScheme.Mouse && UICamera.hoveredObject == gameObject)
			{
				SetState(State.Hover, instant: false);
			}
			else
			{
				SetState(State.Normal, instant: false);
			}
		}
		else
		{
			SetState(State.Normal, instant: false);
		}
	}

	protected virtual void OnDragOver()
	{
		if (isEnabled)
		{
			if (!mInitDone)
			{
				OnInit();
			}
			if (tweenTarget != null)
			{
				SetState(State.Pressed, instant: false);
			}
		}
	}

	protected virtual void OnDragOut()
	{
		if (isEnabled)
		{
			if (!mInitDone)
			{
				OnInit();
			}
			if (tweenTarget != null)
			{
				SetState(State.Normal, instant: false);
			}
		}
	}

	protected virtual void OnSelect(bool isSelected)
	{
		if (isEnabled && tweenTarget != null)
		{
			if (UICamera.currentScheme == UICamera.ControlScheme.Controller)
			{
				OnHover(isSelected);
			}
			else if (!isSelected && UICamera.touchCount < 2)
			{
				OnHover(isSelected);
			}
		}
	}

	public virtual void SetState(State state, bool instant)
	{
		if (!mInitDone)
		{
			mInitDone = true;
			OnInit();
		}
		if (mState != state)
		{
			mState = state;
			UpdateColor(instant);
		}
	}

	public void UpdateColor(bool instant)
	{
		TweenColor tweenColor = mState switch
		{
			State.Hover => TweenColor.Begin(tweenTarget, duration, hover), 
			State.Pressed => TweenColor.Begin(tweenTarget, duration, pressed), 
			State.Disabled => TweenColor.Begin(tweenTarget, duration, disabledColor), 
			_ => TweenColor.Begin(tweenTarget, duration, mDefaultColor), 
		};
		if (instant && tweenColor != null)
		{
			tweenColor.value = tweenColor.to;
			tweenColor.enabled = false;
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/Interaction/Button Keys (Legacy)")]
public class UIButtonKeys : UIKeyNavigation
{
	public UIButtonKeys selectOnClick;

	public UIButtonKeys selectOnUp;

	public UIButtonKeys selectOnDown;

	public UIButtonKeys selectOnLeft;

	public UIButtonKeys selectOnRight;

	protected override void OnEnable()
	{
		Upgrade();
		base.OnEnable();
	}

	public void Upgrade()
	{
		if (onClick == null && selectOnClick != null)
		{
			onClick = selectOnClick.gameObject;
			selectOnClick = null;
			NGUITools.SetDirty(this);
		}
		if (onLeft == null && selectOnLeft != null)
		{
			onLeft = selectOnLeft.gameObject;
			selectOnLeft = null;
			NGUITools.SetDirty(this);
		}
		if (onRight == null && selectOnRight != null)
		{
			onRight = selectOnRight.gameObject;
			selectOnRight = null;
			NGUITools.SetDirty(this);
		}
		if (onUp == null && selectOnUp != null)
		{
			onUp = selectOnUp.gameObject;
			selectOnUp = null;
			NGUITools.SetDirty(this);
		}
		if (onDown == null && selectOnDown != null)
		{
			onDown = selectOnDown.gameObject;
			selectOnDown = null;
			NGUITools.SetDirty(this);
		}
	}
}
[AddComponentMenu("NGUI/Interaction/Button Message (Legacy)")]
public class UIButtonMessage : MonoBehaviour
{
	public enum Trigger
	{
		OnClick,
		OnMouseOver,
		OnMouseOut,
		OnPress,
		OnRelease,
		OnDoubleClick
	}

	public GameObject target;

	public string functionName;

	public Trigger trigger;

	public bool includeChildren;

	private bool mStarted;

	private void Start()
	{
		mStarted = true;
	}

	private void OnEnable()
	{
		if (mStarted)
		{
			OnHover(UICamera.IsHighlighted(base.gameObject));
		}
	}

	private void OnHover(bool isOver)
	{
		if (base.enabled && ((isOver && trigger == Trigger.OnMouseOver) || (!isOver && trigger == Trigger.OnMouseOut)))
		{
			Send();
		}
	}

	private void OnPress(bool isPressed)
	{
		if (base.enabled && ((isPressed && trigger == Trigger.OnPress) || (!isPressed && trigger == Trigger.OnRelease)))
		{
			Send();
		}
	}

	private void OnSelect(bool isSelected)
	{
		if (base.enabled && (!isSelected || UICamera.currentScheme == UICamera.ControlScheme.Controller))
		{
			OnHover(isSelected);
		}
	}

	private void OnClick()
	{
		if (base.enabled && trigger == Trigger.OnClick)
		{
			Send();
		}
	}

	private void OnDoubleClick()
	{
		if (base.enabled && trigger == Trigger.OnDoubleClick)
		{
			Send();
		}
	}

	private void Send()
	{
		if (string.IsNullOrEmpty(functionName))
		{
			return;
		}
		if (target == null)
		{
			target = base.gameObject;
		}
		if (includeChildren)
		{
			Transform[] componentsInChildren = target.GetComponentsInChildren<Transform>();
			int i = 0;
			for (int num = componentsInChildren.Length; i < num; i++)
			{
				Transform transform = componentsInChildren[i];
				transform.gameObject.SendMessage(functionName, base.gameObject, SendMessageOptions.DontRequireReceiver);
			}
		}
		else
		{
			target.SendMessage(functionName, base.gameObject, SendMessageOptions.DontRequireReceiver);
		}
	}
}
[AddComponentMenu("NGUI/Interaction/Button Offset")]
public class UIButtonOffset : MonoBehaviour
{
	public Transform tweenTarget;

	public Vector3 hover = Vector3.zero;

	public Vector3 pressed = new Vector3(2f, -2f);

	public float duration = 0.2f;

	private Vector3 mPos;

	private bool mStarted;

	private void Start()
	{
		if (!mStarted)
		{
			mStarted = true;
			if (tweenTarget == null)
			{
				tweenTarget = base.transform;
			}
			mPos = tweenTarget.localPosition;
		}
	}

	private void OnEnable()
	{
		if (mStarted)
		{
			OnHover(UICamera.IsHighlighted(base.gameObject));
		}
	}

	private void OnDisable()
	{
		if (mStarted && tweenTarget != null)
		{
			TweenPosition component = tweenTarget.GetComponent<TweenPosition>();
			if (component != null)
			{
				component.value = mPos;
				component.enabled = false;
			}
		}
	}

	private void OnPress(bool isPressed)
	{
		if (base.enabled)
		{
			if (!mStarted)
			{
				Start();
			}
			TweenPosition.Begin(tweenTarget.gameObject, duration, isPressed ? (mPos + pressed) : ((!UICamera.IsHighlighted(base.gameObject)) ? mPos : (mPos + hover))).method = UITweener.Method.EaseInOut;
		}
	}

	private void OnHover(bool isOver)
	{
		if (base.enabled)
		{
			if (!mStarted)
			{
				Start();
			}
			TweenPosition.Begin(tweenTarget.gameObject, duration, (!isOver) ? mPos : (mPos + hover)).method = UITweener.Method.EaseInOut;
		}
	}

	private void OnSelect(bool isSelected)
	{
		if (base.enabled && (!isSelected || UICamera.currentScheme == UICamera.ControlScheme.Controller))
		{
			OnHover(isSelected);
		}
	}
}
[AddComponentMenu("NGUI/Interaction/Button Rotation")]
public class UIButtonRotation : MonoBehaviour
{
	public Transform tweenTarget;

	public Vector3 hover = Vector3.zero;

	public Vector3 pressed = Vector3.zero;

	public float duration = 0.2f;

	private Quaternion mRot;

	private bool mStarted;

	private void Start()
	{
		if (!mStarted)
		{
			mStarted = true;
			if (tweenTarget == null)
			{
				tweenTarget = base.transform;
			}
			mRot = tweenTarget.localRotation;
		}
	}

	private void OnEnable()
	{
		if (mStarted)
		{
			OnHover(UICamera.IsHighlighted(base.gameObject));
		}
	}

	private void OnDisable()
	{
		if (mStarted && tweenTarget != null)
		{
			TweenRotation component = tweenTarget.GetComponent<TweenRotation>();
			if (component != null)
			{
				component.value = mRot;
				component.enabled = false;
			}
		}
	}

	private void OnPress(bool isPressed)
	{
		if (base.enabled)
		{
			if (!mStarted)
			{
				Start();
			}
			TweenRotation.Begin(tweenTarget.gameObject, duration, isPressed ? (mRot * Quaternion.Euler(pressed)) : ((!UICamera.IsHighlighted(base.gameObject)) ? mRot : (mRot * Quaternion.Euler(hover)))).method = UITweener.Method.EaseInOut;
		}
	}

	private void OnHover(bool isOver)
	{
		if (base.enabled)
		{
			if (!mStarted)
			{
				Start();
			}
			TweenRotation.Begin(tweenTarget.gameObject, duration, (!isOver) ? mRot : (mRot * Quaternion.Euler(hover))).method = UITweener.Method.EaseInOut;
		}
	}

	private void OnSelect(bool isSelected)
	{
		if (base.enabled && (!isSelected || UICamera.currentScheme == UICamera.ControlScheme.Controller))
		{
			OnHover(isSelected);
		}
	}
}
[AddComponentMenu("NGUI/Interaction/Button Scale")]
public class UIButtonScale : MonoBehaviour
{
	public Transform tweenTarget;

	public Vector3 hover = new Vector3(1.1f, 1.1f, 1.1f);

	public Vector3 pressed = new Vector3(1.05f, 1.05f, 1.05f);

	public float duration = 0.2f;

	private Vector3 mScale;

	private bool mStarted;

	private void Start()
	{
		if (!mStarted)
		{
			mStarted = true;
			if (tweenTarget == null)
			{
				tweenTarget = base.transform;
			}
			mScale = tweenTarget.localScale;
		}
	}

	private void OnEnable()
	{
		if (mStarted)
		{
			OnHover(UICamera.IsHighlighted(base.gameObject));
		}
	}

	private void OnDisable()
	{
		if (mStarted && tweenTarget != null)
		{
			TweenScale component = tweenTarget.GetComponent<TweenScale>();
			if (component != null)
			{
				component.value = mScale;
				component.enabled = false;
			}
		}
	}

	private void OnPress(bool isPressed)
	{
		if (base.enabled)
		{
			if (!mStarted)
			{
				Start();
			}
			TweenScale.Begin(tweenTarget.gameObject, duration, isPressed ? Vector3.Scale(mScale, pressed) : ((!UICamera.IsHighlighted(base.gameObject)) ? mScale : Vector3.Scale(mScale, hover))).method = UITweener.Method.EaseInOut;
		}
	}

	private void OnHover(bool isOver)
	{
		if (base.enabled)
		{
			if (!mStarted)
			{
				Start();
			}
			TweenScale.Begin(tweenTarget.gameObject, duration, (!isOver) ? mScale : Vector3.Scale(mScale, hover)).method = UITweener.Method.EaseInOut;
		}
	}

	private void OnSelect(bool isSelected)
	{
		if (base.enabled && (!isSelected || UICamera.currentScheme == UICamera.ControlScheme.Controller))
		{
			OnHover(isSelected);
		}
	}
}
[AddComponentMenu("NGUI/Interaction/Center Scroll View on Child")]
public class UICenterOnChild : MonoBehaviour
{
	public delegate void OnCenterCallback(GameObject centeredObject);

	public float springStrength = 8f;

	public float nextPageThreshold;

	public SpringPanel.OnFinished onFinished;

	public OnCenterCallback onCenter;

	private UIScrollView mScrollView;

	private GameObject mCenteredObject;

	public GameObject centeredObject => mCenteredObject;

	private void Start()
	{
		Recenter();
	}

	private void OnEnable()
	{
		if ((bool)mScrollView)
		{
			mScrollView.centerOnChild = this;
			Recenter();
		}
	}

	private void OnDisable()
	{
		if ((bool)mScrollView)
		{
			mScrollView.centerOnChild = null;
		}
	}

	private void OnDragFinished()
	{
		if (base.enabled)
		{
			Recenter();
		}
	}

	private void OnValidate()
	{
		nextPageThreshold = Mathf.Abs(nextPageThreshold);
	}

	[ContextMenu("Execute")]
	public void Recenter()
	{
		if (mScrollView == null)
		{
			mScrollView = NGUITools.FindInParents<UIScrollView>(base.gameObject);
			if (mScrollView == null)
			{
				UnityEngine.Debug.LogWarning(string.Concat(GetType(), " requires ", typeof(UIScrollView), " on a parent object in order to work"), this);
				base.enabled = false;
				return;
			}
			if ((bool)mScrollView)
			{
				mScrollView.centerOnChild = this;
				mScrollView.onDragFinished = OnDragFinished;
			}
			if (mScrollView.horizontalScrollBar != null)
			{
				mScrollView.horizontalScrollBar.onDragFinished = OnDragFinished;
			}
			if (mScrollView.verticalScrollBar != null)
			{
				mScrollView.verticalScrollBar.onDragFinished = OnDragFinished;
			}
		}
		if (mScrollView.panel == null)
		{
			return;
		}
		Transform transform = base.transform;
		if (transform.childCount == 0)
		{
			return;
		}
		Vector3[] worldCorners = mScrollView.panel.worldCorners;
		Vector3 vector = (worldCorners[2] + worldCorners[0]) * 0.5f;
		Vector3 velocity = mScrollView.currentMomentum * mScrollView.momentumAmount;
		Vector3 vector2 = NGUIMath.SpringDampen(ref velocity, 9f, 2f);
		Vector3 vector3 = vector - vector2 * 0.01f;
		float num = float.MaxValue;
		Transform target = null;
		int num2 = 0;
		int i = 0;
		for (int childCount = transform.childCount; i < childCount; i++)
		{
			Transform child = transform.GetChild(i);
			if (child.gameObject.activeInHierarchy)
			{
				float num3 = Vector3.SqrMagnitude(child.position - vector3);
				if (num3 < num)
				{
					num = num3;
					target = child;
					num2 = i;
				}
			}
		}
		if (nextPageThreshold > 0f && UICamera.currentTouch != null && mCenteredObject != null && mCenteredObject.transform == transform.GetChild(num2))
		{
			Vector2 totalDelta = UICamera.currentTouch.totalDelta;
			float num4 = 0f;
			num4 = mScrollView.movement switch
			{
				UIScrollView.Movement.Horizontal => totalDelta.x, 
				UIScrollView.Movement.Vertical => totalDelta.y, 
				_ => totalDelta.magnitude, 
			};
			if (Mathf.Abs(num4) > nextPageThreshold)
			{
				UIGrid component = GetComponent<UIGrid>();
				if (component != null && component.sorting != 0)
				{
					List<Transform> childList = component.GetChildList();
					if (num4 > nextPageThreshold)
					{
						target = ((num2 <= 0) ? childList[0] : childList[num2 - 1]);
					}
					else if (num4 < 0f - nextPageThreshold)
					{
						target = ((num2 >= childList.Count - 1) ? childList[childList.Count - 1] : childList[num2 + 1]);
					}
				}
				else
				{
					UnityEngine.Debug.LogWarning("Next Page Threshold requires a sorted UIGrid in order to work properly", this);
				}
			}
		}
		CenterOn(target, vector);
	}

	private void CenterOn(Transform target, Vector3 panelCenter)
	{
		if (target != null && mScrollView != null && mScrollView.panel != null)
		{
			Transform cachedTransform = mScrollView.panel.cachedTransform;
			mCenteredObject = target.gameObject;
			Vector3 vector = cachedTransform.InverseTransformPoint(target.position);
			Vector3 vector2 = cachedTransform.InverseTransformPoint(panelCenter);
			Vector3 vector3 = vector - vector2;
			if (!mScrollView.canMoveHorizontally)
			{
				vector3.x = 0f;
			}
			if (!mScrollView.canMoveVertically)
			{
				vector3.y = 0f;
			}
			vector3.z = 0f;
			SpringPanel.Begin(mScrollView.panel.cachedGameObject, cachedTransform.localPosition - vector3, springStrength).onFinished = onFinished;
		}
		else
		{
			mCenteredObject = null;
		}
		if (onCenter != null)
		{
			onCenter(mCenteredObject);
		}
	}

	public void CenterOn(Transform target)
	{
		if (mScrollView != null && mScrollView.panel != null)
		{
			Vector3[] worldCorners = mScrollView.panel.worldCorners;
			Vector3 panelCenter = (worldCorners[2] + worldCorners[0]) * 0.5f;
			CenterOn(target, panelCenter);
		}
	}
}
[AddComponentMenu("NGUI/Interaction/Center Scroll View on Click")]
public class UICenterOnClick : MonoBehaviour
{
	private void OnClick()
	{
		UICenterOnChild uICenterOnChild = NGUITools.FindInParents<UICenterOnChild>(base.gameObject);
		UIPanel uIPanel = NGUITools.FindInParents<UIPanel>(base.gameObject);
		if (uICenterOnChild != null)
		{
			if (uICenterOnChild.enabled)
			{
				uICenterOnChild.CenterOn(base.transform);
			}
		}
		else if (uIPanel != null && uIPanel.clipping != 0)
		{
			UIScrollView component = uIPanel.GetComponent<UIScrollView>();
			Vector3 pos = -uIPanel.cachedTransform.InverseTransformPoint(base.transform.position);
			if (!component.canMoveHorizontally)
			{
				pos.x = uIPanel.cachedTransform.localPosition.x;
			}
			if (!component.canMoveVertically)
			{
				pos.y = uIPanel.cachedTransform.localPosition.y;
			}
			SpringPanel.Begin(uIPanel.cachedGameObject, pos, 6f);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/Interaction/Drag Camera")]
public class UIDragCamera : MonoBehaviour
{
	public UIDraggableCamera draggableCamera;

	private void Awake()
	{
		if (draggableCamera == null)
		{
			draggableCamera = NGUITools.FindInParents<UIDraggableCamera>(base.gameObject);
		}
	}

	private void OnPress(bool isPressed)
	{
		if (base.enabled && NGUITools.GetActive(base.gameObject) && draggableCamera != null)
		{
			draggableCamera.Press(isPressed);
		}
	}

	private void OnDrag(Vector2 delta)
	{
		if (base.enabled && NGUITools.GetActive(base.gameObject) && draggableCamera != null)
		{
			draggableCamera.Drag(delta);
		}
	}

	private void OnScroll(float delta)
	{
		if (base.enabled && NGUITools.GetActive(base.gameObject) && draggableCamera != null)
		{
			draggableCamera.Scroll(delta);
		}
	}
}
[AddComponentMenu("NGUI/Interaction/Drag and Drop Container")]
public class UIDragDropContainer : MonoBehaviour
{
	public Transform reparentTarget;

	protected virtual void Start()
	{
		if (reparentTarget == null)
		{
			reparentTarget = base.transform;
		}
	}
}
[AddComponentMenu("NGUI/Interaction/Drag and Drop Item")]
public class UIDragDropItem : MonoBehaviour
{
	public enum Restriction
	{
		None,
		Horizontal,
		Vertical,
		PressAndHold
	}

	public Restriction restriction;

	public bool cloneOnDrag;

	[HideInInspector]
	public float pressAndHoldDelay = 1f;

	protected Transform mTrans;

	protected Transform mParent;

	protected Collider mCollider;

	protected Collider2D mCollider2D;

	protected UIButton mButton;

	protected UIRoot mRoot;

	protected UIGrid mGrid;

	protected UITable mTable;

	protected int mTouchID = int.MinValue;

	protected float mDragStartTime;

	protected UIDragScrollView mDragScrollView;

	protected bool mPressed;

	protected bool mDragging;

	protected virtual void Start()
	{
		mTrans = base.transform;
		mCollider = GetComponent<Collider>();
		mCollider2D = GetComponent<Collider2D>();
		mButton = GetComponent<UIButton>();
		mDragScrollView = GetComponent<UIDragScrollView>();
	}

	protected void OnPress(bool isPressed)
	{
		if (isPressed)
		{
			mDragStartTime = RealTime.time + pressAndHoldDelay;
			mPressed = true;
		}
		else
		{
			mPressed = false;
		}
	}

	protected virtual void Update()
	{
		if (restriction == Restriction.PressAndHold && mPressed && !mDragging && mDragStartTime < RealTime.time)
		{
			StartDragging();
		}
	}

	protected void OnDragStart()
	{
		if (!base.enabled || mTouchID != int.MinValue)
		{
			return;
		}
		if (restriction != 0)
		{
			if (restriction == Restriction.Horizontal)
			{
				Vector2 totalDelta = UICamera.currentTouch.totalDelta;
				if (Mathf.Abs(totalDelta.x) < Mathf.Abs(totalDelta.y))
				{
					return;
				}
			}
			else if (restriction == Restriction.Vertical)
			{
				Vector2 totalDelta2 = UICamera.currentTouch.totalDelta;
				if (Mathf.Abs(totalDelta2.x) > Mathf.Abs(totalDelta2.y))
				{
					return;
				}
			}
			else if (restriction == Restriction.PressAndHold)
			{
				return;
			}
		}
		StartDragging();
	}

	protected virtual void StartDragging()
	{
		if (mDragging)
		{
			return;
		}
		if (cloneOnDrag)
		{
			GameObject gameObject = NGUITools.AddChild(base.transform.parent.gameObject, base.gameObject);
			gameObject.transform.localPosition = base.transform.localPosition;
			gameObject.transform.localRotation = base.transform.localRotation;
			gameObject.transform.localScale = base.transform.localScale;
			UIButtonColor component = gameObject.GetComponent<UIButtonColor>();
			if (component != null)
			{
				component.defaultColor = GetComponent<UIButtonColor>().defaultColor;
			}
			UICamera.currentTouch.dragged = gameObject;
			UIDragDropItem component2 = gameObject.GetComponent<UIDragDropItem>();
			component2.mDragging = true;
			component2.Start();
			component2.OnDragDropStart();
		}
		else
		{
			mDragging = true;
			OnDragDropStart();
		}
	}

	protected void OnDrag(Vector2 delta)
	{
		if (mDragging && base.enabled && mTouchID == UICamera.currentTouchID)
		{
			OnDragDropMove(delta * mRoot.pixelSizeAdjustment);
		}
	}

	protected void OnDragEnd()
	{
		if (base.enabled && mTouchID == UICamera.currentTouchID)
		{
			StopDragging(UICamera.hoveredObject);
		}
	}

	public void StopDragging(GameObject go)
	{
		if (mDragging)
		{
			mDragging = false;
			OnDragDropRelease(go);
		}
	}

	protected virtual void OnDragDropStart()
	{
		if (mDragScrollView != null)
		{
			mDragScrollView.enabled = false;
		}
		if (mButton != null)
		{
			mButton.isEnabled = false;
		}
		else if (mCollider != null)
		{
			mCollider.enabled = false;
		}
		else if (mCollider2D != null)
		{
			mCollider2D.enabled = false;
		}
		mTouchID = UICamera.currentTouchID;
		mParent = mTrans.parent;
		mRoot = NGUITools.FindInParents<UIRoot>(mParent);
		mGrid = NGUITools.FindInParents<UIGrid>(mParent);
		mTable = NGUITools.FindInParents<UITable>(mParent);
		if (UIDragDropRoot.root != null)
		{
			mTrans.parent = UIDragDropRoot.root;
		}
		Vector3 localPosition = mTrans.localPosition;
		localPosition.z = 0f;
		mTrans.localPosition = localPosition;
		TweenPosition component = GetComponent<TweenPosition>();
		if (component != null)
		{
			component.enabled = false;
		}
		SpringPosition component2 = GetComponent<SpringPosition>();
		if (component2 != null)
		{
			component2.enabled = false;
		}
		NGUITools.MarkParentAsChanged(base.gameObject);
		if (mTable != null)
		{
			mTable.repositionNow = true;
		}
		if (mGrid != null)
		{
			mGrid.repositionNow = true;
		}
	}

	protected virtual void OnDragDropMove(Vector2 delta)
	{
		mTrans.localPosition += (Vector3)delta;
	}

	protected virtual void OnDragDropRelease(GameObject surface)
	{
		if (!cloneOnDrag)
		{
			mTouchID = int.MinValue;
			if (mButton != null)
			{
				mButton.isEnabled = true;
			}
			else if (mCollider != null)
			{
				mCollider.enabled = true;
			}
			else if (mCollider2D != null)
			{
				mCollider2D.enabled = true;
			}
			UIDragDropContainer uIDragDropContainer = ((!surface) ? null : NGUITools.FindInParents<UIDragDropContainer>(surface));
			if (uIDragDropContainer != null)
			{
				mTrans.parent = ((!(uIDragDropContainer.reparentTarget != null)) ? uIDragDropContainer.transform : uIDragDropContainer.reparentTarget);
				Vector3 localPosition = mTrans.localPosition;
				localPosition.z = 0f;
				mTrans.localPosition = localPosition;
			}
			else
			{
				mTrans.parent = mParent;
			}
			mParent = mTrans.parent;
			mGrid = NGUITools.FindInParents<UIGrid>(mParent);
			mTable = NGUITools.FindInParents<UITable>(mParent);
			if (mDragScrollView != null)
			{
				StartCoroutine(EnableDragScrollView());
			}
			NGUITools.MarkParentAsChanged(base.gameObject);
			if (mTable != null)
			{
				mTable.repositionNow = true;
			}
			if (mGrid != null)
			{
				mGrid.repositionNow = true;
			}
			OnDragDropEnd();
		}
		else
		{
			NGUITools.Destroy(base.gameObject);
		}
	}

	protected virtual void OnDragDropEnd()
	{
	}

	protected IEnumerator EnableDragScrollView()
	{
		yield return new WaitForEndOfFrame();
		if (mDragScrollView != null)
		{
			mDragScrollView.enabled = true;
		}
	}
}
[AddComponentMenu("NGUI/Interaction/Drag and Drop Root")]
public class UIDragDropRoot : MonoBehaviour
{
	public static Transform root;

	private void OnEnable()
	{
		root = base.transform;
	}

	private void OnDisable()
	{
		if (root == base.transform)
		{
			root = null;
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/Interaction/Drag Object")]
public class UIDragObject : MonoBehaviour
{
	public enum DragEffect
	{
		None,
		Momentum,
		MomentumAndSpring
	}

	public Transform target;

	public UIPanel panelRegion;

	public Vector3 scrollMomentum = Vector3.zero;

	public bool restrictWithinPanel;

	public UIRect contentRect;

	public DragEffect dragEffect = DragEffect.MomentumAndSpring;

	public float momentumAmount = 35f;

	[SerializeField]
	protected Vector3 scale = new Vector3(1f, 1f, 0f);

	[SerializeField]
	[HideInInspector]
	private float scrollWheelFactor;

	private Plane mPlane;

	private Vector3 mTargetPos;

	private Vector3 mLastPos;

	private Vector3 mMomentum = Vector3.zero;

	private Vector3 mScroll = Vector3.zero;

	private Bounds mBounds;

	private int mTouchID;

	private bool mStarted;

	private bool mPressed;

	public Vector3 dragMovement
	{
		get
		{
			return scale;
		}
		set
		{
			scale = value;
		}
	}

	private void OnEnable()
	{
		if (scrollWheelFactor != 0f)
		{
			scrollMomentum = scale * scrollWheelFactor;
			scrollWheelFactor = 0f;
		}
		if (contentRect == null && target != null && Application.isPlaying)
		{
			UIWidget component = target.GetComponent<UIWidget>();
			if (component != null)
			{
				contentRect = component;
			}
		}
	}

	private void OnDisable()
	{
		mStarted = false;
	}

	private void FindPanel()
	{
		panelRegion = ((!(target != null)) ? null : UIPanel.Find(target.transform.parent));
		if (panelRegion == null)
		{
			restrictWithinPanel = false;
		}
	}

	private void UpdateBounds()
	{
		if ((bool)contentRect)
		{
			Transform cachedTransform = panelRegion.cachedTransform;
			Matrix4x4 worldToLocalMatrix = cachedTransform.worldToLocalMatrix;
			Vector3[] worldCorners = contentRect.worldCorners;
			for (int i = 0; i < 4; i++)
			{
				ref Vector3 reference = ref worldCorners[i];
				reference = worldToLocalMatrix.MultiplyPoint3x4(worldCorners[i]);
			}
			mBounds = new Bounds(worldCorners[0], Vector3.zero);
			for (int j = 1; j < 4; j++)
			{
				mBounds.Encapsulate(worldCorners[j]);
			}
		}
		else
		{
			mBounds = NGUIMath.CalculateRelativeWidgetBounds(panelRegion.cachedTransform, target);
		}
	}

	private void OnPress(bool pressed)
	{
		if (!base.enabled || !NGUITools.GetActive(base.gameObject) || !(target != null))
		{
			return;
		}
		if (pressed)
		{
			if (!mPressed)
			{
				mTouchID = UICamera.currentTouchID;
				mPressed = true;
				mStarted = false;
				CancelMovement();
				if (restrictWithinPanel && panelRegion == null)
				{
					FindPanel();
				}
				if (restrictWithinPanel)
				{
					UpdateBounds();
				}
				CancelSpring();
				Transform transform = UICamera.currentCamera.transform;
				mPlane = new Plane(((!(panelRegion != null)) ? transform.rotation : panelRegion.cachedTransform.rotation) * Vector3.back, UICamera.lastWorldPosition);
			}
		}
		else if (mPressed && mTouchID == UICamera.currentTouchID)
		{
			mPressed = false;
			if (restrictWithinPanel && dragEffect == DragEffect.MomentumAndSpring && panelRegion.ConstrainTargetToBounds(target, ref mBounds, immediate: false))
			{
				CancelMovement();
			}
		}
	}

	private void OnDrag(Vector2 delta)
	{
		if (!mPressed || mTouchID != UICamera.currentTouchID || !base.enabled || !NGUITools.GetActive(base.gameObject) || !(target != null))
		{
			return;
		}
		UICamera.currentTouch.clickNotification = UICamera.ClickNotification.BasedOnDelta;
		Ray ray = UICamera.currentCamera.ScreenPointToRay(UICamera.currentTouch.pos);
		float enter = 0f;
		if (!mPlane.Raycast(ray, out enter))
		{
			return;
		}
		Vector3 point = ray.GetPoint(enter);
		Vector3 vector = point - mLastPos;
		mLastPos = point;
		if (!mStarted)
		{
			mStarted = true;
			vector = Vector3.zero;
		}
		if (vector.x != 0f || vector.y != 0f)
		{
			vector = target.InverseTransformDirection(vector);
			vector.Scale(scale);
			vector = target.TransformDirection(vector);
		}
		if (dragEffect != 0)
		{
			mMomentum = Vector3.Lerp(mMomentum, mMomentum + vector * (0.01f * momentumAmount), 0.67f);
		}
		Vector3 localPosition = target.localPosition;
		Move(vector);
		if (restrictWithinPanel)
		{
			mBounds.center += target.localPosition - localPosition;
			if (dragEffect != DragEffect.MomentumAndSpring && panelRegion.ConstrainTargetToBounds(target, ref mBounds, immediate: true))
			{
				CancelMovement();
			}
		}
	}

	private void Move(Vector3 worldDelta)
	{
		if (panelRegion != null)
		{
			mTargetPos += worldDelta;
			target.position = mTargetPos;
			Vector3 localPosition = target.localPosition;
			localPosition.x = Mathf.Round(localPosition.x);
			localPosition.y = Mathf.Round(localPosition.y);
			target.localPosition = localPosition;
			UIScrollView component = panelRegion.GetComponent<UIScrollView>();
			if (component != null)
			{
				component.UpdateScrollbars(recalculateBounds: true);
			}
		}
		else
		{
			target.position += worldDelta;
		}
	}

	private void LateUpdate()
	{
		if (target == null)
		{
			return;
		}
		float deltaTime = RealTime.deltaTime;
		mMomentum -= mScroll;
		mScroll = NGUIMath.SpringLerp(mScroll, Vector3.zero, 20f, deltaTime);
		if (mMomentum.magnitude < 0.0001f)
		{
			return;
		}
		if (!mPressed)
		{
			if (panelRegion == null)
			{
				FindPanel();
			}
			Move(NGUIMath.SpringDampen(ref mMomentum, 9f, deltaTime));
			if (restrictWithinPanel && panelRegion != null)
			{
				UpdateBounds();
				if (panelRegion.ConstrainTargetToBounds(target, ref mBounds, dragEffect == DragEffect.None))
				{
					CancelMovement();
				}
				else
				{
					CancelSpring();
				}
			}
			NGUIMath.SpringDampen(ref mMomentum, 9f, deltaTime);
			if (mMomentum.magnitude < 0.0001f)
			{
				CancelMovement();
			}
		}
		else
		{
			NGUIMath.SpringDampen(ref mMomentum, 9f, deltaTime);
		}
	}

	public void CancelMovement()
	{
		if (target != null)
		{
			Vector3 localPosition = target.localPosition;
			localPosition.x = Mathf.RoundToInt(localPosition.x);
			localPosition.y = Mathf.RoundToInt(localPosition.y);
			localPosition.z = Mathf.RoundToInt(localPosition.z);
			target.localPosition = localPosition;
		}
		mTargetPos = ((!(target != null)) ? Vector3.zero : target.position);
		mMomentum = Vector3.zero;
		mScroll = Vector3.zero;
	}

	public void CancelSpring()
	{
		SpringPosition component = target.GetComponent<SpringPosition>();
		if (component != null)
		{
			component.enabled = false;
		}
	}

	private void OnScroll(float delta)
	{
		if (base.enabled && NGUITools.GetActive(base.gameObject))
		{
			mScroll -= scrollMomentum * (delta * 0.05f);
		}
	}
}
[AddComponentMenu("NGUI/Interaction/Drag-Resize Widget")]
public class UIDragResize : MonoBehaviour
{
	public UIWidget target;

	public UIWidget.Pivot pivot = UIWidget.Pivot.BottomRight;

	public int minWidth = 100;

	public int minHeight = 100;

	public int maxWidth = 100000;

	public int maxHeight = 100000;

	private Plane mPlane;

	private Vector3 mRayPos;

	private Vector3 mLocalPos;

	private int mWidth;

	private int mHeight;

	private bool mDragging;

	private void OnDragStart()
	{
		if (target != null)
		{
			Vector3[] worldCorners = target.worldCorners;
			mPlane = new Plane(worldCorners[0], worldCorners[1], worldCorners[3]);
			Ray currentRay = UICamera.currentRay;
			if (mPlane.Raycast(currentRay, out var enter))
			{
				mRayPos = currentRay.GetPoint(enter);
				mLocalPos = target.cachedTransform.localPosition;
				mWidth = target.width;
				mHeight = target.height;
				mDragging = true;
			}
		}
	}

	private void OnDrag(Vector2 delta)
	{
		if (mDragging && target != null)
		{
			Ray currentRay = UICamera.currentRay;
			if (mPlane.Raycast(currentRay, out var enter))
			{
				Transform cachedTransform = target.cachedTransform;
				cachedTransform.localPosition = mLocalPos;
				target.width = mWidth;
				target.height = mHeight;
				Vector3 vector = currentRay.GetPoint(enter) - mRayPos;
				cachedTransform.position += vector;
				Vector3 vector2 = Quaternion.Inverse(cachedTransform.localRotation) * (cachedTransform.localPosition - mLocalPos);
				cachedTransform.localPosition = mLocalPos;
				NGUIMath.ResizeWidget(target, pivot, vector2.x, vector2.y, minWidth, minHeight, maxWidth, maxHeight);
			}
		}
	}

	private void OnDragEnd()
	{
		mDragging = false;
	}
}
[AddComponentMenu("NGUI/Interaction/Drag Scroll View")]
public class UIDragScrollView : MonoBehaviour
{
	public UIScrollView scrollView;

	[HideInInspector]
	[SerializeField]
	private UIScrollView draggablePanel;

	private Transform mTrans;

	private UIScrollView mScroll;

	private bool mAutoFind;

	private bool mStarted;

	private void OnEnable()
	{
		mTrans = base.transform;
		if (scrollView == null && draggablePanel != null)
		{
			scrollView = draggablePanel;
			draggablePanel = null;
		}
		if (mStarted && (mAutoFind || mScroll == null))
		{
			FindScrollView();
		}
	}

	private void Start()
	{
		mStarted = true;
		FindScrollView();
	}

	private void FindScrollView()
	{
		UIScrollView uIScrollView = NGUITools.FindInParents<UIScrollView>(mTrans);
		if (scrollView == null)
		{
			scrollView = uIScrollView;
			mAutoFind = true;
		}
		else if (scrollView == uIScrollView)
		{
			mAutoFind = true;
		}
		mScroll = scrollView;
	}

	private void OnPress(bool pressed)
	{
		if (mAutoFind && mScroll != scrollView)
		{
			mScroll = scrollView;
			mAutoFind = false;
		}
		if ((bool)scrollView && base.enabled && NGUITools.GetActive(base.gameObject))
		{
			scrollView.Press(pressed);
			if (!pressed && mAutoFind)
			{
				scrollView = NGUITools.FindInParents<UIScrollView>(mTrans);
				mScroll = scrollView;
			}
		}
	}

	private void OnDrag(Vector2 delta)
	{
		if ((bool)scrollView && NGUITools.GetActive(this))
		{
			scrollView.Drag();
		}
	}

	private void OnScroll(float delta)
	{
		if ((bool)scrollView && NGUITools.GetActive(this))
		{
			scrollView.Scroll(delta);
		}
	}
}
[RequireComponent(typeof(Camera))]
[AddComponentMenu("NGUI/Interaction/Draggable Camera")]
public class UIDraggableCamera : MonoBehaviour
{
	public Transform rootForBounds;

	public Vector2 scale = Vector2.one;

	public float scrollWheelFactor;

	public UIDragObject.DragEffect dragEffect = UIDragObject.DragEffect.MomentumAndSpring;

	public bool smoothDragStart = true;

	public float momentumAmount = 35f;

	private Camera mCam;

	private Transform mTrans;

	private bool mPressed;

	private Vector2 mMomentum = Vector2.zero;

	private Bounds mBounds;

	private float mScroll;

	private UIRoot mRoot;

	private bool mDragStarted;

	public Vector2 currentMomentum
	{
		get
		{
			return mMomentum;
		}
		set
		{
			mMomentum = value;
		}
	}

	private void Start()
	{
		mCam = GetComponent<Camera>();
		mTrans = base.transform;
		mRoot = NGUITools.FindInParents<UIRoot>(base.gameObject);
		if (rootForBounds == null)
		{
			UnityEngine.Debug.LogError(NGUITools.GetHierarchy(base.gameObject) + " needs the 'Root For Bounds' parameter to be set", this);
			base.enabled = false;
		}
	}

	private Vector3 CalculateConstrainOffset()
	{
		if (rootForBounds == null || rootForBounds.childCount == 0)
		{
			return Vector3.zero;
		}
		Vector3 position = new Vector3(mCam.rect.xMin * (float)Screen.width, mCam.rect.yMin * (float)Screen.height, 0f);
		Vector3 position2 = new Vector3(mCam.rect.xMax * (float)Screen.width, mCam.rect.yMax * (float)Screen.height, 0f);
		position = mCam.ScreenToWorldPoint(position);
		position2 = mCam.ScreenToWorldPoint(position2);
		Vector2 minRect = new Vector2(mBounds.min.x, mBounds.min.y);
		Vector2 maxRect = new Vector2(mBounds.max.x, mBounds.max.y);
		return NGUIMath.ConstrainRect(minRect, maxRect, position, position2);
	}

	public bool ConstrainToBounds(bool immediate)
	{
		if (mTrans != null && rootForBounds != null)
		{
			Vector3 vector = CalculateConstrainOffset();
			if (vector.sqrMagnitude > 0f)
			{
				if (immediate)
				{
					mTrans.position -= vector;
				}
				else
				{
					SpringPosition springPosition = SpringPosition.Begin(base.gameObject, mTrans.position - vector, 13f);
					springPosition.ignoreTimeScale = true;
					springPosition.worldSpace = true;
				}
				return true;
			}
		}
		return false;
	}

	public void Press(bool isPressed)
	{
		if (isPressed)
		{
			mDragStarted = false;
		}
		if (!(rootForBounds != null))
		{
			return;
		}
		mPressed = isPressed;
		if (isPressed)
		{
			mBounds = NGUIMath.CalculateAbsoluteWidgetBounds(rootForBounds);
			mMomentum = Vector2.zero;
			mScroll = 0f;
			SpringPosition component = GetComponent<SpringPosition>();
			if (component != null)
			{
				component.enabled = false;
			}
		}
		else if (dragEffect == UIDragObject.DragEffect.MomentumAndSpring)
		{
			ConstrainToBounds(immediate: false);
		}
	}

	public void Drag(Vector2 delta)
	{
		if (smoothDragStart && !mDragStarted)
		{
			mDragStarted = true;
			return;
		}
		UICamera.currentTouch.clickNotification = UICamera.ClickNotification.BasedOnDelta;
		if (mRoot != null)
		{
			delta *= mRoot.pixelSizeAdjustment;
		}
		Vector2 vector = Vector2.Scale(delta, -scale);
		mTrans.localPosition += (Vector3)vector;
		mMomentum = Vector2.Lerp(mMomentum, mMomentum + vector * (0.01f * momentumAmount), 0.67f);
		if (dragEffect != UIDragObject.DragEffect.MomentumAndSpring && ConstrainToBounds(immediate: true))
		{
			mMomentum = Vector2.zero;
			mScroll = 0f;
		}
	}

	public void Scroll(float delta)
	{
		if (base.enabled && NGUITools.GetActive(base.gameObject))
		{
			if (Mathf.Sign(mScroll) != Mathf.Sign(delta))
			{
				mScroll = 0f;
			}
			mScroll += delta * scrollWheelFactor;
		}
	}

	private void Update()
	{
		float deltaTime = RealTime.deltaTime;
		if (mPressed)
		{
			SpringPosition component = GetComponent<SpringPosition>();
			if (component != null)
			{
				component.enabled = false;
			}
			mScroll = 0f;
		}
		else
		{
			mMomentum += scale * (mScroll * 20f);
			mScroll = NGUIMath.SpringLerp(mScroll, 0f, 20f, deltaTime);
			if (mMomentum.magnitude > 0.01f)
			{
				mTrans.localPosition += (Vector3)NGUIMath.SpringDampen(ref mMomentum, 9f, deltaTime);
				mBounds = NGUIMath.CalculateAbsoluteWidgetBounds(rootForBounds);
				if (!ConstrainToBounds(dragEffect == UIDragObject.DragEffect.None))
				{
					SpringPosition component2 = GetComponent<SpringPosition>();
					if (component2 != null)
					{
						component2.enabled = false;
					}
				}
				return;
			}
			mScroll = 0f;
		}
		NGUIMath.SpringDampen(ref mMomentum, 9f, deltaTime);
	}
}
[AddComponentMenu("NGUI/Interaction/Event Trigger")]
public class UIEventTrigger : MonoBehaviour
{
	public static UIEventTrigger current;

	public List<EventDelegate> onHoverOver = new List<EventDelegate>();

	public List<EventDelegate> onHoverOut = new List<EventDelegate>();

	public List<EventDelegate> onPress = new List<EventDelegate>();

	public List<EventDelegate> onRelease = new List<EventDelegate>();

	public List<EventDelegate> onSelect = new List<EventDelegate>();

	public List<EventDelegate> onDeselect = new List<EventDelegate>();

	public List<EventDelegate> onClick = new List<EventDelegate>();

	public List<EventDelegate> onDoubleClick = new List<EventDelegate>();

	public List<EventDelegate> onDragStart = new List<EventDelegate>();

	public List<EventDelegate> onDragEnd = new List<EventDelegate>();

	public List<EventDelegate> onDragOver = new List<EventDelegate>();

	public List<EventDelegate> onDragOut = new List<EventDelegate>();

	public List<EventDelegate> onDrag = new List<EventDelegate>();

	private void OnHover(bool isOver)
	{
		if (!(current != null))
		{
			current = this;
			if (isOver)
			{
				EventDelegate.Execute(onHoverOver);
			}
			else
			{
				EventDelegate.Execute(onHoverOut);
			}
			current = null;
		}
	}

	private void OnPress(bool pressed)
	{
		if (!(current != null))
		{
			current = this;
			if (pressed)
			{
				EventDelegate.Execute(onPress);
			}
			else
			{
				EventDelegate.Execute(onRelease);
			}
			current = null;
		}
	}

	private void OnSelect(bool selected)
	{
		if (!(current != null))
		{
			current = this;
			if (selected)
			{
				EventDelegate.Execute(onSelect);
			}
			else
			{
				EventDelegate.Execute(onDeselect);
			}
			current = null;
		}
	}

	private void OnClick()
	{
		if (!(current != null))
		{
			current = this;
			EventDelegate.Execute(onClick);
			current = null;
		}
	}

	private void OnDoubleClick()
	{
		if (!(current != null))
		{
			current = this;
			EventDelegate.Execute(onDoubleClick);
			current = null;
		}
	}

	private void OnDragStart()
	{
		if (!(current != null))
		{
			current = this;
			EventDelegate.Execute(onDragStart);
			current = null;
		}
	}

	private void OnDragEnd()
	{
		if (!(current != null))
		{
			current = this;
			EventDelegate.Execute(onDragEnd);
			current = null;
		}
	}

	private void OnDragOver(GameObject go)
	{
		if (!(current != null))
		{
			current = this;
			EventDelegate.Execute(onDragOver);
			current = null;
		}
	}

	private void OnDragOut(GameObject go)
	{
		if (!(current != null))
		{
			current = this;
			EventDelegate.Execute(onDragOut);
			current = null;
		}
	}

	private void OnDrag(Vector2 delta)
	{
		if (!(current != null))
		{
			current = this;
			EventDelegate.Execute(onDragOut);
			current = null;
		}
	}
}
[AddComponentMenu("NGUI/Interaction/Forward Events (Legacy)")]
public class UIForwardEvents : MonoBehaviour
{
	public GameObject target;

	public bool onHover;

	public bool onPress;

	public bool onClick;

	public bool onDoubleClick;

	public bool onSelect;

	public bool onDrag;

	public bool onDrop;

	public bool onSubmit;

	public bool onScroll;

	private void OnHover(bool isOver)
	{
		if (onHover && target != null)
		{
			target.SendMessage("OnHover", isOver, SendMessageOptions.DontRequireReceiver);
		}
	}

	private void OnPress(bool pressed)
	{
		if (onPress && target != null)
		{
			target.SendMessage("OnPress", pressed, SendMessageOptions.DontRequireReceiver);
		}
	}

	private void OnClick()
	{
		if (onClick && target != null)
		{
			target.SendMessage("OnClick", SendMessageOptions.DontRequireReceiver);
		}
	}

	private void OnDoubleClick()
	{
		if (onDoubleClick && target != null)
		{
			target.SendMessage("OnDoubleClick", SendMessageOptions.DontRequireReceiver);
		}
	}

	private void OnSelect(bool selected)
	{
		if (onSelect && target != null)
		{
			target.SendMessage("OnSelect", selected, SendMessageOptions.DontRequireReceiver);
		}
	}

	private void OnDrag(Vector2 delta)
	{
		if (onDrag && target != null)
		{
			target.SendMessage("OnDrag", delta, SendMessageOptions.DontRequireReceiver);
		}
	}

	private void OnDrop(GameObject go)
	{
		if (onDrop && target != null)
		{
			target.SendMessage("OnDrop", go, SendMessageOptions.DontRequireReceiver);
		}
	}

	private void OnSubmit()
	{
		if (onSubmit && target != null)
		{
			target.SendMessage("OnSubmit", SendMessageOptions.DontRequireReceiver);
		}
	}

	private void OnScroll(float delta)
	{
		if (onScroll && target != null)
		{
			target.SendMessage("OnScroll", delta, SendMessageOptions.DontRequireReceiver);
		}
	}
}
[AddComponentMenu("NGUI/Interaction/Grid")]
public class UIGrid : UIWidgetContainer
{
	public delegate void OnReposition();

	public enum Arrangement
	{
		Horizontal,
		Vertical,
		CellSnap
	}

	public enum Sorting
	{
		None,
		Alphabetic,
		Horizontal,
		Vertical,
		Custom
	}

	public Arrangement arrangement;

	public Sorting sorting;

	public UIWidget.Pivot pivot;

	public int maxPerLine;

	public float cellWidth = 200f;

	public float cellHeight = 200f;

	public bool animateSmoothly;

	public bool hideInactive;

	public bool keepWithinPanel;

	public OnReposition onReposition;

	public Comparison<Transform> onCustomSort;

	[HideInInspector]
	[SerializeField]
	private bool sorted;

	protected bool mReposition;

	protected UIPanel mPanel;

	protected bool mInitDone;

	public bool repositionNow
	{
		set
		{
			if (value)
			{
				mReposition = true;
				base.enabled = true;
			}
		}
	}

	public List<Transform> GetChildList()
	{
		Transform transform = base.transform;
		List<Transform> list = new List<Transform>();
		for (int i = 0; i < transform.childCount; i++)
		{
			Transform child = transform.GetChild(i);
			if (!hideInactive || ((bool)child && NGUITools.GetActive(child.gameObject)))
			{
				list.Add(child);
			}
		}
		if (sorting != 0 && arrangement != Arrangement.CellSnap)
		{
			if (sorting == Sorting.Alphabetic)
			{
				list.Sort(SortByName);
			}
			else if (sorting == Sorting.Horizontal)
			{
				list.Sort(SortHorizontal);
			}
			else if (sorting == Sorting.Vertical)
			{
				list.Sort(SortVertical);
			}
			else if (onCustomSort != null)
			{
				list.Sort(onCustomSort);
			}
			else
			{
				Sort(list);
			}
		}
		return list;
	}

	public Transform GetChild(int index)
	{
		List<Transform> childList = GetChildList();
		return (index >= childList.Count) ? null : childList[index];
	}

	public int GetIndex(Transform trans)
	{
		return GetChildList().IndexOf(trans);
	}

	public void AddChild(Transform trans)
	{
		AddChild(trans, sort: true);
	}

	public void AddChild(Transform trans, bool sort)
	{
		if (trans != null)
		{
			trans.parent = base.transform;
			ResetPosition(GetChildList());
		}
	}

	public bool RemoveChild(Transform t)
	{
		List<Transform> childList = GetChildList();
		if (childList.Remove(t))
		{
			ResetPosition(childList);
			return true;
		}
		return false;
	}

	protected virtual void Init()
	{
		mInitDone = true;
		mPanel = NGUITools.FindInParents<UIPanel>(base.gameObject);
	}

	protected virtual void Start()
	{
		if (!mInitDone)
		{
			Init();
		}
		bool flag = animateSmoothly;
		animateSmoothly = false;
		Reposition();
		animateSmoothly = flag;
		base.enabled = false;
	}

	protected virtual void Update()
	{
		Reposition();
		base.enabled = false;
	}

	private void OnValidate()
	{
		if (!Application.isPlaying && NGUITools.GetActive(this))
		{
			Reposition();
		}
	}

	public static int SortByName(Transform a, Transform b)
	{
		return string.Compare(a.name, b.name);
	}

	public static int SortHorizontal(Transform a, Transform b)
	{
		return a.localPosition.x.CompareTo(b.localPosition.x);
	}

	public static int SortVertical(Transform a, Transform b)
	{
		return b.localPosition.y.CompareTo(a.localPosition.y);
	}

	protected virtual void Sort(List<Transform> list)
	{
	}

	[ContextMenu("Execute")]
	public virtual void Reposition()
	{
		if (Application.isPlaying && !mInitDone && NGUITools.GetActive(base.gameObject))
		{
			Init();
		}
		if (sorted)
		{
			sorted = false;
			if (sorting == Sorting.None)
			{
				sorting = Sorting.Alphabetic;
			}
			NGUITools.SetDirty(this);
		}
		List<Transform> childList = GetChildList();
		ResetPosition(childList);
		if (keepWithinPanel)
		{
			ConstrainWithinPanel();
		}
		if (onReposition != null)
		{
			onReposition();
		}
	}

	public void ConstrainWithinPanel()
	{
		if (mPanel != null)
		{
			mPanel.ConstrainTargetToBounds(base.transform, immediate: true);
			UIScrollView component = mPanel.GetComponent<UIScrollView>();
			if (component != null)
			{
				component.UpdateScrollbars(recalculateBounds: true);
			}
		}
	}

	protected void ResetPosition(List<Transform> list)
	{
		mReposition = false;
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		Transform transform = base.transform;
		int i = 0;
		for (int count = list.Count; i < count; i++)
		{
			Transform transform2 = list[i];
			Vector3 vector = transform2.localPosition;
			float z = vector.z;
			if (arrangement == Arrangement.CellSnap)
			{
				if (cellWidth > 0f)
				{
					vector.x = Mathf.Round(vector.x / cellWidth) * cellWidth;
				}
				if (cellHeight > 0f)
				{
					vector.y = Mathf.Round(vector.y / cellHeight) * cellHeight;
				}
			}
			else
			{
				vector = ((arrangement != 0) ? new Vector3(cellWidth * (float)num2, (0f - cellHeight) * (float)num, z) : new Vector3(cellWidth * (float)num, (0f - cellHeight) * (float)num2, z));
			}
			if (animateSmoothly && Application.isPlaying && Vector3.SqrMagnitude(transform2.localPosition - vector) >= 0.0001f)
			{
				SpringPosition springPosition = SpringPosition.Begin(transform2.gameObject, vector, 15f);
				springPosition.updateScrollView = true;
				springPosition.ignoreTimeScale = true;
			}
			else
			{
				transform2.localPosition = vector;
			}
			num3 = Mathf.Max(num3, num);
			num4 = Mathf.Max(num4, num2);
			if (++num >= maxPerLine && maxPerLine > 0)
			{
				num = 0;
				num2++;
			}
		}
		if (pivot == UIWidget.Pivot.TopLeft)
		{
			return;
		}
		Vector2 pivotOffset = NGUIMath.GetPivotOffset(pivot);
		float num5;
		float num6;
		if (arrangement == Arrangement.Horizontal)
		{
			num5 = Mathf.Lerp(0f, (float)num3 * cellWidth, pivotOffset.x);
			num6 = Mathf.Lerp((float)(-num4) * cellHeight, 0f, pivotOffset.y);
		}
		else
		{
			num5 = Mathf.Lerp(0f, (float)num4 * cellWidth, pivotOffset.x);
			num6 = Mathf.Lerp((float)(-num3) * cellHeight, 0f, pivotOffset.y);
		}
		for (int j = 0; j < transform.childCount; j++)
		{
			Transform child = transform.GetChild(j);
			SpringPosition component = child.GetComponent<SpringPosition>();
			if (component != null)
			{
				component.target.x -= num5;
				component.target.y -= num6;
				continue;
			}
			Vector3 localPosition = child.localPosition;
			localPosition.x -= num5;
			localPosition.y -= num6;
			child.localPosition = localPosition;
		}
	}
}
[AddComponentMenu("NGUI/UI/Image Button")]
public class UIImageButton : MonoBehaviour
{
	public UISprite target;

	public string normalSprite;

	public string hoverSprite;

	public string pressedSprite;

	public string disabledSprite;

	public bool pixelSnap = true;

	public bool isEnabled
	{
		get
		{
			Collider component = GetComponent<Collider>();
			return (bool)component && component.enabled;
		}
		set
		{
			Collider component = GetComponent<Collider>();
			if ((bool)component && component.enabled != value)
			{
				component.enabled = value;
				UpdateImage();
			}
		}
	}

	private void OnEnable()
	{
		if (target == null)
		{
			target = GetComponentInChildren<UISprite>();
		}
		UpdateImage();
	}

	private void OnValidate()
	{
		if (target != null)
		{
			if (string.IsNullOrEmpty(normalSprite))
			{
				normalSprite = target.spriteName;
			}
			if (string.IsNullOrEmpty(hoverSprite))
			{
				hoverSprite = target.spriteName;
			}
			if (string.IsNullOrEmpty(pressedSprite))
			{
				pressedSprite = target.spriteName;
			}
			if (string.IsNullOrEmpty(disabledSprite))
			{
				disabledSprite = target.spriteName;
			}
		}
	}

	private void UpdateImage()
	{
		if (target != null)
		{
			if (isEnabled)
			{
				SetSprite((!UICamera.IsHighlighted(base.gameObject)) ? normalSprite : hoverSprite);
			}
			else
			{
				SetSprite(disabledSprite);
			}
		}
	}

	private void OnHover(bool isOver)
	{
		if (isEnabled && target != null)
		{
			SetSprite((!isOver) ? normalSprite : hoverSprite);
		}
	}

	private void OnPress(bool pressed)
	{
		if (pressed)
		{
			SetSprite(pressedSprite);
		}
		else
		{
			UpdateImage();
		}
	}

	private void SetSprite(string sprite)
	{
		if (!(target.atlas == null) && target.atlas.GetSprite(sprite) != null)
		{
			target.spriteName = sprite;
			if (pixelSnap)
			{
				target.MakePixelPerfect();
			}
		}
	}
}
[AddComponentMenu("NGUI/Interaction/Key Binding")]
public class UIKeyBinding : MonoBehaviour
{
	public enum Action
	{
		PressAndClick,
		Select,
		All
	}

	public enum Modifier
	{
		None,
		Shift,
		Control,
		Alt
	}

	public KeyCode keyCode;

	public Modifier modifier;

	public Action action;

	private bool mIgnoreUp;

	private bool mIsInput;

	private bool mPress;

	private void Start()
	{
		UIInput component = GetComponent<UIInput>();
		mIsInput = component != null;
		if (component != null)
		{
			EventDelegate.Add(component.onSubmit, OnSubmit);
		}
	}

	private void OnSubmit()
	{
		if (UICamera.currentKey == keyCode && IsModifierActive())
		{
			mIgnoreUp = true;
		}
	}

	private bool IsModifierActive()
	{
		if (modifier == Modifier.None)
		{
			return true;
		}
		if (modifier == Modifier.Alt)
		{
			if (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt))
			{
				return true;
			}
		}
		else if (modifier == Modifier.Control)
		{
			if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl))
			{
				return true;
			}
		}
		else if (modifier == Modifier.Shift && (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)))
		{
			return true;
		}
		return false;
	}

	private void Update()
	{
		if (keyCode == KeyCode.None || !IsModifierActive())
		{
			return;
		}
		if (action == Action.PressAndClick || action == Action.All)
		{
			if (UICamera.inputHasFocus)
			{
				return;
			}
			UICamera.currentTouch = UICamera.controller;
			UICamera.currentScheme = UICamera.ControlScheme.Mouse;
			UICamera.currentTouch.current = base.gameObject;
			if (Input.GetKeyDown(keyCode))
			{
				mPress = true;
				UICamera.Notify(base.gameObject, "OnPress", true);
			}
			if (Input.GetKeyUp(keyCode))
			{
				UICamera.Notify(base.gameObject, "OnPress", false);
				if (mPress)
				{
					UICamera.Notify(base.gameObject, "OnClick", null);
					mPress = false;
				}
			}
			UICamera.currentTouch.current = null;
		}
		if ((action != Action.Select && action != Action.All) || !Input.GetKeyUp(keyCode))
		{
			return;
		}
		if (mIsInput)
		{
			if (!mIgnoreUp && !UICamera.inputHasFocus)
			{
				UICamera.selectedObject = base.gameObject;
			}
			mIgnoreUp = false;
		}
		else
		{
			UICamera.selectedObject = base.gameObject;
		}
	}
}
[AddComponentMenu("NGUI/Interaction/Key Navigation")]
public class UIKeyNavigation : MonoBehaviour
{
	public enum Constraint
	{
		None,
		Vertical,
		Horizontal,
		Explicit
	}

	public static BetterList<UIKeyNavigation> list = new BetterList<UIKeyNavigation>();

	public Constraint constraint;

	public GameObject onUp;

	public GameObject onDown;

	public GameObject onLeft;

	public GameObject onRight;

	public GameObject onClick;

	public bool startsSelected;

	protected virtual void OnEnable()
	{
		list.Add(this);
		if (startsSelected && (UICamera.selectedObject == null || !NGUITools.GetActive(UICamera.selectedObject)))
		{
			UICamera.currentScheme = UICamera.ControlScheme.Controller;
			UICamera.selectedObject = base.gameObject;
		}
	}

	protected virtual void OnDisable()
	{
		list.Remove(this);
	}

	protected GameObject GetLeft()
	{
		if (NGUITools.GetActive(onLeft))
		{
			return onLeft;
		}
		if (constraint == Constraint.Vertical || constraint == Constraint.Explicit)
		{
			return null;
		}
		return Get(Vector3.left, horizontal: true);
	}

	private GameObject GetRight()
	{
		if (NGUITools.GetActive(onRight))
		{
			return onRight;
		}
		if (constraint == Constraint.Vertical || constraint == Constraint.Explicit)
		{
			return null;
		}
		return Get(Vector3.right, horizontal: true);
	}

	protected GameObject GetUp()
	{
		if (NGUITools.GetActive(onUp))
		{
			return onUp;
		}
		if (constraint == Constraint.Horizontal || constraint == Constraint.Explicit)
		{
			return null;
		}
		return Get(Vector3.up, horizontal: false);
	}

	protected GameObject GetDown()
	{
		if (NGUITools.GetActive(onDown))
		{
			return onDown;
		}
		if (constraint == Constraint.Horizontal || constraint == Constraint.Explicit)
		{
			return null;
		}
		return Get(Vector3.down, horizontal: false);
	}

	protected GameObject Get(Vector3 myDir, bool horizontal)
	{
		Transform transform = base.transform;
		myDir = transform.TransformDirection(myDir);
		Vector3 center = GetCenter(base.gameObject);
		float num = float.MaxValue;
		GameObject result = null;
		for (int i = 0; i < list.size; i++)
		{
			UIKeyNavigation uIKeyNavigation = list[i];
			if (uIKeyNavigation == this)
			{
				continue;
			}
			UIButton component = uIKeyNavigation.GetComponent<UIButton>();
			if (component != null && !component.isEnabled)
			{
				continue;
			}
			Vector3 direction = GetCenter(uIKeyNavigation.gameObject) - center;
			float num2 = Vector3.Dot(myDir, direction.normalized);
			if (!(num2 < 0.707f))
			{
				direction = transform.InverseTransformDirection(direction);
				if (horizontal)
				{
					direction.y *= 2f;
				}
				else
				{
					direction.x *= 2f;
				}
				float sqrMagnitude = direction.sqrMagnitude;
				if (!(sqrMagnitude > num))
				{
					result = uIKeyNavigation.gameObject;
					num = sqrMagnitude;
				}
			}
		}
		return result;
	}

	protected static Vector3 GetCenter(GameObject go)
	{
		UIWidget component = go.GetComponent<UIWidget>();
		if (component != null)
		{
			Vector3[] worldCorners = component.worldCorners;
			return (worldCorners[0] + worldCorners[2]) * 0.5f;
		}
		return go.transform.position;
	}

	protected virtual void OnKey(KeyCode key)
	{
		if (!NGUITools.GetActive(this))
		{
			return;
		}
		GameObject gameObject = null;
		switch (key)
		{
		case KeyCode.LeftArrow:
			gameObject = GetLeft();
			break;
		case KeyCode.RightArrow:
			gameObject = GetRight();
			break;
		case KeyCode.UpArrow:
			gameObject = GetUp();
			break;
		case KeyCode.DownArrow:
			gameObject = GetDown();
			break;
		case KeyCode.Tab:
			if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift))
			{
				gameObject = GetLeft();
				if (gameObject == null)
				{
					gameObject = GetUp();
				}
				if (gameObject == null)
				{
					gameObject = GetDown();
				}
				if (gameObject == null)
				{
					gameObject = GetRight();
				}
			}
			else
			{
				gameObject = GetRight();
				if (gameObject == null)
				{
					gameObject = GetDown();
				}
				if (gameObject == null)
				{
					gameObject = GetUp();
				}
				if (gameObject == null)
				{
					gameObject = GetLeft();
				}
			}
			break;
		}
		if (gameObject != null)
		{
			UICamera.selectedObject = gameObject;
		}
	}

	protected virtual void OnClick()
	{
		if (NGUITools.GetActive(this) && NGUITools.GetActive(onClick))
		{
			UICamera.selectedObject = onClick;
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/Interaction/Play Animation")]
public class UIPlayAnimation : MonoBehaviour
{
	public static UIPlayAnimation current;

	public Animation target;

	public Animator animator;

	public string clipName;

	public Trigger trigger;

	public Direction playDirection = Direction.Forward;

	public bool resetOnPlay;

	public bool clearSelection;

	public EnableCondition ifDisabledOnPlay;

	public DisableCondition disableWhenFinished;

	public List<EventDelegate> onFinished = new List<EventDelegate>();

	[HideInInspector]
	[SerializeField]
	private GameObject eventReceiver;

	[HideInInspector]
	[SerializeField]
	private string callWhenFinished;

	private bool mStarted;

	private bool mActivated;

	private bool dragHighlight;

	private bool dualState => trigger == Trigger.OnPress || trigger == Trigger.OnHover;

	private void Awake()
	{
		UIButton component = GetComponent<UIButton>();
		if (component != null)
		{
			dragHighlight = component.dragHighlight;
		}
		if (eventReceiver != null && EventDelegate.IsValid(onFinished))
		{
			eventReceiver = null;
			callWhenFinished = null;
		}
	}

	private void Start()
	{
		mStarted = true;
		if (target == null && animator == null)
		{
			animator = GetComponentInChildren<Animator>();
		}
		if (animator != null)
		{
			if (animator.enabled)
			{
				animator.enabled = false;
			}
			return;
		}
		if (target == null)
		{
			target = GetComponentInChildren<Animation>();
		}
		if (target != null && target.enabled)
		{
			target.enabled = false;
		}
	}

	private void OnEnable()
	{
		if (mStarted)
		{
			OnHover(UICamera.IsHighlighted(base.gameObject));
		}
		if (UICamera.currentTouch != null)
		{
			if (trigger == Trigger.OnPress || trigger == Trigger.OnPressTrue)
			{
				mActivated = UICamera.currentTouch.pressed == base.gameObject;
			}
			if (trigger == Trigger.OnHover || trigger == Trigger.OnHoverTrue)
			{
				mActivated = UICamera.currentTouch.current == base.gameObject;
			}
		}
		UIToggle component = GetComponent<UIToggle>();
		if (component != null)
		{
			EventDelegate.Add(component.onChange, OnToggle);
		}
	}

	private void OnDisable()
	{
		UIToggle component = GetComponent<UIToggle>();
		if (component != null)
		{
			EventDelegate.Remove(component.onChange, OnToggle);
		}
	}

	private void OnHover(bool isOver)
	{
		if (base.enabled && (trigger == Trigger.OnHover || (trigger == Trigger.OnHoverTrue && isOver) || (trigger == Trigger.OnHoverFalse && !isOver)))
		{
			Play(isOver, dualState);
		}
	}

	private void OnPress(bool isPressed)
	{
		if (base.enabled && UICamera.currentTouchID >= -1 && (trigger == Trigger.OnPress || (trigger == Trigger.OnPressTrue && isPressed) || (trigger == Trigger.OnPressFalse && !isPressed)))
		{
			Play(isPressed, dualState);
		}
	}

	private void OnClick()
	{
		if (UICamera.currentTouchID >= -1 && base.enabled && trigger == Trigger.OnClick)
		{
			Play(forward: true, onlyIfDifferent: false);
		}
	}

	private void OnDoubleClick()
	{
		if (UICamera.currentTouchID >= -1 && base.enabled && trigger == Trigger.OnDoubleClick)
		{
			Play(forward: true, onlyIfDifferent: false);
		}
	}

	private void OnSelect(bool isSelected)
	{
		if (base.enabled && (trigger == Trigger.OnSelect || (trigger == Trigger.OnSelectTrue && isSelected) || (trigger == Trigger.OnSelectFalse && !isSelected)))
		{
			Play(isSelected, dualState);
		}
	}

	private void OnToggle()
	{
		if (base.enabled && !(UIToggle.current == null) && (trigger == Trigger.OnActivate || (trigger == Trigger.OnActivateTrue && UIToggle.current.value) || (trigger == Trigger.OnActivateFalse && !UIToggle.current.value)))
		{
			Play(UIToggle.current.value, dualState);
		}
	}

	private void OnDragOver()
	{
		if (base.enabled && dualState)
		{
			if (UICamera.currentTouch.dragged == base.gameObject)
			{
				Play(forward: true, onlyIfDifferent: true);
			}
			else if (dragHighlight && trigger == Trigger.OnPress)
			{
				Play(forward: true, onlyIfDifferent: true);
			}
		}
	}

	private void OnDragOut()
	{
		if (base.enabled && dualState && UICamera.hoveredObject != base.gameObject)
		{
			Play(forward: false, onlyIfDifferent: true);
		}
	}

	private void OnDrop(GameObject go)
	{
		if (base.enabled && trigger == Trigger.OnPress && UICamera.currentTouch.dragged != base.gameObject)
		{
			Play(forward: false, onlyIfDifferent: true);
		}
	}

	public void Play(bool forward)
	{
		Play(forward, onlyIfDifferent: true);
	}

	public void Play(bool forward, bool onlyIfDifferent)
	{
		if (!target && !animator)
		{
			return;
		}
		if (onlyIfDifferent)
		{
			if (mActivated == forward)
			{
				return;
			}
			mActivated = forward;
		}
		if (clearSelection && UICamera.selectedObject == base.gameObject)
		{
			UICamera.selectedObject = null;
		}
		int num = 0 - playDirection;
		Direction direction = ((!forward) ? ((Direction)num) : playDirection);
		ActiveAnimation activeAnimation = ((!target) ? ActiveAnimation.Play(animator, clipName, direction, ifDisabledOnPlay, disableWhenFinished) : ActiveAnimation.Play(target, clipName, direction, ifDisabledOnPlay, disableWhenFinished));
		if (activeAnimation != null)
		{
			if (resetOnPlay)
			{
				activeAnimation.Reset();
			}
			for (int i = 0; i < onFinished.Count; i++)
			{
				EventDelegate.Add(activeAnimation.onFinished, OnFinished, oneShot: true);
			}
		}
	}

	private void OnFinished()
	{
		if (current == null)
		{
			current = this;
			EventDelegate.Execute(onFinished);
			if (eventReceiver != null && !string.IsNullOrEmpty(callWhenFinished))
			{
				eventReceiver.SendMessage(callWhenFinished, SendMessageOptions.DontRequireReceiver);
			}
			eventReceiver = null;
			current = null;
		}
	}
}
[AddComponentMenu("NGUI/Interaction/Play Sound")]
public class UIPlaySound : MonoBehaviour
{
	public enum Trigger
	{
		OnClick,
		OnMouseOver,
		OnMouseOut,
		OnPress,
		OnRelease,
		Custom,
		OnEnable,
		OnDisable
	}

	public AudioClip audioClip;

	public Trigger trigger;

	[Range(0f, 1f)]
	public float volume = 1f;

	[Range(0f, 2f)]
	public float pitch = 1f;

	private bool mIsOver;

	private bool canPlay
	{
		get
		{
			if (!base.enabled)
			{
				return false;
			}
			UIButton component = GetComponent<UIButton>();
			return component == null || component.isEnabled;
		}
	}

	private void OnEnable()
	{
		if (trigger == Trigger.OnEnable)
		{
			NGUITools.PlaySound(audioClip, volume, pitch);
		}
	}

	private void OnDisable()
	{
		if (trigger == Trigger.OnDisable)
		{
			NGUITools.PlaySound(audioClip, volume, pitch);
		}
	}

	private void OnHover(bool isOver)
	{
		if (trigger == Trigger.OnMouseOver)
		{
			if (mIsOver == isOver)
			{
				return;
			}
			mIsOver = isOver;
		}
		if (canPlay && ((isOver && trigger == Trigger.OnMouseOver) || (!isOver && trigger == Trigger.OnMouseOut)))
		{
			NGUITools.PlaySound(audioClip, volume, pitch);
		}
	}

	private void OnPress(bool isPressed)
	{
		if (trigger == Trigger.OnPress)
		{
			if (mIsOver == isPressed)
			{
				return;
			}
			mIsOver = isPressed;
		}
		if (canPlay && ((isPressed && trigger == Trigger.OnPress) || (!isPressed && trigger == Trigger.OnRelease)))
		{
			NGUITools.PlaySound(audioClip, volume, pitch);
		}
	}

	private void OnClick()
	{
		if (canPlay && trigger == Trigger.OnClick)
		{
			NGUITools.PlaySound(audioClip, volume, pitch);
		}
	}

	private void OnSelect(bool isSelected)
	{
		if (canPlay && (!isSelected || UICamera.currentScheme == UICamera.ControlScheme.Controller))
		{
			OnHover(isSelected);
		}
	}

	public void Play()
	{
		NGUITools.PlaySound(audioClip, volume, pitch);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/Interaction/Play Tween")]
public class UIPlayTween : MonoBehaviour
{
	public static UIPlayTween current;

	public GameObject tweenTarget;

	public int tweenGroup;

	public Trigger trigger;

	public Direction playDirection = Direction.Forward;

	public bool resetOnPlay;

	public bool resetIfDisabled;

	public EnableCondition ifDisabledOnPlay;

	public DisableCondition disableWhenFinished;

	public bool includeChildren;

	public List<EventDelegate> onFinished = new List<EventDelegate>();

	[HideInInspector]
	[SerializeField]
	private GameObject eventReceiver;

	[HideInInspector]
	[SerializeField]
	private string callWhenFinished;

	private UITweener[] mTweens;

	private bool mStarted;

	private int mActive;

	private bool mActivated;

	private void Awake()
	{
		if (eventReceiver != null && EventDelegate.IsValid(onFinished))
		{
			eventReceiver = null;
			callWhenFinished = null;
		}
	}

	private void Start()
	{
		mStarted = true;
		if (tweenTarget == null)
		{
			tweenTarget = base.gameObject;
		}
	}

	private void OnEnable()
	{
		if (mStarted)
		{
			OnHover(UICamera.IsHighlighted(base.gameObject));
		}
		if (UICamera.currentTouch != null)
		{
			if (trigger == Trigger.OnPress || trigger == Trigger.OnPressTrue)
			{
				mActivated = UICamera.currentTouch.pressed == base.gameObject;
			}
			if (trigger == Trigger.OnHover || trigger == Trigger.OnHoverTrue)
			{
				mActivated = UICamera.currentTouch.current == base.gameObject;
			}
		}
		UIToggle component = GetComponent<UIToggle>();
		if (component != null)
		{
			EventDelegate.Add(component.onChange, OnToggle);
		}
	}

	private void OnDisable()
	{
		UIToggle component = GetComponent<UIToggle>();
		if (component != null)
		{
			EventDelegate.Remove(component.onChange, OnToggle);
		}
	}

	private void OnDragOver()
	{
		if (trigger == Trigger.OnHover)
		{
			OnHover(isOver: true);
		}
	}

	private void OnHover(bool isOver)
	{
		if (base.enabled && (trigger == Trigger.OnHover || (trigger == Trigger.OnHoverTrue && isOver) || (trigger == Trigger.OnHoverFalse && !isOver)))
		{
			mActivated = isOver && trigger == Trigger.OnHover;
			Play(isOver);
		}
	}

	private void OnDragOut()
	{
		if (base.enabled && mActivated)
		{
			mActivated = false;
			Play(forward: false);
		}
	}

	private void OnPress(bool isPressed)
	{
		if (base.enabled && (trigger == Trigger.OnPress || (trigger == Trigger.OnPressTrue && isPressed) || (trigger == Trigger.OnPressFalse && !isPressed)))
		{
			mActivated = isPressed && trigger == Trigger.OnPress;
			Play(isPressed);
		}
	}

	private void OnClick()
	{
		if (base.enabled && trigger == Trigger.OnClick)
		{
			Play(forward: true);
		}
	}

	private void OnDoubleClick()
	{
		if (base.enabled && trigger == Trigger.OnDoubleClick)
		{
			Play(forward: true);
		}
	}

	private void OnSelect(bool isSelected)
	{
		if (base.enabled && (trigger == Trigger.OnSelect || (trigger == Trigger.OnSelectTrue && isSelected) || (trigger == Trigger.OnSelectFalse && !isSelected)))
		{
			mActivated = isSelected && trigger == Trigger.OnSelect;
			Play(isSelected);
		}
	}

	private void OnToggle()
	{
		if (base.enabled && !(UIToggle.current == null) && (trigger == Trigger.OnActivate || (trigger == Trigger.OnActivateTrue && UIToggle.current.value) || (trigger == Trigger.OnActivateFalse && !UIToggle.current.value)))
		{
			Play(UIToggle.current.value);
		}
	}

	private void Update()
	{
		if (disableWhenFinished == DisableCondition.DoNotDisable || mTweens == null)
		{
			return;
		}
		bool flag = true;
		bool flag2 = true;
		int i = 0;
		for (int num = mTweens.Length; i < num; i++)
		{
			UITweener uITweener = mTweens[i];
			if (uITweener.tweenGroup == tweenGroup)
			{
				if (uITweener.enabled)
				{
					flag = false;
					break;
				}
				if (uITweener.direction != (Direction)disableWhenFinished)
				{
					flag2 = false;
				}
			}
		}
		if (flag)
		{
			if (flag2)
			{
				NGUITools.SetActive(tweenTarget, state: false);
			}
			mTweens = null;
		}
	}

	public void Play(bool forward)
	{
		mActive = 0;
		GameObject gameObject = ((!(tweenTarget == null)) ? tweenTarget : base.gameObject);
		if (!NGUITools.GetActive(gameObject))
		{
			if (ifDisabledOnPlay != EnableCondition.EnableThenPlay)
			{
				return;
			}
			NGUITools.SetActive(gameObject, state: true);
		}
		mTweens = ((!includeChildren) ? gameObject.GetComponents<UITweener>() : gameObject.GetComponentsInChildren<UITweener>());
		if (mTweens.Length == 0)
		{
			if (disableWhenFinished != 0)
			{
				NGUITools.SetActive(tweenTarget, state: false);
			}
			return;
		}
		bool flag = false;
		if (playDirection == Direction.Reverse)
		{
			forward = !forward;
		}
		int i = 0;
		for (int num = mTweens.Length; i < num; i++)
		{
			UITweener uITweener = mTweens[i];
			if (uITweener.tweenGroup != tweenGroup)
			{
				continue;
			}
			if (!flag && !NGUITools.GetActive(gameObject))
			{
				flag = true;
				NGUITools.SetActive(gameObject, state: true);
			}
			mActive++;
			if (playDirection == Direction.Toggle)
			{
				EventDelegate.Add(uITweener.onFinished, OnFinished, oneShot: true);
				uITweener.Toggle();
				continue;
			}
			if (resetOnPlay || (resetIfDisabled && !uITweener.enabled))
			{
				uITweener.Play(forward);
				uITweener.ResetToBeginning();
			}
			EventDelegate.Add(uITweener.onFinished, OnFinished, oneShot: true);
			uITweener.Play(forward);
		}
	}

	private void OnFinished()
	{
		if (--mActive == 0 && current == null)
		{
			current = this;
			EventDelegate.Execute(onFinished);
			if (eventReceiver != null && !string.IsNullOrEmpty(callWhenFinished))
			{
				eventReceiver.SendMessage(callWhenFinished, SendMessageOptions.DontRequireReceiver);
			}
			eventReceiver = null;
			current = null;
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/Interaction/Popup List")]
public class UIPopupList : UIWidgetContainer
{
	public enum Position
	{
		Auto,
		Above,
		Below
	}

	public enum OpenOn
	{
		ClickOrTap,
		RightClick,
		DoubleClick,
		Manual
	}

	public delegate void LegacyEvent(string val);

	public static UIPopupList current;

	private const float animSpeed = 0.15f;

	public UIAtlas atlas;

	public UIFont bitmapFont;

	public UnityEngine.Font trueTypeFont;

	public int fontSize = 16;

	public UnityEngine.FontStyle fontStyle;

	public string backgroundSprite;

	public string highlightSprite;

	public Position position;

	public NGUIText.Alignment alignment = NGUIText.Alignment.Left;

	public List<string> items = new List<string>();

	public List<object> itemData = new List<object>();

	public Vector2 padding = new Vector3(4f, 4f);

	public UnityEngine.Color textColor = UnityEngine.Color.white;

	public UnityEngine.Color backgroundColor = UnityEngine.Color.white;

	public UnityEngine.Color highlightColor = new UnityEngine.Color(0.88235295f, 40f / 51f, 0.5882353f, 1f);

	public bool isAnimated = true;

	public bool isLocalized;

	public OpenOn openOn;

	public List<EventDelegate> onChange = new List<EventDelegate>();

	[HideInInspector]
	[SerializeField]
	private string mSelectedItem;

	private UIPanel mPanel;

	private GameObject mChild;

	private UISprite mBackground;

	private UISprite mHighlight;

	private UILabel mHighlightedLabel;

	private List<UILabel> mLabelList = new List<UILabel>();

	private float mBgBorder;

	[HideInInspector]
	[SerializeField]
	private GameObject eventReceiver;

	[HideInInspector]
	[SerializeField]
	private string functionName = "OnSelectionChange";

	[HideInInspector]
	[SerializeField]
	private float textScale;

	[HideInInspector]
	[SerializeField]
	private UIFont font;

	[HideInInspector]
	[SerializeField]
	private UILabel textLabel;

	private LegacyEvent mLegacyEvent;

	private bool mUseDynamicFont;

	private bool mTweening;

	public UnityEngine.Object ambigiousFont
	{
		get
		{
			if (trueTypeFont != null)
			{
				return trueTypeFont;
			}
			if (bitmapFont != null)
			{
				return bitmapFont;
			}
			return font;
		}
		set
		{
			if (value is UnityEngine.Font)
			{
				trueTypeFont = value as UnityEngine.Font;
				bitmapFont = null;
				font = null;
			}
			else if (value is UIFont)
			{
				bitmapFont = value as UIFont;
				trueTypeFont = null;
				font = null;
			}
		}
	}

	[Obsolete("Use EventDelegate.Add(popup.onChange, YourCallback) instead, and UIPopupList.current.value to determine the state")]
	public LegacyEvent onSelectionChange
	{
		get
		{
			return mLegacyEvent;
		}
		set
		{
			mLegacyEvent = value;
		}
	}

	public bool isOpen => mChild != null;

	public string value
	{
		get
		{
			return mSelectedItem;
		}
		set
		{
			mSelectedItem = value;
			if (mSelectedItem != null && mSelectedItem != null)
			{
				TriggerCallbacks();
			}
		}
	}

	public object data
	{
		get
		{
			int num = items.IndexOf(mSelectedItem);
			return (num >= itemData.Count) ? null : itemData[num];
		}
	}

	[Obsolete("Use 'value' instead")]
	public string selection
	{
		get
		{
			return value;
		}
		set
		{
			this.value = value;
		}
	}

	private bool handleEvents
	{
		get
		{
			UIKeyNavigation component = GetComponent<UIKeyNavigation>();
			return component == null || !component.enabled;
		}
		set
		{
			UIKeyNavigation component = GetComponent<UIKeyNavigation>();
			if (component != null)
			{
				component.enabled = !value;
			}
		}
	}

	private bool isValid => bitmapFont != null || trueTypeFont != null;

	private int activeFontSize => (!(trueTypeFont != null) && !(bitmapFont == null)) ? bitmapFont.defaultSize : fontSize;

	private float activeFontScale => (!(trueTypeFont != null) && !(bitmapFont == null)) ? ((float)fontSize / (float)bitmapFont.defaultSize) : 1f;

	public void Clear()
	{
		items.Clear();
		itemData.Clear();
	}

	public void AddItem(string text)
	{
		items.Add(text);
		itemData.Add(null);
	}

	public void AddItem(string text, object data)
	{
		items.Add(text);
		itemData.Add(data);
	}

	protected void TriggerCallbacks()
	{
		if (current != this)
		{
			UIPopupList uIPopupList = current;
			current = this;
			if (mLegacyEvent != null)
			{
				mLegacyEvent(mSelectedItem);
			}
			if (EventDelegate.IsValid(onChange))
			{
				EventDelegate.Execute(onChange);
			}
			else if (eventReceiver != null && !string.IsNullOrEmpty(functionName))
			{
				eventReceiver.SendMessage(functionName, mSelectedItem, SendMessageOptions.DontRequireReceiver);
			}
			current = uIPopupList;
		}
	}

	private void OnEnable()
	{
		if (EventDelegate.IsValid(onChange))
		{
			eventReceiver = null;
			functionName = null;
		}
		if (font != null)
		{
			if (font.isDynamic)
			{
				trueTypeFont = font.dynamicFont;
				fontStyle = font.dynamicFontStyle;
				mUseDynamicFont = true;
			}
			else if (bitmapFont == null)
			{
				bitmapFont = font;
				mUseDynamicFont = false;
			}
			font = null;
		}
		if (textScale != 0f)
		{
			fontSize = ((!(bitmapFont != null)) ? 16 : Mathf.RoundToInt((float)bitmapFont.defaultSize * textScale));
			textScale = 0f;
		}
		if (trueTypeFont == null && bitmapFont != null && bitmapFont.isDynamic)
		{
			trueTypeFont = bitmapFont.dynamicFont;
			bitmapFont = null;
		}
	}

	private void OnValidate()
	{
		UnityEngine.Font font = trueTypeFont;
		UIFont uIFont = bitmapFont;
		bitmapFont = null;
		trueTypeFont = null;
		if (font != null && (uIFont == null || !mUseDynamicFont))
		{
			bitmapFont = null;
			trueTypeFont = font;
			mUseDynamicFont = true;
		}
		else if (uIFont != null)
		{
			if (uIFont.isDynamic)
			{
				trueTypeFont = uIFont.dynamicFont;
				fontStyle = uIFont.dynamicFontStyle;
				fontSize = uIFont.defaultSize;
				mUseDynamicFont = true;
			}
			else
			{
				bitmapFont = uIFont;
				mUseDynamicFont = false;
			}
		}
		else
		{
			trueTypeFont = font;
			mUseDynamicFont = true;
		}
	}

	private void Start()
	{
		if (textLabel != null)
		{
			EventDelegate.Add(onChange, textLabel.SetCurrentSelection);
			textLabel = null;
		}
		if (!Application.isPlaying)
		{
			return;
		}
		if (string.IsNullOrEmpty(mSelectedItem))
		{
			if (items.Count > 0)
			{
				value = items[0];
			}
		}
		else
		{
			string text = mSelectedItem;
			mSelectedItem = null;
			value = text;
		}
	}

	private void OnLocalize()
	{
		if (isLocalized)
		{
			TriggerCallbacks();
		}
	}

	private void Highlight(UILabel lbl, bool instant)
	{
		if (!(mHighlight != null))
		{
			return;
		}
		mHighlightedLabel = lbl;
		UISpriteData atlasSprite = mHighlight.GetAtlasSprite();
		if (atlasSprite == null)
		{
			return;
		}
		Vector3 highlightPosition = GetHighlightPosition();
		if (instant || !isAnimated)
		{
			mHighlight.cachedTransform.localPosition = highlightPosition;
			return;
		}
		TweenPosition.Begin(mHighlight.gameObject, 0.1f, highlightPosition).method = UITweener.Method.EaseOut;
		if (!mTweening)
		{
			mTweening = true;
			StartCoroutine(UpdateTweenPosition());
		}
	}

	private Vector3 GetHighlightPosition()
	{
		if (mHighlightedLabel == null || mHighlight == null)
		{
			return Vector3.zero;
		}
		UISpriteData atlasSprite = mHighlight.GetAtlasSprite();
		if (atlasSprite == null)
		{
			return Vector3.zero;
		}
		float pixelSize = atlas.pixelSize;
		float num = (float)atlasSprite.borderLeft * pixelSize;
		float y = (float)atlasSprite.borderTop * pixelSize;
		return mHighlightedLabel.cachedTransform.localPosition + new Vector3(0f - num, y, 1f);
	}

	private IEnumerator UpdateTweenPosition()
	{
		if (mHighlight != null && mHighlightedLabel != null)
		{
			TweenPosition tp = mHighlight.GetComponent<TweenPosition>();
			while (tp != null && tp.enabled)
			{
				tp.to = GetHighlightPosition();
				yield return null;
			}
		}
		mTweening = false;
	}

	private void OnItemHover(GameObject go, bool isOver)
	{
		if (isOver)
		{
			UILabel component = go.GetComponent<UILabel>();
			Highlight(component, instant: false);
		}
	}

	private void Select(UILabel lbl, bool instant)
	{
		Highlight(lbl, instant);
		UIEventListener component = lbl.gameObject.GetComponent<UIEventListener>();
		value = component.parameter as string;
		UIPlaySound[] components = GetComponents<UIPlaySound>();
		int i = 0;
		for (int num = components.Length; i < num; i++)
		{
			UIPlaySound uIPlaySound = components[i];
			if (uIPlaySound.trigger == UIPlaySound.Trigger.OnClick)
			{
				NGUITools.PlaySound(uIPlaySound.audioClip, uIPlaySound.volume, 1f);
			}
		}
	}

	private void OnItemPress(GameObject go, bool isPressed)
	{
		if (isPressed)
		{
			Select(go.GetComponent<UILabel>(), instant: true);
		}
	}

	private void OnItemClick(GameObject go)
	{
		Close();
	}

	private void OnKey(KeyCode key)
	{
		if (!base.enabled || !NGUITools.GetActive(base.gameObject) || !handleEvents)
		{
			return;
		}
		int num = mLabelList.IndexOf(mHighlightedLabel);
		if (num == -1)
		{
			num = 0;
		}
		switch (key)
		{
		case KeyCode.UpArrow:
			if (num > 0)
			{
				Select(mLabelList[--num], instant: false);
			}
			break;
		case KeyCode.DownArrow:
			if (num + 1 < mLabelList.Count)
			{
				Select(mLabelList[++num], instant: false);
			}
			break;
		case KeyCode.Escape:
			OnSelect(isSelected: false);
			break;
		}
	}

	private void OnDisable()
	{
		Close();
	}

	private void OnSelect(bool isSelected)
	{
		if (!isSelected)
		{
			Close();
		}
	}

	public void Close()
	{
		if (!(mChild != null))
		{
			return;
		}
		mLabelList.Clear();
		handleEvents = false;
		if (isAnimated)
		{
			UIWidget[] componentsInChildren = mChild.GetComponentsInChildren<UIWidget>();
			int i = 0;
			for (int num = componentsInChildren.Length; i < num; i++)
			{
				UIWidget uIWidget = componentsInChildren[i];
				UnityEngine.Color color = uIWidget.color;
				color.a = 0f;
				TweenColor.Begin(uIWidget.gameObject, 0.15f, color).method = UITweener.Method.EaseOut;
			}
			Collider[] componentsInChildren2 = mChild.GetComponentsInChildren<Collider>();
			int j = 0;
			for (int num2 = componentsInChildren2.Length; j < num2; j++)
			{
				componentsInChildren2[j].enabled = false;
			}
			UnityEngine.Object.Destroy(mChild, 0.15f);
		}
		else
		{
			UnityEngine.Object.Destroy(mChild);
		}
		mBackground = null;
		mHighlight = null;
		mChild = null;
	}

	private void AnimateColor(UIWidget widget)
	{
		UnityEngine.Color color = widget.color;
		widget.color = new UnityEngine.Color(color.r, color.g, color.b, 0f);
		TweenColor.Begin(widget.gameObject, 0.15f, color).method = UITweener.Method.EaseOut;
	}

	private void AnimatePosition(UIWidget widget, bool placeAbove, float bottom)
	{
		Vector3 localPosition = widget.cachedTransform.localPosition;
		Vector3 localPosition2 = ((!placeAbove) ? new Vector3(localPosition.x, 0f, localPosition.z) : new Vector3(localPosition.x, bottom, localPosition.z));
		widget.cachedTransform.localPosition = localPosition2;
		GameObject go = widget.gameObject;
		TweenPosition.Begin(go, 0.15f, localPosition).method = UITweener.Method.EaseOut;
	}

	private void AnimateScale(UIWidget widget, bool placeAbove, float bottom)
	{
		GameObject go = widget.gameObject;
		Transform cachedTransform = widget.cachedTransform;
		float num = (float)activeFontSize * activeFontScale + mBgBorder * 2f;
		cachedTransform.localScale = new Vector3(1f, num / (float)widget.height, 1f);
		TweenScale.Begin(go, 0.15f, Vector3.one).method = UITweener.Method.EaseOut;
		if (placeAbove)
		{
			Vector3 localPosition = cachedTransform.localPosition;
			cachedTransform.localPosition = new Vector3(localPosition.x, localPosition.y - (float)widget.height + num, localPosition.z);
			TweenPosition.Begin(go, 0.15f, localPosition).method = UITweener.Method.EaseOut;
		}
	}

	private void Animate(UIWidget widget, bool placeAbove, float bottom)
	{
		AnimateColor(widget);
		AnimatePosition(widget, placeAbove, bottom);
	}

	private void OnClick()
	{
		if (openOn != OpenOn.DoubleClick && openOn != OpenOn.Manual && (openOn != OpenOn.RightClick || UICamera.currentTouchID == -2))
		{
			Show();
		}
	}

	private void OnDoubleClick()
	{
		if (openOn == OpenOn.DoubleClick)
		{
			Show();
		}
	}

	public void Show()
	{
		if (base.enabled && NGUITools.GetActive(base.gameObject) && mChild == null && atlas != null && isValid && items.Count > 0)
		{
			mLabelList.Clear();
			if (mPanel == null)
			{
				mPanel = UIPanel.Find(base.transform);
				if (mPanel == null)
				{
					return;
				}
			}
			handleEvents = true;
			Transform transform = base.transform;
			Bounds bounds = NGUIMath.CalculateRelativeWidgetBounds(transform.parent, transform);
			mChild = new GameObject("Drop-down List");
			mChild.layer = base.gameObject.layer;
			Transform transform2 = mChild.transform;
			transform2.parent = transform.parent;
			transform2.localPosition = bounds.min;
			transform2.localRotation = Quaternion.identity;
			transform2.localScale = Vector3.one;
			mBackground = NGUITools.AddSprite(mChild, atlas, backgroundSprite);
			mBackground.pivot = UIWidget.Pivot.TopLeft;
			mBackground.depth = NGUITools.CalculateNextDepth(mPanel.gameObject);
			mBackground.color = backgroundColor;
			Vector4 border = mBackground.border;
			mBgBorder = border.y;
			mBackground.cachedTransform.localPosition = new Vector3(0f, border.y, 0f);
			mHighlight = NGUITools.AddSprite(mChild, atlas, highlightSprite);
			mHighlight.pivot = UIWidget.Pivot.TopLeft;
			mHighlight.color = highlightColor;
			UISpriteData atlasSprite = mHighlight.GetAtlasSprite();
			if (atlasSprite == null)
			{
				return;
			}
			float num = atlasSprite.borderTop;
			float num2 = activeFontSize;
			float num3 = activeFontScale;
			float num4 = num2 * num3;
			float a = 0f;
			float num5 = 0f - padding.y;
			List<UILabel> list = new List<UILabel>();
			if (!items.Contains(mSelectedItem))
			{
				mSelectedItem = null;
			}
			int i = 0;
			for (int count = items.Count; i < count; i++)
			{
				string text = items[i];
				UILabel uILabel = NGUITools.AddWidget<UILabel>(mChild);
				uILabel.name = i.ToString();
				uILabel.pivot = UIWidget.Pivot.TopLeft;
				uILabel.bitmapFont = bitmapFont;
				uILabel.trueTypeFont = trueTypeFont;
				uILabel.fontSize = fontSize;
				uILabel.fontStyle = fontStyle;
				uILabel.text = ((!isLocalized) ? text : Localization.Get(text));
				uILabel.color = textColor;
				uILabel.cachedTransform.localPosition = new Vector3(border.x + padding.x - uILabel.pivotOffset.x, num5, -1f);
				uILabel.overflowMethod = UILabel.Overflow.ResizeFreely;
				uILabel.alignment = alignment;
				list.Add(uILabel);
				num5 -= num4;
				num5 -= padding.y;
				a = Mathf.Max(a, uILabel.printedSize.x);
				UIEventListener uIEventListener = UIEventListener.Get(uILabel.gameObject);
				uIEventListener.onHover = OnItemHover;
				uIEventListener.onPress = OnItemPress;
				uIEventListener.onClick = OnItemClick;
				uIEventListener.parameter = text;
				if (mSelectedItem == text || (i == 0 && string.IsNullOrEmpty(mSelectedItem)))
				{
					Highlight(uILabel, instant: true);
				}
				mLabelList.Add(uILabel);
			}
			a = Mathf.Max(a, bounds.size.x * num3 - (border.x + padding.x) * 2f);
			float num6 = a;
			Vector3 vector = new Vector3(num6 * 0.5f, (0f - num2) * 0.5f, 0f);
			Vector3 vector2 = new Vector3(num6, num4 + padding.y, 1f);
			int j = 0;
			for (int count2 = list.Count; j < count2; j++)
			{
				UILabel uILabel2 = list[j];
				NGUITools.AddWidgetCollider(uILabel2.gameObject);
				uILabel2.autoResizeBoxCollider = false;
				BoxCollider component = uILabel2.GetComponent<BoxCollider>();
				if (component != null)
				{
					vector.z = component.center.z;
					component.center = vector;
					component.size = vector2;
				}
				else
				{
					BoxCollider2D component2 = uILabel2.GetComponent<BoxCollider2D>();
					component2.offset = vector;
					component2.size = vector2;
				}
			}
			int width = Mathf.RoundToInt(a);
			a += (border.x + padding.x) * 2f;
			num5 -= border.y;
			mBackground.width = Mathf.RoundToInt(a);
			mBackground.height = Mathf.RoundToInt(0f - num5 + border.y);
			int k = 0;
			for (int count3 = list.Count; k < count3; k++)
			{
				UILabel uILabel3 = list[k];
				uILabel3.overflowMethod = UILabel.Overflow.ShrinkContent;
				uILabel3.width = width;
			}
			float num7 = 2f * atlas.pixelSize;
			float f = a - (border.x + padding.x) * 2f + (float)atlasSprite.borderLeft * num7;
			float f2 = num4 + num * num7;
			mHighlight.width = Mathf.RoundToInt(f);
			mHighlight.height = Mathf.RoundToInt(f2);
			bool flag = position == Position.Above;
			if (position == Position.Auto)
			{
				UICamera uICamera = UICamera.FindCameraForLayer(base.gameObject.layer);
				if (uICamera != null)
				{
					flag = uICamera.cachedCamera.WorldToViewportPoint(transform.position).y < 0.5f;
				}
			}
			if (isAnimated)
			{
				float bottom = num5 + num4;
				Animate(mHighlight, flag, bottom);
				int l = 0;
				for (int count4 = list.Count; l < count4; l++)
				{
					Animate(list[l], flag, bottom);
				}
				AnimateColor(mBackground);
				AnimateScale(mBackground, flag, bottom);
			}
			if (flag)
			{
				transform2.localPosition = new Vector3(bounds.min.x, bounds.max.y - num5 - border.y, bounds.min.z);
			}
		}
		else
		{
			OnSelect(isSelected: false);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/Interaction/NGUI Progress Bar")]
public class UIProgressBar : UIWidgetContainer
{
	public enum FillDirection
	{
		LeftToRight,
		RightToLeft,
		BottomToTop,
		TopToBottom
	}

	public delegate void OnDragFinished();

	public static UIProgressBar current;

	public OnDragFinished onDragFinished;

	public Transform thumb;

	[HideInInspector]
	[SerializeField]
	protected UIWidget mBG;

	[HideInInspector]
	[SerializeField]
	protected UIWidget mFG;

	[HideInInspector]
	[SerializeField]
	protected float mValue = 1f;

	[HideInInspector]
	[SerializeField]
	protected FillDirection mFill;

	protected Transform mTrans;

	protected bool mIsDirty;

	protected Camera mCam;

	protected float mOffset;

	public int numberOfSteps;

	public List<EventDelegate> onChange = new List<EventDelegate>();

	public Transform cachedTransform
	{
		get
		{
			if (mTrans == null)
			{
				mTrans = base.transform;
			}
			return mTrans;
		}
	}

	public Camera cachedCamera
	{
		get
		{
			if (mCam == null)
			{
				mCam = NGUITools.FindCameraForLayer(base.gameObject.layer);
			}
			return mCam;
		}
	}

	public UIWidget foregroundWidget
	{
		get
		{
			return mFG;
		}
		set
		{
			if (mFG != value)
			{
				mFG = value;
				mIsDirty = true;
			}
		}
	}

	public UIWidget backgroundWidget
	{
		get
		{
			return mBG;
		}
		set
		{
			if (mBG != value)
			{
				mBG = value;
				mIsDirty = true;
			}
		}
	}

	public FillDirection fillDirection
	{
		get
		{
			return mFill;
		}
		set
		{
			if (mFill != value)
			{
				mFill = value;
				ForceUpdate();
			}
		}
	}

	public float value
	{
		get
		{
			if (numberOfSteps > 1)
			{
				return Mathf.Round(mValue * (float)(numberOfSteps - 1)) / (float)(numberOfSteps - 1);
			}
			return mValue;
		}
		set
		{
			float num = Mathf.Clamp01(value);
			if (mValue == num)
			{
				return;
			}
			float num2 = this.value;
			mValue = num;
			if (num2 != this.value)
			{
				ForceUpdate();
				if (current == null && NGUITools.GetActive(this) && EventDelegate.IsValid(onChange))
				{
					current = this;
					EventDelegate.Execute(onChange);
					current = null;
				}
			}
		}
	}

	public float alpha
	{
		get
		{
			if (mFG != null)
			{
				return mFG.alpha;
			}
			if (mBG != null)
			{
				return mBG.alpha;
			}
			return 1f;
		}
		set
		{
			if (mFG != null)
			{
				mFG.alpha = value;
				if (mFG.GetComponent<Collider>() != null)
				{
					mFG.GetComponent<Collider>().enabled = mFG.alpha > 0.001f;
				}
				else if (mFG.GetComponent<Collider2D>() != null)
				{
					mFG.GetComponent<Collider2D>().enabled = mFG.alpha > 0.001f;
				}
			}
			if (mBG != null)
			{
				mBG.alpha = value;
				if (mBG.GetComponent<Collider>() != null)
				{
					mBG.GetComponent<Collider>().enabled = mBG.alpha > 0.001f;
				}
				else if (mBG.GetComponent<Collider2D>() != null)
				{
					mBG.GetComponent<Collider2D>().enabled = mBG.alpha > 0.001f;
				}
			}
			if (!(thumb != null))
			{
				return;
			}
			UIWidget component = thumb.GetComponent<UIWidget>();
			if (component != null)
			{
				component.alpha = value;
				if (component.GetComponent<Collider>() != null)
				{
					component.GetComponent<Collider>().enabled = component.alpha > 0.001f;
				}
				else if (component.GetComponent<Collider2D>() != null)
				{
					component.GetComponent<Collider2D>().enabled = component.alpha > 0.001f;
				}
			}
		}
	}

	protected bool isHorizontal => mFill == FillDirection.LeftToRight || mFill == FillDirection.RightToLeft;

	protected bool isInverted => mFill == FillDirection.RightToLeft || mFill == FillDirection.TopToBottom;

	protected void Start()
	{
		Upgrade();
		if (Application.isPlaying)
		{
			if (mBG != null)
			{
				mBG.autoResizeBoxCollider = true;
			}
			OnStart();
			if (current == null && onChange != null)
			{
				current = this;
				EventDelegate.Execute(onChange);
				current = null;
			}
		}
		ForceUpdate();
	}

	protected virtual void Upgrade()
	{
	}

	protected virtual void OnStart()
	{
	}

	protected void Update()
	{
		if (mIsDirty)
		{
			ForceUpdate();
		}
	}

	protected void OnValidate()
	{
		if (NGUITools.GetActive(this))
		{
			Upgrade();
			mIsDirty = true;
			float num = Mathf.Clamp01(mValue);
			if (mValue != num)
			{
				mValue = num;
			}
			if (numberOfSteps < 0)
			{
				numberOfSteps = 0;
			}
			else if (numberOfSteps > 20)
			{
				numberOfSteps = 20;
			}
			ForceUpdate();
		}
		else
		{
			float num2 = Mathf.Clamp01(mValue);
			if (mValue != num2)
			{
				mValue = num2;
			}
			if (numberOfSteps < 0)
			{
				numberOfSteps = 0;
			}
			else if (numberOfSteps > 20)
			{
				numberOfSteps = 20;
			}
		}
	}

	protected float ScreenToValue(Vector2 screenPos)
	{
		Transform transform = cachedTransform;
		Plane plane = new Plane(transform.rotation * Vector3.back, transform.position);
		Ray ray = cachedCamera.ScreenPointToRay(screenPos);
		if (!plane.Raycast(ray, out var enter))
		{
			return value;
		}
		return LocalToValue(transform.InverseTransformPoint(ray.GetPoint(enter)));
	}

	protected virtual float LocalToValue(Vector2 localPos)
	{
		if (mFG != null)
		{
			Vector3[] localCorners = mFG.localCorners;
			Vector3 vector = localCorners[2] - localCorners[0];
			if (isHorizontal)
			{
				float num = (localPos.x - localCorners[0].x) / vector.x;
				return (!isInverted) ? num : (1f - num);
			}
			float num2 = (localPos.y - localCorners[0].y) / vector.y;
			return (!isInverted) ? num2 : (1f - num2);
		}
		return value;
	}

	public virtual void ForceUpdate()
	{
		mIsDirty = false;
		if (mFG != null)
		{
			UIBasicSprite uIBasicSprite = mFG as UIBasicSprite;
			if (isHorizontal)
			{
				if (uIBasicSprite != null && uIBasicSprite.type == UIBasicSprite.Type.Filled)
				{
					if (uIBasicSprite.fillDirection == UIBasicSprite.FillDirection.Horizontal || uIBasicSprite.fillDirection == UIBasicSprite.FillDirection.Vertical)
					{
						uIBasicSprite.fillDirection = UIBasicSprite.FillDirection.Horizontal;
						uIBasicSprite.invert = isInverted;
					}
					uIBasicSprite.fillAmount = value;
				}
				else
				{
					mFG.drawRegion = ((!isInverted) ? new Vector4(0f, 0f, value, 1f) : new Vector4(1f - value, 0f, 1f, 1f));
					mFG.enabled = value > 0.001f;
				}
			}
			else if (uIBasicSprite != null && uIBasicSprite.type == UIBasicSprite.Type.Filled)
			{
				if (uIBasicSprite.fillDirection == UIBasicSprite.FillDirection.Horizontal || uIBasicSprite.fillDirection == UIBasicSprite.FillDirection.Vertical)
				{
					uIBasicSprite.fillDirection = UIBasicSprite.FillDirection.Vertical;
					uIBasicSprite.invert = isInverted;
				}
				uIBasicSprite.fillAmount = value;
			}
			else
			{
				mFG.drawRegion = ((!isInverted) ? new Vector4(0f, 0f, 1f, value) : new Vector4(0f, 1f - value, 1f, 1f));
				mFG.enabled = value > 0.001f;
			}
		}
		if (thumb != null && (mFG != null || mBG != null))
		{
			Vector3[] array = ((!(mFG != null)) ? mBG.localCorners : mFG.localCorners);
			Vector4 vector = ((!(mFG != null)) ? mBG.border : mFG.border);
			array[0].x += vector.x;
			array[1].x += vector.x;
			array[2].x -= vector.z;
			array[3].x -= vector.z;
			array[0].y += vector.y;
			array[1].y -= vector.w;
			array[2].y -= vector.w;
			array[3].y += vector.y;
			Transform transform = ((!(mFG != null)) ? mBG.cachedTransform : mFG.cachedTransform);
			for (int i = 0; i < 4; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = transform.TransformPoint(array[i]);
			}
			if (isHorizontal)
			{
				Vector3 a = Vector3.Lerp(array[0], array[1], 0.5f);
				Vector3 b = Vector3.Lerp(array[2], array[3], 0.5f);
				SetThumbPosition(Vector3.Lerp(a, b, (!isInverted) ? value : (1f - value)));
			}
			else
			{
				Vector3 a2 = Vector3.Lerp(array[0], array[3], 0.5f);
				Vector3 b2 = Vector3.Lerp(array[1], array[2], 0.5f);
				SetThumbPosition(Vector3.Lerp(a2, b2, (!isInverted) ? value : (1f - value)));
			}
		}
	}

	protected void SetThumbPosition(Vector3 worldPos)
	{
		Transform parent = thumb.parent;
		if (parent != null)
		{
			worldPos = parent.InverseTransformPoint(worldPos);
			worldPos.x = Mathf.Round(worldPos.x);
			worldPos.y = Mathf.Round(worldPos.y);
			worldPos.z = 0f;
			if (Vector3.Distance(thumb.localPosition, worldPos) > 0.001f)
			{
				thumb.localPosition = worldPos;
			}
		}
		else if (Vector3.Distance(thumb.position, worldPos) > 1E-05f)
		{
			thumb.position = worldPos;
		}
	}
}
[AddComponentMenu("NGUI/Interaction/Saved Option")]
public class UISavedOption : MonoBehaviour
{
	public string keyName;

	private UIPopupList mList;

	private UIToggle mCheck;

	private string key => (!string.IsNullOrEmpty(keyName)) ? keyName : ("NGUI State: " + base.name);

	private void Awake()
	{
		mList = GetComponent<UIPopupList>();
		mCheck = GetComponent<UIToggle>();
	}

	private void OnEnable()
	{
		if (mList != null)
		{
			EventDelegate.Add(mList.onChange, SaveSelection);
		}
		if (mCheck != null)
		{
			EventDelegate.Add(mCheck.onChange, SaveState);
		}
		if (mList != null)
		{
			string @string = PlayerPrefs.GetString(key);
			if (!string.IsNullOrEmpty(@string))
			{
				mList.value = @string;
			}
			return;
		}
		if (mCheck != null)
		{
			mCheck.value = PlayerPrefs.GetInt(key, mCheck.startsActive ? 1 : 0) != 0;
			return;
		}
		string string2 = PlayerPrefs.GetString(key);
		UIToggle[] componentsInChildren = GetComponentsInChildren<UIToggle>(includeInactive: true);
		int i = 0;
		for (int num = componentsInChildren.Length; i < num; i++)
		{
			UIToggle uIToggle = componentsInChildren[i];
			uIToggle.value = uIToggle.name == string2;
		}
	}

	private void OnDisable()
	{
		if (mCheck != null)
		{
			EventDelegate.Remove(mCheck.onChange, SaveState);
		}
		if (mList != null)
		{
			EventDelegate.Remove(mList.onChange, SaveSelection);
		}
		if (!(mCheck == null) || !(mList == null))
		{
			return;
		}
		UIToggle[] componentsInChildren = GetComponentsInChildren<UIToggle>(includeInactive: true);
		int i = 0;
		for (int num = componentsInChildren.Length; i < num; i++)
		{
			UIToggle uIToggle = componentsInChildren[i];
			if (uIToggle.value)
			{
				PlayerPrefs.SetString(key, uIToggle.name);
				break;
			}
		}
	}

	public void SaveSelection()
	{
		PlayerPrefs.SetString(key, UIPopupList.current.value);
	}

	public void SaveState()
	{
		PlayerPrefs.SetInt(key, UIToggle.current.value ? 1 : 0);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/Interaction/NGUI Scroll Bar")]
public class UIScrollBar : UISlider
{
	private enum Direction
	{
		Horizontal,
		Vertical,
		Upgraded
	}

	[HideInInspector]
	[SerializeField]
	protected float mSize = 1f;

	[HideInInspector]
	[SerializeField]
	private float mScroll;

	[HideInInspector]
	[SerializeField]
	private Direction mDir = Direction.Upgraded;

	[Obsolete("Use 'value' instead")]
	public float scrollValue
	{
		get
		{
			return base.value;
		}
		set
		{
			base.value = value;
		}
	}

	public float barSize
	{
		get
		{
			return mSize;
		}
		set
		{
			float num = Mathf.Clamp01(value);
			if (mSize == num)
			{
				return;
			}
			mSize = num;
			mIsDirty = true;
			if (NGUITools.GetActive(this))
			{
				if (UIProgressBar.current == null && onChange != null)
				{
					UIProgressBar.current = this;
					EventDelegate.Execute(onChange);
					UIProgressBar.current = null;
				}
				ForceUpdate();
			}
		}
	}

	protected override void Upgrade()
	{
		if (mDir != Direction.Upgraded)
		{
			mValue = mScroll;
			if (mDir == Direction.Horizontal)
			{
				mFill = (mInverted ? FillDirection.RightToLeft : FillDirection.LeftToRight);
			}
			else
			{
				mFill = ((!mInverted) ? FillDirection.TopToBottom : FillDirection.BottomToTop);
			}
			mDir = Direction.Upgraded;
		}
	}

	protected override void OnStart()
	{
		base.OnStart();
		if (mFG != null && mFG.gameObject != base.gameObject && (mFG.GetComponent<Collider>() != null || mFG.GetComponent<Collider2D>() != null))
		{
			UIEventListener uIEventListener = UIEventListener.Get(mFG.gameObject);
			uIEventListener.onPress = (UIEventListener.BoolDelegate)Delegate.Combine(uIEventListener.onPress, new UIEventListener.BoolDelegate(base.OnPressForeground));
			uIEventListener.onDrag = (UIEventListener.VectorDelegate)Delegate.Combine(uIEventListener.onDrag, new UIEventListener.VectorDelegate(base.OnDragForeground));
			mFG.autoResizeBoxCollider = true;
		}
	}

	protected override float LocalToValue(Vector2 localPos)
	{
		if (mFG != null)
		{
			float num = Mathf.Clamp01(mSize) * 0.5f;
			float t = num;
			float t2 = 1f - num;
			Vector3[] localCorners = mFG.localCorners;
			if (base.isHorizontal)
			{
				t = Mathf.Lerp(localCorners[0].x, localCorners[2].x, t);
				t2 = Mathf.Lerp(localCorners[0].x, localCorners[2].x, t2);
				float num2 = t2 - t;
				if (num2 == 0f)
				{
					return base.value;
				}
				return (!base.isInverted) ? ((localPos.x - t) / num2) : ((t2 - localPos.x) / num2);
			}
			t = Mathf.Lerp(localCorners[0].y, localCorners[1].y, t);
			t2 = Mathf.Lerp(localCorners[3].y, localCorners[2].y, t2);
			float num3 = t2 - t;
			if (num3 == 0f)
			{
				return base.value;
			}
			return (!base.isInverted) ? ((localPos.y - t) / num3) : ((t2 - localPos.y) / num3);
		}
		return base.LocalToValue(localPos);
	}

	public override void ForceUpdate()
	{
		if (mFG != null)
		{
			mIsDirty = false;
			float num = Mathf.Clamp01(mSize) * 0.5f;
			float num2 = Mathf.Lerp(num, 1f - num, base.value);
			float num3 = num2 - num;
			float num4 = num2 + num;
			if (base.isHorizontal)
			{
				mFG.drawRegion = ((!base.isInverted) ? new Vector4(num3, 0f, num4, 1f) : new Vector4(1f - num4, 0f, 1f - num3, 1f));
			}
			else
			{
				mFG.drawRegion = ((!base.isInverted) ? new Vector4(0f, num3, 1f, num4) : new Vector4(0f, 1f - num4, 1f, 1f - num3));
			}
			if (thumb != null)
			{
				Vector4 drawingDimensions = mFG.drawingDimensions;
				Vector3 position = new Vector3(Mathf.Lerp(drawingDimensions.x, drawingDimensions.z, 0.5f), Mathf.Lerp(drawingDimensions.y, drawingDimensions.w, 0.5f));
				SetThumbPosition(mFG.cachedTransform.TransformPoint(position));
			}
		}
		else
		{
			base.ForceUpdate();
		}
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(UIPanel))]
[AddComponentMenu("NGUI/Interaction/Scroll View")]
public class UIScrollView : MonoBehaviour
{
	public enum Movement
	{
		Horizontal,
		Vertical,
		Unrestricted,
		Custom
	}

	public enum DragEffect
	{
		None,
		Momentum,
		MomentumAndSpring
	}

	public enum ShowCondition
	{
		Always,
		OnlyIfNeeded,
		WhenDragging
	}

	public delegate void OnDragNotification();

	public static BetterList<UIScrollView> list = new BetterList<UIScrollView>();

	public Movement movement;

	public DragEffect dragEffect = DragEffect.MomentumAndSpring;

	public bool restrictWithinPanel = true;

	public bool disableDragIfFits;

	public bool smoothDragStart = true;

	public bool iOSDragEmulation = true;

	public float scrollWheelFactor = 0.25f;

	public float momentumAmount = 35f;

	public UIProgressBar horizontalScrollBar;

	public UIProgressBar verticalScrollBar;

	public ShowCondition showScrollBars = ShowCondition.OnlyIfNeeded;

	public Vector2 customMovement = new Vector2(1f, 0f);

	public UIWidget.Pivot contentPivot;

	public OnDragNotification onDragStarted;

	public OnDragNotification onDragFinished;

	public OnDragNotification onMomentumMove;

	public OnDragNotification onStoppedMoving;

	[HideInInspector]
	[SerializeField]
	private Vector3 scale = new Vector3(1f, 0f, 0f);

	[SerializeField]
	[HideInInspector]
	private Vector2 relativePositionOnReset = Vector2.zero;

	protected Transform mTrans;

	protected UIPanel mPanel;

	protected Plane mPlane;

	protected Vector3 mLastPos;

	protected bool mPressed;

	protected Vector3 mMomentum = Vector3.zero;

	protected float mScroll;

	protected Bounds mBounds;

	protected bool mCalculatedBounds;

	protected bool mShouldMove;

	protected bool mIgnoreCallbacks;

	protected int mDragID = -10;

	protected Vector2 mDragStartOffset = Vector2.zero;

	protected bool mDragStarted;

	[HideInInspector]
	public UICenterOnChild centerOnChild;

	public UIPanel panel => mPanel;

	public bool isDragging => mPressed && mDragStarted;

	public virtual Bounds bounds
	{
		get
		{
			if (!mCalculatedBounds)
			{
				mCalculatedBounds = true;
				mTrans = base.transform;
				mBounds = NGUIMath.CalculateRelativeWidgetBounds(mTrans, mTrans);
			}
			return mBounds;
		}
	}

	public bool canMoveHorizontally => movement == Movement.Horizontal || movement == Movement.Unrestricted || (movement == Movement.Custom && customMovement.x != 0f);

	public bool canMoveVertically => movement == Movement.Vertical || movement == Movement.Unrestricted || (movement == Movement.Custom && customMovement.y != 0f);

	public virtual bool shouldMoveHorizontally
	{
		get
		{
			float num = bounds.size.x;
			if (mPanel.clipping == UIDrawCall.Clipping.SoftClip)
			{
				num += mPanel.clipSoftness.x * 2f;
			}
			return Mathf.RoundToInt(num - mPanel.width) > 0;
		}
	}

	public virtual bool shouldMoveVertically
	{
		get
		{
			float num = bounds.size.y;
			if (mPanel.clipping == UIDrawCall.Clipping.SoftClip)
			{
				num += mPanel.clipSoftness.y * 2f;
			}
			return Mathf.RoundToInt(num - mPanel.height) > 0;
		}
	}

	protected virtual bool shouldMove
	{
		get
		{
			if (!disableDragIfFits)
			{
				return true;
			}
			if (mPanel == null)
			{
				mPanel = GetComponent<UIPanel>();
			}
			Vector4 finalClipRegion = mPanel.finalClipRegion;
			Bounds bounds = this.bounds;
			float num = ((finalClipRegion.z != 0f) ? (finalClipRegion.z * 0.5f) : ((float)Screen.width));
			float num2 = ((finalClipRegion.w != 0f) ? (finalClipRegion.w * 0.5f) : ((float)Screen.height));
			if (canMoveHorizontally)
			{
				if (bounds.min.x < finalClipRegion.x - num)
				{
					return true;
				}
				if (bounds.max.x > finalClipRegion.x + num)
				{
					return true;
				}
			}
			if (canMoveVertically)
			{
				if (bounds.min.y < finalClipRegion.y - num2)
				{
					return true;
				}
				if (bounds.max.y > finalClipRegion.y + num2)
				{
					return true;
				}
			}
			return false;
		}
	}

	public Vector3 currentMomentum
	{
		get
		{
			return mMomentum;
		}
		set
		{
			mMomentum = value;
			mShouldMove = true;
		}
	}

	private void Awake()
	{
		mTrans = base.transform;
		mPanel = GetComponent<UIPanel>();
		if (mPanel.clipping == UIDrawCall.Clipping.None)
		{
			mPanel.clipping = UIDrawCall.Clipping.ConstrainButDontClip;
		}
		if (movement != Movement.Custom && scale.sqrMagnitude > 0.001f)
		{
			if (scale.x == 1f && scale.y == 0f)
			{
				movement = Movement.Horizontal;
			}
			else if (scale.x == 0f && scale.y == 1f)
			{
				movement = Movement.Vertical;
			}
			else if (scale.x == 1f && scale.y == 1f)
			{
				movement = Movement.Unrestricted;
			}
			else
			{
				movement = Movement.Custom;
				customMovement.x = scale.x;
				customMovement.y = scale.y;
			}
			scale = Vector3.zero;
		}
		if (contentPivot == UIWidget.Pivot.TopLeft && relativePositionOnReset != Vector2.zero)
		{
			contentPivot = NGUIMath.GetPivot(new Vector2(relativePositionOnReset.x, 1f - relativePositionOnReset.y));
			relativePositionOnReset = Vector2.zero;
		}
	}

	private void OnEnable()
	{
		list.Add(this);
		if (Application.isPlaying)
		{
			if (horizontalScrollBar != null)
			{
				EventDelegate.Add(horizontalScrollBar.onChange, OnScrollBar);
				horizontalScrollBar.alpha = ((showScrollBars != 0 && !shouldMoveHorizontally) ? 0f : 1f);
			}
			if (verticalScrollBar != null)
			{
				EventDelegate.Add(verticalScrollBar.onChange, OnScrollBar);
				verticalScrollBar.alpha = ((showScrollBars != 0 && !shouldMoveVertically) ? 0f : 1f);
			}
		}
	}

	private void OnDisable()
	{
		list.Remove(this);
	}

	public bool RestrictWithinBounds(bool instant)
	{
		return RestrictWithinBounds(instant, horizontal: true, vertical: true);
	}

	public bool RestrictWithinBounds(bool instant, bool horizontal, bool vertical)
	{
		Bounds bounds = this.bounds;
		Vector3 vector = mPanel.CalculateConstrainOffset(bounds.min, bounds.max);
		if (!horizontal)
		{
			vector.x = 0f;
		}
		if (!vertical)
		{
			vector.y = 0f;
		}
		if (vector.sqrMagnitude > 0.1f)
		{
			if (!instant && dragEffect == DragEffect.MomentumAndSpring)
			{
				Vector3 pos = mTrans.localPosition + vector;
				pos.x = Mathf.Round(pos.x);
				pos.y = Mathf.Round(pos.y);
				SpringPanel.Begin(mPanel.gameObject, pos, 13f).strength = 8f;
			}
			else
			{
				MoveRelative(vector);
				if (Mathf.Abs(vector.x) > 0.01f)
				{
					mMomentum.x = 0f;
				}
				if (Mathf.Abs(vector.y) > 0.01f)
				{
					mMomentum.y = 0f;
				}
				if (Mathf.Abs(vector.z) > 0.01f)
				{
					mMomentum.z = 0f;
				}
				mScroll = 0f;
			}
			return true;
		}
		return false;
	}

	public void DisableSpring()
	{
		SpringPanel component = GetComponent<SpringPanel>();
		if (component != null)
		{
			component.enabled = false;
		}
	}

	public void UpdateScrollbars()
	{
		UpdateScrollbars(recalculateBounds: true);
	}

	public virtual void UpdateScrollbars(bool recalculateBounds)
	{
		if (mPanel == null)
		{
			return;
		}
		if (horizontalScrollBar != null || verticalScrollBar != null)
		{
			if (recalculateBounds)
			{
				mCalculatedBounds = false;
				mShouldMove = shouldMove;
			}
			Bounds bounds = this.bounds;
			Vector2 vector = bounds.min;
			Vector2 vector2 = bounds.max;
			if (horizontalScrollBar != null && vector2.x > vector.x)
			{
				Vector4 finalClipRegion = mPanel.finalClipRegion;
				int num = Mathf.RoundToInt(finalClipRegion.z);
				if (((uint)num & (true ? 1u : 0u)) != 0)
				{
					num--;
				}
				float f = (float)num * 0.5f;
				f = Mathf.Round(f);
				if (mPanel.clipping == UIDrawCall.Clipping.SoftClip)
				{
					f -= mPanel.clipSoftness.x;
				}
				float contentSize = vector2.x - vector.x;
				float viewSize = f * 2f;
				float x = vector.x;
				float x2 = vector2.x;
				float num2 = finalClipRegion.x - f;
				float num3 = finalClipRegion.x + f;
				x = num2 - x;
				x2 -= num3;
				UpdateScrollbars(horizontalScrollBar, x, x2, contentSize, viewSize, inverted: false);
			}
			if (verticalScrollBar != null && vector2.y > vector.y)
			{
				Vector4 finalClipRegion2 = mPanel.finalClipRegion;
				int num4 = Mathf.RoundToInt(finalClipRegion2.w);
				if (((uint)num4 & (true ? 1u : 0u)) != 0)
				{
					num4--;
				}
				float f2 = (float)num4 * 0.5f;
				f2 = Mathf.Round(f2);
				if (mPanel.clipping == UIDrawCall.Clipping.SoftClip)
				{
					f2 -= mPanel.clipSoftness.y;
				}
				float contentSize2 = vector2.y - vector.y;
				float viewSize2 = f2 * 2f;
				float y = vector.y;
				float y2 = vector2.y;
				float num5 = finalClipRegion2.y - f2;
				float num6 = finalClipRegion2.y + f2;
				y = num5 - y;
				y2 -= num6;
				UpdateScrollbars(verticalScrollBar, y, y2, contentSize2, viewSize2, inverted: true);
			}
		}
		else if (recalculateBounds)
		{
			mCalculatedBounds = false;
		}
	}

	protected void UpdateScrollbars(UIProgressBar slider, float contentMin, float contentMax, float contentSize, float viewSize, bool inverted)
	{
		if (slider == null)
		{
			return;
		}
		mIgnoreCallbacks = true;
		float num;
		if (viewSize < contentSize)
		{
			contentMin = Mathf.Clamp01(contentMin / contentSize);
			contentMax = Mathf.Clamp01(contentMax / contentSize);
			num = contentMin + contentMax;
			slider.value = (inverted ? ((!(num > 0.001f)) ? 0f : (1f - contentMin / num)) : ((!(num > 0.001f)) ? 1f : (contentMin / num)));
		}
		else
		{
			contentMin = Mathf.Clamp01((0f - contentMin) / contentSize);
			contentMax = Mathf.Clamp01((0f - contentMax) / contentSize);
			num = contentMin + contentMax;
			slider.value = (inverted ? ((!(num > 0.001f)) ? 0f : (1f - contentMin / num)) : ((!(num > 0.001f)) ? 1f : (contentMin / num)));
			if (contentSize > 0f)
			{
				contentMin = Mathf.Clamp01(contentMin / contentSize);
				contentMax = Mathf.Clamp01(contentMax / contentSize);
				num = contentMin + contentMax;
			}
		}
		UIScrollBar uIScrollBar = slider as UIScrollBar;
		if (uIScrollBar != null)
		{
			uIScrollBar.barSize = 1f - num;
		}
		mIgnoreCallbacks = false;
	}

	public virtual void SetDragAmount(float x, float y, bool updateScrollbars)
	{
		if (mPanel == null)
		{
			mPanel = GetComponent<UIPanel>();
		}
		DisableSpring();
		Bounds bounds = this.bounds;
		if (bounds.min.x == bounds.max.x || bounds.min.y == bounds.max.y)
		{
			return;
		}
		Vector4 finalClipRegion = mPanel.finalClipRegion;
		float num = finalClipRegion.z * 0.5f;
		float num2 = finalClipRegion.w * 0.5f;
		float num3 = bounds.min.x + num;
		float num4 = bounds.max.x - num;
		float num5 = bounds.min.y + num2;
		float num6 = bounds.max.y - num2;
		if (mPanel.clipping == UIDrawCall.Clipping.SoftClip)
		{
			num3 -= mPanel.clipSoftness.x;
			num4 += mPanel.clipSoftness.x;
			num5 -= mPanel.clipSoftness.y;
			num6 += mPanel.clipSoftness.y;
		}
		float num7 = Mathf.Lerp(num3, num4, x);
		float num8 = Mathf.Lerp(num6, num5, y);
		if (!updateScrollbars)
		{
			Vector3 localPosition = mTrans.localPosition;
			if (canMoveHorizontally)
			{
				localPosition.x += finalClipRegion.x - num7;
			}
			if (canMoveVertically)
			{
				localPosition.y += finalClipRegion.y - num8;
			}
			mTrans.localPosition = localPosition;
		}
		if (canMoveHorizontally)
		{
			finalClipRegion.x = num7;
		}
		if (canMoveVertically)
		{
			finalClipRegion.y = num8;
		}
		Vector4 baseClipRegion = mPanel.baseClipRegion;
		mPanel.clipOffset = new Vector2(finalClipRegion.x - baseClipRegion.x, finalClipRegion.y - baseClipRegion.y);
		if (updateScrollbars)
		{
			UpdateScrollbars(mDragID == -10);
		}
	}

	public void InvalidateBounds()
	{
		mCalculatedBounds = false;
	}

	[ContextMenu("Reset Clipping Position")]
	public void ResetPosition()
	{
		if (NGUITools.GetActive(this))
		{
			mCalculatedBounds = false;
			Vector2 pivotOffset = NGUIMath.GetPivotOffset(contentPivot);
			SetDragAmount(pivotOffset.x, 1f - pivotOffset.y, updateScrollbars: false);
			SetDragAmount(pivotOffset.x, 1f - pivotOffset.y, updateScrollbars: true);
		}
	}

	public void UpdatePosition()
	{
		if (!mIgnoreCallbacks && (horizontalScrollBar != null || verticalScrollBar != null))
		{
			mIgnoreCallbacks = true;
			mCalculatedBounds = false;
			Vector2 pivotOffset = NGUIMath.GetPivotOffset(contentPivot);
			float x = ((!(horizontalScrollBar != null)) ? pivotOffset.x : horizontalScrollBar.value);
			float y = ((!(verticalScrollBar != null)) ? (1f - pivotOffset.y) : verticalScrollBar.value);
			SetDragAmount(x, y, updateScrollbars: false);
			UpdateScrollbars(recalculateBounds: true);
			mIgnoreCallbacks = false;
		}
	}

	public void OnScrollBar()
	{
		if (!mIgnoreCallbacks)
		{
			mIgnoreCallbacks = true;
			float x = ((!(horizontalScrollBar != null)) ? 0f : horizontalScrollBar.value);
			float y = ((!(verticalScrollBar != null)) ? 0f : verticalScrollBar.value);
			SetDragAmount(x, y, updateScrollbars: false);
			mIgnoreCallbacks = false;
		}
	}

	public virtual void MoveRelative(Vector3 relative)
	{
		mTrans.localPosition += relative;
		Vector2 clipOffset = mPanel.clipOffset;
		clipOffset.x -= relative.x;
		clipOffset.y -= relative.y;
		mPanel.clipOffset = clipOffset;
		UpdateScrollbars(recalculateBounds: false);
	}

	public void MoveAbsolute(Vector3 absolute)
	{
		Vector3 vector = mTrans.InverseTransformPoint(absolute);
		Vector3 vector2 = mTrans.InverseTransformPoint(Vector3.zero);
		MoveRelative(vector - vector2);
	}

	public void Press(bool pressed)
	{
		if (UICamera.currentScheme == UICamera.ControlScheme.Controller)
		{
			return;
		}
		if (smoothDragStart && pressed)
		{
			mDragStarted = false;
			mDragStartOffset = Vector2.zero;
		}
		if (!base.enabled || !NGUITools.GetActive(base.gameObject))
		{
			return;
		}
		if (!pressed && mDragID == UICamera.currentTouchID)
		{
			mDragID = -10;
		}
		mCalculatedBounds = false;
		mShouldMove = shouldMove;
		if (!mShouldMove)
		{
			return;
		}
		mPressed = pressed;
		if (pressed)
		{
			mMomentum = Vector3.zero;
			mScroll = 0f;
			DisableSpring();
			mLastPos = UICamera.lastWorldPosition;
			mPlane = new Plane(mTrans.rotation * Vector3.back, mLastPos);
			Vector2 clipOffset = mPanel.clipOffset;
			clipOffset.x = Mathf.Round(clipOffset.x);
			clipOffset.y = Mathf.Round(clipOffset.y);
			mPanel.clipOffset = clipOffset;
			Vector3 localPosition = mTrans.localPosition;
			localPosition.x = Mathf.Round(localPosition.x);
			localPosition.y = Mathf.Round(localPosition.y);
			mTrans.localPosition = localPosition;
			if (!smoothDragStart)
			{
				mDragStarted = true;
				mDragStartOffset = Vector2.zero;
				if (onDragStarted != null)
				{
					onDragStarted();
				}
			}
		}
		else
		{
			if (restrictWithinPanel && mPanel.clipping != 0)
			{
				RestrictWithinBounds(dragEffect == DragEffect.None, canMoveHorizontally, canMoveVertically);
			}
			if (mDragStarted && onDragFinished != null)
			{
				onDragFinished();
			}
			if (!mShouldMove && onStoppedMoving != null)
			{
				onStoppedMoving();
			}
		}
	}

	public void Drag()
	{
		if (UICamera.currentScheme == UICamera.ControlScheme.Controller || !base.enabled || !NGUITools.GetActive(base.gameObject) || !mShouldMove)
		{
			return;
		}
		if (mDragID == -10)
		{
			mDragID = UICamera.currentTouchID;
		}
		UICamera.currentTouch.clickNotification = UICamera.ClickNotification.BasedOnDelta;
		if (smoothDragStart && !mDragStarted)
		{
			mDragStarted = true;
			mDragStartOffset = UICamera.currentTouch.totalDelta;
			if (onDragStarted != null)
			{
				onDragStarted();
			}
		}
		Ray ray = ((!smoothDragStart) ? UICamera.currentCamera.ScreenPointToRay(UICamera.currentTouch.pos) : UICamera.currentCamera.ScreenPointToRay(UICamera.currentTouch.pos - mDragStartOffset));
		float enter = 0f;
		if (!mPlane.Raycast(ray, out enter))
		{
			return;
		}
		Vector3 point = ray.GetPoint(enter);
		Vector3 vector = point - mLastPos;
		mLastPos = point;
		if (vector.x != 0f || vector.y != 0f || vector.z != 0f)
		{
			vector = mTrans.InverseTransformDirection(vector);
			if (movement == Movement.Horizontal)
			{
				vector.y = 0f;
				vector.z = 0f;
			}
			else if (movement == Movement.Vertical)
			{
				vector.x = 0f;
				vector.z = 0f;
			}
			else if (movement == Movement.Unrestricted)
			{
				vector.z = 0f;
			}
			else
			{
				vector.Scale(customMovement);
			}
			vector = mTrans.TransformDirection(vector);
		}
		if (dragEffect == DragEffect.None)
		{
			mMomentum = Vector3.zero;
		}
		else
		{
			mMomentum = Vector3.Lerp(mMomentum, mMomentum + vector * (0.01f * momentumAmount), 0.67f);
		}
		if (!iOSDragEmulation || dragEffect != DragEffect.MomentumAndSpring)
		{
			MoveAbsolute(vector);
		}
		else if (mPanel.CalculateConstrainOffset(bounds.min, bounds.max).magnitude > 1f)
		{
			MoveAbsolute(vector * 0.5f);
			mMomentum *= 0.5f;
		}
		else
		{
			MoveAbsolute(vector);
		}
		if (restrictWithinPanel && mPanel.clipping != 0 && dragEffect != DragEffect.MomentumAndSpring)
		{
			RestrictWithinBounds(instant: true, canMoveHorizontally, canMoveVertically);
		}
	}

	public void Scroll(float delta)
	{
		if (base.enabled && NGUITools.GetActive(base.gameObject) && scrollWheelFactor != 0f)
		{
			DisableSpring();
			mShouldMove |= shouldMove;
			if (Mathf.Sign(mScroll) != Mathf.Sign(delta))
			{
				mScroll = 0f;
			}
			mScroll += delta * scrollWheelFactor;
		}
	}

	private void LateUpdate()
	{
		if (!Application.isPlaying)
		{
			return;
		}
		float deltaTime = RealTime.deltaTime;
		if (showScrollBars != 0 && ((bool)verticalScrollBar || (bool)horizontalScrollBar))
		{
			bool flag = false;
			bool flag2 = false;
			if (showScrollBars != ShowCondition.WhenDragging || mDragID != -10 || mMomentum.magnitude > 0.01f)
			{
				flag = shouldMoveVertically;
				flag2 = shouldMoveHorizontally;
			}
			if ((bool)verticalScrollBar)
			{
				float alpha = verticalScrollBar.alpha;
				alpha += ((!flag) ? ((0f - deltaTime) * 3f) : (deltaTime * 6f));
				alpha = Mathf.Clamp01(alpha);
				if (verticalScrollBar.alpha != alpha)
				{
					verticalScrollBar.alpha = alpha;
				}
			}
			if ((bool)horizontalScrollBar)
			{
				float alpha2 = horizontalScrollBar.alpha;
				alpha2 += ((!flag2) ? ((0f - deltaTime) * 3f) : (deltaTime * 6f));
				alpha2 = Mathf.Clamp01(alpha2);
				if (horizontalScrollBar.alpha != alpha2)
				{
					horizontalScrollBar.alpha = alpha2;
				}
			}
		}
		if (!mShouldMove)
		{
			return;
		}
		if (!mPressed)
		{
			if (mMomentum.magnitude > 0.0001f || mScroll != 0f)
			{
				if (movement == Movement.Horizontal)
				{
					mMomentum -= mTrans.TransformDirection(new Vector3(mScroll * 0.05f, 0f, 0f));
				}
				else if (movement == Movement.Vertical)
				{
					mMomentum -= mTrans.TransformDirection(new Vector3(0f, mScroll * 0.05f, 0f));
				}
				else if (movement == Movement.Unrestricted)
				{
					mMomentum -= mTrans.TransformDirection(new Vector3(mScroll * 0.05f, mScroll * 0.05f, 0f));
				}
				else
				{
					mMomentum -= mTrans.TransformDirection(new Vector3(mScroll * customMovement.x * 0.05f, mScroll * customMovement.y * 0.05f, 0f));
				}
				mScroll = NGUIMath.SpringLerp(mScroll, 0f, 20f, deltaTime);
				Vector3 absolute = NGUIMath.SpringDampen(ref mMomentum, 9f, deltaTime);
				MoveAbsolute(absolute);
				if (restrictWithinPanel && mPanel.clipping != 0)
				{
					if (NGUITools.GetActive(centerOnChild))
					{
						if (centerOnChild.nextPageThreshold != 0f)
						{
							mMomentum = Vector3.zero;
							mScroll = 0f;
						}
						else
						{
							centerOnChild.Recenter();
						}
					}
					else
					{
						RestrictWithinBounds(instant: false, canMoveHorizontally, canMoveVertically);
					}
				}
				if (onMomentumMove != null)
				{
					onMomentumMove();
				}
				return;
			}
			mScroll = 0f;
			mMomentum = Vector3.zero;
			SpringPanel component = GetComponent<SpringPanel>();
			if (!(component != null) || !component.enabled)
			{
				mShouldMove = false;
				if (onStoppedMoving != null)
				{
					onStoppedMoving();
				}
			}
		}
		else
		{
			mScroll = 0f;
			NGUIMath.SpringDampen(ref mMomentum, 9f, deltaTime);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/Interaction/NGUI Slider")]
public class UISlider : UIProgressBar
{
	private enum Direction
	{
		Horizontal,
		Vertical,
		Upgraded
	}

	[HideInInspector]
	[SerializeField]
	private Transform foreground;

	[HideInInspector]
	[SerializeField]
	private float rawValue = 1f;

	[HideInInspector]
	[SerializeField]
	private Direction direction = Direction.Upgraded;

	[HideInInspector]
	[SerializeField]
	protected bool mInverted;

	[Obsolete("Use 'value' instead")]
	public float sliderValue
	{
		get
		{
			return base.value;
		}
		set
		{
			base.value = value;
		}
	}

	[Obsolete("Use 'fillDirection' instead")]
	public bool inverted
	{
		get
		{
			return base.isInverted;
		}
		set
		{
		}
	}

	protected override void Upgrade()
	{
		if (direction != Direction.Upgraded)
		{
			mValue = rawValue;
			if (foreground != null)
			{
				mFG = foreground.GetComponent<UIWidget>();
			}
			if (direction == Direction.Horizontal)
			{
				mFill = (mInverted ? FillDirection.RightToLeft : FillDirection.LeftToRight);
			}
			else
			{
				mFill = ((!mInverted) ? FillDirection.BottomToTop : FillDirection.TopToBottom);
			}
			direction = Direction.Upgraded;
		}
	}

	protected override void OnStart()
	{
		GameObject go = ((!(mBG != null) || (!(mBG.GetComponent<Collider>() != null) && !(mBG.GetComponent<Collider2D>() != null))) ? base.gameObject : mBG.gameObject);
		UIEventListener uIEventListener = UIEventListener.Get(go);
		uIEventListener.onPress = (UIEventListener.BoolDelegate)Delegate.Combine(uIEventListener.onPress, new UIEventListener.BoolDelegate(OnPressBackground));
		uIEventListener.onDrag = (UIEventListener.VectorDelegate)Delegate.Combine(uIEventListener.onDrag, new UIEventListener.VectorDelegate(OnDragBackground));
		if (thumb != null && (thumb.GetComponent<Collider>() != null || thumb.GetComponent<Collider2D>() != null) && (mFG == null || thumb != mFG.cachedTransform))
		{
			UIEventListener uIEventListener2 = UIEventListener.Get(thumb.gameObject);
			uIEventListener2.onPress = (UIEventListener.BoolDelegate)Delegate.Combine(uIEventListener2.onPress, new UIEventListener.BoolDelegate(OnPressForeground));
			uIEventListener2.onDrag = (UIEventListener.VectorDelegate)Delegate.Combine(uIEventListener2.onDrag, new UIEventListener.VectorDelegate(OnDragForeground));
		}
	}

	protected void OnPressBackground(GameObject go, bool isPressed)
	{
		if (UICamera.currentScheme != UICamera.ControlScheme.Controller)
		{
			mCam = UICamera.currentCamera;
			base.value = ScreenToValue(UICamera.lastTouchPosition);
			if (!isPressed && onDragFinished != null)
			{
				onDragFinished();
			}
		}
	}

	protected void OnDragBackground(GameObject go, Vector2 delta)
	{
		if (UICamera.currentScheme != UICamera.ControlScheme.Controller)
		{
			mCam = UICamera.currentCamera;
			base.value = ScreenToValue(UICamera.lastTouchPosition);
		}
	}

	protected void OnPressForeground(GameObject go, bool isPressed)
	{
		if (UICamera.currentScheme != UICamera.ControlScheme.Controller)
		{
			mCam = UICamera.currentCamera;
			if (isPressed)
			{
				mOffset = ((!(mFG == null)) ? (base.value - ScreenToValue(UICamera.lastTouchPosition)) : 0f);
			}
			else if (onDragFinished != null)
			{
				onDragFinished();
			}
		}
	}

	protected void OnDragForeground(GameObject go, Vector2 delta)
	{
		if (UICamera.currentScheme != UICamera.ControlScheme.Controller)
		{
			mCam = UICamera.currentCamera;
			base.value = mOffset + ScreenToValue(UICamera.lastTouchPosition);
		}
	}

	protected void OnKey(KeyCode key)
	{
		if (!base.enabled)
		{
			return;
		}
		float num = ((!((float)numberOfSteps > 1f)) ? 0.125f : (1f / (float)(numberOfSteps - 1)));
		switch (mFill)
		{
		case FillDirection.LeftToRight:
			switch (key)
			{
			case KeyCode.LeftArrow:
				base.value = mValue - num;
				break;
			case KeyCode.RightArrow:
				base.value = mValue + num;
				break;
			}
			break;
		case FillDirection.RightToLeft:
			switch (key)
			{
			case KeyCode.LeftArrow:
				base.value = mValue + num;
				break;
			case KeyCode.RightArrow:
				base.value = mValue - num;
				break;
			}
			break;
		case FillDirection.BottomToTop:
			switch (key)
			{
			case KeyCode.DownArrow:
				base.value = mValue - num;
				break;
			case KeyCode.UpArrow:
				base.value = mValue + num;
				break;
			}
			break;
		case FillDirection.TopToBottom:
			switch (key)
			{
			case KeyCode.DownArrow:
				base.value = mValue + num;
				break;
			case KeyCode.UpArrow:
				base.value = mValue - num;
				break;
			}
			break;
		}
	}
}
[RequireComponent(typeof(UISlider))]
[AddComponentMenu("NGUI/Interaction/Sound Volume")]
public class UISoundVolume : MonoBehaviour
{
	private UISlider mSlider;

	private void Awake()
	{
		mSlider = GetComponent<UISlider>();
		mSlider.value = NGUITools.soundVolume;
		EventDelegate.Add(mSlider.onChange, OnChange);
	}

	private void OnChange()
	{
		NGUITools.soundVolume = UIProgressBar.current.value;
	}
}
[AddComponentMenu("NGUI/Interaction/Table")]
public class UITable : UIWidgetContainer
{
	public delegate void OnReposition();

	public enum Direction
	{
		Down,
		Up
	}

	public enum Sorting
	{
		None,
		Alphabetic,
		Horizontal,
		Vertical,
		Custom
	}

	public int columns;

	public Direction direction;

	public Sorting sorting;

	public UIWidget.Pivot pivot;

	public UIWidget.Pivot cellAlignment;

	public bool hideInactive = true;

	public bool keepWithinPanel;

	public Vector2 padding = Vector2.zero;

	public OnReposition onReposition;

	public Comparison<Transform> onCustomSort;

	protected UIPanel mPanel;

	protected bool mInitDone;

	protected bool mReposition;

	public bool repositionNow
	{
		set
		{
			if (value)
			{
				mReposition = true;
				base.enabled = true;
			}
		}
	}

	public List<Transform> GetChildList()
	{
		Transform transform = base.transform;
		List<Transform> list = new List<Transform>();
		for (int i = 0; i < transform.childCount; i++)
		{
			Transform child = transform.GetChild(i);
			if (!hideInactive || ((bool)child && NGUITools.GetActive(child.gameObject)))
			{
				list.Add(child);
			}
		}
		if (sorting != 0)
		{
			if (sorting == Sorting.Alphabetic)
			{
				list.Sort(UIGrid.SortByName);
			}
			else if (sorting == Sorting.Horizontal)
			{
				list.Sort(UIGrid.SortHorizontal);
			}
			else if (sorting == Sorting.Vertical)
			{
				list.Sort(UIGrid.SortVertical);
			}
			else if (onCustomSort != null)
			{
				list.Sort(onCustomSort);
			}
			else
			{
				Sort(list);
			}
		}
		return list;
	}

	protected virtual void Sort(List<Transform> list)
	{
		list.Sort(UIGrid.SortByName);
	}

	protected virtual void Start()
	{
		Init();
		Reposition();
		base.enabled = false;
	}

	protected virtual void Init()
	{
		mInitDone = true;
		mPanel = NGUITools.FindInParents<UIPanel>(base.gameObject);
	}

	protected virtual void LateUpdate()
	{
		if (mReposition)
		{
			Reposition();
		}
		base.enabled = false;
	}

	private void OnValidate()
	{
		if (!Application.isPlaying && NGUITools.GetActive(this))
		{
			Reposition();
		}
	}

	protected void RepositionVariableSize(List<Transform> children)
	{
		float num = 0f;
		float num2 = 0f;
		int num3 = ((columns <= 0) ? 1 : (children.Count / columns + 1));
		int num4 = ((columns <= 0) ? children.Count : columns);
		Bounds[,] array = new Bounds[num3, num4];
		Bounds[] array2 = new Bounds[num4];
		Bounds[] array3 = new Bounds[num3];
		int num5 = 0;
		int num6 = 0;
		int i = 0;
		for (int count = children.Count; i < count; i++)
		{
			Transform transform = children[i];
			Bounds bounds = NGUIMath.CalculateRelativeWidgetBounds(transform, !hideInactive);
			Vector3 localScale = transform.localScale;
			bounds.min = Vector3.Scale(bounds.min, localScale);
			bounds.max = Vector3.Scale(bounds.max, localScale);
			array[num6, num5] = bounds;
			array2[num5].Encapsulate(bounds);
			array3[num6].Encapsulate(bounds);
			if (++num5 >= columns && columns > 0)
			{
				num5 = 0;
				num6++;
			}
		}
		num5 = 0;
		num6 = 0;
		Vector2 pivotOffset = NGUIMath.GetPivotOffset(cellAlignment);
		int j = 0;
		for (int count2 = children.Count; j < count2; j++)
		{
			Transform transform2 = children[j];
			Bounds bounds2 = array[num6, num5];
			Bounds bounds3 = array2[num5];
			Bounds bounds4 = array3[num6];
			Vector3 localPosition = transform2.localPosition;
			localPosition.x = num + bounds2.extents.x - bounds2.center.x;
			localPosition.x -= Mathf.Lerp(0f, bounds2.max.x - bounds2.min.x - bounds3.max.x + bounds3.min.x, pivotOffset.x) - padding.x;
			if (direction == Direction.Down)
			{
				localPosition.y = 0f - num2 - bounds2.extents.y - bounds2.center.y;
				localPosition.y += Mathf.Lerp(bounds2.max.y - bounds2.min.y - bounds4.max.y + bounds4.min.y, 0f, pivotOffset.y) - padding.y;
			}
			else
			{
				localPosition.y = num2 + bounds2.extents.y - bounds2.center.y;
				localPosition.y -= Mathf.Lerp(0f, bounds2.max.y - bounds2.min.y - bounds4.max.y + bounds4.min.y, pivotOffset.y) - padding.y;
			}
			num += bounds3.size.x + padding.x * 2f;
			transform2.localPosition = localPosition;
			if (++num5 >= columns && columns > 0)
			{
				num5 = 0;
				num6++;
				num = 0f;
				num2 += bounds4.size.y + padding.y * 2f;
			}
		}
		if (pivot == UIWidget.Pivot.TopLeft)
		{
			return;
		}
		pivotOffset = NGUIMath.GetPivotOffset(pivot);
		Bounds bounds5 = NGUIMath.CalculateRelativeWidgetBounds(base.transform);
		float num7 = Mathf.Lerp(0f, bounds5.size.x, pivotOffset.x);
		float num8 = Mathf.Lerp(0f - bounds5.size.y, 0f, pivotOffset.y);
		Transform transform3 = base.transform;
		for (int k = 0; k < transform3.childCount; k++)
		{
			Transform child = transform3.GetChild(k);
			SpringPosition component = child.GetComponent<SpringPosition>();
			if (component != null)
			{
				component.target.x -= num7;
				component.target.y -= num8;
				continue;
			}
			Vector3 localPosition2 = child.localPosition;
			localPosition2.x -= num7;
			localPosition2.y -= num8;
			child.localPosition = localPosition2;
		}
	}

	[ContextMenu("Execute")]
	public virtual void Reposition()
	{
		if (Application.isPlaying && !mInitDone && NGUITools.GetActive(this))
		{
			Init();
		}
		mReposition = false;
		Transform target = base.transform;
		List<Transform> childList = GetChildList();
		if (childList.Count > 0)
		{
			RepositionVariableSize(childList);
		}
		if (keepWithinPanel && mPanel != null)
		{
			mPanel.ConstrainTargetToBounds(target, immediate: true);
			UIScrollView component = mPanel.GetComponent<UIScrollView>();
			if (component != null)
			{
				component.UpdateScrollbars(recalculateBounds: true);
			}
		}
		if (onReposition != null)
		{
			onReposition();
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/Interaction/Toggle")]
public class UIToggle : UIWidgetContainer
{
	public static BetterList<UIToggle> list = new BetterList<UIToggle>();

	public static UIToggle current;

	public int group;

	public UIWidget activeSprite;

	public Animation activeAnimation;

	public bool startsActive;

	public bool instantTween;

	public bool optionCanBeNone;

	public List<EventDelegate> onChange = new List<EventDelegate>();

	[HideInInspector]
	[SerializeField]
	private UISprite checkSprite;

	[HideInInspector]
	[SerializeField]
	private Animation checkAnimation;

	[HideInInspector]
	[SerializeField]
	private GameObject eventReceiver;

	[HideInInspector]
	[SerializeField]
	private string functionName = "OnActivate";

	[HideInInspector]
	[SerializeField]
	private bool startsChecked;

	private bool mIsActive = true;

	private bool mStarted;

	public bool value
	{
		get
		{
			return (!mStarted) ? startsActive : mIsActive;
		}
		set
		{
			if (!mStarted)
			{
				startsActive = value;
			}
			else if (group == 0 || value || optionCanBeNone || !mStarted)
			{
				Set(value);
			}
		}
	}

	[Obsolete("Use 'value' instead")]
	public bool isChecked
	{
		get
		{
			return value;
		}
		set
		{
			this.value = value;
		}
	}

	public static UIToggle GetActiveToggle(int group)
	{
		for (int i = 0; i < list.size; i++)
		{
			UIToggle uIToggle = list[i];
			if (uIToggle != null && uIToggle.group == group && uIToggle.mIsActive)
			{
				return uIToggle;
			}
		}
		return null;
	}

	private void OnEnable()
	{
		list.Add(this);
	}

	private void OnDisable()
	{
		list.Remove(this);
	}

	private void Start()
	{
		if (startsChecked)
		{
			startsChecked = false;
			startsActive = true;
		}
		if (!Application.isPlaying)
		{
			if (checkSprite != null && activeSprite == null)
			{
				activeSprite = checkSprite;
				checkSprite = null;
			}
			if (checkAnimation != null && activeAnimation == null)
			{
				activeAnimation = checkAnimation;
				checkAnimation = null;
			}
			if (Application.isPlaying && activeSprite != null)
			{
				activeSprite.alpha = ((!startsActive) ? 0f : 1f);
			}
			if (EventDelegate.IsValid(onChange))
			{
				eventReceiver = null;
				functionName = null;
			}
		}
		else
		{
			mIsActive = !startsActive;
			mStarted = true;
			bool flag = instantTween;
			instantTween = true;
			Set(startsActive);
			instantTween = flag;
		}
	}

	private void OnClick()
	{
		if (base.enabled)
		{
			value = !value;
		}
	}

	private void Set(bool state)
	{
		if (!mStarted)
		{
			mIsActive = state;
			startsActive = state;
			if (activeSprite != null)
			{
				activeSprite.alpha = ((!state) ? 0f : 1f);
			}
		}
		else
		{
			if (mIsActive == state)
			{
				return;
			}
			if (group != 0 && state)
			{
				int num = 0;
				int size = list.size;
				while (num < size)
				{
					UIToggle uIToggle = list[num];
					if (uIToggle != this && uIToggle.group == group)
					{
						uIToggle.Set(state: false);
					}
					if (list.size != size)
					{
						size = list.size;
						num = 0;
					}
					else
					{
						num++;
					}
				}
			}
			mIsActive = state;
			if (activeSprite != null)
			{
				if (instantTween || !NGUITools.GetActive(this))
				{
					activeSprite.alpha = ((!mIsActive) ? 0f : 1f);
				}
				else
				{
					TweenAlpha.Begin(activeSprite.gameObject, 0.15f, (!mIsActive) ? 0f : 1f);
				}
			}
			if (current == null)
			{
				UIToggle uIToggle2 = current;
				current = this;
				if (EventDelegate.IsValid(onChange))
				{
					EventDelegate.Execute(onChange);
				}
				else if (eventReceiver != null && !string.IsNullOrEmpty(functionName))
				{
					eventReceiver.SendMessage(functionName, mIsActive, SendMessageOptions.DontRequireReceiver);
				}
				current = uIToggle2;
			}
			if (this.activeAnimation != null)
			{
				ActiveAnimation activeAnimation = ActiveAnimation.Play(this.activeAnimation, null, state ? Direction.Forward : Direction.Reverse, EnableCondition.IgnoreDisabledState, DisableCondition.DoNotDisable);
				if (activeAnimation != null && (instantTween || !NGUITools.GetActive(this)))
				{
					activeAnimation.Finish();
				}
			}
		}
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(UIToggle))]
[AddComponentMenu("NGUI/Interaction/Toggled Components")]
public class UIToggledComponents : MonoBehaviour
{
	public List<MonoBehaviour> activate;

	public List<MonoBehaviour> deactivate;

	[HideInInspector]
	[SerializeField]
	private MonoBehaviour target;

	[HideInInspector]
	[SerializeField]
	private bool inverse;

	private void Awake()
	{
		if (target != null)
		{
			if (activate.Count == 0 && deactivate.Count == 0)
			{
				if (inverse)
				{
					deactivate.Add(target);
				}
				else
				{
					activate.Add(target);
				}
			}
			else
			{
				target = null;
			}
		}
		UIToggle component = GetComponent<UIToggle>();
		EventDelegate.Add(component.onChange, Toggle);
	}

	public void Toggle()
	{
		if (base.enabled)
		{
			for (int i = 0; i < activate.Count; i++)
			{
				MonoBehaviour monoBehaviour = activate[i];
				monoBehaviour.enabled = UIToggle.current.value;
			}
			for (int j = 0; j < deactivate.Count; j++)
			{
				MonoBehaviour monoBehaviour2 = deactivate[j];
				monoBehaviour2.enabled = !UIToggle.current.value;
			}
		}
	}
}
[AddComponentMenu("NGUI/Interaction/Toggled Objects")]
public class UIToggledObjects : MonoBehaviour
{
	public List<GameObject> activate;

	public List<GameObject> deactivate;

	[HideInInspector]
	[SerializeField]
	private GameObject target;

	[HideInInspector]
	[SerializeField]
	private bool inverse;

	private void Awake()
	{
		if (target != null)
		{
			if (activate.Count == 0 && deactivate.Count == 0)
			{
				if (inverse)
				{
					deactivate.Add(target);
				}
				else
				{
					activate.Add(target);
				}
			}
			else
			{
				target = null;
			}
		}
		UIToggle component = GetComponent<UIToggle>();
		EventDelegate.Add(component.onChange, Toggle);
	}

	public void Toggle()
	{
		bool value = UIToggle.current.value;
		if (base.enabled)
		{
			for (int i = 0; i < activate.Count; i++)
			{
				Set(activate[i], value);
			}
			for (int j = 0; j < deactivate.Count; j++)
			{
				Set(deactivate[j], !value);
			}
		}
	}

	private void Set(GameObject go, bool state)
	{
		if (go != null)
		{
			NGUITools.SetActive(go, state);
		}
	}
}
[AddComponentMenu("NGUI/Interaction/Widget Container")]
public class UIWidgetContainer : MonoBehaviour
{
}
[AddComponentMenu("NGUI/Interaction/Wrap Content")]
public class UIWrapContent : MonoBehaviour
{
	public delegate void OnInitializeItem(GameObject go, int wrapIndex, int realIndex);

	public int itemSize = 100;

	public bool cullContent = true;

	public int minIndex;

	public int maxIndex;

	public OnInitializeItem onInitializeItem;

	private Transform mTrans;

	private UIPanel mPanel;

	private UIScrollView mScroll;

	private bool mHorizontal;

	private bool mFirstTime = true;

	private List<Transform> mChildren = new List<Transform>();

	protected virtual void Start()
	{
		SortBasedOnScrollMovement();
		WrapContent();
		if (mScroll != null)
		{
			mScroll.GetComponent<UIPanel>().onClipMove = OnMove;
		}
		mFirstTime = false;
	}

	protected virtual void OnMove(UIPanel panel)
	{
		WrapContent();
	}

	[ContextMenu("Sort Based on Scroll Movement")]
	public void SortBasedOnScrollMovement()
	{
		if (CacheScrollView())
		{
			mChildren.Clear();
			for (int i = 0; i < mTrans.childCount; i++)
			{
				mChildren.Add(mTrans.GetChild(i));
			}
			if (mHorizontal)
			{
				mChildren.Sort(UIGrid.SortHorizontal);
			}
			else
			{
				mChildren.Sort(UIGrid.SortVertical);
			}
			ResetChildPositions();
		}
	}

	[ContextMenu("Sort Alphabetically")]
	public void SortAlphabetically()
	{
		if (CacheScrollView())
		{
			mChildren.Clear();
			for (int i = 0; i < mTrans.childCount; i++)
			{
				mChildren.Add(mTrans.GetChild(i));
			}
			mChildren.Sort(UIGrid.SortByName);
			ResetChildPositions();
		}
	}

	protected bool CacheScrollView()
	{
		mTrans = base.transform;
		mPanel = NGUITools.FindInParents<UIPanel>(base.gameObject);
		mScroll = mPanel.GetComponent<UIScrollView>();
		if (mScroll == null)
		{
			return false;
		}
		if (mScroll.movement == UIScrollView.Movement.Horizontal)
		{
			mHorizontal = true;
		}
		else
		{
			if (mScroll.movement != UIScrollView.Movement.Vertical)
			{
				return false;
			}
			mHorizontal = false;
		}
		return true;
	}

	private void ResetChildPositions()
	{
		int i = 0;
		for (int count = mChildren.Count; i < count; i++)
		{
			Transform transform = mChildren[i];
			transform.localPosition = ((!mHorizontal) ? new Vector3(0f, -i * itemSize, 0f) : new Vector3(i * itemSize, 0f, 0f));
		}
	}

	public void WrapContent()
	{
		float num = (float)(itemSize * mChildren.Count) * 0.5f;
		Vector3[] worldCorners = mPanel.worldCorners;
		for (int i = 0; i < 4; i++)
		{
			Vector3 position = worldCorners[i];
			position = mTrans.InverseTransformPoint(position);
			worldCorners[i] = position;
		}
		Vector3 vector = Vector3.Lerp(worldCorners[0], worldCorners[2], 0.5f);
		bool flag = true;
		float num2 = num * 2f;
		if (mHorizontal)
		{
			float num3 = worldCorners[0].x - (float)itemSize;
			float num4 = worldCorners[2].x + (float)itemSize;
			int j = 0;
			for (int count = mChildren.Count; j < count; j++)
			{
				Transform transform = mChildren[j];
				float num5 = transform.localPosition.x - vector.x;
				if (num5 < 0f - num)
				{
					Vector3 localPosition = transform.localPosition;
					localPosition.x += num2;
					num5 = localPosition.x - vector.x;
					int num6 = Mathf.RoundToInt(localPosition.x / (float)itemSize);
					if (minIndex == maxIndex || (minIndex <= num6 && num6 <= maxIndex))
					{
						transform.localPosition = localPosition;
						UpdateItem(transform, j);
						transform.name = num6.ToString();
					}
					else
					{
						flag = false;
					}
				}
				else if (num5 > num)
				{
					Vector3 localPosition2 = transform.localPosition;
					localPosition2.x -= num2;
					num5 = localPosition2.x - vector.x;
					int num7 = Mathf.RoundToInt(localPosition2.x / (float)itemSize);
					if (minIndex == maxIndex || (minIndex <= num7 && num7 <= maxIndex))
					{
						transform.localPosition = localPosition2;
						UpdateItem(transform, j);
						transform.name = num7.ToString();
					}
					else
					{
						flag = false;
					}
				}
				else if (mFirstTime)
				{
					UpdateItem(transform, j);
				}
				if (cullContent)
				{
					num5 += mPanel.clipOffset.x - mTrans.localPosition.x;
					if (!UICamera.IsPressed(transform.gameObject))
					{
						NGUITools.SetActive(transform.gameObject, num5 > num3 && num5 < num4, compatibilityMode: false);
					}
				}
			}
		}
		else
		{
			float num8 = worldCorners[0].y - (float)itemSize;
			float num9 = worldCorners[2].y + (float)itemSize;
			int k = 0;
			for (int count2 = mChildren.Count; k < count2; k++)
			{
				Transform transform2 = mChildren[k];
				float num10 = transform2.localPosition.y - vector.y;
				if (num10 < 0f - num)
				{
					Vector3 localPosition3 = transform2.localPosition;
					localPosition3.y += num2;
					num10 = localPosition3.y - vector.y;
					int num11 = Mathf.RoundToInt(localPosition3.y / (float)itemSize);
					if (minIndex == maxIndex || (minIndex <= num11 && num11 <= maxIndex))
					{
						transform2.localPosition = localPosition3;
						UpdateItem(transform2, k);
						transform2.name = num11.ToString();
					}
					else
					{
						flag = false;
					}
				}
				else if (num10 > num)
				{
					Vector3 localPosition4 = transform2.localPosition;
					localPosition4.y -= num2;
					num10 = localPosition4.y - vector.y;
					int num12 = Mathf.RoundToInt(localPosition4.y / (float)itemSize);
					if (minIndex == maxIndex || (minIndex <= num12 && num12 <= maxIndex))
					{
						transform2.localPosition = localPosition4;
						UpdateItem(transform2, k);
						transform2.name = num12.ToString();
					}
					else
					{
						flag = false;
					}
				}
				else if (mFirstTime)
				{
					UpdateItem(transform2, k);
				}
				if (cullContent)
				{
					num10 += mPanel.clipOffset.y - mTrans.localPosition.y;
					if (!UICamera.IsPressed(transform2.gameObject))
					{
						NGUITools.SetActive(transform2.gameObject, num10 > num8 && num10 < num9, compatibilityMode: false);
					}
				}
			}
		}
		mScroll.restrictWithinPanel = !flag;
	}

	private void OnValidate()
	{
		if (maxIndex < minIndex)
		{
			maxIndex = minIndex;
		}
		if (minIndex > maxIndex)
		{
			maxIndex = minIndex;
		}
	}

	protected virtual void UpdateItem(Transform item, int index)
	{
		if (onInitializeItem != null)
		{
			int realIndex = ((mScroll.movement != UIScrollView.Movement.Vertical) ? Mathf.RoundToInt(item.localPosition.x / (float)itemSize) : Mathf.RoundToInt(item.localPosition.y / (float)itemSize));
			onInitializeItem(item.gameObject, index, realIndex);
		}
	}
}
[AddComponentMenu("NGUI/Internal/Active Animation")]
public class ActiveAnimation : MonoBehaviour
{
	public static ActiveAnimation current;

	public List<EventDelegate> onFinished = new List<EventDelegate>();

	[HideInInspector]
	public GameObject eventReceiver;

	[HideInInspector]
	public string callWhenFinished;

	private Animation mAnim;

	private Direction mLastDirection;

	private Direction mDisableDirection;

	private bool mNotify;

	private Animator mAnimator;

	private string mClip = string.Empty;

	private float playbackTime => Mathf.Clamp01(mAnimator.GetCurrentAnimatorStateInfo(0).normalizedTime);

	public bool isPlaying
	{
		get
		{
			if (mAnim == null)
			{
				if (mAnimator != null)
				{
					if (mLastDirection == Direction.Reverse)
					{
						if (playbackTime == 0f)
						{
							return false;
						}
					}
					else if (playbackTime == 1f)
					{
						return false;
					}
					return true;
				}
				return false;
			}
			foreach (AnimationState item in mAnim)
			{
				if (!mAnim.IsPlaying(item.name))
				{
					continue;
				}
				if (mLastDirection == Direction.Forward)
				{
					if (!(item.time < item.length))
					{
						continue;
					}
					return true;
				}
				if (mLastDirection == Direction.Reverse)
				{
					if (!(item.time > 0f))
					{
						continue;
					}
					return true;
				}
				return true;
			}
			return false;
		}
	}

	public void Finish()
	{
		if (mAnim != null)
		{
			foreach (AnimationState item in mAnim)
			{
				if (mLastDirection == Direction.Forward)
				{
					item.time = item.length;
				}
				else if (mLastDirection == Direction.Reverse)
				{
					item.time = 0f;
				}
			}
			mAnim.Sample();
		}
		else if (mAnimator != null)
		{
			mAnimator.Play(mClip, 0, (mLastDirection != Direction.Forward) ? 0f : 1f);
		}
	}

	public void Reset()
	{
		if (mAnim != null)
		{
			foreach (AnimationState item in mAnim)
			{
				if (mLastDirection == Direction.Reverse)
				{
					item.time = item.length;
				}
				else if (mLastDirection == Direction.Forward)
				{
					item.time = 0f;
				}
			}
			return;
		}
		if (mAnimator != null)
		{
			mAnimator.Play(mClip, 0, (mLastDirection != Direction.Reverse) ? 0f : 1f);
		}
	}

	private void Start()
	{
		if (eventReceiver != null && EventDelegate.IsValid(onFinished))
		{
			eventReceiver = null;
			callWhenFinished = null;
		}
	}

	private void Update()
	{
		float deltaTime = RealTime.deltaTime;
		if (deltaTime == 0f)
		{
			return;
		}
		if (mAnimator != null)
		{
			mAnimator.Update((mLastDirection != Direction.Reverse) ? deltaTime : (0f - deltaTime));
			if (isPlaying)
			{
				return;
			}
			mAnimator.enabled = false;
			base.enabled = false;
		}
		else
		{
			if (!(mAnim != null))
			{
				base.enabled = false;
				return;
			}
			bool flag = false;
			foreach (AnimationState item in mAnim)
			{
				if (!mAnim.IsPlaying(item.name))
				{
					continue;
				}
				float num = item.speed * deltaTime;
				item.time += num;
				if (num < 0f)
				{
					if (item.time > 0f)
					{
						flag = true;
					}
					else
					{
						item.time = 0f;
					}
				}
				else if (item.time < item.length)
				{
					flag = true;
				}
				else
				{
					item.time = item.length;
				}
			}
			mAnim.Sample();
			if (flag)
			{
				return;
			}
			base.enabled = false;
		}
		if (!mNotify)
		{
			return;
		}
		mNotify = false;
		if (current == null)
		{
			current = this;
			EventDelegate.Execute(onFinished);
			if (eventReceiver != null && !string.IsNullOrEmpty(callWhenFinished))
			{
				eventReceiver.SendMessage(callWhenFinished, SendMessageOptions.DontRequireReceiver);
			}
			current = null;
		}
		if (mDisableDirection != 0 && mLastDirection == mDisableDirection)
		{
			NGUITools.SetActive(base.gameObject, state: false);
		}
	}

	private void Play(string clipName, Direction playDirection)
	{
		if (playDirection == Direction.Toggle)
		{
			playDirection = ((mLastDirection != Direction.Forward) ? Direction.Forward : Direction.Reverse);
		}
		if (mAnim != null)
		{
			base.enabled = true;
			mAnim.enabled = false;
			if (string.IsNullOrEmpty(clipName))
			{
				if (!mAnim.isPlaying)
				{
					mAnim.Play();
				}
			}
			else if (!mAnim.IsPlaying(clipName))
			{
				mAnim.Play(clipName);
			}
			foreach (AnimationState item in mAnim)
			{
				if (string.IsNullOrEmpty(clipName) || item.name == clipName)
				{
					float num = Mathf.Abs(item.speed);
					item.speed = num * (float)playDirection;
					if (playDirection == Direction.Reverse && item.time == 0f)
					{
						item.time = item.length;
					}
					else if (playDirection == Direction.Forward && item.time == item.length)
					{
						item.time = 0f;
					}
				}
			}
			mLastDirection = playDirection;
			mNotify = true;
			mAnim.Sample();
		}
		else if (mAnimator != null)
		{
			if (base.enabled && isPlaying && mClip == clipName)
			{
				mLastDirection = playDirection;
				return;
			}
			base.enabled = true;
			mNotify = true;
			mLastDirection = playDirection;
			mClip = clipName;
			mAnimator.Play(mClip, 0, (playDirection != Direction.Forward) ? 1f : 0f);
		}
	}

	public static ActiveAnimation Play(Animation anim, string clipName, Direction playDirection, EnableCondition enableBeforePlay, DisableCondition disableCondition)
	{
		if (!NGUITools.GetActive(anim.gameObject))
		{
			if (enableBeforePlay != EnableCondition.EnableThenPlay)
			{
				return null;
			}
			NGUITools.SetActive(anim.gameObject, state: true);
			UIPanel[] componentsInChildren = anim.gameObject.GetComponentsInChildren<UIPanel>();
			int i = 0;
			for (int num = componentsInChildren.Length; i < num; i++)
			{
				componentsInChildren[i].Refresh();
			}
		}
		ActiveAnimation activeAnimation = anim.GetComponent<ActiveAnimation>();
		if (activeAnimation == null)
		{
			activeAnimation = anim.gameObject.AddComponent<ActiveAnimation>();
		}
		activeAnimation.mAnim = anim;
		activeAnimation.mDisableDirection = (Direction)disableCondition;
		activeAnimation.onFinished.Clear();
		activeAnimation.Play(clipName, playDirection);
		if (activeAnimation.mAnim != null)
		{
			activeAnimation.mAnim.Sample();
		}
		else if (activeAnimation.mAnimator != null)
		{
			activeAnimation.mAnimator.Update(0f);
		}
		return activeAnimation;
	}

	public static ActiveAnimation Play(Animation anim, string clipName, Direction playDirection)
	{
		return Play(anim, clipName, playDirection, EnableCondition.DoNothing, DisableCondition.DoNotDisable);
	}

	public static ActiveAnimation Play(Animation anim, Direction playDirection)
	{
		return Play(anim, null, playDirection, EnableCondition.DoNothing, DisableCondition.DoNotDisable);
	}

	public static ActiveAnimation Play(Animator anim, string clipName, Direction playDirection, EnableCondition enableBeforePlay, DisableCondition disableCondition)
	{
		if (enableBeforePlay != EnableCondition.IgnoreDisabledState && !NGUITools.GetActive(anim.gameObject))
		{
			if (enableBeforePlay != EnableCondition.EnableThenPlay)
			{
				return null;
			}
			NGUITools.SetActive(anim.gameObject, state: true);
			UIPanel[] componentsInChildren = anim.gameObject.GetComponentsInChildren<UIPanel>();
			int i = 0;
			for (int num = componentsInChildren.Length; i < num; i++)
			{
				componentsInChildren[i].Refresh();
			}
		}
		ActiveAnimation activeAnimation = anim.GetComponent<ActiveAnimation>();
		if (activeAnimation == null)
		{
			activeAnimation = anim.gameObject.AddComponent<ActiveAnimation>();
		}
		activeAnimation.mAnimator = anim;
		activeAnimation.mDisableDirection = (Direction)disableCondition;
		activeAnimation.onFinished.Clear();
		activeAnimation.Play(clipName, playDirection);
		if (activeAnimation.mAnim != null)
		{
			activeAnimation.mAnim.Sample();
		}
		else if (activeAnimation.mAnimator != null)
		{
			activeAnimation.mAnimator.Update(0f);
		}
		return activeAnimation;
	}
}
namespace AnimationOrTween
{
	public enum Trigger
	{
		OnClick,
		OnHover,
		OnPress,
		OnHoverTrue,
		OnHoverFalse,
		OnPressTrue,
		OnPressFalse,
		OnActivate,
		OnActivateTrue,
		OnActivateFalse,
		OnDoubleClick,
		OnSelect,
		OnSelectTrue,
		OnSelectFalse
	}
	public enum Direction
	{
		Reverse = -1,
		Toggle,
		Forward
	}
	public enum EnableCondition
	{
		DoNothing,
		EnableThenPlay,
		IgnoreDisabledState
	}
	public enum DisableCondition
	{
		DisableAfterReverse = -1,
		DoNotDisable,
		DisableAfterForward
	}
}
[Serializable]
public class BMFont
{
	[HideInInspector]
	[SerializeField]
	private int mSize = 16;

	[HideInInspector]
	[SerializeField]
	private int mBase;

	[HideInInspector]
	[SerializeField]
	private int mWidth;

	[HideInInspector]
	[SerializeField]
	private int mHeight;

	[HideInInspector]
	[SerializeField]
	private string mSpriteName;

	[HideInInspector]
	[SerializeField]
	private List<BMGlyph> mSaved = new List<BMGlyph>();

	private Dictionary<int, BMGlyph> mDict = new Dictionary<int, BMGlyph>();

	public bool isValid => mSaved.Count > 0;

	public int charSize
	{
		get
		{
			return mSize;
		}
		set
		{
			mSize = value;
		}
	}

	public int baseOffset
	{
		get
		{
			return mBase;
		}
		set
		{
			mBase = value;
		}
	}

	public int texWidth
	{
		get
		{
			return mWidth;
		}
		set
		{
			mWidth = value;
		}
	}

	public int texHeight
	{
		get
		{
			return mHeight;
		}
		set
		{
			mHeight = value;
		}
	}

	public int glyphCount => isValid ? mSaved.Count : 0;

	public string spriteName
	{
		get
		{
			return mSpriteName;
		}
		set
		{
			mSpriteName = value;
		}
	}

	public List<BMGlyph> glyphs => mSaved;

	public BMGlyph GetGlyph(int index, bool createIfMissing)
	{
		BMGlyph value = null;
		if (mDict.Count == 0)
		{
			int i = 0;
			for (int count = mSaved.Count; i < count; i++)
			{
				BMGlyph bMGlyph = mSaved[i];
				mDict.Add(bMGlyph.index, bMGlyph);
			}
		}
		if (!mDict.TryGetValue(index, out value) && createIfMissing)
		{
			value = new BMGlyph();
			value.index = index;
			mSaved.Add(value);
			mDict.Add(index, value);
		}
		return value;
	}

	public BMGlyph GetGlyph(int index)
	{
		return GetGlyph(index, createIfMissing: false);
	}

	public void Clear()
	{
		mDict.Clear();
		mSaved.Clear();
	}

	public void Trim(int xMin, int yMin, int xMax, int yMax)
	{
		if (isValid)
		{
			int i = 0;
			for (int count = mSaved.Count; i < count; i++)
			{
				mSaved[i]?.Trim(xMin, yMin, xMax, yMax);
			}
		}
	}
}
[Serializable]
public class BMGlyph
{
	public int index;

	public int x;

	public int y;

	public int width;

	public int height;

	public int offsetX;

	public int offsetY;

	public int advance;

	public int channel;

	public List<int> kerning;

	public int GetKerning(int previousChar)
	{
		if (kerning != null && previousChar != 0)
		{
			int i = 0;
			for (int count = kerning.Count; i < count; i += 2)
			{
				if (kerning[i] == previousChar)
				{
					return kerning[i + 1];
				}
			}
		}
		return 0;
	}

	public void SetKerning(int previousChar, int amount)
	{
		if (kerning == null)
		{
			kerning = new List<int>();
		}
		for (int i = 0; i < kerning.Count; i += 2)
		{
			if (kerning[i] == previousChar)
			{
				kerning[i + 1] = amount;
				return;
			}
		}
		kerning.Add(previousChar);
		kerning.Add(amount);
	}

	public void Trim(int xMin, int yMin, int xMax, int yMax)
	{
		int num = x + width;
		int num2 = y + height;
		if (x < xMin)
		{
			int num3 = xMin - x;
			x += num3;
			width -= num3;
			offsetX += num3;
		}
		if (y < yMin)
		{
			int num4 = yMin - y;
			y += num4;
			height -= num4;
			offsetY += num4;
		}
		if (num > xMax)
		{
			width -= num - xMax;
		}
		if (num2 > yMax)
		{
			height -= num2 - yMax;
		}
	}
}
[Serializable]
public class BMSymbol
{
	public string sequence;

	public string spriteName;

	private UISpriteData mSprite;

	private bool mIsValid;

	private int mLength;

	private int mOffsetX;

	private int mOffsetY;

	private int mWidth;

	private int mHeight;

	private int mAdvance;

	private Rect mUV;

	public int length
	{
		get
		{
			if (mLength == 0)
			{
				mLength = sequence.Length;
			}
			return mLength;
		}
	}

	public int offsetX => mOffsetX;

	public int offsetY => mOffsetY;

	public int width => mWidth;

	public int height => mHeight;

	public int advance => mAdvance;

	public Rect uvRect => mUV;

	public void MarkAsChanged()
	{
		mIsValid = false;
	}

	public bool Validate(UIAtlas atlas)
	{
		if (atlas == null)
		{
			return false;
		}
		if (!mIsValid)
		{
			if (string.IsNullOrEmpty(spriteName))
			{
				return false;
			}
			mSprite = ((!(atlas != null)) ? null : atlas.GetSprite(spriteName));
			if (mSprite != null)
			{
				Texture texture = atlas.texture;
				if (texture == null)
				{
					mSprite = null;
				}
				else
				{
					mUV = new Rect(mSprite.x, mSprite.y, mSprite.width, mSprite.height);
					mUV = NGUIMath.ConvertToTexCoords(mUV, texture.width, texture.height);
					mOffsetX = mSprite.paddingLeft;
					mOffsetY = mSprite.paddingTop;
					mWidth = mSprite.width;
					mHeight = mSprite.height;
					mAdvance = mSprite.width + (mSprite.paddingLeft + mSprite.paddingRight);
					mIsValid = true;
				}
			}
		}
		return mSprite != null;
	}
}
public class BetterList<T>
{
	public delegate int CompareFunc(T left, T right);

	public T[] buffer;

	public int size;

	[DebuggerHidden]
	public T this[int i]
	{
		get
		{
			return buffer[i];
		}
		set
		{
			buffer[i] = value;
		}
	}

	[DebuggerStepThrough]
	public IEnumerator<T> GetEnumerator()
	{
		if (buffer != null)
		{
			for (int i = 0; i < size; i++)
			{
				yield return buffer[i];
			}
		}
	}

	private void AllocateMore()
	{
		T[] array = ((buffer == null) ? new T[32] : new T[Mathf.Max(buffer.Length << 1, 32)]);
		if (buffer != null && size > 0)
		{
			buffer.CopyTo(array, 0);
		}
		buffer = array;
	}

	private void Trim()
	{
		if (size > 0)
		{
			if (size < buffer.Length)
			{
				T[] array = new T[size];
				for (int i = 0; i < size; i++)
				{
					array[i] = buffer[i];
				}
				buffer = array;
			}
		}
		else
		{
			buffer = null;
		}
	}

	public void Clear()
	{
		size = 0;
	}

	public void Release()
	{
		size = 0;
		buffer = null;
	}

	public void Add(T item)
	{
		if (buffer == null || size == buffer.Length)
		{
			AllocateMore();
		}
		buffer[size++] = item;
	}

	public void Insert(int index, T item)
	{
		if (buffer == null || size == buffer.Length)
		{
			AllocateMore();
		}
		if (index > -1 && index < size)
		{
			for (int num = size; num > index; num--)
			{
				buffer[num] = buffer[num - 1];
			}
			buffer[index] = item;
			size++;
		}
		else
		{
			Add(item);
		}
	}

	public bool Contains(T item)
	{
		if (buffer == null)
		{
			return false;
		}
		for (int i = 0; i < size; i++)
		{
			if (buffer[i].Equals(item))
			{
				return true;
			}
		}
		return false;
	}

	public int IndexOf(T item)
	{
		if (buffer == null)
		{
			return -1;
		}
		for (int i = 0; i < size; i++)
		{
			if (buffer[i].Equals(item))
			{
				return i;
			}
		}
		return -1;
	}

	public bool Remove(T item)
	{
		if (buffer != null)
		{
			EqualityComparer<T> @default = EqualityComparer<T>.Default;
			for (int i = 0; i < size; i++)
			{
				if (@default.Equals(buffer[i], item))
				{
					size--;
					buffer[i] = default(T);
					for (int j = i; j < size; j++)
					{
						buffer[j] = buffer[j + 1];
					}
					buffer[size] = default(T);
					return true;
				}
			}
		}
		return false;
	}

	public void RemoveAt(int index)
	{
		if (buffer != null && index > -1 && index < size)
		{
			size--;
			buffer[index] = default(T);
			for (int i = index; i < size; i++)
			{
				buffer[i] = buffer[i + 1];
			}
			buffer[size] = default(T);
		}
	}

	public T Pop()
	{
		if (buffer != null && size != 0)
		{
			T result = buffer[--size];
			buffer[size] = default(T);
			return result;
		}
		return default(T);
	}

	public T[] ToArray()
	{
		Trim();
		return buffer;
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public void Sort(CompareFunc comparer)
	{
		int num = 0;
		int num2 = size - 1;
		bool flag = true;
		while (flag)
		{
			flag = false;
			for (int i = num; i < num2; i++)
			{
				if (comparer(buffer[i], buffer[i + 1]) > 0)
				{
					T val = buffer[i];
					buffer[i] = buffer[i + 1];
					buffer[i + 1] = val;
					flag = true;
				}
				else if (!flag)
				{
					num = ((i != 0) ? (i - 1) : 0);
				}
			}
		}
	}
}
public class ByteReader
{
	private byte[] mBuffer;

	private int mOffset;

	private static BetterList<string> mTemp = new BetterList<string>();

	public bool canRead => mBuffer != null && mOffset < mBuffer.Length;

	public ByteReader(byte[] bytes)
	{
		mBuffer = bytes;
	}

	public ByteReader(TextAsset asset)
	{
		mBuffer = asset.bytes;
	}

	public static ByteReader Open(string path)
	{
		FileStream fileStream = File.OpenRead(path);
		if (fileStream != null)
		{
			fileStream.Seek(0L, SeekOrigin.End);
			byte[] array = new byte[fileStream.Position];
			fileStream.Seek(0L, SeekOrigin.Begin);
			fileStream.Read(array, 0, array.Length);
			fileStream.Close();
			return new ByteReader(array);
		}
		return null;
	}

	private static string ReadLine(byte[] buffer, int start, int count)
	{
		return Encoding.UTF8.GetString(buffer, start, count);
	}

	public string ReadLine()
	{
		return ReadLine(skipEmptyLines: true);
	}

	public string ReadLine(bool skipEmptyLines)
	{
		int num = mBuffer.Length;
		if (skipEmptyLines)
		{
			while (mOffset < num && mBuffer[mOffset] < 32)
			{
				mOffset++;
			}
		}
		int num2 = mOffset;
		if (num2 < num)
		{
			int num3;
			do
			{
				if (num2 < num)
				{
					num3 = mBuffer[num2++];
					continue;
				}
				num2++;
				break;
			}
			while (num3 != 10 && num3 != 13);
			string result = ReadLine(mBuffer, mOffset, num2 - mOffset - 1);
			mOffset = num2;
			return result;
		}
		mOffset = num;
		return null;
	}

	public Dictionary<string, string> ReadDictionary()
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		char[] separator = new char[1] { '=' };
		while (canRead)
		{
			string text = ReadLine();
			if (text == null)
			{
				break;
			}
			if (!text.StartsWith("//"))
			{
				string[] array = text.Split(separator, 2, StringSplitOptions.RemoveEmptyEntries);
				if (array.Length == 2)
				{
					string key = array[0].Trim();
					string value = array[1].Trim().Replace("\\n", "\n");
					dictionary[key] = value;
				}
			}
		}
		return dictionary;
	}

	public BetterList<string> ReadCSV()
	{
		mTemp.Clear();
		string text = string.Empty;
		bool flag = false;
		int num = 0;
		while (canRead)
		{
			if (flag)
			{
				string text2 = ReadLine(skipEmptyLines: false);
				if (text2 == null)
				{
					return null;
				}
				text2 = text2.Replace("\\n", "\n");
				text = text + "\n" + text2;
			}
			else
			{
				text = ReadLine(skipEmptyLines: true);
				if (text == null)
				{
					return null;
				}
				text = text.Replace("\\n", "\n");
				num = 0;
			}
			int i = num;
			for (int length = text.Length; i < length; i++)
			{
				switch (text[i])
				{
				case ',':
					if (!flag)
					{
						mTemp.Add(text.Substring(num, i - num));
						num = i + 1;
					}
					break;
				case '"':
					if (flag)
					{
						if (i + 1 >= length)
						{
							mTemp.Add(text.Substring(num, i - num).Replace("\"\"", "\""));
							return mTemp;
						}
						if (text[i + 1] != '"')
						{
							mTemp.Add(text.Substring(num, i - num).Replace("\"\"", "\""));
							flag = false;
							if (text[i + 1] == ',')
							{
								i++;
								num = i + 1;
							}
						}
						else
						{
							i++;
						}
					}
					else
					{
						num = i + 1;
						flag = true;
					}
					break;
				}
			}
			if (num < text.Length)
			{
				if (flag)
				{
					continue;
				}
				mTemp.Add(text.Substring(num, text.Length - num));
			}
			return mTemp;
		}
		return null;
	}
}
[Serializable]
public class EventDelegate
{
	[Serializable]
	public class Parameter
	{
		public UnityEngine.Object obj;

		public string field;

		[NonSerialized]
		private object mValue;

		[NonSerialized]
		public Type expectedType = typeof(void);

		[NonSerialized]
		public bool cached;

		[NonSerialized]
		public PropertyInfo propInfo;

		[NonSerialized]
		public FieldInfo fieldInfo;

		public object value
		{
			get
			{
				if (mValue != null)
				{
					return mValue;
				}
				if (!cached)
				{
					cached = true;
					fieldInfo = null;
					propInfo = null;
					if (obj != null && !string.IsNullOrEmpty(field))
					{
						Type type = obj.GetType();
						propInfo = type.GetProperty(field);
						if (propInfo == null)
						{
							fieldInfo = type.GetField(field);
						}
					}
				}
				if (propInfo != null)
				{
					return propInfo.GetValue(obj, null);
				}
				if (fieldInfo != null)
				{
					return fieldInfo.GetValue(obj);
				}
				if (obj != null)
				{
					return obj;
				}
				if (expectedType != null && expectedType.IsValueType)
				{
					return null;
				}
				return Convert.ChangeType(null, expectedType);
			}
			set
			{
				mValue = value;
			}
		}

		public Type type
		{
			get
			{
				if (mValue != null)
				{
					return mValue.GetType();
				}
				if (obj == null)
				{
					return typeof(void);
				}
				return obj.GetType();
			}
		}

		public Parameter()
		{
		}

		public Parameter(UnityEngine.Object obj, string field)
		{
			this.obj = obj;
			this.field = field;
		}

		public Parameter(object val)
		{
			mValue = val;
		}
	}

	public delegate void Callback();

	[SerializeField]
	private MonoBehaviour mTarget;

	[SerializeField]
	private string mMethodName;

	[SerializeField]
	private Parameter[] mParameters;

	public bool oneShot;

	[NonSerialized]
	private Callback mCachedCallback;

	[NonSerialized]
	private bool mRawDelegate;

	[NonSerialized]
	private bool mCached;

	[NonSerialized]
	private MethodInfo mMethod;

	[NonSerialized]
	private object[] mArgs;

	private static int s_Hash = "EventDelegate".GetHashCode();

	public MonoBehaviour target
	{
		get
		{
			return mTarget;
		}
		set
		{
			mTarget = value;
			mCachedCallback = null;
			mRawDelegate = false;
			mCached = false;
			mMethod = null;
			mParameters = null;
		}
	}

	public string methodName
	{
		get
		{
			return mMethodName;
		}
		set
		{
			mMethodName = value;
			mCachedCallback = null;
			mRawDelegate = false;
			mCached = false;
			mMethod = null;
			mParameters = null;
		}
	}

	public Parameter[] parameters
	{
		get
		{
			if (!mCached)
			{
				Cache();
			}
			return mParameters;
		}
	}

	public bool isValid
	{
		get
		{
			if (!mCached)
			{
				Cache();
			}
			return (mRawDelegate && mCachedCallback != null) || (mTarget != null && !string.IsNullOrEmpty(mMethodName));
		}
	}

	public bool isEnabled
	{
		get
		{
			if (!mCached)
			{
				Cache();
			}
			if (mRawDelegate && mCachedCallback != null)
			{
				return true;
			}
			if (mTarget == null)
			{
				return false;
			}
			MonoBehaviour monoBehaviour = mTarget;
			return monoBehaviour == null || monoBehaviour.enabled;
		}
	}

	public EventDelegate()
	{
	}

	public EventDelegate(Callback call)
	{
		Set(call);
	}

	public EventDelegate(MonoBehaviour target, string methodName)
	{
		Set(target, methodName);
	}

	private static string GetMethodName(Callback callback)
	{
		return callback.Method.Name;
	}

	private static bool IsValid(Callback callback)
	{
		return callback != null && callback.Method != null;
	}

	public override bool Equals(object obj)
	{
		if (obj == null)
		{
			return !isValid;
		}
		if (obj is Callback)
		{
			Callback callback = obj as Callback;
			if (callback.Equals(mCachedCallback))
			{
				return true;
			}
			MonoBehaviour monoBehaviour = callback.Target as MonoBehaviour;
			return mTarget == monoBehaviour && string.Equals(mMethodName, GetMethodName(callback));
		}
		if (obj is EventDelegate)
		{
			EventDelegate eventDelegate = obj as EventDelegate;
			return mTarget == eventDelegate.mTarget && string.Equals(mMethodName, eventDelegate.mMethodName);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return s_Hash;
	}

	private void Set(Callback call)
	{
		Clear();
		if (call != null && IsValid(call))
		{
			mTarget = call.Target as MonoBehaviour;
			if (mTarget == null)
			{
				mRawDelegate = true;
				mCachedCallback = call;
				mMethodName = null;
			}
			else
			{
				mMethodName = GetMethodName(call);
				mRawDelegate = false;
			}
		}
	}

	public void Set(MonoBehaviour target, string methodName)
	{
		Clear();
		mTarget = target;
		mMethodName = methodName;
	}

	private void Cache()
	{
		mCached = true;
		if (mRawDelegate || (mCachedCallback != null && !(mCachedCallback.Target as MonoBehaviour != mTarget) && !(GetMethodName(mCachedCallback) != mMethodName)) || !(mTarget != null) || string.IsNullOrEmpty(mMethodName))
		{
			return;
		}
		Type type = mTarget.GetType();
		mMethod = null;
		while (type != null)
		{
			try
			{
				mMethod = type.GetMethod(mMethodName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				if (mMethod != null)
				{
					break;
				}
			}
			catch (Exception)
			{
			}
			type = type.BaseType;
		}
		if (mMethod == null)
		{
			UnityEngine.Debug.LogError("Could not find method '" + mMethodName + "' on " + mTarget.GetType(), mTarget);
			return;
		}
		if (mMethod.ReturnType != typeof(void))
		{
			UnityEngine.Debug.LogError(string.Concat(mTarget.GetType(), ".", mMethodName, " must have a 'void' return type."), mTarget);
			return;
		}
		ParameterInfo[] array = mMethod.GetParameters();
		if (array.Length == 0)
		{
			mCachedCallback = (Callback)Delegate.CreateDelegate(typeof(Callback), mTarget, mMethodName);
			mArgs = null;
			mParameters = null;
			return;
		}
		mCachedCallback = null;
		if (mParameters == null || mParameters.Length != array.Length)
		{
			mParameters = new Parameter[array.Length];
			int i = 0;
			for (int num = mParameters.Length; i < num; i++)
			{
				mParameters[i] = new Parameter();
			}
		}
		int j = 0;
		for (int num2 = mParameters.Length; j < num2; j++)
		{
			mParameters[j].expectedType = array[j].ParameterType;
		}
	}

	public bool Execute()
	{
		if (!mCached)
		{
			Cache();
		}
		if (mCachedCallback != null)
		{
			mCachedCallback();
			return true;
		}
		if (mMethod != null)
		{
			if (mParameters == null || mParameters.Length == 0)
			{
				mMethod.Invoke(mTarget, null);
			}
			else
			{
				if (mArgs == null || mArgs.Length != mParameters.Length)
				{
					mArgs = new object[mParameters.Length];
				}
				int i = 0;
				for (int num = mParameters.Length; i < num; i++)
				{
					mArgs[i] = mParameters[i].value;
				}
				try
				{
					mMethod.Invoke(mTarget, mArgs);
				}
				catch (ArgumentException ex)
				{
					string text = "Error calling ";
					if (mTarget == null)
					{
						text += mMethod.Name;
					}
					else
					{
						string text2 = text;
						text = string.Concat(text2, mTarget.GetType(), ".", mMethod.Name);
					}
					text = text + ": " + ex.Message;
					text += "\n  Expected: ";
					ParameterInfo[] array = mMethod.GetParameters();
					if (array.Length == 0)
					{
						text += "no arguments";
					}
					else
					{
						text += array[0];
						for (int j = 1; j < array.Length; j++)
						{
							text = text + ", " + array[j].ParameterType;
						}
					}
					text += "\n  Received: ";
					if (mParameters.Length == 0)
					{
						text += "no arguments";
					}
					else
					{
						text += mParameters[0].type;
						for (int k = 1; k < mParameters.Length; k++)
						{
							text = text + ", " + mParameters[k].type;
						}
					}
					text += "\n";
					UnityEngine.Debug.LogError(text);
				}
				int l = 0;
				for (int num2 = mArgs.Length; l < num2; l++)
				{
					mArgs[l] = null;
				}
			}
			return true;
		}
		return false;
	}

	public void Clear()
	{
		mTarget = null;
		mMethodName = null;
		mRawDelegate = false;
		mCachedCallback = null;
		mParameters = null;
		mCached = false;
		mMethod = null;
		mArgs = null;
	}

	public override string ToString()
	{
		if (mTarget != null)
		{
			string text = mTarget.GetType().ToString();
			int num = text.LastIndexOf('.');
			if (num > 0)
			{
				text = text.Substring(num + 1);
			}
			if (!string.IsNullOrEmpty(methodName))
			{
				return text + "/" + methodName;
			}
			return text + "/[delegate]";
		}
		return (!mRawDelegate) ? null : "[delegate]";
	}

	public static void Execute(List<EventDelegate> list)
	{
		if (list == null)
		{
			return;
		}
		int num = 0;
		while (num < list.Count)
		{
			EventDelegate eventDelegate = list[num];
			if (eventDelegate != null)
			{
				try
				{
					eventDelegate.Execute();
				}
				catch (Exception ex)
				{
					if (ex.InnerException != null)
					{
						UnityEngine.Debug.LogError(ex.InnerException.Message);
					}
					else
					{
						UnityEngine.Debug.LogError(ex.Message);
					}
				}
				if (num >= list.Count)
				{
					break;
				}
				if (list[num] != eventDelegate)
				{
					continue;
				}
				if (eventDelegate.oneShot)
				{
					list.RemoveAt(num);
					continue;
				}
			}
			num++;
		}
	}

	public static bool IsValid(List<EventDelegate> list)
	{
		if (list != null)
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				EventDelegate eventDelegate = list[i];
				if (eventDelegate != null && eventDelegate.isValid)
				{
					return true;
				}
			}
		}
		return false;
	}

	public static EventDelegate Set(List<EventDelegate> list, Callback callback)
	{
		if (list != null)
		{
			EventDelegate eventDelegate = new EventDelegate(callback);
			list.Clear();
			list.Add(eventDelegate);
			return eventDelegate;
		}
		return null;
	}

	public static void Set(List<EventDelegate> list, EventDelegate del)
	{
		if (list != null)
		{
			list.Clear();
			list.Add(del);
		}
	}

	public static EventDelegate Add(List<EventDelegate> list, Callback callback)
	{
		return Add(list, callback, oneShot: false);
	}

	public static EventDelegate Add(List<EventDelegate> list, Callback callback, bool oneShot)
	{
		if (list != null)
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				EventDelegate eventDelegate = list[i];
				if (eventDelegate != null && eventDelegate.Equals(callback))
				{
					return eventDelegate;
				}
			}
			EventDelegate eventDelegate2 = new EventDelegate(callback);
			eventDelegate2.oneShot = oneShot;
			list.Add(eventDelegate2);
			return eventDelegate2;
		}
		UnityEngine.Debug.LogWarning("Attempting to add a callback to a list that's null");
		return null;
	}

	public static void Add(List<EventDelegate> list, EventDelegate ev)
	{
		Add(list, ev, ev.oneShot);
	}

	public static void Add(List<EventDelegate> list, EventDelegate ev, bool oneShot)
	{
		if (ev.mRawDelegate || ev.target == null || string.IsNullOrEmpty(ev.methodName))
		{
			Add(list, ev.mCachedCallback, oneShot);
		}
		else if (list != null)
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				EventDelegate eventDelegate = list[i];
				if (eventDelegate != null && eventDelegate.Equals(ev))
				{
					return;
				}
			}
			EventDelegate eventDelegate2 = new EventDelegate(ev.target, ev.methodName);
			eventDelegate2.oneShot = oneShot;
			if (ev.mParameters != null && ev.mParameters.Length > 0)
			{
				eventDelegate2.mParameters = new Parameter[ev.mParameters.Length];
				for (int j = 0; j < ev.mParameters.Length; j++)
				{
					eventDelegate2.mParameters[j] = ev.mParameters[j];
				}
			}
			list.Add(eventDelegate2);
		}
		else
		{
			UnityEngine.Debug.LogWarning("Attempting to add a callback to a list that's null");
		}
	}

	public static bool Remove(List<EventDelegate> list, Callback callback)
	{
		if (list != null)
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				EventDelegate eventDelegate = list[i];
				if (eventDelegate != null && eventDelegate.Equals(callback))
				{
					list.RemoveAt(i);
					return true;
				}
			}
		}
		return false;
	}

	public static bool Remove(List<EventDelegate> list, EventDelegate ev)
	{
		if (list != null)
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				EventDelegate eventDelegate = list[i];
				if (eventDelegate != null && eventDelegate.Equals(ev))
				{
					list.RemoveAt(i);
					return true;
				}
			}
		}
		return false;
	}
}
public static class Localization
{
	public delegate byte[] LoadFunction(string path);

	public static LoadFunction loadFunction;

	public static bool localizationHasBeenSet = false;

	private static string[] mLanguages = null;

	private static Dictionary<string, string> mOldDictionary = new Dictionary<string, string>();

	private static Dictionary<string, string[]> mDictionary = new Dictionary<string, string[]>();

	private static int mLanguageIndex = -1;

	private static string mLanguage;

	public static Dictionary<string, string[]> dictionary
	{
		get
		{
			if (!localizationHasBeenSet)
			{
				language = PlayerPrefs.GetString("Language", "English");
			}
			return mDictionary;
		}
		set
		{
			localizationHasBeenSet = value != null;
			mDictionary = value;
		}
	}

	public static string[] knownLanguages
	{
		get
		{
			if (!localizationHasBeenSet)
			{
				LoadDictionary(PlayerPrefs.GetString("Language", "English"));
			}
			return mLanguages;
		}
	}

	public static string language
	{
		get
		{
			if (string.IsNullOrEmpty(mLanguage))
			{
				string[] array = knownLanguages;
				mLanguage = PlayerPrefs.GetString("Language", (array == null) ? "English" : array[0]);
				LoadAndSelect(mLanguage);
			}
			return mLanguage;
		}
		set
		{
			if (mLanguage != value)
			{
				mLanguage = value;
				LoadAndSelect(value);
			}
		}
	}

	[Obsolete("Localization is now always active. You no longer need to check this property.")]
	public static bool isActive => true;

	private static bool LoadDictionary(string value)
	{
		byte[] array = null;
		if (!localizationHasBeenSet)
		{
			if (loadFunction == null)
			{
				TextAsset textAsset = Resources.Load<TextAsset>("Localization");
				if (textAsset != null)
				{
					array = textAsset.bytes;
				}
			}
			else
			{
				array = loadFunction("Localization");
			}
			localizationHasBeenSet = true;
		}
		if (LoadCSV(array))
		{
			return true;
		}
		if (string.IsNullOrEmpty(value))
		{
			return false;
		}
		if (loadFunction == null)
		{
			TextAsset textAsset2 = Resources.Load<TextAsset>(value);
			if (textAsset2 != null)
			{
				array = textAsset2.bytes;
			}
		}
		else
		{
			array = loadFunction(value);
		}
		if (array != null)
		{
			Set(value, array);
			return true;
		}
		return false;
	}

	private static bool LoadAndSelect(string value)
	{
		if (!string.IsNullOrEmpty(value))
		{
			if (mDictionary.Count == 0 && !LoadDictionary(value))
			{
				return false;
			}
			if (SelectLanguage(value))
			{
				return true;
			}
		}
		if (mOldDictionary.Count > 0)
		{
			return true;
		}
		mOldDictionary.Clear();
		mDictionary.Clear();
		if (string.IsNullOrEmpty(value))
		{
			PlayerPrefs.DeleteKey("Language");
		}
		return false;
	}

	public static void Load(TextAsset asset)
	{
		ByteReader byteReader = new ByteReader(asset);
		Set(asset.name, byteReader.ReadDictionary());
	}

	public static void Set(string languageName, byte[] bytes)
	{
		ByteReader byteReader = new ByteReader(bytes);
		Set(languageName, byteReader.ReadDictionary());
	}

	public static bool LoadCSV(TextAsset asset)
	{
		return LoadCSV(asset.bytes, asset);
	}

	public static bool LoadCSV(byte[] bytes)
	{
		return LoadCSV(bytes, null);
	}

	private static bool LoadCSV(byte[] bytes, TextAsset asset)
	{
		if (bytes == null)
		{
			return false;
		}
		ByteReader byteReader = new ByteReader(bytes);
		BetterList<string> betterList = byteReader.ReadCSV();
		if (betterList.size < 2)
		{
			return false;
		}
		betterList[0] = "KEY";
		if (!string.Equals(betterList[0], "KEY"))
		{
			UnityEngine.Debug.LogError("Invalid localization CSV file. The first value is expected to be 'KEY', followed by language columns.\nInstead found '" + betterList[0] + "'", asset);
			return false;
		}
		mLanguages = new string[betterList.size - 1];
		for (int i = 0; i < mLanguages.Length; i++)
		{
			mLanguages[i] = betterList[i + 1];
		}
		mDictionary.Clear();
		while (betterList != null)
		{
			AddCSV(betterList);
			betterList = byteReader.ReadCSV();
		}
		return true;
	}

	private static bool SelectLanguage(string language)
	{
		mLanguageIndex = -1;
		if (mDictionary.Count == 0)
		{
			return false;
		}
		if (mDictionary.TryGetValue("KEY", out var value))
		{
			for (int i = 0; i < value.Length; i++)
			{
				if (value[i] == language)
				{
					mOldDictionary.Clear();
					mLanguageIndex = i;
					mLanguage = language;
					PlayerPrefs.SetString("Language", mLanguage);
					UIRoot.Broadcast("OnLocalize");
					return true;
				}
			}
		}
		return false;
	}

	private static void AddCSV(BetterList<string> values)
	{
		if (values.size < 2)
		{
			return;
		}
		string[] array = new string[values.size - 1];
		for (int i = 1; i < values.size; i++)
		{
			array[i - 1] = values[i];
		}
		try
		{
			mDictionary.Add(values[0], array);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("Unable to add '" + values[0] + "' to the Localization dictionary.\n" + ex.Message);
		}
	}

	public static void Set(string languageName, Dictionary<string, string> dictionary)
	{
		mLanguage = languageName;
		PlayerPrefs.SetString("Language", mLanguage);
		mOldDictionary = dictionary;
		localizationHasBeenSet = false;
		mLanguageIndex = -1;
		mLanguages = new string[1] { languageName };
		UIRoot.Broadcast("OnLocalize");
	}

	public static string Get(string key)
	{
		if (!localizationHasBeenSet)
		{
			language = PlayerPrefs.GetString("Language", "English");
		}
		string key2 = key + " Mobile";
		string value2;
		if (mLanguageIndex != -1 && mDictionary.TryGetValue(key2, out var value))
		{
			if (mLanguageIndex < value.Length)
			{
				return value[mLanguageIndex];
			}
		}
		else if (mOldDictionary.TryGetValue(key2, out value2))
		{
			return value2;
		}
		if (mLanguageIndex != -1 && mDictionary.TryGetValue(key, out value))
		{
			if (mLanguageIndex < value.Length)
			{
				return value[mLanguageIndex];
			}
		}
		else if (mOldDictionary.TryGetValue(key, out value2))
		{
			return value2;
		}
		return key;
	}

	public static string Format(string key, params object[] parameters)
	{
		return string.Format(Get(key), parameters);
	}

	[Obsolete("Use Localization.Get instead")]
	public static string Localize(string key)
	{
		return Get(key);
	}

	public static bool Exists(string key)
	{
		if (!localizationHasBeenSet)
		{
			language = PlayerPrefs.GetString("Language", "English");
		}
		string key2 = key + " Mobile";
		if (mDictionary.ContainsKey(key2))
		{
			return true;
		}
		if (mOldDictionary.ContainsKey(key2))
		{
			return true;
		}
		return mDictionary.ContainsKey(key) || mOldDictionary.ContainsKey(key);
	}
}
[AddComponentMenu("NGUI/Internal/Debug")]
public class NGUIDebug : MonoBehaviour
{
	private static bool mRayDebug = false;

	private static List<string> mLines = new List<string>();

	private static NGUIDebug mInstance = null;

	public static bool debugRaycast
	{
		get
		{
			return mRayDebug;
		}
		set
		{
			if (Application.isPlaying)
			{
				mRayDebug = value;
				if (value)
				{
					CreateInstance();
				}
			}
		}
	}

	public static void CreateInstance()
	{
		if (mInstance == null)
		{
			GameObject gameObject = new GameObject("_NGUI Debug");
			mInstance = gameObject.AddComponent<NGUIDebug>();
			UnityEngine.Object.DontDestroyOnLoad(gameObject);
		}
	}

	private static void LogString(string text)
	{
		if (Application.isPlaying)
		{
			if (mLines.Count > 20)
			{
				mLines.RemoveAt(0);
			}
			mLines.Add(text);
			CreateInstance();
		}
		else
		{
			UnityEngine.Debug.Log(text);
		}
	}

	public static void Log(params object[] objs)
	{
		string text = string.Empty;
		for (int i = 0; i < objs.Length; i++)
		{
			text = ((i != 0) ? (text + ", " + objs[i].ToString()) : (text + objs[i].ToString()));
		}
		LogString(text);
	}

	public static void Clear()
	{
		mLines.Clear();
	}

	public static void DrawBounds(Bounds b)
	{
		Vector3 center = b.center;
		Vector3 vector = b.center - b.extents;
		Vector3 vector2 = b.center + b.extents;
		UnityEngine.Debug.DrawLine(new Vector3(vector.x, vector.y, center.z), new Vector3(vector2.x, vector.y, center.z), UnityEngine.Color.red);
		UnityEngine.Debug.DrawLine(new Vector3(vector.x, vector.y, center.z), new Vector3(vector.x, vector2.y, center.z), UnityEngine.Color.red);
		UnityEngine.Debug.DrawLine(new Vector3(vector2.x, vector.y, center.z), new Vector3(vector2.x, vector2.y, center.z), UnityEngine.Color.red);
		UnityEngine.Debug.DrawLine(new Vector3(vector.x, vector2.y, center.z), new Vector3(vector2.x, vector2.y, center.z), UnityEngine.Color.red);
	}

	private void OnGUI()
	{
		if (mLines.Count == 0)
		{
			if (mRayDebug && UICamera.hoveredObject != null && Application.isPlaying)
			{
				GUILayout.Label("Last Hit: " + NGUITools.GetHierarchy(UICamera.hoveredObject).Replace("\"", string.Empty));
			}
			return;
		}
		int i = 0;
		for (int count = mLines.Count; i < count; i++)
		{
			GUILayout.Label(mLines[i]);
		}
	}
}
public static class NGUIMath
{
	[DebuggerHidden]
	[DebuggerStepThrough]
	public static float Lerp(float from, float to, float factor)
	{
		return from * (1f - factor) + to * factor;
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static int ClampIndex(int val, int max)
	{
		return (val >= 0) ? ((val >= max) ? (max - 1) : val) : 0;
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static int RepeatIndex(int val, int max)
	{
		if (max < 1)
		{
			return 0;
		}
		while (val < 0)
		{
			val += max;
		}
		while (val >= max)
		{
			val -= max;
		}
		return val;
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static float WrapAngle(float angle)
	{
		while (angle > 180f)
		{
			angle -= 360f;
		}
		while (angle < -180f)
		{
			angle += 360f;
		}
		return angle;
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static float Wrap01(float val)
	{
		return val - (float)Mathf.FloorToInt(val);
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static int HexToDecimal(char ch)
	{
		switch (ch)
		{
		case '0':
			return 0;
		case '1':
			return 1;
		case '2':
			return 2;
		case '3':
			return 3;
		case '4':
			return 4;
		case '5':
			return 5;
		case '6':
			return 6;
		case '7':
			return 7;
		case '8':
			return 8;
		case '9':
			return 9;
		case 'A':
		case 'a':
			return 10;
		case 'B':
		case 'b':
			return 11;
		case 'C':
		case 'c':
			return 12;
		case 'D':
		case 'd':
			return 13;
		case 'E':
		case 'e':
			return 14;
		case 'F':
		case 'f':
			return 15;
		default:
			return 15;
		}
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static char DecimalToHexChar(int num)
	{
		if (num > 15)
		{
			return 'F';
		}
		if (num < 10)
		{
			return (char)(48 + num);
		}
		return (char)(65 + num - 10);
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static string DecimalToHex8(int num)
	{
		num &= 0xFF;
		return num.ToString("X2");
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static string DecimalToHex24(int num)
	{
		num &= 0xFFFFFF;
		return num.ToString("X6");
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static string DecimalToHex32(int num)
	{
		return num.ToString("X8");
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static int ColorToInt(UnityEngine.Color c)
	{
		int num = 0;
		num |= Mathf.RoundToInt(c.r * 255f) << 24;
		num |= Mathf.RoundToInt(c.g * 255f) << 16;
		num |= Mathf.RoundToInt(c.b * 255f) << 8;
		return num | Mathf.RoundToInt(c.a * 255f);
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static UnityEngine.Color IntToColor(int val)
	{
		float num = 0.003921569f;
		UnityEngine.Color black = UnityEngine.Color.black;
		black.r = num * (float)((val >> 24) & 0xFF);
		black.g = num * (float)((val >> 16) & 0xFF);
		black.b = num * (float)((val >> 8) & 0xFF);
		black.a = num * (float)(val & 0xFF);
		return black;
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static string IntToBinary(int val, int bits)
	{
		string text = string.Empty;
		int num = bits;
		while (num > 0)
		{
			if (num == 8 || num == 16 || num == 24)
			{
				text += " ";
			}
			text += (((val & (1 << --num)) == 0) ? '0' : '1');
		}
		return text;
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static UnityEngine.Color HexToColor(uint val)
	{
		return IntToColor((int)val);
	}

	public static Rect ConvertToTexCoords(Rect rect, int width, int height)
	{
		Rect result = rect;
		if ((float)width != 0f && (float)height != 0f)
		{
			result.xMin = rect.xMin / (float)width;
			result.xMax = rect.xMax / (float)width;
			result.yMin = 1f - rect.yMax / (float)height;
			result.yMax = 1f - rect.yMin / (float)height;
		}
		return result;
	}

	public static Rect ConvertToPixels(Rect rect, int width, int height, bool round)
	{
		Rect result = rect;
		if (round)
		{
			result.xMin = Mathf.RoundToInt(rect.xMin * (float)width);
			result.xMax = Mathf.RoundToInt(rect.xMax * (float)width);
			result.yMin = Mathf.RoundToInt((1f - rect.yMax) * (float)height);
			result.yMax = Mathf.RoundToInt((1f - rect.yMin) * (float)height);
		}
		else
		{
			result.xMin = rect.xMin * (float)width;
			result.xMax = rect.xMax * (float)width;
			result.yMin = (1f - rect.yMax) * (float)height;
			result.yMax = (1f - rect.yMin) * (float)height;
		}
		return result;
	}

	public static Rect MakePixelPerfect(Rect rect)
	{
		rect.xMin = Mathf.RoundToInt(rect.xMin);
		rect.yMin = Mathf.RoundToInt(rect.yMin);
		rect.xMax = Mathf.RoundToInt(rect.xMax);
		rect.yMax = Mathf.RoundToInt(rect.yMax);
		return rect;
	}

	public static Rect MakePixelPerfect(Rect rect, int width, int height)
	{
		rect = ConvertToPixels(rect, width, height, round: true);
		rect.xMin = Mathf.RoundToInt(rect.xMin);
		rect.yMin = Mathf.RoundToInt(rect.yMin);
		rect.xMax = Mathf.RoundToInt(rect.xMax);
		rect.yMax = Mathf.RoundToInt(rect.yMax);
		return ConvertToTexCoords(rect, width, height);
	}

	public static Vector2 ConstrainRect(Vector2 minRect, Vector2 maxRect, Vector2 minArea, Vector2 maxArea)
	{
		Vector2 zero = Vector2.zero;
		float num = maxRect.x - minRect.x;
		float num2 = maxRect.y - minRect.y;
		float num3 = maxArea.x - minArea.x;
		float num4 = maxArea.y - minArea.y;
		if (num > num3)
		{
			float num5 = num - num3;
			minArea.x -= num5;
			maxArea.x += num5;
		}
		if (num2 > num4)
		{
			float num6 = num2 - num4;
			minArea.y -= num6;
			maxArea.y += num6;
		}
		if (minRect.x < minArea.x)
		{
			zero.x += minArea.x - minRect.x;
		}
		if (maxRect.x > maxArea.x)
		{
			zero.x -= maxRect.x - maxArea.x;
		}
		if (minRect.y < minArea.y)
		{
			zero.y += minArea.y - minRect.y;
		}
		if (maxRect.y > maxArea.y)
		{
			zero.y -= maxRect.y - maxArea.y;
		}
		return zero;
	}

	public static Bounds CalculateAbsoluteWidgetBounds(Transform trans)
	{
		if (trans != null)
		{
			UIWidget[] componentsInChildren = trans.GetComponentsInChildren<UIWidget>();
			if (componentsInChildren.Length == 0)
			{
				return new Bounds(trans.position, Vector3.zero);
			}
			Vector3 center = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
			Vector3 point = new Vector3(float.MinValue, float.MinValue, float.MinValue);
			int i = 0;
			for (int num = componentsInChildren.Length; i < num; i++)
			{
				UIWidget uIWidget = componentsInChildren[i];
				if (!uIWidget.enabled)
				{
					continue;
				}
				Vector3[] worldCorners = uIWidget.worldCorners;
				for (int j = 0; j < 4; j++)
				{
					Vector3 vector = worldCorners[j];
					if (vector.x > point.x)
					{
						point.x = vector.x;
					}
					if (vector.y > point.y)
					{
						point.y = vector.y;
					}
					if (vector.z > point.z)
					{
						point.z = vector.z;
					}
					if (vector.x < center.x)
					{
						center.x = vector.x;
					}
					if (vector.y < center.y)
					{
						center.y = vector.y;
					}
					if (vector.z < center.z)
					{
						center.z = vector.z;
					}
				}
			}
			Bounds result = new Bounds(center, Vector3.zero);
			result.Encapsulate(point);
			return result;
		}
		return new Bounds(Vector3.zero, Vector3.zero);
	}

	public static Bounds CalculateRelativeWidgetBounds(Transform trans)
	{
		return CalculateRelativeWidgetBounds(trans, trans, considerInactive: false);
	}

	public static Bounds CalculateRelativeWidgetBounds(Transform trans, bool considerInactive)
	{
		return CalculateRelativeWidgetBounds(trans, trans, considerInactive);
	}

	public static Bounds CalculateRelativeWidgetBounds(Transform relativeTo, Transform content)
	{
		return CalculateRelativeWidgetBounds(relativeTo, content, considerInactive: false);
	}

	public static Bounds CalculateRelativeWidgetBounds(Transform relativeTo, Transform content, bool considerInactive)
	{
		if (content != null && relativeTo != null)
		{
			bool isSet = false;
			Matrix4x4 toLocal = relativeTo.worldToLocalMatrix;
			Vector3 vMin = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
			Vector3 vMax = new Vector3(float.MinValue, float.MinValue, float.MinValue);
			CalculateRelativeWidgetBounds(content, considerInactive, isRoot: true, ref toLocal, ref vMin, ref vMax, ref isSet);
			if (isSet)
			{
				Bounds result = new Bounds(vMin, Vector3.zero);
				result.Encapsulate(vMax);
				return result;
			}
		}
		return new Bounds(Vector3.zero, Vector3.zero);
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	private static void CalculateRelativeWidgetBounds(Transform content, bool considerInactive, bool isRoot, ref Matrix4x4 toLocal, ref Vector3 vMin, ref Vector3 vMax, ref bool isSet)
	{
		if (content == null || (!considerInactive && !NGUITools.GetActive(content.gameObject)))
		{
			return;
		}
		UIPanel uIPanel = ((!isRoot) ? content.GetComponent<UIPanel>() : null);
		if (uIPanel != null && !uIPanel.enabled)
		{
			return;
		}
		if (uIPanel != null && uIPanel.clipping != 0)
		{
			Vector3[] worldCorners = uIPanel.worldCorners;
			for (int i = 0; i < 4; i++)
			{
				Vector3 vector = toLocal.MultiplyPoint3x4(worldCorners[i]);
				if (vector.x > vMax.x)
				{
					vMax.x = vector.x;
				}
				if (vector.y > vMax.y)
				{
					vMax.y = vector.y;
				}
				if (vector.z > vMax.z)
				{
					vMax.z = vector.z;
				}
				if (vector.x < vMin.x)
				{
					vMin.x = vector.x;
				}
				if (vector.y < vMin.y)
				{
					vMin.y = vector.y;
				}
				if (vector.z < vMin.z)
				{
					vMin.z = vector.z;
				}
				isSet = true;
			}
			return;
		}
		UIWidget component = content.GetComponent<UIWidget>();
		if (component != null && component.enabled)
		{
			Vector3[] worldCorners2 = component.worldCorners;
			for (int j = 0; j < 4; j++)
			{
				Vector3 vector2 = toLocal.MultiplyPoint3x4(worldCorners2[j]);
				if (vector2.x > vMax.x)
				{
					vMax.x = vector2.x;
				}
				if (vector2.y > vMax.y)
				{
					vMax.y = vector2.y;
				}
				if (vector2.z > vMax.z)
				{
					vMax.z = vector2.z;
				}
				if (vector2.x < vMin.x)
				{
					vMin.x = vector2.x;
				}
				if (vector2.y < vMin.y)
				{
					vMin.y = vector2.y;
				}
				if (vector2.z < vMin.z)
				{
					vMin.z = vector2.z;
				}
				isSet = true;
			}
		}
		int k = 0;
		for (int childCount = content.childCount; k < childCount; k++)
		{
			CalculateRelativeWidgetBounds(content.GetChild(k), considerInactive, isRoot: false, ref toLocal, ref vMin, ref vMax, ref isSet);
		}
	}

	public static Vector3 SpringDampen(ref Vector3 velocity, float strength, float deltaTime)
	{
		if (deltaTime > 1f)
		{
			deltaTime = 1f;
		}
		float f = 1f - strength * 0.001f;
		int num = Mathf.RoundToInt(deltaTime * 1000f);
		float num2 = Mathf.Pow(f, num);
		Vector3 vector = velocity * ((num2 - 1f) / Mathf.Log(f));
		velocity *= num2;
		return vector * 0.06f;
	}

	public static Vector2 SpringDampen(ref Vector2 velocity, float strength, float deltaTime)
	{
		if (deltaTime > 1f)
		{
			deltaTime = 1f;
		}
		float f = 1f - strength * 0.001f;
		int num = Mathf.RoundToInt(deltaTime * 1000f);
		float num2 = Mathf.Pow(f, num);
		Vector2 vector = velocity * ((num2 - 1f) / Mathf.Log(f));
		velocity *= num2;
		return vector * 0.06f;
	}

	public static float SpringLerp(float strength, float deltaTime)
	{
		if (deltaTime > 1f)
		{
			deltaTime = 1f;
		}
		int num = Mathf.RoundToInt(deltaTime * 1000f);
		deltaTime = 0.001f * strength;
		float num2 = 0f;
		for (int i = 0; i < num; i++)
		{
			num2 = Mathf.Lerp(num2, 1f, deltaTime);
		}
		return num2;
	}

	public static float SpringLerp(float from, float to, float strength, float deltaTime)
	{
		if (deltaTime > 1f)
		{
			deltaTime = 1f;
		}
		int num = Mathf.RoundToInt(deltaTime * 1000f);
		deltaTime = 0.001f * strength;
		for (int i = 0; i < num; i++)
		{
			from = Mathf.Lerp(from, to, deltaTime);
		}
		return from;
	}

	public static Vector2 SpringLerp(Vector2 from, Vector2 to, float strength, float deltaTime)
	{
		return Vector2.Lerp(from, to, SpringLerp(strength, deltaTime));
	}

	public static Vector3 SpringLerp(Vector3 from, Vector3 to, float strength, float deltaTime)
	{
		return Vector3.Lerp(from, to, SpringLerp(strength, deltaTime));
	}

	public static Quaternion SpringLerp(Quaternion from, Quaternion to, float strength, float deltaTime)
	{
		return Quaternion.Slerp(from, to, SpringLerp(strength, deltaTime));
	}

	public static float RotateTowards(float from, float to, float maxAngle)
	{
		float num = WrapAngle(to - from);
		if (Mathf.Abs(num) > maxAngle)
		{
			num = maxAngle * Mathf.Sign(num);
		}
		return from + num;
	}

	private static float DistancePointToLineSegment(Vector2 point, Vector2 a, Vector2 b)
	{
		float sqrMagnitude = (b - a).sqrMagnitude;
		if (sqrMagnitude == 0f)
		{
			return (point - a).magnitude;
		}
		float num = Vector2.Dot(point - a, b - a) / sqrMagnitude;
		if (num < 0f)
		{
			return (point - a).magnitude;
		}
		if (num > 1f)
		{
			return (point - b).magnitude;
		}
		Vector2 vector = a + num * (b - a);
		return (point - vector).magnitude;
	}

	public static float DistanceToRectangle(Vector2[] screenPoints, Vector2 mousePos)
	{
		bool flag = false;
		int val = 4;
		for (int i = 0; i < 5; i++)
		{
			Vector3 vector = screenPoints[RepeatIndex(i, 4)];
			Vector3 vector2 = screenPoints[RepeatIndex(val, 4)];
			if (vector.y > mousePos.y != vector2.y > mousePos.y && mousePos.x < (vector2.x - vector.x) * (mousePos.y - vector.y) / (vector2.y - vector.y) + vector.x)
			{
				flag = !flag;
			}
			val = i;
		}
		if (!flag)
		{
			float num = -1f;
			for (int j = 0; j < 4; j++)
			{
				Vector3 vector3 = screenPoints[j];
				Vector3 vector4 = screenPoints[RepeatIndex(j + 1, 4)];
				float num2 = DistancePointToLineSegment(mousePos, vector3, vector4);
				if (num2 < num || num < 0f)
				{
					num = num2;
				}
			}
			return num;
		}
		return 0f;
	}

	public static float DistanceToRectangle(Vector3[] worldPoints, Vector2 mousePos, Camera cam)
	{
		Vector2[] array = new Vector2[4];
		for (int i = 0; i < 4; i++)
		{
			ref Vector2 reference = ref array[i];
			reference = cam.WorldToScreenPoint(worldPoints[i]);
		}
		return DistanceToRectangle(array, mousePos);
	}

	public static Vector2 GetPivotOffset(UIWidget.Pivot pv)
	{
		Vector2 zero = Vector2.zero;
		switch (pv)
		{
		case UIWidget.Pivot.Top:
		case UIWidget.Pivot.Center:
		case UIWidget.Pivot.Bottom:
			zero.x = 0.5f;
			break;
		case UIWidget.Pivot.TopRight:
		case UIWidget.Pivot.Right:
		case UIWidget.Pivot.BottomRight:
			zero.x = 1f;
			break;
		default:
			zero.x = 0f;
			break;
		}
		switch (pv)
		{
		case UIWidget.Pivot.Left:
		case UIWidget.Pivot.Center:
		case UIWidget.Pivot.Right:
			zero.y = 0.5f;
			break;
		case UIWidget.Pivot.TopLeft:
		case UIWidget.Pivot.Top:
		case UIWidget.Pivot.TopRight:
			zero.y = 1f;
			break;
		default:
			zero.y = 0f;
			break;
		}
		return zero;
	}

	public static UIWidget.Pivot GetPivot(Vector2 offset)
	{
		if (offset.x == 0f)
		{
			if (offset.y == 0f)
			{
				return UIWidget.Pivot.BottomLeft;
			}
			if (offset.y == 1f)
			{
				return UIWidget.Pivot.TopLeft;
			}
			return UIWidget.Pivot.Left;
		}
		if (offset.x == 1f)
		{
			if (offset.y == 0f)
			{
				return UIWidget.Pivot.BottomRight;
			}
			if (offset.y == 1f)
			{
				return UIWidget.Pivot.TopRight;
			}
			return UIWidget.Pivot.Right;
		}
		if (offset.y == 0f)
		{
			return UIWidget.Pivot.Bottom;
		}
		if (offset.y == 1f)
		{
			return UIWidget.Pivot.Top;
		}
		return UIWidget.Pivot.Center;
	}

	public static void MoveWidget(UIRect w, float x, float y)
	{
		MoveRect(w, x, y);
	}

	public static void MoveRect(UIRect rect, float x, float y)
	{
		int num = Mathf.FloorToInt(x + 0.5f);
		int num2 = Mathf.FloorToInt(y + 0.5f);
		rect.cachedTransform.localPosition += new Vector3(num, num2);
		int num3 = 0;
		if ((bool)rect.leftAnchor.target)
		{
			num3++;
			rect.leftAnchor.absolute += num;
		}
		if ((bool)rect.rightAnchor.target)
		{
			num3++;
			rect.rightAnchor.absolute += num;
		}
		if ((bool)rect.bottomAnchor.target)
		{
			num3++;
			rect.bottomAnchor.absolute += num2;
		}
		if ((bool)rect.topAnchor.target)
		{
			num3++;
			rect.topAnchor.absolute += num2;
		}
		if (num3 != 0)
		{
			rect.UpdateAnchors();
		}
	}

	public static void ResizeWidget(UIWidget w, UIWidget.Pivot pivot, float x, float y, int minWidth, int minHeight)
	{
		ResizeWidget(w, pivot, x, y, 2, 2, 100000, 100000);
	}

	public static void ResizeWidget(UIWidget w, UIWidget.Pivot pivot, float x, float y, int minWidth, int minHeight, int maxWidth, int maxHeight)
	{
		if (pivot == UIWidget.Pivot.Center)
		{
			int num = Mathf.RoundToInt(x - (float)w.width);
			int num2 = Mathf.RoundToInt(y - (float)w.height);
			num -= num & 1;
			num2 -= num2 & 1;
			if ((num | num2) != 0)
			{
				num >>= 1;
				num2 >>= 1;
				AdjustWidget(w, -num, -num2, num, num2, minWidth, minHeight);
			}
			return;
		}
		Vector3 vector = new Vector3(x, y);
		vector = Quaternion.Inverse(w.cachedTransform.localRotation) * vector;
		switch (pivot)
		{
		case UIWidget.Pivot.BottomLeft:
			AdjustWidget(w, vector.x, vector.y, 0f, 0f, minWidth, minHeight, maxWidth, maxHeight);
			break;
		case UIWidget.Pivot.Left:
			AdjustWidget(w, vector.x, 0f, 0f, 0f, minWidth, minHeight, maxWidth, maxHeight);
			break;
		case UIWidget.Pivot.TopLeft:
			AdjustWidget(w, vector.x, 0f, 0f, vector.y, minWidth, minHeight, maxWidth, maxHeight);
			break;
		case UIWidget.Pivot.Top:
			AdjustWidget(w, 0f, 0f, 0f, vector.y, minWidth, minHeight, maxWidth, maxHeight);
			break;
		case UIWidget.Pivot.TopRight:
			AdjustWidget(w, 0f, 0f, vector.x, vector.y, minWidth, minHeight, maxWidth, maxHeight);
			break;
		case UIWidget.Pivot.Right:
			AdjustWidget(w, 0f, 0f, vector.x, 0f, minWidth, minHeight, maxWidth, maxHeight);
			break;
		case UIWidget.Pivot.BottomRight:
			AdjustWidget(w, 0f, vector.y, vector.x, 0f, minWidth, minHeight, maxWidth, maxHeight);
			break;
		case UIWidget.Pivot.Bottom:
			AdjustWidget(w, 0f, vector.y, 0f, 0f, minWidth, minHeight, maxWidth, maxHeight);
			break;
		case UIWidget.Pivot.Center:
			break;
		}
	}

	public static void AdjustWidget(UIWidget w, float left, float bottom, float right, float top)
	{
		AdjustWidget(w, left, bottom, right, top, 2, 2, 100000, 100000);
	}

	public static void AdjustWidget(UIWidget w, float left, float bottom, float right, float top, int minWidth, int minHeight)
	{
		AdjustWidget(w, left, bottom, right, top, minWidth, minHeight, 100000, 100000);
	}

	public static void AdjustWidget(UIWidget w, float left, float bottom, float right, float top, int minWidth, int minHeight, int maxWidth, int maxHeight)
	{
		Vector2 pivotOffset = w.pivotOffset;
		Transform cachedTransform = w.cachedTransform;
		Quaternion localRotation = cachedTransform.localRotation;
		int num = Mathf.FloorToInt(left + 0.5f);
		int num2 = Mathf.FloorToInt(bottom + 0.5f);
		int num3 = Mathf.FloorToInt(right + 0.5f);
		int num4 = Mathf.FloorToInt(top + 0.5f);
		if (pivotOffset.x == 0.5f && (num == 0 || num3 == 0))
		{
			num = num >> 1 << 1;
			num3 = num3 >> 1 << 1;
		}
		if (pivotOffset.y == 0.5f && (num2 == 0 || num4 == 0))
		{
			num2 = num2 >> 1 << 1;
			num4 = num4 >> 1 << 1;
		}
		Vector3 vector = localRotation * new Vector3(num, num4);
		Vector3 vector2 = localRotation * new Vector3(num3, num4);
		Vector3 vector3 = localRotation * new Vector3(num, num2);
		Vector3 vector4 = localRotation * new Vector3(num3, num2);
		Vector3 vector5 = localRotation * new Vector3(num, 0f);
		Vector3 vector6 = localRotation * new Vector3(num3, 0f);
		Vector3 vector7 = localRotation * new Vector3(0f, num4);
		Vector3 vector8 = localRotation * new Vector3(0f, num2);
		Vector3 zero = Vector3.zero;
		if (pivotOffset.x == 0f && pivotOffset.y == 1f)
		{
			zero.x = vector.x;
			zero.y = vector.y;
		}
		else if (pivotOffset.x == 1f && pivotOffset.y == 0f)
		{
			zero.x = vector4.x;
			zero.y = vector4.y;
		}
		else if (pivotOffset.x == 0f && pivotOffset.y == 0f)
		{
			zero.x = vector3.x;
			zero.y = vector3.y;
		}
		else if (pivotOffset.x == 1f && pivotOffset.y == 1f)
		{
			zero.x = vector2.x;
			zero.y = vector2.y;
		}
		else if (pivotOffset.x == 0f && pivotOffset.y == 0.5f)
		{
			zero.x = vector5.x + (vector7.x + vector8.x) * 0.5f;
			zero.y = vector5.y + (vector7.y + vector8.y) * 0.5f;
		}
		else if (pivotOffset.x == 1f && pivotOffset.y == 0.5f)
		{
			zero.x = vector6.x + (vector7.x + vector8.x) * 0.5f;
			zero.y = vector6.y + (vector7.y + vector8.y) * 0.5f;
		}
		else if (pivotOffset.x == 0.5f && pivotOffset.y == 1f)
		{
			zero.x = vector7.x + (vector5.x + vector6.x) * 0.5f;
			zero.y = vector7.y + (vector5.y + vector6.y) * 0.5f;
		}
		else if (pivotOffset.x == 0.5f && pivotOffset.y == 0f)
		{
			zero.x = vector8.x + (vector5.x + vector6.x) * 0.5f;
			zero.y = vector8.y + (vector5.y + vector6.y) * 0.5f;
		}
		else if (pivotOffset.x == 0.5f && pivotOffset.y == 0.5f)
		{
			zero.x = (vector5.x + vector6.x + vector7.x + vector8.x) * 0.5f;
			zero.y = (vector7.y + vector8.y + vector5.y + vector6.y) * 0.5f;
		}
		minWidth = Mathf.Max(minWidth, w.minWidth);
		minHeight = Mathf.Max(minHeight, w.minHeight);
		int num5 = w.width + num3 - num;
		int num6 = w.height + num4 - num2;
		Vector3 zero2 = Vector3.zero;
		int num7 = num5;
		if (num5 < minWidth)
		{
			num7 = minWidth;
		}
		else if (num5 > maxWidth)
		{
			num7 = maxWidth;
		}
		if (num5 != num7)
		{
			if (num != 0)
			{
				zero2.x -= Mathf.Lerp(num7 - num5, 0f, pivotOffset.x);
			}
			else
			{
				zero2.x += Mathf.Lerp(0f, num7 - num5, pivotOffset.x);
			}
			num5 = num7;
		}
		int num8 = num6;
		if (num6 < minHeight)
		{
			num8 = minHeight;
		}
		else if (num6 > maxHeight)
		{
			num8 = maxHeight;
		}
		if (num6 != num8)
		{
			if (num2 != 0)
			{
				zero2.y -= Mathf.Lerp(num8 - num6, 0f, pivotOffset.y);
			}
			else
			{
				zero2.y += Mathf.Lerp(0f, num8 - num6, pivotOffset.y);
			}
			num6 = num8;
		}
		if (pivotOffset.x == 0.5f)
		{
			num5 = num5 >> 1 << 1;
		}
		if (pivotOffset.y == 0.5f)
		{
			num6 = num6 >> 1 << 1;
		}
		Vector3 vector10 = (cachedTransform.localPosition = cachedTransform.localPosition + zero + localRotation * zero2);
		w.SetDimensions(num5, num6);
		if (w.isAnchored)
		{
			cachedTransform = cachedTransform.parent;
			float num9 = vector10.x - pivotOffset.x * (float)num5;
			float num10 = vector10.y - pivotOffset.y * (float)num6;
			if ((bool)w.leftAnchor.target)
			{
				w.leftAnchor.SetHorizontal(cachedTransform, num9);
			}
			if ((bool)w.rightAnchor.target)
			{
				w.rightAnchor.SetHorizontal(cachedTransform, num9 + (float)num5);
			}
			if ((bool)w.bottomAnchor.target)
			{
				w.bottomAnchor.SetVertical(cachedTransform, num10);
			}
			if ((bool)w.topAnchor.target)
			{
				w.topAnchor.SetVertical(cachedTransform, num10 + (float)num6);
			}
		}
	}

	public static int AdjustByDPI(float height)
	{
		float num = Screen.dpi;
		RuntimePlatform platform = Application.platform;
		if (num == 0f)
		{
			num = ((platform != RuntimePlatform.Android && platform != RuntimePlatform.IPhonePlayer) ? 96f : 160f);
		}
		int num2 = Mathf.RoundToInt(height * (96f / num));
		if ((num2 & 1) == 1)
		{
			num2++;
		}
		return num2;
	}

	public static Vector2 ScreenToPixels(Vector2 pos, Transform relativeTo)
	{
		int layer = relativeTo.gameObject.layer;
		Camera camera = NGUITools.FindCameraForLayer(layer);
		if (camera == null)
		{
			UnityEngine.Debug.LogWarning("No camera found for layer " + layer);
			return pos;
		}
		Vector3 position = camera.ScreenToWorldPoint(pos);
		return relativeTo.InverseTransformPoint(position);
	}

	public static Vector2 ScreenToParentPixels(Vector2 pos, Transform relativeTo)
	{
		int layer = relativeTo.gameObject.layer;
		if (relativeTo.parent != null)
		{
			relativeTo = relativeTo.parent;
		}
		Camera camera = NGUITools.FindCameraForLayer(layer);
		if (camera == null)
		{
			UnityEngine.Debug.LogWarning("No camera found for layer " + layer);
			return pos;
		}
		Vector3 vector = camera.ScreenToWorldPoint(pos);
		return (!(relativeTo != null)) ? vector : relativeTo.InverseTransformPoint(vector);
	}

	public static Vector3 WorldToLocalPoint(Vector3 worldPos, Camera worldCam, Camera uiCam, Transform relativeTo)
	{
		worldPos = worldCam.WorldToViewportPoint(worldPos);
		worldPos = uiCam.ViewportToWorldPoint(worldPos);
		if (relativeTo == null)
		{
			return worldPos;
		}
		relativeTo = relativeTo.parent;
		if (relativeTo == null)
		{
			return worldPos;
		}
		return relativeTo.InverseTransformPoint(worldPos);
	}

	public static void OverlayPosition(this Transform trans, Vector3 worldPos, Camera worldCam, Camera myCam)
	{
		worldPos = worldCam.WorldToViewportPoint(worldPos);
		worldPos = myCam.ViewportToWorldPoint(worldPos);
		Transform parent = trans.parent;
		trans.localPosition = ((!(parent != null)) ? worldPos : parent.InverseTransformPoint(worldPos));
	}

	public static void OverlayPosition(this Transform trans, Vector3 worldPos, Camera worldCam)
	{
		Camera camera = NGUITools.FindCameraForLayer(trans.gameObject.layer);
		if (camera != null)
		{
			trans.OverlayPosition(worldPos, worldCam, camera);
		}
	}

	public static void OverlayPosition(this Transform trans, Transform target)
	{
		Camera camera = NGUITools.FindCameraForLayer(trans.gameObject.layer);
		Camera camera2 = NGUITools.FindCameraForLayer(target.gameObject.layer);
		if (camera != null && camera2 != null)
		{
			trans.OverlayPosition(target.position, camera2, camera);
		}
	}
}
public static class NGUIText
{
	public enum Alignment
	{
		Automatic,
		Left,
		Center,
		Right,
		Justified
	}

	public enum SymbolStyle
	{
		None,
		Normal,
		Colored
	}

	public class GlyphInfo
	{
		public Vector2 v0;

		public Vector2 v1;

		public Vector2 u0;

		public Vector2 u1;

		public float advance;

		public int channel;

		public bool rotatedUVs;
	}

	public static UIFont bitmapFont;

	public static UnityEngine.Font dynamicFont;

	public static GlyphInfo glyph = new GlyphInfo();

	public static int fontSize = 16;

	public static float fontScale = 1f;

	public static float pixelDensity = 1f;

	public static UnityEngine.FontStyle fontStyle = UnityEngine.FontStyle.Normal;

	public static Alignment alignment = Alignment.Left;

	public static UnityEngine.Color tint = UnityEngine.Color.white;

	public static int rectWidth = 1000000;

	public static int rectHeight = 1000000;

	public static int regionWidth = 1000000;

	public static int regionHeight = 1000000;

	public static int maxLines = 0;

	public static bool gradient = false;

	public static UnityEngine.Color gradientBottom = UnityEngine.Color.white;

	public static UnityEngine.Color gradientTop = UnityEngine.Color.white;

	public static bool encoding = false;

	public static float spacingX = 0f;

	public static float spacingY = 0f;

	public static bool premultiply = false;

	public static SymbolStyle symbolStyle;

	public static int finalSize = 0;

	public static float finalSpacingX = 0f;

	public static float finalLineHeight = 0f;

	public static float baseline = 0f;

	public static bool useSymbols = false;

	private static UnityEngine.Color mInvisible = new UnityEngine.Color(0f, 0f, 0f, 0f);

	private static BetterList<UnityEngine.Color> mColors = new BetterList<UnityEngine.Color>();

	private static float mAlpha = 1f;

	private static CharacterInfo mTempChar;

	private static BetterList<float> mSizes = new BetterList<float>();

	private static Color32 s_c0;

	private static Color32 s_c1;

	private static float[] mBoldOffset = new float[8] { -0.25f, 0f, 0.25f, 0f, 0f, -0.25f, 0f, 0.25f };

	public static void Update()
	{
		Update(request: true);
	}

	public static void Update(bool request)
	{
		finalSize = Mathf.RoundToInt((float)fontSize / pixelDensity);
		finalSpacingX = spacingX * fontScale;
		finalLineHeight = ((float)fontSize + spacingY) * fontScale;
		useSymbols = bitmapFont != null && bitmapFont.hasSymbols && encoding && symbolStyle != SymbolStyle.None;
		if (!(dynamicFont != null) || !request)
		{
			return;
		}
		dynamicFont.RequestCharactersInTexture(")_-", finalSize, fontStyle);
		if (!dynamicFont.GetCharacterInfo(')', out mTempChar, finalSize, fontStyle) || mTempChar.vert.height == 0f)
		{
			dynamicFont.RequestCharactersInTexture("A", finalSize, fontStyle);
			if (!dynamicFont.GetCharacterInfo('A', out mTempChar, finalSize, fontStyle))
			{
				baseline = 0f;
				return;
			}
		}
		float yMax = mTempChar.vert.yMax;
		float yMin = mTempChar.vert.yMin;
		baseline = Mathf.Round(yMax + ((float)finalSize - yMax + yMin) * 0.5f);
	}

	public static void Prepare(string text)
	{
		if (dynamicFont != null)
		{
			dynamicFont.RequestCharactersInTexture(text, finalSize, fontStyle);
		}
	}

	public static BMSymbol GetSymbol(string text, int index, int textLength)
	{
		return (!(bitmapFont != null)) ? null : bitmapFont.MatchSymbol(text, index, textLength);
	}

	public static float GetGlyphWidth(int ch, int prev)
	{
		if (bitmapFont != null)
		{
			bool flag = false;
			if (ch == 8201)
			{
				flag = true;
				ch = 32;
			}
			BMGlyph bMGlyph = bitmapFont.bmFont.GetGlyph(ch);
			if (bMGlyph != null)
			{
				int num = bMGlyph.advance;
				if (flag)
				{
					num >>= 1;
				}
				return fontScale * (float)((prev == 0) ? bMGlyph.advance : (num + bMGlyph.GetKerning(prev)));
			}
		}
		else if (dynamicFont != null && dynamicFont.GetCharacterInfo((char)ch, out mTempChar, finalSize, fontStyle))
		{
			return mTempChar.width * fontScale * pixelDensity;
		}
		return 0f;
	}

	public static GlyphInfo GetGlyph(int ch, int prev)
	{
		if (bitmapFont != null)
		{
			bool flag = false;
			if (ch == 8201)
			{
				flag = true;
				ch = 32;
			}
			BMGlyph bMGlyph = bitmapFont.bmFont.GetGlyph(ch);
			if (bMGlyph != null)
			{
				int num = ((prev != 0) ? bMGlyph.GetKerning(prev) : 0);
				glyph.v0.x = ((prev == 0) ? bMGlyph.offsetX : (bMGlyph.offsetX + num));
				glyph.v1.y = -bMGlyph.offsetY;
				glyph.v1.x = glyph.v0.x + (float)bMGlyph.width;
				glyph.v0.y = glyph.v1.y - (float)bMGlyph.height;
				glyph.u0.x = bMGlyph.x;
				glyph.u0.y = bMGlyph.y + bMGlyph.height;
				glyph.u1.x = bMGlyph.x + bMGlyph.width;
				glyph.u1.y = bMGlyph.y;
				int num2 = bMGlyph.advance;
				if (flag)
				{
					num2 >>= 1;
				}
				glyph.advance = num2 + num;
				glyph.channel = bMGlyph.channel;
				glyph.rotatedUVs = false;
				if (fontScale != 1f)
				{
					glyph.v0 *= fontScale;
					glyph.v1 *= fontScale;
					glyph.advance *= fontScale;
				}
				return glyph;
			}
		}
		else if (dynamicFont != null && dynamicFont.GetCharacterInfo((char)ch, out mTempChar, finalSize, fontStyle))
		{
			glyph.v0.x = mTempChar.vert.xMin;
			glyph.v1.x = glyph.v0.x + mTempChar.vert.width;
			glyph.v0.y = mTempChar.vert.yMax - baseline;
			glyph.v1.y = glyph.v0.y - mTempChar.vert.height;
			glyph.u0.x = mTempChar.uv.xMin;
			glyph.u0.y = mTempChar.uv.yMin;
			glyph.u1.x = mTempChar.uv.xMax;
			glyph.u1.y = mTempChar.uv.yMax;
			glyph.advance = mTempChar.width;
			glyph.channel = 0;
			glyph.rotatedUVs = mTempChar.flipped;
			glyph.v0.x = Mathf.Round(glyph.v0.x);
			glyph.v0.y = Mathf.Round(glyph.v0.y);
			glyph.v1.x = Mathf.Round(glyph.v1.x);
			glyph.v1.y = Mathf.Round(glyph.v1.y);
			float num3 = fontScale * pixelDensity;
			if (num3 != 1f)
			{
				glyph.v0 *= num3;
				glyph.v1 *= num3;
				glyph.advance *= num3;
			}
			return glyph;
		}
		return null;
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static float ParseAlpha(string text, int index)
	{
		int num = (NGUIMath.HexToDecimal(text[index + 1]) << 4) | NGUIMath.HexToDecimal(text[index + 2]);
		return Mathf.Clamp01((float)num / 255f);
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static UnityEngine.Color ParseColor(string text, int offset)
	{
		return ParseColor24(text, offset);
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static UnityEngine.Color ParseColor24(string text, int offset)
	{
		int num = (NGUIMath.HexToDecimal(text[offset]) << 4) | NGUIMath.HexToDecimal(text[offset + 1]);
		int num2 = (NGUIMath.HexToDecimal(text[offset + 2]) << 4) | NGUIMath.HexToDecimal(text[offset + 3]);
		int num3 = (NGUIMath.HexToDecimal(text[offset + 4]) << 4) | NGUIMath.HexToDecimal(text[offset + 5]);
		float num4 = 0.003921569f;
		return new UnityEngine.Color(num4 * (float)num, num4 * (float)num2, num4 * (float)num3);
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static UnityEngine.Color ParseColor32(string text, int offset)
	{
		int num = (NGUIMath.HexToDecimal(text[offset]) << 4) | NGUIMath.HexToDecimal(text[offset + 1]);
		int num2 = (NGUIMath.HexToDecimal(text[offset + 2]) << 4) | NGUIMath.HexToDecimal(text[offset + 3]);
		int num3 = (NGUIMath.HexToDecimal(text[offset + 4]) << 4) | NGUIMath.HexToDecimal(text[offset + 5]);
		int num4 = (NGUIMath.HexToDecimal(text[offset + 6]) << 4) | NGUIMath.HexToDecimal(text[offset + 7]);
		float num5 = 0.003921569f;
		return new UnityEngine.Color(num5 * (float)num, num5 * (float)num2, num5 * (float)num3, num5 * (float)num4);
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static string EncodeColor(UnityEngine.Color c)
	{
		return EncodeColor24(c);
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static string EncodeAlpha(float a)
	{
		int num = Mathf.Clamp(Mathf.RoundToInt(a * 255f), 0, 255);
		return NGUIMath.DecimalToHex8(num);
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static string EncodeColor24(UnityEngine.Color c)
	{
		int num = 0xFFFFFF & (NGUIMath.ColorToInt(c) >> 8);
		return NGUIMath.DecimalToHex24(num);
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static string EncodeColor32(UnityEngine.Color c)
	{
		int num = NGUIMath.ColorToInt(c);
		return NGUIMath.DecimalToHex32(num);
	}

	public static bool ParseSymbol(string text, ref int index)
	{
		int sub = 1;
		bool bold = false;
		bool italic = false;
		bool underline = false;
		bool strike = false;
		bool ignoreColor = false;
		return ParseSymbol(text, ref index, null, premultiply: false, ref sub, ref bold, ref italic, ref underline, ref strike, ref ignoreColor);
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static bool IsHex(char ch)
	{
		return (ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F');
	}

	public static bool ParseSymbol(string text, ref int index, BetterList<UnityEngine.Color> colors, bool premultiply, ref int sub, ref bool bold, ref bool italic, ref bool underline, ref bool strike, ref bool ignoreColor)
	{
		int length = text.Length;
		if (index + 3 > length || text[index] != '[')
		{
			return false;
		}
		if (text[index + 2] == ']')
		{
			if (text[index + 1] == '-')
			{
				if (colors != null && colors.size > 1)
				{
					colors.RemoveAt(colors.size - 1);
				}
				index += 3;
				return true;
			}
			switch (text.Substring(index, 3))
			{
			case "[b]":
				bold = true;
				index += 3;
				return true;
			case "[i]":
				italic = true;
				index += 3;
				return true;
			case "[u]":
				underline = true;
				index += 3;
				return true;
			case "[s]":
				strike = true;
				index += 3;
				return true;
			case "[c]":
				ignoreColor = true;
				index += 3;
				return true;
			}
		}
		if (index + 4 > length)
		{
			return false;
		}
		if (text[index + 3] == ']')
		{
			switch (text.Substring(index, 4))
			{
			case "[/b]":
				bold = false;
				index += 4;
				return true;
			case "[/i]":
				italic = false;
				index += 4;
				return true;
			case "[/u]":
				underline = false;
				index += 4;
				return true;
			case "[/s]":
				strike = false;
				index += 4;
				return true;
			case "[/c]":
				ignoreColor = false;
				index += 4;
				return true;
			}
			char ch = text[index + 1];
			char ch2 = text[index + 2];
			if (IsHex(ch) && IsHex(ch2))
			{
				int num = (NGUIMath.HexToDecimal(ch) << 4) | NGUIMath.HexToDecimal(ch2);
				mAlpha = (float)num / 255f;
				index += 4;
				return true;
			}
		}
		if (index + 5 > length)
		{
			return false;
		}
		if (text[index + 4] == ']')
		{
			switch (text.Substring(index, 5))
			{
			case "[sub]":
				sub = 1;
				index += 5;
				return true;
			case "[sup]":
				sub = 2;
				index += 5;
				return true;
			}
		}
		if (index + 6 > length)
		{
			return false;
		}
		if (text[index + 5] == ']')
		{
			switch (text.Substring(index, 6))
			{
			case "[/sub]":
				sub = 0;
				index += 6;
				return true;
			case "[/sup]":
				sub = 0;
				index += 6;
				return true;
			case "[/url]":
				index += 6;
				return true;
			}
		}
		if (text[index + 1] == 'u' && text[index + 2] == 'r' && text[index + 3] == 'l' && text[index + 4] == '=')
		{
			int num2 = text.IndexOf(']', index + 4);
			if (num2 != -1)
			{
				index = num2 + 1;
				return true;
			}
			index = text.Length;
			return true;
		}
		if (index + 8 > length)
		{
			return false;
		}
		if (text[index + 7] == ']')
		{
			UnityEngine.Color color = ParseColor24(text, index + 1);
			if (EncodeColor24(color) != text.Substring(index + 1, 6).ToUpper())
			{
				return false;
			}
			if (colors != null)
			{
				color.a = colors[colors.size - 1].a;
				if (premultiply && color.a != 1f)
				{
					color = UnityEngine.Color.Lerp(mInvisible, color, color.a);
				}
				colors.Add(color);
			}
			index += 8;
			return true;
		}
		if (index + 10 > length)
		{
			return false;
		}
		if (text[index + 9] == ']')
		{
			UnityEngine.Color color2 = ParseColor32(text, index + 1);
			if (EncodeColor32(color2) != text.Substring(index + 1, 8).ToUpper())
			{
				return false;
			}
			if (colors != null)
			{
				if (premultiply && color2.a != 1f)
				{
					color2 = UnityEngine.Color.Lerp(mInvisible, color2, color2.a);
				}
				colors.Add(color2);
			}
			index += 10;
			return true;
		}
		return false;
	}

	public static string StripSymbols(string text)
	{
		if (text != null)
		{
			int num = 0;
			int length = text.Length;
			while (num < length)
			{
				char c = text[num];
				if (c == '[')
				{
					int sub = 0;
					bool bold = false;
					bool italic = false;
					bool underline = false;
					bool strike = false;
					bool ignoreColor = false;
					int index = num;
					if (ParseSymbol(text, ref index, null, premultiply: false, ref sub, ref bold, ref italic, ref underline, ref strike, ref ignoreColor))
					{
						text = text.Remove(num, index - num);
						length = text.Length;
						continue;
					}
				}
				num++;
			}
		}
		return text;
	}

	public static void Align(BetterList<Vector3> verts, int indexOffset, float printedWidth)
	{
		switch (alignment)
		{
		case Alignment.Right:
		{
			float num13 = (float)rectWidth - printedWidth;
			if (!(num13 < 0f))
			{
				for (int j = indexOffset; j < verts.size; j++)
				{
					verts.buffer[j].x += num13;
				}
			}
			break;
		}
		case Alignment.Center:
		{
			float num10 = ((float)rectWidth - printedWidth) * 0.5f;
			if (!(num10 < 0f))
			{
				int num11 = Mathf.RoundToInt((float)rectWidth - printedWidth);
				int num12 = Mathf.RoundToInt(rectWidth);
				bool flag = (num11 & 1) == 1;
				bool flag2 = (num12 & 1) == 1;
				if ((flag && !flag2) || (!flag && flag2))
				{
					num10 += 0.5f * fontScale;
				}
				for (int i = indexOffset; i < verts.size; i++)
				{
					verts.buffer[i].x += num10;
				}
			}
			break;
		}
		case Alignment.Justified:
		{
			if (printedWidth < (float)rectWidth * 0.65f)
			{
				break;
			}
			float num = ((float)rectWidth - printedWidth) * 0.5f;
			if (num < 1f)
			{
				break;
			}
			int num2 = (verts.size - indexOffset) / 4;
			if (num2 >= 1)
			{
				float num3 = 1f / (float)(num2 - 1);
				float num4 = (float)rectWidth / printedWidth;
				int num5 = indexOffset + 4;
				int num6 = 1;
				while (num5 < verts.size)
				{
					float x = verts.buffer[num5].x;
					float x2 = verts.buffer[num5 + 2].x;
					float num7 = x2 - x;
					float num8 = x * num4;
					float a = num8 + num7;
					float num9 = x2 * num4;
					float b = num9 - num7;
					float t = (float)num6 * num3;
					x = Mathf.Lerp(num8, b, t);
					x2 = Mathf.Lerp(a, num9, t);
					x = Mathf.Round(x);
					x2 = Mathf.Round(x2);
					verts.buffer[num5++].x = x;
					verts.buffer[num5++].x = x;
					verts.buffer[num5++].x = x2;
					verts.buffer[num5++].x = x2;
					num6++;
				}
			}
			break;
		}
		}
	}

	public static int GetExactCharacterIndex(BetterList<Vector3> verts, BetterList<int> indices, Vector2 pos)
	{
		for (int i = 0; i < indices.size; i++)
		{
			int num = i << 1;
			int i2 = num + 1;
			float x = verts[num].x;
			if (pos.x < x)
			{
				continue;
			}
			float x2 = verts[i2].x;
			if (pos.x > x2)
			{
				continue;
			}
			float y = verts[num].y;
			if (!(pos.y < y))
			{
				float y2 = verts[i2].y;
				if (!(pos.y > y2))
				{
					return indices[i];
				}
			}
		}
		return 0;
	}

	public static int GetApproximateCharacterIndex(BetterList<Vector3> verts, BetterList<int> indices, Vector2 pos)
	{
		float num = float.MaxValue;
		float num2 = float.MaxValue;
		int i = 0;
		for (int j = 0; j < verts.size; j++)
		{
			float num3 = Mathf.Abs(pos.y - verts[j].y);
			if (!(num3 > num2))
			{
				float num4 = Mathf.Abs(pos.x - verts[j].x);
				if (num3 < num2)
				{
					num2 = num3;
					num = num4;
					i = j;
				}
				else if (num4 < num)
				{
					num = num4;
					i = j;
				}
			}
		}
		return indices[i];
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	private static bool IsSpace(int ch)
	{
		return ch == 32 || ch == 8202 || ch == 8203 || ch == 8201;
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static void EndLine(ref StringBuilder s)
	{
		int num = s.Length - 1;
		if (num > 0 && IsSpace(s[num]))
		{
			s[num] = '\n';
		}
		else
		{
			s.Append('\n');
		}
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	private static void ReplaceSpaceWithNewline(ref StringBuilder s)
	{
		int num = s.Length - 1;
		if (num > 0 && IsSpace(s[num]))
		{
			s[num] = '\n';
		}
	}

	public static Vector2 CalculatePrintedSize(string text)
	{
		Vector2 zero = Vector2.zero;
		if (!string.IsNullOrEmpty(text))
		{
			if (encoding)
			{
				text = StripSymbols(text);
			}
			Prepare(text);
			float num = 0f;
			float num2 = 0f;
			float num3 = 0f;
			int length = text.Length;
			int num4 = 0;
			int prev = 0;
			for (int i = 0; i < length; i++)
			{
				num4 = text[i];
				if (num4 == 10)
				{
					if (num > num3)
					{
						num3 = num;
					}
					num = 0f;
					num2 += finalLineHeight;
				}
				else
				{
					if (num4 < 32)
					{
						continue;
					}
					BMSymbol bMSymbol = ((!useSymbols) ? null : GetSymbol(text, i, length));
					if (bMSymbol == null)
					{
						float glyphWidth = GetGlyphWidth(num4, prev);
						if (glyphWidth == 0f)
						{
							continue;
						}
						glyphWidth += finalSpacingX;
						if (Mathf.RoundToInt(num + glyphWidth) > regionWidth)
						{
							if (num > num3)
							{
								num3 = num - finalSpacingX;
							}
							num = glyphWidth;
							num2 += finalLineHeight;
						}
						else
						{
							num += glyphWidth;
						}
						prev = num4;
						continue;
					}
					float num5 = finalSpacingX + (float)bMSymbol.advance * fontScale;
					if (Mathf.RoundToInt(num + num5) > regionWidth)
					{
						if (num > num3)
						{
							num3 = num - finalSpacingX;
						}
						num = num5;
						num2 += finalLineHeight;
					}
					else
					{
						num += num5;
					}
					i += bMSymbol.sequence.Length - 1;
					prev = 0;
				}
			}
			zero.x = ((!(num > num3)) ? num3 : (num - finalSpacingX));
			zero.y = num2 + finalLineHeight;
		}
		return zero;
	}

	public static int CalculateOffsetToFit(string text)
	{
		if (string.IsNullOrEmpty(text) || regionWidth < 1)
		{
			return 0;
		}
		Prepare(text);
		int length = text.Length;
		int num = 0;
		int prev = 0;
		int i = 0;
		for (int length2 = text.Length; i < length2; i++)
		{
			BMSymbol bMSymbol = ((!useSymbols) ? null : GetSymbol(text, i, length));
			if (bMSymbol == null)
			{
				num = text[i];
				float glyphWidth = GetGlyphWidth(num, prev);
				if (glyphWidth != 0f)
				{
					mSizes.Add(finalSpacingX + glyphWidth);
				}
				prev = num;
				continue;
			}
			mSizes.Add(finalSpacingX + (float)bMSymbol.advance * fontScale);
			int j = 0;
			for (int num2 = bMSymbol.sequence.Length - 1; j < num2; j++)
			{
				mSizes.Add(0f);
			}
			i += bMSymbol.sequence.Length - 1;
			prev = 0;
		}
		float num3 = regionWidth;
		int num4 = mSizes.size;
		while (num4 > 0 && num3 > 0f)
		{
			num3 -= mSizes[--num4];
		}
		mSizes.Clear();
		if (num3 < 0f)
		{
			num4++;
		}
		return num4;
	}

	public static string GetEndOfLineThatFits(string text)
	{
		int length = text.Length;
		int num = CalculateOffsetToFit(text);
		return text.Substring(num, length - num);
	}

	public static bool WrapText(string text, out string finalText)
	{
		return WrapText(text, out finalText, keepCharCount: false);
	}

	private static bool CanCharStartNewLine(char ch)
	{
		return ch != '.' && ch != '?' && ch != '!' && ch != ':' && ch != ';' && ch != ' ' && ch != ',' && ch != '' && ch != '' && ch != '' && ch != '' && ch != '';
	}

	private static bool CanCharEndLine(char ch)
	{
		return ch != '';
	}

	public static bool WrapText(string text, out string finalText, bool keepCharCount)
	{
		if (regionWidth < 1 || regionHeight < 1 || finalLineHeight < 1f)
		{
			finalText = string.Empty;
			return false;
		}
		float num = ((maxLines <= 0) ? ((float)regionHeight) : Mathf.Min(regionHeight, finalLineHeight * (float)maxLines));
		int num2 = ((maxLines <= 0) ? 1000000 : maxLines);
		num2 = Mathf.FloorToInt(Mathf.Min(num2, num / finalLineHeight) + 0.01f);
		if (num2 == 0)
		{
			finalText = string.Empty;
			return false;
		}
		if (string.IsNullOrEmpty(text))
		{
			text = " ";
		}
		Prepare(text);
		StringBuilder s = new StringBuilder();
		int length = text.Length;
		float num3 = regionWidth;
		int num4 = 0;
		int i = 0;
		int num5 = 1;
		int prev = 0;
		bool flag = true;
		bool flag2 = true;
		bool flag3 = false;
		float[] array = new float[length];
		for (; i < length; i++)
		{
			char c = text[i];
			if (c == '\n')
			{
				if (num5 == num2)
				{
					break;
				}
				num3 = regionWidth;
				if (num4 < i)
				{
					s.Append(text.Substring(num4, i - num4 + 1));
				}
				else
				{
					s.Append(c);
				}
				flag = true;
				num5++;
				num4 = i + 1;
				prev = 0;
				continue;
			}
			if (encoding && ParseSymbol(text, ref i))
			{
				i--;
				continue;
			}
			BMSymbol bMSymbol = ((!useSymbols) ? null : GetSymbol(text, i, length));
			float num6;
			if (bMSymbol == null)
			{
				float glyphWidth = GetGlyphWidth(c, prev);
				if (glyphWidth == 0f)
				{
					continue;
				}
				num6 = finalSpacingX + glyphWidth;
			}
			else
			{
				num6 = finalSpacingX + (float)bMSymbol.advance * fontScale;
			}
			num3 -= num6;
			array[i] = num6;
			if (IsSpace(c) && !flag3 && num4 < i)
			{
				int num7 = i - num4 + 1;
				if (num5 == num2 && num3 <= 0f && i < length)
				{
					char c2 = text[i];
					if (c2 < ' ' || IsSpace(c2))
					{
						num7--;
					}
				}
				s.Append(text.Substring(num4, num7));
				flag = false;
				num4 = i + 1;
				prev = c;
			}
			if (Mathf.RoundToInt(num3) < 0)
			{
				if (!flag && num5 != num2)
				{
					flag = true;
					num3 = regionWidth;
					i = num4 - 1;
					prev = 0;
					if (num5++ == num2)
					{
						break;
					}
					if (keepCharCount)
					{
						ReplaceSpaceWithNewline(ref s);
					}
					else
					{
						EndLine(ref s);
					}
					continue;
				}
				float num8 = 0f;
				int num9 = i;
				for (int num10 = i - 1; num10 >= 0; num10--)
				{
					num8 += array[num9];
					if (CanCharEndLine(text[num10]) && CanCharStartNewLine(text[num9]))
					{
						i = num9;
						break;
					}
					num9--;
				}
				s.Append(text.Substring(num4, Mathf.Max(0, i - num4)));
				bool flag4 = IsSpace(c);
				if (!flag4 && !flag3)
				{
					flag2 = false;
				}
				if (num5++ == num2)
				{
					num4 = i;
					break;
				}
				if (keepCharCount && flag4)
				{
					ReplaceSpaceWithNewline(ref s);
				}
				else
				{
					EndLine(ref s);
				}
				flag = true;
				if (flag4)
				{
					num4 = i + 1;
					num3 = regionWidth;
				}
				else
				{
					num4 = i;
					num3 = (float)regionWidth - num8;
				}
				prev = 0;
			}
			else
			{
				prev = c;
			}
			if (bMSymbol != null)
			{
				i += bMSymbol.length - 1;
				prev = 0;
			}
		}
		if (num4 < i)
		{
			s.Append(text.Substring(num4, i - num4));
		}
		finalText = s.ToString();
		return flag2 && (i == length || num5 <= Mathf.Min(maxLines, num2));
	}

	public static void Print(string text, BetterList<Vector3> verts, BetterList<Vector2> uvs, BetterList<Color32> cols)
	{
		if (string.IsNullOrEmpty(text))
		{
			return;
		}
		int size = verts.size;
		Prepare(text);
		mColors.Add(UnityEngine.Color.white);
		mAlpha = 1f;
		int num = 0;
		int prev = 0;
		float num2 = 0f;
		float num3 = 0f;
		float num4 = 0f;
		float num5 = finalSize;
		UnityEngine.Color a = tint * gradientBottom;
		UnityEngine.Color b = tint * gradientTop;
		Color32 color = tint;
		int length = text.Length;
		Rect rect = default(Rect);
		float num6 = 0f;
		float num7 = 0f;
		float num8 = num5 * pixelDensity;
		bool flag = false;
		int sub = 0;
		bool bold = false;
		bool italic = false;
		bool underline = false;
		bool strike = false;
		bool ignoreColor = false;
		float num9 = 0f;
		if (bitmapFont != null)
		{
			rect = bitmapFont.uvRect;
			num6 = rect.width / (float)bitmapFont.texWidth;
			num7 = rect.height / (float)bitmapFont.texHeight;
		}
		for (int i = 0; i < length; i++)
		{
			num = text[i];
			num9 = num2;
			if (num == 10)
			{
				if (num2 > num4)
				{
					num4 = num2;
				}
				if (alignment != Alignment.Left)
				{
					Align(verts, size, num2 - finalSpacingX);
					size = verts.size;
				}
				num2 = 0f;
				num3 += finalLineHeight;
				prev = 0;
				continue;
			}
			if (num < 32)
			{
				prev = num;
				continue;
			}
			if (encoding && ParseSymbol(text, ref i, mColors, premultiply, ref sub, ref bold, ref italic, ref underline, ref strike, ref ignoreColor))
			{
				UnityEngine.Color color2;
				if (ignoreColor)
				{
					color2 = mColors[mColors.size - 1];
					color2.a *= mAlpha * tint.a;
				}
				else
				{
					color2 = tint * mColors[mColors.size - 1];
					color2.a *= mAlpha;
				}
				color = color2;
				int j = 0;
				for (int num10 = mColors.size - 2; j < num10; j++)
				{
					color2.a *= mColors[j].a;
				}
				if (gradient)
				{
					a = gradientBottom * color2;
					b = gradientTop * color2;
				}
				i--;
				continue;
			}
			BMSymbol bMSymbol = ((!useSymbols) ? null : GetSymbol(text, i, length));
			float num11;
			float num12;
			float num14;
			float num13;
			if (bMSymbol != null)
			{
				num11 = num2 + (float)bMSymbol.offsetX * fontScale;
				num12 = num11 + (float)bMSymbol.width * fontScale;
				num13 = 0f - (num3 + (float)bMSymbol.offsetY * fontScale);
				num14 = num13 - (float)bMSymbol.height * fontScale;
				if (Mathf.RoundToInt(num2 + (float)bMSymbol.advance * fontScale) > regionWidth)
				{
					if (num2 == 0f)
					{
						return;
					}
					if (alignment != Alignment.Left && size < verts.size)
					{
						Align(verts, size, num2 - finalSpacingX);
						size = verts.size;
					}
					num11 -= num2;
					num12 -= num2;
					num14 -= finalLineHeight;
					num13 -= finalLineHeight;
					num2 = 0f;
					num3 += finalLineHeight;
					num9 = 0f;
				}
				verts.Add(new Vector3(num11, num14));
				verts.Add(new Vector3(num11, num13));
				verts.Add(new Vector3(num12, num13));
				verts.Add(new Vector3(num12, num14));
				num2 += finalSpacingX + (float)bMSymbol.advance * fontScale;
				i += bMSymbol.length - 1;
				prev = 0;
				if (uvs != null)
				{
					Rect uvRect = bMSymbol.uvRect;
					float xMin = uvRect.xMin;
					float yMin = uvRect.yMin;
					float xMax = uvRect.xMax;
					float yMax = uvRect.yMax;
					uvs.Add(new Vector2(xMin, yMin));
					uvs.Add(new Vector2(xMin, yMax));
					uvs.Add(new Vector2(xMax, yMax));
					uvs.Add(new Vector2(xMax, yMin));
				}
				if (cols == null)
				{
					continue;
				}
				if (symbolStyle == SymbolStyle.Colored)
				{
					for (int k = 0; k < 4; k++)
					{
						cols.Add(color);
					}
					continue;
				}
				Color32 item = UnityEngine.Color.white;
				item.a = color.a;
				for (int l = 0; l < 4; l++)
				{
					cols.Add(item);
				}
				continue;
			}
			GlyphInfo glyphInfo = GetGlyph(num, prev);
			if (glyphInfo == null)
			{
				continue;
			}
			prev = num;
			if (sub != 0)
			{
				glyphInfo.v0.x *= 0.75f;
				glyphInfo.v0.y *= 0.75f;
				glyphInfo.v1.x *= 0.75f;
				glyphInfo.v1.y *= 0.75f;
				if (sub == 1)
				{
					glyphInfo.v0.y -= fontScale * (float)fontSize * 0.4f;
					glyphInfo.v1.y -= fontScale * (float)fontSize * 0.4f;
				}
				else
				{
					glyphInfo.v0.y += fontScale * (float)fontSize * 0.05f;
					glyphInfo.v1.y += fontScale * (float)fontSize * 0.05f;
				}
			}
			num11 = glyphInfo.v0.x + num2;
			num14 = glyphInfo.v0.y - num3;
			num12 = glyphInfo.v1.x + num2;
			num13 = glyphInfo.v1.y - num3;
			float num15 = glyphInfo.advance;
			if (finalSpacingX < 0f)
			{
				num15 += finalSpacingX;
			}
			if (Mathf.RoundToInt(num2 + num15) > regionWidth)
			{
				if (num2 == 0f)
				{
					return;
				}
				if (alignment != Alignment.Left && size < verts.size)
				{
					Align(verts, size, num2 - finalSpacingX);
					size = verts.size;
				}
				num11 -= num2;
				num12 -= num2;
				num14 -= finalLineHeight;
				num13 -= finalLineHeight;
				num2 = 0f;
				num3 += finalLineHeight;
				num9 = 0f;
			}
			if (IsSpace(num))
			{
				if (underline)
				{
					num = 95;
				}
				else if (strike)
				{
					num = 45;
				}
			}
			num2 += ((sub != 0) ? ((finalSpacingX + glyphInfo.advance) * 0.75f) : (finalSpacingX + glyphInfo.advance));
			if (IsSpace(num))
			{
				continue;
			}
			if (uvs != null)
			{
				if (bitmapFont != null)
				{
					glyphInfo.u0.x = rect.xMin + num6 * glyphInfo.u0.x;
					glyphInfo.u1.x = rect.xMin + num6 * glyphInfo.u1.x;
					glyphInfo.u0.y = rect.yMax - num7 * glyphInfo.u0.y;
					glyphInfo.u1.y = rect.yMax - num7 * glyphInfo.u1.y;
				}
				int m = 0;
				for (int num16 = ((!bold) ? 1 : 4); m < num16; m++)
				{
					if (glyphInfo.rotatedUVs)
					{
						uvs.Add(glyphInfo.u0);
						uvs.Add(new Vector2(glyphInfo.u1.x, glyphInfo.u0.y));
						uvs.Add(glyphInfo.u1);
						uvs.Add(new Vector2(glyphInfo.u0.x, glyphInfo.u1.y));
					}
					else
					{
						uvs.Add(glyphInfo.u0);
						uvs.Add(new Vector2(glyphInfo.u0.x, glyphInfo.u1.y));
						uvs.Add(glyphInfo.u1);
						uvs.Add(new Vector2(glyphInfo.u1.x, glyphInfo.u0.y));
					}
				}
			}
			if (cols != null)
			{
				if (glyphInfo.channel == 0 || glyphInfo.channel == 15)
				{
					if (gradient)
					{
						float num17 = num8 + glyphInfo.v0.y / fontScale;
						float num18 = num8 + glyphInfo.v1.y / fontScale;
						num17 /= num8;
						num18 /= num8;
						s_c0 = UnityEngine.Color.Lerp(a, b, num17);
						s_c1 = UnityEngine.Color.Lerp(a, b, num18);
						int n = 0;
						for (int num19 = ((!bold) ? 1 : 4); n < num19; n++)
						{
							cols.Add(s_c0);
							cols.Add(s_c1);
							cols.Add(s_c1);
							cols.Add(s_c0);
						}
					}
					else
					{
						int num20 = 0;
						for (int num21 = ((!bold) ? 4 : 16); num20 < num21; num20++)
						{
							cols.Add(color);
						}
					}
				}
				else
				{
					UnityEngine.Color color3 = color;
					color3 *= 0.49f;
					switch (glyphInfo.channel)
					{
					case 1:
						color3.b += 0.51f;
						break;
					case 2:
						color3.g += 0.51f;
						break;
					case 4:
						color3.r += 0.51f;
						break;
					case 8:
						color3.a += 0.51f;
						break;
					}
					Color32 item2 = color3;
					int num22 = 0;
					for (int num23 = ((!bold) ? 4 : 16); num22 < num23; num22++)
					{
						cols.Add(item2);
					}
				}
			}
			if (!bold)
			{
				if (!italic)
				{
					verts.Add(new Vector3(num11, num14));
					verts.Add(new Vector3(num11, num13));
					verts.Add(new Vector3(num12, num13));
					verts.Add(new Vector3(num12, num14));
				}
				else
				{
					float num24 = (float)fontSize * 0.1f * ((num13 - num14) / (float)fontSize);
					verts.Add(new Vector3(num11 - num24, num14));
					verts.Add(new Vector3(num11 + num24, num13));
					verts.Add(new Vector3(num12 + num24, num13));
					verts.Add(new Vector3(num12 - num24, num14));
				}
			}
			else
			{
				for (int num25 = 0; num25 < 4; num25++)
				{
					float num26 = mBoldOffset[num25 * 2];
					float num27 = mBoldOffset[num25 * 2 + 1];
					float num28 = ((!italic) ? 0f : ((float)fontSize * 0.1f * ((num13 - num14) / (float)fontSize)));
					verts.Add(new Vector3(num11 + num26 - num28, num14 + num27));
					verts.Add(new Vector3(num11 + num26 + num28, num13 + num27));
					verts.Add(new Vector3(num12 + num26 + num28, num13 + num27));
					verts.Add(new Vector3(num12 + num26 - num28, num14 + num27));
				}
			}
			if (!underline && !strike)
			{
				continue;
			}
			GlyphInfo glyphInfo2 = GetGlyph((!strike) ? 95 : 45, prev);
			if (glyphInfo2 == null)
			{
				continue;
			}
			if (uvs != null)
			{
				if (bitmapFont != null)
				{
					glyphInfo2.u0.x = rect.xMin + num6 * glyphInfo2.u0.x;
					glyphInfo2.u1.x = rect.xMin + num6 * glyphInfo2.u1.x;
					glyphInfo2.u0.y = rect.yMax - num7 * glyphInfo2.u0.y;
					glyphInfo2.u1.y = rect.yMax - num7 * glyphInfo2.u1.y;
				}
				float x = (glyphInfo2.u0.x + glyphInfo2.u1.x) * 0.5f;
				int num29 = 0;
				for (int num30 = ((!bold) ? 1 : 4); num29 < num30; num29++)
				{
					uvs.Add(new Vector2(x, glyphInfo2.u0.y));
					uvs.Add(new Vector2(x, glyphInfo2.u1.y));
					uvs.Add(new Vector2(x, glyphInfo2.u1.y));
					uvs.Add(new Vector2(x, glyphInfo2.u0.y));
				}
			}
			if (flag && strike)
			{
				num14 = (0f - num3 + glyphInfo2.v0.y) * 0.75f;
				num13 = (0f - num3 + glyphInfo2.v1.y) * 0.75f;
			}
			else
			{
				num14 = 0f - num3 + glyphInfo2.v0.y;
				num13 = 0f - num3 + glyphInfo2.v1.y;
			}
			if (bold)
			{
				for (int num31 = 0; num31 < 4; num31++)
				{
					float num32 = mBoldOffset[num31 * 2];
					float num33 = mBoldOffset[num31 * 2 + 1];
					verts.Add(new Vector3(num9 + num32, num14 + num33));
					verts.Add(new Vector3(num9 + num32, num13 + num33));
					verts.Add(new Vector3(num2 + num32, num13 + num33));
					verts.Add(new Vector3(num2 + num32, num14 + num33));
				}
			}
			else
			{
				verts.Add(new Vector3(num9, num14));
				verts.Add(new Vector3(num9, num13));
				verts.Add(new Vector3(num2, num13));
				verts.Add(new Vector3(num2, num14));
			}
			if (gradient)
			{
				float num34 = num8 + glyphInfo2.v0.y / fontScale;
				float num35 = num8 + glyphInfo2.v1.y / fontScale;
				num34 /= num8;
				num35 /= num8;
				s_c0 = UnityEngine.Color.Lerp(a, b, num34);
				s_c1 = UnityEngine.Color.Lerp(a, b, num35);
				int num36 = 0;
				for (int num37 = ((!bold) ? 1 : 4); num36 < num37; num36++)
				{
					cols.Add(s_c0);
					cols.Add(s_c1);
					cols.Add(s_c1);
					cols.Add(s_c0);
				}
			}
			else
			{
				int num38 = 0;
				for (int num39 = ((!bold) ? 4 : 16); num38 < num39; num38++)
				{
					cols.Add(color);
				}
			}
		}
		if (alignment != Alignment.Left && size < verts.size)
		{
			Align(verts, size, num2 - finalSpacingX);
			size = verts.size;
		}
		mColors.Clear();
	}

	public static void PrintApproximateCharacterPositions(string text, BetterList<Vector3> verts, BetterList<int> indices)
	{
		if (string.IsNullOrEmpty(text))
		{
			text = " ";
		}
		Prepare(text);
		float num = 0f;
		float num2 = 0f;
		float num3 = 0f;
		float num4 = (float)fontSize * fontScale * 0.5f;
		int length = text.Length;
		int size = verts.size;
		int num5 = 0;
		int prev = 0;
		for (int i = 0; i < length; i++)
		{
			num5 = text[i];
			verts.Add(new Vector3(num, 0f - num2 - num4));
			indices.Add(i);
			if (num5 == 10)
			{
				if (num > num3)
				{
					num3 = num;
				}
				if (alignment != Alignment.Left)
				{
					Align(verts, size, num - finalSpacingX);
					size = verts.size;
				}
				num = 0f;
				num2 += finalLineHeight;
				prev = 0;
				continue;
			}
			if (num5 < 32)
			{
				prev = 0;
				continue;
			}
			if (encoding && ParseSymbol(text, ref i))
			{
				i--;
				continue;
			}
			BMSymbol bMSymbol = ((!useSymbols) ? null : GetSymbol(text, i, length));
			if (bMSymbol == null)
			{
				float glyphWidth = GetGlyphWidth(num5, prev);
				if (glyphWidth == 0f)
				{
					continue;
				}
				glyphWidth += finalSpacingX;
				if (Mathf.RoundToInt(num + glyphWidth) > regionWidth)
				{
					if (num == 0f)
					{
						return;
					}
					if (alignment != Alignment.Left && size < verts.size)
					{
						Align(verts, size, num - finalSpacingX);
						size = verts.size;
					}
					num = glyphWidth;
					num2 += finalLineHeight;
				}
				else
				{
					num += glyphWidth;
				}
				verts.Add(new Vector3(num, 0f - num2 - num4));
				indices.Add(i + 1);
				prev = num5;
				continue;
			}
			float num6 = (float)bMSymbol.advance * fontScale + finalSpacingX;
			if (Mathf.RoundToInt(num + num6) > regionWidth)
			{
				if (num == 0f)
				{
					return;
				}
				if (alignment != Alignment.Left && size < verts.size)
				{
					Align(verts, size, num - finalSpacingX);
					size = verts.size;
				}
				num = num6;
				num2 += finalLineHeight;
			}
			else
			{
				num += num6;
			}
			verts.Add(new Vector3(num, 0f - num2 - num4));
			indices.Add(i + 1);
			i += bMSymbol.sequence.Length - 1;
			prev = 0;
		}
		if (alignment != Alignment.Left && size < verts.size)
		{
			Align(verts, size, num - finalSpacingX);
		}
	}

	public static void PrintExactCharacterPositions(string text, BetterList<Vector3> verts, BetterList<int> indices)
	{
		if (string.IsNullOrEmpty(text))
		{
			text = " ";
		}
		Prepare(text);
		float num = (float)fontSize * fontScale;
		float num2 = 0f;
		float num3 = 0f;
		float num4 = 0f;
		int length = text.Length;
		int size = verts.size;
		int num5 = 0;
		int prev = 0;
		for (int i = 0; i < length; i++)
		{
			num5 = text[i];
			if (num5 == 10)
			{
				if (num2 > num4)
				{
					num4 = num2;
				}
				if (alignment != Alignment.Left)
				{
					Align(verts, size, num2 - finalSpacingX);
					size = verts.size;
				}
				num2 = 0f;
				num3 += finalLineHeight;
				prev = 0;
				continue;
			}
			if (num5 < 32)
			{
				prev = 0;
				continue;
			}
			if (encoding && ParseSymbol(text, ref i))
			{
				i--;
				continue;
			}
			BMSymbol bMSymbol = ((!useSymbols) ? null : GetSymbol(text, i, length));
			if (bMSymbol == null)
			{
				float glyphWidth = GetGlyphWidth(num5, prev);
				if (glyphWidth == 0f)
				{
					continue;
				}
				float num6 = glyphWidth + finalSpacingX;
				if (Mathf.RoundToInt(num2 + num6) > regionWidth)
				{
					if (num2 == 0f)
					{
						return;
					}
					if (alignment != Alignment.Left && size < verts.size)
					{
						Align(verts, size, num2 - finalSpacingX);
						size = verts.size;
					}
					num2 = 0f;
					num3 += finalLineHeight;
					prev = 0;
					i--;
				}
				else
				{
					indices.Add(i);
					verts.Add(new Vector3(num2, 0f - num3 - num));
					verts.Add(new Vector3(num2 + num6, 0f - num3));
					prev = num5;
					num2 += num6;
				}
				continue;
			}
			float num7 = (float)bMSymbol.advance * fontScale + finalSpacingX;
			if (Mathf.RoundToInt(num2 + num7) > regionWidth)
			{
				if (num2 == 0f)
				{
					return;
				}
				if (alignment != Alignment.Left && size < verts.size)
				{
					Align(verts, size, num2 - finalSpacingX);
					size = verts.size;
				}
				num2 = 0f;
				num3 += finalLineHeight;
				prev = 0;
				i--;
			}
			else
			{
				indices.Add(i);
				verts.Add(new Vector3(num2, 0f - num3 - num));
				verts.Add(new Vector3(num2 + num7, 0f - num3));
				i += bMSymbol.sequence.Length - 1;
				num2 += num7;
				prev = 0;
			}
		}
		if (alignment != Alignment.Left && size < verts.size)
		{
			Align(verts, size, num2 - finalSpacingX);
		}
	}

	public static void PrintCaretAndSelection(string text, int start, int end, BetterList<Vector3> caret, BetterList<Vector3> highlight)
	{
		if (string.IsNullOrEmpty(text))
		{
			text = " ";
		}
		Prepare(text);
		int num = end;
		if (start > end)
		{
			end = start;
			start = num;
		}
		float num2 = 0f;
		float num3 = 0f;
		float num4 = 0f;
		float num5 = (float)fontSize * fontScale;
		int indexOffset = caret?.size ?? 0;
		int num6 = highlight?.size ?? 0;
		int length = text.Length;
		int i = 0;
		int num7 = 0;
		int prev = 0;
		bool flag = false;
		bool flag2 = false;
		Vector2 vector = Vector2.zero;
		Vector2 vector2 = Vector2.zero;
		for (; i < length; i++)
		{
			if (caret != null && !flag2 && num <= i)
			{
				flag2 = true;
				caret.Add(new Vector3(num2 - 1f, 0f - num3 - num5));
				caret.Add(new Vector3(num2 - 1f, 0f - num3));
				caret.Add(new Vector3(num2 + 1f, 0f - num3));
				caret.Add(new Vector3(num2 + 1f, 0f - num3 - num5));
			}
			num7 = text[i];
			if (num7 == 10)
			{
				if (num2 > num4)
				{
					num4 = num2;
				}
				if (caret != null && flag2)
				{
					if (alignment != Alignment.Left)
					{
						Align(caret, indexOffset, num2 - finalSpacingX);
					}
					caret = null;
				}
				if (highlight != null)
				{
					if (flag)
					{
						flag = false;
						highlight.Add(vector2);
						highlight.Add(vector);
					}
					else if (start <= i && end > i)
					{
						highlight.Add(new Vector3(num2, 0f - num3 - num5));
						highlight.Add(new Vector3(num2, 0f - num3));
						highlight.Add(new Vector3(num2 + 2f, 0f - num3));
						highlight.Add(new Vector3(num2 + 2f, 0f - num3 - num5));
					}
					if (alignment != Alignment.Left && num6 < highlight.size)
					{
						Align(highlight, num6, num2 - finalSpacingX);
						num6 = highlight.size;
					}
				}
				num2 = 0f;
				num3 += finalLineHeight;
				prev = 0;
				continue;
			}
			if (num7 < 32)
			{
				prev = 0;
				continue;
			}
			if (encoding && ParseSymbol(text, ref i))
			{
				i--;
				continue;
			}
			BMSymbol bMSymbol = ((!useSymbols) ? null : GetSymbol(text, i, length));
			float num8 = ((bMSymbol == null) ? GetGlyphWidth(num7, prev) : ((float)bMSymbol.advance * fontScale));
			if (num8 == 0f)
			{
				continue;
			}
			float num9 = num2;
			float num10 = num2 + num8;
			float num11 = 0f - num3 - num5;
			float num12 = 0f - num3;
			if (Mathf.RoundToInt(num10 + finalSpacingX) > regionWidth)
			{
				if (num2 == 0f)
				{
					return;
				}
				if (num2 > num4)
				{
					num4 = num2;
				}
				if (caret != null && flag2)
				{
					if (alignment != Alignment.Left)
					{
						Align(caret, indexOffset, num2 - finalSpacingX);
					}
					caret = null;
				}
				if (highlight != null)
				{
					if (flag)
					{
						flag = false;
						highlight.Add(vector2);
						highlight.Add(vector);
					}
					else if (start <= i && end > i)
					{
						highlight.Add(new Vector3(num2, 0f - num3 - num5));
						highlight.Add(new Vector3(num2, 0f - num3));
						highlight.Add(new Vector3(num2 + 2f, 0f - num3));
						highlight.Add(new Vector3(num2 + 2f, 0f - num3 - num5));
					}
					if (alignment != Alignment.Left && num6 < highlight.size)
					{
						Align(highlight, num6, num2 - finalSpacingX);
						num6 = highlight.size;
					}
				}
				num9 -= num2;
				num10 -= num2;
				num11 -= finalLineHeight;
				num12 -= finalLineHeight;
				num2 = 0f;
				num3 += finalLineHeight;
			}
			num2 += num8 + finalSpacingX;
			if (highlight != null)
			{
				if (start > i || end <= i)
				{
					if (flag)
					{
						flag = false;
						highlight.Add(vector2);
						highlight.Add(vector);
					}
				}
				else if (!flag)
				{
					flag = true;
					highlight.Add(new Vector3(num9, num11));
					highlight.Add(new Vector3(num9, num12));
				}
			}
			vector = new Vector2(num10, num11);
			vector2 = new Vector2(num10, num12);
			prev = num7;
		}
		if (caret != null)
		{
			if (!flag2)
			{
				caret.Add(new Vector3(num2 - 1f, 0f - num3 - num5));
				caret.Add(new Vector3(num2 - 1f, 0f - num3));
				caret.Add(new Vector3(num2 + 1f, 0f - num3));
				caret.Add(new Vector3(num2 + 1f, 0f - num3 - num5));
			}
			if (alignment != Alignment.Left)
			{
				Align(caret, indexOffset, num2 - finalSpacingX);
			}
		}
		if (highlight != null)
		{
			if (flag)
			{
				highlight.Add(vector2);
				highlight.Add(vector);
			}
			else if (start < i && end == i)
			{
				highlight.Add(new Vector3(num2, 0f - num3 - num5));
				highlight.Add(new Vector3(num2, 0f - num3));
				highlight.Add(new Vector3(num2 + 2f, 0f - num3));
				highlight.Add(new Vector3(num2 + 2f, 0f - num3 - num5));
			}
			if (alignment != Alignment.Left && num6 < highlight.size)
			{
				Align(highlight, num6, num2 - finalSpacingX);
			}
		}
	}
}
public static class NGUITools
{
	private static AudioListener mListener;

	private static bool mLoaded = false;

	private static float mGlobalVolume = 1f;

	private static Vector3[] mSides = new Vector3[4];

	public static float soundVolume
	{
		get
		{
			if (!mLoaded)
			{
				mLoaded = true;
				mGlobalVolume = PlayerPrefs.GetFloat("Sound", 1f);
			}
			return mGlobalVolume;
		}
		set
		{
			if (mGlobalVolume != value)
			{
				mLoaded = true;
				mGlobalVolume = value;
				PlayerPrefs.SetFloat("Sound", value);
			}
		}
	}

	public static bool fileAccess => Application.platform != RuntimePlatform.WindowsWebPlayer && Application.platform != RuntimePlatform.OSXWebPlayer;

	public static string clipboard
	{
		get
		{
			TextEditor textEditor = new TextEditor();
			textEditor.Paste();
			return textEditor.content.text;
		}
		set
		{
			TextEditor textEditor = new TextEditor();
			textEditor.content = new GUIContent(value);
			textEditor.OnFocus();
			textEditor.Copy();
		}
	}

	public static Vector2 screenSize => new Vector2(Screen.width, Screen.height);

	public static AudioSource PlaySound(AudioClip clip)
	{
		return PlaySound(clip, 1f, 1f);
	}

	public static AudioSource PlaySound(AudioClip clip, float volume)
	{
		return PlaySound(clip, volume, 1f);
	}

	public static AudioSource PlaySound(AudioClip clip, float volume, float pitch)
	{
		volume *= soundVolume;
		if (clip != null && volume > 0.01f)
		{
			if (mListener == null || !GetActive(mListener))
			{
				if (UnityEngine.Object.FindObjectsOfType(typeof(AudioListener)) is AudioListener[] array)
				{
					for (int i = 0; i < array.Length; i++)
					{
						if (GetActive(array[i]))
						{
							mListener = array[i];
							break;
						}
					}
				}
				if (mListener == null)
				{
					Camera camera = Camera.main;
					if (camera == null)
					{
						camera = UnityEngine.Object.FindObjectOfType(typeof(Camera)) as Camera;
					}
					if (camera != null)
					{
						mListener = camera.gameObject.AddComponent<AudioListener>();
					}
				}
			}
			if (mListener != null && mListener.enabled && GetActive(mListener.gameObject))
			{
				AudioSource audioSource = mListener.GetComponent<AudioSource>();
				if (audioSource == null)
				{
					audioSource = mListener.gameObject.AddComponent<AudioSource>();
				}
				audioSource.pitch = pitch;
				audioSource.PlayOneShot(clip, volume);
				return audioSource;
			}
		}
		return null;
	}

	public static int RandomRange(int min, int max)
	{
		if (min == max)
		{
			return min;
		}
		return UnityEngine.Random.Range(min, max + 1);
	}

	public static string GetHierarchy(GameObject obj)
	{
		if (obj == null)
		{
			return string.Empty;
		}
		string text = obj.name;
		while (obj.transform.parent != null)
		{
			obj = obj.transform.parent.gameObject;
			text = obj.name + "\\" + text;
		}
		return text;
	}

	public static T[] FindActive<T>() where T : Component
	{
		return UnityEngine.Object.FindObjectsOfType(typeof(T)) as T[];
	}

	public static Camera FindCameraForLayer(int layer)
	{
		int num = 1 << layer;
		Camera cachedCamera;
		for (int i = 0; i < UICamera.list.size; i++)
		{
			cachedCamera = UICamera.list.buffer[i].cachedCamera;
			if ((bool)cachedCamera && (cachedCamera.cullingMask & num) != 0)
			{
				return cachedCamera;
			}
		}
		cachedCamera = Camera.main;
		if ((bool)cachedCamera && (cachedCamera.cullingMask & num) != 0)
		{
			return cachedCamera;
		}
		Camera[] array = new Camera[Camera.allCamerasCount];
		int allCameras = Camera.GetAllCameras(array);
		for (int j = 0; j < allCameras; j++)
		{
			cachedCamera = array[j];
			if ((bool)cachedCamera && cachedCamera.enabled && (cachedCamera.cullingMask & num) != 0)
			{
				return cachedCamera;
			}
		}
		return null;
	}

	public static void AddWidgetCollider(GameObject go)
	{
		AddWidgetCollider(go, considerInactive: false);
	}

	public static void AddWidgetCollider(GameObject go, bool considerInactive)
	{
		if (!(go != null))
		{
			return;
		}
		Collider component = go.GetComponent<Collider>();
		BoxCollider boxCollider = component as BoxCollider;
		if (boxCollider != null)
		{
			UpdateWidgetCollider(boxCollider, considerInactive);
		}
		else
		{
			if (component != null)
			{
				return;
			}
			BoxCollider2D component2 = go.GetComponent<BoxCollider2D>();
			if (component2 != null)
			{
				UpdateWidgetCollider(component2, considerInactive);
				return;
			}
			UICamera uICamera = UICamera.FindCameraForLayer(go.layer);
			if (uICamera != null && (uICamera.eventType == UICamera.EventType.World_2D || uICamera.eventType == UICamera.EventType.UI_2D))
			{
				component2 = go.AddComponent<BoxCollider2D>();
				component2.isTrigger = true;
				UIWidget component3 = go.GetComponent<UIWidget>();
				if (component3 != null)
				{
					component3.autoResizeBoxCollider = true;
				}
				UpdateWidgetCollider(component2, considerInactive);
			}
			else
			{
				boxCollider = go.AddComponent<BoxCollider>();
				boxCollider.isTrigger = true;
				UIWidget component4 = go.GetComponent<UIWidget>();
				if (component4 != null)
				{
					component4.autoResizeBoxCollider = true;
				}
				UpdateWidgetCollider(boxCollider, considerInactive);
			}
		}
	}

	public static void UpdateWidgetCollider(GameObject go)
	{
		UpdateWidgetCollider(go, considerInactive: false);
	}

	public static void UpdateWidgetCollider(GameObject go, bool considerInactive)
	{
		if (!(go != null))
		{
			return;
		}
		BoxCollider component = go.GetComponent<BoxCollider>();
		if (component != null)
		{
			UpdateWidgetCollider(component, considerInactive);
			return;
		}
		BoxCollider2D component2 = go.GetComponent<BoxCollider2D>();
		if (component2 != null)
		{
			UpdateWidgetCollider(component2, considerInactive);
		}
	}

	public static void UpdateWidgetCollider(BoxCollider box, bool considerInactive)
	{
		if (!(box != null))
		{
			return;
		}
		GameObject gameObject = box.gameObject;
		UIWidget component = gameObject.GetComponent<UIWidget>();
		if (component != null)
		{
			Vector4 drawRegion = component.drawRegion;
			if (drawRegion.x != 0f || drawRegion.y != 0f || drawRegion.z != 1f || drawRegion.w != 1f)
			{
				Vector4 drawingDimensions = component.drawingDimensions;
				box.center = new Vector3((drawingDimensions.x + drawingDimensions.z) * 0.5f, (drawingDimensions.y + drawingDimensions.w) * 0.5f);
				box.size = new Vector3(drawingDimensions.z - drawingDimensions.x, drawingDimensions.w - drawingDimensions.y);
			}
			else
			{
				Vector3[] localCorners = component.localCorners;
				box.center = Vector3.Lerp(localCorners[0], localCorners[2], 0.5f);
				box.size = localCorners[2] - localCorners[0];
			}
		}
		else
		{
			Bounds bounds = NGUIMath.CalculateRelativeWidgetBounds(gameObject.transform, considerInactive);
			box.center = bounds.center;
			box.size = new Vector3(bounds.size.x, bounds.size.y, 0f);
		}
	}

	public static void UpdateWidgetCollider(BoxCollider2D box, bool considerInactive)
	{
		if (box != null)
		{
			GameObject gameObject = box.gameObject;
			UIWidget component = gameObject.GetComponent<UIWidget>();
			if (component != null)
			{
				Vector3[] localCorners = component.localCorners;
				box.offset = Vector3.Lerp(localCorners[0], localCorners[2], 0.5f);
				box.size = localCorners[2] - localCorners[0];
			}
			else
			{
				Bounds bounds = NGUIMath.CalculateRelativeWidgetBounds(gameObject.transform, considerInactive);
				box.offset = bounds.center;
				box.size = new Vector2(bounds.size.x, bounds.size.y);
			}
		}
	}

	public static string GetTypeName<T>()
	{
		string text = typeof(T).ToString();
		if (text.StartsWith("UI"))
		{
			text = text.Substring(2);
		}
		else if (text.StartsWith("UnityEngine."))
		{
			text = text.Substring(12);
		}
		return text;
	}

	public static string GetTypeName(UnityEngine.Object obj)
	{
		if (obj == null)
		{
			return "Null";
		}
		string text = obj.GetType().ToString();
		if (text.StartsWith("UI"))
		{
			text = text.Substring(2);
		}
		else if (text.StartsWith("UnityEngine."))
		{
			text = text.Substring(12);
		}
		return text;
	}

	public static void RegisterUndo(UnityEngine.Object obj, string name)
	{
	}

	public static void SetDirty(UnityEngine.Object obj)
	{
	}

	public static GameObject AddChild(GameObject parent)
	{
		return AddChild(parent, undo: true);
	}

	public static GameObject AddChild(GameObject parent, bool undo)
	{
		GameObject gameObject = new GameObject();
		if (parent != null)
		{
			Transform transform = gameObject.transform;
			transform.parent = parent.transform;
			transform.localPosition = Vector3.zero;
			transform.localRotation = Quaternion.identity;
			transform.localScale = Vector3.one;
			gameObject.layer = parent.layer;
		}
		return gameObject;
	}

	public static GameObject AddChild(GameObject parent, GameObject prefab)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(prefab);
		if (gameObject != null && parent != null)
		{
			Transform transform = gameObject.transform;
			transform.parent = parent.transform;
			transform.localPosition = Vector3.zero;
			transform.localRotation = Quaternion.identity;
			transform.localScale = Vector3.one;
			gameObject.layer = parent.layer;
		}
		return gameObject;
	}

	public static int CalculateRaycastDepth(GameObject go)
	{
		UIWidget component = go.GetComponent<UIWidget>();
		if (component != null)
		{
			return component.raycastDepth;
		}
		UIWidget[] componentsInChildren = go.GetComponentsInChildren<UIWidget>();
		if (componentsInChildren.Length == 0)
		{
			return 0;
		}
		int num = int.MaxValue;
		int i = 0;
		for (int num2 = componentsInChildren.Length; i < num2; i++)
		{
			if (componentsInChildren[i].enabled)
			{
				num = Mathf.Min(num, componentsInChildren[i].raycastDepth);
			}
		}
		return num;
	}

	public static int CalculateNextDepth(GameObject go)
	{
		int num = -1;
		UIWidget[] componentsInChildren = go.GetComponentsInChildren<UIWidget>();
		int i = 0;
		for (int num2 = componentsInChildren.Length; i < num2; i++)
		{
			num = Mathf.Max(num, componentsInChildren[i].depth);
		}
		return num + 1;
	}

	public static int CalculateNextDepth(GameObject go, bool ignoreChildrenWithColliders)
	{
		if (ignoreChildrenWithColliders)
		{
			int num = -1;
			UIWidget[] componentsInChildren = go.GetComponentsInChildren<UIWidget>();
			int i = 0;
			for (int num2 = componentsInChildren.Length; i < num2; i++)
			{
				UIWidget uIWidget = componentsInChildren[i];
				if (!(uIWidget.cachedGameObject != go) || (!(uIWidget.GetComponent<Collider>() != null) && !(uIWidget.GetComponent<Collider2D>() != null)))
				{
					num = Mathf.Max(num, uIWidget.depth);
				}
			}
			return num + 1;
		}
		return CalculateNextDepth(go);
	}

	public static int AdjustDepth(GameObject go, int adjustment)
	{
		if (go != null)
		{
			UIPanel component = go.GetComponent<UIPanel>();
			if (component != null)
			{
				UIPanel[] componentsInChildren = go.GetComponentsInChildren<UIPanel>(includeInactive: true);
				for (int i = 0; i < componentsInChildren.Length; i++)
				{
					componentsInChildren[i].depth += adjustment;
				}
				return 1;
			}
			component = FindInParents<UIPanel>(go);
			if (component == null)
			{
				return 0;
			}
			UIWidget[] componentsInChildren2 = go.GetComponentsInChildren<UIWidget>(includeInactive: true);
			int j = 0;
			for (int num = componentsInChildren2.Length; j < num; j++)
			{
				UIWidget uIWidget = componentsInChildren2[j];
				if (!(uIWidget.panel != component))
				{
					uIWidget.depth += adjustment;
				}
			}
			return 2;
		}
		return 0;
	}

	public static void BringForward(GameObject go)
	{
		switch (AdjustDepth(go, 1000))
		{
		case 1:
			NormalizePanelDepths();
			break;
		case 2:
			NormalizeWidgetDepths();
			break;
		}
	}

	public static void PushBack(GameObject go)
	{
		switch (AdjustDepth(go, -1000))
		{
		case 1:
			NormalizePanelDepths();
			break;
		case 2:
			NormalizeWidgetDepths();
			break;
		}
	}

	public static void NormalizeDepths()
	{
		NormalizeWidgetDepths();
		NormalizePanelDepths();
	}

	public static void NormalizeWidgetDepths()
	{
		NormalizeWidgetDepths(FindActive<UIWidget>());
	}

	public static void NormalizeWidgetDepths(GameObject go)
	{
		NormalizeWidgetDepths(go.GetComponentsInChildren<UIWidget>());
	}

	public static void NormalizeWidgetDepths(UIWidget[] list)
	{
		int num = list.Length;
		if (num <= 0)
		{
			return;
		}
		Array.Sort(list, UIWidget.FullCompareFunc);
		int num2 = 0;
		int depth = list[0].depth;
		for (int i = 0; i < num; i++)
		{
			UIWidget uIWidget = list[i];
			if (uIWidget.depth == depth)
			{
				uIWidget.depth = num2;
				continue;
			}
			depth = uIWidget.depth;
			num2 = (uIWidget.depth = num2 + 1);
		}
	}

	public static void NormalizePanelDepths()
	{
		UIPanel[] array = FindActive<UIPanel>();
		int num = array.Length;
		if (num <= 0)
		{
			return;
		}
		Array.Sort(array, UIPanel.CompareFunc);
		int num2 = 0;
		int depth = array[0].depth;
		for (int i = 0; i < num; i++)
		{
			UIPanel uIPanel = array[i];
			if (uIPanel.depth == depth)
			{
				uIPanel.depth = num2;
				continue;
			}
			depth = uIPanel.depth;
			num2 = (uIPanel.depth = num2 + 1);
		}
	}

	public static UIPanel CreateUI(bool advanced3D)
	{
		return CreateUI(null, advanced3D, -1);
	}

	public static UIPanel CreateUI(bool advanced3D, int layer)
	{
		return CreateUI(null, advanced3D, layer);
	}

	public static UIPanel CreateUI(Transform trans, bool advanced3D, int layer)
	{
		UIRoot uIRoot = ((!(trans != null)) ? null : FindInParents<UIRoot>(trans.gameObject));
		if (uIRoot == null && UIRoot.list.Count > 0)
		{
			foreach (UIRoot item in UIRoot.list)
			{
				if (item.gameObject.layer == layer)
				{
					uIRoot = item;
					break;
				}
			}
		}
		if (uIRoot != null)
		{
			UICamera componentInChildren = uIRoot.GetComponentInChildren<UICamera>();
			if (componentInChildren != null && componentInChildren.GetComponent<Camera>().orthographic == advanced3D)
			{
				trans = null;
				uIRoot = null;
			}
		}
		if (uIRoot == null)
		{
			GameObject gameObject = AddChild(null, undo: false);
			uIRoot = gameObject.AddComponent<UIRoot>();
			if (layer == -1)
			{
				layer = LayerMask.NameToLayer("UI");
			}
			if (layer == -1)
			{
				layer = LayerMask.NameToLayer("2D UI");
			}
			gameObject.layer = layer;
			if (advanced3D)
			{
				gameObject.name = "UI Root (3D)";
				uIRoot.scalingStyle = UIRoot.Scaling.Constrained;
			}
			else
			{
				gameObject.name = "UI Root";
				uIRoot.scalingStyle = UIRoot.Scaling.Flexible;
			}
		}
		UIPanel uIPanel = uIRoot.GetComponentInChildren<UIPanel>();
		if (uIPanel == null)
		{
			Camera[] array = FindActive<Camera>();
			float num = -1f;
			bool flag = false;
			int num2 = 1 << uIRoot.gameObject.layer;
			foreach (Camera camera in array)
			{
				if (camera.clearFlags == CameraClearFlags.Color || camera.clearFlags == CameraClearFlags.Skybox)
				{
					flag = true;
				}
				num = Mathf.Max(num, camera.depth);
				camera.cullingMask &= ~num2;
			}
			Camera camera2 = AddChild<Camera>(uIRoot.gameObject, undo: false);
			camera2.gameObject.AddComponent<UICamera>();
			camera2.clearFlags = ((!flag) ? CameraClearFlags.Color : CameraClearFlags.Depth);
			camera2.backgroundColor = UnityEngine.Color.grey;
			camera2.cullingMask = num2;
			camera2.depth = num + 1f;
			if (advanced3D)
			{
				camera2.nearClipPlane = 0.1f;
				camera2.farClipPlane = 4f;
				camera2.transform.localPosition = new Vector3(0f, 0f, -700f);
			}
			else
			{
				camera2.orthographic = true;
				camera2.orthographicSize = 1f;
				camera2.nearClipPlane = -10f;
				camera2.farClipPlane = 10f;
			}
			AudioListener[] array2 = FindActive<AudioListener>();
			if (array2 == null || array2.Length == 0)
			{
				camera2.gameObject.AddComponent<AudioListener>();
			}
			uIPanel = uIRoot.gameObject.AddComponent<UIPanel>();
		}
		if (trans != null)
		{
			while (trans.parent != null)
			{
				trans = trans.parent;
			}
			if (IsChild(trans, uIPanel.transform))
			{
				uIPanel = trans.gameObject.AddComponent<UIPanel>();
			}
			else
			{
				trans.parent = uIPanel.transform;
				trans.localScale = Vector3.one;
				trans.localPosition = Vector3.zero;
				SetChildLayer(uIPanel.cachedTransform, uIPanel.cachedGameObject.layer);
			}
		}
		return uIPanel;
	}

	public static void SetChildLayer(Transform t, int layer)
	{
		for (int i = 0; i < t.childCount; i++)
		{
			Transform child = t.GetChild(i);
			child.gameObject.layer = layer;
			SetChildLayer(child, layer);
		}
	}

	public static T AddChild<T>(GameObject parent) where T : Component
	{
		GameObject gameObject = AddChild(parent);
		gameObject.name = GetTypeName<T>();
		return gameObject.AddComponent<T>();
	}

	public static T AddChild<T>(GameObject parent, bool undo) where T : Component
	{
		GameObject gameObject = AddChild(parent, undo);
		gameObject.name = GetTypeName<T>();
		return gameObject.AddComponent<T>();
	}

	public static T AddWidget<T>(GameObject go) where T : UIWidget
	{
		int depth = CalculateNextDepth(go);
		T result = AddChild<T>(go);
		result.width = 100;
		result.height = 100;
		result.depth = depth;
		return result;
	}

	public static UISprite AddSprite(GameObject go, UIAtlas atlas, string spriteName)
	{
		UISpriteData uISpriteData = ((!(atlas != null)) ? null : atlas.GetSprite(spriteName));
		UISprite uISprite = AddWidget<UISprite>(go);
		uISprite.type = ((uISpriteData != null && uISpriteData.hasBorder) ? UIBasicSprite.Type.Sliced : UIBasicSprite.Type.Simple);
		uISprite.atlas = atlas;
		uISprite.spriteName = spriteName;
		return uISprite;
	}

	public static GameObject GetRoot(GameObject go)
	{
		Transform transform = go.transform;
		while (true)
		{
			Transform parent = transform.parent;
			if (parent == null)
			{
				break;
			}
			transform = parent;
		}
		return transform.gameObject;
	}

	public static T FindInParents<T>(GameObject go) where T : Component
	{
		if (go == null)
		{
			return (T)null;
		}
		T component = go.GetComponent<T>();
		if (component == null)
		{
			Transform parent = go.transform.parent;
			while (parent != null && component == null)
			{
				component = parent.gameObject.GetComponent<T>();
				parent = parent.parent;
			}
		}
		return component;
	}

	public static T FindInParents<T>(Transform trans) where T : Component
	{
		if (trans == null)
		{
			return (T)null;
		}
		return trans.GetComponentInParent<T>();
	}

	public static void Destroy(UnityEngine.Object obj)
	{
		if (!(obj != null))
		{
			return;
		}
		if (Application.isPlaying)
		{
			if (obj is GameObject)
			{
				GameObject gameObject = obj as GameObject;
				gameObject.transform.parent = null;
			}
			UnityEngine.Object.Destroy(obj);
		}
		else
		{
			UnityEngine.Object.DestroyImmediate(obj);
		}
	}

	public static void DestroyImmediate(UnityEngine.Object obj)
	{
		if (obj != null)
		{
			if (Application.isEditor)
			{
				UnityEngine.Object.DestroyImmediate(obj);
			}
			else
			{
				UnityEngine.Object.Destroy(obj);
			}
		}
	}

	public static void Broadcast(string funcName)
	{
		GameObject[] array = UnityEngine.Object.FindObjectsOfType(typeof(GameObject)) as GameObject[];
		int i = 0;
		for (int num = array.Length; i < num; i++)
		{
			array[i].SendMessage(funcName, SendMessageOptions.DontRequireReceiver);
		}
	}

	public static void Broadcast(string funcName, object param)
	{
		GameObject[] array = UnityEngine.Object.FindObjectsOfType(typeof(GameObject)) as GameObject[];
		int i = 0;
		for (int num = array.Length; i < num; i++)
		{
			array[i].SendMessage(funcName, param, SendMessageOptions.DontRequireReceiver);
		}
	}

	public static bool IsChild(Transform parent, Transform child)
	{
		if (parent == null || child == null)
		{
			return false;
		}
		while (child != null)
		{
			if (child == parent)
			{
				return true;
			}
			child = child.parent;
		}
		return false;
	}

	private static void Activate(Transform t)
	{
		Activate(t, compatibilityMode: false);
	}

	private static void Activate(Transform t, bool compatibilityMode)
	{
		SetActiveSelf(t.gameObject, state: true);
		if (!compatibilityMode)
		{
			return;
		}
		int i = 0;
		for (int childCount = t.childCount; i < childCount; i++)
		{
			Transform child = t.GetChild(i);
			if (child.gameObject.activeSelf)
			{
				return;
			}
		}
		int j = 0;
		for (int childCount2 = t.childCount; j < childCount2; j++)
		{
			Transform child2 = t.GetChild(j);
			Activate(child2, compatibilityMode: true);
		}
	}

	private static void Deactivate(Transform t)
	{
		SetActiveSelf(t.gameObject, state: false);
	}

	public static void SetActive(GameObject go, bool state)
	{
		SetActive(go, state, compatibilityMode: true);
	}

	public static void SetActive(GameObject go, bool state, bool compatibilityMode)
	{
		if ((bool)go)
		{
			if (state)
			{
				Activate(go.transform, compatibilityMode);
				CallCreatePanel(go.transform);
			}
			else
			{
				Deactivate(go.transform);
			}
		}
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	private static void CallCreatePanel(Transform t)
	{
		UIWidget component = t.GetComponent<UIWidget>();
		if (component != null)
		{
			component.CreatePanel();
		}
		int i = 0;
		for (int childCount = t.childCount; i < childCount; i++)
		{
			CallCreatePanel(t.GetChild(i));
		}
	}

	public static void SetActiveChildren(GameObject go, bool state)
	{
		Transform transform = go.transform;
		if (state)
		{
			int i = 0;
			for (int childCount = transform.childCount; i < childCount; i++)
			{
				Transform child = transform.GetChild(i);
				Activate(child);
			}
		}
		else
		{
			int j = 0;
			for (int childCount2 = transform.childCount; j < childCount2; j++)
			{
				Transform child2 = transform.GetChild(j);
				Deactivate(child2);
			}
		}
	}

	[Obsolete("Use NGUITools.GetActive instead")]
	public static bool IsActive(Behaviour mb)
	{
		return mb != null && mb.enabled && mb.gameObject.activeInHierarchy;
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static bool GetActive(Behaviour mb)
	{
		return (bool)mb && mb.enabled && mb.gameObject.activeInHierarchy;
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static bool GetActive(GameObject go)
	{
		return (bool)go && go.activeInHierarchy;
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static void SetActiveSelf(GameObject go, bool state)
	{
		go.SetActive(state);
	}

	public static void SetLayer(GameObject go, int layer)
	{
		go.layer = layer;
		Transform transform = go.transform;
		int i = 0;
		for (int childCount = transform.childCount; i < childCount; i++)
		{
			Transform child = transform.GetChild(i);
			SetLayer(child.gameObject, layer);
		}
	}

	public static Vector3 Round(Vector3 v)
	{
		v.x = Mathf.Round(v.x);
		v.y = Mathf.Round(v.y);
		v.z = Mathf.Round(v.z);
		return v;
	}

	public static void MakePixelPerfect(Transform t)
	{
		UIWidget component = t.GetComponent<UIWidget>();
		if (component != null)
		{
			component.MakePixelPerfect();
		}
		if (t.GetComponent<UIAnchor>() == null && t.GetComponent<UIRoot>() == null)
		{
			t.localPosition = Round(t.localPosition);
			t.localScale = Round(t.localScale);
		}
		int i = 0;
		for (int childCount = t.childCount; i < childCount; i++)
		{
			MakePixelPerfect(t.GetChild(i));
		}
	}

	public static bool Save(string fileName, byte[] bytes)
	{
		if (!fileAccess)
		{
			return false;
		}
		string path = Application.persistentDataPath + "/" + fileName;
		if (bytes == null)
		{
			if (File.Exists(path))
			{
				File.Delete(path);
			}
			return true;
		}
		FileStream fileStream = null;
		try
		{
			fileStream = File.Create(path);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(ex.Message);
			return false;
		}
		fileStream.Write(bytes, 0, bytes.Length);
		fileStream.Close();
		return true;
	}

	public static byte[] Load(string fileName)
	{
		if (!fileAccess)
		{
			return null;
		}
		string path = Application.persistentDataPath + "/" + fileName;
		if (File.Exists(path))
		{
			return File.ReadAllBytes(path);
		}
		return null;
	}

	public static UnityEngine.Color ApplyPMA(UnityEngine.Color c)
	{
		if (c.a != 1f)
		{
			c.r *= c.a;
			c.g *= c.a;
			c.b *= c.a;
		}
		return c;
	}

	public static void MarkParentAsChanged(GameObject go)
	{
		UIRect[] componentsInChildren = go.GetComponentsInChildren<UIRect>();
		int i = 0;
		for (int num = componentsInChildren.Length; i < num; i++)
		{
			componentsInChildren[i].ParentHasChanged();
		}
	}

	[Obsolete("Use NGUIText.EncodeColor instead")]
	public static string EncodeColor(UnityEngine.Color c)
	{
		return NGUIText.EncodeColor24(c);
	}

	[Obsolete("Use NGUIText.ParseColor instead")]
	public static UnityEngine.Color ParseColor(string text, int offset)
	{
		return NGUIText.ParseColor24(text, offset);
	}

	[Obsolete("Use NGUIText.StripSymbols instead")]
	public static string StripSymbols(string text)
	{
		return NGUIText.StripSymbols(text);
	}

	public static T AddMissingComponent<T>(this GameObject go) where T : Component
	{
		T val = go.GetComponent<T>();
		if (val == null)
		{
			val = go.AddComponent<T>();
		}
		return val;
	}

	public static Vector3[] GetSides(this Camera cam)
	{
		return cam.GetSides(Mathf.Lerp(cam.nearClipPlane, cam.farClipPlane, 0.5f), null);
	}

	public static Vector3[] GetSides(this Camera cam, float depth)
	{
		return cam.GetSides(depth, null);
	}

	public static Vector3[] GetSides(this Camera cam, Transform relativeTo)
	{
		return cam.GetSides(Mathf.Lerp(cam.nearClipPlane, cam.farClipPlane, 0.5f), relativeTo);
	}

	public static Vector3[] GetSides(this Camera cam, float depth, Transform relativeTo)
	{
		if (cam.orthographic)
		{
			float orthographicSize = cam.orthographicSize;
			float num = 0f - orthographicSize;
			float num2 = orthographicSize;
			float y = 0f - orthographicSize;
			float y2 = orthographicSize;
			Rect rect = cam.rect;
			Vector2 vector = screenSize;
			float num3 = vector.x / vector.y;
			num3 *= rect.width / rect.height;
			num *= num3;
			num2 *= num3;
			Transform transform = cam.transform;
			Quaternion rotation = transform.rotation;
			Vector3 position = transform.position;
			ref Vector3 reference = ref mSides[0];
			reference = rotation * new Vector3(num, 0f, depth) + position;
			ref Vector3 reference2 = ref mSides[1];
			reference2 = rotation * new Vector3(0f, y2, depth) + position;
			ref Vector3 reference3 = ref mSides[2];
			reference3 = rotation * new Vector3(num2, 0f, depth) + position;
			ref Vector3 reference4 = ref mSides[3];
			reference4 = rotation * new Vector3(0f, y, depth) + position;
		}
		else
		{
			ref Vector3 reference5 = ref mSides[0];
			reference5 = cam.ViewportToWorldPoint(new Vector3(0f, 0.5f, depth));
			ref Vector3 reference6 = ref mSides[1];
			reference6 = cam.ViewportToWorldPoint(new Vector3(0.5f, 1f, depth));
			ref Vector3 reference7 = ref mSides[2];
			reference7 = cam.ViewportToWorldPoint(new Vector3(1f, 0.5f, depth));
			ref Vector3 reference8 = ref mSides[3];
			reference8 = cam.ViewportToWorldPoint(new Vector3(0.5f, 0f, depth));
		}
		if (relativeTo != null)
		{
			for (int i = 0; i < 4; i++)
			{
				ref Vector3 reference9 = ref mSides[i];
				reference9 = relativeTo.InverseTransformPoint(mSides[i]);
			}
		}
		return mSides;
	}

	public static Vector3[] GetWorldCorners(this Camera cam)
	{
		float depth = Mathf.Lerp(cam.nearClipPlane, cam.farClipPlane, 0.5f);
		return cam.GetWorldCorners(depth, null);
	}

	public static Vector3[] GetWorldCorners(this Camera cam, float depth)
	{
		return cam.GetWorldCorners(depth, null);
	}

	public static Vector3[] GetWorldCorners(this Camera cam, Transform relativeTo)
	{
		return cam.GetWorldCorners(Mathf.Lerp(cam.nearClipPlane, cam.farClipPlane, 0.5f), relativeTo);
	}

	public static Vector3[] GetWorldCorners(this Camera cam, float depth, Transform relativeTo)
	{
		if (cam.orthographic)
		{
			float orthographicSize = cam.orthographicSize;
			float num = 0f - orthographicSize;
			float num2 = orthographicSize;
			float y = 0f - orthographicSize;
			float y2 = orthographicSize;
			Rect rect = cam.rect;
			Vector2 vector = screenSize;
			float num3 = vector.x / vector.y;
			num3 *= rect.width / rect.height;
			num *= num3;
			num2 *= num3;
			Transform transform = cam.transform;
			Quaternion rotation = transform.rotation;
			Vector3 position = transform.position;
			ref Vector3 reference = ref mSides[0];
			reference = rotation * new Vector3(num, y, depth) + position;
			ref Vector3 reference2 = ref mSides[1];
			reference2 = rotation * new Vector3(num, y2, depth) + position;
			ref Vector3 reference3 = ref mSides[2];
			reference3 = rotation * new Vector3(num2, y2, depth) + position;
			ref Vector3 reference4 = ref mSides[3];
			reference4 = rotation * new Vector3(num2, y, depth) + position;
		}
		else
		{
			ref Vector3 reference5 = ref mSides[0];
			reference5 = cam.ViewportToWorldPoint(new Vector3(0f, 0f, depth));
			ref Vector3 reference6 = ref mSides[1];
			reference6 = cam.ViewportToWorldPoint(new Vector3(0f, 1f, depth));
			ref Vector3 reference7 = ref mSides[2];
			reference7 = cam.ViewportToWorldPoint(new Vector3(1f, 1f, depth));
			ref Vector3 reference8 = ref mSides[3];
			reference8 = cam.ViewportToWorldPoint(new Vector3(1f, 0f, depth));
		}
		if (relativeTo != null)
		{
			for (int i = 0; i < 4; i++)
			{
				ref Vector3 reference9 = ref mSides[i];
				reference9 = relativeTo.InverseTransformPoint(mSides[i]);
			}
		}
		return mSides;
	}

	public static string GetFuncName(object obj, string method)
	{
		if (obj == null)
		{
			return "<null>";
		}
		string text = obj.GetType().ToString();
		int num = text.LastIndexOf('/');
		if (num > 0)
		{
			text = text.Substring(num + 1);
		}
		return (!string.IsNullOrEmpty(method)) ? (text + "/" + method) : text;
	}

	public static void Execute<T>(GameObject go, string funcName) where T : Component
	{
		T[] components = go.GetComponents<T>();
		T[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			T obj = array[i];
			obj.GetType().GetMethod(funcName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)?.Invoke(obj, null);
		}
	}

	public static void ExecuteAll<T>(GameObject root, string funcName) where T : Component
	{
		Execute<T>(root, funcName);
		Transform transform = root.transform;
		int i = 0;
		for (int childCount = transform.childCount; i < childCount; i++)
		{
			ExecuteAll<T>(transform.GetChild(i).gameObject, funcName);
		}
	}

	public static void ImmediatelyCreateDrawCalls(GameObject root)
	{
		ExecuteAll<UIWidget>(root, "Start");
		ExecuteAll<UIPanel>(root, "Start");
		ExecuteAll<UIWidget>(root, "Update");
		ExecuteAll<UIPanel>(root, "Update");
		ExecuteAll<UIPanel>(root, "LateUpdate");
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/Internal/Property Binding")]
public class PropertyBinding : MonoBehaviour
{
	public enum UpdateCondition
	{
		OnStart,
		OnUpdate,
		OnLateUpdate,
		OnFixedUpdate
	}

	public enum Direction
	{
		SourceUpdatesTarget,
		TargetUpdatesSource,
		BiDirectional
	}

	public PropertyReference source;

	public PropertyReference target;

	public Direction direction;

	public UpdateCondition update = UpdateCondition.OnUpdate;

	public bool editMode = true;

	private object mLastValue;

	private void Start()
	{
		UpdateTarget();
		if (update == UpdateCondition.OnStart)
		{
			base.enabled = false;
		}
	}

	private void Update()
	{
		if (update == UpdateCondition.OnUpdate)
		{
			UpdateTarget();
		}
	}

	private void LateUpdate()
	{
		if (update == UpdateCondition.OnLateUpdate)
		{
			UpdateTarget();
		}
	}

	private void FixedUpdate()
	{
		if (update == UpdateCondition.OnFixedUpdate)
		{
			UpdateTarget();
		}
	}

	private void OnValidate()
	{
		if (source != null)
		{
			source.Reset();
		}
		if (target != null)
		{
			target.Reset();
		}
	}

	[ContextMenu("Update Now")]
	public void UpdateTarget()
	{
		if (source == null || target == null || !source.isValid || !target.isValid)
		{
			return;
		}
		if (direction == Direction.SourceUpdatesTarget)
		{
			target.Set(source.Get());
		}
		else if (direction == Direction.TargetUpdatesSource)
		{
			source.Set(target.Get());
		}
		else
		{
			if (source.GetPropertyType() != target.GetPropertyType())
			{
				return;
			}
			object obj = source.Get();
			if (mLastValue == null || !mLastValue.Equals(obj))
			{
				mLastValue = obj;
				target.Set(obj);
				return;
			}
			obj = target.Get();
			if (!mLastValue.Equals(obj))
			{
				mLastValue = obj;
				source.Set(obj);
			}
		}
	}
}
[Serializable]
public class PropertyReference
{
	[SerializeField]
	private Component mTarget;

	[SerializeField]
	private string mName;

	private FieldInfo mField;

	private PropertyInfo mProperty;

	private static int s_Hash = "PropertyBinding".GetHashCode();

	public Component target
	{
		get
		{
			return mTarget;
		}
		set
		{
			mTarget = value;
			mProperty = null;
			mField = null;
		}
	}

	public string name
	{
		get
		{
			return mName;
		}
		set
		{
			mName = value;
			mProperty = null;
			mField = null;
		}
	}

	public bool isValid => mTarget != null && !string.IsNullOrEmpty(mName);

	public bool isEnabled
	{
		get
		{
			if (mTarget == null)
			{
				return false;
			}
			MonoBehaviour monoBehaviour = mTarget as MonoBehaviour;
			return monoBehaviour == null || monoBehaviour.enabled;
		}
	}

	public PropertyReference()
	{
	}

	public PropertyReference(Component target, string fieldName)
	{
		mTarget = target;
		mName = fieldName;
	}

	public Type GetPropertyType()
	{
		if (mProperty == null && mField == null && isValid)
		{
			Cache();
		}
		if (mProperty != null)
		{
			return mProperty.PropertyType;
		}
		if (mField != null)
		{
			return mField.FieldType;
		}
		return typeof(void);
	}

	public override bool Equals(object obj)
	{
		if (obj == null)
		{
			return !isValid;
		}
		if (obj is PropertyReference)
		{
			PropertyReference propertyReference = obj as PropertyReference;
			return mTarget == propertyReference.mTarget && string.Equals(mName, propertyReference.mName);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return s_Hash;
	}

	public void Set(Component target, string methodName)
	{
		mTarget = target;
		mName = methodName;
	}

	public void Clear()
	{
		mTarget = null;
		mName = null;
	}

	public void Reset()
	{
		mField = null;
		mProperty = null;
	}

	public override string ToString()
	{
		return ToString(mTarget, name);
	}

	public static string ToString(Component comp, string property)
	{
		if (comp != null)
		{
			string text = comp.GetType().ToString();
			int num = text.LastIndexOf('.');
			if (num > 0)
			{
				text = text.Substring(num + 1);
			}
			if (!string.IsNullOrEmpty(property))
			{
				return text + "." + property;
			}
			return text + ".[property]";
		}
		return null;
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public object Get()
	{
		if (mProperty == null && mField == null && isValid)
		{
			Cache();
		}
		if (mProperty != null)
		{
			if (mProperty.CanRead)
			{
				return mProperty.GetValue(mTarget, null);
			}
		}
		else if (mField != null)
		{
			return mField.GetValue(mTarget);
		}
		return null;
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public bool Set(object value)
	{
		if (mProperty == null && mField == null && isValid)
		{
			Cache();
		}
		if (mProperty == null && mField == null)
		{
			return false;
		}
		if (value == null)
		{
			try
			{
				if (mProperty == null)
				{
					mField.SetValue(mTarget, null);
					return true;
				}
				if (mProperty.CanWrite)
				{
					mProperty.SetValue(mTarget, null, null);
					return true;
				}
			}
			catch (Exception)
			{
				return false;
			}
		}
		if (!Convert(ref value))
		{
			if (Application.isPlaying)
			{
				UnityEngine.Debug.LogError(string.Concat("Unable to convert ", value.GetType(), " to ", GetPropertyType()));
			}
		}
		else
		{
			if (mField != null)
			{
				mField.SetValue(mTarget, value);
				return true;
			}
			if (mProperty.CanWrite)
			{
				mProperty.SetValue(mTarget, value, null);
				return true;
			}
		}
		return false;
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	private bool Cache()
	{
		if (mTarget != null && !string.IsNullOrEmpty(mName))
		{
			Type type = mTarget.GetType();
			mField = type.GetField(mName);
			mProperty = type.GetProperty(mName);
		}
		else
		{
			mField = null;
			mProperty = null;
		}
		return mField != null || mProperty != null;
	}

	private bool Convert(ref object value)
	{
		if (mTarget == null)
		{
			return false;
		}
		Type propertyType = GetPropertyType();
		Type from;
		if (value == null)
		{
			if (!propertyType.IsClass)
			{
				return false;
			}
			from = propertyType;
		}
		else
		{
			from = value.GetType();
		}
		return Convert(ref value, from, propertyType);
	}

	public static bool Convert(Type from, Type to)
	{
		object value = null;
		return Convert(ref value, from, to);
	}

	public static bool Convert(object value, Type to)
	{
		if (value == null)
		{
			value = null;
			return Convert(ref value, to, to);
		}
		return Convert(ref value, value.GetType(), to);
	}

	public static bool Convert(ref object value, Type from, Type to)
	{
		if (to.IsAssignableFrom(from))
		{
			return true;
		}
		if (to == typeof(string))
		{
			value = ((value == null) ? "null" : value.ToString());
			return true;
		}
		if (value == null)
		{
			return false;
		}
		float result2;
		if (to == typeof(int))
		{
			if (from == typeof(string))
			{
				if (int.TryParse((string)value, out var result))
				{
					value = result;
					return true;
				}
			}
			else if (from == typeof(float))
			{
				value = Mathf.RoundToInt((float)value);
				return true;
			}
		}
		else if (to == typeof(float) && from == typeof(string) && float.TryParse((string)value, out result2))
		{
			value = result2;
			return true;
		}
		return false;
	}
}
public class RealTime : MonoBehaviour
{
	public static float time => Time.unscaledTime;

	public static float deltaTime => Time.unscaledDeltaTime;
}
[RequireComponent(typeof(UIPanel))]
[AddComponentMenu("NGUI/Internal/Spring Panel")]
public class SpringPanel : MonoBehaviour
{
	public delegate void OnFinished();

	public static SpringPanel current;

	public Vector3 target = Vector3.zero;

	public float strength = 10f;

	public OnFinished onFinished;

	private UIPanel mPanel;

	private Transform mTrans;

	private UIScrollView mDrag;

	private void Start()
	{
		mPanel = GetComponent<UIPanel>();
		mDrag = GetComponent<UIScrollView>();
		mTrans = base.transform;
	}

	private void Update()
	{
		AdvanceTowardsPosition();
	}

	protected virtual void AdvanceTowardsPosition()
	{
		float deltaTime = RealTime.deltaTime;
		bool flag = false;
		Vector3 localPosition = mTrans.localPosition;
		Vector3 vector = NGUIMath.SpringLerp(mTrans.localPosition, target, strength, deltaTime);
		if ((vector - target).sqrMagnitude < 0.01f)
		{
			vector = target;
			base.enabled = false;
			flag = true;
		}
		mTrans.localPosition = vector;
		Vector3 vector2 = vector - localPosition;
		Vector2 clipOffset = mPanel.clipOffset;
		clipOffset.x -= vector2.x;
		clipOffset.y -= vector2.y;
		mPanel.clipOffset = clipOffset;
		if (mDrag != null)
		{
			mDrag.UpdateScrollbars(recalculateBounds: false);
		}
		if (flag && onFinished != null)
		{
			current = this;
			onFinished();
			current = null;
		}
	}

	public static SpringPanel Begin(GameObject go, Vector3 pos, float strength)
	{
		SpringPanel springPanel = go.GetComponent<SpringPanel>();
		if (springPanel == null)
		{
			springPanel = go.AddComponent<SpringPanel>();
		}
		springPanel.target = pos;
		springPanel.strength = strength;
		springPanel.onFinished = null;
		springPanel.enabled = true;
		return springPanel;
	}
}
public abstract class UIBasicSprite : UIWidget
{
	public enum Type
	{
		Simple,
		Sliced,
		Tiled,
		Filled,
		Advanced
	}

	public enum FillDirection
	{
		Horizontal,
		Vertical,
		Radial90,
		Radial180,
		Radial360
	}

	public enum AdvancedType
	{
		Invisible,
		Sliced,
		Tiled
	}

	public enum Flip
	{
		Nothing,
		Horizontally,
		Vertically,
		Both
	}

	[HideInInspector]
	[SerializeField]
	protected Type mType;

	[HideInInspector]
	[SerializeField]
	protected FillDirection mFillDirection = FillDirection.Radial360;

	[Range(0f, 1f)]
	[HideInInspector]
	[SerializeField]
	protected float mFillAmount = 1f;

	[HideInInspector]
	[SerializeField]
	protected bool mInvert;

	[HideInInspector]
	[SerializeField]
	protected Flip mFlip;

	[NonSerialized]
	private Rect mInnerUV = default(Rect);

	[NonSerialized]
	private Rect mOuterUV = default(Rect);

	public AdvancedType centerType = AdvancedType.Sliced;

	public AdvancedType leftType = AdvancedType.Sliced;

	public AdvancedType rightType = AdvancedType.Sliced;

	public AdvancedType bottomType = AdvancedType.Sliced;

	public AdvancedType topType = AdvancedType.Sliced;

	protected static Vector2[] mTempPos = new Vector2[4];

	protected static Vector2[] mTempUVs = new Vector2[4];

	public virtual Type type
	{
		get
		{
			return mType;
		}
		set
		{
			if (mType != value)
			{
				mType = value;
				MarkAsChanged();
			}
		}
	}

	public Flip flip
	{
		get
		{
			return mFlip;
		}
		set
		{
			if (mFlip != value)
			{
				mFlip = value;
				MarkAsChanged();
			}
		}
	}

	public FillDirection fillDirection
	{
		get
		{
			return mFillDirection;
		}
		set
		{
			if (mFillDirection != value)
			{
				mFillDirection = value;
				mChanged = true;
			}
		}
	}

	public float fillAmount
	{
		get
		{
			return mFillAmount;
		}
		set
		{
			float num = Mathf.Clamp01(value);
			if (mFillAmount != num)
			{
				mFillAmount = num;
				mChanged = true;
			}
		}
	}

	public override int minWidth
	{
		get
		{
			if (type == Type.Sliced || type == Type.Advanced)
			{
				Vector4 vector = border * pixelSize;
				int num = Mathf.RoundToInt(vector.x + vector.z);
				return Mathf.Max(base.minWidth, ((num & 1) != 1) ? num : (num + 1));
			}
			return base.minWidth;
		}
	}

	public override int minHeight
	{
		get
		{
			if (type == Type.Sliced || type == Type.Advanced)
			{
				Vector4 vector = border * pixelSize;
				int num = Mathf.RoundToInt(vector.y + vector.w);
				return Mathf.Max(base.minHeight, ((num & 1) != 1) ? num : (num + 1));
			}
			return base.minHeight;
		}
	}

	public bool invert
	{
		get
		{
			return mInvert;
		}
		set
		{
			if (mInvert != value)
			{
				mInvert = value;
				mChanged = true;
			}
		}
	}

	public bool hasBorder
	{
		get
		{
			Vector4 vector = border;
			return vector.x != 0f || vector.y != 0f || vector.z != 0f || vector.w != 0f;
		}
	}

	public virtual bool premultipliedAlpha => false;

	public virtual float pixelSize => 1f;

	private Vector4 drawingUVs => mFlip switch
	{
		Flip.Horizontally => new Vector4(mOuterUV.xMax, mOuterUV.yMin, mOuterUV.xMin, mOuterUV.yMax), 
		Flip.Vertically => new Vector4(mOuterUV.xMin, mOuterUV.yMax, mOuterUV.xMax, mOuterUV.yMin), 
		Flip.Both => new Vector4(mOuterUV.xMax, mOuterUV.yMax, mOuterUV.xMin, mOuterUV.yMin), 
		_ => new Vector4(mOuterUV.xMin, mOuterUV.yMin, mOuterUV.xMax, mOuterUV.yMax), 
	};

	private Color32 drawingColor
	{
		get
		{
			UnityEngine.Color color = base.color;
			color.a = finalAlpha;
			if (premultipliedAlpha)
			{
				color = NGUITools.ApplyPMA(color);
			}
			if (QualitySettings.activeColorSpace == ColorSpace.Linear)
			{
				color.r = Mathf.Pow(color.r, 2.2f);
				color.g = Mathf.Pow(color.g, 2.2f);
				color.b = Mathf.Pow(color.b, 2.2f);
			}
			return color;
		}
	}

	protected void Fill(BetterList<Vector3> verts, BetterList<Vector2> uvs, BetterList<Color32> cols, Rect outer, Rect inner)
	{
		mOuterUV = outer;
		mInnerUV = inner;
		switch (type)
		{
		case Type.Simple:
			SimpleFill(verts, uvs, cols);
			break;
		case Type.Sliced:
			SlicedFill(verts, uvs, cols);
			break;
		case Type.Filled:
			FilledFill(verts, uvs, cols);
			break;
		case Type.Tiled:
			TiledFill(verts, uvs, cols);
			break;
		case Type.Advanced:
			AdvancedFill(verts, uvs, cols);
			break;
		}
	}

	private void SimpleFill(BetterList<Vector3> verts, BetterList<Vector2> uvs, BetterList<Color32> cols)
	{
		Vector4 vector = drawingDimensions;
		Vector4 vector2 = drawingUVs;
		Color32 item = drawingColor;
		verts.Add(new Vector3(vector.x, vector.y));
		verts.Add(new Vector3(vector.x, vector.w));
		verts.Add(new Vector3(vector.z, vector.w));
		verts.Add(new Vector3(vector.z, vector.y));
		uvs.Add(new Vector2(vector2.x, vector2.y));
		uvs.Add(new Vector2(vector2.x, vector2.w));
		uvs.Add(new Vector2(vector2.z, vector2.w));
		uvs.Add(new Vector2(vector2.z, vector2.y));
		cols.Add(item);
		cols.Add(item);
		cols.Add(item);
		cols.Add(item);
	}

	private void SlicedFill(BetterList<Vector3> verts, BetterList<Vector2> uvs, BetterList<Color32> cols)
	{
		Vector4 vector = border * pixelSize;
		if (vector.x == 0f && vector.y == 0f && vector.z == 0f && vector.w == 0f)
		{
			SimpleFill(verts, uvs, cols);
			return;
		}
		Color32 item = drawingColor;
		Vector4 vector2 = drawingDimensions;
		mTempPos[0].x = vector2.x;
		mTempPos[0].y = vector2.y;
		mTempPos[3].x = vector2.z;
		mTempPos[3].y = vector2.w;
		if (mFlip == Flip.Horizontally || mFlip == Flip.Both)
		{
			mTempPos[1].x = mTempPos[0].x + vector.z;
			mTempPos[2].x = mTempPos[3].x - vector.x;
			mTempUVs[3].x = mOuterUV.xMin;
			mTempUVs[2].x = mInnerUV.xMin;
			mTempUVs[1].x = mInnerUV.xMax;
			mTempUVs[0].x = mOuterUV.xMax;
		}
		else
		{
			mTempPos[1].x = mTempPos[0].x + vector.x;
			mTempPos[2].x = mTempPos[3].x - vector.z;
			mTempUVs[0].x = mOuterUV.xMin;
			mTempUVs[1].x = mInnerUV.xMin;
			mTempUVs[2].x = mInnerUV.xMax;
			mTempUVs[3].x = mOuterUV.xMax;
		}
		if (mFlip == Flip.Vertically || mFlip == Flip.Both)
		{
			mTempPos[1].y = mTempPos[0].y + vector.w;
			mTempPos[2].y = mTempPos[3].y - vector.y;
			mTempUVs[3].y = mOuterUV.yMin;
			mTempUVs[2].y = mInnerUV.yMin;
			mTempUVs[1].y = mInnerUV.yMax;
			mTempUVs[0].y = mOuterUV.yMax;
		}
		else
		{
			mTempPos[1].y = mTempPos[0].y + vector.y;
			mTempPos[2].y = mTempPos[3].y - vector.w;
			mTempUVs[0].y = mOuterUV.yMin;
			mTempUVs[1].y = mInnerUV.yMin;
			mTempUVs[2].y = mInnerUV.yMax;
			mTempUVs[3].y = mOuterUV.yMax;
		}
		for (int i = 0; i < 3; i++)
		{
			int num = i + 1;
			for (int j = 0; j < 3; j++)
			{
				if (centerType != 0 || i != 1 || j != 1)
				{
					int num2 = j + 1;
					verts.Add(new Vector3(mTempPos[i].x, mTempPos[j].y));
					verts.Add(new Vector3(mTempPos[i].x, mTempPos[num2].y));
					verts.Add(new Vector3(mTempPos[num].x, mTempPos[num2].y));
					verts.Add(new Vector3(mTempPos[num].x, mTempPos[j].y));
					uvs.Add(new Vector2(mTempUVs[i].x, mTempUVs[j].y));
					uvs.Add(new Vector2(mTempUVs[i].x, mTempUVs[num2].y));
					uvs.Add(new Vector2(mTempUVs[num].x, mTempUVs[num2].y));
					uvs.Add(new Vector2(mTempUVs[num].x, mTempUVs[j].y));
					cols.Add(item);
					cols.Add(item);
					cols.Add(item);
					cols.Add(item);
				}
			}
		}
	}

	private void TiledFill(BetterList<Vector3> verts, BetterList<Vector2> uvs, BetterList<Color32> cols)
	{
		Texture texture = mainTexture;
		if (texture == null)
		{
			return;
		}
		Vector2 vector = new Vector2(mInnerUV.width * (float)texture.width, mInnerUV.height * (float)texture.height);
		vector *= pixelSize;
		if (texture == null || vector.x < 2f || vector.y < 2f)
		{
			return;
		}
		Color32 item = drawingColor;
		Vector4 vector2 = drawingDimensions;
		Vector4 vector3 = default(Vector4);
		if (mFlip == Flip.Horizontally || mFlip == Flip.Both)
		{
			vector3.x = mInnerUV.xMax;
			vector3.z = mInnerUV.xMin;
		}
		else
		{
			vector3.x = mInnerUV.xMin;
			vector3.z = mInnerUV.xMax;
		}
		if (mFlip == Flip.Vertically || mFlip == Flip.Both)
		{
			vector3.y = mInnerUV.yMax;
			vector3.w = mInnerUV.yMin;
		}
		else
		{
			vector3.y = mInnerUV.yMin;
			vector3.w = mInnerUV.yMax;
		}
		float x = vector2.x;
		float num = vector2.y;
		float x2 = vector3.x;
		float y = vector3.y;
		for (; num < vector2.w; num += vector.y)
		{
			x = vector2.x;
			float num2 = num + vector.y;
			float y2 = vector3.w;
			if (num2 > vector2.w)
			{
				y2 = Mathf.Lerp(vector3.y, vector3.w, (vector2.w - num) / vector.y);
				num2 = vector2.w;
			}
			for (; x < vector2.z; x += vector.x)
			{
				float num3 = x + vector.x;
				float x3 = vector3.z;
				if (num3 > vector2.z)
				{
					x3 = Mathf.Lerp(vector3.x, vector3.z, (vector2.z - x) / vector.x);
					num3 = vector2.z;
				}
				verts.Add(new Vector3(x, num));
				verts.Add(new Vector3(x, num2));
				verts.Add(new Vector3(num3, num2));
				verts.Add(new Vector3(num3, num));
				uvs.Add(new Vector2(x2, y));
				uvs.Add(new Vector2(x2, y2));
				uvs.Add(new Vector2(x3, y2));
				uvs.Add(new Vector2(x3, y));
				cols.Add(item);
				cols.Add(item);
				cols.Add(item);
				cols.Add(item);
			}
		}
	}

	private void FilledFill(BetterList<Vector3> verts, BetterList<Vector2> uvs, BetterList<Color32> cols)
	{
		if (mFillAmount < 0.001f)
		{
			return;
		}
		Vector4 vector = drawingDimensions;
		Vector4 vector2 = drawingUVs;
		Color32 item = drawingColor;
		if (mFillDirection == FillDirection.Horizontal || mFillDirection == FillDirection.Vertical)
		{
			if (mFillDirection == FillDirection.Horizontal)
			{
				float num = (vector2.z - vector2.x) * mFillAmount;
				if (mInvert)
				{
					vector.x = vector.z - (vector.z - vector.x) * mFillAmount;
					vector2.x = vector2.z - num;
				}
				else
				{
					vector.z = vector.x + (vector.z - vector.x) * mFillAmount;
					vector2.z = vector2.x + num;
				}
			}
			else if (mFillDirection == FillDirection.Vertical)
			{
				float num2 = (vector2.w - vector2.y) * mFillAmount;
				if (mInvert)
				{
					vector.y = vector.w - (vector.w - vector.y) * mFillAmount;
					vector2.y = vector2.w - num2;
				}
				else
				{
					vector.w = vector.y + (vector.w - vector.y) * mFillAmount;
					vector2.w = vector2.y + num2;
				}
			}
		}
		ref Vector2 reference = ref mTempPos[0];
		reference = new Vector2(vector.x, vector.y);
		ref Vector2 reference2 = ref mTempPos[1];
		reference2 = new Vector2(vector.x, vector.w);
		ref Vector2 reference3 = ref mTempPos[2];
		reference3 = new Vector2(vector.z, vector.w);
		ref Vector2 reference4 = ref mTempPos[3];
		reference4 = new Vector2(vector.z, vector.y);
		ref Vector2 reference5 = ref mTempUVs[0];
		reference5 = new Vector2(vector2.x, vector2.y);
		ref Vector2 reference6 = ref mTempUVs[1];
		reference6 = new Vector2(vector2.x, vector2.w);
		ref Vector2 reference7 = ref mTempUVs[2];
		reference7 = new Vector2(vector2.z, vector2.w);
		ref Vector2 reference8 = ref mTempUVs[3];
		reference8 = new Vector2(vector2.z, vector2.y);
		if (mFillAmount < 1f)
		{
			if (mFillDirection == FillDirection.Radial90)
			{
				if (RadialCut(mTempPos, mTempUVs, mFillAmount, mInvert, 0))
				{
					for (int i = 0; i < 4; i++)
					{
						verts.Add(mTempPos[i]);
						uvs.Add(mTempUVs[i]);
						cols.Add(item);
					}
				}
				return;
			}
			if (mFillDirection == FillDirection.Radial180)
			{
				for (int j = 0; j < 2; j++)
				{
					float t = 0f;
					float t2 = 1f;
					float t3;
					float t4;
					if (j == 0)
					{
						t3 = 0f;
						t4 = 0.5f;
					}
					else
					{
						t3 = 0.5f;
						t4 = 1f;
					}
					mTempPos[0].x = Mathf.Lerp(vector.x, vector.z, t3);
					mTempPos[1].x = mTempPos[0].x;
					mTempPos[2].x = Mathf.Lerp(vector.x, vector.z, t4);
					mTempPos[3].x = mTempPos[2].x;
					mTempPos[0].y = Mathf.Lerp(vector.y, vector.w, t);
					mTempPos[1].y = Mathf.Lerp(vector.y, vector.w, t2);
					mTempPos[2].y = mTempPos[1].y;
					mTempPos[3].y = mTempPos[0].y;
					mTempUVs[0].x = Mathf.Lerp(vector2.x, vector2.z, t3);
					mTempUVs[1].x = mTempUVs[0].x;
					mTempUVs[2].x = Mathf.Lerp(vector2.x, vector2.z, t4);
					mTempUVs[3].x = mTempUVs[2].x;
					mTempUVs[0].y = Mathf.Lerp(vector2.y, vector2.w, t);
					mTempUVs[1].y = Mathf.Lerp(vector2.y, vector2.w, t2);
					mTempUVs[2].y = mTempUVs[1].y;
					mTempUVs[3].y = mTempUVs[0].y;
					float value = (mInvert ? (mFillAmount * 2f - (float)(1 - j)) : (fillAmount * 2f - (float)j));
					if (RadialCut(mTempPos, mTempUVs, Mathf.Clamp01(value), !mInvert, NGUIMath.RepeatIndex(j + 3, 4)))
					{
						for (int k = 0; k < 4; k++)
						{
							verts.Add(mTempPos[k]);
							uvs.Add(mTempUVs[k]);
							cols.Add(item);
						}
					}
				}
				return;
			}
			if (mFillDirection == FillDirection.Radial360)
			{
				for (int l = 0; l < 4; l++)
				{
					float t5;
					float t6;
					if (l < 2)
					{
						t5 = 0f;
						t6 = 0.5f;
					}
					else
					{
						t5 = 0.5f;
						t6 = 1f;
					}
					float t7;
					float t8;
					if (l == 0 || l == 3)
					{
						t7 = 0f;
						t8 = 0.5f;
					}
					else
					{
						t7 = 0.5f;
						t8 = 1f;
					}
					mTempPos[0].x = Mathf.Lerp(vector.x, vector.z, t5);
					mTempPos[1].x = mTempPos[0].x;
					mTempPos[2].x = Mathf.Lerp(vector.x, vector.z, t6);
					mTempPos[3].x = mTempPos[2].x;
					mTempPos[0].y = Mathf.Lerp(vector.y, vector.w, t7);
					mTempPos[1].y = Mathf.Lerp(vector.y, vector.w, t8);
					mTempPos[2].y = mTempPos[1].y;
					mTempPos[3].y = mTempPos[0].y;
					mTempUVs[0].x = Mathf.Lerp(vector2.x, vector2.z, t5);
					mTempUVs[1].x = mTempUVs[0].x;
					mTempUVs[2].x = Mathf.Lerp(vector2.x, vector2.z, t6);
					mTempUVs[3].x = mTempUVs[2].x;
					mTempUVs[0].y = Mathf.Lerp(vector2.y, vector2.w, t7);
					mTempUVs[1].y = Mathf.Lerp(vector2.y, vector2.w, t8);
					mTempUVs[2].y = mTempUVs[1].y;
					mTempUVs[3].y = mTempUVs[0].y;
					float value2 = ((!mInvert) ? (mFillAmount * 4f - (float)(3 - NGUIMath.RepeatIndex(l + 2, 4))) : (mFillAmount * 4f - (float)NGUIMath.RepeatIndex(l + 2, 4)));
					if (RadialCut(mTempPos, mTempUVs, Mathf.Clamp01(value2), mInvert, NGUIMath.RepeatIndex(l + 2, 4)))
					{
						for (int m = 0; m < 4; m++)
						{
							verts.Add(mTempPos[m]);
							uvs.Add(mTempUVs[m]);
							cols.Add(item);
						}
					}
				}
				return;
			}
		}
		for (int n = 0; n < 4; n++)
		{
			verts.Add(mTempPos[n]);
			uvs.Add(mTempUVs[n]);
			cols.Add(item);
		}
	}

	private void AdvancedFill(BetterList<Vector3> verts, BetterList<Vector2> uvs, BetterList<Color32> cols)
	{
		Texture texture = mainTexture;
		if (texture == null)
		{
			return;
		}
		Vector4 vector = border * pixelSize;
		if (vector.x == 0f && vector.y == 0f && vector.z == 0f && vector.w == 0f)
		{
			SimpleFill(verts, uvs, cols);
			return;
		}
		Color32 color = drawingColor;
		Vector4 vector2 = drawingDimensions;
		Vector2 vector3 = new Vector2(mInnerUV.width * (float)texture.width, mInnerUV.height * (float)texture.height);
		vector3 *= pixelSize;
		if (vector3.x < 1f)
		{
			vector3.x = 1f;
		}
		if (vector3.y < 1f)
		{
			vector3.y = 1f;
		}
		mTempPos[0].x = vector2.x;
		mTempPos[0].y = vector2.y;
		mTempPos[3].x = vector2.z;
		mTempPos[3].y = vector2.w;
		if (mFlip == Flip.Horizontally || mFlip == Flip.Both)
		{
			mTempPos[1].x = mTempPos[0].x + vector.z;
			mTempPos[2].x = mTempPos[3].x - vector.x;
			mTempUVs[3].x = mOuterUV.xMin;
			mTempUVs[2].x = mInnerUV.xMin;
			mTempUVs[1].x = mInnerUV.xMax;
			mTempUVs[0].x = mOuterUV.xMax;
		}
		else
		{
			mTempPos[1].x = mTempPos[0].x + vector.x;
			mTempPos[2].x = mTempPos[3].x - vector.z;
			mTempUVs[0].x = mOuterUV.xMin;
			mTempUVs[1].x = mInnerUV.xMin;
			mTempUVs[2].x = mInnerUV.xMax;
			mTempUVs[3].x = mOuterUV.xMax;
		}
		if (mFlip == Flip.Vertically || mFlip == Flip.Both)
		{
			mTempPos[1].y = mTempPos[0].y + vector.w;
			mTempPos[2].y = mTempPos[3].y - vector.y;
			mTempUVs[3].y = mOuterUV.yMin;
			mTempUVs[2].y = mInnerUV.yMin;
			mTempUVs[1].y = mInnerUV.yMax;
			mTempUVs[0].y = mOuterUV.yMax;
		}
		else
		{
			mTempPos[1].y = mTempPos[0].y + vector.y;
			mTempPos[2].y = mTempPos[3].y - vector.w;
			mTempUVs[0].y = mOuterUV.yMin;
			mTempUVs[1].y = mInnerUV.yMin;
			mTempUVs[2].y = mInnerUV.yMax;
			mTempUVs[3].y = mOuterUV.yMax;
		}
		for (int i = 0; i < 3; i++)
		{
			int num = i + 1;
			for (int j = 0; j < 3; j++)
			{
				if (centerType == AdvancedType.Invisible && i == 1 && j == 1)
				{
					continue;
				}
				int num2 = j + 1;
				if (i == 1 && j == 1)
				{
					if (centerType == AdvancedType.Tiled)
					{
						float x = mTempPos[i].x;
						float x2 = mTempPos[num].x;
						float y = mTempPos[j].y;
						float y2 = mTempPos[num2].y;
						float x3 = mTempUVs[i].x;
						float y3 = mTempUVs[j].y;
						for (float num3 = y; num3 < y2; num3 += vector3.y)
						{
							float num4 = x;
							float num5 = mTempUVs[num2].y;
							float num6 = num3 + vector3.y;
							if (num6 > y2)
							{
								num5 = Mathf.Lerp(y3, num5, (y2 - num3) / vector3.y);
								num6 = y2;
							}
							for (; num4 < x2; num4 += vector3.x)
							{
								float num7 = num4 + vector3.x;
								float num8 = mTempUVs[num].x;
								if (num7 > x2)
								{
									num8 = Mathf.Lerp(x3, num8, (x2 - num4) / vector3.x);
									num7 = x2;
								}
								Fill(verts, uvs, cols, num4, num7, num3, num6, x3, num8, y3, num5, color);
							}
						}
					}
					else if (centerType == AdvancedType.Sliced)
					{
						Fill(verts, uvs, cols, mTempPos[i].x, mTempPos[num].x, mTempPos[j].y, mTempPos[num2].y, mTempUVs[i].x, mTempUVs[num].x, mTempUVs[j].y, mTempUVs[num2].y, color);
					}
				}
				else if (i == 1)
				{
					if ((j == 0 && bottomType == AdvancedType.Tiled) || (j == 2 && topType == AdvancedType.Tiled))
					{
						float x4 = mTempPos[i].x;
						float x5 = mTempPos[num].x;
						float y4 = mTempPos[j].y;
						float y5 = mTempPos[num2].y;
						float x6 = mTempUVs[i].x;
						float y6 = mTempUVs[j].y;
						float y7 = mTempUVs[num2].y;
						for (float num9 = x4; num9 < x5; num9 += vector3.x)
						{
							float num10 = num9 + vector3.x;
							float num11 = mTempUVs[num].x;
							if (num10 > x5)
							{
								num11 = Mathf.Lerp(x6, num11, (x5 - num9) / vector3.x);
								num10 = x5;
							}
							Fill(verts, uvs, cols, num9, num10, y4, y5, x6, num11, y6, y7, color);
						}
					}
					else if ((j == 0 && bottomType == AdvancedType.Sliced) || (j == 2 && topType == AdvancedType.Sliced))
					{
						Fill(verts, uvs, cols, mTempPos[i].x, mTempPos[num].x, mTempPos[j].y, mTempPos[num2].y, mTempUVs[i].x, mTempUVs[num].x, mTempUVs[j].y, mTempUVs[num2].y, color);
					}
				}
				else if (j == 1)
				{
					if ((i == 0 && leftType == AdvancedType.Tiled) || (i == 2 && rightType == AdvancedType.Tiled))
					{
						float x7 = mTempPos[i].x;
						float x8 = mTempPos[num].x;
						float y8 = mTempPos[j].y;
						float y9 = mTempPos[num2].y;
						float x9 = mTempUVs[i].x;
						float x10 = mTempUVs[num].x;
						float y10 = mTempUVs[j].y;
						for (float num12 = y8; num12 < y9; num12 += vector3.y)
						{
							float num13 = mTempUVs[num2].y;
							float num14 = num12 + vector3.y;
							if (num14 > y9)
							{
								num13 = Mathf.Lerp(y10, num13, (y9 - num12) / vector3.y);
								num14 = y9;
							}
							Fill(verts, uvs, cols, x7, x8, num12, num14, x9, x10, y10, num13, color);
						}
					}
					else if ((i == 0 && leftType == AdvancedType.Sliced) || (i == 2 && rightType == AdvancedType.Sliced))
					{
						Fill(verts, uvs, cols, mTempPos[i].x, mTempPos[num].x, mTempPos[j].y, mTempPos[num2].y, mTempUVs[i].x, mTempUVs[num].x, mTempUVs[j].y, mTempUVs[num2].y, color);
					}
				}
				else
				{
					Fill(verts, uvs, cols, mTempPos[i].x, mTempPos[num].x, mTempPos[j].y, mTempPos[num2].y, mTempUVs[i].x, mTempUVs[num].x, mTempUVs[j].y, mTempUVs[num2].y, color);
				}
			}
		}
	}

	private static bool RadialCut(Vector2[] xy, Vector2[] uv, float fill, bool invert, int corner)
	{
		if (fill < 0.001f)
		{
			return false;
		}
		if ((corner & 1) == 1)
		{
			invert = !invert;
		}
		if (!invert && fill > 0.999f)
		{
			return true;
		}
		float num = Mathf.Clamp01(fill);
		if (invert)
		{
			num = 1f - num;
		}
		num *= (float)Math.PI / 2f;
		float cos = Mathf.Cos(num);
		float sin = Mathf.Sin(num);
		RadialCut(xy, cos, sin, invert, corner);
		RadialCut(uv, cos, sin, invert, corner);
		return true;
	}

	private static void RadialCut(Vector2[] xy, float cos, float sin, bool invert, int corner)
	{
		int num = NGUIMath.RepeatIndex(corner + 1, 4);
		int num2 = NGUIMath.RepeatIndex(corner + 2, 4);
		int num3 = NGUIMath.RepeatIndex(corner + 3, 4);
		if ((corner & 1) == 1)
		{
			if (sin > cos)
			{
				cos /= sin;
				sin = 1f;
				if (invert)
				{
					xy[num].x = Mathf.Lerp(xy[corner].x, xy[num2].x, cos);
					xy[num2].x = xy[num].x;
				}
			}
			else if (cos > sin)
			{
				sin /= cos;
				cos = 1f;
				if (!invert)
				{
					xy[num2].y = Mathf.Lerp(xy[corner].y, xy[num2].y, sin);
					xy[num3].y = xy[num2].y;
				}
			}
			else
			{
				cos = 1f;
				sin = 1f;
			}
			if (!invert)
			{
				xy[num3].x = Mathf.Lerp(xy[corner].x, xy[num2].x, cos);
			}
			else
			{
				xy[num].y = Mathf.Lerp(xy[corner].y, xy[num2].y, sin);
			}
			return;
		}
		if (cos > sin)
		{
			sin /= cos;
			cos = 1f;
			if (!invert)
			{
				xy[num].y = Mathf.Lerp(xy[corner].y, xy[num2].y, sin);
				xy[num2].y = xy[num].y;
			}
		}
		else if (sin > cos)
		{
			cos /= sin;
			sin = 1f;
			if (invert)
			{
				xy[num2].x = Mathf.Lerp(xy[corner].x, xy[num2].x, cos);
				xy[num3].x = xy[num2].x;
			}
		}
		else
		{
			cos = 1f;
			sin = 1f;
		}
		if (invert)
		{
			xy[num3].y = Mathf.Lerp(xy[corner].y, xy[num2].y, sin);
		}
		else
		{
			xy[num].x = Mathf.Lerp(xy[corner].x, xy[num2].x, cos);
		}
	}

	private static void Fill(BetterList<Vector3> verts, BetterList<Vector2> uvs, BetterList<Color32> cols, float v0x, float v1x, float v0y, float v1y, float u0x, float u1x, float u0y, float u1y, UnityEngine.Color col)
	{
		verts.Add(new Vector3(v0x, v0y));
		verts.Add(new Vector3(v0x, v1y));
		verts.Add(new Vector3(v1x, v1y));
		verts.Add(new Vector3(v1x, v0y));
		uvs.Add(new Vector2(u0x, u0y));
		uvs.Add(new Vector2(u0x, u1y));
		uvs.Add(new Vector2(u1x, u1y));
		uvs.Add(new Vector2(u1x, u0y));
		cols.Add(col);
		cols.Add(col);
		cols.Add(col);
		cols.Add(col);
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/Internal/Draw Call")]
public class UIDrawCall : MonoBehaviour
{
	public enum Clipping
	{
		None = 0,
		TextureMask = 1,
		SoftClip = 3,
		ConstrainButDontClip = 4
	}

	public delegate void OnRenderCallback(Material mat);

	private static BetterList<UIDrawCall> mActiveList = new BetterList<UIDrawCall>();

	private static BetterList<UIDrawCall> mInactiveList = new BetterList<UIDrawCall>();

	[NonSerialized]
	[HideInInspector]
	public int widgetCount;

	[NonSerialized]
	[HideInInspector]
	public int depthStart = int.MaxValue;

	[NonSerialized]
	[HideInInspector]
	public int depthEnd = int.MinValue;

	[NonSerialized]
	[HideInInspector]
	public UIPanel manager;

	[NonSerialized]
	[HideInInspector]
	public UIPanel panel;

	[NonSerialized]
	[HideInInspector]
	public Texture2D clipTexture;

	[NonSerialized]
	[HideInInspector]
	public bool alwaysOnScreen;

	[NonSerialized]
	[HideInInspector]
	public BetterList<Vector3> verts = new BetterList<Vector3>();

	[NonSerialized]
	[HideInInspector]
	public BetterList<Vector3> norms = new BetterList<Vector3>();

	[NonSerialized]
	[HideInInspector]
	public BetterList<Vector4> tans = new BetterList<Vector4>();

	[NonSerialized]
	[HideInInspector]
	public BetterList<Vector2> uvs = new BetterList<Vector2>();

	[NonSerialized]
	[HideInInspector]
	public BetterList<Color32> cols = new BetterList<Color32>();

	private Material mMaterial;

	private Texture mTexture;

	private Shader mShader;

	private int mClipCount;

	private Transform mTrans;

	private Mesh mMesh;

	private MeshFilter mFilter;

	private MeshRenderer mRenderer;

	private Material mDynamicMat;

	private int[] mIndices;

	private bool mRebuildMat = true;

	private bool mLegacyShader;

	private int mRenderQueue = 3000;

	private int mTriangles;

	[NonSerialized]
	public bool isDirty;

	[NonSerialized]
	private bool mTextureClip;

	public OnRenderCallback onRender;

	private const int maxIndexBufferCache = 10;

	private static List<int[]> mCache = new List<int[]>(10);

	private static int[] ClipRange = new int[4]
	{
		Shader.PropertyToID("_ClipRange0"),
		Shader.PropertyToID("_ClipRange1"),
		Shader.PropertyToID("_ClipRange2"),
		Shader.PropertyToID("_ClipRange4")
	};

	private static int[] ClipArgs = new int[4]
	{
		Shader.PropertyToID("_ClipArgs0"),
		Shader.PropertyToID("_ClipArgs1"),
		Shader.PropertyToID("_ClipArgs2"),
		Shader.PropertyToID("_ClipArgs3")
	};

	[Obsolete("Use UIDrawCall.activeList")]
	public static BetterList<UIDrawCall> list => mActiveList;

	public static BetterList<UIDrawCall> activeList => mActiveList;

	public static BetterList<UIDrawCall> inactiveList => mInactiveList;

	public int renderQueue
	{
		get
		{
			return mRenderQueue;
		}
		set
		{
			if (mRenderQueue != value)
			{
				mRenderQueue = value;
				if (mDynamicMat != null)
				{
					mDynamicMat.renderQueue = value;
				}
			}
		}
	}

	public int sortingOrder
	{
		get
		{
			return (mRenderer != null) ? mRenderer.sortingOrder : 0;
		}
		set
		{
			if (mRenderer != null && mRenderer.sortingOrder != value)
			{
				mRenderer.sortingOrder = value;
			}
		}
	}

	public int finalRenderQueue => (!(mDynamicMat != null)) ? mRenderQueue : mDynamicMat.renderQueue;

	public Transform cachedTransform
	{
		get
		{
			if (mTrans == null)
			{
				mTrans = base.transform;
			}
			return mTrans;
		}
	}

	public Material baseMaterial
	{
		get
		{
			return mMaterial;
		}
		set
		{
			if (mMaterial != value)
			{
				mMaterial = value;
				mRebuildMat = true;
			}
		}
	}

	public Material dynamicMaterial => mDynamicMat;

	public Texture mainTexture
	{
		get
		{
			return mTexture;
		}
		set
		{
			mTexture = value;
			if (mDynamicMat != null)
			{
				mDynamicMat.mainTexture = value;
			}
		}
	}

	public Shader shader
	{
		get
		{
			return mShader;
		}
		set
		{
			if (mShader != value)
			{
				mShader = value;
				mRebuildMat = true;
			}
		}
	}

	public int triangles => (mMesh != null) ? mTriangles : 0;

	public bool isClipped => mClipCount != 0;

	private void CreateMaterial()
	{
		mTextureClip = false;
		mLegacyShader = false;
		mClipCount = panel.clipCount;
		string text = ((mShader != null) ? mShader.name : ((!(mMaterial != null)) ? "Unlit/Transparent Colored" : mMaterial.shader.name));
		text = text.Replace("GUI/Text Shader", "Unlit/Text");
		if (text.Length > 2 && text[text.Length - 2] == ' ')
		{
			int num = text[text.Length - 1];
			if (num > 48 && num <= 57)
			{
				text = text.Substring(0, text.Length - 2);
			}
		}
		if (text.StartsWith("Hidden/"))
		{
			text = text.Substring(7);
		}
		text = text.Replace(" (SoftClip)", string.Empty);
		text = text.Replace(" (TextureClip)", string.Empty);
		if (panel.clipping == Clipping.TextureMask)
		{
			mTextureClip = true;
			shader = Shader.Find("Hidden/" + text + " (TextureClip)");
		}
		else if (mClipCount != 0)
		{
			shader = Shader.Find("Hidden/" + text + " " + mClipCount);
			if (shader == null)
			{
				shader = Shader.Find(text + " " + mClipCount);
			}
			if (shader == null && mClipCount == 1)
			{
				mLegacyShader = true;
				shader = Shader.Find(text + " (SoftClip)");
			}
		}
		else
		{
			shader = Shader.Find(text);
		}
		if (mMaterial != null)
		{
			mDynamicMat = new Material(mMaterial);
			mDynamicMat.name = "[NGUI] " + mMaterial.name;
			mDynamicMat.hideFlags = HideFlags.DontSave | HideFlags.NotEditable;
			mDynamicMat.CopyPropertiesFromMaterial(mMaterial);
			string[] shaderKeywords = mMaterial.shaderKeywords;
			for (int i = 0; i < shaderKeywords.Length; i++)
			{
				mDynamicMat.EnableKeyword(shaderKeywords[i]);
			}
			if (shader != null)
			{
				mDynamicMat.shader = shader;
			}
			else if (mClipCount != 0)
			{
				UnityEngine.Debug.LogError(text + " shader doesn't have a clipped shader version for " + mClipCount + " clip regions");
			}
		}
		else
		{
			mDynamicMat = new Material(shader);
			mDynamicMat.name = "[NGUI] " + shader.name;
			mDynamicMat.hideFlags = HideFlags.DontSave | HideFlags.NotEditable;
		}
	}

	private Material RebuildMaterial()
	{
		NGUITools.DestroyImmediate(mDynamicMat);
		CreateMaterial();
		mDynamicMat.renderQueue = mRenderQueue;
		if (mTexture != null)
		{
			mDynamicMat.mainTexture = mTexture;
		}
		if (mRenderer != null)
		{
			mRenderer.sharedMaterials = new Material[1] { mDynamicMat };
		}
		return mDynamicMat;
	}

	private void UpdateMaterials()
	{
		if (mRebuildMat || mDynamicMat == null || mClipCount != panel.clipCount || mTextureClip != (panel.clipping == Clipping.TextureMask))
		{
			RebuildMaterial();
			mRebuildMat = false;
		}
		else if (mRenderer.sharedMaterial != mDynamicMat)
		{
			mRenderer.sharedMaterials = new Material[1] { mDynamicMat };
		}
	}

	public void UpdateGeometry(int widgetCount)
	{
		this.widgetCount = widgetCount;
		int size = verts.size;
		if (size > 0 && size == uvs.size && size == cols.size && size % 4 == 0)
		{
			if (mFilter == null)
			{
				mFilter = base.gameObject.GetComponent<MeshFilter>();
			}
			if (mFilter == null)
			{
				mFilter = base.gameObject.AddComponent<MeshFilter>();
			}
			if (verts.size < 65000)
			{
				int num = (size >> 1) * 3;
				bool flag = mIndices == null || mIndices.Length != num;
				if (mMesh == null)
				{
					mMesh = new Mesh();
					mMesh.hideFlags = HideFlags.DontSave;
					mMesh.name = ((!(mMaterial != null)) ? "[NGUI] Mesh" : ("[NGUI] " + mMaterial.name));
					mMesh.MarkDynamic();
					flag = true;
				}
				bool flag2 = uvs.buffer.Length != verts.buffer.Length || cols.buffer.Length != verts.buffer.Length || (norms.buffer != null && norms.buffer.Length != verts.buffer.Length) || (tans.buffer != null && tans.buffer.Length != verts.buffer.Length);
				if (!flag2 && panel.renderQueue != 0)
				{
					flag2 = mMesh == null || mMesh.vertexCount != verts.buffer.Length;
				}
				mTriangles = verts.size >> 1;
				if (flag2 || verts.buffer.Length > 65000)
				{
					if (flag2 || mMesh.vertexCount != verts.size)
					{
						mMesh.Clear();
						flag = true;
					}
					mMesh.vertices = verts.ToArray();
					mMesh.uv = uvs.ToArray();
					mMesh.colors32 = cols.ToArray();
					if (norms != null)
					{
						mMesh.normals = norms.ToArray();
					}
					if (tans != null)
					{
						mMesh.tangents = tans.ToArray();
					}
				}
				else
				{
					if (mMesh.vertexCount != verts.buffer.Length)
					{
						mMesh.Clear();
						flag = true;
					}
					mMesh.vertices = verts.buffer;
					mMesh.uv = uvs.buffer;
					mMesh.colors32 = cols.buffer;
					if (norms != null)
					{
						mMesh.normals = norms.buffer;
					}
					if (tans != null)
					{
						mMesh.tangents = tans.buffer;
					}
				}
				if (flag)
				{
					mIndices = GenerateCachedIndexBuffer(size, num);
					mMesh.triangles = mIndices;
				}
				if (flag2 || !alwaysOnScreen)
				{
					mMesh.RecalculateBounds();
				}
				mFilter.mesh = mMesh;
			}
			else
			{
				mTriangles = 0;
				if (mFilter.mesh != null)
				{
					mFilter.mesh.Clear();
				}
				UnityEngine.Debug.LogError("Too many vertices on one panel: " + verts.size);
			}
			if (mRenderer == null)
			{
				mRenderer = base.gameObject.GetComponent<MeshRenderer>();
			}
			if (mRenderer == null)
			{
				mRenderer = base.gameObject.AddComponent<MeshRenderer>();
			}
			UpdateMaterials();
		}
		else
		{
			if (mFilter.mesh != null)
			{
				mFilter.mesh.Clear();
			}
			UnityEngine.Debug.LogError("UIWidgets must fill the buffer with 4 vertices per quad. Found " + size);
		}
		verts.Clear();
		uvs.Clear();
		cols.Clear();
		norms.Clear();
		tans.Clear();
	}

	private int[] GenerateCachedIndexBuffer(int vertexCount, int indexCount)
	{
		int i = 0;
		for (int count = mCache.Count; i < count; i++)
		{
			int[] array = mCache[i];
			if (array != null && array.Length == indexCount)
			{
				return array;
			}
		}
		int[] array2 = new int[indexCount];
		int num = 0;
		for (int j = 0; j < vertexCount; j += 4)
		{
			array2[num++] = j;
			array2[num++] = j + 1;
			array2[num++] = j + 2;
			array2[num++] = j + 2;
			array2[num++] = j + 3;
			array2[num++] = j;
		}
		if (mCache.Count > 10)
		{
			mCache.RemoveAt(0);
		}
		mCache.Add(array2);
		return array2;
	}

	private void OnWillRenderObject()
	{
		UpdateMaterials();
		if (onRender != null)
		{
			onRender(mDynamicMat ?? mMaterial);
		}
		if (mDynamicMat == null || mClipCount == 0)
		{
			return;
		}
		if (mTextureClip)
		{
			Vector4 drawCallClipRange = panel.drawCallClipRange;
			Vector2 clipSoftness = panel.clipSoftness;
			Vector2 vector = new Vector2(1000f, 1000f);
			if (clipSoftness.x > 0f)
			{
				vector.x = drawCallClipRange.z / clipSoftness.x;
			}
			if (clipSoftness.y > 0f)
			{
				vector.y = drawCallClipRange.w / clipSoftness.y;
			}
			mDynamicMat.SetVector(ClipRange[0], new Vector4((0f - drawCallClipRange.x) / drawCallClipRange.z, (0f - drawCallClipRange.y) / drawCallClipRange.w, 1f / drawCallClipRange.z, 1f / drawCallClipRange.w));
			mDynamicMat.SetTexture("_ClipTex", clipTexture);
		}
		else if (!mLegacyShader)
		{
			UIPanel parentPanel = panel;
			int num = 0;
			while (parentPanel != null)
			{
				if (parentPanel.hasClipping)
				{
					float angle = 0f;
					Vector4 drawCallClipRange2 = parentPanel.drawCallClipRange;
					if (parentPanel != panel)
					{
						Vector3 vector2 = parentPanel.cachedTransform.InverseTransformPoint(panel.cachedTransform.position);
						drawCallClipRange2.x -= vector2.x;
						drawCallClipRange2.y -= vector2.y;
						Vector3 eulerAngles = panel.cachedTransform.rotation.eulerAngles;
						Vector3 eulerAngles2 = parentPanel.cachedTransform.rotation.eulerAngles;
						Vector3 vector3 = eulerAngles2 - eulerAngles;
						vector3.x = NGUIMath.WrapAngle(vector3.x);
						vector3.y = NGUIMath.WrapAngle(vector3.y);
						vector3.z = NGUIMath.WrapAngle(vector3.z);
						if (Mathf.Abs(vector3.x) > 0.001f || Mathf.Abs(vector3.y) > 0.001f)
						{
							UnityEngine.Debug.LogWarning("Panel can only be clipped properly if X and Y rotation is left at 0", panel);
						}
						angle = vector3.z;
					}
					SetClipping(num++, drawCallClipRange2, parentPanel.clipSoftness, angle);
				}
				parentPanel = parentPanel.parentPanel;
			}
		}
		else
		{
			Vector2 clipSoftness2 = panel.clipSoftness;
			Vector4 drawCallClipRange3 = panel.drawCallClipRange;
			Vector2 mainTextureOffset = new Vector2((0f - drawCallClipRange3.x) / drawCallClipRange3.z, (0f - drawCallClipRange3.y) / drawCallClipRange3.w);
			Vector2 mainTextureScale = new Vector2(1f / drawCallClipRange3.z, 1f / drawCallClipRange3.w);
			Vector2 vector4 = new Vector2(1000f, 1000f);
			if (clipSoftness2.x > 0f)
			{
				vector4.x = drawCallClipRange3.z / clipSoftness2.x;
			}
			if (clipSoftness2.y > 0f)
			{
				vector4.y = drawCallClipRange3.w / clipSoftness2.y;
			}
			mDynamicMat.mainTextureOffset = mainTextureOffset;
			mDynamicMat.mainTextureScale = mainTextureScale;
			mDynamicMat.SetVector("_ClipSharpness", vector4);
		}
	}

	private void SetClipping(int index, Vector4 cr, Vector2 soft, float angle)
	{
		angle *= -(float)Math.PI / 180f;
		Vector2 vector = new Vector2(1000f, 1000f);
		if (soft.x > 0f)
		{
			vector.x = cr.z / soft.x;
		}
		if (soft.y > 0f)
		{
			vector.y = cr.w / soft.y;
		}
		if (index < ClipRange.Length)
		{
			mDynamicMat.SetVector(ClipRange[index], new Vector4((0f - cr.x) / cr.z, (0f - cr.y) / cr.w, 1f / cr.z, 1f / cr.w));
			mDynamicMat.SetVector(ClipArgs[index], new Vector4(vector.x, vector.y, Mathf.Sin(angle), Mathf.Cos(angle)));
		}
	}

	private void OnEnable()
	{
		mRebuildMat = true;
	}

	private void OnDisable()
	{
		depthStart = int.MaxValue;
		depthEnd = int.MinValue;
		panel = null;
		manager = null;
		mMaterial = null;
		mTexture = null;
		clipTexture = null;
		if (mRenderer != null)
		{
			mRenderer.sharedMaterials = new Material[0];
		}
		NGUITools.DestroyImmediate(mDynamicMat);
		mDynamicMat = null;
	}

	private void OnDestroy()
	{
		NGUITools.DestroyImmediate(mMesh);
		mMesh = null;
	}

	public static UIDrawCall Create(UIPanel panel, Material mat, Texture tex, Shader shader)
	{
		return Create(null, panel, mat, tex, shader);
	}

	private static UIDrawCall Create(string name, UIPanel pan, Material mat, Texture tex, Shader shader)
	{
		UIDrawCall uIDrawCall = Create(name);
		uIDrawCall.gameObject.layer = pan.cachedGameObject.layer;
		uIDrawCall.baseMaterial = mat;
		uIDrawCall.mainTexture = tex;
		uIDrawCall.shader = shader;
		uIDrawCall.renderQueue = pan.startingRenderQueue;
		uIDrawCall.sortingOrder = pan.sortingOrder;
		uIDrawCall.manager = pan;
		return uIDrawCall;
	}

	private static UIDrawCall Create(string name)
	{
		if (mInactiveList.size > 0)
		{
			UIDrawCall uIDrawCall = mInactiveList.Pop();
			mActiveList.Add(uIDrawCall);
			if (name != null)
			{
				uIDrawCall.name = name;
			}
			NGUITools.SetActive(uIDrawCall.gameObject, state: true);
			return uIDrawCall;
		}
		GameObject gameObject = new GameObject(name);
		UnityEngine.Object.DontDestroyOnLoad(gameObject);
		UIDrawCall uIDrawCall2 = gameObject.AddComponent<UIDrawCall>();
		mActiveList.Add(uIDrawCall2);
		return uIDrawCall2;
	}

	public static void ClearAll()
	{
		bool isPlaying = Application.isPlaying;
		int num = mActiveList.size;
		while (num > 0)
		{
			UIDrawCall uIDrawCall = mActiveList[--num];
			if ((bool)uIDrawCall)
			{
				if (isPlaying)
				{
					NGUITools.SetActive(uIDrawCall.gameObject, state: false);
				}
				else
				{
					NGUITools.DestroyImmediate(uIDrawCall.gameObject);
				}
			}
		}
		mActiveList.Clear();
	}

	public static void ReleaseAll()
	{
		ClearAll();
		ReleaseInactive();
	}

	public static void ReleaseInactive()
	{
		int num = mInactiveList.size;
		while (num > 0)
		{
			UIDrawCall uIDrawCall = mInactiveList[--num];
			if ((bool)uIDrawCall)
			{
				NGUITools.DestroyImmediate(uIDrawCall.gameObject);
			}
		}
		mInactiveList.Clear();
	}

	public static int Count(UIPanel panel)
	{
		int num = 0;
		for (int i = 0; i < mActiveList.size; i++)
		{
			if (mActiveList[i].manager == panel)
			{
				num++;
			}
		}
		return num;
	}

	public static void Destroy(UIDrawCall dc)
	{
		if (!dc)
		{
			return;
		}
		dc.onRender = null;
		if (Application.isPlaying)
		{
			if (mActiveList.Remove(dc))
			{
				NGUITools.SetActive(dc.gameObject, state: false);
				mInactiveList.Add(dc);
			}
		}
		else
		{
			mActiveList.Remove(dc);
			NGUITools.DestroyImmediate(dc.gameObject);
		}
	}
}
[AddComponentMenu("NGUI/Internal/Event Listener")]
public class UIEventListener : MonoBehaviour
{
	public delegate void VoidDelegate(GameObject go);

	public delegate void BoolDelegate(GameObject go, bool state);

	public delegate void FloatDelegate(GameObject go, float delta);

	public delegate void VectorDelegate(GameObject go, Vector2 delta);

	public delegate void ObjectDelegate(GameObject go, GameObject obj);

	public delegate void KeyCodeDelegate(GameObject go, KeyCode key);

	public object parameter;

	public VoidDelegate onSubmit;

	public VoidDelegate onClick;

	public VoidDelegate onDoubleClick;

	public BoolDelegate onHover;

	public BoolDelegate onPress;

	public BoolDelegate onSelect;

	public FloatDelegate onScroll;

	public VoidDelegate onDragStart;

	public VectorDelegate onDrag;

	public VoidDelegate onDragOver;

	public VoidDelegate onDragOut;

	public VoidDelegate onDragEnd;

	public ObjectDelegate onDrop;

	public KeyCodeDelegate onKey;

	public BoolDelegate onTooltip;

	private void OnSubmit()
	{
		if (onSubmit != null)
		{
			onSubmit(base.gameObject);
		}
	}

	private void OnClick()
	{
		if (onClick != null)
		{
			onClick(base.gameObject);
		}
	}

	private void OnDoubleClick()
	{
		if (onDoubleClick != null)
		{
			onDoubleClick(base.gameObject);
		}
	}

	private void OnHover(bool isOver)
	{
		if (onHover != null)
		{
			onHover(base.gameObject, isOver);
		}
	}

	private void OnPress(bool isPressed)
	{
		if (onPress != null)
		{
			onPress(base.gameObject, isPressed);
		}
	}

	private void OnSelect(bool selected)
	{
		if (onSelect != null)
		{
			onSelect(base.gameObject, selected);
		}
	}

	private void OnScroll(float delta)
	{
		if (onScroll != null)
		{
			onScroll(base.gameObject, delta);
		}
	}

	private void OnDragStart()
	{
		if (onDragStart != null)
		{
			onDragStart(base.gameObject);
		}
	}

	private void OnDrag(Vector2 delta)
	{
		if (onDrag != null)
		{
			onDrag(base.gameObject, delta);
		}
	}

	private void OnDragOver()
	{
		if (onDragOver != null)
		{
			onDragOver(base.gameObject);
		}
	}

	private void OnDragOut()
	{
		if (onDragOut != null)
		{
			onDragOut(base.gameObject);
		}
	}

	private void OnDragEnd()
	{
		if (onDragEnd != null)
		{
			onDragEnd(base.gameObject);
		}
	}

	private void OnDrop(GameObject go)
	{
		if (onDrop != null)
		{
			onDrop(base.gameObject, go);
		}
	}

	private void OnKey(KeyCode key)
	{
		if (onKey != null)
		{
			onKey(base.gameObject, key);
		}
	}

	private void OnTooltip(bool show)
	{
		if (onTooltip != null)
		{
			onTooltip(base.gameObject, show);
		}
	}

	public static UIEventListener Get(GameObject go)
	{
		UIEventListener uIEventListener = go.GetComponent<UIEventListener>();
		if (uIEventListener == null)
		{
			uIEventListener = go.AddComponent<UIEventListener>();
		}
		return uIEventListener;
	}
}
public class UIGeometry
{
	public BetterList<Vector3> verts = new BetterList<Vector3>();

	public BetterList<Vector2> uvs = new BetterList<Vector2>();

	public BetterList<Color32> cols = new BetterList<Color32>();

	private BetterList<Vector3> mRtpVerts = new BetterList<Vector3>();

	private Vector3 mRtpNormal;

	private Vector4 mRtpTan;

	public bool hasVertices => verts.size > 0;

	public bool hasTransformed => mRtpVerts != null && mRtpVerts.size > 0 && mRtpVerts.size == verts.size;

	public void Clear()
	{
		verts.Clear();
		uvs.Clear();
		cols.Clear();
		mRtpVerts.Clear();
	}

	public void ApplyTransform(Matrix4x4 widgetToPanel)
	{
		if (verts.size > 0)
		{
			mRtpVerts.Clear();
			int i = 0;
			for (int size = verts.size; i < size; i++)
			{
				mRtpVerts.Add(widgetToPanel.MultiplyPoint3x4(verts[i]));
			}
			mRtpNormal = widgetToPanel.MultiplyVector(Vector3.back).normalized;
			Vector3 normalized = widgetToPanel.MultiplyVector(Vector3.right).normalized;
			mRtpTan = new Vector4(normalized.x, normalized.y, normalized.z, -1f);
		}
		else
		{
			mRtpVerts.Clear();
		}
	}

	public void WriteToBuffers(BetterList<Vector3> v, BetterList<Vector2> u, BetterList<Color32> c, BetterList<Vector3> n, BetterList<Vector4> t)
	{
		if (mRtpVerts == null || mRtpVerts.size <= 0)
		{
			return;
		}
		if (n == null)
		{
			for (int i = 0; i < mRtpVerts.size; i++)
			{
				v.Add(mRtpVerts.buffer[i]);
				u.Add(uvs.buffer[i]);
				c.Add(cols.buffer[i]);
			}
			return;
		}
		for (int j = 0; j < mRtpVerts.size; j++)
		{
			v.Add(mRtpVerts.buffer[j]);
			u.Add(uvs.buffer[j]);
			c.Add(cols.buffer[j]);
			n.Add(mRtpNormal);
			t.Add(mRtpTan);
		}
	}
}
public abstract class UIRect : MonoBehaviour
{
	[Serializable]
	public class AnchorPoint
	{
		public Transform target;

		public float relative;

		public int absolute;

		[NonSerialized]
		public UIRect rect;

		[NonSerialized]
		public Camera targetCam;

		public AnchorPoint()
		{
		}

		public AnchorPoint(float relative)
		{
			this.relative = relative;
		}

		public void Set(float relative, float absolute)
		{
			this.relative = relative;
			this.absolute = Mathf.FloorToInt(absolute + 0.5f);
		}

		public void Set(Transform target, float relative, float absolute)
		{
			this.target = target;
			this.relative = relative;
			this.absolute = Mathf.FloorToInt(absolute + 0.5f);
		}

		public void SetToNearest(float abs0, float abs1, float abs2)
		{
			SetToNearest(0f, 0.5f, 1f, abs0, abs1, abs2);
		}

		public void SetToNearest(float rel0, float rel1, float rel2, float abs0, float abs1, float abs2)
		{
			float num = Mathf.Abs(abs0);
			float num2 = Mathf.Abs(abs1);
			float num3 = Mathf.Abs(abs2);
			if (num < num2 && num < num3)
			{
				Set(rel0, abs0);
			}
			else if (num2 < num && num2 < num3)
			{
				Set(rel1, abs1);
			}
			else
			{
				Set(rel2, abs2);
			}
		}

		public void SetHorizontal(Transform parent, float localPos)
		{
			if ((bool)rect)
			{
				Vector3[] sides = rect.GetSides(parent);
				float num = Mathf.Lerp(sides[0].x, sides[2].x, relative);
				absolute = Mathf.FloorToInt(localPos - num + 0.5f);
				return;
			}
			Vector3 position = target.position;
			if (parent != null)
			{
				position = parent.InverseTransformPoint(position);
			}
			absolute = Mathf.FloorToInt(localPos - position.x + 0.5f);
		}

		public void SetVertical(Transform parent, float localPos)
		{
			if ((bool)rect)
			{
				Vector3[] sides = rect.GetSides(parent);
				float num = Mathf.Lerp(sides[3].y, sides[1].y, relative);
				absolute = Mathf.FloorToInt(localPos - num + 0.5f);
				return;
			}
			Vector3 position = target.position;
			if (parent != null)
			{
				position = parent.InverseTransformPoint(position);
			}
			absolute = Mathf.FloorToInt(localPos - position.y + 0.5f);
		}

		public Vector3[] GetSides(Transform relativeTo)
		{
			if (target != null)
			{
				if (rect != null)
				{
					return rect.GetSides(relativeTo);
				}
				if (target.GetComponent<Camera>() != null)
				{
					return target.GetComponent<Camera>().GetSides(relativeTo);
				}
			}
			return null;
		}
	}

	public enum AnchorUpdate
	{
		OnEnable,
		OnUpdate,
		OnStart
	}

	public AnchorPoint leftAnchor = new AnchorPoint();

	public AnchorPoint rightAnchor = new AnchorPoint(1f);

	public AnchorPoint bottomAnchor = new AnchorPoint();

	public AnchorPoint topAnchor = new AnchorPoint(1f);

	public AnchorUpdate updateAnchors = AnchorUpdate.OnUpdate;

	protected GameObject mGo;

	protected Transform mTrans;

	protected BetterList<UIRect> mChildren = new BetterList<UIRect>();

	protected bool mChanged = true;

	protected bool mStarted;

	protected bool mParentFound;

	[NonSerialized]
	private bool mUpdateAnchors = true;

	[NonSerialized]
	private int mUpdateFrame = -1;

	[NonSerialized]
	private bool mAnchorsCached;

	[NonSerialized]
	public float finalAlpha = 1f;

	private UIRoot mRoot;

	private UIRect mParent;

	private bool mRootSet;

	protected Camera mCam;

	protected static Vector3[] mSides = new Vector3[4];

	public GameObject cachedGameObject
	{
		get
		{
			if (mGo == null)
			{
				mGo = base.gameObject;
			}
			return mGo;
		}
	}

	public Transform cachedTransform
	{
		get
		{
			if (mTrans == null)
			{
				mTrans = base.transform;
			}
			return mTrans;
		}
	}

	public Camera anchorCamera
	{
		get
		{
			if (!mAnchorsCached)
			{
				ResetAnchors();
			}
			return mCam;
		}
	}

	public bool isFullyAnchored => (bool)leftAnchor.target && (bool)rightAnchor.target && (bool)topAnchor.target && (bool)bottomAnchor.target;

	public virtual bool isAnchoredHorizontally => (bool)leftAnchor.target || (bool)rightAnchor.target;

	public virtual bool isAnchoredVertically => (bool)bottomAnchor.target || (bool)topAnchor.target;

	public virtual bool canBeAnchored => true;

	public UIRect parent
	{
		get
		{
			if (!mParentFound)
			{
				mParentFound = true;
				mParent = NGUITools.FindInParents<UIRect>(cachedTransform.parent);
			}
			return mParent;
		}
	}

	public UIRoot root
	{
		get
		{
			if (parent != null)
			{
				return mParent.root;
			}
			if (!mRootSet)
			{
				mRootSet = true;
				mRoot = NGUITools.FindInParents<UIRoot>(cachedTransform);
			}
			return mRoot;
		}
	}

	public bool isAnchored => ((bool)leftAnchor.target || (bool)rightAnchor.target || (bool)topAnchor.target || (bool)bottomAnchor.target) && canBeAnchored;

	public abstract float alpha { get; set; }

	public abstract Vector3[] localCorners { get; }

	public abstract Vector3[] worldCorners { get; }

	protected float cameraRayDistance
	{
		get
		{
			if (anchorCamera == null)
			{
				return 0f;
			}
			if (!mCam.orthographic)
			{
				Transform transform = cachedTransform;
				Transform transform2 = mCam.transform;
				Plane plane = new Plane(transform.rotation * Vector3.back, transform.position);
				Ray ray = new Ray(transform2.position, transform2.rotation * Vector3.forward);
				if (plane.Raycast(ray, out var enter))
				{
					return enter;
				}
			}
			return Mathf.Lerp(mCam.nearClipPlane, mCam.farClipPlane, 0.5f);
		}
	}

	public abstract float CalculateFinalAlpha(int frameID);

	public virtual void Invalidate(bool includeChildren)
	{
		mChanged = true;
		if (includeChildren)
		{
			for (int i = 0; i < mChildren.size; i++)
			{
				mChildren.buffer[i].Invalidate(includeChildren: true);
			}
		}
	}

	public virtual Vector3[] GetSides(Transform relativeTo)
	{
		if (anchorCamera != null)
		{
			return mCam.GetSides(cameraRayDistance, relativeTo);
		}
		Vector3 position = cachedTransform.position;
		for (int i = 0; i < 4; i++)
		{
			mSides[i] = position;
		}
		if (relativeTo != null)
		{
			for (int j = 0; j < 4; j++)
			{
				ref Vector3 reference = ref mSides[j];
				reference = relativeTo.InverseTransformPoint(mSides[j]);
			}
		}
		return mSides;
	}

	protected Vector3 GetLocalPos(AnchorPoint ac, Transform trans)
	{
		if (anchorCamera == null || ac.targetCam == null)
		{
			return cachedTransform.localPosition;
		}
		Vector3 vector = mCam.ViewportToWorldPoint(ac.targetCam.WorldToViewportPoint(ac.target.position));
		if (trans != null)
		{
			vector = trans.InverseTransformPoint(vector);
		}
		vector.x = Mathf.Floor(vector.x + 0.5f);
		vector.y = Mathf.Floor(vector.y + 0.5f);
		return vector;
	}

	protected virtual void OnEnable()
	{
		mUpdateFrame = -1;
		if (updateAnchors == AnchorUpdate.OnEnable)
		{
			mAnchorsCached = false;
			mUpdateAnchors = true;
		}
		if (mStarted)
		{
			OnInit();
		}
		mUpdateFrame = -1;
	}

	protected virtual void OnInit()
	{
		mChanged = true;
		mRootSet = false;
		mParentFound = false;
		if (parent != null)
		{
			mParent.mChildren.Add(this);
		}
	}

	protected virtual void OnDisable()
	{
		if ((bool)mParent)
		{
			mParent.mChildren.Remove(this);
		}
		mParent = null;
		mRoot = null;
		mRootSet = false;
		mParentFound = false;
	}

	protected void Start()
	{
		mStarted = true;
		OnInit();
		OnStart();
	}

	public void Update()
	{
		if (!mAnchorsCached)
		{
			ResetAnchors();
		}
		int frameCount = Time.frameCount;
		if (mUpdateFrame == frameCount)
		{
			return;
		}
		if (updateAnchors == AnchorUpdate.OnUpdate || mUpdateAnchors)
		{
			mUpdateFrame = frameCount;
			mUpdateAnchors = false;
			bool flag = false;
			if ((bool)leftAnchor.target)
			{
				flag = true;
				if (leftAnchor.rect != null && leftAnchor.rect.mUpdateFrame != frameCount)
				{
					leftAnchor.rect.Update();
				}
			}
			if ((bool)bottomAnchor.target)
			{
				flag = true;
				if (bottomAnchor.rect != null && bottomAnchor.rect.mUpdateFrame != frameCount)
				{
					bottomAnchor.rect.Update();
				}
			}
			if ((bool)rightAnchor.target)
			{
				flag = true;
				if (rightAnchor.rect != null && rightAnchor.rect.mUpdateFrame != frameCount)
				{
					rightAnchor.rect.Update();
				}
			}
			if ((bool)topAnchor.target)
			{
				flag = true;
				if (topAnchor.rect != null && topAnchor.rect.mUpdateFrame != frameCount)
				{
					topAnchor.rect.Update();
				}
			}
			if (flag)
			{
				OnAnchor();
			}
		}
		OnUpdate();
	}

	public void UpdateAnchors()
	{
		if (isAnchored && updateAnchors != AnchorUpdate.OnStart)
		{
			OnAnchor();
		}
	}

	protected abstract void OnAnchor();

	public void SetAnchor(Transform t)
	{
		leftAnchor.target = t;
		rightAnchor.target = t;
		topAnchor.target = t;
		bottomAnchor.target = t;
		ResetAnchors();
		UpdateAnchors();
	}

	public void SetAnchor(GameObject go)
	{
		Transform target = ((!(go != null)) ? null : go.transform);
		leftAnchor.target = target;
		rightAnchor.target = target;
		topAnchor.target = target;
		bottomAnchor.target = target;
		ResetAnchors();
		UpdateAnchors();
	}

	public void SetAnchor(GameObject go, int left, int bottom, int right, int top)
	{
		Transform target = ((!(go != null)) ? null : go.transform);
		leftAnchor.target = target;
		rightAnchor.target = target;
		topAnchor.target = target;
		bottomAnchor.target = target;
		leftAnchor.relative = 0f;
		rightAnchor.relative = 1f;
		bottomAnchor.relative = 0f;
		topAnchor.relative = 1f;
		leftAnchor.absolute = left;
		rightAnchor.absolute = right;
		bottomAnchor.absolute = bottom;
		topAnchor.absolute = top;
		ResetAnchors();
		UpdateAnchors();
	}

	public void ResetAnchors()
	{
		mAnchorsCached = true;
		leftAnchor.rect = ((!leftAnchor.target) ? null : leftAnchor.target.GetComponent<UIRect>());
		bottomAnchor.rect = ((!bottomAnchor.target) ? null : bottomAnchor.target.GetComponent<UIRect>());
		rightAnchor.rect = ((!rightAnchor.target) ? null : rightAnchor.target.GetComponent<UIRect>());
		topAnchor.rect = ((!topAnchor.target) ? null : topAnchor.target.GetComponent<UIRect>());
		mCam = NGUITools.FindCameraForLayer(cachedGameObject.layer);
		FindCameraFor(leftAnchor);
		FindCameraFor(bottomAnchor);
		FindCameraFor(rightAnchor);
		FindCameraFor(topAnchor);
		mUpdateAnchors = true;
	}

	public void ResetAndUpdateAnchors()
	{
		ResetAnchors();
		UpdateAnchors();
	}

	public abstract void SetRect(float x, float y, float width, float height);

	private void FindCameraFor(AnchorPoint ap)
	{
		if (ap.target == null || ap.rect != null)
		{
			ap.targetCam = null;
		}
		else
		{
			ap.targetCam = NGUITools.FindCameraForLayer(ap.target.gameObject.layer);
		}
	}

	public virtual void ParentHasChanged()
	{
		mParentFound = false;
		UIRect uIRect = NGUITools.FindInParents<UIRect>(cachedTransform.parent);
		if (mParent != uIRect)
		{
			if ((bool)mParent)
			{
				mParent.mChildren.Remove(this);
			}
			mParent = uIRect;
			if ((bool)mParent)
			{
				mParent.mChildren.Add(this);
			}
			mRootSet = false;
		}
	}

	protected abstract void OnStart();

	protected virtual void OnUpdate()
	{
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/Internal/Snapshot Point")]
public class UISnapshotPoint : MonoBehaviour
{
	public bool isOrthographic = true;

	public float nearClip = -100f;

	public float farClip = 100f;

	[Range(10f, 80f)]
	public int fieldOfView = 35;

	public float orthoSize = 30f;

	public Texture2D thumbnail;

	private void Start()
	{
		if (base.tag != "EditorOnly")
		{
			base.tag = "EditorOnly";
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/UI/NGUI Widget")]
public class UIWidget : UIRect
{
	public enum Pivot
	{
		TopLeft,
		Top,
		TopRight,
		Left,
		Center,
		Right,
		BottomLeft,
		Bottom,
		BottomRight
	}

	public delegate void OnDimensionsChanged();

	public delegate void OnPostFillCallback(UIWidget widget, int bufferOffset, BetterList<Vector3> verts, BetterList<Vector2> uvs, BetterList<Color32> cols);

	public enum AspectRatioSource
	{
		Free,
		BasedOnWidth,
		BasedOnHeight
	}

	public delegate bool HitCheck(Vector3 worldPos);

	[HideInInspector]
	[SerializeField]
	protected UnityEngine.Color mColor = UnityEngine.Color.white;

	[HideInInspector]
	[SerializeField]
	protected Pivot mPivot = Pivot.Center;

	[HideInInspector]
	[SerializeField]
	protected int mWidth = 100;

	[HideInInspector]
	[SerializeField]
	protected int mHeight = 100;

	[HideInInspector]
	[SerializeField]
	protected int mDepth;

	public OnDimensionsChanged onChange;

	public OnPostFillCallback onPostFill;

	public UIDrawCall.OnRenderCallback mOnRender;

	public bool autoResizeBoxCollider;

	public bool hideIfOffScreen;

	public AspectRatioSource keepAspectRatio;

	public float aspectRatio = 1f;

	public HitCheck hitCheck;

	[NonSerialized]
	public UIPanel panel;

	[NonSerialized]
	public UIGeometry geometry = new UIGeometry();

	[NonSerialized]
	public bool fillGeometry = true;

	[NonSerialized]
	protected bool mPlayMode = true;

	[NonSerialized]
	protected Vector4 mDrawRegion = new Vector4(0f, 0f, 1f, 1f);

	[NonSerialized]
	private Matrix4x4 mLocalToPanel;

	[NonSerialized]
	private bool mIsVisibleByAlpha = true;

	[NonSerialized]
	private bool mIsVisibleByPanel = true;

	[NonSerialized]
	private bool mIsInFront = true;

	[NonSerialized]
	private float mLastAlpha;

	[NonSerialized]
	private bool mMoved;

	[NonSerialized]
	public UIDrawCall drawCall;

	[NonSerialized]
	protected Vector3[] mCorners = new Vector3[4];

	[NonSerialized]
	private int mAlphaFrameID = -1;

	private int mMatrixFrame = -1;

	private Vector3 mOldV0;

	private Vector3 mOldV1;

	public UIDrawCall.OnRenderCallback onRender
	{
		get
		{
			return mOnRender;
		}
		set
		{
			if (mOnRender != value)
			{
				if (drawCall != null && drawCall.onRender != null && mOnRender != null)
				{
					UIDrawCall uIDrawCall = drawCall;
					uIDrawCall.onRender = (UIDrawCall.OnRenderCallback)Delegate.Remove(uIDrawCall.onRender, mOnRender);
				}
				mOnRender = value;
				if (drawCall != null)
				{
					UIDrawCall uIDrawCall2 = drawCall;
					uIDrawCall2.onRender = (UIDrawCall.OnRenderCallback)Delegate.Combine(uIDrawCall2.onRender, value);
				}
			}
		}
	}

	public Vector4 drawRegion
	{
		get
		{
			return mDrawRegion;
		}
		set
		{
			if (mDrawRegion != value)
			{
				mDrawRegion = value;
				if (autoResizeBoxCollider)
				{
					ResizeCollider();
				}
				MarkAsChanged();
			}
		}
	}

	public Vector2 pivotOffset => NGUIMath.GetPivotOffset(pivot);

	public int width
	{
		get
		{
			return mWidth;
		}
		set
		{
			int num = minWidth;
			if (value < num)
			{
				value = num;
			}
			if (mWidth == value || keepAspectRatio == AspectRatioSource.BasedOnHeight)
			{
				return;
			}
			if (isAnchoredHorizontally)
			{
				if (leftAnchor.target != null && rightAnchor.target != null)
				{
					if (mPivot == Pivot.BottomLeft || mPivot == Pivot.Left || mPivot == Pivot.TopLeft)
					{
						NGUIMath.AdjustWidget(this, 0f, 0f, value - mWidth, 0f);
						return;
					}
					if (mPivot == Pivot.BottomRight || mPivot == Pivot.Right || mPivot == Pivot.TopRight)
					{
						NGUIMath.AdjustWidget(this, mWidth - value, 0f, 0f, 0f);
						return;
					}
					int num2 = value - mWidth;
					num2 -= num2 & 1;
					if (num2 != 0)
					{
						NGUIMath.AdjustWidget(this, (float)(-num2) * 0.5f, 0f, (float)num2 * 0.5f, 0f);
					}
				}
				else if (leftAnchor.target != null)
				{
					NGUIMath.AdjustWidget(this, 0f, 0f, value - mWidth, 0f);
				}
				else
				{
					NGUIMath.AdjustWidget(this, mWidth - value, 0f, 0f, 0f);
				}
			}
			else
			{
				SetDimensions(value, mHeight);
			}
		}
	}

	public int height
	{
		get
		{
			return mHeight;
		}
		set
		{
			int num = minHeight;
			if (value < num)
			{
				value = num;
			}
			if (mHeight == value || keepAspectRatio == AspectRatioSource.BasedOnWidth)
			{
				return;
			}
			if (isAnchoredVertically)
			{
				if (bottomAnchor.target != null && topAnchor.target != null)
				{
					if (mPivot == Pivot.BottomLeft || mPivot == Pivot.Bottom || mPivot == Pivot.BottomRight)
					{
						NGUIMath.AdjustWidget(this, 0f, 0f, 0f, value - mHeight);
						return;
					}
					if (mPivot == Pivot.TopLeft || mPivot == Pivot.Top || mPivot == Pivot.TopRight)
					{
						NGUIMath.AdjustWidget(this, 0f, mHeight - value, 0f, 0f);
						return;
					}
					int num2 = value - mHeight;
					num2 -= num2 & 1;
					if (num2 != 0)
					{
						NGUIMath.AdjustWidget(this, 0f, (float)(-num2) * 0.5f, 0f, (float)num2 * 0.5f);
					}
				}
				else if (bottomAnchor.target != null)
				{
					NGUIMath.AdjustWidget(this, 0f, 0f, 0f, value - mHeight);
				}
				else
				{
					NGUIMath.AdjustWidget(this, 0f, mHeight - value, 0f, 0f);
				}
			}
			else
			{
				SetDimensions(mWidth, value);
			}
		}
	}

	public UnityEngine.Color color
	{
		get
		{
			return mColor;
		}
		set
		{
			if (mColor != value)
			{
				bool includeChildren = mColor.a != value.a;
				mColor = value;
				Invalidate(includeChildren);
			}
		}
	}

	public override float alpha
	{
		get
		{
			return mColor.a;
		}
		set
		{
			if (mColor.a != value)
			{
				mColor.a = value;
				Invalidate(includeChildren: true);
			}
		}
	}

	public bool isVisible => mIsVisibleByPanel && mIsVisibleByAlpha && mIsInFront && finalAlpha > 0.001f && NGUITools.GetActive(this);

	public bool hasVertices => geometry != null && geometry.hasVertices;

	public Pivot rawPivot
	{
		get
		{
			return mPivot;
		}
		set
		{
			if (mPivot != value)
			{
				mPivot = value;
				if (autoResizeBoxCollider)
				{
					ResizeCollider();
				}
				MarkAsChanged();
			}
		}
	}

	public Pivot pivot
	{
		get
		{
			return mPivot;
		}
		set
		{
			if (mPivot != value)
			{
				Vector3 vector = worldCorners[0];
				mPivot = value;
				mChanged = true;
				Vector3 vector2 = worldCorners[0];
				Transform transform = base.cachedTransform;
				Vector3 position = transform.position;
				float z = transform.localPosition.z;
				position.x += vector.x - vector2.x;
				position.y += vector.y - vector2.y;
				base.cachedTransform.position = position;
				position = base.cachedTransform.localPosition;
				position.x = Mathf.Round(position.x);
				position.y = Mathf.Round(position.y);
				position.z = z;
				base.cachedTransform.localPosition = position;
			}
		}
	}

	public int depth
	{
		get
		{
			return mDepth;
		}
		set
		{
			if (mDepth == value)
			{
				return;
			}
			if (panel != null)
			{
				panel.RemoveWidget(this);
			}
			mDepth = value;
			if (panel != null)
			{
				panel.AddWidget(this);
				if (!Application.isPlaying)
				{
					panel.SortWidgets();
					panel.RebuildAllDrawCalls();
				}
			}
		}
	}

	public int raycastDepth
	{
		get
		{
			if (panel == null)
			{
				CreatePanel();
			}
			return (!(panel != null)) ? mDepth : (mDepth + panel.depth * 1000);
		}
	}

	public override Vector3[] localCorners
	{
		get
		{
			Vector2 vector = pivotOffset;
			float num = (0f - vector.x) * (float)mWidth;
			float num2 = (0f - vector.y) * (float)mHeight;
			float x = num + (float)mWidth;
			float y = num2 + (float)mHeight;
			ref Vector3 reference = ref mCorners[0];
			reference = new Vector3(num, num2);
			ref Vector3 reference2 = ref mCorners[1];
			reference2 = new Vector3(num, y);
			ref Vector3 reference3 = ref mCorners[2];
			reference3 = new Vector3(x, y);
			ref Vector3 reference4 = ref mCorners[3];
			reference4 = new Vector3(x, num2);
			return mCorners;
		}
	}

	public virtual Vector2 localSize
	{
		get
		{
			Vector3[] array = localCorners;
			return array[2] - array[0];
		}
	}

	public Vector3 localCenter
	{
		get
		{
			Vector3[] array = localCorners;
			return Vector3.Lerp(array[0], array[2], 0.5f);
		}
	}

	public override Vector3[] worldCorners
	{
		get
		{
			Vector2 vector = pivotOffset;
			float num = (0f - vector.x) * (float)mWidth;
			float num2 = (0f - vector.y) * (float)mHeight;
			float x = num + (float)mWidth;
			float y = num2 + (float)mHeight;
			Transform transform = base.cachedTransform;
			ref Vector3 reference = ref mCorners[0];
			reference = transform.TransformPoint(num, num2, 0f);
			ref Vector3 reference2 = ref mCorners[1];
			reference2 = transform.TransformPoint(num, y, 0f);
			ref Vector3 reference3 = ref mCorners[2];
			reference3 = transform.TransformPoint(x, y, 0f);
			ref Vector3 reference4 = ref mCorners[3];
			reference4 = transform.TransformPoint(x, num2, 0f);
			return mCorners;
		}
	}

	public Vector3 worldCenter => base.cachedTransform.TransformPoint(localCenter);

	public virtual Vector4 drawingDimensions
	{
		get
		{
			Vector2 vector = pivotOffset;
			float num = (0f - vector.x) * (float)mWidth;
			float num2 = (0f - vector.y) * (float)mHeight;
			float num3 = num + (float)mWidth;
			float num4 = num2 + (float)mHeight;
			return new Vector4((mDrawRegion.x != 0f) ? Mathf.Lerp(num, num3, mDrawRegion.x) : num, (mDrawRegion.y != 0f) ? Mathf.Lerp(num2, num4, mDrawRegion.y) : num2, (mDrawRegion.z != 1f) ? Mathf.Lerp(num, num3, mDrawRegion.z) : num3, (mDrawRegion.w != 1f) ? Mathf.Lerp(num2, num4, mDrawRegion.w) : num4);
		}
	}

	public virtual Material material
	{
		get
		{
			return null;
		}
		set
		{
			throw new NotImplementedException(string.Concat(GetType(), " has no material setter"));
		}
	}

	public virtual Texture mainTexture
	{
		get
		{
			Material material = this.material;
			return (!(material != null)) ? null : material.mainTexture;
		}
		set
		{
			throw new NotImplementedException(string.Concat(GetType(), " has no mainTexture setter"));
		}
	}

	public virtual Shader shader
	{
		get
		{
			Material material = this.material;
			return (!(material != null)) ? null : material.shader;
		}
		set
		{
			throw new NotImplementedException(string.Concat(GetType(), " has no shader setter"));
		}
	}

	[Obsolete("There is no relative scale anymore. Widgets now have width and height instead")]
	public Vector2 relativeSize => Vector2.one;

	public bool hasBoxCollider
	{
		get
		{
			BoxCollider boxCollider = GetComponent<Collider>() as BoxCollider;
			if (boxCollider != null)
			{
				return true;
			}
			return GetComponent<BoxCollider2D>() != null;
		}
	}

	public virtual int minWidth => 2;

	public virtual int minHeight => 2;

	public virtual Vector4 border
	{
		get
		{
			return Vector4.zero;
		}
		set
		{
		}
	}

	public void SetDimensions(int w, int h)
	{
		if (mWidth != w || mHeight != h)
		{
			mWidth = w;
			mHeight = h;
			if (keepAspectRatio == AspectRatioSource.BasedOnWidth)
			{
				mHeight = Mathf.RoundToInt((float)mWidth / aspectRatio);
			}
			else if (keepAspectRatio == AspectRatioSource.BasedOnHeight)
			{
				mWidth = Mathf.RoundToInt((float)mHeight * aspectRatio);
			}
			else if (keepAspectRatio == AspectRatioSource.Free)
			{
				aspectRatio = (float)mWidth / (float)mHeight;
			}
			mMoved = true;
			if (autoResizeBoxCollider)
			{
				ResizeCollider();
			}
			MarkAsChanged();
		}
	}

	public override Vector3[] GetSides(Transform relativeTo)
	{
		Vector2 vector = pivotOffset;
		float num = (0f - vector.x) * (float)mWidth;
		float num2 = (0f - vector.y) * (float)mHeight;
		float num3 = num + (float)mWidth;
		float num4 = num2 + (float)mHeight;
		float x = (num + num3) * 0.5f;
		float y = (num2 + num4) * 0.5f;
		Transform transform = base.cachedTransform;
		ref Vector3 reference = ref mCorners[0];
		reference = transform.TransformPoint(num, y, 0f);
		ref Vector3 reference2 = ref mCorners[1];
		reference2 = transform.TransformPoint(x, num4, 0f);
		ref Vector3 reference3 = ref mCorners[2];
		reference3 = transform.TransformPoint(num3, y, 0f);
		ref Vector3 reference4 = ref mCorners[3];
		reference4 = transform.TransformPoint(x, num2, 0f);
		if (relativeTo != null)
		{
			for (int i = 0; i < 4; i++)
			{
				ref Vector3 reference5 = ref mCorners[i];
				reference5 = relativeTo.InverseTransformPoint(mCorners[i]);
			}
		}
		return mCorners;
	}

	public override float CalculateFinalAlpha(int frameID)
	{
		if (mAlphaFrameID != frameID)
		{
			mAlphaFrameID = frameID;
			UpdateFinalAlpha(frameID);
		}
		return finalAlpha;
	}

	protected void UpdateFinalAlpha(int frameID)
	{
		if (!mIsVisibleByAlpha || !mIsInFront)
		{
			finalAlpha = 0f;
			return;
		}
		UIRect uIRect = base.parent;
		finalAlpha = ((!(base.parent != null)) ? mColor.a : (uIRect.CalculateFinalAlpha(frameID) * mColor.a));
	}

	public override void Invalidate(bool includeChildren)
	{
		mChanged = true;
		mAlphaFrameID = -1;
		if (panel != null)
		{
			bool visibleByPanel = (!hideIfOffScreen && !panel.hasCumulativeClipping) || panel.IsVisible(this);
			UpdateVisibility(CalculateCumulativeAlpha(Time.frameCount) > 0.001f, visibleByPanel);
			UpdateFinalAlpha(Time.frameCount);
			if (includeChildren)
			{
				base.Invalidate(includeChildren: true);
			}
		}
	}

	public float CalculateCumulativeAlpha(int frameID)
	{
		UIRect uIRect = base.parent;
		return (!(uIRect != null)) ? mColor.a : (uIRect.CalculateFinalAlpha(frameID) * mColor.a);
	}

	public override void SetRect(float x, float y, float width, float height)
	{
		Vector2 vector = pivotOffset;
		float num = Mathf.Lerp(x, x + width, vector.x);
		float num2 = Mathf.Lerp(y, y + height, vector.y);
		int num3 = Mathf.FloorToInt(width + 0.5f);
		int num4 = Mathf.FloorToInt(height + 0.5f);
		if (vector.x == 0.5f)
		{
			num3 = num3 >> 1 << 1;
		}
		if (vector.y == 0.5f)
		{
			num4 = num4 >> 1 << 1;
		}
		Transform transform = base.cachedTransform;
		Vector3 localPosition = transform.localPosition;
		localPosition.x = Mathf.Floor(num + 0.5f);
		localPosition.y = Mathf.Floor(num2 + 0.5f);
		if (num3 < minWidth)
		{
			num3 = minWidth;
		}
		if (num4 < minHeight)
		{
			num4 = minHeight;
		}
		transform.localPosition = localPosition;
		this.width = num3;
		this.height = num4;
		if (base.isAnchored)
		{
			transform = transform.parent;
			if ((bool)leftAnchor.target)
			{
				leftAnchor.SetHorizontal(transform, x);
			}
			if ((bool)rightAnchor.target)
			{
				rightAnchor.SetHorizontal(transform, x + width);
			}
			if ((bool)bottomAnchor.target)
			{
				bottomAnchor.SetVertical(transform, y);
			}
			if ((bool)topAnchor.target)
			{
				topAnchor.SetVertical(transform, y + height);
			}
		}
	}

	public void ResizeCollider()
	{
		if (NGUITools.GetActive(this))
		{
			NGUITools.UpdateWidgetCollider(base.gameObject);
		}
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static int FullCompareFunc(UIWidget left, UIWidget right)
	{
		int num = UIPanel.CompareFunc(left.panel, right.panel);
		return (num != 0) ? num : PanelCompareFunc(left, right);
	}

	[DebuggerHidden]
	[DebuggerStepThrough]
	public static int PanelCompareFunc(UIWidget left, UIWidget right)
	{
		if (left.mDepth < right.mDepth)
		{
			return -1;
		}
		if (left.mDepth > right.mDepth)
		{
			return 1;
		}
		Material material = left.material;
		Material material2 = right.material;
		if (material == material2)
		{
			return 0;
		}
		if (material != null)
		{
			return -1;
		}
		if (material2 != null)
		{
			return 1;
		}
		return (material.GetInstanceID() >= material2.GetInstanceID()) ? 1 : (-1);
	}

	public Bounds CalculateBounds()
	{
		return CalculateBounds(null);
	}

	public Bounds CalculateBounds(Transform relativeParent)
	{
		if (relativeParent == null)
		{
			Vector3[] array = localCorners;
			Bounds result = new Bounds(array[0], Vector3.zero);
			for (int i = 1; i < 4; i++)
			{
				result.Encapsulate(array[i]);
			}
			return result;
		}
		Matrix4x4 worldToLocalMatrix = relativeParent.worldToLocalMatrix;
		Vector3[] array2 = worldCorners;
		Bounds result2 = new Bounds(worldToLocalMatrix.MultiplyPoint3x4(array2[0]), Vector3.zero);
		for (int j = 1; j < 4; j++)
		{
			result2.Encapsulate(worldToLocalMatrix.MultiplyPoint3x4(array2[j]));
		}
		return result2;
	}

	public void SetDirty()
	{
		if (drawCall != null)
		{
			drawCall.isDirty = true;
		}
		else if (isVisible && hasVertices)
		{
			CreatePanel();
		}
	}

	public void RemoveFromPanel()
	{
		if (panel != null)
		{
			panel.RemoveWidget(this);
			panel = null;
		}
		drawCall = null;
	}

	public virtual void MarkAsChanged()
	{
		if (NGUITools.GetActive(this))
		{
			mChanged = true;
			if (panel != null && base.enabled && NGUITools.GetActive(base.gameObject) && !mPlayMode)
			{
				SetDirty();
				CheckLayer();
			}
		}
	}

	public UIPanel CreatePanel()
	{
		if (mStarted && panel == null && base.enabled && NGUITools.GetActive(base.gameObject))
		{
			panel = UIPanel.Find(base.cachedTransform, createIfMissing: true, base.cachedGameObject.layer);
			if (panel != null)
			{
				mParentFound = false;
				panel.AddWidget(this);
				CheckLayer();
				Invalidate(includeChildren: true);
			}
		}
		return panel;
	}

	public void CheckLayer()
	{
		if (panel != null && panel.gameObject.layer != base.gameObject.layer)
		{
			UnityEngine.Debug.LogWarning("You can't place widgets on a layer different than the UIPanel that manages them.\nIf you want to move widgets to a different layer, parent them to a new panel instead.", this);
			base.gameObject.layer = panel.gameObject.layer;
		}
	}

	public override void ParentHasChanged()
	{
		base.ParentHasChanged();
		if (panel != null)
		{
			UIPanel uIPanel = UIPanel.Find(base.cachedTransform, createIfMissing: true, base.cachedGameObject.layer);
			if (panel != uIPanel)
			{
				RemoveFromPanel();
				CreatePanel();
			}
		}
	}

	protected virtual void Awake()
	{
		mGo = base.gameObject;
		mPlayMode = Application.isPlaying;
	}

	protected override void OnInit()
	{
		base.OnInit();
		RemoveFromPanel();
		mMoved = true;
		if (mWidth == 100 && mHeight == 100 && base.cachedTransform.localScale.magnitude > 8f)
		{
			UpgradeFrom265();
			base.cachedTransform.localScale = Vector3.one;
		}
		Update();
	}

	protected virtual void UpgradeFrom265()
	{
		Vector3 localScale = base.cachedTransform.localScale;
		mWidth = Mathf.Abs(Mathf.RoundToInt(localScale.x));
		mHeight = Mathf.Abs(Mathf.RoundToInt(localScale.y));
		NGUITools.UpdateWidgetCollider(base.gameObject, considerInactive: true);
	}

	protected override void OnStart()
	{
		CreatePanel();
	}

	protected override void OnAnchor()
	{
		Transform transform = base.cachedTransform;
		Transform transform2 = transform.parent;
		Vector3 localPosition = transform.localPosition;
		Vector2 vector = pivotOffset;
		float num;
		float num2;
		float num3;
		float num4;
		if (leftAnchor.target == bottomAnchor.target && leftAnchor.target == rightAnchor.target && leftAnchor.target == topAnchor.target)
		{
			Vector3[] sides = leftAnchor.GetSides(transform2);
			if (sides != null)
			{
				num = NGUIMath.Lerp(sides[0].x, sides[2].x, leftAnchor.relative) + (float)leftAnchor.absolute;
				num2 = NGUIMath.Lerp(sides[0].x, sides[2].x, rightAnchor.relative) + (float)rightAnchor.absolute;
				num3 = NGUIMath.Lerp(sides[3].y, sides[1].y, bottomAnchor.relative) + (float)bottomAnchor.absolute;
				num4 = NGUIMath.Lerp(sides[3].y, sides[1].y, topAnchor.relative) + (float)topAnchor.absolute;
				mIsInFront = true;
			}
			else
			{
				Vector3 localPos = GetLocalPos(leftAnchor, transform2);
				num = localPos.x + (float)leftAnchor.absolute;
				num3 = localPos.y + (float)bottomAnchor.absolute;
				num2 = localPos.x + (float)rightAnchor.absolute;
				num4 = localPos.y + (float)topAnchor.absolute;
				mIsInFront = !hideIfOffScreen || localPos.z >= 0f;
			}
		}
		else
		{
			mIsInFront = true;
			if ((bool)leftAnchor.target)
			{
				Vector3[] sides2 = leftAnchor.GetSides(transform2);
				num = ((sides2 == null) ? (GetLocalPos(leftAnchor, transform2).x + (float)leftAnchor.absolute) : (NGUIMath.Lerp(sides2[0].x, sides2[2].x, leftAnchor.relative) + (float)leftAnchor.absolute));
			}
			else
			{
				num = localPosition.x - vector.x * (float)mWidth;
			}
			if ((bool)rightAnchor.target)
			{
				Vector3[] sides3 = rightAnchor.GetSides(transform2);
				num2 = ((sides3 == null) ? (GetLocalPos(rightAnchor, transform2).x + (float)rightAnchor.absolute) : (NGUIMath.Lerp(sides3[0].x, sides3[2].x, rightAnchor.relative) + (float)rightAnchor.absolute));
			}
			else
			{
				num2 = localPosition.x - vector.x * (float)mWidth + (float)mWidth;
			}
			if ((bool)bottomAnchor.target)
			{
				Vector3[] sides4 = bottomAnchor.GetSides(transform2);
				num3 = ((sides4 == null) ? (GetLocalPos(bottomAnchor, transform2).y + (float)bottomAnchor.absolute) : (NGUIMath.Lerp(sides4[3].y, sides4[1].y, bottomAnchor.relative) + (float)bottomAnchor.absolute));
			}
			else
			{
				num3 = localPosition.y - vector.y * (float)mHeight;
			}
			if ((bool)topAnchor.target)
			{
				Vector3[] sides5 = topAnchor.GetSides(transform2);
				num4 = ((sides5 == null) ? (GetLocalPos(topAnchor, transform2).y + (float)topAnchor.absolute) : (NGUIMath.Lerp(sides5[3].y, sides5[1].y, topAnchor.relative) + (float)topAnchor.absolute));
			}
			else
			{
				num4 = localPosition.y - vector.y * (float)mHeight + (float)mHeight;
			}
		}
		Vector3 vector2 = new Vector3(Mathf.Lerp(num, num2, vector.x), Mathf.Lerp(num3, num4, vector.y), localPosition.z);
		int num5 = Mathf.FloorToInt(num2 - num + 0.5f);
		int num6 = Mathf.FloorToInt(num4 - num3 + 0.5f);
		if (keepAspectRatio != 0 && aspectRatio != 0f)
		{
			if (keepAspectRatio == AspectRatioSource.BasedOnHeight)
			{
				num5 = Mathf.RoundToInt((float)num6 * aspectRatio);
			}
			else
			{
				num6 = Mathf.RoundToInt((float)num5 / aspectRatio);
			}
		}
		if (num5 < minWidth)
		{
			num5 = minWidth;
		}
		if (num6 < minHeight)
		{
			num6 = minHeight;
		}
		if (Vector3.SqrMagnitude(localPosition - vector2) > 0.001f)
		{
			base.cachedTransform.localPosition = vector2;
			if (mIsInFront)
			{
				mChanged = true;
			}
		}
		if (mWidth != num5 || mHeight != num6)
		{
			mWidth = num5;
			mHeight = num6;
			if (mIsInFront)
			{
				mChanged = true;
			}
			if (autoResizeBoxCollider)
			{
				ResizeCollider();
			}
		}
	}

	protected override void OnUpdate()
	{
		if (panel == null)
		{
			CreatePanel();
		}
	}

	private void OnApplicationPause(bool paused)
	{
		if (!paused)
		{
			MarkAsChanged();
		}
	}

	protected override void OnDisable()
	{
		RemoveFromPanel();
		base.OnDisable();
	}

	private void OnDestroy()
	{
		RemoveFromPanel();
	}

	public bool UpdateVisibility(bool visibleByAlpha, bool visibleByPanel)
	{
		if (mIsVisibleByAlpha != visibleByAlpha || mIsVisibleByPanel != visibleByPanel)
		{
			mChanged = true;
			mIsVisibleByAlpha = visibleByAlpha;
			mIsVisibleByPanel = visibleByPanel;
			return true;
		}
		return false;
	}

	public bool UpdateTransform(int frame)
	{
		if (!mMoved && !panel.widgetsAreStatic && base.cachedTransform.hasChanged)
		{
			mTrans.hasChanged = false;
			mLocalToPanel = panel.worldToLocal * base.cachedTransform.localToWorldMatrix;
			mMatrixFrame = frame;
			Vector2 vector = pivotOffset;
			float num = (0f - vector.x) * (float)mWidth;
			float num2 = (0f - vector.y) * (float)mHeight;
			float x = num + (float)mWidth;
			float y = num2 + (float)mHeight;
			Transform transform = base.cachedTransform;
			Vector3 v = transform.TransformPoint(num, num2, 0f);
			Vector3 v2 = transform.TransformPoint(x, y, 0f);
			v = panel.worldToLocal.MultiplyPoint3x4(v);
			v2 = panel.worldToLocal.MultiplyPoint3x4(v2);
			if (Vector3.SqrMagnitude(mOldV0 - v) > 1E-06f || Vector3.SqrMagnitude(mOldV1 - v2) > 1E-06f)
			{
				mMoved = true;
				mOldV0 = v;
				mOldV1 = v2;
			}
		}
		if (mMoved && onChange != null)
		{
			onChange();
		}
		return mMoved || mChanged;
	}

	public bool UpdateGeometry(int frame)
	{
		float num = CalculateFinalAlpha(frame);
		if (mIsVisibleByAlpha && mLastAlpha != num)
		{
			mChanged = true;
		}
		mLastAlpha = num;
		if (mChanged)
		{
			mChanged = false;
			if (mIsVisibleByAlpha && num > 0.001f && shader != null)
			{
				bool result = geometry.hasVertices;
				if (fillGeometry)
				{
					geometry.Clear();
					OnFill(geometry.verts, geometry.uvs, geometry.cols);
				}
				if (geometry.hasVertices)
				{
					if (mMatrixFrame != frame)
					{
						mLocalToPanel = panel.worldToLocal * base.cachedTransform.localToWorldMatrix;
						mMatrixFrame = frame;
					}
					geometry.ApplyTransform(mLocalToPanel);
					mMoved = false;
					return true;
				}
				return result;
			}
			if (geometry.hasVertices)
			{
				if (fillGeometry)
				{
					geometry.Clear();
				}
				mMoved = false;
				return true;
			}
		}
		else if (mMoved && geometry.hasVertices)
		{
			if (mMatrixFrame != frame)
			{
				mLocalToPanel = panel.worldToLocal * base.cachedTransform.localToWorldMatrix;
				mMatrixFrame = frame;
			}
			geometry.ApplyTransform(mLocalToPanel);
			mMoved = false;
			return true;
		}
		mMoved = false;
		return false;
	}

	public void WriteToBuffers(BetterList<Vector3> v, BetterList<Vector2> u, BetterList<Color32> c, BetterList<Vector3> n, BetterList<Vector4> t)
	{
		geometry.WriteToBuffers(v, u, c, n, t);
	}

	public virtual void MakePixelPerfect()
	{
		Vector3 localPosition = base.cachedTransform.localPosition;
		localPosition.z = Mathf.Round(localPosition.z);
		localPosition.x = Mathf.Round(localPosition.x);
		localPosition.y = Mathf.Round(localPosition.y);
		base.cachedTransform.localPosition = localPosition;
		Vector3 localScale = base.cachedTransform.localScale;
		base.cachedTransform.localScale = new Vector3(Mathf.Sign(localScale.x), Mathf.Sign(localScale.y), 1f);
	}

	public virtual void OnFill(BetterList<Vector3> verts, BetterList<Vector2> uvs, BetterList<Color32> cols)
	{
	}
}
[ExecuteInEditMode]
public class AnimatedAlpha : MonoBehaviour
{
	[Range(0f, 1f)]
	public float alpha = 1f;

	private UIWidget mWidget;

	private UIPanel mPanel;

	private void OnEnable()
	{
		mWidget = GetComponent<UIWidget>();
		mPanel = GetComponent<UIPanel>();
		LateUpdate();
	}

	private void LateUpdate()
	{
		if (mWidget != null)
		{
			mWidget.alpha = alpha;
		}
		if (mPanel != null)
		{
			mPanel.alpha = alpha;
		}
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(UIWidget))]
public class AnimatedColor : MonoBehaviour
{
	public UnityEngine.Color color = UnityEngine.Color.white;

	private UIWidget mWidget;

	private void OnEnable()
	{
		mWidget = GetComponent<UIWidget>();
		LateUpdate();
	}

	private void LateUpdate()
	{
		mWidget.color = color;
	}
}
[ExecuteInEditMode]
public class AnimatedWidget : MonoBehaviour
{
	public float width = 1f;

	public float height = 1f;

	private UIWidget mWidget;

	private void OnEnable()
	{
		mWidget = GetComponent<UIWidget>();
		LateUpdate();
	}

	private void LateUpdate()
	{
		if (mWidget != null)
		{
			mWidget.width = Mathf.RoundToInt(width);
			mWidget.height = Mathf.RoundToInt(height);
		}
	}
}
[AddComponentMenu("NGUI/Tween/Spring Position")]
public class SpringPosition : MonoBehaviour
{
	public delegate void OnFinished();

	public static SpringPosition current;

	public Vector3 target = Vector3.zero;

	public float strength = 10f;

	public bool worldSpace;

	public bool ignoreTimeScale;

	public bool updateScrollView;

	public OnFinished onFinished;

	[SerializeField]
	[HideInInspector]
	private GameObject eventReceiver;

	[SerializeField]
	[HideInInspector]
	public string callWhenFinished;

	private Transform mTrans;

	private float mThreshold;

	private UIScrollView mSv;

	private void Start()
	{
		mTrans = base.transform;
		if (updateScrollView)
		{
			mSv = NGUITools.FindInParents<UIScrollView>(base.gameObject);
		}
	}

	private void Update()
	{
		float deltaTime = ((!ignoreTimeScale) ? Time.deltaTime : RealTime.deltaTime);
		if (worldSpace)
		{
			if (mThreshold == 0f)
			{
				mThreshold = (target - mTrans.position).sqrMagnitude * 0.001f;
			}
			mTrans.position = NGUIMath.SpringLerp(mTrans.position, target, strength, deltaTime);
			if (mThreshold >= (target - mTrans.position).sqrMagnitude)
			{
				mTrans.position = target;
				NotifyListeners();
				base.enabled = false;
			}
		}
		else
		{
			if (mThreshold == 0f)
			{
				mThreshold = (target - mTrans.localPosition).sqrMagnitude * 1E-05f;
			}
			mTrans.localPosition = NGUIMath.SpringLerp(mTrans.localPosition, target, strength, deltaTime);
			if (mThreshold >= (target - mTrans.localPosition).sqrMagnitude)
			{
				mTrans.localPosition = target;
				NotifyListeners();
				base.enabled = false;
			}
		}
		if (mSv != null)
		{
			mSv.UpdateScrollbars(recalculateBounds: true);
		}
	}

	private void NotifyListeners()
	{
		current = this;
		if (onFinished != null)
		{
			onFinished();
		}
		if (eventReceiver != null && !string.IsNullOrEmpty(callWhenFinished))
		{
			eventReceiver.SendMessage(callWhenFinished, this, SendMessageOptions.DontRequireReceiver);
		}
		current = null;
	}

	public static SpringPosition Begin(GameObject go, Vector3 pos, float strength)
	{
		SpringPosition springPosition = go.GetComponent<SpringPosition>();
		if (springPosition == null)
		{
			springPosition = go.AddComponent<SpringPosition>();
		}
		springPosition.target = pos;
		springPosition.strength = strength;
		springPosition.onFinished = null;
		if (!springPosition.enabled)
		{
			springPosition.mThreshold = 0f;
			springPosition.enabled = true;
		}
		return springPosition;
	}
}
[AddComponentMenu("NGUI/Tween/Tween Alpha")]
public class TweenAlpha : UITweener
{
	[Range(0f, 1f)]
	public float from = 1f;

	[Range(0f, 1f)]
	public float to = 1f;

	private bool mCached;

	private UIRect mRect;

	private Material mMat;

	private SpriteRenderer mSr;

	[Obsolete("Use 'value' instead")]
	public float alpha
	{
		get
		{
			return value;
		}
		set
		{
			this.value = value;
		}
	}

	public float value
	{
		get
		{
			if (!mCached)
			{
				Cache();
			}
			if (mRect != null)
			{
				return mRect.alpha;
			}
			if (mSr != null)
			{
				return mSr.color.a;
			}
			return (!(mMat != null)) ? 1f : mMat.color.a;
		}
		set
		{
			if (!mCached)
			{
				Cache();
			}
			if (mRect != null)
			{
				mRect.alpha = value;
			}
			else if (mSr != null)
			{
				UnityEngine.Color color = mSr.color;
				color.a = value;
				mSr.color = color;
			}
			else if (mMat != null)
			{
				UnityEngine.Color color2 = mMat.color;
				color2.a = value;
				mMat.color = color2;
			}
		}
	}

	private void Cache()
	{
		mCached = true;
		mRect = GetComponent<UIRect>();
		mSr = GetComponent<SpriteRenderer>();
		if (mRect == null && mSr == null)
		{
			Renderer component = GetComponent<Renderer>();
			if (component != null)
			{
				mMat = component.material;
			}
			if (mMat == null)
			{
				mRect = GetComponentInChildren<UIRect>();
			}
		}
	}

	protected override void OnUpdate(float factor, bool isFinished)
	{
		value = Mathf.Lerp(from, to, factor);
	}

	public static TweenAlpha Begin(GameObject go, float duration, float alpha)
	{
		TweenAlpha tweenAlpha = UITweener.Begin<TweenAlpha>(go, duration);
		tweenAlpha.from = tweenAlpha.value;
		tweenAlpha.to = alpha;
		if (duration <= 0f)
		{
			tweenAlpha.Sample(1f, isFinished: true);
			tweenAlpha.enabled = false;
		}
		return tweenAlpha;
	}

	public override void SetStartToCurrentValue()
	{
		from = value;
	}

	public override void SetEndToCurrentValue()
	{
		to = value;
	}
}
[AddComponentMenu("NGUI/Tween/Tween Color")]
public class TweenColor : UITweener
{
	public UnityEngine.Color from = UnityEngine.Color.white;

	public UnityEngine.Color to = UnityEngine.Color.white;

	private bool mCached;

	private UIWidget mWidget;

	private Material mMat;

	private Light mLight;

	private SpriteRenderer mSr;

	[Obsolete("Use 'value' instead")]
	public UnityEngine.Color color
	{
		get
		{
			return value;
		}
		set
		{
			this.value = value;
		}
	}

	public UnityEngine.Color value
	{
		get
		{
			if (!mCached)
			{
				Cache();
			}
			if (mWidget != null)
			{
				return mWidget.color;
			}
			if (mMat != null)
			{
				return mMat.color;
			}
			if (mSr != null)
			{
				return mSr.color;
			}
			if (mLight != null)
			{
				return mLight.color;
			}
			return UnityEngine.Color.black;
		}
		set
		{
			if (!mCached)
			{
				Cache();
			}
			if (mWidget != null)
			{
				mWidget.color = value;
			}
			else if (mMat != null)
			{
				mMat.color = value;
			}
			else if (mSr != null)
			{
				mSr.color = value;
			}
			else if (mLight != null)
			{
				mLight.color = value;
				mLight.enabled = value.r + value.g + value.b > 0.01f;
			}
		}
	}

	private void Cache()
	{
		mCached = true;
		mWidget = GetComponent<UIWidget>();
		if (mWidget != null)
		{
			return;
		}
		mSr = GetComponent<SpriteRenderer>();
		if (mSr != null)
		{
			return;
		}
		Renderer component = GetComponent<Renderer>();
		if (component != null)
		{
			mMat = component.material;
			return;
		}
		mLight = GetComponent<Light>();
		if (mLight == null)
		{
			mWidget = GetComponentInChildren<UIWidget>();
		}
	}

	protected override void OnUpdate(float factor, bool isFinished)
	{
		value = UnityEngine.Color.Lerp(from, to, factor);
	}

	public static TweenColor Begin(GameObject go, float duration, UnityEngine.Color color)
	{
		TweenColor tweenColor = UITweener.Begin<TweenColor>(go, duration);
		tweenColor.from = tweenColor.value;
		tweenColor.to = color;
		if (duration <= 0f)
		{
			tweenColor.Sample(1f, isFinished: true);
			tweenColor.enabled = false;
		}
		return tweenColor;
	}

	[ContextMenu("Set 'From' to current value")]
	public override void SetStartToCurrentValue()
	{
		from = value;
	}

	[ContextMenu("Set 'To' to current value")]
	public override void SetEndToCurrentValue()
	{
		to = value;
	}

	[ContextMenu("Assume value of 'From'")]
	private void SetCurrentValueToStart()
	{
		value = from;
	}

	[ContextMenu("Assume value of 'To'")]
	private void SetCurrentValueToEnd()
	{
		value = to;
	}
}
[RequireComponent(typeof(Camera))]
[AddComponentMenu("NGUI/Tween/Tween Field of View")]
public class TweenFOV : UITweener
{
	public float from = 45f;

	public float to = 45f;

	private Camera mCam;

	public Camera cachedCamera
	{
		get
		{
			if (mCam == null)
			{
				mCam = GetComponent<Camera>();
			}
			return mCam;
		}
	}

	[Obsolete("Use 'value' instead")]
	public float fov
	{
		get
		{
			return value;
		}
		set
		{
			this.value = value;
		}
	}

	public float value
	{
		get
		{
			return cachedCamera.fieldOfView;
		}
		set
		{
			cachedCamera.fieldOfView = value;
		}
	}

	protected override void OnUpdate(float factor, bool isFinished)
	{
		value = from * (1f - factor) + to * factor;
	}

	public static TweenFOV Begin(GameObject go, float duration, float to)
	{
		TweenFOV tweenFOV = UITweener.Begin<TweenFOV>(go, duration);
		tweenFOV.from = tweenFOV.value;
		tweenFOV.to = to;
		if (duration <= 0f)
		{
			tweenFOV.Sample(1f, isFinished: true);
			tweenFOV.enabled = false;
		}
		return tweenFOV;
	}

	[ContextMenu("Set 'From' to current value")]
	public override void SetStartToCurrentValue()
	{
		from = value;
	}

	[ContextMenu("Set 'To' to current value")]
	public override void SetEndToCurrentValue()
	{
		to = value;
	}

	[ContextMenu("Assume value of 'From'")]
	private void SetCurrentValueToStart()
	{
		value = from;
	}

	[ContextMenu("Assume value of 'To'")]
	private void SetCurrentValueToEnd()
	{
		value = to;
	}
}
[RequireComponent(typeof(UIWidget))]
[AddComponentMenu("NGUI/Tween/Tween Height")]
public class TweenHeight : UITweener
{
	public int from = 100;

	public int to = 100;

	public bool updateTable;

	private UIWidget mWidget;

	private UITable mTable;

	public UIWidget cachedWidget
	{
		get
		{
			if (mWidget == null)
			{
				mWidget = GetComponent<UIWidget>();
			}
			return mWidget;
		}
	}

	[Obsolete("Use 'value' instead")]
	public int height
	{
		get
		{
			return value;
		}
		set
		{
			this.value = value;
		}
	}

	public int value
	{
		get
		{
			return cachedWidget.height;
		}
		set
		{
			cachedWidget.height = value;
		}
	}

	protected override void OnUpdate(float factor, bool isFinished)
	{
		value = Mathf.RoundToInt((float)from * (1f - factor) + (float)to * factor);
		if (!updateTable)
		{
			return;
		}
		if (mTable == null)
		{
			mTable = NGUITools.FindInParents<UITable>(base.gameObject);
			if (mTable == null)
			{
				updateTable = false;
				return;
			}
		}
		mTable.repositionNow = true;
	}

	public static TweenHeight Begin(UIWidget widget, float duration, int height)
	{
		TweenHeight tweenHeight = UITweener.Begin<TweenHeight>(widget.gameObject, duration);
		tweenHeight.from = widget.height;
		tweenHeight.to = height;
		if (duration <= 0f)
		{
			tweenHeight.Sample(1f, isFinished: true);
			tweenHeight.enabled = false;
		}
		return tweenHeight;
	}

	[ContextMenu("Set 'From' to current value")]
	public override void SetStartToCurrentValue()
	{
		from = value;
	}

	[ContextMenu("Set 'To' to current value")]
	public override void SetEndToCurrentValue()
	{
		to = value;
	}

	[ContextMenu("Assume value of 'From'")]
	private void SetCurrentValueToStart()
	{
		value = from;
	}

	[ContextMenu("Assume value of 'To'")]
	private void SetCurrentValueToEnd()
	{
		value = to;
	}
}
[RequireComponent(typeof(Camera))]
[AddComponentMenu("NGUI/Tween/Tween Orthographic Size")]
public class TweenOrthoSize : UITweener
{
	public float from = 1f;

	public float to = 1f;

	private Camera mCam;

	public Camera cachedCamera
	{
		get
		{
			if (mCam == null)
			{
				mCam = GetComponent<Camera>();
			}
			return mCam;
		}
	}

	[Obsolete("Use 'value' instead")]
	public float orthoSize
	{
		get
		{
			return value;
		}
		set
		{
			this.value = value;
		}
	}

	public float value
	{
		get
		{
			return cachedCamera.orthographicSize;
		}
		set
		{
			cachedCamera.orthographicSize = value;
		}
	}

	protected override void OnUpdate(float factor, bool isFinished)
	{
		value = from * (1f - factor) + to * factor;
	}

	public static TweenOrthoSize Begin(GameObject go, float duration, float to)
	{
		TweenOrthoSize tweenOrthoSize = UITweener.Begin<TweenOrthoSize>(go, duration);
		tweenOrthoSize.from = tweenOrthoSize.value;
		tweenOrthoSize.to = to;
		if (duration <= 0f)
		{
			tweenOrthoSize.Sample(1f, isFinished: true);
			tweenOrthoSize.enabled = false;
		}
		return tweenOrthoSize;
	}

	public override void SetStartToCurrentValue()
	{
		from = value;
	}

	public override void SetEndToCurrentValue()
	{
		to = value;
	}
}
[AddComponentMenu("NGUI/Tween/Tween Position")]
public class TweenPosition : UITweener
{
	public Vector3 from;

	public Vector3 to;

	[HideInInspector]
	public bool worldSpace;

	private Transform mTrans;

	private UIRect mRect;

	public Transform cachedTransform
	{
		get
		{
			if (mTrans == null)
			{
				mTrans = base.transform;
			}
			return mTrans;
		}
	}

	[Obsolete("Use 'value' instead")]
	public Vector3 position
	{
		get
		{
			return value;
		}
		set
		{
			this.value = value;
		}
	}

	public Vector3 value
	{
		get
		{
			return (!worldSpace) ? cachedTransform.localPosition : cachedTransform.position;
		}
		set
		{
			if (mRect == null || !mRect.isAnchored || worldSpace)
			{
				if (worldSpace)
				{
					cachedTransform.position = value;
				}
				else
				{
					cachedTransform.localPosition = value;
				}
			}
			else
			{
				value -= cachedTransform.localPosition;
				NGUIMath.MoveRect(mRect, value.x, value.y);
			}
		}
	}

	private void Awake()
	{
		mRect = GetComponent<UIRect>();
	}

	protected override void OnUpdate(float factor, bool isFinished)
	{
		value = from * (1f - factor) + to * factor;
	}

	public static TweenPosition Begin(GameObject go, float duration, Vector3 pos)
	{
		TweenPosition tweenPosition = UITweener.Begin<TweenPosition>(go, duration);
		tweenPosition.from = tweenPosition.value;
		tweenPosition.to = pos;
		if (duration <= 0f)
		{
			tweenPosition.Sample(1f, isFinished: true);
			tweenPosition.enabled = false;
		}
		return tweenPosition;
	}

	public static TweenPosition Begin(GameObject go, float duration, Vector3 pos, bool worldSpace)
	{
		TweenPosition tweenPosition = UITweener.Begin<TweenPosition>(go, duration);
		tweenPosition.worldSpace = worldSpace;
		tweenPosition.from = tweenPosition.value;
		tweenPosition.to = pos;
		if (duration <= 0f)
		{
			tweenPosition.Sample(1f, isFinished: true);
			tweenPosition.enabled = false;
		}
		return tweenPosition;
	}

	[ContextMenu("Set 'From' to current value")]
	public override void SetStartToCurrentValue()
	{
		from = value;
	}

	[ContextMenu("Set 'To' to current value")]
	public override void SetEndToCurrentValue()
	{
		to = value;
	}

	[ContextMenu("Assume value of 'From'")]
	private void SetCurrentValueToStart()
	{
		value = from;
	}

	[ContextMenu("Assume value of 'To'")]
	private void SetCurrentValueToEnd()
	{
		value = to;
	}
}
[AddComponentMenu("NGUI/Tween/Tween Rotation")]
public class TweenRotation : UITweener
{
	public Vector3 from;

	public Vector3 to;

	private Transform mTrans;

	public Transform cachedTransform
	{
		get
		{
			if (mTrans == null)
			{
				mTrans = base.transform;
			}
			return mTrans;
		}
	}

	[Obsolete("Use 'value' instead")]
	public Quaternion rotation
	{
		get
		{
			return value;
		}
		set
		{
			this.value = value;
		}
	}

	public Quaternion value
	{
		get
		{
			return cachedTransform.localRotation;
		}
		set
		{
			cachedTransform.localRotation = value;
		}
	}

	protected override void OnUpdate(float factor, bool isFinished)
	{
		value = Quaternion.Euler(new Vector3(Mathf.Lerp(from.x, to.x, factor), Mathf.Lerp(from.y, to.y, factor), Mathf.Lerp(from.z, to.z, factor)));
	}

	public static TweenRotation Begin(GameObject go, float duration, Quaternion rot)
	{
		TweenRotation tweenRotation = UITweener.Begin<TweenRotation>(go, duration);
		tweenRotation.from = tweenRotation.value.eulerAngles;
		tweenRotation.to = rot.eulerAngles;
		if (duration <= 0f)
		{
			tweenRotation.Sample(1f, isFinished: true);
			tweenRotation.enabled = false;
		}
		return tweenRotation;
	}

	[ContextMenu("Set 'From' to current value")]
	public override void SetStartToCurrentValue()
	{
		from = value.eulerAngles;
	}

	[ContextMenu("Set 'To' to current value")]
	public override void SetEndToCurrentValue()
	{
		to = value.eulerAngles;
	}

	[ContextMenu("Assume value of 'From'")]
	private void SetCurrentValueToStart()
	{
		value = Quaternion.Euler(from);
	}

	[ContextMenu("Assume value of 'To'")]
	private void SetCurrentValueToEnd()
	{
		value = Quaternion.Euler(to);
	}
}
[AddComponentMenu("NGUI/Tween/Tween Scale")]
public class TweenScale : UITweener
{
	public Vector3 from = Vector3.one;

	public Vector3 to = Vector3.one;

	public bool updateTable;

	private Transform mTrans;

	private UITable mTable;

	public Transform cachedTransform
	{
		get
		{
			if (mTrans == null)
			{
				mTrans = base.transform;
			}
			return mTrans;
		}
	}

	public Vector3 value
	{
		get
		{
			return cachedTransform.localScale;
		}
		set
		{
			cachedTransform.localScale = value;
		}
	}

	[Obsolete("Use 'value' instead")]
	public Vector3 scale
	{
		get
		{
			return value;
		}
		set
		{
			this.value = value;
		}
	}

	protected override void OnUpdate(float factor, bool isFinished)
	{
		value = from * (1f - factor) + to * factor;
		if (!updateTable)
		{
			return;
		}
		if (mTable == null)
		{
			mTable = NGUITools.FindInParents<UITable>(base.gameObject);
			if (mTable == null)
			{
				updateTable = false;
				return;
			}
		}
		mTable.repositionNow = true;
	}

	public static TweenScale Begin(GameObject go, float duration, Vector3 scale)
	{
		TweenScale tweenScale = UITweener.Begin<TweenScale>(go, duration);
		tweenScale.from = tweenScale.value;
		tweenScale.to = scale;
		if (duration <= 0f)
		{
			tweenScale.Sample(1f, isFinished: true);
			tweenScale.enabled = false;
		}
		return tweenScale;
	}

	[ContextMenu("Set 'From' to current value")]
	public override void SetStartToCurrentValue()
	{
		from = value;
	}

	[ContextMenu("Set 'To' to current value")]
	public override void SetEndToCurrentValue()
	{
		to = value;
	}

	[ContextMenu("Assume value of 'From'")]
	private void SetCurrentValueToStart()
	{
		value = from;
	}

	[ContextMenu("Assume value of 'To'")]
	private void SetCurrentValueToEnd()
	{
		value = to;
	}
}
[AddComponentMenu("NGUI/Tween/Tween Transform")]
public class TweenTransform : UITweener
{
	public Transform from;

	public Transform to;

	public bool parentWhenFinished;

	private Transform mTrans;

	private Vector3 mPos;

	private Quaternion mRot;

	private Vector3 mScale;

	protected override void OnUpdate(float factor, bool isFinished)
	{
		if (to != null)
		{
			if (mTrans == null)
			{
				mTrans = base.transform;
				mPos = mTrans.position;
				mRot = mTrans.rotation;
				mScale = mTrans.localScale;
			}
			if (from != null)
			{
				mTrans.position = from.position * (1f - factor) + to.position * factor;
				mTrans.localScale = from.localScale * (1f - factor) + to.localScale * factor;
				mTrans.rotation = Quaternion.Slerp(from.rotation, to.rotation, factor);
			}
			else
			{
				mTrans.position = mPos * (1f - factor) + to.position * factor;
				mTrans.localScale = mScale * (1f - factor) + to.localScale * factor;
				mTrans.rotation = Quaternion.Slerp(mRot, to.rotation, factor);
			}
			if (parentWhenFinished && isFinished)
			{
				mTrans.parent = to;
			}
		}
	}

	public static TweenTransform Begin(GameObject go, float duration, Transform to)
	{
		return Begin(go, duration, null, to);
	}

	public static TweenTransform Begin(GameObject go, float duration, Transform from, Transform to)
	{
		TweenTransform tweenTransform = UITweener.Begin<TweenTransform>(go, duration);
		tweenTransform.from = from;
		tweenTransform.to = to;
		if (duration <= 0f)
		{
			tweenTransform.Sample(1f, isFinished: true);
			tweenTransform.enabled = false;
		}
		return tweenTransform;
	}
}
[RequireComponent(typeof(AudioSource))]
[AddComponentMenu("NGUI/Tween/Tween Volume")]
public class TweenVolume : UITweener
{
	[Range(0f, 1f)]
	public float from = 1f;

	[Range(0f, 1f)]
	public float to = 1f;

	private AudioSource mSource;

	public AudioSource audioSource
	{
		get
		{
			if (mSource == null)
			{
				mSource = GetComponent<AudioSource>();
				if (mSource == null)
				{
					mSource = GetComponent<AudioSource>();
					if (mSource == null)
					{
						UnityEngine.Debug.LogError("TweenVolume needs an AudioSource to work with", this);
						base.enabled = false;
					}
				}
			}
			return mSource;
		}
	}

	[Obsolete("Use 'value' instead")]
	public float volume
	{
		get
		{
			return value;
		}
		set
		{
			this.value = value;
		}
	}

	public float value
	{
		get
		{
			return (!(audioSource != null)) ? 0f : mSource.volume;
		}
		set
		{
			if (audioSource != null)
			{
				mSource.volume = value;
			}
		}
	}

	protected override void OnUpdate(float factor, bool isFinished)
	{
		value = from * (1f - factor) + to * factor;
		mSource.enabled = mSource.volume > 0.01f;
	}

	public static TweenVolume Begin(GameObject go, float duration, float targetVolume)
	{
		TweenVolume tweenVolume = UITweener.Begin<TweenVolume>(go, duration);
		tweenVolume.from = tweenVolume.value;
		tweenVolume.to = targetVolume;
		return tweenVolume;
	}

	public override void SetStartToCurrentValue()
	{
		from = value;
	}

	public override void SetEndToCurrentValue()
	{
		to = value;
	}
}
[RequireComponent(typeof(UIWidget))]
[AddComponentMenu("NGUI/Tween/Tween Width")]
public class TweenWidth : UITweener
{
	public int from = 100;

	public int to = 100;

	public bool updateTable;

	private UIWidget mWidget;

	private UITable mTable;

	public UIWidget cachedWidget
	{
		get
		{
			if (mWidget == null)
			{
				mWidget = GetComponent<UIWidget>();
			}
			return mWidget;
		}
	}

	[Obsolete("Use 'value' instead")]
	public int width
	{
		get
		{
			return value;
		}
		set
		{
			this.value = value;
		}
	}

	public int value
	{
		get
		{
			return cachedWidget.width;
		}
		set
		{
			cachedWidget.width = value;
		}
	}

	protected override void OnUpdate(float factor, bool isFinished)
	{
		value = Mathf.RoundToInt((float)from * (1f - factor) + (float)to * factor);
		if (!updateTable)
		{
			return;
		}
		if (mTable == null)
		{
			mTable = NGUITools.FindInParents<UITable>(base.gameObject);
			if (mTable == null)
			{
				updateTable = false;
				return;
			}
		}
		mTable.repositionNow = true;
	}

	public static TweenWidth Begin(UIWidget widget, float duration, int width)
	{
		TweenWidth tweenWidth = UITweener.Begin<TweenWidth>(widget.gameObject, duration);
		tweenWidth.from = widget.width;
		tweenWidth.to = width;
		if (duration <= 0f)
		{
			tweenWidth.Sample(1f, isFinished: true);
			tweenWidth.enabled = false;
		}
		return tweenWidth;
	}

	[ContextMenu("Set 'From' to current value")]
	public override void SetStartToCurrentValue()
	{
		from = value;
	}

	[ContextMenu("Set 'To' to current value")]
	public override void SetEndToCurrentValue()
	{
		to = value;
	}

	[ContextMenu("Assume value of 'From'")]
	private void SetCurrentValueToStart()
	{
		value = from;
	}

	[ContextMenu("Assume value of 'To'")]
	private void SetCurrentValueToEnd()
	{
		value = to;
	}
}
public abstract class UITweener : MonoBehaviour
{
	public enum Method
	{
		Linear,
		EaseIn,
		EaseOut,
		EaseInOut,
		BounceIn,
		BounceOut
	}

	public enum Style
	{
		Once,
		Loop,
		PingPong
	}

	public static UITweener current;

	[HideInInspector]
	public Method method;

	[HideInInspector]
	public Style style;

	[HideInInspector]
	public AnimationCurve animationCurve = new AnimationCurve(new Keyframe(0f, 0f, 0f, 1f), new Keyframe(1f, 1f, 1f, 0f));

	[HideInInspector]
	public bool ignoreTimeScale = true;

	[HideInInspector]
	public float delay;

	[HideInInspector]
	public float duration = 1f;

	[HideInInspector]
	public bool steeperCurves;

	[HideInInspector]
	public int tweenGroup;

	[HideInInspector]
	public List<EventDelegate> onFinished = new List<EventDelegate>();

	[HideInInspector]
	public GameObject eventReceiver;

	[HideInInspector]
	public string callWhenFinished;

	private bool mStarted;

	private float mStartTime;

	private float mDuration;

	private float mAmountPerDelta = 1000f;

	private float mFactor;

	private List<EventDelegate> mTemp;

	public float amountPerDelta
	{
		get
		{
			if (mDuration != duration)
			{
				mDuration = duration;
				mAmountPerDelta = Mathf.Abs((!(duration > 0f)) ? 1000f : (1f / duration)) * Mathf.Sign(mAmountPerDelta);
			}
			return mAmountPerDelta;
		}
	}

	public float tweenFactor
	{
		get
		{
			return mFactor;
		}
		set
		{
			mFactor = Mathf.Clamp01(value);
		}
	}

	public Direction direction => (!(amountPerDelta < 0f)) ? Direction.Forward : Direction.Reverse;

	private void Reset()
	{
		if (!mStarted)
		{
			SetStartToCurrentValue();
			SetEndToCurrentValue();
		}
	}

	protected virtual void Start()
	{
		Update();
	}

	private void Update()
	{
		float num = ((!ignoreTimeScale) ? Time.deltaTime : RealTime.deltaTime);
		float num2 = ((!ignoreTimeScale) ? Time.time : RealTime.time);
		if (!mStarted)
		{
			mStarted = true;
			mStartTime = num2 + delay;
		}
		if (num2 < mStartTime)
		{
			return;
		}
		mFactor += amountPerDelta * num;
		if (style == Style.Loop)
		{
			if (mFactor > 1f)
			{
				mFactor -= Mathf.Floor(mFactor);
			}
		}
		else if (style == Style.PingPong)
		{
			if (mFactor > 1f)
			{
				mFactor = 1f - (mFactor - Mathf.Floor(mFactor));
				mAmountPerDelta = 0f - mAmountPerDelta;
			}
			else if (mFactor < 0f)
			{
				mFactor = 0f - mFactor;
				mFactor -= Mathf.Floor(mFactor);
				mAmountPerDelta = 0f - mAmountPerDelta;
			}
		}
		if (style == Style.Once && (duration == 0f || mFactor > 1f || mFactor < 0f))
		{
			mFactor = Mathf.Clamp01(mFactor);
			Sample(mFactor, isFinished: true);
			if (duration == 0f || (mFactor == 1f && mAmountPerDelta > 0f) || (mFactor == 0f && mAmountPerDelta < 0f))
			{
				base.enabled = false;
			}
			if (!(current == null))
			{
				return;
			}
			current = this;
			if (onFinished != null)
			{
				mTemp = onFinished;
				onFinished = new List<EventDelegate>();
				EventDelegate.Execute(mTemp);
				for (int i = 0; i < mTemp.Count; i++)
				{
					EventDelegate eventDelegate = mTemp[i];
					if (eventDelegate != null && !eventDelegate.oneShot)
					{
						EventDelegate.Add(onFinished, eventDelegate, eventDelegate.oneShot);
					}
				}
				mTemp = null;
			}
			if (eventReceiver != null && !string.IsNullOrEmpty(callWhenFinished))
			{
				eventReceiver.SendMessage(callWhenFinished, this, SendMessageOptions.DontRequireReceiver);
			}
			current = null;
		}
		else
		{
			Sample(mFactor, isFinished: false);
		}
	}

	public void SetOnFinished(EventDelegate.Callback del)
	{
		EventDelegate.Set(onFinished, del);
	}

	public void SetOnFinished(EventDelegate del)
	{
		EventDelegate.Set(onFinished, del);
	}

	public void AddOnFinished(EventDelegate.Callback del)
	{
		EventDelegate.Add(onFinished, del);
	}

	public void AddOnFinished(EventDelegate del)
	{
		EventDelegate.Add(onFinished, del);
	}

	public void RemoveOnFinished(EventDelegate del)
	{
		if (onFinished != null)
		{
			onFinished.Remove(del);
		}
		if (mTemp != null)
		{
			mTemp.Remove(del);
		}
	}

	private void OnDisable()
	{
		mStarted = false;
	}

	public void Sample(float factor, bool isFinished)
	{
		float num = Mathf.Clamp01(factor);
		if (method == Method.EaseIn)
		{
			num = 1f - Mathf.Sin((float)Math.PI / 2f * (1f - num));
			if (steeperCurves)
			{
				num *= num;
			}
		}
		else if (method == Method.EaseOut)
		{
			num = Mathf.Sin((float)Math.PI / 2f * num);
			if (steeperCurves)
			{
				num = 1f - num;
				num = 1f - num * num;
			}
		}
		else if (method == Method.EaseInOut)
		{
			num -= Mathf.Sin(num * ((float)Math.PI * 2f)) / ((float)Math.PI * 2f);
			if (steeperCurves)
			{
				num = num * 2f - 1f;
				float num2 = Mathf.Sign(num);
				num = 1f - Mathf.Abs(num);
				num = 1f - num * num;
				num = num2 * num * 0.5f + 0.5f;
			}
		}
		else if (method == Method.BounceIn)
		{
			num = BounceLogic(num);
		}
		else if (method == Method.BounceOut)
		{
			num = 1f - BounceLogic(1f - num);
		}
		OnUpdate((animationCurve == null) ? num : animationCurve.Evaluate(num), isFinished);
	}

	private float BounceLogic(float val)
	{
		val = ((val < 0.363636f) ? (7.5685f * val * val) : ((val < 0.727272f) ? (7.5625f * (val -= 0.545454f) * val + 0.75f) : ((!(val < 0.90909f)) ? (7.5625f * (val -= 0.9545454f) * val + 63f / 64f) : (7.5625f * (val -= 0.818181f) * val + 0.9375f))));
		return val;
	}

	[Obsolete("Use PlayForward() instead")]
	public void Play()
	{
		Play(forward: true);
	}

	public void PlayForward()
	{
		Play(forward: true);
	}

	public void PlayReverse()
	{
		Play(forward: false);
	}

	public void Play(bool forward)
	{
		mAmountPerDelta = Mathf.Abs(amountPerDelta);
		if (!forward)
		{
			mAmountPerDelta = 0f - mAmountPerDelta;
		}
		base.enabled = true;
		Update();
	}

	public void ResetToBeginning()
	{
		mStarted = false;
		mFactor = ((!(amountPerDelta < 0f)) ? 0f : 1f);
		Sample(mFactor, isFinished: false);
	}

	public void Toggle()
	{
		if (mFactor > 0f)
		{
			mAmountPerDelta = 0f - amountPerDelta;
		}
		else
		{
			mAmountPerDelta = Mathf.Abs(amountPerDelta);
		}
		base.enabled = true;
	}

	protected abstract void OnUpdate(float factor, bool isFinished);

	public static T Begin<T>(GameObject go, float duration) where T : UITweener
	{
		T val = go.GetComponent<T>();
		if (val != null && val.tweenGroup != 0)
		{
			val = (T)null;
			T[] components = go.GetComponents<T>();
			int i = 0;
			for (int num = components.Length; i < num; i++)
			{
				val = components[i];
				if (val != null && val.tweenGroup == 0)
				{
					break;
				}
				val = (T)null;
			}
		}
		if (val == null)
		{
			val = go.AddComponent<T>();
			if (val == null)
			{
				UnityEngine.Debug.LogError(string.Concat("Unable to add ", typeof(T), " to ", NGUITools.GetHierarchy(go)), go);
				return (T)null;
			}
		}
		val.mStarted = false;
		val.duration = duration;
		val.mFactor = 0f;
		val.mAmountPerDelta = Mathf.Abs(val.amountPerDelta);
		val.style = Style.Once;
		val.animationCurve = new AnimationCurve(new Keyframe(0f, 0f, 0f, 1f), new Keyframe(1f, 1f, 1f, 0f));
		val.eventReceiver = null;
		val.callWhenFinished = null;
		val.enabled = true;
		return val;
	}

	public virtual void SetStartToCurrentValue()
	{
	}

	public virtual void SetEndToCurrentValue()
	{
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/UI/NGUI Unity2D Sprite")]
public class UI2DSprite : UIBasicSprite
{
	[HideInInspector]
	[SerializeField]
	private Sprite mSprite;

	[HideInInspector]
	[SerializeField]
	private Material mMat;

	[HideInInspector]
	[SerializeField]
	private Shader mShader;

	[HideInInspector]
	[SerializeField]
	private Vector4 mBorder = Vector4.zero;

	[HideInInspector]
	[SerializeField]
	private bool mFixedAspect;

	[HideInInspector]
	[SerializeField]
	private float mPixelSize = 1f;

	public Sprite nextSprite;

	[NonSerialized]
	private int mPMA = -1;

	public Sprite sprite2D
	{
		get
		{
			return mSprite;
		}
		set
		{
			if (mSprite != value)
			{
				RemoveFromPanel();
				mSprite = value;
				nextSprite = null;
				CreatePanel();
			}
		}
	}

	public override Material material
	{
		get
		{
			return mMat;
		}
		set
		{
			if (mMat != value)
			{
				RemoveFromPanel();
				mMat = value;
				mPMA = -1;
				MarkAsChanged();
			}
		}
	}

	public override Shader shader
	{
		get
		{
			if (mMat != null)
			{
				return mMat.shader;
			}
			if (mShader == null)
			{
				mShader = Shader.Find("Unlit/Transparent Colored");
			}
			return mShader;
		}
		set
		{
			if (mShader != value)
			{
				RemoveFromPanel();
				mShader = value;
				if (mMat == null)
				{
					mPMA = -1;
					MarkAsChanged();
				}
			}
		}
	}

	public override Texture mainTexture
	{
		get
		{
			if (mSprite != null)
			{
				return mSprite.texture;
			}
			if (mMat != null)
			{
				return mMat.mainTexture;
			}
			return null;
		}
	}

	public override bool premultipliedAlpha
	{
		get
		{
			if (mPMA == -1)
			{
				Shader shader = this.shader;
				mPMA = ((shader != null && shader.name.Contains("Premultiplied")) ? 1 : 0);
			}
			return mPMA == 1;
		}
	}

	public override float pixelSize => mPixelSize;

	public override Vector4 drawingDimensions
	{
		get
		{
			Vector2 vector = base.pivotOffset;
			float num = (0f - vector.x) * (float)mWidth;
			float num2 = (0f - vector.y) * (float)mHeight;
			float num3 = num + (float)mWidth;
			float num4 = num2 + (float)mHeight;
			if (mSprite != null && mType != Type.Tiled)
			{
				int num5 = Mathf.RoundToInt(mSprite.rect.width);
				int num6 = Mathf.RoundToInt(mSprite.rect.height);
				int num7 = Mathf.RoundToInt(mSprite.textureRectOffset.x);
				int num8 = Mathf.RoundToInt(mSprite.textureRectOffset.y);
				int num9 = Mathf.RoundToInt(mSprite.rect.width - mSprite.textureRect.width - mSprite.textureRectOffset.x);
				int num10 = Mathf.RoundToInt(mSprite.rect.height - mSprite.textureRect.height - mSprite.textureRectOffset.y);
				float num11 = 1f;
				float num12 = 1f;
				if (num5 > 0 && num6 > 0 && (mType == Type.Simple || mType == Type.Filled))
				{
					if (((uint)num5 & (true ? 1u : 0u)) != 0)
					{
						num9++;
					}
					if (((uint)num6 & (true ? 1u : 0u)) != 0)
					{
						num10++;
					}
					num11 = 1f / (float)num5 * (float)mWidth;
					num12 = 1f / (float)num6 * (float)mHeight;
				}
				if (mFlip == Flip.Horizontally || mFlip == Flip.Both)
				{
					num += (float)num9 * num11;
					num3 -= (float)num7 * num11;
				}
				else
				{
					num += (float)num7 * num11;
					num3 -= (float)num9 * num11;
				}
				if (mFlip == Flip.Vertically || mFlip == Flip.Both)
				{
					num2 += (float)num10 * num12;
					num4 -= (float)num8 * num12;
				}
				else
				{
					num2 += (float)num8 * num12;
					num4 -= (float)num10 * num12;
				}
			}
			float num13;
			float num14;
			if (mFixedAspect)
			{
				num13 = 0f;
				num14 = 0f;
			}
			else
			{
				Vector4 vector2 = border * pixelSize;
				num13 = vector2.x + vector2.z;
				num14 = vector2.y + vector2.w;
			}
			float x = Mathf.Lerp(num, num3 - num13, mDrawRegion.x);
			float y = Mathf.Lerp(num2, num4 - num14, mDrawRegion.y);
			float z = Mathf.Lerp(num + num13, num3, mDrawRegion.z);
			float w = Mathf.Lerp(num2 + num14, num4, mDrawRegion.w);
			return new Vector4(x, y, z, w);
		}
	}

	public override Vector4 border
	{
		get
		{
			return mBorder;
		}
		set
		{
			if (mBorder != value)
			{
				mBorder = value;
				MarkAsChanged();
			}
		}
	}

	protected override void OnUpdate()
	{
		if (nextSprite != null)
		{
			if (nextSprite != mSprite)
			{
				sprite2D = nextSprite;
			}
			nextSprite = null;
		}
		base.OnUpdate();
		if (!mFixedAspect)
		{
			return;
		}
		Texture texture = mainTexture;
		if (texture != null)
		{
			int num = Mathf.RoundToInt(mSprite.rect.width);
			int num2 = Mathf.RoundToInt(mSprite.rect.height);
			int num3 = Mathf.RoundToInt(mSprite.textureRectOffset.x);
			int num4 = Mathf.RoundToInt(mSprite.textureRectOffset.y);
			int num5 = Mathf.RoundToInt(mSprite.rect.width - mSprite.textureRect.width - mSprite.textureRectOffset.x);
			int num6 = Mathf.RoundToInt(mSprite.rect.height - mSprite.textureRect.height - mSprite.textureRectOffset.y);
			num += num3 + num5;
			num2 += num6 + num4;
			float num7 = mWidth;
			float num8 = mHeight;
			float num9 = num7 / num8;
			float num10 = (float)num / (float)num2;
			if (num10 < num9)
			{
				float num11 = (num7 - num8 * num10) / num7 * 0.5f;
				base.drawRegion = new Vector4(num11, 0f, 1f - num11, 1f);
			}
			else
			{
				float num12 = (num8 - num7 / num10) / num8 * 0.5f;
				base.drawRegion = new Vector4(0f, num12, 1f, 1f - num12);
			}
		}
	}

	public override void MakePixelPerfect()
	{
		base.MakePixelPerfect();
		if (mType == Type.Tiled)
		{
			return;
		}
		Texture texture = mainTexture;
		if (!(texture == null) && (mType == Type.Simple || mType == Type.Filled || !base.hasBorder) && texture != null)
		{
			Rect rect = mSprite.rect;
			int num = Mathf.RoundToInt(rect.width);
			int num2 = Mathf.RoundToInt(rect.height);
			if ((num & 1) == 1)
			{
				num++;
			}
			if ((num2 & 1) == 1)
			{
				num2++;
			}
			base.width = num;
			base.height = num2;
		}
	}

	public override void OnFill(BetterList<Vector3> verts, BetterList<Vector2> uvs, BetterList<Color32> cols)
	{
		Texture texture = mainTexture;
		if (!(texture == null))
		{
			Rect rect = ((!(mSprite != null)) ? new Rect(0f, 0f, texture.width, texture.height) : mSprite.textureRect);
			Rect inner = rect;
			Vector4 vector = border;
			inner.xMin += vector.x;
			inner.yMin += vector.y;
			inner.xMax -= vector.z;
			inner.yMax -= vector.w;
			float num = 1f / (float)texture.width;
			float num2 = 1f / (float)texture.height;
			rect.xMin *= num;
			rect.xMax *= num;
			rect.yMin *= num2;
			rect.yMax *= num2;
			inner.xMin *= num;
			inner.xMax *= num;
			inner.yMin *= num2;
			inner.yMax *= num2;
			int size = verts.size;
			Fill(verts, uvs, cols, rect, inner);
			if (onPostFill != null)
			{
				onPostFill(this, size, verts, uvs, cols);
			}
		}
	}
}
public class UI2DSpriteAnimation : MonoBehaviour
{
	[SerializeField]
	protected int framerate = 20;

	public bool ignoreTimeScale = true;

	public bool loop = true;

	public Sprite[] frames;

	private SpriteRenderer mUnitySprite;

	private UI2DSprite mNguiSprite;

	private int mIndex;

	private float mUpdate;

	public bool isPlaying => base.enabled;

	public int framesPerSecond
	{
		get
		{
			return framerate;
		}
		set
		{
			framerate = value;
		}
	}

	public void Play()
	{
		if (frames == null || frames.Length <= 0)
		{
			return;
		}
		if (!base.enabled && !loop)
		{
			int num = ((framerate <= 0) ? (mIndex - 1) : (mIndex + 1));
			if (num < 0 || num >= frames.Length)
			{
				mIndex = ((framerate < 0) ? (frames.Length - 1) : 0);
			}
		}
		base.enabled = true;
		UpdateSprite();
	}

	public void Pause()
	{
		base.enabled = false;
	}

	public void ResetToBeginning()
	{
		mIndex = ((framerate < 0) ? (frames.Length - 1) : 0);
		UpdateSprite();
	}

	private void Start()
	{
		Play();
	}

	private void Update()
	{
		if (frames == null || frames.Length == 0)
		{
			base.enabled = false;
		}
		else
		{
			if (framerate == 0)
			{
				return;
			}
			float num = ((!ignoreTimeScale) ? Time.time : RealTime.time);
			if (mUpdate < num)
			{
				mUpdate = num;
				int num2 = ((framerate <= 0) ? (mIndex - 1) : (mIndex + 1));
				if (!loop && (num2 < 0 || num2 >= frames.Length))
				{
					base.enabled = false;
					return;
				}
				mIndex = NGUIMath.RepeatIndex(num2, frames.Length);
				UpdateSprite();
			}
		}
	}

	private void UpdateSprite()
	{
		if (mUnitySprite == null && mNguiSprite == null)
		{
			mUnitySprite = GetComponent<SpriteRenderer>();
			mNguiSprite = GetComponent<UI2DSprite>();
			if (mUnitySprite == null && mNguiSprite == null)
			{
				base.enabled = false;
				return;
			}
		}
		float num = ((!ignoreTimeScale) ? Time.time : RealTime.time);
		if (framerate != 0)
		{
			mUpdate = num + Mathf.Abs(1f / (float)framerate);
		}
		if (mUnitySprite != null)
		{
			mUnitySprite.sprite = frames[mIndex];
		}
		else if (mNguiSprite != null)
		{
			mNguiSprite.nextSprite = frames[mIndex];
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/UI/Anchor")]
public class UIAnchor : MonoBehaviour
{
	public enum Side
	{
		BottomLeft,
		Left,
		TopLeft,
		Top,
		TopRight,
		Right,
		BottomRight,
		Bottom,
		Center
	}

	public Camera uiCamera;

	public GameObject container;

	public Side side = Side.Center;

	public bool runOnlyOnce = true;

	public Vector2 relativeOffset = Vector2.zero;

	public Vector2 pixelOffset = Vector2.zero;

	[HideInInspector]
	[SerializeField]
	private UIWidget widgetContainer;

	private Transform mTrans;

	private Animation mAnim;

	private Rect mRect = default(Rect);

	private UIRoot mRoot;

	private bool mStarted;

	private void Awake()
	{
		mTrans = base.transform;
		mAnim = GetComponent<Animation>();
		UICamera.onScreenResize = (UICamera.OnScreenResize)Delegate.Combine(UICamera.onScreenResize, new UICamera.OnScreenResize(ScreenSizeChanged));
	}

	private void OnDestroy()
	{
		UICamera.onScreenResize = (UICamera.OnScreenResize)Delegate.Remove(UICamera.onScreenResize, new UICamera.OnScreenResize(ScreenSizeChanged));
	}

	private void ScreenSizeChanged()
	{
		if (mStarted && runOnlyOnce)
		{
			Update();
		}
	}

	private void Start()
	{
		if (container == null && widgetContainer != null)
		{
			container = widgetContainer.gameObject;
			widgetContainer = null;
		}
		mRoot = NGUITools.FindInParents<UIRoot>(base.gameObject);
		if (uiCamera == null)
		{
			uiCamera = NGUITools.FindCameraForLayer(base.gameObject.layer);
		}
		Update();
		mStarted = true;
	}

	private void Update()
	{
		if (mAnim != null && mAnim.enabled && mAnim.isPlaying)
		{
			return;
		}
		bool flag = false;
		UIWidget uIWidget = ((!(container == null)) ? container.GetComponent<UIWidget>() : null);
		UIPanel uIPanel = ((!(container == null) || !(uIWidget == null)) ? container.GetComponent<UIPanel>() : null);
		if (uIWidget != null)
		{
			Bounds bounds = uIWidget.CalculateBounds(container.transform.parent);
			mRect.x = bounds.min.x;
			mRect.y = bounds.min.y;
			mRect.width = bounds.size.x;
			mRect.height = bounds.size.y;
		}
		else if (uIPanel != null)
		{
			if (uIPanel.clipping == UIDrawCall.Clipping.None)
			{
				float num = ((!(mRoot != null)) ? 0.5f : ((float)mRoot.activeHeight / (float)Screen.height * 0.5f));
				mRect.xMin = (float)(-Screen.width) * num;
				mRect.yMin = (float)(-Screen.height) * num;
				mRect.xMax = 0f - mRect.xMin;
				mRect.yMax = 0f - mRect.yMin;
			}
			else
			{
				Vector4 finalClipRegion = uIPanel.finalClipRegion;
				mRect.x = finalClipRegion.x - finalClipRegion.z * 0.5f;
				mRect.y = finalClipRegion.y - finalClipRegion.w * 0.5f;
				mRect.width = finalClipRegion.z;
				mRect.height = finalClipRegion.w;
			}
		}
		else if (container != null)
		{
			Transform parent = container.transform.parent;
			Bounds bounds2 = ((!(parent != null)) ? NGUIMath.CalculateRelativeWidgetBounds(container.transform) : NGUIMath.CalculateRelativeWidgetBounds(parent, container.transform));
			mRect.x = bounds2.min.x;
			mRect.y = bounds2.min.y;
			mRect.width = bounds2.size.x;
			mRect.height = bounds2.size.y;
		}
		else
		{
			if (!(uiCamera != null))
			{
				return;
			}
			flag = true;
			mRect = uiCamera.pixelRect;
		}
		float x = (mRect.xMin + mRect.xMax) * 0.5f;
		float y = (mRect.yMin + mRect.yMax) * 0.5f;
		Vector3 vector = new Vector3(x, y, 0f);
		if (side != Side.Center)
		{
			if (side == Side.Right || side == Side.TopRight || side == Side.BottomRight)
			{
				vector.x = mRect.xMax;
			}
			else if (side == Side.Top || side == Side.Center || side == Side.Bottom)
			{
				vector.x = x;
			}
			else
			{
				vector.x = mRect.xMin;
			}
			if (side == Side.Top || side == Side.TopRight || side == Side.TopLeft)
			{
				vector.y = mRect.yMax;
			}
			else if (side == Side.Left || side == Side.Center || side == Side.Right)
			{
				vector.y = y;
			}
			else
			{
				vector.y = mRect.yMin;
			}
		}
		float width = mRect.width;
		float height = mRect.height;
		vector.x += pixelOffset.x + relativeOffset.x * width;
		vector.y += pixelOffset.y + relativeOffset.y * height;
		if (flag)
		{
			if (uiCamera.orthographic)
			{
				vector.x = Mathf.Round(vector.x);
				vector.y = Mathf.Round(vector.y);
			}
			vector.z = uiCamera.WorldToScreenPoint(mTrans.position).z;
			vector = uiCamera.ScreenToWorldPoint(vector);
		}
		else
		{
			vector.x = Mathf.Round(vector.x);
			vector.y = Mathf.Round(vector.y);
			if (uIPanel != null)
			{
				vector = uIPanel.cachedTransform.TransformPoint(vector);
			}
			else if (container != null)
			{
				Transform parent2 = container.transform.parent;
				if (parent2 != null)
				{
					vector = parent2.TransformPoint(vector);
				}
			}
			vector.z = mTrans.position.z;
		}
		if (mTrans.position != vector)
		{
			mTrans.position = vector;
		}
		if (runOnlyOnce && Application.isPlaying)
		{
			base.enabled = false;
		}
	}
}
[AddComponentMenu("NGUI/UI/Atlas")]
public class UIAtlas : MonoBehaviour
{
	[Serializable]
	private class Sprite
	{
		public string name = "Unity Bug";

		public Rect outer = new Rect(0f, 0f, 1f, 1f);

		public Rect inner = new Rect(0f, 0f, 1f, 1f);

		public bool rotated;

		public float paddingLeft;

		public float paddingRight;

		public float paddingTop;

		public float paddingBottom;

		public bool hasPadding => paddingLeft != 0f || paddingRight != 0f || paddingTop != 0f || paddingBottom != 0f;
	}

	private enum Coordinates
	{
		Pixels,
		TexCoords
	}

	[HideInInspector]
	[SerializeField]
	private Material material;

	[HideInInspector]
	[SerializeField]
	private List<UISpriteData> mSprites = new List<UISpriteData>();

	[HideInInspector]
	[SerializeField]
	private float mPixelSize = 1f;

	[HideInInspector]
	[SerializeField]
	private UIAtlas mReplacement;

	[HideInInspector]
	[SerializeField]
	private Coordinates mCoordinates;

	[HideInInspector]
	[SerializeField]
	private List<Sprite> sprites = new List<Sprite>();

	private int mPMA = -1;

	private Dictionary<string, int> mSpriteIndices = new Dictionary<string, int>();

	public Material spriteMaterial
	{
		get
		{
			return (!(mReplacement != null)) ? material : mReplacement.spriteMaterial;
		}
		set
		{
			if (mReplacement != null)
			{
				mReplacement.spriteMaterial = value;
				return;
			}
			if (material == null)
			{
				mPMA = 0;
				material = value;
				return;
			}
			MarkAsChanged();
			mPMA = -1;
			material = value;
			MarkAsChanged();
		}
	}

	public bool premultipliedAlpha
	{
		get
		{
			if (mReplacement != null)
			{
				return mReplacement.premultipliedAlpha;
			}
			if (mPMA == -1)
			{
				Material material = spriteMaterial;
				mPMA = ((material != null && material.shader != null && material.shader.name.Contains("Premultiplied")) ? 1 : 0);
			}
			return mPMA == 1;
		}
	}

	public List<UISpriteData> spriteList
	{
		get
		{
			if (mReplacement != null)
			{
				return mReplacement.spriteList;
			}
			if (mSprites.Count == 0)
			{
				Upgrade();
			}
			return mSprites;
		}
		set
		{
			if (mReplacement != null)
			{
				mReplacement.spriteList = value;
			}
			else
			{
				mSprites = value;
			}
		}
	}

	public Texture texture => (mReplacement != null) ? mReplacement.texture : ((!(material != null)) ? null : material.mainTexture);

	public float pixelSize
	{
		get
		{
			return (!(mReplacement != null)) ? mPixelSize : mReplacement.pixelSize;
		}
		set
		{
			if (mReplacement != null)
			{
				mReplacement.pixelSize = value;
				return;
			}
			float num = Mathf.Clamp(value, 0.25f, 4f);
			if (mPixelSize != num)
			{
				mPixelSize = num;
				MarkAsChanged();
			}
		}
	}

	public UIAtlas replacement
	{
		get
		{
			return mReplacement;
		}
		set
		{
			UIAtlas uIAtlas = value;
			if (uIAtlas == this)
			{
				uIAtlas = null;
			}
			if (mReplacement != uIAtlas)
			{
				if (uIAtlas != null && uIAtlas.replacement == this)
				{
					uIAtlas.replacement = null;
				}
				if (mReplacement != null)
				{
					MarkAsChanged();
				}
				mReplacement = uIAtlas;
				if (uIAtlas != null)
				{
					material = null;
				}
				MarkAsChanged();
			}
		}
	}

	public UISpriteData GetSprite(string name)
	{
		if (mReplacement != null)
		{
			return mReplacement.GetSprite(name);
		}
		if (!string.IsNullOrEmpty(name))
		{
			if (mSprites.Count == 0)
			{
				Upgrade();
			}
			if (mSprites.Count == 0)
			{
				return null;
			}
			if (mSpriteIndices.Count != mSprites.Count)
			{
				MarkSpriteListAsChanged();
			}
			if (mSpriteIndices.TryGetValue(name, out var value))
			{
				if (value > -1 && value < mSprites.Count)
				{
					return mSprites[value];
				}
				MarkSpriteListAsChanged();
				return (!mSpriteIndices.TryGetValue(name, out value)) ? null : mSprites[value];
			}
			int i = 0;
			for (int count = mSprites.Count; i < count; i++)
			{
				UISpriteData uISpriteData = mSprites[i];
				if (!string.IsNullOrEmpty(uISpriteData.name) && name == uISpriteData.name)
				{
					MarkSpriteListAsChanged();
					return uISpriteData;
				}
			}
		}
		return null;
	}

	public void MarkSpriteListAsChanged()
	{
		mSpriteIndices.Clear();
		int i = 0;
		for (int count = mSprites.Count; i < count; i++)
		{
			mSpriteIndices[mSprites[i].name] = i;
		}
	}

	public void SortAlphabetically()
	{
		mSprites.Sort((UISpriteData s1, UISpriteData s2) => s1.name.CompareTo(s2.name));
	}

	public BetterList<string> GetListOfSprites()
	{
		if (mReplacement != null)
		{
			return mReplacement.GetListOfSprites();
		}
		if (mSprites.Count == 0)
		{
			Upgrade();
		}
		BetterList<string> betterList = new BetterList<string>();
		int i = 0;
		for (int count = mSprites.Count; i < count; i++)
		{
			UISpriteData uISpriteData = mSprites[i];
			if (uISpriteData != null && !string.IsNullOrEmpty(uISpriteData.name))
			{
				betterList.Add(uISpriteData.name);
			}
		}
		return betterList;
	}

	public BetterList<string> GetListOfSprites(string match)
	{
		if ((bool)mReplacement)
		{
			return mReplacement.GetListOfSprites(match);
		}
		if (string.IsNullOrEmpty(match))
		{
			return GetListOfSprites();
		}
		if (mSprites.Count == 0)
		{
			Upgrade();
		}
		BetterList<string> betterList = new BetterList<string>();
		int i = 0;
		for (int count = mSprites.Count; i < count; i++)
		{
			UISpriteData uISpriteData = mSprites[i];
			if (uISpriteData != null && !string.IsNullOrEmpty(uISpriteData.name) && string.Equals(match, uISpriteData.name, StringComparison.OrdinalIgnoreCase))
			{
				betterList.Add(uISpriteData.name);
				return betterList;
			}
		}
		string[] array = match.Split(new char[1] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
		for (int j = 0; j < array.Length; j++)
		{
			array[j] = array[j].ToLower();
		}
		int k = 0;
		for (int count2 = mSprites.Count; k < count2; k++)
		{
			UISpriteData uISpriteData2 = mSprites[k];
			if (uISpriteData2 == null || string.IsNullOrEmpty(uISpriteData2.name))
			{
				continue;
			}
			string text = uISpriteData2.name.ToLower();
			int num = 0;
			for (int l = 0; l < array.Length; l++)
			{
				if (text.Contains(array[l]))
				{
					num++;
				}
			}
			if (num == array.Length)
			{
				betterList.Add(uISpriteData2.name);
			}
		}
		return betterList;
	}

	private bool References(UIAtlas atlas)
	{
		if (atlas == null)
		{
			return false;
		}
		if (atlas == this)
		{
			return true;
		}
		return mReplacement != null && mReplacement.References(atlas);
	}

	public static bool CheckIfRelated(UIAtlas a, UIAtlas b)
	{
		if (a == null || b == null)
		{
			return false;
		}
		return a == b || a.References(b) || b.References(a);
	}

	public void MarkAsChanged()
	{
		if (mReplacement != null)
		{
			mReplacement.MarkAsChanged();
		}
		UISprite[] array = NGUITools.FindActive<UISprite>();
		int i = 0;
		for (int num = array.Length; i < num; i++)
		{
			UISprite uISprite = array[i];
			if (CheckIfRelated(this, uISprite.atlas))
			{
				UIAtlas atlas = uISprite.atlas;
				uISprite.atlas = null;
				uISprite.atlas = atlas;
			}
		}
		UIFont[] array2 = Resources.FindObjectsOfTypeAll(typeof(UIFont)) as UIFont[];
		int j = 0;
		for (int num2 = array2.Length; j < num2; j++)
		{
			UIFont uIFont = array2[j];
			if (CheckIfRelated(this, uIFont.atlas))
			{
				UIAtlas atlas2 = uIFont.atlas;
				uIFont.atlas = null;
				uIFont.atlas = atlas2;
			}
		}
		UILabel[] array3 = NGUITools.FindActive<UILabel>();
		int k = 0;
		for (int num3 = array3.Length; k < num3; k++)
		{
			UILabel uILabel = array3[k];
			if (uILabel.bitmapFont != null && CheckIfRelated(this, uILabel.bitmapFont.atlas))
			{
				UIFont bitmapFont = uILabel.bitmapFont;
				uILabel.bitmapFont = null;
				uILabel.bitmapFont = bitmapFont;
			}
		}
	}

	private bool Upgrade()
	{
		if ((bool)mReplacement)
		{
			return mReplacement.Upgrade();
		}
		if (mSprites.Count == 0 && sprites.Count > 0 && (bool)material)
		{
			Texture mainTexture = material.mainTexture;
			int width = ((!(mainTexture != null)) ? 512 : mainTexture.width);
			int height = ((!(mainTexture != null)) ? 512 : mainTexture.height);
			for (int i = 0; i < sprites.Count; i++)
			{
				Sprite sprite = sprites[i];
				Rect outer = sprite.outer;
				Rect inner = sprite.inner;
				if (mCoordinates == Coordinates.TexCoords)
				{
					NGUIMath.ConvertToPixels(outer, width, height, round: true);
					NGUIMath.ConvertToPixels(inner, width, height, round: true);
				}
				UISpriteData uISpriteData = new UISpriteData();
				uISpriteData.name = sprite.name;
				uISpriteData.x = Mathf.RoundToInt(outer.xMin);
				uISpriteData.y = Mathf.RoundToInt(outer.yMin);
				uISpriteData.width = Mathf.RoundToInt(outer.width);
				uISpriteData.height = Mathf.RoundToInt(outer.height);
				uISpriteData.paddingLeft = Mathf.RoundToInt(sprite.paddingLeft * outer.width);
				uISpriteData.paddingRight = Mathf.RoundToInt(sprite.paddingRight * outer.width);
				uISpriteData.paddingBottom = Mathf.RoundToInt(sprite.paddingBottom * outer.height);
				uISpriteData.paddingTop = Mathf.RoundToInt(sprite.paddingTop * outer.height);
				uISpriteData.borderLeft = Mathf.RoundToInt(inner.xMin - outer.xMin);
				uISpriteData.borderRight = Mathf.RoundToInt(outer.xMax - inner.xMax);
				uISpriteData.borderBottom = Mathf.RoundToInt(outer.yMax - inner.yMax);
				uISpriteData.borderTop = Mathf.RoundToInt(inner.yMin - outer.yMin);
				mSprites.Add(uISpriteData);
			}
			sprites.Clear();
			return true;
		}
		return false;
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/UI/NGUI Event System (UICamera)")]
[RequireComponent(typeof(Camera))]
public class UICamera : MonoBehaviour
{
	public enum ControlScheme
	{
		Mouse,
		Touch,
		Controller
	}

	public enum ClickNotification
	{
		None,
		Always,
		BasedOnDelta
	}

	public class MouseOrTouch
	{
		public Vector2 pos;

		public Vector2 lastPos;

		public Vector2 delta;

		public Vector2 totalDelta;

		public Camera pressedCam;

		public GameObject last;

		public GameObject current;

		public GameObject pressed;

		public GameObject dragged;

		public float pressTime;

		public float clickTime;

		public ClickNotification clickNotification = ClickNotification.Always;

		public bool touchBegan = true;

		public bool pressStarted;

		public bool dragStarted;

		public float deltaTime => (!touchBegan) ? 0f : (RealTime.time - pressTime);

		public bool isOverUI => current != null && current != fallThrough && NGUITools.FindInParents<UIRoot>(current) != null;
	}

	public enum EventType
	{
		World_3D,
		UI_3D,
		World_2D,
		UI_2D
	}

	public delegate bool GetKeyStateFunc(KeyCode key);

	public delegate float GetAxisFunc(string name);

	public delegate void OnScreenResize();

	public delegate void OnCustomInput();

	public delegate void MoveDelegate(Vector2 delta);

	public delegate void VoidDelegate(GameObject go);

	public delegate void BoolDelegate(GameObject go, bool state);

	public delegate void FloatDelegate(GameObject go, float delta);

	public delegate void VectorDelegate(GameObject go, Vector2 delta);

	public delegate void ObjectDelegate(GameObject go, GameObject obj);

	public delegate void KeyCodeDelegate(GameObject go, KeyCode key);

	private struct DepthEntry
	{
		public int depth;

		public RaycastHit hit;

		public Vector3 point;

		public GameObject go;
	}

	public static BetterList<UICamera> list = new BetterList<UICamera>();

	public static GetKeyStateFunc GetKeyDown = Input.GetKeyDown;

	public static GetKeyStateFunc GetKeyUp = Input.GetKeyUp;

	public static GetKeyStateFunc GetKey = Input.GetKey;

	public static GetAxisFunc GetAxis = Input.GetAxis;

	public static OnScreenResize onScreenResize;

	public EventType eventType = EventType.UI_3D;

	public bool eventsGoToColliders;

	public LayerMask eventReceiverMask = -1;

	public bool debug;

	public bool useMouse = true;

	public bool useTouch = true;

	public bool allowMultiTouch = true;

	public bool useKeyboard = true;

	public bool useController = true;

	public bool stickyTooltip = true;

	public float tooltipDelay = 1f;

	public float mouseDragThreshold = 4f;

	public float mouseClickThreshold = 10f;

	public float touchDragThreshold = 40f;

	public float touchClickThreshold = 40f;

	public float rangeDistance = -1f;

	public string scrollAxisName = "Mouse ScrollWheel";

	public string verticalAxisName = "Vertical";

	public string horizontalAxisName = "Horizontal";

	public KeyCode submitKey0 = KeyCode.Return;

	public KeyCode submitKey1 = KeyCode.JoystickButton0;

	public KeyCode cancelKey0 = KeyCode.Escape;

	public KeyCode cancelKey1 = KeyCode.JoystickButton1;

	public static OnCustomInput onCustomInput;

	public static bool showTooltips = true;

	public static Vector2 lastTouchPosition = Vector2.zero;

	public static Vector3 lastWorldPosition = Vector3.zero;

	public static RaycastHit lastHit;

	public static UICamera current = null;

	public static Camera currentCamera = null;

	public static ControlScheme currentScheme = ControlScheme.Mouse;

	public static int currentTouchID = -1;

	public static KeyCode currentKey = KeyCode.None;

	public static MouseOrTouch currentTouch = null;

	public static bool inputHasFocus = false;

	private static GameObject mGenericHandler;

	public static GameObject fallThrough;

	public static VoidDelegate onClick;

	public static VoidDelegate onDoubleClick;

	public static BoolDelegate onHover;

	public static BoolDelegate onPress;

	public static BoolDelegate onSelect;

	public static FloatDelegate onScroll;

	public static VectorDelegate onDrag;

	public static VoidDelegate onDragStart;

	public static ObjectDelegate onDragOver;

	public static ObjectDelegate onDragOut;

	public static VoidDelegate onDragEnd;

	public static ObjectDelegate onDrop;

	public static KeyCodeDelegate onKey;

	public static BoolDelegate onTooltip;

	public static MoveDelegate onMouseMove;

	private static GameObject mCurrentSelection = null;

	private static GameObject mNextSelection = null;

	private static ControlScheme mNextScheme = ControlScheme.Controller;

	private static MouseOrTouch[] mMouse = new MouseOrTouch[3]
	{
		new MouseOrTouch(),
		new MouseOrTouch(),
		new MouseOrTouch()
	};

	private static GameObject mHover;

	public static MouseOrTouch controller = new MouseOrTouch();

	private static float mNextEvent = 0f;

	private static Dictionary<int, MouseOrTouch> mTouches = new Dictionary<int, MouseOrTouch>();

	private static int mWidth = 0;

	private static int mHeight = 0;

	private GameObject mTooltip;

	private Camera mCam;

	private float mTooltipTime;

	private float mNextRaycast;

	public static bool isDragging = false;

	public static GameObject hoveredObject;

	private static DepthEntry mHit = default(DepthEntry);

	private static BetterList<DepthEntry> mHits = new BetterList<DepthEntry>();

	private static Plane m2DPlane = new Plane(Vector3.back, 0f);

	private static bool mNotifying = false;

	[Obsolete("Use new OnDragStart / OnDragOver / OnDragOut / OnDragEnd events instead")]
	public bool stickyPress => true;

	public static Ray currentRay => (!(currentCamera != null) || currentTouch == null) ? default(Ray) : currentCamera.ScreenPointToRay(currentTouch.pos);

	[Obsolete("Use delegates instead such as UICamera.onClick, UICamera.onHover, etc.")]
	public static GameObject genericEventHandler
	{
		get
		{
			return mGenericHandler;
		}
		set
		{
			mGenericHandler = value;
		}
	}

	private bool handlesEvents => eventHandler == this;

	public Camera cachedCamera
	{
		get
		{
			if (mCam == null)
			{
				mCam = GetComponent<Camera>();
			}
			return mCam;
		}
	}

	public static bool isOverUI
	{
		get
		{
			if (currentTouch != null)
			{
				return currentTouch.isOverUI;
			}
			if (hoveredObject == null)
			{
				return false;
			}
			if (hoveredObject == fallThrough)
			{
				return false;
			}
			return NGUITools.FindInParents<UIRoot>(hoveredObject) != null;
		}
	}

	public static GameObject selectedObject
	{
		get
		{
			return mCurrentSelection;
		}
		set
		{
			SetSelection(value, currentScheme);
		}
	}

	public static int touchCount
	{
		get
		{
			int num = 0;
			foreach (KeyValuePair<int, MouseOrTouch> mTouch in mTouches)
			{
				if (mTouch.Value.pressed != null)
				{
					num++;
				}
			}
			for (int i = 0; i < mMouse.Length; i++)
			{
				if (mMouse[i].pressed != null)
				{
					num++;
				}
			}
			if (controller.pressed != null)
			{
				num++;
			}
			return num;
		}
	}

	public static int dragCount
	{
		get
		{
			int num = 0;
			foreach (KeyValuePair<int, MouseOrTouch> mTouch in mTouches)
			{
				if (mTouch.Value.dragged != null)
				{
					num++;
				}
			}
			for (int i = 0; i < mMouse.Length; i++)
			{
				if (mMouse[i].dragged != null)
				{
					num++;
				}
			}
			if (controller.dragged != null)
			{
				num++;
			}
			return num;
		}
	}

	public static Camera mainCamera
	{
		get
		{
			UICamera uICamera = eventHandler;
			return (!(uICamera != null)) ? null : uICamera.cachedCamera;
		}
	}

	public static UICamera eventHandler
	{
		get
		{
			for (int i = 0; i < list.size; i++)
			{
				UICamera uICamera = list.buffer[i];
				if (!(uICamera == null) && uICamera.enabled && NGUITools.GetActive(uICamera.gameObject))
				{
					return uICamera;
				}
			}
			return null;
		}
	}

	public static bool IsPressed(GameObject go)
	{
		for (int i = 0; i < 3; i++)
		{
			if (mMouse[i].pressed == go)
			{
				return true;
			}
		}
		foreach (KeyValuePair<int, MouseOrTouch> mTouch in mTouches)
		{
			if (mTouch.Value.pressed == go)
			{
				return true;
			}
		}
		if (controller.pressed == go)
		{
			return true;
		}
		return false;
	}

	protected static void SetSelection(GameObject go, ControlScheme scheme)
	{
		if (mNextSelection != null)
		{
			mNextSelection = go;
		}
		else
		{
			if (!(mCurrentSelection != go))
			{
				return;
			}
			mNextSelection = go;
			mNextScheme = scheme;
			if (list.size > 0)
			{
				UICamera uICamera = ((!(mNextSelection != null)) ? list[0] : FindCameraForLayer(mNextSelection.layer));
				if (uICamera != null)
				{
					uICamera.StartCoroutine(uICamera.ChangeSelection());
				}
			}
		}
	}

	private IEnumerator ChangeSelection()
	{
		yield return new WaitForEndOfFrame();
		if (onSelect != null)
		{
			onSelect(mCurrentSelection, state: false);
		}
		Notify(mCurrentSelection, "OnSelect", false);
		mCurrentSelection = mNextSelection;
		mNextSelection = null;
		if (mCurrentSelection != null)
		{
			current = this;
			currentCamera = mCam;
			currentScheme = mNextScheme;
			inputHasFocus = mCurrentSelection.GetComponent<UIInput>() != null;
			if (onSelect != null)
			{
				onSelect(mCurrentSelection, state: true);
			}
			Notify(mCurrentSelection, "OnSelect", true);
			current = null;
		}
		else
		{
			inputHasFocus = false;
		}
	}

	private static int CompareFunc(UICamera a, UICamera b)
	{
		if (a.cachedCamera.depth < b.cachedCamera.depth)
		{
			return 1;
		}
		if (a.cachedCamera.depth > b.cachedCamera.depth)
		{
			return -1;
		}
		return 0;
	}

	private static Rigidbody FindRootRigidbody(Transform trans)
	{
		while (trans != null)
		{
			if (trans.GetComponent<UIPanel>() != null)
			{
				return null;
			}
			Rigidbody component = trans.GetComponent<Rigidbody>();
			if (component != null)
			{
				return component;
			}
			trans = trans.parent;
		}
		return null;
	}

	private static Rigidbody2D FindRootRigidbody2D(Transform trans)
	{
		while (trans != null)
		{
			if (trans.GetComponent<UIPanel>() != null)
			{
				return null;
			}
			Rigidbody2D component = trans.GetComponent<Rigidbody2D>();
			if (component != null)
			{
				return component;
			}
			trans = trans.parent;
		}
		return null;
	}

	public static bool Raycast(Vector3 inPos)
	{
		for (int i = 0; i < list.size; i++)
		{
			UICamera uICamera = list.buffer[i];
			if (!uICamera.enabled || !NGUITools.GetActive(uICamera.gameObject))
			{
				continue;
			}
			currentCamera = uICamera.cachedCamera;
			Vector3 vector = currentCamera.ScreenToViewportPoint(inPos);
			if (float.IsNaN(vector.x) || float.IsNaN(vector.y) || vector.x < 0f || vector.x > 1f || vector.y < 0f || vector.y > 1f)
			{
				continue;
			}
			Ray ray = currentCamera.ScreenPointToRay(inPos);
			int layerMask = currentCamera.cullingMask & (int)uICamera.eventReceiverMask;
			float enter = ((!(uICamera.rangeDistance > 0f)) ? (currentCamera.farClipPlane - currentCamera.nearClipPlane) : uICamera.rangeDistance);
			if (uICamera.eventType == EventType.World_3D)
			{
				if (!Physics.Raycast(ray, out lastHit, enter, layerMask))
				{
					continue;
				}
				lastWorldPosition = lastHit.point;
				hoveredObject = lastHit.collider.gameObject;
				if (!uICamera.eventsGoToColliders)
				{
					Rigidbody rigidbody = FindRootRigidbody(hoveredObject.transform);
					if (rigidbody != null)
					{
						hoveredObject = rigidbody.gameObject;
					}
				}
				return true;
			}
			if (uICamera.eventType == EventType.UI_3D)
			{
				RaycastHit[] array = Physics.RaycastAll(ray, enter, layerMask);
				if (array.Length > 1)
				{
					for (int j = 0; j < array.Length; j++)
					{
						GameObject gameObject = array[j].collider.gameObject;
						UIWidget component = gameObject.GetComponent<UIWidget>();
						if (component != null)
						{
							if (!component.isVisible || (component.hitCheck != null && !component.hitCheck(array[j].point)))
							{
								continue;
							}
						}
						else
						{
							UIRect uIRect = NGUITools.FindInParents<UIRect>(gameObject);
							if (uIRect != null && uIRect.finalAlpha < 0.001f)
							{
								continue;
							}
						}
						mHit.depth = NGUITools.CalculateRaycastDepth(gameObject);
						if (mHit.depth != int.MaxValue)
						{
							mHit.hit = array[j];
							mHit.point = array[j].point;
							mHit.go = array[j].collider.gameObject;
							mHits.Add(mHit);
						}
					}
					mHits.Sort((DepthEntry r1, DepthEntry r2) => r2.depth.CompareTo(r1.depth));
					for (int k = 0; k < mHits.size; k++)
					{
						if (IsVisible(ref mHits.buffer[k]))
						{
							lastHit = mHits[k].hit;
							hoveredObject = mHits[k].go;
							lastWorldPosition = mHits[k].point;
							mHits.Clear();
							return true;
						}
					}
					mHits.Clear();
				}
				else
				{
					if (array.Length != 1)
					{
						continue;
					}
					GameObject gameObject2 = array[0].collider.gameObject;
					UIWidget component2 = gameObject2.GetComponent<UIWidget>();
					if (component2 != null)
					{
						if (!component2.isVisible || (component2.hitCheck != null && !component2.hitCheck(array[0].point)))
						{
							continue;
						}
					}
					else
					{
						UIRect uIRect2 = NGUITools.FindInParents<UIRect>(gameObject2);
						if (uIRect2 != null && uIRect2.finalAlpha < 0.001f)
						{
							continue;
						}
					}
					if (IsVisible(array[0].point, array[0].collider.gameObject))
					{
						lastHit = array[0];
						lastWorldPosition = array[0].point;
						hoveredObject = lastHit.collider.gameObject;
						return true;
					}
				}
			}
			else
			{
				if (uICamera.eventType == EventType.World_2D)
				{
					if (!m2DPlane.Raycast(ray, out enter))
					{
						continue;
					}
					Vector3 point = ray.GetPoint(enter);
					Collider2D collider2D = Physics2D.OverlapPoint(point, layerMask);
					if (!collider2D)
					{
						continue;
					}
					lastWorldPosition = point;
					hoveredObject = collider2D.gameObject;
					if (!uICamera.eventsGoToColliders)
					{
						Rigidbody2D rigidbody2D = FindRootRigidbody2D(hoveredObject.transform);
						if (rigidbody2D != null)
						{
							hoveredObject = rigidbody2D.gameObject;
						}
					}
					return true;
				}
				if (uICamera.eventType != EventType.UI_2D || !m2DPlane.Raycast(ray, out enter))
				{
					continue;
				}
				lastWorldPosition = ray.GetPoint(enter);
				Collider2D[] array2 = Physics2D.OverlapPointAll(lastWorldPosition, layerMask);
				if (array2.Length > 1)
				{
					for (int l = 0; l < array2.Length; l++)
					{
						GameObject gameObject3 = array2[l].gameObject;
						UIWidget component3 = gameObject3.GetComponent<UIWidget>();
						if (component3 != null)
						{
							if (!component3.isVisible || (component3.hitCheck != null && !component3.hitCheck(lastWorldPosition)))
							{
								continue;
							}
						}
						else
						{
							UIRect uIRect3 = NGUITools.FindInParents<UIRect>(gameObject3);
							if (uIRect3 != null && uIRect3.finalAlpha < 0.001f)
							{
								continue;
							}
						}
						mHit.depth = NGUITools.CalculateRaycastDepth(gameObject3);
						if (mHit.depth != int.MaxValue)
						{
							mHit.go = gameObject3;
							mHit.point = lastWorldPosition;
							mHits.Add(mHit);
						}
					}
					mHits.Sort((DepthEntry r1, DepthEntry r2) => r2.depth.CompareTo(r1.depth));
					for (int m = 0; m < mHits.size; m++)
					{
						if (IsVisible(ref mHits.buffer[m]))
						{
							hoveredObject = mHits[m].go;
							mHits.Clear();
							return true;
						}
					}
					mHits.Clear();
				}
				else
				{
					if (array2.Length != 1)
					{
						continue;
					}
					GameObject gameObject4 = array2[0].gameObject;
					UIWidget component4 = gameObject4.GetComponent<UIWidget>();
					if (component4 != null)
					{
						if (!component4.isVisible || (component4.hitCheck != null && !component4.hitCheck(lastWorldPosition)))
						{
							continue;
						}
					}
					else
					{
						UIRect uIRect4 = NGUITools.FindInParents<UIRect>(gameObject4);
						if (uIRect4 != null && uIRect4.finalAlpha < 0.001f)
						{
							continue;
						}
					}
					if (IsVisible(lastWorldPosition, gameObject4))
					{
						hoveredObject = gameObject4;
						return true;
					}
				}
			}
		}
		return false;
	}

	private static bool IsVisible(Vector3 worldPoint, GameObject go)
	{
		UIPanel uIPanel = NGUITools.FindInParents<UIPanel>(go);
		while (uIPanel != null)
		{
			if (!uIPanel.IsVisible(worldPoint))
			{
				return false;
			}
			uIPanel = uIPanel.parentPanel;
		}
		return true;
	}

	private static bool IsVisible(ref DepthEntry de)
	{
		UIPanel uIPanel = NGUITools.FindInParents<UIPanel>(de.go);
		while (uIPanel != null)
		{
			if (!uIPanel.IsVisible(de.point))
			{
				return false;
			}
			uIPanel = uIPanel.parentPanel;
		}
		return true;
	}

	public static bool IsHighlighted(GameObject go)
	{
		if (currentScheme == ControlScheme.Mouse)
		{
			return hoveredObject == go;
		}
		if (currentScheme == ControlScheme.Controller)
		{
			return selectedObject == go;
		}
		return false;
	}

	public static UICamera FindCameraForLayer(int layer)
	{
		int num = 1 << layer;
		for (int i = 0; i < list.size; i++)
		{
			UICamera uICamera = list.buffer[i];
			Camera camera = uICamera.cachedCamera;
			if (camera != null && (camera.cullingMask & num) != 0)
			{
				return uICamera;
			}
		}
		return null;
	}

	private static int GetDirection(KeyCode up, KeyCode down)
	{
		if (GetKeyDown(up))
		{
			return 1;
		}
		if (GetKeyDown(down))
		{
			return -1;
		}
		return 0;
	}

	private static int GetDirection(KeyCode up0, KeyCode up1, KeyCode down0, KeyCode down1)
	{
		if (GetKeyDown(up0) || GetKeyDown(up1))
		{
			return 1;
		}
		if (GetKeyDown(down0) || GetKeyDown(down1))
		{
			return -1;
		}
		return 0;
	}

	private static int GetDirection(string axis)
	{
		float time = RealTime.time;
		if (mNextEvent < time && !string.IsNullOrEmpty(axis))
		{
			float num = GetAxis(axis);
			if (num > 0.75f)
			{
				mNextEvent = time + 0.25f;
				return 1;
			}
			if (num < -0.75f)
			{
				mNextEvent = time + 0.25f;
				return -1;
			}
		}
		return 0;
	}

	public static void Notify(GameObject go, string funcName, object obj)
	{
		if (mNotifying)
		{
			return;
		}
		mNotifying = true;
		if (NGUITools.GetActive(go))
		{
			go.SendMessage(funcName, obj, SendMessageOptions.DontRequireReceiver);
			if (mGenericHandler != null && mGenericHandler != go)
			{
				mGenericHandler.SendMessage(funcName, obj, SendMessageOptions.DontRequireReceiver);
			}
		}
		mNotifying = false;
	}

	public static MouseOrTouch GetMouse(int button)
	{
		return mMouse[button];
	}

	public static MouseOrTouch GetTouch(int id)
	{
		MouseOrTouch value = null;
		if (id < 0)
		{
			return GetMouse(-id - 1);
		}
		if (!mTouches.TryGetValue(id, out value))
		{
			value = new MouseOrTouch();
			value.pressTime = RealTime.time;
			value.touchBegan = true;
			mTouches.Add(id, value);
		}
		return value;
	}

	public static void RemoveTouch(int id)
	{
		mTouches.Remove(id);
	}

	private void Awake()
	{
		mWidth = Screen.width;
		mHeight = Screen.height;
		if (Application.platform == RuntimePlatform.Android || Application.platform == RuntimePlatform.IPhonePlayer || Application.platform == RuntimePlatform.WP8Player || Application.platform == RuntimePlatform.BlackBerryPlayer)
		{
			useTouch = true;
			if (Application.platform == RuntimePlatform.IPhonePlayer)
			{
				useMouse = false;
				useKeyboard = false;
				useController = false;
			}
		}
		else if (Application.platform == RuntimePlatform.PS3 || Application.platform == RuntimePlatform.XBOX360)
		{
			useMouse = false;
			useTouch = false;
			useKeyboard = false;
			useController = true;
		}
		mMouse[0].pos = Input.mousePosition;
		for (int i = 1; i < 3; i++)
		{
			mMouse[i].pos = mMouse[0].pos;
			mMouse[i].lastPos = mMouse[0].pos;
		}
		lastTouchPosition = mMouse[0].pos;
	}

	private void OnEnable()
	{
		list.Add(this);
		list.Sort(CompareFunc);
	}

	private void OnDisable()
	{
		list.Remove(this);
	}

	private void Start()
	{
		if (eventType != 0 && cachedCamera.transparencySortMode != TransparencySortMode.Orthographic)
		{
			cachedCamera.transparencySortMode = TransparencySortMode.Orthographic;
		}
		if (Application.isPlaying)
		{
			if (fallThrough == null)
			{
				UIRoot uIRoot = NGUITools.FindInParents<UIRoot>(base.gameObject);
				if (uIRoot != null)
				{
					fallThrough = uIRoot.gameObject;
				}
				else
				{
					Transform transform = base.transform;
					fallThrough = ((!(transform.parent != null)) ? base.gameObject : transform.parent.gameObject);
				}
			}
			cachedCamera.eventMask = 0;
		}
		if (handlesEvents)
		{
			NGUIDebug.debugRaycast = debug;
		}
	}

	private void Update()
	{
		if (!handlesEvents)
		{
			return;
		}
		current = this;
		if (useTouch)
		{
			ProcessTouches();
		}
		else if (useMouse)
		{
			ProcessMouse();
		}
		if (onCustomInput != null)
		{
			onCustomInput();
		}
		if (useMouse && mCurrentSelection != null)
		{
			if (cancelKey0 != 0 && GetKeyDown(cancelKey0))
			{
				currentScheme = ControlScheme.Controller;
				currentKey = cancelKey0;
				selectedObject = null;
			}
			else if (cancelKey1 != 0 && GetKeyDown(cancelKey1))
			{
				currentScheme = ControlScheme.Controller;
				currentKey = cancelKey1;
				selectedObject = null;
			}
		}
		if (mCurrentSelection == null)
		{
			inputHasFocus = false;
		}
		if (mCurrentSelection != null)
		{
			ProcessOthers();
		}
		if (useMouse && mHover != null)
		{
			float num = (string.IsNullOrEmpty(scrollAxisName) ? 0f : GetAxis(scrollAxisName));
			if (num != 0f)
			{
				if (onScroll != null)
				{
					onScroll(mHover, num);
				}
				Notify(mHover, "OnScroll", num);
			}
			if (showTooltips && mTooltipTime != 0f && (mTooltipTime < RealTime.time || GetKey(KeyCode.LeftShift) || GetKey(KeyCode.RightShift)))
			{
				mTooltip = mHover;
				ShowTooltip(val: true);
			}
		}
		current = null;
	}

	private void LateUpdate()
	{
		if (!handlesEvents)
		{
			return;
		}
		int width = Screen.width;
		int height = Screen.height;
		if (width != mWidth || height != mHeight)
		{
			mWidth = width;
			mHeight = height;
			UIRoot.Broadcast("UpdateAnchors");
			if (onScreenResize != null)
			{
				onScreenResize();
			}
		}
	}

	public void ProcessMouse()
	{
		lastTouchPosition = Input.mousePosition;
		mMouse[0].delta = lastTouchPosition - mMouse[0].pos;
		mMouse[0].pos = lastTouchPosition;
		bool flag = mMouse[0].delta.sqrMagnitude > 0.001f;
		for (int i = 1; i < 3; i++)
		{
			mMouse[i].pos = mMouse[0].pos;
			mMouse[i].delta = mMouse[0].delta;
		}
		bool flag2 = false;
		bool flag3 = false;
		for (int j = 0; j < 3; j++)
		{
			if (Input.GetMouseButtonDown(j))
			{
				currentScheme = ControlScheme.Mouse;
				flag3 = true;
				flag2 = true;
			}
			else if (Input.GetMouseButton(j))
			{
				currentScheme = ControlScheme.Mouse;
				flag2 = true;
			}
		}
		if (flag2 || flag || mNextRaycast < RealTime.time)
		{
			mNextRaycast = RealTime.time + 0.02f;
			if (!Raycast(Input.mousePosition))
			{
				hoveredObject = fallThrough;
			}
			if (hoveredObject == null)
			{
				hoveredObject = mGenericHandler;
			}
			for (int k = 0; k < 3; k++)
			{
				mMouse[k].current = hoveredObject;
			}
		}
		bool flag4 = mMouse[0].last != mMouse[0].current;
		if (flag4)
		{
			currentScheme = ControlScheme.Mouse;
		}
		if (flag2)
		{
			mTooltipTime = 0f;
		}
		else if (flag && (!stickyTooltip || flag4))
		{
			if (mTooltipTime != 0f)
			{
				mTooltipTime = RealTime.time + tooltipDelay;
			}
			else if (mTooltip != null)
			{
				ShowTooltip(val: false);
			}
		}
		if (flag && onMouseMove != null)
		{
			currentTouch = mMouse[0];
			onMouseMove(currentTouch.delta);
			currentTouch = null;
		}
		if ((flag3 || !flag2) && mHover != null && flag4)
		{
			currentScheme = ControlScheme.Mouse;
			currentTouch = mMouse[0];
			if (mTooltip != null)
			{
				ShowTooltip(val: false);
			}
			if (onHover != null)
			{
				onHover(mHover, state: false);
			}
			Notify(mHover, "OnHover", false);
			mHover = null;
		}
		for (int l = 0; l < 3; l++)
		{
			bool mouseButtonDown = Input.GetMouseButtonDown(l);
			bool mouseButtonUp = Input.GetMouseButtonUp(l);
			if (mouseButtonDown || mouseButtonUp)
			{
				currentScheme = ControlScheme.Mouse;
			}
			currentTouch = mMouse[l];
			currentTouchID = -1 - l;
			currentKey = (KeyCode)(323 + l);
			if (mouseButtonDown)
			{
				currentTouch.pressedCam = currentCamera;
			}
			else if (currentTouch.pressed != null)
			{
				currentCamera = currentTouch.pressedCam;
			}
			ProcessTouch(mouseButtonDown, mouseButtonUp);
			currentKey = KeyCode.None;
		}
		if (!flag2 && flag4)
		{
			currentScheme = ControlScheme.Mouse;
			mTooltipTime = RealTime.time + tooltipDelay;
			mHover = mMouse[0].current;
			currentTouch = mMouse[0];
			if (onHover != null)
			{
				onHover(mHover, state: true);
			}
			Notify(mHover, "OnHover", true);
		}
		currentTouch = null;
		mMouse[0].last = mMouse[0].current;
		for (int m = 1; m < 3; m++)
		{
			mMouse[m].last = mMouse[0].last;
		}
	}

	public void ProcessTouches()
	{
		currentScheme = ControlScheme.Touch;
		for (int i = 0; i < Input.touchCount; i++)
		{
			Touch touch = Input.GetTouch(i);
			currentTouchID = ((!allowMultiTouch) ? 1 : touch.fingerId);
			currentTouch = GetTouch(currentTouchID);
			bool flag = touch.phase == TouchPhase.Began || currentTouch.touchBegan;
			bool flag2 = touch.phase == TouchPhase.Canceled || touch.phase == TouchPhase.Ended;
			currentTouch.touchBegan = false;
			currentTouch.delta = ((!flag) ? (touch.position - currentTouch.pos) : Vector2.zero);
			currentTouch.pos = touch.position;
			if (!Raycast(currentTouch.pos))
			{
				hoveredObject = fallThrough;
			}
			if (hoveredObject == null)
			{
				hoveredObject = mGenericHandler;
			}
			currentTouch.last = currentTouch.current;
			currentTouch.current = hoveredObject;
			lastTouchPosition = currentTouch.pos;
			if (flag)
			{
				currentTouch.pressedCam = currentCamera;
			}
			else if (currentTouch.pressed != null)
			{
				currentCamera = currentTouch.pressedCam;
			}
			if (touch.tapCount > 1)
			{
				currentTouch.clickTime = RealTime.time;
			}
			ProcessTouch(flag, flag2);
			if (flag2)
			{
				RemoveTouch(currentTouchID);
			}
			currentTouch.last = null;
			currentTouch = null;
			if (!allowMultiTouch)
			{
				break;
			}
		}
		if (Input.touchCount == 0 && useMouse)
		{
			ProcessMouse();
		}
	}

	private void ProcessFakeTouches()
	{
		bool mouseButtonDown = Input.GetMouseButtonDown(0);
		bool mouseButtonUp = Input.GetMouseButtonUp(0);
		bool mouseButton = Input.GetMouseButton(0);
		if (mouseButtonDown || mouseButtonUp || mouseButton)
		{
			currentTouchID = 1;
			currentTouch = mMouse[0];
			currentTouch.touchBegan = mouseButtonDown;
			if (mouseButtonDown)
			{
				currentTouch.pressTime = RealTime.time;
			}
			Vector2 vector = Input.mousePosition;
			currentTouch.delta = ((!mouseButtonDown) ? (vector - currentTouch.pos) : Vector2.zero);
			currentTouch.pos = vector;
			if (!Raycast(currentTouch.pos))
			{
				hoveredObject = fallThrough;
			}
			if (hoveredObject == null)
			{
				hoveredObject = mGenericHandler;
			}
			currentTouch.last = currentTouch.current;
			currentTouch.current = hoveredObject;
			lastTouchPosition = currentTouch.pos;
			if (mouseButtonDown)
			{
				currentTouch.pressedCam = currentCamera;
			}
			else if (currentTouch.pressed != null)
			{
				currentCamera = currentTouch.pressedCam;
			}
			ProcessTouch(mouseButtonDown, mouseButtonUp);
			if (mouseButtonUp)
			{
				RemoveTouch(currentTouchID);
			}
			currentTouch.last = null;
			currentTouch = null;
		}
	}

	public void ProcessOthers()
	{
		currentTouchID = -100;
		currentTouch = controller;
		bool flag = false;
		bool flag2 = false;
		if (submitKey0 != 0 && GetKeyDown(submitKey0))
		{
			currentKey = submitKey0;
			flag = true;
		}
		if (submitKey1 != 0 && GetKeyDown(submitKey1))
		{
			currentKey = submitKey1;
			flag = true;
		}
		if (submitKey0 != 0 && GetKeyUp(submitKey0))
		{
			currentKey = submitKey0;
			flag2 = true;
		}
		if (submitKey1 != 0 && GetKeyUp(submitKey1))
		{
			currentKey = submitKey1;
			flag2 = true;
		}
		if (flag || flag2)
		{
			currentScheme = ControlScheme.Controller;
			currentTouch.last = currentTouch.current;
			currentTouch.current = mCurrentSelection;
			ProcessTouch(flag, flag2);
			currentTouch.last = null;
		}
		int num = 0;
		int num2 = 0;
		if (useKeyboard)
		{
			if (inputHasFocus)
			{
				num += GetDirection(KeyCode.UpArrow, KeyCode.DownArrow);
				num2 += GetDirection(KeyCode.RightArrow, KeyCode.LeftArrow);
			}
			else
			{
				num += GetDirection(KeyCode.W, KeyCode.UpArrow, KeyCode.S, KeyCode.DownArrow);
				num2 += GetDirection(KeyCode.D, KeyCode.RightArrow, KeyCode.A, KeyCode.LeftArrow);
			}
		}
		if (useController)
		{
			if (!string.IsNullOrEmpty(verticalAxisName))
			{
				num += GetDirection(verticalAxisName);
			}
			if (!string.IsNullOrEmpty(horizontalAxisName))
			{
				num2 += GetDirection(horizontalAxisName);
			}
		}
		if (num != 0)
		{
			currentScheme = ControlScheme.Controller;
			KeyCode keyCode = ((num <= 0) ? KeyCode.DownArrow : KeyCode.UpArrow);
			if (onKey != null)
			{
				onKey(mCurrentSelection, keyCode);
			}
			Notify(mCurrentSelection, "OnKey", keyCode);
		}
		if (num2 != 0)
		{
			currentScheme = ControlScheme.Controller;
			KeyCode keyCode2 = ((num2 <= 0) ? KeyCode.LeftArrow : KeyCode.RightArrow);
			if (onKey != null)
			{
				onKey(mCurrentSelection, keyCode2);
			}
			Notify(mCurrentSelection, "OnKey", keyCode2);
		}
		if (useKeyboard && GetKeyDown(KeyCode.Tab))
		{
			currentKey = KeyCode.Tab;
			currentScheme = ControlScheme.Controller;
			if (onKey != null)
			{
				onKey(mCurrentSelection, KeyCode.Tab);
			}
			Notify(mCurrentSelection, "OnKey", KeyCode.Tab);
		}
		if (cancelKey0 != 0 && GetKeyDown(cancelKey0))
		{
			currentKey = cancelKey0;
			currentScheme = ControlScheme.Controller;
			if (onKey != null)
			{
				onKey(mCurrentSelection, KeyCode.Escape);
			}
			Notify(mCurrentSelection, "OnKey", KeyCode.Escape);
		}
		if (cancelKey1 != 0 && GetKeyDown(cancelKey1))
		{
			currentKey = cancelKey1;
			currentScheme = ControlScheme.Controller;
			if (onKey != null)
			{
				onKey(mCurrentSelection, KeyCode.Escape);
			}
			Notify(mCurrentSelection, "OnKey", KeyCode.Escape);
		}
		currentTouch = null;
		currentKey = KeyCode.None;
	}

	public void ProcessTouch(bool pressed, bool unpressed)
	{
		bool flag = currentScheme == ControlScheme.Mouse;
		float num = ((!flag) ? touchDragThreshold : mouseDragThreshold);
		float num2 = ((!flag) ? touchClickThreshold : mouseClickThreshold);
		num *= num;
		num2 *= num2;
		if (pressed)
		{
			if (mTooltip != null)
			{
				ShowTooltip(val: false);
			}
			currentTouch.pressStarted = true;
			if (onPress != null)
			{
				onPress(currentTouch.pressed, state: false);
			}
			Notify(currentTouch.pressed, "OnPress", false);
			currentTouch.pressed = currentTouch.current;
			currentTouch.dragged = currentTouch.current;
			currentTouch.clickNotification = ClickNotification.BasedOnDelta;
			currentTouch.totalDelta = Vector2.zero;
			currentTouch.dragStarted = false;
			if (onPress != null)
			{
				onPress(currentTouch.pressed, state: true);
			}
			Notify(currentTouch.pressed, "OnPress", true);
			if (currentTouch.pressed != mCurrentSelection)
			{
				if (mTooltip != null)
				{
					ShowTooltip(val: false);
				}
				currentScheme = ControlScheme.Touch;
				selectedObject = currentTouch.pressed;
			}
		}
		else if (currentTouch.pressed != null && (currentTouch.delta.sqrMagnitude != 0f || currentTouch.current != currentTouch.last))
		{
			currentTouch.totalDelta += currentTouch.delta;
			float sqrMagnitude = currentTouch.totalDelta.sqrMagnitude;
			bool flag2 = false;
			if (!currentTouch.dragStarted && currentTouch.last != currentTouch.current)
			{
				currentTouch.dragStarted = true;
				currentTouch.delta = currentTouch.totalDelta;
				isDragging = true;
				if (onDragStart != null)
				{
					onDragStart(currentTouch.dragged);
				}
				Notify(currentTouch.dragged, "OnDragStart", null);
				if (onDragOver != null)
				{
					onDragOver(currentTouch.last, currentTouch.dragged);
				}
				Notify(currentTouch.last, "OnDragOver", currentTouch.dragged);
				isDragging = false;
			}
			else if (!currentTouch.dragStarted && num < sqrMagnitude)
			{
				flag2 = true;
				currentTouch.dragStarted = true;
				currentTouch.delta = currentTouch.totalDelta;
			}
			if (currentTouch.dragStarted)
			{
				if (mTooltip != null)
				{
					ShowTooltip(val: false);
				}
				isDragging = true;
				bool flag3 = currentTouch.clickNotification == ClickNotification.None;
				if (flag2)
				{
					if (onDragStart != null)
					{
						onDragStart(currentTouch.dragged);
					}
					Notify(currentTouch.dragged, "OnDragStart", null);
					if (onDragOver != null)
					{
						onDragOver(currentTouch.last, currentTouch.dragged);
					}
					Notify(currentTouch.current, "OnDragOver", currentTouch.dragged);
				}
				else if (currentTouch.last != currentTouch.current)
				{
					if (onDragStart != null)
					{
						onDragStart(currentTouch.dragged);
					}
					Notify(currentTouch.last, "OnDragOut", currentTouch.dragged);
					if (onDragOver != null)
					{
						onDragOver(currentTouch.last, currentTouch.dragged);
					}
					Notify(currentTouch.current, "OnDragOver", currentTouch.dragged);
				}
				if (onDrag != null)
				{
					onDrag(currentTouch.dragged, currentTouch.delta);
				}
				Notify(currentTouch.dragged, "OnDrag", currentTouch.delta);
				currentTouch.last = currentTouch.current;
				isDragging = false;
				if (flag3)
				{
					currentTouch.clickNotification = ClickNotification.None;
				}
				else if (currentTouch.clickNotification == ClickNotification.BasedOnDelta && num2 < sqrMagnitude)
				{
					currentTouch.clickNotification = ClickNotification.None;
				}
			}
		}
		if (!unpressed)
		{
			return;
		}
		currentTouch.pressStarted = false;
		if (mTooltip != null)
		{
			ShowTooltip(val: false);
		}
		if (currentTouch.pressed != null)
		{
			if (currentTouch.dragStarted)
			{
				if (onDragOut != null)
				{
					onDragOut(currentTouch.last, currentTouch.dragged);
				}
				Notify(currentTouch.last, "OnDragOut", currentTouch.dragged);
				if (onDragEnd != null)
				{
					onDragEnd(currentTouch.dragged);
				}
				Notify(currentTouch.dragged, "OnDragEnd", null);
			}
			if (onPress != null)
			{
				onPress(currentTouch.pressed, state: false);
			}
			Notify(currentTouch.pressed, "OnPress", false);
			if (flag)
			{
				if (onHover != null)
				{
					onHover(currentTouch.current, state: true);
				}
				Notify(currentTouch.current, "OnHover", true);
			}
			mHover = currentTouch.current;
			if (currentTouch.dragged == currentTouch.current || (currentScheme != ControlScheme.Controller && currentTouch.clickNotification != 0 && currentTouch.totalDelta.sqrMagnitude < num))
			{
				if (currentTouch.pressed != mCurrentSelection)
				{
					mNextSelection = null;
					mCurrentSelection = currentTouch.pressed;
					if (onSelect != null)
					{
						onSelect(currentTouch.pressed, state: true);
					}
					Notify(currentTouch.pressed, "OnSelect", true);
				}
				else
				{
					mNextSelection = null;
					mCurrentSelection = currentTouch.pressed;
				}
				if (currentTouch.clickNotification != 0 && currentTouch.pressed == currentTouch.current)
				{
					float time = RealTime.time;
					if (onClick != null)
					{
						onClick(currentTouch.pressed);
					}
					Notify(currentTouch.pressed, "OnClick", null);
					if (currentTouch.clickTime + 0.35f > time)
					{
						if (onDoubleClick != null)
						{
							onDoubleClick(currentTouch.pressed);
						}
						Notify(currentTouch.pressed, "OnDoubleClick", null);
					}
					currentTouch.clickTime = time;
				}
			}
			else if (currentTouch.dragStarted)
			{
				if (onDrop != null)
				{
					onDrop(currentTouch.current, currentTouch.dragged);
				}
				Notify(currentTouch.current, "OnDrop", currentTouch.dragged);
			}
		}
		currentTouch.dragStarted = false;
		currentTouch.pressed = null;
		currentTouch.dragged = null;
	}

	public void ShowTooltip(bool val)
	{
		mTooltipTime = 0f;
		if (onTooltip != null)
		{
			onTooltip(mTooltip, val);
		}
		Notify(mTooltip, "OnTooltip", val);
		if (!val)
		{
			mTooltip = null;
		}
	}

	private void OnApplicationPause()
	{
		MouseOrTouch mouseOrTouch = currentTouch;
		if (useTouch)
		{
			BetterList<int> betterList = new BetterList<int>();
			foreach (KeyValuePair<int, MouseOrTouch> mTouch in mTouches)
			{
				if (mTouch.Value != null && (bool)mTouch.Value.pressed)
				{
					currentTouch = mTouch.Value;
					currentTouchID = mTouch.Key;
					currentScheme = ControlScheme.Touch;
					currentTouch.clickNotification = ClickNotification.None;
					ProcessTouch(pressed: false, unpressed: true);
					betterList.Add(currentTouchID);
				}
			}
			for (int i = 0; i < betterList.size; i++)
			{
				RemoveTouch(betterList[i]);
			}
		}
		if (useMouse)
		{
			for (int j = 0; j < 3; j++)
			{
				if ((bool)mMouse[j].pressed)
				{
					currentTouch = mMouse[j];
					currentTouchID = -1 - j;
					currentKey = (KeyCode)(323 + j);
					currentScheme = ControlScheme.Mouse;
					currentTouch.clickNotification = ClickNotification.None;
					ProcessTouch(pressed: false, unpressed: true);
				}
			}
		}
		if (useController && (bool)controller.pressed)
		{
			currentTouch = controller;
			currentTouchID = -100;
			currentScheme = ControlScheme.Controller;
			currentTouch.last = currentTouch.current;
			currentTouch.current = mCurrentSelection;
			currentTouch.clickNotification = ClickNotification.None;
			ProcessTouch(pressed: false, unpressed: true);
			currentTouch.last = null;
		}
		currentTouch = mouseOrTouch;
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/UI/NGUI Font")]
public class UIFont : MonoBehaviour
{
	[HideInInspector]
	[SerializeField]
	private Material mMat;

	[HideInInspector]
	[SerializeField]
	private Rect mUVRect = new Rect(0f, 0f, 1f, 1f);

	[HideInInspector]
	[SerializeField]
	private BMFont mFont = new BMFont();

	[HideInInspector]
	[SerializeField]
	private UIAtlas mAtlas;

	[HideInInspector]
	[SerializeField]
	private UIFont mReplacement;

	[HideInInspector]
	[SerializeField]
	private List<BMSymbol> mSymbols = new List<BMSymbol>();

	[HideInInspector]
	[SerializeField]
	private UnityEngine.Font mDynamicFont;

	[HideInInspector]
	[SerializeField]
	private int mDynamicFontSize = 16;

	[HideInInspector]
	[SerializeField]
	private UnityEngine.FontStyle mDynamicFontStyle;

	[NonSerialized]
	private UISpriteData mSprite;

	private int mPMA = -1;

	private int mPacked = -1;

	public BMFont bmFont
	{
		get
		{
			return (!(mReplacement != null)) ? mFont : mReplacement.bmFont;
		}
		set
		{
			if (mReplacement != null)
			{
				mReplacement.bmFont = value;
			}
			else
			{
				mFont = value;
			}
		}
	}

	public int texWidth
	{
		get
		{
			return (mReplacement != null) ? mReplacement.texWidth : ((mFont == null) ? 1 : mFont.texWidth);
		}
		set
		{
			if (mReplacement != null)
			{
				mReplacement.texWidth = value;
			}
			else if (mFont != null)
			{
				mFont.texWidth = value;
			}
		}
	}

	public int texHeight
	{
		get
		{
			return (mReplacement != null) ? mReplacement.texHeight : ((mFont == null) ? 1 : mFont.texHeight);
		}
		set
		{
			if (mReplacement != null)
			{
				mReplacement.texHeight = value;
			}
			else if (mFont != null)
			{
				mFont.texHeight = value;
			}
		}
	}

	public bool hasSymbols => (mReplacement != null) ? mReplacement.hasSymbols : (mSymbols != null && mSymbols.Count != 0);

	public List<BMSymbol> symbols => (!(mReplacement != null)) ? mSymbols : mReplacement.symbols;

	public UIAtlas atlas
	{
		get
		{
			return (!(mReplacement != null)) ? mAtlas : mReplacement.atlas;
		}
		set
		{
			if (mReplacement != null)
			{
				mReplacement.atlas = value;
			}
			else
			{
				if (!(mAtlas != value))
				{
					return;
				}
				if (value == null)
				{
					if (mAtlas != null)
					{
						mMat = mAtlas.spriteMaterial;
					}
					if (sprite != null)
					{
						mUVRect = uvRect;
					}
				}
				mPMA = -1;
				mAtlas = value;
				MarkAsChanged();
			}
		}
	}

	public Material material
	{
		get
		{
			if (mReplacement != null)
			{
				return mReplacement.material;
			}
			if (mAtlas != null)
			{
				return mAtlas.spriteMaterial;
			}
			if (mMat != null)
			{
				if (mDynamicFont != null && mMat != mDynamicFont.material)
				{
					mMat.mainTexture = mDynamicFont.material.mainTexture;
				}
				return mMat;
			}
			if (mDynamicFont != null)
			{
				return mDynamicFont.material;
			}
			return null;
		}
		set
		{
			if (mReplacement != null)
			{
				mReplacement.material = value;
			}
			else if (mMat != value)
			{
				mPMA = -1;
				mMat = value;
				MarkAsChanged();
			}
		}
	}

	[Obsolete("Use UIFont.premultipliedAlphaShader instead")]
	public bool premultipliedAlpha => premultipliedAlphaShader;

	public bool premultipliedAlphaShader
	{
		get
		{
			if (mReplacement != null)
			{
				return mReplacement.premultipliedAlphaShader;
			}
			if (mAtlas != null)
			{
				return mAtlas.premultipliedAlpha;
			}
			if (mPMA == -1)
			{
				Material material = this.material;
				mPMA = ((material != null && material.shader != null && material.shader.name.Contains("Premultiplied")) ? 1 : 0);
			}
			return mPMA == 1;
		}
	}

	public bool packedFontShader
	{
		get
		{
			if (mReplacement != null)
			{
				return mReplacement.packedFontShader;
			}
			if (mAtlas != null)
			{
				return false;
			}
			if (mPacked == -1)
			{
				Material material = this.material;
				mPacked = ((material != null && material.shader != null && material.shader.name.Contains("Packed")) ? 1 : 0);
			}
			return mPacked == 1;
		}
	}

	public Texture2D texture
	{
		get
		{
			if (mReplacement != null)
			{
				return mReplacement.texture;
			}
			Material material = this.material;
			return (!(material != null)) ? null : (material.mainTexture as Texture2D);
		}
	}

	public Rect uvRect
	{
		get
		{
			if (mReplacement != null)
			{
				return mReplacement.uvRect;
			}
			return (!(mAtlas != null) || sprite == null) ? new Rect(0f, 0f, 1f, 1f) : mUVRect;
		}
		set
		{
			if (mReplacement != null)
			{
				mReplacement.uvRect = value;
			}
			else if (sprite == null && mUVRect != value)
			{
				mUVRect = value;
				MarkAsChanged();
			}
		}
	}

	public string spriteName
	{
		get
		{
			return (!(mReplacement != null)) ? mFont.spriteName : mReplacement.spriteName;
		}
		set
		{
			if (mReplacement != null)
			{
				mReplacement.spriteName = value;
			}
			else if (mFont.spriteName != value)
			{
				mFont.spriteName = value;
				MarkAsChanged();
			}
		}
	}

	public bool isValid => mDynamicFont != null || mFont.isValid;

	[Obsolete("Use UIFont.defaultSize instead")]
	public int size
	{
		get
		{
			return defaultSize;
		}
		set
		{
			defaultSize = value;
		}
	}

	public int defaultSize
	{
		get
		{
			if (mReplacement != null)
			{
				return mReplacement.defaultSize;
			}
			if (isDynamic || mFont == null)
			{
				return mDynamicFontSize;
			}
			return mFont.charSize;
		}
		set
		{
			if (mReplacement != null)
			{
				mReplacement.defaultSize = value;
			}
			else
			{
				mDynamicFontSize = value;
			}
		}
	}

	public UISpriteData sprite
	{
		get
		{
			if (mReplacement != null)
			{
				return mReplacement.sprite;
			}
			if (mSprite == null && mAtlas != null && !string.IsNullOrEmpty(mFont.spriteName))
			{
				mSprite = mAtlas.GetSprite(mFont.spriteName);
				if (mSprite == null)
				{
					mSprite = mAtlas.GetSprite(base.name);
				}
				if (mSprite == null)
				{
					mFont.spriteName = null;
				}
				else
				{
					UpdateUVRect();
				}
				int i = 0;
				for (int count = mSymbols.Count; i < count; i++)
				{
					symbols[i].MarkAsChanged();
				}
			}
			return mSprite;
		}
	}

	public UIFont replacement
	{
		get
		{
			return mReplacement;
		}
		set
		{
			UIFont uIFont = value;
			if (uIFont == this)
			{
				uIFont = null;
			}
			if (mReplacement != uIFont)
			{
				if (uIFont != null && uIFont.replacement == this)
				{
					uIFont.replacement = null;
				}
				if (mReplacement != null)
				{
					MarkAsChanged();
				}
				mReplacement = uIFont;
				if (uIFont != null)
				{
					mPMA = -1;
					mMat = null;
					mFont = null;
					mDynamicFont = null;
				}
				MarkAsChanged();
			}
		}
	}

	public bool isDynamic => (!(mReplacement != null)) ? (mDynamicFont != null) : mReplacement.isDynamic;

	public UnityEngine.Font dynamicFont
	{
		get
		{
			return (!(mReplacement != null)) ? mDynamicFont : mReplacement.dynamicFont;
		}
		set
		{
			if (mReplacement != null)
			{
				mReplacement.dynamicFont = value;
			}
			else if (mDynamicFont != value)
			{
				if (mDynamicFont != null)
				{
					material = null;
				}
				mDynamicFont = value;
				MarkAsChanged();
			}
		}
	}

	public UnityEngine.FontStyle dynamicFontStyle
	{
		get
		{
			return (!(mReplacement != null)) ? mDynamicFontStyle : mReplacement.dynamicFontStyle;
		}
		set
		{
			if (mReplacement != null)
			{
				mReplacement.dynamicFontStyle = value;
			}
			else if (mDynamicFontStyle != value)
			{
				mDynamicFontStyle = value;
				MarkAsChanged();
			}
		}
	}

	private Texture dynamicTexture
	{
		get
		{
			if ((bool)mReplacement)
			{
				return mReplacement.dynamicTexture;
			}
			if (isDynamic)
			{
				return mDynamicFont.material.mainTexture;
			}
			return null;
		}
	}

	private void Trim()
	{
		Texture texture = mAtlas.texture;
		if (texture != null && mSprite != null)
		{
			Rect rect = NGUIMath.ConvertToPixels(mUVRect, this.texture.width, this.texture.height, round: true);
			Rect rect2 = new Rect(mSprite.x, mSprite.y, mSprite.width, mSprite.height);
			int xMin = Mathf.RoundToInt(rect2.xMin - rect.xMin);
			int yMin = Mathf.RoundToInt(rect2.yMin - rect.yMin);
			int xMax = Mathf.RoundToInt(rect2.xMax - rect.xMin);
			int yMax = Mathf.RoundToInt(rect2.yMax - rect.yMin);
			mFont.Trim(xMin, yMin, xMax, yMax);
		}
	}

	private bool References(UIFont font)
	{
		if (font == null)
		{
			return false;
		}
		if (font == this)
		{
			return true;
		}
		return mReplacement != null && mReplacement.References(font);
	}

	public static bool CheckIfRelated(UIFont a, UIFont b)
	{
		if (a == null || b == null)
		{
			return false;
		}
		if (a.isDynamic && b.isDynamic && a.dynamicFont.fontNames[0] == b.dynamicFont.fontNames[0])
		{
			return true;
		}
		return a == b || a.References(b) || b.References(a);
	}

	public void MarkAsChanged()
	{
		if (mReplacement != null)
		{
			mReplacement.MarkAsChanged();
		}
		mSprite = null;
		UILabel[] array = NGUITools.FindActive<UILabel>();
		int i = 0;
		for (int num = array.Length; i < num; i++)
		{
			UILabel uILabel = array[i];
			if (uILabel.enabled && NGUITools.GetActive(uILabel.gameObject) && CheckIfRelated(this, uILabel.bitmapFont))
			{
				UIFont bitmapFont = uILabel.bitmapFont;
				uILabel.bitmapFont = null;
				uILabel.bitmapFont = bitmapFont;
			}
		}
		int j = 0;
		for (int count = symbols.Count; j < count; j++)
		{
			symbols[j].MarkAsChanged();
		}
	}

	public void UpdateUVRect()
	{
		if (mAtlas == null)
		{
			return;
		}
		Texture texture = mAtlas.texture;
		if (texture != null)
		{
			mUVRect = new Rect(mSprite.x - mSprite.paddingLeft, mSprite.y - mSprite.paddingTop, mSprite.width + mSprite.paddingLeft + mSprite.paddingRight, mSprite.height + mSprite.paddingTop + mSprite.paddingBottom);
			mUVRect = NGUIMath.ConvertToTexCoords(mUVRect, texture.width, texture.height);
			if (mSprite.hasPadding)
			{
				Trim();
			}
		}
	}

	private BMSymbol GetSymbol(string sequence, bool createIfMissing)
	{
		int i = 0;
		for (int count = mSymbols.Count; i < count; i++)
		{
			BMSymbol bMSymbol = mSymbols[i];
			if (bMSymbol.sequence == sequence)
			{
				return bMSymbol;
			}
		}
		if (createIfMissing)
		{
			BMSymbol bMSymbol2 = new BMSymbol();
			bMSymbol2.sequence = sequence;
			mSymbols.Add(bMSymbol2);
			return bMSymbol2;
		}
		return null;
	}

	public BMSymbol MatchSymbol(string text, int offset, int textLength)
	{
		int count = mSymbols.Count;
		if (count == 0)
		{
			return null;
		}
		textLength -= offset;
		for (int i = 0; i < count; i++)
		{
			BMSymbol bMSymbol = mSymbols[i];
			int length = bMSymbol.length;
			if (length == 0 || textLength < length)
			{
				continue;
			}
			bool flag = true;
			for (int j = 0; j < length; j++)
			{
				if (text[offset + j] != bMSymbol.sequence[j])
				{
					flag = false;
					break;
				}
			}
			if (flag && bMSymbol.Validate(atlas))
			{
				return bMSymbol;
			}
		}
		return null;
	}

	public void AddSymbol(string sequence, string spriteName)
	{
		BMSymbol symbol = GetSymbol(sequence, createIfMissing: true);
		symbol.spriteName = spriteName;
		MarkAsChanged();
	}

	public void RemoveSymbol(string sequence)
	{
		BMSymbol symbol = GetSymbol(sequence, createIfMissing: false);
		if (symbol != null)
		{
			symbols.Remove(symbol);
		}
		MarkAsChanged();
	}

	public void RenameSymbol(string before, string after)
	{
		BMSymbol symbol = GetSymbol(before, createIfMissing: false);
		if (symbol != null)
		{
			symbol.sequence = after;
		}
		MarkAsChanged();
	}

	public bool UsesSprite(string s)
	{
		if (!string.IsNullOrEmpty(s))
		{
			if (s.Equals(spriteName))
			{
				return true;
			}
			int i = 0;
			for (int count = symbols.Count; i < count; i++)
			{
				BMSymbol bMSymbol = symbols[i];
				if (s.Equals(bMSymbol.spriteName))
				{
					return true;
				}
			}
		}
		return false;
	}
}
[AddComponentMenu("NGUI/UI/Input Field")]
public class UIInput : MonoBehaviour
{
	public enum InputType
	{
		Standard,
		AutoCorrect,
		Password
	}

	public enum Validation
	{
		None,
		Integer,
		Float,
		Alphanumeric,
		Username,
		Name
	}

	public enum KeyboardType
	{
		Default,
		ASCIICapable,
		NumbersAndPunctuation,
		URL,
		NumberPad,
		PhonePad,
		NamePhonePad,
		EmailAddress
	}

	public enum OnReturnKey
	{
		Default,
		Submit,
		NewLine
	}

	public delegate char OnValidate(string text, int charIndex, char addedChar);

	public static UIInput current;

	public static UIInput selection;

	public UILabel label;

	public InputType inputType;

	public OnReturnKey onReturnKey;

	public KeyboardType keyboardType;

	public bool hideInput;

	[NonSerialized]
	public bool selectAllTextOnFocus = true;

	public Validation validation;

	public int characterLimit;

	public string savedAs;

	[HideInInspector]
	[SerializeField]
	private GameObject selectOnTab;

	public UnityEngine.Color activeTextColor = UnityEngine.Color.white;

	public UnityEngine.Color caretColor = new UnityEngine.Color(1f, 1f, 1f, 0.8f);

	public UnityEngine.Color selectionColor = new UnityEngine.Color(1f, 0.8745098f, 47f / 85f, 0.5f);

	public List<EventDelegate> onSubmit = new List<EventDelegate>();

	public List<EventDelegate> onChange = new List<EventDelegate>();

	public OnValidate onValidate;

	[SerializeField]
	[HideInInspector]
	protected string mValue;

	[NonSerialized]
	protected string mDefaultText = string.Empty;

	[NonSerialized]
	protected UnityEngine.Color mDefaultColor = UnityEngine.Color.white;

	[NonSerialized]
	protected float mPosition;

	[NonSerialized]
	protected bool mDoInit = true;

	[NonSerialized]
	protected UIWidget.Pivot mPivot;

	[NonSerialized]
	protected bool mLoadSavedValue = true;

	protected static int mDrawStart;

	protected static string mLastIME = string.Empty;

	protected static TouchScreenKeyboard mKeyboard;

	private static bool mWaitForKeyboard;

	[NonSerialized]
	protected int mSelectionStart;

	[NonSerialized]
	protected int mSelectionEnd;

	[NonSerialized]
	protected UITexture mHighlight;

	[NonSerialized]
	protected UITexture mCaret;

	[NonSerialized]
	protected Texture2D mBlankTex;

	[NonSerialized]
	protected float mNextBlink;

	[NonSerialized]
	protected float mLastAlpha;

	[NonSerialized]
	protected string mCached = string.Empty;

	[NonSerialized]
	protected int mSelectMe = -1;

	public string defaultText
	{
		get
		{
			if (mDoInit)
			{
				Init();
			}
			return mDefaultText;
		}
		set
		{
			if (mDoInit)
			{
				Init();
			}
			mDefaultText = value;
			UpdateLabel();
		}
	}

	public bool inputShouldBeHidden => hideInput && label != null && !label.multiLine && inputType != InputType.Password;

	[Obsolete("Use UIInput.value instead")]
	public string text
	{
		get
		{
			return value;
		}
		set
		{
			this.value = value;
		}
	}

	public string value
	{
		get
		{
			if (mDoInit)
			{
				Init();
			}
			return mValue;
		}
		set
		{
			if (mDoInit)
			{
				Init();
			}
			mDrawStart = 0;
			if (Application.platform == RuntimePlatform.BlackBerryPlayer)
			{
				value = value.Replace("\\b", "\b");
			}
			value = Validate(value);
			if (isSelected && mKeyboard != null && mCached != value)
			{
				mKeyboard.text = value;
				mCached = value;
			}
			if (!(mValue != value))
			{
				return;
			}
			mValue = value;
			mLoadSavedValue = false;
			if (isSelected)
			{
				if (string.IsNullOrEmpty(value))
				{
					mSelectionStart = 0;
					mSelectionEnd = 0;
				}
				else
				{
					mSelectionStart = value.Length;
					mSelectionEnd = mSelectionStart;
				}
			}
			else
			{
				SaveToPlayerPrefs(value);
			}
			UpdateLabel();
			ExecuteOnChange();
		}
	}

	[Obsolete("Use UIInput.isSelected instead")]
	public bool selected
	{
		get
		{
			return isSelected;
		}
		set
		{
			isSelected = value;
		}
	}

	public bool isSelected
	{
		get
		{
			return selection == this;
		}
		set
		{
			if (!value)
			{
				if (isSelected)
				{
					UICamera.selectedObject = null;
				}
			}
			else
			{
				UICamera.selectedObject = base.gameObject;
			}
		}
	}

	public int cursorPosition
	{
		get
		{
			if (mKeyboard != null && !inputShouldBeHidden)
			{
				return value.Length;
			}
			return (!isSelected) ? value.Length : mSelectionEnd;
		}
		set
		{
			if (isSelected && (mKeyboard == null || inputShouldBeHidden))
			{
				mSelectionEnd = value;
				UpdateLabel();
			}
		}
	}

	public int selectionStart
	{
		get
		{
			if (mKeyboard != null && !inputShouldBeHidden)
			{
				return 0;
			}
			return (!isSelected) ? value.Length : mSelectionStart;
		}
		set
		{
			if (isSelected && (mKeyboard == null || inputShouldBeHidden))
			{
				mSelectionStart = value;
				UpdateLabel();
			}
		}
	}

	public int selectionEnd
	{
		get
		{
			if (mKeyboard != null && !inputShouldBeHidden)
			{
				return value.Length;
			}
			return (!isSelected) ? value.Length : mSelectionEnd;
		}
		set
		{
			if (isSelected && (mKeyboard == null || inputShouldBeHidden))
			{
				mSelectionEnd = value;
				UpdateLabel();
			}
		}
	}

	public UITexture caret => mCaret;

	public string Validate(string val)
	{
		if (string.IsNullOrEmpty(val))
		{
			return string.Empty;
		}
		StringBuilder stringBuilder = new StringBuilder(val.Length);
		for (int i = 0; i < val.Length; i++)
		{
			char c = val[i];
			if (onValidate != null)
			{
				c = onValidate(stringBuilder.ToString(), stringBuilder.Length, c);
			}
			else if (validation != 0)
			{
				c = Validate(stringBuilder.ToString(), stringBuilder.Length, c);
			}
			if (c != 0)
			{
				stringBuilder.Append(c);
			}
		}
		if (characterLimit > 0 && stringBuilder.Length > characterLimit)
		{
			return stringBuilder.ToString(0, characterLimit);
		}
		return stringBuilder.ToString();
	}

	private void Start()
	{
		if (selectOnTab != null)
		{
			UIKeyNavigation component = GetComponent<UIKeyNavigation>();
			if (component == null)
			{
				component = base.gameObject.AddComponent<UIKeyNavigation>();
				component.onDown = selectOnTab;
			}
			selectOnTab = null;
			NGUITools.SetDirty(this);
		}
		if (mLoadSavedValue && !string.IsNullOrEmpty(savedAs))
		{
			LoadValue();
		}
		else
		{
			value = mValue.Replace("\\n", "\n");
		}
	}

	protected void Init()
	{
		if (mDoInit && label != null)
		{
			mDoInit = false;
			mDefaultText = label.text;
			mDefaultColor = label.color;
			label.supportEncoding = false;
			if (label.alignment == NGUIText.Alignment.Justified)
			{
				label.alignment = NGUIText.Alignment.Left;
				UnityEngine.Debug.LogWarning("Input fields using labels with justified alignment are not supported at this time", this);
			}
			mPivot = label.pivot;
			mPosition = label.cachedTransform.localPosition.x;
			UpdateLabel();
		}
	}

	protected void SaveToPlayerPrefs(string val)
	{
		if (!string.IsNullOrEmpty(savedAs))
		{
			if (string.IsNullOrEmpty(val))
			{
				PlayerPrefs.DeleteKey(savedAs);
			}
			else
			{
				PlayerPrefs.SetString(savedAs, val);
			}
		}
	}

	protected virtual void OnSelect(bool isSelected)
	{
		if (isSelected)
		{
			OnSelectEvent();
		}
		else
		{
			OnDeselectEvent();
		}
	}

	protected void OnSelectEvent()
	{
		selection = this;
		if (mDoInit)
		{
			Init();
		}
		if (label != null && NGUITools.GetActive(this))
		{
			mSelectMe = Time.frameCount;
		}
	}

	protected void OnDeselectEvent()
	{
		if (mDoInit)
		{
			Init();
		}
		if (label != null && NGUITools.GetActive(this))
		{
			mValue = value;
			if (mKeyboard != null)
			{
				mWaitForKeyboard = false;
				mKeyboard.active = false;
				mKeyboard = null;
			}
			if (string.IsNullOrEmpty(mValue))
			{
				label.text = mDefaultText;
				label.color = mDefaultColor;
			}
			else
			{
				label.text = mValue;
			}
			Input.imeCompositionMode = IMECompositionMode.Auto;
			RestoreLabelPivot();
		}
		selection = null;
		UpdateLabel();
	}

	protected virtual void Update()
	{
		if (!isSelected)
		{
			return;
		}
		if (mDoInit)
		{
			Init();
		}
		if (mWaitForKeyboard)
		{
			if (mKeyboard != null && !mKeyboard.active)
			{
				return;
			}
			mWaitForKeyboard = false;
		}
		if (mSelectMe != -1 && mSelectMe != Time.frameCount)
		{
			mSelectMe = -1;
			mSelectionEnd = ((!string.IsNullOrEmpty(mValue)) ? mValue.Length : 0);
			mDrawStart = 0;
			mSelectionStart = ((!selectAllTextOnFocus) ? mSelectionEnd : 0);
			label.color = activeTextColor;
			if (Application.platform == RuntimePlatform.IPhonePlayer || Application.platform == RuntimePlatform.Android || Application.platform == RuntimePlatform.WP8Player || Application.platform == RuntimePlatform.BlackBerryPlayer || Application.platform == RuntimePlatform.MetroPlayerARM || Application.platform == RuntimePlatform.MetroPlayerX64 || Application.platform == RuntimePlatform.MetroPlayerX86)
			{
				TouchScreenKeyboardType touchScreenKeyboardType;
				string text;
				if (inputShouldBeHidden)
				{
					TouchScreenKeyboard.hideInput = true;
					touchScreenKeyboardType = (TouchScreenKeyboardType)keyboardType;
					text = "|";
				}
				else if (inputType == InputType.Password)
				{
					TouchScreenKeyboard.hideInput = false;
					touchScreenKeyboardType = TouchScreenKeyboardType.Default;
					text = mValue;
					mSelectionStart = mSelectionEnd;
				}
				else
				{
					TouchScreenKeyboard.hideInput = false;
					touchScreenKeyboardType = (TouchScreenKeyboardType)keyboardType;
					text = mValue;
					mSelectionStart = mSelectionEnd;
				}
				mWaitForKeyboard = true;
				mKeyboard = ((inputType != InputType.Password) ? TouchScreenKeyboard.Open(text, touchScreenKeyboardType, !inputShouldBeHidden && inputType == InputType.AutoCorrect, label.multiLine && !hideInput, secure: false, alert: false, defaultText) : TouchScreenKeyboard.Open(text, touchScreenKeyboardType, autocorrection: false, multiline: false, secure: true));
			}
			else
			{
				Vector2 compositionCursorPos = ((!(UICamera.current != null) || !(UICamera.current.cachedCamera != null)) ? label.worldCorners[0] : UICamera.current.cachedCamera.WorldToScreenPoint(label.worldCorners[0]));
				compositionCursorPos.y = (float)Screen.height - compositionCursorPos.y;
				Input.imeCompositionMode = IMECompositionMode.On;
				Input.compositionCursorPos = compositionCursorPos;
			}
			UpdateLabel();
			if (string.IsNullOrEmpty(Input.inputString))
			{
				return;
			}
		}
		if (mKeyboard != null)
		{
			string text2 = mKeyboard.text;
			if (inputShouldBeHidden)
			{
				if (text2 != "|")
				{
					if (!string.IsNullOrEmpty(text2))
					{
						Insert(text2.Substring(1));
					}
					else
					{
						DoBackspace();
					}
					mKeyboard.text = "|";
				}
			}
			else if (mCached != text2)
			{
				mCached = text2;
				value = text2;
			}
			if (mKeyboard.done || !mKeyboard.active)
			{
				if (!mKeyboard.wasCanceled)
				{
					Submit();
				}
				mKeyboard = null;
				isSelected = false;
				mCached = string.Empty;
			}
		}
		else
		{
			string compositionString = Input.compositionString;
			if (string.IsNullOrEmpty(compositionString) && !string.IsNullOrEmpty(Input.inputString))
			{
				string inputString = Input.inputString;
				for (int i = 0; i < inputString.Length; i++)
				{
					char c = inputString[i];
					if (c >= ' ' && c != '\uf700' && c != '\uf701' && c != '\uf702' && c != '\uf703')
					{
						Insert(c.ToString());
					}
				}
			}
			if (mLastIME != compositionString)
			{
				mSelectionEnd = ((!string.IsNullOrEmpty(compositionString)) ? (mValue.Length + compositionString.Length) : mSelectionStart);
				mLastIME = compositionString;
				UpdateLabel();
				ExecuteOnChange();
			}
		}
		if (mCaret != null && mNextBlink < RealTime.time)
		{
			mNextBlink = RealTime.time + 0.5f;
			mCaret.enabled = !mCaret.enabled;
		}
		if (isSelected && mLastAlpha != label.finalAlpha)
		{
			UpdateLabel();
		}
	}

	protected void DoBackspace()
	{
		if (string.IsNullOrEmpty(mValue))
		{
			return;
		}
		if (mSelectionStart == mSelectionEnd)
		{
			if (mSelectionStart < 1)
			{
				return;
			}
			mSelectionEnd--;
		}
		Insert(string.Empty);
	}

	protected virtual void Insert(string text)
	{
		string leftText = GetLeftText();
		string rightText = GetRightText();
		int length = rightText.Length;
		StringBuilder stringBuilder = new StringBuilder(leftText.Length + rightText.Length + text.Length);
		stringBuilder.Append(leftText);
		int i = 0;
		for (int length2 = text.Length; i < length2; i++)
		{
			char c = text[i];
			if (c == '\b')
			{
				DoBackspace();
				continue;
			}
			if (characterLimit > 0 && stringBuilder.Length + length >= characterLimit)
			{
				break;
			}
			if (onValidate != null)
			{
				c = onValidate(stringBuilder.ToString(), stringBuilder.Length, c);
			}
			else if (validation != 0)
			{
				c = Validate(stringBuilder.ToString(), stringBuilder.Length, c);
			}
			if (c != 0)
			{
				stringBuilder.Append(c);
			}
		}
		mSelectionStart = stringBuilder.Length;
		mSelectionEnd = mSelectionStart;
		int j = 0;
		for (int length3 = rightText.Length; j < length3; j++)
		{
			char c2 = rightText[j];
			if (onValidate != null)
			{
				c2 = onValidate(stringBuilder.ToString(), stringBuilder.Length, c2);
			}
			else if (validation != 0)
			{
				c2 = Validate(stringBuilder.ToString(), stringBuilder.Length, c2);
			}
			if (c2 != 0)
			{
				stringBuilder.Append(c2);
			}
		}
		mValue = stringBuilder.ToString();
		UpdateLabel();
		ExecuteOnChange();
	}

	protected string GetLeftText()
	{
		int num = Mathf.Min(mSelectionStart, mSelectionEnd);
		return (!string.IsNullOrEmpty(mValue) && num >= 0) ? mValue.Substring(0, num) : string.Empty;
	}

	protected string GetRightText()
	{
		int num = Mathf.Max(mSelectionStart, mSelectionEnd);
		return (!string.IsNullOrEmpty(mValue) && num < mValue.Length) ? mValue.Substring(num) : string.Empty;
	}

	protected string GetSelection()
	{
		if (string.IsNullOrEmpty(mValue) || mSelectionStart == mSelectionEnd)
		{
			return string.Empty;
		}
		int num = Mathf.Min(mSelectionStart, mSelectionEnd);
		int num2 = Mathf.Max(mSelectionStart, mSelectionEnd);
		return mValue.Substring(num, num2 - num);
	}

	protected int GetCharUnderMouse()
	{
		Vector3[] worldCorners = label.worldCorners;
		Ray currentRay = UICamera.currentRay;
		float enter;
		return new Plane(worldCorners[0], worldCorners[1], worldCorners[2]).Raycast(currentRay, out enter) ? (mDrawStart + label.GetCharacterIndexAtPosition(currentRay.GetPoint(enter), precise: false)) : 0;
	}

	protected virtual void OnPress(bool isPressed)
	{
		if (isPressed && isSelected && label != null && (UICamera.currentScheme == UICamera.ControlScheme.Mouse || UICamera.currentScheme == UICamera.ControlScheme.Touch))
		{
			selectionEnd = GetCharUnderMouse();
			if (!Input.GetKey(KeyCode.LeftShift) && !Input.GetKey(KeyCode.RightShift))
			{
				selectionStart = mSelectionEnd;
			}
		}
	}

	protected virtual void OnDrag(Vector2 delta)
	{
		if (label != null && (UICamera.currentScheme == UICamera.ControlScheme.Mouse || UICamera.currentScheme == UICamera.ControlScheme.Touch))
		{
			selectionEnd = GetCharUnderMouse();
		}
	}

	private void OnDisable()
	{
		Cleanup();
	}

	protected virtual void Cleanup()
	{
		if ((bool)mHighlight)
		{
			mHighlight.enabled = false;
		}
		if ((bool)mCaret)
		{
			mCaret.enabled = false;
		}
		if ((bool)mBlankTex)
		{
			NGUITools.Destroy(mBlankTex);
			mBlankTex = null;
		}
	}

	public void Submit()
	{
		if (NGUITools.GetActive(this))
		{
			mValue = value;
			if (current == null)
			{
				current = this;
				EventDelegate.Execute(onSubmit);
				current = null;
			}
			SaveToPlayerPrefs(mValue);
		}
	}

	public void UpdateLabel()
	{
		if (!(label != null))
		{
			return;
		}
		if (mDoInit)
		{
			Init();
		}
		bool flag = isSelected;
		string text = value;
		bool flag2 = string.IsNullOrEmpty(text) && string.IsNullOrEmpty(Input.compositionString);
		label.color = ((!flag2 || flag) ? activeTextColor : mDefaultColor);
		string text2;
		if (flag2)
		{
			text2 = ((!flag) ? mDefaultText : string.Empty);
			RestoreLabelPivot();
		}
		else
		{
			if (inputType == InputType.Password)
			{
				text2 = string.Empty;
				string text3 = "*";
				if (label.bitmapFont != null && label.bitmapFont.bmFont != null && label.bitmapFont.bmFont.GetGlyph(42) == null)
				{
					text3 = "x";
				}
				int i = 0;
				for (int length = text.Length; i < length; i++)
				{
					text2 += text3;
				}
			}
			else
			{
				text2 = text;
			}
			int num = (flag ? Mathf.Min(text2.Length, cursorPosition) : 0);
			string text4 = text2.Substring(0, num);
			if (flag)
			{
				text4 += Input.compositionString;
			}
			text2 = text4 + text2.Substring(num, text2.Length - num);
			if (flag && label.overflowMethod == UILabel.Overflow.ClampContent && label.maxLineCount == 1)
			{
				int num2 = label.CalculateOffsetToFit(text2);
				if (num2 == 0)
				{
					mDrawStart = 0;
					RestoreLabelPivot();
				}
				else if (num < mDrawStart)
				{
					mDrawStart = num;
					SetPivotToLeft();
				}
				else if (num2 < mDrawStart)
				{
					mDrawStart = num2;
					SetPivotToLeft();
				}
				else
				{
					num2 = label.CalculateOffsetToFit(text2.Substring(0, num));
					if (num2 > mDrawStart)
					{
						mDrawStart = num2;
						SetPivotToRight();
					}
				}
				if (mDrawStart != 0)
				{
					text2 = text2.Substring(mDrawStart, text2.Length - mDrawStart);
				}
			}
			else
			{
				mDrawStart = 0;
				RestoreLabelPivot();
			}
		}
		label.text = text2;
		if (flag && (mKeyboard == null || inputShouldBeHidden))
		{
			int num3 = mSelectionStart - mDrawStart;
			int num4 = mSelectionEnd - mDrawStart;
			if (mBlankTex == null)
			{
				mBlankTex = new Texture2D(2, 2, TextureFormat.ARGB32, mipmap: false);
				for (int j = 0; j < 2; j++)
				{
					for (int k = 0; k < 2; k++)
					{
						mBlankTex.SetPixel(k, j, UnityEngine.Color.white);
					}
				}
				mBlankTex.Apply();
			}
			if (num3 != num4)
			{
				if (mHighlight == null)
				{
					mHighlight = NGUITools.AddWidget<UITexture>(label.cachedGameObject);
					mHighlight.name = "Input Highlight";
					mHighlight.mainTexture = mBlankTex;
					mHighlight.fillGeometry = false;
					mHighlight.pivot = label.pivot;
					mHighlight.SetAnchor(label.cachedTransform);
				}
				else
				{
					mHighlight.pivot = label.pivot;
					mHighlight.mainTexture = mBlankTex;
					mHighlight.MarkAsChanged();
					mHighlight.enabled = true;
				}
			}
			if (mCaret == null)
			{
				mCaret = NGUITools.AddWidget<UITexture>(label.cachedGameObject);
				mCaret.name = "Input Caret";
				mCaret.mainTexture = mBlankTex;
				mCaret.fillGeometry = false;
				mCaret.pivot = label.pivot;
				mCaret.SetAnchor(label.cachedTransform);
			}
			else
			{
				mCaret.pivot = label.pivot;
				mCaret.mainTexture = mBlankTex;
				mCaret.MarkAsChanged();
				mCaret.enabled = true;
			}
			if (num3 != num4)
			{
				label.PrintOverlay(num3, num4, mCaret.geometry, mHighlight.geometry, caretColor, selectionColor);
				mHighlight.enabled = mHighlight.geometry.hasVertices;
			}
			else
			{
				label.PrintOverlay(num3, num4, mCaret.geometry, null, caretColor, selectionColor);
				if (mHighlight != null)
				{
					mHighlight.enabled = false;
				}
			}
			mNextBlink = RealTime.time + 0.5f;
			mLastAlpha = label.finalAlpha;
		}
		else
		{
			Cleanup();
		}
	}

	protected void SetPivotToLeft()
	{
		Vector2 pivotOffset = NGUIMath.GetPivotOffset(mPivot);
		pivotOffset.x = 0f;
		label.pivot = NGUIMath.GetPivot(pivotOffset);
	}

	protected void SetPivotToRight()
	{
		Vector2 pivotOffset = NGUIMath.GetPivotOffset(mPivot);
		pivotOffset.x = 1f;
		label.pivot = NGUIMath.GetPivot(pivotOffset);
	}

	protected void RestoreLabelPivot()
	{
		if (label != null && label.pivot != mPivot)
		{
			label.pivot = mPivot;
		}
	}

	protected char Validate(string text, int pos, char ch)
	{
		if (validation == Validation.None || !base.enabled)
		{
			return ch;
		}
		if (validation == Validation.Integer)
		{
			if (ch >= '0' && ch <= '9')
			{
				return ch;
			}
			if (ch == '-' && pos == 0 && !text.Contains("-"))
			{
				return ch;
			}
		}
		else if (validation == Validation.Float)
		{
			if (ch >= '0' && ch <= '9')
			{
				return ch;
			}
			if (ch == '-' && pos == 0 && !text.Contains("-"))
			{
				return ch;
			}
			if (ch == '.' && !text.Contains("."))
			{
				return ch;
			}
		}
		else if (validation == Validation.Alphanumeric)
		{
			if (ch >= 'A' && ch <= 'Z')
			{
				return ch;
			}
			if (ch >= 'a' && ch <= 'z')
			{
				return ch;
			}
			if (ch >= '0' && ch <= '9')
			{
				return ch;
			}
		}
		else if (validation == Validation.Username)
		{
			if (ch >= 'A' && ch <= 'Z')
			{
				return (char)(ch - 65 + 97);
			}
			if (ch >= 'a' && ch <= 'z')
			{
				return ch;
			}
			if (ch >= '0' && ch <= '9')
			{
				return ch;
			}
		}
		else if (validation == Validation.Name)
		{
			char c = ((text.Length <= 0) ? ' ' : text[Mathf.Clamp(pos, 0, text.Length - 1)]);
			char c2 = ((text.Length <= 0) ? '\n' : text[Mathf.Clamp(pos + 1, 0, text.Length - 1)]);
			if (ch >= 'a' && ch <= 'z')
			{
				if (c == ' ')
				{
					return (char)(ch - 97 + 65);
				}
				return ch;
			}
			if (ch >= 'A' && ch <= 'Z')
			{
				if (c != ' ' && c != '\'')
				{
					return (char)(ch - 65 + 97);
				}
				return ch;
			}
			switch (ch)
			{
			case '\'':
				if (c != ' ' && c != '\'' && c2 != '\'' && !text.Contains("'"))
				{
					return ch;
				}
				break;
			case ' ':
				if (c != ' ' && c != '\'' && c2 != ' ' && c2 != '\'')
				{
					return ch;
				}
				break;
			}
		}
		return '\0';
	}

	protected void ExecuteOnChange()
	{
		if (current == null && EventDelegate.IsValid(onChange))
		{
			current = this;
			EventDelegate.Execute(onChange);
			current = null;
		}
	}

	public void RemoveFocus()
	{
		isSelected = false;
	}

	public void SaveValue()
	{
		SaveToPlayerPrefs(mValue);
	}

	public void LoadValue()
	{
		if (!string.IsNullOrEmpty(savedAs))
		{
			string text = mValue.Replace("\\n", "\n");
			mValue = string.Empty;
			value = ((!PlayerPrefs.HasKey(savedAs)) ? text : PlayerPrefs.GetString(savedAs));
		}
	}
}
[RequireComponent(typeof(UIInput))]
public class UIInputOnGUI : MonoBehaviour
{
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/UI/NGUI Label")]
public class UILabel : UIWidget
{
	public enum Effect
	{
		None,
		Shadow,
		Outline
	}

	public enum Overflow
	{
		ShrinkContent,
		ClampContent,
		ResizeFreely,
		ResizeHeight
	}

	public enum Crispness
	{
		Never,
		OnDesktop,
		Always
	}

	public Crispness keepCrispWhenShrunk = Crispness.OnDesktop;

	[HideInInspector]
	[SerializeField]
	private UnityEngine.Font mTrueTypeFont;

	[HideInInspector]
	[SerializeField]
	private UIFont mFont;

	[Multiline(6)]
	[HideInInspector]
	[SerializeField]
	private string mText = string.Empty;

	[HideInInspector]
	[SerializeField]
	private int mFontSize = 16;

	[HideInInspector]
	[SerializeField]
	private UnityEngine.FontStyle mFontStyle;

	[HideInInspector]
	[SerializeField]
	private NGUIText.Alignment mAlignment;

	[HideInInspector]
	[SerializeField]
	private bool mEncoding = true;

	[HideInInspector]
	[SerializeField]
	private int mMaxLineCount;

	[HideInInspector]
	[SerializeField]
	private Effect mEffectStyle;

	[HideInInspector]
	[SerializeField]
	private UnityEngine.Color mEffectColor = UnityEngine.Color.black;

	[HideInInspector]
	[SerializeField]
	private NGUIText.SymbolStyle mSymbols = NGUIText.SymbolStyle.Normal;

	[HideInInspector]
	[SerializeField]
	private Vector2 mEffectDistance = Vector2.one;

	[HideInInspector]
	[SerializeField]
	private Overflow mOverflow;

	[HideInInspector]
	[SerializeField]
	private Material mMaterial;

	[HideInInspector]
	[SerializeField]
	private bool mApplyGradient;

	[HideInInspector]
	[SerializeField]
	private UnityEngine.Color mGradientTop = UnityEngine.Color.white;

	[HideInInspector]
	[SerializeField]
	private UnityEngine.Color mGradientBottom = new UnityEngine.Color(0.7f, 0.7f, 0.7f);

	[HideInInspector]
	[SerializeField]
	private int mSpacingX;

	[HideInInspector]
	[SerializeField]
	private int mSpacingY;

	[HideInInspector]
	[SerializeField]
	private bool mShrinkToFit;

	[HideInInspector]
	[SerializeField]
	private int mMaxLineWidth;

	[HideInInspector]
	[SerializeField]
	private int mMaxLineHeight;

	[HideInInspector]
	[SerializeField]
	private float mLineWidth;

	[HideInInspector]
	[SerializeField]
	private bool mMultiline = true;

	[NonSerialized]
	private UnityEngine.Font mActiveTTF;

	private float mDensity = 1f;

	private bool mShouldBeProcessed = true;

	private string mProcessedText;

	private bool mPremultiply;

	private Vector2 mCalculatedSize = Vector2.zero;

	private float mScale = 1f;

	private int mPrintedSize;

	private int mLastWidth;

	private int mLastHeight;

	private static BetterList<UILabel> mList = new BetterList<UILabel>();

	private static Dictionary<UnityEngine.Font, int> mFontUsage = new Dictionary<UnityEngine.Font, int>();

	private static BetterList<Vector3> mTempVerts = new BetterList<Vector3>();

	private static BetterList<int> mTempIndices = new BetterList<int>();

	private bool shouldBeProcessed
	{
		get
		{
			return mShouldBeProcessed;
		}
		set
		{
			if (value)
			{
				mChanged = true;
				mShouldBeProcessed = true;
			}
			else
			{
				mShouldBeProcessed = false;
			}
		}
	}

	public override bool isAnchoredHorizontally => base.isAnchoredHorizontally || mOverflow == Overflow.ResizeFreely;

	public override bool isAnchoredVertically => base.isAnchoredVertically || mOverflow == Overflow.ResizeFreely || mOverflow == Overflow.ResizeHeight;

	public override Material material
	{
		get
		{
			if (mMaterial != null)
			{
				return mMaterial;
			}
			if (mFont != null)
			{
				return mFont.material;
			}
			if (mTrueTypeFont != null)
			{
				return mTrueTypeFont.material;
			}
			return null;
		}
		set
		{
			if (mMaterial != value)
			{
				RemoveFromPanel();
				mMaterial = value;
				MarkAsChanged();
			}
		}
	}

	[Obsolete("Use UILabel.bitmapFont instead")]
	public UIFont font
	{
		get
		{
			return bitmapFont;
		}
		set
		{
			bitmapFont = value;
		}
	}

	public UIFont bitmapFont
	{
		get
		{
			return mFont;
		}
		set
		{
			if (mFont != value)
			{
				RemoveFromPanel();
				mFont = value;
				mTrueTypeFont = null;
				MarkAsChanged();
			}
		}
	}

	public UnityEngine.Font trueTypeFont
	{
		get
		{
			if (mTrueTypeFont != null)
			{
				return mTrueTypeFont;
			}
			return (!(mFont != null)) ? null : mFont.dynamicFont;
		}
		set
		{
			if (mTrueTypeFont != value)
			{
				SetActiveFont(null);
				RemoveFromPanel();
				mTrueTypeFont = value;
				shouldBeProcessed = true;
				mFont = null;
				SetActiveFont(value);
				ProcessAndRequest();
				if (mActiveTTF != null)
				{
					base.MarkAsChanged();
				}
			}
		}
	}

	public UnityEngine.Object ambigiousFont
	{
		get
		{
			return (!(mFont != null)) ? ((UnityEngine.Object)mTrueTypeFont) : ((UnityEngine.Object)mFont);
		}
		set
		{
			UIFont uIFont = value as UIFont;
			if (uIFont != null)
			{
				bitmapFont = uIFont;
			}
			else
			{
				trueTypeFont = value as UnityEngine.Font;
			}
		}
	}

	public string text
	{
		get
		{
			return mText;
		}
		set
		{
			if (mText == value)
			{
				return;
			}
			if (string.IsNullOrEmpty(value))
			{
				if (!string.IsNullOrEmpty(mText))
				{
					mText = string.Empty;
					MarkAsChanged();
					ProcessAndRequest();
				}
			}
			else if (mText != value)
			{
				mText = value;
				MarkAsChanged();
				ProcessAndRequest();
			}
			if (autoResizeBoxCollider)
			{
				ResizeCollider();
			}
		}
	}

	public int defaultFontSize => (trueTypeFont != null) ? mFontSize : ((!(mFont != null)) ? 16 : mFont.defaultSize);

	public int fontSize
	{
		get
		{
			return mFontSize;
		}
		set
		{
			value = Mathf.Clamp(value, 0, 256);
			if (mFontSize != value)
			{
				mFontSize = value;
				shouldBeProcessed = true;
				ProcessAndRequest();
			}
		}
	}

	public UnityEngine.FontStyle fontStyle
	{
		get
		{
			return mFontStyle;
		}
		set
		{
			if (mFontStyle != value)
			{
				mFontStyle = value;
				shouldBeProcessed = true;
				ProcessAndRequest();
			}
		}
	}

	public NGUIText.Alignment alignment
	{
		get
		{
			return mAlignment;
		}
		set
		{
			if (mAlignment != value)
			{
				mAlignment = value;
				shouldBeProcessed = true;
				ProcessAndRequest();
			}
		}
	}

	public bool applyGradient
	{
		get
		{
			return mApplyGradient;
		}
		set
		{
			if (mApplyGradient != value)
			{
				mApplyGradient = value;
				MarkAsChanged();
			}
		}
	}

	public UnityEngine.Color gradientTop
	{
		get
		{
			return mGradientTop;
		}
		set
		{
			if (mGradientTop != value)
			{
				mGradientTop = value;
				if (mApplyGradient)
				{
					MarkAsChanged();
				}
			}
		}
	}

	public UnityEngine.Color gradientBottom
	{
		get
		{
			return mGradientBottom;
		}
		set
		{
			if (mGradientBottom != value)
			{
				mGradientBottom = value;
				if (mApplyGradient)
				{
					MarkAsChanged();
				}
			}
		}
	}

	public int spacingX
	{
		get
		{
			return mSpacingX;
		}
		set
		{
			if (mSpacingX != value)
			{
				mSpacingX = value;
				MarkAsChanged();
			}
		}
	}

	public int spacingY
	{
		get
		{
			return mSpacingY;
		}
		set
		{
			if (mSpacingY != value)
			{
				mSpacingY = value;
				MarkAsChanged();
			}
		}
	}

	private bool keepCrisp
	{
		get
		{
			if (trueTypeFont != null && keepCrispWhenShrunk != 0)
			{
				return keepCrispWhenShrunk == Crispness.Always;
			}
			return false;
		}
	}

	public bool supportEncoding
	{
		get
		{
			return mEncoding;
		}
		set
		{
			if (mEncoding != value)
			{
				mEncoding = value;
				shouldBeProcessed = true;
			}
		}
	}

	public NGUIText.SymbolStyle symbolStyle
	{
		get
		{
			return mSymbols;
		}
		set
		{
			if (mSymbols != value)
			{
				mSymbols = value;
				shouldBeProcessed = true;
			}
		}
	}

	public Overflow overflowMethod
	{
		get
		{
			return mOverflow;
		}
		set
		{
			if (mOverflow != value)
			{
				mOverflow = value;
				shouldBeProcessed = true;
			}
		}
	}

	[Obsolete("Use 'width' instead")]
	public int lineWidth
	{
		get
		{
			return base.width;
		}
		set
		{
			base.width = value;
		}
	}

	[Obsolete("Use 'height' instead")]
	public int lineHeight
	{
		get
		{
			return base.height;
		}
		set
		{
			base.height = value;
		}
	}

	public bool multiLine
	{
		get
		{
			return mMaxLineCount != 1;
		}
		set
		{
			if (mMaxLineCount != 1 != value)
			{
				mMaxLineCount = ((!value) ? 1 : 0);
				shouldBeProcessed = true;
			}
		}
	}

	public override Vector3[] localCorners
	{
		get
		{
			if (shouldBeProcessed)
			{
				ProcessText();
			}
			return base.localCorners;
		}
	}

	public override Vector3[] worldCorners
	{
		get
		{
			if (shouldBeProcessed)
			{
				ProcessText();
			}
			return base.worldCorners;
		}
	}

	public override Vector4 drawingDimensions
	{
		get
		{
			if (shouldBeProcessed)
			{
				ProcessText();
			}
			return base.drawingDimensions;
		}
	}

	public int maxLineCount
	{
		get
		{
			return mMaxLineCount;
		}
		set
		{
			if (mMaxLineCount != value)
			{
				mMaxLineCount = Mathf.Max(value, 0);
				shouldBeProcessed = true;
				if (overflowMethod == Overflow.ShrinkContent)
				{
					MakePixelPerfect();
				}
			}
		}
	}

	public Effect effectStyle
	{
		get
		{
			return mEffectStyle;
		}
		set
		{
			if (mEffectStyle != value)
			{
				mEffectStyle = value;
				shouldBeProcessed = true;
			}
		}
	}

	public UnityEngine.Color effectColor
	{
		get
		{
			return mEffectColor;
		}
		set
		{
			if (mEffectColor != value)
			{
				mEffectColor = value;
				if (mEffectStyle != 0)
				{
					shouldBeProcessed = true;
				}
			}
		}
	}

	public Vector2 effectDistance
	{
		get
		{
			return mEffectDistance;
		}
		set
		{
			if (mEffectDistance != value)
			{
				mEffectDistance = value;
				shouldBeProcessed = true;
			}
		}
	}

	[Obsolete("Use 'overflowMethod == UILabel.Overflow.ShrinkContent' instead")]
	public bool shrinkToFit
	{
		get
		{
			return mOverflow == Overflow.ShrinkContent;
		}
		set
		{
			if (value)
			{
				overflowMethod = Overflow.ShrinkContent;
			}
		}
	}

	public string processedText
	{
		get
		{
			if (mLastWidth != mWidth || mLastHeight != mHeight)
			{
				mLastWidth = mWidth;
				mLastHeight = mHeight;
				mShouldBeProcessed = true;
			}
			if (shouldBeProcessed)
			{
				ProcessText();
			}
			return mProcessedText;
		}
	}

	public Vector2 printedSize
	{
		get
		{
			if (shouldBeProcessed)
			{
				ProcessText();
			}
			return mCalculatedSize;
		}
	}

	public override Vector2 localSize
	{
		get
		{
			if (shouldBeProcessed)
			{
				ProcessText();
			}
			return base.localSize;
		}
	}

	private bool isValid => mFont != null || mTrueTypeFont != null;

	protected override void OnInit()
	{
		base.OnInit();
		mList.Add(this);
		SetActiveFont(trueTypeFont);
	}

	protected override void OnDisable()
	{
		SetActiveFont(null);
		mList.Remove(this);
		base.OnDisable();
	}

	protected void SetActiveFont(UnityEngine.Font fnt)
	{
		if (!(mActiveTTF != fnt))
		{
			return;
		}
		if (mActiveTTF != null)
		{
			if (mFontUsage.TryGetValue(mActiveTTF, out var value))
			{
				value = Mathf.Max(0, --value);
				if (value == 0)
				{
					mActiveTTF.textureRebuildCallback = null;
					mFontUsage.Remove(mActiveTTF);
				}
				else
				{
					mFontUsage[mActiveTTF] = value;
				}
			}
			else
			{
				mActiveTTF.textureRebuildCallback = null;
			}
		}
		mActiveTTF = fnt;
		if (mActiveTTF != null)
		{
			int value2 = 0;
			if (!mFontUsage.TryGetValue(mActiveTTF, out value2))
			{
				mActiveTTF.textureRebuildCallback = OnFontTextureChanged;
			}
			value2 = (mFontUsage[mActiveTTF] = value2 + 1);
		}
	}

	private static void OnFontTextureChanged()
	{
		for (int i = 0; i < mList.size; i++)
		{
			UILabel uILabel = mList[i];
			if (uILabel != null)
			{
				UnityEngine.Font font = uILabel.trueTypeFont;
				if (font != null)
				{
					font.RequestCharactersInTexture(uILabel.mText, uILabel.mPrintedSize, uILabel.mFontStyle);
				}
			}
		}
		for (int j = 0; j < mList.size; j++)
		{
			UILabel uILabel2 = mList[j];
			if (uILabel2 != null)
			{
				UnityEngine.Font font2 = uILabel2.trueTypeFont;
				if (font2 != null)
				{
					uILabel2.RemoveFromPanel();
					uILabel2.CreatePanel();
				}
			}
		}
	}

	public override Vector3[] GetSides(Transform relativeTo)
	{
		if (shouldBeProcessed)
		{
			ProcessText();
		}
		return base.GetSides(relativeTo);
	}

	protected override void UpgradeFrom265()
	{
		ProcessText(legacyMode: true, full: true);
		if (mShrinkToFit)
		{
			overflowMethod = Overflow.ShrinkContent;
			mMaxLineCount = 0;
		}
		if (mMaxLineWidth != 0)
		{
			base.width = mMaxLineWidth;
			overflowMethod = ((mMaxLineCount > 0) ? Overflow.ResizeHeight : Overflow.ShrinkContent);
		}
		else
		{
			overflowMethod = Overflow.ResizeFreely;
		}
		if (mMaxLineHeight != 0)
		{
			base.height = mMaxLineHeight;
		}
		if (mFont != null)
		{
			int defaultSize = mFont.defaultSize;
			if (base.height < defaultSize)
			{
				base.height = defaultSize;
			}
			fontSize = defaultSize;
		}
		mMaxLineWidth = 0;
		mMaxLineHeight = 0;
		mShrinkToFit = false;
		NGUITools.UpdateWidgetCollider(base.gameObject, considerInactive: true);
	}

	protected override void OnAnchor()
	{
		if (mOverflow == Overflow.ResizeFreely)
		{
			if (base.isFullyAnchored)
			{
				mOverflow = Overflow.ShrinkContent;
			}
		}
		else if (mOverflow == Overflow.ResizeHeight && topAnchor.target != null && bottomAnchor.target != null)
		{
			mOverflow = Overflow.ShrinkContent;
		}
		base.OnAnchor();
	}

	private void ProcessAndRequest()
	{
		if (ambigiousFont != null)
		{
			ProcessText();
		}
	}

	protected override void OnStart()
	{
		base.OnStart();
		if (mLineWidth > 0f)
		{
			mMaxLineWidth = Mathf.RoundToInt(mLineWidth);
			mLineWidth = 0f;
		}
		if (!mMultiline)
		{
			mMaxLineCount = 1;
			mMultiline = true;
		}
		mPremultiply = material != null && material.shader != null && material.shader.name.Contains("Premultiplied");
		ProcessAndRequest();
	}

	public override void MarkAsChanged()
	{
		shouldBeProcessed = true;
		base.MarkAsChanged();
	}

	public void ProcessText()
	{
		ProcessText(legacyMode: false, full: true);
	}

	private void ProcessText(bool legacyMode, bool full)
	{
		if (!isValid)
		{
			return;
		}
		mChanged = true;
		shouldBeProcessed = false;
		float num = mDrawRegion.z - mDrawRegion.x;
		float num2 = mDrawRegion.w - mDrawRegion.y;
		NGUIText.rectWidth = ((!legacyMode) ? base.width : ((mMaxLineWidth == 0) ? 1000000 : mMaxLineWidth));
		NGUIText.rectHeight = ((!legacyMode) ? base.height : ((mMaxLineHeight == 0) ? 1000000 : mMaxLineHeight));
		NGUIText.regionWidth = ((num == 1f) ? NGUIText.rectWidth : Mathf.RoundToInt((float)NGUIText.rectWidth * num));
		NGUIText.regionHeight = ((num2 == 1f) ? NGUIText.rectHeight : Mathf.RoundToInt((float)NGUIText.rectHeight * num2));
		mPrintedSize = Mathf.Abs((!legacyMode) ? defaultFontSize : Mathf.RoundToInt(base.cachedTransform.localScale.x));
		mScale = 1f;
		if (NGUIText.regionWidth < 1 || NGUIText.regionHeight < 0)
		{
			mProcessedText = string.Empty;
			return;
		}
		bool flag = trueTypeFont != null;
		if (flag && keepCrisp)
		{
			UIRoot uIRoot = base.root;
			if (uIRoot != null)
			{
				mDensity = ((!(uIRoot != null)) ? 1f : uIRoot.pixelSizeAdjustment);
			}
		}
		else
		{
			mDensity = 1f;
		}
		if (full)
		{
			UpdateNGUIText();
		}
		if (mOverflow == Overflow.ResizeFreely)
		{
			NGUIText.rectWidth = 1000000;
			NGUIText.regionWidth = 1000000;
		}
		if (mOverflow == Overflow.ResizeFreely || mOverflow == Overflow.ResizeHeight)
		{
			NGUIText.rectHeight = 1000000;
			NGUIText.regionHeight = 1000000;
		}
		if (mPrintedSize > 0)
		{
			bool flag2 = keepCrisp;
			int num3 = mPrintedSize;
			while (num3 > 0)
			{
				if (flag2)
				{
					mPrintedSize = num3;
					NGUIText.fontSize = mPrintedSize;
				}
				else
				{
					mScale = (float)num3 / (float)mPrintedSize;
					NGUIText.fontScale = ((!flag) ? ((float)mFontSize / (float)mFont.defaultSize * mScale) : mScale);
				}
				NGUIText.Update(request: false);
				bool flag3 = NGUIText.WrapText(mText, out mProcessedText, keepCharCount: true);
				if (mOverflow == Overflow.ShrinkContent && !flag3)
				{
					if (--num3 <= 1)
					{
						break;
					}
					num3--;
					continue;
				}
				if (mOverflow == Overflow.ResizeFreely)
				{
					mCalculatedSize = NGUIText.CalculatePrintedSize(mProcessedText);
					mWidth = Mathf.Max(minWidth, Mathf.RoundToInt(mCalculatedSize.x));
					if (num != 1f)
					{
						mWidth = Mathf.RoundToInt((float)mWidth / num);
					}
					mHeight = Mathf.Max(minHeight, Mathf.RoundToInt(mCalculatedSize.y));
					if (num2 != 1f)
					{
						mHeight = Mathf.RoundToInt((float)mHeight / num2);
					}
					if ((mWidth & 1) == 1)
					{
						mWidth++;
					}
					if ((mHeight & 1) == 1)
					{
						mHeight++;
					}
				}
				else if (mOverflow == Overflow.ResizeHeight)
				{
					mCalculatedSize = NGUIText.CalculatePrintedSize(mProcessedText);
					mHeight = Mathf.Max(minHeight, Mathf.RoundToInt(mCalculatedSize.y));
					if (num2 != 1f)
					{
						mHeight = Mathf.RoundToInt((float)mHeight / num2);
					}
					if ((mHeight & 1) == 1)
					{
						mHeight++;
					}
				}
				else
				{
					mCalculatedSize = NGUIText.CalculatePrintedSize(mProcessedText);
				}
				if (legacyMode)
				{
					base.width = Mathf.RoundToInt(mCalculatedSize.x);
					base.height = Mathf.RoundToInt(mCalculatedSize.y);
					base.cachedTransform.localScale = Vector3.one;
				}
				break;
			}
		}
		else
		{
			base.cachedTransform.localScale = Vector3.one;
			mProcessedText = string.Empty;
			mScale = 1f;
		}
		if (full)
		{
			NGUIText.bitmapFont = null;
			NGUIText.dynamicFont = null;
		}
	}

	public override void MakePixelPerfect()
	{
		if (ambigiousFont != null)
		{
			Vector3 localPosition = base.cachedTransform.localPosition;
			localPosition.x = Mathf.RoundToInt(localPosition.x);
			localPosition.y = Mathf.RoundToInt(localPosition.y);
			localPosition.z = Mathf.RoundToInt(localPosition.z);
			base.cachedTransform.localPosition = localPosition;
			base.cachedTransform.localScale = Vector3.one;
			if (mOverflow == Overflow.ResizeFreely)
			{
				AssumeNaturalSize();
				return;
			}
			int a = base.width;
			int a2 = base.height;
			Overflow overflow = mOverflow;
			if (overflow != Overflow.ResizeHeight)
			{
				mWidth = 100000;
			}
			mHeight = 100000;
			mOverflow = Overflow.ShrinkContent;
			ProcessText(legacyMode: false, full: true);
			mOverflow = overflow;
			int a3 = Mathf.RoundToInt(mCalculatedSize.x);
			int a4 = Mathf.RoundToInt(mCalculatedSize.y);
			a3 = Mathf.Max(a3, base.minWidth);
			a4 = Mathf.Max(a4, base.minHeight);
			mWidth = Mathf.Max(a, a3);
			mHeight = Mathf.Max(a2, a4);
			MarkAsChanged();
		}
		else
		{
			base.MakePixelPerfect();
		}
	}

	public void AssumeNaturalSize()
	{
		if (ambigiousFont != null)
		{
			mWidth = 100000;
			mHeight = 100000;
			ProcessText(legacyMode: false, full: true);
			mWidth = Mathf.RoundToInt(mCalculatedSize.x);
			mHeight = Mathf.RoundToInt(mCalculatedSize.y);
			if ((mWidth & 1) == 1)
			{
				mWidth++;
			}
			if ((mHeight & 1) == 1)
			{
				mHeight++;
			}
			MarkAsChanged();
		}
	}

	[Obsolete("Use UILabel.GetCharacterAtPosition instead")]
	public int GetCharacterIndex(Vector3 worldPos)
	{
		return GetCharacterIndexAtPosition(worldPos, precise: false);
	}

	[Obsolete("Use UILabel.GetCharacterAtPosition instead")]
	public int GetCharacterIndex(Vector2 localPos)
	{
		return GetCharacterIndexAtPosition(localPos, precise: false);
	}

	public int GetCharacterIndexAtPosition(Vector3 worldPos, bool precise)
	{
		Vector2 localPos = base.cachedTransform.InverseTransformPoint(worldPos);
		return GetCharacterIndexAtPosition(localPos, precise);
	}

	public int GetCharacterIndexAtPosition(Vector2 localPos, bool precise)
	{
		if (isValid)
		{
			string value = processedText;
			if (string.IsNullOrEmpty(value))
			{
				return 0;
			}
			UpdateNGUIText();
			if (precise)
			{
				NGUIText.PrintExactCharacterPositions(value, mTempVerts, mTempIndices);
			}
			else
			{
				NGUIText.PrintApproximateCharacterPositions(value, mTempVerts, mTempIndices);
			}
			if (mTempVerts.size > 0)
			{
				ApplyOffset(mTempVerts, 0);
				int result = ((!precise) ? NGUIText.GetApproximateCharacterIndex(mTempVerts, mTempIndices, localPos) : NGUIText.GetExactCharacterIndex(mTempVerts, mTempIndices, localPos));
				mTempVerts.Clear();
				mTempIndices.Clear();
				NGUIText.bitmapFont = null;
				NGUIText.dynamicFont = null;
				return result;
			}
			NGUIText.bitmapFont = null;
			NGUIText.dynamicFont = null;
		}
		return 0;
	}

	public string GetWordAtPosition(Vector3 worldPos)
	{
		int characterIndexAtPosition = GetCharacterIndexAtPosition(worldPos, precise: true);
		return GetWordAtCharacterIndex(characterIndexAtPosition);
	}

	public string GetWordAtPosition(Vector2 localPos)
	{
		int characterIndexAtPosition = GetCharacterIndexAtPosition(localPos, precise: true);
		return GetWordAtCharacterIndex(characterIndexAtPosition);
	}

	public string GetWordAtCharacterIndex(int characterIndex)
	{
		if (characterIndex != -1 && characterIndex < mText.Length)
		{
			int num = mText.LastIndexOfAny(new char[2] { ' ', '\n' }, characterIndex) + 1;
			int num2 = mText.IndexOfAny(new char[4] { ' ', '\n', ',', '.' }, characterIndex);
			if (num2 == -1)
			{
				num2 = mText.Length;
			}
			if (num != num2)
			{
				int num3 = num2 - num;
				if (num3 > 0)
				{
					string text = mText.Substring(num, num3);
					return NGUIText.StripSymbols(text);
				}
			}
		}
		return null;
	}

	public string GetUrlAtPosition(Vector3 worldPos)
	{
		return GetUrlAtCharacterIndex(GetCharacterIndexAtPosition(worldPos, precise: true));
	}

	public string GetUrlAtPosition(Vector2 localPos)
	{
		return GetUrlAtCharacterIndex(GetCharacterIndexAtPosition(localPos, precise: true));
	}

	public string GetUrlAtCharacterIndex(int characterIndex)
	{
		if (characterIndex != -1 && characterIndex < mText.Length - 6)
		{
			int num = ((mText[characterIndex] != '[' || mText[characterIndex + 1] != 'u' || mText[characterIndex + 2] != 'r' || mText[characterIndex + 3] != 'l' || mText[characterIndex + 4] != '=') ? mText.LastIndexOf("[url=", characterIndex) : characterIndex);
			if (num == -1)
			{
				return null;
			}
			num += 5;
			int num2 = mText.IndexOf("]", num);
			if (num2 == -1)
			{
				return null;
			}
			int num3 = mText.IndexOf("[/url]", num2);
			if (num3 == -1 || characterIndex <= num3)
			{
				return mText.Substring(num, num2 - num);
			}
		}
		return null;
	}

	public int GetCharacterIndex(int currentIndex, KeyCode key)
	{
		if (isValid)
		{
			string text = processedText;
			if (string.IsNullOrEmpty(text))
			{
				return 0;
			}
			int num = defaultFontSize;
			UpdateNGUIText();
			NGUIText.PrintApproximateCharacterPositions(text, mTempVerts, mTempIndices);
			if (mTempVerts.size > 0)
			{
				ApplyOffset(mTempVerts, 0);
				for (int i = 0; i < mTempIndices.size; i++)
				{
					if (mTempIndices[i] == currentIndex)
					{
						Vector2 pos = mTempVerts[i];
						switch (key)
						{
						case KeyCode.UpArrow:
							pos.y += num + spacingY;
							break;
						case KeyCode.DownArrow:
							pos.y -= num + spacingY;
							break;
						case KeyCode.Home:
							pos.x -= 1000f;
							break;
						case KeyCode.End:
							pos.x += 1000f;
							break;
						}
						int approximateCharacterIndex = NGUIText.GetApproximateCharacterIndex(mTempVerts, mTempIndices, pos);
						if (approximateCharacterIndex == currentIndex)
						{
							break;
						}
						mTempVerts.Clear();
						mTempIndices.Clear();
						return approximateCharacterIndex;
					}
				}
				mTempVerts.Clear();
				mTempIndices.Clear();
			}
			NGUIText.bitmapFont = null;
			NGUIText.dynamicFont = null;
			switch (key)
			{
			case KeyCode.UpArrow:
			case KeyCode.Home:
				return 0;
			case KeyCode.DownArrow:
			case KeyCode.End:
				return text.Length;
			}
		}
		return currentIndex;
	}

	public void PrintOverlay(int start, int end, UIGeometry caret, UIGeometry highlight, UnityEngine.Color caretColor, UnityEngine.Color highlightColor)
	{
		caret?.Clear();
		highlight?.Clear();
		if (!isValid)
		{
			return;
		}
		string text = processedText;
		UpdateNGUIText();
		int size = caret.verts.size;
		Vector2 item = new Vector2(0.5f, 0.5f);
		float num = finalAlpha;
		if (highlight != null && start != end)
		{
			int size2 = highlight.verts.size;
			NGUIText.PrintCaretAndSelection(text, start, end, caret.verts, highlight.verts);
			if (highlight.verts.size > size2)
			{
				ApplyOffset(highlight.verts, size2);
				Color32 item2 = new UnityEngine.Color(highlightColor.r, highlightColor.g, highlightColor.b, highlightColor.a * num);
				for (int i = size2; i < highlight.verts.size; i++)
				{
					highlight.uvs.Add(item);
					highlight.cols.Add(item2);
				}
			}
		}
		else
		{
			NGUIText.PrintCaretAndSelection(text, start, end, caret.verts, null);
		}
		ApplyOffset(caret.verts, size);
		Color32 item3 = new UnityEngine.Color(caretColor.r, caretColor.g, caretColor.b, caretColor.a * num);
		for (int j = size; j < caret.verts.size; j++)
		{
			caret.uvs.Add(item);
			caret.cols.Add(item3);
		}
		NGUIText.bitmapFont = null;
		NGUIText.dynamicFont = null;
	}

	public override void OnFill(BetterList<Vector3> verts, BetterList<Vector2> uvs, BetterList<Color32> cols)
	{
		if (!isValid)
		{
			return;
		}
		int num = verts.size;
		UnityEngine.Color color = base.color;
		color.a = finalAlpha;
		if (mFont != null && mFont.premultipliedAlphaShader)
		{
			color = NGUITools.ApplyPMA(color);
		}
		if (QualitySettings.activeColorSpace == ColorSpace.Linear)
		{
			color.r = Mathf.Pow(color.r, 2.2f);
			color.g = Mathf.Pow(color.g, 2.2f);
			color.b = Mathf.Pow(color.b, 2.2f);
		}
		string text = processedText;
		int size = verts.size;
		UpdateNGUIText();
		NGUIText.tint = color;
		NGUIText.Print(text, verts, uvs, cols);
		NGUIText.bitmapFont = null;
		NGUIText.dynamicFont = null;
		Vector2 vector = ApplyOffset(verts, size);
		if (mFont != null && mFont.packedFontShader)
		{
			return;
		}
		if (effectStyle != 0)
		{
			int size2 = verts.size;
			vector.x = mEffectDistance.x;
			vector.y = mEffectDistance.y;
			ApplyShadow(verts, uvs, cols, num, size2, vector.x, 0f - vector.y);
			if (effectStyle == Effect.Outline)
			{
				num = size2;
				size2 = verts.size;
				ApplyShadow(verts, uvs, cols, num, size2, 0f - vector.x, vector.y);
				num = size2;
				size2 = verts.size;
				ApplyShadow(verts, uvs, cols, num, size2, vector.x, vector.y);
				num = size2;
				size2 = verts.size;
				ApplyShadow(verts, uvs, cols, num, size2, 0f - vector.x, 0f - vector.y);
			}
		}
		if (onPostFill != null)
		{
			onPostFill(this, num, verts, uvs, cols);
		}
	}

	public Vector2 ApplyOffset(BetterList<Vector3> verts, int start)
	{
		Vector2 vector = base.pivotOffset;
		float f = Mathf.Lerp(0f, -mWidth, vector.x);
		float f2 = Mathf.Lerp(mHeight, 0f, vector.y) + Mathf.Lerp(mCalculatedSize.y - (float)mHeight, 0f, vector.y);
		f = Mathf.Round(f);
		f2 = Mathf.Round(f2);
		for (int i = start; i < verts.size; i++)
		{
			verts.buffer[i].x += f;
			verts.buffer[i].y += f2;
		}
		return new Vector2(f, f2);
	}

	public void ApplyShadow(BetterList<Vector3> verts, BetterList<Vector2> uvs, BetterList<Color32> cols, int start, int end, float x, float y)
	{
		UnityEngine.Color color = mEffectColor;
		color.a *= finalAlpha;
		Color32 color2 = ((!(bitmapFont != null) || !bitmapFont.premultipliedAlphaShader) ? color : NGUITools.ApplyPMA(color));
		for (int i = start; i < end; i++)
		{
			verts.Add(verts.buffer[i]);
			uvs.Add(uvs.buffer[i]);
			cols.Add(cols.buffer[i]);
			Vector3 vector = verts.buffer[i];
			vector.x += x;
			vector.y += y;
			verts.buffer[i] = vector;
			Color32 color3 = cols.buffer[i];
			if (color3.a == byte.MaxValue)
			{
				cols.buffer[i] = color2;
				continue;
			}
			UnityEngine.Color color4 = color;
			color4.a = (float)(int)color3.a / 255f * color.a;
			ref Color32 reference = ref cols.buffer[i];
			reference = ((!(bitmapFont != null) || !bitmapFont.premultipliedAlphaShader) ? color4 : NGUITools.ApplyPMA(color4));
		}
	}

	public int CalculateOffsetToFit(string text)
	{
		UpdateNGUIText();
		NGUIText.encoding = false;
		NGUIText.symbolStyle = NGUIText.SymbolStyle.None;
		int result = NGUIText.CalculateOffsetToFit(text);
		NGUIText.bitmapFont = null;
		NGUIText.dynamicFont = null;
		return result;
	}

	public void SetCurrentProgress()
	{
		if (UIProgressBar.current != null)
		{
			text = UIProgressBar.current.value.ToString("F");
		}
	}

	public void SetCurrentPercent()
	{
		if (UIProgressBar.current != null)
		{
			text = Mathf.RoundToInt(UIProgressBar.current.value * 100f) + "%";
		}
	}

	public void SetCurrentSelection()
	{
		if (UIPopupList.current != null)
		{
			text = ((!UIPopupList.current.isLocalized) ? UIPopupList.current.value : Localization.Get(UIPopupList.current.value));
		}
	}

	public bool Wrap(string text, out string final)
	{
		return Wrap(text, out final, 1000000);
	}

	public bool Wrap(string text, out string final, int height)
	{
		UpdateNGUIText();
		NGUIText.rectHeight = height;
		NGUIText.regionHeight = height;
		bool result = NGUIText.WrapText(text, out final);
		NGUIText.bitmapFont = null;
		NGUIText.dynamicFont = null;
		return result;
	}

	public void UpdateNGUIText()
	{
		UnityEngine.Font font = trueTypeFont;
		bool flag = font != null;
		NGUIText.fontSize = mPrintedSize;
		NGUIText.fontStyle = mFontStyle;
		NGUIText.rectWidth = mWidth;
		NGUIText.rectHeight = mHeight;
		NGUIText.regionWidth = Mathf.RoundToInt((float)mWidth * (mDrawRegion.z - mDrawRegion.x));
		NGUIText.regionHeight = Mathf.RoundToInt((float)mHeight * (mDrawRegion.w - mDrawRegion.y));
		NGUIText.gradient = mApplyGradient && (mFont == null || !mFont.packedFontShader);
		NGUIText.gradientTop = mGradientTop;
		NGUIText.gradientBottom = mGradientBottom;
		NGUIText.encoding = mEncoding;
		NGUIText.premultiply = mPremultiply;
		NGUIText.symbolStyle = mSymbols;
		NGUIText.maxLines = mMaxLineCount;
		NGUIText.spacingX = mSpacingX;
		NGUIText.spacingY = mSpacingY;
		NGUIText.fontScale = ((!flag) ? ((float)mFontSize / (float)mFont.defaultSize * mScale) : mScale);
		if (mFont != null)
		{
			NGUIText.bitmapFont = mFont;
			while (true)
			{
				UIFont replacement = NGUIText.bitmapFont.replacement;
				if (replacement == null)
				{
					break;
				}
				NGUIText.bitmapFont = replacement;
			}
			if (NGUIText.bitmapFont.isDynamic)
			{
				NGUIText.dynamicFont = NGUIText.bitmapFont.dynamicFont;
				NGUIText.bitmapFont = null;
			}
			else
			{
				NGUIText.dynamicFont = null;
			}
		}
		else
		{
			NGUIText.dynamicFont = font;
			NGUIText.bitmapFont = null;
		}
		if (flag && keepCrisp)
		{
			UIRoot uIRoot = base.root;
			if (uIRoot != null)
			{
				NGUIText.pixelDensity = ((!(uIRoot != null)) ? 1f : uIRoot.pixelSizeAdjustment);
			}
		}
		else
		{
			NGUIText.pixelDensity = 1f;
		}
		if (mDensity != NGUIText.pixelDensity)
		{
			ProcessText(legacyMode: false, full: false);
			NGUIText.rectWidth = mWidth;
			NGUIText.rectHeight = mHeight;
			NGUIText.regionWidth = Mathf.RoundToInt((float)mWidth * (mDrawRegion.z - mDrawRegion.x));
			NGUIText.regionHeight = Mathf.RoundToInt((float)mHeight * (mDrawRegion.w - mDrawRegion.y));
		}
		if (alignment == NGUIText.Alignment.Automatic)
		{
			switch (base.pivot)
			{
			case Pivot.TopLeft:
			case Pivot.Left:
			case Pivot.BottomLeft:
				NGUIText.alignment = NGUIText.Alignment.Left;
				break;
			case Pivot.TopRight:
			case Pivot.Right:
			case Pivot.BottomRight:
				NGUIText.alignment = NGUIText.Alignment.Right;
				break;
			default:
				NGUIText.alignment = NGUIText.Alignment.Center;
				break;
			}
		}
		else
		{
			NGUIText.alignment = alignment;
		}
		NGUIText.Update();
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(UIWidget))]
[AddComponentMenu("NGUI/UI/Localize")]
public class UILocalize : MonoBehaviour
{
	public string key;

	private bool mStarted;

	public string value
	{
		set
		{
			if (string.IsNullOrEmpty(value))
			{
				return;
			}
			UIWidget component = GetComponent<UIWidget>();
			UILabel uILabel = component as UILabel;
			UISprite uISprite = component as UISprite;
			if (uILabel != null)
			{
				UIInput uIInput = NGUITools.FindInParents<UIInput>(uILabel.gameObject);
				if (uIInput != null && uIInput.label == uILabel)
				{
					uIInput.defaultText = value;
				}
				else
				{
					uILabel.text = value;
				}
			}
			else if (uISprite != null)
			{
				UIButton uIButton = NGUITools.FindInParents<UIButton>(uISprite.gameObject);
				if (uIButton != null && uIButton.tweenTarget == uISprite.gameObject)
				{
					uIButton.normalSprite = value;
				}
				uISprite.spriteName = value;
				uISprite.MakePixelPerfect();
			}
		}
	}

	private void OnEnable()
	{
		if (mStarted)
		{
			OnLocalize();
		}
	}

	private void Start()
	{
		mStarted = true;
		OnLocalize();
	}

	private void OnLocalize()
	{
		if (string.IsNullOrEmpty(key))
		{
			UILabel component = GetComponent<UILabel>();
			if (component != null)
			{
				key = component.text;
			}
		}
		if (!string.IsNullOrEmpty(key))
		{
			value = Localization.Get(key);
		}
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("NGUI/UI/Orthographic Camera")]
public class UIOrthoCamera : MonoBehaviour
{
	private Camera mCam;

	private Transform mTrans;

	private void Start()
	{
		mCam = GetComponent<Camera>();
		mTrans = base.transform;
		mCam.orthographic = true;
	}

	private void Update()
	{
		float num = mCam.rect.yMin * (float)Screen.height;
		float num2 = mCam.rect.yMax * (float)Screen.height;
		float num3 = (num2 - num) * 0.5f * mTrans.lossyScale.y;
		if (!Mathf.Approximately(mCam.orthographicSize, num3))
		{
			mCam.orthographicSize = num3;
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/UI/NGUI Panel")]
public class UIPanel : UIRect
{
	public enum RenderQueue
	{
		Automatic,
		StartAt,
		Explicit
	}

	public delegate void OnGeometryUpdated();

	public delegate void OnClippingMoved(UIPanel panel);

	public static List<UIPanel> list = new List<UIPanel>();

	public OnGeometryUpdated onGeometryUpdated;

	public bool showInPanelTool = true;

	public bool generateNormals;

	public bool widgetsAreStatic;

	public bool cullWhileDragging = true;

	public bool alwaysOnScreen;

	public bool anchorOffset;

	public bool softBorderPadding = true;

	public RenderQueue renderQueue;

	public int startingRenderQueue = 3000;

	[NonSerialized]
	public List<UIWidget> widgets = new List<UIWidget>();

	[NonSerialized]
	public List<UIDrawCall> drawCalls = new List<UIDrawCall>();

	[NonSerialized]
	public Matrix4x4 worldToLocal = Matrix4x4.identity;

	[NonSerialized]
	public Vector4 drawCallClipRange = new Vector4(0f, 0f, 1f, 1f);

	public OnClippingMoved onClipMove;

	[HideInInspector]
	[SerializeField]
	private Texture2D mClipTexture;

	[HideInInspector]
	[SerializeField]
	private float mAlpha = 1f;

	[HideInInspector]
	[SerializeField]
	private UIDrawCall.Clipping mClipping;

	[HideInInspector]
	[SerializeField]
	private Vector4 mClipRange = new Vector4(0f, 0f, 300f, 200f);

	[HideInInspector]
	[SerializeField]
	private Vector2 mClipSoftness = new Vector2(4f, 4f);

	[HideInInspector]
	[SerializeField]
	private int mDepth;

	[HideInInspector]
	[SerializeField]
	private int mSortingOrder;

	private bool mRebuild;

	private bool mResized;

	[SerializeField]
	private Vector2 mClipOffset = Vector2.zero;

	private float mCullTime;

	private float mUpdateTime;

	private int mMatrixFrame = -1;

	private int mAlphaFrameID;

	private int mLayer = -1;

	private static float[] mTemp = new float[4];

	private Vector2 mMin = Vector2.zero;

	private Vector2 mMax = Vector2.zero;

	private bool mHalfPixelOffset;

	private bool mSortWidgets;

	private bool mUpdateScroll;

	private UIPanel mParentPanel;

	private static Vector3[] mCorners = new Vector3[4];

	private static int mUpdateFrame = -1;

	private UIDrawCall.OnRenderCallback mOnRender;

	private bool mForced;

	public static int nextUnusedDepth
	{
		get
		{
			int num = int.MinValue;
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				num = Mathf.Max(num, list[i].depth);
			}
			return (num != int.MinValue) ? (num + 1) : 0;
		}
	}

	public override bool canBeAnchored => mClipping != UIDrawCall.Clipping.None;

	public override float alpha
	{
		get
		{
			return mAlpha;
		}
		set
		{
			float num = Mathf.Clamp01(value);
			if (mAlpha != num)
			{
				mAlphaFrameID = -1;
				mResized = true;
				mAlpha = num;
				SetDirty();
			}
		}
	}

	public int depth
	{
		get
		{
			return mDepth;
		}
		set
		{
			if (mDepth != value)
			{
				mDepth = value;
				list.Sort(CompareFunc);
			}
		}
	}

	public int sortingOrder
	{
		get
		{
			return mSortingOrder;
		}
		set
		{
			if (mSortingOrder != value)
			{
				mSortingOrder = value;
				UpdateDrawCalls();
			}
		}
	}

	public float width => GetViewSize().x;

	public float height => GetViewSize().y;

	public bool halfPixelOffset => mHalfPixelOffset;

	public bool usedForUI => base.anchorCamera != null && mCam.orthographic;

	public Vector3 drawCallOffset
	{
		get
		{
			if (mHalfPixelOffset && base.anchorCamera != null && mCam.orthographic)
			{
				float num = 1f / GetWindowSize().y / mCam.orthographicSize;
				return new Vector3(0f - num, num);
			}
			return Vector3.zero;
		}
	}

	public UIDrawCall.Clipping clipping
	{
		get
		{
			return mClipping;
		}
		set
		{
			if (mClipping != value)
			{
				mResized = true;
				mClipping = value;
				mMatrixFrame = -1;
			}
		}
	}

	public UIPanel parentPanel => mParentPanel;

	public int clipCount
	{
		get
		{
			int num = 0;
			UIPanel uIPanel = this;
			while (uIPanel != null)
			{
				if (uIPanel.mClipping == UIDrawCall.Clipping.SoftClip || uIPanel.mClipping == UIDrawCall.Clipping.TextureMask)
				{
					num++;
				}
				uIPanel = uIPanel.mParentPanel;
			}
			return num;
		}
	}

	public bool hasClipping => mClipping == UIDrawCall.Clipping.SoftClip || mClipping == UIDrawCall.Clipping.TextureMask;

	public bool hasCumulativeClipping => clipCount != 0;

	[Obsolete("Use 'hasClipping' or 'hasCumulativeClipping' instead")]
	public bool clipsChildren => hasCumulativeClipping;

	public Vector2 clipOffset
	{
		get
		{
			return mClipOffset;
		}
		set
		{
			if (Mathf.Abs(mClipOffset.x - value.x) > 0.001f || Mathf.Abs(mClipOffset.y - value.y) > 0.001f)
			{
				mClipOffset = value;
				InvalidateClipping();
				if (onClipMove != null)
				{
					onClipMove(this);
				}
			}
		}
	}

	public Texture2D clipTexture
	{
		get
		{
			return mClipTexture;
		}
		set
		{
			if (mClipTexture != value)
			{
				mClipTexture = value;
			}
		}
	}

	[Obsolete("Use 'finalClipRegion' or 'baseClipRegion' instead")]
	public Vector4 clipRange
	{
		get
		{
			return baseClipRegion;
		}
		set
		{
			baseClipRegion = value;
		}
	}

	public Vector4 baseClipRegion
	{
		get
		{
			return mClipRange;
		}
		set
		{
			if (Mathf.Abs(mClipRange.x - value.x) > 0.001f || Mathf.Abs(mClipRange.y - value.y) > 0.001f || Mathf.Abs(mClipRange.z - value.z) > 0.001f || Mathf.Abs(mClipRange.w - value.w) > 0.001f)
			{
				mResized = true;
				mCullTime = ((mCullTime != 0f) ? (RealTime.time + 0.15f) : 0.001f);
				mClipRange = value;
				mMatrixFrame = -1;
				UIScrollView component = GetComponent<UIScrollView>();
				if (component != null)
				{
					component.UpdatePosition();
				}
				if (onClipMove != null)
				{
					onClipMove(this);
				}
			}
		}
	}

	public Vector4 finalClipRegion
	{
		get
		{
			Vector2 viewSize = GetViewSize();
			if (mClipping != 0)
			{
				return new Vector4(mClipRange.x + mClipOffset.x, mClipRange.y + mClipOffset.y, viewSize.x, viewSize.y);
			}
			return new Vector4(0f, 0f, viewSize.x, viewSize.y);
		}
	}

	public Vector2 clipSoftness
	{
		get
		{
			return mClipSoftness;
		}
		set
		{
			if (mClipSoftness != value)
			{
				mClipSoftness = value;
			}
		}
	}

	public override Vector3[] localCorners
	{
		get
		{
			if (mClipping == UIDrawCall.Clipping.None)
			{
				Vector3[] array = worldCorners;
				Transform transform = base.cachedTransform;
				for (int i = 0; i < 4; i++)
				{
					ref Vector3 reference = ref array[i];
					reference = transform.InverseTransformPoint(array[i]);
				}
				return array;
			}
			float num = mClipOffset.x + mClipRange.x - 0.5f * mClipRange.z;
			float num2 = mClipOffset.y + mClipRange.y - 0.5f * mClipRange.w;
			float x = num + mClipRange.z;
			float y = num2 + mClipRange.w;
			ref Vector3 reference2 = ref mCorners[0];
			reference2 = new Vector3(num, num2);
			ref Vector3 reference3 = ref mCorners[1];
			reference3 = new Vector3(num, y);
			ref Vector3 reference4 = ref mCorners[2];
			reference4 = new Vector3(x, y);
			ref Vector3 reference5 = ref mCorners[3];
			reference5 = new Vector3(x, num2);
			return mCorners;
		}
	}

	public override Vector3[] worldCorners
	{
		get
		{
			if (mClipping != 0)
			{
				float num = mClipOffset.x + mClipRange.x - 0.5f * mClipRange.z;
				float num2 = mClipOffset.y + mClipRange.y - 0.5f * mClipRange.w;
				float x = num + mClipRange.z;
				float y = num2 + mClipRange.w;
				Transform transform = base.cachedTransform;
				ref Vector3 reference = ref mCorners[0];
				reference = transform.TransformPoint(num, num2, 0f);
				ref Vector3 reference2 = ref mCorners[1];
				reference2 = transform.TransformPoint(num, y, 0f);
				ref Vector3 reference3 = ref mCorners[2];
				reference3 = transform.TransformPoint(x, y, 0f);
				ref Vector3 reference4 = ref mCorners[3];
				reference4 = transform.TransformPoint(x, num2, 0f);
			}
			else
			{
				if (base.anchorCamera != null)
				{
					return mCam.GetWorldCorners(base.cameraRayDistance);
				}
				Vector2 viewSize = GetViewSize();
				float num3 = -0.5f * viewSize.x;
				float num4 = -0.5f * viewSize.y;
				float x2 = num3 + viewSize.x;
				float y2 = num4 + viewSize.y;
				ref Vector3 reference5 = ref mCorners[0];
				reference5 = new Vector3(num3, num4);
				ref Vector3 reference6 = ref mCorners[1];
				reference6 = new Vector3(num3, y2);
				ref Vector3 reference7 = ref mCorners[2];
				reference7 = new Vector3(x2, y2);
				ref Vector3 reference8 = ref mCorners[3];
				reference8 = new Vector3(x2, num4);
				if ((anchorOffset && mCam == null) || mCam.transform.parent != base.cachedTransform)
				{
					Vector3 position = base.cachedTransform.position;
					for (int i = 0; i < 4; i++)
					{
						mCorners[i] += position;
					}
				}
			}
			return mCorners;
		}
	}

	public static int CompareFunc(UIPanel a, UIPanel b)
	{
		if (a != b && a != null && b != null)
		{
			if (a.mDepth < b.mDepth)
			{
				return -1;
			}
			if (a.mDepth > b.mDepth)
			{
				return 1;
			}
			return (a.GetInstanceID() >= b.GetInstanceID()) ? 1 : (-1);
		}
		return 0;
	}

	private void InvalidateClipping()
	{
		mResized = true;
		mMatrixFrame = -1;
		mCullTime = ((mCullTime != 0f) ? (RealTime.time + 0.15f) : 0.001f);
		int i = 0;
		for (int count = list.Count; i < count; i++)
		{
			UIPanel uIPanel = list[i];
			if (uIPanel != this && uIPanel.parentPanel == this)
			{
				uIPanel.InvalidateClipping();
			}
		}
	}

	public override Vector3[] GetSides(Transform relativeTo)
	{
		if (mClipping != 0)
		{
			float num = mClipOffset.x + mClipRange.x - 0.5f * mClipRange.z;
			float num2 = mClipOffset.y + mClipRange.y - 0.5f * mClipRange.w;
			float num3 = num + mClipRange.z;
			float num4 = num2 + mClipRange.w;
			float x = (num + num3) * 0.5f;
			float y = (num2 + num4) * 0.5f;
			Transform transform = base.cachedTransform;
			ref Vector3 reference = ref UIRect.mSides[0];
			reference = transform.TransformPoint(num, y, 0f);
			ref Vector3 reference2 = ref UIRect.mSides[1];
			reference2 = transform.TransformPoint(x, num4, 0f);
			ref Vector3 reference3 = ref UIRect.mSides[2];
			reference3 = transform.TransformPoint(num3, y, 0f);
			ref Vector3 reference4 = ref UIRect.mSides[3];
			reference4 = transform.TransformPoint(x, num2, 0f);
			if (relativeTo != null)
			{
				for (int i = 0; i < 4; i++)
				{
					ref Vector3 reference5 = ref UIRect.mSides[i];
					reference5 = relativeTo.InverseTransformPoint(UIRect.mSides[i]);
				}
			}
			return UIRect.mSides;
		}
		if (base.anchorCamera != null && anchorOffset)
		{
			Vector3[] sides = mCam.GetSides(base.cameraRayDistance);
			Vector3 position = base.cachedTransform.position;
			for (int j = 0; j < 4; j++)
			{
				sides[j] += position;
			}
			if (relativeTo != null)
			{
				for (int k = 0; k < 4; k++)
				{
					ref Vector3 reference6 = ref sides[k];
					reference6 = relativeTo.InverseTransformPoint(sides[k]);
				}
			}
			return sides;
		}
		return base.GetSides(relativeTo);
	}

	public override void Invalidate(bool includeChildren)
	{
		mAlphaFrameID = -1;
		base.Invalidate(includeChildren);
	}

	public override float CalculateFinalAlpha(int frameID)
	{
		if (mAlphaFrameID != frameID)
		{
			mAlphaFrameID = frameID;
			UIRect uIRect = base.parent;
			finalAlpha = ((!(base.parent != null)) ? mAlpha : (uIRect.CalculateFinalAlpha(frameID) * mAlpha));
		}
		return finalAlpha;
	}

	public override void SetRect(float x, float y, float width, float height)
	{
		int num = Mathf.FloorToInt(width + 0.5f);
		int num2 = Mathf.FloorToInt(height + 0.5f);
		num = num >> 1 << 1;
		num2 = num2 >> 1 << 1;
		Transform transform = base.cachedTransform;
		Vector3 localPosition = transform.localPosition;
		localPosition.x = Mathf.Floor(x + 0.5f);
		localPosition.y = Mathf.Floor(y + 0.5f);
		if (num < 2)
		{
			num = 2;
		}
		if (num2 < 2)
		{
			num2 = 2;
		}
		baseClipRegion = new Vector4(localPosition.x, localPosition.y, num, num2);
		if (base.isAnchored)
		{
			transform = transform.parent;
			if ((bool)leftAnchor.target)
			{
				leftAnchor.SetHorizontal(transform, x);
			}
			if ((bool)rightAnchor.target)
			{
				rightAnchor.SetHorizontal(transform, x + width);
			}
			if ((bool)bottomAnchor.target)
			{
				bottomAnchor.SetVertical(transform, y);
			}
			if ((bool)topAnchor.target)
			{
				topAnchor.SetVertical(transform, y + height);
			}
		}
	}

	public bool IsVisible(Vector3 a, Vector3 b, Vector3 c, Vector3 d)
	{
		UpdateTransformMatrix();
		a = worldToLocal.MultiplyPoint3x4(a);
		b = worldToLocal.MultiplyPoint3x4(b);
		c = worldToLocal.MultiplyPoint3x4(c);
		d = worldToLocal.MultiplyPoint3x4(d);
		mTemp[0] = a.x;
		mTemp[1] = b.x;
		mTemp[2] = c.x;
		mTemp[3] = d.x;
		float num = Mathf.Min(mTemp);
		float num2 = Mathf.Max(mTemp);
		mTemp[0] = a.y;
		mTemp[1] = b.y;
		mTemp[2] = c.y;
		mTemp[3] = d.y;
		float num3 = Mathf.Min(mTemp);
		float num4 = Mathf.Max(mTemp);
		if (num2 < mMin.x)
		{
			return false;
		}
		if (num4 < mMin.y)
		{
			return false;
		}
		if (num > mMax.x)
		{
			return false;
		}
		if (num3 > mMax.y)
		{
			return false;
		}
		return true;
	}

	public bool IsVisible(Vector3 worldPos)
	{
		if (mAlpha < 0.001f)
		{
			return false;
		}
		if (mClipping == UIDrawCall.Clipping.None || mClipping == UIDrawCall.Clipping.ConstrainButDontClip)
		{
			return true;
		}
		UpdateTransformMatrix();
		Vector3 vector = worldToLocal.MultiplyPoint3x4(worldPos);
		if (vector.x < mMin.x)
		{
			return false;
		}
		if (vector.y < mMin.y)
		{
			return false;
		}
		if (vector.x > mMax.x)
		{
			return false;
		}
		if (vector.y > mMax.y)
		{
			return false;
		}
		return true;
	}

	public bool IsVisible(UIWidget w)
	{
		UIPanel uIPanel = this;
		Vector3[] array = null;
		while (uIPanel != null)
		{
			if ((uIPanel.mClipping == UIDrawCall.Clipping.None || uIPanel.mClipping == UIDrawCall.Clipping.ConstrainButDontClip) && !w.hideIfOffScreen)
			{
				uIPanel = uIPanel.mParentPanel;
				continue;
			}
			if (array == null)
			{
				array = w.worldCorners;
			}
			if (!uIPanel.IsVisible(array[0], array[1], array[2], array[3]))
			{
				return false;
			}
			uIPanel = uIPanel.mParentPanel;
		}
		return true;
	}

	public bool Affects(UIWidget w)
	{
		if (w == null)
		{
			return false;
		}
		UIPanel panel = w.panel;
		if (panel == null)
		{
			return false;
		}
		UIPanel uIPanel = this;
		while (uIPanel != null)
		{
			if (uIPanel == panel)
			{
				return true;
			}
			if (!uIPanel.hasCumulativeClipping)
			{
				return false;
			}
			uIPanel = uIPanel.mParentPanel;
		}
		return false;
	}

	[ContextMenu("Force Refresh")]
	public void RebuildAllDrawCalls()
	{
		mRebuild = true;
	}

	public void SetDirty()
	{
		int i = 0;
		for (int count = drawCalls.Count; i < count; i++)
		{
			drawCalls[i].isDirty = true;
		}
		Invalidate(includeChildren: true);
	}

	private void Awake()
	{
		mGo = base.gameObject;
		mTrans = base.transform;
		mHalfPixelOffset = Application.platform == RuntimePlatform.WindowsPlayer || Application.platform == RuntimePlatform.XBOX360 || Application.platform == RuntimePlatform.WindowsWebPlayer || Application.platform == RuntimePlatform.WindowsEditor;
		if (mHalfPixelOffset)
		{
			mHalfPixelOffset = SystemInfo.graphicsShaderLevel < 40 && SystemInfo.graphicsDeviceVersion.Contains("Direct3D");
		}
	}

	private void FindParent()
	{
		Transform transform = base.cachedTransform.parent;
		mParentPanel = ((!(transform != null)) ? null : NGUITools.FindInParents<UIPanel>(transform.gameObject));
	}

	public override void ParentHasChanged()
	{
		base.ParentHasChanged();
		FindParent();
	}

	protected override void OnStart()
	{
		mLayer = mGo.layer;
	}

	protected override void OnEnable()
	{
		mRebuild = true;
		mAlphaFrameID = -1;
		mMatrixFrame = -1;
		OnStart();
		base.OnEnable();
		mMatrixFrame = -1;
	}

	protected override void OnInit()
	{
		base.OnInit();
		FindParent();
		if (GetComponent<Rigidbody>() == null && mParentPanel == null)
		{
			UICamera uICamera = ((!(base.anchorCamera != null)) ? null : mCam.GetComponent<UICamera>());
			if (uICamera != null && (uICamera.eventType == UICamera.EventType.UI_3D || uICamera.eventType == UICamera.EventType.World_3D))
			{
				Rigidbody rigidbody = base.gameObject.AddComponent<Rigidbody>();
				rigidbody.isKinematic = true;
				rigidbody.useGravity = false;
			}
		}
		mRebuild = true;
		mAlphaFrameID = -1;
		mMatrixFrame = -1;
		list.Add(this);
		list.Sort(CompareFunc);
	}

	protected override void OnDisable()
	{
		int i = 0;
		for (int count = drawCalls.Count; i < count; i++)
		{
			UIDrawCall uIDrawCall = drawCalls[i];
			if (uIDrawCall != null)
			{
				UIDrawCall.Destroy(uIDrawCall);
			}
		}
		drawCalls.Clear();
		list.Remove(this);
		mAlphaFrameID = -1;
		mMatrixFrame = -1;
		if (list.Count == 0)
		{
			UIDrawCall.ReleaseAll();
			mUpdateFrame = -1;
		}
		base.OnDisable();
	}

	private void UpdateTransformMatrix()
	{
		int frameCount = Time.frameCount;
		if (mMatrixFrame != frameCount)
		{
			mMatrixFrame = frameCount;
			worldToLocal = base.cachedTransform.worldToLocalMatrix;
			Vector2 vector = GetViewSize() * 0.5f;
			float num = mClipOffset.x + mClipRange.x;
			float num2 = mClipOffset.y + mClipRange.y;
			mMin.x = num - vector.x;
			mMin.y = num2 - vector.y;
			mMax.x = num + vector.x;
			mMax.y = num2 + vector.y;
		}
	}

	protected override void OnAnchor()
	{
		if (mClipping == UIDrawCall.Clipping.None)
		{
			return;
		}
		Transform transform = base.cachedTransform;
		Transform transform2 = transform.parent;
		Vector2 viewSize = GetViewSize();
		Vector2 vector = transform.localPosition;
		float num;
		float num2;
		float num3;
		float num4;
		if (leftAnchor.target == bottomAnchor.target && leftAnchor.target == rightAnchor.target && leftAnchor.target == topAnchor.target)
		{
			Vector3[] sides = leftAnchor.GetSides(transform2);
			if (sides != null)
			{
				num = NGUIMath.Lerp(sides[0].x, sides[2].x, leftAnchor.relative) + (float)leftAnchor.absolute;
				num2 = NGUIMath.Lerp(sides[0].x, sides[2].x, rightAnchor.relative) + (float)rightAnchor.absolute;
				num3 = NGUIMath.Lerp(sides[3].y, sides[1].y, bottomAnchor.relative) + (float)bottomAnchor.absolute;
				num4 = NGUIMath.Lerp(sides[3].y, sides[1].y, topAnchor.relative) + (float)topAnchor.absolute;
			}
			else
			{
				Vector2 vector2 = GetLocalPos(leftAnchor, transform2);
				num = vector2.x + (float)leftAnchor.absolute;
				num3 = vector2.y + (float)bottomAnchor.absolute;
				num2 = vector2.x + (float)rightAnchor.absolute;
				num4 = vector2.y + (float)topAnchor.absolute;
			}
		}
		else
		{
			if ((bool)leftAnchor.target)
			{
				Vector3[] sides2 = leftAnchor.GetSides(transform2);
				num = ((sides2 == null) ? (GetLocalPos(leftAnchor, transform2).x + (float)leftAnchor.absolute) : (NGUIMath.Lerp(sides2[0].x, sides2[2].x, leftAnchor.relative) + (float)leftAnchor.absolute));
			}
			else
			{
				num = mClipRange.x - 0.5f * viewSize.x;
			}
			if ((bool)rightAnchor.target)
			{
				Vector3[] sides3 = rightAnchor.GetSides(transform2);
				num2 = ((sides3 == null) ? (GetLocalPos(rightAnchor, transform2).x + (float)rightAnchor.absolute) : (NGUIMath.Lerp(sides3[0].x, sides3[2].x, rightAnchor.relative) + (float)rightAnchor.absolute));
			}
			else
			{
				num2 = mClipRange.x + 0.5f * viewSize.x;
			}
			if ((bool)bottomAnchor.target)
			{
				Vector3[] sides4 = bottomAnchor.GetSides(transform2);
				num3 = ((sides4 == null) ? (GetLocalPos(bottomAnchor, transform2).y + (float)bottomAnchor.absolute) : (NGUIMath.Lerp(sides4[3].y, sides4[1].y, bottomAnchor.relative) + (float)bottomAnchor.absolute));
			}
			else
			{
				num3 = mClipRange.y - 0.5f * viewSize.y;
			}
			if ((bool)topAnchor.target)
			{
				Vector3[] sides5 = topAnchor.GetSides(transform2);
				num4 = ((sides5 == null) ? (GetLocalPos(topAnchor, transform2).y + (float)topAnchor.absolute) : (NGUIMath.Lerp(sides5[3].y, sides5[1].y, topAnchor.relative) + (float)topAnchor.absolute));
			}
			else
			{
				num4 = mClipRange.y + 0.5f * viewSize.y;
			}
		}
		num -= vector.x + mClipOffset.x;
		num2 -= vector.x + mClipOffset.x;
		num3 -= vector.y + mClipOffset.y;
		num4 -= vector.y + mClipOffset.y;
		float x = Mathf.Lerp(num, num2, 0.5f);
		float y = Mathf.Lerp(num3, num4, 0.5f);
		float num5 = num2 - num;
		float num6 = num4 - num3;
		float num7 = Mathf.Max(2f, mClipSoftness.x);
		float num8 = Mathf.Max(2f, mClipSoftness.y);
		if (num5 < num7)
		{
			num5 = num7;
		}
		if (num6 < num8)
		{
			num6 = num8;
		}
		baseClipRegion = new Vector4(x, y, num5, num6);
	}

	private void LateUpdate()
	{
		if (mUpdateFrame == Time.frameCount)
		{
			return;
		}
		mUpdateFrame = Time.frameCount;
		int i = 0;
		for (int count = list.Count; i < count; i++)
		{
			list[i].UpdateSelf();
		}
		int num = 3000;
		int j = 0;
		for (int count2 = list.Count; j < count2; j++)
		{
			UIPanel uIPanel = list[j];
			if (uIPanel.renderQueue == RenderQueue.Automatic)
			{
				uIPanel.startingRenderQueue = num;
				uIPanel.UpdateDrawCalls();
				num += uIPanel.drawCalls.Count;
			}
			else if (uIPanel.renderQueue == RenderQueue.StartAt)
			{
				uIPanel.UpdateDrawCalls();
				if (uIPanel.drawCalls.Count != 0)
				{
					num = Mathf.Max(num, uIPanel.startingRenderQueue + uIPanel.drawCalls.Count);
				}
			}
			else
			{
				uIPanel.UpdateDrawCalls();
				if (uIPanel.drawCalls.Count != 0)
				{
					num = Mathf.Max(num, uIPanel.startingRenderQueue + 1);
				}
			}
		}
	}

	private void UpdateSelf()
	{
		mUpdateTime = RealTime.time;
		UpdateTransformMatrix();
		UpdateLayers();
		UpdateWidgets();
		if (mRebuild)
		{
			mRebuild = false;
			FillAllDrawCalls();
		}
		else
		{
			int num = 0;
			while (num < drawCalls.Count)
			{
				UIDrawCall uIDrawCall = drawCalls[num];
				if (uIDrawCall.isDirty && !FillDrawCall(uIDrawCall))
				{
					UIDrawCall.Destroy(uIDrawCall);
					drawCalls.RemoveAt(num);
				}
				else
				{
					num++;
				}
			}
		}
		if (mUpdateScroll)
		{
			mUpdateScroll = false;
			UIScrollView component = GetComponent<UIScrollView>();
			if (component != null)
			{
				component.UpdateScrollbars();
			}
		}
	}

	public void SortWidgets()
	{
		mSortWidgets = false;
		widgets.Sort(UIWidget.PanelCompareFunc);
	}

	private void FillAllDrawCalls()
	{
		for (int i = 0; i < drawCalls.Count; i++)
		{
			UIDrawCall.Destroy(drawCalls[i]);
		}
		drawCalls.Clear();
		Material material = null;
		Texture texture = null;
		Shader shader = null;
		UIDrawCall uIDrawCall = null;
		int num = 0;
		if (mSortWidgets)
		{
			SortWidgets();
		}
		for (int j = 0; j < widgets.Count; j++)
		{
			UIWidget uIWidget = widgets[j];
			if (uIWidget.isVisible && uIWidget.hasVertices)
			{
				Material material2 = uIWidget.material;
				Texture mainTexture = uIWidget.mainTexture;
				Shader shader2 = uIWidget.shader;
				if (material != material2 || texture != mainTexture || shader != shader2)
				{
					if (uIDrawCall != null && uIDrawCall.verts.size != 0)
					{
						drawCalls.Add(uIDrawCall);
						uIDrawCall.UpdateGeometry(num);
						uIDrawCall.onRender = mOnRender;
						mOnRender = null;
						num = 0;
						uIDrawCall = null;
					}
					material = material2;
					texture = mainTexture;
					shader = shader2;
				}
				if (!(material != null) && !(shader != null) && !(texture != null))
				{
					continue;
				}
				if (uIDrawCall == null)
				{
					uIDrawCall = UIDrawCall.Create(this, material, texture, shader);
					uIDrawCall.depthStart = uIWidget.depth;
					uIDrawCall.depthEnd = uIDrawCall.depthStart;
					uIDrawCall.panel = this;
				}
				else
				{
					int num2 = uIWidget.depth;
					if (num2 < uIDrawCall.depthStart)
					{
						uIDrawCall.depthStart = num2;
					}
					if (num2 > uIDrawCall.depthEnd)
					{
						uIDrawCall.depthEnd = num2;
					}
				}
				uIWidget.drawCall = uIDrawCall;
				num++;
				if (generateNormals)
				{
					uIWidget.WriteToBuffers(uIDrawCall.verts, uIDrawCall.uvs, uIDrawCall.cols, uIDrawCall.norms, uIDrawCall.tans);
				}
				else
				{
					uIWidget.WriteToBuffers(uIDrawCall.verts, uIDrawCall.uvs, uIDrawCall.cols, null, null);
				}
				if (uIWidget.mOnRender != null)
				{
					if (mOnRender == null)
					{
						mOnRender = uIWidget.mOnRender;
					}
					else
					{
						mOnRender = (UIDrawCall.OnRenderCallback)Delegate.Combine(mOnRender, uIWidget.mOnRender);
					}
				}
			}
			else
			{
				uIWidget.drawCall = null;
			}
		}
		if (uIDrawCall != null && uIDrawCall.verts.size != 0)
		{
			drawCalls.Add(uIDrawCall);
			uIDrawCall.UpdateGeometry(num);
			uIDrawCall.onRender = mOnRender;
			mOnRender = null;
		}
	}

	private bool FillDrawCall(UIDrawCall dc)
	{
		if (dc != null)
		{
			dc.isDirty = false;
			int num = 0;
			int num2 = 0;
			while (num2 < widgets.Count)
			{
				UIWidget uIWidget = widgets[num2];
				if (uIWidget == null)
				{
					widgets.RemoveAt(num2);
					continue;
				}
				if (uIWidget.drawCall == dc)
				{
					if (uIWidget.isVisible && uIWidget.hasVertices)
					{
						num++;
						if (generateNormals)
						{
							uIWidget.WriteToBuffers(dc.verts, dc.uvs, dc.cols, dc.norms, dc.tans);
						}
						else
						{
							uIWidget.WriteToBuffers(dc.verts, dc.uvs, dc.cols, null, null);
						}
						if (uIWidget.mOnRender != null)
						{
							if (mOnRender == null)
							{
								mOnRender = uIWidget.mOnRender;
							}
							else
							{
								mOnRender = (UIDrawCall.OnRenderCallback)Delegate.Combine(mOnRender, uIWidget.mOnRender);
							}
						}
					}
					else
					{
						uIWidget.drawCall = null;
					}
				}
				num2++;
			}
			if (dc.verts.size != 0)
			{
				dc.UpdateGeometry(num);
				dc.onRender = mOnRender;
				mOnRender = null;
				return true;
			}
		}
		return false;
	}

	private void UpdateDrawCalls()
	{
		Transform transform = base.cachedTransform;
		bool flag = usedForUI;
		if (clipping != 0)
		{
			drawCallClipRange = finalClipRegion;
			drawCallClipRange.z *= 0.5f;
			drawCallClipRange.w *= 0.5f;
		}
		else
		{
			drawCallClipRange = Vector4.zero;
		}
		if (drawCallClipRange.z == 0f)
		{
			drawCallClipRange.z = (float)Screen.width * 0.5f;
		}
		if (drawCallClipRange.w == 0f)
		{
			drawCallClipRange.w = (float)Screen.height * 0.5f;
		}
		if (halfPixelOffset)
		{
			drawCallClipRange.x -= 0.5f;
			drawCallClipRange.y += 0.5f;
		}
		Vector3 position;
		if (flag)
		{
			Transform transform2 = base.cachedTransform.parent;
			position = base.cachedTransform.localPosition;
			if (transform2 != null)
			{
				position = transform2.TransformPoint(position);
			}
			position += drawCallOffset;
		}
		else
		{
			position = transform.position;
		}
		Quaternion rotation = transform.rotation;
		Vector3 lossyScale = transform.lossyScale;
		for (int i = 0; i < drawCalls.Count; i++)
		{
			UIDrawCall uIDrawCall = drawCalls[i];
			Transform transform3 = uIDrawCall.cachedTransform;
			transform3.position = position;
			transform3.rotation = rotation;
			transform3.localScale = lossyScale;
			uIDrawCall.renderQueue = ((renderQueue != RenderQueue.Explicit) ? (startingRenderQueue + i) : startingRenderQueue);
			uIDrawCall.alwaysOnScreen = alwaysOnScreen && (mClipping == UIDrawCall.Clipping.None || mClipping == UIDrawCall.Clipping.ConstrainButDontClip);
			uIDrawCall.sortingOrder = mSortingOrder;
			uIDrawCall.clipTexture = mClipTexture;
		}
	}

	private void UpdateLayers()
	{
		if (mLayer != base.cachedGameObject.layer)
		{
			mLayer = mGo.layer;
			NGUITools.SetChildLayer(base.cachedTransform, mLayer);
			ResetAnchors();
			for (int i = 0; i < drawCalls.Count; i++)
			{
				drawCalls[i].gameObject.layer = mLayer;
			}
		}
	}

	private void UpdateWidgets()
	{
		bool flag = !cullWhileDragging && mCullTime > mUpdateTime;
		bool flag2 = false;
		if (mForced != flag)
		{
			mForced = flag;
			mResized = true;
		}
		bool flag3 = hasCumulativeClipping;
		int i = 0;
		for (int count = widgets.Count; i < count; i++)
		{
			UIWidget uIWidget = widgets[i];
			if (!(uIWidget.panel == this) || !uIWidget.enabled)
			{
				continue;
			}
			int frameCount = Time.frameCount;
			if (uIWidget.UpdateTransform(frameCount) || mResized)
			{
				bool visibleByAlpha = flag || uIWidget.CalculateCumulativeAlpha(frameCount) > 0.001f;
				uIWidget.UpdateVisibility(visibleByAlpha, flag || (!flag3 && !uIWidget.hideIfOffScreen) || IsVisible(uIWidget));
			}
			if (!uIWidget.UpdateGeometry(frameCount))
			{
				continue;
			}
			flag2 = true;
			if (!mRebuild)
			{
				if (uIWidget.drawCall != null)
				{
					uIWidget.drawCall.isDirty = true;
				}
				else
				{
					FindDrawCall(uIWidget);
				}
			}
		}
		if (flag2 && onGeometryUpdated != null)
		{
			onGeometryUpdated();
		}
		mResized = false;
	}

	public UIDrawCall FindDrawCall(UIWidget w)
	{
		Material material = w.material;
		Texture mainTexture = w.mainTexture;
		int num = w.depth;
		for (int i = 0; i < drawCalls.Count; i++)
		{
			UIDrawCall uIDrawCall = drawCalls[i];
			int num2 = ((i != 0) ? (drawCalls[i - 1].depthEnd + 1) : int.MinValue);
			int num3 = ((i + 1 != drawCalls.Count) ? (drawCalls[i + 1].depthStart - 1) : int.MaxValue);
			if (num2 > num || num3 < num)
			{
				continue;
			}
			if (uIDrawCall.baseMaterial == material && uIDrawCall.mainTexture == mainTexture)
			{
				if (w.isVisible)
				{
					w.drawCall = uIDrawCall;
					if (w.hasVertices)
					{
						uIDrawCall.isDirty = true;
					}
					return uIDrawCall;
				}
			}
			else
			{
				mRebuild = true;
			}
			return null;
		}
		mRebuild = true;
		return null;
	}

	public void AddWidget(UIWidget w)
	{
		mUpdateScroll = true;
		if (widgets.Count == 0)
		{
			widgets.Add(w);
		}
		else if (mSortWidgets)
		{
			widgets.Add(w);
			SortWidgets();
		}
		else if (UIWidget.PanelCompareFunc(w, widgets[0]) == -1)
		{
			widgets.Insert(0, w);
		}
		else
		{
			int num = widgets.Count;
			while (num > 0)
			{
				if (UIWidget.PanelCompareFunc(w, widgets[--num]) == -1)
				{
					continue;
				}
				widgets.Insert(num + 1, w);
				break;
			}
		}
		FindDrawCall(w);
	}

	public void RemoveWidget(UIWidget w)
	{
		if (widgets.Remove(w) && w.drawCall != null)
		{
			int num = w.depth;
			if (num == w.drawCall.depthStart || num == w.drawCall.depthEnd)
			{
				mRebuild = true;
			}
			w.drawCall.isDirty = true;
			w.drawCall = null;
		}
	}

	public void Refresh()
	{
		mRebuild = true;
		mUpdateFrame = -1;
		if (list.Count > 0)
		{
			list[0].LateUpdate();
		}
	}

	public virtual Vector3 CalculateConstrainOffset(Vector2 min, Vector2 max)
	{
		Vector4 vector = finalClipRegion;
		float num = vector.z * 0.5f;
		float num2 = vector.w * 0.5f;
		Vector2 minRect = new Vector2(min.x, min.y);
		Vector2 maxRect = new Vector2(max.x, max.y);
		Vector2 minArea = new Vector2(vector.x - num, vector.y - num2);
		Vector2 maxArea = new Vector2(vector.x + num, vector.y + num2);
		if (softBorderPadding && clipping == UIDrawCall.Clipping.SoftClip)
		{
			minArea.x += mClipSoftness.x;
			minArea.y += mClipSoftness.y;
			maxArea.x -= mClipSoftness.x;
			maxArea.y -= mClipSoftness.y;
		}
		return NGUIMath.ConstrainRect(minRect, maxRect, minArea, maxArea);
	}

	public bool ConstrainTargetToBounds(Transform target, ref Bounds targetBounds, bool immediate)
	{
		Vector3 min = targetBounds.min;
		Vector3 max = targetBounds.max;
		float num = 1f;
		if (mClipping == UIDrawCall.Clipping.None)
		{
			UIRoot uIRoot = base.root;
			if (uIRoot != null)
			{
				num = uIRoot.pixelSizeAdjustment;
			}
		}
		if (num != 1f)
		{
			min /= num;
			max /= num;
		}
		Vector3 vector = CalculateConstrainOffset(min, max) * num;
		if (vector.sqrMagnitude > 0f)
		{
			if (immediate)
			{
				target.localPosition += vector;
				targetBounds.center += vector;
				SpringPosition component = target.GetComponent<SpringPosition>();
				if (component != null)
				{
					component.enabled = false;
				}
			}
			else
			{
				SpringPosition springPosition = SpringPosition.Begin(target.gameObject, target.localPosition + vector, 13f);
				springPosition.ignoreTimeScale = true;
				springPosition.worldSpace = false;
			}
			return true;
		}
		return false;
	}

	public bool ConstrainTargetToBounds(Transform target, bool immediate)
	{
		Bounds targetBounds = NGUIMath.CalculateRelativeWidgetBounds(base.cachedTransform, target);
		return ConstrainTargetToBounds(target, ref targetBounds, immediate);
	}

	public static UIPanel Find(Transform trans)
	{
		return Find(trans, createIfMissing: false, -1);
	}

	public static UIPanel Find(Transform trans, bool createIfMissing)
	{
		return Find(trans, createIfMissing, -1);
	}

	public static UIPanel Find(Transform trans, bool createIfMissing, int layer)
	{
		UIPanel uIPanel = NGUITools.FindInParents<UIPanel>(trans);
		if (uIPanel != null)
		{
			return uIPanel;
		}
		return (!createIfMissing) ? null : NGUITools.CreateUI(trans, advanced3D: false, layer);
	}

	private Vector2 GetWindowSize()
	{
		UIRoot uIRoot = base.root;
		Vector2 screenSize = NGUITools.screenSize;
		if (uIRoot != null)
		{
			screenSize *= uIRoot.GetPixelSizeAdjustment(Mathf.RoundToInt(screenSize.y));
		}
		return screenSize;
	}

	public Vector2 GetViewSize()
	{
		if (mClipping != 0)
		{
			return new Vector2(mClipRange.z, mClipRange.w);
		}
		return NGUITools.screenSize;
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/UI/Root")]
public class UIRoot : MonoBehaviour
{
	public enum Scaling
	{
		Flexible,
		Constrained,
		ConstrainedOnMobiles
	}

	public enum Constraint
	{
		Fit,
		Fill,
		FitWidth,
		FitHeight
	}

	public static List<UIRoot> list = new List<UIRoot>();

	public Scaling scalingStyle;

	public int manualWidth = 1280;

	public int manualHeight = 720;

	public int minimumHeight = 320;

	public int maximumHeight = 1536;

	public bool fitWidth;

	public bool fitHeight = true;

	public bool adjustByDPI;

	public bool shrinkPortraitUI;

	private Transform mTrans;

	public Constraint constraint
	{
		get
		{
			if (fitWidth)
			{
				if (fitHeight)
				{
					return Constraint.Fit;
				}
				return Constraint.FitWidth;
			}
			if (fitHeight)
			{
				return Constraint.FitHeight;
			}
			return Constraint.Fill;
		}
	}

	public Scaling activeScaling
	{
		get
		{
			Scaling scaling = scalingStyle;
			if (scaling == Scaling.ConstrainedOnMobiles)
			{
				return Scaling.Constrained;
			}
			return scaling;
		}
	}

	public int activeHeight
	{
		get
		{
			if (activeScaling == Scaling.Flexible)
			{
				Vector2 screenSize = NGUITools.screenSize;
				float num = screenSize.x / screenSize.y;
				if (screenSize.y < (float)minimumHeight)
				{
					screenSize.y = minimumHeight;
					screenSize.x = screenSize.y * num;
				}
				else if (screenSize.y > (float)maximumHeight)
				{
					screenSize.y = maximumHeight;
					screenSize.x = screenSize.y * num;
				}
				int num2 = Mathf.RoundToInt((!shrinkPortraitUI || !(screenSize.y > screenSize.x)) ? screenSize.y : (screenSize.y / num));
				return (!adjustByDPI) ? num2 : NGUIMath.AdjustByDPI(num2);
			}
			Constraint constraint = this.constraint;
			if (constraint == Constraint.FitHeight)
			{
				return manualHeight;
			}
			Vector2 screenSize2 = NGUITools.screenSize;
			float num3 = screenSize2.x / screenSize2.y;
			float num4 = (float)manualWidth / (float)manualHeight;
			return constraint switch
			{
				Constraint.FitWidth => Mathf.RoundToInt((float)manualWidth / num3), 
				Constraint.Fit => (!(num4 > num3)) ? manualHeight : Mathf.RoundToInt((float)manualWidth / num3), 
				Constraint.Fill => (!(num4 < num3)) ? manualHeight : Mathf.RoundToInt((float)manualWidth / num3), 
				_ => manualHeight, 
			};
		}
	}

	public float pixelSizeAdjustment
	{
		get
		{
			int num = Mathf.RoundToInt(NGUITools.screenSize.y);
			return (num != -1) ? GetPixelSizeAdjustment(num) : 1f;
		}
	}

	public static float GetPixelSizeAdjustment(GameObject go)
	{
		UIRoot uIRoot = NGUITools.FindInParents<UIRoot>(go);
		return (!(uIRoot != null)) ? 1f : uIRoot.pixelSizeAdjustment;
	}

	public float GetPixelSizeAdjustment(int height)
	{
		height = Mathf.Max(2, height);
		if (activeScaling == Scaling.Constrained)
		{
			return (float)activeHeight / (float)height;
		}
		if (height < minimumHeight)
		{
			return (float)minimumHeight / (float)height;
		}
		if (height > maximumHeight)
		{
			return (float)maximumHeight / (float)height;
		}
		return 1f;
	}

	protected virtual void Awake()
	{
		mTrans = base.transform;
	}

	protected virtual void OnEnable()
	{
		list.Add(this);
	}

	protected virtual void OnDisable()
	{
		list.Remove(this);
	}

	protected virtual void Start()
	{
		Update();
	}

	private void Update()
	{
		if (!(mTrans != null))
		{
			return;
		}
		float num = activeHeight;
		if (num > 0f)
		{
			float num2 = 2f / num;
			Vector3 localScale = mTrans.localScale;
			if (!(Mathf.Abs(localScale.x - num2) <= float.Epsilon) || !(Mathf.Abs(localScale.y - num2) <= float.Epsilon) || !(Mathf.Abs(localScale.z - num2) <= float.Epsilon))
			{
				mTrans.localScale = new Vector3(num2, num2, num2);
			}
		}
	}

	public static void Broadcast(string funcName)
	{
		int i = 0;
		for (int count = list.Count; i < count; i++)
		{
			UIRoot uIRoot = list[i];
			if (uIRoot != null)
			{
				uIRoot.BroadcastMessage(funcName, SendMessageOptions.DontRequireReceiver);
			}
		}
	}

	public static void Broadcast(string funcName, object param)
	{
		if (param == null)
		{
			UnityEngine.Debug.LogError("SendMessage is bugged when you try to pass 'null' in the parameter field. It behaves as if no parameter was specified.");
			return;
		}
		int i = 0;
		for (int count = list.Count; i < count; i++)
		{
			UIRoot uIRoot = list[i];
			if (uIRoot != null)
			{
				uIRoot.BroadcastMessage(funcName, param, SendMessageOptions.DontRequireReceiver);
			}
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/UI/NGUI Sprite")]
public class UISprite : UIBasicSprite
{
	[HideInInspector]
	[SerializeField]
	private UIAtlas mAtlas;

	[HideInInspector]
	[SerializeField]
	private string mSpriteName;

	[HideInInspector]
	[SerializeField]
	private bool mFillCenter = true;

	[NonSerialized]
	protected UISpriteData mSprite;

	[NonSerialized]
	private bool mSpriteSet;

	public override Material material => (!(mAtlas != null)) ? null : mAtlas.spriteMaterial;

	public UIAtlas atlas
	{
		get
		{
			return mAtlas;
		}
		set
		{
			if (mAtlas != value)
			{
				RemoveFromPanel();
				mAtlas = value;
				mSpriteSet = false;
				mSprite = null;
				if (string.IsNullOrEmpty(mSpriteName) && mAtlas != null && mAtlas.spriteList.Count > 0)
				{
					SetAtlasSprite(mAtlas.spriteList[0]);
					mSpriteName = mSprite.name;
				}
				if (!string.IsNullOrEmpty(mSpriteName))
				{
					string text = mSpriteName;
					mSpriteName = string.Empty;
					spriteName = text;
					MarkAsChanged();
				}
			}
		}
	}

	public string spriteName
	{
		get
		{
			return mSpriteName;
		}
		set
		{
			if (string.IsNullOrEmpty(value))
			{
				if (!string.IsNullOrEmpty(mSpriteName))
				{
					mSpriteName = string.Empty;
					mSprite = null;
					mChanged = true;
					mSpriteSet = false;
				}
			}
			else if (mSpriteName != value)
			{
				mSpriteName = value;
				mSprite = null;
				mChanged = true;
				mSpriteSet = false;
			}
		}
	}

	public bool isValid => GetAtlasSprite() != null;

	[Obsolete("Use 'centerType' instead")]
	public bool fillCenter
	{
		get
		{
			return centerType != AdvancedType.Invisible;
		}
		set
		{
			if (value != (centerType != AdvancedType.Invisible))
			{
				centerType = (value ? AdvancedType.Sliced : AdvancedType.Invisible);
				MarkAsChanged();
			}
		}
	}

	public override Vector4 border
	{
		get
		{
			UISpriteData atlasSprite = GetAtlasSprite();
			if (atlasSprite == null)
			{
				return base.border;
			}
			return new Vector4(atlasSprite.borderLeft, atlasSprite.borderBottom, atlasSprite.borderRight, atlasSprite.borderTop);
		}
	}

	public override float pixelSize => (!(mAtlas != null)) ? 1f : mAtlas.pixelSize;

	public override int minWidth
	{
		get
		{
			if (type == Type.Sliced || type == Type.Advanced)
			{
				Vector4 vector = border * pixelSize;
				int num = Mathf.RoundToInt(vector.x + vector.z);
				UISpriteData atlasSprite = GetAtlasSprite();
				if (atlasSprite != null)
				{
					num += atlasSprite.paddingLeft + atlasSprite.paddingRight;
				}
				return Mathf.Max(base.minWidth, ((num & 1) != 1) ? num : (num + 1));
			}
			return base.minWidth;
		}
	}

	public override int minHeight
	{
		get
		{
			if (type == Type.Sliced || type == Type.Advanced)
			{
				Vector4 vector = border * pixelSize;
				int num = Mathf.RoundToInt(vector.y + vector.w);
				UISpriteData atlasSprite = GetAtlasSprite();
				if (atlasSprite != null)
				{
					num += atlasSprite.paddingTop + atlasSprite.paddingBottom;
				}
				return Mathf.Max(base.minHeight, ((num & 1) != 1) ? num : (num + 1));
			}
			return base.minHeight;
		}
	}

	public override Vector4 drawingDimensions
	{
		get
		{
			Vector2 vector = base.pivotOffset;
			float num = (0f - vector.x) * (float)mWidth;
			float num2 = (0f - vector.y) * (float)mHeight;
			float num3 = num + (float)mWidth;
			float num4 = num2 + (float)mHeight;
			if (GetAtlasSprite() != null && mType != Type.Tiled)
			{
				int paddingLeft = mSprite.paddingLeft;
				int paddingBottom = mSprite.paddingBottom;
				int num5 = mSprite.paddingRight;
				int num6 = mSprite.paddingTop;
				int num7 = mSprite.width + paddingLeft + num5;
				int num8 = mSprite.height + paddingBottom + num6;
				float num9 = 1f;
				float num10 = 1f;
				if (num7 > 0 && num8 > 0 && (mType == Type.Simple || mType == Type.Filled))
				{
					if (((uint)num7 & (true ? 1u : 0u)) != 0)
					{
						num5++;
					}
					if (((uint)num8 & (true ? 1u : 0u)) != 0)
					{
						num6++;
					}
					num9 = 1f / (float)num7 * (float)mWidth;
					num10 = 1f / (float)num8 * (float)mHeight;
				}
				if (mFlip == Flip.Horizontally || mFlip == Flip.Both)
				{
					num += (float)num5 * num9;
					num3 -= (float)paddingLeft * num9;
				}
				else
				{
					num += (float)paddingLeft * num9;
					num3 -= (float)num5 * num9;
				}
				if (mFlip == Flip.Vertically || mFlip == Flip.Both)
				{
					num2 += (float)num6 * num10;
					num4 -= (float)paddingBottom * num10;
				}
				else
				{
					num2 += (float)paddingBottom * num10;
					num4 -= (float)num6 * num10;
				}
			}
			Vector4 vector2 = ((!(mAtlas != null)) ? Vector4.zero : (border * pixelSize));
			float num11 = vector2.x + vector2.z;
			float num12 = vector2.y + vector2.w;
			float x = Mathf.Lerp(num, num3 - num11, mDrawRegion.x);
			float y = Mathf.Lerp(num2, num4 - num12, mDrawRegion.y);
			float z = Mathf.Lerp(num + num11, num3, mDrawRegion.z);
			float w = Mathf.Lerp(num2 + num12, num4, mDrawRegion.w);
			return new Vector4(x, y, z, w);
		}
	}

	public override bool premultipliedAlpha => mAtlas != null && mAtlas.premultipliedAlpha;

	public UISpriteData GetAtlasSprite()
	{
		if (!mSpriteSet)
		{
			mSprite = null;
		}
		if (mSprite == null && mAtlas != null)
		{
			if (!string.IsNullOrEmpty(mSpriteName))
			{
				UISpriteData sprite = mAtlas.GetSprite(mSpriteName);
				if (sprite == null)
				{
					return null;
				}
				SetAtlasSprite(sprite);
			}
			if (mSprite == null && mAtlas.spriteList.Count > 0)
			{
				UISpriteData uISpriteData = mAtlas.spriteList[0];
				if (uISpriteData == null)
				{
					return null;
				}
				SetAtlasSprite(uISpriteData);
				if (mSprite == null)
				{
					UnityEngine.Debug.LogError(mAtlas.name + " seems to have a null sprite!");
					return null;
				}
				mSpriteName = mSprite.name;
			}
		}
		return mSprite;
	}

	protected void SetAtlasSprite(UISpriteData sp)
	{
		mChanged = true;
		mSpriteSet = true;
		if (sp != null)
		{
			mSprite = sp;
			mSpriteName = mSprite.name;
		}
		else
		{
			mSpriteName = ((mSprite == null) ? string.Empty : mSprite.name);
			mSprite = sp;
		}
	}

	public override void MakePixelPerfect()
	{
		if (!isValid)
		{
			return;
		}
		base.MakePixelPerfect();
		if (mType == Type.Tiled)
		{
			return;
		}
		UISpriteData atlasSprite = GetAtlasSprite();
		if (atlasSprite == null)
		{
			return;
		}
		Texture texture = mainTexture;
		if (!(texture == null) && (mType == Type.Simple || mType == Type.Filled || !atlasSprite.hasBorder) && texture != null)
		{
			int num = Mathf.RoundToInt(pixelSize * (float)(atlasSprite.width + atlasSprite.paddingLeft + atlasSprite.paddingRight));
			int num2 = Mathf.RoundToInt(pixelSize * (float)(atlasSprite.height + atlasSprite.paddingTop + atlasSprite.paddingBottom));
			if ((num & 1) == 1)
			{
				num++;
			}
			if ((num2 & 1) == 1)
			{
				num2++;
			}
			base.width = num;
			base.height = num2;
		}
	}

	protected override void OnInit()
	{
		if (!mFillCenter)
		{
			mFillCenter = true;
			centerType = AdvancedType.Invisible;
		}
		base.OnInit();
	}

	protected override void OnUpdate()
	{
		base.OnUpdate();
		if (mChanged || !mSpriteSet)
		{
			mSpriteSet = true;
			mSprite = null;
			mChanged = true;
		}
	}

	public override void OnFill(BetterList<Vector3> verts, BetterList<Vector2> uvs, BetterList<Color32> cols)
	{
		Texture texture = mainTexture;
		if (texture == null)
		{
			return;
		}
		if (mSprite == null)
		{
			mSprite = atlas.GetSprite(spriteName);
		}
		if (mSprite != null)
		{
			Rect rect = new Rect(mSprite.x, mSprite.y, mSprite.width, mSprite.height);
			Rect rect2 = new Rect(mSprite.x + mSprite.borderLeft, mSprite.y + mSprite.borderTop, mSprite.width - mSprite.borderLeft - mSprite.borderRight, mSprite.height - mSprite.borderBottom - mSprite.borderTop);
			rect = NGUIMath.ConvertToTexCoords(rect, texture.width, texture.height);
			rect2 = NGUIMath.ConvertToTexCoords(rect2, texture.width, texture.height);
			int size = verts.size;
			Fill(verts, uvs, cols, rect, rect2);
			if (onPostFill != null)
			{
				onPostFill(this, size, verts, uvs, cols);
			}
		}
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(UISprite))]
[AddComponentMenu("NGUI/UI/Sprite Animation")]
public class UISpriteAnimation : MonoBehaviour
{
	[HideInInspector]
	[SerializeField]
	protected int mFPS = 30;

	[HideInInspector]
	[SerializeField]
	protected string mPrefix = string.Empty;

	[HideInInspector]
	[SerializeField]
	protected bool mLoop = true;

	[HideInInspector]
	[SerializeField]
	protected bool mSnap = true;

	protected UISprite mSprite;

	protected float mDelta;

	protected int mIndex;

	protected bool mActive = true;

	protected List<string> mSpriteNames = new List<string>();

	public int frames => mSpriteNames.Count;

	public int framesPerSecond
	{
		get
		{
			return mFPS;
		}
		set
		{
			mFPS = value;
		}
	}

	public string namePrefix
	{
		get
		{
			return mPrefix;
		}
		set
		{
			if (mPrefix != value)
			{
				mPrefix = value;
				RebuildSpriteList();
			}
		}
	}

	public bool loop
	{
		get
		{
			return mLoop;
		}
		set
		{
			mLoop = value;
		}
	}

	public bool isPlaying => mActive;

	protected virtual void Start()
	{
		RebuildSpriteList();
	}

	protected virtual void Update()
	{
		if (!mActive || mSpriteNames.Count <= 1 || !Application.isPlaying || mFPS <= 0)
		{
			return;
		}
		mDelta += RealTime.deltaTime;
		float num = 1f / (float)mFPS;
		if (!(num < mDelta))
		{
			return;
		}
		mDelta = ((!(num > 0f)) ? 0f : (mDelta - num));
		if (++mIndex >= mSpriteNames.Count)
		{
			mIndex = 0;
			mActive = mLoop;
		}
		if (mActive)
		{
			mSprite.spriteName = mSpriteNames[mIndex];
			if (mSnap)
			{
				mSprite.MakePixelPerfect();
			}
		}
	}

	public void RebuildSpriteList()
	{
		if (mSprite == null)
		{
			mSprite = GetComponent<UISprite>();
		}
		mSpriteNames.Clear();
		if (!(mSprite != null) || !(mSprite.atlas != null))
		{
			return;
		}
		List<UISpriteData> spriteList = mSprite.atlas.spriteList;
		int i = 0;
		for (int count = spriteList.Count; i < count; i++)
		{
			UISpriteData uISpriteData = spriteList[i];
			if (string.IsNullOrEmpty(mPrefix) || uISpriteData.name.StartsWith(mPrefix))
			{
				mSpriteNames.Add(uISpriteData.name);
			}
		}
		mSpriteNames.Sort();
	}

	public void Play()
	{
		mActive = true;
	}

	public void Pause()
	{
		mActive = false;
	}

	public void ResetToBeginning()
	{
		mActive = true;
		mIndex = 0;
		if (mSprite != null && mSpriteNames.Count > 0)
		{
			mSprite.spriteName = mSpriteNames[mIndex];
			if (mSnap)
			{
				mSprite.MakePixelPerfect();
			}
		}
	}
}
[Serializable]
public class UISpriteData
{
	public string name = "Sprite";

	public int x;

	public int y;

	public int width;

	public int height;

	public int borderLeft;

	public int borderRight;

	public int borderTop;

	public int borderBottom;

	public int paddingLeft;

	public int paddingRight;

	public int paddingTop;

	public int paddingBottom;

	public bool hasBorder => (borderLeft | borderRight | borderTop | borderBottom) != 0;

	public bool hasPadding => (paddingLeft | paddingRight | paddingTop | paddingBottom) != 0;

	public void SetRect(int x, int y, int width, int height)
	{
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
	}

	public void SetPadding(int left, int bottom, int right, int top)
	{
		paddingLeft = left;
		paddingBottom = bottom;
		paddingRight = right;
		paddingTop = top;
	}

	public void SetBorder(int left, int bottom, int right, int top)
	{
		borderLeft = left;
		borderBottom = bottom;
		borderRight = right;
		borderTop = top;
	}

	public void CopyFrom(UISpriteData sd)
	{
		name = sd.name;
		x = sd.x;
		y = sd.y;
		width = sd.width;
		height = sd.height;
		borderLeft = sd.borderLeft;
		borderRight = sd.borderRight;
		borderTop = sd.borderTop;
		borderBottom = sd.borderBottom;
		paddingLeft = sd.paddingLeft;
		paddingRight = sd.paddingRight;
		paddingTop = sd.paddingTop;
		paddingBottom = sd.paddingBottom;
	}

	public void CopyBorderFrom(UISpriteData sd)
	{
		borderLeft = sd.borderLeft;
		borderRight = sd.borderRight;
		borderTop = sd.borderTop;
		borderBottom = sd.borderBottom;
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/UI/Stretch")]
public class UIStretch : MonoBehaviour
{
	public enum Style
	{
		None,
		Horizontal,
		Vertical,
		Both,
		BasedOnHeight,
		FillKeepingRatio,
		FitInternalKeepingRatio
	}

	public Camera uiCamera;

	public GameObject container;

	public Style style;

	public bool runOnlyOnce = true;

	public Vector2 relativeSize = Vector2.one;

	public Vector2 initialSize = Vector2.one;

	public Vector2 borderPadding = Vector2.zero;

	[HideInInspector]
	[SerializeField]
	private UIWidget widgetContainer;

	private Transform mTrans;

	private UIWidget mWidget;

	private UISprite mSprite;

	private UIPanel mPanel;

	private UIRoot mRoot;

	private Animation mAnim;

	private Rect mRect;

	private bool mStarted;

	private void Awake()
	{
		mAnim = GetComponent<Animation>();
		mRect = default(Rect);
		mTrans = base.transform;
		mWidget = GetComponent<UIWidget>();
		mSprite = GetComponent<UISprite>();
		mPanel = GetComponent<UIPanel>();
		UICamera.onScreenResize = (UICamera.OnScreenResize)Delegate.Combine(UICamera.onScreenResize, new UICamera.OnScreenResize(ScreenSizeChanged));
	}

	private void OnDestroy()
	{
		UICamera.onScreenResize = (UICamera.OnScreenResize)Delegate.Remove(UICamera.onScreenResize, new UICamera.OnScreenResize(ScreenSizeChanged));
	}

	private void ScreenSizeChanged()
	{
		if (mStarted && runOnlyOnce)
		{
			Update();
		}
	}

	private void Start()
	{
		if (container == null && widgetContainer != null)
		{
			container = widgetContainer.gameObject;
			widgetContainer = null;
		}
		if (uiCamera == null)
		{
			uiCamera = NGUITools.FindCameraForLayer(base.gameObject.layer);
		}
		mRoot = NGUITools.FindInParents<UIRoot>(base.gameObject);
		Update();
		mStarted = true;
	}

	private void Update()
	{
		if ((mAnim != null && mAnim.isPlaying) || style == Style.None)
		{
			return;
		}
		UIWidget uIWidget = ((!(container == null)) ? container.GetComponent<UIWidget>() : null);
		UIPanel uIPanel = ((!(container == null) || !(uIWidget == null)) ? container.GetComponent<UIPanel>() : null);
		float num = 1f;
		if (uIWidget != null)
		{
			Bounds bounds = uIWidget.CalculateBounds(base.transform.parent);
			mRect.x = bounds.min.x;
			mRect.y = bounds.min.y;
			mRect.width = bounds.size.x;
			mRect.height = bounds.size.y;
		}
		else if (uIPanel != null)
		{
			if (uIPanel.clipping == UIDrawCall.Clipping.None)
			{
				float num2 = ((!(mRoot != null)) ? 0.5f : ((float)mRoot.activeHeight / (float)Screen.height * 0.5f));
				mRect.xMin = (float)(-Screen.width) * num2;
				mRect.yMin = (float)(-Screen.height) * num2;
				mRect.xMax = 0f - mRect.xMin;
				mRect.yMax = 0f - mRect.yMin;
			}
			else
			{
				Vector4 finalClipRegion = uIPanel.finalClipRegion;
				mRect.x = finalClipRegion.x - finalClipRegion.z * 0.5f;
				mRect.y = finalClipRegion.y - finalClipRegion.w * 0.5f;
				mRect.width = finalClipRegion.z;
				mRect.height = finalClipRegion.w;
			}
		}
		else if (container != null)
		{
			Transform parent = base.transform.parent;
			Bounds bounds2 = ((!(parent != null)) ? NGUIMath.CalculateRelativeWidgetBounds(container.transform) : NGUIMath.CalculateRelativeWidgetBounds(parent, container.transform));
			mRect.x = bounds2.min.x;
			mRect.y = bounds2.min.y;
			mRect.width = bounds2.size.x;
			mRect.height = bounds2.size.y;
		}
		else
		{
			if (!(uiCamera != null))
			{
				return;
			}
			mRect = uiCamera.pixelRect;
			if (mRoot != null)
			{
				num = mRoot.pixelSizeAdjustment;
			}
		}
		float num3 = mRect.width;
		float num4 = mRect.height;
		if (num != 1f && num4 > 1f)
		{
			float num5 = (float)mRoot.activeHeight / num4;
			num3 *= num5;
			num4 *= num5;
		}
		Vector3 vector = ((!(mWidget != null)) ? mTrans.localScale : new Vector3(mWidget.width, mWidget.height));
		if (style == Style.BasedOnHeight)
		{
			vector.x = relativeSize.x * num4;
			vector.y = relativeSize.y * num4;
		}
		else if (style == Style.FillKeepingRatio)
		{
			float num6 = num3 / num4;
			float num7 = initialSize.x / initialSize.y;
			if (num7 < num6)
			{
				float num8 = num3 / initialSize.x;
				vector.x = num3;
				vector.y = initialSize.y * num8;
			}
			else
			{
				float num9 = num4 / initialSize.y;
				vector.x = initialSize.x * num9;
				vector.y = num4;
			}
		}
		else if (style == Style.FitInternalKeepingRatio)
		{
			float num10 = num3 / num4;
			float num11 = initialSize.x / initialSize.y;
			if (num11 > num10)
			{
				float num12 = num3 / initialSize.x;
				vector.x = num3;
				vector.y = initialSize.y * num12;
			}
			else
			{
				float num13 = num4 / initialSize.y;
				vector.x = initialSize.x * num13;
				vector.y = num4;
			}
		}
		else
		{
			if (style != Style.Vertical)
			{
				vector.x = relativeSize.x * num3;
			}
			if (style != Style.Horizontal)
			{
				vector.y = relativeSize.y * num4;
			}
		}
		if (mSprite != null)
		{
			float num14 = ((!(mSprite.atlas != null)) ? 1f : mSprite.atlas.pixelSize);
			vector.x -= borderPadding.x * num14;
			vector.y -= borderPadding.y * num14;
			if (style != Style.Vertical)
			{
				mSprite.width = Mathf.RoundToInt(vector.x);
			}
			if (style != Style.Horizontal)
			{
				mSprite.height = Mathf.RoundToInt(vector.y);
			}
			vector = Vector3.one;
		}
		else if (mWidget != null)
		{
			if (style != Style.Vertical)
			{
				mWidget.width = Mathf.RoundToInt(vector.x - borderPadding.x);
			}
			if (style != Style.Horizontal)
			{
				mWidget.height = Mathf.RoundToInt(vector.y - borderPadding.y);
			}
			vector = Vector3.one;
		}
		else if (mPanel != null)
		{
			Vector4 baseClipRegion = mPanel.baseClipRegion;
			if (style != Style.Vertical)
			{
				baseClipRegion.z = vector.x - borderPadding.x;
			}
			if (style != Style.Horizontal)
			{
				baseClipRegion.w = vector.y - borderPadding.y;
			}
			mPanel.baseClipRegion = baseClipRegion;
			vector = Vector3.one;
		}
		else
		{
			if (style != Style.Vertical)
			{
				vector.x -= borderPadding.x;
			}
			if (style != Style.Horizontal)
			{
				vector.y -= borderPadding.y;
			}
		}
		if (mTrans.localScale != vector)
		{
			mTrans.localScale = vector;
		}
		if (runOnlyOnce && Application.isPlaying)
		{
			base.enabled = false;
		}
	}
}
[AddComponentMenu("NGUI/UI/Text List")]
public class UITextList : MonoBehaviour
{
	public enum Style
	{
		Text,
		Chat
	}

	protected class Paragraph
	{
		public string text;

		public string[] lines;
	}

	public UILabel textLabel;

	public UIProgressBar scrollBar;

	public Style style;

	public int paragraphHistory = 50;

	protected char[] mSeparator = new char[1] { '\n' };

	protected BetterList<Paragraph> mParagraphs = new BetterList<Paragraph>();

	protected float mScroll;

	protected int mTotalLines;

	protected int mLastWidth;

	protected int mLastHeight;

	public bool isValid => textLabel != null && textLabel.ambigiousFont != null;

	public float scrollValue
	{
		get
		{
			return mScroll;
		}
		set
		{
			value = Mathf.Clamp01(value);
			if (isValid && mScroll != value)
			{
				if (scrollBar != null)
				{
					scrollBar.value = value;
					return;
				}
				mScroll = value;
				UpdateVisibleText();
			}
		}
	}

	protected float lineHeight => (!(textLabel != null)) ? 20f : ((float)(textLabel.fontSize + textLabel.spacingY));

	protected int scrollHeight
	{
		get
		{
			if (!isValid)
			{
				return 0;
			}
			int num = Mathf.FloorToInt((float)textLabel.height / lineHeight);
			return Mathf.Max(0, mTotalLines - num);
		}
	}

	public void Clear()
	{
		mParagraphs.Clear();
		UpdateVisibleText();
	}

	private void Start()
	{
		if (textLabel == null)
		{
			textLabel = GetComponentInChildren<UILabel>();
		}
		if (scrollBar != null)
		{
			EventDelegate.Add(scrollBar.onChange, OnScrollBar);
		}
		textLabel.overflowMethod = UILabel.Overflow.ClampContent;
		if (style == Style.Chat)
		{
			textLabel.pivot = UIWidget.Pivot.BottomLeft;
			scrollValue = 1f;
		}
		else
		{
			textLabel.pivot = UIWidget.Pivot.TopLeft;
			scrollValue = 0f;
		}
	}

	private void Update()
	{
		if (isValid && (textLabel.width != mLastWidth || textLabel.height != mLastHeight))
		{
			mLastWidth = textLabel.width;
			mLastHeight = textLabel.height;
			Rebuild();
		}
	}

	public void OnScroll(float val)
	{
		int num = scrollHeight;
		if (num != 0)
		{
			val *= lineHeight;
			scrollValue = mScroll - val / (float)num;
		}
	}

	public void OnDrag(Vector2 delta)
	{
		int num = scrollHeight;
		if (num != 0)
		{
			float num2 = delta.y / lineHeight;
			scrollValue = mScroll + num2 / (float)num;
		}
	}

	private void OnScrollBar()
	{
		mScroll = UIProgressBar.current.value;
		UpdateVisibleText();
	}

	public void Add(string text)
	{
		Add(text, updateVisible: true);
	}

	protected void Add(string text, bool updateVisible)
	{
		Paragraph paragraph = null;
		if (mParagraphs.size < paragraphHistory)
		{
			paragraph = new Paragraph();
		}
		else
		{
			paragraph = mParagraphs[0];
			mParagraphs.RemoveAt(0);
		}
		paragraph.text = text;
		mParagraphs.Add(paragraph);
		Rebuild();
	}

	protected void Rebuild()
	{
		if (!isValid)
		{
			return;
		}
		textLabel.UpdateNGUIText();
		NGUIText.rectHeight = 1000000;
		mTotalLines = 0;
		for (int i = 0; i < mParagraphs.size; i++)
		{
			Paragraph paragraph = mParagraphs.buffer[i];
			NGUIText.WrapText(paragraph.text, out var finalText);
			paragraph.lines = finalText.Split('\n');
			mTotalLines += paragraph.lines.Length;
		}
		mTotalLines = 0;
		int j = 0;
		for (int size = mParagraphs.size; j < size; j++)
		{
			mTotalLines += mParagraphs.buffer[j].lines.Length;
		}
		if (scrollBar != null)
		{
			UIScrollBar uIScrollBar = scrollBar as UIScrollBar;
			if (uIScrollBar != null)
			{
				uIScrollBar.barSize = ((mTotalLines != 0) ? (1f - (float)scrollHeight / (float)mTotalLines) : 1f);
			}
		}
		UpdateVisibleText();
	}

	protected void UpdateVisibleText()
	{
		if (!isValid)
		{
			return;
		}
		if (mTotalLines == 0)
		{
			textLabel.text = string.Empty;
			return;
		}
		int num = Mathf.FloorToInt((float)textLabel.height / lineHeight);
		int num2 = Mathf.Max(0, mTotalLines - num);
		int num3 = Mathf.RoundToInt(mScroll * (float)num2);
		if (num3 < 0)
		{
			num3 = 0;
		}
		StringBuilder stringBuilder = new StringBuilder();
		int num4 = 0;
		int size = mParagraphs.size;
		while (num > 0 && num4 < size)
		{
			Paragraph paragraph = mParagraphs.buffer[num4];
			int num5 = 0;
			int num6 = paragraph.lines.Length;
			while (num > 0 && num5 < num6)
			{
				string value = paragraph.lines[num5];
				if (num3 > 0)
				{
					num3--;
				}
				else
				{
					if (stringBuilder.Length > 0)
					{
						stringBuilder.Append("\n");
					}
					stringBuilder.Append(value);
					num--;
				}
				num5++;
			}
			num4++;
		}
		textLabel.text = stringBuilder.ToString();
	}
}
[ExecuteInEditMode]
[AddComponentMenu("NGUI/UI/NGUI Texture")]
public class UITexture : UIBasicSprite
{
	[HideInInspector]
	[SerializeField]
	private Rect mRect = new Rect(0f, 0f, 1f, 1f);

	[HideInInspector]
	[SerializeField]
	private Texture mTexture;

	[HideInInspector]
	[SerializeField]
	private Material mMat;

	[HideInInspector]
	[SerializeField]
	private Shader mShader;

	[HideInInspector]
	[SerializeField]
	private Vector4 mBorder = Vector4.zero;

	[HideInInspector]
	[SerializeField]
	private bool mFixedAspect;

	[NonSerialized]
	private int mPMA = -1;

	public override Texture mainTexture
	{
		get
		{
			if (mTexture != null)
			{
				return mTexture;
			}
			if (mMat != null)
			{
				return mMat.mainTexture;
			}
			return null;
		}
		set
		{
			if (mTexture != value)
			{
				if (drawCall != null && drawCall.widgetCount == 1 && mMat == null)
				{
					mTexture = value;
					drawCall.mainTexture = value;
					return;
				}
				RemoveFromPanel();
				mTexture = value;
				mPMA = -1;
				MarkAsChanged();
			}
		}
	}

	public override Material material
	{
		get
		{
			return mMat;
		}
		set
		{
			if (mMat != value)
			{
				RemoveFromPanel();
				mShader = null;
				mMat = value;
				mPMA = -1;
				MarkAsChanged();
			}
		}
	}

	public override Shader shader
	{
		get
		{
			if (mMat != null)
			{
				return mMat.shader;
			}
			if (mShader == null)
			{
				mShader = Shader.Find("Unlit/Transparent Colored");
			}
			return mShader;
		}
		set
		{
			if (mShader != value)
			{
				if (drawCall != null && drawCall.widgetCount == 1 && mMat == null)
				{
					mShader = value;
					drawCall.shader = value;
					return;
				}
				RemoveFromPanel();
				mShader = value;
				mPMA = -1;
				mMat = null;
				MarkAsChanged();
			}
		}
	}

	public override bool premultipliedAlpha
	{
		get
		{
			if (mPMA == -1)
			{
				Material material = this.material;
				mPMA = ((material != null && material.shader != null && material.shader.name.Contains("Premultiplied")) ? 1 : 0);
			}
			return mPMA == 1;
		}
	}

	public override Vector4 border
	{
		get
		{
			return mBorder;
		}
		set
		{
			if (mBorder != value)
			{
				mBorder = value;
				MarkAsChanged();
			}
		}
	}

	public Rect uvRect
	{
		get
		{
			return mRect;
		}
		set
		{
			if (mRect != value)
			{
				mRect = value;
				MarkAsChanged();
			}
		}
	}

	public override Vector4 drawingDimensions
	{
		get
		{
			Vector2 vector = base.pivotOffset;
			float num = (0f - vector.x) * (float)mWidth;
			float num2 = (0f - vector.y) * (float)mHeight;
			float num3 = num + (float)mWidth;
			float num4 = num2 + (float)mHeight;
			if (mTexture != null && mType != Type.Tiled)
			{
				int num5 = mTexture.width;
				int num6 = mTexture.height;
				int num7 = 0;
				int num8 = 0;
				float num9 = 1f;
				float num10 = 1f;
				if (num5 > 0 && num6 > 0 && (mType == Type.Simple || mType == Type.Filled))
				{
					if (((uint)num5 & (true ? 1u : 0u)) != 0)
					{
						num7++;
					}
					if (((uint)num6 & (true ? 1u : 0u)) != 0)
					{
						num8++;
					}
					num9 = 1f / (float)num5 * (float)mWidth;
					num10 = 1f / (float)num6 * (float)mHeight;
				}
				if (mFlip == Flip.Horizontally || mFlip == Flip.Both)
				{
					num += (float)num7 * num9;
				}
				else
				{
					num3 -= (float)num7 * num9;
				}
				if (mFlip == Flip.Vertically || mFlip == Flip.Both)
				{
					num2 += (float)num8 * num10;
				}
				else
				{
					num4 -= (float)num8 * num10;
				}
			}
			float num11;
			float num12;
			if (mFixedAspect)
			{
				num11 = 0f;
				num12 = 0f;
			}
			else
			{
				Vector4 vector2 = border;
				num11 = vector2.x + vector2.z;
				num12 = vector2.y + vector2.w;
			}
			float x = Mathf.Lerp(num, num3 - num11, mDrawRegion.x);
			float y = Mathf.Lerp(num2, num4 - num12, mDrawRegion.y);
			float z = Mathf.Lerp(num + num11, num3, mDrawRegion.z);
			float w = Mathf.Lerp(num2 + num12, num4, mDrawRegion.w);
			return new Vector4(x, y, z, w);
		}
	}

	public bool fixedAspect
	{
		get
		{
			return mFixedAspect;
		}
		set
		{
			if (mFixedAspect != value)
			{
				mFixedAspect = value;
				mDrawRegion = new Vector4(0f, 0f, 1f, 1f);
				MarkAsChanged();
			}
		}
	}

	public override void MakePixelPerfect()
	{
		base.MakePixelPerfect();
		if (mType == Type.Tiled)
		{
			return;
		}
		Texture texture = mainTexture;
		if (!(texture == null) && (mType == Type.Simple || mType == Type.Filled || !base.hasBorder) && texture != null)
		{
			int num = texture.width;
			int num2 = texture.height;
			if ((num & 1) == 1)
			{
				num++;
			}
			if ((num2 & 1) == 1)
			{
				num2++;
			}
			base.width = num;
			base.height = num2;
		}
	}

	protected override void OnUpdate()
	{
		base.OnUpdate();
		if (!mFixedAspect)
		{
			return;
		}
		Texture texture = mainTexture;
		if (texture != null)
		{
			int num = texture.width;
			int num2 = texture.height;
			if ((num & 1) == 1)
			{
				num++;
			}
			if ((num2 & 1) == 1)
			{
				num2++;
			}
			float num3 = mWidth;
			float num4 = mHeight;
			float num5 = num3 / num4;
			float num6 = (float)num / (float)num2;
			if (num6 < num5)
			{
				float num7 = (num3 - num4 * num6) / num3 * 0.5f;
				base.drawRegion = new Vector4(num7, 0f, 1f - num7, 1f);
			}
			else
			{
				float num8 = (num4 - num3 / num6) / num4 * 0.5f;
				base.drawRegion = new Vector4(0f, num8, 1f, 1f - num8);
			}
		}
	}

	public override void OnFill(BetterList<Vector3> verts, BetterList<Vector2> uvs, BetterList<Color32> cols)
	{
		Texture texture = mainTexture;
		if (!(texture == null))
		{
			Rect rect = new Rect(mRect.x * (float)texture.width, mRect.y * (float)texture.height, (float)texture.width * mRect.width, (float)texture.height * mRect.height);
			Rect inner = rect;
			Vector4 vector = border;
			inner.xMin += vector.x;
			inner.yMin += vector.y;
			inner.xMax -= vector.z;
			inner.yMax -= vector.w;
			float num = 1f / (float)texture.width;
			float num2 = 1f / (float)texture.height;
			rect.xMin *= num;
			rect.xMax *= num;
			rect.yMin *= num2;
			rect.yMax *= num2;
			inner.xMin *= num;
			inner.xMax *= num;
			inner.yMin *= num2;
			inner.yMax *= num2;
			int size = verts.size;
			Fill(verts, uvs, cols, rect, inner);
			if (onPostFill != null)
			{
				onPostFill(this, size, verts, uvs, cols);
			}
		}
	}
}
[AddComponentMenu("NGUI/UI/Tooltip")]
public class UITooltip : MonoBehaviour
{
	protected static UITooltip mInstance;

	public Camera uiCamera;

	public UILabel text;

	public UISprite background;

	public float appearSpeed = 10f;

	public bool scalingTransitions = true;

	protected GameObject mHover;

	protected Transform mTrans;

	protected float mTarget;

	protected float mCurrent;

	protected Vector3 mPos;

	protected Vector3 mSize = Vector3.zero;

	protected UIWidget[] mWidgets;

	public static bool isVisible => mInstance != null && mInstance.mTarget == 1f;

	private void Awake()
	{
		mInstance = this;
	}

	private void OnDestroy()
	{
		mInstance = null;
	}

	protected virtual void Start()
	{
		mTrans = base.transform;
		mWidgets = GetComponentsInChildren<UIWidget>();
		mPos = mTrans.localPosition;
		if (uiCamera == null)
		{
			uiCamera = NGUITools.FindCameraForLayer(base.gameObject.layer);
		}
		SetAlpha(0f);
	}

	protected virtual void Update()
	{
		if (mHover != UICamera.hoveredObject)
		{
			mHover = null;
			mTarget = 0f;
		}
		if (mCurrent != mTarget)
		{
			mCurrent = Mathf.Lerp(mCurrent, mTarget, RealTime.deltaTime * appearSpeed);
			if (Mathf.Abs(mCurrent - mTarget) < 0.001f)
			{
				mCurrent = mTarget;
			}
			SetAlpha(mCurrent * mCurrent);
			if (scalingTransitions)
			{
				Vector3 vector = mSize * 0.25f;
				vector.y = 0f - vector.y;
				Vector3 localScale = Vector3.one * (1.5f - mCurrent * 0.5f);
				Vector3 localPosition = Vector3.Lerp(mPos - vector, mPos, mCurrent);
				mTrans.localPosition = localPosition;
				mTrans.localScale = localScale;
			}
		}
	}

	protected virtual void SetAlpha(float val)
	{
		int i = 0;
		for (int num = mWidgets.Length; i < num; i++)
		{
			UIWidget uIWidget = mWidgets[i];
			UnityEngine.Color color = uIWidget.color;
			color.a = val;
			uIWidget.color = color;
		}
	}

	protected virtual void SetText(string tooltipText)
	{
		if (text != null && !string.IsNullOrEmpty(tooltipText))
		{
			mTarget = 1f;
			mHover = UICamera.hoveredObject;
			text.text = tooltipText;
			mPos = Input.mousePosition;
			Transform transform = text.transform;
			Vector3 localPosition = transform.localPosition;
			Vector3 localScale = transform.localScale;
			mSize = text.printedSize;
			mSize.x *= localScale.x;
			mSize.y *= localScale.y;
			if (background != null)
			{
				Vector4 border = background.border;
				mSize.x += border.x + border.z + (localPosition.x - border.x) * 2f;
				mSize.y += border.y + border.w + (0f - localPosition.y - border.y) * 2f;
				background.width = Mathf.RoundToInt(mSize.x);
				background.height = Mathf.RoundToInt(mSize.y);
			}
			if (uiCamera != null)
			{
				mPos.x = Mathf.Clamp01(mPos.x / (float)Screen.width);
				mPos.y = Mathf.Clamp01(mPos.y / (float)Screen.height);
				float num = uiCamera.orthographicSize / mTrans.parent.lossyScale.y;
				float num2 = (float)Screen.height * 0.5f / num;
				Vector2 vector = new Vector2(num2 * mSize.x / (float)Screen.width, num2 * mSize.y / (float)Screen.height);
				mPos.x = Mathf.Min(mPos.x, 1f - vector.x);
				mPos.y = Mathf.Max(mPos.y, vector.y);
				mTrans.position = uiCamera.ViewportToWorldPoint(mPos);
				mPos = mTrans.localPosition;
				mPos.x = Mathf.Round(mPos.x);
				mPos.y = Mathf.Round(mPos.y);
				mTrans.localPosition = mPos;
			}
			else
			{
				if (mPos.x + mSize.x > (float)Screen.width)
				{
					mPos.x = (float)Screen.width - mSize.x;
				}
				if (mPos.y - mSize.y < 0f)
				{
					mPos.y = mSize.y;
				}
				mPos.x -= (float)Screen.width * 0.5f;
				mPos.y -= (float)Screen.height * 0.5f;
			}
		}
		else
		{
			mHover = null;
			mTarget = 0f;
		}
	}

	[Obsolete("Use UITooltip.Show instead")]
	public static void ShowText(string text)
	{
		if (mInstance != null)
		{
			mInstance.SetText(text);
		}
	}

	public static void Show(string text)
	{
		if (mInstance != null)
		{
			mInstance.SetText(text);
		}
	}

	public static void Hide()
	{
		if (mInstance != null)
		{
			mInstance.mHover = null;
			mInstance.mTarget = 0f;
		}
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("NGUI/UI/Viewport Camera")]
public class UIViewport : MonoBehaviour
{
	public Camera sourceCamera;

	public Transform topLeft;

	public Transform bottomRight;

	public float fullSize = 1f;

	private Camera mCam;

	private void Start()
	{
		mCam = GetComponent<Camera>();
		if (sourceCamera == null)
		{
			sourceCamera = Camera.main;
		}
	}

	private void LateUpdate()
	{
		if (topLeft != null && bottomRight != null)
		{
			Vector3 vector = sourceCamera.WorldToScreenPoint(topLeft.position);
			Vector3 vector2 = sourceCamera.WorldToScreenPoint(bottomRight.position);
			Rect rect = new Rect(vector.x / (float)Screen.width, vector2.y / (float)Screen.height, (vector2.x - vector.x) / (float)Screen.width, (vector.y - vector2.y) / (float)Screen.height);
			float num = fullSize * rect.height;
			if (rect != mCam.rect)
			{
				mCam.rect = rect;
			}
			if (mCam.orthographicSize != num)
			{
				mCam.orthographicSize = num;
			}
		}
	}
}
public class OVRBoundary
{
	public enum Node
	{
		HandLeft = 3,
		HandRight = 4,
		Head = 9
	}

	public enum BoundaryType
	{
		OuterBoundary = 1,
		PlayArea = 0x100
	}

	public struct BoundaryTestResult
	{
		public bool IsTriggering;

		public float ClosestDistance;

		public Vector3 ClosestPoint;

		public Vector3 ClosestPointNormal;
	}

	public struct BoundaryLookAndFeel
	{
		public UnityEngine.Color Color;
	}

	private static int cachedVector3fSize = Marshal.SizeOf(typeof(OVRPlugin.Vector3f));

	private static OVRNativeBuffer cachedGeometryNativeBuffer = new OVRNativeBuffer(0);

	private static float[] cachedGeometryManagedBuffer = new float[0];

	public bool GetConfigured()
	{
		return OVRPlugin.GetBoundaryConfigured();
	}

	public BoundaryTestResult TestNode(Node node, BoundaryType boundaryType)
	{
		OVRPlugin.BoundaryTestResult boundaryTestResult = OVRPlugin.TestBoundaryNode((OVRPlugin.Node)node, (OVRPlugin.BoundaryType)boundaryType);
		BoundaryTestResult result = default(BoundaryTestResult);
		result.IsTriggering = boundaryTestResult.IsTriggering == OVRPlugin.Bool.True;
		result.ClosestDistance = boundaryTestResult.ClosestDistance;
		result.ClosestPoint = boundaryTestResult.ClosestPoint.FromFlippedZVector3f();
		result.ClosestPointNormal = boundaryTestResult.ClosestPointNormal.FromFlippedZVector3f();
		return result;
	}

	public BoundaryTestResult TestPoint(Vector3 point, BoundaryType boundaryType)
	{
		OVRPlugin.BoundaryTestResult boundaryTestResult = OVRPlugin.TestBoundaryPoint(point.ToFlippedZVector3f(), (OVRPlugin.BoundaryType)boundaryType);
		BoundaryTestResult result = default(BoundaryTestResult);
		result.IsTriggering = boundaryTestResult.IsTriggering == OVRPlugin.Bool.True;
		result.ClosestDistance = boundaryTestResult.ClosestDistance;
		result.ClosestPoint = boundaryTestResult.ClosestPoint.FromFlippedZVector3f();
		result.ClosestPointNormal = boundaryTestResult.ClosestPointNormal.FromFlippedZVector3f();
		return result;
	}

	public void SetLookAndFeel(BoundaryLookAndFeel lookAndFeel)
	{
		OVRPlugin.BoundaryLookAndFeel boundaryLookAndFeel = default(OVRPlugin.BoundaryLookAndFeel);
		boundaryLookAndFeel.Color = lookAndFeel.Color.ToColorf();
		OVRPlugin.BoundaryLookAndFeel boundaryLookAndFeel2 = boundaryLookAndFeel;
		OVRPlugin.SetBoundaryLookAndFeel(boundaryLookAndFeel2);
	}

	public void ResetLookAndFeel()
	{
		OVRPlugin.ResetBoundaryLookAndFeel();
	}

	public Vector3[] GetGeometry(BoundaryType boundaryType)
	{
		int pointsCount = 0;
		if (OVRPlugin.GetBoundaryGeometry2((OVRPlugin.BoundaryType)boundaryType, IntPtr.Zero, ref pointsCount))
		{
			int num = pointsCount * cachedVector3fSize;
			if (cachedGeometryNativeBuffer.GetCapacity() < num)
			{
				cachedGeometryNativeBuffer.Reset(num);
			}
			int num2 = pointsCount * 3;
			if (cachedGeometryManagedBuffer.Length < num2)
			{
				cachedGeometryManagedBuffer = new float[num2];
			}
			if (OVRPlugin.GetBoundaryGeometry2((OVRPlugin.BoundaryType)boundaryType, cachedGeometryNativeBuffer.GetPointer(), ref pointsCount))
			{
				Marshal.Copy(cachedGeometryNativeBuffer.GetPointer(), cachedGeometryManagedBuffer, 0, num2);
				Vector3[] array = new Vector3[pointsCount];
				for (int i = 0; i < pointsCount; i++)
				{
					ref Vector3 reference = ref array[i];
					reference = new OVRPlugin.Vector3f
					{
						x = cachedGeometryManagedBuffer[3 * i],
						y = cachedGeometryManagedBuffer[3 * i + 1],
						z = cachedGeometryManagedBuffer[3 * i + 2]
					}.FromFlippedZVector3f();
				}
				return array;
			}
		}
		return new Vector3[0];
	}

	public Vector3 GetDimensions(BoundaryType boundaryType)
	{
		return OVRPlugin.GetBoundaryDimensions((OVRPlugin.BoundaryType)boundaryType).FromVector3f();
	}

	public bool GetVisible()
	{
		return OVRPlugin.GetBoundaryVisible();
	}

	public void SetVisible(bool value)
	{
		OVRPlugin.SetBoundaryVisible(value);
	}
}
[ExecuteInEditMode]
public class OVRCameraRig : MonoBehaviour
{
	public bool usePerEyeCameras;

	private readonly string trackingSpaceName = "TrackingSpace";

	private readonly string trackerAnchorName = "TrackerAnchor";

	private readonly string eyeAnchorName = "EyeAnchor";

	private readonly string handAnchorName = "HandAnchor";

	private readonly string legacyEyeAnchorName = "Camera";

	private Camera _centerEyeCamera;

	private Camera _leftEyeCamera;

	private Camera _rightEyeCamera;

	private bool correctedTrackingSpace;

	public Camera leftEyeCamera => (!usePerEyeCameras) ? _centerEyeCamera : _leftEyeCamera;

	public Camera rightEyeCamera => (!usePerEyeCameras) ? _centerEyeCamera : _rightEyeCamera;

	public Transform trackingSpace { get; private set; }

	public Transform leftEyeAnchor { get; private set; }

	public Transform centerEyeAnchor { get; private set; }

	public Transform rightEyeAnchor { get; private set; }

	public Transform leftHandAnchor { get; private set; }

	public Transform rightHandAnchor { get; private set; }

	public Transform trackerAnchor { get; private set; }

	public event Action<OVRCameraRig> UpdatedAnchors;

	private void Awake()
	{
		EnsureGameObjectIntegrity();
	}

	private void Start()
	{
		EnsureGameObjectIntegrity();
		if (Application.isPlaying)
		{
			UpdateAnchors();
		}
	}

	private void Update()
	{
		EnsureGameObjectIntegrity();
		if (Application.isPlaying)
		{
			UpdateAnchors();
		}
	}

	private void UpdateAnchors()
	{
		bool monoscopic = OVRManager.instance.monoscopic;
		OVRPose pose = OVRManager.tracker.GetPose();
		trackerAnchor.localRotation = pose.orientation;
		centerEyeAnchor.localRotation = InputTracking.GetLocalRotation(VRNode.CenterEye);
		leftEyeAnchor.localRotation = ((!monoscopic) ? InputTracking.GetLocalRotation(VRNode.LeftEye) : centerEyeAnchor.localRotation);
		rightEyeAnchor.localRotation = ((!monoscopic) ? InputTracking.GetLocalRotation(VRNode.RightEye) : centerEyeAnchor.localRotation);
		leftHandAnchor.localRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.LTouch);
		rightHandAnchor.localRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTouch);
		if (this.UpdatedAnchors != null)
		{
			this.UpdatedAnchors(this);
		}
	}

	public void EnsureGameObjectIntegrity()
	{
		if (trackingSpace == null)
		{
			trackingSpace = ConfigureRootAnchor(trackingSpaceName);
		}
		if (leftEyeAnchor == null)
		{
			leftEyeAnchor = ConfigureEyeAnchor(trackingSpace, VRNode.LeftEye);
		}
		if (centerEyeAnchor == null)
		{
			centerEyeAnchor = ConfigureEyeAnchor(trackingSpace, VRNode.CenterEye);
		}
		if (rightEyeAnchor == null)
		{
			rightEyeAnchor = ConfigureEyeAnchor(trackingSpace, VRNode.RightEye);
		}
		if (leftHandAnchor == null)
		{
			leftHandAnchor = ConfigureHandAnchor(trackingSpace, OVRPlugin.Node.HandLeft);
		}
		if (rightHandAnchor == null)
		{
			rightHandAnchor = ConfigureHandAnchor(trackingSpace, OVRPlugin.Node.HandRight);
		}
		if (trackerAnchor == null)
		{
			trackerAnchor = ConfigureTrackerAnchor(trackingSpace);
		}
		if (_centerEyeCamera == null || _leftEyeCamera == null || _rightEyeCamera == null)
		{
			_centerEyeCamera = centerEyeAnchor.GetComponent<Camera>();
			_leftEyeCamera = leftEyeAnchor.GetComponent<Camera>();
			_rightEyeCamera = rightEyeAnchor.GetComponent<Camera>();
			if (_centerEyeCamera == null)
			{
				_centerEyeCamera = centerEyeAnchor.gameObject.AddComponent<Camera>();
				_centerEyeCamera.tag = "MainCamera";
			}
			if (_leftEyeCamera == null)
			{
				_leftEyeCamera = leftEyeAnchor.gameObject.AddComponent<Camera>();
				_leftEyeCamera.tag = "MainCamera";
			}
			if (_rightEyeCamera == null)
			{
				_rightEyeCamera = rightEyeAnchor.gameObject.AddComponent<Camera>();
				_rightEyeCamera.tag = "MainCamera";
			}
			_centerEyeCamera.stereoTargetEye = StereoTargetEyeMask.Both;
			_leftEyeCamera.stereoTargetEye = StereoTargetEyeMask.Left;
			_rightEyeCamera.stereoTargetEye = StereoTargetEyeMask.Right;
		}
		_centerEyeCamera.enabled = !usePerEyeCameras;
		_leftEyeCamera.enabled = usePerEyeCameras;
		_rightEyeCamera.enabled = usePerEyeCameras;
	}

	private Transform ConfigureRootAnchor(string name)
	{
		Transform transform = base.transform.Find(name);
		if (transform == null)
		{
			transform = new GameObject(name).transform;
		}
		transform.parent = base.transform;
		transform.localScale = Vector3.one;
		transform.localPosition = Vector3.zero;
		transform.localRotation = Quaternion.identity;
		return transform;
	}

	private Transform ConfigureEyeAnchor(Transform root, VRNode eye)
	{
		string text = eye switch
		{
			VRNode.CenterEye => "Center", 
			VRNode.LeftEye => "Left", 
			_ => "Right", 
		} + eyeAnchorName;
		Transform transform = base.transform.Find(root.name + "/" + text);
		if (transform == null)
		{
			transform = base.transform.Find(text);
		}
		if (transform == null)
		{
			string text2 = legacyEyeAnchorName + eye;
			transform = base.transform.Find(text2);
		}
		if (transform == null)
		{
			transform = new GameObject(text).transform;
		}
		transform.name = text;
		transform.parent = root;
		transform.localScale = Vector3.one;
		transform.localPosition = Vector3.zero;
		transform.localRotation = Quaternion.identity;
		return transform;
	}

	private Transform ConfigureHandAnchor(Transform root, OVRPlugin.Node hand)
	{
		string text = ((hand != OVRPlugin.Node.HandLeft) ? "Right" : "Left");
		string text2 = text + handAnchorName;
		Transform transform = base.transform.Find(root.name + "/" + text2);
		if (transform == null)
		{
			transform = base.transform.Find(text2);
		}
		if (transform == null)
		{
			transform = new GameObject(text2).transform;
		}
		transform.name = text2;
		transform.parent = root;
		transform.localScale = Vector3.one;
		transform.localPosition = Vector3.zero;
		transform.localRotation = Quaternion.identity;
		return transform;
	}

	private Transform ConfigureTrackerAnchor(Transform root)
	{
		string text = trackerAnchorName;
		Transform transform = base.transform.Find(root.name + "/" + text);
		if (transform == null)
		{
			transform = new GameObject(text).transform;
		}
		transform.parent = root;
		transform.localScale = Vector3.one;
		transform.localPosition = Vector3.zero;
		transform.localRotation = Quaternion.identity;
		return transform;
	}
}
public static class OVRExtensions
{
	public static OVRPose ToTrackingSpacePose(this Transform transform)
	{
		OVRPose oVRPose = default(OVRPose);
		oVRPose.position = InputTracking.GetLocalPosition(VRNode.Head);
		oVRPose.orientation = InputTracking.GetLocalRotation(VRNode.Head);
		return oVRPose * transform.ToHeadSpacePose();
	}

	public static OVRPose ToHeadSpacePose(this Transform transform)
	{
		return Camera.current.transform.ToOVRPose().Inverse() * transform.ToOVRPose();
	}

	internal static OVRPose ToOVRPose(this Transform t, bool isLocal = false)
	{
		OVRPose result = default(OVRPose);
		result.orientation = ((!isLocal) ? t.rotation : t.localRotation);
		result.position = ((!isLocal) ? t.position : t.localPosition);
		return result;
	}

	internal static void FromOVRPose(this Transform t, OVRPose pose, bool isLocal = false)
	{
		if (isLocal)
		{
			t.localRotation = pose.orientation;
			t.localPosition = pose.position;
		}
		else
		{
			t.rotation = pose.orientation;
			t.position = pose.position;
		}
	}

	internal static OVRPose ToOVRPose(this OVRPlugin.Posef p)
	{
		OVRPose result = default(OVRPose);
		result.position = new Vector3(p.Position.x, p.Position.y, 0f - p.Position.z);
		result.orientation = new Quaternion(0f - p.Orientation.x, 0f - p.Orientation.y, p.Orientation.z, p.Orientation.w);
		return result;
	}

	internal static OVRTracker.Frustum ToFrustum(this OVRPlugin.Frustumf f)
	{
		OVRTracker.Frustum result = default(OVRTracker.Frustum);
		result.nearZ = f.zNear;
		result.farZ = f.zFar;
		result.fov = new Vector2
		{
			x = 57.29578f * f.fovX,
			y = 57.29578f * f.fovY
		};
		return result;
	}

	internal static UnityEngine.Color FromColorf(this OVRPlugin.Colorf c)
	{
		UnityEngine.Color result = default(UnityEngine.Color);
		result.r = c.r;
		result.g = c.g;
		result.b = c.b;
		result.a = c.a;
		return result;
	}

	internal static OVRPlugin.Colorf ToColorf(this UnityEngine.Color c)
	{
		OVRPlugin.Colorf result = default(OVRPlugin.Colorf);
		result.r = c.r;
		result.g = c.g;
		result.b = c.b;
		result.a = c.a;
		return result;
	}

	internal static Vector3 FromVector3f(this OVRPlugin.Vector3f v)
	{
		Vector3 result = default(Vector3);
		result.x = v.x;
		result.y = v.y;
		result.z = v.z;
		return result;
	}

	internal static Vector3 FromFlippedZVector3f(this OVRPlugin.Vector3f v)
	{
		Vector3 result = default(Vector3);
		result.x = v.x;
		result.y = v.y;
		result.z = 0f - v.z;
		return result;
	}

	internal static OVRPlugin.Vector3f ToVector3f(this Vector3 v)
	{
		OVRPlugin.Vector3f result = default(OVRPlugin.Vector3f);
		result.x = v.x;
		result.y = v.y;
		result.z = v.z;
		return result;
	}

	internal static OVRPlugin.Vector3f ToFlippedZVector3f(this Vector3 v)
	{
		OVRPlugin.Vector3f result = default(OVRPlugin.Vector3f);
		result.x = v.x;
		result.y = v.y;
		result.z = 0f - v.z;
		return result;
	}

	internal static Quaternion FromQuatf(this OVRPlugin.Quatf q)
	{
		Quaternion result = default(Quaternion);
		result.x = q.x;
		result.y = q.y;
		result.z = q.z;
		result.w = q.w;
		return result;
	}

	internal static OVRPlugin.Quatf ToQuatf(this Quaternion q)
	{
		OVRPlugin.Quatf result = default(OVRPlugin.Quatf);
		result.x = q.x;
		result.y = q.y;
		result.z = q.z;
		result.w = q.w;
		return result;
	}
}
[Serializable]
public struct OVRPose
{
	public Vector3 position;

	public Quaternion orientation;

	public static OVRPose identity
	{
		get
		{
			OVRPose result = default(OVRPose);
			result.position = Vector3.zero;
			result.orientation = Quaternion.identity;
			return result;
		}
	}

	public override bool Equals(object obj)
	{
		return obj is OVRPose && this == (OVRPose)obj;
	}

	public override int GetHashCode()
	{
		return position.GetHashCode() ^ orientation.GetHashCode();
	}

	public static bool operator ==(OVRPose x, OVRPose y)
	{
		return x.position == y.position && x.orientation == y.orientation;
	}

	public static bool operator !=(OVRPose x, OVRPose y)
	{
		return !(x == y);
	}

	public static OVRPose operator *(OVRPose lhs, OVRPose rhs)
	{
		OVRPose result = default(OVRPose);
		result.position = lhs.position + lhs.orientation * rhs.position;
		result.orientation = lhs.orientation * rhs.orientation;
		return result;
	}

	public OVRPose Inverse()
	{
		OVRPose result = default(OVRPose);
		result.orientation = Quaternion.Inverse(orientation);
		result.position = result.orientation * -position;
		return result;
	}

	internal OVRPose flipZ()
	{
		OVRPose result = this;
		result.position.z = 0f - result.position.z;
		result.orientation.z = 0f - result.orientation.z;
		result.orientation.w = 0f - result.orientation.w;
		return result;
	}

	internal OVRPlugin.Posef ToPosef()
	{
		OVRPlugin.Posef result = default(OVRPlugin.Posef);
		result.Position = position.ToVector3f();
		result.Orientation = orientation.ToQuatf();
		return result;
	}
}
public class OVRNativeBuffer : IDisposable
{
	private bool disposed;

	private int m_numBytes;

	private IntPtr m_ptr = IntPtr.Zero;

	public OVRNativeBuffer(int numBytes)
	{
		Reallocate(numBytes);
	}

	~OVRNativeBuffer()
	{
		Dispose(disposing: false);
	}

	public void Reset(int numBytes)
	{
		Reallocate(numBytes);
	}

	public int GetCapacity()
	{
		return m_numBytes;
	}

	public IntPtr GetPointer(int byteOffset = 0)
	{
		if (byteOffset < 0 || byteOffset >= m_numBytes)
		{
			return IntPtr.Zero;
		}
		return (byteOffset != 0) ? new IntPtr(m_ptr.ToInt64() + byteOffset) : m_ptr;
	}

	public void Dispose()
	{
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}

	private void Dispose(bool disposing)
	{
		if (!disposed)
		{
			if (disposing)
			{
			}
			Release();
			disposed = true;
		}
	}

	private void Reallocate(int numBytes)
	{
		Release();
		if (numBytes > 0)
		{
			m_ptr = Marshal.AllocHGlobal(numBytes);
			m_numBytes = numBytes;
		}
		else
		{
			m_ptr = IntPtr.Zero;
			m_numBytes = 0;
		}
	}

	private void Release()
	{
		if (m_ptr != IntPtr.Zero)
		{
			Marshal.FreeHGlobal(m_ptr);
			m_ptr = IntPtr.Zero;
			m_numBytes = 0;
		}
	}
}
public class OVRDebugHeadController : MonoBehaviour
{
	[SerializeField]
	public bool AllowPitchLook;

	[SerializeField]
	public bool AllowYawLook = true;

	[SerializeField]
	public bool InvertPitch;

	[SerializeField]
	public float GamePad_PitchDegreesPerSec = 90f;

	[SerializeField]
	public float GamePad_YawDegreesPerSec = 90f;

	[SerializeField]
	public bool AllowMovement;

	[SerializeField]
	public float ForwardSpeed = 2f;

	[SerializeField]
	public float StrafeSpeed = 2f;

	protected OVRCameraRig CameraRig;

	private void Awake()
	{
		OVRCameraRig[] componentsInChildren = base.gameObject.GetComponentsInChildren<OVRCameraRig>();
		if (componentsInChildren.Length == 0)
		{
			UnityEngine.Debug.LogWarning("OVRCamParent: No OVRCameraRig attached.");
		}
		else if (componentsInChildren.Length > 1)
		{
			UnityEngine.Debug.LogWarning("OVRCamParent: More then 1 OVRCameraRig attached.");
		}
		else
		{
			CameraRig = componentsInChildren[0];
		}
	}

	private void Start()
	{
	}

	private void Update()
	{
		if (AllowMovement)
		{
			float y = OVRInput.Get(OVRInput.RawAxis2D.LThumbstick).y;
			float x = OVRInput.Get(OVRInput.RawAxis2D.LThumbstick).x;
			Vector3 vector = CameraRig.centerEyeAnchor.rotation * Vector3.forward * y * Time.deltaTime * ForwardSpeed;
			Vector3 vector2 = CameraRig.centerEyeAnchor.rotation * Vector3.right * x * Time.deltaTime * StrafeSpeed;
			base.transform.position += vector + vector2;
		}
		if (VRDevice.isPresent || (!AllowYawLook && !AllowPitchLook))
		{
			return;
		}
		Quaternion quaternion = base.transform.rotation;
		if (AllowYawLook)
		{
			float x2 = OVRInput.Get(OVRInput.RawAxis2D.RThumbstick).x;
			float angle = x2 * Time.deltaTime * GamePad_YawDegreesPerSec;
			Quaternion quaternion2 = Quaternion.AngleAxis(angle, Vector3.up);
			quaternion = quaternion2 * quaternion;
		}
		if (AllowPitchLook)
		{
			float num = OVRInput.Get(OVRInput.RawAxis2D.RThumbstick).y;
			if (Mathf.Abs(num) > 0.0001f)
			{
				if (InvertPitch)
				{
					num *= -1f;
				}
				float angle2 = num * Time.deltaTime * GamePad_PitchDegreesPerSec;
				Quaternion quaternion3 = Quaternion.AngleAxis(angle2, Vector3.left);
				quaternion *= quaternion3;
			}
		}
		base.transform.rotation = quaternion;
	}
}
public class OVRDisplay
{
	public struct EyeRenderDesc
	{
		public Vector2 resolution;

		public Vector2 fov;
	}

	public struct LatencyData
	{
		public float render;

		public float timeWarp;

		public float postPresent;

		public float renderError;

		public float timeWarpError;
	}

	private bool needsConfigureTexture;

	private EyeRenderDesc[] eyeDescs = new EyeRenderDesc[2];

	public Vector3 acceleration
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return Vector3.zero;
			}
			return OVRPlugin.GetEyeAcceleration(OVRPlugin.Eye.None).ToOVRPose().position;
		}
	}

	public Quaternion angularAcceleration
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return Quaternion.identity;
			}
			return OVRPlugin.GetEyeAcceleration(OVRPlugin.Eye.None).ToOVRPose().orientation;
		}
	}

	public Vector3 velocity
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return Vector3.zero;
			}
			return OVRPlugin.GetEyeVelocity(OVRPlugin.Eye.None).ToOVRPose().position;
		}
	}

	public Quaternion angularVelocity
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return Quaternion.identity;
			}
			return OVRPlugin.GetEyeVelocity(OVRPlugin.Eye.None).ToOVRPose().orientation;
		}
	}

	public LatencyData latency
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return default(LatencyData);
			}
			string input = OVRPlugin.latency;
			Regex regex = new Regex("Render: ([0-9]+[.][0-9]+)ms, TimeWarp: ([0-9]+[.][0-9]+)ms, PostPresent: ([0-9]+[.][0-9]+)ms", RegexOptions.None);
			LatencyData result = default(LatencyData);
			Match match = regex.Match(input);
			if (match.Success)
			{
				result.render = float.Parse(match.Groups[1].Value);
				result.timeWarp = float.Parse(match.Groups[2].Value);
				result.postPresent = float.Parse(match.Groups[3].Value);
			}
			return result;
		}
	}

	public int recommendedMSAALevel
	{
		get
		{
			int num = OVRPlugin.recommendedMSAALevel;
			if (num == 1)
			{
				num = 0;
			}
			return num;
		}
	}

	public event Action RecenteredPose;

	public OVRDisplay()
	{
		UpdateTextures();
	}

	public void Update()
	{
		UpdateTextures();
	}

	public void RecenterPose()
	{
		InputTracking.Recenter();
		if (this.RecenteredPose != null)
		{
			this.RecenteredPose();
		}
	}

	public EyeRenderDesc GetEyeRenderDesc(VRNode eye)
	{
		return eyeDescs[(int)eye];
	}

	private void UpdateTextures()
	{
		ConfigureEyeDesc(VRNode.LeftEye);
		ConfigureEyeDesc(VRNode.RightEye);
	}

	private void ConfigureEyeDesc(VRNode eye)
	{
		if (OVRManager.isHmdPresent)
		{
			OVRPlugin.Sizei eyeTextureSize = OVRPlugin.GetEyeTextureSize((OVRPlugin.Eye)eye);
			OVRPlugin.Frustumf eyeFrustum = OVRPlugin.GetEyeFrustum((OVRPlugin.Eye)eye);
			ref EyeRenderDesc reference = ref eyeDescs[(int)eye];
			reference = new EyeRenderDesc
			{
				resolution = new Vector2(eyeTextureSize.w, eyeTextureSize.h),
				fov = 57.29578f * new Vector2(eyeFrustum.fovX, eyeFrustum.fovY)
			};
		}
	}
}
public static class OVRHaptics
{
	public static class Config
	{
		public static int SampleRateHz { get; private set; }

		public static int SampleSizeInBytes { get; private set; }

		public static int MinimumSafeSamplesQueued { get; private set; }

		public static int MinimumBufferSamplesCount { get; private set; }

		public static int OptimalBufferSamplesCount { get; private set; }

		public static int MaximumBufferSamplesCount { get; private set; }

		static Config()
		{
			Load();
		}

		public static void Load()
		{
			OVRPlugin.HapticsDesc controllerHapticsDesc = OVRPlugin.GetControllerHapticsDesc(2u);
			SampleRateHz = controllerHapticsDesc.SampleRateHz;
			SampleSizeInBytes = controllerHapticsDesc.SampleSizeInBytes;
			MinimumSafeSamplesQueued = controllerHapticsDesc.MinimumSafeSamplesQueued;
			MinimumBufferSamplesCount = controllerHapticsDesc.MinimumBufferSamplesCount;
			OptimalBufferSamplesCount = controllerHapticsDesc.OptimalBufferSamplesCount;
			MaximumBufferSamplesCount = controllerHapticsDesc.MaximumBufferSamplesCount;
		}
	}

	public class OVRHapticsChannel
	{
		private OVRHapticsOutput m_output;

		public OVRHapticsChannel(uint outputIndex)
		{
			m_output = m_outputs[outputIndex];
		}

		public void Preempt(OVRHapticsClip clip)
		{
			m_output.Preempt(clip);
		}

		public void Queue(OVRHapticsClip clip)
		{
			m_output.Queue(clip);
		}

		public void Mix(OVRHapticsClip clip)
		{
			m_output.Mix(clip);
		}

		public void Clear()
		{
			m_output.Clear();
		}
	}

	private class OVRHapticsOutput
	{
		private class ClipPlaybackTracker
		{
			public int ReadCount { get; set; }

			public OVRHapticsClip Clip { get; set; }

			public ClipPlaybackTracker(OVRHapticsClip clip)
			{
				Clip = clip;
			}
		}

		private bool m_lowLatencyMode = true;

		private int m_prevSamplesQueued;

		private float m_prevSamplesQueuedTime;

		private int m_numPredictionHits;

		private int m_numPredictionMisses;

		private int m_numUnderruns;

		private List<ClipPlaybackTracker> m_pendingClips = new List<ClipPlaybackTracker>();

		private uint m_controller;

		private OVRNativeBuffer m_nativeBuffer = new OVRNativeBuffer(Config.MaximumBufferSamplesCount * Config.SampleSizeInBytes);

		private OVRHapticsClip m_paddingClip = new OVRHapticsClip();

		public OVRHapticsOutput(uint controller)
		{
			m_controller = controller;
		}

		public void Process()
		{
			OVRPlugin.HapticsState controllerHapticsState = OVRPlugin.GetControllerHapticsState(m_controller);
			float num = Time.realtimeSinceStartup - m_prevSamplesQueuedTime;
			if (m_prevSamplesQueued > 0)
			{
				int num2 = m_prevSamplesQueued - (int)(num * (float)Config.SampleRateHz + 0.5f);
				if (num2 < 0)
				{
					num2 = 0;
				}
				if (controllerHapticsState.SamplesQueued - num2 == 0)
				{
					m_numPredictionHits++;
				}
				else
				{
					m_numPredictionMisses++;
				}
				if (num2 > 0 && controllerHapticsState.SamplesQueued == 0)
				{
					m_numUnderruns++;
				}
				m_prevSamplesQueued = controllerHapticsState.SamplesQueued;
				m_prevSamplesQueuedTime = Time.realtimeSinceStartup;
			}
			int num3 = Config.OptimalBufferSamplesCount;
			if (m_lowLatencyMode)
			{
				float num4 = 1000f / (float)Config.SampleRateHz;
				float num5 = num * 1000f;
				int num6 = (int)Mathf.Ceil(num5 / num4);
				int num7 = Config.MinimumSafeSamplesQueued + num6;
				if (num7 < num3)
				{
					num3 = num7;
				}
			}
			if (controllerHapticsState.SamplesQueued > num3)
			{
				return;
			}
			if (num3 > Config.MaximumBufferSamplesCount)
			{
				num3 = Config.MaximumBufferSamplesCount;
			}
			if (num3 > controllerHapticsState.SamplesAvailable)
			{
				num3 = controllerHapticsState.SamplesAvailable;
			}
			int num8 = 0;
			int num9 = 0;
			while (num8 < num3 && num9 < m_pendingClips.Count)
			{
				int num10 = num3 - num8;
				int num11 = m_pendingClips[num9].Clip.Count - m_pendingClips[num9].ReadCount;
				if (num10 > num11)
				{
					num10 = num11;
				}
				if (num10 > 0)
				{
					int length = num10 * Config.SampleSizeInBytes;
					int byteOffset = num8 * Config.SampleSizeInBytes;
					int startIndex = m_pendingClips[num9].ReadCount * Config.SampleSizeInBytes;
					Marshal.Copy(m_pendingClips[num9].Clip.Samples, startIndex, m_nativeBuffer.GetPointer(byteOffset), length);
					m_pendingClips[num9].ReadCount += num10;
					num8 += num10;
				}
				num9++;
			}
			int num12 = m_pendingClips.Count - 1;
			while (num12 >= 0 && m_pendingClips.Count > 0)
			{
				if (m_pendingClips[num12].ReadCount >= m_pendingClips[num12].Clip.Count)
				{
					m_pendingClips.RemoveAt(num12);
				}
				num12--;
			}
			int num13 = num3 - (controllerHapticsState.SamplesQueued + num8);
			if (num13 < Config.MinimumBufferSamplesCount - num8)
			{
				num13 = Config.MinimumBufferSamplesCount - num8;
			}
			if (num13 > controllerHapticsState.SamplesAvailable)
			{
				num13 = controllerHapticsState.SamplesAvailable;
			}
			if (num13 > 0)
			{
				int length2 = num13 * Config.SampleSizeInBytes;
				int byteOffset2 = num8 * Config.SampleSizeInBytes;
				int startIndex2 = 0;
				Marshal.Copy(m_paddingClip.Samples, startIndex2, m_nativeBuffer.GetPointer(byteOffset2), length2);
				num8 += num13;
			}
			if (num8 > 0)
			{
				OVRPlugin.HapticsBuffer hapticsBuffer = default(OVRPlugin.HapticsBuffer);
				hapticsBuffer.Samples = m_nativeBuffer.GetPointer();
				hapticsBuffer.SamplesCount = num8;
				OVRPlugin.SetControllerHaptics(m_controller, hapticsBuffer);
				m_prevSamplesQueued = OVRPlugin.GetControllerHapticsState(m_controller).SamplesQueued;
				m_prevSamplesQueuedTime = Time.realtimeSinceStartup;
			}
		}

		public void Preempt(OVRHapticsClip clip)
		{
			m_pendingClips.Clear();
			m_pendingClips.Add(new ClipPlaybackTracker(clip));
		}

		public void Queue(OVRHapticsClip clip)
		{
			m_pendingClips.Add(new ClipPlaybackTracker(clip));
		}

		public void Mix(OVRHapticsClip clip)
		{
			int num = 0;
			int num2 = 0;
			int num3 = clip.Count;
			while (num3 > 0 && num < m_pendingClips.Count)
			{
				int num4 = m_pendingClips[num].Clip.Count - m_pendingClips[num].ReadCount;
				num3 -= num4;
				num2 += num4;
				num++;
			}
			if (num3 > 0)
			{
				num2 += num3;
				num3 = 0;
			}
			if (num > 0)
			{
				OVRHapticsClip oVRHapticsClip = new OVRHapticsClip(num2);
				int i = 0;
				for (int j = 0; j < num; j++)
				{
					OVRHapticsClip clip2 = m_pendingClips[j].Clip;
					for (int k = m_pendingClips[j].ReadCount; k < clip2.Count; k++)
					{
						if (Config.SampleSizeInBytes == 1)
						{
							byte sample = 0;
							if (i < clip.Count && k < clip2.Count)
							{
								sample = (byte)Mathf.Clamp(clip.Samples[i] + clip2.Samples[k], 0, 255);
								i++;
							}
							else if (k < clip2.Count)
							{
								sample = clip2.Samples[k];
							}
							oVRHapticsClip.WriteSample(sample);
						}
					}
				}
				for (; i < clip.Count; i++)
				{
					if (Config.SampleSizeInBytes == 1)
					{
						oVRHapticsClip.WriteSample(clip.Samples[i]);
					}
				}
				m_pendingClips[0] = new ClipPlaybackTracker(oVRHapticsClip);
				for (int l = 1; l < num; l++)
				{
					m_pendingClips.RemoveAt(1);
				}
			}
			else
			{
				m_pendingClips.Add(new ClipPlaybackTracker(clip));
			}
		}

		public void Clear()
		{
			m_pendingClips.Clear();
		}
	}

	public static readonly OVRHapticsChannel[] Channels;

	public static readonly OVRHapticsChannel LeftChannel;

	public static readonly OVRHapticsChannel RightChannel;

	private static readonly OVRHapticsOutput[] m_outputs;

	static OVRHaptics()
	{
		Config.Load();
		m_outputs = new OVRHapticsOutput[2]
		{
			new OVRHapticsOutput(1u),
			new OVRHapticsOutput(2u)
		};
		Channels = new OVRHapticsChannel[2]
		{
			LeftChannel = new OVRHapticsChannel(0u),
			RightChannel = new OVRHapticsChannel(1u)
		};
	}

	public static void Process()
	{
		Config.Load();
		for (int i = 0; i < m_outputs.Length; i++)
		{
			m_outputs[i].Process();
		}
	}
}
public class OVRHapticsClip
{
	public int Count { get; private set; }

	public int Capacity { get; private set; }

	public byte[] Samples { get; private set; }

	public OVRHapticsClip()
	{
		Capacity = OVRHaptics.Config.MaximumBufferSamplesCount;
		Samples = new byte[Capacity * OVRHaptics.Config.SampleSizeInBytes];
	}

	public OVRHapticsClip(int capacity)
	{
		Capacity = ((capacity >= 0) ? capacity : 0);
		Samples = new byte[Capacity * OVRHaptics.Config.SampleSizeInBytes];
	}

	public OVRHapticsClip(byte[] samples, int samplesCount)
	{
		Samples = samples;
		Capacity = Samples.Length / OVRHaptics.Config.SampleSizeInBytes;
		Count = ((samplesCount >= 0) ? samplesCount : 0);
	}

	public OVRHapticsClip(OVRHapticsClip a, OVRHapticsClip b)
	{
		int count = a.Count;
		if (b.Count > count)
		{
			count = b.Count;
		}
		Capacity = count;
		Samples = new byte[Capacity * OVRHaptics.Config.SampleSizeInBytes];
		for (int i = 0; i < a.Count || i < b.Count; i++)
		{
			if (OVRHaptics.Config.SampleSizeInBytes == 1)
			{
				byte sample = 0;
				if (i < a.Count && i < b.Count)
				{
					sample = (byte)Mathf.Clamp(a.Samples[i] + b.Samples[i], 0, 255);
				}
				else if (i < a.Count)
				{
					sample = a.Samples[i];
				}
				else if (i < b.Count)
				{
					sample = b.Samples[i];
				}
				WriteSample(sample);
			}
		}
	}

	public OVRHapticsClip(AudioClip audioClip, int channel = 0)
	{
		float[] array = new float[audioClip.samples * audioClip.channels];
		audioClip.GetData(array, 0);
		InitializeFromAudioFloatTrack(array, audioClip.frequency, audioClip.channels, channel);
	}

	public void WriteSample(byte sample)
	{
		if (Count < Capacity)
		{
			if (OVRHaptics.Config.SampleSizeInBytes == 1)
			{
				Samples[Count * OVRHaptics.Config.SampleSizeInBytes] = sample;
			}
			Count++;
		}
	}

	public void Reset()
	{
		Count = 0;
	}

	private void InitializeFromAudioFloatTrack(float[] sourceData, double sourceFrequency, int sourceChannelCount, int sourceChannel)
	{
		double num = (sourceFrequency + 1E-06) / (double)OVRHaptics.Config.SampleRateHz;
		if (num < 1.0)
		{
			return;
		}
		int num2 = (int)num;
		double num3 = num - (double)num2;
		double num4 = 0.0;
		int num5 = sourceData.Length;
		Count = 0;
		Capacity = num5 / sourceChannelCount / num2 + 1;
		Samples = new byte[Capacity * OVRHaptics.Config.SampleSizeInBytes];
		int num6 = sourceChannel % sourceChannelCount;
		while (num6 < num5)
		{
			if (OVRHaptics.Config.SampleSizeInBytes == 1)
			{
				WriteSample((byte)(Mathf.Clamp01(Mathf.Abs(sourceData[num6])) * 255f));
			}
			num6 += num2 * sourceChannelCount;
			num4 += num3;
			if ((int)num4 > 0)
			{
				num6 += (int)num4 * sourceChannelCount;
				num4 -= (double)(int)num4;
			}
		}
	}
}
public static class OVRInput
{
	[Flags]
	public enum Button
	{
		None = 0,
		One = 1,
		Two = 2,
		Three = 4,
		Four = 8,
		Start = 0x100,
		Back = 0x200,
		PrimaryShoulder = 0x1000,
		PrimaryIndexTrigger = 0x2000,
		PrimaryHandTrigger = 0x4000,
		PrimaryThumbstick = 0x8000,
		PrimaryThumbstickUp = 0x10000,
		PrimaryThumbstickDown = 0x20000,
		PrimaryThumbstickLeft = 0x40000,
		PrimaryThumbstickRight = 0x80000,
		PrimaryTouchpad = 0x400,
		SecondaryShoulder = 0x100000,
		SecondaryIndexTrigger = 0x200000,
		SecondaryHandTrigger = 0x400000,
		SecondaryThumbstick = 0x800000,
		SecondaryThumbstickUp = 0x1000000,
		SecondaryThumbstickDown = 0x2000000,
		SecondaryThumbstickLeft = 0x4000000,
		SecondaryThumbstickRight = 0x8000000,
		SecondaryTouchpad = 0x800,
		DpadUp = 0x10,
		DpadDown = 0x20,
		DpadLeft = 0x40,
		DpadRight = 0x80,
		Up = 0x10000000,
		Down = 0x20000000,
		Left = 0x40000000,
		Right = int.MinValue,
		Any = -1
	}

	[Flags]
	public enum RawButton
	{
		None = 0,
		A = 1,
		B = 2,
		X = 0x100,
		Y = 0x200,
		Start = 0x100000,
		Back = 0x200000,
		LShoulder = 0x800,
		LIndexTrigger = 0x10000000,
		LHandTrigger = 0x20000000,
		LThumbstick = 0x400,
		LThumbstickUp = 0x10,
		LThumbstickDown = 0x20,
		LThumbstickLeft = 0x40,
		LThumbstickRight = 0x80,
		LTouchpad = 0x40000000,
		RShoulder = 8,
		RIndexTrigger = 0x4000000,
		RHandTrigger = 0x8000000,
		RThumbstick = 4,
		RThumbstickUp = 0x1000,
		RThumbstickDown = 0x2000,
		RThumbstickLeft = 0x4000,
		RThumbstickRight = 0x8000,
		RTouchpad = int.MinValue,
		DpadUp = 0x10000,
		DpadDown = 0x20000,
		DpadLeft = 0x40000,
		DpadRight = 0x80000,
		Any = -1
	}

	[Flags]
	public enum Touch
	{
		None = 0,
		One = 1,
		Two = 2,
		Three = 4,
		Four = 8,
		PrimaryIndexTrigger = 0x2000,
		PrimaryThumbstick = 0x8000,
		PrimaryThumbRest = 0x1000,
		PrimaryTouchpad = 0x400,
		SecondaryIndexTrigger = 0x200000,
		SecondaryThumbstick = 0x800000,
		SecondaryThumbRest = 0x100000,
		SecondaryTouchpad = 0x800,
		Any = -1
	}

	[Flags]
	public enum RawTouch
	{
		None = 0,
		A = 1,
		B = 2,
		X = 0x100,
		Y = 0x200,
		LIndexTrigger = 0x1000,
		LThumbstick = 0x400,
		LThumbRest = 0x800,
		LTouchpad = 0x40000000,
		RIndexTrigger = 0x10,
		RThumbstick = 4,
		RThumbRest = 8,
		RTouchpad = int.MinValue,
		Any = -1
	}

	[Flags]
	public enum NearTouch
	{
		None = 0,
		PrimaryIndexTrigger = 1,
		PrimaryThumbButtons = 2,
		SecondaryIndexTrigger = 4,
		SecondaryThumbButtons = 8,
		Any = -1
	}

	[Flags]
	public enum RawNearTouch
	{
		None = 0,
		LIndexTrigger = 1,
		LThumbButtons = 2,
		RIndexTrigger = 4,
		RThumbButtons = 8,
		Any = -1
	}

	[Flags]
	public enum Axis1D
	{
		None = 0,
		PrimaryIndexTrigger = 1,
		PrimaryHandTrigger = 4,
		SecondaryIndexTrigger = 2,
		SecondaryHandTrigger = 8,
		Any = -1
	}

	[Flags]
	public enum RawAxis1D
	{
		None = 0,
		LIndexTrigger = 1,
		LHandTrigger = 4,
		RIndexTrigger = 2,
		RHandTrigger = 8,
		Any = -1
	}

	[Flags]
	public enum Axis2D
	{
		None = 0,
		PrimaryThumbstick = 1,
		PrimaryTouchpad = 4,
		SecondaryThumbstick = 2,
		SecondaryTouchpad = 8,
		Any = -1
	}

	[Flags]
	public enum RawAxis2D
	{
		None = 0,
		LThumbstick = 1,
		LTouchpad = 4,
		RThumbstick = 2,
		RTouchpad = 8,
		Any = -1
	}

	[Flags]
	public enum Controller
	{
		None = 0,
		LTouch = 1,
		RTouch = 2,
		Touch = 3,
		Remote = 4,
		Gamepad = 0x10,
		Touchpad = 0x8000000,
		LTrackedRemote = 0x1000000,
		RTrackedRemote = 0x2000000,
		Active = int.MinValue,
		All = -1
	}

	private abstract class OVRControllerBase
	{
		public class VirtualButtonMap
		{
			public RawButton None;

			public RawButton One;

			public RawButton Two;

			public RawButton Three;

			public RawButton Four;

			public RawButton Start;

			public RawButton Back;

			public RawButton PrimaryShoulder;

			public RawButton PrimaryIndexTrigger;

			public RawButton PrimaryHandTrigger;

			public RawButton PrimaryThumbstick;

			public RawButton PrimaryThumbstickUp;

			public RawButton PrimaryThumbstickDown;

			public RawButton PrimaryThumbstickLeft;

			public RawButton PrimaryThumbstickRight;

			public RawButton PrimaryTouchpad;

			public RawButton SecondaryShoulder;

			public RawButton SecondaryIndexTrigger;

			public RawButton SecondaryHandTrigger;

			public RawButton SecondaryThumbstick;

			public RawButton SecondaryThumbstickUp;

			public RawButton SecondaryThumbstickDown;

			public RawButton SecondaryThumbstickLeft;

			public RawButton SecondaryThumbstickRight;

			public RawButton SecondaryTouchpad;

			public RawButton DpadUp;

			public RawButton DpadDown;

			public RawButton DpadLeft;

			public RawButton DpadRight;

			public RawButton Up;

			public RawButton Down;

			public RawButton Left;

			public RawButton Right;

			public RawButton ToRawMask(Button virtualMask)
			{
				RawButton rawButton = RawButton.None;
				if (virtualMask == Button.None)
				{
					return RawButton.None;
				}
				if ((virtualMask & Button.One) != 0)
				{
					rawButton |= One;
				}
				if ((virtualMask & Button.Two) != 0)
				{
					rawButton |= Two;
				}
				if ((virtualMask & Button.Three) != 0)
				{
					rawButton |= Three;
				}
				if ((virtualMask & Button.Four) != 0)
				{
					rawButton |= Four;
				}
				if ((virtualMask & Button.Start) != 0)
				{
					rawButton |= Start;
				}
				if ((virtualMask & Button.Back) != 0)
				{
					rawButton |= Back;
				}
				if ((virtualMask & Button.PrimaryShoulder) != 0)
				{
					rawButton |= PrimaryShoulder;
				}
				if ((virtualMask & Button.PrimaryIndexTrigger) != 0)
				{
					rawButton |= PrimaryIndexTrigger;
				}
				if ((virtualMask & Button.PrimaryHandTrigger) != 0)
				{
					rawButton |= PrimaryHandTrigger;
				}
				if ((virtualMask & Button.PrimaryThumbstick) != 0)
				{
					rawButton |= PrimaryThumbstick;
				}
				if ((virtualMask & Button.PrimaryThumbstickUp) != 0)
				{
					rawButton |= PrimaryThumbstickUp;
				}
				if ((virtualMask & Button.PrimaryThumbstickDown) != 0)
				{
					rawButton |= PrimaryThumbstickDown;
				}
				if ((virtualMask & Button.PrimaryThumbstickLeft) != 0)
				{
					rawButton |= PrimaryThumbstickLeft;
				}
				if ((virtualMask & Button.PrimaryThumbstickRight) != 0)
				{
					rawButton |= PrimaryThumbstickRight;
				}
				if ((virtualMask & Button.PrimaryTouchpad) != 0)
				{
					rawButton |= PrimaryTouchpad;
				}
				if ((virtualMask & Button.SecondaryShoulder) != 0)
				{
					rawButton |= SecondaryShoulder;
				}
				if ((virtualMask & Button.SecondaryIndexTrigger) != 0)
				{
					rawButton |= SecondaryIndexTrigger;
				}
				if ((virtualMask & Button.SecondaryHandTrigger) != 0)
				{
					rawButton |= SecondaryHandTrigger;
				}
				if ((virtualMask & Button.SecondaryThumbstick) != 0)
				{
					rawButton |= SecondaryThumbstick;
				}
				if ((virtualMask & Button.SecondaryThumbstickUp) != 0)
				{
					rawButton |= SecondaryThumbstickUp;
				}
				if ((virtualMask & Button.SecondaryThumbstickDown) != 0)
				{
					rawButton |= SecondaryThumbstickDown;
				}
				if ((virtualMask & Button.SecondaryThumbstickLeft) != 0)
				{
					rawButton |= SecondaryThumbstickLeft;
				}
				if ((virtualMask & Button.SecondaryThumbstickRight) != 0)
				{
					rawButton |= SecondaryThumbstickRight;
				}
				if ((virtualMask & Button.SecondaryTouchpad) != 0)
				{
					rawButton |= SecondaryTouchpad;
				}
				if ((virtualMask & Button.DpadUp) != 0)
				{
					rawButton |= DpadUp;
				}
				if ((virtualMask & Button.DpadDown) != 0)
				{
					rawButton |= DpadDown;
				}
				if ((virtualMask & Button.DpadLeft) != 0)
				{
					rawButton |= DpadLeft;
				}
				if ((virtualMask & Button.DpadRight) != 0)
				{
					rawButton |= DpadRight;
				}
				if ((virtualMask & Button.Up) != 0)
				{
					rawButton |= Up;
				}
				if ((virtualMask & Button.Down) != 0)
				{
					rawButton |= Down;
				}
				if ((virtualMask & Button.Left) != 0)
				{
					rawButton |= Left;
				}
				if (((uint)virtualMask & 0x80000000u) != 0)
				{
					rawButton |= Right;
				}
				return rawButton;
			}
		}

		public class VirtualTouchMap
		{
			public RawTouch None;

			public RawTouch One;

			public RawTouch Two;

			public RawTouch Three;

			public RawTouch Four;

			public RawTouch PrimaryIndexTrigger;

			public RawTouch PrimaryThumbstick;

			public RawTouch PrimaryThumbRest;

			public RawTouch PrimaryTouchpad;

			public RawTouch SecondaryIndexTrigger;

			public RawTouch SecondaryThumbstick;

			public RawTouch SecondaryThumbRest;

			public RawTouch SecondaryTouchpad;

			public RawTouch ToRawMask(Touch virtualMask)
			{
				RawTouch rawTouch = RawTouch.None;
				if (virtualMask == Touch.None)
				{
					return RawTouch.None;
				}
				if ((virtualMask & Touch.One) != 0)
				{
					rawTouch |= One;
				}
				if ((virtualMask & Touch.Two) != 0)
				{
					rawTouch |= Two;
				}
				if ((virtualMask & Touch.Three) != 0)
				{
					rawTouch |= Three;
				}
				if ((virtualMask & Touch.Four) != 0)
				{
					rawTouch |= Four;
				}
				if ((virtualMask & Touch.PrimaryIndexTrigger) != 0)
				{
					rawTouch |= PrimaryIndexTrigger;
				}
				if ((virtualMask & Touch.PrimaryThumbstick) != 0)
				{
					rawTouch |= PrimaryThumbstick;
				}
				if ((virtualMask & Touch.PrimaryThumbRest) != 0)
				{
					rawTouch |= PrimaryThumbRest;
				}
				if ((virtualMask & Touch.PrimaryTouchpad) != 0)
				{
					rawTouch |= PrimaryTouchpad;
				}
				if ((virtualMask & Touch.SecondaryIndexTrigger) != 0)
				{
					rawTouch |= SecondaryIndexTrigger;
				}
				if ((virtualMask & Touch.SecondaryThumbstick) != 0)
				{
					rawTouch |= SecondaryThumbstick;
				}
				if ((virtualMask & Touch.SecondaryThumbRest) != 0)
				{
					rawTouch |= SecondaryThumbRest;
				}
				if ((virtualMask & Touch.SecondaryTouchpad) != 0)
				{
					rawTouch |= SecondaryTouchpad;
				}
				return rawTouch;
			}
		}

		public class VirtualNearTouchMap
		{
			public RawNearTouch None;

			public RawNearTouch PrimaryIndexTrigger;

			public RawNearTouch PrimaryThumbButtons;

			public RawNearTouch SecondaryIndexTrigger;

			public RawNearTouch SecondaryThumbButtons;

			public RawNearTouch ToRawMask(NearTouch virtualMask)
			{
				RawNearTouch rawNearTouch = RawNearTouch.None;
				if (virtualMask == NearTouch.None)
				{
					return RawNearTouch.None;
				}
				if ((virtualMask & NearTouch.PrimaryIndexTrigger) != 0)
				{
					rawNearTouch |= PrimaryIndexTrigger;
				}
				if ((virtualMask & NearTouch.PrimaryThumbButtons) != 0)
				{
					rawNearTouch |= PrimaryThumbButtons;
				}
				if ((virtualMask & NearTouch.SecondaryIndexTrigger) != 0)
				{
					rawNearTouch |= SecondaryIndexTrigger;
				}
				if ((virtualMask & NearTouch.SecondaryThumbButtons) != 0)
				{
					rawNearTouch |= SecondaryThumbButtons;
				}
				return rawNearTouch;
			}
		}

		public class VirtualAxis1DMap
		{
			public RawAxis1D None;

			public RawAxis1D PrimaryIndexTrigger;

			public RawAxis1D PrimaryHandTrigger;

			public RawAxis1D SecondaryIndexTrigger;

			public RawAxis1D SecondaryHandTrigger;

			public RawAxis1D ToRawMask(Axis1D virtualMask)
			{
				RawAxis1D rawAxis1D = RawAxis1D.None;
				if (virtualMask == Axis1D.None)
				{
					return RawAxis1D.None;
				}
				if ((virtualMask & Axis1D.PrimaryIndexTrigger) != 0)
				{
					rawAxis1D |= PrimaryIndexTrigger;
				}
				if ((virtualMask & Axis1D.PrimaryHandTrigger) != 0)
				{
					rawAxis1D |= PrimaryHandTrigger;
				}
				if ((virtualMask & Axis1D.SecondaryIndexTrigger) != 0)
				{
					rawAxis1D |= SecondaryIndexTrigger;
				}
				if ((virtualMask & Axis1D.SecondaryHandTrigger) != 0)
				{
					rawAxis1D |= SecondaryHandTrigger;
				}
				return rawAxis1D;
			}
		}

		public class VirtualAxis2DMap
		{
			public RawAxis2D None;

			public RawAxis2D PrimaryThumbstick;

			public RawAxis2D PrimaryTouchpad;

			public RawAxis2D SecondaryThumbstick;

			public RawAxis2D SecondaryTouchpad;

			public RawAxis2D ToRawMask(Axis2D virtualMask)
			{
				RawAxis2D rawAxis2D = RawAxis2D.None;
				if (virtualMask == Axis2D.None)
				{
					return RawAxis2D.None;
				}
				if ((virtualMask & Axis2D.PrimaryThumbstick) != 0)
				{
					rawAxis2D |= PrimaryThumbstick;
				}
				if ((virtualMask & Axis2D.PrimaryTouchpad) != 0)
				{
					rawAxis2D |= PrimaryTouchpad;
				}
				if ((virtualMask & Axis2D.SecondaryThumbstick) != 0)
				{
					rawAxis2D |= SecondaryThumbstick;
				}
				if ((virtualMask & Axis2D.SecondaryTouchpad) != 0)
				{
					rawAxis2D |= SecondaryTouchpad;
				}
				return rawAxis2D;
			}
		}

		public Controller controllerType;

		public VirtualButtonMap buttonMap = new VirtualButtonMap();

		public VirtualTouchMap touchMap = new VirtualTouchMap();

		public VirtualNearTouchMap nearTouchMap = new VirtualNearTouchMap();

		public VirtualAxis1DMap axis1DMap = new VirtualAxis1DMap();

		public VirtualAxis2DMap axis2DMap = new VirtualAxis2DMap();

		public OVRPlugin.ControllerState2 previousState = default(OVRPlugin.ControllerState2);

		public OVRPlugin.ControllerState2 currentState = default(OVRPlugin.ControllerState2);

		public bool shouldApplyDeadzone = true;

		public OVRControllerBase()
		{
			ConfigureButtonMap();
			ConfigureTouchMap();
			ConfigureNearTouchMap();
			ConfigureAxis1DMap();
			ConfigureAxis2DMap();
		}

		public virtual Controller Update()
		{
			OVRPlugin.ControllerState2 controllerState = OVRPlugin.GetControllerState2((uint)controllerType);
			if (controllerState.LIndexTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 268435456u;
			}
			if (controllerState.LHandTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 536870912u;
			}
			if (controllerState.LThumbstick.y >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 16u;
			}
			if (controllerState.LThumbstick.y <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 32u;
			}
			if (controllerState.LThumbstick.x <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 64u;
			}
			if (controllerState.LThumbstick.x >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 128u;
			}
			if (controllerState.RIndexTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 67108864u;
			}
			if (controllerState.RHandTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 134217728u;
			}
			if (controllerState.RThumbstick.y >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 4096u;
			}
			if (controllerState.RThumbstick.y <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 8192u;
			}
			if (controllerState.RThumbstick.x <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 16384u;
			}
			if (controllerState.RThumbstick.x >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 32768u;
			}
			previousState = currentState;
			currentState = controllerState;
			return (Controller)((int)currentState.ConnectedControllers & (int)controllerType);
		}

		public virtual void SetControllerVibration(float frequency, float amplitude)
		{
			OVRPlugin.SetControllerVibration((uint)controllerType, frequency, amplitude);
		}

		public abstract void ConfigureButtonMap();

		public abstract void ConfigureTouchMap();

		public abstract void ConfigureNearTouchMap();

		public abstract void ConfigureAxis1DMap();

		public abstract void ConfigureAxis2DMap();

		public RawButton ResolveToRawMask(Button virtualMask)
		{
			return buttonMap.ToRawMask(virtualMask);
		}

		public RawTouch ResolveToRawMask(Touch virtualMask)
		{
			return touchMap.ToRawMask(virtualMask);
		}

		public RawNearTouch ResolveToRawMask(NearTouch virtualMask)
		{
			return nearTouchMap.ToRawMask(virtualMask);
		}

		public RawAxis1D ResolveToRawMask(Axis1D virtualMask)
		{
			return axis1DMap.ToRawMask(virtualMask);
		}

		public RawAxis2D ResolveToRawMask(Axis2D virtualMask)
		{
			return axis2DMap.ToRawMask(virtualMask);
		}
	}

	private class OVRControllerTouch : OVRControllerBase
	{
		public OVRControllerTouch()
		{
			controllerType = Controller.Touch;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.A;
			buttonMap.Two = RawButton.B;
			buttonMap.Three = RawButton.X;
			buttonMap.Four = RawButton.Y;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.None;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.LHandTrigger;
			buttonMap.PrimaryThumbstick = RawButton.LThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.LThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.LThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.LThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.LThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.SecondaryHandTrigger = RawButton.RHandTrigger;
			buttonMap.SecondaryThumbstick = RawButton.RThumbstick;
			buttonMap.SecondaryThumbstickUp = RawButton.RThumbstickUp;
			buttonMap.SecondaryThumbstickDown = RawButton.RThumbstickDown;
			buttonMap.SecondaryThumbstickLeft = RawButton.RThumbstickLeft;
			buttonMap.SecondaryThumbstickRight = RawButton.RThumbstickRight;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.None;
			buttonMap.DpadDown = RawButton.None;
			buttonMap.DpadLeft = RawButton.None;
			buttonMap.DpadRight = RawButton.None;
			buttonMap.Up = RawButton.LThumbstickUp;
			buttonMap.Down = RawButton.LThumbstickDown;
			buttonMap.Left = RawButton.LThumbstickLeft;
			buttonMap.Right = RawButton.LThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.A;
			touchMap.Two = RawTouch.B;
			touchMap.Three = RawTouch.X;
			touchMap.Four = RawTouch.Y;
			touchMap.PrimaryIndexTrigger = RawTouch.LIndexTrigger;
			touchMap.PrimaryThumbstick = RawTouch.LThumbstick;
			touchMap.PrimaryThumbRest = RawTouch.LThumbRest;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.RIndexTrigger;
			touchMap.SecondaryThumbstick = RawTouch.RThumbstick;
			touchMap.SecondaryThumbRest = RawTouch.RThumbRest;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.LIndexTrigger;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.LThumbButtons;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.RIndexTrigger;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.RThumbButtons;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.LHandTrigger;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.RHandTrigger;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.LThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.RThumbstick;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerLTouch : OVRControllerBase
	{
		public OVRControllerLTouch()
		{
			controllerType = Controller.LTouch;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.X;
			buttonMap.Two = RawButton.Y;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.None;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.LHandTrigger;
			buttonMap.PrimaryThumbstick = RawButton.LThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.LThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.LThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.LThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.LThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.None;
			buttonMap.DpadDown = RawButton.None;
			buttonMap.DpadLeft = RawButton.None;
			buttonMap.DpadRight = RawButton.None;
			buttonMap.Up = RawButton.LThumbstickUp;
			buttonMap.Down = RawButton.LThumbstickDown;
			buttonMap.Left = RawButton.LThumbstickLeft;
			buttonMap.Right = RawButton.LThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.X;
			touchMap.Two = RawTouch.Y;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.LIndexTrigger;
			touchMap.PrimaryThumbstick = RawTouch.LThumbstick;
			touchMap.PrimaryThumbRest = RawTouch.LThumbRest;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.LIndexTrigger;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.LThumbButtons;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.LHandTrigger;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.LThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerRTouch : OVRControllerBase
	{
		public OVRControllerRTouch()
		{
			controllerType = Controller.RTouch;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.A;
			buttonMap.Two = RawButton.B;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.None;
			buttonMap.Back = RawButton.None;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.RHandTrigger;
			buttonMap.PrimaryThumbstick = RawButton.RThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.RThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.RThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.RThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.RThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.None;
			buttonMap.DpadDown = RawButton.None;
			buttonMap.DpadLeft = RawButton.None;
			buttonMap.DpadRight = RawButton.None;
			buttonMap.Up = RawButton.RThumbstickUp;
			buttonMap.Down = RawButton.RThumbstickDown;
			buttonMap.Left = RawButton.RThumbstickLeft;
			buttonMap.Right = RawButton.RThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.A;
			touchMap.Two = RawTouch.B;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.RIndexTrigger;
			touchMap.PrimaryThumbstick = RawTouch.RThumbstick;
			touchMap.PrimaryThumbRest = RawTouch.RThumbRest;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.RIndexTrigger;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.RThumbButtons;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.RHandTrigger;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.RThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerRemote : OVRControllerBase
	{
		public OVRControllerRemote()
		{
			controllerType = Controller.Remote;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.Start;
			buttonMap.Two = RawButton.Back;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.None;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.None;
			buttonMap.PrimaryThumbstickUp = RawButton.None;
			buttonMap.PrimaryThumbstickDown = RawButton.None;
			buttonMap.PrimaryThumbstickLeft = RawButton.None;
			buttonMap.PrimaryThumbstickRight = RawButton.None;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.DpadUp;
			buttonMap.Down = RawButton.DpadDown;
			buttonMap.Left = RawButton.DpadLeft;
			buttonMap.Right = RawButton.DpadRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.None;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.None;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerGamepadPC : OVRControllerBase
	{
		public OVRControllerGamepadPC()
		{
			controllerType = Controller.Gamepad;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.A;
			buttonMap.Two = RawButton.B;
			buttonMap.Three = RawButton.X;
			buttonMap.Four = RawButton.Y;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.LShoulder;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.LThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.LThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.LThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.LThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.LThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.RShoulder;
			buttonMap.SecondaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.RThumbstick;
			buttonMap.SecondaryThumbstickUp = RawButton.RThumbstickUp;
			buttonMap.SecondaryThumbstickDown = RawButton.RThumbstickDown;
			buttonMap.SecondaryThumbstickLeft = RawButton.RThumbstickLeft;
			buttonMap.SecondaryThumbstickRight = RawButton.RThumbstickRight;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.LThumbstickUp;
			buttonMap.Down = RawButton.LThumbstickDown;
			buttonMap.Left = RawButton.LThumbstickLeft;
			buttonMap.Right = RawButton.LThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.LThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.RThumbstick;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerGamepadMac : OVRControllerBase
	{
		private enum AxisGPC
		{
			None = -1,
			LeftXAxis,
			LeftYAxis,
			RightXAxis,
			RightYAxis,
			LeftTrigger,
			RightTrigger,
			DPad_X_Axis,
			DPad_Y_Axis,
			Max
		}

		public enum ButtonGPC
		{
			None = -1,
			A,
			B,
			X,
			Y,
			Up,
			Down,
			Left,
			Right,
			Start,
			Back,
			LStick,
			RStick,
			LeftShoulder,
			RightShoulder,
			Max
		}

		private bool initialized;

		private const string DllName = "OVRGamepad";

		public OVRControllerGamepadMac()
		{
			controllerType = Controller.Gamepad;
			initialized = OVR_GamepadController_Initialize();
		}

		~OVRControllerGamepadMac()
		{
			if (initialized)
			{
				OVR_GamepadController_Destroy();
			}
		}

		public override Controller Update()
		{
			if (!initialized)
			{
				return Controller.None;
			}
			OVRPlugin.ControllerState2 controllerState = default(OVRPlugin.ControllerState2);
			if (OVR_GamepadController_Update())
			{
				controllerState.ConnectedControllers = 16u;
			}
			if (OVR_GamepadController_GetButton(0))
			{
				controllerState.Buttons |= 1u;
			}
			if (OVR_GamepadController_GetButton(1))
			{
				controllerState.Buttons |= 2u;
			}
			if (OVR_GamepadController_GetButton(2))
			{
				controllerState.Buttons |= 256u;
			}
			if (OVR_GamepadController_GetButton(3))
			{
				controllerState.Buttons |= 512u;
			}
			if (OVR_GamepadController_GetButton(4))
			{
				controllerState.Buttons |= 65536u;
			}
			if (OVR_GamepadController_GetButton(5))
			{
				controllerState.Buttons |= 131072u;
			}
			if (OVR_GamepadController_GetButton(6))
			{
				controllerState.Buttons |= 262144u;
			}
			if (OVR_GamepadController_GetButton(7))
			{
				controllerState.Buttons |= 524288u;
			}
			if (OVR_GamepadController_GetButton(8))
			{
				controllerState.Buttons |= 1048576u;
			}
			if (OVR_GamepadController_GetButton(9))
			{
				controllerState.Buttons |= 2097152u;
			}
			if (OVR_GamepadController_GetButton(10))
			{
				controllerState.Buttons |= 1024u;
			}
			if (OVR_GamepadController_GetButton(11))
			{
				controllerState.Buttons |= 4u;
			}
			if (OVR_GamepadController_GetButton(12))
			{
				controllerState.Buttons |= 2048u;
			}
			if (OVR_GamepadController_GetButton(13))
			{
				controllerState.Buttons |= 8u;
			}
			controllerState.LThumbstick.x = OVR_GamepadController_GetAxis(0);
			controllerState.LThumbstick.y = OVR_GamepadController_GetAxis(1);
			controllerState.RThumbstick.x = OVR_GamepadController_GetAxis(2);
			controllerState.RThumbstick.y = OVR_GamepadController_GetAxis(3);
			controllerState.LIndexTrigger = OVR_GamepadController_GetAxis(4);
			controllerState.RIndexTrigger = OVR_GamepadController_GetAxis(5);
			if (controllerState.LIndexTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 268435456u;
			}
			if (controllerState.LHandTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 536870912u;
			}
			if (controllerState.LThumbstick.y >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 16u;
			}
			if (controllerState.LThumbstick.y <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 32u;
			}
			if (controllerState.LThumbstick.x <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 64u;
			}
			if (controllerState.LThumbstick.x >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 128u;
			}
			if (controllerState.RIndexTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 67108864u;
			}
			if (controllerState.RHandTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 134217728u;
			}
			if (controllerState.RThumbstick.y >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 4096u;
			}
			if (controllerState.RThumbstick.y <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 8192u;
			}
			if (controllerState.RThumbstick.x <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 16384u;
			}
			if (controllerState.RThumbstick.x >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 32768u;
			}
			previousState = currentState;
			currentState = controllerState;
			return (Controller)((int)currentState.ConnectedControllers & (int)controllerType);
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.A;
			buttonMap.Two = RawButton.B;
			buttonMap.Three = RawButton.X;
			buttonMap.Four = RawButton.Y;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.LShoulder;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.LThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.LThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.LThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.LThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.LThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.RShoulder;
			buttonMap.SecondaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.RThumbstick;
			buttonMap.SecondaryThumbstickUp = RawButton.RThumbstickUp;
			buttonMap.SecondaryThumbstickDown = RawButton.RThumbstickDown;
			buttonMap.SecondaryThumbstickLeft = RawButton.RThumbstickLeft;
			buttonMap.SecondaryThumbstickRight = RawButton.RThumbstickRight;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.LThumbstickUp;
			buttonMap.Down = RawButton.LThumbstickDown;
			buttonMap.Left = RawButton.LThumbstickLeft;
			buttonMap.Right = RawButton.LThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.LThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.RThumbstick;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}

		public override void SetControllerVibration(float frequency, float amplitude)
		{
			int node = 0;
			float frequency2 = frequency * 200f;
			OVR_GamepadController_SetVibration(node, amplitude, frequency2);
		}

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool OVR_GamepadController_Initialize();

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool OVR_GamepadController_Destroy();

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool OVR_GamepadController_Update();

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern float OVR_GamepadController_GetAxis(int axis);

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool OVR_GamepadController_GetButton(int button);

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool OVR_GamepadController_SetVibration(int node, float strength, float frequency);
	}

	private class OVRControllerGamepadAndroid : OVRControllerBase
	{
		private static class AndroidButtonNames
		{
			public static readonly KeyCode A = KeyCode.JoystickButton0;

			public static readonly KeyCode B = KeyCode.JoystickButton1;

			public static readonly KeyCode X = KeyCode.JoystickButton2;

			public static readonly KeyCode Y = KeyCode.JoystickButton3;

			public static readonly KeyCode Start = KeyCode.JoystickButton10;

			public static readonly KeyCode Back = KeyCode.JoystickButton11;

			public static readonly KeyCode LThumbstick = KeyCode.JoystickButton8;

			public static readonly KeyCode RThumbstick = KeyCode.JoystickButton9;

			public static readonly KeyCode LShoulder = KeyCode.JoystickButton4;

			public static readonly KeyCode RShoulder = KeyCode.JoystickButton5;
		}

		private static class AndroidAxisNames
		{
			public static readonly string LThumbstickX = "Oculus_GearVR_LThumbstickX";

			public static readonly string LThumbstickY = "Oculus_GearVR_LThumbstickY";

			public static readonly string RThumbstickX = "Oculus_GearVR_RThumbstickX";

			public static readonly string RThumbstickY = "Oculus_GearVR_RThumbstickY";

			public static readonly string LIndexTrigger = "Oculus_GearVR_LIndexTrigger";

			public static readonly string RIndexTrigger = "Oculus_GearVR_RIndexTrigger";

			public static readonly string DpadX = "Oculus_GearVR_DpadX";

			public static readonly string DpadY = "Oculus_GearVR_DpadY";
		}

		private bool joystickDetected;

		private float joystickCheckInterval = 1f;

		private float joystickCheckTime;

		public OVRControllerGamepadAndroid()
		{
			controllerType = Controller.Gamepad;
		}

		private bool ShouldUpdate()
		{
			if (Time.realtimeSinceStartup - joystickCheckTime > joystickCheckInterval)
			{
				joystickCheckTime = Time.realtimeSinceStartup;
				joystickDetected = false;
				string[] joystickNames = Input.GetJoystickNames();
				for (int i = 0; i < joystickNames.Length; i++)
				{
					if (joystickNames[i] != string.Empty)
					{
						joystickDetected = true;
						break;
					}
				}
			}
			return joystickDetected;
		}

		public override Controller Update()
		{
			if (!ShouldUpdate())
			{
				return Controller.None;
			}
			OVRPlugin.ControllerState2 controllerState = default(OVRPlugin.ControllerState2);
			controllerState.ConnectedControllers = 16u;
			if (Input.GetKey(AndroidButtonNames.A))
			{
				controllerState.Buttons |= 1u;
			}
			if (Input.GetKey(AndroidButtonNames.B))
			{
				controllerState.Buttons |= 2u;
			}
			if (Input.GetKey(AndroidButtonNames.X))
			{
				controllerState.Buttons |= 256u;
			}
			if (Input.GetKey(AndroidButtonNames.Y))
			{
				controllerState.Buttons |= 512u;
			}
			if (Input.GetKey(AndroidButtonNames.Start))
			{
				controllerState.Buttons |= 1048576u;
			}
			if (Input.GetKey(AndroidButtonNames.Back) || Input.GetKey(KeyCode.Escape))
			{
				controllerState.Buttons |= 2097152u;
			}
			if (Input.GetKey(AndroidButtonNames.LThumbstick))
			{
				controllerState.Buttons |= 1024u;
			}
			if (Input.GetKey(AndroidButtonNames.RThumbstick))
			{
				controllerState.Buttons |= 4u;
			}
			if (Input.GetKey(AndroidButtonNames.LShoulder))
			{
				controllerState.Buttons |= 2048u;
			}
			if (Input.GetKey(AndroidButtonNames.RShoulder))
			{
				controllerState.Buttons |= 8u;
			}
			controllerState.LThumbstick.x = Input.GetAxisRaw(AndroidAxisNames.LThumbstickX);
			controllerState.LThumbstick.y = Input.GetAxisRaw(AndroidAxisNames.LThumbstickY);
			controllerState.RThumbstick.x = Input.GetAxisRaw(AndroidAxisNames.RThumbstickX);
			controllerState.RThumbstick.y = Input.GetAxisRaw(AndroidAxisNames.RThumbstickY);
			controllerState.LIndexTrigger = Input.GetAxisRaw(AndroidAxisNames.LIndexTrigger);
			controllerState.RIndexTrigger = Input.GetAxisRaw(AndroidAxisNames.RIndexTrigger);
			if (controllerState.LIndexTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 268435456u;
			}
			if (controllerState.LHandTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 536870912u;
			}
			if (controllerState.LThumbstick.y >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 16u;
			}
			if (controllerState.LThumbstick.y <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 32u;
			}
			if (controllerState.LThumbstick.x <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 64u;
			}
			if (controllerState.LThumbstick.x >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 128u;
			}
			if (controllerState.RIndexTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 67108864u;
			}
			if (controllerState.RHandTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 134217728u;
			}
			if (controllerState.RThumbstick.y >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 4096u;
			}
			if (controllerState.RThumbstick.y <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 8192u;
			}
			if (controllerState.RThumbstick.x <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 16384u;
			}
			if (controllerState.RThumbstick.x >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 32768u;
			}
			float axisRaw = Input.GetAxisRaw(AndroidAxisNames.DpadX);
			float axisRaw2 = Input.GetAxisRaw(AndroidAxisNames.DpadY);
			if (axisRaw <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 262144u;
			}
			if (axisRaw >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 524288u;
			}
			if (axisRaw2 <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 131072u;
			}
			if (axisRaw2 >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 65536u;
			}
			previousState = currentState;
			currentState = controllerState;
			return (Controller)((int)currentState.ConnectedControllers & (int)controllerType);
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.A;
			buttonMap.Two = RawButton.B;
			buttonMap.Three = RawButton.X;
			buttonMap.Four = RawButton.Y;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.LShoulder;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.LThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.LThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.LThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.LThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.LThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.RShoulder;
			buttonMap.SecondaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.RThumbstick;
			buttonMap.SecondaryThumbstickUp = RawButton.RThumbstickUp;
			buttonMap.SecondaryThumbstickDown = RawButton.RThumbstickDown;
			buttonMap.SecondaryThumbstickLeft = RawButton.RThumbstickLeft;
			buttonMap.SecondaryThumbstickRight = RawButton.RThumbstickRight;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.LThumbstickUp;
			buttonMap.Down = RawButton.LThumbstickDown;
			buttonMap.Left = RawButton.LThumbstickLeft;
			buttonMap.Right = RawButton.LThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.LThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.RThumbstick;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}

		public override void SetControllerVibration(float frequency, float amplitude)
		{
		}
	}

	private class OVRControllerTouchpad : OVRControllerBase
	{
		private OVRPlugin.Vector2f moveAmount;

		private float maxTapMagnitude = 0.1f;

		private float minMoveMagnitude = 0.15f;

		public OVRControllerTouchpad()
		{
			controllerType = Controller.Touchpad;
		}

		public override Controller Update()
		{
			Controller result = base.Update();
			if (GetDown(RawTouch.LTouchpad, Controller.Touchpad))
			{
				moveAmount = currentState.LTouchpad;
			}
			if (GetUp(RawTouch.LTouchpad, Controller.Touchpad))
			{
				moveAmount.x = previousState.LTouchpad.x - moveAmount.x;
				moveAmount.y = previousState.LTouchpad.y - moveAmount.y;
				Vector2 vector = new Vector2(moveAmount.x, moveAmount.y);
				float magnitude = vector.magnitude;
				if (magnitude < maxTapMagnitude)
				{
					currentState.Buttons |= 1048576u;
					currentState.Buttons |= 1073741824u;
				}
				else if (magnitude >= minMoveMagnitude)
				{
					vector.Normalize();
					if (Mathf.Abs(vector.x) > Mathf.Abs(vector.y))
					{
						if (vector.x < 0f)
						{
							currentState.Buttons |= 262144u;
						}
						else
						{
							currentState.Buttons |= 524288u;
						}
					}
					else if (vector.y < 0f)
					{
						currentState.Buttons |= 131072u;
					}
					else
					{
						currentState.Buttons |= 65536u;
					}
				}
			}
			return result;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.Start;
			buttonMap.Two = RawButton.Back;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.None;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.None;
			buttonMap.PrimaryThumbstickUp = RawButton.None;
			buttonMap.PrimaryThumbstickDown = RawButton.None;
			buttonMap.PrimaryThumbstickLeft = RawButton.None;
			buttonMap.PrimaryThumbstickRight = RawButton.None;
			buttonMap.PrimaryTouchpad = RawButton.Start;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.DpadUp;
			buttonMap.Down = RawButton.DpadDown;
			buttonMap.Left = RawButton.DpadLeft;
			buttonMap.Right = RawButton.DpadRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.LTouchpad;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.None;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.None;
			axis2DMap.PrimaryTouchpad = RawAxis2D.LTouchpad;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerLTrackedRemote : OVRControllerBase
	{
		private bool emitSwipe;

		private OVRPlugin.Vector2f moveAmount;

		private float minMoveMagnitude = 0.3f;

		public OVRControllerLTrackedRemote()
		{
			controllerType = Controller.LTrackedRemote;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.LTouchpad;
			buttonMap.Two = RawButton.Back;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.None;
			buttonMap.PrimaryThumbstickUp = RawButton.None;
			buttonMap.PrimaryThumbstickDown = RawButton.None;
			buttonMap.PrimaryThumbstickLeft = RawButton.None;
			buttonMap.PrimaryThumbstickRight = RawButton.None;
			buttonMap.PrimaryTouchpad = RawButton.LTouchpad;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.DpadUp;
			buttonMap.Down = RawButton.DpadDown;
			buttonMap.Left = RawButton.DpadLeft;
			buttonMap.Right = RawButton.DpadRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.LTouchpad;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.None;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.None;
			axis2DMap.PrimaryTouchpad = RawAxis2D.LTouchpad;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}

		public override Controller Update()
		{
			Controller result = base.Update();
			if (GetDown(RawTouch.LTouchpad, Controller.LTrackedRemote))
			{
				emitSwipe = true;
				moveAmount = currentState.LTouchpad;
			}
			if (GetDown(RawButton.LTouchpad, Controller.LTrackedRemote))
			{
				emitSwipe = false;
			}
			if (GetUp(RawTouch.LTouchpad, Controller.LTrackedRemote) && emitSwipe)
			{
				emitSwipe = false;
				moveAmount.x = previousState.LTouchpad.x - moveAmount.x;
				moveAmount.y = previousState.LTouchpad.y - moveAmount.y;
				Vector2 vector = new Vector2(moveAmount.x, moveAmount.y);
				if (vector.magnitude >= minMoveMagnitude)
				{
					vector.Normalize();
					if (Mathf.Abs(vector.x) > Mathf.Abs(vector.y))
					{
						if (vector.x < 0f)
						{
							currentState.Buttons |= 262144u;
						}
						else
						{
							currentState.Buttons |= 524288u;
						}
					}
					else if (vector.y < 0f)
					{
						currentState.Buttons |= 131072u;
					}
					else
					{
						currentState.Buttons |= 65536u;
					}
				}
			}
			return result;
		}
	}

	private class OVRControllerRTrackedRemote : OVRControllerBase
	{
		private bool emitSwipe;

		private OVRPlugin.Vector2f moveAmount;

		private float minMoveMagnitude = 0.3f;

		public OVRControllerRTrackedRemote()
		{
			controllerType = Controller.RTrackedRemote;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.RTouchpad;
			buttonMap.Two = RawButton.Back;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.None;
			buttonMap.PrimaryThumbstickUp = RawButton.None;
			buttonMap.PrimaryThumbstickDown = RawButton.None;
			buttonMap.PrimaryThumbstickLeft = RawButton.None;
			buttonMap.PrimaryThumbstickRight = RawButton.None;
			buttonMap.PrimaryTouchpad = RawButton.RTouchpad;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.DpadUp;
			buttonMap.Down = RawButton.DpadDown;
			buttonMap.Left = RawButton.DpadLeft;
			buttonMap.Right = RawButton.DpadRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.RTouchpad;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.None;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.None;
			axis2DMap.PrimaryTouchpad = RawAxis2D.RTouchpad;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}

		public override Controller Update()
		{
			Controller result = base.Update();
			if (GetDown(RawTouch.RTouchpad, Controller.RTrackedRemote))
			{
				emitSwipe = true;
				moveAmount = currentState.RTouchpad;
			}
			if (GetDown(RawButton.RTouchpad, Controller.RTrackedRemote))
			{
				emitSwipe = false;
			}
			if (GetUp(RawTouch.RTouchpad, Controller.RTrackedRemote) && emitSwipe)
			{
				emitSwipe = false;
				moveAmount.x = previousState.RTouchpad.x - moveAmount.x;
				moveAmount.y = previousState.RTouchpad.y - moveAmount.y;
				Vector2 vector = new Vector2(moveAmount.x, moveAmount.y);
				if (vector.magnitude >= minMoveMagnitude)
				{
					vector.Normalize();
					if (Mathf.Abs(vector.x) > Mathf.Abs(vector.y))
					{
						if (vector.x < 0f)
						{
							currentState.Buttons |= 262144u;
						}
						else
						{
							currentState.Buttons |= 524288u;
						}
					}
					else if (vector.y < 0f)
					{
						currentState.Buttons |= 131072u;
					}
					else
					{
						currentState.Buttons |= 65536u;
					}
				}
			}
			return result;
		}
	}

	private static readonly float AXIS_AS_BUTTON_THRESHOLD;

	private static readonly float AXIS_DEADZONE_THRESHOLD;

	private static List<OVRControllerBase> controllers;

	private static Controller activeControllerType;

	private static Controller connectedControllerTypes;

	private static bool useFixedPoses;

	private static int fixedUpdateCount;

	private static bool _pluginSupportsActiveController;

	private static bool _pluginSupportsActiveControllerCached;

	private static Version _pluginSupportsActiveControllerMinVersion;

	private static bool pluginSupportsActiveController
	{
		get
		{
			if (!_pluginSupportsActiveControllerCached)
			{
				bool flag = true;
				_pluginSupportsActiveController = false && OVRPlugin.version >= _pluginSupportsActiveControllerMinVersion;
				_pluginSupportsActiveControllerCached = true;
			}
			return _pluginSupportsActiveController;
		}
	}

	static OVRInput()
	{
		AXIS_AS_BUTTON_THRESHOLD = 0.5f;
		AXIS_DEADZONE_THRESHOLD = 0.2f;
		activeControllerType = Controller.None;
		connectedControllerTypes = Controller.None;
		useFixedPoses = false;
		fixedUpdateCount = 0;
		_pluginSupportsActiveController = false;
		_pluginSupportsActiveControllerCached = false;
		_pluginSupportsActiveControllerMinVersion = new Version(1, 9, 0);
		controllers = new List<OVRControllerBase>
		{
			new OVRControllerGamepadAndroid(),
			new OVRControllerTouchpad(),
			new OVRControllerLTrackedRemote(),
			new OVRControllerRTrackedRemote()
		};
	}

	public static void Update()
	{
		connectedControllerTypes = Controller.None;
		useFixedPoses = false;
		fixedUpdateCount = 0;
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			connectedControllerTypes |= oVRControllerBase.Update();
			if ((connectedControllerTypes & oVRControllerBase.controllerType) != 0 && (Get(RawButton.Any, oVRControllerBase.controllerType) || Get(RawTouch.Any, oVRControllerBase.controllerType)))
			{
				activeControllerType = oVRControllerBase.controllerType;
			}
		}
		if (activeControllerType == Controller.LTouch || activeControllerType == Controller.RTouch)
		{
			activeControllerType = Controller.Touch;
		}
		if ((connectedControllerTypes & activeControllerType) == 0)
		{
			activeControllerType = Controller.None;
		}
		if (activeControllerType == Controller.None)
		{
			if ((connectedControllerTypes & Controller.RTrackedRemote) != 0)
			{
				activeControllerType = Controller.RTrackedRemote;
			}
			else if ((connectedControllerTypes & Controller.LTrackedRemote) != 0)
			{
				activeControllerType = Controller.LTrackedRemote;
			}
		}
		if (pluginSupportsActiveController)
		{
			connectedControllerTypes = (Controller)OVRPlugin.GetConnectedControllers();
			activeControllerType = (Controller)OVRPlugin.GetActiveController();
		}
	}

	public static void FixedUpdate()
	{
		useFixedPoses = true;
		double predictionSeconds = (double)fixedUpdateCount * (double)Time.fixedDeltaTime / (double)Mathf.Max(Time.timeScale, 1E-06f);
		fixedUpdateCount++;
		OVRPlugin.UpdateNodePhysicsPoses(0, predictionSeconds);
	}

	public static bool GetControllerOrientationTracked(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodeOrientationTracked(OVRPlugin.Node.HandLeft);
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodeOrientationTracked(OVRPlugin.Node.HandRight);
		default:
			return false;
		}
	}

	public static bool GetControllerPositionTracked(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.HandLeft);
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.HandRight);
		default:
			return false;
		}
	}

	public static Vector3 GetLocalControllerPosition(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodePose(OVRPlugin.Node.HandLeft, useFixedPoses).ToOVRPose().position;
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodePose(OVRPlugin.Node.HandRight, useFixedPoses).ToOVRPose().position;
		default:
			return Vector3.zero;
		}
	}

	public static Vector3 GetLocalControllerVelocity(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodeVelocity(OVRPlugin.Node.HandLeft, useFixedPoses).ToOVRPose().position;
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodeVelocity(OVRPlugin.Node.HandRight, useFixedPoses).ToOVRPose().position;
		default:
			return Vector3.zero;
		}
	}

	public static Vector3 GetLocalControllerAcceleration(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodeAcceleration(OVRPlugin.Node.HandLeft, useFixedPoses).ToOVRPose().position;
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodeAcceleration(OVRPlugin.Node.HandRight, useFixedPoses).ToOVRPose().position;
		default:
			return Vector3.zero;
		}
	}

	public static Quaternion GetLocalControllerRotation(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodePose(OVRPlugin.Node.HandLeft, useFixedPoses).ToOVRPose().orientation;
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodePose(OVRPlugin.Node.HandRight, useFixedPoses).ToOVRPose().orientation;
		default:
			return Quaternion.identity;
		}
	}

	public static Quaternion GetLocalControllerAngularVelocity(Controller controllerType)
	{
		return controllerType switch
		{
			Controller.LTouch => OVRPlugin.GetNodeVelocity(OVRPlugin.Node.HandLeft, useFixedPoses).ToOVRPose().orientation, 
			Controller.RTouch => OVRPlugin.GetNodeVelocity(OVRPlugin.Node.HandRight, useFixedPoses).ToOVRPose().orientation, 
			_ => Quaternion.identity, 
		};
	}

	public static Quaternion GetLocalControllerAngularAcceleration(Controller controllerType)
	{
		return controllerType switch
		{
			Controller.LTouch => OVRPlugin.GetNodeAcceleration(OVRPlugin.Node.HandLeft, useFixedPoses).ToOVRPose().orientation, 
			Controller.RTouch => OVRPlugin.GetNodeAcceleration(OVRPlugin.Node.HandRight, useFixedPoses).ToOVRPose().orientation, 
			_ => Quaternion.identity, 
		};
	}

	public static bool Get(Button virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButton(virtualMask, RawButton.None, controllerMask);
	}

	public static bool Get(RawButton rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButton(Button.None, rawMask, controllerMask);
	}

	private static bool GetResolvedButton(Button virtualMask, RawButton rawMask, Controller controllerMask)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawButton rawButton = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.Buttons & (uint)rawButton) != 0)
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool GetDown(Button virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButtonDown(virtualMask, RawButton.None, controllerMask);
	}

	public static bool GetDown(RawButton rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButtonDown(Button.None, rawMask, controllerMask);
	}

	private static bool GetResolvedButtonDown(Button virtualMask, RawButton rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawButton rawButton = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.previousState.Buttons & (uint)rawButton) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.Buttons & (uint)rawButton) != 0 && (oVRControllerBase.previousState.Buttons & (uint)rawButton) == 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static bool GetUp(Button virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButtonUp(virtualMask, RawButton.None, controllerMask);
	}

	public static bool GetUp(RawButton rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButtonUp(Button.None, rawMask, controllerMask);
	}

	private static bool GetResolvedButtonUp(Button virtualMask, RawButton rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawButton rawButton = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.Buttons & (uint)rawButton) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.Buttons & (uint)rawButton) == 0 && (oVRControllerBase.previousState.Buttons & (uint)rawButton) != 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static bool Get(Touch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouch(virtualMask, RawTouch.None, controllerMask);
	}

	public static bool Get(RawTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouch(Touch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedTouch(Touch virtualMask, RawTouch rawMask, Controller controllerMask)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawTouch rawTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.Touches & (uint)rawTouch) != 0)
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool GetDown(Touch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouchDown(virtualMask, RawTouch.None, controllerMask);
	}

	public static bool GetDown(RawTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouchDown(Touch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedTouchDown(Touch virtualMask, RawTouch rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawTouch rawTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.previousState.Touches & (uint)rawTouch) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.Touches & (uint)rawTouch) != 0 && (oVRControllerBase.previousState.Touches & (uint)rawTouch) == 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static bool GetUp(Touch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouchUp(virtualMask, RawTouch.None, controllerMask);
	}

	public static bool GetUp(RawTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouchUp(Touch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedTouchUp(Touch virtualMask, RawTouch rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawTouch rawTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.Touches & (uint)rawTouch) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.Touches & (uint)rawTouch) == 0 && (oVRControllerBase.previousState.Touches & (uint)rawTouch) != 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static bool Get(NearTouch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouch(virtualMask, RawNearTouch.None, controllerMask);
	}

	public static bool Get(RawNearTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouch(NearTouch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedNearTouch(NearTouch virtualMask, RawNearTouch rawMask, Controller controllerMask)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawNearTouch rawNearTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.NearTouches & (uint)rawNearTouch) != 0)
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool GetDown(NearTouch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouchDown(virtualMask, RawNearTouch.None, controllerMask);
	}

	public static bool GetDown(RawNearTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouchDown(NearTouch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedNearTouchDown(NearTouch virtualMask, RawNearTouch rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawNearTouch rawNearTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.previousState.NearTouches & (uint)rawNearTouch) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.NearTouches & (uint)rawNearTouch) != 0 && (oVRControllerBase.previousState.NearTouches & (uint)rawNearTouch) == 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static bool GetUp(NearTouch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouchUp(virtualMask, RawNearTouch.None, controllerMask);
	}

	public static bool GetUp(RawNearTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouchUp(NearTouch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedNearTouchUp(NearTouch virtualMask, RawNearTouch rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawNearTouch rawNearTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.NearTouches & (uint)rawNearTouch) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.NearTouches & (uint)rawNearTouch) == 0 && (oVRControllerBase.previousState.NearTouches & (uint)rawNearTouch) != 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static float Get(Axis1D virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedAxis1D(virtualMask, RawAxis1D.None, controllerMask);
	}

	public static float Get(RawAxis1D rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedAxis1D(Axis1D.None, rawMask, controllerMask);
	}

	private static float GetResolvedAxis1D(Axis1D virtualMask, RawAxis1D rawMask, Controller controllerMask)
	{
		float num = 0f;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (!ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				continue;
			}
			RawAxis1D rawAxis1D = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
			if ((RawAxis1D.LIndexTrigger & rawAxis1D) != 0)
			{
				float num2 = oVRControllerBase.currentState.LIndexTrigger;
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					num2 = CalculateDeadzone(num2, AXIS_DEADZONE_THRESHOLD);
				}
				num = CalculateAbsMax(num, num2);
			}
			if ((RawAxis1D.RIndexTrigger & rawAxis1D) != 0)
			{
				float num3 = oVRControllerBase.currentState.RIndexTrigger;
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					num3 = CalculateDeadzone(num3, AXIS_DEADZONE_THRESHOLD);
				}
				num = CalculateAbsMax(num, num3);
			}
			if ((RawAxis1D.LHandTrigger & rawAxis1D) != 0)
			{
				float num4 = oVRControllerBase.currentState.LHandTrigger;
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					num4 = CalculateDeadzone(num4, AXIS_DEADZONE_THRESHOLD);
				}
				num = CalculateAbsMax(num, num4);
			}
			if ((RawAxis1D.RHandTrigger & rawAxis1D) != 0)
			{
				float num5 = oVRControllerBase.currentState.RHandTrigger;
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					num5 = CalculateDeadzone(num5, AXIS_DEADZONE_THRESHOLD);
				}
				num = CalculateAbsMax(num, num5);
			}
		}
		return num;
	}

	public static Vector2 Get(Axis2D virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedAxis2D(virtualMask, RawAxis2D.None, controllerMask);
	}

	public static Vector2 Get(RawAxis2D rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedAxis2D(Axis2D.None, rawMask, controllerMask);
	}

	private static Vector2 GetResolvedAxis2D(Axis2D virtualMask, RawAxis2D rawMask, Controller controllerMask)
	{
		Vector2 vector = Vector2.zero;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (!ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				continue;
			}
			RawAxis2D rawAxis2D = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
			if ((RawAxis2D.LThumbstick & rawAxis2D) != 0)
			{
				Vector2 vector2 = new Vector2(oVRControllerBase.currentState.LThumbstick.x, oVRControllerBase.currentState.LThumbstick.y);
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					vector2 = CalculateDeadzone(vector2, AXIS_DEADZONE_THRESHOLD);
				}
				vector = CalculateAbsMax(vector, vector2);
			}
			if ((RawAxis2D.LTouchpad & rawAxis2D) != 0)
			{
				Vector2 b = new Vector2(oVRControllerBase.currentState.LTouchpad.x, oVRControllerBase.currentState.LTouchpad.y);
				vector = CalculateAbsMax(vector, b);
			}
			if ((RawAxis2D.RThumbstick & rawAxis2D) != 0)
			{
				Vector2 vector3 = new Vector2(oVRControllerBase.currentState.RThumbstick.x, oVRControllerBase.currentState.RThumbstick.y);
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					vector3 = CalculateDeadzone(vector3, AXIS_DEADZONE_THRESHOLD);
				}
				vector = CalculateAbsMax(vector, vector3);
			}
			if ((RawAxis2D.RTouchpad & rawAxis2D) != 0)
			{
				Vector2 b2 = new Vector2(oVRControllerBase.currentState.RTouchpad.x, oVRControllerBase.currentState.RTouchpad.y);
				vector = CalculateAbsMax(vector, b2);
			}
		}
		return vector;
	}

	public static Controller GetConnectedControllers()
	{
		return connectedControllerTypes;
	}

	public static bool IsControllerConnected(Controller controller)
	{
		return (connectedControllerTypes & controller) == controller;
	}

	public static Controller GetActiveController()
	{
		return activeControllerType;
	}

	public static void SetControllerVibration(float frequency, float amplitude, Controller controllerMask = Controller.Active)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				oVRControllerBase.SetControllerVibration(frequency, amplitude);
			}
		}
	}

	private static Vector2 CalculateAbsMax(Vector2 a, Vector2 b)
	{
		float sqrMagnitude = a.sqrMagnitude;
		float sqrMagnitude2 = b.sqrMagnitude;
		if (sqrMagnitude >= sqrMagnitude2)
		{
			return a;
		}
		return b;
	}

	private static float CalculateAbsMax(float a, float b)
	{
		float num = ((!(a >= 0f)) ? (0f - a) : a);
		float num2 = ((!(b >= 0f)) ? (0f - b) : b);
		if (num >= num2)
		{
			return a;
		}
		return b;
	}

	private static Vector2 CalculateDeadzone(Vector2 a, float deadzone)
	{
		if (a.sqrMagnitude <= deadzone * deadzone)
		{
			return Vector2.zero;
		}
		a *= (a.magnitude - deadzone) / (1f - deadzone);
		if (a.sqrMagnitude > 1f)
		{
			return a.normalized;
		}
		return a;
	}

	private static float CalculateDeadzone(float a, float deadzone)
	{
		float num = ((!(a >= 0f)) ? (0f - a) : a);
		if (num <= deadzone)
		{
			return 0f;
		}
		a *= (num - deadzone) / (1f - deadzone);
		if (a * a > 1f)
		{
			return (!(a >= 0f)) ? (-1f) : 1f;
		}
		return a;
	}

	private static bool ShouldResolveController(Controller controllerType, Controller controllerMask)
	{
		bool result = false;
		if ((controllerType & controllerMask) == controllerType)
		{
			result = true;
		}
		if ((controllerMask & Controller.Touch) == Controller.Touch && (controllerType & Controller.Touch) != 0 && (controllerType & Controller.Touch) != Controller.Touch)
		{
			result = false;
		}
		return result;
	}
}
public class OVRManager : MonoBehaviour
{
	public enum TrackingOrigin
	{
		EyeLevel,
		FloorLevel
	}

	public enum EyeTextureFormat
	{
		Default = 0,
		R16G16B16A16_FP = 2,
		R11G11B10_FP = 3
	}

	private static OVRProfile _profile;

	private IEnumerable<Camera> disabledCameras;

	private float prevTimeScale;

	private static bool _isHmdPresentCached = false;

	private static bool _isHmdPresent = false;

	private static bool _wasHmdPresent = false;

	private static bool _hasVrFocusCached = false;

	private static bool _hasVrFocus = false;

	private static bool _hadVrFocus = false;

	public bool queueAhead = true;

	public bool useRecommendedMSAALevel;

	public bool enableAdaptiveResolution;

	[Range(0.5f, 2f)]
	public float maxRenderScale = 1f;

	[Range(0.5f, 2f)]
	public float minRenderScale = 0.7f;

	[SerializeField]
	private TrackingOrigin _trackingOriginType;

	public bool usePositionTracking = true;

	public bool useIPDInPositionTracking = true;

	public bool resetTrackerOnLoad;

	private static bool _isUserPresentCached = false;

	private static bool _isUserPresent = false;

	private static bool _wasUserPresent = false;

	private static bool prevAudioOutIdIsCached = false;

	private static bool prevAudioInIdIsCached = false;

	private static string prevAudioOutId = string.Empty;

	private static string prevAudioInId = string.Empty;

	private static bool wasPositionTracked = false;

	public static OVRManager instance { get; private set; }

	public static OVRDisplay display { get; private set; }

	public static OVRTracker tracker { get; private set; }

	public static OVRBoundary boundary { get; private set; }

	public static OVRProfile profile
	{
		get
		{
			if (_profile == null)
			{
				_profile = new OVRProfile();
			}
			return _profile;
		}
	}

	public static bool isHmdPresent
	{
		get
		{
			if (!_isHmdPresentCached)
			{
				_isHmdPresentCached = true;
				_isHmdPresent = OVRPlugin.hmdPresent;
			}
			return _isHmdPresent;
		}
		private set
		{
			_isHmdPresentCached = true;
			_isHmdPresent = value;
		}
	}

	public static string audioOutId => OVRPlugin.audioOutId;

	public static string audioInId => OVRPlugin.audioInId;

	public static bool hasVrFocus
	{
		get
		{
			if (!_hasVrFocusCached)
			{
				_hasVrFocusCached = true;
				_hasVrFocus = OVRPlugin.hasVrFocus;
			}
			return _hasVrFocus;
		}
		private set
		{
			_hasVrFocusCached = true;
			_hasVrFocus = value;
		}
	}

	[Obsolete]
	public static bool isHSWDisplayed => false;

	public bool chromatic
	{
		get
		{
			if (!isHmdPresent)
			{
				return false;
			}
			return OVRPlugin.chromatic;
		}
		set
		{
			if (isHmdPresent)
			{
				OVRPlugin.chromatic = value;
			}
		}
	}

	public bool monoscopic
	{
		get
		{
			if (!isHmdPresent)
			{
				return true;
			}
			return OVRPlugin.monoscopic;
		}
		set
		{
			if (isHmdPresent)
			{
				OVRPlugin.monoscopic = value;
			}
		}
	}

	public int vsyncCount
	{
		get
		{
			if (!isHmdPresent)
			{
				return 1;
			}
			return OVRPlugin.vsyncCount;
		}
		set
		{
			if (isHmdPresent)
			{
				OVRPlugin.vsyncCount = value;
			}
		}
	}

	public static float batteryLevel
	{
		get
		{
			if (!isHmdPresent)
			{
				return 1f;
			}
			return OVRPlugin.batteryLevel;
		}
	}

	public static float batteryTemperature
	{
		get
		{
			if (!isHmdPresent)
			{
				return 0f;
			}
			return OVRPlugin.batteryTemperature;
		}
	}

	public static int batteryStatus
	{
		get
		{
			if (!isHmdPresent)
			{
				return -1;
			}
			return (int)OVRPlugin.batteryStatus;
		}
	}

	public static float volumeLevel
	{
		get
		{
			if (!isHmdPresent)
			{
				return 0f;
			}
			return OVRPlugin.systemVolume;
		}
	}

	public static int cpuLevel
	{
		get
		{
			if (!isHmdPresent)
			{
				return 2;
			}
			return OVRPlugin.cpuLevel;
		}
		set
		{
			if (isHmdPresent)
			{
				OVRPlugin.cpuLevel = value;
			}
		}
	}

	public static int gpuLevel
	{
		get
		{
			if (!isHmdPresent)
			{
				return 2;
			}
			return OVRPlugin.gpuLevel;
		}
		set
		{
			if (isHmdPresent)
			{
				OVRPlugin.gpuLevel = value;
			}
		}
	}

	public static bool isPowerSavingActive
	{
		get
		{
			if (!isHmdPresent)
			{
				return false;
			}
			return OVRPlugin.powerSaving;
		}
	}

	public static EyeTextureFormat eyeTextureFormat
	{
		get
		{
			return (EyeTextureFormat)OVRPlugin.GetDesiredEyeTextureFormat();
		}
		set
		{
			OVRPlugin.SetDesiredEyeTextureFormat((OVRPlugin.EyeTextureFormat)value);
		}
	}

	public TrackingOrigin trackingOriginType
	{
		get
		{
			if (!isHmdPresent)
			{
				return _trackingOriginType;
			}
			return (TrackingOrigin)OVRPlugin.GetTrackingOriginType();
		}
		set
		{
			if (isHmdPresent && OVRPlugin.SetTrackingOriginType((OVRPlugin.TrackingOrigin)value))
			{
				_trackingOriginType = value;
			}
		}
	}

	public bool isSupportedPlatform { get; private set; }

	public bool isUserPresent
	{
		get
		{
			if (!_isUserPresentCached)
			{
				_isUserPresentCached = true;
				_isUserPresent = OVRPlugin.userPresent;
			}
			return _isUserPresent;
		}
		private set
		{
			_isUserPresentCached = true;
			_isUserPresent = value;
		}
	}

	public static event Action HMDAcquired;

	public static event Action HMDLost;

	public static event Action HMDMounted;

	public static event Action HMDUnmounted;

	public static event Action VrFocusAcquired;

	public static event Action VrFocusLost;

	public static event Action AudioOutChanged;

	public static event Action AudioInChanged;

	public static event Action TrackingAcquired;

	public static event Action TrackingLost;

	[Obsolete]
	public static event Action HSWDismissed;

	[Obsolete]
	public static void DismissHSWDisplay()
	{
	}

	private void Awake()
	{
		if (instance != null)
		{
			base.enabled = false;
			UnityEngine.Object.DestroyImmediate(this);
			return;
		}
		instance = this;
		UnityEngine.Debug.Log(string.Concat("Unity v", Application.unityVersion, ", Oculus Utilities v", OVRPlugin.wrapperVersion, ", OVRPlugin v", OVRPlugin.version, ", SDK v", OVRPlugin.nativeSDKVersion, "."));
		RuntimePlatform platform = Application.platform;
		isSupportedPlatform |= platform == RuntimePlatform.Android;
		isSupportedPlatform |= platform == RuntimePlatform.OSXEditor;
		isSupportedPlatform |= platform == RuntimePlatform.OSXPlayer;
		isSupportedPlatform |= platform == RuntimePlatform.WindowsEditor;
		isSupportedPlatform |= platform == RuntimePlatform.WindowsPlayer;
		if (!isSupportedPlatform)
		{
			UnityEngine.Debug.LogWarning("This platform is unsupported");
			return;
		}
		OVRTouchpad.Create();
		chromatic = false;
		if (display == null)
		{
			display = new OVRDisplay();
		}
		if (tracker == null)
		{
			tracker = new OVRTracker();
		}
		if (boundary == null)
		{
			boundary = new OVRBoundary();
		}
		if (resetTrackerOnLoad)
		{
			display.RecenterPose();
		}
		OVRPlugin.occlusionMesh = false;
	}

	private void Update()
	{
		if (OVRPlugin.shouldQuit)
		{
			Application.Quit();
		}
		if (OVRPlugin.shouldRecenter)
		{
			display.RecenterPose();
		}
		if (trackingOriginType != _trackingOriginType)
		{
			trackingOriginType = _trackingOriginType;
		}
		tracker.isEnabled = usePositionTracking;
		OVRPlugin.useIPDInPositionTracking = useIPDInPositionTracking;
		isHmdPresent = OVRPlugin.hmdPresent;
		if (useRecommendedMSAALevel && QualitySettings.antiAliasing != display.recommendedMSAALevel)
		{
			UnityEngine.Debug.Log("The current MSAA level is " + QualitySettings.antiAliasing + ", but the recommended MSAA level is " + display.recommendedMSAALevel + ". Switching to the recommended level.");
			QualitySettings.antiAliasing = display.recommendedMSAALevel;
		}
		if (_wasHmdPresent && !isHmdPresent)
		{
			try
			{
				if (OVRManager.HMDLost != null)
				{
					OVRManager.HMDLost();
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex);
			}
		}
		if (!_wasHmdPresent && isHmdPresent)
		{
			try
			{
				if (OVRManager.HMDAcquired != null)
				{
					OVRManager.HMDAcquired();
				}
			}
			catch (Exception ex2)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex2);
			}
		}
		_wasHmdPresent = isHmdPresent;
		isUserPresent = OVRPlugin.userPresent;
		if (_wasUserPresent && !isUserPresent)
		{
			try
			{
				if (OVRManager.HMDUnmounted != null)
				{
					OVRManager.HMDUnmounted();
				}
			}
			catch (Exception ex3)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex3);
			}
		}
		if (!_wasUserPresent && isUserPresent)
		{
			try
			{
				if (OVRManager.HMDMounted != null)
				{
					OVRManager.HMDMounted();
				}
			}
			catch (Exception ex4)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex4);
			}
		}
		_wasUserPresent = isUserPresent;
		hasVrFocus = OVRPlugin.hasVrFocus;
		if (_hadVrFocus && !hasVrFocus)
		{
			try
			{
				if (OVRManager.VrFocusLost != null)
				{
					OVRManager.VrFocusLost();
				}
			}
			catch (Exception ex5)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex5);
			}
		}
		if (!_hadVrFocus && hasVrFocus)
		{
			try
			{
				if (OVRManager.VrFocusAcquired != null)
				{
					OVRManager.VrFocusAcquired();
				}
			}
			catch (Exception ex6)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex6);
			}
		}
		_hadVrFocus = hasVrFocus;
		string text = OVRPlugin.audioOutId;
		if (!prevAudioOutIdIsCached)
		{
			prevAudioOutId = text;
			prevAudioOutIdIsCached = true;
		}
		else if (text != prevAudioOutId)
		{
			try
			{
				if (OVRManager.AudioOutChanged != null)
				{
					OVRManager.AudioOutChanged();
				}
			}
			catch (Exception ex7)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex7);
			}
			prevAudioOutId = text;
		}
		string text2 = OVRPlugin.audioInId;
		if (!prevAudioInIdIsCached)
		{
			prevAudioInId = text2;
			prevAudioInIdIsCached = true;
		}
		else if (text2 != prevAudioInId)
		{
			try
			{
				if (OVRManager.AudioInChanged != null)
				{
					OVRManager.AudioInChanged();
				}
			}
			catch (Exception ex8)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex8);
			}
			prevAudioInId = text2;
		}
		if (wasPositionTracked && !tracker.isPositionTracked)
		{
			try
			{
				if (OVRManager.TrackingLost != null)
				{
					OVRManager.TrackingLost();
				}
			}
			catch (Exception ex9)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex9);
			}
		}
		if (!wasPositionTracked && tracker.isPositionTracked)
		{
			try
			{
				if (OVRManager.TrackingAcquired != null)
				{
					OVRManager.TrackingAcquired();
				}
			}
			catch (Exception ex10)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex10);
			}
		}
		wasPositionTracked = tracker.isPositionTracked;
		display.Update();
		OVRInput.Update();
	}

	private void LateUpdate()
	{
		OVRHaptics.Process();
	}

	private void FixedUpdate()
	{
		OVRInput.FixedUpdate();
	}

	public void ReturnToLauncher()
	{
		PlatformUIConfirmQuit();
	}

	public static void PlatformUIConfirmQuit()
	{
		if (isHmdPresent)
		{
			OVRPlugin.ShowUI(OVRPlugin.PlatformUI.ConfirmQuit);
		}
	}

	public static void PlatformUIGlobalMenu()
	{
		if (isHmdPresent)
		{
			OVRPlugin.ShowUI(OVRPlugin.PlatformUI.GlobalMenu);
		}
	}
}
public abstract class OVROnCompleteListener : AndroidJavaProxy
{
	public OVROnCompleteListener()
		: base("com.oculus.svclib.OnCompleteListener")
	{
	}

	public abstract void onSuccess();

	public abstract void onFailure();
}
public class OVROverlay : MonoBehaviour
{
	public enum OverlayShape
	{
		Quad = 0,
		Cylinder = 1,
		Cubemap = 2,
		OffcenterCubemap = 4
	}

	public enum OverlayType
	{
		None,
		Underlay,
		Overlay,
		OverlayShowLod
	}

	private const int maxInstances = 3;

	internal static OVROverlay[] instances = new OVROverlay[3];

	public OverlayType currentOverlayType = OverlayType.Overlay;

	public OverlayShape currentOverlayShape;

	public Texture[] textures = new Texture[2];

	private Texture[] cachedTextures = new Texture[2];

	private IntPtr[] texNativePtrs = new IntPtr[2]
	{
		IntPtr.Zero,
		IntPtr.Zero
	};

	private int layerIndex = -1;

	private Renderer rend;

	public void OverrideOverlayTextureInfo(Texture srcTexture, IntPtr nativePtr, VRNode node)
	{
		int num = ((node == VRNode.RightEye) ? 1 : 0);
		textures[num] = srcTexture;
		cachedTextures[num] = srcTexture;
		texNativePtrs[num] = nativePtr;
	}

	private void Awake()
	{
		UnityEngine.Debug.Log("Overlay Awake");
		rend = GetComponent<Renderer>();
		for (int i = 0; i < 2; i++)
		{
			if (rend != null && textures[i] == null)
			{
				textures[i] = rend.material.mainTexture;
			}
			if (textures[i] != null)
			{
				cachedTextures[i] = textures[i];
				ref IntPtr reference = ref texNativePtrs[i];
				reference = textures[i].GetNativeTexturePtr();
			}
		}
	}

	private void OnEnable()
	{
		if (!OVRManager.isHmdPresent)
		{
			base.enabled = false;
			return;
		}
		OnDisable();
		for (int i = 0; i < 3; i++)
		{
			if (instances[i] == null || instances[i] == this)
			{
				layerIndex = i;
				instances[i] = this;
				break;
			}
		}
	}

	private void OnDisable()
	{
		if (layerIndex != -1)
		{
			OVRPlugin.SetOverlayQuad(onTop: true, headLocked: false, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, OVRPose.identity.ToPosef(), Vector3.one.ToVector3f(), layerIndex);
			instances[layerIndex] = null;
		}
		layerIndex = -1;
	}

	private void OnRenderObject()
	{
		if (!Camera.current.CompareTag("MainCamera") || Camera.current.cameraType != CameraType.Game || layerIndex == -1 || currentOverlayType == OverlayType.None)
		{
			return;
		}
		for (int i = 0; i < 2; i++)
		{
			if (i >= textures.Length)
			{
				continue;
			}
			if (textures[i] != cachedTextures[i])
			{
				cachedTextures[i] = textures[i];
				if (cachedTextures[i] != null)
				{
					ref IntPtr reference = ref texNativePtrs[i];
					reference = cachedTextures[i].GetNativeTexturePtr();
				}
			}
			if (currentOverlayShape == OverlayShape.Cubemap && textures[i] != null && textures[i].GetType() != typeof(Cubemap))
			{
				UnityEngine.Debug.LogError("Need Cubemap texture for cube map overlay");
				return;
			}
		}
		if (cachedTextures[0] == null || texNativePtrs[0] == IntPtr.Zero)
		{
			return;
		}
		bool onTop = currentOverlayType == OverlayType.Overlay;
		bool flag = false;
		Transform parent = base.transform;
		while (parent != null && !flag)
		{
			flag |= parent == Camera.current.transform;
			parent = parent.parent;
		}
		OVRPose oVRPose = ((!flag) ? base.transform.ToTrackingSpacePose() : base.transform.ToHeadSpacePose());
		Vector3 lossyScale = base.transform.lossyScale;
		for (int j = 0; j < 3; j++)
		{
			lossyScale[j] /= Camera.current.transform.lossyScale[j];
		}
		if (currentOverlayShape == OverlayShape.OffcenterCubemap)
		{
			oVRPose.position = base.transform.position;
			if (oVRPose.position.magnitude > 1f)
			{
				UnityEngine.Debug.LogWarning("your cube map center offset's magnitude is greater than 1, which will cause some cube map pixel always invisible .");
			}
		}
		if (currentOverlayShape == OverlayShape.Cylinder)
		{
			float num = lossyScale.x / lossyScale.z / (float)Math.PI * 180f;
			if (num > 180f)
			{
				UnityEngine.Debug.LogError("Cylinder overlay's arc angle has to be below 180 degree, current arc angle is " + num + " degree.");
				return;
			}
		}
		bool flag2 = OVRPlugin.SetOverlayQuad(onTop, flag, texNativePtrs[0], texNativePtrs[1], IntPtr.Zero, oVRPose.flipZ().ToPosef(), lossyScale.ToVector3f(), layerIndex, (OVRPlugin.OverlayShape)currentOverlayShape);
		if ((bool)rend)
		{
			rend.enabled = !flag2;
		}
	}
}
public class OVRPlatformMenu : MonoBehaviour
{
	public enum eHandler
	{
		ShowConfirmQuit
	}

	private enum eBackButtonAction
	{
		NONE,
		DOUBLE_TAP,
		SHORT_PRESS
	}

	public KeyCode keyCode = KeyCode.Escape;

	public eHandler shortPressHandler;

	private float doubleTapDelay = 0.25f;

	private float shortPressDelay = 0.25f;

	private float longPressDelay = 0.75f;

	private int downCount;

	private int upCount;

	private float initialDownTime = -1f;

	private eBackButtonAction ResetAndSendAction(eBackButtonAction action)
	{
		MonoBehaviour.print(string.Concat("ResetAndSendAction( ", action, " );"));
		downCount = 0;
		upCount = 0;
		initialDownTime = -1f;
		return action;
	}

	private eBackButtonAction HandleBackButtonState()
	{
		return eBackButtonAction.NONE;
	}

	private void Awake()
	{
		if (!OVRManager.isHmdPresent)
		{
			base.enabled = false;
		}
	}

	private void OnApplicationFocus(bool focusState)
	{
	}

	private void OnApplicationPause(bool pauseStatus)
	{
		if (!pauseStatus)
		{
			Input.ResetInputAxes();
		}
	}

	private void ShowConfirmQuitMenu()
	{
		UnityEngine.Debug.Log("[PlatformUI-ConfirmQuit] Showing @ " + Time.time);
		OVRManager.PlatformUIConfirmQuit();
	}

	private void DoHandler(eHandler handler)
	{
		if (handler == eHandler.ShowConfirmQuit)
		{
			ShowConfirmQuitMenu();
		}
	}

	private void Update()
	{
		eBackButtonAction eBackButtonAction = HandleBackButtonState();
		if (eBackButtonAction == eBackButtonAction.SHORT_PRESS)
		{
			DoHandler(shortPressHandler);
		}
	}
}
internal static class OVRPlugin
{
	private struct GUID
	{
		public int a;

		public short b;

		public short c;

		public byte d0;

		public byte d1;

		public byte d2;

		public byte d3;

		public byte d4;

		public byte d5;

		public byte d6;

		public byte d7;
	}

	public enum Bool
	{
		False,
		True
	}

	public enum Eye
	{
		None = -1,
		Left,
		Right,
		Count
	}

	public enum Tracker
	{
		None = -1,
		Zero,
		One,
		Two,
		Three,
		Count
	}

	public enum Node
	{
		None = -1,
		EyeLeft,
		EyeRight,
		EyeCenter,
		HandLeft,
		HandRight,
		TrackerZero,
		TrackerOne,
		TrackerTwo,
		TrackerThree,
		Head,
		Count
	}

	public enum Controller
	{
		None = 0,
		LTouch = 1,
		RTouch = 2,
		Touch = 3,
		Remote = 4,
		Gamepad = 16,
		Touchpad = 134217728,
		LTrackedRemote = 16777216,
		RTrackedRemote = 33554432,
		Active = int.MinValue,
		All = -1
	}

	public enum TrackingOrigin
	{
		EyeLevel,
		FloorLevel,
		Count
	}

	public enum RecenterFlags
	{
		Default = 0,
		Controllers = 1073741824,
		IgnoreAll = int.MinValue,
		Count = -2147483647
	}

	public enum BatteryStatus
	{
		Charging,
		Discharging,
		Full,
		NotCharging,
		Unknown
	}

	public enum EyeTextureFormat
	{
		Default = 0,
		R16G16B16A16_FP = 2,
		R11G11B10_FP = 3
	}

	public enum PlatformUI
	{
		None = -1,
		GlobalMenu,
		ConfirmQuit,
		GlobalMenuTutorial
	}

	public enum SystemRegion
	{
		Unspecified,
		Japan,
		China
	}

	public enum SystemHeadset
	{
		None = 0,
		GearVR_R320 = 1,
		GearVR_R321 = 2,
		GearVR_R322 = 3,
		GearVR_R323 = 4,
		Rift_DK1 = 4096,
		Rift_DK2 = 4097,
		Rift_CV1 = 4098
	}

	public enum OverlayShape
	{
		Quad = 0,
		Cylinder = 1,
		Cubemap = 2,
		OffcenterCubemap = 4
	}

	private enum OverlayFlag
	{
		None = 0,
		OnTop = 1,
		HeadLocked = 2,
		ShapeFlag_Quad = 0,
		ShapeFlag_Cylinder = 16,
		ShapeFlag_Cubemap = 32,
		ShapeFlag_OffcenterCubemap = 64,
		ShapeFlagRangeMask = 240
	}

	public struct Vector2f
	{
		public float x;

		public float y;
	}

	public struct Vector3f
	{
		public float x;

		public float y;

		public float z;
	}

	public struct Quatf
	{
		public float x;

		public float y;

		public float z;

		public float w;
	}

	public struct Posef
	{
		public Quatf Orientation;

		public Vector3f Position;
	}

	public struct ControllerState2
	{
		public uint ConnectedControllers;

		public uint Buttons;

		public uint Touches;

		public uint NearTouches;

		public float LIndexTrigger;

		public float RIndexTrigger;

		public float LHandTrigger;

		public float RHandTrigger;

		public Vector2f LThumbstick;

		public Vector2f RThumbstick;

		public Vector2f LTouchpad;

		public Vector2f RTouchpad;

		public ControllerState2(ControllerState cs)
		{
			ConnectedControllers = cs.ConnectedControllers;
			Buttons = cs.Buttons;
			Touches = cs.Touches;
			NearTouches = cs.NearTouches;
			LIndexTrigger = cs.LIndexTrigger;
			RIndexTrigger = cs.RIndexTrigger;
			LHandTrigger = cs.LHandTrigger;
			RHandTrigger = cs.RHandTrigger;
			LThumbstick = cs.LThumbstick;
			RThumbstick = cs.RThumbstick;
			LTouchpad = new Vector2f
			{
				x = 0f,
				y = 0f
			};
			RTouchpad = new Vector2f
			{
				x = 0f,
				y = 0f
			};
		}
	}

	public struct ControllerState
	{
		public uint ConnectedControllers;

		public uint Buttons;

		public uint Touches;

		public uint NearTouches;

		public float LIndexTrigger;

		public float RIndexTrigger;

		public float LHandTrigger;

		public float RHandTrigger;

		public Vector2f LThumbstick;

		public Vector2f RThumbstick;
	}

	public struct HapticsBuffer
	{
		public IntPtr Samples;

		public int SamplesCount;
	}

	public struct HapticsState
	{
		public int SamplesAvailable;

		public int SamplesQueued;
	}

	public struct HapticsDesc
	{
		public int SampleRateHz;

		public int SampleSizeInBytes;

		public int MinimumSafeSamplesQueued;

		public int MinimumBufferSamplesCount;

		public int OptimalBufferSamplesCount;

		public int MaximumBufferSamplesCount;
	}

	public struct AppPerfFrameStats
	{
		public int HmdVsyncIndex;

		public int AppFrameIndex;

		public int AppDroppedFrameCount;

		public float AppMotionToPhotonLatency;

		public float AppQueueAheadTime;

		public float AppCpuElapsedTime;

		public float AppGpuElapsedTime;

		public int CompositorFrameIndex;

		public int CompositorDroppedFrameCount;

		public float CompositorLatency;

		public float CompositorCpuElapsedTime;

		public float CompositorGpuElapsedTime;

		public float CompositorCpuStartToGpuEndElapsedTime;

		public float CompositorGpuEndToVsyncElapsedTime;
	}

	public struct AppPerfStats
	{
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 5)]
		public AppPerfFrameStats[] FrameStats;

		public int FrameStatsCount;

		public Bool AnyFrameStatsDropped;

		public float AdaptiveGpuPerformanceScale;
	}

	public struct Sizei
	{
		public int w;

		public int h;
	}

	public struct Frustumf
	{
		public float zNear;

		public float zFar;

		public float fovX;

		public float fovY;
	}

	public enum BoundaryType
	{
		OuterBoundary = 1,
		PlayArea = 0x100
	}

	public struct BoundaryTestResult
	{
		public Bool IsTriggering;

		public float ClosestDistance;

		public Vector3f ClosestPoint;

		public Vector3f ClosestPointNormal;
	}

	public struct BoundaryLookAndFeel
	{
		public Colorf Color;
	}

	public struct BoundaryGeometry
	{
		public BoundaryType BoundaryType;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
		public Vector3f[] Points;

		public int PointsCount;
	}

	public struct Colorf
	{
		public float r;

		public float g;

		public float b;

		public float a;
	}

	private static class OVRP_0_1_0
	{
		public static readonly Version version = new Version(0, 1, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Sizei ovrp_GetEyeTextureSize(Eye eyeId);
	}

	private static class OVRP_0_1_1
	{
		public static readonly Version version = new Version(0, 1, 1);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetOverlayQuad2(Bool onTop, Bool headLocked, IntPtr texture, IntPtr device, Posef pose, Vector3f scale);
	}

	private static class OVRP_0_1_2
	{
		public static readonly Version version = new Version(0, 1, 2);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodePose(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetControllerVibration(uint controllerMask, float frequency, float amplitude);
	}

	private static class OVRP_0_1_3
	{
		public static readonly Version version = new Version(0, 1, 3);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodeVelocity(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodeAcceleration(Node nodeId);
	}

	private static class OVRP_0_5_0
	{
		public static readonly Version version = new Version(0, 5, 0);
	}

	private static class OVRP_1_0_0
	{
		public static readonly Version version = new Version(1, 0, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern TrackingOrigin ovrp_GetTrackingOriginType();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetTrackingOriginType(TrackingOrigin originType);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetTrackingCalibratedOrigin();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_RecenterTrackingOrigin(uint flags);
	}

	private static class OVRP_1_1_0
	{
		public static readonly Version version = new Version(1, 1, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetInitialized();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetVersion")]
		private static extern IntPtr _ovrp_GetVersion();

		public static string ovrp_GetVersion()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetVersion());
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetNativeSDKVersion")]
		private static extern IntPtr _ovrp_GetNativeSDKVersion();

		public static string ovrp_GetNativeSDKVersion()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetNativeSDKVersion());
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrp_GetAudioOutId();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrp_GetAudioInId();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetEyeTextureScale();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetEyeTextureScale(float value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetTrackingOrientationSupported();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetTrackingOrientationEnabled();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetTrackingOrientationEnabled(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetTrackingPositionSupported();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetTrackingPositionEnabled();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetTrackingPositionEnabled(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetNodePresent(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetNodeOrientationTracked(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetNodePositionTracked(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Frustumf ovrp_GetNodeFrustum(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern ControllerState ovrp_GetControllerState(uint controllerMask);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovrp_GetSystemCpuLevel();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetSystemCpuLevel(int value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovrp_GetSystemGpuLevel();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetSystemGpuLevel(int value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetSystemPowerSavingMode();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetSystemDisplayFrequency();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovrp_GetSystemVSyncCount();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetSystemVolume();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern BatteryStatus ovrp_GetSystemBatteryStatus();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetSystemBatteryLevel();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetSystemBatteryTemperature();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetSystemProductName")]
		private static extern IntPtr _ovrp_GetSystemProductName();

		public static string ovrp_GetSystemProductName()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetSystemProductName());
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_ShowSystemUI(PlatformUI ui);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetAppMonoscopic();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetAppMonoscopic(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetAppHasVrFocus();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetAppShouldQuit();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetAppShouldRecenter();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetAppLatencyTimings")]
		private static extern IntPtr _ovrp_GetAppLatencyTimings();

		public static string ovrp_GetAppLatencyTimings()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetAppLatencyTimings());
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetUserPresent();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetUserIPD();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetUserIPD(float value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetUserEyeDepth();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetUserEyeDepth(float value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetUserEyeHeight();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetUserEyeHeight(float value);
	}

	private static class OVRP_1_2_0
	{
		public static readonly Version version = new Version(1, 2, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetSystemVSyncCount(int vsyncCount);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrpi_SetTrackingCalibratedOrigin();
	}

	private static class OVRP_1_3_0
	{
		public static readonly Version version = new Version(1, 3, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetEyeOcclusionMeshEnabled();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetEyeOcclusionMeshEnabled(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetSystemHeadphonesPresent();
	}

	private static class OVRP_1_5_0
	{
		public static readonly Version version = new Version(1, 5, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemRegion ovrp_GetSystemRegion();
	}

	private static class OVRP_1_6_0
	{
		public static readonly Version version = new Version(1, 6, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetTrackingIPDEnabled();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetTrackingIPDEnabled(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern HapticsDesc ovrp_GetControllerHapticsDesc(uint controllerMask);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern HapticsState ovrp_GetControllerHapticsState(uint controllerMask);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetControllerHaptics(uint controllerMask, HapticsBuffer hapticsBuffer);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetOverlayQuad3(uint flags, IntPtr textureLeft, IntPtr textureRight, IntPtr device, Posef pose, Vector3f scale, int layerIndex);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetEyeRecommendedResolutionScale();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetAppCpuStartToGpuEndTime();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovrp_GetSystemRecommendedMSAALevel();
	}

	private static class OVRP_1_7_0
	{
		public static readonly Version version = new Version(1, 7, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetAppChromaticCorrection();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetAppChromaticCorrection(Bool value);
	}

	private static class OVRP_1_8_0
	{
		public static readonly Version version = new Version(1, 8, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetBoundaryConfigured();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern BoundaryTestResult ovrp_TestBoundaryNode(Node nodeId, BoundaryType boundaryType);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern BoundaryTestResult ovrp_TestBoundaryPoint(Vector3f point, BoundaryType boundaryType);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetBoundaryLookAndFeel(BoundaryLookAndFeel lookAndFeel);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_ResetBoundaryLookAndFeel();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern BoundaryGeometry ovrp_GetBoundaryGeometry(BoundaryType boundaryType);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Vector3f ovrp_GetBoundaryDimensions(BoundaryType boundaryType);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetBoundaryVisible();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetBoundaryVisible(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_Update2(int stateId, int frameIndex, double predictionSeconds);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodePose2(int stateId, Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodeVelocity2(int stateId, Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodeAcceleration2(int stateId, Node nodeId);
	}

	private static class OVRP_1_9_0
	{
		public static readonly Version version = new Version(1, 9, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemHeadset ovrp_GetSystemHeadsetType();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Controller ovrp_GetActiveController();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Controller ovrp_GetConnectedControllers();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetBoundaryGeometry2(BoundaryType boundaryType, IntPtr points, ref int pointsCount);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern AppPerfStats ovrp_GetAppPerfStats();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_ResetAppPerfStats();
	}

	private static class OVRP_1_10_0
	{
		public static readonly Version version = new Version(1, 10, 0);
	}

	private static class OVRP_1_11_0
	{
		public static readonly Version version = new Version(1, 11, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetDesiredEyeTextureFormat(EyeTextureFormat value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern EyeTextureFormat ovrp_GetDesiredEyeTextureFormat();
	}

	private static class OVRP_1_12_0
	{
		public static readonly Version version = new Version(1, 12, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern ControllerState2 ovrp_GetControllerState2(uint controllerMask);
	}

	public static readonly Version wrapperVersion = OVRP_1_12_0.version;

	private static Version _version;

	private static Version _nativeSDKVersion;

	private const int OverlayShapeFlagShift = 4;

	public const int AppPerfFrameStatsMaxCount = 5;

	private static Guid _cachedAudioOutGuid;

	private static string _cachedAudioOutString;

	private static Guid _cachedAudioInGuid;

	private static string _cachedAudioInString;

	private const string pluginName = "OVRPlugin";

	private static Version _versionZero = new Version(0, 0, 0);

	public static Version version
	{
		get
		{
			if (_version == null)
			{
				try
				{
					string text = OVRP_1_1_0.ovrp_GetVersion();
					if (text != null)
					{
						text = text.Split('-')[0];
						_version = new Version(text);
					}
					else
					{
						_version = _versionZero;
					}
				}
				catch
				{
					_version = _versionZero;
				}
				if (_version == OVRP_0_5_0.version)
				{
					_version = OVRP_0_1_0.version;
				}
				if (_version > _versionZero && _version < OVRP_1_3_0.version)
				{
					throw new PlatformNotSupportedException(string.Concat("Oculus Utilities version ", wrapperVersion, " is too new for OVRPlugin version ", _version.ToString(), ". Update to the latest version of Unity."));
				}
			}
			return _version;
		}
	}

	public static Version nativeSDKVersion
	{
		get
		{
			if (_nativeSDKVersion == null)
			{
				try
				{
					string empty = string.Empty;
					empty = ((!(version >= OVRP_1_1_0.version)) ? _versionZero.ToString() : OVRP_1_1_0.ovrp_GetNativeSDKVersion());
					if (empty != null)
					{
						empty = empty.Split('-')[0];
						_nativeSDKVersion = new Version(empty);
					}
					else
					{
						_nativeSDKVersion = _versionZero;
					}
				}
				catch
				{
					_nativeSDKVersion = _versionZero;
				}
			}
			return _nativeSDKVersion;
		}
	}

	public static bool initialized => OVRP_1_1_0.ovrp_GetInitialized() == Bool.True;

	public static bool chromatic
	{
		get
		{
			if (version >= OVRP_1_7_0.version)
			{
				return OVRP_1_7_0.ovrp_GetAppChromaticCorrection() == Bool.True;
			}
			return false;
		}
		set
		{
			if (version >= OVRP_1_7_0.version)
			{
				OVRP_1_7_0.ovrp_SetAppChromaticCorrection(ToBool(value));
			}
		}
	}

	public static bool monoscopic
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetAppMonoscopic() == Bool.True;
		}
		set
		{
			OVRP_1_1_0.ovrp_SetAppMonoscopic(ToBool(value));
		}
	}

	public static bool rotation
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetTrackingOrientationEnabled() == Bool.True;
		}
		set
		{
			OVRP_1_1_0.ovrp_SetTrackingOrientationEnabled(ToBool(value));
		}
	}

	public static bool position
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetTrackingPositionEnabled() == Bool.True;
		}
		set
		{
			OVRP_1_1_0.ovrp_SetTrackingPositionEnabled(ToBool(value));
		}
	}

	public static bool useIPDInPositionTracking
	{
		get
		{
			if (version >= OVRP_1_6_0.version)
			{
				return OVRP_1_6_0.ovrp_GetTrackingIPDEnabled() == Bool.True;
			}
			return true;
		}
		set
		{
			if (version >= OVRP_1_6_0.version)
			{
				OVRP_1_6_0.ovrp_SetTrackingIPDEnabled(ToBool(value));
			}
		}
	}

	public static bool positionSupported => OVRP_1_1_0.ovrp_GetTrackingPositionSupported() == Bool.True;

	public static bool positionTracked => OVRP_1_1_0.ovrp_GetNodePositionTracked(Node.EyeCenter) == Bool.True;

	public static bool powerSaving => OVRP_1_1_0.ovrp_GetSystemPowerSavingMode() == Bool.True;

	public static bool hmdPresent => OVRP_1_1_0.ovrp_GetNodePresent(Node.EyeCenter) == Bool.True;

	public static bool userPresent => OVRP_1_1_0.ovrp_GetUserPresent() == Bool.True;

	public static bool headphonesPresent => OVRP_1_3_0.ovrp_GetSystemHeadphonesPresent() == Bool.True;

	public static int recommendedMSAALevel
	{
		get
		{
			if (version >= OVRP_1_6_0.version)
			{
				return OVRP_1_6_0.ovrp_GetSystemRecommendedMSAALevel();
			}
			return 2;
		}
	}

	public static SystemRegion systemRegion
	{
		get
		{
			if (version >= OVRP_1_5_0.version)
			{
				return OVRP_1_5_0.ovrp_GetSystemRegion();
			}
			return SystemRegion.Unspecified;
		}
	}

	public static string audioOutId
	{
		get
		{
			try
			{
				IntPtr intPtr = OVRP_1_1_0.ovrp_GetAudioOutId();
				if (intPtr != IntPtr.Zero)
				{
					GUID gUID = (GUID)Marshal.PtrToStructure(intPtr, typeof(GUID));
					Guid guid = new Guid(gUID.a, gUID.b, gUID.c, gUID.d0, gUID.d1, gUID.d2, gUID.d3, gUID.d4, gUID.d5, gUID.d6, gUID.d7);
					if (guid != _cachedAudioOutGuid)
					{
						_cachedAudioOutGuid = guid;
						_cachedAudioOutString = _cachedAudioOutGuid.ToString();
					}
					return _cachedAudioOutString;
				}
			}
			catch
			{
			}
			return string.Empty;
		}
	}

	public static string audioInId
	{
		get
		{
			try
			{
				IntPtr intPtr = OVRP_1_1_0.ovrp_GetAudioInId();
				if (intPtr != IntPtr.Zero)
				{
					GUID gUID = (GUID)Marshal.PtrToStructure(intPtr, typeof(GUID));
					Guid guid = new Guid(gUID.a, gUID.b, gUID.c, gUID.d0, gUID.d1, gUID.d2, gUID.d3, gUID.d4, gUID.d5, gUID.d6, gUID.d7);
					if (guid != _cachedAudioInGuid)
					{
						_cachedAudioInGuid = guid;
						_cachedAudioInString = _cachedAudioInGuid.ToString();
					}
					return _cachedAudioInString;
				}
			}
			catch
			{
			}
			return string.Empty;
		}
	}

	public static bool hasVrFocus => OVRP_1_1_0.ovrp_GetAppHasVrFocus() == Bool.True;

	public static bool shouldQuit => OVRP_1_1_0.ovrp_GetAppShouldQuit() == Bool.True;

	public static bool shouldRecenter => OVRP_1_1_0.ovrp_GetAppShouldRecenter() == Bool.True;

	public static string productName => OVRP_1_1_0.ovrp_GetSystemProductName();

	public static string latency => OVRP_1_1_0.ovrp_GetAppLatencyTimings();

	public static float eyeDepth
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetUserEyeDepth();
		}
		set
		{
			OVRP_1_1_0.ovrp_SetUserEyeDepth(value);
		}
	}

	public static float eyeHeight
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetUserEyeHeight();
		}
		set
		{
			OVRP_1_1_0.ovrp_SetUserEyeHeight(value);
		}
	}

	public static float batteryLevel => OVRP_1_1_0.ovrp_GetSystemBatteryLevel();

	public static float batteryTemperature => OVRP_1_1_0.ovrp_GetSystemBatteryTemperature();

	public static int cpuLevel
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetSystemCpuLevel();
		}
		set
		{
			OVRP_1_1_0.ovrp_SetSystemCpuLevel(value);
		}
	}

	public static int gpuLevel
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetSystemGpuLevel();
		}
		set
		{
			OVRP_1_1_0.ovrp_SetSystemGpuLevel(value);
		}
	}

	public static int vsyncCount
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetSystemVSyncCount();
		}
		set
		{
			OVRP_1_2_0.ovrp_SetSystemVSyncCount(value);
		}
	}

	public static float systemVolume => OVRP_1_1_0.ovrp_GetSystemVolume();

	public static float ipd
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetUserIPD();
		}
		set
		{
			OVRP_1_1_0.ovrp_SetUserIPD(value);
		}
	}

	public static bool occlusionMesh
	{
		get
		{
			return OVRP_1_3_0.ovrp_GetEyeOcclusionMeshEnabled() == Bool.True;
		}
		set
		{
			OVRP_1_3_0.ovrp_SetEyeOcclusionMeshEnabled(ToBool(value));
		}
	}

	public static BatteryStatus batteryStatus => OVRP_1_1_0.ovrp_GetSystemBatteryStatus();

	public static Posef GetEyeVelocity(Eye eyeId)
	{
		return GetNodeVelocity((Node)eyeId, usePhysicsPose: false);
	}

	public static Posef GetEyeAcceleration(Eye eyeId)
	{
		return GetNodeAcceleration((Node)eyeId, usePhysicsPose: false);
	}

	public static Frustumf GetEyeFrustum(Eye eyeId)
	{
		return OVRP_1_1_0.ovrp_GetNodeFrustum((Node)eyeId);
	}

	public static Sizei GetEyeTextureSize(Eye eyeId)
	{
		return OVRP_0_1_0.ovrp_GetEyeTextureSize(eyeId);
	}

	public static Posef GetTrackerPose(Tracker trackerId)
	{
		return GetNodePose((Node)(trackerId + 5), usePhysicsPose: false);
	}

	public static Frustumf GetTrackerFrustum(Tracker trackerId)
	{
		return OVRP_1_1_0.ovrp_GetNodeFrustum((Node)(trackerId + 5));
	}

	public static bool ShowUI(PlatformUI ui)
	{
		return OVRP_1_1_0.ovrp_ShowSystemUI(ui) == Bool.True;
	}

	public static bool SetOverlayQuad(bool onTop, bool headLocked, IntPtr leftTexture, IntPtr rightTexture, IntPtr device, Posef pose, Vector3f scale, int layerIndex = 0, OverlayShape shape = OverlayShape.Quad)
	{
		if (version >= OVRP_1_6_0.version)
		{
			uint num = 0u;
			if (onTop)
			{
				num |= 1u;
			}
			if (headLocked)
			{
				num |= 2u;
			}
			if (shape == OverlayShape.Cylinder || shape == OverlayShape.Cubemap)
			{
				if (!(version >= OVRP_1_7_0.version))
				{
					return false;
				}
				num |= (uint)((int)shape << 4);
			}
			if (shape == OverlayShape.OffcenterCubemap)
			{
				if (!(version >= OVRP_1_11_0.version))
				{
					return false;
				}
				num |= (uint)((int)shape << 4);
			}
			return OVRP_1_6_0.ovrp_SetOverlayQuad3(num, leftTexture, rightTexture, device, pose, scale, layerIndex) == Bool.True;
		}
		if (layerIndex != 0)
		{
			return false;
		}
		return OVRP_0_1_1.ovrp_SetOverlayQuad2(ToBool(onTop), ToBool(headLocked), leftTexture, device, pose, scale) == Bool.True;
	}

	public static bool UpdateNodePhysicsPoses(int frameIndex, double predictionSeconds)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_Update2(0, frameIndex, predictionSeconds) == Bool.True;
		}
		return false;
	}

	public static Posef GetNodePose(Node nodeId, bool usePhysicsPose)
	{
		if (version >= OVRP_1_8_0.version && usePhysicsPose)
		{
			return OVRP_1_8_0.ovrp_GetNodePose2(0, nodeId);
		}
		return OVRP_0_1_2.ovrp_GetNodePose(nodeId);
	}

	public static Posef GetNodeVelocity(Node nodeId, bool usePhysicsPose)
	{
		if (version >= OVRP_1_8_0.version && usePhysicsPose)
		{
			return OVRP_1_8_0.ovrp_GetNodeVelocity2(0, nodeId);
		}
		return OVRP_0_1_3.ovrp_GetNodeVelocity(nodeId);
	}

	public static Posef GetNodeAcceleration(Node nodeId, bool usePhysicsPose)
	{
		if (version >= OVRP_1_8_0.version && usePhysicsPose)
		{
			return OVRP_1_8_0.ovrp_GetNodeAcceleration2(0, nodeId);
		}
		return OVRP_0_1_3.ovrp_GetNodeAcceleration(nodeId);
	}

	public static bool GetNodePresent(Node nodeId)
	{
		return OVRP_1_1_0.ovrp_GetNodePresent(nodeId) == Bool.True;
	}

	public static bool GetNodeOrientationTracked(Node nodeId)
	{
		return OVRP_1_1_0.ovrp_GetNodeOrientationTracked(nodeId) == Bool.True;
	}

	public static bool GetNodePositionTracked(Node nodeId)
	{
		return OVRP_1_1_0.ovrp_GetNodePositionTracked(nodeId) == Bool.True;
	}

	public static ControllerState GetControllerState(uint controllerMask)
	{
		return OVRP_1_1_0.ovrp_GetControllerState(controllerMask);
	}

	public static ControllerState2 GetControllerState2(uint controllerMask)
	{
		if (version >= OVRP_1_12_0.version)
		{
			return OVRP_1_12_0.ovrp_GetControllerState2(controllerMask);
		}
		return new ControllerState2(OVRP_1_1_0.ovrp_GetControllerState(controllerMask));
	}

	public static bool SetControllerVibration(uint controllerMask, float frequency, float amplitude)
	{
		return OVRP_0_1_2.ovrp_SetControllerVibration(controllerMask, frequency, amplitude) == Bool.True;
	}

	public static HapticsDesc GetControllerHapticsDesc(uint controllerMask)
	{
		if (version >= OVRP_1_6_0.version)
		{
			return OVRP_1_6_0.ovrp_GetControllerHapticsDesc(controllerMask);
		}
		return default(HapticsDesc);
	}

	public static HapticsState GetControllerHapticsState(uint controllerMask)
	{
		if (version >= OVRP_1_6_0.version)
		{
			return OVRP_1_6_0.ovrp_GetControllerHapticsState(controllerMask);
		}
		return default(HapticsState);
	}

	public static bool SetControllerHaptics(uint controllerMask, HapticsBuffer hapticsBuffer)
	{
		if (version >= OVRP_1_6_0.version)
		{
			return OVRP_1_6_0.ovrp_SetControllerHaptics(controllerMask, hapticsBuffer) == Bool.True;
		}
		return false;
	}

	public static float GetEyeRecommendedResolutionScale()
	{
		if (version >= OVRP_1_6_0.version)
		{
			return OVRP_1_6_0.ovrp_GetEyeRecommendedResolutionScale();
		}
		return 1f;
	}

	public static float GetAppCpuStartToGpuEndTime()
	{
		if (version >= OVRP_1_6_0.version)
		{
			return OVRP_1_6_0.ovrp_GetAppCpuStartToGpuEndTime();
		}
		return 0f;
	}

	public static bool GetBoundaryConfigured()
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_GetBoundaryConfigured() == Bool.True;
		}
		return false;
	}

	public static BoundaryTestResult TestBoundaryNode(Node nodeId, BoundaryType boundaryType)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_TestBoundaryNode(nodeId, boundaryType);
		}
		return default(BoundaryTestResult);
	}

	public static BoundaryTestResult TestBoundaryPoint(Vector3f point, BoundaryType boundaryType)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_TestBoundaryPoint(point, boundaryType);
		}
		return default(BoundaryTestResult);
	}

	public static bool SetBoundaryLookAndFeel(BoundaryLookAndFeel lookAndFeel)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_SetBoundaryLookAndFeel(lookAndFeel) == Bool.True;
		}
		return false;
	}

	public static bool ResetBoundaryLookAndFeel()
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_ResetBoundaryLookAndFeel() == Bool.True;
		}
		return false;
	}

	public static BoundaryGeometry GetBoundaryGeometry(BoundaryType boundaryType)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_GetBoundaryGeometry(boundaryType);
		}
		return default(BoundaryGeometry);
	}

	public static bool GetBoundaryGeometry2(BoundaryType boundaryType, IntPtr points, ref int pointsCount)
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_GetBoundaryGeometry2(boundaryType, points, ref pointsCount) == Bool.True;
		}
		pointsCount = 0;
		return false;
	}

	public static AppPerfStats GetAppPerfStats()
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_GetAppPerfStats();
		}
		return default(AppPerfStats);
	}

	public static bool ResetAppPerfStats()
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_ResetAppPerfStats() == Bool.True;
		}
		return false;
	}

	public static EyeTextureFormat GetDesiredEyeTextureFormat()
	{
		if (version >= OVRP_1_11_0.version)
		{
			uint num = (uint)OVRP_1_11_0.ovrp_GetDesiredEyeTextureFormat();
			if (num == 1)
			{
				num = 0u;
			}
			return (EyeTextureFormat)num;
		}
		return EyeTextureFormat.Default;
	}

	public static bool SetDesiredEyeTextureFormat(EyeTextureFormat value)
	{
		if (version >= OVRP_1_11_0.version)
		{
			return OVRP_1_11_0.ovrp_SetDesiredEyeTextureFormat(value) == Bool.True;
		}
		return false;
	}

	public static Vector3f GetBoundaryDimensions(BoundaryType boundaryType)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_GetBoundaryDimensions(boundaryType);
		}
		return default(Vector3f);
	}

	public static bool GetBoundaryVisible()
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_GetBoundaryVisible() == Bool.True;
		}
		return false;
	}

	public static bool SetBoundaryVisible(bool value)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_SetBoundaryVisible(ToBool(value)) == Bool.True;
		}
		return false;
	}

	public static SystemHeadset GetSystemHeadsetType()
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_GetSystemHeadsetType();
		}
		return SystemHeadset.None;
	}

	public static Controller GetActiveController()
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_GetActiveController();
		}
		return Controller.None;
	}

	public static Controller GetConnectedControllers()
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_GetConnectedControllers();
		}
		return Controller.None;
	}

	private static Bool ToBool(bool b)
	{
		return b ? Bool.True : Bool.False;
	}

	public static TrackingOrigin GetTrackingOriginType()
	{
		return OVRP_1_0_0.ovrp_GetTrackingOriginType();
	}

	public static bool SetTrackingOriginType(TrackingOrigin originType)
	{
		return OVRP_1_0_0.ovrp_SetTrackingOriginType(originType) == Bool.True;
	}

	public static Posef GetTrackingCalibratedOrigin()
	{
		return OVRP_1_0_0.ovrp_GetTrackingCalibratedOrigin();
	}

	public static bool SetTrackingCalibratedOrigin()
	{
		return OVRP_1_2_0.ovrpi_SetTrackingCalibratedOrigin() == Bool.True;
	}

	public static bool RecenterTrackingOrigin(RecenterFlags flags)
	{
		return OVRP_1_0_0.ovrp_RecenterTrackingOrigin((uint)flags) == Bool.True;
	}
}
public class OVRProfile : UnityEngine.Object
{
	[Obsolete]
	public enum State
	{
		NOT_TRIGGERED,
		LOADING,
		READY,
		ERROR
	}

	[Obsolete]
	public string id => "000abc123def";

	[Obsolete]
	public string userName => "Oculus User";

	[Obsolete]
	public string locale => "en_US";

	public float ipd => Vector3.Distance(OVRPlugin.GetNodePose(OVRPlugin.Node.EyeLeft, usePhysicsPose: false).ToOVRPose().position, OVRPlugin.GetNodePose(OVRPlugin.Node.EyeRight, usePhysicsPose: false).ToOVRPose().position);

	public float eyeHeight => OVRPlugin.eyeHeight;

	public float eyeDepth => OVRPlugin.eyeDepth;

	public float neckHeight => eyeHeight - 0.075f;

	[Obsolete]
	public State state => State.READY;
}
public static class OVRTouchpad
{
	public enum TouchEvent
	{
		SingleTap,
		Left,
		Right,
		Up,
		Down
	}

	public class TouchArgs : EventArgs
	{
		public TouchEvent TouchType;
	}

	private enum TouchState
	{
		Init,
		Down,
		Stationary,
		Move,
		Up
	}

	private static TouchState touchState = TouchState.Init;

	private static float minMovMagnitude = 100f;

	private static Vector3 moveAmountMouse;

	private static float minMovMagnitudeMouse = 25f;

	private static OVRTouchpadHelper touchpadHelper = new GameObject("OVRTouchpadHelper").AddComponent<OVRTouchpadHelper>();

	public static event EventHandler TouchHandler;

	public static void Create()
	{
	}

	public static void Update()
	{
		if (Input.GetMouseButtonDown(0))
		{
			moveAmountMouse = Input.mousePosition;
			touchState = TouchState.Down;
		}
		else if (Input.GetMouseButtonUp(0))
		{
			moveAmountMouse -= Input.mousePosition;
			HandleInputMouse(ref moveAmountMouse);
			touchState = TouchState.Init;
		}
	}

	public static void OnDisable()
	{
	}

	private static void HandleInput(TouchState state, ref Vector2 move)
	{
		if (move.magnitude < minMovMagnitude || touchState == TouchState.Stationary || touchState != TouchState.Move)
		{
			return;
		}
		move.Normalize();
		if (Mathf.Abs(move.x) > Mathf.Abs(move.y))
		{
			if (!(move.x > 0f))
			{
			}
		}
		else if (!(move.y > 0f))
		{
		}
	}

	private static void HandleInputMouse(ref Vector3 move)
	{
		if (move.magnitude < minMovMagnitudeMouse)
		{
			if (OVRTouchpad.TouchHandler != null)
			{
				OVRTouchpad.TouchHandler(null, new TouchArgs
				{
					TouchType = TouchEvent.SingleTap
				});
			}
			return;
		}
		move.Normalize();
		if (Mathf.Abs(move.x) > Mathf.Abs(move.y))
		{
			if (move.x > 0f)
			{
				if (OVRTouchpad.TouchHandler != null)
				{
					OVRTouchpad.TouchHandler(null, new TouchArgs
					{
						TouchType = TouchEvent.Left
					});
				}
			}
			else if (OVRTouchpad.TouchHandler != null)
			{
				OVRTouchpad.TouchHandler(null, new TouchArgs
				{
					TouchType = TouchEvent.Right
				});
			}
		}
		else if (move.y > 0f)
		{
			if (OVRTouchpad.TouchHandler != null)
			{
				OVRTouchpad.TouchHandler(null, new TouchArgs
				{
					TouchType = TouchEvent.Down
				});
			}
		}
		else if (OVRTouchpad.TouchHandler != null)
		{
			OVRTouchpad.TouchHandler(null, new TouchArgs
			{
				TouchType = TouchEvent.Up
			});
		}
	}
}
public sealed class OVRTouchpadHelper : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void Start()
	{
		OVRTouchpad.TouchHandler += LocalTouchEventCallback;
	}

	private void Update()
	{
		OVRTouchpad.Update();
	}

	public void OnDisable()
	{
		OVRTouchpad.OnDisable();
	}

	private void LocalTouchEventCallback(object sender, EventArgs args)
	{
		OVRTouchpad.TouchArgs touchArgs = (OVRTouchpad.TouchArgs)args;
		switch (touchArgs.TouchType)
		{
		case OVRTouchpad.TouchEvent.SingleTap:
			break;
		case OVRTouchpad.TouchEvent.Left:
			break;
		case OVRTouchpad.TouchEvent.Right:
			break;
		case OVRTouchpad.TouchEvent.Up:
			break;
		case OVRTouchpad.TouchEvent.Down:
			break;
		}
	}
}
public class OVRTracker
{
	public struct Frustum
	{
		public float nearZ;

		public float farZ;

		public Vector2 fov;
	}

	public bool isPresent
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return false;
			}
			return OVRPlugin.positionSupported;
		}
	}

	public bool isPositionTracked => OVRPlugin.positionTracked;

	public bool isEnabled
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return false;
			}
			return OVRPlugin.position;
		}
		set
		{
			if (OVRManager.isHmdPresent)
			{
				OVRPlugin.position = value;
			}
		}
	}

	public int count
	{
		get
		{
			int num = 0;
			for (int i = 0; i < 4; i++)
			{
				if (GetPresent(i))
				{
					num++;
				}
			}
			return num;
		}
	}

	public Frustum GetFrustum(int tracker = 0)
	{
		if (!OVRManager.isHmdPresent)
		{
			return default(Frustum);
		}
		return OVRPlugin.GetTrackerFrustum((OVRPlugin.Tracker)tracker).ToFrustum();
	}

	public OVRPose GetPose(int tracker = 0)
	{
		if (!OVRManager.isHmdPresent)
		{
			return OVRPose.identity;
		}
		OVRPose oVRPose;
		switch (tracker)
		{
		case 0:
			oVRPose = OVRPlugin.GetNodePose(OVRPlugin.Node.TrackerZero, usePhysicsPose: false).ToOVRPose();
			break;
		case 1:
			oVRPose = OVRPlugin.GetNodePose(OVRPlugin.Node.TrackerOne, usePhysicsPose: false).ToOVRPose();
			break;
		case 2:
			oVRPose = OVRPlugin.GetNodePose(OVRPlugin.Node.TrackerTwo, usePhysicsPose: false).ToOVRPose();
			break;
		case 3:
			oVRPose = OVRPlugin.GetNodePose(OVRPlugin.Node.TrackerThree, usePhysicsPose: false).ToOVRPose();
			break;
		default:
			return OVRPose.identity;
		}
		OVRPose result = default(OVRPose);
		result.position = oVRPose.position;
		result.orientation = oVRPose.orientation * Quaternion.Euler(0f, 180f, 0f);
		return result;
	}

	public bool GetPoseValid(int tracker = 0)
	{
		if (!OVRManager.isHmdPresent)
		{
			return false;
		}
		return tracker switch
		{
			0 => OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.TrackerZero), 
			1 => OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.TrackerOne), 
			2 => OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.TrackerTwo), 
			3 => OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.TrackerThree), 
			_ => false, 
		};
	}

	public bool GetPresent(int tracker = 0)
	{
		if (!OVRManager.isHmdPresent)
		{
			return false;
		}
		return tracker switch
		{
			0 => OVRPlugin.GetNodePresent(OVRPlugin.Node.TrackerZero), 
			1 => OVRPlugin.GetNodePresent(OVRPlugin.Node.TrackerOne), 
			2 => OVRPlugin.GetNodePresent(OVRPlugin.Node.TrackerTwo), 
			3 => OVRPlugin.GetNodePresent(OVRPlugin.Node.TrackerThree), 
			_ => false, 
		};
	}
}
public class OVRChromaticAberration : MonoBehaviour
{
	public OVRInput.RawButton toggleButton = OVRInput.RawButton.X;

	private bool chromatic;

	private void Start()
	{
		OVRManager.instance.chromatic = chromatic;
	}

	private void Update()
	{
		if (OVRInput.GetDown(toggleButton))
		{
			chromatic = !chromatic;
			OVRManager.instance.chromatic = chromatic;
		}
	}
}
public class OVRCubemapCapture : MonoBehaviour
{
	public bool autoTriggerAfterLaunch = true;

	public float autoTriggerDelay = 1f;

	private float autoTriggerElapse;

	public KeyCode triggeredByKey = KeyCode.F8;

	public string pathName;

	public int cubemapSize = 2048;

	private void Update()
	{
		if (autoTriggerAfterLaunch)
		{
			autoTriggerElapse += Time.deltaTime;
			if (autoTriggerElapse >= autoTriggerDelay)
			{
				autoTriggerAfterLaunch = false;
				TriggerCubemapCapture(base.transform.position, cubemapSize, pathName);
			}
		}
		if (Input.GetKeyDown(triggeredByKey))
		{
			TriggerCubemapCapture(base.transform.position, cubemapSize, pathName);
		}
	}

	public static void TriggerCubemapCapture(Vector3 capturePos, int cubemapSize = 2048, string pathName = null)
	{
		GameObject gameObject = new GameObject("CubemapCamera", typeof(Camera));
		gameObject.hideFlags = HideFlags.HideAndDontSave;
		gameObject.transform.position = capturePos;
		gameObject.transform.rotation = Quaternion.identity;
		Camera component = gameObject.GetComponent<Camera>();
		component.farClipPlane = 10000f;
		component.enabled = false;
		Cubemap cubemap = new Cubemap(cubemapSize, TextureFormat.RGB24, mipmap: false);
		RenderIntoCubemap(component, cubemap);
		SaveCubemapCapture(cubemap, pathName);
		UnityEngine.Object.DestroyImmediate(cubemap);
		UnityEngine.Object.DestroyImmediate(gameObject);
	}

	public static void RenderIntoCubemap(Camera ownerCamera, Cubemap outCubemap)
	{
		int width = outCubemap.width;
		int height = outCubemap.height;
		CubemapFace[] array = new CubemapFace[6]
		{
			CubemapFace.PositiveX,
			CubemapFace.NegativeX,
			CubemapFace.PositiveY,
			CubemapFace.NegativeY,
			CubemapFace.PositiveZ,
			CubemapFace.NegativeZ
		};
		Vector3[] array2 = new Vector3[6]
		{
			new Vector3(0f, 90f, 0f),
			new Vector3(0f, -90f, 0f),
			new Vector3(-90f, 0f, 0f),
			new Vector3(90f, 0f, 0f),
			new Vector3(0f, 0f, 0f),
			new Vector3(0f, 180f, 0f)
		};
		RenderTexture active = RenderTexture.active;
		float fieldOfView = ownerCamera.fieldOfView;
		float aspect = ownerCamera.aspect;
		Quaternion rotation = ownerCamera.transform.rotation;
		RenderTexture renderTexture = new RenderTexture(width, height, 24);
		renderTexture.antiAliasing = 8;
		renderTexture.dimension = TextureDimension.Tex2D;
		renderTexture.hideFlags = HideFlags.HideAndDontSave;
		Texture2D texture2D = new Texture2D(width, height, TextureFormat.RGB24, mipmap: false);
		texture2D.hideFlags = HideFlags.HideAndDontSave;
		ownerCamera.targetTexture = renderTexture;
		ownerCamera.fieldOfView = 90f;
		ownerCamera.aspect = 1f;
		UnityEngine.Color[] array3 = new UnityEngine.Color[texture2D.height * texture2D.width];
		for (int i = 0; i < array.Length; i++)
		{
			ownerCamera.transform.eulerAngles = array2[i];
			ownerCamera.Render();
			RenderTexture.active = renderTexture;
			texture2D.ReadPixels(new Rect(0f, 0f, width, height), 0, 0);
			UnityEngine.Color[] pixels = texture2D.GetPixels();
			for (int j = 0; j < height; j++)
			{
				for (int k = 0; k < width; k++)
				{
					ref UnityEngine.Color reference = ref array3[j * width + k];
					reference = pixels[(height - 1 - j) * width + k];
				}
			}
			outCubemap.SetPixels(array3, array[i]);
		}
		outCubemap.SmoothEdges();
		RenderTexture.active = active;
		ownerCamera.fieldOfView = fieldOfView;
		ownerCamera.aspect = aspect;
		ownerCamera.transform.rotation = rotation;
		ownerCamera.targetTexture = active;
		UnityEngine.Object.DestroyImmediate(texture2D);
		UnityEngine.Object.DestroyImmediate(renderTexture);
	}

	public static bool SaveCubemapCapture(Cubemap cubemap, string pathName = null)
	{
		int width = cubemap.width;
		int height = cubemap.height;
		int num = 0;
		int y = 0;
		bool flag = true;
		string text;
		string text2;
		if (string.IsNullOrEmpty(pathName))
		{
			text = Application.persistentDataPath + "/OVR_ScreenShot360/";
			text2 = null;
		}
		else
		{
			text = Path.GetDirectoryName(pathName);
			text2 = Path.GetFileName(pathName);
			if (text[text.Length - 1] != '/' || text[text.Length - 1] != '\\')
			{
				text += "/";
			}
		}
		if (string.IsNullOrEmpty(text2))
		{
			text2 = "OVR_" + DateTime.Now.ToString("hh_mm_ss") + ".png";
		}
		string extension = Path.GetExtension(text2);
		if (extension == ".png")
		{
			flag = true;
		}
		else
		{
			if (!(extension == ".jpg"))
			{
				UnityEngine.Debug.LogError("Unsupported file format" + extension);
				return false;
			}
			flag = false;
		}
		try
		{
			Directory.CreateDirectory(text);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("Failed to create path " + text + " since " + ex.ToString());
			return false;
		}
		Texture2D texture2D = new Texture2D(width * 6, height, TextureFormat.RGB24, mipmap: false);
		if (texture2D == null)
		{
			UnityEngine.Debug.LogError("[OVRScreenshotWizard] Failed creating the texture!");
			return false;
		}
		CubemapFace[] array = new CubemapFace[6]
		{
			CubemapFace.PositiveX,
			CubemapFace.NegativeX,
			CubemapFace.PositiveY,
			CubemapFace.NegativeY,
			CubemapFace.PositiveZ,
			CubemapFace.NegativeZ
		};
		for (int i = 0; i < array.Length; i++)
		{
			UnityEngine.Color[] array2 = null;
			UnityEngine.Color[] pixels = cubemap.GetPixels(array[i]);
			array2 = new UnityEngine.Color[pixels.Length];
			for (int j = 0; j < height; j++)
			{
				for (int k = 0; k < width; k++)
				{
					ref UnityEngine.Color reference = ref array2[j * width + k];
					reference = pixels[(height - 1 - j) * width + k];
				}
			}
			texture2D.SetPixels(num, y, width, height, array2);
			num += width;
		}
		try
		{
			byte[] bytes = ((!flag) ? texture2D.EncodeToJPG() : texture2D.EncodeToPNG());
			File.WriteAllBytes(text + text2, bytes);
			UnityEngine.Debug.Log("Cubemap file created " + text + text2);
		}
		catch (Exception ex2)
		{
			UnityEngine.Debug.LogError("Failed to save cubemap file since " + ex2.ToString());
			return false;
		}
		UnityEngine.Object.DestroyImmediate(texture2D);
		return true;
	}
}
public class OVRDebugInfo : MonoBehaviour
{
	private GameObject debugUIManager;

	private GameObject debugUIObject;

	private GameObject riftPresent;

	private GameObject fps;

	private GameObject ipd;

	private GameObject fov;

	private GameObject height;

	private GameObject depth;

	private GameObject resolutionEyeTexture;

	private GameObject latencies;

	private GameObject texts;

	private string strRiftPresent;

	private string strFPS;

	private string strIPD;

	private string strFOV;

	private string strHeight;

	private string strDepth;

	private string strResolutionEyeTexture;

	private string strLatencies;

	private float updateInterval = 0.5f;

	private float accum;

	private int frames;

	private float timeLeft;

	private bool initUIComponent;

	private bool isInited;

	private float offsetY = 55f;

	private float riftPresentTimeout;

	private bool showVRVars;

	private void Awake()
	{
		debugUIManager = new GameObject();
		debugUIManager.name = "DebugUIManager";
		debugUIManager.transform.parent = GameObject.Find("LeftEyeAnchor").transform;
		RectTransform rectTransform = debugUIManager.AddComponent<RectTransform>();
		rectTransform.sizeDelta = new Vector2(100f, 100f);
		rectTransform.localScale = new Vector3(0.001f, 0.001f, 0.001f);
		rectTransform.localPosition = new Vector3(0.01f, 0.17f, 0.53f);
		rectTransform.localEulerAngles = Vector3.zero;
		Canvas canvas = debugUIManager.AddComponent<Canvas>();
		canvas.renderMode = RenderMode.WorldSpace;
		canvas.pixelPerfect = false;
	}

	private void Update()
	{
		if (initUIComponent && !isInited)
		{
			InitUIComponents();
		}
		if (Input.GetKeyDown(KeyCode.Space) && riftPresentTimeout < 0f)
		{
			initUIComponent = true;
			showVRVars ^= true;
		}
		UpdateDeviceDetection();
		if (showVRVars)
		{
			debugUIManager.SetActive(value: true);
			UpdateVariable();
			UpdateStrings();
		}
		else
		{
			debugUIManager.SetActive(value: false);
		}
	}

	private void OnDestroy()
	{
		isInited = false;
	}

	private void InitUIComponents()
	{
		float num = 0f;
		int fontSize = 20;
		debugUIObject = new GameObject();
		debugUIObject.name = "DebugInfo";
		debugUIObject.transform.parent = GameObject.Find("DebugUIManager").transform;
		debugUIObject.transform.localPosition = new Vector3(0f, 100f, 0f);
		debugUIObject.transform.localEulerAngles = Vector3.zero;
		debugUIObject.transform.localScale = new Vector3(1f, 1f, 1f);
		if (!string.IsNullOrEmpty(strFPS))
		{
			fps = VariableObjectManager(fps, "FPS", num -= offsetY, strFPS, fontSize);
		}
		if (!string.IsNullOrEmpty(strIPD))
		{
			ipd = VariableObjectManager(ipd, "IPD", num -= offsetY, strIPD, fontSize);
		}
		if (!string.IsNullOrEmpty(strFOV))
		{
			fov = VariableObjectManager(fov, "FOV", num -= offsetY, strFOV, fontSize);
		}
		if (!string.IsNullOrEmpty(strHeight))
		{
			height = VariableObjectManager(height, "Height", num -= offsetY, strHeight, fontSize);
		}
		if (!string.IsNullOrEmpty(strDepth))
		{
			depth = VariableObjectManager(depth, "Depth", num -= offsetY, strDepth, fontSize);
		}
		if (!string.IsNullOrEmpty(strResolutionEyeTexture))
		{
			resolutionEyeTexture = VariableObjectManager(resolutionEyeTexture, "Resolution", num -= offsetY, strResolutionEyeTexture, fontSize);
		}
		if (!string.IsNullOrEmpty(strLatencies))
		{
			latencies = VariableObjectManager(latencies, "Latency", num -= offsetY, strLatencies, 17);
			num = 0f;
		}
		initUIComponent = false;
		isInited = true;
	}

	private void UpdateVariable()
	{
		UpdateIPD();
		UpdateEyeHeightOffset();
		UpdateEyeDepthOffset();
		UpdateFOV();
		UpdateResolutionEyeTexture();
		UpdateLatencyValues();
		UpdateFPS();
	}

	private void UpdateStrings()
	{
		if (!(debugUIObject == null))
		{
			if (!string.IsNullOrEmpty(strFPS))
			{
				fps.GetComponentInChildren<Text>().text = strFPS;
			}
			if (!string.IsNullOrEmpty(strIPD))
			{
				ipd.GetComponentInChildren<Text>().text = strIPD;
			}
			if (!string.IsNullOrEmpty(strFOV))
			{
				fov.GetComponentInChildren<Text>().text = strFOV;
			}
			if (!string.IsNullOrEmpty(strResolutionEyeTexture))
			{
				resolutionEyeTexture.GetComponentInChildren<Text>().text = strResolutionEyeTexture;
			}
			if (!string.IsNullOrEmpty(strLatencies))
			{
				latencies.GetComponentInChildren<Text>().text = strLatencies;
				latencies.GetComponentInChildren<Text>().fontSize = 14;
			}
			if (!string.IsNullOrEmpty(strHeight))
			{
				height.GetComponentInChildren<Text>().text = strHeight;
			}
			if (!string.IsNullOrEmpty(strDepth))
			{
				depth.GetComponentInChildren<Text>().text = strDepth;
			}
		}
	}

	private void RiftPresentGUI(GameObject guiMainOBj)
	{
		riftPresent = ComponentComposition(riftPresent);
		riftPresent.transform.SetParent(guiMainOBj.transform);
		riftPresent.name = "RiftPresent";
		RectTransform component = riftPresent.GetComponent<RectTransform>();
		component.localPosition = new Vector3(0f, 0f, 0f);
		component.localScale = new Vector3(1f, 1f, 1f);
		component.localEulerAngles = Vector3.zero;
		Text componentInChildren = riftPresent.GetComponentInChildren<Text>();
		componentInChildren.text = strRiftPresent;
		componentInChildren.fontSize = 20;
	}

	private void UpdateDeviceDetection()
	{
		if (riftPresentTimeout >= 0f)
		{
			riftPresentTimeout -= Time.deltaTime;
		}
	}

	private GameObject VariableObjectManager(GameObject gameObject, string name, float posY, string str, int fontSize)
	{
		gameObject = ComponentComposition(gameObject);
		gameObject.name = name;
		gameObject.transform.SetParent(debugUIObject.transform);
		RectTransform component = gameObject.GetComponent<RectTransform>();
		component.localPosition = new Vector3(0f, posY -= offsetY, 0f);
		Text componentInChildren = gameObject.GetComponentInChildren<Text>();
		componentInChildren.text = str;
		componentInChildren.fontSize = fontSize;
		gameObject.transform.localEulerAngles = Vector3.zero;
		component.localScale = new Vector3(1f, 1f, 1f);
		return gameObject;
	}

	private GameObject ComponentComposition(GameObject GO)
	{
		GO = new GameObject();
		GO.AddComponent<RectTransform>();
		GO.AddComponent<CanvasRenderer>();
		GO.AddComponent<UnityEngine.UI.Image>();
		GO.GetComponent<RectTransform>().sizeDelta = new Vector2(350f, 50f);
		GO.GetComponent<UnityEngine.UI.Image>().color = new UnityEngine.Color(0.02745098f, 0.1764706f, 0.2784314f, 40f / 51f);
		texts = new GameObject();
		texts.AddComponent<RectTransform>();
		texts.AddComponent<CanvasRenderer>();
		texts.AddComponent<Text>();
		texts.GetComponent<RectTransform>().sizeDelta = new Vector2(350f, 50f);
		texts.GetComponent<Text>().font = Resources.GetBuiltinResource(typeof(UnityEngine.Font), "Arial.ttf") as UnityEngine.Font;
		texts.GetComponent<Text>().alignment = TextAnchor.MiddleCenter;
		texts.transform.SetParent(GO.transform);
		texts.name = "TextBox";
		return GO;
	}

	private void UpdateIPD()
	{
		strIPD = $"IPD (mm): {OVRManager.profile.ipd * 1000f:F4}";
	}

	private void UpdateEyeHeightOffset()
	{
		float eyeHeight = OVRManager.profile.eyeHeight;
		strHeight = $"Eye Height (m): {eyeHeight:F3}";
	}

	private void UpdateEyeDepthOffset()
	{
		float eyeDepth = OVRManager.profile.eyeDepth;
		strDepth = $"Eye Depth (m): {eyeDepth:F3}";
	}

	private void UpdateFOV()
	{
		strFOV = $"FOV (deg): {OVRManager.display.GetEyeRenderDesc(VRNode.LeftEye).fov.y:F3}";
	}

	private void UpdateResolutionEyeTexture()
	{
		OVRDisplay.EyeRenderDesc eyeRenderDesc = OVRManager.display.GetEyeRenderDesc(VRNode.LeftEye);
		OVRDisplay.EyeRenderDesc eyeRenderDesc2 = OVRManager.display.GetEyeRenderDesc(VRNode.RightEye);
		float renderScale = VRSettings.renderScale;
		float num = (int)(renderScale * (eyeRenderDesc.resolution.x + eyeRenderDesc2.resolution.x));
		float num2 = (int)(renderScale * Mathf.Max(eyeRenderDesc.resolution.y, eyeRenderDesc2.resolution.y));
		strResolutionEyeTexture = $"Resolution : {num} x {num2}";
	}

	private void UpdateLatencyValues()
	{
	}

	private void UpdateFPS()
	{
		timeLeft -= Time.unscaledDeltaTime;
		accum += Time.unscaledDeltaTime;
		frames++;
		if ((double)timeLeft <= 0.0)
		{
			float num = (float)frames / accum;
			strFPS = $"FPS: {num:F2}";
			timeLeft += updateInterval;
			accum = 0f;
			frames = 0;
		}
	}
}
public class OVRGearVrController : MonoBehaviour
{
	public GameObject m_model;

	private bool m_prevControllerConnected;

	private bool m_prevControllerConnectedCached;

	private void Start()
	{
	}

	private void Update()
	{
		if (!(SceneManager.GetActiveScene().name == "Splash_Climax") && !(SceneManager.GetActiveScene().name == "Boot") && !(SceneManager.GetActiveScene().name == "Opening"))
		{
			bool flag = OVRInput.IsControllerConnected(OVRInput.Controller.LTrackedRemote) || OVRInput.IsControllerConnected(OVRInput.Controller.RTrackedRemote);
			if (flag != m_prevControllerConnected || !m_prevControllerConnectedCached)
			{
				m_model.SetActive(flag);
				m_prevControllerConnected = flag;
				m_prevControllerConnectedCached = true;
			}
			if (flag)
			{
				base.transform.localRotation = OVRInput.GetLocalControllerRotation(OVRInput.GetActiveController());
				base.transform.localPosition = OVRInput.GetLocalControllerPosition(OVRInput.GetActiveController());
			}
		}
	}
}
public class OVRGearVrControllerTest : MonoBehaviour
{
	public class BoolMonitor
	{
		public delegate bool BoolGenerator();

		private string m_name = string.Empty;

		private BoolGenerator m_generator;

		private bool m_currentValue;

		private float m_displayTimeout;

		private float m_displayTimer;

		public BoolMonitor(string name, BoolGenerator generator, float displayTimeout = 0.5f)
		{
			m_name = name;
			m_generator = generator;
			m_displayTimeout = displayTimeout;
		}

		public void Update()
		{
			m_currentValue = m_generator();
			if (m_currentValue)
			{
				m_displayTimer = m_displayTimeout;
			}
			m_displayTimer -= Time.deltaTime;
			if (m_displayTimer < 0f)
			{
				m_displayTimer = 0f;
			}
		}

		public override string ToString()
		{
			return "<b>" + m_name + ": </b>" + ((!(m_displayTimer > 0f)) ? "<color=black>" : "<color=red>") + m_currentValue + "</color>";
		}
	}

	public Text uiText;

	private List<BoolMonitor> monitors;

	private void Start()
	{
		if (uiText != null)
		{
			uiText.supportRichText = true;
		}
		monitors = new List<BoolMonitor>
		{
			new BoolMonitor("One", () => OVRInput.Get(OVRInput.Button.One)),
			new BoolMonitor("OneDown", () => OVRInput.GetDown(OVRInput.Button.One)),
			new BoolMonitor("OneUp", () => OVRInput.GetUp(OVRInput.Button.One)),
			new BoolMonitor("Two", () => OVRInput.Get(OVRInput.Button.Two)),
			new BoolMonitor("TwoDown", () => OVRInput.GetDown(OVRInput.Button.Two)),
			new BoolMonitor("TwoUp", () => OVRInput.GetUp(OVRInput.Button.Two)),
			new BoolMonitor("PrimaryIndexTrigger", () => OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger)),
			new BoolMonitor("PrimaryIndexTriggerDown", () => OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger)),
			new BoolMonitor("PrimaryIndexTriggerUp", () => OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger)),
			new BoolMonitor("Up", () => OVRInput.Get(OVRInput.Button.Up)),
			new BoolMonitor("Down", () => OVRInput.Get(OVRInput.Button.Down)),
			new BoolMonitor("Left", () => OVRInput.Get(OVRInput.Button.Left)),
			new BoolMonitor("Right", () => OVRInput.Get(OVRInput.Button.Right)),
			new BoolMonitor("Touchpad (Touch)", () => OVRInput.Get(OVRInput.Touch.PrimaryTouchpad)),
			new BoolMonitor("TouchpadDown (Touch)", () => OVRInput.GetDown(OVRInput.Touch.PrimaryTouchpad)),
			new BoolMonitor("TouchpadUp (Touch)", () => OVRInput.GetUp(OVRInput.Touch.PrimaryTouchpad)),
			new BoolMonitor("Touchpad (Click)", () => OVRInput.Get(OVRInput.Button.PrimaryTouchpad)),
			new BoolMonitor("TouchpadDown (Click)", () => OVRInput.GetDown(OVRInput.Button.PrimaryTouchpad)),
			new BoolMonitor("TouchpadUp (Click)", () => OVRInput.GetUp(OVRInput.Button.PrimaryTouchpad)),
			new BoolMonitor("Start", () => OVRInput.Get(OVRInput.RawButton.Start)),
			new BoolMonitor("StartDown", () => OVRInput.GetDown(OVRInput.RawButton.Start)),
			new BoolMonitor("StartUp", () => OVRInput.GetUp(OVRInput.RawButton.Start)),
			new BoolMonitor("Back", () => OVRInput.Get(OVRInput.RawButton.Back)),
			new BoolMonitor("BackDown", () => OVRInput.GetDown(OVRInput.RawButton.Back)),
			new BoolMonitor("BackUp", () => OVRInput.GetUp(OVRInput.RawButton.Back)),
			new BoolMonitor("A", () => OVRInput.Get(OVRInput.RawButton.A)),
			new BoolMonitor("ADown", () => OVRInput.GetDown(OVRInput.RawButton.A)),
			new BoolMonitor("AUp", () => OVRInput.GetUp(OVRInput.RawButton.A))
		};
	}

	private void Update()
	{
		string text = string.Concat("<b>Active: </b>", OVRInput.GetActiveController(), "\n<b>Connected: </b>", OVRInput.GetConnectedControllers(), "\n");
		string text2 = text;
		text = string.Concat(text2, "Orientation: ", OVRInput.GetLocalControllerRotation(OVRInput.GetActiveController()), "\n");
		text2 = text;
		text = string.Concat(text2, "AngVel: ", OVRInput.GetLocalControllerAngularVelocity(OVRInput.GetActiveController()), "\n");
		text2 = text;
		text = string.Concat(text2, "AngAcc: ", OVRInput.GetLocalControllerAngularAcceleration(OVRInput.GetActiveController()), "\n");
		text2 = text;
		text = string.Concat(text2, "Position: ", OVRInput.GetLocalControllerPosition(OVRInput.GetActiveController()), "\n");
		text2 = text;
		text = string.Concat(text2, "Vel: ", OVRInput.GetLocalControllerVelocity(OVRInput.GetActiveController()), "\n");
		text2 = text;
		text = string.Concat(text2, "Acc: ", OVRInput.GetLocalControllerAcceleration(OVRInput.GetActiveController()), "\n");
		text2 = text;
		text = string.Concat(text2, "PrimaryTouchPad: ", OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad), "\n");
		text2 = text;
		text = string.Concat(text2, "SecondaryTouchPad: ", OVRInput.Get(OVRInput.Axis2D.SecondaryTouchpad), "\n");
		for (int i = 0; i < monitors.Count; i++)
		{
			monitors[i].Update();
			text = text + monitors[i].ToString() + "\n";
		}
		if (uiText != null)
		{
			uiText.text = text;
		}
	}
}
public class OVRGrabbable : MonoBehaviour
{
	[SerializeField]
	protected bool m_allowOffhandGrab = true;

	[SerializeField]
	protected bool m_snapPosition;

	[SerializeField]
	protected bool m_snapOrientation;

	[SerializeField]
	protected Transform m_snapOffset;

	[SerializeField]
	protected Collider[] m_grabPoints;

	protected bool m_grabbedKinematic;

	protected Collider m_grabbedCollider;

	protected OVRGrabber m_grabbedBy;

	public bool allowOffhandGrab => m_allowOffhandGrab;

	public bool isGrabbed => m_grabbedBy != null;

	public bool snapPosition => m_snapPosition;

	public bool snapOrientation => m_snapOrientation;

	public Transform snapOffset => m_snapOffset;

	public OVRGrabber grabbedBy => m_grabbedBy;

	public Transform grabbedTransform => m_grabbedCollider.transform;

	public Rigidbody grabbedRigidbody => m_grabbedCollider.attachedRigidbody;

	public Collider[] grabPoints => m_grabPoints;

	public virtual void GrabBegin(OVRGrabber hand, Collider grabPoint)
	{
		m_grabbedBy = hand;
		m_grabbedCollider = grabPoint;
		base.gameObject.GetComponent<Rigidbody>().isKinematic = true;
	}

	public virtual void GrabEnd(Vector3 linearVelocity, Vector3 angularVelocity)
	{
		Rigidbody component = base.gameObject.GetComponent<Rigidbody>();
		component.isKinematic = m_grabbedKinematic;
		component.velocity = linearVelocity;
		component.angularVelocity = angularVelocity;
		m_grabbedBy = null;
		m_grabbedCollider = null;
	}

	private void Awake()
	{
		if (m_grabPoints.Length == 0)
		{
			Collider component = GetComponent<Collider>();
			if (component == null)
			{
				throw new ArgumentException("Grabbables cannot have zero grab points and no collider -- please add a grab point or collider.");
			}
			m_grabPoints = new Collider[1] { component };
		}
	}

	private void Start()
	{
		m_grabbedKinematic = GetComponent<Rigidbody>().isKinematic;
	}

	private void OnDestroy()
	{
		if (m_grabbedBy != null)
		{
			m_grabbedBy.ForceRelease(this);
		}
	}
}
[RequireComponent(typeof(Rigidbody))]
public class OVRGrabber : MonoBehaviour
{
	public float grabBegin = 0.55f;

	public float grabEnd = 0.35f;

	[SerializeField]
	protected bool m_parentHeldObject;

	[SerializeField]
	protected Transform m_gripTransform;

	[SerializeField]
	protected Collider[] m_grabVolumes;

	[SerializeField]
	protected OVRInput.Controller m_controller;

	[SerializeField]
	protected Transform m_parentTransform;

	protected bool m_grabVolumeEnabled = true;

	protected Vector3 m_lastPos;

	protected Quaternion m_lastRot;

	protected Quaternion m_anchorOffsetRotation;

	protected Vector3 m_anchorOffsetPosition;

	protected float m_prevFlex;

	protected OVRGrabbable m_grabbedObj;

	private Vector3 m_grabbedObjectPosOff;

	private Quaternion m_grabbedObjectRotOff;

	protected Dictionary<OVRGrabbable, int> m_grabCandidates = new Dictionary<OVRGrabbable, int>();

	public OVRGrabbable grabbedObject => m_grabbedObj;

	public void ForceRelease(OVRGrabbable grabbable)
	{
		if (m_grabbedObj != null && m_grabbedObj == grabbable)
		{
			GrabEnd();
		}
	}

	private void Awake()
	{
		m_anchorOffsetPosition = base.transform.localPosition;
		m_anchorOffsetRotation = base.transform.localRotation;
	}

	private void Start()
	{
		m_lastPos = base.transform.position;
		m_lastRot = base.transform.rotation;
		if (m_parentTransform == null)
		{
			if (base.gameObject.transform.parent != null)
			{
				m_parentTransform = base.gameObject.transform.parent.transform;
				return;
			}
			m_parentTransform = new GameObject().transform;
			m_parentTransform.position = Vector3.zero;
			m_parentTransform.rotation = Quaternion.identity;
		}
	}

	private void FixedUpdate()
	{
		Vector3 localControllerPosition = OVRInput.GetLocalControllerPosition(m_controller);
		Quaternion localControllerRotation = OVRInput.GetLocalControllerRotation(m_controller);
		Vector3 vector = m_parentTransform.TransformPoint(m_anchorOffsetPosition + localControllerPosition);
		Quaternion rot = m_parentTransform.rotation * localControllerRotation * m_anchorOffsetRotation;
		GetComponent<Rigidbody>().MovePosition(vector);
		GetComponent<Rigidbody>().MoveRotation(rot);
		if (!m_parentHeldObject)
		{
			MoveGrabbedObject(vector, rot);
		}
		m_lastPos = base.transform.position;
		m_lastRot = base.transform.rotation;
		float prevFlex = m_prevFlex;
		m_prevFlex = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller);
		CheckForGrabOrRelease(prevFlex);
	}

	private void OnDestroy()
	{
		if (m_grabbedObj != null)
		{
			GrabEnd();
		}
	}

	private void OnTriggerEnter(Collider otherCollider)
	{
		OVRGrabbable oVRGrabbable = otherCollider.GetComponent<OVRGrabbable>() ?? otherCollider.GetComponentInParent<OVRGrabbable>();
		if (!(oVRGrabbable == null))
		{
			int value = 0;
			m_grabCandidates.TryGetValue(oVRGrabbable, out value);
			m_grabCandidates[oVRGrabbable] = value + 1;
		}
	}

	private void OnTriggerExit(Collider otherCollider)
	{
		OVRGrabbable oVRGrabbable = otherCollider.GetComponent<OVRGrabbable>() ?? otherCollider.GetComponentInParent<OVRGrabbable>();
		if (oVRGrabbable == null)
		{
			return;
		}
		int value = 0;
		if (m_grabCandidates.TryGetValue(oVRGrabbable, out value))
		{
			if (value > 1)
			{
				m_grabCandidates[oVRGrabbable] = value - 1;
			}
			else
			{
				m_grabCandidates.Remove(oVRGrabbable);
			}
		}
	}

	protected void CheckForGrabOrRelease(float prevFlex)
	{
		if (m_prevFlex >= grabBegin && prevFlex < grabBegin)
		{
			GrabBegin();
		}
		else if (m_prevFlex <= grabEnd && prevFlex > grabEnd)
		{
			GrabEnd();
		}
	}

	protected void GrabBegin()
	{
		float num = float.MaxValue;
		OVRGrabbable oVRGrabbable = null;
		Collider grabPoint = null;
		foreach (OVRGrabbable key in m_grabCandidates.Keys)
		{
			if (key.isGrabbed && !key.allowOffhandGrab)
			{
				continue;
			}
			for (int i = 0; i < key.grabPoints.Length; i++)
			{
				Collider collider = key.grabPoints[i];
				Vector3 vector = collider.ClosestPointOnBounds(m_gripTransform.position);
				float sqrMagnitude = (m_gripTransform.position - vector).sqrMagnitude;
				if (sqrMagnitude < num)
				{
					num = sqrMagnitude;
					oVRGrabbable = key;
					grabPoint = collider;
				}
			}
		}
		GrabVolumeEnable(enabled: false);
		if (!(oVRGrabbable != null))
		{
			return;
		}
		if (oVRGrabbable.isGrabbed)
		{
			oVRGrabbable.grabbedBy.OffhandGrabbed(oVRGrabbable);
		}
		m_grabbedObj = oVRGrabbable;
		m_grabbedObj.GrabBegin(this, grabPoint);
		m_lastPos = base.transform.position;
		m_lastRot = base.transform.rotation;
		if (m_grabbedObj.snapPosition)
		{
			m_grabbedObjectPosOff = m_gripTransform.localPosition;
			if ((bool)m_grabbedObj.snapOffset)
			{
				Vector3 position = m_grabbedObj.snapOffset.position;
				if (m_controller == OVRInput.Controller.LTouch)
				{
					position.x = 0f - position.x;
				}
				m_grabbedObjectPosOff += position;
			}
		}
		else
		{
			Vector3 vector2 = m_grabbedObj.transform.position - base.transform.position;
			vector2 = Quaternion.Inverse(base.transform.rotation) * vector2;
			m_grabbedObjectPosOff = vector2;
		}
		if (m_grabbedObj.snapOrientation)
		{
			m_grabbedObjectRotOff = m_gripTransform.localRotation;
			if ((bool)m_grabbedObj.snapOffset)
			{
				m_grabbedObjectRotOff = m_grabbedObj.snapOffset.rotation * m_grabbedObjectRotOff;
			}
		}
		else
		{
			Quaternion grabbedObjectRotOff = Quaternion.Inverse(base.transform.rotation) * m_grabbedObj.transform.rotation;
			m_grabbedObjectRotOff = grabbedObjectRotOff;
		}
		MoveGrabbedObject(m_lastPos, m_lastRot, forceTeleport: true);
		if (m_parentHeldObject)
		{
			m_grabbedObj.transform.parent = base.transform;
		}
	}

	protected void MoveGrabbedObject(Vector3 pos, Quaternion rot, bool forceTeleport = false)
	{
		if (!(m_grabbedObj == null))
		{
			Rigidbody grabbedRigidbody = m_grabbedObj.grabbedRigidbody;
			Vector3 position = pos + rot * m_grabbedObjectPosOff;
			Quaternion quaternion = rot * m_grabbedObjectRotOff;
			if (forceTeleport)
			{
				grabbedRigidbody.transform.position = position;
				grabbedRigidbody.transform.rotation = quaternion;
			}
			else
			{
				grabbedRigidbody.MovePosition(position);
				grabbedRigidbody.MoveRotation(quaternion);
			}
		}
	}

	protected void GrabEnd()
	{
		if (m_grabbedObj != null)
		{
			OVRPose oVRPose = default(OVRPose);
			oVRPose.position = OVRInput.GetLocalControllerPosition(m_controller);
			oVRPose.orientation = OVRInput.GetLocalControllerRotation(m_controller);
			OVRPose oVRPose2 = oVRPose;
			oVRPose = default(OVRPose);
			oVRPose.position = m_anchorOffsetPosition;
			oVRPose.orientation = m_anchorOffsetRotation;
			OVRPose oVRPose3 = oVRPose;
			oVRPose2 *= oVRPose3;
			OVRPose oVRPose4 = base.transform.ToOVRPose() * oVRPose2.Inverse();
			oVRPose = default(OVRPose);
			oVRPose.position = OVRInput.GetLocalControllerVelocity(m_controller);
			oVRPose.orientation = OVRInput.GetLocalControllerAngularVelocity(m_controller);
			OVRPose oVRPose5 = oVRPose;
			Vector3 linearVelocity = oVRPose4.orientation * oVRPose5.position;
			Vector3 angularVelocity = (oVRPose4.orientation * oVRPose5.orientation).eulerAngles * ((float)Math.PI / 180f);
			if (angularVelocity.x > (float)Math.PI)
			{
				angularVelocity.x -= (float)Math.PI * 2f;
			}
			if (angularVelocity.y > (float)Math.PI)
			{
				angularVelocity.y -= (float)Math.PI * 2f;
			}
			if (angularVelocity.z > (float)Math.PI)
			{
				angularVelocity.z -= (float)Math.PI * 2f;
			}
			GrabbableRelease(linearVelocity, angularVelocity);
		}
		GrabVolumeEnable(enabled: true);
	}

	protected void GrabbableRelease(Vector3 linearVelocity, Vector3 angularVelocity)
	{
		m_grabbedObj.GrabEnd(linearVelocity, angularVelocity);
		if (m_parentHeldObject)
		{
			m_grabbedObj.transform.parent = null;
		}
		m_grabbedObj = null;
	}

	protected void GrabVolumeEnable(bool enabled)
	{
		if (m_grabVolumeEnabled != enabled)
		{
			m_grabVolumeEnabled = enabled;
			for (int i = 0; i < m_grabVolumes.Length; i++)
			{
				Collider collider = m_grabVolumes[i];
				collider.enabled = m_grabVolumeEnabled;
			}
			if (!m_grabVolumeEnabled)
			{
				m_grabCandidates.Clear();
			}
		}
	}

	protected void OffhandGrabbed(OVRGrabbable grabbable)
	{
		if (m_grabbedObj == grabbable)
		{
			GrabbableRelease(Vector3.zero, Vector3.zero);
		}
	}
}
public class OVRGridCube : MonoBehaviour
{
	public KeyCode GridKey = KeyCode.G;

	private GameObject CubeGrid;

	private bool CubeGridOn;

	private bool CubeSwitchColorOld;

	private bool CubeSwitchColor;

	private int gridSizeX = 6;

	private int gridSizeY = 4;

	private int gridSizeZ = 6;

	private float gridScale = 0.3f;

	private float cubeScale = 0.03f;

	private OVRCameraRig CameraController;

	private void Update()
	{
		UpdateCubeGrid();
	}

	public void SetOVRCameraController(ref OVRCameraRig cameraController)
	{
		CameraController = cameraController;
	}

	private void UpdateCubeGrid()
	{
		if (Input.GetKeyDown(GridKey))
		{
			if (!CubeGridOn)
			{
				CubeGridOn = true;
				UnityEngine.Debug.LogWarning("CubeGrid ON");
				if (CubeGrid != null)
				{
					CubeGrid.SetActive(value: true);
				}
				else
				{
					CreateCubeGrid();
				}
			}
			else
			{
				CubeGridOn = false;
				UnityEngine.Debug.LogWarning("CubeGrid OFF");
				if (CubeGrid != null)
				{
					CubeGrid.SetActive(value: false);
				}
			}
		}
		if (CubeGrid != null)
		{
			CubeSwitchColor = !OVRManager.tracker.isPositionTracked;
			if (CubeSwitchColor != CubeSwitchColorOld)
			{
				CubeGridSwitchColor(CubeSwitchColor);
			}
			CubeSwitchColorOld = CubeSwitchColor;
		}
	}

	private void CreateCubeGrid()
	{
		UnityEngine.Debug.LogWarning("Create CubeGrid");
		CubeGrid = new GameObject("CubeGrid");
		CubeGrid.layer = CameraController.gameObject.layer;
		for (int i = -gridSizeX; i <= gridSizeX; i++)
		{
			for (int j = -gridSizeY; j <= gridSizeY; j++)
			{
				for (int k = -gridSizeZ; k <= gridSizeZ; k++)
				{
					int num = 0;
					if ((i == 0 && j == 0) || (i == 0 && k == 0) || (j == 0 && k == 0))
					{
						num = ((i != 0 || j != 0 || k != 0) ? 1 : 2);
					}
					GameObject gameObject = GameObject.CreatePrimitive(PrimitiveType.Cube);
					BoxCollider component = gameObject.GetComponent<BoxCollider>();
					component.enabled = false;
					gameObject.layer = CameraController.gameObject.layer;
					Renderer component2 = gameObject.GetComponent<Renderer>();
					component2.shadowCastingMode = ShadowCastingMode.Off;
					component2.receiveShadows = false;
					switch (num)
					{
					case 0:
						component2.material.color = UnityEngine.Color.red;
						break;
					case 1:
						component2.material.color = UnityEngine.Color.white;
						break;
					default:
						component2.material.color = UnityEngine.Color.yellow;
						break;
					}
					gameObject.transform.position = new Vector3((float)i * gridScale, (float)j * gridScale, (float)k * gridScale);
					float num2 = 0.7f;
					if (num == 1)
					{
						num2 = 1f;
					}
					if (num == 2)
					{
						num2 = 2f;
					}
					gameObject.transform.localScale = new Vector3(cubeScale * num2, cubeScale * num2, cubeScale * num2);
					gameObject.transform.parent = CubeGrid.transform;
				}
			}
		}
	}

	private void CubeGridSwitchColor(bool CubeSwitchColor)
	{
		UnityEngine.Color color = UnityEngine.Color.red;
		if (CubeSwitchColor)
		{
			color = UnityEngine.Color.blue;
		}
		foreach (Transform item in CubeGrid.transform)
		{
			Material material = item.GetComponent<Renderer>().material;
			if (material.color == UnityEngine.Color.red || material.color == UnityEngine.Color.blue)
			{
				material.color = color;
			}
		}
	}
}
public class OVRModeParms : MonoBehaviour
{
	public OVRInput.RawButton resetButton = OVRInput.RawButton.X;

	private void Start()
	{
		if (!OVRManager.isHmdPresent)
		{
			base.enabled = false;
		}
		else
		{
			InvokeRepeating("TestPowerStateMode", 10f, 10f);
		}
	}

	private void Update()
	{
		if (OVRInput.GetDown(resetButton))
		{
			OVRPlugin.cpuLevel = 0;
			OVRPlugin.gpuLevel = 1;
		}
	}

	private void TestPowerStateMode()
	{
		if (OVRPlugin.powerSaving)
		{
			UnityEngine.Debug.Log("POWER SAVE MODE ACTIVATED");
		}
	}
}
public class OVRMonoscopic : MonoBehaviour
{
	public OVRInput.RawButton toggleButton = OVRInput.RawButton.B;

	private bool monoscopic;

	private void Update()
	{
		if (OVRInput.GetDown(toggleButton))
		{
			monoscopic = !monoscopic;
			OVRManager.instance.monoscopic = monoscopic;
		}
	}
}
[RequireComponent(typeof(CharacterController))]
public class OVRPlayerController : MonoBehaviour
{
	public float Acceleration = 0.1f;

	public float Damping = 0.3f;

	public float BackAndSideDampen = 0.5f;

	public float JumpForce = 0.3f;

	public float RotationAmount = 1.5f;

	public float RotationRatchet = 45f;

	public bool HmdResetsY = true;

	public bool HmdRotatesY = true;

	public float GravityModifier = 0.379f;

	public bool useProfileData = true;

	protected CharacterController Controller;

	protected OVRCameraRig CameraRig;

	private float MoveScale = 1f;

	private Vector3 MoveThrottle = Vector3.zero;

	private float FallSpeed;

	private OVRPose? InitialPose;

	private float InitialYRotation;

	private float MoveScaleMultiplier = 1f;

	private float RotationScaleMultiplier = 1f;

	private bool SkipMouseRotation;

	private bool HaltUpdateMovement;

	private bool prevHatLeft;

	private bool prevHatRight;

	private float SimulationRate = 60f;

	private void Start()
	{
		Vector3 localPosition = CameraRig.transform.localPosition;
		localPosition.z = OVRManager.profile.eyeDepth;
		CameraRig.transform.localPosition = localPosition;
	}

	private void Awake()
	{
		Controller = base.gameObject.GetComponent<CharacterController>();
		if (Controller == null)
		{
			UnityEngine.Debug.LogWarning("OVRPlayerController: No CharacterController attached.");
		}
		OVRCameraRig[] componentsInChildren = base.gameObject.GetComponentsInChildren<OVRCameraRig>();
		if (componentsInChildren.Length == 0)
		{
			UnityEngine.Debug.LogWarning("OVRPlayerController: No OVRCameraRig attached.");
		}
		else if (componentsInChildren.Length > 1)
		{
			UnityEngine.Debug.LogWarning("OVRPlayerController: More then 1 OVRCameraRig attached.");
		}
		else
		{
			CameraRig = componentsInChildren[0];
		}
		InitialYRotation = base.transform.rotation.eulerAngles.y;
	}

	private void OnEnable()
	{
		OVRManager.display.RecenteredPose += ResetOrientation;
		if (CameraRig != null)
		{
			CameraRig.UpdatedAnchors += UpdateTransform;
		}
	}

	private void OnDisable()
	{
		OVRManager.display.RecenteredPose -= ResetOrientation;
		if (CameraRig != null)
		{
			CameraRig.UpdatedAnchors -= UpdateTransform;
		}
	}

	protected virtual void UpdateController()
	{
		if (useProfileData)
		{
			OVRPose? initialPose = InitialPose;
			if (!initialPose.HasValue)
			{
				InitialPose = new OVRPose
				{
					position = CameraRig.transform.localPosition,
					orientation = CameraRig.transform.localRotation
				};
			}
			Vector3 localPosition = CameraRig.transform.localPosition;
			if (OVRManager.instance.trackingOriginType == OVRManager.TrackingOrigin.EyeLevel)
			{
				localPosition.y = OVRManager.profile.eyeHeight - 0.5f * Controller.height + Controller.center.y;
			}
			else if (OVRManager.instance.trackingOriginType == OVRManager.TrackingOrigin.FloorLevel)
			{
				localPosition.y = 0f - 0.5f * Controller.height + Controller.center.y;
			}
			CameraRig.transform.localPosition = localPosition;
		}
		else
		{
			OVRPose? initialPose2 = InitialPose;
			if (initialPose2.HasValue)
			{
				CameraRig.transform.localPosition = InitialPose.Value.position;
				CameraRig.transform.localRotation = InitialPose.Value.orientation;
				InitialPose = null;
			}
		}
		UpdateMovement();
		Vector3 zero = Vector3.zero;
		float num = 1f + Damping * SimulationRate * Time.deltaTime;
		MoveThrottle.x /= num;
		MoveThrottle.y = ((!(MoveThrottle.y > 0f)) ? MoveThrottle.y : (MoveThrottle.y / num));
		MoveThrottle.z /= num;
		zero += MoveThrottle * SimulationRate * Time.deltaTime;
		if (Controller.isGrounded && FallSpeed <= 0f)
		{
			FallSpeed = Physics.gravity.y * (GravityModifier * 0.002f);
		}
		else
		{
			FallSpeed += Physics.gravity.y * (GravityModifier * 0.002f) * SimulationRate * Time.deltaTime;
		}
		zero.y += FallSpeed * SimulationRate * Time.deltaTime;
		float num2 = 0f;
		if (Controller.isGrounded && MoveThrottle.y <= base.transform.lossyScale.y * 0.001f)
		{
			num2 = Mathf.Max(Controller.stepOffset, new Vector3(zero.x, 0f, zero.z).magnitude);
			zero -= num2 * Vector3.up;
		}
		Vector3 vector = Vector3.Scale(Controller.transform.localPosition + zero, new Vector3(1f, 0f, 1f));
		Controller.Move(zero);
		Vector3 vector2 = Vector3.Scale(Controller.transform.localPosition, new Vector3(1f, 0f, 1f));
		if (vector != vector2)
		{
			MoveThrottle += (vector2 - vector) / (SimulationRate * Time.deltaTime);
		}
	}

	public virtual void UpdateMovement()
	{
		if (!HaltUpdateMovement)
		{
			bool flag = Input.GetKey(KeyCode.W) || Input.GetKey(KeyCode.UpArrow);
			bool flag2 = Input.GetKey(KeyCode.A) || Input.GetKey(KeyCode.LeftArrow);
			bool flag3 = Input.GetKey(KeyCode.D) || Input.GetKey(KeyCode.RightArrow);
			bool flag4 = Input.GetKey(KeyCode.S) || Input.GetKey(KeyCode.DownArrow);
			bool flag5 = false;
			if (OVRInput.Get(OVRInput.Button.DpadUp))
			{
				flag = true;
				flag5 = true;
			}
			if (OVRInput.Get(OVRInput.Button.DpadDown))
			{
				flag4 = true;
				flag5 = true;
			}
			MoveScale = 1f;
			if ((flag && flag2) || (flag && flag3) || (flag4 && flag2) || (flag4 && flag3))
			{
				MoveScale = 0.70710677f;
			}
			if (!Controller.isGrounded)
			{
				MoveScale = 0f;
			}
			MoveScale *= SimulationRate * Time.deltaTime;
			float num = Acceleration * 0.1f * MoveScale * MoveScaleMultiplier;
			if (flag5 || Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift))
			{
				num *= 2f;
			}
			Vector3 eulerAngles = base.transform.rotation.eulerAngles;
			eulerAngles.z = (eulerAngles.x = 0f);
			Quaternion quaternion = Quaternion.Euler(eulerAngles);
			if (flag)
			{
				MoveThrottle += quaternion * (base.transform.lossyScale.z * num * Vector3.forward);
			}
			if (flag4)
			{
				MoveThrottle += quaternion * (base.transform.lossyScale.z * num * BackAndSideDampen * Vector3.back);
			}
			if (flag2)
			{
				MoveThrottle += quaternion * (base.transform.lossyScale.x * num * BackAndSideDampen * Vector3.left);
			}
			if (flag3)
			{
				MoveThrottle += quaternion * (base.transform.lossyScale.x * num * BackAndSideDampen * Vector3.right);
			}
			Vector3 eulerAngles2 = base.transform.rotation.eulerAngles;
			bool flag6 = OVRInput.Get(OVRInput.Button.PrimaryShoulder);
			if (flag6 && !prevHatLeft)
			{
				eulerAngles2.y -= RotationRatchet;
			}
			prevHatLeft = flag6;
			bool flag7 = OVRInput.Get(OVRInput.Button.SecondaryShoulder);
			if (flag7 && !prevHatRight)
			{
				eulerAngles2.y += RotationRatchet;
			}
			prevHatRight = flag7;
			if (Input.GetKeyDown(KeyCode.Q))
			{
				eulerAngles2.y -= RotationRatchet;
			}
			if (Input.GetKeyDown(KeyCode.E))
			{
				eulerAngles2.y += RotationRatchet;
			}
			float num2 = SimulationRate * Time.deltaTime * RotationAmount * RotationScaleMultiplier;
			num = Acceleration * 0.1f * MoveScale * MoveScaleMultiplier;
			Vector2 vector = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick);
			if (vector.y > 0f)
			{
				MoveThrottle += quaternion * (vector.y * base.transform.lossyScale.z * num * Vector3.forward);
			}
			if (vector.y < 0f)
			{
				MoveThrottle += quaternion * (Mathf.Abs(vector.y) * base.transform.lossyScale.z * num * BackAndSideDampen * Vector3.back);
			}
			if (vector.x < 0f)
			{
				MoveThrottle += quaternion * (Mathf.Abs(vector.x) * base.transform.lossyScale.x * num * BackAndSideDampen * Vector3.left);
			}
			if (vector.x > 0f)
			{
				MoveThrottle += quaternion * (vector.x * base.transform.lossyScale.x * num * BackAndSideDampen * Vector3.right);
			}
			eulerAngles2.y += OVRInput.Get(OVRInput.Axis2D.SecondaryThumbstick).x * num2;
			base.transform.rotation = Quaternion.Euler(eulerAngles2);
		}
	}

	public void UpdateTransform(OVRCameraRig rig)
	{
		Transform trackingSpace = CameraRig.trackingSpace;
		Transform centerEyeAnchor = CameraRig.centerEyeAnchor;
		if (HmdRotatesY)
		{
			Vector3 position = trackingSpace.position;
			Quaternion rotation = trackingSpace.rotation;
			base.transform.rotation = Quaternion.Euler(0f, centerEyeAnchor.rotation.eulerAngles.y, 0f);
			trackingSpace.position = position;
			trackingSpace.rotation = rotation;
		}
		UpdateController();
	}

	public bool Jump()
	{
		if (!Controller.isGrounded)
		{
			return false;
		}
		MoveThrottle += new Vector3(0f, base.transform.lossyScale.y * JumpForce, 0f);
		return true;
	}

	public void Stop()
	{
		Controller.Move(Vector3.zero);
		MoveThrottle = Vector3.zero;
		FallSpeed = 0f;
	}

	public void GetMoveScaleMultiplier(ref float moveScaleMultiplier)
	{
		moveScaleMultiplier = MoveScaleMultiplier;
	}

	public void SetMoveScaleMultiplier(float moveScaleMultiplier)
	{
		MoveScaleMultiplier = moveScaleMultiplier;
	}

	public void GetRotationScaleMultiplier(ref float rotationScaleMultiplier)
	{
		rotationScaleMultiplier = RotationScaleMultiplier;
	}

	public void SetRotationScaleMultiplier(float rotationScaleMultiplier)
	{
		RotationScaleMultiplier = rotationScaleMultiplier;
	}

	public void GetSkipMouseRotation(ref bool skipMouseRotation)
	{
		skipMouseRotation = SkipMouseRotation;
	}

	public void SetSkipMouseRotation(bool skipMouseRotation)
	{
		SkipMouseRotation = skipMouseRotation;
	}

	public void GetHaltUpdateMovement(ref bool haltUpdateMovement)
	{
		haltUpdateMovement = HaltUpdateMovement;
	}

	public void SetHaltUpdateMovement(bool haltUpdateMovement)
	{
		HaltUpdateMovement = haltUpdateMovement;
	}

	public void ResetOrientation()
	{
		if (HmdResetsY)
		{
			Vector3 eulerAngles = base.transform.rotation.eulerAngles;
			eulerAngles.y = InitialYRotation;
			base.transform.rotation = Quaternion.Euler(eulerAngles);
		}
	}
}
public class OVRRTOverlayConnector : MonoBehaviour
{
	public int alphaBorderSizePixels = 3;

	private const int overlayRTChainSize = 3;

	private int overlayRTIndex;

	private IntPtr[] overlayTexturePtrs = new IntPtr[3];

	private RenderTexture[] overlayRTChain = new RenderTexture[3];

	public GameObject ovrOverlayObj;

	private RenderTexture srcRT;

	private Camera ownerCamera;

	private bool borderCleaned;

	public void RefreshRenderTextureChain()
	{
		srcRT = ownerCamera.targetTexture;
		ConstructRenderTextureChain();
	}

	private void ConstructRenderTextureChain()
	{
		for (int i = 0; i < 3; i++)
		{
			overlayRTChain[i] = new RenderTexture(srcRT.width, srcRT.height, 1, srcRT.format, RenderTextureReadWrite.sRGB);
			overlayRTChain[i].antiAliasing = 1;
			overlayRTChain[i].depth = 0;
			overlayRTChain[i].wrapMode = TextureWrapMode.Clamp;
			overlayRTChain[i].hideFlags = HideFlags.HideAndDontSave;
			overlayRTChain[i].Create();
			ref IntPtr reference = ref overlayTexturePtrs[i];
			reference = overlayRTChain[i].GetNativeTexturePtr();
		}
	}

	private void Start()
	{
		ownerCamera = GetComponent<Camera>();
		srcRT = ownerCamera.targetTexture;
		ConstructRenderTextureChain();
	}

	private void OnPreRender()
	{
		if (!borderCleaned)
		{
			GL.Clear(clearDepth: false, clearColor: true, new UnityEngine.Color(0f, 0f, 0f, 0f));
			GetComponent<Camera>().pixelRect = new Rect(alphaBorderSizePixels, alphaBorderSizePixels, srcRT.width - 2 * alphaBorderSizePixels, srcRT.height - 2 * alphaBorderSizePixels);
			borderCleaned = true;
		}
	}

	private void OnPostRender()
	{
		if ((bool)srcRT)
		{
			UnityEngine.Graphics.Blit(srcRT, overlayRTChain[overlayRTIndex]);
			OVROverlay component = ovrOverlayObj.GetComponent<OVROverlay>();
			component.OverrideOverlayTextureInfo(overlayRTChain[overlayRTIndex], overlayTexturePtrs[overlayRTIndex], VRNode.LeftEye);
			overlayRTIndex++;
			overlayRTIndex %= 3;
		}
	}
}
public class OVRResetOrientation : MonoBehaviour
{
	public OVRInput.RawButton resetButton = OVRInput.RawButton.Y;

	private void Update()
	{
		if (OVRInput.GetDown(resetButton))
		{
			OVRManager.display.RecenterPose();
		}
	}
}
public class OVRSceneSampleController : MonoBehaviour
{
	public KeyCode quitKey = KeyCode.Escape;

	public Texture fadeInTexture;

	public float speedRotationIncrement = 0.05f;

	private OVRPlayerController playerController;

	private OVRCameraRig cameraController;

	public string layerName = "Default";

	private bool visionMode = true;

	private OVRGridCube gridCube;

	private void Awake()
	{
		OVRCameraRig[] componentsInChildren = base.gameObject.GetComponentsInChildren<OVRCameraRig>();
		if (componentsInChildren.Length == 0)
		{
			UnityEngine.Debug.LogWarning("OVRMainMenu: No OVRCameraRig attached.");
		}
		else if (componentsInChildren.Length > 1)
		{
			UnityEngine.Debug.LogWarning("OVRMainMenu: More then 1 OVRCameraRig attached.");
		}
		else
		{
			cameraController = componentsInChildren[0];
		}
		OVRPlayerController[] componentsInChildren2 = base.gameObject.GetComponentsInChildren<OVRPlayerController>();
		if (componentsInChildren2.Length == 0)
		{
			UnityEngine.Debug.LogWarning("OVRMainMenu: No OVRPlayerController attached.");
		}
		else if (componentsInChildren2.Length > 1)
		{
			UnityEngine.Debug.LogWarning("OVRMainMenu: More then 1 OVRPlayerController attached.");
		}
		else
		{
			playerController = componentsInChildren2[0];
		}
	}

	private void Start()
	{
		if (!Application.isEditor)
		{
			Cursor.visible = false;
			Cursor.lockState = CursorLockMode.Locked;
		}
		if (cameraController != null)
		{
			gridCube = base.gameObject.AddComponent<OVRGridCube>();
			gridCube.SetOVRCameraController(ref cameraController);
		}
	}

	private void Update()
	{
		UpdateRecenterPose();
		UpdateVisionMode();
		if (playerController != null)
		{
			UpdateSpeedAndRotationScaleMultiplier();
		}
		if (Input.GetKeyDown(KeyCode.F11))
		{
			Screen.fullScreen = !Screen.fullScreen;
		}
		if (Input.GetKeyDown(KeyCode.M))
		{
			VRSettings.showDeviceView = !VRSettings.showDeviceView;
		}
	}

	private void UpdateVisionMode()
	{
		if (Input.GetKeyDown(KeyCode.F2))
		{
			visionMode ^= visionMode;
			OVRManager.tracker.isEnabled = visionMode;
		}
	}

	private void UpdateSpeedAndRotationScaleMultiplier()
	{
		float moveScaleMultiplier = 0f;
		playerController.GetMoveScaleMultiplier(ref moveScaleMultiplier);
		if (Input.GetKeyDown(KeyCode.Alpha7))
		{
			moveScaleMultiplier -= speedRotationIncrement;
		}
		else if (Input.GetKeyDown(KeyCode.Alpha8))
		{
			moveScaleMultiplier += speedRotationIncrement;
		}
		playerController.SetMoveScaleMultiplier(moveScaleMultiplier);
		float rotationScaleMultiplier = 0f;
		playerController.GetRotationScaleMultiplier(ref rotationScaleMultiplier);
		if (Input.GetKeyDown(KeyCode.Alpha9))
		{
			rotationScaleMultiplier -= speedRotationIncrement;
		}
		else if (Input.GetKeyDown(KeyCode.Alpha0))
		{
			rotationScaleMultiplier += speedRotationIncrement;
		}
		playerController.SetRotationScaleMultiplier(rotationScaleMultiplier);
	}

	private void UpdateRecenterPose()
	{
		if (Input.GetKeyDown(KeyCode.R))
		{
			OVRManager.display.RecenterPose();
		}
	}
}
public class OVRScreenFade : MonoBehaviour
{
	public float fadeTime = 2f;

	public UnityEngine.Color fadeColor = new UnityEngine.Color(0.01f, 0.01f, 0.01f, 1f);

	private Material fadeMaterial;

	private bool isFading;

	private YieldInstruction fadeInstruction = new WaitForEndOfFrame();

	private void Awake()
	{
		fadeMaterial = new Material(Shader.Find("Oculus/Unlit Transparent Color"));
	}

	private void OnEnable()
	{
		StartCoroutine(FadeIn());
	}

	private void OnLevelFinishedLoading(int level)
	{
		StartCoroutine(FadeIn());
	}

	private void OnDestroy()
	{
		if (fadeMaterial != null)
		{
			UnityEngine.Object.Destroy(fadeMaterial);
		}
	}

	private IEnumerator FadeIn()
	{
		float elapsedTime = 0f;
		fadeMaterial.color = fadeColor;
		UnityEngine.Color color = fadeColor;
		isFading = true;
		while (elapsedTime < fadeTime)
		{
			yield return fadeInstruction;
			elapsedTime += Time.deltaTime;
			color.a = 1f - Mathf.Clamp01(elapsedTime / fadeTime);
			fadeMaterial.color = color;
		}
		isFading = false;
	}

	private void OnPostRender()
	{
		if (isFading)
		{
			fadeMaterial.SetPass(0);
			GL.PushMatrix();
			GL.LoadOrtho();
			GL.Color(fadeMaterial.color);
			GL.Begin(7);
			GL.Vertex3(0f, 0f, -12f);
			GL.Vertex3(0f, 1f, -12f);
			GL.Vertex3(1f, 1f, -12f);
			GL.Vertex3(1f, 0f, -12f);
			GL.End();
			GL.PopMatrix();
		}
	}
}
public class OVRWaitCursor : MonoBehaviour
{
	public Vector3 rotateSpeeds = new Vector3(0f, 0f, -60f);

	private void Update()
	{
		base.transform.Rotate(rotateSpeeds * Time.smoothDeltaTime);
	}
}
[Serializable]
public abstract class Achievement
{
	[SerializeField]
	private string m_id;

	protected string m_desc;

	protected bool m_isAchieved;

	public virtual void Init()
	{
		m_desc = m_id.Translate();
	}

	public virtual void StartMission()
	{
	}

	public virtual void EndMission(GameManager.EndMissionReason reason)
	{
	}

	public virtual void OnKill()
	{
	}

	public string GetDesc()
	{
		return m_desc;
	}

	public string GetID()
	{
		return m_id;
	}

	public bool IsAchieved()
	{
		return m_isAchieved;
	}

	public void SetAchieved(bool a)
	{
		m_isAchieved = a;
	}

	public abstract int GetGoal();

	public abstract int GetCurrent();

	protected void Achieve()
	{
		m_isAchieved = true;
		Singleton<AchievementManager>.Instance.OnAchieved(this);
	}
}
public class AchievementManager : Singleton<AchievementManager>
{
	private List<Achievement> m_achievements;

	[SerializeField]
	private AllStarsAchievement m_allStars;

	[SerializeField]
	private MissionsCountAchievement[] m_missionsCountAchievements;

	[SerializeField]
	private StarsCountAchievement[] m_starsCountAchievements;

	[SerializeField]
	private KillsAchievement[] m_killAchievements;

	public void Init()
	{
		m_achievements = new List<Achievement> { m_allStars };
		for (int i = 0; i < m_missionsCountAchievements.Length; i++)
		{
			m_achievements.Add(m_missionsCountAchievements[i]);
		}
		for (int j = 0; j < m_starsCountAchievements.Length; j++)
		{
			m_achievements.Add(m_starsCountAchievements[j]);
		}
		for (int k = 0; k < m_killAchievements.Length; k++)
		{
			m_achievements.Add(m_killAchievements[k]);
		}
		Singleton<Profile>.Instance.Achievements.Load();
		for (int l = 0; l < m_achievements.Count; l++)
		{
			m_achievements[l].Init();
		}
	}

	public void OnAchieved(Achievement achievement)
	{
		Singleton<Profile>.Instance.Achievements.Save();
	}

	public void StartMission()
	{
		for (int i = 0; i < m_achievements.Count; i++)
		{
			if (!m_achievements[i].IsAchieved())
			{
				m_achievements[i].StartMission();
			}
		}
	}

	public void EndMission(GameManager.EndMissionReason reason)
	{
		for (int i = 0; i < m_achievements.Count; i++)
		{
			if (!m_achievements[i].IsAchieved())
			{
				m_achievements[i].EndMission(reason);
			}
		}
	}

	public void OnKill()
	{
		for (int i = 0; i < m_achievements.Count; i++)
		{
			if (!m_achievements[i].IsAchieved())
			{
				m_achievements[i].OnKill();
			}
		}
	}

	public List<Achievement> GetAchievements()
	{
		return m_achievements;
	}
}
[Serializable]
public class AllStarsAchievement : Achievement
{
	public override void EndMission(GameManager.EndMissionReason reason)
	{
		if (reason == GameManager.EndMissionReason.Victory && Singleton<PlayerScore>.Instance.Stars == 5)
		{
			Achieve();
		}
	}

	public override int GetGoal()
	{
		return 5;
	}

	public override int GetCurrent()
	{
		return 0;
	}
}
[Serializable]
public class KillsAchievement : Achievement
{
	[SerializeField]
	private Statistics.Key m_key;

	[SerializeField]
	private int m_goal;

	public override void Init()
	{
		base.Init();
		m_desc = m_desc.Replace("{n}", m_goal.ToString());
	}

	public override void OnKill()
	{
		int current = GetCurrent();
		if (current >= m_goal)
		{
			Achieve();
		}
	}

	public override int GetGoal()
	{
		return m_goal;
	}

	public override int GetCurrent()
	{
		return Singleton<Profile>.Instance.Statistics.GetStatistics()[m_key];
	}
}
[Serializable]
public class MissionsCountAchievement : Achievement
{
	[SerializeField]
	private int m_goal;

	public override void Init()
	{
		base.Init();
		m_desc = m_desc.Replace("{n}", m_goal.ToString());
	}

	public override void EndMission(GameManager.EndMissionReason reason)
	{
		if (reason == GameManager.EndMissionReason.Victory && Singleton<Profile>.Instance.Progress.LastPlayedLevel == m_goal)
		{
			Achieve();
		}
	}

	public override int GetGoal()
	{
		return m_goal;
	}

	public override int GetCurrent()
	{
		return Singleton<Profile>.Instance.Progress.LastPlayedLevel;
	}
}
[Serializable]
public class StarsCountAchievement : Achievement
{
	[SerializeField]
	private int m_goal;

	public override void Init()
	{
		base.Init();
		m_desc = m_desc.Replace("{n}", m_goal.ToString());
	}

	public override void EndMission(GameManager.EndMissionReason reason)
	{
		if (reason == GameManager.EndMissionReason.Victory && Singleton<Profile>.Instance.Progress.GetStarsAmount() >= m_goal)
		{
			Achieve();
		}
	}

	public override int GetGoal()
	{
		return m_goal;
	}

	public override int GetCurrent()
	{
		return Singleton<Profile>.Instance.Progress.GetStarsAmount();
	}
}
public class CharacterRotation : MonoBehaviour
{
	[SerializeField]
	private float m_maxRotationAngle;

	[SerializeField]
	private float m_smoothing;

	private Animator m_anim;

	private Vector3 m_cameraVector;

	private Vector3 m_pilotVector;

	private float m_velocity;

	private float m_currentRotation;

	private void Start()
	{
		m_anim = GetComponent<Animator>();
	}

	private void Update()
	{
		if ((bool)Singleton<GameManager>.Instance.Turret)
		{
			m_anim.SetFloat("Shooting", (!Singleton<GameManager>.Instance.Turret.CurrentGun.IsShooting) ? (-1f) : 1f);
		}
		m_cameraVector = Singleton<CameraManager>.Instance.GetCamera().forward;
		m_cameraVector.y = 0f;
		m_cameraVector.Normalize();
		m_pilotVector = -base.transform.forward;
		m_pilotVector.y = 0f;
		m_pilotVector.Normalize();
		float num = Mathf.Acos(Mathf.Clamp(Vector3.Dot(m_cameraVector, m_pilotVector), -1f, 1f));
		num = Mathf.Clamp(num * 57.29578f, 0f, m_maxRotationAngle);
		float num2 = 0f - Mathf.Sign(Vector3.Cross(m_cameraVector, m_pilotVector).y);
		m_currentRotation = Mathf.SmoothDamp(m_currentRotation, num * num2 / m_maxRotationAngle, ref m_velocity, m_smoothing, float.PositiveInfinity, Time.unscaledDeltaTime);
		m_anim.SetFloat("Rotation", m_currentRotation);
	}
}
public class AudioEventStarter : MonoBehaviour
{
	public List<AudioEvent> eventList = new List<AudioEvent>();

	[NonSerialized]
	[HideInInspector]
	public new GameObject gameObject;

	private void Start()
	{
		gameObject = base.gameObject;
		for (int i = 0; i < eventList.Count; i++)
		{
			Singleton<AudioManager>.Instance.Play(eventList[i], gameObject);
		}
	}
}
public enum AudioEvent
{
	NOSOUND,
	EvtBomberEngineDrone,
	EvtBulletImpact,
	EvtBulletImpact_Invin,
	EvtExplode,
	EvtFanfare,
	EvtGUI_FE_amb_footsteps_3D,
	EvtGUI_FE_amb_gramophone_3D,
	EvtGUI_FE_amb_hanger_doors_3D,
	EvtGUI_FE_amb_planes_3D,
	EvtGUI_FE_amb_telephone_3D,
	EvtGUI_FE_amb_tone_2D,
	EvtGUI_FE_amb_tool_workings_3D,
	EvtGUI_FE_amb_vehicles_3D,
	EvtGUI_FE_Highlight,
	EvtGUI_FE_Select,
	EvtGUI_FE_StartGame,
	EvtGUI_IN_powerup_activate,
	EvtGUI_IN_powerup_crate_smash,
	EvtGUI_IN_powerup_deactivate,
	EvtGUI_IN_powerup_slowdown_breath,
	EvtGunFire,
	EvtGunFire_Fst,
	EvtGunFire_Hvy,
	EvtGunFire_Overheated,
	EvtGunFireEnd,
	EvtGunFireEnd_Hvy,
	EvtNPCFriendlyAmb,
	EvtNPCNMEEngine,
	EvtNPCNMEEngine_Jet,
	EvtNPCNMEEngine_passby_down,
	EvtNPCNMEEngine_passby_down_Jet,
	EvtNPCNMEEngine_passby_left_right,
	EvtNPCNMEEngine_passby_left_right_Jet,
	EvtNPCNMEEngine_passby_up,
	EvtNPCNMEEngine_passby_up_Jet,
	EvtNPCNMEExplode,
	EvtNPCNMEGunFire,
	EvtNPCNMEGunFireEnd,
	EvtPlayerVoxChatter_DamageDeath,
	EvtPlayerVoxChatter_DamageHigh,
	EvtPlayerVoxChatter_DamageLow,
	EvtPlayerVoxChatter_DamageMed,
	EvtPlayerVoxChatter_GoodShot,
	EvtPlayerVoxChatter_MissionTime_1mins_Death,
	EvtPlayerVoxChatter_MissionTime_2mins_Death,
	EvtPlayerVoxChatter_MissionTime_30secs_Death,
	EvtPlayerVoxChatter_MissionTime_bomb_door_open,
	EvtPlayerVoxChatter_MissionTime_bombs_away,
	EvtPlayerVoxChatter_MissionTime_over_Death,
	EvtPlayerVoxChatter_Warning,
	EvtPlayerVoxChatter_Wasser_Launch_In_Mission,
	EvtPlayerVoxChatter_Wasser_Launch,
	EvtPlayerVoxChatter_Wasser_Wave_Finished,
	EvtPlayerVoxChatter_Lurker_Launch,
	EvtPlayerVoxChatter_V2_Start,
	EvtPlayerVoxChatter_V2_During,
	EvtFanfare_Fail,
	EvtNPCNME_Lurker_Missile_Launch,
	EvtNPCNME_Lurker_Missile_Loop,
	EvtNPCNME_Lurker_Missile_Impact_Explode,
	EvtNPCNME_Lurker_Missile_Shot_Explode,
	EvtNPCNME_Wasserfall_Missile_Loop,
	EvtNPCNME_Wasserfall_Missile_Impact_Explode,
	EvtNPCNME_Wasserfall_Missile_Shot_Explode,
	EvtNPCNME_V2_Rocket_Loop,
	EvtNPCNME_V2_Rocket_PassBy,
	EvtNPCNME_V2_Rocket_Shot_Explode,
	EvtGUI_IN_NME_Wave_Start,
	EvtGUI_IN_NME_Wave_End,
	EvtGUI_FE_Change_Menu,
	EvtPlayerVoxChatter_Training,
	EvtPlayerVoxChatter_Combo,
	EvtPlayerVoxChatter_MissileWarning,
	EvtPlayerVoxChatter_MissileClose,
	EvtPlayerVoxChatter_RocketWarning,
	EvtPlayerVoxChatter_RocketClose,
	EvtNPCNME_Wasserfall_Missile_Launch,
	EvtNPCNME_V2_Rocket_Launch,
	EvtMissileIncoming_Warning,
	EvtMusic_V2_bonus_mission,
	EvtEndSeq_Amb_Loop,
	EvtEndSeq_RifleFire,
	EvtEndSeq_CrowdCheer,
	EvtEndSeq_Lanc_Landing,
	EvtEndSeq_Lanc_Flyby,
	EvtEndSeq_Music,
	EvtPlayerVoxChatter_MissionTime_2mins_Target,
	EvtPlayerVoxChatter_MissionTime_1mins_Target,
	EvtPlayerVoxChatter_MissionTime_30secs_Target,
	EvtGUI_FE_Pos_Purchase,
	EvtGUI_FE_Neg_Purchase,
	EvtNPCNMEEngine_Jet02,
	EvtNPCNMEEngine02,
	EvtNPCNMEEngine03_lrg,
	EvtNPCNMEEngine_passby_down_lrg,
	EvtNPCNMEEngine_passby_left_right_lrg,
	EvtNPCNMEEngine_passby_up_lrg,
	EvtPressStart_Music
}
internal class AudioEventComparer : IEqualityComparer<AudioEvent>
{
	public static readonly AudioEventComparer Instance = new AudioEventComparer();

	public bool Equals(AudioEvent x, AudioEvent y)
	{
		return x == y;
	}

	public int GetHashCode(AudioEvent obj)
	{
		return (int)obj;
	}
}
public enum ParameterType
{
	Damage,
	Angle
}
internal class ParameterTypeComparer : IEqualityComparer<ParameterType>
{
	public static readonly ParameterTypeComparer Instance = new ParameterTypeComparer();

	public bool Equals(ParameterType x, ParameterType y)
	{
		return x == y;
	}

	public int GetHashCode(ParameterType obj)
	{
		return (int)obj;
	}
}
public class AudioManager : Singleton<AudioManager>
{
	[Serializable]
	public class Parameter
	{
		public ParameterType Type;

		[HideInInspector]
		public float Value;

		public AnimationCurve Curve;

		public Parameter(Parameter p)
		{
			Type = p.Type;
			Value = p.Value;
			Curve = p.Curve;
		}

		public float Evaluate()
		{
			return Curve.Evaluate(Value);
		}
	}

	[Serializable]
	public class LocalizedSounds
	{
		public GameLanguage Language;

		public List<ClipAndParameters> Sounds;
	}

	[Serializable]
	public class ClipAndParameters
	{
		public AudioClip ClipFile;

		[Range(0f, 1f)]
		public float Volume = 1f;

		public List<Parameter> Parameters;

		public ClipAndParameters(ClipAndParameters other)
		{
			ClipFile = other.ClipFile;
			Volume = other.Volume;
			Parameters = new List<Parameter>(other.Parameters);
		}
	}

	public class PlayingSource
	{
		public AudioSource m_Source;

		public Transform transform;

		public bool canBePaused = true;

		public bool isPaused;

		public float pauseTime;

		public PlayingSource(AudioSource source)
		{
			m_Source = source;
			transform = m_Source.transform;
		}
	}

	public class ParametrizedPlayingSource : PlayingSource
	{
		public List<Parameter> ParameterValues = new List<Parameter>(3);

		[NonSerialized]
		[HideInInspector]
		public float ClipVolume = 1f;

		public ParametrizedPlayingSource(AudioSource source, ClipAndParameters data)
			: base(source)
		{
			foreach (Parameter parameter in data.Parameters)
			{
				ParameterValues.Add(new Parameter(parameter));
			}
			ClipVolume = data.Volume;
			m_Source.clip = data.ClipFile;
		}
	}

	[Serializable]
	public class AudioData
	{
		public float MinDistance = 15f;

		public float MaxDistance = 500f;

		public bool ParametrizedSource;

		public bool Looping;

		public int NumMaxInstances;

		public VolumeSettings VolumeGrouping = VolumeSettings.Default;

		public bool canBeDucked = true;

		public List<ClipAndParameters> Sounds;

		public List<LocalizedSounds> LocSoundsList;

		[HideInInspector]
		public List<ClipAndParameters> UsedLocSounds;

		[HideInInspector]
		public Stack<PlayingSource> PooledSources;

		[HideInInspector]
		public Queue<PlayingSource> PlayingSources;

		[HideInInspector]
		public Dictionary<GameObject, List<PlayingSource>> MappedPlayingSources;
	}

	[Serializable]
	public class AudioMapping
	{
		public AudioEvent EventType;

		public AudioData Data;
	}

	public float soundEffectDistanceOnMissionEnd = 500f;

	public List<AudioMapping> SoundMapping = new List<AudioMapping>();

	private Dictionary<AudioEvent, AudioData> EventsInfo = new Dictionary<AudioEvent, AudioData>(70, AudioEventComparer.Instance);

	private List<AudioEvent> EventTypes = new List<AudioEvent>(20);

	private List<ParameterType> ParameterTypes = new List<ParameterType>(5);

	private Dictionary<AudioEvent, List<GameObject>> ActiveObjects = new Dictionary<AudioEvent, List<GameObject>>(70, AudioEventComparer.Instance);

	[SerializeField]
	private int NumPlayingSources;

	private float[] VolumeGroups;

	private Vector3 PlayPosition;

	private bool forcePosition;

	[NonSerialized]
	[HideInInspector]
	public new Transform transform;

	[NonSerialized]
	[HideInInspector]
	public new GameObject gameObject;

	private List<GameObject> objectsToRemove;

	private bool isPaused;

	private AudioEvent currentRadioEvent;

	[SerializeField]
	[Range(0f, 1f)]
	private float sfxDuckingModifier = 0.8f;

	[SerializeField]
	private float duckingInterpTime = 0.5f;

	public bool Paused => isPaused;

	protected override void Awake()
	{
		gameObject = base.gameObject;
		transform = GetComponent<Transform>();
		objectsToRemove = new List<GameObject>();
		PlayPosition = transform.position;
		isPaused = false;
		foreach (AudioEvent value in Enum.GetValues(typeof(AudioEvent)))
		{
			if (value != 0)
			{
				EventTypes.Add(value);
			}
		}
		foreach (ParameterType value2 in Enum.GetValues(typeof(ParameterType)))
		{
			ParameterTypes.Add(value2);
		}
		VolumeGroups = new float[3];
		for (int i = 0; i < VolumeGroups.Length; i++)
		{
			VolumeGroups[i] = 1f;
		}
		Init();
	}

	public void Init()
	{
		GameLanguage languageEnum = Singleton<Profile>.Instance.Settings.m_languageEnum;
		string text = string.Empty;
		switch (languageEnum)
		{
		case GameLanguage.Chinese:
			text = "CHS";
			break;
		case GameLanguage.French:
			text = "FRE";
			break;
		case GameLanguage.German:
			text = "GER";
			break;
		case GameLanguage.Korean:
			text = "KOR";
			break;
		case GameLanguage.Spanish:
			text = "MEX";
			break;
		}
		for (int i = 0; i < SoundMapping.Count; i++)
		{
			AudioMapping audioMapping = SoundMapping[i];
			AudioData data = audioMapping.Data;
			int numMaxInstances = data.NumMaxInstances;
			data.UsedLocSounds = data.Sounds;
			bool flag = languageEnum == GameLanguage.English;
			if (!flag && data.LocSoundsList.Count > 0)
			{
				foreach (LocalizedSounds locSounds in data.LocSoundsList)
				{
					if (locSounds.Language == languageEnum)
					{
						data.UsedLocSounds = locSounds.Sounds;
						flag = true;
						break;
					}
				}
			}
			if (!flag)
			{
				if (data.VolumeGrouping != VolumeSettings.Radio)
				{
					data.UsedLocSounds = data.Sounds;
				}
				else
				{
					List<ClipAndParameters> list = new List<ClipAndParameters>();
					for (int j = 0; j < data.Sounds.Count; j++)
					{
						ClipAndParameters clipAndParameters = new ClipAndParameters(data.Sounds[j]);
						if (!(clipAndParameters.ClipFile == null))
						{
							string text2 = clipAndParameters.ClipFile.name;
							text2 = text2 + "_" + text;
							clipAndParameters.ClipFile = Resources.Load<AudioClip>("Audio/VOX/" + text + "/" + text2);
							if (clipAndParameters.ClipFile == null)
							{
								UnityEngine.Debug.LogWarning("Audio file not found: " + text2);
							}
							else
							{
								list.Add(clipAndParameters);
							}
						}
					}
					if (list.Count > 0)
					{
						data.UsedLocSounds = list;
					}
				}
			}
			data.PooledSources = new Stack<PlayingSource>(numMaxInstances);
			data.PlayingSources = new Queue<PlayingSource>(numMaxInstances);
			data.MappedPlayingSources = new Dictionary<GameObject, List<PlayingSource>>(200);
			EventsInfo[audioMapping.EventType] = data;
			ActiveObjects[audioMapping.EventType] = new List<GameObject>(data.NumMaxInstances);
			AudioSource audioSource = new GameObject("Audio Source: " + audioMapping.EventType).AddComponent<AudioSource>();
			audioSource.playOnAwake = false;
			audioSource.loop = data.Looping;
			audioSource.minDistance = data.MinDistance;
			audioSource.maxDistance = data.MaxDistance;
			audioSource.spatialBlend = 1f;
			audioSource.rolloffMode = AudioRolloffMode.Logarithmic;
			audioSource.transform.parent = transform;
			audioSource.gameObject.SetActive(value: false);
			if (data.ParametrizedSource)
			{
				data.PooledSources.Push(new ParametrizedPlayingSource(audioSource, data.UsedLocSounds[0]));
				for (int k = 1; k < numMaxInstances * data.UsedLocSounds.Count; k++)
				{
					AudioSource audioSource2 = UnityEngine.Object.Instantiate(audioSource);
					audioSource2.name = audioSource.name;
					audioSource2.transform.parent = transform;
					audioSource2.gameObject.SetActive(value: false);
					data.PooledSources.Push(new ParametrizedPlayingSource(audioSource2, data.UsedLocSounds[k % data.UsedLocSounds.Count]));
				}
			}
			else
			{
				data.PooledSources.Push(new PlayingSource(audioSource));
				for (int l = 1; l < numMaxInstances; l++)
				{
					AudioSource audioSource3 = UnityEngine.Object.Instantiate(audioSource);
					audioSource3.name = audioSource.name;
					audioSource3.transform.parent = transform;
					audioSource3.gameObject.SetActive(value: false);
					data.PooledSources.Push(new PlayingSource(audioSource3));
				}
			}
		}
	}

	public bool IsPlaying(AudioEvent audioEvent)
	{
		return ActiveObjects[audioEvent].Count > 0;
	}

	private void Update()
	{
		int num = 0;
		int count = EventTypes.Count;
		for (int i = 0; i < count; i++)
		{
			AudioEvent audioEvent = EventTypes[i];
			AudioData audioData = EventsInfo[audioEvent];
			if (!ActiveObjects.TryGetValue(audioEvent, out var value))
			{
				continue;
			}
			num = value.Count;
			for (int j = 0; j < num; j++)
			{
				GameObject gameObject = value[j];
				NumPlayingSources = 0;
				if (!audioData.MappedPlayingSources.TryGetValue(gameObject, out var value2))
				{
					continue;
				}
				int count2 = value2.Count;
				if (count2 == 0)
				{
					objectsToRemove.Add(gameObject);
					continue;
				}
				for (int num2 = count2 - 1; num2 >= 0; num2--)
				{
					PlayingSource playingSource = value2[num2];
					if (!playingSource.m_Source)
					{
						value2.RemoveAt(num2);
					}
					else if (!playingSource.m_Source.isPlaying && !playingSource.isPaused && !playingSource.m_Source.loop)
					{
						value2.RemoveAt(num2);
						if (playingSource is ParametrizedPlayingSource)
						{
							audioData.MappedPlayingSources.Remove(gameObject);
						}
						playingSource.transform.parent = transform;
						playingSource.m_Source.enabled = false;
						audioData.PooledSources.Push(playingSource);
					}
					else
					{
						NumPlayingSources++;
					}
				}
				if (NumPlayingSources == 0)
				{
					objectsToRemove.Add(gameObject);
				}
			}
			num = objectsToRemove.Count;
			if (num != 0)
			{
				if (currentRadioEvent == audioEvent)
				{
					currentRadioEvent = AudioEvent.NOSOUND;
					StartCoroutine("InterpolateDuckingUp");
				}
				for (int k = 0; k < num; k++)
				{
					value.Remove(objectsToRemove[k]);
				}
				objectsToRemove.Clear();
			}
		}
	}

	public void Pause(bool pause)
	{
		isPaused = pause;
		int num = 0;
		int count = EventTypes.Count;
		for (int i = 0; i < count; i++)
		{
			AudioEvent key = EventTypes[i];
			AudioData audioData = EventsInfo[key];
			if (!ActiveObjects.TryGetValue(key, out var value))
			{
				continue;
			}
			num = value.Count;
			for (int j = 0; j < num; j++)
			{
				GameObject key2 = value[j];
				NumPlayingSources = 0;
				if (!audioData.MappedPlayingSources.TryGetValue(key2, out var value2))
				{
					continue;
				}
				int count2 = value2.Count;
				if (count2 == 0 || !value2[0].canBePaused)
				{
					continue;
				}
				for (int num2 = count2 - 1; num2 >= 0; num2--)
				{
					if (pause)
					{
						value2[num2].pauseTime = value2[num2].m_Source.time;
						value2[num2].m_Source.Pause();
						value2[num2].isPaused = true;
					}
					else
					{
						value2[num2].m_Source.Play();
						value2[num2].m_Source.time = value2[num2].pauseTime;
						value2[num2].isPaused = false;
					}
				}
			}
		}
	}

	public bool Stop(AudioEvent soundType, GameObject parentObject = null)
	{
		if (soundType == AudioEvent.NOSOUND)
		{
			return true;
		}
		GameObject key = ((!(parentObject == null)) ? parentObject : gameObject);
		if (!EventsInfo[soundType].MappedPlayingSources.TryGetValue(key, out var value))
		{
			return false;
		}
		for (int i = 0; i < value.Count; i++)
		{
			PlayingSource playingSource = value[i];
			playingSource.m_Source.Stop();
			playingSource.transform.parent = transform;
			playingSource.m_Source.enabled = false;
			EventsInfo[soundType].PooledSources.Push(playingSource);
		}
		value.Clear();
		EventsInfo[soundType].MappedPlayingSources.Remove(key);
		return true;
	}

	public bool PreloadSound(AudioEvent soundType, GameObject parentObject)
	{
		AudioData audioData = EventsInfo[soundType];
		if (audioData == null)
		{
			UnityEngine.Debug.LogWarning("Unrecognized sound type: " + soundType);
			return false;
		}
		if (!ActiveObjects[soundType].Contains(parentObject))
		{
			ActiveObjects[soundType].Add(parentObject);
		}
		if (!audioData.MappedPlayingSources.ContainsKey(parentObject))
		{
			audioData.MappedPlayingSources[parentObject] = new List<PlayingSource>(10);
		}
		return true;
	}

	public bool Play(AudioEvent soundType, GameObject parentObject = null, bool canBePaused = true, Dictionary<ParameterType, float> parameters = null)
	{
		if (soundType == AudioEvent.NOSOUND)
		{
			return true;
		}
		if (parentObject == null)
		{
			parentObject = gameObject;
		}
		AudioData audioData = EventsInfo[soundType];
		if (audioData == null)
		{
			UnityEngine.Debug.LogWarning("Unrecognized sound type: " + soundType);
			return false;
		}
		if (audioData.VolumeGrouping == VolumeSettings.Radio && Singleton<GameManager>.Instance.InGame)
		{
			if (currentRadioEvent != 0)
			{
				return false;
			}
			currentRadioEvent = soundType;
			StopCoroutine("InterpolateDuckingUp");
			SetVolume(VolumeSettings.SFX, Singleton<Profile>.Instance.Settings.GetVolume(VolumeSettings.SFX) * sfxDuckingModifier, isDucking: true);
		}
		if (audioData.PooledSources.Count <= 0)
		{
			audioData.PooledSources.Push(audioData.PlayingSources.Dequeue());
		}
		bool flag = false;
		flag = ((!audioData.ParametrizedSource) ? PlaySound(soundType, audioData, parentObject, canBePaused) : PlayParameterSound(soundType, audioData, parentObject, canBePaused, parameters));
		if (flag && !ActiveObjects[soundType].Contains(parentObject))
		{
			ActiveObjects[soundType].Add(parentObject);
		}
		return flag;
	}

	private IEnumerator InterpolateDuckingUp()
	{
		float timer = 0f;
		while (timer < duckingInterpTime)
		{
			timer += Time.deltaTime;
			SetVolume(VolumeSettings.SFX, Singleton<Profile>.Instance.Settings.GetVolume(VolumeSettings.SFX) * Mathf.Lerp(sfxDuckingModifier, 1f, timer / duckingInterpTime), isDucking: true);
			yield return null;
		}
		SetVolume(VolumeSettings.SFX, Singleton<Profile>.Instance.Settings.GetVolume(VolumeSettings.SFX), isDucking: false);
	}

	public bool PlayOneShot(AudioEvent soundType, GameObject parentObject = null, bool canBePaused = true)
	{
		if (soundType == AudioEvent.NOSOUND)
		{
			return false;
		}
		if (parentObject == null)
		{
			parentObject = gameObject;
		}
		AudioData audioData = EventsInfo[soundType];
		if (audioData == null)
		{
			UnityEngine.Debug.LogWarning("Unrecognized sound type: " + soundType);
			return false;
		}
		if (audioData.VolumeGrouping == VolumeSettings.Radio && Singleton<GameManager>.Instance.InGame)
		{
			if (currentRadioEvent != 0)
			{
				return false;
			}
			currentRadioEvent = soundType;
		}
		PlayingSource playingSource = audioData.PooledSources.Pop();
		AudioSource source = playingSource.m_Source;
		int index = UnityEngine.Random.Range(0, audioData.UsedLocSounds.Count);
		source.clip = audioData.UsedLocSounds[index].ClipFile;
		source.loop = audioData.Looping;
		source.volume = VolumeGroups[(int)audioData.VolumeGrouping];
		if ((bool)parentObject)
		{
			playingSource.transform.parent = parentObject.transform;
			playingSource.transform.localPosition = Vector3.zero;
		}
		source.gameObject.SetActive(value: true);
		source.enabled = true;
		if (isPaused && canBePaused)
		{
			playingSource.pauseTime = 0f;
			playingSource.isPaused = true;
		}
		else
		{
			source.Play();
		}
		source.volume *= audioData.UsedLocSounds[index].Volume;
		UnityEngine.Object.Destroy(source.gameObject, source.clip.length);
		return true;
	}

	private bool PlaySound(AudioEvent soundType, AudioData data, GameObject parentObject, bool canBePaused)
	{
		PlayingSource playingSource = data.PooledSources.Pop();
		AudioSource source = playingSource.m_Source;
		playingSource.canBePaused = canBePaused;
		data.PlayingSources.Enqueue(playingSource);
		if (source == null)
		{
			UnityEngine.Debug.Log(string.Concat("Null source for object", parentObject, "event type", soundType.ToString()));
		}
		int index = UnityEngine.Random.Range(0, data.UsedLocSounds.Count);
		source.clip = data.UsedLocSounds[index].ClipFile;
		source.loop = data.Looping;
		source.volume = VolumeGroups[(int)data.VolumeGrouping];
		if (forcePosition)
		{
			playingSource.transform.position = PlayPosition;
		}
		else if ((bool)parentObject)
		{
			playingSource.transform.parent = parentObject.transform;
			playingSource.transform.localPosition = Vector3.zero;
		}
		source.gameObject.SetActive(value: true);
		source.enabled = true;
		if (isPaused && canBePaused)
		{
			playingSource.pauseTime = 0f;
			playingSource.isPaused = true;
		}
		else
		{
			source.Play();
		}
		source.volume *= data.UsedLocSounds[index].Volume;
		if (!data.MappedPlayingSources.ContainsKey(parentObject))
		{
			data.MappedPlayingSources[parentObject] = new List<PlayingSource>(5);
		}
		data.MappedPlayingSources[parentObject].Add(playingSource);
		return true;
	}

	private bool PlayParameterSound(AudioEvent soundType, AudioData data, GameObject parentObject, bool canBePaused = true, Dictionary<ParameterType, float> parameters = null)
	{
		if (parentObject == null)
		{
			parentObject = gameObject;
		}
		if (!data.MappedPlayingSources.ContainsKey(parentObject))
		{
			data.MappedPlayingSources[parentObject] = new List<PlayingSource>(10);
		}
		if (data.UsedLocSounds.Count > data.PooledSources.Count)
		{
			UnityEngine.Debug.LogWarning("Pool emptied for sound: " + soundType);
			return false;
		}
		float num = VolumeGroups[(int)data.VolumeGrouping];
		int count = data.UsedLocSounds.Count;
		for (int i = 0; i < count; i++)
		{
			ParametrizedPlayingSource parametrizedPlayingSource = data.PooledSources.Pop() as ParametrizedPlayingSource;
			AudioSource source = parametrizedPlayingSource.m_Source;
			parametrizedPlayingSource.canBePaused = canBePaused;
			if (forcePosition)
			{
				parametrizedPlayingSource.transform.position = PlayPosition;
			}
			else
			{
				parametrizedPlayingSource.transform.parent = parentObject.transform;
				parametrizedPlayingSource.transform.localPosition = Vector3.zero;
			}
			source.gameObject.SetActive(value: true);
			source.enabled = true;
			data.MappedPlayingSources[parentObject].Add(parametrizedPlayingSource);
			float num2 = 1f;
			int count2 = parametrizedPlayingSource.ParameterValues.Count;
			for (int j = 0; j < count2; j++)
			{
				Parameter parameter = parametrizedPlayingSource.ParameterValues[j];
				if (parameters.TryGetValue(parameter.Type, out var value))
				{
					parameter.Value = value;
				}
				num2 *= parameter.Evaluate();
			}
			source.volume = num * num2 * parametrizedPlayingSource.ClipVolume;
			if (isPaused && canBePaused)
			{
				parametrizedPlayingSource.pauseTime = 0f;
				parametrizedPlayingSource.isPaused = true;
			}
			else
			{
				source.Play();
			}
		}
		return true;
	}

	public bool SetParameter(AudioEvent soundType, ParameterType paramType, float parameterValue, GameObject parentObject, bool canBePaused)
	{
		if (soundType == AudioEvent.NOSOUND)
		{
			return true;
		}
		if (parentObject == null)
		{
			parentObject = gameObject;
		}
		if (EventsInfo.TryGetValue(soundType, out var value) && value.MappedPlayingSources.TryGetValue(parentObject, out var value2))
		{
			float num = VolumeGroups[(int)value.VolumeGrouping];
			int count = value2.Count;
			for (int i = 0; i < count; i++)
			{
				ParametrizedPlayingSource parametrizedPlayingSource = value2[i] as ParametrizedPlayingSource;
				float num2 = 1f;
				int count2 = parametrizedPlayingSource.ParameterValues.Count;
				for (int j = 0; j < count2; j++)
				{
					Parameter parameter = parametrizedPlayingSource.ParameterValues[j];
					if (parameter.Type == paramType)
					{
						parameter.Value = parameterValue;
					}
					num2 *= parameter.Evaluate();
				}
				parametrizedPlayingSource.m_Source.volume = num * num2 * parametrizedPlayingSource.ClipVolume;
			}
			return true;
		}
		Dictionary<ParameterType, float> dictionary = new Dictionary<ParameterType, float>();
		dictionary[paramType] = parameterValue;
		Play(soundType, parentObject, canBePaused, dictionary);
		return false;
	}

	public void SetVolume(VolumeSettings group, float volume, bool isDucking)
	{
		VolumeGroups[(int)group] = volume;
		if (isDucking)
		{
			foreach (AudioData value in EventsInfo.Values)
			{
				if (value.VolumeGrouping == group && value.canBeDucked && !value.ParametrizedSource)
				{
					foreach (PlayingSource playingSource in value.PlayingSources)
					{
						playingSource.m_Source.volume = volume;
					}
				}
			}
			return;
		}
		foreach (AudioData value2 in EventsInfo.Values)
		{
			if (value2.VolumeGrouping != group || value2.ParametrizedSource)
			{
				continue;
			}
			foreach (PlayingSource playingSource2 in value2.PlayingSources)
			{
				playingSource2.m_Source.volume = volume;
			}
		}
	}

	public void Restart()
	{
		foreach (AudioData value in EventsInfo.Values)
		{
			foreach (PlayingSource playingSource in value.PlayingSources)
			{
				if (playingSource.m_Source != null)
				{
					UnityEngine.Object.Destroy(playingSource.m_Source.gameObject);
				}
			}
			foreach (PlayingSource pooledSource in value.PooledSources)
			{
				if (pooledSource.m_Source != null)
				{
					UnityEngine.Object.Destroy(pooledSource.m_Source.gameObject);
				}
			}
			value.PlayingSources.Clear();
			value.PooledSources.Clear();
		}
		ActiveObjects.Clear();
		Init();
	}

	private void OnLevelWasLoaded(int level)
	{
		if (level != 2)
		{
			Restart();
		}
	}

	public void PlayInLocation(AudioEvent ExplodeAudioEvent, Vector3 position)
	{
		PlayPosition = position;
		forcePosition = true;
		Play(ExplodeAudioEvent);
		forcePosition = false;
	}
}
public class CameraAnchor : MonoBehaviour
{
	private void Awake()
	{
		Singleton<CameraManager>.Instance.Anchor = base.gameObject;
		GameObject gameObject = GameObject.FindGameObjectWithTag("Neck");
		if (gameObject != null)
		{
			if (Singleton<GameManager>.TryInstance() && Singleton<GameManager>.Instance.InHangar)
			{
				base.transform.position = gameObject.transform.position;
			}
			else
			{
				base.transform.position = new Vector3(base.transform.position.x, gameObject.transform.position.y, base.transform.position.z);
			}
		}
	}
}
public class CameraManager : Singleton<CameraManager>
{
	private GameObject m_anchor;

	[SerializeField]
	private Transform cameraTransform;

	[SerializeField]
	private ScreenFader screenFader;

	[NonSerialized]
	public CameraUIInteraction cameraSomething;

	[NonSerialized]
	[HideInInspector]
	public new Transform transform;

	private bool bNeedToRecenter = true;

	public GameObject Anchor
	{
		get
		{
			return m_anchor;
		}
		set
		{
			m_anchor = value;
			if (m_anchor == null)
			{
				Singleton<CameraManager>.Instance.transform.parent = null;
				UnityEngine.Object.DontDestroyOnLoad(Singleton<CameraManager>.Instance.gameObject);
			}
		}
	}

	protected override void Awake()
	{
		transform = GetComponent<Transform>();
		base.Awake();
		cameraSomething = transform.GetComponentInChildren<CameraUIInteraction>();
		if (m_anchor != null)
		{
			transform.parent = m_anchor.transform;
			transform.localRotation = Quaternion.identity;
			transform.localPosition = Vector3.zero;
			transform.localScale = Vector3.one;
		}
		bNeedToRecenter = true;
	}

	public void FadeToBlack(float duration)
	{
		StopAllCoroutines();
		StartCoroutine(screenFader.FadeOut(duration));
	}

	public void FadeToWhite(float duration)
	{
		StopAllCoroutines();
		StartCoroutine(screenFader.FadeIn(duration));
	}

	private void Update()
	{
		if (m_anchor != null)
		{
			transform.parent = m_anchor.transform;
			transform.localRotation = Quaternion.identity;
			transform.localPosition = Vector3.zero;
			transform.localScale = Vector3.one;
		}
	}

	public Transform GetCamera()
	{
		return cameraTransform;
	}
}
public class PlayerMeshAlpha : MonoBehaviour
{
	[SerializeField]
	private float m_alphaAngle = 70f;

	[SerializeField]
	private float m_alphaAngleYaw = 115f;

	[SerializeField]
	private float m_transitionTime = 0.3f;

	[SerializeField]
	private Shader m_originalShader;

	[SerializeField]
	private Shader m_alphaShader;

	private UnityEngine.Color m_color;

	private Material m_material;

	private float m_currentTransitionTime;

	[NonSerialized]
	[HideInInspector]
	public new Transform transform;

	[NonSerialized]
	[HideInInspector]
	public Renderer renderer;

	protected void Awake()
	{
		transform = GetComponent<Transform>();
		renderer = GetComponent<Renderer>();
	}

	private void Start()
	{
		m_material = transform.GetComponent<Renderer>().material;
		m_color = UnityEngine.Color.white;
		if (m_originalShader == null)
		{
			m_originalShader = Shader.Find("Mobile/Diffuse");
		}
		if (m_alphaShader == null)
		{
			m_alphaShader = Shader.Find("Transparent/Diffuse");
		}
		m_material.shader = m_originalShader;
	}

	private void Update()
	{
		float num = Vector3.Dot(transform.up, Singleton<CameraManager>.Instance.GetCamera().up);
		float value = Vector3.Dot(transform.forward, -Singleton<CameraManager>.Instance.GetCamera().forward);
		value = 57.29578f * Mathf.Acos(Mathf.Clamp(value, -1f, 1f));
		if (m_material.shader == m_originalShader)
		{
			if (num < 0f || value > m_alphaAngleYaw)
			{
				m_material.shader = m_alphaShader;
				m_currentTransitionTime = m_transitionTime;
				return;
			}
			num = 57.29578f * Mathf.Acos(num);
			if (num > m_alphaAngle)
			{
				m_material.shader = m_alphaShader;
				m_currentTransitionTime = m_transitionTime;
			}
		}
		else if (m_currentTransitionTime > 0f)
		{
			m_currentTransitionTime -= Time.unscaledDeltaTime;
			m_currentTransitionTime = Mathf.Clamp(m_currentTransitionTime, 0f, 1f);
			m_color.a = m_currentTransitionTime / m_transitionTime;
			m_material.color = m_color;
			if (m_color.a <= 0f)
			{
				renderer.enabled = false;
			}
		}
		else if (m_currentTransitionTime < 0f)
		{
			renderer.enabled = true;
			m_currentTransitionTime += Time.unscaledDeltaTime;
			m_color.a = 1f + m_currentTransitionTime / m_transitionTime;
			m_material.color = m_color;
			if (m_currentTransitionTime >= 0f)
			{
				m_material.shader = m_originalShader;
			}
		}
		else if (num > 0f && value < m_alphaAngleYaw)
		{
			num = 57.29578f * Mathf.Acos(num);
			if (num < m_alphaAngle)
			{
				m_currentTransitionTime = 0f - m_transitionTime;
			}
		}
	}
}
public class VRSkybox : MonoBehaviour
{
	public enum Shape
	{
		Sphere,
		Cube
	}

	public Material material;

	public float radius = 1200f;

	public int segments = 32;

	public Shape shape;

	public GameObject follow;

	public Material skybox;

	public Color32 fogColour;

	public float fogDensity;

	public Color32 ambientColour;

	private void Awake()
	{
		RenderSettings.fogColor = fogColour;
		RenderSettings.fogDensity = fogDensity;
		RenderSettings.fog = true;
		RenderSettings.ambientLight = ambientColour;
		RenderSettings.skybox = skybox;
	}
}
public class ApplicationManager : Singleton<ApplicationManager>
{
	private void Update()
	{
	}
}
public class Boot : MonoBehaviour
{
	[SerializeField]
	private string[] m_bootSequenceNames = new string[0];

	[SerializeField]
	private float m_splashDisplayTimes = 3f;

	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void Start()
	{
		if (!Singleton<GameManager>.TryInstance())
		{
			Singleton<GameManager>.Instance.Init();
		}
		if (Application.loadedLevel == 0)
		{
			Singleton<LoadingScreen>.Instance.LoadSplash(m_bootSequenceNames, m_splashDisplayTimes);
		}
	}
}
public class InputUtils
{
	private static string Fire1Name = "Fire1";

	private static string FireTurretName = "FireTurret";

	public static bool GetFire1ButtonDown()
	{
		if (IsTrackedRemoteActive())
		{
			return OVRInput.GetDown(OVRInput.Button.PrimaryTouchpad);
		}
		return Input.GetButtonDown(Fire1Name);
	}

	public static bool GetMenuButtonPressed()
	{
		if (IsTrackedRemoteActive())
		{
			return OVRInput.GetDown(OVRInput.Button.PrimaryTouchpad) || OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger);
		}
		return Input.GetButtonDown(Fire1Name);
	}

	public static bool GetPauseButtonDown()
	{
		return false;
	}

	public static bool IsFiring()
	{
		if (IsTrackedRemoteActive())
		{
			return OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger);
		}
		if (IsGamepadActive())
		{
			return Input.GetButton(Fire1Name) || OVRInput.Get(OVRInput.Button.SecondaryIndexTrigger, OVRInput.Controller.Gamepad);
		}
		return Input.GetButton(Fire1Name);
	}

	public static bool IsTrackedRemoteActive()
	{
		OVRInput.Controller activeController = OVRInput.GetActiveController();
		return activeController == OVRInput.Controller.RTrackedRemote || activeController == OVRInput.Controller.LTrackedRemote;
	}

	public static bool IsGamepadActive()
	{
		return OVRInput.GetActiveController() == OVRInput.Controller.Gamepad;
	}
}
public class InstantiateUnity43Prefab : MonoBehaviour
{
	public GameObject Prefab;

	private void Awake()
	{
	}
}
public class LoadingScreen : Singleton<LoadingScreen>
{
	public enum ComingFrom
	{
		Boot,
		MainMenu,
		Game
	}

	private AsyncOperation m_asyncLoading;

	private ComingFrom m_CameFrom;

	private GameObject m_queueCameraAnchor;

	private bool m_instantAnchorActivation;

	private static GameObject m_loadingIcon;

	private float m_fadeTime = 0.3f;

	protected override void Awake()
	{
		isPersistant = true;
		base.Awake();
		if (m_loadingIcon == null)
		{
			m_loadingIcon = UnityEngine.Object.Instantiate(Resources.Load("GUI/LoadingIcon")) as GameObject;
			UnityEngine.Object.DontDestroyOnLoad(m_loadingIcon);
		}
		m_loadingIcon.SetActive(value: false);
	}

	public void LoadSplash(string[] sequence, float displayTime)
	{
		StartCoroutine(ShowSplash(sequence, displayTime));
	}

	public void LoadGame()
	{
		m_CameFrom = ComingFrom.MainMenu;
		Singleton<GameManager>.Instance.InHangar = false;
		Singleton<GameManager>.Instance.InGame = true;
		StartLoading(4);
	}

	public void LoadOpening()
	{
		Singleton<GameManager>.Instance.InHangar = false;
		Singleton<GameManager>.Instance.InGame = false;
		SceneManager.LoadScene(7);
	}

	public void LoadOpeningFromMenu()
	{
		m_CameFrom = ComingFrom.Boot;
		Singleton<GameManager>.Instance.InHangar = false;
		Singleton<GameManager>.Instance.InGame = false;
		StartLoading(7);
	}

	public void LoadMenu(ComingFrom cameFrom)
	{
		m_CameFrom = cameFrom;
		if (m_CameFrom == ComingFrom.Game)
		{
			Singleton<GameManager>.Instance.OnLevelExit();
		}
		Singleton<GameManager>.Instance.InHangar = true;
		Singleton<GameManager>.Instance.InGame = false;
		StartLoading(3);
	}

	public void LoadEnding(bool showAllStars)
	{
		m_CameFrom = ComingFrom.Game;
		Singleton<GameManager>.Instance.OnShowEnding();
		Singleton<GameManager>.Instance.InHangar = false;
		Singleton<GameManager>.Instance.InGame = false;
		if (showAllStars)
		{
			StartLoading(6);
		}
		else
		{
			StartLoading(5);
		}
	}

	private IEnumerator LoadAsync(int index)
	{
		yield return StartCoroutine(StartFade(fadeToBlack: true));
		Singleton<MenuManager>.Instance.ShowCrosshair(show: false);
		FreeCamera();
		m_instantAnchorActivation = true;
		GC.Collect();
		m_asyncLoading = Resources.UnloadUnusedAssets();
		yield return m_asyncLoading;
		SceneManager.LoadScene("LoadingScreen");
		m_loadingIcon.SetActive(value: true);
		float loadProgress = 0f;
		SimpleLoadProgressBar.UpdateValue(loadProgress);
		yield return new WaitForEndOfFrame();
		yield return new WaitForEndOfFrame();
		GC.Collect();
		m_asyncLoading = Resources.UnloadUnusedAssets();
		yield return m_asyncLoading;
		RenderSettings.skybox = null;
		m_asyncLoading = SceneManager.LoadSceneAsync(index);
		m_asyncLoading.allowSceneActivation = false;
		yield return new WaitForEndOfFrame();
		yield return StartCoroutine(StartFade(fadeToBlack: false));
		m_instantAnchorActivation = false;
		while (m_asyncLoading.progress < 0.9f)
		{
			if (m_asyncLoading.progress > loadProgress)
			{
				loadProgress = m_asyncLoading.progress;
				SimpleLoadProgressBar.UpdateValue(loadProgress);
			}
			yield return null;
		}
		SimpleLoadProgressBar.UpdateValue(1f);
		StartCoroutine(AllDone());
	}

	public void EndLoading()
	{
		SimpleLoadProgressBar.UpdateValue(1f);
		m_asyncLoading = null;
		StartCoroutine(AllDone());
	}

	public void StartLoading(int index)
	{
		if (m_asyncLoading == null)
		{
			StartCoroutine(LoadAsync(index));
		}
	}

	public IEnumerator AllDone()
	{
		while (!SimpleLoadProgressBar.BarFull())
		{
			yield return null;
		}
		yield return StartCoroutine(StartFade(fadeToBlack: true));
		FreeCamera();
		m_asyncLoading.allowSceneActivation = true;
		yield return m_asyncLoading;
		m_asyncLoading = null;
		if (m_CameFrom == ComingFrom.MainMenu)
		{
			Singleton<GameManager>.Instance.OnLevelLoaded();
		}
		else if (Singleton<GameManager>.Instance.State == GameManager.GameState.Ending)
		{
			Singleton<MenuManager>.Instance.ShowCrosshair(show: true);
		}
		else if (Singleton<GameManager>.Instance.InHangar)
		{
			Singleton<MenuManager>.Instance.OnMenuLoaded();
			Singleton<MenuManager>.Instance.ShowCrosshair(show: true);
		}
		yield return new WaitForEndOfFrame();
		UseQueuedAnchor();
		m_loadingIcon.SetActive(value: false);
		if (m_CameFrom == ComingFrom.MainMenu)
		{
			Singleton<MissionManager>.Instance.CurrentMissionSettings.LoadSkybox();
			Singleton<GameManager>.Instance.SetVrPerformanceValues(2);
			Singleton<CameraManager>.Instance.cameraSomething.enabled = false;
		}
		else
		{
			Singleton<CameraManager>.Instance.cameraSomething.enabled = true;
			if (Singleton<GameManager>.Instance.State == GameManager.GameState.Ending)
			{
				Singleton<GameManager>.Instance.SetVrPerformanceValues();
				Singleton<LoadEndingSkybox>.Instance.SetupEndingSkybox();
			}
		}
		if (m_CameFrom == ComingFrom.Boot)
		{
			yield return new WaitForSeconds(1f);
		}
		yield return StartCoroutine(StartFade(fadeToBlack: false));
		UnityEngine.Object.Destroy(base.gameObject);
	}

	public void QueueCameraAnchor(GameObject obj)
	{
		m_queueCameraAnchor = obj;
		if (m_instantAnchorActivation)
		{
			UseQueuedAnchor();
		}
	}

	private void UseQueuedAnchor()
	{
		if ((bool)m_queueCameraAnchor)
		{
			Singleton<CameraManager>.Instance.Anchor = m_queueCameraAnchor;
			m_queueCameraAnchor = null;
		}
	}

	private void FreeCamera()
	{
		Singleton<CameraManager>.Instance.Anchor = null;
	}

	public IEnumerator StartFade(bool fadeToBlack, float duration = -1f)
	{
		if (duration == -1f)
		{
			duration = m_fadeTime;
		}
		if (fadeToBlack)
		{
			Singleton<CameraManager>.Instance.FadeToBlack(duration);
		}
		else
		{
			Singleton<CameraManager>.Instance.FadeToWhite(duration);
		}
		yield return new WaitForSeconds(duration);
	}

	private IEnumerator ShowSplash(string[] sequence, float displayTime)
	{
		m_instantAnchorActivation = true;
		for (int i = 0; i < sequence.Length; i++)
		{
			SceneManager.LoadScene(sequence[i]);
			yield return new WaitForSeconds(displayTime);
			FreeCamera();
		}
		m_instantAnchorActivation = false;
		LoadOpening();
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
[AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = true)]
public class MultilineHeaderAttribute : PropertyAttribute
{
	public readonly string header;

	public readonly int numberOfLines;

	public readonly UnityEngine.Color textColor;

	public MultilineHeaderAttribute(string header)
	{
		this.header = header;
		textColor = new UnityEngine.Color(0.705f, 0.705f, 0.705f);
		numberOfLines = 1;
		int length = header.Length;
		for (int i = 0; i < length; i++)
		{
			if (header[i] == '\n')
			{
				numberOfLines++;
			}
		}
	}

	public MultilineHeaderAttribute(string header, float r, float g, float b)
	{
		this.header = header;
		textColor = new UnityEngine.Color(r, g, b);
		numberOfLines = 1;
		int length = header.Length;
		for (int i = 0; i < length; i++)
		{
			if (header[i] == '\n')
			{
				numberOfLines++;
			}
		}
	}
}
public enum PhoneID
{
	SamsungS6,
	SamsungS7,
	Other
}
public class PhoneIdentifier
{
	private static string[] SamsungS7IDs = new string[2] { "SM-G930", "SM-G935" };

	private static string[] SamsungS6IDs = new string[2] { "SM-G920", "SM-G925" };

	private static string[] USSubIDs = new string[12]
	{
		"0", "8", "AZ", "A", "T1", "R6", "R7", "P", "T", "R4",
		"V", "U"
	};

	public static PhoneID GetPhoneID(string deviceModel)
	{
		if (IsSamsungS6(deviceModel))
		{
			return PhoneID.SamsungS6;
		}
		if (IsSamsungS7(deviceModel))
		{
			return PhoneID.SamsungS7;
		}
		return PhoneID.Other;
	}

	public static bool IsSamsungS7(string deviceModel)
	{
		for (int i = 0; i < SamsungS7IDs.Length; i++)
		{
			if (deviceModel.Contains(SamsungS7IDs[i]))
			{
				return true;
			}
		}
		return false;
	}

	private static bool IsSamsungS6(string deviceModel)
	{
		for (int i = 0; i < SamsungS6IDs.Length; i++)
		{
			if (deviceModel.Contains(SamsungS6IDs[i]))
			{
				return true;
			}
		}
		return false;
	}

	public static bool IsExynosSamsungS7(string deviceModel)
	{
		if (IsSamsungS7(deviceModel))
		{
			int length = Mathf.Min(deviceModel.Length - 7, 2);
			string value = deviceModel.Substring(7, length).Trim();
			return Array.IndexOf(USSubIDs, value) > -1;
		}
		return false;
	}
}
public class Singleton<T> : MonoBehaviour where T : MonoBehaviour
{
	private static T instance;

	private static bool applicationIsQuitting;

	[SerializeField]
	protected bool isPersistant;

	public static T Instance
	{
		get
		{
			if (instance == null)
			{
				instance = UnityEngine.Object.FindObjectOfType<T>();
				if (instance == null && !applicationIsQuitting)
				{
					UnityEngine.Object @object = Resources.Load("Managers/" + typeof(T));
					if (@object != null)
					{
						GameObject gameObject = UnityEngine.Object.Instantiate(@object, Vector3.zero, Quaternion.identity) as GameObject;
						instance = gameObject.GetComponent<T>();
					}
					else
					{
						GameObject gameObject2 = new GameObject("_" + typeof(T));
						instance = gameObject2.AddComponent<T>();
					}
				}
			}
			return instance;
		}
	}

	public static bool TryInstance()
	{
		return instance != null;
	}

	protected virtual void Awake()
	{
		if (instance != null && instance != this)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		instance = (T)(MonoBehaviour)this;
		if (isPersistant && base.transform.parent == null)
		{
			GameObject gameObject = GameObject.Find("PersistantManagers");
			if (gameObject == null)
			{
				gameObject = new GameObject("PersistantManagers");
			}
			instance.transform.parent = gameObject.transform;
		}
	}

	public virtual void OnDestroy()
	{
		if (!Singleton<LoadingScreen>.TryInstance() && UnityEngine.Object.FindObjectsOfType<T>().Length == 0)
		{
			applicationIsQuitting = true;
		}
	}
}
public class TimeInfo : Singleton<TimeInfo>
{
	private float _StartupTime;

	private float _UnscaledDeltaTime;

	private float _PrevFrameTime;

	public float UnscaledDeltaTime => _UnscaledDeltaTime;

	private void Start()
	{
		_StartupTime = Time.realtimeSinceStartup;
		_PrevFrameTime = _StartupTime;
	}

	private void Update()
	{
		_UnscaledDeltaTime = Time.realtimeSinceStartup - _PrevFrameTime;
		_PrevFrameTime = Time.realtimeSinceStartup;
	}
}
[Serializable]
public struct Effect
{
	[NonSerialized]
	public GameObject m_effect;

	public GameObject m_criticalEffect;

	public GameObject[] m_effects;

	public UnityEngine.Color[] colors;

	public ParticleAnimator animator;

	public int m_likelihood;

	public float m_minDamage;

	public float m_critDamage;

	public float m_startSize;

	public float m_startLifeTime;

	public float m_startAmount;

	public float m_maxSize;

	public float m_maxLifeTime;

	public float m_minAmount;

	public float m_maxBlackColor;

	[NonSerialized]
	public bool m_isEmitter;
}
public class DamageEffect : MonoBehaviour
{
	[SerializeField]
	private List<Effect> m_effects;

	private float m_time;

	private float m_curHealth = 1f;

	private bool m_isInited;

	private static readonly float REDUCED_EMISSION_RATE = 0.1f;

	private static readonly float SMOKE_REDUCTION_FACTOR = 6f;

	private void Init()
	{
		List<GameObject> list = new List<GameObject>();
		for (int i = 0; i < m_effects.Count; i++)
		{
			Effect value = m_effects[i];
			for (int j = 0; j < value.m_effects.Length; j++)
			{
				ParticleEmitter component = value.m_effects[j].GetComponent<ParticleEmitter>();
				if ((bool)component)
				{
					component.emit = false;
					component.maxEmission = ((!Singleton<GameManager>.Instance.ReduceQuality) ? value.m_startAmount : (value.m_startAmount / SMOKE_REDUCTION_FACTOR));
					component.minEmission = 0f;
				}
				else
				{
					ParticleSystem component2 = value.m_effects[j].GetComponent<ParticleSystem>();
					component2.enableEmission = false;
				}
			}
			int num = 0;
			while (num++ < 10 && value.m_effect == null)
			{
				int num2 = UnityEngine.Random.Range(0, value.m_effects.Length);
				value.m_effect = value.m_effects[num2];
				for (int k = 0; k < list.Count; k++)
				{
					if (list[k] == value.m_effects[num2])
					{
						value.m_effect = null;
					}
				}
			}
			if (value.m_effect != null)
			{
				list.Add(value.m_effect);
				value.colors = value.m_effect.GetComponent<ParticleAnimator>().colorAnimation;
				value.animator = value.m_effect.GetComponent<ParticleAnimator>();
				ParticleEmitter component3 = value.m_effect.GetComponent<ParticleEmitter>();
				if ((bool)component3)
				{
					component3.maxSize = value.m_startSize;
					component3.maxEnergy = value.m_startLifeTime;
					component3.maxEmission = ((!Singleton<GameManager>.Instance.ReduceQuality) ? value.m_startAmount : (value.m_startAmount / SMOKE_REDUCTION_FACTOR));
					component3.minEmission = 0f;
					value.m_isEmitter = true;
				}
				else
				{
					ParticleSystem component4 = value.m_effect.GetComponent<ParticleSystem>();
					component4.startSize = value.m_startSize;
					component4.startLifetime = value.m_startLifeTime;
					value.m_isEmitter = false;
				}
				m_effects[i] = value;
			}
		}
		m_isInited = true;
	}

	public void UpdateSmoke(float health)
	{
		if (health <= 0f && m_isInited)
		{
			m_time += Time.deltaTime;
			if (m_time > 3f)
			{
				OnDisable();
				return;
			}
		}
		if (health > 0f && health < m_curHealth && !m_isInited)
		{
			Init();
		}
		if (!m_isInited)
		{
			return;
		}
		if (health >= 1f && m_curHealth < 1f)
		{
			for (int i = 0; i < m_effects.Count; i++)
			{
				Effect effect = m_effects[i];
				if (effect.m_criticalEffect != null)
				{
					if ((bool)effect.m_criticalEffect.GetComponent<ParticleEmitter>())
					{
						effect.m_criticalEffect.GetComponent<ParticleEmitter>().emit = false;
					}
					else
					{
						effect.m_criticalEffect.GetComponent<ParticleSystem>().enableEmission = false;
						if (Singleton<GameManager>.Instance.ReduceQuality)
						{
							ParticleSystem.EmissionModule emission = effect.m_criticalEffect.GetComponent<ParticleSystem>().emission;
							emission.rateOverDistance = REDUCED_EMISSION_RATE;
						}
					}
				}
				if (effect.m_effect == null)
				{
					continue;
				}
				if (effect.m_isEmitter)
				{
					effect.m_effect.GetComponent<ParticleEmitter>().emit = false;
					continue;
				}
				effect.m_effect.GetComponent<ParticleSystem>().enableEmission = false;
				if (Singleton<GameManager>.Instance.ReduceQuality)
				{
					ParticleSystem.EmissionModule emission2 = effect.m_effect.GetComponent<ParticleSystem>().emission;
					emission2.rateOverDistance = REDUCED_EMISSION_RATE;
				}
			}
			m_curHealth = health;
		}
		else
		{
			if (health >= m_curHealth)
			{
				return;
			}
			for (int j = 0; j < m_effects.Count; j++)
			{
				Effect effect2 = m_effects[j];
				if (effect2.m_effect == null)
				{
					continue;
				}
				bool flag = ((!effect2.m_isEmitter) ? effect2.m_effect.GetComponent<ParticleSystem>().enableEmission : effect2.m_effect.GetComponent<ParticleEmitter>().emit);
				if (!flag && effect2.m_criticalEffect != null)
				{
					flag = effect2.m_criticalEffect.GetComponent<ParticleSystem>().enableEmission;
				}
				if (flag)
				{
					if (effect2.m_criticalEffect != null && health <= effect2.m_critDamage && !effect2.m_criticalEffect.GetComponent<ParticleSystem>().enableEmission)
					{
						m_effects[j].m_criticalEffect.GetComponent<ParticleSystem>().enableEmission = true;
						if (Singleton<GameManager>.Instance.ReduceQuality)
						{
							ParticleSystem.EmissionModule emission3 = m_effects[j].m_criticalEffect.GetComponent<ParticleSystem>().emission;
							emission3.rateOverDistance = REDUCED_EMISSION_RATE;
						}
						if (m_effects[j].m_isEmitter)
						{
							m_effects[j].m_effect.GetComponent<ParticleEmitter>().emit = false;
						}
						else
						{
							m_effects[j].m_effect.GetComponent<ParticleSystem>().enableEmission = false;
						}
						Vector3 localPosition = m_effects[j].m_criticalEffect.transform.localPosition;
						localPosition.x = m_effects[j].m_effect.transform.localPosition.x;
						localPosition.y = m_effects[j].m_effect.transform.localPosition.y;
						m_effects[j].m_criticalEffect.transform.localPosition = localPosition;
					}
					float num = effect2.m_startSize + (1f - health) * effect2.m_maxSize;
					float num2 = effect2.m_startLifeTime + (1f - health) * effect2.m_startLifeTime;
					float num3 = effect2.m_maxBlackColor + (1f - effect2.m_maxBlackColor) * health;
					UnityEngine.Color color = new UnityEngine.Color(num3, num3, num3, 1f);
					if (effect2.m_isEmitter)
					{
						ParticleEmitter component = effect2.m_effect.GetComponent<ParticleEmitter>();
						component.maxSize = num;
						component.maxEnergy = num2;
						float num4 = effect2.m_minAmount + (effect2.m_startAmount - effect2.m_minAmount) * health;
						component.maxEmission = ((!Singleton<GameManager>.Instance.ReduceQuality) ? num4 : (num4 / SMOKE_REDUCTION_FACTOR));
						effect2.colors[0] = color;
						effect2.colors[1] = color;
						effect2.animator.colorAnimation = effect2.colors;
					}
					else
					{
						ParticleSystem component2 = effect2.m_effect.GetComponent<ParticleSystem>();
						component2.startSize = num;
						component2.startLifetime = num2;
						component2.startColor = color;
						if (Singleton<GameManager>.Instance.ReduceQuality)
						{
							ParticleSystem.EmissionModule emission4 = component2.emission;
							emission4.rateOverDistance = REDUCED_EMISSION_RATE;
						}
					}
				}
				else
				{
					if (!(health <= effect2.m_minDamage))
					{
						continue;
					}
					int num5 = UnityEngine.Random.Range(0, 100);
					if (num5 >= m_effects[j].m_likelihood)
					{
						continue;
					}
					if (m_effects[j].m_isEmitter)
					{
						m_effects[j].m_effect.GetComponent<ParticleEmitter>().emit = true;
						continue;
					}
					m_effects[j].m_effect.GetComponent<ParticleSystem>().enableEmission = true;
					if (Singleton<GameManager>.Instance.ReduceQuality)
					{
						ParticleSystem.EmissionModule emission5 = m_effects[j].m_effect.GetComponent<ParticleSystem>().emission;
						emission5.rateOverDistance = REDUCED_EMISSION_RATE;
					}
				}
			}
			m_curHealth = health;
		}
	}

	private void OnDisable()
	{
		if (m_isInited)
		{
			UpdateSmoke(1f);
			m_isInited = false;
			m_time = 0f;
			return;
		}
		for (int num = base.transform.childCount - 1; num >= 0; num--)
		{
			base.transform.GetChild(num).gameObject.SetActive(value: false);
		}
	}

	private void OnEnable()
	{
		for (int num = base.transform.childCount - 1; num >= 0; num--)
		{
			base.transform.GetChild(num).gameObject.SetActive(value: true);
		}
	}
}
[RequireComponent(typeof(MeshFilter))]
[RequireComponent(typeof(MeshRenderer))]
public class MassLineRenderer : Singleton<MassLineRenderer>
{
	private enum MeshTypes
	{
		Bullets,
		HPBar,
		RadarPointer,
		MAX
	}

	public const int MAX_BULLETS = 200;

	private const int MAX_RADAR_POINTERS = 35;

	private const int MAX_HP_BARS = 35;

	private const int NUM_BUFFERS = 2;

	[SerializeField]
	public float trailWidth = 0.2f;

	[SerializeField]
	public float specialTrailWidth = 0.5f;

	[SerializeField]
	public float trailLength = 15f;

	[SerializeField]
	private float m_bigPointerLength = 0.06f;

	[SerializeField]
	private float m_smallPointerLength = 0.02f;

	[SerializeField]
	private float m_pointerHalfWidth = 0.025f;

	[SerializeField]
	private Vector2 m_hpBackSize = new Vector2(4.4f, 0.5f);

	[SerializeField]
	private Vector2 m_hpFrontSize = new Vector2(4.2f, 0.3f);

	private MeshFilter m_meshFilter;

	private Mesh[] m_mesh = new Mesh[2];

	private int m_activeMeshIndex;

	private Vector3[] m_vertices;

	private Vector3[] m_normals;

	private Vector2[] m_uvs;

	private int[] m_triangles;

	private UnityEngine.Color[] m_colors;

	private Bounds m_bounds = new Bounds(Vector3.zero, new Vector3(10000f, 10000f, 10000f));

	private int[] m_vertexCounts = new int[3] { 4, 8, 4 };

	private int[] m_triangleCounts = new int[3] { 6, 12, 6 };

	private int[] m_maxObjects = new int[3] { 200, 35, 35 };

	private int[] m_counts = new int[3];

	private int[] m_activeCounts = new int[3];

	public List<Bullet> bullets = new List<Bullet>(200);

	private List<Bullet> m_removeBullets = new List<Bullet>(50);

	public List<RadarPointer> radarPointers = new List<RadarPointer>(35);

	private List<RadarPointer> m_removeRadarPointer = new List<RadarPointer>(10);

	public List<SimpleHealthBar> healthBars = new List<SimpleHealthBar>(35);

	private List<SimpleHealthBar> m_removeHealthBars = new List<SimpleHealthBar>(20);

	private Vector2[] m_uvBullets = new Vector2[4]
	{
		new Vector2(1f, 1f),
		new Vector2(1f, 0.5f),
		new Vector2(0f, 1f),
		new Vector2(0f, 0.5f)
	};

	private Vector2[] m_uvBulletsSpecial = new Vector2[4]
	{
		new Vector2(1f, 0.5f),
		new Vector2(1f, 0f),
		new Vector2(0f, 0.5f),
		new Vector2(0f, 0f)
	};

	private Vector2[] m_uvWhite = new Vector2[4]
	{
		new Vector2(0.26f, 0.25f),
		new Vector2(0.26f, 0.24f),
		new Vector2(0.25f, 0.25f),
		new Vector2(0.25f, 0.24f)
	};

	protected override void Awake()
	{
		base.Awake();
		for (int i = 0; i < 2; i++)
		{
			m_mesh[i] = new Mesh();
			m_mesh[i].Clear();
			m_mesh[i].MarkDynamic();
			m_mesh[i].bounds = m_bounds;
		}
		m_meshFilter = GetComponent<MeshFilter>();
		m_meshFilter.sharedMesh = m_mesh[m_activeMeshIndex];
		int num = 0;
		for (int j = 0; j < 3; j++)
		{
			num += m_maxObjects[j] * m_vertexCounts[j];
		}
		m_vertices = new Vector3[num];
		m_uvs = new Vector2[num];
		m_colors = new UnityEngine.Color[num];
		int num2 = 0;
		for (int k = 0; k < 3; k++)
		{
			num2 += m_maxObjects[k] * m_triangleCounts[k];
		}
		m_triangles = new int[num2];
		int num3 = 0;
		int num4 = 0;
		for (int l = 0; l < 3; l++)
		{
			for (int m = 0; m < m_maxObjects[l]; m++)
			{
				int num5 = num3 + m * m_vertexCounts[l];
				for (int n = 0; n < m_vertexCounts[l]; n++)
				{
					ref Vector3 reference = ref m_vertices[num5 + n];
					reference = Vector3.zero;
					if (l == 1)
					{
						ref UnityEngine.Color reference2 = ref m_colors[num5 + n];
						reference2 = UnityEngine.Color.black;
					}
					else
					{
						ref UnityEngine.Color reference3 = ref m_colors[num5 + n];
						reference3 = UnityEngine.Color.white;
					}
				}
				int num6 = num4 + m * m_triangleCounts[l];
				if (m_triangleCounts[l] > 0)
				{
					m_triangles[num6 + 2] = num5;
					m_triangles[num6 + 1] = num5 + 1;
					m_triangles[num6] = num5 + 2;
				}
				if (m_triangleCounts[l] > 3)
				{
					m_triangles[num6 + 5] = num5 + 3;
					m_triangles[num6 + 4] = num5 + 2;
					m_triangles[num6 + 3] = num5 + 1;
				}
				if (m_triangleCounts[l] > 6)
				{
					m_triangles[num6 + 8] = num5 + 4;
					m_triangles[num6 + 7] = num5 + 5;
					m_triangles[num6 + 6] = num5 + 6;
				}
				if (m_triangleCounts[l] > 9)
				{
					m_triangles[num6 + 11] = num5 + 7;
					m_triangles[num6 + 10] = num5 + 6;
					m_triangles[num6 + 9] = num5 + 5;
				}
				if (l == 1 || l == 2)
				{
					for (int num7 = 0; num7 < m_vertexCounts[l]; num7++)
					{
						ref Vector2 reference4 = ref m_uvs[num5 + num7];
						reference4 = m_uvWhite[num7 % 4];
					}
				}
			}
			num3 += m_maxObjects[l] * m_vertexCounts[l];
			num4 += m_maxObjects[l] * m_triangleCounts[l];
		}
		for (int num8 = 0; num8 < 2; num8++)
		{
			m_mesh[num8].vertices = m_vertices;
			m_mesh[num8].triangles = m_triangles;
			m_mesh[num8].bounds = m_bounds;
		}
	}

	private void LateUpdate()
	{
		UpdateMeshes();
		CleanupMeshes();
		Mesh mesh = m_mesh[m_activeMeshIndex];
		mesh.vertices = m_vertices;
		mesh.uv = m_uvs;
		mesh.colors = m_colors;
		mesh.bounds = m_bounds;
		m_meshFilter.sharedMesh = mesh;
		m_activeMeshIndex = (m_activeMeshIndex + 1) % 2;
	}

	private void UpdateMeshes()
	{
		int i = 0;
		int num = -1;
		for (MeshTypes meshTypes = MeshTypes.Bullets; meshTypes < MeshTypes.MAX; i += m_maxObjects[num] * m_vertexCounts[num], meshTypes++)
		{
			num = (int)meshTypes;
			int num2 = 0;
			switch (meshTypes)
			{
			case MeshTypes.Bullets:
				num2 = Mathf.Min(200, bullets.Count);
				break;
			case MeshTypes.RadarPointer:
				num2 = Mathf.Min(35, radarPointers.Count);
				break;
			case MeshTypes.HPBar:
				num2 = Mathf.Min(35, healthBars.Count);
				break;
			}
			m_activeCounts[num] = 0;
			if (num2 <= 0)
			{
				continue;
			}
			switch (meshTypes)
			{
			case MeshTypes.Bullets:
			{
				int num4 = i;
				int count = bullets.Count;
				for (int k = 0; k < count; k++)
				{
					Bullet bullet = bullets[k];
					if (bullet.gameObject.activeSelf && bullet.isActive)
					{
						ref Vector3 reference11 = ref m_vertices[num4];
						reference11 = bullet.transform.position + bullet.perpendicular;
						ref Vector3 reference12 = ref m_vertices[num4 + 1];
						reference12 = bullet.transform.position - bullet.perpendicular;
						ref Vector3 reference13 = ref m_vertices[num4 + 2];
						reference13 = m_vertices[num4] + bullet.forwardLength;
						ref Vector3 reference14 = ref m_vertices[num4 + 3];
						reference14 = m_vertices[num4 + 1] + bullet.forwardLength;
						if (!bullet.SpecialBullet)
						{
							for (int l = 0; l < 4; l++)
							{
								ref Vector2 reference15 = ref m_uvs[num4 + l];
								reference15 = m_uvBullets[l];
							}
						}
						else
						{
							for (int m = 0; m < 4; m++)
							{
								ref Vector2 reference16 = ref m_uvs[num4 + m];
								reference16 = m_uvBulletsSpecial[m];
							}
						}
						m_activeCounts[num]++;
						num4 += m_vertexCounts[num];
					}
					else
					{
						m_removeBullets.Add(bullet);
					}
				}
				continue;
			}
			case MeshTypes.RadarPointer:
			{
				if (Singleton<GameManager>.Instance.IsPaused)
				{
					break;
				}
				int num3 = i;
				for (int j = 0; j < num2; j++)
				{
					RadarPointer radarPointer = radarPointers[j];
					if (radarPointer.gameObject.activeSelf)
					{
						Vector3 vector = radarPointer.transform.up * radarPointer.Scale * ((!radarPointer.ShowingBigPointer) ? m_smallPointerLength : m_bigPointerLength);
						Vector3 vector2 = Vector3.Cross(radarPointer.transform.up, radarPointer.transform.forward).normalized * m_pointerHalfWidth * radarPointer.Scale;
						ref Vector3 reference = ref m_vertices[num3];
						reference = radarPointer.transform.position + vector2;
						ref Vector3 reference2 = ref m_vertices[num3 + 1];
						reference2 = radarPointer.transform.position - vector2;
						if (radarPointer.ShowingBigPointer)
						{
							ref Vector3 reference3 = ref m_vertices[num3 + 2];
							reference3 = radarPointer.transform.position + vector;
							ref Vector3 reference4 = ref m_vertices[num3 + 3];
							reference4 = m_vertices[num3 + 2];
						}
						else
						{
							ref Vector3 reference5 = ref m_vertices[num3 + 2];
							reference5 = m_vertices[num3] + vector;
							ref Vector3 reference6 = ref m_vertices[num3 + 3];
							reference6 = m_vertices[num3 + 1] + vector;
						}
						ref UnityEngine.Color reference7 = ref m_colors[num3];
						ref UnityEngine.Color reference8 = ref m_colors[num3 + 1];
						ref UnityEngine.Color reference9 = ref m_colors[num3 + 2];
						ref UnityEngine.Color reference10 = ref m_colors[num3 + 3];
						reference7 = (reference8 = (reference9 = (reference10 = radarPointer.CurrentColor)));
						m_activeCounts[num]++;
						num3 += m_vertexCounts[num];
					}
					else
					{
						m_removeRadarPointer.Add(radarPointer);
					}
				}
				continue;
			}
			}
			if (meshTypes != MeshTypes.HPBar || Singleton<GameManager>.Instance.IsPaused)
			{
				continue;
			}
			int num5 = i;
			for (int n = 0; n < num2; n++)
			{
				SimpleHealthBar simpleHealthBar = healthBars[n];
				if (simpleHealthBar.gameObject.activeSelf)
				{
					Transform transform = simpleHealthBar.transform;
					Vector3 vector3 = transform.right * m_hpBackSize.x * transform.localScale.x;
					Vector3 vector4 = transform.up * m_hpBackSize.y * transform.localScale.y;
					ref Vector3 reference17 = ref m_vertices[num5];
					reference17 = transform.position + vector3 + vector4;
					ref Vector3 reference18 = ref m_vertices[num5 + 1];
					reference18 = transform.position + vector3 - vector4;
					ref Vector3 reference19 = ref m_vertices[num5 + 2];
					reference19 = transform.position - vector3 + vector4;
					ref Vector3 reference20 = ref m_vertices[num5 + 3];
					reference20 = transform.position - vector3 - vector4;
					vector3 = transform.right * m_hpFrontSize.x * transform.localScale.x;
					vector4 = transform.up * m_hpFrontSize.y * transform.localScale.y;
					ref Vector3 reference21 = ref m_vertices[num5 + 6];
					reference21 = transform.position - vector3 + vector4;
					ref Vector3 reference22 = ref m_vertices[num5 + 7];
					reference22 = transform.position - vector3 - vector4;
					ref Vector3 reference23 = ref m_vertices[num5 + 4];
					reference23 = m_vertices[num5 + 6] + vector3 * (healthBars[n].CurrentValue * 2f);
					ref Vector3 reference24 = ref m_vertices[num5 + 5];
					reference24 = m_vertices[num5 + 7] + vector3 * (healthBars[n].CurrentValue * 2f);
					ref UnityEngine.Color reference25 = ref m_colors[num5 + 4];
					ref UnityEngine.Color reference26 = ref m_colors[num5 + 5];
					ref UnityEngine.Color reference27 = ref m_colors[num5 + 6];
					ref UnityEngine.Color reference28 = ref m_colors[num5 + 7];
					reference25 = (reference26 = (reference27 = (reference28 = simpleHealthBar.CurrentColor)));
					m_activeCounts[num]++;
					num5 += m_vertexCounts[num];
				}
				else
				{
					m_removeHealthBars.Add(simpleHealthBar);
				}
			}
		}
		int count2 = m_removeBullets.Count;
		if (count2 != 0)
		{
			for (int num6 = 0; num6 < count2; num6++)
			{
				bullets.Remove(m_removeBullets[num6]);
			}
			m_removeBullets.Clear();
		}
		count2 = m_removeRadarPointer.Count;
		if (count2 != 0)
		{
			for (int num7 = 0; num7 < count2; num7++)
			{
				radarPointers.Remove(m_removeRadarPointer[num7]);
			}
			m_removeRadarPointer.Clear();
		}
		count2 = m_removeHealthBars.Count;
		if (count2 != 0)
		{
			for (int num8 = 0; num8 < count2; num8++)
			{
				healthBars.Remove(m_removeHealthBars[num8]);
			}
			m_removeHealthBars.Clear();
		}
	}

	private void CleanupMeshes()
	{
		int num = 0;
		for (int i = 0; i < 3; i++)
		{
			int num2 = num + m_counts[i] * m_vertexCounts[i];
			for (int j = num + m_activeCounts[i] * m_vertexCounts[i]; j < num2; j++)
			{
				ref Vector3 reference = ref m_vertices[j];
				reference = Vector3.zero;
			}
			m_counts[i] = m_activeCounts[i];
			num += m_vertexCounts[i] * m_maxObjects[i];
		}
	}
}
public class OneTimeParticleSystem : MonoBehaviour
{
	private ParticleSystem[] MyParticleSystem;

	[SerializeField]
	private EffectType m_effectType;

	private void Start()
	{
		ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>();
		MyParticleSystem = new ParticleSystem[componentsInChildren.Length];
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			MyParticleSystem[i] = componentsInChildren[i];
		}
	}

	private void Update()
	{
		if (MyParticleSystem == null || MyParticleSystem.Length == 0)
		{
			return;
		}
		bool flag = true;
		for (int i = 0; i < MyParticleSystem.Length; i++)
		{
			if (MyParticleSystem[i].isPlaying)
			{
				flag = false;
				break;
			}
			MyParticleSystem[i].Clear();
		}
		if (flag)
		{
			if (m_effectType == EffectType.None)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			else
			{
				Singleton<EffectsPool>.Instance.ReturnToPool(MyParticleSystem[0], m_effectType);
			}
		}
	}
}
public class OneTimeSprite : MonoBehaviour
{
	private Animator MyAnimator;

	public bool DoRoll;

	private float roll;

	private void Start()
	{
		MyAnimator = GetComponent<Animator>();
		if (DoRoll)
		{
			roll = UnityEngine.Random.Range(0, 360);
		}
	}

	private void Update()
	{
		if (MyAnimator == null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		Vector3 position = Singleton<CameraManager>.Instance.transform.position;
		base.transform.rotation = Quaternion.FromToRotation(Vector3.forward, position - base.transform.position);
		if (DoRoll)
		{
			base.transform.rotation *= Quaternion.Euler(new Vector3(0f, 0f, roll));
		}
		if (MyAnimator.GetCurrentAnimatorStateInfo(0).normalizedTime >= 1f)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class ShaderAlphaFadeOut : MonoBehaviour
{
	private float m_alpha = 1f;

	public float m_fadeSpeed = 1f;

	public string m_shaderAlphaProperty = string.Empty;

	private void Update()
	{
		if (Mathf.Approximately(0f, m_alpha))
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		if (m_shaderAlphaProperty.Length > 0)
		{
			GetComponent<Renderer>().material.SetFloat(m_shaderAlphaProperty, m_alpha);
			m_alpha = Mathf.Max(0f, m_alpha - Time.deltaTime * m_fadeSpeed);
		}
	}
}
public class ComingIntoLand : MonoBehaviour
{
	public enum LandingState
	{
		ComingInToLand,
		Landing,
		Taxiing,
		Stopped
	}

	[SerializeField]
	private Transform startPos;

	[SerializeField]
	private Transform descentPos;

	[SerializeField]
	private Transform landingPos;

	[SerializeField]
	private Transform endPos;

	[SerializeField]
	private float inAirSpeed = 60f;

	[SerializeField]
	private float speedOnLand = 40f;

	[SerializeField]
	private float onGroundSpeed = 20f;

	[SerializeField]
	private float onGroundDeceleration = 10f;

	[SerializeField]
	private LandingState startingState;

	private LandingState state;

	[SerializeField]
	private float verticalSpeed = 10f;

	private float horizontalSpeed;

	private float airToLandDistance;

	[NonSerialized]
	[HideInInspector]
	public new Transform transform;

	private Quaternion onGroundRotation;

	[SerializeField]
	private float rotationSpeed = 6f;

	private Transform mesh;

	[SerializeField]
	private float bounceHeight = 1f;

	[SerializeField]
	private float bounceTime = 0.5f;

	[SerializeField]
	private float bounceStart = 0.5f;

	private float absoluteBounceHeight;

	[SerializeField]
	private ParticleSystem[] dustParticles = new ParticleSystem[0];

	private bool showingParticles;

	private float bounceTimer;

	public LandingState State => state;

	private void Start()
	{
		transform = GetComponent<Transform>();
		horizontalSpeed = inAirSpeed;
		state = startingState;
		if (state == LandingState.Landing)
		{
			Singleton<AudioManager>.Instance.Play(AudioEvent.EvtEndSeq_Lanc_Landing, base.gameObject);
		}
		airToLandDistance = descentPos.position.y - landingPos.position.y;
		onGroundRotation = landingPos.rotation;
		transform.position = startPos.position;
		mesh = transform.GetChild(0);
		absoluteBounceHeight = landingPos.position.y + bounceHeight;
		bounceTimer = bounceStart;
	}

	public void Reset()
	{
		horizontalSpeed = inAirSpeed;
		mesh.localRotation = Quaternion.identity;
		state = LandingState.ComingInToLand;
		bounceTimer = bounceStart;
		showingParticles = false;
	}

	private void Update()
	{
		switch (state)
		{
		case LandingState.ComingInToLand:
			transform.position += transform.forward * Time.deltaTime * horizontalSpeed;
			if (Vector3.SqrMagnitude(transform.position - descentPos.position) <= 10f)
			{
				state = LandingState.Landing;
				Singleton<AudioManager>.Instance.Play(AudioEvent.EvtEndSeq_Lanc_Landing, base.gameObject);
			}
			break;
		case LandingState.Landing:
		{
			float num = transform.position.y - landingPos.position.y;
			float num2 = 1f - num / airToLandDistance;
			horizontalSpeed = Mathf.Lerp(inAirSpeed, speedOnLand, num2);
			Vector3 vector = transform.forward * Time.deltaTime * horizontalSpeed;
			vector -= transform.up * Time.deltaTime * verticalSpeed;
			transform.position += vector;
			if (!showingParticles && num2 >= 0.99f)
			{
				for (int i = 0; i < dustParticles.Length; i++)
				{
					dustParticles[i].Play();
				}
				showingParticles = true;
			}
			if (horizontalSpeed <= speedOnLand)
			{
				state = LandingState.Taxiing;
				horizontalSpeed = speedOnLand;
				Singleton<AudioManager>.Instance.Play(AudioEvent.EvtEndSeq_RifleFire, Singleton<LandingController>.Instance.gunShotOnLandPosition);
				Singleton<AudioManager>.Instance.Play(AudioEvent.EvtEndSeq_CrowdCheer, Singleton<LandingController>.Instance.crowdCheeringPosition);
				mesh.rotation = Quaternion.Lerp(mesh.rotation, onGroundRotation, 0.1f);
			}
			break;
		}
		case LandingState.Taxiing:
			if (bounceTimer < 1f)
			{
				Bounce();
			}
			if (bounceTimer >= 0.25f && Quaternion.Dot(transform.rotation, onGroundRotation) < 1f - Mathf.Epsilon)
			{
				mesh.rotation = Quaternion.Lerp(mesh.rotation, onGroundRotation, Time.deltaTime * rotationSpeed);
			}
			if (horizontalSpeed > onGroundSpeed)
			{
				horizontalSpeed -= onGroundDeceleration * Time.deltaTime;
			}
			transform.position += transform.forward * Time.deltaTime * horizontalSpeed;
			if (Vector3.SqrMagnitude(transform.position - endPos.position) <= 100f)
			{
				state = LandingState.Stopped;
				horizontalSpeed = 0f;
			}
			break;
		case LandingState.Stopped:
			Singleton<LandingController>.Instance.AddToPool(this);
			break;
		}
	}

	private float Bounce(float x)
	{
		return Mathf.Abs(Mathf.Sin(3.14f * (x + 1f) * (x + 1f)) * (1f - x));
	}

	private void Bounce()
	{
		transform.SetYPosition(Mathf.Lerp(landingPos.transform.position.y, absoluteBounceHeight, Bounce(bounceTimer)));
		bounceTimer += Time.deltaTime / bounceTime;
	}
}
public class CreditInfo
{
	public string devName;

	public string devPosition;

	public static readonly CreditInfo Empty = new CreditInfo();
}
public class CreditsLabel : MonoBehaviour
{
	private UILabel nameLabel;

	private UILabel positionLabel;

	private void Awake()
	{
		nameLabel = GetComponent<UILabel>();
		positionLabel = base.transform.GetChild(0).GetComponent<UILabel>();
	}

	public void SetInfo(CreditInfo info)
	{
		nameLabel.text = info.devName;
		positionLabel.text = info.devPosition;
	}
}
public class CreditsUIScreen : MonoBehaviour
{
	[SerializeField]
	private NamesList namesList;

	[SerializeField]
	private UISprite bomberPicture;

	[SerializeField]
	private UILabel labelCurrency;

	[SerializeField]
	private UILabel labelStarsMax;

	[SerializeField]
	private UILabel labelStarsTotal;

	private const string creditSpriteName = "eol_credit_pic_";

	[SerializeField]
	private float timeBetweenScreens = 5f;

	private float timer;

	private int currentPage;

	private int currentBackground;

	private List<CreditInfo[]> pages;

	private void Awake()
	{
		InitPages();
	}

	private void Start()
	{
		currentPage = 0;
		namesList.SetPage(pages[currentPage]);
		currentBackground = 0;
		if (Singleton<Profile>.TryInstance())
		{
			StartCoroutine(ShowEndingPopup((!Singleton<Profile>.Instance.Progress.HasMaxStars()) ? "endgame_normal" : "endgame_allstars"));
			labelCurrency.text = ProcessNumber(Singleton<Profile>.Instance.Player.GetMoney());
			labelStarsMax.text = (Singleton<MissionManager>.Instance.AvailableMissions.Length * 3).ToString();
			labelStarsTotal.text = Singleton<Profile>.Instance.Progress.GetStarsAmount() + "/";
			Singleton<MenuManager>.Instance.ShowCrosshair(show: true);
			if (Singleton<Profile>.Instance.Progress.HasMaxStars())
			{
				Singleton<Profile>.Instance.Progress.ShownEndingAllStars = true;
			}
			else
			{
				Singleton<Profile>.Instance.Progress.ShownEnding = true;
			}
			Singleton<Profile>.Instance.Save();
		}
	}

	public static string ProcessNumber(int n)
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append(n);
		for (int num = stringBuilder.Length - 3; num > 0; num -= 3)
		{
			stringBuilder.Insert(num, ",");
		}
		return stringBuilder.ToString();
	}

	public void BackToMenu()
	{
		Singleton<AudioManager>.Instance.PlayOneShot(AudioEvent.EvtGUI_IN_NME_Wave_Start);
		Singleton<LoadingScreen>.Instance.LoadMenu(LoadingScreen.ComingFrom.Game);
	}

	private void Update()
	{
		timer += Time.deltaTime;
		if (timer >= timeBetweenScreens)
		{
			currentPage = (currentPage + 1) % pages.Count;
			namesList.SetPage(pages[currentPage]);
			currentBackground = (currentBackground + 1) % 4;
			bomberPicture.spriteName = "eol_credit_pic_" + (currentBackground + 1);
			timer = 0f;
		}
		if (Singleton<GameManager>.Instance.Button1State == GameManager.InputButtonState.ShortPress)
		{
			BackToMenu();
		}
	}

	private IEnumerator ShowEndingPopup(string textId)
	{
		while (Singleton<LoadingScreen>.TryInstance())
		{
			yield return null;
		}
		Singleton<TutorialManager>.Instance.ShowPopup(textId, 740);
		Time.timeScale = 1f;
	}

	private void InitPages()
	{
		pages = new List<CreditInfo[]>();
		string xmlAssetPath = "Credits/Credits";
		XmlTextReader xmlTextReader = XmlHelper.GetXmlTextReader(xmlAssetPath);
		xmlTextReader.WhitespaceHandling = WhitespaceHandling.None;
		List<CreditInfo> list = null;
		while (xmlTextReader.Read())
		{
			if (xmlTextReader.NodeType != XmlNodeType.Element)
			{
				continue;
			}
			if (xmlTextReader.Name == "page")
			{
				if (list != null)
				{
					pages.Add(list.ToArray());
				}
				list = new List<CreditInfo>();
			}
			else if (xmlTextReader.Name == "dev")
			{
				string attribute = xmlTextReader.GetAttribute("name");
				string attribute2 = xmlTextReader.GetAttribute("position");
				CreditInfo creditInfo = new CreditInfo();
				creditInfo.devName = attribute;
				creditInfo.devPosition = attribute2;
				list.Add(creditInfo);
			}
		}
		if (list != null)
		{
			pages.Add(list.ToArray());
		}
		xmlTextReader.Close();
	}
}
public class Flyover : MonoBehaviour
{
	[SerializeField]
	private float flyingSpeed = 300f;

	[SerializeField]
	private Transform rotationWaypoint;

	[SerializeField]
	private float yawSpeed = 0.05f;

	[SerializeField]
	private float rollSpeed = 0.01f;

	private Quaternion desiredYawRotation;

	private Quaternion desiredRollRotation;

	[SerializeField]
	protected Transform planeParent;

	private Vector3 initialPosition;

	private Quaternion initialYawRotation;

	private Quaternion initialRollRotation;

	[SerializeField]
	private float timeAlive = 15f;

	private float timer;

	[NonSerialized]
	[HideInInspector]
	public new Transform transform;

	[SerializeField]
	private float heightDeviation = 10f;

	[SerializeField]
	private AudioEvent flyoverAudioEvent = AudioEvent.EvtEndSeq_Lanc_Flyby;

	[SerializeField]
	private bool randomiseHeights = true;

	[SerializeField]
	private GameObject playAudioFrom;

	protected virtual void Awake()
	{
		transform = GetComponent<Transform>();
		initialPosition = transform.position;
		initialYawRotation = transform.rotation;
		initialRollRotation = planeParent.rotation;
		desiredYawRotation = initialYawRotation;
		desiredRollRotation = initialRollRotation;
		if (randomiseHeights)
		{
			for (int i = 0; i < planeParent.childCount; i++)
			{
				planeParent.GetChild(i).AddYPosition(UnityEngine.Random.Range(0f, heightDeviation));
			}
		}
	}

	public virtual void Reset()
	{
		transform.position = initialPosition;
		transform.rotation = initialYawRotation;
		planeParent.rotation = initialRollRotation;
		desiredYawRotation = initialYawRotation;
		desiredRollRotation = initialRollRotation;
		if (randomiseHeights)
		{
			for (int i = 0; i < planeParent.childCount; i++)
			{
				planeParent.GetChild(i).AddYPosition(UnityEngine.Random.Range(0f, heightDeviation));
			}
		}
		timer = 0f;
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.transform == rotationWaypoint)
		{
			Vector3 eulerAngles = other.transform.eulerAngles;
			Vector3 eulerAngles2 = transform.rotation.eulerAngles;
			desiredYawRotation = Quaternion.Euler(eulerAngles.x, eulerAngles.y, eulerAngles2.z);
			desiredRollRotation = Quaternion.Euler(eulerAngles2.x, eulerAngles2.y, eulerAngles.z);
		}
	}

	public void Activate()
	{
		base.gameObject.SetActive(value: true);
		Reset();
		Singleton<AudioManager>.Instance.Play(flyoverAudioEvent, playAudioFrom);
	}

	private void Update()
	{
		timer += Time.deltaTime;
		if (timer >= timeAlive)
		{
			base.gameObject.SetActive(value: false);
			return;
		}
		transform.position += transform.forward * Time.deltaTime * flyingSpeed;
		if (Quaternion.Dot(transform.rotation, desiredYawRotation) < 1f - Mathf.Epsilon)
		{
			transform.rotation = Quaternion.Slerp(transform.rotation, desiredYawRotation, Time.deltaTime * yawSpeed);
			desiredRollRotation = Quaternion.Euler(transform.rotation.eulerAngles.x, transform.rotation.eulerAngles.y, desiredRollRotation.eulerAngles.z);
		}
		if (Quaternion.Dot(planeParent.rotation, desiredRollRotation) < 1f - Mathf.Epsilon)
		{
			planeParent.rotation = Quaternion.Slerp(planeParent.rotation, desiredRollRotation, Time.deltaTime * rollSpeed);
		}
	}
}
public class FlyoverAllStars : Singleton<FlyoverAllStars>
{
	private FlyoverPlaneController[] controllers;

	public GameObject[] planePrefabs;

	private List<FlyoverPlaneController> activeControllers = new List<FlyoverPlaneController>();

	private List<FlyoverPlaneController> inactiveControllers = new List<FlyoverPlaneController>();

	[SerializeField]
	private float timeBetweenActivations = 5f;

	private float activationTimer;

	protected override void Awake()
	{
		base.Awake();
		controllers = base.transform.GetComponentsInChildren<FlyoverPlaneController>(includeInactive: true);
		for (int i = 0; i < controllers.Length; i++)
		{
			inactiveControllers.Add(controllers[i]);
		}
		activationTimer = timeBetweenActivations * 2f;
	}

	private void Update()
	{
		if (!Singleton<LoadingScreen>.TryInstance())
		{
			activationTimer += Time.deltaTime;
			if (activationTimer >= timeBetweenActivations && inactiveControllers.Count > 0)
			{
				ActivateController(inactiveControllers[UnityEngine.Random.Range(0, inactiveControllers.Count)]);
				activationTimer = 0f;
			}
		}
	}

	private void ActivateController(FlyoverPlaneController controller)
	{
		activeControllers.Add(controller);
		inactiveControllers.Remove(controller);
		controller.Reset(planePrefabs[UnityEngine.Random.Range(0, planePrefabs.Length)]);
	}

	public void OnControllerDeactivate(FlyoverPlaneController controller)
	{
		activeControllers.Remove(controller);
		inactiveControllers.Add(controller);
	}
}
public class FlyoverController : MonoBehaviour
{
	private enum FlyoverType
	{
		Behind,
		Sides
	}

	[SerializeField]
	private Flyover[] fromBehind;

	[SerializeField]
	private Flyover[] fromSides;

	[SerializeField]
	private float fromBehindMinActivationTime = 10f;

	[SerializeField]
	private float fromBehindMaxActivationTime = 15f;

	[SerializeField]
	private float fromSidesMinActivationTime = 10f;

	[SerializeField]
	private float fromSidesMaxActivationTime = 15f;

	private FlyoverType lastActive;

	private float timer;

	private float nextActivationTime;

	private void Start()
	{
		lastActive = FlyoverType.Behind;
		for (int i = 0; i < fromBehind.Length; i++)
		{
			fromBehind[i].Activate();
		}
		nextActivationTime = UnityEngine.Random.Range(fromSidesMinActivationTime, fromSidesMaxActivationTime);
	}

	private void Update()
	{
		timer += Time.deltaTime;
		if (!(timer >= nextActivationTime))
		{
			return;
		}
		if (lastActive == FlyoverType.Behind)
		{
			fromSides[UnityEngine.Random.Range(0, fromSides.Length)].Activate();
			lastActive = FlyoverType.Sides;
			nextActivationTime = UnityEngine.Random.Range(fromBehindMinActivationTime, fromBehindMaxActivationTime);
		}
		else if (lastActive == FlyoverType.Sides)
		{
			for (int i = 0; i < fromBehind.Length; i++)
			{
				fromBehind[i].Activate();
			}
			lastActive = FlyoverType.Behind;
			nextActivationTime = UnityEngine.Random.Range(fromSidesMinActivationTime, fromSidesMaxActivationTime);
		}
		timer = 0f;
	}
}
public class FlyoverPlane : MonoBehaviour
{
	public float flyingSpeed = 100f;

	public Transform[] waypoints = new Transform[0];

	private int nextWaypointIndex;

	public float yawSpeed = 0.2f;

	public float rollSpeed = 0.1f;

	private Quaternion desiredYawRotation;

	private Quaternion desiredRollRotation;

	private Vector3 initialPosition;

	private Quaternion initialYawRotation;

	private Quaternion initialRollRotation;

	[NonSerialized]
	[HideInInspector]
	public new Transform transform;

	public bool turnBasedOnZ = true;

	private bool initialised;

	protected void Awake()
	{
		if (!initialised)
		{
			Initialise();
		}
	}

	private void Initialise()
	{
		transform = GetComponent<Transform>();
		initialPosition = transform.position;
		initialYawRotation = transform.rotation;
		initialRollRotation = transform.rotation;
		desiredYawRotation = initialYawRotation;
		desiredRollRotation = initialRollRotation;
		initialised = true;
	}

	public void Reset()
	{
		if (!initialised)
		{
			Initialise();
		}
		transform.position = initialPosition;
		transform.rotation = initialYawRotation;
		desiredYawRotation = initialYawRotation;
		desiredRollRotation = initialRollRotation;
		nextWaypointIndex = ((waypoints.Length <= 0) ? (-1) : 0);
	}

	private void Update()
	{
		transform.position += transform.forward * Time.deltaTime * flyingSpeed;
		CheckForTurn();
		if (Quaternion.Dot(transform.rotation, desiredYawRotation) < 1f - Mathf.Epsilon)
		{
			transform.rotation = Quaternion.Slerp(transform.rotation, desiredYawRotation, Time.deltaTime * yawSpeed);
			desiredRollRotation = Quaternion.Euler(transform.rotation.eulerAngles.x, transform.rotation.eulerAngles.y, desiredRollRotation.eulerAngles.z);
		}
		if (Quaternion.Dot(transform.rotation, desiredRollRotation) < 1f - Mathf.Epsilon)
		{
			transform.rotation = Quaternion.Slerp(transform.rotation, desiredRollRotation, Time.deltaTime * rollSpeed);
		}
	}

	private void CheckForTurn()
	{
		if (nextWaypointIndex != -1 && waypoints[nextWaypointIndex].InverseTransformPoint(transform.position).y <= 0f)
		{
			StartTurn();
		}
	}

	private void StartTurn()
	{
		Vector3 eulerAngles = waypoints[nextWaypointIndex].eulerAngles;
		Vector3 eulerAngles2 = transform.rotation.eulerAngles;
		desiredYawRotation = Quaternion.Euler(eulerAngles.x, eulerAngles.y, eulerAngles2.z);
		desiredRollRotation = Quaternion.Euler(eulerAngles2.x, eulerAngles2.y, eulerAngles.z);
		nextWaypointIndex++;
		if (nextWaypointIndex >= waypoints.Length)
		{
			nextWaypointIndex = -1;
		}
	}
}
public enum FlyoverFormation
{
	None = -1,
	V,
	EchelonLeft,
	EchelonRight,
	Count
}
public class FlyoverPlaneController : MonoBehaviour
{
	[SerializeField]
	private float flyingSpeed = 100f;

	[SerializeField]
	private Transform[] rotationWaypoints;

	[SerializeField]
	private float yawSpeed = 0.2f;

	[SerializeField]
	private float rollSpeed = 0.1f;

	[SerializeField]
	private FlyoverFormation formation;

	[SerializeField]
	private float xDistanceBetweenPlanes = 8f;

	[SerializeField]
	private float zDistanceBetweenPlanes = 10f;

	[SerializeField]
	private GameObject planePrefab;

	[SerializeField]
	private int numberOfPlanes = 9;

	[SerializeField]
	private float heightDeviation = 10f;

	[SerializeField]
	private bool randomiseHeights = true;

	private Transform planeParent;

	[SerializeField]
	private float timeAlive = 15f;

	private float aliveTimer;

	[SerializeField]
	private bool turnBasedOnZ = true;

	[SerializeField]
	private AudioEvent propellerAudioEvent = AudioEvent.EvtEndSeq_Lanc_Flyby;

	[SerializeField]
	private AudioEvent jetAudioEvent = AudioEvent.EvtEndSeq_Lanc_Flyby;

	private bool usingJetPlanes;

	private GameObject audioPlane;

	private Transform PlaneParent
	{
		get
		{
			if (planeParent == null)
			{
				return base.transform;
			}
			return planeParent;
		}
	}

	private void Setup()
	{
		switch (formation)
		{
		case FlyoverFormation.V:
			SetupVFormation();
			break;
		case FlyoverFormation.EchelonLeft:
			SetupEchelon(left: true);
			break;
		case FlyoverFormation.EchelonRight:
			SetupEchelon(left: false);
			break;
		}
		if (randomiseHeights)
		{
			RandomiseHeights();
		}
	}

	public void Reset(GameObject plane)
	{
		Transform transform = PlaneParent;
		int childCount = transform.childCount;
		for (int i = 0; i < childCount; i++)
		{
			UnityEngine.Object.Destroy(transform.GetChild(i).gameObject);
		}
		planePrefab = plane;
		usingJetPlanes = plane.GetComponent<IsPlaneJet>().isJet;
		base.gameObject.SetActive(value: true);
		formation = (FlyoverFormation)UnityEngine.Random.Range(0, 3);
		aliveTimer = 0f;
		Setup();
	}

	private void SetupVFormation()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(planePrefab);
		gameObject.transform.parent = base.transform;
		gameObject.transform.localPosition = Vector3.zero;
		gameObject.transform.localRotation = Quaternion.identity;
		FlyoverPlane flyoverPlane = gameObject.AddComponent<FlyoverPlane>();
		flyoverPlane.flyingSpeed = flyingSpeed;
		flyoverPlane.yawSpeed = yawSpeed;
		flyoverPlane.rollSpeed = rollSpeed;
		flyoverPlane.waypoints = rotationWaypoints;
		flyoverPlane.turnBasedOnZ = turnBasedOnZ;
		flyoverPlane.Reset();
		if (usingJetPlanes)
		{
			Singleton<AudioManager>.Instance.Play(jetAudioEvent, gameObject);
		}
		else
		{
			Singleton<AudioManager>.Instance.Play(propellerAudioEvent, gameObject);
		}
		audioPlane = gameObject;
		float num = 0f - xDistanceBetweenPlanes;
		float num2 = 0f - zDistanceBetweenPlanes;
		for (int i = 1; i < numberOfPlanes; i++)
		{
			gameObject = UnityEngine.Object.Instantiate(planePrefab);
			gameObject.transform.parent = base.transform;
			gameObject.transform.localPosition = new Vector3(num, 0f, num2);
			gameObject.transform.localRotation = Quaternion.identity;
			flyoverPlane = gameObject.AddComponent<FlyoverPlane>();
			flyoverPlane.flyingSpeed = flyingSpeed;
			flyoverPlane.yawSpeed = yawSpeed;
			flyoverPlane.rollSpeed = rollSpeed;
			flyoverPlane.waypoints = rotationWaypoints;
			flyoverPlane.turnBasedOnZ = turnBasedOnZ;
			flyoverPlane.Reset();
			if (i % 2 == 0)
			{
				num -= Math.Abs(num) * 2f;
				num -= Math.Abs(xDistanceBetweenPlanes);
				num2 -= zDistanceBetweenPlanes;
			}
			else
			{
				num += Math.Abs(num) * 2f;
			}
		}
	}

	private void RandomiseHeights()
	{
		Transform transform = PlaneParent;
		for (int i = 0; i < transform.childCount; i++)
		{
			transform.GetChild(i).AddLocalYPosition(UnityEngine.Random.Range(0f, heightDeviation));
		}
	}

	private void Update()
	{
		aliveTimer += Time.deltaTime;
		if (aliveTimer >= timeAlive)
		{
			Singleton<FlyoverAllStars>.Instance.OnControllerDeactivate(this);
			if (usingJetPlanes)
			{
				Singleton<AudioManager>.Instance.Stop(jetAudioEvent, audioPlane);
			}
			else
			{
				Singleton<AudioManager>.Instance.Stop(propellerAudioEvent, audioPlane);
			}
			base.gameObject.SetActive(value: false);
		}
	}

	private void ReadjustParentPositions(int firstChildIndex)
	{
		Transform transform = PlaneParent;
		Bounds bounds = default(Bounds);
		bounds.center = transform.GetChild(0).position;
		Renderer componentInChildren = transform.GetChild(0).GetComponentInChildren<Renderer>();
		bounds.Encapsulate(componentInChildren.bounds);
		componentInChildren = transform.GetChild(transform.childCount - 1).GetComponentInChildren<Renderer>();
		bounds.Encapsulate(componentInChildren.bounds);
		componentInChildren = transform.GetChild(transform.childCount - 2).GetComponentInChildren<Renderer>();
		bounds.Encapsulate(componentInChildren.bounds);
		Transform[] array = new Transform[transform.childCount];
		for (int i = 0; i < transform.childCount; i++)
		{
			array[i] = transform.GetChild(i);
		}
		transform.DetachChildren();
		transform.position = bounds.center;
		Transform[] array2 = array;
		foreach (Transform transform2 in array2)
		{
			transform2.parent = transform;
		}
		transform.localPosition = Vector3.zero;
	}

	private void SetupEchelon(bool left)
	{
		if (planeParent == null)
		{
			planeParent = new GameObject("Centre Point").transform;
			planeParent.transform.parent = base.transform;
			planeParent.transform.localPosition = Vector3.zero;
			planeParent.transform.localRotation = Quaternion.identity;
		}
		float num = 0f;
		float num2 = 0f;
		int num3 = numberOfPlanes / 2;
		for (int i = 0; i < numberOfPlanes; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(planePrefab);
			gameObject.transform.parent = planeParent;
			gameObject.transform.localPosition = new Vector3(num, 0f, num2);
			gameObject.transform.localRotation = Quaternion.identity;
			FlyoverPlane flyoverPlane = gameObject.AddComponent<FlyoverPlane>();
			flyoverPlane.flyingSpeed = flyingSpeed;
			flyoverPlane.yawSpeed = yawSpeed;
			flyoverPlane.rollSpeed = rollSpeed;
			flyoverPlane.waypoints = rotationWaypoints;
			flyoverPlane.turnBasedOnZ = turnBasedOnZ;
			flyoverPlane.Reset();
			if (num3 == i)
			{
				if (usingJetPlanes)
				{
					Singleton<AudioManager>.Instance.Play(jetAudioEvent, gameObject);
				}
				else
				{
					Singleton<AudioManager>.Instance.Play(propellerAudioEvent, gameObject);
				}
				audioPlane = gameObject;
			}
			num = ((!left) ? (num + xDistanceBetweenPlanes) : (num - xDistanceBetweenPlanes));
			num2 -= zDistanceBetweenPlanes;
		}
		ReadjustParentPositions(1);
	}
}
public class IsPlaneJet : MonoBehaviour
{
	public bool isJet;
}
public class LandingController : Singleton<LandingController>
{
	public Transform planeSpawnTransform;

	public GameObject gunShotOnLandPosition;

	public GameObject crowdCheeringPosition;

	[SerializeField]
	private ComingIntoLand lastPlane;

	private ComingIntoLand.LandingState previousState;

	private Stack<ComingIntoLand> planePool = new Stack<ComingIntoLand>();

	[SerializeField]
	private float minSpawnDistance = 500f;

	private float minSpawnDistanceSqr;

	private void Start()
	{
		minSpawnDistanceSqr = minSpawnDistance * minSpawnDistance;
	}

	private void Update()
	{
		if (!(Vector3.Dot(planeSpawnTransform.position - lastPlane.transform.position, lastPlane.transform.forward) > 0f) && Vector3.SqrMagnitude(planeSpawnTransform.position - lastPlane.transform.position) >= minSpawnDistanceSqr)
		{
			if (planePool.Count == 0)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(lastPlane.gameObject, planeSpawnTransform.position, planeSpawnTransform.rotation);
				gameObject.transform.parent = base.transform;
				lastPlane = gameObject.GetComponent<ComingIntoLand>();
			}
			else
			{
				lastPlane = planePool.Pop();
				lastPlane.gameObject.SetActive(value: true);
				lastPlane.transform.position = planeSpawnTransform.position;
				lastPlane.Reset();
			}
		}
	}

	public void AddToPool(ComingIntoLand plane)
	{
		planePool.Push(plane);
		plane.gameObject.SetActive(value: false);
	}
}
public class LoadEndingSkybox : Singleton<LoadEndingSkybox>
{
	[SerializeField]
	private GameObject skyboxPrefab;

	protected override void Awake()
	{
		base.Awake();
		if (!Singleton<Profile>.TryInstance())
		{
			SetupEndingSkybox();
		}
	}

	public void SetupEndingSkybox()
	{
		UnityEngine.Object.Instantiate(skyboxPrefab, Vector3.zero, Quaternion.identity);
	}
}
public class NamesList : MonoBehaviour
{
	private CreditsLabel[] creditsLabels;

	private void Awake()
	{
		creditsLabels = GetComponentsInChildren<CreditsLabel>();
	}

	public void SetPage(CreditInfo[] infoList)
	{
		for (int i = 0; i < Mathf.Min(creditsLabels.Length, infoList.Length); i++)
		{
			creditsLabels[i].SetInfo(infoList[i]);
		}
		for (int j = infoList.Length; j < creditsLabels.Length; j++)
		{
			creditsLabels[j].SetInfo(CreditInfo.Empty);
		}
	}
}
public class BonusRocketBehaviour : EnemyBehavior
{
	private enum Stage
	{
		Launch,
		Seek,
		Fly
	}

	[SerializeField]
	private Vector3 m_spawnCentreGroundRelative = new Vector3(0f, -100f, 0f);

	[SerializeField]
	private Vector2 m_spawnAreaExtent = new Vector2(500f, 200f);

	[SerializeField]
	private float m_moveSpeed = 200f;

	[SerializeField]
	private float m_turnSpeed = 40f;

	[SerializeField]
	private float m_destroyZ = 500f;

	[SerializeField]
	private ParticleSystem m_LaunchEffect;

	[SerializeField]
	private GameObject m_trailPosition;

	[SerializeField]
	private GameObject m_trailPrefab;

	private GameObject m_trailObject;

	[SerializeField]
	private string m_trailShaderAlphaProperty;

	[SerializeField]
	private float m_trailFadeoutSpeed = 1f;

	[SerializeField]
	private AudioEvent m_onHitAudioEvent;

	[SerializeField]
	private AudioEvent m_launchAudioEvent;

	private float m_turnHeight;

	private Stage m_stage;

	private bool m_trailDetached;

	[SerializeField]
	private Transform missileMesh;

	[SerializeField]
	private float spinSpeed = 180f;

	private Vector3 m_turnTarget = Vector3.zero;

	public override void OnBackFromPool()
	{
		base.OnBackFromPool();
		if (GetComponent<MoveWithGroundSlider>() == null)
		{
			gameObject.AddComponent<MoveWithGroundSlider>();
		}
		m_stage = Stage.Launch;
		m_trailDetached = false;
		Status.StartedFire = true;
		Vector2 vector = new Vector2(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f));
		desiredPosition = m_spawnCentreGroundRelative + new Vector3(vector.x * m_spawnAreaExtent.x, 0f, vector.y * m_spawnAreaExtent.y);
		transform.position = desiredPosition;
		m_turnHeight = UnityEngine.Random.Range(-200f, 50f);
		if (m_turnHeight < -163f && m_turnHeight > -180f)
		{
			m_turnHeight += 30f * Mathf.Sign(UnityEngine.Random.Range(-1, 1));
		}
		m_turnTarget = new Vector3(transform.position.x, m_turnHeight, transform.position.z + 1000f);
		for (int i = 0; i < transform.childCount; i++)
		{
			transform.GetChild(i).gameObject.SetActive(value: true);
		}
		Singleton<AudioManager>.Instance.Play(Status._engineAudioEvent, gameObject);
		if (m_LaunchEffect != null)
		{
			Vector3 position = desiredPosition;
			position -= desiredPosition.normalized * 200f;
			position.y -= 40f;
			ParticleSystem particleSystem = UnityEngine.Object.Instantiate(m_LaunchEffect, position, Quaternion.LookRotation(-transform.position));
			if (particleSystem.gameObject.GetComponent<OneTimeParticleSystem>() == null)
			{
				particleSystem.gameObject.AddComponent<OneTimeParticleSystem>();
			}
			if (particleSystem.gameObject.GetComponent<MoveWithGroundSlider>() == null)
			{
				particleSystem.gameObject.AddComponent<MoveWithGroundSlider>();
			}
			if (gameObject.GetComponent<MoveWithGroundSlider>() == null)
			{
				gameObject.AddComponent<MoveWithGroundSlider>();
			}
			Singleton<AudioManager>.Instance.Play(m_launchAudioEvent, gameObject);
		}
		if ((bool)m_trailObject)
		{
			m_trailObject.transform.parent = null;
			UnityEngine.Object.Destroy(m_trailObject);
			m_trailObject = null;
		}
		if ((bool)m_trailPrefab)
		{
			m_trailObject = UnityEngine.Object.Instantiate(m_trailPrefab);
			if ((bool)m_trailPosition)
			{
				m_trailObject.transform.parent = m_trailPosition.transform;
			}
			else
			{
				m_trailObject.transform.parent = transform.parent;
			}
			m_trailObject.transform.localPosition = Vector3.zero;
		}
		transform.rotation = Quaternion.LookRotation(m_turnTarget - transform.position);
		desiredRotation = transform.rotation;
	}

	public override void Tick()
	{
		base.Tick();
		if ((bool)m_trailObject)
		{
			Vector3 vector = Singleton<CameraManager>.Instance.transform.position - desiredPosition;
			float y = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
			m_trailObject.transform.localRotation = Quaternion.Euler(new Vector3(0f, y, 0f));
		}
	}

	private void LateUpdate()
	{
		if (m_currentState == BehaviorType.Falling)
		{
			if (Singleton<GameManager>.Instance.State == GameManager.GameState.InGame && UnityEngine.Random.Range(0f, 1f) < 0.2f)
			{
				Singleton<AudioManager>.Instance.Play(m_onHitAudioEvent);
			}
			DestroyMe();
		}
	}

	private void DestroyMe(bool detachTrail = false)
	{
		if (detachTrail)
		{
			DetachTrail();
		}
		Status.OnDestroy();
		Singleton<AudioManager>.Instance.Stop(Status._engineAudioEvent, gameObject);
		Singleton<EnemiesPool>.Instance.ReturnToPool(this, Status.Spawner.m_enemyPreset);
		Status.Spawner.OnKill(Status, killedByPlayer: false);
	}

	private void DetachTrail()
	{
		if (!m_trailDetached && (bool)m_trailObject && m_trailShaderAlphaProperty.Length > 0)
		{
			m_trailDetached = true;
			m_trailObject.transform.parent = null;
			ShaderAlphaFadeOut shaderAlphaFadeOut = m_trailObject.AddComponent<ShaderAlphaFadeOut>();
			shaderAlphaFadeOut.m_shaderAlphaProperty = m_trailShaderAlphaProperty;
			shaderAlphaFadeOut.m_fadeSpeed = m_trailFadeoutSpeed;
			m_trailObject.AddComponent<MoveWithGroundSlider>();
			m_trailObject = null;
		}
	}

	protected override void BehaviorUpdate(float deltaTime)
	{
		switch (m_stage)
		{
		case Stage.Launch:
			m_targetRotation = Quaternion.LookRotation(m_turnTarget - transform.position);
			if (desiredPosition.y > m_turnHeight)
			{
				DetachTrail();
				m_stage = Stage.Seek;
			}
			break;
		case Stage.Seek:
			m_targetRotation = Quaternion.LookRotation(Vector3.forward);
			if (transform.position.z >= -10f)
			{
				m_stage = Stage.Fly;
				Singleton<AudioManager>.Instance.Play(Status._engineAudioPassbyDownEvent, gameObject);
			}
			break;
		case Stage.Fly:
			if (desiredPosition.z > m_destroyZ)
			{
				DestroyMe(detachTrail: true);
			}
			break;
		}
		if (Quaternion.Dot(desiredRotation, m_targetRotation) < 1f - Mathf.Epsilon)
		{
			desiredRotation = Quaternion.Lerp(desiredRotation, m_targetRotation, deltaTime * m_turnSpeed);
		}
		desiredPosition += desiredRotation * Vector3.forward * deltaTime * m_moveSpeed;
		missileMesh.Rotate(Vector3.forward * spinSpeed * deltaTime);
		float num;
		for (num = desiredRotation.eulerAngles.x; num < -180f; num += 360f)
		{
		}
		while (num > 180f)
		{
			num -= 360f;
		}
		num /= 180f;
		num += 0.5f;
	}
}
public class CargoBehavior : EnemyBehavior
{
	[SerializeField]
	private float m_spawnRadius;

	private float m_despawnDistance;

	[SerializeField]
	private float m_powerUpSpawnDelay;

	[SerializeField]
	private float m_powerUpSpawnFrequency = 5f;

	private int counter;

	private float m_powerUpTimer;

	public override void OnBackFromPool()
	{
		Status.StartedFire = true;
		m_despawnDistance = m_spawnRadius * m_spawnRadius * 1.5f;
		float num = 0f;
		if (Singleton<MissionManager>.Instance.TimeLimit == TimeLimit.Checkpoint)
		{
			num = UnityEngine.Random.Range(-10f, 10f);
			Vector3 vector = Quaternion.AngleAxis(num, Vector3.up) * Vector3.forward;
			Vector3 vector2 = vector * 50f;
			vector2.y += UnityEngine.Random.Range(30f, 60f);
			desiredPosition = vector2;
			num = UnityEngine.Random.Range(-15f, 15f);
			vector = Quaternion.AngleAxis(num, Vector3.up) * -vector2;
			vector.y = 0f;
			desiredPosition = vector2;
			desiredRotation = Quaternion.LookRotation(vector);
			MeshCollider[] componentsInChildren = transform.GetComponentsInChildren<MeshCollider>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].enabled = false;
			}
			m_powerUpTimer = 0f - m_powerUpSpawnDelay;
		}
		else
		{
			float num2 = 1f;
			if (Singleton<EnemyBehaviorManager>.Instance.CargoSpawn == null)
			{
				num2 = Mathf.Sign(UnityEngine.Random.Range(-1f, 1f));
			}
			num = UnityEngine.Random.Range(65f, 115f) * num2;
			Vector3 vector3 = Quaternion.AngleAxis(num, Vector3.up) * Vector3.right;
			Vector3 vector4 = vector3 * m_spawnRadius;
			vector4.y += UnityEngine.Random.Range(30f, 60f) * Mathf.Sign(UnityEngine.Random.Range(-1f, 1f));
			num = UnityEngine.Random.Range(5f, 15f) * Mathf.Sign(UnityEngine.Random.Range(-1f, 1f));
			vector3 = Quaternion.AngleAxis(num, Vector3.up) * -vector4;
			vector3.y = 0f;
			desiredPosition = vector4;
			desiredRotation = Quaternion.LookRotation(vector3);
		}
		transform.position = desiredPosition;
		transform.rotation = desiredRotation;
		m_currentState = BehaviorType.Idle;
		m_isDying = false;
		UpdateAudio();
	}

	protected override void BehaviorUpdate(float deltaTime)
	{
		desiredPosition += transform.forward * deltaTime * m_speed_mod;
		if (m_currentState == BehaviorType.Falling)
		{
			desiredRotation = Quaternion.Lerp(desiredRotation, m_targetRotation, deltaTime * m_fallingSpeed);
		}
		UpdateAudio();
		if (Singleton<MissionManager>.Instance.TimeLimit == TimeLimit.Checkpoint && Singleton<GameManager>.Instance.State == GameManager.GameState.InGame)
		{
			m_powerUpTimer += deltaTime;
			if (m_powerUpTimer > m_powerUpSpawnFrequency)
			{
				Singleton<PowerUpManager>.Instance.CreatePowerUp(desiredPosition, desiredRotation);
				m_powerUpTimer = 0f;
			}
		}
		if (++counter > 100 && m_currentState == BehaviorType.Idle)
		{
			counter = 0;
			if (Vector3.SqrMagnitude(desiredPosition - playerTransform.position) > m_despawnDistance)
			{
				Status.Spawner.OnKill(Status, killedByPlayer: false);
			}
		}
	}
}
public class EnemyAvoidanceCollision : MonoBehaviour
{
	private EnemyBehavior enemyBehaviour;

	private void Awake()
	{
		enemyBehaviour = GetComponentInParent<EnemyBehavior>();
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!enemyBehaviour)
		{
			UnityEngine.Debug.Log("Avoiding collision without enemy attached");
		}
		else
		{
			enemyBehaviour.ProcessUpcomingCollision(other.transform.parent.gameObject);
		}
	}
}
public enum BehaviorType
{
	Attacking,
	StartsAttacking,
	Circling,
	PullingOut,
	MakingDistance,
	Falling,
	Idle
}
public class EnemyBehavior : MonoBehaviour
{
	protected BehaviorType m_currentState;

	[SerializeField]
	protected float m_speed;

	protected float m_speed_mod;

	[SerializeField]
	protected float m_maxTurnSpeed;

	[SerializeField]
	protected float m_maxPullingOutTurnSpeed;

	[SerializeField]
	protected float m_turnSmoothing;

	[SerializeField]
	protected float m_fallingSpeed;

	[SerializeField]
	protected float m_attackDistance;

	protected float m_attackDistanceSquared;

	[SerializeField]
	protected float m_minCirclingRadius;

	[SerializeField]
	protected float m_maxCirclingRadius;

	[SerializeField]
	public bool m_oneAttack;

	protected float m_circlingRadius;

	protected float m_circlingRadiusSquared;

	private float m_fallingDirection;

	protected bool m_furtherThanRadius;

	protected Gun m_guns;

	protected bool m_isShooting;

	[NonSerialized]
	[HideInInspector]
	public EnemyStatus Status;

	[NonSerialized]
	[HideInInspector]
	public new Transform transform;

	[NonSerialized]
	[HideInInspector]
	public Rigidbody rigidbody;

	[NonSerialized]
	[HideInInspector]
	public new GameObject gameObject;

	protected bool m_isDying;

	protected Vector3 m_pitchYawRoll;

	protected float m_rotationVelocity;

	protected float m_rotationSpeed;

	protected Quaternion m_rotation;

	protected Quaternion m_targetRotation;

	protected Transform m_target;

	protected FriendlyPlane m_targetPlane;

	protected GameObject m_pullingAwayFrom;

	protected float m_currentStateTime;

	protected bool m_behaviorUpdated;

	protected bool m_freezeHeight;

	protected int m_numberInFormation;

	protected Quaternion desiredRotation;

	protected Vector3 desiredPosition;

	protected Transform playerTransform;

	private const int m_smoothRollCount = 7;

	private float[] m_smoothRoll = new float[7];

	private float m_smoothRollAvg;

	private int m_smoothRollIdx;

	private bool m_smoothInitialized;

	[SerializeField]
	private bool m_updateRollInBaseUpdate = true;

	[SerializeField]
	protected bool onlyAttackFriends;

	public bool IsOnAttackRun => m_currentState == BehaviorType.Attacking || m_currentState == BehaviorType.StartsAttacking;

	public bool IsPullingOut => m_currentState == BehaviorType.PullingOut;

	protected virtual void Awake()
	{
		m_guns = GetComponentInChildren<Gun>();
		Status = GetComponent<EnemyStatus>();
		transform = GetComponent<Transform>();
		rigidbody = GetComponentInChildren<Rigidbody>();
		gameObject = base.gameObject;
		desiredPosition = transform.position;
		desiredRotation = transform.rotation;
		m_attackDistanceSquared = m_attackDistance * m_attackDistance;
		playerTransform = Singleton<GameManager>.Instance.Player.transform;
		m_speed_mod = m_speed * 0.75f;
	}

	public void SetNumberInFormation(int n)
	{
		m_numberInFormation = n;
	}

	public virtual void Tick()
	{
		float num = Time.deltaTime;
		if (m_currentState != BehaviorType.Falling)
		{
			num *= Singleton<GameManager>.Instance.EnemyTimeScale;
		}
		BehaviorUpdate(num);
	}

	protected virtual void BehaviorUpdate(float deltaTime)
	{
		float num = Quaternion.Angle(m_targetRotation, desiredRotation);
		bool targetAchieved = num < 3f;
		float num2 = Mathf.Clamp(num / 10f, 0f, 1f);
		m_rotationSpeed = Mathf.SmoothDamp(target: (m_currentState != BehaviorType.PullingOut) ? (num2 * m_maxTurnSpeed) : (num2 * m_maxPullingOutTurnSpeed), current: m_rotationSpeed, currentVelocity: ref m_rotationVelocity, smoothTime: m_turnSmoothing);
		if (!m_behaviorUpdated)
		{
			switch (m_currentState)
			{
			case BehaviorType.StartsAttacking:
				UpdateStartAttacking(deltaTime, targetAchieved);
				break;
			case BehaviorType.Attacking:
				UpdateAttacking();
				break;
			case BehaviorType.PullingOut:
				UpdatePullingOut(targetAchieved);
				break;
			case BehaviorType.MakingDistance:
				UpdateMakingDistance();
				break;
			case BehaviorType.Circling:
				UpdateCircling(num);
				break;
			case BehaviorType.Falling:
				m_rotationSpeed = m_fallingSpeed;
				transform.Rotate(0f, (0f - m_fallingDirection) / 2f * deltaTime, m_fallingDirection * deltaTime);
				break;
			}
		}
		m_behaviorUpdated = false;
		if (Quaternion.Dot(desiredRotation, m_targetRotation) < 1f - Mathf.Epsilon)
		{
			desiredRotation = Quaternion.Lerp(desiredRotation, m_targetRotation, deltaTime * m_rotationSpeed);
			if (m_updateRollInBaseUpdate)
			{
				UpdateRoll(deltaTime);
			}
			UpdateAudio();
		}
		desiredPosition += transform.forward * deltaTime * m_speed;
	}

	protected void UpdateAudio()
	{
		if (gameObject.activeSelf)
		{
			float num = desiredRotation.eulerAngles.x;
			if (num < -180f)
			{
				num += 360f;
			}
			else if (num > 180f)
			{
				num -= 360f;
			}
			num /= 180f;
			num += 0.5f;
			Singleton<AudioManager>.Instance.SetParameter(Status._engineAudioEvent, ParameterType.Angle, num, gameObject, canBePaused: true);
		}
	}

	protected void UpdateRoll(float deltaTime)
	{
		m_pitchYawRoll = desiredRotation.eulerAngles;
		float num = ((!(m_pitchYawRoll.z > 180f)) ? m_pitchYawRoll.z : (m_pitchYawRoll.z - 360f));
		if (!m_smoothInitialized)
		{
			m_smoothInitialized = true;
			m_smoothRollIdx = 0;
			m_smoothRollAvg = num;
			for (int i = 0; i < 7; i++)
			{
				m_smoothRoll[i] = num;
			}
		}
		else
		{
			m_smoothRollAvg += (num - m_smoothRoll[m_smoothRollIdx]) / 7f;
			m_smoothRoll[m_smoothRollIdx] = num;
			m_smoothRollIdx++;
			if (m_smoothRollIdx >= 7)
			{
				m_smoothRollIdx = 0;
			}
		}
		m_pitchYawRoll.z = m_smoothRollAvg;
		if (m_freezeHeight)
		{
			m_pitchYawRoll.x = 0f;
		}
		desiredRotation = Quaternion.Euler(m_pitchYawRoll);
	}

	private void UpdateCircling(float angleToTarget)
	{
		if (angleToTarget < 20f)
		{
			if (m_oneAttack)
			{
				float num = Vector3.Dot(playerTransform.forward, desiredPosition.normalized);
				if (num > 0.9f)
				{
					Status.Spawner.OnKill(Status, killedByPlayer: false);
				}
			}
			else if (CanAttack())
			{
				StartAttack();
			}
		}
		if (m_currentState == BehaviorType.Circling)
		{
			Vector3 vector = desiredPosition;
			Vector3 forward = transform.forward;
			vector.y = (forward.y = 0f);
			Vector3 rhs = Vector3.Cross(-vector, forward);
			m_targetRotation = Quaternion.LookRotation(-Vector3.Cross(-vector, rhs));
		}
	}

	private void UpdateMakingDistance()
	{
		float num = Vector3.SqrMagnitude(desiredPosition);
		if (num > m_circlingRadiusSquared)
		{
			m_currentState = BehaviorType.Circling;
			desiredRotation *= Quaternion.AngleAxis(0f - Mathf.Sign(Vector3.Dot(playerTransform.right, transform.forward)), Vector3.up);
			m_targetRotation = desiredRotation;
			m_rotationSpeed = 0f;
			m_rotationVelocity = 0f;
		}
	}

	private void UpdatePullingOut(bool targetAchieved)
	{
		if (m_isShooting)
		{
			if (m_target == null || !CanShoot())
			{
				SetShooting(start: false);
			}
			else if ((bool)m_guns)
			{
				m_guns.Shoot();
			}
		}
		if (targetAchieved)
		{
			if (m_isShooting)
			{
				SetShooting(start: false);
			}
			m_target = null;
			m_pullingAwayFrom = null;
			if (m_isDying)
			{
				StartFalling();
			}
			else
			{
				StartMakingDistance(justSpawned: false);
			}
		}
	}

	private void UpdateAttacking()
	{
		if (m_target == null)
		{
			StartMakingDistance(justSpawned: false);
			return;
		}
		if (onlyAttackFriends && m_targetPlane != null && m_targetPlane.GetHealthPercentage() <= 0f)
		{
			StartMakingDistance(justSpawned: false);
			return;
		}
		bool flag = CanShoot();
		if (!m_isShooting && flag)
		{
			SetShooting(start: true);
		}
		else if (m_isShooting)
		{
			if (!flag)
			{
				SetShooting(start: false);
			}
			else if ((bool)m_guns)
			{
				m_guns.Shoot();
			}
		}
		float num = Vector3.Dot(transform.forward, m_target.position - desiredPosition);
		if (num < 0f)
		{
			StartMakingDistance(justSpawned: false);
		}
	}

	private void UpdateStartAttacking(float deltaTime, bool targetAchieved)
	{
		m_currentStateTime += deltaTime;
		if (m_target == null || m_currentStateTime > 5f)
		{
			StartMakingDistance(justSpawned: false);
			return;
		}
		m_targetRotation = Quaternion.LookRotation(m_target.position - desiredPosition);
		if (targetAchieved)
		{
			m_currentState = BehaviorType.Attacking;
			m_rotationSpeed = 0f;
			m_rotationVelocity = 0f;
		}
		bool flag = CanShoot();
		if (!m_isShooting && flag)
		{
			SetShooting(start: true);
		}
		else if (m_isShooting)
		{
			if (!flag)
			{
				SetShooting(start: false);
			}
			else if ((bool)m_guns)
			{
				m_guns.Shoot();
			}
		}
	}

	protected void PerformPullOut(GameObject AvoidThis, bool goUnderneath = false)
	{
		m_pullingAwayFrom = AvoidThis;
		if (IsOnAttackRun && !onlyAttackFriends)
		{
			Singleton<EnemyBehaviorManager>.Instance.OnStopAttack();
		}
		m_currentState = BehaviorType.PullingOut;
		float num = 0f;
		if (!goUnderneath)
		{
			num = GetPullingAwayAngle();
		}
		Vector3 vector = Quaternion.AngleAxis(45f, transform.right) * transform.forward;
		vector = Quaternion.AngleAxis(num, transform.forward) * vector;
		m_targetRotation.SetLookRotation(vector);
		if (num < 45f || num > 315f)
		{
			Singleton<AudioManager>.Instance.Play(Status._engineAudioPassbyDownEvent, gameObject);
		}
		else if (num > 135f && num < 225f)
		{
			Singleton<AudioManager>.Instance.Play(Status._engineAudioPassbyUpEvent, gameObject);
		}
		else
		{
			Singleton<AudioManager>.Instance.Play(Status._engineAudioPassbyLeftRightEvent, gameObject);
		}
	}

	public void ProcessUpcomingCollision(GameObject hit)
	{
		if (hit == m_pullingAwayFrom)
		{
			return;
		}
		bool flag = true;
		EnemyBehavior component = hit.GetComponent<EnemyBehavior>();
		if ((bool)component)
		{
			flag = component.IsOnAttackRun;
			if (!flag && !component.IsPullingOut)
			{
				component.PerformPullOut(gameObject);
			}
		}
		if (flag && !IsOnAttackRun)
		{
			PerformPullOut(hit);
		}
	}

	protected virtual bool CanAttack()
	{
		if (Singleton<EnemyBehaviorManager>.Instance.IsAttackAllowed || onlyAttackFriends)
		{
			Vector2 currentAttackSector = Singleton<EnemyBehaviorManager>.Instance.GetCurrentAttackSector();
			Vector2 vector = new Vector2(desiredPosition.x, 0f - desiredPosition.z);
			float num = (0f - Mathf.Atan2(vector.x, vector.y)) * 57.29578f;
			float num2 = 15f * Mathf.Sign(0f - transform.forward.x);
			if (num < currentAttackSector.y - num2 && num > currentAttackSector.x - num2)
			{
				return true;
			}
		}
		return false;
	}

	protected virtual void StartAttack()
	{
		m_currentState = BehaviorType.StartsAttacking;
		if (!onlyAttackFriends)
		{
			Singleton<EnemyBehaviorManager>.Instance.OnStartAttack();
		}
		ChooseTarget();
		m_targetRotation = Quaternion.LookRotation(m_target.position - desiredPosition);
		m_currentStateTime = 0f;
	}

	protected void ChooseTarget()
	{
		if (onlyAttackFriends)
		{
			List<FriendlyPlane> friends = Singleton<MissionManager>.Instance.Friends;
			if (friends.Count != 0)
			{
				m_targetPlane = friends[UnityEngine.Random.Range(0, friends.Count)];
				while (m_targetPlane.GetHealthPercentage() <= 0f)
				{
					m_targetPlane = friends[UnityEngine.Random.Range(0, friends.Count)];
				}
				m_target = m_targetPlane.transform;
			}
			else
			{
				m_target = playerTransform;
			}
		}
		else
		{
			m_target = playerTransform;
		}
	}

	protected virtual void StartMakingDistance(bool justSpawned)
	{
		if (IsOnAttackRun && !onlyAttackFriends)
		{
			Singleton<EnemyBehaviorManager>.Instance.OnStopAttack();
		}
		m_currentState = BehaviorType.MakingDistance;
		if (m_isShooting)
		{
			SetShooting(start: false);
		}
		if (Vector3.SqrMagnitude(desiredPosition - playerTransform.position) > m_circlingRadiusSquared)
		{
			if (justSpawned)
			{
				float num = 0f - Mathf.Sign(Vector3.Cross(playerTransform.forward, playerTransform.position - desiredPosition).y);
				Vector3 vector = playerTransform.position + playerTransform.right * num * m_circlingRadius;
				vector.y = desiredPosition.y;
				m_targetRotation = Quaternion.LookRotation(vector - desiredPosition);
				desiredRotation = m_targetRotation;
			}
			else
			{
				Vector3 position = playerTransform.position;
				position.y = desiredPosition.y;
				m_targetRotation = Quaternion.LookRotation(position - desiredPosition);
			}
		}
		else
		{
			m_targetRotation = desiredRotation;
			m_targetRotation.x = (m_targetRotation.z = 0f);
		}
	}

	protected virtual bool CanShoot()
	{
		Vector3 position = m_target.position;
		float num = Vector3.SqrMagnitude(position - desiredPosition);
		if (m_currentState == BehaviorType.Attacking && num < 3500f)
		{
			PerformPullOut(m_target.gameObject);
		}
		if (num <= m_attackDistanceSquared)
		{
			float f = Vector3.Dot(transform.forward, (m_target.position - desiredPosition).normalized);
			f = Mathf.Acos(f) * 57.29578f;
			if (f < 10f || float.IsNaN(f))
			{
				return true;
			}
		}
		return false;
	}

	protected virtual void SetShooting(bool start)
	{
		if ((bool)m_guns)
		{
			if (start)
			{
				m_guns.StartShooting();
				Status.StartedFire = true;
			}
			else
			{
				m_guns.EndShooting();
			}
			m_isShooting = start;
		}
	}

	public virtual void OnKill(bool killedByPlayer = true)
	{
		m_isDying = true;
		if (IsOnAttackRun && !onlyAttackFriends)
		{
			Singleton<EnemyBehaviorManager>.Instance.OnStopAttack();
		}
		SetShooting(start: false);
		if (m_currentState != BehaviorType.PullingOut)
		{
			StartFalling();
		}
	}

	private void StartFalling()
	{
		m_currentState = BehaviorType.Falling;
		float num = desiredRotation.eulerAngles.z;
		if (num == 0f)
		{
			num = UnityEngine.Random.Range(-1f, 1f);
		}
		m_fallingDirection = UnityEngine.Random.Range(30f, 80f) * Mathf.Sign(num);
		m_targetRotation = Quaternion.LookRotation(-Vector3.up);
	}

	public virtual void Disintegrate()
	{
		m_oneAttack = true;
	}

	public virtual void OnBackFromPool()
	{
		m_circlingRadius = UnityEngine.Random.Range(m_minCirclingRadius, m_maxCirclingRadius);
		m_circlingRadiusSquared = m_circlingRadius * m_circlingRadius;
		m_isDying = false;
		m_isShooting = false;
		m_rotationSpeed = 0f;
		m_rotationVelocity = 0f;
		m_currentStateTime = 0f;
		m_oneAttack = false;
		desiredPosition = transform.position;
		desiredRotation = transform.rotation;
		m_smoothInitialized = false;
		if (m_numberInFormation > 0 && Status.Spawner.AttackPattern == AttackPattern.Split)
		{
			float num = ((m_numberInFormation % 2 != 1) ? (-1f) : 1f);
			desiredPosition += Vector3.Cross(transform.forward, Vector3.up) * Singleton<EnemyBehaviorManager>.Instance.SplitAttack.m_distance * num;
			desiredRotation = Quaternion.LookRotation(-desiredPosition);
		}
		if (Singleton<EnemyBehaviorManager>.Instance.IsAttackAllowed || m_oneAttack || m_numberInFormation > 0)
		{
			StartAttack();
		}
		else
		{
			StartMakingDistance(justSpawned: true);
		}
		UpdateAudio();
	}

	protected float GetPullingAwayAngle()
	{
		return Status.Spawner.AttackPattern switch
		{
			AttackPattern.Staggered => (float)(m_numberInFormation % 2) * 180f, 
			AttackPattern.Split => m_numberInFormation switch
			{
				1 => 200f, 
				2 => 160f, 
				3 => 270f, 
				_ => 90f, 
			}, 
			_ => UnityEngine.Random.Range(0f, 360f), 
		};
	}

	public void FixedTick()
	{
		rigidbody.MovePosition(desiredPosition);
		rigidbody.MoveRotation(desiredRotation);
	}
}
[Serializable]
public class StaggeredAttackPattern
{
	public float m_timeDelay = 1f;

	public int m_planesAmount = 3;
}
[Serializable]
public class SplitAttackPattern
{
	public float m_timeDelay = 1f;

	public float m_distance = 20f;
}
public class EnemyBehaviorManager : Singleton<EnemyBehaviorManager>
{
	public delegate void EnemyDelegate();

	private List<EnemySpawner> m_enemySpawners = new List<EnemySpawner>();

	private int m_enemySpawnersCount;

	private int m_activeEnemies;

	private int m_maxPlanesAtATime;

	private bool m_isSpawnAllowed = true;

	private float m_currentTime;

	private int m_maxAttackingPlanes;

	private int m_attackingPlanesCount;

	private Vector2 m_attackSector;

	public EnemyDelegate EnemySpawn;

	public EnemyDelegate CargoSpawn;

	[SerializeField]
	private StaggeredAttackPattern m_staggeredAttackPattern = new StaggeredAttackPattern();

	[SerializeField]
	private SplitAttackPattern m_splitAttackPattern = new SplitAttackPattern();

	public bool IsSpawnAllowed => m_isSpawnAllowed;

	public bool IsAttackAllowed => m_attackingPlanesCount < m_maxAttackingPlanes;

	public StaggeredAttackPattern StaggeredAttack => m_staggeredAttackPattern;

	public SplitAttackPattern SplitAttack => m_splitAttackPattern;

	public float NumOfAttackingPlanes => m_attackingPlanesCount;

	public bool MissionHasWasserfalls { get; private set; }

	private void Start()
	{
		Singleton<GameManager>.Instance.OnStartMission += RestartMission;
		Singleton<GameManager>.Instance.OnEndMission += EndMission;
		m_attackSector = new Vector2(-45f, 45f);
		ChangeAttackSector();
	}

	public override void OnDestroy()
	{
		if (Singleton<GameManager>.Instance != null)
		{
			Singleton<GameManager>.Instance.OnStartMission -= RestartMission;
			Singleton<GameManager>.Instance.OnEndMission -= EndMission;
		}
		base.OnDestroy();
	}

	public void SetupEnemySpawers(List<EnemySpawner> enemySpawners, int maxPlanesAtATime)
	{
		m_enemySpawners = enemySpawners;
		m_maxPlanesAtATime = maxPlanesAtATime;
		Singleton<EnemiesPool>.Instance.InitEnemies(enemySpawners, maxPlanesAtATime);
		m_activeEnemies = 0;
		m_attackingPlanesCount = 0;
		m_isSpawnAllowed = true;
		m_enemySpawnersCount = m_enemySpawners.Count;
		MissionHasWasserfalls = false;
		if (Singleton<MissionManager>.Instance.Mission == 0)
		{
			m_enemySpawners[1].SetSpecialTutorialFlag();
			return;
		}
		for (int i = 0; i < m_enemySpawnersCount; i++)
		{
			if (enemySpawners[i].SpawnsWasserfalls)
			{
				MissionHasWasserfalls = true;
				break;
			}
		}
	}

	public void SetMaxAttackingCount(int count)
	{
		if (count > 0)
		{
			m_maxAttackingPlanes = count;
		}
	}

	public void LoopRestart(int loopWaveStartIndex)
	{
		for (int i = loopWaveStartIndex; i < m_enemySpawnersCount; i++)
		{
			m_enemySpawners[i].Restart();
		}
	}

	private void Update()
	{
		if (!Singleton<LoadingScreen>.TryInstance())
		{
			for (int i = 0; i < m_enemySpawnersCount; i++)
			{
				m_enemySpawners[i].Tick();
			}
		}
		if (Singleton<GameManager>.Instance.State != GameManager.GameState.InGame)
		{
			return;
		}
		if (!m_isSpawnAllowed && m_activeEnemies < m_maxPlanesAtATime && m_currentTime < 10f)
		{
			m_isSpawnAllowed = true;
		}
		m_currentTime += Time.deltaTime;
		if (m_currentTime > 10f && m_isSpawnAllowed && m_attackingPlanesCount > 0)
		{
			m_isSpawnAllowed = false;
			ChangeAttackSector();
		}
		if (m_currentTime > 12f)
		{
			m_currentTime = 0f;
			if (!m_isSpawnAllowed && m_activeEnemies < m_maxPlanesAtATime)
			{
				m_isSpawnAllowed = true;
			}
		}
	}

	private void ChangeAttackSector()
	{
		float num = 15f;
		int num2 = 0;
		float num3 = -45f;
		while (num3 < m_attackSector.x)
		{
			num3 += num;
			num2++;
		}
		int num4;
		for (num4 = num2; num4 == num2; num4 = UnityEngine.Random.Range(0, (int)(90f / num)))
		{
		}
		m_attackSector.x = -45f + (float)num4 * num;
		m_attackSector.y = m_attackSector.x + num;
	}

	public void OnEnemyDestroy()
	{
		m_activeEnemies--;
	}

	public void OnStartAttack()
	{
		m_attackingPlanesCount++;
	}

	public void OnStopAttack()
	{
		m_attackingPlanesCount--;
	}

	public void OnEnemyKill()
	{
		for (int i = 1; i < m_enemySpawnersCount; i++)
		{
			if (!m_enemySpawners[i].IsActive && m_enemySpawners[i].ActivateOnKill)
			{
				int[] array = new int[i];
				for (int j = 0; j < i; j++)
				{
					array[j] = m_enemySpawners[j].KilledCount;
				}
				m_enemySpawners[i].TryActivate(array);
			}
		}
	}

	private void EndMission(GameManager.EndMissionReason reason)
	{
		switch (reason)
		{
		case GameManager.EndMissionReason.Victory:
		{
			for (int i = 0; i < m_enemySpawnersCount; i++)
			{
				m_enemySpawners[i].DeactivateSpawner();
			}
			break;
		}
		case GameManager.EndMissionReason.Lost:
			DisintegrateWaves(null);
			break;
		}
	}

	private void RestartMission(bool restart)
	{
		if (restart)
		{
			for (int i = 0; i < m_enemySpawnersCount; i++)
			{
				m_enemySpawners[i].Restart();
			}
			m_activeEnemies = 0;
			m_attackingPlanesCount = 0;
			m_isSpawnAllowed = true;
		}
	}

	public void OnSpawn(PlaneType type)
	{
		if (++m_activeEnemies >= m_maxPlanesAtATime)
		{
			m_isSpawnAllowed = false;
		}
		if (EnemySpawn != null)
		{
			EnemySpawn();
		}
		if (type == PlaneType.Cargo && CargoSpawn != null)
		{
			CargoSpawn();
		}
	}

	public Vector2 GetCurrentAttackSector()
	{
		return m_attackSector;
	}

	public void DisintegrateSpecificWaves(int[] spawners)
	{
		if (m_enemySpawnersCount == 0)
		{
			return;
		}
		for (int i = 0; i < spawners.Length; i++)
		{
			if (m_enemySpawners.Count > spawners[i])
			{
				m_enemySpawners[spawners[i]].DisintegrateWave();
			}
		}
	}

	public void DisintegrateWaves(EnemySpawner spawner)
	{
		for (int i = 0; i < m_enemySpawnersCount && !(spawner == m_enemySpawners[i]); i++)
		{
			m_enemySpawners[i].DisintegrateWave();
		}
	}

	private void FixedUpdate()
	{
		if (!Singleton<LoadingScreen>.TryInstance())
		{
			for (int i = 0; i < m_enemySpawnersCount; i++)
			{
				m_enemySpawners[i].FixedTick();
			}
		}
	}
}
public class EnemyPrefabDictionary : Singleton<EnemyPrefabDictionary>
{
	private Dictionary<PlaneType, GameObject> prefabMapping = new Dictionary<PlaneType, GameObject>();

	[SerializeField]
	private PlaneType[] planeTypes = new PlaneType[23];

	[SerializeField]
	private GameObject[] planePrefabs = new GameObject[23];

	protected override void Awake()
	{
		base.Awake();
		for (int i = 0; i < planeTypes.Length; i++)
		{
			prefabMapping.Add(planeTypes[i], planePrefabs[i]);
		}
	}

	public GameObject GetPrefabOfPlane(PlaneType planeType)
	{
		if (planeType == PlaneType.Any)
		{
			return prefabMapping[PlaneType.Cargo];
		}
		return prefabMapping[planeType];
	}
}
public enum ActivationType
{
	ActivateOnStart,
	ActivateWithTimeDelay,
	ActivateOnKill,
	ActivateAfterTutorial,
	ActivateOnKillOrTimeDelay
}
public enum AttackPattern
{
	None,
	Staggered,
	Split
}
[Serializable]
public struct SpawnerConfig
{
	[HideInInspector]
	public string m_planeName;

	public SpawnerSettings m_spawner;

	public ActivationType m_activateType;

	public float m_activationDelay;

	public int tutorialIndex;

	[Space(5f)]
	public int m_planesToKillFromPreviosWaves;

	public int[] m_previosWaves;

	[Space(5f)]
	public bool firstPlaneSpawnsImmediately;

	public float m_minDelay;

	public float m_maxDelay;

	public int m_planesToSpawn;

	public bool m_countTowardsVictory;

	[MultilineHeader("Tick Disintegrate Other Waves to disintegrate ALL previous waves\n(leave unticked if not).\nFill Disintegrate Specific Waves array to disintegrate only those waves\n(leaving the tickbox unchecked).", 0f, 1f, 0f)]
	public bool m_disintegrateOtherWaves;

	public int[] m_disintegrateSpecificWaves;

	[Space(5f)]
	public int m_maxAttackingPlanes;

	public int m_maxPlanes;

	[Space(5f)]
	public AudioEvent m_waveStartWarningAudioEvent;

	public AttackPattern m_attackPattern;

	[Space(5f)]
	public bool loopAfterCurrentWave;

	public int loopWaveStartIndex;

	public int loopAfterNumEnemiesKilled;

	public float loopAfterTimeElapsed;

	[Tooltip("This tickbox is ONLY for the looping wave")]
	public bool disintegrateThisWaveOnLoop;
}
public class EnemySpawner : ScriptableObject
{
	private class ActiveEnemy
	{
		public EnemyStatus m_status;

		public EnemyBehavior m_behavior;

		public Gun[] m_guns;
	}

	private List<ActiveEnemy> m_activeEnemies = new List<ActiveEnemy>(20);

	private List<ActiveEnemy> m_enemiesToRemove = new List<ActiveEnemy>(20);

	private List<EnemyStatus> m_currentEnemies = new List<EnemyStatus>(20);

	private SpawnerConfig m_config;

	private int m_spawnedCount;

	private int m_killedCount;

	public GameObject m_enemyPreset;

	public float MaxHealth;

	public float m_damage;

	public float m_fireRate;

	public int m_pointsValue = 100;

	public bool m_canSpawnPowerUps;

	private ActivationType m_activationType;

	private bool m_stopSpawn;

	private float m_timeTillNextSpawn;

	private float m_timeSinceLastSpawn;

	private int m_planesInFormation;

	private Vector3 m_newPosition;

	private Vector3 m_newDirection;

	private Vector3 m_savedPosition;

	private bool m_oneAttack;

	private EnemyBehavior m_enemyPresetBehavior;

	private bool hasSpawned;

	private float loopTimer;

	private bool isSpecialTutorialWave;

	public int KilledCount => m_killedCount;

	public ActivationType ActivationType => m_config.m_activateType;

	public AttackPattern AttackPattern => m_config.m_attackPattern;

	public int AmountOfEnemiesToKill => m_config.m_planesToSpawn - m_spawnedCount + m_currentEnemies.Count;

	public bool SpawnsWasserfalls => m_config.m_spawner.m_planeType == PlaneType.Wasserfall;

	public bool IsActive { get; private set; }

	public float Damage => m_damage;

	public bool CountTowardsVictory => m_config.m_countTowardsVictory;

	public SpawnerConfig Config => m_config;

	public bool CanCheckForLoop => (IsActive && m_config.m_planesToSpawn == 0) || hasSpawned;

	public bool ActivateOnKill => ActivationType == ActivationType.ActivateOnKill || ActivationType == ActivationType.ActivateOnKillOrTimeDelay;

	public bool CanSpawnPowerUps => m_canSpawnPowerUps;

	public void SetSpecialTutorialFlag()
	{
		isSpecialTutorialWave = true;
	}

	public void ActivateSpawner()
	{
		IsActive = true;
		Singleton<EnemyBehaviorManager>.Instance.SetMaxAttackingCount(m_config.m_maxAttackingPlanes);
		if (m_config.m_disintegrateOtherWaves)
		{
			Singleton<EnemyBehaviorManager>.Instance.DisintegrateWaves(this);
		}
		else if (m_config.m_disintegrateSpecificWaves.Length > 0)
		{
			Singleton<EnemyBehaviorManager>.Instance.DisintegrateSpecificWaves(m_config.m_disintegrateSpecificWaves);
		}
		if (ActivationType == ActivationType.ActivateWithTimeDelay)
		{
			return;
		}
		if (m_config.m_activationDelay <= 0f)
		{
			if (m_config.firstPlaneSpawnsImmediately)
			{
				m_timeTillNextSpawn = 0f;
			}
			else
			{
				m_timeTillNextSpawn = UnityEngine.Random.Range(m_config.m_minDelay, m_config.m_maxDelay);
			}
		}
		else
		{
			m_timeTillNextSpawn = m_config.m_activationDelay;
		}
	}

	public void DeactivateSpawner()
	{
		IsActive = false;
		for (int i = 0; i < m_currentEnemies.Count; i++)
		{
			m_currentEnemies[i].Hurt(10000f, hitByPlayer: false);
		}
		m_currentEnemies.Clear();
	}

	public void Initialise(SpawnerConfig config)
	{
		m_config = config;
		m_activationType = config.m_activateType;
		hasSpawned = false;
		SpawnerSettings spawner = config.m_spawner;
		m_enemyPreset = Singleton<EnemyPrefabDictionary>.Instance.GetPrefabOfPlane(spawner.m_planeType);
		MaxHealth = spawner.m_maxHealth;
		m_damage = spawner.m_bulletDamage;
		m_fireRate = spawner.m_fireRate;
		m_pointsValue = spawner.m_pointsValue;
		m_canSpawnPowerUps = spawner.m_canSpawnPowerUps;
		m_enemyPresetBehavior = m_enemyPreset.GetComponent<EnemyBehavior>();
		m_oneAttack = m_enemyPresetBehavior.m_oneAttack;
		Restart();
	}

	public void Tick()
	{
		UpdateSpawnedEnemies();
		if (CanCheckForLoop && m_config.loopAfterCurrentWave)
		{
			UpdateLoopChecks();
		}
		if (!IsActive && TryToActivate())
		{
			ActivateSpawner();
		}
		if (IsActive && Singleton<GameManager>.Instance.State == GameManager.GameState.InGame)
		{
			if (!m_stopSpawn && (m_config.m_planesToSpawn < 0 || m_spawnedCount < m_config.m_planesToSpawn))
			{
				TryToSpawn();
			}
			if (m_config.m_planesToSpawn != 0 && m_spawnedCount == m_config.m_planesToSpawn && m_currentEnemies.Count == 0)
			{
				MakeInactive();
			}
		}
	}

	private void UpdateSpawnedEnemies()
	{
		for (int i = 0; i < m_activeEnemies.Count; i++)
		{
			m_activeEnemies[i].m_status.Tick();
			m_activeEnemies[i].m_behavior.Tick();
			for (int j = 0; j < m_activeEnemies[i].m_guns.Length; j++)
			{
				m_activeEnemies[i].m_guns[j].Tick();
			}
		}
		if (m_enemiesToRemove.Count > 0)
		{
			for (int k = 0; k < m_enemiesToRemove.Count; k++)
			{
				m_activeEnemies.Remove(m_enemiesToRemove[k]);
			}
			m_enemiesToRemove.Clear();
		}
	}

	private void UpdateLoopChecks()
	{
		if (m_killedCount < m_config.loopAfterNumEnemiesKilled)
		{
			return;
		}
		if (Singleton<EnemyBehaviorManager>.Instance.NumOfAttackingPlanes > 0f)
		{
			loopTimer += Time.deltaTime * Singleton<GameManager>.Instance.EnemyTimeScale;
		}
		else
		{
			loopTimer += Time.deltaTime;
		}
		if (loopTimer >= m_config.loopAfterTimeElapsed)
		{
			if (m_config.disintegrateThisWaveOnLoop)
			{
				DisintegrateWave();
			}
			Singleton<EnemyBehaviorManager>.Instance.LoopRestart(m_config.loopWaveStartIndex);
		}
	}

	private bool TryToActivate()
	{
		switch (m_config.m_activateType)
		{
		case ActivationType.ActivateWithTimeDelay:
		case ActivationType.ActivateOnKillOrTimeDelay:
			if (Singleton<EnemyBehaviorManager>.Instance.NumOfAttackingPlanes > 0f)
			{
				m_timeSinceLastSpawn += Time.deltaTime * Singleton<GameManager>.Instance.EnemyTimeScale;
			}
			else
			{
				m_timeSinceLastSpawn += Time.deltaTime;
			}
			IsActive = m_timeSinceLastSpawn > m_timeTillNextSpawn;
			break;
		case ActivationType.ActivateAfterTutorial:
			IsActive = Singleton<TutorialManager>.Instance.PreviousTutorialCompleted == m_config.tutorialIndex;
			break;
		}
		return IsActive;
	}

	private void TryToSpawn()
	{
		if ((m_currentEnemies.Count >= m_config.m_maxPlanes && m_planesInFormation <= 0) || !Singleton<EnemyBehaviorManager>.Instance.IsSpawnAllowed)
		{
			return;
		}
		if (Singleton<EnemyBehaviorManager>.Instance.NumOfAttackingPlanes > 0f)
		{
			m_timeSinceLastSpawn += Time.deltaTime * Singleton<GameManager>.Instance.EnemyTimeScale;
		}
		else
		{
			m_timeSinceLastSpawn += Time.deltaTime;
		}
		if (m_timeSinceLastSpawn > m_timeTillNextSpawn)
		{
			SpawnEnemy();
			if (!hasSpawned)
			{
				hasSpawned = true;
				OnFirstSpawn();
			}
		}
	}

	private void OnFirstSpawn()
	{
		if (m_config.m_waveStartWarningAudioEvent != 0)
		{
			Singleton<AudioManager>.Instance.Play(m_config.m_waveStartWarningAudioEvent);
		}
	}

	private void MakeInactive()
	{
		IsActive = false;
	}

	public void FixedTick()
	{
		for (int i = 0; i < m_activeEnemies.Count; i++)
		{
			m_activeEnemies[i].m_behavior.FixedTick();
		}
	}

	private void SpawnEnemy()
	{
		m_timeSinceLastSpawn = 0f;
		if (m_savedPosition != Vector3.zero)
		{
			m_newPosition = m_savedPosition;
		}
		else
		{
			Vector2 currentAttackSector = Singleton<EnemyBehaviorManager>.Instance.GetCurrentAttackSector();
			m_newDirection = Quaternion.AngleAxis(UnityEngine.Random.Range(currentAttackSector.x, currentAttackSector.y), Vector3.up) * -Vector3.forward;
			m_newPosition = m_newDirection * 300f;
			m_newPosition.y += UnityEngine.Random.Range(-80f, 80f);
			if (m_planesInFormation == 0 && m_config.m_attackPattern != 0)
			{
				m_savedPosition = m_newPosition;
			}
		}
		if (isSpecialTutorialWave)
		{
			m_newPosition.z *= -1f;
		}
		ActiveEnemy activeEnemy = new ActiveEnemy();
		EnemyBehavior fromPool = Singleton<EnemiesPool>.Instance.GetFromPool(m_enemyPreset, m_newPosition, Quaternion.LookRotation(-m_newPosition));
		Singleton<EnemyBehaviorManager>.Instance.OnSpawn(m_config.m_spawner.m_planeType);
		m_spawnedCount++;
		activeEnemy.m_status = fromPool.Status;
		activeEnemy.m_status.Initialise(this);
		m_currentEnemies.Add(activeEnemy.m_status);
		activeEnemy.m_guns = fromPool.Status.Guns;
		fromPool.SetNumberInFormation(0);
		fromPool.m_oneAttack = m_oneAttack;
		switch (m_config.m_attackPattern)
		{
		case AttackPattern.Staggered:
			fromPool.SetNumberInFormation(++m_planesInFormation);
			if (m_planesInFormation >= Singleton<EnemyBehaviorManager>.Instance.StaggeredAttack.m_planesAmount)
			{
				m_planesInFormation = 0;
				m_savedPosition = Vector3.zero;
				m_timeTillNextSpawn = UnityEngine.Random.Range(m_config.m_minDelay, m_config.m_maxDelay);
			}
			else
			{
				m_timeTillNextSpawn = Singleton<EnemyBehaviorManager>.Instance.StaggeredAttack.m_timeDelay;
			}
			break;
		case AttackPattern.Split:
			fromPool.SetNumberInFormation(++m_planesInFormation);
			if (m_planesInFormation >= 4)
			{
				m_planesInFormation = 0;
				m_savedPosition = Vector3.zero;
				m_timeTillNextSpawn = UnityEngine.Random.Range(m_config.m_minDelay, m_config.m_maxDelay);
			}
			else if (m_planesInFormation % 2 == 0)
			{
				m_timeTillNextSpawn = Singleton<EnemyBehaviorManager>.Instance.StaggeredAttack.m_timeDelay;
			}
			else
			{
				m_timeTillNextSpawn = 0.2f;
			}
			break;
		case AttackPattern.None:
			m_timeTillNextSpawn = UnityEngine.Random.Range(m_config.m_minDelay, m_config.m_maxDelay);
			break;
		}
		fromPool.OnBackFromPool();
		activeEnemy.m_behavior = fromPool;
		m_activeEnemies.Add(activeEnemy);
		if (m_config.m_spawner.m_planeType == PlaneType.Wasserfall && !Singleton<AudioManager>.Instance.IsPlaying(AudioEvent.EvtMissileIncoming_Warning))
		{
			Singleton<AudioManager>.Instance.Play(AudioEvent.EvtMissileIncoming_Warning);
		}
	}

	public void OnKill(EnemyStatus enemy, bool killedByPlayer)
	{
		if (enemy.GetHealthPercentage() <= 0f)
		{
			enemy.Behaviour.OnKill();
			if (killedByPlayer)
			{
				if (m_canSpawnPowerUps)
				{
					Singleton<PowerUpManager>.Instance.CreatePowerUp(enemy.transform.position, enemy.transform.rotation);
				}
				Singleton<PlayerScore>.Instance.AddKillPoints(m_pointsValue, enemy);
				if (m_config.m_countTowardsVictory)
				{
					Singleton<MissionManager>.Instance.OnKill(m_config.m_spawner.m_planeType);
				}
			}
			if (IsActive)
			{
				m_killedCount++;
				Singleton<EnemyBehaviorManager>.Instance.OnEnemyKill();
				m_currentEnemies.Remove(enemy);
			}
		}
		else
		{
			enemy.OnDestroy();
			Singleton<EnemiesPool>.Instance.ReturnToPool(enemy.Behaviour, m_enemyPreset);
			m_currentEnemies.Remove(enemy);
		}
	}

	public void OnEnemyDestroy(EnemyStatus enemy)
	{
		for (int i = 0; i < m_activeEnemies.Count; i++)
		{
			if (m_activeEnemies[i].m_status == enemy)
			{
				m_enemiesToRemove.Add(m_activeEnemies[i]);
				break;
			}
		}
		if (m_config.m_spawner.m_planeType == PlaneType.Wasserfall && m_enemiesToRemove.Count == m_activeEnemies.Count)
		{
			Singleton<AudioManager>.Instance.Stop(AudioEvent.EvtMissileIncoming_Warning);
		}
	}

	public void Restart()
	{
		m_spawnedCount = 0;
		m_killedCount = 0;
		m_timeSinceLastSpawn = 0f;
		loopTimer = 0f;
		IsActive = false;
		hasSpawned = false;
		if (m_activationType == ActivationType.ActivateOnStart)
		{
			ActivateSpawner();
		}
		m_timeTillNextSpawn = m_config.m_activationDelay;
		m_stopSpawn = false;
		m_planesInFormation = 0;
	}

	public void TryActivate(int[] killedCount)
	{
		int num = 0;
		for (int i = 0; i < killedCount.Length; i++)
		{
			for (int j = 0; j < m_config.m_previosWaves.Length; j++)
			{
				if (m_config.m_previosWaves[j] == i)
				{
					num += killedCount[i];
				}
			}
		}
		if (num >= m_config.m_planesToKillFromPreviosWaves)
		{
			ActivateSpawner();
		}
	}

	public void DisintegrateWave()
	{
		for (int i = 0; i < m_currentEnemies.Count; i++)
		{
			m_currentEnemies[i].Behaviour.Disintegrate();
		}
		m_stopSpawn = true;
	}
}
public class EnemyStatus : MonoBehaviour
{
	private float m_maxHealth = 100f;

	private float m_currentHealth;

	private float m_damageAudioParamTargetValue;

	private float m_damageAudioParamValue;

	[SerializeField]
	private float m_damageAudioParamChangeRate = 0.25f;

	public AudioEvent _engineAudioEvent = AudioEvent.EvtNPCNMEEngine;

	public AudioEvent _engineAudioPassbyDownEvent = AudioEvent.EvtNPCNMEEngine_passby_down;

	public AudioEvent _engineAudioPassbyUpEvent = AudioEvent.EvtNPCNMEEngine_passby_up;

	public AudioEvent _engineAudioPassbyLeftRightEvent = AudioEvent.EvtNPCNMEEngine_passby_left_right;

	public AudioEvent _explodeAudioEvent = AudioEvent.EvtNPCNMEExplode;

	private DamageEffect m_smokeEffect;

	[HideInInspector]
	public float FirstDamageTime;

	[HideInInspector]
	public bool StartedFire;

	[HideInInspector]
	public float DamageDone;

	[HideInInspector]
	public float FriendlyDamageDone;

	[SerializeField]
	private bool m_showHealthBar = true;

	[SerializeField]
	private bool m_trackedOnRadar = true;

	[SerializeField]
	private EffectType explosionEffectType = EffectType.Explosion;

	private EnemySpawner m_spawner;

	[NonSerialized]
	public EnemyBehavior Behaviour;

	[NonSerialized]
	[HideInInspector]
	public Gun[] Guns;

	[NonSerialized]
	[HideInInspector]
	public MissileGun[] MissileGuns;

	private RadarPointer m_radarPointer;

	private EnemyHealthBar m_healthBar;

	public bool updateDamageAudio = true;

	private bool m_updateHealthBar = true;

	private bool invincible;

	[NonSerialized]
	[HideInInspector]
	public new Transform transform;

	[SerializeField]
	private UnityEngine.Color fullHealthColour = UnityEngine.Color.green;

	[SerializeField]
	private UnityEngine.Color minorHealthLossColour = UnityEngine.Color.yellow;

	[SerializeField]
	private UnityEngine.Color majorHealthLossColour = UnityEngine.Color.red;

	private static readonly float MIN_TIME_BETWEEN_EXPLOSIONS = 1f;

	private static float ms_nextExplosionMinTime;

	public bool TrackedOnRadar => m_trackedOnRadar;

	public EnemySpawner Spawner
	{
		get
		{
			return m_spawner;
		}
		private set
		{
			m_spawner = value;
		}
	}

	public bool IsAlive => m_currentHealth > 0f;

	private void Awake()
	{
		Behaviour = GetComponent<EnemyBehavior>();
		DamageEffect[] componentsInChildren = GetComponentsInChildren<DamageEffect>(includeInactive: true);
		if (componentsInChildren.Length == 1)
		{
			m_smokeEffect = componentsInChildren[0];
		}
		Guns = GetComponentsInChildren<Gun>(includeInactive: true);
		MissileGuns = GetComponentsInChildren<MissileGun>(includeInactive: true);
		transform = GetComponent<Transform>();
		if (m_trackedOnRadar)
		{
			GameObject gameObject = new GameObject("Radar Pointer");
			gameObject.transform.parent = transform;
			m_radarPointer = gameObject.AddComponent<RadarPointer>();
			m_radarPointer.TargetEnemy = this;
		}
	}

	public void Initialise(EnemySpawner spawner)
	{
		Singleton<GameManager>.Instance.OnStartMission += SelfDestroy;
		Spawner = spawner;
		m_maxHealth = Spawner.MaxHealth;
		SetCurrentHealth(m_maxHealth, hitByPlayer: false);
		m_damageAudioParamValue = 0f;
		m_damageAudioParamTargetValue = 0f;
		if (updateDamageAudio)
		{
			Singleton<AudioManager>.Instance.SetParameter(_engineAudioEvent, ParameterType.Damage, m_damageAudioParamValue, base.gameObject, canBePaused: true);
		}
		FirstDamageTime = -1f;
		StartedFire = false;
		DamageDone = 0f;
		FriendlyDamageDone = 0f;
		if (Singleton<MissionManager>.Instance.TimeLimit != TimeLimit.Checkpoint)
		{
			SetupHealthBar();
		}
		else if (Behaviour is CargoBehavior)
		{
			invincible = true;
		}
		else
		{
			SetupHealthBar();
		}
		if (m_healthBar == null)
		{
			m_updateHealthBar = false;
		}
		if (m_radarPointer != null)
		{
			m_radarPointer.gameObject.SetActive(value: true);
			m_radarPointer.ActivateInRenderer(active: true);
		}
		if (Guns != null)
		{
			for (int i = 0; i < Guns.Length; i++)
			{
				Guns[i].SetParams(spawner.m_fireRate, spawner.m_damage);
			}
		}
		if (MissileGuns != null)
		{
			for (int j = 0; j < MissileGuns.Length; j++)
			{
				MissileGuns[j].SetDamage(spawner.m_damage);
			}
		}
	}

	private void SetupHealthBar()
	{
		if (m_showHealthBar)
		{
			if (m_healthBar == null)
			{
				m_healthBar = EnemyHealthBar.CreateNew(this, fullHealthColour, minorHealthLossColour, majorHealthLossColour);
			}
			else
			{
				m_healthBar.gameObject.SetActive(value: true);
			}
		}
	}

	private void SelfDestroy(bool restart)
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}

	public void OnDestroy()
	{
		if (Singleton<GameManager>.Instance != null)
		{
			Singleton<GameManager>.Instance.OnStartMission -= SelfDestroy;
		}
		if (!Singleton<LoadingScreen>.TryInstance() && Singleton<EnemyBehaviorManager>.Instance != null)
		{
			Singleton<EnemyBehaviorManager>.Instance.OnEnemyDestroy();
		}
		if (m_spawner != null)
		{
			m_spawner.OnEnemyDestroy(this);
		}
		if (Singleton<MassLineRenderer>.TryInstance() && m_radarPointer != null)
		{
			m_radarPointer.gameObject.SetActive(value: false);
			m_radarPointer.ActivateInRenderer(active: false);
		}
		m_currentHealth = 0f;
	}

	public void Tick()
	{
		if (m_damageAudioParamValue != m_damageAudioParamTargetValue && updateDamageAudio)
		{
			float num = m_damageAudioParamChangeRate * Time.deltaTime;
			float num2 = Mathf.Clamp(m_damageAudioParamTargetValue - m_damageAudioParamValue, 0f - num, num);
			m_damageAudioParamValue += num2;
			Singleton<AudioManager>.Instance.SetParameter(_engineAudioEvent, ParameterType.Damage, m_damageAudioParamValue, base.gameObject, canBePaused: true);
		}
		if (m_updateHealthBar && m_healthBar != null)
		{
			m_healthBar.Tick();
		}
		if (m_currentHealth <= 0f && (Spawner.SpawnsWasserfalls || transform.position.y < -350f))
		{
			OnDestroy();
			Singleton<EnemiesPool>.Instance.ReturnToPool(Behaviour, Spawner.m_enemyPreset);
			return;
		}
		if ((bool)m_smokeEffect)
		{
			m_smokeEffect.UpdateSmoke(GetHealthPercentage());
		}
		if ((bool)m_radarPointer && !Singleton<GameManager>.Instance.IsPaused)
		{
			m_radarPointer.Tick(Time.deltaTime);
		}
	}

	private void SetCurrentHealth(float newHealth, bool hitByPlayer)
	{
		m_currentHealth = Mathf.Clamp(newHealth, 0f, m_maxHealth);
		if (m_currentHealth <= 0f)
		{
			Explode(hitByPlayer);
		}
		m_damageAudioParamTargetValue = 1f - GetHealthPercentage();
	}

	public void Explode(bool killedByPlayer)
	{
		m_spawner.OnKill(this, killedByPlayer);
		Singleton<AudioManager>.Instance.Stop(_engineAudioEvent, base.gameObject);
		if (killedByPlayer && (!Singleton<GameManager>.Instance.ReduceQuality || Time.time > ms_nextExplosionMinTime))
		{
			Singleton<EffectsPool>.Instance.GetFromPool(explosionEffectType, transform.position, transform.rotation);
			Vector3 position = transform.position;
			if (Singleton<GameManager>.Instance.State == GameManager.GameState.Inactive)
			{
				position.z = Singleton<AudioManager>.Instance.soundEffectDistanceOnMissionEnd;
			}
			Singleton<AudioManager>.Instance.PlayInLocation(_explodeAudioEvent, position);
			ms_nextExplosionMinTime = Time.time + MIN_TIME_BETWEEN_EXPLOSIONS;
		}
		m_currentHealth = 0f;
		if ((bool)m_radarPointer)
		{
			m_radarPointer.gameObject.SetActive(value: false);
		}
	}

	public void Hurt(float Damage, bool hitByPlayer)
	{
		if (!invincible && IsAlive)
		{
			if (FirstDamageTime < 0f && Damage < m_currentHealth)
			{
				FirstDamageTime = Time.time;
			}
			SetCurrentHealth(m_currentHealth - Damage, hitByPlayer);
		}
	}

	public float GetHealthPercentage()
	{
		return m_currentHealth / m_maxHealth;
	}

	public bool IsOnAttackRun()
	{
		if ((bool)Behaviour)
		{
			return Behaviour.IsOnAttackRun;
		}
		return false;
	}

	public bool IsCargoPlane()
	{
		if ((bool)m_spawner)
		{
			return m_spawner.CanSpawnPowerUps;
		}
		return false;
	}
}
public class JinkerEnemyBehavior : EnemyBehavior
{
	[SerializeField]
	private float m_jinkRadius = 15f;

	[SerializeField]
	private float m_jinkOffset = 55f;

	[SerializeField]
	private float m_jinkSpeed = 1f;

	private float m_currentOffset;

	private float m_currentDirection = 1f;

	private float m_jinkVelocity;

	protected override void BehaviorUpdate(float deltaTime)
	{
		float num = 0f;
		if (m_currentState == BehaviorType.Attacking && (bool)m_target)
		{
			desiredRotation = Quaternion.Lerp(desiredRotation, Quaternion.LookRotation(m_target.position - desiredPosition), deltaTime * m_maxTurnSpeed);
			m_targetRotation = desiredRotation;
			num = Mathf.SmoothDamp(m_currentOffset, m_jinkOffset * m_currentDirection, ref m_jinkVelocity, m_jinkSpeed, float.PositiveInfinity, deltaTime);
			if (Math.Abs(m_jinkOffset * m_currentDirection - num) < 30f)
			{
				m_currentDirection *= -1f;
			}
		}
		else
		{
			num = Mathf.SmoothDamp(m_currentOffset, 0f, ref m_jinkVelocity, m_jinkSpeed);
		}
		base.BehaviorUpdate(deltaTime);
		Vector3 vector = desiredPosition + transform.up * m_jinkRadius;
		float num2 = num - m_currentOffset;
		if (!Mathf.Approximately(num2, 0f))
		{
			Quaternion quaternion = Quaternion.AngleAxis(num2, transform.forward);
			Vector3 vector2 = desiredPosition - vector;
			vector2 = quaternion * vector2;
			desiredPosition = vector + vector2;
			desiredRotation = quaternion * desiredRotation;
			UpdateRoll(deltaTime);
		}
		m_currentOffset = num;
	}
}
public class KometEnemyBehavior : EnemyBehavior
{
	[SerializeField]
	private float m_attackAngle;

	public override void OnBackFromPool()
	{
		base.OnBackFromPool();
		Vector3 vector = transform.position.normalized * 1000f;
		vector.y = -150f;
		desiredPosition = vector;
		m_oneAttack = true;
		transform.position = desiredPosition;
	}

	protected override void BehaviorUpdate(float deltaTime)
	{
		if (m_currentState == BehaviorType.StartsAttacking)
		{
			m_currentStateTime += deltaTime;
			if (m_target == null || m_currentStateTime > 20f)
			{
				StartMakingDistance(justSpawned: false);
			}
			m_targetRotation = Quaternion.LookRotation(Vector3.up * 300f - desiredPosition);
			Vector3 to = desiredPosition;
			to.y = 0f;
			float num = Vector3.Angle(desiredPosition, to);
			if (num > m_attackAngle)
			{
				m_currentState = BehaviorType.Attacking;
				m_rotationSpeed = 0f;
				m_rotationVelocity = 0f;
			}
			if (desiredRotation != m_targetRotation)
			{
				desiredRotation = Quaternion.Lerp(desiredRotation, m_targetRotation, deltaTime * m_maxTurnSpeed);
			}
			float y = m_pitchYawRoll.y;
			m_pitchYawRoll = desiredRotation.eulerAngles;
			m_pitchYawRoll.z = Mathf.MoveTowardsAngle(m_pitchYawRoll.z, (y - m_pitchYawRoll.y) * 150f, deltaTime * 50f);
			desiredRotation = Quaternion.Euler(m_pitchYawRoll);
			desiredPosition += transform.forward * deltaTime * m_speed_mod;
		}
		if (m_currentState == BehaviorType.Attacking && (bool)m_target)
		{
			desiredRotation = Quaternion.Lerp(desiredRotation, Quaternion.LookRotation(m_target.position - desiredPosition), deltaTime * m_maxTurnSpeed);
			m_targetRotation = desiredRotation;
			if (m_isShooting)
			{
				PerformPullOut(m_target.gameObject, goUnderneath: true);
			}
		}
		if (m_currentState != BehaviorType.StartsAttacking)
		{
			base.BehaviorUpdate(deltaTime);
		}
	}
}
public class LurkerEnemyBehavior : EnemyBehavior
{
	public enum CirclingStage
	{
		Circling,
		Turning,
		None
	}

	[SerializeField]
	private float m_attackFrequency = 4f;

	private CirclingStage m_circlingStage;

	private float m_curTurnAngle;

	private MissileGun m_missileGuns;

	private float m_turnDirection;

	private Vector3 m_2dPosition;

	protected override void Awake()
	{
		base.Awake();
		m_missileGuns = GetComponentInChildren<MissileGun>();
		m_freezeHeight = true;
	}

	public override void OnBackFromPool()
	{
		m_oneAttack = false;
		m_isDying = false;
		m_currentStateTime = 0f;
		m_rotationVelocity = 0f;
		m_rotationSpeed = 0f;
		m_circlingRadius = UnityEngine.Random.Range(m_minCirclingRadius, m_maxCirclingRadius);
		m_circlingRadiusSquared = m_circlingRadius * m_circlingRadius;
		m_2dPosition = transform.position;
		m_2dPosition.y = 0f;
		Vector3 rhs = Vector3.Cross(Vector3.forward, m_2dPosition);
		desiredPosition = -Vector3.forward * m_circlingRadius;
		desiredRotation = (m_targetRotation = Quaternion.LookRotation(-Vector3.Cross(m_2dPosition, rhs)));
		m_currentState = BehaviorType.Circling;
		m_curTurnAngle = 20f;
		m_circlingStage = CirclingStage.Circling;
		transform.position = desiredPosition;
		transform.rotation = desiredRotation;
		UpdateAudio();
	}

	protected override void BehaviorUpdate(float deltaTime)
	{
		m_2dPosition = desiredPosition;
		m_2dPosition.y = 0f;
		switch (m_currentState)
		{
		case BehaviorType.Circling:
			if (m_circlingStage != CirclingStage.None)
			{
				m_behaviorUpdated = true;
				m_currentStateTime += deltaTime;
				UpdateCircling();
			}
			break;
		case BehaviorType.Attacking:
			m_behaviorUpdated = true;
			m_currentStateTime += deltaTime;
			m_targetRotation = Quaternion.LookRotation(m_target.position - desiredPosition);
			if (m_currentStateTime > 1f)
			{
				m_currentState = BehaviorType.Circling;
				m_circlingStage = CirclingStage.Circling;
				m_currentStateTime = 0f;
			}
			break;
		case BehaviorType.StartsAttacking:
			m_behaviorUpdated = true;
			m_targetRotation = Quaternion.LookRotation(m_target.position - desiredPosition);
			if (Quaternion.Angle(m_targetRotation, desiredRotation) < 45f)
			{
				m_currentState = BehaviorType.Attacking;
				m_currentStateTime = 0f;
				if (!m_oneAttack && Status.IsAlive)
				{
					m_missileGuns.Shoot();
				}
			}
			break;
		}
		m_freezeHeight = m_behaviorUpdated;
		base.BehaviorUpdate(deltaTime);
	}

	private void TurnAround()
	{
		m_targetRotation = Quaternion.LookRotation(-Vector3.forward * m_circlingRadius - desiredPosition);
		m_circlingStage = CirclingStage.Turning;
		m_rotationVelocity = 0f;
		m_rotationSpeed = 0f;
		m_turnDirection = Mathf.Sign(Vector3.Cross(Vector3.forward, m_2dPosition).y);
	}

	private void UpdateCircling()
	{
		switch (m_circlingStage)
		{
		case CirclingStage.Circling:
		{
			if (Quaternion.Angle(m_targetRotation, desiredRotation) < 5f)
			{
				desiredRotation = m_targetRotation;
			}
			Vector3 vector = desiredPosition;
			Vector3 forward2 = transform.forward;
			vector.y = (forward2.y = 0f);
			Vector3 rhs = Vector3.Cross(-vector, forward2);
			m_targetRotation = Quaternion.LookRotation(-Vector3.Cross(-vector, rhs));
			float num2 = Vector3.Dot(Vector3.forward, transform.forward);
			if (!(num2 > 0f))
			{
				break;
			}
			num2 = 90f - Mathf.Acos(Mathf.Clamp(num2, -1f, 1f)) * 57.29578f;
			if (num2 > m_curTurnAngle)
			{
				if (m_currentStateTime > m_attackFrequency)
				{
					StartAttack();
				}
				else
				{
					TurnAround();
				}
			}
			break;
		}
		case CirclingStage.Turning:
		{
			bool flag = Quaternion.Angle(m_targetRotation, desiredRotation) < 5f;
			float f = Mathf.Clamp(Vector3.Dot(-Vector3.forward, m_2dPosition.normalized), -1f, 1f);
			f = Mathf.Acos(f) * 57.29578f;
			if (!flag && f > 10f && m_turnDirection == Mathf.Sign(Vector3.Cross(Vector3.forward, m_2dPosition).y))
			{
				Vector3 forward = -Vector3.forward * m_circlingRadius - desiredPosition;
				m_targetRotation = Quaternion.LookRotation(forward);
				break;
			}
			m_targetRotation = desiredRotation;
			float num = Vector3.SqrMagnitude(desiredPosition);
			if (num >= m_circlingRadiusSquared)
			{
				m_circlingStage = CirclingStage.Circling;
				m_rotationVelocity = 0f;
				m_rotationSpeed = 0f;
			}
			break;
		}
		}
	}

	protected override void StartAttack()
	{
		m_currentState = BehaviorType.StartsAttacking;
		m_circlingStage = CirclingStage.None;
		ChooseTarget();
		m_targetRotation = Quaternion.LookRotation(m_target.position - desiredPosition);
		m_currentStateTime = 0f;
	}

	public override void Disintegrate()
	{
		base.Disintegrate();
		m_circlingStage = CirclingStage.None;
	}
}
public class MEEnemyBEhavior : EnemyBehavior
{
	public enum AttackStage
	{
		Front,
		Swoop,
		Rare,
		None
	}

	[SerializeField]
	private float m_verticalDistance;

	[SerializeField]
	private float m_minAttackDistance;

	private float m_minAttackDistanceSquared;

	[SerializeField]
	private float m_maxSideAttackDistance;

	private float m_maxSideAttackDistanceSquared;

	private Gun m_rareGuns;

	private AttackStage m_attackStage;

	protected override void Awake()
	{
		base.Awake();
		Gun[] componentsInChildren = transform.GetComponentsInChildren<Gun>();
		m_guns = componentsInChildren[0];
		m_rareGuns = componentsInChildren[1];
		m_maxSideAttackDistanceSquared = m_maxSideAttackDistance * m_maxSideAttackDistance;
		m_minAttackDistanceSquared = m_minAttackDistance * m_minAttackDistance;
	}

	public override void OnBackFromPool()
	{
		base.OnBackFromPool();
		m_currentState = BehaviorType.Attacking;
		m_attackStage = AttackStage.Rare;
		float angle = UnityEngine.Random.Range(-60f, -120f);
		Vector3 vector = Quaternion.AngleAxis(angle, Vector3.up) * Vector3.right;
		Vector3 vector2 = vector * 100f;
		vector2.y = m_verticalDistance;
		desiredPosition = vector2;
		desiredRotation = (m_targetRotation = Quaternion.LookRotation(-vector));
	}

	protected override void StartAttack()
	{
		base.StartAttack();
		if (m_attackStage == AttackStage.None)
		{
			m_attackStage = AttackStage.Front;
		}
		m_circlingRadius = UnityEngine.Random.Range(m_minCirclingRadius, m_maxCirclingRadius);
		m_circlingRadiusSquared = m_circlingRadius * m_circlingRadius;
		if (m_isShooting)
		{
			SetShooting(start: false);
		}
	}

	private void PerformSwoop()
	{
		m_attackStage = AttackStage.Swoop;
		if (m_isShooting)
		{
			SetShooting(start: false);
		}
		Vector3 vector = desiredPosition;
		vector.y = 0f;
		float num = Vector3.Angle(-m_target.forward, vector);
		float num2 = Mathf.Sign(vector.x);
		Quaternion quaternion = Quaternion.AngleAxis(num * (0f - num2) * 2f, Vector3.up);
		m_targetRotation.SetLookRotation(quaternion * -vector);
	}

	protected override bool CanShoot()
	{
		float num = Vector3.SqrMagnitude(desiredPosition);
		float num2 = Vector3.Dot(transform.forward, desiredPosition);
		switch (m_attackStage)
		{
		case AttackStage.Front:
		{
			Vector3 vector = desiredPosition;
			vector.y = 0f;
			float f = Vector3.Dot(Vector3.forward, vector.normalized);
			if (Mathf.Abs(f) < 0.9f)
			{
				if (num < 5000f)
				{
					PerformSwoop();
				}
			}
			else if (num < 3500f)
			{
				PerformPullOut(m_target.gameObject);
				SetShooting(start: false);
				m_attackStage = AttackStage.None;
			}
			if (num2 < 0f)
			{
				f = Vector3.Dot(transform.forward, (m_target.position - desiredPosition).normalized);
				f = Mathf.Acos(Mathf.Clamp(f, -1f, 1f)) * 57.29578f;
				if (f < 20f || float.IsNaN(f))
				{
					return true;
				}
			}
			break;
		}
		case AttackStage.Rare:
			if (num2 > 0f)
			{
				if (num > m_attackDistanceSquared || num > m_circlingRadiusSquared)
				{
					m_circlingRadius = Mathf.Sqrt(num) + 1f;
					m_circlingRadiusSquared = num + 1f;
					StartMakingDistance(justSpawned: false);
					m_attackStage = AttackStage.None;
				}
				else if (num > m_minAttackDistanceSquared)
				{
					return true;
				}
			}
			break;
		case AttackStage.Swoop:
			if (num > m_attackDistanceSquared || num > m_circlingRadiusSquared - 150f)
			{
				StartMakingDistance(justSpawned: false);
				SetShooting(start: false);
				m_attackStage = AttackStage.None;
			}
			break;
		}
		return false;
	}

	protected override void BehaviorUpdate(float deltaTime)
	{
		if (m_isShooting)
		{
			if (m_rareGuns.IsShooting)
			{
				m_rareGuns.UpdateGunRotation();
				m_rareGuns.Shoot();
			}
			else if (m_guns.IsShooting)
			{
				m_guns.Shoot();
			}
		}
		if (m_currentState == BehaviorType.StartsAttacking)
		{
			if (m_attackStage == AttackStage.Rare)
			{
				m_behaviorUpdated = true;
				Vector3 forward = m_target.position - desiredPosition;
				forward.y = 0f;
				m_targetRotation = Quaternion.LookRotation(forward);
				if (Quaternion.Angle(m_targetRotation, desiredRotation) < 10f)
				{
					m_currentState = BehaviorType.Attacking;
					m_rotationSpeed = 0f;
					m_rotationVelocity = 0f;
				}
			}
		}
		else if (m_currentState == BehaviorType.Attacking)
		{
			m_behaviorUpdated = true;
			if (m_target == null)
			{
				StartMakingDistance(justSpawned: false);
			}
			else
			{
				bool flag = CanShoot();
				if (!m_isShooting && flag)
				{
					SetShooting(start: true);
				}
				else if (m_isShooting && !flag)
				{
					SetShooting(start: false);
				}
				if (m_attackStage == AttackStage.Front)
				{
					desiredRotation = Quaternion.Lerp(desiredRotation, Quaternion.LookRotation(m_target.position - desiredPosition), deltaTime * m_maxTurnSpeed);
					m_targetRotation = desiredRotation;
				}
				else if (m_attackStage == AttackStage.Swoop && Quaternion.Angle(m_targetRotation, desiredRotation) < 5f)
				{
					m_attackStage = AttackStage.Rare;
				}
			}
		}
		else if (m_currentState == BehaviorType.Circling)
		{
			m_behaviorUpdated = true;
			Vector3 vector = desiredPosition;
			Vector3 forward2 = transform.forward;
			vector.y = (forward2.y = 0f);
			float value = Vector3.Dot(Vector3.forward, vector.normalized);
			value = Mathf.Acos(Mathf.Clamp(value, -1f, 1f)) * 57.29578f;
			if (m_oneAttack && value < 10f)
			{
				Status.Spawner.OnKill(Status, killedByPlayer: false);
				return;
			}
			float num = Vector3.SqrMagnitude(vector);
			if (m_isShooting && (value > 225f || value < 100f || num > m_maxSideAttackDistanceSquared))
			{
				SetShooting(start: false);
			}
			else if (!m_isShooting && num <= m_maxSideAttackDistanceSquared && value > 100f && value < 265f)
			{
				SetShooting(start: true);
			}
			if (desiredPosition.y > m_verticalDistance - 20f && desiredPosition.y < m_verticalDistance + 20f && Singleton<EnemyBehaviorManager>.Instance.IsAttackAllowed && value < 35f && !m_oneAttack)
			{
				m_currentState = BehaviorType.StartsAttacking;
				Singleton<EnemyBehaviorManager>.Instance.OnStartAttack();
				m_target = playerTransform;
				m_attackStage = AttackStage.Rare;
				m_behaviorUpdated = true;
				Vector3 forward3 = m_target.position - desiredPosition;
				forward3.y = 0f;
				m_targetRotation = Quaternion.LookRotation(forward3);
			}
			m_behaviorUpdated = true;
			if (Quaternion.Angle(m_targetRotation, desiredRotation) < 10f && !m_oneAttack && CanAttack())
			{
				StartAttack();
			}
			if (m_currentState == BehaviorType.Circling)
			{
				Vector3 rhs = Vector3.Cross(-vector, forward2);
				m_targetRotation = Quaternion.LookRotation(-Vector3.Cross(-vector, rhs));
			}
		}
		base.BehaviorUpdate(deltaTime);
	}

	protected override void SetShooting(bool start)
	{
		m_isShooting = start;
		if (start)
		{
			Status.StartedFire = true;
		}
		if (m_attackStage == AttackStage.Front)
		{
			if (start)
			{
				if (m_rareGuns.IsShooting)
				{
					m_rareGuns.EndShooting();
				}
				m_guns.StartShooting();
			}
			else
			{
				m_guns.EndShooting();
			}
		}
		else if (m_attackStage == AttackStage.Rare)
		{
			if (start)
			{
				if (m_guns.IsShooting)
				{
					m_guns.EndShooting();
				}
				m_rareGuns.StartShooting();
			}
			else
			{
				m_rareGuns.EndShooting();
			}
		}
		else if (m_attackStage == AttackStage.None)
		{
			m_guns.EndShooting();
			if (!start)
			{
				m_rareGuns.EndShooting();
			}
			else if (!m_rareGuns.IsShooting)
			{
				m_rareGuns.StartShooting();
			}
		}
	}

	protected override void StartMakingDistance(bool justSpawned)
	{
		if (base.IsOnAttackRun && !onlyAttackFriends)
		{
			Singleton<EnemyBehaviorManager>.Instance.OnStopAttack();
		}
		m_currentState = BehaviorType.MakingDistance;
		float num = Vector3.SqrMagnitude(desiredPosition - playerTransform.position);
		if (num > m_circlingRadiusSquared)
		{
			float num2 = 0f - Mathf.Sign(Vector3.Cross(playerTransform.forward, playerTransform.position - desiredPosition).y);
			Vector3 vector = playerTransform.position + playerTransform.right * num2 * m_circlingRadius;
			vector.y = desiredPosition.y;
			m_targetRotation = Quaternion.LookRotation(vector - desiredPosition);
			m_furtherThanRadius = true;
			if (justSpawned)
			{
				desiredRotation = m_targetRotation;
			}
		}
		else
		{
			m_targetRotation = desiredRotation;
			m_targetRotation.x = (m_targetRotation.z = 0f);
			m_furtherThanRadius = false;
		}
	}
}
public class RocketMe262Behaviour : EnemyBehavior
{
	private MissileGun m_missileGuns;

	private float m_prevHealth = 1f;

	protected override void Awake()
	{
		base.Awake();
		m_missileGuns = GetComponentInChildren<MissileGun>();
	}

	protected override void BehaviorUpdate(float deltaTime)
	{
		if (m_currentState == BehaviorType.Attacking && (bool)m_target)
		{
			desiredRotation = Quaternion.Lerp(desiredRotation, Quaternion.LookRotation(m_target.position - desiredPosition), deltaTime * m_maxTurnSpeed);
			m_targetRotation = desiredRotation;
		}
		switch (m_currentState)
		{
		case BehaviorType.Attacking:
		{
			if (Status.GetHealthPercentage() + 0.001f < m_prevHealth)
			{
				PerformPullOut(null);
				break;
			}
			float num = Vector3.SqrMagnitude(desiredPosition);
			if (num < m_circlingRadiusSquared / 2f && Status.IsAlive)
			{
				m_missileGuns.Shoot();
				PerformPullOut(null);
			}
			break;
		}
		case BehaviorType.StartsAttacking:
		case BehaviorType.MakingDistance:
			if (Status.GetHealthPercentage() + 0.001f < m_prevHealth)
			{
				PerformPullOut(null);
			}
			break;
		}
		m_prevHealth = Status.GetHealthPercentage();
		base.BehaviorUpdate(deltaTime);
	}
}
public class SimpleEnemyBehavior : EnemyBehavior
{
	protected override void BehaviorUpdate(float deltaTime)
	{
		if (m_currentState == BehaviorType.Attacking && (bool)m_target)
		{
			desiredRotation = Quaternion.Lerp(desiredRotation, Quaternion.LookRotation(m_target.position - desiredPosition), deltaTime * m_maxTurnSpeed);
			m_targetRotation = desiredRotation;
		}
		base.BehaviorUpdate(deltaTime);
	}
}
public class SmartEnemyBehavior : EnemyBehavior
{
	private bool m_isAvoiding;

	private float m_prevHealth = 1f;

	private float m_avoidTime;

	protected override void BehaviorUpdate(float deltaTime)
	{
		if (m_currentState == BehaviorType.Attacking && m_target != null)
		{
			if (!m_isAvoiding)
			{
				desiredRotation = Quaternion.Lerp(desiredRotation, Quaternion.LookRotation(m_target.position - desiredPosition), deltaTime * m_maxTurnSpeed);
				m_targetRotation = desiredRotation;
				if (Status.GetHealthPercentage() + 0.001f < m_prevHealth)
				{
					m_isAvoiding = true;
					m_avoidTime = 0f;
					float angle = UnityEngine.Random.Range(0f, 360f);
					Vector3 vector = Quaternion.AngleAxis(45f, transform.right) * transform.forward;
					vector = Quaternion.AngleAxis(angle, transform.forward) * vector;
					m_targetRotation.SetLookRotation(vector);
				}
			}
			else
			{
				m_avoidTime += deltaTime;
				if (m_avoidTime > 1f)
				{
					m_isAvoiding = false;
				}
			}
		}
		else
		{
			m_isAvoiding = false;
		}
		m_prevHealth = Status.GetHealthPercentage();
		base.BehaviorUpdate(deltaTime);
		if (m_currentState == BehaviorType.Attacking)
		{
			float y = m_pitchYawRoll.y;
			m_pitchYawRoll = desiredRotation.eulerAngles;
			m_pitchYawRoll.z = Mathf.MoveTowardsAngle(m_pitchYawRoll.z, (y - m_pitchYawRoll.y) * 150f, deltaTime * 50f);
			desiredRotation = Quaternion.Euler(m_pitchYawRoll);
		}
	}
}
public enum PlaneType
{
	StraightFlyer,
	Jinker,
	Avoider,
	Cargo,
	Any,
	Komet,
	Lurker,
	ME,
	BonusRocket,
	Wasserfall,
	StraightFlyer1,
	StraightFlyer2,
	Jinker1,
	Jinker2,
	Avoider1,
	Avoider2,
	Cargo1,
	RocketMe262,
	Armoured262,
	Armoured262Protect,
	CargoEasy,
	Komet2,
	Lurker2,
	ME2,
	StraightFlyer1Protect,
	StraightFlyer2Protect
}
public class SpawnerSettings : ScriptableObject
{
	public PlaneType m_planeType;

	public float m_maxHealth = 100f;

	public int m_pointsValue = 100;

	public float m_bulletDamage = 5f;

	public float m_fireRate = 300f;

	public bool m_canSpawnPowerUps;
}
public class WasserfallEnemyBehavior : EnemyBehavior
{
	[SerializeField]
	private float m_minAttackHeight = -100f;

	[SerializeField]
	private float m_maxAttackHeight = 80f;

	[SerializeField]
	private ParticleSystem m_launchEffect;

	[SerializeField]
	private AudioEvent m_flyLoopSoundEvent;

	[SerializeField]
	private AudioEvent m_lastOneHitAudioEvent = AudioEvent.EvtPlayerVoxChatter_Wasser_Wave_Finished;

	[SerializeField]
	private AudioEvent m_launchAudioEvent;

	public AudioEvent killedSoundEvent = AudioEvent.EvtNPCNME_Wasserfall_Missile_Shot_Explode;

	public AudioEvent impactSoundEvent = AudioEvent.EvtNPCNME_Wasserfall_Missile_Impact_Explode;

	[SerializeField]
	private float m_acceleration = 5f;

	private float m_currentSpeed;

	[SerializeField]
	private Transform missileMesh;

	[SerializeField]
	private float spinSpeed = 2f;

	private float m_attackHeight;

	private bool m_active = true;

	private Vector3 m_targetPosition;

	private FriendlyPlane planeTarget;

	public override void OnBackFromPool()
	{
		if (Singleton<MissionManager>.Instance.WinCondition == WinCondition.Protect)
		{
			ChooseTarget();
			if (m_target != playerTransform)
			{
				planeTarget = m_target.GetComponent<FriendlyPlane>();
			}
			else
			{
				planeTarget = null;
			}
		}
		Vector3 vector = transform.position.normalized * 1000f;
		vector.y = -400f;
		desiredPosition = vector;
		transform.position = desiredPosition;
		desiredRotation = transform.rotation;
		m_attackHeight = UnityEngine.Random.Range(m_minAttackHeight, m_maxAttackHeight);
		m_currentState = BehaviorType.StartsAttacking;
		transform.GetChild(0).gameObject.SetActive(value: true);
		transform.GetChild(1).gameObject.SetActive(value: true);
		m_rotationSpeed = 0f;
		m_rotationVelocity = 0f;
		m_active = true;
		m_currentSpeed = 0f;
		Status.StartedFire = true;
		Singleton<AudioManager>.Instance.Play(m_flyLoopSoundEvent, gameObject);
		if (m_launchEffect != null)
		{
			Vector3 position = desiredPosition;
			position -= position.normalized * 25.7f;
			ParticleSystem particleSystem = UnityEngine.Object.Instantiate(m_launchEffect, position, Quaternion.LookRotation(-desiredPosition));
			if (particleSystem.gameObject.GetComponent<OneTimeParticleSystem>() == null)
			{
				particleSystem.gameObject.AddComponent<OneTimeParticleSystem>();
			}
			if (particleSystem.gameObject.GetComponent<MoveWithGroundSlider>() == null)
			{
				particleSystem.gameObject.AddComponent<MoveWithGroundSlider>();
			}
			if (gameObject.GetComponent<MoveWithGroundSlider>() == null)
			{
				gameObject.AddComponent<MoveWithGroundSlider>();
			}
			Singleton<AudioManager>.Instance.Play(m_launchAudioEvent, gameObject);
		}
	}

	protected override void BehaviorUpdate(float deltaTime)
	{
		if (m_currentState == BehaviorType.StartsAttacking)
		{
			m_currentSpeed = Mathf.SmoothStep(m_currentSpeed, m_speed, deltaTime * m_acceleration);
			m_targetRotation = Quaternion.LookRotation(Vector3.up * 300f - desiredPosition);
			if (desiredPosition.y > m_attackHeight)
			{
				m_currentState = BehaviorType.Attacking;
				if (!Singleton<AudioManager>.Instance.IsPlaying(AudioEvent.EvtPlayerVoxChatter_MissileClose))
				{
					Singleton<AudioManager>.Instance.Play(AudioEvent.EvtPlayerVoxChatter_MissileClose);
				}
				if (Singleton<MissionManager>.Instance.WinCondition == WinCondition.Protect && planeTarget != null && planeTarget.GetHealthPercentage() > 0f)
				{
					m_targetPosition = m_target.position;
				}
			}
		}
		else if (m_currentState == BehaviorType.Attacking)
		{
			m_currentSpeed = Mathf.SmoothStep(m_currentSpeed, m_speed_mod, deltaTime * m_acceleration);
			if (Singleton<MissionManager>.Instance.WinCondition == WinCondition.Protect && m_target != playerTransform)
			{
				if (rigidbody.position.z >= 100f)
				{
					Remove();
					return;
				}
				if (planeTarget != null && planeTarget.GetHealthPercentage() > 0f)
				{
					m_targetRotation = Quaternion.LookRotation(m_targetPosition - rigidbody.position);
				}
			}
			else
			{
				m_targetRotation = Quaternion.LookRotation(-desiredPosition);
			}
		}
		if (Quaternion.Dot(desiredRotation, m_targetRotation) < 1f - Mathf.Epsilon)
		{
			desiredRotation = Quaternion.Lerp(desiredRotation, m_targetRotation, deltaTime * m_maxTurnSpeed);
		}
		desiredPosition += desiredRotation * Vector3.forward * deltaTime * m_currentSpeed;
		transform.position = desiredPosition;
		missileMesh.Rotate(Vector3.forward * spinSpeed * deltaTime);
		float num;
		for (num = desiredRotation.eulerAngles.x; num < -180f; num += 360f)
		{
		}
		while (num > 180f)
		{
			num -= 360f;
		}
		num /= 180f;
		num += 0.5f;
		Singleton<AudioManager>.Instance.SetParameter(Status._engineAudioEvent, ParameterType.Angle, num, gameObject, canBePaused: true);
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (!m_active)
		{
			return;
		}
		if (collision.collider.CompareTag("Friend"))
		{
			FriendlyPlane component = collision.collider.GetComponent<FriendlyPlane>();
			if ((bool)component)
			{
				component.Hurt(Status.Spawner.Damage);
				Status.Hurt(float.MaxValue, hitByPlayer: false);
			}
			return;
		}
		PlayerStats componentInParent = collision.collider.GetComponentInParent<PlayerStats>();
		if ((bool)componentInParent)
		{
			componentInParent.Hurt(Status.Spawner.Damage);
			Status.Hurt(float.MaxValue, hitByPlayer: false);
			if (Status.Spawner.AmountOfEnemiesToKill == 0 && Singleton<GameManager>.Instance.State == GameManager.GameState.InGame)
			{
				Singleton<AudioManager>.Instance.Play(m_lastOneHitAudioEvent);
			}
		}
	}

	private void Remove()
	{
		Singleton<AudioManager>.Instance.Stop(m_flyLoopSoundEvent, gameObject);
		m_active = false;
		m_targetRotation = Quaternion.LookRotation(Vector3.down);
		for (int i = 0; i < transform.childCount; i++)
		{
			transform.GetChild(i).gameObject.SetActive(value: false);
		}
	}

	public override void OnKill(bool killedByPlayer = true)
	{
		m_currentState = BehaviorType.Falling;
		Singleton<AudioManager>.Instance.Stop(m_flyLoopSoundEvent, gameObject);
		m_active = false;
		m_targetRotation = Quaternion.LookRotation(Vector3.down);
		if (killedByPlayer)
		{
			Singleton<AudioManager>.Instance.PlayInLocation(killedSoundEvent, desiredPosition);
		}
		else
		{
			Singleton<AudioManager>.Instance.PlayInLocation(impactSoundEvent, desiredPosition);
		}
		for (int i = 0; i < transform.childCount; i++)
		{
			transform.GetChild(i).gameObject.SetActive(value: false);
		}
	}
}
public class PointerLaser : MonoBehaviour
{
	public UnityEngine.Color laserColor = new UnityEngine.Color(1f, 1f, 1f, 0.25f);

	public Transform crosshairTransform;

	[NonSerialized]
	public Vector3 pointerPosition = Vector3.zero;

	private LineRenderer lineRenderer;

	private void Awake()
	{
		lineRenderer = base.gameObject.GetComponent<LineRenderer>();
	}

	private void LateUpdate()
	{
		lineRenderer.SetPosition(0, base.transform.position);
		Vector3 position = crosshairTransform.position;
		lineRenderer.SetPosition(1, position);
		float t = ((!InputUtils.IsTrackedRemoteActive()) ? 0f : 1f);
		lineRenderer.SetColors(UnityEngine.Color.Lerp(UnityEngine.Color.clear, laserColor, t), UnityEngine.Color.clear);
	}
}
public class ScreenFader : MonoBehaviour
{
	[SerializeField]
	private Shader shader;

	[SerializeField]
	private float time = 2f;

	[SerializeField]
	private UnityEngine.Color color = new UnityEngine.Color(0f, 0f, 0f, 1f);

	private MeshRenderer sphereMeshRenderer;

	private YieldInstruction fadeInstruction = new WaitForEndOfFrame();

	private static string sortingLayer = "ScreenFader";

	private void Awake()
	{
		GameObject gameObject = GameObject.CreatePrimitive(PrimitiveType.Sphere);
		gameObject.name = "ScreenFaderSphere";
		gameObject.transform.parent = base.transform;
		gameObject.transform.localPosition = Vector3.zero;
		Collider component = gameObject.GetComponent<Collider>();
		if (component != null)
		{
			component.enabled = false;
		}
		sphereMeshRenderer = gameObject.GetComponent<MeshRenderer>();
		sphereMeshRenderer.sortingLayerName = sortingLayer;
		Material material = new Material(shader);
		sphereMeshRenderer.material = material;
		sphereMeshRenderer.material.color = color;
		sphereMeshRenderer.enabled = false;
	}

	private void OnDestroy()
	{
		if (sphereMeshRenderer.material != null)
		{
			UnityEngine.Object.Destroy(sphereMeshRenderer.material);
		}
	}

	private void OnEnabled()
	{
		FadeIn();
	}

	public IEnumerator FadeIn()
	{
		yield return Fade(fadeIn: true, time);
	}

	public IEnumerator FadeOut()
	{
		yield return Fade(fadeIn: false, time);
	}

	public IEnumerator FadeIn(float customTime)
	{
		yield return Fade(fadeIn: true, customTime);
	}

	public IEnumerator FadeOut(float customTime)
	{
		yield return Fade(fadeIn: false, customTime);
	}

	private IEnumerator Fade(bool fadeIn, float totalTime)
	{
		UnityEngine.Color color = sphereMeshRenderer.material.color;
		color.a = ((!fadeIn) ? 0f : 1f);
		sphereMeshRenderer.material.color = color;
		sphereMeshRenderer.enabled = true;
		if (totalTime > 0f)
		{
			float elapsedTime = 0f;
			float invTotalTime = 1f / totalTime;
			while (elapsedTime < totalTime)
			{
				yield return fadeInstruction;
				float deltaTime = Mathf.Max(0.05f, Time.unscaledDeltaTime);
				elapsedTime += deltaTime;
				if (fadeIn)
				{
					color.a = 1f - Mathf.Clamp01(elapsedTime * invTotalTime);
				}
				else
				{
					color.a = Mathf.Clamp01(elapsedTime * invTotalTime);
				}
				sphereMeshRenderer.material.color = color;
			}
		}
		if (fadeIn)
		{
			sphereMeshRenderer.enabled = false;
		}
	}
}
public class UICrosshair : MonoBehaviour
{
	[SerializeField]
	private Transform cameraTransform;

	[SerializeField]
	private Transform pointerTransform;

	[SerializeField]
	private float scale = 1f;

	private static readonly float distanceRatio = 0.01f;

	private int layerMask;

	private float scaleFactor;

	private Ray aimRay;

	public Ray AimRay => aimRay;

	private void Start()
	{
		layerMask = (1 << LayerMask.NameToLayer("UI")) + (1 << LayerMask.NameToLayer("CrosshairBlocker"));
		float x = base.transform.localScale.x;
		float magnitude = (cameraTransform.position - base.transform.position).magnitude;
		scaleFactor = base.transform.localScale.x / (cameraTransform.position - base.transform.position).magnitude;
	}

	private void Update()
	{
		RaycastHit hitInfo;
		if (InputUtils.IsTrackedRemoteActive())
		{
			Physics.Raycast(pointerTransform.position, pointerTransform.forward, out hitInfo, float.PositiveInfinity, layerMask);
		}
		else
		{
			Physics.Raycast(Singleton<CameraManager>.Instance.GetCamera().position, Singleton<CameraManager>.Instance.GetCamera().forward, out hitInfo, float.PositiveInfinity, layerMask);
		}
		if ((bool)hitInfo.collider)
		{
			base.transform.position = hitInfo.point;
		}
		else
		{
			base.transform.position = pointerTransform.position + 1000000f * pointerTransform.forward;
		}
		UpdateScale();
		aimRay.origin = pointerTransform.position;
		aimRay.direction = (base.transform.position - pointerTransform.position).normalized;
	}

	private void UpdateScale()
	{
		float num = (cameraTransform.position - base.transform.position).magnitude * distanceRatio * scale;
		Vector3 one = Vector3.one;
		one = base.transform.parent.InverseTransformVector(Vector3.one);
		base.transform.localScale = num * one;
	}
}
public class Cloud : MonoBehaviour
{
}
public class CloudPack : MonoBehaviour
{
	public Cloud[] cloudPrefabs;
}
public class CloudSpawner : MonoBehaviour
{
	[SerializeField]
	private CloudPack cloudPack;

	[SerializeField]
	private float cloudSpeed;

	[SerializeField]
	private float cloudMaxX;

	[SerializeField]
	private float cloudMaxZ;

	[SerializeField]
	private float cloudOffsetY;

	[SerializeField]
	private float minScale = 4f;

	[SerializeField]
	private float maxScale = 6f;

	[SerializeField]
	private uint numClouds;

	[SerializeField]
	private bool missionCloud = true;

	[SerializeField]
	private bool useDefaultCloudStats = true;

	private Vector3 posDelta = Vector3.zero;

	private List<Cloud> activeClouds = new List<Cloud>();

	private float maxRotation = 5f;

	private void Awake()
	{
		if (missionCloud && useDefaultCloudStats)
		{
			cloudSpeed = -50f;
			cloudMaxX = 10000f;
			cloudMaxZ = 10000f;
			cloudOffsetY = 100f;
			minScale = 9f;
			maxScale = 12f;
			numClouds = 50u;
		}
		if (!Singleton<GameManager>.Instance.ReduceQuality)
		{
			GenerateInitialClouds();
		}
		else
		{
			base.gameObject.SetActive(value: false);
		}
	}

	private void GenerateInitialClouds()
	{
		for (uint num = numClouds; num != 0; num--)
		{
			Cloud cloud = UnityEngine.Object.Instantiate(cloudPack.cloudPrefabs[UnityEngine.Random.Range(0, cloudPack.cloudPrefabs.Length)]);
			PlaceCloud(cloud, bPlaceAtStart: false);
			activeClouds.Add(cloud);
		}
	}

	private void PlaceCloud(Cloud cloud, bool bPlaceAtStart)
	{
		Vector3 position = base.transform.position;
		float num = UnityEngine.Random.Range(-1f, 1f);
		position.x = base.transform.position.x + num * cloudMaxX;
		position.y = base.transform.position.y + UnityEngine.Random.Range(0f - cloudOffsetY, cloudOffsetY);
		if (bPlaceAtStart)
		{
			position.z = base.transform.position.z + ((!missionCloud) ? (0f - cloudMaxZ) : cloudMaxZ);
		}
		else
		{
			position.z = base.transform.position.z + UnityEngine.Random.Range(0f - cloudMaxZ, cloudMaxZ);
		}
		cloud.transform.position = position;
		float num2 = UnityEngine.Random.Range(minScale, maxScale);
		cloud.transform.localScale = new Vector3(num2, num2, num2);
		cloud.transform.eulerAngles = new Vector3(0f, 0f, maxRotation * num);
	}

	private void Update()
	{
		posDelta.z = Time.deltaTime * cloudSpeed;
		foreach (Cloud activeCloud in activeClouds)
		{
			if ((missionCloud && activeCloud.transform.position.z + cloudMaxZ < base.transform.position.z) || (!missionCloud && activeCloud.transform.position.z - cloudMaxZ > base.transform.position.z))
			{
				PlaceCloud(activeCloud, bPlaceAtStart: true);
			}
			else
			{
				activeCloud.transform.position += posDelta;
			}
		}
	}
}
public class GameManager : Singleton<GameManager>
{
	public enum GameState
	{
		Frontend,
		Inactive,
		InGame,
		Pause,
		Tutorial,
		Ending
	}

	public enum EndMissionReason
	{
		Restart,
		Lost,
		Victory,
		Quit
	}

	public enum PauseOptions
	{
		PausedIcon,
		PausedText,
		Resume,
		RestartMission,
		QuitGame,
		PauseOptionsCount
	}

	public enum InputButtonState
	{
		NotPressed,
		MonitoringPress,
		LongPress,
		DoubleTap,
		ShortPress
	}

	private GameObject m_player;

	private GameState PrevState;

	private Turret m_Turret;

	private bool m_reduceQuality;

	private bool Paused;

	private List<string> PauseOptionTexts;

	public float EnemyTimeScale = 1f;

	private InputButtonState m_Button1State;

	private float m_Button1DownTime;

	private float m_Button1TimeSincePressed;

	private bool m_Button1RecentlyPressed;

	private bool m_Button1PushUsed;

	public GameState State { get; private set; }

	public EndMissionReason endMissionReason { get; private set; }

	public GameObject Player => m_player;

	public PlayerStats PlayerStatsData { get; private set; }

	public Turret Turret => m_Turret;

	public bool InHangar { get; set; }

	public bool InGame { get; set; }

	public bool ReduceQuality => m_reduceQuality;

	public bool IsPaused => State == GameState.Tutorial || State == GameState.Pause;

	public InputButtonState Button1State => m_Button1State;

	public event Action<EndMissionReason> OnEndMission;

	public event Action<bool> OnStartMission;

	protected override void Awake()
	{
		isPersistant = true;
		State = GameState.Frontend;
		base.Awake();
	}

	public void Init()
	{
		Singleton<Profile>.Instance.Load();
		m_reduceQuality = PhoneIdentifier.GetPhoneID(SystemInfo.deviceModel) == PhoneID.SamsungS7;
	}

	public void OnLevelLoaded()
	{
		m_player = GameObject.Find("MainPlane");
		PlayerStatsData = m_player.GetComponent<PlayerStats>();
		m_Turret = UnityEngine.Object.FindObjectOfType<Turret>();
		m_Turret.SetupTurret(Singleton<Profile>.Instance.Upgrades.CurrentGun);
		Singleton<InGameUIManager>.Instance.SetupPauseMenu(m_Turret);
		Singleton<Profile>.Instance.Progress.OnLevelStart();
		StartCoroutine(LoadResourcesCoroutine());
	}

	private IEnumerator LoadResourcesCoroutine()
	{
		MissionSettings mission = UnityEngine.Object.Instantiate(Singleton<MissionManager>.Instance.CurrentMissionSettings);
		yield return StartCoroutine(mission.LoadResources());
		Singleton<EffectsPool>.Instance.InitEffects();
		NGUICockpit.CockpitGUIRenderSetting guiStats = new NGUICockpit.CockpitGUIRenderSetting();
		if (Singleton<MissionManager>.Instance.TimeLimit != TimeLimit.Survival)
		{
			KillPlaneMap[] enemiesInMission = Singleton<MissionManager>.Instance.EnemiesInMission;
			string planeTypeIcon = GetPlaneTypeIcon(enemiesInMission[0].m_type);
			guiStats.InitPlaneType(0, enemiesInMission[0].m_count, planeTypeIcon);
			if (enemiesInMission.Length > 1)
			{
				planeTypeIcon = GetPlaneTypeIcon(enemiesInMission[1].m_type);
				guiStats.InitPlaneType(1, enemiesInMission[1].m_count, planeTypeIcon);
			}
			else if (Singleton<MissionManager>.Instance.WinCondition != 0)
			{
				guiStats.InitPlaneType(1, Singleton<MissionManager>.Instance.FriendsToKill, "bsui-ig-bomber-icon");
			}
		}
		if (Singleton<MissionManager>.Instance.RemainingTime > 0f)
		{
			guiStats.timeLeft = Mathf.FloorToInt(Singleton<MissionManager>.Instance.RemainingTime);
		}
		Singleton<InGameUIManager>.Instance.InitialiseCockpit(guiStats, m_Turret);
		if (Singleton<MissionManager>.Instance.DoingBonusMission)
		{
			m_Turret.DeactivateGuns(forceLower: true);
			Singleton<InGameUIManager>.Instance.FadeMenu(InGameMenuType.BonusIntro, 1f, fadingIn: true);
			while (!InputUtils.GetFire1ButtonDown() || Singleton<GameManager>.Instance.Button1State != 0)
			{
				yield return null;
			}
			Singleton<InGameUIManager>.Instance.FadeMenu(InGameMenuType.BonusIntro, 1f, fadingIn: false);
			Singleton<AudioManager>.Instance.Play(AudioEvent.EvtMusic_V2_bonus_mission);
			Singleton<AudioManager>.Instance.Play(AudioEvent.EvtPlayerVoxChatter_V2_Start);
			Singleton<AudioManager>.Instance.Play(AudioEvent.EvtMissileIncoming_Warning);
		}
		this.OnStartMission(obj: false);
		EnemyTimeScale = 1f;
		if (Singleton<MissionManager>.Instance.Mission != 0)
		{
			Singleton<TutorialManager>.Instance.enabled = false;
		}
		State = GameState.InGame;
	}

	private string GetPlaneTypeIcon(PlaneType type)
	{
		string result = "bsui-ig-fighter-icon";
		switch (type)
		{
		case PlaneType.Avoider1:
			result = "bsui-ig-me162-icon";
			break;
		case PlaneType.Avoider2:
			result = "bsui-ig-focke-icon";
			break;
		case PlaneType.Jinker1:
			result = "bsui-ig-fw190-icon";
			break;
		case PlaneType.Jinker2:
			result = "bsui-ig-dornier-icon";
			break;
		case PlaneType.StraightFlyer1:
			result = "bsui-ig-bf109g-icon";
			break;
		case PlaneType.StraightFlyer2:
			result = "bsui-ig-messr-icon";
			break;
		case PlaneType.RocketMe262:
			result = "bsui-ig-me262b-icon";
			break;
		case PlaneType.Armoured262:
			result = "bsui-ig-me262a-icon";
			break;
		}
		return result;
	}

	public void OnLevelExit()
	{
		State = GameState.Frontend;
	}

	public void OnShowEnding()
	{
		State = GameState.Ending;
	}

	public void Victory()
	{
		endMissionReason = EndMissionReason.Victory;
		EndMission();
		if (Singleton<MissionManager>.Instance.Mission != 0)
		{
			ShowScoreScreen();
		}
	}

	public void ShowScoreScreen()
	{
		Singleton<InGameUIManager>.Instance.FadeMenu(InGameMenuType.Score, 1f, fadingIn: true);
	}

	public void Death()
	{
		endMissionReason = EndMissionReason.Lost;
		EndMission();
		ShowScoreScreen();
	}

	public void RestartMission()
	{
		endMissionReason = EndMissionReason.Quit;
		EndMission();
		Singleton<LoadingScreen>.Instance.LoadGame();
	}

	public void StartMission()
	{
		Singleton<MissionManager>.Instance.RestartMission();
		Singleton<PlayerScore>.Instance.ResetScore();
		this.OnStartMission(obj: true);
		EnemyTimeScale = 1f;
		if (Singleton<MissionManager>.Instance.Mission != 0)
		{
			Singleton<TutorialManager>.Instance.enabled = false;
		}
		Singleton<Profile>.Instance.Progress.OnLevelStart();
		State = GameState.InGame;
	}

	private void EndMission()
	{
		bool doingBonusMission = Singleton<MissionManager>.Instance.DoingBonusMission;
		State = GameState.Inactive;
		if (doingBonusMission)
		{
			Singleton<PlayerScore>.Instance.OnBonusEnd();
		}
		else if (endMissionReason == EndMissionReason.Victory || endMissionReason == EndMissionReason.Lost)
		{
			Singleton<PlayerScore>.Instance.OnMissionEnd(endMissionReason);
		}
		this.OnEndMission(endMissionReason);
		Singleton<TutorialManager>.Instance.enabled = true;
		if (!doingBonusMission && endMissionReason == EndMissionReason.Victory)
		{
			Singleton<Profile>.Instance.Progress.UpdateProgress();
		}
		if (endMissionReason != EndMissionReason.Quit)
		{
			NGUIScoreScreen.ScoreRenderSetting score = null;
			switch (endMissionReason)
			{
			case EndMissionReason.Lost:
			case EndMissionReason.Victory:
				Singleton<PlayerScore>.Instance.MissionComplete(out score);
				break;
			}
			if (score != null)
			{
				score.wasVictory = endMissionReason == EndMissionReason.Victory;
				NGUIScoreScreen.CurrentScoreSettings = score;
			}
			Singleton<Profile>.Instance.Save();
			if (m_Turret != null)
			{
				m_Turret.DeactivateGuns(forceLower: false);
				m_Turret.ShowGunReticule(visible: false);
			}
		}
		Singleton<AudioManager>.Instance.Stop(AudioEvent.EvtMissileIncoming_Warning);
		if (doingBonusMission)
		{
			Singleton<AudioManager>.Instance.Stop(AudioEvent.EvtMusic_V2_bonus_mission);
			Singleton<MissionManager>.Instance.FinishBonusMission();
		}
	}

	private void Update()
	{
		m_Button1State = InputButtonState.MonitoringPress;
		KeyCode key = KeyCode.Escape;
		if (Input.GetKeyDown(key))
		{
			m_Button1DownTime = 0f;
			if (m_Button1RecentlyPressed && m_Button1TimeSincePressed < 0.25f)
			{
				m_Button1State = InputButtonState.DoubleTap;
				m_Button1RecentlyPressed = false;
				m_Button1PushUsed = true;
			}
		}
		else if (m_Button1State != InputButtonState.LongPress && Input.GetKey(key))
		{
			m_Button1DownTime += Time.unscaledDeltaTime;
			if (m_Button1DownTime > 0.75f)
			{
				m_Button1State = InputButtonState.LongPress;
				m_Button1PushUsed = true;
				m_Button1DownTime = 0f;
			}
		}
		else if (Input.GetKeyUp(key))
		{
			m_Button1DownTime = 0f;
			if (!m_Button1PushUsed)
			{
				m_Button1RecentlyPressed = true;
			}
			m_Button1TimeSincePressed = 0f;
			m_Button1PushUsed = false;
		}
		else if (m_Button1RecentlyPressed)
		{
			m_Button1TimeSincePressed += Time.unscaledDeltaTime;
			if (m_Button1TimeSincePressed >= 0.25f)
			{
				m_Button1State = InputButtonState.ShortPress;
				m_Button1RecentlyPressed = false;
			}
		}
		else
		{
			m_Button1State = InputButtonState.NotPressed;
		}
		if (m_Button1State == InputButtonState.DoubleTap)
		{
			Recenter();
		}
		else if (m_Button1State == InputButtonState.ShortPress && !Singleton<LoadingScreen>.TryInstance() && SceneManager.GetActiveScene().buildIndex == 7)
		{
			OVRManager.PlatformUIConfirmQuit();
		}
		if (State != 0 && (bool)m_Turret)
		{
			Singleton<InGameUIManager>.Instance.UpdateCockpitUI();
		}
		if (!Singleton<LoadingScreen>.TryInstance() && (m_Button1State == InputButtonState.ShortPress || InputUtils.GetPauseButtonDown()) && (State == GameState.Pause || State == GameState.InGame))
		{
			TogglePause();
		}
	}

	public void Recenter()
	{
		InputTracking.Recenter();
		m_Turret.RecenterYawFromCamera();
	}

	public void PauseIfInGame()
	{
		if (State == GameState.InGame && !Paused)
		{
			TogglePause();
		}
	}

	private void TogglePause()
	{
		if (State == GameState.Inactive || !Singleton<InGameUIManager>.Instance.CanShowPauseScreen)
		{
			return;
		}
		Paused = !Paused;
		if (Paused)
		{
			State = GameState.Pause;
			Singleton<CameraManager>.Instance.cameraSomething.enabled = true;
			Time.timeScale = 0f;
		}
		else
		{
			State = GameState.InGame;
			Singleton<CameraManager>.Instance.cameraSomething.enabled = false;
			Time.timeScale = 1f;
		}
		if (InGame)
		{
			Singleton<AudioManager>.Instance.Pause(Paused);
			if ((bool)m_Turret)
			{
				m_Turret.ShowGunReticule(!Paused);
			}
		}
		Singleton<InGameUIManager>.Instance.FadeMenu(InGameMenuType.Pause, 1f, Paused);
	}

	public void ToggleTutorial(bool pause)
	{
		if (pause)
		{
			PrevState = State;
			State = GameState.Tutorial;
			Time.timeScale = 0f;
		}
		else
		{
			State = PrevState;
			Time.timeScale = 1f;
		}
		if (InGame)
		{
			Singleton<AudioManager>.Instance.Pause(pause);
		}
	}

	public void PerformPauseMenuSelection(PauseOptions option)
	{
		PerformPauseMenuSelection((int)option);
	}

	private void PerformPauseMenuSelection(int option)
	{
		if (option != -1)
		{
			TogglePause();
			switch ((PauseOptions)option)
			{
			case PauseOptions.QuitGame:
				Singleton<AudioManager>.Instance.PlayOneShot(AudioEvent.EvtGUI_IN_NME_Wave_Start);
				QuitGame();
				break;
			case PauseOptions.RestartMission:
				Singleton<AudioManager>.Instance.PlayOneShot(AudioEvent.EvtGUI_FE_StartGame);
				RestartMission();
				break;
			}
		}
	}

	public void QuitGame()
	{
		endMissionReason = EndMissionReason.Quit;
		EndMission();
		Singleton<LoadingScreen>.Instance.LoadMenu(LoadingScreen.ComingFrom.Game);
	}

	public void StartNextMission()
	{
		Singleton<MissionManager>.Instance.Mission = Singleton<MissionManager>.Instance.Mission + 1;
		endMissionReason = EndMissionReason.Quit;
		EndMission();
		Singleton<LoadingScreen>.Instance.LoadGame();
	}

	public void StartBonusMission()
	{
		Singleton<MissionManager>.Instance.SetupBonusMission();
		Singleton<LoadingScreen>.Instance.LoadGame();
	}

	public void ShowEnding()
	{
		Singleton<LoadingScreen>.Instance.LoadEnding(Singleton<Profile>.Instance.Progress.HasMaxStars());
	}

	public void SetVrPerformanceValues(int cpuLevel = 1, int gpuLevel = 2, bool vSync60 = true)
	{
	}
}
public class GroundSlider : Singleton<GroundSlider>
{
	[SerializeField]
	private GameObject[] m_planes = new GameObject[2];

	private bool m_currentPlane = true;

	private bool m_isInitiallized;

	private float m_size;

	[SerializeField]
	private float m_speed;

	public float Speed => m_speed;

	private void Initialize()
	{
		if (base.transform.childCount > 0)
		{
			m_planes[0] = base.transform.GetChild(0).gameObject;
			Mesh mesh = m_planes[0].GetComponent<MeshFilter>().mesh;
			m_planes[1] = base.transform.GetChild(1).gameObject;
			m_size = mesh.bounds.size.z;
			m_planes[0].transform.position += Vector3.forward * m_size;
			m_isInitiallized = true;
		}
	}

	private void Update()
	{
		if (!m_isInitiallized)
		{
			Initialize();
			return;
		}
		if (Application.loadedLevel == 7)
		{
			if (m_planes[(!m_currentPlane) ? 1u : 0u].transform.position.z > 20000f)
			{
				Swap();
			}
		}
		else if (m_planes[(!m_currentPlane) ? 1u : 0u].transform.position.z < 0f)
		{
			Swap();
		}
		m_planes[0].transform.position -= Vector3.forward * m_speed * Time.deltaTime;
		m_planes[1].transform.position -= Vector3.forward * m_speed * Time.deltaTime;
	}

	private void Swap()
	{
		m_currentPlane = !m_currentPlane;
		if (Application.loadedLevel == 7)
		{
			m_planes[m_currentPlane ? 1 : 0].transform.SetZPosition(0f - m_size);
		}
		else
		{
			m_planes[(!m_currentPlane) ? 1u : 0u].transform.position += Vector3.forward * m_size * 2f;
		}
	}
}
[Serializable]
public struct MissionTimeChatterAudioLevel
{
	public float RemainingTime;

	public AudioEvent Event;
}
public struct MissionPreset
{
	public WinCondition m_winCondition;

	public TimeLimit m_timeLimit;

	public KillPlaneMap[] m_enemiesToKill;

	public float m_maxTime;

	public int m_targetScoreOneStar;

	public int m_targetScoreTwoStar;

	public int m_targetScoreThreeStar;

	public Vector3[] m_friends;

	public FriendlyPlaneTypes m_friendlyPlaneType;

	public int m_friendlyPlanesToKill;

	public float m_friendlyPlanesHealth;

	public List<MissionTimeChatterAudioLevel> m_MissionTimeChatterAudioLevels;

	public float m_currencyMultiplier;

	public float m_checkPointTimeBonus;
}
public class MissionManager : Singleton<MissionManager>
{
	private MissionPreset m_config;

	private float m_currentTime;

	private KillPlaneMap[] m_enemiesKilled;

	private int m_friendsKilled;

	private int m_currentMission = 1;

	private int m_currentBonusMission = 1;

	private List<MissionTimeChatterAudioLevel> m_MissionTimeChatterAudioLevels;

	[SerializeField]
	private MissionSettings[] m_Missions;

	[SerializeField]
	private MissionSettings[] m_bonusMissionSettings;

	[SerializeField]
	private GameObject m_friendlyPlanePrefab;

	private bool m_JustCompletedBonusMission;

	private bool m_doingBonusMission;

	private float m_currentMaxTime;

	private bool m_firstTimeComplete;

	public List<FriendlyPlane> Friends;

	public bool DoBonus = true;

	public WinCondition WinCondition => m_config.m_winCondition;

	public bool JustCompletedBonusMission
	{
		get
		{
			return m_JustCompletedBonusMission;
		}
		set
		{
			m_JustCompletedBonusMission = value;
		}
	}

	public bool DoingBonusMission => m_doingBonusMission;

	public int Mission
	{
		get
		{
			return m_currentMission;
		}
		set
		{
			m_currentMission = value;
			m_doingBonusMission = false;
			m_firstTimeComplete = false;
		}
	}

	public int BonusMission
	{
		get
		{
			return m_currentBonusMission;
		}
		set
		{
			m_currentBonusMission = value;
			m_doingBonusMission = true;
			m_firstTimeComplete = false;
		}
	}

	public bool CompletedMissionForFirstTime
	{
		set
		{
			m_firstTimeComplete = value;
		}
	}

	public MissionSettings CurrentMissionSettings
	{
		get
		{
			if (m_doingBonusMission)
			{
				return AvailableBonusMissions[BonusMission];
			}
			return AvailableMissions[Mission];
		}
	}

	public bool HasTimeLimit => m_config.m_timeLimit == TimeLimit.Yes || m_config.m_timeLimit == TimeLimit.Checkpoint;

	public TimeLimit TimeLimit => m_config.m_timeLimit;

	public float CheckpointTimeBonus => m_config.m_checkPointTimeBonus;

	public float RemainingTime
	{
		get
		{
			if (m_config.m_timeLimit != 0)
			{
				return Mathf.Max(0f, m_currentMaxTime - m_currentTime);
			}
			return 0f;
		}
	}

	public int TargetScoreOneStar => m_config.m_targetScoreOneStar;

	public int TargetScoreTwoStar => m_config.m_targetScoreTwoStar;

	public int TargetScoreThreeStar => m_config.m_targetScoreThreeStar;

	public float CurrencyMultiplier => m_config.m_currencyMultiplier;

	public MissionSettings[] AvailableMissions => m_Missions;

	public MissionSettings[] AvailableBonusMissions => m_bonusMissionSettings;

	public KillPlaneMap[] EnemiesKilled => m_enemiesKilled;

	public KillPlaneMap[] EnemiesInMission => m_config.m_enemiesToKill;

	public int FriendsToKill => m_config.m_friendlyPlanesToKill;

	public int FriendsKilled => m_friendsKilled;

	private void Start()
	{
		m_currentMission = Singleton<Profile>.Instance.Progress.LastPlayedLevel;
	}

	public void AddTime(float time)
	{
		m_currentMaxTime += time;
	}

	public void ReloadAvailableMissionsTexts()
	{
		if (m_Missions != null)
		{
			MissionSettings[] missions = m_Missions;
			foreach (MissionSettings missionSettings in missions)
			{
				missionSettings.ReloadStrings();
			}
		}
	}

	public void SetupMission(MissionPreset preset)
	{
		m_config = preset;
		m_MissionTimeChatterAudioLevels = preset.m_MissionTimeChatterAudioLevels;
		m_enemiesKilled = new KillPlaneMap[m_config.m_enemiesToKill.Length];
		for (int i = 0; i < m_config.m_enemiesToKill.Length; i++)
		{
			m_enemiesKilled[i].m_type = m_config.m_enemiesToKill[i].m_type;
		}
		RestartMission();
	}

	public void OnKill(PlaneType type)
	{
		if (m_config.m_timeLimit == TimeLimit.Survival)
		{
			return;
		}
		bool flag = true;
		if (m_enemiesKilled[0].m_type == PlaneType.Any)
		{
			m_enemiesKilled[0].m_count++;
			if (m_enemiesKilled[0].m_count < m_config.m_enemiesToKill[0].m_count)
			{
				flag = false;
			}
		}
		else
		{
			for (int i = 0; i < m_enemiesKilled.Length; i++)
			{
				if (m_enemiesKilled[i].m_type == type && m_enemiesKilled[i].m_count < m_config.m_enemiesToKill[i].m_count)
				{
					m_enemiesKilled[i].m_count++;
				}
				if (m_enemiesKilled[i].m_count < m_config.m_enemiesToKill[i].m_count)
				{
					flag = false;
				}
			}
		}
		if (flag)
		{
			Singleton<GameManager>.Instance.Victory();
		}
	}

	private void Update()
	{
		if (!Singleton<GameManager>.Instance.InGame || Singleton<LoadingScreen>.TryInstance())
		{
			return;
		}
		if (Singleton<GameManager>.Instance.State == GameManager.GameState.InGame)
		{
			float remainingTime = RemainingTime;
			m_currentTime += Time.deltaTime;
			float remainingTime2 = RemainingTime;
			if (m_MissionTimeChatterAudioLevels != null)
			{
				for (int i = 0; i < m_MissionTimeChatterAudioLevels.Count; i++)
				{
					if (remainingTime > m_MissionTimeChatterAudioLevels[i].RemainingTime && remainingTime2 <= m_MissionTimeChatterAudioLevels[i].RemainingTime)
					{
						Singleton<AudioManager>.Instance.Play(m_MissionTimeChatterAudioLevels[i].Event);
					}
				}
			}
			if ((m_config.m_timeLimit == TimeLimit.Yes || m_config.m_timeLimit == TimeLimit.Checkpoint) && m_currentTime > m_currentMaxTime)
			{
				Singleton<GameManager>.Instance.Death();
			}
			else if (m_config.m_timeLimit == TimeLimit.Survival && m_currentTime > m_config.m_maxTime)
			{
				Singleton<GameManager>.Instance.Victory();
			}
		}
		if (m_config.m_winCondition != WinCondition.Protect)
		{
			return;
		}
		for (int j = 0; j < Friends.Count; j++)
		{
			if (Friends[j] != null)
			{
				Friends[j].Tick();
			}
		}
	}

	public void RestartMission()
	{
		m_currentTime = 0f;
		m_currentMaxTime = m_config.m_maxTime;
		m_friendsKilled = 0;
		for (int i = 0; i < m_enemiesKilled.Length; i++)
		{
			m_enemiesKilled[i].m_count = 0;
		}
		if (Friends != null)
		{
			for (int j = 0; j < Friends.Count; j++)
			{
				if (Friends[j] != null && Friends[j].gameObject != null)
				{
					UnityEngine.Object.Destroy(Friends[j].gameObject);
				}
			}
			Friends.Clear();
		}
		if (m_config.m_winCondition == WinCondition.Protect || m_config.m_winCondition == WinCondition.DontShoot)
		{
			GameObject gameObject = null;
			Friends = new List<FriendlyPlane>(m_config.m_friends.Length);
			for (int k = 0; k < m_config.m_friends.Length; k++)
			{
				gameObject = UnityEngine.Object.Instantiate(m_friendlyPlanePrefab, m_config.m_friends[k], Quaternion.identity);
				Friends.Add(gameObject.GetComponent<FriendlyPlane>());
				Friends[k].SetHealth(m_config.m_friendlyPlanesHealth);
			}
		}
	}

	public float GetTimeBonus()
	{
		return Mathf.Max(0f, m_currentMaxTime - m_currentTime);
	}

	public void FriendDied(FriendlyPlane friend)
	{
		m_friendsKilled++;
		if (m_friendsKilled == m_config.m_friendlyPlanesToKill)
		{
			Singleton<GameManager>.Instance.Death();
		}
	}

	public void RemoveFriend(FriendlyPlane friend)
	{
		Friends.Remove(friend);
	}

	public bool ShallWeBonus()
	{
		if (!m_firstTimeComplete)
		{
			return false;
		}
		for (int i = 0; i < Singleton<Profile>.Instance.m_missionIndexsWithBonuses.Length; i++)
		{
			if (Mission == Singleton<Profile>.Instance.m_missionIndexsWithBonuses[i])
			{
				return true;
			}
		}
		return false;
	}

	public bool HaveCompletedAllMissionsOnce()
	{
		for (int i = 0; i < 30; i++)
		{
			if (Singleton<Profile>.Instance.Progress.GetStars(i) == 0)
			{
				return false;
			}
		}
		return true;
	}

	public void SetupBonusMission()
	{
		BonusMission = Math.Min(3, Singleton<Profile>.Instance.Progress.BonusMissionsCompleted);
		m_JustCompletedBonusMission = false;
	}

	public void FinishBonusMission()
	{
		m_doingBonusMission = false;
		m_firstTimeComplete = false;
		m_JustCompletedBonusMission = true;
	}
}
public enum WinCondition
{
	Kills,
	Protect,
	DontShoot
}
public enum TimeLimit
{
	No,
	Yes,
	Checkpoint,
	Survival
}
public enum FriendlyPlaneTypes
{
	Lancaster,
	BF109,
	Focke
}
[Serializable]
public struct KillPlaneMap
{
	public PlaneType m_type;

	public int m_count;
}
[Serializable]
public class MissionSettings : ScriptableObject
{
	public enum TimeOfDay
	{
		Dawn,
		Day,
		Twilight,
		Night
	}

	public delegate void UpdateObject(GameObject obj);

	[SerializeField]
	private CloudSpawner m_cloudSpawner;

	[SerializeField]
	public List<SpawnerConfig> m_spawners = new List<SpawnerConfig>();

	[SerializeField]
	private TimeLimit m_timeLimit;

	[SerializeField]
	private float m_time;

	[SerializeField]
	private float m_checkPointTimeBonus;

	[SerializeField]
	private KillPlaneMap[] m_planesToKill;

	[SerializeField]
	private WinCondition m_winCondition;

	[SerializeField]
	private Vector3[] m_friendlyPlanes;

	[SerializeField]
	private FriendlyPlaneTypes m_friendlyPlanesType;

	[SerializeField]
	private int m_friendlyPlanesToKill;

	[SerializeField]
	private float m_friendlyPlanesHealth;

	[SerializeField]
	private int m_maxPlanesAtATime;

	[SerializeField]
	private int m_requiredStars;

	[SerializeField]
	private int m_targetScoreOneStar;

	[SerializeField]
	private int m_targetScoreTwoStar;

	[SerializeField]
	private int m_targetScoreThreeStar;

	[SerializeField]
	private float m_currencyMultiplier = 1f;

	[SerializeField]
	private TimeOfDay m_timeOfDay;

	[SerializeField]
	private string m_skybox;

	[SerializeField]
	private string m_ground;

	[SerializeField]
	private string m_lighting;

	[SerializeField]
	private string m_NameStringID;

	private string m_description;

	[SerializeField]
	private string m_DescStringID;

	private string m_name;

	[SerializeField]
	private List<MissionTimeChatterAudioLevel> m_MissionTimeChatterAudioLevels = new List<MissionTimeChatterAudioLevel>();

	[SerializeField]
	private PowerUpWeights m_powerUpWeights;

	public bool HasTimeLimit => m_timeLimit == TimeLimit.Yes || m_timeLimit == TimeLimit.Checkpoint;

	public TimeLimit TimeLimitType => m_timeLimit;

	public float CheckpointTimeBonus => m_checkPointTimeBonus;

	public KillPlaneMap[] PlanesToKill => m_planesToKill;

	public float Time => m_time;

	public WinCondition WinCondition => m_winCondition;

	public FriendlyPlaneTypes FriendlyPlaneType => m_friendlyPlanesType;

	public int FriendlyPlanesToProtect => m_friendlyPlanesToKill;

	public int RequiredStars => m_requiredStars;

	public int TargetScoreOneStar => m_targetScoreOneStar;

	public int TargetScoreTwoStar => m_targetScoreTwoStar;

	public int TargetScoreThreeStar => m_targetScoreThreeStar;

	public string Ground => m_ground;

	public TimeOfDay GetWeatherType()
	{
		return m_timeOfDay;
	}

	public string GetWeatherName()
	{
		return m_timeOfDay switch
		{
			TimeOfDay.Dawn => "menu_proj_mission_weather_dawn".Translate(), 
			TimeOfDay.Day => "menu_proj_mission_weather_day".Translate(), 
			TimeOfDay.Twilight => "menu_proj_mission_weather_twilight".Translate(), 
			_ => "UNKNOWN", 
		};
	}

	public string GetDescId()
	{
		return m_DescStringID;
	}

	public string GetNameId()
	{
		return m_NameStringID;
	}

	public string GetDescription()
	{
		return m_description;
	}

	public string GetName()
	{
		return m_name;
	}

	private void OnEnable()
	{
		ReloadStrings();
	}

	public void ReloadStrings()
	{
		m_description = m_DescStringID.Translate();
		m_name = m_NameStringID.Translate();
	}

	public bool LoadObject(string objName, UpdateObject update)
	{
		if (!string.IsNullOrEmpty(objName))
		{
			GameObject gameObject = Resources.Load(objName) as GameObject;
			if (gameObject != null)
			{
				update(gameObject);
				return true;
			}
		}
		return false;
	}

	public void UpdateDefault(GameObject obj)
	{
		obj = UnityEngine.Object.Instantiate(obj);
	}

	public void UpdateSkybox(GameObject obj)
	{
		obj = UnityEngine.Object.Instantiate(obj, Vector3.zero, Quaternion.identity);
	}

	public void UpdateGround(GameObject obj)
	{
		Transform transform = GameObject.Find("Ground").transform;
		obj = UnityEngine.Object.Instantiate(obj, transform.position, Quaternion.identity);
		obj.transform.parent = transform;
		obj = UnityEngine.Object.Instantiate(obj, transform.position, Quaternion.identity);
		obj.transform.parent = transform;
	}

	public IEnumerator LoadResources()
	{
		LoadObject("Environment/GroundPlanes/" + m_ground, UpdateGround);
		LoadObject("Environment/Lighting/" + m_lighting, UpdateDefault);
		List<EnemySpawner> spawners = new List<EnemySpawner>();
		for (int i = 0; i < m_spawners.Count; i++)
		{
			EnemySpawner enemySpawner = ScriptableObject.CreateInstance<EnemySpawner>();
			enemySpawner.Initialise(m_spawners[i]);
			spawners.Add(enemySpawner);
		}
		Singleton<EnemyBehaviorManager>.Instance.SetupEnemySpawers(spawners, m_maxPlanesAtATime);
		if (m_timeLimit == TimeLimit.Survival)
		{
			m_planesToKill = new KillPlaneMap[0];
		}
		MissionPreset mission = new MissionPreset
		{
			m_maxTime = m_time,
			m_enemiesToKill = m_planesToKill,
			m_winCondition = m_winCondition,
			m_timeLimit = m_timeLimit,
			m_targetScoreOneStar = m_targetScoreOneStar,
			m_targetScoreTwoStar = m_targetScoreTwoStar,
			m_targetScoreThreeStar = m_targetScoreThreeStar,
			m_currencyMultiplier = m_currencyMultiplier,
			m_MissionTimeChatterAudioLevels = m_MissionTimeChatterAudioLevels,
			m_friends = m_friendlyPlanes,
			m_friendlyPlaneType = m_friendlyPlanesType,
			m_friendlyPlanesToKill = m_friendlyPlanesToKill,
			m_friendlyPlanesHealth = m_friendlyPlanesHealth,
			m_checkPointTimeBonus = m_checkPointTimeBonus
		};
		Singleton<MissionManager>.Instance.SetupMission(mission);
		Singleton<PowerUpManager>.Instance.SetWeights(m_powerUpWeights);
		if (m_cloudSpawner != null)
		{
			UnityEngine.Object.Instantiate(m_cloudSpawner);
		}
		yield return null;
	}

	public void LoadSkybox()
	{
		LoadObject("Environment/Skyboxes/" + m_skybox, UpdateSkybox);
	}

	public void SetNames()
	{
		for (int i = 0; i < m_spawners.Count; i++)
		{
			SpawnerConfig value = m_spawners[i];
			value.m_planeName = value.m_spawner.name;
			m_spawners[i] = value;
		}
		if (m_timeLimit == TimeLimit.Survival)
		{
			m_planesToKill = null;
		}
	}
}
public class MoveWithGroundSlider : MonoBehaviour
{
	private void Update()
	{
		base.transform.position += -Vector3.forward * Singleton<GroundSlider>.Instance.Speed * Time.deltaTime;
		ParticleSystem component = GetComponent<ParticleSystem>();
		if ((bool)component)
		{
			ParticleSystem.Particle[] array = new ParticleSystem.Particle[component.particleCount];
			int particles = component.GetParticles(array);
			for (int i = 0; i < particles; i++)
			{
				array[i].position += -Vector3.forward * Singleton<GroundSlider>.Instance.Speed * Time.deltaTime;
			}
			component.SetParticles(array, particles);
		}
	}
}
public enum KillInfo
{
	Sniper,
	HotGun,
	SnapShot,
	QuickKill,
	MultiKill,
	NoReply,
	Overkill,
	SlowmoKill,
	BorrowedTime,
	InvulnerableKill,
	RevengeKill,
	SaviourKill
}
public class PlayerScore : Singleton<PlayerScore>
{
	[SerializeField]
	private int m_distanceBonus = 50;

	[SerializeField]
	private float m_minDistance = 150f;

	private float m_minDistanceSqr;

	[SerializeField]
	private int m_overheatBonus = 50;

	[SerializeField]
	private int m_snapShotBonus = 50;

	[SerializeField]
	private int m_slowmoBonus = 50;

	[SerializeField]
	private int m_invulnerableBonus = 20;

	[SerializeField]
	private int m_quickKillBonus = 50;

	[SerializeField]
	private float m_quickKillMaxTime = 0.3f;

	[SerializeField]
	private int m_noReplyBonus = 50;

	[SerializeField]
	private int m_overkillBonus = 50;

	[SerializeField]
	private int m_borrowedTimeBonus = 50;

	[SerializeField]
	private float m_borrowedTimeMaxTime = 10f;

	[SerializeField]
	private int m_revengeBonus = 50;

	[SerializeField]
	private float m_revengeMinDamage = 100f;

	[SerializeField]
	private int m_saviourBonus = 50;

	[SerializeField]
	private float m_saviourMinDamage = 100f;

	[SerializeField]
	private float m_multiKillMinTime = 2f;

	private float m_timeAfterTurn;

	private float m_timeSinceLastKill;

	private int m_multikillCounter;

	private int m_maxMultikill;

	private int m_totalKills;

	private int m_baseScore;

	private int m_killScore;

	private int m_totalScore;

	private int m_timeBonus;

	private int m_protectBonus;

	private int m_moneyEarned;

	private int m_bulletsFired;

	private int m_bulletsHit;

	private int m_stars;

	private float m_ScoreAudioCooldownTimer;

	[SerializeField]
	private float m_ScoreAudioCooldownDuration = 5f;

	private bool[] m_killInfo = new bool[Enum.GetValues(typeof(KillInfo)).Length];

	private int[] m_totalMedals = new int[Enum.GetValues(typeof(KillInfo)).Length];

	private Queue<Quaternion> m_cameraRotations = new Queue<Quaternion>(10);

	private Quaternion m_oldCameraRotation;

	private Quaternion m_newCameraRotation;

	private Transform camTrans;

	public int[] TotalMedals => m_totalMedals;

	public int Stars => m_stars;

	public int Score => m_totalScore;

	public int CurrentMissionScore => m_killScore;

	protected override void Awake()
	{
		base.Awake();
		camTrans = Singleton<CameraManager>.Instance.GetCamera();
		m_minDistanceSqr = m_minDistance * m_minDistance;
	}

	private void Start()
	{
		for (int i = 0; i < m_killInfo.Length; i++)
		{
			m_killInfo[i] = false;
			m_totalMedals[i] = 0;
		}
	}

	private void Update()
	{
		if (Singleton<GameManager>.Instance.State != GameManager.GameState.InGame)
		{
			return;
		}
		if (m_cameraRotations.Count < 10)
		{
			m_cameraRotations.Enqueue(camTrans.rotation);
		}
		else
		{
			m_timeAfterTurn -= Time.deltaTime;
			m_newCameraRotation = camTrans.rotation;
			m_oldCameraRotation = m_cameraRotations.Dequeue();
			m_cameraRotations.Enqueue(m_newCameraRotation);
			float num = Quaternion.Angle(m_oldCameraRotation, m_newCameraRotation);
			if (num > 45f)
			{
				m_timeAfterTurn = 1f;
			}
		}
		m_ScoreAudioCooldownTimer -= Time.unscaledDeltaTime;
		m_timeSinceLastKill += Time.unscaledDeltaTime;
		if (m_timeSinceLastKill > m_multiKillMinTime)
		{
			m_multikillCounter = 0;
		}
	}

	private int GetFinalCurrencyFromScore()
	{
		int num = Mathf.FloorToInt((float)m_totalScore * Singleton<MissionManager>.Instance.CurrencyMultiplier);
		return num % 10 / 4 * 5 + num / 10 * 10;
	}

	public void OnMissionEnd(GameManager.EndMissionReason endMissionReason)
	{
		m_totalScore += m_killScore;
		if (endMissionReason == GameManager.EndMissionReason.Victory)
		{
			if (Singleton<MissionManager>.Instance.HasTimeLimit)
			{
				m_timeBonus = (int)Singleton<MissionManager>.Instance.GetTimeBonus();
				m_totalScore += m_timeBonus;
			}
			if (Singleton<MissionManager>.Instance.WinCondition != 0)
			{
				m_protectBonus = (Singleton<MissionManager>.Instance.FriendsToKill - Singleton<MissionManager>.Instance.FriendsKilled) * 100;
				m_totalScore += m_protectBonus;
			}
		}
		else
		{
			m_timeBonus = 0;
			m_protectBonus = 0;
		}
		m_moneyEarned = GetFinalCurrencyFromScore();
		Singleton<Profile>.Instance.Player.AddMoney(m_moneyEarned);
		if (endMissionReason == GameManager.EndMissionReason.Victory)
		{
			if (m_totalScore >= Singleton<MissionManager>.Instance.TargetScoreThreeStar)
			{
				m_stars = 3;
			}
			else if (m_totalScore >= Singleton<MissionManager>.Instance.TargetScoreTwoStar)
			{
				m_stars = 2;
			}
			else if (m_totalScore >= Singleton<MissionManager>.Instance.TargetScoreOneStar)
			{
				m_stars = 1;
			}
		}
		else
		{
			m_stars = 0;
		}
	}

	public void OnBonusEnd()
	{
		m_totalScore = m_baseScore;
		m_moneyEarned = GetFinalCurrencyFromScore();
		Singleton<Profile>.Instance.Player.AddMoney(m_moneyEarned);
		Singleton<Profile>.Instance.Progress.CompletedBonusMission();
	}

	public void AddKillPoints(int points, EnemyStatus enemy)
	{
		m_totalKills++;
		int multiplier = Singleton<PowerUpManager>.Instance.PointsMultiplier;
		int num = points;
		m_baseScore += points;
		if (!Singleton<MissionManager>.Instance.DoingBonusMission)
		{
			num += ApplyBonusesToKill(enemy, Vector3.SqrMagnitude(camTrans.position - enemy.transform.position), ref multiplier);
		}
		int bonus = num - points;
		int num2 = 0;
		int num3 = 0;
		if (enemy.Spawner.CountTowardsVictory)
		{
			PlaneType planeType = enemy.Spawner.Config.m_spawner.m_planeType;
			KillPlaneMap[] enemiesInMission = Singleton<MissionManager>.Instance.EnemiesInMission;
			KillPlaneMap[] enemiesKilled = Singleton<MissionManager>.Instance.EnemiesKilled;
			for (int i = 0; i < enemiesInMission.Length; i++)
			{
				if (enemiesInMission[i].m_type == PlaneType.Any)
				{
					num2 = enemiesKilled[i].m_count;
					num3 = enemiesInMission[i].m_count;
				}
				else if (enemiesInMission[i].m_type == planeType)
				{
					num2 = enemiesKilled[i].m_count;
					num3 = enemiesInMission[i].m_count;
				}
			}
			num2 = Mathf.Clamp(num2 + 1, 0, num3);
		}
		Singleton<FlyingScorePool>.Instance.ShowNewFloater(enemy.transform.position, points, bonus, multiplier, num2, num3);
		num *= multiplier;
		m_killScore += num;
	}

	private int ApplyBonusesToKill(EnemyStatus enemy, float sqrDistToCam, ref int multiplier)
	{
		for (int i = 0; i < m_killInfo.Length; i++)
		{
			m_killInfo[i] = false;
		}
		PlayerStats playerStatsData = Singleton<GameManager>.Instance.PlayerStatsData;
		bool flag = false;
		int num = 0;
		if (sqrDistToCam > m_minDistanceSqr)
		{
			num += m_distanceBonus;
			flag = (m_killInfo[0] = true);
			m_totalMedals[0]++;
		}
		if (playerStatsData.GetOverheatPercentage() > 0.95f)
		{
			num += m_overheatBonus;
			flag = (m_killInfo[1] = true);
			m_totalMedals[1]++;
		}
		if (m_timeAfterTurn > 0f)
		{
			num += m_snapShotBonus;
			flag = (m_killInfo[2] = true);
			m_totalMedals[2]++;
		}
		if (enemy.FirstDamageTime > 0f && Time.time - enemy.FirstDamageTime < m_quickKillMaxTime)
		{
			num += m_quickKillBonus;
			flag = (m_killInfo[3] = true);
			m_totalMedals[3]++;
		}
		m_timeSinceLastKill = 0f;
		m_multikillCounter++;
		multiplier *= m_multikillCounter;
		if (m_multikillCounter > 1)
		{
			if (m_multikillCounter > m_maxMultikill)
			{
				m_maxMultikill = m_multikillCounter;
			}
			flag = (m_killInfo[4] = true);
			m_totalMedals[4]++;
		}
		if (!enemy.StartedFire)
		{
			num += m_noReplyBonus;
			flag = (m_killInfo[5] = true);
			m_totalMedals[5]++;
		}
		if (enemy.FirstDamageTime < 0f)
		{
			num += m_overkillBonus;
			flag = (m_killInfo[6] = true);
			m_totalMedals[6]++;
		}
		if (Time.timeScale < 1f)
		{
			num += m_slowmoBonus;
			flag = (m_killInfo[7] = true);
			m_totalMedals[7]++;
		}
		if (Singleton<MissionManager>.Instance.HasTimeLimit && Singleton<MissionManager>.Instance.RemainingTime <= m_borrowedTimeMaxTime)
		{
			num += m_borrowedTimeBonus;
			flag = (m_killInfo[8] = true);
			m_totalMedals[8]++;
		}
		if (playerStatsData.Invulnerable)
		{
			num += m_invulnerableBonus;
			flag = (m_killInfo[9] = true);
			m_totalMedals[9]++;
		}
		if (enemy.DamageDone > m_revengeMinDamage)
		{
			num += m_revengeBonus;
			m_killInfo[10] = true;
			m_totalMedals[10]++;
		}
		if (enemy.FriendlyDamageDone > m_saviourMinDamage)
		{
			num += m_saviourBonus;
			m_killInfo[11] = true;
			m_totalMedals[11]++;
		}
		if (flag && m_ScoreAudioCooldownTimer <= 0f)
		{
			Singleton<AudioManager>.Instance.Play(AudioEvent.EvtPlayerVoxChatter_Combo);
			m_ScoreAudioCooldownTimer = m_ScoreAudioCooldownDuration;
		}
		return num;
	}

	public void AddBullet(bool wasHit)
	{
		if (wasHit)
		{
			m_bulletsHit++;
		}
		m_bulletsFired++;
	}

	public void MissionComplete(out NGUIScoreScreen.ScoreRenderSetting score)
	{
		bool doingBonusMission = Singleton<MissionManager>.Instance.DoingBonusMission;
		score = new NGUIScoreScreen.ScoreRenderSetting();
		int num = 5;
		if (Singleton<MissionManager>.Instance.HasTimeLimit)
		{
			num++;
		}
		if (Singleton<MissionManager>.Instance.WinCondition != 0)
		{
			num++;
		}
		if (doingBonusMission)
		{
			num = 3;
		}
		score.leftColumn = new string[num];
		score.rightColumn = new string[num];
		int num2 = 0;
		score.showingStarsAtEnd = !doingBonusMission;
		if (doingBonusMission)
		{
			score.leftColumn[num2] = "score_label_bonus_kills".Translate();
			score.rightColumn[num2++] = string.Empty + m_totalKills;
			score.leftColumn[num2] = "score_label_score".Translate();
			score.rightColumn[num2++] = string.Empty + m_baseScore;
			score.leftColumn[num2] = "score_label_currency".Translate();
			score.rightColumn[num2++] = string.Empty + m_moneyEarned;
			score.smallMessages = 0;
			return;
		}
		score.leftColumn[num2] = "score_label_score".Translate();
		score.rightColumn[num2++] = string.Empty + m_baseScore;
		score.leftColumn[num2] = "score_label_bonus".Translate();
		score.rightColumn[num2++] = string.Empty + (m_killScore - m_baseScore);
		if (Singleton<MissionManager>.Instance.HasTimeLimit)
		{
			score.leftColumn[num2] = "score_label_time_bonus".Translate();
			score.rightColumn[num2++] = string.Empty + m_timeBonus;
		}
		if (Singleton<MissionManager>.Instance.WinCondition != 0)
		{
			score.leftColumn[num2] = "score_label_protect_bonus".Translate();
			score.rightColumn[num2++] = string.Empty + m_protectBonus;
		}
		score.smallMessages = num2;
		score.leftColumn[num2] = "score_label_total".Translate();
		score.rightColumn[num2++] = string.Empty + m_totalScore;
		score.leftColumn[num2] = "score_label_currency".Translate();
		score.rightColumn[num2++] = string.Empty + m_moneyEarned;
		score.leftColumn[num2] = "score_label_rating".Translate();
		score.rightColumn[num2++] = string.Empty + Stars;
	}

	public void ResetScore()
	{
		m_timeSinceLastKill = 0f;
		m_timeAfterTurn = 0f;
		m_totalScore = 0;
		m_totalKills = 0;
		m_baseScore = 0;
		m_killScore = 0;
		m_bulletsHit = 0;
		m_bulletsFired = 0;
		m_multikillCounter = 0;
		m_maxMultikill = 0;
		m_ScoreAudioCooldownTimer = 0f;
		for (int i = 0; i < m_totalMedals.Length; i++)
		{
			m_totalMedals[i] = 0;
		}
	}

	public string GetBonusDescription(int bonus)
	{
		KillInfo killInfo = (KillInfo)bonus;
		return (killInfo.ToString() + "_bonus").Translate();
	}
}
public static class GeneralHelperUtility
{
	public static string Vector3ToString(Vector3 vec)
	{
		return "(" + vec.x + ", " + vec.y + ", " + vec.z + ")";
	}

	public static void SetXPosition(this Transform trans, float x)
	{
		Vector3 position = trans.position;
		position.x = x;
		trans.position = position;
	}

	public static void SetYPosition(this Transform trans, float y)
	{
		Vector3 position = trans.position;
		position.y = y;
		trans.position = position;
	}

	public static void SetZPosition(this Transform trans, float z)
	{
		Vector3 position = trans.position;
		position.z = z;
		trans.position = position;
	}

	public static void SetLocalXPosition(this Transform trans, float x)
	{
		Vector3 localPosition = trans.localPosition;
		localPosition.x = x;
		trans.localPosition = localPosition;
	}

	public static void SetLocalYPosition(this Transform trans, float y)
	{
		Vector3 localPosition = trans.localPosition;
		localPosition.y = y;
		trans.localPosition = localPosition;
	}

	public static void SetLocalZPosition(this Transform trans, float z)
	{
		Vector3 localPosition = trans.localPosition;
		localPosition.z = z;
		trans.localPosition = localPosition;
	}

	public static void AddXPosition(this Transform trans, float x)
	{
		Vector3 position = trans.position;
		position.x += x;
		trans.position = position;
	}

	public static void AddYPosition(this Transform trans, float y)
	{
		Vector3 position = trans.position;
		position.y += y;
		trans.position = position;
	}

	public static void AddZPosition(this Transform trans, float z)
	{
		Vector3 position = trans.position;
		position.z += z;
		trans.position = position;
	}

	public static void AddLocalXPosition(this Transform trans, float x)
	{
		Vector3 localPosition = trans.localPosition;
		localPosition.x += x;
		trans.localPosition = localPosition;
	}

	public static void AddLocalYPosition(this Transform trans, float y)
	{
		Vector3 localPosition = trans.localPosition;
		localPosition.y += y;
		trans.localPosition = localPosition;
	}

	public static void AddLocalZPosition(this Transform trans, float z)
	{
		Vector3 localPosition = trans.localPosition;
		localPosition.z += z;
		trans.localPosition = localPosition;
	}

	public static void SetXRotation(this Transform trans, float x)
	{
		Vector3 eulerAngles = trans.eulerAngles;
		eulerAngles.x = x;
		trans.rotation = Quaternion.Euler(eulerAngles);
	}

	public static void SetYRotation(this Transform trans, float y)
	{
		Vector3 eulerAngles = trans.eulerAngles;
		eulerAngles.y = y;
		trans.rotation = Quaternion.Euler(eulerAngles);
	}

	public static void SetZRotation(this Transform trans, float z)
	{
		Vector3 eulerAngles = trans.eulerAngles;
		eulerAngles.z = z;
		trans.rotation = Quaternion.Euler(eulerAngles);
	}

	public static void SetLocalXRotation(this Transform trans, float x)
	{
		Vector3 localEulerAngles = trans.localEulerAngles;
		localEulerAngles.x = x;
		trans.localRotation = Quaternion.Euler(localEulerAngles);
	}

	public static void SetLocalYRotation(this Transform trans, float y)
	{
		Vector3 localEulerAngles = trans.localEulerAngles;
		localEulerAngles.y = y;
		trans.localRotation = Quaternion.Euler(localEulerAngles);
	}

	public static void SetLocalZRotation(this Transform trans, float z)
	{
		Vector3 localEulerAngles = trans.localEulerAngles;
		localEulerAngles.z = z;
		trans.localRotation = Quaternion.Euler(localEulerAngles);
	}

	public static void AddXRotation(this Transform trans, float x)
	{
		Vector3 eulerAngles = trans.eulerAngles;
		eulerAngles.x += x;
		trans.rotation = Quaternion.Euler(eulerAngles);
	}

	public static void AddYRotation(this Transform trans, float y)
	{
		Vector3 eulerAngles = trans.eulerAngles;
		eulerAngles.y += y;
		trans.rotation = Quaternion.Euler(eulerAngles);
	}

	public static void AddZRotation(this Transform trans, float z)
	{
		Vector3 eulerAngles = trans.eulerAngles;
		eulerAngles.z += z;
		trans.rotation = Quaternion.Euler(eulerAngles);
	}

	public static void AddLocalXRotation(this Transform trans, float x)
	{
		Vector3 localEulerAngles = trans.localEulerAngles;
		localEulerAngles.x += x;
		trans.localRotation = Quaternion.Euler(localEulerAngles);
	}

	public static void AddLocalYRotation(this Transform trans, float y)
	{
		Vector3 localEulerAngles = trans.localEulerAngles;
		localEulerAngles.y += y;
		trans.localRotation = Quaternion.Euler(localEulerAngles);
	}

	public static void AddLocalZRotation(this Transform trans, float z)
	{
		Vector3 localEulerAngles = trans.localEulerAngles;
		localEulerAngles.z += z;
		trans.localRotation = Quaternion.Euler(localEulerAngles);
	}

	public static T GetComponentUpwards<T>(this Component child) where T : Component
	{
		T component = child.GetComponent<T>();
		if (component == null)
		{
			Transform parent = child.transform.parent;
			while (component == null && parent != null)
			{
				component = parent.GetComponent<T>();
				parent = parent.parent;
			}
		}
		return component;
	}

	public static T GetOrAddComponent<T>(this Component child) where T : Component
	{
		T val = child.GetComponent<T>();
		if (val == null)
		{
			val = child.gameObject.AddComponent<T>();
		}
		return val;
	}

	public static T GetOrAddComponent<T>(this GameObject child) where T : Component
	{
		T val = child.GetComponent<T>();
		if (val == null)
		{
			val = child.AddComponent<T>();
		}
		return val;
	}

	public static bool OutOfScreen(this Vector3 position, float PercentageOut = 0.1f)
	{
		Vector3 vector = Camera.main.WorldToViewportPoint(position);
		if (vector.x < PercentageOut || (double)vector.y < (double)PercentageOut || vector.x > 1f - PercentageOut || vector.y > 1f - PercentageOut || vector.z < Camera.main.nearClipPlane * (1f - PercentageOut) || vector.z > Camera.main.farClipPlane * (1f + PercentageOut))
		{
			return true;
		}
		return false;
	}

	public static void Shuffle<T>(this IList<T> list)
	{
		System.Random random = new System.Random();
		int num = list.Count;
		while (num > 1)
		{
			num--;
			int index = random.Next(num + 1);
			T value = list[index];
			list[index] = list[num];
			list[num] = value;
		}
	}
}
public class ConstantMover : MonoBehaviour
{
	private Vector3 m_Speed = Vector3.zero;

	[HideInInspector]
	private Transform _transform;

	public Vector3 Speed
	{
		get
		{
			return m_Speed;
		}
		set
		{
			m_Speed = value;
		}
	}

	private void Awake()
	{
		_transform = base.transform;
	}

	private void Update()
	{
		_transform.position += m_Speed * Time.deltaTime;
	}
}
public class EnemyCounterDisplay : MonoBehaviour
{
	[SerializeField]
	private SpinningTicker TotalUnits;

	[SerializeField]
	private SpinningTicker TotalTens;

	[SerializeField]
	private SpinningTicker KilledUnits;

	[SerializeField]
	private SpinningTicker KilledTens;

	private void Start()
	{
	}

	private void Update()
	{
		if (Singleton<MissionManager>.TryInstance() && Singleton<GameManager>.Instance.State == GameManager.GameState.InGame)
		{
			int num = 0;
			int num2 = 0;
			if ((bool)TotalUnits)
			{
				TotalUnits.SetValue(num2 % 10);
			}
			if ((bool)TotalTens)
			{
				TotalTens.SetValue((num2 - num2 % 10) / 10);
			}
			if ((bool)KilledUnits)
			{
				KilledUnits.SetValue(num % 10);
			}
			if ((bool)KilledTens)
			{
				KilledTens.SetValue((num - num % 10) / 10);
			}
		}
	}
}
public class EnemyHealthBar : SimpleHealthBar
{
	private EnemyStatus m_MyTarget;

	public static EnemyHealthBar CreateNew(EnemyStatus enemy, UnityEngine.Color fullHealth, UnityEngine.Color minorDamage, UnityEngine.Color majorDamage)
	{
		if (!Singleton<Profile>.Instance.Settings.EnableHealthbars)
		{
			return null;
		}
		GameObject gameObject = new GameObject("HealthBar");
		EnemyHealthBar enemyHealthBar = gameObject.AddComponent<EnemyHealthBar>();
		enemyHealthBar.Initialise(enemy);
		enemyHealthBar.fullHealthColour = fullHealth;
		enemyHealthBar.minorHealthLossColour = minorDamage;
		enemyHealthBar.majorHealthLossColour = majorDamage;
		return enemyHealthBar;
	}

	public void Initialise(EnemyStatus enemy)
	{
		m_MyTarget = enemy;
		transform.parent = enemy.transform;
		UpdateTransform();
		m_fadeOnDestroy = (m_destroyOnZero = true);
	}

	protected override bool HasValidTarget()
	{
		return m_MyTarget != null;
	}

	protected override Vector3 TargetPosition()
	{
		return m_MyTarget.transform.position;
	}

	protected override float GetLatestValue()
	{
		return m_MyTarget.GetHealthPercentage();
	}
}
public class FriendlyPlaneHealthBar : SimpleHealthBar
{
	private FriendlyPlane m_MyTarget;

	private Vector3 offset;

	public static FriendlyPlaneHealthBar CreateNew(FriendlyPlane enemy, UnityEngine.Color fullHealth, UnityEngine.Color minorDamage, UnityEngine.Color majorDamage)
	{
		if (!Singleton<Profile>.Instance.Settings.EnableHealthbars)
		{
			return null;
		}
		GameObject gameObject = new GameObject("HealthBar");
		FriendlyPlaneHealthBar friendlyPlaneHealthBar = gameObject.AddComponent<FriendlyPlaneHealthBar>();
		friendlyPlaneHealthBar.Initialise(enemy);
		friendlyPlaneHealthBar.fullHealthColour = fullHealth;
		friendlyPlaneHealthBar.minorHealthLossColour = minorDamage;
		friendlyPlaneHealthBar.majorHealthLossColour = majorDamage;
		return friendlyPlaneHealthBar;
	}

	public void Initialise(FriendlyPlane enemy)
	{
		m_MyTarget = enemy;
		transform.parent = enemy.transform;
		UpdateTransform();
		m_fadeOnDestroy = (m_destroyOnZero = true);
		m_applyYOffset = false;
	}

	public void SetOffsetAndScale(float y, float z, float scaleModifier)
	{
		if (m_MyTarget.transform.position.y > 0f)
		{
			y *= -1f;
		}
		offset = new Vector3(0f, y, z);
		distanceScaleModifier = scaleModifier;
	}

	protected override bool HasValidTarget()
	{
		return m_MyTarget != null;
	}

	protected override Vector3 TargetPosition()
	{
		return m_MyTarget.transform.position + offset;
	}

	protected override float GetLatestValue()
	{
		return m_MyTarget.GetHealthPercentage();
	}
}
public class PlayerHealthBar : RadarOverheatBar
{
	[SerializeField]
	private UnityEngine.Color m_color2;

	[SerializeField]
	private UnityEngine.Color m_color3;

	[SerializeField]
	private UnityEngine.Color m_color4;

	[SerializeField]
	private UnityEngine.Color m_goldenColor;

	[SerializeField]
	private float m_restoreSpeed;

	private float m_currentValue;

	private float m_growingVelocity;

	private bool m_isGoingUp;

	private UnityEngine.Color m_color = UnityEngine.Color.green;

	public override void Tick()
	{
		float healthPercentage = m_player.GetHealthPercentage();
		if (m_player.Invulnerable)
		{
			Blink(m_goldenColor, m_blinkColor);
		}
		else if (m_isBlinking)
		{
			Blink(m_color, m_goldenColor);
		}
		if (m_PrevValue != healthPercentage)
		{
			if (!m_isGoingUp)
			{
				if (m_PrevValue > healthPercentage)
				{
					SetValue(healthPercentage);
					m_currentValue = healthPercentage;
				}
				else
				{
					m_isGoingUp = true;
					m_isBlinking = true;
				}
			}
			m_PrevValue = healthPercentage;
		}
		if (m_isGoingUp)
		{
			m_currentValue = Mathf.SmoothDamp(m_currentValue, healthPercentage, ref m_growingVelocity, m_restoreSpeed);
			if (m_currentValue >= healthPercentage - 0.02f)
			{
				m_growingVelocity = 0f;
				m_isGoingUp = false;
			}
			if (!m_isBlinking)
			{
				m_isBlinking = true;
			}
			SetValue(m_currentValue);
		}
	}

	protected override void Reset(bool restart)
	{
		m_PrevValue = 1f;
		SetValue(1f);
	}

	protected override void SetValue(float value)
	{
		base.SetValue(value);
		if (value > 0.9f)
		{
			m_color = m_mainColor;
		}
		else if (value > 0.7f)
		{
			m_color.r = (m_mainColor.r - m_color2.r) * (value - 0.7f) / 0.2f + m_color2.r;
			m_color.g = (m_mainColor.g - m_color2.g) * (value - 0.7f) / 0.2f + m_color2.g;
			m_color.b = (m_mainColor.b - m_color2.b) * (value - 0.7f) / 0.2f + m_color2.b;
		}
		else if (value > 0.4f)
		{
			m_color.r = (m_color2.r - m_color3.r) * (value - 0.4f) / 0.3f + m_color3.r;
			m_color.g = (m_color2.g - m_color3.g) * (value - 0.4f) / 0.3f + m_color3.g;
			m_color.b = (m_color2.b - m_color3.b) * (value - 0.4f) / 0.3f + m_color3.b;
		}
		else
		{
			m_color.r = (m_color3.r - m_color4.r) * value / 0.4f + m_color4.r;
			m_color.g = (m_color3.g - m_color4.g) * value / 0.4f + m_color4.g;
			m_color.b = (m_color3.b - m_color4.b) * value / 0.4f + m_color4.b;
		}
		renderer.material.color = m_color;
	}
}
public class PlayerHealthBarLights : MonoBehaviour
{
	private PlayerStats m_MyTarget;

	[SerializeField]
	private Transform[] m_LightPositions = new Transform[0];

	private Light[] m_lights;

	private float m_InitialIntensity;

	[SerializeField]
	private Mesh m_redMesh;

	[SerializeField]
	private Material m_redMaterial;

	[SerializeField]
	private Mesh m_redGlowMesh;

	[SerializeField]
	private Material m_redGlowMaterial;

	[SerializeField]
	private Mesh m_greenMesh;

	[SerializeField]
	private Material m_greenMaterial;

	[SerializeField]
	private Mesh m_greenGlowMesh;

	[SerializeField]
	private Material m_greenGlowMaterial;

	[SerializeField]
	private Mesh m_offMesh;

	[SerializeField]
	private Material m_offMaterial;

	[SerializeField]
	private bool m_ChangeMeshOnFlash = true;

	[SerializeField]
	private float m_flashTimeNormal = 1f;

	[SerializeField]
	private float m_flashTimeCritical = 0.5f;

	private float m_flashingTime;

	private void Start()
	{
		m_MyTarget = Singleton<GameManager>.Instance.Player.GetComponent<PlayerStats>();
		m_lights = new Light[m_LightPositions.Length];
		for (int i = 0; i < m_LightPositions.Length; i++)
		{
			m_lights[i] = m_LightPositions[i].GetComponentInChildren<Light>();
		}
		if (m_lights.Length > 0 && m_lights[0] != null)
		{
			m_InitialIntensity = m_lights[0].intensity;
		}
	}

	private void Update()
	{
		float healthPercentage = m_MyTarget.GetHealthPercentage();
		int num = m_LightPositions.Length;
		float num2 = healthPercentage * (float)num;
		int num3 = Mathf.CeilToInt(num2);
		float num4 = num2 + 1f - (float)num3;
		bool flag = num4 > 0f && num4 <= 0.5f;
		if (!flag)
		{
			m_flashingTime = 0f;
		}
		else
		{
			m_flashingTime += Time.unscaledDeltaTime;
		}
		bool flag2 = false;
		UnityEngine.Color color = UnityEngine.Color.green;
		float num5 = ((num3 != 1) ? m_flashTimeNormal : m_flashTimeCritical);
		float num6 = Mathf.Abs(Mathf.Repeat(m_flashingTime, num5) / num5 - 0.5f) * 2f;
		bool flag3 = flag && m_ChangeMeshOnFlash && num6 < 0.5f;
		for (int i = 0; i < num; i++)
		{
			bool flag4 = i == num3 - 1;
			if (i < num3 - 1 || (flag4 && !flag3))
			{
				flag2 = true;
				if (num3 == 1)
				{
					color = UnityEngine.Color.red;
					UnityEngine.Graphics.DrawMesh(m_redMesh, m_LightPositions[i].localToWorldMatrix, m_redMaterial, 0);
					UnityEngine.Graphics.DrawMesh(m_redGlowMesh, m_LightPositions[i].localToWorldMatrix, m_redGlowMaterial, 0);
				}
				else
				{
					color = UnityEngine.Color.green;
					UnityEngine.Graphics.DrawMesh(m_greenMesh, m_LightPositions[i].localToWorldMatrix, m_greenMaterial, 0);
					UnityEngine.Graphics.DrawMesh(m_greenGlowMesh, m_LightPositions[i].localToWorldMatrix, m_greenGlowMaterial, 0);
				}
			}
			else
			{
				if (!flag4)
				{
					flag2 = false;
				}
				UnityEngine.Graphics.DrawMesh(m_offMesh, m_LightPositions[i].localToWorldMatrix, m_offMaterial, 0);
			}
			if ((bool)m_lights[i])
			{
				m_lights[i].enabled = flag2;
				m_lights[i].color = color;
				if (flag && flag4)
				{
					m_lights[i].intensity = m_InitialIntensity * num6;
				}
			}
		}
	}
}
public class RadarOverheatBar : MonoBehaviour
{
	[SerializeField]
	private Texture m_BarTexture;

	[SerializeField]
	private Texture m_BarTextureMask;

	[SerializeField]
	private Shader m_BarShader;

	[SerializeField]
	private float m_size = 0.053f;

	[SerializeField]
	protected UnityEngine.Color m_mainColor;

	[SerializeField]
	protected UnityEngine.Color m_blinkColor;

	[SerializeField]
	private float m_blinkingSpeed;

	private MeshFilter m_MeshFilter;

	private Mesh m_BarMesh;

	protected float m_PrevValue;

	protected PlayerStats m_player;

	protected float m_currentAlpha = 1f;

	protected bool m_isBlinking;

	protected float m_time;

	[NonSerialized]
	[HideInInspector]
	public new Transform transform;

	[NonSerialized]
	[HideInInspector]
	public Renderer renderer;

	private void Awake()
	{
		transform = GetComponent<Transform>();
		renderer = base.gameObject.AddComponent<MeshRenderer>();
	}

	public void Initialise()
	{
		if (Singleton<Crosshair>.Instance == null)
		{
			Destroy();
			return;
		}
		transform.parent = Singleton<Crosshair>.Instance.GetCentre();
		transform.localPosition = new Vector3(m_size, 0f - Mathf.Abs(m_size), 0.005f);
		transform.localRotation = Quaternion.Euler(0f, 180f, 0f);
		transform.localScale = new Vector3(1f, 1f, 1f);
		renderer.material.color = m_mainColor;
		renderer.material.shader = m_BarShader;
		m_MeshFilter = base.gameObject.AddComponent<MeshFilter>();
		if ((bool)m_BarTexture)
		{
			renderer.material.mainTexture = m_BarTexture;
		}
		if ((bool)m_BarTextureMask)
		{
			renderer.material.SetTexture("_MaskTex", m_BarTextureMask);
		}
		if (m_BarMesh == null)
		{
			m_BarMesh = CreatePlane(Mathf.Abs(m_size), Mathf.Abs(m_size));
		}
		m_MeshFilter.mesh = m_BarMesh;
		SetValue(0f);
		m_player = Singleton<GameManager>.Instance.Player.GetComponent<PlayerStats>();
		Singleton<GameManager>.Instance.OnStartMission += Reset;
	}

	private void OnDestroy()
	{
		if (Singleton<GameManager>.TryInstance())
		{
			Singleton<GameManager>.Instance.OnStartMission -= Reset;
		}
	}

	protected virtual void Reset(bool restart)
	{
		m_PrevValue = 0f;
		SetValue(0f);
	}

	public virtual void Tick()
	{
		float overheatPercentage = m_player.GetOverheatPercentage();
		if (Singleton<PowerUpManager>.Instance.NoHeating)
		{
			Blink(m_mainColor, m_blinkColor);
		}
		if (m_PrevValue != overheatPercentage)
		{
			SetValue(overheatPercentage);
			m_PrevValue = overheatPercentage;
		}
	}

	protected void Blink(UnityEngine.Color baseColor, UnityEngine.Color blinkColor)
	{
		m_currentAlpha -= Time.deltaTime * m_blinkingSpeed;
		if (m_blinkingSpeed > 0f && m_currentAlpha <= 0f)
		{
			m_currentAlpha = 0f;
			m_blinkingSpeed *= -1f;
		}
		else if (m_blinkingSpeed < 0f && m_currentAlpha >= 1f)
		{
			m_currentAlpha -= Time.deltaTime * m_blinkingSpeed;
			m_currentAlpha = 1f;
			m_blinkingSpeed *= -1f;
			m_isBlinking = false;
		}
		baseColor.r = (baseColor.r - blinkColor.r) * m_currentAlpha + blinkColor.r;
		baseColor.g = (baseColor.g - blinkColor.g) * m_currentAlpha + blinkColor.g;
		baseColor.b = (baseColor.b - blinkColor.b) * m_currentAlpha + blinkColor.b;
		renderer.material.color = baseColor;
	}

	protected virtual void SetValue(float value)
	{
		renderer.material.SetFloat("_DisplayPercent", value);
	}

	private Vector2 RotateUV(Vector2 uv, Quaternion rot)
	{
		uv.x -= 1f;
		uv.y -= 1f;
		uv = rot * uv;
		uv.x += 1f;
		uv.y += 1f;
		return uv;
	}

	private void Destroy()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private Mesh CreatePlane(float width, float height)
	{
		Mesh mesh = new Mesh();
		mesh.name = "PlaneMesh";
		mesh.vertices = new Vector3[4]
		{
			new Vector3(0f - width, height, 0f),
			new Vector3(width, height, 0f),
			new Vector3(width, 0f - height, 0f),
			new Vector3(0f - width, 0f - height, 0f)
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(1f, 0f),
			new Vector2(0f, 0f)
		};
		mesh.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
		mesh.RecalculateNormals();
		return mesh;
	}
}
public class RadarPointer : MonoBehaviour
{
	private EnemyStatus m_TargetEnemy;

	private float m_scale;

	private Vector3 m_posDiff;

	private UnityEngine.Color m_color;

	private UnityEngine.Color m_newColor;

	private Vector3 m_rotation = Vector3.zero;

	private Vector3 m_offset;

	private bool m_activeInRenderer;

	[NonSerialized]
	[HideInInspector]
	public new Transform transform;

	[NonSerialized]
	[HideInInspector]
	public new GameObject gameObject;

	private bool m_showingBigPointer = true;

	private bool justActivated;

	private Transform parentTransform;

	private Crosshair.CrosshairRadarSettings radarSettings;

	public EnemyStatus TargetEnemy
	{
		set
		{
			m_TargetEnemy = value;
		}
	}

	public bool ShowingBigPointer => m_showingBigPointer;

	public UnityEngine.Color CurrentColor => m_color;

	public float Scale => m_scale;

	private void Awake()
	{
		transform = GetComponent<Transform>();
		gameObject = base.gameObject;
	}

	private void Start()
	{
		Transform centre = Singleton<Crosshair>.Instance.GetCentre();
		transform.parent = centre;
		parentTransform = centre;
		radarSettings = Singleton<Crosshair>.Instance.RadarSettings;
		transform.localPosition = (m_offset = new Vector3(0f, radarSettings.PointerDistanceFromCentre, 0f));
		transform.localRotation = Quaternion.identity;
	}

	public void ActivateInRenderer(bool active)
	{
		if (m_activeInRenderer == active)
		{
			return;
		}
		m_activeInRenderer = active;
		if (active)
		{
			if (radarSettings == null)
			{
				radarSettings = Singleton<Crosshair>.Instance.RadarSettings;
			}
			if (justActivated)
			{
				if (m_TargetEnemy.Behaviour is CargoBehavior)
				{
					m_color = (m_newColor = radarSettings.PointerColorCargo);
				}
				else
				{
					m_color = (m_newColor = radarSettings.PointerColorNotAttacking);
				}
				justActivated = false;
			}
			Singleton<MassLineRenderer>.Instance.radarPointers.Add(this);
		}
		else
		{
			Singleton<MassLineRenderer>.Instance.radarPointers.Remove(this);
		}
	}

	private void OnEnable()
	{
		justActivated = true;
	}

	public void Tick(float deltaTime)
	{
		m_posDiff = m_TargetEnemy.transform.position - parentTransform.position;
		Vector3 vector = ((!Singleton<Profile>.Instance.Settings.GazeToAim && InputUtils.IsTrackedRemoteActive()) ? Singleton<MenuManager>.Instance.GetCrosshair().transform.eulerAngles : Singleton<CameraManager>.Instance.GetCamera().eulerAngles);
		float num = Mathf.Atan2(m_posDiff.x, m_posDiff.z) * 57.29578f;
		m_posDiff = Quaternion.Euler(new Vector3(0f, 0f - num, 0f)) * m_posDiff;
		num -= vector.y;
		float num2 = (0f - Mathf.Atan2(0f - m_posDiff.y, m_posDiff.z)) * 57.29578f;
		num2 -= 0f - vector.x;
		for (; num < -180f; num += 360f)
		{
		}
		while (num > 180f)
		{
			num -= 360f;
		}
		for (; num2 < -180f; num2 += 360f)
		{
		}
		while (num2 > 180f)
		{
			num2 -= 360f;
		}
		ActivateInRenderer(!(Math.Abs(num) < 5f) || !(Math.Abs(num2) < 5f));
		if (Math.Abs(num) > 90f)
		{
			m_rotation.z = num;
			m_showingBigPointer = false;
		}
		else
		{
			m_rotation.z = Mathf.Atan2(0f - num2, num) * 57.29578f + 90f;
			m_showingBigPointer = true;
		}
		Quaternion quaternion = Quaternion.Euler(m_rotation);
		transform.localPosition = quaternion * m_offset;
		transform.localRotation = quaternion;
		float scale = radarSettings.PointerMaxScale;
		if (m_TargetEnemy.IsOnAttackRun())
		{
			float sqrMagnitude = m_posDiff.sqrMagnitude;
			if (sqrMagnitude > radarSettings.PointerEnemyDistanceMinSizeSqr)
			{
				scale = radarSettings.PointerMinScale;
			}
			else if (sqrMagnitude > radarSettings.PointerEnemyDistanceMaxSizeSqr)
			{
				scale = (1f - (m_posDiff.magnitude - radarSettings.PointerEnemyDistanceMaxSize) / (radarSettings.PointerEnemyDistanceMinSize - radarSettings.PointerEnemyDistanceMaxSize)) * (radarSettings.PointerMaxScale - radarSettings.PointerMinScale) + radarSettings.PointerMinScale;
			}
			m_newColor = radarSettings.PointerColorAttacking;
		}
		else if (m_TargetEnemy.IsCargoPlane())
		{
			m_newColor = radarSettings.PointerColorCargo;
		}
		else
		{
			scale = radarSettings.PointerMinScale;
			m_newColor = radarSettings.PointerColorNotAttacking;
		}
		m_color = UnityEngine.Color.Lerp(m_color, m_newColor, deltaTime);
		m_scale = scale;
	}
}
public class ScoreDisplay : MonoBehaviour
{
	[SerializeField]
	private SpinningTicker Units;

	[SerializeField]
	private SpinningTicker Tens;

	[SerializeField]
	private SpinningTicker Hundreds;

	[SerializeField]
	private SpinningTicker Thousands;

	private int m_PrevScore;

	private void Start()
	{
	}

	private void Update()
	{
		if (!Singleton<MissionManager>.Instance)
		{
			return;
		}
		int currentMissionScore = Singleton<PlayerScore>.Instance.CurrentMissionScore;
		if (currentMissionScore != m_PrevScore)
		{
			m_PrevScore = currentMissionScore;
			int num = currentMissionScore % 10;
			currentMissionScore -= num;
			int num2 = currentMissionScore % 100 / 10;
			currentMissionScore -= num2;
			int num3 = currentMissionScore % 1000 / 100;
			currentMissionScore -= num3;
			if ((bool)Units)
			{
				Units.SetValue(num);
			}
			if ((bool)Tens)
			{
				Tens.SetValue(num2);
			}
			if ((bool)Hundreds)
			{
				Hundreds.SetValue(num3);
			}
			if ((bool)Thousands)
			{
				Thousands.SetValue(currentMissionScore / 1000);
			}
		}
	}
}
public class SimpleHealthBar : MonoBehaviour
{
	private float m_PrevValue = -1f;

	protected bool m_fadeOnDestroy;

	protected bool m_destroyOnZero;

	protected float m_fadeOutTime = 0.5f;

	private float m_fadeOutTimeRemaining;

	protected Vector3 m_scale = Vector3.one;

	protected bool m_applyYOffset = true;

	protected bool m_usingSimpleBars = true;

	[NonSerialized]
	[HideInInspector]
	public new Transform transform;

	private Transform CamTransform;

	[NonSerialized]
	[HideInInspector]
	public new GameObject gameObject;

	private UnityEngine.Color m_color;

	protected UnityEngine.Color fullHealthColour = UnityEngine.Color.green;

	protected UnityEngine.Color minorHealthLossColour = UnityEngine.Color.yellow;

	protected UnityEngine.Color majorHealthLossColour = UnityEngine.Color.red;

	protected float distanceScaleModifier = 50f;

	public UnityEngine.Color CurrentColor => m_color;

	public virtual float CurrentValue => m_PrevValue;

	protected virtual void Awake()
	{
		gameObject = base.gameObject;
		transform = GetComponent<Transform>();
		CamTransform = Singleton<CameraManager>.Instance.transform;
	}

	private void OnEnable()
	{
		if (m_usingSimpleBars)
		{
			Singleton<MassLineRenderer>.Instance.healthBars.Add(this);
			if (HasValidTarget())
			{
				Tick();
			}
		}
	}

	private void OnDisable()
	{
		if (m_usingSimpleBars && Singleton<MassLineRenderer>.TryInstance())
		{
			Singleton<MassLineRenderer>.Instance.healthBars.Remove(this);
		}
	}

	public void Tick()
	{
		UpdateTransform();
		if (!HasValidTarget())
		{
			Destroy();
			return;
		}
		float latestValue = GetLatestValue();
		if (!Mathf.Approximately(latestValue, m_PrevValue))
		{
			if (m_destroyOnZero && Mathf.Approximately(0f, latestValue))
			{
				Destroy();
			}
			SetValue(latestValue);
			m_PrevValue = latestValue;
		}
	}

	protected virtual bool HasValidTarget()
	{
		return false;
	}

	protected virtual Vector3 TargetPosition()
	{
		return Vector3.zero;
	}

	protected virtual float GetLatestValue()
	{
		return 1f;
	}

	protected virtual void UpdateTransform()
	{
		Vector3 vector = CamTransform.position - transform.position;
		float magnitude = vector.magnitude;
		float num = magnitude / distanceScaleModifier;
		transform.position = TargetPosition();
		if (m_applyYOffset)
		{
			transform.position += new Vector3(0f, -1.5f * num, 0f);
		}
		transform.forward = -(vector / magnitude);
		float num2 = 0.5f * num;
		transform.localScale = Vector3.Scale(new Vector3(num2, num2, 1f), m_scale);
	}

	protected virtual void SetValue(float value)
	{
		if (value > 0.6f)
		{
			m_color = fullHealthColour;
		}
		else if (value > 0.3f)
		{
			m_color = minorHealthLossColour;
		}
		else
		{
			m_color = majorHealthLossColour;
		}
	}

	protected void Destroy()
	{
		gameObject.SetActive(value: false);
	}

	private void UpdateDestruction()
	{
		m_fadeOutTimeRemaining -= Time.unscaledDeltaTime;
		if (m_fadeOutTimeRemaining <= 0f)
		{
			gameObject.SetActive(value: false);
		}
	}
}
public class SimpleLoadProgressBar : SimpleHealthBar
{
	public static SimpleLoadProgressBar Instance;

	private Vector3 m_offset;

	[SerializeField]
	private Sprite m_boxSprite;

	[SerializeField]
	private Sprite m_loadingFilled;

	[SerializeField]
	private Sprite m_loadingEmpty;

	private SpriteRenderer[] m_blockRend = new SpriteRenderer[10];

	private float m_currentValue;

	private float m_barMoveSpeed = 2f;

	private float m_loadPercent;

	public override float CurrentValue => m_currentValue;

	public float LoadPercent
	{
		set
		{
			m_loadPercent = value;
		}
	}

	public static void UpdateValue(float val)
	{
		if ((bool)Instance)
		{
			Instance.LoadPercent = val;
		}
	}

	public static bool BarFull()
	{
		if (!Instance)
		{
			return true;
		}
		return Mathf.Approximately(Instance.CurrentValue, 1f);
	}

	protected override void Awake()
	{
		m_usingSimpleBars = false;
		base.Awake();
		GameObject gameObject = new GameObject("frame");
		gameObject.layer = LayerMask.NameToLayer("LoadingScreen");
		gameObject.transform.parent = transform;
		gameObject.transform.localPosition = Vector3.zero;
		gameObject.transform.localRotation = Quaternion.identity;
		SpriteRenderer spriteRenderer = gameObject.AddComponent<SpriteRenderer>();
		spriteRenderer.sprite = m_boxSprite;
		spriteRenderer.sortingOrder = 1;
		float num = (m_boxSprite.bounds.size.x - m_loadingEmpty.bounds.size.x * 10f) / 11f;
		float num2 = 0f - (m_loadingEmpty.bounds.size.x * 4.5f + num * 4.5f);
		for (int i = 0; i < 10; i++)
		{
			GameObject gameObject2 = new GameObject("blob");
			gameObject2.layer = LayerMask.NameToLayer("LoadingScreen");
			gameObject2.transform.parent = transform;
			gameObject2.transform.localPosition = new Vector3(num2 + (num + m_loadingEmpty.bounds.size.x) * (float)i, 0f, 0f);
			gameObject2.transform.localRotation = Quaternion.identity;
			m_blockRend[i] = gameObject2.AddComponent<SpriteRenderer>();
			m_blockRend[i].sprite = m_loadingEmpty;
			m_blockRend[i].sortingOrder = 2;
		}
		m_offset = transform.localPosition;
		m_applyYOffset = false;
		Instance = this;
		m_scale = new Vector3(7f, 7f, 1f);
	}

	protected override float GetLatestValue()
	{
		m_currentValue = Mathf.Min(m_loadPercent, m_currentValue + Time.deltaTime * m_barMoveSpeed);
		return m_currentValue;
	}

	protected override void SetValue(float val)
	{
		for (int i = 0; i < 10; i++)
		{
			if (val < (float)(i + 1) * 0.1f && !Mathf.Approximately(val, 1f))
			{
				m_blockRend[i].sprite = m_loadingEmpty;
			}
			else
			{
				m_blockRend[i].sprite = m_loadingFilled;
			}
		}
	}

	private void Update()
	{
		Tick();
	}

	protected override bool HasValidTarget()
	{
		return true;
	}

	protected override Vector3 TargetPosition()
	{
		return transform.parent.position + m_offset;
	}
}
public class SpinningTicker : MonoBehaviour
{
	[SerializeField]
	private int Segments = 10;

	[SerializeField]
	private int TurnSpeed = 50;

	private float[] SegmentDegrees;

	private int CurrentValue;

	private int DesiredValue;

	private float CurrentAngle;

	private void Start()
	{
		SegmentDegrees = new float[Segments];
		for (int i = 0; i < Segments; i++)
		{
			SegmentDegrees[i] = (float)i * (360f / (float)Segments);
		}
	}

	private void Update()
	{
		if (DesiredValue != CurrentValue)
		{
			while (DesiredValue < 0)
			{
				DesiredValue += Segments;
			}
			if (DesiredValue >= Segments)
			{
				DesiredValue %= Segments;
			}
			float num;
			for (num = SegmentDegrees[DesiredValue] - CurrentAngle; num > 180f; num -= 360f)
			{
			}
			for (; num <= -180f; num += 360f)
			{
			}
			float num2 = Mathf.Sign(num);
			float num3 = Time.deltaTime * (float)TurnSpeed * num2;
			float f = num - num3;
			if (Mathf.Sign(f) != num2)
			{
				num3 = num;
				CurrentValue = DesiredValue;
			}
			CurrentAngle += num3;
			base.transform.localRotation *= Quaternion.Euler(new Vector3(num3, 0f, 0f));
		}
	}

	public void SetValue(int Index)
	{
		if (Index >= Segments)
		{
			Index %= Segments;
		}
		DesiredValue = Index;
	}

	public void Increment(int n)
	{
		SetValue(CurrentValue + n);
	}

	public void InstantlySetValue(int Index)
	{
		while (Index < 0)
		{
			Index += Segments;
		}
		if (Index >= Segments)
		{
			Index %= Segments;
		}
		CurrentValue = (DesiredValue = Index);
		float currentAngle = CurrentAngle;
		CurrentAngle = SegmentDegrees[CurrentValue];
		float x = CurrentAngle - currentAngle;
		base.transform.localRotation *= Quaternion.Euler(new Vector3(x, 0f, 0f));
	}
}
public class TimerDisplay : MonoBehaviour
{
	[SerializeField]
	private SpinningTicker SecondsUnits;

	[SerializeField]
	private SpinningTicker SecondsTens;

	[SerializeField]
	private SpinningTicker MinutesUnits;

	[SerializeField]
	private SpinningTicker MinutesTens;

	private void Start()
	{
	}

	private void Update()
	{
		if ((bool)Singleton<MissionManager>.Instance)
		{
			int num = Mathf.FloorToInt(Singleton<MissionManager>.Instance.RemainingTime);
			int num2 = num % 60;
			int num3 = (num - num % 60) / 60;
			if ((bool)SecondsUnits)
			{
				SecondsUnits.SetValue(num2 % 10);
			}
			if ((bool)SecondsTens)
			{
				SecondsTens.SetValue((num2 - num2 % 10) / 10);
			}
			if ((bool)MinutesUnits)
			{
				MinutesUnits.SetValue(num3 % 10);
			}
			if ((bool)MinutesTens)
			{
				MinutesTens.SetValue((num3 - num3 % 10) / 10);
			}
		}
	}
}
public class WorldText : MonoBehaviour
{
	private static Sprite[] bsuiSprites;

	private static Sprite[] HudSprites;

	private static Sprite[] FrontEndSprites;

	private static Sprite[] FrontEndSprites2;

	public static Sprite GetSpriteByName(string name)
	{
		if (bsuiSprites == null)
		{
			bsuiSprites = Resources.LoadAll<Sprite>("GUI/Textures/bsui-texturesheet");
			HudSprites = Resources.LoadAll<Sprite>("GUI/Textures/bsui-hud-texturesheet");
			FrontEndSprites = Resources.LoadAll<Sprite>("GUI/Textures/banditsix_fe_assets");
			FrontEndSprites2 = Resources.LoadAll<Sprite>("GUI/Textures/BS_UI_FE");
		}
		for (int i = 0; i < bsuiSprites.Length; i++)
		{
			if (bsuiSprites[i].name.Equals(name))
			{
				return bsuiSprites[i];
			}
		}
		for (int j = 0; j < HudSprites.Length; j++)
		{
			if (HudSprites[j].name.Equals(name))
			{
				return HudSprites[j];
			}
		}
		for (int k = 0; k < FrontEndSprites2.Length; k++)
		{
			if (FrontEndSprites2[k].name.Equals(name))
			{
				return FrontEndSprites2[k];
			}
		}
		for (int l = 0; l < FrontEndSprites.Length; l++)
		{
			if (FrontEndSprites[l].name.Equals(name))
			{
				return FrontEndSprites[l];
			}
		}
		return null;
	}
}
public class AutoLocalizer : MonoBehaviour
{
	[SerializeField]
	private string locKey;

	private void Start()
	{
		UILabel component = base.gameObject.GetComponent<UILabel>();
		component.text = locKey.Translate();
	}
}
public class GeometryUtils
{
	public static int IntersectRaySphere(Vector3 rayPosition, Vector3 rayDirection, Vector3 sphereCenter, float sphereRadius, out Vector3 firstIntersection, out Vector3 secondIntersection)
	{
		Vector3 vector = sphereCenter - rayPosition;
		float magnitude = vector.magnitude;
		if (Vector3.Dot(vector, rayDirection) < 0f)
		{
			if (magnitude > sphereRadius)
			{
				firstIntersection = Vector3.zero;
				secondIntersection = Vector3.zero;
				return 0;
			}
			if (Mathf.Abs(magnitude - sphereRadius) < Mathf.Epsilon)
			{
				firstIntersection = rayPosition;
				secondIntersection = Vector3.zero;
				return 1;
			}
			Vector3 vector2 = Vector3.Project(vector, rayDirection) + rayPosition;
			float magnitude2 = (vector2 - sphereCenter).magnitude;
			float num = Mathf.Sqrt(sphereRadius * sphereRadius - magnitude2 * magnitude2);
			float num2 = num - (vector2 - rayPosition).magnitude;
			firstIntersection = rayPosition + num2 * rayDirection;
			secondIntersection = Vector3.zero;
			return 1;
		}
		Vector3 vector3 = Vector3.Project(vector, rayDirection) + rayPosition;
		if ((sphereCenter - vector3).magnitude > sphereRadius)
		{
			firstIntersection = Vector3.zero;
			secondIntersection = Vector3.zero;
			return 0;
		}
		float magnitude3 = (vector3 - sphereCenter).magnitude;
		float num3 = Mathf.Sqrt(sphereRadius * sphereRadius - magnitude3 * magnitude3);
		float magnitude4 = (vector3 - rayPosition).magnitude;
		float num4;
		if (magnitude > sphereRadius)
		{
			num4 = magnitude4 - num3;
			float num5 = magnitude4 + num3;
			firstIntersection = rayPosition + num4 * rayDirection;
			secondIntersection = rayPosition + num5 * rayDirection;
			return 2;
		}
		num4 = (vector3 - rayPosition).magnitude + num3;
		firstIntersection = rayPosition + num4 * rayDirection;
		secondIntersection = Vector3.zero;
		return 1;
	}
}
public class QuatMathUtils
{
	public static float GetQuatLength(Quaternion q)
	{
		return Mathf.Sqrt(q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w);
	}

	public static Quaternion GetQuatConjugate(Quaternion q)
	{
		return new Quaternion(0f - q.x, 0f - q.y, 0f - q.z, q.w);
	}

	public static Quaternion GetQuatLog(Quaternion q)
	{
		Quaternion result = q;
		result.w = 0f;
		if (Mathf.Abs(q.w) < 1f)
		{
			float num = Mathf.Acos(q.w);
			float num2 = Mathf.Sin(num);
			if ((double)Mathf.Abs(num2) > 0.0001)
			{
				float num3 = num / num2;
				result.x = q.x * num3;
				result.y = q.y * num3;
				result.z = q.z * num3;
			}
		}
		return result;
	}

	public static Quaternion GetQuatExp(Quaternion q)
	{
		Quaternion result = q;
		float num = Mathf.Sqrt(q.x * q.x + q.y * q.y + q.z * q.z);
		float num2 = Mathf.Sin(num);
		result.w = Mathf.Cos(num);
		if ((double)Mathf.Abs(num2) > 0.0001)
		{
			float num3 = num2 / num;
			result.x = num3 * q.x;
			result.y = num3 * q.y;
			result.z = num3 * q.z;
		}
		return result;
	}

	public static Quaternion GetQuatSquad(float t, Quaternion q0, Quaternion q1, Quaternion a0, Quaternion a1)
	{
		float t2 = 2f * t * (1f - t);
		Quaternion p = Slerp(q0, q1, t);
		Quaternion q2 = Slerp(a0, a1, t);
		return Slerp(p, q2, t2);
	}

	public static Quaternion GetSquadIntermediate(Quaternion q0, Quaternion q1, Quaternion q2)
	{
		Quaternion quatConjugate = GetQuatConjugate(q1);
		Quaternion quatLog = GetQuatLog(quatConjugate * q0);
		Quaternion quatLog2 = GetQuatLog(quatConjugate * q2);
		Quaternion q3 = new Quaternion(-0.25f * (quatLog.x + quatLog2.x), -0.25f * (quatLog.y + quatLog2.y), -0.25f * (quatLog.z + quatLog2.z), -0.25f * (quatLog.w + quatLog2.w));
		return q1 * GetQuatExp(q3);
	}

	public static float Ease(float t, float k1, float k2)
	{
		float num = k1 * 2f / (float)Math.PI + k2 - k1 + (1f - k2) * 2f / (float)Math.PI;
		float num2 = ((t < k1) ? (k1 * (2f / (float)Math.PI) * (Mathf.Sin(t / k1 * (float)Math.PI / 2f - (float)Math.PI / 2f) + 1f)) : ((!(t < k2)) ? (2f * k1 / (float)Math.PI + k2 - k1 + (1f - k2) * (2f / (float)Math.PI) * Mathf.Sin((t - k2) / (1f - k2) * (float)Math.PI / 2f)) : (2f * k1 / (float)Math.PI + t - k1)));
		return num2 / num;
	}

	public static Quaternion Slerp(Quaternion p, Quaternion q, float t)
	{
		float num = Quaternion.Dot(p, q);
		Quaternion result = default(Quaternion);
		if ((double)(1f + num) > 1E-05)
		{
			float num4;
			float num5;
			if ((double)(1f - num) > 1E-05)
			{
				float num2 = Mathf.Acos(num);
				float num3 = 1f / Mathf.Sin(num2);
				num4 = Mathf.Sin((1f - t) * num2) * num3;
				num5 = Mathf.Sin(t * num2) * num3;
			}
			else
			{
				num4 = 1f - t;
				num5 = t;
			}
			result.x = num4 * p.x + num5 * q.x;
			result.y = num4 * p.y + num5 * q.y;
			result.z = num4 * p.z + num5 * q.z;
			result.w = num4 * p.w + num5 * q.w;
		}
		else
		{
			float num6 = Mathf.Sin((1f - t) * (float)Math.PI * 0.5f);
			float num7 = Mathf.Sin(t * (float)Math.PI * 0.5f);
			result.x = num6 * p.x - num7 * p.y;
			result.y = num6 * p.y + num7 * p.x;
			result.z = num6 * p.z - num7 * p.w;
			result.w = p.z;
		}
		return result;
	}
}
public class TextHelper : Singleton<TextHelper>
{
	private Hashtable m_textTable;

	protected override void Awake()
	{
		isPersistant = true;
		base.Awake();
	}

	public void Load()
	{
		m_textTable = new Hashtable();
		string xmlAssetPath = "Localization/loc_" + Singleton<Profile>.Instance.Settings.Language;
		XmlTextReader xmlTextReader = XmlHelper.GetXmlTextReader(xmlAssetPath);
		xmlTextReader.WhitespaceHandling = WhitespaceHandling.None;
		while (xmlTextReader.Read())
		{
			if (xmlTextReader.NodeType == XmlNodeType.Element && xmlTextReader.Name == "element")
			{
				string attribute = xmlTextReader.GetAttribute("id");
				string attribute2 = xmlTextReader.GetAttribute("text");
				m_textTable.Add(attribute, attribute2);
			}
		}
		xmlTextReader.Close();
	}

	public string Translate(string id)
	{
		if (m_textTable == null)
		{
			Load();
		}
		object obj = m_textTable[id];
		if (obj != null)
		{
			return (string)obj;
		}
		return string.Empty;
	}

	public bool HasWord(string id)
	{
		if (m_textTable == null)
		{
			Load();
		}
		return m_textTable[id] != null;
	}
}
namespace UnityEngine
{
	public static class Util
	{
		public static string Translate(this string str)
		{
			if (!string.IsNullOrEmpty(str))
			{
				return Singleton<TextHelper>.Instance.Translate(str);
			}
			return string.Empty;
		}

		public static bool CanTranslate(this string str)
		{
			if (!string.IsNullOrEmpty(str))
			{
				return Singleton<TextHelper>.Instance.HasWord(str);
			}
			return false;
		}
	}
}
public static class XmlHelper
{
	private const string sm_value = "value";

	public static XmlDocument GetXmlDocument(string xmlAssetPath)
	{
		TextAsset textAsset = (TextAsset)Resources.Load(xmlAssetPath);
		XmlDocument xmlDocument = new XmlDocument();
		xmlDocument.LoadXml(textAsset.text);
		Resources.UnloadAsset(textAsset);
		textAsset = null;
		return xmlDocument;
	}

	public static XmlTextReader GetXmlTextReader(string xmlAssetPath)
	{
		TextAsset textAsset = (TextAsset)Resources.Load(xmlAssetPath);
		XmlTextReader result = new XmlTextReader(new StringReader(textAsset.text));
		Resources.UnloadAsset(textAsset);
		textAsset = null;
		return result;
	}

	public static string GetStringParam(XmlNode parentNode, string paramName)
	{
		foreach (XmlNode childNode in parentNode.ChildNodes)
		{
			if (childNode.Name == paramName)
			{
				XmlNode xmlNode2 = childNode.Attributes["value"];
				if (xmlNode2 != null)
				{
					return xmlNode2.Value;
				}
			}
		}
		return string.Empty;
	}

	public static float GetFloatParam(XmlNode parentNode, string paramName)
	{
		string stringParam = GetStringParam(parentNode, paramName);
		float.TryParse(stringParam, out var result);
		return result;
	}

	public static int GetIntParam(XmlNode parentNode, string paramName)
	{
		string stringParam = GetStringParam(parentNode, paramName);
		int.TryParse(stringParam, out var result);
		return result;
	}

	public static object GetEnumParam(XmlNode parentNode, string paramName, Type enumType)
	{
		string stringParam = GetStringParam(parentNode, paramName);
		return Enum.Parse(enumType, stringParam);
	}

	public static XmlNode CreateNode(XmlDocument doc, string nodeName, string attributeName, string attributeValue)
	{
		XmlNode xmlNode = doc.CreateNode("element", nodeName, string.Empty);
		XmlAttribute xmlAttribute = doc.CreateAttribute(attributeName);
		xmlAttribute.Value = attributeValue;
		xmlNode.Attributes.Append(xmlAttribute);
		return xmlNode;
	}

	public static XmlNode AppendChild(this XmlNode node, string nodeName, string value)
	{
		return node.AppendChild(CreateNode(node.OwnerDocument, nodeName, "value", value));
	}

	public static XmlNode AppendChild(this XmlNode node, string nodeName, string attributeName, string attributeValue)
	{
		return node.AppendChild(CreateNode(node.OwnerDocument, nodeName, attributeName, attributeValue));
	}

	public static XmlNode FindNode(this XmlNode node, string nodeName)
	{
		foreach (XmlNode childNode in node.ChildNodes)
		{
			if (childNode.Name == nodeName)
			{
				return childNode;
			}
		}
		return null;
	}

	public static XmlNode FindNodeWithAttribute(this XmlNode node, string nodeName, string attributeName, string attributeValue)
	{
		foreach (XmlNode childNode in node.ChildNodes)
		{
			if (!(childNode.Name == nodeName))
			{
				continue;
			}
			foreach (XmlAttribute attribute in childNode.Attributes)
			{
				if (attribute.Name == attributeName && attribute.Value == attributeValue)
				{
					return childNode;
				}
			}
		}
		return null;
	}
}
public class MenuManager : Singleton<MenuManager>
{
	public delegate void MenuDelegate();

	public MenuDelegate OnMenuLoadedEvent;

	[SerializeField]
	private GameObject m_crosshair;

	private bool m_shouldShow;

	public GameObject GetCrosshair()
	{
		return m_crosshair;
	}

	protected void Start()
	{
		ShowCrosshair(show: false);
	}

	public void ShowCrosshair(bool show)
	{
		m_shouldShow = show;
	}

	private void Update()
	{
		if (m_shouldShow && !m_crosshair.activeInHierarchy && InputUtils.IsTrackedRemoteActive())
		{
			m_crosshair.SetActive(value: true);
		}
		else if (m_crosshair.activeInHierarchy && (!m_shouldShow || !InputUtils.IsTrackedRemoteActive()))
		{
			m_crosshair.SetActive(value: false);
		}
	}

	public void OnMenuLoaded()
	{
		if (OnMenuLoadedEvent != null)
		{
			OnMenuLoadedEvent();
		}
	}
}
public class CameraUIInteraction : MonoBehaviour
{
	[SerializeField]
	private Transform pointerTransform;

	[SerializeField]
	private UICrosshair crosshair;

	private UIButtonColor m_hoveredButton;

	private Collider m_hoverCollider;

	private int m_uiLayermask;

	private Transform camTrans;

	public Collider HoveredCollider => m_hoverCollider;

	private void Start()
	{
		camTrans = Singleton<CameraManager>.Instance.GetCamera();
		m_uiLayermask = 1 << LayerMask.NameToLayer("UI");
	}

	public void CheckIfHoveringOverExitButton(UIButton exitButton)
	{
		if (exitButton == m_hoveredButton)
		{
			m_hoveredButton.SendMessage("OnHover", true);
		}
	}

	private void Update()
	{
		if (Singleton<LoadingScreen>.TryInstance() || Singleton<GameManager>.Instance.State == GameManager.GameState.Tutorial)
		{
			if (m_hoveredButton != null && m_hoveredButton.gameObject.activeInHierarchy)
			{
				m_hoveredButton.SendMessage("OnHover", false);
			}
			SetHighlighted(null);
			return;
		}
		Vector3 position = camTrans.position;
		Vector3 direction = crosshair.gameObject.transform.position - camTrans.position;
		Physics.Raycast(position, direction, out var hitInfo, float.PositiveInfinity, m_uiLayermask);
		if ((bool)hitInfo.collider && hitInfo.collider != m_hoverCollider)
		{
			if (m_hoveredButton != null && m_hoveredButton.gameObject.activeInHierarchy)
			{
				m_hoveredButton.SendMessage("OnHover", false);
			}
			SetHighlighted(hitInfo.collider);
			if (m_hoveredButton != null)
			{
				if (m_hoveredButton.CompareTag("MissionSelection"))
				{
					NGUIMissionListCell component = m_hoveredButton.GetComponent<NGUIMissionListCell>();
					if (!component.IsMissionLocked())
					{
						m_hoveredButton.SendMessage("OnHover", true);
						Singleton<AudioManager>.Instance.Play(AudioEvent.EvtGUI_FE_Highlight);
					}
				}
				else
				{
					m_hoveredButton.SendMessage("OnHover", true);
					Singleton<AudioManager>.Instance.Play(AudioEvent.EvtGUI_FE_Highlight);
				}
			}
		}
		else if (!hitInfo.collider && (bool)m_hoverCollider)
		{
			if ((bool)m_hoveredButton && m_hoveredButton.gameObject.activeInHierarchy)
			{
				m_hoveredButton.SendMessage("OnHover", false);
			}
			SetHighlighted(null);
		}
		if (m_hoveredButton != null && InputUtils.GetMenuButtonPressed() && Singleton<GameManager>.Instance.Button1State == GameManager.InputButtonState.NotPressed)
		{
			m_hoveredButton.SendMessage("OnClick");
		}
	}

	private void SetHighlighted(Collider newHit)
	{
		if (newHit == null)
		{
			m_hoveredButton = null;
			m_hoverCollider = null;
		}
		else
		{
			m_hoveredButton = newHit.GetComponent<UIButtonColor>();
			m_hoverCollider = newHit;
		}
	}
}
public enum InGameMenuType
{
	Pause,
	BonusIntro,
	Score
}
public class InGameUIManager : Singleton<InGameUIManager>
{
	[SerializeField]
	private UIPanel pauseMenu;

	[SerializeField]
	private UIPanel bonusIntroScreen;

	[SerializeField]
	private UIPanel scoreScreen;

	[SerializeField]
	private NGUICockpit cockpitUI;

	private NGUICockpit.CockpitGUIRenderSetting guiStats = new NGUICockpit.CockpitGUIRenderSetting();

	public bool CanShowPauseScreen => !bonusIntroScreen.cachedGameObject.activeInHierarchy && !scoreScreen.cachedGameObject.activeInHierarchy;

	public void SetupPauseMenu(Turret turret)
	{
		Transform parent = null;
		Vector3 localPosition = new Vector3(0f, 0f, 5f);
		Quaternion localRotation = Quaternion.Euler(new Vector3(0f, 180f, 0f));
		if ((bool)turret)
		{
			parent = turret.transform;
			if ((bool)turret.textPlane)
			{
				parent = turret.textPlane.parent;
				localRotation = turret.textPlane.localRotation;
				localPosition = turret.textPlane.localPosition + new Vector3(0f, 0f, 0.1f);
			}
		}
		pauseMenu.cachedTransform.parent = parent;
		pauseMenu.cachedTransform.localPosition = localPosition;
		pauseMenu.cachedTransform.localRotation = localRotation;
		pauseMenu.cachedGameObject.SetActive(value: false);
		scoreScreen.cachedTransform.parent = parent;
		scoreScreen.cachedTransform.localPosition = localPosition;
		scoreScreen.cachedTransform.localRotation = localRotation;
		scoreScreen.cachedGameObject.SetActive(value: false);
		bonusIntroScreen.cachedTransform.parent = parent;
		bonusIntroScreen.cachedTransform.localPosition = localPosition;
		bonusIntroScreen.cachedTransform.localRotation = localRotation;
		bonusIntroScreen.cachedGameObject.SetActive(value: false);
		cockpitUI.transform.position = new Vector3(0f, 20f, 0f);
	}

	public void InitialiseCockpit(NGUICockpit.CockpitGUIRenderSetting stats, Turret playerTurret)
	{
		guiStats = stats;
		cockpitUI.InitStats(guiStats);
		playerTurret.GUIScreenRenderer.material.mainTexture = cockpitUI.GUITexture;
	}

	private IEnumerator FadeMenu(UIPanel menu, float fadeSpeed, bool fadingIn)
	{
		if (!menu)
		{
			yield break;
		}
		menu.cachedGameObject.SetActive(value: true);
		float alpha = (fadingIn ? 1 : 0);
		if (fadingIn)
		{
			while (!Mathf.Approximately(alpha, 1f))
			{
				alpha = (menu.alpha = Mathf.Min(1f, alpha + Time.deltaTime * fadeSpeed));
				yield return null;
			}
			Singleton<MenuManager>.Instance.ShowCrosshair(show: true);
			yield break;
		}
		Singleton<MenuManager>.Instance.ShowCrosshair(show: false);
		while (!Mathf.Approximately(alpha, 0f))
		{
			alpha = (menu.alpha = Mathf.Max(0f, alpha - Time.deltaTime * fadeSpeed));
			yield return null;
		}
		menu.cachedGameObject.SetActive(value: false);
	}

	public void FadeMenu(InGameMenuType menuType, float fadeTime, bool fadingIn)
	{
		switch (menuType)
		{
		case InGameMenuType.Pause:
			StartCoroutine(FadeMenu(pauseMenu, fadeTime, fadingIn));
			break;
		case InGameMenuType.BonusIntro:
			StartCoroutine(FadeMenu(bonusIntroScreen, fadeTime, fadingIn));
			break;
		case InGameMenuType.Score:
			StartCoroutine(FadeMenu(scoreScreen, fadeTime, fadingIn));
			break;
		}
	}

	public void UpdateCockpitUI()
	{
		if (guiStats.hasTimer)
		{
			guiStats.timeLeft = Mathf.FloorToInt(Singleton<MissionManager>.Instance.RemainingTime);
		}
		if (Singleton<MissionManager>.Instance.TimeLimit != TimeLimit.Survival)
		{
			KillPlaneMap[] enemiesKilled = Singleton<MissionManager>.Instance.EnemiesKilled;
			guiStats.UpdateKills(0, enemiesKilled[0].m_count);
			if (enemiesKilled.Length > 1)
			{
				guiStats.UpdateKills(1, enemiesKilled[1].m_count);
			}
			else if (Singleton<MissionManager>.Instance.WinCondition != 0)
			{
				guiStats.UpdateKills(1, Singleton<MissionManager>.Instance.FriendsKilled);
			}
		}
		if (guiStats.Dirty)
		{
			cockpitUI.UpdateStats(guiStats);
			guiStats.Dirty = false;
		}
	}
}
public class NGUIBonusDescriptionLabel : MonoBehaviour
{
	private void Start()
	{
		UILabel component = GetComponent<UILabel>();
		if ((bool)component)
		{
			component.text = string.Format("bonus_info_description1".Translate(), "bonus_info_location_london".Translate()) + "\n\n" + string.Format("bonus_info_description2".Translate(), "bonus_info_enemy_v2".Translate(), Singleton<MissionManager>.Instance.CurrentMissionSettings.Time) + "\n\n\n" + "bonus_info_continue".Translate();
		}
	}
}
public class NGUICockpit : MonoBehaviour
{
	public class CockpitPlaneDisplayType
	{
		public int m_kills;

		public int m_total;

		public string m_icon = string.Empty;
	}

	public class CockpitGUIRenderSetting
	{
		private bool m_dirty = true;

		private int m_timeLeft = -1;

		private CockpitPlaneDisplayType[] planes;

		public int PlaneTypeCount;

		public bool Dirty
		{
			get
			{
				return m_dirty;
			}
			set
			{
				m_dirty = value;
			}
		}

		public bool hasTimer => m_timeLeft != -1;

		public int timeLeft
		{
			get
			{
				return m_timeLeft;
			}
			set
			{
				if (m_timeLeft != value)
				{
					m_timeLeft = value;
					m_dirty = true;
				}
			}
		}

		public CockpitPlaneDisplayType[] PlaneTypes => planes;

		public CockpitGUIRenderSetting()
		{
			Reset();
		}

		public void InitPlaneType(int planeType, int count, string iconName)
		{
			planes[planeType].m_total = count;
			planes[planeType].m_icon = iconName;
			m_dirty = true;
			UpdatePlaneTypeCount();
		}

		public void UpdateKills(int planeType, int count)
		{
			if (planes[planeType].m_kills != count)
			{
				planes[planeType].m_kills = count;
				m_dirty = true;
			}
		}

		private void UpdatePlaneTypeCount()
		{
			int num = 0;
			for (int i = 0; i < 2; i++)
			{
				if (planes[i].m_total > 0)
				{
					num++;
				}
			}
			PlaneTypeCount = num;
		}

		public void Reset()
		{
			m_timeLeft = -1;
			planes = new CockpitPlaneDisplayType[2];
			for (int i = 0; i < 2; i++)
			{
				planes[i] = new CockpitPlaneDisplayType();
			}
		}
	}

	[SerializeField]
	private UITable m_singleTable;

	[SerializeField]
	private UISprite m_singlePic;

	[SerializeField]
	private UILabel m_singleLabel;

	[SerializeField]
	private GameObject m_twoDivider;

	[SerializeField]
	private UISprite m_twoTopSprite;

	[SerializeField]
	private UILabel m_twoTopLabel;

	[SerializeField]
	private UISprite m_twoBottomSpritePlane;

	[SerializeField]
	private UILabel m_twoBottomLabelPlane;

	[SerializeField]
	private UISprite m_twoBottomSpriteTimer;

	[SerializeField]
	private UILabel m_twoBottomLabelTimer;

	[SerializeField]
	private GameObject m_threeDivider;

	[SerializeField]
	private UISprite m_threeLeftSprite;

	[SerializeField]
	private UILabel m_threeLeftLabel;

	[SerializeField]
	private UISprite m_threeRightSprite;

	[SerializeField]
	private UILabel m_threeRightLabel;

	[SerializeField]
	private UISprite m_threeTimerSprite;

	[SerializeField]
	private UILabel m_threeTimerLabel;

	private int m_layoutType = 1;

	private RenderTexture m_texture;

	private Camera m_camera;

	public RenderTexture GUITexture => m_texture;

	private void Start()
	{
		m_texture = new RenderTexture(512, 512, 0);
		m_texture.wrapMode = TextureWrapMode.Repeat;
		m_texture.Create();
		m_camera = GetComponentInChildren<Camera>();
		if ((bool)m_camera)
		{
			m_camera.targetTexture = m_texture;
		}
	}

	public void InitStats(CockpitGUIRenderSetting stats)
	{
		m_layoutType = stats.PlaneTypeCount + (stats.hasTimer ? 1 : 0);
		m_singleTable.gameObject.SetActive(value: false);
		m_twoDivider.SetActive(value: false);
		m_threeDivider.SetActive(value: false);
		switch (m_layoutType)
		{
		case 1:
			m_singleTable.gameObject.SetActive(value: true);
			if (stats.hasTimer)
			{
				m_singlePic.spriteName = "bsui-ig-timer-icon";
				m_singlePic.MakePixelPerfect();
				string text3 = string.Empty;
				int num5 = stats.timeLeft % 60;
				int num6 = (stats.timeLeft - num5) / 60;
				if (num6 < 10)
				{
					text3 += "0";
				}
				text3 += num6;
				text3 += ":";
				if (num5 < 10)
				{
					text3 += 0;
				}
				text3 += num5;
				m_singleLabel.text = text3;
			}
			else
			{
				m_singlePic.spriteName = stats.PlaneTypes[0].m_icon;
				m_singlePic.MakePixelPerfect();
				m_singleLabel.text = stats.PlaneTypes[0].m_kills + "/" + stats.PlaneTypes[0].m_total;
			}
			m_singleTable.Reposition();
			break;
		case 2:
		{
			m_twoDivider.SetActive(value: true);
			m_twoTopSprite.spriteName = stats.PlaneTypes[0].m_icon;
			m_twoTopSprite.MakePixelPerfect();
			m_twoTopLabel.text = stats.PlaneTypes[0].m_kills + "/" + stats.PlaneTypes[0].m_total;
			m_twoBottomSpritePlane.gameObject.SetActive(value: false);
			m_twoBottomLabelPlane.gameObject.SetActive(value: false);
			m_twoBottomSpriteTimer.gameObject.SetActive(value: false);
			m_twoBottomLabelTimer.gameObject.SetActive(value: false);
			if (stats.PlaneTypeCount > 1)
			{
				m_twoBottomSpritePlane.gameObject.SetActive(value: true);
				m_twoBottomSpritePlane.spriteName = stats.PlaneTypes[1].m_icon;
				m_twoBottomSpritePlane.MakePixelPerfect();
				m_twoBottomLabelPlane.gameObject.SetActive(value: true);
				m_twoBottomLabelPlane.text = stats.PlaneTypes[1].m_kills + "/" + stats.PlaneTypes[1].m_total;
				break;
			}
			m_twoBottomSpriteTimer.gameObject.SetActive(value: true);
			m_twoBottomSpriteTimer.spriteName = "bsui-ig-timer-icon";
			m_twoBottomSpriteTimer.MakePixelPerfect();
			string text2 = string.Empty;
			int num3 = stats.timeLeft % 60;
			int num4 = (stats.timeLeft - num3) / 60;
			if (num4 < 10)
			{
				text2 += "0";
			}
			text2 += num4;
			text2 += ":";
			if (num3 < 10)
			{
				text2 += 0;
			}
			text2 += num3;
			m_twoBottomLabelTimer.gameObject.SetActive(value: true);
			m_twoBottomLabelTimer.text = text2;
			break;
		}
		case 3:
		{
			m_threeDivider.SetActive(value: true);
			m_threeLeftSprite.spriteName = stats.PlaneTypes[0].m_icon;
			m_threeLeftSprite.MakePixelPerfect();
			m_threeLeftLabel.text = stats.PlaneTypes[0].m_kills + "/" + stats.PlaneTypes[0].m_total;
			m_threeRightSprite.spriteName = stats.PlaneTypes[1].m_icon;
			m_threeRightSprite.MakePixelPerfect();
			m_threeRightLabel.text = stats.PlaneTypes[1].m_kills + "/" + stats.PlaneTypes[1].m_total;
			m_threeTimerSprite.spriteName = "bsui-ig-timer-icon";
			m_threeTimerSprite.MakePixelPerfect();
			string text = string.Empty;
			int num = stats.timeLeft % 60;
			int num2 = (stats.timeLeft - num) / 60;
			if (num2 < 10)
			{
				text += "0";
			}
			text += num2;
			text += ":";
			if (num < 10)
			{
				text += 0;
			}
			text += num;
			m_threeTimerLabel.text = text;
			break;
		}
		}
	}

	public void UpdateStats(CockpitGUIRenderSetting stats)
	{
		switch (m_layoutType)
		{
		case 1:
			if (stats.hasTimer)
			{
				string text4 = string.Empty;
				int num5 = stats.timeLeft % 60;
				int num6 = (stats.timeLeft - num5) / 60;
				if (num6 < 10)
				{
					text4 += "0";
				}
				text4 += num6;
				text4 += ":";
				if (num5 < 10)
				{
					text4 += 0;
				}
				text4 += num5;
				m_singleLabel.text = text4;
			}
			else
			{
				m_singleLabel.text = stats.PlaneTypes[0].m_kills + "/" + stats.PlaneTypes[0].m_total;
			}
			break;
		case 2:
		{
			m_twoTopLabel.text = stats.PlaneTypes[0].m_kills + "/" + stats.PlaneTypes[0].m_total;
			if (stats.PlaneTypeCount > 1)
			{
				string text2 = ((Singleton<MissionManager>.Instance.WinCondition != WinCondition.Protect) ? stats.PlaneTypes[1].m_kills.ToString() : (stats.PlaneTypes[1].m_total - stats.PlaneTypes[1].m_kills).ToString());
				m_twoBottomLabelPlane.text = text2 + "/" + stats.PlaneTypes[1].m_total;
				break;
			}
			string text3 = string.Empty;
			int num3 = stats.timeLeft % 60;
			int num4 = (stats.timeLeft - num3) / 60;
			if (num4 < 10)
			{
				text3 += "0";
			}
			text3 += num4;
			text3 += ":";
			if (num3 < 10)
			{
				text3 += 0;
			}
			text3 += num3;
			m_twoBottomLabelTimer.text = text3;
			break;
		}
		case 3:
		{
			m_threeLeftLabel.text = stats.PlaneTypes[0].m_kills + "/" + stats.PlaneTypes[0].m_total;
			m_threeRightLabel.text = stats.PlaneTypes[1].m_kills + "/" + stats.PlaneTypes[1].m_total;
			string text = string.Empty;
			int num = stats.timeLeft % 60;
			int num2 = (stats.timeLeft - num) / 60;
			if (num2 < 10)
			{
				text += "0";
			}
			text += num2;
			text += ":";
			if (num < 10)
			{
				text += 0;
			}
			text += num;
			m_threeTimerLabel.text = text;
			break;
		}
		}
		if ((bool)m_camera)
		{
			StartCoroutine(RenderCam());
		}
	}

	private IEnumerator RenderCam()
	{
		yield return new WaitForEndOfFrame();
		yield return new WaitForEndOfFrame();
		m_camera.Render();
	}
}
public class NGUIFlyingScore : MonoBehaviour
{
	[SerializeField]
	private UILabel m_score;

	[SerializeField]
	private UILabel m_bonus;

	[SerializeField]
	private UILabel m_multiplier;

	[SerializeField]
	private UILabel m_killsProgress;

	[SerializeField]
	private float m_showTime = 3f;

	[SerializeField]
	private float m_fadeSpeed = 1f;

	[SerializeField]
	private float m_verticalOffset = 100f;

	[SerializeField]
	private float m_scaleMultiplier = 1f;

	[SerializeField]
	private UnityEngine.Color m_powerupMainTextColour = UnityEngine.Color.yellow;

	[SerializeField]
	private UnityEngine.Color m_powerupSecondaryTextColour = UnityEngine.Color.green;

	[HideInInspector]
	private Transform _transform;

	private Vector3 verticalSpeed = Vector3.zero;

	private float m_scale = 1f;

	private UnityEngine.Color[] m_originalColours = new UnityEngine.Color[4];

	public float Scale
	{
		get
		{
			return m_scale;
		}
		set
		{
			m_scale = value * m_scaleMultiplier;
		}
	}

	private void Awake()
	{
		ref UnityEngine.Color reference = ref m_originalColours[0];
		reference = m_score.color;
		ref UnityEngine.Color reference2 = ref m_originalColours[1];
		reference2 = m_bonus.color;
		ref UnityEngine.Color reference3 = ref m_originalColours[2];
		reference3 = m_multiplier.color;
		ref UnityEngine.Color reference4 = ref m_originalColours[3];
		reference4 = m_killsProgress.color;
		_transform = base.transform;
	}

	private void Update()
	{
		_transform.localScale = Vector3.one * m_scale;
		_transform.position += verticalSpeed * Time.deltaTime;
	}

	public void Refresh(int score, int bonus, int multiplier, int killsProgress, int killsRequired)
	{
		m_score.text = score.ToString();
		if (multiplier > 1)
		{
			m_score.color = m_powerupMainTextColour;
			UILabel bonus2 = m_bonus;
			UnityEngine.Color powerupSecondaryTextColour = m_powerupSecondaryTextColour;
			m_killsProgress.color = powerupSecondaryTextColour;
			powerupSecondaryTextColour = powerupSecondaryTextColour;
			m_multiplier.color = powerupSecondaryTextColour;
			bonus2.color = powerupSecondaryTextColour;
		}
		else
		{
			m_score.color = m_originalColours[0];
			m_bonus.color = m_originalColours[1];
			m_multiplier.color = m_originalColours[2];
			m_killsProgress.color = m_originalColours[3];
		}
		m_bonus.gameObject.SetActive(bonus > 0);
		if (bonus > 0)
		{
			m_bonus.text = "+" + bonus;
		}
		m_multiplier.gameObject.SetActive(multiplier > 1);
		if (multiplier > 1)
		{
			m_multiplier.text = "x" + multiplier;
		}
		m_killsProgress.gameObject.SetActive(killsRequired > 0);
		if (killsRequired > 0)
		{
			m_killsProgress.text = killsProgress + "/" + killsRequired;
		}
	}

	public void StartShowing()
	{
		StartCoroutine(StartShowingCoroutine(m_showTime, m_fadeSpeed));
		verticalSpeed = new Vector3(0f, m_verticalOffset * m_scale, 0f);
	}

	private IEnumerator StartShowingCoroutine(float showTime, float fadeSpeed)
	{
		UIPanel panel = GetComponent<UIPanel>();
		float alpha = 0f;
		while (!Mathf.Approximately(1f, alpha))
		{
			alpha = (panel.alpha = Mathf.Min(1f, alpha + Time.deltaTime * fadeSpeed));
			yield return null;
		}
		yield return new WaitForSeconds(showTime);
		while (!Mathf.Approximately(0f, alpha))
		{
			alpha = (panel.alpha = Mathf.Max(0f, alpha - Time.deltaTime * fadeSpeed));
			yield return null;
		}
		Singleton<FlyingScorePool>.Instance.ReturnToPool(this);
	}
}
public class NGUIPauseMenuButton : MonoBehaviour
{
	[SerializeField]
	private Texture buttonHoverTexture;

	[SerializeField]
	private Texture buttonNotHoverTexture;

	private UITexture uiTexture;

	private void Awake()
	{
		uiTexture = GetComponent<UITexture>();
	}

	private void OnHover(bool hover)
	{
		if (hover)
		{
			Singleton<AudioManager>.Instance.Play(AudioEvent.EvtGUI_FE_Select, null, canBePaused: false);
			uiTexture.mainTexture = buttonHoverTexture;
		}
		else
		{
			uiTexture.mainTexture = buttonNotHoverTexture;
		}
	}
}
public class NGUIPauseScreen : MonoBehaviour
{
	[SerializeField]
	private UIButton m_restartButton;

	[SerializeField]
	private UIButton m_quitButton;

	[SerializeField]
	private UISprite m_emblem;

	private void OnEnable()
	{
		m_restartButton.isEnabled = !Singleton<MissionManager>.Instance.DoingBonusMission;
	}

	public void Resume()
	{
		Singleton<GameManager>.Instance.PerformPauseMenuSelection(GameManager.PauseOptions.Resume);
	}

	public void Restart()
	{
		Singleton<GameManager>.Instance.PerformPauseMenuSelection(GameManager.PauseOptions.RestartMission);
	}

	public void Quit()
	{
		Singleton<GameManager>.Instance.PerformPauseMenuSelection(GameManager.PauseOptions.QuitGame);
	}
}
public class NGUIScoreScreen : MonoBehaviour
{
	public class ScoreRenderSetting
	{
		public bool wasVictory;

		public string[] leftColumn;

		public string[] rightColumn;

		public int smallMessages;

		public bool showingStarsAtEnd = true;
	}

	[SerializeField]
	private UILabel m_titleLabel;

	[SerializeField]
	private UITable m_bigMedalTable;

	[SerializeField]
	private UITable m_smallMedalTop;

	[SerializeField]
	private UITable m_smallMedalBottom;

	[SerializeField]
	private UIButton m_retryButton;

	[SerializeField]
	private UIButton m_exitButton;

	[SerializeField]
	private UIButton m_bonusButton;

	[SerializeField]
	private UIButton m_continueButton;

	[SerializeField]
	private UISprite m_medalPrefab;

	[SerializeField]
	private int m_maxBigMedals = 4;

	[SerializeField]
	private float m_medalScale = 0.6f;

	[SerializeField]
	private UIPanel m_tooltipParent;

	[SerializeField]
	private UILabel m_tooltipLabel;

	[SerializeField]
	private UILabel m_scoreLabelPrefab;

	[SerializeField]
	private UISprite m_scoreSeparatorPrefab;

	[SerializeField]
	private UITable m_statsTable;

	[SerializeField]
	private GameObject m_statsTableSeparator;

	[SerializeField]
	private UITable m_smallStatsTable;

	[SerializeField]
	private UITable m_bigStatsTable;

	[SerializeField]
	private GameObject m_starRatingDisplay;

	[SerializeField]
	private GameObject m_starsParent;

	[SerializeField]
	private float m_buttonActivationDelay = 1f;

	[SerializeField]
	private AudioEvent m_winSoundEvent = AudioEvent.EvtFanfare;

	[SerializeField]
	private AudioEvent m_loseSoundEvent = AudioEvent.EvtFanfare_Fail;

	private List<int> m_medals = new List<int>();

	private List<Collider> m_medalColliders = new List<Collider>();

	private static ScoreRenderSetting m_scoreSettings;

	private Collider m_currentHover;

	private float m_tooltipAlpha;

	private CameraUIInteraction cameraSomething;

	public static ScoreRenderSetting CurrentScoreSettings
	{
		set
		{
			m_scoreSettings = value;
		}
	}

	private void OnEnable()
	{
		Refresh();
		if (m_scoreSettings != null)
		{
			if (m_scoreSettings.wasVictory)
			{
				Singleton<AudioManager>.Instance.Play(m_winSoundEvent);
			}
			else
			{
				Singleton<AudioManager>.Instance.Play(m_loseSoundEvent);
			}
			StartCoroutine(EnableButtonsAfterDelay(m_buttonActivationDelay));
			cameraSomething = Singleton<CameraManager>.Instance.cameraSomething;
			if ((bool)cameraSomething)
			{
				cameraSomething.enabled = true;
			}
		}
	}

	private IEnumerator EnableButtonsAfterDelay(float delay)
	{
		yield return new WaitForSeconds(delay);
		if (m_retryButton.gameObject.activeInHierarchy)
		{
			m_retryButton.isEnabled = true;
		}
		if (m_exitButton.gameObject.activeInHierarchy)
		{
			m_exitButton.isEnabled = true;
		}
		if (m_bonusButton.gameObject.activeInHierarchy)
		{
			m_bonusButton.isEnabled = true;
		}
		if (m_continueButton.gameObject.activeInHierarchy)
		{
			m_continueButton.isEnabled = true;
		}
	}

	private void Refresh()
	{
		if (m_scoreSettings == null)
		{
			return;
		}
		if (m_scoreSettings.wasVictory)
		{
			if (Singleton<MissionManager>.Instance.ShallWeBonus())
			{
				ShowBonusButtons();
			}
			else if (Singleton<Profile>.Instance.Progress.CanSeeEnding())
			{
				ShowEndingButtons();
			}
			else
			{
				ShowNormalButtons();
			}
		}
		else
		{
			ShowNormalButtons();
		}
		if (m_retryButton.gameObject.activeInHierarchy)
		{
			m_retryButton.SetState(UIButtonColor.State.Disabled, immediate: true);
			m_retryButton.isEnabled = false;
		}
		if (m_exitButton.gameObject.activeInHierarchy)
		{
			m_exitButton.SetState(UIButtonColor.State.Disabled, immediate: true);
			m_exitButton.isEnabled = false;
		}
		if (m_bonusButton.gameObject.activeInHierarchy)
		{
			m_bonusButton.SetState(UIButtonColor.State.Disabled, immediate: true);
			m_bonusButton.isEnabled = false;
		}
		if (m_continueButton.gameObject.activeInHierarchy)
		{
			m_continueButton.SetState(UIButtonColor.State.Disabled, immediate: true);
			m_continueButton.isEnabled = false;
		}
		m_titleLabel.text = ((!m_scoreSettings.wasVictory) ? "score_label_defeat" : "score_label_victory").Translate();
		for (int i = 0; i < m_smallStatsTable.transform.childCount; i++)
		{
			UnityEngine.Object.Destroy(m_smallStatsTable.transform.GetChild(i).gameObject);
		}
		m_smallStatsTable.transform.DetachChildren();
		for (int j = 0; j < m_bigStatsTable.transform.childCount; j++)
		{
			UnityEngine.Object.Destroy(m_bigStatsTable.transform.GetChild(j).gameObject);
		}
		m_bigStatsTable.transform.DetachChildren();
		int num = m_scoreSettings.leftColumn.Length;
		if (m_scoreSettings.showingStarsAtEnd)
		{
			num--;
		}
		for (int k = 0; k < num; k++)
		{
			bool flag = k < m_scoreSettings.smallMessages;
			UILabel uILabel = UnityEngine.Object.Instantiate(m_scoreLabelPrefab);
			UILabel component = uILabel.transform.GetChild(0).GetComponent<UILabel>();
			uILabel.text = m_scoreSettings.leftColumn[k];
			component.text = m_scoreSettings.rightColumn[k];
			int fontSize = (component.fontSize = ((!flag) ? 40 : 30));
			uILabel.fontSize = fontSize;
			fontSize = (component.spacingY = -uILabel.fontSize / 5);
			uILabel.spacingY = fontSize;
			uILabel.transform.parent = ((!flag) ? m_bigStatsTable : m_smallStatsTable).transform;
			uILabel.transform.localPosition = Vector3.zero;
			uILabel.transform.localRotation = Quaternion.identity;
			uILabel.transform.localScale = Vector3.one;
			if ((flag && k < m_scoreSettings.smallMessages - 1) || (!flag && k < num - 1))
			{
				UISprite uISprite = UnityEngine.Object.Instantiate(m_scoreSeparatorPrefab);
				uISprite.transform.parent = ((!flag) ? m_bigStatsTable : m_smallStatsTable).transform;
				uISprite.transform.localPosition = Vector3.zero;
				uISprite.transform.localRotation = Quaternion.identity;
				uISprite.transform.localScale = Vector3.one;
			}
		}
		m_starRatingDisplay.SetActive(m_scoreSettings.showingStarsAtEnd);
		if (m_scoreSettings.showingStarsAtEnd)
		{
			int num4 = int.Parse(m_scoreSettings.rightColumn[m_scoreSettings.rightColumn.Length - 1]);
			UISprite[] componentsInChildren = m_starsParent.GetComponentsInChildren<UISprite>();
			for (int l = 0; l < componentsInChildren.Length; l++)
			{
				if (l < num4)
				{
					componentsInChildren[l].spriteName = "bsui-star";
				}
				else
				{
					componentsInChildren[l].spriteName = "bsui-star-empty";
				}
			}
		}
		m_statsTableSeparator.SetActive(m_scoreSettings.smallMessages > 0 && m_scoreSettings.leftColumn.Length > m_scoreSettings.smallMessages);
		m_smallStatsTable.Reposition();
		m_bigStatsTable.Reposition();
		m_statsTable.Reposition();
		m_medalColliders.Clear();
		m_medals.Clear();
		int[] totalMedals = Singleton<PlayerScore>.Instance.TotalMedals;
		for (int m = 0; m < totalMedals.Length; m++)
		{
			if (totalMedals[m] != 0)
			{
				m_medals.Add(m);
			}
		}
		for (int n = 0; n < m_bigMedalTable.transform.childCount; n++)
		{
			UnityEngine.Object.Destroy(m_bigMedalTable.transform.GetChild(n).gameObject);
		}
		m_bigMedalTable.transform.DetachChildren();
		for (int num5 = 0; num5 < m_smallMedalTop.transform.childCount; num5++)
		{
			UnityEngine.Object.Destroy(m_smallMedalTop.transform.GetChild(num5).gameObject);
		}
		m_smallMedalTop.transform.DetachChildren();
		for (int num6 = 0; num6 < m_smallMedalBottom.transform.childCount; num6++)
		{
			UnityEngine.Object.Destroy(m_smallMedalBottom.transform.GetChild(num6).gameObject);
		}
		m_smallMedalBottom.transform.DetachChildren();
		bool flag2 = m_medals.Count > m_maxBigMedals;
		for (int num7 = 0; num7 < m_medals.Count; num7++)
		{
			UISprite uISprite2 = UnityEngine.Object.Instantiate(m_medalPrefab);
			if (flag2)
			{
				uISprite2.transform.parent = ((num7 > m_medals.Count / 2) ? m_smallMedalBottom : m_smallMedalTop).transform;
			}
			else
			{
				uISprite2.transform.parent = m_bigMedalTable.transform;
			}
			uISprite2.transform.localPosition = Vector3.zero;
			uISprite2.transform.localRotation = Quaternion.identity;
			uISprite2.spriteName = GetMedalSprite(m_medals[num7]);
			uISprite2.MakePixelPerfect();
			uISprite2.width = (int)((float)uISprite2.width * m_medalScale);
			uISprite2.height = (int)((float)uISprite2.height * m_medalScale);
			m_medalColliders.Add(uISprite2.gameObject.GetComponent<Collider>());
		}
		if (flag2)
		{
			m_bigMedalTable.Reposition();
			return;
		}
		m_smallMedalTop.Reposition();
		m_smallMedalBottom.Reposition();
	}

	private void ShowNormalButtons()
	{
		if (Singleton<MissionManager>.Instance.JustCompletedBonusMission)
		{
			m_retryButton.gameObject.SetActive(value: false);
			m_exitButton.gameObject.SetActive(value: true);
			m_exitButton.transform.position = m_retryButton.transform.position;
			Singleton<MissionManager>.Instance.JustCompletedBonusMission = false;
		}
		else
		{
			m_retryButton.gameObject.SetActive(value: true);
			m_exitButton.gameObject.SetActive(value: true);
		}
		m_bonusButton.gameObject.SetActive(value: false);
		m_continueButton.gameObject.SetActive(value: false);
	}

	private void ShowBonusButtons()
	{
		m_retryButton.gameObject.SetActive(value: false);
		m_exitButton.gameObject.SetActive(value: false);
		m_bonusButton.gameObject.SetActive(value: true);
		m_continueButton.gameObject.SetActive(value: false);
	}

	private void ShowEndingButtons()
	{
		m_retryButton.gameObject.SetActive(value: false);
		m_exitButton.gameObject.SetActive(value: false);
		m_bonusButton.gameObject.SetActive(value: false);
		m_continueButton.gameObject.SetActive(value: true);
	}

	private void Update()
	{
		if (cameraSomething != null && m_currentHover != cameraSomething.HoveredCollider)
		{
			m_currentHover = null;
			for (int i = 0; i < m_medalColliders.Count; i++)
			{
				if (m_medalColliders[i].Equals(cameraSomething.HoveredCollider))
				{
					m_currentHover = cameraSomething.HoveredCollider;
					m_tooltipAlpha = 0f;
					UpdateTooltip(m_currentHover.gameObject, m_medals[i]);
					break;
				}
			}
		}
		if ((bool)m_currentHover && m_tooltipAlpha < 1f)
		{
			m_tooltipAlpha = Mathf.Min(1f, m_tooltipAlpha + Time.unscaledDeltaTime * 2f);
		}
		else if (!m_currentHover && m_tooltipAlpha > 0f)
		{
			m_tooltipAlpha = Mathf.Max(0f, m_tooltipAlpha - Time.unscaledDeltaTime * 2f);
		}
		m_tooltipParent.alpha = m_tooltipAlpha;
	}

	public void UpdateTooltip(GameObject medal, int id)
	{
		m_tooltipParent.transform.parent = medal.transform;
		m_tooltipParent.transform.localPosition = Vector3.zero;
		m_tooltipParent.transform.localRotation = Quaternion.identity;
		m_tooltipParent.transform.AddLocalZPosition(-1f);
		m_tooltipLabel.text = Singleton<PlayerScore>.Instance.GetBonusDescription(id);
	}

	public void RetryMission()
	{
		m_scoreSettings = null;
		Singleton<GameManager>.Instance.RestartMission();
	}

	public void ExitMission()
	{
		m_scoreSettings = null;
		Singleton<GameManager>.Instance.QuitGame();
	}

	public void BonusMission()
	{
		m_scoreSettings = null;
		Singleton<GameManager>.Instance.StartBonusMission();
	}

	public void StartEnding()
	{
		m_scoreSettings = null;
		Singleton<GameManager>.Instance.ShowEnding();
	}

	private string GetMedalSprite(int i)
	{
		return (KillInfo)i switch
		{
			KillInfo.HotGun => "bsui-medal-hotstuff", 
			KillInfo.MultiKill => "bsui-medal-nomercy", 
			KillInfo.NoReply => "bsui-medal-noreply", 
			KillInfo.Overkill => "bsui-medal-overkill", 
			KillInfo.QuickKill => "bsui-medal-quickkill", 
			KillInfo.SnapShot => "bsui-medal-snapshot", 
			KillInfo.Sniper => "bsui-medal-sniper", 
			KillInfo.BorrowedTime => "bsui-medal-borrowedtime", 
			KillInfo.SlowmoKill => "bsui-medal-baywatch", 
			KillInfo.InvulnerableKill => "bsui-medal-canttouchthis", 
			KillInfo.RevengeKill => "bsui-medal-revenge", 
			_ => "bsui-medal-saviour", 
		};
	}
}
public class NGUITutorialPopup : MonoBehaviour
{
	private enum State
	{
		Showing,
		Hidden
	}

	[SerializeField]
	private UILabel m_textLabel;

	[SerializeField]
	private UILabel m_tapToContinueLabel;

	[SerializeField]
	private UISprite m_icon;

	private UIPanel panel;

	private State m_state = State.Hidden;

	private bool m_fadingIn;

	public bool FadingIn => m_fadingIn;

	private void Awake()
	{
		panel = GetComponent<UIPanel>();
		m_fadingIn = false;
	}

	public void Show(string text, float continueShowDelay, string icon = "", int textWidth = 1000)
	{
		if (m_state == State.Showing)
		{
			return;
		}
		m_state = State.Showing;
		m_textLabel.width = textWidth;
		m_textLabel.text = text;
		if ((bool)m_icon)
		{
			m_icon.spriteName = icon;
			if (icon == "tut_5" || icon == "tut_6")
			{
				m_icon.width = 200;
				m_icon.height = 116;
			}
			else
			{
				m_icon.width = 200;
				m_icon.height = 189;
			}
		}
		m_tapToContinueLabel.alpha = 0.01f;
		StopCoroutine("FadeOut");
		panel.alpha = 0f;
		StartCoroutine(FadeIn(1f, continueShowDelay));
	}

	public void Hide()
	{
		if (m_state != State.Hidden)
		{
			m_state = State.Hidden;
			StartCoroutine("FadeOut", 1);
		}
	}

	private IEnumerator FadeIn(float fadeSpeed, float continueShowDelay)
	{
		m_fadingIn = true;
		panel.alpha = 0f;
		yield return null;
		yield return null;
		yield return null;
		float alpha2 = 0f;
		while (!Mathf.Approximately(alpha2, 1f))
		{
			alpha2 = Mathf.Min(1f, alpha2 + Time.unscaledDeltaTime * fadeSpeed);
			panel.alpha = alpha2;
			yield return null;
		}
		float waitTime = continueShowDelay;
		while (waitTime > 0f)
		{
			waitTime -= Time.unscaledDeltaTime;
			yield return null;
		}
		alpha2 = 0.01f;
		while (!Mathf.Approximately(alpha2, 1f))
		{
			alpha2 = Mathf.Min(1f, alpha2 + Time.unscaledDeltaTime * fadeSpeed);
			m_tapToContinueLabel.alpha = alpha2;
			yield return null;
		}
		m_fadingIn = false;
	}

	private IEnumerator FadeOut(float fadeSpeed)
	{
		m_fadingIn = false;
		float alpha = 1f;
		while (!Mathf.Approximately(alpha, 0f))
		{
			alpha = Mathf.Max(0f, alpha - Time.unscaledDeltaTime * fadeSpeed);
			panel.alpha = alpha;
			yield return null;
		}
		base.transform.parent = null;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		base.gameObject.SetActive(value: false);
	}
}
public class NGUIArmourUpgrade : MonoBehaviour
{
	[SerializeField]
	private UILabel m_costLabel;

	[SerializeField]
	private GameObject m_pipsParent;

	private void OnEnable()
	{
		Refresh();
	}

	private void Refresh()
	{
		int armourUpgrade = Singleton<Profile>.Instance.Upgrades.GetArmourUpgrade();
		bool flag = false;
		if (Singleton<UpgradeManager>.Instance.CanBuyUpgrade(UpgradeType.Armour, out var CostOut) == -1 && CostOut == 0)
		{
			flag = true;
		}
		if (flag)
		{
			m_costLabel.text = "menu_proj_upgrades_max".Translate();
		}
		else
		{
			m_costLabel.text = NGUIProjectorMenuManager.ProcessNumber(CostOut);
		}
		UISprite[] componentsInChildren = m_pipsParent.GetComponentsInChildren<UISprite>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (i < armourUpgrade)
			{
				componentsInChildren[i].spriteName = "upgrade_item_details_status1";
			}
			else
			{
				componentsInChildren[i].spriteName = "upgrade_item_details_status0";
			}
		}
	}
}
public class NGUIGunSelectButton : MonoBehaviour
{
	[SerializeField]
	private int m_index;

	[SerializeField]
	private UISprite m_numberSprite;

	[SerializeField]
	private GameObject m_cooldownPipParent;

	[SerializeField]
	private GameObject m_damagePipParent;

	[SerializeField]
	private GameObject m_rofPipParent;

	[SerializeField]
	private UILabel m_unlockCostLabel;

	private bool m_ownsGun;

	private UIButton myButton;

	private void Awake()
	{
		myButton = GetComponent<UIButton>();
	}

	private void OnEnable()
	{
		m_ownsGun = Singleton<Profile>.Instance.Upgrades.OwnsGun(m_index);
		if (!m_ownsGun)
		{
			myButton.isEnabled = false;
			m_unlockCostLabel.text = Singleton<UpgradeManager>.Instance.GunRequiredStars(m_index).ToString();
		}
		else if (m_unlockCostLabel != null)
		{
			m_unlockCostLabel.cachedGameObject.SetActive(value: false);
		}
		for (int i = 0; i < 3; i++)
		{
			int gunUpgrade;
			GameObject gameObject;
			switch (i)
			{
			case 0:
				gunUpgrade = Singleton<Profile>.Instance.Upgrades.GetGunUpgrade(m_index, 2);
				gameObject = m_cooldownPipParent;
				break;
			case 1:
				gunUpgrade = Singleton<Profile>.Instance.Upgrades.GetGunUpgrade(m_index, 0);
				gameObject = m_damagePipParent;
				break;
			default:
				gunUpgrade = Singleton<Profile>.Instance.Upgrades.GetGunUpgrade(m_index, 1);
				gameObject = m_rofPipParent;
				break;
			}
			UISprite[] componentsInChildren = gameObject.GetComponentsInChildren<UISprite>();
			for (int j = 0; j < componentsInChildren.Length; j++)
			{
				if (j < gunUpgrade)
				{
					componentsInChildren[j].spriteName = "upgrade_item_button_pip_full";
				}
				else
				{
					componentsInChildren[j].spriteName = "upgrade_item_button_pip_empty";
				}
			}
		}
		if (Singleton<Profile>.Instance.Upgrades.CurrentGun == m_index)
		{
			myButton.hoverSprite = null;
			myButton.normalSprite = "weapon_select_button_s";
		}
		else
		{
			myButton.hoverSprite = "weapon_select_button_h";
			myButton.normalSprite = "weapon_select_button";
		}
	}

	private void OnClick()
	{
		if (m_ownsGun)
		{
			Singleton<Profile>.Instance.Upgrades.CurrentGun = m_index;
			Singleton<NGUIProjectorMenuManager>.Instance.BackButtonPressed();
		}
	}
}
public class NGUILocaliseLabel : MonoBehaviour
{
	[SerializeField]
	private string m_key = string.Empty;

	private void Start()
	{
		UILabel component = GetComponent<UILabel>();
		if (m_key.Length > 0 && (bool)component)
		{
			component.text = m_key.Translate();
		}
	}
}
public class NGUILocaliseLabelBasedOnController : MonoBehaviour
{
	[SerializeField]
	private string m_headsetGamepadKey = string.Empty;

	[SerializeField]
	private string m_touchKey = string.Empty;

	private UILabel m_label;

	private OVRInput.Controller m_currentController;

	private void Start()
	{
		m_label = GetComponent<UILabel>();
		if (m_headsetGamepadKey.Length > 0 && (bool)m_label)
		{
			m_label.text = m_headsetGamepadKey.Translate();
			m_label.SetDirty();
		}
		Update();
	}

	private void Update()
	{
		if (m_currentController != OVRInput.GetActiveController())
		{
			string text = ((!InputUtils.IsTrackedRemoteActive()) ? m_headsetGamepadKey : m_touchKey);
			m_currentController = OVRInput.GetActiveController();
			if (text.Length > 0 && (bool)m_label)
			{
				m_label.text = text.Translate();
				m_label.SetDirty();
			}
		}
	}
}
public class NGUIMissionInfo : MonoBehaviour
{
	private enum MissionType
	{
		checkpoint,
		cts,
		dontshoot,
		protect,
		special
	}

	[SerializeField]
	private UILabel m_requiredStars1;

	[SerializeField]
	private UILabel m_requiredStars2;

	[SerializeField]
	private UILabel m_requiredStars3;

	[SerializeField]
	private UILabel m_titleLabel;

	[SerializeField]
	private UILabel m_descriptionLabel;

	[SerializeField]
	private UILabel m_highScoreLabel;

	[SerializeField]
	private UITexture m_thumbnailTexture;

	[SerializeField]
	private UISprite[] m_currentStars;

	[SerializeField]
	private UISprite m_selectedGunIcon;

	private int m_currentWeapon;

	public void SetupInfo(int missionID)
	{
		MissionSettings missionSettings = Singleton<MissionManager>.Instance.AvailableMissions[missionID];
		m_requiredStars1.text = missionSettings.TargetScoreOneStar.ToString();
		m_requiredStars2.text = missionSettings.TargetScoreTwoStar.ToString();
		m_requiredStars3.text = missionSettings.TargetScoreThreeStar.ToString();
		RefreshDescriptionText(missionID);
		m_highScoreLabel.text = NGUIProjectorMenuManager.ProcessNumber(Singleton<Profile>.Instance.Progress.GetHighestScore(missionID));
		int stars = Singleton<Profile>.Instance.Progress.GetStars(missionID);
		for (int i = 0; i < m_currentStars.Length; i++)
		{
			if (i < stars)
			{
				m_currentStars[i].spriteName = "briefing_pic_container_star";
			}
			else
			{
				m_currentStars[i].spriteName = "briefing_pic_container_star_empty";
			}
		}
	}

	private void OnEnable()
	{
		if (Singleton<Profile>.Instance.Upgrades.CurrentGun != m_currentWeapon)
		{
			m_currentWeapon = Singleton<Profile>.Instance.Upgrades.CurrentGun;
			m_selectedGunIcon.spriteName = "briefing_screen_gun" + (m_currentWeapon + 1);
		}
	}

	private void RefreshDescriptionText(int missionID)
	{
		string text = string.Empty;
		string text2 = string.Empty;
		MissionSettings missionSettings = Singleton<MissionManager>.Instance.AvailableMissions[missionID];
		KillPlaneMap[] planesToKill = missionSettings.PlanesToKill;
		string text3 = FormatMissionTime((int)missionSettings.Time);
		string[] array = new string[2]
		{
			(planesToKill.Length <= 0) ? string.Empty : (planesToKill[0].m_count + string.Empty),
			(planesToKill.Length <= 1) ? string.Empty : (planesToKill[1].m_count + string.Empty)
		};
		MissionType missionType = MissionType.cts;
		string text4 = missionSettings.FriendlyPlaneType switch
		{
			FriendlyPlaneTypes.BF109 => "menu_proj_mission_plane_type_bf109".Translate(), 
			FriendlyPlaneTypes.Focke => "menu_proj_mission_plane_type_focke".Translate(), 
			_ => "menu_proj_mission_plane_type_lancaster".Translate(), 
		};
		if (missionID == 0)
		{
			text = "menu_proj_mission_tutorial_title".Translate();
			missionType = MissionType.cts;
			text2 = FormatDescriptionText("menu_proj_mission_tutorial_desc".Translate());
		}
		else if (missionSettings.WinCondition == WinCondition.Protect)
		{
			text = "menu_proj_mission_protect_title".Translate();
			missionType = MissionType.protect;
			text2 = ((planesToKill.Length <= 0) ? FormatDescriptionText("menu_proj_mission_protect_desc5".Translate(), missionSettings.FriendlyPlanesToProtect, text4, text3) : ((planesToKill[0].m_type == PlaneType.Any) ? ((!missionSettings.HasTimeLimit) ? FormatDescriptionText("menu_proj_mission_protect_desc1".Translate(), array[0], missionSettings.FriendlyPlanesToProtect, text4) : FormatDescriptionText("menu_proj_mission_protect_desc2".Translate(), array[0], text3, missionSettings.FriendlyPlanesToProtect, text4)) : ((!missionSettings.HasTimeLimit) ? FormatDescriptionText("menu_proj_mission_protect_desc3".Translate(), array[0], GetPlaneName(planesToKill[0].m_type), missionSettings.FriendlyPlanesToProtect, text4) : FormatDescriptionText("menu_proj_mission_protect_desc4".Translate(), array[0], GetPlaneName(planesToKill[0].m_type), text3, missionSettings.FriendlyPlanesToProtect, text4))));
		}
		else if (missionSettings.WinCondition == WinCondition.DontShoot)
		{
			text = "menu_proj_mission_avoid_title".Translate();
			missionType = MissionType.dontshoot;
			if (planesToKill.Length > 0)
			{
				text2 = ((planesToKill[0].m_type == PlaneType.Any) ? ((!missionSettings.HasTimeLimit) ? FormatDescriptionText("menu_proj_mission_avoid_desc1".Translate(), array[0], missionSettings.FriendlyPlanesToProtect, text4) : FormatDescriptionText("menu_proj_mission_avoid_desc2".Translate(), array[0], text3, missionSettings.FriendlyPlanesToProtect, text4)) : ((!missionSettings.HasTimeLimit) ? FormatDescriptionText("menu_proj_mission_avoid_desc3".Translate(), array[0], GetPlaneName(planesToKill[0].m_type), missionSettings.FriendlyPlanesToProtect, text4) : FormatDescriptionText("menu_proj_mission_avoid_desc4".Translate(), array[0], GetPlaneName(planesToKill[0].m_type), text3, missionSettings.FriendlyPlanesToProtect, text4)));
			}
		}
		else if (missionSettings.TimeLimitType == TimeLimit.Checkpoint)
		{
			text = "menu_proj_mission_checkpoint_title".Translate();
			missionType = MissionType.checkpoint;
			if (planesToKill.Length > 0)
			{
				text2 = ((planesToKill[0].m_type != PlaneType.Any) ? FormatDescriptionText("menu_proj_mission_checkpoint_desc2".Translate(), array[0], GetPlaneName(planesToKill[0].m_type), text3, missionSettings.CheckpointTimeBonus) : FormatDescriptionText("menu_proj_mission_checkpoint_desc1".Translate(), array[0], text3, missionSettings.CheckpointTimeBonus));
			}
		}
		else if (missionSettings.TimeLimitType == TimeLimit.Survival)
		{
			text = "menu_proj_mission_survive_title".Translate();
			missionType = MissionType.cts;
			text2 = FormatDescriptionText("menu_proj_mission_survive_desc1".Translate(), text3);
		}
		else if (planesToKill.Length > 0)
		{
			if (planesToKill[0].m_type == PlaneType.Any)
			{
				text = "menu_proj_mission_destroy_any_title".Translate();
				missionType = MissionType.cts;
				text2 = ((!missionSettings.HasTimeLimit) ? FormatDescriptionText("menu_proj_mission_destroy_any_desc1".Translate(), array[0]) : FormatDescriptionText("menu_proj_mission_destroy_any_desc2".Translate(), array[0], text3));
			}
			else if (planesToKill.Length == 1)
			{
				text = "menu_proj_mission_destroy_any_title".Translate();
				missionType = MissionType.cts;
				text2 = ((!missionSettings.HasTimeLimit) ? FormatDescriptionText("menu_proj_mission_destroy_specific_desc1".Translate(), array[0], GetPlaneName(planesToKill[0].m_type)) : FormatDescriptionText("menu_proj_mission_destroy_specific_desc2".Translate(), array[0], GetPlaneName(planesToKill[0].m_type), text3));
			}
			else
			{
				text = "menu_proj_mission_destroy_specific_title".Translate();
				missionType = MissionType.special;
				text2 = ((!missionSettings.HasTimeLimit) ? FormatDescriptionText("menu_proj_mission_destroy_specific_desc3".Translate(), array[0], GetPlaneName(planesToKill[0].m_type), array[1], GetPlaneName(planesToKill[1].m_type)) : FormatDescriptionText("menu_proj_mission_destroy_specific_desc4".Translate(), array[0], GetPlaneName(planesToKill[0].m_type), array[1], GetPlaneName(planesToKill[1].m_type), text3));
			}
		}
		if (missionSettings.Ground != null)
		{
			string text5 = "GUI/Textures/Mission_Thumbnails/";
			switch (missionType)
			{
			case MissionType.checkpoint:
				text5 += "Checkpoint/Checkpoint_";
				break;
			case MissionType.cts:
				text5 += "Clear_The_Skies/CTS_";
				break;
			case MissionType.dontshoot:
				text5 += "Don't_Shoot/Don't_Shoot_";
				break;
			case MissionType.protect:
				text5 += "Protect/Protect_";
				break;
			case MissionType.special:
				text5 += "Special/Special_";
				break;
			}
			text5 += missionSettings.Ground;
			m_thumbnailTexture.mainTexture = Resources.Load<Texture>(text5);
			m_thumbnailTexture.SetDirty();
		}
		m_titleLabel.text = ((missionID <= 0) ? string.Empty : (missionID + ": ")) + text;
		m_descriptionLabel.text = text2;
	}

	private string FormatMissionTime(int time)
	{
		string text = string.Empty;
		int num = time % 60;
		int num2 = (time - num) / 60;
		if (num2 < 10)
		{
			text += "0";
		}
		text += num2;
		text += ":";
		if (num < 10)
		{
			text += "0";
		}
		return text + num;
	}

	private string FormatDescriptionText(string format, params object[] args)
	{
		UnityEngine.Color color = new UnityEngine.Color(0.61960787f, 0.16862746f, 18f / 85f);
		string[] array = new string[args.Length];
		string arg = $"{(int)(color.r * 255f):X2}{(int)(color.g * 255f):X2}{(int)(color.b * 255f):X2}";
		for (int i = 0; i < args.Length; i++)
		{
			array[i] = $"[{arg}]{args[i].ToString()}[-]";
		}
		string arg2 = string.Format(format, array);
		color = new UnityEngine.Color(0.2509804f, 18f / 85f, 14f / 85f);
		arg = $"{(int)(color.r * 255f):X2}{(int)(color.g * 255f):X2}{(int)(color.b * 255f):X2}";
		return $"[{arg}]{arg2}[-]";
	}

	private string GetPlaneName(PlaneType type)
	{
		return type switch
		{
			PlaneType.Avoider => "menu_proj_mission_plane_type_avoider".Translate(), 
			PlaneType.Avoider1 => "menu_proj_mission_plane_type_avoider1".Translate(), 
			PlaneType.Avoider2 => "menu_proj_mission_plane_type_avoider2".Translate(), 
			PlaneType.Cargo => "menu_proj_mission_plane_type_cargo".Translate(), 
			PlaneType.Cargo1 => "menu_proj_mission_plane_type_cargo1".Translate(), 
			PlaneType.Jinker => "menu_proj_mission_plane_type_jinker".Translate(), 
			PlaneType.Jinker1 => "menu_proj_mission_plane_type_jinker1".Translate(), 
			PlaneType.Jinker2 => "menu_proj_mission_plane_type_jinker2".Translate(), 
			PlaneType.StraightFlyer => "menu_proj_mission_plane_type_straight_flyer".Translate(), 
			PlaneType.StraightFlyer1 => "menu_proj_mission_plane_type_straight_flyer1".Translate(), 
			PlaneType.StraightFlyer2 => "menu_proj_mission_plane_type_straight_flyer2".Translate(), 
			PlaneType.Komet => "menu_proj_mission_plane_type_komet".Translate(), 
			PlaneType.Lurker => "menu_proj_mission_plane_type_lurker".Translate(), 
			PlaneType.ME => "menu_proj_mission_plane_type_me".Translate(), 
			PlaneType.BonusRocket => "menu_proj_mission_plane_type_bonus_rocket".Translate(), 
			PlaneType.Wasserfall => "menu_proj_mission_plane_type_wasserfall".Translate(), 
			PlaneType.RocketMe262 => "menu_proj_mission_plane_type_rocketme262".Translate(), 
			PlaneType.Armoured262 => "menu_proj_mission_plane_type_armoured262".Translate(), 
			_ => "menu_proj_mission_plane_type_default".Translate(), 
		};
	}
}
public class NGUIMissionList : MonoBehaviour
{
	[SerializeField]
	private GameObject[] m_Rows;

	[SerializeField]
	private UIButton m_prevPage;

	[SerializeField]
	private UIButton m_nextPage;

	private List<NGUIMissionListCell> m_cells = new List<NGUIMissionListCell>();

	private int m_page;

	private int m_missionPerPage = 15;

	private bool m_wantToRefresh = true;

	private void Start()
	{
		for (int i = 0; i < m_Rows.Length; i++)
		{
			NGUIMissionListCell[] componentsInChildren = m_Rows[i].transform.GetComponentsInChildren<NGUIMissionListCell>();
			for (int j = 0; j < componentsInChildren.Length; j++)
			{
				m_cells.Add(componentsInChildren[j]);
			}
		}
		m_page = (Singleton<MissionManager>.Instance.Mission - Singleton<MissionManager>.Instance.Mission % m_missionPerPage) / m_missionPerPage;
		RefreshList();
	}

	private void Update()
	{
		if (m_wantToRefresh)
		{
			PerformRefresh();
		}
	}

	private void PerformRefresh()
	{
		MissionSettings[] availableMissions = Singleton<MissionManager>.Instance.AvailableMissions;
		int num = m_page * m_missionPerPage;
		if (availableMissions == null)
		{
			return;
		}
		for (int i = num; i < num + m_missionPerPage && i < availableMissions.Length; i++)
		{
			int index = i % m_missionPerPage;
			if (Singleton<Profile>.Instance.Progress.GetStarsAmount() < availableMissions[i].RequiredStars)
			{
				m_cells[index].ShowRequiredStars(availableMissions[i].RequiredStars);
			}
			else
			{
				m_cells[index].ShowPlayable(i, Singleton<Profile>.Instance.Progress.GetStars(i), Singleton<Profile>.Instance.Progress.HasPlayedLevelBefore(i));
			}
		}
		if ((bool)m_prevPage)
		{
			m_prevPage.isEnabled = m_page > 0;
		}
		if ((bool)m_nextPage)
		{
			m_nextPage.isEnabled = m_page < 1;
		}
		m_wantToRefresh = false;
	}

	private void RefreshList()
	{
		m_wantToRefresh = true;
	}

	private void ChangePage(int increment)
	{
		m_page = Mathf.Clamp(m_page + increment, 0, 1);
		RefreshList();
		Singleton<NGUIProjectorMenuManager>.Instance.PlaySlideSound();
	}

	public void NextPage()
	{
		ChangePage(1);
	}

	public void PreviousPage()
	{
		ChangePage(-1);
	}
}
public class NGUIMissionListCell : MonoBehaviour
{
	[SerializeField]
	private UILabel m_missionNumber;

	[SerializeField]
	private UILabel m_unlockedLabel;

	[SerializeField]
	private GameObject m_starsToUnlock;

	[SerializeField]
	private GameObject m_starsAquired;

	[SerializeField]
	private GameObject m_training;

	[SerializeField]
	private float m_maxHoverScale = 1.2f;

	[SerializeField]
	private float m_hoverScaleSpeed = 1f;

	private int m_missionID = -1;

	private bool m_hovering;

	private float m_hoverScale = 1f;

	private float m_prevScale = -1f;

	private UIButton myButton;

	private UISprite mySprite;

	private void Awake()
	{
		myButton = GetComponent<UIButton>();
		mySprite = GetComponent<UISprite>();
		UIEventTrigger uIEventTrigger = GetComponent<UIEventTrigger>();
		if (!uIEventTrigger)
		{
			uIEventTrigger = base.gameObject.AddComponent<UIEventTrigger>();
		}
		m_unlockedLabel.text = "menu_proj_unlocked".Translate();
		uIEventTrigger.onHoverOver.Add(new EventDelegate(StartHover));
		uIEventTrigger.onHoverOut.Add(new EventDelegate(EndHover));
	}

	private void OnEnable()
	{
		m_hovering = false;
		m_hoverScale = 1f;
		m_prevScale = -1f;
		base.transform.localScale = new Vector3(m_hoverScale, m_hoverScale, 1f);
	}

	private void Update()
	{
		if (m_hovering && m_missionID != -1)
		{
			m_hoverScale = Mathf.Min(m_maxHoverScale, m_hoverScale + Time.deltaTime * m_hoverScaleSpeed);
		}
		else
		{
			m_hoverScale = Mathf.Max(1f, m_hoverScale - Time.deltaTime * m_hoverScaleSpeed);
		}
		if (!Mathf.Approximately(m_prevScale, m_hoverScale))
		{
			m_prevScale = m_hoverScale;
			base.transform.localScale = new Vector3(m_hoverScale, m_hoverScale, 1f);
		}
	}

	public void ShowPlayable(int missionNumber, int stars, bool playedMissionBefore)
	{
		m_missionID = missionNumber;
		if (missionNumber == 0)
		{
			ShowStars(stars);
			m_unlockedLabel.cachedGameObject.SetActive(value: false);
			m_starsToUnlock.SetActive(value: false);
			ShowTutorial();
		}
		else if (!playedMissionBefore)
		{
			m_starsAquired.SetActive(value: false);
			m_training.SetActive(value: false);
			m_unlockedLabel.cachedGameObject.SetActive(value: false);
			m_starsToUnlock.SetActive(value: false);
			m_missionNumber.cachedGameObject.SetActive(value: true);
			m_missionNumber.text = missionNumber.ToString();
			m_unlockedLabel.cachedGameObject.SetActive(value: true);
			mySprite.spriteName = "mission_select_container";
			myButton.normalSprite = "mission_select_container";
			myButton.hoverSprite = "mission_select_container_h";
		}
		else
		{
			ShowPlayedMission(missionNumber, stars);
		}
	}

	private void ShowPlayedMission(int missionNumber, int stars)
	{
		ShowStars(stars);
		m_unlockedLabel.cachedGameObject.SetActive(value: false);
		m_starsToUnlock.SetActive(value: false);
		m_training.SetActive(value: false);
		m_missionNumber.cachedGameObject.SetActive(value: true);
		m_missionNumber.text = missionNumber.ToString();
		mySprite.spriteName = "mission_select_container";
		myButton.normalSprite = "mission_select_container";
		myButton.hoverSprite = "mission_select_container_h";
	}

	private void ShowStars(int stars)
	{
		m_starsAquired.SetActive(value: true);
		for (int i = 0; i < m_starsAquired.transform.childCount; i++)
		{
			UISprite component = m_starsAquired.transform.GetChild(i).GetComponent<UISprite>();
			if (!component)
			{
				UnityEngine.Debug.LogError("Missing star sprite on mission icon");
			}
			else if (i < stars)
			{
				component.spriteName = "mission_select_rating_star_filled";
			}
			else
			{
				component.spriteName = "mission_select_rating_star";
			}
		}
	}

	public bool IsMissionLocked()
	{
		return m_missionID < 0;
	}

	public void ShowTutorial()
	{
		m_training.SetActive(value: true);
		m_unlockedLabel.cachedGameObject.SetActive(value: false);
		m_starsToUnlock.SetActive(value: false);
		m_missionNumber.cachedGameObject.SetActive(value: false);
		mySprite.spriteName = "mission_select_training_container";
		myButton.normalSprite = "mission_select_training_container";
		myButton.hoverSprite = "mission_select_training_container_h";
	}

	public void ShowRequiredStars(int required)
	{
		m_missionID = -1;
		m_training.SetActive(value: false);
		m_starsAquired.SetActive(value: false);
		m_missionNumber.cachedGameObject.SetActive(value: false);
		m_unlockedLabel.cachedGameObject.SetActive(value: false);
		m_starsToUnlock.SetActive(value: true);
		UILabel componentInChildren = m_starsToUnlock.transform.GetComponentInChildren<UILabel>();
		if ((bool)componentInChildren)
		{
			componentInChildren.text = string.Empty + required;
		}
		mySprite.spriteName = "mission_select_container_locked";
		myButton.normalSprite = "mission_select_container_locked";
		myButton.hoverSprite = null;
	}

	private void OnClick()
	{
		if (m_missionID != -1)
		{
			Singleton<NGUIProjectorMenuManager>.Instance.ShowMissionInfo(m_missionID);
		}
	}

	private void StartHover()
	{
		m_hovering = true;
	}

	private void EndHover()
	{
		m_hovering = false;
	}
}
public class NGUIOptionsScreen : MonoBehaviour
{
	[SerializeField]
	private UILabel m_healthLabel;

	[SerializeField]
	private UILabel m_gazeToAimLabel;

	[SerializeField]
	private GameObject m_sfxBlockParent;

	[SerializeField]
	private GameObject m_radioBlockParent;

	[SerializeField]
	private GameObject m_gazeToAimObject;

	private float m_originalSfx = 1f;

	private float m_originalRadio = 1f;

	private bool m_gazeToAim = true;

	private bool m_healthDisplay = true;

	private float m_sfx = 1f;

	private float m_radio = 1f;

	private bool m_optionsSaved;

	private int m_sfxBlocksFull = 10;

	private int m_radioBlocksFull = 10;

	private void OnEnable()
	{
		UpdateValues();
		RefreshHealth();
		RefreshSFX();
		RefreshRadio();
		RefreshGazeToAim();
	}

	private void OnDisable()
	{
		if (!m_optionsSaved)
		{
			RevertAudio();
		}
	}

	private void UpdateValues()
	{
		m_optionsSaved = false;
		m_originalSfx = (m_sfx = Singleton<Profile>.Instance.Settings.GetValue(ProfileSettings.SliderOptions.VolumeSFX));
		m_originalRadio = (m_radio = Singleton<Profile>.Instance.Settings.GetValue(ProfileSettings.SliderOptions.VolumeRadio));
		m_healthDisplay = Singleton<Profile>.Instance.Settings.GetValue(ProfileSettings.ToggleOptions.ShowHealthBars);
		m_gazeToAim = Singleton<Profile>.Instance.Settings.GetValue(ProfileSettings.ToggleOptions.GazeToAim);
		m_sfxBlocksFull = Mathf.CeilToInt(m_sfx * 10f);
		m_radioBlocksFull = Mathf.CeilToInt(m_radio * 10f);
	}

	public void SaveOptions()
	{
		Singleton<Profile>.Instance.Settings.SetValue(ProfileSettings.ToggleOptions.GazeToAim, m_gazeToAim);
		Singleton<Profile>.Instance.Settings.SetValue(ProfileSettings.ToggleOptions.ShowHealthBars, m_healthDisplay);
		Singleton<Profile>.Instance.Settings.SetValue(ProfileSettings.SliderOptions.VolumeSFX, m_sfx);
		Singleton<Profile>.Instance.Settings.SetValue(ProfileSettings.SliderOptions.VolumeRadio, m_radio);
		Singleton<Profile>.Instance.Save();
		m_optionsSaved = true;
		Singleton<NGUIProjectorMenuManager>.Instance.BackButtonPressed();
	}

	private void RefreshHealth()
	{
		m_healthLabel.text = ((!m_healthDisplay) ? "menu_proj_no" : "menu_proj_yes").Translate();
	}

	private void RefreshGazeToAim()
	{
		m_gazeToAimLabel.text = ((!m_gazeToAim) ? "menu_proj_no" : "menu_proj_yes").Translate();
		m_gazeToAimObject.SetActive(InputUtils.IsTrackedRemoteActive());
	}

	private void RefreshSFX()
	{
		UISprite[] componentsInChildren = m_sfxBlockParent.GetComponentsInChildren<UISprite>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (i < m_sfxBlocksFull)
			{
				componentsInChildren[i].spriteName = "options_volume_full";
			}
			else
			{
				componentsInChildren[i].spriteName = "options_volume_empty";
			}
		}
		Singleton<AudioManager>.Instance.SetVolume(VolumeSettings.SFX, m_sfx, isDucking: false);
	}

	private void RefreshRadio()
	{
		UISprite[] componentsInChildren = m_radioBlockParent.GetComponentsInChildren<UISprite>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (i < m_radioBlocksFull)
			{
				componentsInChildren[i].spriteName = "options_volume_full";
			}
			else
			{
				componentsInChildren[i].spriteName = "options_volume_empty";
			}
		}
		Singleton<AudioManager>.Instance.SetVolume(VolumeSettings.Radio, m_radio, isDucking: false);
	}

	public void ChangedHealth()
	{
		m_healthDisplay = !m_healthDisplay;
		RefreshHealth();
	}

	public void ChangedGazeToAim()
	{
		m_gazeToAim = !m_gazeToAim;
		RefreshGazeToAim();
	}

	public void SFXLeft()
	{
		m_sfx = Mathf.Max(0f, m_sfx - 0.1f);
		m_sfxBlocksFull = Mathf.Max(0, m_sfxBlocksFull - 1);
		RefreshSFX();
	}

	public void SFXRight()
	{
		m_sfx = Mathf.Min(1f, m_sfx + 0.1f);
		m_sfxBlocksFull = Mathf.Min(10, m_sfxBlocksFull + 1);
		RefreshSFX();
	}

	public void RadioLeft()
	{
		m_radio = Mathf.Max(0f, m_radio - 0.1f);
		m_radioBlocksFull = Mathf.Max(0, m_radioBlocksFull - 1);
		RefreshRadio();
	}

	public void RadioRight()
	{
		m_radio = Mathf.Min(1f, m_radio + 0.1f);
		m_radioBlocksFull = Mathf.Min(10, m_radioBlocksFull + 1);
		RefreshRadio();
	}

	private void RevertAudio()
	{
		Singleton<AudioManager>.Instance.SetVolume(VolumeSettings.SFX, m_originalSfx, isDucking: false);
		Singleton<AudioManager>.Instance.SetVolume(VolumeSettings.Radio, m_originalRadio, isDucking: false);
	}

	public void CancelOptions()
	{
		RevertAudio();
		Singleton<NGUIProjectorMenuManager>.Instance.BackButtonPressed();
	}
}
public class NGUIPickupUpgradeButton : MonoBehaviour
{
	[SerializeField]
	private PowerUpType m_type;

	[SerializeField]
	private UILabel m_costLabel;

	[SerializeField]
	private UILabel m_nameLabel;

	[SerializeField]
	private GameObject m_pipParent;

	[SerializeField]
	private UISprite m_icon;

	private void OnEnable()
	{
		Refresh();
	}

	private void Refresh()
	{
		UpgradeType type = (UpgradeType)(10 + m_type);
		int powerUpUpgrade = Singleton<Profile>.Instance.Upgrades.GetPowerUpUpgrade((int)m_type);
		int CostOut;
		bool flag = Singleton<UpgradeManager>.Instance.CanBuyUpgrade(type, out CostOut) == -1 && CostOut == 0;
		string text = "upgrade_pickup_";
		text = m_type switch
		{
			PowerUpType.Health => text + "1", 
			PowerUpType.Invulnerability => text + "6", 
			PowerUpType.Slowmo => text + "8", 
			PowerUpType.ExtraTime => text + "7", 
			PowerUpType.Cooling => text + "4", 
			PowerUpType.Damage => text + "2", 
			PowerUpType.Points => text + "3", 
			_ => text + "5", 
		};
		m_icon.spriteName = text;
		m_icon.MakePixelPerfect();
		m_icon.bottomAnchor.Set(1f, 0f);
		m_nameLabel.text = Singleton<UpgradeManager>.Instance.GetUpgradeName(type);
		m_costLabel.text = ((!flag) ? NGUIProjectorMenuManager.ProcessNumber(CostOut) : "menu_proj_upgrades_max".Translate());
		UISprite[] componentsInChildren = m_pipParent.GetComponentsInChildren<UISprite>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (i < powerUpUpgrade)
			{
				componentsInChildren[i].spriteName = "upgrade_pickup_container_pip";
			}
			else
			{
				componentsInChildren[i].spriteName = "upgrade_pickup_container_pip_empty";
			}
		}
	}

	private void OnClick()
	{
		Singleton<NGUIUpgradesManager>.Instance.UpgradeSelected((UpgradeType)(10 + m_type));
		Singleton<NGUIProjectorMenuManager>.Instance.PlaySlideSound();
	}
}
public class NGUIPlayCustomSound : MonoBehaviour
{
	[SerializeField]
	private AudioEvent m_event;

	[SerializeField]
	private Vector3 soundPosition = default(Vector3);

	[SerializeField]
	private bool useOneShot;

	private void OnClick()
	{
		if (useOneShot)
		{
			Singleton<AudioManager>.Instance.PlayOneShot(m_event);
		}
		else if (soundPosition != default(Vector3))
		{
			Singleton<AudioManager>.Instance.PlayInLocation(m_event, soundPosition);
		}
		else
		{
			Singleton<AudioManager>.Instance.Play(m_event);
		}
	}
}
public class NGUIProjectorMenuManager : Singleton<NGUIProjectorMenuManager>
{
	public enum Pages
	{
		None = -1,
		MissionSelect,
		MissionInfo,
		Upgrades,
		Options,
		Quit
	}

	[SerializeField]
	private UILabel m_labelStarsMax;

	[SerializeField]
	private UILabel m_labelStarsTotal;

	[SerializeField]
	private UILabel m_labelCurrency;

	[SerializeField]
	private GameObject m_MissionList;

	[SerializeField]
	private GameObject m_MissionInfo;

	[SerializeField]
	private GameObject m_QuitConfirm;

	[SerializeField]
	private GameObject m_GunSelect;

	[SerializeField]
	private GameObject m_Options;

	[SerializeField]
	private GameObject m_Upgrades;

	[SerializeField]
	private GameObject m_optionsButton;

	[SerializeField]
	private GameObject m_upgradesButton;

	[SerializeField]
	private GameObject m_exitButton;

	private Stack<GameObject> m_contentStack = new Stack<GameObject>();

	private int m_previousCurrency;

	private int m_selectedMissionID;

	private Pages m_currentPage = Pages.None;

	public Vector3 menuSlideSoundPosition = new Vector3(2.442799f, -2.065667f, -2.176944f);

	public Pages CurrentPage => m_currentPage;

	public event Action<Pages> OnChangePage;

	private void Start()
	{
		if (!m_labelStarsMax || !m_labelStarsTotal || !m_labelCurrency || !m_MissionList || !m_MissionInfo || !m_QuitConfirm || !m_GunSelect || !m_Options || !m_Upgrades || !m_optionsButton || !m_upgradesButton || !m_exitButton)
		{
			UnityEngine.Debug.LogError("Not all menu pointers are set, problems likely.");
		}
		m_contentStack.Push(m_MissionList);
		m_MissionList.SetActive(value: true);
		m_previousCurrency = Singleton<Profile>.Instance.Player.GetMoney();
		m_labelCurrency.text = ProcessNumber(m_previousCurrency);
		m_labelStarsMax.text = (Singleton<MissionManager>.Instance.AvailableMissions.Length * 3).ToString();
		m_labelStarsTotal.text = Singleton<Profile>.Instance.Progress.GetStarsAmount() + "/";
		EnableButtons(enabled: true);
		m_currentPage = Pages.MissionSelect;
	}

	public void PlaySlideSound()
	{
		Singleton<AudioManager>.Instance.PlayInLocation(AudioEvent.EvtGUI_FE_Change_Menu, menuSlideSoundPosition);
	}

	private void Update()
	{
		int money = Singleton<Profile>.Instance.Player.GetMoney();
		if (money != m_previousCurrency)
		{
			m_previousCurrency = money;
			m_labelCurrency.text = ProcessNumber(money);
		}
		if (!Singleton<LoadingScreen>.TryInstance() && Singleton<GameManager>.Instance.State == GameManager.GameState.Frontend && Singleton<GameManager>.Instance.Button1State == GameManager.InputButtonState.ShortPress)
		{
			BackButtonPressed();
		}
	}

	private void EnableButtons(bool enabled)
	{
		m_optionsButton.SetActive(enabled);
		m_upgradesButton.SetActive(enabled);
		UIButton component = m_exitButton.GetComponent<UIButton>();
		if ((bool)component)
		{
			if (enabled)
			{
				component.normalSprite = "header_quit_button";
				component.hoverSprite = "header_quit_button_h";
			}
			else
			{
				component.normalSprite = "header_back";
				component.hoverSprite = "header_back_h";
			}
			Singleton<CameraManager>.Instance.cameraSomething.CheckIfHoveringOverExitButton(component);
		}
	}

	public void BackButtonPressed()
	{
		if (m_contentStack.Count > 1)
		{
			PlaySlideSound();
		}
		if (m_Upgrades == m_contentStack.Peek() && !Singleton<NGUIUpgradesManager>.Instance.OnFrontPage)
		{
			return;
		}
		if (m_contentStack.Count > 1)
		{
			m_contentStack.Pop().SetActive(value: false);
			m_contentStack.Peek().SetActive(value: true);
			if (m_contentStack.Count == 1)
			{
				m_currentPage = Pages.MissionSelect;
				if (this.OnChangePage != null)
				{
					this.OnChangePage(Pages.MissionSelect);
				}
				EnableButtons(enabled: true);
			}
		}
		else
		{
			Singleton<LoadingScreen>.Instance.LoadOpeningFromMenu();
		}
	}

	public void ShowMissionInfo(int missionID)
	{
		if (this.OnChangePage != null)
		{
			this.OnChangePage(Pages.MissionInfo);
		}
		m_selectedMissionID = missionID;
		m_currentPage = Pages.MissionInfo;
		ChangePage(m_MissionInfo);
		m_MissionInfo.GetComponent<NGUIMissionInfo>().SetupInfo(m_selectedMissionID);
	}

	public void LaunchMission()
	{
		Singleton<MissionManager>.Instance.Mission = m_selectedMissionID;
		Singleton<LoadingScreen>.Instance.LoadGame();
	}

	public void ShowGunSelect()
	{
		ChangePage(m_GunSelect);
	}

	public void ShowUpgrades()
	{
		if (this.OnChangePage != null)
		{
			this.OnChangePage(Pages.Upgrades);
		}
		m_currentPage = Pages.Upgrades;
		ChangePage(m_Upgrades);
	}

	public void ShowOptions()
	{
		if (this.OnChangePage != null)
		{
			this.OnChangePage(Pages.Options);
		}
		m_currentPage = Pages.Options;
		ChangePage(m_Options);
	}

	private void ChangePage(GameObject newPage)
	{
		if (!(m_contentStack.Peek() == newPage))
		{
			m_contentStack.Peek().SetActive(value: false);
			newPage.SetActive(value: true);
			m_contentStack.Push(newPage);
			EnableButtons(enabled: false);
			PlaySlideSound();
		}
	}

	public static string ProcessNumber(int n)
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append(n);
		for (int num = stringBuilder.Length - 3; num > 0; num -= 3)
		{
			stringBuilder.Insert(num, ",");
		}
		return stringBuilder.ToString();
	}

	public void QuitGame()
	{
		Application.Quit();
	}
}
public class NGUIUpgradeSelected : MonoBehaviour
{
	[SerializeField]
	private UpgradeType m_type;

	private void OnClick()
	{
		Singleton<NGUIUpgradesManager>.Instance.UpgradeSelected(m_type);
		Singleton<NGUIProjectorMenuManager>.Instance.PlaySlideSound();
	}
}
public class NGUIUpgradeTabButton : MonoBehaviour
{
	[SerializeField]
	private NGUIUpgradesManager.UpgradeTabs m_type;

	[SerializeField]
	private UILabel m_unlockCostLabel;

	private string m_originalNormal;

	private string m_originalHover;

	private bool m_isSelected;

	private bool m_isEnabled = true;

	private UIButton myButton;

	private void Awake()
	{
		myButton = GetComponent<UIButton>();
		if ((bool)myButton)
		{
			m_originalNormal = myButton.normalSprite;
			m_originalHover = myButton.hoverSprite;
		}
	}

	private void OnEnable()
	{
		if (m_type == NGUIUpgradesManager.UpgradeTabs.Gun2 || m_type == NGUIUpgradesManager.UpgradeTabs.Gun3)
		{
			int gun = 0;
			switch (m_type)
			{
			case NGUIUpgradesManager.UpgradeTabs.Gun2:
				gun = 1;
				break;
			case NGUIUpgradesManager.UpgradeTabs.Gun3:
				gun = 2;
				break;
			}
			SetEnabled(Singleton<Profile>.Instance.Upgrades.OwnsGun(gun));
			if (!m_isEnabled)
			{
				m_unlockCostLabel.cachedGameObject.SetActive(value: true);
				m_unlockCostLabel.text = Singleton<UpgradeManager>.Instance.GunRequiredStars(gun).ToString();
			}
			else
			{
				m_unlockCostLabel.cachedGameObject.SetActive(value: false);
			}
		}
	}

	private void Update()
	{
		if (!m_isEnabled)
		{
			return;
		}
		if (Singleton<NGUIUpgradesManager>.Instance.ActiveContent == m_type)
		{
			if (!m_isSelected)
			{
				SetSelected(selected: true);
			}
		}
		else if (m_isSelected)
		{
			SetSelected(selected: false);
		}
	}

	public void SetSelected(bool selected)
	{
		m_isSelected = selected;
		if ((bool)myButton)
		{
			if (selected)
			{
				myButton.normalSprite = m_originalNormal + "_s";
				myButton.hoverSprite = null;
				myButton.SetState(UIButtonColor.State.Normal, immediate: true);
			}
			else
			{
				myButton.normalSprite = m_originalNormal;
				myButton.hoverSprite = m_originalHover;
			}
		}
	}

	public void SetEnabled(bool enabled)
	{
		myButton.isEnabled = (m_isEnabled = enabled);
	}

	private void OnClick()
	{
		if (m_isEnabled)
		{
			Singleton<NGUIUpgradesManager>.Instance.OpenTab(m_type);
			Singleton<NGUIProjectorMenuManager>.Instance.PlaySlideSound();
		}
	}
}
public class NGUIUpgradesManager : Singleton<NGUIUpgradesManager>
{
	[Serializable]
	public enum UpgradeTabs
	{
		Gun1,
		Gun2,
		Gun3,
		Armour,
		Pickup
	}

	[SerializeField]
	private GameObject m_armourContent;

	[SerializeField]
	private GameObject m_weaponContent;

	[SerializeField]
	private GameObject m_pickupContent;

	[SerializeField]
	private GameObject m_confirmScreenRightSide;

	[SerializeField]
	private GameObject m_confirmScreenLeftSide;

	[SerializeField]
	private UILabel m_confirmTitleLabel;

	[SerializeField]
	private UISprite m_confirmThumbnail;

	[SerializeField]
	private UISprite m_confirmThumbnailOverlay;

	[SerializeField]
	private UILabel m_confirmDescTitle;

	[SerializeField]
	private UILabel m_confirmDescriptionWithTitle;

	[SerializeField]
	private UILabel m_confirmDescriptionWithoutTitle;

	[SerializeField]
	private UILabel m_confirmCost;

	[SerializeField]
	private UISprite m_confirmExtraIcon;

	[SerializeField]
	private GameObject m_pipParent3;

	[SerializeField]
	private GameObject m_pipParent5;

	[SerializeField]
	private AudioEvent m_purchaseUpgradeSuccessEvent;

	[SerializeField]
	private AudioEvent m_purchaseUpgradeFailureEvent;

	private UpgradeTabs m_currentTab = UpgradeTabs.Armour;

	private GameObject m_activeContent;

	private int m_activeWeaponScreen;

	private UpgradeType m_currentUpgradeType;

	public int ActiveWeapon => m_activeWeaponScreen;

	public bool OnFrontPage => !m_confirmScreenLeftSide.activeInHierarchy;

	public UpgradeTabs ActiveContent => m_currentTab;

	public UpgradeType UpgradeType => m_currentUpgradeType;

	private void OnEnable()
	{
		m_weaponContent.SetActive(value: false);
		m_pickupContent.SetActive(value: false);
		m_confirmScreenLeftSide.SetActive(value: false);
		m_confirmScreenRightSide.SetActive(value: false);
		m_currentTab = UpgradeTabs.Armour;
		m_activeContent = m_armourContent;
		m_activeContent.SetActive(value: true);
	}

	private void Update()
	{
		if (Singleton<GameManager>.Instance.Button1State == GameManager.InputButtonState.ShortPress)
		{
			BackPressed();
		}
	}

	public void OpenTab(UpgradeTabs type)
	{
		if (m_currentTab != type)
		{
			m_currentTab = type;
			if ((bool)m_activeContent)
			{
				m_activeContent.SetActive(value: false);
			}
			switch (type)
			{
			case UpgradeTabs.Gun1:
			case UpgradeTabs.Gun2:
			case UpgradeTabs.Gun3:
				m_activeWeaponScreen = (int)type;
				m_activeContent = m_weaponContent;
				break;
			case UpgradeTabs.Armour:
				m_activeContent = m_armourContent;
				break;
			case UpgradeTabs.Pickup:
				m_activeContent = m_pickupContent;
				break;
			}
			m_confirmScreenLeftSide.SetActive(value: false);
			m_confirmScreenRightSide.SetActive(value: false);
			m_activeContent.SetActive(value: true);
		}
	}

	public void UpgradeSelected(UpgradeType type)
	{
		m_activeContent.SetActive(value: false);
		m_confirmScreenLeftSide.SetActive(value: true);
		m_confirmScreenRightSide.SetActive(value: true);
		if (type >= UpgradeType.Gun1Damage && type <= UpgradeType.Gun3Cooling)
		{
			ProfileUpgrades.GunUpgrades gunUpgrades;
			switch (type)
			{
			case UpgradeType.Gun1Cooling:
			case UpgradeType.Gun2Cooling:
			case UpgradeType.Gun3Cooling:
				gunUpgrades = ProfileUpgrades.GunUpgrades.Cooldown;
				break;
			case UpgradeType.Gun1Damage:
			case UpgradeType.Gun2Damage:
			case UpgradeType.Gun3Damage:
				gunUpgrades = ProfileUpgrades.GunUpgrades.Damage;
				break;
			default:
				gunUpgrades = ProfileUpgrades.GunUpgrades.RateOfFire;
				break;
			}
			int gunUpgrade = Singleton<Profile>.Instance.Upgrades.GetGunUpgrade(ActiveWeapon, gunUpgrades);
			if (type == UpgradeType.Gun1Cooling || type == UpgradeType.Gun1Damage || type == UpgradeType.Gun1FireRate)
			{
				type += ActiveWeapon * 3;
			}
			Singleton<UpgradeManager>.Instance.CanBuyUpgrade(type, out var CostOut);
			ShowConfirm(("menu_proj_upgrades_title_gun" + (ActiveWeapon + 1)).Translate(), "upgrade_item_gun" + (ActiveWeapon + 1) + "_img", Singleton<UpgradeManager>.Instance.GetUpgradeName(type), Singleton<UpgradeManager>.Instance.GetUpgradeDescription(type), gunUpgrade, 3, CostOut, thumbnailNeedsBackground: false, gunUpgrades switch
			{
				ProfileUpgrades.GunUpgrades.Cooldown => "upgrade_item_cooldown_icon", 
				ProfileUpgrades.GunUpgrades.Damage => "upgrade_item_damage_icon", 
				_ => "upgrade_item_rof_icon", 
			});
		}
		else if (type == UpgradeType.Armour)
		{
			int armourUpgrade = Singleton<Profile>.Instance.Upgrades.GetArmourUpgrade();
			Singleton<UpgradeManager>.Instance.CanBuyUpgrade(UpgradeType.Armour, out var CostOut2);
			ShowConfirm(Singleton<UpgradeManager>.Instance.GetUpgradeName(UpgradeType.Armour), "upgrade_item_armour_img", string.Empty, Singleton<UpgradeManager>.Instance.GetUpgradeDescription(UpgradeType.Armour), armourUpgrade, 5, CostOut2, thumbnailNeedsBackground: false, string.Empty);
		}
		else
		{
			int powerUpUpgrade = Singleton<Profile>.Instance.Upgrades.GetPowerUpUpgrade((int)(type - 10));
			Singleton<UpgradeManager>.Instance.CanBuyUpgrade(type, out var CostOut3);
			string text = "upgrade_pickup_";
			text = (PowerUpType)type switch
			{
				(PowerUpType)16 => text + "1", 
				(PowerUpType)10 => text + "6", 
				(PowerUpType)11 => text + "8", 
				(PowerUpType)17 => text + "7", 
				(PowerUpType)12 => text + "4", 
				(PowerUpType)13 => text + "2", 
				(PowerUpType)14 => text + "3", 
				_ => text + "5", 
			} + "_large";
			ShowConfirm(Singleton<UpgradeManager>.Instance.GetUpgradeName(type), text, string.Empty, Singleton<UpgradeManager>.Instance.GetUpgradeDescription(type), powerUpUpgrade, 5, CostOut3, thumbnailNeedsBackground: true, string.Empty);
		}
		m_currentUpgradeType = type;
	}

	public void BackPressed()
	{
		if (m_confirmScreenLeftSide.activeInHierarchy)
		{
			UpgradeConfirmClosed();
			Singleton<NGUIProjectorMenuManager>.Instance.PlaySlideSound();
		}
	}

	private void UpgradeConfirmClosed()
	{
		m_confirmScreenLeftSide.SetActive(value: false);
		m_confirmScreenRightSide.SetActive(value: false);
		m_activeContent.SetActive(value: true);
	}

	public void ShowConfirm(string title, string thumbnail, string descriptionTitle, string description, int rank, int maxRank, int cost, bool thumbnailNeedsBackground = false, string extraIcon = "")
	{
		ShowConfirmRightSide(title, thumbnail, thumbnailNeedsBackground);
		ShowConfirmLeftSide(descriptionTitle, description, rank, maxRank, cost, extraIcon);
	}

	public void ShowConfirmRightSide(string title, string thumbnail, bool thumbnailNeedsBackground = false)
	{
		m_confirmScreenRightSide.SetActive(value: true);
		m_confirmTitleLabel.text = title;
		if (thumbnailNeedsBackground)
		{
			m_confirmThumbnail.spriteName = "upgrade_pickup_container_backdrop";
			m_confirmThumbnailOverlay.spriteName = thumbnail;
			m_confirmThumbnailOverlay.MakePixelPerfect();
		}
		else
		{
			m_confirmThumbnail.spriteName = thumbnail;
		}
		m_confirmThumbnailOverlay.gameObject.SetActive(thumbnailNeedsBackground);
	}

	public void ShowConfirmLeftSide(string title, string description, int rank, int maxRank, int cost, string extraIcon = "")
	{
		m_confirmCost.text = ((rank != maxRank) ? NGUIProjectorMenuManager.ProcessNumber(cost) : "menu_proj_upgrades_max".Translate());
		if (extraIcon.Length > 0)
		{
			m_confirmExtraIcon.enabled = true;
			m_confirmExtraIcon.spriteName = extraIcon;
			m_confirmExtraIcon.MakePixelPerfect();
		}
		else
		{
			m_confirmExtraIcon.enabled = false;
		}
		m_confirmDescTitle.text = title;
		if (title.Length > 0)
		{
			m_confirmDescriptionWithTitle.text = description;
			m_confirmDescriptionWithoutTitle.text = string.Empty;
		}
		else
		{
			m_confirmDescriptionWithoutTitle.text = description;
			m_confirmDescriptionWithTitle.text = string.Empty;
		}
		GameObject gameObject;
		if (maxRank == 3)
		{
			gameObject = m_pipParent3;
			m_pipParent5.SetActive(value: false);
			m_pipParent3.SetActive(value: true);
		}
		else
		{
			gameObject = m_pipParent5;
			m_pipParent5.SetActive(value: true);
			m_pipParent3.SetActive(value: false);
		}
		UISprite[] componentsInChildren = gameObject.GetComponentsInChildren<UISprite>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (i < rank)
			{
				componentsInChildren[i].spriteName = "upgrade_item_details_status1";
			}
			else if (i == rank)
			{
				componentsInChildren[i].spriteName = "upgrade_item_details_status2";
			}
			else
			{
				componentsInChildren[i].spriteName = "upgrade_item_details_status0";
			}
		}
	}

	public bool CanBuyCurrentUpgrade()
	{
		return Singleton<UpgradeManager>.Instance.CanBuyUpgrade(m_currentUpgradeType) >= 0;
	}

	public void ConfirmUpgrade()
	{
		if (Singleton<UpgradeManager>.Instance.BuyUpgrade(m_currentUpgradeType))
		{
			UpgradeSelected(m_currentUpgradeType);
			Singleton<AudioManager>.Instance.Play(m_purchaseUpgradeSuccessEvent);
			return;
		}
		if (Singleton<UpgradeManager>.Instance.IsUpgradeMaxed(m_currentUpgradeType))
		{
			Singleton<TutorialManager>.Instance.ShowPopup("menu_proj_upgrades_max_upgrade", 480);
		}
		else
		{
			Singleton<TutorialManager>.Instance.ShowPopup("menu_proj_upgrades_cant_buy", 480);
		}
		Singleton<AudioManager>.Instance.Play(m_purchaseUpgradeFailureEvent);
	}
}
public class NGUIWeaponUpgrade : MonoBehaviour
{
	[SerializeField]
	private UILabel m_nameLabel;

	[SerializeField]
	private UISprite m_picture;

	[SerializeField]
	private GameObject m_cooldownPipParent;

	[SerializeField]
	private UILabel m_cooldownCostLabel;

	[SerializeField]
	private GameObject m_rofPipParent;

	[SerializeField]
	private UILabel m_rofCostLabel;

	[SerializeField]
	private GameObject m_damagePipParent;

	[SerializeField]
	private UILabel m_damageCostLabel;

	private void OnEnable()
	{
		Refresh();
	}

	private void Refresh()
	{
		int activeWeapon = Singleton<NGUIUpgradesManager>.Instance.ActiveWeapon;
		Singleton<NGUIUpgradesManager>.Instance.ShowConfirmRightSide(("menu_proj_upgrades_title_gun" + (activeWeapon + 1)).Translate(), "upgrade_item_gun" + (activeWeapon + 1) + "_img");
		for (int i = 0; i < 3; i++)
		{
			ProfileUpgrades.GunUpgrades upgrade;
			GameObject gameObject;
			UILabel uILabel;
			UpgradeType upgradeType;
			switch (i)
			{
			case 0:
				upgrade = ProfileUpgrades.GunUpgrades.Cooldown;
				upgradeType = UpgradeType.Gun1Cooling;
				gameObject = m_cooldownPipParent;
				uILabel = m_cooldownCostLabel;
				break;
			case 1:
				upgrade = ProfileUpgrades.GunUpgrades.Damage;
				upgradeType = UpgradeType.Gun1Damage;
				gameObject = m_damagePipParent;
				uILabel = m_damageCostLabel;
				break;
			default:
				upgrade = ProfileUpgrades.GunUpgrades.RateOfFire;
				upgradeType = UpgradeType.Gun1FireRate;
				gameObject = m_rofPipParent;
				uILabel = m_rofCostLabel;
				break;
			}
			upgradeType += activeWeapon * 3;
			int gunUpgrade = Singleton<Profile>.Instance.Upgrades.GetGunUpgrade(activeWeapon, upgrade);
			if (Singleton<UpgradeManager>.Instance.CanBuyUpgrade(upgradeType, out var CostOut) == -1 && CostOut == 0)
			{
				uILabel.text = "menu_proj_upgrades_max".Translate();
			}
			else
			{
				uILabel.text = NGUIProjectorMenuManager.ProcessNumber(CostOut);
			}
			UISprite[] componentsInChildren = gameObject.GetComponentsInChildren<UISprite>();
			for (int j = 0; j < componentsInChildren.Length; j++)
			{
				if (j < gunUpgrade)
				{
					componentsInChildren[j].spriteName = "upgrade_item_button_pip_full";
				}
				else
				{
					componentsInChildren[j].spriteName = "upgrade_item_button_pip_empty";
				}
			}
		}
	}
}
public class BulletPool : GenericPool<Bullet>
{
	public static BulletPool Instance;

	private List<Bullet> m_activeBullets = new List<Bullet>(100);

	private List<Bullet> m_bulletsToDelete = new List<Bullet>(100);

	[SerializeField]
	private string m_enemyBulletMask = "EnemyBullet";

	[SerializeField]
	private string m_playerBulletMask = "PlayerBullet";

	private int m_enemyBulletLayerID;

	private int m_playerBulletLayerID;

	private int m_inactiveBulletLayerID;

	private void Awake()
	{
		Instance = this;
		m_enemyBulletLayerID = LayerMask.NameToLayer(m_enemyBulletMask);
		m_playerBulletLayerID = LayerMask.NameToLayer(m_playerBulletMask);
		m_inactiveBulletLayerID = LayerMask.NameToLayer("Ignore Raycast");
	}

	private void Update()
	{
		int count = m_activeBullets.Count;
		for (int i = 0; i < count; i++)
		{
			m_activeBullets[i].Tick(Time.deltaTime);
		}
		int count2 = m_bulletsToDelete.Count;
		if (count2 > 0)
		{
			for (int j = 0; j < count2; j++)
			{
				m_activeBullets.Remove(m_bulletsToDelete[j]);
			}
			m_bulletsToDelete.Clear();
		}
	}

	public Bullet GetFromPool(Bullet cloneFrom, Vector3 pos, Quaternion rot, bool playerBullet)
	{
		Bullet bullet = null;
		if (m_Pool.Count > 0)
		{
			bullet = m_Pool.Pop();
		}
		if (!bullet && (bool)cloneFrom)
		{
			bullet = UnityEngine.Object.Instantiate(cloneFrom);
			UnityEngine.Debug.Log("Pool short instantiating" + cloneFrom.name);
		}
		else if ((bool)bullet)
		{
			bullet.gameObject.SetActive(value: true);
		}
		bullet.transform.parent = base.transform;
		bullet.Initialise(cloneFrom, pos, rot);
		m_activeBullets.Add(bullet);
		bullet.gameObject.layer = ((!playerBullet) ? m_enemyBulletLayerID : m_playerBulletLayerID);
		bullet.rigidbody.useGravity = true;
		bullet.rigidbody.WakeUp();
		bullet.isActive = true;
		return bullet;
	}

	public override void ReturnToPool(Bullet obj)
	{
		base.ReturnToPool(obj);
		m_bulletsToDelete.Add(obj);
		obj.isActive = false;
		obj.rigidbody.useGravity = false;
		obj.rigidbody.angularVelocity = Vector3.zero;
		obj.rigidbody.velocity = Vector3.zero;
		obj.rigidbody.Sleep();
		obj.gameObject.layer = m_inactiveBulletLayerID;
	}
}
public enum EffectType
{
	None,
	Explosion,
	Sparks,
	PlayerSparks,
	ExplosionV2,
	ExplosionWasserfall
}
public class EffectsPool : Singleton<EffectsPool>
{
	[SerializeField]
	private GameObject m_explosionEffect;

	[SerializeField]
	private GameObject m_explosionEffectReduced;

	public int numExplosionInstances = 10;

	[SerializeField]
	private GameObject m_explosionV2Effect;

	public int numExplosionV2Instances = 10;

	[SerializeField]
	private GameObject m_explosionWasserfallEffect;

	public int numExplosionWasserfallInstances = 10;

	[SerializeField]
	private GameObject m_sparksEffect;

	public int numSparkInstances = 40;

	[SerializeField]
	private GameObject m_playerSparkEffect;

	public int numPlayerSparkInstances = 30;

	private Dictionary<EffectType, Stack<ParticleSystem>> pool = new Dictionary<EffectType, Stack<ParticleSystem>>();

	public void ReturnToPool(ParticleSystem obj, EffectType type)
	{
		obj.gameObject.SetActive(value: false);
		obj.transform.parent = base.transform;
		pool[type].Push(obj);
	}

	public virtual ParticleSystem GetFromPool(EffectType type, Vector3 pos, Quaternion rot)
	{
		Stack<ParticleSystem> stack = pool[type];
		ParticleSystem particleSystem = null;
		if (stack.Count > 0)
		{
			particleSystem = stack.Pop();
			particleSystem.transform.position = pos;
			particleSystem.transform.rotation = rot;
		}
		else
		{
			UnityEngine.Debug.Log("Effects pool empty getting " + type);
			switch (type)
			{
			case EffectType.Explosion:
				particleSystem = UnityEngine.Object.Instantiate((!Singleton<GameManager>.Instance.ReduceQuality) ? m_explosionEffect : m_explosionEffectReduced, pos, rot).GetComponent<ParticleSystem>();
				break;
			case EffectType.ExplosionV2:
				particleSystem = UnityEngine.Object.Instantiate(m_explosionV2Effect, pos, rot).GetComponent<ParticleSystem>();
				break;
			case EffectType.Sparks:
				particleSystem = UnityEngine.Object.Instantiate(m_sparksEffect, pos, rot).GetComponent<ParticleSystem>();
				break;
			case EffectType.PlayerSparks:
				particleSystem = UnityEngine.Object.Instantiate(m_playerSparkEffect, pos, rot).GetComponent<ParticleSystem>();
				break;
			}
			particleSystem.transform.parent = base.transform;
		}
		particleSystem.gameObject.SetActive(value: true);
		return particleSystem;
	}

	public void InitEffects()
	{
		pool[EffectType.Explosion] = new Stack<ParticleSystem>();
		for (int i = 0; i < numExplosionInstances; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate((!Singleton<GameManager>.Instance.ReduceQuality) ? m_explosionEffect : m_explosionEffectReduced);
			pool[EffectType.Explosion].Push(gameObject.GetComponent<ParticleSystem>());
			gameObject.transform.parent = base.transform;
			gameObject.SetActive(value: false);
		}
		if (Singleton<MissionManager>.Instance.DoingBonusMission)
		{
			pool[EffectType.ExplosionV2] = new Stack<ParticleSystem>();
			for (int j = 0; j < numExplosionV2Instances; j++)
			{
				GameObject gameObject2 = UnityEngine.Object.Instantiate(m_explosionV2Effect);
				pool[EffectType.ExplosionV2].Push(gameObject2.GetComponent<ParticleSystem>());
				gameObject2.transform.parent = base.transform;
				gameObject2.SetActive(value: false);
			}
		}
		if (Singleton<EnemyBehaviorManager>.Instance.MissionHasWasserfalls)
		{
			pool[EffectType.ExplosionWasserfall] = new Stack<ParticleSystem>();
			for (int k = 0; k < numExplosionV2Instances; k++)
			{
				GameObject gameObject3 = UnityEngine.Object.Instantiate(m_explosionWasserfallEffect);
				pool[EffectType.ExplosionWasserfall].Push(gameObject3.GetComponent<ParticleSystem>());
				gameObject3.transform.parent = base.transform;
				gameObject3.SetActive(value: false);
			}
		}
		pool[EffectType.Sparks] = new Stack<ParticleSystem>();
		for (int l = 0; l < numSparkInstances; l++)
		{
			GameObject gameObject4 = UnityEngine.Object.Instantiate(m_sparksEffect);
			pool[EffectType.Sparks].Push(gameObject4.GetComponent<ParticleSystem>());
			gameObject4.transform.parent = base.transform;
			gameObject4.SetActive(value: false);
		}
		pool[EffectType.PlayerSparks] = new Stack<ParticleSystem>();
		for (int m = 0; m < numPlayerSparkInstances; m++)
		{
			GameObject gameObject5 = UnityEngine.Object.Instantiate(m_playerSparkEffect);
			pool[EffectType.PlayerSparks].Push(gameObject5.GetComponent<ParticleSystem>());
			gameObject5.transform.parent = base.transform;
			gameObject5.SetActive(value: false);
		}
	}
}
public class EnemiesPool : Singleton<EnemiesPool>
{
	private Dictionary<GameObject, Stack<EnemyBehavior>> pool = new Dictionary<GameObject, Stack<EnemyBehavior>>();

	[NonSerialized]
	[HideInInspector]
	public new Transform transform;

	protected override void Awake()
	{
		base.Awake();
		transform = GetComponent<Transform>();
	}

	public void ReturnToPool(EnemyBehavior obj, GameObject prefab)
	{
		obj.gameObject.SetActive(value: false);
		pool[prefab].Push(obj);
	}

	public EnemyBehavior GetFromPool(GameObject cloneFrom, Vector3 pos, Quaternion rot)
	{
		Stack<EnemyBehavior> stack = pool[cloneFrom];
		EnemyBehavior enemyBehavior;
		if (stack.Count > 0)
		{
			enemyBehavior = stack.Pop();
			enemyBehavior.transform.position = pos;
			enemyBehavior.transform.rotation = rot;
		}
		else
		{
			UnityEngine.Debug.Log("Enemies pool empty getting " + cloneFrom);
			enemyBehavior = UnityEngine.Object.Instantiate(cloneFrom, pos, rot).GetComponent<EnemyBehavior>();
		}
		enemyBehavior.gameObject.SetActive(value: true);
		return enemyBehavior;
	}

	public void InitEnemies(List<EnemySpawner> enemySpawners, int maxPlanesAtATime)
	{
		int num = (int)((float)maxPlanesAtATime * 1.2f);
		int count = enemySpawners.Count;
		for (int i = 0; i < count; i++)
		{
			EnemySpawner enemySpawner = enemySpawners[i];
			GameObject enemyPreset = enemySpawner.m_enemyPreset;
			Stack<EnemyBehavior> stack = new Stack<EnemyBehavior>();
			pool[enemyPreset] = stack;
			Stack<EnemyBehavior> stack2 = stack;
			for (int j = 0; j < num; j++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(enemyPreset, transform.position, transform.rotation);
				EnemyBehavior component = gameObject.GetComponent<EnemyBehavior>();
				stack2.Push(component);
				gameObject.transform.parent = transform;
				gameObject.SetActive(value: false);
			}
		}
	}
}
public class FlyingScorePool : Singleton<FlyingScorePool>
{
	[SerializeField]
	private NGUIFlyingScore m_prefab;

	private Stack<NGUIFlyingScore> m_pool = new Stack<NGUIFlyingScore>();

	protected override void Awake()
	{
		base.Awake();
		for (int i = 0; i < 8; i++)
		{
			NGUIFlyingScore nGUIFlyingScore = UnityEngine.Object.Instantiate(m_prefab);
			nGUIFlyingScore.transform.parent = base.transform;
			nGUIFlyingScore.gameObject.SetActive(value: false);
			m_pool.Push(nGUIFlyingScore);
		}
	}

	public void ShowNewFloater(Vector3 position, int score, int bonus = 0, int multiplier = 1, int killsProgress = 0, int killsRequired = 0)
	{
		NGUIFlyingScore nGUIFlyingScore = null;
		if (m_pool.Count > 0)
		{
			nGUIFlyingScore = m_pool.Pop();
		}
		if (nGUIFlyingScore == null)
		{
			nGUIFlyingScore = UnityEngine.Object.Instantiate(m_prefab);
		}
		nGUIFlyingScore.gameObject.SetActive(value: true);
		nGUIFlyingScore.Refresh(score, bonus, multiplier, killsProgress, killsRequired);
		Vector3 vector = Singleton<CameraManager>.Instance.transform.position - position;
		float num = Mathf.Atan2(vector.x, vector.z) * 57.29578f + 180f;
		vector = Quaternion.Euler(new Vector3(0f, 0f - num, 0f)) * vector;
		float x = Mathf.Atan2(0f - vector.y, vector.z) * 57.29578f + 180f;
		Quaternion rotation = Quaternion.Euler(new Vector3(x, num, 0f));
		nGUIFlyingScore.Scale = vector.magnitude * 0.0005f;
		nGUIFlyingScore.transform.position = position + new Vector3(0f, 100f * nGUIFlyingScore.Scale, 0f);
		nGUIFlyingScore.transform.rotation = rotation;
		nGUIFlyingScore.StartShowing();
	}

	public void ReturnToPool(NGUIFlyingScore score)
	{
		score.gameObject.SetActive(value: false);
		m_pool.Push(score);
	}
}
public class GenericPool<T> : MonoBehaviour where T : MonoBehaviour
{
	[SerializeField]
	private T m_DefaultPrefab;

	[SerializeField]
	private int m_StartingPoolSize = 10;

	private bool m_deactivateGO;

	protected Stack<T> m_Pool = new Stack<T>();

	protected virtual void Start()
	{
		for (int i = 0; i < m_StartingPoolSize; i++)
		{
			T t = UnityEngine.Object.Instantiate(m_DefaultPrefab);
			m_Pool.Push(t);
			t.transform.parent = base.transform;
			t.gameObject.SetActive(value: false);
		}
	}

	public virtual void ReturnToPool(T obj)
	{
		if (m_deactivateGO)
		{
			obj.gameObject.SetActive(value: false);
		}
		m_Pool.Push(obj);
	}

	protected virtual IEnumerator ReturnToPoolCoroutine(T obj)
	{
		m_Pool.Push(obj);
		return null;
	}

	public virtual T GetFromPool(T cloneFrom, Vector3 pos, Quaternion rot)
	{
		T val = (T)null;
		if (m_Pool.Count > 0)
		{
			val = m_Pool.Pop();
		}
		if (!val && (bool)m_DefaultPrefab)
		{
			val = UnityEngine.Object.Instantiate(m_DefaultPrefab);
			UnityEngine.Debug.Log("Pool short instantiating" + m_DefaultPrefab.name);
		}
		else if ((bool)val)
		{
			val.gameObject.SetActive(value: true);
		}
		if (!val)
		{
			return (T)null;
		}
		val.transform.parent = base.transform;
		return val;
	}
}
public class LevelOpening : MonoBehaviour
{
	[SerializeField]
	private float fadeSpeed = 1f;

	private AudioSource audioSource;

	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		audioSource = GetComponent<AudioSource>();
		if (Singleton<Profile>.TryInstance())
		{
			audioSource.volume *= Singleton<Profile>.Instance.Settings.GetVolume(VolumeSettings.SFX);
		}
	}

	private void Update()
	{
		if (Singleton<GameManager>.Instance.Button1State == GameManager.InputButtonState.ShortPress)
		{
		}
		if (InputUtils.GetFire1ButtonDown() && !Singleton<LoadingScreen>.TryInstance())
		{
			Singleton<LoadingScreen>.Instance.LoadMenu(LoadingScreen.ComingFrom.Boot);
			Singleton<AudioManager>.Instance.PlayOneShot(AudioEvent.EvtGUI_IN_NME_Wave_Start);
			StartCoroutine(FadeOutOnLevelExit());
		}
	}

	private IEnumerator FadeOutOnLevelExit()
	{
		while (audioSource.volume > 0f)
		{
			audioSource.volume -= fadeSpeed * Time.deltaTime;
			yield return null;
		}
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class OpeningPlaneSpawner : Singleton<OpeningPlaneSpawner>
{
	[SerializeField]
	private GameObject lancasterPlanePrefab;

	[SerializeField]
	private float minSpawnTime = 1f;

	[SerializeField]
	private float maxSpawnTime = 5f;

	private float spawnTimer;

	private float spawnTime;

	private Stack<OpeningFriendlyPlane> planePool = new Stack<OpeningFriendlyPlane>();

	[SerializeField]
	private float maxXRotation = 20f;

	[SerializeField]
	private float minXRotation = -20f;

	[SerializeField]
	private float maxYRotation = 20f;

	[SerializeField]
	private float minYRotation = -20f;

	private void Start()
	{
		spawnTime = UnityEngine.Random.Range(minSpawnTime, maxSpawnTime);
		Spawn();
	}

	private void Spawn()
	{
		OpeningFriendlyPlane openingFriendlyPlane;
		if (planePool.Count == 0)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(lancasterPlanePrefab, base.transform.position, base.transform.rotation);
			gameObject.transform.parent = base.transform;
			gameObject.transform.rotation *= GetPlaneSpawnRotation();
			openingFriendlyPlane = gameObject.GetComponent<OpeningFriendlyPlane>();
		}
		else
		{
			openingFriendlyPlane = planePool.Pop();
			openingFriendlyPlane.gameObject.SetActive(value: true);
			openingFriendlyPlane.transform.position = base.transform.position;
			openingFriendlyPlane.transform.rotation = base.transform.rotation;
			openingFriendlyPlane.transform.rotation *= GetPlaneSpawnRotation();
		}
		openingFriendlyPlane.Reset();
	}

	private Quaternion GetPlaneSpawnRotation()
	{
		float num = UnityEngine.Random.Range(minYRotation, maxYRotation);
		float num2 = UnityEngine.Random.Range(minXRotation, maxXRotation);
		if (Math.Abs(num2) < 5f)
		{
			bool flag = false;
			while (Math.Abs(num) < 10f)
			{
				num = UnityEngine.Random.Range(minYRotation, maxYRotation);
				flag = true;
			}
			if (!flag)
			{
				while (Math.Abs(num2) < 5f)
				{
					num2 = UnityEngine.Random.Range(minXRotation, maxXRotation);
				}
			}
		}
		return Quaternion.Euler(num2, num, 0f);
	}

	private void Update()
	{
		spawnTimer += Time.deltaTime;
		if (spawnTimer >= spawnTime)
		{
			Spawn();
			spawnTimer = 0f;
			spawnTime = UnityEngine.Random.Range(minSpawnTime, maxSpawnTime);
		}
	}

	public void AddToPool(OpeningFriendlyPlane plane)
	{
		planePool.Push(plane);
		plane.gameObject.SetActive(value: false);
	}
}
public class FriendlyPlane : MonoBehaviour
{
	private float m_maxHealth;

	private float m_curHealth;

	[SerializeField]
	private float m_minOffset;

	[SerializeField]
	private float m_maxOffset;

	[SerializeField]
	private float m_offsetSpeed;

	[SerializeField]
	private float m_fallingSpeed;

	[SerializeField]
	private float m_fallingAcceleration;

	[SerializeField]
	private float m_fallingRotationSpeed = 0.005f;

	[SerializeField]
	private float m_fallingBackSpeed = 1.2f;

	[SerializeField]
	private ParticleSystem m_explodeEffect;

	private ParticleSystem m_activeExplodeEffect;

	private DamageEffect m_smokeEffect;

	private float m_target;

	private float m_currentOffset;

	private float m_currentDirection = 1f;

	private float m_velocity;

	private Vector3 m_position;

	private float m_currentSpeed;

	private float m_fallingVelocity;

	[NonSerialized]
	[HideInInspector]
	public Rigidbody rigidbody;

	[NonSerialized]
	[HideInInspector]
	public new Transform transform;

	private Quaternion m_rotation;

	private FriendlyPlaneHealthBar m_healthBar;

	[SerializeField]
	private UnityEngine.Color fullHealthColour = UnityEngine.Color.green;

	[SerializeField]
	private UnityEngine.Color minorHealthLossColour = UnityEngine.Color.yellow;

	[SerializeField]
	private UnityEngine.Color majorHealthLossColour = UnityEngine.Color.red;

	[SerializeField]
	private float healthBarYOffset;

	[SerializeField]
	private float healthBarZOffset;

	[SerializeField]
	private float healthScaleModifier = 50f;

	private void Awake()
	{
		transform = GetComponent<Transform>();
		m_position = transform.position;
		rigidbody = GetComponent<Rigidbody>();
		m_target = m_maxOffset;
		m_smokeEffect = transform.GetComponentInChildren<DamageEffect>();
		m_rotation = transform.rotation;
	}

	private void SetupHealthBar()
	{
		if (m_healthBar == null)
		{
			m_healthBar = FriendlyPlaneHealthBar.CreateNew(this, fullHealthColour, minorHealthLossColour, majorHealthLossColour);
			if (!(m_healthBar == null))
			{
				m_healthBar.SetOffsetAndScale(healthBarYOffset, healthBarZOffset, healthScaleModifier);
			}
		}
	}

	private void OnDestroy()
	{
		if (Singleton<GameManager>.Instance != null)
		{
			Singleton<GameManager>.Instance.OnStartMission -= SelfDestroy;
		}
		if (!Singleton<LoadingScreen>.TryInstance() && Singleton<MissionManager>.Instance != null)
		{
			Singleton<MissionManager>.Instance.RemoveFriend(this);
		}
		if ((bool)m_activeExplodeEffect)
		{
			UnityEngine.Object.Destroy(m_activeExplodeEffect.gameObject);
		}
	}

	private void SelfDestroy(bool restart)
	{
		if (m_curHealth <= 0f)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	public void SetHealth(float health)
	{
		m_maxHealth = health;
		m_curHealth = m_maxHealth;
		Singleton<GameManager>.Instance.OnStartMission += SelfDestroy;
		SetupHealthBar();
	}

	public float Hurt(float damage)
	{
		if (m_curHealth > 0f)
		{
			float curHealth = m_curHealth;
			m_curHealth = Mathf.Max(m_curHealth - damage, 0f);
			float curHealth2 = m_curHealth;
			if (m_curHealth <= 0f)
			{
				m_activeExplodeEffect = UnityEngine.Object.Instantiate(m_explodeEffect, transform.position, transform.rotation);
				Singleton<MissionManager>.Instance.FriendDied(this);
			}
			return curHealth - curHealth2;
		}
		return 0f;
	}

	public void Tick()
	{
		if (m_curHealth > 0f)
		{
			float num = Mathf.SmoothDamp(m_currentOffset, m_target * m_currentDirection, ref m_velocity, m_offsetSpeed);
			if (Mathf.Abs(m_target * m_currentDirection - num) < 1f)
			{
				m_currentDirection *= -1f;
				m_target = UnityEngine.Random.Range(m_minOffset - 0.0001f, m_maxOffset);
			}
			m_position.y += num - m_currentOffset;
			m_currentOffset = num;
		}
		else
		{
			m_currentSpeed = Mathf.SmoothDamp(m_currentSpeed, m_fallingSpeed, ref m_fallingVelocity, m_fallingAcceleration);
			m_position += transform.forward * m_currentSpeed;
			m_position -= Vector3.forward * (m_currentSpeed * m_fallingBackSpeed);
			m_rotation = Quaternion.Lerp(m_rotation, Quaternion.LookRotation(-Vector3.up), m_currentSpeed * m_fallingRotationSpeed);
			if ((bool)m_activeExplodeEffect && !m_activeExplodeEffect.isPlaying)
			{
				UnityEngine.Object.Destroy(m_activeExplodeEffect.gameObject);
				m_activeExplodeEffect = null;
			}
			Plane[] planes = GeometryUtility.CalculateFrustumPlanes(Camera.main);
			Vector3 center = m_position + transform.forward * 50f;
			Bounds bounds = new Bounds(center, new Vector3(1f, 1f, 1f));
			if (!GeometryUtility.TestPlanesAABB(planes, GetComponent<Collider>().bounds) && !GeometryUtility.TestPlanesAABB(planes, bounds))
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
		m_smokeEffect.UpdateSmoke(GetHealthPercentage());
		if (m_healthBar != null)
		{
			m_healthBar.Tick();
		}
	}

	public float GetHealthPercentage()
	{
		return m_curHealth / m_maxHealth;
	}

	private void FixedUpdate()
	{
		rigidbody.MovePosition(m_position);
		rigidbody.MoveRotation(m_rotation);
	}
}
public class OpeningFriendlyPlane : MonoBehaviour
{
	[SerializeField]
	private AudioEvent engineEvent = AudioEvent.EvtNPCNMEEngine03_lrg;

	[SerializeField]
	private AudioEvent passbyEvent = AudioEvent.EvtEndSeq_Lanc_Flyby;

	[SerializeField]
	private float distanceToPlayPassbySound = 10f;

	[SerializeField]
	private float flightSpeed = 50f;

	[SerializeField]
	private float lifeTime = 10f;

	private float lifeTimer;

	private bool hasPlayedFlyby;

	public void Reset()
	{
		Singleton<AudioManager>.Instance.SetParameter(engineEvent, ParameterType.Damage, 0f, base.gameObject, canBePaused: false);
		Singleton<AudioManager>.Instance.SetParameter(engineEvent, ParameterType.Angle, 0.5f, base.gameObject, canBePaused: false);
		hasPlayedFlyby = false;
	}

	private void Update()
	{
		base.transform.position += base.transform.forward * flightSpeed * Time.deltaTime;
		lifeTimer += Time.deltaTime;
		if (lifeTimer >= lifeTime)
		{
			Singleton<OpeningPlaneSpawner>.Instance.AddToPool(this);
			lifeTimer = 0f;
		}
		if (!hasPlayedFlyby && base.transform.position.z <= distanceToPlayPassbySound)
		{
			Singleton<AudioManager>.Instance.Play(passbyEvent, base.gameObject);
			hasPlayedFlyby = true;
		}
	}
}
public class PlayerStats : MonoBehaviour
{
	[Serializable]
	public struct HealthChatterAudioLevel
	{
		public float HealthThresholdPct;

		public AudioEvent Event;
	}

	private float m_maxHealth;

	[SerializeField]
	private float m_maxBanking;

	[SerializeField]
	private bool m_godMode;

	private float m_currentHealth;

	private float m_damageAudioParamTargetValue;

	private float m_damageAudioParamValue;

	private DamageEffect m_smokeEffect;

	[SerializeField]
	private List<HealthChatterAudioLevel> m_HealthChatterAudioLevels = new List<HealthChatterAudioLevel>();

	[SerializeField]
	private float m_damageAudioParamChangeRate = 0.25f;

	[NonSerialized]
	[HideInInspector]
	public new Transform transform;

	public bool Invulnerable
	{
		get
		{
			return m_godMode;
		}
		set
		{
			m_godMode = value;
		}
	}

	private void Awake()
	{
		transform = GetComponent<Transform>();
	}

	private void Start()
	{
		m_maxHealth = Singleton<UpgradeManager>.Instance.GetMaxHealth();
		m_damageAudioParamValue = 0f;
		m_damageAudioParamTargetValue = 0f;
		Singleton<GameManager>.Instance.OnStartMission += Restart;
		Singleton<AudioManager>.Instance.SetParameter(AudioEvent.EvtBomberEngineDrone, ParameterType.Damage, m_damageAudioParamValue, base.gameObject, canBePaused: false);
		if (m_smokeEffect == null)
		{
			m_smokeEffect = transform.GetComponentInChildren<DamageEffect>();
		}
	}

	private void OnDestroy()
	{
		if (Singleton<GameManager>.Instance != null)
		{
			Singleton<GameManager>.Instance.OnStartMission -= Restart;
		}
	}

	private void Update()
	{
		if (Singleton<GameManager>.Instance.State == GameManager.GameState.InGame)
		{
			if (m_damageAudioParamValue != m_damageAudioParamTargetValue)
			{
				float num = m_damageAudioParamChangeRate * Time.deltaTime;
				float num2 = Mathf.Clamp(m_damageAudioParamTargetValue - m_damageAudioParamValue, 0f - num, num);
				m_damageAudioParamValue += num2;
				Singleton<AudioManager>.Instance.SetParameter(AudioEvent.EvtBomberEngineDrone, ParameterType.Damage, m_damageAudioParamValue, base.gameObject, canBePaused: false);
			}
			m_smokeEffect.UpdateSmoke(GetHealthPercentage());
		}
	}

	private void SetCurrentHealth(float newHealth)
	{
		m_currentHealth = Mathf.Clamp(newHealth, 0f, m_maxHealth);
		m_damageAudioParamTargetValue = 1f - GetHealthPercentage();
	}

	public float Hurt(float damage)
	{
		if (!m_godMode && m_currentHealth > 0f)
		{
			float currentHealth = m_currentHealth;
			float num = m_currentHealth / m_maxHealth * 100f;
			SetCurrentHealth(m_currentHealth - damage);
			float currentHealth2 = m_currentHealth;
			float num2 = m_currentHealth / m_maxHealth * 100f;
			for (int i = 0; i < m_HealthChatterAudioLevels.Count; i++)
			{
				if (num > m_HealthChatterAudioLevels[i].HealthThresholdPct && num2 <= m_HealthChatterAudioLevels[i].HealthThresholdPct)
				{
					Singleton<AudioManager>.Instance.Play(m_HealthChatterAudioLevels[i].Event, base.gameObject);
				}
			}
			if (m_currentHealth <= 0f)
			{
				Singleton<GameManager>.Instance.Death();
			}
			return currentHealth - currentHealth2;
		}
		return 0f;
	}

	public void PowerUp(float healthBonus)
	{
		SetCurrentHealth(m_currentHealth + m_maxHealth * healthBonus * 0.01f);
	}

	private void Restart(bool restart)
	{
		SetCurrentHealth(m_maxHealth);
		Singleton<GameManager>.Instance.Turret.CurrentGun.OnStartMission();
	}

	public float GetHealthPercentage()
	{
		return m_currentHealth / m_maxHealth;
	}

	public float GetOverheatPercentage()
	{
		return Singleton<GameManager>.Instance.Turret.CurrentGun.Overheat;
	}
}
public class PowerUp : MonoBehaviour
{
	[SerializeField]
	private float m_lifeTime;

	[SerializeField]
	private AnimationCurve m_curve1;

	[SerializeField]
	private AnimationCurve m_curve2;

	[SerializeField]
	private float m_fallingSpeed;

	[SerializeField]
	private float m_movementSpeed;

	[SerializeField]
	private float m_swingOffset = 8f;

	[SerializeField]
	private float m_swingSpeed;

	[SerializeField]
	private float m_initialFallingSpeed;

	[SerializeField]
	private float m_parachuteDeceleration;

	protected float m_curTime;

	[HideInInspector]
	public PowerUpType Type;

	[HideInInspector]
	public bool Positive = true;

	private float m_currentOffset;

	private float m_currentDirection = 1f;

	private float m_swingVelocity;

	private float m_curFallingSpeed;

	private float m_fallingVelocity;

	private Transform m_parachute;

	private bool m_isActivated;

	private void Awake()
	{
		Singleton<GameManager>.Instance.OnEndMission += DestroyPowerUp;
		m_parachute = base.transform.GetChild(1);
		m_curFallingSpeed = m_initialFallingSpeed;
	}

	private void DestroyPowerUp(GameManager.EndMissionReason reason)
	{
		Singleton<PowerUpManager>.Instance.DestroyPowerUp(this);
	}

	private void OnDestroy()
	{
		if (Singleton<GameManager>.TryInstance())
		{
			Singleton<GameManager>.Instance.OnEndMission -= DestroyPowerUp;
		}
	}

	public void Initialise()
	{
		float z;
		float x = (z = m_curve2.Evaluate(0f));
		float y = m_curve1.Evaluate(0f);
		m_parachute.localScale = new Vector3(x, y, z);
	}

	private void Update()
	{
		m_curTime += Time.deltaTime;
		if (!m_isActivated)
		{
			float z;
			float x = (z = m_curve2.Evaluate(m_curTime));
			float y = m_curve1.Evaluate(m_curTime);
			m_parachute.localScale = new Vector3(x, y, z);
			if (m_curTime > 1f)
			{
				m_isActivated = true;
			}
		}
		else
		{
			if (Singleton<PowerUpManager>.Instance.CollectPowerUpEvent == null)
			{
				m_curFallingSpeed = Mathf.SmoothDamp(m_curFallingSpeed, m_fallingSpeed, ref m_fallingVelocity, m_parachuteDeceleration);
			}
			else
			{
				m_curFallingSpeed = Mathf.SmoothDamp(m_curFallingSpeed, 0f, ref m_fallingVelocity, m_parachuteDeceleration);
			}
			float num = Mathf.SmoothDamp(m_currentOffset, m_swingOffset * m_currentDirection, ref m_swingVelocity, m_swingSpeed);
			if (Mathf.Abs(m_swingOffset * m_currentDirection - num) < 1f)
			{
				m_currentDirection *= -1f;
			}
			base.transform.Rotate(base.transform.right, num - m_currentOffset);
			m_currentOffset = num;
			if (m_curTime > m_lifeTime && Singleton<PowerUpManager>.Instance.CollectPowerUpEvent == null)
			{
				Singleton<PowerUpManager>.Instance.DestroyPowerUp(this);
				m_isActivated = false;
			}
		}
		base.transform.position += base.transform.forward * m_movementSpeed;
		base.transform.position -= Vector3.up * m_curFallingSpeed * Time.deltaTime;
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (m_isActivated)
		{
			Singleton<PowerUpManager>.Instance.CollectPowerUp(this);
			m_isActivated = false;
		}
	}
}
public abstract class PowerUpDisplay : MonoBehaviour
{
	public PowerUpDisplayType displayType;

	public abstract void SetAlpha(float alpha);

	public abstract void SetScale(float scale);
}
public class PowerUpDisplay_Localized : PowerUpDisplay
{
	[SerializeField]
	protected string powerUpText;

	[SerializeField]
	protected Text uiText;

	[SerializeField]
	protected UnityEngine.UI.Image uiImage;

	[SerializeField]
	protected RawImage renderedImage;

	[SerializeField]
	protected Camera renderCam;

	private RenderTexture m_texture;

	private static RenderTexture ms_commonRenderTexture;

	private static bool ms_commonTextureInUse;

	private void OnDisable()
	{
		if (m_texture != null && m_texture == ms_commonRenderTexture)
		{
			ms_commonTextureInUse = false;
			m_texture = null;
		}
	}

	private RenderTexture GetCommonRenderTexture()
	{
		InitRenderTexture();
		if (!ms_commonTextureInUse)
		{
			ms_commonTextureInUse = true;
			return ms_commonRenderTexture;
		}
		return null;
	}

	public static void InitRenderTexture()
	{
		if (ms_commonRenderTexture == null)
		{
			ms_commonRenderTexture = CreateRenderTexture();
		}
	}

	private static RenderTexture CreateRenderTexture()
	{
		RenderTexture renderTexture = new RenderTexture(512, 512, 0);
		renderTexture.anisoLevel = 0;
		renderTexture.filterMode = FilterMode.Bilinear;
		renderTexture.antiAliasing = 1;
		renderTexture.wrapMode = TextureWrapMode.Clamp;
		return renderTexture;
	}

	private void Start()
	{
		if (powerUpText.Length > 0 && uiText != null)
		{
			uiText.text = powerUpText.Translate();
		}
		if (renderCam != null && uiImage != null)
		{
			m_texture = GetCommonRenderTexture();
			if (m_texture == null)
			{
				m_texture = CreateRenderTexture();
			}
			renderCam.targetTexture = m_texture;
			renderedImage.texture = m_texture;
		}
		StartCoroutine(DisableCam());
	}

	private IEnumerator DisableCam()
	{
		yield return new WaitForSeconds(0.5f);
		renderCam.enabled = false;
	}

	public override void SetScale(float scale)
	{
		if (renderedImage != null)
		{
			renderedImage.rectTransform.localScale = new Vector3(scale, scale, scale);
		}
		else
		{
			UnityEngine.Debug.LogError("No rendered image pointer");
		}
	}

	public override void SetAlpha(float alpha)
	{
		if (renderedImage != null)
		{
			UnityEngine.Color color = renderedImage.color;
			color.a = alpha;
			renderedImage.color = color;
		}
	}
}
public class PowerUpDisplay_Sprite : PowerUpDisplay
{
	[SerializeField]
	protected SpriteRenderer uiSpriteRndr;

	public override void SetAlpha(float alpha)
	{
		if (uiSpriteRndr != null)
		{
			UnityEngine.Color color = uiSpriteRndr.color;
			color.a = alpha;
			uiSpriteRndr.color = color;
		}
	}

	public override void SetScale(float scale)
	{
		base.gameObject.transform.localScale = new Vector3(scale, scale, scale);
	}
}
public class CoolingEffect : PowerUpEffect
{
	public CoolingEffect(float time)
		: base(time)
	{
	}

	public override void Reset()
	{
		base.Reset();
		Singleton<PowerUpManager>.Instance.NoHeating = true;
	}

	public override void Deactivate()
	{
		base.Deactivate();
		Singleton<PowerUpManager>.Instance.NoHeating = false;
	}
}
public class DamageMultiplierEffect : PowerUpEffect
{
	public DamageMultiplierEffect(float time)
		: base(time)
	{
	}

	public override void Reset()
	{
		base.Reset();
		int progress = 0;
		Singleton<UpgradeManager>.Instance.GetUpgradeProgress(UpgradeType.Damage, ref progress);
		float damageMultiplier = 2f;
		switch (progress)
		{
		case 2:
			damageMultiplier = 3f;
			break;
		case 3:
		case 4:
			damageMultiplier = 4f;
			break;
		case 5:
			damageMultiplier = 5f;
			break;
		}
		Singleton<PowerUpManager>.Instance.DamageMultiplier = damageMultiplier;
	}

	public override void Deactivate()
	{
		Singleton<PowerUpManager>.Instance.DamageMultiplier = 1f;
		base.Deactivate();
	}
}
public class FireSpeedEffect : PowerUpEffect
{
	public FireSpeedEffect(float time)
		: base(time)
	{
	}

	public override void Reset()
	{
		base.Reset();
		Singleton<PowerUpManager>.Instance.FireSpeedBonus = true;
	}

	public override void Deactivate()
	{
		base.Deactivate();
		Singleton<PowerUpManager>.Instance.FireSpeedBonus = false;
	}
}
public class InvulnerabilityEffect : PowerUpEffect
{
	public InvulnerabilityEffect(float time)
		: base(time)
	{
	}

	public override void Reset()
	{
		base.Reset();
		PlayerStats component = Singleton<GameManager>.Instance.Player.GetComponent<PlayerStats>();
		component.Invulnerable = true;
	}

	public override void Deactivate()
	{
		base.Deactivate();
		PlayerStats component = Singleton<GameManager>.Instance.Player.GetComponent<PlayerStats>();
		component.Invulnerable = false;
	}
}
public class PointsEffect : PowerUpEffect
{
	public PointsEffect(float time)
		: base(time)
	{
	}

	public override void Reset()
	{
		base.Reset();
		int progress = 0;
		Singleton<UpgradeManager>.Instance.GetUpgradeProgress(UpgradeType.Points, ref progress);
		int pointsMultiplier = 2;
		switch (progress)
		{
		case 2:
			pointsMultiplier = 3;
			break;
		case 3:
		case 4:
			pointsMultiplier = 4;
			break;
		case 5:
			pointsMultiplier = 5;
			break;
		}
		Singleton<PowerUpManager>.Instance.PointsMultiplier = pointsMultiplier;
	}

	public override void Deactivate()
	{
		base.Deactivate();
		Singleton<PowerUpManager>.Instance.PointsMultiplier = 1;
	}
}
public abstract class PowerUpEffect
{
	protected float m_maxTime;

	protected float m_curTime;

	protected AudioEvent m_deactivateSound = AudioEvent.EvtGUI_IN_powerup_deactivate;

	public bool isActive;

	public PowerUpEffect(float time)
	{
		m_maxTime = time;
		m_curTime = 0f;
	}

	public virtual void Deactivate()
	{
		if (m_deactivateSound != 0)
		{
			Singleton<AudioManager>.Instance.Play(m_deactivateSound);
		}
		isActive = false;
	}

	public virtual void Reset()
	{
		m_curTime = m_maxTime;
		isActive = true;
	}

	public void UpdateEffect()
	{
		m_curTime -= Time.deltaTime;
		if (m_curTime <= 0f)
		{
			Deactivate();
		}
	}
}
public class SlomoEffect : PowerUpEffect
{
	private float timeScale = 0.2f;

	public SlomoEffect(float time)
		: base(time)
	{
	}

	public override void Reset()
	{
		base.Reset();
		Singleton<GameManager>.Instance.EnemyTimeScale = timeScale;
	}

	public override void Deactivate()
	{
		base.Deactivate();
		Singleton<GameManager>.Instance.EnemyTimeScale = 1f;
	}
}
[Serializable]
public struct PowerUpWeights
{
	public float m_Health;

	public float m_Invulnerability;

	public float m_Slowmo;

	public float m_ExtraTime;

	public float m_Cooling;

	public float m_Damage;

	public float m_Points;

	public float m_FireRate;

	public float m_Checkpoint;
}
public enum PowerUpType
{
	Invulnerability,
	Slowmo,
	Cooling,
	Damage,
	Points,
	FireRate,
	Health,
	ExtraTime,
	Checkpoint,
	Count
}
public enum PowerUpDisplayType
{
	None,
	Invulnerability,
	Slowmo,
	Cooling,
	HeavyLead,
	Multiplier,
	Hellfire,
	Toolkit,
	Clockwork,
	ExtraTime_5,
	ExtraTime_10,
	ExtraTime_15,
	ExtraTime_20,
	ExtraTime_25,
	ExtraTime_30
}
public class PowerUpManager : Singleton<PowerUpManager>
{
	public struct PowerUpPool
	{
		public int m_index;

		public float m_weight;
	}

	public delegate void PowerUpDelegate();

	private const int numberOfBonuses = 6;

	private PowerUpEffect[] m_activeBonuses = new PowerUpEffect[6];

	private PowerUpPool[] m_powerUpPool;

	public bool NoHeating;

	public bool FireSpeedBonus;

	public float DamageMultiplier = 1f;

	public int PointsMultiplier = 1;

	private float[] m_weights = new float[9];

	public PowerUpDelegate CollectPowerUpEvent;

	[SerializeField]
	private GameObject powerUpPrefab;

	[SerializeField]
	private List<PowerUpDisplay> powerUpDisplayPrefabs;

	private void Start()
	{
		Singleton<GameManager>.Instance.OnStartMission += Reset;
		UpgradeManager upgradeManager = Singleton<UpgradeManager>.Instance;
		m_activeBonuses[0] = new InvulnerabilityEffect(upgradeManager.GetPowerUp(PowerUpType.Invulnerability));
		m_activeBonuses[1] = new SlomoEffect(upgradeManager.GetPowerUp(PowerUpType.Slowmo));
		m_activeBonuses[2] = new CoolingEffect(upgradeManager.GetPowerUp(PowerUpType.Cooling));
		m_activeBonuses[3] = new DamageMultiplierEffect(upgradeManager.GetPowerUp(PowerUpType.Damage));
		m_activeBonuses[4] = new PointsEffect(upgradeManager.GetPowerUp(PowerUpType.Points));
		m_activeBonuses[5] = new FireSpeedEffect(upgradeManager.GetPowerUp(PowerUpType.FireRate));
	}

	public void SetWeights(PowerUpWeights weights)
	{
		m_weights[0] = weights.m_Invulnerability;
		m_weights[1] = weights.m_Slowmo;
		m_weights[2] = weights.m_Cooling;
		m_weights[3] = weights.m_Damage;
		m_weights[4] = weights.m_Points;
		m_weights[5] = weights.m_FireRate;
		m_weights[6] = weights.m_Health;
		m_weights[7] = weights.m_ExtraTime;
		m_weights[8] = weights.m_Checkpoint;
		float num = 0f;
		for (int i = 0; i < m_weights.Length; i++)
		{
			num += m_weights[i];
		}
		for (int j = 0; j < m_weights.Length; j++)
		{
			m_weights[j] /= num;
		}
	}

	private void Reset(bool restart)
	{
		for (int i = 0; i < 6; i++)
		{
			if (m_activeBonuses[i].isActive)
			{
				m_activeBonuses[i].Deactivate();
			}
		}
		ResetPool();
	}

	private void ResetPool()
	{
		int num = 0;
		for (int i = 0; i < m_weights.Length; i++)
		{
			if (m_weights[i] > 0f)
			{
				num++;
			}
		}
		m_powerUpPool = new PowerUpPool[num];
		int num2 = 0;
		float num3 = 0f;
		for (int j = 0; j < m_weights.Length; j++)
		{
			if (m_weights[j] > 0f)
			{
				PowerUpPool powerUpPool = default(PowerUpPool);
				powerUpPool.m_index = j;
				num3 = (powerUpPool.m_weight = num3 + m_weights[j]);
				m_powerUpPool[num2++] = powerUpPool;
			}
		}
		PowerUpDisplay_Localized.InitRenderTexture();
	}

	public void DestroyPowerUp(PowerUp powerUp)
	{
		UnityEngine.Object.Destroy(powerUp.gameObject);
	}

	public void CreatePowerUp(Vector3 position, Quaternion rotation)
	{
		if (m_powerUpPool.Length == 0)
		{
			return;
		}
		Quaternion rotation2 = rotation;
		rotation2.x = 0f;
		rotation2.z = 0f;
		GameObject gameObject = UnityEngine.Object.Instantiate(powerUpPrefab, position, rotation2);
		PowerUp component = gameObject.GetComponent<PowerUp>();
		float value = UnityEngine.Random.value;
		for (int i = 0; i < m_powerUpPool.Length; i++)
		{
			if (m_powerUpPool[i].m_weight >= value && (m_powerUpPool[i].m_index != 6 || !(Singleton<GameManager>.Instance.PlayerStatsData.GetHealthPercentage() >= 1f)))
			{
				component.Type = (PowerUpType)m_powerUpPool[i].m_index;
				break;
			}
		}
		component.Initialise();
	}

	public void TestSlowdown()
	{
		ActivateBonus(PowerUpType.Slowmo);
	}

	public void CollectPowerUp(PowerUp powerUp)
	{
		Singleton<AudioManager>.Instance.Play(AudioEvent.EvtGUI_IN_powerup_activate);
		float num = Singleton<UpgradeManager>.Instance.GetPowerUp(powerUp.Type);
		PowerUpDisplayType type = PowerUpDisplayType.None;
		switch (powerUp.Type)
		{
		case PowerUpType.Health:
			Singleton<GameManager>.Instance.PlayerStatsData.PowerUp(num);
			type = PowerUpDisplayType.Toolkit;
			break;
		case PowerUpType.Invulnerability:
			ActivateBonus(powerUp.Type);
			type = PowerUpDisplayType.Invulnerability;
			break;
		case PowerUpType.Slowmo:
			ActivateBonus(powerUp.Type);
			type = PowerUpDisplayType.Slowmo;
			break;
		case PowerUpType.ExtraTime:
			if (Singleton<MissionManager>.Instance.TimeLimit == TimeLimit.Checkpoint)
			{
				num = Singleton<MissionManager>.Instance.CheckpointTimeBonus;
			}
			Singleton<MissionManager>.Instance.AddTime(num);
			type = PowerUpDisplayType.Clockwork;
			break;
		case PowerUpType.Cooling:
			ActivateBonus(powerUp.Type);
			type = PowerUpDisplayType.Cooling;
			break;
		case PowerUpType.Damage:
			ActivateBonus(powerUp.Type);
			type = PowerUpDisplayType.HeavyLead;
			break;
		case PowerUpType.Points:
			ActivateBonus(powerUp.Type);
			type = PowerUpDisplayType.Multiplier;
			break;
		case PowerUpType.FireRate:
			ActivateBonus(powerUp.Type);
			type = PowerUpDisplayType.Hellfire;
			break;
		case PowerUpType.Checkpoint:
			num = Singleton<MissionManager>.Instance.CheckpointTimeBonus;
			type = ((num > 29f) ? PowerUpDisplayType.ExtraTime_30 : ((num > 24f) ? PowerUpDisplayType.ExtraTime_25 : ((num > 19f) ? PowerUpDisplayType.ExtraTime_20 : ((num > 14f) ? PowerUpDisplayType.ExtraTime_15 : ((!(num > 9f)) ? PowerUpDisplayType.ExtraTime_5 : PowerUpDisplayType.ExtraTime_10)))));
			Singleton<MissionManager>.Instance.AddTime(num);
			break;
		}
		PowerUpDisplay powerUpDisplayPrefabForType = GetPowerUpDisplayPrefabForType(type);
		if (powerUpDisplayPrefabForType != null)
		{
			Vector3 vector = new Vector3(0f, 5f, 0f);
			float num2 = 0.5f;
			float fadeInTime = 0.6f;
			float duration = 2f;
			float fadeOutTime = 0.6f;
			float num3 = Vector3.Distance(Singleton<CameraManager>.Instance.transform.position, powerUp.transform.position);
			Vector3 vector2 = powerUp.transform.position + vector * num3 / 100f;
			Vector3 vector3 = Singleton<CameraManager>.Instance.transform.position - vector2;
			float num4 = Mathf.Atan2(vector3.x, vector3.z) * 57.29578f + 180f;
			vector3 = Quaternion.Euler(new Vector3(0f, 0f - num4, 0f)) * vector3;
			float x = Mathf.Atan2(0f - vector3.y, vector3.z) * 57.29578f + 180f;
			PowerUpDisplay powerUpDisplay = UnityEngine.Object.Instantiate(powerUpDisplayPrefabForType);
			powerUpDisplay.transform.position = vector2;
			powerUpDisplay.transform.rotation = Quaternion.Euler(new Vector3(x, num4, 0f));
			float scale = num2 * num3 / 10f;
			powerUpDisplay.SetScale(scale);
			Singleton<AudioManager>.Instance.Play(AudioEvent.EvtGUI_IN_powerup_crate_smash);
			StartCoroutine(ShowPopup(powerUpDisplay, fadeInTime, duration, fadeOutTime));
		}
		else
		{
			UnityEngine.Debug.LogError("No powerup display");
		}
		DestroyPowerUp(powerUp);
		if (CollectPowerUpEvent != null)
		{
			CollectPowerUpEvent();
		}
	}

	private PowerUpDisplay GetPowerUpDisplayPrefabForType(PowerUpDisplayType type)
	{
		foreach (PowerUpDisplay powerUpDisplayPrefab in powerUpDisplayPrefabs)
		{
			if (powerUpDisplayPrefab.displayType == type)
			{
				return powerUpDisplayPrefab;
			}
		}
		return null;
	}

	private IEnumerator ShowPopup(PowerUpDisplay popup, float fadeInTime, float duration, float fadeOutTime)
	{
		float timeInState2 = 0f;
		float alpha = 0f;
		while (!Mathf.Approximately(alpha, 1f))
		{
			alpha = Mathf.Min(1f, timeInState2 / fadeInTime);
			popup.SetAlpha(alpha);
			timeInState2 += Time.deltaTime;
			yield return null;
		}
		yield return new WaitForSeconds(duration);
		timeInState2 = 0f;
		while (!Mathf.Approximately(alpha, 0f))
		{
			alpha = Mathf.Max(0f, 1f - timeInState2 / fadeInTime);
			popup.SetAlpha(alpha);
			timeInState2 += Time.deltaTime;
			yield return null;
		}
		UnityEngine.Object.Destroy(popup.gameObject);
	}

	public void ActivateBonus(PowerUpType type)
	{
		m_activeBonuses[(int)type].Reset();
	}

	private void Update()
	{
		for (int i = 0; i < 6; i++)
		{
			if (m_activeBonuses[i].isActive)
			{
				m_activeBonuses[i].UpdateEffect();
			}
		}
	}
}
public interface IStorable
{
	void Save();

	void Load();
}
public class Profile : Singleton<Profile>
{
	private ProfileSettings m_settings = new ProfileSettings();

	private ProfileLevelProgress m_progress = new ProfileLevelProgress();

	private ProfileUpgrades m_upgrades = new ProfileUpgrades();

	private ProfilePlayer m_player = new ProfilePlayer();

	private ProfileAchievements m_achievements = new ProfileAchievements();

	private ProfileStatistics m_statictics = new ProfileStatistics();

	private ProfileTutorial m_tutorial = new ProfileTutorial();

	public int MissionCount = 30;

	public int[] m_missionIndexsWithBonuses = new int[4] { 5, 11, 17, 23 };

	public ProfileSettings Settings => m_settings;

	public ProfileLevelProgress Progress => m_progress;

	public ProfileUpgrades Upgrades => m_upgrades;

	public ProfilePlayer Player => m_player;

	public ProfileAchievements Achievements => m_achievements;

	public ProfileStatistics Statistics => m_statictics;

	public ProfileTutorial Tutorial => m_tutorial;

	public void Load()
	{
		m_settings.Load();
		m_settings.RefreshVolumes();
		m_progress.Load();
		m_upgrades.Load();
		m_player.Load();
		m_statictics.Load();
		m_tutorial.Load();
	}

	public void Save()
	{
		m_settings.Save();
		m_progress.Save();
		m_upgrades.Save();
		m_player.Save();
		m_statictics.Save();
		PlayerPrefs.Save();
	}

	public void ResetProfile()
	{
		m_progress.Reset();
		m_upgrades.Reset();
		m_player.Reset();
		m_statictics.Reset();
		m_settings.RefreshVolumes();
	}

	private void OnApplicationPause()
	{
		Save();
	}
}
public class ProfileAchievements : IStorable
{
	private static string sm_ach = "_ach_";

	public void Load()
	{
		List<Achievement> achievements = Singleton<AchievementManager>.Instance.GetAchievements();
		for (int i = 0; i < achievements.Count; i++)
		{
			achievements[i].SetAchieved(PlayerPrefs.GetInt(sm_ach + i) == 1);
		}
	}

	public void Save()
	{
		List<Achievement> achievements = Singleton<AchievementManager>.Instance.GetAchievements();
		for (int i = 0; i < achievements.Count; i++)
		{
			PlayerPrefs.SetInt(sm_ach + i, achievements[i].IsAchieved() ? 1 : 0);
		}
	}

	public void Reset()
	{
		List<Achievement> achievements = Singleton<AchievementManager>.Instance.GetAchievements();
		for (int i = 0; i < achievements.Count; i++)
		{
			achievements[i].SetAchieved(a: false);
		}
	}
}
public class ProfileLevelProgress : IStorable
{
	private static string sm_currentLevel = "current_level";

	private static string sm_levelStars = "level_stars";

	private static string sm_levelScore = "level_score";

	private static string sm_bonusMissionsPlayed = "bonus_missions_played";

	private static string sm_shownEnding = "shown_ending";

	private static string sm_shownEndingAllStars = "shown_ending_all_stars";

	private static string sm_playedLevel = "played_level";

	private int[] m_lastPlayedLevel = new int[2];

	private int[] m_playedMissions;

	private int[,] m_progress;

	private int[,] m_highestScore;

	private int m_bonusMissionsPlayed;

	private bool m_shownEnding;

	private bool m_shownEndingAllStars;

	public int LastPlayedLevel => m_lastPlayedLevel[Singleton<Profile>.Instance.Settings.Nation];

	public int BonusMissionsCompleted => m_bonusMissionsPlayed;

	public bool ShownEnding
	{
		get
		{
			return m_shownEnding;
		}
		set
		{
			m_shownEnding = value;
		}
	}

	public bool ShownEndingAllStars
	{
		get
		{
			return m_shownEndingAllStars;
		}
		set
		{
			m_shownEndingAllStars = value;
			m_shownEnding = value;
		}
	}

	public void Load()
	{
		m_lastPlayedLevel[0] = PlayerPrefs.GetInt(sm_currentLevel + 0, 0);
		m_lastPlayedLevel[1] = PlayerPrefs.GetInt(sm_currentLevel + 1, 0);
		m_progress = new int[2, Singleton<Profile>.Instance.MissionCount];
		m_highestScore = new int[2, Singleton<Profile>.Instance.MissionCount];
		m_playedMissions = new int[Singleton<Profile>.Instance.MissionCount];
		for (int i = 0; i < Singleton<Profile>.Instance.MissionCount; i++)
		{
			m_progress[0, i] = PlayerPrefs.GetInt(sm_levelStars + 0 + "_" + i, -1);
			m_progress[1, i] = PlayerPrefs.GetInt(sm_levelStars + 1 + "_" + i, -1);
			m_highestScore[0, i] = PlayerPrefs.GetInt(sm_levelScore + 0 + "_" + i, 0);
			m_highestScore[1, i] = PlayerPrefs.GetInt(sm_levelScore + 1 + "_" + i, 0);
			m_playedMissions[i] = PlayerPrefs.GetInt(sm_playedLevel + i, 0);
		}
		m_bonusMissionsPlayed = PlayerPrefs.GetInt(sm_bonusMissionsPlayed, 0);
		m_shownEnding = PlayerPrefs.GetInt(sm_shownEnding, 0) != 0;
		m_shownEndingAllStars = PlayerPrefs.GetInt(sm_shownEndingAllStars, 0) != 0;
		Singleton<UpgradeManager>.Instance.UpdateOwnedGuns();
	}

	public void Save()
	{
		PlayerPrefs.SetInt(sm_currentLevel + 0, m_lastPlayedLevel[0]);
		PlayerPrefs.SetInt(sm_currentLevel + 1, m_lastPlayedLevel[1]);
		for (int i = 0; i < Singleton<Profile>.Instance.MissionCount; i++)
		{
			PlayerPrefs.SetInt(sm_levelStars + 0 + "_" + i, m_progress[0, i]);
			PlayerPrefs.SetInt(sm_levelStars + 1 + "_" + i, m_progress[1, i]);
			PlayerPrefs.SetInt(sm_levelScore + 0 + "_" + i, m_highestScore[0, i]);
			PlayerPrefs.SetInt(sm_levelScore + 1 + "_" + i, m_highestScore[1, i]);
			PlayerPrefs.SetInt(sm_playedLevel + i, m_playedMissions[i]);
		}
		PlayerPrefs.SetInt(sm_bonusMissionsPlayed, m_bonusMissionsPlayed);
		if (m_shownEnding)
		{
			PlayerPrefs.SetInt(sm_shownEnding, 1);
		}
		else
		{
			PlayerPrefs.SetInt(sm_shownEnding, 0);
		}
		if (m_shownEndingAllStars)
		{
			PlayerPrefs.SetInt(sm_shownEndingAllStars, 1);
		}
		else
		{
			PlayerPrefs.SetInt(sm_shownEndingAllStars, 0);
		}
	}

	public void Reset()
	{
		m_lastPlayedLevel[0] = (m_lastPlayedLevel[1] = 0);
		PlayerPrefs.SetInt(sm_currentLevel + 0, 0);
		for (int i = 0; i < Singleton<Profile>.Instance.MissionCount; i++)
		{
			m_progress[0, i] = (m_progress[1, i] = -1);
			m_highestScore[0, i] = (m_highestScore[1, i] = 0);
		}
	}

	public void OnLevelStart()
	{
		m_playedMissions[Singleton<MissionManager>.Instance.Mission] = 1;
	}

	public void UpdateProgress()
	{
		int nation = Singleton<Profile>.Instance.Settings.Nation;
		int stars = Singleton<PlayerScore>.Instance.Stars;
		int mission = Singleton<MissionManager>.Instance.Mission;
		int num = m_progress[nation, mission];
		Singleton<MissionManager>.Instance.CompletedMissionForFirstTime = num == -1;
		if (stars > num)
		{
			Singleton<Profile>.Instance.Player.AddStars(stars - m_progress[nation, mission]);
			m_progress[nation, mission] = stars;
		}
		int score = Singleton<PlayerScore>.Instance.Score;
		if (score > m_highestScore[nation, mission])
		{
			m_highestScore[nation, mission] = score;
		}
		m_lastPlayedLevel[nation] = mission;
		Singleton<UpgradeManager>.Instance.UpdateOwnedGuns();
	}

	public bool HasPlayedLevelBefore(int level)
	{
		return m_playedMissions[level] > 0;
	}

	public int GetStars(int level)
	{
		return Mathf.Max(0, m_progress[Singleton<Profile>.Instance.Settings.Nation, level]);
	}

	public int GetHighestScore(int level)
	{
		return m_highestScore[Singleton<Profile>.Instance.Settings.Nation, level];
	}

	public int GetStarsAmount()
	{
		int nation = Singleton<Profile>.Instance.Settings.Nation;
		int num = 0;
		for (int i = 0; i < Singleton<Profile>.Instance.MissionCount; i++)
		{
			num += Mathf.Max(0, m_progress[nation, i]);
		}
		return num;
	}

	public bool HasMaxStars()
	{
		return GetStarsAmount() >= Singleton<MissionManager>.Instance.AvailableMissions.Length * 3;
	}

	public void GrantMaxStars()
	{
		for (int i = 0; i < Singleton<Profile>.Instance.MissionCount; i++)
		{
			m_progress[0, i] = 3;
			m_progress[1, i] = 3;
		}
	}

	public void CompletedBonusMission()
	{
		m_bonusMissionsPlayed++;
	}

	public bool CanSeeEnding()
	{
		return (!m_shownEnding && Singleton<MissionManager>.Instance.HaveCompletedAllMissionsOnce()) || (!m_shownEndingAllStars && HasMaxStars());
	}
}
public class ProfilePlayer : IStorable
{
	private static string sm_money = "money";

	private static string sm_stars = "stars_";

	private int m_money;

	private int[] m_stars = new int[2];

	public void Load()
	{
		m_money = PlayerPrefs.GetInt(sm_money, 0);
		m_stars[0] = PlayerPrefs.GetInt(sm_stars + 0, 0);
		m_stars[1] = PlayerPrefs.GetInt(sm_stars + 1, 0);
	}

	public void Save()
	{
		PlayerPrefs.SetInt(sm_money, m_money);
		PlayerPrefs.SetInt(sm_stars + 0, m_stars[0]);
		PlayerPrefs.SetInt(sm_stars + 1, m_stars[1]);
	}

	public void Reset()
	{
		m_money = 0;
		PlayerPrefs.SetInt(sm_money, 0);
	}

	public void AddStars(int stars)
	{
		int nation = Singleton<Profile>.Instance.Settings.Nation;
		m_stars[nation] += stars;
	}

	public int GetMoney()
	{
		return m_money;
	}

	public int AddMoney(int money)
	{
		return m_money += money;
	}

	public int SpendMoney(int amount)
	{
		if (m_money >= amount)
		{
			m_money -= amount;
		}
		return m_money;
	}
}
public enum VolumeSettings
{
	SFX,
	Radio,
	Default,
	Count
}
public enum GameLanguage
{
	English,
	German,
	Spanish,
	French,
	Korean,
	Chinese
}
public class ProfileSettings : IStorable
{
	public enum ListOptions
	{
		Language,
		Nation,
		Weapon
	}

	public enum Languages
	{
		en,
		ru,
		max
	}

	public enum Nations
	{
		Britain,
		Germany,
		max
	}

	public enum SliderOptions
	{
		VolumeSFX,
		VolumeRadio
	}

	public enum ToggleOptions
	{
		ShowHealthBars,
		GazeToAim
	}

	private static string[] sm_sound = new string[3] { "sound_sfx", "sound_radio", "sound_default" };

	private static string sm_language = "language";

	private static string sm_nation = "nation";

	private static string sm_enableHealthbars = "enable_healthbars";

	private static string sm_gazeToAim = "b6_gazeToAim";

	private float[] m_volume = new float[3];

	private string m_language = "en";

	private int m_nation;

	private bool m_enableHealthbars = true;

	private bool m_gazeToAim = true;

	public GameLanguage m_languageEnum { get; private set; }

	public string Language => m_language;

	public int Nation => m_nation;

	public bool EnableHealthbars => m_enableHealthbars;

	public bool GazeToAim => m_gazeToAim;

	public float GetVolume(VolumeSettings setting)
	{
		return m_volume[(int)setting];
	}

	public void Load()
	{
		for (int i = 0; i < 3; i++)
		{
			m_volume[i] = PlayerPrefs.GetFloat(sm_sound[i], 1f);
		}
		m_language = PlayerPrefs.GetString(sm_language, "en");
		switch (Application.systemLanguage)
		{
		case SystemLanguage.English:
			m_language = "en";
			break;
		case SystemLanguage.French:
			m_language = "fr";
			break;
		case SystemLanguage.Korean:
			m_language = "kr";
			break;
		case SystemLanguage.German:
			m_language = "de";
			break;
		case SystemLanguage.Spanish:
			m_language = "es";
			break;
		case SystemLanguage.Chinese:
			m_language = "cn";
			break;
		case SystemLanguage.ChineseSimplified:
			m_language = "cn";
			break;
		case SystemLanguage.ChineseTraditional:
			m_language = "cn";
			break;
		default:
			m_language = "en";
			break;
		}
		switch (m_language)
		{
		case "en":
			m_languageEnum = GameLanguage.English;
			break;
		case "fr":
			m_languageEnum = GameLanguage.French;
			break;
		case "de":
			m_languageEnum = GameLanguage.German;
			break;
		case "es":
			m_languageEnum = GameLanguage.Spanish;
			break;
		case "kr":
			m_languageEnum = GameLanguage.Korean;
			break;
		case "cn":
			m_languageEnum = GameLanguage.Chinese;
			break;
		}
		Singleton<TextHelper>.Instance.Load();
		m_nation = PlayerPrefs.GetInt(sm_nation, 0);
		m_enableHealthbars = PlayerPrefs.GetInt(sm_enableHealthbars, 1) > 0;
		m_gazeToAim = PlayerPrefs.GetInt(sm_gazeToAim, 1) > 0;
	}

	public void Save()
	{
		for (int i = 0; i < 3; i++)
		{
			PlayerPrefs.SetFloat(sm_sound[i], m_volume[i]);
		}
		PlayerPrefs.SetString(sm_language, m_language);
		PlayerPrefs.SetInt(sm_nation, m_nation);
		PlayerPrefs.SetInt(sm_enableHealthbars, m_enableHealthbars ? 1 : 0);
		PlayerPrefs.SetInt(sm_gazeToAim, m_gazeToAim ? 1 : 0);
	}

	public int GetOptionCount(ListOptions option)
	{
		return option switch
		{
			ListOptions.Language => 2, 
			ListOptions.Nation => 2, 
			ListOptions.Weapon => Singleton<Profile>.Instance.Upgrades.GetOwnedGunCount(Nation), 
			_ => 0, 
		};
	}

	public string GetOptionTextID(ListOptions option)
	{
		switch (option)
		{
		case ListOptions.Language:
			return "loc_name";
		case ListOptions.Nation:
			switch (Nation)
			{
			case 0:
				return "name_britain";
			case 1:
				return "name_germany";
			}
			break;
		case ListOptions.Weapon:
			switch (Singleton<Profile>.Instance.Upgrades.CurrentGun)
			{
			case 0:
				return "name_weapon0";
			case 1:
				return "name_weapon1";
			case 2:
				return "name_weapon2";
			}
			break;
		}
		return string.Empty;
	}

	public int GetValue(ListOptions option)
	{
		switch (option)
		{
		case ListOptions.Language:
		{
			for (int i = 0; i < 2; i++)
			{
				Languages languages = (Languages)i;
				if (languages.ToString() == Language)
				{
					return i;
				}
			}
			break;
		}
		case ListOptions.Nation:
			return Nation;
		case ListOptions.Weapon:
			return Singleton<Profile>.Instance.Upgrades.CurrentGun;
		}
		return -1;
	}

	public void SetValue(ListOptions option, int value)
	{
		switch (option)
		{
		case ListOptions.Language:
		{
			Languages languages = (Languages)value;
			m_language = languages.ToString();
			Singleton<TextHelper>.Instance.Load();
			Singleton<MissionManager>.Instance.ReloadAvailableMissionsTexts();
			break;
		}
		case ListOptions.Nation:
			m_nation = Mathf.Clamp(value, 0, 2);
			break;
		case ListOptions.Weapon:
			Singleton<Profile>.Instance.Upgrades.CurrentGun = value;
			break;
		}
	}

	public float GetValue(SliderOptions option)
	{
		return option switch
		{
			SliderOptions.VolumeSFX => m_volume[0], 
			SliderOptions.VolumeRadio => m_volume[1], 
			_ => 0f, 
		};
	}

	public void SetValue(SliderOptions option, float value)
	{
		switch (option)
		{
		case SliderOptions.VolumeSFX:
			SetVolume(value, VolumeSettings.SFX);
			break;
		case SliderOptions.VolumeRadio:
			SetVolume(value, VolumeSettings.Radio);
			break;
		}
	}

	public void RefreshVolumes()
	{
		for (int i = 0; i < 3; i++)
		{
			SetVolume(m_volume[i], (VolumeSettings)i);
		}
	}

	public void SetVolume(float volume, VolumeSettings option)
	{
		m_volume[(int)option] = volume;
		Singleton<AudioManager>.Instance.SetVolume(option, volume, isDucking: false);
	}

	public bool GetValue(ToggleOptions option)
	{
		return option switch
		{
			ToggleOptions.ShowHealthBars => m_enableHealthbars, 
			ToggleOptions.GazeToAim => m_gazeToAim, 
			_ => false, 
		};
	}

	public void SetValue(ToggleOptions option, bool value)
	{
		switch (option)
		{
		case ToggleOptions.ShowHealthBars:
			m_enableHealthbars = value;
			break;
		case ToggleOptions.GazeToAim:
			m_gazeToAim = value;
			break;
		}
	}
}
public class ProfileStatistics : IStorable
{
	private static string sm_stat = "stat_";

	private Statistics m_statistics = new Statistics();

	public void Load()
	{
		int num = 17;
		for (int i = 0; i < num; i++)
		{
			Statistics statistics = m_statistics;
			int key = i;
			string text = sm_stat;
			Statistics.Key key2 = (Statistics.Key)i;
			statistics[(Statistics.Key)key] = PlayerPrefs.GetInt(text + key2, 0);
		}
	}

	public void Save()
	{
		int num = 17;
		for (int i = 0; i < num; i++)
		{
			string text = sm_stat;
			Statistics.Key key = (Statistics.Key)i;
			PlayerPrefs.SetInt(text + key, m_statistics[(Statistics.Key)i]);
		}
	}

	public void Reset()
	{
		int num = 17;
		for (int i = 0; i < num; i++)
		{
			m_statistics[i] = 0;
		}
	}

	public Statistics GetStatistics()
	{
		return m_statistics;
	}
}
public class ProfileTutorial : IStorable
{
	private string sm_tutorial = "tutorial_";

	private int[] m_tutorialList;

	public void Load()
	{
		int messageCount = Singleton<TutorialManager>.Instance.MessageCount;
		m_tutorialList = new int[messageCount];
		for (int i = 0; i < messageCount; i++)
		{
			m_tutorialList[i] = PlayerPrefs.GetInt(sm_tutorial + i, 0);
		}
		Singleton<TutorialManager>.Instance.Load();
	}

	public void Save()
	{
		for (int i = 0; i < m_tutorialList.Length; i++)
		{
			PlayerPrefs.SetInt(sm_tutorial + i, m_tutorialList[i]);
		}
		PlayerPrefs.Save();
	}

	public void Reset()
	{
		for (int i = 0; i < m_tutorialList.Length; i++)
		{
			m_tutorialList[i] = 0;
		}
		Singleton<TutorialManager>.Instance.Reset();
	}

	public void CompleteTutorialItem(int n)
	{
		if (m_tutorialList == null)
		{
			Load();
		}
		m_tutorialList[n] = 1;
		Save();
	}

	public bool IsTutorialItemCompleted(int n)
	{
		if (m_tutorialList == null)
		{
			Load();
		}
		return m_tutorialList[n] == 1;
	}
}
public class ProfileUpgrades : IStorable
{
	public enum GunUpgrades
	{
		Damage,
		RateOfFire,
		Cooldown
	}

	private static string sm_gun_upgrades = "gun_upgrades_";

	private static string sm_armour_upgrade = "armour_upgrade_";

	private static string sm_gun = "gun_";

	private static string sm_gunAmount = "gun_amaunt";

	private static string sm_powerUp = "power_up_";

	private int[,,] m_gunUpgrades = new int[2, 3, 3];

	private int[] m_armourUpgrade = new int[2];

	private int[,] m_gunsPurchased = new int[2, 3];

	private int[] m_powerUpUpgrades;

	private int powerUpCount;

	private int[] m_currentGun = new int[2];

	public int CurrentGun
	{
		get
		{
			return m_currentGun[Singleton<Profile>.Instance.Settings.Nation];
		}
		set
		{
			int num = value;
			for (int i = 0; i < 3; i++)
			{
				if (m_gunsPurchased[Singleton<Profile>.Instance.Settings.Nation, i] > 0)
				{
					if (num == 0)
					{
						m_currentGun[Singleton<Profile>.Instance.Settings.Nation] = i;
						break;
					}
					num--;
				}
			}
		}
	}

	public void Load()
	{
		m_gunsPurchased[0, 0] = (m_gunsPurchased[1, 0] = 1);
		for (int i = 0; i < 2; i++)
		{
			for (int j = 0; j < 3; j++)
			{
				for (int k = 0; k < 3; k++)
				{
					m_gunUpgrades[i, j, k] = PlayerPrefs.GetInt(sm_gun_upgrades + i + "_" + j + "_" + k, 0);
				}
			}
			m_armourUpgrade[i] = PlayerPrefs.GetInt(sm_armour_upgrade + i, 0);
			m_gunsPurchased[i, 1] = PlayerPrefs.GetInt(sm_gunAmount + i + "_" + 1, 0);
			m_gunsPurchased[i, 2] = PlayerPrefs.GetInt(sm_gunAmount + i + "_" + 2, 0);
		}
		powerUpCount = 9;
		m_powerUpUpgrades = new int[powerUpCount];
		for (int l = 0; l < powerUpCount; l++)
		{
			m_powerUpUpgrades[l] = PlayerPrefs.GetInt(sm_powerUp + l, 0);
		}
		for (int m = 0; m < 2; m++)
		{
			m_currentGun[m] = PlayerPrefs.GetInt(sm_gun + m, 0);
		}
	}

	public void Save()
	{
		for (int i = 0; i < 2; i++)
		{
			for (int j = 0; j < 3; j++)
			{
				for (int k = 0; k < 3; k++)
				{
					PlayerPrefs.SetInt(sm_gun_upgrades + i + "_" + j + "_" + k, m_gunUpgrades[i, j, k]);
				}
			}
			PlayerPrefs.SetInt(sm_armour_upgrade + i, m_armourUpgrade[i]);
			PlayerPrefs.SetInt(sm_gunAmount + i + "_" + 1, m_gunsPurchased[i, 1]);
			PlayerPrefs.SetInt(sm_gunAmount + i + "_" + 2, m_gunsPurchased[i, 2]);
		}
		for (int l = 0; l < powerUpCount; l++)
		{
			PlayerPrefs.SetInt(sm_powerUp + l, m_powerUpUpgrades[l]);
		}
		for (int m = 0; m < 2; m++)
		{
			PlayerPrefs.SetInt(sm_gun + m, m_currentGun[m]);
		}
	}

	public void Reset()
	{
		for (int i = 0; i < 2; i++)
		{
			for (int j = 0; j < 3; j++)
			{
				for (int k = 0; k < 3; k++)
				{
					m_gunUpgrades[i, j, k] = 0;
					PlayerPrefs.SetInt(sm_gun_upgrades + i + "_" + j + "_" + k, 0);
				}
			}
			m_armourUpgrade[i] = 0;
			PlayerPrefs.SetInt(sm_armour_upgrade + i, 0);
			m_gunsPurchased[i, 1] = 0;
			m_gunsPurchased[i, 2] = 0;
			PlayerPrefs.SetInt(sm_gunAmount + i + "_" + 1, 0);
			PlayerPrefs.SetInt(sm_gunAmount + i + "_" + 2, 0);
		}
		for (int l = 0; l < powerUpCount; l++)
		{
			m_powerUpUpgrades[l] = 0;
			PlayerPrefs.SetInt(sm_powerUp + l, 0);
		}
		for (int m = 0; m < 2; m++)
		{
			m_currentGun[m] = 0;
			PlayerPrefs.SetInt(sm_gun + m, 0);
		}
	}

	public void BuyGun(int gun)
	{
		int nation = Singleton<Profile>.Instance.Settings.Nation;
		if (m_gunsPurchased[nation, gun] == 0)
		{
			switch (gun)
			{
			case 1:
				Singleton<TutorialManager>.Instance.Gun2Acquired = true;
				Singleton<TutorialManager>.Instance.NeedSelectGun2Tutorial = true;
				break;
			case 2:
				Singleton<TutorialManager>.Instance.Gun3Acquired = true;
				Singleton<TutorialManager>.Instance.NeedSelectGun3Tutorial = true;
				break;
			}
			m_gunsPurchased[nation, gun] = 1;
		}
	}

	public void BuyGunUpgrade(int gun, int upgrade)
	{
		int nation = Singleton<Profile>.Instance.Settings.Nation;
		m_gunUpgrades[nation, gun, upgrade] = ++m_gunUpgrades[nation, gun, upgrade];
	}

	public void BuyGunUpgrade(int gun, GunUpgrades upgrade)
	{
		BuyGunUpgrade(gun, (int)upgrade);
	}

	public int GetGunUpgrade(int gun, int upgrade)
	{
		int nation = Singleton<Profile>.Instance.Settings.Nation;
		return m_gunUpgrades[nation, gun, upgrade];
	}

	public int GetGunUpgrade(int gun, GunUpgrades upgrade)
	{
		return GetGunUpgrade(gun, (int)upgrade);
	}

	public void GetGunUpgrades(ref int damage, ref int fireRate, ref int coolingSpeed)
	{
		int nation = Singleton<Profile>.Instance.Settings.Nation;
		damage = m_gunUpgrades[nation, m_currentGun[nation], 0];
		fireRate = m_gunUpgrades[nation, m_currentGun[nation], 1];
		coolingSpeed = m_gunUpgrades[nation, m_currentGun[nation], 2];
	}

	public void BuyArmourUpgrade()
	{
		int nation = Singleton<Profile>.Instance.Settings.Nation;
		m_armourUpgrade[nation] = ++m_armourUpgrade[nation];
	}

	public int GetArmourUpgrade()
	{
		int nation = Singleton<Profile>.Instance.Settings.Nation;
		return m_armourUpgrade[nation];
	}

	public int GetOwnedGunCount(int nation)
	{
		int num = 0;
		for (int i = 0; i < 3; i++)
		{
			if (m_gunsPurchased[nation, i] > 0)
			{
				num++;
			}
		}
		return num;
	}

	public bool OwnsGun(int gun)
	{
		return m_gunsPurchased[Singleton<Profile>.Instance.Settings.Nation, gun] > 0;
	}

	public void BuyPowerUpUpgrade(int index)
	{
		m_powerUpUpgrades[index]++;
	}

	public int GetPowerUpUpgrade(int index)
	{
		return m_powerUpUpgrades[index];
	}
}
public class CurrentSession
{
	private Statistics m_statistics;

	public void OnStartMission()
	{
		m_statistics = new Statistics();
	}

	public void OnEndMission()
	{
		Statistics statistics = Singleton<Profile>.Instance.Statistics.GetStatistics();
		statistics.Merge(m_statistics);
	}

	public void OnEnemyKill(bool[] info)
	{
		m_statistics[Statistics.Key.StEnemiesKilled]++;
		m_statistics[Statistics.Key.StSniperShots] += (info[0] ? 1 : 0);
		m_statistics[Statistics.Key.StHotGunKills] += (info[1] ? 1 : 0);
		m_statistics[Statistics.Key.StSnapShots] += (info[2] ? 1 : 0);
		m_statistics[Statistics.Key.StQuickKills] += (info[3] ? 1 : 0);
		m_statistics[Statistics.Key.StMultiKills] += (info[4] ? 1 : 0);
		m_statistics[Statistics.Key.StNoReplyKills] += (info[5] ? 1 : 0);
		m_statistics[Statistics.Key.StOverKills] += (info[6] ? 1 : 0);
		m_statistics[Statistics.Key.StSlowmoKills] += (info[7] ? 1 : 0);
		m_statistics[Statistics.Key.StBorrowedTimeKills] += (info[8] ? 1 : 0);
		m_statistics[Statistics.Key.StInvulnerableKills] += (info[9] ? 1 : 0);
		m_statistics[Statistics.Key.StRevengeKills] += (info[10] ? 1 : 0);
		m_statistics[Statistics.Key.StSaviourKills] += (info[11] ? 1 : 0);
	}

	public Statistics GetStatistics()
	{
		return m_statistics;
	}
}
public class Statistics
{
	public enum Key
	{
		StEnemiesKilled,
		StMinutesSurvived,
		StExtraTimeCollected,
		StSniperShots,
		StHotGunKills,
		StSnapShots,
		StQuickKills,
		StMultiKills,
		StNoReplyKills,
		StOverKills,
		StSlowmoKills,
		StBorrowedTimeKills,
		StInvulnerableKills,
		StRevengeKills,
		StSaviourKills,
		StMaxMinutesSurvived,
		StMaxKillChain,
		StCount
	}

	private int[] m_values = new int[17];

	public int this[Key key]
	{
		get
		{
			return m_values[(int)key];
		}
		set
		{
			m_values[(int)key] = value;
		}
	}

	public int this[int key]
	{
		get
		{
			return m_values[key];
		}
		set
		{
			m_values[key] = value;
		}
	}

	public Statistics()
	{
		int num = 17;
		for (int i = 0; i < num; i++)
		{
			m_values[i] = 0;
		}
	}

	public int[] GetValues()
	{
		return m_values;
	}

	public void Merge(Statistics stat)
	{
		int num = 17;
		for (int i = 0; i < num; i++)
		{
			if (i < 15)
			{
				m_values[i] += stat[i];
			}
			else
			{
				m_values[i] = stat[i];
			}
		}
	}
}
[RequireComponent(typeof(Rigidbody))]
public class Bullet : Projectile
{
	public bool SpecialBullet;

	private float m_velocityScale = 1f;

	private bool m_trailEnabled;

	private float trailWidth;

	[NonSerialized]
	[HideInInspector]
	public Rigidbody rigidbody;

	[NonSerialized]
	[HideInInspector]
	public new Transform transform;

	[NonSerialized]
	[HideInInspector]
	public new GameObject gameObject;

	[HideInInspector]
	public Vector3 perpendicular;

	[HideInInspector]
	public Vector3 forward;

	[HideInInspector]
	public Vector3 forwardLength;

	public bool isActive;

	private void Awake()
	{
		transform = GetComponent<Transform>();
		rigidbody = GetComponent<Rigidbody>();
		rigidbody.GetComponent<Collider>().material = new PhysicMaterial();
		gameObject = base.gameObject;
	}

	protected override void Initialise()
	{
		base.Initialise();
		Vector3 velocity = transform.forward * m_speed;
		rigidbody.velocity = velocity;
		m_velocityScale = 1f;
		trailWidth = ((!SpecialBullet) ? Singleton<MassLineRenderer>.Instance.trailWidth : Singleton<MassLineRenderer>.Instance.specialTrailWidth);
		SetTrailRendererEnabled(enable: false);
		UpdatePositionValues();
	}

	public override void Tick(float deltaTime)
	{
		if (!m_playerOwner)
		{
			float enemyTimeScale = Singleton<GameManager>.Instance.EnemyTimeScale;
			deltaTime *= enemyTimeScale;
			if (m_velocityScale != enemyTimeScale)
			{
				rigidbody.velocity *= enemyTimeScale / m_velocityScale;
				m_velocityScale = enemyTimeScale;
			}
		}
		base.Tick(deltaTime);
	}

	protected override void OnCollisionEnter(Collision collision)
	{
		if (!gameObject.activeSelf || !isActive)
		{
			return;
		}
		base.OnCollisionEnter(collision);
		if (playerCollision != null)
		{
			if (playerCollision.Invulnerable)
			{
				Singleton<AudioManager>.Instance.Play(AudioEvent.EvtBulletImpact_Invin, playerCollision.gameObject);
			}
			else
			{
				Singleton<AudioManager>.Instance.Play(AudioEvent.EvtBulletImpact, playerCollision.gameObject);
			}
		}
		if (m_processCollision)
		{
			ContactPoint contactPoint = collision.contacts[0];
			ParticleSystem particleSystem = ((!m_playerCollision) ? Singleton<EffectsPool>.Instance.GetFromPool(EffectType.Sparks, contactPoint.point, Quaternion.FromToRotation(Vector3.forward, contactPoint.normal)) : Singleton<EffectsPool>.Instance.GetFromPool(EffectType.PlayerSparks, contactPoint.point, Quaternion.FromToRotation(Vector3.forward, contactPoint.normal)));
			particleSystem.transform.parent = collision.collider.transform;
		}
	}

	public void SetTrailRendererEnabled(bool enable)
	{
		if (enable && !m_trailEnabled)
		{
			Singleton<MassLineRenderer>.Instance.bullets.Add(this);
		}
		else if (!enable && m_trailEnabled)
		{
			Singleton<MassLineRenderer>.Instance.bullets.Remove(this);
		}
		m_trailEnabled = enable;
	}

	private void UpdatePositionValues()
	{
		forward = transform.forward;
		forwardLength = forward * Singleton<MassLineRenderer>.Instance.trailLength;
		perpendicular = transform.right * (trailWidth * -0.5f);
	}

	protected override void ReturnToPool(bool overtime)
	{
		SetTrailRendererEnabled(enable: false);
		BulletPool.Instance.ReturnToPool(this);
	}
}
public class Crosshair : Singleton<Crosshair>
{
	[Serializable]
	public class CrosshairRadarSettings
	{
		public float PointerWidth = 0.05f;

		public float PointerHeight = 0.06f;

		public float PointerDotRadius = 0.02f;

		public float PointerDistanceFromCentre = 0.11f;

		public float PointerMaxScale = 1f;

		public float PointerMinScale = 0.5f;

		public UnityEngine.Color PointerColorAttacking = UnityEngine.Color.red;

		public UnityEngine.Color PointerColorNotAttacking = UnityEngine.Color.yellow;

		public UnityEngine.Color PointerColorCargo = UnityEngine.Color.green;

		public float PointerEnemyDistanceMaxSize = 150f;

		public float PointerEnemyDistanceMinSize = 500f;

		public float PointerEnemyDistanceMaxSizeSqr;

		public float PointerEnemyDistanceMinSizeSqr;

		public CrosshairRadarSettings()
		{
			PointerEnemyDistanceMaxSizeSqr = PointerEnemyDistanceMaxSize * PointerEnemyDistanceMaxSize;
			PointerEnemyDistanceMinSizeSqr = PointerEnemyDistanceMinSize * PointerEnemyDistanceMinSize;
		}
	}

	private Transform m_guns;

	private float m_radius;

	private float m_angleToCenter;

	private Vector3 m_camPos;

	private Vector3 m_gunPos;

	private Vector3 m_gunDir;

	private Vector3 m_pointInFront;

	private Vector3 m_camVector;

	[SerializeField]
	private CrosshairRadarSettings m_RadarSettings = new CrosshairRadarSettings();

	private Transform cameraTransform;

	[SerializeField]
	private RadarOverheatBar overheatBar;

	[SerializeField]
	private PlayerHealthBar healthBar;

	[NonSerialized]
	[HideInInspector]
	public new Transform transform;

	public CrosshairRadarSettings RadarSettings => m_RadarSettings;

	public Transform GetCentre()
	{
		return transform.GetChild(0);
	}

	protected override void Awake()
	{
		base.Awake();
		transform = GetComponent<Transform>();
		cameraTransform = Singleton<CameraManager>.Instance.GetCamera();
	}

	public void Initialise()
	{
		m_guns = transform.parent.GetComponentInParent<Turret>().CurrentGun.transform;
		Vector3 position = m_guns.position;
		Vector3 position2 = transform.GetChild(0).position;
		float num = position2.y - position.y;
		position.y = 0f;
		position2.y = 0f;
		float num2 = Vector3.Distance(position, position2);
		m_radius = Mathf.Sqrt(num * num + num2 * num2);
		m_angleToCenter = Mathf.Asin(num / m_radius);
		overheatBar.Initialise();
		healthBar.Initialise();
	}

	public void Tick()
	{
		m_camPos = cameraTransform.position;
		m_gunPos = m_guns.position;
		m_gunDir = -m_guns.forward;
		m_pointInFront = m_gunPos + m_gunDir * 100f;
		m_camVector = m_pointInFront - m_camPos;
		Vector3 a = Vector3.Project(m_gunPos - m_pointInFront, -m_camVector);
		a += m_pointInFront;
		float num = Vector3.Distance(a, m_gunPos);
		float num2 = Mathf.Asin(Mathf.Clamp(num / m_radius, -1f, 1f));
		float value = Vector3.Dot(m_gunDir, m_camVector);
		value = Mathf.Acos(Mathf.Clamp(value, -1f, 1f));
		float value2 = Vector3.Dot(m_gunDir, -transform.parent.forward);
		value2 = Mathf.Acos(Mathf.Clamp(value2, -1f, 1f));
		float num3 = 0f - Mathf.Sign(m_guns.rotation.eulerAngles.x - 180f);
		float num4 = num2 - value - m_angleToCenter + value2 * num3;
		num4 *= 57.29578f;
		num4 -= 0.7f;
		transform.localRotation = Quaternion.identity;
		transform.RotateAround(transform.position, transform.right, num4);
		TickBars();
	}

	public void TickBars()
	{
		overheatBar.Tick();
		healthBar.Tick();
	}
}
public class Gun : MonoBehaviour
{
	[SerializeField]
	private Bullet m_bullet;

	[SerializeField]
	private Reticule m_reticule;

	[SerializeField]
	private bool m_playerOwner;

	[SerializeField]
	private bool m_rotatable;

	[SerializeField]
	private int BulletsPerTracer = 1;

	private int BulletsTillTracer;

	private float m_fireRate = 1.5f;

	private float m_damage;

	private float FireDelayRemaining;

	[SerializeField]
	private ParticleSystem MuzzleFlashPrefab;

	private ParticleSystem[] SubMuzzleFlash;

	private ParticleSystem[] MuzzleFlash;

	[SerializeField]
	private AnimationCurve m_overheatCurve;

	[SerializeField]
	private AnimationCurve m_overheatCurveFliped;

	[SerializeField]
	private AnimationCurve m_cooldownCurve;

	[SerializeField]
	private float m_overheatPenalty;

	private float m_overheat;

	private float m_shootingTime;

	private float m_coolingTime;

	private bool m_isOverheated;

	private bool m_forceCooling;

	private float m_maxCoolingTime;

	private float m_maxHeatingTime;

	private float m_OverheatLF;

	public bool SingleFireAudio;

	private bool m_isShooting;

	public AudioEvent GunFireEvent = AudioEvent.EvtGunFire;

	public AudioEvent GunFireEndEvent = AudioEvent.EvtGunFireEnd;

	public AudioEvent GunFireOverheatEvent;

	private Bullet m_newBullet;

	[SerializeField]
	private bool HasBulletDrop = true;

	private Transform[] m_barrels;

	private int m_barrelShot;

	private List<Renderer> heatRenderers = new List<Renderer>();

	private EnemyStatus m_planeStatus;

	[NonSerialized]
	[HideInInspector]
	public new Transform transform;

	private GameObject playerGameObject;

	public float Overheat => m_overheat;

	public bool IsShooting => m_isShooting;

	public Reticule Reticule => m_reticule;

	private void Awake()
	{
		transform = GetComponent<Transform>();
		Transform child;
		if (m_playerOwner)
		{
			child = transform.GetChild(0);
			playerGameObject = Singleton<GameManager>.Instance.Player;
		}
		else
		{
			child = transform;
		}
		int num = child.childCount;
		if (m_rotatable)
		{
			num = 2;
		}
		m_barrels = new Transform[num];
		MuzzleFlash = new ParticleSystem[num];
		SubMuzzleFlash = new ParticleSystem[num];
		for (int i = 0; i < num; i++)
		{
			if (m_playerOwner)
			{
				m_barrels[i] = child.GetChild(i);
			}
			else
			{
				m_barrels[i] = child.GetChild(i);
			}
			if ((bool)MuzzleFlashPrefab)
			{
				MuzzleFlash[i] = UnityEngine.Object.Instantiate(MuzzleFlashPrefab, m_barrels[i].position, m_barrels[i].rotation);
				MuzzleFlash[i].loop = false;
				MuzzleFlash[i].transform.parent = m_barrels[i];
				MuzzleFlash[i].Stop();
				MuzzleFlash[i].GetComponent<Renderer>().enabled = false;
				if (!m_playerOwner)
				{
					SubMuzzleFlash[i] = MuzzleFlash[i].transform.GetChild(0).gameObject.GetComponent<ParticleSystem>();
					SubMuzzleFlash[i].loop = false;
					SubMuzzleFlash[i].GetComponent<Renderer>().enabled = false;
					SubMuzzleFlash[i].Stop();
				}
			}
		}
		Renderer[] componentsInChildren = base.gameObject.GetComponentsInChildren<Renderer>();
		for (int j = 0; j < componentsInChildren.Length; j++)
		{
			if (componentsInChildren[j].material.HasProperty("_Heat"))
			{
				heatRenderers.Add(componentsInChildren[j]);
			}
		}
		if (!m_playerOwner)
		{
			m_planeStatus = GetComponentInParent<EnemyStatus>();
		}
	}

	public void SetParams(float fireRate, float damage, float coolingTime = 0f, float heatingTime = 0f)
	{
		m_fireRate = fireRate;
		m_damage = damage;
		if (m_playerOwner)
		{
			m_damage *= m_barrels.Length;
		}
		m_maxCoolingTime = coolingTime;
		m_maxHeatingTime = heatingTime;
	}

	public void Tick()
	{
		float num = Time.deltaTime;
		for (int i = 0; i < MuzzleFlash.Length; i++)
		{
			if ((bool)MuzzleFlash[i] && !MuzzleFlash[i].isPlaying && MuzzleFlash[i].GetComponent<Renderer>().enabled)
			{
				MuzzleFlash[i].GetComponent<Renderer>().enabled = false;
			}
			if ((bool)SubMuzzleFlash[i] && !SubMuzzleFlash[i].isPlaying && MuzzleFlash[i].GetComponent<Renderer>().enabled)
			{
				SubMuzzleFlash[i].GetComponent<Renderer>().enabled = false;
			}
		}
		if (!m_playerOwner)
		{
			num *= Singleton<GameManager>.Instance.EnemyTimeScale;
		}
		else
		{
			if (!m_forceCooling && Singleton<PowerUpManager>.Instance.NoHeating)
			{
				m_coolingTime = m_maxCoolingTime * m_cooldownCurve.Evaluate(m_overheat);
				m_forceCooling = true;
			}
			else if (m_forceCooling && !Singleton<PowerUpManager>.Instance.NoHeating)
			{
				m_shootingTime = m_maxHeatingTime * m_overheatCurveFliped.Evaluate(m_overheat);
				m_forceCooling = false;
			}
			if (m_isShooting && !m_forceCooling)
			{
				m_overheat = m_overheatCurve.Evaluate(m_shootingTime / m_maxHeatingTime);
				if (m_overheat >= 1f)
				{
					EndShooting();
					m_isOverheated = true;
				}
				m_shootingTime += Time.deltaTime;
			}
			else
			{
				m_overheat = m_cooldownCurve.Evaluate(m_coolingTime / m_maxCoolingTime);
				if (m_isOverheated && m_overheat < 1f - m_overheatPenalty)
				{
					m_isOverheated = false;
				}
				m_coolingTime += Time.deltaTime;
			}
			if (m_overheat != m_OverheatLF)
			{
				for (int j = 0; j < heatRenderers.Count; j++)
				{
					heatRenderers[j].material.SetFloat("_Heat", 1f - m_overheat);
				}
				m_OverheatLF = m_overheat;
			}
		}
		if (FireDelayRemaining > 0f)
		{
			FireDelayRemaining = Mathf.Max(0f, FireDelayRemaining - num);
		}
	}

	public void UpdateGunRotation()
	{
		if (m_rotatable)
		{
			transform.rotation = Quaternion.LookRotation(-transform.position);
		}
	}

	public void StartShooting()
	{
		if (m_playerOwner && m_isOverheated)
		{
			return;
		}
		if (!SingleFireAudio)
		{
			float num = 1f;
			if (m_playerOwner)
			{
				num = Singleton<PowerUpManager>.Instance.DamageMultiplier;
			}
			if (num > 1f)
			{
				Singleton<AudioManager>.Instance.Play(AudioEvent.EvtGunFire_Hvy, base.gameObject);
			}
			else
			{
				Singleton<AudioManager>.Instance.Play(GunFireEvent, base.gameObject);
			}
		}
		m_isShooting = true;
		if (m_playerOwner)
		{
			m_shootingTime = m_maxHeatingTime * m_overheatCurveFliped.Evaluate(m_overheat);
		}
	}

	public void EndShooting()
	{
		if (!m_isShooting)
		{
			return;
		}
		if (!SingleFireAudio)
		{
			Singleton<AudioManager>.Instance.Stop(GunFireEvent, base.gameObject);
		}
		if (GunFireEndEvent != 0)
		{
			Singleton<AudioManager>.Instance.Play(GunFireEndEvent, base.gameObject);
		}
		if (m_playerOwner)
		{
			float damageMultiplier = Singleton<PowerUpManager>.Instance.DamageMultiplier;
			if (damageMultiplier > 1f)
			{
				Singleton<AudioManager>.Instance.Play(AudioEvent.EvtGunFire_Hvy, base.gameObject);
			}
			m_coolingTime = m_maxCoolingTime * m_cooldownCurve.Evaluate(m_overheat);
		}
		m_isShooting = false;
	}

	public void Shoot()
	{
		if (Singleton<GameManager>.Instance.State != GameManager.GameState.InGame || m_bullet == null || FireDelayRemaining > 0f)
		{
			return;
		}
		FireDelayRemaining = 1f / m_fireRate;
		if (m_playerOwner)
		{
			if (Singleton<PowerUpManager>.Instance.FireSpeedBonus)
			{
				FireDelayRemaining /= 2f;
			}
			if (m_isOverheated)
			{
				if (GunFireOverheatEvent != 0)
				{
					Singleton<AudioManager>.Instance.Play(GunFireOverheatEvent, base.gameObject, canBePaused: false);
				}
				return;
			}
		}
		if (m_playerOwner)
		{
			FireBarrel(m_barrelShot);
			m_barrelShot++;
			if (m_barrelShot >= m_barrels.Length)
			{
				m_barrelShot = 0;
			}
		}
		else
		{
			for (int i = 0; i < m_barrels.Length; i++)
			{
				FireBarrel(i);
			}
		}
		if (BulletsTillTracer <= 0)
		{
			BulletsTillTracer = BulletsPerTracer;
		}
		BulletsTillTracer--;
		if (SingleFireAudio)
		{
			float num = 1f;
			if (m_playerOwner)
			{
				num = Singleton<PowerUpManager>.Instance.DamageMultiplier;
			}
			if (num > 1f)
			{
				Singleton<AudioManager>.Instance.Play(AudioEvent.EvtGunFire_Hvy, base.gameObject, canBePaused: false);
			}
			else
			{
				Singleton<AudioManager>.Instance.Play(GunFireEvent, base.gameObject, canBePaused: false);
			}
		}
	}

	private void FireBarrel(int i)
	{
		m_newBullet = BulletPool.Instance.GetFromPool(m_bullet, m_barrels[i].position, m_barrels[i].rotation, m_playerOwner);
		if (m_newBullet == null)
		{
			return;
		}
		if (BulletsTillTracer <= 0)
		{
			m_newBullet.SetTrailRendererEnabled(enable: true);
		}
		m_newBullet.SpecialBullet = false;
		if (m_playerOwner)
		{
			m_newBullet.Owner = playerGameObject;
			if (Singleton<PowerUpManager>.Instance.DamageMultiplier > 1f)
			{
				m_newBullet.SpecialBullet = true;
			}
		}
		else
		{
			m_newBullet.Owner = m_planeStatus.gameObject;
		}
		m_newBullet.m_playerOwner = m_playerOwner;
		if (m_playerOwner)
		{
			MuzzleFlash[i].GetComponent<Renderer>().enabled = true;
			MuzzleFlash[i].Play();
		}
		else
		{
			if ((bool)MuzzleFlash[i])
			{
				MuzzleFlash[i].GetComponent<Renderer>().enabled = true;
				MuzzleFlash[i].Play();
				MuzzleFlash[i].playbackSpeed = Singleton<GameManager>.Instance.EnemyTimeScale;
			}
			if ((bool)SubMuzzleFlash[i])
			{
				SubMuzzleFlash[i].GetComponent<Renderer>().enabled = true;
				SubMuzzleFlash[i].Play();
				SubMuzzleFlash[i].playbackSpeed = Singleton<GameManager>.Instance.EnemyTimeScale;
			}
		}
		m_newBullet.SetDamage(m_damage);
		m_newBullet.rigidbody.useGravity = HasBulletDrop;
	}

	public void OnStartMission()
	{
		m_isOverheated = false;
		m_overheat = 0f;
		m_isShooting = false;
		m_forceCooling = false;
		m_shootingTime = 0f;
		m_coolingTime = m_maxCoolingTime;
	}
}
public class Missile : Projectile
{
	private Transform m_target;

	[SerializeField]
	private bool m_straight = true;

	[SerializeField]
	private float m_rotaionSpeed = 0.5f;

	[SerializeField]
	private float m_modelRotationSpeed = 1f;

	[SerializeField]
	private float m_modelRotationOffset = 1f;

	[SerializeField]
	private AudioEvent m_missileShootExplosionAudio;

	[SerializeField]
	private AudioEvent m_missileImpactExplosionAudio;

	[SerializeField]
	private AudioEvent m_missileFlyAudio;

	private Transform m_model;

	[HideInInspector]
	public MissileGun Gun;

	private bool m_active = true;

	[NonSerialized]
	[HideInInspector]
	public new Transform transform;

	private void Awake()
	{
		transform = GetComponent<Transform>();
	}

	protected override void Initialise()
	{
		base.Initialise();
		m_active = true;
		m_target = Singleton<GameManager>.Instance.Player.transform;
		m_model = transform.GetChild(0);
		if (!m_straight)
		{
			m_model.localPosition = new Vector3(0f, m_modelRotationOffset, 0f);
		}
		Singleton<AudioManager>.Instance.Play(m_missileFlyAudio, base.gameObject);
	}

	private void Update()
	{
		Tick(Time.deltaTime * Singleton<GameManager>.Instance.EnemyTimeScale);
	}

	private void OnDestroy()
	{
		Singleton<AudioManager>.Instance.Stop(m_missileFlyAudio, base.gameObject);
	}

	public override void Tick(float deltaTime)
	{
		base.Tick(deltaTime);
		if (Singleton<GameManager>.Instance.State == GameManager.GameState.Inactive)
		{
			OnHit();
			return;
		}
		transform.rotation = Quaternion.Lerp(transform.rotation, Quaternion.LookRotation(m_target.position - transform.position), deltaTime * m_rotaionSpeed);
		transform.position += transform.forward * m_speed * deltaTime;
		if (!m_straight)
		{
			m_model.RotateAround(transform.position, transform.forward, m_modelRotationSpeed * deltaTime);
		}
		float num;
		for (num = transform.rotation.eulerAngles.x; num < -180f; num += 360f)
		{
		}
		while (num > 180f)
		{
			num -= 360f;
		}
		num /= 180f;
		num += 0.5f;
	}

	public void OnHit()
	{
		if (m_active)
		{
			Singleton<EffectsPool>.Instance.GetFromPool(EffectType.Explosion, transform.position, transform.rotation);
			Vector3 position = transform.position;
			if (Singleton<GameManager>.Instance.State == GameManager.GameState.Inactive)
			{
				position.z = Singleton<AudioManager>.Instance.soundEffectDistanceOnMissionEnd;
			}
			Singleton<AudioManager>.Instance.PlayInLocation(m_missileShootExplosionAudio, position);
			UnityEngine.Object.Destroy(base.gameObject);
			m_active = false;
		}
	}

	protected override void OnCollisionEnter(Collision collision)
	{
		if (m_active)
		{
			base.OnCollisionEnter(collision);
			if (playerCollision != null)
			{
				Singleton<AudioManager>.Instance.PlayInLocation(m_missileImpactExplosionAudio, transform.position);
				m_active = false;
				Singleton<EffectsPool>.Instance.GetFromPool(EffectType.Explosion, transform.position, transform.rotation);
			}
		}
	}

	protected override void ReturnToPool(bool overtime)
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class MissileGun : MonoBehaviour
{
	[SerializeField]
	private Missile m_missile;

	[SerializeField]
	private AudioEvent m_missileLaunchAudioEvent;

	[SerializeField]
	private AudioEvent m_missileLaunchChatterAudioEvent = AudioEvent.EvtPlayerVoxChatter_Lurker_Launch;

	[SerializeField]
	private float m_timeBetweenMissiles = 0.5f;

	private float m_damage;

	private float m_shootingTime;

	private int m_currentGun = -1;

	private Missile m_newMissile;

	private Transform[] m_barrels;

	private EnemyStatus status;

	private bool firedFirstMissile;

	private void Start()
	{
		status = GetComponentInParent<EnemyStatus>();
		m_barrels = new Transform[base.transform.childCount];
		for (int i = 0; i < base.transform.childCount; i++)
		{
			m_barrels[i] = base.transform.GetChild(i);
		}
	}

	public void SetDamage(float damage)
	{
		m_damage = damage;
	}

	public void Shoot()
	{
		m_currentGun = 0;
		m_shootingTime = 0f;
		firedFirstMissile = false;
	}

	private void Update()
	{
		float num = Time.deltaTime * Singleton<GameManager>.Instance.EnemyTimeScale;
		if (m_currentGun < 0)
		{
			return;
		}
		if (!status.IsAlive)
		{
			Singleton<AudioManager>.Instance.PlayInLocation(m_missileLaunchAudioEvent, base.transform.position);
			Singleton<AudioManager>.Instance.Play(m_missileLaunchChatterAudioEvent);
			m_currentGun = -1;
		}
		else
		{
			if (Singleton<GameManager>.Instance.State != GameManager.GameState.InGame)
			{
				return;
			}
			m_shootingTime += num;
			if (m_shootingTime > m_timeBetweenMissiles)
			{
				m_shootingTime = 0f;
				m_newMissile = UnityEngine.Object.Instantiate(m_missile);
				m_newMissile.Initialise(m_missile, m_barrels[m_currentGun].position, m_barrels[m_currentGun].rotation);
				m_newMissile.Owner = GetComponentInParent<EnemyStatus>().gameObject;
				m_newMissile.SetDamage(m_damage);
				m_newMissile.Gun = this;
				if (!firedFirstMissile)
				{
					Singleton<AudioManager>.Instance.PlayInLocation(m_missileLaunchAudioEvent, base.transform.position);
					Singleton<AudioManager>.Instance.Play(m_missileLaunchChatterAudioEvent);
					firedFirstMissile = true;
				}
				if (++m_currentGun >= m_barrels.Length)
				{
					m_currentGun = -1;
				}
			}
		}
	}
}
public abstract class Projectile : MonoBehaviour
{
	[SerializeField]
	protected float m_speed;

	protected float m_damage;

	[SerializeField]
	internal float m_lifeTime;

	protected float m_time;

	protected GameObject m_Owner;

	protected PlayerStats playerCollision;

	protected bool m_processCollision;

	public bool m_playerOwner;

	protected bool m_playerCollision;

	public GameObject Owner
	{
		get
		{
			return m_Owner;
		}
		set
		{
			m_Owner = value;
		}
	}

	public void Initialise(Projectile p, Vector3 pos, Quaternion rot)
	{
		m_speed = p.m_speed;
		m_damage = p.m_damage;
		m_lifeTime = p.m_lifeTime;
		base.transform.position = pos;
		base.transform.rotation = rot;
		m_time = 0f;
		m_Owner = null;
		playerCollision = null;
		Initialise();
	}

	public void SetDamage(float damage)
	{
		m_damage = damage;
	}

	protected virtual void Initialise()
	{
	}

	public virtual void Tick(float deltaTime)
	{
		if (Singleton<GameManager>.Instance.State != GameManager.GameState.InGame)
		{
			return;
		}
		m_time += deltaTime;
		if (m_time > m_lifeTime)
		{
			if (m_playerOwner)
			{
				Singleton<PlayerScore>.Instance.AddBullet(wasHit: false);
			}
			ReturnToPool(overtime: true);
		}
	}

	protected virtual void OnCollisionEnter(Collision collision)
	{
		playerCollision = null;
		m_processCollision = false;
		if (Singleton<GameManager>.Instance.State != GameManager.GameState.InGame || collision.collider.gameObject.GetType() == typeof(Bullet))
		{
			return;
		}
		FriendlyPlane friendlyPlane = null;
		Missile missile = null;
		EnemyStatus enemyStatus = null;
		PlayerStats playerStats = null;
		bool flag = collision.collider.CompareTag("Player");
		bool wasHit = false;
		if (flag)
		{
			playerStats = Singleton<GameManager>.Instance.PlayerStatsData;
			if (m_Owner == null || m_playerOwner)
			{
				return;
			}
			float num = playerStats.Hurt(m_damage);
			if (m_Owner.CompareTag("Enemy"))
			{
				EnemyStatus component = m_Owner.GetComponent<EnemyStatus>();
				if (component != null)
				{
					component.DamageDone += num;
				}
			}
			playerCollision = playerStats;
		}
		else if (collision.collider.CompareTag("Enemy"))
		{
			enemyStatus = collision.collider.GetComponent<EnemyStatus>();
			if (enemyStatus == null)
			{
				enemyStatus = collision.collider.transform.parent.GetComponent<EnemyStatus>();
			}
			if (m_Owner != null && Singleton<GameManager>.Instance.Player != m_Owner)
			{
				return;
			}
			float damageMultiplier = Singleton<PowerUpManager>.Instance.DamageMultiplier;
			enemyStatus.Hurt(m_damage * damageMultiplier, hitByPlayer: true);
			wasHit = true;
		}
		else if (collision.collider.CompareTag("Friend"))
		{
			friendlyPlane = collision.collider.GetComponent<FriendlyPlane>();
			if (m_Owner.CompareTag("Enemy"))
			{
				float num2 = friendlyPlane.Hurt(m_damage);
				EnemyStatus component2 = m_Owner.GetComponent<EnemyStatus>();
				component2.FriendlyDamageDone += num2;
			}
		}
		else
		{
			missile = collision.collider.GetComponent<Missile>();
			if ((bool)missile)
			{
				missile.OnHit();
				wasHit = true;
			}
		}
		if (flag || (bool)friendlyPlane || (bool)enemyStatus || (bool)missile)
		{
			if (m_playerOwner)
			{
				Singleton<PlayerScore>.Instance.AddBullet(wasHit);
			}
			ReturnToPool(overtime: false);
			m_processCollision = true;
		}
		m_playerCollision = flag;
	}

	protected abstract void ReturnToPool(bool overtime);
}
public class Reticule : MonoBehaviour
{
}
public class Turret : MonoBehaviour
{
	[SerializeField]
	public int m_index;

	[SerializeField]
	public float m_maxTurretRotation;

	[SerializeField]
	private float m_minGunRotation;

	[SerializeField]
	private float m_maxGunRotation;

	[SerializeField]
	private float m_autoRotationSpeed;

	[SerializeField]
	private float m_deactivateRotationSpeed = 15f;

	[SerializeField]
	public Transform textPlane;

	[SerializeField]
	private MeshRenderer m_guiScreen;

	[SerializeField]
	private Gun[] m_possibleGuns;

	private Gun m_currentGuns;

	private Transform m_camera;

	private Quaternion m_turretTargetRotation;

	private Quaternion m_gunsTargetRotation;

	private Vector3 cameraEulerAngles = default(Vector3);

	private bool m_gunsEnabled = true;

	[NonSerialized]
	[HideInInspector]
	private Transform turretTransform;

	private Crosshair crosshair;

	public MeshRenderer GUIScreenRenderer => m_guiScreen;

	public Gun CurrentGun => m_currentGuns;

	public Transform GetCrosshairXform()
	{
		return crosshair.transform;
	}

	private void Awake()
	{
		m_turretTargetRotation = Quaternion.identity;
		m_gunsTargetRotation = Quaternion.identity;
	}

	private void Start()
	{
		turretTransform = base.transform.GetChild(0);
		m_camera = Singleton<CameraManager>.Instance.GetCamera();
	}

	public void SetupTurret(int gunIndex)
	{
		m_currentGuns = m_possibleGuns[gunIndex];
		m_currentGuns.gameObject.SetActive(value: true);
		crosshair = GetComponentInChildren<Crosshair>();
		crosshair.Initialise();
		Initialise();
	}

	private void Initialise()
	{
		float damage = 0f;
		float fireRate = 0f;
		float coolingTime = 0f;
		float heatingTime = 0f;
		Singleton<UpgradeManager>.Instance.GetGunStats(ref damage, ref fireRate, ref coolingTime, ref heatingTime);
		m_currentGuns.SetParams(fireRate, damage, coolingTime, heatingTime);
	}

	public void ActivateGuns(bool activate)
	{
		m_gunsEnabled = activate;
	}

	private void MakeShot()
	{
		m_currentGuns.Shoot();
	}

	private void StartShooting()
	{
		m_currentGuns.StartShooting();
	}

	private void EndShooting()
	{
		m_currentGuns.EndShooting();
	}

	private void Update()
	{
		if (Singleton<GameManager>.Instance.State != GameManager.GameState.InGame && Singleton<GameManager>.Instance.State != GameManager.GameState.Tutorial)
		{
			return;
		}
		m_currentGuns.Tick();
		crosshair.Tick();
		cameraEulerAngles = ((!Singleton<Profile>.Instance.Settings.GazeToAim && InputUtils.IsTrackedRemoteActive()) ? Singleton<MenuManager>.Instance.GetCrosshair().transform.eulerAngles : m_camera.eulerAngles);
		float num = Math.Abs(cameraEulerAngles.y) - 180f;
		float num2 = Vector3.Dot(m_camera.up, Vector3.up);
		float autoRotationSpeed = m_autoRotationSpeed;
		num = ((!(num > 0f)) ? (num + 180f) : (num - 180f));
		if (num2 > 0.15f && Math.Abs(num) + m_maxTurretRotation > 180f)
		{
			m_turretTargetRotation = Quaternion.Euler(0f, cameraEulerAngles.y + 180f, 0f);
		}
		turretTransform.localRotation = Quaternion.Lerp(turretTransform.localRotation, m_turretTargetRotation, Time.unscaledDeltaTime * autoRotationSpeed);
		if (num2 > 0.15f && Mathf.Abs(num) > m_maxTurretRotation)
		{
			float num3 = Mathf.Abs(cameraEulerAngles.x) - 180f;
			if (Mathf.Abs(num3) > 90f && ((num3 <= 0f && num3 < -180f + m_minGunRotation) || (num3 > 0f && num3 > 180f - m_maxGunRotation)))
			{
				m_gunsTargetRotation = Quaternion.Euler(0f - cameraEulerAngles.x, 0f, 0f);
			}
		}
		m_currentGuns.transform.localRotation = Quaternion.Lerp(m_currentGuns.transform.localRotation, m_gunsTargetRotation, Time.unscaledDeltaTime * m_autoRotationSpeed);
		if (Singleton<GameManager>.Instance.State == GameManager.GameState.Tutorial)
		{
			return;
		}
		if (m_gunsEnabled && InputUtils.IsFiring())
		{
			if (!m_currentGuns.IsShooting)
			{
				StartShooting();
			}
			MakeShot();
		}
		else if (m_currentGuns.IsShooting)
		{
			EndShooting();
		}
	}

	public void RecenterYawFromCamera()
	{
		turretTransform.localRotation = Quaternion.identity;
	}

	public void DeactivateGuns(bool forceLower)
	{
		if (forceLower)
		{
			m_gunsTargetRotation = Quaternion.Euler(new Vector3(0f - m_minGunRotation, 0f, 0f));
			m_currentGuns.transform.localRotation = m_gunsTargetRotation;
			crosshair.transform.localRotation = m_gunsTargetRotation;
		}
		else
		{
			crosshair.TickBars();
			StartCoroutine(DeactivateGunsCoroutine());
		}
	}

	public void ShowGunReticule(bool visible)
	{
		m_currentGuns.Reticule.gameObject.SetActive(visible);
	}

	private IEnumerator DeactivateGunsCoroutine()
	{
		while (Singleton<GameManager>.Instance.State == GameManager.GameState.Tutorial)
		{
			yield return null;
		}
		m_gunsTargetRotation = Quaternion.Euler(new Vector3(0f - m_minGunRotation, 0f, 0f));
		while (!m_currentGuns.transform.localRotation.Equals(m_gunsTargetRotation))
		{
			m_currentGuns.transform.localRotation = Quaternion.RotateTowards(m_currentGuns.transform.localRotation, m_gunsTargetRotation, Time.unscaledDeltaTime * m_deactivateRotationSpeed);
			crosshair.transform.localRotation = Quaternion.RotateTowards(m_currentGuns.transform.localRotation, m_gunsTargetRotation, Time.unscaledDeltaTime * m_deactivateRotationSpeed);
			yield return null;
		}
	}
}
public class TutorialManager : Singleton<TutorialManager>
{
	[SerializeField]
	private TutorialMessageFrontend m_chooseMission = new TutorialMessageFrontend();

	[SerializeField]
	private TutorialMessageControl m_controlInfo = new TutorialMessageControl();

	[SerializeField]
	private TutorialMessageFrontend m_missionDescription = new TutorialMessageFrontend();

	[SerializeField]
	private TutorialMessageRadar m_radar = new TutorialMessageRadar();

	[SerializeField]
	private TutorialMessageKillEnemy m_shooting = new TutorialMessageKillEnemy();

	[SerializeField]
	private TutorialMessageOverheat m_overheat = new TutorialMessageOverheat();

	[SerializeField]
	private TutorialMessageHealth m_health = new TutorialMessageHealth();

	[SerializeField]
	private TutorialMessageKillCargo m_cargo = new TutorialMessageKillCargo();

	[SerializeField]
	private TutorialMessageShootPowerUp m_crate = new TutorialMessageShootPowerUp();

	[SerializeField]
	private TutorialMessageCollectPowerUp m_powerUp = new TutorialMessageCollectPowerUp();

	[SerializeField]
	private TutorialMessageProgressScreen m_progressScreen = new TutorialMessageProgressScreen();

	[SerializeField]
	private TutorialMessageScoreScreen m_scoreScreen = new TutorialMessageScoreScreen();

	[SerializeField]
	private TutorialMessageUpgrades m_upgrades = new TutorialMessageUpgrades();

	[SerializeField]
	private TutorialMessageGun2Acquired m_gun2Acquired = new TutorialMessageGun2Acquired();

	[SerializeField]
	private TutorialMessageGun3Acquired m_gun3Acquired = new TutorialMessageGun3Acquired();

	[SerializeField]
	private TutorialMessageSelectGun2 m_selectGun2 = new TutorialMessageSelectGun2();

	[SerializeField]
	private TutorialMessageSelectGun3 m_selectGun3 = new TutorialMessageSelectGun3();

	[SerializeField]
	private float m_screenWidth;

	[SerializeField]
	private Vector4 m_textPadding;

	[SerializeField]
	private float m_distanceFromCamera;

	[SerializeField]
	private GUIStyle m_style;

	[SerializeField]
	private GUIStyle m_buttonStyle;

	[SerializeField]
	private float m_iconSize;

	[SerializeField]
	private float m_buttonShowDelay = 2f;

	[SerializeField]
	private float m_buttonShowFadeInSpeed = 1f;

	[SerializeField]
	private NGUITutorialPopup m_popupPrefab;

	[SerializeField]
	private NGUITutorialPopup m_popupWithIconPrefab;

	private NGUITutorialPopup m_popup;

	private NGUITutorialPopup m_popupWithIcon;

	private List<TutorialMessage> m_tutorialList;

	private List<TutorialMessage> m_frontEndTutorialMessages;

	private List<TutorialMessage> m_inGameTutorialMessages;

	private TutorialMessage m_currentTutorial;

	private string m_text = string.Empty;

	private float m_buttonShowDelayRemaining;

	private bool m_needToHide;

	[NonSerialized]
	public bool NeedSelectGun2Tutorial;

	[NonSerialized]
	public bool NeedSelectGun3Tutorial;

	[NonSerialized]
	public bool Gun2Acquired;

	[NonSerialized]
	public bool Gun3Acquired;

	private int previousTutorialCompleted = -1;

	private bool showingNonTutorialMessage;

	private bool messageOpenedThisFrame;

	public bool ShowingTutorial => m_currentTutorial != null;

	public int MessageCount => m_tutorialList.Count;

	public int PreviousTutorialCompleted => previousTutorialCompleted;

	private TutorialManager()
	{
		m_tutorialList = new List<TutorialMessage>
		{
			m_chooseMission, m_missionDescription, m_radar, m_shooting, m_overheat, m_health, m_cargo, m_crate, m_powerUp, m_progressScreen,
			m_scoreScreen, m_upgrades, m_gun2Acquired, m_selectGun2, m_gun3Acquired, m_selectGun3, m_controlInfo
		};
	}

	protected override void Awake()
	{
		base.Awake();
		InitPopups();
	}

	public void Load()
	{
		m_inGameTutorialMessages = new List<TutorialMessage>(m_tutorialList.Count);
		m_frontEndTutorialMessages = new List<TutorialMessage>(m_tutorialList.Count);
		ProfileTutorial tutorial = Singleton<Profile>.Instance.Tutorial;
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < m_tutorialList.Count; i++)
		{
			if (!tutorial.IsTutorialItemCompleted(i))
			{
				if (m_tutorialList[i] is TutorialMessageFrontend)
				{
					m_frontEndTutorialMessages.Add(m_tutorialList[i]);
					m_frontEndTutorialMessages[num++].Init(i);
				}
				else
				{
					m_inGameTutorialMessages.Add(m_tutorialList[i]);
					m_inGameTutorialMessages[num2++].Init(i);
				}
			}
		}
	}

	public void Reset()
	{
		Load();
		m_currentTutorial = null;
	}

	private void InitPopups()
	{
		if (!m_popup)
		{
			m_popup = UnityEngine.Object.Instantiate(m_popupPrefab);
			m_popup.gameObject.SetActive(value: false);
			UnityEngine.Object.DontDestroyOnLoad(m_popup);
		}
		if (!m_popupWithIcon)
		{
			m_popupWithIcon = UnityEngine.Object.Instantiate(m_popupWithIconPrefab);
			m_popupWithIcon.gameObject.SetActive(value: false);
			UnityEngine.Object.DontDestroyOnLoad(m_popupWithIcon);
		}
	}

	public void Activate(TutorialMessage message)
	{
		InitPopups();
		m_currentTutorial = message;
		m_text = string.Empty;
		if (InputUtils.IsTrackedRemoteActive())
		{
			m_text = m_currentTutorial.TutTextTouchController.Translate();
		}
		if (m_text == string.Empty)
		{
			m_text = m_currentTutorial.TutText.Translate();
		}
		Singleton<GameManager>.Instance.ToggleTutorial(pause: true);
		NGUITutorialPopup nGUITutorialPopup = ((message.Icon.Length <= 0) ? m_popup : m_popupWithIcon);
		Transform transform = null;
		Vector3 vector = new Vector3(0f, 0f, 5f);
		Quaternion quaternion = Quaternion.Euler(new Vector3(0f, 180f, 0f));
		Turret turret = Singleton<GameManager>.Instance.Turret;
		if ((bool)turret)
		{
			transform = turret.transform;
			if ((bool)turret.textPlane)
			{
				transform = turret.textPlane.parent;
				quaternion = turret.textPlane.localRotation;
				vector = turret.textPlane.localPosition + new Vector3(0f, 0f, 0.2f);
			}
		}
		if ((bool)turret)
		{
			nGUITutorialPopup.transform.position = transform.transform.rotation * new Vector3(0f, 0f, -5f) + transform.transform.position;
			Quaternion quaternion2 = Quaternion.AngleAxis(180f, new Vector3(0f, 1f, 0f));
			nGUITutorialPopup.transform.rotation = transform.transform.rotation * quaternion2;
		}
		else if ((bool)Singleton<NGUIProjectorMenuManager>.Instance)
		{
			nGUITutorialPopup.transform.parent = Singleton<NGUIProjectorMenuManager>.Instance.transform;
			nGUITutorialPopup.transform.localPosition = Vector3.zero;
			nGUITutorialPopup.transform.localRotation = Quaternion.identity;
		}
		else
		{
			nGUITutorialPopup.transform.parent = Singleton<CameraManager>.Instance.transform.parent;
			nGUITutorialPopup.transform.localPosition = new Vector3(0f, 0f, m_distanceFromCamera);
			nGUITutorialPopup.transform.localRotation = Quaternion.identity;
		}
		nGUITutorialPopup.gameObject.SetActive(value: true);
		nGUITutorialPopup.Show(m_text, m_buttonShowDelay, message.Icon, message.TextWidth);
		messageOpenedThisFrame = true;
		m_buttonShowDelayRemaining = m_buttonShowDelay;
	}

	public void ShowPopup(string textId, int boxWidth)
	{
		InitPopups();
		if (InputUtils.IsTrackedRemoteActive())
		{
			string str = textId + "_C";
			m_text = str.Translate();
			if (m_text == string.Empty)
			{
				m_text = textId.Translate();
			}
		}
		else
		{
			m_text = textId.Translate();
		}
		Singleton<GameManager>.Instance.ToggleTutorial(pause: true);
		NGUITutorialPopup popup = m_popup;
		Transform parent = null;
		Vector3 localPosition = new Vector3(0f, 0f, 5f);
		Quaternion localRotation = Quaternion.Euler(new Vector3(0f, 180f, 0f));
		Turret turret = Singleton<GameManager>.Instance.Turret;
		if ((bool)turret)
		{
			parent = turret.transform;
			if ((bool)turret.textPlane)
			{
				parent = turret.textPlane.parent;
				localRotation = turret.textPlane.localRotation;
				localPosition = turret.textPlane.localPosition + new Vector3(0f, 0f, 0.2f);
			}
		}
		if ((bool)turret)
		{
			popup.transform.parent = parent;
			popup.transform.localPosition = localPosition;
			popup.transform.localRotation = localRotation;
		}
		else if (Singleton<NGUIProjectorMenuManager>.TryInstance())
		{
			popup.transform.parent = Singleton<NGUIProjectorMenuManager>.Instance.transform;
			popup.transform.localPosition = Vector3.zero;
			popup.transform.localRotation = Quaternion.identity;
		}
		else
		{
			popup.transform.parent = Singleton<CameraManager>.Instance.transform.parent;
			popup.transform.localPosition = new Vector3(0f, 0.5f, m_distanceFromCamera);
			popup.transform.localRotation = Quaternion.identity;
		}
		popup.gameObject.SetActive(value: true);
		popup.Show(m_text, m_buttonShowDelay, null, boxWidth);
		messageOpenedThisFrame = true;
		m_buttonShowDelayRemaining = m_buttonShowDelay;
		showingNonTutorialMessage = true;
	}

	public void CompleteTutorial(TutorialMessage message)
	{
		Singleton<Profile>.Instance.Tutorial.CompleteTutorialItem(message.Index);
		if (message is TutorialMessageFrontend)
		{
			m_frontEndTutorialMessages.Remove(message);
		}
		else
		{
			m_inGameTutorialMessages.Remove(message);
		}
	}

	private void Hide()
	{
		if (m_currentTutorial == null)
		{
			m_popup.Hide();
			Singleton<GameManager>.Instance.ToggleTutorial(pause: false);
			showingNonTutorialMessage = false;
			return;
		}
		((m_currentTutorial.Icon.Length <= 0) ? m_popup : m_popupWithIcon).Hide();
		if (!m_currentTutorial.Repeatable)
		{
			Singleton<Profile>.Instance.Tutorial.CompleteTutorialItem(m_currentTutorial.Index);
			if (m_currentTutorial is TutorialMessageFrontend)
			{
				m_frontEndTutorialMessages.Remove(m_currentTutorial);
			}
			else
			{
				m_inGameTutorialMessages.Remove(m_currentTutorial);
			}
		}
		previousTutorialCompleted = m_currentTutorial.Index;
		m_currentTutorial = null;
		Singleton<GameManager>.Instance.ToggleTutorial(pause: false);
	}

	private void Update()
	{
		bool flag = messageOpenedThisFrame;
		messageOpenedThisFrame = false;
		if (m_needToHide)
		{
			Hide();
			m_needToHide = false;
			return;
		}
		if (Singleton<GameManager>.Instance.InHangar)
		{
			UpdateFrontendTutorial();
		}
		else if (Singleton<MissionManager>.TryInstance() && Singleton<MissionManager>.Instance.Mission == 0)
		{
			UpdateInGameTutorial();
		}
		if (!showingNonTutorialMessage && (m_currentTutorial == null || m_currentTutorial.Index == -1))
		{
			return;
		}
		if (!Mathf.Approximately(0f, m_buttonShowDelayRemaining))
		{
			m_buttonShowDelayRemaining = Mathf.Max(0f, m_buttonShowDelayRemaining - Time.unscaledDeltaTime * m_buttonShowFadeInSpeed);
			return;
		}
		bool flag2 = m_popup.FadingIn || m_popupWithIcon.FadingIn;
		if (!flag && !flag2 && InputUtils.GetMenuButtonPressed() && Singleton<GameManager>.Instance.Button1State == GameManager.InputButtonState.NotPressed)
		{
			m_needToHide = true;
			if (m_currentTutorial != null)
			{
				m_currentTutorial.OnHide();
			}
		}
	}

	private void UpdateInGameTutorial()
	{
		if (m_inGameTutorialMessages == null)
		{
			return;
		}
		for (int i = 0; i < m_inGameTutorialMessages.Count; i++)
		{
			if (m_inGameTutorialMessages[i].NeedUpdate)
			{
				m_inGameTutorialMessages[i].Update();
			}
		}
	}

	private void UpdateFrontendTutorial()
	{
		if (m_frontEndTutorialMessages == null)
		{
			return;
		}
		for (int i = 0; i < m_frontEndTutorialMessages.Count; i++)
		{
			if (m_frontEndTutorialMessages[i].NeedUpdate)
			{
				m_frontEndTutorialMessages[i].Update();
			}
		}
	}
}
[Serializable]
public class TutorialMessage
{
	protected int m_index = -1;

	[SerializeField]
	protected bool m_repeatable = true;

	[SerializeField]
	protected string m_tutText;

	[SerializeField]
	protected string m_tutTextTouchController;

	[SerializeField]
	private string m_icon;

	[SerializeField]
	private int m_textWidth = 1000;

	protected bool m_needUpdate;

	protected bool m_activated;

	public string TutText => m_tutText;

	public string TutTextTouchController => m_tutTextTouchController;

	public bool Repeatable => m_repeatable;

	public bool NeedUpdate => m_needUpdate;

	public string Icon => m_icon;

	public int Index => m_index;

	public int TextWidth => m_textWidth;

	public virtual void Init(int index)
	{
		m_index = index;
		if (m_icon == null)
		{
			m_icon = string.Empty;
		}
		m_activated = false;
	}

	public virtual void DeInit()
	{
		m_activated = false;
	}

	public virtual void OnHide()
	{
		m_activated = false;
	}

	public virtual void Update()
	{
	}

	protected void Activate()
	{
		if (Singleton<GameManager>.Instance.State != GameManager.GameState.Tutorial)
		{
			DeInit();
			Singleton<TutorialManager>.Instance.Activate(this);
			m_activated = true;
		}
	}
}
[Serializable]
public class TutorialMessageControl : TutorialMessageFrontend
{
	public override void Update()
	{
		if (InputUtils.IsTrackedRemoteActive() && !m_activated)
		{
			m_needUpdate = !TryToActivate();
		}
	}

	protected override void OnMenuLoaded()
	{
		if (InputUtils.IsTrackedRemoteActive())
		{
			if (m_activatePage == NGUIProjectorMenuManager.Pages.MissionSelect)
			{
				Singleton<TutorialManager>.Instance.StartCoroutine(WaitForFadeOut());
			}
			if (Singleton<NGUIProjectorMenuManager>.TryInstance())
			{
				Singleton<NGUIProjectorMenuManager>.Instance.OnChangePage += OnChangePage;
			}
		}
	}
}
[Serializable]
public class TutorialMessageFrontend : TutorialMessage
{
	[SerializeField]
	protected NGUIProjectorMenuManager.Pages m_activatePage;

	protected NGUIProjectorMenuManager.Pages m_currentPage;

	public override void Init(int index)
	{
		base.Init(index);
		m_repeatable = false;
		MenuManager instance = Singleton<MenuManager>.Instance;
		instance.OnMenuLoadedEvent = (MenuManager.MenuDelegate)Delegate.Combine(instance.OnMenuLoadedEvent, new MenuManager.MenuDelegate(OnMenuLoaded));
	}

	protected virtual void OnMenuLoaded()
	{
		if (m_activatePage == NGUIProjectorMenuManager.Pages.MissionSelect)
		{
			Singleton<TutorialManager>.Instance.StartCoroutine(WaitForFadeOut());
		}
		if (Singleton<NGUIProjectorMenuManager>.TryInstance())
		{
			Singleton<NGUIProjectorMenuManager>.Instance.OnChangePage += OnChangePage;
		}
	}

	protected virtual bool TryToActivate()
	{
		if (Singleton<GameManager>.Instance.State != GameManager.GameState.Tutorial)
		{
			DeInit();
			Singleton<TutorialManager>.Instance.Activate(this);
			m_activated = true;
			return true;
		}
		return false;
	}

	protected virtual IEnumerator WaitForFadeOut()
	{
		while (Singleton<LoadingScreen>.TryInstance())
		{
			yield return null;
		}
		if (!TryToActivate())
		{
			m_needUpdate = true;
			m_currentPage = Singleton<NGUIProjectorMenuManager>.Instance.CurrentPage;
		}
	}

	protected virtual void OnChangePage(NGUIProjectorMenuManager.Pages page)
	{
		if (page == m_activatePage && !m_activated && !TryToActivate())
		{
			m_needUpdate = true;
			m_currentPage = page;
		}
	}

	public override void Update()
	{
		if (m_currentPage == m_activatePage && !m_activated)
		{
			m_needUpdate = !TryToActivate();
		}
	}

	public override void DeInit()
	{
		base.DeInit();
		if (Singleton<NGUIProjectorMenuManager>.TryInstance())
		{
			Singleton<NGUIProjectorMenuManager>.Instance.OnChangePage -= OnChangePage;
		}
		MenuManager instance = Singleton<MenuManager>.Instance;
		instance.OnMenuLoadedEvent = (MenuManager.MenuDelegate)Delegate.Remove(instance.OnMenuLoadedEvent, new MenuManager.MenuDelegate(OnMenuLoaded));
	}
}
[Serializable]
public class TutorialMessageGun2Acquired : TutorialMessageFrontend
{
	protected override IEnumerator WaitForFadeOut()
	{
		while (Singleton<LoadingScreen>.TryInstance())
		{
			yield return null;
		}
		if (Singleton<TutorialManager>.Instance.Gun2Acquired && !TryToActivate())
		{
			m_needUpdate = true;
			m_currentPage = Singleton<NGUIProjectorMenuManager>.Instance.CurrentPage;
		}
	}

	protected override void OnChangePage(NGUIProjectorMenuManager.Pages page)
	{
		if (page == m_activatePage && Singleton<TutorialManager>.Instance.Gun2Acquired && !m_activated && !TryToActivate())
		{
			m_needUpdate = true;
			m_currentPage = page;
		}
	}
}
[Serializable]
public class TutorialMessageGun3Acquired : TutorialMessageFrontend
{
	protected override IEnumerator WaitForFadeOut()
	{
		while (Singleton<LoadingScreen>.TryInstance())
		{
			yield return null;
		}
		if (Singleton<TutorialManager>.Instance.Gun3Acquired && !TryToActivate())
		{
			m_needUpdate = true;
			m_currentPage = Singleton<NGUIProjectorMenuManager>.Instance.CurrentPage;
		}
	}

	protected override void OnChangePage(NGUIProjectorMenuManager.Pages page)
	{
		if (page == m_activatePage && Singleton<TutorialManager>.Instance.Gun3Acquired && !m_activated && !TryToActivate())
		{
			m_needUpdate = true;
			m_currentPage = page;
		}
	}
}
[Serializable]
public class TutorialMessageSelectGun2 : TutorialMessageFrontend
{
	protected override void OnChangePage(NGUIProjectorMenuManager.Pages page)
	{
		if (page == m_activatePage && Singleton<TutorialManager>.Instance.NeedSelectGun2Tutorial && !m_activated)
		{
			if (Singleton<Profile>.Instance.Upgrades.GetOwnedGunCount(0) != 2 || !TryToActivate())
			{
				m_needUpdate = true;
				m_currentPage = page;
			}
			else
			{
				Singleton<Profile>.Instance.Upgrades.CurrentGun = 1;
				Singleton<TutorialManager>.Instance.NeedSelectGun2Tutorial = false;
			}
		}
	}

	public override void OnHide()
	{
		base.OnHide();
		Singleton<TutorialManager>.Instance.NeedSelectGun2Tutorial = false;
	}
}
[Serializable]
public class TutorialMessageSelectGun3 : TutorialMessageFrontend
{
	protected override void OnChangePage(NGUIProjectorMenuManager.Pages page)
	{
		if (page == m_activatePage && Singleton<TutorialManager>.Instance.NeedSelectGun3Tutorial && !m_activated)
		{
			if (Singleton<Profile>.Instance.Upgrades.GetOwnedGunCount(0) != 3 || !TryToActivate())
			{
				m_needUpdate = true;
				m_currentPage = page;
			}
			else
			{
				Singleton<Profile>.Instance.Upgrades.CurrentGun = 2;
				Singleton<TutorialManager>.Instance.NeedSelectGun3Tutorial = false;
			}
		}
	}

	public override void OnHide()
	{
		base.OnHide();
		Singleton<TutorialManager>.Instance.NeedSelectGun3Tutorial = false;
	}
}
[Serializable]
public class TutorialMessageUpgrades : TutorialMessageFrontend
{
	private int lowestCostOfUpgrade;

	public override void Init(int index)
	{
		base.Init(index);
		Singleton<UpgradeManager>.Instance.CanBuyUpgrade(UpgradeType.Gun1Damage, out lowestCostOfUpgrade);
	}

	protected override IEnumerator WaitForFadeOut()
	{
		while (Singleton<LoadingScreen>.TryInstance())
		{
			yield return null;
		}
		if (Singleton<Profile>.Instance.Player.GetMoney() >= lowestCostOfUpgrade && !TryToActivate())
		{
			m_needUpdate = true;
			m_currentPage = Singleton<NGUIProjectorMenuManager>.Instance.CurrentPage;
		}
	}

	protected override void OnChangePage(NGUIProjectorMenuManager.Pages page)
	{
		if (page == m_activatePage && Singleton<Profile>.Instance.Player.GetMoney() >= lowestCostOfUpgrade && !m_activated && !TryToActivate())
		{
			m_needUpdate = true;
			m_currentPage = page;
		}
	}
}
[Serializable]
public class TutorialMessageRadar : TutorialMessage
{
	public override void Init(int index)
	{
		base.Init(index);
		Singleton<GameManager>.Instance.OnStartMission += StartMission;
		Singleton<GameManager>.Instance.OnEndMission += EndMission;
	}

	private void StartMission(bool restart)
	{
		if (Singleton<MissionManager>.Instance.Mission == 0)
		{
			EnemyBehaviorManager instance = Singleton<EnemyBehaviorManager>.Instance;
			instance.EnemySpawn = (EnemyBehaviorManager.EnemyDelegate)Delegate.Combine(instance.EnemySpawn, new EnemyBehaviorManager.EnemyDelegate(base.Activate));
			Singleton<GameManager>.Instance.Turret.ActivateGuns(activate: false);
		}
	}

	private void EndMission(GameManager.EndMissionReason reason)
	{
		DeInit();
	}

	public override void DeInit()
	{
		base.DeInit();
		if (Singleton<MissionManager>.Instance.Mission == 0)
		{
			EnemyBehaviorManager instance = Singleton<EnemyBehaviorManager>.Instance;
			instance.EnemySpawn = (EnemyBehaviorManager.EnemyDelegate)Delegate.Remove(instance.EnemySpawn, new EnemyBehaviorManager.EnemyDelegate(base.Activate));
		}
	}
}
[Serializable]
public class TutorialMessageKillEnemy : TutorialMessage
{
	public override void Init(int index)
	{
		base.Init(index);
		Singleton<GameManager>.Instance.OnStartMission += StartMission;
		Singleton<GameManager>.Instance.OnEndMission += EndMission;
	}

	private void StartMission(bool restart)
	{
		if (Singleton<MissionManager>.Instance.Mission == 0)
		{
			EnemyBehaviorManager instance = Singleton<EnemyBehaviorManager>.Instance;
			instance.EnemySpawn = (EnemyBehaviorManager.EnemyDelegate)Delegate.Combine(instance.EnemySpawn, new EnemyBehaviorManager.EnemyDelegate(OnEnemySpawn));
			Singleton<GameManager>.Instance.Turret.ActivateGuns(activate: false);
		}
	}

	private void OnEnemySpawn()
	{
		m_needUpdate = true;
	}

	public override void Update()
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag("Enemy");
		for (int i = 0; i < array.Length; i++)
		{
			float num = Vector3.Dot(Singleton<CameraManager>.Instance.GetCamera().forward, array[i].transform.position.normalized);
			if (num > 0.9f && Singleton<GameManager>.Instance.State == GameManager.GameState.InGame)
			{
				Activate();
			}
		}
	}

	private void EndMission(GameManager.EndMissionReason reason)
	{
		base.DeInit();
		DeInit();
	}

	public override void DeInit()
	{
		base.DeInit();
		if (Singleton<MissionManager>.Instance.Mission == 0)
		{
			m_needUpdate = false;
			Singleton<GameManager>.Instance.Turret.ActivateGuns(activate: true);
			EnemyBehaviorManager instance = Singleton<EnemyBehaviorManager>.Instance;
			instance.EnemySpawn = (EnemyBehaviorManager.EnemyDelegate)Delegate.Remove(instance.EnemySpawn, new EnemyBehaviorManager.EnemyDelegate(OnEnemySpawn));
		}
	}
}
[Serializable]
public class TutorialMessageOverheat : TutorialMessage
{
	[SerializeField]
	protected float m_activationLimit;

	public override void Init(int index)
	{
		base.Init(index);
		Singleton<GameManager>.Instance.OnStartMission += StartMission;
		Singleton<GameManager>.Instance.OnEndMission += EndMission;
	}

	private void StartMission(bool restart)
	{
		if (Singleton<MissionManager>.Instance.Mission == 0)
		{
			m_needUpdate = true;
		}
	}

	protected virtual void EndMission(GameManager.EndMissionReason reason)
	{
		m_needUpdate = false;
	}

	public override void Update()
	{
		float overheatPercentage = Singleton<GameManager>.Instance.PlayerStatsData.GetOverheatPercentage();
		if (overheatPercentage >= m_activationLimit && !Singleton<TutorialManager>.Instance.ShowingTutorial)
		{
			Activate();
			m_needUpdate = false;
		}
	}
}
[Serializable]
public class TutorialMessageHealth : TutorialMessageOverheat
{
	private int m_prevCount;

	protected override void EndMission(GameManager.EndMissionReason reason)
	{
		m_needUpdate = false;
		m_prevCount = 0;
	}

	public override void Update()
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag("Enemy");
		if (array.Length < m_prevCount)
		{
			Activate();
			m_needUpdate = false;
		}
		m_prevCount = array.Length;
	}
}
[Serializable]
public class TutorialMessageKillCargo : TutorialMessage
{
	private EnemyStatus m_trackingCargo;

	public override void Init(int index)
	{
		base.Init(index);
		Singleton<GameManager>.Instance.OnStartMission += StartMission;
		Singleton<GameManager>.Instance.OnEndMission += EndMission;
	}

	private void EndMission(GameManager.EndMissionReason reason)
	{
		if (Singleton<MissionManager>.Instance.Mission == 0)
		{
			m_needUpdate = false;
			m_trackingCargo = null;
			EnemyBehaviorManager instance = Singleton<EnemyBehaviorManager>.Instance;
			instance.CargoSpawn = (EnemyBehaviorManager.EnemyDelegate)Delegate.Remove(instance.CargoSpawn, new EnemyBehaviorManager.EnemyDelegate(base.Activate));
			Singleton<GameManager>.Instance.EnemyTimeScale = 1f;
		}
	}

	private void StartMission(bool restart)
	{
		if (Singleton<MissionManager>.Instance.Mission == 0)
		{
			EnemyBehaviorManager instance = Singleton<EnemyBehaviorManager>.Instance;
			instance.CargoSpawn = (EnemyBehaviorManager.EnemyDelegate)Delegate.Combine(instance.CargoSpawn, new EnemyBehaviorManager.EnemyDelegate(base.Activate));
		}
	}

	public override void Update()
	{
		if (!m_trackingCargo)
		{
			GameObject[] array = GameObject.FindGameObjectsWithTag("Enemy");
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].GetComponent<CargoBehavior>() != null)
				{
					m_trackingCargo = array[i].GetComponent<EnemyStatus>();
					break;
				}
			}
			return;
		}
		float num = Vector3.SqrMagnitude(m_trackingCargo.transform.position);
		if (num < 55000f || m_trackingCargo.GetHealthPercentage() <= 0f)
		{
			Singleton<GameManager>.Instance.EnemyTimeScale = 0f;
			m_needUpdate = false;
			m_trackingCargo = null;
			EnemyBehaviorManager instance = Singleton<EnemyBehaviorManager>.Instance;
			instance.CargoSpawn = (EnemyBehaviorManager.EnemyDelegate)Delegate.Remove(instance.CargoSpawn, new EnemyBehaviorManager.EnemyDelegate(base.Activate));
		}
	}

	public override void DeInit()
	{
		base.DeInit();
		m_needUpdate = true;
		m_trackingCargo = null;
	}
}
[Serializable]
public class TutorialMessageShootPowerUp : TutorialMessage
{
	private EnemyStatus m_trackingCargo;

	public override void Init(int index)
	{
		base.Init(index);
		Singleton<GameManager>.Instance.OnStartMission += StartMission;
		Singleton<GameManager>.Instance.OnEndMission += EndMission;
	}

	private void StartMission(bool restart)
	{
		if (Singleton<MissionManager>.Instance.Mission == 0)
		{
			EnemyBehaviorManager instance = Singleton<EnemyBehaviorManager>.Instance;
			instance.CargoSpawn = (EnemyBehaviorManager.EnemyDelegate)Delegate.Combine(instance.CargoSpawn, new EnemyBehaviorManager.EnemyDelegate(OnCargoSpawn));
		}
	}

	private void EndMission(GameManager.EndMissionReason reason)
	{
		DeInit();
		if (Singleton<MissionManager>.Instance.Mission == 0)
		{
			EnemyBehaviorManager instance = Singleton<EnemyBehaviorManager>.Instance;
			instance.CargoSpawn = (EnemyBehaviorManager.EnemyDelegate)Delegate.Remove(instance.CargoSpawn, new EnemyBehaviorManager.EnemyDelegate(OnCargoSpawn));
		}
	}

	private void OnCargoSpawn()
	{
		EnemyBehaviorManager instance = Singleton<EnemyBehaviorManager>.Instance;
		instance.CargoSpawn = (EnemyBehaviorManager.EnemyDelegate)Delegate.Remove(instance.CargoSpawn, new EnemyBehaviorManager.EnemyDelegate(OnCargoSpawn));
		m_needUpdate = true;
	}

	public override void Update()
	{
		if (!m_trackingCargo)
		{
			GameObject[] array = GameObject.FindGameObjectsWithTag("Enemy");
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].GetComponent<CargoBehavior>() != null)
				{
					m_trackingCargo = array[i].GetComponent<EnemyStatus>();
				}
			}
		}
		else if (m_trackingCargo.GetHealthPercentage() <= 0f)
		{
			Activate();
		}
	}

	public override void DeInit()
	{
		base.DeInit();
		m_needUpdate = false;
		m_trackingCargo = null;
	}
}
[Serializable]
public class TutorialMessageCollectPowerUp : TutorialMessage
{
	public override void Init(int index)
	{
		base.Init(index);
		Singleton<GameManager>.Instance.OnStartMission += StartMission;
		Singleton<GameManager>.Instance.OnEndMission += EndMission;
	}

	private void StartMission(bool restart)
	{
		if (Singleton<MissionManager>.Instance.Mission == 0)
		{
			PowerUpManager instance = Singleton<PowerUpManager>.Instance;
			instance.CollectPowerUpEvent = (PowerUpManager.PowerUpDelegate)Delegate.Combine(instance.CollectPowerUpEvent, new PowerUpManager.PowerUpDelegate(base.Activate));
		}
	}

	private void EndMission(GameManager.EndMissionReason reason)
	{
		DeInit();
	}

	public override void DeInit()
	{
		base.DeInit();
		if (Singleton<MissionManager>.Instance.Mission == 0)
		{
			PowerUpManager instance = Singleton<PowerUpManager>.Instance;
			instance.CollectPowerUpEvent = (PowerUpManager.PowerUpDelegate)Delegate.Remove(instance.CollectPowerUpEvent, new PowerUpManager.PowerUpDelegate(base.Activate));
			Singleton<GameManager>.Instance.EnemyTimeScale = 1f;
		}
	}
}
[Serializable]
public class TutorialMessageProgressScreen : TutorialMessage
{
	[SerializeField]
	private float m_timeDelay = 2f;

	private float m_currentTime;

	public override void Init(int index)
	{
		base.Init(index);
		Singleton<GameManager>.Instance.OnStartMission += StartMission;
		Singleton<GameManager>.Instance.OnEndMission += EndMission;
	}

	private void StartMission(bool restart)
	{
		if (Singleton<MissionManager>.Instance.Mission == 0)
		{
			PowerUpManager instance = Singleton<PowerUpManager>.Instance;
			instance.CollectPowerUpEvent = (PowerUpManager.PowerUpDelegate)Delegate.Combine(instance.CollectPowerUpEvent, new PowerUpManager.PowerUpDelegate(OnCollectPowerUp));
			m_currentTime = 0f;
		}
	}

	private void EndMission(GameManager.EndMissionReason reason)
	{
		if (m_needUpdate)
		{
			PowerUpManager instance = Singleton<PowerUpManager>.Instance;
			instance.CollectPowerUpEvent = (PowerUpManager.PowerUpDelegate)Delegate.Remove(instance.CollectPowerUpEvent, new PowerUpManager.PowerUpDelegate(OnCollectPowerUp));
			m_needUpdate = false;
		}
	}

	private void OnCollectPowerUp()
	{
		PowerUpManager instance = Singleton<PowerUpManager>.Instance;
		instance.CollectPowerUpEvent = (PowerUpManager.PowerUpDelegate)Delegate.Remove(instance.CollectPowerUpEvent, new PowerUpManager.PowerUpDelegate(OnCollectPowerUp));
		m_needUpdate = true;
	}

	public override void Update()
	{
		m_currentTime += Time.deltaTime * Singleton<GameManager>.Instance.EnemyTimeScale;
		if (m_currentTime > m_timeDelay)
		{
			Activate();
		}
	}

	public override void DeInit()
	{
		base.DeInit();
		m_needUpdate = false;
	}
}
[Serializable]
public class TutorialMessageScoreScreen : TutorialMessage
{
	public override void Init(int index)
	{
		base.Init(index);
		Singleton<GameManager>.Instance.OnEndMission += EndMission;
	}

	private void EndMission(GameManager.EndMissionReason reason)
	{
		if (Singleton<MissionManager>.Instance.Mission == 0 && reason == GameManager.EndMissionReason.Victory)
		{
			Activate();
		}
	}

	public override void OnHide()
	{
		Singleton<GameManager>.Instance.ShowScoreScreen();
	}
}
[ExecuteInEditMode]
public class UpgradeManager : Singleton<UpgradeManager>
{
	[SerializeField]
	private UpgradeTree m_upgradeTree;

	public string GetUpgradeName(UpgradeType type)
	{
		return ("menu_proj_upgrades_name_" + type).Translate();
	}

	public string GetUpgradeDescription(UpgradeType type)
	{
		return ("menu_proj_upgrades_desc_" + type).Translate();
	}

	public void GetUpgradeProgress(UpgradeType type, ref int progress)
	{
		int num = (int)type;
		if (num == 0)
		{
			progress = Singleton<Profile>.Instance.Upgrades.GetArmourUpgrade();
		}
		else if (num <= 9)
		{
			int gun = (num - 1) / 3;
			int upgrade = (num - 1) % 3;
			progress = Singleton<Profile>.Instance.Upgrades.GetGunUpgrade(gun, upgrade);
		}
		else if (num < 18)
		{
			num -= 10;
			progress = Singleton<Profile>.Instance.Upgrades.GetPowerUpUpgrade(num);
		}
		else
		{
			progress = 0;
		}
	}

	public int CanBuyUpgrade(UpgradeType type)
	{
		int CostOut;
		return CanBuyUpgrade(type, out CostOut);
	}

	public int CanBuyUpgrade(UpgradeType type, out int CostOut)
	{
		int num = (int)type;
		int num2 = 0;
		int num3 = 0;
		CostOut = 0;
		if (num == 0)
		{
			num3 = Singleton<Profile>.Instance.Upgrades.GetArmourUpgrade();
			if (num3 >= m_upgradeTree.m_healthBonus.Length - 1)
			{
				return -1;
			}
			num2 = (CostOut = m_upgradeTree.m_healthBonus[num3 + 1].m_cost);
			if (num2 > Singleton<Profile>.Instance.Player.GetMoney())
			{
				return -1;
			}
		}
		else if (num <= 9)
		{
			int num4 = (num - 1) / 3;
			int num5 = (num - 1) % 3;
			num3 = Singleton<Profile>.Instance.Upgrades.GetGunUpgrade(num4, num5);
			int num6 = 0;
			switch (num5)
			{
			case 0:
				num6 = m_upgradeTree.m_gunUpgrades[num4].m_damage.Length;
				if (num3 >= num6 - 1)
				{
					return -1;
				}
				num2 = m_upgradeTree.m_gunUpgrades[num4].m_damage[num3 + 1].m_cost;
				break;
			case 1:
				num6 = m_upgradeTree.m_gunUpgrades[num4].m_fireRate.Length;
				if (num3 >= num6 - 1)
				{
					return -1;
				}
				num2 = m_upgradeTree.m_gunUpgrades[num4].m_fireRate[num3 + 1].m_cost;
				break;
			case 2:
				num6 = m_upgradeTree.m_gunUpgrades[num4].m_coolingSpeed.Length;
				if (num3 >= num6 - 1)
				{
					return -1;
				}
				num2 = m_upgradeTree.m_gunUpgrades[num4].m_coolingSpeed[num3 + 1].m_cost;
				break;
			}
			CostOut = num2;
			if (num2 > Singleton<Profile>.Instance.Player.GetMoney())
			{
				return -1;
			}
		}
		else
		{
			num -= 10;
			num3 = Singleton<Profile>.Instance.Upgrades.GetPowerUpUpgrade(num);
			if (num3 >= m_upgradeTree.m_powerUpUpgrades[num].m_cost.Length - 1)
			{
				return -1;
			}
			num2 = (CostOut = m_upgradeTree.m_powerUpUpgrades[num].m_cost[num3 + 1]);
			if (num2 > Singleton<Profile>.Instance.Player.GetMoney())
			{
				return -1;
			}
		}
		CostOut = num2;
		return num2;
	}

	public bool IsUpgradeMaxed(UpgradeType type)
	{
		if (type == UpgradeType.Armour)
		{
			return Singleton<Profile>.Instance.Upgrades.GetArmourUpgrade() >= m_upgradeTree.m_healthBonus.Length - 1;
		}
		int num = (int)type;
		if (type <= UpgradeType.Gun3Cooling)
		{
			int num2 = (num - 1) / 3;
			int num3 = (num - 1) % 3;
			int gunUpgrade = Singleton<Profile>.Instance.Upgrades.GetGunUpgrade(num2, num3);
			return num3 switch
			{
				0 => gunUpgrade >= m_upgradeTree.m_gunUpgrades[num2].m_damage.Length - 1, 
				1 => gunUpgrade >= m_upgradeTree.m_gunUpgrades[num2].m_fireRate.Length - 1, 
				2 => gunUpgrade >= m_upgradeTree.m_gunUpgrades[num2].m_coolingSpeed.Length - 1, 
				_ => false, 
			};
		}
		num -= 10;
		return Singleton<Profile>.Instance.Upgrades.GetPowerUpUpgrade(num) >= m_upgradeTree.m_powerUpUpgrades[num].m_cost.Length - 1;
	}

	public bool BuyUpgrade(UpgradeType type)
	{
		int num = CanBuyUpgrade(type);
		if (num >= 0)
		{
			if (type == UpgradeType.Armour)
			{
				Singleton<Profile>.Instance.Upgrades.BuyArmourUpgrade();
			}
			else if (type <= UpgradeType.Gun3Cooling)
			{
				int gun = (int)(type - 1) / 3;
				int upgrade = (int)(type - 1) % 3;
				Singleton<Profile>.Instance.Upgrades.BuyGunUpgrade(gun, upgrade);
			}
			else
			{
				Singleton<Profile>.Instance.Upgrades.BuyPowerUpUpgrade((int)(type - 10));
			}
			Singleton<Profile>.Instance.Player.SpendMoney(num);
			Singleton<Profile>.Instance.Save();
			return true;
		}
		return false;
	}

	public float GetMaxHealth()
	{
		int armourUpgrade = Singleton<Profile>.Instance.Upgrades.GetArmourUpgrade();
		float num = m_upgradeTree.m_healthBonus[0].m_value;
		if (armourUpgrade > 0)
		{
			num += num * m_upgradeTree.m_healthBonus[armourUpgrade].m_value * 0.01f;
		}
		return num;
	}

	public void GetGunStats(ref float damage, ref float fireRate, ref float coolingTime, ref float heatingTime)
	{
		int currentGun = Singleton<Profile>.Instance.Upgrades.CurrentGun;
		int damage2 = 0;
		int fireRate2 = 0;
		int coolingSpeed = 0;
		Singleton<Profile>.Instance.Upgrades.GetGunUpgrades(ref damage2, ref fireRate2, ref coolingSpeed);
		damage = m_upgradeTree.m_gunUpgrades[currentGun].m_damage[0].m_value;
		if (damage2 > 0)
		{
			damage += damage * m_upgradeTree.m_gunUpgrades[currentGun].m_damage[damage2].m_value * 0.01f;
		}
		fireRate = m_upgradeTree.m_gunUpgrades[currentGun].m_fireRate[0].m_value;
		if (fireRate2 > 0)
		{
			fireRate += fireRate * m_upgradeTree.m_gunUpgrades[currentGun].m_fireRate[fireRate2].m_value * 0.01f;
		}
		heatingTime = m_upgradeTree.m_gunUpgrades[currentGun].m_fireRateTable[coolingSpeed].m_data[fireRate2];
		coolingTime = m_upgradeTree.m_gunUpgrades[currentGun].m_coolingSpeed[coolingSpeed].m_value;
	}

	public float GetPowerUp(PowerUpType type)
	{
		if (type != PowerUpType.Checkpoint)
		{
			int powerUpUpgrade = Singleton<Profile>.Instance.Upgrades.GetPowerUpUpgrade((int)type);
			return m_upgradeTree.m_powerUpUpgrades[(int)type].m_positive[powerUpUpgrade];
		}
		return 0f;
	}

	public void UpdateOwnedGuns()
	{
		int starsAmount = Singleton<Profile>.Instance.Progress.GetStarsAmount();
		for (int i = 0; i < m_upgradeTree.m_GunUnlockStarRequirements.Length; i++)
		{
			if (starsAmount >= m_upgradeTree.m_GunUnlockStarRequirements[i])
			{
				Singleton<Profile>.Instance.Upgrades.BuyGun(i);
			}
		}
	}

	public int GunRequiredStars(int gun)
	{
		return m_upgradeTree.m_GunUnlockStarRequirements[gun];
	}
}
public enum UpgradeType
{
	Armour,
	Gun1Damage,
	Gun1FireRate,
	Gun1Cooling,
	Gun2Damage,
	Gun2FireRate,
	Gun2Cooling,
	Gun3Damage,
	Gun3FireRate,
	Gun3Cooling,
	Invulnerability,
	Slowmo,
	Cooling,
	Damage,
	Points,
	FireRate,
	HealthPowerUp,
	ExtraTime,
	Checkpoint
}
public class UpgradeTree : ScriptableObject
{
	[Serializable]
	public struct GunUpgrades
	{
		public ShopItem[] m_damage;

		public ShopItem[] m_fireRate;

		public ShopItem[] m_coolingSpeed;

		public Row[] m_fireRateTable;
	}

	[Serializable]
	public struct ShopItem
	{
		public float m_value;

		public int m_cost;
	}

	[Serializable]
	public struct PowerUpShopItem
	{
		[HideInInspector]
		public string m_name;

		public float[] m_positive;

		public int[] m_cost;
	}

	[Serializable]
	public struct Row
	{
		public float[] m_data;
	}

	public ShopItem[] m_healthBonus;

	public GunUpgrades[] m_gunUpgrades = new GunUpgrades[3];

	public PowerUpShopItem[] m_powerUpUpgrades = new PowerUpShopItem[9];

	public int[] m_GunUnlockStarRequirements = new int[3] { 0, 10, 20 };
}
[RequireComponent(typeof(Camera))]
public class EnableCameraDepthInForward : MonoBehaviour
{
	private void Start()
	{
		Set();
	}

	private void Set()
	{
		if (GetComponent<Camera>().depthTextureMode == DepthTextureMode.None)
		{
			GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
		}
	}
}
