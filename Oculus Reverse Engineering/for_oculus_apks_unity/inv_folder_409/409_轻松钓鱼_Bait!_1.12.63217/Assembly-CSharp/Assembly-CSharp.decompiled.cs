using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Text.RegularExpressions;
using CakewalkIoC.Core;
using CakewalkIoC.Exceptions;
using CakewalkIoC.Injection;
using CakewalkIoC.Signal;
using DarkTonic.MasterAudio;
using Oculus.Platform;
using Oculus.Platform.Models;
using RG;
using RGCommon;
using UnityEngine;
using UnityEngine.Audio;
using UnityEngine.EventSystems;
using UnityEngine.Networking;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;
using UnityEngine.Serialization;
using UnityEngine.UI;
using UnityEngine.XR;

[assembly: InternalsVisibleTo("Assembly-CSharp-Editor")]
[assembly: InternalsVisibleTo("Assembly-CSharp-Editor")]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: AssemblyVersion("0.0.0.0")]
namespace CakewalkIoC.Core
{
	public abstract class BaseBootStrapper : MonoBehaviour
	{
		public static BaseBootStrapper Instance { get; private set; }

		private void Awake()
		{
			if (Instance == null)
			{
				Instance = this;
				Container container2 = (IoCExtentions.Container = new Container());
				Configure(container2);
				UnityEngine.Object.DontDestroyOnLoad(this);
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		public abstract void Configure(Container container);
	}
	public class Container
	{
		private List<Type> dependencyChain;

		public Dictionary<Type, Type> Registrations { get; private set; }

		public Dictionary<Type, object> Instances { get; private set; }

		public Container()
		{
			Registrations = new Dictionary<Type, Type>();
			Instances = new Dictionary<Type, object>();
			dependencyChain = new List<Type>();
		}

		public void Register<TInterface, TClass>() where TClass : class, TInterface
		{
			ValidateRegistration<TInterface, TClass>();
			Registrations.Add(typeof(TInterface), typeof(TClass));
		}

		public void Register<TClass>() where TClass : class
		{
			if (Registrations.Values.Contains(typeof(TClass)))
			{
				throw new RegistrationException(typeof(TClass).ToString() + "is already registered.");
			}
			Registrations.Add(typeof(TClass), typeof(TClass));
		}

		public void InjectProperties(object obj)
		{
			Type type = obj.GetType();
			PropertyInfo[] array = (from prop in type.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
				where prop.IsDefined(typeof(Dependency), inherit: false)
				select prop).ToArray();
			PropertyInfo[] array2 = array;
			foreach (PropertyInfo propertyInfo in array2)
			{
				object value = Resolve(propertyInfo.PropertyType);
				propertyInfo.SetValue(obj, value, null);
			}
		}

		private void ValidateRegistration<TInterface, TClass>()
		{
			if (!typeof(TInterface).IsInterface)
			{
				throw new RegistrationException(typeof(TInterface).ToString() + "is not an interface.");
			}
			if (typeof(TClass).IsAbstract)
			{
				throw new RegistrationException(typeof(TClass).ToString() + "is abstract and cannot be instantiated.");
			}
		}

		public object Resolve<T>()
		{
			Type typeFromHandle = typeof(T);
			return Resolve(typeFromHandle);
		}

		private object Resolve(Type type)
		{
			if (Instances.TryGetValue(type, out var value))
			{
				return value;
			}
			if (dependencyChain.Contains(type))
			{
				throw new CircularDependencyException("Circular dependency in " + type.ToString());
			}
			dependencyChain.Add(type);
			if (!Registrations.TryGetValue(type, out var value2))
			{
				throw new NullBindingException("Attempt to instanciate a null-binding. " + type.ToString() + " is not registered.");
			}
			ConstructorInfo constructor = GetConstructor(value2);
			object[] array = ResolvedDependencies(constructor);
			if (array.Length < 1)
			{
				dependencyChain.Clear();
			}
			value = constructor.Invoke(array);
			Instances.Add(type, value);
			return value;
		}

		private ConstructorInfo GetConstructor(Type type)
		{
			ConstructorInfo[] constructors = type.GetConstructors();
			if (constructors.Length < 1)
			{
				throw new ResolveException(type.ToString() + " has no public constructors and cannot be instanciated.");
			}
			return constructors.Aggregate((ConstructorInfo c1, ConstructorInfo c2) => (c1.GetParameters().Count() <= c2.GetParameters().Count()) ? c2 : c1);
		}

		private object[] ResolvedDependencies(ConstructorInfo constructorInfo)
		{
			List<object> list = new List<object>();
			ParameterInfo[] parameters = constructorInfo.GetParameters();
			ParameterInfo[] array = parameters;
			foreach (ParameterInfo parameterInfo in array)
			{
				if (parameterInfo.ParameterType.IsValueType)
				{
					throw new ResolveException(string.Concat("Parameter ", parameterInfo.ToString(), " in ", constructorInfo.ReflectedType, " is a valuetype. This is not allowed in injected classes"));
				}
				Type parameterType = parameterInfo.ParameterType;
				object item = Resolve(parameterType);
				list.Add(item);
			}
			return list.ToArray();
		}
	}
}
namespace CakewalkIoC.Injection
{
	[AttributeUsage(AttributeTargets.Property)]
	public class Dependency : Attribute
	{
	}
}
namespace CakewalkIoC.Exceptions
{
	public class CircularDependencyException : Exception
	{
		public CircularDependencyException(string message)
			: base(message)
		{
		}
	}
	public class NullBindingException : Exception
	{
		public NullBindingException(string message)
			: base(message)
		{
		}
	}
	public class RegistrationException : Exception
	{
		public RegistrationException(string message)
			: base(message)
		{
		}
	}
	public class ResolveException : Exception
	{
		public ResolveException(string message)
			: base(message)
		{
		}
	}
}
namespace CakewalkIoC.Injection
{
	public static class IoCExtentions
	{
		public static Container Container { get; set; }

		public static void Inject<T>(this T monoBehaviour) where T : MonoBehaviour
		{
			Container.InjectProperties(monoBehaviour);
		}
	}
}
namespace CakewalkIoC.Signal
{
	public class Signal
	{
		public delegate void SignalDelegate();

		private event SignalDelegate SendSignal;

		public void AddListener(SignalDelegate listener)
		{
			if (this.SendSignal == null)
			{
				SendSignal += listener;
			}
			else if (!this.SendSignal.GetInvocationList().Contains(listener))
			{
				SendSignal += listener;
			}
		}

		public void RemoveListener(SignalDelegate listener)
		{
			SendSignal -= listener;
		}

		public void Dispatch()
		{
			if (this.SendSignal != null)
			{
				this.SendSignal();
			}
		}
	}
	public class Signal<T>
	{
		public delegate void SignalDelegate(T item);

		private event SignalDelegate SendSignal;

		public void AddListener(SignalDelegate listener)
		{
			if (this.SendSignal == null)
			{
				SendSignal += listener;
			}
			else if (!this.SendSignal.GetInvocationList().Contains(listener))
			{
				SendSignal += listener;
			}
		}

		public void RemoveListener(SignalDelegate listener)
		{
			SendSignal -= listener;
		}

		public void Dispatch(T item)
		{
			if (this.SendSignal != null)
			{
				this.SendSignal(item);
			}
		}
	}
	public class Signal<T, U>
	{
		public delegate void SignalDelegate(T item1, U item2);

		private event SignalDelegate SendSignal;

		public void AddListener(SignalDelegate listener)
		{
			if (this.SendSignal == null)
			{
				SendSignal += listener;
			}
			else if (!this.SendSignal.GetInvocationList().Contains(listener))
			{
				SendSignal += listener;
			}
		}

		public void RemoveListener(SignalDelegate listener)
		{
			SendSignal -= listener;
		}

		public void Dispatch(T item1, U item2)
		{
			if (this.SendSignal != null)
			{
				this.SendSignal(item1, item2);
			}
		}
	}
	public class Signal<T, U, V>
	{
		public delegate void SignalDelegate(T item1, U item2, V item3);

		private event SignalDelegate SendSignal;

		public void AddListener(SignalDelegate listener)
		{
			if (this.SendSignal == null)
			{
				SendSignal += listener;
			}
			else if (!this.SendSignal.GetInvocationList().Contains(listener))
			{
				SendSignal += listener;
			}
		}

		public void RemoveListener(SignalDelegate listener)
		{
			SendSignal -= listener;
		}

		public void Dispatch(T item1, U item2, V item3)
		{
			if (this.SendSignal != null)
			{
				this.SendSignal(item1, item2, item3);
			}
		}
	}
	public class Signal<T, U, V, W>
	{
		public delegate void SignalDelegate(T item1, U item2, V item3, W item4);

		private event SignalDelegate SendSignal;

		public void AddListener(SignalDelegate listener)
		{
			if (this.SendSignal == null)
			{
				SendSignal += listener;
			}
			else if (!this.SendSignal.GetInvocationList().Contains(listener))
			{
				SendSignal += listener;
			}
		}

		public void RemoveListener(SignalDelegate listener)
		{
			SendSignal -= listener;
		}

		public void Dispatch(T item1, U item2, V item3, W item4)
		{
			if (this.SendSignal != null)
			{
				this.SendSignal(item1, item2, item3, item4);
			}
		}
	}
}
public class LeanAudioStream
{
	public int position;

	public AudioClip audioClip;

	public float[] audioArr;

	public LeanAudioStream(float[] audioArr)
	{
		this.audioArr = audioArr;
	}

	public void OnAudioRead(float[] data)
	{
		for (int i = 0; i < data.Length; i++)
		{
			data[i] = audioArr[position];
			position++;
		}
	}

	public void OnAudioSetPosition(int newPosition)
	{
		position = newPosition;
	}
}
public class LeanAudio
{
	public static float MIN_FREQEUNCY_PERIOD = 0.000115f;

	public static int PROCESSING_ITERATIONS_MAX = 50000;

	public static float[] generatedWaveDistances;

	public static int generatedWaveDistancesCount;

	private static float[] longList;

	public static LeanAudioOptions options()
	{
		if (generatedWaveDistances == null)
		{
			generatedWaveDistances = new float[PROCESSING_ITERATIONS_MAX];
			longList = new float[PROCESSING_ITERATIONS_MAX];
		}
		return new LeanAudioOptions();
	}

	public static LeanAudioStream createAudioStream(AnimationCurve volume, AnimationCurve frequency, LeanAudioOptions options = null)
	{
		if (options == null)
		{
			options = new LeanAudioOptions();
		}
		options.useSetData = false;
		int waveLength = createAudioWave(volume, frequency, options);
		createAudioFromWave(waveLength, options);
		return options.stream;
	}

	public static AudioClip createAudio(AnimationCurve volume, AnimationCurve frequency, LeanAudioOptions options = null)
	{
		if (options == null)
		{
			options = new LeanAudioOptions();
		}
		int waveLength = createAudioWave(volume, frequency, options);
		return createAudioFromWave(waveLength, options);
	}

	private static int createAudioWave(AnimationCurve volume, AnimationCurve frequency, LeanAudioOptions options)
	{
		float time = volume[volume.length - 1].time;
		int num = 0;
		float num2 = 0f;
		for (int i = 0; i < PROCESSING_ITERATIONS_MAX; i++)
		{
			float num3 = frequency.Evaluate(num2);
			if (num3 < MIN_FREQEUNCY_PERIOD)
			{
				num3 = MIN_FREQEUNCY_PERIOD;
			}
			float num4 = volume.Evaluate(num2 + 0.5f * num3);
			if (options.vibrato != null)
			{
				for (int j = 0; j < options.vibrato.Length; j++)
				{
					float num5 = Mathf.Abs(Mathf.Sin(1.5708f + num2 * (1f / options.vibrato[j][0]) * (float)Math.PI));
					float num6 = 1f - options.vibrato[j][1];
					num5 = options.vibrato[j][1] + num6 * num5;
					num4 *= num5;
				}
			}
			if (num2 + 0.5f * num3 >= time)
			{
				break;
			}
			if (num >= PROCESSING_ITERATIONS_MAX - 1)
			{
				UnityEngine.Debug.LogError("LeanAudio has reached it's processing cap. To avoid this error increase the number of iterations ex: LeanAudio.PROCESSING_ITERATIONS_MAX = " + PROCESSING_ITERATIONS_MAX * 2);
				break;
			}
			int num7 = num / 2;
			num2 += num3;
			generatedWaveDistances[num7] = num2;
			longList[num] = num2;
			longList[num + 1] = ((i % 2 != 0) ? num4 : (0f - num4));
			num += 2;
		}
		num += -2;
		generatedWaveDistancesCount = num / 2;
		return num;
	}

	private static AudioClip createAudioFromWave(int waveLength, LeanAudioOptions options)
	{
		float num = longList[waveLength - 2];
		float[] array = new float[(int)((float)options.frequencyRate * num)];
		int num2 = 0;
		float num3 = longList[num2];
		float num4 = 0f;
		float num5 = longList[num2];
		float num6 = longList[num2 + 1];
		for (int i = 0; i < array.Length; i++)
		{
			float num7 = (float)i / (float)options.frequencyRate;
			if (num7 > longList[num2])
			{
				num4 = longList[num2];
				num2 += 2;
				num3 = longList[num2] - longList[num2 - 2];
				num6 = longList[num2 + 1];
			}
			num5 = num7 - num4;
			float num8 = num5 / num3;
			float num9 = Mathf.Sin(num8 * (float)Math.PI);
			if (options.waveStyle == LeanAudioOptions.LeanAudioWaveStyle.Square)
			{
				if (num9 > 0f)
				{
					num9 = 1f;
				}
				if (num9 < 0f)
				{
					num9 = -1f;
				}
			}
			else if (options.waveStyle == LeanAudioOptions.LeanAudioWaveStyle.Sawtooth)
			{
				float num10 = ((!(num9 > 0f)) ? (-1f) : 1f);
				num9 = ((!(num8 < 0.5f)) ? ((1f - num8) * 2f * num10) : (num8 * 2f * num10));
			}
			else if (options.waveStyle == LeanAudioOptions.LeanAudioWaveStyle.Noise)
			{
				float num11 = 1f - options.waveNoiseInfluence + Mathf.PerlinNoise(0f, num7 * options.waveNoiseScale) * options.waveNoiseInfluence;
				num9 *= num11;
			}
			num9 *= num6;
			if (options.modulation != null)
			{
				for (int j = 0; j < options.modulation.Length; j++)
				{
					float num12 = Mathf.Abs(Mathf.Sin(1.5708f + num7 * (1f / options.modulation[j][0]) * (float)Math.PI));
					float num13 = 1f - options.modulation[j][1];
					num12 = options.modulation[j][1] + num13 * num12;
					num9 *= num12;
				}
			}
			array[i] = num9;
		}
		int lengthSamples = array.Length;
		AudioClip audioClip = null;
		if (options.useSetData)
		{
			audioClip = AudioClip.Create("Generated Audio", lengthSamples, 1, options.frequencyRate, stream: false, null, OnAudioSetPosition);
			audioClip.SetData(array, 0);
		}
		else
		{
			options.stream = new LeanAudioStream(array);
			audioClip = AudioClip.Create("Generated Audio", lengthSamples, 1, options.frequencyRate, stream: false, options.stream.OnAudioRead, options.stream.OnAudioSetPosition);
			options.stream.audioClip = audioClip;
		}
		return audioClip;
	}

	private static void OnAudioSetPosition(int newPosition)
	{
	}

	public static AudioClip generateAudioFromCurve(AnimationCurve curve, int frequencyRate = 44100)
	{
		float time = curve[curve.length - 1].time;
		float num = time;
		float[] array = new float[(int)((float)frequencyRate * num)];
		for (int i = 0; i < array.Length; i++)
		{
			float time2 = (float)i / (float)frequencyRate;
			array[i] = curve.Evaluate(time2);
		}
		int lengthSamples = array.Length;
		AudioClip audioClip = AudioClip.Create("Generated Audio", lengthSamples, 1, frequencyRate, stream: false);
		audioClip.SetData(array, 0);
		return audioClip;
	}

	public static AudioSource play(AudioClip audio, float volume)
	{
		AudioSource audioSource = playClipAt(audio, Vector3.zero);
		audioSource.volume = volume;
		return audioSource;
	}

	public static AudioSource play(AudioClip audio)
	{
		return playClipAt(audio, Vector3.zero);
	}

	public static AudioSource play(AudioClip audio, Vector3 pos)
	{
		return playClipAt(audio, pos);
	}

	public static AudioSource play(AudioClip audio, Vector3 pos, float volume)
	{
		AudioSource audioSource = playClipAt(audio, pos);
		audioSource.minDistance = 1f;
		audioSource.volume = volume;
		return audioSource;
	}

	public static AudioSource playClipAt(AudioClip clip, Vector3 pos)
	{
		GameObject gameObject = new GameObject();
		gameObject.transform.position = pos;
		AudioSource audioSource = gameObject.AddComponent<AudioSource>();
		audioSource.clip = clip;
		audioSource.Play();
		UnityEngine.Object.Destroy(gameObject, clip.length);
		return audioSource;
	}

	public static void printOutAudioClip(AudioClip audioClip, ref AnimationCurve curve, float scaleX = 1f)
	{
		float[] array = new float[audioClip.samples * audioClip.channels];
		audioClip.GetData(array, 0);
		int i = 0;
		Keyframe[] array2 = new Keyframe[array.Length];
		for (; i < array.Length; i++)
		{
			ref Keyframe reference = ref array2[i];
			reference = new Keyframe((float)i * scaleX, array[i]);
		}
		curve = new AnimationCurve(array2);
	}
}
public class LeanAudioOptions
{
	public enum LeanAudioWaveStyle
	{
		Sine,
		Square,
		Sawtooth,
		Noise
	}

	public LeanAudioWaveStyle waveStyle;

	public Vector3[] vibrato;

	public Vector3[] modulation;

	public int frequencyRate = 44100;

	public float waveNoiseScale = 1000f;

	public float waveNoiseInfluence = 1f;

	public bool useSetData = true;

	public LeanAudioStream stream;

	public LeanAudioOptions setFrequency(int frequencyRate)
	{
		this.frequencyRate = frequencyRate;
		return this;
	}

	public LeanAudioOptions setVibrato(Vector3[] vibrato)
	{
		this.vibrato = vibrato;
		return this;
	}

	public LeanAudioOptions setWaveSine()
	{
		waveStyle = LeanAudioWaveStyle.Sine;
		return this;
	}

	public LeanAudioOptions setWaveSquare()
	{
		waveStyle = LeanAudioWaveStyle.Square;
		return this;
	}

	public LeanAudioOptions setWaveSawtooth()
	{
		waveStyle = LeanAudioWaveStyle.Sawtooth;
		return this;
	}

	public LeanAudioOptions setWaveNoise()
	{
		waveStyle = LeanAudioWaveStyle.Noise;
		return this;
	}

	public LeanAudioOptions setWaveStyle(LeanAudioWaveStyle style)
	{
		waveStyle = style;
		return this;
	}

	public LeanAudioOptions setWaveNoiseScale(float waveScale)
	{
		waveNoiseScale = waveScale;
		return this;
	}

	public LeanAudioOptions setWaveNoiseInfluence(float influence)
	{
		waveNoiseInfluence = influence;
		return this;
	}
}
public class LeanSmooth
{
	public static float damp(float current, float target, ref float currentVelocity, float smoothTime, float maxSpeed = -1f, float deltaTime = -1f)
	{
		if (deltaTime < 0f)
		{
			deltaTime = Time.deltaTime;
		}
		smoothTime = Mathf.Max(0.0001f, smoothTime);
		float num = 2f / smoothTime;
		float num2 = num * deltaTime;
		float num3 = 1f / (1f + num2 + 0.48f * num2 * num2 + 0.235f * num2 * num2 * num2);
		float num4 = current - target;
		float num5 = target;
		if (maxSpeed > 0f)
		{
			float num6 = maxSpeed * smoothTime;
			num4 = Mathf.Clamp(num4, 0f - num6, num6);
		}
		target = current - num4;
		float num7 = (currentVelocity + num * num4) * deltaTime;
		currentVelocity = (currentVelocity - num * num7) * num3;
		float num8 = target + (num4 + num7) * num3;
		if (num5 - current > 0f == num8 > num5)
		{
			num8 = num5;
			currentVelocity = (num8 - num5) / deltaTime;
		}
		return num8;
	}

	public static Vector3 damp(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime, float maxSpeed = -1f, float deltaTime = -1f)
	{
		float x = damp(current.x, target.x, ref currentVelocity.x, smoothTime, maxSpeed, deltaTime);
		float y = damp(current.y, target.y, ref currentVelocity.y, smoothTime, maxSpeed, deltaTime);
		float z = damp(current.z, target.z, ref currentVelocity.z, smoothTime, maxSpeed, deltaTime);
		return new Vector3(x, y, z);
	}

	public static Color damp(Color current, Color target, ref Color currentVelocity, float smoothTime, float maxSpeed = -1f, float deltaTime = -1f)
	{
		float r = damp(current.r, target.r, ref currentVelocity.r, smoothTime, maxSpeed, deltaTime);
		float g = damp(current.g, target.g, ref currentVelocity.g, smoothTime, maxSpeed, deltaTime);
		float b = damp(current.b, target.b, ref currentVelocity.b, smoothTime, maxSpeed, deltaTime);
		float a = damp(current.a, target.a, ref currentVelocity.a, smoothTime, maxSpeed, deltaTime);
		return new Color(r, g, b, a);
	}

	public static float spring(float current, float target, ref float currentVelocity, float smoothTime, float maxSpeed = -1f, float deltaTime = -1f, float friction = 2f, float accelRate = 0.5f)
	{
		if (deltaTime < 0f)
		{
			deltaTime = Time.deltaTime;
		}
		float num = target - current;
		currentVelocity += deltaTime / smoothTime * accelRate * num;
		currentVelocity *= 1f - deltaTime * friction;
		if (maxSpeed > 0f && maxSpeed < Mathf.Abs(currentVelocity))
		{
			currentVelocity = maxSpeed * Mathf.Sign(currentVelocity);
		}
		return current + currentVelocity;
	}

	public static Vector3 spring(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime, float maxSpeed = -1f, float deltaTime = -1f, float friction = 2f, float accelRate = 0.5f)
	{
		float x = spring(current.x, target.x, ref currentVelocity.x, smoothTime, maxSpeed, deltaTime, friction, accelRate);
		float y = spring(current.y, target.y, ref currentVelocity.y, smoothTime, maxSpeed, deltaTime, friction, accelRate);
		float z = spring(current.z, target.z, ref currentVelocity.z, smoothTime, maxSpeed, deltaTime, friction, accelRate);
		return new Vector3(x, y, z);
	}

	public static Color spring(Color current, Color target, ref Color currentVelocity, float smoothTime, float maxSpeed = -1f, float deltaTime = -1f, float friction = 2f, float accelRate = 0.5f)
	{
		float r = spring(current.r, target.r, ref currentVelocity.r, smoothTime, maxSpeed, deltaTime, friction, accelRate);
		float g = spring(current.g, target.g, ref currentVelocity.g, smoothTime, maxSpeed, deltaTime, friction, accelRate);
		float b = spring(current.b, target.b, ref currentVelocity.b, smoothTime, maxSpeed, deltaTime, friction, accelRate);
		float a = spring(current.a, target.a, ref currentVelocity.a, smoothTime, maxSpeed, deltaTime, friction, accelRate);
		return new Color(r, g, b, a);
	}

	public static float linear(float current, float target, float moveSpeed, float deltaTime = -1f)
	{
		if (deltaTime < 0f)
		{
			deltaTime = Time.deltaTime;
		}
		bool flag = target > current;
		float num = deltaTime * moveSpeed * ((!flag) ? (-1f) : 1f);
		float num2 = current + num;
		float num3 = num2 - target;
		if ((flag && num3 > 0f) || (!flag && num3 < 0f))
		{
			return target;
		}
		return num2;
	}

	public static Vector3 linear(Vector3 current, Vector3 target, float moveSpeed, float deltaTime = -1f)
	{
		float x = linear(current.x, target.x, moveSpeed, deltaTime);
		float y = linear(current.y, target.y, moveSpeed, deltaTime);
		float z = linear(current.z, target.z, moveSpeed, deltaTime);
		return new Vector3(x, y, z);
	}

	public static Color linear(Color current, Color target, float moveSpeed)
	{
		float r = linear(current.r, target.r, moveSpeed);
		float g = linear(current.g, target.g, moveSpeed);
		float b = linear(current.b, target.b, moveSpeed);
		float a = linear(current.a, target.a, moveSpeed);
		return new Color(r, g, b, a);
	}

	public static float bounceOut(float current, float target, ref float currentVelocity, float smoothTime, float maxSpeed = -1f, float deltaTime = -1f, float friction = 2f, float accelRate = 0.5f, float hitDamping = 0.9f)
	{
		if (deltaTime < 0f)
		{
			deltaTime = Time.deltaTime;
		}
		float num = target - current;
		currentVelocity += deltaTime / smoothTime * accelRate * num;
		currentVelocity *= 1f - deltaTime * friction;
		if (maxSpeed > 0f && maxSpeed < Mathf.Abs(currentVelocity))
		{
			currentVelocity = maxSpeed * Mathf.Sign(currentVelocity);
		}
		float num2 = current + currentVelocity;
		bool flag = target > current;
		float num3 = num2 - target;
		if ((flag && num3 > 0f) || (!flag && num3 < 0f))
		{
			currentVelocity = (0f - currentVelocity) * hitDamping;
			num2 = current + currentVelocity;
		}
		return num2;
	}

	public static Vector3 bounceOut(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime, float maxSpeed = -1f, float deltaTime = -1f, float friction = 2f, float accelRate = 0.5f, float hitDamping = 0.9f)
	{
		float x = bounceOut(current.x, target.x, ref currentVelocity.x, smoothTime, maxSpeed, deltaTime, friction, accelRate, hitDamping);
		float y = bounceOut(current.y, target.y, ref currentVelocity.y, smoothTime, maxSpeed, deltaTime, friction, accelRate, hitDamping);
		float z = bounceOut(current.z, target.z, ref currentVelocity.z, smoothTime, maxSpeed, deltaTime, friction, accelRate, hitDamping);
		return new Vector3(x, y, z);
	}

	public static Color bounceOut(Color current, Color target, ref Color currentVelocity, float smoothTime, float maxSpeed = -1f, float deltaTime = -1f, float friction = 2f, float accelRate = 0.5f, float hitDamping = 0.9f)
	{
		float r = bounceOut(current.r, target.r, ref currentVelocity.r, smoothTime, maxSpeed, deltaTime, friction, accelRate, hitDamping);
		float g = bounceOut(current.g, target.g, ref currentVelocity.g, smoothTime, maxSpeed, deltaTime, friction, accelRate, hitDamping);
		float b = bounceOut(current.b, target.b, ref currentVelocity.b, smoothTime, maxSpeed, deltaTime, friction, accelRate, hitDamping);
		float a = bounceOut(current.a, target.a, ref currentVelocity.a, smoothTime, maxSpeed, deltaTime, friction, accelRate, hitDamping);
		return new Color(r, g, b, a);
	}
}
public class LeanTester : MonoBehaviour
{
	public float timeout = 15f;

	public void Start()
	{
		StartCoroutine(timeoutCheck());
	}

	private IEnumerator timeoutCheck()
	{
		float pauseEndTime = Time.realtimeSinceStartup + timeout;
		while (Time.realtimeSinceStartup < pauseEndTime)
		{
			yield return 0;
		}
		if (!LeanTest.testsFinished)
		{
			UnityEngine.Debug.Log(LeanTest.formatB("Tests timed out!"));
			LeanTest.overview();
		}
	}
}
public class LeanTest
{
	public static int expected;

	private static int tests;

	private static int passes;

	public static float timeout = 15f;

	public static bool timeoutStarted;

	public static bool testsFinished;

	public static void debug(string name, bool didPass, string failExplaination = null)
	{
		expect(didPass, name, failExplaination);
	}

	public static void expect(bool didPass, string definition, string failExplaination = null)
	{
		float num = printOutLength(definition);
		int totalWidth = 40 - (int)(num * 1.05f);
		string text = string.Empty.PadRight(totalWidth, "_"[0]);
		string text2 = formatB(definition) + " " + text + " [ " + ((!didPass) ? formatC("fail", "red") : formatC("pass", "green")) + " ]";
		if (!didPass && failExplaination != null)
		{
			text2 = text2 + " - " + failExplaination;
		}
		UnityEngine.Debug.Log(text2);
		if (didPass)
		{
			passes++;
		}
		tests++;
		if (tests == expected && !testsFinished)
		{
			overview();
		}
		else if (tests > expected)
		{
			UnityEngine.Debug.Log(formatB("Too many tests for a final report!") + " set LeanTest.expected = " + tests);
		}
		if (!timeoutStarted)
		{
			timeoutStarted = true;
			GameObject gameObject = new GameObject();
			gameObject.name = "~LeanTest";
			LeanTester leanTester = gameObject.AddComponent(typeof(LeanTester)) as LeanTester;
			leanTester.timeout = timeout;
			gameObject.hideFlags = HideFlags.HideAndDontSave;
		}
	}

	public static string padRight(int len)
	{
		string text = string.Empty;
		for (int i = 0; i < len; i++)
		{
			text += "_";
		}
		return text;
	}

	public static float printOutLength(string str)
	{
		float num = 0f;
		for (int i = 0; i < str.Length; i++)
		{
			num = ((str[i] != "I"[0]) ? ((str[i] != "J"[0]) ? (num + 1f) : (num + 0.85f)) : (num + 0.5f));
		}
		return num;
	}

	public static string formatBC(string str, string color)
	{
		return formatC(formatB(str), color);
	}

	public static string formatB(string str)
	{
		return "<b>" + str + "</b>";
	}

	public static string formatC(string str, string color)
	{
		return "<color=" + color + ">" + str + "</color>";
	}

	public static void overview()
	{
		testsFinished = true;
		int num = expected - passes;
		string text = ((num <= 0) ? (string.Empty + num) : formatBC(string.Empty + num, "red"));
		UnityEngine.Debug.Log(formatB("Final Report:") + " _____________________ PASSED: " + formatBC(string.Empty + passes, "green") + " FAILED: " + text + " ");
	}
}
public enum TweenAction
{
	MOVE_X,
	MOVE_Y,
	MOVE_Z,
	MOVE_LOCAL_X,
	MOVE_LOCAL_Y,
	MOVE_LOCAL_Z,
	MOVE_CURVED,
	MOVE_CURVED_LOCAL,
	MOVE_SPLINE,
	MOVE_SPLINE_LOCAL,
	SCALE_X,
	SCALE_Y,
	SCALE_Z,
	ROTATE_X,
	ROTATE_Y,
	ROTATE_Z,
	ROTATE_AROUND,
	ROTATE_AROUND_LOCAL,
	CANVAS_ROTATEAROUND,
	CANVAS_ROTATEAROUND_LOCAL,
	CANVAS_PLAYSPRITE,
	ALPHA,
	TEXT_ALPHA,
	CANVAS_ALPHA,
	CANVASGROUP_ALPHA,
	ALPHA_VERTEX,
	COLOR,
	CALLBACK_COLOR,
	TEXT_COLOR,
	CANVAS_COLOR,
	CANVAS_MOVE_X,
	CANVAS_MOVE_Y,
	CANVAS_MOVE_Z,
	CALLBACK,
	MOVE,
	MOVE_LOCAL,
	MOVE_TO_TRANSFORM,
	ROTATE,
	ROTATE_LOCAL,
	SCALE,
	VALUE3,
	GUI_MOVE,
	GUI_MOVE_MARGIN,
	GUI_SCALE,
	GUI_ALPHA,
	GUI_ROTATE,
	DELAYED_SOUND,
	CANVAS_MOVE,
	CANVAS_SCALE,
	CANVAS_SIZEDELTA,
	FOLLOW
}
public enum LeanTweenType
{
	notUsed,
	linear,
	easeOutQuad,
	easeInQuad,
	easeInOutQuad,
	easeInCubic,
	easeOutCubic,
	easeInOutCubic,
	easeInQuart,
	easeOutQuart,
	easeInOutQuart,
	easeInQuint,
	easeOutQuint,
	easeInOutQuint,
	easeInSine,
	easeOutSine,
	easeInOutSine,
	easeInExpo,
	easeOutExpo,
	easeInOutExpo,
	easeInCirc,
	easeOutCirc,
	easeInOutCirc,
	easeInBounce,
	easeOutBounce,
	easeInOutBounce,
	easeInBack,
	easeOutBack,
	easeInOutBack,
	easeInElastic,
	easeOutElastic,
	easeInOutElastic,
	easeSpring,
	easeShake,
	punch,
	once,
	clamp,
	pingPong,
	animationCurve
}
public enum LeanProp
{
	position,
	localPosition,
	x,
	y,
	z,
	localX,
	localY,
	localZ,
	scale,
	color
}
public class LeanTween : MonoBehaviour
{
	public static bool throwErrors = true;

	public static float tau = (float)Math.PI * 2f;

	public static float PI_DIV2 = (float)Math.PI / 2f;

	private static LTSeq[] sequences;

	private static LTDescr[] tweens;

	private static int[] tweensFinished;

	private static int[] tweensFinishedIds;

	private static LTDescr tween;

	private static int tweenMaxSearch = -1;

	private static int maxTweens = 400;

	private static int maxSequences = 400;

	private static int frameRendered = -1;

	private static GameObject _tweenEmpty;

	public static float dtEstimated = -1f;

	public static float dtManual;

	public static float dtActual;

	private static uint global_counter = 0u;

	private static int i;

	private static int j;

	private static int finishedCnt;

	public static AnimationCurve punch = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.112586f, 0.9976035f), new Keyframe(0.3120486f, -0.1720615f), new Keyframe(0.4316337f, 0.07030682f), new Keyframe(0.5524869f, -0.03141804f), new Keyframe(0.6549395f, 0.003909959f), new Keyframe(0.770987f, -0.009817753f), new Keyframe(0.8838775f, 0.001939224f), new Keyframe(1f, 0f));

	public static AnimationCurve shake = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.25f, 1f), new Keyframe(0.75f, -1f), new Keyframe(1f, 0f));

	private static int maxTweenReached;

	public static int startSearch = 0;

	public static LTDescr d;

	private static Action<LTEvent>[] eventListeners;

	private static GameObject[] goListeners;

	private static int eventsMaxSearch = 0;

	public static int EVENTS_MAX = 10;

	public static int LISTENERS_MAX = 10;

	private static int INIT_LISTENERS_MAX = LISTENERS_MAX;

	public static int maxSearch => tweenMaxSearch;

	public static int maxSimulataneousTweens => maxTweens;

	public static int tweensRunning
	{
		get
		{
			int num = 0;
			for (int i = 0; i <= tweenMaxSearch; i++)
			{
				if (tweens[i].toggle)
				{
					num++;
				}
			}
			return num;
		}
	}

	public static GameObject tweenEmpty
	{
		get
		{
			init(maxTweens);
			return _tweenEmpty;
		}
	}

	public static void init()
	{
		init(maxTweens);
	}

	public static void init(int maxSimultaneousTweens)
	{
		init(maxSimultaneousTweens, maxSequences);
	}

	public static void init(int maxSimultaneousTweens, int maxSimultaneousSequences)
	{
		if (tweens == null)
		{
			maxTweens = maxSimultaneousTweens;
			tweens = new LTDescr[maxTweens];
			tweensFinished = new int[maxTweens];
			tweensFinishedIds = new int[maxTweens];
			_tweenEmpty = new GameObject();
			_tweenEmpty.name = "~LeanTween";
			_tweenEmpty.AddComponent(typeof(LeanTween));
			_tweenEmpty.isStatic = true;
			_tweenEmpty.hideFlags = HideFlags.HideAndDontSave;
			UnityEngine.Object.DontDestroyOnLoad(_tweenEmpty);
			for (int i = 0; i < maxTweens; i++)
			{
				tweens[i] = new LTDescr();
			}
			SceneManager.sceneLoaded += onLevelWasLoaded54;
			sequences = new LTSeq[maxSimultaneousSequences];
			for (int j = 0; j < maxSimultaneousSequences; j++)
			{
				sequences[j] = new LTSeq();
			}
		}
	}

	public static void reset()
	{
		if (tweens != null)
		{
			for (int i = 0; i <= tweenMaxSearch; i++)
			{
				if (tweens[i] != null)
				{
					tweens[i].toggle = false;
				}
			}
		}
		tweens = null;
		UnityEngine.Object.Destroy(_tweenEmpty);
	}

	public void Update()
	{
		update();
	}

	private static void onLevelWasLoaded54(Scene scene, LoadSceneMode mode)
	{
		internalOnLevelWasLoaded(scene.buildIndex);
	}

	private static void internalOnLevelWasLoaded(int lvl)
	{
		LTGUI.reset();
	}

	public static void update()
	{
		if (frameRendered == Time.frameCount)
		{
			return;
		}
		init();
		dtEstimated = ((dtEstimated < 0f) ? 0f : (dtEstimated = Time.unscaledDeltaTime));
		dtActual = Time.deltaTime;
		maxTweenReached = 0;
		finishedCnt = 0;
		for (int i = 0; i <= tweenMaxSearch && i < maxTweens; i++)
		{
			tween = tweens[i];
			if (tween.toggle)
			{
				maxTweenReached = i;
				if (tween.updateInternal())
				{
					tweensFinished[finishedCnt] = i;
					tweensFinishedIds[finishedCnt] = tweens[i].id;
					finishedCnt++;
				}
			}
		}
		tweenMaxSearch = maxTweenReached;
		frameRendered = Time.frameCount;
		for (int j = 0; j < finishedCnt; j++)
		{
			LeanTween.j = tweensFinished[j];
			tween = tweens[LeanTween.j];
			if (tween.id == tweensFinishedIds[j])
			{
				removeTween(LeanTween.j);
				if (tween.hasExtraOnCompletes && tween.trans != null)
				{
					tween.callOnCompletes();
				}
			}
		}
	}

	public static void removeTween(int i, int uniqueId)
	{
		if (tweens[i].uniqueId == uniqueId)
		{
			removeTween(i);
		}
	}

	public static void removeTween(int i)
	{
		if (!tweens[i].toggle)
		{
			return;
		}
		tweens[i].toggle = false;
		tweens[i].counter = uint.MaxValue;
		if (tweens[i].destroyOnComplete)
		{
			if (tweens[i]._optional.ltRect != null)
			{
				LTGUI.destroy(tweens[i]._optional.ltRect.id);
			}
			else if (tweens[i].trans != null && tweens[i].trans.gameObject != _tweenEmpty)
			{
				UnityEngine.Object.Destroy(tweens[i].trans.gameObject);
			}
		}
		startSearch = i;
		if (i + 1 >= tweenMaxSearch)
		{
			startSearch = 0;
		}
	}

	public static Vector3[] add(Vector3[] a, Vector3 b)
	{
		Vector3[] array = new Vector3[a.Length];
		for (i = 0; i < a.Length; i++)
		{
			ref Vector3 reference = ref array[i];
			reference = a[i] + b;
		}
		return array;
	}

	public static float closestRot(float from, float to)
	{
		float num = 0f - (360f - to);
		float num2 = 360f + to;
		float num3 = Mathf.Abs(to - from);
		float num4 = Mathf.Abs(num - from);
		float num5 = Mathf.Abs(num2 - from);
		if (num3 < num4 && num3 < num5)
		{
			return to;
		}
		if (num4 < num5)
		{
			return num;
		}
		return num2;
	}

	public static void cancelAll()
	{
		cancelAll(callComplete: false);
	}

	public static void cancelAll(bool callComplete)
	{
		init();
		for (int i = 0; i <= tweenMaxSearch; i++)
		{
			if (tweens[i].trans != null)
			{
				if (callComplete && tweens[i].optional.onComplete != null)
				{
					tweens[i].optional.onComplete();
				}
				removeTween(i);
			}
		}
	}

	public static void cancel(GameObject gameObject)
	{
		cancel(gameObject, callOnComplete: false);
	}

	public static void cancel(GameObject gameObject, bool callOnComplete)
	{
		init();
		Transform transform = gameObject.transform;
		for (int i = 0; i <= tweenMaxSearch; i++)
		{
			LTDescr lTDescr = tweens[i];
			if (lTDescr != null && lTDescr.toggle && lTDescr.trans == transform)
			{
				if (callOnComplete && lTDescr.optional.onComplete != null)
				{
					lTDescr.optional.onComplete();
				}
				removeTween(i);
			}
		}
	}

	public static void cancel(RectTransform rect)
	{
		cancel(rect.gameObject, callOnComplete: false);
	}

	public static void cancel(GameObject gameObject, int uniqueId, bool callOnComplete = false)
	{
		if (uniqueId < 0)
		{
			return;
		}
		init();
		int num = uniqueId & 0xFFFF;
		int num2 = uniqueId >> 16;
		if (tweens[num].trans == null || (tweens[num].trans.gameObject == gameObject && tweens[num].counter == num2))
		{
			if (callOnComplete && tweens[num].optional.onComplete != null)
			{
				tweens[num].optional.onComplete();
			}
			removeTween(num);
		}
	}

	public static void cancel(LTRect ltRect, int uniqueId)
	{
		if (uniqueId >= 0)
		{
			init();
			int num = uniqueId & 0xFFFF;
			int num2 = uniqueId >> 16;
			if (tweens[num]._optional.ltRect == ltRect && tweens[num].counter == num2)
			{
				removeTween(num);
			}
		}
	}

	public static void cancel(int uniqueId)
	{
		cancel(uniqueId, callOnComplete: false);
	}

	public static void cancel(int uniqueId, bool callOnComplete)
	{
		if (uniqueId < 0)
		{
			return;
		}
		init();
		int num = uniqueId & 0xFFFF;
		int num2 = uniqueId >> 16;
		if (num > tweens.Length - 1)
		{
			int num3 = num - tweens.Length;
			LTSeq lTSeq = sequences[num3];
			for (int i = 0; i < maxSequences; i++)
			{
				if (lTSeq.current.tween != null)
				{
					int uniqueId2 = lTSeq.current.tween.uniqueId;
					int num4 = uniqueId2 & 0xFFFF;
					removeTween(num4);
				}
				if (lTSeq.current.previous == null)
				{
					break;
				}
				lTSeq.current = lTSeq.current.previous;
			}
		}
		else if (tweens[num].counter == num2)
		{
			if (callOnComplete && tweens[num].optional.onComplete != null)
			{
				tweens[num].optional.onComplete();
			}
			removeTween(num);
		}
	}

	public static LTDescr descr(int uniqueId)
	{
		init();
		int num = uniqueId & 0xFFFF;
		int num2 = uniqueId >> 16;
		if (tweens[num] != null && tweens[num].uniqueId == uniqueId && tweens[num].counter == num2)
		{
			return tweens[num];
		}
		for (int i = 0; i <= tweenMaxSearch; i++)
		{
			if (tweens[i].uniqueId == uniqueId && tweens[i].counter == num2)
			{
				return tweens[i];
			}
		}
		return null;
	}

	public static LTDescr description(int uniqueId)
	{
		return descr(uniqueId);
	}

	public static LTDescr[] descriptions(GameObject gameObject = null)
	{
		if (gameObject == null)
		{
			return null;
		}
		List<LTDescr> list = new List<LTDescr>();
		Transform transform = gameObject.transform;
		for (int i = 0; i <= tweenMaxSearch; i++)
		{
			if (tweens[i].toggle && tweens[i].trans == transform)
			{
				list.Add(tweens[i]);
			}
		}
		return list.ToArray();
	}

	[Obsolete("Use 'pause( id )' instead")]
	public static void pause(GameObject gameObject, int uniqueId)
	{
		pause(uniqueId);
	}

	public static void pause(int uniqueId)
	{
		int num = uniqueId & 0xFFFF;
		int num2 = uniqueId >> 16;
		if (tweens[num].counter == num2)
		{
			tweens[num].pause();
		}
	}

	public static void pause(GameObject gameObject)
	{
		Transform transform = gameObject.transform;
		for (int i = 0; i <= tweenMaxSearch; i++)
		{
			if (tweens[i].trans == transform)
			{
				tweens[i].pause();
			}
		}
	}

	public static void pauseAll()
	{
		init();
		for (int i = 0; i <= tweenMaxSearch; i++)
		{
			tweens[i].pause();
		}
	}

	public static void resumeAll()
	{
		init();
		for (int i = 0; i <= tweenMaxSearch; i++)
		{
			tweens[i].resume();
		}
	}

	[Obsolete("Use 'resume( id )' instead")]
	public static void resume(GameObject gameObject, int uniqueId)
	{
		resume(uniqueId);
	}

	public static void resume(int uniqueId)
	{
		int num = uniqueId & 0xFFFF;
		int num2 = uniqueId >> 16;
		if (tweens[num].counter == num2)
		{
			tweens[num].resume();
		}
	}

	public static void resume(GameObject gameObject)
	{
		Transform transform = gameObject.transform;
		for (int i = 0; i <= tweenMaxSearch; i++)
		{
			if (tweens[i].trans == transform)
			{
				tweens[i].resume();
			}
		}
	}

	public static bool isPaused(GameObject gameObject = null)
	{
		if (gameObject == null)
		{
			for (int i = 0; i <= tweenMaxSearch; i++)
			{
				if (object.Equals(tweens[i].direction, 0f))
				{
					return true;
				}
			}
			return false;
		}
		Transform transform = gameObject.transform;
		for (int j = 0; j <= tweenMaxSearch; j++)
		{
			if (object.Equals(tweens[j].direction, 0f) && tweens[j].trans == transform)
			{
				return true;
			}
		}
		return false;
	}

	public static bool isPaused(RectTransform rect)
	{
		return isTweening(rect.gameObject);
	}

	public static bool isPaused(int uniqueId)
	{
		int num = uniqueId & 0xFFFF;
		int num2 = uniqueId >> 16;
		if (num < 0 || num >= maxTweens)
		{
			return false;
		}
		if (tweens[num].counter == num2 && object.Equals(tweens[i].direction, 0f))
		{
			return true;
		}
		return false;
	}

	public static bool isTweening(GameObject gameObject = null)
	{
		if (gameObject == null)
		{
			for (int i = 0; i <= tweenMaxSearch; i++)
			{
				if (tweens[i].toggle)
				{
					return true;
				}
			}
			return false;
		}
		Transform transform = gameObject.transform;
		for (int j = 0; j <= tweenMaxSearch; j++)
		{
			if (tweens[j].toggle && tweens[j].trans == transform)
			{
				return true;
			}
		}
		return false;
	}

	public static bool isTweening(RectTransform rect)
	{
		return isTweening(rect.gameObject);
	}

	public static bool isTweening(int uniqueId)
	{
		int num = uniqueId & 0xFFFF;
		int num2 = uniqueId >> 16;
		if (num < 0 || num >= maxTweens)
		{
			return false;
		}
		if (tweens[num].counter == num2 && tweens[num].toggle)
		{
			return true;
		}
		return false;
	}

	public static bool isTweening(LTRect ltRect)
	{
		for (int i = 0; i <= tweenMaxSearch; i++)
		{
			if (tweens[i].toggle && tweens[i]._optional.ltRect == ltRect)
			{
				return true;
			}
		}
		return false;
	}

	public static void drawBezierPath(Vector3 a, Vector3 b, Vector3 c, Vector3 d, float arrowSize = 0f, Transform arrowTransform = null)
	{
		Vector3 vector = a;
		Vector3 vector2 = -a + 3f * (b - c) + d;
		Vector3 vector3 = 3f * (a + c) - 6f * b;
		Vector3 vector4 = 3f * (b - a);
		if (arrowSize > 0f)
		{
			Vector3 position = arrowTransform.position;
			Quaternion rotation = arrowTransform.rotation;
			float num = 0f;
			for (float num2 = 1f; num2 <= 120f; num2 += 1f)
			{
				float num3 = num2 / 120f;
				Vector3 vector5 = ((vector2 * num3 + vector3) * num3 + vector4) * num3 + a;
				Gizmos.DrawLine(vector, vector5);
				num += (vector5 - vector).magnitude;
				if (num > 1f)
				{
					num -= 1f;
					arrowTransform.position = vector5;
					arrowTransform.LookAt(vector, Vector3.forward);
					Vector3 vector6 = arrowTransform.TransformDirection(Vector3.right);
					Vector3 normalized = (vector - vector5).normalized;
					Gizmos.DrawLine(vector5, vector5 + (vector6 + normalized) * arrowSize);
					vector6 = arrowTransform.TransformDirection(-Vector3.right);
					Gizmos.DrawLine(vector5, vector5 + (vector6 + normalized) * arrowSize);
				}
				vector = vector5;
			}
			arrowTransform.position = position;
			arrowTransform.rotation = rotation;
		}
		else
		{
			for (float num4 = 1f; num4 <= 30f; num4 += 1f)
			{
				float num3 = num4 / 30f;
				Vector3 vector5 = ((vector2 * num3 + vector3) * num3 + vector4) * num3 + a;
				Gizmos.DrawLine(vector, vector5);
				vector = vector5;
			}
		}
	}

	public static object logError(string error)
	{
		if (throwErrors)
		{
			UnityEngine.Debug.LogError(error);
		}
		else
		{
			UnityEngine.Debug.Log(error);
		}
		return null;
	}

	public static LTDescr options(LTDescr seed)
	{
		UnityEngine.Debug.LogError("error this function is no longer used");
		return null;
	}

	public static LTDescr options()
	{
		init();
		bool flag = false;
		j = 0;
		i = startSearch;
		while (j <= maxTweens)
		{
			if (j >= maxTweens)
			{
				return logError("LeanTween - You have run out of available spaces for tweening. To avoid this error increase the number of spaces to available for tweening when you initialize the LeanTween class ex: LeanTween.init( " + maxTweens * 2 + " );") as LTDescr;
			}
			if (i >= maxTweens)
			{
				i = 0;
			}
			if (!tweens[i].toggle)
			{
				if (i + 1 > tweenMaxSearch && i + 1 < maxTweens)
				{
					tweenMaxSearch = i + 1;
				}
				startSearch = i + 1;
				flag = true;
				break;
			}
			j++;
			i++;
		}
		if (!flag)
		{
			logError("no available tween found!");
		}
		tweens[i].reset();
		global_counter++;
		if (global_counter > 32768)
		{
			global_counter = 0u;
		}
		tweens[i].setId((uint)i, global_counter);
		return tweens[i];
	}

	private static LTDescr pushNewTween(GameObject gameObject, Vector3 to, float time, LTDescr tween)
	{
		init(maxTweens);
		if (gameObject == null || tween == null)
		{
			return null;
		}
		tween.trans = gameObject.transform;
		tween.to = to;
		tween.time = time;
		if (tween.time <= 0f)
		{
			tween.updateInternal();
		}
		return tween;
	}

	public static LTDescr play(RectTransform rectTransform, Sprite[] sprites)
	{
		float num = 0.25f;
		float time = num * (float)sprites.Length;
		return pushNewTween(rectTransform.gameObject, new Vector3((float)sprites.Length - 1f, 0f, 0f), time, options().setCanvasPlaySprite().setSprites(sprites).setRepeat(-1));
	}

	public static LTSeq sequence(bool initSequence = true)
	{
		init(maxTweens);
		for (int i = 0; i < sequences.Length; i++)
		{
			if ((sequences[i].tween != null && sequences[i].tween.toggle) || sequences[i].toggle)
			{
				continue;
			}
			LTSeq lTSeq = sequences[i];
			if (initSequence)
			{
				lTSeq.init((uint)(i + tweens.Length), global_counter);
				global_counter++;
				if (global_counter > 32768)
				{
					global_counter = 0u;
				}
			}
			else
			{
				lTSeq.reset();
			}
			return lTSeq;
		}
		return null;
	}

	public static LTDescr alpha(GameObject gameObject, float to, float time)
	{
		LTDescr lTDescr = pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setAlpha());
		SpriteRenderer component = gameObject.GetComponent<SpriteRenderer>();
		lTDescr.spriteRen = component;
		return lTDescr;
	}

	public static LTDescr alpha(LTRect ltRect, float to, float time)
	{
		ltRect.alphaEnabled = true;
		return pushNewTween(tweenEmpty, new Vector3(to, 0f, 0f), time, options().setGUIAlpha().setRect(ltRect));
	}

	public static LTDescr textAlpha(RectTransform rectTransform, float to, float time)
	{
		return pushNewTween(rectTransform.gameObject, new Vector3(to, 0f, 0f), time, options().setTextAlpha());
	}

	public static LTDescr alphaText(RectTransform rectTransform, float to, float time)
	{
		return pushNewTween(rectTransform.gameObject, new Vector3(to, 0f, 0f), time, options().setTextAlpha());
	}

	public static LTDescr alphaCanvas(CanvasGroup canvasGroup, float to, float time)
	{
		return pushNewTween(canvasGroup.gameObject, new Vector3(to, 0f, 0f), time, options().setCanvasGroupAlpha());
	}

	public static LTDescr alphaVertex(GameObject gameObject, float to, float time)
	{
		return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setAlphaVertex());
	}

	public static LTDescr color(GameObject gameObject, Color to, float time)
	{
		LTDescr lTDescr = pushNewTween(gameObject, new Vector3(1f, to.a, 0f), time, options().setColor().setPoint(new Vector3(to.r, to.g, to.b)));
		SpriteRenderer component = gameObject.GetComponent<SpriteRenderer>();
		lTDescr.spriteRen = component;
		return lTDescr;
	}

	public static LTDescr textColor(RectTransform rectTransform, Color to, float time)
	{
		return pushNewTween(rectTransform.gameObject, new Vector3(1f, to.a, 0f), time, options().setTextColor().setPoint(new Vector3(to.r, to.g, to.b)));
	}

	public static LTDescr colorText(RectTransform rectTransform, Color to, float time)
	{
		return pushNewTween(rectTransform.gameObject, new Vector3(1f, to.a, 0f), time, options().setTextColor().setPoint(new Vector3(to.r, to.g, to.b)));
	}

	public static LTDescr delayedCall(float delayTime, Action callback)
	{
		return pushNewTween(tweenEmpty, Vector3.zero, delayTime, options().setCallback().setOnComplete(callback));
	}

	public static LTDescr delayedCall(float delayTime, Action<object> callback)
	{
		return pushNewTween(tweenEmpty, Vector3.zero, delayTime, options().setCallback().setOnComplete(callback));
	}

	public static LTDescr delayedCall(GameObject gameObject, float delayTime, Action callback)
	{
		return pushNewTween(gameObject, Vector3.zero, delayTime, options().setCallback().setOnComplete(callback));
	}

	public static LTDescr delayedCall(GameObject gameObject, float delayTime, Action<object> callback)
	{
		return pushNewTween(gameObject, Vector3.zero, delayTime, options().setCallback().setOnComplete(callback));
	}

	public static LTDescr destroyAfter(LTRect rect, float delayTime)
	{
		return pushNewTween(tweenEmpty, Vector3.zero, delayTime, options().setCallback().setRect(rect).setDestroyOnComplete(doesDestroy: true));
	}

	public static LTDescr move(GameObject gameObject, Vector3 to, float time)
	{
		return pushNewTween(gameObject, to, time, options().setMove());
	}

	public static LTDescr move(GameObject gameObject, Vector2 to, float time)
	{
		return pushNewTween(gameObject, new Vector3(to.x, to.y, gameObject.transform.position.z), time, options().setMove());
	}

	public static LTDescr move(GameObject gameObject, Vector3[] to, float time)
	{
		d = options().setMoveCurved();
		if (d.optional.path == null)
		{
			d.optional.path = new LTBezierPath(to);
		}
		else
		{
			d.optional.path.setPoints(to);
		}
		return pushNewTween(gameObject, new Vector3(1f, 0f, 0f), time, d);
	}

	public static LTDescr move(GameObject gameObject, LTBezierPath to, float time)
	{
		d = options().setMoveCurved();
		d.optional.path = to;
		return pushNewTween(gameObject, new Vector3(1f, 0f, 0f), time, d);
	}

	public static LTDescr move(GameObject gameObject, LTSpline to, float time)
	{
		d = options().setMoveSpline();
		d.optional.spline = to;
		return pushNewTween(gameObject, new Vector3(1f, 0f, 0f), time, d);
	}

	public static LTDescr moveSpline(GameObject gameObject, Vector3[] to, float time)
	{
		d = options().setMoveSpline();
		d.optional.spline = new LTSpline(to);
		return pushNewTween(gameObject, new Vector3(1f, 0f, 0f), time, d);
	}

	public static LTDescr moveSpline(GameObject gameObject, LTSpline to, float time)
	{
		d = options().setMoveSpline();
		d.optional.spline = to;
		return pushNewTween(gameObject, new Vector3(1f, 0f, 0f), time, d);
	}

	public static LTDescr moveSplineLocal(GameObject gameObject, Vector3[] to, float time)
	{
		d = options().setMoveSplineLocal();
		d.optional.spline = new LTSpline(to);
		return pushNewTween(gameObject, new Vector3(1f, 0f, 0f), time, d);
	}

	public static LTDescr move(LTRect ltRect, Vector2 to, float time)
	{
		return pushNewTween(tweenEmpty, to, time, options().setGUIMove().setRect(ltRect));
	}

	public static LTDescr moveMargin(LTRect ltRect, Vector2 to, float time)
	{
		return pushNewTween(tweenEmpty, to, time, options().setGUIMoveMargin().setRect(ltRect));
	}

	public static LTDescr moveX(GameObject gameObject, float to, float time)
	{
		return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setMoveX());
	}

	public static LTDescr moveY(GameObject gameObject, float to, float time)
	{
		return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setMoveY());
	}

	public static LTDescr moveZ(GameObject gameObject, float to, float time)
	{
		return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setMoveZ());
	}

	public static LTDescr moveLocal(GameObject gameObject, Vector3 to, float time)
	{
		return pushNewTween(gameObject, to, time, options().setMoveLocal());
	}

	public static LTDescr moveLocal(GameObject gameObject, Vector3[] to, float time)
	{
		d = options().setMoveCurvedLocal();
		if (d.optional.path == null)
		{
			d.optional.path = new LTBezierPath(to);
		}
		else
		{
			d.optional.path.setPoints(to);
		}
		return pushNewTween(gameObject, new Vector3(1f, 0f, 0f), time, d);
	}

	public static LTDescr moveLocalX(GameObject gameObject, float to, float time)
	{
		return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setMoveLocalX());
	}

	public static LTDescr moveLocalY(GameObject gameObject, float to, float time)
	{
		return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setMoveLocalY());
	}

	public static LTDescr moveLocalZ(GameObject gameObject, float to, float time)
	{
		return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setMoveLocalZ());
	}

	public static LTDescr moveLocal(GameObject gameObject, LTBezierPath to, float time)
	{
		d = options().setMoveCurvedLocal();
		d.optional.path = to;
		return pushNewTween(gameObject, new Vector3(1f, 0f, 0f), time, d);
	}

	public static LTDescr moveLocal(GameObject gameObject, LTSpline to, float time)
	{
		d = options().setMoveSplineLocal();
		d.optional.spline = to;
		return pushNewTween(gameObject, new Vector3(1f, 0f, 0f), time, d);
	}

	public static LTDescr move(GameObject gameObject, Transform to, float time)
	{
		return pushNewTween(gameObject, Vector3.zero, time, options().setTo(to).setMoveToTransform());
	}

	public static LTDescr rotate(GameObject gameObject, Vector3 to, float time)
	{
		return pushNewTween(gameObject, to, time, options().setRotate());
	}

	public static LTDescr rotate(LTRect ltRect, float to, float time)
	{
		return pushNewTween(tweenEmpty, new Vector3(to, 0f, 0f), time, options().setGUIRotate().setRect(ltRect));
	}

	public static LTDescr rotateLocal(GameObject gameObject, Vector3 to, float time)
	{
		return pushNewTween(gameObject, to, time, options().setRotateLocal());
	}

	public static LTDescr rotateX(GameObject gameObject, float to, float time)
	{
		return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setRotateX());
	}

	public static LTDescr rotateY(GameObject gameObject, float to, float time)
	{
		return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setRotateY());
	}

	public static LTDescr rotateZ(GameObject gameObject, float to, float time)
	{
		return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setRotateZ());
	}

	public static LTDescr rotateAround(GameObject gameObject, Vector3 axis, float add, float time)
	{
		return pushNewTween(gameObject, new Vector3(add, 0f, 0f), time, options().setAxis(axis).setRotateAround());
	}

	public static LTDescr rotateAroundLocal(GameObject gameObject, Vector3 axis, float add, float time)
	{
		return pushNewTween(gameObject, new Vector3(add, 0f, 0f), time, options().setRotateAroundLocal().setAxis(axis));
	}

	public static LTDescr scale(GameObject gameObject, Vector3 to, float time)
	{
		return pushNewTween(gameObject, to, time, options().setScale());
	}

	public static LTDescr scale(LTRect ltRect, Vector2 to, float time)
	{
		return pushNewTween(tweenEmpty, to, time, options().setGUIScale().setRect(ltRect));
	}

	public static LTDescr scaleX(GameObject gameObject, float to, float time)
	{
		return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setScaleX());
	}

	public static LTDescr scaleY(GameObject gameObject, float to, float time)
	{
		return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setScaleY());
	}

	public static LTDescr scaleZ(GameObject gameObject, float to, float time)
	{
		return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setScaleZ());
	}

	public static LTDescr value(GameObject gameObject, float from, float to, float time)
	{
		return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setCallback().setFrom(new Vector3(from, 0f, 0f)));
	}

	public static LTDescr value(float from, float to, float time)
	{
		return pushNewTween(tweenEmpty, new Vector3(to, 0f, 0f), time, options().setCallback().setFrom(new Vector3(from, 0f, 0f)));
	}

	public static LTDescr value(GameObject gameObject, Vector2 from, Vector2 to, float time)
	{
		return pushNewTween(gameObject, new Vector3(to.x, to.y, 0f), time, options().setValue3().setTo(new Vector3(to.x, to.y, 0f)).setFrom(new Vector3(from.x, from.y, 0f)));
	}

	public static LTDescr value(GameObject gameObject, Vector3 from, Vector3 to, float time)
	{
		return pushNewTween(gameObject, to, time, options().setValue3().setFrom(from));
	}

	public static LTDescr value(GameObject gameObject, Color from, Color to, float time)
	{
		LTDescr lTDescr = pushNewTween(gameObject, new Vector3(1f, to.a, 0f), time, options().setCallbackColor().setPoint(new Vector3(to.r, to.g, to.b)).setFromColor(from)
			.setHasInitialized(has: false));
		SpriteRenderer component = gameObject.GetComponent<SpriteRenderer>();
		lTDescr.spriteRen = component;
		return lTDescr;
	}

	public static LTDescr value(GameObject gameObject, Action<float> callOnUpdate, float from, float to, float time)
	{
		return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setCallback().setTo(new Vector3(to, 0f, 0f)).setFrom(new Vector3(from, 0f, 0f))
			.setOnUpdate(callOnUpdate));
	}

	public static LTDescr value(GameObject gameObject, Action<float, float> callOnUpdateRatio, float from, float to, float time)
	{
		return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setCallback().setTo(new Vector3(to, 0f, 0f)).setFrom(new Vector3(from, 0f, 0f))
			.setOnUpdateRatio(callOnUpdateRatio));
	}

	public static LTDescr value(GameObject gameObject, Action<Color> callOnUpdate, Color from, Color to, float time)
	{
		return pushNewTween(gameObject, new Vector3(1f, to.a, 0f), time, options().setCallbackColor().setPoint(new Vector3(to.r, to.g, to.b)).setAxis(new Vector3(from.r, from.g, from.b))
			.setFrom(new Vector3(0f, from.a, 0f))
			.setHasInitialized(has: false)
			.setOnUpdateColor(callOnUpdate));
	}

	public static LTDescr value(GameObject gameObject, Action<Color, object> callOnUpdate, Color from, Color to, float time)
	{
		return pushNewTween(gameObject, new Vector3(1f, to.a, 0f), time, options().setCallbackColor().setPoint(new Vector3(to.r, to.g, to.b)).setAxis(new Vector3(from.r, from.g, from.b))
			.setFrom(new Vector3(0f, from.a, 0f))
			.setHasInitialized(has: false)
			.setOnUpdateColor(callOnUpdate));
	}

	public static LTDescr value(GameObject gameObject, Action<Vector2> callOnUpdate, Vector2 from, Vector2 to, float time)
	{
		return pushNewTween(gameObject, new Vector3(to.x, to.y, 0f), time, options().setValue3().setTo(new Vector3(to.x, to.y, 0f)).setFrom(new Vector3(from.x, from.y, 0f))
			.setOnUpdateVector2(callOnUpdate));
	}

	public static LTDescr value(GameObject gameObject, Action<Vector3> callOnUpdate, Vector3 from, Vector3 to, float time)
	{
		return pushNewTween(gameObject, to, time, options().setValue3().setTo(to).setFrom(from)
			.setOnUpdateVector3(callOnUpdate));
	}

	public static LTDescr value(GameObject gameObject, Action<float, object> callOnUpdate, float from, float to, float time)
	{
		return pushNewTween(gameObject, new Vector3(to, 0f, 0f), time, options().setCallback().setTo(new Vector3(to, 0f, 0f)).setFrom(new Vector3(from, 0f, 0f))
			.setOnUpdate(callOnUpdate, gameObject));
	}

	public static LTDescr delayedSound(AudioClip audio, Vector3 pos, float volume)
	{
		return pushNewTween(tweenEmpty, pos, 0f, options().setDelayedSound().setTo(pos).setFrom(new Vector3(volume, 0f, 0f))
			.setAudio(audio));
	}

	public static LTDescr delayedSound(GameObject gameObject, AudioClip audio, Vector3 pos, float volume)
	{
		return pushNewTween(gameObject, pos, 0f, options().setDelayedSound().setTo(pos).setFrom(new Vector3(volume, 0f, 0f))
			.setAudio(audio));
	}

	public static LTDescr move(RectTransform rectTrans, Vector3 to, float time)
	{
		return pushNewTween(rectTrans.gameObject, to, time, options().setCanvasMove().setRect(rectTrans));
	}

	public static LTDescr moveX(RectTransform rectTrans, float to, float time)
	{
		return pushNewTween(rectTrans.gameObject, new Vector3(to, 0f, 0f), time, options().setCanvasMoveX().setRect(rectTrans));
	}

	public static LTDescr moveY(RectTransform rectTrans, float to, float time)
	{
		return pushNewTween(rectTrans.gameObject, new Vector3(to, 0f, 0f), time, options().setCanvasMoveY().setRect(rectTrans));
	}

	public static LTDescr moveZ(RectTransform rectTrans, float to, float time)
	{
		return pushNewTween(rectTrans.gameObject, new Vector3(to, 0f, 0f), time, options().setCanvasMoveZ().setRect(rectTrans));
	}

	public static LTDescr rotate(RectTransform rectTrans, float to, float time)
	{
		return pushNewTween(rectTrans.gameObject, new Vector3(to, 0f, 0f), time, options().setCanvasRotateAround().setRect(rectTrans).setAxis(Vector3.forward));
	}

	public static LTDescr rotate(RectTransform rectTrans, Vector3 to, float time)
	{
		return pushNewTween(rectTrans.gameObject, to, time, options().setCanvasRotateAround().setRect(rectTrans).setAxis(Vector3.forward));
	}

	public static LTDescr rotateAround(RectTransform rectTrans, Vector3 axis, float to, float time)
	{
		return pushNewTween(rectTrans.gameObject, new Vector3(to, 0f, 0f), time, options().setCanvasRotateAround().setRect(rectTrans).setAxis(axis));
	}

	public static LTDescr rotateAroundLocal(RectTransform rectTrans, Vector3 axis, float to, float time)
	{
		return pushNewTween(rectTrans.gameObject, new Vector3(to, 0f, 0f), time, options().setCanvasRotateAroundLocal().setRect(rectTrans).setAxis(axis));
	}

	public static LTDescr scale(RectTransform rectTrans, Vector3 to, float time)
	{
		return pushNewTween(rectTrans.gameObject, to, time, options().setCanvasScale().setRect(rectTrans));
	}

	public static LTDescr size(RectTransform rectTrans, Vector2 to, float time)
	{
		return pushNewTween(rectTrans.gameObject, to, time, options().setCanvasSizeDelta().setRect(rectTrans));
	}

	public static LTDescr alpha(RectTransform rectTrans, float to, float time)
	{
		return pushNewTween(rectTrans.gameObject, new Vector3(to, 0f, 0f), time, options().setCanvasAlpha().setRect(rectTrans));
	}

	public static LTDescr color(RectTransform rectTrans, Color to, float time)
	{
		return pushNewTween(rectTrans.gameObject, new Vector3(1f, to.a, 0f), time, options().setCanvasColor().setRect(rectTrans).setPoint(new Vector3(to.r, to.g, to.b)));
	}

	public static float tweenOnCurve(LTDescr tweenDescr, float ratioPassed)
	{
		return tweenDescr.from.x + tweenDescr.diff.x * tweenDescr.optional.animationCurve.Evaluate(ratioPassed);
	}

	public static Vector3 tweenOnCurveVector(LTDescr tweenDescr, float ratioPassed)
	{
		return new Vector3(tweenDescr.from.x + tweenDescr.diff.x * tweenDescr.optional.animationCurve.Evaluate(ratioPassed), tweenDescr.from.y + tweenDescr.diff.y * tweenDescr.optional.animationCurve.Evaluate(ratioPassed), tweenDescr.from.z + tweenDescr.diff.z * tweenDescr.optional.animationCurve.Evaluate(ratioPassed));
	}

	public static float easeOutQuadOpt(float start, float diff, float ratioPassed)
	{
		return (0f - diff) * ratioPassed * (ratioPassed - 2f) + start;
	}

	public static float easeInQuadOpt(float start, float diff, float ratioPassed)
	{
		return diff * ratioPassed * ratioPassed + start;
	}

	public static float easeInOutQuadOpt(float start, float diff, float ratioPassed)
	{
		ratioPassed /= 0.5f;
		if (ratioPassed < 1f)
		{
			return diff / 2f * ratioPassed * ratioPassed + start;
		}
		ratioPassed -= 1f;
		return (0f - diff) / 2f * (ratioPassed * (ratioPassed - 2f) - 1f) + start;
	}

	public static Vector3 easeInOutQuadOpt(Vector3 start, Vector3 diff, float ratioPassed)
	{
		ratioPassed /= 0.5f;
		if (ratioPassed < 1f)
		{
			return diff / 2f * ratioPassed * ratioPassed + start;
		}
		ratioPassed -= 1f;
		return -diff / 2f * (ratioPassed * (ratioPassed - 2f) - 1f) + start;
	}

	public static float linear(float start, float end, float val)
	{
		return Mathf.Lerp(start, end, val);
	}

	public static float clerp(float start, float end, float val)
	{
		float num = 0f;
		float num2 = 360f;
		float num3 = Mathf.Abs((num2 - num) / 2f);
		float num4 = 0f;
		float num5 = 0f;
		if (end - start < 0f - num3)
		{
			num5 = (num2 - start + end) * val;
			return start + num5;
		}
		if (end - start > num3)
		{
			num5 = (0f - (num2 - end + start)) * val;
			return start + num5;
		}
		return start + (end - start) * val;
	}

	public static float spring(float start, float end, float val)
	{
		val = Mathf.Clamp01(val);
		val = (Mathf.Sin(val * (float)Math.PI * (0.2f + 2.5f * val * val * val)) * Mathf.Pow(1f - val, 2.2f) + val) * (1f + 1.2f * (1f - val));
		return start + (end - start) * val;
	}

	public static float easeInQuad(float start, float end, float val)
	{
		end -= start;
		return end * val * val + start;
	}

	public static float easeOutQuad(float start, float end, float val)
	{
		end -= start;
		return (0f - end) * val * (val - 2f) + start;
	}

	public static float easeInOutQuad(float start, float end, float val)
	{
		val /= 0.5f;
		end -= start;
		if (val < 1f)
		{
			return end / 2f * val * val + start;
		}
		val -= 1f;
		return (0f - end) / 2f * (val * (val - 2f) - 1f) + start;
	}

	public static float easeInOutQuadOpt2(float start, float diffBy2, float val, float val2)
	{
		val /= 0.5f;
		if (val < 1f)
		{
			return diffBy2 * val2 + start;
		}
		val -= 1f;
		return (0f - diffBy2) * (val2 - 2f - 1f) + start;
	}

	public static float easeInCubic(float start, float end, float val)
	{
		end -= start;
		return end * val * val * val + start;
	}

	public static float easeOutCubic(float start, float end, float val)
	{
		val -= 1f;
		end -= start;
		return end * (val * val * val + 1f) + start;
	}

	public static float easeInOutCubic(float start, float end, float val)
	{
		val /= 0.5f;
		end -= start;
		if (val < 1f)
		{
			return end / 2f * val * val * val + start;
		}
		val -= 2f;
		return end / 2f * (val * val * val + 2f) + start;
	}

	public static float easeInQuart(float start, float end, float val)
	{
		end -= start;
		return end * val * val * val * val + start;
	}

	public static float easeOutQuart(float start, float end, float val)
	{
		val -= 1f;
		end -= start;
		return (0f - end) * (val * val * val * val - 1f) + start;
	}

	public static float easeInOutQuart(float start, float end, float val)
	{
		val /= 0.5f;
		end -= start;
		if (val < 1f)
		{
			return end / 2f * val * val * val * val + start;
		}
		val -= 2f;
		return (0f - end) / 2f * (val * val * val * val - 2f) + start;
	}

	public static float easeInQuint(float start, float end, float val)
	{
		end -= start;
		return end * val * val * val * val * val + start;
	}

	public static float easeOutQuint(float start, float end, float val)
	{
		val -= 1f;
		end -= start;
		return end * (val * val * val * val * val + 1f) + start;
	}

	public static float easeInOutQuint(float start, float end, float val)
	{
		val /= 0.5f;
		end -= start;
		if (val < 1f)
		{
			return end / 2f * val * val * val * val * val + start;
		}
		val -= 2f;
		return end / 2f * (val * val * val * val * val + 2f) + start;
	}

	public static float easeInSine(float start, float end, float val)
	{
		end -= start;
		return (0f - end) * Mathf.Cos(val / 1f * ((float)Math.PI / 2f)) + end + start;
	}

	public static float easeOutSine(float start, float end, float val)
	{
		end -= start;
		return end * Mathf.Sin(val / 1f * ((float)Math.PI / 2f)) + start;
	}

	public static float easeInOutSine(float start, float end, float val)
	{
		end -= start;
		return (0f - end) / 2f * (Mathf.Cos((float)Math.PI * val / 1f) - 1f) + start;
	}

	public static float easeInExpo(float start, float end, float val)
	{
		end -= start;
		return end * Mathf.Pow(2f, 10f * (val / 1f - 1f)) + start;
	}

	public static float easeOutExpo(float start, float end, float val)
	{
		end -= start;
		return end * (0f - Mathf.Pow(2f, -10f * val / 1f) + 1f) + start;
	}

	public static float easeInOutExpo(float start, float end, float val)
	{
		val /= 0.5f;
		end -= start;
		if (val < 1f)
		{
			return end / 2f * Mathf.Pow(2f, 10f * (val - 1f)) + start;
		}
		val -= 1f;
		return end / 2f * (0f - Mathf.Pow(2f, -10f * val) + 2f) + start;
	}

	public static float easeInCirc(float start, float end, float val)
	{
		end -= start;
		return (0f - end) * (Mathf.Sqrt(1f - val * val) - 1f) + start;
	}

	public static float easeOutCirc(float start, float end, float val)
	{
		val -= 1f;
		end -= start;
		return end * Mathf.Sqrt(1f - val * val) + start;
	}

	public static float easeInOutCirc(float start, float end, float val)
	{
		val /= 0.5f;
		end -= start;
		if (val < 1f)
		{
			return (0f - end) / 2f * (Mathf.Sqrt(1f - val * val) - 1f) + start;
		}
		val -= 2f;
		return end / 2f * (Mathf.Sqrt(1f - val * val) + 1f) + start;
	}

	public static float easeInBounce(float start, float end, float val)
	{
		end -= start;
		float num = 1f;
		return end - easeOutBounce(0f, end, num - val) + start;
	}

	public static float easeOutBounce(float start, float end, float val)
	{
		val /= 1f;
		end -= start;
		if (val < 0.36363637f)
		{
			return end * (7.5625f * val * val) + start;
		}
		if (val < 0.72727275f)
		{
			val -= 0.54545456f;
			return end * (7.5625f * val * val + 0.75f) + start;
		}
		if ((double)val < 0.9090909090909091)
		{
			val -= 0.8181818f;
			return end * (7.5625f * val * val + 0.9375f) + start;
		}
		val -= 21f / 22f;
		return end * (7.5625f * val * val + 63f / 64f) + start;
	}

	public static float easeInOutBounce(float start, float end, float val)
	{
		end -= start;
		float num = 1f;
		if (val < num / 2f)
		{
			return easeInBounce(0f, end, val * 2f) * 0.5f + start;
		}
		return easeOutBounce(0f, end, val * 2f - num) * 0.5f + end * 0.5f + start;
	}

	public static float easeInBack(float start, float end, float val, float overshoot = 1f)
	{
		end -= start;
		val /= 1f;
		float num = 1.70158f * overshoot;
		return end * val * val * ((num + 1f) * val - num) + start;
	}

	public static float easeOutBack(float start, float end, float val, float overshoot = 1f)
	{
		float num = 1.70158f * overshoot;
		end -= start;
		val = val / 1f - 1f;
		return end * (val * val * ((num + 1f) * val + num) + 1f) + start;
	}

	public static float easeInOutBack(float start, float end, float val, float overshoot = 1f)
	{
		float num = 1.70158f * overshoot;
		end -= start;
		val /= 0.5f;
		if (val < 1f)
		{
			num *= 1.525f * overshoot;
			return end / 2f * (val * val * ((num + 1f) * val - num)) + start;
		}
		val -= 2f;
		num *= 1.525f * overshoot;
		return end / 2f * (val * val * ((num + 1f) * val + num) + 2f) + start;
	}

	public static float easeInElastic(float start, float end, float val, float overshoot = 1f, float period = 0.3f)
	{
		end -= start;
		float num = 0f;
		float num2 = 0f;
		if (val == 0f)
		{
			return start;
		}
		if (val == 1f)
		{
			return start + end;
		}
		if (num2 == 0f || num2 < Mathf.Abs(end))
		{
			num2 = end;
			num = period / 4f;
		}
		else
		{
			num = period / ((float)Math.PI * 2f) * Mathf.Asin(end / num2);
		}
		if (overshoot > 1f && val > 0.6f)
		{
			overshoot = 1f + (1f - val) / 0.4f * (overshoot - 1f);
		}
		val -= 1f;
		return start - num2 * Mathf.Pow(2f, 10f * val) * Mathf.Sin((val - num) * ((float)Math.PI * 2f) / period) * overshoot;
	}

	public static float easeOutElastic(float start, float end, float val, float overshoot = 1f, float period = 0.3f)
	{
		end -= start;
		float num = 0f;
		float num2 = 0f;
		if (val == 0f)
		{
			return start;
		}
		if (val == 1f)
		{
			return start + end;
		}
		if (num2 == 0f || num2 < Mathf.Abs(end))
		{
			num2 = end;
			num = period / 4f;
		}
		else
		{
			num = period / ((float)Math.PI * 2f) * Mathf.Asin(end / num2);
		}
		if (overshoot > 1f && val < 0.4f)
		{
			overshoot = 1f + val / 0.4f * (overshoot - 1f);
		}
		return start + end + num2 * Mathf.Pow(2f, -10f * val) * Mathf.Sin((val - num) * ((float)Math.PI * 2f) / period) * overshoot;
	}

	public static float easeInOutElastic(float start, float end, float val, float overshoot = 1f, float period = 0.3f)
	{
		end -= start;
		float num = 0f;
		float num2 = 0f;
		if (val == 0f)
		{
			return start;
		}
		val /= 0.5f;
		if (val == 2f)
		{
			return start + end;
		}
		if (num2 == 0f || num2 < Mathf.Abs(end))
		{
			num2 = end;
			num = period / 4f;
		}
		else
		{
			num = period / ((float)Math.PI * 2f) * Mathf.Asin(end / num2);
		}
		if (overshoot > 1f)
		{
			if (val < 0.2f)
			{
				overshoot = 1f + val / 0.2f * (overshoot - 1f);
			}
			else if (val > 0.8f)
			{
				overshoot = 1f + (1f - val) / 0.2f * (overshoot - 1f);
			}
		}
		if (val < 1f)
		{
			val -= 1f;
			return start - 0.5f * (num2 * Mathf.Pow(2f, 10f * val) * Mathf.Sin((val - num) * ((float)Math.PI * 2f) / period)) * overshoot;
		}
		val -= 1f;
		return end + start + num2 * Mathf.Pow(2f, -10f * val) * Mathf.Sin((val - num) * ((float)Math.PI * 2f) / period) * 0.5f * overshoot;
	}

	public static LTDescr followDamp(Transform trans, Transform target, LeanProp prop, float smoothTime, float maxSpeed = -1f)
	{
		LTDescr d = pushNewTween(trans.gameObject, Vector3.zero, float.MaxValue, options().setFollow().setTarget(target));
		switch (prop)
		{
		case LeanProp.localPosition:
			d.optional.axis = d.trans.localPosition;
			d.easeInternal = delegate
			{
				d.optional.axis = LeanSmooth.damp(d.optional.axis, d.toTrans.localPosition, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime);
				d.trans.localPosition = d.optional.axis + d.toInternal;
			};
			break;
		case LeanProp.position:
			d.diff = d.trans.position;
			d.easeInternal = delegate
			{
				d.optional.axis = LeanSmooth.damp(d.optional.axis, d.toTrans.position, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime);
				d.trans.position = d.optional.axis + d.toInternal;
			};
			break;
		case LeanProp.localX:
			d.easeInternal = delegate
			{
				d.trans.LeanSetLocalPosX(LeanSmooth.damp(d.trans.localPosition.x, d.toTrans.localPosition.x, ref d.fromInternal.x, smoothTime, maxSpeed, Time.deltaTime));
			};
			break;
		case LeanProp.localY:
			d.easeInternal = delegate
			{
				d.trans.LeanSetLocalPosY(LeanSmooth.damp(d.trans.localPosition.y, d.toTrans.localPosition.y, ref d.fromInternal.y, smoothTime, maxSpeed, Time.deltaTime));
			};
			break;
		case LeanProp.localZ:
			d.easeInternal = delegate
			{
				d.trans.LeanSetLocalPosZ(LeanSmooth.damp(d.trans.localPosition.z, d.toTrans.localPosition.z, ref d.fromInternal.z, smoothTime, maxSpeed, Time.deltaTime));
			};
			break;
		case LeanProp.x:
			d.easeInternal = delegate
			{
				d.trans.LeanSetPosX(LeanSmooth.damp(d.trans.position.x, d.toTrans.position.x, ref d.fromInternal.x, smoothTime, maxSpeed, Time.deltaTime));
			};
			break;
		case LeanProp.y:
			d.easeInternal = delegate
			{
				d.trans.LeanSetPosY(LeanSmooth.damp(d.trans.position.y, d.toTrans.position.y, ref d.fromInternal.y, smoothTime, maxSpeed, Time.deltaTime));
			};
			break;
		case LeanProp.z:
			d.easeInternal = delegate
			{
				d.trans.LeanSetPosZ(LeanSmooth.damp(d.trans.position.z, d.toTrans.position.z, ref d.fromInternal.z, smoothTime, maxSpeed, Time.deltaTime));
			};
			break;
		case LeanProp.scale:
			d.easeInternal = delegate
			{
				d.trans.localScale = LeanSmooth.damp(d.trans.localScale, d.toTrans.localScale, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime);
			};
			break;
		case LeanProp.color:
			d.easeInternal = delegate
			{
				Color color = LeanSmooth.damp(d.trans.LeanColor(), d.toTrans.LeanColor(), ref d.optional.color, smoothTime, maxSpeed, Time.deltaTime);
				d.trans.GetComponent<Renderer>().material.color = color;
			};
			break;
		}
		return d;
	}

	public static LTDescr followSpring(Transform trans, Transform target, LeanProp prop, float smoothTime, float maxSpeed = -1f, float friction = 2f, float accelRate = 0.5f)
	{
		LTDescr d = pushNewTween(trans.gameObject, Vector3.zero, float.MaxValue, options().setFollow().setTarget(target));
		switch (prop)
		{
		case LeanProp.localPosition:
			d.optional.axis = d.trans.localPosition;
			d.easeInternal = delegate
			{
				d.optional.axis = LeanSmooth.spring(d.optional.axis, d.toTrans.localPosition, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate);
				d.trans.localPosition = d.optional.axis + d.toInternal;
			};
			break;
		case LeanProp.position:
			d.diff = d.trans.position;
			d.easeInternal = delegate
			{
				d.diff = LeanSmooth.spring(d.diff, d.toTrans.position, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate);
				d.trans.position = d.diff;
			};
			break;
		case LeanProp.localX:
			d.easeInternal = delegate
			{
				d.trans.LeanSetLocalPosX(LeanSmooth.spring(d.trans.localPosition.x, d.toTrans.localPosition.x, ref d.fromInternal.x, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate));
			};
			break;
		case LeanProp.localY:
			d.easeInternal = delegate
			{
				d.trans.LeanSetLocalPosY(LeanSmooth.spring(d.trans.localPosition.y, d.toTrans.localPosition.y, ref d.fromInternal.y, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate));
			};
			break;
		case LeanProp.localZ:
			d.easeInternal = delegate
			{
				d.trans.LeanSetLocalPosZ(LeanSmooth.spring(d.trans.localPosition.z, d.toTrans.localPosition.z, ref d.fromInternal.z, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate));
			};
			break;
		case LeanProp.x:
			d.easeInternal = delegate
			{
				d.trans.LeanSetPosX(LeanSmooth.spring(d.trans.position.x, d.toTrans.position.x, ref d.fromInternal.x, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate));
			};
			break;
		case LeanProp.y:
			d.easeInternal = delegate
			{
				d.trans.LeanSetPosY(LeanSmooth.spring(d.trans.position.y, d.toTrans.position.y, ref d.fromInternal.y, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate));
			};
			break;
		case LeanProp.z:
			d.easeInternal = delegate
			{
				d.trans.LeanSetPosZ(LeanSmooth.spring(d.trans.position.z, d.toTrans.position.z, ref d.fromInternal.z, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate));
			};
			break;
		case LeanProp.scale:
			d.easeInternal = delegate
			{
				d.trans.localScale = LeanSmooth.spring(d.trans.localScale, d.toTrans.localScale, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate);
			};
			break;
		case LeanProp.color:
			d.easeInternal = delegate
			{
				Color color = LeanSmooth.spring(d.trans.LeanColor(), d.toTrans.LeanColor(), ref d.optional.color, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate);
				d.trans.GetComponent<Renderer>().material.color = color;
			};
			break;
		}
		return d;
	}

	public static LTDescr followBounceOut(Transform trans, Transform target, LeanProp prop, float smoothTime, float maxSpeed = -1f, float friction = 2f, float accelRate = 0.5f, float hitDamping = 0.9f)
	{
		LTDescr d = pushNewTween(trans.gameObject, Vector3.zero, float.MaxValue, options().setFollow().setTarget(target));
		switch (prop)
		{
		case LeanProp.localPosition:
			d.optional.axis = d.trans.localPosition;
			d.easeInternal = delegate
			{
				d.optional.axis = LeanSmooth.bounceOut(d.optional.axis, d.toTrans.localPosition, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping);
				d.trans.localPosition = d.optional.axis + d.toInternal;
			};
			break;
		case LeanProp.position:
			d.easeInternal = delegate
			{
				d.optional.axis = LeanSmooth.bounceOut(d.optional.axis, d.toTrans.position, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping);
				d.trans.position = d.optional.axis + d.toInternal;
			};
			break;
		case LeanProp.localX:
			d.easeInternal = delegate
			{
				d.trans.LeanSetLocalPosX(LeanSmooth.bounceOut(d.trans.localPosition.x, d.toTrans.localPosition.x, ref d.fromInternal.x, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping));
			};
			break;
		case LeanProp.localY:
			d.easeInternal = delegate
			{
				d.trans.LeanSetLocalPosY(LeanSmooth.bounceOut(d.trans.localPosition.y, d.toTrans.localPosition.y, ref d.fromInternal.y, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping));
			};
			break;
		case LeanProp.localZ:
			d.easeInternal = delegate
			{
				d.trans.LeanSetLocalPosZ(LeanSmooth.bounceOut(d.trans.localPosition.z, d.toTrans.localPosition.z, ref d.fromInternal.z, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping));
			};
			break;
		case LeanProp.x:
			d.easeInternal = delegate
			{
				d.trans.LeanSetPosX(LeanSmooth.bounceOut(d.trans.position.x, d.toTrans.position.x, ref d.fromInternal.x, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping));
			};
			break;
		case LeanProp.y:
			d.easeInternal = delegate
			{
				d.trans.LeanSetPosY(LeanSmooth.bounceOut(d.trans.position.y, d.toTrans.position.y, ref d.fromInternal.y, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping));
			};
			break;
		case LeanProp.z:
			d.easeInternal = delegate
			{
				d.trans.LeanSetPosZ(LeanSmooth.bounceOut(d.trans.position.z, d.toTrans.position.z, ref d.fromInternal.z, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping));
			};
			break;
		case LeanProp.scale:
			d.easeInternal = delegate
			{
				d.trans.localScale = LeanSmooth.bounceOut(d.trans.localScale, d.toTrans.localScale, ref d.fromInternal, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping);
			};
			break;
		case LeanProp.color:
			d.easeInternal = delegate
			{
				Color color = LeanSmooth.bounceOut(d.trans.LeanColor(), d.toTrans.LeanColor(), ref d.optional.color, smoothTime, maxSpeed, Time.deltaTime, friction, accelRate, hitDamping);
				d.trans.GetComponent<Renderer>().material.color = color;
			};
			break;
		}
		return d;
	}

	public static LTDescr followLinear(Transform trans, Transform target, LeanProp prop, float moveSpeed)
	{
		LTDescr d = pushNewTween(trans.gameObject, Vector3.zero, float.MaxValue, options().setFollow().setTarget(target));
		switch (prop)
		{
		case LeanProp.localPosition:
			d.optional.axis = d.trans.localPosition;
			d.easeInternal = delegate
			{
				d.optional.axis = LeanSmooth.linear(d.optional.axis, d.toTrans.localPosition, moveSpeed);
				d.trans.localPosition = d.optional.axis + d.toInternal;
			};
			break;
		case LeanProp.position:
			d.easeInternal = delegate
			{
				d.trans.position = LeanSmooth.linear(d.trans.position, d.toTrans.position, moveSpeed);
			};
			break;
		case LeanProp.localX:
			d.easeInternal = delegate
			{
				d.trans.LeanSetLocalPosX(LeanSmooth.linear(d.trans.localPosition.x, d.toTrans.localPosition.x, moveSpeed));
			};
			break;
		case LeanProp.localY:
			d.easeInternal = delegate
			{
				d.trans.LeanSetLocalPosY(LeanSmooth.linear(d.trans.localPosition.y, d.toTrans.localPosition.y, moveSpeed));
			};
			break;
		case LeanProp.localZ:
			d.easeInternal = delegate
			{
				d.trans.LeanSetLocalPosZ(LeanSmooth.linear(d.trans.localPosition.z, d.toTrans.localPosition.z, moveSpeed));
			};
			break;
		case LeanProp.x:
			d.easeInternal = delegate
			{
				d.trans.LeanSetPosX(LeanSmooth.linear(d.trans.position.x, d.toTrans.position.x, moveSpeed));
			};
			break;
		case LeanProp.y:
			d.easeInternal = delegate
			{
				d.trans.LeanSetPosY(LeanSmooth.linear(d.trans.position.y, d.toTrans.position.y, moveSpeed));
			};
			break;
		case LeanProp.z:
			d.easeInternal = delegate
			{
				d.trans.LeanSetPosZ(LeanSmooth.linear(d.trans.position.z, d.toTrans.position.z, moveSpeed));
			};
			break;
		case LeanProp.scale:
			d.easeInternal = delegate
			{
				d.trans.localScale = LeanSmooth.linear(d.trans.localScale, d.toTrans.localScale, moveSpeed);
			};
			break;
		case LeanProp.color:
			d.easeInternal = delegate
			{
				Color color = LeanSmooth.linear(d.trans.LeanColor(), d.toTrans.LeanColor(), moveSpeed);
				d.trans.GetComponent<Renderer>().material.color = color;
			};
			break;
		}
		return d;
	}

	public static void addListener(int eventId, Action<LTEvent> callback)
	{
		addListener(tweenEmpty, eventId, callback);
	}

	public static void addListener(GameObject caller, int eventId, Action<LTEvent> callback)
	{
		if (eventListeners == null)
		{
			INIT_LISTENERS_MAX = LISTENERS_MAX;
			eventListeners = new Action<LTEvent>[EVENTS_MAX * LISTENERS_MAX];
			goListeners = new GameObject[EVENTS_MAX * LISTENERS_MAX];
		}
		for (i = 0; i < INIT_LISTENERS_MAX; i++)
		{
			int num = eventId * INIT_LISTENERS_MAX + i;
			if (goListeners[num] == null || eventListeners[num] == null)
			{
				eventListeners[num] = callback;
				goListeners[num] = caller;
				if (i >= eventsMaxSearch)
				{
					eventsMaxSearch = i + 1;
				}
				return;
			}
			if (goListeners[num] == caller && object.Equals(eventListeners[num], callback))
			{
				return;
			}
		}
		UnityEngine.Debug.LogError("You ran out of areas to add listeners, consider increasing LISTENERS_MAX, ex: LeanTween.LISTENERS_MAX = " + LISTENERS_MAX * 2);
	}

	public static bool removeListener(int eventId, Action<LTEvent> callback)
	{
		return removeListener(tweenEmpty, eventId, callback);
	}

	public static bool removeListener(int eventId)
	{
		int num = eventId * INIT_LISTENERS_MAX + i;
		eventListeners[num] = null;
		goListeners[num] = null;
		return true;
	}

	public static bool removeListener(GameObject caller, int eventId, Action<LTEvent> callback)
	{
		for (i = 0; i < eventsMaxSearch; i++)
		{
			int num = eventId * INIT_LISTENERS_MAX + i;
			if (goListeners[num] == caller && object.Equals(eventListeners[num], callback))
			{
				eventListeners[num] = null;
				goListeners[num] = null;
				return true;
			}
		}
		return false;
	}

	public static void dispatchEvent(int eventId)
	{
		dispatchEvent(eventId, null);
	}

	public static void dispatchEvent(int eventId, object data)
	{
		for (int i = 0; i < eventsMaxSearch; i++)
		{
			int num = eventId * INIT_LISTENERS_MAX + i;
			if (eventListeners[num] != null)
			{
				if ((bool)goListeners[num])
				{
					eventListeners[num](new LTEvent(eventId, data));
				}
				else
				{
					eventListeners[num] = null;
				}
			}
		}
	}
}
public class LTUtility
{
	public static Vector3[] reverse(Vector3[] arr)
	{
		int num = arr.Length;
		int num2 = 0;
		int num3 = num - 1;
		while (num2 < num3)
		{
			Vector3 vector = arr[num2];
			ref Vector3 reference = ref arr[num2];
			reference = arr[num3];
			arr[num3] = vector;
			num2++;
			num3--;
		}
		return arr;
	}
}
public class LTBezier
{
	public float length;

	private Vector3 a;

	private Vector3 aa;

	private Vector3 bb;

	private Vector3 cc;

	private float len;

	private float[] arcLengths;

	public LTBezier(Vector3 a, Vector3 b, Vector3 c, Vector3 d, float precision)
	{
		this.a = a;
		aa = -a + 3f * (b - c) + d;
		bb = 3f * (a + c) - 6f * b;
		cc = 3f * (b - a);
		len = 1f / precision;
		arcLengths = new float[(int)len + 1];
		arcLengths[0] = 0f;
		Vector3 vector = a;
		float num = 0f;
		for (int i = 1; (float)i <= len; i++)
		{
			Vector3 vector2 = bezierPoint((float)i * precision);
			num += (vector - vector2).magnitude;
			arcLengths[i] = num;
			vector = vector2;
		}
		length = num;
	}

	private float map(float u)
	{
		float num = u * arcLengths[(int)len];
		int num2 = 0;
		int num3 = (int)len;
		int num4 = 0;
		while (num2 < num3)
		{
			num4 = num2 + ((int)((float)(num3 - num2) / 2f) | 0);
			if (arcLengths[num4] < num)
			{
				num2 = num4 + 1;
			}
			else
			{
				num3 = num4;
			}
		}
		if (arcLengths[num4] > num)
		{
			num4--;
		}
		if (num4 < 0)
		{
			num4 = 0;
		}
		return ((float)num4 + (num - arcLengths[num4]) / (arcLengths[num4 + 1] - arcLengths[num4])) / len;
	}

	private Vector3 bezierPoint(float t)
	{
		return ((aa * t + bb) * t + cc) * t + a;
	}

	public Vector3 point(float t)
	{
		return bezierPoint(map(t));
	}
}
public class LTBezierPath
{
	public Vector3[] pts;

	public float length;

	public bool orientToPath;

	public bool orientToPath2d;

	private LTBezier[] beziers;

	private float[] lengthRatio;

	private int currentBezier;

	private int previousBezier;

	public float distance => length;

	public LTBezierPath()
	{
	}

	public LTBezierPath(Vector3[] pts_)
	{
		setPoints(pts_);
	}

	public void setPoints(Vector3[] pts_)
	{
		if (pts_.Length < 4)
		{
			LeanTween.logError("LeanTween - When passing values for a vector path, you must pass four or more values!");
		}
		if (pts_.Length % 4 != 0)
		{
			LeanTween.logError("LeanTween - When passing values for a vector path, they must be in sets of four: controlPoint1, controlPoint2, endPoint2, controlPoint2, controlPoint2...");
		}
		pts = pts_;
		int num = 0;
		beziers = new LTBezier[pts.Length / 4];
		lengthRatio = new float[beziers.Length];
		length = 0f;
		for (int i = 0; i < pts.Length; i += 4)
		{
			beziers[num] = new LTBezier(pts[i], pts[i + 2], pts[i + 1], pts[i + 3], 0.05f);
			length += beziers[num].length;
			num++;
		}
		for (int i = 0; i < beziers.Length; i++)
		{
			lengthRatio[i] = beziers[i].length / length;
		}
	}

	public Vector3 point(float ratio)
	{
		float num = 0f;
		for (int i = 0; i < lengthRatio.Length; i++)
		{
			num += lengthRatio[i];
			if (num >= ratio)
			{
				return beziers[i].point((ratio - (num - lengthRatio[i])) / lengthRatio[i]);
			}
		}
		return beziers[lengthRatio.Length - 1].point(1f);
	}

	public void place2d(Transform transform, float ratio)
	{
		transform.position = point(ratio);
		ratio += 0.001f;
		if (ratio <= 1f)
		{
			Vector3 vector = point(ratio) - transform.position;
			float z = Mathf.Atan2(vector.y, vector.x) * 57.29578f;
			transform.eulerAngles = new Vector3(0f, 0f, z);
		}
	}

	public void placeLocal2d(Transform transform, float ratio)
	{
		transform.localPosition = point(ratio);
		ratio += 0.001f;
		if (ratio <= 1f)
		{
			Vector3 vector = point(ratio) - transform.localPosition;
			float z = Mathf.Atan2(vector.y, vector.x) * 57.29578f;
			transform.localEulerAngles = new Vector3(0f, 0f, z);
		}
	}

	public void place(Transform transform, float ratio)
	{
		place(transform, ratio, Vector3.up);
	}

	public void place(Transform transform, float ratio, Vector3 worldUp)
	{
		transform.position = point(ratio);
		ratio += 0.001f;
		if (ratio <= 1f)
		{
			transform.LookAt(point(ratio), worldUp);
		}
	}

	public void placeLocal(Transform transform, float ratio)
	{
		placeLocal(transform, ratio, Vector3.up);
	}

	public void placeLocal(Transform transform, float ratio, Vector3 worldUp)
	{
		ratio = Mathf.Clamp01(ratio);
		transform.localPosition = point(ratio);
		ratio = Mathf.Clamp01(ratio + 0.001f);
		if (ratio <= 1f)
		{
			transform.LookAt(transform.parent.TransformPoint(point(ratio)), worldUp);
		}
	}

	public void gizmoDraw(float t = -1f)
	{
		Vector3 to = point(0f);
		for (int i = 1; i <= 120; i++)
		{
			float ratio = (float)i / 120f;
			Vector3 vector = point(ratio);
			Gizmos.color = ((previousBezier != currentBezier) ? Color.grey : Color.magenta);
			Gizmos.DrawLine(vector, to);
			to = vector;
			previousBezier = currentBezier;
		}
	}

	public float ratioAtPoint(Vector3 pt, float precision = 0.01f)
	{
		float num = float.MaxValue;
		int num2 = 0;
		int num3 = Mathf.RoundToInt(1f / precision);
		for (int i = 0; i < num3; i++)
		{
			float ratio = (float)i / (float)num3;
			float num4 = Vector3.Distance(pt, point(ratio));
			if (num4 < num)
			{
				num = num4;
				num2 = i;
			}
		}
		return (float)num2 / (float)num3;
	}
}
[Serializable]
public class LTSpline
{
	public static int DISTANCE_COUNT = 3;

	public static int SUBLINE_COUNT = 20;

	public float distance;

	public bool constantSpeed = true;

	public Vector3[] pts;

	[NonSerialized]
	public Vector3[] ptsAdj;

	public int ptsAdjLength;

	public bool orientToPath;

	public bool orientToPath2d;

	private int numSections;

	private int currPt;

	public LTSpline(Vector3[] pts)
	{
		init(pts, constantSpeed: true);
	}

	public LTSpline(Vector3[] pts, bool constantSpeed)
	{
		this.constantSpeed = constantSpeed;
		init(pts, constantSpeed);
	}

	private void init(Vector3[] pts, bool constantSpeed)
	{
		if (pts.Length < 4)
		{
			LeanTween.logError("LeanTween - When passing values for a spline path, you must pass four or more values!");
			return;
		}
		this.pts = new Vector3[pts.Length];
		Array.Copy(pts, this.pts, pts.Length);
		numSections = pts.Length - 3;
		float num = float.PositiveInfinity;
		Vector3 b = this.pts[1];
		float num2 = 0f;
		for (int i = 1; i < this.pts.Length - 1; i++)
		{
			float num3 = Vector3.Distance(this.pts[i], b);
			if (num3 < num)
			{
				num = num3;
			}
			num2 += num3;
		}
		if (!constantSpeed)
		{
			return;
		}
		num = num2 / (float)(numSections * SUBLINE_COUNT);
		float num4 = num / (float)SUBLINE_COUNT;
		int num5 = (int)Mathf.Ceil(num2 / num4) * DISTANCE_COUNT;
		if (num5 <= 1)
		{
			num5 = 2;
		}
		ptsAdj = new Vector3[num5];
		b = interp(0f);
		int num6 = 1;
		ptsAdj[0] = b;
		distance = 0f;
		for (int j = 0; j < num5 + 1; j++)
		{
			float num7 = (float)j / (float)num5;
			Vector3 vector = interp(num7);
			float num8 = Vector3.Distance(vector, b);
			if (num8 >= num4 || num7 >= 1f)
			{
				ptsAdj[num6] = vector;
				distance += num8;
				b = vector;
				num6++;
			}
		}
		ptsAdjLength = num6;
	}

	public Vector3 map(float u)
	{
		if (u >= 1f)
		{
			return pts[pts.Length - 2];
		}
		float num = u * (float)(ptsAdjLength - 1);
		int num2 = (int)Mathf.Floor(num);
		int num3 = (int)Mathf.Ceil(num);
		if (num2 < 0)
		{
			num2 = 0;
		}
		Vector3 vector = ptsAdj[num2];
		Vector3 vector2 = ptsAdj[num3];
		float num4 = num - (float)num2;
		return vector + (vector2 - vector) * num4;
	}

	public Vector3 interp(float t)
	{
		currPt = Mathf.Min(Mathf.FloorToInt(t * (float)numSections), numSections - 1);
		float num = t * (float)numSections - (float)currPt;
		Vector3 vector = pts[currPt];
		Vector3 vector2 = pts[currPt + 1];
		Vector3 vector3 = pts[currPt + 2];
		Vector3 vector4 = pts[currPt + 3];
		return 0.5f * ((-vector + 3f * vector2 - 3f * vector3 + vector4) * (num * num * num) + (2f * vector - 5f * vector2 + 4f * vector3 - vector4) * (num * num) + (-vector + vector3) * num + 2f * vector2);
	}

	public float ratioAtPoint(Vector3 pt)
	{
		float num = float.MaxValue;
		int num2 = 0;
		for (int i = 0; i < ptsAdjLength; i++)
		{
			float num3 = Vector3.Distance(pt, ptsAdj[i]);
			if (num3 < num)
			{
				num = num3;
				num2 = i;
			}
		}
		return (float)num2 / (float)(ptsAdjLength - 1);
	}

	public Vector3 point(float ratio)
	{
		float num = ((!(ratio > 1f)) ? ratio : 1f);
		return (!constantSpeed) ? interp(num) : map(num);
	}

	public void place2d(Transform transform, float ratio)
	{
		transform.position = point(ratio);
		ratio += 0.001f;
		if (ratio <= 1f)
		{
			Vector3 vector = point(ratio) - transform.position;
			float z = Mathf.Atan2(vector.y, vector.x) * 57.29578f;
			transform.eulerAngles = new Vector3(0f, 0f, z);
		}
	}

	public void placeLocal2d(Transform transform, float ratio)
	{
		Transform parent = transform.parent;
		if (parent == null)
		{
			place2d(transform, ratio);
			return;
		}
		transform.localPosition = point(ratio);
		ratio += 0.001f;
		if (ratio <= 1f)
		{
			Vector3 vector = point(ratio);
			Vector3 vector2 = vector - transform.localPosition;
			float z = Mathf.Atan2(vector2.y, vector2.x) * 57.29578f;
			transform.localEulerAngles = new Vector3(0f, 0f, z);
		}
	}

	public void place(Transform transform, float ratio)
	{
		place(transform, ratio, Vector3.up);
	}

	public void place(Transform transform, float ratio, Vector3 worldUp)
	{
		transform.position = point(ratio);
		ratio += 0.001f;
		if (ratio <= 1f)
		{
			transform.LookAt(point(ratio), worldUp);
		}
	}

	public void placeLocal(Transform transform, float ratio)
	{
		placeLocal(transform, ratio, Vector3.up);
	}

	public void placeLocal(Transform transform, float ratio, Vector3 worldUp)
	{
		transform.localPosition = point(ratio);
		ratio += 0.001f;
		if (ratio <= 1f)
		{
			transform.LookAt(transform.parent.TransformPoint(point(ratio)), worldUp);
		}
	}

	public void gizmoDraw(float t = -1f)
	{
		if (ptsAdj != null && ptsAdj.Length > 0)
		{
			Vector3 from = ptsAdj[0];
			for (int i = 0; i < ptsAdjLength; i++)
			{
				Vector3 vector = ptsAdj[i];
				Gizmos.DrawLine(from, vector);
				from = vector;
			}
		}
	}

	public void drawGizmo(Color color)
	{
		if (ptsAdjLength >= 4)
		{
			Vector3 from = ptsAdj[0];
			Color color2 = Gizmos.color;
			Gizmos.color = color;
			for (int i = 0; i < ptsAdjLength; i++)
			{
				Vector3 vector = ptsAdj[i];
				Gizmos.DrawLine(from, vector);
				from = vector;
			}
			Gizmos.color = color2;
		}
	}

	public static void drawGizmo(Transform[] arr, Color color)
	{
		if (arr.Length >= 4)
		{
			Vector3[] array = new Vector3[arr.Length];
			for (int i = 0; i < arr.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = arr[i].position;
			}
			LTSpline lTSpline = new LTSpline(array);
			Vector3 from = lTSpline.ptsAdj[0];
			Color color2 = Gizmos.color;
			Gizmos.color = color;
			for (int j = 0; j < lTSpline.ptsAdjLength; j++)
			{
				Vector3 vector = lTSpline.ptsAdj[j];
				Gizmos.DrawLine(from, vector);
				from = vector;
			}
			Gizmos.color = color2;
		}
	}

	public static void drawLine(Transform[] arr, float width, Color color)
	{
		if (arr.Length < 4)
		{
		}
	}

	public void drawLinesGLLines(Material outlineMaterial, Color color, float width)
	{
		GL.PushMatrix();
		outlineMaterial.SetPass(0);
		GL.LoadPixelMatrix();
		GL.Begin(1);
		GL.Color(color);
		if (constantSpeed)
		{
			if (ptsAdjLength >= 4)
			{
				Vector3 v = ptsAdj[0];
				for (int i = 0; i < ptsAdjLength; i++)
				{
					Vector3 vector = ptsAdj[i];
					GL.Vertex(v);
					GL.Vertex(vector);
					v = vector;
				}
			}
		}
		else if (pts.Length >= 4)
		{
			Vector3 v2 = pts[0];
			float num = 1f / ((float)pts.Length * 10f);
			for (float num2 = 0f; num2 < 1f; num2 += num)
			{
				float t = num2 / 1f;
				Vector3 vector2 = interp(t);
				GL.Vertex(v2);
				GL.Vertex(vector2);
				v2 = vector2;
			}
		}
		GL.End();
		GL.PopMatrix();
	}

	public Vector3[] generateVectors()
	{
		if (pts.Length >= 4)
		{
			List<Vector3> list = new List<Vector3>();
			Vector3 item = pts[0];
			list.Add(item);
			float num = 1f / ((float)pts.Length * 10f);
			for (float num2 = 0f; num2 < 1f; num2 += num)
			{
				float t = num2 / 1f;
				Vector3 item2 = interp(t);
				list.Add(item2);
			}
			list.ToArray();
		}
		return null;
	}
}
[Serializable]
public class LTRect
{
	public Rect _rect;

	public float alpha = 1f;

	public float rotation;

	public Vector2 pivot;

	public Vector2 margin;

	public Rect relativeRect = new Rect(0f, 0f, float.PositiveInfinity, float.PositiveInfinity);

	public bool rotateEnabled;

	[HideInInspector]
	public bool rotateFinished;

	public bool alphaEnabled;

	public string labelStr;

	public LTGUI.Element_Type type;

	public GUIStyle style;

	public bool useColor;

	public Color color = Color.white;

	public bool fontScaleToFit;

	public bool useSimpleScale;

	public bool sizeByHeight;

	public Texture texture;

	private int _id = -1;

	[HideInInspector]
	public int counter;

	public static bool colorTouched;

	public bool hasInitiliazed => _id != -1;

	public int id => _id | (counter << 16);

	public float x
	{
		get
		{
			return _rect.x;
		}
		set
		{
			_rect.x = value;
		}
	}

	public float y
	{
		get
		{
			return _rect.y;
		}
		set
		{
			_rect.y = value;
		}
	}

	public float width
	{
		get
		{
			return _rect.width;
		}
		set
		{
			_rect.width = value;
		}
	}

	public float height
	{
		get
		{
			return _rect.height;
		}
		set
		{
			_rect.height = value;
		}
	}

	public Rect rect
	{
		get
		{
			if (colorTouched)
			{
				colorTouched = false;
				GUI.color = new Color(GUI.color.r, GUI.color.g, GUI.color.b, 1f);
			}
			if (rotateEnabled)
			{
				if (rotateFinished)
				{
					rotateFinished = false;
					rotateEnabled = false;
					pivot = Vector2.zero;
				}
				else
				{
					GUIUtility.RotateAroundPivot(rotation, pivot);
				}
			}
			if (alphaEnabled)
			{
				GUI.color = new Color(GUI.color.r, GUI.color.g, GUI.color.b, alpha);
				colorTouched = true;
			}
			if (fontScaleToFit)
			{
				if (useSimpleScale)
				{
					style.fontSize = (int)(_rect.height * relativeRect.height);
				}
				else
				{
					style.fontSize = (int)_rect.height;
				}
			}
			return _rect;
		}
		set
		{
			_rect = value;
		}
	}

	public LTRect()
	{
		reset();
		rotateEnabled = (alphaEnabled = true);
		_rect = new Rect(0f, 0f, 1f, 1f);
	}

	public LTRect(Rect rect)
	{
		_rect = rect;
		reset();
	}

	public LTRect(float x, float y, float width, float height)
	{
		_rect = new Rect(x, y, width, height);
		alpha = 1f;
		rotation = 0f;
		rotateEnabled = (alphaEnabled = false);
	}

	public LTRect(float x, float y, float width, float height, float alpha)
	{
		_rect = new Rect(x, y, width, height);
		this.alpha = alpha;
		rotation = 0f;
		rotateEnabled = (alphaEnabled = false);
	}

	public LTRect(float x, float y, float width, float height, float alpha, float rotation)
	{
		_rect = new Rect(x, y, width, height);
		this.alpha = alpha;
		this.rotation = rotation;
		rotateEnabled = (alphaEnabled = false);
		if (rotation != 0f)
		{
			rotateEnabled = true;
			resetForRotation();
		}
	}

	public void setId(int id, int counter)
	{
		_id = id;
		this.counter = counter;
	}

	public void reset()
	{
		alpha = 1f;
		rotation = 0f;
		rotateEnabled = (alphaEnabled = false);
		margin = Vector2.zero;
		sizeByHeight = false;
		useColor = false;
	}

	public void resetForRotation()
	{
		Vector3 vector = new Vector3(GUI.matrix[0, 0], GUI.matrix[1, 1], GUI.matrix[2, 2]);
		if (pivot == Vector2.zero)
		{
			pivot = new Vector2((_rect.x + _rect.width * 0.5f) * vector.x + GUI.matrix[0, 3], (_rect.y + _rect.height * 0.5f) * vector.y + GUI.matrix[1, 3]);
		}
	}

	public LTRect setStyle(GUIStyle style)
	{
		this.style = style;
		return this;
	}

	public LTRect setFontScaleToFit(bool fontScaleToFit)
	{
		this.fontScaleToFit = fontScaleToFit;
		return this;
	}

	public LTRect setColor(Color color)
	{
		this.color = color;
		useColor = true;
		return this;
	}

	public LTRect setAlpha(float alpha)
	{
		this.alpha = alpha;
		return this;
	}

	public LTRect setLabel(string str)
	{
		labelStr = str;
		return this;
	}

	public LTRect setUseSimpleScale(bool useSimpleScale, Rect relativeRect)
	{
		this.useSimpleScale = useSimpleScale;
		this.relativeRect = relativeRect;
		return this;
	}

	public LTRect setUseSimpleScale(bool useSimpleScale)
	{
		this.useSimpleScale = useSimpleScale;
		relativeRect = new Rect(0f, 0f, Screen.width, Screen.height);
		return this;
	}

	public LTRect setSizeByHeight(bool sizeByHeight)
	{
		this.sizeByHeight = sizeByHeight;
		return this;
	}

	public override string ToString()
	{
		return "x:" + _rect.x + " y:" + _rect.y + " width:" + _rect.width + " height:" + _rect.height;
	}
}
public class LTEvent
{
	public int id;

	public object data;

	public LTEvent(int id, object data)
	{
		this.id = id;
		this.data = data;
	}
}
public class LTGUI
{
	public enum Element_Type
	{
		Texture,
		Label
	}

	public static int RECT_LEVELS = 5;

	public static int RECTS_PER_LEVEL = 10;

	public static int BUTTONS_MAX = 24;

	private static LTRect[] levels;

	private static int[] levelDepths;

	private static Rect[] buttons;

	private static int[] buttonLevels;

	private static int[] buttonLastFrame;

	private static LTRect r;

	private static Color color = Color.white;

	private static bool isGUIEnabled = false;

	private static int global_counter = 0;

	public static void init()
	{
		if (levels == null)
		{
			levels = new LTRect[RECT_LEVELS * RECTS_PER_LEVEL];
			levelDepths = new int[RECT_LEVELS];
		}
	}

	public static void initRectCheck()
	{
		if (buttons == null)
		{
			buttons = new Rect[BUTTONS_MAX];
			buttonLevels = new int[BUTTONS_MAX];
			buttonLastFrame = new int[BUTTONS_MAX];
			for (int i = 0; i < buttonLevels.Length; i++)
			{
				buttonLevels[i] = -1;
			}
		}
	}

	public static void reset()
	{
		if (isGUIEnabled)
		{
			isGUIEnabled = false;
			for (int i = 0; i < levels.Length; i++)
			{
				levels[i] = null;
			}
			for (int j = 0; j < levelDepths.Length; j++)
			{
				levelDepths[j] = 0;
			}
		}
	}

	public static void update(int updateLevel)
	{
		if (!isGUIEnabled)
		{
			return;
		}
		init();
		if (levelDepths[updateLevel] <= 0)
		{
			return;
		}
		color = GUI.color;
		int num = updateLevel * RECTS_PER_LEVEL;
		int num2 = num + levelDepths[updateLevel];
		for (int i = num; i < num2; i++)
		{
			r = levels[i];
			if (r == null)
			{
				continue;
			}
			if (r.useColor)
			{
				GUI.color = r.color;
			}
			if (r.type == Element_Type.Label)
			{
				if (r.style != null)
				{
					GUI.skin.label = r.style;
				}
				if (r.useSimpleScale)
				{
					GUI.Label(new Rect((r.rect.x + r.margin.x + r.relativeRect.x) * r.relativeRect.width, (r.rect.y + r.margin.y + r.relativeRect.y) * r.relativeRect.height, r.rect.width * r.relativeRect.width, r.rect.height * r.relativeRect.height), r.labelStr);
				}
				else
				{
					GUI.Label(new Rect(r.rect.x + r.margin.x, r.rect.y + r.margin.y, r.rect.width, r.rect.height), r.labelStr);
				}
			}
			else if (r.type == Element_Type.Texture && r.texture != null)
			{
				Vector2 vector = ((!r.useSimpleScale) ? new Vector2(r.rect.width, r.rect.height) : new Vector2(0f, r.rect.height * r.relativeRect.height));
				if (r.sizeByHeight)
				{
					vector.x = (float)r.texture.width / (float)r.texture.height * vector.y;
				}
				if (r.useSimpleScale)
				{
					GUI.DrawTexture(new Rect((r.rect.x + r.margin.x + r.relativeRect.x) * r.relativeRect.width, (r.rect.y + r.margin.y + r.relativeRect.y) * r.relativeRect.height, vector.x, vector.y), r.texture);
				}
				else
				{
					GUI.DrawTexture(new Rect(r.rect.x + r.margin.x, r.rect.y + r.margin.y, vector.x, vector.y), r.texture);
				}
			}
		}
		GUI.color = color;
	}

	public static bool checkOnScreen(Rect rect)
	{
		bool flag = rect.x + rect.width < 0f;
		bool flag2 = rect.x > (float)Screen.width;
		bool flag3 = rect.y > (float)Screen.height;
		bool flag4 = rect.y + rect.height < 0f;
		return !flag && !flag2 && !flag3 && !flag4;
	}

	public static void destroy(int id)
	{
		int num = id & 0xFFFF;
		int num2 = id >> 16;
		if (id >= 0 && levels[num] != null && levels[num].hasInitiliazed && levels[num].counter == num2)
		{
			levels[num] = null;
		}
	}

	public static void destroyAll(int depth)
	{
		int num = depth * RECTS_PER_LEVEL + RECTS_PER_LEVEL;
		int num2 = depth * RECTS_PER_LEVEL;
		while (levels != null && num2 < num)
		{
			levels[num2] = null;
			num2++;
		}
	}

	public static LTRect label(Rect rect, string label, int depth)
	{
		return LTGUI.label(new LTRect(rect), label, depth);
	}

	public static LTRect label(LTRect rect, string label, int depth)
	{
		rect.type = Element_Type.Label;
		rect.labelStr = label;
		return element(rect, depth);
	}

	public static LTRect texture(Rect rect, Texture texture, int depth)
	{
		return LTGUI.texture(new LTRect(rect), texture, depth);
	}

	public static LTRect texture(LTRect rect, Texture texture, int depth)
	{
		rect.type = Element_Type.Texture;
		rect.texture = texture;
		return element(rect, depth);
	}

	public static LTRect element(LTRect rect, int depth)
	{
		isGUIEnabled = true;
		init();
		int num = depth * RECTS_PER_LEVEL + RECTS_PER_LEVEL;
		int num2 = 0;
		if (rect != null)
		{
			destroy(rect.id);
		}
		if (rect.type == Element_Type.Label && rect.style != null && rect.style.normal.textColor.a <= 0f)
		{
			UnityEngine.Debug.LogWarning("Your GUI normal color has an alpha of zero, and will not be rendered.");
		}
		if (rect.relativeRect.width == float.PositiveInfinity)
		{
			rect.relativeRect = new Rect(0f, 0f, Screen.width, Screen.height);
		}
		for (int i = depth * RECTS_PER_LEVEL; i < num; i++)
		{
			r = levels[i];
			if (r == null)
			{
				r = rect;
				r.rotateEnabled = true;
				r.alphaEnabled = true;
				r.setId(i, global_counter);
				levels[i] = r;
				if (num2 >= levelDepths[depth])
				{
					levelDepths[depth] = num2 + 1;
				}
				global_counter++;
				return r;
			}
			num2++;
		}
		UnityEngine.Debug.LogError("You ran out of GUI Element spaces");
		return null;
	}

	public static bool hasNoOverlap(Rect rect, int depth)
	{
		initRectCheck();
		bool result = true;
		bool flag = false;
		for (int i = 0; i < buttonLevels.Length; i++)
		{
			if (buttonLevels[i] >= 0)
			{
				if (buttonLastFrame[i] + 1 < Time.frameCount)
				{
					buttonLevels[i] = -1;
				}
				else if (buttonLevels[i] > depth && pressedWithinRect(buttons[i]))
				{
					result = false;
				}
			}
			if (!flag && buttonLevels[i] < 0)
			{
				flag = true;
				buttonLevels[i] = depth;
				buttons[i] = rect;
				buttonLastFrame[i] = Time.frameCount;
			}
		}
		return result;
	}

	public static bool pressedWithinRect(Rect rect)
	{
		Vector2 vector = firstTouch();
		if (vector.x < 0f)
		{
			return false;
		}
		float num = (float)Screen.height - vector.y;
		return vector.x > rect.x && vector.x < rect.x + rect.width && num > rect.y && num < rect.y + rect.height;
	}

	public static bool checkWithinRect(Vector2 vec2, Rect rect)
	{
		vec2.y = (float)Screen.height - vec2.y;
		return vec2.x > rect.x && vec2.x < rect.x + rect.width && vec2.y > rect.y && vec2.y < rect.y + rect.height;
	}

	public static Vector2 firstTouch()
	{
		if (Input.touchCount > 0)
		{
			return Input.touches[0].position;
		}
		if (Input.GetMouseButton(0))
		{
			return Input.mousePosition;
		}
		return new Vector2(float.NegativeInfinity, float.NegativeInfinity);
	}
}
namespace DentedPixel
{
	public class LeanDummy
	{
	}
}
public static class LeanTweenExt
{
	public static LTDescr LeanAlpha(this GameObject gameObject, float to, float time)
	{
		return LeanTween.alpha(gameObject, to, time);
	}

	public static LTDescr LeanAlphaVertex(this GameObject gameObject, float to, float time)
	{
		return LeanTween.alphaVertex(gameObject, to, time);
	}

	public static LTDescr LeanAlpha(this RectTransform rectTransform, float to, float time)
	{
		return LeanTween.alpha(rectTransform, to, time);
	}

	public static LTDescr LeanAlpha(this CanvasGroup canvas, float to, float time)
	{
		return LeanTween.alphaCanvas(canvas, to, time);
	}

	public static LTDescr LeanAlphaText(this RectTransform rectTransform, float to, float time)
	{
		return LeanTween.alphaText(rectTransform, to, time);
	}

	public static void LeanCancel(this GameObject gameObject)
	{
		LeanTween.cancel(gameObject);
	}

	public static void LeanCancel(this GameObject gameObject, bool callOnComplete)
	{
		LeanTween.cancel(gameObject, callOnComplete);
	}

	public static void LeanCancel(this GameObject gameObject, int uniqueId, bool callOnComplete = false)
	{
		LeanTween.cancel(gameObject, uniqueId, callOnComplete);
	}

	public static void LeanCancel(this RectTransform rectTransform)
	{
		LeanTween.cancel(rectTransform);
	}

	public static LTDescr LeanColor(this GameObject gameObject, Color to, float time)
	{
		return LeanTween.color(gameObject, to, time);
	}

	public static LTDescr LeanColorText(this RectTransform rectTransform, Color to, float time)
	{
		return LeanTween.colorText(rectTransform, to, time);
	}

	public static LTDescr LeanDelayedCall(this GameObject gameObject, float delayTime, Action callback)
	{
		return LeanTween.delayedCall(gameObject, delayTime, callback);
	}

	public static LTDescr LeanDelayedCall(this GameObject gameObject, float delayTime, Action<object> callback)
	{
		return LeanTween.delayedCall(gameObject, delayTime, callback);
	}

	public static bool LeanIsPaused(this GameObject gameObject)
	{
		return LeanTween.isPaused(gameObject);
	}

	public static bool LeanIsPaused(this RectTransform rectTransform)
	{
		return LeanTween.isPaused(rectTransform);
	}

	public static bool LeanIsTweening(this GameObject gameObject)
	{
		return LeanTween.isTweening(gameObject);
	}

	public static LTDescr LeanMove(this GameObject gameObject, Vector3 to, float time)
	{
		return LeanTween.move(gameObject, to, time);
	}

	public static LTDescr LeanMove(this Transform transform, Vector3 to, float time)
	{
		return LeanTween.move(transform.gameObject, to, time);
	}

	public static LTDescr LeanMove(this RectTransform rectTransform, Vector3 to, float time)
	{
		return LeanTween.move(rectTransform, to, time);
	}

	public static LTDescr LeanMove(this GameObject gameObject, Vector2 to, float time)
	{
		return LeanTween.move(gameObject, to, time);
	}

	public static LTDescr LeanMove(this Transform transform, Vector2 to, float time)
	{
		return LeanTween.move(transform.gameObject, to, time);
	}

	public static LTDescr LeanMove(this GameObject gameObject, Vector3[] to, float time)
	{
		return LeanTween.move(gameObject, to, time);
	}

	public static LTDescr LeanMove(this GameObject gameObject, LTBezierPath to, float time)
	{
		return LeanTween.move(gameObject, to, time);
	}

	public static LTDescr LeanMove(this GameObject gameObject, LTSpline to, float time)
	{
		return LeanTween.move(gameObject, to, time);
	}

	public static LTDescr LeanMove(this Transform transform, Vector3[] to, float time)
	{
		return LeanTween.move(transform.gameObject, to, time);
	}

	public static LTDescr LeanMove(this Transform transform, LTBezierPath to, float time)
	{
		return LeanTween.move(transform.gameObject, to, time);
	}

	public static LTDescr LeanMove(this Transform transform, LTSpline to, float time)
	{
		return LeanTween.move(transform.gameObject, to, time);
	}

	public static LTDescr LeanMoveLocal(this GameObject gameObject, Vector3 to, float time)
	{
		return LeanTween.moveLocal(gameObject, to, time);
	}

	public static LTDescr LeanMoveLocal(this GameObject gameObject, LTBezierPath to, float time)
	{
		return LeanTween.moveLocal(gameObject, to, time);
	}

	public static LTDescr LeanMoveLocal(this GameObject gameObject, LTSpline to, float time)
	{
		return LeanTween.moveLocal(gameObject, to, time);
	}

	public static LTDescr LeanMoveLocal(this Transform transform, Vector3 to, float time)
	{
		return LeanTween.moveLocal(transform.gameObject, to, time);
	}

	public static LTDescr LeanMoveLocal(this Transform transform, LTBezierPath to, float time)
	{
		return LeanTween.moveLocal(transform.gameObject, to, time);
	}

	public static LTDescr LeanMoveLocal(this Transform transform, LTSpline to, float time)
	{
		return LeanTween.moveLocal(transform.gameObject, to, time);
	}

	public static LTDescr LeanMoveLocalX(this GameObject gameObject, float to, float time)
	{
		return LeanTween.moveLocalX(gameObject, to, time);
	}

	public static LTDescr LeanMoveLocalY(this GameObject gameObject, float to, float time)
	{
		return LeanTween.moveLocalY(gameObject, to, time);
	}

	public static LTDescr LeanMoveLocalZ(this GameObject gameObject, float to, float time)
	{
		return LeanTween.moveLocalZ(gameObject, to, time);
	}

	public static LTDescr LeanMoveLocalX(this Transform transform, float to, float time)
	{
		return LeanTween.moveLocalX(transform.gameObject, to, time);
	}

	public static LTDescr LeanMoveLocalY(this Transform transform, float to, float time)
	{
		return LeanTween.moveLocalY(transform.gameObject, to, time);
	}

	public static LTDescr LeanMoveLocalZ(this Transform transform, float to, float time)
	{
		return LeanTween.moveLocalZ(transform.gameObject, to, time);
	}

	public static LTDescr LeanMoveSpline(this GameObject gameObject, Vector3[] to, float time)
	{
		return LeanTween.moveSpline(gameObject, to, time);
	}

	public static LTDescr LeanMoveSpline(this GameObject gameObject, LTSpline to, float time)
	{
		return LeanTween.moveSpline(gameObject, to, time);
	}

	public static LTDescr LeanMoveSpline(this Transform transform, Vector3[] to, float time)
	{
		return LeanTween.moveSpline(transform.gameObject, to, time);
	}

	public static LTDescr LeanMoveSpline(this Transform transform, LTSpline to, float time)
	{
		return LeanTween.moveSpline(transform.gameObject, to, time);
	}

	public static LTDescr LeanMoveSplineLocal(this GameObject gameObject, Vector3[] to, float time)
	{
		return LeanTween.moveSplineLocal(gameObject, to, time);
	}

	public static LTDescr LeanMoveSplineLocal(this Transform transform, Vector3[] to, float time)
	{
		return LeanTween.moveSplineLocal(transform.gameObject, to, time);
	}

	public static LTDescr LeanMoveX(this GameObject gameObject, float to, float time)
	{
		return LeanTween.moveX(gameObject, to, time);
	}

	public static LTDescr LeanMoveX(this Transform transform, float to, float time)
	{
		return LeanTween.moveX(transform.gameObject, to, time);
	}

	public static LTDescr LeanMoveX(this RectTransform rectTransform, float to, float time)
	{
		return LeanTween.moveX(rectTransform, to, time);
	}

	public static LTDescr LeanMoveY(this GameObject gameObject, float to, float time)
	{
		return LeanTween.moveY(gameObject, to, time);
	}

	public static LTDescr LeanMoveY(this Transform transform, float to, float time)
	{
		return LeanTween.moveY(transform.gameObject, to, time);
	}

	public static LTDescr LeanMoveY(this RectTransform rectTransform, float to, float time)
	{
		return LeanTween.moveY(rectTransform, to, time);
	}

	public static LTDescr LeanMoveZ(this GameObject gameObject, float to, float time)
	{
		return LeanTween.moveZ(gameObject, to, time);
	}

	public static LTDescr LeanMoveZ(this Transform transform, float to, float time)
	{
		return LeanTween.moveZ(transform.gameObject, to, time);
	}

	public static LTDescr LeanMoveZ(this RectTransform rectTransform, float to, float time)
	{
		return LeanTween.moveZ(rectTransform, to, time);
	}

	public static void LeanPause(this GameObject gameObject)
	{
		LeanTween.pause(gameObject);
	}

	public static LTDescr LeanPlay(this RectTransform rectTransform, Sprite[] sprites)
	{
		return LeanTween.play(rectTransform, sprites);
	}

	public static void LeanResume(this GameObject gameObject)
	{
		LeanTween.resume(gameObject);
	}

	public static LTDescr LeanRotate(this GameObject gameObject, Vector3 to, float time)
	{
		return LeanTween.rotate(gameObject, to, time);
	}

	public static LTDescr LeanRotate(this Transform transform, Vector3 to, float time)
	{
		return LeanTween.rotate(transform.gameObject, to, time);
	}

	public static LTDescr LeanRotate(this RectTransform rectTransform, Vector3 to, float time)
	{
		return LeanTween.rotate(rectTransform, to, time);
	}

	public static LTDescr LeanRotateAround(this GameObject gameObject, Vector3 axis, float add, float time)
	{
		return LeanTween.rotateAround(gameObject, axis, add, time);
	}

	public static LTDescr LeanRotateAround(this Transform transform, Vector3 axis, float add, float time)
	{
		return LeanTween.rotateAround(transform.gameObject, axis, add, time);
	}

	public static LTDescr LeanRotateAround(this RectTransform rectTransform, Vector3 axis, float add, float time)
	{
		return LeanTween.rotateAround(rectTransform, axis, add, time);
	}

	public static LTDescr LeanRotateAroundLocal(this GameObject gameObject, Vector3 axis, float add, float time)
	{
		return LeanTween.rotateAroundLocal(gameObject, axis, add, time);
	}

	public static LTDescr LeanRotateAroundLocal(this Transform transform, Vector3 axis, float add, float time)
	{
		return LeanTween.rotateAroundLocal(transform.gameObject, axis, add, time);
	}

	public static LTDescr LeanRotateAroundLocal(this RectTransform rectTransform, Vector3 axis, float add, float time)
	{
		return LeanTween.rotateAroundLocal(rectTransform, axis, add, time);
	}

	public static LTDescr LeanRotateX(this GameObject gameObject, float to, float time)
	{
		return LeanTween.rotateX(gameObject, to, time);
	}

	public static LTDescr LeanRotateX(this Transform transform, float to, float time)
	{
		return LeanTween.rotateX(transform.gameObject, to, time);
	}

	public static LTDescr LeanRotateY(this GameObject gameObject, float to, float time)
	{
		return LeanTween.rotateY(gameObject, to, time);
	}

	public static LTDescr LeanRotateY(this Transform transform, float to, float time)
	{
		return LeanTween.rotateY(transform.gameObject, to, time);
	}

	public static LTDescr LeanRotateZ(this GameObject gameObject, float to, float time)
	{
		return LeanTween.rotateZ(gameObject, to, time);
	}

	public static LTDescr LeanRotateZ(this Transform transform, float to, float time)
	{
		return LeanTween.rotateZ(transform.gameObject, to, time);
	}

	public static LTDescr LeanScale(this GameObject gameObject, Vector3 to, float time)
	{
		return LeanTween.scale(gameObject, to, time);
	}

	public static LTDescr LeanScale(this Transform transform, Vector3 to, float time)
	{
		return LeanTween.scale(transform.gameObject, to, time);
	}

	public static LTDescr LeanScale(this RectTransform rectTransform, Vector3 to, float time)
	{
		return LeanTween.scale(rectTransform, to, time);
	}

	public static LTDescr LeanScaleX(this GameObject gameObject, float to, float time)
	{
		return LeanTween.scaleX(gameObject, to, time);
	}

	public static LTDescr LeanScaleX(this Transform transform, float to, float time)
	{
		return LeanTween.scaleX(transform.gameObject, to, time);
	}

	public static LTDescr LeanScaleY(this GameObject gameObject, float to, float time)
	{
		return LeanTween.scaleY(gameObject, to, time);
	}

	public static LTDescr LeanScaleY(this Transform transform, float to, float time)
	{
		return LeanTween.scaleY(transform.gameObject, to, time);
	}

	public static LTDescr LeanScaleZ(this GameObject gameObject, float to, float time)
	{
		return LeanTween.scaleZ(gameObject, to, time);
	}

	public static LTDescr LeanScaleZ(this Transform transform, float to, float time)
	{
		return LeanTween.scaleZ(transform.gameObject, to, time);
	}

	public static LTDescr LeanSize(this RectTransform rectTransform, Vector2 to, float time)
	{
		return LeanTween.size(rectTransform, to, time);
	}

	public static LTDescr LeanValue(this GameObject gameObject, Color from, Color to, float time)
	{
		return LeanTween.value(gameObject, from, to, time);
	}

	public static LTDescr LeanValue(this GameObject gameObject, float from, float to, float time)
	{
		return LeanTween.value(gameObject, from, to, time);
	}

	public static LTDescr LeanValue(this GameObject gameObject, Vector2 from, Vector2 to, float time)
	{
		return LeanTween.value(gameObject, from, to, time);
	}

	public static LTDescr LeanValue(this GameObject gameObject, Vector3 from, Vector3 to, float time)
	{
		return LeanTween.value(gameObject, from, to, time);
	}

	public static LTDescr LeanValue(this GameObject gameObject, Action<float> callOnUpdate, float from, float to, float time)
	{
		return LeanTween.value(gameObject, callOnUpdate, from, to, time);
	}

	public static LTDescr LeanValue(this GameObject gameObject, Action<float, float> callOnUpdate, float from, float to, float time)
	{
		return LeanTween.value(gameObject, callOnUpdate, from, to, time);
	}

	public static LTDescr LeanValue(this GameObject gameObject, Action<float, object> callOnUpdate, float from, float to, float time)
	{
		return LeanTween.value(gameObject, callOnUpdate, from, to, time);
	}

	public static LTDescr LeanValue(this GameObject gameObject, Action<Color> callOnUpdate, Color from, Color to, float time)
	{
		return LeanTween.value(gameObject, callOnUpdate, from, to, time);
	}

	public static LTDescr LeanValue(this GameObject gameObject, Action<Vector2> callOnUpdate, Vector2 from, Vector2 to, float time)
	{
		return LeanTween.value(gameObject, callOnUpdate, from, to, time);
	}

	public static LTDescr LeanValue(this GameObject gameObject, Action<Vector3> callOnUpdate, Vector3 from, Vector3 to, float time)
	{
		return LeanTween.value(gameObject, callOnUpdate, from, to, time);
	}

	public static void LeanSetPosX(this Transform transform, float val)
	{
		transform.position = new Vector3(val, transform.position.y, transform.position.z);
	}

	public static void LeanSetPosY(this Transform transform, float val)
	{
		transform.position = new Vector3(transform.position.x, val, transform.position.z);
	}

	public static void LeanSetPosZ(this Transform transform, float val)
	{
		transform.position = new Vector3(transform.position.x, transform.position.y, val);
	}

	public static void LeanSetLocalPosX(this Transform transform, float val)
	{
		transform.localPosition = new Vector3(val, transform.localPosition.y, transform.localPosition.z);
	}

	public static void LeanSetLocalPosY(this Transform transform, float val)
	{
		transform.localPosition = new Vector3(transform.localPosition.x, val, transform.localPosition.z);
	}

	public static void LeanSetLocalPosZ(this Transform transform, float val)
	{
		transform.localPosition = new Vector3(transform.localPosition.x, transform.localPosition.y, val);
	}

	public static Color LeanColor(this Transform transform)
	{
		return transform.GetComponent<Renderer>().material.color;
	}
}
public class LTDescr
{
	public delegate Vector3 EaseTypeDelegate();

	public delegate void ActionMethodDelegate();

	public bool toggle;

	public bool useEstimatedTime;

	public bool useFrames;

	public bool useManualTime;

	public bool usesNormalDt;

	public bool hasInitiliazed;

	public bool hasExtraOnCompletes;

	public bool hasPhysics;

	public bool onCompleteOnRepeat;

	public bool onCompleteOnStart;

	public bool useRecursion;

	public float ratioPassed;

	public float passed;

	public float delay;

	public float time;

	public float speed;

	public float lastVal;

	private uint _id;

	public int loopCount;

	public uint counter = uint.MaxValue;

	public float direction;

	public float directionLast;

	public float overshoot;

	public float period;

	public float scale;

	public bool destroyOnComplete;

	public Transform trans;

	internal Vector3 fromInternal;

	internal Vector3 toInternal;

	internal Vector3 diff;

	internal Vector3 diffDiv2;

	public TweenAction type;

	private LeanTweenType easeType;

	public LeanTweenType loopType;

	public bool hasUpdateCallback;

	public EaseTypeDelegate easeMethod;

	public SpriteRenderer spriteRen;

	public RectTransform rectTransform;

	public Text uiText;

	public Image uiImage;

	public RawImage rawImage;

	public Sprite[] sprites;

	public LTDescrOptional _optional = new LTDescrOptional();

	public static float val;

	public static float dt;

	public static Vector3 newVect;

	public Vector3 from
	{
		get
		{
			return fromInternal;
		}
		set
		{
			fromInternal = value;
		}
	}

	public Vector3 to
	{
		get
		{
			return toInternal;
		}
		set
		{
			toInternal = value;
		}
	}

	public ActionMethodDelegate easeInternal { get; set; }

	public ActionMethodDelegate initInternal { get; set; }

	public Transform toTrans => optional.toTrans;

	public int uniqueId => (int)(_id | (counter << 16));

	public int id => uniqueId;

	public LTDescrOptional optional
	{
		get
		{
			return _optional;
		}
		set
		{
			_optional = value;
		}
	}

	public override string ToString()
	{
		return string.Concat((!(trans != null)) ? "gameObject:null" : ("name:" + trans.gameObject.name), " toggle:", toggle, " passed:", passed, " time:", time, " delay:", delay, " direction:", direction, " from:", from, " to:", to, " diff:", diff, " type:", type, " ease:", easeType, " useEstimatedTime:", useEstimatedTime, " id:", id, " hasInitiliazed:", hasInitiliazed);
	}

	[Obsolete("Use 'LeanTween.cancel( id )' instead")]
	public LTDescr cancel(GameObject gameObject)
	{
		if (gameObject == trans.gameObject)
		{
			LeanTween.removeTween((int)_id, uniqueId);
		}
		return this;
	}

	public void reset()
	{
		toggle = (useRecursion = (usesNormalDt = true));
		trans = null;
		spriteRen = null;
		passed = (delay = (lastVal = 0f));
		hasUpdateCallback = (useEstimatedTime = (useFrames = (hasInitiliazed = (onCompleteOnRepeat = (destroyOnComplete = (onCompleteOnStart = (useManualTime = (hasExtraOnCompletes = false))))))));
		easeType = LeanTweenType.linear;
		loopType = LeanTweenType.once;
		loopCount = 0;
		direction = (directionLast = (overshoot = (scale = 1f)));
		period = 0.3f;
		speed = -1f;
		easeMethod = easeLinear;
		Vector3 vector = (to = Vector3.zero);
		from = vector;
		_optional.reset();
	}

	public LTDescr setFollow()
	{
		type = TweenAction.FOLLOW;
		return this;
	}

	public LTDescr setMoveX()
	{
		type = TweenAction.MOVE_X;
		initInternal = delegate
		{
			fromInternal.x = trans.position.x;
		};
		easeInternal = delegate
		{
			trans.position = new Vector3(easeMethod().x, trans.position.y, trans.position.z);
		};
		return this;
	}

	public LTDescr setMoveY()
	{
		type = TweenAction.MOVE_Y;
		initInternal = delegate
		{
			fromInternal.x = trans.position.y;
		};
		easeInternal = delegate
		{
			trans.position = new Vector3(trans.position.x, easeMethod().x, trans.position.z);
		};
		return this;
	}

	public LTDescr setMoveZ()
	{
		type = TweenAction.MOVE_Z;
		initInternal = delegate
		{
			fromInternal.x = trans.position.z;
		};
		easeInternal = delegate
		{
			trans.position = new Vector3(trans.position.x, trans.position.y, easeMethod().x);
		};
		return this;
	}

	public LTDescr setMoveLocalX()
	{
		type = TweenAction.MOVE_LOCAL_X;
		initInternal = delegate
		{
			fromInternal.x = trans.localPosition.x;
		};
		easeInternal = delegate
		{
			trans.localPosition = new Vector3(easeMethod().x, trans.localPosition.y, trans.localPosition.z);
		};
		return this;
	}

	public LTDescr setMoveLocalY()
	{
		type = TweenAction.MOVE_LOCAL_Y;
		initInternal = delegate
		{
			fromInternal.x = trans.localPosition.y;
		};
		easeInternal = delegate
		{
			trans.localPosition = new Vector3(trans.localPosition.x, easeMethod().x, trans.localPosition.z);
		};
		return this;
	}

	public LTDescr setMoveLocalZ()
	{
		type = TweenAction.MOVE_LOCAL_Z;
		initInternal = delegate
		{
			fromInternal.x = trans.localPosition.z;
		};
		easeInternal = delegate
		{
			trans.localPosition = new Vector3(trans.localPosition.x, trans.localPosition.y, easeMethod().x);
		};
		return this;
	}

	private void initFromInternal()
	{
		fromInternal.x = 0f;
	}

	public LTDescr setOffset(Vector3 offset)
	{
		toInternal = offset;
		return this;
	}

	public LTDescr setMoveCurved()
	{
		type = TweenAction.MOVE_CURVED;
		initInternal = initFromInternal;
		easeInternal = delegate
		{
			newVect = easeMethod();
			val = newVect.x;
			if (_optional.path.orientToPath)
			{
				if (_optional.path.orientToPath2d)
				{
					_optional.path.place2d(trans, val);
				}
				else
				{
					_optional.path.place(trans, val);
				}
			}
			else
			{
				trans.position = _optional.path.point(val);
			}
		};
		return this;
	}

	public LTDescr setMoveCurvedLocal()
	{
		type = TweenAction.MOVE_CURVED_LOCAL;
		initInternal = initFromInternal;
		easeInternal = delegate
		{
			newVect = easeMethod();
			val = newVect.x;
			if (_optional.path.orientToPath)
			{
				if (_optional.path.orientToPath2d)
				{
					_optional.path.placeLocal2d(trans, val);
				}
				else
				{
					_optional.path.placeLocal(trans, val);
				}
			}
			else
			{
				trans.localPosition = _optional.path.point(val);
			}
		};
		return this;
	}

	public LTDescr setMoveSpline()
	{
		type = TweenAction.MOVE_SPLINE;
		initInternal = initFromInternal;
		easeInternal = delegate
		{
			newVect = easeMethod();
			val = newVect.x;
			if (_optional.spline.orientToPath)
			{
				if (_optional.spline.orientToPath2d)
				{
					_optional.spline.place2d(trans, val);
				}
				else
				{
					_optional.spline.place(trans, val);
				}
			}
			else
			{
				trans.position = _optional.spline.point(val);
			}
		};
		return this;
	}

	public LTDescr setMoveSplineLocal()
	{
		type = TweenAction.MOVE_SPLINE_LOCAL;
		initInternal = initFromInternal;
		easeInternal = delegate
		{
			newVect = easeMethod();
			val = newVect.x;
			if (_optional.spline.orientToPath)
			{
				if (_optional.spline.orientToPath2d)
				{
					_optional.spline.placeLocal2d(trans, val);
				}
				else
				{
					_optional.spline.placeLocal(trans, val);
				}
			}
			else
			{
				trans.localPosition = _optional.spline.point(val);
			}
		};
		return this;
	}

	public LTDescr setScaleX()
	{
		type = TweenAction.SCALE_X;
		initInternal = delegate
		{
			fromInternal.x = trans.localScale.x;
		};
		easeInternal = delegate
		{
			trans.localScale = new Vector3(easeMethod().x, trans.localScale.y, trans.localScale.z);
		};
		return this;
	}

	public LTDescr setScaleY()
	{
		type = TweenAction.SCALE_Y;
		initInternal = delegate
		{
			fromInternal.x = trans.localScale.y;
		};
		easeInternal = delegate
		{
			trans.localScale = new Vector3(trans.localScale.x, easeMethod().x, trans.localScale.z);
		};
		return this;
	}

	public LTDescr setScaleZ()
	{
		type = TweenAction.SCALE_Z;
		initInternal = delegate
		{
			fromInternal.x = trans.localScale.z;
		};
		easeInternal = delegate
		{
			trans.localScale = new Vector3(trans.localScale.x, trans.localScale.y, easeMethod().x);
		};
		return this;
	}

	public LTDescr setRotateX()
	{
		type = TweenAction.ROTATE_X;
		initInternal = delegate
		{
			fromInternal.x = trans.eulerAngles.x;
			toInternal.x = LeanTween.closestRot(fromInternal.x, toInternal.x);
		};
		easeInternal = delegate
		{
			trans.eulerAngles = new Vector3(easeMethod().x, trans.eulerAngles.y, trans.eulerAngles.z);
		};
		return this;
	}

	public LTDescr setRotateY()
	{
		type = TweenAction.ROTATE_Y;
		initInternal = delegate
		{
			fromInternal.x = trans.eulerAngles.y;
			toInternal.x = LeanTween.closestRot(fromInternal.x, toInternal.x);
		};
		easeInternal = delegate
		{
			trans.eulerAngles = new Vector3(trans.eulerAngles.x, easeMethod().x, trans.eulerAngles.z);
		};
		return this;
	}

	public LTDescr setRotateZ()
	{
		type = TweenAction.ROTATE_Z;
		initInternal = delegate
		{
			fromInternal.x = trans.eulerAngles.z;
			toInternal.x = LeanTween.closestRot(fromInternal.x, toInternal.x);
		};
		easeInternal = delegate
		{
			trans.eulerAngles = new Vector3(trans.eulerAngles.x, trans.eulerAngles.y, easeMethod().x);
		};
		return this;
	}

	public LTDescr setRotateAround()
	{
		type = TweenAction.ROTATE_AROUND;
		initInternal = delegate
		{
			fromInternal.x = 0f;
			_optional.origRotation = trans.rotation;
		};
		easeInternal = delegate
		{
			newVect = easeMethod();
			val = newVect.x;
			Vector3 localPosition = trans.localPosition;
			Vector3 point = trans.TransformPoint(_optional.point);
			trans.RotateAround(point, _optional.axis, 0f - _optional.lastVal);
			Vector3 vector = localPosition - trans.localPosition;
			trans.localPosition = localPosition - vector;
			trans.rotation = _optional.origRotation;
			point = trans.TransformPoint(_optional.point);
			trans.RotateAround(point, _optional.axis, val);
			_optional.lastVal = val;
		};
		return this;
	}

	public LTDescr setRotateAroundLocal()
	{
		type = TweenAction.ROTATE_AROUND_LOCAL;
		initInternal = delegate
		{
			fromInternal.x = 0f;
			_optional.origRotation = trans.localRotation;
		};
		easeInternal = delegate
		{
			newVect = easeMethod();
			val = newVect.x;
			Vector3 localPosition = trans.localPosition;
			trans.RotateAround(trans.TransformPoint(_optional.point), trans.TransformDirection(_optional.axis), 0f - _optional.lastVal);
			Vector3 vector = localPosition - trans.localPosition;
			trans.localPosition = localPosition - vector;
			trans.localRotation = _optional.origRotation;
			Vector3 point = trans.TransformPoint(_optional.point);
			trans.RotateAround(point, trans.TransformDirection(_optional.axis), val);
			_optional.lastVal = val;
		};
		return this;
	}

	public LTDescr setAlpha()
	{
		type = TweenAction.ALPHA;
		initInternal = delegate
		{
			SpriteRenderer component = trans.GetComponent<SpriteRenderer>();
			if (component != null)
			{
				fromInternal.x = component.color.a;
			}
			else if (trans.GetComponent<Renderer>() != null && trans.GetComponent<Renderer>().material.HasProperty("_Color"))
			{
				fromInternal.x = trans.GetComponent<Renderer>().material.color.a;
			}
			else if (trans.GetComponent<Renderer>() != null && trans.GetComponent<Renderer>().material.HasProperty("_TintColor"))
			{
				Color color = trans.GetComponent<Renderer>().material.GetColor("_TintColor");
				fromInternal.x = color.a;
			}
			else if (trans.childCount > 0)
			{
				foreach (Transform tran in trans)
				{
					if (tran.gameObject.GetComponent<Renderer>() != null)
					{
						Color color2 = tran.gameObject.GetComponent<Renderer>().material.color;
						fromInternal.x = color2.a;
						break;
					}
				}
			}
			easeInternal = delegate
			{
				val = easeMethod().x;
				if (spriteRen != null)
				{
					spriteRen.color = new Color(spriteRen.color.r, spriteRen.color.g, spriteRen.color.b, val);
					alphaRecursiveSprite(trans, val);
				}
				else
				{
					alphaRecursive(trans, val, useRecursion);
				}
			};
		};
		easeInternal = delegate
		{
			newVect = easeMethod();
			val = newVect.x;
			if (spriteRen != null)
			{
				spriteRen.color = new Color(spriteRen.color.r, spriteRen.color.g, spriteRen.color.b, val);
				alphaRecursiveSprite(trans, val);
			}
			else
			{
				alphaRecursive(trans, val, useRecursion);
			}
		};
		return this;
	}

	public LTDescr setTextAlpha()
	{
		type = TweenAction.TEXT_ALPHA;
		initInternal = delegate
		{
			uiText = trans.GetComponent<Text>();
			fromInternal.x = ((!(uiText != null)) ? 1f : uiText.color.a);
		};
		easeInternal = delegate
		{
			textAlphaRecursive(trans, easeMethod().x, useRecursion);
		};
		return this;
	}

	public LTDescr setAlphaVertex()
	{
		type = TweenAction.ALPHA_VERTEX;
		initInternal = delegate
		{
			fromInternal.x = (int)trans.GetComponent<MeshFilter>().mesh.colors32[0].a;
		};
		easeInternal = delegate
		{
			newVect = easeMethod();
			val = newVect.x;
			Mesh mesh = trans.GetComponent<MeshFilter>().mesh;
			Vector3[] vertices = mesh.vertices;
			Color32[] array = new Color32[vertices.Length];
			if (array.Length == 0)
			{
				Color32 color = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, 0);
				array = new Color32[mesh.vertices.Length];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = color;
				}
				mesh.colors32 = array;
			}
			Color32 color2 = mesh.colors32[0];
			color2 = new Color((int)color2.r, (int)color2.g, (int)color2.b, val);
			for (int j = 0; j < vertices.Length; j++)
			{
				array[j] = color2;
			}
			mesh.colors32 = array;
		};
		return this;
	}

	public LTDescr setColor()
	{
		type = TweenAction.COLOR;
		initInternal = delegate
		{
			SpriteRenderer component = trans.GetComponent<SpriteRenderer>();
			if (component != null)
			{
				setFromColor(component.color);
			}
			else if (trans.GetComponent<Renderer>() != null && trans.GetComponent<Renderer>().material.HasProperty("_Color"))
			{
				Color color2 = trans.GetComponent<Renderer>().material.color;
				setFromColor(color2);
			}
			else if (trans.GetComponent<Renderer>() != null && trans.GetComponent<Renderer>().material.HasProperty("_TintColor"))
			{
				Color color3 = trans.GetComponent<Renderer>().material.GetColor("_TintColor");
				setFromColor(color3);
			}
			else if (trans.childCount > 0)
			{
				foreach (Transform tran in trans)
				{
					if (tran.gameObject.GetComponent<Renderer>() != null)
					{
						Color color4 = tran.gameObject.GetComponent<Renderer>().material.color;
						setFromColor(color4);
						break;
					}
				}
			}
		};
		easeInternal = delegate
		{
			newVect = easeMethod();
			val = newVect.x;
			Color color = tweenColor(this, val);
			if (spriteRen != null)
			{
				spriteRen.color = color;
				colorRecursiveSprite(trans, color);
			}
			else if (type == TweenAction.COLOR)
			{
				colorRecursive(trans, color, useRecursion);
			}
			if (dt != 0f && _optional.onUpdateColor != null)
			{
				_optional.onUpdateColor(color);
			}
			else if (dt != 0f && _optional.onUpdateColorObject != null)
			{
				_optional.onUpdateColorObject(color, _optional.onUpdateParam);
			}
		};
		return this;
	}

	public LTDescr setCallbackColor()
	{
		type = TweenAction.CALLBACK_COLOR;
		initInternal = delegate
		{
			diff = new Vector3(1f, 0f, 0f);
		};
		easeInternal = delegate
		{
			newVect = easeMethod();
			val = newVect.x;
			Color color = tweenColor(this, val);
			if (spriteRen != null)
			{
				spriteRen.color = color;
				colorRecursiveSprite(trans, color);
			}
			else if (type == TweenAction.COLOR)
			{
				colorRecursive(trans, color, useRecursion);
			}
			if (dt != 0f && _optional.onUpdateColor != null)
			{
				_optional.onUpdateColor(color);
			}
			else if (dt != 0f && _optional.onUpdateColorObject != null)
			{
				_optional.onUpdateColorObject(color, _optional.onUpdateParam);
			}
		};
		return this;
	}

	public LTDescr setTextColor()
	{
		type = TweenAction.TEXT_COLOR;
		initInternal = delegate
		{
			uiText = trans.GetComponent<Text>();
			setFromColor((!(uiText != null)) ? Color.white : uiText.color);
		};
		easeInternal = delegate
		{
			newVect = easeMethod();
			val = newVect.x;
			Color color = tweenColor(this, val);
			uiText.color = color;
			if (dt != 0f && _optional.onUpdateColor != null)
			{
				_optional.onUpdateColor(color);
			}
			if (useRecursion && trans.childCount > 0)
			{
				textColorRecursive(trans, color);
			}
		};
		return this;
	}

	public LTDescr setCanvasAlpha()
	{
		type = TweenAction.CANVAS_ALPHA;
		initInternal = delegate
		{
			uiImage = trans.GetComponent<Image>();
			if (uiImage != null)
			{
				fromInternal.x = uiImage.color.a;
			}
			else
			{
				rawImage = trans.GetComponent<RawImage>();
				if (rawImage != null)
				{
					fromInternal.x = rawImage.color.a;
				}
				else
				{
					fromInternal.x = 1f;
				}
			}
		};
		easeInternal = delegate
		{
			newVect = easeMethod();
			val = newVect.x;
			if (uiImage != null)
			{
				Color color = uiImage.color;
				color.a = val;
				uiImage.color = color;
			}
			else if (rawImage != null)
			{
				Color color2 = rawImage.color;
				color2.a = val;
				rawImage.color = color2;
			}
			if (useRecursion)
			{
				alphaRecursive(rectTransform, val);
				textAlphaChildrenRecursive(rectTransform, val);
			}
		};
		return this;
	}

	public LTDescr setCanvasGroupAlpha()
	{
		type = TweenAction.CANVASGROUP_ALPHA;
		initInternal = delegate
		{
			fromInternal.x = trans.GetComponent<CanvasGroup>().alpha;
		};
		easeInternal = delegate
		{
			trans.GetComponent<CanvasGroup>().alpha = easeMethod().x;
		};
		return this;
	}

	public LTDescr setCanvasColor()
	{
		type = TweenAction.CANVAS_COLOR;
		initInternal = delegate
		{
			uiImage = trans.GetComponent<Image>();
			if (uiImage == null)
			{
				rawImage = trans.GetComponent<RawImage>();
				setFromColor((!(rawImage != null)) ? Color.white : rawImage.color);
			}
			else
			{
				setFromColor(uiImage.color);
			}
		};
		easeInternal = delegate
		{
			newVect = easeMethod();
			val = newVect.x;
			Color color = tweenColor(this, val);
			if (uiImage != null)
			{
				uiImage.color = color;
			}
			else if (rawImage != null)
			{
				rawImage.color = color;
			}
			if (dt != 0f && _optional.onUpdateColor != null)
			{
				_optional.onUpdateColor(color);
			}
			if (useRecursion)
			{
				colorRecursive(rectTransform, color);
			}
		};
		return this;
	}

	public LTDescr setCanvasMoveX()
	{
		type = TweenAction.CANVAS_MOVE_X;
		initInternal = delegate
		{
			fromInternal.x = rectTransform.anchoredPosition3D.x;
		};
		easeInternal = delegate
		{
			Vector3 anchoredPosition3D = rectTransform.anchoredPosition3D;
			rectTransform.anchoredPosition3D = new Vector3(easeMethod().x, anchoredPosition3D.y, anchoredPosition3D.z);
		};
		return this;
	}

	public LTDescr setCanvasMoveY()
	{
		type = TweenAction.CANVAS_MOVE_Y;
		initInternal = delegate
		{
			fromInternal.x = rectTransform.anchoredPosition3D.y;
		};
		easeInternal = delegate
		{
			Vector3 anchoredPosition3D = rectTransform.anchoredPosition3D;
			rectTransform.anchoredPosition3D = new Vector3(anchoredPosition3D.x, easeMethod().x, anchoredPosition3D.z);
		};
		return this;
	}

	public LTDescr setCanvasMoveZ()
	{
		type = TweenAction.CANVAS_MOVE_Z;
		initInternal = delegate
		{
			fromInternal.x = rectTransform.anchoredPosition3D.z;
		};
		easeInternal = delegate
		{
			Vector3 anchoredPosition3D = rectTransform.anchoredPosition3D;
			rectTransform.anchoredPosition3D = new Vector3(anchoredPosition3D.x, anchoredPosition3D.y, easeMethod().x);
		};
		return this;
	}

	private void initCanvasRotateAround()
	{
		lastVal = 0f;
		fromInternal.x = 0f;
		_optional.origRotation = rectTransform.rotation;
	}

	public LTDescr setCanvasRotateAround()
	{
		type = TweenAction.CANVAS_ROTATEAROUND;
		initInternal = initCanvasRotateAround;
		easeInternal = delegate
		{
			newVect = easeMethod();
			val = newVect.x;
			RectTransform rectTransform = this.rectTransform;
			Vector3 localPosition = rectTransform.localPosition;
			rectTransform.RotateAround(rectTransform.TransformPoint(_optional.point), _optional.axis, 0f - val);
			Vector3 vector = localPosition - rectTransform.localPosition;
			rectTransform.localPosition = localPosition - vector;
			rectTransform.rotation = _optional.origRotation;
			rectTransform.RotateAround(rectTransform.TransformPoint(_optional.point), _optional.axis, val);
		};
		return this;
	}

	public LTDescr setCanvasRotateAroundLocal()
	{
		type = TweenAction.CANVAS_ROTATEAROUND_LOCAL;
		initInternal = initCanvasRotateAround;
		easeInternal = delegate
		{
			newVect = easeMethod();
			val = newVect.x;
			RectTransform rectTransform = this.rectTransform;
			Vector3 localPosition = rectTransform.localPosition;
			rectTransform.RotateAround(rectTransform.TransformPoint(_optional.point), rectTransform.TransformDirection(_optional.axis), 0f - val);
			Vector3 vector = localPosition - rectTransform.localPosition;
			rectTransform.localPosition = localPosition - vector;
			rectTransform.rotation = _optional.origRotation;
			rectTransform.RotateAround(rectTransform.TransformPoint(_optional.point), rectTransform.TransformDirection(_optional.axis), val);
		};
		return this;
	}

	public LTDescr setCanvasPlaySprite()
	{
		type = TweenAction.CANVAS_PLAYSPRITE;
		initInternal = delegate
		{
			uiImage = trans.GetComponent<Image>();
			fromInternal.x = 0f;
		};
		easeInternal = delegate
		{
			newVect = easeMethod();
			val = newVect.x;
			int num = (int)Mathf.Round(val);
			uiImage.sprite = sprites[num];
		};
		return this;
	}

	public LTDescr setCanvasMove()
	{
		type = TweenAction.CANVAS_MOVE;
		initInternal = delegate
		{
			fromInternal = rectTransform.anchoredPosition3D;
		};
		easeInternal = delegate
		{
			rectTransform.anchoredPosition3D = easeMethod();
		};
		return this;
	}

	public LTDescr setCanvasScale()
	{
		type = TweenAction.CANVAS_SCALE;
		initInternal = delegate
		{
			from = rectTransform.localScale;
		};
		easeInternal = delegate
		{
			rectTransform.localScale = easeMethod();
		};
		return this;
	}

	public LTDescr setCanvasSizeDelta()
	{
		type = TweenAction.CANVAS_SIZEDELTA;
		initInternal = delegate
		{
			from = rectTransform.sizeDelta;
		};
		easeInternal = delegate
		{
			rectTransform.sizeDelta = easeMethod();
		};
		return this;
	}

	private void callback()
	{
		newVect = easeMethod();
		val = newVect.x;
	}

	public LTDescr setCallback()
	{
		type = TweenAction.CALLBACK;
		initInternal = delegate
		{
		};
		easeInternal = callback;
		return this;
	}

	public LTDescr setValue3()
	{
		type = TweenAction.VALUE3;
		initInternal = delegate
		{
		};
		easeInternal = callback;
		return this;
	}

	public LTDescr setMove()
	{
		type = TweenAction.MOVE;
		initInternal = delegate
		{
			from = trans.position;
		};
		easeInternal = delegate
		{
			newVect = easeMethod();
			trans.position = newVect;
		};
		return this;
	}

	public LTDescr setMoveLocal()
	{
		type = TweenAction.MOVE_LOCAL;
		initInternal = delegate
		{
			from = trans.localPosition;
		};
		easeInternal = delegate
		{
			newVect = easeMethod();
			trans.localPosition = newVect;
		};
		return this;
	}

	public LTDescr setMoveToTransform()
	{
		type = TweenAction.MOVE_TO_TRANSFORM;
		initInternal = delegate
		{
			from = trans.position;
		};
		easeInternal = delegate
		{
			to = _optional.toTrans.position;
			diff = to - from;
			diffDiv2 = diff * 0.5f;
			newVect = easeMethod();
			trans.position = newVect;
		};
		return this;
	}

	public LTDescr setRotate()
	{
		type = TweenAction.ROTATE;
		initInternal = delegate
		{
			from = trans.eulerAngles;
			to = new Vector3(LeanTween.closestRot(fromInternal.x, toInternal.x), LeanTween.closestRot(from.y, to.y), LeanTween.closestRot(from.z, to.z));
		};
		easeInternal = delegate
		{
			newVect = easeMethod();
			trans.eulerAngles = newVect;
		};
		return this;
	}

	public LTDescr setRotateLocal()
	{
		type = TweenAction.ROTATE_LOCAL;
		initInternal = delegate
		{
			from = trans.localEulerAngles;
			to = new Vector3(LeanTween.closestRot(fromInternal.x, toInternal.x), LeanTween.closestRot(from.y, to.y), LeanTween.closestRot(from.z, to.z));
		};
		easeInternal = delegate
		{
			newVect = easeMethod();
			trans.localEulerAngles = newVect;
		};
		return this;
	}

	public LTDescr setScale()
	{
		type = TweenAction.SCALE;
		initInternal = delegate
		{
			from = trans.localScale;
		};
		easeInternal = delegate
		{
			newVect = easeMethod();
			trans.localScale = newVect;
		};
		return this;
	}

	public LTDescr setGUIMove()
	{
		type = TweenAction.GUI_MOVE;
		initInternal = delegate
		{
			from = new Vector3(_optional.ltRect.rect.x, _optional.ltRect.rect.y, 0f);
		};
		easeInternal = delegate
		{
			Vector3 vector = easeMethod();
			_optional.ltRect.rect = new Rect(vector.x, vector.y, _optional.ltRect.rect.width, _optional.ltRect.rect.height);
		};
		return this;
	}

	public LTDescr setGUIMoveMargin()
	{
		type = TweenAction.GUI_MOVE_MARGIN;
		initInternal = delegate
		{
			from = new Vector2(_optional.ltRect.margin.x, _optional.ltRect.margin.y);
		};
		easeInternal = delegate
		{
			Vector3 vector = easeMethod();
			_optional.ltRect.margin = new Vector2(vector.x, vector.y);
		};
		return this;
	}

	public LTDescr setGUIScale()
	{
		type = TweenAction.GUI_SCALE;
		initInternal = delegate
		{
			from = new Vector3(_optional.ltRect.rect.width, _optional.ltRect.rect.height, 0f);
		};
		easeInternal = delegate
		{
			Vector3 vector = easeMethod();
			_optional.ltRect.rect = new Rect(_optional.ltRect.rect.x, _optional.ltRect.rect.y, vector.x, vector.y);
		};
		return this;
	}

	public LTDescr setGUIAlpha()
	{
		type = TweenAction.GUI_ALPHA;
		initInternal = delegate
		{
			fromInternal.x = _optional.ltRect.alpha;
		};
		easeInternal = delegate
		{
			_optional.ltRect.alpha = easeMethod().x;
		};
		return this;
	}

	public LTDescr setGUIRotate()
	{
		type = TweenAction.GUI_ROTATE;
		initInternal = delegate
		{
			if (!_optional.ltRect.rotateEnabled)
			{
				_optional.ltRect.rotateEnabled = true;
				_optional.ltRect.resetForRotation();
			}
			fromInternal.x = _optional.ltRect.rotation;
		};
		easeInternal = delegate
		{
			_optional.ltRect.rotation = easeMethod().x;
		};
		return this;
	}

	public LTDescr setDelayedSound()
	{
		type = TweenAction.DELAYED_SOUND;
		initInternal = delegate
		{
			hasExtraOnCompletes = true;
		};
		easeInternal = callback;
		return this;
	}

	public LTDescr setTarget(Transform trans)
	{
		optional.toTrans = trans;
		return this;
	}

	private void init()
	{
		hasInitiliazed = true;
		usesNormalDt = !useEstimatedTime && !useManualTime && !useFrames;
		if (useFrames)
		{
			optional.initFrameCount = Time.frameCount;
		}
		if (time <= 0f)
		{
			time = Mathf.Epsilon;
		}
		if (initInternal != null)
		{
			initInternal();
		}
		diff = to - from;
		diffDiv2 = diff * 0.5f;
		if (_optional.onStart != null)
		{
			_optional.onStart();
		}
		if (onCompleteOnStart)
		{
			callOnCompletes();
		}
		if (speed >= 0f)
		{
			initSpeed();
		}
	}

	private void initSpeed()
	{
		if (type == TweenAction.MOVE_CURVED || type == TweenAction.MOVE_CURVED_LOCAL)
		{
			time = _optional.path.distance / speed;
		}
		else if (type == TweenAction.MOVE_SPLINE || type == TweenAction.MOVE_SPLINE_LOCAL)
		{
			time = _optional.spline.distance / speed;
		}
		else
		{
			time = (to - from).magnitude / speed;
		}
	}

	public LTDescr updateNow()
	{
		updateInternal();
		return this;
	}

	public bool updateInternal()
	{
		float num = direction;
		if (usesNormalDt)
		{
			dt = LeanTween.dtActual;
		}
		else if (useEstimatedTime)
		{
			dt = LeanTween.dtEstimated;
		}
		else if (useFrames)
		{
			dt = ((optional.initFrameCount != 0) ? 1 : 0);
			optional.initFrameCount = Time.frameCount;
		}
		else if (useManualTime)
		{
			dt = LeanTween.dtManual;
		}
		if (delay <= 0f && num != 0f)
		{
			if (trans == null)
			{
				return true;
			}
			if (!hasInitiliazed)
			{
				init();
			}
			dt *= num;
			passed += dt;
			passed = Mathf.Clamp(passed, 0f, time);
			ratioPassed = passed / time;
			easeInternal();
			if (hasUpdateCallback)
			{
				_optional.callOnUpdate(val, ratioPassed);
			}
			if ((!(num > 0f)) ? (passed <= 0f) : (passed >= time))
			{
				loopCount--;
				if (loopType == LeanTweenType.pingPong)
				{
					direction = 0f - num;
				}
				else
				{
					passed = Mathf.Epsilon;
				}
				bool flag = loopCount == 0 || loopType == LeanTweenType.once;
				if (!flag && onCompleteOnRepeat && hasExtraOnCompletes)
				{
					callOnCompletes();
				}
				return flag;
			}
		}
		else
		{
			delay -= dt;
		}
		return false;
	}

	public void callOnCompletes()
	{
		if (type == TweenAction.GUI_ROTATE)
		{
			_optional.ltRect.rotateFinished = true;
		}
		if (type == TweenAction.DELAYED_SOUND)
		{
			AudioSource.PlayClipAtPoint((AudioClip)_optional.onCompleteParam, to, from.x);
		}
		if (_optional.onComplete != null)
		{
			_optional.onComplete();
		}
		else if (_optional.onCompleteObject != null)
		{
			_optional.onCompleteObject(_optional.onCompleteParam);
		}
	}

	public LTDescr setFromColor(Color col)
	{
		from = new Vector3(0f, col.a, 0f);
		diff = new Vector3(1f, 0f, 0f);
		_optional.axis = new Vector3(col.r, col.g, col.b);
		return this;
	}

	private static void alphaRecursive(Transform transform, float val, bool useRecursion = true)
	{
		Renderer component = transform.gameObject.GetComponent<Renderer>();
		if (component != null)
		{
			Material[] materials = component.materials;
			foreach (Material material in materials)
			{
				if (material.HasProperty("_Color"))
				{
					material.color = new Color(material.color.r, material.color.g, material.color.b, val);
				}
				else if (material.HasProperty("_TintColor"))
				{
					Color color = material.GetColor("_TintColor");
					material.SetColor("_TintColor", new Color(color.r, color.g, color.b, val));
				}
			}
		}
		if (!useRecursion || transform.childCount <= 0)
		{
			return;
		}
		foreach (Transform item in transform)
		{
			alphaRecursive(item, val);
		}
	}

	private static void colorRecursive(Transform transform, Color toColor, bool useRecursion = true)
	{
		Renderer component = transform.gameObject.GetComponent<Renderer>();
		if (component != null)
		{
			Material[] materials = component.materials;
			foreach (Material material in materials)
			{
				material.color = toColor;
			}
		}
		if (!useRecursion || transform.childCount <= 0)
		{
			return;
		}
		foreach (Transform item in transform)
		{
			colorRecursive(item, toColor);
		}
	}

	private static void alphaRecursive(RectTransform rectTransform, float val, int recursiveLevel = 0)
	{
		if (rectTransform.childCount <= 0)
		{
			return;
		}
		foreach (RectTransform item in rectTransform)
		{
			MaskableGraphic component = item.GetComponent<Image>();
			if (component != null)
			{
				Color color = component.color;
				color.a = val;
				component.color = color;
			}
			else
			{
				component = item.GetComponent<RawImage>();
				if (component != null)
				{
					Color color2 = component.color;
					color2.a = val;
					component.color = color2;
				}
			}
			alphaRecursive(item, val, recursiveLevel + 1);
		}
	}

	private static void alphaRecursiveSprite(Transform transform, float val)
	{
		if (transform.childCount <= 0)
		{
			return;
		}
		foreach (Transform item in transform)
		{
			SpriteRenderer component = item.GetComponent<SpriteRenderer>();
			if (component != null)
			{
				component.color = new Color(component.color.r, component.color.g, component.color.b, val);
			}
			alphaRecursiveSprite(item, val);
		}
	}

	private static void colorRecursiveSprite(Transform transform, Color toColor)
	{
		if (transform.childCount <= 0)
		{
			return;
		}
		foreach (Transform item in transform)
		{
			SpriteRenderer component = transform.gameObject.GetComponent<SpriteRenderer>();
			if (component != null)
			{
				component.color = toColor;
			}
			colorRecursiveSprite(item, toColor);
		}
	}

	private static void colorRecursive(RectTransform rectTransform, Color toColor)
	{
		if (rectTransform.childCount <= 0)
		{
			return;
		}
		foreach (RectTransform item in rectTransform)
		{
			MaskableGraphic component = item.GetComponent<Image>();
			if (component != null)
			{
				component.color = toColor;
			}
			else
			{
				component = item.GetComponent<RawImage>();
				if (component != null)
				{
					component.color = toColor;
				}
			}
			colorRecursive(item, toColor);
		}
	}

	private static void textAlphaChildrenRecursive(Transform trans, float val, bool useRecursion = true)
	{
		if (!useRecursion || trans.childCount <= 0)
		{
			return;
		}
		foreach (Transform tran in trans)
		{
			Text component = tran.GetComponent<Text>();
			if (component != null)
			{
				Color color = component.color;
				color.a = val;
				component.color = color;
			}
			textAlphaChildrenRecursive(tran, val);
		}
	}

	private static void textAlphaRecursive(Transform trans, float val, bool useRecursion = true)
	{
		Text component = trans.GetComponent<Text>();
		if (component != null)
		{
			Color color = component.color;
			color.a = val;
			component.color = color;
		}
		if (!useRecursion || trans.childCount <= 0)
		{
			return;
		}
		foreach (Transform tran in trans)
		{
			textAlphaRecursive(tran, val);
		}
	}

	private static void textColorRecursive(Transform trans, Color toColor)
	{
		if (trans.childCount <= 0)
		{
			return;
		}
		foreach (Transform tran in trans)
		{
			Text component = tran.GetComponent<Text>();
			if (component != null)
			{
				component.color = toColor;
			}
			textColorRecursive(tran, toColor);
		}
	}

	private static Color tweenColor(LTDescr tween, float val)
	{
		Vector3 vector = tween._optional.point - tween._optional.axis;
		float num = tween.to.y - tween.from.y;
		return new Color(tween._optional.axis.x + vector.x * val, tween._optional.axis.y + vector.y * val, tween._optional.axis.z + vector.z * val, tween.from.y + num * val);
	}

	public LTDescr pause()
	{
		if (direction != 0f)
		{
			directionLast = direction;
			direction = 0f;
		}
		return this;
	}

	public LTDescr resume()
	{
		direction = directionLast;
		return this;
	}

	public LTDescr setAxis(Vector3 axis)
	{
		_optional.axis = axis;
		return this;
	}

	public LTDescr setDelay(float delay)
	{
		this.delay = delay;
		return this;
	}

	public LTDescr setEase(LeanTweenType easeType)
	{
		switch (easeType)
		{
		case LeanTweenType.linear:
			setEaseLinear();
			break;
		case LeanTweenType.easeOutQuad:
			setEaseOutQuad();
			break;
		case LeanTweenType.easeInQuad:
			setEaseInQuad();
			break;
		case LeanTweenType.easeInOutQuad:
			setEaseInOutQuad();
			break;
		case LeanTweenType.easeInCubic:
			setEaseInCubic();
			break;
		case LeanTweenType.easeOutCubic:
			setEaseOutCubic();
			break;
		case LeanTweenType.easeInOutCubic:
			setEaseInOutCubic();
			break;
		case LeanTweenType.easeInQuart:
			setEaseInQuart();
			break;
		case LeanTweenType.easeOutQuart:
			setEaseOutQuart();
			break;
		case LeanTweenType.easeInOutQuart:
			setEaseInOutQuart();
			break;
		case LeanTweenType.easeInQuint:
			setEaseInQuint();
			break;
		case LeanTweenType.easeOutQuint:
			setEaseOutQuint();
			break;
		case LeanTweenType.easeInOutQuint:
			setEaseInOutQuint();
			break;
		case LeanTweenType.easeInSine:
			setEaseInSine();
			break;
		case LeanTweenType.easeOutSine:
			setEaseOutSine();
			break;
		case LeanTweenType.easeInOutSine:
			setEaseInOutSine();
			break;
		case LeanTweenType.easeInExpo:
			setEaseInExpo();
			break;
		case LeanTweenType.easeOutExpo:
			setEaseOutExpo();
			break;
		case LeanTweenType.easeInOutExpo:
			setEaseInOutExpo();
			break;
		case LeanTweenType.easeInCirc:
			setEaseInCirc();
			break;
		case LeanTweenType.easeOutCirc:
			setEaseOutCirc();
			break;
		case LeanTweenType.easeInOutCirc:
			setEaseInOutCirc();
			break;
		case LeanTweenType.easeInBounce:
			setEaseInBounce();
			break;
		case LeanTweenType.easeOutBounce:
			setEaseOutBounce();
			break;
		case LeanTweenType.easeInOutBounce:
			setEaseInOutBounce();
			break;
		case LeanTweenType.easeInBack:
			setEaseInBack();
			break;
		case LeanTweenType.easeOutBack:
			setEaseOutBack();
			break;
		case LeanTweenType.easeInOutBack:
			setEaseInOutBack();
			break;
		case LeanTweenType.easeInElastic:
			setEaseInElastic();
			break;
		case LeanTweenType.easeOutElastic:
			setEaseOutElastic();
			break;
		case LeanTweenType.easeInOutElastic:
			setEaseInOutElastic();
			break;
		case LeanTweenType.punch:
			setEasePunch();
			break;
		case LeanTweenType.easeShake:
			setEaseShake();
			break;
		case LeanTweenType.easeSpring:
			setEaseSpring();
			break;
		default:
			setEaseLinear();
			break;
		}
		return this;
	}

	public LTDescr setEaseLinear()
	{
		easeType = LeanTweenType.linear;
		easeMethod = easeLinear;
		return this;
	}

	public LTDescr setEaseSpring()
	{
		easeType = LeanTweenType.easeSpring;
		easeMethod = easeSpring;
		return this;
	}

	public LTDescr setEaseInQuad()
	{
		easeType = LeanTweenType.easeInQuad;
		easeMethod = easeInQuad;
		return this;
	}

	public LTDescr setEaseOutQuad()
	{
		easeType = LeanTweenType.easeOutQuad;
		easeMethod = easeOutQuad;
		return this;
	}

	public LTDescr setEaseInOutQuad()
	{
		easeType = LeanTweenType.easeInOutQuad;
		easeMethod = easeInOutQuad;
		return this;
	}

	public LTDescr setEaseInCubic()
	{
		easeType = LeanTweenType.easeInCubic;
		easeMethod = easeInCubic;
		return this;
	}

	public LTDescr setEaseOutCubic()
	{
		easeType = LeanTweenType.easeOutCubic;
		easeMethod = easeOutCubic;
		return this;
	}

	public LTDescr setEaseInOutCubic()
	{
		easeType = LeanTweenType.easeInOutCubic;
		easeMethod = easeInOutCubic;
		return this;
	}

	public LTDescr setEaseInQuart()
	{
		easeType = LeanTweenType.easeInQuart;
		easeMethod = easeInQuart;
		return this;
	}

	public LTDescr setEaseOutQuart()
	{
		easeType = LeanTweenType.easeOutQuart;
		easeMethod = easeOutQuart;
		return this;
	}

	public LTDescr setEaseInOutQuart()
	{
		easeType = LeanTweenType.easeInOutQuart;
		easeMethod = easeInOutQuart;
		return this;
	}

	public LTDescr setEaseInQuint()
	{
		easeType = LeanTweenType.easeInQuint;
		easeMethod = easeInQuint;
		return this;
	}

	public LTDescr setEaseOutQuint()
	{
		easeType = LeanTweenType.easeOutQuint;
		easeMethod = easeOutQuint;
		return this;
	}

	public LTDescr setEaseInOutQuint()
	{
		easeType = LeanTweenType.easeInOutQuint;
		easeMethod = easeInOutQuint;
		return this;
	}

	public LTDescr setEaseInSine()
	{
		easeType = LeanTweenType.easeInSine;
		easeMethod = easeInSine;
		return this;
	}

	public LTDescr setEaseOutSine()
	{
		easeType = LeanTweenType.easeOutSine;
		easeMethod = easeOutSine;
		return this;
	}

	public LTDescr setEaseInOutSine()
	{
		easeType = LeanTweenType.easeInOutSine;
		easeMethod = easeInOutSine;
		return this;
	}

	public LTDescr setEaseInExpo()
	{
		easeType = LeanTweenType.easeInExpo;
		easeMethod = easeInExpo;
		return this;
	}

	public LTDescr setEaseOutExpo()
	{
		easeType = LeanTweenType.easeOutExpo;
		easeMethod = easeOutExpo;
		return this;
	}

	public LTDescr setEaseInOutExpo()
	{
		easeType = LeanTweenType.easeInOutExpo;
		easeMethod = easeInOutExpo;
		return this;
	}

	public LTDescr setEaseInCirc()
	{
		easeType = LeanTweenType.easeInCirc;
		easeMethod = easeInCirc;
		return this;
	}

	public LTDescr setEaseOutCirc()
	{
		easeType = LeanTweenType.easeOutCirc;
		easeMethod = easeOutCirc;
		return this;
	}

	public LTDescr setEaseInOutCirc()
	{
		easeType = LeanTweenType.easeInOutCirc;
		easeMethod = easeInOutCirc;
		return this;
	}

	public LTDescr setEaseInBounce()
	{
		easeType = LeanTweenType.easeInBounce;
		easeMethod = easeInBounce;
		return this;
	}

	public LTDescr setEaseOutBounce()
	{
		easeType = LeanTweenType.easeOutBounce;
		easeMethod = easeOutBounce;
		return this;
	}

	public LTDescr setEaseInOutBounce()
	{
		easeType = LeanTweenType.easeInOutBounce;
		easeMethod = easeInOutBounce;
		return this;
	}

	public LTDescr setEaseInBack()
	{
		easeType = LeanTweenType.easeInBack;
		easeMethod = easeInBack;
		return this;
	}

	public LTDescr setEaseOutBack()
	{
		easeType = LeanTweenType.easeOutBack;
		easeMethod = easeOutBack;
		return this;
	}

	public LTDescr setEaseInOutBack()
	{
		easeType = LeanTweenType.easeInOutBack;
		easeMethod = easeInOutBack;
		return this;
	}

	public LTDescr setEaseInElastic()
	{
		easeType = LeanTweenType.easeInElastic;
		easeMethod = easeInElastic;
		return this;
	}

	public LTDescr setEaseOutElastic()
	{
		easeType = LeanTweenType.easeOutElastic;
		easeMethod = easeOutElastic;
		return this;
	}

	public LTDescr setEaseInOutElastic()
	{
		easeType = LeanTweenType.easeInOutElastic;
		easeMethod = easeInOutElastic;
		return this;
	}

	public LTDescr setEasePunch()
	{
		_optional.animationCurve = LeanTween.punch;
		toInternal.x = from.x + to.x;
		easeMethod = tweenOnCurve;
		return this;
	}

	public LTDescr setEaseShake()
	{
		_optional.animationCurve = LeanTween.shake;
		toInternal.x = from.x + to.x;
		easeMethod = tweenOnCurve;
		return this;
	}

	private Vector3 tweenOnCurve()
	{
		return new Vector3(from.x + diff.x * _optional.animationCurve.Evaluate(ratioPassed), from.y + diff.y * _optional.animationCurve.Evaluate(ratioPassed), from.z + diff.z * _optional.animationCurve.Evaluate(ratioPassed));
	}

	private Vector3 easeInOutQuad()
	{
		val = ratioPassed * 2f;
		if (val < 1f)
		{
			val *= val;
			return new Vector3(diffDiv2.x * val + from.x, diffDiv2.y * val + from.y, diffDiv2.z * val + from.z);
		}
		val = (1f - val) * (val - 3f) + 1f;
		return new Vector3(diffDiv2.x * val + from.x, diffDiv2.y * val + from.y, diffDiv2.z * val + from.z);
	}

	private Vector3 easeInQuad()
	{
		val = ratioPassed * ratioPassed;
		return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
	}

	private Vector3 easeOutQuad()
	{
		val = ratioPassed;
		val = (0f - val) * (val - 2f);
		return diff * val + from;
	}

	private Vector3 easeLinear()
	{
		val = ratioPassed;
		return new Vector3(from.x + diff.x * val, from.y + diff.y * val, from.z + diff.z * val);
	}

	private Vector3 easeSpring()
	{
		val = Mathf.Clamp01(ratioPassed);
		val = (Mathf.Sin(val * (float)Math.PI * (0.2f + 2.5f * val * val * val)) * Mathf.Pow(1f - val, 2.2f) + val) * (1f + 1.2f * (1f - val));
		return from + diff * val;
	}

	private Vector3 easeInCubic()
	{
		val = ratioPassed * ratioPassed * ratioPassed;
		return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
	}

	private Vector3 easeOutCubic()
	{
		val = ratioPassed - 1f;
		val = val * val * val + 1f;
		return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
	}

	private Vector3 easeInOutCubic()
	{
		val = ratioPassed * 2f;
		if (val < 1f)
		{
			val = val * val * val;
			return new Vector3(diffDiv2.x * val + from.x, diffDiv2.y * val + from.y, diffDiv2.z * val + from.z);
		}
		val -= 2f;
		val = val * val * val + 2f;
		return new Vector3(diffDiv2.x * val + from.x, diffDiv2.y * val + from.y, diffDiv2.z * val + from.z);
	}

	private Vector3 easeInQuart()
	{
		val = ratioPassed * ratioPassed * ratioPassed * ratioPassed;
		return diff * val + from;
	}

	private Vector3 easeOutQuart()
	{
		val = ratioPassed - 1f;
		val = 0f - (val * val * val * val - 1f);
		return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
	}

	private Vector3 easeInOutQuart()
	{
		val = ratioPassed * 2f;
		if (val < 1f)
		{
			val = val * val * val * val;
			return new Vector3(diffDiv2.x * val + from.x, diffDiv2.y * val + from.y, diffDiv2.z * val + from.z);
		}
		val -= 2f;
		return -diffDiv2 * (val * val * val * val - 2f) + from;
	}

	private Vector3 easeInQuint()
	{
		val = ratioPassed;
		val = val * val * val * val * val;
		return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
	}

	private Vector3 easeOutQuint()
	{
		val = ratioPassed - 1f;
		val = val * val * val * val * val + 1f;
		return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
	}

	private Vector3 easeInOutQuint()
	{
		val = ratioPassed * 2f;
		if (val < 1f)
		{
			val = val * val * val * val * val;
			return new Vector3(diffDiv2.x * val + from.x, diffDiv2.y * val + from.y, diffDiv2.z * val + from.z);
		}
		val -= 2f;
		val = val * val * val * val * val + 2f;
		return new Vector3(diffDiv2.x * val + from.x, diffDiv2.y * val + from.y, diffDiv2.z * val + from.z);
	}

	private Vector3 easeInSine()
	{
		val = 0f - Mathf.Cos(ratioPassed * LeanTween.PI_DIV2);
		return new Vector3(diff.x * val + diff.x + from.x, diff.y * val + diff.y + from.y, diff.z * val + diff.z + from.z);
	}

	private Vector3 easeOutSine()
	{
		val = Mathf.Sin(ratioPassed * LeanTween.PI_DIV2);
		return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
	}

	private Vector3 easeInOutSine()
	{
		val = 0f - (Mathf.Cos((float)Math.PI * ratioPassed) - 1f);
		return new Vector3(diffDiv2.x * val + from.x, diffDiv2.y * val + from.y, diffDiv2.z * val + from.z);
	}

	private Vector3 easeInExpo()
	{
		val = Mathf.Pow(2f, 10f * (ratioPassed - 1f));
		return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
	}

	private Vector3 easeOutExpo()
	{
		val = 0f - Mathf.Pow(2f, -10f * ratioPassed) + 1f;
		return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
	}

	private Vector3 easeInOutExpo()
	{
		val = ratioPassed * 2f;
		if (val < 1f)
		{
			return diffDiv2 * Mathf.Pow(2f, 10f * (val - 1f)) + from;
		}
		val -= 1f;
		return diffDiv2 * (0f - Mathf.Pow(2f, -10f * val) + 2f) + from;
	}

	private Vector3 easeInCirc()
	{
		val = 0f - (Mathf.Sqrt(1f - ratioPassed * ratioPassed) - 1f);
		return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
	}

	private Vector3 easeOutCirc()
	{
		val = ratioPassed - 1f;
		val = Mathf.Sqrt(1f - val * val);
		return new Vector3(diff.x * val + from.x, diff.y * val + from.y, diff.z * val + from.z);
	}

	private Vector3 easeInOutCirc()
	{
		val = ratioPassed * 2f;
		if (val < 1f)
		{
			val = 0f - (Mathf.Sqrt(1f - val * val) - 1f);
			return new Vector3(diffDiv2.x * val + from.x, diffDiv2.y * val + from.y, diffDiv2.z * val + from.z);
		}
		val -= 2f;
		val = Mathf.Sqrt(1f - val * val) + 1f;
		return new Vector3(diffDiv2.x * val + from.x, diffDiv2.y * val + from.y, diffDiv2.z * val + from.z);
	}

	private Vector3 easeInBounce()
	{
		val = ratioPassed;
		val = 1f - val;
		return new Vector3(diff.x - LeanTween.easeOutBounce(0f, diff.x, val) + from.x, diff.y - LeanTween.easeOutBounce(0f, diff.y, val) + from.y, diff.z - LeanTween.easeOutBounce(0f, diff.z, val) + from.z);
	}

	private Vector3 easeOutBounce()
	{
		val = ratioPassed;
		float num2;
		float num;
		if (val < (num = 1f - 1.75f * overshoot / 2.75f))
		{
			val = 1f / num / num * val * val;
		}
		else if (val < (num2 = 1f - 0.75f * overshoot / 2.75f))
		{
			val -= (num + num2) / 2f;
			val = 7.5625f * val * val + 1f - 0.25f * overshoot * overshoot;
		}
		else if (val < (num = 1f - 0.25f * overshoot / 2.75f))
		{
			val -= (num + num2) / 2f;
			val = 7.5625f * val * val + 1f - 0.0625f * overshoot * overshoot;
		}
		else
		{
			val -= (num + 1f) / 2f;
			val = 7.5625f * val * val + 1f - 1f / 64f * overshoot * overshoot;
		}
		return diff * val + from;
	}

	private Vector3 easeInOutBounce()
	{
		val = ratioPassed * 2f;
		if (val < 1f)
		{
			return new Vector3(LeanTween.easeInBounce(0f, diff.x, val) * 0.5f + from.x, LeanTween.easeInBounce(0f, diff.y, val) * 0.5f + from.y, LeanTween.easeInBounce(0f, diff.z, val) * 0.5f + from.z);
		}
		val -= 1f;
		return new Vector3(LeanTween.easeOutBounce(0f, diff.x, val) * 0.5f + diffDiv2.x + from.x, LeanTween.easeOutBounce(0f, diff.y, val) * 0.5f + diffDiv2.y + from.y, LeanTween.easeOutBounce(0f, diff.z, val) * 0.5f + diffDiv2.z + from.z);
	}

	private Vector3 easeInBack()
	{
		val = ratioPassed;
		val /= 1f;
		float num = 1.70158f * overshoot;
		return diff * val * val * ((num + 1f) * val - num) + from;
	}

	private Vector3 easeOutBack()
	{
		float num = 1.70158f * overshoot;
		val = ratioPassed / 1f - 1f;
		val = val * val * ((num + 1f) * val + num) + 1f;
		return diff * val + from;
	}

	private Vector3 easeInOutBack()
	{
		float num = 1.70158f * overshoot;
		val = ratioPassed * 2f;
		if (val < 1f)
		{
			num *= 1.525f * overshoot;
			return diffDiv2 * (val * val * ((num + 1f) * val - num)) + from;
		}
		val -= 2f;
		num *= 1.525f * overshoot;
		val = val * val * ((num + 1f) * val + num) + 2f;
		return diffDiv2 * val + from;
	}

	private Vector3 easeInElastic()
	{
		return new Vector3(LeanTween.easeInElastic(from.x, to.x, ratioPassed, overshoot, period), LeanTween.easeInElastic(from.y, to.y, ratioPassed, overshoot, period), LeanTween.easeInElastic(from.z, to.z, ratioPassed, overshoot, period));
	}

	private Vector3 easeOutElastic()
	{
		return new Vector3(LeanTween.easeOutElastic(from.x, to.x, ratioPassed, overshoot, period), LeanTween.easeOutElastic(from.y, to.y, ratioPassed, overshoot, period), LeanTween.easeOutElastic(from.z, to.z, ratioPassed, overshoot, period));
	}

	private Vector3 easeInOutElastic()
	{
		return new Vector3(LeanTween.easeInOutElastic(from.x, to.x, ratioPassed, overshoot, period), LeanTween.easeInOutElastic(from.y, to.y, ratioPassed, overshoot, period), LeanTween.easeInOutElastic(from.z, to.z, ratioPassed, overshoot, period));
	}

	public LTDescr setOvershoot(float overshoot)
	{
		this.overshoot = overshoot;
		return this;
	}

	public LTDescr setPeriod(float period)
	{
		this.period = period;
		return this;
	}

	public LTDescr setScale(float scale)
	{
		this.scale = scale;
		return this;
	}

	public LTDescr setEase(AnimationCurve easeCurve)
	{
		_optional.animationCurve = easeCurve;
		easeMethod = tweenOnCurve;
		easeType = LeanTweenType.animationCurve;
		return this;
	}

	public LTDescr setTo(Vector3 to)
	{
		if (hasInitiliazed)
		{
			this.to = to;
			diff = to - from;
		}
		else
		{
			this.to = to;
		}
		return this;
	}

	public LTDescr setTo(Transform to)
	{
		_optional.toTrans = to;
		return this;
	}

	public LTDescr setFrom(Vector3 from)
	{
		if ((bool)trans)
		{
			init();
		}
		this.from = from;
		diff = to - this.from;
		diffDiv2 = diff * 0.5f;
		return this;
	}

	public LTDescr setFrom(float from)
	{
		return setFrom(new Vector3(from, 0f, 0f));
	}

	public LTDescr setDiff(Vector3 diff)
	{
		this.diff = diff;
		return this;
	}

	public LTDescr setHasInitialized(bool has)
	{
		hasInitiliazed = has;
		return this;
	}

	public LTDescr setId(uint id, uint global_counter)
	{
		_id = id;
		counter = global_counter;
		return this;
	}

	public LTDescr setPassed(float passed)
	{
		this.passed = passed;
		return this;
	}

	public LTDescr setTime(float time)
	{
		float num = passed / this.time;
		passed = time * num;
		this.time = time;
		return this;
	}

	public LTDescr setSpeed(float speed)
	{
		this.speed = speed;
		if (hasInitiliazed)
		{
			initSpeed();
		}
		return this;
	}

	public LTDescr setRepeat(int repeat)
	{
		loopCount = repeat;
		if ((repeat > 1 && loopType == LeanTweenType.once) || (repeat < 0 && loopType == LeanTweenType.once))
		{
			loopType = LeanTweenType.clamp;
		}
		if (type == TweenAction.CALLBACK || type == TweenAction.CALLBACK_COLOR)
		{
			setOnCompleteOnRepeat(isOn: true);
		}
		return this;
	}

	public LTDescr setLoopType(LeanTweenType loopType)
	{
		this.loopType = loopType;
		return this;
	}

	public LTDescr setUseEstimatedTime(bool useEstimatedTime)
	{
		this.useEstimatedTime = useEstimatedTime;
		usesNormalDt = false;
		return this;
	}

	public LTDescr setIgnoreTimeScale(bool useUnScaledTime)
	{
		useEstimatedTime = useUnScaledTime;
		usesNormalDt = false;
		return this;
	}

	public LTDescr setUseFrames(bool useFrames)
	{
		this.useFrames = useFrames;
		usesNormalDt = false;
		return this;
	}

	public LTDescr setUseManualTime(bool useManualTime)
	{
		this.useManualTime = useManualTime;
		usesNormalDt = false;
		return this;
	}

	public LTDescr setLoopCount(int loopCount)
	{
		loopType = LeanTweenType.clamp;
		this.loopCount = loopCount;
		return this;
	}

	public LTDescr setLoopOnce()
	{
		loopType = LeanTweenType.once;
		return this;
	}

	public LTDescr setLoopClamp()
	{
		loopType = LeanTweenType.clamp;
		if (loopCount == 0)
		{
			loopCount = -1;
		}
		return this;
	}

	public LTDescr setLoopClamp(int loops)
	{
		loopCount = loops;
		return this;
	}

	public LTDescr setLoopPingPong()
	{
		loopType = LeanTweenType.pingPong;
		if (loopCount == 0)
		{
			loopCount = -1;
		}
		return this;
	}

	public LTDescr setLoopPingPong(int loops)
	{
		loopType = LeanTweenType.pingPong;
		loopCount = ((loops != -1) ? (loops * 2) : loops);
		return this;
	}

	public LTDescr setOnComplete(Action onComplete)
	{
		_optional.onComplete = onComplete;
		hasExtraOnCompletes = true;
		return this;
	}

	public LTDescr setOnComplete(Action<object> onComplete)
	{
		_optional.onCompleteObject = onComplete;
		hasExtraOnCompletes = true;
		return this;
	}

	public LTDescr setOnComplete(Action<object> onComplete, object onCompleteParam)
	{
		_optional.onCompleteObject = onComplete;
		hasExtraOnCompletes = true;
		if (onCompleteParam != null)
		{
			_optional.onCompleteParam = onCompleteParam;
		}
		return this;
	}

	public LTDescr setOnCompleteParam(object onCompleteParam)
	{
		_optional.onCompleteParam = onCompleteParam;
		hasExtraOnCompletes = true;
		return this;
	}

	public LTDescr setOnUpdate(Action<float> onUpdate)
	{
		_optional.onUpdateFloat = onUpdate;
		hasUpdateCallback = true;
		return this;
	}

	public LTDescr setOnUpdateRatio(Action<float, float> onUpdate)
	{
		_optional.onUpdateFloatRatio = onUpdate;
		hasUpdateCallback = true;
		return this;
	}

	public LTDescr setOnUpdateObject(Action<float, object> onUpdate)
	{
		_optional.onUpdateFloatObject = onUpdate;
		hasUpdateCallback = true;
		return this;
	}

	public LTDescr setOnUpdateVector2(Action<Vector2> onUpdate)
	{
		_optional.onUpdateVector2 = onUpdate;
		hasUpdateCallback = true;
		return this;
	}

	public LTDescr setOnUpdateVector3(Action<Vector3> onUpdate)
	{
		_optional.onUpdateVector3 = onUpdate;
		hasUpdateCallback = true;
		return this;
	}

	public LTDescr setOnUpdateColor(Action<Color> onUpdate)
	{
		_optional.onUpdateColor = onUpdate;
		hasUpdateCallback = true;
		return this;
	}

	public LTDescr setOnUpdateColor(Action<Color, object> onUpdate)
	{
		_optional.onUpdateColorObject = onUpdate;
		hasUpdateCallback = true;
		return this;
	}

	public LTDescr setOnUpdate(Action<Color> onUpdate)
	{
		_optional.onUpdateColor = onUpdate;
		hasUpdateCallback = true;
		return this;
	}

	public LTDescr setOnUpdate(Action<Color, object> onUpdate)
	{
		_optional.onUpdateColorObject = onUpdate;
		hasUpdateCallback = true;
		return this;
	}

	public LTDescr setOnUpdate(Action<float, object> onUpdate, object onUpdateParam = null)
	{
		_optional.onUpdateFloatObject = onUpdate;
		hasUpdateCallback = true;
		if (onUpdateParam != null)
		{
			_optional.onUpdateParam = onUpdateParam;
		}
		return this;
	}

	public LTDescr setOnUpdate(Action<Vector3, object> onUpdate, object onUpdateParam = null)
	{
		_optional.onUpdateVector3Object = onUpdate;
		hasUpdateCallback = true;
		if (onUpdateParam != null)
		{
			_optional.onUpdateParam = onUpdateParam;
		}
		return this;
	}

	public LTDescr setOnUpdate(Action<Vector2> onUpdate, object onUpdateParam = null)
	{
		_optional.onUpdateVector2 = onUpdate;
		hasUpdateCallback = true;
		if (onUpdateParam != null)
		{
			_optional.onUpdateParam = onUpdateParam;
		}
		return this;
	}

	public LTDescr setOnUpdate(Action<Vector3> onUpdate, object onUpdateParam = null)
	{
		_optional.onUpdateVector3 = onUpdate;
		hasUpdateCallback = true;
		if (onUpdateParam != null)
		{
			_optional.onUpdateParam = onUpdateParam;
		}
		return this;
	}

	public LTDescr setOnUpdateParam(object onUpdateParam)
	{
		_optional.onUpdateParam = onUpdateParam;
		return this;
	}

	public LTDescr setOrientToPath(bool doesOrient)
	{
		if (type == TweenAction.MOVE_CURVED || type == TweenAction.MOVE_CURVED_LOCAL)
		{
			if (_optional.path == null)
			{
				_optional.path = new LTBezierPath();
			}
			_optional.path.orientToPath = doesOrient;
		}
		else
		{
			_optional.spline.orientToPath = doesOrient;
		}
		return this;
	}

	public LTDescr setOrientToPath2d(bool doesOrient2d)
	{
		setOrientToPath(doesOrient2d);
		if (type == TweenAction.MOVE_CURVED || type == TweenAction.MOVE_CURVED_LOCAL)
		{
			_optional.path.orientToPath2d = doesOrient2d;
		}
		else
		{
			_optional.spline.orientToPath2d = doesOrient2d;
		}
		return this;
	}

	public LTDescr setRect(LTRect rect)
	{
		_optional.ltRect = rect;
		return this;
	}

	public LTDescr setRect(Rect rect)
	{
		_optional.ltRect = new LTRect(rect);
		return this;
	}

	public LTDescr setPath(LTBezierPath path)
	{
		_optional.path = path;
		return this;
	}

	public LTDescr setPoint(Vector3 point)
	{
		_optional.point = point;
		return this;
	}

	public LTDescr setDestroyOnComplete(bool doesDestroy)
	{
		destroyOnComplete = doesDestroy;
		return this;
	}

	public LTDescr setAudio(object audio)
	{
		_optional.onCompleteParam = audio;
		return this;
	}

	public LTDescr setOnCompleteOnRepeat(bool isOn)
	{
		onCompleteOnRepeat = isOn;
		return this;
	}

	public LTDescr setOnCompleteOnStart(bool isOn)
	{
		onCompleteOnStart = isOn;
		return this;
	}

	public LTDescr setRect(RectTransform rect)
	{
		rectTransform = rect;
		return this;
	}

	public LTDescr setSprites(Sprite[] sprites)
	{
		this.sprites = sprites;
		return this;
	}

	public LTDescr setFrameRate(float frameRate)
	{
		time = (float)sprites.Length / frameRate;
		return this;
	}

	public LTDescr setOnStart(Action onStart)
	{
		_optional.onStart = onStart;
		return this;
	}

	public LTDescr setDirection(float direction)
	{
		if (this.direction != -1f && this.direction != 1f)
		{
			UnityEngine.Debug.LogWarning("You have passed an incorrect direction of '" + direction + "', direction must be -1f or 1f");
			return this;
		}
		if (this.direction != direction)
		{
			if (hasInitiliazed)
			{
				this.direction = direction;
			}
			else if (_optional.path != null)
			{
				_optional.path = new LTBezierPath(LTUtility.reverse(_optional.path.pts));
			}
			else if (_optional.spline != null)
			{
				_optional.spline = new LTSpline(LTUtility.reverse(_optional.spline.pts));
			}
		}
		return this;
	}

	public LTDescr setRecursive(bool useRecursion)
	{
		this.useRecursion = useRecursion;
		return this;
	}
}
public class LTDescrOptional
{
	public AnimationCurve animationCurve;

	public int initFrameCount;

	public Color color;

	public Transform toTrans { get; set; }

	public Vector3 point { get; set; }

	public Vector3 axis { get; set; }

	public float lastVal { get; set; }

	public Quaternion origRotation { get; set; }

	public LTBezierPath path { get; set; }

	public LTSpline spline { get; set; }

	public LTRect ltRect { get; set; }

	public Action<float> onUpdateFloat { get; set; }

	public Action<float, float> onUpdateFloatRatio { get; set; }

	public Action<float, object> onUpdateFloatObject { get; set; }

	public Action<Vector2> onUpdateVector2 { get; set; }

	public Action<Vector3> onUpdateVector3 { get; set; }

	public Action<Vector3, object> onUpdateVector3Object { get; set; }

	public Action<Color> onUpdateColor { get; set; }

	public Action<Color, object> onUpdateColorObject { get; set; }

	public Action onComplete { get; set; }

	public Action<object> onCompleteObject { get; set; }

	public object onCompleteParam { get; set; }

	public object onUpdateParam { get; set; }

	public Action onStart { get; set; }

	public void reset()
	{
		animationCurve = null;
		onUpdateFloat = null;
		onUpdateFloatRatio = null;
		onUpdateVector2 = null;
		onUpdateVector3 = null;
		onUpdateFloatObject = null;
		onUpdateVector3Object = null;
		onUpdateColor = null;
		onComplete = null;
		onCompleteObject = null;
		onCompleteParam = null;
		onStart = null;
		point = Vector3.zero;
		initFrameCount = 0;
	}

	public void callOnUpdate(float val, float ratioPassed)
	{
		if (onUpdateFloat != null)
		{
			onUpdateFloat(val);
		}
		if (onUpdateFloatRatio != null)
		{
			onUpdateFloatRatio(val, ratioPassed);
		}
		else if (onUpdateFloatObject != null)
		{
			onUpdateFloatObject(val, onUpdateParam);
		}
		else if (onUpdateVector3Object != null)
		{
			onUpdateVector3Object(LTDescr.newVect, onUpdateParam);
		}
		else if (onUpdateVector3 != null)
		{
			onUpdateVector3(LTDescr.newVect);
		}
		else if (onUpdateVector2 != null)
		{
			onUpdateVector2(new Vector2(LTDescr.newVect.x, LTDescr.newVect.y));
		}
	}
}
public class LTSeq
{
	public LTSeq previous;

	public LTSeq current;

	public LTDescr tween;

	public float totalDelay;

	public float timeScale;

	private int debugIter;

	public uint counter;

	public bool toggle;

	private uint _id;

	public int id => (int)(_id | (counter << 16));

	public void reset()
	{
		previous = null;
		tween = null;
		totalDelay = 0f;
	}

	public void init(uint id, uint global_counter)
	{
		reset();
		_id = id;
		counter = global_counter;
		current = this;
	}

	private LTSeq addOn()
	{
		current.toggle = true;
		LTSeq lTSeq = current;
		current = LeanTween.sequence();
		current.previous = lTSeq;
		lTSeq.toggle = false;
		current.totalDelay = lTSeq.totalDelay;
		current.debugIter = lTSeq.debugIter + 1;
		return current;
	}

	private float addPreviousDelays()
	{
		LTSeq lTSeq = current.previous;
		if (lTSeq != null && lTSeq.tween != null)
		{
			return current.totalDelay + lTSeq.tween.time;
		}
		return current.totalDelay;
	}

	public LTSeq append(float delay)
	{
		current.totalDelay += delay;
		return current;
	}

	public LTSeq append(Action callback)
	{
		LTDescr lTDescr = LeanTween.delayedCall(0f, callback);
		return append(lTDescr);
	}

	public LTSeq append(Action<object> callback, object obj)
	{
		append(LeanTween.delayedCall(0f, callback).setOnCompleteParam(obj));
		return addOn();
	}

	public LTSeq append(GameObject gameObject, Action callback)
	{
		append(LeanTween.delayedCall(gameObject, 0f, callback));
		return addOn();
	}

	public LTSeq append(GameObject gameObject, Action<object> callback, object obj)
	{
		append(LeanTween.delayedCall(gameObject, 0f, callback).setOnCompleteParam(obj));
		return addOn();
	}

	public LTSeq append(LTDescr tween)
	{
		current.tween = tween;
		current.totalDelay = addPreviousDelays();
		tween.setDelay(current.totalDelay);
		return addOn();
	}

	public LTSeq insert(LTDescr tween)
	{
		current.tween = tween;
		tween.setDelay(addPreviousDelays());
		return addOn();
	}

	public LTSeq setScale(float timeScale)
	{
		setScaleRecursive(current, timeScale, 500);
		return addOn();
	}

	private void setScaleRecursive(LTSeq seq, float timeScale, int count)
	{
		if (count <= 0)
		{
			return;
		}
		this.timeScale = timeScale;
		seq.totalDelay *= timeScale;
		if (seq.tween != null)
		{
			if (seq.tween.time != 0f)
			{
				seq.tween.setTime(seq.tween.time * timeScale);
			}
			seq.tween.setDelay(seq.tween.delay * timeScale);
		}
		if (seq.previous != null)
		{
			setScaleRecursive(seq.previous, timeScale, count - 1);
		}
	}

	public LTSeq reverse()
	{
		return addOn();
	}
}
namespace Oculus.Platform
{
	public class AbuseReportOptions
	{
		private IntPtr Handle;

		public AbuseReportOptions()
		{
			Handle = CAPI.ovr_AbuseReportOptions_Create();
		}

		public void SetPreventPeopleChooser(bool value)
		{
			CAPI.ovr_AbuseReportOptions_SetPreventPeopleChooser(Handle, value);
		}

		public void SetReportType(AbuseReportType value)
		{
			CAPI.ovr_AbuseReportOptions_SetReportType(Handle, value);
		}

		public static explicit operator IntPtr(AbuseReportOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~AbuseReportOptions()
		{
			CAPI.ovr_AbuseReportOptions_Destroy(Handle);
		}
	}
	public enum AbuseReportType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("OBJECT")]
		Object,
		[Description("USER")]
		User
	}
	public enum AchievementType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SIMPLE")]
		Simple,
		[Description("BITFIELD")]
		Bitfield,
		[Description("COUNT")]
		Count
	}
	public class AndroidPlatform
	{
		public bool Initialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			return CAPI.ovr_UnityInitWrapper(appId);
		}

		public Request<PlatformInitialize> AsyncInitialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			return new Request<PlatformInitialize>(CAPI.ovr_UnityInitWrapperAsynchronous(appId));
		}
	}
	public class ApplicationOptions
	{
		private IntPtr Handle;

		public ApplicationOptions()
		{
			Handle = CAPI.ovr_ApplicationOptions_Create();
		}

		public void SetDeeplinkMessage(string value)
		{
			CAPI.ovr_ApplicationOptions_SetDeeplinkMessage(Handle, value);
		}

		public static explicit operator IntPtr(ApplicationOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~ApplicationOptions()
		{
			CAPI.ovr_ApplicationOptions_Destroy(Handle);
		}
	}
}
public class BufferedAudioStream
{
	private const bool VerboseLogging = false;

	private AudioSource audio;

	private float[] audioBuffer;

	private int writePos;

	private const float bufferLengthSeconds = 0.25f;

	private const int sampleRate = 48000;

	private const int bufferSize = 12000;

	private const float playbackDelayTimeSeconds = 0.05f;

	private float playbackDelayRemaining;

	private float remainingBufferTime;

	public BufferedAudioStream(AudioSource audio)
	{
		audioBuffer = new float[12000];
		this.audio = audio;
		audio.loop = true;
		audio.clip = AudioClip.Create(string.Empty, 12000, 1, 48000, stream: false);
		Stop();
	}

	public void Update()
	{
		if (remainingBufferTime > 0f)
		{
			if (!audio.isPlaying && remainingBufferTime > 0.05f)
			{
				playbackDelayRemaining -= Time.deltaTime;
				if (playbackDelayRemaining <= 0f)
				{
					audio.Play();
				}
			}
			if (audio.isPlaying)
			{
				remainingBufferTime -= Time.deltaTime;
				if (remainingBufferTime < 0f)
				{
					remainingBufferTime = 0f;
				}
			}
		}
		if (remainingBufferTime <= 0f)
		{
			if (audio.isPlaying)
			{
				UnityEngine.Debug.Log("Buffer empty, stopping " + DateTime.Now);
				Stop();
			}
			else if (writePos != 0)
			{
				UnityEngine.Debug.LogError("writePos non zero while not playing, how did this happen?");
			}
		}
	}

	private void Stop()
	{
		audio.Stop();
		audio.time = 0f;
		writePos = 0;
		playbackDelayRemaining = 0.05f;
	}

	public void AddData(float[] samples)
	{
		int num = samples.Length;
		if (writePos > audioBuffer.Length)
		{
			throw new Exception();
		}
		do
		{
			int num2 = num;
			int num3 = audioBuffer.Length - writePos;
			if (num2 > num3)
			{
				num2 = num3;
			}
			Array.Copy(samples, 0, audioBuffer, writePos, num2);
			num -= num2;
			writePos += num2;
			if (writePos > audioBuffer.Length)
			{
				throw new Exception();
			}
			if (writePos == audioBuffer.Length)
			{
				writePos = 0;
			}
		}
		while (num > 0);
		remainingBufferTime += (float)samples.Length / 48000f;
		audio.clip.SetData(audioBuffer, 0);
	}
}
namespace Oculus.Platform
{
	public static class Callback
	{
		private class RequestCallback
		{
			private Message.Callback messageCallback;

			public RequestCallback()
			{
			}

			public RequestCallback(Message.Callback callback)
			{
				messageCallback = callback;
			}

			public virtual void HandleMessage(Message msg)
			{
				if (messageCallback != null)
				{
					messageCallback(msg);
				}
			}
		}

		private sealed class RequestCallback<T> : RequestCallback
		{
			private Message<T>.Callback callback;

			public RequestCallback(Message<T>.Callback callback)
			{
				this.callback = callback;
			}

			public override void HandleMessage(Message msg)
			{
				if (callback != null)
				{
					if (!hasRegisteredRoomInviteNotificationHandler && msg.Type == Message.MessageType.Notification_Room_InviteAccepted)
					{
						pendingRoomInviteNotifications.Add(msg);
					}
					else if (msg is Message<T>)
					{
						callback((Message<T>)msg);
					}
					else
					{
						UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
					}
				}
			}
		}

		private static Dictionary<ulong, RequestCallback> requestIDsToCallbacks = new Dictionary<ulong, RequestCallback>();

		private static Dictionary<Message.MessageType, RequestCallback> notificationCallbacks = new Dictionary<Message.MessageType, RequestCallback>();

		private static bool hasRegisteredRoomInviteNotificationHandler = false;

		private static List<Message> pendingRoomInviteNotifications = new List<Message>();

		internal static void SetNotificationCallback<T>(Message.MessageType type, Message<T>.Callback callback)
		{
			if (callback == null)
			{
				throw new Exception("Cannot provide a null notification callback.");
			}
			notificationCallbacks[type] = new RequestCallback<T>(callback);
			if (type == Message.MessageType.Notification_Room_InviteAccepted)
			{
				FlushRoomInviteNotificationQueue();
			}
		}

		internal static void SetNotificationCallback(Message.MessageType type, Message.Callback callback)
		{
			if (callback == null)
			{
				throw new Exception("Cannot provide a null notification callback.");
			}
			notificationCallbacks[type] = new RequestCallback(callback);
		}

		internal static void OnComplete<T>(Request<T> request, Message<T>.Callback callback)
		{
			requestIDsToCallbacks[request.RequestID] = new RequestCallback<T>(callback);
		}

		internal static void OnComplete(Request request, Message.Callback callback)
		{
			requestIDsToCallbacks[request.RequestID] = new RequestCallback(callback);
		}

		internal static void RunCallbacks()
		{
			while (true)
			{
				Message message = Message.PopMessage();
				if (message == null)
				{
					break;
				}
				HandleMessage(message);
			}
		}

		internal static void RunLimitedCallbacks(uint limit)
		{
			for (int i = 0; i < limit; i++)
			{
				Message message = Message.PopMessage();
				if (message == null)
				{
					break;
				}
				HandleMessage(message);
			}
		}

		private static void FlushRoomInviteNotificationQueue()
		{
			hasRegisteredRoomInviteNotificationHandler = true;
			foreach (Message pendingRoomInviteNotification in pendingRoomInviteNotifications)
			{
				HandleMessage(pendingRoomInviteNotification);
			}
			pendingRoomInviteNotifications.Clear();
		}

		private static void HandleMessage(Message msg)
		{
			if (requestIDsToCallbacks.TryGetValue(msg.RequestID, out var value))
			{
				try
				{
					value.HandleMessage(msg);
					return;
				}
				finally
				{
					requestIDsToCallbacks.Remove(msg.RequestID);
				}
			}
			if (notificationCallbacks.TryGetValue(msg.Type, out value))
			{
				value.HandleMessage(msg);
			}
		}
	}
	public class CallbackRunner : MonoBehaviour
	{
		public bool IsPersistantBetweenSceneLoads = true;

		[DllImport("ovrplatformloader")]
		private static extern void ovr_UnityResetTestPlatform();

		private void Awake()
		{
			CallbackRunner callbackRunner = UnityEngine.Object.FindObjectOfType<CallbackRunner>();
			if (callbackRunner != this)
			{
				UnityEngine.Debug.LogWarning("You only need one instance of CallbackRunner");
			}
			if (IsPersistantBetweenSceneLoads)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		private void Update()
		{
			Request.RunCallbacks();
		}

		private void OnDestroy()
		{
		}
	}
	public class CAPI
	{
		public struct ovrKeyValuePair
		{
			public string key_;

			private KeyValuePairType valueType_;

			public string stringValue_;

			public int intValue_;

			public double doubleValue_;

			public ovrKeyValuePair(string key, string value)
			{
				key_ = key;
				valueType_ = KeyValuePairType.String;
				stringValue_ = value;
				intValue_ = 0;
				doubleValue_ = 0.0;
			}

			public ovrKeyValuePair(string key, int value)
			{
				key_ = key;
				valueType_ = KeyValuePairType.Int;
				intValue_ = value;
				stringValue_ = null;
				doubleValue_ = 0.0;
			}

			public ovrKeyValuePair(string key, double value)
			{
				key_ = key;
				valueType_ = KeyValuePairType.Double;
				doubleValue_ = value;
				stringValue_ = null;
				intValue_ = 0;
			}
		}

		public struct ovrMatchmakingCriterion
		{
			public string key_;

			public MatchmakingCriterionImportance importance_;

			public IntPtr parameterArray;

			public uint parameterArrayCount;

			public ovrMatchmakingCriterion(string key, MatchmakingCriterionImportance importance)
			{
				key_ = key;
				importance_ = importance;
				parameterArray = IntPtr.Zero;
				parameterArrayCount = 0u;
			}
		}

		public struct ovrMatchmakingCustomQueryData
		{
			public IntPtr dataArray;

			public uint dataArrayCount;

			public IntPtr criterionArray;

			public uint criterionArrayCount;
		}

		public struct OculusInitParams
		{
			public int sType;

			public string email;

			public string password;

			public ulong appId;

			public string uriPrefixOverride;
		}

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void FilterCallback([In][Out][MarshalAs(UnmanagedType.LPArray, SizeConst = 480)] short[] pcmData, UIntPtr pcmDataLength, int frequency, int numChannels);

		public const string DLL_NAME = "ovrplatformloader";

		private static UTF8Encoding nativeStringEncoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);

		public const int VoipFilterBufferSize = 480;

		public static IntPtr ArrayOfStructsToIntPtr(Array ar)
		{
			int num = 0;
			for (int i = 0; i < ar.Length; i++)
			{
				num += Marshal.SizeOf(ar.GetValue(i));
			}
			IntPtr intPtr = Marshal.AllocHGlobal(num);
			IntPtr intPtr2 = intPtr;
			for (int j = 0; j < ar.Length; j++)
			{
				Marshal.StructureToPtr(ar.GetValue(j), intPtr2, fDeleteOld: false);
				intPtr2 = (IntPtr)((long)intPtr2 + Marshal.SizeOf(ar.GetValue(j)));
			}
			return intPtr;
		}

		public static ovrKeyValuePair[] DictionaryToOVRKeyValuePairs(Dictionary<string, object> dict)
		{
			if (dict == null || dict.Count == 0)
			{
				return null;
			}
			ovrKeyValuePair[] array = new ovrKeyValuePair[dict.Count];
			int num = 0;
			foreach (KeyValuePair<string, object> item in dict)
			{
				if (item.Value.GetType() == typeof(int))
				{
					ref ovrKeyValuePair reference = ref array[num];
					reference = new ovrKeyValuePair(item.Key, (int)item.Value);
				}
				else if (item.Value.GetType() == typeof(string))
				{
					ref ovrKeyValuePair reference2 = ref array[num];
					reference2 = new ovrKeyValuePair(item.Key, (string)item.Value);
				}
				else
				{
					if (item.Value.GetType() != typeof(double))
					{
						throw new Exception("Only int, double or string are allowed types in CustomQuery.data");
					}
					ref ovrKeyValuePair reference3 = ref array[num];
					reference3 = new ovrKeyValuePair(item.Key, (double)item.Value);
				}
				num++;
			}
			return array;
		}

		public static byte[] IntPtrToByteArray(IntPtr data, ulong size)
		{
			byte[] array = new byte[size];
			Marshal.Copy(data, array, 0, (int)size);
			return array;
		}

		public static Dictionary<string, string> DataStoreFromNative(IntPtr pointer)
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			int num = (int)(uint)ovr_DataStore_GetNumKeys(pointer);
			for (int i = 0; i < num; i++)
			{
				string key = ovr_DataStore_GetKey(pointer, i);
				dictionary[key] = ovr_DataStore_GetValue(pointer, key);
			}
			return dictionary;
		}

		public static string StringFromNative(IntPtr pointer)
		{
			if (pointer == IntPtr.Zero)
			{
				return null;
			}
			int nativeStringLengthNotIncludingNullTerminator = GetNativeStringLengthNotIncludingNullTerminator(pointer);
			byte[] array = new byte[nativeStringLengthNotIncludingNullTerminator];
			Marshal.Copy(pointer, array, 0, nativeStringLengthNotIncludingNullTerminator);
			return nativeStringEncoding.GetString(array);
		}

		public static int GetNativeStringLengthNotIncludingNullTerminator(IntPtr pointer)
		{
			int i;
			for (i = 0; Marshal.ReadByte(pointer, i) != 0; i++)
			{
			}
			return i;
		}

		public static DateTime DateTimeFromNative(ulong seconds_since_the_one_true_epoch)
		{
			return new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(seconds_since_the_one_true_epoch).ToLocalTime();
		}

		public static byte[] BlobFromNative(uint size, IntPtr pointer)
		{
			byte[] array = new byte[size];
			for (int i = 0; i < (int)size; i++)
			{
				array[i] = Marshal.ReadByte(pointer, i);
			}
			return array;
		}

		public static byte[] FiledataFromNative(uint size, IntPtr pointer)
		{
			byte[] array = new byte[size];
			Marshal.Copy(pointer, array, 0, (int)size);
			return array;
		}

		public static IntPtr StringToNative(string s)
		{
			if (s == null)
			{
				throw new Exception("StringFromNative: null argument");
			}
			int byteCount = nativeStringEncoding.GetByteCount(s);
			byte[] array = new byte[byteCount + 1];
			nativeStringEncoding.GetBytes(s, 0, s.Length, array, 0);
			IntPtr intPtr = Marshal.AllocCoTaskMem(byteCount + 1);
			Marshal.Copy(array, 0, intPtr, byteCount + 1);
			return intPtr;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UnityInitWrapper(string appId);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UnityInitGlobals(IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_UnityInitWrapperAsynchronous(string appId);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UnityInitWrapperStandalone(string accessToken, IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Platform_InitializeStandaloneOculus(ref OculusInitParams init);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PlatformInitializeWithAccessToken(ulong appId, string accessToken);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UnityInitWrapperWindows(string appId, IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_UnityInitWrapperWindowsAsynchronous(string appId, IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_SetDeveloperAccessToken(string accessToken);

		public static string ovr_GetLoggedInUserLocale()
		{
			return StringFromNative(ovr_GetLoggedInUserLocale_Native());
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_GetLoggedInUserLocale")]
		private static extern IntPtr ovr_GetLoggedInUserLocale_Native();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_PopMessage();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_FreeMessage(IntPtr message);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_NetworkingPeer_GetSendPolicy(IntPtr networkingPeer);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Voip_CreateEncoder();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_DestroyEncoder(IntPtr encoder);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Voip_CreateDecoder();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_DestroyDecoder(IntPtr decoder);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipDecoder_Decode(IntPtr obj, byte[] compressedData, ulong compressedSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Microphone_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_Destroy(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetSystemVoipPassthrough(bool passthrough);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetSystemVoipMicrophoneMuted(VoipMuteState muted);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UnityResetTestPlatform();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_HTTP_GetWithMessageType(string url, int messageType);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_CrashApplication();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetMicrophoneFilterCallback(FilterCallback cb);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetMicrophoneFilterCallbackWithFixedSizeBuffer(FilterCallback cb, UIntPtr bufferSizeElements);

		public static void LogNewEvent(string eventName, Dictionary<string, string> values)
		{
			IntPtr intPtr = StringToNative(eventName);
			int num = values?.Count ?? 0;
			IntPtr[] array = new IntPtr[num * 2];
			if (num > 0)
			{
				int num2 = 0;
				foreach (KeyValuePair<string, string> value in values)
				{
					ref IntPtr reference = ref array[num2 * 2];
					reference = StringToNative(value.Key);
					ref IntPtr reference2 = ref array[num2 * 2 + 1];
					reference2 = StringToNative(value.Value);
					num2++;
				}
			}
			ovr_Log_NewEvent(intPtr, array, (UIntPtr)(ulong)num);
			Marshal.FreeCoTaskMem(intPtr);
			IntPtr[] array2 = array;
			foreach (IntPtr ptr in array2)
			{
				Marshal.FreeCoTaskMem(ptr);
			}
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Log_NewEvent(IntPtr eventName, IntPtr[] values, UIntPtr length);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_ApplicationLifecycle_GetLaunchDetails();

		public static ulong ovr_HTTP_StartTransfer(string url, ovrKeyValuePair[] headers)
		{
			IntPtr intPtr = StringToNative(url);
			UIntPtr numItems = (UIntPtr)(ulong)headers.Length;
			ulong result = ovr_HTTP_StartTransfer_Native(intPtr, headers, numItems);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_StartTransfer")]
		private static extern ulong ovr_HTTP_StartTransfer_Native(IntPtr url, ovrKeyValuePair[] headers, UIntPtr numItems);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_HTTP_Write(ulong transferId, byte[] bytes, UIntPtr length);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_HTTP_WriteEOM(ulong transferId);

		public static string ovr_Message_GetStringForJavascript(IntPtr message)
		{
			return StringFromNative(ovr_Message_GetStringForJavascript_Native(message));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Message_GetStringForJavascript")]
		private static extern IntPtr ovr_Message_GetStringForJavascript_Native(IntPtr message);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_Accept(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_AcceptForCurrentRoom();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_Close(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_CloseForCurrentRoom();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_Connect(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_IsConnected(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Net_Ping(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Net_ReadPacket();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_SendPacket(ulong userID, UIntPtr length, byte[] bytes, SendPolicy policy);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_SendPacketToCurrentRoom(UIntPtr length, byte[] bytes, SendPolicy policy);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_Party_PluginGetSharedMemHandle();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipMuteState ovr_Party_PluginGetVoipMicrophoneMuted();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Party_PluginGetVoipPassthrough();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemVoipStatus ovr_Party_PluginGetVoipStatus();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_Accept(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipDtxState ovr_Voip_GetIsConnectionUsingDtx(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipBitrate ovr_Voip_GetLocalBitrate(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetOutputBufferMaxSize();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCM(ulong senderID, short[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMFloat(ulong senderID, float[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMSize(ulong senderID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMWithTimestamp(ulong senderID, short[] outputBuffer, UIntPtr outputBufferNumElements, uint[] timestamp);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMWithTimestampFloat(ulong senderID, float[] outputBuffer, UIntPtr outputBufferNumElements, uint[] timestamp);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipBitrate ovr_Voip_GetRemoteBitrate(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Voip_GetSyncTimestamp(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_Voip_GetSyncTimestampDifference(uint lhs, uint rhs);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipMuteState ovr_Voip_GetSystemVoipMicrophoneMuted();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemVoipStatus ovr_Voip_GetSystemVoipStatus();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetMicrophoneMuted(VoipMuteState state);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetNewConnectionOptions(IntPtr voipOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetOutputSampleRate(VoipSampleRate rate);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_Start(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_Stop(ulong userID);

		public static ulong ovr_Achievements_AddCount(string name, ulong count)
		{
			IntPtr intPtr = StringToNative(name);
			ulong result = ovr_Achievements_AddCount_Native(intPtr, count);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Achievements_AddCount")]
		private static extern ulong ovr_Achievements_AddCount_Native(IntPtr name, ulong count);

		public static ulong ovr_Achievements_AddFields(string name, string fields)
		{
			IntPtr intPtr = StringToNative(name);
			IntPtr intPtr2 = StringToNative(fields);
			ulong result = ovr_Achievements_AddFields_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Achievements_AddFields")]
		private static extern ulong ovr_Achievements_AddFields_Native(IntPtr name, IntPtr fields);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetAllDefinitions();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetAllProgress();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetDefinitionsByName(string[] names, int count);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetProgressByName(string[] names, int count);

		public static ulong ovr_Achievements_Unlock(string name)
		{
			IntPtr intPtr = StringToNative(name);
			ulong result = ovr_Achievements_Unlock_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Achievements_Unlock")]
		private static extern ulong ovr_Achievements_Unlock_Native(IntPtr name);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_ExecuteCoordinatedLaunch(ulong appID, ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_GetInstalledApplications();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_GetVersion();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_LaunchOtherApp(ulong appID, IntPtr deeplink_options);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_ApplicationLifecycle_GetRegisteredPIDs();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_ApplicationLifecycle_GetSessionKey();

		public static ulong ovr_ApplicationLifecycle_RegisterSessionKey(string sessionKey)
		{
			IntPtr intPtr = StringToNative(sessionKey);
			ulong result = ovr_ApplicationLifecycle_RegisterSessionKey_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationLifecycle_RegisterSessionKey")]
		private static extern ulong ovr_ApplicationLifecycle_RegisterSessionKey_Native(IntPtr sessionKey);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_Delete(ulong assetFileID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_DeleteById(ulong assetFileID);

		public static ulong ovr_AssetFile_DeleteByName(string assetFileName)
		{
			IntPtr intPtr = StringToNative(assetFileName);
			ulong result = ovr_AssetFile_DeleteByName_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFile_DeleteByName")]
		private static extern ulong ovr_AssetFile_DeleteByName_Native(IntPtr assetFileName);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_Download(ulong assetFileID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_DownloadById(ulong assetFileID);

		public static ulong ovr_AssetFile_DownloadByName(string assetFileName)
		{
			IntPtr intPtr = StringToNative(assetFileName);
			ulong result = ovr_AssetFile_DownloadByName_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFile_DownloadByName")]
		private static extern ulong ovr_AssetFile_DownloadByName_Native(IntPtr assetFileName);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_DownloadCancel(ulong assetFileID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_DownloadCancelById(ulong assetFileID);

		public static ulong ovr_AssetFile_DownloadCancelByName(string assetFileName)
		{
			IntPtr intPtr = StringToNative(assetFileName);
			ulong result = ovr_AssetFile_DownloadCancelByName_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFile_DownloadCancelByName")]
		private static extern ulong ovr_AssetFile_DownloadCancelByName_Native(IntPtr assetFileName);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_GetList();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_Status(ulong assetFileID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_StatusById(ulong assetFileID);

		public static ulong ovr_AssetFile_StatusByName(string assetFileName)
		{
			IntPtr intPtr = StringToNative(assetFileName);
			ulong result = ovr_AssetFile_StatusByName_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFile_StatusByName")]
		private static extern ulong ovr_AssetFile_StatusByName_Native(IntPtr assetFileName);

		public static ulong ovr_Avatar_UpdateMetaData(string avatarMetaData, string imageFilePath)
		{
			IntPtr intPtr = StringToNative(avatarMetaData);
			IntPtr intPtr2 = StringToNative(imageFilePath);
			ulong result = ovr_Avatar_UpdateMetaData_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Avatar_UpdateMetaData")]
		private static extern ulong ovr_Avatar_UpdateMetaData_Native(IntPtr avatarMetaData, IntPtr imageFilePath);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Cal_FinalizeApplication(ulong groupingObject, ulong[] userIDs, int numUserIDs, ulong finalized_application_ID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Cal_GetSuggestedApplications(ulong groupingObject, ulong[] userIDs, int numUserIDs);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Cal_ProposeApplication(ulong groupingObject, ulong[] userIDs, int numUserIDs, ulong proposed_application_ID);

		public static ulong ovr_CloudStorage_Delete(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_Delete_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_Delete")]
		private static extern ulong ovr_CloudStorage_Delete_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_Load(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_Load_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_Load")]
		private static extern ulong ovr_CloudStorage_Load_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_LoadBucketMetadata(string bucket)
		{
			IntPtr intPtr = StringToNative(bucket);
			ulong result = ovr_CloudStorage_LoadBucketMetadata_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadBucketMetadata")]
		private static extern ulong ovr_CloudStorage_LoadBucketMetadata_Native(IntPtr bucket);

		public static ulong ovr_CloudStorage_LoadConflictMetadata(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_LoadConflictMetadata_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadConflictMetadata")]
		private static extern ulong ovr_CloudStorage_LoadConflictMetadata_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_LoadHandle(string handle)
		{
			IntPtr intPtr = StringToNative(handle);
			ulong result = ovr_CloudStorage_LoadHandle_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadHandle")]
		private static extern ulong ovr_CloudStorage_LoadHandle_Native(IntPtr handle);

		public static ulong ovr_CloudStorage_LoadMetadata(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_LoadMetadata_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadMetadata")]
		private static extern ulong ovr_CloudStorage_LoadMetadata_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_ResolveKeepLocal(string bucket, string key, string remoteHandle)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			IntPtr intPtr3 = StringToNative(remoteHandle);
			ulong result = ovr_CloudStorage_ResolveKeepLocal_Native(intPtr, intPtr2, intPtr3);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_ResolveKeepLocal")]
		private static extern ulong ovr_CloudStorage_ResolveKeepLocal_Native(IntPtr bucket, IntPtr key, IntPtr remoteHandle);

		public static ulong ovr_CloudStorage_ResolveKeepRemote(string bucket, string key, string remoteHandle)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			IntPtr intPtr3 = StringToNative(remoteHandle);
			ulong result = ovr_CloudStorage_ResolveKeepRemote_Native(intPtr, intPtr2, intPtr3);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_ResolveKeepRemote")]
		private static extern ulong ovr_CloudStorage_ResolveKeepRemote_Native(IntPtr bucket, IntPtr key, IntPtr remoteHandle);

		public static ulong ovr_CloudStorage_Save(string bucket, string key, byte[] data, uint dataSize, long counter, string extraData)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			IntPtr intPtr3 = StringToNative(extraData);
			ulong result = ovr_CloudStorage_Save_Native(intPtr, intPtr2, data, dataSize, counter, intPtr3);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_Save")]
		private static extern ulong ovr_CloudStorage_Save_Native(IntPtr bucket, IntPtr key, byte[] data, uint dataSize, long counter, IntPtr extraData);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CloudStorage2_GetUserDirectoryPath();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Entitlement_GetIsViewerEntitled();

		public static ulong ovr_GraphAPI_Get(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_GraphAPI_Get_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_GraphAPI_Get")]
		private static extern ulong ovr_GraphAPI_Get_Native(IntPtr url);

		public static ulong ovr_GraphAPI_Post(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_GraphAPI_Post_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_GraphAPI_Post")]
		private static extern ulong ovr_GraphAPI_Post_Native(IntPtr url);

		public static ulong ovr_HTTP_Get(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_HTTP_Get_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_Get")]
		private static extern ulong ovr_HTTP_Get_Native(IntPtr url);

		public static ulong ovr_HTTP_GetToFile(string url, string diskFile)
		{
			IntPtr intPtr = StringToNative(url);
			IntPtr intPtr2 = StringToNative(diskFile);
			ulong result = ovr_HTTP_GetToFile_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_GetToFile")]
		private static extern ulong ovr_HTTP_GetToFile_Native(IntPtr url, IntPtr diskFile);

		public static ulong ovr_HTTP_MultiPartPost(string url, string filepath_param_name, string filepath, string access_token, ovrKeyValuePair[] post_params)
		{
			IntPtr intPtr = StringToNative(url);
			IntPtr intPtr2 = StringToNative(filepath_param_name);
			IntPtr intPtr3 = StringToNative(filepath);
			IntPtr intPtr4 = StringToNative(access_token);
			UIntPtr numItems = (UIntPtr)(ulong)post_params.Length;
			ulong result = ovr_HTTP_MultiPartPost_Native(intPtr, intPtr2, intPtr3, intPtr4, post_params, numItems);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			Marshal.FreeCoTaskMem(intPtr4);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_MultiPartPost")]
		private static extern ulong ovr_HTTP_MultiPartPost_Native(IntPtr url, IntPtr filepath_param_name, IntPtr filepath, IntPtr access_token, ovrKeyValuePair[] post_params, UIntPtr numItems);

		public static ulong ovr_HTTP_Post(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_HTTP_Post_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_Post")]
		private static extern ulong ovr_HTTP_Post_Native(IntPtr url);

		public static ulong ovr_IAP_ConsumePurchase(string sku)
		{
			IntPtr intPtr = StringToNative(sku);
			ulong result = ovr_IAP_ConsumePurchase_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_IAP_ConsumePurchase")]
		private static extern ulong ovr_IAP_ConsumePurchase_Native(IntPtr sku);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_IAP_GetProductsBySKU(string[] skus, int count);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_IAP_GetViewerPurchases();

		public static ulong ovr_IAP_LaunchCheckoutFlow(string sku)
		{
			IntPtr intPtr = StringToNative(sku);
			ulong result = ovr_IAP_LaunchCheckoutFlow_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_IAP_LaunchCheckoutFlow")]
		private static extern ulong ovr_IAP_LaunchCheckoutFlow_Native(IntPtr sku);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LanguagePack_GetCurrent();

		public static ulong ovr_LanguagePack_SetCurrent(string tag)
		{
			IntPtr intPtr = StringToNative(tag);
			ulong result = ovr_LanguagePack_SetCurrent_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LanguagePack_SetCurrent")]
		private static extern ulong ovr_LanguagePack_SetCurrent_Native(IntPtr tag);

		public static ulong ovr_Leaderboard_GetEntries(string leaderboardName, int limit, LeaderboardFilterType filter, LeaderboardStartAt startAt)
		{
			IntPtr intPtr = StringToNative(leaderboardName);
			ulong result = ovr_Leaderboard_GetEntries_Native(intPtr, limit, filter, startAt);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Leaderboard_GetEntries")]
		private static extern ulong ovr_Leaderboard_GetEntries_Native(IntPtr leaderboardName, int limit, LeaderboardFilterType filter, LeaderboardStartAt startAt);

		public static ulong ovr_Leaderboard_GetEntriesAfterRank(string leaderboardName, int limit, ulong afterRank)
		{
			IntPtr intPtr = StringToNative(leaderboardName);
			ulong result = ovr_Leaderboard_GetEntriesAfterRank_Native(intPtr, limit, afterRank);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Leaderboard_GetEntriesAfterRank")]
		private static extern ulong ovr_Leaderboard_GetEntriesAfterRank_Native(IntPtr leaderboardName, int limit, ulong afterRank);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Leaderboard_GetNextEntries(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Leaderboard_GetPreviousEntries(IntPtr handle);

		public static ulong ovr_Leaderboard_WriteEntry(string leaderboardName, long score, byte[] extraData, uint extraDataLength, bool forceUpdate)
		{
			IntPtr intPtr = StringToNative(leaderboardName);
			ulong result = ovr_Leaderboard_WriteEntry_Native(intPtr, score, extraData, extraDataLength, forceUpdate);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Leaderboard_WriteEntry")]
		private static extern ulong ovr_Leaderboard_WriteEntry_Native(IntPtr leaderboardName, long score, byte[] extraData, uint extraDataLength, bool forceUpdate);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_GetStatus();

		public static ulong ovr_Livestreaming_IsAllowedForApplication(string packageName)
		{
			IntPtr intPtr = StringToNative(packageName);
			ulong result = ovr_Livestreaming_IsAllowedForApplication_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Livestreaming_IsAllowedForApplication")]
		private static extern ulong ovr_Livestreaming_IsAllowedForApplication_Native(IntPtr packageName);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_PauseStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_ResumeStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_StartPartyStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_StartStream(LivestreamingAudience audience, LivestreamingMicrophoneStatus micStatus);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_StopPartyStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_StopStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_UpdateCommentsOverlayVisibility(bool isVisible);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_UpdateMicStatus(LivestreamingMicrophoneStatus micStatus);

		public static ulong ovr_Matchmaking_Browse(string pool, IntPtr customQueryData)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Browse_Native(intPtr, customQueryData);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Browse")]
		private static extern ulong ovr_Matchmaking_Browse_Native(IntPtr pool, IntPtr customQueryData);

		public static ulong ovr_Matchmaking_Browse2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Browse2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Browse2")]
		private static extern ulong ovr_Matchmaking_Browse2_Native(IntPtr pool, IntPtr matchmakingOptions);

		public static ulong ovr_Matchmaking_Cancel(string pool, string requestHash)
		{
			IntPtr intPtr = StringToNative(pool);
			IntPtr intPtr2 = StringToNative(requestHash);
			ulong result = ovr_Matchmaking_Cancel_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Cancel")]
		private static extern ulong ovr_Matchmaking_Cancel_Native(IntPtr pool, IntPtr requestHash);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_Cancel2();

		public static ulong ovr_Matchmaking_CreateAndEnqueueRoom(string pool, uint maxUsers, bool subscribeToUpdates, IntPtr customQueryData)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateAndEnqueueRoom_Native(intPtr, maxUsers, subscribeToUpdates, customQueryData);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateAndEnqueueRoom")]
		private static extern ulong ovr_Matchmaking_CreateAndEnqueueRoom_Native(IntPtr pool, uint maxUsers, bool subscribeToUpdates, IntPtr customQueryData);

		public static ulong ovr_Matchmaking_CreateAndEnqueueRoom2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateAndEnqueueRoom2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateAndEnqueueRoom2")]
		private static extern ulong ovr_Matchmaking_CreateAndEnqueueRoom2_Native(IntPtr pool, IntPtr matchmakingOptions);

		public static ulong ovr_Matchmaking_CreateRoom(string pool, uint maxUsers, bool subscribeToUpdates)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateRoom_Native(intPtr, maxUsers, subscribeToUpdates);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateRoom")]
		private static extern ulong ovr_Matchmaking_CreateRoom_Native(IntPtr pool, uint maxUsers, bool subscribeToUpdates);

		public static ulong ovr_Matchmaking_CreateRoom2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateRoom2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateRoom2")]
		private static extern ulong ovr_Matchmaking_CreateRoom2_Native(IntPtr pool, IntPtr matchmakingOptions);

		public static ulong ovr_Matchmaking_Enqueue(string pool, IntPtr customQueryData)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Enqueue_Native(intPtr, customQueryData);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Enqueue")]
		private static extern ulong ovr_Matchmaking_Enqueue_Native(IntPtr pool, IntPtr customQueryData);

		public static ulong ovr_Matchmaking_Enqueue2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Enqueue2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Enqueue2")]
		private static extern ulong ovr_Matchmaking_Enqueue2_Native(IntPtr pool, IntPtr matchmakingOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_EnqueueRoom(ulong roomID, IntPtr customQueryData);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_EnqueueRoom2(ulong roomID, IntPtr matchmakingOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_GetAdminSnapshot();

		public static ulong ovr_Matchmaking_GetStats(string pool, uint maxLevel, MatchmakingStatApproach approach)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_GetStats_Native(intPtr, maxLevel, approach);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_GetStats")]
		private static extern ulong ovr_Matchmaking_GetStats_Native(IntPtr pool, uint maxLevel, MatchmakingStatApproach approach);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_JoinRoom(ulong roomID, bool subscribeToUpdates);

		public static ulong ovr_Matchmaking_ReportResultInsecure(ulong roomID, ovrKeyValuePair[] data)
		{
			UIntPtr numItems = (UIntPtr)(ulong)data.Length;
			return ovr_Matchmaking_ReportResultInsecure_Native(roomID, data, numItems);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_ReportResultInsecure")]
		private static extern ulong ovr_Matchmaking_ReportResultInsecure_Native(ulong roomID, ovrKeyValuePair[] data, UIntPtr numItems);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_StartMatch(ulong roomID);

		public static ulong ovr_Media_ShareToFacebook(string postTextSuggestion, string filePath, MediaContentType contentType)
		{
			IntPtr intPtr = StringToNative(postTextSuggestion);
			IntPtr intPtr2 = StringToNative(filePath);
			ulong result = ovr_Media_ShareToFacebook_Native(intPtr, intPtr2, contentType);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Media_ShareToFacebook")]
		private static extern ulong ovr_Media_ShareToFacebook_Native(IntPtr postTextSuggestion, IntPtr filePath, MediaContentType contentType);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Notification_GetRoomInvites();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Notification_MarkAsRead(ulong notificationID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GatherInApplication(ulong partyID, ulong appID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Get(ulong partyID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GetCurrent();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GetCurrentForUser(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Invite(ulong partyID, ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Join(ulong partyID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Leave(ulong partyID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_CreateAndJoinPrivate(RoomJoinPolicy joinPolicy, uint maxUsers, bool subscribeToUpdates);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_CreateAndJoinPrivate2(RoomJoinPolicy joinPolicy, uint maxUsers, IntPtr roomOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Get(ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetCurrent();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetCurrentForUser(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetInvitableUsers();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetInvitableUsers2(IntPtr roomOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetModeratedRooms();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetSocialRooms(ulong appID);

		public static ulong ovr_Room_InviteUser(ulong roomID, string inviteToken)
		{
			IntPtr intPtr = StringToNative(inviteToken);
			ulong result = ovr_Room_InviteUser_Native(roomID, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_InviteUser")]
		private static extern ulong ovr_Room_InviteUser_Native(ulong roomID, IntPtr inviteToken);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Join(ulong roomID, bool subscribeToUpdates);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Join2(ulong roomID, IntPtr roomOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_KickUser(ulong roomID, ulong userID, int kickDurationSeconds);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_LaunchInvitableUserFlow(ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Leave(ulong roomID);

		public static ulong ovr_Room_SetDescription(ulong roomID, string description)
		{
			IntPtr intPtr = StringToNative(description);
			ulong result = ovr_Room_SetDescription_Native(roomID, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_SetDescription")]
		private static extern ulong ovr_Room_SetDescription_Native(ulong roomID, IntPtr description);

		public static ulong ovr_Room_UpdateDataStore(ulong roomID, ovrKeyValuePair[] data)
		{
			UIntPtr numItems = (UIntPtr)(ulong)data.Length;
			return ovr_Room_UpdateDataStore_Native(roomID, data, numItems);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_UpdateDataStore")]
		private static extern ulong ovr_Room_UpdateDataStore_Native(ulong roomID, ovrKeyValuePair[] data, UIntPtr numItems);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdateMembershipLockStatus(ulong roomID, RoomMembershipLockStatus membershipLockStatus);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdateOwner(ulong roomID, ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdatePrivateRoomJoinPolicy(ulong roomID, RoomJoinPolicy newJoinPolicy);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_SystemPermissions_GetStatus(PermissionType permType);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_SystemPermissions_LaunchDeeplink(PermissionType permType);

		public static ulong ovr_User_CancelRecordingForReportFlow(string recordingUUID)
		{
			IntPtr intPtr = StringToNative(recordingUUID);
			ulong result = ovr_User_CancelRecordingForReportFlow_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_CancelRecordingForReportFlow")]
		private static extern ulong ovr_User_CancelRecordingForReportFlow_Native(IntPtr recordingUUID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_Get(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetAccessToken();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLinkedAccounts(IntPtr userOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUser();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUserFriends();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUserFriendsAndRooms();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUserRecentlyMetUsersAndRooms(IntPtr userOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetOrgScopedID(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetSdkAccounts();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetUserProof();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchBlockFlow(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchFriendRequestFlow(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchProfile(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchReportFlow(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchReportFlow2(ulong optionalUserID, IntPtr abuseReportOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchUnblockFlow(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_NewEntitledTestUser();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_NewTestUser();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_NewTestUserFriends();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_StartRecordingForReportFlow();

		public static ulong ovr_User_StopRecordingAndLaunchReportFlow(ulong optionalUserID, string optionalRecordingUUID)
		{
			IntPtr intPtr = StringToNative(optionalRecordingUUID);
			ulong result = ovr_User_StopRecordingAndLaunchReportFlow_Native(optionalUserID, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_StopRecordingAndLaunchReportFlow")]
		private static extern ulong ovr_User_StopRecordingAndLaunchReportFlow_Native(ulong optionalUserID, IntPtr optionalRecordingUUID);

		public static ulong ovr_User_StopRecordingAndLaunchReportFlow2(ulong optionalUserID, string optionalRecordingUUID, IntPtr abuseReportOptions)
		{
			IntPtr intPtr = StringToNative(optionalRecordingUUID);
			ulong result = ovr_User_StopRecordingAndLaunchReportFlow2_Native(optionalUserID, intPtr, abuseReportOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_StopRecordingAndLaunchReportFlow2")]
		private static extern ulong ovr_User_StopRecordingAndLaunchReportFlow2_Native(ulong optionalUserID, IntPtr optionalRecordingUUID, IntPtr abuseReportOptions);

		public static ulong ovr_User_TestUserCreateDeviceManifest(string deviceID, ulong[] appIDs, int numAppIDs)
		{
			IntPtr intPtr = StringToNative(deviceID);
			ulong result = ovr_User_TestUserCreateDeviceManifest_Native(intPtr, appIDs, numAppIDs);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_TestUserCreateDeviceManifest")]
		private static extern ulong ovr_User_TestUserCreateDeviceManifest_Native(IntPtr deviceID, ulong[] appIDs, int numAppIDs);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Voip_SetSystemVoipSuppressed(bool suppressed);

		public static string ovr_AbuseReportRecording_GetRecordingUuid(IntPtr obj)
		{
			return StringFromNative(ovr_AbuseReportRecording_GetRecordingUuid_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AbuseReportRecording_GetRecordingUuid")]
		private static extern IntPtr ovr_AbuseReportRecording_GetRecordingUuid_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_AchievementDefinition_GetBitfieldLength(IntPtr obj);

		public static string ovr_AchievementDefinition_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementDefinition_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementDefinition_GetName")]
		private static extern IntPtr ovr_AchievementDefinition_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AchievementDefinition_GetTarget(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern AchievementType ovr_AchievementDefinition_GetType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AchievementDefinitionArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_AchievementDefinitionArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementDefinitionArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementDefinitionArray_GetNextUrl")]
		private static extern IntPtr ovr_AchievementDefinitionArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_AchievementDefinitionArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementDefinitionArray_HasNextPage(IntPtr obj);

		public static string ovr_AchievementProgress_GetBitfield(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementProgress_GetBitfield_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgress_GetBitfield")]
		private static extern IntPtr ovr_AchievementProgress_GetBitfield_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AchievementProgress_GetCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementProgress_GetIsUnlocked(IntPtr obj);

		public static string ovr_AchievementProgress_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementProgress_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgress_GetName")]
		private static extern IntPtr ovr_AchievementProgress_GetName_Native(IntPtr obj);

		public static DateTime ovr_AchievementProgress_GetUnlockTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_AchievementProgress_GetUnlockTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgress_GetUnlockTime")]
		private static extern ulong ovr_AchievementProgress_GetUnlockTime_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AchievementProgressArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_AchievementProgressArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementProgressArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgressArray_GetNextUrl")]
		private static extern IntPtr ovr_AchievementProgressArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_AchievementProgressArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementProgressArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementUpdate_GetJustUnlocked(IntPtr obj);

		public static string ovr_AchievementUpdate_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementUpdate_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementUpdate_GetName")]
		private static extern IntPtr ovr_AchievementUpdate_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_ApplicationVersion_GetCurrentCode(IntPtr obj);

		public static string ovr_ApplicationVersion_GetCurrentName(IntPtr obj)
		{
			return StringFromNative(ovr_ApplicationVersion_GetCurrentName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationVersion_GetCurrentName")]
		private static extern IntPtr ovr_ApplicationVersion_GetCurrentName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_ApplicationVersion_GetLatestCode(IntPtr obj);

		public static string ovr_ApplicationVersion_GetLatestName(IntPtr obj)
		{
			return StringFromNative(ovr_ApplicationVersion_GetLatestName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationVersion_GetLatestName")]
		private static extern IntPtr ovr_ApplicationVersion_GetLatestName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetDetails_GetAssetId(IntPtr obj);

		public static string ovr_AssetDetails_GetAssetType(IntPtr obj)
		{
			return StringFromNative(ovr_AssetDetails_GetAssetType_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetDetails_GetAssetType")]
		private static extern IntPtr ovr_AssetDetails_GetAssetType_Native(IntPtr obj);

		public static string ovr_AssetDetails_GetDownloadStatus(IntPtr obj)
		{
			return StringFromNative(ovr_AssetDetails_GetDownloadStatus_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetDetails_GetDownloadStatus")]
		private static extern IntPtr ovr_AssetDetails_GetDownloadStatus_Native(IntPtr obj);

		public static string ovr_AssetDetails_GetFilepath(IntPtr obj)
		{
			return StringFromNative(ovr_AssetDetails_GetFilepath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetDetails_GetFilepath")]
		private static extern IntPtr ovr_AssetDetails_GetFilepath_Native(IntPtr obj);

		public static string ovr_AssetDetails_GetIapStatus(IntPtr obj)
		{
			return StringFromNative(ovr_AssetDetails_GetIapStatus_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetDetails_GetIapStatus")]
		private static extern IntPtr ovr_AssetDetails_GetIapStatus_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AssetDetails_GetLanguage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AssetDetailsArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_AssetDetailsArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDeleteResult_GetAssetFileId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDeleteResult_GetAssetId(IntPtr obj);

		public static string ovr_AssetFileDeleteResult_GetFilepath(IntPtr obj)
		{
			return StringFromNative(ovr_AssetFileDeleteResult_GetFilepath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFileDeleteResult_GetFilepath")]
		private static extern IntPtr ovr_AssetFileDeleteResult_GetFilepath_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AssetFileDeleteResult_GetSuccess(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadCancelResult_GetAssetFileId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadCancelResult_GetAssetId(IntPtr obj);

		public static string ovr_AssetFileDownloadCancelResult_GetFilepath(IntPtr obj)
		{
			return StringFromNative(ovr_AssetFileDownloadCancelResult_GetFilepath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFileDownloadCancelResult_GetFilepath")]
		private static extern IntPtr ovr_AssetFileDownloadCancelResult_GetFilepath_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AssetFileDownloadCancelResult_GetSuccess(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadResult_GetAssetId(IntPtr obj);

		public static string ovr_AssetFileDownloadResult_GetFilepath(IntPtr obj)
		{
			return StringFromNative(ovr_AssetFileDownloadResult_GetFilepath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFileDownloadResult_GetFilepath")]
		private static extern IntPtr ovr_AssetFileDownloadResult_GetFilepath_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadUpdate_GetAssetFileId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadUpdate_GetAssetId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_AssetFileDownloadUpdate_GetBytesTotal(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_AssetFileDownloadUpdate_GetBytesTransferred(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AssetFileDownloadUpdate_GetCompleted(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_CalApplicationFinalized_GetCountdownMS(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CalApplicationFinalized_GetID(IntPtr obj);

		public static string ovr_CalApplicationFinalized_GetLaunchDetails(IntPtr obj)
		{
			return StringFromNative(ovr_CalApplicationFinalized_GetLaunchDetails_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CalApplicationFinalized_GetLaunchDetails")]
		private static extern IntPtr ovr_CalApplicationFinalized_GetLaunchDetails_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CalApplicationProposed_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CalApplicationSuggestion_GetID(IntPtr obj);

		public static string ovr_CalApplicationSuggestion_GetSocialContext(IntPtr obj)
		{
			return StringFromNative(ovr_CalApplicationSuggestion_GetSocialContext_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CalApplicationSuggestion_GetSocialContext")]
		private static extern IntPtr ovr_CalApplicationSuggestion_GetSocialContext_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CalApplicationSuggestionArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_CalApplicationSuggestionArray_GetSize(IntPtr obj);

		public static string ovr_CloudStorage2UserDirectoryPathResponse_GetPath(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorage2UserDirectoryPathResponse_GetPath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage2UserDirectoryPathResponse_GetPath")]
		private static extern IntPtr ovr_CloudStorage2UserDirectoryPathResponse_GetPath_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CloudStorageConflictMetadata_GetLocal(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CloudStorageConflictMetadata_GetRemote(IntPtr obj);

		public static string ovr_CloudStorageData_GetBucket(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageData_GetBucket_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageData_GetBucket")]
		private static extern IntPtr ovr_CloudStorageData_GetBucket_Native(IntPtr obj);

		public static byte[] ovr_CloudStorageData_GetData(IntPtr obj)
		{
			return FiledataFromNative(ovr_CloudStorageData_GetDataSize(obj), ovr_CloudStorageData_GetData_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageData_GetData")]
		private static extern IntPtr ovr_CloudStorageData_GetData_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_CloudStorageData_GetDataSize(IntPtr obj);

		public static string ovr_CloudStorageData_GetKey(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageData_GetKey_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageData_GetKey")]
		private static extern IntPtr ovr_CloudStorageData_GetKey_Native(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetBucket(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetBucket_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetBucket")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetBucket_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_CloudStorageMetadata_GetCounter(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_CloudStorageMetadata_GetDataSize(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetExtraData(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetExtraData_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetExtraData")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetExtraData_Native(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetKey(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetKey_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetKey")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetKey_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CloudStorageMetadata_GetSaveTime(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern CloudStorageDataStatus ovr_CloudStorageMetadata_GetStatus(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetVersionHandle(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetVersionHandle_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetVersionHandle")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetVersionHandle_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CloudStorageMetadataArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_CloudStorageMetadataArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadataArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadataArray_GetNextUrl")]
		private static extern IntPtr ovr_CloudStorageMetadataArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_CloudStorageMetadataArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_CloudStorageMetadataArray_HasNextPage(IntPtr obj);

		public static string ovr_CloudStorageUpdateResponse_GetBucket(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageUpdateResponse_GetBucket_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageUpdateResponse_GetBucket")]
		private static extern IntPtr ovr_CloudStorageUpdateResponse_GetBucket_Native(IntPtr obj);

		public static string ovr_CloudStorageUpdateResponse_GetKey(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageUpdateResponse_GetKey_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageUpdateResponse_GetKey")]
		private static extern IntPtr ovr_CloudStorageUpdateResponse_GetKey_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern CloudStorageUpdateStatus ovr_CloudStorageUpdateResponse_GetStatus(IntPtr obj);

		public static string ovr_CloudStorageUpdateResponse_GetVersionHandle(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageUpdateResponse_GetVersionHandle_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageUpdateResponse_GetVersionHandle")]
		private static extern IntPtr ovr_CloudStorageUpdateResponse_GetVersionHandle_Native(IntPtr obj);

		public static uint ovr_DataStore_Contains(IntPtr obj, string key)
		{
			IntPtr intPtr = StringToNative(key);
			uint result = ovr_DataStore_Contains_Native(obj, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DataStore_Contains")]
		private static extern uint ovr_DataStore_Contains_Native(IntPtr obj, IntPtr key);

		public static string ovr_DataStore_GetKey(IntPtr obj, int index)
		{
			return StringFromNative(ovr_DataStore_GetKey_Native(obj, index));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DataStore_GetKey")]
		private static extern IntPtr ovr_DataStore_GetKey_Native(IntPtr obj, int index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_DataStore_GetNumKeys(IntPtr obj);

		public static string ovr_DataStore_GetValue(IntPtr obj, string key)
		{
			IntPtr intPtr = StringToNative(key);
			string result = StringFromNative(ovr_DataStore_GetValue_Native(obj, intPtr));
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DataStore_GetValue")]
		private static extern IntPtr ovr_DataStore_GetValue_Native(IntPtr obj, IntPtr key);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_Error_GetCode(IntPtr obj);

		public static string ovr_Error_GetDisplayableMessage(IntPtr obj)
		{
			return StringFromNative(ovr_Error_GetDisplayableMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Error_GetDisplayableMessage")]
		private static extern IntPtr ovr_Error_GetDisplayableMessage_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_Error_GetHttpCode(IntPtr obj);

		public static string ovr_Error_GetMessage(IntPtr obj)
		{
			return StringFromNative(ovr_Error_GetMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Error_GetMessage")]
		private static extern IntPtr ovr_Error_GetMessage_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_HttpTransferUpdate_GetBytes(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_HttpTransferUpdate_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_HttpTransferUpdate_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_HttpTransferUpdate_IsCompleted(IntPtr obj);

		public static string ovr_InstalledApplication_GetApplicationId(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetApplicationId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetApplicationId")]
		private static extern IntPtr ovr_InstalledApplication_GetApplicationId_Native(IntPtr obj);

		public static string ovr_InstalledApplication_GetPackageName(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetPackageName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetPackageName")]
		private static extern IntPtr ovr_InstalledApplication_GetPackageName_Native(IntPtr obj);

		public static string ovr_InstalledApplication_GetStatus(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetStatus_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetStatus")]
		private static extern IntPtr ovr_InstalledApplication_GetStatus_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_InstalledApplication_GetVersionCode(IntPtr obj);

		public static string ovr_InstalledApplication_GetVersionName(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetVersionName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetVersionName")]
		private static extern IntPtr ovr_InstalledApplication_GetVersionName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_InstalledApplicationArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_InstalledApplicationArray_GetSize(IntPtr obj);

		public static string ovr_LanguagePackInfo_GetEnglishName(IntPtr obj)
		{
			return StringFromNative(ovr_LanguagePackInfo_GetEnglishName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LanguagePackInfo_GetEnglishName")]
		private static extern IntPtr ovr_LanguagePackInfo_GetEnglishName_Native(IntPtr obj);

		public static string ovr_LanguagePackInfo_GetNativeName(IntPtr obj)
		{
			return StringFromNative(ovr_LanguagePackInfo_GetNativeName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LanguagePackInfo_GetNativeName")]
		private static extern IntPtr ovr_LanguagePackInfo_GetNativeName_Native(IntPtr obj);

		public static string ovr_LanguagePackInfo_GetTag(IntPtr obj)
		{
			return StringFromNative(ovr_LanguagePackInfo_GetTag_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LanguagePackInfo_GetTag")]
		private static extern IntPtr ovr_LanguagePackInfo_GetTag_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchBlockFlowResult_GetDidBlock(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchBlockFlowResult_GetDidCancel(IntPtr obj);

		public static string ovr_LaunchDetails_GetDeeplinkMessage(IntPtr obj)
		{
			return StringFromNative(ovr_LaunchDetails_GetDeeplinkMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LaunchDetails_GetDeeplinkMessage")]
		private static extern IntPtr ovr_LaunchDetails_GetDeeplinkMessage_Native(IntPtr obj);

		public static string ovr_LaunchDetails_GetLaunchSource(IntPtr obj)
		{
			return StringFromNative(ovr_LaunchDetails_GetLaunchSource_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LaunchDetails_GetLaunchSource")]
		private static extern IntPtr ovr_LaunchDetails_GetLaunchSource_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern LaunchType ovr_LaunchDetails_GetLaunchType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LaunchDetails_GetRoomID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LaunchDetails_GetUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchFriendRequestFlowResult_GetDidCancel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchFriendRequestFlowResult_GetDidSendRequest(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchReportFlowResult_GetDidCancel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LaunchReportFlowResult_GetUserReportId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchUnblockFlowResult_GetDidCancel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchUnblockFlowResult_GetDidUnblock(IntPtr obj);

		public static byte[] ovr_LeaderboardEntry_GetExtraData(IntPtr obj)
		{
			return BlobFromNative(ovr_LeaderboardEntry_GetExtraDataLength(obj), ovr_LeaderboardEntry_GetExtraData_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntry_GetExtraData")]
		private static extern IntPtr ovr_LeaderboardEntry_GetExtraData_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_LeaderboardEntry_GetExtraDataLength(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LeaderboardEntry_GetRank(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_LeaderboardEntry_GetScore(IntPtr obj);

		public static DateTime ovr_LeaderboardEntry_GetTimestamp(IntPtr obj)
		{
			return DateTimeFromNative(ovr_LeaderboardEntry_GetTimestamp_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntry_GetTimestamp")]
		private static extern ulong ovr_LeaderboardEntry_GetTimestamp_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LeaderboardEntry_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LeaderboardEntryArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_LeaderboardEntryArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_LeaderboardEntryArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntryArray_GetNextUrl")]
		private static extern IntPtr ovr_LeaderboardEntryArray_GetNextUrl_Native(IntPtr obj);

		public static string ovr_LeaderboardEntryArray_GetPreviousUrl(IntPtr obj)
		{
			return StringFromNative(ovr_LeaderboardEntryArray_GetPreviousUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntryArray_GetPreviousUrl")]
		private static extern IntPtr ovr_LeaderboardEntryArray_GetPreviousUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_LeaderboardEntryArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LeaderboardEntryArray_GetTotalCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LeaderboardEntryArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LeaderboardEntryArray_HasPreviousPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LeaderboardUpdateStatus_GetDidUpdate(IntPtr obj);

		public static string ovr_LinkedAccount_GetAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_LinkedAccount_GetAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LinkedAccount_GetAccessToken")]
		private static extern IntPtr ovr_LinkedAccount_GetAccessToken_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ServiceProvider ovr_LinkedAccount_GetServiceProvider(IntPtr obj);

		public static string ovr_LinkedAccount_GetUserId(IntPtr obj)
		{
			return StringFromNative(ovr_LinkedAccount_GetUserId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LinkedAccount_GetUserId")]
		private static extern IntPtr ovr_LinkedAccount_GetUserId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LinkedAccountArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_LinkedAccountArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingApplicationStatus_GetStreamingEnabled(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern LivestreamingStartStatus ovr_LivestreamingStartResult_GetStreamingResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetCommentsVisible(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetIsPaused(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetLivestreamingEnabled(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LivestreamingStatus_GetLivestreamingType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetMicEnabled(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LivestreamingVideoStats_GetCommentCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LivestreamingVideoStats_GetReactionCount(IntPtr obj);

		public static string ovr_LivestreamingVideoStats_GetTotalViews(IntPtr obj)
		{
			return StringFromNative(ovr_LivestreamingVideoStats_GetTotalViews_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LivestreamingVideoStats_GetTotalViews")]
		private static extern IntPtr ovr_LivestreamingVideoStats_GetTotalViews_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingAdminSnapshot_GetCandidates(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshot_GetMyCurrentThreshold(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_MatchmakingAdminSnapshotCandidate_GetCanMatch(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshotCandidate_GetMyTotalScore(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshotCandidate_GetTheirCurrentThreshold(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshotCandidate_GetTheirTotalScore(IntPtr obj);

		public static string ovr_MatchmakingAdminSnapshotCandidate_GetTraceId(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingAdminSnapshotCandidate_GetTraceId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingAdminSnapshotCandidate_GetTraceId")]
		private static extern IntPtr ovr_MatchmakingAdminSnapshotCandidate_GetTraceId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingAdminSnapshotCandidateArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingAdminSnapshotCandidateArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingBrowseResult_GetEnqueueResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingBrowseResult_GetRooms(IntPtr obj);

		public static string ovr_MatchmakingCandidate_GetEntryHash(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingCandidate_GetEntryHash_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingCandidate_GetEntryHash")]
		private static extern IntPtr ovr_MatchmakingCandidate_GetEntryHash_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_MatchmakingCandidate_GetUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingCandidateArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_MatchmakingCandidateArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingCandidateArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingCandidateArray_GetNextUrl")]
		private static extern IntPtr ovr_MatchmakingCandidateArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingCandidateArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_MatchmakingCandidateArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueueResult_GetAdminSnapshot(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetAverageWait(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetMatchesInLastHourCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetMaxExpectedWait(IntPtr obj);

		public static string ovr_MatchmakingEnqueueResult_GetPool(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingEnqueueResult_GetPool_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingEnqueueResult_GetPool")]
		private static extern IntPtr ovr_MatchmakingEnqueueResult_GetPool_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetRecentMatchPercentage(IntPtr obj);

		public static string ovr_MatchmakingEnqueueResult_GetRequestHash(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingEnqueueResult_GetRequestHash_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingEnqueueResult_GetRequestHash")]
		private static extern IntPtr ovr_MatchmakingEnqueueResult_GetRequestHash_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueueResultAndRoom_GetMatchmakingEnqueueResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueueResultAndRoom_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_MatchmakingEnqueuedUser_GetAdditionalUserID(IntPtr obj, uint index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueuedUser_GetAdditionalUserIDsSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueuedUser_GetCustomData(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueuedUser_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueuedUserArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingEnqueuedUserArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_MatchmakingNotification_GetAddedByUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingNotification_GetRoom(IntPtr obj);

		public static string ovr_MatchmakingNotification_GetTraceId(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingNotification_GetTraceId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingNotification_GetTraceId")]
		private static extern IntPtr ovr_MatchmakingNotification_GetTraceId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingRoom_GetPingTime(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingRoom_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_MatchmakingRoom_HasPingTime(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingRoomArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingRoomArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetDrawCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetLossCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetSkillLevel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetWinCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAbuseReportRecording(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAchievementDefinitionArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAchievementProgressArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAchievementUpdate(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetApplicationVersion(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetDetails(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetDetailsArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetFileDeleteResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetFileDownloadCancelResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetFileDownloadResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetFileDownloadUpdate(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCalApplicationFinalized(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCalApplicationProposed(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCalApplicationSuggestionArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageConflictMetadata(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageData(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageMetadata(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageMetadataArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageUpdateResponse(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetError(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetHttpTransferUpdate(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetInstalledApplicationArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLaunchBlockFlowResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLaunchFriendRequestFlowResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLaunchReportFlowResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLaunchUnblockFlowResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLeaderboardEntryArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLeaderboardUpdateStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLinkedAccountArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingApplicationStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingStartResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingVideoStats(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingAdminSnapshot(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingBrowseResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingEnqueueResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingEnqueueResultAndRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingRoomArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingStats(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetNativeMessage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetNetworkingPeer(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetOrgScopedID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetParty(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPartyID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPidArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPingResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPlatformInitialize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetProductArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPurchase(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPurchaseArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Message_GetRequestID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoomArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoomInviteNotification(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoomInviteNotificationArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetSdkAccountArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetShareMediaResult(IntPtr obj);

		public static string ovr_Message_GetString(IntPtr obj)
		{
			return StringFromNative(ovr_Message_GetString_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Message_GetString")]
		private static extern IntPtr ovr_Message_GetString_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetSystemPermission(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetSystemVoipState(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern Message.MessageType ovr_Message_GetType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserAndRoomArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserProof(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserReportID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Message_IsError(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetNumSamplesAvailable(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetOutputBufferMaxSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetPCM(IntPtr obj, short[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetPCMFloat(IntPtr obj, float[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_ReadData(IntPtr obj, float[] outputBuffer, UIntPtr outputBufferSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_SetAcceptableRecordingDelayHint(IntPtr obj, UIntPtr delayMs);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_Start(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_Stop(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_NetworkingPeer_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern PeerConnectionState ovr_NetworkingPeer_GetState(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_OrgScopedID_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Packet_Free(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Packet_GetBytes(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SendPolicy ovr_Packet_GetSendPolicy(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Packet_GetSenderID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Packet_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetInvitedUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetLeader(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PartyID_GetID(IntPtr obj);

		public static string ovr_Pid_GetId(IntPtr obj)
		{
			return StringFromNative(ovr_Pid_GetId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Pid_GetId")]
		private static extern IntPtr ovr_Pid_GetId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_PidArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_PidArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PingResult_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PingResult_GetPingTimeUsec(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_PingResult_IsTimeout(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern PlatformInitializeResult ovr_PlatformInitialize_GetResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Price_GetAmountInHundredths(IntPtr obj);

		public static string ovr_Price_GetCurrency(IntPtr obj)
		{
			return StringFromNative(ovr_Price_GetCurrency_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Price_GetCurrency")]
		private static extern IntPtr ovr_Price_GetCurrency_Native(IntPtr obj);

		public static string ovr_Price_GetFormatted(IntPtr obj)
		{
			return StringFromNative(ovr_Price_GetFormatted_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Price_GetFormatted")]
		private static extern IntPtr ovr_Price_GetFormatted_Native(IntPtr obj);

		public static string ovr_Product_GetDescription(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetDescription_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetDescription")]
		private static extern IntPtr ovr_Product_GetDescription_Native(IntPtr obj);

		public static string ovr_Product_GetFormattedPrice(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetFormattedPrice_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetFormattedPrice")]
		private static extern IntPtr ovr_Product_GetFormattedPrice_Native(IntPtr obj);

		public static string ovr_Product_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetName")]
		private static extern IntPtr ovr_Product_GetName_Native(IntPtr obj);

		public static string ovr_Product_GetSKU(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetSKU_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetSKU")]
		private static extern IntPtr ovr_Product_GetSKU_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_ProductArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_ProductArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_ProductArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ProductArray_GetNextUrl")]
		private static extern IntPtr ovr_ProductArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_ProductArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_ProductArray_HasNextPage(IntPtr obj);

		public static DateTime ovr_Purchase_GetExpirationTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_Purchase_GetExpirationTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Purchase_GetExpirationTime")]
		private static extern ulong ovr_Purchase_GetExpirationTime_Native(IntPtr obj);

		public static DateTime ovr_Purchase_GetGrantTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_Purchase_GetGrantTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Purchase_GetGrantTime")]
		private static extern ulong ovr_Purchase_GetGrantTime_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Purchase_GetPurchaseID(IntPtr obj);

		public static string ovr_Purchase_GetSKU(IntPtr obj)
		{
			return StringFromNative(ovr_Purchase_GetSKU_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Purchase_GetSKU")]
		private static extern IntPtr ovr_Purchase_GetSKU_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_PurchaseArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_PurchaseArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_PurchaseArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_PurchaseArray_GetNextUrl")]
		private static extern IntPtr ovr_PurchaseArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_PurchaseArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_PurchaseArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetApplicationID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetDataStore(IntPtr obj);

		public static string ovr_Room_GetDescription(IntPtr obj)
		{
			return StringFromNative(ovr_Room_GetDescription_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_GetDescription")]
		private static extern IntPtr ovr_Room_GetDescription_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetInvitedUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Room_GetIsMembershipLocked(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern RoomJoinPolicy ovr_Room_GetJoinPolicy(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern RoomJoinability ovr_Room_GetJoinability(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetMatchedUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Room_GetMaxUsers(IntPtr obj);

		public static string ovr_Room_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_Room_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_GetName")]
		private static extern IntPtr ovr_Room_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetOwner(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern RoomType ovr_Room_GetType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Room_GetVersion(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RoomArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_RoomArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_RoomArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomArray_GetNextUrl")]
		private static extern IntPtr ovr_RoomArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_RoomArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_RoomArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RoomInviteNotification_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RoomInviteNotification_GetRoomID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RoomInviteNotification_GetSenderID(IntPtr obj);

		public static DateTime ovr_RoomInviteNotification_GetSentTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_RoomInviteNotification_GetSentTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomInviteNotification_GetSentTime")]
		private static extern ulong ovr_RoomInviteNotification_GetSentTime_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RoomInviteNotificationArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_RoomInviteNotificationArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_RoomInviteNotificationArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomInviteNotificationArray_GetNextUrl")]
		private static extern IntPtr ovr_RoomInviteNotificationArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_RoomInviteNotificationArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_RoomInviteNotificationArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SdkAccountType ovr_SdkAccount_GetAccountType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_SdkAccount_GetUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_SdkAccountArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_SdkAccountArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ShareMediaStatus ovr_ShareMediaResult_GetStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_SystemPermission_GetHasPermission(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern PermissionGrantStatus ovr_SystemPermission_GetPermissionGrantStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipMuteState ovr_SystemVoipState_GetMicrophoneMuted(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemVoipStatus ovr_SystemVoipState_GetStatus(IntPtr obj);

		public static string ovr_TestUser_GetAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_TestUser_GetAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUser_GetAccessToken")]
		private static extern IntPtr ovr_TestUser_GetAccessToken_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_TestUser_GetAppAccessArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_TestUser_GetFbAppAccessArray(IntPtr obj);

		public static string ovr_TestUser_GetFriendAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_TestUser_GetFriendAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUser_GetFriendAccessToken")]
		private static extern IntPtr ovr_TestUser_GetFriendAccessToken_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_TestUser_GetFriendAppAccessArray(IntPtr obj);

		public static string ovr_TestUser_GetUserAlias(IntPtr obj)
		{
			return StringFromNative(ovr_TestUser_GetUserAlias_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUser_GetUserAlias")]
		private static extern IntPtr ovr_TestUser_GetUserAlias_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUser_GetUserFbid(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUser_GetUserId(IntPtr obj);

		public static string ovr_TestUserAppAccess_GetAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_TestUserAppAccess_GetAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUserAppAccess_GetAccessToken")]
		private static extern IntPtr ovr_TestUserAppAccess_GetAccessToken_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUserAppAccess_GetAppId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUserAppAccess_GetUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_TestUserAppAccessArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_TestUserAppAccessArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetID(IntPtr obj);

		public static string ovr_User_GetImageUrl(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetImageUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetImageUrl")]
		private static extern IntPtr ovr_User_GetImageUrl_Native(IntPtr obj);

		public static string ovr_User_GetInviteToken(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetInviteToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetInviteToken")]
		private static extern IntPtr ovr_User_GetInviteToken_Native(IntPtr obj);

		public static string ovr_User_GetOculusID(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetOculusID_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetOculusID")]
		private static extern IntPtr ovr_User_GetOculusID_Native(IntPtr obj);

		public static string ovr_User_GetPresence(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetPresence_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetPresence")]
		private static extern IntPtr ovr_User_GetPresence_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UserPresenceStatus ovr_User_GetPresenceStatus(IntPtr obj);

		public static string ovr_User_GetSmallImageUrl(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetSmallImageUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetSmallImageUrl")]
		private static extern IntPtr ovr_User_GetSmallImageUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserAndRoom_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserAndRoom_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserAndRoomArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_UserAndRoomArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_UserAndRoomArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_UserAndRoomArray_GetNextUrl")]
		private static extern IntPtr ovr_UserAndRoomArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_UserAndRoomArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UserAndRoomArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_UserArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_UserArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_UserArray_GetNextUrl")]
		private static extern IntPtr ovr_UserArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_UserArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UserArray_HasNextPage(IntPtr obj);

		public static string ovr_UserProof_GetNonce(IntPtr obj)
		{
			return StringFromNative(ovr_UserProof_GetNonce_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_UserProof_GetNonce")]
		private static extern IntPtr ovr_UserProof_GetNonce_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UserReportID_GetDidCancel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_UserReportID_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipDecoder_Decode(IntPtr obj, byte[] compressedData, UIntPtr compressedSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_VoipDecoder_GetDecodedPCM(IntPtr obj, float[] outputBuffer, UIntPtr outputBufferSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipEncoder_AddPCM(IntPtr obj, float[] inputData, uint inputSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_VoipEncoder_GetCompressedData(IntPtr obj, byte[] outputBuffer, UIntPtr intputSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_VoipEncoder_GetCompressedDataSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AbuseReportOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_AbuseReportOptions_Destroy(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_AbuseReportOptions_SetPreventPeopleChooser(IntPtr handle, bool value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_AbuseReportOptions_SetReportType(IntPtr handle, AbuseReportType value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_ApplicationOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_ApplicationOptions_Destroy(IntPtr handle);

		public static void ovr_ApplicationOptions_SetDeeplinkMessage(IntPtr handle, string value)
		{
			IntPtr intPtr = StringToNative(value);
			ovr_ApplicationOptions_SetDeeplinkMessage_Native(handle, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationOptions_SetDeeplinkMessage")]
		private static extern void ovr_ApplicationOptions_SetDeeplinkMessage_Native(IntPtr handle, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_Destroy(IntPtr handle);

		public static void ovr_MatchmakingOptions_SetCreateRoomDataStoreString(IntPtr handle, string key, string value)
		{
			IntPtr intPtr = StringToNative(key);
			IntPtr intPtr2 = StringToNative(value);
			ovr_MatchmakingOptions_SetCreateRoomDataStoreString_Native(handle, intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetCreateRoomDataStoreString")]
		private static extern void ovr_MatchmakingOptions_SetCreateRoomDataStoreString_Native(IntPtr handle, IntPtr key, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_ClearCreateRoomDataStore(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_SetCreateRoomJoinPolicy(IntPtr handle, RoomJoinPolicy value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_SetCreateRoomMaxUsers(IntPtr handle, uint value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_AddEnqueueAdditionalUser(IntPtr handle, ulong value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_ClearEnqueueAdditionalUsers(IntPtr handle);

		public static void ovr_MatchmakingOptions_SetEnqueueDataSettingsInt(IntPtr handle, string key, int value)
		{
			IntPtr intPtr = StringToNative(key);
			ovr_MatchmakingOptions_SetEnqueueDataSettingsInt_Native(handle, intPtr, value);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueDataSettingsInt")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueDataSettingsInt_Native(IntPtr handle, IntPtr key, int value);

		public static void ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble(IntPtr handle, string key, double value)
		{
			IntPtr intPtr = StringToNative(key);
			ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble_Native(handle, intPtr, value);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble_Native(IntPtr handle, IntPtr key, double value);

		public static void ovr_MatchmakingOptions_SetEnqueueDataSettingsString(IntPtr handle, string key, string value)
		{
			IntPtr intPtr = StringToNative(key);
			IntPtr intPtr2 = StringToNative(value);
			ovr_MatchmakingOptions_SetEnqueueDataSettingsString_Native(handle, intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueDataSettingsString")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueDataSettingsString_Native(IntPtr handle, IntPtr key, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_ClearEnqueueDataSettings(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_SetEnqueueIsDebug(IntPtr handle, bool value);

		public static void ovr_MatchmakingOptions_SetEnqueueQueryKey(IntPtr handle, string value)
		{
			IntPtr intPtr = StringToNative(value);
			ovr_MatchmakingOptions_SetEnqueueQueryKey_Native(handle, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueQueryKey")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueQueryKey_Native(IntPtr handle, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RoomOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_Destroy(IntPtr handle);

		public static void ovr_RoomOptions_SetDataStoreString(IntPtr handle, string key, string value)
		{
			IntPtr intPtr = StringToNative(key);
			IntPtr intPtr2 = StringToNative(value);
			ovr_RoomOptions_SetDataStoreString_Native(handle, intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomOptions_SetDataStoreString")]
		private static extern void ovr_RoomOptions_SetDataStoreString_Native(IntPtr handle, IntPtr key, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_ClearDataStore(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetExcludeRecentlyMet(IntPtr handle, bool value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetMaxUserResults(IntPtr handle, uint value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetOrdering(IntPtr handle, UserOrdering value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetRecentlyMetTimeWindow(IntPtr handle, TimeWindow value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetRoomId(IntPtr handle, ulong value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetTurnOffUpdates(IntPtr handle, bool value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_Destroy(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_SetMaxUsers(IntPtr handle, uint value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_AddServiceProvider(IntPtr handle, ServiceProvider value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_ClearServiceProviders(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_SetTimeWindow(IntPtr handle, TimeWindow value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_VoipOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipOptions_Destroy(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipOptions_SetBitrateForNewConnections(IntPtr handle, VoipBitrate value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipOptions_SetCreateNewConnectionUseDtx(IntPtr handle, VoipDtxState value);
	}
	public enum CloudStorageDataStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("IN_SYNC")]
		InSync,
		[Description("NEEDS_DOWNLOAD")]
		NeedsDownload,
		[Description("REMOTE_DOWNLOADING")]
		RemoteDownloading,
		[Description("NEEDS_UPLOAD")]
		NeedsUpload,
		[Description("LOCAL_UPLOADING")]
		LocalUploading,
		[Description("IN_CONFLICT")]
		InConflict
	}
	public enum CloudStorageUpdateStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("OK")]
		Ok,
		[Description("BETTER_VERSION_STORED")]
		BetterVersionStored,
		[Description("MANUAL_MERGE_REQUIRED")]
		ManualMergeRequired
	}
	public interface IMicrophone
	{
		void Start();

		void Stop();

		float[] Update();
	}
	public interface IVoipPCMSource
	{
		int GetPCM(float[] dest, int length);

		void SetSenderID(ulong senderID);

		void Update();

		int PeekSizeElements();
	}
	public enum KeyValuePairType
	{
		[Description("STRING")]
		String,
		[Description("INTEGER")]
		Int,
		[Description("DOUBLE")]
		Double,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum LaunchType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("NORMAL")]
		Normal,
		[Description("INVITE")]
		Invite,
		[Description("COORDINATED")]
		Coordinated,
		[Description("DEEPLINK")]
		Deeplink
	}
	public enum LeaderboardFilterType
	{
		[Description("NONE")]
		None,
		[Description("FRIENDS")]
		Friends,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum LeaderboardStartAt
	{
		[Description("TOP")]
		Top,
		[Description("CENTERED_ON_VIEWER")]
		CenteredOnViewer,
		[Description("CENTERED_ON_VIEWER_OR_TOP")]
		CenteredOnViewerOrTop,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum LivestreamingAudience
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("PUBLIC")]
		Public,
		[Description("FRIENDS")]
		Friends,
		[Description("ONLY_ME")]
		OnlyMe
	}
	public enum LivestreamingMicrophoneStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MICROPHONE_ON")]
		MicrophoneOn,
		[Description("MICROPHONE_OFF")]
		MicrophoneOff
	}
	public enum LivestreamingStartStatus
	{
		[Description("SUCCESS")]
		Success = 1,
		[Description("UNKNOWN")]
		Unknown = 0,
		[Description("NO_PACKAGE_SET")]
		NoPackageSet = -1,
		[Description("NO_FB_CONNECT")]
		NoFbConnect = -2,
		[Description("NO_SESSION_ID")]
		NoSessionId = -3,
		[Description("MISSING_PARAMETERS")]
		MissingParameters = -4
	}
	public enum MatchmakingCriterionImportance
	{
		[Description("REQUIRED")]
		Required,
		[Description("HIGH")]
		High,
		[Description("MEDIUM")]
		Medium,
		[Description("LOW")]
		Low,
		[Description("UNKNOWN")]
		Unknown
	}
	public class MatchmakingOptions
	{
		private IntPtr Handle;

		public MatchmakingOptions()
		{
			Handle = CAPI.ovr_MatchmakingOptions_Create();
		}

		public void SetCreateRoomDataStore(string key, string value)
		{
			CAPI.ovr_MatchmakingOptions_SetCreateRoomDataStoreString(Handle, key, value);
		}

		public void ClearCreateRoomDataStore()
		{
			CAPI.ovr_MatchmakingOptions_ClearCreateRoomDataStore(Handle);
		}

		public void SetCreateRoomJoinPolicy(RoomJoinPolicy value)
		{
			CAPI.ovr_MatchmakingOptions_SetCreateRoomJoinPolicy(Handle, value);
		}

		public void SetCreateRoomMaxUsers(uint value)
		{
			CAPI.ovr_MatchmakingOptions_SetCreateRoomMaxUsers(Handle, value);
		}

		public void AddEnqueueAdditionalUser(ulong userID)
		{
			CAPI.ovr_MatchmakingOptions_AddEnqueueAdditionalUser(Handle, userID);
		}

		public void ClearEnqueueAdditionalUsers()
		{
			CAPI.ovr_MatchmakingOptions_ClearEnqueueAdditionalUsers(Handle);
		}

		public void SetEnqueueDataSettings(string key, int value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueDataSettingsInt(Handle, key, value);
		}

		public void SetEnqueueDataSettings(string key, double value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble(Handle, key, value);
		}

		public void SetEnqueueDataSettings(string key, string value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueDataSettingsString(Handle, key, value);
		}

		public void ClearEnqueueDataSettings()
		{
			CAPI.ovr_MatchmakingOptions_ClearEnqueueDataSettings(Handle);
		}

		public void SetEnqueueIsDebug(bool value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueIsDebug(Handle, value);
		}

		public void SetEnqueueQueryKey(string value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueQueryKey(Handle, value);
		}

		public static explicit operator IntPtr(MatchmakingOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~MatchmakingOptions()
		{
			CAPI.ovr_MatchmakingOptions_Destroy(Handle);
		}
	}
	public enum MatchmakingStatApproach
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("TRAILING")]
		Trailing,
		[Description("SWINGY")]
		Swingy
	}
	public enum MediaContentType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("PHOTO")]
		Photo
	}
	public abstract class Message<T> : Message
	{
		public new delegate void Callback(Message<T> message);

		private T data;

		public T Data => data;

		public Message(IntPtr c_message)
			: base(c_message)
		{
			if (!base.IsError)
			{
				data = GetDataFromMessage(c_message);
			}
		}

		protected abstract T GetDataFromMessage(IntPtr c_message);
	}
	public class Message
	{
		public delegate void Callback(Message message);

		public enum MessageType : uint
		{
			Unknown = 0u,
			Achievements_AddCount = 65495601u,
			Achievements_AddFields = 346693929u,
			Achievements_GetAllDefinitions = 64177549u,
			Achievements_GetAllProgress = 1335877149u,
			Achievements_GetDefinitionsByName = 1653670332u,
			Achievements_GetNextAchievementDefinitionArrayPage = 712888917u,
			Achievements_GetNextAchievementProgressArrayPage = 792913703u,
			Achievements_GetProgressByName = 354837425u,
			Achievements_Unlock = 1497156573u,
			ApplicationLifecycle_GetRegisteredPIDs = 82169698u,
			ApplicationLifecycle_GetSessionKey = 984570141u,
			ApplicationLifecycle_RegisterSessionKey = 1303818232u,
			Application_GetVersion = 1751583246u,
			Application_LaunchOtherApp = 1424151032u,
			AssetFile_Delete = 1834842246u,
			AssetFile_DeleteById = 1525206354u,
			AssetFile_DeleteByName = 1108001231u,
			AssetFile_Download = 289710021u,
			AssetFile_DownloadById = 755009938u,
			AssetFile_DownloadByName = 1664536314u,
			AssetFile_DownloadCancel = 134927303u,
			AssetFile_DownloadCancelById = 1365611796u,
			AssetFile_DownloadCancelByName = 1147858170u,
			AssetFile_GetList = 1258057588u,
			AssetFile_Status = 47394656u,
			AssetFile_StatusById = 1570069816u,
			AssetFile_StatusByName = 1104140880u,
			CloudStorage_Delete = 685393261u,
			CloudStorage_GetNextCloudStorageMetadataArrayPage = 1544004335u,
			CloudStorage_Load = 1082420033u,
			CloudStorage_LoadBucketMetadata = 1931977997u,
			CloudStorage_LoadConflictMetadata = 1146770162u,
			CloudStorage_LoadHandle = 845863478u,
			CloudStorage_LoadMetadata = 65446546u,
			CloudStorage_ResolveKeepLocal = 811109637u,
			CloudStorage_ResolveKeepRemote = 1965400838u,
			CloudStorage_Save = 1270570030u,
			Entitlement_GetIsViewerEntitled = 409688241u,
			IAP_ConsumePurchase = 532378329u,
			IAP_GetNextProductArrayPage = 467225263u,
			IAP_GetNextPurchaseArrayPage = 1196886677u,
			IAP_GetProductsBySKU = 2124073717u,
			IAP_GetViewerPurchases = 974095385u,
			IAP_LaunchCheckoutFlow = 1067126029u,
			LanguagePack_GetCurrent = 529592533u,
			LanguagePack_SetCurrent = 1531952096u,
			Leaderboard_GetEntries = 1572030284u,
			Leaderboard_GetEntriesAfterRank = 406293487u,
			Leaderboard_GetNextEntries = 1310751961u,
			Leaderboard_GetPreviousEntries = 1224858304u,
			Leaderboard_WriteEntry = 293587198u,
			Livestreaming_GetStatus = 1218079125u,
			Livestreaming_PauseStream = 916223619u,
			Livestreaming_ResumeStream = 575827343u,
			Matchmaking_Browse = 509948616u,
			Matchmaking_Browse2 = 1715641947u,
			Matchmaking_Cancel = 543705519u,
			Matchmaking_Cancel2 = 285117908u,
			Matchmaking_CreateAndEnqueueRoom = 1615617480u,
			Matchmaking_CreateAndEnqueueRoom2 = 693889755u,
			Matchmaking_CreateRoom = 54203178u,
			Matchmaking_CreateRoom2 = 1231922052u,
			Matchmaking_Enqueue = 1086418033u,
			Matchmaking_Enqueue2 = 303174325u,
			Matchmaking_EnqueueRoom = 1888108644u,
			Matchmaking_EnqueueRoom2 = 1428741028u,
			Matchmaking_GetAdminSnapshot = 1008820116u,
			Matchmaking_GetStats = 1123849272u,
			Matchmaking_JoinRoom = 1295177725u,
			Matchmaking_ReportResultInsecure = 439800205u,
			Matchmaking_StartMatch = 1154746693u,
			Media_ShareToFacebook = 14912239u,
			Notification_GetNextRoomInviteNotificationArrayPage = 102890359u,
			Notification_GetRoomInvites = 1871801234u,
			Notification_MarkAsRead = 1903319523u,
			Party_GetCurrent = 1200830304u,
			Room_CreateAndJoinPrivate = 1977017207u,
			Room_CreateAndJoinPrivate2 = 1513775683u,
			Room_Get = 1704628152u,
			Room_GetCurrent = 161916164u,
			Room_GetCurrentForUser = 234887141u,
			Room_GetInvitableUsers = 506615698u,
			Room_GetInvitableUsers2 = 1330899120u,
			Room_GetModeratedRooms = 159645047u,
			Room_GetNextRoomArrayPage = 1317239238u,
			Room_InviteUser = 1093266451u,
			Room_Join = 382373641u,
			Room_Join2 = 1303059522u,
			Room_KickUser = 1233344310u,
			Room_LaunchInvitableUserFlow = 843047539u,
			Room_Leave = 1916281973u,
			Room_SetDescription = 809796911u,
			Room_UpdateDataStore = 40779816u,
			Room_UpdateMembershipLockStatus = 923514796u,
			Room_UpdateOwner = 850803997u,
			Room_UpdatePrivateRoomJoinPolicy = 289473179u,
			User_Get = 1808768583u,
			User_GetAccessToken = 111696574u,
			User_GetLoggedInUser = 1131361373u,
			User_GetLoggedInUserFriends = 1484532365u,
			User_GetLoggedInUserFriendsAndRooms = 1585908615u,
			User_GetLoggedInUserRecentlyMetUsersAndRooms = 694139440u,
			User_GetNextUserAndRoomArrayPage = 2143146719u,
			User_GetNextUserArrayPage = 645723971u,
			User_GetOrgScopedID = 418426907u,
			User_GetSdkAccounts = 1733454467u,
			User_GetUserProof = 578880643u,
			User_LaunchFriendRequestFlow = 151303576u,
			User_LaunchProfile = 171537047u,
			Voip_SetSystemVoipSuppressed = 1161808298u,
			Notification_ApplicationLifecycle_LaunchIntentChanged = 78859427u,
			Notification_AssetFile_DownloadUpdate = 803015885u,
			Notification_Cal_FinalizeApplication = 1963741337u,
			Notification_Cal_ProposeApplication = 779375093u,
			Notification_HTTP_Transfer = 2111073839u,
			Notification_Livestreaming_StatusChange = 575101294u,
			Notification_Matchmaking_MatchFound = 197393623u,
			Notification_Networking_ConnectionStateChange = 1577243802u,
			Notification_Networking_PeerConnectRequest = 1295114959u,
			Notification_Networking_PingResult = 1360343058u,
			Notification_Room_InviteAccepted = 1829794225u,
			Notification_Room_InviteReceived = 1783209300u,
			Notification_Room_RoomUpdate = 1626094639u,
			Notification_Voip_ConnectRequest = 908343318u,
			Notification_Voip_StateChange = 888120928u,
			Notification_Voip_SystemVoipState = 1490179237u,
			Platform_InitializeWithAccessToken = 896085803u,
			Platform_InitializeStandaloneOculus = 1375260172u,
			Platform_InitializeAndroidAsynchronous = 450037684u,
			Platform_InitializeWindowsAsynchronous = 1839708815u
		}

		internal delegate Message ExtraMessageTypesHandler(IntPtr messageHandle, MessageType message_type);

		private MessageType type;

		private ulong requestID;

		private Error error;

		public MessageType Type => type;

		public bool IsError => error != null;

		public ulong RequestID => requestID;

		internal static ExtraMessageTypesHandler HandleExtraMessageTypes { private get; set; }

		public Message(IntPtr c_message)
		{
			type = CAPI.ovr_Message_GetType(c_message);
			bool flag = CAPI.ovr_Message_IsError(c_message);
			requestID = CAPI.ovr_Message_GetRequestID(c_message);
			if (flag)
			{
				IntPtr obj = CAPI.ovr_Message_GetError(c_message);
				error = new Error(CAPI.ovr_Error_GetCode(obj), CAPI.ovr_Error_GetMessage(obj), CAPI.ovr_Error_GetHttpCode(obj));
			}
			else if (Core.LogMessages)
			{
				string text = CAPI.ovr_Message_GetString(c_message);
				if (text != null)
				{
					UnityEngine.Debug.Log(text);
				}
				else
				{
					UnityEngine.Debug.Log($"null message string {c_message}");
				}
			}
		}

		~Message()
		{
		}

		public virtual Error GetError()
		{
			return error;
		}

		public virtual PingResult GetPingResult()
		{
			return null;
		}

		public virtual NetworkingPeer GetNetworkingPeer()
		{
			return null;
		}

		public virtual HttpTransferUpdate GetHttpTransferUpdate()
		{
			return null;
		}

		public virtual PlatformInitialize GetPlatformInitialize()
		{
			return null;
		}

		public virtual AbuseReportRecording GetAbuseReportRecording()
		{
			return null;
		}

		public virtual AchievementDefinitionList GetAchievementDefinitions()
		{
			return null;
		}

		public virtual AchievementProgressList GetAchievementProgressList()
		{
			return null;
		}

		public virtual AchievementUpdate GetAchievementUpdate()
		{
			return null;
		}

		public virtual ApplicationVersion GetApplicationVersion()
		{
			return null;
		}

		public virtual AssetDetails GetAssetDetails()
		{
			return null;
		}

		public virtual AssetDetailsList GetAssetDetailsList()
		{
			return null;
		}

		public virtual AssetFileDeleteResult GetAssetFileDeleteResult()
		{
			return null;
		}

		public virtual AssetFileDownloadCancelResult GetAssetFileDownloadCancelResult()
		{
			return null;
		}

		public virtual AssetFileDownloadResult GetAssetFileDownloadResult()
		{
			return null;
		}

		public virtual AssetFileDownloadUpdate GetAssetFileDownloadUpdate()
		{
			return null;
		}

		public virtual CalApplicationFinalized GetCalApplicationFinalized()
		{
			return null;
		}

		public virtual CalApplicationProposed GetCalApplicationProposed()
		{
			return null;
		}

		public virtual CalApplicationSuggestionList GetCalApplicationSuggestionList()
		{
			return null;
		}

		public virtual CloudStorageConflictMetadata GetCloudStorageConflictMetadata()
		{
			return null;
		}

		public virtual CloudStorageData GetCloudStorageData()
		{
			return null;
		}

		public virtual CloudStorageMetadata GetCloudStorageMetadata()
		{
			return null;
		}

		public virtual CloudStorageMetadataList GetCloudStorageMetadataList()
		{
			return null;
		}

		public virtual CloudStorageUpdateResponse GetCloudStorageUpdateResponse()
		{
			return null;
		}

		public virtual InstalledApplicationList GetInstalledApplicationList()
		{
			return null;
		}

		public virtual LaunchBlockFlowResult GetLaunchBlockFlowResult()
		{
			return null;
		}

		public virtual LaunchFriendRequestFlowResult GetLaunchFriendRequestFlowResult()
		{
			return null;
		}

		public virtual LaunchReportFlowResult GetLaunchReportFlowResult()
		{
			return null;
		}

		public virtual LaunchUnblockFlowResult GetLaunchUnblockFlowResult()
		{
			return null;
		}

		public virtual bool GetLeaderboardDidUpdate()
		{
			return false;
		}

		public virtual LeaderboardEntryList GetLeaderboardEntryList()
		{
			return null;
		}

		public virtual LinkedAccountList GetLinkedAccountList()
		{
			return null;
		}

		public virtual LivestreamingApplicationStatus GetLivestreamingApplicationStatus()
		{
			return null;
		}

		public virtual LivestreamingStartResult GetLivestreamingStartResult()
		{
			return null;
		}

		public virtual LivestreamingStatus GetLivestreamingStatus()
		{
			return null;
		}

		public virtual LivestreamingVideoStats GetLivestreamingVideoStats()
		{
			return null;
		}

		public virtual MatchmakingAdminSnapshot GetMatchmakingAdminSnapshot()
		{
			return null;
		}

		public virtual MatchmakingBrowseResult GetMatchmakingBrowseResult()
		{
			return null;
		}

		public virtual MatchmakingEnqueueResult GetMatchmakingEnqueueResult()
		{
			return null;
		}

		public virtual MatchmakingEnqueueResultAndRoom GetMatchmakingEnqueueResultAndRoom()
		{
			return null;
		}

		public virtual MatchmakingStats GetMatchmakingStats()
		{
			return null;
		}

		public virtual OrgScopedID GetOrgScopedID()
		{
			return null;
		}

		public virtual Party GetParty()
		{
			return null;
		}

		public virtual PartyID GetPartyID()
		{
			return null;
		}

		public virtual PidList GetPidList()
		{
			return null;
		}

		public virtual ProductList GetProductList()
		{
			return null;
		}

		public virtual Purchase GetPurchase()
		{
			return null;
		}

		public virtual PurchaseList GetPurchaseList()
		{
			return null;
		}

		public virtual Room GetRoom()
		{
			return null;
		}

		public virtual RoomInviteNotification GetRoomInviteNotification()
		{
			return null;
		}

		public virtual RoomInviteNotificationList GetRoomInviteNotificationList()
		{
			return null;
		}

		public virtual RoomList GetRoomList()
		{
			return null;
		}

		public virtual SdkAccountList GetSdkAccountList()
		{
			return null;
		}

		public virtual ShareMediaResult GetShareMediaResult()
		{
			return null;
		}

		public virtual string GetString()
		{
			return null;
		}

		public virtual SystemPermission GetSystemPermission()
		{
			return null;
		}

		public virtual SystemVoipState GetSystemVoipState()
		{
			return null;
		}

		public virtual User GetUser()
		{
			return null;
		}

		public virtual UserAndRoomList GetUserAndRoomList()
		{
			return null;
		}

		public virtual UserList GetUserList()
		{
			return null;
		}

		public virtual UserProof GetUserProof()
		{
			return null;
		}

		public virtual UserReportID GetUserReportID()
		{
			return null;
		}

		internal static Message ParseMessageHandle(IntPtr messageHandle)
		{
			if (messageHandle.ToInt64() == 0)
			{
				return null;
			}
			Message message = null;
			MessageType messageType = CAPI.ovr_Message_GetType(messageHandle);
			switch (messageType)
			{
			case MessageType.Achievements_GetAllDefinitions:
			case MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			case MessageType.Achievements_GetDefinitionsByName:
				message = new MessageWithAchievementDefinitions(messageHandle);
				break;
			case MessageType.Achievements_GetProgressByName:
			case MessageType.Achievements_GetNextAchievementProgressArrayPage:
			case MessageType.Achievements_GetAllProgress:
				message = new MessageWithAchievementProgressList(messageHandle);
				break;
			case MessageType.Achievements_AddCount:
			case MessageType.Achievements_AddFields:
			case MessageType.Achievements_Unlock:
				message = new MessageWithAchievementUpdate(messageHandle);
				break;
			case MessageType.Application_GetVersion:
				message = new MessageWithApplicationVersion(messageHandle);
				break;
			case MessageType.AssetFile_Status:
			case MessageType.LanguagePack_GetCurrent:
			case MessageType.AssetFile_StatusByName:
			case MessageType.AssetFile_StatusById:
				message = new MessageWithAssetDetails(messageHandle);
				break;
			case MessageType.AssetFile_GetList:
				message = new MessageWithAssetDetailsList(messageHandle);
				break;
			case MessageType.AssetFile_DeleteByName:
			case MessageType.AssetFile_DeleteById:
			case MessageType.AssetFile_Delete:
				message = new MessageWithAssetFileDeleteResult(messageHandle);
				break;
			case MessageType.AssetFile_DownloadCancel:
			case MessageType.AssetFile_DownloadCancelByName:
			case MessageType.AssetFile_DownloadCancelById:
				message = new MessageWithAssetFileDownloadCancelResult(messageHandle);
				break;
			case MessageType.AssetFile_Download:
			case MessageType.AssetFile_DownloadById:
			case MessageType.LanguagePack_SetCurrent:
			case MessageType.AssetFile_DownloadByName:
				message = new MessageWithAssetFileDownloadResult(messageHandle);
				break;
			case MessageType.Notification_AssetFile_DownloadUpdate:
				message = new MessageWithAssetFileDownloadUpdate(messageHandle);
				break;
			case MessageType.Notification_Cal_FinalizeApplication:
				message = new MessageWithCalApplicationFinalized(messageHandle);
				break;
			case MessageType.Notification_Cal_ProposeApplication:
				message = new MessageWithCalApplicationProposed(messageHandle);
				break;
			case MessageType.CloudStorage_LoadConflictMetadata:
				message = new MessageWithCloudStorageConflictMetadata(messageHandle);
				break;
			case MessageType.CloudStorage_LoadHandle:
			case MessageType.CloudStorage_Load:
				message = new MessageWithCloudStorageData(messageHandle);
				break;
			case MessageType.CloudStorage_LoadMetadata:
				message = new MessageWithCloudStorageMetadataUnderLocal(messageHandle);
				break;
			case MessageType.CloudStorage_GetNextCloudStorageMetadataArrayPage:
			case MessageType.CloudStorage_LoadBucketMetadata:
				message = new MessageWithCloudStorageMetadataList(messageHandle);
				break;
			case MessageType.CloudStorage_Delete:
			case MessageType.CloudStorage_ResolveKeepLocal:
			case MessageType.CloudStorage_Save:
			case MessageType.CloudStorage_ResolveKeepRemote:
				message = new MessageWithCloudStorageUpdateResponse(messageHandle);
				break;
			case MessageType.User_LaunchProfile:
			case MessageType.Matchmaking_Cancel2:
			case MessageType.Entitlement_GetIsViewerEntitled:
			case MessageType.Matchmaking_ReportResultInsecure:
			case MessageType.IAP_ConsumePurchase:
			case MessageType.Matchmaking_Cancel:
			case MessageType.Room_LaunchInvitableUserFlow:
			case MessageType.Room_UpdateOwner:
			case MessageType.Matchmaking_StartMatch:
			case MessageType.ApplicationLifecycle_RegisterSessionKey:
			case MessageType.Notification_MarkAsRead:
				message = new Message(messageHandle);
				break;
			case MessageType.User_LaunchFriendRequestFlow:
				message = new MessageWithLaunchFriendRequestFlowResult(messageHandle);
				break;
			case MessageType.Leaderboard_GetEntriesAfterRank:
			case MessageType.Leaderboard_GetPreviousEntries:
			case MessageType.Leaderboard_GetNextEntries:
			case MessageType.Leaderboard_GetEntries:
				message = new MessageWithLeaderboardEntryList(messageHandle);
				break;
			case MessageType.Leaderboard_WriteEntry:
				message = new MessageWithLeaderboardDidUpdate(messageHandle);
				break;
			case MessageType.Notification_Livestreaming_StatusChange:
			case MessageType.Livestreaming_ResumeStream:
			case MessageType.Livestreaming_PauseStream:
			case MessageType.Livestreaming_GetStatus:
				message = new MessageWithLivestreamingStatus(messageHandle);
				break;
			case MessageType.Matchmaking_GetAdminSnapshot:
				message = new MessageWithMatchmakingAdminSnapshot(messageHandle);
				break;
			case MessageType.Matchmaking_Browse:
			case MessageType.Matchmaking_Browse2:
				message = new MessageWithMatchmakingBrowseResult(messageHandle);
				break;
			case MessageType.Matchmaking_Enqueue2:
			case MessageType.Matchmaking_Enqueue:
			case MessageType.Matchmaking_EnqueueRoom2:
			case MessageType.Matchmaking_EnqueueRoom:
				message = new MessageWithMatchmakingEnqueueResult(messageHandle);
				break;
			case MessageType.Matchmaking_CreateAndEnqueueRoom2:
			case MessageType.Matchmaking_CreateAndEnqueueRoom:
				message = new MessageWithMatchmakingEnqueueResultAndRoom(messageHandle);
				break;
			case MessageType.Matchmaking_GetStats:
				message = new MessageWithMatchmakingStatsUnderMatchmakingStats(messageHandle);
				break;
			case MessageType.User_GetOrgScopedID:
				message = new MessageWithOrgScopedID(messageHandle);
				break;
			case MessageType.Party_GetCurrent:
				message = new MessageWithPartyUnderCurrentParty(messageHandle);
				break;
			case MessageType.ApplicationLifecycle_GetRegisteredPIDs:
				message = new MessageWithPidList(messageHandle);
				break;
			case MessageType.IAP_GetNextProductArrayPage:
			case MessageType.IAP_GetProductsBySKU:
				message = new MessageWithProductList(messageHandle);
				break;
			case MessageType.IAP_LaunchCheckoutFlow:
				message = new MessageWithPurchase(messageHandle);
				break;
			case MessageType.IAP_GetViewerPurchases:
			case MessageType.IAP_GetNextPurchaseArrayPage:
				message = new MessageWithPurchaseList(messageHandle);
				break;
			case MessageType.Room_Get:
				message = new MessageWithRoom(messageHandle);
				break;
			case MessageType.Room_GetCurrent:
			case MessageType.Room_GetCurrentForUser:
				message = new MessageWithRoomUnderCurrentRoom(messageHandle);
				break;
			case MessageType.Room_UpdateDataStore:
			case MessageType.Matchmaking_CreateRoom:
			case MessageType.Room_UpdatePrivateRoomJoinPolicy:
			case MessageType.Room_Join:
			case MessageType.Room_SetDescription:
			case MessageType.Room_UpdateMembershipLockStatus:
			case MessageType.Room_InviteUser:
			case MessageType.Matchmaking_CreateRoom2:
			case MessageType.Room_KickUser:
			case MessageType.Matchmaking_JoinRoom:
			case MessageType.Room_Join2:
			case MessageType.Room_CreateAndJoinPrivate2:
			case MessageType.Notification_Room_RoomUpdate:
			case MessageType.Room_Leave:
			case MessageType.Room_CreateAndJoinPrivate:
				message = new MessageWithRoomUnderViewerRoom(messageHandle);
				break;
			case MessageType.Room_GetModeratedRooms:
			case MessageType.Room_GetNextRoomArrayPage:
				message = new MessageWithRoomList(messageHandle);
				break;
			case MessageType.Notification_Room_InviteReceived:
				message = new MessageWithRoomInviteNotification(messageHandle);
				break;
			case MessageType.Notification_GetNextRoomInviteNotificationArrayPage:
			case MessageType.Notification_GetRoomInvites:
				message = new MessageWithRoomInviteNotificationList(messageHandle);
				break;
			case MessageType.User_GetSdkAccounts:
				message = new MessageWithSdkAccountList(messageHandle);
				break;
			case MessageType.Media_ShareToFacebook:
				message = new MessageWithShareMediaResult(messageHandle);
				break;
			case MessageType.Notification_ApplicationLifecycle_LaunchIntentChanged:
			case MessageType.User_GetAccessToken:
			case MessageType.ApplicationLifecycle_GetSessionKey:
			case MessageType.Application_LaunchOtherApp:
			case MessageType.Notification_Room_InviteAccepted:
				message = new MessageWithString(messageHandle);
				break;
			case MessageType.Voip_SetSystemVoipSuppressed:
				message = new MessageWithSystemVoipState(messageHandle);
				break;
			case MessageType.User_GetLoggedInUser:
			case MessageType.User_Get:
				message = new MessageWithUser(messageHandle);
				break;
			case MessageType.User_GetLoggedInUserRecentlyMetUsersAndRooms:
			case MessageType.User_GetLoggedInUserFriendsAndRooms:
			case MessageType.User_GetNextUserAndRoomArrayPage:
				message = new MessageWithUserAndRoomList(messageHandle);
				break;
			case MessageType.Room_GetInvitableUsers:
			case MessageType.User_GetNextUserArrayPage:
			case MessageType.Room_GetInvitableUsers2:
			case MessageType.User_GetLoggedInUserFriends:
				message = new MessageWithUserList(messageHandle);
				break;
			case MessageType.User_GetUserProof:
				message = new MessageWithUserProof(messageHandle);
				break;
			case MessageType.Notification_Networking_PeerConnectRequest:
			case MessageType.Notification_Networking_ConnectionStateChange:
				message = new MessageWithNetworkingPeer(messageHandle);
				break;
			case MessageType.Notification_Networking_PingResult:
				message = new MessageWithPingResult(messageHandle);
				break;
			case MessageType.Notification_Matchmaking_MatchFound:
				message = new MessageWithMatchmakingNotification(messageHandle);
				break;
			case MessageType.Notification_Voip_StateChange:
			case MessageType.Notification_Voip_ConnectRequest:
				message = new MessageWithNetworkingPeer(messageHandle);
				break;
			case MessageType.Notification_Voip_SystemVoipState:
				message = new MessageWithSystemVoipState(messageHandle);
				break;
			case MessageType.Notification_HTTP_Transfer:
				message = new MessageWithHttpTransferUpdate(messageHandle);
				break;
			case MessageType.Platform_InitializeAndroidAsynchronous:
			case MessageType.Platform_InitializeWithAccessToken:
			case MessageType.Platform_InitializeStandaloneOculus:
			case MessageType.Platform_InitializeWindowsAsynchronous:
				message = new MessageWithPlatformInitialize(messageHandle);
				break;
			default:
				message = PlatformInternal.ParseMessageHandle(messageHandle, messageType);
				if (message == null)
				{
					UnityEngine.Debug.LogError($"Unrecognized message type {messageType}\n");
				}
				break;
			}
			return message;
		}

		public static Message PopMessage()
		{
			if (!Core.IsInitialized())
			{
				return null;
			}
			IntPtr intPtr = CAPI.ovr_PopMessage();
			Message result = ParseMessageHandle(intPtr);
			CAPI.ovr_FreeMessage(intPtr);
			return result;
		}
	}
	public class MessageWithAbuseReportRecording : Message<AbuseReportRecording>
	{
		public MessageWithAbuseReportRecording(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AbuseReportRecording GetAbuseReportRecording()
		{
			return base.Data;
		}

		protected override AbuseReportRecording GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAbuseReportRecording(obj);
			return new AbuseReportRecording(o);
		}
	}
	public class MessageWithAchievementDefinitions : Message<AchievementDefinitionList>
	{
		public MessageWithAchievementDefinitions(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AchievementDefinitionList GetAchievementDefinitions()
		{
			return base.Data;
		}

		protected override AchievementDefinitionList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetAchievementDefinitionArray(obj);
			return new AchievementDefinitionList(a);
		}
	}
	public class MessageWithAchievementProgressList : Message<AchievementProgressList>
	{
		public MessageWithAchievementProgressList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AchievementProgressList GetAchievementProgressList()
		{
			return base.Data;
		}

		protected override AchievementProgressList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetAchievementProgressArray(obj);
			return new AchievementProgressList(a);
		}
	}
	public class MessageWithAchievementUpdate : Message<AchievementUpdate>
	{
		public MessageWithAchievementUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AchievementUpdate GetAchievementUpdate()
		{
			return base.Data;
		}

		protected override AchievementUpdate GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAchievementUpdate(obj);
			return new AchievementUpdate(o);
		}
	}
	public class MessageWithApplicationVersion : Message<ApplicationVersion>
	{
		public MessageWithApplicationVersion(IntPtr c_message)
			: base(c_message)
		{
		}

		public override ApplicationVersion GetApplicationVersion()
		{
			return base.Data;
		}

		protected override ApplicationVersion GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetApplicationVersion(obj);
			return new ApplicationVersion(o);
		}
	}
	public class MessageWithAssetDetails : Message<AssetDetails>
	{
		public MessageWithAssetDetails(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetDetails GetAssetDetails()
		{
			return base.Data;
		}

		protected override AssetDetails GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAssetDetails(obj);
			return new AssetDetails(o);
		}
	}
	public class MessageWithAssetDetailsList : Message<AssetDetailsList>
	{
		public MessageWithAssetDetailsList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetDetailsList GetAssetDetailsList()
		{
			return base.Data;
		}

		protected override AssetDetailsList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetAssetDetailsArray(obj);
			return new AssetDetailsList(a);
		}
	}
	public class MessageWithAssetFileDeleteResult : Message<AssetFileDeleteResult>
	{
		public MessageWithAssetFileDeleteResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetFileDeleteResult GetAssetFileDeleteResult()
		{
			return base.Data;
		}

		protected override AssetFileDeleteResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAssetFileDeleteResult(obj);
			return new AssetFileDeleteResult(o);
		}
	}
	public class MessageWithAssetFileDownloadCancelResult : Message<AssetFileDownloadCancelResult>
	{
		public MessageWithAssetFileDownloadCancelResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetFileDownloadCancelResult GetAssetFileDownloadCancelResult()
		{
			return base.Data;
		}

		protected override AssetFileDownloadCancelResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAssetFileDownloadCancelResult(obj);
			return new AssetFileDownloadCancelResult(o);
		}
	}
	public class MessageWithAssetFileDownloadResult : Message<AssetFileDownloadResult>
	{
		public MessageWithAssetFileDownloadResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetFileDownloadResult GetAssetFileDownloadResult()
		{
			return base.Data;
		}

		protected override AssetFileDownloadResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAssetFileDownloadResult(obj);
			return new AssetFileDownloadResult(o);
		}
	}
	public class MessageWithAssetFileDownloadUpdate : Message<AssetFileDownloadUpdate>
	{
		public MessageWithAssetFileDownloadUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetFileDownloadUpdate GetAssetFileDownloadUpdate()
		{
			return base.Data;
		}

		protected override AssetFileDownloadUpdate GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAssetFileDownloadUpdate(obj);
			return new AssetFileDownloadUpdate(o);
		}
	}
	public class MessageWithCalApplicationFinalized : Message<CalApplicationFinalized>
	{
		public MessageWithCalApplicationFinalized(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CalApplicationFinalized GetCalApplicationFinalized()
		{
			return base.Data;
		}

		protected override CalApplicationFinalized GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCalApplicationFinalized(obj);
			return new CalApplicationFinalized(o);
		}
	}
	public class MessageWithCalApplicationProposed : Message<CalApplicationProposed>
	{
		public MessageWithCalApplicationProposed(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CalApplicationProposed GetCalApplicationProposed()
		{
			return base.Data;
		}

		protected override CalApplicationProposed GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCalApplicationProposed(obj);
			return new CalApplicationProposed(o);
		}
	}
	public class MessageWithCalApplicationSuggestionList : Message<CalApplicationSuggestionList>
	{
		public MessageWithCalApplicationSuggestionList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CalApplicationSuggestionList GetCalApplicationSuggestionList()
		{
			return base.Data;
		}

		protected override CalApplicationSuggestionList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetCalApplicationSuggestionArray(obj);
			return new CalApplicationSuggestionList(a);
		}
	}
	public class MessageWithCloudStorageConflictMetadata : Message<CloudStorageConflictMetadata>
	{
		public MessageWithCloudStorageConflictMetadata(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageConflictMetadata GetCloudStorageConflictMetadata()
		{
			return base.Data;
		}

		protected override CloudStorageConflictMetadata GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCloudStorageConflictMetadata(obj);
			return new CloudStorageConflictMetadata(o);
		}
	}
	public class MessageWithCloudStorageData : Message<CloudStorageData>
	{
		public MessageWithCloudStorageData(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageData GetCloudStorageData()
		{
			return base.Data;
		}

		protected override CloudStorageData GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCloudStorageData(obj);
			return new CloudStorageData(o);
		}
	}
	public class MessageWithCloudStorageMetadataUnderLocal : Message<CloudStorageMetadata>
	{
		public MessageWithCloudStorageMetadataUnderLocal(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageMetadata GetCloudStorageMetadata()
		{
			return base.Data;
		}

		protected override CloudStorageMetadata GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCloudStorageMetadata(obj);
			return new CloudStorageMetadata(o);
		}
	}
	public class MessageWithCloudStorageMetadataList : Message<CloudStorageMetadataList>
	{
		public MessageWithCloudStorageMetadataList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageMetadataList GetCloudStorageMetadataList()
		{
			return base.Data;
		}

		protected override CloudStorageMetadataList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetCloudStorageMetadataArray(obj);
			return new CloudStorageMetadataList(a);
		}
	}
	public class MessageWithCloudStorageUpdateResponse : Message<CloudStorageUpdateResponse>
	{
		public MessageWithCloudStorageUpdateResponse(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageUpdateResponse GetCloudStorageUpdateResponse()
		{
			return base.Data;
		}

		protected override CloudStorageUpdateResponse GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCloudStorageUpdateResponse(obj);
			return new CloudStorageUpdateResponse(o);
		}
	}
	public class MessageWithInstalledApplicationList : Message<InstalledApplicationList>
	{
		public MessageWithInstalledApplicationList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override InstalledApplicationList GetInstalledApplicationList()
		{
			return base.Data;
		}

		protected override InstalledApplicationList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetInstalledApplicationArray(obj);
			return new InstalledApplicationList(a);
		}
	}
	public class MessageWithLaunchBlockFlowResult : Message<LaunchBlockFlowResult>
	{
		public MessageWithLaunchBlockFlowResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LaunchBlockFlowResult GetLaunchBlockFlowResult()
		{
			return base.Data;
		}

		protected override LaunchBlockFlowResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLaunchBlockFlowResult(obj);
			return new LaunchBlockFlowResult(o);
		}
	}
	public class MessageWithLaunchFriendRequestFlowResult : Message<LaunchFriendRequestFlowResult>
	{
		public MessageWithLaunchFriendRequestFlowResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LaunchFriendRequestFlowResult GetLaunchFriendRequestFlowResult()
		{
			return base.Data;
		}

		protected override LaunchFriendRequestFlowResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLaunchFriendRequestFlowResult(obj);
			return new LaunchFriendRequestFlowResult(o);
		}
	}
	public class MessageWithLaunchReportFlowResult : Message<LaunchReportFlowResult>
	{
		public MessageWithLaunchReportFlowResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LaunchReportFlowResult GetLaunchReportFlowResult()
		{
			return base.Data;
		}

		protected override LaunchReportFlowResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLaunchReportFlowResult(obj);
			return new LaunchReportFlowResult(o);
		}
	}
	public class MessageWithLaunchUnblockFlowResult : Message<LaunchUnblockFlowResult>
	{
		public MessageWithLaunchUnblockFlowResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LaunchUnblockFlowResult GetLaunchUnblockFlowResult()
		{
			return base.Data;
		}

		protected override LaunchUnblockFlowResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLaunchUnblockFlowResult(obj);
			return new LaunchUnblockFlowResult(o);
		}
	}
	public class MessageWithLeaderboardEntryList : Message<LeaderboardEntryList>
	{
		public MessageWithLeaderboardEntryList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LeaderboardEntryList GetLeaderboardEntryList()
		{
			return base.Data;
		}

		protected override LeaderboardEntryList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetLeaderboardEntryArray(obj);
			return new LeaderboardEntryList(a);
		}
	}
	public class MessageWithLinkedAccountList : Message<LinkedAccountList>
	{
		public MessageWithLinkedAccountList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LinkedAccountList GetLinkedAccountList()
		{
			return base.Data;
		}

		protected override LinkedAccountList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetLinkedAccountArray(obj);
			return new LinkedAccountList(a);
		}
	}
	public class MessageWithLivestreamingApplicationStatus : Message<LivestreamingApplicationStatus>
	{
		public MessageWithLivestreamingApplicationStatus(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingApplicationStatus GetLivestreamingApplicationStatus()
		{
			return base.Data;
		}

		protected override LivestreamingApplicationStatus GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLivestreamingApplicationStatus(obj);
			return new LivestreamingApplicationStatus(o);
		}
	}
	public class MessageWithLivestreamingStartResult : Message<LivestreamingStartResult>
	{
		public MessageWithLivestreamingStartResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingStartResult GetLivestreamingStartResult()
		{
			return base.Data;
		}

		protected override LivestreamingStartResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLivestreamingStartResult(obj);
			return new LivestreamingStartResult(o);
		}
	}
	public class MessageWithLivestreamingStatus : Message<LivestreamingStatus>
	{
		public MessageWithLivestreamingStatus(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingStatus GetLivestreamingStatus()
		{
			return base.Data;
		}

		protected override LivestreamingStatus GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLivestreamingStatus(obj);
			return new LivestreamingStatus(o);
		}
	}
	public class MessageWithLivestreamingVideoStats : Message<LivestreamingVideoStats>
	{
		public MessageWithLivestreamingVideoStats(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingVideoStats GetLivestreamingVideoStats()
		{
			return base.Data;
		}

		protected override LivestreamingVideoStats GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLivestreamingVideoStats(obj);
			return new LivestreamingVideoStats(o);
		}
	}
	public class MessageWithMatchmakingAdminSnapshot : Message<MatchmakingAdminSnapshot>
	{
		public MessageWithMatchmakingAdminSnapshot(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingAdminSnapshot GetMatchmakingAdminSnapshot()
		{
			return base.Data;
		}

		protected override MatchmakingAdminSnapshot GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingAdminSnapshot(obj);
			return new MatchmakingAdminSnapshot(o);
		}
	}
	public class MessageWithMatchmakingEnqueueResult : Message<MatchmakingEnqueueResult>
	{
		public MessageWithMatchmakingEnqueueResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingEnqueueResult GetMatchmakingEnqueueResult()
		{
			return base.Data;
		}

		protected override MatchmakingEnqueueResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingEnqueueResult(obj);
			return new MatchmakingEnqueueResult(o);
		}
	}
	public class MessageWithMatchmakingEnqueueResultAndRoom : Message<MatchmakingEnqueueResultAndRoom>
	{
		public MessageWithMatchmakingEnqueueResultAndRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingEnqueueResultAndRoom GetMatchmakingEnqueueResultAndRoom()
		{
			return base.Data;
		}

		protected override MatchmakingEnqueueResultAndRoom GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingEnqueueResultAndRoom(obj);
			return new MatchmakingEnqueueResultAndRoom(o);
		}
	}
	public class MessageWithMatchmakingStatsUnderMatchmakingStats : Message<MatchmakingStats>
	{
		public MessageWithMatchmakingStatsUnderMatchmakingStats(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingStats GetMatchmakingStats()
		{
			return base.Data;
		}

		protected override MatchmakingStats GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingStats(obj);
			return new MatchmakingStats(o);
		}
	}
	public class MessageWithOrgScopedID : Message<OrgScopedID>
	{
		public MessageWithOrgScopedID(IntPtr c_message)
			: base(c_message)
		{
		}

		public override OrgScopedID GetOrgScopedID()
		{
			return base.Data;
		}

		protected override OrgScopedID GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetOrgScopedID(obj);
			return new OrgScopedID(o);
		}
	}
	public class MessageWithParty : Message<Party>
	{
		public MessageWithParty(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Party GetParty()
		{
			return base.Data;
		}

		protected override Party GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetParty(obj);
			return new Party(o);
		}
	}
	public class MessageWithPartyUnderCurrentParty : Message<Party>
	{
		public MessageWithPartyUnderCurrentParty(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Party GetParty()
		{
			return base.Data;
		}

		protected override Party GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetParty(obj);
			return new Party(o);
		}
	}
	public class MessageWithPartyID : Message<PartyID>
	{
		public MessageWithPartyID(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PartyID GetPartyID()
		{
			return base.Data;
		}

		protected override PartyID GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetPartyID(obj);
			return new PartyID(o);
		}
	}
	public class MessageWithPidList : Message<PidList>
	{
		public MessageWithPidList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PidList GetPidList()
		{
			return base.Data;
		}

		protected override PidList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetPidArray(obj);
			return new PidList(a);
		}
	}
	public class MessageWithProductList : Message<ProductList>
	{
		public MessageWithProductList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override ProductList GetProductList()
		{
			return base.Data;
		}

		protected override ProductList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetProductArray(obj);
			return new ProductList(a);
		}
	}
	public class MessageWithPurchase : Message<Purchase>
	{
		public MessageWithPurchase(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Purchase GetPurchase()
		{
			return base.Data;
		}

		protected override Purchase GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetPurchase(obj);
			return new Purchase(o);
		}
	}
	public class MessageWithPurchaseList : Message<PurchaseList>
	{
		public MessageWithPurchaseList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PurchaseList GetPurchaseList()
		{
			return base.Data;
		}

		protected override PurchaseList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetPurchaseArray(obj);
			return new PurchaseList(a);
		}
	}
	public class MessageWithRoom : Message<Room>
	{
		public MessageWithRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Room GetRoom()
		{
			return base.Data;
		}

		protected override Room GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoom(obj);
			return new Room(o);
		}
	}
	public class MessageWithRoomUnderCurrentRoom : Message<Room>
	{
		public MessageWithRoomUnderCurrentRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Room GetRoom()
		{
			return base.Data;
		}

		protected override Room GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoom(obj);
			return new Room(o);
		}
	}
	public class MessageWithRoomUnderViewerRoom : Message<Room>
	{
		public MessageWithRoomUnderViewerRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Room GetRoom()
		{
			return base.Data;
		}

		protected override Room GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoom(obj);
			return new Room(o);
		}
	}
	public class MessageWithRoomList : Message<RoomList>
	{
		public MessageWithRoomList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override RoomList GetRoomList()
		{
			return base.Data;
		}

		protected override RoomList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetRoomArray(obj);
			return new RoomList(a);
		}
	}
	public class MessageWithRoomInviteNotification : Message<RoomInviteNotification>
	{
		public MessageWithRoomInviteNotification(IntPtr c_message)
			: base(c_message)
		{
		}

		public override RoomInviteNotification GetRoomInviteNotification()
		{
			return base.Data;
		}

		protected override RoomInviteNotification GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoomInviteNotification(obj);
			return new RoomInviteNotification(o);
		}
	}
	public class MessageWithRoomInviteNotificationList : Message<RoomInviteNotificationList>
	{
		public MessageWithRoomInviteNotificationList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override RoomInviteNotificationList GetRoomInviteNotificationList()
		{
			return base.Data;
		}

		protected override RoomInviteNotificationList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetRoomInviteNotificationArray(obj);
			return new RoomInviteNotificationList(a);
		}
	}
	public class MessageWithSdkAccountList : Message<SdkAccountList>
	{
		public MessageWithSdkAccountList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override SdkAccountList GetSdkAccountList()
		{
			return base.Data;
		}

		protected override SdkAccountList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetSdkAccountArray(obj);
			return new SdkAccountList(a);
		}
	}
	public class MessageWithShareMediaResult : Message<ShareMediaResult>
	{
		public MessageWithShareMediaResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override ShareMediaResult GetShareMediaResult()
		{
			return base.Data;
		}

		protected override ShareMediaResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetShareMediaResult(obj);
			return new ShareMediaResult(o);
		}
	}
	public class MessageWithString : Message<string>
	{
		public MessageWithString(IntPtr c_message)
			: base(c_message)
		{
		}

		public override string GetString()
		{
			return base.Data;
		}

		protected override string GetDataFromMessage(IntPtr c_message)
		{
			return CAPI.ovr_Message_GetString(c_message);
		}
	}
	public class MessageWithSystemPermission : Message<SystemPermission>
	{
		public MessageWithSystemPermission(IntPtr c_message)
			: base(c_message)
		{
		}

		public override SystemPermission GetSystemPermission()
		{
			return base.Data;
		}

		protected override SystemPermission GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetSystemPermission(obj);
			return new SystemPermission(o);
		}
	}
	public class MessageWithSystemVoipState : Message<SystemVoipState>
	{
		public MessageWithSystemVoipState(IntPtr c_message)
			: base(c_message)
		{
		}

		public override SystemVoipState GetSystemVoipState()
		{
			return base.Data;
		}

		protected override SystemVoipState GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetSystemVoipState(obj);
			return new SystemVoipState(o);
		}
	}
	public class MessageWithUser : Message<User>
	{
		public MessageWithUser(IntPtr c_message)
			: base(c_message)
		{
		}

		public override User GetUser()
		{
			return base.Data;
		}

		protected override User GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetUser(obj);
			return new User(o);
		}
	}
	public class MessageWithUserAndRoomList : Message<UserAndRoomList>
	{
		public MessageWithUserAndRoomList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserAndRoomList GetUserAndRoomList()
		{
			return base.Data;
		}

		protected override UserAndRoomList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetUserAndRoomArray(obj);
			return new UserAndRoomList(a);
		}
	}
	public class MessageWithUserList : Message<UserList>
	{
		public MessageWithUserList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserList GetUserList()
		{
			return base.Data;
		}

		protected override UserList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetUserArray(obj);
			return new UserList(a);
		}
	}
	public class MessageWithUserProof : Message<UserProof>
	{
		public MessageWithUserProof(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserProof GetUserProof()
		{
			return base.Data;
		}

		protected override UserProof GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetUserProof(obj);
			return new UserProof(o);
		}
	}
	public class MessageWithUserReportID : Message<UserReportID>
	{
		public MessageWithUserReportID(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserReportID GetUserReportID()
		{
			return base.Data;
		}

		protected override UserReportID GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetUserReportID(obj);
			return new UserReportID(o);
		}
	}
	public class MessageWithNetworkingPeer : Message<NetworkingPeer>
	{
		public MessageWithNetworkingPeer(IntPtr c_message)
			: base(c_message)
		{
		}

		public override NetworkingPeer GetNetworkingPeer()
		{
			return base.Data;
		}

		protected override NetworkingPeer GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNetworkingPeer(c_message);
			return new NetworkingPeer(CAPI.ovr_NetworkingPeer_GetID(obj), CAPI.ovr_NetworkingPeer_GetState(obj));
		}
	}
	public class MessageWithPingResult : Message<PingResult>
	{
		public MessageWithPingResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PingResult GetPingResult()
		{
			return base.Data;
		}

		protected override PingResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetPingResult(c_message);
			bool flag = CAPI.ovr_PingResult_IsTimeout(obj);
			return new PingResult(CAPI.ovr_PingResult_GetID(obj), (!flag) ? new ulong?(CAPI.ovr_PingResult_GetPingTimeUsec(obj)) : null);
		}
	}
	public class MessageWithLeaderboardDidUpdate : Message<bool>
	{
		public MessageWithLeaderboardDidUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override bool GetLeaderboardDidUpdate()
		{
			return base.Data;
		}

		protected override bool GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr obj2 = CAPI.ovr_Message_GetLeaderboardUpdateStatus(obj);
			return CAPI.ovr_LeaderboardUpdateStatus_GetDidUpdate(obj2);
		}
	}
	public class MessageWithMatchmakingNotification : Message<Room>
	{
		public MessageWithMatchmakingNotification(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Room GetRoom()
		{
			return base.Data;
		}

		protected override Room GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoom(obj);
			return new Room(o);
		}
	}
	public class MessageWithMatchmakingBrowseResult : Message<MatchmakingBrowseResult>
	{
		public MessageWithMatchmakingBrowseResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingEnqueueResult GetMatchmakingEnqueueResult()
		{
			return base.Data.EnqueueResult;
		}

		public override RoomList GetRoomList()
		{
			return base.Data.Rooms;
		}

		protected override MatchmakingBrowseResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingBrowseResult(obj);
			return new MatchmakingBrowseResult(o);
		}
	}
	public class MessageWithHttpTransferUpdate : Message<HttpTransferUpdate>
	{
		public MessageWithHttpTransferUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override HttpTransferUpdate GetHttpTransferUpdate()
		{
			return base.Data;
		}

		protected override HttpTransferUpdate GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetHttpTransferUpdate(obj);
			return new HttpTransferUpdate(o);
		}
	}
	public class MessageWithPlatformInitialize : Message<PlatformInitialize>
	{
		public MessageWithPlatformInitialize(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PlatformInitialize GetPlatformInitialize()
		{
			return base.Data;
		}

		protected override PlatformInitialize GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetPlatformInitialize(obj);
			return new PlatformInitialize(o);
		}
	}
}
namespace Oculus.Platform.Models
{
	public class AbuseReportRecording
	{
		public readonly string RecordingUuid;

		public AbuseReportRecording(IntPtr o)
		{
			RecordingUuid = CAPI.ovr_AbuseReportRecording_GetRecordingUuid(o);
		}
	}
	public class AchievementDefinition
	{
		public readonly AchievementType Type;

		public readonly string Name;

		public readonly uint BitfieldLength;

		public readonly ulong Target;

		public AchievementDefinition(IntPtr o)
		{
			Type = CAPI.ovr_AchievementDefinition_GetType(o);
			Name = CAPI.ovr_AchievementDefinition_GetName(o);
			BitfieldLength = CAPI.ovr_AchievementDefinition_GetBitfieldLength(o);
			Target = CAPI.ovr_AchievementDefinition_GetTarget(o);
		}
	}
	public class AchievementDefinitionList : DeserializableList<AchievementDefinition>
	{
		public AchievementDefinitionList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_AchievementDefinitionArray_GetSize(a);
			_Data = new List<AchievementDefinition>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new AchievementDefinition(CAPI.ovr_AchievementDefinitionArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_AchievementDefinitionArray_GetNextUrl(a);
		}
	}
	public class AchievementProgress
	{
		public readonly string Bitfield;

		public readonly ulong Count;

		public readonly bool IsUnlocked;

		public readonly string Name;

		public readonly DateTime UnlockTime;

		public AchievementProgress(IntPtr o)
		{
			Bitfield = CAPI.ovr_AchievementProgress_GetBitfield(o);
			Count = CAPI.ovr_AchievementProgress_GetCount(o);
			IsUnlocked = CAPI.ovr_AchievementProgress_GetIsUnlocked(o);
			Name = CAPI.ovr_AchievementProgress_GetName(o);
			UnlockTime = CAPI.ovr_AchievementProgress_GetUnlockTime(o);
		}
	}
	public class AchievementProgressList : DeserializableList<AchievementProgress>
	{
		public AchievementProgressList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_AchievementProgressArray_GetSize(a);
			_Data = new List<AchievementProgress>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new AchievementProgress(CAPI.ovr_AchievementProgressArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_AchievementProgressArray_GetNextUrl(a);
		}
	}
	public class AchievementUpdate
	{
		public readonly bool JustUnlocked;

		public readonly string Name;

		public AchievementUpdate(IntPtr o)
		{
			JustUnlocked = CAPI.ovr_AchievementUpdate_GetJustUnlocked(o);
			Name = CAPI.ovr_AchievementUpdate_GetName(o);
		}
	}
	public class ApplicationVersion
	{
		public readonly int CurrentCode;

		public readonly string CurrentName;

		public readonly int LatestCode;

		public readonly string LatestName;

		public ApplicationVersion(IntPtr o)
		{
			CurrentCode = CAPI.ovr_ApplicationVersion_GetCurrentCode(o);
			CurrentName = CAPI.ovr_ApplicationVersion_GetCurrentName(o);
			LatestCode = CAPI.ovr_ApplicationVersion_GetLatestCode(o);
			LatestName = CAPI.ovr_ApplicationVersion_GetLatestName(o);
		}
	}
	public class AssetDetails
	{
		public readonly ulong AssetId;

		public readonly string AssetType;

		public readonly string DownloadStatus;

		public readonly string Filepath;

		public readonly string IapStatus;

		public readonly LanguagePackInfo LanguageOptional;

		[Obsolete("Deprecated in favor of LanguageOptional")]
		public readonly LanguagePackInfo Language;

		public AssetDetails(IntPtr o)
		{
			AssetId = CAPI.ovr_AssetDetails_GetAssetId(o);
			AssetType = CAPI.ovr_AssetDetails_GetAssetType(o);
			DownloadStatus = CAPI.ovr_AssetDetails_GetDownloadStatus(o);
			Filepath = CAPI.ovr_AssetDetails_GetFilepath(o);
			IapStatus = CAPI.ovr_AssetDetails_GetIapStatus(o);
			IntPtr intPtr = CAPI.ovr_AssetDetails_GetLanguage(o);
			Language = new LanguagePackInfo(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				LanguageOptional = null;
			}
			else
			{
				LanguageOptional = Language;
			}
		}
	}
	public class AssetDetailsList : DeserializableList<AssetDetails>
	{
		public AssetDetailsList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_AssetDetailsArray_GetSize(a);
			_Data = new List<AssetDetails>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new AssetDetails(CAPI.ovr_AssetDetailsArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class AssetFileDeleteResult
	{
		public readonly ulong AssetFileId;

		public readonly ulong AssetId;

		public readonly string Filepath;

		public readonly bool Success;

		public AssetFileDeleteResult(IntPtr o)
		{
			AssetFileId = CAPI.ovr_AssetFileDeleteResult_GetAssetFileId(o);
			AssetId = CAPI.ovr_AssetFileDeleteResult_GetAssetId(o);
			Filepath = CAPI.ovr_AssetFileDeleteResult_GetFilepath(o);
			Success = CAPI.ovr_AssetFileDeleteResult_GetSuccess(o);
		}
	}
	public class AssetFileDownloadCancelResult
	{
		public readonly ulong AssetFileId;

		public readonly ulong AssetId;

		public readonly string Filepath;

		public readonly bool Success;

		public AssetFileDownloadCancelResult(IntPtr o)
		{
			AssetFileId = CAPI.ovr_AssetFileDownloadCancelResult_GetAssetFileId(o);
			AssetId = CAPI.ovr_AssetFileDownloadCancelResult_GetAssetId(o);
			Filepath = CAPI.ovr_AssetFileDownloadCancelResult_GetFilepath(o);
			Success = CAPI.ovr_AssetFileDownloadCancelResult_GetSuccess(o);
		}
	}
	public class AssetFileDownloadResult
	{
		public readonly ulong AssetId;

		public readonly string Filepath;

		public AssetFileDownloadResult(IntPtr o)
		{
			AssetId = CAPI.ovr_AssetFileDownloadResult_GetAssetId(o);
			Filepath = CAPI.ovr_AssetFileDownloadResult_GetFilepath(o);
		}
	}
	public class AssetFileDownloadUpdate
	{
		public readonly ulong AssetFileId;

		public readonly ulong AssetId;

		public readonly uint BytesTotal;

		public readonly int BytesTransferred;

		public readonly bool Completed;

		public AssetFileDownloadUpdate(IntPtr o)
		{
			AssetFileId = CAPI.ovr_AssetFileDownloadUpdate_GetAssetFileId(o);
			AssetId = CAPI.ovr_AssetFileDownloadUpdate_GetAssetId(o);
			BytesTotal = CAPI.ovr_AssetFileDownloadUpdate_GetBytesTotal(o);
			BytesTransferred = CAPI.ovr_AssetFileDownloadUpdate_GetBytesTransferred(o);
			Completed = CAPI.ovr_AssetFileDownloadUpdate_GetCompleted(o);
		}
	}
	public class CalApplicationFinalized
	{
		public readonly int CountdownMS;

		public readonly ulong ID;

		public readonly string LaunchDetails;

		public CalApplicationFinalized(IntPtr o)
		{
			CountdownMS = CAPI.ovr_CalApplicationFinalized_GetCountdownMS(o);
			ID = CAPI.ovr_CalApplicationFinalized_GetID(o);
			LaunchDetails = CAPI.ovr_CalApplicationFinalized_GetLaunchDetails(o);
		}
	}
	public class CalApplicationProposed
	{
		public readonly ulong ID;

		public CalApplicationProposed(IntPtr o)
		{
			ID = CAPI.ovr_CalApplicationProposed_GetID(o);
		}
	}
	public class CalApplicationSuggestion
	{
		public readonly ulong ID;

		public readonly string SocialContext;

		public CalApplicationSuggestion(IntPtr o)
		{
			ID = CAPI.ovr_CalApplicationSuggestion_GetID(o);
			SocialContext = CAPI.ovr_CalApplicationSuggestion_GetSocialContext(o);
		}
	}
	public class CalApplicationSuggestionList : DeserializableList<CalApplicationSuggestion>
	{
		public CalApplicationSuggestionList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_CalApplicationSuggestionArray_GetSize(a);
			_Data = new List<CalApplicationSuggestion>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new CalApplicationSuggestion(CAPI.ovr_CalApplicationSuggestionArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class CloudStorageConflictMetadata
	{
		public readonly CloudStorageMetadata Local;

		public readonly CloudStorageMetadata Remote;

		public CloudStorageConflictMetadata(IntPtr o)
		{
			Local = new CloudStorageMetadata(CAPI.ovr_CloudStorageConflictMetadata_GetLocal(o));
			Remote = new CloudStorageMetadata(CAPI.ovr_CloudStorageConflictMetadata_GetRemote(o));
		}
	}
	public class CloudStorageData
	{
		public readonly string Bucket;

		public readonly byte[] Data;

		public readonly uint DataSize;

		public readonly string Key;

		public CloudStorageData(IntPtr o)
		{
			Bucket = CAPI.ovr_CloudStorageData_GetBucket(o);
			Data = CAPI.ovr_CloudStorageData_GetData(o);
			DataSize = CAPI.ovr_CloudStorageData_GetDataSize(o);
			Key = CAPI.ovr_CloudStorageData_GetKey(o);
		}
	}
	public class CloudStorageMetadata
	{
		public readonly string Bucket;

		public readonly long Counter;

		public readonly uint DataSize;

		public readonly string ExtraData;

		public readonly string Key;

		public readonly ulong SaveTime;

		public readonly CloudStorageDataStatus Status;

		public readonly string VersionHandle;

		public CloudStorageMetadata(IntPtr o)
		{
			Bucket = CAPI.ovr_CloudStorageMetadata_GetBucket(o);
			Counter = CAPI.ovr_CloudStorageMetadata_GetCounter(o);
			DataSize = CAPI.ovr_CloudStorageMetadata_GetDataSize(o);
			ExtraData = CAPI.ovr_CloudStorageMetadata_GetExtraData(o);
			Key = CAPI.ovr_CloudStorageMetadata_GetKey(o);
			SaveTime = CAPI.ovr_CloudStorageMetadata_GetSaveTime(o);
			Status = CAPI.ovr_CloudStorageMetadata_GetStatus(o);
			VersionHandle = CAPI.ovr_CloudStorageMetadata_GetVersionHandle(o);
		}
	}
	public class CloudStorageMetadataList : DeserializableList<CloudStorageMetadata>
	{
		public CloudStorageMetadataList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_CloudStorageMetadataArray_GetSize(a);
			_Data = new List<CloudStorageMetadata>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new CloudStorageMetadata(CAPI.ovr_CloudStorageMetadataArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_CloudStorageMetadataArray_GetNextUrl(a);
		}
	}
	public class CloudStorageUpdateResponse
	{
		public readonly string Bucket;

		public readonly string Key;

		public readonly CloudStorageUpdateStatus Status;

		public readonly string VersionHandle;

		public CloudStorageUpdateResponse(IntPtr o)
		{
			Bucket = CAPI.ovr_CloudStorageUpdateResponse_GetBucket(o);
			Key = CAPI.ovr_CloudStorageUpdateResponse_GetKey(o);
			Status = CAPI.ovr_CloudStorageUpdateResponse_GetStatus(o);
			VersionHandle = CAPI.ovr_CloudStorageUpdateResponse_GetVersionHandle(o);
		}
	}
	public class DeserializableList<T> : IList<T>, IEnumerable, ICollection<T>, IEnumerable<T>
	{
		protected List<T> _Data;

		protected string _NextUrl;

		protected string _PreviousUrl;

		bool ICollection<T>.IsReadOnly => ((ICollection<T>)_Data).IsReadOnly;

		public int Count => _Data.Count;

		public T this[int index]
		{
			get
			{
				return _Data[index];
			}
			set
			{
				_Data[index] = value;
			}
		}

		[Obsolete("Use IList interface on the DeserializableList object instead.", false)]
		public List<T> Data => _Data;

		public bool HasNextPage => !string.IsNullOrEmpty(NextUrl);

		public bool HasPreviousPage => !string.IsNullOrEmpty(PreviousUrl);

		public string NextUrl => _NextUrl;

		public string PreviousUrl => _PreviousUrl;

		public int IndexOf(T obj)
		{
			return _Data.IndexOf(obj);
		}

		public void Add(T item)
		{
			_Data.Add(item);
		}

		public void Clear()
		{
			_Data.Clear();
		}

		public bool Contains(T item)
		{
			return _Data.Contains(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			_Data.CopyTo(array, arrayIndex);
		}

		public IEnumerator<T> GetEnumerator()
		{
			return _Data.GetEnumerator();
		}

		public void Insert(int index, T item)
		{
			_Data.Insert(index, item);
		}

		public bool Remove(T item)
		{
			return _Data.Remove(item);
		}

		public void RemoveAt(int index)
		{
			_Data.RemoveAt(index);
		}

		private IEnumerator GetEnumerator1()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator1();
		}
	}
	public class Error
	{
		public readonly int Code;

		public readonly int HttpCode;

		public readonly string Message;

		public Error(int code, string message, int httpCode)
		{
			Message = message;
			Code = code;
			HttpCode = httpCode;
		}
	}
	public class HttpTransferUpdate
	{
		public readonly ulong ID;

		public readonly byte[] Payload;

		public readonly bool IsCompleted;

		public HttpTransferUpdate(IntPtr o)
		{
			ID = CAPI.ovr_HttpTransferUpdate_GetID(o);
			IsCompleted = CAPI.ovr_HttpTransferUpdate_IsCompleted(o);
			long num = (long)(ulong)CAPI.ovr_HttpTransferUpdate_GetSize(o);
			Payload = new byte[num];
			Marshal.Copy(CAPI.ovr_Packet_GetBytes(o), Payload, 0, (int)num);
		}
	}
	public class InstalledApplication
	{
		public readonly string ApplicationId;

		public readonly string PackageName;

		public readonly string Status;

		public readonly int VersionCode;

		public readonly string VersionName;

		public InstalledApplication(IntPtr o)
		{
			ApplicationId = CAPI.ovr_InstalledApplication_GetApplicationId(o);
			PackageName = CAPI.ovr_InstalledApplication_GetPackageName(o);
			Status = CAPI.ovr_InstalledApplication_GetStatus(o);
			VersionCode = CAPI.ovr_InstalledApplication_GetVersionCode(o);
			VersionName = CAPI.ovr_InstalledApplication_GetVersionName(o);
		}
	}
	public class InstalledApplicationList : DeserializableList<InstalledApplication>
	{
		public InstalledApplicationList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_InstalledApplicationArray_GetSize(a);
			_Data = new List<InstalledApplication>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new InstalledApplication(CAPI.ovr_InstalledApplicationArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class LanguagePackInfo
	{
		public readonly string EnglishName;

		public readonly string NativeName;

		public readonly string Tag;

		public LanguagePackInfo(IntPtr o)
		{
			EnglishName = CAPI.ovr_LanguagePackInfo_GetEnglishName(o);
			NativeName = CAPI.ovr_LanguagePackInfo_GetNativeName(o);
			Tag = CAPI.ovr_LanguagePackInfo_GetTag(o);
		}
	}
	public class LaunchBlockFlowResult
	{
		public readonly bool DidBlock;

		public readonly bool DidCancel;

		public LaunchBlockFlowResult(IntPtr o)
		{
			DidBlock = CAPI.ovr_LaunchBlockFlowResult_GetDidBlock(o);
			DidCancel = CAPI.ovr_LaunchBlockFlowResult_GetDidCancel(o);
		}
	}
	public class LaunchDetails
	{
		public readonly string DeeplinkMessage;

		public readonly string LaunchSource;

		public readonly LaunchType LaunchType;

		public readonly ulong RoomID;

		public readonly UserList UsersOptional;

		[Obsolete("Deprecated in favor of UsersOptional")]
		public readonly UserList Users;

		public LaunchDetails(IntPtr o)
		{
			DeeplinkMessage = CAPI.ovr_LaunchDetails_GetDeeplinkMessage(o);
			LaunchSource = CAPI.ovr_LaunchDetails_GetLaunchSource(o);
			LaunchType = CAPI.ovr_LaunchDetails_GetLaunchType(o);
			RoomID = CAPI.ovr_LaunchDetails_GetRoomID(o);
			IntPtr intPtr = CAPI.ovr_LaunchDetails_GetUsers(o);
			Users = new UserList(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				UsersOptional = null;
			}
			else
			{
				UsersOptional = Users;
			}
		}
	}
	public class LaunchFriendRequestFlowResult
	{
		public readonly bool DidCancel;

		public readonly bool DidSendRequest;

		public LaunchFriendRequestFlowResult(IntPtr o)
		{
			DidCancel = CAPI.ovr_LaunchFriendRequestFlowResult_GetDidCancel(o);
			DidSendRequest = CAPI.ovr_LaunchFriendRequestFlowResult_GetDidSendRequest(o);
		}
	}
	public class LaunchReportFlowResult
	{
		public readonly bool DidCancel;

		public readonly ulong UserReportId;

		public LaunchReportFlowResult(IntPtr o)
		{
			DidCancel = CAPI.ovr_LaunchReportFlowResult_GetDidCancel(o);
			UserReportId = CAPI.ovr_LaunchReportFlowResult_GetUserReportId(o);
		}
	}
	public class LaunchUnblockFlowResult
	{
		public readonly bool DidCancel;

		public readonly bool DidUnblock;

		public LaunchUnblockFlowResult(IntPtr o)
		{
			DidCancel = CAPI.ovr_LaunchUnblockFlowResult_GetDidCancel(o);
			DidUnblock = CAPI.ovr_LaunchUnblockFlowResult_GetDidUnblock(o);
		}
	}
	public class LeaderboardEntry
	{
		public readonly byte[] ExtraData;

		public readonly int Rank;

		public readonly long Score;

		public readonly DateTime Timestamp;

		public readonly User User;

		public LeaderboardEntry(IntPtr o)
		{
			ExtraData = CAPI.ovr_LeaderboardEntry_GetExtraData(o);
			Rank = CAPI.ovr_LeaderboardEntry_GetRank(o);
			Score = CAPI.ovr_LeaderboardEntry_GetScore(o);
			Timestamp = CAPI.ovr_LeaderboardEntry_GetTimestamp(o);
			User = new User(CAPI.ovr_LeaderboardEntry_GetUser(o));
		}
	}
	public class LeaderboardEntryList : DeserializableList<LeaderboardEntry>
	{
		public readonly ulong TotalCount;

		public LeaderboardEntryList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_LeaderboardEntryArray_GetSize(a);
			_Data = new List<LeaderboardEntry>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new LeaderboardEntry(CAPI.ovr_LeaderboardEntryArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			TotalCount = CAPI.ovr_LeaderboardEntryArray_GetTotalCount(a);
			_PreviousUrl = CAPI.ovr_LeaderboardEntryArray_GetPreviousUrl(a);
			_NextUrl = CAPI.ovr_LeaderboardEntryArray_GetNextUrl(a);
		}
	}
	public class LinkedAccount
	{
		public readonly string AccessToken;

		public readonly ServiceProvider ServiceProvider;

		public readonly string UserId;

		public LinkedAccount(IntPtr o)
		{
			AccessToken = CAPI.ovr_LinkedAccount_GetAccessToken(o);
			ServiceProvider = CAPI.ovr_LinkedAccount_GetServiceProvider(o);
			UserId = CAPI.ovr_LinkedAccount_GetUserId(o);
		}
	}
	public class LinkedAccountList : DeserializableList<LinkedAccount>
	{
		public LinkedAccountList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_LinkedAccountArray_GetSize(a);
			_Data = new List<LinkedAccount>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new LinkedAccount(CAPI.ovr_LinkedAccountArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class LivestreamingApplicationStatus
	{
		public readonly bool StreamingEnabled;

		public LivestreamingApplicationStatus(IntPtr o)
		{
			StreamingEnabled = CAPI.ovr_LivestreamingApplicationStatus_GetStreamingEnabled(o);
		}
	}
	public class LivestreamingStartResult
	{
		public readonly LivestreamingStartStatus StreamingResult;

		public LivestreamingStartResult(IntPtr o)
		{
			StreamingResult = CAPI.ovr_LivestreamingStartResult_GetStreamingResult(o);
		}
	}
	public class LivestreamingStatus
	{
		public readonly bool CommentsVisible;

		public readonly bool IsPaused;

		public readonly bool LivestreamingEnabled;

		public readonly int LivestreamingType;

		public readonly bool MicEnabled;

		public LivestreamingStatus(IntPtr o)
		{
			CommentsVisible = CAPI.ovr_LivestreamingStatus_GetCommentsVisible(o);
			IsPaused = CAPI.ovr_LivestreamingStatus_GetIsPaused(o);
			LivestreamingEnabled = CAPI.ovr_LivestreamingStatus_GetLivestreamingEnabled(o);
			LivestreamingType = CAPI.ovr_LivestreamingStatus_GetLivestreamingType(o);
			MicEnabled = CAPI.ovr_LivestreamingStatus_GetMicEnabled(o);
		}
	}
	public class LivestreamingVideoStats
	{
		public readonly int CommentCount;

		public readonly int ReactionCount;

		public readonly string TotalViews;

		public LivestreamingVideoStats(IntPtr o)
		{
			CommentCount = CAPI.ovr_LivestreamingVideoStats_GetCommentCount(o);
			ReactionCount = CAPI.ovr_LivestreamingVideoStats_GetReactionCount(o);
			TotalViews = CAPI.ovr_LivestreamingVideoStats_GetTotalViews(o);
		}
	}
	public class MatchmakingAdminSnapshot
	{
		public readonly MatchmakingAdminSnapshotCandidateList Candidates;

		public readonly double MyCurrentThreshold;

		public MatchmakingAdminSnapshot(IntPtr o)
		{
			Candidates = new MatchmakingAdminSnapshotCandidateList(CAPI.ovr_MatchmakingAdminSnapshot_GetCandidates(o));
			MyCurrentThreshold = CAPI.ovr_MatchmakingAdminSnapshot_GetMyCurrentThreshold(o);
		}
	}
	public class MatchmakingAdminSnapshotCandidate
	{
		public readonly bool CanMatch;

		public readonly double MyTotalScore;

		public readonly double TheirCurrentThreshold;

		public readonly double TheirTotalScore;

		public readonly string TraceId;

		public MatchmakingAdminSnapshotCandidate(IntPtr o)
		{
			CanMatch = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetCanMatch(o);
			MyTotalScore = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetMyTotalScore(o);
			TheirCurrentThreshold = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetTheirCurrentThreshold(o);
			TheirTotalScore = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetTheirTotalScore(o);
			TraceId = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetTraceId(o);
		}
	}
	public class MatchmakingAdminSnapshotCandidateList : DeserializableList<MatchmakingAdminSnapshotCandidate>
	{
		public MatchmakingAdminSnapshotCandidateList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_MatchmakingAdminSnapshotCandidateArray_GetSize(a);
			_Data = new List<MatchmakingAdminSnapshotCandidate>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new MatchmakingAdminSnapshotCandidate(CAPI.ovr_MatchmakingAdminSnapshotCandidateArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class MatchmakingBrowseResult
	{
		public readonly MatchmakingEnqueueResult EnqueueResult;

		public readonly RoomList Rooms;

		public MatchmakingBrowseResult(IntPtr o)
		{
			EnqueueResult = new MatchmakingEnqueueResult(CAPI.ovr_MatchmakingBrowseResult_GetEnqueueResult(o));
			Rooms = new RoomList(CAPI.ovr_MatchmakingBrowseResult_GetRooms(o));
		}
	}
	public class MatchmakingEnqueuedUser
	{
		public readonly Dictionary<string, string> CustomData;

		public readonly User UserOptional;

		[Obsolete("Deprecated in favor of UserOptional")]
		public readonly User User;

		public MatchmakingEnqueuedUser(IntPtr o)
		{
			CustomData = CAPI.DataStoreFromNative(CAPI.ovr_MatchmakingEnqueuedUser_GetCustomData(o));
			IntPtr intPtr = CAPI.ovr_MatchmakingEnqueuedUser_GetUser(o);
			User = new User(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				UserOptional = null;
			}
			else
			{
				UserOptional = User;
			}
		}
	}
	public class MatchmakingEnqueuedUserList : DeserializableList<MatchmakingEnqueuedUser>
	{
		public MatchmakingEnqueuedUserList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_MatchmakingEnqueuedUserArray_GetSize(a);
			_Data = new List<MatchmakingEnqueuedUser>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new MatchmakingEnqueuedUser(CAPI.ovr_MatchmakingEnqueuedUserArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class MatchmakingEnqueueResult
	{
		public readonly MatchmakingAdminSnapshot AdminSnapshotOptional;

		[Obsolete("Deprecated in favor of AdminSnapshotOptional")]
		public readonly MatchmakingAdminSnapshot AdminSnapshot;

		public readonly uint AverageWait;

		public readonly uint MatchesInLastHourCount;

		public readonly uint MaxExpectedWait;

		public readonly string Pool;

		public readonly uint RecentMatchPercentage;

		public readonly string RequestHash;

		public MatchmakingEnqueueResult(IntPtr o)
		{
			IntPtr intPtr = CAPI.ovr_MatchmakingEnqueueResult_GetAdminSnapshot(o);
			AdminSnapshot = new MatchmakingAdminSnapshot(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				AdminSnapshotOptional = null;
			}
			else
			{
				AdminSnapshotOptional = AdminSnapshot;
			}
			AverageWait = CAPI.ovr_MatchmakingEnqueueResult_GetAverageWait(o);
			MatchesInLastHourCount = CAPI.ovr_MatchmakingEnqueueResult_GetMatchesInLastHourCount(o);
			MaxExpectedWait = CAPI.ovr_MatchmakingEnqueueResult_GetMaxExpectedWait(o);
			Pool = CAPI.ovr_MatchmakingEnqueueResult_GetPool(o);
			RecentMatchPercentage = CAPI.ovr_MatchmakingEnqueueResult_GetRecentMatchPercentage(o);
			RequestHash = CAPI.ovr_MatchmakingEnqueueResult_GetRequestHash(o);
		}
	}
	public class MatchmakingEnqueueResultAndRoom
	{
		public readonly MatchmakingEnqueueResult MatchmakingEnqueueResult;

		public readonly Room Room;

		public MatchmakingEnqueueResultAndRoom(IntPtr o)
		{
			MatchmakingEnqueueResult = new MatchmakingEnqueueResult(CAPI.ovr_MatchmakingEnqueueResultAndRoom_GetMatchmakingEnqueueResult(o));
			Room = new Room(CAPI.ovr_MatchmakingEnqueueResultAndRoom_GetRoom(o));
		}
	}
	public class MatchmakingStats
	{
		public readonly uint DrawCount;

		public readonly uint LossCount;

		public readonly uint SkillLevel;

		public readonly uint WinCount;

		public MatchmakingStats(IntPtr o)
		{
			DrawCount = CAPI.ovr_MatchmakingStats_GetDrawCount(o);
			LossCount = CAPI.ovr_MatchmakingStats_GetLossCount(o);
			SkillLevel = CAPI.ovr_MatchmakingStats_GetSkillLevel(o);
			WinCount = CAPI.ovr_MatchmakingStats_GetWinCount(o);
		}
	}
	public class NetworkingPeer
	{
		public ulong ID { get; private set; }

		public PeerConnectionState State { get; private set; }

		public NetworkingPeer(ulong id, PeerConnectionState state)
		{
			ID = id;
			State = state;
		}
	}
	public class OrgScopedID
	{
		public readonly ulong ID;

		public OrgScopedID(IntPtr o)
		{
			ID = CAPI.ovr_OrgScopedID_GetID(o);
		}
	}
	public class Party
	{
		public readonly ulong ID;

		public readonly UserList InvitedUsersOptional;

		[Obsolete("Deprecated in favor of InvitedUsersOptional")]
		public readonly UserList InvitedUsers;

		public readonly User LeaderOptional;

		[Obsolete("Deprecated in favor of LeaderOptional")]
		public readonly User Leader;

		public readonly Room RoomOptional;

		[Obsolete("Deprecated in favor of RoomOptional")]
		public readonly Room Room;

		public readonly UserList UsersOptional;

		[Obsolete("Deprecated in favor of UsersOptional")]
		public readonly UserList Users;

		public Party(IntPtr o)
		{
			ID = CAPI.ovr_Party_GetID(o);
			IntPtr intPtr = CAPI.ovr_Party_GetInvitedUsers(o);
			InvitedUsers = new UserList(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				InvitedUsersOptional = null;
			}
			else
			{
				InvitedUsersOptional = InvitedUsers;
			}
			IntPtr intPtr2 = CAPI.ovr_Party_GetLeader(o);
			Leader = new User(intPtr2);
			if (intPtr2 == IntPtr.Zero)
			{
				LeaderOptional = null;
			}
			else
			{
				LeaderOptional = Leader;
			}
			IntPtr intPtr3 = CAPI.ovr_Party_GetRoom(o);
			Room = new Room(intPtr3);
			if (intPtr3 == IntPtr.Zero)
			{
				RoomOptional = null;
			}
			else
			{
				RoomOptional = Room;
			}
			IntPtr intPtr4 = CAPI.ovr_Party_GetUsers(o);
			Users = new UserList(intPtr4);
			if (intPtr4 == IntPtr.Zero)
			{
				UsersOptional = null;
			}
			else
			{
				UsersOptional = Users;
			}
		}
	}
	public class PartyID
	{
		public readonly ulong ID;

		public PartyID(IntPtr o)
		{
			ID = CAPI.ovr_PartyID_GetID(o);
		}
	}
	public class Pid
	{
		public readonly string Id;

		public Pid(IntPtr o)
		{
			Id = CAPI.ovr_Pid_GetId(o);
		}
	}
	public class PidList : DeserializableList<Pid>
	{
		public PidList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_PidArray_GetSize(a);
			_Data = new List<Pid>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Pid(CAPI.ovr_PidArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class PingResult
	{
		private ulong? pingTimeUsec;

		public ulong ID { get; private set; }

		public ulong PingTimeUsec => (!pingTimeUsec.HasValue) ? 0 : pingTimeUsec.Value;

		public bool IsTimeout => !pingTimeUsec.HasValue;

		public PingResult(ulong id, ulong? pingTimeUsec)
		{
			ID = id;
			this.pingTimeUsec = pingTimeUsec;
		}
	}
	public class PlatformInitialize
	{
		public readonly PlatformInitializeResult Result;

		public PlatformInitialize(IntPtr o)
		{
			Result = CAPI.ovr_PlatformInitialize_GetResult(o);
		}
	}
	public class Product
	{
		public readonly string Description;

		public readonly string FormattedPrice;

		public readonly string Name;

		public readonly string Sku;

		public Product(IntPtr o)
		{
			Description = CAPI.ovr_Product_GetDescription(o);
			FormattedPrice = CAPI.ovr_Product_GetFormattedPrice(o);
			Name = CAPI.ovr_Product_GetName(o);
			Sku = CAPI.ovr_Product_GetSKU(o);
		}
	}
	public class ProductList : DeserializableList<Product>
	{
		public ProductList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_ProductArray_GetSize(a);
			_Data = new List<Product>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Product(CAPI.ovr_ProductArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_ProductArray_GetNextUrl(a);
		}
	}
	public class Purchase
	{
		public readonly DateTime ExpirationTime;

		public readonly DateTime GrantTime;

		public readonly ulong ID;

		public readonly string Sku;

		public Purchase(IntPtr o)
		{
			ExpirationTime = CAPI.ovr_Purchase_GetExpirationTime(o);
			GrantTime = CAPI.ovr_Purchase_GetGrantTime(o);
			ID = CAPI.ovr_Purchase_GetPurchaseID(o);
			Sku = CAPI.ovr_Purchase_GetSKU(o);
		}
	}
	public class PurchaseList : DeserializableList<Purchase>
	{
		public PurchaseList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_PurchaseArray_GetSize(a);
			_Data = new List<Purchase>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Purchase(CAPI.ovr_PurchaseArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_PurchaseArray_GetNextUrl(a);
		}
	}
	public class Room
	{
		public readonly ulong ApplicationID;

		public readonly Dictionary<string, string> DataStore;

		public readonly string Description;

		public readonly ulong ID;

		public readonly UserList InvitedUsersOptional;

		[Obsolete("Deprecated in favor of InvitedUsersOptional")]
		public readonly UserList InvitedUsers;

		public readonly bool IsMembershipLocked;

		public readonly RoomJoinPolicy JoinPolicy;

		public readonly RoomJoinability Joinability;

		public readonly MatchmakingEnqueuedUserList MatchedUsersOptional;

		[Obsolete("Deprecated in favor of MatchedUsersOptional")]
		public readonly MatchmakingEnqueuedUserList MatchedUsers;

		public readonly uint MaxUsers;

		public readonly string Name;

		public readonly User OwnerOptional;

		[Obsolete("Deprecated in favor of OwnerOptional")]
		public readonly User Owner;

		public readonly RoomType Type;

		public readonly UserList UsersOptional;

		[Obsolete("Deprecated in favor of UsersOptional")]
		public readonly UserList Users;

		public readonly uint Version;

		public Room(IntPtr o)
		{
			ApplicationID = CAPI.ovr_Room_GetApplicationID(o);
			DataStore = CAPI.DataStoreFromNative(CAPI.ovr_Room_GetDataStore(o));
			Description = CAPI.ovr_Room_GetDescription(o);
			ID = CAPI.ovr_Room_GetID(o);
			IntPtr intPtr = CAPI.ovr_Room_GetInvitedUsers(o);
			InvitedUsers = new UserList(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				InvitedUsersOptional = null;
			}
			else
			{
				InvitedUsersOptional = InvitedUsers;
			}
			IsMembershipLocked = CAPI.ovr_Room_GetIsMembershipLocked(o);
			JoinPolicy = CAPI.ovr_Room_GetJoinPolicy(o);
			Joinability = CAPI.ovr_Room_GetJoinability(o);
			IntPtr intPtr2 = CAPI.ovr_Room_GetMatchedUsers(o);
			MatchedUsers = new MatchmakingEnqueuedUserList(intPtr2);
			if (intPtr2 == IntPtr.Zero)
			{
				MatchedUsersOptional = null;
			}
			else
			{
				MatchedUsersOptional = MatchedUsers;
			}
			MaxUsers = CAPI.ovr_Room_GetMaxUsers(o);
			Name = CAPI.ovr_Room_GetName(o);
			IntPtr intPtr3 = CAPI.ovr_Room_GetOwner(o);
			Owner = new User(intPtr3);
			if (intPtr3 == IntPtr.Zero)
			{
				OwnerOptional = null;
			}
			else
			{
				OwnerOptional = Owner;
			}
			Type = CAPI.ovr_Room_GetType(o);
			IntPtr intPtr4 = CAPI.ovr_Room_GetUsers(o);
			Users = new UserList(intPtr4);
			if (intPtr4 == IntPtr.Zero)
			{
				UsersOptional = null;
			}
			else
			{
				UsersOptional = Users;
			}
			Version = CAPI.ovr_Room_GetVersion(o);
		}
	}
	public class RoomList : DeserializableList<Room>
	{
		public RoomList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_RoomArray_GetSize(a);
			_Data = new List<Room>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Room(CAPI.ovr_RoomArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_RoomArray_GetNextUrl(a);
		}
	}
	public class RoomInviteNotification
	{
		public readonly ulong ID;

		public readonly ulong RoomID;

		public readonly ulong SenderID;

		public readonly DateTime SentTime;

		public RoomInviteNotification(IntPtr o)
		{
			ID = CAPI.ovr_RoomInviteNotification_GetID(o);
			RoomID = CAPI.ovr_RoomInviteNotification_GetRoomID(o);
			SenderID = CAPI.ovr_RoomInviteNotification_GetSenderID(o);
			SentTime = CAPI.ovr_RoomInviteNotification_GetSentTime(o);
		}
	}
	public class RoomInviteNotificationList : DeserializableList<RoomInviteNotification>
	{
		public RoomInviteNotificationList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_RoomInviteNotificationArray_GetSize(a);
			_Data = new List<RoomInviteNotification>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new RoomInviteNotification(CAPI.ovr_RoomInviteNotificationArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_RoomInviteNotificationArray_GetNextUrl(a);
		}
	}
	public class SdkAccount
	{
		public readonly SdkAccountType AccountType;

		public readonly ulong UserId;

		public SdkAccount(IntPtr o)
		{
			AccountType = CAPI.ovr_SdkAccount_GetAccountType(o);
			UserId = CAPI.ovr_SdkAccount_GetUserId(o);
		}
	}
	public class SdkAccountList : DeserializableList<SdkAccount>
	{
		public SdkAccountList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_SdkAccountArray_GetSize(a);
			_Data = new List<SdkAccount>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new SdkAccount(CAPI.ovr_SdkAccountArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class ShareMediaResult
	{
		public readonly ShareMediaStatus Status;

		public ShareMediaResult(IntPtr o)
		{
			Status = CAPI.ovr_ShareMediaResult_GetStatus(o);
		}
	}
	public class SystemPermission
	{
		public readonly bool HasPermission;

		public readonly PermissionGrantStatus PermissionGrantStatus;

		public SystemPermission(IntPtr o)
		{
			HasPermission = CAPI.ovr_SystemPermission_GetHasPermission(o);
			PermissionGrantStatus = CAPI.ovr_SystemPermission_GetPermissionGrantStatus(o);
		}
	}
	public class SystemVoipState
	{
		public readonly VoipMuteState MicrophoneMuted;

		public readonly SystemVoipStatus Status;

		public SystemVoipState(IntPtr o)
		{
			MicrophoneMuted = CAPI.ovr_SystemVoipState_GetMicrophoneMuted(o);
			Status = CAPI.ovr_SystemVoipState_GetStatus(o);
		}
	}
	public class User
	{
		public readonly ulong ID;

		public readonly string ImageURL;

		public readonly string InviteToken;

		public readonly string OculusID;

		public readonly string Presence;

		public readonly UserPresenceStatus PresenceStatus;

		public readonly string SmallImageUrl;

		public User(IntPtr o)
		{
			ID = CAPI.ovr_User_GetID(o);
			ImageURL = CAPI.ovr_User_GetImageUrl(o);
			InviteToken = CAPI.ovr_User_GetInviteToken(o);
			OculusID = CAPI.ovr_User_GetOculusID(o);
			Presence = CAPI.ovr_User_GetPresence(o);
			PresenceStatus = CAPI.ovr_User_GetPresenceStatus(o);
			SmallImageUrl = CAPI.ovr_User_GetSmallImageUrl(o);
		}
	}
	public class UserList : DeserializableList<User>
	{
		public UserList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_UserArray_GetSize(a);
			_Data = new List<User>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new User(CAPI.ovr_UserArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_UserArray_GetNextUrl(a);
		}
	}
	public class UserAndRoom
	{
		public readonly Room RoomOptional;

		[Obsolete("Deprecated in favor of RoomOptional")]
		public readonly Room Room;

		public readonly User User;

		public UserAndRoom(IntPtr o)
		{
			IntPtr intPtr = CAPI.ovr_UserAndRoom_GetRoom(o);
			Room = new Room(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				RoomOptional = null;
			}
			else
			{
				RoomOptional = Room;
			}
			User = new User(CAPI.ovr_UserAndRoom_GetUser(o));
		}
	}
	public class UserAndRoomList : DeserializableList<UserAndRoom>
	{
		public UserAndRoomList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_UserAndRoomArray_GetSize(a);
			_Data = new List<UserAndRoom>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new UserAndRoom(CAPI.ovr_UserAndRoomArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_UserAndRoomArray_GetNextUrl(a);
		}
	}
	public class UserProof
	{
		public readonly string Value;

		public UserProof(IntPtr o)
		{
			Value = CAPI.ovr_UserProof_GetNonce(o);
		}
	}
	public class UserReportID
	{
		public readonly bool DidCancel;

		public readonly ulong ID;

		public UserReportID(IntPtr o)
		{
			DidCancel = CAPI.ovr_UserReportID_GetDidCancel(o);
			ID = CAPI.ovr_UserReportID_GetID(o);
		}
	}
}
namespace Oculus.Platform
{
	public sealed class Packet : IDisposable
	{
		private readonly ulong size;

		private readonly IntPtr packetHandle;

		public ulong SenderID => CAPI.ovr_Packet_GetSenderID(packetHandle);

		public ulong Size => size;

		public SendPolicy Policy => CAPI.ovr_Packet_GetSendPolicy(packetHandle);

		public Packet(IntPtr packetHandle)
		{
			this.packetHandle = packetHandle;
			size = (ulong)CAPI.ovr_Packet_GetSize(packetHandle);
		}

		public ulong ReadBytes(byte[] destination)
		{
			if ((ulong)destination.LongLength < size)
			{
				throw new ArgumentException($"Destination array was not big enough to hold {size} bytes");
			}
			Marshal.Copy(CAPI.ovr_Packet_GetBytes(packetHandle), destination, 0, (int)size);
			return size;
		}

		~Packet()
		{
			Dispose();
		}

		public void Dispose()
		{
			CAPI.ovr_Packet_Free(packetHandle);
			GC.SuppressFinalize(this);
		}
	}
	public enum PeerConnectionState
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("CONNECTED")]
		Connected,
		[Description("TIMEOUT")]
		Timeout,
		[Description("CLOSED")]
		Closed
	}
	public enum PermissionGrantStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("GRANTED")]
		Granted,
		[Description("DENIED")]
		Denied,
		[Description("BLOCKED")]
		Blocked
	}
	public enum PermissionType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MICROPHONE")]
		Microphone,
		[Description("WRITE_EXTERNAL_STORAGE")]
		WriteExternalStorage
	}
	public sealed class Core
	{
		private static bool IsPlatformInitialized;

		public static bool LogMessages;

		public static bool IsInitialized()
		{
			return IsPlatformInitialized;
		}

		internal static void ForceInitialized()
		{
			IsPlatformInitialized = true;
		}

		private static string getAppID(string appId = null)
		{
			string appIDFromConfig = GetAppIDFromConfig();
			if (string.IsNullOrEmpty(appId))
			{
				if (string.IsNullOrEmpty(appIDFromConfig))
				{
					throw new UnityException("Update your app id by selecting 'Oculus Platform' -> 'Edit Settings'");
				}
				appId = appIDFromConfig;
			}
			else if (!string.IsNullOrEmpty(appIDFromConfig))
			{
				UnityEngine.Debug.LogWarningFormat("The 'Oculus App Id ({0})' field in 'Oculus Platform/Edit Settings' is being overridden by the App Id ({1}) that you passed in to Platform.Core.Initialize.  You should only specify this in one place.  We recommend the menu location.", appIDFromConfig, appId);
			}
			return appId;
		}

		public static Request<PlatformInitialize> AsyncInitialize(string appId = null)
		{
			appId = getAppID(appId);
			Request<PlatformInitialize> request;
			if (UnityEngine.Application.isEditor && PlatformSettings.UseStandalonePlatform)
			{
				StandalonePlatform standalonePlatform = new StandalonePlatform();
				request = standalonePlatform.InitializeInEditor();
			}
			else if (UnityEngine.Application.platform == RuntimePlatform.WindowsEditor || UnityEngine.Application.platform == RuntimePlatform.WindowsPlayer)
			{
				WindowsPlatform windowsPlatform = new WindowsPlatform();
				request = windowsPlatform.AsyncInitialize(appId);
			}
			else
			{
				if (UnityEngine.Application.platform != RuntimePlatform.Android)
				{
					throw new NotImplementedException("Oculus platform is not implemented on this platform yet.");
				}
				AndroidPlatform androidPlatform = new AndroidPlatform();
				request = androidPlatform.AsyncInitialize(appId);
			}
			IsPlatformInitialized = request != null;
			if (!IsPlatformInitialized)
			{
				throw new UnityException("Oculus Platform failed to initialize.");
			}
			if (LogMessages)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.Core.LogMessages is set to true. This will cause extra heap allocations, and should not be used outside of testing and debugging.");
			}
			new GameObject("Oculus.Platform.CallbackRunner").AddComponent<CallbackRunner>();
			return request;
		}

		public static void Initialize(string appId = null)
		{
			appId = getAppID(appId);
			if (UnityEngine.Application.isEditor && PlatformSettings.UseStandalonePlatform)
			{
				StandalonePlatform standalonePlatform = new StandalonePlatform();
				IsPlatformInitialized = standalonePlatform.InitializeInEditor() != null;
			}
			else if (UnityEngine.Application.platform == RuntimePlatform.WindowsEditor || UnityEngine.Application.platform == RuntimePlatform.WindowsPlayer)
			{
				WindowsPlatform windowsPlatform = new WindowsPlatform();
				IsPlatformInitialized = windowsPlatform.Initialize(appId);
			}
			else
			{
				if (UnityEngine.Application.platform != RuntimePlatform.Android)
				{
					throw new NotImplementedException("Oculus platform is not implemented on this platform yet.");
				}
				AndroidPlatform androidPlatform = new AndroidPlatform();
				IsPlatformInitialized = androidPlatform.Initialize(appId);
			}
			if (!IsPlatformInitialized)
			{
				throw new UnityException("Oculus Platform failed to initialize.");
			}
			if (LogMessages)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.Core.LogMessages is set to true. This will cause extra heap allocations, and should not be used outside of testing and debugging.");
			}
			new GameObject("Oculus.Platform.CallbackRunner").AddComponent<CallbackRunner>();
		}

		private static string GetAppIDFromConfig()
		{
			if (UnityEngine.Application.platform == RuntimePlatform.Android)
			{
				return PlatformSettings.MobileAppID;
			}
			return PlatformSettings.AppID;
		}
	}
	public static class ApplicationLifecycle
	{
		public static LaunchDetails GetLaunchDetails()
		{
			return new LaunchDetails(CAPI.ovr_ApplicationLifecycle_GetLaunchDetails());
		}
	}
	public static class Rooms
	{
		public static Request<Room> UpdateDataStore(ulong roomID, Dictionary<string, string> data)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovrKeyValuePair[] array = new CAPI.ovrKeyValuePair[data.Count];
				int num = 0;
				foreach (KeyValuePair<string, string> datum in data)
				{
					ref CAPI.ovrKeyValuePair reference = ref array[num++];
					reference = new CAPI.ovrKeyValuePair(datum.Key, datum.Value);
				}
				return new Request<Room>(CAPI.ovr_Room_UpdateDataStore(roomID, array));
			}
			return null;
		}

		[Obsolete("Deprecated in favor of SetRoomInviteAcceptedNotificationCallback")]
		public static void SetRoomInviteNotificationCallback(Message<string>.Callback callback)
		{
			SetRoomInviteAcceptedNotificationCallback(callback);
		}

		public static Request<Room> CreateAndJoinPrivate(RoomJoinPolicy joinPolicy, uint maxUsers, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_CreateAndJoinPrivate(joinPolicy, maxUsers, subscribeToUpdates));
			}
			return null;
		}

		public static Request<Room> CreateAndJoinPrivate2(RoomJoinPolicy joinPolicy, uint maxUsers, RoomOptions roomOptions)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_CreateAndJoinPrivate2(joinPolicy, maxUsers, (IntPtr)roomOptions));
			}
			return null;
		}

		public static Request<Room> Get(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_Get(roomID));
			}
			return null;
		}

		public static Request<Room> GetCurrent()
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_GetCurrent());
			}
			return null;
		}

		public static Request<Room> GetCurrentForUser(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_GetCurrentForUser(userID));
			}
			return null;
		}

		public static Request<UserList> GetInvitableUsers()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_Room_GetInvitableUsers());
			}
			return null;
		}

		public static Request<UserList> GetInvitableUsers2(RoomOptions roomOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_Room_GetInvitableUsers2((IntPtr)roomOptions));
			}
			return null;
		}

		public static Request<RoomList> GetModeratedRooms()
		{
			if (Core.IsInitialized())
			{
				return new Request<RoomList>(CAPI.ovr_Room_GetModeratedRooms());
			}
			return null;
		}

		public static Request<Room> InviteUser(ulong roomID, string inviteToken)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_InviteUser(roomID, inviteToken));
			}
			return null;
		}

		public static Request<Room> Join(ulong roomID, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_Join(roomID, subscribeToUpdates));
			}
			return null;
		}

		public static Request<Room> Join2(ulong roomID, RoomOptions roomOptions)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_Join2(roomID, (IntPtr)roomOptions));
			}
			return null;
		}

		public static Request<Room> KickUser(ulong roomID, ulong userID, int kickDurationSeconds)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_KickUser(roomID, userID, kickDurationSeconds));
			}
			return null;
		}

		public static Request LaunchInvitableUserFlow(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Room_LaunchInvitableUserFlow(roomID));
			}
			return null;
		}

		public static Request<Room> Leave(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_Leave(roomID));
			}
			return null;
		}

		public static Request<Room> SetDescription(ulong roomID, string description)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_SetDescription(roomID, description));
			}
			return null;
		}

		public static Request<Room> UpdateMembershipLockStatus(ulong roomID, RoomMembershipLockStatus membershipLockStatus)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_UpdateMembershipLockStatus(roomID, membershipLockStatus));
			}
			return null;
		}

		public static Request UpdateOwner(ulong roomID, ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Room_UpdateOwner(roomID, userID));
			}
			return null;
		}

		public static Request<Room> UpdatePrivateRoomJoinPolicy(ulong roomID, RoomJoinPolicy newJoinPolicy)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_UpdatePrivateRoomJoinPolicy(roomID, newJoinPolicy));
			}
			return null;
		}

		public static void SetRoomInviteAcceptedNotificationCallback(Message<string>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Room_InviteAccepted, callback);
		}

		public static void SetRoomInviteReceivedNotificationCallback(Message<RoomInviteNotification>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Room_InviteReceived, callback);
		}

		public static void SetUpdateNotificationCallback(Message<Room>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Room_RoomUpdate, callback);
		}

		public static Request<RoomList> GetNextRoomListPage(RoomList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextRoomListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<RoomList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1317239238));
			}
			return null;
		}
	}
	public static class Matchmaking
	{
		public class CustomQuery
		{
			public struct Criterion
			{
				public string key;

				public MatchmakingCriterionImportance importance;

				public Dictionary<string, object> parameters;

				public Criterion(string key_, MatchmakingCriterionImportance importance_)
				{
					key = key_;
					importance = importance_;
					parameters = null;
				}
			}

			public Dictionary<string, object> data;

			public Criterion[] criteria;

			public IntPtr ToUnmanaged()
			{
				CAPI.ovrMatchmakingCustomQueryData ovrMatchmakingCustomQueryData = default(CAPI.ovrMatchmakingCustomQueryData);
				if (criteria != null && criteria.Length > 0)
				{
					ovrMatchmakingCustomQueryData.criterionArrayCount = (uint)criteria.Length;
					CAPI.ovrMatchmakingCriterion[] array = new CAPI.ovrMatchmakingCriterion[criteria.Length];
					for (int i = 0; i < criteria.Length; i++)
					{
						array[i].importance_ = criteria[i].importance;
						array[i].key_ = criteria[i].key;
						if (criteria[i].parameters != null && criteria[i].parameters.Count > 0)
						{
							array[i].parameterArrayCount = (uint)criteria[i].parameters.Count;
							array[i].parameterArray = CAPI.ArrayOfStructsToIntPtr(CAPI.DictionaryToOVRKeyValuePairs(criteria[i].parameters));
						}
						else
						{
							array[i].parameterArrayCount = 0u;
							array[i].parameterArray = IntPtr.Zero;
						}
					}
					ovrMatchmakingCustomQueryData.criterionArray = CAPI.ArrayOfStructsToIntPtr(array);
				}
				else
				{
					ovrMatchmakingCustomQueryData.criterionArrayCount = 0u;
					ovrMatchmakingCustomQueryData.criterionArray = IntPtr.Zero;
				}
				if (data != null && data.Count > 0)
				{
					ovrMatchmakingCustomQueryData.dataArrayCount = (uint)data.Count;
					ovrMatchmakingCustomQueryData.dataArray = CAPI.ArrayOfStructsToIntPtr(CAPI.DictionaryToOVRKeyValuePairs(data));
				}
				else
				{
					ovrMatchmakingCustomQueryData.dataArrayCount = 0u;
					ovrMatchmakingCustomQueryData.dataArray = IntPtr.Zero;
				}
				IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(ovrMatchmakingCustomQueryData));
				Marshal.StructureToPtr(ovrMatchmakingCustomQueryData, intPtr, fDeleteOld: true);
				return intPtr;
			}
		}

		public static Request ReportResultsInsecure(ulong roomID, Dictionary<string, int> data)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovrKeyValuePair[] array = new CAPI.ovrKeyValuePair[data.Count];
				int num = 0;
				foreach (KeyValuePair<string, int> datum in data)
				{
					ref CAPI.ovrKeyValuePair reference = ref array[num++];
					reference = new CAPI.ovrKeyValuePair(datum.Key, datum.Value);
				}
				return new Request(CAPI.ovr_Matchmaking_ReportResultInsecure(roomID, array));
			}
			return null;
		}

		public static Request<MatchmakingStats> GetStats(string pool, uint maxLevel, MatchmakingStatApproach approach = MatchmakingStatApproach.Trailing)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingStats>(CAPI.ovr_Matchmaking_GetStats(pool, maxLevel, approach));
			}
			return null;
		}

		public static Request<MatchmakingBrowseResult> Browse(string pool, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingBrowseResult>(CAPI.ovr_Matchmaking_Browse(pool, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingBrowseResult> Browse2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingBrowseResult>(CAPI.ovr_Matchmaking_Browse2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request Cancel(string pool, string requestHash)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_Cancel(pool, requestHash));
			}
			return null;
		}

		public static Request Cancel()
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_Cancel2());
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResultAndRoom> CreateAndEnqueueRoom(string pool, uint maxUsers, bool subscribeToUpdates = false, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResultAndRoom>(CAPI.ovr_Matchmaking_CreateAndEnqueueRoom(pool, maxUsers, subscribeToUpdates, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResultAndRoom> CreateAndEnqueueRoom2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResultAndRoom>(CAPI.ovr_Matchmaking_CreateAndEnqueueRoom2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<Room> CreateRoom(string pool, uint maxUsers, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Matchmaking_CreateRoom(pool, maxUsers, subscribeToUpdates));
			}
			return null;
		}

		public static Request<Room> CreateRoom2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Matchmaking_CreateRoom2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> Enqueue(string pool, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_Enqueue(pool, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> Enqueue2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_Enqueue2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> EnqueueRoom(ulong roomID, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_EnqueueRoom(roomID, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> EnqueueRoom2(ulong roomID, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_EnqueueRoom2(roomID, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<MatchmakingAdminSnapshot> GetAdminSnapshot()
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingAdminSnapshot>(CAPI.ovr_Matchmaking_GetAdminSnapshot());
			}
			return null;
		}

		public static Request<Room> JoinRoom(ulong roomID, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Matchmaking_JoinRoom(roomID, subscribeToUpdates));
			}
			return null;
		}

		public static Request StartMatch(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_StartMatch(roomID));
			}
			return null;
		}

		public static void SetMatchFoundNotificationCallback(Message<Room>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Matchmaking_MatchFound, callback);
		}
	}
	public static class Net
	{
		public static Packet ReadPacket()
		{
			if (!Core.IsInitialized())
			{
				return null;
			}
			IntPtr intPtr = CAPI.ovr_Net_ReadPacket();
			if (intPtr == IntPtr.Zero)
			{
				return null;
			}
			return new Packet(intPtr);
		}

		public static bool SendPacket(ulong userID, byte[] bytes, SendPolicy policy)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_SendPacket(userID, (UIntPtr)(ulong)bytes.Length, bytes, policy);
			}
			return false;
		}

		public static void Connect(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_Connect(userID);
			}
		}

		public static void Accept(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_Accept(userID);
			}
		}

		public static void Close(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_Close(userID);
			}
		}

		public static bool IsConnected(ulong userID)
		{
			return Core.IsInitialized() && CAPI.ovr_Net_IsConnected(userID);
		}

		public static bool SendPacketToCurrentRoom(byte[] bytes, SendPolicy policy)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_SendPacketToCurrentRoom((UIntPtr)(ulong)bytes.Length, bytes, policy);
			}
			return false;
		}

		public static bool AcceptForCurrentRoom()
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_AcceptForCurrentRoom();
			}
			return false;
		}

		public static void CloseForCurrentRoom()
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_CloseForCurrentRoom();
			}
		}

		public static Request<PingResult> Ping(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<PingResult>(CAPI.ovr_Net_Ping(userID));
			}
			return null;
		}

		public static void SetConnectionStateChangedCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Networking_ConnectionStateChange, callback);
		}

		public static void SetPeerConnectRequestCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Networking_PeerConnectRequest, callback);
		}

		public static void SetPingResultNotificationCallback(Message<PingResult>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Networking_PingResult, callback);
		}
	}
	public static class Leaderboards
	{
		public static Request<LeaderboardEntryList> GetNextEntries(LeaderboardEntryList list)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1310751961));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetPreviousEntries(LeaderboardEntryList list)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_HTTP_GetWithMessageType(list.PreviousUrl, 1224858304));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetEntries(string leaderboardName, int limit, LeaderboardFilterType filter, LeaderboardStartAt startAt)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_Leaderboard_GetEntries(leaderboardName, limit, filter, startAt));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetEntriesAfterRank(string leaderboardName, int limit, ulong afterRank)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_Leaderboard_GetEntriesAfterRank(leaderboardName, limit, afterRank));
			}
			return null;
		}

		public static Request<bool> WriteEntry(string leaderboardName, long score, byte[] extraData = null, bool forceUpdate = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<bool>(CAPI.ovr_Leaderboard_WriteEntry(leaderboardName, score, extraData, (extraData != null) ? ((uint)extraData.Length) : 0u, forceUpdate));
			}
			return null;
		}
	}
	public static class Voip
	{
		public static void Start(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_Start(userID);
			}
		}

		public static void Accept(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_Accept(userID);
			}
		}

		public static void Stop(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_Stop(userID);
			}
		}

		public static void SetMicrophoneFilterCallback(CAPI.FilterCallback callback)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_SetMicrophoneFilterCallbackWithFixedSizeBuffer(callback, (UIntPtr)480uL);
			}
		}

		public static void SetMicrophoneMuted(VoipMuteState state)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_SetMicrophoneMuted(state);
			}
		}

		public static VoipMuteState GetSystemVoipMicrophoneMuted()
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetSystemVoipMicrophoneMuted();
			}
			return VoipMuteState.Unknown;
		}

		public static SystemVoipStatus GetSystemVoipStatus()
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetSystemVoipStatus();
			}
			return SystemVoipStatus.Unknown;
		}

		public static VoipDtxState GetIsConnectionUsingDtx(ulong peerID)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetIsConnectionUsingDtx(peerID);
			}
			return VoipDtxState.Unknown;
		}

		public static VoipBitrate GetLocalBitrate(ulong peerID)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetLocalBitrate(peerID);
			}
			return VoipBitrate.Unknown;
		}

		public static VoipBitrate GetRemoteBitrate(ulong peerID)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetRemoteBitrate(peerID);
			}
			return VoipBitrate.Unknown;
		}

		public static void SetNewConnectionOptions(VoipOptions voipOptions)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_SetNewConnectionOptions((IntPtr)voipOptions);
			}
		}

		public static Request<SystemVoipState> SetSystemVoipSuppressed(bool suppressed)
		{
			if (Core.IsInitialized())
			{
				return new Request<SystemVoipState>(CAPI.ovr_Voip_SetSystemVoipSuppressed(suppressed));
			}
			return null;
		}

		public static void SetVoipConnectRequestCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Voip_ConnectRequest, callback);
		}

		public static void SetVoipStateChangeCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Voip_StateChange, callback);
		}

		public static void SetSystemVoipStateNotificationCallback(Message<SystemVoipState>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Voip_SystemVoipState, callback);
		}
	}
	public static class Achievements
	{
		public static Request<AchievementUpdate> AddCount(string name, ulong count)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementUpdate>(CAPI.ovr_Achievements_AddCount(name, count));
			}
			return null;
		}

		public static Request<AchievementUpdate> AddFields(string name, string fields)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementUpdate>(CAPI.ovr_Achievements_AddFields(name, fields));
			}
			return null;
		}

		public static Request<AchievementDefinitionList> GetAllDefinitions()
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementDefinitionList>(CAPI.ovr_Achievements_GetAllDefinitions());
			}
			return null;
		}

		public static Request<AchievementProgressList> GetAllProgress()
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementProgressList>(CAPI.ovr_Achievements_GetAllProgress());
			}
			return null;
		}

		public static Request<AchievementDefinitionList> GetDefinitionsByName(string[] names)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementDefinitionList>(CAPI.ovr_Achievements_GetDefinitionsByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Request<AchievementProgressList> GetProgressByName(string[] names)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementProgressList>(CAPI.ovr_Achievements_GetProgressByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Request<AchievementUpdate> Unlock(string name)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementUpdate>(CAPI.ovr_Achievements_Unlock(name));
			}
			return null;
		}

		public static Request<AchievementDefinitionList> GetNextAchievementDefinitionListPage(AchievementDefinitionList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextAchievementDefinitionListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<AchievementDefinitionList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 712888917));
			}
			return null;
		}

		public static Request<AchievementProgressList> GetNextAchievementProgressListPage(AchievementProgressList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextAchievementProgressListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<AchievementProgressList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 792913703));
			}
			return null;
		}
	}
	public static class Application
	{
		public static Request<ApplicationVersion> GetVersion()
		{
			if (Core.IsInitialized())
			{
				return new Request<ApplicationVersion>(CAPI.ovr_Application_GetVersion());
			}
			return null;
		}

		public static Request<string> LaunchOtherApp(ulong appID, ApplicationOptions deeplink_options = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<string>(CAPI.ovr_Application_LaunchOtherApp(appID, (IntPtr)deeplink_options));
			}
			return null;
		}
	}
	public static class AssetFile
	{
		public static Request<AssetFileDeleteResult> Delete(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDeleteResult>(CAPI.ovr_AssetFile_Delete(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDeleteResult> DeleteById(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDeleteResult>(CAPI.ovr_AssetFile_DeleteById(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDeleteResult> DeleteByName(string assetFileName)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDeleteResult>(CAPI.ovr_AssetFile_DeleteByName(assetFileName));
			}
			return null;
		}

		public static Request<AssetFileDownloadResult> Download(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadResult>(CAPI.ovr_AssetFile_Download(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDownloadResult> DownloadById(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadResult>(CAPI.ovr_AssetFile_DownloadById(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDownloadResult> DownloadByName(string assetFileName)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadResult>(CAPI.ovr_AssetFile_DownloadByName(assetFileName));
			}
			return null;
		}

		public static Request<AssetFileDownloadCancelResult> DownloadCancel(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadCancelResult>(CAPI.ovr_AssetFile_DownloadCancel(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDownloadCancelResult> DownloadCancelById(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadCancelResult>(CAPI.ovr_AssetFile_DownloadCancelById(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDownloadCancelResult> DownloadCancelByName(string assetFileName)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadCancelResult>(CAPI.ovr_AssetFile_DownloadCancelByName(assetFileName));
			}
			return null;
		}

		public static Request<AssetDetailsList> GetList()
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetailsList>(CAPI.ovr_AssetFile_GetList());
			}
			return null;
		}

		public static Request<AssetDetails> Status(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetails>(CAPI.ovr_AssetFile_Status(assetFileID));
			}
			return null;
		}

		public static Request<AssetDetails> StatusById(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetails>(CAPI.ovr_AssetFile_StatusById(assetFileID));
			}
			return null;
		}

		public static Request<AssetDetails> StatusByName(string assetFileName)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetails>(CAPI.ovr_AssetFile_StatusByName(assetFileName));
			}
			return null;
		}

		public static void SetDownloadUpdateNotificationCallback(Message<AssetFileDownloadUpdate>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_AssetFile_DownloadUpdate, callback);
		}
	}
	public static class Avatar
	{
	}
	public static class Cal
	{
	}
	public static class CloudStorage
	{
		public static Request<CloudStorageUpdateResponse> Delete(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_Delete(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageData> Load(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageData>(CAPI.ovr_CloudStorage_Load(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageMetadataList> LoadBucketMetadata(string bucket)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageMetadataList>(CAPI.ovr_CloudStorage_LoadBucketMetadata(bucket));
			}
			return null;
		}

		public static Request<CloudStorageConflictMetadata> LoadConflictMetadata(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageConflictMetadata>(CAPI.ovr_CloudStorage_LoadConflictMetadata(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageData> LoadHandle(string handle)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageData>(CAPI.ovr_CloudStorage_LoadHandle(handle));
			}
			return null;
		}

		public static Request<CloudStorageMetadata> LoadMetadata(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageMetadata>(CAPI.ovr_CloudStorage_LoadMetadata(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageUpdateResponse> ResolveKeepLocal(string bucket, string key, string remoteHandle)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_ResolveKeepLocal(bucket, key, remoteHandle));
			}
			return null;
		}

		public static Request<CloudStorageUpdateResponse> ResolveKeepRemote(string bucket, string key, string remoteHandle)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_ResolveKeepRemote(bucket, key, remoteHandle));
			}
			return null;
		}

		public static Request<CloudStorageUpdateResponse> Save(string bucket, string key, byte[] data, long counter, string extraData)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_Save(bucket, key, data, (data != null) ? ((uint)data.Length) : 0u, counter, extraData));
			}
			return null;
		}

		public static Request<CloudStorageMetadataList> GetNextCloudStorageMetadataListPage(CloudStorageMetadataList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextCloudStorageMetadataListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageMetadataList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1544004335));
			}
			return null;
		}
	}
	public static class CloudStorage2
	{
	}
	public static class Entitlements
	{
		public static Request IsUserEntitledToApplication()
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Entitlement_GetIsViewerEntitled());
			}
			return null;
		}
	}
	public static class GraphAPI
	{
	}
	public static class HTTP
	{
	}
	public static class IAP
	{
		public static Request ConsumePurchase(string sku)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_IAP_ConsumePurchase(sku));
			}
			return null;
		}

		public static Request<ProductList> GetProductsBySKU(string[] skus)
		{
			if (Core.IsInitialized())
			{
				return new Request<ProductList>(CAPI.ovr_IAP_GetProductsBySKU(skus, (skus != null) ? skus.Length : 0));
			}
			return null;
		}

		public static Request<PurchaseList> GetViewerPurchases()
		{
			if (Core.IsInitialized())
			{
				return new Request<PurchaseList>(CAPI.ovr_IAP_GetViewerPurchases());
			}
			return null;
		}

		public static Request<Purchase> LaunchCheckoutFlow(string sku)
		{
			if (Core.IsInitialized())
			{
				if (UnityEngine.Application.isEditor)
				{
					throw new NotImplementedException("LaunchCheckoutFlow() is not implemented in the editor yet.");
				}
				return new Request<Purchase>(CAPI.ovr_IAP_LaunchCheckoutFlow(sku));
			}
			return null;
		}

		public static Request<ProductList> GetNextProductListPage(ProductList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextProductListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<ProductList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 467225263));
			}
			return null;
		}

		public static Request<PurchaseList> GetNextPurchaseListPage(PurchaseList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextPurchaseListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<PurchaseList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1196886677));
			}
			return null;
		}
	}
	public static class LanguagePack
	{
		public static Request<AssetDetails> GetCurrent()
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetails>(CAPI.ovr_LanguagePack_GetCurrent());
			}
			return null;
		}

		public static Request<AssetFileDownloadResult> SetCurrent(string tag)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadResult>(CAPI.ovr_LanguagePack_SetCurrent(tag));
			}
			return null;
		}
	}
	public static class Livestreaming
	{
		public static Request<LivestreamingStatus> GetStatus()
		{
			if (Core.IsInitialized())
			{
				return new Request<LivestreamingStatus>(CAPI.ovr_Livestreaming_GetStatus());
			}
			return null;
		}

		public static Request<LivestreamingStatus> PauseStream()
		{
			if (Core.IsInitialized())
			{
				return new Request<LivestreamingStatus>(CAPI.ovr_Livestreaming_PauseStream());
			}
			return null;
		}

		public static Request<LivestreamingStatus> ResumeStream()
		{
			if (Core.IsInitialized())
			{
				return new Request<LivestreamingStatus>(CAPI.ovr_Livestreaming_ResumeStream());
			}
			return null;
		}

		public static void SetStatusUpdateNotificationCallback(Message<LivestreamingStatus>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Livestreaming_StatusChange, callback);
		}
	}
	public static class Media
	{
		public static Request<ShareMediaResult> ShareToFacebook(string postTextSuggestion, string filePath, MediaContentType contentType)
		{
			if (Core.IsInitialized())
			{
				return new Request<ShareMediaResult>(CAPI.ovr_Media_ShareToFacebook(postTextSuggestion, filePath, contentType));
			}
			return null;
		}
	}
	public static class Notifications
	{
		public static Request<RoomInviteNotificationList> GetRoomInviteNotifications()
		{
			if (Core.IsInitialized())
			{
				return new Request<RoomInviteNotificationList>(CAPI.ovr_Notification_GetRoomInvites());
			}
			return null;
		}

		public static Request MarkAsRead(ulong notificationID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Notification_MarkAsRead(notificationID));
			}
			return null;
		}

		public static Request<RoomInviteNotificationList> GetNextRoomInviteNotificationListPage(RoomInviteNotificationList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextRoomInviteNotificationListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<RoomInviteNotificationList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 102890359));
			}
			return null;
		}
	}
	public static class Parties
	{
		public static Request<Party> GetCurrent()
		{
			if (Core.IsInitialized())
			{
				return new Request<Party>(CAPI.ovr_Party_GetCurrent());
			}
			return null;
		}
	}
	public static class Users
	{
		public static Request<User> Get(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<User>(CAPI.ovr_User_Get(userID));
			}
			return null;
		}

		public static Request<string> GetAccessToken()
		{
			if (Core.IsInitialized())
			{
				return new Request<string>(CAPI.ovr_User_GetAccessToken());
			}
			return null;
		}

		public static Request<User> GetLoggedInUser()
		{
			if (Core.IsInitialized())
			{
				return new Request<User>(CAPI.ovr_User_GetLoggedInUser());
			}
			return null;
		}

		public static Request<UserList> GetLoggedInUserFriends()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_User_GetLoggedInUserFriends());
			}
			return null;
		}

		public static Request<UserAndRoomList> GetLoggedInUserFriendsAndRooms()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserAndRoomList>(CAPI.ovr_User_GetLoggedInUserFriendsAndRooms());
			}
			return null;
		}

		public static Request<UserAndRoomList> GetLoggedInUserRecentlyMetUsersAndRooms(UserOptions userOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<UserAndRoomList>(CAPI.ovr_User_GetLoggedInUserRecentlyMetUsersAndRooms((IntPtr)userOptions));
			}
			return null;
		}

		public static Request<OrgScopedID> GetOrgScopedID(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<OrgScopedID>(CAPI.ovr_User_GetOrgScopedID(userID));
			}
			return null;
		}

		public static Request<SdkAccountList> GetSdkAccounts()
		{
			if (Core.IsInitialized())
			{
				return new Request<SdkAccountList>(CAPI.ovr_User_GetSdkAccounts());
			}
			return null;
		}

		public static Request<UserProof> GetUserProof()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserProof>(CAPI.ovr_User_GetUserProof());
			}
			return null;
		}

		public static Request<LaunchFriendRequestFlowResult> LaunchFriendRequestFlow(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<LaunchFriendRequestFlowResult>(CAPI.ovr_User_LaunchFriendRequestFlow(userID));
			}
			return null;
		}

		public static Request LaunchProfile(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_User_LaunchProfile(userID));
			}
			return null;
		}

		public static Request<UserAndRoomList> GetNextUserAndRoomListPage(UserAndRoomList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextUserAndRoomListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<UserAndRoomList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 2143146719));
			}
			return null;
		}

		public static Request<UserList> GetNextUserListPage(UserList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextUserListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 645723971));
			}
			return null;
		}
	}
	public enum PlatformInitializeResult
	{
		[Description("SUCCESS")]
		Success = 0,
		[Description("UNINITIALIZED")]
		Uninitialized = -1,
		[Description("PRE_LOADED")]
		PreLoaded = -2,
		[Description("FILE_INVALID")]
		FileInvalid = -3,
		[Description("SIGNATURE_INVALID")]
		SignatureInvalid = -4,
		[Description("UNABLE_TO_VERIFY")]
		UnableToVerify = -5,
		[Description("VERSION_MISMATCH")]
		VersionMismatch = -6,
		[Description("UNKNOWN")]
		Unknown = -7,
		[Description("INVALID_CREDENTIALS")]
		InvalidCredentials = -8,
		[Description("NOT_ENTITLED")]
		NotEntitled = -9
	}
	public static class PlatformInternal
	{
		public enum MessageTypeInternal : uint
		{
			Application_ExecuteCoordinatedLaunch = 645772532u,
			Application_GetInstalledApplications = 1376744524u,
			Avatar_UpdateMetaData = 2077219214u,
			Cal_FinalizeApplication = 497667029u,
			Cal_GetSuggestedApplications = 1450209301u,
			Cal_ProposeApplication = 1317270237u,
			CloudStorage2_GetUserDirectoryPath = 1990471406u,
			GraphAPI_Get = 822018158u,
			GraphAPI_Post = 1990567876u,
			HTTP_Get = 1874211363u,
			HTTP_GetToFile = 1317133401u,
			HTTP_MultiPartPost = 1480774160u,
			HTTP_Post = 1798743375u,
			Livestreaming_IsAllowedForApplication = 191729014u,
			Livestreaming_StartPartyStream = 2066701532u,
			Livestreaming_StartStream = 1343932350u,
			Livestreaming_StopPartyStream = 661065560u,
			Livestreaming_StopStream = 1155796426u,
			Livestreaming_UpdateCommentsOverlayVisibility = 528318516u,
			Livestreaming_UpdateMicStatus = 475495815u,
			Party_Create = 450042703u,
			Party_GatherInApplication = 1921499523u,
			Party_Get = 1586058173u,
			Party_GetCurrentForUser = 1489764138u,
			Party_Invite = 901104867u,
			Party_Join = 1744993395u,
			Party_Leave = 848430801u,
			Room_CreateOrUpdateAndJoinNamed = 2089683601u,
			Room_GetNamedRooms = 125660812u,
			Room_GetSocialRooms = 1636310390u,
			SystemPermissions_GetStatus = 493497353u,
			SystemPermissions_LaunchDeeplink = 442139697u,
			User_CancelRecordingForReportFlow = 65065289u,
			User_GetLinkedAccounts = 1469314134u,
			User_LaunchBlockFlow = 1876305192u,
			User_LaunchReportFlow = 1449304081u,
			User_LaunchReportFlow2 = 2139314275u,
			User_LaunchUnblockFlow = 346172055u,
			User_NewEntitledTestUser = 292822787u,
			User_NewTestUser = 921194380u,
			User_NewTestUserFriends = 517416647u,
			User_StartRecordingForReportFlow = 1819161571u,
			User_StopRecordingAndLaunchReportFlow = 1618513035u,
			User_StopRecordingAndLaunchReportFlow2 = 432190251u,
			User_TestUserCreateDeviceManifest = 1701884605u
		}

		public static class HTTP
		{
			public static void SetHttpTransferUpdateCallback(Message<HttpTransferUpdate>.Callback callback)
			{
				Callback.SetNotificationCallback(Message.MessageType.Notification_HTTP_Transfer, callback);
			}
		}

		public static void CrashApplication()
		{
			CAPI.ovr_CrashApplication();
		}

		internal static Message ParseMessageHandle(IntPtr messageHandle, Message.MessageType messageType)
		{
			Message result = null;
			switch ((MessageTypeInternal)messageType)
			{
			case MessageTypeInternal.User_StartRecordingForReportFlow:
				result = new MessageWithAbuseReportRecording(messageHandle);
				break;
			case MessageTypeInternal.Cal_FinalizeApplication:
				result = new MessageWithCalApplicationFinalized(messageHandle);
				break;
			case MessageTypeInternal.Cal_GetSuggestedApplications:
				result = new MessageWithCalApplicationSuggestionList(messageHandle);
				break;
			case MessageTypeInternal.User_CancelRecordingForReportFlow:
			case MessageTypeInternal.Livestreaming_UpdateMicStatus:
			case MessageTypeInternal.Application_ExecuteCoordinatedLaunch:
			case MessageTypeInternal.Livestreaming_StopPartyStream:
			case MessageTypeInternal.Party_Leave:
			case MessageTypeInternal.Cal_ProposeApplication:
			case MessageTypeInternal.User_TestUserCreateDeviceManifest:
				result = new Message(messageHandle);
				break;
			case MessageTypeInternal.Application_GetInstalledApplications:
				result = new MessageWithInstalledApplicationList(messageHandle);
				break;
			case MessageTypeInternal.User_LaunchBlockFlow:
				result = new MessageWithLaunchBlockFlowResult(messageHandle);
				break;
			case MessageTypeInternal.User_LaunchReportFlow2:
				result = new MessageWithLaunchReportFlowResult(messageHandle);
				break;
			case MessageTypeInternal.User_LaunchUnblockFlow:
				result = new MessageWithLaunchUnblockFlowResult(messageHandle);
				break;
			case MessageTypeInternal.User_GetLinkedAccounts:
				result = new MessageWithLinkedAccountList(messageHandle);
				break;
			case MessageTypeInternal.Livestreaming_IsAllowedForApplication:
				result = new MessageWithLivestreamingApplicationStatus(messageHandle);
				break;
			case MessageTypeInternal.Livestreaming_StartStream:
			case MessageTypeInternal.Livestreaming_StartPartyStream:
				result = new MessageWithLivestreamingStartResult(messageHandle);
				break;
			case MessageTypeInternal.Livestreaming_UpdateCommentsOverlayVisibility:
				result = new MessageWithLivestreamingStatus(messageHandle);
				break;
			case MessageTypeInternal.Livestreaming_StopStream:
				result = new MessageWithLivestreamingVideoStats(messageHandle);
				break;
			case MessageTypeInternal.Party_Get:
				result = new MessageWithParty(messageHandle);
				break;
			case MessageTypeInternal.Party_GetCurrentForUser:
				result = new MessageWithPartyUnderCurrentParty(messageHandle);
				break;
			case MessageTypeInternal.Party_Create:
			case MessageTypeInternal.Party_Invite:
			case MessageTypeInternal.Party_Join:
			case MessageTypeInternal.Party_GatherInApplication:
				result = new MessageWithPartyID(messageHandle);
				break;
			case MessageTypeInternal.Room_CreateOrUpdateAndJoinNamed:
				result = new MessageWithRoomUnderViewerRoom(messageHandle);
				break;
			case MessageTypeInternal.Room_GetNamedRooms:
			case MessageTypeInternal.Room_GetSocialRooms:
				result = new MessageWithRoomList(messageHandle);
				break;
			case MessageTypeInternal.User_NewEntitledTestUser:
			case MessageTypeInternal.User_NewTestUserFriends:
			case MessageTypeInternal.GraphAPI_Get:
			case MessageTypeInternal.User_NewTestUser:
			case MessageTypeInternal.HTTP_GetToFile:
			case MessageTypeInternal.HTTP_MultiPartPost:
			case MessageTypeInternal.HTTP_Post:
			case MessageTypeInternal.HTTP_Get:
			case MessageTypeInternal.CloudStorage2_GetUserDirectoryPath:
			case MessageTypeInternal.GraphAPI_Post:
			case MessageTypeInternal.Avatar_UpdateMetaData:
				result = new MessageWithString(messageHandle);
				break;
			case MessageTypeInternal.SystemPermissions_LaunchDeeplink:
			case MessageTypeInternal.SystemPermissions_GetStatus:
				result = new MessageWithSystemPermission(messageHandle);
				break;
			case MessageTypeInternal.User_StopRecordingAndLaunchReportFlow2:
			case MessageTypeInternal.User_LaunchReportFlow:
			case MessageTypeInternal.User_StopRecordingAndLaunchReportFlow:
				result = new MessageWithUserReportID(messageHandle);
				break;
			}
			return result;
		}
	}
	public sealed class PlatformSettings : ScriptableObject
	{
		[SerializeField]
		private string ovrAppID = string.Empty;

		[SerializeField]
		private string ovrMobileAppID = string.Empty;

		[SerializeField]
		private bool ovrUseStandalonePlatform = true;

		[SerializeField]
		private bool ovrEnableARM64Support;

		private static PlatformSettings instance;

		public static string AppID
		{
			get
			{
				return Instance.ovrAppID;
			}
			set
			{
				Instance.ovrAppID = value;
			}
		}

		public static string MobileAppID
		{
			get
			{
				return Instance.ovrMobileAppID;
			}
			set
			{
				Instance.ovrMobileAppID = value;
			}
		}

		public static bool UseStandalonePlatform
		{
			get
			{
				return Instance.ovrUseStandalonePlatform;
			}
			set
			{
				Instance.ovrUseStandalonePlatform = value;
			}
		}

		public static bool EnableARM64Support
		{
			get
			{
				return Instance.ovrEnableARM64Support;
			}
			set
			{
				Instance.ovrEnableARM64Support = value;
			}
		}

		public static PlatformSettings Instance
		{
			get
			{
				if (instance == null)
				{
					instance = Resources.Load<PlatformSettings>("OculusPlatformSettings");
					if (instance == null)
					{
						instance = ScriptableObject.CreateInstance<PlatformSettings>();
					}
				}
				return instance;
			}
			set
			{
				instance = value;
			}
		}
	}
	public sealed class Request<T> : Request
	{
		public Request(ulong requestID)
			: base(requestID)
		{
		}

		public Request<T> OnComplete(Message<T>.Callback callback)
		{
			Callback.OnComplete(this, callback);
			return this;
		}
	}
	public class Request
	{
		public ulong RequestID { get; set; }

		public Request(ulong requestID)
		{
			RequestID = requestID;
		}

		public Request OnComplete(Message.Callback callback)
		{
			Callback.OnComplete(this, callback);
			return this;
		}

		public static void RunCallbacks(uint limit = 0u)
		{
			if (limit == 0)
			{
				Callback.RunCallbacks();
			}
			else
			{
				Callback.RunLimitedCallbacks(limit);
			}
		}
	}
	public enum RoomJoinability
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ARE_IN")]
		AreIn,
		[Description("ARE_KICKED")]
		AreKicked,
		[Description("CAN_JOIN")]
		CanJoin,
		[Description("IS_FULL")]
		IsFull,
		[Description("NO_VIEWER")]
		NoViewer,
		[Description("POLICY_PREVENTS")]
		PolicyPrevents
	}
	public enum RoomJoinPolicy
	{
		[Description("NONE")]
		None,
		[Description("EVERYONE")]
		Everyone,
		[Description("FRIENDS_OF_MEMBERS")]
		FriendsOfMembers,
		[Description("FRIENDS_OF_OWNER")]
		FriendsOfOwner,
		[Description("INVITED_USERS")]
		InvitedUsers,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum RoomMembershipLockStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("LOCK")]
		Lock,
		[Description("UNLOCK")]
		Unlock
	}
	public class RoomOptions
	{
		private IntPtr Handle;

		public RoomOptions()
		{
			Handle = CAPI.ovr_RoomOptions_Create();
		}

		public void SetDataStore(string key, string value)
		{
			CAPI.ovr_RoomOptions_SetDataStoreString(Handle, key, value);
		}

		public void ClearDataStore()
		{
			CAPI.ovr_RoomOptions_ClearDataStore(Handle);
		}

		public void SetExcludeRecentlyMet(bool value)
		{
			CAPI.ovr_RoomOptions_SetExcludeRecentlyMet(Handle, value);
		}

		public void SetMaxUserResults(uint value)
		{
			CAPI.ovr_RoomOptions_SetMaxUserResults(Handle, value);
		}

		public void SetOrdering(UserOrdering value)
		{
			CAPI.ovr_RoomOptions_SetOrdering(Handle, value);
		}

		public void SetRecentlyMetTimeWindow(TimeWindow value)
		{
			CAPI.ovr_RoomOptions_SetRecentlyMetTimeWindow(Handle, value);
		}

		public void SetRoomId(ulong value)
		{
			CAPI.ovr_RoomOptions_SetRoomId(Handle, value);
		}

		public void SetTurnOffUpdates(bool value)
		{
			CAPI.ovr_RoomOptions_SetTurnOffUpdates(Handle, value);
		}

		public static explicit operator IntPtr(RoomOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~RoomOptions()
		{
			CAPI.ovr_RoomOptions_Destroy(Handle);
		}
	}
	public enum RoomType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MATCHMAKING")]
		Matchmaking,
		[Description("MODERATED")]
		Moderated,
		[Description("PRIVATE")]
		Private,
		[Description("SOLO")]
		Solo
	}
	public enum SdkAccountType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("OCULUS")]
		Oculus,
		[Description("FACEBOOK_GAMEROOM")]
		FacebookGameroom
	}
	public enum SendPolicy
	{
		[Description("UNRELIABLE")]
		Unreliable,
		[Description("RELIABLE")]
		Reliable,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum ServiceProvider
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("DROPBOX")]
		Dropbox,
		[Description("FACEBOOK")]
		Facebook,
		[Description("GOOGLE")]
		Google,
		[Description("INSTAGRAM")]
		Instagram,
		[Description("REMOTE_MEDIA")]
		RemoteMedia
	}
	public enum ShareMediaStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SHARED")]
		Shared,
		[Description("CANCELED")]
		Canceled
	}
	public sealed class StandalonePlatform
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void UnityLogDelegate(IntPtr tag, IntPtr msg);

		public Request<PlatformInitialize> InitializeInEditor()
		{
			if (string.IsNullOrEmpty(PlatformSettings.MobileAppID))
			{
				throw new UnityException("Update your App ID by selecting 'Oculus Platform' -> 'Edit Settings'");
			}
			string mobileAppID = PlatformSettings.MobileAppID;
			if (string.IsNullOrEmpty(StandalonePlatformSettings.OculusPlatformTestUserAccessToken))
			{
				throw new UnityException("Update your standalone credentials by selecting 'Oculus Platform' -> 'Edit Settings'");
			}
			string oculusPlatformTestUserAccessToken = StandalonePlatformSettings.OculusPlatformTestUserAccessToken;
			CAPI.ovr_UnityResetTestPlatform();
			CAPI.ovr_UnityInitGlobals(IntPtr.Zero);
			return new Request<PlatformInitialize>(CAPI.ovr_PlatformInitializeWithAccessToken(ulong.Parse(mobileAppID), oculusPlatformTestUserAccessToken));
		}
	}
	public sealed class StandalonePlatformSettings
	{
		public static string OculusPlatformTestUserEmail
		{
			get
			{
				return string.Empty;
			}
			set
			{
			}
		}

		public static string OculusPlatformTestUserPassword
		{
			get
			{
				return string.Empty;
			}
			set
			{
			}
		}

		public static string OculusPlatformTestUserAccessToken
		{
			get
			{
				return string.Empty;
			}
			set
			{
			}
		}
	}
	public enum SystemVoipStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("UNAVAILABLE")]
		Unavailable,
		[Description("SUPPRESSED")]
		Suppressed,
		[Description("ACTIVE")]
		Active
	}
	public enum TimeWindow
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ONE_HOUR")]
		OneHour,
		[Description("ONE_DAY")]
		OneDay,
		[Description("ONE_WEEK")]
		OneWeek,
		[Description("THIRTY_DAYS")]
		ThirtyDays,
		[Description("NINETY_DAYS")]
		NinetyDays
	}
	public class UserOptions
	{
		private IntPtr Handle;

		public UserOptions()
		{
			Handle = CAPI.ovr_UserOptions_Create();
		}

		public void SetMaxUsers(uint value)
		{
			CAPI.ovr_UserOptions_SetMaxUsers(Handle, value);
		}

		public void AddServiceProvider(ServiceProvider value)
		{
			CAPI.ovr_UserOptions_AddServiceProvider(Handle, value);
		}

		public void ClearServiceProviders()
		{
			CAPI.ovr_UserOptions_ClearServiceProviders(Handle);
		}

		public void SetTimeWindow(TimeWindow value)
		{
			CAPI.ovr_UserOptions_SetTimeWindow(Handle, value);
		}

		public static explicit operator IntPtr(UserOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~UserOptions()
		{
			CAPI.ovr_UserOptions_Destroy(Handle);
		}
	}
	public enum UserOrdering
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("NONE")]
		None,
		[Description("PRESENCE_ALPHABETICAL")]
		PresenceAlphabetical
	}
	public enum UserPresenceStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ONLINE")]
		Online,
		[Description("OFFLINE")]
		Offline
	}
	public class VoipAudioSourceHiLevel : MonoBehaviour
	{
		public class FilterReadDelegate : MonoBehaviour
		{
			public VoipAudioSourceHiLevel parent;

			private float[] scratchBuffer;

			private void Awake()
			{
				int num = (int)(uint)CAPI.ovr_Voip_GetOutputBufferMaxSize();
				scratchBuffer = new float[num];
			}

			private void OnAudioFilterRead(float[] data, int channels)
			{
				int num = data.Length / channels;
				int num2 = num;
				if (num2 > scratchBuffer.Length)
				{
					Array.Clear(data, 0, data.Length);
					throw new Exception($"Audio system tried to pull {num} bytes, max voip internal ring buffer size {scratchBuffer.Length}");
				}
				int num3 = parent.pcmSource.PeekSizeElements();
				if (num3 < num2)
				{
					if (verboseLogging)
					{
						UnityEngine.Debug.LogFormat("Voip starved! Want {0}, but only have {1} available", num2, num3);
					}
					return;
				}
				int pCM = parent.pcmSource.GetPCM(scratchBuffer, num2);
				if (pCM < num2)
				{
					UnityEngine.Debug.LogWarningFormat("GetPCM() returned {0} samples, expected {1}", pCM, num2);
					return;
				}
				int num4 = 0;
				float num5 = -1f;
				for (int i = 0; i < num; i++)
				{
					float num6 = scratchBuffer[i];
					for (int j = 0; j < channels; j++)
					{
						data[num4++] = num6;
						if (num6 > num5)
						{
							num5 = num6;
						}
					}
				}
				parent.peakAmplitude = num5;
			}
		}

		private int initialPlaybackDelayMS;

		public AudioSource audioSource;

		public float peakAmplitude;

		protected IVoipPCMSource pcmSource;

		private static int audioSystemPlaybackFrequency;

		private static bool verboseLogging;

		public ulong senderID
		{
			set
			{
				pcmSource.SetSenderID(value);
			}
		}

		protected void Stop()
		{
		}

		private VoipSampleRate SampleRateToEnum(int rate)
		{
			return rate switch
			{
				48000 => VoipSampleRate.HZ48000, 
				44100 => VoipSampleRate.HZ44100, 
				24000 => VoipSampleRate.HZ24000, 
				_ => VoipSampleRate.Unknown, 
			};
		}

		protected void Awake()
		{
			CreatePCMSource();
			if (audioSource == null)
			{
				audioSource = base.gameObject.AddComponent<AudioSource>();
			}
			audioSource.gameObject.AddComponent<FilterReadDelegate>();
			FilterReadDelegate component = audioSource.gameObject.GetComponent<FilterReadDelegate>();
			component.parent = this;
			initialPlaybackDelayMS = 40;
			audioSystemPlaybackFrequency = AudioSettings.outputSampleRate;
			CAPI.ovr_Voip_SetOutputSampleRate(SampleRateToEnum(audioSystemPlaybackFrequency));
			if (verboseLogging)
			{
				UnityEngine.Debug.LogFormat("freq {0}", audioSystemPlaybackFrequency);
			}
		}

		private void Start()
		{
			audioSource.Stop();
		}

		protected virtual void CreatePCMSource()
		{
			pcmSource = new VoipPCMSourceNative();
		}

		protected static int MSToElements(int ms)
		{
			return ms * audioSystemPlaybackFrequency / 1000;
		}

		private void Update()
		{
			pcmSource.Update();
			if (!audioSource.isPlaying && pcmSource.PeekSizeElements() >= MSToElements(initialPlaybackDelayMS))
			{
				if (verboseLogging)
				{
					UnityEngine.Debug.LogFormat("buffered {0} elements, starting playback", pcmSource.PeekSizeElements());
				}
				audioSource.Play();
			}
		}
	}
	public enum VoipBitrate
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("B16000")]
		B16000,
		[Description("B24000")]
		B24000,
		[Description("B32000")]
		B32000,
		[Description("B64000")]
		B64000,
		[Description("B96000")]
		B96000,
		[Description("B128000")]
		B128000
	}
	public enum VoipDtxState
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ENABLED")]
		Enabled,
		[Description("DISABLED")]
		Disabled
	}
	public enum VoipMuteState
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MUTED")]
		Muted,
		[Description("UNMUTED")]
		Unmuted
	}
	public class VoipOptions
	{
		private IntPtr Handle;

		public VoipOptions()
		{
			Handle = CAPI.ovr_VoipOptions_Create();
		}

		public void SetBitrateForNewConnections(VoipBitrate value)
		{
			CAPI.ovr_VoipOptions_SetBitrateForNewConnections(Handle, value);
		}

		public void SetCreateNewConnectionUseDtx(VoipDtxState value)
		{
			CAPI.ovr_VoipOptions_SetCreateNewConnectionUseDtx(Handle, value);
		}

		public static explicit operator IntPtr(VoipOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~VoipOptions()
		{
			CAPI.ovr_VoipOptions_Destroy(Handle);
		}
	}
	public class VoipPCMSourceNative : IVoipPCMSource
	{
		private ulong senderID;

		public int GetPCM(float[] dest, int length)
		{
			return (int)(uint)CAPI.ovr_Voip_GetPCMFloat(senderID, dest, (UIntPtr)(ulong)length);
		}

		public void SetSenderID(ulong senderID)
		{
			this.senderID = senderID;
		}

		public int PeekSizeElements()
		{
			return (int)(uint)CAPI.ovr_Voip_GetPCMSize(senderID);
		}

		public void Update()
		{
		}
	}
	public enum VoipSampleRate
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("HZ24000")]
		HZ24000,
		[Description("HZ44100")]
		HZ44100,
		[Description("HZ48000")]
		HZ48000
	}
	public class WindowsPlatform
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void UnityLogDelegate(IntPtr tag, IntPtr msg);

		private void CPPLogCallback(IntPtr tag, IntPtr message)
		{
			UnityEngine.Debug.Log($"{Marshal.PtrToStringAnsi(tag)}: {Marshal.PtrToStringAnsi(message)}");
		}

		private IntPtr getCallbackPointer()
		{
			return IntPtr.Zero;
		}

		public bool Initialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			CAPI.ovr_UnityInitWrapperWindows(appId, getCallbackPointer());
			return true;
		}

		public Request<PlatformInitialize> AsyncInitialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			return new Request<PlatformInitialize>(CAPI.ovr_UnityInitWrapperWindowsAsynchronous(appId, getCallbackPointer()));
		}
	}
}
public class ParticleEffectHandler : MonoBehaviour
{
	private ParticleSystem.EmissionModule emitter;

	private string activeSceneName;

	[@Dependency]
	public FishODexEvent FishODexSignal { get; set; }

	private void Start()
	{
		this.Inject();
		activeSceneName = SceneManager.GetActiveScene().name;
		emitter = GetComponent<ParticleSystem>().emission;
		FishODexSpawner.FishODexSpawnSignal.AddListener(OnFishOdexSpawned);
		FishODexSignal.AddListener(OnFishOdexClosed);
		CatchDisplay.CatchDisplaySignal.AddListener(OnCatchDisplayEvent);
	}

	private void activateParticles(bool active)
	{
		if (activeSceneName == "SurfShop01")
		{
			emitter.enabled = active;
		}
		else
		{
			base.gameObject.SetActive(active);
		}
	}

	private void OnFishOdexSpawned(FishODexSpawnContent content, bool wasBackButton)
	{
		if (content == FishODexSpawnContent.Map)
		{
			activateParticles(active: false);
		}
	}

	private void OnFishOdexClosed(FishODexEventType type, Transform t)
	{
		if (type == FishODexEventType.Close)
		{
			activateParticles(active: true);
		}
	}

	private void OnCatchDisplayEvent(CatchDisplayEventType type)
	{
		switch (type)
		{
		case CatchDisplayEventType.Show:
			if (activeSceneName == "Swamp_01")
			{
				activateParticles(active: false);
			}
			break;
		case CatchDisplayEventType.Hide:
			if (activeSceneName == "Swamp_01")
			{
				activateParticles(active: true);
			}
			break;
		}
	}

	private void OnDestroy()
	{
		FishODexSpawner.FishODexSpawnSignal.RemoveListener(OnFishOdexSpawned);
		FishODexSignal.RemoveListener(OnFishOdexClosed);
		CatchDisplay.CatchDisplaySignal.RemoveListener(OnCatchDisplayEvent);
	}
}
[RequireComponent(typeof(BoxCollider))]
public class DebugSetReel : GazeButton
{
	public ReelType reel;

	[@Dependency]
	public InventoryManager InventoryManager { get; set; }

	private void Awake()
	{
		this.Inject();
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		InventoryManager.Inventory.Reel = reel;
		Vector3 localScale = base.transform.localScale;
		LeanTween.scale(base.gameObject, localScale * 0.8f, 0.5f);
		LeanTween.scale(base.gameObject, localScale, 0.5f).setDelay(0.5f);
		return PostSelectAction.Restart;
	}
}
[RequireComponent(typeof(BoxCollider))]
public class DebugSetRod : GazeButton
{
	public RodType rod;

	[@Dependency]
	public InventoryManager InventoryManager { get; set; }

	private void Awake()
	{
		this.Inject();
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		InventoryManager.Inventory.Rod = rod;
		Vector3 localScale = base.transform.localScale;
		LeanTween.scale(base.gameObject, localScale * 0.8f, 0.5f);
		LeanTween.scale(base.gameObject, localScale, 0.5f).setDelay(0.5f);
		return PostSelectAction.Restart;
	}
}
[RequireComponent(typeof(BoxCollider))]
public class DebugToggler : GazeButton
{
	public GameObject ObjectToToggle;

	public override PostSelectAction OnSelect(GameObject obj)
	{
		ObjectToToggle.SetActive(!ObjectToToggle.activeSelf);
		return PostSelectAction.Restart;
	}
}
public class DestroyIfReleaseBuild : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
[RequireComponent(typeof(BoxCollider))]
public class LaunchMissile : GazeButton
{
	private bool isActivated;

	[SerializeField]
	private ParticleSystem missileSmoke;

	private void Awake()
	{
		this.Inject();
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		if (!isActivated)
		{
			missileSmoke.Play();
			base.transform.LeanMoveLocalY(3000f, 120f);
			isActivated = true;
		}
		return PostSelectAction.Restart;
	}
}
public class RGDebug
{
	[Conditional("UNITY_EDITOR")]
	public static void Log(string s)
	{
		UnityEngine.Debug.Log(s);
	}
}
[RequireComponent(typeof(RectTransform))]
[ExecuteInEditMode]
public class GlitchyScreenGradientMask : MonoBehaviour
{
	public Material materialToUpdate;

	[Range(0f, 1f)]
	public float gradientWidth = 0.1f;

	[Tooltip("Move the gradient inwards by this amount")]
	public float offset;

	private Vector3[] corners = new Vector3[4];

	private float clipLeft = float.NegativeInfinity;

	private float clipRight = float.PositiveInfinity;

	private float setGradientWidth = float.PositiveInfinity;

	private void Start()
	{
		UpdateMaterial();
	}

	private void Update()
	{
		if (materialToUpdate != null)
		{
			GetEdges(out var left, out var right);
			if (gradientWidth != setGradientWidth || left != clipLeft || right != clipRight)
			{
				UpdateMaterial();
			}
		}
	}

	private void UpdateMaterial()
	{
		Material material = materialToUpdate;
		material.EnableKeyword("HORIZONTAL_CLIP");
		GetEdges(out var left, out var right);
		SetClipBoundaries(left, right);
		material.SetFloat("_ClipGradient", (right - left) / 2f * gradientWidth);
		setGradientWidth = gradientWidth;
	}

	private void SetClipBoundaries(float left, float right)
	{
		Material material = materialToUpdate;
		material.SetFloat("_LeftClip", left);
		material.SetFloat("_RightClip", right);
		clipLeft = left;
		clipRight = right;
	}

	private void GetEdges(out float left, out float right)
	{
		RectTransform rectTransform = Find.ComponentOnGameObject<RectTransform>(this);
		rectTransform.GetWorldCorners(corners);
		float num = corners[3].x - corners[0].x;
		left = corners[0].x + offset * num;
		right = corners[3].x - offset * num;
	}
}
[RequireComponent(typeof(Text))]
public class TypewriterText : MonoBehaviour
{
	public float charactersPerSecond = 50f;

	public Signal finishedSignal = new Signal();

	private string prefix = string.Empty;

	private string text = string.Empty;

	private bool isAnimating;

	private float startTime;

	private int previousLength;

	private Text textComponent;

	[@Dependency]
	private Localization localization { get; set; }

	public bool IsAnimating => isAnimating;

	private void Awake()
	{
		this.Inject();
		textComponent = GetComponent<Text>();
	}

	private void Start()
	{
		textComponent.font = localization.GetLanguageFont();
		textComponent.resizeTextMaxSize = (int)((float)textComponent.resizeTextMaxSize * localization.GetLanguageFontSizeMultiplier());
		textComponent.fontSize = (int)((float)textComponent.fontSize * localization.GetLanguageFontSizeMultiplier());
		textComponent.resizeTextMinSize = (int)((float)textComponent.resizeTextMinSize * localization.GetLanguageFontSizeMultiplier());
	}

	public void ShowText(string text, string prefix = "", float startDelay = 0f)
	{
		this.text = text;
		this.prefix = prefix;
		startTime = Time.time + startDelay;
		previousLength = -1;
		SetText(0);
		isAnimating = true;
		textComponent.resizeTextForBestFit = true;
		RectTransform rectTransform = Find.ComponentOnGameObject<RectTransform>(this);
		TextGenerator textGenerator = new TextGenerator();
		textGenerator.Populate(prefix + text, textComponent.GetGenerationSettings(rectTransform.sizeDelta));
		textComponent.resizeTextForBestFit = false;
		textComponent.fontSize = textGenerator.fontSizeUsedForBestFit;
		if (localization.CurrentLanguangId != "ja")
		{
			UILineInfo[] linesArray = textGenerator.GetLinesArray();
			if (linesArray.Length <= 1)
			{
				return;
			}
			for (int num = linesArray.Length - 1; num > 0; num--)
			{
				int num2 = linesArray[num].startCharIdx - prefix.Length;
				if (num2 <= 0 || !(this.text.Substring(num2 - 1, 1) == "\n"))
				{
					this.text = this.text.Insert(num2, "\n");
				}
			}
		}
		else
		{
			this.text = this.text.Replace("? ", "");
			this.text = this.text.Replace("! ", "");
			this.text = this.text.Replace(". ", "");
		}
	}

	public void Finish()
	{
		SetText(text.Length);
		isAnimating = false;
		finishedSignal.Dispatch();
	}

	private void Update()
	{
		if (isAnimating)
		{
			int num = (int)((Time.time - startTime) * charactersPerSecond);
			if (num < 0)
			{
				num = 0;
			}
			if (num < text.Length)
			{
				SetText(num);
			}
			else
			{
				Finish();
			}
		}
	}

	private void SetText(int length)
	{
		if (previousLength != length)
		{
			textComponent.text = prefix + text.Substring(0, length);
			previousLength = length;
		}
	}
}
public class AggregationOfFish : MonoBehaviour
{
	[Tooltip("The fish are added as children of this object")]
	public GameObject fishRoot;

	public GameObject debugPrefab;

	public FlatPolygon swimBoundaries;

	public FlatPolygon escapeArea;

	private int numberOfFishesInScene = 10;

	private List<FishType> spawnList;

	private List<FishBehavior> activeFish;

	private FishBehavior caughtFish;

	private const string folderName = "Fish";

	private bool inMenu;

	[@Dependency]
	public Quest Quest { get; set; }

	[@Dependency]
	public FishingRodEvent FishingRodSignal { get; set; }

	[@Dependency]
	public InventoryManager InventoryManager { get; set; }

	[@Dependency]
	public FishParser FishParser { get; set; }

	[@Dependency]
	public RGTracking tracking { get; set; }

	[@Dependency]
	public UIDisplayEvent UIDisplaySignal { get; set; }

	[@Dependency]
	public FishODexEvent FishODexSignal { get; set; }

	public IList<FishBehavior> Fishes => activeFish.AsReadOnly();

	private void Start()
	{
		this.Inject();
		FishingRodSignal.AddListener(OnFishingRodSignal);
		TensionMeter.TensionMeterSignal.AddListener(OnTensionMeterSignal);
		spawnList = new List<FishType>();
		activeFish = new List<FishBehavior>();
		SinkerCasting.CatchFishSignal.AddListener(OnCatchFishSignal);
		Quest.EnterQuestStateSignal.AddListener(OnEnterQuestState);
		InventoryGUI.equipBaitNotification.AddListener(OnEquipBait);
		ParseSpawnInfo();
		FishODexSpawner.FishODexSpawnSignal.AddListener(OnSpawnFishODex);
		FishODexSignal.AddListener(OnCloseFishOdex);
	}

	private void Update()
	{
		if (activeFish.Count < numberOfFishesInScene && !inMenu)
		{
			SpawnNewFish();
		}
		if (activeFish.Count != 0)
		{
			for (int i = 0; i < activeFish.Count; i++)
			{
				FishBehavior fishBehavior = activeFish[i];
				fishBehavior.Update();
			}
			if (caughtFish != null)
			{
				caughtFish.Update();
			}
		}
	}

	private void FixedUpdate()
	{
		for (int i = 0; i < activeFish.Count; i++)
		{
			FishBehavior fishBehavior = activeFish[i];
			fishBehavior.FixedUpdate();
		}
	}

	private void OnEquipBait(BaitType baitType)
	{
		RespawnFish();
	}

	private void OnEnterQuestState(QuestState questState)
	{
		RespawnFish();
	}

	private void RespawnFish()
	{
		ClearAllFish();
		ParseSpawnInfo();
	}

	private void ParseSpawnInfo()
	{
		CSVTable fishBySceneName = FishParser.GetFishBySceneName(SceneManager.GetActiveScene().name);
		string header = ((!fishBySceneName.HasHeader(Quest.CurrentState.Id)) ? "Default" : Quest.CurrentState.Id);
		numberOfFishesInScene = fishBySceneName.GetRow(0).GetColumnInt(header);
		for (int i = 1; i < fishBySceneName.NumRows; i++)
		{
			CSVTable.Row row = fishBySceneName.GetRow(i);
			FishType enumByName = EnumHelper.GetEnumByName<FishType>(row.GetColumn(0));
			int num = row.GetColumnInt(header);
			if (FishRegistry.Instance.GetFishDatabyType(enumByName).fishRarity == FishRarity.Rare || IsQuestFish(enumByName))
			{
				GameObject baitByType = GearRegistry.Instance.GetBaitByType(InventoryManager.Inventory.CurrentBait);
				float rareFishMultiplier = baitByType.GetComponent<Bait>().rareFishMultiplier;
				num = (int)((float)num * rareFishMultiplier);
			}
			for (int j = 0; j < num; j++)
			{
				spawnList.Add(enumByName);
			}
		}
	}

	private bool IsQuestFish(FishType fishType)
	{
		if (!(Quest.CurrentState.Condition is FishCondition))
		{
			return false;
		}
		FishCondition fishCondition = (FishCondition)Quest.CurrentState.Condition;
		if (fishCondition.FishType == fishType)
		{
			return true;
		}
		return false;
	}

	private void OnCatchFishSignal(Fish fish, GameObject fishGO)
	{
		if (fish != null)
		{
			int fishIndex = GetFishIndex(fish);
			if (fish.gameObject.activeSelf)
			{
				caughtFish = activeFish[fishIndex];
				CatchDisplay.CatchDisplaySignal.AddListener(OnCatchDisplayClose);
			}
			activeFish.RemoveAt(fishIndex);
		}
	}

	private void OnCatchDisplayClose(CatchDisplayEventType type)
	{
		if (type == CatchDisplayEventType.Hide)
		{
			caughtFish = null;
			CatchDisplay.CatchDisplaySignal.RemoveListener(OnCatchDisplayClose);
		}
	}

	private int GetFishIndex(Fish fish)
	{
		for (int i = 0; i < activeFish.Count; i++)
		{
			if (activeFish[i].fish == fish)
			{
				return i;
			}
		}
		return -1;
	}

	private void SpawnNewFish()
	{
		if (spawnList.Count >= 1)
		{
			int index = UnityEngine.Random.Range(0, spawnList.Count);
			FishType fishType = spawnList[index];
			Vector2 randomPoint = swimBoundaries.GetRandomPoint();
			Vector3 spawnPoint = new Vector3(randomPoint.x, 0f, randomPoint.y);
			FishBehavior fishBehavior = SpawnFish(fishType, spawnPoint);
			fishBehavior.StartInNormalMode();
		}
	}

	public FishBehavior SpawnFish(FishType fishType, Vector3 spawnPoint)
	{
		GameObject fishPrefab = FishRegistry.Instance.GetFishPrefab(fishType);
		FishData fishDatabyType = FishRegistry.Instance.GetFishDatabyType(fishType);
		spawnPoint.y = fishDatabyType.swimDepth;
		GameObject gameObject = UnityEngine.Object.Instantiate(fishPrefab, spawnPoint, Quaternion.identity);
		Fish component = gameObject.GetComponent<Fish>();
		component.FishData = fishDatabyType;
		gameObject.transform.parent = fishRoot.transform;
		gameObject.transform.Rotate(Vector3.up, UnityEngine.Random.Range(0f, 360f));
		FishBehavior fishBehavior = new FishBehavior(component, swimBoundaries, escapeArea);
		fishBehavior.SpawnPoint = spawnPoint;
		fishBehavior.tracking = tracking;
		if (debugPrefab != null)
		{
			GameObject gameObject2 = UnityEngine.Object.Instantiate(debugPrefab, gameObject.transform.position + Vector3.up * 0.3f, Quaternion.identity);
			gameObject2.transform.parent = gameObject.transform;
			gameObject2.GetComponent<FishDebug>().behavior = fishBehavior;
		}
		gameObject.name = "Fish " + activeFish.Count + " " + fishDatabyType.name;
		activeFish.Add(fishBehavior);
		return fishBehavior;
	}

	private void ClearAllFish()
	{
		for (int i = 0; i < activeFish.Count; i++)
		{
			UnityEngine.Object.Destroy(activeFish[i].fish.gameObject);
		}
		activeFish.Clear();
		spawnList.Clear();
	}

	private void OnDestroy()
	{
		SinkerCasting.CatchFishSignal.RemoveListener(OnCatchFishSignal);
		Quest.EnterQuestStateSignal.RemoveListener(OnEnterQuestState);
		FishingRodSignal.RemoveListener(OnFishingRodSignal);
		InventoryGUI.equipBaitNotification.RemoveListener(OnEquipBait);
		TensionMeter.TensionMeterSignal.RemoveListener(OnTensionMeterSignal);
		FishODexSpawner.FishODexSpawnSignal.RemoveListener(OnSpawnFishODex);
		FishODexSignal.RemoveListener(OnCloseFishOdex);
	}

	private void OnFishingRodSignal(FishingRodEventType type)
	{
		for (int i = 0; i < activeFish.Count; i++)
		{
			activeFish[i].OnFishingRodSignal(type);
		}
	}

	private void OnTensionMeterSignal(TensionMeter.TensionMeterEventType eventType)
	{
		for (int i = 0; i < activeFish.Count; i++)
		{
			activeFish[i].OnTensionMeterSignal(eventType);
		}
	}

	private void OnSpawnFishODex(FishODexSpawnContent selectedTab, bool wasBackButton)
	{
		ClearAllFish();
		inMenu = true;
	}

	private void OnCloseFishOdex(FishODexEventType type, Transform transform)
	{
		if (type == FishODexEventType.Close)
		{
			ParseSpawnInfo();
			inMenu = false;
		}
	}
}
public class ApplicationEvent : MonoBehaviour
{
	public static Signal Quit = new Signal();

	public static Signal Pause = new Signal();

	private void Awake()
	{
		this.Inject();
	}

	private void OnApplicationQuit()
	{
		Quit.Dispatch();
	}

	private void OnApplicationPause()
	{
		Pause.Dispatch();
	}
}
public class Bait : MonoBehaviour
{
	public float rareFishMultiplier = 1f;

	private Renderer rend;

	[@Dependency]
	public UIDisplayEvent UIDisplaySignal { get; set; }

	[@Dependency]
	public FishingRodEvent FishingRodSignal { get; set; }

	private void Awake()
	{
		this.Inject();
		rend = GetComponent<Renderer>();
		UIDisplaySignal.AddListener(OnUIDisplaySignal);
		FishingRodSignal.AddListener(OnFishingRodSignal);
	}

	public void HideBait()
	{
		rend.enabled = false;
	}

	private void OnUIDisplaySignal(UIEventType eventType)
	{
		switch (eventType)
		{
		case UIEventType.Display:
			rend.enabled = false;
			break;
		case UIEventType.Remove:
			rend.enabled = true;
			break;
		}
	}

	private void OnFishingRodSignal(FishingRodEventType type)
	{
		switch (type)
		{
		case FishingRodEventType.HideRod:
			rend.enabled = false;
			break;
		case FishingRodEventType.VisibleRod:
			rend.enabled = true;
			break;
		}
	}

	private void OnDestroy()
	{
		UIDisplaySignal.RemoveListener(OnUIDisplaySignal);
		FishingRodSignal.RemoveListener(OnFishingRodSignal);
	}
}
public class BaitBootstrapper : BaseBootStrapper
{
	private const int TWEEN_POOL_SIZE = 50;

	public override void Configure(Container container)
	{
		LeanTween.init(50);
		container.Register<GameSession>();
		container.Register<Quest>();
		container.Register<InventoryManager>();
		container.Register<Localization>();
		container.Register<FishParser>();
		container.Register<BuyableItemData>();
		container.Register<RGTracking>();
		container.Register<InputManager>();
		container.Register<IAPService>();
		container.Register<FishingRodEvent>();
		container.Register<UIDisplayEvent>();
		container.Register<FishODexEvent>();
		container.Register<DialogSpeechbubbleStartEvent>();
		container.Register<DialogChatStartEvent>();
		container.Register<DialogAdvanceEvent>();
		container.Register<DialogEndEvent>();
		container.Register<InputModeSwitchEvent>();
	}
}
public enum CatchDisplayEventType
{
	Show,
	StartCountUp,
	Record,
	Star1,
	Star2,
	Star3,
	Shine1,
	Shine2,
	Shine3,
	KeepButton,
	Hide,
	Skip
}
public class CatchDisplay : MonoBehaviour
{
	private struct FishStat
	{
		public float Weight;

		public FishStar NumStars;

		public bool IsNewRecord;

		public Vector3 Scale;

		public float previousRecord;

		public bool IsFirstTimeFish;
	}

	public static Signal<CatchDisplayEventType> CatchDisplaySignal = new Signal<CatchDisplayEventType>();

	[Tooltip("How heigh above the water level should the catchdisplay spawn")]
	[Range(0f, 5f)]
	public float CatchDisplayHeightPosition = 1.9f;

	[Tooltip("Distance factor for the spawn point.")]
	[Range(1f, 5f)]
	public float SpawnDistanceFactor = 4f;

	[Tooltip("Min/max degrees wherein the catchdisplay is allowed to spawn, relative to the camera rotation.")]
	public float SpawnClampDegrees = 35f;

	[Tooltip("How fast the spinning rays should scale up when the third star becomes visible")]
	public float ShineScaleUpDuration = 1.5f;

	[Tooltip("We need to scale the fishes up, but they will also be modified by the display weight of the fish")]
	public float FishScaleUpValue = 2.5f;

	[Tooltip("Delay before we show first star")]
	public float Star1Delay = 1.6f;

	[Tooltip("Delay before we show second star, if we only have two stars")]
	public float Star2Delay2Stars = 3f;

	[Tooltip("Delay before we show second star, when there are three stars in total")]
	public float Star2Delay3Stars = 2.6f;

	[Tooltip("Delay before we show third star")]
	public float Star3Delay = 3.6f;

	[Tooltip("Delay before we show the new record sign")]
	public float NewRecordDelay = 4.1f;

	[Tooltip("Delay before we can click the done-button and close the dialog instead of skipping")]
	public float ReenableButtonDelay = 4.1f;

	public float starWiggleOffsetZ = 0.3f;

	public float starWiggleDurationZ = 0.6f;

	public float starWiggleDelayZ = 0.2f;

	public float starWiggleRepeatDelay = 0.85f;

	public Camera centerCamera;

	public GameObject fishPrefab;

	private CatchDisplayMissionProgress missionProgress;

	private GameObject fishHolder;

	private GameObject displayFish;

	private CatchDisplayStar[] stars;

	private GameObject[] starOutlines;

	private ParticleSystem[] starParticleSystems;

	private ParticleSystem starExplosionSystem;

	private GameObject[] recordStars;

	private GameObject shine;

	private Text fishNameText;

	private Text fishNameTextShadow;

	private Text recordWeightHeadline;

	private Text recordWeightText;

	private Text currentWeightText;

	private Text currentValueText;

	private Text newRecordText;

	private Text balanceText;

	private ButtonEffect keepButton;

	private ButtonEffect missionButton;

	private FishDisplay fishDisplay;

	private bool shineVisible;

	private bool newRecordVisible;

	private FishData currentFishData;

	private FishStat currentStats;

	private float previousRecord;

	private bool transitionRunning;

	[@Dependency]
	public InventoryManager InventoryMgr { get; set; }

	[@Dependency]
	public UIDisplayEvent UIDisplaySignal { get; set; }

	[@Dependency]
	public Quest Quest { get; set; }

	[@Dependency]
	public Localization localization { get; set; }

	[@Dependency]
	public RGTracking tracking { get; set; }

	[@Dependency]
	private InputManager Input { get; set; }

	[@Dependency]
	public GameSession GameSession { get; set; }

	private void Awake()
	{
		this.Inject();
		GameObject go = Find.ComponentInChildren<Canvas>(this).gameObject;
		missionProgress = Find.ComponentOnChild<CatchDisplayMissionProgress>(this, go, "MissionProgress");
		fishNameText = Find.ComponentOnChild<Text>(this, go, "TextFishName");
		fishNameTextShadow = Find.ComponentOnChild<Text>(this, go, "TextFishNameShadow");
		recordWeightHeadline = Find.ComponentOnChild<Text>(this, go, "HeadlineRecord");
		recordWeightText = Find.ComponentOnChild<Text>(this, go, "TextRecordWeight");
		currentWeightText = Find.ComponentOnChild<Text>(this, go, "TextWeight");
		currentValueText = Find.ComponentOnChild<Text>(this, go, "TextValue");
		newRecordText = Find.ComponentOnChild<Text>(this, go, "TextNewRecord");
		balanceText = Find.ComponentOnChild<Text>(this, go, "TextBalance");
		shine = Find.ChildByName(this, go, "Shine");
		keepButton = Find.ComponentOnChild<ButtonEffect>(this, go, "ButtonKeep");
		missionButton = Find.ComponentOnChild<ButtonEffect>(this, go, "MissionProgress/MissionLogButton");
		recordStars = new GameObject[3]
		{
			Find.ChildByName(this, go, "RecordStar1"),
			Find.ChildByName(this, go, "RecordStar2"),
			Find.ChildByName(this, go, "RecordStar3")
		};
		starOutlines = new GameObject[3]
		{
			Find.ChildByName(this, "StarOutline1"),
			Find.ChildByName(this, "StarOutline2"),
			Find.ChildByName(this, "StarOutline3")
		};
		fishHolder = Find.ChildByName(this, "FishHolder");
		fishDisplay = GetComponentInChildren<FishDisplay>();
		stars = new CatchDisplayStar[3]
		{
			GetStar("Star1", 0),
			GetStar("Star2", 1),
			GetStar("Star3", 2)
		};
		starParticleSystems = new ParticleSystem[3]
		{
			Find.ComponentOnChild<ParticleSystem>(this, "ParticleStar1"),
			Find.ComponentOnChild<ParticleSystem>(this, "ParticleStar2"),
			Find.ComponentOnChild<ParticleSystem>(this, "ParticleStar3")
		};
		starExplosionSystem = Find.ComponentOnChild<ParticleSystem>(this, "StarExplosion");
		keepButton.OnSelectSignal.AddListener(OnKeepButtonSelected);
		missionButton.OnSelectSignal.AddListener(OnMissionLogSelected);
		Reset();
	}

	private CatchDisplayStar GetStar(string name, int index)
	{
		CatchDisplayStar catchDisplayStar = Find.ComponentOnChild<CatchDisplayStar>(this, name);
		catchDisplayStar.index = index;
		return catchDisplayStar;
	}

	private void Start()
	{
		SinkerCasting.CatchFishSignal.AddListener(OnCatchFishSignal);
		SinkerCasting.ThrowFishSignal.AddListener(OnThrowFishSignal);
		InputManager.InputSignal.AddListener(OnInput);
		FishODexSpawner.FishODexSpawnSignal.AddListener(OnSpawnFishODex);
		Hide();
	}

	private void OnSpawnFishODex(FishODexSpawnContent selectedTab, bool wasBackButton)
	{
		Hide();
	}

	private void Update()
	{
		if (Input.IsButtonDown(InputAction.Button1, Handedness.Left) || Input.IsButtonDown(InputAction.Button1, Handedness.Right))
		{
			if (transitionRunning)
			{
				Skip();
			}
			else
			{
				OnInteraction();
			}
		}
	}

	private void OnCatchFishSignal(Fish fish, GameObject fishGO)
	{
		if (!(fish == null))
		{
			Reset();
			currentFishData = fish.FishData;
			currentStats = default(FishStat);
			currentStats.Weight = fish.weight;
			currentStats.NumStars = currentFishData.GetStarRating(currentStats.Weight);
			bool flag = !InventoryMgr.Inventory.HasRecord(fish);
			bool isNewRecord = InventoryMgr.Inventory.IsRecord(fish) && !flag;
			currentStats.IsFirstTimeFish = flag;
			currentStats.IsNewRecord = isNewRecord;
			currentStats.previousRecord = ((!flag) ? InventoryMgr.Inventory.GetRecord(fish) : fish.weight);
			currentStats.Scale = fish.capturedScale * fish.CatchDisplayScale * FishScaleUpValue;
			Show(fish, fishGO);
			missionProgress.ShowProgress(fish);
			tracking.TrackFish("captured", fish, Quest);
		}
	}

	private void OnThrowFishSignal(Fish fish)
	{
		RemoveCatchDisplay();
	}

	private void Reset()
	{
		for (int i = 0; i < stars.Length; i++)
		{
			stars[i].InitializeAndHide();
			starOutlines[i].SetActive(value: true);
		}
		shineVisible = false;
		newRecordVisible = false;
		shine.transform.localScale = Vector3.zero;
		shine.SetActive(value: false);
		newRecordText.gameObject.SetActive(value: false);
		keepButton.SetIsSelectable(selectable: true);
		missionButton.SetIsSelectable(selectable: true);
		if (displayFish != null)
		{
			UnityEngine.Object.Destroy(displayFish);
			displayFish = null;
		}
	}

	private void Show(Fish fish, GameObject fishGO)
	{
		InventoryMgr.Inventory.AddFishWorth(currentFishData);
		base.gameObject.SetActive(value: true);
		transitionRunning = true;
		UIDisplaySignal.Dispatch(UIEventType.Display);
		CatchDisplaySignal.Dispatch(CatchDisplayEventType.Show);
		PositionAtFish(fishGO);
		fishNameText.text = localization.GetString(fish.FishData.name);
		fishNameText.font = localization.GetLanguageFont();
		fishNameTextShadow.text = fishNameText.text;
		fishNameTextShadow.font = localization.GetLanguageFont();
		currentWeightText.text = localization.FormatWeight(0f);
		currentWeightText.font = localization.GetLanguageFont();
		currentValueText.text = fish.FishData.worth.ToString();
		currentValueText.font = localization.GetLanguageFont();
		balanceText.text = InventoryMgr.Inventory.Money.ToString();
		balanceText.font = localization.GetLanguageFont();
		balanceText.resizeTextMaxSize = (int)((float)balanceText.resizeTextMaxSize * localization.GetLanguageFontSizeMultiplier());
		InventoryMgr.Inventory.AddToFishRecord(fish);
		GameSession.ManuallySaveSession();
		ShowPreviousRecord(currentStats.IsFirstTimeFish, currentStats.IsNewRecord, currentStats.previousRecord);
		if (Quest.IsInBeachTutorialState())
		{
			missionButton.gameObject.SetActive(value: false);
		}
		else
		{
			missionButton.gameObject.SetActive(value: true);
		}
		FishStar starRating = fish.FishData.GetStarRating(fish.weight);
		float star1Delay = Star1Delay;
		float num = ((starRating != FishStar.Three) ? Star2Delay2Stars : Star2Delay3Stars);
		float star3Delay = Star3Delay;
		float delayTime = star1Delay;
		switch (starRating)
		{
		case FishStar.Two:
			delayTime = num;
			break;
		case FishStar.Three:
			delayTime = star3Delay;
			break;
		}
		LeanTween.value(base.gameObject, 0f, currentStats.Weight, 3.5f).setDelay(1f).setOnUpdate(delegate(float val)
		{
			currentWeightText.text = localization.FormatWeight(val);
		})
			.setEase(LeanTweenType.easeOutQuint)
			.setOnStart(OnWeightCountUpStart);
		LeanTween.delayedCall(base.gameObject, star1Delay, (Action)delegate
		{
			ShowStar(stars[0]);
		});
		if (starRating > FishStar.One)
		{
			LeanTween.delayedCall(base.gameObject, num, (Action)delegate
			{
				ShowStar(stars[1]);
			});
		}
		if (starRating > FishStar.Two)
		{
			LeanTween.delayedCall(base.gameObject, star3Delay, (Action)delegate
			{
				ShowStar(stars[2]);
			});
		}
		LeanTween.delayedCall(base.gameObject, delayTime, (Action)delegate
		{
			ShowShine();
		});
		if (currentStats.IsFirstTimeFish)
		{
			LeanTween.delayedCall(base.gameObject, NewRecordDelay, (Action)delegate
			{
				ShowNewFish();
			});
		}
		else if (currentStats.IsNewRecord)
		{
			LeanTween.delayedCall(base.gameObject, NewRecordDelay, (Action)delegate
			{
				ShowNewRecord();
			});
		}
		LeanTween.delayedCall(base.gameObject, ReenableButtonDelay, (Action)delegate
		{
			transitionRunning = false;
		});
		LeanTween.delayedCall(base.gameObject, 5f, WiggleStars);
	}

	private void PositionCatchDisplayInFrontOfCamera()
	{
		PositionCatchDisplayAtRotation(centerCamera.transform.rotation);
	}

	private void PositionAtFish(GameObject fishGameObject)
	{
		CatchDisplayHandheldFollowFish component = GetComponent<CatchDisplayHandheldFollowFish>();
		Transform transformToFollow = fishGameObject.GetComponentsInChildren<Collider>()[2].transform;
		component.SetTransformToFollow(transformToFollow);
	}

	private void PositionCatchDisplayAtRotation(Quaternion rotation)
	{
		float num = rotation.eulerAngles.y;
		if (num > 180f)
		{
			num -= 360f;
		}
		num = Mathf.Max(0f - SpawnClampDegrees, Mathf.Min(SpawnClampDegrees, num));
		float f = num * ((float)Math.PI / 180f);
		Vector3 position = new Vector3(Mathf.Sin(f) * SpawnDistanceFactor, CatchDisplayHeightPosition, Mathf.Cos(f) * SpawnDistanceFactor);
		base.transform.position = position;
		base.transform.localRotation = Quaternion.Euler(0f, num, 0f);
	}

	private void OnWeightCountUpStart()
	{
		CatchDisplaySignal.Dispatch(CatchDisplayEventType.StartCountUp);
	}

	private void OnWeightCountUpDone()
	{
		transitionRunning = false;
	}

	private void ShowStar(CatchDisplayStar star)
	{
		CatchDisplayEventType[] array = new CatchDisplayEventType[3]
		{
			CatchDisplayEventType.Star1,
			CatchDisplayEventType.Star2,
			CatchDisplayEventType.Star3
		};
		CatchDisplaySignal.Dispatch(array[star.index]);
		star.transform.localPosition = star.TargetPosition + new Vector3(0f, 0f, -1f);
		LeanTween.scale(star.gameObject, star.TargetScale, 1.2f).setEase(LeanTweenType.easeOutElastic);
		LeanTween.moveLocal(star.gameObject, star.TargetPosition, 0.5f).setEase(LeanTweenType.easeOutSine).setOnComplete((Action)delegate
		{
			starOutlines[star.index].SetActive(value: false);
		});
		LeanTween.delayedCall(base.gameObject, 0.4f, (Action)delegate
		{
			starParticleSystems[star.index].Play();
		});
		if (star.index == 2)
		{
			starExplosionSystem.Play();
		}
	}

	private void WiggleStars()
	{
		for (int i = 0; i < (int)currentStats.NumStars; i++)
		{
			LeanTween.moveLocalZ(stars[i].gameObject, stars[i].TargetPosition.z - starWiggleOffsetZ, starWiggleDurationZ).setDelay((float)i * starWiggleDelayZ).setEase(LeanTweenType.easeInCubic)
				.setLoopPingPong(1);
		}
		float num = (float)currentStats.NumStars * starWiggleDelayZ + 2f * starWiggleDurationZ;
		LeanTween.delayedCall(base.gameObject, num + starWiggleRepeatDelay, WiggleStars);
	}

	private void ShowShine()
	{
		if (!shineVisible)
		{
			shineVisible = true;
			LeanTween.cancel(shine);
			shine.SetActive(value: true);
			Find.ComponentOnGameObject<CatchDisplayBgRays>(this, shine).SetBackgroundForNumberOfStars(currentStats.NumStars);
			if (transitionRunning)
			{
				CatchDisplayEventType[] array = new CatchDisplayEventType[3]
				{
					CatchDisplayEventType.Shine1,
					CatchDisplayEventType.Shine2,
					CatchDisplayEventType.Shine3
				};
				CatchDisplaySignal.Dispatch(array[(int)(currentStats.NumStars - 1)]);
				LeanTween.scale(shine, new Vector3(1f, 1f, 1f), ShineScaleUpDuration).setEase(LeanTweenType.easeOutSine);
			}
			else
			{
				shine.transform.localScale = Vector3.one;
			}
		}
	}

	private void ShowNewRecord()
	{
		FlashText(localization.GetString("GUI_NewRecord"));
	}

	private void ShowNewFish()
	{
		FlashText(localization.GetString("GUI_NewFish"));
	}

	private void FlashText(string text)
	{
		if (!newRecordVisible)
		{
			newRecordVisible = true;
			newRecordText.text = text;
			newRecordText.font = localization.GetLanguageFont();
			CatchDisplaySignal.Dispatch(CatchDisplayEventType.Record);
			newRecordText.gameObject.SetActive(value: true);
			Color color = newRecordText.color;
			color.a = 0f;
			newRecordText.color = color;
			LeanTween.textAlpha(newRecordText.rectTransform, 1f, 0.7f).setEase(LeanTweenType.easeOutQuint).setLoopPingPong()
				.setLoopCount(10);
		}
	}

	private void ShowPreviousRecord(bool firstTimeCaught, bool isRecord, float previousRecordWeight)
	{
		recordWeightHeadline.text = localization.GetString((!isRecord) ? "GUI_Record" : "GUI_PreviousRecord");
		recordWeightHeadline.font = localization.GetLanguageFont();
		recordWeightText.text = localization.FormatWeight(previousRecordWeight);
		recordWeightText.font = localization.GetLanguageFont();
		int starRating = (int)currentFishData.GetStarRating(previousRecordWeight);
		for (int i = 0; i < recordStars.Length; i++)
		{
			bool active = i < starRating;
			recordStars[i].SetActive(active);
		}
	}

	private void Hide()
	{
		CatchDisplaySignal.Dispatch(CatchDisplayEventType.Hide);
		StopTweens();
		base.gameObject.SetActive(value: false);
		currentFishData = null;
	}

	private void StopTweens()
	{
		LeanTween.cancel(fishHolder);
		LeanTween.cancel(shine);
		LeanTween.cancel(base.gameObject);
		for (int i = 0; i < stars.Length; i++)
		{
			LeanTween.cancel(stars[i].gameObject);
		}
	}

	private void OnKeepButtonSelected()
	{
		if (!transitionRunning)
		{
			OnInteraction();
			CatchDisplaySignal.Dispatch(CatchDisplayEventType.KeepButton);
		}
		else
		{
			Skip();
		}
	}

	private void OnMissionLogSelected()
	{
		if (!transitionRunning)
		{
			OnInteraction();
			FishODexSpawner.FishODexSpawnSignal.Dispatch(FishODexSpawnContent.MissionLog, item2: false);
		}
		else
		{
			Skip();
		}
	}

	private void OnInteraction()
	{
		keepButton.SetIsSelectable(selectable: false);
		missionButton.SetIsSelectable(selectable: false);
		RemoveCatchDisplay();
	}

	private void OnInput(InputType type)
	{
		if (type == InputType.KeyUp && transitionRunning)
		{
			Skip();
		}
	}

	private void Skip()
	{
		if (transitionRunning)
		{
			StopTweens();
			transitionRunning = false;
			currentWeightText.text = localization.FormatWeight(currentStats.Weight);
			fishHolder.transform.localScale = currentStats.Scale;
			stars[0].PlaceAtTargetPos();
			starOutlines[0].SetActive(value: false);
			if (currentStats.NumStars > FishStar.One)
			{
				stars[1].PlaceAtTargetPos();
				starOutlines[1].SetActive(value: false);
			}
			if (currentStats.NumStars > FishStar.Two)
			{
				stars[2].PlaceAtTargetPos();
				starOutlines[2].SetActive(value: false);
			}
			ShowShine();
			if (currentStats.IsNewRecord)
			{
				ShowNewRecord();
			}
			if (currentStats.IsFirstTimeFish)
			{
				ShowNewFish();
			}
			CatchDisplaySignal.Dispatch(CatchDisplayEventType.Skip);
		}
	}

	private void RemoveCatchDisplay()
	{
		UIDisplaySignal.Dispatch(UIEventType.Remove);
		Hide();
	}

	private void OnDestroy()
	{
		SinkerCasting.CatchFishSignal.RemoveListener(OnCatchFishSignal);
		SinkerCasting.ThrowFishSignal.RemoveListener(OnThrowFishSignal);
		InputManager.InputSignal.RemoveListener(OnInput);
		FishODexSpawner.FishODexSpawnSignal.RemoveListener(OnSpawnFishODex);
		keepButton.OnSelectSignal.RemoveListener(OnKeepButtonSelected);
		missionButton.OnSelectSignal.RemoveListener(OnMissionLogSelected);
		Canvas[] componentsInChildren = GetComponentsInChildren<Canvas>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].enabled = false;
		}
	}

	private string DebugFishDataStats(Fish fish)
	{
		FishData fishData = fish.FishData;
		string text = fishData.name;
		float weight = fish.weight;
		float maxWeight = fishData.maxWeight;
		float minWeight = fishData.minWeight;
		float twoStarWeight = fishData.TwoStarWeight;
		float threeStarWeight = fishData.ThreeStarWeight;
		float record = InventoryMgr.Inventory.GetRecord(fish);
		string text2 = text + "*";
		if (weight >= twoStarWeight)
		{
			text2 += "*";
		}
		if (weight >= threeStarWeight)
		{
			text2 += "*";
		}
		string text3 = text2;
		text2 = text3 + "   weight: " + minWeight + " < " + weight + " < " + maxWeight + ",     2* " + twoStarWeight + ",     3* " + threeStarWeight;
		return text2 + "  prevRecord: " + record;
	}
}
public class CatchDisplayBgRays : MonoBehaviour
{
	public Sprite oneStar;

	public Sprite twoStars;

	public Sprite threeStars;

	[Tooltip("How many seconds it takes for the rays to spin 360 degrees")]
	public float ShineRotationSpeed = 15f;

	private float rotation;

	private Image image;

	private void Awake()
	{
		image = Find.ComponentOnGameObject<Image>(this);
	}

	public void SetBackgroundForNumberOfStars(FishStar numStars)
	{
		Sprite sprite;
		switch (numStars)
		{
		case FishStar.One:
			sprite = oneStar;
			break;
		case FishStar.Two:
			sprite = twoStars;
			break;
		case FishStar.Three:
			sprite = threeStars;
			break;
		default:
			UnityEngine.Debug.LogError("Invalid number of stars: " + numStars);
			return;
		}
		image.sprite = sprite;
	}

	public void Update()
	{
		rotation += ShineRotationSpeed * Time.deltaTime;
		base.transform.localRotation = Quaternion.Euler(0f, 0f, rotation);
	}
}
public class CatchDisplayCacheObject : MonoBehaviour
{
	private bool destroy;

	private void Start()
	{
		base.transform.GetChild(0).gameObject.SetActive(value: true);
		destroy = false;
	}

	private void Update()
	{
		if (destroy)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		destroy = true;
	}
}
public class CatchDisplayDebug : MonoBehaviour
{
	public enum DebugNumStars
	{
		Ranodomize,
		One,
		Two,
		Three
	}

	public CatchDisplay CatchDisplayRef;

	public bool debugShowAtStartup;

	public DebugNumStars showNumStars;

	public bool isNewRecord;

	public bool forceRandomizeFish;

	public FishType showFish = FishType.AlligatorPerch;

	private Fish testFish;

	[@Dependency]
	public InventoryManager InventoryMgr { get; set; }

	private void Start()
	{
		this.Inject();
		if (debugShowAtStartup)
		{
			LeanTween.delayedCall(0.01f, ShowRandomFishDebug);
		}
	}

	private void ShowRandomFishDebug()
	{
		if (forceRandomizeFish)
		{
			showFish = (FishType)UnityEngine.Random.Range(1, 16);
			if (showFish == FishType.GoldFish)
			{
				showFish = FishType.GlowstickTetra;
			}
		}
		FishData fishDatabyType = FishRegistry.Instance.GetFishDatabyType(showFish);
		GameObject fishPrefab = FishRegistry.Instance.GetFishPrefab(showFish);
		testFish = fishPrefab.GetComponent<Fish>();
		testFish.FishData = fishDatabyType;
		testFish.weight = fishDatabyType.GetRandomWeight();
		if (showNumStars != 0)
		{
			if (showNumStars == DebugNumStars.Three)
			{
				testFish.weight = fishDatabyType.maxWeight;
			}
			else if (showNumStars == DebugNumStars.Two)
			{
				testFish.weight = fishDatabyType.TwoStarWeight + 0.001f;
			}
			else
			{
				testFish.weight = fishDatabyType.minWeight;
			}
		}
		bool flag = InventoryMgr.Inventory.IsRecord(testFish);
		if (isNewRecord && !flag)
		{
			InventoryMgr.Inventory.FishRecords[fishDatabyType.fishType] = testFish.weight - 0.1f;
		}
		else if (!isNewRecord && flag)
		{
			InventoryMgr.Inventory.FishRecords[fishDatabyType.fishType] = testFish.weight + 0.1f;
		}
		SinkerCasting.CatchFishSignal.Dispatch(testFish, fishPrefab);
	}

	private float GetFishWeight(FishData fd, float weightPercent)
	{
		return (fd.maxWeight - fd.minWeight) * weightPercent + fd.minWeight;
	}
}
public class CatchDisplayDebugHandheld : MonoBehaviour
{
	public enum DebugNumStars
	{
		Ranodomize,
		One,
		Two,
		Three
	}

	public GameObject fishPosRef;

	public CatchDisplay CatchDisplayRef;

	public bool debugShowAtStartup;

	public DebugNumStars showNumStars;

	public bool isNewRecord;

	public bool forceRandomizeFish;

	public FishType showFish = FishType.AlligatorPerch;

	private Fish testFish;

	[@Dependency]
	public InventoryManager InventoryMgr { get; set; }

	[@Dependency]
	public GameSession GameSession { get; set; }

	private void Awake()
	{
		this.Inject();
	}

	private void Start()
	{
		if (debugShowAtStartup)
		{
			LeanTween.delayedCall(0.1f, ShowRandomFishDebug);
		}
	}

	private void ShowRandomFishDebug()
	{
		if (forceRandomizeFish)
		{
			showFish = (FishType)UnityEngine.Random.Range(1, 16);
			if (showFish == FishType.GoldFish)
			{
				showFish = FishType.GlowstickTetra;
			}
		}
		FishData fishDatabyType = FishRegistry.Instance.GetFishDatabyType(showFish);
		GameObject gameObject = UnityEngine.Object.Instantiate(FishRegistry.Instance.GetFishPrefab(showFish), fishPosRef.transform.position, fishPosRef.transform.rotation);
		testFish = gameObject.GetComponent<Fish>();
		testFish.FishData = fishDatabyType;
		testFish.weight = fishDatabyType.GetRandomWeight();
		if (showNumStars != 0)
		{
			if (showNumStars == DebugNumStars.Three)
			{
				testFish.weight = fishDatabyType.maxWeight;
			}
			else if (showNumStars == DebugNumStars.Two)
			{
				testFish.weight = fishDatabyType.TwoStarWeight + 0.001f;
			}
			else
			{
				testFish.weight = fishDatabyType.minWeight;
			}
		}
		SinkerCasting.CatchFishSignal.Dispatch(testFish, gameObject);
	}

	private float GetFishWeight(FishData fd, float weightPercent)
	{
		return (fd.maxWeight - fd.minWeight) * weightPercent + fd.minWeight;
	}
}
public class CatchDisplayHolder : MonoBehaviour
{
	public GameObject CatchDisplayPrefab;

	private Camera centerCamera;

	private void Start()
	{
		StartCoroutine(WaitForMainCamera());
	}

	private IEnumerator WaitForMainCamera()
	{
		while (centerCamera == null)
		{
			centerCamera = Camera.main;
			yield return null;
		}
		GameObject go = UnityEngine.Object.Instantiate(CatchDisplayPrefab);
		go.transform.parent = base.transform.parent;
		CatchDisplay cd = go.GetComponent<CatchDisplay>();
		cd.centerCamera = centerCamera;
	}
}
public class CatchDisplayKeepButton : ButtonEffect
{
	[@Dependency]
	public InputManager input { get; set; }

	private void Start()
	{
		this.Inject();
		input.AddBackButtonListener(4, BackButtonFunction);
	}

	public CallbackResult BackButtonFunction()
	{
		if (base.gameObject.activeInHierarchy)
		{
			base.FishODexSignal.Dispatch(FishODexEventType.ItemSelect, base.gameObject.transform);
			OnSelectSignal.Dispatch();
			return CallbackResult.Consumed;
		}
		return CallbackResult.NotConsumed;
	}

	private void OnDestroy()
	{
		input.RemoveBackButtonListener(BackButtonFunction);
	}
}
public class CatchDisplayMissionCard : MonoBehaviour
{
	private Text headline;

	private int headlineMaxSize;

	private Text label;

	private GameObject checkmark;

	private bool wobble;

	private Vector3 startScale;

	private float wobbleSpeed = 5f;

	private float wobbleMagnitude = 0.1f;

	private void Awake()
	{
		headline = Find.ComponentOnChild<Text>(this, "Headline");
		headlineMaxSize = headline.resizeTextMaxSize;
		label = Find.ComponentOnChild<Text>(this, "Label");
		checkmark = Find.ChildByName(this, "Done");
		wobble = false;
		Hide();
	}

	private void Start()
	{
		startScale = base.transform.localScale;
	}

	private void Update()
	{
		if (wobble)
		{
			base.transform.localScale = startScale * (1f + Mathf.Sin(Time.timeSinceLevelLoad * wobbleSpeed) * wobbleMagnitude);
		}
	}

	public void Show(string text, string headline, bool completed, Font font, float multiplier)
	{
		this.headline.text = headline;
		this.headline.font = font;
		this.headline.resizeTextMaxSize = (int)((float)headlineMaxSize * multiplier);
		label.text = text;
		label.font = font;
		checkmark.SetActive(completed);
		wobble = completed;
		base.gameObject.SetActive(value: true);
	}

	public void Hide()
	{
		base.gameObject.SetActive(value: false);
	}
}
public class CatchDisplayMissionProgress : MonoBehaviour
{
	public struct MissionProgressInfo
	{
		public string Text;

		public bool Completed;

		public bool Highlighted;
	}

	public string AnyFishProgressTemplateText = "GUI_MissionAnyFishProgress";

	public string FishProgressTemplateText = "{{fish}} {{progress}}";

	public string MoneyProgressTemplateText = "GUI_MissionMoneyProgress";

	public string TrashProgressTemplateText = "GUI_MissionTrashProgress";

	public string HeadlineOneMission = "GUI_CurrentMissionTitle";

	public string HeadlineNextMission = "GUI_NextMissionTitle";

	public string HeadlineCompletedMission = "GUI_CurrentMissionCompleted";

	public string finalStateId = "PostGame01";

	private CatchDisplayMissionCard missionCardTop;

	private CatchDisplayMissionCard missionCardBottom;

	[@Dependency]
	public Quest QuestManager { get; set; }

	[@Dependency]
	public Localization localization { get; set; }

	private void Awake()
	{
		this.Inject();
		missionCardTop = Find.ComponentOnChild<CatchDisplayMissionCard>(this, "MissionCardTop");
		missionCardBottom = Find.ComponentOnChild<CatchDisplayMissionCard>(this, "MissionCardBottom");
		Hide();
	}

	private void Start()
	{
	}

	public void ShowProgress(Fish fish)
	{
		ShowQuestProgress(fish);
	}

	private void OnFishCaught(Fish fish)
	{
		ShowQuestProgress(fish);
	}

	private void Hide()
	{
		base.gameObject.SetActive(value: false);
	}

	private void Show(MissionProgressInfo currentMission)
	{
		base.gameObject.SetActive(value: true);
		missionCardTop.Hide();
		missionCardBottom.Show(currentMission.Text, localization.GetString(HeadlineOneMission), currentMission.Completed, localization.GetLanguageFont(), localization.GetLanguageFontSizeMultiplier());
	}

	private void Show(MissionProgressInfo completedMission, MissionProgressInfo currentMission)
	{
		base.gameObject.SetActive(value: true);
		missionCardTop.Show(completedMission.Text, localization.GetString(HeadlineCompletedMission), completedMission.Completed, localization.GetLanguageFont(), localization.GetLanguageFontSizeMultiplier());
		missionCardBottom.Show(currentMission.Text, localization.GetString(HeadlineNextMission), currentMission.Completed, localization.GetLanguageFont(), localization.GetLanguageFontSizeMultiplier());
	}

	private void ShowQuestProgress(Fish fish)
	{
		QuestState currentState = QuestManager.CurrentState;
		Mission currentMission = QuestManager.CurrentMission;
		if (currentMission == Mission.Empty)
		{
			Hide();
			return;
		}
		if (QuestManager.CurrentState.Id == finalStateId)
		{
			Hide();
			return;
		}
		MissionProgressInfo infoForQuest = GetInfoForQuest(currentState, fish);
		if (infoForQuest.Completed && currentMission != null)
		{
			Mission.MissionPart upcomingMissionPart = currentMission.GetUpcomingMissionPart(currentState);
			if (!upcomingMissionPart.IsEmpty())
			{
				QuestState stateFromId = QuestManager.GetStateFromId(upcomingMissionPart.QuestId);
				MissionProgressInfo infoForQuest2 = GetInfoForQuest(stateFromId, null);
				Show(infoForQuest, infoForQuest2);
				return;
			}
		}
		if (!infoForQuest.Highlighted && currentMission != null)
		{
			Mission.MissionPart previousMissionPart = currentMission.GetPreviousMissionPart(currentState);
			if (!previousMissionPart.IsEmpty())
			{
				QuestState stateFromId2 = QuestManager.GetStateFromId(previousMissionPart.QuestId);
				if (stateFromId2 != null)
				{
					bool forceCompleted = true;
					MissionProgressInfo infoForQuest3 = GetInfoForQuest(stateFromId2, null, forceCompleted);
					Show(infoForQuest3, infoForQuest);
					return;
				}
			}
		}
		Show(infoForQuest);
	}

	private MissionProgressInfo GetInfoForQuest(QuestState questState, Fish fish, bool forceCompleted = false)
	{
		QuestCondition condition = questState.Condition;
		Mission.MissionPart missionPart = QuestManager.CurrentMission?.GetMissionPartForQuest(questState) ?? Mission.MissionPart.empty;
		MissionProgressInfo result = default(MissionProgressInfo);
		result.Text = string.Empty;
		result.Completed = condition.IsFullfilled || forceCompleted;
		result.Highlighted = false;
		bool flag = condition is FishCondition;
		bool flag2 = condition is MoneyCondition;
		bool flag3 = condition is TrashCondition;
		if (!flag && !flag2 && !flag3 && !missionPart.IsEmpty())
		{
			result.Text = localization.GetString(missionPart.Text);
			return result;
		}
		if (flag)
		{
			FishType fishType = ((FishCondition)condition).FishType;
			bool flag4 = fishType == FishType.None;
			bool flag5 = fishType != FishType.None;
			if (fish != null)
			{
				result.Highlighted = flag4 || (flag5 && fishType == fish.FishData.fishType);
			}
			result.Text = ((!flag4) ? FishProgressTemplateText : localization.GetString(AnyFishProgressTemplateText));
			if (flag5)
			{
				string id = FishRegistry.Instance.GetFishDatabyType(fishType).name;
				id = localization.GetString(id);
				result.Text = result.Text.Replace("{{fish}}", id);
			}
		}
		if (flag2)
		{
			result.Text = localization.GetString(MoneyProgressTemplateText);
			result.Highlighted = true;
		}
		if (flag3)
		{
			result.Text = localization.GetString(TrashProgressTemplateText);
			result.Highlighted = true;
		}
		int num = ((!forceCompleted) ? condition.CurrentProgress : condition.RequiredProgress);
		int requiredProgress = condition.RequiredProgress;
		string newValue = num + "/" + requiredProgress;
		result.Text = result.Text.Replace("{{progress}}", newValue);
		return result;
	}
}
public class CatchDisplayStar : MonoBehaviour
{
	[HideInInspector]
	public int index;

	private Vector3 initialLocalPos;

	private Vector3 initialScale;

	private bool initialized;

	public Vector3 TargetPosition => initialLocalPos;

	public Vector3 TargetScale => initialScale;

	private void Awake()
	{
		if (!initialized)
		{
			init();
		}
	}

	public void InitializeAndHide()
	{
		if (!initialized)
		{
			init();
		}
		base.transform.localPosition = initialLocalPos;
		base.transform.localScale = Vector3.zero;
	}

	public void PlaceAtTargetPos()
	{
		base.transform.localPosition = initialLocalPos;
		base.transform.localScale = initialScale;
	}

	private void init()
	{
		initialLocalPos = base.transform.localPosition;
		initialScale = base.transform.localScale;
		initialized = true;
	}
}
public class RodSwosh : MonoBehaviour
{
	[Range(0.1f, 1f)]
	public float swoshDelay = 0.4f;

	[Range(0.1f, 0.5f)]
	public float swoshAccelerationThreshold = 0.15f;

	[Range(2f, 7f)]
	public int frameSampleCount = 5;

	private Vector3 previousPosition;

	private float timeSinceLastSwosh;

	private bool isMovingEnough;

	private Vector3[] positionDeltas;

	private int sampleIndex;

	private bool rodVisible;

	private bool gazeInputActive;

	private bool simpleCastingActive;

	private bool castingWithRod;

	[@Dependency]
	private FishingRodEvent FishingRodEvent { get; set; }

	[@Dependency]
	public GameSession gameSession { get; set; }

	[@Dependency]
	public InputModeSwitchEvent GearVRInputSwitchSignal { get; set; }

	[@Dependency]
	public FishingRodEvent FishingRodSignal { get; set; }

	private void Awake()
	{
		this.Inject();
		FishingRodEvent.AddListener(OnFishingRodEvent);
		gameSession.AfterCastingModeChangedSignal.AddListener(OnCastingModeChanged);
		GearVRInputSwitchSignal.AddListener(OnActiveControllerChanged);
		FishingRodSignal.AddListener(OnFishingRodSignal);
	}

	private void Start()
	{
		positionDeltas = new Vector3[frameSampleCount];
		previousPosition = base.transform.position;
	}

	private void OnFishingRodEvent(FishingRodEventType item)
	{
		switch (item)
		{
		case FishingRodEventType.HideRod:
			rodVisible = false;
			break;
		case FishingRodEventType.VisibleRod:
			rodVisible = true;
			break;
		}
	}

	private void Update()
	{
		if (rodVisible && !gazeInputActive && (!simpleCastingActive || !castingWithRod))
		{
			Vector3 vector = base.transform.position - previousPosition;
			timeSinceLastSwosh += Time.deltaTime;
			previousPosition = base.transform.position;
			sampleIndex = (sampleIndex + 1) % frameSampleCount;
			positionDeltas[sampleIndex] = vector;
			Vector3 zero = Vector3.zero;
			for (int i = 0; i < positionDeltas.Length; i++)
			{
				zero += positionDeltas[i];
			}
			if ((zero / positionDeltas.Length).magnitude > swoshAccelerationThreshold && timeSinceLastSwosh > swoshDelay)
			{
				MasterAudio.PlaySound("WhooshCastReel2");
				timeSinceLastSwosh = 0f;
			}
		}
	}

	private void OnCastingModeChanged(CastingMode castingMode)
	{
		simpleCastingActive = castingMode == CastingMode.Simple;
	}

	private void OnActiveControllerChanged(InputMode inputType)
	{
		gazeInputActive = inputType == InputMode.Headset;
	}

	private void OnFishingRodSignal(FishingRodEventType type)
	{
		castingWithRod = type == FishingRodEventType.StartCasting;
	}

	private void OnDestroy()
	{
		FishingRodEvent.RemoveListener(OnFishingRodEvent);
		gameSession.AfterCastingModeChangedSignal.RemoveListener(OnCastingModeChanged);
		GearVRInputSwitchSignal.RemoveListener(OnActiveControllerChanged);
		FishingRodSignal.RemoveListener(OnFishingRodSignal);
	}
}
public class CatchDisplayHandheldFollowFish : MonoBehaviour
{
	private Transform followTransform;

	private Camera mainCam;

	private void Awake()
	{
		mainCam = Camera.main;
	}

	public void SetTransformToFollow(Transform followMe)
	{
		followTransform = followMe;
	}

	private void Update()
	{
		if (!(followTransform == null))
		{
			base.transform.position = followTransform.position;
			base.transform.rotation = Quaternion.LookRotation(followTransform.position - mainCam.transform.position, Vector3.up);
		}
	}
}
public class WaterDropper : MonoBehaviour
{
	public static Signal<Transform> HitWaterSignal = new Signal<Transform>();

	public bool playSound = true;

	private Camera centerCamera;

	public GameObject waterDropPrefab;

	public GameObject waterRingPrefab;

	[Range(0.1f, 10f)]
	public float spawnDelay = 1f;

	[Range(0f, 5f)]
	public float spawnTimeRandomness = 1f;

	public Vector3 fallDisplacement = new Vector3(0f, -0.13f, 0f);

	private GameObject waterDrop;

	private GameObject waterRing;

	private void Start()
	{
		this.Inject();
		waterDrop = UnityEngine.Object.Instantiate(waterDropPrefab, base.transform.position, Quaternion.identity);
		waterDrop.transform.parent = base.transform;
		StartCoroutine(WaitForCamera());
	}

	private IEnumerator WaitForCamera()
	{
		while (Camera.main == null)
		{
			yield return null;
		}
		centerCamera = Camera.main;
		StartCoroutine(Drop());
	}

	private IEnumerator Drop()
	{
		while (waterDrop.transform.position.y > 0f)
		{
			waterDrop.transform.position += fallDisplacement;
			waterDrop.transform.rotation = Quaternion.LookRotation(centerCamera.transform.position - base.transform.position, Vector3.up);
			yield return null;
		}
		if (playSound)
		{
			HitWaterSignal.Dispatch(waterDrop.transform);
		}
		waterDrop.SetActive(value: false);
		StartCoroutine(SpawnWaterRing());
		waterDrop.transform.position = base.transform.position;
		yield return new WaitForSeconds(Mathf.Max(0f, spawnDelay + UnityEngine.Random.Range(0f - spawnTimeRandomness, spawnTimeRandomness)));
		waterDrop.SetActive(value: true);
		StartCoroutine(Drop());
	}

	private IEnumerator SpawnWaterRing()
	{
		GameObject waterRings = UnityEngine.Object.Instantiate(waterRingPrefab, waterDrop.transform.position, Quaternion.identity);
		waterRings.transform.parent = base.transform;
		ParticleSystem splashParticleSystem = waterRings.GetComponentInChildren<ParticleSystem>();
		while (splashParticleSystem.IsAlive())
		{
			yield return null;
		}
		UnityEngine.Object.Destroy(waterRings);
	}
}
public class CreditsScreen : MonoBehaviour
{
	public enum LineStatus
	{
		Below,
		Visible,
		Above
	}

	public struct ScrollingItem
	{
		public GameObject gameObject;

		public LineStatus status;
	}

	private ScrollingItem[] items;

	private Vector3 upperBounds;

	private Vector3 lowerBounds;

	private float scrollSpeed = 0.8f;

	private float scrollY;

	private bool creditsCompleted;

	private void Start()
	{
		this.Inject();
		upperBounds = Find.ChildByName(this, base.transform.parent.gameObject, "UpperBounds").transform.position;
		lowerBounds = Find.ChildByName(this, base.transform.parent.gameObject, "LowerBounds").transform.position;
		items = new ScrollingItem[base.transform.childCount];
		for (int i = 0; i < base.transform.childCount; i++)
		{
			GameObject gameObject = base.transform.GetChild(i).gameObject;
			LineStatus status = LineStatus.Visible;
			bool flag = true;
			float y = gameObject.transform.position.y;
			if (y < lowerBounds.y)
			{
				status = LineStatus.Below;
				flag = false;
			}
			else if (y > upperBounds.y)
			{
				status = LineStatus.Above;
				flag = false;
			}
			if (!flag)
			{
				SetAlpha(gameObject, 0f);
			}
			items[i] = default(ScrollingItem);
			items[i].gameObject = gameObject;
			items[i].status = status;
		}
		scrollY = base.transform.position.y;
		InputManager.InputSignal.AddListener(OnInputSignal);
	}

	private void OnInputSignal(InputType type)
	{
		if (type == InputType.KeyUp && !creditsCompleted)
		{
			NavigateBack();
		}
	}

	private void NavigateBack()
	{
		LeanTween.cancel(base.gameObject);
		creditsCompleted = true;
		LoadScene.LoadPreviousSceneSignal.Dispatch("TheDocks01");
	}

	private void SetAlpha(GameObject go, float alpha)
	{
		Text component = go.GetComponent<Text>();
		if (component != null)
		{
			Color color = component.color;
			color.a = alpha;
			component.color = color;
		}
		Image component2 = go.GetComponent<Image>();
		if (component2 != null)
		{
			Color color2 = component2.color;
			color2.a = alpha;
			component2.color = color2;
		}
		go.SetActive(alpha > 0f);
	}

	private void Update()
	{
		scrollY += scrollSpeed * Time.deltaTime;
		base.transform.position = new Vector3(base.transform.position.x, scrollY, base.transform.position.z);
		for (int i = 0; i < items.Length; i++)
		{
			if (items[i].status == LineStatus.Visible && items[i].gameObject.transform.position.y > upperBounds.y)
			{
				items[i].status = LineStatus.Above;
				FadeOut(items[i].gameObject);
			}
			if (items[i].status == LineStatus.Below && items[i].gameObject.transform.position.y > lowerBounds.y)
			{
				items[i].gameObject.SetActive(value: true);
				FadeIn(items[i].gameObject);
				items[i].status = LineStatus.Visible;
			}
		}
		if (creditsCompleted)
		{
			return;
		}
		for (int j = 0; j < items.Length; j++)
		{
			if (items[j].status != LineStatus.Above)
			{
				return;
			}
		}
		creditsCompleted = true;
		LeanTween.delayedCall(base.gameObject, 1f, NavigateBack);
	}

	private void OnDestroy()
	{
		InputManager.InputSignal.RemoveListener(OnInputSignal);
		LeanTween.cancel(base.gameObject);
	}

	private void FadeIn(GameObject go)
	{
		Text component = go.GetComponent<Text>();
		if (component != null)
		{
			LeanTween.textAlpha(component.rectTransform, 1f, 1f);
			return;
		}
		Image component2 = go.GetComponent<Image>();
		if (component2 != null)
		{
			LeanTween.alpha(component2.rectTransform, 1f, 1f);
		}
	}

	private void FadeOut(GameObject go)
	{
		Text component = go.GetComponent<Text>();
		if (component != null)
		{
			LeanTween.textAlpha(component.rectTransform, 0f, 1f);
			return;
		}
		Image component2 = go.GetComponent<Image>();
		if (component2 != null)
		{
			LeanTween.alpha(component2.rectTransform, 0f, 1f);
		}
	}
}
public class DayDreamApplicationExit : MonoBehaviour
{
	private void Start()
	{
		Input.backButtonLeavesApp = true;
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			UnityEngine.Application.Quit();
		}
	}
}
public class ContinueDialogButton : GazeButton
{
	private SpeechBubble speechBubble;

	private Vector3 startScale;

	private float wobbleSpeed = 5f;

	private float wobbleMagnitude = 0.1f;

	private void Start()
	{
		speechBubble = GetComponentInParent<SpeechBubble>();
		startScale = base.transform.localScale;
		ForceBuyQuestItem.ForceBuyQuestItemNotification.AddListener(OnTutorialNotification);
	}

	private void Update()
	{
		base.transform.localScale = startScale * (1f + Mathf.Sin(Time.timeSinceLevelLoad * wobbleSpeed) * wobbleMagnitude);
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		speechBubble.Continue();
		return PostSelectAction.WaitForLookAway;
	}

	private void OnTutorialNotification(ForceBuyEventType eventType)
	{
		if (eventType == ForceBuyEventType.BuyItem)
		{
			base.gameObject.SetActive(value: false);
		}
	}

	private void OnDestroy()
	{
		ForceBuyQuestItem.ForceBuyQuestItemNotification.RemoveListener(OnTutorialNotification);
	}
}
public class Dialog : MonoBehaviour
{
	public enum DialogType
	{
		Speechbubble,
		GuiChat
	}

	public struct Line
	{
		public string id;

		public string speaker;

		public string text;
	}

	public struct ViewEntry
	{
		private string characterId;

		private DialogView view;
	}

	public static Signal<string> SayLineNotification = new Signal<string>();

	public DialogType CurrentDialogType;

	private DialogView[] views;

	private List<Line> currentDialog;

	private string currentDialogId;

	private int currentLine;

	[@Dependency]
	public DialogSpeechbubbleStartEvent StartSpeechbubbleDialogSignal { get; set; }

	[@Dependency]
	public DialogChatStartEvent StartChatDialogSignal { get; set; }

	[@Dependency]
	public DialogAdvanceEvent AdvanceDialogSignal { get; set; }

	[@Dependency]
	public DialogEndEvent EndDialogSignal { get; set; }

	[@Dependency]
	public Localization localization { get; set; }

	private void Start()
	{
		this.Inject();
		if (CurrentDialogType == DialogType.Speechbubble)
		{
			StartSpeechbubbleDialogSignal.AddListener(StartDialog);
		}
		else
		{
			StartChatDialogSignal.AddListener(StartDialog);
		}
		views = GetComponentsInChildren<DialogView>();
		for (int i = 0; i < views.Length; i++)
		{
			views[i].Clear();
		}
	}

	private void OnDestroy()
	{
		if (StartSpeechbubbleDialogSignal != null)
		{
			StartSpeechbubbleDialogSignal.RemoveListener(StartDialog);
		}
		if (StartChatDialogSignal != null)
		{
			StartChatDialogSignal.RemoveListener(StartDialog);
		}
		if (AdvanceDialogSignal != null)
		{
			AdvanceDialogSignal.RemoveListener(Advance);
		}
	}

	public void StartDialog(string dialogId)
	{
		AdvanceDialogSignal.AddListener(Advance);
		string text = $"Dialog/Text/{localization.CurrentLanguangId}/{dialogId}";
		TextAsset textAsset = (TextAsset)Resources.Load(text);
		if (textAsset == null)
		{
			UnityEngine.Debug.LogErrorFormat("Text asset not found: {0}", text);
			currentDialog = new List<Line>();
			currentDialog.Add(new Line
			{
				id = "MissingDialog",
				speaker = "Player",
				text = "Missing dialog " + dialogId
			});
		}
		else
		{
			currentDialog = ParseDialog(dialogId, textAsset.text);
		}
		currentDialogId = dialogId;
		currentLine = 0;
		ShowLine();
	}

	public void Advance()
	{
		currentLine++;
		if (currentLine >= currentDialog.Count)
		{
			StopDialog();
			EndDialogSignal.Dispatch(currentDialogId);
			AdvanceDialogSignal.RemoveListener(Advance);
		}
		else
		{
			ShowLine();
		}
	}

	private void StopDialog()
	{
		for (int i = 0; i < views.Length; i++)
		{
			views[i].Clear();
		}
	}

	private void ShowLine()
	{
		Line line = currentDialog[currentLine];
		DialogView.LineContext lineContext = default(DialogView.LineContext);
		lineContext.isFirst = currentLine == 0;
		lineContext.isLast = currentLine == currentDialog.Count - 1;
		DialogView.LineContext context = lineContext;
		for (int i = 0; i < views.Length; i++)
		{
			views[i].Say(line, context);
		}
		SayLineNotification.Dispatch(line.id);
	}

	private List<Line> ParseDialog(string dialogId, string rawText)
	{
		string[] array = rawText.Split('\n');
		string[] array2 = array[0].Split('\t');
		List<Line> list = new List<Line>();
		for (int i = 1; i < array.Length; i++)
		{
			if (!(array[i] == string.Empty))
			{
				string[] array3 = array[i].Split('\t');
				Line line = default(Line);
				line.id = array3[0];
				line.speaker = array2[int.Parse(array3[1])];
				line.text = localization.ReplaceSpecialChars(array3[2].Replace("\\n", "\n"));
				Line item = line;
				list.Add(item);
			}
		}
		return list;
	}
}
public class DialogBackgroundSelection : DialogView
{
	public bool alwaysActive;

	private Collider selectionCollider;

	private bool closeAfterLast;

	[@Dependency]
	public Quest Quest { get; set; }

	private void Awake()
	{
		selectionCollider = Find.ComponentOnGameObject<Collider>(this);
		selectionCollider.enabled = false;
	}

	private void Start()
	{
		this.Inject();
		Quest.EnterQuestStateSignal.AddListener(OnQuestStateChanged);
		CheckTutorialState(Quest.CurrentState);
	}

	private void OnDestroy()
	{
		Quest.EnterQuestStateSignal.RemoveListener(OnQuestStateChanged);
	}

	public override void Say(Dialog.Line line, LineContext context)
	{
		selectionCollider.enabled = true;
		if (!alwaysActive && closeAfterLast && context.isLast)
		{
			selectionCollider.enabled = false;
		}
	}

	public override void Clear()
	{
		selectionCollider.enabled = false;
	}

	private void OnQuestStateChanged(QuestState state)
	{
		CheckTutorialState(state);
	}

	private void CheckTutorialState(QuestState state)
	{
		if (state.Id.Equals("TutorialShop01") || state.Id.Equals("BuyReel01") || state.Id.Equals("BuyBobber01") || state.Id.Equals("BuyBait01"))
		{
			closeAfterLast = true;
		}
	}
}
public class DialogSpeechbubbleStartEvent : Signal<string>
{
}
public class DialogChatStartEvent : Signal<string>
{
}
public class DialogAdvanceEvent : Signal
{
}
public class DialogEndEvent : Signal<string>
{
}
public class DialogImage : DialogView
{
	[Serializable]
	public struct SpeakerImageMapping
	{
		public string SpeakerId;

		public Sprite SpeakerImage;
	}

	public SpeakerImageMapping[] ImageMappings;

	public override void Say(Dialog.Line line, LineContext context)
	{
		for (int i = 0; i < ImageMappings.Length; i++)
		{
			if (ImageMappings[i].SpeakerId == line.speaker)
			{
				Image image = Find.ComponentOnGameObject<Image>(this);
				image.sprite = ImageMappings[i].SpeakerImage;
				image.SetNativeSize();
			}
		}
	}

	public override void Clear()
	{
	}
}
public abstract class DialogView : MonoBehaviour
{
	public struct LineContext
	{
		public bool isFirst;

		public bool isLast;
	}

	public abstract void Say(Dialog.Line line, LineContext context);

	public abstract void Clear();
}
public class JawAnimator : SpeechPlayback.AudioVisualizer
{
	public Transform jawJoint;

	public float closedAngle;

	public float openedAngle = 30f;

	[Tooltip("Subtract this amount from the angle to avoid tiny mouth movements")]
	[Range(0f, 0.99999f)]
	public float floor = 0.1f;

	[Tooltip("Expand (>1) or compress (<1) the jaw's angle")]
	public float expansion = 0.5f;

	public override void UpdateLoudness(float amount)
	{
		amount = Mathf.Max(amount - floor, 0f) / (1f - floor);
		amount = Mathf.Pow(amount, expansion);
		float x = closedAngle + (openedAngle - closedAngle) * amount;
		jawJoint.localRotation = Quaternion.Euler(x, 0f, 0f);
	}
}
public abstract class ShopKeeperInteraction : GazeButton
{
	public string[] greetingDialogs;

	public string[] fillerDialogs;

	public string DefaultDialogName;

	protected bool isHavingDialog;

	protected bool showingOtherUI;

	private bool hasGreeted;

	private int fillerDialogIndex;

	[@Dependency]
	public DialogSpeechbubbleStartEvent DialogStartSignal { get; set; }

	[@Dependency]
	public DialogEndEvent DialogEndSignal { get; set; }

	[@Dependency]
	public UIDisplayEvent UIDisplaySignal { get; set; }

	[@Dependency]
	public Quest quest { get; set; }

	protected abstract string QuestDialog { get; }

	private void Awake()
	{
		this.Inject();
	}

	public virtual void Start()
	{
		DialogEndSignal.AddListener(OnDialogEndSignal);
		UIDisplaySignal.AddListener(OnUIDisplaySignal);
		quest.EnterQuestStateSignal.AddListener(OnEnterQuestState);
		isHavingDialog = false;
		hasGreeted = false;
		fillerDialogIndex = UnityEngine.Random.Range(0, fillerDialogs.Length - 1);
		CheckQuestState();
	}

	private void OnUIDisplaySignal(UIEventType type)
	{
		switch (type)
		{
		case UIEventType.Display:
			showingOtherUI = true;
			break;
		case UIEventType.Remove:
			showingOtherUI = false;
			break;
		}
	}

	private void OnDialogEndSignal(string dialogId)
	{
		isHavingDialog = false;
		UIDisplaySignal.Dispatch(UIEventType.Remove);
	}

	public override bool IsSelectable(GameObject obj)
	{
		return !isHavingDialog && !showingOtherUI;
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		StartCoroutine(StartDialog());
		return PostSelectAction.WaitForLookAway;
	}

	private void OnEnterQuestState(QuestState questState)
	{
		CheckQuestState();
	}

	private void CheckQuestState()
	{
		if (quest.CurrentState.Condition is DialogCondition && QuestDialog != string.Empty)
		{
			StartCoroutine(StartDialog());
		}
	}

	private IEnumerator StartDialog()
	{
		yield return null;
		isHavingDialog = true;
		string specialDialog = QuestDialog;
		if (specialDialog != string.Empty)
		{
			DialogStartSignal.Dispatch(specialDialog);
		}
		else if (!hasGreeted)
		{
			string item = greetingDialogs[UnityEngine.Random.Range(0, greetingDialogs.Length - 1)];
			hasGreeted = true;
			DialogStartSignal.Dispatch(item);
		}
		else
		{
			string item2 = fillerDialogs[fillerDialogIndex % fillerDialogs.Length];
			fillerDialogIndex++;
			DialogStartSignal.Dispatch(item2);
		}
		UIDisplaySignal.Dispatch(UIEventType.Display);
	}

	protected virtual void OnDestroy()
	{
		DialogEndSignal.RemoveListener(OnDialogEndSignal);
		UIDisplaySignal.RemoveListener(OnUIDisplaySignal);
		quest.EnterQuestStateSignal.RemoveListener(OnEnterQuestState);
	}
}
public class ShowWhenSpeaking : DialogView
{
	public string speakerId = "Player";

	[Tooltip("Whether this component should be shown when there is no current dialog line")]
	public bool showWhenClear = true;

	public override void Say(Dialog.Line line, LineContext context)
	{
		base.gameObject.SetActive(line.speaker == speakerId);
	}

	public override void Clear()
	{
		base.gameObject.SetActive(showWhenClear);
	}
}
public class SpeechBubble : DialogView
{
	[Tooltip("Unique ID for this character, for internal use, not visible to user")]
	public string characterId;

	private TypewriterText typewriter;

	private GameObject continueButton;

	[@Dependency]
	public DialogAdvanceEvent AdvanceDialogSignal { get; set; }

	[@Dependency]
	public Localization localization { get; set; }

	private void Awake()
	{
		this.Inject();
		typewriter = GetComponentInChildren<TypewriterText>();
		continueButton = Find.ChildByName(this, "SpeechCanvas/ContinueButton");
	}

	public override void Say(Dialog.Line line, LineContext context)
	{
		if (line.speaker == characterId)
		{
			float startDelay = ((!context.isFirst) ? 0f : 1f);
			string text = localization.GetSpeakerName(line.speaker);
			if (text != string.Empty)
			{
				text += "";
			}
			typewriter.ShowText(line.text, text, startDelay);
			SetVisibility(visible: true);
		}
		else
		{
			Clear();
		}
	}

	public override void Clear()
	{
		SetVisibility(visible: false);
	}

	public void Continue()
	{
		if (typewriter.IsAnimating)
		{
			typewriter.Finish();
		}
		else
		{
			AdvanceDialogSignal.Dispatch();
		}
	}

	private void SetVisibility(bool visible)
	{
		continueButton.SetActive(visible);
		foreach (Transform item in base.transform)
		{
			item.gameObject.SetActive(visible);
		}
	}
}
public enum SpeechEventType
{
	Start,
	Stop
}
public class SpeechPlayback : DialogView
{
	public abstract class AudioVisualizer : MonoBehaviour
	{
		public abstract void UpdateLoudness(float loudness);
	}

	private enum PlaybackState
	{
		Silent,
		Playing,
		FadingOut,
		Stopped
	}

	public static Signal<SpeechEventType> SpeechAudioNotification = new Signal<SpeechEventType>();

	[Tooltip("Unique ID for this character, for internal use, not visible to user")]
	public string characterId;

	[Tooltip("Delay before starting sound")]
	public float predelay = 0.5f;

	public float fadeOutSpeed = 2f;

	public AudioSource audioSource;

	public AudioVisualizer audioVisualizer;

	private const float frameInterval = 1f / 60f;

	private PlaybackState playbackState;

	private float defaultVolume;

	private float predelayLeft;

	private AudioClip nextClip;

	private TextAsset speechData;

	private void Start()
	{
		this.Inject();
		playbackState = PlaybackState.Silent;
		defaultVolume = audioSource.volume;
	}

	public override void Say(Dialog.Line line, LineContext context)
	{
		if (line.speaker != characterId)
		{
			Interrupt();
			return;
		}
		AudioClip audioClip = (AudioClip)Resources.Load("Dialog/Sound/" + line.id);
		if (audioClip == null)
		{
			UnityEngine.Debug.LogWarning("Audio clip not found for line " + line.id);
			return;
		}
		speechData = (TextAsset)Resources.Load("Dialog/Animation/" + line.id + "Animation");
		playbackState = PlaybackState.Playing;
		predelayLeft = predelay + ((!context.isFirst) ? 0f : 1f);
		nextClip = audioClip;
	}

	public override void Clear()
	{
		Interrupt();
	}

	private void Interrupt()
	{
		if (playbackState == PlaybackState.Playing)
		{
			playbackState = PlaybackState.FadingOut;
			SpeechAudioNotification.Dispatch(SpeechEventType.Stop);
		}
		else
		{
			playbackState = PlaybackState.Silent;
		}
	}

	private void LateUpdate()
	{
		if (playbackState == PlaybackState.FadingOut)
		{
			UpdateWhenFadingOut();
		}
		else if (playbackState == PlaybackState.Playing)
		{
			UpdateWhenPlaying();
		}
	}

	private void UpdateWhenFadingOut()
	{
		if (FadeOut())
		{
			playbackState = PlaybackState.Silent;
			if (audioVisualizer != null)
			{
				audioVisualizer.UpdateLoudness(0f);
			}
		}
		else
		{
			UpdateVisualizer();
		}
	}

	private void UpdateWhenPlaying()
	{
		if (predelayLeft > 0f)
		{
			FadeOut();
			predelayLeft -= Time.deltaTime;
			if (predelayLeft <= 0f)
			{
				audioSource.clip = nextClip;
				audioSource.volume = defaultVolume;
				audioSource.Play();
				SpeechAudioNotification.Dispatch(SpeechEventType.Start);
			}
		}
		else if (!audioSource.isPlaying)
		{
			SpeechAudioNotification.Dispatch(SpeechEventType.Stop);
			playbackState = PlaybackState.Stopped;
		}
		UpdateVisualizer();
	}

	private bool FadeOut()
	{
		float num = Mathf.Max(0f, audioSource.volume - fadeOutSpeed * Time.deltaTime);
		audioSource.volume = num;
		return num == 0f;
	}

	private void UpdateVisualizer()
	{
		if (!(audioVisualizer == null))
		{
			float num2;
			if (audioSource.isPlaying)
			{
				float time = audioSource.time;
				int num = (int)(time / (1f / 60f));
				num2 = ((!(speechData == null) && num < speechData.bytes.Length) ? ((float)(int)speechData.bytes[num] / 127f) : 0f);
			}
			else
			{
				num2 = 0f;
			}
			audioVisualizer.UpdateLoudness(num2 * audioSource.volume / defaultVolume);
		}
	}
}
public class VolumeBarAnimator : SpeechPlayback.AudioVisualizer
{
	private RectTransform rectTransform;

	private float originalHeight;

	[Tooltip("Expand (>1) or compress (<1) the meter's response")]
	public float expansion = 0.5f;

	private void Start()
	{
		rectTransform = GetComponent<RectTransform>();
		originalHeight = rectTransform.rect.height;
		UpdateLoudness(0f);
	}

	public override void UpdateLoudness(float loudness)
	{
		float size = originalHeight * Mathf.Pow(loudness, expansion);
		rectTransform.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, size);
	}
}
public static class EnumHelper
{
	public static T GetEnumByName<T>(string name) where T : struct, IConvertible
	{
		if (!typeof(T).IsEnum)
		{
			throw new ArgumentException("T must be an enumerated type");
		}
		T result = default(T);
		if (name == string.Empty)
		{
			return result;
		}
		try
		{
			return (T)Enum.Parse(typeof(T), name, ignoreCase: true);
		}
		catch (Exception innerException)
		{
			throw new ArgumentException("No" + typeof(T).ToString() + "with the name: " + name + " could be found.", innerException);
		}
	}
}
public class ExclamationMark : MonoBehaviour
{
	public float wiggleSpeed;

	public float wiggleMagnitude;

	public Camera CenterCamera { get; set; }

	private void Update()
	{
		base.transform.rotation = Quaternion.Euler(new Vector3(0f, 0f, (Mathf.PingPong(Time.time * wiggleSpeed, 2f) - 1f) * wiggleMagnitude));
	}
}
[RequireComponent(typeof(FishGrabbable))]
[RequireComponent(typeof(Rigidbody))]
public class Fish : MonoBehaviour
{
	public enum SwimAnimation
	{
		Swim,
		Hooked,
		Struggle,
		PullUp
	}

	public Mesh fishMesh;

	public Material fishMaterial;

	public Mesh shadowFishMesh;

	public Material shadowFishMaterial;

	public Sprite flatImage;

	[Tooltip("The scale to be used for the shadowfish")]
	public Vector3 shadowFishScale = new Vector3(1f, 1f, 1f);

	[Tooltip("The scale of the fish when it's on the hook")]
	public Vector3 capturedScale = new Vector3(1.6f, 1.6f, 1.6f);

	[Tooltip("The scale of the fish when it's on the catch display")]
	public float CatchDisplayScale = 1f;

	public Vector3 DetailsViewScale = new Vector3(12f, 12f, 12f);

	[Tooltip("The particles used for when fish is pulled out of the water")]
	public GameObject SplashParticlesPrefab;

	[Tooltip("The particles used for when fish is pulled in and struggling")]
	public GameObject StruggleParticlesPrefab;

	[Tooltip("The particles used for when fish is thrown on terrain")]
	public GameObject PuffParticlePrefab;

	[Tooltip("The particles used for the water splash")]
	public GameObject waterRingsPrefab;

	[Tooltip("Drag of fish when pulled out of water.")]
	public float pullUpDrag = 0.5f;

	[NonSerialized]
	public float weight;

	private Rigidbody rigidbodyComponent;

	private SkinnedMeshRenderer skinnedMeshRenderer;

	private Animation fishAnimation;

	private SwimAnimation? currentAnimation;

	private AnimationState currentAnimationState;

	private Dictionary<int, string> swimAnimations;

	private FishGrabbable grabbable;

	private static bool hasSplashed;

	public FishData FishData { get; set; }

	[@Dependency]
	public FishingRodEvent FishingRodSignal { get; set; }

	private void Awake()
	{
		skinnedMeshRenderer = GetComponentInChildren<SkinnedMeshRenderer>();
		fishAnimation = base.gameObject.GetComponent<Animation>();
		swimAnimations = new Dictionary<int, string>();
		InitializeAnimations();
	}

	private void Start()
	{
		this.Inject();
		bool flag = false;
		if (FishData == null)
		{
			flag = true;
			FishData = new FishData(FishType.AlligatorPerch, "test", FishRarity.Common, 1f, 2f, 1f, 1f, 1f, 2f, string.Empty, 1, 1, 1, 1, 1f, 1f, 1f, 1f, 1f, 1f, 1f, 1, 1, 1f, 1f, 1f, 1f, 1f, 1f, 1f, 1f, 1f, 1f, 1f, 1f, 1f, 1f);
		}
		weight = FishData.GetRandomWeight();
		rigidbodyComponent = base.gameObject.GetComponent<Rigidbody>();
		rigidbodyComponent.mass = FishData.physicsMass;
		rigidbodyComponent.drag = FishData.physicsDrag;
		rigidbodyComponent.centerOfMass = new Vector3(0f, 0f, -0.2f);
		if (flag)
		{
			ShowAsRealFish();
		}
		grabbable = base.gameObject.GetComponent<FishGrabbable>();
		grabbable.Setup(this, flag);
	}

	private void OnEnable()
	{
		hasSplashed = false;
		if (!(grabbable != null) || grabbable.FishColliders == null)
		{
			return;
		}
		foreach (Collider fishCollider in grabbable.FishColliders)
		{
			if (fishCollider != null)
			{
				fishCollider.gameObject.layer = 28;
			}
		}
	}

	public void ShowAsShadow()
	{
		skinnedMeshRenderer.sharedMesh = fishMesh;
		skinnedMeshRenderer.sharedMaterial = fishMaterial;
		base.transform.localScale = capturedScale;
	}

	public void ShowAsRealFish()
	{
		skinnedMeshRenderer.sharedMesh = fishMesh;
		skinnedMeshRenderer.sharedMaterial = fishMaterial;
		base.transform.localScale = capturedScale;
	}

	public void AttachToHook(Rigidbody hookBody)
	{
		base.transform.position = hookBody.transform.position;
		rigidbodyComponent.isKinematic = false;
		rigidbodyComponent.constraints = (RigidbodyConstraints)84;
		FixedJoint fixedJoint = base.gameObject.AddComponent<FixedJoint>();
		fixedJoint.connectedBody = hookBody;
	}

	public void ReleaseFromHook()
	{
		UnityEngine.Object.Destroy(GetComponent<FixedJoint>());
		rigidbodyComponent.isKinematic = true;
		rigidbodyComponent.constraints = RigidbodyConstraints.None;
	}

	public void AllowPullup()
	{
		rigidbodyComponent.constraints = RigidbodyConstraints.FreezeRotation;
		foreach (Collider fishCollider in grabbable.FishColliders)
		{
			if (fishCollider != null)
			{
				fishCollider.gameObject.layer = 8;
			}
		}
	}

	public void AssistPullup()
	{
		rigidbodyComponent.useGravity = true;
		rigidbodyComponent.drag = pullUpDrag;
		rigidbodyComponent.transform.eulerAngles = new Vector3(0f, 0f, 0f);
		FishingRodSignal.Dispatch(FishingRodEventType.StopCranking);
	}

	public bool TrySplashIntoWater()
	{
		if (SingleInstanceBehavior<WaterArea>.Instance.IsInside(base.transform.position))
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(SplashParticlesPrefab, base.transform);
			gameObject.transform.rotation = Quaternion.identity;
			FishBehavior.FishSignal.Dispatch(FishEventType.FallIntoWater, this);
			StartCoroutine(SpawnWaterRing());
			return true;
		}
		return false;
	}

	private IEnumerator SpawnWaterRing()
	{
		GameObject waterRings = UnityEngine.Object.Instantiate(waterRingsPrefab, new Vector3(base.transform.position.x, 0f, base.transform.position.z), Quaternion.identity);
		ParticleSystem splashParticleSystem = waterRings.GetComponentInChildren<ParticleSystem>();
		while (splashParticleSystem.IsAlive())
		{
			yield return null;
		}
		UnityEngine.Object.Destroy(waterRings);
	}

	public void SplashOnLand()
	{
		UnityEngine.Object.Instantiate(PuffParticlePrefab, new Vector3(base.transform.position.x, base.transform.position.y - 0.3f, base.transform.position.z), Quaternion.identity);
		FishBehavior.FishSignal.Dispatch(FishEventType.FallOnBeach, this);
	}

	private void InitializeAnimations()
	{
		int num = 0;
		foreach (AnimationState item in fishAnimation)
		{
			swimAnimations.Add(num, item.name);
			num++;
		}
	}

	public void ChangeAnimation(SwimAnimation newAnimation, float animationSpeed)
	{
		string animation = swimAnimations[(int)newAnimation];
		if (currentAnimation == newAnimation)
		{
			currentAnimationState.speed = animationSpeed;
			return;
		}
		fishAnimation.Stop();
		currentAnimationState = fishAnimation[animation];
		currentAnimationState.speed = animationSpeed;
		fishAnimation.Play(animation);
		currentAnimation = newAnimation;
	}

	public void StopAnimation()
	{
		currentAnimationState.speed = 0f;
	}

	public void PlayCatchAnimation(SwimAnimation newAnimation, float speed)
	{
		ChangeAnimation(newAnimation, speed);
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (grabbable.IsThrown && !hasSplashed)
		{
			hasSplashed = true;
			StartCoroutine(DestroyMe());
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (grabbable.IsThrown && other.gameObject.layer == 4 && !hasSplashed)
		{
			TrySplashIntoWater();
			hasSplashed = true;
			base.transform.GetComponentInChildren<SkinnedMeshRenderer>().enabled = false;
			UnityEngine.Object.Destroy(base.gameObject, 1f);
		}
	}

	private IEnumerator DestroyMe()
	{
		SplashOnLand();
		base.transform.GetComponentInChildren<SkinnedMeshRenderer>().enabled = false;
		yield return new WaitForSeconds(1f);
		FishBehavior.FishSignal.Dispatch(FishEventType.FallIntoWater, this);
		UnityEngine.Object.Destroy(base.gameObject, 0f);
	}

	static Fish()
	{
	}
}
public enum FishEventType
{
	Approach,
	Nibble,
	Hook,
	CaptureBegin,
	CaptureStruggle,
	CaptureFatigue,
	CaptureEnd,
	EscapeHook,
	MoveAwayFromSinker,
	PullUpFromWater,
	FallIntoWater,
	FallOnBeach
}
public class FishBehavior
{
	private abstract class FishState
	{
		public virtual void Enter(FishBehavior behavior, Fish fish)
		{
		}

		public virtual void Update(FishBehavior behavior, Fish fish)
		{
		}

		public virtual void FixedUpdate(FishBehavior behavior, Fish fish)
		{
		}

		public virtual void OnTensionMeterSignal(FishBehavior behavior, Fish fish, TensionMeter.TensionMeterEventType eventType)
		{
		}

		public virtual void OnReelIn(FishBehavior behavior, Fish fish)
		{
		}

		public virtual void OnJerk(FishBehavior behavior, Fish fish)
		{
		}

		public virtual void OnAutoReelIn(FishBehavior behavior, Fish fish)
		{
		}

		public virtual void Exit(FishBehavior behavior, Fish fish)
		{
		}

		public virtual void Lure(FishBehavior behavior, Fish fish, Hook hook)
		{
		}
	}

	private class TutorialMoveState : FishState
	{
		private Vector3 targetPosition;

		public override void Enter(FishBehavior behavior, Fish fish)
		{
			fish.ChangeAnimation(Fish.SwimAnimation.Swim, GetAnimationSpeedFromSwimSpeed(fish.FishData.maxSpeed));
		}

		public override void Update(FishBehavior behavior, Fish fish)
		{
			targetPosition = behavior.TutorialMoveTarget.transform.position;
			targetPosition.y = fish.FishData.swimDepth;
			fish.gameObject.transform.LookAt(targetPosition);
			fish.transform.position += fish.transform.forward * Time.deltaTime * fish.FishData.maxSpeed;
		}

		public override void Lure(FishBehavior behavior, Fish fish, Hook hookComponent)
		{
			behavior.Bait(hookComponent);
		}
	}

	private class RoamingState : FishState
	{
		private float sprintSpeed;

		private float sprintTime;

		private float sprintLength;

		private float swimDepth;

		private const float depthRandomness = 0.15f;

		private Swimming swimming;

		private bool showingSprintAnimation;

		private const float minSprintAnimationTime = 1f;

		private const float verticalMovementSpeed = 2f;

		public override void Enter(FishBehavior behavior, Fish fish)
		{
			StartSprint(behavior, fish);
			swimDepth = UnityEngine.Random.Range(fish.FishData.swimDepth - 0.15f, fish.FishData.swimDepth + 0.15f);
		}

		private void StartSprint(FishBehavior behavior, Fish fish)
		{
			sprintSpeed = UnityEngine.Random.Range(1f, fish.FishData.maxSpeed);
			swimming = new Swimming(fish.transform, behavior.swimArea.GetRandomPoint());
			fish.ChangeAnimation(Fish.SwimAnimation.Swim, GetAnimationSpeedFromSwimSpeed(sprintSpeed));
			showingSprintAnimation = true;
			sprintLength = 2f * UnityEngine.Random.Range(fish.FishData.intervalMeanTime - fish.FishData.intervalRandomness, fish.FishData.intervalMeanTime + fish.FishData.intervalRandomness);
			sprintTime = 0f;
		}

		public override void Update(FishBehavior behavior, Fish fish)
		{
			sprintTime += Time.deltaTime;
			if (sprintTime >= sprintLength)
			{
				StartSprint(behavior, fish);
			}
			swimming.UpdateKinematic(sprintSpeed);
			if (showingSprintAnimation && sprintTime > 1f && swimming.IsSlowingDown())
			{
				fish.ChangeAnimation(Fish.SwimAnimation.Swim, fish.FishData.idleAnimationSpeed);
				showingSprintAnimation = false;
			}
			Vector3 position = fish.transform.position;
			fish.transform.position = new Vector3(position.x, Mathf.MoveTowards(position.y, swimDepth, Time.deltaTime * 2f), position.z);
		}

		public override void Lure(FishBehavior behavior, Fish fish, Hook hookComponent)
		{
			behavior.Bait(hookComponent);
		}
	}

	private class ApproachingState : FishState
	{
		private Swimming swimming;

		public override void Enter(FishBehavior behavior, Fish fish)
		{
			fish.ChangeAnimation(Fish.SwimAnimation.Swim, GetAnimationSpeedFromSwimSpeed(fish.FishData.moveToHookSpeed));
			FishSignal.Dispatch(FishEventType.Approach, fish);
			swimming = new Swimming(fish.transform, Swimming.PositionTo2D(behavior.GetHookPosition()));
			swimming.minDistance = fish.FishData.nibbleDistance;
		}

		public override void Update(FishBehavior behavior, Fish fish)
		{
			if (!behavior.IsHookInteresting())
			{
				behavior.hook.Free(behavior);
				behavior.ChangeState(behavior.roamingState);
				return;
			}
			Vector3 hookPosition = behavior.GetHookPosition();
			swimming.targetPoint = Swimming.PositionTo2D(hookPosition);
			swimming.UpdateKinematic(fish.FishData.moveToHookSpeed);
			if (swimming.IsSlowingDown())
			{
				behavior.ChangeState(behavior.nibbleState);
			}
		}

		public override void OnReelIn(FishBehavior behavior, Fish fish)
		{
			if (!behavior.tutorialMode)
			{
				behavior.tracking.TrackPullBobber("early", fish);
				BobberHintSignal.Dispatch(BobberHintType.tooEarly);
				behavior.MoveAwayFromHook();
			}
		}

		public override void OnJerk(FishBehavior behavior, Fish fish)
		{
			if (!behavior.tutorialMode)
			{
				behavior.tracking.TrackFish("too_early", fish);
				BobberHintSignal.Dispatch(BobberHintType.tooEarly);
				behavior.MoveAwayFromHook();
			}
		}
	}

	private class NibblingState : FishState
	{
		private Vector3 fishStartPosition;

		private Quaternion lookAtHookRotation;

		private Vector3 hookStartPosition;

		private int currNibbleCount;

		private int totalNibbleCount;

		public override void Enter(FishBehavior behavior, Fish fish)
		{
			behavior.nibbleStartRotation = fish.transform.rotation;
			lookAtHookRotation = Quaternion.LookRotation(behavior.GetHookPosition() - fish.transform.position);
			hookStartPosition = behavior.hook.transform.position;
			totalNibbleCount = UnityEngine.Random.Range(fish.FishData.minNumNibbles, fish.FishData.maxNumNibbles);
			currNibbleCount = 0;
			fishStartPosition = fish.transform.position;
			if (currNibbleCount < totalNibbleCount)
			{
				StartNewNibble(behavior, fish);
			}
		}

		public override void Update(FishBehavior behavior, Fish fish)
		{
			if (!behavior.IsHookInteresting())
			{
				behavior.MoveAwayFromHook();
				return;
			}
			if (currNibbleCount >= totalNibbleCount)
			{
				behavior.ChangeState(behavior.hookedState);
				return;
			}
			if (behavior.IntervalHasEnded())
			{
				StartNewNibble(behavior, fish);
				return;
			}
			float num = Mathf.Clamp01((Time.time - behavior.intervalStartTime) / behavior.intervalTime / fish.FishData.nibbleFraction);
			float num2 = Mathf.Sin(num * (float)Math.PI);
			fish.transform.position = fishStartPosition + fish.transform.forward * num2 * 0.2f;
			fish.transform.rotation = Quaternion.Lerp(behavior.nibbleStartRotation, lookAtHookRotation, num2);
			behavior.hook.transform.position = hookStartPosition + num2 * behavior.hook.nibbleDisplacement;
		}

		private void StartNewNibble(FishBehavior behavior, Fish fish)
		{
			currNibbleCount++;
			FishSignal.Dispatch(FishEventType.Nibble, fish);
			behavior.StartNewInterval(fish.FishData.nibbleLength, fish.FishData.nibbleRandomness);
		}

		public override void OnReelIn(FishBehavior behavior, Fish fish)
		{
			if (!behavior.tutorialMode)
			{
				if (currNibbleCount > 0)
				{
					behavior.tracking.TrackPullBobber("early", fish);
					BobberHintSignal.Dispatch(BobberHintType.tooEarly);
				}
				behavior.MoveAwayFromHook();
			}
		}

		public override void OnJerk(FishBehavior behavior, Fish fish)
		{
			if (!behavior.tutorialMode)
			{
				if (currNibbleCount > 0)
				{
					behavior.tracking.TrackFish("too_early", fish);
					BobberHintSignal.Dispatch(BobberHintType.tooEarly);
				}
				behavior.MoveAwayFromHook();
			}
		}
	}

	private class HookedState : FishState
	{
		private Vector3 fishStartPosition;

		private Quaternion fishStartRotation;

		private Vector3 hookStartPosition;

		private Quaternion lookAtHookRotation;

		public override void Enter(FishBehavior behavior, Fish fish)
		{
			fishStartPosition = fish.transform.position;
			fishStartRotation = fish.transform.rotation;
			hookStartPosition = behavior.hook.transform.position;
			lookAtHookRotation = Quaternion.LookRotation(behavior.GetHookPosition() - fish.transform.position);
			float hookedLengthMultiplier = behavior.hook.bobber.GetComponent<Bobber>().hookedLengthMultiplier;
			behavior.StartNewInterval(fish.FishData.hookedLength * hookedLengthMultiplier, 0f);
			fish.ChangeAnimation(Fish.SwimAnimation.Hooked, 1.5f);
			behavior.hook.GetComponent<Rigidbody>().isKinematic = true;
			FishSignal.Dispatch(FishEventType.Hook, fish);
		}

		public override void Update(FishBehavior behavior, Fish fish)
		{
			float t = Mathf.Clamp01((Time.time - behavior.intervalStartTime) * behavior.swallowLengthMultiplier);
			behavior.hook.transform.position = Vector3.Lerp(hookStartPosition, hookStartPosition + behavior.hook.hookedDisplacement, t);
			fish.transform.position = Vector3.Lerp(fishStartPosition, behavior.hook.transform.position, t);
			fish.transform.rotation = Quaternion.Lerp(fishStartRotation, lookAtHookRotation, t);
			if (behavior.IntervalHasEnded() && !behavior.tutorialMode)
			{
				behavior.hook.transform.position = hookStartPosition;
				behavior.MoveAwayFromHook();
				behavior.tracking.TrackPullBobber("late", fish);
				BobberHintSignal.Dispatch(BobberHintType.tooLate);
			}
		}

		public override void Exit(FishBehavior behavior, Fish fish)
		{
			behavior.hook.GetComponent<Rigidbody>().isKinematic = false;
		}

		public override void OnReelIn(FishBehavior behavior, Fish fish)
		{
			behavior.BeginCapture(reeledIn: true);
			behavior.ChangeState(behavior.capturedStruggleState);
		}

		public override void OnJerk(FishBehavior behavior, Fish fish)
		{
			behavior.BeginCapture(reeledIn: false);
			behavior.ChangeState(behavior.capturedStruggleState);
		}
	}

	private class CapturedStruggleState : FishState
	{
		private float startTime;

		private Swimming swimming;

		public override void Enter(FishBehavior behavior, Fish fish)
		{
			swimming = new Swimming(fish.transform, behavior.escapeArea.GetRandomPoint());
			startTime = Time.time;
			fish.ChangeAnimation(Fish.SwimAnimation.Struggle, 1.3f);
			FishSignal.Dispatch(FishEventType.CaptureStruggle, fish);
			behavior.StartNewInterval(fish.FishData.rushTime, fish.FishData.rushRandomness);
		}

		public override void Update(FishBehavior behavior, Fish fish)
		{
			if (!behavior.tutorialMode)
			{
				if (behavior.captureIdleTime > behavior.captureIdleTimeout)
				{
					BobberHintSignal.Dispatch(BobberHintType.idle);
					behavior.tracking.TrackReeling("not_enough", fish);
					behavior.EscapeHook();
				}
				else if (behavior.beingReeledIn)
				{
					behavior.stamina -= behavior.hook.reel.ReelTensionWithFish * behavior.staminaDecay * Time.deltaTime;
				}
				else
				{
					behavior.captureIdleTime += Time.deltaTime;
				}
			}
		}

		public override void FixedUpdate(FishBehavior behavior, Fish fish)
		{
			if (behavior.IntervalHasEnded())
			{
				behavior.ChangeState(behavior.capturedFatigueState);
				return;
			}
			float num = Time.time - startTime;
			float num2 = num / Mathf.Max(0.01f, fish.FishData.rushTime);
			float maxForce = num2 * fish.FishData.struggleForce;
			swimming.UpdatePhysics(fish.GetComponent<Rigidbody>(), maxForce);
			if (swimming.HasArrived())
			{
				behavior.ChangeState(behavior.capturedFatigueState);
			}
		}

		public override void OnTensionMeterSignal(FishBehavior behavior, Fish fish, TensionMeter.TensionMeterEventType eventType)
		{
			if (!behavior.tutorialMode && eventType == TensionMeter.TensionMeterEventType.Full)
			{
				behavior.tracking.TrackReeling("too_much", fish);
				behavior.EscapeHook();
				BobberHintSignal.Dispatch(BobberHintType.lineBreak);
			}
		}

		public override void OnReelIn(FishBehavior behavior, Fish fish)
		{
			behavior.captureIdleTime = 0f;
			behavior.beingReeledIn = true;
		}

		public override void OnAutoReelIn(FishBehavior behavior, Fish fish)
		{
			behavior.ChangeState(behavior.capturedEndState);
		}
	}

	private class CapturedFatigueState : FishState
	{
		private const float torqueAmount = 0.1f;

		private const float maxTorque = 13f;

		public override void Enter(FishBehavior behavior, Fish fish)
		{
			fish.ChangeAnimation(Fish.SwimAnimation.Struggle, fish.FishData.struggleAnimationSpeed);
			FishSignal.Dispatch(FishEventType.CaptureFatigue, fish);
			behavior.StartNewInterval(fish.FishData.fatigueTime * 2.5f, fish.FishData.fatigueRandomness);
		}

		public override void Update(FishBehavior behavior, Fish fish)
		{
			if (behavior.IntervalHasEnded() && behavior.stamina > 0f)
			{
				behavior.ChangeState(behavior.capturedStruggleState);
			}
			if (behavior.tutorialMode)
			{
				return;
			}
			if (behavior.beingReeledIn)
			{
				FishingLine fishingLine = behavior.hook.fishingLine;
				Vector3 vector = fishingLine.playerTranform.position - fish.transform.position;
				float target = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
				float num = Mathf.DeltaAngle(fish.transform.rotation.eulerAngles.y, target);
				float num2 = Mathf.Clamp(num * 0.1f, -13f, 13f);
				fish.GetComponent<Rigidbody>().AddTorque(Vector3.up * num2);
				if (vector.magnitude < fishingLine.autoReelinDistancePlayer * 2f && behavior.stamina > 0f)
				{
					behavior.ChangeState(behavior.capturedStruggleState);
				}
			}
			else
			{
				behavior.captureIdleTime += Time.deltaTime;
				if (behavior.captureIdleTime > behavior.captureIdleTimeout && !behavior.beingReeledIn)
				{
					BobberHintSignal.Dispatch(BobberHintType.idle);
					behavior.tracking.TrackReeling("not_enough", fish);
					behavior.EscapeHook();
				}
			}
		}

		public override void OnTensionMeterSignal(FishBehavior behavior, Fish fish, TensionMeter.TensionMeterEventType eventType)
		{
			if (eventType == TensionMeter.TensionMeterEventType.Full)
			{
				behavior.tracking.TrackReeling("too_much", fish);
				behavior.EscapeHook();
				BobberHintSignal.Dispatch(BobberHintType.lineBreak);
			}
		}

		public override void OnReelIn(FishBehavior behavior, Fish fish)
		{
			behavior.captureIdleTime = 0f;
			behavior.beingReeledIn = true;
		}

		public override void OnAutoReelIn(FishBehavior behavior, Fish fish)
		{
			behavior.ChangeState(behavior.capturedEndState);
		}
	}

	private class CapturedEndState : FishState
	{
		private bool isUnderWater;

		private Rigidbody body;

		public override void Enter(FishBehavior behavior, Fish fish)
		{
			isUnderWater = true;
			behavior.hook.AllowPullup();
			body = fish.GetComponent<Rigidbody>();
			FishSignal.Dispatch(FishEventType.CaptureEnd, fish);
		}

		public override void Update(FishBehavior behavior, Fish fish)
		{
			float y = fish.transform.position.y;
			float y2 = body.velocity.y;
			if (y >= 0f && isUnderWater)
			{
				isUnderWater = false;
				fish.ChangeAnimation(Fish.SwimAnimation.PullUp, 1f);
				if (y2 > 0.3f)
				{
					FishSignal.Dispatch(FishEventType.PullUpFromWater, fish);
					GameObject gameObject = UnityEngine.Object.Instantiate(fish.SplashParticlesPrefab, fish.transform.position, Quaternion.identity);
					gameObject.transform.parent = fish.transform;
				}
				fish.AssistPullup();
			}
			if (y <= 0f && !isUnderWater)
			{
				isUnderWater = true;
				if (y2 < -0.3f)
				{
					fish.TrySplashIntoWater();
				}
			}
		}
	}

	public static Signal<FishEventType, Fish> FishSignal = new Signal<FishEventType, Fish>();

	public static Signal<BobberHintType> BobberHintSignal = new Signal<BobberHintType>();

	public Fish fish;

	private FlatPolygon swimArea;

	private FlatPolygon escapeArea;

	private bool tutorialMode;

	private TutorialMoveState tutorialMoveState;

	private RoamingState roamingState;

	private ApproachingState approachingState;

	private NibblingState nibbleState;

	private HookedState hookedState;

	private CapturedStruggleState capturedStruggleState;

	private CapturedFatigueState capturedFatigueState;

	private CapturedEndState capturedEndState;

	private float lastMoveAwayTime;

	private const float disinterestedTime = 10f;

	private float intervalTime;

	private float intervalStartTime;

	private FishState fishState;

	private Quaternion targetRotation;

	private Quaternion nibbleStartRotation;

	private float swallowLengthMultiplier = 8f;

	private float captureIdleTimeout = 5f;

	private float captureIdleTime;

	private float staminaDecay = 10f;

	private Hook hook;

	private bool beingReeledIn;

	private bool rodReelingIn;

	private float stamina;

	public Vector3 SpawnPoint { get; set; }

	public GameObject TutorialMoveTarget { get; set; }

	public RGTracking tracking { get; internal set; }

	public FishBehavior(Fish fish, FlatPolygon swimArea, FlatPolygon escapeArea)
	{
		this.fish = fish;
		this.swimArea = swimArea;
		this.escapeArea = escapeArea;
		tutorialMoveState = new TutorialMoveState();
		roamingState = new RoamingState();
		approachingState = new ApproachingState();
		nibbleState = new NibblingState();
		hookedState = new HookedState();
		capturedStruggleState = new CapturedStruggleState();
		capturedFatigueState = new CapturedFatigueState();
		capturedEndState = new CapturedEndState();
		stamina = fish.FishData.GetStamina(fish.weight);
		beingReeledIn = false;
		rodReelingIn = false;
	}

	public string GetDebugInfo()
	{
		return fish.FishData.name + "\n" + fishState.GetType().Name;
	}

	public void SetFishAsCaughtDebug()
	{
		stamina = 0f;
	}

	public void StartInNormalMode()
	{
		tutorialMode = false;
		ChangeState(roamingState);
		fish.ShowAsShadow();
	}

	public void StartInTutorialMode(GameObject target)
	{
		tutorialMode = true;
		TutorialMoveTarget = target;
		ChangeState(tutorialMoveState);
		fish.ShowAsShadow();
	}

	public void Update()
	{
		fishState.Update(this, fish);
	}

	public void FixedUpdate()
	{
		fishState.FixedUpdate(this, fish);
	}

	private void ChangeState(FishState newState)
	{
		if (fishState != null)
		{
			fishState.Exit(this, fish);
		}
		fishState = newState;
		newState.Enter(this, fish);
	}

	private void StartNewInterval(float intervalLength, float lengthVariation)
	{
		intervalStartTime = Time.time;
		intervalTime = Mathf.Max(0f, intervalLength + UnityEngine.Random.Range(0f - lengthVariation, lengthVariation));
	}

	private bool IntervalHasEnded()
	{
		return Time.time - intervalStartTime >= intervalTime;
	}

	public void OnFishingRodSignal(FishingRodEventType type)
	{
		switch (type)
		{
		case FishingRodEventType.StartReelInWithoutFish:
		case FishingRodEventType.StartReelInWithFish:
			fishState.OnReelIn(this, fish);
			rodReelingIn = true;
			break;
		case FishingRodEventType.JerkRodWithFish:
		case FishingRodEventType.JerkRodWithoutFish:
			fishState.OnJerk(this, fish);
			break;
		case FishingRodEventType.StartAutoReelIn:
			fishState.OnAutoReelIn(this, fish);
			break;
		case FishingRodEventType.StopReelIn:
			beingReeledIn = false;
			rodReelingIn = false;
			break;
		}
	}

	public void OnTensionMeterSignal(TensionMeter.TensionMeterEventType eventType)
	{
		fishState.OnTensionMeterSignal(this, fish, eventType);
	}

	public override string ToString()
	{
		return "FishBehavior " + fish.name;
	}

	private Vector3 GetHookPosition()
	{
		Vector3 position = hook.transform.position;
		return new Vector3(position.x, fish.transform.position.y, position.z);
	}

	private bool IsHookInteresting()
	{
		return hook.transform.position.y < 0f;
	}

	public bool CanBeCaptured()
	{
		return fishState is HookedState;
	}

	private void BeginCapture(bool reeledIn)
	{
		hook.HookFish();
		fish.ShowAsRealFish();
		captureIdleTime = 0f;
		beingReeledIn = reeledIn || rodReelingIn;
		FishSignal.Dispatch(FishEventType.CaptureBegin, fish);
	}

	private void EscapeHook()
	{
		fish.ShowAsShadow();
		fish.transform.rotation = Quaternion.Euler(0f, fish.transform.rotation.eulerAngles.y, 0f);
		FishSignal.Dispatch(FishEventType.EscapeHook, fish);
		stamina = fish.FishData.GetStamina(fish.weight);
		MoveAwayFromHook();
	}

	private void MoveAwayFromHook()
	{
		hook.Free(this);
		lastMoveAwayTime = Time.time;
		FishSignal.Dispatch(FishEventType.MoveAwayFromSinker, fish);
		ChangeState(roamingState);
	}

	private void Bait(Hook hookComponent)
	{
		hook = hookComponent;
		hookComponent.Allocate(this);
		tracking.TrackFish("approach", fish);
		ChangeState(approachingState);
	}

	public void Lure(Hook hook)
	{
		float num = Time.time - lastMoveAwayTime;
		if (!(num < 10f))
		{
			fishState.Lure(this, fish, hook);
		}
	}

	private static float GetAnimationSpeedFromSwimSpeed(float swimSpeed)
	{
		return 1f + swimSpeed * 3f;
	}
}
public class FishData
{
	public readonly FishType fishType;

	public readonly string name;

	public readonly FishRarity fishRarity;

	public readonly float minWeight;

	public readonly float maxWeight;

	public readonly float physicsMass;

	public readonly float physicsDrag;

	private readonly float twoStarLimit;

	private readonly float threeStarLimit;

	public readonly string description;

	public readonly int worth;

	public readonly int twoStarBonus;

	public readonly int threeStarBonus;

	public readonly int newRecordBonus;

	public readonly float maxSpeed;

	public readonly float swimDepth;

	public readonly float deceleration;

	public readonly float intervalMeanTime;

	public readonly float intervalRandomness;

	public readonly float turnStrength;

	public readonly float idleAnimationSpeed;

	public readonly int minNumNibbles;

	public readonly int maxNumNibbles;

	public readonly float moveToHookSpeed;

	public readonly float nibbleDistance;

	public readonly float nibbleFraction;

	public readonly float nibbleLength;

	public readonly float nibbleRandomness;

	public readonly float hookedLength;

	public readonly float rushTime;

	public readonly float rushRandomness;

	public readonly float fatigueTime;

	public readonly float fatigueRandomness;

	public readonly float struggleForce;

	public readonly float struggleTorque;

	public readonly float struggleAnimationSpeed;

	public readonly float struggleStamina;

	private readonly float twoStarWeight;

	private readonly float threeStarWeight;

	public float TwoStarWeight => twoStarWeight;

	public float ThreeStarWeight => threeStarWeight;

	public FishData(FishType fishType, string name, FishRarity fishRarity, float minWeight, float maxWeight, float physicsMass, float physicsDrag, float twoStarLimit, float threeStarLimit, string description, int worth, int twoStarBonus, int threeStarBonus, int newRecordBonus, float maxSpeed, float swimDepth, float deceleration, float intervalMeanTime, float intervalRandomness, float turnStrength, float idleAnimationSpeed, int minNumNibbles, int maxNumNibbles, float moveToHookSpeed, float nibbleDistance, float nibbleFraction, float nibbleLength, float nibbleRandomness, float hookedLength, float rushTime, float rushRandomness, float fatigueTime, float fatigueRandomness, float struggleForce, float struggleTorque, float struggleAnimationSpeed, float struggleStamina)
	{
		this.fishType = fishType;
		this.name = name;
		this.fishRarity = fishRarity;
		this.minWeight = minWeight;
		this.maxWeight = maxWeight;
		this.physicsMass = physicsMass;
		this.physicsDrag = physicsDrag;
		this.description = description;
		this.worth = worth;
		this.twoStarBonus = twoStarBonus;
		this.threeStarBonus = threeStarBonus;
		this.newRecordBonus = newRecordBonus;
		this.maxSpeed = maxSpeed;
		this.swimDepth = swimDepth;
		this.deceleration = deceleration;
		this.intervalMeanTime = intervalMeanTime;
		this.intervalRandomness = intervalRandomness;
		this.turnStrength = turnStrength;
		this.idleAnimationSpeed = idleAnimationSpeed;
		this.minNumNibbles = minNumNibbles;
		this.maxNumNibbles = maxNumNibbles;
		this.moveToHookSpeed = moveToHookSpeed;
		this.nibbleDistance = nibbleDistance;
		this.nibbleFraction = nibbleFraction;
		this.nibbleLength = nibbleLength;
		this.nibbleRandomness = nibbleRandomness;
		this.hookedLength = hookedLength;
		this.rushTime = rushTime;
		this.rushRandomness = rushRandomness;
		this.fatigueTime = fatigueTime;
		this.fatigueRandomness = fatigueRandomness;
		this.struggleForce = struggleForce;
		this.struggleTorque = struggleTorque;
		this.struggleAnimationSpeed = struggleAnimationSpeed;
		this.struggleStamina = struggleStamina;
		twoStarWeight = RoundWeight(Mathf.LerpUnclamped(minWeight, maxWeight, twoStarLimit));
		threeStarWeight = RoundWeight(Mathf.LerpUnclamped(minWeight, maxWeight, threeStarLimit));
	}

	public FishStar GetStarRating(float weight)
	{
		if (weight > ThreeStarWeight)
		{
			return FishStar.Three;
		}
		if (weight > TwoStarWeight)
		{
			return FishStar.Two;
		}
		return FishStar.One;
	}

	public float GetStamina(float weight)
	{
		FishStar starRating = GetStarRating(weight);
		return struggleStamina * starRating switch
		{
			FishStar.Two => 1.1f, 
			FishStar.Three => 1.2f, 
			_ => 1f, 
		};
	}

	public float GetRandomWeight()
	{
		return RoundWeight(UnityEngine.Random.Range(minWeight, maxWeight));
	}

	public static float RoundWeight(float weight)
	{
		return Mathf.Round(weight * 100f) / 100f;
	}
}
public class FishDebug : MonoBehaviour
{
	public FishBehavior behavior;

	private void Update()
	{
		TextMesh component = GetComponent<TextMesh>();
		component.text = behavior.GetDebugInfo();
		base.transform.forward = base.transform.position - Camera.main.transform.position;
	}
}
public class FishDisplay : MonoBehaviour
{
	public float fishRotationAmount = 40f;

	public bool rotate;

	private GameObject spawnedFish;

	private bool fishIsVisible;

	private void Start()
	{
	}

	public void ShowFishWithOffset(Fish fish, Vector3 offset)
	{
		ShowFish(fish);
		spawnedFish.transform.localPosition += offset;
	}

	private void Update()
	{
		if (rotate && fishIsVisible)
		{
			float y = (Mathf.Sin(Time.timeSinceLevelLoad) + 1f) * (fishRotationAmount / 2f);
			base.transform.localRotation = Quaternion.Euler(0f, y, 0f);
		}
	}

	public void ShowFish(Fish fish)
	{
		base.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
		Fish fish2 = SpawnNewFish(fish.FishData.fishType);
		fish2.ChangeAnimation(Fish.SwimAnimation.Swim, 1f);
		spawnedFish = fish2.gameObject;
		Renderer componentInChildren = spawnedFish.GetComponentInChildren<Renderer>();
		Vector3 center = componentInChildren.bounds.center;
		Vector3 vector = spawnedFish.transform.InverseTransformPoint(center);
		spawnedFish.transform.localPosition = new Vector3(0f - vector.z, 0f, 0f);
		spawnedFish.transform.localRotation = Quaternion.Euler(0f, 95f, 0f);
		fishIsVisible = true;
	}

	private Fish SpawnNewFish(FishType type)
	{
		GameObject fishPrefab = FishRegistry.Instance.GetFishPrefab(type);
		FishData fishDatabyType = FishRegistry.Instance.GetFishDatabyType(type);
		GameObject gameObject = UnityEngine.Object.Instantiate(fishPrefab);
		Fish component = gameObject.GetComponent<Fish>();
		component.FishData = fishDatabyType;
		gameObject.transform.SetParent(base.transform);
		gameObject.transform.localScale = Vector3.one;
		gameObject.transform.localPosition = Vector3.zero;
		return component;
	}

	private void OnDisable()
	{
		UnityEngine.Object.Destroy(spawnedFish);
		fishIsVisible = false;
	}
}
[RequireComponent(typeof(FishGrabbable))]
[RequireComponent(typeof(Rigidbody))]
public class FishGrabbable : GrabbableObject
{
	[SerializeField]
	private Vector3 snapOffset;

	private Rigidbody body;

	private Fish fish;

	private List<Collider> fishColliders = new List<Collider>();

	public bool fishCought;

	private bool isSnaping;

	private bool isThrown;

	private float throwMultiplier = 3f;

	public Fish FishToGrabb => fish;

	public bool IsThrown
	{
		get
		{
			return isThrown;
		}
		set
		{
			isThrown = value;
		}
	}

	public List<Collider> FishColliders
	{
		get
		{
			return fishColliders;
		}
		set
		{
			fishColliders = value;
		}
	}

	private void Awake()
	{
		body = Find.ComponentOnGameObject<Rigidbody>(base.gameObject);
	}

	public override HandAnimation.Pose GetGrabbedPose()
	{
		if (fishCought)
		{
			return HandAnimation.Pose.HoldFishHard;
		}
		return HandAnimation.Pose.HoldFishSoft;
	}

	public void Setup(Fish fishToGrabb, bool debug)
	{
		fish = fishToGrabb;
		priorty = 15;
		Transform transform = Find.ComponentOnChild<Transform>(this, "joint1");
		List<Transform> list = new List<Transform>();
		transform.gameObject.GetComponentsInChildren(list);
		int count = list.Count;
		for (int i = 0; i < count; i++)
		{
			Collider component = list[i].gameObject.GetComponent<Collider>();
			if (component != null)
			{
				fishColliders.Add(component);
			}
		}
	}

	public override void OnObjectGrabbed(Hand hand, Action OnGrabbed)
	{
		base.OnObjectGrabbed(hand, OnGrabbed);
		base.transform.parent = hand.FishAnchor;
		SetFishAsCaught(fish, base.gameObject);
		fish.StopAnimation();
		isSnaping = true;
		StartCoroutine(KeepSnaping(hand));
		fish.PlayCatchAnimation(Fish.SwimAnimation.Swim, 1.4f);
	}

	private IEnumerator KeepSnaping(Hand hand)
	{
		while (isSnaping)
		{
			SnapToHand(hand);
			yield return null;
		}
	}

	public void SetFishAsCaught(Fish fish, GameObject fishGO)
	{
		fish.ReleaseFromHook();
		StopAllCoroutines();
		if (!fishCought)
		{
			SinkerCasting.CatchFishSignal.Dispatch(fish, base.gameObject);
			CatchDisplay.CatchDisplaySignal.AddListener(OnCatchDisplayClose);
			fishCought = true;
		}
	}

	private void SnapToHand(Hand hand)
	{
		Transform transform = fishColliders[1].transform;
		Quaternion quaternion = Quaternion.LookRotation(transform.right, transform.up);
		Quaternion rotation = Quaternion.Inverse(base.transform.rotation) * quaternion;
		base.transform.localRotation = Quaternion.Inverse(rotation);
		Vector3 position = transform.position;
		Vector3 vector = hand.FishAnchor.InverseTransformPoint(position);
		base.transform.localPosition += -vector + snapOffset;
	}

	private void OnCatchDisplayClose(CatchDisplayEventType type)
	{
		if (type == CatchDisplayEventType.Hide)
		{
			if (!IsThrown)
			{
				base.gameObject.SetActive(value: false);
			}
			base.OnObjectGrabbed(null, null);
		}
	}

	protected override void StartHovering()
	{
	}

	protected override void EndHovering()
	{
	}

	public override void OnInput(InputAction action, InputType type)
	{
	}

	public override void OnObjectReleased(Hand hand)
	{
		isSnaping = false;
		base.OnObjectReleased(hand);
		base.transform.parent = null;
		if ((double)hand.AvrageThrowVelocity.magnitude > 1.0)
		{
			IsThrown = true;
			body.useGravity = true;
			body.isKinematic = false;
			body.velocity = hand.AvrageThrowVelocity * throwMultiplier;
			body.angularVelocity = hand.AvrageAngularThrowVelocity * throwMultiplier;
			SinkerCasting.ThrowFishSignal.Dispatch(fish);
		}
		else
		{
			UnityEngine.Debug.Log(hand.AvrageThrowVelocity);
			StartCoroutine(HoverAway(hand.AvrageThrowVelocity));
		}
	}

	private IEnumerator HoverAway(Vector3 velocity)
	{
		float time = 0f;
		Vector3 currentPostion = base.transform.position;
		while (true)
		{
			if ((double)velocity.magnitude > 0.001)
			{
				base.transform.position += velocity * Time.deltaTime;
				velocity *= 0.95f;
				currentPostion = base.transform.position;
			}
			else
			{
				time += Time.deltaTime;
				base.transform.position = currentPostion + Vector3.up * Mathf.Sin(time * 0.7f) * 0.03f;
			}
			yield return null;
		}
	}

	private void OnDestroy()
	{
		if (fishCought)
		{
			CatchDisplay.CatchDisplaySignal.RemoveListener(OnCatchDisplayClose);
		}
	}
}
[RequireComponent(typeof(RodBend))]
public class AdditionalRodBend : MonoBehaviour
{
	public float nibbleBendAmount = 10f;

	public float nibbleLength = 0.2f;

	public float hookBendAmount = 30f;

	public float hookLength = 0.2f;

	public float captureBendAmount = 40f;

	public float captureBendTime = 0.2f;

	public float reelInWithFishAmount = 10f;

	public float reelInWithoutFishAmount = 5f;

	public float straightenRodTime = 0.5f;

	[Tooltip("How quickly the rod bends when reeling in")]
	public float reelInBendTime = 0.05f;

	[Tooltip("How quickly the rod bends back to normal when not reeling in anymore")]
	public float reelInBendBackTime = 0.15f;

	public Transform firstJoint;

	private RodBend rodBend;

	private float fishActivityBend;

	private float wantedReelingBend;

	private float currentReelingBend;

	private float currentReelingBendSpeed;

	private static FishEventType currentFishEvent;

	private bool started;

	[@Dependency]
	public FishingRodEvent FishingRodSignal { get; set; }

	private void Start()
	{
		this.Inject();
		FishBehavior.FishSignal.AddListener(OnFishSignal);
		FishingRodSignal.AddListener(OnFishingRodSignal);
		FishingLine.ReelInDoneSignal.AddListener(OnReelInDoneSignal);
		started = true;
		rodBend = GetComponent<RodBend>();
		if (currentFishEvent == FishEventType.Hook || currentFishEvent == FishEventType.CaptureFatigue || currentFishEvent == FishEventType.CaptureStruggle)
		{
			fishActivityBend = hookBendAmount;
		}
		else if (currentFishEvent == FishEventType.CaptureBegin)
		{
			fishActivityBend = captureBendAmount;
		}
	}

	private void Update()
	{
		Vector3 vector = rodBend.firstJoint.InverseTransformPoint(rodBend.spring.transform.position);
		Vector3 vector2 = rodBend.firstJoint.InverseTransformPoint(rodBend.spring.connectedBody.transform.position);
		Vector3 vector3 = vector2 - vector;
		if (vector == vector2)
		{
			rodBend.additionalHorizontalBend = 0f;
			rodBend.additionalVerticalBend = 0f;
			return;
		}
		float num = Mathf.Abs(vector3.z);
		float num2 = Mathf.Abs(vector3.y);
		float smoothTime = ((!(currentReelingBend < wantedReelingBend)) ? reelInBendBackTime : reelInBendTime);
		currentReelingBend = Mathf.SmoothDamp(currentReelingBend, wantedReelingBend, ref currentReelingBendSpeed, smoothTime);
		rodBend.additionalVerticalBend = (fishActivityBend + currentReelingBend) * (0f - vector3.y / (num + num2));
		rodBend.additionalHorizontalBend = (fishActivityBend + currentReelingBend) * (vector3.z / (num + num2));
	}

	private void OnFishSignal(FishEventType type, Fish fish)
	{
		currentFishEvent = type;
		switch (type)
		{
		case FishEventType.Nibble:
			StartCoroutine(BendAndStraighten(nibbleBendAmount, nibbleLength));
			break;
		case FishEventType.Hook:
			StartCoroutine(Bend(hookBendAmount, hookLength));
			break;
		case FishEventType.MoveAwayFromSinker:
			StartCoroutine(Straighten(0.2f));
			break;
		case FishEventType.CaptureBegin:
			StartCoroutine(Bend(captureBendAmount, captureBendTime));
			break;
		case FishEventType.CaptureStruggle:
		case FishEventType.CaptureFatigue:
		case FishEventType.CaptureEnd:
		case FishEventType.EscapeHook:
			break;
		}
	}

	private void OnFishingRodSignal(FishingRodEventType type)
	{
		switch (type)
		{
		case FishingRodEventType.StartReelInWithFish:
			wantedReelingBend = reelInWithFishAmount;
			break;
		case FishingRodEventType.StartReelInWithoutFish:
			wantedReelingBend = reelInWithoutFishAmount;
			break;
		case FishingRodEventType.StopReelIn:
			wantedReelingBend = 0f;
			break;
		case FishingRodEventType.StartAutoReelIn:
			StartCoroutine(Straighten(straightenRodTime));
			break;
		case FishingRodEventType.JerkRodWithFish:
		case FishingRodEventType.JerkRodWithoutFish:
			break;
		}
	}

	private void OnReelInDoneSignal(bool fishOnHook)
	{
		wantedReelingBend = 0f;
	}

	private IEnumerator BendAndStraighten(float amount, float time)
	{
		float startTime = Time.time;
		float progress = 0f;
		while (Interpolation.ProgressOverTime(startTime, time, ref progress))
		{
			fishActivityBend = Mathf.Sin(progress * (float)Math.PI) * amount;
			yield return null;
		}
	}

	private IEnumerator Bend(float amount, float time)
	{
		float startTime = Time.time;
		float progress = 0f;
		while (Interpolation.ProgressOverTime(startTime, time, ref progress))
		{
			fishActivityBend = Mathf.Sin(progress * ((float)Math.PI / 2f)) * amount;
			yield return null;
		}
	}

	private IEnumerator Straighten(float time)
	{
		float startTime = Time.time;
		float progress = 0f;
		float startBend = fishActivityBend;
		while (Interpolation.ProgressOverTime(startTime, time, ref progress))
		{
			fishActivityBend = startBend * (Mathf.Sin((float)Math.PI / 2f) - progress);
			yield return null;
		}
	}

	private void OnDestroy()
	{
		if (started)
		{
			FishBehavior.FishSignal.RemoveListener(OnFishSignal);
			FishingRodSignal.RemoveListener(OnFishingRodSignal);
			FishingLine.ReelInDoneSignal.RemoveListener(OnReelInDoneSignal);
		}
	}
}
public class AimHintSpawner : MonoBehaviour
{
	public string castTooEarlyString = "GUI_BobberCastTooEarly";

	public string castTooLateString = "GUI_BobberCastTooLate";

	public GameObject bobberTooltipPrefab;

	private Camera centerCamera;

	private BobberHint[] bobberHintPool;

	[@Dependency]
	public Localization localization { get; set; }

	private void Start()
	{
		this.Inject();
		bobberHintPool = new BobberHint[3];
		FishBehavior.BobberHintSignal.AddListener(SpawnBobberHint);
	}

	private IEnumerator WaitForMainCamera()
	{
		while (centerCamera == null)
		{
			centerCamera = Camera.main;
			yield return null;
		}
		PreInstantiateBobberPool();
	}

	private void OnEnable()
	{
		if (centerCamera == null)
		{
			StartCoroutine(WaitForMainCamera());
		}
	}

	private void OnDestroy()
	{
		if (bobberHintPool != null)
		{
			BobberHint[] array = bobberHintPool;
			foreach (BobberHint bobberHint in array)
			{
				if ((bool)bobberHint)
				{
					UnityEngine.Object.Destroy(bobberHint.gameObject);
				}
			}
		}
		FishBehavior.BobberHintSignal.RemoveListener(SpawnBobberHint);
	}

	private void SpawnBobberHint(BobberHintType type)
	{
		BobberHint bobberHint = null;
		int num = 0;
		while (bobberHint == null)
		{
			if (num >= bobberHintPool.Length)
			{
				return;
			}
			if (bobberHintPool[num] == null)
			{
				bobberHint = InstantiateBobberHint();
				bobberHintPool[num] = bobberHint;
			}
			else if (bobberHintPool[num].ReadyForUse())
			{
				bobberHint = bobberHintPool[num];
			}
			num++;
		}
		string text = "error";
		switch (type)
		{
		default:
			return;
		case BobberHintType.castTooEarly:
			text = castTooEarlyString;
			break;
		case BobberHintType.castTooLate:
			text = castTooLateString;
			break;
		}
		text = localization.GetString(text);
		if (type == BobberHintType.castTooLate || type == BobberHintType.castTooEarly)
		{
			bobberHint.ShowHint(type, text, 0.5f);
		}
		else
		{
			bobberHint.ShowHint(type, text);
		}
	}

	private BobberHint InstantiateBobberHint()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(bobberTooltipPrefab, base.transform.position, Quaternion.identity);
		gameObject.transform.parent = base.transform.parent.transform;
		BobberHint component = gameObject.GetComponent<BobberHint>();
		component.Setup(base.transform, centerCamera);
		return component;
	}

	private void PreInstantiateBobberPool()
	{
		for (int i = 0; i < bobberHintPool.Length; i++)
		{
			bobberHintPool[i] = InstantiateBobberHint();
		}
		StartCoroutine(DisableBobberHints());
	}

	private IEnumerator DisableBobberHints()
	{
		yield return new WaitForEndOfFrame();
		for (int i = 0; i < bobberHintPool.Length; i++)
		{
			bobberHintPool[i].gameObject.SetActive(value: false);
		}
		yield return 0;
	}
}
public class AimImageChanger : MonoBehaviour
{
	public Material LockedAimMaterial;

	public Material FreeAimMaterial;

	private MeshRenderer meshRenderer;

	private void Start()
	{
		SinkerCasting.FishingRodSoundSignal.AddListener(OnAimLockSignal);
		meshRenderer = GetComponent<MeshRenderer>();
	}

	private void OnAimLockSignal(FishingRodSoundEventType type)
	{
		switch (type)
		{
		case FishingRodSoundEventType.StartPreCasting:
			meshRenderer.material = LockedAimMaterial;
			break;
		case FishingRodSoundEventType.ReleaseLineAdvanded:
		case FishingRodSoundEventType.AbortCasting:
			meshRenderer.material = FreeAimMaterial;
			break;
		case FishingRodSoundEventType.StartCastingSimple:
			break;
		}
	}

	private void OnDestroy()
	{
		SinkerCasting.FishingRodSoundSignal.RemoveListener(OnAimLockSignal);
	}
}
public class AimMarker : MonoBehaviour
{
	public GameObject tutorialArrowPrefab;

	public Vector3 tutorialArrowOffset = new Vector3(0f, 0.15f, 0f);

	public Vector3 tutorialArrowScale = new Vector3(1.2f, 1.2f, 1.2f);

	public float distanceScaleFactor = 0.3f;

	public float wobbleSpeed = 10f;

	public float wobbleMagnitude = 0.1f;

	private Vector3 startScale;

	private Vector3 distanceMeasurePoint = new Vector3(0f, 0f, 0f);

	private GameObject tutorialArrow;

	private bool startHasRun;

	[@Dependency]
	public Quest Quest { get; set; }

	private void Start()
	{
		this.Inject();
		startScale = base.transform.localScale;
		Tutorial.StateChangeSignal.AddListener(OnTurorialNotification);
		if (Quest.CurrentState.Id == "Tutorial01")
		{
			SpawnTutorialArrow();
		}
		startHasRun = true;
	}

	private void OnEnable()
	{
		if (startHasRun)
		{
			base.transform.localScale = startScale;
			if (Quest.CurrentState.Id == "Tutorial01")
			{
				SpawnTutorialArrow();
			}
		}
	}

	private void Update()
	{
		float num = Vector3.Distance(distanceMeasurePoint, base.transform.position);
		base.transform.localScale = startScale * num * distanceScaleFactor;
		base.transform.localScale = base.transform.localScale * (1f + Mathf.Sin(Time.timeSinceLevelLoad * wobbleSpeed) * wobbleMagnitude);
	}

	private void OnTurorialNotification(TutorialStateType eventType)
	{
		if (eventType == TutorialStateType.FailReelin || eventType == TutorialStateType.WaitForAttraction)
		{
			UnityEngine.Object.Destroy(tutorialArrow);
		}
	}

	private void SpawnTutorialArrow()
	{
		if (tutorialArrow == null)
		{
			tutorialArrow = UnityEngine.Object.Instantiate(tutorialArrowPrefab, base.transform.position + tutorialArrowOffset, Quaternion.identity);
			tutorialArrow.transform.localScale = tutorialArrowScale;
			tutorialArrow.transform.parent = base.transform;
		}
	}

	private void OnDestroy()
	{
		if (Tutorial.StateChangeSignal != null)
		{
			Tutorial.StateChangeSignal.RemoveListener(OnTurorialNotification);
		}
	}
}
public enum BaitType
{
	Bait1,
	Bait1QuestUpgrade,
	Bait2,
	BaitIAP1
}
public class Bobber : MonoBehaviour
{
	public static Signal<GameObject> bobberHitWaterSignal = new Signal<GameObject>();

	[Range(1f, 5f)]
	[Tooltip("The multiplier for how long the fish is hooked. Set for each bobber.")]
	public float hookedLengthMultiplier = 1f;

	public GameObject waterRingsPrefab;

	public GameObject splashParticlesPrefab;

	public GameObject jerkSplashParticlesPrefab;

	public GameObject waveParticlesPrefab;

	public GameObject tensionMeterPrefab;

	public GameObject exclamationMarkPrefab;

	public float waveSpeedThreshold = 0.2f;

	public Reel reel;

	public Camera centerCamera;

	private GameObject splashBobberParticlesRoot;

	private bool bobberInWater;

	private ParticleSystem waveParticles;

	private GameObject waveParticlesGameObject;

	private GameObject tensionMeter;

	private GameObject exclamationMark;

	private Vector3 tensionMeterOffset = new Vector3(0f, 0.3f, 0f);

	private Renderer rend;

	private Vector3 previousPosition;

	private bool emittingWaves;

	private float velocity;

	private float speed;

	private float waveUpdateTime = 0.001f;

	private bool fishOnHook;

	private bool isFishing;

	[@Dependency]
	public FishingRodEvent FishingRodSignal { get; set; }

	[@Dependency]
	public UIDisplayEvent UIDisplaySignal { get; set; }

	private void Awake()
	{
		this.Inject();
		bobberInWater = false;
		fishOnHook = false;
		FishingLine.ReelInDoneSignal.AddListener(OnReelInDoneSignal);
		FishBehavior.FishSignal.AddListener(OnFishSignal);
		FishingRodSignal.AddListener(OnFishingRodSignal);
		waveParticlesGameObject = UnityEngine.Object.Instantiate(waveParticlesPrefab, base.transform.position, Quaternion.identity);
		waveParticles = waveParticlesGameObject.GetComponentInChildren<ParticleSystem>();
		waveParticles.Stop();
		splashBobberParticlesRoot = new GameObject("SplashBobberParticlesRoot");
		isFishing = false;
		speed = 0f;
		previousPosition = base.transform.position;
		emittingWaves = false;
		velocity = 0f;
	}

	private void OnFishingRodSignal(FishingRodEventType type)
	{
		switch (type)
		{
		case FishingRodEventType.ReleaseLine:
			isFishing = true;
			break;
		case FishingRodEventType.HideRod:
			base.gameObject.SetActive(value: false);
			break;
		case FishingRodEventType.VisibleRod:
			base.gameObject.SetActive(value: true);
			break;
		case FishingRodEventType.JerkRodWithFish:
		case FishingRodEventType.JerkRodWithoutFish:
			StartCoroutine(SpawnJerkSplashParticles());
			MasterAudio.PlaySound3DAtTransformAndForget("nibble", base.transform);
			if (fishOnHook)
			{
				MasterAudio.PlaySound3DAtTransformAndForget("FishSplashHook", base.transform);
			}
			break;
		case FishingRodEventType.StartAutoReelIn:
			waveParticles.Stop();
			break;
		case FishingRodEventType.StartReelInWithoutFish:
		case FishingRodEventType.StartReelInWithFish:
		case FishingRodEventType.StopReelIn:
		case FishingRodEventType.StopCasting:
			break;
		}
	}

	private void OnEnable()
	{
		waveParticles.Stop();
	}

	private void OnDisable()
	{
		if ((bool)splashBobberParticlesRoot)
		{
			UnityEngine.Object.Destroy(splashBobberParticlesRoot);
		}
	}

	private void Update()
	{
		if (base.transform.position.y <= 0f && !bobberInWater)
		{
			if (isFishing)
			{
				bobberHitWaterSignal.Dispatch(base.gameObject);
			}
			StartCoroutine(SpawnWaterRing());
			StartCoroutine(SpawnSplashParticles());
			bobberInWater = true;
		}
		else if (base.transform.position.y >= 0.05f && bobberInWater)
		{
			bobberInWater = false;
			waveParticles.Stop();
			emittingWaves = false;
		}
		if (bobberInWater)
		{
			UpdateWaveParticles();
		}
		if (fishOnHook)
		{
			UpdateTensionMeterPosition();
		}
	}

	private void UpdateTensionMeterPosition()
	{
		Transform transform = tensionMeter.transform;
		transform.rotation = Quaternion.LookRotation(-base.transform.position);
		transform.position = base.transform.position + tensionMeterOffset;
	}

	private void UpdateWaveParticles()
	{
		Vector3 vector = base.transform.position - previousPosition;
		Vector3 vector2 = new Vector3(vector.x, 0f, vector.z);
		waveParticlesGameObject.transform.position = new Vector3(base.transform.position.x, 0f, base.transform.position.z);
		previousPosition = base.transform.position;
		velocity = Mathf.SmoothDamp(velocity, vector2.magnitude / Time.deltaTime, ref speed, waveUpdateTime);
		float num = (float)Math.PI / 180f * Vector3.Angle(Vector3.forward, vector2);
		num = ((!(Vector3.Cross(Vector3.forward, vector2).y > 0f)) ? (0f - num) : num);
		ParticleSystem.MainModule main = waveParticles.main;
		main.startRotation = num;
		if (velocity > waveSpeedThreshold && !emittingWaves)
		{
			waveParticles.Play();
			emittingWaves = true;
		}
		else if (velocity < waveSpeedThreshold && emittingWaves)
		{
			waveParticles.Stop();
			emittingWaves = false;
		}
	}

	private void OnReelInDoneSignal(bool fishOnHook)
	{
		emittingWaves = true;
		isFishing = false;
		waveParticles.Stop();
	}

	private void OnFishSignal(FishEventType type, Fish fish)
	{
		switch (type)
		{
		case FishEventType.Nibble:
			break;
		case FishEventType.Hook:
			SpawnExclamationMark();
			break;
		case FishEventType.MoveAwayFromSinker:
			StartCoroutine(SpawnWaterRing());
			DestroyExclamationMark();
			break;
		case FishEventType.CaptureBegin:
			OnCaptureBegin(fish);
			DestroyExclamationMark();
			break;
		case FishEventType.CaptureEnd:
		case FishEventType.EscapeHook:
			OnEscapeHook();
			break;
		case FishEventType.CaptureStruggle:
		case FishEventType.CaptureFatigue:
			break;
		}
	}

	private void OnCaptureBegin(Fish fish)
	{
		fishOnHook = true;
		tensionMeter = UnityEngine.Object.Instantiate(tensionMeterPrefab, base.transform.position + tensionMeterOffset, Quaternion.identity);
		tensionMeter.transform.parent = base.transform;
		tensionMeter.GetComponent<TensionMeter>().Reel = reel;
		tensionMeter.GetComponent<TensionMeter>().Fish = fish;
		tensionMeter.GetComponent<TensionMeter>().CenterCamera = centerCamera;
	}

	private void OnEscapeHook()
	{
		fishOnHook = false;
		emittingWaves = false;
		waveParticles.Stop();
		UnityEngine.Object.Destroy(tensionMeter);
	}

	private void SpawnExclamationMark()
	{
		Vector3 vector = new Vector3(0f, 0.15f, 0f);
		exclamationMark = UnityEngine.Object.Instantiate(exclamationMarkPrefab, base.transform.position + vector, Quaternion.identity);
		exclamationMark.GetComponent<ExclamationMark>().CenterCamera = centerCamera;
	}

	private void DestroyExclamationMark()
	{
		UnityEngine.Object.Destroy(exclamationMark);
	}

	private IEnumerator SpawnWaterRing()
	{
		GameObject waterRings = UnityEngine.Object.Instantiate(waterRingsPrefab, new Vector3(base.transform.position.x, 0f, base.transform.position.z), Quaternion.identity);
		ParticleSystem splashParticleSystem = waterRings.GetComponentInChildren<ParticleSystem>();
		while (splashParticleSystem.IsAlive())
		{
			yield return null;
		}
		UnityEngine.Object.Destroy(waterRings);
	}

	private IEnumerator SpawnSplashParticles()
	{
		if ((bool)splashBobberParticlesRoot)
		{
			GameObject splashBobberParticles = UnityEngine.Object.Instantiate(splashParticlesPrefab, base.transform.position, Quaternion.identity);
			splashBobberParticles.transform.SetParent(splashBobberParticlesRoot.transform, worldPositionStays: true);
			ParticleSystem splashParticleSystem = splashBobberParticles.GetComponentInChildren<ParticleSystem>();
			while (splashParticleSystem.IsAlive())
			{
				yield return null;
			}
			UnityEngine.Object.Destroy(splashBobberParticles);
		}
	}

	private IEnumerator SpawnJerkSplashParticles()
	{
		GameObject splashBobberParticles = UnityEngine.Object.Instantiate(jerkSplashParticlesPrefab, base.transform.position, Quaternion.identity);
		splashBobberParticles.transform.SetParent(splashBobberParticlesRoot.transform, worldPositionStays: true);
		ParticleSystem splashParticleSystem = splashBobberParticles.GetComponentInChildren<ParticleSystem>();
		while (splashParticleSystem.IsAlive())
		{
			yield return null;
		}
		UnityEngine.Object.Destroy(splashBobberParticles);
	}

	private void OnDestroy()
	{
		FishingLine.ReelInDoneSignal.RemoveListener(OnReelInDoneSignal);
		FishBehavior.FishSignal.RemoveListener(OnFishSignal);
		FishingRodSignal.RemoveListener(OnFishingRodSignal);
	}

	public void JerkMotion(float force)
	{
		if (bobberInWater)
		{
			force = Mathf.Clamp(force *= 0.03f, 0f, 0.2f);
			GetComponent<Rigidbody>().AddForce(Vector3.up * force, ForceMode.Impulse);
		}
	}
}
public enum BobberHintType
{
	none,
	tooEarly,
	tooLate,
	lineBreak,
	idle,
	reelInReminder,
	castTooLate,
	castTooEarly
}
public class BobberHint : MonoBehaviour
{
	[HideInInspector]
	public Camera centerCamera;

	[HideInInspector]
	public Transform bobber;

	private TextMesh textMesh;

	private MeshRenderer textRenderer;

	private bool isActive;

	private float alpha;

	private bool isDelayRunning;

	[@Dependency]
	public Localization localization { get; set; }

	public void Setup(Transform transform, Camera centerCamera)
	{
		bobber = transform;
		this.centerCamera = centerCamera;
	}

	private void Awake()
	{
		this.Inject();
		textRenderer = GetComponent<MeshRenderer>();
		textMesh = GetComponent<TextMesh>();
		textRenderer.sharedMaterial.renderQueue = 4001;
		textMesh.text = "XXX";
		SetAlpha(0f);
	}

	private void Update()
	{
		if (isActive && !isDelayRunning)
		{
			Vector3 localPosition = base.transform.localPosition;
			base.transform.localPosition = new Vector3(localPosition.x, localPosition.y + 0.1f * Time.deltaTime, localPosition.z);
			SetAlpha(Mathf.Max(0f, alpha - 0.3f * Time.deltaTime));
			if (alpha == 0f)
			{
				OnHintDone();
			}
		}
	}

	private void SetAlpha(float alpha)
	{
		this.alpha = alpha;
		SetAlpha(alpha, textRenderer);
	}

	private void Activate()
	{
		if (!base.gameObject.activeSelf)
		{
			base.gameObject.SetActive(value: true);
		}
		if (textMesh != null)
		{
			textMesh.text = string.Empty;
			textMesh.font = localization.GetLanguageFont();
		}
		isActive = true;
	}

	private void OnHintDone()
	{
		StopAllCoroutines();
		base.gameObject.SetActive(value: false);
		SetAlpha(0f);
		isActive = false;
	}

	public bool ReadyForUse()
	{
		return !isActive;
	}

	public void ShowHint(BobberHintType type, string hintText)
	{
		if (type != 0)
		{
			Activate();
			if (!(textMesh == null) || localization != null)
			{
				base.transform.position = new Vector3(bobber.position.x, 0.3f, bobber.position.z);
				RotateToFaceCamera();
				float num = Vector3.Distance(centerCamera.transform.position, base.transform.position);
				float num2 = num * 0.15f;
				base.transform.localScale = new Vector3(num2, num2, num2);
				textMesh.text = hintText;
				textMesh.font = localization.GetLanguageFont();
				textRenderer.sharedMaterial = textMesh.font.material;
				SetAlpha(1f);
			}
		}
	}

	public void ShowHint(BobberHintType type, string hintText, float delaySeconds)
	{
		Activate();
		SetAlpha(0f);
		StartCoroutine(ShowHintWithDelay(type, hintText, delaySeconds));
	}

	private IEnumerator ShowHintWithDelay(BobberHintType type, string hintText, float delaySeconds)
	{
		isDelayRunning = true;
		yield return new WaitForSeconds(delaySeconds);
		isDelayRunning = false;
		ShowHint(type, hintText);
	}

	private void RotateToFaceCamera()
	{
		base.transform.rotation = Quaternion.LookRotation(base.transform.position - centerCamera.transform.position);
	}

	private void SetAlpha(float alpha, MeshRenderer renderer)
	{
		Color color = renderer.material.color;
		color.a = alpha;
		renderer.material.SetColor("_Color", color);
	}
}
public class BobberHintLogic : MonoBehaviour
{
	private bool fishCapture;

	private float reelInIdleWarningTime = 2.5f;

	private float reelInIdleTimer;

	private bool reelInWarningShown;

	private bool reelingIn;

	[@Dependency]
	public FishingRodEvent FishingRodSignal { get; set; }

	private void Start()
	{
		this.Inject();
		FishingRodSignal.AddListener(OnFishingRodSignal);
		FishBehavior.FishSignal.AddListener(OnFishSignal);
	}

	private void OnDestroy()
	{
		FishingRodSignal.RemoveListener(OnFishingRodSignal);
		FishBehavior.FishSignal.RemoveListener(OnFishSignal);
	}

	private void OnFishSignal(FishEventType type, Fish fish)
	{
		switch (type)
		{
		case FishEventType.CaptureBegin:
			fishCapture = true;
			reelInWarningShown = false;
			reelInIdleTimer = 0f;
			break;
		case FishEventType.CaptureEnd:
		case FishEventType.EscapeHook:
		case FishEventType.MoveAwayFromSinker:
			fishCapture = false;
			break;
		case FishEventType.CaptureStruggle:
		case FishEventType.CaptureFatigue:
			break;
		}
	}

	public void OnFishingRodSignal(FishingRodEventType type)
	{
		switch (type)
		{
		case FishingRodEventType.StartReelInWithoutFish:
		case FishingRodEventType.StartReelInWithFish:
			reelingIn = true;
			break;
		case FishingRodEventType.StopReelIn:
			reelInIdleTimer = 0f;
			reelingIn = false;
			break;
		}
	}

	private void Update()
	{
		if (fishCapture && !reelingIn && !reelInWarningShown)
		{
			reelInIdleTimer += Time.deltaTime;
			if (reelInIdleTimer >= reelInIdleWarningTime)
			{
				reelInWarningShown = true;
				FishBehavior.BobberHintSignal.Dispatch(BobberHintType.reelInReminder);
			}
		}
	}
}
public class BobberHintSpawner : MonoBehaviour
{
	public string lineBreakString = "GUI_BobberLineBreak";

	public string idleString = "GUI_BobberLineIdle";

	public string tooLateString = "GUI_BobberLineTooLate";

	public string tooEarlyString = "GUI_BobberLineTooEarly";

	public string tooLateStringHeadset = "GUI_BobberLineTooLate";

	public string tooEarlyStringHeadset = "GUI_BobberLineTooEarly";

	public string reelReminderString = "GUI_BobberLineReelReminder";

	public GameObject bobberTooltipPrefab;

	private Camera centerCamera;

	private BobberHint[] bobberHintPool;

	[@Dependency]
	public Localization localization { get; set; }

	[@Dependency]
	public InputManager input { get; set; }

	private void Start()
	{
		this.Inject();
		StartCoroutine(WaitForMainCamera());
	}

	private IEnumerator WaitForMainCamera()
	{
		while (centerCamera == null)
		{
			centerCamera = Camera.main;
			yield return null;
		}
		bobberHintPool = new BobberHint[3];
		FishBehavior.BobberHintSignal.AddListener(SpawnBobberHint);
		PreInstantiateBobberPool();
	}

	private void OnEnable()
	{
		if (centerCamera == null)
		{
			StartCoroutine(WaitForMainCamera());
		}
	}

	private void OnDestroy()
	{
		FishBehavior.BobberHintSignal.RemoveListener(SpawnBobberHint);
	}

	private void SpawnBobberHint(BobberHintType type)
	{
		BobberHint bobberHint = null;
		int num = 0;
		while (bobberHint == null)
		{
			if (num >= bobberHintPool.Length)
			{
				return;
			}
			if (bobberHintPool[num] == null)
			{
				bobberHint = InstantiateBobberHint();
				bobberHintPool[num] = bobberHint;
			}
			else if (bobberHintPool[num].ReadyForUse())
			{
				bobberHint = bobberHintPool[num];
			}
			num++;
		}
		string text = "error";
		switch (type)
		{
		default:
			return;
		case BobberHintType.lineBreak:
			text = lineBreakString;
			break;
		case BobberHintType.idle:
			text = idleString;
			break;
		case BobberHintType.reelInReminder:
			text = reelReminderString;
			break;
		case BobberHintType.tooEarly:
			text = ((input.GetInputMode() != InputMode.Headset) ? tooEarlyString : tooEarlyStringHeadset);
			break;
		case BobberHintType.tooLate:
			text = ((input.GetInputMode() != InputMode.Headset) ? tooLateString : tooLateStringHeadset);
			break;
		}
		text = localization.GetString(text);
		if (type == BobberHintType.tooLate)
		{
			bobberHint.ShowHint(type, text, 0.3f);
		}
		else
		{
			bobberHint.ShowHint(type, text);
		}
	}

	private BobberHint InstantiateBobberHint()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(bobberTooltipPrefab, base.transform.position, Quaternion.identity);
		gameObject.transform.parent = base.transform.parent.transform;
		BobberHint component = gameObject.GetComponent<BobberHint>();
		component.Setup(base.transform, centerCamera);
		return component;
	}

	private void PreInstantiateBobberPool()
	{
		for (int i = 0; i < bobberHintPool.Length; i++)
		{
			bobberHintPool[i] = InstantiateBobberHint();
		}
		StartCoroutine(DisableBobberHints());
	}

	private IEnumerator DisableBobberHints()
	{
		yield return new WaitForEndOfFrame();
		for (int i = 0; i < bobberHintPool.Length; i++)
		{
			bobberHintPool[i].gameObject.SetActive(value: false);
		}
		yield return 0;
	}
}
public enum BobberType
{
	Bobber1,
	Bobber2,
	Bobber3
}
public class Buoyancy : MonoBehaviour
{
	public float waterLevel;

	public float buoyancy = 2.5f;

	public float airDrag = 2f;

	public float waterDrag = 10f;

	public Vector3 centerOfMass = new Vector3(0f, -0.05f, 0f);

	[Tooltip("Half the height of the object, for calculating how much of it is submerged")]
	public float floatRadius = 0.025f;

	private Rigidbody rigidbodyComponent;

	private void Awake()
	{
		rigidbodyComponent = GetComponent<Rigidbody>();
		rigidbodyComponent.centerOfMass = centerOfMass;
	}

	public void FixedUpdate()
	{
		float submersion = GetSubmersion();
		Vector3 force = -Physics.gravity * rigidbodyComponent.mass * buoyancy * submersion;
		rigidbodyComponent.AddForce(force);
		rigidbodyComponent.drag = Mathf.Lerp(airDrag, waterDrag, submersion);
	}

	private float GetSubmersion()
	{
		float num = waterLevel - (base.transform.position.y - floatRadius);
		return Mathf.Clamp01(num / floatRadius / 2f);
	}
}
public enum CastingMode
{
	Simple,
	Advanced,
	Free
}
public class FishingLine : MonoBehaviour
{
	private enum State
	{
		Fixed,
		Free,
		ReelingIn,
		ReelingInAuto
	}

	public static Signal<bool> ReelInDoneSignal = new Signal<bool>();

	[Tooltip("The hook script attached to the bobber.")]
	public Hook hook;

	public Reel reel;

	public Transform playerTranform;

	public GameObject bobber;

	public float fishingLineLength = 1000f;

	public float reeledInLength = 0.15f;

	public float castLineLength = 0.15f;

	public float finishReelInDistance = 0.25f;

	public float reelInForceWithFish = 15f;

	public float reelInForceWithoutFish = 2f;

	public float reelInSpeedup = 0.1f;

	public float reelInSlowdown = 0.1f;

	public float jerkForceWithoutFish = 40f;

	public float autoReelInDistance = 2f;

	[Header("Controller Only Values")]
	public float autoReelinDistancePlayer = 2f;

	public float reelInTime = 1f;

	private Transform rodTip;

	private SpringJoint fishingLineJoint;

	private float currentReelInForce;

	private bool isFishing;

	private float timer;

	private Vector3 ControllerDirectionOnPress = Vector3.forward;

	private bool controllerButtonDown;

	private bool isControllerActive;

	private State state;

	[@Dependency]
	public FishingRodEvent FishingRodSignal { get; set; }

	[@Dependency]
	public InputModeSwitchEvent GearVRInputSwitchSignal { get; set; }

	[@Dependency]
	public InputManager input { get; set; }

	private void Start()
	{
		this.Inject();
		fishingLineJoint = GetComponent<SpringJoint>();
		fishingLineJoint.maxDistance = castLineLength;
		rodTip = base.transform;
		InputManager.InputSignal.AddListener(GetButtonDown);
		GearVRInputSwitchSignal.AddListener(OnActiveControllerChanged);
		FishingRodSignal.AddListener(OnFishingRodSignal);
		state = State.Fixed;
		isControllerActive = input.GetInputMode() != InputMode.Headset;
	}

	private void FixedUpdate()
	{
		float num = Vector3.Distance(new Vector3(bobber.transform.position.x, 0f, bobber.transform.position.z), new Vector3(rodTip.position.x, 0f, rodTip.position.z));
		float num2 = Vector3.Distance(new Vector3(bobber.transform.position.x, 0f, bobber.transform.position.z), new Vector3(playerTranform.position.x, 0f, playerTranform.position.z));
		if (isFishing && (num < autoReelInDistance || (isControllerActive && num2 < autoReelinDistancePlayer)) && state != State.ReelingInAuto)
		{
			FishingRodSignal.Dispatch(FishingRodEventType.StartAutoReelIn);
		}
		if (state == State.Free || state == State.Fixed)
		{
			return;
		}
		bool flag = hook.HookedFish != null;
		float num3 = ((!flag) ? reelInForceWithoutFish : reelInForceWithFish);
		num3 *= ((!flag) ? reel.ReelTensionWithoutFish : reel.ReelTensionWithFish);
		if (state == State.ReelingIn || state == State.ReelingInAuto)
		{
			currentReelInForce = Mathf.Min(num3, currentReelInForce + reelInSpeedup);
		}
		else
		{
			currentReelInForce = Mathf.Max(0f, currentReelInForce - reelInSlowdown);
		}
		Vector3 vector = base.transform.position - bobber.transform.position;
		vector.y = 0f;
		if (num < autoReelInDistance || (isControllerActive && num2 < autoReelinDistancePlayer))
		{
			vector = rodTip.position + fishingLineJoint.anchor - (bobber.transform.position + fishingLineJoint.connectedAnchor);
		}
		float sqrMagnitude = vector.sqrMagnitude;
		if (state == State.ReelingInAuto)
		{
			timer += Time.deltaTime;
		}
		if (sqrMagnitude > finishReelInDistance * finishReelInDistance && (!isControllerActive || timer < reelInTime))
		{
			float num4 = Mathf.Sqrt(sqrMagnitude);
			if (num4 - GetDistanceOffset() < fishingLineJoint.maxDistance)
			{
			}
			Rigidbody component = bobber.GetComponent<Rigidbody>();
			component.AddForce(vector / num4 * currentReelInForce);
			return;
		}
		float maxDistance = fishingLineJoint.maxDistance;
		fishingLineJoint.maxDistance = Mathf.MoveTowards(fishingLineJoint.maxDistance, reeledInLength, Time.fixedDeltaTime / reelInTime);
		if ((state == State.ReelingIn || state == State.ReelingInAuto) && fishingLineJoint.maxDistance == reeledInLength)
		{
			state = State.Fixed;
			bool item = hook.HookedFish != null;
			ReelInDoneSignal.Dispatch(item);
			isFishing = false;
			timer = 0f;
		}
	}

	private void OnFishingRodSignal(FishingRodEventType type)
	{
		switch (type)
		{
		case FishingRodEventType.StartCasting:
			fishingLineJoint.maxDistance = castLineLength;
			state = State.Fixed;
			break;
		case FishingRodEventType.ReleaseLine:
			fishingLineJoint.maxDistance = fishingLineLength;
			state = State.Free;
			break;
		case FishingRodEventType.StartReelInWithoutFish:
		case FishingRodEventType.StartReelInWithFish:
			state = State.ReelingIn;
			isFishing = true;
			break;
		case FishingRodEventType.StartAutoReelIn:
			state = State.ReelingInAuto;
			fishingLineJoint.maxDistance = (fishingLineJoint.transform.position - fishingLineJoint.connectedBody.transform.position).magnitude;
			timer = 0f;
			break;
		case FishingRodEventType.StopReelIn:
			if (state != State.ReelingInAuto)
			{
				fishingLineJoint.maxDistance = fishingLineLength;
				state = State.Free;
			}
			break;
		case FishingRodEventType.JerkRodWithoutFish:
		{
			Vector3 normalized2 = (rodTip.transform.position - Vector3.up - bobber.transform.position).normalized;
			normalized2 *= jerkForceWithoutFish;
			Rigidbody component2 = bobber.GetComponent<Rigidbody>();
			component2.AddForce(normalized2);
			isFishing = true;
			break;
		}
		case FishingRodEventType.JerkRodWithFish:
		{
			Vector3 normalized = (rodTip.transform.position - Vector3.up - bobber.transform.position).normalized;
			normalized *= reelInForceWithFish;
			Rigidbody component = bobber.GetComponent<Rigidbody>();
			component.AddForce(normalized);
			isFishing = true;
			break;
		}
		}
	}

	protected void OnActiveControllerChanged(InputMode type)
	{
		isControllerActive = type != InputMode.Headset;
	}

	private void GetButtonDown(InputType type)
	{
		switch (type)
		{
		case InputType.KeyDown:
			controllerButtonDown = true;
			ControllerDirectionOnPress = input.GetControllerOrientation() * Vector3.forward;
			break;
		case InputType.KeyHold:
			break;
		case InputType.KeyUp:
			controllerButtonDown = false;
			break;
		}
	}

	private float GetDistanceOffset()
	{
		float result = 0f;
		if (isControllerActive && controllerButtonDown && state != 0 && state != State.Free)
		{
			Vector3 vector = input.GetControllerOrientation() * Vector3.forward;
			float magnitude = base.transform.localPosition.magnitude;
			result = (vector * magnitude - ControllerDirectionOnPress * magnitude).magnitude;
		}
		return result;
	}

	private void OnDestroy()
	{
		FishingRodSignal.RemoveListener(OnFishingRodSignal);
		InputManager.InputSignal.RemoveListener(GetButtonDown);
		GearVRInputSwitchSignal.RemoveListener(OnActiveControllerChanged);
	}
}
public enum FishingLineType
{
	Default
}
public enum FishingRodEventType
{
	StartGrab,
	EndGrab,
	StartCasting,
	ReleaseLine,
	StartReelInWithoutFish,
	StartReelInWithFish,
	JerkRodWithFish,
	JerkRodWithoutFish,
	StartAutoReelIn,
	StopReelIn,
	StopCasting,
	HideRod,
	VisibleRod,
	StopCranking,
	StartReelInWithFishSound,
	StartReelInWithoutFishSound,
	StopReelInSound
}
public class FishingRodEvent : Signal<FishingRodEventType>
{
}
public class Hook : MonoBehaviour
{
	public static Signal ReenableBaitNotification = new Signal();

	public Vector3 nibbleDisplacement = new Vector3(0f, -0.05f, 0f);

	public Vector3 hookedDisplacement = new Vector3(0f, -0.1f, 0f);

	[Tooltip("Delay for enabling hook collider after it hits the water.")]
	public float colliderEnableDelay = 1.5f;

	public GameObject bobber;

	public Reel reel;

	public FishingLine fishingLine;

	private bool baitAttached;

	private FishBehavior baitee;

	private FishBehavior hookedFish;

	private bool isFishing;

	private Rigidbody hookRigidbody;

	private SpringJoint hookJoint;

	private float timeUnderWater;

	[@Dependency]
	public FishingRodEvent FishingRodSignal { get; set; }

	public FishBehavior Baitee => baitee;

	public FishBehavior HookedFish => hookedFish;

	public bool CanAttract => isFishing && baitee == null && timeUnderWater >= colliderEnableDelay;

	public bool BaitAttached => baitAttached;

	private void Awake()
	{
		this.Inject();
		hookRigidbody = Find.ComponentOnGameObject<Rigidbody>(this);
		hookJoint = Find.ComponentOnGameObject<SpringJoint>(this);
		FishingRodSignal.AddListener(OnFishingRodSignal);
	}

	private void Start()
	{
		FishingLine.ReelInDoneSignal.AddListener(OnReelInDone);
		isFishing = false;
	}

	private void Update()
	{
		if (base.transform.position.y < 0f)
		{
			timeUnderWater += Time.deltaTime;
		}
		else
		{
			timeUnderWater = 0f;
		}
	}

	public void AttachToBobber()
	{
		base.gameObject.SetActive(value: true);
		hookJoint.connectedBody = Find.ComponentOnGameObject<Rigidbody>(bobber);
		base.transform.position = bobber.transform.position - new Vector3(0f, 0.15f, 0f);
		hookRigidbody.isKinematic = false;
		if (!BaitAttached)
		{
			ReenableBaitNotification.Dispatch();
		}
		baitAttached = true;
	}

	public void DetachFromBobber()
	{
		baitAttached = false;
		hookJoint.connectedBody = null;
		hookRigidbody.isKinematic = true;
		base.gameObject.SetActive(value: false);
	}

	public void Allocate(FishBehavior fish)
	{
		baitee = fish;
	}

	public void Free(FishBehavior fish)
	{
		bool flag = hookedFish != null;
		baitee = null;
		if (flag)
		{
			bobber.GetComponent<Rigidbody>().constraints = RigidbodyConstraints.None;
			hookedFish.fish.ReleaseFromHook();
			hookedFish = null;
		}
	}

	public void HookFish()
	{
		hookedFish = baitee;
		hookedFish.fish.AttachToHook(hookRigidbody);
		bobber.GetComponent<Rigidbody>().constraints = RigidbodyConstraints.FreezePositionY;
	}

	public void AllowPullup()
	{
		hookRigidbody.constraints = RigidbodyConstraints.None;
		bobber.GetComponent<Rigidbody>().constraints = RigidbodyConstraints.None;
		hookedFish.fish.AllowPullup();
	}

	private void OnFishingRodSignal(FishingRodEventType type)
	{
		switch (type)
		{
		case FishingRodEventType.StartCasting:
			isFishing = true;
			break;
		case FishingRodEventType.StartAutoReelIn:
		case FishingRodEventType.StopCasting:
			isFishing = false;
			break;
		case FishingRodEventType.HideRod:
			base.gameObject.SetActive(value: false);
			break;
		case FishingRodEventType.VisibleRod:
			base.gameObject.SetActive(value: true);
			StartCoroutine(ReaplyConnectedBody());
			break;
		}
	}

	private IEnumerator ReaplyConnectedBody()
	{
		yield return new WaitForEndOfFrame();
		AttachToBobber();
	}

	private void OnReelInDone(bool fishOnHook)
	{
		isFishing = false;
	}

	private void OnDestroy()
	{
		FishingRodSignal.RemoveListener(OnFishingRodSignal);
		FishingLine.ReelInDoneSignal.RemoveListener(OnReelInDone);
	}
}
public class Reel : GrabbableObject
{
	[Range(1f, 3f)]
	public float TensionMeterMultiplier = 1f;

	public Transform reelHandleBone;

	public float defaultSpinSpeed = -720f;

	public AnimationCurve tensionCurveWithFish;

	public AnimationCurve tensionCurveWithoutFish;

	public RodGrabbable rod;

	[HideInInspector]
	public SinkerCasting sinkerCasting;

	private bool autoReelInStarted;

	private float avgVelocity;

	private bool allowGrabbing;

	private float previousAngle;

	private float[] spinVelocityBuffer = new float[5];

	private bool isReelingIn;

	private bool isCasting;

	private bool reelInEnabled;

	private bool isReelRotating;

	private Vector3[] handPositions = new Vector3[30];

	private bool isReelingInWithFish;

	private bool isReelingInWithoutFish;

	private bool isAutoReeling;

	[@Dependency]
	public FishingRodEvent FishingRodSignal { get; set; }

	[@Dependency]
	public InputManager Input { get; set; }

	[@Dependency]
	public GameSession gameSession { get; set; }

	public float ReelTensionWithFish => tensionCurveWithFish.Evaluate(avgVelocity);

	public float ReelTensionWithoutFish => tensionCurveWithoutFish.Evaluate(avgVelocity);

	private Vector3 LastHandPos => handPositions[0];

	public void SetRod(RodGrabbable rod)
	{
		this.rod = rod;
	}

	private void Start()
	{
		this.Inject();
		FishingRodSignal.AddListener(OnFishingRodSignal);
		FishingLine.ReelInDoneSignal.AddListener(OnReelInDone);
		avgVelocity = 0f;
		reelInEnabled = false;
	}

	private void OnDestroy()
	{
		FishingRodSignal.RemoveListener(OnFishingRodSignal);
		FishingLine.ReelInDoneSignal.RemoveListener(OnReelInDone);
	}

	public void SetGrabbingAllowed(bool allowed)
	{
		allowGrabbing = allowed;
	}

	public override bool GetIsGrabbable()
	{
		return allowGrabbing;
	}

	public override HandAnimation.Pose GetGrabbedPose()
	{
		return HandAnimation.Pose.HoldReel;
	}

	public override void OnObjectGrabbed(Hand hand, Action OnGrabbed)
	{
		StartCoroutine(CheckReelStatus());
		if (gameSession.GetReelMode() != ReelMode.Click)
		{
			base.OnObjectGrabbed(hand, OnGrabbed);
			int i = 0;
			for (int num = handPositions.Length; i < num; i++)
			{
				ref Vector3 reference = ref handPositions[i];
				reference = reelHandleBone.position;
			}
			Vector3 reelInPosition = hand.ReelInPosition;
			PushPositionBuffer(reelInPosition);
			float handCrankAngle = GetHandCrankAngle();
			int j = 0;
			for (int num2 = spinVelocityBuffer.Length; j < num2; j++)
			{
				spinVelocityBuffer[j] = 0f;
			}
			SetReelAngle(handCrankAngle);
			previousAngle = handCrankAngle;
		}
	}

	public override void OnObjectReleased(Hand hand)
	{
		base.OnObjectReleased(hand);
		sinkerCasting.OnReelInput(InputType.KeyUp);
		isReelingIn = false;
	}

	protected override void StartHovering()
	{
	}

	protected override void EndHovering()
	{
	}

	public override void OnInput(InputAction action, InputType type)
	{
	}

	private float GetHandCrankAngle()
	{
		int num = handPositions.Length;
		for (int i = 1; i < num; i++)
		{
			UnityEngine.Debug.DrawLine(handPositions[i], handPositions[i - 1], Color.red, 0.1f);
		}
		Vector3 zero = Vector3.zero;
		for (int j = 0; j < num; j++)
		{
			zero += handPositions[j];
		}
		zero *= 1f / (float)num;
		UnityEngine.Debug.DrawLine(zero + Vector3.up, zero + Vector3.down, Color.cyan);
		UnityEngine.Debug.DrawLine(zero + Vector3.left, zero + Vector3.right, Color.cyan);
		UnityEngine.Debug.DrawLine(zero + Vector3.forward, zero + Vector3.back, Color.cyan);
		Vector3 vector = reelHandleBone.parent.InverseTransformDirection(hand.ReelInPosition - zero);
		vector.x = 0f;
		return Vector3.SignedAngle(Vector3.up, vector.normalized, Vector3.right);
	}

	private void SetReelAngle(float angle)
	{
		Vector3 localEulerAngles = reelHandleBone.localEulerAngles;
		localEulerAngles.Set(angle, 0f, 0f);
		reelHandleBone.localEulerAngles = localEulerAngles;
	}

	private float GetAverageVelocity(float[] values)
	{
		float num = 0f;
		int num2 = values.Length;
		for (int i = 0; i < num2; i++)
		{
			num += values[i];
		}
		return num / (float)num2;
	}

	private void PushVelocityBuffer(float velocity)
	{
		int num = spinVelocityBuffer.Length;
		for (int num2 = num - 1; num2 > 0; num2--)
		{
			spinVelocityBuffer[num2] = spinVelocityBuffer[num2 - 1];
		}
		spinVelocityBuffer[0] = velocity;
	}

	private void PushPositionBuffer(Vector3 position)
	{
		int num = handPositions.Length;
		for (int num2 = num - 1; num2 > 0; num2--)
		{
			ref Vector3 reference = ref handPositions[num2];
			reference = handPositions[num2 - 1];
		}
		handPositions[0] = position;
	}

	private void Update()
	{
		float num = defaultSpinSpeed * 0.1f;
		float num2 = 0f;
		Handedness handedness = Handedness.None;
		if (isCasting)
		{
			isReelingIn = false;
			return;
		}
		if (reelInEnabled)
		{
			if (gameSession.GetReelMode() == ReelMode.Crank)
			{
				if (hand == null)
				{
					return;
				}
				float handCrankAngle = GetHandCrankAngle();
				SetReelAngle(handCrankAngle);
				if (!Input.IsInputEnabled())
				{
					previousAngle = handCrankAngle;
				}
				num2 = Mathf.DeltaAngle(previousAngle, handCrankAngle) / Time.deltaTime;
				isReelRotating = false;
				if (Mathf.Abs(num2) < num)
				{
					num2 = 0f;
				}
				if (Vector3.Distance(hand.ReelInPosition, LastHandPos) > 0.01f)
				{
					PushPositionBuffer(hand.ReelInPosition);
				}
				previousAngle = handCrankAngle;
				handedness = hand.Handedness;
				if (Vector3.Distance(hand.gameObject.transform.position, base.gameObject.transform.position) > 0.25f)
				{
					OnObjectReleased(hand);
					return;
				}
			}
			else if (gameSession.GetReelMode() == ReelMode.Click)
			{
				if (rod == null || rod.Hand == null)
				{
					return;
				}
				if (rod.Hand.Handedness == Handedness.None)
				{
					PushVelocityBuffer(0f);
					return;
				}
				handedness = rod.Hand.Handedness;
				num2 = Input.Axis(InputAction.Trigger, handedness) * Mathf.Abs(defaultSpinSpeed) * 4f;
				isReelRotating = true;
				if (num2 < Mathf.Abs(num))
				{
					num2 = 0f;
					isReelRotating = false;
				}
				reelHandleBone.Rotate(new Vector3(1f, 0f, 0f), avgVelocity * 0.01f);
			}
		}
		PushVelocityBuffer(num2);
		avgVelocity = Mathf.Abs(GetAverageVelocity(spinVelocityBuffer));
		isReelRotating = Mathf.Abs(avgVelocity) > 100f;
		if (avgVelocity > 0f)
		{
			if (!isReelingIn && sinkerCasting.OnReelInput(InputType.KeyDown))
			{
				isReelingIn = true;
			}
			Input.RandomHaptic(0f, Mathf.Abs(avgVelocity / defaultSpinSpeed) * 0.1f, 0.05f, handedness);
		}
		else if (isReelingIn && sinkerCasting.OnReelInput(InputType.KeyUp))
		{
			isReelingIn = false;
		}
	}

	private void OnReelInDone(bool item)
	{
		autoReelInStarted = false;
		reelInEnabled = false;
	}

	private void OnFishingRodSignal(FishingRodEventType type)
	{
		switch (type)
		{
		case FishingRodEventType.StartCasting:
			isCasting = true;
			reelInEnabled = true;
			break;
		case FishingRodEventType.ReleaseLine:
			isCasting = false;
			break;
		case FishingRodEventType.StartAutoReelIn:
			autoReelInStarted = true;
			break;
		case FishingRodEventType.StartReelInWithFish:
			reelInEnabled = true;
			isReelingInWithoutFish = false;
			isReelingInWithFish = true;
			break;
		case FishingRodEventType.StartReelInWithoutFish:
			avgVelocity = defaultSpinSpeed;
			isReelingInWithoutFish = true;
			isReelingInWithFish = false;
			break;
		case FishingRodEventType.StopReelIn:
			if (!autoReelInStarted)
			{
				avgVelocity = 0f;
			}
			isReelingInWithoutFish = false;
			isReelingInWithFish = false;
			break;
		case FishingRodEventType.StopCranking:
			reelInEnabled = false;
			break;
		case FishingRodEventType.JerkRodWithFish:
		case FishingRodEventType.JerkRodWithoutFish:
		case FishingRodEventType.StopCasting:
		case FishingRodEventType.HideRod:
		case FishingRodEventType.VisibleRod:
			break;
		}
	}

	private IEnumerator CheckReelStatus()
	{
		bool isReeling = false;
		while (true)
		{
			if (isReelRotating && !isReeling && reelInEnabled)
			{
				if (isReelingInWithoutFish)
				{
					FishingRodSignal.Dispatch(FishingRodEventType.StartReelInWithoutFishSound);
				}
				else if (isReelingInWithFish)
				{
					FishingRodSignal.Dispatch(FishingRodEventType.StartReelInWithFishSound);
				}
				isReeling = true;
			}
			if ((!isReelRotating && isReeling) || !reelInEnabled)
			{
				FishingRodSignal.Dispatch(FishingRodEventType.StopReelInSound);
				isReeling = false;
			}
			yield return null;
		}
	}
}
public enum ReelMode
{
	Crank,
	Click
}
public enum ReelType
{
	Reel1,
	Reel2,
	Reel3,
	Reel4
}
public class RodAssembler : MonoBehaviour
{
	public struct RodParts
	{
		public GameObject rod;

		public GameObject reel;

		public GameObject hook;

		public GameObject bobber;

		public GameObject bait;
	}

	[Serializable]
	public class BobberInfo
	{
		public BobberType bobberType;

		public GameObject prefab;
	}

	[Serializable]
	public class RodInfo
	{
		public RodType rodType;

		public GameObject prefab;
	}

	[Serializable]
	public class ReelInfo
	{
		public ReelType reelType;

		public GameObject prefab;
	}

	[Serializable]
	public class BaitInfo
	{
		public BaitType baitType;

		public GameObject prefab;
	}

	public static Signal<RodParts> RodAssembledNotification = new Signal<RodParts>();

	public GameObject rodTip;

	public GameObject rodHolder;

	private Camera centerCamera;

	public GameObject hookPrefab;

	public RodGrabbable rodGrabbable;

	private GameObject rodPrefab;

	private GameObject bobberPrefab;

	private GameObject reelPrefab;

	private GameObject baitPrefab;

	private RodParts parts = default(RodParts);

	[@Dependency]
	public InventoryManager inventoryManager { get; set; }

	[@Dependency]
	public GameSession gameSession { get; set; }

	[@Dependency]
	public InputModeSwitchEvent GearVRInputSwitchSignal { get; set; }

	[@Dependency]
	public InputManager input { get; set; }

	private void Start()
	{
		this.Inject();
		centerCamera = Camera.main;
		SinkerCasting.CatchFishSignal.AddListener(CheckBaitQuantity);
		InventoryGUI.equipBaitNotification.AddListener(ChangeBait);
		gameSession.CastingModeChangedSignal.AddListener(OnCastingModeChanged);
		GearVRInputSwitchSignal.AddListener(OnActiveControllerChanged);
		UpdatedPrefabs();
		AssembleRod();
	}

	public void UpdatedPrefabs()
	{
		bobberPrefab = GearRegistry.Instance.GetBobberByType(inventoryManager.Inventory.Bobber);
		rodPrefab = GearRegistry.Instance.GetRodByType(inventoryManager.Inventory.Rod, gameSession.GetCastingMode(), input.GetInputMode());
		reelPrefab = GearRegistry.Instance.GetReelByType(inventoryManager.Inventory.Reel);
		baitPrefab = GearRegistry.Instance.GetBaitByType(inventoryManager.Inventory.CurrentBait);
	}

	private void OnCastingModeChanged(CastingMode castingMode)
	{
		AssembleRodRuntime();
		gameSession.AfterCastingModeChangedSignal.Dispatch(castingMode);
	}

	private void DestroyRodParts()
	{
		UnityEngine.Object.Destroy(parts.rod);
		UnityEngine.Object.Destroy(parts.bait);
		UnityEngine.Object.Destroy(parts.bobber);
		UnityEngine.Object.Destroy(parts.reel);
		UnityEngine.Object.Destroy(parts.hook);
	}

	private void ChangeBait(BaitType newBaitType)
	{
		UnityEngine.Object.Destroy(parts.bait);
		parts.bait = null;
		GameObject baitByType = GearRegistry.Instance.GetBaitByType(newBaitType);
		parts.bait = UnityEngine.Object.Instantiate(baitByType, parts.hook.transform.position, Quaternion.identity);
		parts.bait.transform.parent = parts.hook.transform;
		parts.bait.GetComponent<Bait>().HideBait();
	}

	private void AssembleRodRuntime()
	{
		SinkerCasting.FishingState currentState = parts.rod.GetComponent<SinkerCasting>().currentState;
		Vector3 localRodtipPosition = parts.rod.GetComponent<SinkerCasting>().localRodtipPosition;
		parts.reel.transform.parent = null;
		UnityEngine.Object.Destroy(parts.rod);
		UpdatedPrefabs();
		GameObject gameObject = UnityEngine.Object.Instantiate(rodPrefab, rodHolder.transform.position, rodHolder.transform.rotation);
		parts.rod = gameObject;
		gameObject.transform.parent = rodHolder.transform;
		gameObject.transform.Rotate(180f, 0f, 180f);
		gameObject.GetComponent<RodBend>().spring = rodTip.GetComponent<SpringJoint>();
		gameObject.GetComponent<RodTilt>().spring = rodTip.GetComponent<SpringJoint>();
		SinkerCasting sinkerCasting = Find.ComponentOnGameObject<SinkerCasting>(gameObject);
		sinkerCasting.hook = parts.hook.GetComponent<Hook>();
		sinkerCasting.rodTip = rodTip.transform;
		sinkerCasting.gameRootTransform = base.transform.parent.transform;
		sinkerCasting.mainCamera = centerCamera;
		sinkerCasting.localRodtipPosition = localRodtipPosition;
		gameObject.GetComponent<RodFader>().forwardDirection = rodHolder.transform;
		sinkerCasting.currentState = currentState;
		rodGrabbable.sinkerCasting = sinkerCasting;
		RodBending component = gameObject.GetComponent<RodBending>();
		component.rodTip = rodTip.transform;
		component.reel = parts.reel.GetComponent<Reel>();
		component.bobber = parts.bobber.GetComponent<Bobber>();
		component.spring = rodTip.GetComponent<SpringJoint>();
		parts.reel.transform.parent = gameObject.transform;
		parts.reel.transform.position = gameObject.transform.position;
		parts.reel.transform.rotation = gameObject.transform.rotation;
		Reel component2 = parts.reel.GetComponent<Reel>();
		component2.sinkerCasting = sinkerCasting;
		RodAssembledNotification.Dispatch(parts);
	}

	private void AssembleRod()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(bobberPrefab, rodTip.transform.position, Quaternion.identity);
		parts.bobber = gameObject;
		gameObject.transform.parent = base.transform;
		gameObject.GetComponent<Bobber>().centerCamera = centerCamera;
		gameObject.GetComponent<Rigidbody>().centerOfMass = new Vector3(0f, 0.1f, 0f);
		GameObject gameObject2 = UnityEngine.Object.Instantiate(hookPrefab, gameObject.transform.position, Quaternion.identity);
		parts.hook = gameObject2;
		gameObject2.transform.parent = base.transform;
		gameObject2.GetComponent<Hook>().bobber = gameObject;
		gameObject2.GetComponent<Hook>().fishingLine = rodTip.GetComponent<FishingLine>();
		gameObject2.GetComponent<SpringJoint>().connectedBody = gameObject.GetComponent<Rigidbody>();
		parts.bait = UnityEngine.Object.Instantiate(baitPrefab, gameObject2.transform.position, Quaternion.Euler(0f, 70f, 0f));
		parts.bait.transform.parent = gameObject2.transform;
		GameObject gameObject3 = UnityEngine.Object.Instantiate(rodPrefab, rodHolder.transform.position, rodHolder.transform.rotation);
		parts.rod = gameObject3;
		gameObject3.transform.parent = rodHolder.transform;
		gameObject3.transform.Rotate(180f, 0f, 180f);
		gameObject3.GetComponent<RodBend>().spring = rodTip.GetComponent<SpringJoint>();
		gameObject3.GetComponent<RodTilt>().spring = rodTip.GetComponent<SpringJoint>();
		SinkerCasting sinkerCasting = Find.ComponentOnGameObject<SinkerCasting>(gameObject3);
		sinkerCasting.hook = gameObject2.GetComponent<Hook>();
		sinkerCasting.rodTip = rodTip.transform;
		sinkerCasting.gameRootTransform = base.transform.parent.transform;
		sinkerCasting.mainCamera = centerCamera;
		gameObject3.GetComponent<RodFader>().forwardDirection = rodHolder.transform;
		rodGrabbable.sinkerCasting = sinkerCasting;
		rodTip.GetComponent<FishingLine>().hook = gameObject2.GetComponent<Hook>();
		rodTip.GetComponent<FishingLine>().bobber = gameObject;
		rodTip.GetComponent<SpringJoint>().connectedBody = gameObject.GetComponent<Rigidbody>();
		GameObject gameObject4 = UnityEngine.Object.Instantiate(reelPrefab, gameObject3.transform.position, gameObject3.transform.rotation);
		gameObject4.name = "Reel";
		parts.reel = gameObject4;
		gameObject4.transform.parent = gameObject3.transform;
		Reel component = gameObject4.GetComponent<Reel>();
		component.sinkerCasting = sinkerCasting;
		RodBending component2 = gameObject3.GetComponent<RodBending>();
		component2.rodTip = rodTip.transform;
		component2.reel = parts.reel.GetComponent<Reel>();
		component2.bobber = parts.bobber.GetComponent<Bobber>();
		component2.spring = rodTip.GetComponent<SpringJoint>();
		gameObject.GetComponent<Bobber>().reel = component;
		rodTip.GetComponent<FishingLine>().reel = component;
		rodGrabbable.reel = component;
		gameObject2.GetComponent<Hook>().reel = component;
		RodAssembledNotification.Dispatch(parts);
	}

	private void CheckBaitQuantity(Fish fish, GameObject fishGO)
	{
		if (!(fish == null))
		{
			Inventory inventory = inventoryManager.Inventory;
			if (inventory.CurrentBait != inventory.DefaultBait)
			{
				inventoryManager.Inventory.Baits[inventoryManager.Inventory.CurrentBait]--;
			}
			if (inventory.Baits[inventory.CurrentBait] == 0)
			{
				inventory.CurrentBait = inventory.DefaultBait;
				UnityEngine.Object.Destroy(parts.bait);
				GameObject baitByType = GearRegistry.Instance.GetBaitByType(inventory.DefaultBait);
				parts.bait = UnityEngine.Object.Instantiate(baitByType, parts.hook.transform.position, Quaternion.identity);
				parts.bait.transform.parent = parts.hook.transform;
			}
		}
	}

	private void OnActiveControllerChanged(InputMode inputType)
	{
		AssembleRodRuntime();
	}

	private void OnDestroy()
	{
		SinkerCasting.CatchFishSignal.RemoveListener(CheckBaitQuantity);
		InventoryGUI.equipBaitNotification.RemoveListener(ChangeBait);
		gameSession.CastingModeChangedSignal.RemoveListener(OnCastingModeChanged);
		GearVRInputSwitchSignal.RemoveListener(OnActiveControllerChanged);
	}
}
public class RodRotator : MonoBehaviour
{
	public Vector3 offset;

	private bool active = true;

	public bool disable;

	[HideInInspector]
	public bool lerpRotation;

	[@Dependency]
	public InputModeSwitchEvent GearVRInputSwitchSignal { get; set; }

	[@Dependency]
	public InputManager input { get; set; }

	protected void Start()
	{
		this.Inject();
		GearVRInputSwitchSignal.AddListener(OnActiveControllerChanged);
		if (input.GetInputMode() == InputMode.Headset)
		{
			base.enabled = false;
		}
	}

	protected void FixedUpdate()
	{
		if (disable || input.GetInputMode() == InputMode.Headset || !active)
		{
			return;
		}
		Quaternion quaternion = input.GetControllerOrientation() * Quaternion.Euler(offset);
		if (lerpRotation)
		{
			float t = 1f;
			if (Quaternion.Angle(quaternion, base.transform.rotation) > 8f)
			{
				t = 0.5f;
			}
			base.transform.rotation = Quaternion.Slerp(base.transform.rotation, quaternion, t);
			if (quaternion.Equals(base.transform.rotation))
			{
				lerpRotation = false;
			}
		}
		else
		{
			base.transform.rotation = quaternion;
		}
	}

	protected void OnActiveControllerChanged(InputMode type)
	{
		if (type == InputMode.Headset)
		{
			base.enabled = false;
			return;
		}
		base.enabled = true;
		EnableRotator(state: true);
	}

	public void EnableRotator(bool state)
	{
		if (!state)
		{
			lerpRotation = true;
		}
		active = state;
	}

	private void OnDestroy()
	{
		GearVRInputSwitchSignal.RemoveListener(OnActiveControllerChanged);
	}
}
public class RodTipHider : MonoBehaviour
{
	private Rigidbody connectedBody;

	private SpringJoint fishingLineJoint;

	[@Dependency]
	public FishingRodEvent FishingRodSignal { get; set; }

	private void Start()
	{
		this.Inject();
		FishingRodSignal.AddListener(OnFishingRodSignal);
		fishingLineJoint = GetComponent<SpringJoint>();
	}

	private void OnFishingRodSignal(FishingRodEventType type)
	{
		switch (type)
		{
		case FishingRodEventType.HideRod:
			if ((bool)fishingLineJoint.connectedBody)
			{
				connectedBody = fishingLineJoint.connectedBody;
			}
			base.gameObject.SetActive(value: false);
			break;
		case FishingRodEventType.VisibleRod:
			base.gameObject.SetActive(value: true);
			StartCoroutine(ReaplyConnectedBody());
			break;
		}
	}

	private IEnumerator ReaplyConnectedBody()
	{
		if ((bool)connectedBody)
		{
			connectedBody.position = base.transform.position;
		}
		yield return new WaitForEndOfFrame();
		if (connectedBody != null)
		{
			fishingLineJoint.connectedBody = connectedBody;
		}
	}

	private void OnDestroy()
	{
		FishingRodSignal.RemoveListener(OnFishingRodSignal);
	}
}
public enum RodType
{
	Rod1,
	Rod2,
	Rod3
}
public class TensionMeter : MonoBehaviour
{
	public enum TensionMeterEventType
	{
		StartCreeking,
		StopCreeking,
		Full
	}

	public static Signal<TensionMeterEventType> TensionMeterSignal = new Signal<TensionMeterEventType>();

	[Range(0.1f, 1f)]
	public float creekLimit = 0.6f;

	[Range(0.1f, 1f)]
	public float glowLimit = 0.6f;

	[Range(0.1f, 1.5f)]
	public float fishTensionFillTime = 0.6f;

	[Range(10f, 60f)]
	public float fillSpeedMultiplier = 35f;

	[Range(0.1f, 2f)]
	public float decayTime = 0.15f;

	[Range(0f, 1f)]
	public float fatigueTargetTension = 0.2f;

	[Range(0f, 1f)]
	public float maxTensionDelay = 0.5f;

	[Range(0f, 5f)]
	[Tooltip("How much the fich struggle force will effect the tension. 0 means nothing.")]
	public float fishTensionMultiplier;

	public Transform buildUp;

	public Transform glow;

	public Transform bobberPin;

	public Transform exclamationMark;

	[SerializeField]
	[Range(0f, 1f)]
	private float currentTension;

	public bool addTension;

	private float fillUpSpeed;

	private float smoothTime;

	private float fishTension;

	private float maxTension;

	private float fishTensionEffect;

	private bool isCreeking;

	private MeshRenderer buildUpRenderer;

	private float bobberPinOffset = -0.02f;

	private float bobberPinWiggleSpeed = 20f;

	private float bobberPinWiggleMagnitude = 15f;

	private float maxTensionTime;

	public static TensionMeter instance { get; private set; }

	[@Dependency]
	public Quest Quest { get; set; }

	[@Dependency]
	public InputManager Input { get; set; }

	[@Dependency]
	public FishingRodEvent FishingRodSignal { get; set; }

	public Fish Fish { get; set; }

	public Reel Reel { get; set; }

	public RodGrabbable rod { get; set; }

	public Camera CenterCamera { get; set; }

	public float CurrentTension => currentTension;

	public void Awake()
	{
		this.Inject();
		FishingRodSignal.AddListener(OnFishingRodSignal);
		addTension = true;
		smoothTime = fishTensionFillTime;
		instance = this;
	}

	private void Start()
	{
		FishBehavior.FishSignal.AddListener(OnFishSignal);
		buildUpRenderer = buildUp.GetComponent<MeshRenderer>();
		buildUp.localScale = new Vector3(1f, 0f, 1f);
		currentTension = 0f;
		fillUpSpeed = 0f;
		fishTension = 1f;
		fishTensionEffect = 1f + Fish.FishData.struggleForce * fishTensionMultiplier / 100f;
		maxTension = 0.98f;
		GetComponent<Renderer>().sortingOrder = 1;
		GetComponentInChildren<Renderer>().sortingOrder = 1;
		isCreeking = false;
		CheckCreekLimit();
		CheckGlowLimit();
		UpdateBuildUp();
		UpdateBobberPin();
		UpdateExclamationMark();
	}

	private void Update()
	{
		float target = Mathf.Clamp01((Reel.ReelTensionWithFish + fishTension) * 0.5f);
		currentTension = Mathf.SmoothDamp(currentTension, target, ref fillUpSpeed, smoothTime * fishTensionEffect * Reel.TensionMeterMultiplier);
		if (!((double)currentTension < 0.01))
		{
			CheckCreekLimit();
			CheckGlowLimit();
			UpdateBuildUp();
			UpdateBobberPin();
			UpdateExclamationMark();
		}
	}

	private void UpdateBobberPin()
	{
		if (currentTension > glowLimit)
		{
			bobberPin.localEulerAngles = new Vector3(0f, 0f, (Mathf.PingPong(Time.time * bobberPinWiggleSpeed, 2f) - 1f) * bobberPinWiggleMagnitude * ((!(currentTension >= maxTension)) ? 1f : 1.5f));
		}
		else
		{
			bobberPin.transform.localRotation = Quaternion.identity;
		}
		if (currentTension > 0.7f && Quest.CurrentState.Id == "Tutorial01")
		{
			currentTension = 0.7f;
		}
		else
		{
			bobberPin.transform.localPosition = new Vector3(buildUp.localPosition.x - currentTension / 4f, bobberPinOffset, 0f);
		}
	}

	private void UpdateExclamationMark()
	{
		exclamationMark.gameObject.SetActive(currentTension >= maxTension);
	}

	private void CheckCreekLimit()
	{
		if (currentTension > creekLimit && !isCreeking)
		{
			TensionMeterSignal.Dispatch(TensionMeterEventType.StartCreeking);
			isCreeking = true;
		}
		else if (currentTension < creekLimit && isCreeking)
		{
			TensionMeterSignal.Dispatch(TensionMeterEventType.StopCreeking);
			isCreeking = false;
		}
	}

	private void CheckGlowLimit()
	{
		if (currentTension > glowLimit)
		{
			glow.localScale = new Vector3(1f + currentTension * 0.5f, 1f + currentTension * 2f, 1f);
		}
		else
		{
			glow.localScale = Vector3.zero;
		}
	}

	private void UpdateBuildUp()
	{
		if (currentTension > 0.7f && Quest.CurrentState.Id == "Tutorial01")
		{
			return;
		}
		buildUp.transform.localScale = new Vector3(currentTension, 1f, 1f);
		buildUpRenderer.material.SetFloat("_MainProgress", currentTension);
		if (currentTension > 0.55f)
		{
			if (Reel.rod.Hand == null)
			{
				return;
			}
			float num = (currentTension - 0.5f) * 0.25f;
			float duration = 0.05f;
			Input.RandomHaptic(num, num * 1.5f, duration, Reel.rod.Hand.Handedness);
		}
		if (currentTension > maxTension)
		{
			currentTension = 1f;
			maxTensionTime += Time.deltaTime;
			if (maxTensionTime > maxTensionDelay)
			{
				TensionMeterSignal.Dispatch(TensionMeterEventType.Full);
				currentTension = 0f;
				maxTensionTime = 0f;
				buildUp.transform.localScale = new Vector3(currentTension, 1f, 1f);
			}
		}
		else
		{
			maxTensionTime = Mathf.MoveTowards(maxTensionTime, 0f, 0.1f * Time.deltaTime);
		}
	}

	private void OnFishSignal(FishEventType type, Fish fish)
	{
		switch (type)
		{
		case FishEventType.CaptureStruggle:
			fishTension = 1f;
			break;
		case FishEventType.CaptureFatigue:
			fishTension = fatigueTargetTension * fishTensionEffect;
			break;
		}
	}

	private void OnFishingRodSignal(FishingRodEventType type)
	{
		switch (type)
		{
		case FishingRodEventType.StartReelInWithFish:
			smoothTime = fishTensionFillTime;
			addTension = true;
			break;
		case FishingRodEventType.StartAutoReelIn:
			addTension = false;
			break;
		case FishingRodEventType.StopReelIn:
			smoothTime = decayTime;
			addTension = false;
			break;
		case FishingRodEventType.JerkRodWithFish:
		case FishingRodEventType.JerkRodWithoutFish:
			break;
		}
	}

	private void OnDestroy()
	{
		TensionMeterSignal.Dispatch(TensionMeterEventType.StopCreeking);
		FishingRodSignal.RemoveListener(OnFishingRodSignal);
		FishBehavior.FishSignal.RemoveListener(OnFishSignal);
		instance = null;
	}
}
public class TransformSwitcher : MonoBehaviour
{
	public Vector3 positionWhenHeadset;

	public Vector3 rotationWhenHeadSet;

	public Vector3 positionWhenController;

	public Vector3 rotationWhenController;

	[@Dependency]
	public InputModeSwitchEvent GearVRInputSwitchSignal { get; set; }

	[@Dependency]
	public InputManager input { get; set; }

	private void Start()
	{
		this.Inject();
		GearVRInputSwitchSignal.AddListener(OnActiveControllerChanged);
		if (input.GetInputMode() == InputMode.Headset)
		{
			base.transform.localPosition = positionWhenHeadset;
			base.transform.localRotation = Quaternion.Euler(rotationWhenHeadSet);
		}
		else
		{
			base.transform.localPosition = positionWhenController;
			base.transform.localRotation = Quaternion.Euler(rotationWhenController);
		}
	}

	protected void OnActiveControllerChanged(InputMode type)
	{
		if (type == InputMode.Headset)
		{
			base.transform.localPosition = positionWhenHeadset;
			base.transform.localRotation = Quaternion.Euler(rotationWhenHeadSet);
		}
		else
		{
			base.transform.localPosition = positionWhenController;
			base.transform.localRotation = Quaternion.Euler(rotationWhenController);
		}
	}

	private void OnDestroy()
	{
		GearVRInputSwitchSignal.RemoveListener(OnActiveControllerChanged);
	}
}
public class BuyLakeGUI : MonoBehaviour
{
	public Location mapLocation;

	private GameObject loader;

	private BuyLakeButton buyLakeButtonIAP;

	private BuyLakeButton buyLakeButtonRegular;

	private BuyLakeButton buyLakeButton;

	private Text infoText;

	private Text errorText;

	private Text currentBalance;

	private Transform balanceObject;

	private BuyPriceTag priceTagRegular;

	private BuyPriceTag priceTagIAP;

	private BuyPriceTag priceTag;

	private bool isIAP;

	private bool startHasRun;

	[@Dependency]
	public IAPService IAPService { get; set; }

	[@Dependency]
	public BuyableItemData BuyableItemData { get; set; }

	[@Dependency]
	public InventoryManager InventoryManager { get; set; }

	[@Dependency]
	public Quest quest { get; set; }

	[@Dependency]
	public Localization localization { get; set; }

	[@Dependency]
	public RGTracking tracking { get; set; }

	public string mapItemId
	{
		get
		{
			return mapLocation.ToString().ToLower();
		}
		set
		{
			try
			{
				mapLocation = (Location)Enum.Parse(typeof(Location), value, ignoreCase: true);
			}
			catch (ArgumentException)
			{
				UnityEngine.Debug.LogError("Trying to assign location value with id: " + value);
			}
		}
	}

	private void Start()
	{
		this.Inject();
		loader = Find.ChildByName(this, "Loader");
		buyLakeButtonIAP = Find.ComponentOnChild<BuyLakeButton>(this, "BuyButtonIAP");
		buyLakeButtonRegular = Find.ComponentOnChild<BuyLakeButton>(this, "BuyButtonNoIAP");
		infoText = Find.ComponentOnChild<Text>(this, "InfoText");
		priceTagRegular = Find.ComponentOnChild<BuyPriceTag>(this, "PriceFrameNoIAP");
		priceTagIAP = Find.ComponentOnChild<BuyPriceTag>(this, "PriceFrameIAP");
		errorText = Find.ComponentOnChild<Text>(this, "ErrorText");
		currentBalance = Find.ComponentOnChild<Text>(this, "Balance/TextBalance");
		balanceObject = Find.ChildTransformByName(this, "Balance");
		errorText.gameObject.SetActive(value: false);
		OnShow();
		startHasRun = true;
	}

	private void OnShow()
	{
		BuyLakeButton.clickEvent.AddListener(OnBuyButtonClick);
		int money = InventoryManager.Inventory.Money;
		BuyableItemData.Item itemFromId = BuyableItemData.GetItemFromId(mapItemId);
		isIAP = itemFromId.shopBehavior == BuyableItemData.BuyableType.ConsumableIAP || itemFromId.shopBehavior == BuyableItemData.BuyableType.DurableIAP;
		SetupGUI(isIAP);
		if (!isIAP)
		{
			GetProduct(money);
		}
		else
		{
			IAPService.GetProduct(mapItemId, OnGetProductsSuccess, OnGetProductsError);
		}
		tracking.TrackShopEvent("shop", "inspect_item", mapItemId, money, quest.CurrentState);
	}

	private void OnEnable()
	{
		if (startHasRun)
		{
			OnShow();
		}
	}

	private void SetupGUI(bool showIAP)
	{
		buyLakeButtonRegular.gameObject.SetActive(!showIAP);
		priceTagRegular.gameObject.SetActive(!showIAP);
		buyLakeButtonIAP.gameObject.SetActive(showIAP);
		priceTagIAP.gameObject.SetActive(showIAP);
		buyLakeButton = ((!showIAP) ? buyLakeButtonRegular : buyLakeButtonIAP);
		priceTag = ((!showIAP) ? priceTagRegular : priceTagIAP);
		buyLakeButton.IsLoading = showIAP;
		buyLakeButton.IsIAP = showIAP;
		loader.SetActive(showIAP);
		balanceObject.gameObject.SetActive(!showIAP);
		infoText.gameObject.SetActive(!showIAP);
	}

	private void UpdateGUI(string productPrice, bool isAvailable, bool isAffordable)
	{
		loader.SetActive(value: false);
		priceTag.SetPrice(productPrice, localization.GetLanguageFont());
		infoText.gameObject.SetActive(value: true);
		buyLakeButton.IsAvailable = isAvailable;
		buyLakeButton.IsAffordable = isAffordable;
	}

	private void BuyItem()
	{
		if (!isIAP)
		{
			InventoryManager.Inventory.Licenses.Add(mapLocation);
		}
		tracking.TrackShopEvent("shop", "buy", mapItemId, InventoryManager.Inventory.Money, quest.CurrentState);
		FishODex.GoBackSignal.Dispatch();
	}

	private void OnBuyButtonClick()
	{
		if (isIAP)
		{
			buyLakeButton.IsLoading = true;
			loader.SetActive(value: true);
			IAPService.RequestBuyItem(mapItemId, OnBuyItemSuccess, OnBuyItemError);
		}
		else
		{
			ExtractCostFromWallet();
			BuyItem();
		}
	}

	private void GetProduct(int balance)
	{
		BuyableItemData.Item itemFromId = BuyableItemData.GetItemFromId(mapItemId);
		currentBalance.text = balance.ToString();
		bool isAvailable = !InventoryManager.Inventory.Licenses.Contains(mapLocation) && (itemFromId.questCondition == string.Empty || itemFromId.questCondition == quest.CurrentState.Id);
		bool isAffordable = balance >= itemFromId.cost;
		UpdateGUI(itemFromId.cost.ToString(), isAvailable, isAffordable);
	}

	private void ExtractCostFromWallet()
	{
		int cost = BuyableItemData.GetItemFromId(mapItemId).cost;
		InventoryManager.Inventory.Money -= cost;
	}

	private void OnGetProductsSuccess(Product product)
	{
		buyLakeButton.IsLoading = false;
		errorText.gameObject.SetActive(value: false);
		UpdateGUI(product.FormattedPrice, isAvailable: true, isAffordable: true);
	}

	private void OnGetProductsError(string message)
	{
		UpdateGUI("---", isAvailable: false, isAffordable: false);
		errorText.gameObject.SetActive(value: false);
		buyLakeButton.IsLoading = false;
	}

	private void OnIAPItemPurchased(string itemId)
	{
		buyLakeButton.IsLoading = false;
		FishODex.GoBackSignal.Dispatch();
	}

	private void OnBuyItemSuccess(string sku)
	{
		BuyItem();
	}

	private void OnBuyItemError(string message)
	{
		buyLakeButton.IsLoading = false;
		loader.SetActive(value: false);
		buyLakeButton.IsLoading = false;
	}

	private void OnDisable()
	{
		if (BuyLakeButton.clickEvent != null)
		{
			BuyLakeButton.clickEvent.RemoveListener(OnBuyButtonClick);
		}
	}
}
public class ChatContent : DialogView
{
	[Serializable]
	public struct SpeakerSettings
	{
		public string characterId;

		public string screenName;

		public string color;
	}

	public TypewriterText typewriter;

	public ContinueChatButton continueButton;

	public string[] fillerDialogs;

	public SpeakerSettings[] speakerSettings;

	public float textDisplayDelay = 0.5f;

	private string dialogId;

	private LineContext currentLineContext;

	[@Dependency]
	public Quest Quest { get; set; }

	[@Dependency]
	public DialogChatStartEvent StartDialogSignal { get; set; }

	[@Dependency]
	public DialogAdvanceEvent DialogAdvanceSignal { get; set; }

	[@Dependency]
	public DialogEndEvent EndDialogSignal { get; set; }

	[@Dependency]
	public Localization localization { get; set; }

	private void Start()
	{
		this.Inject();
		typewriter.finishedSignal.AddListener(OnTypewriterFinished);
		LeanTween.delayedCall(0.01f, StartShowing);
	}

	private void Destroy()
	{
		typewriter.finishedSignal.RemoveListener(OnTypewriterFinished);
	}

	private void OnEnable()
	{
		if (Quest != null)
		{
			StartShowing();
		}
	}

	private void StartShowing()
	{
		typewriter.ShowText(string.Empty, string.Empty);
		continueButton.gameObject.SetActive(value: false);
		ShowText();
	}

	public void Continue()
	{
		if (typewriter.IsAnimating)
		{
			typewriter.Finish();
		}
		else
		{
			DialogAdvanceSignal.Dispatch();
		}
	}

	private void OnTypewriterFinished()
	{
		if (currentLineContext.isLast)
		{
			EndDialogSignal.Dispatch(dialogId);
			continueButton.gameObject.SetActive(value: false);
		}
	}

	private void ShowText()
	{
		dialogId = Quest.CurrentState.ChatDialog;
		if (dialogId == string.Empty)
		{
			dialogId = fillerDialogs[UnityEngine.Random.Range(0, fillerDialogs.Length)];
		}
		StartDialogSignal.Dispatch(dialogId);
	}

	public override void Say(Dialog.Line line, LineContext context)
	{
		currentLineContext = context;
		string speakerPrefix = GetSpeakerPrefix(line.speaker);
		float startDelay = ((!context.isFirst) ? 0f : 1f);
		typewriter.ShowText(line.text, speakerPrefix, startDelay);
		continueButton.gameObject.SetActive(value: true);
	}

	public override void Clear()
	{
	}

	private string GetSpeakerPrefix(string characterId)
	{
		for (int i = 0; i < speakerSettings.Length; i++)
		{
			if (speakerSettings[i].characterId == characterId)
			{
				string text = localization.GetSpeakerName(speakerSettings[i].characterId);
				if (text != string.Empty)
				{
					text += "";
				}
				return "<color=" + speakerSettings[i].color + ">" + text + "</color>";
			}
		}
		return string.Empty;
	}
}
public class CloseContentButton : GazeButton
{
	public override PostSelectAction OnSelect(GameObject obj)
	{
		UnityEngine.Object.Destroy(base.transform.parent.gameObject);
		return PostSelectAction.WaitForLookAway;
	}
}
public class ContinueChatButton : GazeButton
{
	private ChatContent chatContent;

	private Vector3 startScale;

	private float wobbleSpeed = 5f;

	private float wobbleMagnitude = 0.1f;

	private void Start()
	{
		startScale = base.transform.localScale;
		chatContent = GetComponentInParent<ChatContent>();
	}

	private void Update()
	{
		base.transform.localScale = startScale * (1f + Mathf.Sin(Time.timeSinceLevelLoad * wobbleSpeed) * wobbleMagnitude);
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		chatContent.Continue();
		return PostSelectAction.Restart;
	}

	public override bool IsSelectable(GameObject obj)
	{
		return true;
	}
}
public class FishDetails : MonoBehaviour
{
	public FishDisplay fishDisplay;

	public GameObject star1;

	public GameObject star2;

	public GameObject star3;

	private Dictionary<string, string> templateVariables;

	private bool started;

	private FishData fishToShow;

	[@Dependency]
	public InventoryManager InventoryManager { get; set; }

	[@Dependency]
	public Localization localization { get; set; }

	private void Awake()
	{
		this.Inject();
		templateVariables = new Dictionary<string, string>();
	}

	private void Start()
	{
		started = true;
		if (fishToShow != null)
		{
			StartShowing();
		}
	}

	public void ShowFish(FishData fish)
	{
		fishToShow = fish;
		if (started)
		{
			StartShowing();
		}
	}

	private void StartShowing()
	{
		FishData fish = fishToShow;
		ShowModel(fish);
		UpdateUI(fish);
	}

	private void UpdateUI(FishData fish)
	{
		Dictionary<string, string> dictionary = templateVariables;
		dictionary["name"] = localization.GetString(fish.name);
		dictionary["description"] = localization.GetString(fish.description);
		Inventory inventory = InventoryManager.Inventory;
		inventory.FishRecords.TryGetValue(fish.fishType, out var value);
		inventory.UnopenedFishes.Remove(fish.fishType);
		dictionary["record"] = localization.FormatWeight(value);
		dictionary["limit2"] = localization.FormatWeight(fish.TwoStarWeight);
		dictionary["limit2Unitless"] = localization.FormatWeightWithoutUnit(fish.TwoStarWeight);
		if (localization.CurrentLanguangId == "zh" || localization.CurrentLanguangId == "ko" || localization.CurrentLanguangId == "ja")
		{
			dictionary["limit3"] = string.Format("{0}{1}", localization.FormatWeightWithoutUnit(fish.ThreeStarWeight), localization.GetString("GUI_kg_abbreviation"));
			dictionary["limit3+"] = string.Format("{0}+{1}", localization.FormatWeightWithoutUnit(fish.ThreeStarWeight), localization.GetString("GUI_kg_abbreviation"));
		}
		else
		{
			dictionary["limit3"] = localization.FormatWeight(fish.ThreeStarWeight);
			dictionary["limit3+"] = $"{localization.FormatWeight(fish.ThreeStarWeight)}+";
		}
		dictionary["limit3Unitless"] = localization.FormatWeightWithoutUnit(fish.ThreeStarWeight);
		TextTemplate[] componentsInChildren = GetComponentsInChildren<TextTemplate>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].SetVariables(dictionary, localization.GetLanguageFont());
		}
		FishStar starRating = fish.GetStarRating(value);
		star1.SetActive(value > 0f);
		star2.SetActive(starRating >= FishStar.Two);
		star3.SetActive(starRating >= FishStar.Three);
	}

	private void ShowModel(FishData fish)
	{
		GameObject fishPrefab = FishRegistry.Instance.GetFishPrefab(fish.fishType);
		Fish component = fishPrefab.GetComponent<Fish>();
		component.FishData = fish;
		fishDisplay.transform.localScale = Vector3.one;
		fishDisplay.ShowFish(component);
		fishDisplay.transform.localScale = component.DetailsViewScale;
	}
}
public class FishGrid : MonoBehaviour
{
	public struct Item
	{
		public FishData fish;

		public bool caught;

		public bool unopened;

		public FishStar stars;
	}

	public Vector2 center = Vector2.zero;

	public Vector2 dimensions = new Vector2(100f, 100f);

	public int numberOfRows = 2;

	public int numberOfColumns = 5;

	public GameObject itemTemplate;

	public RectTransform scrollingContent;

	public float scrollTime = 0.2f;

	public FlipPageButton nextPageButton;

	public FlipPageButton previousPageButton;

	public Text pageNumberText;

	public Sprite unknownFishImage;

	private List<Item> items;

	private List<GameObject> objectPool;

	private Rect bounds;

	private int pageNumber;

	private int numberOfPages;

	private float scrollSpeed;

	private const string objectNamePrefix = "Entry";

	[SerializeField]
	private string unknownFishName = "---";

	private bool started;

	[@Dependency]
	public InventoryManager InventoryMgr { get; set; }

	[@Dependency]
	public Localization localization { get; set; }

	private void Awake()
	{
		objectPool = new List<GameObject>();
		nextPageButton.IsNextButton = true;
		previousPageButton.IsNextButton = false;
	}

	private void OnEnable()
	{
		nextPageButton.SelectSignal.AddListener(GoToNextPage);
		previousPageButton.SelectSignal.AddListener(GoToPreviousPage);
	}

	private void OnSelectFishodexButton(GameObject content, bool pushContent, string key)
	{
		if (content.name == "FishOPediaContent" && started)
		{
			ShowFishes();
		}
	}

	private void OnDisable()
	{
		nextPageButton.SelectSignal.RemoveListener(GoToNextPage);
		previousPageButton.SelectSignal.RemoveListener(GoToPreviousPage);
	}

	private void Start()
	{
		if (!started)
		{
			this.Inject();
			SelectFishButton.ShowFishSignal.AddListener(OnShowFish);
			FishODexMenuButton.SelectSignal.AddListener(OnSelectFishodexButton);
			started = true;
		}
		bounds = CalculateBounds();
		itemTemplate.SetActive(value: false);
		ShowFishes();
	}

	public void ShowFishes()
	{
		PopulateItemsFromInventory();
		InventoryMgr.Inventory.ClearNewFishes();
		switch (SceneManager.GetActiveScene().name)
		{
		case "OceanLake01":
			pageNumber = 0;
			break;
		case "Swamp_01":
			pageNumber = 1;
			break;
		case "CherryFalls01":
			pageNumber = 2;
			break;
		case "Cave01":
			pageNumber = 3;
			break;
		case "River":
			pageNumber = 4;
			break;
		}
		UpdatePageNumber();
	}

	private void Update()
	{
		Vector3 localPosition = scrollingContent.localPosition;
		float columnWidth = GetColumnWidth();
		float num = columnWidth * (float)numberOfColumns;
		float target = (float)(-pageNumber) * num;
		localPosition.x = Mathf.SmoothDamp(localPosition.x, target, ref scrollSpeed, scrollTime);
		scrollingContent.localPosition = localPosition;
		int num2 = (int)((0f - localPosition.x) / columnWidth + 0.01f);
		int num3 = (int)((0f - localPosition.x + bounds.width) / columnWidth + 1f - 0.01f);
		int column = 0;
		int row = 0;
		int page = 0;
		for (int i = 0; i < objectPool.Count; i++)
		{
			int num4 = column + page * numberOfColumns;
			objectPool[i].SetActive(num4 >= num2 && num4 <= num3);
			GetNextPosition(ref column, ref row, ref page);
		}
	}

	private void OnDestroy()
	{
		for (int i = 0; i < objectPool.Count; i++)
		{
			UnityEngine.Object.Destroy(objectPool[i]);
		}
		objectPool.Clear();
		SelectFishButton.ShowFishSignal.RemoveListener(OnShowFish);
		FishODexMenuButton.SelectSignal.RemoveListener(OnSelectFishodexButton);
	}

	public Item GetItem(UnityEngine.Object entryObject)
	{
		string s = entryObject.name.Substring("Entry".Length);
		int result;
		bool flag = int.TryParse(s, out result);
		return items[result];
	}

	private Rect CalculateBounds()
	{
		return new Rect(center - dimensions * 0.5f, dimensions);
	}

	private void PopulateItemsFromInventory()
	{
		List<FishData> fishes = FishRegistry.Instance.Fishes;
		List<Item> list = new List<Item>(fishes.Count);
		Inventory inventory = InventoryMgr.Inventory;
		for (int i = 0; i < fishes.Count; i++)
		{
			FishData fishData = fishes[i];
			float value;
			bool caught = inventory.FishRecords.TryGetValue(fishData.fishType, out value);
			FishStar starRating = fishData.GetStarRating(value);
			bool unopened = inventory.UnopenedFishes.ContainsKey(fishData.fishType);
			list.Add(new Item
			{
				fish = fishData,
				caught = caught,
				unopened = unopened,
				stars = starRating
			});
		}
		SetItems(list);
	}

	private void SetItems(List<Item> items)
	{
		this.items = items;
		int num = numberOfRows * numberOfColumns;
		numberOfPages = (items.Count + num - 1) / num;
		UpdateItemObjects();
		UpdatePageNumber();
	}

	private void UpdateItemObjects()
	{
		int num = 0;
		int page = 0;
		int row = 0;
		int column = 0;
		for (num = 0; num < items.Count; num++)
		{
			GameObject gameObject = GetGameObject(num);
			gameObject.SetActive(value: true);
			Vector2 anchoredPosition = new Vector2(GetXForColumn(page, column), GetYForRow(row));
			gameObject.GetComponent<RectTransform>().anchoredPosition = anchoredPosition;
			UpdateItemView(num);
			GetNextPosition(ref column, ref row, ref page);
		}
		while (num < objectPool.Count)
		{
			objectPool[num++].SetActive(value: false);
		}
	}

	private GameObject GetGameObject(int entryIndex)
	{
		while (objectPool.Count <= entryIndex)
		{
			objectPool.Add(null);
		}
		if (objectPool[entryIndex] == null)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(itemTemplate);
			gameObject.transform.SetParent(itemTemplate.transform.parent, worldPositionStays: false);
			gameObject.name = "Entry" + entryIndex;
			objectPool[entryIndex] = gameObject;
		}
		return objectPool[entryIndex];
	}

	private void UpdateItemView(int entryIndex)
	{
		Item item = items[entryIndex];
		GameObject go = GetGameObject(entryIndex);
		Image image = Find.ComponentOnChild<Image>(this, go, "FishImage");
		if (item.caught)
		{
			GameObject fishPrefab = FishRegistry.Instance.GetFishPrefab(item.fish.fishType);
			Fish fish = Find.ComponentOnGameObject<Fish>(this, fishPrefab);
			if (fish.flatImage == null)
			{
				UnityEngine.Debug.LogWarningFormat("Fish {0} does not have an image", fish);
				image.sprite = unknownFishImage;
			}
			else
			{
				image.sprite = fish.flatImage;
			}
		}
		else
		{
			image.sprite = unknownFishImage;
		}
		image.SetNativeSize();
		int num = (int)(item.caught ? item.stars : ((FishStar)0));
		foreach (Transform item2 in Find.ChildByName(this, go, "Stars").transform)
		{
			item2.gameObject.SetActive(num-- > 0);
		}
		Text text = Find.ComponentOnChild<Text>(this, go, "FishNameText");
		text.text = ((!item.caught) ? unknownFishName : localization.GetString(item.fish.name));
		text.font = localization.GetLanguageFont();
		GameObject gameObject = Find.ChildByName(this, go, "NewFishIcon");
		gameObject.SetActive(item.unopened);
	}

	private void GetNextPosition(ref int column, ref int row, ref int page)
	{
		if (++column == numberOfColumns)
		{
			column = 0;
			if (++row == numberOfRows)
			{
				row = 0;
				page++;
			}
		}
	}

	private float GetXForColumn(int page, int column)
	{
		return bounds.xMin + (float)(page * numberOfColumns + column) * GetColumnWidth();
	}

	private float GetYForRow(int row)
	{
		return Mathf.LerpUnclamped(bounds.yMax, bounds.yMin, (float)row / ((float)numberOfRows - 1f));
	}

	private float GetColumnWidth()
	{
		if (numberOfColumns == 1)
		{
			return 0f;
		}
		return (bounds.xMax - bounds.xMin) / ((float)numberOfColumns - 1f);
	}

	private void GoToNextPage()
	{
		pageNumber++;
		UpdatePageNumber();
	}

	private void GoToPreviousPage()
	{
		pageNumber--;
		UpdatePageNumber();
	}

	private void UpdatePageNumber()
	{
		pageNumberText.text = pageNumber + 1 + "/" + numberOfPages;
		previousPageButton.gameObject.SetActive(pageNumber > 0);
		nextPageButton.gameObject.SetActive(pageNumber < numberOfPages - 1);
	}

	private void OnShowFish(FishData fish)
	{
		FishType fishType = fish.fishType;
		for (int i = 0; i < items.Count; i++)
		{
			if (items[i].fish.fishType == fishType)
			{
				Item value = items[i];
				value.unopened = false;
				items[i] = value;
				UpdateItemView(i);
				return;
			}
		}
		UnityEngine.Debug.LogWarningFormat("Fishopedia does not have a fish of type {0} but one is shown anyway", fish.fishType);
	}
}
public enum FishODexSoundEventType
{
	Select,
	Close
}
public class FishODex : MonoBehaviour
{
	public static Signal<FishODexSoundEventType> SoundSignal = new Signal<FishODexSoundEventType>();

	public static Signal GoBackSignal = new Signal();

	public Transform contentAnchor;

	public GameObject fishDetailsPrefab;

	public GameObject startContentPrefab;

	public GameObject chatContentPrefab;

	public GameObject missionLogPrefab;

	public GameObject settingsPrefab;

	public GameObject LakeIAPPrefab;

	[Tooltip("These prefabs will be instantiated when the scene loads")]
	public GameObject[] preinstantiations;

	private Dictionary<GameObject, GameObject> instances;

	private GameObject currentContent;

	private Stack<GameObject> goBackStack;

	private GameObject settingsScreen;

	private GameObject castSettings;

	private GameObject reelSettings;

	private GameObject headline;

	private GameObject currentPrefab;

	[@Dependency]
	public FishODexEvent FishODexSignal { get; set; }

	[@Dependency]
	public InputModeSwitchEvent GearVRInputSwitchSignal { get; set; }

	[@Dependency]
	public InputManager input { get; set; }

	[@Dependency]
	public Quest Quest { get; set; }

	[@Dependency]
	public RGTracking tracking { get; set; }

	private void Awake()
	{
		this.Inject();
		InstantiatePrefabs();
		goBackStack = new Stack<GameObject>();
		base.gameObject.SetActive(value: false);
	}

	private void Start()
	{
		FishODexMenuButton.SelectSignal.AddListener(OnMenuButtonSignal);
		SelectFishButton.ShowFishSignal.AddListener(OnShowFish);
		GearVRInputSwitchSignal.AddListener(OnActiveControllerChanged);
		GoBackSignal.AddListener(GoBack);
		settingsScreen = FindChildGameObject("SettingsScreen");
		castSettings = FindChildGameObject("CastSettings");
		reelSettings = FindChildGameObject("ReelSettings");
		headline = FindChildGameObject("Headline");
	}

	private GameObject FindChildGameObject(string name)
	{
		UnityEngine.Component[] componentsInChildren = GetComponentsInChildren(typeof(Transform), includeInactive: true);
		UnityEngine.Component[] array = componentsInChildren;
		for (int i = 0; i < array.Length; i++)
		{
			Transform transform = (Transform)array[i];
			if (transform.name == name)
			{
				return transform.gameObject;
			}
		}
		return null;
	}

	private void OnActiveControllerChanged(InputMode inputType)
	{
		if (currentPrefab.name == "SettingsContent")
		{
			goBackStack.Clear();
			ClearCurrentContent();
			ShowContent(currentPrefab);
			if (inputType == InputMode.Headset)
			{
				UpdateSettingsScreen(showsSettings: false);
			}
			else
			{
				UpdateSettingsScreen(showsSettings: true);
			}
		}
	}

	private void UpdateSettingsScreen(bool showsSettings)
	{
		castSettings.SetActive(showsSettings);
		reelSettings.SetActive(showsSettings);
		if (showsSettings)
		{
			settingsScreen.transform.localPosition = new Vector3(-500f, 61f, 0f);
		}
		else
		{
			settingsScreen.transform.localPosition = new Vector3(-8f, 61f, 0f);
		}
	}

	private void InstantiatePrefabs()
	{
		instances = new Dictionary<GameObject, GameObject>();
		for (int i = 0; i < preinstantiations.Length; i++)
		{
			GameObject gameObject = preinstantiations[i];
			GameObject gameObject2 = CreateInstance(gameObject);
			gameObject2.SetActive(value: false);
			instances[gameObject] = gameObject2;
		}
	}

	public void ShowMap(bool ignoreTracking = false)
	{
		GameObject prefab = startContentPrefab;
		bool ignoreTracking2 = ignoreTracking;
		ChangeContent(prefab, null, ignoreTracking2);
	}

	public void ShowChat()
	{
		ChangeContent(chatContentPrefab);
	}

	public void ShowMissionLog(bool ignoreTracking = false)
	{
		GameObject prefab = missionLogPrefab;
		bool ignoreTracking2 = ignoreTracking;
		ChangeContent(prefab, null, ignoreTracking2);
		MissionLog componentInChildren = currentContent.GetComponentInChildren<MissionLog>();
		if (componentInChildren != null)
		{
			componentInChildren.PopulateData();
		}
	}

	private void OnMenuButtonSignal(GameObject content, bool pushContent, string contentID)
	{
		if (currentContent.name == content.name + "(Clone)")
		{
			return;
		}
		if (pushContent)
		{
			PushContent(content, contentID);
		}
		else
		{
			ChangeContent(content, contentID);
		}
		if (!string.IsNullOrEmpty(contentID))
		{
			ApplyLocalizedText[] componentsInChildren = currentContent.GetComponentsInChildren<ApplyLocalizedText>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].localizationKey = contentID;
			}
			BuyLakeGUI componentInChildren = currentContent.GetComponentInChildren<BuyLakeGUI>();
			if (componentInChildren != null)
			{
				componentInChildren.mapItemId = contentID;
			}
		}
	}

	private void OnShowFish(FishData fish)
	{
		PushContent(fishDetailsPrefab, fish.name);
		FishDetails component = currentContent.GetComponent<FishDetails>();
		component.ShowFish(fish);
	}

	private void GoBack()
	{
		ClearCurrentContent();
		GameObject gameObject = goBackStack.Pop();
		gameObject.SetActive(value: true);
		currentContent = gameObject;
		FishODexSignal.Dispatch(FishODexEventType.GoBack, null);
	}

	private void PushContent(GameObject prefab, string contentID = null)
	{
		if (currentContent != null)
		{
			goBackStack.Push(currentContent);
			ClearCurrentContent();
		}
		ShowContent(prefab);
		TrackFishODDex(prefab, contentID);
	}

	private void ClearCurrentContent()
	{
		if (!(currentContent == null))
		{
			currentContent.SetActive(value: false);
			currentContent = null;
		}
	}

	private void ChangeContent(GameObject prefab, string contentID = null, bool ignoreTracking = false)
	{
		currentPrefab = prefab;
		goBackStack.Clear();
		ClearCurrentContent();
		ShowContent(prefab);
		if (prefab.name == "SettingsContent")
		{
			if (input.GetInputMode() == InputMode.Headset)
			{
				UpdateSettingsScreen(showsSettings: false);
			}
			else
			{
				UpdateSettingsScreen(showsSettings: true);
			}
		}
		if (!ignoreTracking)
		{
			TrackFishODDex(prefab, contentID);
		}
	}

	private void ShowContent(GameObject prefab)
	{
		if (!instances.TryGetValue(prefab, out currentContent))
		{
			currentContent = CreateInstance(prefab);
		}
		currentContent.SetActive(value: true);
	}

	private void TrackFishODDex(GameObject content, string contentID = null)
	{
		if (!(content == null))
		{
			tracking.TrackFishoDexEvent(content.name, contentID);
		}
	}

	private GameObject CreateInstance(GameObject contentPrefab)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(contentPrefab, contentAnchor.position, Quaternion.identity);
		Vector3 contentAnchorOffset = Find.ComponentOnGameObject<FishODexContent>(gameObject).ContentAnchorOffset;
		gameObject.transform.SetParent(contentAnchor.transform, worldPositionStays: false);
		gameObject.transform.localPosition = Vector3.zero + contentAnchorOffset;
		return gameObject;
	}

	private void OnDestroy()
	{
		FishODexMenuButton.SelectSignal.RemoveListener(OnMenuButtonSignal);
		SelectFishButton.ShowFishSignal.RemoveListener(OnShowFish);
		GoBackSignal.RemoveListener(GoBack);
		GearVRInputSwitchSignal.RemoveListener(OnActiveControllerChanged);
	}
}
public class FishODexCallNotification : MonoBehaviour
{
	public static Signal<Transform, bool> CallSignal = new Signal<Transform, bool>();

	public float wiggleSpeed = 5f;

	public float wiggleMagnitude = 40f;

	private Quaternion startRotation;

	private float delayForNotification;

	private bool hasFiredNotification;

	private float scriptStartTime;

	public Camera centerCamera { get; set; }

	private void Start()
	{
		this.Inject();
		scriptStartTime = Time.time;
		base.transform.LookAt(centerCamera.transform.position);
		base.transform.localRotation *= Quaternion.Euler(180f, 0f, 180f);
		startRotation = base.transform.localRotation;
		GetComponent<Renderer>().enabled = false;
	}

	public void Setup(Camera camera, int delay)
	{
		centerCamera = camera;
		delayForNotification = delay;
	}

	private void Update()
	{
		if (!hasFiredNotification && Time.time > scriptStartTime + delayForNotification)
		{
			hasFiredNotification = true;
			CallSignal.Dispatch(base.transform, item2: true);
			GetComponent<Renderer>().enabled = true;
		}
		else
		{
			base.transform.localRotation = startRotation * Quaternion.Euler(0f, 0f, Mathf.Sin(Time.timeSinceLevelLoad * wiggleSpeed) * wiggleMagnitude);
		}
	}

	private void OnDestroy()
	{
		if (CallSignal != null)
		{
			CallSignal.Dispatch(base.transform, item2: false);
		}
	}
}
public class FishODexCloseButton : GazeButton
{
	public Material enabledMaterial;

	public Material disabledMaterial;

	public string[] disabledQuestStates;

	public static Signal SelectSignal = new Signal();

	private Image image;

	private bool isEnabled;

	private bool wobble;

	private Vector3 startScale;

	private float wobbleSpeed = 5f;

	private float wobbleMagnitude = 0.13f;

	private Vector3 hoverScale;

	private bool onDialogEndSubscribed;

	[@Dependency]
	public FishODexEvent FishODexSignal { get; set; }

	[@Dependency]
	public Quest Quest { get; set; }

	[@Dependency]
	public InputManager input { get; set; }

	[@Dependency]
	public DialogEndEvent DialogEndNotification { get; set; }

	private void Awake()
	{
		image = GetComponent<Image>();
		startScale = base.transform.localScale;
	}

	private void Start()
	{
		this.Inject();
		isEnabled = true;
		wobble = false;
		Quest.EnterQuestStateSignal.AddListener(OnEnterQuestState);
		input.AddBackButtonListener(4, BackButtonFunction);
		CheckQuestState();
		float num = 1.4f;
		hoverScale = startScale * num;
	}

	private void OnEnterQuestState(QuestState obj)
	{
		CheckQuestState();
	}

	private void OnEnable()
	{
		if (Quest != null)
		{
			CheckQuestState();
		}
	}

	private void Update()
	{
		if (!(Quest.CurrentState.Id != "Intro01") && wobble)
		{
			base.transform.localScale = startScale * (1f + Mathf.Sin(Time.timeSinceLevelLoad * wobbleSpeed) * wobbleMagnitude);
		}
	}

	public override void OnStartGaze()
	{
		LeanTween.cancel(base.gameObject);
		if (Quest.CurrentState.Id != "Intro01")
		{
			LeanTween.scale(base.gameObject, hoverScale, 0.2f).setEase(LeanTweenType.easeOutSine);
		}
		FishODexSignal.Dispatch(FishODexEventType.ItemHover, base.gameObject.transform);
	}

	public override void OnStopGaze()
	{
		LeanTween.cancel(base.gameObject);
		if (Quest.CurrentState.Id != "Intro01")
		{
			LeanTween.scale(base.gameObject, startScale, 0.2f).setEase(LeanTweenType.easeOutSine);
		}
	}

	public override bool IsSelectable(GameObject obj)
	{
		return isEnabled;
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		SendCloseEvents();
		return PostSelectAction.WaitForLookAway;
	}

	private void SendCloseEvents()
	{
		SelectSignal.Dispatch();
		FishODexSignal.Dispatch(FishODexEventType.Close, base.gameObject.transform);
	}

	private void CheckQuestState()
	{
		if (disabledQuestStates.Contains(Quest.CurrentState.Id) || Quest.CurrentState.Condition is ChatCondition)
		{
			Disable();
		}
		else if (Quest.CurrentState.Condition is ChatAndCloseCondition)
		{
			Disable();
			DialogEndNotification.AddListener(OnDialogEnd);
			onDialogEndSubscribed = true;
		}
		else
		{
			Enable();
		}
	}

	private void OnDialogEnd(string dialogId)
	{
		Enable();
		wobble = true;
		DialogEndNotification.RemoveListener(OnDialogEnd);
		onDialogEndSubscribed = false;
	}

	private void Disable()
	{
		isEnabled = false;
		wobble = false;
		image.material = disabledMaterial;
	}

	private void Enable()
	{
		isEnabled = true;
		image.material = enabledMaterial;
	}

	public CallbackResult BackButtonFunction()
	{
		if (base.gameObject.activeInHierarchy)
		{
			if (isEnabled)
			{
				SendCloseEvents();
			}
			return CallbackResult.Consumed;
		}
		return CallbackResult.NotConsumed;
	}

	private void OnDestroy()
	{
		Quest.EnterQuestStateSignal.RemoveListener(OnEnterQuestState);
		if (onDialogEndSubscribed)
		{
			DialogEndNotification.RemoveListener(OnDialogEnd);
		}
		input.RemoveBackButtonListener(BackButtonFunction);
	}
}
public class FishODexContent : MonoBehaviour
{
	public Vector3 ContentAnchorOffset = new Vector3(0f, 0f, 0f);
}
public enum FishODexEventType
{
	Open,
	Close,
	ItemHover,
	ItemSelect,
	GoBack,
	Scroll
}
public class FishODexEvent : Signal<FishODexEventType, Transform>
{
}
public class FishODexMenuButton : GazeButton
{
	[Tooltip("Content to be displayed in view")]
	public GameObject content;

	public Material enabledMaterial;

	public Material disabledMaterial;

	[Tooltip("Queststates where the button is disabled.")]
	public string[] disabledQuestStates;

	[Tooltip("QuestStates where the button is wobbling.")]
	public string[] wobblingQuestStates;

	public static Signal<GameObject, bool, string> SelectSignal = new Signal<GameObject, bool, string>();

	protected Image image;

	private Vector3 originalScale;

	private Vector3 hoverScale;

	private bool isEnabled;

	private bool wobble;

	private Vector3 startScale;

	private float wobbleSpeed = 5f;

	private float wobbleMagnitude = 0.1f;

	[@Dependency]
	public FishODexEvent FishodexSignal { get; set; }

	[@Dependency]
	public Quest Quest { get; set; }

	private void Start()
	{
		this.Inject();
		isEnabled = true;
		wobble = false;
		startScale = base.transform.localScale;
		float num = 1.4f;
		hoverScale = startScale * num;
		image = GetComponent<Image>();
		Quest.EnterQuestStateSignal.AddListener(OnEnterQuestState);
		CheckQuestState();
	}

	private void Update()
	{
		if (wobble)
		{
			base.transform.localScale = startScale * (1f + Mathf.Sin(Time.timeSinceLevelLoad * wobbleSpeed) * wobbleMagnitude);
		}
	}

	private void OnEnterQuestState(QuestState obj)
	{
		CheckQuestState();
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		SelectSignal.Dispatch(content, item2: false, null);
		if (wobble)
		{
			wobble = false;
		}
		FishodexSignal.Dispatch(FishODexEventType.ItemSelect, base.gameObject.transform);
		return PostSelectAction.WaitForLookAway;
	}

	public override bool IsSelectable(GameObject obj)
	{
		return isEnabled;
	}

	public override void OnStartGaze()
	{
		LeanTween.cancel(base.gameObject);
		LeanTween.scale(base.gameObject, hoverScale, 0.2f).setEase(LeanTweenType.easeOutSine);
		FishodexSignal.Dispatch(FishODexEventType.ItemHover, base.gameObject.transform);
	}

	public override void OnStopGaze()
	{
		LeanTween.cancel(base.gameObject);
		LeanTween.scale(base.gameObject, startScale, 0.2f).setEase(LeanTweenType.easeOutSine);
	}

	private void CheckQuestState()
	{
		if (disabledQuestStates.Contains(Quest.CurrentState.Id) || Quest.CurrentState.Condition is ChatCondition || Quest.CurrentState.Condition is ChatAndCloseCondition)
		{
			Disable();
		}
		else
		{
			Enable();
		}
		if (wobblingQuestStates.Contains(Quest.CurrentState.Id))
		{
			wobble = true;
		}
		else
		{
			wobble = false;
		}
	}

	private void Disable()
	{
		LeanTween.cancel(base.gameObject);
		if (image != null && disabledMaterial != null)
		{
			image.material = disabledMaterial;
		}
		isEnabled = false;
	}

	private void Enable()
	{
		if (image != null && enabledMaterial != null)
		{
			image.material = enabledMaterial;
		}
		isEnabled = true;
	}

	private void OnDestroy()
	{
		LeanTween.cancel(base.gameObject);
		Quest.EnterQuestStateSignal.RemoveListener(OnEnterQuestState);
	}
}
public class FishODexQuestNotification : MonoBehaviour
{
	[@Dependency]
	public Quest Quest { get; set; }

	private void Start()
	{
		this.Inject();
		Quest.EnterQuestStateSignal.AddListener(OnEnterQuestState);
		FishODexMenuButton.SelectSignal.AddListener(OnMenuButtonClick);
		FishODexSpawner.FishODexSpawnSignal.AddListener(OnFishODexSpawnSignal);
		CheckQuestState(Quest.CurrentState);
	}

	private void OnFishODexSpawnSignal(FishODexSpawnContent selectedTab, bool wasBackButton)
	{
		if (selectedTab == FishODexSpawnContent.MissionLog)
		{
			DisableQuestNotification();
		}
	}

	private void OnMenuButtonClick(GameObject content, bool pushContent, string key)
	{
		if (content.name == "MissionLogContent")
		{
			DisableQuestNotification();
		}
	}

	private void DisableQuestNotification()
	{
		base.gameObject.SetActive(value: false);
		Quest.CurrentState.HasNotification = false;
	}

	private void OnEnterQuestState(QuestState questState)
	{
		CheckQuestState(questState);
	}

	private void CheckQuestState(QuestState questState)
	{
		if (questState.HasNotification)
		{
			base.gameObject.SetActive(value: true);
		}
		else
		{
			base.gameObject.SetActive(value: false);
		}
	}

	private void OnDestroy()
	{
		if (Quest.EnterQuestStateSignal != null)
		{
			Quest.EnterQuestStateSignal.RemoveListener(OnEnterQuestState);
		}
		if (FishODexMenuButton.SelectSignal != null)
		{
			FishODexMenuButton.SelectSignal.RemoveListener(OnMenuButtonClick);
		}
		if (FishODexSpawner.FishODexSpawnSignal != null)
		{
			FishODexSpawner.FishODexSpawnSignal.RemoveListener(OnFishODexSpawnSignal);
		}
	}
}
public enum FishODexSpawnContent
{
	Map,
	MissionLog
}
public class FishODexSpawner : GazeButton
{
	public static Signal<FishODexSpawnContent, bool> FishODexSpawnSignal = new Signal<FishODexSpawnContent, bool>();

	public Vector3 spawnScale = new Vector3(1f, 1f, 1f);

	public Vector3 spawnRotation = new Vector3(0f, 0f, 0f);

	public Transform UIAnchor;

	public Transform callNotifyAnchor;

	public Transform cameraTransform;

	public GameObject fishODexPrefab;

	public float spawnAnimationTime = 0.4f;

	public Vector3 UIAnchorPositionOffset = new Vector3(0f, 1.91f, -1.7f);

	private Camera centerCamera;

	public GameObject callNotificationPrefab;

	private GameObject fishODex;

	private GameObject callNotification;

	private GameObject callNotificationCue;

	private Vector3 callNotificationOffset = new Vector3(0.1f, 0.6f, 0.05f);

	private bool isShowingNotification;

	private bool disabledByFishing;

	private bool disabledByShopTutorial;

	private bool UIShowing;

	private Vector3 hoverScale;

	private Vector3 startScale;

	[SerializeField]
	private GameObject canvas;

	private int showHideTween = -1;

	[@Dependency]
	public UIDisplayEvent UIDisplaySignal { get; set; }

	[@Dependency]
	public FishingRodEvent FishingRodSignal { get; set; }

	[@Dependency]
	public InputManager Input { get; set; }

	[@Dependency]
	public Quest Quest { get; set; }

	[@Dependency]
	public RGTracking tracking { get; set; }

	private void Start()
	{
		this.Inject();
		FishODexCloseButton.SelectSignal.AddListener(OnCloseSignal);
		FishODexSpawnSignal.AddListener(OnFishODexSpawnSignal);
		Quest.EnterQuestStateSignal.AddListener(OnEnterQuestState);
		FishingRodSignal.AddListener(OnFishingRodSignal);
		FishingLine.ReelInDoneSignal.AddListener(OnReelInDoneSignal);
		CatchDisplay.CatchDisplaySignal.AddListener(OnCatchDisplaySignal);
		ForceBuyQuestItem.ForceBuyQuestItemNotification.AddListener(OnForceBuyItemNotification);
		UIDisplaySignal.AddListener(OnUIDisplaySignal);
		isShowingNotification = false;
		disabledByFishing = false;
		disabledByShopTutorial = false;
		UIShowing = false;
		StartCoroutine(WaitForMainCamera());
		Input.AddBackButtonListener(5, OnBackButton);
		SpawnFishODex();
		UIDisplaySignal.Dispatch(UIEventType.Remove);
		if (canvas != null)
		{
			canvas.SetActive(value: false);
		}
		float num = 1.2f;
		startScale = base.transform.localScale;
		hoverScale = startScale * num;
	}

	private void Update()
	{
		if (isShowingNotification && callNotificationCue != null)
		{
			float y = cameraTransform.localEulerAngles.y;
			if (y <= 350f && y >= 240f)
			{
				if (callNotificationCue.activeSelf)
				{
					callNotificationCue.SetActive(value: false);
				}
			}
			else if (!callNotificationCue.activeSelf)
			{
				callNotificationCue.SetActive(value: true);
			}
		}
		if ((!disabledByFishing && Quest.CurrentState.Id != "Tutorial01" && !disabledByShopTutorial && !UIShowing) || fishODex.activeSelf)
		{
			canvas.SetActive(value: false);
		}
		else
		{
			canvas.SetActive(value: true);
		}
		if (Input.IsButtonDown(InputAction.Special, Handedness.Left))
		{
			if (!disabledByFishing && Quest.CurrentState.Id != "Tutorial01" && !disabledByShopTutorial && !UIShowing)
			{
				ShowFishodex(wasBackButton: false);
			}
			else if (!disabledByFishing && Quest.CurrentState.Id != "Tutorial01" && !disabledByShopTutorial)
			{
				OnCloseSignal();
			}
		}
	}

	private IEnumerator WaitForMainCamera()
	{
		while (centerCamera == null)
		{
			centerCamera = Camera.main;
			yield return null;
		}
		cameraTransform = centerCamera.transform;
		callNotifyAnchor = Find.ChildTransformByName(centerCamera, "CallNotificationAnchor");
		CheckCallNotification();
	}

	public override void OnStartGaze()
	{
		LeanTween.cancel(base.gameObject);
		LeanTween.scale(base.gameObject, hoverScale, 0.2f).setEase(LeanTweenType.easeOutSine);
		UIDisplaySignal.Dispatch(UIEventType.StartGaze);
	}

	public override void OnStopGaze()
	{
		LeanTween.cancel(base.gameObject);
		LeanTween.scale(base.gameObject, startScale, 0.2f).setEase(LeanTweenType.easeOutSine);
		UIDisplaySignal.Dispatch(UIEventType.StopGaze);
	}

	public override bool IsSelectable(GameObject obj)
	{
		return !disabledByFishing && Quest.CurrentState.Id != "Tutorial01" && !disabledByShopTutorial && !UIShowing;
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		FishODexSpawnSignal.Dispatch(FishODexSpawnContent.Map, item2: false);
		return PostSelectAction.WaitForLookAway;
	}

	public bool IsShowingOrHiding()
	{
		return LeanTween.isTweening(showHideTween);
	}

	private void OnEnterQuestState(QuestState questState)
	{
		if (questState.Condition is ChatCondition && !isShowingNotification)
		{
			if (Quest.CurrentState.Id == "Intro01")
			{
				SpawnNotification(3);
			}
			else
			{
				SpawnNotification(0);
			}
		}
		CheckCallNotification();
	}

	private void CheckCallNotification()
	{
		QuestCondition condition = Quest.CurrentState.Condition;
		if ((condition is ChatCondition || condition is ChatAndCloseCondition) && !isShowingNotification)
		{
			if (Quest.CurrentState.Id == "Intro01")
			{
				SpawnNotification(3);
			}
			else
			{
				SpawnNotification(0);
			}
		}
	}

	private void OnFishODexSpawnSignal(FishODexSpawnContent selectedTab, bool wasBackButton)
	{
		ShowFishodex(wasBackButton, selectedTab == FishODexSpawnContent.MissionLog);
	}

	private void SpawnNotification(int delay)
	{
		callNotificationCue = UnityEngine.Object.Instantiate(callNotificationPrefab, callNotifyAnchor.position, Quaternion.identity);
		callNotification = UnityEngine.Object.Instantiate(callNotificationPrefab, base.transform.position + callNotificationOffset, Quaternion.identity);
		callNotification.GetComponent<FishODexCallNotification>().Setup(centerCamera, delay);
		callNotification.transform.parent = base.transform;
		callNotificationCue.GetComponent<FishODexCallNotification>().Setup(centerCamera, delay);
		callNotificationCue.transform.parent = callNotifyAnchor;
		isShowingNotification = true;
	}

	private void RemoveNotification()
	{
		if (callNotification != null)
		{
			UnityEngine.Object.Destroy(callNotification);
		}
		if (callNotificationCue != null)
		{
			UnityEngine.Object.Destroy(callNotificationCue);
		}
		isShowingNotification = false;
	}

	private void OnFishingRodSignal(FishingRodEventType eventType)
	{
		switch (eventType)
		{
		case FishingRodEventType.ReleaseLine:
			disabledByFishing = true;
			break;
		case FishingRodEventType.StopCasting:
			disabledByFishing = false;
			break;
		}
	}

	private void OnReelInDoneSignal(bool fishOnHook)
	{
		if (!fishOnHook)
		{
			disabledByFishing = false;
		}
	}

	private void OnCatchDisplaySignal(CatchDisplayEventType eventType)
	{
		if (eventType == CatchDisplayEventType.Show)
		{
			disabledByFishing = false;
		}
	}

	private void OnForceBuyItemNotification(ForceBuyEventType eventType)
	{
		switch (eventType)
		{
		case ForceBuyEventType.Begin:
		case ForceBuyEventType.BuyItem:
			disabledByShopTutorial = true;
			break;
		case ForceBuyEventType.End:
			disabledByShopTutorial = false;
			break;
		}
	}

	private void SpawnFishODex()
	{
		if (fishODex == null)
		{
			fishODex = UnityEngine.Object.Instantiate(fishODexPrefab, UIAnchor.transform.position, Quaternion.identity);
			fishODex.transform.position = base.transform.position;
			fishODex.transform.localScale = Vector3.zero;
			fishODex.transform.parent = UIAnchor.transform;
			fishODex.transform.localRotation = Quaternion.Euler(spawnRotation);
		}
	}

	private void ShowFishodex(bool wasBackButton, bool wasMissionLog = false)
	{
		UIDisplaySignal.Dispatch(UIEventType.Display);
		SpawnFishODex();
		LTDescr lTDescr = LeanTween.moveLocal(fishODex, UIAnchorPositionOffset, spawnAnimationTime);
		showHideTween = lTDescr.uniqueId;
		LeanTween.scale(fishODex, spawnScale, spawnAnimationTime);
		RemoveNotification();
		fishODex.SetActive(value: true);
		FishODex component = fishODex.GetComponent<FishODex>();
		if (Quest.CurrentState.Condition is ChatCondition || Quest.CurrentState.Condition is ChatAndCloseCondition)
		{
			component.ShowChat();
		}
		else if (wasMissionLog)
		{
			tracking.TrackFishoDexEvent("MissionLogContent", "CatchDisplay");
			component.ShowMissionLog(ignoreTracking: true);
		}
		else
		{
			tracking.TrackFishoDexEvent("Open", (!wasBackButton) ? "FishodexSpawner" : "BackButton");
			component.ShowMap(ignoreTracking: true);
		}
	}

	private void OnUIDisplaySignal(UIEventType type)
	{
		switch (type)
		{
		case UIEventType.Display:
			UIShowing = true;
			break;
		case UIEventType.Remove:
			UIShowing = false;
			break;
		}
	}

	private void OnCloseSignal()
	{
		if (!IsShowingOrHiding())
		{
			LTDescr lTDescr = LeanTween.move(fishODex, base.transform.position, spawnAnimationTime).setEase(LeanTweenType.easeOutCirc);
			showHideTween = lTDescr.uniqueId;
			LeanTween.scale(fishODex, new Vector3(0.01f, 0.01f, 0.01f), spawnAnimationTime).setEase(LeanTweenType.easeOutCirc).setOnComplete((Action)delegate
			{
				fishODex.transform.localScale = Vector3.zero;
				fishODex.SetActive(value: false);
			});
			UIDisplaySignal.Dispatch(UIEventType.Remove);
		}
	}

	public CallbackResult OnBackButton()
	{
		return CallbackResult.NotConsumed;
	}

	private void OnDestroy()
	{
		FishODexCloseButton.SelectSignal.RemoveListener(OnCloseSignal);
		Quest.EnterQuestStateSignal.RemoveListener(OnEnterQuestState);
		FishODexSpawnSignal.RemoveListener(OnFishODexSpawnSignal);
		FishingLine.ReelInDoneSignal.RemoveListener(OnReelInDoneSignal);
		CatchDisplay.CatchDisplaySignal.RemoveListener(OnCatchDisplaySignal);
		ForceBuyQuestItem.ForceBuyQuestItemNotification.RemoveListener(OnForceBuyItemNotification);
		FishingRodSignal.RemoveListener(OnFishingRodSignal);
		Input.RemoveBackButtonListener(OnBackButton);
		if (UIDisplaySignal != null)
		{
			UIDisplaySignal.RemoveListener(OnUIDisplaySignal);
		}
	}
}
public class FishODexSpawnerBobberRotation : MonoBehaviour
{
	public float speed = 10f;

	private Quaternion startRotation;

	private void Start()
	{
		startRotation = base.transform.localRotation;
	}

	private void Update()
	{
		base.transform.localRotation = startRotation * Quaternion.Euler(0f, speed * Time.timeSinceLevelLoad, 0f);
	}
}
public class FlipPageButton : GazeButton
{
	private Signal selectSignal = new Signal();

	[@Dependency]
	public FishODexEvent FishODexSignal { get; set; }

	public bool IsNextButton { get; set; }

	public Signal SelectSignal => selectSignal;

	private void OnEnable()
	{
		ControllerSwipe.SwipeSignal.AddListener(OnSwipe);
	}

	private void OnDisable()
	{
		ControllerSwipe.SwipeSignal.RemoveListener(OnSwipe);
	}

	public void OnSwipe(SwipeDirection swipe)
	{
		if ((IsNextButton && swipe == SwipeDirection.Left) || (!IsNextButton && swipe == SwipeDirection.Right))
		{
			PressButton();
		}
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		PressButton();
		return PostSelectAction.Restart;
	}

	private void PressButton()
	{
		FishODexSignal.Dispatch(FishODexEventType.Scroll, null);
		selectSignal.Dispatch();
	}
}
public class GoBackButton : GazeButton
{
	[@Dependency]
	public InputManager input { get; set; }

	private void Start()
	{
		this.Inject();
		input.AddBackButtonListener(3, BackButtonFunction);
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		FishODex.GoBackSignal.Dispatch();
		return PostSelectAction.Restart;
	}

	public CallbackResult BackButtonFunction()
	{
		if (base.gameObject.activeInHierarchy)
		{
			FishODex.GoBackSignal.Dispatch();
			return CallbackResult.Consumed;
		}
		return CallbackResult.NotConsumed;
	}

	private void OnDestroy()
	{
		input.RemoveBackButtonListener(BackButtonFunction);
	}
}
public class IAPImageCaruselButton : GazeButton
{
	public IAPImageScrollController.Direction dir;

	private void Start()
	{
		this.Inject();
	}

	private void OnEnable()
	{
		ControllerSwipe.SwipeSignal.AddListener(OnSwipe);
	}

	private void OnDisable()
	{
		ControllerSwipe.SwipeSignal.RemoveListener(OnSwipe);
	}

	public void OnSwipe(SwipeDirection swipe)
	{
		if ((dir == IAPImageScrollController.Direction.Right && swipe == SwipeDirection.Left) || (dir == IAPImageScrollController.Direction.Left && swipe == SwipeDirection.Right))
		{
			PressButton();
		}
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		PressButton();
		return base.OnSelect(obj);
	}

	private void PressButton()
	{
		IAPImageScrollController.clickEvent.Dispatch(dir);
	}
}
public class IAPImageScrollController : MonoBehaviour
{
	public enum Direction
	{
		Right,
		Left
	}

	public static Signal<Direction> clickEvent = new Signal<Direction>();

	[SerializeField]
	public Scrollbar scrollbar;

	[SerializeField]
	private bool shouldAutoscroll;

	[SerializeField]
	private ScrollRect scrollrect;

	[SerializeField]
	private RectTransform contentParent;

	[SerializeField]
	private int scrollSteps = 1;

	private int scrollIndexTarget;

	private bool startHasRun;

	private void Start()
	{
		this.Inject();
		clickEvent.AddListener(HumanScroll);
		startHasRun = true;
	}

	private void Reset()
	{
		VerifyComponents();
	}

	private void OnEnable()
	{
		VerifyComponents();
		LeanTween.cancel(scrollrect.gameObject);
		CancelInvoke("AutoScroll");
		if (startHasRun)
		{
			clickEvent.AddListener(HumanScroll);
		}
		if (shouldAutoscroll)
		{
			InvokeRepeating("AutoScroll", 3.5f, 3.5f);
		}
	}

	private void VerifyComponents()
	{
		if (scrollbar == null)
		{
			scrollbar = base.transform.parent.GetComponentInChildren<Scrollbar>();
		}
		if (scrollbar != null && scrollrect == null)
		{
			scrollrect = scrollbar.transform.parent.GetComponent<ScrollRect>();
		}
		if (contentParent == null)
		{
			contentParent = Find.ChildByName(this, "Viewport/Content").GetComponent<RectTransform>();
		}
		scrollSteps = base.transform.parent.GetComponentInChildren<Mask>().transform.GetChild(0).childCount - 1;
		scrollSteps = ((scrollSteps <= 0) ? 1 : scrollSteps);
		scrollIndexTarget = 0;
		scrollrect.horizontalNormalizedPosition = 0f;
	}

	private void AutoScroll()
	{
		Scroll();
	}

	private void HumanScroll(Direction dir)
	{
		CancelInvoke("AutoScroll");
		Scroll(dir);
	}

	private void Scroll(Direction dir = Direction.Right)
	{
		if (LeanTween.isTweening(scrollrect.gameObject))
		{
			return;
		}
		if (dir == Direction.Right)
		{
			scrollIndexTarget++;
			if (scrollIndexTarget > scrollSteps)
			{
				contentParent.GetChild(0).GetComponent<RectTransform>().SetAsLastSibling();
				setScroll(((float)scrollSteps - 1f) / (float)scrollSteps);
				scrollIndexTarget = scrollSteps;
			}
		}
		else
		{
			scrollIndexTarget--;
			if (scrollIndexTarget < 0)
			{
				contentParent.GetChild(contentParent.childCount - 1).GetComponent<RectTransform>().SetAsFirstSibling();
				setScroll(1f / (float)scrollSteps);
				scrollIndexTarget = 0;
			}
		}
		LeanTween.value(scrollrect.gameObject, scrollrect.horizontalNormalizedPosition, (float)scrollIndexTarget / (float)scrollSteps, 0.5f).setOnUpdate(setScroll).setEase(LeanTweenType.easeInOutQuart)
			.setOnComplete(setScrollIndex);
	}

	public void setScrollIndex()
	{
		setScroll((float)scrollIndexTarget / (float)scrollSteps);
	}

	public void setScroll(float value)
	{
		scrollrect.horizontalNormalizedPosition = value;
	}

	private void OnDisable()
	{
		if (clickEvent != null)
		{
			clickEvent.RemoveListener(HumanScroll);
		}
	}
}
public class IAPImageScrollRectNoDrag : ScrollRect
{
	public override void OnBeginDrag(PointerEventData eventData)
	{
	}

	public override void OnDrag(PointerEventData eventData)
	{
	}

	public override void OnEndDrag(PointerEventData eventData)
	{
	}
}
public class InventoryEquipButton : GazeButton
{
	public Sprite enabledBackground;

	public Sprite disabledBackground;

	public Image backGroundImage;

	public Text buttonText;

	public string equippableTextID = "GUI_InventoryEquipButton";

	public string equippedTextID = "GUI_InventoryEquippedButton";

	private bool selectable;

	private InventoryGUI inventoryGUI;

	[@Dependency]
	public Localization localization { get; set; }

	private void Start()
	{
		this.Inject();
		backGroundImage = Find.ComponentOnGameObject<Image>(this);
		buttonText = Find.ComponentInChildren<Text>(this);
		inventoryGUI = GetComponentInParent<InventoryGUI>();
		SetIsEquipped();
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		inventoryGUI.OnEquipButtonClick();
		FishODex.SoundSignal.Dispatch(FishODexSoundEventType.Select);
		SetIsEquipped();
		return base.OnSelect(obj);
	}

	public override bool IsSelectable(GameObject obj)
	{
		return selectable;
	}

	public void SetIsEquipped()
	{
		backGroundImage.sprite = disabledBackground;
		buttonText.text = localization.GetString(equippedTextID);
		buttonText.font = localization.GetLanguageFont();
		selectable = false;
	}

	public void SetIsEquippable()
	{
		backGroundImage.sprite = enabledBackground;
		buttonText.text = localization.GetString(equippableTextID);
		buttonText.font = localization.GetLanguageFont();
		selectable = true;
	}

	public void SetDisabledEquip()
	{
		backGroundImage.sprite = disabledBackground;
		buttonText.text = localization.GetString(equippableTextID);
		buttonText.font = localization.GetLanguageFont();
		selectable = false;
	}
}
public class InventoryGUI : MonoBehaviour
{
	public static Signal<BaitType> equipBaitNotification = new Signal<BaitType>();

	public Text descriptionHeader;

	public Text descriptionText;

	public Text BalanceText;

	private InventoryItemButton[] itemButtons;

	private InventoryItemButtonBait[] baitButtons;

	private InventoryEquipButton equipButton;

	private BaitType selectedBait;

	private bool hasRunStart;

	[@Dependency]
	public BuyableItemData buyableItemData { get; set; }

	[@Dependency]
	public InventoryManager inventoryManager { get; set; }

	[@Dependency]
	public Localization localization { get; set; }

	private void Awake()
	{
		this.Inject();
		baitButtons = GetComponentsInChildren<InventoryItemButtonBait>();
		itemButtons = GetComponentsInChildren<InventoryItemButton>();
		equipButton = GetComponentInChildren<InventoryEquipButton>();
		descriptionText.fontSize = (int)((float)descriptionText.fontSize * localization.GetLanguageFontSizeMultiplier());
	}

	private void Start()
	{
		hasRunStart = true;
		SetStartItem();
		UpdateBalance();
	}

	private void OnEnable()
	{
		if (hasRunStart)
		{
			SetStartItem();
			UpdateBalance();
		}
	}

	private void SetStartItem()
	{
		BuyableItemData.Item itemFromId = buyableItemData.GetItemFromId(inventoryManager.Inventory.Rod.ToString());
		SelectGear(itemFromId);
		GetComponentInChildren<InventoryItemButtonRod>().SetSelected(selected: true);
	}

	public void SelectBait(BaitType baitType, BuyableItemData.Item itemData, int availableAmount)
	{
		ClearSelectGlows();
		UpdateTexts(itemData.name, itemData.description);
		selectedBait = baitType;
		if (baitType == inventoryManager.Inventory.CurrentBait)
		{
			equipButton.SetIsEquipped();
		}
		else if (availableAmount > 0)
		{
			equipButton.SetIsEquippable();
		}
		else
		{
			equipButton.SetDisabledEquip();
		}
	}

	public void SelectGear(BuyableItemData.Item itemData)
	{
		UpdateTexts(itemData.name, itemData.description);
		ClearSelectGlows();
		equipButton.SetIsEquipped();
	}

	public void OnEquipButtonClick()
	{
		inventoryManager.Inventory.CurrentBait = selectedBait;
		equipBaitNotification.Dispatch(selectedBait);
		UpdateBaitButtons();
	}

	private void UpdateTexts(string header, string description)
	{
		descriptionHeader.font = localization.GetLanguageFont();
		descriptionHeader.text = header;
		description = description.Replace("\\n", Environment.NewLine);
		if (localization.CurrentLanguangId == "ja")
		{
			description = description.Replace("? ", "");
			description = description.Replace("! ", "");
			description = description.Replace(". ", "");
		}
		descriptionText.font = localization.GetLanguageFont();
		descriptionText.text = description;
	}

	private void UpdateBalance()
	{
		BalanceText.text = inventoryManager.Inventory.Money.ToString();
	}

	private void UpdateBaitButtons()
	{
		for (int i = 0; i < baitButtons.Length; i++)
		{
			baitButtons[i].UpdateVisual();
		}
	}

	private void ClearSelectGlows()
	{
		for (int i = 0; i < itemButtons.Length; i++)
		{
			itemButtons[i].SetSelected(selected: false);
		}
	}
}
public class InventoryImageRegistry : MonoBehaviour
{
	[Serializable]
	public struct BobberSprite
	{
		public BobberType bobberType;

		public Sprite sprite;
	}

	[Serializable]
	public struct ReelSprite
	{
		public ReelType reelType;

		public Sprite sprite;
	}

	[Serializable]
	public struct RodSprite
	{
		public RodType rodType;

		public Sprite sprite;
	}

	private static InventoryImageRegistry Instance;

	public BobberSprite[] BobberSpriteList;

	public ReelSprite[] ReelSpriteList;

	public RodSprite[] RodSpriteList;

	[@Dependency]
	public InventoryManager inventoryManager { get; set; }

	public static Sprite GetBobberSprite(BobberType type)
	{
		BobberSprite[] bobberSpriteList = Instance.BobberSpriteList;
		for (int i = 0; i < bobberSpriteList.Length; i++)
		{
			if (bobberSpriteList[i].bobberType == type)
			{
				return bobberSpriteList[i].sprite;
			}
		}
		throw new Exception("Failed to find bobber sprite for type: " + type);
	}

	public static Sprite GetReelSprite(ReelType type)
	{
		ReelSprite[] reelSpriteList = Instance.ReelSpriteList;
		for (int i = 0; i < reelSpriteList.Length; i++)
		{
			if (reelSpriteList[i].reelType == type)
			{
				return reelSpriteList[i].sprite;
			}
		}
		throw new Exception("Failed to find reel sprite for type: " + type);
	}

	public static Sprite GetRodSprite(RodType type)
	{
		RodSprite[] rodSpriteList = Instance.RodSpriteList;
		for (int i = 0; i < rodSpriteList.Length; i++)
		{
			if (rodSpriteList[i].rodType == type)
			{
				return rodSpriteList[i].sprite;
			}
		}
		throw new Exception("Failed to find rod sprite for type: " + type);
	}

	private void Awake()
	{
		Instance = this;
	}

	private void OnDestroy()
	{
		Instance = null;
	}
}
public abstract class InventoryItemButton : GazeButton
{
	[@Dependency]
	public BuyableItemData buyableItemData { get; set; }

	[@Dependency]
	public InventoryManager inventoryManager { get; set; }

	protected InventoryGUI inventoryGUI { get; private set; }

	private void Awake()
	{
		this.Inject();
		InventoryGUI componentInParent = GetComponentInParent<InventoryGUI>();
		inventoryGUI = componentInParent;
	}

	private void Start()
	{
		OnShow();
	}

	private void OnEnable()
	{
		OnShow();
	}

	private void OnDisable()
	{
		OnHide();
	}

	public virtual void OnShow()
	{
	}

	public virtual void OnHide()
	{
	}

	public virtual void SetSelected(bool selected)
	{
	}
}
public class InventoryItemButtonBait : InventoryItemButton
{
	public Sprite defaultBackGround;

	public Sprite equippedBackGround;

	public Image selectedGlow;

	public Image backgroundImage;

	public Text amountText;

	public BaitType baitType;

	public bool infiniteAmount;

	public GameObject baitObject;

	private BuyableItemData.Item itemData;

	private int availableAmount;

	public override void OnShow()
	{
		itemData = base.buyableItemData.GetItemFromId(baitType.ToString());
		if (!base.inventoryManager.Inventory.Baits.TryGetValue(baitType, out availableAmount) && !infiniteAmount)
		{
			baitObject.SetActive(value: false);
		}
		else
		{
			baitObject.SetActive(value: true);
		}
		SetAmountText(availableAmount);
		UpdateVisual();
	}

	public void UpdateVisual()
	{
		if (baitType == base.inventoryManager.Inventory.CurrentBait)
		{
			SetEquipped(equipped: true);
		}
		else
		{
			SetEquipped(equipped: false);
		}
	}

	public override bool IsSelectable(GameObject obj)
	{
		return baitObject.activeSelf;
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		base.inventoryGUI.SelectBait(baitType, itemData, availableAmount);
		FishODex.SoundSignal.Dispatch(FishODexSoundEventType.Select);
		SetSelected(selected: true);
		return base.OnSelect(obj);
	}

	public override void SetSelected(bool selected)
	{
		selectedGlow.gameObject.SetActive(selected);
	}

	public void SetEquipped(bool equipped)
	{
		if (equipped)
		{
			backgroundImage.sprite = equippedBackGround;
		}
		else
		{
			backgroundImage.sprite = defaultBackGround;
		}
	}

	private void SetAmountText(int amount)
	{
		if (infiniteAmount)
		{
			amountText.text = "Infinite";
		}
		else
		{
			amountText.text = amount.ToString();
		}
	}
}
public class InventoryItemButtonBobber : InventoryItemButton
{
	public Image thumbnail;

	public Image selectedGlow;

	private BobberType bobberType;

	private BuyableItemData.Item itemData;

	public override void OnShow()
	{
		bobberType = base.inventoryManager.Inventory.Bobber;
		thumbnail.sprite = InventoryImageRegistry.GetBobberSprite(bobberType);
		itemData = base.buyableItemData.GetItemFromId(bobberType.ToString());
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		base.inventoryGUI.SelectGear(itemData);
		FishODex.SoundSignal.Dispatch(FishODexSoundEventType.Select);
		SetSelected(selected: true);
		return base.OnSelect(obj);
	}

	public override void SetSelected(bool selected)
	{
		selectedGlow.gameObject.SetActive(selected);
	}
}
public class InventoryItemButtonReel : InventoryItemButton
{
	public Image thumbnail;

	public Image selectedGlow;

	private ReelType reelType;

	private BuyableItemData.Item itemData;

	public override void OnShow()
	{
		reelType = base.inventoryManager.Inventory.Reel;
		thumbnail.sprite = InventoryImageRegistry.GetReelSprite(reelType);
		itemData = base.buyableItemData.GetItemFromId(reelType.ToString());
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		base.inventoryGUI.SelectGear(itemData);
		FishODex.SoundSignal.Dispatch(FishODexSoundEventType.Select);
		SetSelected(selected: true);
		return base.OnSelect(obj);
	}

	public override void SetSelected(bool selected)
	{
		selectedGlow.gameObject.SetActive(selected);
	}
}
public class InventoryItemButtonRod : InventoryItemButton
{
	public Image thumbnail;

	public Image selectedGlow;

	private RodType rodType;

	private BuyableItemData.Item itemData;

	public override void OnShow()
	{
		rodType = base.inventoryManager.Inventory.Rod;
		thumbnail.sprite = InventoryImageRegistry.GetRodSprite(rodType);
		itemData = base.buyableItemData.GetItemFromId(rodType.ToString());
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		base.inventoryGUI.SelectGear(itemData);
		SetSelected(selected: true);
		FishODex.SoundSignal.Dispatch(FishODexSoundEventType.Select);
		return base.OnSelect(obj);
	}

	public override void SetSelected(bool selected)
	{
		selectedGlow.gameObject.SetActive(selected);
	}
}
[RequireComponent(typeof(InventoryItemButtonBait))]
public class InventoryItemDefaultBait : InventoryItemButton
{
	public override void OnShow()
	{
		BaitType baitType = Find.ComponentOnGameObject<InventoryItemButtonBait>(this).baitType;
		if (baitType != base.inventoryManager.Inventory.DefaultBait)
		{
			base.gameObject.SetActive(value: false);
		}
	}
}
public class BuyLakeButton : BuyButton
{
	public static Signal clickEvent = new Signal();

	public float activeZOffset = 30f;

	public PostSelectAction OnSelectAction = PostSelectAction.WaitForLookAway;

	private float startZ;

	[@Dependency]
	public FishODexEvent FishODexSignal { get; set; }

	private void Start()
	{
		this.Inject();
		startZ = base.transform.localPosition.z;
	}

	public override void OnStartGaze()
	{
		if (IsSelectable(base.gameObject))
		{
			FishODexSignal.Dispatch(FishODexEventType.ItemHover, base.gameObject.transform);
			LeanTween.moveLocalZ(base.gameObject, startZ - activeZOffset, 0.2f).setEase(LeanTweenType.easeOutSine);
		}
	}

	public override void OnStopGaze()
	{
		if (IsSelectable(base.gameObject))
		{
			LeanTween.moveLocalZ(base.gameObject, startZ, 0.2f).setEase(LeanTweenType.easeOutSine);
		}
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		clickEvent.Dispatch();
		FishODexSignal.Dispatch(FishODexEventType.ItemHover, base.gameObject.transform);
		disableAfterClick = true;
		LeanTween.delayedCall(base.gameObject, 1f, (Action)delegate
		{
			disableAfterClick = false;
		});
		return OnSelectAction;
	}
}
public class DashedLineImage : MonoBehaviour, ILocationEnabled, ILocationMenuItem
{
	public Location location;

	private float scrollX;

	private float speed = 0.012f;

	private RawImage img;

	private bool lineEnabled;

	private void Awake()
	{
		img = base.gameObject.GetComponent<RawImage>();
		float x = Find.ComponentOnGameObject<RectTransform>(this).sizeDelta.x;
		float num = 0.015f;
		img.uvRect = new Rect(0f, 0f, num * x, 1f);
		base.transform.localScale = new Vector3(1f, 0f, 1f);
	}

	private void Update()
	{
		scrollX -= speed;
		Rect uvRect = img.uvRect;
		uvRect.x = scrollX;
		img.uvRect = uvRect;
	}

	public void Show()
	{
		LeanTween.cancel(base.gameObject);
		LeanTween.scaleY(base.gameObject, 1f, 0.2f).setEase(LeanTweenType.easeOutSine);
	}

	public void Hide()
	{
		LeanTween.cancel(base.gameObject);
		LeanTween.scaleY(base.gameObject, 0f, 0.2f).setEase(LeanTweenType.easeOutSine);
	}

	public Location GetLocation()
	{
		return location;
	}

	private void OnDestroy()
	{
		LeanTween.cancel(base.gameObject);
	}

	public void UpdateLocationEnabled(bool hasLicense, Location currentLocation)
	{
		lineEnabled = hasLicense;
		base.gameObject.SetActive(lineEnabled);
	}

	GameObject ILocationMenuItem.get_gameObject()
	{
		return base.gameObject;
	}
}
public class FishODexIAPGazeEventButton : MapGazeEventButton
{
	[Tooltip("Content to be displayed in view")]
	public GameObject content;

	[Tooltip("Queststates where the button is disabled.")]
	public string[] disabledQuestStates;

	[Tooltip("QuestStates where the button is wobbling.")]
	public string[] wobblingQuestStates;

	private string itemID;

	private Text infoLabel;

	private Text catchLabel;

	private Image infoBackground;

	private Text label;

	private GameObject pin;

	private GameObject line;

	private Padlock padlock;

	private Vector3 originalScale;

	private Vector3 hoverScale;

	private bool isEnabled;

	private bool wobble;

	private Vector3 startScale;

	private float wobbleSpeed = 5f;

	private float wobbleMagnitude = 0.1f;

	private Text priceLabel;

	private bool isIAP;

	private GameObject coin;

	private bool startHasRun;

	[@Dependency]
	public FishODexEvent FishodexSignal { get; set; }

	[@Dependency]
	public Quest Quest { get; set; }

	[@Dependency]
	public InventoryManager InventoryManager { get; set; }

	[@Dependency]
	public IAPService IAPService { get; set; }

	[@Dependency]
	public BuyableItemData BuyableItemData { get; set; }

	private void Start()
	{
		this.Inject();
		isEnabled = true;
		wobble = false;
		VerifyComponents();
		SetInfoAlpha(0f);
		startScale = label.transform.localScale;
		float num = 1.1f;
		hoverScale = startScale * num;
		itemID = location.ToString().ToLower();
		startHasRun = true;
		isIAP = BuyableItemData.GetItemFromId(itemID).shopBehavior == BuyableItemData.BuyableType.DurableIAP;
		OnShow();
	}

	private void Reset()
	{
		VerifyComponents();
	}

	private void VerifyComponents()
	{
		label = Find.ChildByName(this, "Label").GetComponent<Text>();
		infoBackground = Find.ChildByName(this, "InfoBackground").GetComponent<Image>();
		infoLabel = Find.ChildByName(this, "InfoBackground/InfoLabel").GetComponent<Text>();
		priceLabel = Find.ChildByName(this, "PriceLabel").GetComponent<Text>();
		coin = Find.ChildByName(this, "Coin");
		catchLabel = Find.ChildByName(this, "CatchLabel").GetComponent<Text>();
		pin = Find.ChildByName(base.transform, "Pin");
		line = Find.ChildByName(base.transform, "Line");
		padlock = GetComponentInChildren<Padlock>();
		catchLabel.gameObject.SetActive(value: false);
	}

	private void OnShow()
	{
		Quest.EnterQuestStateSignal.AddListener(OnEnterQuestState);
		CheckQuestState();
		SetButtonState();
		if (isIAP)
		{
			IAPService.GetProduct(itemID, OnGetLakeSuccess, OnGetLakeError);
		}
		else
		{
			SetPriceTag(itemID);
		}
	}

	private void OnGetLakeSuccess(Product product)
	{
		priceLabel.text = product.FormattedPrice;
	}

	private void OnGetLakeError(string reason)
	{
		priceLabel.text = "---";
	}

	private void OnEnable()
	{
		if (startHasRun)
		{
			OnShow();
		}
	}

	private void SetButtonState()
	{
		bool isItemOwned = GetIsItemOwned();
		if (isItemOwned)
		{
			priceLabel.gameObject.SetActive(value: false);
			coin.SetActive(value: false);
			pin.SetActive(value: true);
			line.SetActive(value: true);
			catchLabel.gameObject.SetActive(value: true);
			catchLabel.text = $"{InventoryManager.GetNumFishCaughtInLocation(location.ToString())}/10";
		}
		if ((bool)padlock)
		{
			if (disabledQuestStates.Contains(Quest.CurrentState.Id))
			{
				padlock.gameObject.SetActive(value: true);
				label.gameObject.SetActive(value: false);
				priceLabel.gameObject.SetActive(value: false);
				coin.SetActive(value: false);
				catchLabel.gameObject.SetActive(value: false);
				infoBackground.gameObject.SetActive(value: false);
				infoLabel.gameObject.SetActive(value: false);
			}
			else
			{
				infoBackground.gameObject.SetActive(!isItemOwned);
				infoLabel.gameObject.SetActive(!isItemOwned);
				padlock.gameObject.SetActive(value: false);
				padlock = null;
				label.gameObject.SetActive(value: true);
				priceLabel.gameObject.SetActive(!isItemOwned);
				catchLabel.gameObject.SetActive(isItemOwned);
				coin.SetActive(value: false);
			}
		}
	}

	private void SetPriceTag(string id)
	{
		BuyableItemData.Item itemFromId = BuyableItemData.GetItemFromId(id);
		priceLabel.text = itemFromId.cost.ToString();
	}

	private void Update()
	{
		if (wobble)
		{
			base.transform.localScale = startScale * (1f + Mathf.Sin(Time.timeSinceLevelLoad * wobbleSpeed) * wobbleMagnitude);
		}
	}

	private void OnEnterQuestState(QuestState obj)
	{
		CheckQuestState();
	}

	public override bool IsSelectable(GameObject obj)
	{
		return isEnabled;
	}

	private void CheckQuestState()
	{
		if (disabledQuestStates.Contains(Quest.CurrentState.Id))
		{
			Disable();
		}
		else
		{
			Enable();
		}
		if (wobblingQuestStates.Contains(Quest.CurrentState.Id))
		{
			wobble = true;
		}
		else
		{
			wobble = false;
		}
	}

	private void Disable()
	{
		LeanTween.cancel(label.gameObject);
		isEnabled = false;
	}

	private void Enable()
	{
		isEnabled = true;
	}

	public override void OnStartGaze()
	{
		if (GetIsItemOwned())
		{
			LeanTween.cancel(label.gameObject);
			LeanTween.scale(label.gameObject, hoverScale, 0.2f).setEase(LeanTweenType.easeOutSine);
		}
		else
		{
			LeanTween.cancel(infoLabel.gameObject);
			infoBackground.gameObject.SetActive(value: true);
			infoLabel.gameObject.SetActive(value: true);
			LeanTween.value(infoLabel.gameObject, infoLabel.color.a, 1f, 0.4f).setOnUpdate(SetInfoAlpha);
		}
		FishodexSignal.Dispatch(FishODexEventType.ItemHover, base.gameObject.transform);
		guiMapEvent.Dispatch(GuiMapEventType.StartGaze, location);
	}

	public override void OnStopGaze()
	{
		if (GetIsItemOwned())
		{
			LeanTween.cancel(label.gameObject);
			LeanTween.scale(label.gameObject, startScale, 0.2f).setEase(LeanTweenType.easeOutSine);
		}
		else
		{
			LeanTween.cancel(infoLabel.gameObject);
			LeanTween.value(infoLabel.gameObject, infoBackground.color.a, 0f, 0.4f).setOnUpdate(SetInfoAlpha).setOnComplete(OnBackgrpundTweenComplete);
		}
		guiMapEvent.Dispatch(GuiMapEventType.StopGaze, location);
	}

	private void OnBackgrpundTweenComplete()
	{
		infoBackground.gameObject.SetActive(value: false);
		infoLabel.gameObject.SetActive(value: false);
	}

	private void SetInfoAlpha(float value)
	{
		infoBackground.color = new Color(infoBackground.color.r, infoBackground.color.g, infoBackground.color.b, value * 0.75f);
		infoLabel.color = new Color(infoLabel.color.r, infoLabel.color.g, infoLabel.color.b, value);
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		if (GetIsItemOwned())
		{
			guiMapEvent.Dispatch(GuiMapEventType.Select, location);
		}
		else
		{
			FishODexMenuButton.SelectSignal.Dispatch(content, item2: true, itemID);
			if (wobble)
			{
				wobble = false;
			}
		}
		base.FishODexSignal.Dispatch(FishODexEventType.ItemSelect, base.gameObject.transform);
		return PostSelectAction.Restart;
	}

	private bool GetIsItemOwned()
	{
		return true;
	}

	private void OnDestroy()
	{
		if (label != null)
		{
			LeanTween.cancel(label.gameObject);
		}
		if (Quest.EnterQuestStateSignal != null)
		{
			Quest.EnterQuestStateSignal.RemoveListener(OnEnterQuestState);
		}
	}
}
public enum GuiMapEventType
{
	StartGaze,
	StopGaze,
	Select
}
public class GuiMapEvent : Signal<GuiMapEventType, Location>
{
}
public interface ILocationEnabled
{
	Location GetLocation();

	void UpdateLocationEnabled(bool hasLicense, Location currentLocation);
}
public interface ILocationMenuItem
{
	GameObject gameObject { get; }

	void Show();

	void Hide();

	Location GetLocation();
}
public class LocationStatusVisibility : MonoBehaviour, ILocationEnabled
{
	public enum Condition
	{
		ShowIfUnlocked,
		ShowIfLocked,
		ShowIfCurrent
	}

	public Condition VisibleCondition;

	public Location Location;

	public Location GetLocation()
	{
		return Location;
	}

	public void UpdateLocationEnabled(bool isEnabled, Location currentLocation)
	{
		if (VisibleCondition == Condition.ShowIfCurrent)
		{
			base.gameObject.SetActive(currentLocation == Location);
		}
		else if (VisibleCondition == Condition.ShowIfUnlocked)
		{
			base.gameObject.SetActive(isEnabled);
		}
		else if (VisibleCondition == Condition.ShowIfLocked)
		{
			base.gameObject.SetActive(!isEnabled);
		}
	}
}
[Serializable]
public struct LocationSceneMapping
{
	public Location location;

	public string sceneName;
}
public class MapContentScript : MonoBehaviour
{
	private GuiMapEvent[] guiMapEvents;

	private ILocationMenuItem[] menuItems;

	private Location currentFocusLocation;

	public LocationSceneMapping[] locationToSceneMapping;

	[@Dependency]
	public InventoryManager InvManager { get; set; }

	[@Dependency]
	public Quest Quest { get; set; }

	private void Awake()
	{
		this.Inject();
		menuItems = GetComponentsInChildren<ILocationMenuItem>();
		MapGazeEventButton[] componentsInChildren = GetComponentsInChildren<MapGazeEventButton>();
		guiMapEvents = new GuiMapEvent[componentsInChildren.Length];
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			guiMapEvents[i] = componentsInChildren[i].guiMapEvent;
			guiMapEvents[i].AddListener(OnGuiMapEvent);
		}
	}

	private void OnEnable()
	{
		StartCoroutine(UpdateEnabledLocations());
	}

	private Location getLocationFromButton(MapLabelButton btn)
	{
		MapGazeEventButton component = btn.gameObject.GetComponent<MapGazeEventButton>();
		return component.location;
	}

	private void OnGuiMapEvent(GuiMapEventType type, Location loc)
	{
		switch (type)
		{
		case GuiMapEventType.StartGaze:
			if (currentFocusLocation != 0 && currentFocusLocation != loc)
			{
				HideLocation(currentFocusLocation);
			}
			currentFocusLocation = loc;
			ShowLocation(loc);
			break;
		case GuiMapEventType.StopGaze:
			if (currentFocusLocation != 0)
			{
				HideLocation(currentFocusLocation);
			}
			currentFocusLocation = Location.None;
			break;
		case GuiMapEventType.Select:
		{
			string sceneNameFromLocation = GetSceneNameFromLocation(loc);
			if (sceneNameFromLocation.Equals(string.Empty))
			{
				UnityEngine.Debug.LogError(string.Concat("Scene name for location ", loc, " is not mapped!"));
				break;
			}
			string text = SceneManager.GetActiveScene().name;
			if (!(sceneNameFromLocation == text))
			{
				LoadScene.LoadSceneSignal.Dispatch(sceneNameFromLocation);
			}
			break;
		}
		}
	}

	private void ShowLocation(Location loc)
	{
		for (int i = 0; i < menuItems.Length; i++)
		{
			if (menuItems[i].GetLocation() == loc)
			{
				menuItems[i].Show();
			}
		}
	}

	private void HideLocation(Location loc)
	{
		for (int i = 0; i < menuItems.Length; i++)
		{
			if (menuItems[i].GetLocation() == loc)
			{
				menuItems[i].Hide();
			}
		}
	}

	private string GetSceneNameFromLocation(Location loc)
	{
		for (int i = 0; i < locationToSceneMapping.Length; i++)
		{
			if (locationToSceneMapping[i].location == loc)
			{
				return locationToSceneMapping[i].sceneName;
			}
		}
		return string.Empty;
	}

	private Location GetLocationFromSceneName(string currentScene)
	{
		for (int i = 0; i < locationToSceneMapping.Length; i++)
		{
			if (locationToSceneMapping[i].sceneName == currentScene)
			{
				return locationToSceneMapping[i].location;
			}
		}
		return Location.Beach;
	}

	private IEnumerator UpdateEnabledLocations()
	{
		yield return null;
		string sceneName = SceneManager.GetActiveScene().name;
		Location currentLocation = GetLocationFromSceneName(sceneName);
		ILocationEnabled[] locs = GetComponentsInChildren<ILocationEnabled>(includeInactive: true);
		for (int i = 0; i < locs.Length; i++)
		{
			bool hasLicense = HasLicenceForLocation(locs[i].GetLocation());
			locs[i].UpdateLocationEnabled(hasLicense, currentLocation);
		}
	}

	private bool HasLicenceForLocation(Location loc)
	{
		if (loc == Location.River && Quest.CurrentState.StateNumber < 11)
		{
			return false;
		}
		return InvManager.Inventory.Licenses.Contains(loc) || InvManager.DurableInventory.ContainsItem(loc.ToString().ToLower());
	}

	private void OnDestroy()
	{
		for (int i = 0; i < guiMapEvents.Length; i++)
		{
			if (guiMapEvents[i] != null)
			{
				guiMapEvents[i].RemoveListener(OnGuiMapEvent);
			}
		}
		guiMapEvents = null;
		menuItems = null;
	}
}
public class MapGazeEventButton : GazeButton
{
	[HideInInspector]
	public GuiMapEvent guiMapEvent = new GuiMapEvent();

	public Location location;

	private bool isCurrentLocation;

	[@Dependency]
	public FishODexEvent FishODexSignal { get; set; }

	public override void OnStartGaze()
	{
		FishODexSignal.Dispatch(FishODexEventType.ItemHover, base.gameObject.transform);
		guiMapEvent.Dispatch(GuiMapEventType.StartGaze, location);
	}

	public override void OnStopGaze()
	{
		guiMapEvent.Dispatch(GuiMapEventType.StopGaze, location);
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		guiMapEvent.Dispatch(GuiMapEventType.Select, location);
		FishODexSignal.Dispatch(FishODexEventType.ItemSelect, base.gameObject.transform);
		return PostSelectAction.Restart;
	}

	public void SetIsCurrentLocation(bool isCurrent)
	{
		isCurrentLocation = isCurrent;
	}

	public override bool FakeShowAsNotSelectable()
	{
		return isCurrentLocation;
	}
}
public class MapLabelButton : MonoBehaviour, ILocationMenuItem, ILocationEnabled
{
	private bool isCurrentLocation;

	private Transform label;

	private Vector3 originalLabelPos;

	private Vector3 highlightedLabelPos;

	private Location location;

	private Collider coll;

	private void Awake()
	{
		label = Find.ChildByName(this, "Label").transform;
		originalLabelPos = label.localPosition;
		highlightedLabelPos = originalLabelPos + new Vector3(0f, 0f, -40f);
		location = Find.ComponentOnGameObject<MapGazeEventButton>(this).location;
		coll = Find.ComponentOnGameObject<Collider>(this);
		Hide();
	}

	public void Show()
	{
		if (!isCurrentLocation)
		{
			LeanTween.cancel(label.gameObject);
			LeanTween.moveLocal(label.gameObject, highlightedLabelPos, 0.15f).setEase(LeanTweenType.easeOutSine);
		}
	}

	public void Hide()
	{
		if (!isCurrentLocation)
		{
			LeanTween.cancel(label.gameObject);
			LeanTween.moveLocal(label.gameObject, originalLabelPos, 0.15f).setEase(LeanTweenType.easeOutSine);
		}
	}

	public Location GetLocation()
	{
		return location;
	}

	public void UpdateLocationEnabled(bool isEnabled, Location currentLocation)
	{
		coll.enabled = isEnabled;
		label.gameObject.SetActive(isEnabled);
		isCurrentLocation = currentLocation == location;
		if (isCurrentLocation)
		{
			LeanTween.cancel(label.gameObject);
			label.localPosition = highlightedLabelPos;
		}
		Find.ComponentOnGameObject<MapGazeEventButton>(this).SetIsCurrentLocation(isCurrentLocation);
	}

	private void OnDestroy()
	{
		LeanTween.cancel(label.gameObject);
	}

	GameObject ILocationMenuItem.get_gameObject()
	{
		return base.gameObject;
	}
}
public class MapPin : MonoBehaviour, ILocationEnabled
{
	public Sprite YouAreHereDot;

	private Location myLocation;

	private Image img;

	private void Awake()
	{
		myLocation = Find.ComponentOnGameObject<LocationStatusVisibility>(this).Location;
		img = Find.ComponentOnGameObject<Image>(this);
	}

	public Location GetLocation()
	{
		return myLocation;
	}

	public void UpdateLocationEnabled(bool isEnabled, Location currentLocation)
	{
		if (currentLocation == myLocation)
		{
			img.sprite = YouAreHereDot;
			Find.ComponentOnGameObject<MapGazeEventButton>(this).SetIsCurrentLocation(isCurrent: true);
		}
	}
}
public class MenuItemLogo : MonoBehaviour, ILocationMenuItem, ILocationEnabled
{
	public Location location;

	private Image logo;

	private bool isCurrentLocation;

	private void Start()
	{
		logo = Find.ComponentOnGameObject<Image>(this);
		logo.color = new Color(1f, 1f, 1f, 0f);
		base.gameObject.SetActive(value: false);
	}

	public void Show()
	{
		if (!isCurrentLocation)
		{
			base.gameObject.SetActive(value: true);
			LeanTween.cancel(base.gameObject);
			LeanTween.value(base.gameObject, logo.color.a, 1f, 0.4f).setOnUpdate(SetAlpha).setDelay(0.1f);
		}
	}

	public void Hide()
	{
		LeanTween.cancel(base.gameObject);
		LeanTween.value(base.gameObject, logo.color.a, 0f, 0.4f).setOnUpdate(SetAlpha).setOnComplete((Action)delegate
		{
			base.gameObject.SetActive(value: false);
		});
	}

	public Location GetLocation()
	{
		return location;
	}

	private void SetAlpha(float value)
	{
		logo.color = new Color(1f, 1f, 1f, value);
	}

	public void UpdateLocationEnabled(bool hasLicense, Location currentLocation)
	{
		isCurrentLocation = location == currentLocation;
	}

	GameObject ILocationMenuItem.get_gameObject()
	{
		return base.gameObject;
	}
}
public class Padlock : GazeButton
{
	private bool animationPlaying;

	public float rotation = 12f;

	public float rotDur = 0.1f;

	public int rotPingpong = 2;

	public float jumpZOffset = 50f;

	public float jumpT1 = 0.2f;

	public float jumpT2 = 0.8f;

	public override void OnStartGaze()
	{
		base.OnStartGaze();
		if (animationPlaying)
		{
			return;
		}
		animationPlaying = true;
		LeanTween.rotate(base.gameObject, new Vector3(0f, 0f, rotation), rotDur / 2f).setOnComplete((Action)delegate
		{
			LeanTween.rotate(base.gameObject, new Vector3(0f, 0f, 0f - rotation), rotDur).setLoopPingPong(rotPingpong).setEase(LeanTweenType.easeInOutSine)
				.setOnComplete((Action)delegate
				{
					LeanTween.rotate(base.gameObject, Vector3.zero, rotDur / 2f);
				});
		});
		float locZ = base.gameObject.transform.localPosition.z;
		float to = locZ - jumpZOffset;
		LeanTween.moveLocalZ(base.gameObject, to, jumpT1).setEase(LeanTweenType.easeOutQuint).setOnComplete((Action)delegate
		{
			LeanTween.moveLocalZ(base.gameObject, locZ, jumpT2).setEase(LeanTweenType.easeOutBounce);
		});
		LeanTween.delayedCall(base.gameObject, 2f, (Action)delegate
		{
			animationPlaying = false;
		});
	}

	private void OnDestroy()
	{
		LeanTween.cancel(base.gameObject);
	}

	public override bool FakeShowAsNotSelectable()
	{
		return true;
	}
}
public class MissionCardUI : MonoBehaviour
{
	[HideInInspector]
	public int PageNumber;

	[HideInInspector]
	public bool IsUsed;

	private MissionPartUI[] missionParts;

	private Image missionCompletedBg;

	private Image missionCompletedCheckmark;

	[@Dependency]
	public Localization localization { get; set; }

	private void Awake()
	{
		this.Inject();
		missionParts = new MissionPartUI[3]
		{
			Find.ComponentOnChild<MissionPartUI>(this, "MissionPart1"),
			Find.ComponentOnChild<MissionPartUI>(this, "MissionPart2"),
			Find.ComponentOnChild<MissionPartUI>(this, "MissionPart3")
		};
		missionCompletedBg = Find.ComponentOnChild<Image>(this, "MissionCompletedBg");
		missionCompletedCheckmark = Find.ComponentOnChild<Image>(this, "MissionCompletedCheckmark");
	}

	public void PopulateData(int page, Mission mission, QuestState runningQuest)
	{
		SetVisible(vis: true);
		PageNumber = page;
		int num = mission.Parts.Length;
		for (int i = 0; i < missionParts.Length; i++)
		{
			bool flag = i < num;
			missionParts[i].gameObject.SetActive(flag);
			if (flag)
			{
				missionParts[i].SetText(localization.GetString(mission.Parts[i].Text), localization.GetLanguageFont(), localization.GetLanguageFontSizeMultiplier());
				missionParts[i].SetIsChecked(mission.CompletedTasks[i]);
				missionParts[i].HideProgress();
				if (mission.Parts[i].QuestId == runningQuest.Id)
				{
					int requiredProgress = runningQuest.Condition.RequiredProgress;
					if (requiredProgress > 1)
					{
						missionParts[i].ShowProgress(runningQuest.Condition.CurrentProgress, requiredProgress);
					}
				}
			}
			SetMissionAsCompleted(mission.MissionCompleted);
		}
	}

	private void SetMissionAsCompleted(bool completed)
	{
		Image image = missionCompletedBg;
		bool flag = completed;
		missionCompletedCheckmark.enabled = flag;
		image.enabled = flag;
	}

	public void SetVisible(bool vis)
	{
		base.gameObject.SetActive(vis);
	}
}
public class MissionLog : MonoBehaviour
{
	private bool hasUpdated;

	private bool startHasRun;

	public float PaddingBetweenCards = 1400f;

	private int currentPage;

	private FlipPageButton scrollLeftBtn;

	private FlipPageButton scrollRightBtn;

	private GameObject scrollContent;

	private MissionCardUI[] missionCards;

	private MissionCardUI leftmostCard;

	[@Dependency]
	public Quest QuestManager { get; set; }

	private void Start()
	{
		this.Inject();
		scrollLeftBtn = Find.ComponentOnChild<FlipPageButton>(this, "LeftButton");
		scrollRightBtn = Find.ComponentOnChild<FlipPageButton>(this, "RightButton");
		scrollContent = Find.ChildByName(this, "ScrollingMask/ScrollingContent");
		scrollLeftBtn.IsNextButton = false;
		scrollRightBtn.IsNextButton = true;
		missionCards = new MissionCardUI[4]
		{
			Find.ComponentOnChild<MissionCardUI>(this, "ScrollingMask/ScrollingContent/MissionCard1"),
			Find.ComponentOnChild<MissionCardUI>(this, "ScrollingMask/ScrollingContent/MissionCard2"),
			Find.ComponentOnChild<MissionCardUI>(this, "ScrollingMask/ScrollingContent/MissionCard3"),
			Find.ComponentOnChild<MissionCardUI>(this, "ScrollingMask/ScrollingContent/MissionCard4")
		};
		leftmostCard = missionCards[0];
		for (int i = 0; i < missionCards.Length; i++)
		{
			missionCards[i].SetVisible(vis: false);
		}
		scrollLeftBtn.SelectSignal.AddListener(OnScrollLeft);
		scrollRightBtn.SelectSignal.AddListener(OnScrollRight);
		FishODexMenuButton.SelectSignal.AddListener(OnSelectFishodexButton);
		startHasRun = true;
		PopulateData();
	}

	private void OnSelectFishodexButton(GameObject content, bool pushContent, string key)
	{
		if (content.name == "MissionLogContent" && startHasRun)
		{
			PopulateData();
		}
	}

	public void PopulateData()
	{
		if (QuestManager != null && startHasRun)
		{
			hasUpdated = false;
			Scroll(QuestManager.GetActiveMissionIndex(), transition: false);
		}
	}

	private void CheckScrollButtonStatus()
	{
		if (QuestManager != null)
		{
			bool active = currentPage > 0;
			bool active2 = currentPage < QuestManager.GetActiveMissionIndex();
			scrollLeftBtn.gameObject.SetActive(active);
			scrollRightBtn.gameObject.SetActive(active2);
		}
	}

	private void OnScrollLeft()
	{
		Scroll(currentPage - 1);
	}

	private void OnScrollRight()
	{
		Scroll(currentPage + 1);
	}

	private void Scroll(int toPage, bool transition = true)
	{
		currentPage = toPage;
		currentPage = Mathf.Clamp(currentPage, 0, QuestManager.GetActiveMissionIndex());
		float num = PaddingBetweenCards * (float)currentPage * -1f;
		if (LeanTween.isTweening(scrollContent))
		{
			LeanTween.cancel(scrollContent);
		}
		if (transition)
		{
			LeanTween.moveLocalX(scrollContent, num, 0.4f).setEase(LeanTweenType.easeOutSine);
			OnScrollUpdate(num);
		}
		else
		{
			Vector3 localPosition = scrollContent.transform.localPosition;
			scrollContent.transform.localPosition = new Vector3(num, localPosition.y, localPosition.z);
			OnScrollUpdate(num);
		}
		CheckScrollButtonStatus();
	}

	private void OnScrollUpdate(float xPos)
	{
		int num = Mathf.FloorToInt((0f - xPos) / PaddingBetweenCards) - 1;
		if (num < 0)
		{
			num = 0;
		}
		if (leftmostCard.PageNumber == num && hasUpdated)
		{
			return;
		}
		hasUpdated = true;
		QuestState currentState = QuestManager.CurrentState;
		int activeMissionIndex = QuestManager.GetActiveMissionIndex();
		for (int i = 0; i < missionCards.Length; i++)
		{
			int num2 = num + i;
			if (num2 <= activeMissionIndex)
			{
				Vector3 localPosition = missionCards[i].transform.localPosition;
				missionCards[i].transform.localPosition = new Vector3((float)num2 * PaddingBetweenCards, localPosition.y, localPosition.z);
				missionCards[i].PageNumber = num2;
				missionCards[i].PopulateData(num2, QuestManager.Missions[num2], currentState);
			}
			else
			{
				missionCards[i].SetVisible(vis: false);
			}
		}
	}

	private void MoveToLocalX(Transform t, float x)
	{
		t.localPosition = new Vector3(x, t.localPosition.y, t.localPosition.z);
	}

	private void OnDestroy()
	{
		if (scrollLeftBtn != null)
		{
			scrollLeftBtn.SelectSignal.RemoveListener(OnScrollLeft);
		}
		if (scrollRightBtn != null)
		{
			scrollRightBtn.SelectSignal.RemoveListener(OnScrollRight);
		}
		FishODexMenuButton.SelectSignal.RemoveListener(OnSelectFishodexButton);
	}
}
public class MissionPartUI : MonoBehaviour
{
	private Image checkMarker;

	private Text missionText;

	private GameObject progress;

	private Text progressText;

	private int missionTextMaxSize;

	private void Awake()
	{
		checkMarker = Find.ComponentOnChild<Image>(this, "Checkbox");
		missionText = Find.ComponentOnChild<Text>(this, "MissionText");
		progress = Find.ChildByName(this, "Progress");
		progressText = Find.ComponentOnChild<Text>(this, "Progress/ProgressText");
		missionTextMaxSize = missionText.resizeTextMaxSize;
		HideProgress();
	}

	public void SetIsChecked(bool isChecked)
	{
		checkMarker.gameObject.SetActive(isChecked);
	}

	public void SetText(string text, Font font, float sizeMultiplier)
	{
		missionText.text = text;
		missionText.font = font;
		missionText.resizeTextMaxSize = (int)((float)missionTextMaxSize * sizeMultiplier);
	}

	public void HideProgress()
	{
		progress.SetActive(value: false);
	}

	public void ShowProgress(int current, int total)
	{
		progress.SetActive(value: true);
		progressText.text = current + "/" + total;
	}
}
public class NumberOfNewFishTypes : MonoBehaviour
{
	private Text textComponent;

	private Image backgroundImage;

	[@Dependency]
	public InventoryManager InventoryManager { get; set; }

	private void Awake()
	{
		this.Inject();
		textComponent = Find.ComponentInChildren<Text>(this);
		backgroundImage = Find.ComponentOnChild<Image>(this, "NewFishNotificationBackground");
		UpdateNumber();
	}

	private void OnDestroy()
	{
		InventoryManager.Inventory.NumberOfNewFishesSignal.RemoveListener(SetNumber);
	}

	private void OnEnable()
	{
		InventoryManager.Inventory.NumberOfNewFishesSignal.AddListener(SetNumber);
		UpdateNumber();
	}

	private void UpdateNumber()
	{
		if (InventoryManager != null && InventoryManager.Inventory != null)
		{
			int numberOfNewFishes = InventoryManager.Inventory.NumberOfNewFishes;
			SetNumber(numberOfNewFishes);
		}
	}

	private void SetNumber(int number)
	{
		bool flag = number != 0;
		if (flag)
		{
			textComponent.text = number.ToString();
		}
		textComponent.enabled = flag;
		backgroundImage.enabled = flag;
	}
}
public class RotateSpawnerBackplate : MonoBehaviour
{
	public float speed = 10f;

	private Quaternion startRotation;

	private void Start()
	{
		startRotation = base.transform.localRotation;
	}

	private void Update()
	{
		base.transform.localRotation = startRotation * Quaternion.Euler(speed * Time.timeSinceLevelLoad, 0f, 0f);
	}
}
[RequireComponent(typeof(FishGrid))]
public class SelectFishButton : GazeButton
{
	public static Signal<FishData> ShowFishSignal = new Signal<FishData>();

	private FishGrid grid;

	private void Start()
	{
		this.Inject();
		grid = GetComponent<FishGrid>();
	}

	public override bool IsSelectable(GameObject obj)
	{
		return grid.GetItem(obj.transform.parent).caught;
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		FishODex.SoundSignal.Dispatch(FishODexSoundEventType.Select);
		FishData fish = grid.GetItem(obj.transform.parent).fish;
		ShowFishSignal.Dispatch(fish);
		return PostSelectAction.WaitForLookAway;
	}
}
public class CastingSettingsGui : MonoBehaviour
{
	private SwitchCastingButton[] switchButtons;

	private void Awake()
	{
		switchButtons = GetComponentsInChildren<SwitchCastingButton>();
	}

	public void OnSwitchButtonClick()
	{
		UpdateBaitButtons();
	}

	private void UpdateBaitButtons()
	{
		for (int i = 0; i < switchButtons.Length; i++)
		{
			switchButtons[i].UpdateVisual();
		}
	}
}
public class ReelSettingsGui : MonoBehaviour
{
	private SwitchReelButton[] switchButtons;

	private void Awake()
	{
		switchButtons = GetComponentsInChildren<SwitchReelButton>();
	}

	public void OnSwitchButtonClick()
	{
		UpdateBaitButtons();
	}

	private void UpdateBaitButtons()
	{
		for (int i = 0; i < switchButtons.Length; i++)
		{
			switchButtons[i].UpdateVisual();
		}
	}
}
public class ReturnToDocksButton : ButtonEffect
{
	public Text infoText;

	public string infoTextString;

	private ApplyLocalizedText infoTextLocalization;

	[@Dependency]
	public GameSession gameSession { get; set; }

	public override PostSelectAction OnSelect(GameObject obj)
	{
		this.Inject();
		gameSession.ManuallySaveSession();
		LoadScene.LoadSceneSignal.Dispatch("TheDocks01");
		return base.OnSelect(obj);
	}

	private void Awake()
	{
		if (infoText == null)
		{
			UnityEngine.Debug.LogWarning(base.transform.name + " doesn't have info link text assigned in the inspector");
		}
		else
		{
			infoTextLocalization = infoText.gameObject.GetComponent<ApplyLocalizedText>();
		}
	}

	public override void OnStartGaze()
	{
		if (infoText == null)
		{
			UnityEngine.Debug.LogWarning(base.transform.name + " doesn't have info link text assigned in the inspector");
			return;
		}
		infoText.text = infoTextString;
		infoText.gameObject.SetActive(value: true);
		infoTextLocalization.PopulateText(forceUpdate: true);
	}

	public override void OnStopGaze()
	{
		if (infoText == null)
		{
			UnityEngine.Debug.LogWarning(base.transform.name + " doesn't have info link text assigned in the inspector");
		}
		else
		{
			infoText.gameObject.SetActive(value: false);
		}
	}
}
public class SwitchCastingButton : ButtonEffect
{
	public Sprite defaultBackGround;

	public Sprite activeBackGround;

	public Image selectedGlow;

	public Image backgroundImage;

	public Text infoText;

	public string infoTextString;

	private ApplyLocalizedText infoTextLocalization;

	public CastingMode castingMode;

	private bool isInitReady;

	private CastingSettingsGui controllerSettingGui;

	[@Dependency]
	public GameSession gameSession { get; set; }

	[@Dependency]
	public Quest Quest { get; set; }

	[@Dependency]
	public Localization localization { get; set; }

	private bool AllowedToSwitch => Quest.CurrentState != null && Quest.CurrentState.Id == "Tutorial01";

	private void Awake()
	{
		this.Inject();
		controllerSettingGui = GetComponentInParent<CastingSettingsGui>();
		if (infoText == null)
		{
			UnityEngine.Debug.LogWarning(base.transform.name + " doesn't have info link text assigned in the inspector");
		}
		else
		{
			infoTextLocalization = infoText.gameObject.GetComponent<ApplyLocalizedText>();
		}
	}

	private void Start()
	{
		isInitReady = true;
		UpdateVisual();
	}

	private void OnEnable()
	{
		if (AllowedToSwitch)
		{
			backgroundImage.color = Color.grey;
			SetIsSelectable(selectable: false);
		}
		else
		{
			SetIsSelectable(selectable: true);
			UpdateVisual();
		}
	}

	public void UpdateVisual()
	{
		if (isInitReady)
		{
			bool flag = gameSession.GetCastingMode() == castingMode;
			selectedGlow.gameObject.SetActive(flag);
			backgroundImage.sprite = ((!flag) ? defaultBackGround : activeBackGround);
		}
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		if (AllowedToSwitch)
		{
			return PostSelectAction.Restart;
		}
		gameSession.SetCastingMode(castingMode);
		controllerSettingGui.OnSwitchButtonClick();
		UpdateVisual();
		return base.OnSelect(obj);
	}

	public override void OnStartGaze()
	{
		if (infoText == null)
		{
			UnityEngine.Debug.LogWarning(base.transform.name + " doesn't have info link text assigned in the inspector");
			return;
		}
		infoText.text = infoTextString;
		infoText.gameObject.SetActive(value: true);
		infoTextLocalization.PopulateText(forceUpdate: true);
	}

	public override void OnStopGaze()
	{
		if (infoText == null)
		{
			UnityEngine.Debug.LogWarning(base.transform.name + " doesn't have info link text assigned in the inspector");
		}
		else
		{
			infoText.gameObject.SetActive(value: false);
		}
	}
}
public class SwitchReelButton : ButtonEffect
{
	public Sprite defaultBackGround;

	public Sprite activeBackGround;

	public Image selectedGlow;

	public Image backgroundImage;

	public Text infoText;

	public string infoTextString;

	private ApplyLocalizedText infoTextLocalization;

	public ReelMode reelMode;

	private bool isInitReady;

	private ReelSettingsGui controllerSettingGui;

	[@Dependency]
	public GameSession gameSession { get; set; }

	[@Dependency]
	public Quest Quest { get; set; }

	[@Dependency]
	public Localization localization { get; set; }

	private bool AllowedToSwitch => Quest.CurrentState != null && Quest.CurrentState.Id == "Tutorial01";

	private void Awake()
	{
		this.Inject();
		controllerSettingGui = GetComponentInParent<ReelSettingsGui>();
		if (infoText == null)
		{
			UnityEngine.Debug.LogWarning(base.transform.name + " doesn't have info link text assigned in the inspector");
		}
		else
		{
			infoTextLocalization = infoText.gameObject.GetComponent<ApplyLocalizedText>();
		}
	}

	private void Start()
	{
		isInitReady = true;
		UpdateVisual();
	}

	private void OnEnable()
	{
		if (AllowedToSwitch)
		{
			backgroundImage.color = Color.grey;
			SetIsSelectable(selectable: false);
		}
		else
		{
			SetIsSelectable(selectable: true);
			UpdateVisual();
		}
	}

	public void UpdateVisual()
	{
		if (isInitReady)
		{
			bool flag = gameSession.GetReelMode() == reelMode;
			selectedGlow.gameObject.SetActive(flag);
			backgroundImage.sprite = ((!flag) ? defaultBackGround : activeBackGround);
		}
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		if (AllowedToSwitch)
		{
			return PostSelectAction.Restart;
		}
		gameSession.SetReelMode(reelMode);
		controllerSettingGui.OnSwitchButtonClick();
		UpdateVisual();
		return base.OnSelect(obj);
	}

	public override void OnStartGaze()
	{
		if (infoText == null)
		{
			UnityEngine.Debug.LogWarning(base.transform.name + " doesn't have info link text assigned in the inspector");
			return;
		}
		infoText.text = infoTextString;
		infoText.gameObject.SetActive(value: true);
		infoTextLocalization.PopulateText(forceUpdate: true);
	}

	public override void OnStopGaze()
	{
		if (infoText == null)
		{
			UnityEngine.Debug.LogWarning(base.transform.name + " doesn't have info link text assigned in the inspector");
		}
		else
		{
			infoText.gameObject.SetActive(value: false);
		}
	}
}
public class SpawnerLookAtCamera : MonoBehaviour
{
	public Camera centerCamera;

	private void Start()
	{
		base.transform.LookAt(centerCamera.transform.position);
		base.transform.rotation *= Quaternion.Euler(0f, 90f, 0f);
	}
}
public class FishParser
{
	private Dictionary<string, CSVTable> sceneFishes;

	private const string folderName = "Fish";

	private string[] scenes = new string[5] { "Cave01", "CherryFalls01", "OceanLake01", "River", "Swamp_01" };

	public FishParser()
	{
		sceneFishes = new Dictionary<string, CSVTable>();
		for (int i = 0; i < scenes.Length; i++)
		{
			sceneFishes.Add(scenes[i], ParseFishesForScene(scenes[i]));
		}
	}

	private CSVTable ParseFishesForScene(string sceneName)
	{
		CSVTable cSVTable = new CSVTable();
		cSVTable.LoadFromResources("Fish/" + sceneName);
		return cSVTable;
	}

	public CSVTable GetFishBySceneName(string sceneName)
	{
		if (!sceneFishes.TryGetValue(sceneName, out var value))
		{
			throw new ArgumentException("No fish definitions found for scene: " + sceneName);
		}
		return value;
	}
}
public enum FishRarity
{
	Common,
	Rare
}
public class FishRegistry : MonoBehaviour
{
	[Serializable]
	public class PrefabInfo
	{
		public FishType fishType;

		public GameObject prefab;
	}

	public PrefabInfo[] fishPrefabs;

	private const string filePath = "Fish/Fish";

	public static FishRegistry Instance { get; private set; }

	public List<FishData> Fishes { get; private set; }

	public List<FishData> QuestFishes => Fishes.Where((FishData fd) => isQuestFish(fd.fishType)).ToList();

	private bool isQuestFish(FishType fish)
	{
		if (fish == FishType.ShamanPerch || fish == FishType.SilverbackMullet || fish == FishType.MonarchPomfret || fish == FishType.BengalTigerFish || fish == FishType.OrangutangMoray || fish == FishType.GalaxyShiner || fish == FishType.FlyingFugu || fish == FishType.BagheeraBurbot || fish == FishType.RiverQueenFish || fish == FishType.BananaFish)
		{
			return false;
		}
		return true;
	}

	private void Awake()
	{
		if (Instance != null)
		{
			UnityEngine.Object.Destroy(this);
			return;
		}
		Instance = this;
		UnityEngine.Object.DontDestroyOnLoad(this);
		Initialize();
	}

	public FishData GetFishDatabyType(FishType fishType)
	{
		FishData fishData = Fishes.FirstOrDefault((FishData fd) => fd.fishType == fishType);
		if (fishData == null)
		{
			throw new ArgumentException("No FishData available for type: " + fishType);
		}
		return fishData;
	}

	public GameObject GetFishPrefab(FishType fishType)
	{
		for (int i = 0; i < fishPrefabs.Length; i++)
		{
			if (fishPrefabs[i].fishType == fishType)
			{
				return fishPrefabs[i].prefab;
			}
		}
		throw new ArgumentException("No FishPrefab available for type: " + fishType);
	}

	private void Initialize()
	{
		Fishes = new List<FishData>();
		CSVTable cSVTable = new CSVTable();
		cSVTable.LoadFromResources("Fish/Fish");
		for (int i = 0; i < cSVTable.NumRows; i++)
		{
			Fishes.Add(CreateFishData(cSVTable.GetRow(i)));
		}
	}

	private FishData CreateFishData(CSVTable.Row row)
	{
		try
		{
			return new FishData(EnumHelper.GetEnumByName<FishType>(row.GetColumn("Fish")), string.Format("Fish_{0}_Name", row.GetColumn("Fish")), EnumHelper.GetEnumByName<FishRarity>(row.GetColumn("Rarity")), row.GetColumnFloat("MinWeight"), row.GetColumnFloat("MaxWeight"), row.GetColumnFloat("PhysicsMass"), row.GetColumnFloat("PhysicsDrag"), row.GetColumnFloat("TwoStarLimit"), row.GetColumnFloat("ThreeStarLimit"), string.Format("Fish_{0}_Description", row.GetColumn("Fish")), row.GetColumnInt("Worth"), row.GetColumnInt("TwoStarBonus"), row.GetColumnInt("ThreeStarBonus"), row.GetColumnInt("NewRecordBonus"), row.GetColumnFloat("MaxSpeed"), row.GetColumnFloat("SwimDepth"), row.GetColumnFloat("Deceleration"), row.GetColumnFloat("IntervalMeanTime"), row.GetColumnFloat("IntervalRandomness"), row.GetColumnFloat("TurnStrength"), row.GetColumnFloat("IdleAnimationSpeed"), row.GetColumnInt("MinNumNibbles"), row.GetColumnInt("MaxNumNibbles"), row.GetColumnFloat("MoveToHookSpeed"), row.GetColumnFloat("NibbleDistance"), row.GetColumnFloat("NibbleFraction"), row.GetColumnFloat("NibbleLength"), row.GetColumnFloat("NibbleRandomness"), row.GetColumnFloat("HookedLength"), row.GetColumnFloat("RushTime"), row.GetColumnFloat("RushRandomness"), row.GetColumnFloat("FatigueTime"), row.GetColumnFloat("FatigueRandomness"), row.GetColumnFloat("StruggleForce"), row.GetColumnFloat("StruggleTorque"), row.GetColumnFloat("StruggleAnimationSpeed"), row.GetColumnFloat("StruggleStamina"));
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("Cannot load fish registry. Malformed line in Fish.csv : " + row.ToString() + " " + ex);
			throw;
		}
	}
}
public enum FishStar
{
	One = 1,
	Two,
	Three
}
public enum FishType
{
	None,
	PunkPike,
	GoldFish,
	SkullBass,
	AlligatorPerch,
	LeopardCatfish,
	PythonEel,
	CowKoi,
	AutumnChar,
	GhostPerch,
	ImperialSalmon,
	GroovyGourami,
	GlowstickTetra,
	BlindHaddock,
	TrashBoot,
	TrashBeercan1,
	TrashBeercan2,
	ParrotPerch,
	TinyWhite,
	ZebraTuna,
	HodRodCuda,
	MandarinTang,
	DiamondMudray,
	ChiliAnchovy,
	HarlequinnFish,
	PinstripePerch,
	PoisonDartMinnow,
	SparklingTrout,
	CamoKoi,
	LavaStoneFish,
	SumoBlowfish,
	Clownfish,
	CopperTopEel,
	KahunaTuna,
	BullPiranah,
	PickledHerring,
	RabidGuppy,
	GoatHeadFish,
	GoldenCrackerFish,
	TattooFish,
	GrimAnglerFish,
	PigskinPufferFish,
	PrehistoricPerch,
	KnifeFish,
	SunAndMoonFish,
	ShamanPerch,
	SilverbackMullet,
	MonarchPomfret,
	BengalTigerFish,
	OrangutangMoray,
	GalaxyShiner,
	FlyingFugu,
	BagheeraBurbot,
	RiverQueenFish,
	BananaFish
}
public class GameSession
{
	public int currentQuestTime;

	public RGSession CurrentSession;

	private Quest quest;

	private InventoryManager inventoryManager;

	private RGTracking tracking;

	private readonly string CatalogueName = "GameSessions";

	private readonly string newGameStartLevel = "OceanLake01";

	private bool isInitialized;

	private bool isCheating;

	private const int maxNumSession = 3;

	public Signal<int> SessionDeletedSignal { get; private set; }

	public Signal<CastingMode> CastingModeChangedSignal { get; private set; }

	public Signal<CastingMode> AfterCastingModeChangedSignal { get; private set; }

	public Signal<ReelMode> ReelModeChangeSingal { get; private set; }

	public List<RGSession> Sessions { get; private set; }

	public GameSession(Quest quest, InventoryManager inventoryManager, RGTracking tracking)
	{
		Sessions = new List<RGSession>(3);
		this.quest = quest;
		this.inventoryManager = inventoryManager;
		this.tracking = tracking;
		SessionDeletedSignal = new Signal<int>();
		CastingModeChangedSignal = new Signal<CastingMode>();
		AfterCastingModeChangedSignal = new Signal<CastingMode>();
		quest.EnterQuestStateSignal.AddListener(OnEnterQuestState);
		EnterGamePlayScene.Enter.AddListener(OnEnterGamePlayScene);
		ApplicationEvent.Quit.AddListener(SaveSession);
		LoadSessionsFromDisk();
		isInitialized = false;
		isCheating = false;
	}

	private void LoadSessionsFromDisk()
	{
		DirectoryInfo directoryInfo = new DirectoryInfo(UnityEngine.Application.persistentDataPath + "/" + CatalogueName);
		if (!directoryInfo.Exists)
		{
			Directory.CreateDirectory(UnityEngine.Application.persistentDataPath + "/" + CatalogueName);
		}
		FileInfo[] files = directoryInfo.GetFiles();
		FileInfo[] array = files;
		foreach (FileInfo fileInfo in array)
		{
			FileStream fileStream = fileInfo.Open(FileMode.Open);
			BinaryFormatter binaryFormatter = new BinaryFormatter();
			binaryFormatter.Binder = new RGSessionTypeBinder();
			try
			{
				RGSession item = (RGSession)binaryFormatter.Deserialize(fileStream);
				Sessions.Add(item);
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError("Unable to deserialize saved gamesession: " + ex);
			}
			fileStream.Close();
		}
	}

	public void ClearCurrentSession()
	{
		CurrentSession = null;
		quest.Reset();
		isInitialized = false;
	}

	public void StartSession(int sessionId)
	{
		RGSession rGSession = Sessions.FirstOrDefault((RGSession s) => s.Id == sessionId);
		isInitialized = true;
		quest.Reset();
		if (rGSession != null)
		{
			tracking.TrackStartMenu("continue", rGSession.Id);
			ContinueSession(rGSession);
		}
		else
		{
			CreateNewSession(newGameStartLevel, sessionId, cheating: false);
			tracking.TrackStartMenu("new", rGSession.Id);
		}
	}

	public void CreateNewSession(string startLevel, int sessionId, bool cheating)
	{
		isCheating = cheating;
		RGSession rGSession = new RGSession();
		rGSession.Id = sessionId;
		CurrentSession = rGSession;
		quest.InitializeQuest(null);
		inventoryManager.InitializeInventory(null);
		rGSession.CastingMode = CastingMode.Free;
		rGSession.ReelMode = ReelMode.Crank;
		Sessions.Add(CurrentSession);
		int num2 = (rGSession.GameTime = 0);
		currentQuestTime = num2;
		LoadScene.LoadSceneSignal.Dispatch(startLevel);
	}

	public void CreateNewUnlockedSession(string startLevel, int sessionId)
	{
		RGSession rGSession = Sessions.FirstOrDefault((RGSession s) => s.Id == sessionId);
		isInitialized = true;
		quest.Reset();
		if (rGSession != null)
		{
			isCheating = true;
		}
		rGSession = new RGSession();
		rGSession.Inventory = new Inventory();
		rGSession.Inventory.Licenses.Add(Location.Beach);
		rGSession.Inventory.Licenses.Add(Location.Swamp);
		rGSession.Inventory.Licenses.Add(Location.Shop01);
		rGSession.Inventory.Licenses.Add(Location.CherryFalls);
		rGSession.Inventory.Licenses.Add(Location.SurfShop01);
		rGSession.Inventory.Licenses.Add(Location.Cave);
		rGSession.Inventory.Rod = RodType.Rod1;
		rGSession.Inventory.Rod = RodType.Rod2;
		rGSession.Inventory.Bobber = BobberType.Bobber3;
		rGSession.Inventory.Reel = ReelType.Reel3;
		rGSession.Inventory.Money = 99000;
		rGSession.Inventory.Baits.Add(BaitType.Bait1, 1);
		rGSession.Inventory.DefaultBait = BaitType.Bait1;
		QuestCondition condition = new FishCondition(FishType.SkullBass, FishStar.Three, 9999, string.Empty);
		rGSession.QuestState = new QuestState("FinishedGame", -1, "None", condition, hasNotification: true, string.Empty, string.Empty, string.Empty, Location.None);
		rGSession.Scene = startLevel;
		rGSession.GameTime = (currentQuestTime = 0);
		rGSession.Id = sessionId;
		CurrentSession = rGSession;
		quest.InitializeQuest(rGSession);
		inventoryManager.InitializeInventory(rGSession);
		rGSession.SimpleCastingMode = false;
		if (!isCheating)
		{
			Sessions.Add(CurrentSession);
		}
		LoadScene.LoadSceneSignal.Dispatch(startLevel);
	}

	public float GetQuestProgress(int sessionId)
	{
		RGSession rGSession = Sessions.FirstOrDefault((RGSession s) => s.Id == sessionId);
		if (rGSession == null)
		{
			return 0f;
		}
		return quest.GetProgress(rGSession.QuestState);
	}

	public int GetNumUniqueCaughtFish(int sessionId)
	{
		return Sessions.FirstOrDefault((RGSession s) => s.Id == sessionId)?.Inventory.FishRecords.Count ?? 0;
	}

	public int GetNumUniqueCaughtQuestFish()
	{
		return Sessions.FirstOrDefault((RGSession s) => s.Id == CurrentSession.Id)?.Inventory.FishRecords.Where((KeyValuePair<FishType, float> ft) => IsQuestFish(ft.Key)).Count() ?? 0;
	}

	public int GetNumUniqueCaughtQuestFish(int sessionId)
	{
		return Sessions.FirstOrDefault((RGSession s) => s.Id == sessionId)?.Inventory.FishRecords.Where((KeyValuePair<FishType, float> ft) => IsQuestFish(ft.Key)).Count() ?? 0;
	}

	public CastingMode GetCastingMode()
	{
		return Sessions.FirstOrDefault((RGSession s) => s.Id == CurrentSession.Id)?.CastingMode ?? CastingMode.Free;
	}

	public void SetCastingMode(CastingMode castingMode)
	{
		RGSession rGSession = Sessions.FirstOrDefault((RGSession s) => s.Id == CurrentSession.Id);
		if (rGSession != null)
		{
			rGSession.CastingMode = castingMode;
			CastingModeChangedSignal.Dispatch(rGSession.CastingMode);
		}
	}

	public ReelMode GetReelMode()
	{
		return Sessions.FirstOrDefault((RGSession s) => s.Id == CurrentSession.Id)?.ReelMode ?? ReelMode.Crank;
	}

	public void SetReelMode(ReelMode reelMode)
	{
		RGSession rGSession = Sessions.FirstOrDefault((RGSession s) => s.Id == CurrentSession.Id);
		if (rGSession != null)
		{
			rGSession.ReelMode = reelMode;
			CastingModeChangedSignal.Dispatch(rGSession.CastingMode);
		}
	}

	private bool IsQuestFish(FishType fish)
	{
		if (fish == FishType.ShamanPerch || fish == FishType.SilverbackMullet || fish == FishType.MonarchPomfret || fish == FishType.BengalTigerFish || fish == FishType.OrangutangMoray || fish == FishType.GalaxyShiner || fish == FishType.FlyingFugu || fish == FishType.BagheeraBurbot || fish == FishType.RiverQueenFish || fish == FishType.BananaFish)
		{
			return false;
		}
		return true;
	}

	public void ManuallySaveSession()
	{
		SaveSession();
	}

	private void ContinueSession(RGSession session)
	{
		CurrentSession = session;
		quest.InitializeQuest(session);
		inventoryManager.InitializeInventory(session);
		if (session.Scene == "Credits" || session.Scene == "credits")
		{
			LoadScene.LoadSceneSignal.Dispatch("OceanLake01");
		}
		else
		{
			LoadScene.LoadSceneSignal.Dispatch(session.Scene);
		}
	}

	private void OnEnterGamePlayScene(string sceneName)
	{
		if (!isInitialized)
		{
			UnityEngine.Debug.Log("Creating mock gamesession.");
			isCheating = true;
			RGSession session = (CurrentSession = CreateCheatSession(sceneName));
			quest.InitializeQuest(session);
			inventoryManager.InitializeInventory(session);
			isInitialized = true;
		}
		else
		{
			SaveSession();
		}
	}

	private void OnEnterQuestState(QuestState questState)
	{
		SaveSession();
	}

	private void SaveSession()
	{
		if (isCheating || CurrentSession == null)
		{
			return;
		}
		CurrentSession.GameTime += currentQuestTime;
		currentQuestTime = 0;
		if (CurrentSession.QuestState != quest.CurrentState)
		{
			tracking.TrackIntroEvent(quest.CurrentState.Id, CurrentSession.GameTime);
			int gameTime = 0;
			CurrentSession.GameTime = gameTime;
			currentQuestTime = gameTime;
		}
		CurrentSession.QuestState = quest.CurrentState;
		CurrentSession.Inventory = inventoryManager.Inventory;
		CurrentSession.Scene = SceneManager.GetActiveScene().name;
		try
		{
			BinaryFormatter binaryFormatter = new BinaryFormatter();
			FileStream fileStream = File.Create(UnityEngine.Application.persistentDataPath + "/" + CatalogueName + "/" + CurrentSession.Id);
			binaryFormatter.Serialize(fileStream, CurrentSession);
			fileStream.Close();
		}
		catch (Exception ex)
		{
			throw new Exception("Unable to save gamesession: " + ex);
		}
	}

	public void DeleteSession(int sessionId)
	{
		string[] files = Directory.GetFiles(UnityEngine.Application.persistentDataPath + "/" + CatalogueName + "/" + sessionId);
		if (files.Length < 1)
		{
			throw new FileNotFoundException("GameSession file with id " + sessionId + " does now exist.");
		}
		try
		{
			File.Delete(files[0]);
		}
		catch (Exception innerException)
		{
			throw new Exception("Unable to delete GameSession file: " + files[0], innerException);
		}
		RGSession rGSession = Sessions.FirstOrDefault((RGSession s) => s.Id == sessionId);
		if (rGSession == null)
		{
			throw new ArgumentException("Gamesession object with id " + sessionId + "does not exist.");
		}
		if (CurrentSession != null && CurrentSession.Id == sessionId)
		{
			CurrentSession = null;
		}
		Sessions.Remove(rGSession);
		SessionDeletedSignal.Dispatch(sessionId);
		tracking.TrackIntroEvent("delete", sessionId);
	}

	private RGSession CreateCheatSession(string startScene)
	{
		RGSession rGSession = new RGSession();
		rGSession.Id = -1;
		rGSession.Inventory = new Inventory();
		rGSession.Inventory.Licenses.Add(Location.Beach);
		rGSession.Inventory.Licenses.Add(Location.Swamp);
		rGSession.Inventory.Licenses.Add(Location.Shop01);
		rGSession.Inventory.Licenses.Add(Location.CherryFalls);
		rGSession.Inventory.Licenses.Add(Location.SurfShop01);
		rGSession.Inventory.Licenses.Add(Location.Cave);
		rGSession.Inventory.Rod = RodType.Rod2;
		rGSession.Inventory.PurchasedItems.Add("rod2");
		rGSession.Inventory.Bobber = BobberType.Bobber2;
		rGSession.Inventory.PurchasedItems.Add("bobber2");
		rGSession.Inventory.Reel = ReelType.Reel2;
		rGSession.Inventory.PurchasedItems.Add("reel2");
		rGSession.Inventory.Money = 99000;
		rGSession.Inventory.Baits.Add(BaitType.Bait1, 1);
		rGSession.Inventory.DefaultBait = BaitType.Bait1;
		rGSession.Inventory.Baits[BaitType.Bait2] = 2;
		rGSession.Inventory.Baits[BaitType.BaitIAP1] = 2;
		QuestCondition condition = new FishCondition(FishType.SkullBass, FishStar.Three, 9999, string.Empty);
		rGSession.QuestState = new QuestState("FinishedGame", -1, "None", condition, hasNotification: true, string.Empty, string.Empty, string.Empty, Location.None);
		rGSession.Scene = startScene;
		rGSession.CastingMode = CastingMode.Free;
		rGSession.ReelMode = ReelMode.Crank;
		return rGSession;
	}
}
[Serializable]
public class RGSession
{
	public int Id { get; set; }

	public QuestState QuestState { get; set; }

	public Inventory Inventory { get; set; }

	public string Scene { get; set; }

	public bool SimpleCastingMode { get; set; }

	public CastingMode CastingMode { get; set; }

	public ReelMode ReelMode { get; set; }

	public int GameTime { get; set; }
}
public class RGSessionTypeBinder : SerializationBinder
{
	public override Type BindToType(string assemblyName, string typeName)
	{
		typeName = typeName.Replace("Session", "RGSession");
		assemblyName = assemblyName.Replace("Session", "RGSession");
		return Type.GetType($"{typeName}, {assemblyName}");
	}
}
public class CallbackGazeButton : GazeButton
{
	private Action callback;

	public override PostSelectAction OnSelect(GameObject obj)
	{
		callback();
		return PostSelectAction.Restart;
	}

	public void SetClickedCallback(Action callback)
	{
		this.callback = callback;
	}
}
public class GDPRDialogStatus
{
	private const string GDPR_PREFS_KEY = "GDPR_User_viewed";

	public static bool HasAccepted()
	{
		return PlayerPrefs.HasKey("GDPR_User_viewed");
	}

	public static void OnPlayerAccepted()
	{
		PlayerPrefs.SetString("GDPR_User_viewed", "accepted");
	}
}
public class GDPRWindow : MonoBehaviour
{
	public GameObject windowRoot;

	public CallbackGazeButton checkMark;

	public CallbackGazeButton acceptButton;

	public Text acceptText;

	public GameObject checkMarkGo;

	public PulsateScale checkmarkPulse;

	public List<GameObject> hideWhenWindowOpen;

	private bool checkmarkChecked;

	private bool alertVisualsActive;

	private void Start()
	{
		bool flag = !GDPRDialogStatus.HasAccepted();
		SetWindowActive(flag);
		if (flag)
		{
			checkMark.SetClickedCallback(OnCheckmarkClicked);
			acceptButton.SetClickedCallback(OnAcceptButtonClicked);
			SetAcceptButtonActive(active: false);
			SetCheckmarkActive(active: false);
		}
	}

	private void SetWindowActive(bool active)
	{
		windowRoot.SetActive(active);
		for (int i = 0; i < hideWhenWindowOpen.Count; i++)
		{
			hideWhenWindowOpen[i].SetActive(!active);
		}
	}

	private void OnCheckmarkClicked()
	{
		checkmarkChecked = !checkmarkChecked;
		SetCheckmarkActive(checkmarkChecked);
		SetAcceptButtonActive(checkmarkChecked);
	}

	private void SetCheckmarkActive(bool active)
	{
		checkMarkGo.SetActive(active);
		checkmarkPulse.enabled = !active;
	}

	private void SetAcceptButtonActive(bool active)
	{
		Image component = acceptButton.GetComponent<Image>();
		component.color = ((!active) ? new Color(1f, 1f, 1f, 0.5f) : Color.white);
		Color color = acceptText.color;
		Color color2 = new Color(color.r, color.g, color.b, (!active) ? 0.5f : 0.9f);
		acceptText.color = color2;
	}

	private void OnAcceptButtonClicked()
	{
		if (checkmarkChecked)
		{
			SetWindowActive(active: false);
			GDPRDialogStatus.OnPlayerAccepted();
		}
		else
		{
			StartCoroutine(OnAcceptFail());
		}
	}

	private IEnumerator OnAcceptFail()
	{
		if (!alertVisualsActive)
		{
			alertVisualsActive = true;
			Image checkmarkImage = checkMark.GetComponent<Image>();
			Transform checkTransform = checkmarkImage.transform;
			Vector3 oldPos = checkTransform.localPosition;
			float mult = 0f;
			float addedAmplitude = 0.5f;
			Color alertColor = (checkmarkImage.color = new Color(1f, 0.15f, 0f));
			checkmarkPulse.pulseAddedAmplitude = addedAmplitude;
			while (mult < 1f)
			{
				mult += 3f * Time.unscaledDeltaTime;
				yield return new WaitForEndOfFrame();
				checkmarkImage.color = Color.Lerp(alertColor, Color.white, mult);
				checkmarkPulse.pulseAddedAmplitude = Mathf.Lerp(addedAmplitude, 0f, mult);
				float shake = Mathf.Sin(mult * (float)Math.PI * 4f) * 15f * Mathf.Sin(mult * (float)Math.PI);
				checkTransform.localPosition = new Vector3(oldPos.x + shake, oldPos.y, oldPos.z);
			}
			alertVisualsActive = false;
		}
	}

	[ContextMenu("Debug: Reset GDPR acceptance")]
	private void ResetGDPRAcceptance()
	{
		PlayerPrefs.DeleteKey("GDPR_User_viewed");
	}
}
public class PulsateScale : MonoBehaviour
{
	public float pulseSpeed = 1f;

	public float pulseAmplitude = 0.3f;

	[HideInInspector]
	public float pulseAddedAmplitude;

	private void Update()
	{
		float num = 1f - pulseAmplitude + pulseAmplitude * Mathf.Sin(Time.time * pulseSpeed) + pulseAddedAmplitude;
		base.transform.localScale = new Vector3(num, num, num);
	}
}
public class GearRegistry : MonoBehaviour
{
	[Serializable]
	public class BobberInfo
	{
		public BobberType bobberType;

		public GameObject prefab;
	}

	[Serializable]
	public class RodInfo
	{
		public RodType rodType;

		public GameObject Defualt;

		[FormerlySerializedAs("Spimple")]
		public GameObject Simple;

		public GameObject Free;

		public GameObject Gaze;
	}

	[Serializable]
	public class ReelInfo
	{
		public ReelType reelType;

		public GameObject prefab;
	}

	[Serializable]
	public class BaitInfo
	{
		public BaitType baitType;

		public GameObject prefab;
	}

	public RodInfo[] rods;

	public BobberInfo[] bobbers;

	public ReelInfo[] reels;

	public BaitInfo[] baits;

	public static GearRegistry Instance { get; private set; }

	private void Awake()
	{
		if (Instance != null)
		{
			UnityEngine.Object.Destroy(this);
		}
		else
		{
			Instance = this;
		}
	}

	public GameObject GetRodByType(RodType rodType, CastingMode castingMode, InputMode inputMode)
	{
		RodInfo rodInfo = rods.FirstOrDefault((RodInfo rod) => rod.rodType == rodType);
		if (rodInfo == null || rodInfo.Defualt == null || rodInfo.Simple == null || rodInfo.Gaze == null)
		{
		}
		if (inputMode == InputMode.Headset)
		{
			return rodInfo.Gaze;
		}
		return castingMode switch
		{
			CastingMode.Simple => rodInfo.Simple, 
			CastingMode.Free => rodInfo.Free, 
			_ => rodInfo.Defualt, 
		};
	}

	public GameObject GetBobberByType(BobberType bobberType)
	{
		BobberInfo bobberInfo = bobbers.FirstOrDefault((BobberInfo bobber) => bobber.bobberType == bobberType);
		if (bobberInfo == null || bobberInfo.prefab == null)
		{
		}
		return bobberInfo.prefab;
	}

	public GameObject GetReelByType(ReelType reelType)
	{
		ReelInfo reelInfo = reels.FirstOrDefault((ReelInfo reel) => reel.reelType == reelType);
		if (reelInfo == null || reelInfo.prefab == null)
		{
		}
		return reelInfo.prefab;
	}

	public GameObject GetBaitByType(BaitType baitType)
	{
		BaitInfo baitInfo = baits.FirstOrDefault((BaitInfo bait) => bait.baitType == baitType);
		if (baitInfo == null || baitInfo.prefab == null)
		{
		}
		return baitInfo.prefab;
	}
}
[RequireComponent(typeof(Collision))]
public class HitableByFish : MonoBehaviour
{
	public static Signal<GameObject, string> OnFishHitSignal = new Signal<GameObject, string>();

	[SerializeField]
	private GameObject onHitparticleEffect;

	[SerializeField]
	private string soundFXName;

	[SerializeField]
	private bool destroyOnHit;

	[SerializeField]
	[Range(1f, 240f)]
	private float respawnTime = 120f;

	private void Awake()
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject.layer == 28 || other.gameObject.layer == 8)
		{
			UnityEngine.Object.Instantiate(onHitparticleEffect, base.transform.position, Quaternion.identity);
			OnFishHitSignal.Dispatch(base.gameObject, soundFXName);
			if (destroyOnHit)
			{
				OnObjectHitWithFish();
			}
		}
	}

	private void OnObjectHitWithFish()
	{
		base.gameObject.GetComponent<Collider>().enabled = false;
		base.gameObject.GetComponentInChildren<SkinnedMeshRenderer>().enabled = false;
		StartCoroutine(RespawnTimer());
	}

	private IEnumerator RespawnTimer()
	{
		yield return new WaitForSeconds(respawnTime);
		base.gameObject.GetComponentInChildren<SkinnedMeshRenderer>().enabled = true;
		base.gameObject.GetComponent<Collider>().enabled = true;
	}
}
public class BuyableItemData
{
	public enum BuyableType
	{
		BuyOnce = 1,
		ConsumableNonIAP,
		ConsumableIAP,
		DurableIAP
	}

	public struct Item
	{
		public string id;

		public string name;

		public string description;

		public int cost;

		public bool defaultAvailable;

		public string questCondition;

		public string requiredItem;

		public BuyableType shopBehavior;
	}

	private CSVTable csv;

	private Quest quest;

	private Localization localization;

	public const string CSV_FILEPATH = "Buyables/Buyables";

	public BuyableItemData(Quest quest, Localization localization)
	{
		csv = new CSVTable();
		csv.LoadFromResources("Buyables/Buyables");
		this.quest = quest;
		this.localization = localization;
	}

	public Item GetItemFromId(string id)
	{
		id = id.ToLower();
		for (int i = 0; i < csv.NumRows; i++)
		{
			if (csv.GetRow(i).GetColumn("Id") == id)
			{
				CSVTable.Row row = csv.GetRow(i);
				Item result = default(Item);
				result.id = id;
				result.name = localization.GetString(row.GetColumn("Name"));
				result.description = localization.GetString(row.GetColumn("Description"));
				if (result.id == "bait2" && quest.CurrentState.Id == "BuyBait01")
				{
					result.cost = 0;
				}
				else
				{
					result.cost = row.GetColumnInt("Cost");
				}
				result.defaultAvailable = row.GetColumnBool("AvailableByDefault");
				result.questCondition = row.GetColumn("QuestCondition");
				result.requiredItem = row.GetColumn("RequiredItem");
				try
				{
					result.shopBehavior = GetTypeFromString(row.GetColumn("ShopBehavior"));
				}
				catch (Exception ex)
				{
					UnityEngine.Debug.LogError("ERROR: Invalid ShopBehaviour value on item " + result.name + ", " + ex.Message);
				}
				return result;
			}
		}
		throw new Exception("Cannot locate item with id '" + id + "'");
	}

	private BuyableType GetTypeFromString(string str)
	{
		return str switch
		{
			"BuyOnce" => BuyableType.BuyOnce, 
			"ConsumableNonIAP" => BuyableType.ConsumableNonIAP, 
			"ConsumableIAP" => BuyableType.ConsumableIAP, 
			"DurableIAP" => BuyableType.DurableIAP, 
			_ => throw new Exception("Invalid ShopBehavior string: " + str), 
		};
	}

	public string[] GetIAPSKUs()
	{
		List<string> list = new List<string>();
		for (int i = 0; i < csv.NumRows; i++)
		{
			CSVTable.Row row = csv.GetRow(i);
			BuyableType typeFromString = GetTypeFromString(row.GetColumn("ShopBehavior"));
			if (typeFromString == BuyableType.ConsumableIAP || typeFromString == BuyableType.DurableIAP)
			{
				list.Add(row.GetColumn("Id"));
			}
		}
		return list.ToArray();
	}

	public BuyableType GetItemTypeFromSku(string sku)
	{
		return GetItemFromId(sku).shopBehavior;
	}
}
[Serializable]
public class DurableInventory
{
	private List<string> Items;

	public DurableInventory()
	{
		Items = new List<string>();
	}

	public void SyncItem(string itemId)
	{
		if (!Items.Contains(itemId))
		{
			Items.Add(itemId);
		}
	}

	public bool ContainsItem(string itemId)
	{
		return Items.Contains(itemId);
	}
}
[Serializable]
public class Inventory
{
	private int money;

	private int numberOfNewFishes;

	[NonSerialized]
	public Signal<int> NumberOfNewFishesSignal;

	public int Money
	{
		get
		{
			return money;
		}
		set
		{
			money = Mathf.Max(value, 0);
		}
	}

	public BaitType CurrentBait { get; set; }

	public BaitType DefaultBait { get; set; }

	public Dictionary<BaitType, int> Baits { get; set; }

	public Dictionary<FishType, float> FishRecords { get; set; }

	public int NumberOfNewFishes
	{
		get
		{
			return numberOfNewFishes;
		}
		private set
		{
			if (value != numberOfNewFishes)
			{
				numberOfNewFishes = value;
				NumberOfNewFishesSignal.Dispatch(value);
			}
		}
	}

	public Dictionary<FishType, bool> UnopenedFishes { get; set; }

	public List<Location> Licenses { get; set; }

	public BobberType Bobber { get; set; }

	public RodType Rod { get; set; }

	public ReelType Reel { get; set; }

	public FishingLineType fishingLine { get; set; }

	public List<string> PurchasedItems { get; set; }

	public Inventory()
	{
		Licenses = new List<Location>();
		FishRecords = new Dictionary<FishType, float>();
		UnopenedFishes = new Dictionary<FishType, bool>();
		NumberOfNewFishes = 0;
		Baits = new Dictionary<BaitType, int>();
		PurchasedItems = new List<string>();
		money = 0;
		InitializeNonserialized();
	}

	[OnDeserializing]
	private void SetValuesOnDeserializing(StreamingContext context)
	{
		InitializeNonserialized();
	}

	private void InitializeNonserialized()
	{
		NumberOfNewFishesSignal = new Signal<int>();
	}

	public void AddFishWorth(FishData fish)
	{
		Money += fish.worth;
	}

	public void AddToFishRecord(Fish fish)
	{
		float value;
		bool flag = FishRecords.TryGetValue(fish.FishData.fishType, out value);
		FishType fishType = fish.FishData.fishType;
		FishRecords[fishType] = Mathf.Max(fish.weight, value);
		if (!flag)
		{
			UnopenedFishes[fishType] = true;
			NumberOfNewFishes++;
		}
	}

	public bool HasRecord(Fish fish)
	{
		return FishRecords.ContainsKey(fish.FishData.fishType);
	}

	public float GetRecord(Fish fish)
	{
		FishData fishData = fish.FishData;
		FishType fishType = fishData.fishType;
		float minWeight = fishData.minWeight;
		FishRecords.TryGetValue(fishType, out var value);
		return Mathf.Max(minWeight, value);
	}

	public bool IsRecord(Fish fish)
	{
		float weight = fish.weight;
		float record = GetRecord(fish);
		return weight > record;
	}

	public int GetNumThreeStarFishes()
	{
		int num = 0;
		for (int i = 0; i < FishRecords.Count; i++)
		{
			FishType key = FishRecords.ElementAt(i).Key;
			float value = FishRecords.ElementAt(i).Value;
			FishData fishDatabyType = FishRegistry.Instance.GetFishDatabyType(key);
			if (fishDatabyType.GetStarRating(value) == FishStar.Three)
			{
				num++;
			}
		}
		return num;
	}

	public void ClearNewFishes()
	{
		NumberOfNewFishes = 0;
	}
}
public class InventoryManager
{
	private FishParser fishParser;

	private string catalogueName = UnityEngine.Application.persistentDataPath + "/DurableInventory/";

	private string fileName = "DurableInventory";

	public Inventory Inventory { get; private set; }

	public DurableInventory DurableInventory { get; private set; }

	public InventoryManager(FishParser fishParser)
	{
		this.fishParser = fishParser;
		DurableInventory = LoadDurableInventory();
	}

	public void InitializeInventory(RGSession session)
	{
		if (session != null)
		{
			Inventory = session.Inventory;
		}
		else
		{
			Inventory = CreateNewInventory();
		}
	}

	public int GetNumFishCaughtInLocation(string location)
	{
		int num = 0;
		CSVTable fishBySceneName = fishParser.GetFishBySceneName(location);
		for (int i = 1; i < fishBySceneName.NumRows; i++)
		{
			FishType enumByName = EnumHelper.GetEnumByName<FishType>(fishBySceneName.GetRow(i).GetColumn(0));
			if (Inventory.FishRecords.ContainsKey(enumByName))
			{
				num++;
			}
		}
		return num;
	}

	private Inventory CreateNewInventory()
	{
		Inventory inventory = new Inventory();
		inventory.Bobber = BobberType.Bobber1;
		inventory.Rod = RodType.Rod1;
		inventory.Reel = ReelType.Reel1;
		inventory.Licenses.Add(Location.Beach);
		inventory.fishingLine = FishingLineType.Default;
		inventory.Baits.Add(BaitType.Bait1, 1);
		inventory.Baits.Add(BaitType.Bait1QuestUpgrade, 1);
		inventory.CurrentBait = BaitType.Bait1;
		inventory.DefaultBait = BaitType.Bait1;
		return inventory;
	}

	private DurableInventory LoadDurableInventory()
	{
		string path = catalogueName + fileName;
		if (!File.Exists(path))
		{
			Directory.CreateDirectory(catalogueName);
			return new DurableInventory();
		}
		FileStream fileStream = new FileStream(path, FileMode.Open);
		try
		{
			BinaryFormatter binaryFormatter = new BinaryFormatter();
			return binaryFormatter.Deserialize(fileStream) as DurableInventory;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogWarning($"Unable to deserialize durable inventory: {ex.ToString()}");
			return new DurableInventory();
		}
		finally
		{
			fileStream?.Close();
		}
	}

	public void SaveDurableInventory()
	{
		try
		{
			BinaryFormatter binaryFormatter = new BinaryFormatter();
			FileStream fileStream = File.Create(catalogueName + fileName);
			binaryFormatter.Serialize(fileStream, DurableInventory);
			fileStream.Close();
		}
		catch (Exception ex)
		{
			throw new Exception("Unable to save durable inventory: " + ex);
		}
	}
}
public enum Location
{
	None = 0,
	Beach = 1,
	Swamp = 2,
	CherryFalls = 4,
	Shop01 = 8,
	SurfShop01 = 0x10,
	Cave = 0x20,
	River = 0x40
}
public class Luring : MonoBehaviour
{
	public AggregationOfFish fishes;

	public float minimumDistance = 1f;

	private Hook hook;

	private int fishIndex;

	private void Start()
	{
		this.Inject();
		RodAssembler.RodAssembledNotification.AddListener(UpdateRod);
	}

	private void OnDestroy()
	{
		RodAssembler.RodAssembledNotification.RemoveListener(UpdateRod);
	}

	private void UpdateRod(RodAssembler.RodParts parts)
	{
		hook = parts.hook.GetComponent<Hook>();
	}

	private void Update()
	{
		if (!hook.CanAttract)
		{
			return;
		}
		IList<FishBehavior> list = fishes.Fishes;
		if (list.Count != 0)
		{
			fishIndex = (fishIndex + 1) % list.Count;
			Vector3 position = hook.transform.position;
			float num = minimumDistance * minimumDistance;
			FishBehavior fishBehavior = list[fishIndex];
			float sqrMagnitude = (fishBehavior.fish.transform.position - position).sqrMagnitude;
			if (sqrMagnitude <= num)
			{
				fishBehavior.Lure(hook);
			}
		}
	}
}
public class ButtonEffect : GazeButton
{
	public Signal OnSelectSignal = new Signal();

	public float activeZOffset = 30f;

	public PostSelectAction OnSelectAction = PostSelectAction.WaitForLookAway;

	private float startZ;

	private bool isSelectable = true;

	[@Dependency]
	public FishODexEvent FishODexSignal { get; set; }

	private void Awake()
	{
		this.Inject();
		startZ = base.transform.localPosition.z;
	}

	public override void OnStartGaze()
	{
		if (isSelectable)
		{
			FishODexSignal.Dispatch(FishODexEventType.ItemHover, base.gameObject.transform);
			LeanTween.moveLocalZ(base.gameObject, startZ - activeZOffset, 0.2f).setEase(LeanTweenType.easeOutSine);
		}
	}

	public override void OnStopGaze()
	{
		if (isSelectable)
		{
			LeanTween.moveLocalZ(base.gameObject, startZ, 0.2f).setEase(LeanTweenType.easeOutSine);
		}
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		FishODexSignal.Dispatch(FishODexEventType.ItemSelect, base.gameObject.transform);
		OnSelectSignal.Dispatch();
		return OnSelectAction;
	}

	public void SetIsSelectable(bool selectable)
	{
		isSelectable = selectable;
		if (!isSelectable)
		{
			LeanTween.cancel(base.gameObject);
			base.transform.localPosition = new Vector3(base.transform.localPosition.x, base.transform.localPosition.y, startZ);
		}
	}

	private void OnDestroy()
	{
		LeanTween.cancel(base.gameObject);
	}
}
public class CheatButton : GazeButton
{
	public string scene = "Swamp01";

	[@Dependency]
	public GameSession gameSession { get; set; }

	private void Start()
	{
		this.Inject();
		GetComponentInChildren<TextMesh>().text = scene;
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		gameSession.CreateNewSession(scene, -1, cheating: true);
		return base.OnSelect(obj);
	}
}
public class CreditsButton : ButtonEffect
{
	public override PostSelectAction OnSelect(GameObject obj)
	{
		LoadScene.LoadSceneSignal.Dispatch("Credits");
		return base.OnSelect(obj);
	}
}
public class MainMenu : MonoBehaviour
{
	public enum Screen
	{
		Main,
		Play,
		Edit,
		ConfirmDelete,
		Settings,
		Language,
		Credits
	}

	public GameObject MainScreen;

	public GameObject PlayScreen;

	public GameObject SettingsScreen;

	public GameObject LanguageScreen;

	public GameObject ConfirmDelete;

	private Dictionary<Screen, BaseScreen> screens;

	private BaseScreen currentScreen;

	private int selectedDeleteSessionId;

	[@Dependency]
	public GameSession GameSession { get; set; }

	[@Dependency]
	public Localization localization { get; set; }

	private void Awake()
	{
		this.Inject();
		screens = new Dictionary<Screen, BaseScreen>(6);
		SetupScreen(MainScreen, Screen.Main);
		SetupScreen(PlayScreen, Screen.Play);
		SetupScreen(SettingsScreen, Screen.Settings);
		SetupScreen(LanguageScreen, Screen.Language);
		SetupScreen(ConfirmDelete, Screen.ConfirmDelete);
		ChangeScreen(Screen.Main);
	}

	private void Start()
	{
		MainMenuDeleteButton.ClickSignal.AddListener(OnDeleteButtonClick);
		MainMenuConfirmDeleteButton.clickEvent.AddListener(OnConfirmDeleteButtonClick);
		localization.changeLanguageNotification.AddListener(UpdateLanguageInMainMenu);
		GameSession.ClearCurrentSession();
	}

	public void UpdateLanguageInMainMenu()
	{
		ApplyLocalizedText[] componentsInChildren = GetComponentsInChildren<ApplyLocalizedText>(includeInactive: true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (componentsInChildren[i].localization != null)
			{
				componentsInChildren[i].PopulateText();
			}
		}
	}

	private void OnDeleteButtonClick(int sessionId)
	{
		selectedDeleteSessionId = sessionId;
	}

	private void OnConfirmDeleteButtonClick()
	{
		GameSession.DeleteSession(selectedDeleteSessionId);
	}

	private void SetupScreen(GameObject screen, Screen key)
	{
		screen.SetActive(value: true);
		screen.transform.localPosition = Vector3.zero;
		MainMenuNavButton[] componentsInChildren = screen.GetComponentsInChildren<MainMenuNavButton>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].ChangeScreenSignal.AddListener(ChangeScreen);
		}
		BaseScreen baseScreen = Find.ComponentOnGameObject<BaseScreen>(this, screen);
		baseScreen.InitScreen(this, key);
		screens[key] = baseScreen;
		screen.SetActive(value: false);
	}

	private BaseScreen GetScreenInstanceFromEnum(Screen screenEnum)
	{
		return screens[screenEnum];
	}

	public void ChangeScreen(Screen toScreen)
	{
		if (!(currentScreen != null) || currentScreen.GetScreenId() != toScreen)
		{
			if (currentScreen != null)
			{
				currentScreen.gameObject.SetActive(value: false);
			}
			currentScreen = GetScreenInstanceFromEnum(toScreen);
			currentScreen.gameObject.SetActive(value: true);
		}
	}

	private void OnDestroy()
	{
		MainMenuDeleteButton.ClickSignal.RemoveListener(OnDeleteButtonClick);
		MainMenuConfirmDeleteButton.clickEvent.RemoveListener(OnConfirmDeleteButtonClick);
		localization.changeLanguageNotification.RemoveListener(UpdateLanguageInMainMenu);
	}
}
public class MainMenuConfirmDeleteButton : MainMenuNavButton
{
	public static Signal clickEvent = new Signal();

	[@Dependency]
	public RGTracking tracking { get; set; }

	public override PostSelectAction OnSelect(GameObject obj)
	{
		clickEvent.Dispatch();
		ChangeScreenSignal.Dispatch(TargetScreen);
		return base.OnSelect(obj);
	}
}
public class MainMenuDeleteButton : MainMenuNavButton
{
	public static Signal<int> ClickSignal = new Signal<int>();

	public int sessionId { get; set; }

	public override PostSelectAction OnSelect(GameObject obj)
	{
		ClickSignal.Dispatch(sessionId);
		ChangeScreenSignal.Dispatch(TargetScreen);
		return base.OnSelect(obj);
	}
}
public class MainMenuGameSlotButton : ButtonEffect
{
	[Tooltip("GameSession Id for this slot: 0,1 or 2")]
	public int sessionId;

	public GameObject deleteButton;

	public Sprite newGameBackground;

	public Sprite continueGameBackground;

	private Text newGameText;

	private Image backGround;

	private Image fishImage;

	private Text numFishText;

	private Image progressBarBorder;

	private Image progressBarFill;

	private Text storyText;

	private Text tapToPlayText;

	private Text clickToPlayText;

	[@Dependency]
	public GameSession GameSession { get; set; }

	[@Dependency]
	public InputModeSwitchEvent GearVRInputSwitchSignal { get; set; }

	[@Dependency]
	public InputManager input { get; set; }

	private void Start()
	{
		this.Inject();
		backGround = Find.ComponentOnGameObject<Image>(this);
		newGameText = Find.ComponentOnChild<Text>(this, "NewGameText");
		storyText = Find.ComponentOnChild<Text>(this, "StoryText");
		fishImage = Find.ComponentOnChild<Image>(this, "FishImage");
		numFishText = Find.ComponentOnChild<Text>(this, "NumFishText");
		progressBarBorder = Find.ComponentOnChild<Image>(this, "ProgressBarBorder");
		progressBarFill = Find.ComponentOnChild<Image>(this, "ProgressBarFill");
		tapToPlayText = Find.ComponentOnChild<Text>(this, "TapToPlay");
		clickToPlayText = Find.ComponentOnChild<Text>(this, "ClickToPlay");
		tapToPlayText.gameObject.SetActive(value: false);
		clickToPlayText.gameObject.SetActive(value: false);
		GameSession.SessionDeletedSignal.AddListener(OnSessionDeleletedNotification);
		GearVRInputSwitchSignal.AddListener(OnActiveControllerChanged);
		UpdateVisuals(sessionId);
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		GameSession.StartSession(sessionId);
		return base.OnSelect(obj);
	}

	private void OnActiveControllerChanged(InputMode inputType)
	{
		if (inputType == InputMode.Headset)
		{
			if (!newGameText.gameObject.activeSelf)
			{
				tapToPlayText.gameObject.SetActive(value: true);
			}
			clickToPlayText.gameObject.SetActive(value: false);
		}
		else
		{
			if (!newGameText.gameObject.activeSelf)
			{
				clickToPlayText.gameObject.SetActive(value: true);
			}
			tapToPlayText.gameObject.SetActive(value: false);
		}
	}

	private void OnSessionDeleletedNotification(int deletedSessionId)
	{
		UpdateVisuals(sessionId);
	}

	private void UpdateVisuals(int sessionId)
	{
		RGSession rGSession = GameSession.Sessions.FirstOrDefault((RGSession s) => s.Id == sessionId);
		if (rGSession != null)
		{
			SetContinueGameVisuals(rGSession);
		}
		else
		{
			SetNewGameVisuals();
		}
	}

	private void SetContinueGameVisuals(RGSession session)
	{
		backGround.sprite = continueGameBackground;
		newGameText.gameObject.SetActive(value: false);
		storyText.gameObject.SetActive(value: true);
		fishImage.gameObject.SetActive(value: true);
		numFishText.gameObject.SetActive(value: true);
		numFishText.text = GetNumFishText();
		if (input.GetInputMode() == InputMode.Headset)
		{
			tapToPlayText.gameObject.SetActive(value: true);
		}
		else
		{
			clickToPlayText.gameObject.SetActive(value: true);
		}
		progressBarBorder.gameObject.SetActive(value: true);
		progressBarFill.gameObject.SetActive(value: true);
		AdjustProgressBarFill();
		deleteButton.SetActive(value: true);
		Find.ComponentOnGameObject<MainMenuDeleteButton>(deleteButton).sessionId = sessionId;
	}

	private void SetNewGameVisuals()
	{
		backGround.sprite = newGameBackground;
		newGameText.gameObject.SetActive(value: true);
		storyText.gameObject.SetActive(value: false);
		fishImage.gameObject.SetActive(value: false);
		numFishText.gameObject.SetActive(value: false);
		if (input.GetInputMode() == InputMode.Headset)
		{
			tapToPlayText.gameObject.SetActive(value: false);
		}
		else
		{
			clickToPlayText.gameObject.SetActive(value: false);
		}
		progressBarBorder.gameObject.SetActive(value: false);
		progressBarFill.gameObject.SetActive(value: false);
		deleteButton.SetActive(value: false);
	}

	private void AdjustProgressBarFill()
	{
		float questProgress = GameSession.GetQuestProgress(sessionId);
		progressBarFill.fillAmount = Mathf.Max(0.05f, questProgress);
	}

	private string GetNumFishText()
	{
		int numUniqueCaughtQuestFish = GameSession.GetNumUniqueCaughtQuestFish(sessionId);
		int num = FishRegistry.Instance.QuestFishes.Count();
		return $"{numUniqueCaughtQuestFish}/{num}";
	}

	private void OnDestroy()
	{
		GameSession.SessionDeletedSignal.RemoveListener(OnSessionDeleletedNotification);
		GearVRInputSwitchSignal.RemoveListener(OnActiveControllerChanged);
	}
}
public class MainMenuNavButton : ButtonEffect
{
	public Signal<MainMenu.Screen> ChangeScreenSignal = new Signal<MainMenu.Screen>();

	public MainMenu.Screen TargetScreen;

	[@Dependency]
	public InputManager input { get; set; }

	private void Start()
	{
		this.Inject();
		input.AddBackButtonListener(4, BackButtonFunction);
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		ChangeScreenSignal.Dispatch(TargetScreen);
		return base.OnSelect(obj);
	}

	public CallbackResult BackButtonFunction()
	{
		if (TargetScreen == MainMenu.Screen.Main && base.gameObject.activeInHierarchy)
		{
			ChangeScreenSignal.Dispatch(TargetScreen);
			return CallbackResult.Consumed;
		}
		return CallbackResult.NotConsumed;
	}

	private void OnDestroy()
	{
		input.RemoveBackButtonListener(BackButtonFunction);
	}
}
public class MainMenuSelectLanguageButton : MainMenuNavButton
{
	public string LanguageToSet;

	private Image backgroundImage;

	private Text textField;

	[@Dependency]
	public Localization localization { get; set; }

	private void Start()
	{
		this.Inject();
		SetUpReferences();
		localization.changeLanguageNotification.AddListener(UpdateColorsOnButtons);
		UpdateColorsOnButtons();
	}

	private void SetUpReferences()
	{
		if (backgroundImage == null)
		{
			backgroundImage = base.transform.parent.GetComponent<Image>();
		}
		if (textField == null)
		{
			textField = GetComponent<Text>();
		}
		TargetScreen = MainMenu.Screen.Language;
	}

	private void Reset()
	{
		SetUpReferences();
	}

	private void UpdateColorsOnButtons()
	{
		if (localization.CurrentLanguangId == LanguageToSet)
		{
			backgroundImage.color = new Color(0.83529f, 0.93725f, 0.36078f, 0.85f);
			textField.color = new Color(0.34118f, 0.40784f, 0.26667f);
		}
		else
		{
			backgroundImage.color = Color.clear;
			textField.color = new Color(0.83529f, 0.93725f, 0.36078f);
		}
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		localization.SetLanguage(LanguageToSet, fromStartup: false);
		return base.OnSelect(obj);
	}

	private void OnDestroy()
	{
		localization.changeLanguageNotification.RemoveListener(UpdateColorsOnButtons);
	}
}
public class MainMenuSignalButton : ButtonEffect
{
	public Signal SelectSignal = new Signal();

	public override PostSelectAction OnSelect(GameObject obj)
	{
		SelectSignal.Dispatch();
		return base.OnSelect(obj);
	}
}
public class MainMenuStartButton : MainMenuNavButton
{
	[@Dependency]
	public RGTracking tracking { get; set; }

	public override PostSelectAction OnSelect(GameObject obj)
	{
		ChangeScreenSignal.Dispatch(TargetScreen);
		return PostSelectAction.Restart;
	}
}
public class BaseScreen : MonoBehaviour
{
	private MainMenu menu;

	private MainMenu.Screen id;

	public void InitScreen(MainMenu mainMenu, MainMenu.Screen screenId)
	{
		menu = mainMenu;
		id = screenId;
	}

	protected void ChangeScreen(MainMenu.Screen toScreen)
	{
		menu.ChangeScreen(toScreen);
	}

	public MainMenu.Screen GetScreenId()
	{
		return id;
	}
}
public enum SoundSettingsEventType
{
	SavePersistantSettings,
	LoadPersistantSettings,
	MuteMusic,
	UnmuteMusic,
	MuteSounds,
	UnmuteSounds
}
public enum HapticsSettingsEventType
{
	SavePersistantSettings,
	LoadPersistantSettings,
	EnableHaptics,
	DisableHaptics
}
public class SettingsScreen : BaseScreen
{
	public static Signal<SoundSettingsEventType> SoundSettingsSignal = new Signal<SoundSettingsEventType>();

	public static Signal<HapticsSettingsEventType> HapticsSettingsSignal = new Signal<HapticsSettingsEventType>();

	public Sprite SoundOnSprite;

	public Sprite SoundOffSprite;

	public Sprite MusicOnSprite;

	public Sprite MusicOffSprite;

	private GameObject toggleSoundGO;

	private Signal toggleSoundSignal;

	private Image toggleSoundImage;

	private GameObject toggleMusicGO;

	private Signal toggleMusicSignal;

	private Image toggleMusicImage;

	private bool isInitReady;

	private void Awake()
	{
		this.Inject();
		toggleSoundGO = Find.ChildByName(this, "SoundFXButton");
		toggleMusicGO = Find.ChildByName(this, "MusicButton");
		toggleSoundSignal = Find.ComponentOnGameObject<MainMenuSignalButton>(this, toggleSoundGO).SelectSignal;
		toggleMusicSignal = Find.ComponentOnGameObject<MainMenuSignalButton>(this, toggleMusicGO).SelectSignal;
		toggleSoundImage = Find.ComponentOnGameObject<Image>(this, toggleSoundGO);
		toggleMusicImage = Find.ComponentOnGameObject<Image>(this, toggleMusicGO);
	}

	private void Start()
	{
		isInitReady = true;
		InitButtons();
	}

	private void OnEnable()
	{
		InitButtons();
	}

	private void InitButtons()
	{
		if (isInitReady)
		{
			toggleSoundSignal.AddListener(OnToggleSound);
			toggleMusicSignal.AddListener(OnToggleMusic);
			UpdateSoundButton();
			UpdateMusicButton();
		}
	}

	private void OnDisable()
	{
		toggleSoundSignal.RemoveListener(OnToggleSound);
		toggleMusicSignal.RemoveListener(OnToggleMusic);
	}

	private void OnToggleMusic()
	{
		SoundSettingsEventType item = ((!SoundManager.MusicMuted) ? SoundSettingsEventType.MuteMusic : SoundSettingsEventType.UnmuteMusic);
		SoundSettingsSignal.Dispatch(item);
		SoundSettingsSignal.Dispatch(SoundSettingsEventType.SavePersistantSettings);
		UpdateMusicButton();
	}

	private void OnToggleSound()
	{
		SoundSettingsEventType item = ((!SoundManager.SoundsMuted) ? SoundSettingsEventType.MuteSounds : SoundSettingsEventType.UnmuteSounds);
		SoundSettingsSignal.Dispatch(item);
		SoundSettingsSignal.Dispatch(SoundSettingsEventType.SavePersistantSettings);
		UpdateSoundButton();
	}

	private void UpdateSoundButton()
	{
		toggleSoundImage.sprite = ((!SoundManager.SoundsMuted) ? SoundOnSprite : SoundOffSprite);
	}

	private void UpdateMusicButton()
	{
		toggleMusicImage.sprite = ((!SoundManager.MusicMuted) ? MusicOnSprite : MusicOffSprite);
	}
}
public class ToggleHapticsButton : ButtonEffect
{
	public Sprite ButtonOnSprite;

	public Sprite ButtonOffSprite;

	private Image buttonImage;

	private bool isInitReady;

	public Text infoText;

	public string infoTextString;

	private ApplyLocalizedText infoTextLocalization;

	[@Dependency]
	public InputManager input { get; set; }

	private void Awake()
	{
		this.Inject();
		buttonImage = Find.ComponentOnGameObject<Image>(this);
		if (infoText == null)
		{
			UnityEngine.Debug.LogWarning(base.transform.name + " doesn't have info link text assigned in the inspector");
		}
		else
		{
			infoTextLocalization = infoText.gameObject.GetComponent<ApplyLocalizedText>();
		}
	}

	private void Start()
	{
		isInitReady = true;
		UpdateButtonState();
	}

	private void OnEnable()
	{
		UpdateButtonState();
	}

	private void UpdateButtonState()
	{
		if (isInitReady)
		{
			buttonImage.sprite = ((!SaveLoadPersistant.isHapticEnabled) ? ButtonOffSprite : ButtonOnSprite);
		}
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		OnToogleHaptics();
		return base.OnSelect(obj);
	}

	private void OnToogleHaptics()
	{
		HapticsSettingsEventType item = ((!SaveLoadPersistant.isHapticEnabled) ? HapticsSettingsEventType.DisableHaptics : HapticsSettingsEventType.EnableHaptics);
		SettingsScreen.HapticsSettingsSignal.Dispatch(item);
		SettingsScreen.HapticsSettingsSignal.Dispatch(HapticsSettingsEventType.SavePersistantSettings);
		if (SaveLoadPersistant.isHapticEnabled)
		{
			input.RandomHaptic(0.5f, 1f, 0.1f);
		}
		UpdateButtonState();
	}

	public override void OnStartGaze()
	{
		if (infoText == null)
		{
			UnityEngine.Debug.LogWarning(base.transform.name + " doesn't have info link text assigned in the inspector");
			return;
		}
		infoText.text = infoTextString;
		infoText.gameObject.SetActive(value: true);
		infoTextLocalization.PopulateText(forceUpdate: true);
	}

	public override void OnStopGaze()
	{
		if (infoText == null)
		{
			UnityEngine.Debug.LogWarning(base.transform.name + " doesn't have info link text assigned in the inspector");
		}
		else
		{
			infoText.gameObject.SetActive(value: false);
		}
	}
}
public class ToggleSoundButton : ButtonEffect
{
	public enum SoundToggleType
	{
		ToggleMusic,
		ToggleSounds
	}

	public SoundToggleType WhatToToggle;

	public Sprite ButtonOnSprite;

	public Sprite ButtonOffSprite;

	private Image buttonImage;

	private bool isInitReady;

	public Text infoText;

	public string infoTextString;

	private ApplyLocalizedText infoTextLocalization;

	private void Awake()
	{
		this.Inject();
		buttonImage = Find.ComponentOnGameObject<Image>(this);
		if (infoText == null)
		{
			UnityEngine.Debug.LogWarning(base.transform.name + " doesn't have info link text assigned in the inspector");
		}
		else
		{
			infoTextLocalization = infoText.gameObject.GetComponent<ApplyLocalizedText>();
		}
	}

	private void Start()
	{
		isInitReady = true;
		UpdateButtonState();
	}

	private void OnEnable()
	{
		UpdateButtonState();
	}

	private void UpdateButtonState()
	{
		if (isInitReady)
		{
			if (WhatToToggle == SoundToggleType.ToggleMusic)
			{
				buttonImage.sprite = ((!SoundManager.MusicMuted) ? ButtonOnSprite : ButtonOffSprite);
			}
			else
			{
				buttonImage.sprite = ((!SoundManager.SoundsMuted) ? ButtonOnSprite : ButtonOffSprite);
			}
		}
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		if (WhatToToggle == SoundToggleType.ToggleMusic)
		{
			OnToggleMusic();
		}
		else
		{
			OnToggleSound();
		}
		return base.OnSelect(obj);
	}

	private void OnToggleMusic()
	{
		SoundSettingsEventType item = ((!SoundManager.MusicMuted) ? SoundSettingsEventType.MuteMusic : SoundSettingsEventType.UnmuteMusic);
		SettingsScreen.SoundSettingsSignal.Dispatch(item);
		SettingsScreen.SoundSettingsSignal.Dispatch(SoundSettingsEventType.SavePersistantSettings);
		UpdateButtonState();
	}

	private void OnToggleSound()
	{
		SoundSettingsEventType item = ((!SoundManager.SoundsMuted) ? SoundSettingsEventType.MuteSounds : SoundSettingsEventType.UnmuteSounds);
		SettingsScreen.SoundSettingsSignal.Dispatch(item);
		SettingsScreen.SoundSettingsSignal.Dispatch(SoundSettingsEventType.SavePersistantSettings);
		UpdateButtonState();
	}

	public override void OnStartGaze()
	{
		if (infoText == null)
		{
			UnityEngine.Debug.LogWarning(base.transform.name + " doesn't have info link text assigned in the inspector");
			return;
		}
		infoText.text = infoTextString;
		infoText.gameObject.SetActive(value: true);
		infoTextLocalization.PopulateText(forceUpdate: true);
	}

	public override void OnStopGaze()
	{
		if (infoText == null)
		{
			UnityEngine.Debug.LogWarning(base.transform.name + " doesn't have info link text assigned in the inspector");
		}
		else
		{
			infoText.gameObject.SetActive(value: false);
		}
	}
}
[Serializable]
public class BuyBaitCondition : QuestCondition
{
	public BaitType BaitType { get; private set; }

	public BuyBaitCondition(BaitType baitType)
	{
		base.CurrentProgress = 0;
		base.RequiredProgress = 1;
		BaitType = baitType;
	}

	public override void OnBuyBait(BaitType baitType)
	{
		base.CurrentProgress++;
	}
}
[Serializable]
public class BuyBobberCondition : QuestCondition
{
	public BobberType BobberType { get; private set; }

	public BuyBobberCondition(BobberType bobberType)
	{
		BobberType = bobberType;
		base.RequiredProgress = 1;
		base.CurrentProgress = 0;
	}

	public override void OnBuyBobber(BobberType bobberType)
	{
		if (bobberType == BobberType)
		{
			base.CurrentProgress++;
		}
	}
}
[Serializable]
public class BuyReelCondition : QuestCondition
{
	public ReelType ReelType { get; private set; }

	public BuyReelCondition(ReelType reelType)
	{
		ReelType = reelType;
		base.RequiredProgress = 1;
		base.CurrentProgress = 0;
	}

	public override void OnBuyReel(ReelType reelType)
	{
		if (reelType == ReelType)
		{
			base.CurrentProgress++;
		}
	}
}
[Serializable]
public class BuyRodCondition : QuestCondition
{
	public RodType RodType { get; private set; }

	public BuyRodCondition(RodType rodType)
	{
		RodType = rodType;
		base.RequiredProgress = 1;
		base.CurrentProgress = 0;
	}

	public override void OnBuyRod(RodType rodType)
	{
		if (rodType == RodType)
		{
			base.CurrentProgress++;
		}
	}
}
[Serializable]
public class CatchAllCondition : QuestCondition
{
	private FishType[] allOriginlFish = new FishType[43]
	{
		FishType.AlligatorPerch,
		FishType.AutumnChar,
		FishType.BlindHaddock,
		FishType.CowKoi,
		FishType.PythonEel,
		FishType.GhostPerch,
		FishType.GlowstickTetra,
		FishType.GroovyGourami,
		FishType.LeopardCatfish,
		FishType.PunkPike,
		FishType.ImperialSalmon,
		FishType.SkullBass,
		FishType.TrashBoot,
		FishType.TrashBeercan1,
		FishType.TrashBeercan2,
		FishType.ParrotPerch,
		FishType.TinyWhite,
		FishType.ZebraTuna,
		FishType.HodRodCuda,
		FishType.MandarinTang,
		FishType.DiamondMudray,
		FishType.ChiliAnchovy,
		FishType.HarlequinnFish,
		FishType.PinstripePerch,
		FishType.PoisonDartMinnow,
		FishType.CamoKoi,
		FishType.SparklingTrout,
		FishType.LavaStoneFish,
		FishType.SumoBlowfish,
		FishType.Clownfish,
		FishType.CopperTopEel,
		FishType.BullPiranah,
		FishType.KahunaTuna,
		FishType.PickledHerring,
		FishType.RabidGuppy,
		FishType.GoatHeadFish,
		FishType.GoldenCrackerFish,
		FishType.TattooFish,
		FishType.GrimAnglerFish,
		FishType.PigskinPufferFish,
		FishType.PrehistoricPerch,
		FishType.SunAndMoonFish,
		FishType.KnifeFish
	};

	public CatchAllCondition()
	{
		base.RequiredProgress = 1;
		base.CurrentProgress = 0;
	}

	public override void OnCatchFishSignal(Fish fish, Inventory inventory)
	{
		bool flag = true;
		for (int i = 0; i < allOriginlFish.Length; i++)
		{
			if (allOriginlFish[i] != fish.FishData.fishType && !inventory.FishRecords.ContainsKey(allOriginlFish[i]))
			{
				flag = false;
			}
		}
		if (flag)
		{
			base.CurrentProgress++;
		}
	}
}
[Serializable]
public class ChatAndCloseCondition : QuestCondition
{
	public string DialogId { get; private set; }

	public ChatAndCloseCondition(string dialogId)
	{
		DialogId = dialogId;
		base.RequiredProgress = 2;
	}

	public override void OnDialogEnd(string dialogId)
	{
		if (dialogId == DialogId)
		{
			base.CurrentProgress = 1;
		}
	}

	public override void OnFishODexClose()
	{
		base.CurrentProgress++;
	}
}
[Serializable]
public class ChatCondition : QuestCondition
{
	public string DialogId { get; private set; }

	public ChatCondition(string dialogId)
	{
		DialogId = dialogId;
		base.RequiredProgress = 1;
	}

	public override void OnDialogEnd(string dialogId)
	{
		if (dialogId == DialogId)
		{
			base.CurrentProgress++;
		}
	}
}
[Serializable]
public class DialogCondition : QuestCondition
{
	public string DialogId { get; private set; }

	public DialogCondition(string dialogId)
	{
		DialogId = dialogId;
		base.RequiredProgress = 1;
	}

	public override void OnDialogEnd(string dialogId)
	{
		if (dialogId == DialogId)
		{
			base.CurrentProgress++;
		}
	}
}
[Serializable]
public class FishCondition : QuestCondition
{
	public FishType FishType { get; private set; }

	public FishStar StarRating { get; private set; }

	public string RequiredScene { get; private set; }

	public FishCondition(FishType fishType, FishStar starRequirement, int requiredProgress, string requiredScene)
	{
		FishType = fishType;
		StarRating = starRequirement;
		base.RequiredProgress = requiredProgress;
		RequiredScene = requiredScene;
		base.CurrentProgress = 0;
	}

	public override void OnCatchFishSignal(Fish fish, Inventory inventory)
	{
		string name = SceneManager.GetActiveScene().name;
		if (!(name != RequiredScene) || !(RequiredScene != string.Empty))
		{
			if (FishType == FishType.None && fish.FishData.GetStarRating(fish.weight) >= StarRating)
			{
				base.CurrentProgress++;
			}
			else if (FishType == fish.FishData.fishType && fish.FishData.GetStarRating(fish.weight) >= StarRating)
			{
				base.CurrentProgress++;
			}
		}
	}
}
public class Mission
{
	public struct MissionPart
	{
		public string QuestId;

		public string Text;

		public static MissionPart empty => new MissionPart(string.Empty, string.Empty);

		public MissionPart(string questId, string text)
		{
			QuestId = questId;
			Text = text;
		}

		public bool IsEmpty()
		{
			return QuestId == string.Empty && Text == string.Empty;
		}
	}

	public static readonly Mission Empty = new Mission(0, new MissionPart[0]);

	public bool[] CompletedTasks;

	public int MissionNumber { get; private set; }

	public MissionPart[] Parts { get; private set; }

	public bool MissionCompleted { get; private set; }

	public Mission(int missionNumber, MissionPart[] parts)
	{
		MissionNumber = missionNumber;
		Parts = parts;
		MissionCompleted = false;
		CompletedTasks = new bool[Parts.Length];
	}

	public void SetMissionCompleted()
	{
		MissionCompleted = true;
		for (int i = 0; i < CompletedTasks.Length; i++)
		{
			CompletedTasks[i] = true;
		}
	}

	public void SetQuestCompleted(QuestState state)
	{
		for (int i = 0; i < Parts.Length; i++)
		{
			if (!(Parts[i].QuestId == state.Id))
			{
				continue;
			}
			CompletedTasks[i] = true;
			for (int j = 0; j < CompletedTasks.Length; j++)
			{
				if (!CompletedTasks[j])
				{
					return;
				}
			}
			MissionCompleted = true;
			break;
		}
	}

	public bool ContainsQuest(QuestState state)
	{
		for (int i = 0; i < Parts.Length; i++)
		{
			if (Parts[i].QuestId == state.Id)
			{
				return true;
			}
		}
		return false;
	}

	public MissionPart GetMissionPartForQuest(QuestState state)
	{
		for (int i = 0; i < Parts.Length; i++)
		{
			if (Parts[i].QuestId == state.Id)
			{
				return Parts[i];
			}
		}
		return MissionPart.empty;
	}

	public MissionPart GetUpcomingMissionPart(QuestState state)
	{
		for (int i = 0; i < Parts.Length; i++)
		{
			if (Parts[i].QuestId == state.Id)
			{
				if (i + 1 < Parts.Length)
				{
					return Parts[i + 1];
				}
				return MissionPart.empty;
			}
		}
		return MissionPart.empty;
	}

	public MissionPart GetPreviousMissionPart(QuestState state)
	{
		for (int i = 0; i < Parts.Length; i++)
		{
			if (Parts[i].QuestId == state.Id)
			{
				if (i > 0)
				{
					return Parts[i - 1];
				}
				return MissionPart.empty;
			}
		}
		return MissionPart.empty;
	}

	public void MarkQuestsAsCompletedUpTo(QuestState state)
	{
		for (int i = 0; i < Parts.Length && !(Parts[i].QuestId == state.Id); i++)
		{
			CompletedTasks[i] = true;
			if (i == Parts.Length - 1)
			{
				MissionCompleted = true;
			}
		}
	}

	public void Reset()
	{
		MissionCompleted = false;
		for (int i = 0; i < Parts.Length; i++)
		{
			CompletedTasks[i] = false;
		}
	}
}
[Serializable]
public class MoneyCondition : QuestCondition
{
	public MoneyCondition(int requiredMount)
	{
		base.RequiredProgress = requiredMount;
		base.CurrentProgress = 0;
	}

	public override void OnCatchFishSignal(Fish fish, Inventory inventory)
	{
		base.CurrentProgress += fish.FishData.worth;
	}
}
[Serializable]
public class NavigationCondition : QuestCondition
{
	public string SceneName { get; private set; }

	public NavigationCondition(string sceneName)
	{
		SceneName = sceneName;
		base.RequiredProgress = 1;
	}

	public override void OnEnterGamePlayScene(string sceneName)
	{
		if (SceneName == sceneName)
		{
			base.CurrentProgress++;
		}
	}
}
public class Quest
{
	private DialogEndEvent dialogEndSignal;

	private Dictionary<string, QuestState> states;

	private string questFilePath = "Quest/QuestLine";

	private InventoryManager inventoryManager;

	private string startStateId = "Intro01";

	private RGTracking tracking;

	public Signal<QuestState> EnterQuestStateSignal { get; private set; }

	public Signal<QuestState> ExitQuestStateSignal { get; private set; }

	public QuestState CurrentState { get; private set; }

	public Mission[] Missions { get; private set; }

	public Mission CurrentMission
	{
		get
		{
			int activeMissionIndex = GetActiveMissionIndex();
			if (activeMissionIndex == -1)
			{
				return Mission.Empty;
			}
			return Missions[activeMissionIndex];
		}
	}

	public Quest(DialogEndEvent dialogEndEvent, InventoryManager inventoryManager, RGTracking tracking)
	{
		EnterQuestStateSignal = new Signal<QuestState>();
		ExitQuestStateSignal = new Signal<QuestState>();
		dialogEndSignal = dialogEndEvent;
		this.inventoryManager = inventoryManager;
		this.tracking = tracking;
		SinkerCasting.CatchFishSignal.AddListener(OnCatchFishSignal);
		CatchDisplay.CatchDisplaySignal.AddListener(OnCatchDisplaySignal);
		Tutorial.StateChangeSignal.AddListener(OnTutorialSignal);
		dialogEndSignal.AddListener(OnDialogEnd);
		BuyableItem.BuyableItemSignal.AddListener(OnBuyItem);
		FishODexCloseButton.SelectSignal.AddListener(OnFishODexClose);
		EnterGamePlayScene.Enter.AddListener(OnEnterGamePlayScene);
		states = new Dictionary<string, QuestState>();
		ParseQuestData();
	}

	public bool IsInIntroState()
	{
		return CurrentState != null && CurrentState.Id == startStateId;
	}

	public bool IsInBeachTutorialState()
	{
		return CurrentState != null && (CurrentState.Id == "Tutorial01" || CurrentState.Id == "Tutorial02" || CurrentState.Id == "Tutorial03");
	}

	public bool ShouldInputSwitchWork()
	{
		return CurrentState == null || (!(CurrentState.Id == startStateId) && !(CurrentState.Id == "Tutorial01") && !(CurrentState.Id == "Tutorial02"));
	}

	public float GetProgress(QuestState questState)
	{
		if (questState == null)
		{
			return 0f;
		}
		return (float)questState.StateNumber / (float)states.Count;
	}

	private void ParseQuestData()
	{
		CSVTable cSVTable = new CSVTable();
		cSVTable.LoadFromResources(questFilePath);
		for (int i = 0; i < cSVTable.NumRows; i++)
		{
			try
			{
				QuestState questState = CreateState(cSVTable.GetRow(i), i);
				states.Add(questState.Id, questState);
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError("Failed to create quest state: " + ex.Message);
			}
		}
		CreateMissions(cSVTable);
	}

	public void InitializeQuest(RGSession session)
	{
		if (session != null)
		{
			int currentProgress = session.QuestState.Condition.CurrentProgress;
			bool hasNotification = session.QuestState.HasNotification;
			QuestState questState = states[session.QuestState.Id];
			questState.Condition.CurrentProgress = currentProgress;
			questState.HasNotification = hasNotification;
			CurrentState = questState;
		}
		else
		{
			CurrentState = states[startStateId];
		}
		SyncMissionCompletedStatus();
	}

	public void Reset()
	{
		CurrentState = null;
		states = new Dictionary<string, QuestState>();
		ParseQuestData();
	}

	private void CreateMissions(CSVTable csv)
	{
		Dictionary<int, List<Mission.MissionPart>> dictionary = new Dictionary<int, List<Mission.MissionPart>>();
		List<int> list = new List<int>();
		Mission.MissionPart item = default(Mission.MissionPart);
		for (int i = 0; i < csv.NumRows; i++)
		{
			if (csv.GetRow(i).NotEmpty("MissionNumber") && csv.GetRow(i).NotEmpty("MissionTask"))
			{
				int columnInt = csv.GetRow(i).GetColumnInt("MissionNumber");
				string column = csv.GetRow(i).GetColumn("MissionTask");
				string column2 = csv.GetRow(i).GetColumn("State");
				item.QuestId = column2;
				item.Text = column;
				if (!dictionary.ContainsKey(columnInt))
				{
					dictionary.Add(columnInt, new List<Mission.MissionPart>());
				}
				dictionary[columnInt].Add(item);
				if (list.Count == 0 || list[list.Count - 1] != columnInt)
				{
					list.Add(columnInt);
				}
			}
		}
		Missions = new Mission[list.Count];
		for (int j = 0; j < list.Count; j++)
		{
			int num = list[j];
			Missions[j] = new Mission(num, dictionary[num].ToArray());
		}
	}

	private QuestState CreateState(CSVTable.Row csvRow, int stateNumber)
	{
		string column = csvRow.GetColumn(0);
		string column2 = csvRow.GetColumn(1);
		int columnInt = csvRow.GetColumnInt(2);
		string column3 = csvRow.GetColumn(3);
		bool columnBool = csvRow.GetColumnBool(4);
		FishStar starRequirement = ((!csvRow.HasValue(5)) ? FishStar.One : ((FishStar)csvRow.GetColumnInt(5)));
		string column4 = csvRow.GetColumn(6);
		string column5 = csvRow.GetColumn(7);
		string column6 = csvRow.GetColumn(8);
		string column7 = csvRow.GetColumn(9);
		Location licenseReward = (csvRow.HasValue(10) ? ((Location)Enum.Parse(typeof(Location), csvRow.GetColumn(10))) : Location.None);
		string column8 = csvRow.GetColumn(11);
		return new QuestState(column, stateNumber, column8, column2 switch
		{
			"Fish" => new FishCondition(EnumHelper.GetEnumByName<FishType>(column3), starRequirement, columnInt, column4), 
			"Dialog" => new DialogCondition(column3), 
			"Money" => new MoneyCondition(columnInt), 
			"Navigation" => new NavigationCondition(column3), 
			"Chat" => new ChatCondition(column3), 
			"ChatAndClose" => new ChatAndCloseCondition(column3), 
			"BuyRod" => new BuyRodCondition(EnumHelper.GetEnumByName<RodType>(column3)), 
			"Trash" => new TrashCondition(columnInt, column4), 
			"BuyBobber" => new BuyBobberCondition(EnumHelper.GetEnumByName<BobberType>(column3)), 
			"BuyReel" => new BuyReelCondition(EnumHelper.GetEnumByName<ReelType>(column3)), 
			"BuyBait" => new BuyBaitCondition(EnumHelper.GetEnumByName<BaitType>(column3)), 
			"Tutorial" => new TutorialCondition(), 
			"CatchAll" => new CatchAllCondition(), 
			_ => throw new Exception("No ConditionType of type: " + csvRow.GetColumn(1) + " could be found."), 
		}, columnBool, column5, column7, column6, licenseReward);
	}

	private void OnCatchFishSignal(Fish fish, GameObject fishGO)
	{
		if (fish != null)
		{
			CurrentState.Condition.OnCatchFishSignal(fish, inventoryManager.Inventory);
		}
	}

	private void OnDialogEnd(string dialogId)
	{
		CurrentState.Condition.OnDialogEnd(dialogId);
		CheckProgress();
	}

	private void OnBuyItem(string itemId, BuyableItemEventType eventType, BuyableItem.ItemType itemType)
	{
		if (eventType == BuyableItemEventType.ItemPurchased)
		{
			switch (itemType)
			{
			case BuyableItem.ItemType.Rod:
				CurrentState.Condition.OnBuyRod(EnumHelper.GetEnumByName<RodType>(itemId));
				break;
			case BuyableItem.ItemType.Reel:
				CurrentState.Condition.OnBuyReel(EnumHelper.GetEnumByName<ReelType>(itemId));
				break;
			case BuyableItem.ItemType.Bobber:
				CurrentState.Condition.OnBuyBobber(EnumHelper.GetEnumByName<BobberType>(itemId));
				break;
			case BuyableItem.ItemType.Bait:
				CurrentState.Condition.OnBuyBait(EnumHelper.GetEnumByName<BaitType>(itemId));
				break;
			}
			CheckProgress();
		}
	}

	private void OnCatchDisplaySignal(CatchDisplayEventType type)
	{
		if (type == CatchDisplayEventType.Hide)
		{
			CheckProgress();
		}
	}

	private void OnEnterGamePlayScene(string sceneName)
	{
		if (CurrentState != null)
		{
			CurrentState.Condition.OnEnterGamePlayScene(sceneName);
			CheckProgress();
		}
	}

	private void OnTutorialSignal(TutorialStateType eventType)
	{
		if (eventType == TutorialStateType.End)
		{
			CurrentState.Condition.OnTutorialEnd();
			CheckProgress();
		}
	}

	private void OnFishODexClose()
	{
		if (CurrentState != null)
		{
			CurrentState.Condition.OnFishODexClose();
			CheckProgress();
		}
	}

	private void CheckProgress()
	{
		if (CurrentState.Condition.IsFullfilled)
		{
			GoToNextState();
		}
	}

	public void GoToNextState()
	{
		tracking.TrackQuestCompleted(CurrentState, inventoryManager);
		if (!states.TryGetValue(CurrentState.NextStateId, out var value))
		{
			throw new KeyNotFoundException("Cannot find QuestState with id: " + CurrentState.NextStateId);
		}
		if (CurrentState.LicenseReward != 0)
		{
			inventoryManager.Inventory.Licenses.Add(CurrentState.LicenseReward);
		}
		ExitQuestStateSignal.Dispatch(CurrentState);
		OnQuestCompleted(CurrentState);
		SetCurrentState(value);
		EnterQuestStateSignal.Dispatch(CurrentState);
	}

	private void OnQuestCompleted(QuestState state)
	{
		int num = Missions.Length;
		for (int i = 0; i < num; i++)
		{
			if (Missions[i].ContainsQuest(state))
			{
				Missions[i].SetQuestCompleted(state);
				break;
			}
		}
	}

	private void SetCurrentState(QuestState state)
	{
		CurrentState = state;
		bool flag = true;
		int activeMissionIndex = GetActiveMissionIndex();
		if (activeMissionIndex <= -1)
		{
			return;
		}
		for (int i = 0; i < activeMissionIndex; i++)
		{
			if (Missions[i].ContainsQuest(state))
			{
				flag = false;
			}
			if (flag)
			{
				Missions[i].SetMissionCompleted();
			}
		}
	}

	public int GetActiveMissionIndex()
	{
		if (CurrentState == null)
		{
			return -1;
		}
		for (int i = 0; i < Missions.Length; i++)
		{
			if (Missions[i].ContainsQuest(CurrentState))
			{
				return i;
			}
		}
		return -1;
	}

	public QuestState GetStateFromId(string id)
	{
		if (states.ContainsKey(id))
		{
			return states[id];
		}
		return null;
	}

	public void SyncMissionCompletedStatus()
	{
		int num = -1;
		if (CurrentState != null)
		{
			for (int i = 0; i < Missions.Length; i++)
			{
				if (Missions[i].ContainsQuest(CurrentState))
				{
					num = i;
					break;
				}
			}
		}
		for (int j = 0; j < Missions.Length; j++)
		{
			if (j <= num)
			{
				Missions[j].MarkQuestsAsCompletedUpTo(CurrentState);
			}
			else
			{
				Missions[j].Reset();
			}
		}
	}
}
public class QuestCheat : MonoBehaviour
{
	public KeyCode cheatKey = KeyCode.Q;

	public KeyCode addMoneyKey = KeyCode.M;

	[@Dependency]
	public Quest quest { get; set; }

	[@Dependency]
	public InventoryManager InventoryManager { get; set; }

	[@Dependency]
	public Localization localization { get; set; }

	private void Awake()
	{
		this.Inject();
	}
}
[Serializable]
public abstract class QuestCondition
{
	public int RequiredProgress { get; protected set; }

	public int CurrentProgress { get; set; }

	public bool IsFullfilled => CurrentProgress >= RequiredProgress;

	public virtual void OnCatchFishSignal(Fish fish, Inventory inventory)
	{
	}

	public virtual void OnDialogEnd(string dialogId)
	{
	}

	public virtual void OnEnterGamePlayScene(string sceneName)
	{
	}

	public virtual void OnBuyRod(RodType rodType)
	{
	}

	public virtual void OnBuyBobber(BobberType bobberType)
	{
	}

	public virtual void OnBuyReel(ReelType reelType)
	{
	}

	public virtual void OnTutorialEnd()
	{
	}

	public virtual void OnFishODexClose()
	{
	}

	public virtual void OnBuyBait(BaitType baitType)
	{
	}
}
[Serializable]
public class QuestState
{
	public string Id { get; private set; }

	public int StateNumber { get; private set; }

	public QuestCondition Condition { get; private set; }

	public bool HasNotification { get; set; }

	public string ShopKeeper01Dialog { get; private set; }

	public string ShopKeeper02Dialog { get; private set; }

	public string ChatDialog { get; private set; }

	public Location LicenseReward { get; private set; }

	public string NextStateId { get; private set; }

	public QuestState(string stateId, int stateNumber, string nextStateId, QuestCondition condition, bool hasNotification, string shopKeeper01Dialog, string shopKeeper02Dialog, string chatDialog, Location licenseReward)
	{
		Id = stateId;
		StateNumber = stateNumber;
		Condition = condition;
		HasNotification = hasNotification;
		NextStateId = nextStateId;
		ShopKeeper01Dialog = shopKeeper01Dialog;
		ShopKeeper02Dialog = shopKeeper02Dialog;
		ChatDialog = chatDialog;
		LicenseReward = licenseReward;
	}
}
[Serializable]
public class TrashCondition : QuestCondition
{
	public string RequiredScene { get; private set; }

	public TrashCondition(int requiredProgress, string requiredScene)
	{
		base.CurrentProgress = 0;
		base.RequiredProgress = requiredProgress;
		RequiredScene = requiredScene;
	}

	public override void OnCatchFishSignal(Fish fish, Inventory inventory)
	{
		if (SceneManager.GetActiveScene().name == RequiredScene && FishIsTrash(fish.FishData.fishType))
		{
			base.CurrentProgress++;
		}
	}

	private bool FishIsTrash(FishType fishType)
	{
		return fishType == FishType.TrashBeercan1 || fishType == FishType.TrashBeercan2 || fishType == FishType.TrashBoot;
	}
}
public enum TutorialStateType
{
	GrabRod,
	Throw,
	WaitForAttraction,
	FishFight,
	FailReelin,
	GrabFish,
	CatchFishByYourSelf,
	CatchFishForMoney,
	End
}
public class Tutorial : MonoBehaviour
{
	private abstract class TutorialState
	{
		public virtual void Enter(Tutorial tutorial)
		{
		}

		public virtual void Update(Tutorial tutorial)
		{
		}

		public virtual void Exit(Tutorial tutorial)
		{
		}
	}

	private class GrabRodState : TutorialState
	{
		public override void Enter(Tutorial tutorial)
		{
			StateChangeSignal.Dispatch(TutorialStateType.GrabRod);
			tutorial.ShowRod();
			tutorial.FishingRodSignal.AddListener(tutorial.OnFishingRodSignal);
			if (tutorial.IsControllerActive())
			{
				tutorial.StartCoroutine(tutorial.SpawnSpeechbubbleDialogWindow("Tutorial05BeachDD"));
				if (tutorial.GetUseSecondaryimage())
				{
					tutorial.StartImageReel(tutorial.grabInput);
				}
				else
				{
					tutorial.StartImageReel(tutorial.grabInput);
				}
			}
			else
			{
				tutorial.StartCoroutine(tutorial.SpawnSpeechbubbleDialogWindow("Tutorial05Beach"));
				tutorial.StartImageReel(tutorial.grabInput);
			}
		}

		public override void Exit(Tutorial tutorial)
		{
			tutorial.FishingRodSignal.RemoveListener(tutorial.OnFishingRodSignal);
			tutorial.StopImageReel();
		}
	}

	private class ThrowState : TutorialState
	{
		public override void Enter(Tutorial tutorial)
		{
			StateChangeSignal.Dispatch(TutorialStateType.Throw);
			Bobber.bobberHitWaterSignal.AddListener(tutorial.CheckTargetAreaHit);
			if (tutorial.IsControllerActive())
			{
				tutorial.StartCoroutine(tutorial.SpawnSpeechbubbleDialogWindow("Tutorial10BeachDD"));
				if (tutorial.GetUseSecondaryimage())
				{
					tutorial.StartImageReel(tutorial.throwImageReelSecondary);
				}
				else
				{
					tutorial.StartImageReel(tutorial.throwImageReelController);
				}
			}
			else
			{
				tutorial.StartCoroutine(tutorial.SpawnSpeechbubbleDialogWindow("Tutorial10Beach"));
				tutorial.StartImageReel(tutorial.throwImageReelGaze);
			}
			tutorial.SpawnTargetArea();
		}

		public override void Exit(Tutorial tutorial)
		{
			tutorial.StopImageReel();
			Bobber.bobberHitWaterSignal.RemoveListener(tutorial.CheckTargetAreaHit);
		}
	}

	private class FailReelInState : TutorialState
	{
		public override void Enter(Tutorial tutorial)
		{
			StateChangeSignal.Dispatch(TutorialStateType.FailReelin);
			if (tutorial.IsControllerActive())
			{
				tutorial.DialogSpeechbubbleStartSignal.Dispatch("Tutorial20BeachDD");
				FishingLine.ReelInDoneSignal.AddListener(tutorial.CompleteReelInFail);
				if (tutorial.GetUseSecondaryimage())
				{
					tutorial.StartImageReel(tutorial.reelInImageReelSecondary);
				}
				else
				{
					tutorial.StartImageReel(tutorial.reelInImageReelController);
				}
			}
			else
			{
				tutorial.DialogSpeechbubbleStartSignal.Dispatch("Tutorial20Beach");
				FishingLine.ReelInDoneSignal.AddListener(tutorial.CompleteReelInFail);
				tutorial.StartImageReel(tutorial.reelInImageReelGaze);
			}
			UnityEngine.Object.Destroy(tutorial.targetArea);
			base.Enter(tutorial);
		}

		public override void Exit(Tutorial tutorial)
		{
			tutorial.StopImageReel();
			FishingLine.ReelInDoneSignal.RemoveListener(tutorial.CompleteReelInFail);
			base.Exit(tutorial);
		}
	}

	private class WaitForFishAttractionState : TutorialState
	{
		public override void Enter(Tutorial tutorial)
		{
			StateChangeSignal.Dispatch(TutorialStateType.WaitForAttraction);
			Update(tutorial);
			FishBehavior.FishSignal.AddListener(tutorial.OnFishAttraction);
			tutorial.StartImageReel(tutorial.fishAttractionReel);
			UnityEngine.Object.Destroy(tutorial.targetArea);
			tutorial.SpawnTutorialFish();
		}

		public override void Update(Tutorial tutorial)
		{
			if (tutorial.IsControllerActive())
			{
				tutorial.DialogSpeechbubbleStartSignal.Dispatch("Tutorial30BeachDD");
			}
			else
			{
				tutorial.DialogSpeechbubbleStartSignal.Dispatch("Tutorial30Beach");
			}
		}

		public override void Exit(Tutorial tutorial)
		{
			FishBehavior.FishSignal.RemoveListener(tutorial.OnFishAttraction);
			tutorial.StopImageReel();
		}
	}

	private class FishFightState : TutorialState
	{
		public override void Enter(Tutorial tutorial)
		{
			FishBehavior.FishSignal.AddListener(tutorial.OnFishAttraction);
			tutorial.StartImageReel(tutorial.reelInImageReelController);
			if (tutorial.IsControllerActive())
			{
				tutorial.StartCoroutine(tutorial.SpawnSpeechbubbleDialogWindow("Tutorial60BeachDD"));
				CatchDisplay.CatchDisplaySignal.AddListener(tutorial.OnCatchDisplaySignal);
			}
			else
			{
				tutorial.StartCoroutine(tutorial.SpawnSpeechbubbleDialogWindow("Tutorial60Beach"));
				CatchDisplay.CatchDisplaySignal.AddListener(tutorial.OnCatchDisplaySignal);
				tutorial.StartImageReel(tutorial.reelInImageReelGaze);
			}
		}

		public override void Exit(Tutorial tutorial)
		{
			CatchDisplay.CatchDisplaySignal.RemoveListener(tutorial.OnCatchDisplaySignal);
			FishBehavior.FishSignal.RemoveListener(tutorial.OnFishAttraction);
			tutorial.StopImageReel();
		}
	}

	private class GrabFishState : TutorialState
	{
		public override void Enter(Tutorial tutorial)
		{
			if (tutorial.IsControllerActive())
			{
				tutorial.StartCoroutine(tutorial.SpawnSpeechbubbleDialogWindow("Tutorial65BeachDD"));
				CatchDisplay.CatchDisplaySignal.AddListener(tutorial.OnCatchDisplaySignal);
				if (tutorial.GetUseSecondaryimage())
				{
					tutorial.StartImageReel(tutorial.grabInput);
				}
				else
				{
					tutorial.StartImageReel(tutorial.grabInput);
				}
			}
			else
			{
				tutorial.StartCoroutine(tutorial.SpawnSpeechbubbleDialogWindow("Tutorial65Beach"));
				CatchDisplay.CatchDisplaySignal.AddListener(tutorial.OnCatchDisplaySignal);
				tutorial.StartImageReel(tutorial.grabInput);
			}
		}

		public override void Exit(Tutorial tutorial)
		{
			CatchDisplay.CatchDisplaySignal.RemoveListener(tutorial.OnCatchDisplaySignal);
			FishBehavior.FishSignal.RemoveListener(tutorial.OnFishAttraction);
			tutorial.StopImageReel();
		}
	}

	private class CatchFishByYourselfState : TutorialState
	{
		public override void Enter(Tutorial tutorial)
		{
			StateChangeSignal.Dispatch(TutorialStateType.CatchFishByYourSelf);
			Bobber.bobberHitWaterSignal.AddListener(tutorial.ContinueFishing);
			TensionMeter.TensionMeterSignal.AddListener(tutorial.OnTensionMeterSignal);
			tutorial.StartCoroutine(tutorial.SpawnSpeechbubbleDialogWindow("Tutorial70Beach"));
			tutorial.StartImageReel(tutorial.catchOneImageReel);
		}

		public override void Exit(Tutorial tutorial)
		{
			tutorial.StopImageReel();
			Bobber.bobberHitWaterSignal.RemoveListener(tutorial.ContinueFishing);
			TensionMeter.TensionMeterSignal.RemoveListener(tutorial.OnTensionMeterSignal);
		}
	}

	private class GetMoneyState : TutorialState
	{
		public override void Enter(Tutorial tutorial)
		{
			StateChangeSignal.Dispatch(TutorialStateType.CatchFishForMoney);
			tutorial.StartCoroutine(tutorial.SpawnSpeechbubbleDialogWindow("Tutorial80Beach"));
			Bobber.bobberHitWaterSignal.AddListener(tutorial.ContinueFishing);
			TensionMeter.TensionMeterSignal.AddListener(tutorial.OnTensionMeterSignal);
			tutorial.StartImageReel(tutorial.fishForMoneyImageReel);
		}

		public override void Exit(Tutorial tutorial)
		{
			tutorial.StopImageReel();
			Bobber.bobberHitWaterSignal.RemoveListener(tutorial.ContinueFishing);
			TensionMeter.TensionMeterSignal.RemoveListener(tutorial.OnTensionMeterSignal);
		}
	}

	private class OutroState : TutorialState
	{
		public override void Enter(Tutorial tutorial)
		{
			StateChangeSignal.Dispatch(TutorialStateType.End);
			tutorial.gameObject.SetActive(value: false);
		}
	}

	public static Signal<TutorialStateType> StateChangeSignal = new Signal<TutorialStateType>();

	public static Signal<FishingRodEventType> RodSignal = new Signal<FishingRodEventType>();

	public Sprite[] grabInput;

	[FormerlySerializedAs("throwImageReel")]
	public Sprite[] throwImageReelController;

	[FormerlySerializedAs("reelInImageReel")]
	public Sprite[] reelInImageReelController;

	public Sprite[] fishAttractionReel;

	public Sprite[] fishHookReel;

	[FormerlySerializedAs("fishGotAwayImageReel")]
	public Sprite[] fishGotAwayImageReelController;

	public Sprite[] catchOneImageReel;

	public Sprite[] fishForMoneyImageReel;

	public Sprite[] throwImageReelGaze;

	public Sprite[] reelInImageReelGaze;

	public Sprite[] fishGotAwayImageReelGaze;

	public Sprite[] throwImageReelSecondary;

	public Sprite[] reelInImageReelSecondary;

	public Sprite[] fishGotAwayImageReelSecondary;

	public GameObject TutorialDialogPrefab;

	public GameObject TargetAreaPrefab;

	public FishType tutorialFishType = FishType.MandarinTang;

	public float dialogRemovalDelay = 3f;

	public float tensionMeterHintRemovalDelay = 10f;

	public float imageReelDelay = 0.3f;

	public Camera centerCamera;

	private GameObject tutorialDialog;

	private GameObject targetArea;

	private List<GameObject> tutorialFish;

	private Vector3 targetAreaPosition = new Vector3(0.3f, 0f, 9f);

	private GameObject tutorialFishMoveTarget;

	private IEnumerator imageReelCorotine;

	private TutorialState currentState;

	private GrabRodState grabRodState;

	private ThrowState throwState;

	private FailReelInState failReelInState;

	private WaitForFishAttractionState waitForFishAttractionState;

	private FishFightState fishFightState;

	private GrabFishState grabFishState;

	private CatchFishByYourselfState catchFishByYourSelfState;

	private GetMoneyState getMoneyState;

	private OutroState outroState;

	private bool tensionMeterActive;

	[@Dependency]
	public Quest Quest { get; set; }

	[@Dependency]
	public DialogSpeechbubbleStartEvent DialogSpeechbubbleStartSignal { get; set; }

	[@Dependency]
	public DialogChatStartEvent DialogChatStartSignal { get; set; }

	[@Dependency]
	public RGTracking tracking { get; set; }

	[@Dependency]
	public InputModeSwitchEvent GearVRInputSwitchSignal { get; set; }

	[@Dependency]
	public FishingRodEvent FishingRodSignal { get; set; }

	[@Dependency]
	public InputManager input { get; set; }

	private void Start()
	{
		this.Inject();
		grabRodState = new GrabRodState();
		throwState = new ThrowState();
		failReelInState = new FailReelInState();
		waitForFishAttractionState = new WaitForFishAttractionState();
		fishFightState = new FishFightState();
		grabFishState = new GrabFishState();
		catchFishByYourSelfState = new CatchFishByYourselfState();
		getMoneyState = new GetMoneyState();
		outroState = new OutroState();
		centerCamera = Camera.main;
		tutorialDialog = UnityEngine.Object.Instantiate(TutorialDialogPrefab, base.transform.position, Quaternion.LookRotation(base.transform.position - centerCamera.transform.position));
		tutorialDialog.transform.parent = base.transform;
		tutorialDialog.SetActive(value: false);
		Quest.EnterQuestStateSignal.AddListener(OnEnterQuestState);
		GearVRInputSwitchSignal.AddListener(OnActiveControllerChanged);
		CheckQuestState(Quest.CurrentState);
	}

	private void OnActiveControllerChanged(InputMode type)
	{
		if (tensionMeterActive)
		{
			TensionMeter.TensionMeterSignal.Dispatch(TensionMeter.TensionMeterEventType.Full);
		}
		else if (currentState != null && tutorialDialog.activeSelf && !tensionMeterActive)
		{
			if (currentState.GetType() == typeof(WaitForFishAttractionState))
			{
				currentState.Update(this);
			}
			else
			{
				ChangeTutorialState(currentState);
			}
		}
	}

	private bool IsControllerActive()
	{
		return input.GetInputMode() != InputMode.Headset;
	}

	private void ChangeTutorialState(TutorialState newState)
	{
		if (currentState != null)
		{
			currentState.Exit(this);
		}
		currentState = newState;
		string text = newState.ToString();
		text = text.Replace('+', '_').Replace("State", string.Empty).Replace("Tutorial", "tut");
		if (14 + text.Length > 32)
		{
			text = text.Substring(0, 18);
		}
		newState.Enter(this);
	}

	private void CheckQuestState(QuestState questState)
	{
		switch (questState.Id)
		{
		case "Tutorial01":
			ChangeTutorialState(grabRodState);
			break;
		case "Tutorial02":
			ChangeTutorialState(catchFishByYourSelfState);
			break;
		case "Tutorial03":
			ChangeTutorialState(getMoneyState);
			break;
		case "Intro02":
			ChangeTutorialState(outroState);
			break;
		}
	}

	private void OnEnterQuestState(QuestState questState)
	{
		CheckQuestState(questState);
	}

	private void OnTensionMeterSignal(TensionMeter.TensionMeterEventType eventType)
	{
		if (eventType != TensionMeter.TensionMeterEventType.Full)
		{
			return;
		}
		tensionMeterActive = true;
		if (IsControllerActive())
		{
			StartCoroutine(SpawnSpeechbubbleDialogWindow("Tutorial90BeachDD"));
			StopImageReel();
			if (GetUseSecondaryimage())
			{
				StartImageReel(fishGotAwayImageReelSecondary);
			}
			else
			{
				StartImageReel(fishGotAwayImageReelController);
			}
		}
		else
		{
			StartCoroutine(SpawnSpeechbubbleDialogWindow("Tutorial90Beach"));
			StopImageReel();
			StartImageReel(fishGotAwayImageReelGaze);
		}
		StartCoroutine(DeactivateDialogWindow(tensionMeterHintRemovalDelay));
	}

	private void CheckTargetAreaHit(GameObject bobber)
	{
		Vector3 position = bobber.transform.position;
		tutorialFishMoveTarget = bobber;
		if (targetArea.GetComponent<Renderer>().bounds.Contains(new Vector3(position.x, targetArea.transform.position.y, position.z)))
		{
			ChangeTutorialState(waitForFishAttractionState);
		}
		else
		{
			ChangeTutorialState(failReelInState);
		}
	}

	private void OnFishAttraction(FishEventType eventType, Fish fish)
	{
		switch (eventType)
		{
		case FishEventType.Nibble:
			DialogSpeechbubbleStartSignal.Dispatch("Tutorial40Beach");
			break;
		case FishEventType.Hook:
			if (IsControllerActive())
			{
				DialogSpeechbubbleStartSignal.Dispatch("Tutorial50BeachDD");
			}
			else
			{
				DialogSpeechbubbleStartSignal.Dispatch("Tutorial50Beach");
			}
			StopImageReel();
			StartImageReel(fishHookReel);
			StateChangeSignal.Dispatch(TutorialStateType.FishFight);
			break;
		case FishEventType.CaptureBegin:
			ChangeTutorialState(fishFightState);
			break;
		case FishEventType.PullUpFromWater:
			ChangeTutorialState(grabFishState);
			break;
		}
	}

	private void OnFishingRodSignal(FishingRodEventType type)
	{
		if (type == FishingRodEventType.StartGrab)
		{
			ChangeTutorialState(throwState);
		}
	}

	private void OnCatchDisplaySignal(CatchDisplayEventType eventType)
	{
		if (eventType == CatchDisplayEventType.Show)
		{
			tutorialDialog.SetActive(value: false);
		}
	}

	private void CompleteReelInFail(bool fishOnHook)
	{
		ChangeTutorialState(throwState);
	}

	private void SpawnTargetArea()
	{
		if (targetArea == null)
		{
			targetArea = UnityEngine.Object.Instantiate(TargetAreaPrefab, targetAreaPosition, Quaternion.identity * Quaternion.Euler(90f, 0f, 0f));
			targetArea.transform.parent = base.transform;
		}
	}

	private IEnumerator SpawnSpeechbubbleDialogWindow(string dialogId)
	{
		tutorialDialog.SetActive(value: true);
		yield return null;
		DialogSpeechbubbleStartSignal.Dispatch(dialogId);
	}

	private void SetImage(Sprite sprite)
	{
		TutorialDialog component = tutorialDialog.GetComponent<TutorialDialog>();
		component.SetImage(sprite);
	}

	private void StartImageReel(Sprite[] imageReel)
	{
		imageReelCorotine = PlayImageReel(imageReel);
		StartCoroutine(imageReelCorotine);
	}

	private void StopImageReel()
	{
		if (imageReelCorotine != null)
		{
			StopCoroutine(imageReelCorotine);
		}
		TutorialDialog component = tutorialDialog.GetComponent<TutorialDialog>();
		component.SetImage(null);
	}

	private IEnumerator PlayImageReel(Sprite[] imageReel)
	{
		int index = 0;
		TutorialDialog dialogWindow = tutorialDialog.GetComponent<TutorialDialog>();
		while (true)
		{
			dialogWindow.SetImage(imageReel[index]);
			index = (index + 1) % imageReel.Length;
			yield return new WaitForSeconds(imageReelDelay);
		}
	}

	private void ShowRod()
	{
		FishingRodSignal.Dispatch(FishingRodEventType.VisibleRod);
	}

	private void ContinueFishing(GameObject bobber)
	{
		StartCoroutine(DeactivateDialogWindow(dialogRemovalDelay));
	}

	private IEnumerator DeactivateDialogWindow(float delay)
	{
		yield return new WaitForSeconds(delay);
		tensionMeterActive = false;
		tutorialDialog.SetActive(value: false);
	}

	private void SpawnTutorialFish()
	{
		Vector3 vector = new Vector3(6f, 0f, -7f);
		Vector3 spawnPoint = new Vector3(tutorialFishMoveTarget.transform.position.x, -0.3f, tutorialFishMoveTarget.transform.position.z) + vector;
		AggregationOfFish aggregationOfFish = UnityEngine.Object.FindObjectOfType<AggregationOfFish>();
		FishBehavior fishBehavior = aggregationOfFish.SpawnFish(tutorialFishType, spawnPoint);
		fishBehavior.StartInTutorialMode(tutorialFishMoveTarget);
	}

	private bool GetUseSecondaryimage()
	{
		return SingletonBehavior<DeviceConfigLoader>.Instance.GetConfig().GetUseSecondaryImage();
	}

	private void OnDestroy()
	{
		Quest.EnterQuestStateSignal.RemoveListener(OnEnterQuestState);
		GearVRInputSwitchSignal.RemoveListener(OnActiveControllerChanged);
		if (currentState != null)
		{
			currentState.Exit(this);
		}
	}
}
public class TutorialDialog : DialogView
{
	public Image imageArea;

	private Text text;

	[@Dependency]
	public Localization localization { get; set; }

	private void Start()
	{
		this.Inject();
		text = GetComponentInChildren<Text>();
		text.fontSize = (int)((float)text.fontSize * localization.GetLanguageFontSizeMultiplier());
	}

	public void SetImage(Sprite sprite)
	{
		imageArea.sprite = sprite;
	}

	public override void Say(Dialog.Line line, LineContext context)
	{
		text.text = line.text;
		if (localization.CurrentLanguangId == "ja")
		{
			text.text = text.text.Replace("? ", "");
			text.text = text.text.Replace("! ", "");
			text.text = text.text.Replace(". ", "");
		}
		text.font = localization.GetLanguageFont();
	}

	public override void Clear()
	{
	}
}
[Serializable]
public class TutorialCondition : QuestCondition
{
	public TutorialCondition()
	{
		base.RequiredProgress = 1;
		base.CurrentProgress = 0;
	}

	public override void OnTutorialEnd()
	{
		base.CurrentProgress++;
	}
}
public class RodAttachPoint : MonoBehaviour
{
}
public class RodBend : MonoBehaviour
{
	private struct Joint
	{
		public Transform transform;

		public Quaternion originalRotation;
	}

	public SpringJoint spring;

	public Transform firstJoint;

	public float horizontalBendiness = 3f;

	public float maxHorizontalBend = 20f;

	public float verticalBendiness = 3f;

	public float maxVerticalBend = 10f;

	public float maxBendAtAngle = 70f;

	public float stretchSpeed = 7f;

	public float additionalHorizontalBend;

	public float additionalVerticalBend;

	private GameObject rodHolder;

	private List<Joint> joints;

	private float currentStretch;

	private void Start()
	{
		UpdateJoints();
		rodHolder = GetComponentInParent<RodHolder>().gameObject;
	}

	private void UpdateJoints()
	{
		joints = new List<Joint>();
		Transform child = firstJoint;
		while (true)
		{
			joints.Add(new Joint
			{
				transform = child,
				originalRotation = child.transform.localRotation
			});
			if (child.childCount == 0)
			{
				break;
			}
			child = child.GetChild(0);
		}
	}

	public void Update()
	{
		Transform parent = joints[0].transform.parent;
		Vector3 vector = parent.InverseTransformPoint(spring.transform.position);
		Vector3 vector2 = parent.InverseTransformPoint(spring.connectedBody.transform.position);
		Vector3 direction = vector2 - vector;
		float magnitude = direction.magnitude;
		float target = Mathf.Max(0f, magnitude - spring.maxDistance);
		currentStretch = Mathf.MoveTowards(currentStretch, target, stretchSpeed * Time.deltaTime);
		Vector3 vector3 = direction.normalized * currentStretch;
		float num = Vector3.Angle(rodHolder.transform.forward, firstJoint.TransformDirection(direction));
		float num2 = Mathf.Min(num / maxBendAtAngle, 1f);
		BendRod(Quaternion.AngleAxis(GetAngle(vector3.y * verticalBendiness * num2, maxVerticalBend) + additionalVerticalBend / (float)joints.Count * num2, Vector3.forward) * Quaternion.AngleAxis(GetAngle(vector3.z * (0f - horizontalBendiness) * num2, maxHorizontalBend) + additionalHorizontalBend / (float)joints.Count * num2, Vector3.up));
	}

	private void BendRod(Quaternion rotationPerJoint)
	{
		int count = joints.Count;
		for (int i = 0; i < count; i++)
		{
			Joint joint = joints[i];
			joint.transform.localRotation = joint.originalRotation * rotationPerJoint;
		}
	}

	private float GetAngle(float bendAmount, float maxBend)
	{
		float to = maxBend / (float)joints.Count;
		if (bendAmount < 0f)
		{
			return Mathf.SmoothStep(0f, to, 0f - bendAmount);
		}
		return 0f - Mathf.SmoothStep(0f, to, bendAmount);
	}
}
public class RodBending : MonoBehaviour
{
	private enum State
	{
		ReeledIn,
		ReeledInWithFish,
		Casting,
		InWater,
		FishStruggle,
		CaptureEnd
	}

	private struct Joint
	{
		public Transform transform;

		public Quaternion originalRotation;
	}

	public Transform firstJoint;

	public Transform jointRoot;

	public float maxVerticalAngle = 70f;

	public float maxHorizontalAngle = 70f;

	public float bendSpeed = 10f;

	public float lineTensionReleaseSpeed = 3f;

	public float reelTensionSpeed = 0.5f;

	public float reelStruggleTensionSpeed = 0.5f;

	[Header("Bend percentages")]
	[Range(0f, 1f)]
	public float struggleDefaultBend = 0.05f;

	[Range(0f, 1f)]
	public float nibbleBend = 0.1f;

	public float? bendOverride;

	public float? bendLimit;

	private GameObject rodHolder;

	private List<Joint> joints;

	private float currentBend;

	private float lineDistance;

	private float fishWeightModifier = 1f;

	private float captureBendLerpProgress;

	private State currentState;

	private Coroutine nibbleCoroutine;

	private Coroutine jerkCoroutine;

	[@Dependency]
	public FishingRodEvent FishingRodSignal { get; set; }

	public Transform rodTip { get; set; }

	public Reel reel { get; set; }

	public SpringJoint spring { get; set; }

	public Bobber bobber { get; set; }

	private Joint LastJoint => joints[joints.Count - 1];

	private void Start()
	{
		this.Inject();
		FindJoints();
		rodHolder = GetComponentInParent<RodHolder>().gameObject;
		FishingRodSignal.AddListener(OnFishingRodSignal);
		FishingLine.ReelInDoneSignal.AddListener(OnReelInDoneSignal);
		Bobber.bobberHitWaterSignal.AddListener(OnBobberHitWaterSignal);
		CatchDisplay.CatchDisplaySignal.AddListener(OnCatchDisplay);
		FishBehavior.FishSignal.AddListener(OnFishEvent);
	}

	private void OnDestroy()
	{
		FishingRodSignal.RemoveListener(OnFishingRodSignal);
		FishingLine.ReelInDoneSignal.RemoveListener(OnReelInDoneSignal);
		Bobber.bobberHitWaterSignal.RemoveListener(OnBobberHitWaterSignal);
		CatchDisplay.CatchDisplaySignal.RemoveListener(OnCatchDisplay);
		FishBehavior.FishSignal.RemoveListener(OnFishEvent);
	}

	private void OnFishingRodSignal(FishingRodEventType type)
	{
		switch (type)
		{
		case FishingRodEventType.ReleaseLine:
			currentState = State.Casting;
			break;
		case FishingRodEventType.JerkRodWithoutFish:
			if (jerkCoroutine != null)
			{
				StopCoroutine(jerkCoroutine);
			}
			jerkCoroutine = StartCoroutine(DoJerkBend(hasFish: false));
			break;
		case FishingRodEventType.JerkRodWithFish:
			if (jerkCoroutine != null)
			{
				StopCoroutine(jerkCoroutine);
			}
			jerkCoroutine = StartCoroutine(DoJerkBend(hasFish: true));
			break;
		}
	}

	private void OnBobberHitWaterSignal(GameObject obj)
	{
		currentState = State.InWater;
	}

	private void OnReelInDoneSignal(bool fishOnHook)
	{
		if (fishOnHook)
		{
			currentState = State.ReeledInWithFish;
		}
		else
		{
			currentState = State.ReeledIn;
		}
	}

	private void OnCatchDisplay(CatchDisplayEventType type)
	{
		if (type == CatchDisplayEventType.Show)
		{
			currentState = State.ReeledIn;
			fishWeightModifier = 1f;
		}
	}

	private void OnFishEvent(FishEventType type, Fish fish)
	{
		switch (type)
		{
		case FishEventType.Nibble:
			if (nibbleCoroutine != null)
			{
				StopCoroutine(nibbleCoroutine);
			}
			nibbleCoroutine = StartCoroutine(DoNibbleBend());
			break;
		case FishEventType.CaptureEnd:
			currentState = State.CaptureEnd;
			captureBendLerpProgress = 0f;
			fishWeightModifier = Mathf.Log(fish.weight + 5f, 20f);
			break;
		}
	}

	private IEnumerator DoNibbleBend()
	{
		float currentValue = nibbleBend * 0.5f;
		while (currentValue != nibbleBend)
		{
			currentValue = Mathf.MoveTowards(currentValue, nibbleBend, Time.deltaTime);
			bendOverride = currentValue;
			yield return null;
		}
		yield return null;
		bendOverride = null;
		nibbleCoroutine = null;
	}

	private IEnumerator DoJerkBend(bool hasFish)
	{
		float storeBendSpeed = bendSpeed;
		bendOverride = ((!hasFish) ? 0.5f : 1f);
		yield return null;
		yield return null;
		bendSpeed = storeBendSpeed;
		bendOverride = null;
	}

	private void FindJoints()
	{
		joints = new List<Joint>();
		Transform child = firstJoint;
		while (true)
		{
			joints.Add(new Joint
			{
				transform = child,
				originalRotation = child.localRotation
			});
			if (child.childCount == 0)
			{
				break;
			}
			child = child.GetChild(0);
		}
	}

	private void Update()
	{
		Vector3 vector = jointRoot.transform.InverseTransformPoint(bobber.transform.position);
		Vector3 vector2 = jointRoot.transform.InverseTransformPoint(rodTip.position);
		Vector3 vector3 = vector;
		if (currentState == State.ReeledInWithFish)
		{
			spring.anchor = rodTip.InverseTransformPoint(LastJoint.transform.TransformPoint(new Vector3(0f, 0f, -0.1f)));
			vector3 -= vector2;
			UnityEngine.Debug.DrawRay(jointRoot.TransformPoint(vector2), jointRoot.TransformDirection(vector3), Color.cyan);
		}
		else
		{
			spring.anchor = Vector3.zero;
		}
		if (currentState == State.CaptureEnd)
		{
			captureBendLerpProgress = Mathf.MoveTowards(captureBendLerpProgress, 1f, Time.deltaTime);
			vector3 -= vector2 * captureBendLerpProgress;
		}
		Vector3 vector4 = default(Vector3);
		Vector3 vector5 = vector3;
		vector5.y = 0f;
		vector4.y = Vector3.SignedAngle(Vector3.left, vector5, Vector3.up);
		Vector3 vector6 = vector3;
		vector6.z = 0f;
		vector4.z = Vector3.SignedAngle(Vector3.left, vector6, Vector3.forward);
		Vector3 direction = vector3;
		direction.x = 0f;
		direction.Normalize();
		float y = direction.y;
		float z = direction.z;
		UnityEngine.Debug.DrawRay(rodTip.transform.position, jointRoot.TransformDirection(vector5), Color.yellow);
		UnityEngine.Debug.DrawRay(rodTip.transform.position, jointRoot.TransformDirection(vector6), Color.red);
		UnityEngine.Debug.DrawRay(rodTip.transform.position, jointRoot.TransformDirection(direction), Color.blue);
		vector4.y = Mathf.Clamp(vector4.y, 0f - maxHorizontalAngle, maxHorizontalAngle);
		vector4.z = Mathf.Clamp(vector4.z, 0f - maxVerticalAngle, maxVerticalAngle);
		vector4.z *= Mathf.Abs(y);
		vector4.y *= Mathf.Abs(z);
		float magnitude = (bobber.transform.position - rodTip.position).magnitude;
		float num = Mathf.Max(0f, magnitude - Mathf.Min(lineDistance, spring.maxDistance));
		float num2 = num;
		switch (currentState)
		{
		case State.ReeledIn:
		case State.ReeledInWithFish:
		{
			float magnitude2 = (bobber.transform.position - rodTip.TransformPoint(spring.anchor)).magnitude;
			float num5 = (magnitude + magnitude2) * 0.5f * fishWeightModifier;
			num2 = Mathf.Max(0f, num5 - spring.maxDistance);
			break;
		}
		case State.CaptureEnd:
			num2 = Mathf.MoveTowards(currentBend, 1f, 1f * Time.deltaTime);
			break;
		case State.Casting:
			num2 = Mathf.MoveTowards(currentBend, 0f, Time.deltaTime);
			lineDistance = magnitude;
			break;
		case State.InWater:
		{
			lineDistance = Mathf.MoveTowards(lineDistance, magnitude, lineTensionReleaseSpeed * Time.deltaTime);
			float num3 = 0f;
			float num4 = reelTensionSpeed;
			if (TensionMeter.instance == null)
			{
				num3 = Mathf.Clamp(reel.ReelTensionWithoutFish * 0.2f, 0f, 0.3f);
			}
			else
			{
				num3 = Mathf.Max(TensionMeter.instance.CurrentTension, reel.ReelTensionWithFish * 0.8f);
				num4 = reelStruggleTensionSpeed;
			}
			num2 = Mathf.Lerp(currentBend, num + num3, num4 * Time.deltaTime);
			num2 = Mathf.Max(struggleDefaultBend, num2);
			if (lineDistance > magnitude)
			{
				lineDistance = magnitude;
			}
			break;
		}
		}
		if (bendOverride.HasValue)
		{
			num2 = Mathf.Max(bendOverride.Value, num2);
		}
		if (bendLimit.HasValue)
		{
			num2 = Mathf.Min(bendLimit.Value, num2);
		}
		currentBend = Mathf.MoveTowards(currentBend, Mathf.Clamp01(num2), Time.deltaTime * bendSpeed);
		vector4 *= currentBend;
		Quaternion quaternion = Quaternion.Euler(vector4 * (1f / (float)joints.Count));
		UnityEngine.Debug.DrawLine(jointRoot.transform.position, jointRoot.transform.TransformPoint(vector));
		UnityEngine.Debug.DrawRay(jointRoot.transform.position, jointRoot.transform.TransformDirection(quaternion * Vector3.forward), Color.blue);
		UnityEngine.Debug.DrawRay(jointRoot.transform.position, jointRoot.transform.TransformDirection(quaternion * Vector3.up), Color.yellow);
		BendRod(quaternion);
	}

	private void BendRod(Quaternion rotationPerJoint)
	{
		int count = joints.Count;
		for (int i = 0; i < count; i++)
		{
			Joint joint = joints[i];
			joint.transform.localRotation = joint.originalRotation * rotationPerJoint;
		}
	}

	private float GetAngle(float bendAmount, float maxBend)
	{
		float to = maxBend / (float)joints.Count;
		if (bendAmount < 0f)
		{
			return Mathf.SmoothStep(0f, to, 0f - bendAmount);
		}
		return 0f - Mathf.SmoothStep(0f, to, bendAmount);
	}
}
[RequireComponent(typeof(SinkerCasting))]
public class RodFader : MonoBehaviour
{
	public Material rodTransparentMaterial;

	public Material rodOpaqueMaterial;

	public Material reelTransparentMaterial;

	public Material reelOpaqueMaterial;

	[Header("Controller Specific")]
	[Range(0f, 50f)]
	public float fadeAngleFromFace = 5f;

	[Range(0f, 50f)]
	public float forceFullFadeAtAngle = 15f;

	[SerializeField]
	private const float fadeSpeed = 4f;

	[HideInInspector]
	public Transform forwardDirection;

	private bool isMaterialTransparent;

	private Material rodCurrentMaterial;

	private Material reelCurrentMaterial;

	private float angleAlpha;

	private SkinnedMeshRenderer poleRenderer;

	private MeshRenderer shaftRenderer;

	private MeshRenderer reelRenderer;

	private bool fadeShaft;

	[@Dependency]
	public InputManager input { get; set; }

	private void Start()
	{
		this.Inject();
		poleRenderer = Find.ComponentOnChild<SkinnedMeshRenderer>(this, "Pole");
		rodCurrentMaterial = GetComponentInChildren<SkinnedMeshRenderer>().material;
		DeviceConfig config = SingletonBehavior<DeviceConfigLoader>.Instance.GetConfig();
		fadeShaft = config.GetFadeRodShaft();
		if (fadeShaft)
		{
			shaftRenderer = Find.ComponentOnChild<MeshRenderer>(this, "FishingRodShaft");
			reelRenderer = Find.ComponentOnChild<MeshRenderer>(this, "Reel");
		}
	}

	private void LateUpdate()
	{
		UpdateAngleAlpha();
		float num = angleAlpha;
		if ((num < 1f && !isMaterialTransparent) || (num >= 1f && isMaterialTransparent))
		{
			SwitchMaterial();
		}
		if (isMaterialTransparent)
		{
			SetAlpha(num, rodCurrentMaterial);
			if (fadeShaft)
			{
				SetAlpha(num, reelCurrentMaterial);
			}
		}
	}

	private void UpdateAngleAlpha()
	{
		Camera main = Camera.main;
		if (main == null)
		{
			return;
		}
		if (input.GetInputMode() != InputMode.Headset)
		{
			Vector3 from = main.transform.position - base.transform.position;
			float num = Vector3.Angle(from, forwardDirection.forward);
			if (num < fadeAngleFromFace)
			{
				angleAlpha = Mathf.Max(0f, angleAlpha - 4f * Time.deltaTime);
			}
			else
			{
				angleAlpha = Mathf.Min(1f, angleAlpha + 4f * Time.deltaTime);
			}
			if (num < forceFullFadeAtAngle)
			{
				angleAlpha = 0f;
			}
		}
		else
		{
			angleAlpha = 1f;
		}
	}

	private void SwitchMaterial()
	{
		Material material = ((!isMaterialTransparent) ? rodTransparentMaterial : rodOpaqueMaterial);
		poleRenderer.material = material;
		rodCurrentMaterial = material;
		if (fadeShaft)
		{
			shaftRenderer.material = rodCurrentMaterial;
			material = ((!isMaterialTransparent) ? reelTransparentMaterial : reelOpaqueMaterial);
			reelRenderer.material = material;
			reelCurrentMaterial = material;
		}
		isMaterialTransparent = !isMaterialTransparent;
	}

	private void SetAlpha(float alpha, Material material)
	{
		Color color = material.color;
		color.a = alpha;
		material.color = color;
	}
}
public class RodGrabbable : GrabbableObject
{
	[SerializeField]
	private Transform rightHandDefaultHolder;

	[SerializeField]
	private Transform leftHandDefaultHolder;

	[SerializeField]
	private Transform middleHandDefaultHolder;

	[SerializeField]
	private float returnDelay = 1f;

	[SerializeField]
	private float returnTweenDuration = 1f;

	[SerializeField]
	private Vector3 grabbRotationOffset = new Vector3(-40f, 0f, 0f);

	[SerializeField]
	private Vector3 grabbPositionOffset = new Vector3(0f, 0f, -0.1f);

	[SerializeField]
	private float heightDifferenceToReturnToDefault = 1f;

	[SerializeField]
	private float distanceToReturnToDefault = 2f;

	[HideInInspector]
	public SinkerCasting sinkerCasting;

	[HideInInspector]
	public Reel reel;

	private Transform attachPoint;

	[@Dependency]
	public InputManager Input { get; set; }

	[@Dependency]
	public FishingRodEvent FishingRodSignal { get; set; }

	public override HandAnimation.Pose GetGrabbedPose()
	{
		return HandAnimation.Pose.HoldController;
	}

	public override void OnObjectGrabbed(Hand hand, Action OnGrabbed)
	{
		base.OnObjectGrabbed(hand, OnGrabbed);
		StopAllCoroutines();
		AttachToHand(hand);
		reel.SetRod(this);
		LeanTween.cancel(base.gameObject);
		if (sinkerCasting != null)
		{
			sinkerCasting.SetHand(hand);
			sinkerCasting.OnGrabbed();
		}
		if ((bool)reel)
		{
			Vector3 localScale = reel.transform.localScale;
			localScale.x = Mathf.Abs(localScale.x) * ((hand.Handedness != Handedness.Left) ? 1f : (-1f));
			reel.transform.localScale = localScale;
			reel.SetGrabbingAllowed(allowed: true);
		}
		FishingRodSignal.Dispatch(FishingRodEventType.StartGrab);
	}

	private void Awake()
	{
		this.Inject();
		FishingRodSignal.AddListener(OnFishingRodSignal);
		RodAssembler.RodAssembledNotification.AddListener(OnRodAssembledSignal);
		Bobber.bobberHitWaterSignal.AddListener(OnBobberHitWaterSignal);
	}

	private IEnumerator Start()
	{
		FishBehavior.FishSignal.AddListener(OnFishSignal);
		while (Camera.main == null)
		{
			yield return null;
		}
		yield return null;
		float delay = returnDelay;
		returnDelay = 0f;
		StartCoroutine(ReturnToDefaultLocation(Handedness.None));
		returnDelay = delay;
	}

	protected override void StartHovering()
	{
	}

	public override void OnInput(InputAction action, InputType type)
	{
		if (sinkerCasting != null)
		{
			sinkerCasting.OnInput(action, type);
		}
	}

	protected override void EndHovering()
	{
	}

	public override void OnObjectReleased(Hand hand)
	{
		base.OnObjectReleased(hand);
		reel.SetRod(this);
		base.transform.parent = null;
		if (attachPoint != null)
		{
			AttachTo(attachPoint);
		}
		else
		{
			if (rightHandDefaultHolder != null && leftHandDefaultHolder != null)
			{
				StartCoroutine(HoverAway(hand.AvrageThrowVelocity));
				StartCoroutine(ReturnToDefaultLocation(hand.Handedness));
			}
			sinkerCasting.OnReleased();
		}
		if (sinkerCasting != null)
		{
			sinkerCasting.SetHand(null);
		}
		if ((bool)reel)
		{
			reel.SetGrabbingAllowed(allowed: false);
		}
		FishingRodSignal.Dispatch(FishingRodEventType.EndGrab);
	}

	private void AttachToHand(Hand obj)
	{
		base.transform.parent = obj.transform;
		base.transform.localRotation = Quaternion.Euler(grabbRotationOffset);
		float num = 1f;
		num = ((hand.Handedness != Handedness.Right) ? (-1f) : 1f);
		Vector3 vector = new Vector3(grabbPositionOffset.x * num, grabbPositionOffset.y, grabbPositionOffset.z);
		base.transform.position = obj.transform.position + base.transform.TransformVector(vector);
	}

	private void AttachTo(Transform obj)
	{
		base.transform.parent = obj;
		base.transform.localRotation = Quaternion.identity;
		base.transform.localPosition = Vector3.zero;
	}

	private IEnumerator ReturnToDefaultLocation(Handedness previousHand)
	{
		yield return new WaitForSeconds(returnDelay);
		Transform target = ((previousHand != Handedness.Right && previousHand != 0) ? leftHandDefaultHolder : rightHandDefaultHolder);
		LeanTween.move(base.gameObject, target.position, returnTweenDuration);
		LeanTween.rotate(to: target.rotation.eulerAngles, gameObject: base.gameObject, time: returnTweenDuration);
		StopAllCoroutines();
		StartCoroutine(ReturnIfFarAway(Camera.main.transform, returnTweenDuration));
	}

	private IEnumerator ReturnIfFarAway(Transform target, float initialDelay)
	{
		yield return new WaitForSeconds(initialDelay);
		YieldInstruction yielder = new WaitForSeconds(1f);
		while (true)
		{
			Vector3 distance = target.position - base.transform.position;
			if (Mathf.Abs(distance.y) > heightDifferenceToReturnToDefault || distance.magnitude > distanceToReturnToDefault)
			{
				break;
			}
			yield return yielder;
		}
		StartCoroutine(ReturnToDefaultLocation(Handedness.None));
	}

	private IEnumerator HoverAway(Vector3 velocity)
	{
		Vector3 currentPostion2 = base.transform.position;
		while (true)
		{
			if ((double)velocity.magnitude > 0.001)
			{
				base.transform.position += velocity * Time.deltaTime;
				velocity *= 0.95f;
				currentPostion2 = base.transform.position;
			}
			yield return null;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		RodAttachPoint component = other.GetComponent<RodAttachPoint>();
		if ((bool)component)
		{
			attachPoint = component.transform;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.transform == attachPoint)
		{
			attachPoint = null;
		}
	}

	private void OnFishSignal(FishEventType fishEvent, Fish fish)
	{
		if (!(hand == null))
		{
			switch (fishEvent)
			{
			case FishEventType.PullUpFromWater:
				Input.FadeHaptic(0.7f, 0.15f, fish.pullUpDrag * 0.5f, hand.Handedness);
				break;
			case FishEventType.Nibble:
				Input.RandomHaptic(0.3f, 0.5f, 0.25f, hand.Handedness);
				break;
			case FishEventType.Hook:
				Input.RandomHaptic(0.3f, 0.5f, 0.1f, hand.Handedness);
				break;
			case FishEventType.EscapeHook:
				Input.RandomHaptic(0f, 0f, 0f, hand.Handedness);
				break;
			}
		}
	}

	private void OnFishingRodSignal(FishingRodEventType type)
	{
		switch (type)
		{
		case FishingRodEventType.HideRod:
			base.gameObject.SetActive(value: false);
			break;
		case FishingRodEventType.VisibleRod:
			base.gameObject.SetActive(value: true);
			break;
		case FishingRodEventType.ReleaseLine:
			if (hand != null)
			{
				Input.FadeHaptic(0.6f, 0.1f, 1.5f, hand.Handedness);
			}
			break;
		}
	}

	private void OnRodAssembledSignal(RodAssembler.RodParts parts)
	{
		if (hand != null)
		{
			sinkerCasting.SetHand(hand);
		}
	}

	private void OnBobberHitWaterSignal(GameObject bobber)
	{
		Input.RandomHaptic(0f, 0f, 0f, Handedness.Left);
		Input.RandomHaptic(0f, 0f, 0f, Handedness.Right);
	}

	private void OnDestroy()
	{
		FishBehavior.FishSignal.RemoveListener(OnFishSignal);
		FishingRodSignal.RemoveListener(OnFishingRodSignal);
		Bobber.bobberHitWaterSignal.RemoveListener(OnBobberHitWaterSignal);
	}
}
public class RodHolder : MonoBehaviour
{
	public Vector3 localHeadSetRotation;

	public Vector3 localControllerRotation;

	[HideInInspector]
	public Vector3 localStartPosition;

	[HideInInspector]
	public Quaternion localStartRotation;

	[@Dependency]
	public InputModeSwitchEvent GearVRInputSwitchSignal { get; set; }

	[@Dependency]
	public InputManager input { get; set; }

	private void Awake()
	{
		localStartPosition = base.transform.localPosition;
	}

	private void Start()
	{
		this.Inject();
		GearVRInputSwitchSignal.AddListener(OnActiveControllerChanged);
		if (input.GetInputMode() == InputMode.Headset)
		{
			localStartRotation = Quaternion.Euler(localHeadSetRotation);
		}
		else
		{
			localStartRotation = Quaternion.Euler(localControllerRotation);
		}
		base.transform.localRotation = localStartRotation;
	}

	private void OnActiveControllerChanged(InputMode inputType)
	{
		if (inputType == InputMode.Headset)
		{
			localStartRotation = Quaternion.Euler(localHeadSetRotation);
		}
		else
		{
			localStartRotation = Quaternion.Euler(localControllerRotation);
		}
		base.transform.localPosition = localStartPosition;
		base.transform.localRotation = localStartRotation;
	}

	private void OnDestroy()
	{
		GearVRInputSwitchSignal.RemoveListener(OnActiveControllerChanged);
	}
}
public class RodTilt : MonoBehaviour
{
	[Tooltip("The amount of tilt when reeling in a fish.")]
	public float reelinTilt = -20f;

	[Tooltip("The time it takes to tilt when reeling in a fish.")]
	public float reelInTiltTime = 1f;

	[Tooltip("The time it takes to move the rod back in position.")]
	public float moveBackTime = 0.3f;

	public SpringJoint spring;

	private Transform rodHolder;

	private Quaternion localStartRotation;

	private Quaternion tiltTargetRotation;

	private bool started;

	[@Dependency]
	public FishingRodEvent FishingRodSignal { get; set; }

	private void Start()
	{
		this.Inject();
		rodHolder = base.transform.parent;
		localStartRotation = rodHolder.GetComponent<RodHolder>().localStartRotation;
		tiltTargetRotation = localStartRotation * Quaternion.AngleAxis(reelinTilt, Vector3.right);
		started = true;
	}

	private void OnEnable()
	{
		if (started)
		{
			rodHolder.localRotation = localStartRotation;
		}
	}

	private void OnTensionMeterSignal(TensionMeter.TensionMeterEventType type)
	{
		if (type == TensionMeter.TensionMeterEventType.Full)
		{
			StopAllCoroutines();
			StartCoroutine(TiltToStartRotation(moveBackTime));
		}
	}

	private void OnFishingRodSignal(FishingRodEventType type)
	{
		StopAllCoroutines();
		switch (type)
		{
		case FishingRodEventType.StartReelInWithFish:
			StartCoroutine(Tilt(reelinTilt, reelInTiltTime));
			break;
		case FishingRodEventType.StopReelIn:
			StartCoroutine(TiltToStartRotation(moveBackTime));
			break;
		}
	}

	private IEnumerator Tilt(float angle, float time)
	{
		Quaternion startRotation = rodHolder.localRotation;
		float startTime = Time.time;
		float progress = 0f;
		while (Interpolation.ProgressOverTime(startTime, time, ref progress))
		{
			UpdateTargetRotation();
			float smoothProgress = Interpolation.EaseInEaseOut(progress, 3);
			rodHolder.localRotation = Quaternion.Lerp(startRotation, tiltTargetRotation, smoothProgress);
			yield return null;
		}
	}

	private IEnumerator TiltToStartRotation(float time)
	{
		Quaternion currentRotation = rodHolder.localRotation;
		float startTime = Time.time;
		float progress = 0f;
		while (Interpolation.ProgressOverTime(startTime, time, ref progress))
		{
			float smoothProgress = Interpolation.EaseInEaseOut(progress, 3);
			rodHolder.localRotation = Quaternion.Lerp(currentRotation, localStartRotation, smoothProgress);
			yield return null;
		}
	}

	private void UpdateTargetRotation()
	{
		Vector3 vector = rodHolder.InverseTransformPoint(spring.transform.position);
		Vector3 vector2 = rodHolder.InverseTransformPoint(spring.connectedBody.transform.position);
		Vector3 lhs = vector2 - vector;
		Vector3 axis = Vector3.Cross(lhs, rodHolder.InverseTransformDirection(base.transform.forward));
		tiltTargetRotation = localStartRotation * Quaternion.AngleAxis(reelinTilt, axis);
	}

	private void OnDestroy()
	{
		if (!started)
		{
		}
	}
}
public class RodTip : MonoBehaviour
{
	private Vector3 positionLastFrame;

	private Vector3 positionThisFrame;

	private void Update()
	{
		positionLastFrame = positionThisFrame;
		positionThisFrame = base.transform.position;
	}

	public Vector3 NormalizedDirectionOfTipBetweenFrames()
	{
		return (positionThisFrame + new Vector3(0f, 0.01f, 0f) - positionLastFrame).normalized;
	}
}
public class SetChildCameraBackgorund : MonoBehaviour
{
	public Color cameraColor;

	private void Start()
	{
		Camera[] componentsInChildren = GetComponentsInChildren<Camera>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			Camera camera = componentsInChildren[i];
			if (camera.clearFlags == CameraClearFlags.Color || camera.clearFlags == CameraClearFlags.Skybox)
			{
				componentsInChildren[i].backgroundColor = cameraColor;
				componentsInChildren[i].clearFlags = CameraClearFlags.Color;
			}
		}
	}
}
public enum ForceBuyEventType
{
	Begin,
	BuyItem,
	End
}
[RequireComponent(typeof(BuyableItem))]
public class ForceBuyQuestItem : MonoBehaviour
{
	private abstract class ForceBuyState
	{
		public virtual void Enter(ForceBuyQuestItem behavior)
		{
		}

		public virtual void Update(ForceBuyQuestItem behavior)
		{
		}

		public virtual void Exit(ForceBuyQuestItem behavior)
		{
		}

		public virtual void OnBuyItemNotification(ForceBuyQuestItem behavior, string itemId, BuyableItemEventType eventType, BuyableItem.ItemType itemType)
		{
		}

		public virtual void OnSayLine(ForceBuyQuestItem behavior, string lineId)
		{
		}
	}

	private class BeginState : ForceBuyState
	{
		public override void Enter(ForceBuyQuestItem behavior)
		{
			ForceBuyQuestItemNotification.Dispatch(ForceBuyEventType.Begin);
			behavior.StartCoroutine(behavior.StartDialog(behavior.buyDialogId));
		}

		public override void OnSayLine(ForceBuyQuestItem behavior, string lineId)
		{
			behavior.itemGazeButton.EnableInteractionDuringForceBuy();
			behavior.ChangeState(behavior.buyItemState);
		}
	}

	private class BuyItemState : ForceBuyState
	{
		private bool wobble;

		private bool itemBought;

		public override void Enter(ForceBuyQuestItem behavior)
		{
			ForceBuyQuestItemNotification.Dispatch(ForceBuyEventType.BuyItem);
			wobble = true;
			itemBought = false;
		}

		public override void Update(ForceBuyQuestItem behavior)
		{
			if (wobble)
			{
				behavior.transform.localScale = behavior.startScale * (1f + Mathf.Sin(Time.timeSinceLevelLoad * behavior.wobbleSpeed) * behavior.wobbleMagnitude);
			}
		}

		public override void OnBuyItemNotification(ForceBuyQuestItem behavior, string itemId, BuyableItemEventType eventType, BuyableItem.ItemType itemType)
		{
			switch (eventType)
			{
			case BuyableItemEventType.ShowItem:
				behavior.DialogAdvanceRequest.Dispatch();
				wobble = false;
				break;
			case BuyableItemEventType.PutBackItem:
				if (!itemBought)
				{
					wobble = true;
				}
				break;
			case BuyableItemEventType.ItemPurchased:
				itemBought = true;
				ForceBuyQuestItemNotification.Dispatch(ForceBuyEventType.End);
				break;
			}
		}
	}

	public static Signal<ForceBuyEventType> ForceBuyQuestItemNotification = new Signal<ForceBuyEventType>();

	public string startStateId;

	public string buyDialogId;

	public string startWobbleLineId;

	private BuyableItem TargetItem;

	private BeginState beginState;

	private BuyItemState buyItemState;

	private ForceBuyState currentState;

	private string buyItemId;

	private Vector3 startScale;

	private float wobbleSpeed = 5f;

	private float wobbleMagnitude = 0.1f;

	private bool wobble;

	private LaunchShopGUIButton itemGazeButton;

	[@Dependency]
	public Quest Quest { get; set; }

	[@Dependency]
	public DialogSpeechbubbleStartEvent DialogStartRequest { get; set; }

	[@Dependency]
	public DialogAdvanceEvent DialogAdvanceRequest { get; set; }

	[@Dependency]
	public DialogEndEvent DialogEndNotification { get; set; }

	private void Start()
	{
		this.Inject();
		beginState = new BeginState();
		buyItemState = new BuyItemState();
		if (TargetItem == null)
		{
			TargetItem = Find.ComponentOnGameObject<BuyableItem>(this);
		}
		startScale = base.transform.localScale;
		buyItemId = TargetItem.itemId;
		itemGazeButton = Find.ComponentOnGameObject<LaunchShopGUIButton>(this);
		Quest.EnterQuestStateSignal.AddListener(OnEnterQuestState);
		BuyableItem.BuyableItemSignal.AddListener(OnBuyItemNotification);
		Dialog.SayLineNotification.AddListener(OnSayLine);
		CheckQuestState(Quest.CurrentState);
	}

	private void OnEnterQuestState(QuestState questState)
	{
		CheckQuestState(questState);
	}

	private void CheckQuestState(QuestState questState)
	{
		if (questState.Id == startStateId)
		{
			StartCoroutine(EnterStartBuy(beginState));
		}
	}

	private void ChangeState(ForceBuyState newState)
	{
		if (currentState != null)
		{
			currentState.Exit(this);
		}
		currentState = newState;
		newState.Enter(this);
	}

	private void OnBuyItemNotification(string itemId, BuyableItemEventType eventType, BuyableItem.ItemType itemType)
	{
		if (buyItemId == itemId && currentState != null)
		{
			currentState.OnBuyItemNotification(this, itemId, eventType, itemType);
		}
	}

	private void OnSayLine(string lineId)
	{
		if (lineId == startWobbleLineId && currentState != null)
		{
			currentState.OnSayLine(this, lineId);
		}
	}

	private void Update()
	{
		if (currentState != null)
		{
			currentState.Update(this);
		}
	}

	private IEnumerator EnterStartBuy(ForceBuyState startState)
	{
		yield return null;
		ChangeState(startState);
	}

	private IEnumerator StartDialog(string dialogId)
	{
		yield return null;
		DialogStartRequest.Dispatch(dialogId);
	}

	private void OnDestroy()
	{
		if (currentState != null)
		{
			currentState.Exit(this);
		}
		Quest.EnterQuestStateSignal.RemoveListener(OnEnterQuestState);
		BuyableItem.BuyableItemSignal.RemoveListener(OnBuyItemNotification);
		Dialog.SayLineNotification.RemoveListener(OnSayLine);
	}
}
public class ShopKeep01Interaction : ShopKeeperInteraction
{
	private bool disabledByForceBuyItem;

	protected override string QuestDialog => base.quest.CurrentState.ShopKeeper01Dialog;

	public override void Start()
	{
		base.Start();
		ForceBuyQuestItem.ForceBuyQuestItemNotification.AddListener(OnForceBuyItemNotification);
	}

	public override bool IsSelectable(GameObject obj)
	{
		return !disabledByForceBuyItem && !isHavingDialog && !showingOtherUI;
	}

	private void OnForceBuyItemNotification(ForceBuyEventType eventType)
	{
		switch (eventType)
		{
		case ForceBuyEventType.Begin:
		case ForceBuyEventType.BuyItem:
			disabledByForceBuyItem = true;
			break;
		case ForceBuyEventType.End:
			disabledByForceBuyItem = false;
			break;
		}
	}

	protected override void OnDestroy()
	{
		ForceBuyQuestItem.ForceBuyQuestItemNotification.RemoveListener(OnForceBuyItemNotification);
		base.OnDestroy();
	}
}
public class AnimationStateMachineRandomizer : StateMachineBehaviour
{
	public override void OnStateMachineEnter(Animator animator, int stateMachinePathHash)
	{
		animator.SetFloat("Random", UnityEngine.Random.Range(0f, 100f));
	}
}
public class BuyableBait : BuyableItem
{
	public BaitType baitType;

	public int buyAmount;

	public float rotationSpeed = 0.5f;

	public override string itemId => baitType.ToString().ToLower();

	public override ItemType itemType
	{
		get
		{
			if (baitType == BaitType.BaitIAP1)
			{
				return ItemType.BaitIAP;
			}
			return ItemType.Bait;
		}
	}

	protected override void Awake()
	{
		base.Awake();
	}

	protected override void CheckQuestStateWobble()
	{
	}

	protected override void AddItemToInventory()
	{
		if (!base.InventoryManager.Inventory.Baits.TryGetValue(baitType, out var _))
		{
			base.InventoryManager.Inventory.Baits.Add(baitType, buyAmount);
		}
		else
		{
			base.InventoryManager.Inventory.Baits[baitType] += buyAmount;
		}
	}

	protected override Vector3 GetInitialTransitionTargetRotation()
	{
		return new Vector3(0f, 180f, 0f);
	}

	protected override void RotateItem()
	{
		base.transform.Rotate(0f, 0f - rotationSpeed, 0f);
	}

	protected override void AddBait()
	{
		if (!base.InventoryManager.Inventory.Baits.TryGetValue(baitType, out var _))
		{
			base.InventoryManager.Inventory.Baits.Add(baitType, buyAmount);
		}
		else
		{
			base.InventoryManager.Inventory.Baits[baitType] += buyAmount;
		}
	}
}
public class BuyableBobber : BuyableItem
{
	public BobberType bobberType;

	public float rotationSpeed = 0.5f;

	private Vector3 rotationVector = new Vector3(0f, 0.5f, 0f);

	public override string itemId => bobberType.ToString().ToLower();

	public override ItemType itemType => ItemType.Bobber;

	protected override void CheckQuestStateWobble()
	{
	}

	protected override void RotateItem()
	{
		base.transform.Rotate(rotationVector, Space.World);
	}

	protected override Vector3 GetInitialTransitionTargetRotation()
	{
		return new Vector3(30f, 0f, 30f);
	}

	protected override void AddItemToInventory()
	{
		base.InventoryManager.Inventory.Bobber = bobberType;
	}

	protected override void AddBait()
	{
	}
}
public enum BuyableItemEventType
{
	ShowItem,
	ItemPurchased,
	PutBackItem,
	ResetItem
}
public abstract class BuyableItem : MonoBehaviour
{
	public enum ItemType
	{
		Rod,
		Reel,
		Bobber,
		Bait,
		BaitIAP,
		Location
	}

	public static Signal<string, BuyableItemEventType, ItemType> BuyableItemSignal;

	public Transform buyItemDisplayAnchor;

	public Transform boughtItemTargetPos;

	public Vector3 UIAnchorOffset = new Vector3(0f, 0f, -0.1f);

	public Vector3 scaledUpScale = new Vector3(4f, 4f, 4f);

	public float moveToPlayerTime = 1f;

	public Vector3 moveToPlayerOffset = new Vector3(0f, -0.25f, 0f);

	public float wobbleSpeed = 5f;

	public float wobbleMagnitude = 0.1f;

	protected bool isInView;

	protected bool wobble;

	protected Vector3 originalPosition;

	protected Vector3 originalScale;

	protected Quaternion originalRotation;

	protected Collider selectionCollider;

	public abstract string itemId { get; }

	public abstract ItemType itemType { get; }

	[@Dependency]
	public UIDisplayEvent UIDisplaySignal { get; set; }

	[@Dependency]
	public InventoryManager InventoryManager { get; set; }

	[@Dependency]
	public BuyableItemData BuyableItemData { get; set; }

	[@Dependency]
	public Quest Quest { get; set; }

	protected abstract void AddItemToInventory();

	protected abstract Vector3 GetInitialTransitionTargetRotation();

	protected abstract void RotateItem();

	protected abstract void CheckQuestStateWobble();

	protected virtual void Awake()
	{
		this.Inject();
	}

	protected virtual void Start()
	{
		selectionCollider = Find.ComponentOnGameObject<Collider>(this);
		BuyableItemSignal.AddListener(OnBuyableItemsSignal);
		Quest.EnterQuestStateSignal.AddListener(OnEnterQuestState);
		originalPosition = base.transform.position;
		originalScale = base.transform.localScale;
		originalRotation = base.transform.rotation;
		isInView = false;
		wobble = false;
		CheckQuestStateWobble();
	}

	private void OnBuyableItemsSignal(string itemId, BuyableItemEventType eventType, ItemType itemType)
	{
		if (!(itemId != this.itemId))
		{
			switch (eventType)
			{
			case BuyableItemEventType.ShowItem:
				ViewItem();
				break;
			case BuyableItemEventType.ItemPurchased:
				OnItemPurchased();
				break;
			case BuyableItemEventType.PutBackItem:
				PutBackItem();
				break;
			case BuyableItemEventType.ResetItem:
				ResetItem();
				break;
			}
		}
	}

	private void Update()
	{
		if (isInView)
		{
			RotateItem();
		}
		if (wobble && !isInView)
		{
			base.transform.localScale = originalScale * (1f + Mathf.Sin(Time.timeSinceLevelLoad * wobbleSpeed) * wobbleMagnitude);
		}
	}

	private void ViewItem()
	{
		wobble = false;
		AddBait();
		selectionCollider.enabled = false;
		UIDisplaySignal.Dispatch(UIEventType.Display);
		Vector3 to = buyItemDisplayAnchor.position + UIAnchorOffset;
		Vector3 initialTransitionTargetRotation = GetInitialTransitionTargetRotation();
		float num = 1f;
		LeanTween.move(base.gameObject, to, num).setEase(LeanTweenType.easeInOutSine);
		LeanTween.rotate(base.gameObject, initialTransitionTargetRotation, num).setEase(LeanTweenType.easeInOutSine);
		LeanTween.scale(base.gameObject, scaledUpScale, num).setEase(LeanTweenType.easeInOutSine);
		LeanTween.delayedCall(base.gameObject, num + 0.2f, (Action)delegate
		{
			isInView = true;
		});
	}

	private void PutBackItem()
	{
		selectionCollider.enabled = true;
		float num = 1.5f;
		LeanTween.move(base.gameObject, originalPosition, num).setEase(LeanTweenType.easeInOutSine);
		LeanTween.rotate(base.gameObject, originalRotation.eulerAngles, num).setEase(LeanTweenType.easeInOutSine);
		LeanTween.scale(base.gameObject, originalScale, num).setEase(LeanTweenType.easeInOutSine);
		LeanTween.delayedCall(base.gameObject, num, (Action)delegate
		{
			isInView = false;
			UIDisplaySignal.Dispatch(UIEventType.Remove);
			CheckQuestStateWobble();
		});
	}

	private void OnItemPurchased()
	{
		UIDisplaySignal.Dispatch(UIEventType.Remove);
		BuyableItemData.Item itemFromId = BuyableItemData.GetItemFromId(itemId);
		bool canBuyItemMultipleTimes = false;
		if (itemFromId.shopBehavior == BuyableItemData.BuyableType.ConsumableIAP || itemFromId.shopBehavior == BuyableItemData.BuyableType.ConsumableNonIAP)
		{
			canBuyItemMultipleTimes = true;
		}
		AddItemToInventory();
		Vector3 position = boughtItemTargetPos.position;
		LeanTween.cancel(base.gameObject);
		LeanTween.scale(base.gameObject, Vector3.zero, moveToPlayerTime * 0.6f).setEase(LeanTweenType.easeInSine);
		LeanTween.move(base.gameObject, position, moveToPlayerTime).setEase(LeanTweenType.easeInOutSine).setOnComplete((Action)delegate
		{
			isInView = false;
			if (canBuyItemMultipleTimes)
			{
				ResetItem();
			}
			else
			{
				RemoveItem();
			}
		});
	}

	private void ResetItem()
	{
		selectionCollider.enabled = true;
		base.transform.position = originalPosition;
		base.transform.rotation = originalRotation;
		base.transform.localScale = originalScale;
	}

	private void RemoveItem()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private void OnEnterQuestState(QuestState questState)
	{
		CheckQuestStateWobble();
	}

	private void OnDestroy()
	{
		BuyableItemSignal.RemoveListener(OnBuyableItemsSignal);
		Quest.EnterQuestStateSignal.RemoveListener(OnEnterQuestState);
	}

	static BuyableItem()
	{
		BuyableItemSignal = new Signal<string, BuyableItemEventType, ItemType>();
	}

	protected abstract void AddBait();
}
public class BuyableLicense : BuyableItem
{
	public Location location;

	public float rotationSpeed = 0.5f;

	public override string itemId => location.ToString().ToLower();

	public override ItemType itemType => ItemType.Location;

	protected override void AddItemToInventory()
	{
		base.InventoryManager.Inventory.Licenses.Add(location);
	}

	protected override void CheckQuestStateWobble()
	{
	}

	protected override Vector3 GetInitialTransitionTargetRotation()
	{
		return default(Vector3);
	}

	protected override void RotateItem()
	{
		base.transform.Rotate(0f, 0f - rotationSpeed, 0f);
	}

	protected override void AddBait()
	{
	}
}
public class BuyableReel : BuyableItem
{
	public ReelType reelType;

	public float rotationSpeed = 0.5f;

	public override string itemId => reelType.ToString().ToLower();

	public override ItemType itemType => ItemType.Reel;

	protected override void RotateItem()
	{
		base.transform.Rotate(0f, rotationSpeed, 0f);
	}

	protected override void CheckQuestStateWobble()
	{
	}

	protected override Vector3 GetInitialTransitionTargetRotation()
	{
		return new Vector3(0f, -90f, 0f);
	}

	protected override void AddItemToInventory()
	{
		base.InventoryManager.Inventory.Reel = reelType;
	}

	protected override void AddBait()
	{
	}
}
public class BuyableRod : BuyableItem
{
	public RodType rodType;

	public float rotationSpeed = 0.01f;

	public override string itemId => rodType.ToString().ToLower();

	public override ItemType itemType => ItemType.Rod;

	protected override void RotateItem()
	{
		base.transform.Rotate(0f, 0f, rotationSpeed);
	}

	protected override void AddItemToInventory()
	{
		base.InventoryManager.Inventory.Rod = rodType;
	}

	protected override void CheckQuestStateWobble()
	{
	}

	protected override Vector3 GetInitialTransitionTargetRotation()
	{
		return new Vector3(60f, 90f, 0f);
	}

	protected override void AddBait()
	{
	}
}
public class BuyButton : GazeButton
{
	public Sprite regularBackground;

	public Sprite disabledBackground;

	protected bool isAffordable;

	protected bool isAvailable;

	private bool outOfStock;

	private bool isEquipped;

	private bool isIAP;

	private bool isLoading;

	private Image buttonBackground;

	private Text buttonInfo;

	protected bool disableAfterClick;

	[@Dependency]
	public Localization localization { get; set; }

	public bool IsAffordable
	{
		get
		{
			return isAffordable;
		}
		set
		{
			isAffordable = value;
			UpdateButtonStatus();
		}
	}

	public bool IsAvailable
	{
		get
		{
			return isAvailable;
		}
		set
		{
			isAvailable = value;
			UpdateButtonStatus();
		}
	}

	public bool IsCurrentlyEquipped
	{
		get
		{
			return isEquipped;
		}
		set
		{
			isEquipped = value;
			UpdateButtonStatus();
		}
	}

	public bool IsOutOfStock
	{
		get
		{
			return outOfStock;
		}
		set
		{
			outOfStock = value;
			UpdateButtonStatus();
		}
	}

	public bool IsIAP
	{
		get
		{
			return isIAP;
		}
		set
		{
			isIAP = value;
		}
	}

	public bool IsLoading
	{
		get
		{
			return isLoading;
		}
		set
		{
			isLoading = value;
		}
	}

	private void Awake()
	{
		this.Inject();
		buttonBackground = Find.ComponentOnChild<Image>(this, "ButtonImage");
		buttonInfo = Find.ComponentOnChild<Text>(this, "TextButtonInfo");
	}

	protected void UpdateButtonStatus()
	{
		if (isEquipped)
		{
			DisableButton(localization.GetString("GUI_ShopAlreadyEquipped"));
		}
		else if (outOfStock)
		{
			DisableButton(localization.GetString("GUI_ShopOutOfStock"));
		}
		else if (!isAvailable)
		{
			DisableButton(localization.GetString("GUI_ShopNotYetAvailable"));
		}
		else if (!isAffordable)
		{
			DisableButton(localization.GetString("GUI_ShopNotEnoughMoney"));
		}
		else
		{
			EnableButton();
		}
	}

	private void DisableButton(string str)
	{
		str = str.Replace("\\n", Environment.NewLine);
		buttonInfo.text = str;
		buttonInfo.font = localization.GetLanguageFont();
		buttonBackground.sprite = disabledBackground;
	}

	private void EnableButton()
	{
		buttonInfo.text = string.Empty;
		buttonInfo.font = localization.GetLanguageFont();
		buttonBackground.sprite = regularBackground;
	}

	public override bool IsSelectable(GameObject obj)
	{
		if (disableAfterClick)
		{
			return false;
		}
		if (isIAP)
		{
			return IsAffordable && IsAvailable && !isLoading;
		}
		return IsAffordable && IsAvailable;
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		if (isIAP)
		{
			BuyItemGUI.BuyItemGUISignal.Dispatch(BuyItemGUIEventType.OnBuyButtonIAPClicked);
		}
		else
		{
			BuyItemGUI.BuyItemGUISignal.Dispatch(BuyItemGUIEventType.OnBuyButtonClicked);
		}
		disableAfterClick = true;
		LeanTween.delayedCall(base.gameObject, 1f, (Action)delegate
		{
			disableAfterClick = false;
		});
		return PostSelectAction.WaitForLookAway;
	}

	private void OnDestroy()
	{
		LeanTween.cancel(base.gameObject);
	}
}
public class BuyItemCancelButton : GazeButton
{
	[@Dependency]
	public InputManager input { get; set; }

	private void Start()
	{
		this.Inject();
		input.AddBackButtonListener(3, BackButtonFunction);
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		BuyItemGUI.BuyItemGUISignal.Dispatch(BuyItemGUIEventType.OnCancelButtonClicked);
		return PostSelectAction.WaitForLookAway;
	}

	public CallbackResult BackButtonFunction()
	{
		if (base.gameObject.activeInHierarchy)
		{
			BuyItemGUI.BuyItemGUISignal.Dispatch(BuyItemGUIEventType.OnCancelButtonClicked);
			return CallbackResult.Consumed;
		}
		return CallbackResult.NotConsumed;
	}

	private void OnDestroy()
	{
		input.RemoveBackButtonListener(BackButtonFunction);
	}
}
public enum BuyItemGUIEventType
{
	OnBuyButtonClicked,
	OnBuyButtonIAPClicked,
	OnCancelButtonClicked
}
public class BuyItemGUI : GazeButton
{
	public static Signal<BuyItemGUIEventType> BuyItemGUISignal = new Signal<BuyItemGUIEventType>();

	private BuyButton buyButtonRegular;

	private BuyButton buyButtonIAP;

	private BuyButton buyButton;

	private Text itemHeadline;

	private Text itemHeadlineShadow;

	private Text itemDescription;

	private Text currentBalance;

	private int itemHeadlineMaxSize;

	private int itemDescriptionMaxSize;

	private int itemDescriptionMinSize;

	private GameObject balanceHolder;

	private GameObject iapNotice;

	private GameObject loader;

	private GameObject errorText;

	private BuyPriceTag priceTagRegular;

	private BuyPriceTag priceTagIAP;

	private BuyPriceTag priceTag;

	private bool startInvoked;

	[@Dependency]
	public InventoryManager InventoryManager { get; set; }

	[@Dependency]
	public BuyableItemData BuyableItemData { get; set; }

	[@Dependency]
	public Quest QuestManager { get; set; }

	[@Dependency]
	public IAPService IAPService { get; set; }

	[@Dependency]
	public Localization localization { get; set; }

	private void Awake()
	{
		this.Inject();
		buyButtonRegular = Find.ComponentOnChild<BuyButton>(this, "Canvas/BuyDialog/BuyButton");
		buyButtonRegular.IsIAP = false;
		buyButtonIAP = Find.ComponentOnChild<BuyButton>(this, "Canvas/BuyDialog/BuyButtonIAP");
		buyButtonIAP.IsIAP = true;
		priceTagRegular = Find.ComponentOnChild<BuyPriceTag>(this, "Canvas/PriceTag");
		priceTagIAP = Find.ComponentOnChild<BuyPriceTag>(this, "Canvas/PriceTagIAP");
		itemHeadline = Find.ComponentOnChild<Text>(this, "Canvas/BuyDialog/HeadlineDialog");
		itemHeadlineShadow = Find.ComponentOnChild<Text>(this, "Canvas/BuyDialog/HeadlineDialogShadow");
		itemDescription = Find.ComponentOnChild<Text>(this, "Canvas/BuyDialog/TextDescription");
		currentBalance = Find.ComponentOnChild<Text>(this, "Canvas/BuyDialog/Balance/TextBalance");
		itemHeadlineMaxSize = itemHeadline.resizeTextMaxSize;
		balanceHolder = Find.ChildByName(this, "Canvas/BuyDialog/Balance");
		iapNotice = Find.ChildByName(this, "Canvas/BuyDialog/IAPNotice");
		errorText = Find.ChildByName(this, "Canvas/BuyDialog/ErrorText");
		errorText.SetActive(value: false);
		loader = Find.ChildByName(this, "Canvas/Loader");
		itemDescription.fontSize = (int)((float)itemDescription.fontSize * localization.GetLanguageFontSizeMultiplier());
		itemHeadline.fontSize = (int)((float)itemHeadline.fontSize * localization.GetLanguageFontSizeMultiplier());
		itemHeadlineShadow.fontSize = (int)((float)itemHeadlineShadow.fontSize * localization.GetLanguageFontSizeMultiplier());
	}

	public override bool IsSelectable(GameObject obj)
	{
		return false;
	}

	public void ShowItem(string itemId)
	{
		BuyableItemData.Item itemFromId = BuyableItemData.GetItemFromId(itemId);
		int money = InventoryManager.Inventory.Money;
		string id = QuestManager.CurrentState.Id;
		bool flag = itemFromId.shopBehavior == BuyableItemData.BuyableType.BuyOnce;
		bool flag2 = itemFromId.shopBehavior == BuyableItemData.BuyableType.ConsumableNonIAP;
		bool flag3 = itemFromId.shopBehavior == BuyableItemData.BuyableType.ConsumableIAP;
		SetDisplayAsIAP(flag3);
		bool flag4 = itemFromId.questCondition == string.Empty || itemFromId.questCondition == id;
		bool isCurrentlyEquipped = false;
		bool isOutOfStock = false;
		bool isAvailable = true;
		bool isAffordable = money >= itemFromId.cost;
		string price = itemFromId.cost.ToString();
		string text = money.ToString();
		if (flag)
		{
			string text2 = InventoryManager.Inventory.Bobber.ToString().ToLower();
			string text3 = InventoryManager.Inventory.Reel.ToString().ToLower();
			string text4 = InventoryManager.Inventory.Rod.ToString().ToLower();
			bool flag5 = itemFromId.requiredItem == string.Empty || itemFromId.requiredItem == text2 || itemFromId.requiredItem == text3 || itemFromId.requiredItem == text4;
			isAvailable = itemFromId.defaultAvailable || (flag4 && flag5);
			isCurrentlyEquipped = itemFromId.id == text2 || itemFromId.id == text3 || itemFromId.id == text4;
			isOutOfStock = InventoryManager.Inventory.PurchasedItems.Contains(itemFromId.id.ToLower());
		}
		else if (flag2)
		{
			isCurrentlyEquipped = false;
			isOutOfStock = false;
			isAvailable = itemFromId.defaultAvailable || flag4;
		}
		else if (flag3)
		{
			isAffordable = true;
			isAvailable = true;
			price = string.Empty;
			text = string.Empty;
			loader.SetActive(value: true);
			buyButton.IsLoading = true;
			IAPService.GetProduct(itemId, OnGetProductsSuccess, OnGetProductsError);
		}
		buyButton.IsCurrentlyEquipped = isCurrentlyEquipped;
		buyButton.IsAffordable = isAffordable;
		buyButton.IsAvailable = isAvailable;
		buyButton.IsOutOfStock = isOutOfStock;
		SetItemHeadline(itemFromId.name);
		SetDescription(itemFromId.description);
		if (!flag3)
		{
			SetPrice(price);
			SetCurrentBalance(text);
		}
	}

	private void OnGetProductsSuccess(Product product)
	{
		SetPrice(product.FormattedPrice);
		loader.SetActive(value: false);
		errorText.SetActive(value: false);
		buyButtonIAP.gameObject.SetActive(value: true);
		itemDescription.gameObject.SetActive(value: true);
		iapNotice.SetActive(value: true);
		buyButton.IsLoading = false;
	}

	private void OnGetProductsError(string message)
	{
		UnityEngine.Debug.Log("IAP Error: " + message);
		errorText.SetActive(value: true);
		buyButtonIAP.gameObject.SetActive(value: false);
		itemDescription.gameObject.SetActive(value: false);
		iapNotice.SetActive(value: false);
		loader.SetActive(value: false);
	}

	private void SetPrice(string price)
	{
		priceTag.SetPrice(price, localization.GetLanguageFont());
	}

	private void SetItemHeadline(string name)
	{
		Text text = itemHeadline;
		itemHeadlineShadow.text = name;
		text.text = name;
		itemHeadline.font = localization.GetLanguageFont();
		itemHeadlineShadow.font = localization.GetLanguageFont();
	}

	private void SetDescription(string descr)
	{
		descr = descr.Replace("\\n", Environment.NewLine);
		if (localization.CurrentLanguangId == "ja")
		{
			descr = descr.Replace("? ", "");
			descr = descr.Replace("! ", "");
			descr = descr.Replace(". ", "");
		}
		itemDescription.text = descr;
		itemDescription.font = localization.GetLanguageFont();
	}

	private void SetCurrentBalance(string s)
	{
		currentBalance.text = s;
		currentBalance.font = localization.GetLanguageFont();
	}

	private void SetDisplayAsIAP(bool isIAP)
	{
		buyButtonRegular.gameObject.SetActive(!isIAP);
		priceTagRegular.gameObject.SetActive(!isIAP);
		buyButtonIAP.gameObject.SetActive(isIAP);
		priceTagIAP.gameObject.SetActive(isIAP);
		iapNotice.SetActive(isIAP);
		balanceHolder.SetActive(!isIAP);
		buyButton = ((!isIAP) ? buyButtonRegular : buyButtonIAP);
		priceTag = ((!isIAP) ? priceTagRegular : priceTagIAP);
		loader.SetActive(value: false);
	}
}
public class BuyItemGUIHolder : MonoBehaviour
{
	public BuyItemGUI BuyItemGuiRef;

	private void Start()
	{
		this.Inject();
		BuyableItem.BuyableItemSignal.AddListener(OnBuyableItemSignal);
	}

	private void OnBuyableItemSignal(string itemId, BuyableItemEventType eventType, BuyableItem.ItemType itemType)
	{
		switch (eventType)
		{
		case BuyableItemEventType.ShowItem:
			BuyItemGuiRef.gameObject.SetActive(value: true);
			BuyItemGuiRef.ShowItem(itemId);
			break;
		case BuyableItemEventType.ItemPurchased:
		case BuyableItemEventType.PutBackItem:
		case BuyableItemEventType.ResetItem:
			BuyItemGuiRef.gameObject.SetActive(value: false);
			break;
		}
	}

	private void OnDestroy()
	{
		BuyableItem.BuyableItemSignal.RemoveListener(OnBuyableItemSignal);
	}
}
public class BuyPriceTag : MonoBehaviour
{
	private Text PriceText;

	private Text PriceTextShadow;

	private void Awake()
	{
		PriceText = Find.ComponentOnChild<Text>(this, "TextPrice");
		PriceTextShadow = Find.ComponentOnChild<Text>(this, "TextPriceShadow");
	}

	public void SetPrice(string price, Font font)
	{
		PriceText.text = price;
		PriceText.font = font;
		PriceTextShadow.text = price;
		PriceTextShadow.font = font;
	}
}
public class IAPLoaderSpinning : MonoBehaviour
{
	public float rotationSpeed = 1f;

	private float rotation;

	private void Update()
	{
		rotation += rotationSpeed;
		base.transform.localRotation = Quaternion.Euler(0f, 0f, rotation);
	}
}
[RequireComponent(typeof(BuyableItem))]
public class LaunchShopGUIButton : GazeButton
{
	public static Signal<string, BuyableItem.ItemType> LaunchShopSignal = new Signal<string, BuyableItem.ItemType>();

	private BuyableItem ItemToLaunch;

	private string itemId;

	private BuyableItem.ItemType itemType;

	private bool UIShowing;

	private bool disabledByForceBuyItem;

	[@Dependency]
	public UIDisplayEvent UIDisplaySignal { get; set; }

	private void Start()
	{
		UIDisplaySignal.AddListener(OnUIDisplaySignal);
		ForceBuyQuestItem.ForceBuyQuestItemNotification.AddListener(OnForceBuyItemNotification);
		if (ItemToLaunch == null)
		{
			ItemToLaunch = Find.ComponentOnGameObject<BuyableItem>(this);
		}
		itemId = ItemToLaunch.itemId;
		itemType = ItemToLaunch.itemType;
	}

	public override bool IsSelectable(GameObject obj)
	{
		return !UIShowing && !disabledByForceBuyItem;
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		LaunchShopSignal.Dispatch(itemId, itemType);
		return base.OnSelect(obj);
	}

	private void OnUIDisplaySignal(UIEventType type)
	{
		switch (type)
		{
		case UIEventType.Display:
			UIShowing = true;
			break;
		case UIEventType.Remove:
			UIShowing = false;
			break;
		}
	}

	private void OnForceBuyItemNotification(ForceBuyEventType eventType)
	{
		switch (eventType)
		{
		case ForceBuyEventType.Begin:
			disabledByForceBuyItem = true;
			break;
		case ForceBuyEventType.End:
			disabledByForceBuyItem = false;
			break;
		}
	}

	public void EnableInteractionDuringForceBuy()
	{
		disabledByForceBuyItem = false;
	}

	private void OnDestroy()
	{
		if (UIDisplaySignal != null)
		{
			UIDisplaySignal.RemoveListener(OnUIDisplaySignal);
		}
		if (ForceBuyQuestItem.ForceBuyQuestItemNotification != null)
		{
			ForceBuyQuestItem.ForceBuyQuestItemNotification.RemoveListener(OnForceBuyItemNotification);
		}
	}
}
public class NPCSpeechAnimation : MonoBehaviour
{
	private Animator NPCAnimator;

	private void Start()
	{
		this.Inject();
		SpeechPlayback.SpeechAudioNotification.AddListener(OnSpeechNotification);
		NPCAnimator = Find.ComponentOnGameObject<Animator>(this);
	}

	private void OnSpeechNotification(SpeechEventType eventType)
	{
		switch (eventType)
		{
		case SpeechEventType.Start:
			NPCAnimator.SetTrigger("Talk");
			break;
		case SpeechEventType.Stop:
			NPCAnimator.SetTrigger("Idle");
			break;
		}
	}

	private void OnDestroy()
	{
		SpeechPlayback.SpeechAudioNotification.RemoveListener(OnSpeechNotification);
	}
}
public class SellButton : GazeButton
{
	public event EventHandler OnSelectEvent;

	public override PostSelectAction OnSelect(GameObject obj)
	{
		this.OnSelectEvent(this, EventArgs.Empty);
		return base.OnSelect(obj);
	}
}
public class ShopLogic : MonoBehaviour
{
	private string showingItemId;

	private BuyableItem.ItemType showingItemType;

	private bool shopIsOpen;

	[@Dependency]
	public InventoryManager InventoryManager { get; set; }

	[@Dependency]
	public BuyableItemData BuyableItemData { get; set; }

	[@Dependency]
	public Quest quest { get; set; }

	[@Dependency]
	public IAPService IAPService { get; set; }

	[@Dependency]
	public RGTracking tracking { get; set; }

	private void Start()
	{
		this.Inject();
		LaunchShopGUIButton.LaunchShopSignal.AddListener(OnLaunchShop);
		BuyItemGUI.BuyItemGUISignal.AddListener(OnBuyGUISignal);
	}

	private void OnLaunchShop(string itemId, BuyableItem.ItemType itemType)
	{
		showingItemId = itemId;
		showingItemType = itemType;
		shopIsOpen = true;
		DispatchBuyableEvent(BuyableItemEventType.ShowItem);
		tracking.TrackShopEvent("shop", "inspect_item", itemId, InventoryManager.Inventory.Money, quest.CurrentState);
	}

	private void OnBuyGUISignal(BuyItemGUIEventType eventType)
	{
		switch (eventType)
		{
		case BuyItemGUIEventType.OnBuyButtonClicked:
			ExtractCostFromWallet();
			BuyItem();
			break;
		case BuyItemGUIEventType.OnBuyButtonIAPClicked:
			IAPService.RequestBuyItem(showingItemId, OnBuyIAPSuccess, OnBuyIAPFailure);
			break;
		case BuyItemGUIEventType.OnCancelButtonClicked:
			DispatchBuyableEvent(BuyableItemEventType.PutBackItem);
			OnClose();
			break;
		}
	}

	private void OnBuyIAPSuccess(string sku)
	{
		BuyItem();
	}

	private void OnBuyIAPFailure(string message)
	{
	}

	private void ExtractCostFromWallet()
	{
		int cost = BuyableItemData.GetItemFromId(showingItemId).cost;
		InventoryManager.Inventory.Money -= cost;
	}

	private void BuyItem()
	{
		List<string> purchasedItems = InventoryManager.Inventory.PurchasedItems;
		if (!purchasedItems.Contains(showingItemId.ToLower()))
		{
			purchasedItems.Add(showingItemId.ToLower());
		}
		tracking.TrackShopEvent("shop", "buy", showingItemId, InventoryManager.Inventory.Money, quest.CurrentState);
		DispatchBuyableEvent(BuyableItemEventType.ItemPurchased);
		OnClose();
	}

	private void DispatchBuyableEvent(BuyableItemEventType eventType)
	{
		BuyableItem.BuyableItemSignal.Dispatch(showingItemId, eventType, showingItemType);
	}

	private void OnClose()
	{
		shopIsOpen = false;
	}

	private void OnDestroy()
	{
		LaunchShopGUIButton.LaunchShopSignal.RemoveListener(OnLaunchShop);
		BuyItemGUI.BuyItemGUISignal.RemoveListener(OnBuyGUISignal);
	}
}
public enum FishingRodSoundEventType
{
	StartPreCasting,
	StartCastingSimple,
	ReleaseLineAdvanded,
	AbortCasting
}
public class SinkerCasting : MonoBehaviour
{
	public enum TrackingControlScheme
	{
		Gaze,
		SimpleController,
		AdvancedController,
		FreeController
	}

	public enum FishingState
	{
		Aiming,
		PreCasting,
		Casting,
		InAir,
		InWater,
		UIVisible,
		AfterReelIn,
		Intro,
		Hidden
	}

	public static Signal<Fish, GameObject> CatchFishSignal = new Signal<Fish, GameObject>();

	public static Signal<Fish> ThrowFishSignal = new Signal<Fish>();

	public static Signal<FishingRodSoundEventType> FishingRodSoundSignal = new Signal<FishingRodSoundEventType>();

	public float throwForceMultiplier = 250f;

	public float swingBackDuration = 0.5f;

	public float swingBackAngle = -90f;

	public float swingForwardDuration = 0.4f;

	public float swingForwardAngle = 5f;

	public float swingReturnDuration = 1f;

	public float fishDangleTime = 1.2f;

	public Transform rodTip;

	protected float hookJerkThreshold = 5f;

	protected float jerkDelay = 0.4f;

	[Range(0f, 1f)]
	[Tooltip("At what point in the forward swing to release the fishing line")]
	public float releaseLineTime = 0.7f;

	public float sinkerMarkerDistanceFactor = 10f;

	public float optimalThrowingAnlge = 70f;

	public float throwingAngleRotation = 35f;

	public GameObject targetMarketPrefab;

	public Hook hook;

	public Transform gameRootTransform;

	public Camera mainCamera;

	[HideInInspector]
	public float alphaValue = 1f;

	protected Transform rodHolder;

	protected GameObject aimMarker;

	protected SpringJoint rodTipSpringJoint;

	protected Vector3 originalLocalPosition;

	protected Quaternion originalLocalRotation;

	protected float lineStrengthWhileSwinging = 100f;

	protected float lineStrengthWhileFishing = 10f;

	protected float lineStrengthWhileDangling = 20f;

	protected Vector3 throwForce;

	protected bool interactingWithUI;

	protected bool disabledByTutorial;

	protected bool baitAttached;

	protected bool rodVisible;

	protected WaitForSeconds dangleDelay;

	protected bool aimInsideBounds = true;

	protected Vector3 hideRodPositionOffset = new Vector3(1f, 0f, -3f);

	protected float hideRodTime = 0.8f;

	protected Vector3 hidePosition;

	protected Hook hookComponent;

	protected Hand hand;

	protected RodBending rodbending;

	protected Transform joint2;

	public Vector3 localRodtipPosition = Vector3.zero;

	protected Vector3 localRodtipRetractPosition = new Vector3(0.007f, 0.012f, 0.613f);

	protected Vector3 previousTipPosition;

	protected float lastJerkTime = float.MinValue;

	protected Coroutine bendTweenCoroutine;

	public FishingState currentState;

	public FishingState stateBeforeUI;

	[@Dependency]
	public FishingRodEvent FishingRodSignal { get; set; }

	[@Dependency]
	public UIDisplayEvent UIDisplaySignal { get; set; }

	[@Dependency]
	public InventoryManager InventoryManager { get; set; }

	[@Dependency]
	public Quest Quest { get; set; }

	[@Dependency]
	public RGTracking tracking { get; set; }

	[@Dependency]
	public InputManager input { get; set; }

	[@Dependency]
	public InputModeSwitchEvent GearVRInputSwitchSignal { get; set; }

	[@Dependency]
	public GameSession gameSession { get; set; }

	protected virtual void Start()
	{
		this.Inject();
		joint2 = Find.ChildTransformByName(this, "joint1/joint2");
		rodTipSpringJoint = rodTip.GetComponent<SpringJoint>();
		if (localRodtipPosition == Vector3.zero)
		{
			localRodtipPosition = rodTip.localPosition;
		}
		dangleDelay = new WaitForSeconds(fishDangleTime);
		FishingLine.ReelInDoneSignal.AddListener(OnReeInDoneSignal);
		UIDisplaySignal.AddListener(OnUIDisplay);
		Bobber.bobberHitWaterSignal.AddListener(OnBobberHitWaterSignal);
		Tutorial.StateChangeSignal.AddListener(OnTutorialStateChange);
		ControllerUnhider.ControllerHideSignal.AddListener(OnControllerHide);
		FishingRodSignal.AddListener(OnFishingRodSignal);
		GearVRInputSwitchSignal.AddListener(OnActiveControllerChanged);
		rodHolder = base.transform.parent;
		originalLocalPosition = rodHolder.GetComponent<RodHolder>().localStartPosition;
		originalLocalRotation = rodHolder.GetComponent<RodHolder>().localStartRotation;
		hidePosition = originalLocalPosition + hideRodPositionOffset;
		interactingWithUI = false;
		disabledByTutorial = false;
		baitAttached = hook.gameObject.activeInHierarchy;
		rodVisible = true;
		CatchFishSignal.AddListener(CatchFish);
		aimMarker = UnityEngine.Object.Instantiate(targetMarketPrefab, GetMarkerPosition(), Quaternion.identity);
		aimMarker.transform.parent = gameRootTransform;
		bool flag = true;
		if (Quest.IsInIntroState())
		{
			flag = false;
			currentState = FishingState.Intro;
		}
		else if (currentState == FishingState.PreCasting)
		{
			currentState = FishingState.Aiming;
			FishingRodSignal.Dispatch(FishingRodEventType.StopCasting);
		}
		else if (currentState == FishingState.AfterReelIn)
		{
			flag = false;
			CatchFish(null, null);
		}
		if (flag)
		{
			FishingRodSignal.Dispatch(FishingRodEventType.VisibleRod);
		}
		else
		{
			FishingRodSignal.Dispatch(FishingRodEventType.HideRod);
		}
		hookComponent = Find.ComponentOnGameObject<Hook>(hook);
		rodbending = Find.ComponentOnGameObject<RodBending>(this);
		if (hand == null)
		{
			rodbending.bendLimit = 0f;
		}
		else
		{
			rodbending.bendLimit = null;
		}
	}

	private void OnFishingRodSignal(FishingRodEventType type)
	{
		if (type == FishingRodEventType.StartGrab)
		{
			previousTipPosition = rodTip.position;
		}
	}

	protected virtual void LateUpdate()
	{
		bool active = ((currentState == FishingState.Aiming && GetIsAimInsideBounds()) || currentState == FishingState.PreCasting) && rodVisible && !interactingWithUI;
		aimMarker.SetActive(active);
		if (currentState == FishingState.Aiming)
		{
			UpdateMarkerPosition();
		}
		else if (currentState == FishingState.InWater && hook.HookedFish == null)
		{
			UpdateJerkHooking();
		}
	}

	protected void UpdateJerkHooking()
	{
		Vector3 position = rodTip.position;
		Vector3 position2 = hook.bobber.transform.position;
		Vector3 normalized = (position - position2).normalized;
		Vector3 vector = position - previousTipPosition;
		previousTipPosition = position;
		if (Time.time - lastJerkTime < jerkDelay)
		{
			return;
		}
		float num = Mathf.Clamp01(Vector3.Dot(normalized, vector));
		float num2 = (vector * num).magnitude / Time.deltaTime;
		if (!disabledByTutorial)
		{
			hook.bobber.GetComponent<Bobber>().JerkMotion(num2);
		}
		if (hand != null && input.IsInputEnabled() && !disabledByTutorial && num2 > hookJerkThreshold)
		{
			lastJerkTime = Time.time;
			bool flag = hook.Baitee != null;
			if (flag)
			{
				FishingRodSignal.Dispatch(FishingRodEventType.JerkRodWithFish);
			}
			else
			{
				FishingRodSignal.Dispatch(FishingRodEventType.JerkRodWithoutFish);
			}
			float num3 = ((!flag) ? 0.4f : 0.8f);
			input.RandomHaptic(num3, num3, 0.4f, hand.Handedness);
		}
	}

	protected virtual bool GetIsAimInsideBounds()
	{
		return aimInsideBounds;
	}

	public void SetHand(Hand hand)
	{
		this.hand = hand;
	}

	public bool OnReelInput(InputType type)
	{
		if (interactingWithUI || disabledByTutorial)
		{
			return false;
		}
		if (currentState == FishingState.InWater)
		{
			OnInputInWater(type);
			return true;
		}
		return false;
	}

	public void OnInput(InputAction action, InputType type)
	{
		switch (action)
		{
		case InputAction.Trigger:
			if (currentState != FishingState.InWater)
			{
				OnInput(type);
			}
			break;
		case InputAction.TouchPad:
			if (currentState == FishingState.AfterReelIn && type == InputType.KeyDown)
			{
				FishBehavior hookedFish = hook.HookedFish;
				GameObject gameObject = hookedFish.fish.gameObject;
				gameObject.transform.position = GameObject.FindGameObjectWithTag("Player").transform.position + new Vector3(-0.05f, 1.2f, 0.9f);
				gameObject.transform.localEulerAngles = new Vector3(0f, 90f, 0f);
				hookedFish.fish.ChangeAnimation(Fish.SwimAnimation.Swim, 1.5f);
				hookedFish?.fish.GetComponent<FishGrabbable>().SetFishAsCaught(hookedFish.fish, gameObject);
			}
			break;
		}
	}

	public void OnGrabbed()
	{
		if (base.transform.localScale.x != 1f)
		{
			LeanTween.cancel(joint2.gameObject);
			LeanTween.cancel(rodTip.gameObject);
			LeanTween.moveLocal(rodTip.gameObject, localRodtipPosition, 0.5f);
			if (bendTweenCoroutine != null)
			{
				StopCoroutine(bendTweenCoroutine);
			}
			float start = ((!rodbending.bendLimit.HasValue) ? 0f : rodbending.bendLimit.Value);
			bendTweenCoroutine = StartCoroutine(TweenBendLimit(start, 1f, 0.5f, 0.4f, nullAfter: true));
		}
	}

	public void OnReleased()
	{
		if (currentState == FishingState.Aiming || currentState == FishingState.UIVisible)
		{
			LeanTween.cancel(joint2.gameObject);
			LeanTween.cancel(rodTip.gameObject);
			if (bendTweenCoroutine != null)
			{
				StopCoroutine(bendTweenCoroutine);
			}
			float start = ((!rodbending.bendLimit.HasValue) ? 1f : rodbending.bendLimit.Value);
			bendTweenCoroutine = StartCoroutine(TweenBendLimit(start, 0f, 0.3f, 0f, nullAfter: false));
		}
	}

	protected IEnumerator TweenBendLimit(float start, float end, float duration, float predelay, bool nullAfter)
	{
		rodbending.StopAllCoroutines();
		yield return new WaitForSeconds(predelay);
		float timePassed = 0f;
		while (timePassed < 1f)
		{
			timePassed += Time.deltaTime / duration;
			rodbending.bendLimit = Mathf.Lerp(start, end, timePassed);
			yield return null;
		}
		if (nullAfter)
		{
			rodbending.bendLimit = null;
		}
		else
		{
			rodbending.bendLimit = end;
		}
	}

	protected virtual void OnInput(InputType type)
	{
		if (interactingWithUI || disabledByTutorial)
		{
			return;
		}
		switch (currentState)
		{
		case FishingState.Aiming:
			if (!hookComponent.BaitAttached)
			{
				hookComponent.AttachToBobber();
			}
			else if (type == InputType.KeyDown && GetIsAimInsideBounds())
			{
				StartCoroutine(Cast());
			}
			break;
		case FishingState.InWater:
			OnInputInWater(type);
			break;
		}
	}

	private void OnControllerHide(ControllerHideEventType type)
	{
		switch (type)
		{
		case ControllerHideEventType.Hidden:
			currentState = FishingState.Aiming;
			break;
		case ControllerHideEventType.Visible:
			currentState = FishingState.Hidden;
			break;
		}
	}

	private void OnUIDisplay(UIEventType type)
	{
		switch (type)
		{
		case UIEventType.Display:
			stateBeforeUI = currentState;
			currentState = FishingState.UIVisible;
			break;
		case UIEventType.Remove:
			currentState = FishingState.Aiming;
			if (stateBeforeUI == FishingState.InAir || stateBeforeUI == FishingState.Casting)
			{
				currentState = FishingState.InWater;
			}
			break;
		}
	}

	protected virtual void OnInputInWater(InputType type)
	{
		switch (type)
		{
		case InputType.KeyDown:
			if (hook.Baitee != null)
			{
				FishingRodSignal.Dispatch(FishingRodEventType.StartReelInWithFish);
				if (gameSession.GetReelMode() != 0)
				{
					FishingRodSignal.Dispatch(FishingRodEventType.StartReelInWithFishSound);
				}
			}
			else if (hook.HookedFish != null)
			{
				FishingRodSignal.Dispatch(FishingRodEventType.StartReelInWithFish);
				if (gameSession.GetReelMode() != 0)
				{
					FishingRodSignal.Dispatch(FishingRodEventType.StartReelInWithFishSound);
				}
			}
			else
			{
				FishingRodSignal.Dispatch(FishingRodEventType.StartReelInWithoutFish);
				if (gameSession.GetReelMode() != 0)
				{
					FishingRodSignal.Dispatch(FishingRodEventType.StartReelInWithoutFishSound);
				}
			}
			break;
		case InputType.KeyHold:
			break;
		case InputType.KeyUp:
			FishingRodSignal.Dispatch(FishingRodEventType.StopReelIn);
			FishingRodSignal.Dispatch(FishingRodEventType.StopReelInSound);
			break;
		}
	}

	protected virtual void OnActiveControllerChanged(InputMode inputType)
	{
		StopAllCoroutines();
		if (currentState == FishingState.InWater)
		{
			FishingRodSignal.Dispatch(FishingRodEventType.StopReelIn);
		}
		InputManager.InputSignal.RemoveListener(OnInput);
		FishingLine.ReelInDoneSignal.RemoveListener(OnReeInDoneSignal);
		UIDisplaySignal.RemoveListener(OnUIDisplay);
		Bobber.bobberHitWaterSignal.RemoveListener(OnBobberHitWaterSignal);
		Tutorial.StateChangeSignal.RemoveListener(OnTutorialStateChange);
		ControllerUnhider.ControllerHideSignal.RemoveListener(OnControllerHide);
		GearVRInputSwitchSignal.RemoveListener(OnActiveControllerChanged);
		CatchFishSignal.RemoveListener(CatchFish);
	}

	protected virtual IEnumerator Cast(float swingBackMultiplier = 1f)
	{
		currentState = FishingState.PreCasting;
		FishingRodSoundSignal.Dispatch(FishingRodSoundEventType.StartCastingSimple);
		FishingRodSignal.Dispatch(FishingRodEventType.StartCasting);
		Quaternion originalRotation = rodHolder.localRotation;
		rodTipSpringJoint.spring = lineStrengthWhileSwinging;
		Quaternion swingBackTargetRotation = originalRotation * Quaternion.AngleAxis(swingBackAngle * swingBackMultiplier, Vector3.right);
		yield return StartCoroutine(SwingFishingRod(swingBackTargetRotation, swingBackDuration));
		Quaternion swingForwardTargetRotation = originalRotation * Quaternion.AngleAxis(swingForwardAngle, Vector3.right);
		yield return StartCoroutine(SwingFishingRod(swingForwardTargetRotation, swingForwardDuration, releaseLineTime));
		yield return StartCoroutine(SwingFishingRod(originalRotation, swingReturnDuration));
	}

	private void OnReeInDoneSignal(bool fishOnHook)
	{
		FinishReelIn();
	}

	private void OnBobberHitWaterSignal(GameObject obj)
	{
		if (currentState == FishingState.Casting)
		{
			currentState = FishingState.InWater;
			hook.GetComponent<Rigidbody>().velocity = Vector3.zero;
		}
	}

	private void OnTutorialStateChange(TutorialStateType eventType)
	{
		switch (eventType)
		{
		case TutorialStateType.WaitForAttraction:
			disabledByTutorial = true;
			break;
		case TutorialStateType.FailReelin:
			break;
		case TutorialStateType.FishFight:
			disabledByTutorial = false;
			break;
		}
	}

	private void FinishReelIn()
	{
		FishBehavior hookedFish = hook.HookedFish;
		if (hookedFish != null)
		{
			currentState = FishingState.AfterReelIn;
			rodTipSpringJoint.spring = lineStrengthWhileDangling;
			hook.HookedFish.fish.GetComponent<Rigidbody>().drag = 1f;
		}
		else
		{
			currentState = FishingState.Aiming;
		}
	}

	private void CatchFish(Fish CoughtFish, GameObject fishGO)
	{
		FishBehavior hookedFish = hook.HookedFish;
		rodTipSpringJoint.spring = lineStrengthWhileFishing;
		hook.Free(hookedFish);
		hook.DetachFromBobber();
		baitAttached = false;
		currentState = FishingState.UIVisible;
		CatchDisplay.CatchDisplaySignal.AddListener(OnCatchDisplay);
	}

	private void OnCatchDisplay(CatchDisplayEventType type)
	{
		CatchDisplay.CatchDisplaySignal.RemoveListener(OnCatchDisplay);
		hook.AttachToBobber();
	}

	public void TrackCastingEvent(string castState, TrackingControlScheme castingMode, string failReason = null)
	{
		tracking.TrackCastingEvent(castState, Quest.CurrentState, castingMode, failReason);
	}

	protected virtual IEnumerator SwingFishingRod(Quaternion endRotation, float duration, float releaseTime = float.PositiveInfinity)
	{
		bool released = false;
		float startTime = Time.time;
		float progress = 0f;
		Quaternion startRotation = rodHolder.localRotation;
		while (Interpolation.ProgressOverTime(startTime, duration, ref progress))
		{
			float smoothProgress = Interpolation.EaseInEaseOut(progress, 3);
			rodHolder.localRotation = Quaternion.Lerp(startRotation, endRotation, smoothProgress);
			if (progress >= releaseTime && !released)
			{
				released = true;
				ThrowBobber();
			}
			yield return null;
		}
	}

	protected virtual void ThrowBobber()
	{
		currentState = FishingState.Casting;
	}

	public virtual void HideFishingRod()
	{
	}

	public virtual void RevealFishingRod()
	{
	}

	public virtual void SetPositionAndHide()
	{
	}

	private void UpdateMarkerPosition()
	{
		aimMarker.transform.position = GetMarkerPosition();
	}

	private Vector3 GetMarkerPosition()
	{
		float num = 0f - rodTip.transform.position.y;
		float num2 = sinkerMarkerDistanceFactor * rodTip.forward.y / (Physics.gravity.y / 2f);
		float num3 = 0f - num / (Physics.gravity.y / 2f);
		float num4 = Mathf.Pow(num2 / 2f, 2f) - num3;
		if (num4 < 0f)
		{
			return new Vector3(0f, -1E+09f, -1E+09f);
		}
		float num5 = 0f - num2 / 2f + Mathf.Sqrt(num4);
		float x = rodTip.transform.position.x + num5 * rodTip.forward.x * sinkerMarkerDistanceFactor;
		float z = rodTip.transform.position.z + num5 * rodTip.forward.z * sinkerMarkerDistanceFactor;
		return new Vector3(x, 0f, z);
	}

	protected virtual void OnDestroy()
	{
		FishingLine.ReelInDoneSignal.RemoveListener(OnReeInDoneSignal);
		UIDisplaySignal.RemoveListener(OnUIDisplay);
		Bobber.bobberHitWaterSignal.RemoveListener(OnBobberHitWaterSignal);
		Tutorial.StateChangeSignal.RemoveListener(OnTutorialStateChange);
		ControllerUnhider.ControllerHideSignal.RemoveListener(OnControllerHide);
		GearVRInputSwitchSignal.RemoveListener(OnActiveControllerChanged);
		CatchFishSignal.RemoveListener(CatchFish);
		FishingRodSignal.RemoveListener(OnFishingRodSignal);
		UnityEngine.Object.Destroy(aimMarker);
	}
}
public class SinkerCastingAdvanced : SinkerCastingSimple
{
	[Tooltip("Angle to water that the rod needs to be pulled back")]
	public float chargeAngle = 80f;

	[Range(0f, 4f)]
	public float minCastSpeed = 0.5f;

	[Tooltip("interval for the optimal casting angle, min and max")]
	public Vector2 optimalCastingInterval = new Vector2(10f, 70f);

	[Tooltip("The number of frames the speed should be avraged over")]
	public int avrageCount;

	public float minCastDistans = 3f;

	private float currentSpeed;

	private Queue<float> speedQueue = new Queue<float>();

	private Vector3 oldAngle;

	private float angleMultiplier;

	private Vector3 castingDirection = Vector3.forward;

	protected bool charged;

	protected bool failedCast;

	protected override void Start()
	{
		base.Start();
		rodRotator.lerpRotation = false;
	}

	private void Update()
	{
		float num = 0f;
		FishingState fishingState = currentState;
		if (fishingState == FishingState.PreCasting)
		{
			num = CastingAngle();
			if (!charged && num > chargeAngle)
			{
				charged = true;
			}
			else if (charged)
			{
				CalculateThrowSpeed();
			}
		}
	}

	private IEnumerator HandleInput(InputType type)
	{
		yield return null;
		switch (currentState)
		{
		case FishingState.Aiming:
			if (!hookComponent.BaitAttached)
			{
				hookComponent.AttachToBobber();
			}
			else if (type == InputType.KeyDown && GetIsAimInsideBounds())
			{
				EnterPreCast();
			}
			break;
		case FishingState.PreCasting:
			if (type == InputType.KeyUp && charged)
			{
				CastBait();
			}
			else if (type == InputType.KeyUp)
			{
				AbortCast();
			}
			break;
		default:
			base.OnInput(type);
			break;
		}
	}

	protected override void OnInput(InputType type)
	{
		if (!interactingWithUI && !disabledByTutorial && base.gameObject.activeSelf)
		{
			StartCoroutine(HandleInput(type));
		}
	}

	protected virtual void EnterPreCast()
	{
		currentState = FishingState.PreCasting;
		SinkerCasting.FishingRodSoundSignal.Dispatch(FishingRodSoundEventType.StartPreCasting);
		charged = false;
		base.FishingRodSignal.Dispatch(FishingRodEventType.StartCasting);
		rodTipSpringJoint.spring = lineStrengthWhileSwinging;
	}

	protected virtual void AbortCast()
	{
		charged = false;
		currentState = FishingState.Aiming;
		SinkerCasting.FishingRodSoundSignal.Dispatch(FishingRodSoundEventType.AbortCasting);
		TrackCastingEvent("abort_throw", TrackingControlScheme.AdvancedController);
		base.FishingRodSignal.Dispatch(FishingRodEventType.StopCasting);
		rodTipSpringJoint.spring = lineStrengthWhileDangling;
	}

	protected virtual void CastBait()
	{
		failedCast = false;
		float num = CastingAngle();
		if (!(GetAverageSpeed() > minCastSpeed) || 1 == 0 || num < -90f)
		{
			AbortCast();
			return;
		}
		if (num < optimalCastingInterval.x)
		{
			failedCast = true;
			FishBehavior.BobberHintSignal.Dispatch(BobberHintType.castTooLate);
			TrackCastingEvent("mediocre_throw", TrackingControlScheme.AdvancedController, "cast_too_late");
		}
		else if (num > optimalCastingInterval.y)
		{
			FishBehavior.BobberHintSignal.Dispatch(BobberHintType.castTooEarly);
			TrackCastingEvent("mediocre_throw", TrackingControlScheme.AdvancedController, "cast_too_early");
			failedCast = true;
		}
		SinkerCasting.FishingRodSoundSignal.Dispatch(FishingRodSoundEventType.ReleaseLineAdvanded);
		if (!failedCast)
		{
			TrackCastingEvent("successful", TrackingControlScheme.AdvancedController);
		}
		ThrowBobber();
	}

	protected void CalculateThrowSpeed()
	{
		Vector3 forward = rodHolder.forward;
		float b = Vector3.Dot(forward, oldAngle);
		b = Mathf.Min(1f, b);
		b = Mathf.Max(-1f, b);
		currentSpeed = Mathf.Acos(b) / Time.fixedDeltaTime * Mathf.Sign(Vector3.Dot(rodHolder.up, oldAngle));
		speedQueue.Enqueue(currentSpeed);
		if (speedQueue.Count > avrageCount)
		{
			speedQueue.Dequeue();
		}
		oldAngle = forward;
	}

	protected float GetAverageSpeed()
	{
		float num = 0f;
		foreach (float item in speedQueue)
		{
			num += item;
		}
		return num / (float)speedQueue.Count;
	}

	protected float CastingAngle()
	{
		float num = 0f;
		Vector3 vector = aimMarker.transform.position - rodHolder.position;
		vector = new Vector3(vector.x, 0f, vector.z);
		castingDirection = rodHolder.forward;
		num = Vector3.Angle(castingDirection, vector);
		return num * Mathf.Sign(castingDirection.y);
	}

	protected override float GetRodDistansMultiplier()
	{
		Vector3 zero = Vector3.zero;
		float num = 1f;
		if (failedCast)
		{
			Vector3 vector = new Vector3(mainCamera.transform.position.x, 0f, mainCamera.transform.position.z);
			Vector3 vector2 = aimMarker.transform.position - vector;
			Vector3 normalized = new Vector3(vector2.x, 0f, vector2.z).normalized;
			normalized *= minCastDistans;
			zero = vector + normalized;
			UnityEngine.Debug.DrawLine(vector, zero, Color.black, 100f);
			float f = (hook.bobber.transform.position - aimMarker.transform.position).sqrMagnitude - (zero - aimMarker.transform.position).sqrMagnitude;
			num = Mathf.Sign(f);
		}
		else
		{
			zero = aimMarker.transform.position;
		}
		Vector3 vector3 = zero - hook.bobber.transform.position;
		float magnitude = new Vector3(vector3.x, 0f, vector3.z).magnitude;
		return magnitude * 0.2f * num;
	}

	protected override void OnDestroy()
	{
		base.OnDestroy();
	}
}
public class SinkerCastingFree : SinkerCastingAdvanced
{
	[SerializeField]
	private float castForceMultiplier = 1f;

	private Vector3[] positionBuffer = new Vector3[15];

	protected override void Start()
	{
		base.Start();
	}

	protected override void EnterPreCast()
	{
		base.EnterPreCast();
		int i = 0;
		for (int num = positionBuffer.Length; i < num; i++)
		{
			ref Vector3 reference = ref positionBuffer[i];
			reference = Vector3.zero;
		}
	}

	protected override void LateUpdate()
	{
		base.LateUpdate();
		aimMarker.SetActive(value: false);
	}

	private void FixedUpdate()
	{
		if (currentState == FishingState.PreCasting)
		{
			PushPosition(rodTip.position);
			int i = 0;
			for (int num = positionBuffer.Length - 1; i < num; i++)
			{
				UnityEngine.Debug.DrawLine(positionBuffer[i], positionBuffer[i + 1], Color.cyan);
			}
		}
	}

	private void PushPosition(Vector3 position)
	{
		for (int num = positionBuffer.Length - 1; num > 0; num--)
		{
			ref Vector3 reference = ref positionBuffer[num];
			reference = positionBuffer[num - 1];
		}
		positionBuffer[0] = position;
	}

	protected override void InsideBounds()
	{
		aimInsideBounds = true;
	}

	protected override void CastBait()
	{
		if (hook.bobber.transform.position.y < 0.5f)
		{
			currentState = FishingState.Aiming;
			failedCast = true;
		}
		else
		{
			failedCast = false;
			SinkerCasting.FishingRodSoundSignal.Dispatch(FishingRodSoundEventType.ReleaseLineAdvanded);
			ThrowBobber();
		}
	}

	protected override void ThrowBobber()
	{
		Rigidbody component = hook.bobber.GetComponent<Rigidbody>();
		Rigidbody component2 = hook.GetComponent<Rigidbody>();
		currentState = FishingState.Casting;
		throwForce = Vector3.zero;
		for (int num = positionBuffer.Length - 1; num > 0; num--)
		{
			throwForce += (positionBuffer[num - 1] - positionBuffer[num]) / Time.fixedDeltaTime;
		}
		throwForce *= 1f / (float)positionBuffer.Length * castForceMultiplier;
		component.velocity = Vector3.zero;
		component2.velocity = Vector3.zero;
		component.velocity = throwForce;
		component2.velocity = throwForce;
		rodTipSpringJoint.spring = lineStrengthWhileFishing;
		base.FishingRodSignal.Dispatch(FishingRodEventType.ReleaseLine);
	}

	protected override void OnDestroy()
	{
		base.OnDestroy();
	}
}
public class SinkerCastingGaze : SinkerCasting
{
	private FollowRotation rodRotation;

	private bool rodRevealDone = true;

	protected override void Start()
	{
		base.Start();
		rodRotation = GetComponentInParent<FollowRotation>();
	}

	protected override bool GetIsAimInsideBounds()
	{
		return rodRotation.InsideBounds;
	}

	private float GetRodAngleMultiplier()
	{
		Vector3 to = new Vector3(rodHolder.transform.forward.x, 0f, rodHolder.transform.forward.z);
		float num = Vector3.Angle(rodHolder.forward, to);
		return (1f - Mathf.Pow(Mathf.Abs(optimalThrowingAnlge - num) / optimalThrowingAnlge, 2f)) * 2f;
	}

	private IEnumerator HandleInput(InputType type)
	{
		yield return null;
		if (currentState == FishingState.Aiming)
		{
			if (!hookComponent.BaitAttached)
			{
				hookComponent.AttachToBobber();
			}
			else if (type == InputType.KeyDown && GetIsAimInsideBounds())
			{
				float rodAngleMultiplier = GetRodAngleMultiplier();
				throwForce = Quaternion.AngleAxis(throwingAngleRotation, rodHolder.transform.right) * rodHolder.transform.forward * throwForceMultiplier * rodAngleMultiplier;
				StartCoroutine(Cast());
			}
		}
		else
		{
			base.OnInput(type);
		}
	}

	protected override void OnInput(InputType type)
	{
		if (!interactingWithUI && !disabledByTutorial && base.transform.gameObject.activeSelf && rodRevealDone)
		{
			StartCoroutine(HandleInput(type));
		}
	}

	protected override void OnActiveControllerChanged(InputMode inputType)
	{
		base.OnActiveControllerChanged(inputType);
		LeanTween.cancel(rodHolder.gameObject);
	}

	protected override void ThrowBobber()
	{
		base.ThrowBobber();
		Rigidbody component = hook.bobber.GetComponent<Rigidbody>();
		Rigidbody component2 = hook.GetComponent<Rigidbody>();
		component.velocity = Vector3.zero;
		component2.velocity = Vector3.zero;
		component.AddForce(throwForce);
		component2.AddForce(throwForce);
		rodTip.GetComponent<SpringJoint>().spring = lineStrengthWhileFishing;
		base.FishingRodSignal.Dispatch(FishingRodEventType.ReleaseLine);
		TrackCastingEvent("successful", TrackingControlScheme.Gaze);
	}

	public override void HideFishingRod()
	{
		if (rodVisible)
		{
			Quaternion quaternion = Quaternion.Inverse(Quaternion.AngleAxis(90f, new Vector3(1f, 0f, 0f)));
			base.FishingRodSignal.Dispatch(FishingRodEventType.HideRod);
			rodRevealDone = false;
			LeanTween.cancel(rodHolder.gameObject);
			LeanTween.moveLocal(rodHolder.gameObject, hidePosition, hideRodTime).setEase(LeanTweenType.easeOutSine);
			LeanTween.rotateLocal(rodHolder.gameObject, quaternion.eulerAngles, hideRodTime).setEase(LeanTweenType.easeOutSine).setOnComplete((Action)delegate
			{
				base.gameObject.SetActive(value: false);
			});
			rodVisible = false;
		}
	}

	public override void RevealFishingRod()
	{
		if (!rodVisible)
		{
			base.FishingRodSignal.Dispatch(FishingRodEventType.VisibleRod);
			rodVisible = true;
			base.gameObject.SetActive(value: true);
			LeanTween.cancel(rodHolder.gameObject);
			LeanTween.moveLocal(rodHolder.gameObject, originalLocalPosition, hideRodTime).setEase(LeanTweenType.easeOutSine);
			LeanTween.rotateLocal(rodHolder.gameObject, originalLocalRotation.eulerAngles, hideRodTime).setEase(LeanTweenType.easeOutSine).setOnComplete((Action)delegate
			{
				rodRevealDone = true;
			});
		}
	}

	public override void SetPositionAndHide()
	{
		rodHolder.localRotation = Quaternion.Inverse(Quaternion.AngleAxis(90f, new Vector3(1f, 0f, 0f)));
		rodHolder.localPosition = hidePosition;
		HideFishingRod();
	}
}
public class SinkerCastingSimple : SinkerCasting
{
	[Header("Hide Rod")]
	public float alphaHideRatio = 0.2f;

	[Header("Aim Restrictions")]
	public float angleFromCamera = 30f;

	public float distansfromCamera = 5f;

	protected RodRotator rodRotator;

	private const float alphaFadeSpeed = 4f;

	protected override void Start()
	{
		alphaValue = 1f;
		base.Start();
		rodRotator = GetComponentInParent<RodRotator>();
		if (rodRotator == null)
		{
			UnityEngine.Debug.Log("GetComponentInParent failed to find RodRotator. Fallback to manual search");
			Transform parent = base.transform;
			while (parent.parent != null)
			{
				parent = parent.parent;
				rodRotator = parent.GetComponent<RodRotator>();
				if (rodRotator != null)
				{
					break;
				}
			}
		}
		base.FishingRodSignal.AddListener(OnRelease);
	}

	protected override void LateUpdate()
	{
		if (rodVisible && alphaValue != 1f)
		{
			alphaValue = 1f;
			if (alphaValue == 1f)
			{
				base.FishingRodSignal.Dispatch(FishingRodEventType.VisibleRod);
			}
		}
		else if (!rodVisible && alphaValue != 0f)
		{
			alphaValue = 0f;
			if (alphaValue == 0f)
			{
				base.gameObject.SetActive(value: false);
			}
		}
		else if (!rodVisible && alphaValue == 0f && base.gameObject.activeSelf)
		{
			base.gameObject.SetActive(value: false);
		}
		InsideBounds();
		base.LateUpdate();
	}

	protected virtual float GetRodDistansMultiplier()
	{
		Vector3 vector = aimMarker.transform.position - hook.bobber.transform.position;
		float magnitude = new Vector3(vector.x, 0f, vector.z).magnitude;
		return magnitude * 0.2f;
	}

	private IEnumerator HandleInput(InputType type)
	{
		yield return 0;
		if (currentState == FishingState.Aiming)
		{
			if (!hookComponent.BaitAttached)
			{
				hookComponent.AttachToBobber();
			}
			else if (type == InputType.KeyDown && GetIsAimInsideBounds())
			{
				rodRotator.EnableRotator(state: false);
				StartCoroutine(Cast());
				TrackCastingEvent("successful", TrackingControlScheme.SimpleController);
			}
		}
		else
		{
			base.OnInput(type);
		}
	}

	protected override void OnInput(InputType type)
	{
		if (!interactingWithUI && !disabledByTutorial && base.gameObject.activeSelf)
		{
			StartCoroutine(HandleInput(type));
		}
	}

	protected virtual void InsideBounds()
	{
		Vector3 vector = aimMarker.transform.position - mainCamera.transform.position;
		vector = new Vector3(vector.x, 0f, vector.z);
		float num = Vector3.Angle(vector, Vector3.forward);
		aimInsideBounds = num < angleFromCamera && aimMarker.transform.position.z > distansfromCamera;
	}

	private void OnRelease(FishingRodEventType type)
	{
		if (type == FishingRodEventType.ReleaseLine)
		{
			rodRotator.EnableRotator(state: true);
		}
	}

	protected override void ThrowBobber()
	{
		base.ThrowBobber();
		Vector3 vector = aimMarker.transform.position - hook.bobber.transform.position;
		Vector3 vector2 = new Vector3(vector.x, rodHolder.transform.forward.y, vector.z);
		Vector3 normalized = vector2.normalized;
		Vector3 vector3 = Vector3.Cross(Vector3.up, normalized);
		UnityEngine.Debug.DrawLine(base.transform.position, base.transform.position + vector3 * 10f, Color.red, 100f);
		float rodDistansMultiplier = GetRodDistansMultiplier();
		Vector3 to = new Vector3(rodHolder.transform.forward.x, 0f, rodHolder.transform.forward.z);
		float num = Vector3.Angle(rodHolder.forward, to) * Mathf.Sign(rodHolder.forward.y - to.y);
		num *= 0.2f;
		throwForce = Quaternion.AngleAxis(num - 20f, vector3) * normalized * rodDistansMultiplier * throwForceMultiplier;
		Rigidbody component = hook.bobber.GetComponent<Rigidbody>();
		Rigidbody component2 = hook.GetComponent<Rigidbody>();
		component.velocity = Vector3.zero;
		component2.velocity = Vector3.zero;
		component.AddForce(throwForce);
		component2.AddForce(throwForce);
		rodTipSpringJoint.spring = lineStrengthWhileFishing;
		base.FishingRodSignal.Dispatch(FishingRodEventType.ReleaseLine);
	}

	public override void HideFishingRod()
	{
		if (rodVisible)
		{
			base.FishingRodSignal.Dispatch(FishingRodEventType.HideRod);
			rodVisible = false;
		}
	}

	public override void RevealFishingRod()
	{
		rodVisible = true;
		base.gameObject.SetActive(value: true);
	}

	public override void SetPositionAndHide()
	{
		base.FishingRodSignal.Dispatch(FishingRodEventType.HideRod);
		alphaValue = 0f;
		aimMarker.SetActive(value: false);
		base.gameObject.SetActive(value: false);
	}

	protected override void OnDestroy()
	{
		base.FishingRodSignal.RemoveListener(OnRelease);
		base.OnDestroy();
	}
}
public class SoundManager : MonoBehaviour
{
	private const string PERSIST_KEY_MUSIC_MUTED = "MusicMuted";

	private const string PERSIST_KEY_SOUND_MUTED = "SoundMuted";

	private const string MIXER_KEY_MUSIC = "MusicVolume";

	private const string MIXER_KEY_SOUND1 = "Sound1Volume";

	private const string MIXER_KEY_SOUND2 = "Sound2Volume";

	public AudioMixerSnapshot mixerSnapshot;

	public AudioMixerSnapshot UIMixerSnapshot;

	public AudioMixer MasterMixer;

	private Fish capturedFish;

	private bool fishOnAndStruggling;

	private float strugglePitchIncrease = 0.06f;

	private float struggleDefaultPitch = 1f;

	private float struggleMaxPitch = 2f;

	private float struggleCurrentPitch;

	private float reelInPitchChange = 0.4f;

	private float reelInDefaultPitch = 1f;

	private float reelInMinPitch = 0.8f;

	private float reelInCurrentPitch;

	[@Dependency]
	public FishingRodEvent FishingRodSignal { get; set; }

	[@Dependency]
	public FishODexEvent FishODexSignal { get; set; }

	[@Dependency]
	public RGTracking tracking { get; set; }

	public static bool MusicMuted { get; private set; }

	public static bool SoundsMuted { get; private set; }

	private void Start()
	{
		this.Inject();
		LoadPersistantSettings();
		FishingRodSignal.AddListener(OnFishingRodSignal);
		FishBehavior.FishSignal.AddListener(OnFishSignal);
		CatchDisplay.CatchDisplaySignal.AddListener(OnCatchDisplay);
		FishingLine.ReelInDoneSignal.AddListener(OnReelInDone);
		Bobber.bobberHitWaterSignal.AddListener(OnBobberHitWaterSignal);
		TensionMeter.TensionMeterSignal.AddListener(OnTensionmeterSingal);
		FishODexSignal.AddListener(OnFishODexSignal);
		WaterDropper.HitWaterSignal.AddListener(OnDropHitWater);
		BuyableItem.BuyableItemSignal.AddListener(OnBuyableItemInteraction);
		FishODexCallNotification.CallSignal.AddListener(OnFishODexCall);
		FishODex.SoundSignal.AddListener(OnFishOPedia);
		SettingsScreen.SoundSettingsSignal.AddListener(OnSoundManagerSignal);
		Hook.ReenableBaitNotification.AddListener(OnReenableBait);
		EndGamePopup.ShowNotification.AddListener(OnEndGamePopupNotification);
		SinkerCasting.FishingRodSoundSignal.AddListener(OnFishingRodSoundSignal);
		HitableByFish.OnFishHitSignal.AddListener(OnFishHit);
		fishOnAndStruggling = false;
		if (mixerSnapshot != null)
		{
			mixerSnapshot.TransitionTo(0.01f);
		}
		else
		{
			UnityEngine.Debug.LogWarning("No mixer AudioMixerSnapshot set in scene!");
		}
	}

	private void OnFishHit(GameObject hitObject, string soundFXName)
	{
		PlaySound(soundFXName);
	}

	private void OnFishOPedia(FishODexSoundEventType e)
	{
		switch (e)
		{
		case FishODexSoundEventType.Select:
			PlaySound("UiSoundKlick");
			break;
		case FishODexSoundEventType.Close:
			PlaySound("Uidecline");
			break;
		}
	}

	private void OnFishODexCall(Transform trans, bool calling)
	{
		if (calling)
		{
			PlaySound("RingTone");
		}
		else
		{
			FadeOutSound("RingTone", 0.3f);
		}
	}

	private void OnBuyableItemInteraction(string itemId, BuyableItemEventType eventType, BuyableItem.ItemType itemType)
	{
		switch (eventType)
		{
		case BuyableItemEventType.ShowItem:
			switch (itemType)
			{
			case BuyableItem.ItemType.Rod:
				PlaySound("RodSelect");
				break;
			case BuyableItem.ItemType.Reel:
				PlaySound("ReelSelect");
				break;
			case BuyableItem.ItemType.Bobber:
				PlaySound("BobberSelect");
				break;
			case BuyableItem.ItemType.Bait:
				PlaySound("BobberSelect");
				break;
			}
			break;
		case BuyableItemEventType.ItemPurchased:
			PlaySound("Buy");
			switch (itemType)
			{
			case BuyableItem.ItemType.Rod:
				PlaySound("RodDecline");
				break;
			case BuyableItem.ItemType.Reel:
				PlaySound("ReelDecline");
				break;
			case BuyableItem.ItemType.Bobber:
				PlaySound("BobberSelect");
				break;
			case BuyableItem.ItemType.Bait:
				PlaySound("BobberSelect");
				break;
			}
			break;
		case BuyableItemEventType.PutBackItem:
			PlaySound("Uidecline");
			switch (itemType)
			{
			case BuyableItem.ItemType.Rod:
				PlaySound("RodDecline");
				break;
			case BuyableItem.ItemType.Reel:
				PlaySound("ReelDecline");
				break;
			case BuyableItem.ItemType.Bobber:
				PlaySound("BobberDecline");
				break;
			case BuyableItem.ItemType.Bait:
				PlaySound("BobberDecline");
				break;
			}
			break;
		}
	}

	private void OnDropHitWater(Transform transform)
	{
		MasterAudio.PlaySound3DAtTransform("WaterDripCave", transform);
	}

	private void OnReenableBait()
	{
		PlaySound("BaitDrop");
	}

	private void Update()
	{
		UpdateStrugglePitch();
	}

	private void UpdateStrugglePitch()
	{
		if (fishOnAndStruggling)
		{
			struggleCurrentPitch = Mathf.Clamp(struggleCurrentPitch + strugglePitchIncrease, struggleDefaultPitch, struggleMaxPitch);
			reelInCurrentPitch = Mathf.Clamp(reelInCurrentPitch - reelInPitchChange, reelInMinPitch, reelInDefaultPitch);
		}
		else
		{
			struggleCurrentPitch = struggleDefaultPitch;
			reelInCurrentPitch = Mathf.Clamp(reelInCurrentPitch + reelInPitchChange, reelInMinPitch, reelInDefaultPitch);
		}
		MasterAudio.ChangeVariationPitch("ReelInFishFight", changeAllVariations: true, string.Empty, struggleCurrentPitch);
		MasterAudio.ChangeVariationPitch("ReelInWithFish", changeAllVariations: true, string.Empty, reelInCurrentPitch);
	}

	private void OnReelInDone(bool fishOnHook)
	{
		FadeOutSound("ReelIn", 0.1f);
		FadeOutSound("ReelInWithFish", 0.1f);
		FadeOutSound("FishSound", 0.3f);
		FadeOutSound("FishOnSurface", 0.1f);
		PlaySound("LatchReelInDone");
	}

	private void OnCatchDisplay(CatchDisplayEventType type)
	{
		switch (type)
		{
		case CatchDisplayEventType.Show:
			PlaySound("ScoreBoardWhoosh02");
			PlaySound("WoodBoardImpact");
			break;
		case CatchDisplayEventType.StartCountUp:
			PlaySound("ScoreBoardCounter");
			break;
		case CatchDisplayEventType.Record:
			PlaySound("TestBoardEventNewHighScore");
			break;
		case CatchDisplayEventType.Star1:
			PlaySound("ScoreBoardStar");
			PlaySound("ScoreBoardChimes");
			break;
		case CatchDisplayEventType.Star2:
			PlaySound("ScoreBoardStar02");
			PlaySound("ScoreBoardChimes");
			break;
		case CatchDisplayEventType.Star3:
			PlaySound("ScoreBoardStar03");
			PlaySound("ScoreBoardChimes");
			PlaySound("TestBoardEventHighScoreMusic");
			break;
		case CatchDisplayEventType.Skip:
			FadeOutSound("WoodBoardImpact", 0.3f);
			FadeOutSound("ScoreBoardWhoosh01", 0.3f);
			FadeOutSound("ScoreBoardWhoosh02", 0.3f);
			FadeOutSound("ScoreBoardCounter", 0.3f);
			FadeOutSound("TestBoardEventNewHighScore", 0.3f);
			break;
		case CatchDisplayEventType.KeepButton:
			break;
		case CatchDisplayEventType.Hide:
			PlaySound("UiSoundPowerOff");
			break;
		case CatchDisplayEventType.Shine1:
			break;
		case CatchDisplayEventType.Shine2:
			break;
		case CatchDisplayEventType.Shine3:
			break;
		}
	}

	private void OnFishSignal(FishEventType type, Fish fish)
	{
		Transform sourceTrans = fish.gameObject.transform;
		switch (type)
		{
		case FishEventType.Nibble:
			MasterAudio.PlaySound3DAtTransform("Nibble", sourceTrans);
			break;
		case FishEventType.Hook:
			MasterAudio.PlaySound3DAtTransform("FishHook", sourceTrans);
			MasterAudio.PlaySound3DAtTransform("FishSplashHook", sourceTrans);
			break;
		case FishEventType.CaptureBegin:
			capturedFish = fish;
			break;
		case FishEventType.CaptureStruggle:
			fishOnAndStruggling = true;
			PlaySound("ReelInFishFight");
			MasterAudio.PlaySound3DFollowTransform("FishSound", sourceTrans);
			FadeOutSound("FishOnSurface", 0.3f);
			break;
		case FishEventType.CaptureFatigue:
			fishOnAndStruggling = false;
			FadeOutSound("FishSound", 0.3f);
			FadeOutSound("ReelInFishFight", 0.3f);
			break;
		case FishEventType.PullUpFromWater:
			fishOnAndStruggling = false;
			MasterAudio.PlaySound3DAtTransform("Splash01", sourceTrans);
			FadeOutSound("FishSound", 0.3f);
			FadeOutSound("FishOnSurface", 0.3f);
			PlaySound("FishShake");
			break;
		case FishEventType.FallIntoWater:
			MasterAudio.PlaySound3DAtTransform("Splash01", sourceTrans);
			break;
		case FishEventType.FallOnBeach:
			MasterAudio.PlaySound3DAtTransform("Splash02", sourceTrans);
			break;
		case FishEventType.CaptureEnd:
			capturedFish = null;
			break;
		case FishEventType.EscapeHook:
			fishOnAndStruggling = false;
			PlaySound("latch");
			PlaySound("string_snap");
			FadeOutSound("FishSound", 0.3f);
			FadeOutSound("ReelInFishFight", 0.3f);
			FadeOutSound("FishOnSurface", 0.3f);
			break;
		case FishEventType.MoveAwayFromSinker:
			break;
		}
	}

	private void OnFishingRodSignal(FishingRodEventType type)
	{
		switch (type)
		{
		case FishingRodEventType.StartCasting:
			break;
		case FishingRodEventType.ReleaseLine:
			break;
		case FishingRodEventType.StartReelInWithFish:
			if (capturedFish != null)
			{
				MasterAudio.PlaySound3DFollowTransform("FishOnSurface", capturedFish.transform);
			}
			break;
		case FishingRodEventType.StartReelInWithFishSound:
			PlaySound("ReelInWithFish");
			break;
		case FishingRodEventType.StartReelInWithoutFish:
			FadeOutSound("ReelInFishFight", 0.3f);
			break;
		case FishingRodEventType.StartReelInWithoutFishSound:
			PlaySound("ReelIn");
			break;
		case FishingRodEventType.StartAutoReelIn:
			FadeOutSound("ReelInWithFish", 0.1f);
			FadeOutSound("FishOnSurface", 0.3f);
			FadeOutSound("ReelInFishFight", 0.3f);
			break;
		case FishingRodEventType.StopReelIn:
			FadeOutSound("FishOnSurface", 0.3f);
			FadeOutSound("ReelIn", 0.1f);
			FadeOutSound("ReelInWithFish", 0.1f);
			break;
		case FishingRodEventType.StopReelInSound:
			FadeOutSound("ReelIn", 0.1f);
			FadeOutSound("ReelInWithFish", 0.1f);
			break;
		case FishingRodEventType.JerkRodWithFish:
		case FishingRodEventType.JerkRodWithoutFish:
		case FishingRodEventType.StopCasting:
		case FishingRodEventType.HideRod:
		case FishingRodEventType.VisibleRod:
		case FishingRodEventType.StopCranking:
			break;
		}
	}

	private void OnFishingRodSoundSignal(FishingRodSoundEventType type)
	{
		switch (type)
		{
		case FishingRodSoundEventType.StartPreCasting:
			PlaySound("LatchReelInDone");
			break;
		case FishingRodSoundEventType.StartCastingSimple:
			PlaySound("WhooshCastReel2");
			PlaySound("WhooshCastReel");
			PlaySound("CastReelOut");
			PlaySound("LatchReelInDone");
			break;
		case FishingRodSoundEventType.ReleaseLineAdvanded:
			PlaySound("LatchReelInDone");
			PlaySound("CastReelOutAdvanced");
			break;
		case FishingRodSoundEventType.AbortCasting:
			PlaySound("LatchReelInDone");
			break;
		}
	}

	private void OnTensionmeterSingal(TensionMeter.TensionMeterEventType type)
	{
		switch (type)
		{
		case TensionMeter.TensionMeterEventType.StartCreeking:
			PlaySound("Creak_test_02");
			break;
		case TensionMeter.TensionMeterEventType.StopCreeking:
			FadeOutSound("Creak_test_02", 0.3f);
			break;
		case TensionMeter.TensionMeterEventType.Full:
			break;
		}
	}

	private void OnBobberHitWaterSignal(GameObject bobber)
	{
		FadeOutSound("CastReelOut", 0.1f);
		FadeOutSound("CastReelOutAdvanced", 0.1f);
		MasterAudio.PlaySound3DAtTransform("BobberHitWater", bobber.transform);
	}

	private void OnFishODexSignal(FishODexEventType eventType, Transform transform)
	{
		switch (eventType)
		{
		case FishODexEventType.Open:
			MasterAudio.PlaySound3DAtVector3AndForget("UiSoundPowerOn", transform.position);
			MasterAudio.PlaySound3DAtVector3AndForget("UiSoundstatic", transform.position);
			if (UIMixerSnapshot != null)
			{
				UIMixerSnapshot.TransitionTo(0.2f);
			}
			else
			{
				UnityEngine.Debug.LogWarning("No UIMixer AudioMixerSnapshot set in scene!");
			}
			break;
		case FishODexEventType.Close:
			MasterAudio.PlaySound3DAtVector3AndForget("UiSoundPowerOff", transform.position);
			FadeOutSound("UiSoundstatic", 0.3f);
			if (mixerSnapshot != null)
			{
				mixerSnapshot.TransitionTo(0.4f);
			}
			else
			{
				UnityEngine.Debug.LogWarning("No mixer AudioMixerSnapshot set in scene!");
			}
			break;
		case FishODexEventType.ItemHover:
			MasterAudio.PlaySound3DAtVector3AndForget("UiSoundHoover", transform.position);
			break;
		case FishODexEventType.ItemSelect:
			MasterAudio.PlaySound3DAtVector3AndForget("UiSoundKlick", transform.position);
			break;
		case FishODexEventType.GoBack:
			PlaySound("Uidecline");
			break;
		case FishODexEventType.Scroll:
			PlaySound("WhooshCastReel2");
			break;
		}
	}

	private void OnEndGamePopupNotification(bool show)
	{
		if (show)
		{
			PlaySound("Winning_game_music_stinger");
			PlaySound("test_board_event_new_high_score");
		}
	}

	private void PlaySound(string name)
	{
		MasterAudio.PlaySound(name);
	}

	private void FadeOutSound(string name, float fadeTime)
	{
		MasterAudio.FadeOutAllOfSound(name, fadeTime);
	}

	private void ChangePlaylistByName(string name)
	{
		MasterAudio.ChangePlaylistByName(name);
	}

	private void OnDestroy()
	{
		FishingRodSignal.RemoveListener(OnFishingRodSignal);
		FishBehavior.FishSignal.RemoveListener(OnFishSignal);
		CatchDisplay.CatchDisplaySignal.RemoveListener(OnCatchDisplay);
		FishingLine.ReelInDoneSignal.RemoveListener(OnReelInDone);
		Bobber.bobberHitWaterSignal.RemoveListener(OnBobberHitWaterSignal);
		TensionMeter.TensionMeterSignal.RemoveListener(OnTensionmeterSingal);
		FishODexSignal.RemoveListener(OnFishODexSignal);
		WaterDropper.HitWaterSignal.RemoveListener(OnDropHitWater);
		BuyableItem.BuyableItemSignal.RemoveListener(OnBuyableItemInteraction);
		FishODexCallNotification.CallSignal.RemoveListener(OnFishODexCall);
		FishODex.SoundSignal.RemoveListener(OnFishOPedia);
		SinkerCasting.FishingRodSoundSignal.RemoveListener(OnFishingRodSoundSignal);
	}

	private void OnSoundManagerSignal(SoundSettingsEventType type)
	{
		switch (type)
		{
		case SoundSettingsEventType.SavePersistantSettings:
			SavePersistantSettings();
			break;
		case SoundSettingsEventType.LoadPersistantSettings:
			LoadPersistantSettings();
			break;
		case SoundSettingsEventType.MuteMusic:
			SetMusicMuted(isMuted: true);
			break;
		case SoundSettingsEventType.UnmuteMusic:
			SetMusicMuted(isMuted: false);
			break;
		case SoundSettingsEventType.MuteSounds:
			SetSoundsMuted(isMuted: true);
			break;
		case SoundSettingsEventType.UnmuteSounds:
			SetSoundsMuted(isMuted: false);
			break;
		}
	}

	private void SavePersistantSettings()
	{
		PlayerPrefs.SetInt("MusicMuted", MusicMuted ? 1 : 0);
		PlayerPrefs.SetInt("SoundMuted", SoundsMuted ? 1 : 0);
	}

	private void LoadPersistantSettings()
	{
		bool isMuted = PlayerPrefs.HasKey("MusicMuted") && PlayerPrefs.GetInt("MusicMuted") == 1;
		bool isMuted2 = PlayerPrefs.HasKey("SoundMuted") && PlayerPrefs.GetInt("SoundMuted") == 1;
		SetMusicMuted(isMuted, fromStartup: true);
		SetSoundsMuted(isMuted2, fromStartup: true);
	}

	private void SetMusicMuted(bool isMuted, bool fromStartup = false)
	{
		MusicMuted = isMuted;
		MasterMixer.SetFloat("MusicVolume", (!isMuted) ? 0f : (-80f));
		if (fromStartup)
		{
		}
	}

	private void SetSoundsMuted(bool isMuted, bool fromStartup = false)
	{
		SoundsMuted = isMuted;
		MasterMixer.SetFloat("Sound1Volume", (!isMuted) ? 0f : (-80f));
		MasterMixer.SetFloat("Sound2Volume", (!isMuted) ? 0f : (-80f));
		if (!fromStartup)
		{
			tracking.TrackSettingsEvent("sound", (!SoundsMuted) ? "ON" : "OFF");
		}
	}
}
public class EnterGamePlayScene : MonoBehaviour
{
	public static Signal<string> Enter = new Signal<string>();

	private void Awake()
	{
		Enter.Dispatch(SceneManager.GetActiveScene().name);
	}
}
public class Startup : MonoBehaviour
{
	public string startScene = "MainMenu";

	private void Start()
	{
		SceneManager.LoadScene(startScene);
	}
}
public class BaitJar : MonoBehaviour
{
	public BaitType baitType;

	public float wobbleSpeed = 5f;

	public float wobbleMagnitude = 0.1f;

	private Vector3 originalScale;

	private bool wobble;

	[@Dependency]
	public Quest Quest { get; set; }

	private void Start()
	{
		this.Inject();
		Quest.EnterQuestStateSignal.AddListener(OnEnterQuestState);
		BuyableItem.BuyableItemSignal.AddListener(OnBuyableItemInteraction);
		originalScale = base.transform.localScale;
		wobble = InWobbleQuestState(Quest.CurrentState);
	}

	private void OnBuyableItemInteraction(string itemId, BuyableItemEventType eventType, BuyableItem.ItemType itemType)
	{
		if (!(itemId != baitType.ToString()) && InWobbleQuestState(Quest.CurrentState))
		{
			switch (eventType)
			{
			case BuyableItemEventType.ShowItem:
				wobble = false;
				break;
			case BuyableItemEventType.ItemPurchased:
				break;
			case BuyableItemEventType.PutBackItem:
				wobble = true;
				break;
			}
		}
	}

	private void Update()
	{
		if (wobble)
		{
			base.transform.localScale = originalScale * (1f + Mathf.Sin(Time.timeSinceLevelLoad * wobbleSpeed) * wobbleMagnitude);
		}
	}

	private void OnEnterQuestState(QuestState questState)
	{
		wobble = InWobbleQuestState(questState);
	}

	private bool InWobbleQuestState(QuestState questState)
	{
		if (questState.Condition is BuyBaitCondition buyBaitCondition && buyBaitCondition.BaitType == baitType)
		{
			return true;
		}
		base.transform.localScale = originalScale;
		return false;
	}

	private void OnDestroy()
	{
		Quest.EnterQuestStateSignal.RemoveListener(OnEnterQuestState);
		BuyableItem.BuyableItemSignal.RemoveListener(OnBuyableItemInteraction);
	}
}
public class DharmaUpgradeBait : MonoBehaviour
{
	public string upgradeQuestId = "TalkToDarma07";

	public BaitType newDefaultBait = BaitType.Bait1QuestUpgrade;

	[@Dependency]
	public Quest Quest { get; set; }

	[@Dependency]
	public InventoryManager InventoryManager { get; set; }

	private void Start()
	{
		this.Inject();
		if (Quest.CurrentState.Id == upgradeQuestId && InventoryManager.Inventory.DefaultBait != newDefaultBait)
		{
			UpgradeDefaultBait();
		}
	}

	private void UpgradeDefaultBait()
	{
		InventoryManager.Inventory.DefaultBait = newDefaultBait;
		InventoryManager.Inventory.CurrentBait = newDefaultBait;
	}
}
public class EndGamePopup : MonoBehaviour
{
	public static Signal<bool> ShowNotification = new Signal<bool>();

	public Canvas canvas;

	public Text textComponent;

	public Text header;

	public Image banner;

	public Image backGround;

	public Image OkButton;

	public Image thumb;

	public Image star;

	public GameObject konfettiParticlesPrefab;

	public Image trumpetInnerLeft;

	public Image trumpetMiddleLeft;

	public Image trumpetOuterLeft;

	public Image trumpetInnerRight;

	public Image trumpetMiddleRight;

	public Image trumpetOuterRight;

	private Vector3 bannerTargetPosition;

	[@Dependency]
	public Quest Quest { get; set; }

	[@Dependency]
	public InventoryManager InventoryManager { get; set; }

	[@Dependency]
	public UIDisplayEvent UIDisplayNotification { get; set; }

	[@Dependency]
	public GameSession gameSession { get; set; }

	[@Dependency]
	public Localization localization { get; set; }

	private void Start()
	{
		this.Inject();
		bannerTargetPosition = banner.transform.localPosition;
		canvas.gameObject.SetActive(value: false);
		Quest.EnterQuestStateSignal.AddListener(OnEnterQuestState);
		EndGamePopupButton.ClickNotification.AddListener(OnOkButtonClick);
		textComponent.fontSize = (int)((float)textComponent.fontSize * localization.GetLanguageFontSizeMultiplier());
	}

	private IEnumerator Show()
	{
		yield return null;
		UIDisplayNotification.Dispatch(UIEventType.Display);
		ShowNotification.Dispatch(item: true);
		canvas.gameObject.SetActive(value: true);
		SetStartProperties();
		AnimateBanner();
		AnimateTextBox();
	}

	private void SetTextParameters()
	{
		string arg = gameSession.GetNumUniqueCaughtQuestFish().ToString();
		string arg2 = FishRegistry.Instance.QuestFishes.Count.ToString();
		string arg3 = InventoryManager.Inventory.GetNumThreeStarFishes().ToString();
		string text = localization.GetString("GUI_EndGameText");
		if (localization.CurrentLanguangId == "ja")
		{
			text = text.Replace("? ", "");
			text = text.Replace("! ", "");
			text = text.Replace(". ", "");
		}
		textComponent.font = localization.GetLanguageFont();
		textComponent.text = string.Format(text, arg, arg2, arg3);
		textComponent.resizeTextMinSize = (int)((float)textComponent.resizeTextMinSize * localization.GetLanguageFontSizeMultiplier());
	}

	private void OnEnterQuestState(QuestState questState)
	{
		if (questState.Id == "FinishedGame")
		{
			StartCoroutine(Show());
		}
	}

	private void OnOkButtonClick()
	{
		Find.ComponentOnGameObject<EndGamePopupButton>(OkButton).Selectable = false;
		LeanTween.scale(base.gameObject, new Vector3(0.1f, 0.1f, 0.1f), 0.5f).setEase(LeanTweenType.easeInSine).setOnComplete((Action)delegate
		{
			ShowNotification.Dispatch(item: false);
			UIDisplayNotification.Dispatch(UIEventType.Remove);
			base.gameObject.SetActive(value: false);
			UnityEngine.Object.Destroy(base.gameObject);
		});
	}

	private void SetStartProperties()
	{
		Vector3 localScale = new Vector3(0.1f, 0.1f, 0.1f);
		trumpetInnerLeft.transform.localScale = localScale;
		trumpetInnerRight.transform.localScale = localScale;
		trumpetMiddleLeft.transform.localScale = localScale;
		trumpetMiddleRight.transform.localScale = localScale;
		trumpetOuterLeft.transform.localScale = localScale;
		trumpetOuterRight.transform.localScale = localScale;
		trumpetInnerLeft.gameObject.SetActive(value: false);
		trumpetInnerRight.gameObject.SetActive(value: false);
		trumpetMiddleLeft.gameObject.SetActive(value: false);
		trumpetMiddleRight.gameObject.SetActive(value: false);
		trumpetOuterLeft.gameObject.SetActive(value: false);
		trumpetOuterRight.gameObject.SetActive(value: false);
		thumb.gameObject.SetActive(value: false);
		star.gameObject.SetActive(value: false);
		star.transform.localScale = new Vector3(0.01f, 0.01f, 0.01f);
		banner.transform.localPosition += new Vector3(0f, 300f, 0f);
		backGround.transform.localScale = new Vector3(0.1f, 0.1f, 1f);
		OkButton.transform.localScale = new Vector3(0.8f, 0.8f, 0.8f);
		OkButton.gameObject.SetActive(value: false);
		textComponent.gameObject.SetActive(value: false);
		header.gameObject.SetActive(value: false);
	}

	private void AnimateOkButton()
	{
		OkButton.gameObject.SetActive(value: true);
		LeanTween.scale(OkButton.gameObject, new Vector3(1f, 1f, 1f), 1.5f).setEase(LeanTweenType.easeOutSine).setOnComplete((Action)delegate
		{
			Find.ComponentOnGameObject<EndGamePopupButton>(OkButton).Selectable = true;
		});
	}

	private void AnimateBanner()
	{
		LeanTween.moveLocal(banner.gameObject, bannerTargetPosition, 0.5f).setEase(LeanTweenType.easeOutSine).setOnComplete((Action)delegate
		{
			LeanTween.delayedCall(0.5f, AnimateTrumpets);
		});
	}

	private void SpawnKonfettiParticles()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(konfettiParticlesPrefab, canvas.transform.position - new Vector3(0f, 0f, 0f), Quaternion.identity);
		gameObject.transform.parent = canvas.transform;
	}

	private void AnimateThumb()
	{
		thumb.gameObject.SetActive(value: true);
		Vector3 to = thumb.transform.localPosition + new Vector3(0f, -25f, 0f);
		LeanTween.moveLocal(thumb.gameObject, to, 0.8f).setLoopPingPong().setEase(LeanTweenType.easeInOutSine);
		SpawnKonfettiParticles();
	}

	private void AnimateTrumpets()
	{
		float trumpetAnimationTime = 0.2f;
		Vector3 trumpetPingPongOffset = new Vector3(1f, 5f, 0f);
		trumpetInnerLeft.gameObject.SetActive(value: true);
		LeanTween.scale(trumpetInnerLeft.gameObject, Vector3.one, trumpetAnimationTime).setEase(LeanTweenType.easeOutSine).setOnComplete((Action)delegate
		{
			LeanTween.moveLocal(trumpetInnerLeft.gameObject, trumpetInnerLeft.transform.localPosition + trumpetPingPongOffset, 0.8f).setLoopPingPong().setEase(LeanTweenType.easeInOutSine);
			trumpetMiddleLeft.gameObject.SetActive(value: true);
			LeanTween.scale(trumpetMiddleLeft.gameObject, Vector3.one, trumpetAnimationTime).setEase(LeanTweenType.easeOutSine).setOnComplete((Action)delegate
			{
				LeanTween.moveLocal(trumpetMiddleLeft.gameObject, trumpetMiddleLeft.transform.localPosition + trumpetPingPongOffset, 0.8f).setLoopPingPong().setEase(LeanTweenType.easeInOutSine);
				trumpetOuterLeft.gameObject.SetActive(value: true);
				LeanTween.scale(trumpetOuterLeft.gameObject, Vector3.one, trumpetAnimationTime).setEase(LeanTweenType.easeOutSine).setOnComplete((Action)delegate
				{
					LeanTween.moveLocal(trumpetOuterLeft.gameObject, trumpetOuterLeft.transform.localPosition + trumpetPingPongOffset, 0.8f).setLoopPingPong().setEase(LeanTweenType.easeInOutSine);
				});
			});
		});
		trumpetInnerRight.gameObject.SetActive(value: true);
		LeanTween.scale(trumpetInnerRight.gameObject, Vector3.one, trumpetAnimationTime).setEase(LeanTweenType.easeOutSine).setOnComplete((Action)delegate
		{
			LeanTween.moveLocal(trumpetInnerRight.gameObject, trumpetInnerRight.transform.localPosition + trumpetPingPongOffset, 0.8f).setLoopPingPong().setEase(LeanTweenType.easeInOutSine);
			trumpetMiddleRight.gameObject.SetActive(value: true);
			LeanTween.scale(trumpetMiddleRight.gameObject, Vector3.one, trumpetAnimationTime).setEase(LeanTweenType.easeOutSine).setOnComplete((Action)delegate
			{
				LeanTween.moveLocal(trumpetMiddleRight.gameObject, trumpetMiddleRight.transform.localPosition + trumpetPingPongOffset, 0.8f).setLoopPingPong().setEase(LeanTweenType.easeInOutSine);
				trumpetOuterRight.gameObject.SetActive(value: true);
				LeanTween.scale(trumpetOuterRight.gameObject, Vector3.one, trumpetAnimationTime).setEase(LeanTweenType.easeOutSine).setOnComplete((Action)delegate
				{
					LeanTween.moveLocal(trumpetOuterRight.gameObject, trumpetOuterRight.transform.localPosition + trumpetPingPongOffset, 0.8f).setLoopPingPong().setEase(LeanTweenType.easeInOutSine);
					AnimateThumb();
				});
			});
		});
	}

	private void AnimateTextBox()
	{
		LeanTween.scale(backGround.gameObject, new Vector3(1f, 1f, 1f), 1f).setEase(LeanTweenType.easeInOutCubic).setOnComplete((Action)delegate
		{
			textComponent.gameObject.SetActive(value: true);
			header.gameObject.SetActive(value: true);
			SetTextParameters();
			AnimateStar();
			AnimateOkButton();
		});
	}

	private void AnimateStar()
	{
		star.gameObject.SetActive(value: true);
		LeanTween.scale(star.gameObject, Vector3.one, 0.8f).setEase(LeanTweenType.easeOutSine);
		LeanTween.rotateZ(star.gameObject, 180f, 12f).setRepeat(9999);
	}

	private void OnDestroy()
	{
		canvas.gameObject.SetActive(value: false);
		Quest.EnterQuestStateSignal.RemoveListener(OnEnterQuestState);
		EndGamePopupButton.ClickNotification.RemoveListener(OnOkButtonClick);
	}
}
public class EndGamePopupButton : GazeButton
{
	public static Signal ClickNotification = new Signal();

	public bool Selectable { get; set; }

	public override bool IsSelectable(GameObject obj)
	{
		return Selectable;
	}

	public override PostSelectAction OnSelect(GameObject obj)
	{
		ClickNotification.Dispatch();
		return PostSelectAction.WaitForLookAway;
	}
}
public class ShopKeeper02Interaction : ShopKeeperInteraction
{
	private bool disabledByForceBuyItem;

	protected override string QuestDialog => base.quest.CurrentState.ShopKeeper02Dialog;

	public override void Start()
	{
		base.Start();
		ForceBuyQuestItem.ForceBuyQuestItemNotification.AddListener(OnForceBuyItemNotification);
	}

	public override bool IsSelectable(GameObject obj)
	{
		return !disabledByForceBuyItem && !isHavingDialog && !showingOtherUI;
	}

	private void OnForceBuyItemNotification(ForceBuyEventType eventType)
	{
		switch (eventType)
		{
		case ForceBuyEventType.Begin:
		case ForceBuyEventType.BuyItem:
			disabledByForceBuyItem = true;
			break;
		case ForceBuyEventType.End:
			disabledByForceBuyItem = false;
			break;
		}
	}

	protected override void OnDestroy()
	{
		ForceBuyQuestItem.ForceBuyQuestItemNotification.RemoveListener(OnForceBuyItemNotification);
		base.OnDestroy();
	}
}
public class SpeechAnimation : DialogView
{
	public Animator characterAnimator;

	public string characterId;

	public override void Clear()
	{
		characterAnimator.SetTrigger("Idle");
	}

	public override void Say(Dialog.Line line, LineContext context)
	{
		if (line.speaker == characterId)
		{
			characterAnimator.SetTrigger("Talk");
		}
		else
		{
			characterAnimator.SetTrigger("Idle");
		}
	}
}
public class GodRayDust : MonoBehaviour
{
	public int materialIndex;

	public Vector2 uvAnimationRate = new Vector2(1f, 0f);

	public string textureName = "_MainTex";

	private Renderer dustRenderer;

	private Vector2 uvOffset = Vector2.zero;

	private void Start()
	{
		dustRenderer = GetComponent<Renderer>();
	}

	private void Update()
	{
		uvOffset += uvAnimationRate * Time.deltaTime;
		dustRenderer.material.SetTextureOffset("_MainTex", uvOffset);
	}
}
public struct Swimming
{
	public readonly Transform transform;

	public Vector2 targetPoint;

	private bool sprinting;

	private const float turnSpeed = 2.22f;

	public float minDistance;

	private const float physicsTurnSpeed = 25f;

	public Swimming(Transform swimmingObject, Vector2 targetPoint)
	{
		transform = swimmingObject;
		this.targetPoint = targetPoint;
		sprinting = true;
		minDistance = 5f;
	}

	public void UpdateKinematic(float maxSpeed)
	{
		CalculateDeltas(out var wantedRotation, out var speedFactor);
		sprinting = speedFactor >= 1f;
		float y = transform.rotation.eulerAngles.y;
		float f = Mathf.DeltaAngle(y, wantedRotation);
		float maxDelta = Mathf.Abs(f) * Time.deltaTime * 2.22f;
		y = Mathf.MoveTowardsAngle(y, wantedRotation, maxDelta);
		transform.rotation = Quaternion.Euler(0f, y, 0f);
		float num = speedFactor * maxSpeed * Time.deltaTime;
		float f2 = y * ((float)Math.PI / 180f);
		transform.position += new Vector3(Mathf.Sin(f2) * num, 0f, Mathf.Cos(f2) * num);
	}

	public void UpdatePhysics(Rigidbody body, float maxForce)
	{
		float y = transform.rotation.eulerAngles.y;
		CalculateDeltas(out var wantedRotation, out var speedFactor);
		sprinting = speedFactor >= 1f;
		y = Mathf.MoveTowardsAngle(y, wantedRotation, 25f);
		body.MoveRotation(Quaternion.Euler(0f, y, 0f));
		body.AddForce(transform.forward * speedFactor * maxForce);
		UnityEngine.Debug.DrawLine(transform.position, new Vector3(targetPoint.x, transform.position.y, targetPoint.y), (!sprinting) ? Color.gray : Color.yellow);
	}

	public bool IsSlowingDown()
	{
		return !sprinting;
	}

	public bool HasArrived()
	{
		Vector3 vector = targetPoint;
		vector.y = transform.position.y;
		return (transform.position - vector).sqrMagnitude < 1f;
	}

	public static Vector2 PositionTo2D(Vector3 p)
	{
		return new Vector2(p.x, p.z);
	}

	private void CalculateDeltas(out float wantedRotation, out float speedFactor)
	{
		Vector2 vector = targetPoint - GetCurrentPosition();
		wantedRotation = Mathf.Atan2(vector.x, vector.y) * 57.29578f;
		float sqrMagnitude = vector.sqrMagnitude;
		if (sqrMagnitude >= minDistance * minDistance)
		{
			speedFactor = 1f;
			return;
		}
		float num = Mathf.Sqrt(sqrMagnitude);
		speedFactor = num / minDistance;
	}

	private Vector2 GetCurrentPosition()
	{
		Vector3 position = transform.position;
		return new Vector2(position.x, position.z);
	}
}
public enum UIEventType
{
	StartGaze,
	StopGaze,
	Display,
	Remove
}
public class UIDisplayEvent : Signal<UIEventType>
{
}
public class UIGroundGazeBuffer : GazeButton
{
	public override bool IsSelectable(GameObject obj)
	{
		return false;
	}
}
public class VaryParticlesByHeight : MonoBehaviour
{
	public float middleY;

	public float height = 0.6f;

	public float falloff = 2f;

	private ParticleSystem particles;

	private float maxEmissionRate;

	private float emissionRate
	{
		get
		{
			return particles.emission.rateOverTime.constant;
		}
		set
		{
			ParticleSystem.EmissionModule emission = particles.emission;
			emission.rateOverTime = value;
		}
	}

	private void Start()
	{
		particles = GetComponent<ParticleSystem>();
		maxEmissionRate = emissionRate;
	}

	private void Update()
	{
		float y = base.transform.position.y;
		float num = height / 2f;
		float f = (middleY - y) / num;
		float num2 = 1f - Mathf.Pow(f, falloff);
		emissionRate = num2 * maxEmissionRate;
	}
}
[RequireComponent(typeof(FlatPolygon))]
public class WaterArea : SingleInstanceBehavior<WaterArea>
{
	private FlatPolygon polygon;

	public override void Awake()
	{
		base.Awake();
		polygon = Find.ComponentOnGameObject<FlatPolygon>(this);
	}

	public bool IsInside(Vector3 point)
	{
		return polygon.IsPointInside(point);
	}
}
public class IAPDebug : MonoBehaviour
{
	private static string debugText = string.Empty;

	private static bool exists;

	private static Text text;

	public static void Debug(string str)
	{
		debugText = str + "\n" + debugText;
		if (exists)
		{
			Print(str);
		}
	}

	private void Awake()
	{
		text = GetComponentInChildren<Text>();
		exists = true;
	}

	private void Start()
	{
		MonoBehaviour.print(debugText);
	}

	private static void Print(string str)
	{
		text.text = debugText;
	}

	private void OnDestroy()
	{
		exists = false;
		debugText = string.Empty;
	}
}
public class IAPInitBehaviour : MonoBehaviour
{
	[@Dependency]
	private IAPService IAPService { get; set; }

	private void Start()
	{
		this.Inject();
	}
}
public class IAPService
{
	private Quest quest;

	private BuyableItemData buyableItemData;

	private InventoryManager inventoryManager;

	private RGTracking tracking;

	private bool initialized;

	private const string SDKinitErrorMsg = "Unable to initialize Oculus Platform SDK";

	private const string getProductErrorMsg = "No product found with sku {0}";

	private readonly string[] availableProducts;

	private ProductList cachedProducts;

	public IAPService(BuyableItemData buyableItemData, InventoryManager inventoryManager, Quest quest, RGTracking tracking)
	{
		this.buyableItemData = buyableItemData;
		this.inventoryManager = inventoryManager;
		this.quest = quest;
		this.tracking = tracking;
		initialized = false;
		availableProducts = buyableItemData.GetIAPSKUs();
		TryInitialize(null, null);
	}

	private void TryInitialize(Action onSuccess, Action<string> onError)
	{
		try
		{
			if (!Core.IsInitialized())
			{
				Core.AsyncInitialize();
			}
		}
		catch (Exception ex)
		{
			if (onError != null)
			{
				onError(ex.Message);
			}
			return;
		}
		IAP.GetProductsBySKU(availableProducts).OnComplete(delegate(Message<ProductList> getProductsMessage)
		{
			if (getProductsMessage.IsError)
			{
				if (onError != null)
				{
					onError(getProductsMessage.GetError().Message);
				}
			}
			else
			{
				cachedProducts = getProductsMessage.GetProductList();
				IAP.GetViewerPurchases().OnComplete(delegate(Message<PurchaseList> getPurchasesMessage)
				{
					if (getPurchasesMessage.IsError)
					{
						if (onError != null)
						{
							onError(getPurchasesMessage.GetError().Message);
						}
					}
					else
					{
						SyncPurchases(getPurchasesMessage.GetPurchaseList());
						initialized = true;
						if (onSuccess != null)
						{
							onSuccess();
						}
					}
				});
			}
		});
	}

	public void GetProduct(string sku, Action<Product> onSuccess, Action<string> onError)
	{
		if (!initialized)
		{
			TryInitialize(delegate
			{
				GetProduct(sku, onSuccess, onError);
			}, onError);
		}
		if (cachedProducts != null)
		{
			Product product = cachedProducts.FirstOrDefault((Product p) => p.Sku == sku);
			if (product != null)
			{
				onSuccess(product);
				return;
			}
		}
		onError($"No product found with sku {sku}");
		PrepareIAPEvent("get_product_failed", sku, null, "No product found with sku {0}");
	}

	public void RequestBuyItem(string sku, Action<string> onSuccess, Action<string> onError)
	{
		if (!initialized)
		{
			TryInitialize(delegate
			{
				RequestBuyItem(sku, onSuccess, onError);
			}, onError);
			return;
		}
		if (inventoryManager.DurableInventory.ContainsItem(sku))
		{
			onSuccess(sku);
			return;
		}
		PrepareIAPEvent("purchase_attempted", sku);
		IAP.LaunchCheckoutFlow(sku).OnComplete(delegate(Message<Purchase> Message)
		{
			if (Message.IsError)
			{
				onError(Message.GetError().Message);
				PrepareIAPEvent("purchase_failed", sku, Message);
			}
			else
			{
				string sku2 = Message.GetPurchase().Sku;
				if (buyableItemData.GetItemTypeFromSku(sku2) == BuyableItemData.BuyableType.ConsumableIAP)
				{
					IAP.ConsumePurchase(sku2);
				}
				else if (buyableItemData.GetItemTypeFromSku(sku2) == BuyableItemData.BuyableType.DurableIAP)
				{
					inventoryManager.DurableInventory.SyncItem(sku2);
					inventoryManager.SaveDurableInventory();
				}
				onSuccess(sku2);
				PrepareIAPEvent("purchase_succeeded", sku);
			}
		});
	}

	private void FakePurchaseSequence(string sku, Action<string> onSuccess, Action<string> onError)
	{
		LeanTween.delayedCall(0.5f, (Action)delegate
		{
			UnityEngine.Debug.Log($"LaunchCheckoutFlow SUCCESS: {sku}");
			PrepareIAPEvent("purchase_succeeded", sku);
			if (buyableItemData.GetItemTypeFromSku(sku) == BuyableItemData.BuyableType.ConsumableIAP)
			{
				UnityEngine.Debug.Log($"Purchase consumed: {sku}");
			}
			else if (buyableItemData.GetItemTypeFromSku(sku) == BuyableItemData.BuyableType.DurableIAP)
			{
				inventoryManager.DurableInventory.SyncItem(sku);
				inventoryManager.SaveDurableInventory();
			}
			onSuccess(sku);
		});
	}

	private void SyncPurchases(PurchaseList purchaseList)
	{
		for (int i = 0; i < purchaseList.Count; i++)
		{
			string sku = purchaseList[i].Sku;
			if (buyableItemData.GetItemTypeFromSku(sku) == BuyableItemData.BuyableType.ConsumableIAP)
			{
				IAP.ConsumePurchase(sku);
			}
			else if (buyableItemData.GetItemTypeFromSku(sku) == BuyableItemData.BuyableType.DurableIAP)
			{
				inventoryManager.DurableInventory.SyncItem(sku);
				inventoryManager.SaveDurableInventory();
			}
		}
	}

	private string FormatPriceForTracking(string oculusFormattedPrice)
	{
		return oculusFormattedPrice.Trim('$', ' ').Replace(',', '.');
	}

	private void PrepareIAPEvent(string state, string sku, Message<Purchase> failureMessage = null, string errorMessage = null)
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		double result = 0.0;
		if (state == "purchase_failed" && failureMessage != null)
		{
			dictionary.Add("iap_error_message", failureMessage.GetError().Message);
			dictionary.Add("iap_error_code", failureMessage.GetError().Code.ToString());
			dictionary.Add("iap_error_http_code", failureMessage.GetError().HttpCode.ToString());
		}
		else if (state == "purchase_succeeded")
		{
			if (cachedProducts != null)
			{
				string text = FormatPriceForTracking(cachedProducts.Where((Product x) => x.Sku == sku).First().FormattedPrice);
				if (!double.TryParse(text, out result))
				{
					dictionary.Add("iap_price_unparseable", text);
					result = 0.0;
				}
			}
			else
			{
				dictionary.Add("iap_error_message", $"cachedProducts was null when purchasing sku {sku} in {SceneManager.GetActiveScene().name}!");
			}
		}
		else if (state == "get_product_failed")
		{
			dictionary.Add("iap_error_message", errorMessage);
		}
		tracking.TrackIAPEvent(state, sku, quest.CurrentState, result, dictionary);
	}
}
public enum InputType
{
	KeyDown,
	KeyHold,
	KeyUp,
	KeyDownNoTouch
}
public enum InputAction
{
	Trigger,
	Grab,
	Special,
	TouchPad,
	Button1,
	Button2
}
public enum CallbackResult
{
	Consumed,
	NotConsumed
}
public class InputManager
{
	private class InputEventListener : IComparable
	{
		public int priority;

		public Func<CallbackResult> onInputEvent;

		public InputEventListener(int priority, Func<CallbackResult> onInputEvent)
		{
			this.priority = priority;
			this.onInputEvent = onInputEvent;
		}

		public int CompareTo(object obj)
		{
			if (obj == null)
			{
				return 1;
			}
			if (obj is InputEventListener inputEventListener)
			{
				return priority.CompareTo(inputEventListener.priority);
			}
			throw new ArgumentException("Object is not an InputEventListener");
		}
	}

	public static Signal<InputType> InputSignal = new Signal<InputType>();

	private InputMode currentInputMode;

	private float blockTime;

	private InputWrapper wrapper;

	private DeviceConfig deviceConfig;

	private Handedness activeController = Handedness.Right;

	private List<InputEventListener> backButtonCallbacks = new List<InputEventListener>();

	public InputManager()
	{
		UpdateDispatcher.Instance.AddListener(Update);
		GameObject gameObject = new GameObject("Input");
		gameObject.AddComponent<DontDestroyOnLoad>();
		wrapper = gameObject.AddComponent<InputWrapperGearVR>();
		deviceConfig = SingletonBehavior<DeviceConfigLoader>.GetInstance().GetConfig();
		currentInputMode = deviceConfig.GetDefaultInputMode();
		OVRManager.VrFocusAcquired += delegate
		{
			UnityEngine.Debug.Log("VRFocus Aquired");
		};
		OVRManager.VrFocusLost += delegate
		{
			UnityEngine.Debug.Log("VRFocus Lost");
		};
		OVRManager.InputFocusAcquired += delegate
		{
			UnityEngine.Debug.Log("InputFocus Aquired");
		};
		OVRManager.InputFocusLost += delegate
		{
			UnityEngine.Debug.Log("InputFocus Lost");
		};
	}

	private void Update()
	{
		if (blockTime > 0f)
		{
			blockTime -= Time.deltaTime;
			return;
		}
		if (IsButtonDown(InputAction.Special))
		{
		}
		UpdateActiveController();
		if (IsButtonDownNoTouch())
		{
			InputSignal.Dispatch(InputType.KeyDownNoTouch);
		}
		if (IsButtonDown(InputAction.Trigger))
		{
			InputSignal.Dispatch(InputType.KeyDown);
		}
		else if (IsButtonHeld(InputAction.Trigger))
		{
			InputSignal.Dispatch(InputType.KeyHold);
		}
		else if (IsButtonUp(InputAction.Trigger))
		{
			InputSignal.Dispatch(InputType.KeyUp);
		}
	}

	public InputWrapper GetWrapper()
	{
		return wrapper;
	}

	public InputMode GetInputMode()
	{
		return currentInputMode;
	}

	public bool IsInputEnabled()
	{
		return wrapper.IsInputEnabled();
	}

	private void UpdateActiveController()
	{
		InputSource button = (InputSource)(-1);
		Handedness handedness = ((activeController != Handedness.Right) ? Handedness.Right : Handedness.Left);
		if (wrapper.GetButtonUp(button, currentInputMode, handedness))
		{
			activeController = handedness;
			UnityEngine.Debug.Log("New Controller is " + handedness);
		}
	}

	public Handedness GetActiveController()
	{
		return activeController;
	}

	public Vector3 GetControllerAcceleration(Handedness handedness = Handedness.None)
	{
		if (handedness == Handedness.None)
		{
			handedness = GetActiveController();
		}
		return wrapper.GetControllerAcceleration(currentInputMode, handedness);
	}

	public Quaternion GetControllerOrientation(Handedness handedness = Handedness.None)
	{
		if (handedness == Handedness.None)
		{
			handedness = GetActiveController();
		}
		return wrapper.GetControllerOrientation(currentInputMode, handedness);
	}

	public Vector3 GetControllerLocalPosition(Handedness handedness = Handedness.None)
	{
		if (handedness == Handedness.None)
		{
			handedness = GetActiveController();
		}
		return wrapper.GetControllerLocalPosition(currentInputMode, handedness);
	}

	public Vector3 GetControllerAngularVelocity(Handedness handedness = Handedness.None)
	{
		if (handedness == Handedness.None)
		{
			handedness = GetActiveController();
		}
		return wrapper.GetControllerAngularVelocity(currentInputMode, handedness);
	}

	public bool IsButtonDown(InputAction action, Handedness handedness = Handedness.None)
	{
		if (handedness == Handedness.None)
		{
			handedness = GetActiveController();
		}
		return action switch
		{
			InputAction.Grab => wrapper.GetButtonDown(InputSource.GripTrigger, currentInputMode, handedness), 
			InputAction.Trigger => wrapper.GetButtonDown(InputSource.IndexTrigger, currentInputMode, handedness), 
			InputAction.Special => wrapper.GetButtonDown(InputSource.Special, currentInputMode, handedness), 
			InputAction.TouchPad => wrapper.GetButtonDown((InputSource)384, currentInputMode, handedness), 
			InputAction.Button1 => wrapper.GetButtonDown(InputSource.One, currentInputMode, handedness), 
			InputAction.Button2 => wrapper.GetButtonDown(InputSource.Two, currentInputMode, handedness), 
			_ => false, 
		};
	}

	public bool IsButtonUp(InputAction action, Handedness handedness = Handedness.None)
	{
		if (handedness == Handedness.None)
		{
			handedness = GetActiveController();
		}
		return action switch
		{
			InputAction.Grab => wrapper.GetButtonUp(InputSource.GripTrigger, currentInputMode, handedness), 
			InputAction.Trigger => wrapper.GetButtonUp(InputSource.IndexTrigger, currentInputMode, handedness), 
			InputAction.Special => wrapper.GetButtonUp(InputSource.Special, currentInputMode, handedness), 
			InputAction.TouchPad => wrapper.GetButtonUp((InputSource)384, currentInputMode, handedness), 
			InputAction.Button1 => wrapper.GetButtonUp(InputSource.One, currentInputMode, handedness), 
			InputAction.Button2 => wrapper.GetButtonUp(InputSource.Two, currentInputMode, handedness), 
			_ => false, 
		};
	}

	public bool IsButtonHeld(InputAction action, Handedness handedness = Handedness.None)
	{
		if (handedness == Handedness.None)
		{
			handedness = GetActiveController();
		}
		return action switch
		{
			InputAction.Grab => wrapper.GetButton(InputSource.GripTrigger, currentInputMode, handedness), 
			InputAction.Trigger => wrapper.GetButton(InputSource.IndexTrigger, currentInputMode, handedness), 
			InputAction.Special => wrapper.GetButton(InputSource.Special, currentInputMode, handedness), 
			InputAction.TouchPad => wrapper.GetButton((InputSource)384, currentInputMode, handedness), 
			InputAction.Button1 => wrapper.GetButton(InputSource.One, currentInputMode, handedness), 
			InputAction.Button2 => wrapper.GetButton(InputSource.Two, currentInputMode, handedness), 
			_ => false, 
		};
	}

	private bool IsButtonDownNoTouch(Handedness handedness = Handedness.None)
	{
		if (handedness == Handedness.None)
		{
			handedness = GetActiveController();
		}
		return wrapper.GetButtonDown(InputSource.IndexTrigger, currentInputMode, handedness) && !wrapper.GetTouching(InputSource.IndexTrigger, currentInputMode, handedness);
	}

	public float Axis(InputAction action, Handedness handedness = Handedness.None)
	{
		if (handedness == Handedness.None)
		{
			handedness = GetActiveController();
		}
		return action switch
		{
			InputAction.Grab => wrapper.GetAxis(InputSource.GripTrigger, currentInputMode, handedness), 
			InputAction.Trigger => wrapper.GetAxis(InputSource.IndexTrigger, currentInputMode, handedness), 
			_ => 0f, 
		};
	}

	public bool IsTouching(InputAction action, Handedness handedness = Handedness.None)
	{
		if (handedness == Handedness.None)
		{
			handedness = GetActiveController();
		}
		return action switch
		{
			InputAction.Trigger => wrapper.GetTouching(InputSource.IndexTrigger, currentInputMode, handedness), 
			InputAction.TouchPad => wrapper.GetTouching(InputSource.Touchpad, currentInputMode, handedness), 
			_ => false, 
		};
	}

	public bool IsTouchingNear(InputAction action, Handedness handedness = Handedness.None)
	{
		if (handedness == Handedness.None)
		{
			handedness = GetActiveController();
		}
		if (action == InputAction.Trigger)
		{
			return wrapper.GetTouchingNear(InputSource.IndexTrigger, currentInputMode, handedness);
		}
		return false;
	}

	public Vector2 TouchPosition(Handedness handedness = Handedness.None)
	{
		if (handedness == Handedness.None)
		{
			handedness = GetActiveController();
		}
		return wrapper.GetAxis2D(InputSource.Touchpad, currentInputMode, handedness);
	}

	public ConnectionState GetControllerConnection(Handedness handedness = Handedness.None)
	{
		if (handedness == Handedness.None)
		{
			handedness = GetActiveController();
		}
		return wrapper.GetConnectionState(currentInputMode, handedness);
	}

	public bool IsConnected()
	{
		return GetStatus() == ConnectionState.Connected;
	}

	public bool IsRecentering()
	{
		return wrapper.GetIsRecentering();
	}

	public ConnectionState GetStatus()
	{
		return wrapper.GetConnectionState(InputMode.Controller_6DoF, activeController);
	}

	public void RandomHaptic(float minForce, float maxForce, float duration, Handedness handedness = Handedness.None)
	{
		if (SaveLoadPersistant.isHapticEnabled)
		{
			if (handedness == Handedness.None)
			{
				handedness = GetActiveController();
			}
			minForce = Mathf.Clamp(minForce, 0f, 1f);
			maxForce = Mathf.Clamp(maxForce, 0f, 1f);
			minForce *= 255f;
			maxForce *= 255f;
			duration *= 360f;
			int num = (int)duration;
			OVRHapticsClip oVRHapticsClip = new OVRHapticsClip(num);
			for (int i = 0; i < num; i++)
			{
				oVRHapticsClip.WriteSample((byte)UnityEngine.Random.Range(minForce, maxForce));
			}
			OVRHaptics.OVRHapticsChannel oVRHapticsChannel = OVRHaptics.RightChannel;
			switch (handedness)
			{
			case Handedness.Right:
				oVRHapticsChannel = OVRHaptics.RightChannel;
				break;
			case Handedness.Left:
				oVRHapticsChannel = OVRHaptics.LeftChannel;
				break;
			}
			oVRHapticsChannel.Preempt(oVRHapticsClip);
		}
	}

	public void FadeHaptic(float startForce, float endForce, float duration, Handedness handedness = Handedness.None)
	{
		if (SaveLoadPersistant.isHapticEnabled)
		{
			if (handedness == Handedness.None)
			{
				handedness = GetActiveController();
			}
			startForce = Mathf.Clamp(startForce, 0f, 1f);
			endForce = Mathf.Clamp(endForce, 0f, 1f);
			startForce *= 255f;
			endForce *= 255f;
			duration *= 360f;
			int num = (int)duration;
			OVRHapticsClip oVRHapticsClip = new OVRHapticsClip(num);
			for (int i = 0; i < num; i++)
			{
				oVRHapticsClip.WriteSample((byte)Mathf.Lerp(startForce, endForce, (float)i / duration));
			}
			OVRHaptics.OVRHapticsChannel oVRHapticsChannel = OVRHaptics.RightChannel;
			switch (handedness)
			{
			case Handedness.Right:
				oVRHapticsChannel = OVRHaptics.RightChannel;
				break;
			case Handedness.Left:
				oVRHapticsChannel = OVRHaptics.LeftChannel;
				break;
			}
			oVRHapticsChannel.Preempt(oVRHapticsClip);
		}
	}

	public void AddBackButtonListener(int priority, Func<CallbackResult> functionToCall)
	{
		InputEventListener item = new InputEventListener(priority, functionToCall);
		backButtonCallbacks.Add(item);
		backButtonCallbacks.Sort();
	}

	public void RemoveBackButtonListener(Func<CallbackResult> functionToCall)
	{
		for (int num = backButtonCallbacks.Count - 1; num >= 0; num--)
		{
			if (backButtonCallbacks[num].onInputEvent == functionToCall)
			{
				backButtonCallbacks.RemoveAt(num);
				break;
			}
		}
	}

	public bool HandleBackButtonPress()
	{
		for (int i = 0; i < backButtonCallbacks.Count; i++)
		{
			if (backButtonCallbacks[i].onInputEvent() == CallbackResult.Consumed)
			{
				return true;
			}
		}
		return false;
	}
}
public class InputPriorities : MonoBehaviour
{
	public const int MenuLayerThird = 2;

	public const int MenuLayerSecond = 3;

	public const int MenuLayerFirst = 4;

	public const int FishoDex = 5;

	public const int BackButton = 6;
}
namespace RG
{
	public enum Handedness : byte
	{
		None,
		Right,
		Left
	}
	public enum ConnectionState
	{
		Error = -1,
		Disconnected,
		Scanning,
		Connecting,
		Connected
	}
	public enum InputMode
	{
		Headset = 1,
		Controller_3DoF = 2,
		Controller_6DoF = 4,
		Gamepad = 8
	}
	public enum InputSource
	{
		Special = 1,
		One = 2,
		Two = 4,
		Three = 8,
		Four = 0x10,
		IndexTrigger = 0x20,
		GripTrigger = 0x40,
		Touchpad = 0x80,
		Thumbstick = 0x100
	}
}
public abstract class InputWrapper : MonoBehaviour
{
	public virtual bool IsControllerActive(InputMode inputMode, Handedness hand)
	{
		return false;
	}

	public virtual bool IsInputEnabled()
	{
		return true;
	}

	public virtual Handedness GetHandedness()
	{
		return Handedness.Right;
	}

	public virtual Vector3 GetControllerAcceleration(InputMode inputMode, Handedness hand)
	{
		return Vector3.zero;
	}

	public virtual Quaternion GetControllerOrientation(InputMode inputMode, Handedness hand)
	{
		return Quaternion.identity;
	}

	public virtual Vector3 GetControllerAngularVelocity(InputMode inputMode, Handedness hand)
	{
		return Vector3.zero;
	}

	public virtual Vector3 GetControllerLocalPosition(InputMode inputMode, Handedness hand)
	{
		return Vector3.zero;
	}

	public virtual float GetAxis(InputSource axis, InputMode inputMode, Handedness hand)
	{
		return 0f;
	}

	public virtual Vector2 GetAxis2D(InputSource axis, InputMode inputMode, Handedness hand)
	{
		return Vector2.zero;
	}

	public virtual bool GetButtonDown(InputSource button, InputMode inputMode, Handedness hand)
	{
		return false;
	}

	public virtual bool GetButtonUp(InputSource button, InputMode inputMode, Handedness hand)
	{
		return false;
	}

	public virtual bool GetButton(InputSource button, InputMode inputMode, Handedness hand)
	{
		return false;
	}

	public virtual bool GetTouchingDown(InputSource area, InputMode inputMode, Handedness hand)
	{
		return false;
	}

	public virtual bool GetTouchingUp(InputSource area, InputMode inputMode, Handedness hand)
	{
		return false;
	}

	public virtual bool GetTouching(InputSource area, InputMode inputMode, Handedness hand)
	{
		return false;
	}

	public virtual bool GetTouchingNearDown(InputSource area, InputMode inputMode, Handedness hand)
	{
		return false;
	}

	public virtual bool GetTouchingNearUp(InputSource area, InputMode inputMode, Handedness hand)
	{
		return false;
	}

	public virtual bool GetTouchingNear(InputSource area, InputMode inputMode, Handedness hand)
	{
		return false;
	}

	public virtual bool GetIsRecentering()
	{
		return false;
	}

	public virtual ConnectionState GetConnectionState(InputMode inputMode, Handedness hand)
	{
		return ConnectionState.Connected;
	}
}
public class InputWrapperEditor : InputWrapper
{
}
public abstract class GrabbableObject : MonoBehaviour
{
	[SerializeField]
	protected int priorty;

	[SerializeField]
	protected InputAction grabAction = InputAction.Grab;

	protected Hand hand;

	protected Action OnGrabbed;

	protected int hoverCounter;

	public Hand Hand => hand;

	public int GetPriority()
	{
		return priorty;
	}

	public bool GetIsGrabbed()
	{
		return hand != null;
	}

	public virtual bool GetIsGrabbable()
	{
		return true;
	}

	public virtual HandAnimation.Pose GetGrabbedPose()
	{
		return HandAnimation.Pose.GenericHold;
	}

	public virtual InputAction GetGrabAction()
	{
		return grabAction;
	}

	public virtual void OnObjectGrabbed(Hand hand, Action OnGrabbed)
	{
		this.hand = hand;
		if (this.OnGrabbed != null)
		{
			this.OnGrabbed();
		}
		this.OnGrabbed = OnGrabbed;
	}

	public void OnHoverStart()
	{
		hoverCounter++;
		if (hoverCounter == 1)
		{
			StartHovering();
		}
	}

	protected abstract void StartHovering();

	public void OnHoverEnd()
	{
		hoverCounter--;
		if (hoverCounter <= 0)
		{
			hoverCounter = 0;
			EndHovering();
		}
	}

	protected abstract void EndHovering();

	public abstract void OnInput(InputAction action, InputType type);

	public virtual void OnObjectReleased(Hand hand)
	{
		if (this.hand == hand)
		{
			this.hand = null;
			OnGrabbed = null;
		}
	}
}
[RequireComponent(typeof(Collider), typeof(Hand), typeof(Rigidbody))]
[RequireComponent(typeof(ControllerVisualization))]
public class Grabber : MonoBehaviour
{
	private Hand hand;

	[SerializeField]
	private float grabbInterval = 0.5f;

	private GrabbableObject currentGrabObject;

	private GrabbableObject hoveringObject;

	private List<GrabbableObject> overlappingObjects;

	private ControllerVisualization visualization;

	private float grabbTimmer;

	private bool wantToGrabb;

	[@Dependency]
	private InputManager Input { get; set; }

	public bool IsGrabbging => currentGrabObject != null;

	private void Awake()
	{
		this.Inject();
		hand = Find.ComponentOnGameObject<Hand>(base.gameObject);
		visualization = Find.ComponentOnGameObject<ControllerVisualization>(base.gameObject);
		overlappingObjects = new List<GrabbableObject>();
	}

	private void Update()
	{
		if (!Input.IsInputEnabled())
		{
			return;
		}
		if ((bool)currentGrabObject)
		{
			foreach (InputAction value in Enum.GetValues(typeof(InputAction)))
			{
				if (Input.IsButtonDown(value, hand.Handedness))
				{
					currentGrabObject.OnInput(value, InputType.KeyDown);
				}
				if (Input.IsButtonHeld(value, hand.Handedness))
				{
					currentGrabObject.OnInput(value, InputType.KeyHold);
				}
				if (Input.IsButtonUp(value, hand.Handedness))
				{
					currentGrabObject.OnInput(value, InputType.KeyUp);
				}
			}
			if (Input.IsButtonUp(currentGrabObject.GetGrabAction(), hand.Handedness))
			{
				UnityEngine.Debug.Log(string.Concat("Active when released: ", Input.GetActiveController(), " : ", Input.IsButtonDown(currentGrabObject.GetGrabAction(), hand.Handedness), " : ", Input.IsButtonHeld(currentGrabObject.GetGrabAction(), hand.Handedness), " : ", Input.IsButtonUp(currentGrabObject.GetGrabAction(), hand.Handedness)));
				OnReleaseObject();
			}
		}
		else
		{
			UpdateHovering();
			if (Input.IsButtonDown(InputAction.Grab, hand.Handedness))
			{
				grabbTimmer = 0f;
				wantToGrabb = true;
			}
			grabbTimmer += Time.deltaTime;
			if ((bool)hoveringObject && ((grabbTimmer < grabbInterval && wantToGrabb && hoveringObject.GetGrabAction() == InputAction.Grab) || Input.IsButtonDown(hoveringObject.GetGrabAction(), hand.Handedness)))
			{
				OnGrabObject();
			}
		}
	}

	private void OnGrabObject()
	{
		if ((bool)hoveringObject)
		{
			hoveringObject.OnHoverEnd();
			hand.SetPose(hoveringObject.GetGrabbedPose());
			hoveringObject.OnObjectGrabbed(hand, OnObjectTaken);
			currentGrabObject = hoveringObject;
			hoveringObject = null;
			grabbTimmer = 0f;
			wantToGrabb = false;
			visualization.DisabledByGrabbing = true;
			visualization.SetVisible(visible: false);
		}
	}

	private void OnReleaseObject()
	{
		if ((bool)currentGrabObject)
		{
			UpdateHovering();
			currentGrabObject.OnObjectReleased(hand);
			currentGrabObject = null;
			hand.SetPose(HandAnimation.Pose.Flex);
			visualization.DisabledByGrabbing = false;
		}
	}

	public void OnObjectTaken()
	{
		if ((bool)currentGrabObject)
		{
			UpdateHovering();
			currentGrabObject.OnInput(InputAction.Trigger, InputType.KeyUp);
			currentGrabObject = null;
			hand.SetPose(HandAnimation.Pose.Flex);
			visualization.DisabledByGrabbing = false;
		}
	}

	private void UpdateHovering()
	{
		for (int i = 0; i < overlappingObjects.Count; i++)
		{
			GrabbableObject grabbableObject = overlappingObjects[i];
			if (!grabbableObject.gameObject.activeInHierarchy)
			{
				overlappingObjects.RemoveAt(i);
				i--;
			}
			else
			{
				if (!grabbableObject.GetIsGrabbable())
				{
					continue;
				}
				if (grabbableObject != hoveringObject)
				{
					if ((bool)hoveringObject)
					{
						hoveringObject.OnHoverEnd();
					}
					hoveringObject = grabbableObject;
					hoveringObject.OnHoverStart();
				}
				return;
			}
		}
		if ((bool)hoveringObject)
		{
			hoveringObject.OnHoverEnd();
			hoveringObject = null;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!AddGrabbable(other.gameObject))
		{
			Rigidbody attachedRigidbody = other.attachedRigidbody;
			if ((bool)attachedRigidbody)
			{
				AddGrabbable(attachedRigidbody.gameObject);
			}
		}
	}

	private bool AddGrabbable(GameObject gameObject)
	{
		GrabbableObject component = gameObject.GetComponent<GrabbableObject>();
		if ((bool)component)
		{
			overlappingObjects.Add(component);
			overlappingObjects.Sort(SortByPrioirty);
			return true;
		}
		return false;
	}

	private void OnTriggerExit(Collider other)
	{
		if (!RemoveGrabbable(other.gameObject))
		{
			Rigidbody attachedRigidbody = other.attachedRigidbody;
			if ((bool)attachedRigidbody)
			{
				RemoveGrabbable(attachedRigidbody.gameObject);
			}
		}
	}

	private bool RemoveGrabbable(GameObject gameObject)
	{
		GrabbableObject component = gameObject.GetComponent<GrabbableObject>();
		if (overlappingObjects.Remove(component))
		{
			if (hoveringObject == component)
			{
				hoveringObject.OnHoverEnd();
				hoveringObject = null;
			}
			return true;
		}
		return false;
	}

	private static int SortByPrioirty(GrabbableObject a, GrabbableObject b)
	{
		return -a.GetPriority().CompareTo(b.GetPriority());
	}
}
public class Hand : MonoBehaviour
{
	[SerializeField]
	private Handedness hand;

	[SerializeField]
	private Vector3 throwOffset;

	[SerializeField]
	private Vector3 reelCrankOffset;

	[SerializeField]
	private int avrageOverFrames = 5;

	private Vector3 velocity;

	private Vector3 avrageVelocity;

	private Vector3[] velocityBuffer;

	private Vector3 previousThrowLocation;

	private Vector3 angularVelocity;

	private Vector3 avrageAngularVelocity;

	private Vector3[] angularVelocityBuffer;

	private Vector3 previousThrowRotation;

	private HandAnimation handAnim;

	[@Dependency]
	public InputManager input { get; set; }

	public Handedness Handedness
	{
		get
		{
			return hand;
		}
		set
		{
			hand = value;
		}
	}

	public Vector3 ThrowPosition => base.transform.TransformPoint(throwOffset);

	public Vector3 ThrowVelocity => velocity;

	public Vector3 AvrageThrowVelocity => avrageVelocity;

	public Vector3 AvrageAngularThrowVelocity => avrageAngularVelocity;

	public Vector3 ReelInPosition => base.transform.TransformPoint(reelCrankOffset);

	public Transform FishAnchor => handAnim.fishAnchor;

	private void Awake()
	{
		this.Inject();
		velocityBuffer = new Vector3[avrageOverFrames];
		angularVelocityBuffer = new Vector3[avrageOverFrames];
	}

	private void Start()
	{
		handAnim = Find.ComponentInChildren<HandAnimation>(this);
	}

	public void SetPose(HandAnimation.Pose pose)
	{
		handAnim.SetPose(pose);
	}

	private void FixedUpdate()
	{
		if (input.IsConnected() && !input.IsRecentering() && input.IsInputEnabled() && !(input.GetControllerLocalPosition(Handedness).y < 0f))
		{
			if (Vector3.Distance(base.transform.localPosition, input.GetControllerLocalPosition(Handedness)) < 0.1f)
			{
				base.transform.localPosition = input.GetControllerLocalPosition(Handedness);
				UpdateThrowVelocity();
			}
			else
			{
				base.transform.localPosition = Vector3.Lerp(base.transform.localPosition, input.GetControllerLocalPosition(Handedness), 0.05f);
			}
			base.transform.localRotation = input.GetControllerOrientation(Handedness);
		}
	}

	private void UpdateThrowVelocity()
	{
		velocity = (ThrowPosition - previousThrowLocation) / Time.fixedDeltaTime;
		angularVelocity = (base.transform.rotation.eulerAngles - previousThrowRotation) / Time.fixedDeltaTime;
		previousThrowLocation = ThrowPosition;
		previousThrowRotation = base.transform.rotation.eulerAngles;
		Vector3 vector = velocity;
		Vector3 vector2 = angularVelocity;
		if (avrageOverFrames > 0)
		{
			for (int i = 1; i < avrageOverFrames; i++)
			{
				ref Vector3 reference = ref velocityBuffer[i];
				reference = velocityBuffer[i - 1];
				ref Vector3 reference2 = ref angularVelocityBuffer[i];
				reference2 = velocityBuffer[i - 1];
				vector += velocityBuffer[i];
				vector2 += angularVelocityBuffer[i];
			}
			ref Vector3 reference3 = ref velocityBuffer[0];
			reference3 = velocity;
			ref Vector3 reference4 = ref angularVelocityBuffer[0];
			reference4 = angularVelocity;
			avrageVelocity = vector / avrageOverFrames;
			avrageAngularVelocity = vector2 / avrageOverFrames;
		}
		else
		{
			avrageVelocity = velocity;
			avrageAngularVelocity = angularVelocity;
		}
	}
}
[RequireComponent(typeof(Text))]
public class ApplyLocalizedText : MonoBehaviour
{
	[SerializeField]
	private bool MakeUppercase;

	[SerializeField]
	private bool useLocalizedFont = true;

	private Text textComponent;

	private int maxSize;

	private string ID;

	private string _localizationKey;

	private bool startHasHappened;

	[@Dependency]
	public Localization localization { get; set; }

	public string localizationKey
	{
		get
		{
			return _localizationKey;
		}
		set
		{
			_localizationKey = value;
			if (startHasHappened)
			{
				PopulateText();
			}
		}
	}

	private void Start()
	{
		this.Inject();
		PopulateText();
		startHasHappened = true;
	}

	private void Reset()
	{
		SetupTextComponent();
	}

	private void SetupTextComponent()
	{
		textComponent = Find.ComponentOnGameObject<Text>(this);
		maxSize = textComponent.resizeTextMaxSize;
	}

	public void PopulateText(bool forceUpdate = false)
	{
		if (textComponent == null)
		{
			SetupTextComponent();
		}
		if (ID == null || ID == string.Empty || forceUpdate)
		{
			ID = textComponent.text;
		}
		else
		{
			textComponent.text = ID;
		}
		if (localizationKey != null && textComponent.text.Contains("{0}"))
		{
			textComponent.text = textComponent.text.Replace("{0}", localizationKey);
		}
		try
		{
			textComponent.text = localization.GetString(textComponent.text);
		}
		catch (Exception innerException)
		{
			throw new Exception(base.gameObject.ToString(), innerException);
		}
		textComponent.resizeTextMaxSize = maxSize;
		if (MakeUppercase)
		{
			textComponent.text = textComponent.text.ToUpper();
		}
		if (useLocalizedFont)
		{
			textComponent.font = localization.GetLanguageFont();
			textComponent.fontSize = (int)((float)textComponent.resizeTextMaxSize * localization.GetLanguageFontSizeMultiplier());
		}
		textComponent.text = textComponent.text.Replace("\\n", Environment.NewLine);
		if (localization.CurrentLanguangId == "ja")
		{
			textComponent.text = textComponent.text.Replace("? ", "");
			textComponent.text = textComponent.text.Replace("! ", "");
			textComponent.text = textComponent.text.Replace(". ", "");
			textComponent.text = textComponent.text.Replace(": ", "");
		}
	}
}
public class LocalePrefabSpawner : MonoBehaviour
{
	[Serializable]
	public class Entry
	{
		public string[] locales;

		public GameObject prefab;

		public bool IsLocaleMatching(string locale)
		{
			int i = 0;
			for (int num = locales.Length; i < num; i++)
			{
				if (locales[i].Equals(locale))
				{
					return true;
				}
			}
			return false;
		}
	}

	[SerializeField]
	private Entry[] entries;

	[@Dependency]
	public Localization localization { get; set; }

	private void Awake()
	{
		this.Inject();
		localization.changeLanguageNotification.AddListener(ApplyLocalizedPrefab);
		ApplyLocalizedPrefab();
	}

	private void OnDestroy()
	{
		localization.changeLanguageNotification.RemoveListener(ApplyLocalizedPrefab);
	}

	private void ApplyLocalizedPrefab()
	{
		string currentLanguangId = localization.CurrentLanguangId;
		int childCount = base.transform.childCount;
		for (int num = childCount - 1; num >= 0; num--)
		{
			UnityEngine.Object.Destroy(base.transform.GetChild(num).gameObject);
		}
		int i = 0;
		for (int num2 = entries.Length; i < num2; i++)
		{
			if (entries[i].IsLocaleMatching(currentLanguangId))
			{
				SpawnPrefab(entries[i].prefab);
				break;
			}
		}
	}

	private void SpawnPrefab(GameObject prefab)
	{
		UnityEngine.Object.Instantiate(prefab, base.transform, worldPositionStays: false);
	}
}
public class Localization
{
	[Serializable]
	private class LanguageSetting
	{
		public string languageId;
	}

	private Dictionary<string, string> strings;

	private string languageCataloguePath = UnityEngine.Application.persistentDataPath + "/LanguageSetting/";

	private string languageFileName = "userLanguage";

	private LanguageSetting currentLanguageSetting;

	private Font defaultFont;

	private Font chineseFont;

	private Font japaneseFont;

	private Font koreanFont;

	private RGTracking tracking;

	public Signal changeLanguageNotification { get; private set; }

	public string CurrentLanguangId => currentLanguageSetting.languageId;

	public Localization(RGTracking tracking)
	{
		this.tracking = tracking;
		strings = new Dictionary<string, string>();
		defaultFont = (Font)Resources.Load("Fonts/light_pixel-7", typeof(Font));
		chineseFont = (Font)Resources.Load("Fonts/mini-jian-caocuyuan", typeof(Font));
		japaneseFont = (Font)Resources.Load("Fonts/logotypejp_mp_b_1", typeof(Font));
		koreanFont = (Font)Resources.Load("Fonts/BMHANNA_11yrs", typeof(Font));
		changeLanguageNotification = new Signal();
		SetStartLanguage();
	}

	public string GetString(string id)
	{
		id = id.Replace("\r", string.Empty).Replace("\n", string.Empty).Replace("\t", string.Empty)
			.Replace("\v", string.Empty);
		if (!strings.TryGetValue(id, out var value))
		{
			throw new ArgumentException($"Cannot find localized string with id: {id}");
		}
		return ReplaceSpecialChars(value);
	}

	public string GetSpeakerName(string speakerID)
	{
		string empty = string.Empty;
		return speakerID switch
		{
			"Player" => GetString("Dialog_You"), 
			"Shopkeep1" => GetString("Dialog_JimBob"), 
			"Shopkeep2" => GetString("Dialog_DharmaMae"), 
			"Boss" => GetString("Dialog_Boss"), 
			_ => string.Empty, 
		};
	}

	private void SetStartLanguage()
	{
		LanguageSetting languageSetting = LoadLanguageSetting();
		if (languageSetting == null)
		{
			SetLanguage(GetDefaultLanguage(), fromStartup: true);
		}
		else
		{
			SetLanguage(languageSetting.languageId, fromStartup: true);
		}
	}

	public void SetLanguage(string languageId, bool fromStartup)
	{
		string text = $"Strings/{languageId}/Strings";
		CSVTable cSVTable = new CSVTable();
		try
		{
			cSVTable.LoadFromResources(text);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogWarning($"Localization.cs::SetLanguage: Could not load Strings.csv for language {languageId}.\n {ex.ToString()}");
			languageId = "en";
			text = "Strings/en/Strings";
			cSVTable.LoadFromResources(text);
		}
		strings.Clear();
		for (int i = 0; i < cSVTable.NumRows; i++)
		{
			try
			{
				CSVTable.Row row = cSVTable.GetRow(i);
				strings.Add(row.GetColumn(0), row.GetColumn(1));
			}
			catch (Exception innerException)
			{
				throw new IOException($"Failed parsing language file {text}. Error at line {i}", innerException);
			}
		}
		currentLanguageSetting = new LanguageSetting
		{
			languageId = languageId
		};
		SaveLanguageSetting();
		changeLanguageNotification.Dispatch();
		string setting = ((!fromStartup) ? "changed" : "at_startup");
		tracking.TrackSettingsEvent("language", setting, "language_id", currentLanguageSetting.languageId);
	}

	private string GetDefaultLanguage()
	{
		switch (UnityEngine.Application.systemLanguage)
		{
		case SystemLanguage.English:
			return "en";
		case SystemLanguage.German:
			return "de";
		case SystemLanguage.Spanish:
			return "es";
		case SystemLanguage.Catalan:
			return "es";
		case SystemLanguage.French:
			return "fr";
		case SystemLanguage.Italian:
			return "it";
		case SystemLanguage.Chinese:
		case SystemLanguage.ChineseSimplified:
		case SystemLanguage.ChineseTraditional:
			return "zh";
		case SystemLanguage.Korean:
			return "ko";
		case SystemLanguage.Japanese:
			return "ja";
		default:
			return "en";
		}
	}

	public string FormatWeight(float kilograms)
	{
		if (currentLanguageSetting.languageId == "en")
		{
			return KilogramsToPounds(kilograms).ToString("#0.00\u202f") + GetString("GUI_lbs_abbreviation");
		}
		return kilograms.ToString("#0.00\u202f") + GetString("GUI_kg_abbreviation");
	}

	public string FormatWeightWithoutUnit(float kilograms)
	{
		if (currentLanguageSetting.languageId == "en")
		{
			return KilogramsToPounds(kilograms).ToString("#0.00");
		}
		return kilograms.ToString("#0.00");
	}

	private static float KilogramsToPounds(float kgs)
	{
		return kgs * 2.20462f;
	}

	private void SaveLanguageSetting()
	{
		try
		{
			if (!Directory.Exists(languageCataloguePath))
			{
				Directory.CreateDirectory(languageCataloguePath);
			}
			BinaryFormatter binaryFormatter = new BinaryFormatter();
			FileStream fileStream = File.Create(languageCataloguePath + languageFileName);
			binaryFormatter.Serialize(fileStream, currentLanguageSetting);
			fileStream.Close();
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("Unable to save language setting: " + ex);
		}
	}

	private LanguageSetting LoadLanguageSetting()
	{
		string path = languageCataloguePath + languageFileName;
		if (!File.Exists(path))
		{
			return null;
		}
		FileStream fileStream = new FileStream(path, FileMode.Open);
		try
		{
			BinaryFormatter binaryFormatter = new BinaryFormatter();
			return binaryFormatter.Deserialize(fileStream) as LanguageSetting;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("Unable to deserialize saved language setting: " + ex);
		}
		finally
		{
			fileStream?.Close();
		}
		return null;
	}

	public Font GetLanguageFont()
	{
		return CurrentLanguangId switch
		{
			"zh" => chineseFont, 
			"ko" => koreanFont, 
			"ja" => japaneseFont, 
			_ => defaultFont, 
		};
	}

	public float GetLanguageFontSizeMultiplier()
	{
		return CurrentLanguangId switch
		{
			"zh" => 1.5f, 
			"ko" => 1.5f, 
			"ja" => 1.5f, 
			_ => 1f, 
		};
	}

	public string ReplaceSpecialChars(string text)
	{
		if (CurrentLanguangId == "zh" || CurrentLanguangId == "ko" || CurrentLanguangId == "ja")
		{
			return text.Replace("", ". ").Replace("", ", ").Replace("", "! ")
				.Replace("", "? ");
		}
		return text;
	}
}
[RequireComponent(typeof(Renderer))]
public class Billboard : MonoBehaviour
{
	private struct SavedObject
	{
		public GameObject gameObject;

		public int originalLayer;
	}

	public GameObject[] billboardedObjects;

	[Tooltip("Layer to put the billboarded objects in. The billboard camera will render only objects in this layer.")]
	public int layerNumber = 23;

	public bool stereoscopic = true;

	public float stereoSeparation = 0.064f;

	[Range(0f, 11f)]
	public int textureWidthPowerOfTwo = 8;

	[Range(0f, 11f)]
	public int textureHeightPowerOfTwo = 8;

	[Tooltip("Remove the original objects after creating the billboard")]
	public bool deleteOriginals = true;

	[Tooltip("Re-render the billboard every frame")]
	public bool renderContinuously;

	public bool estimateViewFrustum = true;

	private static RenderTexture blankTexture;

	private GameObject cameraObject;

	private Camera renderCam;

	private Transform renderCamTransform;

	private RenderTexture[] textures;

	private bool needToRender;

	private Camera mainCamera;

	private List<SavedObject> savedObjects;

	private Material billboardMaterial;

	private Dictionary<Camera, int> eyeForCamera;

	private void Start()
	{
		eyeForCamera = new Dictionary<Camera, int>();
		savedObjects = new List<SavedObject>();
		GameObject[] array = billboardedObjects;
		foreach (GameObject obj in array)
		{
			SaveObjectSettingsRecursively(obj, savedObjects);
		}
		if (Camera.main != null)
		{
			mainCamera = Camera.main;
		}
		else
		{
			mainCamera = GameObject.Find("CenterCamera").GetComponent<Camera>();
		}
		cameraObject = new GameObject("BillboardCamera");
		cameraObject.tag = "Untagged";
		renderCamTransform = cameraObject.transform;
		renderCam = cameraObject.AddComponent<Camera>();
		renderCam.CopyFrom(mainCamera);
		renderCam.clearFlags = CameraClearFlags.Color;
		renderCam.backgroundColor = new Color(0f, 0f, 0f, 0f);
		renderCam.enabled = false;
		textures = new RenderTexture[2];
		RenderTextures();
		needToRender = false;
	}

	private void Update()
	{
		if (needToRender)
		{
			RenderTextures();
		}
		needToRender = renderContinuously && !deleteOriginals;
		if (deleteOriginals)
		{
			GameObject[] array = billboardedObjects;
			foreach (GameObject obj in array)
			{
				UnityEngine.Object.Destroy(obj);
			}
		}
	}

	private void RenderTextures()
	{
		renderCamTransform.position = mainCamera.transform.position;
		int num = 1 << textureWidthPowerOfTwo;
		int num2 = 1 << textureHeightPowerOfTwo;
		PutInCameraLayer();
		int num3 = ((!stereoscopic) ? 1 : 2);
		for (int i = 0; i < num3; i++)
		{
			RenderTexture renderTexture = textures[i];
			if (renderTexture == null || renderTexture.width != num || renderTexture.height != num2)
			{
				renderTexture = new RenderTexture(num, num2, 24);
				renderTexture.hideFlags = HideFlags.DontSave;
				textures[i] = renderTexture;
			}
			RenderEye(i);
		}
		RestoreLayers();
	}

	private void OnDestroy()
	{
		UnityEngine.Object.Destroy(cameraObject);
	}

	public void OnWillRenderObject()
	{
		Camera current = Camera.current;
		Texture value;
		if (textures == null)
		{
			if (blankTexture == null)
			{
				blankTexture = new RenderTexture(1, 1, 24);
				blankTexture.hideFlags = HideFlags.DontSave;
			}
			value = blankTexture;
		}
		else
		{
			int value2;
			if (stereoscopic)
			{
				if (!eyeForCamera.TryGetValue(current, out value2))
				{
					value2 = (current.name.StartsWith("Right") ? 1 : 0);
					eyeForCamera[current] = value2;
				}
			}
			else
			{
				value2 = 0;
			}
			value = textures[value2];
		}
		current.cullingMask &= ~(1 << layerNumber);
		if (billboardMaterial == null)
		{
			billboardMaterial = GetComponent<Renderer>().material;
		}
		billboardMaterial.SetTexture("_MainTex", value);
	}

	private void RenderEye(int eye)
	{
		float num = 0f;
		if (stereoscopic)
		{
			num = stereoSeparation * (-0.5f + (float)eye);
		}
		RenderTexture targetTexture = textures[eye];
		Transform transform = mainCamera.transform;
		renderCamTransform.position = transform.position + transform.right * num;
		renderCamTransform.LookAt(base.transform.position);
		renderCam.targetTexture = targetTexture;
		renderCam.cullingMask = 1 << layerNumber;
		renderCam.rect = new Rect(0f, 0f, 1f, 1f);
		SetObliqueProjection(renderCam, base.transform.TransformPoint(new Vector3(-0.5f, -0.5f, 0f)), base.transform.TransformPoint(new Vector3(0.5f, -0.5f, 0f)), base.transform.TransformPoint(new Vector3(-0.5f, 0.5f, 0f)), renderCamTransform.position, renderCam.nearClipPlane, renderCam.farClipPlane);
		bool fog = RenderSettings.fog;
		RenderSettings.fog = false;
		renderCam.Render();
		RenderSettings.fog = fog;
		renderCam.targetTexture = null;
	}

	private static void SaveObjectSettingsRecursively(GameObject obj, ICollection<SavedObject> objects)
	{
		objects.Add(new SavedObject
		{
			gameObject = obj,
			originalLayer = obj.layer
		});
		foreach (Transform item in obj.transform)
		{
			SaveObjectSettingsRecursively(item.gameObject, objects);
		}
	}

	private void PutInCameraLayer()
	{
		for (int i = 0; i < savedObjects.Count; i++)
		{
			savedObjects[i].gameObject.layer = layerNumber;
		}
	}

	private void RestoreLayers()
	{
		for (int i = 0; i < savedObjects.Count; i++)
		{
			savedObjects[i].gameObject.layer = savedObjects[i].originalLayer;
		}
	}

	private void SetObliqueProjection(Camera cameraComponent, Vector3 pa, Vector3 pb, Vector3 pc, Vector3 pe, float n, float f)
	{
		Vector3 lhs = pb - pa;
		Vector3 vector = pc - pa;
		lhs.Normalize();
		vector.Normalize();
		Vector3 rhs = -Vector3.Cross(lhs, vector);
		rhs.Normalize();
		Vector3 vector2 = pa - pe;
		Vector3 rhs2 = pb - pe;
		Vector3 rhs3 = pc - pe;
		float num = 0f - Vector3.Dot(vector2, rhs);
		float num2 = Vector3.Dot(lhs, vector2) * n / num;
		float num3 = Vector3.Dot(lhs, rhs2) * n / num;
		float num4 = Vector3.Dot(vector, vector2) * n / num;
		float num5 = Vector3.Dot(vector, rhs3) * n / num;
		Matrix4x4 projectionMatrix = default(Matrix4x4);
		projectionMatrix[0, 0] = 2f * n / (num3 - num2);
		projectionMatrix[0, 1] = 0f;
		projectionMatrix[0, 2] = (num3 + num2) / (num3 - num2);
		projectionMatrix[0, 3] = 0f;
		projectionMatrix[1, 0] = 0f;
		projectionMatrix[1, 1] = 2f * n / (num5 - num4);
		projectionMatrix[1, 2] = (num5 + num4) / (num5 - num4);
		projectionMatrix[1, 3] = 0f;
		projectionMatrix[2, 0] = 0f;
		projectionMatrix[2, 1] = 0f;
		projectionMatrix[2, 2] = (f + n) / (n - f);
		projectionMatrix[2, 3] = 2f * f * n / (n - f);
		projectionMatrix[3, 0] = 0f;
		projectionMatrix[3, 1] = 0f;
		projectionMatrix[3, 2] = -1f;
		projectionMatrix[3, 3] = 0f;
		Matrix4x4 matrix4x = default(Matrix4x4);
		matrix4x[0, 0] = lhs.x;
		matrix4x[0, 1] = lhs.y;
		matrix4x[0, 2] = lhs.z;
		matrix4x[0, 3] = 0f;
		matrix4x[1, 0] = vector.x;
		matrix4x[1, 1] = vector.y;
		matrix4x[1, 2] = vector.z;
		matrix4x[1, 3] = 0f;
		matrix4x[2, 0] = rhs.x;
		matrix4x[2, 1] = rhs.y;
		matrix4x[2, 2] = rhs.z;
		matrix4x[2, 3] = 0f;
		matrix4x[3, 0] = 0f;
		matrix4x[3, 1] = 0f;
		matrix4x[3, 2] = 0f;
		matrix4x[3, 3] = 1f;
		Matrix4x4 matrix4x2 = default(Matrix4x4);
		matrix4x2[0, 0] = 1f;
		matrix4x2[0, 1] = 0f;
		matrix4x2[0, 2] = 0f;
		matrix4x2[0, 3] = 0f - pe.x;
		matrix4x2[1, 0] = 0f;
		matrix4x2[1, 1] = 1f;
		matrix4x2[1, 2] = 0f;
		matrix4x2[1, 3] = 0f - pe.y;
		matrix4x2[2, 0] = 0f;
		matrix4x2[2, 1] = 0f;
		matrix4x2[2, 2] = 1f;
		matrix4x2[2, 3] = 0f - pe.z;
		matrix4x2[3, 0] = 0f;
		matrix4x2[3, 1] = 0f;
		matrix4x2[3, 2] = 0f;
		matrix4x2[3, 3] = 1f;
		cameraComponent.projectionMatrix = projectionMatrix;
		cameraComponent.worldToCameraMatrix = matrix4x * matrix4x2;
		if (estimateViewFrustum)
		{
			Quaternion rotation = default(Quaternion);
			rotation.SetLookRotation(0.5f * (pb + pc) - pe, vector);
			cameraComponent.transform.rotation = rotation;
			if ((double)cameraComponent.aspect >= 1.0)
			{
				cameraComponent.fieldOfView = 57.29578f * Mathf.Atan(((pb - pa).magnitude + (pc - pa).magnitude) / vector2.magnitude);
			}
			else
			{
				cameraComponent.fieldOfView = 57.29578f / cameraComponent.aspect * Mathf.Atan(((pb - pa).magnitude + (pc - pa).magnitude) / vector2.magnitude);
			}
		}
	}
}
namespace RGCommon
{
	public static class SynthesizedAudio
	{
		private abstract class Generator
		{
			public readonly float frequency;

			public readonly float amplitude;

			protected int position;

			public Generator(float frequency, float amplitude)
			{
				this.frequency = frequency;
				this.amplitude = amplitude;
			}

			public abstract void OnAudioRead(float[] data);

			public void OnAudioSetPosition(int newPosition)
			{
				position = newPosition;
			}
		}

		private class SineGenerator : Generator
		{
			public SineGenerator(float frequency, float amplitude)
				: base(frequency, amplitude)
			{
			}

			public override void OnAudioRead(float[] data)
			{
				int i = 0;
				for (int num = data.Length; i < num; i++)
				{
					data[i] = Mathf.Sin((float)Math.PI * 2f * frequency * (float)position / 44100f) * amplitude;
					position++;
				}
			}
		}

		private const int sampleRate = 44100;

		public static AudioClip GenerateSineBeep(float frequency, float amplitude, float lengthInSeconds)
		{
			Generator generator = new SineGenerator(frequency, amplitude);
			int lengthSamples = Mathf.RoundToInt(44100f * lengthInSeconds);
			return AudioClip.Create("Synthesized Audio", lengthSamples, 1, 44100, stream: false, generator.OnAudioRead, generator.OnAudioSetPosition);
		}
	}
	public class VersionDisplay : MonoBehaviour
	{
		private void Start()
		{
			string version = VersionInformation.Version;
			TextMesh component = GetComponent<TextMesh>();
			if (component != null)
			{
				component.text = version;
			}
			Text component2 = GetComponent<Text>();
			if (component2 != null)
			{
				component2.text = version;
			}
		}
	}
	public static class VersionInformation
	{
		public static string Version => "1.12.63217";
	}
	public static class BestMatch
	{
		public static void UpdateIfGreater<T>(ref T currentBest, ref float bestValue, T candidate, float candidateValue)
		{
			if (candidateValue > bestValue)
			{
				currentBest = candidate;
				bestValue = candidateValue;
			}
		}

		public static void UpdateIfLess<T>(ref T currentBest, ref float bestValue, T candidate, float candidateValue)
		{
			if (candidateValue < bestValue)
			{
				currentBest = candidate;
				bestValue = candidateValue;
			}
		}
	}
	public static class Collections
	{
		public static void Shuffle<T>(T[] values)
		{
			int num = values.Length;
			for (int i = 0; i < num - 1; i++)
			{
				int num2 = UnityEngine.Random.Range(i, num);
				T val = values[i];
				values[i] = values[num2];
				values[num2] = val;
			}
		}

		public static void Shuffle<T>(List<T> values)
		{
			int count = values.Count;
			for (int i = 0; i < count - 1; i++)
			{
				int index = UnityEngine.Random.Range(i, count);
				T value = values[i];
				values[i] = values[index];
				values[index] = value;
			}
		}
	}
	public class CSVTable
	{
		public struct Row
		{
			private int index;

			private Dictionary<string, int> headerIndexes;

			private string[] columns;

			public int Count => columns.Length;

			internal Row(int index, Dictionary<string, int> headerIndexes, string[] columns)
			{
				this.index = index;
				this.headerIndexes = headerIndexes;
				this.columns = columns;
			}

			private void ValidateHeader(string header)
			{
				if (!headerIndexes.ContainsKey(header))
				{
					throw new KeyNotFoundException("CSVTable.GetRow(" + index + ").GetColumn(" + header + "), header name [" + header + "] invalid!");
				}
			}

			private void ValidateIndex(int i)
			{
				if (i < 0 || i > columns.Length - 1)
				{
					throw new IndexOutOfRangeException("CSVTable.GetRow(" + index + ").GetColumn(" + i + "), column index [" + i + "] out of range!");
				}
			}

			public bool HasValue(int i)
			{
				ValidateIndex(i);
				return !string.IsNullOrEmpty(columns[i]);
			}

			public bool NotEmpty(string header)
			{
				ValidateHeader(header);
				return HasValue(headerIndexes[header]);
			}

			public string GetColumn(int i)
			{
				ValidateIndex(i);
				return columns[i];
			}

			public string GetColumn(string header)
			{
				ValidateHeader(header);
				return GetColumn(headerIndexes[header]);
			}

			public int GetColumnInt(string header)
			{
				return int.Parse(GetColumn(header));
			}

			public int GetColumnInt(int i)
			{
				return int.Parse(GetColumn(i));
			}

			public float GetColumnFloat(string header)
			{
				return float.Parse(GetColumn(header));
			}

			public float GetColumnFloat(int i)
			{
				return float.Parse(GetColumn(i));
			}

			public bool GetColumnBool(string header)
			{
				return GetColumnBool(headerIndexes[header]);
			}

			public bool GetColumnBool(int i)
			{
				string text = GetColumn(i).ToLower();
				return text == "true" || text == "yes";
			}

			public int Index()
			{
				return index;
			}

			public override string ToString()
			{
				string text = "Row " + index + ":: ";
				string[] array = columns;
				foreach (string text2 in array)
				{
					text = text + text2 + ",";
				}
				return text;
			}
		}

		private string path;

		private bool isLoaded;

		private Row[] rows;

		private string[] headers;

		private Dictionary<string, int> headerIndexes;

		public int NumRows => rows.Length - 1;

		public int NumColumns => headers.Length;

		public void LoadFromResources(string path)
		{
			if (path.EndsWith(".csv"))
			{
				throw new FileLoadException("Error opening file " + path + " from CSVTable, should not end in .csv when loading from resources");
			}
			this.path = path;
			string text;
			try
			{
				TextAsset textAsset = (TextAsset)Resources.Load(path, typeof(TextAsset));
				text = textAsset.text;
			}
			catch (Exception inner)
			{
				throw new FileLoadException("Could not load CSV file from " + path, inner);
			}
			string[] array = text.Split('\n');
			headers = array[0].Trim('\r').Split(',');
			headerIndexes = new Dictionary<string, int>(headers.Length);
			for (int i = 0; i < headers.Length; i++)
			{
				headerIndexes[headers[i]] = i;
			}
			rows = new Row[array.Length - 1];
			for (int j = 1; j < array.Length; j++)
			{
				if (array[j] == string.Empty)
				{
					continue;
				}
				string[] array2 = array[j].Trim('\r').Split(',');
				if (array[j].Contains("\""))
				{
					List<string> list = new List<string>(array2.Length);
					bool flag = false;
					string text2 = string.Empty;
					foreach (string text3 in array2)
					{
						if (!flag)
						{
							if (text3.StartsWith("\""))
							{
								flag = true;
								text2 = text3.Substring(1) + ",";
							}
							else
							{
								list.Add(text3);
							}
						}
						else if (flag)
						{
							if (text3.EndsWith("\""))
							{
								text2 += text3.Substring(0, text3.Length - 1);
								flag = false;
								list.Add(text2);
								text2 = string.Empty;
							}
							else
							{
								text2 = text2 + text3 + ",";
							}
						}
					}
					array2 = list.ToArray();
				}
				Row row = new Row(j - 1, headerIndexes, array2);
				rows[j - 1] = row;
			}
			isLoaded = true;
		}

		public string GetHeader(int i)
		{
			if (i < 0 || i > headers.Length - 1)
			{
				throw new IndexOutOfRangeException("CSVTable.GetHeader index out of range: " + i);
			}
			return headers[i];
		}

		public int GetHeaderIndex(string name)
		{
			return headerIndexes[name];
		}

		public bool HasHeader(string name)
		{
			return headerIndexes.ContainsKey(name);
		}

		public Row GetRow(int i)
		{
			if (i < 0 || i > rows.Length - 1)
			{
				throw new IndexOutOfRangeException("CSVTable.GeRow index out of range: " + i);
			}
			return rows[i];
		}

		public override string ToString()
		{
			return "CSVTable [path='" + path + "', isLoaded: " + isLoaded + "]";
		}
	}
	public class PerFrameCounter : MonoBehaviour
	{
		[Conditional("UNITY_EDITOR")]
		public static void Add(string name, int amount = 1)
		{
		}
	}
	public class SpeedControl : MonoBehaviour
	{
		public bool enableOnDevice;

		public KeyCode activationKey = KeyCode.Alpha0;

		public float speedFactorWhenActivated = 0.2f;

		private bool activated;

		private void Start()
		{
			base.enabled = enableOnDevice;
		}

		private void Update()
		{
			if (Input.GetKeyDown(activationKey))
			{
				activated = !activated;
				Time.timeScale = ((!activated) ? 1f : speedFactorWhenActivated);
			}
		}
	}
	public class ToggleActive : MonoBehaviour
	{
		public GameObject[] objects;

		public KeyCode key = KeyCode.T;

		private void Update()
		{
			if (Input.GetKeyDown(key))
			{
				GameObject[] array = objects;
				foreach (GameObject gameObject in array)
				{
					gameObject.SetActive(!gameObject.activeSelf);
				}
			}
		}
	}
	public class CaptureCamera : MonoBehaviour
	{
		public enum FileFormat
		{
			PNG,
			PNGWithAlpha,
			JPG,
			EXR
		}

		[Tooltip("Name of input in InputManager that triggers capturing the camera")]
		public string inputName = "CaptureCamera";

		public Vector2Int resolution = new Vector2Int(2048, 2048);

		public FileFormat fileFormat;

		private static string[] extensions = new string[4] { "png", "png", "jpg", "exr" };

		[Tooltip("Camera to capture. Default is main camera")]
		public Camera cameraToCapture;

		public void Update()
		{
			if (Input.GetButtonDown(inputName))
			{
				Camera main = cameraToCapture;
				if (main == null)
				{
					main = Camera.main;
				}
				if (main == null)
				{
					UnityEngine.Debug.LogFormat("No camera to capture!");
					return;
				}
				UnityEngine.Debug.LogFormat("Capturing camera {0}...", main);
				Capture(main);
			}
		}

		private void Capture(Camera cam)
		{
			RenderTexture targetTexture = cam.targetTexture;
			bool flag = fileFormat == FileFormat.EXR;
			RenderTexture active = (cam.targetTexture = new RenderTexture(resolution.x, resolution.y, 24, flag ? RenderTextureFormat.ARGBFloat : RenderTextureFormat.ARGB32));
			cam.Render();
			cam.targetTexture = targetTexture;
			TextureFormat targetTextureFormat = GetTargetTextureFormat();
			Texture2D texture2D = new Texture2D(resolution.x, resolution.y, targetTextureFormat, mipChain: false);
			RenderTexture.active = active;
			texture2D.ReadPixels(new Rect(0f, 0f, resolution.x, resolution.y), 0, 0);
			texture2D.Apply();
			byte[] bytes;
			switch (fileFormat)
			{
			case FileFormat.PNG:
			case FileFormat.PNGWithAlpha:
				bytes = texture2D.EncodeToPNG();
				break;
			case FileFormat.JPG:
				bytes = texture2D.EncodeToJPG();
				break;
			case FileFormat.EXR:
				bytes = texture2D.EncodeToEXR();
				break;
			default:
				UnityEngine.Debug.LogErrorFormat("Invalid file format: {0}", fileFormat);
				return;
			}
			string text = string.Format("camera-{0}.{1}", DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss"), extensions[(int)fileFormat]);
			File.WriteAllBytes(text, bytes);
			UnityEngine.Debug.LogFormat("Saved image to {0}", text);
		}

		private TextureFormat GetTargetTextureFormat()
		{
			return fileFormat switch
			{
				FileFormat.PNGWithAlpha => TextureFormat.ARGB32, 
				FileFormat.EXR => TextureFormat.RGBAFloat, 
				_ => TextureFormat.RGB24, 
			};
		}
	}
	public class EditorCameraControl : MonoBehaviour
	{
		public float mouseSpeed = 2f;

		public float maxKeyboardRotation = 30f;

		public KeyCode freezeKey = KeyCode.F;

		public float touchRotationSpeed = 0.3f;

		public float keyboardRotationSpeed = 5f;

		public KeyCode turnLeftKey = KeyCode.LeftArrow;

		public KeyCode turnRightKey = KeyCode.RightArrow;

		public KeyCode lookUpKey = KeyCode.UpArrow;

		public KeyCode lookDownKey = KeyCode.DownArrow;

		public KeyCode recenterKey = KeyCode.F12;

		public bool startMouseEnabled = true;

		[Tooltip("If set, rotate the camera in the opposite direction of this object's orientation to disable head rotation tracking")]
		public Transform vrHead;

		private Quaternion startRotation;

		private Vector3 currentRotation;

		private Vector3? currentPosition;

		private bool mouseEnabled;

		private void Start()
		{
			UnityEngine.Object.Destroy(this);
		}

		private void OnEnable()
		{
			startRotation = base.transform.localRotation;
			currentRotation = startRotation.eulerAngles;
		}

		private void OnDisable()
		{
			base.transform.localRotation = startRotation;
		}

		public void SetPosition(Vector3 localPosition)
		{
			currentPosition = localPosition;
			base.transform.localPosition = currentPosition.Value;
		}

		private void Update()
		{
			if (Input.GetKeyDown(freezeKey))
			{
				mouseEnabled = !mouseEnabled;
			}
			if (Input.GetKeyDown(recenterKey))
			{
				InputTracking.Recenter();
				currentRotation = Vector3.zero;
			}
			if (mouseEnabled && Input.touchCount > 0)
			{
				Vector2 vector = Input.GetTouch(0).deltaPosition * touchRotationSpeed;
				currentRotation.y += vector.x;
				currentRotation.x -= vector.y;
			}
			if (mouseEnabled)
			{
				float axis = Input.GetAxis("Mouse X");
				float axis2 = Input.GetAxis("Mouse Y");
				float axis3 = Input.GetAxis("Horizontal");
				currentRotation.y += axis * mouseSpeed;
				currentRotation.x -= axis2 * mouseSpeed;
				currentRotation.z = axis3 * (0f - maxKeyboardRotation);
			}
			if (Input.GetKey(turnLeftKey))
			{
				currentRotation.y -= keyboardRotationSpeed;
			}
			if (Input.GetKey(turnRightKey))
			{
				currentRotation.y += keyboardRotationSpeed;
			}
			if (Input.GetKey(lookUpKey))
			{
				currentRotation.x -= keyboardRotationSpeed;
			}
			if (Input.GetKey(lookDownKey))
			{
				currentRotation.x += keyboardRotationSpeed;
			}
			Quaternion quaternion = Quaternion.Euler(currentRotation);
			if (vrHead != null)
			{
				base.transform.localRotation = quaternion * Quaternion.Inverse(vrHead.localRotation);
				if (currentPosition.HasValue)
				{
					base.transform.localPosition = currentPosition.Value + base.transform.localRotation * -vrHead.localPosition;
				}
			}
			else
			{
				base.transform.localRotation = quaternion;
			}
		}
	}
	public class Fader : MonoBehaviour
	{
		public float targetAlpha;

		public float fadeTime = 2f;

		public Shader fadeShader;

		public Color color = Color.black;

		protected float currentAlpha;

		private Material fadeMaterial;

		public bool Done => currentAlpha == targetAlpha;

		public void FadeIn()
		{
			targetAlpha = 0f;
		}

		public void FadeOut()
		{
			targetAlpha = 1f;
		}

		private void Awake()
		{
			Setup();
			fadeMaterial = new Material(fadeShader);
			fadeMaterial.color = color;
		}

		private void Start()
		{
			currentAlpha = 1f;
		}

		private void Reset()
		{
			Setup();
		}

		private void Setup()
		{
			if (fadeShader == null)
			{
				UnityEngine.Debug.LogWarningFormat("Fader.cs missing shader on object {0}", base.gameObject);
				fadeShader = Shader.Find("Transparent/Diffuse");
			}
		}

		private void Update()
		{
			if (currentAlpha != targetAlpha)
			{
				currentAlpha = Mathf.MoveTowards(currentAlpha, targetAlpha, Time.deltaTime / fadeTime);
				color.a = currentAlpha;
				fadeMaterial.color = color;
				if (currentAlpha != targetAlpha)
				{
				}
			}
		}

		private void OnEnable()
		{
			SceneManager.sceneLoaded += SceneWasLoaded;
		}

		private void OnDisable()
		{
			SceneManager.sceneLoaded -= SceneWasLoaded;
		}

		private void SceneWasLoaded(Scene scene, LoadSceneMode mode)
		{
			FadeIn();
		}

		private void OnDestroy()
		{
			if (fadeMaterial != null)
			{
				UnityEngine.Object.Destroy(fadeMaterial);
			}
		}

		private void OnPostRender()
		{
			if (currentAlpha != 0f)
			{
				fadeMaterial.SetPass(0);
				GL.PushMatrix();
				GL.LoadOrtho();
				GL.Color(fadeMaterial.color);
				GL.Begin(7);
				GL.Vertex3(0f, 0f, -12f);
				GL.Vertex3(0f, 1f, -12f);
				GL.Vertex3(1f, 1f, -12f);
				GL.Vertex3(1f, 0f, -12f);
				GL.End();
				GL.PopMatrix();
			}
		}
	}
	public class FpsDisplay : MonoBehaviour
	{
		public float updateInterval = 1f;

		public KeyCode toggleKey = KeyCode.R;

		public bool visible;

		public float warningTime = 0.018f;

		public Color standardColor = Color.gray;

		public Color warningColor = Color.red;

		private TextMesh textMesh;

		private Renderer rendererComponent;

		private int frameCount;

		private int warningCount;

		private float elapsed;

		private float fps;

		private float msPerFrame;

		private float maxTime;

		private float minTime = float.PositiveInfinity;

		private string text;

		private float lastUpdate;

		private float collectionStartTime;

		private void Awake()
		{
			textMesh = Find.ComponentOnGameObject<TextMesh>(this);
			rendererComponent = Find.ComponentOnGameObject<Renderer>(this);
		}

		private void Start()
		{
			collectionStartTime = Time.realtimeSinceStartup;
			rendererComponent.enabled = visible;
			rendererComponent.material.color = standardColor;
		}

		private void Update()
		{
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			float num = realtimeSinceStartup - lastUpdate;
			if (visible)
			{
				if (num > warningTime)
				{
					rendererComponent.material.color = warningColor;
					warningCount++;
				}
				else
				{
					rendererComponent.material.color = standardColor;
				}
			}
			maxTime = Mathf.Max(maxTime, num);
			minTime = Mathf.Min(minTime, num);
			lastUpdate = realtimeSinceStartup;
			frameCount++;
			if (Input.GetKeyDown(toggleKey))
			{
				ToggleVisibility();
			}
			float num2 = realtimeSinceStartup - collectionStartTime;
			if (num2 >= updateInterval)
			{
				fps = (float)frameCount / num2;
				msPerFrame = num2 / (float)frameCount * 1000f;
				if (visible)
				{
					UpdateDisplay();
				}
				frameCount = 0;
				warningCount = 0;
				maxTime = 0f;
				minTime = float.PositiveInfinity;
				collectionStartTime = realtimeSinceStartup;
			}
		}

		public void ToggleVisibility()
		{
			visible = !visible;
			rendererComponent.enabled = visible;
			if (visible)
			{
				UpdateDisplay();
			}
		}

		private void UpdateDisplay()
		{
			text = string.Format("{0:F2}FPS avg={1:F2} min={3:F2} max={2:F2} ms {4}W", fps, msPerFrame, maxTime * 1000f, minTime * 1000f, warningCount);
			textMesh.text = text;
		}
	}
	public class Screenshot : MonoBehaviour
	{
		public KeyCode screenshotKey = KeyCode.C;

		public int superSize = 4;

		public void Start()
		{
			UnityEngine.Object.DestroyImmediate(this);
		}

		public void LateUpdate()
		{
			if (Input.GetKeyDown(screenshotKey))
			{
				TakeScreenshot();
			}
		}

		public static string ScreenShotName()
		{
			return string.Format("screen-{0}.png", DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss"));
		}

		public void TakeScreenshot()
		{
			string text = ScreenShotName();
			ScreenCapture.CaptureScreenshot(text, superSize);
			UnityEngine.Debug.Log("Screenshot captured: " + text);
		}
	}
	public static class Find
	{
		public static GameObject ChildByName(UnityEngine.Component tag, string path)
		{
			return InternalFindChildByName(tag, tag.transform, path).gameObject;
		}

		public static GameObject ChildByName(object tag, GameObject go, string path)
		{
			return InternalFindChildByName(tag, go.transform, path).gameObject;
		}

		public static Transform ChildTransformByName(UnityEngine.Component tag, string path)
		{
			return InternalFindChildByName(tag, tag.transform, path);
		}

		public static Transform ChildTransformByName(object tag, Transform go, string path)
		{
			return InternalFindChildByName(tag, go, path);
		}

		public static T ComponentOnGameObject<T>(UnityEngine.Component tag) where T : UnityEngine.Component
		{
			return InternalFindComponentOnGameObject<T>(tag, tag.gameObject);
		}

		public static T ComponentOnGameObject<T>(GameObject tag) where T : UnityEngine.Component
		{
			return InternalFindComponentOnGameObject<T>(tag, tag);
		}

		public static T ComponentOnGameObject<T>(object tag, GameObject go) where T : UnityEngine.Component
		{
			return InternalFindComponentOnGameObject<T>(tag, go);
		}

		public static T ComponentOrCreate<T>(GameObject gameObject) where T : UnityEngine.Component
		{
			T component = gameObject.GetComponent<T>();
			if (component != null)
			{
				return component;
			}
			return gameObject.AddComponent<T>();
		}

		public static T ComponentOnChild<T>(UnityEngine.Component tag, string path) where T : UnityEngine.Component
		{
			return InternalFindComponentOnChild<T>(tag, tag.gameObject, path);
		}

		public static T ComponentOnChild<T>(object tag, GameObject go, string path) where T : UnityEngine.Component
		{
			return InternalFindComponentOnChild<T>(tag, go, path);
		}

		public static T ComponentInChildren<T>(UnityEngine.Component tag) where T : UnityEngine.Component
		{
			return InternalFindComponentInChildren<T>(tag, tag.gameObject);
		}

		public static T ComponentInChildren<T>(object tag, GameObject go) where T : UnityEngine.Component
		{
			return InternalFindComponentInChildren<T>(tag, go);
		}

		public static T ComponentOrNull<T>(GameObject container) where T : UnityEngine.Component
		{
			return container.GetComponent<T>();
		}

		private static Transform InternalFindChildByName(object tag, Transform transform, string path)
		{
			string template = "The tag [[tag]] is expecting GameObject [[gameobject]] to have a child named [[path]]";
			Transform transform2 = transform.Find(path);
			if (transform2 == null)
			{
				throw new Exception(FormatError(template, tag, transform.gameObject, path, null, "GameObject does not exist: [[fullpath]]"));
			}
			return transform2;
		}

		private static T InternalFindComponentOnGameObject<T>(object tag, GameObject go) where T : UnityEngine.Component
		{
			string template = "The tag [[tag]] is expecting GameObject [[gameobject]] to have component [[component]]";
			T component = go.GetComponent<T>();
			if (component == null)
			{
				throw new Exception(FormatError(template, tag, go, null, typeof(T), "component does not exist on [[gameobject]]"));
			}
			return component;
		}

		private static T InternalFindComponentOnChild<T>(object tag, GameObject go, string path) where T : UnityEngine.Component
		{
			string template = "The tag [[tag]] is expecting GameObject [[gameobject]] with child [[path]] to have component [[component]]";
			Transform transform = go.transform.Find(path);
			if (transform == null)
			{
				throw new Exception(FormatError(template, tag, go, path, typeof(T), "gameObject [[fullpath]] does not exist"));
			}
			T component = transform.gameObject.GetComponent<T>();
			if (component == null)
			{
				throw new Exception(FormatError(template, tag, go, path, typeof(T), "no component [[component]] exists on [[fullpath]]"));
			}
			return component;
		}

		private static T InternalFindComponentInChildren<T>(object tag, GameObject go)
		{
			string template = "The tag [[tag]] is expecting GameObject [[gameobject]] to have any child with script [[component]]";
			T[] componentsInChildren = go.GetComponentsInChildren<T>();
			if (componentsInChildren.Length == 0)
			{
				throw new Exception(FormatError(template, tag, go, null, typeof(T), "component [[component]] does not exist on any children"));
			}
			if (componentsInChildren.Length > 1)
			{
				throw new Exception(FormatError(template, tag, go, null, typeof(T), "more than one component of type [[component]] exists in children"));
			}
			return componentsInChildren[0];
		}

		private static string FormatError(string template, object tag, GameObject go, string path, Type t, string reason)
		{
			return "FIND ERROR! ";
		}

		private static string FormatTag(object theTag)
		{
			if (theTag is GameObject)
			{
				return "GameObject: '" + ((GameObject)theTag).name + "'";
			}
			if (theTag is MonoBehaviour)
			{
				return "MonoBehaviour: '" + theTag.GetType().FullName + "'";
			}
			return theTag.GetType().Name;
		}
	}
	public static class ComponentValidation
	{
		public static bool DisableIfNull(MonoBehaviour component, UnityEngine.Object attributeValue, string attributeName)
		{
			if (attributeValue == null)
			{
				UnityEngine.Debug.LogFormat("Attribute \"{0}\" on \"{1}\" is null - disabling component", attributeName, component);
				component.enabled = false;
				return true;
			}
			return false;
		}

		[Conditional("UNITY_ASSERTIONS")]
		public static void FailIfNull(MonoBehaviour component, UnityEngine.Object attributeValue, string attributeName)
		{
		}
	}
	public class DontDestroyOnLoad : MonoBehaviour
	{
		private void Awake()
		{
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}
	}
	public class Loader : MonoBehaviour
	{
		public string scene;

		public float minimumTime;

		private IEnumerator Start()
		{
			Fader[] faders = UnityEngine.Object.FindObjectsOfType<Fader>();
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			float startTime = Time.time;
			if (faders.Length > 0)
			{
				bool allFadersDone4 = false;
				do
				{
					yield return null;
					allFadersDone4 = true;
					for (int i = 0; i < faders.Length; i++)
					{
						allFadersDone4 = allFadersDone4 && faders[i].Done;
					}
				}
				while (!allFadersDone4);
			}
			UnityEngine.AsyncOperation async = SceneManager.LoadSceneAsync(scene);
			async.allowSceneActivation = false;
			do
			{
				yield return null;
			}
			while (async.progress < 0.9f);
			float timeLeft = startTime + minimumTime - Time.time;
			yield return new WaitForSeconds(Mathf.Max(0f, timeLeft));
			if (faders.Length > 0)
			{
				Fader[] array = faders;
				foreach (Fader fader in array)
				{
					fader.FadeOut();
				}
				bool allFadersDone2 = false;
				do
				{
					yield return null;
					allFadersDone2 = true;
					for (int k = 0; k < faders.Length; k++)
					{
						allFadersDone2 = allFadersDone2 && faders[k].Done;
					}
				}
				while (!allFadersDone2);
			}
			async.allowSceneActivation = true;
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
	public class SingleInstanceBehavior<T> : MonoBehaviour where T : SingleInstanceBehavior<T>
	{
		private static T instance;

		private static string noInstanceMessage;

		public static T Instance => instance;

		static SingleInstanceBehavior()
		{
			noInstanceMessage = $"No instance of {typeof(T)}";
		}

		public virtual void Awake()
		{
			instance = (T)this;
		}

		public virtual void OnDestroy()
		{
			instance = (T)null;
		}

		public static T GetInstance()
		{
			return instance;
		}
	}
	public class Singleton<T> where T : Singleton<T>, new()
	{
		private static T instance;

		public static T Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new T();
				}
				return instance;
			}
		}

		public Singleton()
		{
			instance = (T)this;
		}

		public static T GetInstance()
		{
			return instance;
		}
	}
	public class SingletonBehavior<T> : MonoBehaviour where T : SingletonBehavior<T>
	{
		private static T instance;

		public static T Instance
		{
			get
			{
				if (instance == null)
				{
					GameObject gameObject = new GameObject(typeof(T).Name);
					instance = gameObject.AddComponent<T>();
				}
				return instance;
			}
		}

		public virtual void Awake()
		{
			if (instance != null && instance != (T)this)
			{
				UnityEngine.Object.DestroyImmediate(this);
			}
			else
			{
				instance = (T)this;
			}
		}

		public virtual void OnDestroy()
		{
			if (instance == (T)this)
			{
				instance = (T)null;
			}
		}

		public static T GetInstance()
		{
			return instance;
		}
	}
	public class Locale : Singleton<Locale>
	{
		private string language;

		private string country;

		private string explicitlySetLocale;

		private string currentLocale;

		private string[] availableLocales;

		private string[] stringIDs;

		private Dictionary<string, string> strings;

		private const string resourceFolder = "Text";

		private const string binaryResourceSuffix = "_Strings";

		private static Dictionary<string, string> countrySpecificLocales = new Dictionary<string, string>
		{
			{ "es-AR", "es-419" },
			{ "es-BO", "es-419" },
			{ "es-CL", "es-419" },
			{ "es-CO", "es-419" },
			{ "es-CR", "es-419" },
			{ "es-DO", "es-419" },
			{ "es-EC", "es-419" },
			{ "es-GT", "es-419" },
			{ "es-HN", "es-419" },
			{ "es-MX", "es-419" },
			{ "es-NI", "es-419" },
			{ "es-PA", "es-419" },
			{ "es-PE", "es-419" },
			{ "es-PR", "es-419" },
			{ "es-PY", "es-419" },
			{ "es-SV", "es-419" },
			{ "es-US", "es-419" },
			{ "es-UY", "es-419" },
			{ "es-VE", "es-419" },
			{ "es-CU", "es-419" },
			{ "en-AU", "en-GB" },
			{ "zh-SG", "zh-TW" },
			{ "zh-MO", "zh-TW" },
			{ "zh-HK", "zh-TW" },
			{ "zh-CN", "zh-TW" }
		};

		public Locale()
		{
			LoadAvailableLocales();
			SetDefaultLanguageAndCountry();
			currentLocale = GetLocale(availableLocales);
			LoadStrings();
		}

		public string GetString(string key)
		{
			if (string.IsNullOrEmpty(key) || !strings.TryGetValue(key, out var value))
			{
				return key;
			}
			return value;
		}

		public bool TryGetString(string key, out string localized)
		{
			if (string.IsNullOrEmpty(key) || !strings.TryGetValue(key, out localized))
			{
				localized = null;
				return false;
			}
			return true;
		}

		public string Format(string key, params object[] templateArguments)
		{
			string @string = GetString(key);
			try
			{
				return string.Format(@string, templateArguments);
			}
			catch (FormatException ex)
			{
				UnityEngine.Debug.LogErrorFormat("Error in template format for string \"{0}\" for locale \"{1}\": \"{2}\": {3} ", key, currentLocale, @string, ex);
				return @string;
			}
		}

		public bool TryFormat(string key, out string localized, params object[] templateArguments)
		{
			if (!TryGetString(key, out var localized2))
			{
				localized = null;
				return false;
			}
			try
			{
				localized = string.Format(localized2, templateArguments);
			}
			catch (FormatException ex)
			{
				UnityEngine.Debug.LogErrorFormat("Error in template format for string \"{0}\" for locale \"{1}\": \"{2}\": {3} ", key, currentLocale, localized2, ex);
				localized = null;
				return false;
			}
			return true;
		}

		public string GetDefaultLanguageOrLocale()
		{
			if (explicitlySetLocale != null)
			{
				return explicitlySetLocale;
			}
			return language;
		}

		public string GetDefaultCountry()
		{
			return country;
		}

		public string GetCurrentLocale()
		{
			return currentLocale;
		}

		public void SetLocale(string localeCode)
		{
			explicitlySetLocale = localeCode;
			currentLocale = localeCode;
			LoadStrings();
		}

		public string[] GetAvailableLocales()
		{
			if (availableLocales == null || UnityEngine.Application.isEditor)
			{
				LoadAvailableLocales();
			}
			return availableLocales;
		}

		public string GetLocale(string[] availableLocales)
		{
			string text = ((explicitlySetLocale == null) ? (language + "-" + country) : explicitlySetLocale);
			for (int i = 0; i < availableLocales.Length; i++)
			{
				if (availableLocales[i].Equals(text))
				{
					return text;
				}
			}
			if (countrySpecificLocales.TryGetValue(text, out var value))
			{
				text = value;
			}
			for (int j = 0; j < availableLocales.Length; j++)
			{
				if (availableLocales[j].Equals(text))
				{
					return text;
				}
			}
			for (int k = 0; k < availableLocales.Length; k++)
			{
				if (availableLocales[k].Substring(0, 2).Equals(text.Substring(0, 2)))
				{
					return availableLocales[k];
				}
			}
			return "en-US";
		}

		public string[] GetStringIDs()
		{
			if (stringIDs == null)
			{
				return new string[0];
			}
			return stringIDs;
		}

		public void Refresh()
		{
			LoadAvailableLocales();
			LoadStrings();
		}

		private void LoadAvailableLocales()
		{
			string path = "Text/Languages";
			TextAsset textAsset = (TextAsset)Resources.Load(path, typeof(TextAsset));
			if (textAsset == null)
			{
				availableLocales = new string[0];
				return;
			}
			availableLocales = textAsset.text.Split(',');
		}

		private void LoadStrings()
		{
			strings = new Dictionary<string, string>();
			if (!TryLoadStrings())
			{
				TryLoadStringsFromBinaryAssets();
			}
			stringIDs = new string[strings.Count];
			strings.Keys.CopyTo(stringIDs, 0);
		}

		private bool TryLoadStrings()
		{
			string path = "Text/" + currentLocale;
			Translations translations = Resources.Load<Translations>(path);
			if (translations == null)
			{
				return false;
			}
			Translations.StringEntry[] entries = translations.entries;
			int i = 0;
			for (int num = entries.Length; i < num; i++)
			{
				strings[entries[i].id] = entries[i].translation;
			}
			return true;
		}

		private bool TryLoadStringsFromBinaryAssets()
		{
			string path = "Text/" + currentLocale + "_Strings";
			TextAsset textAsset = (TextAsset)Resources.Load(path, typeof(TextAsset));
			if (textAsset == null)
			{
				return false;
			}
			SeparatedStringReader separatedStringReader = new SeparatedStringReader(textAsset.bytes);
			while (separatedStringReader.HasNext())
			{
				string next = separatedStringReader.GetNext();
				string next2 = separatedStringReader.GetNext();
				strings[next] = next2;
			}
			return true;
		}

		private void SetDefaultLanguageAndCountry()
		{
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("java.util.Locale");
			AndroidJavaObject androidJavaObject = androidJavaClass.CallStatic<AndroidJavaObject>("getDefault", new object[0]);
			language = androidJavaObject.Call<string>("getLanguage", new object[0]);
			country = androidJavaObject.Call<string>("getCountry", new object[0]);
			UnityEngine.Debug.LogFormat("Locale: language={0} country={1}", language, country);
		}

		[Obsolete("GetLanguage is deprecated, use GetResourceLocale instead.")]
		public string GetLanguage()
		{
			return GetCurrentLocale();
		}

		[Obsolete("SetLanguage is deprecated, use SetLocale instead.")]
		public void SetLanguage(string languageCode)
		{
			SetLocale(languageCode);
		}

		[Obsolete("GetAvailableLanguages is deprecated, use GetAvailableLocales instead.")]
		public string[] GetAvailableLanguages()
		{
			return GetAvailableLocales();
		}
	}
	public class LocaleFonts : SingleInstanceBehavior<LocaleFonts>
	{
		[Serializable]
		public class Settings
		{
			[Tooltip("Locale code (language or language-region)")]
			public string locale;

			[Tooltip("The font to use for text in this locale")]
			public Font font;

			[Tooltip("The size of the text relative to the original font")]
			public float scale = 1f;
		}

		[SerializeField]
		[Tooltip("Locales that should use a specific font")]
		private Settings[] localeSettings;

		public Settings GetCurrentLocaleSettings()
		{
			string currentLocale = Singleton<Locale>.Instance.GetCurrentLocale();
			int i = 0;
			for (int num = localeSettings.Length; i < num; i++)
			{
				if (localeSettings[i].locale == currentLocale)
				{
					return localeSettings[i];
				}
			}
			return null;
		}
	}
	[DisallowMultipleComponent]
	public class LocalizedText : MonoBehaviour
	{
		private struct FontProxy
		{
			public Font font;
		}

		private interface ITextComponent
		{
			string Text { get; set; }

			FontProxy Font { get; set; }

			int FontSize { get; set; }
		}

		private sealed class TextComponent : ITextComponent
		{
			private readonly Text textComponent;

			public string Text
			{
				get
				{
					return textComponent.text;
				}
				set
				{
					textComponent.text = value;
				}
			}

			public FontProxy Font
			{
				get
				{
					FontProxy result = default(FontProxy);
					result.font = textComponent.font;
					return result;
				}
				set
				{
					textComponent.font = value.font;
				}
			}

			public int FontSize
			{
				get
				{
					return textComponent.fontSize;
				}
				set
				{
					textComponent.fontSize = value;
				}
			}

			public TextComponent(Text text)
			{
				textComponent = text;
			}
		}

		private sealed class TextMeshComponent : ITextComponent
		{
			private readonly TextMesh textComponent;

			public string Text
			{
				get
				{
					return textComponent.text;
				}
				set
				{
					textComponent.text = value;
				}
			}

			public FontProxy Font
			{
				get
				{
					FontProxy result = default(FontProxy);
					result.font = textComponent.font;
					return result;
				}
				set
				{
					textComponent.font = value.font;
				}
			}

			public int FontSize
			{
				get
				{
					return textComponent.fontSize;
				}
				set
				{
					textComponent.fontSize = value;
				}
			}

			public TextMeshComponent(TextMesh text)
			{
				textComponent = text;
			}
		}

		[SerializeField]
		private string stringID;

		private ITextComponent textComponent;

		private string[] templateArguments = new string[10];

		private int?[] templateArgumentsInts = new int?[10];

		private bool fontOverridden;

		private FontProxy? originalFont;

		private int originalFontSize;

		private void Start()
		{
			FindComponents();
			UpdateText();
			UpdateFont();
		}

		public void ShowString(string stringID)
		{
			this.stringID = stringID;
			UpdateText();
		}

		public void SetTemplateArgument(int index, string value)
		{
			if (templateArguments[index] == null || !templateArguments[index].Equals(value))
			{
				templateArguments[index] = value;
				templateArgumentsInts[index] = null;
				UpdateText();
			}
		}

		public void SetTemplateArgument(int index, int value)
		{
			if (!templateArgumentsInts[index].HasValue || templateArgumentsInts[index].Value != value)
			{
				ref int? reference = ref templateArgumentsInts[index];
				reference = value;
				templateArguments[index] = value.ToString();
				UpdateText();
			}
		}

		public void ShowRawText(string text)
		{
			stringID = null;
			FindComponents();
			if (textComponent != null)
			{
				textComponent.Text = text;
			}
		}

		public void UpdateText()
		{
			if (!string.IsNullOrEmpty(stringID))
			{
				string text = ((templateArguments != null) ? Singleton<Locale>.Instance.Format(stringID, templateArguments) : Singleton<Locale>.Instance.GetString(stringID));
				if (textComponent != null)
				{
					textComponent.Text = text;
				}
			}
		}

		public void UpdateFont()
		{
			if (!UnityEngine.Application.isPlaying || textComponent == null)
			{
				return;
			}
			LocaleFonts localeFonts = ((!UnityEngine.Application.isPlaying) ? UnityEngine.Object.FindObjectOfType<LocaleFonts>() : SingleInstanceBehavior<LocaleFonts>.GetInstance());
			LocaleFonts.Settings settings = null;
			if (localeFonts != null)
			{
				settings = localeFonts.GetCurrentLocaleSettings();
			}
			if (settings == null)
			{
				if (fontOverridden)
				{
					textComponent.Font = originalFont.Value;
					textComponent.FontSize = originalFontSize;
					originalFont = null;
					originalFontSize = 0;
					fontOverridden = false;
				}
				return;
			}
			if (!fontOverridden)
			{
				originalFont = textComponent.Font;
				originalFontSize = textComponent.FontSize;
				fontOverridden = true;
			}
			int fontSize = Mathf.RoundToInt(settings.scale * (float)originalFontSize);
			textComponent.Font = new FontProxy
			{
				font = settings.font
			};
			textComponent.FontSize = fontSize;
		}

		private void FindComponents()
		{
			bool flag = false;
			if (!flag)
			{
				Text component = GetComponent<Text>();
				if (component != null)
				{
					textComponent = new TextComponent(component);
					flag = true;
				}
			}
			if (!flag)
			{
				TextMesh component2 = GetComponent<TextMesh>();
				if (component2 != null)
				{
					textComponent = new TextMeshComponent(component2);
					flag = true;
				}
			}
			if (!flag)
			{
				string text = ((!string.IsNullOrEmpty(stringID)) ? stringID : "no string id set");
				string text2 = base.gameObject.name;
				Transform parent = base.transform.parent;
				while (parent != null)
				{
					text2 = parent.name + "/" + text2;
					parent = parent.parent;
				}
				UnityEngine.Debug.LogErrorFormat("LocalizedText could not find a text or textmesh component on gameObject '{0}' (stringID: '{1}')", text2, text);
			}
		}
	}
	public struct SeparatedStringReader
	{
		private byte[] bytes;

		private int index;

		public SeparatedStringReader(byte[] bytes, int startingIndex = 0)
		{
			this.bytes = bytes;
			index = startingIndex;
		}

		public bool HasNext()
		{
			return index != bytes.Length;
		}

		public string GetNext()
		{
			int num = index;
			while (index != bytes.Length && bytes[index] != 0)
			{
				index++;
			}
			string @string = Encoding.UTF8.GetString(bytes, num, index - num);
			if (index != bytes.Length)
			{
				index++;
			}
			return @string;
		}
	}
	public class TextTemplateDemo : MonoBehaviour
	{
		public bool useIntegerArgument = true;

		private int number;

		private void Update()
		{
			LocalizedText component = GetComponent<LocalizedText>();
			if (Time.frameCount % 60 == 0)
			{
				number++;
			}
			if (useIntegerArgument)
			{
				component.SetTemplateArgument(0, number);
			}
			else
			{
				component.SetTemplateArgument(0, number.ToString());
			}
		}
	}
	public class Translations : ScriptableObject
	{
		[Serializable]
		public struct StringEntry
		{
			public string id;

			public string translation;
		}

		public StringEntry[] entries;
	}
	public static class Interpolation
	{
		public static float EaseInEaseOut(float progress, int depth)
		{
			float num = progress;
			while (depth > 1)
			{
				num = Mathf.SmoothStep(0f, 1f, num);
				depth--;
			}
			return num;
		}

		public static bool ProgressOverTime(float startTime, float totalTime, ref float progress)
		{
			if (progress >= 1f)
			{
				progress = 1f;
				return false;
			}
			progress = Mathf.Clamp01((Time.time - startTime) / totalTime);
			return true;
		}
	}
	public abstract class TwoD
	{
		public static bool TriangleIsInBounds(Rect bounds, Vector2 p0, Vector2 p1, Vector2 p2)
		{
			return TriangleIntersectsRectangle(p0, p1, p2, bounds) || TriangleContainsPoint(p0, p1, p2, new Vector2(bounds.xMin, bounds.yMin)) || TriangleContainsPoint(p0, p1, p2, new Vector2(bounds.xMax, bounds.yMin)) || TriangleContainsPoint(p0, p1, p2, new Vector2(bounds.xMin, bounds.yMax)) || TriangleContainsPoint(p0, p1, p2, new Vector2(bounds.xMax, bounds.yMax));
		}

		public static bool TriangleContainsPoint(Vector2 vertex0, Vector2 vertex1, Vector2 vertex2, Vector2 point)
		{
			return PointsOnSameSide(vertex0, vertex1, vertex2, point) && PointsOnSameSide(vertex1, vertex2, vertex0, point) && PointsOnSameSide(vertex2, vertex0, vertex1, point);
		}

		public static bool PointsOnSameSide(Vector2 line0, Vector2 line1, Vector2 point0, Vector2 point1)
		{
			return 0f <= Determinant(line0, line1, point0) * Determinant(line0, line1, point1);
		}

		public static Vector3 ToBarycentric(Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p)
		{
			float x = p.x;
			float y = p.y;
			float x2 = p0.x;
			float y2 = p0.y;
			float x3 = p1.x;
			float y3 = p1.y;
			float x4 = p2.x;
			float y4 = p2.y;
			float num = ((y3 - y4) * (x - x4) + (x4 - x3) * (y - y4)) / ((y3 - y4) * (x2 - x4) + (x4 - x3) * (y2 - y4));
			float num2 = ((y4 - y2) * (x - x4) + (x2 - x4) * (y - y4)) / ((y3 - y4) * (x2 - x4) + (x4 - x3) * (y2 - y4));
			float z = 1f - num - num2;
			return new Vector3(num, num2, z);
		}

		public static float Determinant(Vector2 p0, Vector2 p1, Vector2 p2)
		{
			return p0.x * p1.y + p1.x * p2.y + p2.x * p0.y - p0.x * p2.y - p1.x * p0.y - p2.x * p1.y;
		}

		public static bool TriangleIntersectsRectangle(Vector2 vertex0, Vector2 vertex1, Vector2 vertex2, Rect rect)
		{
			float xMin = rect.xMin;
			float xMax = rect.xMax;
			float yMin = rect.yMin;
			float yMax = rect.yMax;
			float x = vertex0.x;
			float y = vertex0.y;
			float x2 = vertex1.x;
			float y2 = vertex1.y;
			float x3 = vertex2.x;
			float y3 = vertex2.y;
			int num = ((x > xMin) ? 1 : 0) | (((y > yMin) ? 1 : 0) << 1) | (((x > xMax) ? 1 : 0) << 2) | (((y > yMax) ? 1 : 0) << 3);
			if (num == 3)
			{
				return true;
			}
			int num2 = ((x2 > xMin) ? 1 : 0) | (((y2 > yMin) ? 1 : 0) << 1) | (((x2 > xMax) ? 1 : 0) << 2) | (((y2 > yMax) ? 1 : 0) << 3);
			if (num2 == 3)
			{
				return true;
			}
			int num3 = ((x3 > xMin) ? 1 : 0) | (((y3 > yMin) ? 1 : 0) << 1) | (((x3 > xMax) ? 1 : 0) << 2) | (((y3 > yMax) ? 1 : 0) << 3);
			if (num3 == 3)
			{
				return true;
			}
			int num4 = num ^ num2;
			if (num4 != 0)
			{
				float num5 = (y2 - y) / (x2 - x);
				float num6 = y - num5 * x;
				if (((uint)num4 & (true ? 1u : 0u)) != 0)
				{
					float num7 = num5 * xMin + num6;
					if (num7 > yMin && num7 < yMax)
					{
						return true;
					}
				}
				if (((uint)num4 & 2u) != 0)
				{
					float num7 = (yMin - num6) / num5;
					if (num7 > xMin && num7 < xMax)
					{
						return true;
					}
				}
				if (((uint)num4 & 4u) != 0)
				{
					float num7 = num5 * xMax + num6;
					if (num7 > yMin && num7 < yMax)
					{
						return true;
					}
				}
				if (((uint)num4 & 8u) != 0)
				{
					float num7 = (yMax - num6) / num5;
					if (num7 > xMin && num7 < xMax)
					{
						return true;
					}
				}
			}
			int num8 = num2 ^ num3;
			if (num8 != 0)
			{
				float num9 = (y3 - y2) / (x3 - x2);
				float num10 = y2 - num9 * x2;
				if (((uint)num8 & (true ? 1u : 0u)) != 0)
				{
					float num7 = num9 * xMin + num10;
					if (num7 > yMin && num7 < yMax)
					{
						return true;
					}
				}
				if (((uint)num8 & 2u) != 0)
				{
					float num7 = (yMin - num10) / num9;
					if (num7 > xMin && num7 < xMax)
					{
						return true;
					}
				}
				if (((uint)num8 & 4u) != 0)
				{
					float num7 = num9 * xMax + num10;
					if (num7 > yMin && num7 < yMax)
					{
						return true;
					}
				}
				if (((uint)num8 & 8u) != 0)
				{
					float num7 = (yMax - num10) / num9;
					if (num7 > xMin && num7 < xMax)
					{
						return true;
					}
				}
			}
			int num11 = num ^ num3;
			if (num11 != 0)
			{
				float num12 = (y3 - y) / (x3 - x);
				float num13 = y - num12 * x;
				if (((uint)num11 & (true ? 1u : 0u)) != 0)
				{
					float num7 = num12 * xMin + num13;
					if (num7 > yMin && num7 < yMax)
					{
						return true;
					}
				}
				if (((uint)num11 & 2u) != 0)
				{
					float num7 = (yMin - num13) / num12;
					if (num7 > xMin && num7 < xMax)
					{
						return true;
					}
				}
				if (((uint)num11 & 4u) != 0)
				{
					float num7 = num12 * xMax + num13;
					if (num7 > yMin && num7 < yMax)
					{
						return true;
					}
				}
				if (((uint)num11 & 8u) != 0)
				{
					float num7 = (yMax - num13) / num12;
					if (num7 > xMin && num7 < xMax)
					{
						return true;
					}
				}
			}
			return false;
		}

		[Obsolete("Use VectorExtensions.SwizzleXZ instead")]
		public static Vector2 SwizzleXZ(Vector3 v)
		{
			return new Vector2(v.x, v.z);
		}
	}
}
namespace RGCommon.VectorExtensions
{
	public static class VectorComponentReplacement
	{
		public static Vector3 WithX(this Vector3 original, float newX)
		{
			return new Vector3(newX, original.y, original.z);
		}

		public static Vector3 WithY(this Vector3 original, float newY)
		{
			return new Vector3(original.x, newY, original.z);
		}

		public static Vector3 WithZ(this Vector3 original, float newZ)
		{
			return new Vector3(original.x, original.y, newZ);
		}

		public static Vector2 WithX(this Vector2 original, float newX)
		{
			return new Vector2(newX, original.y);
		}

		public static Vector2 WithY(this Vector2 original, float newY)
		{
			return new Vector2(original.x, newY);
		}
	}
	public static class VectorSwizzle
	{
		public static Vector2 Swizzle00(this Vector3 original)
		{
			return new Vector2(0f, 0f);
		}

		public static Vector2 Swizzle0X(this Vector3 original)
		{
			return new Vector2(0f, original.x);
		}

		public static Vector2 Swizzle0Y(this Vector3 original)
		{
			return new Vector2(0f, original.y);
		}

		public static Vector2 Swizzle0Z(this Vector3 original)
		{
			return new Vector2(0f, original.z);
		}

		public static Vector2 SwizzleX0(this Vector3 original)
		{
			return new Vector2(original.x, 0f);
		}

		public static Vector2 SwizzleXX(this Vector3 original)
		{
			return new Vector2(original.x, original.x);
		}

		public static Vector2 SwizzleXY(this Vector3 original)
		{
			return new Vector2(original.x, original.y);
		}

		public static Vector2 SwizzleXZ(this Vector3 original)
		{
			return new Vector2(original.x, original.z);
		}

		public static Vector2 SwizzleY0(this Vector3 original)
		{
			return new Vector2(original.y, 0f);
		}

		public static Vector2 SwizzleYX(this Vector3 original)
		{
			return new Vector2(original.y, original.x);
		}

		public static Vector2 SwizzleYY(this Vector3 original)
		{
			return new Vector2(original.y, original.y);
		}

		public static Vector2 SwizzleYZ(this Vector3 original)
		{
			return new Vector2(original.y, original.z);
		}

		public static Vector2 SwizzleZ0(this Vector3 original)
		{
			return new Vector2(original.z, 0f);
		}

		public static Vector2 SwizzleZX(this Vector3 original)
		{
			return new Vector2(original.z, original.x);
		}

		public static Vector2 SwizzleZY(this Vector3 original)
		{
			return new Vector2(original.z, original.y);
		}

		public static Vector2 SwizzleZZ(this Vector3 original)
		{
			return new Vector2(original.z, original.z);
		}

		public static Vector3 Swizzle000(this Vector3 original)
		{
			return new Vector3(0f, 0f, 0f);
		}

		public static Vector3 Swizzle00X(this Vector3 original)
		{
			return new Vector3(0f, 0f, original.x);
		}

		public static Vector3 Swizzle00Y(this Vector3 original)
		{
			return new Vector3(0f, 0f, original.y);
		}

		public static Vector3 Swizzle00Z(this Vector3 original)
		{
			return new Vector3(0f, 0f, original.z);
		}

		public static Vector3 Swizzle0X0(this Vector3 original)
		{
			return new Vector3(0f, original.x, 0f);
		}

		public static Vector3 Swizzle0XX(this Vector3 original)
		{
			return new Vector3(0f, original.x, original.x);
		}

		public static Vector3 Swizzle0XY(this Vector3 original)
		{
			return new Vector3(0f, original.x, original.y);
		}

		public static Vector3 Swizzle0XZ(this Vector3 original)
		{
			return new Vector3(0f, original.x, original.z);
		}

		public static Vector3 Swizzle0Y0(this Vector3 original)
		{
			return new Vector3(0f, original.y, 0f);
		}

		public static Vector3 Swizzle0YX(this Vector3 original)
		{
			return new Vector3(0f, original.y, original.x);
		}

		public static Vector3 Swizzle0YY(this Vector3 original)
		{
			return new Vector3(0f, original.y, original.y);
		}

		public static Vector3 Swizzle0YZ(this Vector3 original)
		{
			return new Vector3(0f, original.y, original.z);
		}

		public static Vector3 Swizzle0Z0(this Vector3 original)
		{
			return new Vector3(0f, original.z, 0f);
		}

		public static Vector3 Swizzle0ZX(this Vector3 original)
		{
			return new Vector3(0f, original.z, original.x);
		}

		public static Vector3 Swizzle0ZY(this Vector3 original)
		{
			return new Vector3(0f, original.z, original.y);
		}

		public static Vector3 Swizzle0ZZ(this Vector3 original)
		{
			return new Vector3(0f, original.z, original.z);
		}

		public static Vector3 SwizzleX00(this Vector3 original)
		{
			return new Vector3(original.x, 0f, 0f);
		}

		public static Vector3 SwizzleX0X(this Vector3 original)
		{
			return new Vector3(original.x, 0f, original.x);
		}

		public static Vector3 SwizzleX0Y(this Vector3 original)
		{
			return new Vector3(original.x, 0f, original.y);
		}

		public static Vector3 SwizzleX0Z(this Vector3 original)
		{
			return new Vector3(original.x, 0f, original.z);
		}

		public static Vector3 SwizzleXX0(this Vector3 original)
		{
			return new Vector3(original.x, original.x, 0f);
		}

		public static Vector3 SwizzleXXX(this Vector3 original)
		{
			return new Vector3(original.x, original.x, original.x);
		}

		public static Vector3 SwizzleXXY(this Vector3 original)
		{
			return new Vector3(original.x, original.x, original.y);
		}

		public static Vector3 SwizzleXXZ(this Vector3 original)
		{
			return new Vector3(original.x, original.x, original.z);
		}

		public static Vector3 SwizzleXY0(this Vector3 original)
		{
			return new Vector3(original.x, original.y, 0f);
		}

		public static Vector3 SwizzleXYX(this Vector3 original)
		{
			return new Vector3(original.x, original.y, original.x);
		}

		public static Vector3 SwizzleXYY(this Vector3 original)
		{
			return new Vector3(original.x, original.y, original.y);
		}

		public static Vector3 SwizzleXYZ(this Vector3 original)
		{
			return new Vector3(original.x, original.y, original.z);
		}

		public static Vector3 SwizzleXZ0(this Vector3 original)
		{
			return new Vector3(original.x, original.z, 0f);
		}

		public static Vector3 SwizzleXZX(this Vector3 original)
		{
			return new Vector3(original.x, original.z, original.x);
		}

		public static Vector3 SwizzleXZY(this Vector3 original)
		{
			return new Vector3(original.x, original.z, original.y);
		}

		public static Vector3 SwizzleXZZ(this Vector3 original)
		{
			return new Vector3(original.x, original.z, original.z);
		}

		public static Vector3 SwizzleY00(this Vector3 original)
		{
			return new Vector3(original.y, 0f, 0f);
		}

		public static Vector3 SwizzleY0X(this Vector3 original)
		{
			return new Vector3(original.y, 0f, original.x);
		}

		public static Vector3 SwizzleY0Y(this Vector3 original)
		{
			return new Vector3(original.y, 0f, original.y);
		}

		public static Vector3 SwizzleY0Z(this Vector3 original)
		{
			return new Vector3(original.y, 0f, original.z);
		}

		public static Vector3 SwizzleYX0(this Vector3 original)
		{
			return new Vector3(original.y, original.x, 0f);
		}

		public static Vector3 SwizzleYXX(this Vector3 original)
		{
			return new Vector3(original.y, original.x, original.x);
		}

		public static Vector3 SwizzleYXY(this Vector3 original)
		{
			return new Vector3(original.y, original.x, original.y);
		}

		public static Vector3 SwizzleYXZ(this Vector3 original)
		{
			return new Vector3(original.y, original.x, original.z);
		}

		public static Vector3 SwizzleYY0(this Vector3 original)
		{
			return new Vector3(original.y, original.y, 0f);
		}

		public static Vector3 SwizzleYYX(this Vector3 original)
		{
			return new Vector3(original.y, original.y, original.x);
		}

		public static Vector3 SwizzleYYY(this Vector3 original)
		{
			return new Vector3(original.y, original.y, original.y);
		}

		public static Vector3 SwizzleYYZ(this Vector3 original)
		{
			return new Vector3(original.y, original.y, original.z);
		}

		public static Vector3 SwizzleYZ0(this Vector3 original)
		{
			return new Vector3(original.y, original.z, 0f);
		}

		public static Vector3 SwizzleYZX(this Vector3 original)
		{
			return new Vector3(original.y, original.z, original.x);
		}

		public static Vector3 SwizzleYZY(this Vector3 original)
		{
			return new Vector3(original.y, original.z, original.y);
		}

		public static Vector3 SwizzleYZZ(this Vector3 original)
		{
			return new Vector3(original.y, original.z, original.z);
		}

		public static Vector3 SwizzleZ00(this Vector3 original)
		{
			return new Vector3(original.z, 0f, 0f);
		}

		public static Vector3 SwizzleZ0X(this Vector3 original)
		{
			return new Vector3(original.z, 0f, original.x);
		}

		public static Vector3 SwizzleZ0Y(this Vector3 original)
		{
			return new Vector3(original.z, 0f, original.y);
		}

		public static Vector3 SwizzleZ0Z(this Vector3 original)
		{
			return new Vector3(original.z, 0f, original.z);
		}

		public static Vector3 SwizzleZX0(this Vector3 original)
		{
			return new Vector3(original.z, original.x, 0f);
		}

		public static Vector3 SwizzleZXX(this Vector3 original)
		{
			return new Vector3(original.z, original.x, original.x);
		}

		public static Vector3 SwizzleZXY(this Vector3 original)
		{
			return new Vector3(original.z, original.x, original.y);
		}

		public static Vector3 SwizzleZXZ(this Vector3 original)
		{
			return new Vector3(original.z, original.x, original.z);
		}

		public static Vector3 SwizzleZY0(this Vector3 original)
		{
			return new Vector3(original.z, original.y, 0f);
		}

		public static Vector3 SwizzleZYX(this Vector3 original)
		{
			return new Vector3(original.z, original.y, original.x);
		}

		public static Vector3 SwizzleZYY(this Vector3 original)
		{
			return new Vector3(original.z, original.y, original.y);
		}

		public static Vector3 SwizzleZYZ(this Vector3 original)
		{
			return new Vector3(original.z, original.y, original.z);
		}

		public static Vector3 SwizzleZZ0(this Vector3 original)
		{
			return new Vector3(original.z, original.z, 0f);
		}

		public static Vector3 SwizzleZZX(this Vector3 original)
		{
			return new Vector3(original.z, original.z, original.x);
		}

		public static Vector3 SwizzleZZY(this Vector3 original)
		{
			return new Vector3(original.z, original.z, original.y);
		}

		public static Vector3 SwizzleZZZ(this Vector3 original)
		{
			return new Vector3(original.z, original.z, original.z);
		}

		public static Vector2 Swizzle00(this Vector2 original)
		{
			return new Vector2(0f, 0f);
		}

		public static Vector2 Swizzle0X(this Vector2 original)
		{
			return new Vector2(0f, original.x);
		}

		public static Vector2 Swizzle0Y(this Vector2 original)
		{
			return new Vector2(0f, original.y);
		}

		public static Vector2 SwizzleX0(this Vector2 original)
		{
			return new Vector2(original.x, 0f);
		}

		public static Vector2 SwizzleXX(this Vector2 original)
		{
			return new Vector2(original.x, original.x);
		}

		public static Vector2 SwizzleXY(this Vector2 original)
		{
			return new Vector2(original.x, original.y);
		}

		public static Vector2 SwizzleY0(this Vector2 original)
		{
			return new Vector2(original.y, 0f);
		}

		public static Vector2 SwizzleYX(this Vector2 original)
		{
			return new Vector2(original.y, original.x);
		}

		public static Vector2 SwizzleYY(this Vector2 original)
		{
			return new Vector2(original.y, original.y);
		}

		public static Vector3 Swizzle000(this Vector2 original)
		{
			return new Vector3(0f, 0f, 0f);
		}

		public static Vector3 Swizzle00X(this Vector2 original)
		{
			return new Vector3(0f, 0f, original.x);
		}

		public static Vector3 Swizzle00Y(this Vector2 original)
		{
			return new Vector3(0f, 0f, original.y);
		}

		public static Vector3 Swizzle0X0(this Vector2 original)
		{
			return new Vector3(0f, original.x, 0f);
		}

		public static Vector3 Swizzle0XX(this Vector2 original)
		{
			return new Vector3(0f, original.x, original.x);
		}

		public static Vector3 Swizzle0XY(this Vector2 original)
		{
			return new Vector3(0f, original.x, original.y);
		}

		public static Vector3 Swizzle0Y0(this Vector2 original)
		{
			return new Vector3(0f, original.y, 0f);
		}

		public static Vector3 Swizzle0YX(this Vector2 original)
		{
			return new Vector3(0f, original.y, original.x);
		}

		public static Vector3 Swizzle0YY(this Vector2 original)
		{
			return new Vector3(0f, original.y, original.y);
		}

		public static Vector3 SwizzleX00(this Vector2 original)
		{
			return new Vector3(original.x, 0f, 0f);
		}

		public static Vector3 SwizzleX0X(this Vector2 original)
		{
			return new Vector3(original.x, 0f, original.x);
		}

		public static Vector3 SwizzleX0Y(this Vector2 original)
		{
			return new Vector3(original.x, 0f, original.y);
		}

		public static Vector3 SwizzleXX0(this Vector2 original)
		{
			return new Vector3(original.x, original.x, 0f);
		}

		public static Vector3 SwizzleXXX(this Vector2 original)
		{
			return new Vector3(original.x, original.x, original.x);
		}

		public static Vector3 SwizzleXXY(this Vector2 original)
		{
			return new Vector3(original.x, original.x, original.y);
		}

		public static Vector3 SwizzleXY0(this Vector2 original)
		{
			return new Vector3(original.x, original.y, 0f);
		}

		public static Vector3 SwizzleXYX(this Vector2 original)
		{
			return new Vector3(original.x, original.y, original.x);
		}

		public static Vector3 SwizzleXYY(this Vector2 original)
		{
			return new Vector3(original.x, original.y, original.y);
		}

		public static Vector3 SwizzleY00(this Vector2 original)
		{
			return new Vector3(original.y, 0f, 0f);
		}

		public static Vector3 SwizzleY0X(this Vector2 original)
		{
			return new Vector3(original.y, 0f, original.x);
		}

		public static Vector3 SwizzleY0Y(this Vector2 original)
		{
			return new Vector3(original.y, 0f, original.y);
		}

		public static Vector3 SwizzleYX0(this Vector2 original)
		{
			return new Vector3(original.y, original.x, 0f);
		}

		public static Vector3 SwizzleYXX(this Vector2 original)
		{
			return new Vector3(original.y, original.x, original.x);
		}

		public static Vector3 SwizzleYXY(this Vector2 original)
		{
			return new Vector3(original.y, original.x, original.y);
		}

		public static Vector3 SwizzleYY0(this Vector2 original)
		{
			return new Vector3(original.y, original.y, 0f);
		}

		public static Vector3 SwizzleYYX(this Vector2 original)
		{
			return new Vector3(original.y, original.y, original.x);
		}

		public static Vector3 SwizzleYYY(this Vector2 original)
		{
			return new Vector3(original.y, original.y, original.y);
		}
	}
}
namespace RGCommon
{
	public class MeasurePoint : MonoBehaviour
	{
		private static int nextNumber;

		private int number;
	}
	public class DummyEvent : Tracking.TrackingEvent
	{
		public static DummyEvent instance = new DummyEvent();

		public Tracking.TrackingEvent AddParameter(string name, float value)
		{
			return this;
		}

		public Tracking.TrackingEvent AddParameter(string name, bool value)
		{
			return this;
		}

		public Tracking.TrackingEvent AddParameter(string name, double value)
		{
			return this;
		}

		public Tracking.TrackingEvent AddParameter(string name, int value)
		{
			return this;
		}

		public Tracking.TrackingEvent AddParameter(string name, string value)
		{
			return this;
		}

		public void Submit()
		{
		}

		public override string ToString()
		{
			return "DummyEvent";
		}
	}
	public class ErrorCheckingTracker : Tracking.Tracker
	{
		public class Failure : ApplicationException
		{
			public Failure(string message)
				: base(message)
			{
			}
		}

		private class ErrorCheckingEvent : Tracking.TrackingEvent
		{
			public readonly string eventName;

			private Dictionary<string, string> parameters = new Dictionary<string, string>();

			private bool revenueSet;

			public bool isSubmitted;

			public ErrorCheckingEvent(string eventName)
			{
				this.eventName = eventName;
			}

			public Tracking.TrackingEvent AddParameter(string name, string value)
			{
				if (isSubmitted)
				{
					throw new Failure("Event \"" + eventName + "\" already submitted");
				}
				if (parameters.TryGetValue(name, out var value2))
				{
					throw new Failure("Parameter \"" + name + "\" set multiple times with values \"" + value2 + "\" and \"" + value + "\"");
				}
				parameters[name] = value;
				return this;
			}

			public Tracking.TrackingEvent AddParameter(string name, float value)
			{
				AddParameter(name, value.ToString());
				return this;
			}

			public Tracking.TrackingEvent AddParameter(string name, double value)
			{
				AddParameter(name, value.ToString());
				return this;
			}

			public Tracking.TrackingEvent AddParameter(string name, int value)
			{
				AddParameter(name, value.ToString());
				return this;
			}

			public Tracking.TrackingEvent AddParameter(string name, bool value)
			{
				AddParameter(name, value.ToString());
				return this;
			}

			public void Submit()
			{
				if (isSubmitted)
				{
					throw new Failure("Event \"" + eventName + "\" submitted more than once");
				}
				isSubmitted = true;
			}

			public override string ToString()
			{
				return "ErrorCheckingTracker event " + eventName;
			}
		}

		private ErrorCheckingEvent currentEvent;

		public Tracking.TrackingEvent Track(string eventName)
		{
			if (currentEvent != null && !currentEvent.isSubmitted)
			{
				throw new Failure("Starting new event \"" + eventName + "\" before submitting previous event \"" + currentEvent.eventName + "\" - did you forget to call Submit?");
			}
			currentEvent = new ErrorCheckingEvent(eventName);
			return currentEvent;
		}
	}
	public class FirebaseTracking : MonoBehaviour, Tracking.Tracker
	{
		Tracking.TrackingEvent Tracking.Tracker.Track(string eventName)
		{
			throw new Exception("Trying to use Firebase without USE_FIREBASE defined!");
		}
	}
	public class HTTPTracking : MonoBehaviour, Tracking.Tracker, Tracking.TrackingEvent
	{
		private struct Timing
		{
			public float time;

			public float variation;
		}

		private const float highFrequencyTime = 300f;

		private readonly Timing highFrequencyTimeBetweenSends = new Timing
		{
			time = 30f,
			variation = 0f
		};

		private readonly Timing standardTimeBetweenSends = new Timing
		{
			time = 1200f,
			variation = 600f
		};

		private const string serverUrl = "https://e.resgam.com/";

		private static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);

		private static string baseUrl;

		private StringBuilder eventLog = new StringBuilder();

		private bool eventOngoing;

		private bool quitting;

		private bool stopped;

		private static readonly string NEXT_BATCH_NUMBER_KEY = "tracking_batch_number";

		private static readonly string FIRST_UNSENT_BATCH_KEY = "tracking_unsent";

		private static readonly string BATCH_KEY_PREFIX = "events_";

		private int currentBatchNumber;

		private int firstUnsentBatch;

		private bool lastSendFailed;

		private int lastResponseCode;

		private int consecutiveSendFailures;

		public Tracking.TrackingEvent AddParameter(string name, string value)
		{
			eventLog.Append(' ');
			eventLog.Append(Encode(name));
			eventLog.Append('=');
			eventLog.Append(Encode(value));
			return this;
		}

		public Tracking.TrackingEvent AddParameter(string name, float value)
		{
			eventLog.Append(" f.");
			eventLog.Append(Encode(name));
			eventLog.Append('=');
			eventLog.Append(value.ToString(CultureInfo.InvariantCulture));
			return this;
		}

		public Tracking.TrackingEvent AddParameter(string name, bool value)
		{
			eventLog.Append(" b.");
			eventLog.Append(Encode(name));
			eventLog.Append('=');
			eventLog.Append((!value) ? '0' : '1');
			return this;
		}

		public Tracking.TrackingEvent AddParameter(string name, double value)
		{
			eventLog.Append(" d.");
			eventLog.Append(Encode(name));
			eventLog.Append('=');
			eventLog.Append(value.ToString(CultureInfo.InvariantCulture));
			return this;
		}

		public Tracking.TrackingEvent AddParameter(string name, int value)
		{
			eventLog.Append(" i.");
			eventLog.Append(Encode(name));
			eventLog.Append('=');
			eventLog.Append(value.ToString(CultureInfo.InvariantCulture));
			return this;
		}

		public void Submit()
		{
			eventOngoing = false;
			eventLog.Append('\n');
		}

		public Tracking.TrackingEvent Track(string eventName)
		{
			eventOngoing = true;
			eventLog.Append("E ");
			double timestamp = GetTimestamp();
			eventLog.Append(timestamp.ToString(CultureInfo.InvariantCulture));
			eventLog.Append(' ');
			eventLog.Append(Encode(eventName));
			return this;
		}

		public void Awake()
		{
			currentBatchNumber = PlayerPrefs.GetInt(NEXT_BATCH_NUMBER_KEY, 0);
			firstUnsentBatch = PlayerPrefs.GetInt(FIRST_UNSENT_BATCH_KEY, 0);
			Tracking.RegisterTracker(this);
			UnityEngine.Application.wantsToQuit += OnWantsToQuit;
		}

		private bool OnWantsToQuit()
		{
			UnityEngine.Application.wantsToQuit -= OnWantsToQuit;
			StartCoroutine(Quit());
			return false;
		}

		private void OnApplicationPause(bool pause)
		{
			if (pause)
			{
				EndBatch();
			}
		}

		private void OnDestroy()
		{
			if (eventLog.Length != 0)
			{
				EndBatch();
			}
		}

		private IEnumerator Quit()
		{
			UnityEngine.Debug.Log("Quit starting");
			quitting = true;
			do
			{
				yield return null;
			}
			while (!stopped);
			UnityEngine.Debug.Log("Tracking stopped - now quitting for real");
			UnityEngine.Application.Quit();
		}

		private IEnumerator Start()
		{
			do
			{
				float now2 = Time.unscaledTime;
				Timing timing = ((!(now2 < 300f)) ? standardTimeBetweenSends : highFrequencyTimeBetweenSends);
				float timeToNextSend = UnityEngine.Random.Range(timing.time - timing.variation, timing.time + timing.variation);
				float nextSendTime = Time.unscaledTime + timeToNextSend;
				do
				{
					yield return null;
					now2 = Time.unscaledTime;
				}
				while (now2 < nextSendTime && !quitting);
				yield return SendPending();
			}
			while (!quitting);
			stopped = true;
		}

		private IEnumerator SendPending()
		{
			if (eventLog.Length != 0 && !eventOngoing)
			{
				EndBatch();
			}
			if (firstUnsentBatch >= currentBatchNumber)
			{
				yield break;
			}
			do
			{
				string prefsKey = BATCH_KEY_PREFIX + firstUnsentBatch;
				string eventsData = PlayerPrefs.GetString(prefsKey, "X");
				if (eventsData == "X")
				{
					Tracking.Track("tracking_warn_batch_missing").AddParameter("batch", firstUnsentBatch).Submit();
				}
				else if (eventsData == string.Empty)
				{
					Tracking.Track("tracking_warn_batch_empty").AddParameter("batch", firstUnsentBatch).Submit();
				}
				else
				{
					lastSendFailed = false;
					yield return SendBatch(firstUnsentBatch, eventsData);
					if (lastSendFailed)
					{
						break;
					}
				}
				PlayerPrefs.DeleteKey(prefsKey);
				firstUnsentBatch++;
				PlayerPrefs.SetInt(FIRST_UNSENT_BATCH_KEY, firstUnsentBatch);
			}
			while (firstUnsentBatch < currentBatchNumber);
			PlayerPrefs.Save();
		}

		private void EndBatch()
		{
			if (eventOngoing)
			{
				UnityEngine.Debug.LogWarningFormat("Warning: EndBatch called with ongoing event: {0}", eventLog.ToString());
			}
			else if (eventLog.Length != 0)
			{
				PlayerPrefs.SetString(BATCH_KEY_PREFIX + currentBatchNumber, eventLog.ToString());
				currentBatchNumber++;
				PlayerPrefs.SetInt(NEXT_BATCH_NUMBER_KEY, currentBatchNumber);
				PlayerPrefs.Save();
				eventLog.Length = 0;
			}
		}

		private IEnumerator SendBatch(int batchNumber, string eventsData)
		{
			if (baseUrl == null)
			{
				baseUrl = "https://e.resgam.com/" + Tracking.GetProduct() + "/" + Tracking.GetVersion() + "/" + Tracking.GetUserId() + "/";
			}
			string url = baseUrl + batchNumber;
			byte[] payload = Encoding.UTF8.GetBytes(eventsData);
			using UnityWebRequest request = UnityWebRequest.Put(url, payload);
			yield return request.SendWebRequest();
			if (request.responseCode == 200)
			{
				lastSendFailed = false;
				if (consecutiveSendFailures != 0)
				{
					Tracking.Track("tracking_requests_reconnected").AddParameter("fail_count", consecutiveSendFailures).AddParameter("response_code", lastResponseCode)
						.AddParameter("batch", batchNumber)
						.Submit();
				}
				consecutiveSendFailures = 0;
				yield break;
			}
			lastSendFailed = true;
			lastResponseCode = (int)request.responseCode;
			UnityEngine.Debug.LogFormat("Sending events failed with code {0}", request.responseCode);
			if (consecutiveSendFailures == 0)
			{
				Tracking.Track("tracking_request_failed").AddParameter("response_code", (int)request.responseCode).AddParameter("batch", batchNumber)
					.Submit();
			}
			consecutiveSendFailures++;
		}

		private static string Encode(string v)
		{
			if (v == null)
			{
				return string.Empty;
			}
			return v.Replace("\\", "\\\\").Replace("\n", "\\n").Replace(" ", "\\ ");
		}

		private static double GetTimestamp()
		{
			return (DateTime.UtcNow - epoch).TotalSeconds;
		}
	}
	public class LifecycleTracking : MonoBehaviour
	{
		public string platform;

		private static string PRODUCT_VERSION_KEY = "product_version";

		private bool hasSentStopEvent;

		private bool? lastKnownPause;

		private void Awake()
		{
			UnityEngine.Object.DontDestroyOnLoad(this);
		}

		private void Start()
		{
			string version = VersionInformation.Version;
			string @string = PlayerPrefs.GetString(PRODUCT_VERSION_KEY, string.Empty);
			if (@string == string.Empty)
			{
				AddCommonParameters(Tracking.Track("core_app_install").AddParameter("version", version)).Submit();
			}
			else if (version != @string)
			{
				AddCommonParameters(Tracking.Track("core_app_update").AddParameter("previous", @string).AddParameter("version", version)).Submit();
			}
			PlayerPrefs.SetString(PRODUCT_VERSION_KEY, version);
			PlayerPrefs.Save();
			AddCommonParameters(Tracking.Track("core_app_start")).Submit();
		}

		private void OnApplicationPause(bool pause)
		{
			if (pause)
			{
				Tracking.Track("core_app_pause").Submit();
			}
			else if (lastKnownPause.HasValue)
			{
				Tracking.Track("core_app_unpause").Submit();
			}
			lastKnownPause = pause;
		}

		private void OnApplicationQuit()
		{
			if (!hasSentStopEvent)
			{
				Tracking.Track("core_app_stop").Submit();
				hasSentStopEvent = true;
			}
		}

		private Tracking.TrackingEvent AddCommonParameters(Tracking.TrackingEvent ev)
		{
			string text = UnityEngine.Application.platform.ToString();
			return ev.AddParameter("device_model", SystemInfo.deviceModel).AddParameter("platform", (platform == null) ? text : platform).AddParameter("runtime", text);
		}
	}
	internal class MultiTracker : Tracking.Tracker
	{
		private class MultiEvent : Tracking.TrackingEvent
		{
			private Tracking.TrackingEvent[] events;

			public MultiEvent(Tracking.TrackingEvent[] events)
			{
				this.events = events;
			}

			public Tracking.TrackingEvent AddParameter(string name, int value)
			{
				int i = 0;
				for (int num = events.Length; i < num; i++)
				{
					events[i].AddParameter(name, value);
				}
				return this;
			}

			public Tracking.TrackingEvent AddParameter(string name, double value)
			{
				int i = 0;
				for (int num = events.Length; i < num; i++)
				{
					events[i].AddParameter(name, value);
				}
				return this;
			}

			public Tracking.TrackingEvent AddParameter(string name, bool value)
			{
				int i = 0;
				for (int num = events.Length; i < num; i++)
				{
					events[i].AddParameter(name, value);
				}
				return this;
			}

			public Tracking.TrackingEvent AddParameter(string name, float value)
			{
				int i = 0;
				for (int num = events.Length; i < num; i++)
				{
					events[i].AddParameter(name, value);
				}
				return this;
			}

			public Tracking.TrackingEvent AddParameter(string name, string value)
			{
				int i = 0;
				for (int num = events.Length; i < num; i++)
				{
					events[i].AddParameter(name, value);
				}
				return this;
			}

			public void Submit()
			{
				int i = 0;
				for (int num = events.Length; i < num; i++)
				{
					try
					{
						events[i].Submit();
					}
					catch (Exception ex)
					{
						UnityEngine.Debug.LogErrorFormat("Failed to submit event \"{0}\": {1}", events[i], ex);
					}
				}
			}
		}

		public List<Tracking.Tracker> trackers = new List<Tracking.Tracker>();

		public Tracking.TrackingEvent Track(string eventName)
		{
			int count = trackers.Count;
			Tracking.TrackingEvent[] array = new Tracking.TrackingEvent[count];
			for (int i = 0; i < count; i++)
			{
				try
				{
					array[i] = trackers[i].Track(eventName);
				}
				catch (Exception ex)
				{
					UnityEngine.Debug.LogErrorFormat("Failed to track using \"{0}\": {1}", trackers[i], ex);
					array[i] = new DummyEvent();
				}
			}
			return new MultiEvent(array);
		}
	}
	public static class SimpleTracking
	{
		public struct Settings
		{
			public string productName;

			public string platform;
		}

		private static bool started;

		public static void Start(Settings settings)
		{
			if (started)
			{
				UnityEngine.Debug.Log("SimpleTracking.Start: already started");
				return;
			}
			started = true;
			Tracking.SetProduct(settings.productName);
			GameObject gameObject = new GameObject("Tracking");
			Find.ComponentOrCreate<HTTPTracking>(gameObject);
			LifecycleTracking lifecycleTracking = Find.ComponentOrCreate<LifecycleTracking>(gameObject);
			lifecycleTracking.platform = settings.platform;
			UnityEngine.Object.DontDestroyOnLoad(gameObject);
		}
	}
	public static class Tracking
	{
		public interface TrackingEvent
		{
			TrackingEvent AddParameter(string name, string value);

			TrackingEvent AddParameter(string name, int value);

			TrackingEvent AddParameter(string name, float value);

			TrackingEvent AddParameter(string name, double value);

			TrackingEvent AddParameter(string name, bool value);

			void Submit();
		}

		public interface Tracker
		{
			TrackingEvent Track(string eventName);
		}

		private static string installationId;

		private const string installationIdPrefsKey = "installationId";

		private static string productId;

		private static Tracker tracker;

		public static TrackingEvent Track(string eventName)
		{
			if (tracker == null)
			{
				return DummyEvent.instance;
			}
			return tracker.Track(eventName);
		}

		public static void RegisterTracker(Tracker newTracker)
		{
			if (tracker == null)
			{
				tracker = newTracker;
				return;
			}
			MultiTracker multiTracker = tracker as MultiTracker;
			if (multiTracker == null)
			{
				multiTracker = new MultiTracker();
				multiTracker.trackers.Add(tracker);
				tracker = multiTracker;
			}
			multiTracker.trackers.Add(newTracker);
		}

		public static void SetProduct(string product)
		{
			productId = product;
		}

		public static string GetProduct()
		{
			if (productId == null)
			{
				throw new ApplicationException("Product ID not set");
			}
			return productId;
		}

		public static string GetVersion()
		{
			return VersionInformation.Version;
		}

		public static string GetUserId()
		{
			if (installationId == null)
			{
				if (PlayerPrefs.HasKey("installationId"))
				{
					installationId = PlayerPrefs.GetString("installationId");
				}
				else
				{
					installationId = Guid.NewGuid().ToString();
					PlayerPrefs.SetString("installationId", installationId);
					PlayerPrefs.Save();
				}
			}
			return installationId;
		}
	}
	public static class TrackingNames
	{
		public const string eventAddPaymentInfo = "add_payment_info";

		public const string eventAddToCart = "add_to_cart";

		public const string eventAddToWishlist = "add_to_wishlist";

		public const string eventAppOpen = "app_open";

		public const string eventBeginCheckout = "begin_checkout";

		public const string eventCampaignDetails = "campaign_details";

		public const string eventCheckoutProgress = "checkout_progress";

		public const string eventEarnVirtualCurrency = "earn_virtual_currency";

		public const string eventEcommercePurchase = "ecommerce_purchase";

		public const string eventGenerateLead = "generate_lead";

		public const string eventJoinGroup = "join_group";

		public const string eventLevelUp = "level_up";

		public const string eventLogin = "login";

		public const string eventPostScore = "post_score";

		public const string eventPresentOffer = "present_offer";

		public const string eventPurchaseRefund = "purchase_refund";

		public const string eventRemoveFromCart = "remove_from_cart";

		public const string eventSearch = "search";

		public const string eventSelectContent = "select_content";

		public const string eventSetCheckoutOption = "set_checkout_option";

		public const string eventShare = "share";

		public const string eventSignUp = "sign_up";

		public const string eventSpendVirtualCurrency = "spend_virtual_currency";

		public const string eventTutorialBegin = "tutorial_begin";

		public const string eventTutorialComplete = "tutorial_complete";

		public const string eventUnlockAchievement = "unlock_achievement";

		public const string eventViewItem = "view_item";

		public const string eventViewItemList = "view_item_list";

		public const string eventViewSearchResults = "view_search_results";

		public const string parameterAchievementId = "achievement_id";

		public const string parameterAdNetworkClickID = "aclid";

		public const string parameterAffiliation = "affiliation";

		public const string parameterCampaign = "campaign";

		public const string parameterCharacter = "character";

		public const string parameterCheckoutOption = "checkout_option";

		public const string parameterCheckoutStep = "checkout_step";

		public const string parameterContent = "content";

		public const string parameterContentType = "content_type";

		public const string parameterCoupon = "coupon";

		public const string parameterCP1 = "cp1";

		public const string parameterCreativeName = "creative_name";

		public const string parameterCreativeSlot = "creative_slot";

		public const string parameterCurrency = "currency";

		public const string parameterDestination = "destination";

		public const string parameterEndDate = "end_date";

		public const string parameterFlightNumber = "flight_number";

		public const string parameterGroupId = "group_id";

		public const string parameterItemBrand = "item_brand";

		public const string parameterItemCategory = "item_category";

		public const string parameterItemId = "item_id";

		public const string parameterItemList = "item_list";

		public const string parameterItemLocationId = "item_location_id";

		public const string parameterItemName = "item_name";

		public const string parameterItemVariant = "item_variant";

		public const string parameterLevel = "level";

		public const string parameterLocation = "location";

		public const string parameterMedium = "medium";

		public const string parameterNumberOfNights = "number_of_nights";

		public const string parameterNumberOfPassengers = "number_of_passengers";

		public const string parameterNumberOfRooms = "number_of_rooms";

		public const string parameterOrigin = "origin";

		public const string parameterPrice = "price";

		public const string parameterQuantity = "quantity";

		public const string parameterScore = "score";

		public const string parameterSearchTerm = "search_term";

		public const string parameterShipping = "shipping";

		public const string parameterSignUpMethod = "sign_up_method";

		public const string parameterSource = "source";

		public const string parameterStartDate = "start_date";

		public const string parameterTax = "tax";

		public const string parameterTerm = "term";

		public const string parameterTransactionId = "transaction_id";

		public const string parameterTravelClass = "travel_class";

		public const string parameterValue = "value";

		public const string parameterVirtualCurrencyName = "virtual_currency_name";

		public const string userPropertySignUpMethod = "sign_up_method";
	}
	public class FollowPose : MonoBehaviour
	{
		[Tooltip("The object to follow if not main camera")]
		public Transform objectToFollow;

		[Tooltip("How long it takes for the object to settle at the target object's position")]
		[SerializeField]
		private float movementSmoothTime = 0.2f;

		[Tooltip("How long it takes for the object to settle at the target object's rotation")]
		[SerializeField]
		private float rotationSmoothTime = 0.2f;

		[Tooltip("Offset from target object's global position")]
		[SerializeField]
		private Vector3 globalPositionOffset = Vector3.zero;

		[Tooltip("Offset from target object's local position")]
		[SerializeField]
		private Vector3 localPositionOffset = Vector3.zero;

		[Tooltip("Offset from target object's local position")]
		[SerializeField]
		private Vector3 rotationOffset = Vector3.zero;

		[Tooltip("Make sure the horizon stays straight")]
		[SerializeField]
		private bool keepHorizontal;

		private new Transform transform;

		private Vector3 movementVelocity;

		private Quaternion rotationVelocity;

		private void Awake()
		{
			transform = base.transform;
		}

		private void Update()
		{
			Transform transform = objectToFollow;
			if (transform == null)
			{
				if (!(Camera.main != null))
				{
					return;
				}
				transform = Camera.main.transform;
			}
			Vector3 target = transform.position + globalPositionOffset + transform.TransformDirection(localPositionOffset);
			Quaternion target2 = ((!keepHorizontal) ? transform.rotation : Quaternion.LookRotation(transform.rotation * Vector3.forward));
			target2 *= Quaternion.Euler(rotationOffset);
			this.transform.position = Vector3.SmoothDamp(this.transform.position, target, ref movementVelocity, movementSmoothTime);
			this.transform.rotation = SmoothDamp(this.transform.rotation, target2, ref rotationVelocity, rotationSmoothTime);
		}

		private static Quaternion SmoothDamp(Quaternion rot, Quaternion target, ref Quaternion deriv, float time)
		{
			float num = Quaternion.Dot(rot, target);
			float num2 = ((!(num > 0f)) ? (-1f) : 1f);
			target.x *= num2;
			target.y *= num2;
			target.z *= num2;
			target.w *= num2;
			Vector4 normalized = new Vector4(Mathf.SmoothDamp(rot.x, target.x, ref deriv.x, time), Mathf.SmoothDamp(rot.y, target.y, ref deriv.y, time), Mathf.SmoothDamp(rot.z, target.z, ref deriv.z, time), Mathf.SmoothDamp(rot.w, target.w, ref deriv.w, time)).normalized;
			float num3 = 1f / Time.deltaTime;
			deriv.x = (normalized.x - rot.x) * num3;
			deriv.y = (normalized.y - rot.y) * num3;
			deriv.z = (normalized.z - rot.z) * num3;
			deriv.w = (normalized.w - rot.w) * num3;
			return new Quaternion(normalized.x, normalized.y, normalized.z, normalized.w);
		}
	}
	public class VideoSlate : MonoBehaviour
	{
		public KeyCode visibilityKey = KeyCode.S;

		public KeyCode slateKey = KeyCode.G;

		private GUIStyle guiStyle = new GUIStyle();

		private int framesLeft;

		private Texture2D bgTexture;

		private int slateNumber = 1;

		private bool showSlateNumber;

		private AudioSource audioSource;

		private void Awake()
		{
			bgTexture = new Texture2D(1, 1);
			bgTexture.SetPixel(0, 0, new Color(255f, 255f, 255f));
			bgTexture.Apply();
			guiStyle.normal.background = bgTexture;
			slateNumber = PlayerPrefs.GetInt("slateNumber", 1);
			audioSource = base.gameObject.AddComponent<AudioSource>();
			audioSource.spatialBlend = 0f;
			audioSource.clip = SynthesizedAudio.GenerateSineBeep(1000f, 1f, 0.25f);
		}

		private void Update()
		{
			if (Input.GetKeyDown(visibilityKey))
			{
				showSlateNumber = !showSlateNumber;
			}
			if (Input.GetKeyDown(slateKey))
			{
				audioSource.Play();
				framesLeft = 150;
			}
			else if (framesLeft > 0 && --framesLeft == 0)
			{
				showSlateNumber = false;
				slateNumber++;
				PlayerPrefs.SetInt("slateNumber", slateNumber);
				PlayerPrefs.Save();
			}
		}

		private void OnGUI()
		{
			bool flag = framesLeft > 0;
			if (flag || showSlateNumber)
			{
				guiStyle.fontSize = 100;
				guiStyle.normal.textColor = new Color(0f, 0f, 0f);
				guiStyle.alignment = TextAnchor.MiddleCenter;
				guiStyle.normal.background = bgTexture;
				guiStyle.normal.textColor = Color.black;
				string text = "Slate " + slateNumber;
				Rect position;
				if (flag)
				{
					position = new Rect(0f, (float)Screen.height * 0.25f, Screen.width, (float)Screen.height * 0.5f);
					string text2 = text;
					text = text2 + "\nFrame " + Time.frameCount + "\n" + DateTime.Now.ToString("HH:mm:ss");
				}
				else
				{
					position = new Rect(0f, (float)Screen.height * 0.45f, Screen.width, (float)Screen.height * 0.1f);
				}
				GUI.Label(position, text, guiStyle);
			}
		}
	}
}
public class CubemapRenderer : MonoBehaviour
{
	[SerializeField]
	private int cubemapSize = 2048;

	[SerializeField]
	private bool oneFacePerFrame = true;

	[SerializeField]
	private Camera cubeMapRenderCamera;

	private RenderTexture renderTexture;

	[SerializeField]
	private bool renderBack;

	[SerializeField]
	private bool renderBottom;

	[SerializeField]
	private bool renderTop;

	private int maxFaceMask = 63;

	private Camera mainCamera;

	private int frameCounter;

	private void Start()
	{
		if (!renderBack)
		{
			maxFaceMask -= 32;
		}
		if (!renderBottom)
		{
			maxFaceMask -= 8;
		}
		if (!renderTop)
		{
			maxFaceMask -= 4;
		}
		if (renderTexture == null)
		{
			renderTexture = new RenderTexture(cubemapSize, cubemapSize, 16);
			renderTexture.dimension = TextureDimension.Cube;
			renderTexture.hideFlags = HideFlags.HideAndDontSave;
			GetComponent<Renderer>().sharedMaterial.SetTexture("_ReflectionTex", renderTexture);
			UpdateCubemap(maxFaceMask);
		}
	}

	private void OnDisable()
	{
		UnityEngine.Object.Destroy(renderTexture);
	}

	private void LateUpdate()
	{
		if (oneFacePerFrame)
		{
			frameCounter++;
			if (!renderTop && frameCounter == 2)
			{
				frameCounter++;
			}
			if (!renderBottom && frameCounter == 3)
			{
				frameCounter++;
			}
			if (!renderBack && frameCounter == 5)
			{
				frameCounter++;
			}
			if (frameCounter > 5)
			{
				frameCounter = 0;
			}
			UpdateCubemap(1 << frameCounter);
		}
		else
		{
			UpdateCubemap(maxFaceMask);
		}
	}

	private void UpdateCubemap(int faceMask)
	{
		if (!cubeMapRenderCamera)
		{
			cubeMapRenderCamera.enabled = false;
		}
		if (Camera.main != null)
		{
			if (mainCamera == null)
			{
				mainCamera = Camera.main;
			}
			cubeMapRenderCamera.transform.position = new Vector3(mainCamera.transform.position.x, 0f - mainCamera.transform.position.y, mainCamera.transform.position.z);
		}
		cubeMapRenderCamera.RenderToCubemap(renderTexture, faceMask);
	}
}
public class ReflectionPositionOffset : MonoBehaviour
{
	private Transform cameraTransform;

	public float shiftMultiplier = 1f;

	public float scaleMultiplier = 1f;

	public float shiftOffsetFixed;

	public float scaleOffsetFixed;

	public Material waterMaterial;

	private Vector3 startPosition;

	private void Start()
	{
		cameraTransform = Camera.main.transform;
		startPosition = cameraTransform.position;
	}

	private void Update()
	{
		float value = cameraTransform.position.x * shiftMultiplier + shiftOffsetFixed;
		float value2 = (cameraTransform.position.z - startPosition.z) * scaleMultiplier + scaleOffsetFixed;
		waterMaterial.SetFloat("_ReflectionShiftX", value);
		waterMaterial.SetFloat("_ReflectionShiftScale", value2);
	}
}
public class KeepInFrontOfCamera : MonoBehaviour
{
	public float distanceFromCamera = 0.5f;

	private const float allowedDistanceFromOptimal = 0.15f;

	private void LateUpdate()
	{
		Camera main = Camera.main;
		if (!(main == null))
		{
			Transform transform = main.transform;
			Transform transform2 = base.transform;
			Vector3 vector = transform.position + transform.TransformDirection(Vector3.forward * distanceFromCamera);
			float sqrMagnitude = (vector - transform2.position).sqrMagnitude;
			if (!(sqrMagnitude <= 0.0225f))
			{
				transform2.position = vector;
				Vector3 forward = vector - transform.position;
				transform2.rotation = Quaternion.LookRotation(forward);
			}
		}
	}
}
[RequireComponent(typeof(Text))]
public class TextTemplate : MonoBehaviour
{
	private static Regex replacement = new Regex("\\{\\{(.+?)\\}\\}");

	private Text textComponent;

	private string template;

	[@Dependency]
	public Localization localization { get; set; }

	private void Awake()
	{
		this.Inject();
		textComponent = GetComponent<Text>();
		template = textComponent.text;
		textComponent.fontSize = (int)((float)textComponent.fontSize * localization.GetLanguageFontSizeMultiplier());
	}

	public void SetVariables(IDictionary<string, string> variables, Font font)
	{
		MatchEvaluator evaluator = delegate(Match match)
		{
			string value = match.Groups[1].Value;
			if (variables.TryGetValue(value, out var value2))
			{
				return value2;
			}
			UnityEngine.Debug.LogWarningFormat("Variable {0} not set in {1}", value, this);
			return match.Groups[0].Value;
		};
		textComponent.text = replacement.Replace(template, evaluator);
		textComponent.font = font;
	}
}
public static class BaitTracking
{
	[RuntimeInitializeOnLoadMethod]
	public static void StartTracking()
	{
		Device device = DeviceDetection.GetDevice();
		SimpleTracking.Settings settings = default(SimpleTracking.Settings);
		settings.productName = "bait";
		settings.platform = device.ToString();
		SimpleTracking.Start(settings);
		UnityEngine.Debug.Log("CurrentPlatform = " + device);
	}
}
public class CirclePositioning : MonoBehaviour
{
	public float timeForOneLap = 20f;

	public float radius = 10f;

	public float altitudeSpeed = 0.5f;

	public float amplitude = 1f;

	public Transform centerPosition;

	private void Update()
	{
		float num = timeForOneLap / 2f;
		float num2 = (float)Math.PI / num;
		float num3 = num2 * Time.time;
		float x = Mathf.Cos(num3) * radius + centerPosition.position.x;
		float z = Mathf.Sin(num3) * radius + centerPosition.position.z;
		float y = centerPosition.position.y + Mathf.Cos(Time.time * altitudeSpeed) * amplitude;
		base.transform.position = new Vector3(x, y, z);
		base.transform.rotation = Quaternion.Euler(0f, 180f - 57.29578f * num3, 0f);
	}
}
public class DestroyIfDuplicate : MonoBehaviour
{
	[SerializeField]
	[Tooltip("For keeping track of whether an object already exists. For one key, there will be only one game object")]
	private string uniqueKey = Guid.NewGuid().ToString();

	private static HashSet<string> existingObjects = new HashSet<string>();

	private bool isAllowedInstance;

	private void Awake()
	{
		isAllowedInstance = existingObjects.Add(uniqueKey);
		if (!isAllowedInstance)
		{
			UnityEngine.Debug.LogFormat("Duplicate instance of {0} - destroying it", this);
			UnityEngine.Object.DestroyImmediate(base.gameObject);
		}
	}

	private void OnDestroy()
	{
		if (isAllowedInstance)
		{
			UnityEngine.Debug.LogFormat("Removed the one and only instance of {0}", this);
			bool flag = existingObjects.Remove(uniqueKey);
		}
	}

	public override string ToString()
	{
		return base.ToString() + " with key \"" + uniqueKey + "\"";
	}
}
public class DummyTracking : MonoBehaviour, Tracking.Tracker
{
	private void Awake()
	{
		Tracking.RegisterTracker(this);
	}

	public Tracking.TrackingEvent Track(string eventName)
	{
		return new DummyEvent();
	}
}
public class FlatPolygon : MonoBehaviour
{
	private Triangulator triangulator;

	private Vector2[] points = new Vector2[0];

	private int[] indices = new int[0];

	private float[] areas = new float[0];

	private float totalArea;

	private Rect bounds;

	private void Start()
	{
		UpdatePolygon();
	}

	public bool IsPointInside(Vector3 worldPoint)
	{
		Vector2 point = To2DPoint(worldPoint);
		for (int i = 0; i < indices.Length; i += 3)
		{
			if (TwoD.TriangleContainsPoint(points[indices[i]], points[indices[i + 1]], points[indices[i + 2]], point))
			{
				return true;
			}
		}
		return false;
	}

	public Vector2 GetRandomPoint()
	{
		float num = UnityEngine.Random.Range(0f, totalArea);
		int num2 = 0;
		float num3 = num;
		while (true)
		{
			num3 -= areas[num2];
			if (num3 <= 0f)
			{
				break;
			}
			num2++;
		}
		int num4 = num2 * 3;
		Vector2 p = points[indices[num4]];
		Vector2 p2 = points[indices[num4 + 1]];
		Vector2 p3 = points[indices[num4 + 2]];
		return GetRandomPointInTriangle(p, p2, p3);
	}

	private static Vector2 GetRandomPointInTriangle(Vector2 p0, Vector2 p2, Vector2 p1)
	{
		Vector2 vector = p1 - p0;
		Vector2 vector2 = p2 - p0;
		float value = UnityEngine.Random.value;
		float value2 = UnityEngine.Random.value;
		if (value2 < 1f - value)
		{
			return p0 + value * vector + value2 * vector2;
		}
		return p0 + (1f - value) * vector + (1f - value2) * vector2;
	}

	private void OnDrawGizmos()
	{
		UpdatePolygon();
		Gizmos.color = Color.white;
		for (int i = 0; i < indices.Length; i += 3)
		{
			Vector2 p = points[indices[i]];
			Vector2 p2 = points[indices[i + 1]];
			Vector2 p3 = points[indices[i + 2]];
			Gizmos.DrawLine(ToWorldPoint(p), ToWorldPoint(p2));
			Gizmos.DrawLine(ToWorldPoint(p2), ToWorldPoint(p3));
			Gizmos.DrawLine(ToWorldPoint(p3), ToWorldPoint(p));
		}
	}

	private static Vector3 ToWorldPoint(Vector2 p)
	{
		return new Vector3(p.x, 0f, p.y);
	}

	private static Vector3 To2DPoint(Vector3 worldPoint)
	{
		return new Vector2(worldPoint.x, worldPoint.z);
	}

	private void UpdatePolygon()
	{
		points = new Vector2[base.transform.childCount];
		if (points.Length == 0)
		{
			indices = new int[0];
			bounds = default(Rect);
			return;
		}
		float num = float.PositiveInfinity;
		float num2 = float.NegativeInfinity;
		float num3 = float.PositiveInfinity;
		float num4 = float.NegativeInfinity;
		for (int i = 0; i < points.Length; i++)
		{
			Vector3 position = base.transform.GetChild(i).position;
			Vector3 vector = new Vector2(position.x, position.z);
			ref Vector2 reference = ref points[i];
			reference = vector;
			num = Mathf.Min(num, vector.x);
			num2 = Mathf.Max(num2, vector.x);
			num3 = Mathf.Min(num3, vector.y);
			num4 = Mathf.Max(num4, vector.y);
		}
		triangulator = new Triangulator(points);
		indices = triangulator.Triangulate();
		bounds = Rect.MinMaxRect(num, num3, num2, num4);
		int num5 = indices.Length / 3;
		areas = new float[num5];
		totalArea = 0f;
		for (int j = 0; j < num5; j++)
		{
			Vector2 p = points[indices[j * 3]];
			Vector2 p2 = points[indices[j * 3 + 1]];
			Vector2 p3 = points[indices[j * 3 + 2]];
			float num6 = Mathf.Abs(TwoD.Determinant(p2, p, p3) / 2f);
			areas[j] = num6;
			totalArea += num6;
		}
	}

	private void DebugDrawInside(float showTime = 0f)
	{
		for (float num = bounds.min.x; num <= bounds.max.x; num += 0.1f)
		{
			for (float num2 = bounds.min.y; num2 <= bounds.max.y; num2 += 0.1f)
			{
				if (IsPointInside(new Vector3(num, 0f, num2)))
				{
					UnityEngine.Debug.DrawLine(new Vector3(num, 0f, num2), new Vector3(num + 0.05f, 0f, num2 + 0.05f), Color.white, showTime, depthTest: true);
				}
			}
		}
	}

	private void DebugDrawRandom(int numberOfPoints = 100, float showTime = 0f)
	{
		for (int i = 0; i < numberOfPoints; i++)
		{
			Vector2 randomPoint = GetRandomPoint();
			Vector3 vector = ToWorldPoint(randomPoint);
			UnityEngine.Debug.DrawLine(vector, vector + new Vector3(0.1f, 0.1f, 0f), Color.white, showTime, depthTest: true);
		}
	}
}
[RequireComponent(typeof(Collider))]
public class FluidDynamics : MonoBehaviour
{
	[Tooltip("Y coordinate of water surface")]
	public float waterLevel;

	[Tooltip("Force to apply to objects above water level")]
	public Vector3 wind = Vector3.zero;

	[Tooltip("Force to apply to objects below water level")]
	public Vector3 waterFlow = Vector3.zero;

	public void OnTriggerStay(Collider other)
	{
		GameObject gameObject = other.gameObject;
		Vector3 force = ((!(gameObject.transform.position.y < waterLevel)) ? wind : waterFlow);
		other.attachedRigidbody.AddForce(force);
	}
}
public class FollowHeadPosition : MonoBehaviour
{
	[HideInInspector]
	public Transform headTransform;

	public Vector3 positionOffset = Vector3.zero;

	private Camera mainCamera;

	private void Start()
	{
		StartCoroutine(WaitForCamera());
	}

	private IEnumerator WaitForCamera()
	{
		while (mainCamera == null)
		{
			mainCamera = Camera.main;
			yield return null;
		}
		headTransform = mainCamera.transform.parent;
	}

	private void Update()
	{
		if (headTransform != null)
		{
			base.transform.position = headTransform.position + positionOffset;
		}
	}
}
public class FollowRotation : MonoBehaviour
{
	[Tooltip("The object to get the rotation from")]
	private Transform followObject;

	public Vector3 smoothTime = new Vector3(1f, 1f, 1f);

	public Vector3 maxAngularVelocity = new Vector3(90f, 90f, 90f);

	public Vector3 minRotation = new Vector3(-90f, -180f, -180f);

	public Vector3 maxRotation = new Vector3(90f, 180f, 180f);

	[Tooltip("Make this object rotate this much more than the followed object")]
	public Vector3 ratio = Vector3.one;

	public readonly Signal OutOfBoundsSignal = new Signal();

	public readonly Signal InsideBoundsSignal = new Signal();

	protected Vector3 currentVelocity;

	protected Quaternion myStartRotation;

	private Camera mainCamera;

	[@Dependency]
	public InputModeSwitchEvent GearVRInputSwitchSignal { get; set; }

	[@Dependency]
	public InputManager input { get; set; }

	public bool InsideBounds { get; protected set; }

	protected virtual void Start()
	{
		this.Inject();
		StartCoroutine(Initialzie());
	}

	private IEnumerator Initialzie()
	{
		while (mainCamera == null)
		{
			mainCamera = Camera.main;
			yield return null;
		}
		followObject = mainCamera.transform;
		myStartRotation = base.transform.rotation;
		InsideBounds = true;
		GearVRInputSwitchSignal.AddListener(OnActiveControllerChanged);
		if (input.GetInputMode() != InputMode.Headset)
		{
			base.enabled = false;
		}
	}

	protected virtual void Update()
	{
		if (followObject == null)
		{
			return;
		}
		Vector3 vector = DeltaAngles(Vector3.zero, followObject.transform.rotation.eulerAngles);
		vector.Scale(ratio);
		Vector3 vector2 = default(Vector3);
		vector2.x = Mathf.Clamp(vector.x, minRotation.x, maxRotation.x);
		vector2.y = Mathf.Clamp(vector.y, minRotation.y, maxRotation.y);
		vector2.z = Mathf.Clamp(vector.z, minRotation.z, maxRotation.z);
		Vector3 eulerAngles = base.transform.rotation.eulerAngles;
		Vector3 vector3 = myStartRotation.eulerAngles + vector2;
		Vector3 euler = new Vector3(Mathf.SmoothDampAngle(eulerAngles.x, vector3.x, ref currentVelocity.x, smoothTime.x, maxAngularVelocity.x), Mathf.SmoothDampAngle(eulerAngles.y, vector3.y, ref currentVelocity.y, smoothTime.y, maxAngularVelocity.y), Mathf.SmoothDampAngle(eulerAngles.z, vector3.z, ref currentVelocity.z, smoothTime.z, maxAngularVelocity.z));
		base.transform.rotation = Quaternion.Euler(euler);
		bool flag = vector == vector2;
		if (flag != InsideBounds)
		{
			InsideBounds = flag;
			if (flag)
			{
				InsideBoundsSignal.Dispatch();
			}
			else
			{
				OutOfBoundsSignal.Dispatch();
			}
		}
	}

	protected void OnActiveControllerChanged(InputMode type)
	{
		if (type != InputMode.Headset)
		{
			base.transform.rotation = myStartRotation;
			base.enabled = false;
		}
		else
		{
			base.enabled = true;
		}
	}

	protected static Vector3 DeltaAngles(Vector3 a, Vector3 b)
	{
		return new Vector3(Mathf.DeltaAngle(a.x, b.x), Mathf.DeltaAngle(a.y, b.y), Mathf.DeltaAngle(a.z, b.z));
	}

	private void OnDestroy()
	{
		GearVRInputSwitchSignal.RemoveListener(OnActiveControllerChanged);
	}
}
public class InitializePlatformSpecifics : MonoBehaviour
{
	private void Awake()
	{
		DeviceConfig config = SingletonBehavior<DeviceConfigLoader>.Instance.GetConfig();
		int targetFPS = config.GetTargetFPS();
		float textureResolutionScale = config.GetTextureResolutionScale();
		if (textureResolutionScale > 0f)
		{
			XRSettings.eyeTextureResolutionScale = textureResolutionScale;
		}
		UnityEngine.Application.targetFrameRate = targetFPS;
		Time.fixedDeltaTime = 1f / (float)targetFPS;
		Time.maximumDeltaTime = 1f / (float)targetFPS;
		QualitySettings.vSyncCount = 0;
	}
}
[RequireComponent(typeof(LensFlare))]
public class LensFlareFader : Fader
{
	private LensFlare flare;

	private float startBrightness;

	private void Start()
	{
		flare = GetComponent<LensFlare>();
		startBrightness = flare.brightness;
	}

	private void LateUpdate()
	{
		if (currentAlpha != targetAlpha)
		{
			flare.brightness = (1f - currentAlpha) * startBrightness;
		}
	}
}
public enum FadeState
{
	FadeInStart,
	FadeInEnd,
	FadeOutStart,
	FadeOutEnd
}
public class LoadScene : MonoBehaviour
{
	public static Signal<string> LoadSceneSignal = new Signal<string>();

	public static Signal<string> LoadPreviousSceneSignal = new Signal<string>();

	public static Signal<FadeState> FadeSignal = new Signal<FadeState>();

	private Fader[] faders;

	private static string lastLoadedSceneName = string.Empty;

	private static string currentlyLoadedSceneName = string.Empty;

	private void Awake()
	{
	}

	private void Start()
	{
		this.Inject();
		faders = UnityEngine.Object.FindObjectsOfType<Fader>();
		LoadSceneSignal.AddListener(LoadAScene);
		LoadPreviousSceneSignal.AddListener(OnLoadPrevSceneSignal);
		StartCoroutine(DispatchFadeInEvents());
	}

	private void OnLoadPrevSceneSignal(string fallbackSceneName)
	{
		string text = lastLoadedSceneName;
		if (string.IsNullOrEmpty(text))
		{
			text = fallbackSceneName;
		}
		LoadAScene(text);
	}

	public void LoadAScene(string scene)
	{
		lastLoadedSceneName = currentlyLoadedSceneName;
		currentlyLoadedSceneName = scene;
		Tracking.Track("nav_load_scene").AddParameter("parting_scene", lastLoadedSceneName).AddParameter("entering_scene", currentlyLoadedSceneName)
			.Submit();
		StartCoroutine(FadeOutAllAndLoadLevel(scene));
	}

	private void OnDestroy()
	{
		LoadSceneSignal.RemoveListener(LoadAScene);
		LoadPreviousSceneSignal.RemoveListener(OnLoadPrevSceneSignal);
	}

	private IEnumerator DispatchFadeInEvents()
	{
		FadeSignal.Dispatch(FadeState.FadeInStart);
		yield return WaitForFaders();
		FadeSignal.Dispatch(FadeState.FadeInEnd);
	}

	private IEnumerator FadeOutAllAndLoadLevel(string sceneName)
	{
		FadeSignal.Dispatch(FadeState.FadeOutStart);
		UnityEngine.AsyncOperation loadingScene = SceneManager.LoadSceneAsync(sceneName, LoadSceneMode.Single);
		loadingScene.allowSceneActivation = false;
		for (int i = 0; i < faders.Length; i++)
		{
			faders[i].FadeOut();
		}
		while (loadingScene.progress <= 0.9f && !AllFadersAreDone())
		{
			yield return null;
		}
		loadingScene.allowSceneActivation = true;
		FadeSignal.Dispatch(FadeState.FadeOutEnd);
	}

	private IEnumerator WaitForFaders()
	{
		if (faders.Length > 0)
		{
			do
			{
				yield return null;
			}
			while (!AllFadersAreDone());
		}
	}

	private bool AllFadersAreDone()
	{
		for (int i = 0; i < faders.Length; i++)
		{
			if (!faders[i].Done)
			{
				return false;
			}
		}
		return true;
	}
}
public class LoadSceneDirect : MonoBehaviour
{
	public string SceneName;

	private void Start()
	{
		SceneManager.LoadScene(SceneName, LoadSceneMode.Single);
	}
}
public class LoadSceneInSeconds : MonoBehaviour
{
	public string SceneName;

	public float TimeToWaitBeforeLoad = 3f;

	private Fader[] faders;

	private void Start()
	{
		faders = UnityEngine.Object.FindObjectsOfType<Fader>();
		StartCoroutine(LoadDocks());
	}

	private IEnumerator LoadDocks()
	{
		float elapsedTime = 0f;
		UnityEngine.AsyncOperation loadingScene = SceneManager.LoadSceneAsync(SceneName, LoadSceneMode.Single);
		loadingScene.allowSceneActivation = false;
		while ((double)loadingScene.progress <= 0.9 && elapsedTime < TimeToWaitBeforeLoad)
		{
			elapsedTime += Time.deltaTime;
			yield return null;
		}
		for (int i = 0; i < faders.Length; i++)
		{
			faders[i].FadeOut();
		}
		while (!AllFadersAreDone())
		{
			yield return null;
		}
		loadingScene.allowSceneActivation = true;
	}

	private bool AllFadersAreDone()
	{
		for (int i = 0; i < faders.Length; i++)
		{
			if (!faders[i].Done)
			{
				return false;
			}
		}
		return true;
	}
}
public class PersistentBetweenSceneLoads : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}
}
public class PlatformComponentActivator : MonoBehaviour
{
	[Serializable]
	public struct Entry
	{
		[EnumFlag]
		public Device platform;

		public Behaviour[] behaviours;
	}

	[SerializeField]
	private Entry[] behaviours;

	private void Awake()
	{
		Device device = DeviceDetection.GetDevice();
		int i = 0;
		for (int num = behaviours.Length; i < num; i++)
		{
			bool flag = (behaviours[i].platform & device) > (Device)0;
			int j = 0;
			for (int num2 = behaviours[i].behaviours.Length; j < num2; j++)
			{
				behaviours[i].behaviours[j].enabled = flag;
			}
		}
	}
}
public class PlatformGameObjectSelector : MonoBehaviour
{
	[Serializable]
	public struct Entry
	{
		[EnumFlag]
		public Device platform;

		public GameObject gameObject;
	}

	[SerializeField]
	private Entry[] gameObjects;

	private void Awake()
	{
		Device device = DeviceDetection.GetDevice();
		int i = 0;
		for (int num = gameObjects.Length; i < num; i++)
		{
			bool active = (gameObjects[i].platform & device) > (Device)0;
			gameObjects[i].gameObject.SetActive(active);
		}
	}
}
public class PlatformGameObjectSpawner : MonoBehaviour
{
	[SerializeField]
	private ConfigPrefab prefabTypeToSpawn;

	private void Awake()
	{
		DeviceConfig config = SingletonBehavior<DeviceConfigLoader>.Instance.GetConfig();
		GameObject prefabOfType = config.GetPrefabOfType(prefabTypeToSpawn);
		GameObject gameObject = UnityEngine.Object.Instantiate(prefabOfType, base.transform);
		gameObject.name = prefabOfType.name;
	}
}
public class RGTracking
{
	public void TrackQuestCompleted(QuestState CurrentState, InventoryManager inventoryManager)
	{
		if (CurrentState.StateNumber >= 0)
		{
			Tracking.TrackingEvent trackingEvent = Tracking.Track("play_quest_completed");
			trackingEvent.AddParameter("quest_number", CurrentState.StateNumber);
			trackingEvent.AddParameter("quest_name", CurrentState.Id);
			trackingEvent.AddParameter("balance", inventoryManager.Inventory.Money);
			if (CurrentState.Id == "TalkToDarma09")
			{
				string value = inventoryManager.Inventory.FishRecords.Count.ToString();
				string value2 = FishRegistry.Instance.Fishes.Count.ToString();
				string value3 = inventoryManager.Inventory.GetNumThreeStarFishes().ToString();
				trackingEvent.AddParameter("fish_types_caught", value);
				trackingEvent.AddParameter("fish_types_total", value2);
				trackingEvent.AddParameter("fish_types_caught_three_stars", value3);
			}
			trackingEvent.Submit();
		}
	}

	public void TrackFish(string eventName, Fish fish, Quest quest = null)
	{
		Tracking.TrackingEvent trackingEvent = Tracking.Track($"play_fishing_captured");
		trackingEvent.AddParameter("fish_name", fish.FishData.name.Split('_')[1]);
		if (eventName == "captured")
		{
			trackingEvent.AddParameter("fish_weight", fish.weight);
			trackingEvent.AddParameter("fish_stars", (int)fish.FishData.GetStarRating(fish.weight));
			trackingEvent.AddParameter("value", fish.FishData.worth);
			trackingEvent.AddParameter("location", SceneManager.GetActiveScene().name);
			if (quest != null)
			{
				trackingEvent.AddParameter("quest_number", quest.CurrentState.StateNumber);
				trackingEvent.AddParameter("quest_name", quest.CurrentState.Id);
			}
		}
		trackingEvent.Submit();
	}

	public void TrackCastingEvent(string castState, QuestState currentQuestState, SinkerCasting.TrackingControlScheme castingMode, string failReason = null)
	{
		Tracking.TrackingEvent trackingEvent = Tracking.Track($"play_casting");
		trackingEvent.AddParameter("throw", castState);
		trackingEvent.AddParameter("casting_mode", castingMode.ToString());
		trackingEvent.AddParameter("quest_number", currentQuestState.StateNumber);
		trackingEvent.AddParameter("quest_name", currentQuestState.Id);
		if (!string.IsNullOrEmpty(failReason))
		{
			trackingEvent.AddParameter("fail_reason", failReason);
		}
		trackingEvent.Submit();
	}

	public void TrackPullBobber(string pullState, Fish fish)
	{
		Tracking.TrackingEvent trackingEvent = Tracking.Track("play_pull_bobber");
		trackingEvent.AddParameter("timing", pullState);
		trackingEvent.AddParameter("fish_name", fish.FishData.name);
		trackingEvent.Submit();
	}

	public void TrackReeling(string escapeState, Fish fish)
	{
		Tracking.TrackingEvent trackingEvent = Tracking.Track("play_reeling_fail");
		trackingEvent.AddParameter("cause", escapeState);
		trackingEvent.AddParameter("fish_name", fish.FishData.name);
		trackingEvent.Submit();
	}

	public void TrackStartMenu(string state, int slotID)
	{
		string value = null;
		switch (slotID)
		{
		case 0:
			value = "One";
			break;
		case 1:
			value = "Two";
			break;
		case 2:
			value = "Three";
			break;
		}
		Tracking.TrackingEvent trackingEvent = Tracking.Track("nav_start_menu");
		trackingEvent.AddParameter("action", state);
		trackingEvent.AddParameter("save_slot", value);
		trackingEvent.Submit();
	}

	public void TrackShopEvent(string category, string state, string itemID, int moneyBalance, QuestState quest)
	{
		Tracking.TrackingEvent trackingEvent = Tracking.Track($"nav_shop_{category}");
		trackingEvent.AddParameter("item_id", itemID);
		trackingEvent.AddParameter("balance", moneyBalance);
		trackingEvent.AddParameter("quest_number", quest.StateNumber);
		trackingEvent.AddParameter("quest_name", quest.Id);
		trackingEvent.Submit();
	}

	public void TrackFishoDexEvent(string contentName, string contentID)
	{
		Tracking.TrackingEvent trackingEvent = Tracking.Track($"nav_fishodex");
		if (contentID != null)
		{
			trackingEvent.AddParameter("item_name", contentID);
			trackingEvent.AddParameter("screen_name", contentName);
		}
		trackingEvent.Submit();
	}

	public void TrackIntroEvent(string eventType, int gameTime)
	{
		Tracking.TrackingEvent trackingEvent = Tracking.Track("nav_onboarding");
		trackingEvent.AddParameter("step", eventType);
		trackingEvent.AddParameter("time", gameTime);
		trackingEvent.Submit();
	}

	public void TrackSettingsEvent(string category, string setting, string parameterName = null, string parameterValue = null)
	{
		Tracking.TrackingEvent trackingEvent = Tracking.Track($"nav_settings_{category}_{setting}");
		if (parameterName != null && parameterValue != null)
		{
			trackingEvent.AddParameter(parameterName, parameterValue);
		}
		trackingEvent.Submit();
	}

	public void TrackIAPEvent(string state, string sku, QuestState questState, double price = 0.0, Dictionary<string, string> optionalParameters = null)
	{
		Tracking.TrackingEvent trackingEvent = Tracking.Track($"iap_{state}");
		if (optionalParameters != null)
		{
			foreach (KeyValuePair<string, string> optionalParameter in optionalParameters)
			{
				trackingEvent.AddParameter(optionalParameter.Key, optionalParameter.Value);
			}
		}
		if (!optionalParameters.ContainsKey("product_failed"))
		{
			trackingEvent.AddParameter("item_id", sku);
			trackingEvent.AddParameter("quest_number", questState.StateNumber);
			trackingEvent.AddParameter("quest_name", questState.Id);
			if (price != 0.0)
			{
				trackingEvent.AddParameter("currency", "USD");
				trackingEvent.AddParameter("value", price);
				trackingEvent.AddParameter("price", price);
			}
		}
		trackingEvent.Submit();
	}
}
public class RGTrackingMono : MonoBehaviour
{
	private float timer;

	[@Dependency]
	public GameSession gameSession { get; set; }

	public void Start()
	{
		this.Inject();
	}

	private void Update()
	{
		if (gameSession.CurrentSession != null)
		{
			timer += Time.deltaTime;
			if (timer > 1f)
			{
				gameSession.currentQuestTime++;
				timer = 0f;
			}
		}
	}
}
public class RodPostionController : MonoBehaviour
{
	[@Dependency]
	public InputModeSwitchEvent GearVRInputSwitchSignal { get; set; }

	[@Dependency]
	public InputManager input { get; set; }

	private void Start()
	{
		this.Inject();
		GearVRInputSwitchSignal.AddListener(OnActiveControllerChanged);
		if (input.GetInputMode() == InputMode.Headset)
		{
			base.enabled = false;
		}
	}

	private void Update()
	{
		base.transform.localPosition = input.GetControllerLocalPosition();
	}

	private void OnDestroy()
	{
		GearVRInputSwitchSignal.RemoveListener(OnActiveControllerChanged);
	}

	protected void OnActiveControllerChanged(InputMode type)
	{
		base.enabled = type != InputMode.Headset;
	}
}
[RequireComponent(typeof(RodAssembler))]
public class RodSwapper : MonoBehaviour
{
}
public class SaveLoadPersistant : MonoBehaviour
{
	private const string PERSIST_KEY_HAPTICS_ENABLED = "HapticsMuted";

	public static bool isHapticEnabled { get; private set; }

	private void Start()
	{
		SettingsScreen.HapticsSettingsSignal.AddListener(OnHapticsSignal);
		LoadPersistantSettings();
	}

	private void OnHapticsSignal(HapticsSettingsEventType type)
	{
		switch (type)
		{
		case HapticsSettingsEventType.SavePersistantSettings:
			SavePersistantSettings();
			break;
		case HapticsSettingsEventType.LoadPersistantSettings:
			LoadPersistantSettings();
			break;
		case HapticsSettingsEventType.EnableHaptics:
			isHapticEnabled = false;
			break;
		case HapticsSettingsEventType.DisableHaptics:
			isHapticEnabled = true;
			break;
		}
	}

	private void SavePersistantSettings()
	{
		PlayerPrefs.SetInt("HapticsMuted", isHapticEnabled ? 1 : 0);
	}

	private void LoadPersistantSettings()
	{
		if (PlayerPrefs.HasKey("HapticsMuted"))
		{
			isHapticEnabled = PlayerPrefs.GetInt("HapticsMuted") == 1;
			return;
		}
		isHapticEnabled = true;
		SavePersistantSettings();
	}
}
public class SetSkyboxOnChildCameras : MonoBehaviour
{
	[SerializeField]
	private Material skyboxMaterial;

	private Camera mainCamera;

	private void Start()
	{
		StartCoroutine(WaitForCamera());
	}

	private IEnumerator WaitForCamera()
	{
		while (mainCamera == null)
		{
			mainCamera = Camera.main;
			yield return null;
		}
		Skybox[] skyboxes = GetComponentsInChildren<Skybox>();
		for (int i = 0; i < skyboxes.Length; i++)
		{
			skyboxes[i].material = skyboxMaterial;
		}
	}
}
public class SkyboxRotation : MonoBehaviour
{
	public float rotationSpeed;

	private Material skyMaterial;

	private float originalRotation;

	private int rotationPropertyId;

	private void Start()
	{
		rotationPropertyId = Shader.PropertyToID("_Rotation");
		Skybox component = GetComponent<Skybox>();
		if (component == null)
		{
			UnityEngine.Object.Destroy(this);
			return;
		}
		skyMaterial = component.material;
		originalRotation = skyMaterial.GetFloat(rotationPropertyId);
	}

	private void Update()
	{
		float value = originalRotation + Time.time * rotationSpeed;
		skyMaterial.SetFloat(rotationPropertyId, value);
	}

	private void OnDestroy()
	{
		if (skyMaterial != null)
		{
			skyMaterial.SetFloat(rotationPropertyId, originalRotation);
		}
	}
}
public class ToggleCursorOnFade : MonoBehaviour
{
	private BaseCursor cursor;

	private CrosshairTimer crosshairTimer;

	private void Awake()
	{
		cursor = Find.ComponentOnGameObject<BaseCursor>(this);
		crosshairTimer = Find.ComponentOnGameObject<CrosshairTimer>(this);
		SetEnabled(enable: false);
	}

	private void Start()
	{
		this.Inject();
		LoadScene.FadeSignal.AddListener(OnFadeHappening);
	}

	private void OnFadeHappening(FadeState fadeEvent)
	{
		bool flag;
		switch (fadeEvent)
		{
		default:
			return;
		case FadeState.FadeInStart:
		case FadeState.FadeOutStart:
			flag = false;
			break;
		case FadeState.FadeInEnd:
			flag = true;
			break;
		case FadeState.FadeOutEnd:
			flag = false;
			break;
		}
		SetEnabled(flag);
	}

	private void SetEnabled(bool enable)
	{
		cursor.enabled = enable;
		crosshairTimer.enabled = enable;
	}

	private void OnDestroy()
	{
		LoadScene.FadeSignal.RemoveListener(OnFadeHappening);
	}
}
public class ToggleFPSWithController : MonoBehaviour
{
	[@Dependency]
	public InputManager input { get; set; }

	private void Start()
	{
		this.Inject();
	}
}
public class TrackingSelector : MonoBehaviour
{
	private void Awake()
	{
		BaitTracking.StartTracking();
	}
}
public class Triangulator
{
	private List<Vector2> m_points = new List<Vector2>();

	public Triangulator(Vector2[] points)
	{
		m_points = new List<Vector2>(points);
	}

	public int[] Triangulate()
	{
		List<int> list = new List<int>();
		int count = m_points.Count;
		if (count < 3)
		{
			return list.ToArray();
		}
		int[] array = new int[count];
		if (Area() > 0f)
		{
			for (int i = 0; i < count; i++)
			{
				array[i] = i;
			}
		}
		else
		{
			for (int j = 0; j < count; j++)
			{
				array[j] = count - 1 - j;
			}
		}
		int num = count;
		int num2 = 2 * num;
		int num3 = 0;
		int num4 = num - 1;
		while (num > 2)
		{
			if (num2-- <= 0)
			{
				return list.ToArray();
			}
			int num5 = num4;
			if (num <= num5)
			{
				num5 = 0;
			}
			num4 = num5 + 1;
			if (num <= num4)
			{
				num4 = 0;
			}
			int num6 = num4 + 1;
			if (num <= num6)
			{
				num6 = 0;
			}
			if (Snip(num5, num4, num6, num, array))
			{
				int item = array[num5];
				int item2 = array[num4];
				int item3 = array[num6];
				list.Add(item);
				list.Add(item2);
				list.Add(item3);
				num3++;
				int num7 = num4;
				for (int k = num4 + 1; k < num; k++)
				{
					array[num7] = array[k];
					num7++;
				}
				num--;
				num2 = 2 * num;
			}
		}
		list.Reverse();
		return list.ToArray();
	}

	private float Area()
	{
		int count = m_points.Count;
		float num = 0f;
		int index = count - 1;
		int num2 = 0;
		while (num2 < count)
		{
			Vector2 vector = m_points[index];
			Vector2 vector2 = m_points[num2];
			num += vector.x * vector2.y - vector2.x * vector.y;
			index = num2++;
		}
		return num * 0.5f;
	}

	private bool Snip(int u, int v, int w, int n, int[] V)
	{
		Vector2 a = m_points[V[u]];
		Vector2 b = m_points[V[v]];
		Vector2 c = m_points[V[w]];
		if (Mathf.Epsilon > (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x))
		{
			return false;
		}
		for (int i = 0; i < n; i++)
		{
			if (i != u && i != v && i != w)
			{
				Vector2 p = m_points[V[i]];
				if (InsideTriangle(a, b, c, p))
				{
					return false;
				}
			}
		}
		return true;
	}

	private bool InsideTriangle(Vector2 A, Vector2 B, Vector2 C, Vector2 P)
	{
		float num = C.x - B.x;
		float num2 = C.y - B.y;
		float num3 = A.x - C.x;
		float num4 = A.y - C.y;
		float num5 = B.x - A.x;
		float num6 = B.y - A.y;
		float num7 = P.x - A.x;
		float num8 = P.y - A.y;
		float num9 = P.x - B.x;
		float num10 = P.y - B.y;
		float num11 = P.x - C.x;
		float num12 = P.y - C.y;
		float num13 = num * num10 - num2 * num9;
		float num14 = num5 * num8 - num6 * num7;
		float num15 = num3 * num12 - num4 * num11;
		return num13 >= 0f && num15 >= 0f && num14 >= 0f;
	}
}
[RequireComponent(typeof(Collider))]
public class UIColliderHider : MonoBehaviour
{
	private Collider col;

	[@Dependency]
	public UIDisplayEvent UIDisplaySignal { get; set; }

	private void Awake()
	{
		base.enabled = false;
		this.Inject();
		SetupCollider();
	}

	private void SetupCollider()
	{
		if (col == null)
		{
			col = GetComponent<Collider>();
		}
		col.enabled = false;
	}

	private void Start()
	{
		UIDisplaySignal.AddListener(OnUIDisplaySignal);
	}

	private void OnUIDisplaySignal(UIEventType type)
	{
		switch (type)
		{
		case UIEventType.Display:
			col.enabled = true;
			break;
		case UIEventType.Remove:
			col.enabled = false;
			break;
		}
	}

	private void OnDestroy()
	{
		UIDisplaySignal.RemoveListener(OnUIDisplaySignal);
	}
}
public class UpdateDispatcher : MonoBehaviour
{
	private static UpdateDispatcher instance;

	private Action UpdateListeners;

	public static UpdateDispatcher Instance
	{
		get
		{
			if (instance == null)
			{
				GameObject gameObject = new GameObject("UpdateDispatcher");
				instance = gameObject.AddComponent<UpdateDispatcher>();
				UnityEngine.Object.DontDestroyOnLoad(gameObject);
			}
			return instance;
		}
	}

	public void AddListener(Action listener)
	{
		RemoveListener(listener);
		UpdateListeners = (Action)Delegate.Combine(UpdateListeners, listener);
	}

	public void RemoveListener(Action listener)
	{
		UpdateListeners = (Action)Delegate.Remove(UpdateListeners, listener);
	}

	private void Start()
	{
		AddListener(delegate
		{
		});
	}

	private void Update()
	{
		UpdateListeners();
	}
}
public class WaypointMovement : MonoBehaviour
{
	public GameObject[] Waypoints;

	private Transform departingWP;

	private Transform arrivingWP;

	private int waypointIndex;

	private Transform ourTransform;

	public bool shouldRandomizeStart;

	private float currentAnimationProgress;

	public float AnimationSpeed = 1f;

	private float animationDuration;

	private void Start()
	{
		if (shouldRandomizeStart)
		{
			currentAnimationProgress = UnityEngine.Random.Range(0f, 1f);
		}
		ourTransform = base.transform;
		SetWaypoint(0);
	}

	private void Update()
	{
		currentAnimationProgress += Time.deltaTime / animationDuration;
		while (currentAnimationProgress >= 1f)
		{
			SetWaypoint((waypointIndex + 1) % Waypoints.Length);
			currentAnimationProgress -= 1f;
		}
		ourTransform.position = Vector3.Lerp(departingWP.position, arrivingWP.position, currentAnimationProgress);
	}

	private void SetWaypoint(int index)
	{
		waypointIndex = index;
		departingWP = Waypoints[index].transform;
		arrivingWP = Waypoints[(index + 1) % Waypoints.Length].transform;
		animationDuration = Mathf.Max(0.01f, Vector3.Distance(departingWP.position, arrivingWP.position) / AnimationSpeed);
	}
}
public class ControllerSpawner : MonoBehaviour
{
	[SerializeField]
	private Hand controllerPrefab;

	[SerializeField]
	private Handedness[] controllersToSpawn;

	private void Awake()
	{
		for (int i = 0; i < controllersToSpawn.Length; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(controllerPrefab.gameObject, base.transform, worldPositionStays: false);
			Handedness handedness = controllersToSpawn[i];
			gameObject.name = "Hand" + handedness;
			Hand hand = Find.ComponentOnGameObject<Hand>(gameObject);
			hand.Handedness = handedness;
		}
	}
}
public class ControllerUI : SingleInstanceBehavior<ControllerUI>
{
	private GameObject statusUI;

	private Dictionary<ConnectionState, GameObject> viewForStatus;

	private static ConnectionState? currentlyShownStatus;

	private GameObject statusView;

	private ConnectionState? pendingStatus;

	private Coroutine currentCoroutine;

	private const float messageDelay = 0.5f;

	private const float messageShowTime = 1.5f;

	[@Dependency]
	public InputManager Input { get; set; }

	public override void Awake()
	{
		base.Awake();
		statusUI = Find.ChildByName(this, "ControllerStatus");
		viewForStatus = new Dictionary<ConnectionState, GameObject>();
		GameObject gameObject = Find.ChildByName(this, "ControllerStatus/DisconnectedStatus");
		viewForStatus[ConnectionState.Disconnected] = gameObject;
		gameObject.SetActive(value: false);
	}

	private void Start()
	{
		this.Inject();
		ConnectionState? connectionState = currentlyShownStatus;
		if (!connectionState.HasValue)
		{
			currentlyShownStatus = ((Input.GetInputMode() != InputMode.Headset) ? ConnectionState.Connected : ConnectionState.Disconnected);
		}
		Hide();
	}

	private void Update()
	{
		ConnectionState controllerConnection = Input.GetControllerConnection();
		if (controllerConnection == ConnectionState.Connected)
		{
			Hide();
			currentlyShownStatus = ConnectionState.Connected;
			if (currentCoroutine != null)
			{
				StopAllCoroutines();
				currentCoroutine = null;
				pendingStatus = null;
			}
		}
		else if (controllerConnection != pendingStatus && controllerConnection != currentlyShownStatus)
		{
			pendingStatus = controllerConnection;
			if (currentCoroutine != null)
			{
				StopAllCoroutines();
				currentCoroutine = null;
			}
			currentCoroutine = StartCoroutine(ShowStatusWithDelay(controllerConnection));
		}
	}

	public bool GameShouldBePaused()
	{
		if (!Input.IsConnected() || Input.IsRecentering())
		{
			return true;
		}
		return SingletonBehavior<DeviceConfigLoader>.Instance.GetConfig().ShouldPause();
	}

	private void Hide()
	{
		statusUI.SetActive(value: false);
		if (statusView != null)
		{
			statusView.SetActive(value: false);
			statusView = null;
		}
	}

	private IEnumerator ShowStatusWithDelay(ConnectionState status)
	{
		yield return new WaitForSeconds(0.5f);
		ShowStatus(status);
		StartCoroutine(DelayedRemoveOnHeadset());
		pendingStatus = null;
	}

	private IEnumerator DelayedRemoveOnHeadset()
	{
		while (currentlyShownStatus != ConnectionState.Connected && Input.GetInputMode() != InputMode.Headset)
		{
			yield return null;
		}
		yield return new WaitForSeconds(1.5f);
		Hide();
	}

	private void ShowStatus(ConnectionState status)
	{
		if (!(statusView != null) || status != currentlyShownStatus)
		{
			statusUI.SetActive(value: true);
			if (statusView != null)
			{
				statusView.SetActive(value: false);
			}
			bool flag = viewForStatus.TryGetValue(status, out statusView);
			statusView.SetActive(value: true);
			currentlyShownStatus = status;
		}
	}
}
public class BaseCursor : MonoBehaviour
{
	private float offsetFromObjects = 0.01f;

	public float defaultScale = 0.1f;

	public float minimumScale = 0.05f;

	public float maxLaserPointLenght = 50f;

	private Transform controllerTransform;

	private Transform currentOriginTransform;

	[Tooltip("Layermask for cursor interaction.")]
	public LayerMask LayerMask = -1;

	public Texture idleTexture;

	public Texture focusedTexture;

	public Texture leavingTexture;

	public Texture disabledTexture;

	private Transform transformComponent;

	private Renderer rendererComponent;

	private CrosshairTimer crosshairTimer;

	private GameObject latestGazeObject;

	private GazeButton latestGazeButton;

	private LineRenderer laserPointer;

	private bool isInintialized;

	private bool isFishing;

	private Dictionary<Handedness, ControllerVisualization> handSetup = new Dictionary<Handedness, ControllerVisualization>();

	private Handedness handedness;

	[@Dependency]
	public InputModeSwitchEvent GearVRInputSwitchSignal { get; set; }

	[@Dependency]
	public InputManager input { get; set; }

	[@Dependency]
	public FishingRodEvent FishingRodSignal { get; set; }

	private void Start()
	{
		this.Inject();
		GearVRInputSwitchSignal.AddListener(OnActiveControllerChanged);
		FishingRodSignal.AddListener(OnFishingRodSignal);
		FishingLine.ReelInDoneSignal.AddListener(OnReelInDoneSignal);
		CatchDisplay.CatchDisplaySignal.AddListener(OnCatchDisplaySignal);
		StartCoroutine(Ininitialize());
	}

	private IEnumerator Ininitialize()
	{
		ControllerVisualization[] visuals = UnityEngine.Object.FindObjectsOfType<ControllerVisualization>();
		foreach (ControllerVisualization controllerVisualization in visuals)
		{
			handSetup.Add(controllerVisualization.Handedness, controllerVisualization);
		}
		while (currentOriginTransform == null)
		{
			handedness = input.GetActiveController();
			LineRenderer rendere = handSetup[handedness].laserRenderer;
			if ((bool)rendere)
			{
				currentOriginTransform = rendere.transform;
			}
			yield return null;
		}
		laserPointer = handSetup[handedness].laserRenderer;
		isInintialized = true;
	}

	private void OnDestroy()
	{
		GearVRInputSwitchSignal.RemoveListener(OnActiveControllerChanged);
	}

	private void Awake()
	{
		transformComponent = base.transform;
		crosshairTimer = GetComponent<CrosshairTimer>();
		if (crosshairTimer == null)
		{
			UnityEngine.Debug.LogError("ERROR: missing crosshairTimer on " + base.name);
			base.enabled = false;
		}
		else
		{
			rendererComponent = GetComponent<Renderer>();
		}
	}

	private void OnDisable()
	{
		SetGraphicsEnabled(enabled: false);
	}

	public void SetGraphicsEnabled(bool enabled)
	{
		if (rendererComponent != null)
		{
			rendererComponent.enabled = enabled;
		}
		handSetup[handedness].SetVisible(enabled);
	}

	private void LateUpdate()
	{
		if (!isInintialized)
		{
			return;
		}
		Handedness activeController = input.GetActiveController();
		if (activeController != handedness && !handSetup[activeController].DisabledByGrabbing)
		{
			if (handedness != 0)
			{
				SetGraphicsEnabled(enabled: false);
			}
			handedness = activeController;
			laserPointer = handSetup[handedness].laserRenderer;
			currentOriginTransform = laserPointer.transform;
		}
		bool disabledByGrabbing = handSetup[handedness].DisabledByGrabbing;
		Vector3 position = currentOriginTransform.position;
		Vector3 forward = currentOriginTransform.forward;
		Vector3 vector = new Vector3(0f, 0f, maxLaserPointLenght);
		Ray ray = new Ray(position, forward);
		if (!disabledByGrabbing && Physics.Raycast(ray, out var hitInfo, float.PositiveInfinity, LayerMask))
		{
			transformComponent.position = CalculateCursorPosition(hitInfo.point, currentOriginTransform.position, out var crosshairForward);
			transformComponent.forward = crosshairForward;
			float num = Vector3.Distance(hitInfo.point, position) * 0.3f;
			float value = defaultScale * num;
			value = Mathf.Clamp(value, minimumScale, 1000f);
			transformComponent.localScale = new Vector3(value, value, value);
			GazeButton componentInParent = hitInfo.transform.gameObject.GetComponentInParent<GazeButton>();
			if (componentInParent != null)
			{
				if (latestGazeButton != null && latestGazeButton != componentInParent)
				{
					latestGazeButton.OnStopGaze();
				}
				latestGazeButton = componentInParent;
				latestGazeObject = hitInfo.transform.gameObject;
				transformComponent.localScale *= componentInParent.GetCrossHairScale();
			}
			else if (latestGazeButton != null)
			{
				latestGazeButton.OnStopGaze();
				latestGazeButton = null;
				latestGazeObject = null;
			}
			vector = new Vector3(0f, 0f, Vector3.Distance(currentOriginTransform.position, base.transform.position));
			SetGraphicsEnabled(enabled: true);
			UpdateVisual();
		}
		else
		{
			if (latestGazeButton != null)
			{
				latestGazeButton.OnStopGaze();
				latestGazeButton = null;
				latestGazeObject = null;
			}
			SetGraphicsEnabled(enabled: false);
		}
		laserPointer.SetPosition(0, vector * 0.5f);
		laserPointer.SetPosition(1, vector);
		crosshairTimer.SetGazedObject(latestGazeObject, latestGazeButton);
	}

	private Vector3 CalculateCursorPosition(Vector3 hitPoint, Vector3 cameraPosition, out Vector3 crosshairForward)
	{
		Vector3 vector = (crosshairForward = hitPoint - cameraPosition);
		return hitPoint + -vector.normalized * offsetFromObjects;
	}

	private void OnActiveControllerChanged(InputMode newInput)
	{
		switch (newInput)
		{
		case InputMode.Controller_3DoF:
		case InputMode.Controller_6DoF:
			currentOriginTransform = controllerTransform;
			break;
		default:
			currentOriginTransform = Camera.main.transform;
			break;
		}
	}

	private void OnFishingRodSignal(FishingRodEventType type)
	{
		switch (type)
		{
		case FishingRodEventType.ReleaseLine:
			isFishing = true;
			break;
		case FishingRodEventType.StopCasting:
			isFishing = false;
			break;
		}
	}

	private void OnReelInDoneSignal(bool fishOnHook)
	{
		if (!fishOnHook)
		{
			isFishing = false;
		}
	}

	private void OnCatchDisplaySignal(CatchDisplayEventType type)
	{
		if (type == CatchDisplayEventType.Show)
		{
			isFishing = false;
		}
	}

	private void UpdateVisual()
	{
		switch (crosshairTimer.InteractionState)
		{
		case CrosshairTimer.State.Idle:
			if (isFishing)
			{
				rendererComponent.material.mainTexture = disabledTexture;
			}
			else
			{
				rendererComponent.material.mainTexture = idleTexture;
			}
			break;
		case CrosshairTimer.State.Focused:
			if (isFishing)
			{
				rendererComponent.material.mainTexture = disabledTexture;
			}
			else if (latestGazeButton != null && latestGazeButton.FakeShowAsNotSelectable())
			{
				rendererComponent.material.mainTexture = idleTexture;
			}
			else
			{
				rendererComponent.material.mainTexture = focusedTexture;
			}
			break;
		case CrosshairTimer.State.Leaving:
			rendererComponent.material.mainTexture = leavingTexture;
			break;
		}
		float value = crosshairTimer.ImpactProgress();
		rendererComponent.material.SetFloat("_Progress", value);
	}
}
public class ControllerDefualtPosition : MonoBehaviour
{
	public Vector3 positionOffset = Vector3.zero;

	private void Start()
	{
		GameObject gameObject = GameObject.FindGameObjectWithTag("Player");
		if (gameObject != null)
		{
			base.transform.position = gameObject.transform.position + positionOffset;
		}
		GameObject gameObject2 = Find.ChildByName(this, gameObject, "VRCamera/TrackingSpace/CenterEyeAnchor");
		if (gameObject2 != null)
		{
			FollowHeadPosition followHeadPosition = base.gameObject.AddComponent<FollowHeadPosition>();
			followHeadPosition.headTransform = gameObject2.transform;
			followHeadPosition.positionOffset = positionOffset;
		}
	}
}
public class ControllerGraphicsHandle : MonoBehaviour
{
	public enum MaterialType
	{
		Idle,
		TouchClick,
		AppClick,
		SystemClick
	}

	public enum DisableType
	{
		Mesh,
		GameObject
	}

	public DisableType disableType;

	public MeshRenderer[] renderers;

	public GameObject[] gameobject;

	public bool supportAlpha;

	[Header("Optional")]
	public GameObject touch;

	public Transform touchIndicator;

	public void SetVisible(bool visible)
	{
		if (disableType == DisableType.GameObject)
		{
			for (int i = 0; i < gameobject.Length; i++)
			{
				gameobject[i].SetActive(visible);
			}
		}
		else
		{
			for (int j = 0; j < renderers.Length; j++)
			{
				renderers[j].enabled = visible;
			}
		}
	}

	public void SetTouchIndicatorActive(bool active)
	{
		touchIndicator.gameObject.SetActive(active);
	}

	public void SetTouchPosition(Vector2 position)
	{
		touchIndicator.localPosition = new Vector3(position.x, 0f, 0f - position.y);
	}
}
public class HandAnimation : MonoBehaviour
{
	public enum Pose
	{
		Flex,
		GenericHold,
		HoldBall,
		HoldController,
		HoldFishSoft,
		HoldReel,
		HoldFishHard
	}

	[SerializeField]
	private Handedness hand;

	[SerializeField]
	private Animator animator;

	public Transform fishAnchor;

	public const string ANIM_LAYER_NAME_POINT = "Point Layer";

	public const string ANIM_LAYER_NAME_THUMB = "Thumb Layer";

	public const string ANIM_PARAM_NAME_FLEX = "Flex";

	public const string ANIM_PARAM_NAME_POSE = "Pose";

	public const float INPUT_RATE_CHANGE = 20f;

	private int m_animLayerIndexThumb = -1;

	private int m_animLayerIndexPoint = -1;

	private int m_animParamIndexFlex = -1;

	private int m_animParamIndexPose = -1;

	private bool isPointing;

	private bool isGivingThumbsUp;

	private Pose currentPose;

	private float pointBlend;

	private float thumbsUpBlend;

	[@Dependency]
	public InputManager Input { get; set; }

	private void Awake()
	{
		this.Inject();
		m_animLayerIndexPoint = animator.GetLayerIndex("Point Layer");
		m_animLayerIndexThumb = animator.GetLayerIndex("Thumb Layer");
		m_animParamIndexFlex = Animator.StringToHash("Flex");
		m_animParamIndexPose = Animator.StringToHash("Pose");
	}

	private void Update()
	{
		UpdateCapTouchStates();
		pointBlend = InputValueRateChange(currentPose == Pose.Flex && isPointing, pointBlend);
		thumbsUpBlend = InputValueRateChange(currentPose == Pose.Flex && isGivingThumbsUp, thumbsUpBlend);
		UpdateAnimStates();
	}

	public void SetPose(Pose pose)
	{
		animator.SetInteger(m_animParamIndexPose, (int)pose);
		currentPose = pose;
	}

	private void UpdateCapTouchStates()
	{
		isPointing = !Input.IsTouching(InputAction.Trigger, hand);
		isGivingThumbsUp = !Input.GetWrapper().GetTouching((InputSource)384, InputMode.Controller_6DoF, hand);
	}

	private float InputValueRateChange(bool isDown, float value)
	{
		float num = Time.deltaTime * 20f;
		float num2 = ((!isDown) ? (-1f) : 1f);
		return Mathf.Clamp01(value + num * num2);
	}

	private void UpdateAnimStates()
	{
		float value = ((currentPose != 0) ? 0f : Input.Axis(InputAction.Grab, hand));
		animator.SetFloat(m_animParamIndexFlex, value);
		animator.SetLayerWeight(m_animLayerIndexPoint, pointBlend);
		animator.SetLayerWeight(m_animLayerIndexThumb, thumbsUpBlend);
		float value2 = Input.Axis(InputAction.Trigger, hand);
		animator.SetFloat("Pinch", value2);
	}
}
public class ControllerPosition : MonoBehaviour
{
	[SerializeField]
	private Handedness Hand;

	[@Dependency]
	public InputManager input { get; set; }

	private void Start()
	{
		this.Inject();
	}

	private void Update()
	{
		base.transform.localPosition = input.GetControllerLocalPosition(Hand);
		base.transform.localRotation = input.GetControllerOrientation(Hand);
	}
}
public enum SwipeDirection
{
	Up,
	Down,
	Left,
	Right
}
public class ControllerSwipe : MonoBehaviour
{
	public static Signal<SwipeDirection> SwipeSignal = new Signal<SwipeDirection>();

	[Range(0f, 1f)]
	public float minSwipeDist = 0.2f;

	private Vector2 startPos;

	private bool isSwiping;

	[@Dependency]
	public InputManager Input { get; set; }

	private void Awake()
	{
		this.Inject();
	}

	private void Update()
	{
		if (OVRInput.GetDown(OVRInput.Button.DpadRight))
		{
			SwipeSignal.Dispatch(SwipeDirection.Right);
		}
		else if (OVRInput.GetDown(OVRInput.Button.DpadLeft))
		{
			SwipeSignal.Dispatch(SwipeDirection.Left);
		}
	}
}
public enum ControllerHideEventType
{
	Hidden,
	Visible
}
public enum ControllerHiderState
{
	Idle,
	UI,
	Fishing,
	MenuScene
}
public class ControllerUnhider : MonoBehaviour
{
	public static Signal<ControllerHideEventType> ControllerHideSignal = new Signal<ControllerHideEventType>();

	public float thresholdUpper;

	public float thresholdLower;

	public float thresholdUp = 285f;

	private Transform cameraTransform;

	private bool isHeadSetMode;

	private bool skippUpdateOnSwitch;

	private ControllerHiderState currentState;

	private ControllerHideEventType currentVisibility;

	private ControllerVisualization visualization;

	private Hand hand;

	private Grabber grabber;

	private bool isActiveHand;

	private bool isGrabbing;

	[@Dependency]
	public FishingRodEvent FishingRodSignal { get; set; }

	[@Dependency]
	public UIDisplayEvent UIDisplaySignal { get; set; }

	[@Dependency]
	public Quest Quest { get; set; }

	[@Dependency]
	public InputManager input { get; set; }

	private IEnumerator Start()
	{
		this.Inject();
		hand = Find.ComponentOnGameObject<Hand>(base.gameObject);
		grabber = Find.ComponentOnGameObject<Grabber>(base.gameObject);
		FishingRodSignal.AddListener(OnFishingRodSignal);
		FishingLine.ReelInDoneSignal.AddListener(OnReelInDoneSignal);
		UIDisplaySignal.AddListener(OnUIDisplaySignal);
		visualization = Find.ComponentOnGameObject<ControllerVisualization>(base.gameObject);
		visualization.SetVisible(visible: false);
		isHeadSetMode = input.GetInputMode() == InputMode.Headset;
		currentState = ControllerHiderState.Idle;
		currentVisibility = ControllerHideEventType.Hidden;
		string activeSceneName = SceneManager.GetActiveScene().name;
		cameraTransform = Camera.main.transform;
		if (!isHeadSetMode && Quest.CurrentMission.MissionNumber == 0 && Quest.IsInIntroState())
		{
			yield return null;
			SetVisibility(ControllerHideEventType.Visible);
			currentState = ControllerHiderState.UI;
			yield break;
		}
		switch (activeSceneName)
		{
		case "TheDocks01":
		case "Shop01":
		case "SurfShop01":
			if (!isHeadSetMode)
			{
				SetVisibility(ControllerHideEventType.Visible);
			}
			currentState = ControllerHiderState.MenuScene;
			break;
		}
	}

	private void Update()
	{
		if (GetIsActvetHand() != isActiveHand || isGrabbing != grabber.IsGrabbging)
		{
			isActiveHand = GetIsActvetHand();
			isGrabbing = grabber.IsGrabbging;
			SetVisibility(isActiveHand ? ControllerHideEventType.Visible : ControllerHideEventType.Hidden);
		}
		if (currentState != 0 || skippUpdateOnSwitch || Quest.IsInIntroState() || !GetIsActvetHand() || grabber.IsGrabbging)
		{
			skippUpdateOnSwitch = false;
			return;
		}
		float num = 0f;
		if (cameraTransform == null)
		{
			Camera main = Camera.main;
			if (main != null)
			{
				cameraTransform = Camera.main.transform;
			}
			return;
		}
		num = cameraTransform.localEulerAngles.y;
		num = Mathf.Abs(Mathf.DeltaAngle(0f, num));
		Vector3 zero = Vector3.zero;
		zero = input.GetControllerOrientation().eulerAngles;
		if (zero.x > 200f && zero.x < thresholdUp)
		{
			zero.y = 0f;
		}
		zero.y = Mathf.Abs(Mathf.DeltaAngle(0f, zero.y));
		float num2 = Mathf.Max(zero.y, num);
		if (num2 > thresholdUpper && currentVisibility != ControllerHideEventType.Visible)
		{
			SetVisibility(ControllerHideEventType.Visible);
		}
		else if (num2 < thresholdLower && currentVisibility != 0)
		{
			SetVisibility(ControllerHideEventType.Hidden);
		}
	}

	private void OnDestroy()
	{
		FishingRodSignal.RemoveListener(OnFishingRodSignal);
		FishingLine.ReelInDoneSignal.RemoveListener(OnReelInDoneSignal);
		UIDisplaySignal.RemoveListener(OnUIDisplaySignal);
	}

	private void OnUIDisplaySignal(UIEventType type)
	{
		if (currentState != ControllerHiderState.MenuScene)
		{
			switch (type)
			{
			case UIEventType.Display:
				currentState = ControllerHiderState.UI;
				SetVisibility(ControllerHideEventType.Visible);
				break;
			case UIEventType.Remove:
				currentState = ControllerHiderState.Idle;
				SetVisibility(ControllerHideEventType.Hidden);
				break;
			}
		}
	}

	private void OnFishingRodSignal(FishingRodEventType type)
	{
		switch (type)
		{
		case FishingRodEventType.StartCasting:
			currentState = ControllerHiderState.Fishing;
			break;
		case FishingRodEventType.StopCasting:
			currentState = ControllerHiderState.Idle;
			break;
		}
	}

	private void OnReelInDoneSignal(bool fishOnHook)
	{
		currentState = (fishOnHook ? ControllerHiderState.Fishing : ControllerHiderState.Idle);
	}

	private bool GetIsActvetHand()
	{
		return input.GetActiveController() == hand.Handedness;
	}

	private void SetVisibility(ControllerHideEventType HideEvent)
	{
		currentVisibility = HideEvent;
		bool flag = currentVisibility == ControllerHideEventType.Visible && GetIsActvetHand() && !grabber.IsGrabbging;
		visualization.SetVisible(flag && !isHeadSetMode);
	}
}
public class ControllerVisualization : MonoBehaviour
{
	public Transform controllerGraphicsAnchor;

	[HideInInspector]
	public LineRenderer laserRenderer;

	public Color laserColorStart = Color.white;

	public Color laserColorEnd = Color.white;

	[Header("Oculus Specific")]
	[Range(0f, 0.4f)]
	public float fadeDistanceFromFace = 0.32f;

	private const float DELTA_ALPHA = 4f;

	private ControllerGraphicsHandle controller;

	private float alphaValue = 1f;

	private float fadeAlpha = 1f;

	private bool disabledByGrabbing;

	private Handedness handedness;

	public bool DisabledByGrabbing
	{
		get
		{
			return disabledByGrabbing;
		}
		set
		{
			disabledByGrabbing = value;
		}
	}

	public Handedness Handedness => handedness;

	private void Start()
	{
		Hand component = GetComponent<Hand>();
		DeviceConfig config = SingletonBehavior<DeviceConfigLoader>.Instance.GetConfig();
		handedness = component.Handedness;
		ConfigPrefab objectType = ((handedness != Handedness.Right) ? ConfigPrefab.HandLeft : ConfigPrefab.HandRight);
		GameObject prefabOfType = config.GetPrefabOfType(objectType);
		GameObject gameObject = null;
		gameObject = UnityEngine.Object.Instantiate(prefabOfType);
		gameObject.transform.SetParent(controllerGraphicsAnchor, worldPositionStays: false);
		controller = Find.ComponentOnGameObject<ControllerGraphicsHandle>(this, gameObject);
		laserRenderer = Find.ComponentOnChild<LineRenderer>(controller, "LaserOrigin");
		SetVisible(visible: false);
	}

	private void Update()
	{
		float a = 1f;
		float num = Vector3.Distance(base.transform.localPosition, Vector3.zero);
		if (num < fadeDistanceFromFace)
		{
			fadeAlpha = Mathf.Max(0f, fadeAlpha - 4f * Time.deltaTime);
		}
		else
		{
			fadeAlpha = Mathf.Min(1f, fadeAlpha + 4f * Time.deltaTime);
		}
		a = Mathf.Min(a, alphaValue);
		SetLineRendererAlpha(laserRenderer, Mathf.Min(laserColorEnd.a, a), a);
	}

	public void SetVisible(bool visible)
	{
		if (controller.supportAlpha)
		{
			StopAllCoroutines();
			StartCoroutine(FadeAlpha((!visible) ? 0f : 1f, 0.2f));
		}
		else
		{
			SetControllerVisible(visible);
		}
	}

	private IEnumerator FadeAlpha(float target, float time)
	{
		if (target != 0f)
		{
			SetControllerVisible(visible: true);
		}
		float timePassed = 0f;
		float start = alphaValue;
		while (timePassed < time)
		{
			timePassed += Time.deltaTime;
			alphaValue = Mathf.Lerp(start, target, timePassed / time);
			yield return null;
		}
		alphaValue = target;
		SetControllerVisible(alphaValue != 0f);
	}

	private void SetControllerVisible(bool visible)
	{
		if (controller != null)
		{
			controller.SetVisible(visible);
		}
		if (laserRenderer != null)
		{
			laserRenderer.enabled = visible;
		}
	}

	private void SetLineRendererAlpha(LineRenderer r, float alpha1, float alpha2)
	{
		Color startColor = laserColorStart;
		startColor.a = alpha1;
		Color endColor = laserColorEnd;
		endColor.a = alpha2;
		r.startColor = startColor;
		r.endColor = endColor;
	}
}
public class CrosshairTimer : MonoBehaviour
{
	public enum State
	{
		Idle,
		Focused,
		Leaving
	}

	private class Target
	{
		public GazeButton button;

		public GameObject gameObject;
	}

	private class SelectionState
	{
		public bool selected;

		public bool selectedWithKey;

		public bool waitForLookAway;
	}

	private int amountOfGazeInteractions;

	private int amountOfButtonInteractions;

	public LayerMask layerForImpact;

	public Transform cameraTransform;

	public bool enableTimeout;

	[Tooltip("The timeout the crosshair will have if it is not specified on the GazeButton")]
	public float defaultGazeTimeout = 1f;

	[Tooltip("How many times slower the gaze timeout is after you have used the key to select")]
	public float afterKeypressTimeoutFactor = 3f;

	public AudioClip focusSound;

	public AudioClip selectSound;

	private State state;

	private float progress;

	private GameObject gazedObject;

	private GazeButton gazedButton;

	private bool blockInput;

	private float lastHapticTime;

	private float minHapticDelay = 0.125f;

	public State InteractionState => state;

	public int AmountOfGazeInteractions => amountOfGazeInteractions;

	public int AmountOfButtonInteractions => amountOfButtonInteractions;

	[@Dependency]
	public InputModeSwitchEvent GearVRInputSwitchSignal { get; set; }

	[@Dependency]
	public InputManager input { get; set; }

	private void Awake()
	{
		this.Inject();
		GearVRInputSwitchSignal.AddListener(OnActiveControllerChanged);
	}

	private void OnDestroy()
	{
		GearVRInputSwitchSignal.RemoveListener(OnActiveControllerChanged);
	}

	private void OnActiveControllerChanged(InputMode type)
	{
		blockInput = true;
		StartCoroutine(ResumeInput(0.5f));
	}

	private IEnumerator ResumeInput(float waitTime)
	{
		yield return new WaitForSeconds(waitTime);
		blockInput = false;
	}

	private IEnumerator Start()
	{
		Camera CameraMain = Camera.main;
		if (CameraMain == null)
		{
			UnityEngine.Debug.LogError("ERROR: missing camera object on " + base.name);
			base.enabled = false;
			yield return false;
		}
		else
		{
			cameraTransform = CameraMain.transform;
		}
		yield return null;
		SelectionState selectionState = new SelectionState();
		Target target = new Target();
		while (true)
		{
			progress = 0f;
			if (!selectionState.selected)
			{
				yield return StartCoroutine(WaitForFocus(target));
				yield return StartCoroutine(WaitForSelect(target, selectionState));
			}
			if (!selectionState.selected)
			{
				continue;
			}
			try
			{
				if (base.enabled)
				{
					Select(target, selectionState);
				}
			}
			catch
			{
				UnityEngine.Debug.Log("Tried clicking on button when CrosshairTimer wasn not enabled");
			}
			yield return StartCoroutine(WaitForLookAway(target, selectionState));
		}
	}

	private void PlaySound(AudioClip clip)
	{
		if (GetComponent<AudioSource>() != null)
		{
			GetComponent<AudioSource>().PlayOneShot(clip);
		}
	}

	private bool IsSelectable(GazeButton button, GameObject gameObject)
	{
		if (button == null)
		{
			return false;
		}
		try
		{
			return button.IsSelectable(gameObject);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(string.Concat("IsSelectable failed for ", button, ": ", ex));
			return false;
		}
	}

	private bool LookingAtObject(GameObject gameObject)
	{
		GazeButton button = null;
		GameObject gameObject2 = null;
		GetGazedObject(out button, out gameObject2);
		return gameObject2 == gameObject;
	}

	private bool KeyIsPressed()
	{
		return input.IsButtonDown(InputAction.Trigger);
	}

	public float ImpactProgress()
	{
		return progress;
	}

	public void SetGazedObject(GameObject gameObject, GazeButton gazeButton)
	{
		gazedObject = gameObject;
		gazedButton = gazeButton;
	}

	public bool GetGazedObject(out GazeButton button, out GameObject gameObject)
	{
		if (gazedObject == null)
		{
			button = null;
			gameObject = null;
			return false;
		}
		gameObject = gazedObject;
		button = gazedButton;
		if (button == null)
		{
			return false;
		}
		return true;
	}

	private Ray GetCameraRay()
	{
		Vector3 position = cameraTransform.position;
		Vector3 forward = cameraTransform.forward;
		return new Ray(position, forward);
	}

	private IEnumerator WaitForFocus(Target target)
	{
		state = State.Idle;
		while (true)
		{
			GetGazedObject(out target.button, out target.gameObject);
			if (IsSelectable(target.button, target.gameObject))
			{
				break;
			}
			yield return null;
		}
		TriggerHaptic();
	}

	private void TriggerHaptic()
	{
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		float num = realtimeSinceStartup - lastHapticTime;
		if (num > minHapticDelay)
		{
			lastHapticTime = realtimeSinceStartup;
			input.RandomHaptic(0.07f, 0.12f, 0.08f);
		}
	}

	private IEnumerator WaitForSelect(Target target, SelectionState selectionState)
	{
		PlaySound(focusSound);
		target.button.OnStartGaze();
		state = State.Focused;
		float timeout = 0f;
		if (enableTimeout)
		{
			timeout = target.button.GetGazeTimerLength(target.gameObject, defaultGazeTimeout);
			if (selectionState.selectedWithKey)
			{
				timeout *= afterKeypressTimeoutFactor;
			}
		}
		selectionState.selected = false;
		float impactTime = 0f;
		do
		{
			yield return null;
			if (KeyIsPressed() && !blockInput)
			{
				selectionState.selected = true;
				selectionState.selectedWithKey = true;
				amountOfButtonInteractions++;
			}
			if (enableTimeout)
			{
				impactTime += Time.deltaTime;
				if (impactTime >= timeout)
				{
					selectionState.selected = true;
					selectionState.selectedWithKey = false;
					progress = 1f;
					amountOfGazeInteractions++;
				}
				else
				{
					progress = impactTime / timeout;
				}
			}
		}
		while (!selectionState.selected && LookingAtObject(target.gameObject));
		if (GetComponent<AudioSource>() != null)
		{
			GetComponent<AudioSource>().Stop();
		}
	}

	private void Select(Target target, SelectionState selectionState)
	{
		PlaySound(selectSound);
		GazeButton.PostSelectAction postSelectAction;
		try
		{
			postSelectAction = target.button.OnSelect(target.gameObject);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(string.Concat("OnSelect failed for ", target.button, ": ", ex));
			postSelectAction = GazeButton.PostSelectAction.WaitForLookAway;
		}
		selectionState.waitForLookAway = postSelectAction == GazeButton.PostSelectAction.WaitForLookAway;
	}

	private IEnumerator WaitForLookAway(Target target, SelectionState selectionState)
	{
		progress = 0f;
		selectionState.selected = false;
		GazeButton newButton = null;
		GameObject newObject = null;
		if (!selectionState.waitForLookAway)
		{
			yield break;
		}
		state = State.Leaving;
		do
		{
			yield return null;
			GetGazedObject(out newButton, out newObject);
			if (KeyIsPressed() && IsSelectable(newButton, newObject) && !blockInput)
			{
				selectionState.selected = true;
				selectionState.selectedWithKey = true;
				target.button = newButton;
				target.gameObject = newObject;
				break;
			}
		}
		while (newButton == target.button);
	}
}
public class GazeButton : MonoBehaviour
{
	public enum PostSelectAction
	{
		Restart,
		WaitForLookAway
	}

	private void Awake()
	{
		this.Inject();
	}

	public virtual bool ForceSendEvents()
	{
		return false;
	}

	public virtual bool IsSelectable(GameObject obj)
	{
		return true;
	}

	public virtual bool FakeShowAsNotSelectable()
	{
		return false;
	}

	public virtual PostSelectAction OnSelect(GameObject obj)
	{
		return PostSelectAction.Restart;
	}

	public virtual float GetGazeTimerLength(GameObject obj, float defaultTime)
	{
		return defaultTime;
	}

	public virtual float GetCrossHairScale()
	{
		return 1f;
	}

	public virtual void OnStartGaze()
	{
	}

	public virtual void OnStopGaze()
	{
	}
}
public class LaserPointerAngle : MonoBehaviour
{
	public Vector3 AngleOnOculus;

	private void Start()
	{
		base.transform.localRotation = Quaternion.Euler(AngleOnOculus);
	}
}
public enum ConfigPrefab
{
	Camera,
	HandLeft,
	HandRight,
	Essentials
}
[CreateAssetMenu(fileName = "DeviceConfig.asset", menuName = "Create Config/Generic Config")]
public class DeviceConfig : ScriptableObject
{
	[SerializeField]
	private int targetFps = 60;

	[SerializeField]
	private GameObject cameraPrefab;

	[SerializeField]
	private GameObject rightHand;

	[SerializeField]
	private GameObject leftHand;

	[SerializeField]
	[Tooltip("GameObject that holds all general device specific scripts")]
	private GameObject deviceEssentials;

	[SerializeField]
	private bool useSecondaryTutorialImage;

	[SerializeField]
	[Tooltip("Overrides the Texture resolution scale if value is greater than 0")]
	private float TextureResolutionScale;

	[SerializeField]
	[Tooltip("Whether the handle of the rod should fade when pointing the rod towards the camera.")]
	private bool fadeRodShaft;

	[SerializeField]
	private InputMode defaultInputMode;

	[EnumFlag]
	[SerializeField]
	private InputMode supportedInputModes;

	public virtual int GetTargetFPS()
	{
		return targetFps;
	}

	public virtual bool ShouldPause()
	{
		return false;
	}

	public virtual bool GetUseSecondaryImage()
	{
		return useSecondaryTutorialImage;
	}

	public virtual GameObject GetCameraPrefab()
	{
		return cameraPrefab;
	}

	public virtual GameObject GetHandRight()
	{
		return rightHand;
	}

	public virtual GameObject GetHandLeft()
	{
		return leftHand;
	}

	public virtual GameObject GetEssentialsPrefab()
	{
		return deviceEssentials;
	}

	public virtual Type GetTrackerType()
	{
		return typeof(DummyTracking);
	}

	public virtual float GetTextureResolutionScale()
	{
		return TextureResolutionScale;
	}

	public virtual bool GetFadeRodShaft()
	{
		return fadeRodShaft;
	}

	public virtual InputMode GetDefaultInputMode()
	{
		return defaultInputMode;
	}

	public virtual bool IsInputModeSupported(InputMode inputMode)
	{
		return (supportedInputModes & inputMode) != 0;
	}

	public GameObject GetPrefabOfType(ConfigPrefab objectType)
	{
		GameObject result = null;
		switch (objectType)
		{
		case ConfigPrefab.Camera:
			result = GetCameraPrefab();
			break;
		case ConfigPrefab.HandLeft:
			result = GetHandLeft();
			break;
		case ConfigPrefab.HandRight:
			result = GetHandRight();
			break;
		case ConfigPrefab.Essentials:
			result = GetEssentialsPrefab();
			break;
		}
		return result;
	}
}
public class DeviceConfigLoader : SingletonBehavior<DeviceConfigLoader>
{
	private DeviceConfig config;

	public override void Awake()
	{
		UnityEngine.Debug.Log("ConfigLoader: Awake()+");
		base.Awake();
		if (SingletonBehavior<DeviceConfigLoader>.Instance == this)
		{
			LoadConfig();
			UnityEngine.Object.DontDestroyOnLoad(this);
		}
		UnityEngine.Debug.Log("ConfigLoader: Awake()-");
	}

	public DeviceConfig GetConfig()
	{
		if (config == null)
		{
			UnityEngine.Debug.LogWarning("Tried getting platform config without one loaded! Loading immediately to fix this");
			LoadConfig();
		}
		return config;
	}

	private void LoadConfig()
	{
		string path = DeviceDetection.GetDevice().ToString() + "Config";
		config = Resources.Load<DeviceConfig>(path);
	}
}
public enum Device
{
	GearVR = 1,
	Daydream = 2,
	OculusGo = 4,
	Polaris = 8,
	ViveFocus = 0x10,
	Xiaomi = 0x20,
	SantaCruz = 0x40,
	Rift = 0x80,
	Pico = 0x100
}
public static class DeviceDetection
{
	public const string OVERRIDE_PREFS_KEY = "DEVICE_OVERRIDE";

	private static Device? currentDevice;

	public static Device GetDevice()
	{
		if (!currentDevice.HasValue)
		{
			SetCurrentDevice();
		}
		return currentDevice.Value;
	}

	private static void SetCurrentDevice()
	{
		if (OVRPlugin.GetSystemHeadsetType() == OVRPlugin.SystemHeadset.Oculus_Go)
		{
			currentDevice = Device.OculusGo;
		}
		else
		{
			currentDevice = Device.SantaCruz;
		}
		UnityEngine.Debug.Log("SystemInfo.deviceModel: " + SystemInfo.deviceModel);
		UnityEngine.Debug.Log("CurrentDevice: " + currentDevice);
	}
}
public enum DeviceModel
{
	S6 = 1
}
public class AdaptRenderScaleForScene : MonoBehaviour
{
	[Serializable]
	private class DeviceRenderSetttings
	{
		[EnumFlag]
		public DeviceModel device;

		public float renderScale = 1f;
	}

	[SerializeField]
	private DeviceRenderSetttings[] deviceSettings;

	private DeviceModel currentDevice;

	private void Awake()
	{
		GetCurrentDevice();
		for (int i = 0; i < deviceSettings.Length; i++)
		{
			DeviceRenderSetttings deviceRenderSetttings = deviceSettings[i];
			if (deviceRenderSetttings != null && (currentDevice & deviceRenderSetttings.device) != 0)
			{
				XRSettings.renderViewportScale = deviceRenderSetttings.renderScale;
			}
		}
	}

	private void OnDestroy()
	{
		XRSettings.renderViewportScale = 1f;
	}

	private void GetCurrentDevice()
	{
		string deviceModel = SystemInfo.deviceModel;
		UnityEngine.Debug.Log("Current Device is : " + deviceModel);
		if (deviceModel.Contains("SM-G92"))
		{
			currentDevice = DeviceModel.S6;
		}
	}
}
public class EntitlementCheck : MonoBehaviour
{
	private GameObject entitlementText;

	private void Start()
	{
		if (!Core.IsInitialized())
		{
			Core.AsyncInitialize().OnComplete(OnInitializedCallback);
		}
		entitlementText = Find.ChildByName(this, "EntitlementText");
		entitlementText.SetActive(value: false);
		Entitlements.IsUserEntitledToApplication().OnComplete(OnIsUserEntitled);
		UnityEngine.Debug.Log("EntitlementCheck: Checking User Entitlement. ");
	}

	private void OnInitializedCallback(Message msg)
	{
		if (!msg.IsError)
		{
			UnityEngine.Debug.Log("EntitlementCheck: Oculus Platform initialized");
			return;
		}
		Error error = msg.GetError();
		UnityEngine.Debug.Log("EntitlementCheck : Oculus Platform OnInitilize: FAIL. Error code: " + error.Code + " http: " + error.HttpCode + " msg: " + error.Message);
		Tracking.Track("rg_iap_initialize_error").AddParameter("message", error.Message);
	}

	private void OnIsUserEntitled(Message msg)
	{
		if (!msg.IsError)
		{
			UnityEngine.Debug.Log("EntitlementCheck: Entitlement passed");
			return;
		}
		UnityEngine.Debug.Log("EntitlementCheck: Entitlement failed");
		StartCoroutine(OnEntitlementfailed());
	}

	private IEnumerator OnEntitlementfailed()
	{
		entitlementText.SetActive(value: true);
		yield return new WaitForSeconds(8f);
		UnityEngine.Application.Quit();
	}
}
public class InputModeSwitchEvent : Signal<InputMode>
{
}
public class InputWrapperGearVR : InputWrapper
{
	protected virtual OVRInput.Controller GetOVRController(InputMode inputMode, Handedness hand)
	{
		return inputMode switch
		{
			InputMode.Controller_3DoF => hand switch
			{
				Handedness.Left => OVRInput.Controller.LTrackedRemote, 
				Handedness.Right => OVRInput.Controller.RTrackedRemote, 
				_ => throw new Exception(string.Concat("Trying to get controller for undefined inputmode/handedness: ", inputMode, " ", hand)), 
			}, 
			InputMode.Controller_6DoF => hand switch
			{
				Handedness.Left => OVRInput.Controller.LTouch, 
				Handedness.Right => OVRInput.Controller.RTouch, 
				_ => throw new Exception(string.Concat("Trying to get controller for undefined inputmode/handedness: ", inputMode, " ", hand)), 
			}, 
			InputMode.Headset => OVRInput.Controller.Touchpad, 
			InputMode.Gamepad => OVRInput.Controller.Gamepad, 
			_ => throw new Exception("Trying to get controller for undefined inputmode: " + inputMode), 
		};
	}

	protected virtual OVRInput.Button GetOVRButton(InputSource button)
	{
		OVRInput.Button button2 = OVRInput.Button.None;
		if ((InputSource.One & button) > (InputSource)0)
		{
			button2 |= OVRInput.Button.One;
		}
		if ((InputSource.Two & button) > (InputSource)0)
		{
			button2 |= OVRInput.Button.Two;
		}
		if ((InputSource.Three & button) > (InputSource)0)
		{
			button2 |= OVRInput.Button.Three;
		}
		if ((InputSource.Four & button) > (InputSource)0)
		{
			button2 |= OVRInput.Button.Four;
		}
		if ((InputSource.IndexTrigger & button) > (InputSource)0)
		{
			button2 |= OVRInput.Button.PrimaryIndexTrigger;
		}
		if ((InputSource.GripTrigger & button) > (InputSource)0)
		{
			button2 |= OVRInput.Button.PrimaryHandTrigger;
		}
		if ((InputSource.Touchpad & button) > (InputSource)0)
		{
			button2 |= OVRInput.Button.PrimaryTouchpad;
		}
		if ((InputSource.Thumbstick & button) > (InputSource)0)
		{
			button2 |= OVRInput.Button.PrimaryThumbstick;
		}
		if ((InputSource.Special & button) > (InputSource)0)
		{
			button2 |= OVRInput.Button.Start;
		}
		return button2;
	}

	protected virtual OVRInput.Axis1D GetOVRAxis1D(InputSource axis)
	{
		OVRInput.Axis1D axis1D = OVRInput.Axis1D.None;
		if ((InputSource.IndexTrigger & axis) > (InputSource)0)
		{
			axis1D |= OVRInput.Axis1D.PrimaryIndexTrigger;
		}
		if ((InputSource.GripTrigger & axis) > (InputSource)0)
		{
			axis1D |= OVRInput.Axis1D.PrimaryHandTrigger;
		}
		return axis1D;
	}

	protected virtual OVRInput.Axis2D GetOVRAxis2D(InputSource axis)
	{
		OVRInput.Axis2D axis2D = OVRInput.Axis2D.None;
		if ((InputSource.Thumbstick & axis) > (InputSource)0)
		{
			axis2D |= OVRInput.Axis2D.PrimaryThumbstick;
		}
		if ((InputSource.Touchpad & axis) > (InputSource)0)
		{
			axis2D |= OVRInput.Axis2D.PrimaryTouchpad;
		}
		return axis2D;
	}

	protected virtual OVRInput.Touch GetOVRTouch(InputSource touch)
	{
		OVRInput.Touch touch2 = OVRInput.Touch.None;
		if ((InputSource.One & touch) > (InputSource)0)
		{
			touch2 |= OVRInput.Touch.One;
		}
		if ((InputSource.Two & touch) > (InputSource)0)
		{
			touch2 |= OVRInput.Touch.Two;
		}
		if ((InputSource.Three & touch) > (InputSource)0)
		{
			touch2 |= OVRInput.Touch.Three;
		}
		if ((InputSource.Four & touch) > (InputSource)0)
		{
			touch2 |= OVRInput.Touch.Four;
		}
		if ((InputSource.IndexTrigger & touch) > (InputSource)0)
		{
			touch2 |= OVRInput.Touch.PrimaryIndexTrigger;
		}
		if ((InputSource.Touchpad & touch) > (InputSource)0)
		{
			touch2 |= OVRInput.Touch.PrimaryTouchpad;
		}
		if ((InputSource.Thumbstick & touch) > (InputSource)0)
		{
			touch2 |= OVRInput.Touch.PrimaryThumbstick;
		}
		return touch2;
	}

	protected virtual OVRInput.NearTouch GetOVRTouchNear(InputSource touch)
	{
		OVRInput.NearTouch nearTouch = OVRInput.NearTouch.None;
		if ((InputSource.Thumbstick & touch) > (InputSource)0)
		{
			nearTouch |= OVRInput.NearTouch.PrimaryThumbButtons;
		}
		if ((InputSource.IndexTrigger & touch) > (InputSource)0)
		{
			nearTouch |= OVRInput.NearTouch.PrimaryIndexTrigger;
		}
		return nearTouch;
	}

	protected virtual OVRInput.Controller GetHandedController()
	{
		return GetOVRController(InputMode.Controller_3DoF, GetHandedness());
	}

	public override Handedness GetHandedness()
	{
		return (!OVRInput.IsControllerConnected(OVRInput.Controller.LTrackedRemote)) ? Handedness.Right : Handedness.Left;
	}

	public override bool IsControllerActive(InputMode inputMode, Handedness hand)
	{
		OVRInput.Controller activeController = OVRInput.GetActiveController();
		return activeController == GetOVRController(inputMode, hand) && GetConnectionState(inputMode, hand) == ConnectionState.Connected;
	}

	public override bool IsInputEnabled()
	{
		return OVRManager.hasInputFocus;
	}

	public override Vector3 GetControllerAcceleration(InputMode inputMode, Handedness hand)
	{
		return OVRInput.GetLocalControllerAcceleration(GetOVRController(inputMode, hand));
	}

	public override Quaternion GetControllerOrientation(InputMode inputMode, Handedness hand)
	{
		return OVRInput.GetLocalControllerRotation(GetOVRController(inputMode, hand));
	}

	public override Vector3 GetControllerAngularVelocity(InputMode inputMode, Handedness hand)
	{
		return OVRInput.GetLocalControllerAngularVelocity(GetOVRController(inputMode, hand));
	}

	public override Vector3 GetControllerLocalPosition(InputMode inputMode, Handedness hand)
	{
		return OVRInput.GetLocalControllerPosition(GetOVRController(inputMode, hand));
	}

	public override float GetAxis(InputSource axis, InputMode inputMode, Handedness hand)
	{
		return OVRInput.Get(GetOVRAxis1D(axis), GetOVRController(inputMode, hand));
	}

	public override Vector2 GetAxis2D(InputSource axis, InputMode inputMode, Handedness hand)
	{
		return OVRInput.Get(GetOVRAxis2D(axis), GetOVRController(inputMode, hand));
	}

	public override bool GetButtonDown(InputSource button, InputMode inputMode, Handedness hand)
	{
		return OVRInput.GetDown(GetOVRButton(button), GetOVRController(inputMode, hand));
	}

	public override bool GetButtonUp(InputSource button, InputMode inputMode, Handedness hand)
	{
		return OVRInput.GetUp(GetOVRButton(button), GetOVRController(inputMode, hand));
	}

	public override bool GetButton(InputSource button, InputMode inputMode, Handedness hand)
	{
		return OVRInput.Get(GetOVRButton(button), GetOVRController(inputMode, hand));
	}

	public override bool GetTouchingDown(InputSource area, InputMode inputMode, Handedness hand)
	{
		return OVRInput.GetDown(GetOVRTouch(area), GetOVRController(inputMode, hand));
	}

	public override bool GetTouchingUp(InputSource area, InputMode inputMode, Handedness hand)
	{
		return OVRInput.GetUp(GetOVRTouch(area), GetOVRController(inputMode, hand));
	}

	public override bool GetTouching(InputSource area, InputMode inputMode, Handedness hand)
	{
		return OVRInput.Get(GetOVRTouch(area), GetOVRController(inputMode, hand));
	}

	public override bool GetTouchingNearDown(InputSource area, InputMode inputMode, Handedness hand)
	{
		return OVRInput.GetDown(GetOVRTouchNear(area), GetOVRController(inputMode, hand));
	}

	public override bool GetTouchingNearUp(InputSource area, InputMode inputMode, Handedness hand)
	{
		return OVRInput.GetUp(GetOVRTouchNear(area), GetOVRController(inputMode, hand));
	}

	public override bool GetTouchingNear(InputSource area, InputMode inputMode, Handedness hand)
	{
		return OVRInput.Get(GetOVRTouchNear(area), GetOVRController(inputMode, hand));
	}

	public override bool GetIsRecentering()
	{
		return false;
	}

	public override ConnectionState GetConnectionState(InputMode inputMode, Handedness hand)
	{
		return OVRInput.IsControllerConnected(GetOVRController(inputMode, hand)) ? ConnectionState.Connected : ConnectionState.Disconnected;
	}
}
[CreateAssetMenu(fileName = "OculusConfig.asset", menuName = "Create Config/Oculus Config")]
public class OculusConfig : DeviceConfig
{
	public override bool ShouldPause()
	{
		if (!OVRPlugin.userPresent)
		{
			return true;
		}
		return false;
	}

	public override Type GetTrackerType()
	{
		if (DeviceDetection.GetDevice() == Device.SantaCruz)
		{
			UnityEngine.Debug.Log("Initialize Dummy Tracking");
			return typeof(DummyTracking);
		}
		return base.GetTrackerType();
	}
}
public class InputWrapperGoogleVR : InputWrapper
{
}
public class FishingGameBackButtonBehavior : MonoBehaviour
{
	public static FishingGameBackButtonBehavior instance;

	private bool isMainMenuScene;

	private bool isInCreditsScene;

	private Fader[] faders;

	private bool initialized;

	[@Dependency]
	public GameSession GameSession { get; set; }

	[@Dependency]
	public InputManager input { get; set; }

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
			this.Inject();
			isMainMenuScene = SceneManager.GetActiveScene().name == "TheDocks01";
			isInCreditsScene = SceneManager.GetActiveScene().name == "Credits";
			faders = UnityEngine.Object.FindObjectsOfType<Fader>();
			input.AddBackButtonListener(6, OnMenuBackButtonHandler);
			initialized = true;
		}
		else
		{
			UnityEngine.Object.Destroy(this);
		}
	}

	public bool ShouldLoadTheDocks()
	{
		return !isMainMenuScene && AllFadersAreDone();
	}

	public CallbackResult OnMenuBackButtonHandler()
	{
		if (isMainMenuScene)
		{
			return CallbackResult.NotConsumed;
		}
		if (isInCreditsScene)
		{
			LoadScene.LoadSceneSignal.Dispatch("TheDocks01");
			return CallbackResult.Consumed;
		}
		if (ShouldLoadTheDocks())
		{
			GameSession.ManuallySaveSession();
			LoadScene.LoadSceneSignal.Dispatch("TheDocks01");
		}
		return CallbackResult.Consumed;
	}

	private bool AllFadersAreDone()
	{
		for (int i = 0; i < faders.Length; i++)
		{
			if (!faders[i].Done)
			{
				return false;
			}
		}
		return true;
	}

	private void OnDestroy()
	{
		if (initialized)
		{
			input.RemoveBackButtonListener(OnMenuBackButtonHandler);
		}
	}
}
public class OVRPlatformMenuRG : MonoBehaviour
{
	public enum eHandler
	{
		ShowConfirmQuit,
		RetreatOneLevel,
		BaitBackButton
	}

	private enum eBackButtonAction
	{
		NONE,
		SHORT_PRESS
	}

	private OVRInput.RawButton inputCode = OVRInput.RawButton.Back;

	public eHandler shortPressHandler;

	public Func<bool> OnShortPress;

	private static Stack<string> sceneStack = new Stack<string>();

	[@Dependency]
	private InputManager input { get; set; }

	private eBackButtonAction HandleBackButtonState()
	{
		eBackButtonAction result = eBackButtonAction.NONE;
		if (OVRInput.GetDown(inputCode))
		{
			result = eBackButtonAction.SHORT_PRESS;
		}
		return result;
	}

	private void Awake()
	{
		if (shortPressHandler == eHandler.BaitBackButton && OnShortPress == null)
		{
			OnShortPress = BaitBackButton;
		}
		if (shortPressHandler == eHandler.RetreatOneLevel && OnShortPress == null)
		{
			OnShortPress = RetreatOneLevel;
		}
		if (!OVRManager.isHmdPresent)
		{
			base.enabled = false;
		}
		else
		{
			sceneStack.Push(SceneManager.GetActiveScene().name);
		}
	}

	private void Start()
	{
		this.Inject();
	}

	private void ShowConfirmQuitMenu()
	{
		UnityEngine.Debug.Log("[PlatformUI-ConfirmQuit] Showing @ " + Time.time);
		OVRManager.PlatformUIConfirmQuit();
	}

	private bool BaitBackButton()
	{
		bool flag = input.HandleBackButtonPress();
		if (!flag && FishingGameBackButtonBehavior.instance != null && FishingGameBackButtonBehavior.instance.ShouldLoadTheDocks())
		{
			FishingGameBackButtonBehavior.instance.OnMenuBackButtonHandler();
			return false;
		}
		return !flag;
	}

	private static bool RetreatOneLevel()
	{
		if (sceneStack.Count > 1)
		{
			string sceneName = sceneStack.Pop();
			SceneManager.LoadSceneAsync(sceneName);
			return false;
		}
		return true;
	}

	private void Update()
	{
		eBackButtonAction eBackButtonAction = HandleBackButtonState();
		if (eBackButtonAction == eBackButtonAction.SHORT_PRESS && (OnShortPress == null || OnShortPress()))
		{
			ShowConfirmQuitMenu();
		}
	}
}
public class OculusPerformanceSettings : MonoBehaviour
{
	[Range(0f, 3f)]
	public int cpuLevel;

	[Range(0f, 3f)]
	public int gpuLevel;

	private void Start()
	{
		OVRPlugin.cpuLevel = cpuLevel;
		OVRPlugin.gpuLevel = gpuLevel;
	}
}
public class DisableIfPlatform : MonoBehaviour
{
	public Device[] platformsToDisableOn;

	public GameObject[] objectsToDisable;

	private void Start()
	{
		for (int i = 0; i < platformsToDisableOn.Length; i++)
		{
			if (DeviceDetection.GetDevice().Equals(platformsToDisableOn[i]))
			{
				for (int j = 0; j < objectsToDisable.Length; j++)
				{
					objectsToDisable[j].SetActive(value: false);
				}
			}
		}
	}
}
public class InputWrapperPico : InputWrapper
{
}
[CreateAssetMenu(fileName = "PicoConfig.asset", menuName = "Create Config/Pico Config")]
public class PicoConfig : DeviceConfig
{
	public override bool ShouldPause()
	{
		return false;
	}

	public override Type GetTrackerType()
	{
		if (DeviceDetection.GetDevice() == Device.Pico)
		{
			UnityEngine.Debug.Log("Initialize Dummy Tracking");
			return typeof(DummyTracking);
		}
		return base.GetTrackerType();
	}
}
public class PicoControllerConnector : MonoBehaviour
{
}
public class SetupCameraFades : MonoBehaviour
{
	public Fader fader;

	private void Start()
	{
		StartCoroutine(SetupFaders());
	}

	private IEnumerator SetupFaders()
	{
		Camera[] cameras = GetComponentsInChildren<Camera>();
		while (cameras.Length != 3)
		{
			yield return null;
			cameras = GetComponentsInChildren<Camera>();
		}
		Camera[] array = cameras;
		foreach (Camera camera in array)
		{
			if (camera.tag != "MainCamera")
			{
				Fader fader = camera.gameObject.AddComponent<Fader>();
				fader.color = this.fader.color;
				fader.fadeTime = this.fader.fadeTime;
				fader.fadeShader = this.fader.fadeShader;
			}
		}
	}
}
public class StereoCamera : MonoBehaviour
{
	public enum DisplayMode
	{
		SingleCamera,
		TwoCameras,
		SideBySide
	}

	public DisplayMode displayModeInEditor;

	public DisplayMode displayModeOnDevice = DisplayMode.TwoCameras;

	private Transform centerAnchor;

	private Transform leftAnchor;

	private Transform rightAnchor;

	private void Start()
	{
		DisplayMode displayMode = displayModeOnDevice;
		Camera[] componentsInChildren = GetComponentsInChildren<Camera>();
		Camera camera = componentsInChildren[0];
		Camera camera2 = componentsInChildren[1];
		Camera camera3 = componentsInChildren[2];
		centerAnchor = camera.transform;
		leftAnchor = camera2.transform;
		rightAnchor = camera3.transform;
		if (displayMode == DisplayMode.SideBySide)
		{
			camera2.rect = new Rect(0f, 0f, 0.5f, 1f);
			camera3.rect = new Rect(0.5f, 0f, 0.5f, 1f);
		}
		bool flag2 = (camera.enabled = displayMode == DisplayMode.SingleCamera);
		bool flag4 = (camera3.enabled = !flag2);
		camera2.enabled = flag4;
	}

	private void Update()
	{
		UpdateCamera(leftAnchor, XRNode.LeftEye);
		UpdateCamera(centerAnchor, XRNode.CenterEye);
		UpdateCamera(rightAnchor, XRNode.RightEye);
	}

	private void UpdateCamera(Transform transform, XRNode vrNode)
	{
		transform.localRotation = InputTracking.GetLocalRotation(vrNode);
		transform.localPosition = InputTracking.GetLocalPosition(vrNode);
	}
}
public class VrCameraEssentials : MonoBehaviour
{
	[Header("Oculus")]
	public bool usePerEyeCameras;

	public bool useFixedUpdateForTracking;

	private void Awake()
	{
		OVRCameraRig oVRCameraRig = base.gameObject.AddComponent<OVRCameraRig>();
		oVRCameraRig.useFixedUpdateForTracking = useFixedUpdateForTracking;
		oVRCameraRig.usePerEyeCameras = usePerEyeCameras;
	}
}
public class VrEssentials : SingletonBehavior<VrEssentials>
{
	public override void Awake()
	{
		base.Awake();
		if (!(SingletonBehavior<VrEssentials>.Instance != this))
		{
			DeviceConfig config = SingletonBehavior<DeviceConfigLoader>.Instance.GetConfig();
			GameObject prefabOfType = config.GetPrefabOfType(ConfigPrefab.Essentials);
			UnityEngine.Object.Instantiate(prefabOfType, base.transform);
			base.gameObject.AddComponent<DontDestroyOnLoad>();
		}
	}
}
public class InputWrapperWaveVR : InputWrapper
{
}
public class ViveDofSwitch : MonoBehaviour
{
}
public class ViveDRM : MonoBehaviour
{
	private static GameObject entitlementText;

	private static ViveDRM instance;
}
public class ViveSettings : MonoBehaviour
{
	public static string VIVEPORT_ID = "e5febe7a-44d7-4490-ab7e-0fdc1f625bcc";

	public static string VIVEPORT_KEY = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCW0GV49nHf0yyPPzHrY0qp8QjiRLZa6cBw0eY4v2Tt67cCF2D9ZFzdk4krcV7sNG93/XEbeoypcTTd9+H8FcmV03UjjzsLZPXQrLkojtk6+cE9eK8XAdMKboLHA37XEBbuo1YHkmXD/2TVyuzFOZ2mKJ/uwV+iV0kivH4P5ph2BwIDAQAB";
}
public class ViveUserFocusHandler : MonoBehaviour
{
	private bool CurrentPauseStatus;
}
[CreateAssetMenu(fileName = "ViveWaveConfig.asset", menuName = "Create Config/ViveWave Config")]
public class ViveWaveConfig : DeviceConfig
{
	public override Type GetTrackerType()
	{
		return typeof(DummyTracking);
	}
}
public class InputWrapperXiaomi : InputWrapper
{
}
[CreateAssetMenu(fileName = "XiaomiConfig.asset", menuName = "Create Config/Xiaomi Config")]
public class XiaomiConfig : DeviceConfig
{
	public override bool ShouldPause()
	{
		return false;
	}

	public override Type GetTrackerType()
	{
		return typeof(DummyTracking);
	}
}
public class XiaomiEntitlementCheck : MonoBehaviour
{
	private GameObject entitlementText;
}
public abstract class RGVersion
{
	public const string VERSION = "1.12.63217";
}
