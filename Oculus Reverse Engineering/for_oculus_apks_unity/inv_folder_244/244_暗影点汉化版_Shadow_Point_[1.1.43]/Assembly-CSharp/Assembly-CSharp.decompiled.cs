using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.IO.IsolatedStorage;
using System.Linq;
using System.Linq.Expressions;
using System.Net;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using System.Security;
using System.Security.Permissions;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using Coatsink;
using Coatsink.Common;
using Coatsink.Common.Events;
using FMOD;
using FMOD.Studio;
using Occlusion;
using Oculus.Platform;
using Oculus.Platform.Models;
using ProBuilder.Core;
using ROBERT;
using Sebastian.Geometry;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Jobs.LowLevel.Unsafe;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Networking;
using UnityEngine.Profiling;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;
using UnityEngine.Serialization;
using UnityEngine.UI;
using UnityEngine.XR;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: InternalsVisibleTo("HagletSupport")]
[assembly: InternalsVisibleTo("Haglet-Assembly-CSharp-02")]
[assembly: InternalsVisibleTo("Haglet-Assembly-CSharp-Editor-02")]
[assembly: InternalsVisibleTo("Assembly-CSharp-Editor")]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("0.0.0.0")]
[module: UnverifiableCode]
public class ActivateOnAnimEvent : MonoBehaviour
{
	public GameObject objectToEnable;

	private void Start()
	{
		objectToEnable.SetActive(value: false);
	}

	public void ActivateObj()
	{
		HandleObject();
	}

	public void HandleObject()
	{
		objectToEnable.SetActive(value: true);
	}
}
public class AmbiantIdleAnimation : IdleAnimation
{
	public IdleAnimationSet ambiantIdle;

	public bool startOnAwake = true;

	private System.Random random = new System.Random();

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		if (startOnAwake)
		{
			StartIdling(ambiantIdle, random);
		}
	}

	[KubrickAnimFunc(ExecuteInEditMode = true)]
	public void StartIdleKubrick()
	{
		StartIdling(ambiantIdle, random);
	}

	[KubrickAnimFunc(ExecuteInEditMode = true)]
	public void StopIdleKubrick()
	{
		StopIdling();
	}
}
public class AnimationSFX : MonoBehaviour
{
	[SerializeField]
	private Transform[] sfxSources;

	private Dictionary<string, Transform> nameToXForm;

	protected void Awake()
	{
		nameToXForm = new Dictionary<string, Transform>(sfxSources.Length);
		Transform[] array = sfxSources;
		foreach (Transform transform in array)
		{
			nameToXForm[transform.name] = transform;
		}
	}

	[KubrickAnimFunc(ExecuteInEditMode = true)]
	private void PlaySFX(FMODEventAsset sfx, string xFormName, bool track)
	{
		if (nameToXForm.TryGetValue(xFormName, out var value))
		{
			if (track)
			{
				FAC.Inst.PlayOneShot(sfx, value);
			}
			else
			{
				FAC.Inst.PlayOneShot(sfx, value.position);
			}
		}
	}

	private static float PlaySFX_GetDuration(FMODEventAsset sfx, string xFormPathOverride, bool stopPrevious)
	{
		return FACMisc.GetDuration(sfx);
	}

	private static string PlaySFX_GetDisplayName(FMODEventAsset sfx, string xFormPathOverride, bool stopPrevious)
	{
		return FACMisc.GetDisplayName(sfx);
	}

	private static void PlaySFX_Preload(FMODEventAsset sfx, string xFormPathOverride, bool stopPrevious)
	{
		FACMisc.PreloadAsset(sfx);
	}

	private static void PlaySFX_Unload(FMODEventAsset sfx, string xFormPathOverride, bool stopPrevious)
	{
		FACMisc.UnloadAsset(sfx);
	}
}
public class AnimMoveToTarget : MonoBehaviour
{
	public FMODEventAsset moveSound;

	private FMOD.Studio.EventInstance evtMove;

	private IHaglet<Vector3, float, bool> routineAnimateToTarget;

	private void Awake()
	{
		Haglet.Create(out routineAnimateToTarget, (Routine.Func3<Vector3, float, bool>)RoutineAnimateToTarget, (string)null, startNow: false, (int?)null, (string)null);
	}

	private IEnumerator<Routine.Yield> RoutineAnimateToTarget(Vector3 position, float timeMax, bool localPosition)
	{
		if (moveSound != null)
		{
			if (evtMove.isValid())
			{
				evtMove.stop(STOP_MODE.ALLOWFADEOUT);
			}
			evtMove = FAC.Inst.PlayOneShot(moveSound, base.transform);
		}
		Vector3 startPosition = (localPosition ? base.transform.localPosition : base.transform.position);
		float time = 0f;
		while (time < timeMax)
		{
			time += IC.DeltaTime;
			float t = Mathf.SmoothStep(0f, 1f, time / timeMax);
			if (localPosition)
			{
				base.transform.localPosition = Vector3.Lerp(startPosition, position, t);
			}
			else
			{
				base.transform.position = Vector3.Lerp(startPosition, position, t);
			}
			yield return Wait.For.LRUpdates(1);
		}
		evtMove.stop(STOP_MODE.ALLOWFADEOUT);
	}

	public void Animate(Vector3 position, float time, bool localRotation = false)
	{
		if (routineAnimateToTarget.started)
		{
			routineAnimateToTarget.Stop();
		}
		routineAnimateToTarget.Start(position, time, localRotation);
	}

	public Wait AnimateOnYield(Vector3 position, float time, bool localRotation = false)
	{
		if (routineAnimateToTarget.started)
		{
			routineAnimateToTarget.Stop();
		}
		return routineAnimateToTarget.Call(position, time, localRotation);
	}

	private void OnDestroy()
	{
		if (evtMove.isValid())
		{
			evtMove.stop(STOP_MODE.IMMEDIATE);
		}
	}
}
public interface IAnimNodeBehaviour
{
	void OnAwake();

	void OnBecomeCurrent(Animation animInstance, bool skipping);

	Wait OnIdle();
}
[Serializer.ExcludeAllFields]
public class AnimPath : IDObject
{
	private struct AnimationSample
	{
		public AnimationClip clip0;

		public AnimationClip clip1;

		public float weight0;

		public float weight1;

		public float animLerpTime;

		public float animClipTime0;

		public float animClipTime1;

		public bool isForcedOutClip;

		public BlendType blendType;

		public Vector3 position;

		public Quaternion rotation;
	}

	private enum BlendType
	{
		None,
		Blending
	}

	public GameObject animatedModelAsset;

	public bool instantiateObject = true;

	private AnimPathNode[] nodes;

	private AnimPathPose[] poses;

	[NonSerialized]
	[HideInInspector]
	public Animation AnimInstance;

	public bool loopPath;

	public bool startOnAwake = true;

	public HagletButton skipCurrentNode;

	public float editorPreviewTime;

	public float editorPreviewTimeMultiplier = 1f;

	[Range(0f, 0.1f)]
	public float editorPreviewSpeedScale = 0.1f;

	public bool editorPlayback;

	private Bezier[] curves;

	public FMODEventAsset soundPlayAnimation;

	[ConditionalHide("soundPlayAnimation")]
	public bool soundOneShot;

	private FMOD.Studio.EventInstance evtAnimation;

	private Dictionary<AnimationClip, string> clipNames;

	public bool allowRepositionOnStart = true;

	[ConditionalHide("allowRepositionOnStart", true)]
	public bool shouldNegateRootXForm;

	[ConditionalHide("allowRepositionOnStart", true)]
	public Transform rootXForm;

	public bool shouldSave = true;

	private IHaglet routineAnimation;

	[HideInInspector]
	public bool resuming;

	private int resumeCount;

	[Serializer.IncludeField]
	private int checkpointCount;

	public Wait OnAnimationComplete => Wait.Until.Completed(routineAnimation);

	public override void OnAwakeLR(MRBase owner)
	{
		base.OnAwakeLR(owner);
		nodes = GetComponentsInChildren<AnimPathNode>(includeInactive: true);
		UpdatePoses();
		if (nodes.Length != 0)
		{
			AnimPathNode animPathNode = nodes[0];
			GameObject gameObject = null;
			if (instantiateObject)
			{
				Vector3 position = ((allowRepositionOnStart && startOnAwake) ? animPathNode.transform.position : base.transform.position);
				if (allowRepositionOnStart && shouldNegateRootXForm)
				{
					position -= rootXForm.transform.localPosition;
				}
				Quaternion rotation = ((allowRepositionOnStart && startOnAwake) ? animPathNode.transform.rotation : base.transform.rotation);
				if (allowRepositionOnStart && shouldNegateRootXForm)
				{
					rotation *= Quaternion.Inverse(rootXForm.transform.localRotation);
				}
				gameObject = UnityEngine.Object.Instantiate(animatedModelAsset, position, rotation, base.transform);
			}
			else
			{
				gameObject = animatedModelAsset;
				if (allowRepositionOnStart)
				{
					gameObject.transform.position = animPathNode.transform.position;
					gameObject.transform.rotation = animPathNode.transform.rotation;
				}
			}
			AnimInstance = gameObject.GetComponentInChildren<Animation>();
			if (!AnimInstance)
			{
				AnimInstance = gameObject.AddComponent<Animation>();
			}
			HashSet<AnimationClip> hashSet = new HashSet<AnimationClip>();
			AnimPathPose[] array = poses;
			foreach (AnimPathPose animPathPose in array)
			{
				if ((bool)animPathPose.clip)
				{
					hashSet.Add(animPathPose.clip);
				}
			}
			AnimPathNode[] array2 = nodes;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].OnAwakeLR();
			}
			clipNames = new Dictionary<AnimationClip, string>();
			foreach (AnimationClip item in hashSet)
			{
				string text = item.name;
				clipNames.Add(item, text);
				AnimInstance.AddClip(item, text);
			}
			AnimNodesCacheStartTimes();
		}
		Haglet.Create(out routineAnimation, RoutineAnimation, null, startOnAwake);
		if (resumeCount != checkpointCount)
		{
			resuming = true;
			routineAnimation.Skip();
		}
	}

	private string GetAnimationName(AnimationClip clip)
	{
		return clipNames[clip];
	}

	public Wait StartAnimationRoutine(bool call = false)
	{
		if (routineAnimation.started)
		{
			return Wait.Until.Completed(routineAnimation);
		}
		if (call)
		{
			return routineAnimation.Call();
		}
		return routineAnimation.Start();
	}

	private IEnumerator<Routine.Yield> RoutineAnimation()
	{
		int nodeCurrentIdx = 0;
		float timeAccul = 0f;
		while (true)
		{
			AnimPathNode nodeCurrent = nodes[nodeCurrentIdx];
			Wait none = Wait.None;
			IAnimNodeBehaviour[] behavioursIdle = nodeCurrent.behavioursIdle;
			foreach (IAnimNodeBehaviour animNodeBehaviour in behavioursIdle)
			{
				none |= animNodeBehaviour.OnIdle();
			}
			yield return none;
			for (int j = 0; j < nodeCurrent.behavioursIdle.Length; j++)
			{
				nodeCurrent.behavioursIdle[j].OnBecomeCurrent(AnimInstance, Routine.Skipping);
			}
			if ((bool)soundPlayAnimation)
			{
				evtAnimation = FAC.Inst.PlayOneShot(soundPlayAnimation, AnimInstance.transform);
			}
			if (nodeCurrentIdx + 1 >= nodes.Length)
			{
				if (Routine.Skipping || !loopPath)
				{
					break;
				}
				nodeCurrentIdx = 0;
				timeAccul = 0f;
			}
			if (nodeCurrent.shouldSave)
			{
				yield return CHECKPOINT();
			}
			AnimPathNode animPathNode = nodes[nodeCurrentIdx + 1];
			AnimInstance.Stop();
			float time = 0f;
			float timeMax = GetAnimLengthOfNode(nodeCurrentIdx);
			float timeStart = timeAccul;
			timeAccul += timeMax;
			_ = timeAccul;
			if ((bool)animPathNode && animPathNode.shouldSetPosition && !Routine.Skipping)
			{
				for (; time <= timeMax; time += IC.DeltaTime * editorPreviewTimeMultiplier)
				{
					AnimationSample animationSample = Sample(timeStart + time, HACK_forDrawingCurve: false);
					if ((bool)animationSample.clip0)
					{
						AnimationState animationState = AnimInstance[GetAnimationName(animationSample.clip0)];
						animationState.enabled = true;
						animationState.weight = animationSample.weight0;
						animationState.time = animationSample.animClipTime0;
						animationState.speed = 0f;
						if ((bool)animationSample.clip1)
						{
							AnimationState animationState2 = AnimInstance[GetAnimationName(animationSample.clip1)];
							animationState2.enabled = true;
							animationState2.weight = animationSample.weight1;
							animationState2.time = animationSample.animClipTime1;
							animationState2.speed = 0f;
						}
					}
					AnimInstance.transform.position = animationSample.position;
					AnimInstance.transform.rotation = animationSample.rotation;
					yield return Wait.For.LRUpdates(1);
				}
			}
			nodeCurrentIdx++;
		}
		if ((bool)soundPlayAnimation && !soundOneShot)
		{
			evtAnimation.stop(STOP_MODE.ALLOWFADEOUT);
		}
		if (shouldSave)
		{
			yield return CHECKPOINT();
		}
		AnimInstance.gameObject.SetActive(value: false);
	}

	public Routine.Yield CHECKPOINT()
	{
		if (resuming)
		{
			UnityEngine.Debug.LogFormat("[SAVE] [RESUME] {1} CheckPoint ({0})", resumeCount, GetType());
			resumeCount++;
			if (resumeCount == checkpointCount)
			{
				UnityEngine.Debug.LogFormat("[SAVE] [RESUME] {1} Stopping ({0})", resumeCount, GetType());
				resuming = false;
				return Routine.Yield.SpecialIndex.StopCallStackSkipping;
			}
			return Wait.None;
		}
		checkpointCount++;
		UnityEngine.Debug.LogFormat("[SAVE] [CHECKPOINT] {1} CheckPoint ({0})", checkpointCount, GetType());
		return Routine.Yield.SpecialIndex.StopCallStackSkipping;
	}

	public Vector3 GetStartNodePosition()
	{
		return nodes[0].transform.position;
	}

	public Quaternion GetStartNodeRotation()
	{
		return nodes[0].transform.rotation;
	}

	private float GetAnimLengthOfNode(int node0Idx)
	{
		if (curves != null && node0Idx < curves.Length && curves[node0Idx] != null)
		{
			return curves[node0Idx].TotalLength;
		}
		return 0f;
	}

	public void UpdatePoses()
	{
		poses = GetComponentsInChildren<AnimPathPose>();
		Array.Sort(poses, (AnimPathPose lhs, AnimPathPose rhs) => lhs.time.CompareTo(rhs.time));
		for (int i = 0; i < poses.Length; i++)
		{
			AnimPathPose animPathPose = poses[i];
			AnimationSample animationSample = Sample(animPathPose.time, HACK_forDrawingCurve: true);
			animPathPose.transform.position = animationSample.position;
			animPathPose.transform.rotation = animationSample.rotation;
			animPathPose.transform.localScale = Vector3.one;
		}
	}

	private void SampleBetweenNodes(ref AnimationSample sample, AnimPathNode node0, AnimPathNode node1, float timeStart, float timeEnd, float time, int startNodeIdx)
	{
		int num = 0;
		for (int i = 1; i < poses.Length; i++)
		{
			AnimPathPose animPathPose = poses[num];
			AnimPathPose animPathPose2 = poses[i];
			if (time >= animPathPose.time && time < animPathPose2.time)
			{
				sample.animClipTime0 = time - animPathPose.time;
				sample.clip0 = animPathPose.clip;
				if ((bool)sample.clip0)
				{
					sample.animClipTime0 = sample.animClipTime0.Wrap(sample.clip0.length);
				}
				float num2 = animPathPose2.time - animPathPose2.blendTime;
				float time2 = animPathPose2.time;
				if (time > num2)
				{
					sample.clip1 = animPathPose2.clip;
					sample.blendType = BlendType.Blending;
					sample.weight1 = Mathf.InverseLerp(num2, time2, time);
					sample.weight0 = 1f - sample.weight1;
					sample.animClipTime1 = time - num2 - animPathPose2.blendTime;
					if ((bool)sample.clip1)
					{
						sample.animClipTime1 = sample.animClipTime1.Wrap(sample.clip1.length);
					}
				}
				else
				{
					sample.blendType = BlendType.None;
					sample.weight0 = 1f;
					sample.weight1 = 0f;
				}
				break;
			}
			num++;
		}
		sample.animLerpTime = Mathf.InverseLerp(timeStart, timeEnd, time);
		sample.position = curves[startNodeIdx].MappedSample(sample.animLerpTime);
		Transform transform = node0.transform;
		Transform transform2 = node1.transform;
		float t = node0.rotationCurve.Evaluate(Mathf.SmoothStep(0f, 1f, sample.animLerpTime));
		sample.rotation = Quaternion.Lerp(transform.rotation, transform2.rotation, t);
	}

	private float GetAnimationLength()
	{
		if (ArrayX.IsNullOrEmpty(nodes))
		{
			return 0f;
		}
		float num = 0f;
		int num2 = 0;
		for (int i = 1; i < nodes.Length; i++)
		{
			num += GetAnimLengthOfNode(num2);
			num2++;
		}
		return num;
	}

	private void AnimNodesCacheStartTimes()
	{
		curves = new Bezier[nodes.Length - 1];
		float num = 0f;
		int num2 = 0;
		for (int i = 1; i < nodes.Length; i++)
		{
			AnimPathNode animPathNode = nodes[num2];
			AnimPathNode animPathNode2 = nodes[i];
			curves[num2] = new Bezier(animPathNode.transform.position, animPathNode.ControlPos1, animPathNode2.ControlPos0, animPathNode2.transform.position, animPathNode.speed, animPathNode2.speed, animPathNode2.speedCurve);
			animPathNode.timeDurationCached = GetAnimLengthOfNode(num2);
			num = (animPathNode2.timeStartCached = num + animPathNode.timeDurationCached);
			num2++;
		}
	}

	private float GetAnimNodeStartTime(AnimPathNode searchNode)
	{
		return searchNode.timeStartCached;
	}

	private AnimationSample Sample(float time, bool HACK_forDrawingCurve)
	{
		AnimationSample sample = default(AnimationSample);
		bool flag = false;
		float num = 0f;
		int num2 = 0;
		for (int i = 1; i < nodes.Length; i++)
		{
			AnimPathNode animPathNode = nodes[num2];
			AnimPathNode node = nodes[i];
			float num3 = num;
			num += animPathNode.timeDurationCached;
			float num4 = num;
			if (time >= num3 && time < num4)
			{
				flag = true;
				SampleBetweenNodes(ref sample, animPathNode, node, num3, num4, time, num2);
				break;
			}
			num2++;
		}
		if (!flag)
		{
			int num5 = nodes.Length - 1;
			AnimPathNode animPathNode2 = nodes[num5];
			sample.position = animPathNode2.transform.position;
			sample.rotation = animPathNode2.transform.rotation;
			sample.animClipTime0 = 0f;
		}
		return sample;
	}
}
public class AnimPathFinlayClifftopsA : MonoBehaviour, IAnimNodeBehaviour
{
	public AnimPath animPath;

	public FrustumDetector3D perchedFinlayFrustum;

	public PuzzleInfo[] puzzlesToComplete;

	public PlayerAreaTrigger finlayAreaTrigger;

	public string preFlightIdleAnim;

	public string flightAnim;

	public float flightAnimBlendTime;

	private IHaglet logicRoutine;

	void IAnimNodeBehaviour.OnAwake()
	{
		Haglet.Create(out logicRoutine, LogicRoutine);
	}

	void IAnimNodeBehaviour.OnBecomeCurrent(Animation animInstance, bool skipping)
	{
	}

	Wait IAnimNodeBehaviour.OnIdle()
	{
		return logicRoutine.Call();
	}

	private IEnumerator<Routine.Yield> LogicRoutine()
	{
		Animation finlay = animPath.AnimInstance;
		finlay.gameObject.SetActive(value: false);
		yield return perchedFinlayFrustum.IsNotInView;
		AmbiantIdleAnimation aia = finlay.GetComponent<AmbiantIdleAnimation>();
		aia.StartIdleKubrick();
		finlay.gameObject.SetActive(value: true);
		finlay.transform.position = Vector3.zero;
		finlay.transform.rotation = Quaternion.identity;
		yield return WaitForPuzzles(puzzlesToComplete);
		aia.StopIdleKubrick();
		yield return perchedFinlayFrustum.IsNotInView;
		finlay.transform.position = new Vector3(-300f, 0f, 200f);
		HAGIS.PlayAnim(finlay, preFlightIdleAnim);
		yield return finlayAreaTrigger.OnInsidePremet;
		yield return HAGIS.PlayAnim(animPath.AnimInstance, flightAnim, flightAnimBlendTime);
	}

	protected Wait WaitForPuzzle(PuzzleInfo info)
	{
		return info.UntilComplete(SaveDataGame.PuzzleSaveType.Scene);
	}

	protected Wait WaitForPuzzles(PuzzleInfo[] infos)
	{
		Wait none = Wait.None;
		for (int i = 0; i < infos.Length; i++)
		{
			none &= WaitForPuzzle(infos[i]);
		}
		return none;
	}
}
public class AnimPathNode : MonoBehaviour
{
	public float speed = 1f;

	public IAnimNodeBehaviour[] behavioursIdle;

	public bool forceCompletionOfOutAnimation;

	public bool lockTangents;

	public AnimationCurve speedCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public AnimationCurve rotationCurve;

	public bool shouldSetPosition = true;

	[NonSerialized]
	[HideInInspector]
	public float timeStartCached;

	[NonSerialized]
	[HideInInspector]
	public float timeDurationCached;

	public bool shouldSave;

	[HideInInspector]
	[SerializeField]
	private Vector3 controlPos0;

	[HideInInspector]
	[SerializeField]
	private Vector3 controlPos1;

	public Vector3 ControlPos0
	{
		get
		{
			return base.transform.position + controlPos0;
		}
		set
		{
			controlPos0 = value - base.transform.position;
		}
	}

	public Vector3 ControlPos1
	{
		get
		{
			return base.transform.position + controlPos1;
		}
		set
		{
			controlPos1 = value - base.transform.position;
		}
	}

	public void OnAwakeLR()
	{
		behavioursIdle = GetComponentsInChildren<IAnimNodeBehaviour>();
		IAnimNodeBehaviour[] array = behavioursIdle;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].OnAwake();
		}
	}
}
public class AnimPathNodeBehaviourFinlayPetting : MonoBehaviour, IAnimNodeBehaviour, IUpdateEvent
{
	[Serializable]
	private class BonePair
	{
		public string boneName_A;

		public string boneName_B;

		[NonSerialized]
		public Transform boneXForm_A;

		[NonSerialized]
		public Transform boneXForm_B;
	}

	[Serializable]
	private class AnimState
	{
		public BonePair[] bonePairs;

		public string animationName;

		public float animationBlendTime = 0.2f;

		public FMODEventAsset sfx;

		public float enterStateDist = 0.05f;

		public float exitStateDist = 0.1f;

		public float GetClosestPointDist(Vector3 worldPos)
		{
			float num = float.MaxValue;
			BonePair[] array = bonePairs;
			foreach (BonePair bonePair in array)
			{
				Vector3 vector = MathfX.ClosestPointLineSegment(worldPos, bonePair.boneXForm_A.position, bonePair.boneXForm_B.position);
				float sqrMagnitude = (worldPos - vector).sqrMagnitude;
				if (sqrMagnitude < num)
				{
					num = sqrMagnitude;
				}
			}
			return num;
		}
	}

	[Header("Anim Path")]
	public AnimPath path;

	[Header("Idle Animations")]
	public string idleAnim = "CH_Finlay_PetIdle";

	public string idleAltAnim = "CH_Finlay_PetIdleAlt";

	public float idleAltBlend = 0.2f;

	[Tooltip("X - min time, Y - max time ()")]
	public Vector2 idleAltTriggerTime;

	[Header("Max Interactions & Exit Animations")]
	[Tooltip("Finlay will fly away after this many interactions (Default = -1 (Never fly away)")]
	public int maxInteractions = -1;

	public string exitAnimationName = "";

	public float exitAnimationBlend = 0.2f;

	[Header("Mimic Reference for ALT scenes")]
	public IDObjectRef mimicRef;

	public string sfxSourceBoneName = "Ref_Jnt_Head_01";

	public FMODEventAsset sfxLoopAsset;

	[SerializeField]
	[Header("Pet Animation States")]
	private AnimState[] animStates = new AnimState[0];

	private int currentInteractionCount;

	private AnimPathNode node;

	private AnimPathNodeBehaviourFinlayPetting _mimic;

	private ParticlePrefab pettingParticle;

	private AnimState currentAnimState;

	private float idleBlendTime;

	private HagletValue<bool> isPetting;

	private System.Random random;

	private float currPettingDuration;

	private float currIdleDuration;

	private Transform sfxSourceXForm;

	private FMOD.Studio.EventInstance eventInst;

	private IHaglet idleRoutine;

	private IHaglet pettingRoutine;

	private AnimPathNodeBehaviourFinlayPetting Mimic
	{
		get
		{
			if (_mimic == null)
			{
				mimicRef.TryGet<IDObject>(out var value);
				_mimic = value?.GetComponent<AnimPathNodeBehaviourFinlayPetting>();
			}
			return _mimic;
		}
	}

	public void Start()
	{
	}

	void IAnimNodeBehaviour.OnAwake()
	{
		Haglet.Create(out idleRoutine, IdleRoutine);
		Haglet.Create(out pettingRoutine, PettingRoutine);
		HagletValue.Create(out isPetting, null, initVal: false, null, 8);
		node = GetComponent<AnimPathNode>();
		AnimState[] array = animStates;
		foreach (AnimState animState in array)
		{
			for (int j = 0; j < animState.bonePairs.Length; j++)
			{
				BonePair bonePair = animState.bonePairs[j];
				if (!string.IsNullOrWhiteSpace(bonePair.boneName_A) && !string.IsNullOrWhiteSpace(bonePair.boneName_B))
				{
					bonePair.boneXForm_A = path.transform.FindDeepChild(bonePair.boneName_A);
					bonePair.boneXForm_B = path.transform.FindDeepChild(bonePair.boneName_B);
				}
			}
		}
		path.AnimInstance[idleAnim].wrapMode = WrapMode.Loop;
		path.AnimInstance[idleAltAnim].wrapMode = WrapMode.Once;
		sfxSourceXForm = path.transform.FindDeepChild(sfxSourceBoneName);
		int seed = UnityEngine.Random.Range(0, int.MaxValue);
		random = new System.Random(seed);
		AnimPathNodeBehaviourFinlayPetting mimic = Mimic;
		if (mimic != null)
		{
			mimic.random = new System.Random(seed);
		}
		base.enabled = false;
	}

	void IAnimNodeBehaviour.OnBecomeCurrent(Animation animInstance, bool skipping)
	{
	}

	Wait IAnimNodeBehaviour.OnIdle()
	{
		base.enabled = true;
		idleRoutine.Start();
		return pettingRoutine.Start();
	}

	void IUpdateEvent.OnUpdateLR()
	{
		Transform transform = CC.Inst.handL.transform;
		Transform obj = CC.Inst.handR.transform;
		Vector3 position = transform.position;
		Vector3 position2 = obj.position;
		AnimPathNodeBehaviourFinlayPetting mimic = Mimic;
		if (isPetting.value)
		{
			currPettingDuration += IC.DeltaTime;
		}
		else
		{
			currIdleDuration += IC.DeltaTime;
		}
		if (isPetting.value && currentAnimState != null)
		{
			float closestPointDist = currentAnimState.GetClosestPointDist(position);
			float closestPointDist2 = currentAnimState.GetClosestPointDist(position2);
			if (((closestPointDist < closestPointDist2) ? closestPointDist : closestPointDist2) > currentAnimState.exitStateDist)
			{
				idleBlendTime = currentAnimState.animationBlendTime;
				if (mimic != null)
				{
					mimic.idleBlendTime = currentAnimState.animationBlendTime;
				}
				currentAnimState = null;
			}
		}
		if (!isPetting.value)
		{
			float num = float.MaxValue;
			AnimState animState = null;
			AnimState[] array = animStates;
			foreach (AnimState animState2 in array)
			{
				float closestPointDist3 = animState2.GetClosestPointDist(position);
				float closestPointDist4 = animState2.GetClosestPointDist(position2);
				float num2 = ((closestPointDist3 < closestPointDist4) ? closestPointDist3 : closestPointDist4);
				if (num2 < animState2.enterStateDist && num2 < num)
				{
					num = num2;
					animState = animState2;
				}
			}
			if (animState != null)
			{
				currentAnimState = animState;
			}
		}
		bool flag = currentAnimState != null;
		if ((bool)mimic)
		{
			flag |= mimic.currentAnimState != null;
		}
		SetIsPetting(flag, mimic);
		if (currIdleDuration > 1f && eventInst.isValid())
		{
			eventInst.stop(STOP_MODE.ALLOWFADEOUT);
		}
		if (!isPetting.value && currIdleDuration > 1f && maxInteractions != -1 && currentInteractionCount >= maxInteractions)
		{
			pettingRoutine.Stop();
			idleRoutine.Stop();
			base.enabled = false;
			if (!string.IsNullOrEmpty(exitAnimationName))
			{
				path.AnimInstance.CrossFade(exitAnimationName, exitAnimationBlend);
			}
		}
	}

	private void SetIsPetting(bool isCurrentlyPetting, AnimPathNodeBehaviourFinlayPetting mimic)
	{
		if (isCurrentlyPetting == isPetting.value)
		{
			return;
		}
		if (isCurrentlyPetting && currIdleDuration > 1f)
		{
			currentInteractionCount++;
			if (sfxLoopAsset != null)
			{
				eventInst = FAC.Inst.PlayOneShot(sfxLoopAsset, sfxSourceXForm);
			}
		}
		currPettingDuration = 0f;
		currIdleDuration = 0f;
		isPetting.value = isCurrentlyPetting;
		if (mimic != null)
		{
			mimic.currentInteractionCount = currentInteractionCount;
			mimic.currIdleDuration = currIdleDuration;
			mimic.currPettingDuration = currPettingDuration;
			if (mimic.isPetting != null)
			{
				mimic.isPetting.value = isCurrentlyPetting;
			}
		}
	}

	private IEnumerator<Routine.Yield> IdleRoutine()
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		currIdleDuration = 0f;
		while (true)
		{
			yield return Wait.Until.False(isPetting, 1, allowPreMetNow: true);
			bool playAlt = false;
			while (!isPetting.value)
			{
				if (playAlt)
				{
					path.AnimInstance.CrossFade(idleAltAnim, idleBlendTime);
				}
				else
				{
					path.AnimInstance.CrossFade(idleAnim, idleBlendTime);
				}
				idleBlendTime = idleAltBlend;
				float seconds = (playAlt ? path.AnimInstance[idleAltAnim].length : ((float)random.NextDouble(idleAltTriggerTime.x, idleAltTriggerTime.y)));
				yield return Wait.Until.True(isPetting) | Wait.For.Seconds(seconds);
				playAlt = !playAlt;
			}
		}
	}

	private IEnumerator<Routine.Yield> PettingRoutine()
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		currPettingDuration = 0f;
		AnimPathNodeBehaviourFinlayPetting mimic = Mimic;
		while (true)
		{
			yield return Wait.Until.True(isPetting, 1, allowPreMetNow: true);
			AnimState animState = ((currentAnimState != null) ? currentAnimState : mimic.currentAnimState);
			path.AnimInstance.CrossFade(animState.animationName, animState.animationBlendTime);
			FAC.Inst.PlayOneShot(animState.sfx, sfxSourceXForm);
			yield return Wait.Until.False(isPetting);
		}
	}
}
public class AnimPathNodeBehaviourPetAndThrow : MonoBehaviour, IAnimNodeBehaviour, ICutsceneEvent
{
	[Serializable]
	private struct PetAnims
	{
		public Trigger trigger;

		public string animation;

		public float blendTime;

		public float blendOut;

		public string soundEffect;

		public string attachedToJoint;
	}

	public AnimPath path;

	public string petAnimIdle = "CH_Finlay_PetIdle";

	[SerializeField]
	[Space(10f)]
	private PetAnims[] petAnims = new PetAnims[0];

	public bool neverFly;

	public int flyAwayInteractNum = 5;

	private int interactNum;

	private AnimPathNode node;

	public string flyAnim = "CH_Finlay_WorkshopA_Exit";

	public float flyBlend = 0.2f;

	private bool voPlayed;

	private bool inCutscene;

	private bool flownAway;

	public string idleAlt;

	public float altBlend = 0.2f;

	public Vector2 altTime = new Vector2(8f, 12f);

	public IDObjectRef mimicRef;

	private AnimPathNodeBehaviourPetAndThrow _mimic;

	private bool parentedTriggersToJoints;

	private PetAnims currentPetAnim;

	private bool blendOut;

	private ParticlePrefab pettingParticle;

	private IHaglet throwAndPetRoutine;

	private IHaglet idleRoutine;

	public bool HasFlownAway => flownAway;

	private AnimPathNodeBehaviourPetAndThrow Mimic
	{
		get
		{
			if (_mimic == null)
			{
				mimicRef.TryGet<IDObject>(out var value);
				_mimic = value?.GetComponent<AnimPathNodeBehaviourPetAndThrow>();
			}
			return _mimic;
		}
	}

	public void Start()
	{
	}

	public void OnAwake()
	{
		Haglet.Create(out throwAndPetRoutine, ThrowAndPetRoutine);
		Haglet.Create(out idleRoutine, IdleRoutine);
		node = GetComponent<AnimPathNode>();
	}

	public void OnBecomeCurrent(Animation animInstance, bool skipping)
	{
	}

	public Wait OnIdle()
	{
		return throwAndPetRoutine.Start();
	}

	public Wait WaitUntilGone()
	{
		return Wait.Until.Completed(throwAndPetRoutine);
	}

	private IEnumerator<Routine.Yield> ThrowAndPetRoutine()
	{
		idleRoutine.Start();
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		idleRoutine.Stop();
		while ((interactNum < flyAwayInteractNum || neverFly) && !Routine.Skipping)
		{
			bool flag = false;
			for (int i = 0; i < petAnims.Length; i++)
			{
				flag |= petAnims[i].trigger.IsInsideBool;
			}
			if (!flag)
			{
				idleRoutine.Start();
				Wait wait = IsAllTriggersOutsidePremet();
				yield return wait;
				Wait wait2 = IsAnyTriggerInsidePremet();
				yield return wait2;
				idleRoutine.Stop();
			}
			yield return Wait.For.LRUpdates(1);
			if (GetTriggeredAnimationState(out var petAnim))
			{
				currentPetAnim = petAnim;
				blendOut = true;
				FMOD.Studio.EventInstance eventInst = default(FMOD.Studio.EventInstance);
				if (!pettingParticle && (currentPetAnim.animation == "CH_Finlay_PetLeft" || currentPetAnim.animation == "CH_Finlay_PetRight"))
				{
					pettingParticle = PSC.Inst.PlayAt(ParticleType.Finlay_Feathers, currentPetAnim.trigger.transform.position);
				}
				if (!string.IsNullOrEmpty(currentPetAnim.soundEffect))
				{
					eventInst = FAC.Inst.PlayOneShot(currentPetAnim.soundEffect, base.transform);
				}
				HAGIS.PlayAnim(path.AnimInstance, currentPetAnim.animation, currentPetAnim.blendTime);
				yield return currentPetAnim.trigger.OnOutisePremet;
				if (eventInst.isValid())
				{
					eventInst.stop(STOP_MODE.ALLOWFADEOUT);
				}
				if ((bool)pettingParticle)
				{
					pettingParticle.gameObject.SetActive(value: false);
					pettingParticle = null;
				}
				interactNum++;
			}
		}
		if (string.IsNullOrEmpty(flyAnim))
		{
			yield return HAGIS.PlayAnim(path.AnimInstance, "CH_Finlay_WorkshopA_Exit", flyBlend);
		}
		else
		{
			yield return HAGIS.PlayAnim(path.AnimInstance, flyAnim, flyBlend);
		}
		flownAway = true;
	}

	private Wait IsAllTriggersOutsidePremet()
	{
		Wait none = Wait.None;
		for (int i = 0; i < petAnims.Length; i++)
		{
			none &= petAnims[i].trigger.OnOutisePremet;
		}
		if ((bool)Mimic)
		{
			for (int j = 0; j < Mimic.petAnims.Length; j++)
			{
				none &= Mimic.petAnims[j].trigger.OnOutisePremet;
			}
		}
		return none;
	}

	private Wait IsAnyTriggerInsidePremet()
	{
		Wait none = Wait.None;
		for (int i = 0; i < petAnims.Length; i++)
		{
			none |= petAnims[i].trigger.OnInsidePremet;
		}
		if ((bool)Mimic)
		{
			for (int j = 0; j < Mimic.petAnims.Length; j++)
			{
				none |= Mimic.petAnims[j].trigger.OnInsidePremet;
			}
		}
		return none;
	}

	private bool GetTriggeredAnimationState(out PetAnims petAnim)
	{
		petAnim = default(PetAnims);
		for (int i = 0; i < petAnims.Length; i++)
		{
			if (petAnims[i].trigger.IsInsideBool)
			{
				petAnim = petAnims[i];
				return true;
			}
		}
		if ((bool)Mimic)
		{
			for (int j = 0; j < Mimic.petAnims.Length; j++)
			{
				if (Mimic.petAnims[j].trigger.IsInsideBool)
				{
					petAnim = Mimic.petAnims[j];
					return true;
				}
			}
		}
		return false;
	}

	public void OnCutsceneBegin()
	{
		inCutscene = true;
	}

	public void OnCutsceneEnd()
	{
		inCutscene = false;
	}

	private IEnumerator<Routine.Yield> IdleRoutine()
	{
		float blendTime = (blendOut ? currentPetAnim.blendOut : altBlend);
		yield return HAGIS.PlayAnim(path.AnimInstance, petAnimIdle, blendTime);
		blendOut = false;
		if (!parentedTriggersToJoints)
		{
			for (int i = 0; i < petAnims.Length; i++)
			{
				if (!string.IsNullOrEmpty(petAnims[i].attachedToJoint))
				{
					Trigger trigger = petAnims[i].trigger;
					Transform transform = path.AnimInstance.transform.FindDeepChild(petAnims[i].attachedToJoint);
					if ((bool)transform)
					{
						trigger.transform.SetParent(transform, worldPositionStays: false);
					}
				}
			}
			parentedTriggersToJoints = true;
		}
		if (string.IsNullOrEmpty(idleAlt))
		{
			yield break;
		}
		while (true)
		{
			float wait = UnityEngine.Random.Range(altTime.x, altTime.y);
			float startTime;
			for (float time = 0f; time < wait; time += IC.Time - startTime)
			{
				startTime = IC.Time;
				yield return HAGIS.PlayAnim(path.AnimInstance, petAnimIdle, altBlend);
			}
			yield return HAGIS.PlayAnim(path.AnimInstance, idleAlt, altBlend);
		}
	}
}
public class AnimPathNodeBehaviourThrowTrigger : MonoBehaviour, IAnimNodeBehaviour
{
	private Trigger trigger;

	void IAnimNodeBehaviour.OnAwake()
	{
		trigger = GetComponent<Trigger>();
	}

	void IAnimNodeBehaviour.OnBecomeCurrent(Animation animInstance, bool skipping)
	{
	}

	Wait IAnimNodeBehaviour.OnIdle()
	{
		return trigger.OnInsidePremet;
	}
}
public class AnimPathNodeBehaviourTimer : MonoBehaviour, IAnimNodeBehaviour
{
	public float seconds;

	void IAnimNodeBehaviour.OnAwake()
	{
	}

	void IAnimNodeBehaviour.OnBecomeCurrent(Animation animInstance, bool skipping)
	{
	}

	Wait IAnimNodeBehaviour.OnIdle()
	{
		return Wait.For.Seconds(seconds);
	}
}
public class AnimPathNodeEventSound : MonoBehaviour, IAnimNodeBehaviour
{
	public FMODEventAsset soundPlayAnimation;

	public void OnAwake()
	{
	}

	public void OnBecomeCurrent(Animation animInstance, bool skipping = false)
	{
		if (!skipping)
		{
			FAC.Inst.PlayOneShot(soundPlayAnimation, animInstance.transform);
		}
	}

	public Wait OnIdle()
	{
		return Wait.None;
	}
}
public class AnimPathNodeThrowTrigger : MonoBehaviour, IAnimNodeBehaviour
{
	private Trigger trigger;

	public float timeout;

	void IAnimNodeBehaviour.OnAwake()
	{
		trigger = GetComponent<Trigger>();
	}

	void IAnimNodeBehaviour.OnBecomeCurrent(Animation animInstance, bool skipping)
	{
	}

	Wait IAnimNodeBehaviour.OnIdle()
	{
		if (timeout > 0f)
		{
			return Wait.For.Seconds(timeout) | trigger.OnInsidePremet;
		}
		return trigger.OnInsidePremet;
	}
}
public class AnimPathNodeTrigger : MonoBehaviour, IAnimNodeBehaviour
{
	public Trigger trigger;

	public void OnAwake()
	{
	}

	public void OnBecomeCurrent(Animation animInstance, bool skipping)
	{
	}

	public Wait OnIdle()
	{
		if ((bool)trigger)
		{
			return trigger.OnInsidePremet;
		}
		return Wait.None;
	}
}
public class AnimPathPose : MonoBehaviour
{
	public AnimationClip clip;

	public float time;

	[Range(0f, 0.5f)]
	public float blendTime = 0.2f;

	private void OnValidate()
	{
		if (time < 0f)
		{
			time = 0f;
		}
	}
}
public class AnimRotateToTarget : MonoBehaviour, IAwakeEvent
{
	public AnimationCurve animationCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public FMODEventAsset soundRotate;

	private const float SOUND_DEGREE_OFFSET = 30f;

	private IHaglet<Quaternion, float, bool> routineAnimateToTarget;

	public void OnAwakeLR(MRBase owner)
	{
		Haglet.Create(out routineAnimateToTarget, (Routine.Func3<Quaternion, float, bool>)RoutineAnimateToTarget, (string)null, startNow: false, (int?)null, (string)null);
	}

	public void SetRotateSound(FMODEventAsset newSoundRotate)
	{
		soundRotate = newSoundRotate;
	}

	private IEnumerator<Routine.Yield> RoutineAnimateToTarget(Quaternion rotation, float timeMax, bool localRotation)
	{
		Quaternion startRotation = (localRotation ? base.transform.localRotation : base.transform.rotation);
		float time = 0f;
		while (time < timeMax && !Routine.Skipping)
		{
			time += IC.DeltaTime;
			float t = animationCurve.Evaluate(time / timeMax);
			if (localRotation)
			{
				base.transform.localRotation = Quaternion.SlerpUnclamped(startRotation, rotation, t);
			}
			else
			{
				base.transform.rotation = Quaternion.SlerpUnclamped(startRotation, rotation, t);
			}
			yield return Wait.For.LRUpdates(1);
		}
		if (localRotation)
		{
			base.transform.localRotation = rotation;
		}
		else
		{
			base.transform.rotation = rotation;
		}
	}

	public void Animate(Quaternion rotation, float time, bool localRotation = false)
	{
		if (routineAnimateToTarget.started)
		{
			routineAnimateToTarget.Stop();
		}
		routineAnimateToTarget.Start(rotation, time, localRotation);
	}

	public Wait AnimateOnYield(Quaternion rotation, float time, bool localRotation = false, bool skipping = false)
	{
		if (routineAnimateToTarget.started)
		{
			routineAnimateToTarget.Stop();
		}
		return routineAnimateToTarget.Call(rotation, time, localRotation, 1, reset: true, skipping);
	}
}
public class AnimRotation : MonoBehaviour
{
	public Vector3 rotation;

	private void Update()
	{
		base.transform.Rotate(rotation * IC.DeltaTime, Space.Self);
	}
}
public class AnimTranslate : MonoBehaviour, IUpdateEvent
{
	public Vector3 translate;

	public void OnUpdateLR()
	{
		base.transform.Translate(translate * IC.DeltaTime, Space.Self);
	}
}
[Serializable]
public class Bezier
{
	[SerializeField]
	[HideInInspector]
	private Vector3 p0;

	[SerializeField]
	[HideInInspector]
	private Vector3 p1;

	[SerializeField]
	[HideInInspector]
	private Vector3 p2;

	[SerializeField]
	[HideInInspector]
	private Vector3 p3;

	[SerializeField]
	[HideInInspector]
	private int samples = 100;

	[SerializeField]
	[HideInInspector]
	private float speed0;

	[SerializeField]
	[HideInInspector]
	private float speed1;

	[SerializeField]
	[HideInInspector]
	private AnimationCurve speedCurve;

	[NonSerialized]
	[HideInInspector]
	public float TotalLength;

	[SerializeField]
	[HideInInspector]
	private float[] arcLengths;

	public Bezier(Vector3 point0, Vector3 point1, Vector3 point2, Vector3 point3, float speed0 = 1f, float speed1 = 1f, AnimationCurve speedCurve = null)
	{
		p0 = point0;
		p1 = point1;
		p2 = point2;
		p3 = point3;
		arcLengths = new float[samples + 1];
		arcLengths[0] = 0f;
		this.speed0 = speed0;
		this.speed1 = speed1;
		this.speedCurve = speedCurve;
		RecalculateLengths();
	}

	public void RecalculateLengths()
	{
		Vector3 vector = Sample(0f);
		float num = 0f;
		for (int i = 1; i < arcLengths.Length; i++)
		{
			float num2 = (float)i / (float)samples;
			Vector3 vector2 = Sample(num2);
			float magnitude = (vector2 - vector).magnitude;
			float num3 = ((speedCurve != null) ? speedCurve.Evaluate(num2) : num2);
			magnitude /= speed0 + num3 * (speed1 - speed0);
			num += magnitude;
			arcLengths[i] = num;
			vector = vector2;
		}
		TotalLength = num;
	}

	private float Map(float time)
	{
		if (time == 0f)
		{
			return 0f;
		}
		float num = time * arcLengths[samples];
		int num2 = 0;
		int num3 = samples;
		int num4 = 0;
		while (num2 < num3)
		{
			num4 = num2 + (num3 - num2) / 2;
			if (arcLengths[num4] < num)
			{
				num2 = num4 + 1;
			}
			else
			{
				num3 = num4;
			}
		}
		if (arcLengths[num4] > num)
		{
			num4--;
		}
		float num5 = arcLengths[num4];
		if (num5 == num)
		{
			return (float)num4 / num;
		}
		return ((float)num4 + (num - num5) / (arcLengths[num4 + 1] - num5)) / (float)samples;
	}

	public Vector3 Sample(float time)
	{
		return VectorX.BezierCurve(p0, p1, p2, p3, time);
	}

	public Vector3 MappedSample(float time)
	{
		float num = Map(time);
		if (float.IsNaN(num))
		{
			UnityEngine.Debug.Log($"Mapped time for {time} is NaN");
		}
		return Sample(num);
	}
}
[ExecuteInEditMode]
public class CharacterLookAt : MonoBehaviour, IAwakeEvent, ILateUpdateEvent
{
	private class LookAtContainer
	{
		public Transform groupRoot;

		public Transform jointRoot;

		public Vector3 Constraints;

		public bool flipForward;

		public VectorAnimator currentWeight;

		public Vector3 weight;
	}

	private struct LookAxis
	{
		public Vector3 right;

		public Vector3 up;

		public Vector3 forward;
	}

	public Transform neckRoot;

	public Transform headRoot;

	public Transform leftEyeRoot;

	public Transform rightEyeRoot;

	public CharacterLookAtSettings animationSettings;

	private List<LookAtContainer> lookAtGroups;

	private float lookAtSpeed;

	public bool animateLookAtOutIfCantSeePlayer;

	private Quaternion rightToForwardCorrection = Quaternion.FromToRotation(Vector3X.right, Vector3X.forward);

	private Quaternion flippedRightToForwardCorrection = Quaternion.FromToRotation(Vector3X.right, Vector3X.forward) * Quaternion.Euler(0f, 180f, 0f);

	private readonly Vector3 yRot180Vec = new Vector3(0f, 180f, 0f);

	private readonly Quaternion yRot180 = Quaternion.Euler(0f, 180f, 0f);

	private float animateTime = 0.2f;

	private Animation targetAnim;

	private MRBase owner;

	public void OnAwakeLR(MRBase owner)
	{
		Initialise();
		this.owner = owner;
	}

	private void Initialise()
	{
		lookAtSpeed = animationSettings.lookAtSpeed;
		lookAtGroups = new List<LookAtContainer>();
		lookAtGroups.Add(CreateLookAtGroup(neckRoot, animationSettings.NeckRotationExtents, animationSettings.NeckForwardFlipped));
		lookAtGroups.Add(CreateLookAtGroup(headRoot, animationSettings.HeadRotationExtents, animationSettings.HeadForwardFlipped));
		lookAtGroups.Add(CreateLookAtGroup(leftEyeRoot, animationSettings.EyesRotationExtents, animationSettings.EyesForwardFlipped));
		lookAtGroups.Add(CreateLookAtGroup(rightEyeRoot, animationSettings.EyesRotationExtents, animationSettings.EyesForwardFlipped));
		targetAnim = neckRoot.GetComponentInParent<Animation>();
	}

	private LookAtContainer CreateLookAtGroup(Transform root, Vector3 RotationConstraints, bool flipForward = false)
	{
		return new LookAtContainer
		{
			groupRoot = root,
			jointRoot = root.GetChild(0),
			Constraints = RotationConstraints,
			flipForward = flipForward,
			currentWeight = new VectorAnimator()
		};
	}

	public void OnLateUpdateLR()
	{
		Animation animation = targetAnim;
		if (((object)animation != null && !animation.isPlaying) || owner != MainCamera.Inst.GetOwner())
		{
			return;
		}
		bool flag = MakeGroupsLookAt(IC.GetHeadPosition());
		if (animateLookAtOutIfCantSeePlayer)
		{
			if (flag)
			{
				AnimateGroupsToWeights();
			}
			else
			{
				AnimateGroupsOut();
			}
		}
	}

	private bool MakeGroupsLookAt(Vector3 lookAtPos)
	{
		bool result = false;
		int count = lookAtGroups.Count;
		Vector3 forward = default(Vector3);
		Vector3 euler = default(Vector3);
		Vector3 vector = default(Vector3);
		for (int i = 0; i < count; i++)
		{
			LookAtContainer lookAtContainer = lookAtGroups[i];
			lookAtContainer.groupRoot.localRotation = QuaternionX.identity;
			forward.x = lookAtPos.x - lookAtContainer.jointRoot.position.x;
			forward.y = lookAtPos.y - lookAtContainer.jointRoot.position.y;
			forward.z = lookAtPos.z - lookAtContainer.jointRoot.position.z;
			Quaternion quaternion = Quaternion.LookRotation(forward);
			Quaternion quaternion2 = (lookAtContainer.flipForward ? flippedRightToForwardCorrection : rightToForwardCorrection);
			Quaternion rotation = quaternion * quaternion2 * Quaternion.Inverse(lookAtContainer.jointRoot.localRotation);
			lookAtContainer.groupRoot.rotation = rotation;
			Vector3 eulerAngles = lookAtContainer.groupRoot.localRotation.eulerAngles;
			Vector3 currentValue = lookAtContainer.currentWeight.CurrentValue;
			euler.x = (eulerAngles.x - ((eulerAngles.x > 180f) ? 360f : 0f)) * currentValue.x;
			euler.y = (eulerAngles.y - ((eulerAngles.y > 180f) ? 360f : 0f)) * currentValue.y;
			euler.z = (eulerAngles.z - ((eulerAngles.z > 180f) ? 360f : 0f)) * currentValue.z;
			float x = lookAtContainer.Constraints.x;
			float y = lookAtContainer.Constraints.y;
			float z = lookAtContainer.Constraints.z;
			vector.x = ((euler.x < 0f - x) ? (0f - x) : ((euler.x > x) ? x : euler.x));
			vector.y = ((euler.y < 0f - y) ? (0f - y) : ((euler.y > y) ? y : euler.y));
			vector.z = ((euler.z < 0f - z) ? (0f - z) : ((euler.z > z) ? z : euler.z));
			if (euler.x != vector.x || euler.y != vector.y || euler.z != vector.z)
			{
				euler = vector;
			}
			else
			{
				result = true;
			}
			lookAtContainer.groupRoot.localRotation = Quaternion.Euler(euler);
		}
		return result;
	}

	private void AnimateGroupsToWeights()
	{
		foreach (LookAtContainer lookAtGroup in lookAtGroups)
		{
			lookAtGroup.currentWeight.AnimateTo(lookAtGroup.weight, animateTime, onlyResetIfNewTarget: true);
		}
	}

	private void AnimateGroupsOut()
	{
		foreach (LookAtContainer lookAtGroup in lookAtGroups)
		{
			lookAtGroup.currentWeight.AnimateTo(Vector3X.zero, animateTime, onlyResetIfNewTarget: true);
		}
	}

	[KubrickAnimFunc(ExecuteInEditMode = true)]
	private void UpdateLookAtWeights(Vector3 neckWeight, Vector3 headWeight, Vector3 eyeWeight, float animationTime)
	{
		lookAtGroups[0].weight = neckWeight;
		lookAtGroups[1].weight = headWeight;
		lookAtGroups[2].weight = eyeWeight;
		lookAtGroups[3].weight = eyeWeight;
		animateTime = animationTime;
		AnimateGroupsToWeights();
	}
}
public class CharacterVoice : MonoBehaviour
{
	public Transform voiceXForm;

	[KubrickAnimFunc(ExecuteInEditMode = true)]
	private void PlayVoiceClip(FMODEventAsset voiceClip, string xFormPathOverride, bool stopPrevious, bool isSFX = false)
	{
		Transform transform = (string.IsNullOrEmpty(xFormPathOverride) ? voiceXForm : base.transform.Find(xFormPathOverride));
		if (isSFX)
		{
			FAC.Inst.PlayOneShot(voiceClip, transform);
		}
		else
		{
			VOC.Inst.PlayVOImmediate(voiceClip.fmodGUID, 0f, transform);
		}
	}

	private static float PlayVoiceClip_GetDuration(FMODEventAsset voiceClip, string xFormPathOverride, bool stopPrevious, bool isSFX)
	{
		return FACMisc.GetDuration(voiceClip);
	}

	private static string PlayVoiceClip_GetDisplayName(FMODEventAsset voiceClip, string xFormPathOverride, bool stopPrevious, bool isSFX)
	{
		return FACMisc.GetDisplayName(voiceClip);
	}

	private static void PlayVoiceClip_Preload(FMODEventAsset voiceClip, string xFormPathOverride, bool stopPrevious, bool isSFX)
	{
		FACMisc.PreloadAsset(voiceClip);
	}

	private static void PlayVoiceClip_Unload(FMODEventAsset voiceClip, string xFormPathOverride, bool stopPrevious, bool isSFX)
	{
		FACMisc.UnloadAsset(voiceClip);
	}
}
[Serializable]
public class IdleAnimationSet
{
	public string idle;

	[Tooltip("Only used when blending back to this animation, e.g. from a talk animation")]
	public float returnBlend = 0.2f;

	public Vector2 altFrequency = new Vector2(8f, 16f);

	public IdleAltSet[] idleAltSets;

	[HideInInspector]
	public bool expanded;

	public IdleAltSet GetRandomAltSet(System.Random random)
	{
		if (idleAltSets == null || idleAltSets.Length == 0)
		{
			return null;
		}
		int num = random.Next(0, idleAltSets.Length);
		return idleAltSets[num];
	}
}
[Serializable]
public class IdleAltSet
{
	public string idleAlt;

	public float idleBlend;

	[HideInInspector]
	public bool expanded;
}
[DisallowMultipleComponent]
public class IdleAnimation : MonoBehaviour
{
	[Serializable]
	public struct VOAnimPair
	{
		public string VOLine;

		public AnimationClip animation;

		public float blendTime;

		[Tooltip("Number of frames  to wait for after the voice line has ended.set to something small like 2 if you expect another VO line to play immediately after this one")]
		public int delayFramesAfter;

		[Tooltip("Loop the animation until the VO has finished.")]
		public bool loopAnimation;

		[Tooltip("Wait for the animation to finish before returning to idle, regardless of if the VO line has finished. \nIf Loop Animation is checked, the animation will loop while the VO is playing, and once the VO finishes the animation will run to completion before returning to Idle")]
		public bool playEntireAnimation;
	}

	private Animation anim;

	public AnimationClip idleClips;

	public VOAnimPair[] voAnimationPairs;

	private IdleAnimationSet cachedAnimSet;

	private HagletValue<VOAnimPair> animPairValue;

	private bool shouldContinueIdle;

	private HagletTrigger currentVOTrigger;

	private System.Random cachedRandom;

	private IHaglet<IdleAnimationSet, System.Random> idleRoutine;

	private IHaglet loopAnim;

	public bool isIdling
	{
		get
		{
			if (idleRoutine != null)
			{
				return idleRoutine.started;
			}
			return false;
		}
	}

	public virtual void OnAwakeLR()
	{
		anim = GetComponent<Animation>();
		Haglet.Create(out idleRoutine, (Routine.Func2<IdleAnimationSet, System.Random>)IdleRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out loopAnim, LoopAnimRoutine);
		HagletValue.Create(out animPairValue, null, default(VOAnimPair), null, 8);
		VOC.Inst.onLineStartedPlaying -= OnVOPlayed;
		VOC.Inst.onLineStartedPlaying += OnVOPlayed;
		anim = GetComponent<Animation>();
	}

	public IEnumerator<Routine.Yield> IdleRoutine(IdleAnimationSet set, System.Random random)
	{
		if (random == null)
		{
			random = cachedRandom;
		}
		else
		{
			cachedRandom = random;
		}
		if (loopAnim.started)
		{
			yield return Wait.Until.Completed(loopAnim);
		}
		IdleAltSet currentSet = set.GetRandomAltSet(random);
		while (true)
		{
			if (currentSet != null)
			{
				HAGIS.PlayAnim(anim, set.idle, currentSet.idleBlend);
				float seconds = (float)random.NextDouble(set.altFrequency.x, set.altFrequency.y);
				yield return Wait.For.Seconds(seconds);
				yield return HAGIS.PlayAnim(anim, currentSet.idleAlt, currentSet.idleBlend);
				currentSet = set.GetRandomAltSet(random);
			}
			else
			{
				yield return HAGIS.PlayAnim(anim, set.idle, set.returnBlend);
			}
		}
	}

	public void OnVOPlayed(object sender, VOC.VOClip voClip)
	{
		if (GetAnimPairForClip(voClip.key, out var animPair))
		{
			UnityEngine.Debug.Log("Playing!");
			animPairValue.value = animPair;
			bool started = idleRoutine.started;
			currentVOTrigger = voClip.onComplete;
			if (started)
			{
				idleRoutine.Stop();
			}
			if (!loopAnim.started)
			{
				shouldContinueIdle = started;
				loopAnim.Start();
			}
		}
	}

	private bool GetAnimPairForClip(string voClipName, out VOAnimPair animPair)
	{
		animPair = default(VOAnimPair);
		if (voAnimationPairs == null || voAnimationPairs.Length == 0)
		{
			return false;
		}
		for (int i = 0; i < voAnimationPairs.Length; i++)
		{
			animPair = voAnimationPairs[i];
			if (voAnimationPairs[i].VOLine == voClipName)
			{
				return true;
			}
		}
		return false;
	}

	private IEnumerator<Routine.Yield> LoopAnimRoutine()
	{
		VOAnimPair animPair = animPairValue.value;
		ulong happenCount = animPairValue.happenCount;
		while (true)
		{
			Wait wait = HAGIS.PlayAnim(anim, animPair.animation.name, animPair.blendTime);
			ulong voTriggerHappenCount = currentVOTrigger.happenCount;
			if (animPair.playEntireAnimation)
			{
				yield return wait;
			}
			else
			{
				yield return wait | currentVOTrigger;
			}
			if (animPair.loopAnimation && currentVOTrigger.happenCount == voTriggerHappenCount)
			{
				anim.Rewind();
				continue;
			}
			yield return Wait.For.LRUpdates(animPair.delayFramesAfter) | animPairValue;
			if (!animPairValue.happening || happenCount == animPairValue.happenCount)
			{
				break;
			}
			animPair = animPairValue.value;
			happenCount = animPairValue.happenCount;
		}
		if (shouldContinueIdle)
		{
			ResumeIdling();
		}
	}

	public void StartIdling(IdleAnimationSet set, System.Random random)
	{
		cachedAnimSet = set;
		idleRoutine.Start(set, random, resetIfStarted: true);
	}

	public void ResumeIdling()
	{
		if (!idleRoutine.started)
		{
			idleRoutine.Start(cachedAnimSet, resetIfStarted: true);
		}
	}

	public void StopIdling()
	{
		if (idleRoutine.started)
		{
			idleRoutine.Stop();
		}
		else if (loopAnim.started)
		{
			shouldContinueIdle = false;
		}
	}

	private void OnDestroy()
	{
		VOC.Inst.onLineStartedPlaying -= OnVOPlayed;
	}
}
public class KubrickEventIDObjectSetActive : MonoBehaviour
{
	private MRBase owner;

	private void Awake()
	{
		owner = base.gameObject.GetComponentInAscendant<MRBase>();
		_ = owner == null;
	}

	[KubrickAnimFunc(ExecuteInEditMode = true)]
	private void IDObjectSetActive(string customName, string id, bool active)
	{
		LR.Inst.GetIDObject<IDObject>(id).gameObject.SetActive(active);
	}

	private static float IDObjectSetActive_GetDuration()
	{
		return 1f;
	}

	private static string IDObjectSetActive_GetDisplayName(string customName, string id, bool active)
	{
		return customName;
	}
}
public class KubrickEventPlayAnim : MonoBehaviour
{
	public Animation animComp;

	[KubrickAnimFunc(ExecuteInEditMode = true)]
	private void PlayAnim(AnimationClip clip)
	{
		if ((bool)animComp && (bool)clip)
		{
			if (!animComp.GetClip(clip.name))
			{
				animComp.AddClip(clip, clip.name);
			}
			animComp.Play(clip.name);
		}
	}

	private static float PlayAnim_GetDuration(AnimationClip clip)
	{
		if (!clip)
		{
			return 1f;
		}
		return clip.length;
	}

	private static string PlayAnim_GetDisplayName(AnimationClip clip)
	{
		if (!clip)
		{
			return "No Animation";
		}
		return clip.name;
	}
}
public class KubrickEventPlayParticle : MonoBehaviour
{
	private MRBase owner;

	private void Awake()
	{
		owner = base.gameObject.GetComponentInAscendant<MRBase>();
		_ = owner == null;
	}

	[KubrickAnimFunc(ExecuteInEditMode = true)]
	private void PlayParticle(string customName, string targPos, ParticleType chosenParticle, bool active)
	{
		IDObject iDObject = LR.Inst.GetIDObject<IDObject>(targPos);
		PSC.Inst.PlayAt(chosenParticle, iDObject.gameObject.transform.position);
	}

	private static float PlayParticle_GetDuration()
	{
		return 1f;
	}

	private static string PlayParticle_GetDisplayName(string customName)
	{
		return customName;
	}
}
public class KubrickEventRemoveStoryItem : MonoBehaviour
{
	public bool debugShowAllItems;

	private void Start()
	{
		if (debugShowAllItems)
		{
			PlayerInventory.Inst.ShowAllStoryItems();
		}
	}

	[KubrickAnimFunc(ExecuteInEditMode = false)]
	private void RemoveStoryItem(InventoryStoryItem storyItem, float delay)
	{
		PlayerInventory.Inst.RemoveStoryItem(storyItem, delay);
	}
}
public class LightSensorGenericEnable : MonoBehaviour, IAreaEvent, IAwakeEvent, IUpdateEvent
{
	public IDObjectRef[] lightSensorRefs;

	private LightSensor[] lightSensors;

	public IDObjectRef targetRef;

	private GameObject targetGameObject;

	public bool inverse;

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		lightSensors = new LightSensor[lightSensorRefs.Length];
		for (int i = 0; i < lightSensors.Length; i++)
		{
			lightSensors[i] = LR.Inst.GetIDObjectComponent<LightSensor>(lightSensorRefs[i]);
		}
		targetGameObject = LR.Inst.GetIDObject<IDObject>(targetRef).gameObject;
		base.enabled = false;
	}

	void IUpdateEvent.OnUpdateLR()
	{
		bool activeSelf = targetGameObject.activeSelf;
		bool flag = false;
		for (int i = 0; i < lightSensors.Length; i++)
		{
			LightSensor lightSensor = lightSensors[i];
			flag |= lightSensor.isReceivingLight.value;
		}
		flag = (inverse ? (!flag) : flag);
		if (activeSelf != flag)
		{
			targetGameObject.SetActive(flag);
		}
	}

	void IAreaEvent.OnAreaEnter()
	{
		base.enabled = true;
	}

	void IAreaEvent.OnAreaExit()
	{
		base.enabled = false;
	}
}
public class LightSensorHighlighter : MonoBehaviour, IAwakeEvent, IUpdateEvent
{
	public Color defaultTintColor = Color.clear;

	public Color highlightTintColor = Color.yellow;

	public LightSensor lightSensor;

	private MeshRenderer mr;

	private MaterialPropertyBlock mpb;

	private int tintColorID;

	private Color objColor = new Color(1f, 1f, 1f, 1f);

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		mr = GetComponent<MeshRenderer>();
		mpb = new MaterialPropertyBlock();
		tintColorID = Shader.PropertyToID("_TintColor");
		SetColorImmediate(defaultTintColor);
	}

	void IUpdateEvent.OnUpdateLR()
	{
		if (lightSensor.isReceivingLight.value)
		{
			if (objColor != highlightTintColor)
			{
				SetColorImmediate(ColorX.MoveTowards(objColor, highlightTintColor, 0.1f));
			}
		}
		else if (objColor != defaultTintColor)
		{
			SetColorImmediate(ColorX.MoveTowards(objColor, defaultTintColor, 0.1f));
		}
	}

	private void SetColorImmediate(Color color)
	{
		objColor.r = color.r;
		objColor.g = color.g;
		objColor.b = color.b;
		objColor.a = color.a;
		mpb.SetColor(tintColorID, objColor);
		mr.SetPropertyBlock(mpb);
	}
}
public class LightSensorLightEnabler : MonoBehaviour, IUpdateEvent
{
	public LightSensor lightSensor;

	public LightSource targetLight;

	public IDObjectRef mimicLightRef;

	private LightSource mimicLightSource;

	void IUpdateEvent.OnUpdateLR()
	{
		CheckLight(targetLight);
		if ((bool)mimicLightSource || mimicLightRef.TryGetComponent<LightSource>(out mimicLightSource))
		{
			CheckLight(mimicLightSource);
		}
	}

	private void CheckLight(LightSource light)
	{
		if (!lightSensor)
		{
			return;
		}
		bool lightIsEnabled = light.LightIsEnabled;
		bool value = lightSensor.isReceivingLight.value;
		if (lightIsEnabled != value)
		{
			if (value)
			{
				light.EnableLight();
			}
			else
			{
				light.DisableLight();
			}
		}
	}
}
public class LightSensorRegionEnable : MonoBehaviour, IAwakeEvent, IUpdateEvent
{
	public IDObjectRef[] lightSensorRefs;

	private LightSensor[] lightSensors;

	public IDObjectRef regionRef;

	private Region region;

	public bool inverse;

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		lightSensors = new LightSensor[lightSensorRefs.Length];
		for (int i = 0; i < lightSensors.Length; i++)
		{
			lightSensors[i] = LR.Inst.GetIDObjectComponent<LightSensor>(lightSensorRefs[i]);
		}
		region = LR.Inst.GetIDObjectComponent<Region>(regionRef);
	}

	void IUpdateEvent.OnUpdateLR()
	{
		bool isEnabled = region.IsEnabled;
		bool flag = false;
		for (int i = 0; i < lightSensors.Length; i++)
		{
			flag |= lightSensors[i]?.isReceivingLight.value ?? false;
		}
		flag = (inverse ? (!flag) : flag);
		if (isEnabled != flag)
		{
			if (flag)
			{
				region.Enable();
			}
			else
			{
				region.Disable();
			}
		}
	}
}
public class ParticlePath : MonoBehaviour, IAwakeEvent, IUpdateEvent, IPrebuildEvent
{
	public enum PathType
	{
		PARTICLE,
		MODEL
	}

	public struct SampleResult
	{
		public Vector3 localPosition;

		public Quaternion rotation;
	}

	[SerializeField]
	private PathType pathType;

	[HideInInspector]
	public bool showNodes;

	[HideInInspector]
	public ConstArray<Transform> nodeXforms;

	[SerializeField]
	[HideInInspector]
	private ParticlePathNode[] pathNodes;

	[SerializeField]
	[HideInInspector]
	private Bezier[] curves;

	[SerializeField]
	[HideInInspector]
	private float[] segmentDistances;

	[SerializeField]
	public Transform targetXform;

	[SerializeField]
	[Tooltip("On means path time is based on nodes, false means manual times")]
	private bool useNodeTime = true;

	private float time;

	[SerializeField]
	[ConditionalHide("useNodeTime", true, true)]
	private float pathTime = 3f;

	private bool waitingForSound = true;

	[SerializeField]
	[ReadOnly]
	private float pathDistance = -1f;

	[SerializeField]
	[HideInInspector]
	private ParticleSystem targetPS;

	[SerializeField]
	[HideInInspector]
	private ParticleSystem trailPS;

	[SerializeField]
	private bool playPSOnAwake;

	private Vector3[] bezierPoints = new Vector3[4];

	public float PathTime
	{
		get
		{
			if (useNodeTime)
			{
				float num = 0f;
				for (int i = 0; i < pathNodes.Length - 1; i++)
				{
					num += pathNodes[i].Time;
				}
				return num;
			}
			return pathTime;
		}
	}

	void IPrebuildEvent.OnPrebuildRoot(bool isPrefab)
	{
		CalculateCurves();
		segmentDistances = new float[pathNodes.Length];
		pathDistance = CalculateDistance();
		targetPS = targetXform.GetComponent<ParticleSystem>();
		Transform transform = targetXform.Find("Trail");
		trailPS = transform.GetComponent<ParticleSystem>();
	}

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		if (targetXform == null || targetPS == null)
		{
			base.enabled = false;
			return;
		}
		if (pathType == PathType.PARTICLE)
		{
			ParticleSystem.MainModule main = targetPS.main;
			main.startLifetime = PathTime + 0.5f;
			main.startSpeed = 0f;
			main.startDelay = 0f;
			ParticleSystem.TrailModule trails = targetPS.trails;
			_ = trails.lifetime;
			trails.lifetimeMultiplier = 0.25f;
			ParticleSystem.MainModule main2 = trailPS.main;
			main2.duration = PathTime + 0.5f;
			if (playPSOnAwake)
			{
				targetPS.Play();
			}
		}
		base.enabled = false;
	}

	private void CalculateCurves()
	{
		pathNodes = GetComponentsInChildren<ParticlePathNode>();
		curves = new Bezier[pathNodes.Length - 1];
		int num = 0;
		for (int i = 1; i < pathNodes.Length; i++)
		{
			ParticlePathNode particlePathNode = pathNodes[num];
			ParticlePathNode particlePathNode2 = pathNodes[i];
			curves[num] = new Bezier(base.transform.InverseTransformPoint(particlePathNode.transform.position), base.transform.InverseTransformPoint(particlePathNode.ControlPos1), base.transform.InverseTransformPoint(particlePathNode2.ControlPos0), base.transform.InverseTransformPoint(particlePathNode2.transform.position));
			num++;
		}
	}

	void IUpdateEvent.OnUpdateLR()
	{
		time += IC.DeltaTime;
		if (waitingForSound)
		{
			if (time < 0.6f)
			{
				return;
			}
			time = 0f;
			waitingForSound = false;
		}
		if (!playPSOnAwake && !targetPS.isPlaying)
		{
			targetPS.Play();
		}
		if (time <= PathTime)
		{
			SampleResult sampleResult = Sample(time);
			targetXform.position = base.transform.TransformPoint(sampleResult.localPosition);
			targetXform.rotation = sampleResult.rotation;
		}
		else if (time >= PathTime + 0.5f)
		{
			base.enabled = false;
			waitingForSound = true;
			time = 0f;
			StopParticles();
		}
	}

	public void ManualUpdate(float sampleTime)
	{
		SampleResult sampleResult = Sample(sampleTime);
		targetXform.position = base.transform.TransformPoint(sampleResult.localPosition);
		targetXform.rotation = sampleResult.rotation;
	}

	public void StopParticles()
	{
		targetPS.Stop();
	}

	public SampleResult Sample(float time)
	{
		SampleResult result = default(SampleResult);
		time = Mathf.Clamp(time, 0f, PathTime);
		float num = PathTime / pathDistance;
		bool flag = false;
		float num2 = 0f;
		int num3 = 0;
		for (int i = 1; i < pathNodes.Length; i++)
		{
			ParticlePathNode particlePathNode = pathNodes[num3];
			ParticlePathNode particlePathNode2 = pathNodes[i];
			float num4 = num2;
			num2 += (useNodeTime ? particlePathNode.Time : (segmentDistances[num3] * num));
			float num5 = num2;
			if (time >= num4 && time <= num5)
			{
				flag = true;
				float t = Mathf.InverseLerp(num4, num5, time);
				result.localPosition = curves[num3].MappedSample(t);
				result.rotation = Quaternion.Slerp(particlePathNode.transform.rotation, particlePathNode2.transform.rotation, t);
				break;
			}
			num3++;
		}
		if (!flag)
		{
			result.localPosition = ((pathNodes.Length != 0) ? base.transform.InverseTransformPoint(pathNodes[pathNodes.Length - 1].transform.position) : Vector3.zero);
		}
		return result;
	}

	private Vector3 SamplePositionBetweenNodes(ParticlePathNode node0, ParticlePathNode node1, float lerpTime, int startNodeIdx)
	{
		bezierPoints[0] = node0.transform.position;
		bezierPoints[1] = node0.ControlPos1;
		bezierPoints[2] = node1.ControlPos0;
		bezierPoints[3] = node1.transform.position;
		return VectorX.BezierCurve(bezierPoints, lerpTime);
	}

	private float CalculateDistance()
	{
		float num = 0f;
		if (pathNodes == null)
		{
			pathNodes = GetComponentsInChildren<ParticlePathNode>();
		}
		if (segmentDistances == null || segmentDistances.Length != pathNodes.Length)
		{
			segmentDistances = new float[pathNodes.Length];
		}
		int num2 = 0;
		for (int i = 1; i < pathNodes.Length; i++)
		{
			ParticlePathNode particlePathNode = pathNodes[num2];
			ParticlePathNode particlePathNode2 = pathNodes[i];
			float magnitude = (particlePathNode2.transform.position - particlePathNode.transform.position).magnitude;
			float magnitude2 = (particlePathNode2.transform.position - particlePathNode2.ControlPos0).magnitude;
			magnitude2 += (particlePathNode2.ControlPos0 - particlePathNode.ControlPos1).magnitude;
			magnitude2 += (particlePathNode.ControlPos1 - particlePathNode.transform.position).magnitude;
			segmentDistances[num2] = (magnitude + magnitude2) / 2f;
			num += segmentDistances[num2];
			num2++;
		}
		return num;
	}
}
public class ParticlePathNode : MonoBehaviour
{
	[HideInInspector]
	public Vector3 controlPos0;

	[HideInInspector]
	public Vector3 controlPos1;

	public bool mirrorNodeRotation;

	[SerializeField]
	private float time = 0.5f;

	public float Time => time;

	public Vector3 ControlPos0
	{
		get
		{
			return base.transform.TransformPoint(controlPos0);
		}
		set
		{
			controlPos0 = base.transform.InverseTransformPoint(value);
		}
	}

	public Vector3 ControlPos1
	{
		get
		{
			return base.transform.TransformPoint(controlPos1);
		}
		set
		{
			controlPos1 = base.transform.InverseTransformPoint(value);
		}
	}
}
public class PortalAnimate : MonoBehaviour
{
	public Portal portal;

	[KubrickAnimFunc(ExecuteInEditMode = true)]
	private void LockPortal(bool locked = true)
	{
		portal.SetUnlockedState(!locked);
	}
}
public enum NXAchievements
{
	Princess_Complete,
	Hunter_Complete,
	Stargazing_Complete,
	Escape_Complete,
	EvilGate_Complete,
	Insanity_Complete,
	Death_Complete,
	FirstMeeting_Complete,
	Story_Complete,
	MansfieldsLab_Unlocked,
	Testing,
	Testing2,
	MAX
}
public class AchievementController
{
	private static readonly string[] achievementNames = new string[12]
	{
		"CROWN_COMPLETE", "HUNTRESS_COMPLETE", "STARGAZING_COMPLETE", "ESCAPE_COMPLETE", "EVILGATE_COMPLETE", "INSANITY_COMPLETE", "DEATH_COMPLETE", "FIRSTMEETING_COMPLETE", "STORY_COMPLETE", "MANSFIELD_COMPLETE",
		"TEST_COMPLETE", "TEST_2_COMPLETE"
	};

	private static bool[] achievementsUnlocked = new bool[12];

	public void GetAvailableAchievements()
	{
		Achievements.GetAllDefinitions().OnComplete(DefinitionsCallback);
	}

	private void DefinitionsCallback(Message<AchievementDefinitionList> msg)
	{
		if (msg.IsError)
		{
			UnityEngine.Debug.LogError("Definition Error: " + msg.GetError().Message);
			return;
		}
		UnityEngine.Debug.Log("Available Achievements: ");
		foreach (AchievementDefinition datum in msg.Data)
		{
			UnityEngine.Debug.Log(datum.Name);
		}
		Achievements.GetAllProgress().OnComplete(ProgressCallback);
	}

	public void GetAchievementProgressOculus()
	{
		Achievements.GetAllProgress().OnComplete(ProgressCallback);
	}

	public bool[] GetAchievementProgressNexus()
	{
		return achievementsUnlocked;
	}

	private void ProgressCallback(Message<AchievementProgressList> msg)
	{
		if (msg.IsError)
		{
			UnityEngine.Debug.LogError("Progress Error: " + msg.GetError().Message);
			return;
		}
		UnityEngine.Debug.Log("Achievement Progress: ");
		int num = achievementNames.Length;
		for (int i = 0; i < num; i++)
		{
			achievementsUnlocked[i] = false;
		}
		for (int j = 0; j < msg.Data.Count; j++)
		{
			AchievementProgress achievementProgress = msg.Data[j];
			UnityEngine.Debug.Log($"{achievementProgress.Name} unlock status: {achievementProgress.IsUnlocked}");
			for (int k = 0; k < num; k++)
			{
				if (achievementProgress.Name == achievementNames[k])
				{
					achievementsUnlocked[k] = true;
				}
			}
		}
	}

	public void UnlockAchievement(NXAchievements achievement)
	{
		Achievements.Unlock(achievementNames[(int)achievement]).OnComplete(UnlockCallback);
	}

	private void UnlockCallback(Message<AchievementUpdate> msg)
	{
		if (msg.IsError)
		{
			UnityEngine.Debug.LogError("Unlock Failed: " + msg.GetError().Message);
		}
		else if (msg.Data.JustUnlocked)
		{
			UnityEngine.Debug.Log("Achievement Unlocked: " + msg.Data.Name);
		}
		else
		{
			UnityEngine.Debug.Log("Achievement already unlocked: " + msg.Data.Name);
		}
	}

	public IEnumerator ResetAllAchievementProgress(string access_token, string userID)
	{
		WWWForm wWWForm = new WWWForm();
		wWWForm.AddField("access_token", access_token);
		wWWForm.AddField("user_id", userID);
		UnityEngine.Debug.Log("Access Token: '" + access_token + "' UserID: '" + userID + "'");
		UnityWebRequest request = UnityWebRequest.Post("https://graph.oculus.com/achievement_remove_all", wWWForm);
		yield return request.SendWebRequest();
		if (request.isNetworkError || request.isHttpError)
		{
			UnityEngine.Debug.Log("Reset Request Error: " + request.error);
			yield break;
		}
		UnityEngine.Debug.Log("Reset Request Sent");
		if (UnityEngine.Application.isPlaying)
		{
			Achievements.GetAllProgress().OnComplete(ProgressCallback);
		}
	}
}
public class BoundaryBox : MonoBehaviour
{
	public enum BoundaryType
	{
		Boundary,
		PlayerArea,
		PlayerExclusiveArea
	}

	public BoundaryType m_boundaryType;

	private BoxCollider m_boxCollider;

	private Vector3 m_size;

	private Vector3 m_centre;

	public bool IsPlayerArea
	{
		get
		{
			if (m_boundaryType != BoundaryType.PlayerArea)
			{
				return m_boundaryType == BoundaryType.PlayerExclusiveArea;
			}
			return true;
		}
	}

	public bool IsExclusive
	{
		get
		{
			return m_boundaryType == BoundaryType.PlayerExclusiveArea;
		}
		set
		{
			m_boundaryType = ((!value) ? BoundaryType.PlayerArea : BoundaryType.PlayerExclusiveArea);
		}
	}

	public void OnAwakeLR()
	{
		m_boxCollider = GetComponent<BoxCollider>();
		m_size = m_boxCollider.size;
		m_centre = m_boxCollider.center;
	}

	public bool CheckTargetInVolume(Vector3 worldPos, float allowance = 0f)
	{
		Vector3 vector = m_boxCollider.transform.InverseTransformPoint(worldPos) - m_centre;
		float num = m_size.x * 0.5f;
		float num2 = m_size.y * 0.5f;
		float num3 = m_size.z * 0.5f;
		if (vector.x < num && vector.x > 0f - num && vector.y < num2 && vector.y > 0f - num2 && vector.z < num3 && vector.z > 0f - num3)
		{
			return true;
		}
		return false;
	}
}
public class Localisation
{
	public interface IUseLocalisation
	{
		void OnLanguageChanged(Language newLanguage);
	}

	private struct FontData
	{
		public string path;

		public Font font;

		public Material material;

		public FontType fontType;

		public FontData(string fontPath, FontType type)
		{
			path = fontPath;
			fontType = type;
			font = Resources.Load<Font>(fontPath);
			material = Resources.Load<Material>(fontPath);
		}
	}

	public enum FontType
	{
		Regular1 = 0,
		Regular2 = 1,
		Outline = 2,
		Digital = 3,
		ERROR = -1
	}

	public enum Language
	{
		ENGLISH,
		FRENCH,
		SPANISH,
		GERMAN,
		KOREAN,
		JAPANESE,
		LANGUAGE_MAX
	}

	private static Localisation _instance;

	private int languageIndex;

	private Dictionary<string, string[]> database;

	public static readonly int[] langToFMODLookup = new int[6] { 1, 3, 6, 2, 5, 4 };

	private FontData[] fontData = new FontData[12]
	{
		new FontData("NotoSans-Bold", FontType.Regular1),
		new FontData("Pangolin", FontType.Regular2),
		new FontData("NotoSans-Outline", FontType.Outline),
		new FontData("NotoMono-Regular", FontType.Digital),
		new FontData("NotoSansCJKkr-Medium", FontType.Regular1),
		new FontData("NotoSansCJKkr-Regular", FontType.Regular2),
		new FontData("NotoSansCJKkr-Outline", FontType.Outline),
		new FontData("NotoSansMonoCJKkr-Bold", FontType.Digital),
		new FontData("NotoSansCJKjp-Medium", FontType.Regular1),
		new FontData("NotoSansCJKjp-Regular", FontType.Regular2),
		new FontData("NotoSansCJKjp-Outline", FontType.Outline),
		new FontData("NotoSansMonoCJKjp-Bold", FontType.Digital)
	};

	public static readonly string[] Language_String = new string[6] { "NEXUS_UI_languages_text_002", "NEXUS_UI_languages_text_003", "NEXUS_UI_languages_text_004", "NEXUS_UI_languages_text_005", "NEXUS_UI_languages_text_006", "NEXUS_UI_languages_text_008" };

	private static int kFontStyleCount = 4;

	private readonly List<IUseLocalisation> localisationUsers = new List<IUseLocalisation>(512);

	public static Localisation Inst
	{
		get
		{
			if (_instance != null)
			{
				return _instance;
			}
			return _instance = new Localisation();
		}
		set
		{
			_instance = value;
		}
	}

	public Language CurrentLanguage => (Language)languageIndex;

	private Localisation()
	{
		languageIndex = PlayerPrefs.GetInt("Language", -1);
		if (languageIndex == -1)
		{
			languageIndex = 0;
			PlayerPrefs.SetInt("Language", languageIndex);
			PlayerPrefs.Save();
		}
	}

	public static void RefreshDataBase(Dictionary<string, string[]> injectedDatabase = null)
	{
		if (injectedDatabase != null)
		{
			Inst.database = injectedDatabase;
			return;
		}
		Inst.database = null;
		Inst.database = GetDatabaseImmediate();
	}

	private static Dictionary<string, string[]> ParseCSVIntoDictionary(string csvData)
	{
		Dictionary<string, string[]> dictionary = new Dictionary<string, string[]>();
		bool flag = false;
		StringBuilder stringBuilder = new StringBuilder();
		int num = 0;
		string text = null;
		for (int i = 0; i < csvData.Length; i++)
		{
			char c = csvData[i];
			if ((c == ',' || c == '\n') && !flag)
			{
				if (text == null)
				{
					text = stringBuilder.ToString();
					stringBuilder.Length = 0;
					string[] value = new string[6];
					if (dictionary.ContainsKey(text))
					{
						continue;
					}
					dictionary.Add(text, value);
				}
				else if (num < 6)
				{
					dictionary[text][num] = stringBuilder.ToString().Trim();
					num++;
					stringBuilder.Length = 0;
				}
				if (c == '\n')
				{
					int num2 = 5;
					_ = dictionary[text][num2];
					text = null;
					stringBuilder.Length = 0;
					flag = false;
					num = 0;
				}
			}
			else if (c == '"')
			{
				if (flag)
				{
					if (i + 1 < csvData.Length && csvData[i + 1] == '"')
					{
						stringBuilder.Append(csvData[i + 1]);
						i++;
					}
					else
					{
						flag = false;
					}
				}
				else
				{
					flag = true;
				}
			}
			else
			{
				stringBuilder.Append(c);
			}
		}
		return dictionary;
	}

	public Wait LoadLocalization(bool synchronous)
	{
		if (database != null)
		{
			return Wait.PreMet;
		}
		if (synchronous)
		{
			database = GetDatabaseImmediate();
			LoadFontsImmediate();
			return Wait.PreMet;
		}
		Haglet.Create(out var hag, LoadRoutine, "Localisation Load Routine");
		return hag.Start();
	}

	private Wait OnResourcesRequestComplete(ResourceRequest request)
	{
		return Wait.Until.True(() => request.isDone);
	}

	private IEnumerator<Routine.Yield> LoadRoutine()
	{
		ResourceRequest resRequest = Resources.LoadAsync<TextAsset>("Localisation/localisation_script");
		yield return OnResourcesRequestComplete(resRequest);
		if (resRequest.asset == null)
		{
			UnityEngine.Debug.LogError("LocalisationController: Failed to open 'localisation_script.csv'!");
			yield break;
		}
		string csvData = ((TextAsset)resRequest.asset).text;
		FAC.AddThreadTask(delegate
		{
			database = ParseCSVIntoDictionary(csvData);
		});
		yield return FAC.WaitThreadBusy;
		int i = 0;
		while (i < fontData.Length)
		{
			ResourceRequest fontLoader2 = Resources.LoadAsync<Font>(fontData[i].path);
			yield return OnResourcesRequestComplete(fontLoader2);
			fontData[i].font = (Font)fontLoader2.asset;
			fontLoader2 = Resources.LoadAsync<Material>(fontData[i].path);
			yield return OnResourcesRequestComplete(fontLoader2);
			fontData[i].material = (Material)fontLoader2.asset;
			int num = i + 1;
			i = num;
		}
	}

	private static Dictionary<string, string[]> GetDatabaseImmediate()
	{
		TextAsset textAsset = Resources.Load<TextAsset>("Localisation/localisation_script");
		if (textAsset == null)
		{
			UnityEngine.Debug.LogError("LocalisationController: Failed to open 'localisation_script.csv'!");
			return null;
		}
		return ParseCSVIntoDictionary(textAsset.text);
	}

	public static bool IsKeyValid(string key)
	{
		Inst.LoadLocalization(synchronous: true);
		string[] value;
		if (!string.IsNullOrEmpty(key))
		{
			return Inst.database.TryGetValue(key, out value);
		}
		return false;
	}

	public static string Retrieve(string key)
	{
		return RetrieveSpecific(key, (Language)Inst.languageIndex);
	}

	public static string RetrieveSpecific(string key, Language specificLanguage)
	{
		if (!Inst.database.TryGetValue(key, out var value))
		{
			return null;
		}
		string text = value[(int)specificLanguage];
		if (string.IsNullOrEmpty(key) || !string.IsNullOrEmpty(text))
		{
			return text;
		}
		return "[Missing Text]";
	}

	public static string[] GetAllKeys()
	{
		string[] array = new string[Inst.database.Keys.Count];
		Inst.database.Keys.CopyTo(array, 0);
		return array;
	}

	public void ChangeLanguage(Language language)
	{
		if (language < Language.LANGUAGE_MAX)
		{
			languageIndex = (int)language;
			PlayerPrefs.SetInt("Language", languageIndex);
			NotifyLocalisationUsers(CurrentLanguage);
		}
	}

	private static int GetFontIndex(Language language, FontType type)
	{
		int num = 0;
		switch (language)
		{
		case Language.KOREAN:
			num = 1;
			break;
		case Language.JAPANESE:
			num = 2;
			break;
		}
		return (int)(num * kFontStyleCount + type);
	}

	private void LoadFontsImmediate()
	{
		for (int i = 0; i < fontData.Length; i++)
		{
			if (fontData[i].font == null)
			{
				fontData[i].font = Resources.Load<Font>(fontData[i].path);
			}
			if (fontData[i].material == null)
			{
				fontData[i].material = Resources.Load<Material>(fontData[i].path);
			}
		}
	}

	public static Font GetFontByName(string fontName)
	{
		for (int i = 0; i < Inst.fontData.Length; i++)
		{
			if (Inst.fontData[i].font.name == fontName)
			{
				return Inst.fontData[i].font;
			}
		}
		return null;
	}

	public static Material GetFontMaterialByName(string fontName)
	{
		for (int i = 0; i < Inst.fontData.Length; i++)
		{
			if (Inst.fontData[i].font.name == fontName)
			{
				return Inst.fontData[i].material;
			}
		}
		return null;
	}

	public static FontType GetFontType(Font font)
	{
		for (int i = 0; i < Inst.fontData.Length; i++)
		{
			if (Inst.fontData[i].font == font)
			{
				return Inst.fontData[i].fontType;
			}
		}
		return FontType.ERROR;
	}

	public static void SetLocalisedFont(UITextbox tb)
	{
		SetLocalisedFont(tb, (!tb.enforceEnglish) ? ((Language)Inst.languageIndex) : Language.ENGLISH);
	}

	public static void SetLocalisedFont(UITextbox tb, Language language)
	{
		if (!tb.disableLocalisedFont && !(tb.font == null))
		{
			FontType fontType = GetFontType(tb.font);
			if (fontType != FontType.ERROR)
			{
				Font localisedFont = GetLocalisedFont(fontType, language);
				Material localisedFontMaterial = GetLocalisedFontMaterial(fontType, language);
				tb.SetFont(localisedFont, localisedFontMaterial);
			}
		}
	}

	private static FontData GetLocalisedFontData(FontType type, Language language)
	{
		return Inst.fontData[GetFontIndex(language, type)];
	}

	public static Font GetLocalisedFont(FontType type, Language language)
	{
		return GetLocalisedFontData(type, language).font;
	}

	public static Material GetLocalisedFontMaterial(FontType type, Language language)
	{
		return GetLocalisedFontData(type, language).material;
	}

	public void AddUsesLocalisation(IUseLocalisation localisationUser)
	{
		localisationUsers.Add(localisationUser);
	}

	public void RemoveUsesLocalisation(IUseLocalisation localisationUser)
	{
		localisationUsers.Remove(localisationUser);
	}

	private void NotifyLocalisationUsers(Language newLanguage)
	{
		foreach (IUseLocalisation localisationUser in localisationUsers)
		{
			localisationUser.OnLanguageChanged(newLanguage);
		}
	}
}
public enum TrackingMode
{
	FrontFacing,
	Full360
}
[Serializer.ExcludeAllFields]
public class CC : MonoBehaviour, Serializer.ISelfComposer
{
	public enum MovementType
	{
		None,
		Teleport,
		FreeMove,
		Frustum
	}

	public struct TeleportInfo
	{
		public Portal portal;

		public EGrill eGrill;

		public Region region;

		public bool wasEGrillEncounterBeforePortal;
	}

	private struct MovementData
	{
		public bool fadeCamera;

		public float fadeOut;

		public float fadeDelay;

		public float fadeIn;

		public Color fadeColor;

		public Vector3 worldPosition;

		public Quaternion worldRotation;

		public TeleportInfo teleportInfo;

		public bool forceUpdateLastState;

		public MovementType movementType;

		public PlayerEntryPoint entryPoint;

		public AnimationCurve fadeInCurve;

		public AnimationCurve fadeOutCurve;

		public Portal portalTeleportedThrough;

		public EGrill eGrillTeleportedThrough;

		public bool clearUnusedAssets;
	}

	public static CC Inst;

	public PlayerTeleport teleporter;

	public PlayerFreeMove freeMove;

	[HideInInspector]
	public Plane[] frustumPlanes = new Plane[6];

	[HideInInspector]
	public Plane[] extendedFrustumPlanes = new Plane[6];

	[HideInInspector]
	public ConstArray<Hand> hands = new ConstArray<Hand>(2u);

	[NonSerialized]
	[HideInInspector]
	public TrackingCircle TrackingCircle;

	[NonSerialized]
	[HideInInspector]
	public TrackingDirection TrackingDirection;

	private TrackingFootprint footprints;

	[NonSerialized]
	[HideInInspector]
	public OutOfBoundsIndicator OOBIndicator;

	private TrackingDirectionHint trackingDirectionHint;

	[ReadOnly]
	public TrackingMode trackingMode;

	[HideInInspector]
	public Telepoint telepointStoodOn;

	public MaskController maskController;

	[NonSerialized]
	[HideInInspector]
	public IUpdateEvent[] updateEventSubscribers;

	[Serializer.IncludeField]
	[ReadOnly]
	public string currentSceneUIDName;

	[ReadOnly]
	public SaveDataGame.Chapter currentChapter;

	public SeatingController seatingController;

	[NonSerialized]
	[HideInInspector]
	public OutOfBoundsSystem.PositionData LastHeadPos;

	[NonSerialized]
	[HideInInspector]
	public OutOfBoundsSystem.PositionData LastValidHeadPos;

	private readonly Color DefaultFadeColor = new Color(0f, 0f, 0f, 1f);

	public IC.Hand lastHandInput = IC.Hand.Right;

	private FMOD.Studio.EventInstance highlightSound;

	private bool highlightSoundPlaying;

	private MRBase owner;

	private PortalRenderer portalRenderer;

	private IHaglet onAwakeLRRoutine;

	public Hand handL;

	public Hand handR;

	[HideInInspector]
	public ConstArray<Region> telepadRegions = new ConstArray<Region>(64u);

	[HideInInspector]
	public ConstArray<Stairway> stairways = new ConstArray<Stairway>(16u);

	private bool pushPopRoutineOngoing;

	private bool pushPopRoutineCancelTeleportMovement;

	private IHaglet<MovementData> pushPopPositionRoutine;

	public IHaglet recenterRoutine;

	private IHaglet<bool, Renderer, MaterialPropertyBlock, ParticleSystemRenderer[]>[] transitionRoutines;

	private new Transform transform => base.transform;

	public Region CurrentRegion => LastHeadPos.region;

	public Region LastValidRegion => LastValidHeadPos.region;

	public void Decompose(Serializer.IMemberSink members)
	{
		members["position"] = transform.position;
		members["rotation"] = transform.rotation;
	}

	public void Recompose(Serializer.IMemberSource members)
	{
		transform.position = (Vector3)members["position"];
		transform.rotation = (Quaternion)members["rotation"];
	}

	public Wait OnAwakeLR()
	{
		Haglet.Create(out onAwakeLRRoutine, OnAwakeLRRoutine);
		return onAwakeLRRoutine.Start();
	}

	private IEnumerator<Routine.Yield> OnAwakeLRRoutine()
	{
		Inst = this;
		LR.Inst.GetComponentInChildren<MainCamera>(includeInactive: true).OnAwakeLR();
		yield return Wait.For.Updates(1);
		handL = LR.Inst.GetComponentInChildren<HandL>(includeInactive: true);
		handL.OnAwakeLR();
		handR = LR.Inst.GetComponentInChildren<HandR>(includeInactive: true);
		handR.OnAwakeLR();
		yield return Wait.For.Updates(1);
		teleporter = new PlayerTeleport();
		teleporter.OnAwakeLR();
		yield return Wait.For.Updates(1);
		freeMove = new PlayerFreeMove();
		freeMove.OnAwakeLR();
		portalRenderer = GetComponentInChildren<PortalRenderer>(includeInactive: true);
		portalRenderer.OnAwakeLR();
		TrackingCircle = GetComponentInChildren<TrackingCircle>(includeInactive: true);
		TrackingCircle.OnAwakeLR();
		footprints = TrackingCircle.GetComponentInChildren<TrackingFootprint>(includeInactive: true);
		TrackingDirection = GetComponentInChildren<TrackingDirection>(includeInactive: true);
		TrackingDirection.OnAwakeLR();
		OOBIndicator = GetComponentInChildren<OutOfBoundsIndicator>(includeInactive: true);
		OOBIndicator.OnAwakeLR();
		trackingDirectionHint = GetComponentInChildren<TrackingDirectionHint>(includeInactive: true);
		trackingDirectionHint.OnAwakeLR();
		maskController = GetComponentInChildren<MaskController>();
		maskController.OnAwakeLR();
		seatingController = GetComponentInChildren<SeatingController>();
		seatingController.OnAwakeLR();
		SetTrackingMode(TrackingMode.Full360);
		Haglet.Create(out pushPopPositionRoutine, (Routine.Func1<MovementData>)PushPopPositionRoutine, (string)null, startNow: false, (int?)32, (string)null);
		Haglet.Create(out recenterRoutine, RecenterRoutine);
		transitionRoutines = new IHaglet<bool, Renderer, MaterialPropertyBlock, ParticleSystemRenderer[]>[4];
		for (int i = 0; i < 4; i++)
		{
			Haglet.Create(out transitionRoutines[i], (Routine.Func4<bool, Renderer, MaterialPropertyBlock, ParticleSystemRenderer[]>)TransitionRoutine, (string)null, startNow: false, (int?)null, (string)null);
		}
		MovementData movementData = default(MovementData);
		movementData.worldPosition = transform.position;
		movementData.worldRotation = transform.rotation;
		updateEventSubscribers = GetComponentsInChildren<IUpdateEvent>(includeInactive: true);
		IAwakeEvent[] componentsInChildren = GetComponentsInChildren<IAwakeEvent>(includeInactive: true);
		for (int j = 0; j < componentsInChildren.Length; j++)
		{
			componentsInChildren[j].OnAwakeLR(MainCamera.Inst.GetOwner());
		}
		if (LR.GetPlatform() == LR.NexusPlatform.QUEST)
		{
			handL.SetHandOffset(new Vector3(0f, 0f, -0.04f));
			handR.SetHandOffset(new Vector3(0f, 0f, -0.04f));
		}
	}

	public void SetTrackingMode(TrackingMode trackingMode)
	{
		this.trackingMode = trackingMode;
		switch (trackingMode)
		{
		case TrackingMode.FrontFacing:
			TrackingDirection.gameObject.SetActive(value: true);
			break;
		case TrackingMode.Full360:
			TrackingDirection.gameObject.SetActive(value: false);
			break;
		}
	}

	private float NoiseWrapped(float pos, float freq)
	{
		float x = (0.5f + Mathf.Sin(pos) * 0.5f) * freq;
		float y = (0.5f + Mathf.Cos(pos) * 0.5f) * freq;
		return Mathf.Clamp01(Mathf.PerlinNoise(x, y)) * 2f - 1f;
	}

	public void OnUpdateLR()
	{
		MainCamera.Inst.OnUpdateLR();
		UpdateTrackingSpaceTransform(transform.position, transform.rotation, updateHeldObjects: false);
		handL.OnUpdateLR();
		handR.OnUpdateLR();
		PlayerInventory.Inst.CheckInventoryShouldOpen();
		trackingDirectionHint.OnUpdateLR();
		maskController.OnUpdateLR();
		IUpdateEvent[] array = updateEventSubscribers;
		foreach (IUpdateEvent updateEvent in array)
		{
			MonoBehaviour monoBehaviour = updateEvent as MonoBehaviour;
			if (monoBehaviour == null || monoBehaviour.isActiveAndEnabled)
			{
				updateEvent.OnUpdateLR();
			}
		}
		Vector3 vector = transform.up * TrackingCircle.yOffset;
		Vector3 worldFloorPosition = GetWorldFloorPosition(IC.GetHeadPosition());
		footprints.transform.position = worldFloorPosition + vector;
		TrackingDirection.transform.position = transform.position + vector;
	}

	public void OnLateUpdateLR()
	{
		if (CurrentRegion != null)
		{
			if (CurrentRegion.isDynamic)
			{
				transform.position += CurrentRegion.DynamicOffset;
				NexusFullScreenPass.Inst.UpdateLastValidPosDynamic(CurrentRegion.DynamicOffset);
			}
		}
		else if (LastValidRegion != null && LastValidRegion.isDynamic)
		{
			transform.position += LastValidRegion.DynamicOffset;
			NexusFullScreenPass.Inst.UpdateLastValidPosDynamic(LastValidRegion.DynamicOffset);
		}
	}

	public void OnRealtimeLateUpdateLR()
	{
		handL.OnLateUpdateLR();
		handR.OnLateUpdateLR();
	}

	public void OnPauseUpdateLR()
	{
		MainCamera.Inst.OnUpdateLR();
		UpdateTrackingSpaceTransform(transform.position, transform.rotation, updateHeldObjects: false);
		if (NexusFullScreenPass.Inst.isFadeActive && !UIPauseMenu.Inst.IsShown)
		{
			UpdateMovement();
		}
		handL.OnUpdateLR();
		handR.OnUpdateLR();
		UpdateInputHand();
		trackingDirectionHint.OnUpdateLR();
	}

	public Region.ValidPos GetNearestTelepadRegion(MRBase targetOwner, Vector3 posTarget)
	{
		TeleportSettings inst = BaseSettings<TeleportSettings>.Inst;
		Region.ValidPos result = default(Region.ValidPos);
		telepadRegions.Clear();
		PlayerTeleport.AddActiveRegionsToRegionArray(telepadRegions, targetOwner.regions);
		float num = float.MaxValue;
		for (int i = 0; i < telepadRegions.Length; i++)
		{
			Region region = telepadRegions[i];
			Region.ValidPos validPos = region.FindNearestValidPoint(posTarget, useMaximumConstraints: true, allowOutOfRegionEdgeSnapping: true, inst.freeMoveStepHeight, inst.freeMoveStepHeight, inst.maxXZDistanceToRegionSnap);
			if (!validPos.valid || !region.IsAlignedToUpDirection(transform.up))
			{
				continue;
			}
			float num2 = Vector3.Distance(validPos.worldPos, posTarget);
			if (num2 < num || (result.requiredRepositionToInnerBorder && !validPos.requiredRepositionToInnerBorder))
			{
				num = num2;
				result = validPos;
				if (!validPos.requiredRepositionToInnerBorder)
				{
					break;
				}
			}
		}
		telepadRegions.ClearToDefault();
		return result;
	}

	public Stairway.ValidPos GetNearestStairway(MRBase targetOwner, Vector3 posTarget)
	{
		_ = BaseSettings<TeleportSettings>.Inst;
		Stairway.ValidPos result = default(Stairway.ValidPos);
		stairways.Clear();
		PlayerTeleport.UpdateStairwayArrayWithActiveStairways(stairways, targetOwner.stairways);
		float num = float.MaxValue;
		for (int i = 0; i < stairways.Length; i++)
		{
			Stairway.ValidPos validPos = stairways[i].FindNearestValidPoint(posTarget, transform.up);
			if (!validPos.valid)
			{
				continue;
			}
			float num2 = Vector3.Distance(posTarget, validPos.worldPos);
			if (result.valid)
			{
				if (result.requiredPlaneRepositioning && !validPos.requiredPlaneRepositioning)
				{
					result = validPos;
					num = num2;
				}
				else if (result.requiredEdgeRepositioning && !validPos.requiredEdgeRepositioning)
				{
					result = validPos;
					num = num2;
				}
				else if (num2 < num)
				{
					result = validPos;
					num = num2;
				}
			}
			else
			{
				result = validPos;
				num = num2;
			}
		}
		stairways.ClearToDefault();
		return result;
	}

	public bool CheckStairwayCollision(MRBase targetOwner, Vector3 posTarget)
	{
		TeleportSettings inst = BaseSettings<TeleportSettings>.Inst;
		stairways.Clear();
		PlayerTeleport.UpdateStairwayArrayWithActiveStairways(stairways, targetOwner.stairways);
		for (int i = 0; i < stairways.Length; i++)
		{
			if (Physics.CheckSphere(posTarget, inst.farFromRegionDist, 16384, QueryTriggerInteraction.Ignore))
			{
				return true;
			}
		}
		stairways.ClearToDefault();
		return false;
	}

	private void UpdateMovement()
	{
		switch (BaseSettings<TeleportSettings>.Inst.InputMode)
		{
		case TeleportSettings.Mode.Teleport:
		{
			IC.IHandInput inputForHand3 = IC.GetInputForHand(IC.Hand.Left);
			IC.IHandInput inputForHand4 = IC.GetInputForHand(IC.Hand.Right);
			bool num2 = inputForHand3.GetBackHeld() && !inputForHand3.GetButtonHeld();
			bool flag2 = inputForHand4.GetBackHeld() && !inputForHand4.GetButtonHeld();
			if ((!num2 && !flag2) || !PlayerTeleport.TeleportEnabled.Value)
			{
				bool justProcessInput2 = PositionStackAnimating();
				if (PlayerFreeMove.FreeTurnEnabled.Value && NexusFullScreenPass.Inst.IsClear())
				{
					freeMove.OnUpdateRotation(handR, justProcessInput2);
				}
			}
			break;
		}
		case TeleportSettings.Mode.DualInput:
		{
			if (!IC.isHmdPresent)
			{
				freeMove.OnUpdateMovement(handR, justProcessInput: false);
			}
			IC.IHandInput inputForHand = IC.GetInputForHand(IC.Hand.Left);
			IC.IHandInput inputForHand2 = IC.GetInputForHand(IC.Hand.Right);
			bool num = inputForHand.GetBackHeld() && !inputForHand.GetButtonHeld();
			bool flag = inputForHand2.GetBackHeld() && !inputForHand2.GetButtonHeld();
			if ((num || flag) && PlayerTeleport.TeleportEnabled.Value)
			{
				break;
			}
			bool justProcessInput = PositionStackAnimating();
			if (!NexusFullScreenPass.Inst.isFadeActive || NexusFullScreenPass.Inst.isFadeOOB)
			{
				if (PlayerFreeMove.FreeMoveEnabled.Value)
				{
					freeMove.OnUpdateMovement(handL, justProcessInput);
				}
				if (PlayerFreeMove.FreeTurnEnabled.Value)
				{
					freeMove.OnUpdateRotation(handR, justProcessInput);
				}
			}
			break;
		}
		}
	}

	public void UpdateGrabAndFocus()
	{
		if (LR.Inst.IsPaused || LR.Inst.IsInCutscene)
		{
			if (highlightSoundPlaying)
			{
				highlightSound.stop(STOP_MODE.ALLOWFADEOUT);
				highlightSoundPlaying = false;
			}
			return;
		}
		handL.lastFocusedGrabPointData = handL.currFocusedGrabPointData;
		handL.currFocusedGrabPointData = handL.UpdateHandFocusAndGrab();
		handL.UpdateHighlight();
		handR.lastFocusedGrabPointData = handR.currFocusedGrabPointData;
		handR.currFocusedGrabPointData = handR.UpdateHandFocusAndGrab();
		handR.UpdateHighlight();
		handL.UpdateHandSingle();
		handR.UpdateHandSingle();
		UpdateFocusHighlightSound();
	}

	public void OnPostPhysicsUpdateLR()
	{
		UpdateMovement();
		EvaluateMovementTrackingSpace(default(TeleportInfo));
		bool flag = teleporter.OnUpdateLR();
		freeMove.UpdateTeleported(flag, flag);
		UpdateFrustumPlanes();
		UpdateGrabAndFocus();
		handL.OnPostPhysicsUpdateLR();
		handR.OnPostPhysicsUpdateLR();
		Vector3 gravityDir = -Inst.transform.up;
		OutOfBoundsSystem.PositionData lastHeadPos = OutOfBoundsSystem.TestOutOfBoundsPosition(MainCamera.Inst.GetOwner(), MainCamera.Inst.transform.position, gravityDir, LastHeadPos);
		if (lastHeadPos.region != LastHeadPos.region)
		{
			if ((bool)LastHeadPos.region)
			{
				LastHeadPos.region.OnExitRegion();
			}
			if ((bool)lastHeadPos.region)
			{
				lastHeadPos.region.OnEnterRegion();
			}
		}
		LastHeadPos = lastHeadPos;
		if (LastHeadPos.isValid)
		{
			LastValidHeadPos = LastHeadPos;
		}
	}

	public void UpdateHandTransforms(bool updateHeldObjects)
	{
		handL.UpdateHandTransform(updateHeldObjects);
		handR.UpdateHandTransform(updateHeldObjects);
	}

	public bool IsObjectGrabbed(InteractableObject interactableObject)
	{
		if ((object)handL.InteractableHeld == interactableObject)
		{
			return true;
		}
		if ((object)handR.InteractableHeld == interactableObject)
		{
			return true;
		}
		return false;
	}

	public bool IsObjectGrabbedOrFocusGrabbed(InteractableObject interactableObject)
	{
		if ((object)handL.InteractableHeld == interactableObject)
		{
			return true;
		}
		if ((object)handL.InteractableFocusGrabbed == interactableObject)
		{
			return true;
		}
		if ((object)handR.InteractableHeld == interactableObject)
		{
			return true;
		}
		if ((object)handR.InteractableFocusGrabbed == interactableObject)
		{
			return true;
		}
		return false;
	}

	public Hand GetHandObjectIsGrabbedOrFocusGrabbed(InteractableObject interactableObject)
	{
		if ((object)handL.InteractableHeld == interactableObject)
		{
			return handL;
		}
		if ((object)handL.InteractableFocusGrabbed == interactableObject)
		{
			return handL;
		}
		if ((object)handR.InteractableHeld == interactableObject)
		{
			return handR;
		}
		if ((object)handR.InteractableFocusGrabbed == interactableObject)
		{
			return handR;
		}
		return null;
	}

	public Hand GetHandObjectIsFocusGrabbed(InteractableObject interactableObject)
	{
		if ((object)handL.InteractableFocusGrabbed == interactableObject)
		{
			return handL;
		}
		if ((object)handR.InteractableFocusGrabbed == interactableObject)
		{
			return handR;
		}
		return null;
	}

	public Hand GetHandObjectIsGrabbed(InteractableObject interactableObject)
	{
		if ((object)handL.InteractableHeld == interactableObject)
		{
			return handL;
		}
		if ((object)handR.InteractableHeld == interactableObject)
		{
			return handR;
		}
		return null;
	}

	private void UpdateFocusHighlightSound()
	{
		bool flag = ((bool)handL.currFocusedGrabPointData.grabPoint && handL.currFocusedGrabPointData.focusGrab) || ((bool)handR.currFocusedGrabPointData.grabPoint && handR.currFocusedGrabPointData.focusGrab);
		if (flag && !highlightSoundPlaying)
		{
			highlightSound = FAC.Inst.PlayOneShot(BaseSettings<InteractionSettings>.Inst.sfxHighlight, transform.position);
			highlightSoundPlaying = true;
		}
		else if (!flag && highlightSoundPlaying)
		{
			highlightSound.stop(STOP_MODE.ALLOWFADEOUT);
			highlightSoundPlaying = false;
		}
	}

	public void UpdateInputHand()
	{
		if (UIPauseMenu.Inst.IsShown)
		{
			if (IC.GetInputForHand(IC.Hand.Right).GetAnyDown())
			{
				lastHandInput = IC.Hand.Right;
			}
			else if (IC.GetInputForHand(IC.Hand.Left).GetAnyDown())
			{
				lastHandInput = IC.Hand.Left;
			}
		}
	}

	public Ray GetHandRay()
	{
		if (lastHandInput != IC.Hand.Right)
		{
			return new Ray(handL.transform.position, handL.transform.forward);
		}
		return new Ray(handR.transform.position, handR.transform.forward);
	}

	public Transform GetHandRayTransform()
	{
		if (lastHandInput != IC.Hand.Right)
		{
			return handL.transform;
		}
		return handR.transform;
	}

	public void ResetOrientation()
	{
		InputTracking.Recenter();
	}

	private void ToggleCursor()
	{
		if (!Cursor.visible)
		{
			Cursor.visible = true;
			Cursor.lockState = CursorLockMode.None;
		}
		else
		{
			Cursor.visible = false;
			Cursor.lockState = CursorLockMode.Locked;
		}
	}

	public Wait PositionReplace(Vector3 worldPos, Quaternion worldRot, TeleportInfo teleportInfo, bool fadeCamera = true, bool forceUpdateLastState = false, bool MovementType = false, MovementType movementType = CC.MovementType.None, Color? fadeColor = null, float? fadeInTime = null, float? fadeDelayTime = null, float? fadeOutTime = null, AnimationCurve fadeInCurve = null, AnimationCurve fadeOutCurve = null, Portal portalTeleportedThrough = null, EGrill eGrillTeleportedThrough = null, bool clearUnusedAssets = false)
	{
		MovementData movementData = default(MovementData);
		movementData.worldPosition = worldPos;
		movementData.worldRotation = worldRot;
		movementData.fadeCamera = fadeCamera;
		movementData.teleportInfo = teleportInfo;
		movementData.forceUpdateLastState = forceUpdateLastState;
		movementData.movementType = movementType;
		movementData.fadeIn = fadeInTime ?? BaseSettings<TeleportSettings>.Inst.TeleportFadeSpeed;
		movementData.fadeDelay = fadeDelayTime ?? 0f;
		movementData.fadeOut = fadeOutTime ?? BaseSettings<TeleportSettings>.Inst.TeleportFadeSpeed;
		movementData.fadeColor = fadeColor ?? Color.black;
		movementData.fadeInCurve = fadeInCurve;
		movementData.fadeOutCurve = fadeOutCurve;
		movementData.portalTeleportedThrough = portalTeleportedThrough;
		movementData.eGrillTeleportedThrough = eGrillTeleportedThrough;
		movementData.clearUnusedAssets = clearUnusedAssets;
		if (fadeCamera)
		{
			pushPopPositionRoutine.Start(movementData, resetIfStarted: true);
			if (Wait.Until != null)
			{
				return Wait.Until.Completed(pushPopPositionRoutine);
			}
			return Wait.None;
		}
		if (pushPopPositionRoutine.started)
		{
			pushPopPositionRoutine.Stop();
		}
		PushPopPosition(movementData);
		return Wait.None;
	}

	public Wait PositionReplace(PlayerEntryPoint entryPoint, TeleportInfo teleportInfo, bool fadeCamera = true, bool forceUpdateLastState = false, bool MovementType = false, MovementType movementType = CC.MovementType.None, Color? fadeColor = null, float? fadeInTime = null, float? fadeDelayTime = null, float? fadeOutTime = null, AnimationCurve fadeInCurve = null, AnimationCurve fadeOutCurve = null, Portal portalTeleportedThrough = null, EGrill eGrillTeleportedThrough = null, bool clearUnusedAssets = false)
	{
		MovementData movementData = default(MovementData);
		movementData.entryPoint = entryPoint;
		movementData.worldPosition = entryPoint.transform.position;
		movementData.worldRotation = entryPoint.transform.rotation;
		movementData.fadeCamera = fadeCamera;
		movementData.teleportInfo = teleportInfo;
		movementData.forceUpdateLastState = forceUpdateLastState;
		movementData.movementType = movementType;
		movementData.fadeIn = fadeInTime ?? BaseSettings<TeleportSettings>.Inst.TeleportFadeSpeed;
		movementData.fadeDelay = fadeDelayTime ?? 0f;
		movementData.fadeOut = fadeOutTime ?? BaseSettings<TeleportSettings>.Inst.TeleportFadeSpeed;
		movementData.fadeColor = fadeColor ?? Color.black;
		movementData.fadeInCurve = fadeInCurve;
		movementData.fadeOutCurve = fadeOutCurve;
		movementData.portalTeleportedThrough = portalTeleportedThrough;
		movementData.eGrillTeleportedThrough = eGrillTeleportedThrough;
		movementData.clearUnusedAssets = clearUnusedAssets;
		if (fadeCamera)
		{
			pushPopPositionRoutine.Start(movementData, resetIfStarted: true);
			if (Wait.Until != null)
			{
				return Wait.Until.Completed(pushPopPositionRoutine);
			}
			return Wait.None;
		}
		if (pushPopPositionRoutine.started)
		{
			pushPopPositionRoutine.Stop();
		}
		PushPopPosition(movementData);
		return Wait.None;
	}

	public bool PositionStackAnimating()
	{
		return pushPopPositionRoutine.started;
	}

	public Wait WaitForPositionStackAnimating()
	{
		if (PositionStackAnimating())
		{
			return Wait.Until.Completed(pushPopPositionRoutine);
		}
		return Wait.None;
	}

	private IEnumerator<Routine.Yield> PushPopPositionRoutine(MovementData op)
	{
		if (!pushPopRoutineOngoing)
		{
			IC.Inst.PauseMenuEnabled = false;
			IC.Inst.RecenterEnabled = false;
			PlayerTeleport.TeleportEnabled.Value = false;
		}
		pushPopRoutineOngoing = true;
		pushPopRoutineCancelTeleportMovement = false;
		bool fadeCamera = op.fadeCamera;
		Region region = op.teleportInfo.region;
		Vector3 localRegionPos = Vector3X.zero;
		if (region?.isDynamic ?? false)
		{
			localRegionPos = region.transform.InverseTransformPoint(op.worldPosition);
		}
		if (fadeCamera)
		{
			yield return NexusFullScreenPass.Inst.StartFadeToColor(op.fadeOut, op.fadeColor, 1f, op.fadeInCurve);
			yield return Wait.For.LRUpdates(1);
			if (op.clearUnusedAssets)
			{
				OVROverlayNexus.Inst.SetupColor(black: false);
				yield return Wait.For.LRLateUpdates(2);
				Resources.UnloadUnusedAssets();
			}
		}
		if (!pushPopRoutineCancelTeleportMovement || op.movementType != MovementType.Teleport)
		{
			bool updateHeldObjects = op.movementType == MovementType.Frustum;
			if (localRegionPos != Vector3X.zero)
			{
				op.worldPosition = region.transform.TransformPoint(localRegionPos);
			}
			teleporter.eGrillTeleportedThrough = op.eGrillTeleportedThrough;
			teleporter.portalTeleportedThrough = op.portalTeleportedThrough;
			UpdateTrackingSpaceTransform(op.worldPosition, op.worldRotation, updateHeldObjects);
			if (op.forceUpdateLastState)
			{
				ForceLastStateUpdate();
			}
			bool flag = handL.IsHoldingPortal || handR.IsHoldingPortal;
			bool num = op.movementType == MovementType.Teleport && flag;
			if (num)
			{
				ForceLastStateUpdate();
			}
			if (op.movementType != MovementType.FreeMove)
			{
				EvaluateMovementTrackingSpace(op.teleportInfo, op.movementType);
			}
			if (num)
			{
				if (handL.IsHoldingPortal)
				{
					if ((bool)handL.InteractableHeld)
					{
						(handL.InteractableHeld as GrabObject).HACK_eyeglassPortal.GetLastState().UpdateToLatestState();
					}
					else if ((bool)handL.InteractableFocusGrabbed)
					{
						(handL.InteractableFocusGrabbed as GrabObject).HACK_eyeglassPortal.GetLastState().UpdateToLatestState();
					}
				}
				if (handR.IsHoldingPortal)
				{
					if ((bool)handR.InteractableHeld)
					{
						(handR.InteractableHeld as GrabObject).HACK_eyeglassPortal.GetLastState().UpdateToLatestState();
					}
					else if ((bool)handR.InteractableFocusGrabbed)
					{
						(handR.InteractableFocusGrabbed as GrabObject).HACK_eyeglassPortal.GetLastState().UpdateToLatestState();
					}
				}
			}
			if (op.movementType == MovementType.Teleport)
			{
				NexusFullScreenPass.Inst.ForceUpdateLastValidPosition();
			}
			if ((bool)op.entryPoint)
			{
				SetRegion(op.entryPoint.telepadRegion);
				op.entryPoint.OnPlayerEnter();
			}
			handL.OnPositionReplace();
			handR.OnPositionReplace();
		}
		if (fadeCamera)
		{
			if (op.clearUnusedAssets)
			{
				OVROverlayNexus.Inst.SetupColor(black: true);
			}
			yield return Wait.For.Seconds(op.fadeDelay);
			yield return NexusFullScreenPass.Inst.StartFadeToClear(op.fadeIn, op.fadeOutCurve);
		}
		PlayerTeleport.TeleportEnabled.Value = true;
		IC.Inst.PauseMenuEnabled = true;
		IC.Inst.RecenterEnabled = true;
		pushPopRoutineOngoing = false;
	}

	private void PushPopPosition(MovementData op)
	{
		if (!pushPopRoutineOngoing)
		{
			IC.Inst.PauseMenuEnabled = false;
			IC.Inst.RecenterEnabled = false;
			PlayerTeleport.TeleportEnabled.Value = false;
		}
		pushPopRoutineOngoing = true;
		pushPopRoutineCancelTeleportMovement = false;
		Region region = op.teleportInfo.region;
		Vector3 vector = Vector3X.zero;
		if ((object)region != null && region.isDynamic)
		{
			vector = region.transform.InverseTransformPoint(op.worldPosition);
		}
		if (!pushPopRoutineCancelTeleportMovement || op.movementType != MovementType.Teleport)
		{
			bool updateHeldObjects = op.movementType == MovementType.Frustum;
			if (vector != Vector3X.zero)
			{
				op.worldPosition = region.transform.TransformPoint(vector);
			}
			UpdateTrackingSpaceTransform(op.worldPosition, op.worldRotation, updateHeldObjects);
			if (op.forceUpdateLastState)
			{
				ForceLastStateUpdate();
			}
			bool flag = handL.IsHoldingPortal || handR.IsHoldingPortal;
			bool num = op.movementType == MovementType.Teleport && flag;
			if (num)
			{
				ForceLastStateUpdate();
			}
			if (op.movementType != MovementType.FreeMove)
			{
				EvaluateMovementTrackingSpace(op.teleportInfo, op.movementType);
			}
			if (num)
			{
				if (handL.IsHoldingPortal)
				{
					if ((bool)handL.InteractableHeld)
					{
						(handL.InteractableHeld as GrabObject).HACK_eyeglassPortal.GetLastState().UpdateToLatestState();
					}
					else if ((bool)handL.InteractableFocusGrabbed)
					{
						(handL.InteractableFocusGrabbed as GrabObject).HACK_eyeglassPortal.GetLastState().UpdateToLatestState();
					}
				}
				if (handR.IsHoldingPortal)
				{
					if ((bool)handR.InteractableHeld)
					{
						(handR.InteractableHeld as GrabObject).HACK_eyeglassPortal.GetLastState().UpdateToLatestState();
					}
					else if ((bool)handR.InteractableFocusGrabbed)
					{
						(handR.InteractableFocusGrabbed as GrabObject).HACK_eyeglassPortal.GetLastState().UpdateToLatestState();
					}
				}
			}
			if (op.movementType == MovementType.Teleport)
			{
				NexusFullScreenPass.Inst.ForceUpdateLastValidPosition();
			}
			if ((bool)op.entryPoint)
			{
				SetRegion(op.entryPoint.telepadRegion);
				op.entryPoint.OnPlayerEnter();
			}
			handL.OnPositionReplace();
			handR.OnPositionReplace();
		}
		PlayerTeleport.TeleportEnabled.Value = true;
		IC.Inst.PauseMenuEnabled = true;
		IC.Inst.RecenterEnabled = true;
		pushPopRoutineOngoing = false;
	}

	public void CancelPushPopRoutineTeleport()
	{
		pushPopRoutineCancelTeleportMovement = true;
	}

	public void UpdateTrackingSpaceTransform(Vector3 worldPos, Quaternion worldRot, bool updateHeldObjects)
	{
		transform.position = worldPos;
		transform.rotation = worldRot;
		UpdateHandTransforms(updateHeldObjects);
	}

	private void ForceLastStateUpdate()
	{
		handL.ForceUpdateToLatestState();
		handR.ForceUpdateToLatestState();
		NexusFullScreenPass.Inst.ForceUpdateLastValidPosition();
		MainCamera.Inst.GetLastState().UpdateToLatestState();
		IC.Inst.UpdateHeadPosition();
	}

	public void Recenter()
	{
		if (!recenterRoutine.started)
		{
			recenterRoutine.Start();
		}
	}

	public Wait WaitForRecenterComplete()
	{
		if (!recenterRoutine.started)
		{
			return Wait.None;
		}
		return Wait.Until.Completed(recenterRoutine, 1, allowPreMetNow: true);
	}

	private IEnumerator<Routine.Yield> RecenterRoutine()
	{
		TeleportSettings settings = BaseSettings<TeleportSettings>.Inst;
		if (settings.recenterShouldFade)
		{
			yield return NexusFullScreenPass.Inst.StartFadeToBlack(settings.recenterFadeTime / 2f);
		}
		yield return Wait.For.LRRealtimeLateUpdates(1);
		Vector3 preRecenterHeadPos = InputTracking.GetLocalPosition(XRNode.Head);
		Quaternion preRecenterFloorRot = Quaternion.LookRotation((Quaternion.Euler(InputTracking.GetLocalRotation(XRNode.Head).eulerAngles.RepXZ(0f, 0f)) * Vector3X.forward).normalized, Vector3X.up);
		InputTracking.Recenter();
		yield return LR.Inst.OnRenderPipelineStart;
		Vector3 localPosition = InputTracking.GetLocalPosition(XRNode.Head);
		Quaternion quaternion = Quaternion.LookRotation((Quaternion.Euler(InputTracking.GetLocalRotation(XRNode.Head).eulerAngles.RepXZ(0f, 0f)) * Vector3X.forward).normalized, Vector3X.up);
		Vector3 vector = localPosition - preRecenterHeadPos;
		Quaternion rotation = quaternion * Quaternion.Inverse(preRecenterFloorRot);
		transform.localPosition -= transform.TransformVector(vector);
		transform.localRotation *= Quaternion.Inverse(rotation);
		if (settings.recenterShouldFade)
		{
			yield return NexusFullScreenPass.Inst.StartFadeToClear(settings.recenterFadeTime / 2f);
		}
	}

	public void EvaluateMovementTrackingSpace(TeleportInfo teleportInfo, MovementType movementType = MovementType.None)
	{
		if (!(MainCamera.Inst.GetOwner() == null))
		{
			MainCamera.Inst.EvaluateMovement(teleportInfo, movementType);
		}
	}

	public void SetRegion(Region region)
	{
		MainCamera.Inst.SetOwner(region.owner);
	}

	public Vector3 GetWorldFloorPosition(Vector3 worldPos)
	{
		Vector3 vect = transform.InverseTransformPoint(worldPos);
		return transform.TransformPoint(vect.RepY(0f));
	}

	public Vector3 CalculateCCPosFromHeadPos(Vector3 targetHeadFloorPos, bool checkOOB)
	{
		Vector3 position = transform.InverseTransformPoint(targetHeadFloorPos);
		Vector3 vect;
		if (checkOOB && NexusFullScreenPass.Inst.isFadeActive)
		{
			Vector3 worldFloorPosition = GetWorldFloorPosition(LastHeadPos.constrainedWorldPos);
			vect = transform.InverseTransformPoint(worldFloorPosition);
		}
		else
		{
			vect = IC.GetHeadLocalPosition();
		}
		position -= vect.RepY(0f);
		return transform.TransformPoint(position);
	}

	public void UpdateFrustumPlanes()
	{
		Camera cameraComp = MainCamera.Inst.cameraComp;
		GeometryUtility.CalculateFrustumPlanes(cameraComp, frustumPlanes);
		FrustumSettings inst = BaseSettings<FrustumSettings>.Inst;
		Matrix4x4 matrix4x = Matrix4x4.Perspective(cameraComp.fieldOfView + inst.fovModifier, cameraComp.aspect + inst.aspectModifier, cameraComp.nearClipPlane, cameraComp.farClipPlane);
		matrix4x *= cameraComp.worldToCameraMatrix;
		extendedFrustumPlanes[0].normal = new Vector3(matrix4x.m30 + matrix4x.m00, matrix4x.m31 + matrix4x.m01, matrix4x.m32 + matrix4x.m02);
		extendedFrustumPlanes[0].distance = matrix4x.m33 + matrix4x.m03;
		extendedFrustumPlanes[1].normal = new Vector3(matrix4x.m30 - matrix4x.m00, matrix4x.m31 - matrix4x.m01, matrix4x.m32 - matrix4x.m02);
		extendedFrustumPlanes[1].distance = matrix4x.m33 - matrix4x.m03;
		extendedFrustumPlanes[2].normal = new Vector3(matrix4x.m30 + matrix4x.m10, matrix4x.m31 + matrix4x.m11, matrix4x.m32 + matrix4x.m12);
		extendedFrustumPlanes[2].distance = matrix4x.m33 + matrix4x.m13;
		extendedFrustumPlanes[3].normal = new Vector3(matrix4x.m30 - matrix4x.m10, matrix4x.m31 - matrix4x.m11, matrix4x.m32 - matrix4x.m12);
		extendedFrustumPlanes[3].distance = matrix4x.m33 - matrix4x.m13;
		extendedFrustumPlanes[4].normal = new Vector3(matrix4x.m30 + matrix4x.m20, matrix4x.m31 + matrix4x.m21, matrix4x.m32 + matrix4x.m22);
		extendedFrustumPlanes[4].distance = matrix4x.m33 + matrix4x.m23;
		extendedFrustumPlanes[5].normal = new Vector3(matrix4x.m30 - matrix4x.m20, matrix4x.m31 - matrix4x.m21, matrix4x.m32 - matrix4x.m22);
		extendedFrustumPlanes[5].distance = matrix4x.m33 - matrix4x.m23;
		for (int i = 0; i < 6; i++)
		{
			float magnitude = extendedFrustumPlanes[i].normal.magnitude;
			extendedFrustumPlanes[i].normal /= magnitude;
			extendedFrustumPlanes[i].distance /= magnitude;
		}
	}

	public void OnPauseLR(bool paused)
	{
		if (paused)
		{
			DropHeldObjects();
			Hand.StopHapticFeedback(handL);
			Hand.StopHapticFeedback(handR);
		}
	}

	public void OnCutscene(bool cutscene)
	{
		if (cutscene)
		{
			DropHeldObjects();
		}
	}

	public void DropHeldObjects()
	{
		handL.UngrabObject();
		handR.UngrabObject();
	}

	public void TriggerTransition(bool enabled, Renderer renderer, MaterialPropertyBlock mpb, ParticleSystemRenderer[] particles)
	{
		for (int i = 0; i < transitionRoutines.Length; i++)
		{
			IHaglet<bool, Renderer, MaterialPropertyBlock, ParticleSystemRenderer[]> haglet = transitionRoutines[i];
			if (!haglet.started || haglet.arg1 == renderer)
			{
				haglet.Start(enabled, renderer, mpb, particles, resetIfStarted: true);
				break;
			}
			_ = transitionRoutines.Length - 1;
		}
	}

	private IEnumerator<Routine.Yield> TransitionRoutine(bool enabled, Renderer renderer, MaterialPropertyBlock mpb, ParticleSystemRenderer[] particles)
	{
		TeleportSettings inst = BaseSettings<TeleportSettings>.Inst;
		float animTime = inst.transitionTime;
		float time = 0f;
		int particleCount = ((particles != null) ? particles.Length : 0);
		renderer.sharedMaterial.EnableKeyword("TRANSITION_EFFECT_ON");
		while (time < animTime)
		{
			time += IC.DeltaTime;
			float num = Mathf.Clamp01(time / animTime);
			num = (enabled ? num : (1f - num));
			mpb.SetFloat(ShaderPID._TransitionAmount, num);
			renderer.SetPropertyBlock(mpb);
			for (int i = 0; i < particleCount; i++)
			{
				particles[i].enabled = renderer.enabled && renderer.gameObject.activeInHierarchy;
			}
			yield return Wait.For.LRUpdates(1);
		}
		renderer.sharedMaterial.DisableKeyword("TRANSITION_EFFECT_ON");
	}

	public void SetOwner(MRBase ownerNew)
	{
		MRBase mRBase = owner;
		if (mRBase != ownerNew)
		{
			owner = ownerNew;
			if (portalRenderer != null)
			{
				MRBase.TransferObject(mRBase, ownerNew, portalRenderer);
			}
		}
	}
}
public class IC : MonoBehaviour
{
	public enum Hand
	{
		Left,
		Right
	}

	public enum RecordMode
	{
		Ready,
		Recording,
		Replaying,
		StopStarting
	}

	private static class RecordingVersion
	{
		public const int CURRENT = 4;

		public const int MIN_SUPPORTED = 4;
	}

	public struct HandState
	{
		public float trigger;

		public float grip;

		public byte stateTrigger;

		public byte stateBack;

		public byte stateButton;

		public byte stateMenu;

		public byte stateGrip;

		public byte stateAxis;

		public byte indexTouch;

		public byte thumbTouch;

		public Vector2 axis;

		public AxisState axisState;

		public Vector3 position;

		public Quaternion rotation;

		private static byte CombineState(byte a, byte b)
		{
			bool num = ((uint)a & (true ? 1u : 0u)) != 0 || (b & 1) != 0;
			bool flag = (a & 2u) != 0 || (b & 2) != 0;
			bool flag2 = ((a & 4u) != 0 && (b & 2) == 0) || ((b & 4u) != 0 && (a & 2) == 0);
			return (byte)((num ? 1u : 0u) | (flag ? 2u : 0u) | (flag2 ? 4u : 0u));
		}

		public static HandState Combine(ref HandState A, ref HandState B)
		{
			HandState result = default(HandState);
			result.position = Vector3.Lerp(A.position, B.position, 0.5f);
			result.rotation = Quaternion.Lerp(A.rotation, B.rotation, 0.5f);
			result.axis = A.axis + B.axis;
			if (result.axis.sqrMagnitude > 1f)
			{
				result.axis.Normalize();
			}
			AxisState axisState = A.axisState;
			AxisState axisState2 = B.axisState;
			if ((axisState == AxisState.Up && axisState2 == AxisState.Down) || (axisState == AxisState.Down && axisState2 == AxisState.Up))
			{
				result.axisState = AxisState.Held;
			}
			else
			{
				result.axisState = (AxisState)Mathf.Max((int)A.axisState, (int)B.axisState);
			}
			result.trigger = A.trigger + B.trigger;
			if (Mathf.Abs(result.trigger) > 1f)
			{
				result.trigger = Mathf.Sign(result.trigger);
			}
			result.grip = A.grip + B.grip;
			if (Mathf.Abs(result.grip) > 1f)
			{
				result.grip = Mathf.Sign(result.grip);
			}
			result.stateAxis = CombineState(A.stateAxis, B.stateAxis);
			result.stateBack = CombineState(A.stateBack, B.stateBack);
			result.stateButton = CombineState(A.stateButton, B.stateButton);
			result.stateGrip = CombineState(A.stateGrip, B.stateGrip);
			result.stateTrigger = CombineState(A.stateTrigger, B.stateTrigger);
			result.stateMenu = CombineState(A.stateMenu, B.stateMenu);
			return result;
		}
	}

	private struct InputState
	{
		public HandState handL;

		public HandState handR;

		public HandState combined;

		public float deltaTime;

		public float realDeltaTime;

		public float time;

		public float timeSinceStartup;

		public Vector3 headLocalPos;

		public Quaternion headLocalRot;
	}

	public class IHandInput
	{
		private bool right;

		public IHandInput(bool right)
		{
			this.right = right;
		}

		public Vector2 GetAxis()
		{
			if (!right)
			{
				return state.handL.axis;
			}
			return state.handR.axis;
		}

		public AxisState GetAxisState()
		{
			if (!right)
			{
				return state.handL.axisState;
			}
			return state.handR.axisState;
		}

		public bool GetAxisButtonDown()
		{
			if (!right)
			{
				return (state.handL.stateAxis & 1) != 0;
			}
			return (state.handR.stateAxis & 1) != 0;
		}

		public bool GetAxisButtonHeld()
		{
			if (!right)
			{
				return (state.handL.stateAxis & 2) != 0;
			}
			return (state.handR.stateAxis & 2) != 0;
		}

		public bool GetAxisButtonUp()
		{
			if (!right)
			{
				return (state.handL.stateAxis & 4) != 0;
			}
			return (state.handR.stateAxis & 4) != 0;
		}

		public float GetGrip()
		{
			if (!right)
			{
				return state.handL.grip;
			}
			return state.handR.grip;
		}

		public bool GetBackDown()
		{
			if (!right)
			{
				return (state.handL.stateBack & 1) != 0;
			}
			return (state.handR.stateBack & 1) != 0;
		}

		public bool GetBackHeld()
		{
			if (!right)
			{
				return (state.handL.stateBack & 2) != 0;
			}
			return (state.handR.stateBack & 2) != 0;
		}

		public bool GetBackUp()
		{
			if (!right)
			{
				return (state.handL.stateBack & 4) != 0;
			}
			return (state.handR.stateBack & 4) != 0;
		}

		public bool GetButtonDown()
		{
			if (!right)
			{
				return (state.handL.stateButton & 1) != 0;
			}
			return (state.handR.stateButton & 1) != 0;
		}

		public bool GetButtonHeld()
		{
			if (!right)
			{
				return (state.handL.stateButton & 2) != 0;
			}
			return (state.handR.stateButton & 2) != 0;
		}

		public bool GetButtonUp()
		{
			if (!right)
			{
				return (state.handL.stateButton & 4) != 0;
			}
			return (state.handR.stateButton & 4) != 0;
		}

		public bool GetGripDown()
		{
			if (!right)
			{
				return (state.handL.stateGrip & 1) != 0;
			}
			return (state.handR.stateGrip & 1) != 0;
		}

		public bool GetGripHeld()
		{
			if (!right)
			{
				return (state.handL.stateGrip & 2) != 0;
			}
			return (state.handR.stateGrip & 2) != 0;
		}

		public bool GetGripUp()
		{
			if (!right)
			{
				return (state.handL.stateGrip & 4) != 0;
			}
			return (state.handR.stateGrip & 4) != 0;
		}

		public Vector3 GetPosition()
		{
			if (!right)
			{
				return state.handL.position;
			}
			return state.handR.position;
		}

		public Quaternion GetRotation()
		{
			if (!right)
			{
				return state.handL.rotation;
			}
			return state.handR.rotation;
		}

		public float GetTrigger()
		{
			if (!right)
			{
				return state.handL.trigger;
			}
			return state.handR.trigger;
		}

		public bool GetTriggerDown()
		{
			if (!right)
			{
				return (state.handL.stateTrigger & 1) != 0;
			}
			return (state.handR.stateTrigger & 1) != 0;
		}

		public bool GetTriggerHeld()
		{
			if (!right)
			{
				return (state.handL.stateTrigger & 2) != 0;
			}
			return (state.handR.stateTrigger & 2) != 0;
		}

		public bool GetTriggerUp()
		{
			if (!right)
			{
				return (state.handL.stateTrigger & 4) != 0;
			}
			return (state.handR.stateTrigger & 4) != 0;
		}

		public bool GetMenuDown()
		{
			if (!right)
			{
				return (state.handL.stateMenu & 1) != 0;
			}
			return (state.handR.stateMenu & 1) != 0;
		}

		public bool GetMenuHeld()
		{
			if (!right)
			{
				return (state.handL.stateMenu & 2) != 0;
			}
			return (state.handR.stateMenu & 2) != 0;
		}

		public bool GetMenuUp()
		{
			if (!right)
			{
				return (state.handL.stateMenu & 4) != 0;
			}
			return (state.handR.stateMenu & 4) != 0;
		}

		public bool GetIndexTouch()
		{
			if (!right)
			{
				return state.handL.indexTouch != 0;
			}
			return state.handR.indexTouch != 0;
		}

		public bool GetThumbTouch()
		{
			if (!right)
			{
				return state.handL.thumbTouch != 0;
			}
			return state.handR.thumbTouch != 0;
		}

		public bool GetAnyDown()
		{
			if (right)
			{
				if (state.handR.axisState != AxisState.Down && (state.handR.stateBack & 1) == 0 && (state.handR.stateButton & 1) == 0 && (state.handR.stateGrip & 1) == 0)
				{
					return (state.handR.stateTrigger & 1) != 0;
				}
				return true;
			}
			if (state.handL.axisState != AxisState.Down && (state.handL.stateBack & 1) == 0 && (state.handL.stateButton & 1) == 0 && (state.handL.stateGrip & 1) == 0)
			{
				return (state.handL.stateTrigger & 1) != 0;
			}
			return true;
		}
	}

	public enum AxisState
	{
		None,
		Up,
		Down,
		Held
	}

	private class KBMInput
	{
		private static readonly Vector3 DEF_M_MOVE = new Vector3(1f, 1f, 10f);

		private static readonly Vector3 DEF_K_MOVE = new Vector3(0.2f, 0.2f, 0.2f);

		private static readonly Vector3 DEF_M_ROT = new Vector3(75f, 75f, 75f);

		private static readonly Vector3 DEF_K_ROT = new Vector3(75f, 75f, 75f);

		public const KeyCode LEFT_MOUSE_MODE = KeyCode.RightAlt;

		public const KeyCode RIGHT_MOUSE_MODE = KeyCode.RightControl;

		private const KeyCode AXIS_MODE_SWITCH = KeyCode.Space;

		private const float MOVE_SPEED = 0.2f;

		private const float ROTATION_SPEED = 75f;

		private readonly KeyCode u;

		private readonly KeyCode d;

		private readonly KeyCode l;

		private readonly KeyCode r;

		private readonly KeyCode f;

		private readonly KeyCode b;

		private readonly KeyCode back;

		private readonly KeyCode button;

		private readonly KeyCode axis;

		private readonly KeyCode rotationMode;

		private readonly KeyCode mouseMode;

		private readonly KeyCode menu;

		private readonly int mButton;

		private readonly Vector2 defaultAxis;

		private Vector3 localPos;

		private Quaternion localRot;

		private bool axisMoved;

		private Vector3 axisPos;

		private Vector3 lastAxisPos;

		private AxisState axisState;

		private bool right;

		private Vector3 MouseMoveScale => DEF_M_MOVE;

		private Vector3 KeyMoveScale => DEF_K_MOVE;

		private Vector3 MouseRotScale => DEF_M_ROT;

		private Vector3 KeyRotScale => DEF_K_ROT;

		private bool MouseModeActive => Input.GetKey(mouseMode);

		public KBMInput(bool right)
		{
			u = (right ? KeyCode.Keypad8 : KeyCode.I);
			d = (right ? KeyCode.Keypad5 : KeyCode.K);
			l = (right ? KeyCode.Keypad4 : KeyCode.J);
			r = (right ? KeyCode.Keypad6 : KeyCode.L);
			f = (right ? KeyCode.Keypad7 : KeyCode.U);
			b = (right ? KeyCode.Keypad9 : KeyCode.O);
			mouseMode = (right ? KeyCode.RightControl : KeyCode.RightAlt);
			rotationMode = (right ? KeyCode.Keypad0 : KeyCode.B);
			this.right = right;
			back = KeyCode.T;
			button = (right ? KeyCode.Semicolon : KeyCode.KeypadEnter);
			mButton = (right ? 1 : 0);
			axis = (right ? KeyCode.Alpha2 : KeyCode.Alpha3);
			menu = (right ? KeyCode.RightShift : KeyCode.LeftShift);
			defaultAxis = (right ? Vector2.up : Vector2.zero);
			localPos = new Vector3(right ? 0.5f : (-0.5f), 0f, 1f);
			localRot = Quaternion.identity;
		}

		public void UpdateState(ref HandState state)
		{
			lastAxisPos = axisPos;
			axisPos = (Input.GetKey(KeyCode.Space) ? GetKeyboardAxis() : GetMouseAxis());
			axisMoved = axisPos != Vector3.zero;
			if (!Input.GetKey(KeyCode.Space))
			{
				axisMoved = false;
				if (Input.GetKey(rotationMode))
				{
					Vector3 scale = (MouseModeActive ? MouseRotScale : KeyRotScale);
					axisPos.Scale(scale);
					axisPos.Set(0f - axisPos.y, axisPos.x, axisPos.z);
					localRot *= Quaternion.Euler(axisPos * DeltaTime);
				}
				else
				{
					Vector3 scale2 = (MouseModeActive ? MouseMoveScale : KeyMoveScale);
					axisPos.Scale(scale2);
					localPos += axisPos * DeltaTime;
				}
			}
			float magnitude = lastAxisPos.magnitude;
			float magnitude2 = axisPos.magnitude;
			if (magnitude < 0.2f && magnitude2 > 0.2f)
			{
				axisState = AxisState.Down;
			}
			else if (magnitude > 0.2f && magnitude2 > 0.2f)
			{
				axisState = AxisState.Held;
			}
			else if (magnitude > 0.2f && magnitude2 < 0.2f)
			{
				axisState = AxisState.Up;
			}
			else if (magnitude < 0.2f && magnitude2 < 0.2f)
			{
				axisState = AxisState.None;
			}
			state.position = localPos;
			state.rotation = localRot;
			state.grip = (Input.GetMouseButton(mButton) ? 1f : 0f);
			state.trigger = (Input.GetMouseButton(mButton) ? 1f : 0f);
			state.stateTrigger |= (byte)(Input.GetMouseButtonDown(mButton) ? 1 : 0);
			state.stateTrigger |= (byte)(Input.GetMouseButton(mButton) ? 2 : 0);
			state.stateTrigger |= (byte)(Input.GetMouseButtonUp(mButton) ? 4 : 0);
			state.stateBack |= (byte)((right && Input.GetKeyDown(back)) ? 1 : 0);
			state.stateBack |= (byte)((right && Input.GetKey(back)) ? 2 : 0);
			state.stateBack |= (byte)((right && Input.GetKeyUp(back)) ? 4 : 0);
			state.stateButton |= (byte)(Input.GetKeyDown(button) ? 1 : 0);
			state.stateButton |= (byte)(Input.GetKey(button) ? 2 : 0);
			state.stateButton |= (byte)(Input.GetKeyUp(button) ? 4 : 0);
			state.stateGrip |= (byte)(Input.GetMouseButtonDown(mButton) ? 1 : 0);
			state.stateGrip |= (byte)(Input.GetMouseButton(mButton) ? 2 : 0);
			state.stateGrip |= (byte)(Input.GetMouseButtonUp(mButton) ? 4 : 0);
			state.stateAxis |= (byte)(Input.GetKeyDown(axis) ? 1 : 0);
			state.stateAxis |= (byte)(Input.GetKey(axis) ? 2 : 0);
			state.stateAxis |= (byte)(Input.GetKeyUp(axis) ? 4 : 0);
			state.stateMenu |= (byte)(Input.GetKeyDown(menu) ? 1 : 0);
			state.stateMenu |= (byte)(Input.GetKeyDown(menu) ? 2 : 0);
			state.stateMenu |= (byte)(Input.GetKeyDown(menu) ? 4 : 0);
			if (Input.GetKey(KeyCode.Space))
			{
				state.axis = (axisMoved ? ((Vector2)GetKeyboardAxis()) : defaultAxis);
			}
			state.axisState = axisState;
		}

		private Vector3 GetMouseAxis()
		{
			if (MouseModeActive)
			{
				return new Vector3(Input.GetAxisRaw("Mouse X"), Input.GetAxisRaw("Mouse Y"), Input.GetAxisRaw("Mouse ScrollWheel"));
			}
			return GetKeyboardAxis();
		}

		private Vector3 GetKeyboardAxis()
		{
			return (Input.GetKey(u) ? new Vector3(0f, 1f, 0f) : Vector3.zero) + (Input.GetKey(d) ? new Vector3(0f, -1f, 0f) : Vector3.zero) + (Input.GetKey(l) ? new Vector3(-1f, 0f, 0f) : Vector3.zero) + (Input.GetKey(r) ? new Vector3(1f, 0f, 0f) : Vector3.zero) + (Input.GetKey(f) ? new Vector3(0f, 0f, 1f) : Vector3.zero) + (Input.GetKey(b) ? new Vector3(0f, 0f, -1f) : Vector3.zero);
		}
	}

	private class TouchInput
	{
		protected readonly OVRInput.Controller ctrl;

		protected readonly OVRInput.RawAxis2D ax;

		protected readonly OVRInput.RawAxis1D tAx;

		protected readonly OVRInput.RawAxis1D hAx;

		protected readonly OVRInput.RawButton tBut;

		protected readonly OVRInput.RawButton gBut;

		protected readonly OVRInput.RawButton mBut;

		protected readonly OVRInput.RawButton bBut;

		protected readonly OVRInput.RawButton axBut;

		protected readonly OVRInput.RawButton menuBut;

		private readonly XRNode vrNode;

		private Vector2 axisPos;

		private Vector2 lastAxisPos;

		private Vector3 lastTrackedPos;

		private Quaternion lastTrackedRot;

		private AxisState axisState;

		private bool backConsumed;

		private OVRPlugin.ControllerState4 cStateCurr;

		private OVRPlugin.ControllerState4 cStatePrev;

		public TouchInput(bool right)
		{
			ctrl = ((!right) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
			ax = ((!right) ? OVRInput.RawAxis2D.LThumbstick : OVRInput.RawAxis2D.RThumbstick);
			tAx = ((!right) ? OVRInput.RawAxis1D.LIndexTrigger : OVRInput.RawAxis1D.RIndexTrigger);
			hAx = (right ? OVRInput.RawAxis1D.RHandTrigger : OVRInput.RawAxis1D.LHandTrigger);
			tBut = (right ? OVRInput.RawButton.RIndexTrigger : OVRInput.RawButton.LIndexTrigger);
			gBut = (right ? OVRInput.RawButton.RHandTrigger : OVRInput.RawButton.LHandTrigger);
			mBut = (right ? OVRInput.RawButton.A : OVRInput.RawButton.X);
			bBut = (right ? OVRInput.RawButton.B : OVRInput.RawButton.Y);
			axBut = (right ? OVRInput.RawButton.RThumbstick : OVRInput.RawButton.LThumbstick);
			menuBut = (right ? OVRInput.RawButton.Start : OVRInput.RawButton.Start);
			vrNode = (right ? XRNode.RightHand : XRNode.LeftHand);
			lastTrackedRot = Quaternion.identity;
		}

		private bool _GetDown(OVRInput.RawButton mask)
		{
			if ((cStateCurr.Buttons & (uint)mask) != 0 && (cStatePrev.Buttons & (uint)mask) == 0)
			{
				return true;
			}
			return false;
		}

		private bool _GetUp(OVRInput.RawButton mask)
		{
			if ((cStateCurr.Buttons & (uint)mask) == 0 && (cStatePrev.Buttons & (uint)mask) != 0)
			{
				return true;
			}
			return false;
		}

		private bool _Get(OVRInput.RawButton mask)
		{
			if ((cStateCurr.Buttons & (uint)mask) != 0)
			{
				return true;
			}
			return false;
		}

		public void UpdateState(ref HandState state)
		{
			bool flag = ctrl == OVRInput.Controller.LTouch;
			OVRPlugin.Controller controllerMask = (flag ? OVRPlugin.Controller.LTouch : OVRPlugin.Controller.RTouch);
			cStatePrev = cStateCurr;
			cStateCurr = OVRPlugin.GetControllerState4((uint)controllerMask);
			if (cStateCurr.LIndexTrigger >= 0.5f)
			{
				cStateCurr.Buttons |= 268435456u;
			}
			if (cStateCurr.LHandTrigger >= 0.5f)
			{
				cStateCurr.Buttons |= 536870912u;
			}
			if (cStateCurr.LThumbstick.y >= 0.5f)
			{
				cStateCurr.Buttons |= 16u;
			}
			if (cStateCurr.LThumbstick.y <= -0.5f)
			{
				cStateCurr.Buttons |= 32u;
			}
			if (cStateCurr.LThumbstick.x <= -0.5f)
			{
				cStateCurr.Buttons |= 64u;
			}
			if (cStateCurr.LThumbstick.x >= 0.5f)
			{
				cStateCurr.Buttons |= 128u;
			}
			if (cStateCurr.RIndexTrigger >= 0.5f)
			{
				cStateCurr.Buttons |= 67108864u;
			}
			if (cStateCurr.RHandTrigger >= 0.5f)
			{
				cStateCurr.Buttons |= 134217728u;
			}
			if (cStateCurr.RThumbstick.y >= 0.5f)
			{
				cStateCurr.Buttons |= 4096u;
			}
			if (cStateCurr.RThumbstick.y <= -0.5f)
			{
				cStateCurr.Buttons |= 8192u;
			}
			if (cStateCurr.RThumbstick.x <= -0.5f)
			{
				cStateCurr.Buttons |= 16384u;
			}
			if (cStateCurr.RThumbstick.x >= 0.5f)
			{
				cStateCurr.Buttons |= 32768u;
			}
			lastAxisPos = axisPos;
			axisPos = ((ctrl == OVRInput.Controller.LTouch) ? new Vector2(cStateCurr.LThumbstick.x, cStateCurr.LThumbstick.y) : new Vector2(cStateCurr.RThumbstick.x, cStateCurr.RThumbstick.y));
			float magnitude = lastAxisPos.magnitude;
			float magnitude2 = axisPos.magnitude;
			if (magnitude < 0.2f && magnitude2 > 0.2f)
			{
				axisState = AxisState.Down;
			}
			else if (magnitude > 0.2f && magnitude2 > 0.2f)
			{
				axisState = AxisState.Held;
			}
			else if (magnitude > 0.2f && magnitude2 < 0.2f)
			{
				axisState = AxisState.Up;
			}
			else if (magnitude < 0.2f && magnitude2 < 0.2f)
			{
				axisState = AxisState.None;
			}
			state.grip = (flag ? cStateCurr.LHandTrigger : cStateCurr.RHandTrigger);
			state.grip = OVRInput.CalculateDeadzone(state.grip, 0.2f);
			state.trigger = (flag ? cStateCurr.LIndexTrigger : cStateCurr.RIndexTrigger);
			state.trigger = OVRInput.CalculateDeadzone(state.trigger, 0.2f);
			state.axis = axisPos;
			state.axisState = axisState;
			state.stateTrigger |= (byte)(_GetDown(tBut) ? 1 : 0);
			state.stateTrigger |= (byte)(_Get(tBut) ? 2 : 0);
			state.stateTrigger |= (byte)(_GetUp(tBut) ? 4 : 0);
			state.stateBack |= (byte)(_GetDown(bBut) ? 1 : 0);
			state.stateBack |= (byte)(_Get(bBut) ? 2 : 0);
			state.stateBack |= (byte)(_GetUp(bBut) ? 4 : 0);
			state.stateButton |= (byte)(_GetDown(mBut) ? 1 : 0);
			state.stateButton |= (byte)(_Get(mBut) ? 2 : 0);
			state.stateButton |= (byte)(_GetUp(mBut) ? 4 : 0);
			state.stateGrip |= (byte)(_GetDown(gBut) ? 1 : 0);
			state.stateGrip |= (byte)(_Get(gBut) ? 2 : 0);
			state.stateGrip |= (byte)(_GetUp(gBut) ? 4 : 0);
			state.stateAxis |= (byte)(_GetDown(axBut) ? 1 : 0);
			state.stateAxis |= (byte)(_Get(axBut) ? 2 : 0);
			state.stateAxis |= (byte)(_GetUp(axBut) ? 4 : 0);
			state.stateMenu |= (byte)(_GetDown(menuBut) ? 1 : 0);
			state.stateMenu |= (byte)(_Get(menuBut) ? 2 : 0);
			state.stateMenu |= (byte)(_GetUp(menuBut) ? 4 : 0);
			if (OVRInput.GetControllerPositionTracked(ctrl))
			{
				lastTrackedPos = OVRInput.GetLocalControllerPosition(ctrl);
			}
			if (OVRInput.GetControllerOrientationTracked(ctrl))
			{
				lastTrackedRot = OVRInput.GetLocalControllerRotation(ctrl);
			}
			OVRInput.RawTouch rawTouch = (flag ? (OVRInput.RawTouch.X | OVRInput.RawTouch.Y | OVRInput.RawTouch.LThumbstick | OVRInput.RawTouch.LThumbRest | OVRInput.RawTouch.LTouchpad) : (OVRInput.RawTouch.RTouchpad | OVRInput.RawTouch.A | OVRInput.RawTouch.B | OVRInput.RawTouch.RThumbstick | OVRInput.RawTouch.RThumbRest));
			OVRInput.RawTouch rawTouch2 = (flag ? OVRInput.RawTouch.LIndexTrigger : OVRInput.RawTouch.RIndexTrigger);
			state.thumbTouch = (byte)(((cStateCurr.Touches & (uint)rawTouch) != 0) ? 1u : 0u);
			state.indexTouch = (byte)(((cStateCurr.Touches & (uint)rawTouch2) != 0) ? 1u : 0u);
			state.position = lastTrackedPos;
			state.rotation = lastTrackedRot;
		}
	}

	private const string EDITOR_PREFS_KEY = "NEXUS.IC";

	private const string MOUSE_X = "Mouse X";

	private const string MOUSE_Y = "Mouse Y";

	private const string MOUSE_Z = "Mouse ScrollWheel";

	public bool InputIntercept;

	public bool MainMenuIntercept;

	protected static IC _instance;

	[NonSerialized]
	[HideInInspector]
	public UIButton ButtonCurrentFocused;

	private HagletValue<RecordMode> recordMode;

	private HagletTrigger onStateUpdate;

	private UIButton buttonCurrent;

	private IHandInput[] handInputs = new IHandInput[2];

	private TouchInput[] touchInputs = new TouchInput[2];

	private KBMInput[] kbmInputs = new KBMInput[2];

	private const byte STATE_DOWN = 1;

	private const byte STATE_HELD = 2;

	private const byte STATE_UP = 4;

	private static InputState state;

	public static bool isHmdPresent;

	[NonSerialized]
	[HideInInspector]
	public bool PauseMenuEnabled = true;

	[NonSerialized]
	[HideInInspector]
	public bool RecenterEnabled = true;

	private IHaglet<string> recordingRoutine;

	private IHaglet<string> replayRoutine;

	public static IC Inst => _instance;

	private Wait RecordReplayStop => Wait.For.Value(recordMode, RecordMode.StopStarting, 1, allowPreMetNow: true);

	public static float DeltaTimeUnclamped => state.deltaTime;

	public static float DeltaTime
	{
		get
		{
			if (Haglet.inOne && Routine.Skipping)
			{
				return 1f / 60f;
			}
			float deltaTime = state.deltaTime;
			float timeScale = UnityEngine.Time.timeScale;
			return Mathf.Clamp(deltaTime, timeScale / 240f, timeScale / 15f);
		}
	}

	public static float RealDeltaTime
	{
		get
		{
			if (Haglet.inOne && Routine.Skipping)
			{
				return 1f / 60f;
			}
			return Mathf.Clamp(state.realDeltaTime, 0.004166667f, 1f / 15f);
		}
	}

	public static float Time => state.time;

	public static string RecordingPath => UnityEngine.Application.persistentDataPath + "/InputRecordings";

	public static bool IsRecording => Inst.recordMode.value == RecordMode.Recording;

	public static bool IsReplaying => Inst.recordMode.value == RecordMode.Replaying;

	private static void PreferencedGUI()
	{
	}

	public static void OpenRecordingsFolder()
	{
		UnityEngine.Application.OpenURL("file://" + RecordingPath);
	}

	public void OnAwakeLR()
	{
		_instance = this;
		handInputs[0] = new IHandInput(right: false);
		handInputs[1] = new IHandInput(right: true);
		touchInputs[0] = new TouchInput(right: false);
		touchInputs[1] = new TouchInput(right: true);
		OVRPlugin.SetTrackingOriginType(OVRPlugin.TrackingOrigin.FloorLevel);
		Haglet.Create(out recordingRoutine, (Routine.Func1<string>)RecordingRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out replayRoutine, (Routine.Func1<string>)ReplayRoutine, (string)null, startNow: false, (int?)null, (string)null);
		HagletValue.Create(out recordMode, null, RecordMode.Ready);
		onStateUpdate = new HagletTrigger("IC.StateUpdate");
	}

	public void OnUpdateLR()
	{
		isHmdPresent = OVRPlugin.hmdPresent;
		if (recordMode.value != RecordMode.Replaying)
		{
			if (OVRPlugin.hasVrFocus)
			{
				state.handL = default(HandState);
				state.handL.rotation = QuaternionX.identity;
				state.handR = default(HandState);
				state.handR.rotation = QuaternionX.identity;
				state.combined = default(HandState);
				state.combined.rotation = QuaternionX.identity;
				if (!InputIntercept)
				{
					touchInputs[0].UpdateState(ref state.handL);
					touchInputs[1].UpdateState(ref state.handR);
					state.combined = HandState.Combine(ref state.handL, ref state.handR);
				}
				state.deltaTime = UnityEngine.Time.deltaTime;
				float realtimeSinceStartup = UnityEngine.Time.realtimeSinceStartup;
				state.realDeltaTime = realtimeSinceStartup - state.timeSinceStartup;
				state.timeSinceStartup = realtimeSinceStartup;
				state.time = UnityEngine.Time.time;
				UpdateHeadPosition();
			}
			else
			{
				state.handL.axis = Vector2.zero;
				state.handL.axisState = AxisState.None;
				state.handL.stateBack = 0;
				state.handL.stateButton = 0;
				state.handL.stateTrigger = 0;
				state.handL.stateGrip = 0;
				state.handL.stateMenu = 0;
				state.handL.stateAxis = 0;
				state.handR.axis = Vector2.zero;
				state.handR.axisState = AxisState.None;
				state.handR.stateBack = 0;
				state.handR.stateButton = 0;
				state.handR.stateTrigger = 0;
				state.handR.stateGrip = 0;
				state.handR.stateMenu = 0;
				state.handR.stateAxis = 0;
			}
			if (MainMenuIntercept)
			{
				state.handL.axis = Vector2.zero;
				state.handL.axisState = AxisState.None;
				state.handL.stateMenu = 0;
				state.combined.stateMenu = 0;
			}
		}
		onStateUpdate.Trigger();
		bool actionTriggered = ((CC.Inst.lastHandInput == Hand.Left) ? ((state.handL.stateTrigger & 1) != 0) : ((state.handR.stateTrigger & 1) != 0));
		int layerMask = 524320;
		Ray handRay = CC.Inst.GetHandRay();
		if (Physics.Raycast(handRay.origin, handRay.direction, out var hitInfo, float.MaxValue, layerMask))
		{
			HandleLookedAtCollider(hitInfo, ref actionTriggered);
		}
		else
		{
			if (actionTriggered && (bool)buttonCurrent)
			{
				buttonCurrent.TapUp();
				actionTriggered = false;
			}
			if ((bool)ButtonCurrentFocused)
			{
				ButtonCurrentFocused.FocusExit();
			}
			ButtonCurrentFocused = null;
			buttonCurrent = null;
		}
		if (actionTriggered)
		{
			actionTriggered = false;
		}
		if (OVRPlugin.shouldRecenter)
		{
			CC.Inst.Recenter();
		}
		UIPauseMenu inst = UIPauseMenu.Inst;
		if (LR.Inst.AreAllLoadedScenesAwake && ((uint)state.combined.stateMenu & (true ? 1u : 0u)) != 0 && PauseMenuEnabled)
		{
			if (!LR.Inst.IsMenuActive())
			{
				LR.Inst.Pause(paused: true);
				inst.ShowPauseMenu(default(UIPauseMenuShowOptions));
			}
			else if (inst.IsShown && !inst.IsAnimating())
			{
				LR.Inst.Pause(paused: false);
				inst.HideBook();
			}
		}
		if (inst.IsShown && ((uint)state.combined.stateBack & (true ? 1u : 0u)) != 0 && inst.InputReturnMenu())
		{
			state.handL.stateBack = 0;
			state.handR.stateBack = 0;
			state.combined.stateBack = 0;
		}
	}

	private void HandleLookedAtCollider(RaycastHit hit, ref bool actionTriggered)
	{
		UIButton uIButton = null;
		int layer = hit.collider.gameObject.layer;
		if (layer == 5 || layer == 19)
		{
			uIButton = hit.collider.GetComponent<UIButton>();
			if (uIButton == null)
			{
				UISubButton component = hit.collider.GetComponent<UISubButton>();
				if ((bool)component)
				{
					uIButton = component.parentButton;
				}
			}
		}
		if (uIButton != null && (!uIButton.enabled || !uIButton.interactable))
		{
			uIButton = null;
		}
		if (uIButton == null)
		{
			if ((bool)ButtonCurrentFocused)
			{
				ButtonCurrentFocused.FocusExit();
			}
			ButtonCurrentFocused = null;
			buttonCurrent = null;
			return;
		}
		if (ButtonCurrentFocused == null)
		{
			ButtonCurrentFocused = uIButton;
			ButtonCurrentFocused.FocusEnter();
		}
		if (ButtonCurrentFocused != uIButton)
		{
			ButtonCurrentFocused.FocusExit();
			ButtonCurrentFocused = uIButton;
			ButtonCurrentFocused.FocusEnter();
		}
		if (uIButton == null && ButtonCurrentFocused != null)
		{
			ButtonCurrentFocused.FocusExit();
			ButtonCurrentFocused = null;
		}
		if (ButtonCurrentFocused != null)
		{
			ButtonCurrentFocused.FocusStay();
		}
		if (((uint)state.combined.stateTrigger & (true ? 1u : 0u)) != 0 && buttonCurrent == null)
		{
			buttonCurrent = uIButton;
			buttonCurrent.TapDown();
		}
		if ((state.combined.stateTrigger & 2u) != 0 && buttonCurrent != null)
		{
			buttonCurrent.TapHeld();
		}
		if (actionTriggered && buttonCurrent != null && buttonCurrent.TapUp())
		{
			actionTriggered = false;
		}
		if ((state.combined.stateTrigger & 2) == 0 && buttonCurrent != null)
		{
			buttonCurrent = null;
		}
	}

	private void ProcessInputData()
	{
	}

	public static Vector3 GetHeadPosition()
	{
		return CC.Inst.transform.TransformPoint(state.headLocalPos);
	}

	public static Vector3 GetHeadLocalPosition()
	{
		return state.headLocalPos;
	}

	public static Quaternion GetHeadLocalRotation()
	{
		return state.headLocalRot;
	}

	public static Quaternion GetHeadRotation()
	{
		return CC.Inst.transform.rotation * state.headLocalRot;
	}

	public static IHandInput GetInputForHand(Hand hand)
	{
		return Inst.handInputs[(int)hand];
	}

	public static float GetProfileEyeHeight(float min = 0f)
	{
		return Mathf.Max(OVRManager.profile.eyeHeight, min);
	}

	public void UpdateHeadPosition()
	{
		Transform transform = MainCamera.Inst.transform;
		Transform transform2 = CC.Inst.transform;
		state.headLocalPos = transform2.InverseTransformPoint(transform.position);
		state.headLocalRot = transform2.rotation.InverseTransformRotation(transform.rotation);
	}

	private static byte[] StructToBytes<T>(T state) where T : struct
	{
		int num = Marshal.SizeOf(state);
		IntPtr intPtr = Marshal.AllocHGlobal(num);
		byte[] array = new byte[num];
		Marshal.StructureToPtr(state, intPtr, fDeleteOld: true);
		Marshal.Copy(intPtr, array, 0, num);
		Marshal.FreeHGlobal(intPtr);
		return array;
	}

	private static bool StructFromBinaryReader<T>(BinaryReader reader, ref T data) where T : struct
	{
		Marshal.SizeOf(data);
		if (reader.BaseStream.Position != reader.BaseStream.Length)
		{
			GCHandle gCHandle = GCHandle.Alloc(reader.ReadBytes(Marshal.SizeOf(typeof(T))), GCHandleType.Pinned);
			data = (T)Marshal.PtrToStructure(gCHandle.AddrOfPinnedObject(), typeof(T));
			gCHandle.Free();
			return true;
		}
		return false;
	}

	public static void RecordingStart(string fileName = null)
	{
		if (Inst.recordMode.value == RecordMode.Ready)
		{
			Inst.recordingRoutine.Start(fileName);
		}
	}

	public static void RecordingStop()
	{
		if (IsRecording)
		{
			Inst.recordMode.value = RecordMode.StopStarting;
		}
	}

	private IEnumerator<Routine.Yield> RecordingRoutine(string filename)
	{
		UnityEngine.Debug.Log("Recording started: " + filename);
		Inst.recordMode.value = RecordMode.StopStarting;
		SceneInfo sceneInfo = MainCamera.Inst.GetOwner().info.Load();
		yield return LR.Inst.LoadPlayerIntoScene(sceneInfo);
		if (filename == null)
		{
			filename = sceneInfo.prettyName + DateTime.Now.ToString("_yy-MM-dd_HH-mm-ss");
		}
		string text = RecordingPath + "/" + filename + ".bin";
		Directory.CreateDirectory(Path.GetDirectoryName(text));
		UnityEngine.Debug.Log("IC.RecordingStart: " + text);
		FileStream output = new FileStream(text, FileMode.Create, FileAccess.Write, FileShare.ReadWrite);
		BinaryWriter writer = new BinaryWriter(output, Encoding.Default);
		writer.Write(4);
		writer.Write(sceneInfo.sceneUIDName);
		writer.Write((int)BaseSettings<TeleportSettings>.Inst.InputMode);
		writer.Write(BaseSettings<TeleportSettings>.Inst.FreeMoveSpeed);
		Vector3 position = CC.Inst.transform.position;
		Quaternion rotation = CC.Inst.transform.rotation;
		writer.Write(position.x);
		writer.Write(position.y);
		writer.Write(position.z);
		writer.Write(rotation.x);
		writer.Write(rotation.y);
		writer.Write(rotation.z);
		writer.Write(rotation.w);
		Inst.recordMode.value = RecordMode.Recording;
		while (true)
		{
			yield return onStateUpdate | RecordReplayStop;
			if (!IsRecording)
			{
				break;
			}
			writer.Write(StructToBytes(state));
		}
		UnityEngine.Debug.Log("Recording stopped: " + filename);
		writer.Close();
		yield return Wait.For.Updates(1);
		UnityEngine.Debug.Log("Recording available again");
		recordMode.value = RecordMode.Ready;
	}

	public static void Replay(string filepath)
	{
		if (Inst.recordMode.value == RecordMode.Ready)
		{
			Inst.replayRoutine.Start(filepath);
		}
	}

	public static void ReplayStop()
	{
		if (IsReplaying)
		{
			Inst.recordMode.value = RecordMode.StopStarting;
		}
	}

	private IEnumerator<Routine.Yield> ReplayRoutine(string filepath)
	{
		FileStream input = new FileStream(filepath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
		BinaryReader reader = new BinaryReader(input, Encoding.Default);
		int num = reader.ReadInt32();
		if (num < 4)
		{
			UnityEngine.Debug.Log("Recording format version " + num + " is not supported, must be " + 4 + " or greater.");
			reader.Close();
			yield break;
		}
		UnityEngine.Debug.Log("Replay started: " + filepath);
		recordMode.value = RecordMode.StopStarting;
		MainCamera.Inst.cameraComp.stereoTargetEye = StereoTargetEyeMask.None;
		GameObject tempCamGO = new GameObject("Recording Playback View Camera");
		tempCamGO.transform.SetParent(CC.Inst.transform, worldPositionStays: false);
		tempCamGO.transform.localPosition = Vector3.zero;
		tempCamGO.transform.localRotation = Quaternion.identity;
		Camera camera = tempCamGO.AddComponent<Camera>();
		camera.CopyFrom(MainCamera.Inst.cameraComp);
		camera.cullingMask = -1;
		camera.stereoTargetEye = StereoTargetEyeMask.Both;
		camera.clearFlags = CameraClearFlags.Color;
		UnityEngine.Debug.Log("Reading recording format version " + num);
		TeleportSettings.Mode curInputMode = BaseSettings<TeleportSettings>.Inst.InputMode;
		TeleportSettings.SpeedSetting curMoveSpeed = LR.Inst.saveDataSettings.freeMoveSpeed;
		string text = reader.ReadString();
		int inputMode = reader.ReadInt32();
		reader.ReadInt32();
		reader.ReadSingle();
		Vector3 value = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
		Quaternion value2 = new Quaternion(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
		SceneInfo sceneInfoWithSceneUIDName = LR.Inst.GetSceneInfoWithSceneUIDName(text);
		if ((bool)sceneInfoWithSceneUIDName)
		{
			BaseSettings<TeleportSettings>.Inst.InputMode = (TeleportSettings.Mode)inputMode;
			yield return LR.Inst.LoadPlayerIntoScene(sceneInfoWithSceneUIDName, value, value2, shouldFadeToClearAtEndOfRoutine: true);
			recordMode.value = RecordMode.Replaying;
		}
		else
		{
			UnityEngine.Debug.Log("Failed to Replay: " + text);
		}
		while (true)
		{
			yield return onStateUpdate | RecordReplayStop;
			if (!IsReplaying)
			{
				break;
			}
			if (StructFromBinaryReader(reader, ref state))
			{
				Transform obj = MainCamera.Inst.transform;
				Transform transform = CC.Inst.transform;
				obj.position = transform.TransformPoint(state.headLocalPos);
				obj.rotation = transform.rotation * state.headLocalRot;
			}
			else
			{
				ReplayStop();
			}
		}
		UnityEngine.Debug.Log("Replay stopped: " + filepath);
		reader.Close();
		MainCamera.Inst.transform.localPosition = Vector3.zero;
		MainCamera.Inst.transform.localRotation = Quaternion.identity;
		MainCamera.Inst.cameraComp.stereoTargetEye = StereoTargetEyeMask.Both;
		UnityEngine.Object.Destroy(tempCamGO);
		BaseSettings<TeleportSettings>.Inst.InputMode = curInputMode;
		LR.Inst.saveDataSettings.freeMoveSpeed = curMoveSpeed;
		yield return Wait.For.Updates(1);
		UnityEngine.Debug.Log("Recording available again");
		recordMode.value = RecordMode.Ready;
	}

	public bool ControllersAreActive()
	{
		OVRPlugin.Controller connectedControllers = OVRPlugin.GetConnectedControllers();
		OVRPlugin.Controller controller = OVRPlugin.Controller.Touch;
		OVRPlugin.Controller controller2 = (OVRPlugin.Controller)50331648;
		if ((connectedControllers & controller) != controller)
		{
			return (connectedControllers & controller2) == controller2;
		}
		return true;
	}

	public bool HeadsetIsActive()
	{
		if (!LR.Inst.allowUpdates)
		{
			return OVRPlugin.hmdPresent;
		}
		return isHmdPresent;
	}
}
public class LR : RootBase, Serializer.IUnityObjectSerializer
{
	public enum NexusPlatform
	{
		RIFT,
		QUEST
	}

	public delegate void INTERNAL_get_worldToLocalMatrix(Transform xForm, ref Matrix4x4 value);

	public delegate void INTERNAL_get_localToWorldMatrix(Transform xForm, ref Matrix4x4 value);

	public delegate void LookRotation_Injected(ref Vector3 forward, ref Vector3 upwards, out Quaternion ret);

	public unsafe delegate JobHandle ScheduleRaycastBatch(ref JobsUtility.JobScheduleParameters parameters, void* commands, int commandLen, void* result, int resultLen, int minCommandsPerJob);

	public struct RayPortalResult
	{
		public Ray ray;

		public Portal portal;

		public RaycastHit hit;

		public float length;
	}

	public const int MAX_OPEN_SCENES = 16;

	private const int SPAWNER_ARRAY_SIZE = 50;

	public static LR Inst;

	private HagletTrigger _onUpdate = new HagletTrigger("Update", null, 64);

	private HagletTrigger _onLateUpdate = new HagletTrigger("Late Update", null, 64);

	private HagletTrigger _onPrePhysicsUpdate = new HagletTrigger("Pre Physics Update", null, 64);

	private HagletTrigger _onPostPhysicsUpdate = new HagletTrigger("Post Physics Update", null, 64);

	private HagletTrigger _onPauseUpdate = new HagletTrigger("Pause Update", null, 64);

	private HagletTrigger _onRealTimeUpdate = new HagletTrigger("Realtime Update", null, 64);

	private HagletTrigger _onRealTimeLateUpdate = new HagletTrigger("Realtime Late Update", null, 64);

	private HagletTrigger _OnRenderPipelineStart = new HagletTrigger("Render Pipeline Start", null, 64);

	private PoolUpdateRunner poolUpdater;

	[ReadOnly]
	public SceneInfo_BundleRef[] sceneInfoRefs;

	[HideInInspector]
	public SceneInfoGroup_BundleRef[] sceneInfoGroupRefs;

	[HideInInspector]
	public SceneInfoGroup[] sceneInfoGroups;

	private Dictionary<string, SceneInfo> sceneUIDName_To_SceneInfo = new Dictionary<string, SceneInfo>();

	private IDPool32 sceneMaskPool = new IDPool32();

	private PlatformManager platformManager;

	private bool lastMenuActive;

	private FMOD.Studio.EventInstance musicInstance;

	private FMOD.Studio.EventInstance portalIdleInstance;

	[NonSerialized]
	public FMOD.Studio.EventInstance HACK_soundRadio;

	private float HACK_soundRadioParam;

	[NonSerialized]
	public bool HACK_soundRadioDream;

	[NonSerialized]
	public bool HACK_soundRadioStartFade;

	[NonSerialized]
	public Vector3 HACK_radioPos;

	private FMOD.Studio.EventInstance musicOneshotInstance;

	private FMODEventAsset currentMusic;

	[NonSerialized]
	[HideInInspector]
	public bool hasFocus = true;

	public readonly Dictionary<string, IDObject> idObjects = new Dictionary<string, IDObject>(128);

	private float errorTimer;

	[SerializeField]
	private RasterizerSettings rasterizerSettings;

	[SerializeField]
	private TeleportSettings teleportSettings;

	[SerializeField]
	private InventorySettings inventorySettings;

	[SerializeField]
	private InteractionSettings interactionSettings;

	[SerializeField]
	private FrustumSettings frustumSettings;

	[SerializeField]
	private ObeliskSettings obeliskSettings;

	[SerializeField]
	private PortalSettings portalSettings;

	[SerializeField]
	private OcclusionSettings occlusionSettings;

	[SerializeField]
	private TutorialSettings tutorialSettings;

	[SerializeField]
	private LightSettings lightSettings;

	[SerializeField]
	private HelperSettings helperSettings;

	[SerializeField]
	private VOSettings voSettings;

	[SerializeField]
	private ODZSettings odzSettings;

	[SerializeField]
	private VaultSettings vaultSettings;

	[SerializeField]
	private GearSettings gearSettings;

	[SerializeField]
	private FramerateTestSettings framerateTestSettings;

	[SerializeField]
	private UISettings uiSettings;

	[SerializeField]
	private ShaderVariantStorage svs;

	[SerializeField]
	private Light HACK_light;

	public static INTERNAL_get_worldToLocalMatrix fast_worldToLocalMatrix;

	public static INTERNAL_get_localToWorldMatrix fast_localToWorldMatrix;

	public static LookRotation_Injected fast_LookRotation;

	public static ScheduleRaycastBatch ScheduleRaycastBatchWithLength;

	private bool collectedGC;

	public bool allowUpdates;

	private bool onPauseMenuNotShown;

	private ConstArray<KubrickAnimClip> kubricksToUnload = new ConstArray<KubrickAnimClip>(128u);

	private ConstArray<Material> atlasMatsToUnload = new ConstArray<Material>(128u);

	private ConstArray<Texture> atlasTextureToUnload = new ConstArray<Texture>(128u);

	public ConstArray<MRBase> mrsLoaded = new ConstArray<MRBase>(16u);

	public ConstArray<MRBase> mrsToUnload = new ConstArray<MRBase>(16u);

	private ConstArray<GrabObjectSpawnPoint> loadedSpawnPoints = new ConstArray<GrabObjectSpawnPoint>(50u);

	private Dictionary<string, MRBase> sceneUIDName_To_LoadedMR = new Dictionary<string, MRBase>(16);

	private HagletValue<bool> isAllConnectedScenesLoaded;

	private HagletValue<bool> isAllConnectedScenesUnloaded;

	private const float maxPhysicsDelta = 1f / 30f;

	private const float minPhysicsDelta = 0f;

	private static string prevAudioOutId = string.Empty;

	public IHaglet shaderPrewarmRoutine;

	[HideInInspector]
	public IHaglet awakeLR;

	private IHaglet<SceneInfo> _loadSceneImpl;

	private ConstArray<MRBase> _notifyScenes = new ConstArray<MRBase>(4u);

	private ConstArray<SceneInfo> connectedScenes = new ConstArray<SceneInfo>(16u);

	private IHaglet<bool> loadAndUnloadAdjacentScenes;

	private IHaglet<SceneInfo, bool> sceneLoad;

	private string occlusionSceneNameLoaded;

	private IHaglet<SceneInfo, Vector3?, Quaternion?, bool> loadPlayerIntoSceneRoutine;

	private IHaglet<SceneInfo> sceneUnload;

	public IHaglet<MRBase> startCredits;

	private IHaglet<SceneInfo> framerateTestScene;

	private IHaglet collectPerfStatsForCurrentScene;

	private int HACK_tempVal;

	private static IHaglet<Transform, bool, bool> initialiseUIHierarchyRoutine;

	private static IHaglet<string, Transform, Vector3, Quaternion> onLoadUIResource;

	[NonSerialized]
	[HideInInspector]
	public bool IsPaused;

	[NonSerialized]
	[HideInInspector]
	public bool IsInCutscene;

	private FMOD.Studio.EventInstance evtDucker;

	public HagletTrigger onProfileSwitched = new HagletTrigger();

	private IHaglet saveRoutine;

	public IHaglet saveAfterScenesLoaded;

	public SaveDataSettings saveDataSettings;

	public SaveDataGame saveDataGame;

	private byte[] saveDataSettingsMem = new byte[4096];

	private byte[] saveDataGameMem = new byte[4194304];

	private MemoryStream saveDataSettingsMS;

	private MemoryStream saveDataGameMS;

	private HagletTrigger saveCompleteTrigger;

	private SaveLoad.ResultHandler saveCompleteHandler;

	private int saveCounter;

	public const int kSaveSlotCount = 2;

	public IHaglet<float, SceneInfo, MRBase> fadeAndSpawn;

	public IHaglet<bool> HACK_radioRoutine;

	public HagletEvent onUpdate => _onUpdate;

	public HagletEvent onLateUpdate => _onLateUpdate;

	public HagletEvent onPrePhysicsUpdate => _onPrePhysicsUpdate;

	public HagletEvent onPostPhysicsUpdate => _onPostPhysicsUpdate;

	public HagletEvent onPauseUpdate => _onPauseUpdate;

	public HagletEvent onRealTimeUpdate => _onRealTimeUpdate;

	public HagletEvent onRealTimeLateUpdate => _onRealTimeLateUpdate;

	public HagletEvent OnRenderPipelineStart => _OnRenderPipelineStart;

	public PlatformManager PlatformManager => platformManager;

	public bool MainMenuMode { get; set; }

	public Wait IsAllConnectedScenesLoaded => Wait.Until.True(isAllConnectedScenesLoaded, 1, allowPreMetNow: true);

	public Wait IsAllConnectedScenesUnloaded => Wait.Until.True(isAllConnectedScenesUnloaded, 1, allowPreMetNow: true);

	public bool AreAllLoadedScenesAwake
	{
		get
		{
			ConstArray<MRBase> constArray = mrsLoaded;
			for (int i = 0; i < constArray.sLength; i++)
			{
				if (!constArray[i].isAwake)
				{
					return false;
				}
			}
			return true;
		}
	}

	private void OnApplicationPause(bool pause)
	{
		hasFocus = !pause;
		if (!allowUpdates)
		{
			Time.timeScale = ((!pause) ? 1 : 0);
			return;
		}
		FAC.Inst.sys.getLowLevelSystem(out var system);
		if (pause)
		{
			system.mixerSuspend();
		}
		else
		{
			system.mixerResume();
		}
		UIPauseMenu inst = UIPauseMenu.Inst;
		inst?.RefreshPosition(default(UIPauseMenuShowOptions));
		if (pause)
		{
			if (IC.Inst.PauseMenuEnabled && !inst.IsShown && NexusFullScreenPass.Inst.IsClear())
			{
				inst?.ShowPauseMenu(default(UIPauseMenuShowOptions));
			}
			else if (!IsPaused)
			{
				onPauseMenuNotShown = true;
			}
			Pause(paused: true, lockMovement: false);
		}
		else if (onPauseMenuNotShown)
		{
			Pause(paused: false, lockMovement: false);
			onPauseMenuNotShown = false;
		}
	}

	public bool RegisterId(IDObject idObject)
	{
		if (idObject == null)
		{
			return false;
		}
		if (idObject.id != "error")
		{
			if (idObjects.ContainsKey(idObject.id))
			{
				if (idObject != idObjects[idObject.id])
				{
					_ = idObjects[idObject.id];
					return false;
				}
				return true;
			}
			idObjects.Add(idObject.id, idObject);
			return true;
		}
		UnityEngine.Debug.Log("IDObject has id of 'error'", idObject);
		return false;
	}

	public void DeregisterId(IDObject idObject)
	{
		idObjects.Remove(idObject.id);
	}

	public SceneInfo GetSceneInfoWithSceneUIDName(string sceneUIDName)
	{
		sceneUIDName_To_SceneInfo.TryGetValue(sceneUIDName, out var value);
		return value;
	}

	public uint GetSceneMask()
	{
		return sceneMaskPool.GetIDMask();
	}

	public void ReturnSceneMask(uint mask)
	{
		sceneMaskPool.ReturnIDMask(mask);
	}

	public MRBase GetLoadedMRWithSceneUIDNameOrNull(string sceneUIDName)
	{
		if (!string.IsNullOrEmpty(sceneUIDName))
		{
			if (!sceneUIDName_To_LoadedMR.TryGetValue(sceneUIDName, out var value))
			{
				return null;
			}
			return value;
		}
		return null;
	}

	public bool IsAllConnectedSceneLoadingUnloadingComplete()
	{
		if (isAllConnectedScenesLoaded.value)
		{
			return isAllConnectedScenesUnloaded.value;
		}
		return false;
	}

	public PoolUpdateRunner GetPoolUpdater()
	{
		return poolUpdater;
	}

	private static bool EquivSceneName(string first, string second)
	{
		return Path.GetFileNameWithoutExtension(first).ToLower() == Path.GetFileNameWithoutExtension(second).ToLower();
	}

	public MRBase GetMRBaseWithSceneInfo(SceneInfo info)
	{
		for (int i = 0; i < mrsLoaded.Length; i++)
		{
			MRBase mRBase = mrsLoaded[i];
			if (mRBase.info.Load() == info)
			{
				return mRBase;
			}
		}
		return null;
	}

	public static void SetupFMODAudioDriverToRespectOculusAudioSettings()
	{
	}

	public static void SetClockLevels(int cpu, int gpu)
	{
		OVRManager.cpuLevel = cpu;
		OVRManager.gpuLevel = gpu;
	}

	public static void SetMultiResLevel(OVRPlugin.TiledMultiResLevel level)
	{
		OVRPlugin.tiledMultiResLevel = level;
	}

	private void Awake()
	{
		Inst = this;
		SetClockLevels(4, 5);
		SetMultiResLevel(OVRPlugin.TiledMultiResLevel.LMSMedium);
		Transform firstArgument = null;
		fast_worldToLocalMatrix = (INTERNAL_get_worldToLocalMatrix)Delegate.CreateDelegate(typeof(INTERNAL_get_worldToLocalMatrix), firstArgument, typeof(Transform).GetMethod("get_worldToLocalMatrix_Injected", BindingFlags.Instance | BindingFlags.NonPublic));
		fast_localToWorldMatrix = (INTERNAL_get_localToWorldMatrix)Delegate.CreateDelegate(typeof(INTERNAL_get_localToWorldMatrix), firstArgument, typeof(Transform).GetMethod("get_localToWorldMatrix_Injected", BindingFlags.Instance | BindingFlags.NonPublic));
		fast_LookRotation = (LookRotation_Injected)Delegate.CreateDelegate(typeof(LookRotation_Injected), typeof(Quaternion).GetMethod("LookRotation_Injected", BindingFlags.Static | BindingFlags.NonPublic));
		ScheduleRaycastBatchWithLength = (ScheduleRaycastBatch)Delegate.CreateDelegate(typeof(ScheduleRaycastBatch), typeof(RaycastCommand).GetMethod("ScheduleRaycastBatch", BindingFlags.Static | BindingFlags.NonPublic));
		Haglet.Create(out awakeLR, AwakeLR, null, startNow: true);
		Haglet.Create(out shaderPrewarmRoutine, ShaderPrewarmRoutine);
		Haglet.Create(out sceneLoad, (Routine.Func2<SceneInfo, bool>)_SceneLoad, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out sceneUnload, (Routine.Func1<SceneInfo>)_SceneUnload, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out loadAndUnloadAdjacentScenes, (Routine.Func1<bool>)LoadAndUnloadAdjacentScenes, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out initialiseUIHierarchyRoutine, (Routine.Func3<Transform, bool, bool>)InitialiseUIHierarchyRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out onLoadUIResource, (Routine.Func4<string, Transform, Vector3, Quaternion>)OnLoadUIResource, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out _loadSceneImpl, (Routine.Func1<SceneInfo>)_LoadSceneImpl, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out loadPlayerIntoSceneRoutine, (Routine.Func4<SceneInfo, Vector3?, Quaternion?, bool>)LoadPlayerIntoSceneRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out HACK_radioRoutine, (Routine.Func1<bool>)HACK_RadioRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out fadeAndSpawn, (Routine.Func3<float, SceneInfo, MRBase>)FadeAndSpawnRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out startCredits, (Routine.Func1<MRBase>)StartCreditsRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out saveAfterScenesLoaded, SaveAfterScenesLoadedRoutine);
		Haglet.Create(out saveRoutine, SaveRoutine);
		saveDataSettingsMS = new MemoryStream(saveDataSettingsMem);
		saveDataGameMS = new MemoryStream(saveDataGameMem);
		saveCompleteTrigger = new HagletTrigger();
		saveCompleteHandler = delegate
		{
			saveCompleteTrigger.Trigger();
		};
		base.gameObject.AddComponent<SaveLoad.DispatchRunner>();
		HagletValue.Create(out isAllConnectedScenesLoaded, "IsAllConnectedScenesLoaded", initVal: false, null, 128);
		HagletValue.Create(out isAllConnectedScenesUnloaded, null, initVal: false, null, 8);
		poolUpdater = GetComponentInChildren<PoolUpdateRunner>(includeInactive: true);
		Haglet.Create(out collectPerfStatsForCurrentScene, CollectPerfStatsForCurrentScene);
		platformManager = GetComponent<PlatformManager>();
	}

	private void OnDestroy()
	{
		LightSensor.UninitializeStatics();
		try
		{
			RasterizationController.Inst.StopThread();
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
		try
		{
			RasterizerNative.UnloadLibrary();
		}
		catch (Exception exception2)
		{
			UnityEngine.Debug.LogException(exception2);
		}
		awakeLR.Stop();
		Time.timeScale = 1f;
	}

	public static NexusPlatform GetPlatform()
	{
		return NexusPlatform.QUEST;
	}

	private static void HACK_UpdateEditorList()
	{
	}

	public void OnSpawnPointAwake(GrabObjectSpawnPoint spawnPoint)
	{
		loadedSpawnPoints.Add(spawnPoint);
	}

	public void OnSpawnPointDestroy(GrabObjectSpawnPoint spawnPoint)
	{
		loadedSpawnPoints.Remove(spawnPoint);
	}

	public void PrecacheTypes()
	{
		Serializer.PrecacheTypes(new Type[3]
		{
			typeof(SaveDataGame),
			typeof(SceneSaveData),
			typeof(SaveLoad.Metadata[])
		}, new Type[0], new Assembly[3]
		{
			typeof(GameObject).Assembly,
			typeof(SaveDataGame).Assembly,
			typeof(object).Assembly
		});
	}

	protected override void OnPrebuildSelf()
	{
		base.OnPrebuildSelf();
	}

	private static void JitMethod(MethodBase method)
	{
		try
		{
			if (!method.IsAbstract && !method.ContainsGenericParameters)
			{
				method.MethodHandle.GetFunctionPointer();
			}
		}
		catch
		{
		}
	}

	public static void ForceJit(Assembly assembly)
	{
		Type[] types = assembly.GetTypes();
		foreach (Type type in types)
		{
			ConstructorInfo[] constructors = type.GetConstructors(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			for (int j = 0; j < constructors.Length; j++)
			{
				JitMethod(constructors[j]);
			}
			MethodInfo[] methods = type.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			for (int j = 0; j < methods.Length; j++)
			{
				JitMethod(methods[j]);
			}
			PropertyInfo[] properties = type.GetProperties(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			foreach (PropertyInfo obj in properties)
			{
				JitMethod(obj.GetGetMethod());
				JitMethod(obj.GetSetMethod());
			}
		}
	}

	private SceneInfo GetStartingSceneInfo()
	{
		return Runtime.LoadAsset<SceneInfo>("Assets/_GameAssets/CustomAssets/SceneInfos/SC_TutorialSequence_LOGIC.asset");
	}

	private IEnumerator<Routine.Yield> ShaderPrewarmRoutine()
	{
		int num = 0;
		for (int i = 0; i < svs.variants.Length; i++)
		{
			ShaderVariantStorage.ShaderVariants shaderVariants = svs.variants[i];
			num += 2 << shaderVariants.keywords.Length;
		}
		Material prewarmMaterial = null;
		int shaderVarIdx = 0;
		int variantIdx = 0;
		CommandBuffer cb = new CommandBuffer();
		NexusRenderPipeline.PipelineEvent pipeEvent = NexusRenderPipeline.PipelineEvent.End;
		bool lighted = false;
		Transform camXForm = MainCamera.Inst.transform;
		Func<CommandBuffer> callback = delegate
		{
			Vector3 pos = camXForm.position + camXForm.forward * 5f;
			Quaternion identity = Quaternion.identity;
			Vector3 one = Vector3.one;
			cb.Clear();
			HACK_light.enabled = lighted;
			for (int j = 0; j < 1; j++)
			{
				ShaderVariantStorage.ShaderVariants shaderVariants3 = svs.variants[shaderVarIdx];
				for (int k = 0; k < shaderVariants3.keywords.Length; k++)
				{
					bool enableInstancing = ((variantIdx >> k) & 1) == 1;
					if (shaderVariants3.keywords[k] == "INSTANCING_ON")
					{
						prewarmMaterial.enableInstancing = enableInstancing;
					}
					else
					{
						prewarmMaterial.SetKeyword_NX(shaderVariants3.keywords[k], enableInstancing);
					}
				}
				cb.DrawMesh(svs.prewarmMesh, Matrix4x4.TRS(pos, identity, one), prewarmMaterial);
				variantIdx++;
			}
			return cb;
		};
		HACK_light.transform.position = camXForm.position + camXForm.forward * 5f + camXForm.up;
		NexusRenderPipeline.AddPipelineCallback(pipeEvent, callback);
		shaderVarIdx = 0;
		while (shaderVarIdx < svs.variants.Length)
		{
			ShaderVariantStorage.ShaderVariants shaderVariants2 = svs.variants[shaderVarIdx];
			prewarmMaterial = new Material(shaderVariants2.shader);
			int variantNum = 2 << shaderVariants2.keywords.Length;
			variantIdx = 0;
			while (variantIdx < variantNum)
			{
				yield return Wait.For.Updates(1);
				lighted = true;
				yield return Wait.For.Updates(1);
				lighted = false;
			}
			int num2 = shaderVarIdx + 1;
			shaderVarIdx = num2;
		}
		HACK_light.enabled = false;
		NexusRenderPipeline.RemovePipelineCallback(pipeEvent, callback);
	}

	private void RunInBackGroundIfInEditor()
	{
		UnityEngine.Application.runInBackground = false;
	}

	private IEnumerator<Routine.Yield> AwakeLR()
	{
		RunInBackGroundIfInEditor();
		ForceJit(typeof(LR).Assembly);
		GC.Collect();
		bool synchronousLoading = false;
		bool isEditor = false;
		bool disableSaveData = false;
		bool clearSaveDataOnStart = false;
		bool skipTitleSequence = false;
		bool isAndroid = true;
		if (isEditor && OVROverlayNexus.Inst == null)
		{
			GameObject obj = new GameObject("OVROverlay");
			obj.AddComponent<OVROverlayNexus>();
			UnityEngine.Object.DontDestroyOnLoad(obj);
		}
		BaseSettings<RasterizerSettings>.Init(rasterizerSettings);
		BaseSettings<TeleportSettings>.Init(teleportSettings);
		BaseSettings<InventorySettings>.Init(inventorySettings);
		BaseSettings<InteractionSettings>.Init(interactionSettings);
		BaseSettings<FrustumSettings>.Init(frustumSettings);
		BaseSettings<ObeliskSettings>.Init(obeliskSettings);
		BaseSettings<PortalSettings>.Init(portalSettings);
		BaseSettings<OcclusionSettings>.Init(occlusionSettings);
		BaseSettings<TutorialSettings>.Init(tutorialSettings);
		BaseSettings<LightSettings>.Init(lightSettings);
		BaseSettings<HelperSettings>.Init(helperSettings);
		BaseSettings<VOSettings>.Init(voSettings);
		BaseSettings<ODZSettings>.Init(odzSettings);
		BaseSettings<VaultSettings>.Init(vaultSettings);
		BaseSettings<GearSettings>.Init(gearSettings);
		BaseSettings<FramerateTestSettings>.Init(framerateTestSettings);
		BaseSettings<UISettings>.Init(uiSettings);
		SaveLoad.Retain(2, null, unthreaded: true, null, silent: true, log: false, GetSaveDataBasePath());
		Serializer.Retain();
		Serializer.SetUnityObjectSerializer(this);
		Serializer.AddExclude<JK3D>();
		Serializer.AddExcludeAssignablesTo<HagletEvent>();
		Serializer.AddExcludeAssignablesTo<FMOD.Studio.EventInstance>();
		Serializer.AddExcludeAssignablesTo<ParameterInstance>();
		if (!synchronousLoading)
		{
			FAC.AddThreadTask(delegate
			{
				PrecacheTypes();
			});
		}
		else
		{
			PrecacheTypes();
		}
		GetComponentInChildren<LoadingScreenController>(includeInactive: true).OnAwakeLR();
		GetComponentInChildren<IC>(includeInactive: true).OnAwakeLR();
		LoadingScreenController.Inst.ShowLoadingScreen();
		yield return Wait.For.Updates(1, allowPreMetNow: false, allowPreMetLater: false, asCoroutine: true);
		Runtime.Initialise();
		yield return Runtime.LoadAllBundles();
		yield return FAC.WaitThreadBusy;
		if (disableSaveData)
		{
			ClearSave();
		}
		else
		{
			if (isEditor && clearSaveDataOnStart)
			{
				ClearSave();
			}
			LoadSave();
		}
		NexusRenderPipeline.AddPipelineCallback(NexusRenderPipeline.PipelineEvent.Start, RenderPipelineEvent_Start);
		yield return Wait.For.Updates(1);
		FACMisc.PrefetchUnityPaths();
		yield return Wait.For.Updates(1);
		yield return Localisation.Inst.LoadLocalization(synchronousLoading);
		yield return Wait.For.Updates(1);
		UIErrorPrompt componentInChildren = GetComponentInChildren<UIErrorPrompt>();
		componentInChildren.Initialise();
		UIElement[] componentsInChildren = componentInChildren.GetComponentsInChildren<UIElement>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].OnAwakeLR();
		}
		UIErrorPrompt errorP = UIErrorPrompt.Inst;
		errorP.UpdateCamera(LoadingCamera.Inst.transform, loadingMode: true);
		float timeout = 5f;
		if (!isAndroid && (!IC.Inst.ControllersAreActive() || !IC.Inst.HeadsetIsActive()))
		{
			errorP.ShowErrorMessage();
			while (!IC.Inst.ControllersAreActive() || !IC.Inst.HeadsetIsActive())
			{
				errorP.UpdateError();
				timeout -= Time.unscaledDeltaTime;
				if (timeout < 0f)
				{
					UnityEngine.Application.Quit();
				}
				yield return Wait.For.Updates(1);
			}
			errorP.DismissErrorMessage();
		}
		DetectionController.EnsureInstance();
		yield return Wait.For.Updates(1);
		yield return GetComponentInChildren<PSC>(includeInactive: true).OnAwakeLR();
		yield return Wait.For.Updates(1);
		yield return GetComponentInChildren<CC>(includeInactive: true).OnAwakeLR();
		yield return Wait.For.Updates(1);
		GetComponentInChildren<PlayerInventory>(includeInactive: true).OnAwakeLR();
		yield return Wait.For.Updates(1);
		GetComponentInChildren<TitleCardController>(includeInactive: true).OnAwakeLR();
		yield return Wait.For.Updates(1);
		yield return InitialiseUIHierarchy(base.transform, hide: false, forceInactiveDuringLoading: false);
		yield return Wait.For.Updates(1);
		UIPauseMenu.Inst.HideAll();
		yield return Wait.For.Updates(1);
		UIDebug.Inst.HideAll();
		yield return Wait.For.Updates(1);
		LightSensor.InitializeStatics();
		yield return Wait.For.Updates(1);
		yield return Wait.Until.True(() => FAC.Initialized, 1, allowPreMetNow: true);
		if (isAndroid)
		{
			yield return FAC.unpackFileFromJarRoutine.Call("Banks/Master Bank.strings.bank", FACMisc.GetUnpackedPath("Banks/Master Bank.strings.bank"));
			yield return FAC.unpackFileFromJarRoutine.Call("Banks/Master Bank.bank", FACMisc.GetUnpackedPath("Banks/Master Bank.bank"));
		}
		if (synchronousLoading)
		{
			FAC.Inst.LoadBank(FACMisc.GetUnpackedPath("Banks/Master Bank.strings.bank"), includeSamples: false, null);
			FAC.Inst.LoadBank(FACMisc.GetUnpackedPath("Banks/Master Bank.bank"), includeSamples: false, null);
		}
		else
		{
			yield return FAC.Inst.LoadBankAsync(FACMisc.GetUnpackedPath("Banks/Master Bank.strings.bank"), includeSamples: false);
			yield return FAC.Inst.LoadBankAsync(FACMisc.GetUnpackedPath("Banks/Master Bank.bank"), includeSamples: false);
		}
		if (isEditor)
		{
			yield return Wait.For.Updates(4);
		}
		if (!synchronousLoading)
		{
			FAC.AddThreadTask(delegate
			{
				SetupFMODAudioDriverToRespectOculusAudioSettings();
			});
		}
		else
		{
			SetupFMODAudioDriverToRespectOculusAudioSettings();
		}
		yield return FAC.WaitThreadBusy;
		yield return GetComponentInChildren<VOC>(includeInactive: true).OnAwakeLR(synchronousLoading);
		Physics.autoSimulation = false;
		Physics.autoSyncTransforms = false;
		Crosshair.Inst.gameObject.SetActive(value: true);
		RasterizerNative.LoadLibrary();
		RasterizationController.Inst.StartThread();
		SceneInfo_BundleRef[] array = sceneInfoRefs;
		for (int i = 0; i < array.Length; i++)
		{
			SceneInfo sceneInfo = array[i].Load();
			sceneUIDName_To_SceneInfo.Add(sceneInfo.sceneUIDName, sceneInfo);
			sceneInfo.InitAwakeValue();
		}
		MainMenuMode = true;
		sceneInfoGroups = new SceneInfoGroup[sceneInfoGroupRefs.Length];
		for (int j = 0; j < sceneInfoGroups.Length; j++)
		{
			sceneInfoGroups[j] = sceneInfoGroupRefs[j].Load();
		}
		bool loadedScene = false;
		SceneInfo startingSceneInfo = GetStartingSceneInfo();
		SetVCAMusicVolume();
		SetVCASFXVolume();
		SetVCAVoVolume();
		shaderPrewarmRoutine.Start();
		if (!skipTitleSequence)
		{
			yield return LoadingScreenController.Inst.titleRoutine.Call();
		}
		NexusFullScreenPass.Inst.InitSnapshot();
		yield return NexusFullScreenPass.Inst.StartFadeToColor(0.25f, NexusFullScreenPass.offWhite);
		MRBase[] activeMRs = null;
		if (isEditor)
		{
			for (int k = 0; k < SceneManager.sceneCount; k++)
			{
				Scene sceneAt = SceneManager.GetSceneAt(k);
				_AddSceneToMRLoaded(sceneAt);
			}
			activeMRs = UnityEngine.Object.FindObjectsOfType<MRBase>();
		}
		if (!ArrayX.IsNullOrEmpty(activeMRs))
		{
			MRBase[] array2 = activeMRs;
			foreach (MRBase mRBase in array2)
			{
				yield return SceneLoad(mRBase.info.Load(), fadeToBlack: false);
				yield return Wait.For.LRUpdates(1);
				loadedScene = true;
			}
		}
		else if (startingSceneInfo != null)
		{
			yield return SceneLoad(startingSceneInfo, fadeToBlack: false);
			yield return Wait.For.LRUpdates(1);
			loadedScene = true;
		}
		else
		{
			isAllConnectedScenesLoaded.value = true;
			isAllConnectedScenesUnloaded.value = true;
		}
		if (!ArrayX.IsNullOrEmpty(activeMRs))
		{
			for (int m = 0; m < activeMRs.Length; m++)
			{
				activeMRs[m] = null;
			}
		}
		Crosshair.Inst.CrosshairDisplayMode = Crosshair.CrosshairMode.Off;
		if (!isEditor)
		{
			while (!OVRPlugin.hasInputFocus || !OVRPlugin.hasVrFocus)
			{
				yield return Wait.For.LRRealtimeUpdates(1);
			}
		}
		LoadingScreenController.Inst.HideLoadingScreen();
		yield return Wait.For.LRRealtimeUpdates(2);
		if (loadedScene)
		{
			IC.Inst.UpdateHeadPosition();
			if (!EditorSpawnPlayer())
			{
				SpawnPlayer(mrsLoaded[0]);
			}
			EnsureBatching();
		}
		portalIdleInstance = FAC.Inst.PlayOneShot(BaseSettings<PortalSettings>.Inst.portalIdleSound, base.transform.position);
		portalIdleInstance.setParameterValue("PortalDistance", 10f);
		PlayerInventory.Inst.CloseInventory();
		UIErrorPrompt.Inst.UpdateCamera(MainCamera.Inst.transform, loadingMode: false);
		OVROverlayNexus.Inst.SetupColor(black: true);
		allowUpdates = true;
		NexusFullScreenPass.Inst.StartFadeToClear(0.25f);
	}

	private CommandBuffer RenderPipelineEvent_Start()
	{
		_OnRenderPipelineStart.Trigger();
		return null;
	}

	private IEnumerator<Routine.Yield> _LoadSceneImpl(SceneInfo infoToLoad)
	{
		if (SceneManager.GetSceneByName(infoToLoad.sceneName).isLoaded)
		{
			yield break;
		}
		if (Routine.Skipping)
		{
			UnityEngine.Debug.Log("Skip Loading \"" + infoToLoad.sceneName + "\" now...");
			SceneManager.LoadScene(infoToLoad.sceneName, LoadSceneMode.Additive);
			UnityEngine.Debug.Log("Finished Skip Loading \"" + infoToLoad.sceneName);
		}
		else
		{
			UnityEngine.AsyncOperation op = SceneManager.LoadSceneAsync(infoToLoad.sceneName, LoadSceneMode.Additive);
			if (op != null)
			{
				while (!op.isDone)
				{
					yield return Wait.For.LRUpdates(1);
				}
			}
			else
			{
				UnityEngine.Debug.LogError("Unable to Load Scene: " + infoToLoad.sceneName);
			}
		}
		Scene sceneByName = SceneManager.GetSceneByName(infoToLoad.sceneName);
		_AddSceneToMRLoaded(sceneByName);
	}

	private void _AddSceneToMRLoaded(Scene scene)
	{
		GameObject[] rootGameObjects = scene.GetRootGameObjects();
		for (int i = 0; i < rootGameObjects.Length; i++)
		{
			MRBase component = rootGameObjects[i].GetComponent<MRBase>();
			if (!(component == null) && !mrsLoaded.Contains(component))
			{
				mrsLoaded.Add(component);
				sceneUIDName_To_LoadedMR.Add(component.info.Load().sceneUIDName, component);
			}
		}
	}

	private void _PrebuildScene(Scene scene)
	{
	}

	public bool IsSceneLoaded(SceneInfo info)
	{
		for (int i = 0; i < mrsLoaded.Length; i++)
		{
			if (mrsLoaded[i].info.Load() == info)
			{
				return true;
			}
		}
		return false;
	}

	public MRBase GetSceneLoaded(SceneInfo info)
	{
		for (int i = 0; i < mrsLoaded.Length; i++)
		{
			MRBase mRBase = mrsLoaded[i];
			if (mRBase.info.Load() == info)
			{
				return mRBase;
			}
		}
		return null;
	}

	public bool IsSceneLoaded(string idScene)
	{
		for (int i = 0; i < mrsLoaded.Length; i++)
		{
			if (mrsLoaded[i].info.Load().sceneUIDName == idScene)
			{
				return true;
			}
		}
		return false;
	}

	public bool AreOwnersPartOfSameArea(MRBase ownerPrev, MRBase ownerNew)
	{
		if (!ownerPrev || !ownerNew)
		{
			return false;
		}
		SceneInfo value = ownerPrev.info.Load();
		SceneInfo value2 = ownerNew.info.Load();
		SceneInfoGroup[] array = sceneInfoGroups;
		foreach (SceneInfoGroup sceneInfoGroup in array)
		{
			if (sceneInfoGroup.scenes.Contains(value) && sceneInfoGroup.scenes.Contains(value2) && sceneInfoGroup.isSameArea)
			{
				return true;
			}
		}
		return false;
	}

	private ConstArray<MRBase> BeginQuery_ScenesToNotifyOfAreaEvent(MRBase ownerPrev, MRBase ownerNew, MRBase ownerToNotify)
	{
		if (!AreOwnersPartOfSameArea(ownerPrev, ownerNew))
		{
			SceneInfo value = (ownerToNotify ? ownerToNotify.info.Load() : null);
			_notifyScenes.Add(ownerToNotify);
			SceneInfoGroup[] array = sceneInfoGroups;
			foreach (SceneInfoGroup sceneInfoGroup in array)
			{
				if (!sceneInfoGroup.isSameArea || !sceneInfoGroup.scenes.Contains(value))
				{
					continue;
				}
				SceneInfo[] scenes = sceneInfoGroup.scenes;
				foreach (SceneInfo info in scenes)
				{
					MRBase sceneLoaded = GetSceneLoaded(info);
					if ((bool)sceneLoaded && sceneLoaded.isAwake && !_notifyScenes.Contains(sceneLoaded))
					{
						_notifyScenes.Add(sceneLoaded);
					}
				}
			}
		}
		return _notifyScenes;
	}

	private void EndQuery_ScenesToNotifyOfAreaEvent(ConstArray<MRBase> scenesToNotify)
	{
		scenesToNotify.ClearToDefault();
	}

	public void NotifyOnAreaEnter(MRBase ownerPrev, MRBase ownerNew)
	{
		ConstArray<MRBase> constArray = BeginQuery_ScenesToNotifyOfAreaEvent(ownerPrev, ownerNew, ownerNew);
		for (int i = 0; i < constArray.Length; i++)
		{
			constArray[i].NotifyOnAreaEnter();
		}
		EndQuery_ScenesToNotifyOfAreaEvent(constArray);
	}

	public void NotifyOnAreaExit(MRBase ownerPrev, MRBase ownerNew)
	{
		ConstArray<MRBase> constArray = BeginQuery_ScenesToNotifyOfAreaEvent(ownerPrev, ownerNew, ownerPrev);
		for (int i = 0; i < constArray.Length; i++)
		{
			constArray[i].NotifyOnAreaExit();
		}
		EndQuery_ScenesToNotifyOfAreaEvent(constArray);
	}

	public void NotifyOnAreaEnter_OnAwakeMRBase(MRBase owner)
	{
		SceneInfo sceneInfo = owner.info.Load();
		MRBase owner2 = MainCamera.Inst.GetOwner();
		if (!owner2)
		{
			return;
		}
		ConstArray<SceneInfo> constArray = owner2.CalculateConnectedScenes();
		for (int i = 0; i < constArray.Length; i++)
		{
			if (constArray[i] == sceneInfo && AreOwnersPartOfSameArea(owner2, owner))
			{
				owner.NotifyOnAreaEnter();
			}
		}
	}

	public Wait SceneLoad(SceneInfo info, bool fadeToBlack = true)
	{
		return sceneLoad.Start(info, fadeToBlack);
	}

	public Wait LoadAdjacentScenes(bool forceReload = false)
	{
		return loadAndUnloadAdjacentScenes.Start(forceReload, resetIfStarted: true);
	}

	public Wait WaitForSceneLoadandUnload()
	{
		return Wait.Until.Completed(loadAndUnloadAdjacentScenes, 1, allowPreMetNow: true);
	}

	private IEnumerator<Routine.Yield> LoadAndUnloadAdjacentScenes(bool forceReload)
	{
		ResetAllConnectedScenesLoadedTrigger();
		ResetAllConnectedScenesUnLoadedTrigger();
		MRBase owner = MainCamera.Inst.GetOwner();
		MRBase curOwner = owner;
		SceneInfo curSceneInfo = curOwner.info.Load();
		while (sceneLoad.started || sceneUnload.started)
		{
			yield return Wait.For.LRUpdates(1);
		}
		yield return Wait.For.LRUpdates(1);
		connectedScenes.Clear();
		ConstArray<SceneInfo> constArray = curOwner.CalculateConnectedScenes();
		for (int l = 0; l < constArray.Length; l++)
		{
			SceneInfo obj = constArray[l];
			connectedScenes.Add(obj);
		}
		SceneInfoGroup[] array = sceneInfoGroups;
		foreach (SceneInfoGroup sceneInfoGroup in array)
		{
			if (!sceneInfoGroup.scenes.Contains(curSceneInfo))
			{
				continue;
			}
			SceneInfo[] scenes = sceneInfoGroup.scenes;
			foreach (SceneInfo sceneInfo in scenes)
			{
				if (!connectedScenes.Contains(sceneInfo))
				{
					connectedScenes.Add(sceneInfo);
				}
			}
			if (!sceneInfoGroup.isSameArea)
			{
				continue;
			}
			scenes = sceneInfoGroup.scenes;
			foreach (SceneInfo info in scenes)
			{
				MRBase sceneLoaded = GetSceneLoaded(info);
				if (!sceneLoaded)
				{
					continue;
				}
				ConstArray<SceneInfo> constArray2 = sceneLoaded.CalculateConnectedScenes();
				for (int num = 0; num < constArray2.Length; num++)
				{
					SceneInfo sceneInfo2 = constArray2[num];
					if (!connectedScenes.Contains(sceneInfo2))
					{
						connectedScenes.Add(sceneInfo2);
					}
				}
			}
		}
		for (int num2 = 0; num2 < connectedScenes.Length; num2++)
		{
			SceneInfo value = connectedScenes[num2];
			array = sceneInfoGroups;
			foreach (SceneInfoGroup sceneInfoGroup2 in array)
			{
				if (!sceneInfoGroup2.isSameArea || !sceneInfoGroup2.scenes.Contains(value))
				{
					continue;
				}
				SceneInfo[] scenes = sceneInfoGroup2.scenes;
				foreach (SceneInfo sceneInfo3 in scenes)
				{
					if (!connectedScenes.Contains(sceneInfo3))
					{
						connectedScenes.Add(sceneInfo3);
					}
				}
			}
		}
		mrsToUnload.ClearToDefault();
		for (int num3 = 0; num3 < mrsLoaded.Length; num3++)
		{
			MRBase mRBase = mrsLoaded[num3];
			SceneInfo sceneInfo4 = mRBase.info.Load();
			if (!(curSceneInfo == sceneInfo4) && (!connectedScenes.Contains(sceneInfo4) || forceReload))
			{
				mrsToUnload.Add(mRBase);
			}
		}
		kubricksToUnload.ClearToDefault();
		atlasMatsToUnload.ClearToDefault();
		atlasTextureToUnload.ClearToDefault();
		for (int k = 0; k < mrsToUnload.Length; k++)
		{
			yield return Wait.For.LRUpdates(1);
			GatherKubricksToUnload(mrsToUnload[k]);
			GatherAtlasesToUnload(mrsToUnload[k]);
			SceneInfo arg = mrsToUnload[k].info.Load();
			yield return sceneUnload.Start(arg);
			yield return Wait.For.LRUpdates(1);
		}
		mrsToUnload.ClearToDefault();
		isAllConnectedScenesUnloaded.value = true;
		int m;
		for (int k = 0; k < connectedScenes.Length; k = m)
		{
			SceneInfo sceneInfo5 = connectedScenes[k];
			if (!IsSceneLoaded(sceneInfo5))
			{
				yield return sceneLoad.Start(sceneInfo5, arg1: false);
				yield return Wait.For.LRUpdates(1);
			}
			m = k + 1;
		}
		CheckKubricksToUnloadWithLoadedScenes();
		CheckAtlasesToUnloadWithLoadedScenes();
		int counter = 0;
		for (int k = 0; k < kubricksToUnload.Length; k++)
		{
			Resources.UnloadAsset(kubricksToUnload[k].clipRef);
			Resources.UnloadAsset(kubricksToUnload[k]);
			if (counter++ > 5)
			{
				counter = 0;
				yield return Wait.For.Updates(1);
			}
		}
		UnloadAtlases();
		kubricksToUnload.ClearToDefault();
		atlasMatsToUnload.ClearToDefault();
		atlasTextureToUnload.ClearToDefault();
		PlayerInventory.Inst.DestroyUnusedObjects();
		isAllConnectedScenesLoaded.value = true;
	}

	private void GatherKubricksToUnload(MRBase owner)
	{
		ConstArray<KubrickAnimator> kubrickAnimators = owner.kubrickAnimators;
		for (int i = 0; i < kubrickAnimators.Length; i++)
		{
			KubrickAnimClip[] animClips = kubrickAnimators[i].animClips;
			for (int j = 0; j < animClips.Length; j++)
			{
				if (!kubricksToUnload.Contains(animClips[j]))
				{
					kubricksToUnload.Add(animClips[j]);
				}
			}
		}
	}

	private void GatherAtlasesToUnload(MRBase owner)
	{
		JK3DAtlasMaterial[] array = owner.atlasMaterials;
		foreach (JK3DAtlasMaterial jK3DAtlasMaterial in array)
		{
			if (jK3DAtlasMaterial.atlasName == "Gameplay_Dynamic" || jK3DAtlasMaterial.atlasName == "Global_Diffuse")
			{
				continue;
			}
			if ((bool)jK3DAtlasMaterial.staticMat)
			{
				if (!atlasMatsToUnload.Contains(jK3DAtlasMaterial.staticMat))
				{
					atlasMatsToUnload.Add(jK3DAtlasMaterial.staticMat);
				}
				Texture mainTexture = jK3DAtlasMaterial.staticMat.mainTexture;
				if (!atlasTextureToUnload.Contains(mainTexture))
				{
					atlasTextureToUnload.Add(mainTexture);
				}
				if (jK3DAtlasMaterial.staticMat.HasProperty("_EmissionMap"))
				{
					Texture texture = jK3DAtlasMaterial.staticMat.GetTexture("_EmissionMap");
					if ((bool)texture && !atlasTextureToUnload.Contains(texture))
					{
						atlasTextureToUnload.Add(texture);
					}
				}
			}
			if (!jK3DAtlasMaterial.dynamicMat)
			{
				continue;
			}
			if (!atlasMatsToUnload.Contains(jK3DAtlasMaterial.dynamicMat))
			{
				atlasMatsToUnload.Add(jK3DAtlasMaterial.dynamicMat);
			}
			Texture mainTexture2 = jK3DAtlasMaterial.dynamicMat.mainTexture;
			if (!atlasTextureToUnload.Contains(mainTexture2))
			{
				atlasTextureToUnload.Add(mainTexture2);
			}
			if (jK3DAtlasMaterial.dynamicMat.HasProperty("_EmissionMap"))
			{
				Texture texture2 = jK3DAtlasMaterial.dynamicMat.GetTexture("_EmissionMap");
				if ((bool)texture2 && !atlasTextureToUnload.Contains(texture2))
				{
					atlasTextureToUnload.Add(texture2);
				}
			}
		}
	}

	private void CheckKubricksToUnloadWithLoadedScenes()
	{
		for (int i = 0; i < mrsLoaded.Length; i++)
		{
			ConstArray<KubrickAnimator> kubrickAnimators = mrsLoaded[i].kubrickAnimators;
			for (int j = 0; j < kubrickAnimators.Length; j++)
			{
				KubrickAnimClip[] animClips = kubrickAnimators[j].animClips;
				for (int k = 0; k < animClips.Length; k++)
				{
					int num = kubricksToUnload.IndexOf(animClips[k]);
					if (num != -1)
					{
						kubricksToUnload.RemoveAtIndex((uint)num);
					}
				}
			}
		}
	}

	private void CheckAtlasesToUnloadWithLoadedScenes()
	{
		for (int i = 0; i < mrsLoaded.Length; i++)
		{
			JK3DAtlasMaterial[] array = mrsLoaded[i].atlasMaterials;
			foreach (JK3DAtlasMaterial jK3DAtlasMaterial in array)
			{
				if ((bool)jK3DAtlasMaterial.staticMat)
				{
					int num = atlasMatsToUnload.IndexOf(jK3DAtlasMaterial.staticMat);
					if (num != -1)
					{
						atlasMatsToUnload.RemoveAtIndex((uint)num);
					}
					Texture mainTexture = jK3DAtlasMaterial.staticMat.mainTexture;
					int num2 = atlasTextureToUnload.IndexOf(mainTexture);
					if (num2 != -1)
					{
						atlasTextureToUnload.RemoveAtIndex((uint)num2);
					}
					if (jK3DAtlasMaterial.staticMat.HasProperty("_EmissionMap"))
					{
						Texture texture = jK3DAtlasMaterial.staticMat.GetTexture("_EmissionMap");
						int num3 = atlasTextureToUnload.IndexOf(texture);
						if ((bool)texture && num3 != -1)
						{
							atlasTextureToUnload.RemoveAtIndex((uint)num3);
						}
					}
				}
				if (!jK3DAtlasMaterial.dynamicMat)
				{
					continue;
				}
				int num4 = atlasMatsToUnload.IndexOf(jK3DAtlasMaterial.dynamicMat);
				if (num4 != -1)
				{
					atlasMatsToUnload.RemoveAtIndex((uint)num4);
				}
				Texture mainTexture2 = jK3DAtlasMaterial.dynamicMat.mainTexture;
				int num5 = atlasTextureToUnload.IndexOf(mainTexture2);
				if (num5 != -1)
				{
					atlasTextureToUnload.RemoveAtIndex((uint)num5);
				}
				if (jK3DAtlasMaterial.dynamicMat.HasProperty("_EmissionMap"))
				{
					Texture texture2 = jK3DAtlasMaterial.dynamicMat.GetTexture("_EmissionMap");
					int num6 = atlasTextureToUnload.IndexOf(texture2);
					if ((bool)texture2 && num6 != -1)
					{
						atlasTextureToUnload.RemoveAtIndex((uint)num6);
					}
				}
			}
		}
	}

	private void UnloadAtlases()
	{
		for (int i = 0; i < atlasMatsToUnload.Length; i++)
		{
			Resources.UnloadAsset(atlasMatsToUnload[i]);
		}
		for (int j = 0; j < atlasTextureToUnload.Length; j++)
		{
			Resources.UnloadAsset(atlasTextureToUnload[j]);
		}
	}

	private IEnumerator<Routine.Yield> _SceneLoad(SceneInfo infoToLoad, bool fadeToBlack)
	{
		yield return Routine.Yield.SpecialIndex.RoutineResetToHere;
		bool isEditor = false;
		if (fadeToBlack)
		{
			NexusFullScreenPass.Inst.StartFadeToBlack(0.5f);
			yield return Wait.For.Seconds(0.5f);
		}
		yield return _loadSceneImpl.Start(infoToLoad);
		MRBase mrBase2 = GetMRBaseWithSceneInfo(infoToLoad);
		int mrIdx2 = 0;
		while (mrIdx2 < mrsLoaded.Length)
		{
			MRBase mr = mrsLoaded[mrIdx2];
			if (!mr.isAwake)
			{
				yield return mr.SpawnObjects();
				mr.InitialiseReturnPortal();
			}
			int num = mrIdx2 + 1;
			mrIdx2 = num;
		}
		SceneInfo sceneInfo2 = mrBase2.info.Load();
		if (!mrBase2.isLoadedRefs)
		{
			mrBase2.isLoadedRefs = true;
			yield return Wait.For.Updates(1);
			ConstArray<SceneInfo> constArray = mrBase2.CalculateConnectedScenes();
			for (int i = 0; i < mrBase2.linkedScenesUIDs.Length; i++)
			{
				string text = mrBase2.linkedScenesUIDs[i];
				bool flag = false;
				if (text == mrBase2.info.Load().sceneUIDName)
				{
					flag = true;
				}
				else
				{
					for (int j = 0; j < constArray.Length; j++)
					{
						if (constArray[j].sceneUIDName == text)
						{
							flag = true;
							break;
						}
					}
				}
				if (!flag && sceneInfo2.allowSceneRefConnections && sceneUIDName_To_SceneInfo.TryGetValue(text, out var value))
				{
					mrBase2.AddConnectingScene(value);
				}
			}
		}
		yield return Wait.None;
		for (int k = 0; k < mrsLoaded.Length; k++)
		{
			MRBase mRBase = mrsLoaded[k];
			if (mRBase.isAwake)
			{
				continue;
			}
			IDObject[] componentsInChildren = mRBase.GetComponentsInChildren<IDObject>(includeInactive: true);
			foreach (IDObject iDObject in componentsInChildren)
			{
				if ((!isEditor || !iDObject.GetComponentInAscendant<GrabObjectSpawnPoint>()) && !(iDObject is InventoryObject))
				{
					RegisterId(iDObject);
				}
			}
		}
		for (int l = 0; l < mrsLoaded.Length; l++)
		{
			MRBase mRBase2 = mrsLoaded[l];
			if (!mRBase2.isAwake)
			{
				mRBase2.Setup();
			}
		}
		mrIdx2 = 0;
		while (mrIdx2 < mrsLoaded.Length)
		{
			mrBase2 = mrsLoaded[mrIdx2];
			int num;
			if (!mrBase2.isAwake)
			{
				sceneInfo2 = mrBase2.info.Load();
				SceneInfo mimicSceneInfo = null;
				SceneInfoGroup[] array = sceneInfoGroups;
				for (num = 0; num < array.Length; num++)
				{
					SceneInfoMimicGroup sceneInfoMimicGroup = array[num] as SceneInfoMimicGroup;
					if (sceneInfoMimicGroup == null || !sceneInfoMimicGroup.scenes.Contains(sceneInfo2))
					{
						continue;
					}
					SceneInfo[] scenes = sceneInfoMimicGroup.scenes;
					foreach (SceneInfo sceneInfo3 in scenes)
					{
						if (!(sceneInfo3 == sceneInfo2))
						{
							mimicSceneInfo = sceneInfo3;
						}
					}
				}
				yield return mrBase2.OnAwakeLR(mimicSceneInfo);
				mrBase2.isAwake = !mrBase2.awakeFailed;
				if (mrBase2.isAwake)
				{
					sceneInfo2.isSceneAwake.value = true;
					mrBase2.Save();
				}
			}
			num = mrIdx2 + 1;
			mrIdx2 = num;
		}
		bool flag2 = infoToLoad.sceneUIDName == "suez" && mrsLoaded.Length > 1;
		if (!string.IsNullOrEmpty(infoToLoad.occlusionSceneName) && !flag2 && infoToLoad.occlusionSceneName != occlusionSceneNameLoaded)
		{
			UnityEngine.AsyncOperation op2;
			if (!string.IsNullOrEmpty(occlusionSceneNameLoaded))
			{
				op2 = SceneManager.UnloadSceneAsync(occlusionSceneNameLoaded);
				if (op2 != null)
				{
					while (!op2.isDone)
					{
						yield return Wait.For.LRUpdates(1);
					}
				}
			}
			op2 = SceneManager.LoadSceneAsync(infoToLoad.occlusionSceneName, LoadSceneMode.Additive);
			if (op2 != null)
			{
				while (!op2.isDone)
				{
					yield return Wait.For.LRUpdates(1);
				}
			}
			occlusionSceneNameLoaded = infoToLoad.occlusionSceneName;
			SceneManager.SetActiveScene(SceneManager.GetSceneByName(infoToLoad.occlusionSceneName));
			SceneManager.LoadScene("TheBatcher", LoadSceneMode.Additive);
			SceneManager.UnloadSceneAsync("TheBatcher");
		}
		if (fadeToBlack)
		{
			NexusFullScreenPass.Inst.StartFadeToClear(0.5f);
			yield return Wait.For.Seconds(0.5f);
		}
	}

	public Wait LoadPlayerIntoScene(SceneInfo info)
	{
		return loadPlayerIntoSceneRoutine.Start(info, null, null, arg3: false);
	}

	public Wait LoadPlayerIntoScene(SceneInfo info, Vector3? startPos, Quaternion? startRot, bool shouldFadeToClearAtEndOfRoutine)
	{
		return loadPlayerIntoSceneRoutine.Start(info, startPos, startRot, shouldFadeToClearAtEndOfRoutine);
	}

	public void ResetAllConnectedScenesLoadedTrigger()
	{
		isAllConnectedScenesLoaded.value = false;
	}

	public void ResetAllConnectedScenesUnLoadedTrigger()
	{
		isAllConnectedScenesUnloaded.value = false;
	}

	private IEnumerator<Routine.Yield> LoadPlayerIntoSceneRoutine(SceneInfo info, Vector3? startPos, Quaternion? startRot, bool shouldFadeToClearAtEndOfRoutine)
	{
		ResetAllConnectedScenesLoadedTrigger();
		ResetAllConnectedScenesUnLoadedTrigger();
		loadAndUnloadAdjacentScenes.Stop();
		OVROverlayNexus.Inst.SetupColor(black: false);
		yield return Wait.For.LRLateUpdates(1);
		MainCamera.Inst.SetOwner(null);
		while (sceneLoad.started || sceneUnload.started)
		{
			yield return Wait.For.LRUpdates(1);
		}
		yield return Wait.For.LRUpdates(1);
		kubricksToUnload.ClearToDefault();
		atlasMatsToUnload.ClearToDefault();
		atlasTextureToUnload.ClearToDefault();
		uint i = 0u;
		while (i < mrsLoaded.Length)
		{
			GatherKubricksToUnload(mrsLoaded[i]);
			GatherAtlasesToUnload(mrsLoaded[i]);
			yield return mrsLoaded[i].OnSceneUnload();
			SceneManager.UnloadSceneAsync(mrsLoaded[i].info.Load().sceneName);
			uint num = i + 1;
			i = num;
		}
		mrsLoaded.ClearToDefault();
		foreach (KeyValuePair<string, SceneInfo> item in sceneUIDName_To_SceneInfo)
		{
			item.Value.isSceneAwake.value = false;
		}
		sceneUIDName_To_LoadedMR.Clear();
		Resources.UnloadUnusedAssets();
		yield return SceneLoad(info, fadeToBlack: false);
		yield return Wait.For.LRUpdates(1);
		CheckKubricksToUnloadWithLoadedScenes();
		CheckAtlasesToUnloadWithLoadedScenes();
		int counter = 0;
		for (int j = 0; j < kubricksToUnload.Length; j++)
		{
			Resources.UnloadAsset(kubricksToUnload[j].clipRef);
			Resources.UnloadAsset(kubricksToUnload[j]);
			if (counter++ > 5)
			{
				counter = 0;
				yield return Wait.For.Updates(1);
			}
		}
		UnloadAtlases();
		kubricksToUnload.ClearToDefault();
		atlasMatsToUnload.ClearToDefault();
		atlasTextureToUnload.ClearToDefault();
		MRBase mRBaseWithSceneInfo = Inst.GetMRBaseWithSceneInfo(info);
		if (startPos.HasValue && startRot.HasValue)
		{
			SpawnPlayer(mRBaseWithSceneInfo, startPos.Value, startRot.Value);
		}
		else
		{
			SpawnPlayer(mRBaseWithSceneInfo);
		}
		OVROverlayNexus.Inst.SetupColor(black: true);
		NexusFullScreenPass.Inst.ForceUpdateLastValidPosition();
		EnsureBatching();
		if (shouldFadeToClearAtEndOfRoutine)
		{
			NexusFullScreenPass.Inst.StartFadeToClear(BaseSettings<VaultSettings>.Inst.whitefadeOutTime);
		}
		IC.Inst.PauseMenuEnabled = true;
		IC.Inst.RecenterEnabled = true;
		PlayerTeleport.TeleportEnabled.Reset();
		PlayerTeleport.TeleportEnabled.Value = true;
	}

	private IEnumerator<Routine.Yield> _SceneUnload(SceneInfo infoToUnload)
	{
		uint i = 0u;
		while (i < mrsLoaded.Length)
		{
			MRBase mRBase = mrsLoaded[i];
			if (mRBase.info.Load() == infoToUnload)
			{
				yield return mRBase.OnSceneUnload();
				mrsLoaded.RemoveAtIndex(i);
				sceneUIDName_To_LoadedMR.Remove(infoToUnload.sceneUIDName);
				infoToUnload.isSceneAwake.value = false;
				break;
			}
			uint num = i + 1;
			i = num;
		}
		mrsLoaded.ReleaseUnusedReferences();
		UnityEngine.AsyncOperation op = SceneManager.UnloadSceneAsync(infoToUnload.sceneName);
		while (!op.isDone)
		{
			yield return Wait.For.LRUpdates(1);
		}
	}

	private IEnumerator<Routine.Yield> StartCreditsRoutine(MRBase owner)
	{
		SceneInfo arg = Runtime.LoadAsset<SceneInfo>("Assets/_GameAssets/CustomAssets/SceneInfos/SC_Credits.asset");
		yield return fadeAndSpawn.Start(0.5f, arg, owner);
	}

	private IEnumerator<Routine.Yield> FramerateTestAllScenesRoutine(SceneInfo sceneToTest)
	{
		_ = BaseSettings<FramerateTestSettings>.Inst.sceneGroupsToTest;
		FramerateTestSettings fti = BaseSettings<FramerateTestSettings>.Inst;
		UnityEngine.Debug.Log("Testing: " + sceneToTest.prettyName);
		if (!IsSceneLoaded(sceneToTest) || !isAllConnectedScenesLoaded.value)
		{
			yield return LoadPlayerIntoScene(sceneToTest);
			yield return IsAllConnectedScenesLoaded & IsAllConnectedScenesUnloaded;
		}
		MRBase owner = MainCamera.Inst.GetOwner();
		FramerateTester framerateTester = UnityEngine.Object.FindObjectOfType<FramerateTester>();
		if (framerateTester == null)
		{
			GameObject gameObject = new GameObject("TEMP_AUTOTEST");
			framerateTester = gameObject.AddComponent<FramerateTester>();
		}
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < owner.regions.Length; i++)
		{
			list.AddRange(GetRegionTestPositions(owner.regions[i], fti.positionsPerUnit, 1.78f));
		}
		framerateTester.Initialise(list.ToArray(), fti.horizontalOrientations, fti.verticalOrientations, fti.framesToTest, fti.horizontalCSVFields);
		yield return framerateTester.RunTestYield(MainCamera.Inst.cameraComp, 0f, sceneToTest.prettyName);
		framerateTester.WriteStatsToCSV("STATS_" + sceneToTest.prettyName);
		framerateTester.WriteToFiles(fti.outputFileType, sceneToTest.prettyName);
	}

	public Vector3[] GetTestPositions(MRBase mr, float positionsPerUnit, float yOffset)
	{
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < mr.regions.Length; i++)
		{
			list.AddRange(GetRegionTestPositions(mr.regions[i], positionsPerUnit, yOffset));
		}
		return list.ToArray();
	}

	private Vector3[] GetRegionTestPositions(Region region, float positionsPerUnit, float yOffset)
	{
		int num = (int)(positionsPerUnit * region.GetArea() + 1f);
		Vector3[] array = new Vector3[num];
		for (int i = 0; i < num; i++)
		{
			array[i] = region.GetRandomPosition(yOffset);
		}
		return array;
	}

	private IEnumerator<Routine.Yield> CollectPerfStatsForCurrentScene()
	{
		yield return IsAllConnectedScenesLoaded & IsAllConnectedScenesUnloaded;
		InputTracking.Recenter();
		MRBase curMR = MainCamera.Inst.GetOwner();
		Region[] curRegions = curMR.regions;
		long totalBatches = 0L;
		int totalPositions = 0;
		int maxBatches = 0;
		foreach (Region region in curRegions)
		{
			Vector3 vector = region.WorldSpaceBounds.extents * 2f;
			int testPositions = Mathf.CeilToInt(0.25f * vector.x * vector.z);
			UnityEngine.Debug.Log($"Region:{region.name} Size:{vector.x}x{vector.z}({vector.x * vector.z}) Points:{testPositions}", region);
			totalPositions += testPositions;
			for (int posI = 0; posI < testPositions; posI++)
			{
				Vector3 pos = region.GetRandomPosition(0f);
				Vector3 up = region.transform.up;
				Vector3 forward = region.transform.forward;
				int num = 0;
				for (int yRotI = 0; yRotI < 8; yRotI++)
				{
					Quaternion worldRot = Quaternion.LookRotation(Quaternion.AngleAxis(360f * ((float)yRotI / 8f), up) * forward, up);
					CC.Inst.UpdateTrackingSpaceTransform(pos, worldRot, updateHeldObjects: false);
					yield return Wait.For.LRRealtimeUpdates(1);
					num = 0;
				}
				maxBatches = Mathf.Max(maxBatches, num);
				totalBatches += num;
				UnityEngine.Debug.Log($"Pos:{pos} Batches:{num}");
			}
		}
		long num2 = totalBatches / totalPositions;
		UnityEngine.Debug.Log($"Scene:{curMR.gameObject.scene.path} Avg:{num2} Max:{maxBatches}");
	}

	private static void RunPerfStatsForCurrentScene()
	{
		Inst.collectPerfStatsForCurrentScene.Start();
	}

	public bool IsMenuActive()
	{
		if (UIDebug.Inst != null && UIDebug.Inst.IsShown)
		{
			return true;
		}
		if (UIPauseMenu.Inst != null && UIPauseMenu.Inst.IsShown)
		{
			return true;
		}
		return false;
	}

	public bool WasMenuActive()
	{
		return lastMenuActive;
	}

	private void OnUpdateLR()
	{
		if (NexusFullScreenPass.Inst.fadeAnimator.CurrentColor.a >= 1f)
		{
			if (!collectedGC)
			{
				GC.Collect();
				collectedGC = true;
			}
		}
		else
		{
			collectedGC = false;
		}
		SetupFMODAudioDriverToRespectOculusAudioSettings();
		lastMenuActive = IsMenuActive();
		IC.Inst.OnUpdateLR();
		if (MainCamera.Inst.GetOwner() == null)
		{
			Crosshair.Inst.CrosshairDisplayMode = ((!IsMenuActive()) ? Crosshair.CrosshairMode.Off : Crosshair.CrosshairMode.Default);
			Crosshair.Inst.OnUpdateLR();
			CC.Inst.UpdateHandTransforms(updateHeldObjects: false);
			return;
		}
		UIErrorPrompt inst = UIErrorPrompt.Inst;
		if (inst.CurrentError)
		{
			if (IC.Inst.ControllersAreActive() && IC.Inst.HeadsetIsActive())
			{
				inst.DismissErrorMessage();
			}
			else
			{
				inst.UpdateError();
			}
		}
		else if (IC.Inst.ControllersAreActive() && IC.Inst.HeadsetIsActive())
		{
			errorTimer = 0f;
		}
		if (!IsPaused)
		{
			NotifyOnUpdateLR();
			NotifyOnPrePhysicsUpdateLR();
			SimulatePhysics();
			NotifyOnPostPhysicsUpdateLR();
		}
		else
		{
			Physics.SyncTransforms();
			NotifyOnPauseUpdateLR();
			CC.Inst.UpdateFrustumPlanes();
		}
		bool flag = IsMenuActive();
		Crosshair.Inst.CrosshairDisplayMode = ((!flag) ? Crosshair.CrosshairMode.Off : Crosshair.CrosshairMode.Default);
	}

	private void OnLateUpdateLR()
	{
		Physics.SyncTransforms();
		if (!IsPaused)
		{
			NotifyOnLateUpdateLR();
		}
		NotifyOnRealtimeLateUpdateLR();
	}

	private void SimulatePhysics()
	{
		float deltaTime = IC.DeltaTime;
		if (deltaTime > 0f)
		{
			Physics.Simulate(deltaTime);
		}
	}

	private void NotifyOnUpdateLR()
	{
		CC.Inst.OnUpdateLR();
		STC.Inst.OnUpdateLR();
		VOC.Inst.OnUpdateLR();
		Crosshair.Inst.OnUpdateLR();
		DetectionController.Inst.OnUpdateLR();
		for (int i = 0; i < mrsLoaded.Length; i++)
		{
			MRBase mRBase = mrsLoaded[i];
			if (mRBase.isAwake)
			{
				try
				{
					mRBase.OnUpdateLR();
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception, mRBase.gameObject);
				}
			}
		}
	}

	private void NotifyOnPrePhysicsUpdateLR()
	{
		for (int i = 0; i < mrsLoaded.Length; i++)
		{
			MRBase mRBase = mrsLoaded[i];
			if (mRBase.isAwake)
			{
				try
				{
					mRBase.OnPrePhysicsUpdateLR();
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception, mRBase.gameObject);
				}
			}
		}
		_onPrePhysicsUpdate.Trigger(IC.DeltaTime);
	}

	private void NotifyOnPostPhysicsUpdateLR()
	{
		CC.Inst.OnPostPhysicsUpdateLR();
		for (int i = 0; i < mrsLoaded.Length; i++)
		{
			MRBase mRBase = mrsLoaded[i];
			if (mRBase.isAwake)
			{
				try
				{
					mRBase.OnPostPhysicsUpdateLR();
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception, mRBase.gameObject);
				}
			}
		}
		_onPostPhysicsUpdate.Trigger(IC.DeltaTime);
	}

	private void NotifyOnPauseLR(bool paused)
	{
		CC.Inst?.OnPauseLR(paused);
		VOC.Inst?.OnPauseLR(paused);
		MainCamera.Inst?.OnPauseLR(paused);
		FAC.Inst.GetBus("bus:/Submix").setPaused(paused);
		for (int i = 0; i < mrsLoaded.Length; i++)
		{
			MRBase mRBase = mrsLoaded[i];
			if (mRBase.isAwake)
			{
				try
				{
					mRBase.OnPauseLR(paused);
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception, mRBase.gameObject);
				}
			}
		}
	}

	private void NotifyOnPauseUpdateLR()
	{
		CC.Inst.OnPauseUpdateLR();
		STC.Inst.OnPauseUpdateLR();
		Crosshair.Inst.OnUpdateLR();
		for (int i = 0; i < mrsLoaded.Length; i++)
		{
			MRBase mRBase = mrsLoaded[i];
			if (mRBase.isAwake)
			{
				try
				{
					mRBase.OnPauseUpdateLR();
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception, mRBase.gameObject);
				}
			}
		}
	}

	private void NotifyOnLateUpdateLR()
	{
		if ((bool)MainCamera.Inst)
		{
			MRBase owner = MainCamera.Inst.GetOwner();
			if (owner != null && owner.isAwake)
			{
				RasterizationController.Inst.UpdateRateLimited(owner);
			}
		}
		for (int i = 0; i < mrsLoaded.Length; i++)
		{
			MRBase mRBase = mrsLoaded[i];
			if (mRBase.isAwake)
			{
				try
				{
					mRBase.OnLateUpdateLR();
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception, mRBase.gameObject);
				}
			}
		}
		CC.Inst.OnLateUpdateLR();
		MainCamera.Inst.OnLateUpdateLR();
		float value = 10f;
		MRBase owner2 = MainCamera.Inst.GetOwner();
		if (owner2 != null)
		{
			value = owner2.GetNearestPortalDistForPortalIdle();
		}
		if (!portalIdleInstance.isValid())
		{
			portalIdleInstance = FAC.Inst.PlayOneShot(BaseSettings<PortalSettings>.Inst.portalIdleSound, base.transform.position);
		}
		portalIdleInstance.setParameterValue("PortalDistance", value);
	}

	private void NotifyOnRealtimeLateUpdateLR()
	{
		for (int i = 0; i < mrsLoaded.Length; i++)
		{
			MRBase mRBase = mrsLoaded[i];
			if (mRBase.isAwake)
			{
				try
				{
					mRBase.OnRealtimeLateUpdateLR();
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception, mRBase.gameObject);
				}
			}
		}
		UIPauseMenu.Inst.OnRealtimeUpdateLR();
		CC.Inst.OnRealtimeLateUpdateLR();
		MainCamera.Inst.OnRealtimeLateUpdateLR();
	}

	private void NotifyOnCutSceneLR(bool cutscene)
	{
		CC.Inst.OnCutscene(cutscene);
		for (int i = 0; i < mrsLoaded.Length; i++)
		{
			MRBase mRBase = mrsLoaded[i];
			if (mRBase.isAwake)
			{
				try
				{
					mRBase.OnCutsceneLR(cutscene);
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception, mRBase.gameObject);
				}
			}
		}
	}

	public static Wait InitialiseUIHierarchy(Transform uiRoot, bool hide, bool forceInactiveDuringLoading)
	{
		return initialiseUIHierarchyRoutine.Call(uiRoot, hide, forceInactiveDuringLoading);
	}

	private static IEnumerator<Routine.Yield> InitialiseUIHierarchyRoutine(Transform uiRoot, bool hide, bool forceInactiveDuringLoading)
	{
		UIElement[] uiElements = uiRoot.GetComponentsInChildren<UIElement>(includeInactive: true);
		int counter3 = 0;
		UIElement[] array = uiElements;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].OnAwakeLR();
			counter3++;
			if (counter3 % 10 == 0)
			{
				if (forceInactiveDuringLoading)
				{
					uiRoot.gameObject.SetActive(value: false);
				}
				yield return Wait.For.Updates(1);
			}
		}
		array = uiElements;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].OnStartLR();
			counter3++;
			if (counter3 % 10 == 0)
			{
				if (forceInactiveDuringLoading)
				{
					uiRoot.gameObject.SetActive(value: false);
				}
				yield return Wait.For.Updates(1);
			}
		}
		UIContainer[] uiContainers = uiRoot.GetComponentsInChildren<UIContainer>(includeInactive: true);
		UIContainer[] array2 = uiContainers;
		for (counter3 = 0; counter3 < array2.Length; counter3++)
		{
			array2[counter3].Initialise();
			yield return Wait.For.Updates(1);
		}
		if (forceInactiveDuringLoading)
		{
			uiRoot.gameObject.SetActive(value: false);
		}
		yield return Wait.For.Updates(1);
		array2 = uiContainers;
		foreach (UIContainer uIContainer in array2)
		{
			yield return uIContainer.OnAwakeLR();
			if (forceInactiveDuringLoading)
			{
				uiRoot.gameObject.SetActive(value: false);
			}
			yield return Wait.For.Updates(1);
		}
		if (!hide)
		{
			yield break;
		}
		UIContainer component = uiRoot.GetComponent<UIContainer>();
		if ((bool)component)
		{
			component.HideAll();
			yield break;
		}
		UIContainer[] componentsInChildren = uiRoot.GetComponentsInChildren<UIContainer>(includeInactive: true);
		for (int j = 0; j < componentsInChildren.Length; j++)
		{
			componentsInChildren[j].HideAll();
		}
	}

	public static Wait LoadUIResource(string path, Transform parent = null, Vector3 localPosition = default(Vector3), Quaternion localRotation = default(Quaternion))
	{
		return onLoadUIResource.Start(path, parent, localPosition, localRotation);
	}

	private static IEnumerator<Routine.Yield> OnLoadUIResource(string path, Transform parent, Vector3 localPosition, Quaternion localRotation)
	{
		ResourceRequest request = Resources.LoadAsync<GameObject>(path);
		yield return Wait.Until.True(() => request.isDone);
		GameObject gameObject = UnityEngine.Object.Instantiate(request.asset, parent ? parent : Inst.transform) as GameObject;
		gameObject.transform.localPosition = localPosition;
		gameObject.transform.localRotation = localRotation;
		gameObject.transform.localScale = Vector3.one;
		yield return InitialiseUIHierarchy(gameObject.transform, hide: true, forceInactiveDuringLoading: true);
	}

	public void Pause(bool paused, bool lockMovement = true)
	{
		if (IsPaused != paused)
		{
			if (lockMovement && !IsInCutscene)
			{
				PlayerTeleport.TeleportEnabled.Value = !paused;
				PlayerFreeMove.FreeMoveEnabled.Value = !paused;
				PlayerFreeMove.FreeTurnEnabled.Value = !paused;
			}
			PlayerInventory.InventoryEnabled.Value = !paused;
			PlayerInventory.Inst?.ResetOpenTimer();
			NotifyOnPauseLR(paused);
			Time.timeScale = ((!paused) ? 1 : 0);
			IsPaused = paused;
		}
	}

	public void SetInCutscene(bool cutscene)
	{
		if (IsInCutscene == cutscene)
		{
			return;
		}
		if (cutscene)
		{
			VOC.Inst.VOStop(interruption: true);
			evtDucker = FAC.Inst.PlayOneShot("snapshot:/CutsceneDucker", base.transform);
			FAC.Inst.PlayOneShot(BaseSettings<TeleportSettings>.Inst.cutsceneIntroSFX.Value, CC.Inst.transform);
		}
		else
		{
			if (evtDucker.isValid())
			{
				evtDucker.stop(STOP_MODE.ALLOWFADEOUT);
			}
			FAC.Inst.PlayOneShot(BaseSettings<TeleportSettings>.Inst.cutsceneOutroSFX.Value, CC.Inst.transform);
		}
		PlayerInventory.InventoryEnabled.Value = !cutscene;
		NotifyOnCutSceneLR(cutscene);
		IsInCutscene = cutscene;
	}

	private void Update()
	{
		MRBase mRBase = (MainCamera.Inst ? MainCamera.Inst.GetOwner() : null);
		if ((object)mRBase != null)
		{
			MRBase.CalculateIfAllowedToUpdate(mRBase, mrsLoaded);
		}
		if ((bool)IC.Inst)
		{
			if (!IsPaused)
			{
				_onUpdate.Trigger(IC.DeltaTime);
			}
			else
			{
				_onPauseUpdate.Trigger(IC.RealDeltaTime);
			}
			_onRealTimeUpdate.Trigger(IC.RealDeltaTime);
			if (allowUpdates)
			{
				OnUpdateLR();
			}
		}
	}

	private void LateUpdate()
	{
		if ((bool)IC.Inst)
		{
			if (!IsPaused)
			{
				_onLateUpdate.Trigger(IC.DeltaTime);
			}
			_onRealTimeLateUpdate.Trigger(IC.RealDeltaTime);
			if (allowUpdates)
			{
				OnLateUpdateLR();
			}
		}
	}

	public void SetTimeScale(float newTimeScale)
	{
		Time.timeScale = newTimeScale;
	}

	public Wait Save()
	{
		saveCounter++;
		if (!saveRoutine.started && !saveRoutine.executing)
		{
			return saveRoutine.Start();
		}
		return Wait.None;
	}

	private IEnumerator<Routine.Yield> SaveRoutine()
	{
		while (saveCounter > 0)
		{
			saveCounter--;
			int i = 0;
			while (i < mrsLoaded.Length)
			{
				if (mrsLoaded[i].isAwake)
				{
					mrsLoaded[i].Save();
					yield return Wait.For.Updates(1);
				}
				int num = i + 1;
				i = num;
			}
			saveDataSettingsMS.Position = 0L;
			saveDataGameMS.Position = 0L;
			Serializer.SerializeToStream(saveDataSettings, saveDataSettingsMS);
			yield return Wait.For.Updates(1);
			Serializer.SerializeToStream(saveDataGame, saveDataGameMS);
			yield return Wait.For.Updates(1);
			saveDataSettingsMS.Position = 0L;
			saveDataGameMS.Position = 0L;
			SaveLoad.Save(default(SaveLoad.DataHeader), saveDataSettingsMS, saveCompleteHandler, 1, unthreaded: false, silent: true);
			yield return saveCompleteTrigger;
			SaveLoad.Save(default(SaveLoad.DataHeader), saveDataGameMS, saveCompleteHandler, 0, unthreaded: false, silent: true);
			yield return saveCompleteTrigger;
		}
	}

	private IEnumerator<Routine.Yield> SaveAfterScenesLoadedRoutine()
	{
		yield return Wait.For.LRUpdates(1);
		yield return Inst.IsAllConnectedScenesLoaded;
		yield return Inst.Save();
	}

	private string GetSaveDataBasePath()
	{
		return UnityEngine.Application.persistentDataPath;
	}

	public void ClearSave()
	{
		SaveLoad.Retain(2, null, unthreaded: true, null, silent: false, log: false, GetSaveDataBasePath());
		SaveLoad.Delete(null, 0, unthreaded: true);
		SaveLoad.Release();
		LoadSave();
	}

	public void LoadSave()
	{
		if (SaveLoad.Retain(2, null, unthreaded: true, null, silent: false, log: false, GetSaveDataBasePath()).Succeeded())
		{
			LoadSaveGame();
			LoadSaveSettings();
		}
		else
		{
			saveDataGame = new SaveDataGame();
			saveDataSettings = new SaveDataSettings();
		}
	}

	public void LoadSaveGame()
	{
		if (SaveLoad.Load(null, 0, null, unthreaded: true, silent: true).Succeeded())
		{
			saveDataGameMem = SaveLoad.GetAndClearLastLoadedObject<byte[]>();
			saveDataGame = Serializer.DeserialiseFromMemory<SaveDataGame>(saveDataGameMem);
		}
		else
		{
			saveDataGame = new SaveDataGame();
		}
	}

	public void LoadSaveSettings()
	{
		if (SaveLoad.Load(null, 1, null, unthreaded: true).Succeeded())
		{
			saveDataSettingsMem = SaveLoad.GetAndClearLastLoadedObject<byte[]>();
			saveDataSettings = Serializer.DeserialiseFromMemory<SaveDataSettings>(saveDataSettingsMem);
		}
		else
		{
			saveDataSettings = new SaveDataSettings();
		}
	}

	public T GetIDObject<T>(string id, UnityEngine.Object context = null) where T : IDObject
	{
		return IDObject.GetIDObject<T>(idObjects, id, context);
	}

	public bool TryGetIDObject<T>(string id, out T value, UnityEngine.Object context = null) where T : IDObject
	{
		if (idObjects != null)
		{
			return IDObject.TryGetIDObject<T>(idObjects, id, out value, context);
		}
		value = null;
		return false;
	}

	public T GetIDObject<T>(IDObjectRef objRef, UnityEngine.Object context = null) where T : IDObject
	{
		return GetIDObject<T>(objRef.id, context);
	}

	public bool TryGetIDObject<T>(IDObjectRef objRef, out T value, UnityEngine.Object context = null) where T : IDObject
	{
		if (objRef == null || !objRef.IsRefLoaded())
		{
			value = null;
			return false;
		}
		if (TryGetIDObject<T>(objRef.id, out value))
		{
			return true;
		}
		value = null;
		return false;
	}

	public T GetIDObjectComponent<T>(IDObjectRef objRef, UnityEngine.Object context = null) where T : class
	{
		IDObject iDObject = GetIDObject<IDObject>(objRef, context);
		T result = null;
		if ((bool)iDObject)
		{
			return iDObject.GetComponent<T>();
		}
		return result;
	}

	public bool TryGetIDObjectComponent<T>(IDObjectRef objRef, out T value, UnityEngine.Object context = null) where T : class
	{
		if (!TryGetIDObject<IDObject>(objRef, out var value2, context))
		{
			value = null;
			return false;
		}
		value = value2.GetComponent<T>();
		if (value == null)
		{
			return false;
		}
		return true;
	}

	public static bool EditorSpawnPlayer()
	{
		return false;
	}

	public static bool SpawnPlayer(MRBase mr)
	{
		PlayerSpawnPoint componentInChildren = mr.GetComponentInChildren<PlayerSpawnPoint>();
		if (!componentInChildren)
		{
			return false;
		}
		Transform transform = componentInChildren.transform;
		Vector3 hitPosWorld;
		Region region = FindFocusedRegion(mr.regions, new Ray(transform.position + transform.up, -transform.up), out hitPosWorld);
		if (region == null)
		{
			return false;
		}
		SpawnPlayer(region, hitPosWorld, transform.transform.rotation);
		return true;
	}

	public static bool SpawnPlayer(MRBase mr, Vector3 startPos, Quaternion startRot, bool forcePosition = false)
	{
		Region.ValidPos closestValidPos = Region.GetClosestValidPos(startRot * Vector3.up, startPos, mr.regions);
		if (!closestValidPos.valid)
		{
			return false;
		}
		SpawnPlayer(closestValidPos.region, forcePosition ? startPos : closestValidPos.worldPos, startRot);
		return true;
	}

	private static void SpawnPlayer(Region startingRegion, Vector3 startPos, Quaternion startRot)
	{
		CC.Inst.transform.rotation = startRot;
		startPos = CC.Inst.CalculateCCPosFromHeadPos(startPos, checkOOB: false);
		CC.Inst.transform.position = startPos;
		CC.Inst.SetRegion(startingRegion);
		if (!IC.isHmdPresent)
		{
			MainCamera.Inst.transform.localPosition = Vector3.up * 1.78f;
			MainCamera.Inst.transform.localRotation = Quaternion.identity;
		}
		IC.Inst.MainMenuIntercept = false;
		PlayerTeleport.TeleportEnabled.Value = true;
		PlayerFreeMove.FreeMoveEnabled.Value = true;
	}

	public static Region FindFocusedRegion(Region[] regions, Ray ray, out Vector3 hitPosWorld)
	{
		Region result = null;
		hitPosWorld = Vector3.zero;
		float num = float.MaxValue;
		foreach (Region region in regions)
		{
			if (region.Raycast(ray, out var distance, out var hitPosWorld2) && distance < num)
			{
				hitPosWorld = hitPosWorld2;
				result = region;
				num = distance;
			}
		}
		return result;
	}

	public static void EnsureBatching()
	{
		try
		{
			SceneManager.LoadScene("TheBatcher", LoadSceneMode.Additive);
			SceneManager.UnloadSceneAsync("TheBatcher");
		}
		catch
		{
			UnityEngine.Debug.Log("BATCH SCENE NOT INCLUDED");
		}
	}

	private IEnumerator<Routine.Yield> FadeAndSpawnRoutine(float fadeTime, SceneInfo targetSceneInfo, MRBase owner)
	{
		NexusFullScreenPass.Inst.StartFadeToColor(fadeTime, NexusFullScreenPass.offWhite);
		yield return Wait.For.Seconds(fadeTime);
		OVROverlayNexus.Inst.SetupColor(black: false);
		if (!owner.CalculateConnectedScenes().Contains(targetSceneInfo))
		{
			owner.AddConnectingScene(targetSceneInfo);
			LoadAdjacentScenes();
		}
		yield return IsAllConnectedScenesLoaded;
		EnsureBatching();
		MRBase mr = GetMRBaseWithSceneInfo(targetSceneInfo);
		yield return Wait.For.Updates(1);
		SpawnPlayer(mr);
		NexusFullScreenPass.Inst.ForceUpdateLastValidPosition();
		yield return IsAllConnectedScenesLoaded;
		Resources.UnloadUnusedAssets();
		OVROverlayNexus.Inst.SetupColor(black: true);
		NexusFullScreenPass.Inst.StartFadeToClear(fadeTime);
		yield return Wait.For.Seconds(fadeTime);
	}

	public static Vector3 GetEditorCameraPos()
	{
		return Vector3.zero;
	}

	public static Vector3 GetEditorCameraDirection()
	{
		return Vector3.forward;
	}

	public static RayPortalResult RayTransformWithPortals(Ray ray, float maxDistance = float.MaxValue, int layerMask = -1)
	{
		return _RayTransformWithPortals(ray, maxDistance, layerMask);
	}

	private static RayPortalResult _RayTransformWithPortals(Ray ray, float maxDistance, int layerMask)
	{
		RayPortalResult result = default(RayPortalResult);
		if (Physics.Raycast(ray, out var hitInfo, maxDistance, layerMask, QueryTriggerInteraction.Ignore))
		{
			if (hitInfo.collider.gameObject.layer == 10)
			{
				Portal component = hitInfo.collider.gameObject.GetComponent<Portal>();
				if ((bool)component.Link)
				{
					ray.origin = hitInfo.point + ray.direction * 0.01f;
					Portal.PortalTransform portalTransform = component.CalculatePortalObjectTransform(ray.origin, Quaternion.identity, ray.direction);
					result.ray.origin = portalTransform.position;
					result.ray.direction = portalTransform.direction;
					result.portal = component;
					result.hit = hitInfo;
					result.length = maxDistance - hitInfo.distance;
				}
				else
				{
					result.ray = ray;
				}
			}
			else
			{
				result.ray = ray;
				result.hit = hitInfo;
			}
		}
		else
		{
			result.ray = ray;
			result.length = maxDistance;
		}
		return result;
	}

	public bool CurrentMusicEquals(FMODEventAsset music)
	{
		return currentMusic == music;
	}

	public void SetMusic(FMODEventAsset music)
	{
		if (!CurrentMusicEquals(music))
		{
			StopMusic();
			musicInstance = FAC.Inst.PlayOneShot(music, Vector3.zero);
			musicInstance.setParameterValue("MusicVolume", GetAudioValue(0));
			currentMusic = music;
		}
	}

	public void StopMusic()
	{
		if (musicInstance.isValid())
		{
			musicInstance.stop(STOP_MODE.ALLOWFADEOUT);
		}
		currentMusic = null;
	}

	public void PlayMusicOneShot(FMODEventAsset musicOneShot)
	{
		if (musicOneshotInstance.isValid())
		{
			musicOneshotInstance.stop(STOP_MODE.ALLOWFADEOUT);
		}
		musicOneshotInstance = FAC.Inst.PlayOneShot(musicOneShot, Vector3.zero);
		musicOneshotInstance.setParameterValue("MusicVolume", GetAudioValue(0));
	}

	public void SetMusicParameter(string param, float value)
	{
		if (musicInstance.isValid())
		{
			musicInstance.setParameterValue(param, value);
		}
	}

	private IEnumerator<Routine.Yield> HACK_RadioRoutine(bool skipToWakeUp = false)
	{
		TutorialSettings settings = BaseSettings<TutorialSettings>.Inst;
		RadioStub radioStub = UnityEngine.Object.FindObjectOfType<RadioStub>();
		HACK_radioPos = radioStub.transform.position;
		HACK_soundRadioDream = true;
		HACK_soundRadio = FAC.Inst.PlayOneShot(settings.soundRadio.Value, CC.Inst.transform.position);
		if (!skipToWakeUp)
		{
			while (!HACK_soundRadioStartFade)
			{
				yield return Wait.For.Updates(1);
			}
			while (HACK_soundRadioDream)
			{
				HACK_soundRadioParam = Mathf.MoveTowards(HACK_soundRadioParam, 0.5f, Time.deltaTime / settings.soundRadioDelta);
				HACK_soundRadio.setParameterValue("RadioDirection", HACK_soundRadioParam);
				yield return Wait.For.Updates(1);
			}
		}
		else
		{
			HACK_soundRadioParam = 0.5f;
		}
		HACK_soundRadio.set3DAttributes(HACK_radioPos.to3DAttributes());
		while (HACK_soundRadioParam != 1f)
		{
			HACK_soundRadioParam = Mathf.MoveTowards(HACK_soundRadioParam, 1f, Time.deltaTime / settings.soundRadioDelta);
			HACK_soundRadio.setParameterValue("RadioDirection", HACK_soundRadioParam);
			yield return Wait.For.Updates(1);
		}
	}

	public void SetVCAMusicVolume()
	{
		FAC.Inst.sys.getVCAByID(BaseSettings<VOSettings>.Inst.vcaMusic.Value.fmodGUID, out var vca);
		float audioValue = GetAudioValue(0);
		vca.setVolume(audioValue);
		if (musicInstance.isValid())
		{
			musicInstance.setParameterValue("MusicVolume", audioValue);
		}
		if (musicOneshotInstance.isValid())
		{
			musicOneshotInstance.setParameterValue("MusicVolume", audioValue);
		}
	}

	public void SetVCASFXVolume()
	{
		FAC.Inst.sys.getVCAByID(BaseSettings<VOSettings>.Inst.vcaSFX.Value.fmodGUID, out var vca);
		vca.setVolume(GetAudioValue(1));
	}

	public void SetVCAVoVolume()
	{
		FAC.Inst.sys.getVCAByID(BaseSettings<VOSettings>.Inst.vcaVO.Value.fmodGUID, out var vca);
		vca.setVolume(GetAudioValue(2));
	}

	private float GetAudioValue(int idx)
	{
		return (float)saveDataSettings.volumeLevels[idx] / 5f;
	}

	void Serializer.IUnityObjectSerializer.SerializePrefabInstance(BinaryWriter writer, Serializer_Prefab prefabInstance)
	{
		Serializer.SerializePrefabInstanceDefault(writer, prefabInstance);
	}

	GameObject Serializer.IUnityObjectSerializer.DeserializePrefabInstance(BinaryReader reader, GameObject prefab)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(prefab);
		gameObject.name = prefab.name;
		return Serializer.DeserializePrefabInstanceDefault(reader, prefab, deserializeParentPath: true, gameObject);
	}

	void Serializer.IUnityObjectSerializer.SerializeGameObject(BinaryWriter writer, GameObject gameObject)
	{
		Serializer.SerializeGameObjectDefault(writer, gameObject);
	}

	GameObject Serializer.IUnityObjectSerializer.DeserializeGameObject(BinaryReader reader)
	{
		return Serializer.DeserializeGameObjectDefault(reader);
	}

	void Serializer.IUnityObjectSerializer.SerializeComponent(BinaryWriter writer, UnityEngine.Component component)
	{
		Serializer.SerializeComponentDefault(writer, component);
	}

	UnityEngine.Component Serializer.IUnityObjectSerializer.DeserializeComponent(BinaryReader reader, Type type)
	{
		return Serializer.DeserializeComponentDefault(reader, type);
	}
}
public class ParticleSystemFromPool : GameObjectPool<ParticlePrefab, ParticleSystemFromPool>.GOFromPool
{
	private float timeToDestroy;

	public override void OnReady()
	{
		timeToDestroy = pr.component.duration * 2f;
	}

	public override void OnStop()
	{
		timeToDestroy = 0f;
		base.gameObject.SetActive(value: false);
	}

	private void LateUpdate()
	{
		if (timeToDestroy > 0f)
		{
			if ((!pr.component.loop || !pr.component.isPlaying) && !pr.component.IsPaused)
			{
				timeToDestroy -= IC.DeltaTime;
			}
		}
		else
		{
			base.gameObject.SetActive(value: false);
		}
	}
}
public class ParticlePrefabPool : GameObjectPool<ParticlePrefab, ParticleSystemFromPool>
{
	protected override void OnAllocate(ParticlePrefab newObject, ParticleSystemFromPool newWatcher)
	{
		newObject.ps = newObject.GetComponentsInChildren<ParticleSystem>(includeInactive: true);
	}
}
public class PSC : MonoBehaviour, IPrebuildEvent
{
	private static PSC _inst;

	public readonly HagletFlag allPoolsLoaded = new HagletFlag();

	[NonSerialized]
	[HideInInspector]
	public int LoadedPoolCount;

	public ParticlePrefab[] particlePoolPrefabs;

	private bool paused;

	private ParticlePrefabPool[] particlePrefabPools;

	private PoolUpdateRunner updateRunner;

	private IHaglet initRoutine;

	private readonly Dictionary<ParticleType, int> indexByType = new Dictionary<ParticleType, int>();

	[SerializeField]
	private ParticleType[] typesCached;

	public static PSC Inst
	{
		get
		{
			if (_inst == null)
			{
				throw new InvalidOperationException("Particle system controller not initialized.");
			}
			return _inst;
		}
		private set
		{
			if (_inst != null && value != null)
			{
				throw new InvalidOperationException("More than one particle system controller initialized.");
			}
			_inst = value;
		}
	}

	public int TotalPoolCount => particlePrefabPools.Length;

	void IPrebuildEvent.OnPrebuildRoot(bool isPrefab)
	{
		typesCached = new ParticleType[particlePoolPrefabs.Length];
		for (int i = 0; i < typesCached.Length; i++)
		{
			typesCached[i] = ParticlePrefab.GetTypeFromPath(particlePoolPrefabs[i].name);
		}
	}

	public Wait OnAwakeLR()
	{
		for (int i = 0; i < particlePoolPrefabs.Length; i++)
		{
			indexByType.Add(typesCached[i], i);
		}
		updateRunner = base.gameObject.AddComponent<PoolUpdateRunner>();
		particlePrefabPools = new ParticlePrefabPool[particlePoolPrefabs.Length];
		allPoolsLoaded.Clear();
		Inst = this;
		Haglet.Create(out initRoutine, SetupParticleSystems);
		return initRoutine.Start();
	}

	private void OnDestroy()
	{
		if (initRoutine != null)
		{
			initRoutine.Stop();
		}
		Inst = null;
	}

	public IEnumerator<Routine.Yield> SetupParticleSystems()
	{
		yield return Wait.For.LRUpdates(1);
		int i = 0;
		while (i < particlePoolPrefabs.Length)
		{
			ParticlePrefabPool ppp = SetupPrefabPool(i);
			if (ppp == null)
			{
				UnityEngine.Debug.LogError("Failed to setup pool for " + ParticlePrefab.GetTypeNameFromPath(particlePoolPrefabs[i].name));
				yield return Wait.For.LRUpdates(1);
			}
			else
			{
				yield return Wait.Until.False(() => ppp.TotalInstCount < ppp.initialSize);
			}
			LoadedPoolCount++;
			int num = i + 1;
			i = num;
		}
		allPoolsLoaded.Set();
	}

	private ParticlePrefabPool SetupPrefabPool(ParticleType particleType)
	{
		if (indexByType.TryGetValue(particleType, out var value))
		{
			return SetupPrefabPool(value);
		}
		UnityEngine.Debug.LogError("This particle system controller does not contain the particle type " + particleType);
		return null;
	}

	private ParticlePrefabPool SetupPrefabPool(int index)
	{
		if (particlePrefabPools[index] != null)
		{
			return particlePrefabPools[index];
		}
		ParticlePrefab particlePrefab = particlePoolPrefabs[index];
		ParticlePrefabPool particlePrefabPool = base.gameObject.AddComponent<ParticlePrefabPool>();
		particlePrefabPools[index] = particlePrefabPool;
		particlePrefabPool.updateRunner = updateRunner;
		particlePrefabPool.sourcePrefab = particlePrefab;
		particlePrefabPool.initialSize = particlePrefab.intialNum;
		particlePrefabPool.maxSize = particlePrefab.maxNum;
		particlePrefabPool.Init(fillImmediately: false);
		return particlePrefabPool;
	}

	public ParticlePrefab Play(ParticleType particleType, Transform parent)
	{
		return Play(particleType, Vector3.zero, Quaternion.identity, Vector3.one, parent);
	}

	public ParticlePrefab Play(ParticleType particleType, Vector3 localPosition, Quaternion localRotation, Vector3 localScale, Transform parent = null, bool clear = false)
	{
		Vector3 worldPostion = ((parent == null) ? localPosition : parent.TransformPoint(localPosition));
		ParticlePrefab particlePrefab = Get(particleType, worldPostion, parent);
		Transform obj = particlePrefab.transform;
		obj.localRotation = localRotation;
		obj.localScale = localScale;
		if (clear)
		{
			particlePrefab.ClearParticles();
		}
		particlePrefab.PlayParticles();
		return particlePrefab;
	}

	public ParticlePrefab PlayAt(ParticleType particleType, Vector3 position, bool clear = true)
	{
		ParticlePrefab particlePrefab = Get(particleType, position);
		_ = particlePrefab.transform;
		if (clear)
		{
			particlePrefab.ClearParticles();
		}
		particlePrefab.PlayParticles();
		return particlePrefab;
	}

	public ParticlePrefab Get(ParticleType particleType, Vector3 worldPostion, Transform parent = null, bool active = true)
	{
		ParticleSystemFromPool watcher;
		return GetPool(particleType).Get(out watcher, worldPostion, parent, active);
	}

	public ParticlePrefabPool GetPool(ParticleType particleType)
	{
		ParticlePrefabPool particlePrefabPool = null;
		for (int i = 0; i < particlePrefabPools.Length; i++)
		{
			if (!(particlePrefabPools[i] == null) && particlePrefabPools[i].sourcePrefab.particleType == particleType)
			{
				particlePrefabPool = particlePrefabPools[i];
				break;
			}
		}
		if (particlePrefabPool == null)
		{
			particlePrefabPool = SetupPrefabPool(particleType);
		}
		return particlePrefabPool;
	}

	public void SetPaused(bool pause)
	{
		if (paused == pause)
		{
			return;
		}
		for (int i = 0; i < particlePrefabPools.Length; i++)
		{
			if (!(particlePrefabPools[i] != null))
			{
				continue;
			}
			foreach (GameObjectPool<ParticlePrefab, ParticleSystemFromPool>.PoolReferences activeObject in particlePrefabPools[i]._activeObjects)
			{
				if (pause)
				{
					activeObject.component.PauseParticles();
				}
				else
				{
					activeObject.component.PlayParticles();
				}
			}
		}
		paused = pause;
	}
}
public class SceneRenderSettings : MonoBehaviour
{
	public enum FogNoiseMode
	{
		Off,
		Multiply,
		Add
	}

	private const float GAMEPLAY_LAYER_CULL_DISTANCE = 100f;

	private static float[] layerCullOn;

	private static float[] layerCullOff;

	private CommandBuffer shaderPropertiesCMD;

	public float cameraFarClip = 850f;

	public bool useFarClipForAllLayers;

	public Texture2D skybox;

	public Vector2 skyboxCenter = new Vector2(0.5f, 0.5f);

	public float skyboxXScale = 1f;

	public float skyboxFadeEnd = 1f;

	public float skyboxFadeStart = 5f;

	public bool enableFog;

	[ConditionalHide("enableFog")]
	public float fogStartDepth = 10f;

	[ConditionalHide("enableFog")]
	public float fogEndDepth = 200f;

	[ConditionalHide("enableFog")]
	public float fogStartHeight = -50f;

	[ConditionalHide("enableFog")]
	public float fogEndHeight = -10f;

	[ConditionalHide("enableFog")]
	public float fogStrength = 1f;

	[ConditionalHide("enableFog")]
	public float fogStrengthMin;

	[ConditionalHide("enableFog")]
	public FogNoiseMode fogNoiseMode = FogNoiseMode.Multiply;

	[ConditionalHide("fogNoiseMode", targetEnumValue = 0)]
	public float fogNoiseScale = 15f;

	[ConditionalHide("fogNoiseMode", targetEnumValue = 0)]
	public float fogNoiseSpeed = 1.5f;

	[ConditionalHide("fogNoiseMode", targetEnumValue = 0)]
	public float fogNoiseDensityTarget = 0.1f;

	[ConditionalHide("fogNoiseMode", targetEnumValue = 0)]
	public float fogNoiseStrength = 1f;

	[ConditionalHide("enableFog")]
	public Texture2D fogLookUp;

	public float lightmapStrength = 2f;

	public Cubemap sceneCubemap;

	public Sunlight sunlight;

	public bool enableAmbientLights = true;

	public Color ambientColorIntensity = new Color(0.3f, 0.3f, 0.3f, 1f);

	public bool enableContrastEffect;

	[ConditionalHide("enableContrastEffect")]
	public float greyscaleStrength;

	[ConditionalHide("enableContrastEffect")]
	public float contrastCenter = 0.5f;

	[ConditionalHide("enableContrastEffect")]
	public float contrastPower = 1f;

	[ConditionalHide("enableContrastEffect")]
	public float minValue;

	[ConditionalHide("enableContrastEffect")]
	public float maxValue = 1f;

	public CommandBuffer ShaderPropertiesCMD => shaderPropertiesCMD;

	static SceneRenderSettings()
	{
		layerCullOn = new float[32];
		layerCullOff = new float[32];
		for (int i = 0; i < layerCullOn.Length; i++)
		{
			layerCullOn[i] = 100f;
			layerCullOff[i] = 0f;
		}
		layerCullOn[31] = 0f;
	}

	public void OnAwakeLR(MRBase owner)
	{
		shaderPropertiesCMD = new CommandBuffer
		{
			name = owner.info.Load().prettyName + " Shader Properties"
		};
	}

	public void UpdateRenderingData()
	{
		shaderPropertiesCMD.Clear();
		ApplyShaderProperties(shaderPropertiesCMD);
	}

	public void ApplyShaderProperties(CommandBuffer cb)
	{
		NexusRenderPipeline inst = NexusRenderPipeline.Inst;
		if ((bool)skybox)
		{
			cb.SetSkybox_NX(skybox, skyboxCenter, skyboxXScale);
		}
		else
		{
			inst.ApplyDefaultSkyboxProperties(cb);
		}
		cb.SetGlobalVector(ShaderPID._SkyboxFadeParams, new Vector4(cameraFarClip - skyboxFadeStart, cameraFarClip - skyboxFadeEnd, 0f, 0f));
		if (enableFog)
		{
			cb.EnableShaderKeyword("FOG_ON");
			cb.SetGlobalTexture(ShaderPID._FogLookUp, fogLookUp);
			cb.SetGlobalVector(ShaderPID._FogStrength, new Vector4(fogStrength, fogStrengthMin, 1f, 1f));
			cb.SetGlobalVector(ShaderPID._FogRange, new Vector4(fogStartDepth, 1f / (fogEndDepth - fogStartDepth), fogStartHeight, 1f / (fogEndHeight - fogStartHeight)));
		}
		else
		{
			cb.DisableShaderKeyword("FOG_ON");
		}
		cb.SetGlobalFloat(ShaderPID._LightmapStrength, lightmapStrength);
		cb.SetGlobalTexture(ShaderPID._SceneCube, sceneCubemap);
		if (sunlight != null)
		{
			Vector4 value = -sunlight.transform.forward;
			Vector4 value2 = sunlight.lightColor;
			value2.w = sunlight.intensity;
			cb.EnableShaderKeyword("SUNLIGHT_ON");
			cb.SetGlobalVector(ShaderPID._SunDirection, value);
			cb.SetGlobalVector(ShaderPID._SunColor_Intensity, value2);
		}
		else
		{
			cb.DisableShaderKeyword("SUNLIGHT_ON");
		}
		if (enableAmbientLights)
		{
			cb.SetGlobalVector(ShaderPID._AmbientColor_Intensity, ambientColorIntensity);
		}
		else
		{
			cb.SetGlobalVector(ShaderPID._AmbientColor_Intensity, ColorX.black);
		}
		if (enableContrastEffect)
		{
			cb.EnableShaderKeyword("NEXUS_GREY_CONTRAST_EFFECT_ON");
			cb.SetGlobalVector(ShaderPID._GreyContrastEffect, new Vector4(contrastPower, contrastCenter, greyscaleStrength, 0f));
			cb.SetGlobalVector(ShaderPID._MinMaxValue, new Vector4(minValue, maxValue, 0f, 0f));
		}
		else
		{
			cb.DisableShaderKeyword("NEXUS_GREY_CONTRAST_EFFECT_ON");
		}
	}

	public void ApplyCameraProperties(Camera cam)
	{
		cam.farClipPlane = cameraFarClip;
		cam.layerCullDistances = (useFarClipForAllLayers ? layerCullOff : layerCullOn);
	}
}
[Serializer.ExcludeAllFields]
public class MRBase : RootBase
{
	private struct RBInitState
	{
		public bool kinematic;

		public Rigidbody rb;
	}

	[ReadOnly]
	public bool isLoadedRefs;

	[ReadOnly]
	public bool isAwake;

	[ReadOnly]
	public bool shouldUpdate;

	[ReadOnly]
	public bool awakeFailed;

	public int debugAreaEnterNotificationCount;

	private ConstArray<SceneInfo> connectedScenes = new ConstArray<SceneInfo>(16u);

	private ConstArray<SceneInfo> connectedScenesRuntime = new ConstArray<SceneInfo>(16u);

	private ConstArray<Material> allMaterials = new ConstArray<Material>(128u);

	[ReadOnly]
	public SceneInfo_BundleRef info;

	[SerializeField]
	private FMODAmbientSource[] allAmbienceSources;

	[NonSerialized]
	[HideInInspector]
	public ConstArray<Portal> portals;

	[HideInInspector]
	public Trigger[] triggers;

	[NonSerialized]
	[HideInInspector]
	public FrustumDetector[] frustumDetectors;

	[NonSerialized]
	[HideInInspector]
	public FrustumDetector3D[] frustumDetectors3D;

	[NonSerialized]
	[HideInInspector]
	public FrustumObject[] frustumObjects;

	[NonSerialized]
	[HideInInspector]
	public ConstArray<InteractableObject> interactableObjects;

	[NonSerialized]
	[HideInInspector]
	public ConstArray<InteractiveBeam> interactiveBeams;

	[NonSerialized]
	[HideInInspector]
	public ConstArray<PortalingRigidbody> portalingRidgidbodies;

	[NonSerialized]
	[HideInInspector]
	public ConstArray<PortalingAnimObject> portalingAnimObjects;

	[NonSerialized]
	[HideInInspector]
	public Region[] regions;

	[NonSerialized]
	[HideInInspector]
	public ConstArray<Rasterizer> rasterizers;

	[NonSerialized]
	[HideInInspector]
	public RasterizerGroup[] rasterizerGroups;

	[NonSerialized]
	[HideInInspector]
	public ObeliskPuzzleObject[] puzzleObjects;

	[NonSerialized]
	[HideInInspector]
	public Obelisk obelisk;

	[NonSerialized]
	[HideInInspector]
	public ConstArray<HookPoint> hookPoints;

	[NonSerialized]
	[HideInInspector]
	public ConstArray<GravityDangler> gravityDanglers;

	[NonSerialized]
	[HideInInspector]
	public Telepoint[] telepoints;

	[HideInInspector]
	[SerializeField]
	public ObjectAreaTrigger[] objectAreaTriggers;

	[HideInInspector]
	[SerializeField]
	public GrabObjectAreaTrigger[] grabObjectAreaTriggers;

	[HideInInspector]
	[SerializeField]
	public CutsceneAreaTrigger[] cutsceneAreaTriggers;

	[HideInInspector]
	[SerializeField]
	public PlayerAreaTrigger[] playerAreaTriggers;

	[NonSerialized]
	[HideInInspector]
	public ConstArray<LightSensor> lightSensors;

	[HideInInspector]
	public ConstArray<ICanBeRasterized> rasterizables;

	[HideInInspector]
	public ConstArray<KubrickAnimator> kubrickAnimators;

	[NonSerialized]
	[HideInInspector]
	public ConstArray<PortalRenderer> portalRenderers;

	[HideInInspector]
	[SerializeField]
	public Stairway[] stairways;

	[HideInInspector]
	[SerializeField]
	public GameObject[] gameObjectsToActivate;

	[NonSerialized]
	[HideInInspector]
	public ConstArray<IAreaEvent> areaEventSubscribers;

	[NonSerialized]
	[HideInInspector]
	public ConstArray<ICutsceneEvent> cutsceneEventSubscribers;

	[NonSerialized]
	[HideInInspector]
	public IUpdateEvent[] updateEventSubscribers;

	[NonSerialized]
	[HideInInspector]
	public ILateUpdateEvent[] lateUpdateEventSubscribers;

	[NonSerialized]
	[HideInInspector]
	public IPostPhysicsUpdateEvent[] postPhysicsUpdateEventSubscribers;

	[NonSerialized]
	[HideInInspector]
	public IPauseEvent[] pauseEventSubscribers;

	[NonSerialized]
	[HideInInspector]
	public IPauseUpdate[] pauseUpdateSubscribers;

	[NonSerialized]
	[HideInInspector]
	public IRealtimeUpdate[] realtimeUpdateSubscribers;

	[NonSerialized]
	[HideInInspector]
	public BoundaryBox[] boundaryBoxes;

	[HideInInspector]
	[SerializeField]
	public PlacementHelper[] placementHelpers;

	[HideInInspector]
	[SerializeField]
	public EGrill[] eGrills;

	[HideInInspector]
	[SerializeField]
	public MaskHide[] maskHides;

	[HideInInspector]
	[SerializeField]
	public Animation[] animations;

	public ConstArray<ObjectMimic> m_objectMimics = new ConstArray<ObjectMimic>(32u);

	[NonSerialized]
	[HideInInspector]
	public ConstArray<PortalVariations> portalVariations;

	[NonSerialized]
	[HideInInspector]
	public ConstArray<LightSource> lightSources;

	[NonSerialized]
	[HideInInspector]
	public ConstArray<ISceneUnloadEvent> sceneUnloadEvents;

	public SceneRenderSettings sceneRenderSettings;

	public SceneInfo mimicSceneInfo;

	public AmbientAudioProbeGroup ambientProbes;

	public ReturnPortalStub returnPortal;

	[HideInInspector]
	[SerializeField]
	public NothingToSeeHere nothingToSeeHere;

	[HideInInspector]
	public string[] linkedScenesUIDs;

	[NonSerialized]
	[Serializer.IncludeField]
	[HideInInspector]
	private ConstArray<InteractableObject> interactableObjectsToSave;

	[Serializer.IncludeField]
	[HideInInspector]
	public InteractableTarget[] interactableTargets;

	[NonSerialized]
	[Serializer.IncludeField]
	[HideInInspector]
	public ConstArray<HAGIS> hagiss;

	[NonSerialized]
	[Serializer.IncludeField]
	[HideInInspector]
	public ConstArray<IOccludee> staticOccludees;

	[NonSerialized]
	[Serializer.IncludeField]
	[HideInInspector]
	public ConstArray<Doorway> doorways;

	[NonSerialized]
	[Serializer.IncludeField]
	[HideInInspector]
	public MultiLightmapController lightmapController;

	[NonSerialized]
	[Serializer.IncludeField]
	[HideInInspector]
	public ConstArray<AnimPath> animPaths;

	public float objectResetDistance = 1000f;

	[HideInInspector]
	public InventoryState[] eGrillInventories = new InventoryState[16];

	[NonSerialized]
	[HideInInspector]
	public uint sceneMask;

	public Color rasterizerBackgroundColor = Color.grey;

	[SerializeField]
	[HideInInspector]
	private string sceneName = "";

	private ConstArray<Texture> sceneTextures = new ConstArray<Texture>(10u);

	private IHaglet spawnObjectsRoutine;

	private IHaglet onAwakeLR;

	private IHaglet onUnloadRoutine;

	private IHaglet<int, int, FMODAmbientSource[]> spreadAmbientSoundStart;

	public ConstArray<SceneInfo> CalculateConnectedScenes()
	{
		connectedScenesRuntime.ClearToDefault();
		for (int i = 0; i < connectedScenes.Length; i++)
		{
			connectedScenesRuntime.Add(connectedScenes[i]);
		}
		SceneInfo sceneInfo = info.Load();
		if (portals != null && sceneInfo.allowSceneRefConnections)
		{
			for (int j = 0; j < portals.Length; j++)
			{
				Portal portal = portals[j];
				if (!portal.gameObject.activeInHierarchy)
				{
					continue;
				}
				Portal link = portal.Link;
				if ((bool)link && link.Link == portal && link.owner != this)
				{
					SceneInfo sceneInfo2 = link.owner.info.Load();
					if (!connectedScenesRuntime.Contains(sceneInfo2))
					{
						connectedScenesRuntime.Add(sceneInfo2);
					}
				}
			}
		}
		return connectedScenesRuntime;
	}

	public void AddConnectingScene(SceneInfo info)
	{
		if (!connectedScenes.Contains(info))
		{
			connectedScenes.Add(info);
		}
	}

	public void RemoveConnectingScene(SceneInfo info)
	{
		if (connectedScenes.Contains(info))
		{
			connectedScenes.Remove(info);
		}
	}

	public void ClearConnectedScenes()
	{
		connectedScenes.Clear();
	}

	protected void Awake()
	{
	}

	public override string ToString()
	{
		return base.name;
	}

	public Wait OnAwakeLR(SceneInfo mimicSceneInfo)
	{
		this.mimicSceneInfo = mimicSceneInfo;
		InitialiseReturnPortal();
		Haglet.Create(out onAwakeLR, _OnAwakeLR, null, startNow: false, 32);
		Haglet.Create(out onUnloadRoutine, OnUnloadRoutine);
		Haglet.Create(out spreadAmbientSoundStart, (Routine.Func3<int, int, FMODAmbientSource[]>)SpreadAmbientSoundStart, (string)null, startNow: false, (int?)null, (string)null);
		onAwakeLR.onException += OnAwakeLR_onException;
		awakeFailed = false;
		return onAwakeLR.Call(1, reset: true, skip: false, requireComplete: false);
	}

	public void InitialiseReturnPortal()
	{
		returnPortal = GetComponentInChildren<ReturnPortalStub>(includeInactive: true);
	}

	protected override void OnPrebuildSelf()
	{
	}

	public Wait SpawnObjects()
	{
		if (spawnObjectsRoutine == null)
		{
			Haglet.Create(out spawnObjectsRoutine, SpawnObjectsRoutine);
		}
		return spawnObjectsRoutine.Start();
	}

	private IEnumerator<Routine.Yield> SpawnObjectsRoutine()
	{
		SaveDataGame saveData = LR.Inst.saveDataGame;
		ConstArray<string> grabObjectsToSave = saveData.SceneGrabObjectsGet(this);
		GrabObject grabObject2;
		for (int k = 0; k < grabObjectsToSave.Length; k++)
		{
			if (saveData.SpawnGrabObjectFromData(grabObjectsToSave[k], out grabObject2) && grabObject2.gameObject.scene != base.gameObject.scene)
			{
				grabObject2.transform.parent = base.transform;
			}
			grabObject2.GetComponent<Rigidbody>().isKinematic = true;
			yield return Wait.For.LRUpdates(1);
			grabObject2.SpawnInventoryItem();
			yield return Wait.For.LRUpdates(1);
			grabObject2 = null;
		}
		ConstArray<string> chapterInventoryIDs = saveData.GetChapterInventory(info.Load());
		uint invCount = chapterInventoryIDs.Length;
		for (int k = 0; k < invCount; k++)
		{
			string id = chapterInventoryIDs[k];
			if (info.Load().GetPuzzleChapter() == SaveDataGame.Chapter.None && !id.StartsWith(info.Load().sceneUIDName))
			{
				UnityEngine.Debug.Log("Tried to load object not from this scene");
				continue;
			}
			yield return Wait.For.LRUpdates(1);
			bool wasSpawned = saveData.SpawnGrabObjectFromData(id, out grabObject2);
			yield return Wait.For.LRUpdates(1);
			if (wasSpawned)
			{
				grabObject2.SpawnInventoryItem();
				yield return Wait.For.LRUpdates(1);
				Transform transform = grabObject2.transform;
				if (transform.root == transform)
				{
					transform.SetParent(base.transform);
					grabObject2.inventoryObject.transform.SetParent(base.transform);
				}
				if ((bool)grabObject2.mimic)
				{
					if (saveData.SpawnGrabObjectFromData(grabObject2.mimic.m_mimicObjectRef.id, out var mimic))
					{
						if (mimic.allowSaving)
						{
							LR.Inst.saveDataGame.AddObjectToChapterInventory(MainCamera.Inst.GetOwner().info.Load().GetPuzzleChapter(), mimic);
						}
						mimic.SpawnInventoryItem();
						yield return Wait.For.LRUpdates(1);
						transform = mimic.transform;
						if (transform.root == transform)
						{
							transform.SetParent(base.transform);
							mimic.inventoryObject.transform.SetParent(base.transform);
						}
					}
					mimic = null;
				}
			}
			yield return Wait.For.LRUpdates(1);
			grabObject2 = null;
		}
		GrabObjectSpawnPoint[] componentsInChildren = GetComponentsInChildren<GrabObjectSpawnPoint>(includeInactive: true);
		GrabObjectSpawnPoint[] array = componentsInChildren;
		foreach (GrabObjectSpawnPoint grabObjectSpawnPoint in array)
		{
			grabObject2 = grabObjectSpawnPoint.Spawn(this);
			if (grabObject2 != null)
			{
				yield return Wait.For.LRUpdates(1);
				grabObject2.SpawnInventoryItem();
				if (grabObject2.allowSaving && !grabObjectsToSave.Contains(grabObject2.id))
				{
					grabObjectsToSave.Add(grabObject2.id);
				}
			}
			yield return Wait.For.LRUpdates(1);
		}
	}

	private void CollectSavedGrabObjects()
	{
		LR inst = LR.Inst;
		string[] array = inst.saveDataGame.SceneGrabObjectsGet(this).ToArray();
		foreach (string id in array)
		{
			GrabObject iDObject = inst.GetIDObject<GrabObject>(id);
			if ((bool)iDObject)
			{
				iDObject.pr.SetOwner(this);
			}
		}
	}

	private void OnAwakeLR_onException(Exception arg1, Haglet.Inspection arg2)
	{
		awakeFailed = true;
	}

	private IEnumerator<Routine.Yield> _OnAwakeLR()
	{
		int yieldCounter = 0;
		int gameObjectsToActivateLength = gameObjectsToActivate.Length;
		int num;
		for (int i4 = 0; i4 < gameObjectsToActivateLength; i4 = num)
		{
			if (gameObjectsToActivate[i4] != null)
			{
				gameObjectsToActivate[i4].SetActive(value: true);
				yieldCounter++;
				if (yieldCounter > 50)
				{
					yieldCounter = 0;
					yield return Wait.For.Updates(1);
				}
			}
			num = i4 + 1;
		}
		yield return LR.InitialiseUIHierarchy(base.transform, hide: false, forceInactiveDuringLoading: false);
		interactableObjectsToSave = new ConstArray<InteractableObject>(64u);
		staticOccludees = new ConstArray<IOccludee>(16u);
		doorways = new ConstArray<Doorway>(16u);
		LR.Inst.saveDataGame.SceneLoad(this);
		sceneRenderSettings = GetComponentInChildren<SceneRenderSettings>();
		if ((bool)sceneRenderSettings)
		{
			sceneRenderSettings.OnAwakeLR(this);
		}
		else
		{
			sceneRenderSettings = null;
		}
		ambientProbes = GetComponentInChildren<AmbientAudioProbeGroup>();
		yield return Wait.For.Updates(1);
		if (ambientProbes != null)
		{
			ambientProbes.OnAwakeLR();
		}
		lightmapController = GetComponentInChildren<MultiLightmapController>(includeInactive: true);
		if ((bool)lightmapController)
		{
			lightmapController.OnAwakeLR(this);
		}
		ConstArray<RBInitState> rigidBodysInitState = new ConstArray<RBInitState>(128u);
		Rigidbody[] componentsInChildren = GetComponentsInChildren<Rigidbody>(includeInactive: true);
		foreach (Rigidbody rigidbody in componentsInChildren)
		{
			RBInitState obj = default(RBInitState);
			obj.rb = rigidbody;
			obj.kinematic = rigidbody.isKinematic;
			rigidbody.useGravity = false;
			rigidbody.isKinematic = true;
			rigidBodysInitState.Add(obj);
		}
		frustumDetectors = GetComponentsInChildren<FrustumDetector>(includeInactive: true);
		FrustumDetector[] array = frustumDetectors;
		for (num = 0; num < array.Length; num++)
		{
			array[num].OnAwakeLR(this);
		}
		yield return Wait.For.Updates(1);
		frustumDetectors3D = GetComponentsInChildren<FrustumDetector3D>(includeInactive: true);
		FrustumDetector3D[] array2 = frustumDetectors3D;
		for (num = 0; num < array2.Length; num++)
		{
			array2[num].OnAwakeLR();
		}
		yield return Wait.For.Updates(1);
		frustumObjects = GetComponentsInChildren<FrustumObject>(includeInactive: true);
		FrustumObject[] array3 = frustumObjects;
		for (num = 0; num < array3.Length; num++)
		{
			array3[num].OnAwakeLR(this);
		}
		yield return Wait.For.Updates(1);
		if ((bool)nothingToSeeHere)
		{
			nothingToSeeHere.OnAwakeLR();
		}
		IOccludee[] componentsInChildren2 = GetComponentsInChildren<IOccludee>(includeInactive: true);
		IOccluder[] occluders = GetComponentsInChildren<IOccluder>(includeInactive: true);
		IOccludee[] array4 = componentsInChildren2;
		foreach (IOccludee occludee in array4)
		{
			MonoBehaviour comp = occludee as MonoBehaviour;
			if (!staticOccludees.Contains(occludee) && comp.GetComponentInAscendant<GrabObject>() == null)
			{
				staticOccludees.Add(occludee);
			}
			occludee.OnOccludeeAwake(this);
		}
		Doorway[] componentsInChildren3 = GetComponentsInChildren<Doorway>(includeInactive: true);
		foreach (Doorway doorway in componentsInChildren3)
		{
			if (!doorways.Contains(doorway))
			{
				doorways.Add(doorway);
			}
		}
		yield return Wait.For.Updates(1);
		IOccluder[] array5 = occluders;
		for (num = 0; num < array5.Length; num++)
		{
			array5[num].OnOccluderAwake(this);
		}
		yield return Wait.For.Updates(1);
		PlayerEntryPoint[] componentsInChildren4 = GetComponentsInChildren<PlayerEntryPoint>(includeInactive: true);
		for (num = 0; num < componentsInChildren4.Length; num++)
		{
			componentsInChildren4[num].OnAwakeLR(this);
		}
		yield return Wait.For.Updates(1);
		Trigger[] array6 = triggers;
		for (num = 0; num < array6.Length; num++)
		{
			array6[num].OnAwakeLR(this);
		}
		yield return Wait.For.Updates(1);
		PlacementHelper[] array7 = placementHelpers;
		for (num = 0; num < array7.Length; num++)
		{
			array7[num].OnAwakeLR();
		}
		yield return Wait.For.Updates(1);
		InteractableTarget[] array8 = interactableTargets;
		for (num = 0; num < array8.Length; num++)
		{
			array8[num].OnAwakeLR(this);
		}
		yield return Wait.For.Updates(1);
		rasterizers = new ConstArray<Rasterizer>(16u);
		Rasterizer[] componentsInChildren5 = GetComponentsInChildren<Rasterizer>(includeInactive: true);
		Rasterizer[] array9 = componentsInChildren5;
		foreach (Rasterizer rasterizer in array9)
		{
			rasterizers.Add(rasterizer);
			rasterizer.OnAwakeLR(this);
			yield return Wait.For.LRUpdates(1);
			yield return rasterizer.IntializeRasterizer();
			yield return Wait.For.LRUpdates(1);
		}
		yield return Wait.For.Updates(1);
		InteractableObject[] interactableArray = GetComponentsInChildren<InteractableObject>(includeInactive: true);
		interactableObjects = new ConstArray<InteractableObject>(512u);
		InteractableObject[] array10 = interactableArray;
		foreach (InteractableObject interactableObject in array10)
		{
			interactableObjects.Add(interactableObject);
			if (!(interactableObject is InventoryObject) && interactableObject.GetComponentInAscendant<GrabObject>() == null && !interactableObjectsToSave.Contains(interactableObject))
			{
				interactableObjectsToSave.Add(interactableObject);
			}
			interactableObject.OnAwakeLR(this);
			yield return Wait.For.Updates(1);
		}
		InteractiveBeam[] componentsInChildren6 = GetComponentsInChildren<InteractiveBeam>(includeInactive: true);
		interactiveBeams = new ConstArray<InteractiveBeam>(512u);
		InteractiveBeam[] array11 = componentsInChildren6;
		foreach (InteractiveBeam obj2 in array11)
		{
			interactiveBeams.Add(obj2);
		}
		yield return Wait.For.Updates(1);
		GrabPoint[] componentsInChildren7 = GetComponentsInChildren<GrabPoint>(includeInactive: true);
		for (num = 0; num < componentsInChildren7.Length; num++)
		{
			componentsInChildren7[num].OnAwakeLR();
		}
		yield return Wait.For.Updates(1);
		InteractableObject[] array12 = interactableArray;
		for (num = 0; num < array12.Length; num++)
		{
			array12[num].ValidateGrabPoints();
		}
		yield return Wait.For.Updates(1);
		PortalingRigidbody[] portalingRidgidbodyArray = GetComponentsInChildren<PortalingRigidbody>(includeInactive: true);
		portalingRidgidbodies = new ConstArray<PortalingRigidbody>(128u);
		PortalingRigidbody[] array13 = portalingRidgidbodyArray;
		foreach (PortalingRigidbody portalingRigidbody in array13)
		{
			portalingRidgidbodies.Add(portalingRigidbody);
			portalingRigidbody.OnAwakeLR(this);
			portalingRigidbody.GatherRenderersAndColliders();
		}
		yield return Wait.For.Updates(1);
		hookPoints = new ConstArray<HookPoint>(64u, GetComponentsInChildren<HookPoint>(includeInactive: true));
		HookPoint.PartitionHooks(hookPoints);
		HookPoint.OnAwakeLR(hookPoints);
		yield return Wait.For.Updates(1);
		array13 = portalingRidgidbodyArray;
		for (num = 0; num < array13.Length; num++)
		{
			array13[num].GatherRenderersAndColliders();
		}
		yield return Wait.For.Updates(1);
		portalingAnimObjects = new ConstArray<PortalingAnimObject>(32u, GetComponentsInChildren<PortalingAnimObject>(includeInactive: true));
		GrabObject[] grabObjects = GetComponentsInChildren<GrabObject>(includeInactive: true);
		GrabObject[] array14 = grabObjects;
		for (int i4 = 0; i4 < array14.Length; i4++)
		{
			array14[i4].SetInitialState();
			yield return Wait.For.LRUpdates(1);
		}
		yield return Wait.For.Updates(1);
		regions = GetComponentsInChildren<Region>(includeInactive: true);
		Region[] array15 = regions;
		for (num = 0; num < array15.Length; num++)
		{
			array15[num].OnAwakeLR(this);
		}
		Region.EvaluateRegions(regions);
		yield return Wait.For.Updates(1);
		EGrill[] array16 = eGrills;
		for (num = 0; num < array16.Length; num++)
		{
			array16[num].OnAwakeLR(this);
		}
		yield return Wait.For.Updates(1);
		for (int num2 = 0; num2 < eGrillInventories.Length; num2++)
		{
			eGrillInventories[num2] = new InventoryState();
		}
		yield return Wait.For.Updates(1);
		lightSources = new ConstArray<LightSource>((uint)NexusRenderPipeline.MAX_LIGHT_IDS, GetComponentsInChildren<LightSource>(includeInactive: true));
		for (int num3 = 0; num3 < lightSources.Length; num3++)
		{
			lightSources[num3].OnAwakeLR();
		}
		yield return Wait.For.Updates(1);
		sceneUnloadEvents = new ConstArray<ISceneUnloadEvent>(512u, GetComponentsInChildren<ISceneUnloadEvent>(includeInactive: true));
		yield return Wait.For.Updates(1);
		lightSensors = new ConstArray<LightSensor>(32u, GetComponentsInChildren<LightSensor>(includeInactive: true));
		for (int num4 = 0; num4 < lightSensors.Length; num4++)
		{
			lightSensors[num4].OnAwakeLR(this);
		}
		yield return Wait.For.Updates(1);
		portals = new ConstArray<Portal>(32u, GetComponentsInChildren<Portal>(includeInactive: true));
		for (int i4 = 0; i4 < portals.Length; i4 = num)
		{
			portals[i4].OnAwakeLR(this, i4 + 1);
			yield return Wait.For.Updates(1);
			num = i4 + 1;
		}
		yield return Wait.For.Updates(1);
		for (int num5 = 0; num5 < portals.Length; num5++)
		{
			Portal portal = portals[num5];
			portal.SetLinkRef(portal.linkRef);
		}
		yield return Wait.For.Updates(1);
		PortalAssignSelfToLink[] componentsInChildren8 = GetComponentsInChildren<PortalAssignSelfToLink>(includeInactive: true);
		for (num = 0; num < componentsInChildren8.Length; num++)
		{
			componentsInChildren8[num].OnAwakeLR();
		}
		yield return Wait.For.Updates(1);
		rasterizerGroups = GetComponentsInChildren<RasterizerGroup>(includeInactive: true);
		RasterizerGroup[] array17 = rasterizerGroups;
		foreach (RasterizerGroup rGroup in array17)
		{
			rGroup.OnAwakeLR(this);
			yield return Wait.For.Updates(1);
			yield return rGroup.IntializeRasterizerGroup();
		}
		yield return Wait.For.Updates(1);
		puzzleObjects = GetComponentsInChildren<ObeliskPuzzleObject>(includeInactive: true);
		ObeliskPuzzleObject[] array18 = puzzleObjects;
		for (num = 0; num < array18.Length; num++)
		{
			array18[num].IntializePuzzle();
		}
		yield return Wait.For.Updates(1);
		telepoints = GetComponentsInChildren<Telepoint>(includeInactive: true);
		Telepoint[] array19 = telepoints;
		for (num = 0; num < array19.Length; num++)
		{
			array19[num].OnAwakeLR();
		}
		yield return Wait.For.Updates(1);
		gravityDanglers = new ConstArray<GravityDangler>(32u);
		GravityDangler[] componentsInChildren9 = GetComponentsInChildren<GravityDangler>(includeInactive: true);
		foreach (GravityDangler gravityDangler in componentsInChildren9)
		{
			gravityDangler.OnAwakeLR();
			gravityDanglers.Add(gravityDangler);
		}
		yield return Wait.For.Updates(1);
		obelisk = GetComponentInChildren<Obelisk>(includeInactive: true);
		if ((bool)obelisk)
		{
			obelisk.OnAwakeLR(this);
		}
		yield return Wait.For.Updates(1);
		Constellation[] componentsInChildren10 = GetComponentsInChildren<Constellation>(includeInactive: true);
		for (int num6 = 0; num6 < componentsInChildren10.Length; num6++)
		{
			componentsInChildren10[num6].OnAwakeLR();
		}
		yield return Wait.For.Updates(1);
		boundaryBoxes = GetComponentsInChildren<BoundaryBox>(includeInactive: true);
		BoundaryBox[] array20 = boundaryBoxes;
		for (num = 0; num < array20.Length; num++)
		{
			array20[num].OnAwakeLR();
		}
		yield return Wait.For.Updates(1);
		ObjectMimic[] componentsInChildren11 = GetComponentsInChildren<ObjectMimic>(includeInactive: true);
		foreach (ObjectMimic objectMimic in componentsInChildren11)
		{
			m_objectMimics.Add(objectMimic);
			objectMimic.OnAwakeLR(this);
		}
		yield return Wait.For.Updates(1);
		portalVariations = new ConstArray<PortalVariations>(64u, GetComponentsInChildren<PortalVariations>(includeInactive: true));
		for (int num7 = 0; num7 < portalVariations.Length; num7++)
		{
			portalVariations[num7].OnAwakeLR();
		}
		yield return Wait.For.Updates(1);
		areaEventSubscribers = new ConstArray<IAreaEvent>(64u);
		IAreaEvent[] componentsInChildren12 = GetComponentsInChildren<IAreaEvent>(includeInactive: true);
		foreach (IAreaEvent obj3 in componentsInChildren12)
		{
			areaEventSubscribers.Add(obj3);
		}
		IdleAnimation[] componentsInChildren13 = GetComponentsInChildren<IdleAnimation>(includeInactive: true);
		for (num = 0; num < componentsInChildren13.Length; num++)
		{
			componentsInChildren13[num].OnAwakeLR();
		}
		yield return Wait.For.Updates(1);
		cutsceneEventSubscribers = new ConstArray<ICutsceneEvent>(16u);
		ICutsceneEvent[] componentsInChildren14 = GetComponentsInChildren<ICutsceneEvent>(includeInactive: true);
		foreach (ICutsceneEvent obj4 in componentsInChildren14)
		{
			cutsceneEventSubscribers.Add(obj4);
		}
		for (int num8 = 0; num8 < rigidBodysInitState.Length; num8++)
		{
			RBInitState rBInitState = rigidBodysInitState[num8];
			rBInitState.rb.isKinematic = rBInitState.kinematic;
		}
		yield return Wait.For.Updates(1);
		KubrickAnimator[] componentsInChildren15 = GetComponentsInChildren<KubrickAnimator>(includeInactive: true);
		kubrickAnimators = new ConstArray<KubrickAnimator>(128u);
		int num9 = componentsInChildren15.Length;
		for (int num10 = 0; num10 < num9; num10++)
		{
			KubrickAnimator kubrickAnimator = componentsInChildren15[num10];
			if (!kubrickAnimator.GetComponent<STUB_DoNotUnloadMe>())
			{
				kubrickAnimators.Add(kubrickAnimator);
			}
		}
		yield return Wait.For.Updates(1);
		IAwakeEvent[] componentsInChildren16 = GetComponentsInChildren<IAwakeEvent>(includeInactive: true);
		IAwakeEvent[] array21 = componentsInChildren16;
		for (int i4 = 0; i4 < array21.Length; i4++)
		{
			array21[i4].OnAwakeLR(this);
			yield return Wait.For.Updates(1);
		}
		yield return Wait.For.Updates(1);
		Rasterizable[] componentsInChildren17 = GetComponentsInChildren<Rasterizable>(includeInactive: true);
		for (num = 0; num < componentsInChildren17.Length; num++)
		{
			componentsInChildren17[num].OnAwakeLR();
		}
		yield return Wait.For.Updates(1);
		rasterizables = new ConstArray<ICanBeRasterized>(256u);
		ICanBeRasterized[] componentsInChildren18 = GetComponentsInChildren<ICanBeRasterized>(includeInactive: true);
		for (int num11 = 0; num11 < componentsInChildren18.Length; num11++)
		{
			componentsInChildren18[num11].GenerateRasterizerMesh();
			rasterizables.Add(componentsInChildren18[num11]);
		}
		yield return Wait.For.Updates(1);
		portalRenderers = new ConstArray<PortalRenderer>(128u, GetComponentsInChildren<PortalRenderer>(includeInactive: true));
		for (int num12 = 0; num12 < portalRenderers.Length; num12++)
		{
			portalRenderers[num12].OnAwakeLR();
		}
		yield return Wait.For.Updates(1);
		animPaths = new ConstArray<AnimPath>(8u, GetComponentsInChildren<AnimPath>(includeInactive: true));
		for (int num13 = 0; num13 < animPaths.Length; num13++)
		{
			animPaths[num13].OnAwakeLR(this);
		}
		yield return Wait.For.Updates(1);
		updateEventSubscribers = GetComponentsInChildren<IUpdateEvent>(includeInactive: true);
		lateUpdateEventSubscribers = GetComponentsInChildren<ILateUpdateEvent>(includeInactive: true);
		postPhysicsUpdateEventSubscribers = GetComponentsInChildren<IPostPhysicsUpdateEvent>(includeInactive: true);
		pauseEventSubscribers = GetComponentsInChildren<IPauseEvent>(includeInactive: true);
		pauseUpdateSubscribers = GetComponentsInChildren<IPauseUpdate>(includeInactive: true);
		realtimeUpdateSubscribers = GetComponentsInChildren<IRealtimeUpdate>(includeInactive: true);
		Renderer[] componentsInChildren19 = GetComponentsInChildren<Renderer>(includeInactive: true);
		uint renderingLayerMask = (sceneMask = LR.Inst.GetSceneMask());
		Renderer[] array22 = componentsInChildren19;
		for (num = 0; num < array22.Length; num++)
		{
			array22[num].renderingLayerMask = renderingLayerMask;
		}
		yield return Wait.For.Updates(1);
		hagiss = new ConstArray<HAGIS>(32u, GetComponentsInChildren<HAGIS>(includeInactive: true));
		for (int i4 = 0; i4 < hagiss.Length; i4 = num)
		{
			hagiss[i4].OnAwakeLR(this);
			yield return Wait.For.Updates(1);
			num = i4 + 1;
		}
		yield return Wait.For.Updates(1);
		IPrepareEvent[] componentsInChildren20 = GetComponentsInChildren<IPrepareEvent>(includeInactive: true);
		IPrepareEvent[] array23 = componentsInChildren20;
		foreach (IPrepareEvent prepareEvent in array23)
		{
			yield return prepareEvent.PrepareEvents();
			yield return Wait.For.LRUpdates(1);
		}
		GrabObject[] array24 = grabObjects;
		for (num = 0; num < array24.Length; num++)
		{
			array24[num].OnLateAwakeLR();
		}
		ILateAwakeEvent[] componentsInChildren21 = GetComponentsInChildren<ILateAwakeEvent>(includeInactive: true);
		for (int num14 = 0; num14 < componentsInChildren21.Length; num14++)
		{
			componentsInChildren21[num14].OnLateAwakeLR();
		}
		CollectSavedGrabObjects();
		LR.Inst.NotifyOnAreaEnter_OnAwakeMRBase(this);
		for (int num15 = 0; num15 < hagiss.Length; num15++)
		{
			HAGIS hAGIS = hagiss[num15];
			if ((bool)hAGIS)
			{
				hAGIS.OnLoadLR(this);
			}
		}
	}

	public void Save()
	{
		if (onAwakeLR != null && !onAwakeLR.started && info.Load().canSave)
		{
			SaveDataGame saveDataGame = LR.Inst.saveDataGame;
			saveDataGame.SceneGet(this).owner = this;
			saveDataGame.SceneSave(this);
		}
	}

	public static void TransferObject(MRBase _old, MRBase _new, InteractableObject _object)
	{
		if (TransferObject(_old, _new, _old?.interactableObjects, _new?.interactableObjects, _object) && (_old?.interactableObjectsToSave?.Contains(_object) ?? false))
		{
			_old.interactableObjectsToSave.Remove(_object);
			_new?.interactableObjectsToSave?.Add(_object);
		}
	}

	public static void TransferObject(MRBase _old, MRBase _new, PortalingRigidbody _object)
	{
		TransferObject(_old, _new, _old?.portalingRidgidbodies, _new?.portalingRidgidbodies, _object);
	}

	public static void TransferObject(MRBase _old, MRBase _new, PortalingAnimObject _object)
	{
		if (TransferObject(_old, _new, _old?.portalingAnimObjects, _new?.portalingAnimObjects, _object))
		{
			if ((object)_new == null)
			{
				_object.transform.parent = LR.Inst.transform;
			}
			else
			{
				_object.transform.parent = _new.transform;
			}
		}
	}

	public static void TransferObject(MRBase _old, MRBase _new, KubrickAnimator _object)
	{
		TransferObject(_old, _new, _old?.kubrickAnimators, _new?.kubrickAnimators, _object);
	}

	public static void TransferObject(MRBase _old, MRBase _new, PortalRenderer _object)
	{
		TransferObject(_old, _new, _old?.portalRenderers, _new?.portalRenderers, _object);
	}

	public static void TransferObject(MRBase _old, MRBase _new, ICanBeRasterized _object)
	{
		TransferObject(_old, _new, _old?.rasterizables, _new?.rasterizables, _object);
	}

	public static void TransferObject(MRBase _old, MRBase _new, Portal _object)
	{
		TransferObject(_old, _new, _old?.portals, _new?.portals, _object);
	}

	public static void TransferObject(MRBase _old, MRBase _new, GravityDangler _object)
	{
		TransferObject(_old, _new, _old?.gravityDanglers, _new?.gravityDanglers, _object);
	}

	public static void TransferObject(MRBase _old, MRBase _new, HookPoint _object)
	{
		TransferObject(_old, _new, _old?.hookPoints, _new?.hookPoints, _object);
	}

	public static void TransferObject(MRBase _old, MRBase _new, IAreaEvent _object)
	{
		TransferObject(_old, _new, _old?.areaEventSubscribers, _new?.areaEventSubscribers, _object);
	}

	public static void TransferObject(MRBase _old, MRBase _new, HAGIS _object)
	{
		TransferObject(_old, _new, _old?.hagiss, _new?.hagiss, _object);
	}

	public static void TransferObject(MRBase _old, MRBase _new, ObjectMimic _object)
	{
		TransferObject(_old, _new, _old?.m_objectMimics, _new?.m_objectMimics, _object);
	}

	public static void TransferObject(MRBase _old, MRBase _new, Rasterizer _object)
	{
		TransferObject(_old, _new, _old?.rasterizers, _new?.rasterizers, _object);
	}

	public static void TransferObject(MRBase _old, MRBase _new, LightSource _object)
	{
		TransferObject(_old, _new, _old?.lightSources, _new?.lightSources, _object);
	}

	public static void TransferObject(MRBase _old, MRBase _new, ISceneUnloadEvent sue)
	{
		TransferObject(_old, _new, _old?.sceneUnloadEvents, _new?.sceneUnloadEvents, sue);
	}

	public static void TransferObject(MRBase _old, MRBase _new, LightSensor _object)
	{
		TransferObject(_old, _new, _old?.lightSensors, _new?.lightSensors, _object);
	}

	public static void TransferObject(MRBase _old, MRBase _new, PortalVariations _object)
	{
		TransferObject(_old, _new, _old?.portalVariations, _new?.portalVariations, _object);
	}

	public static void TransferObject(MRBase _old, MRBase _new, InteractiveBeam _object)
	{
		TransferObject(_old, _new, _old?.interactiveBeams, _new?.interactiveBeams, _object);
	}

	private static bool TransferObject<T>(MRBase _old, MRBase _new, ConstArray<T> _oldArr, ConstArray<T> _newArr, T _object)
	{
		if (_oldArr == _newArr)
		{
			return false;
		}
		_oldArr?.Remove(_object);
		_newArr?.Add(_object);
		return true;
	}

	public void OnUpdateLR()
	{
		if (!shouldUpdate)
		{
			return;
		}
		MRBase owner = MainCamera.Inst.GetOwner();
		bool inPlayerScene = this == owner;
		HookPoint.PartitionHooks(hookPoints);
		HookPoint.OnUpdateLR(hookPoints);
		for (int i = 0; i < portalingRidgidbodies.Length; i++)
		{
			PortalingRigidbody portalingRigidbody = portalingRidgidbodies[i];
			if (portalingRigidbody.isActiveAndEnabled)
			{
				portalingRigidbody.OnUpdateLR();
			}
		}
		InteractableObject.OnUpdateLR(interactableObjects);
		InteractiveBeam.OnUpdateAll(interactiveBeams);
		Portal.OnUpdateAll(portals, inPlayerScene, owner);
		Trigger[] array = triggers;
		for (int j = 0; j < array.Length; j++)
		{
			array[j].OnUpdateLR();
		}
		FrustumDetector[] array2 = frustumDetectors;
		for (int j = 0; j < array2.Length; j++)
		{
			array2[j].OnUpdateLR();
		}
		FrustumDetector3D[] array3 = frustumDetectors3D;
		for (int j = 0; j < array3.Length; j++)
		{
			array3[j].OnUpdateLR();
		}
		FrustumObject[] array4 = frustumObjects;
		for (int j = 0; j < array4.Length; j++)
		{
			array4[j].OnUpdateLR();
		}
		Region.OnUpdateAll(regions);
		for (int k = 0; k < rasterizers.Length; k++)
		{
			rasterizers[k].OnUpdateLR();
		}
		RasterizerGroup[] array5 = rasterizerGroups;
		for (int j = 0; j < array5.Length; j++)
		{
			array5[j].OnUpdateLR();
		}
		LightSensor.KickOffAllRaycastCommands(lightSensors, lightSources);
		LightSource.OnUpdateAll(lightSources);
		LightSensor.OnUpdateAll(lightSensors);
		PlacementHelper[] array6 = placementHelpers;
		foreach (PlacementHelper placementHelper in array6)
		{
			if (placementHelper.isActiveAndEnabled)
			{
				placementHelper.OnUpdateLR();
			}
		}
		Telepoint.OnUpdateLR(telepoints);
		ObjectAreaTrigger.OnUpdateAll(objectAreaTriggers);
		GrabObjectAreaTrigger.OnUpdateAll(grabObjectAreaTriggers);
		CutsceneAreaTrigger.OnUpdateAll(cutsceneAreaTriggers);
		IUpdateEvent[] array7 = updateEventSubscribers;
		foreach (IUpdateEvent updateEvent in array7)
		{
			if ((updateEvent as MonoBehaviour).isActiveAndEnabled)
			{
				updateEvent.OnUpdateLR();
			}
		}
		OnEndOfUpdate();
	}

	private void OnEndOfUpdate()
	{
		MRBase owner = MainCamera.Inst.GetOwner();
		bool inPlayerScene = this == owner;
		for (int i = 0; i < interactableObjects.Length; i++)
		{
			if (interactableObjects[i].isActiveAndEnabled)
			{
				interactableObjects[i].OnEndOfUpdate(inPlayerScene);
			}
		}
		for (int j = 0; j < portals.Length; j++)
		{
			portals[j].OnEndOfUpdate();
		}
	}

	public void OnLateUpdateLR()
	{
		if (shouldUpdate)
		{
			for (int i = 0; i < portalingAnimObjects.Length; i++)
			{
				portalingAnimObjects[i].OnLateUpdateLR();
			}
			for (int j = 0; j < portals.Length; j++)
			{
				portals[j].OnLateUpdateLR();
			}
			Region[] array = regions;
			for (int k = 0; k < array.Length; k++)
			{
				array[k].OnLateUpdateLR();
			}
			for (int l = 0; l < lateUpdateEventSubscribers.Length; l++)
			{
				lateUpdateEventSubscribers[l].OnLateUpdateLR();
			}
			for (int m = 0; m < gravityDanglers.Length; m++)
			{
				gravityDanglers[m].OnLateUpdateLR();
			}
		}
	}

	public void OnRealtimeLateUpdateLR()
	{
		if ((bool)nothingToSeeHere)
		{
			nothingToSeeHere.OnRealtimeLateUpdateLR();
		}
		PlayerAreaTrigger.OnUpdateAll(playerAreaTriggers);
		IRealtimeUpdate[] array = realtimeUpdateSubscribers;
		foreach (IRealtimeUpdate realtimeUpdate in array)
		{
			if ((realtimeUpdate as MonoBehaviour).isActiveAndEnabled)
			{
				realtimeUpdate.OnRealtimeUpdateLR();
			}
		}
		Portal.OnUpdateAllPortalLinks(portals);
		if (shouldUpdate)
		{
			PortalRenderer.UpdateRenderingData(portalRenderers);
			MainCamera inst = MainCamera.Inst;
			MRBase owner = inst.GetOwner();
			bool inPlayerScene = (object)this == owner;
			Vector3 headPosition = IC.GetHeadPosition();
			Vector3 position = inst.transform.position;
			for (int j = 0; j < portals.Length; j++)
			{
				portals[j].UpdateRenderingData(owner, inPlayerScene, headPosition, position);
			}
			PortalRenderer.UpdateRenderingDataComplete(portalRenderers);
			PortalVariations.SaveRenderingState(portalVariations);
			sceneRenderSettings?.UpdateRenderingData();
		}
	}

	public void OnPauseLR(bool paused)
	{
		for (int i = 0; i < pauseEventSubscribers.Length; i++)
		{
			pauseEventSubscribers[i].OnPauseLR(paused);
		}
	}

	public void OnPauseUpdateLR()
	{
		for (int i = 0; i < pauseUpdateSubscribers.Length; i++)
		{
			IPauseUpdate pauseUpdate = pauseUpdateSubscribers[i];
			if ((bool)(pauseUpdate as MonoBehaviour))
			{
				pauseUpdate.OnPauseUpdateLR();
			}
		}
	}

	public void StopAllAnimations()
	{
		Animation[] array = animations;
		foreach (Animation animation in array)
		{
			if (animation != null)
			{
				animation.Stop();
			}
		}
	}

	public void OnCutsceneLR(bool cutscene)
	{
		for (int i = 0; i < cutsceneEventSubscribers.Length; i++)
		{
			ICutsceneEvent cutsceneEvent = cutsceneEventSubscribers[i];
			if (cutscene)
			{
				cutsceneEvent.OnCutsceneBegin();
			}
			else
			{
				cutsceneEvent.OnCutsceneEnd();
			}
		}
	}

	public void OnPrePhysicsUpdateLR()
	{
		if (shouldUpdate)
		{
			for (int i = 0; i < portalingRidgidbodies.Length; i++)
			{
				portalingRidgidbodies[i].OnPrePhysicsUpdateLR();
			}
		}
	}

	public void OnPostPhysicsUpdateLR()
	{
		if (!shouldUpdate)
		{
			return;
		}
		for (int i = 0; i < eGrills.Length; i++)
		{
			eGrills[i].OnPostPhysicsUpdateLR(this);
		}
		for (int j = 0; j < portalingRidgidbodies.Length; j++)
		{
			PortalingRigidbody portalingRigidbody = portalingRidgidbodies[j];
			portalingRigidbody.wentThroughPortalLastFrame = false;
			if (portalingRigidbody.isActiveAndEnabled)
			{
				Portal.PortalableEvaluateCrossingPortal(portalingRidgidbodies[j]);
			}
		}
		for (int k = 0; k < portalingRidgidbodies.Length; k++)
		{
			PortalingRigidbody portalingRigidbody2 = portalingRidgidbodies[k];
			if (portalingRigidbody2.isActiveAndEnabled)
			{
				portalingRigidbody2.OnPostPhysicsUpdateLR();
			}
		}
		InteractableObject.PostPhysicsUpdateLR(interactableObjects);
		for (int l = 0; l < m_objectMimics.Length; l++)
		{
			m_objectMimics[l].UpdateMimic();
			m_objectMimics[l].CheckControl();
		}
		IPostPhysicsUpdateEvent[] array = postPhysicsUpdateEventSubscribers;
		foreach (IPostPhysicsUpdateEvent postPhysicsUpdateEvent in array)
		{
			if ((postPhysicsUpdateEvent as MonoBehaviour).isActiveAndEnabled)
			{
				postPhysicsUpdateEvent.OnPostPhysicsUpdateLR();
			}
		}
	}

	public void ReevaluateHelpers()
	{
		PlacementHelper[] array = placementHelpers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].ReevaluateHelper();
		}
	}

	public SaveDataGame.Chapter GetChapter()
	{
		return info.Load().GetPuzzleChapter();
	}

	public Wait OnSceneUnload()
	{
		return onUnloadRoutine.Call();
	}

	private IEnumerator<Routine.Yield> OnUnloadRoutine()
	{
		Save();
		yield return Wait.For.Updates(1);
		ConstArray<GrabObject> grabObjects = PlayerInventory.Inst.inventoryState.grabObjects;
		for (int k = 0; k < grabObjects.Length; k++)
		{
			GrabObject grabObject = grabObjects[k];
			if (grabObject.owner == this)
			{
				grabObject.pr.SetOwner(null);
			}
		}
		LR.Inst.ReturnSceneMask(sceneMask);
		LR.Inst.saveDataGame.SceneUnload(this);
		yield return Wait.For.Updates(1);
		for (int l = 0; l < sceneUnloadEvents._dataNum; l++)
		{
			sceneUnloadEvents._data[l].OnSceneUnload();
		}
		yield return Wait.For.Updates(1);
		isAwake = false;
		int counter2 = 0;
		int j = gameObjectsToActivate.Length;
		while (j-- > 0)
		{
			GameObject gameObject = gameObjectsToActivate[j];
			if ((bool)gameObject)
			{
				gameObject.SetActive(value: false);
			}
			if (counter2++ > 100)
			{
				counter2 = 0;
				yield return Wait.For.Updates(1);
			}
		}
		counter2 = 0;
		j = gameObjectsToActivate.Length;
		while (j-- > 0)
		{
			GameObject gameObject2 = gameObjectsToActivate[j];
			if ((bool)gameObject2)
			{
				UnityEngine.Object.Destroy(gameObject2);
			}
			if (counter2++ > 100)
			{
				counter2 = 0;
				yield return Wait.For.Updates(1);
			}
		}
	}

	public float GetNearestPortalDistForPortalIdle()
	{
		if (portals.Length != 0)
		{
			Portal portal = null;
			float num = float.MaxValue;
			for (int i = 0; i < portals.Length; i++)
			{
				if ((portals[i].type == PortalType.WithinWorlds || portals[i].type == PortalType.BetweenWorlds) && portals[i].GetPortalState() == PortalState.OPEN)
				{
					float sqrMagnitude = (portals[i].transform.position - MainCamera.Inst.transform.position).sqrMagnitude;
					if (sqrMagnitude < num)
					{
						num = sqrMagnitude;
						portal = portals[i];
					}
				}
			}
			if (portal != null)
			{
				return (portal.transform.position - MainCamera.Inst.transform.position).magnitude;
			}
		}
		return 10f;
	}

	public Vector3 SetScenePosition(MRBase rootBase)
	{
		return Vector3.zero;
	}

	public override void OnValidate()
	{
	}

	protected void OnDrawGizmos()
	{
	}

	private IEnumerator<Routine.Yield> SpreadAmbientSoundStart(int framesBetween, int numPerFrame, FMODAmbientSource[] sources)
	{
		yield return Wait.For.LRUpdates(1);
		int instCount = 0;
		for (int i = 0; i < sources.Length; i++)
		{
			sources[i].Play();
			instCount++;
			if (instCount >= numPerFrame)
			{
				instCount = 0;
				yield return Wait.For.LRUpdates(framesBetween);
			}
		}
	}

	public void NotifyOnAreaEnter()
	{
		debugAreaEnterNotificationCount++;
		if (!spreadAmbientSoundStart.started)
		{
			spreadAmbientSoundStart.Start(1, 3, allAmbienceSources);
		}
		for (int i = 0; i < areaEventSubscribers.Length; i++)
		{
			areaEventSubscribers[i].OnAreaEnter();
		}
		LR.Inst.LoadAdjacentScenes();
		UIPauseMenu.Inst.currentMenuType = info.Load().sceneMenuType;
	}

	public void NotifyOnAreaExit()
	{
		debugAreaEnterNotificationCount--;
		if (spreadAmbientSoundStart.started)
		{
			spreadAmbientSoundStart.Stop();
		}
		FMODAmbientSource[] array = allAmbienceSources;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Stop();
		}
		for (int j = 0; j < areaEventSubscribers.Length; j++)
		{
			areaEventSubscribers[j].OnAreaExit();
		}
	}

	public static void CalculateIfAllowedToUpdate(MRBase currentOwner, ConstArray<MRBase> mrsLoaded)
	{
		for (int i = 0; i < mrsLoaded.Length; i++)
		{
			mrsLoaded[i].shouldUpdate = false;
		}
		currentOwner.shouldUpdate = true;
		for (int j = 0; j < currentOwner.portals.Length; j++)
		{
			Portal portal = currentOwner.portals[j];
			bool flag = portal.GetPortalState() == PortalState.OPEN || portal.openAmount > 0f;
			bool num;
			if (portal.type != PortalType.FakeMirror)
			{
				num = flag;
			}
			else
			{
				if (!flag)
				{
					goto IL_0075;
				}
				num = portal.PortalCamera.enabled;
			}
			if (!num)
			{
				goto IL_0075;
			}
			goto IL_007e;
			IL_0075:
			if (portal.type != PortalType.Eyeglass)
			{
				continue;
			}
			goto IL_007e;
			IL_007e:
			Portal link = portal.Link;
			if ((bool)link && (bool)link.owner)
			{
				link.owner.shouldUpdate = true;
			}
		}
	}
}
public class NXPreferences
{
}
public class PlatformManager : MonoBehaviour
{
	private ulong appID;

	private string oculusUserID;

	private string userID;

	private AchievementController achievementController;

	private bool isEntitled;

	private void Awake()
	{
		achievementController = new AchievementController();
		try
		{
			Core.AsyncInitialize().OnComplete(InitalizeCallback);
			Entitlements.IsUserEntitledToApplication().OnComplete(CheckEntitlementCallback);
		}
		catch (UnityException exception)
		{
			UnityEngine.Debug.LogError("Platform failed to initialize due to exception.");
			UnityEngine.Debug.LogException(exception);
			UnityEngine.Application.Quit();
		}
	}

	private void InitalizeCallback(Message msg)
	{
		UnityEngine.Debug.Log($"Core Initialize complete: {Core.IsInitialized()}");
	}

	private void CheckEntitlementCallback(Message msg)
	{
		if (msg.IsError)
		{
			UnityEngine.Debug.LogError("Entitlement Error: " + msg.GetError().Message);
			UnityEngine.Application.Quit();
		}
		else
		{
			isEntitled = true;
			UnityEngine.Debug.Log("User is Entitled");
			Users.GetLoggedInUser().OnComplete(GetUserCallback);
		}
	}

	private void GetUserCallback(Message<User> msg)
	{
		if (msg.IsError)
		{
			UnityEngine.Debug.LogError("Get User Error: " + msg.GetError().Message);
			return;
		}
		UnityEngine.Debug.Log("Successfull found user");
		appID = msg.Data.ID;
		oculusUserID = msg.Data.OculusID;
		userID = $"{msg.Data.ID}";
		achievementController.GetAvailableAchievements();
	}

	public void UnlockAchievement(NXAchievements achievement)
	{
		if (!isEntitled)
		{
			UnityEngine.Debug.Log("Not Entitled, can't unlock achievements");
		}
		else
		{
			achievementController.UnlockAchievement(achievement);
		}
	}

	public void CheckAchievementProgress()
	{
		if (isEntitled)
		{
			achievementController.GetAchievementProgressOculus();
		}
	}

	public bool[] GetAchievementProgress()
	{
		return achievementController.GetAchievementProgressNexus();
	}

	public void ResetAchievementProgress()
	{
		if (!isEntitled)
		{
			UnityEngine.Debug.Log("Not entitled");
			return;
		}
		string text = "";
		text = "OC|" + PlatformSettings.MobileAppID + "|d166d3c6ce37a76f492816d5645d6f55";
		StartCoroutine(achievementController.ResetAllAchievementProgress(text, userID));
	}
}
[Flags]
public enum QueueProperty
{
	Queue = 1,
	Interrupt = 2,
	Instant = 4,
	OnlyPlayIfQueueEmpty = 8,
	OnlyPlayIfOutOfSequence = 0x10,
	Reverse = 0x20,
	Loop = 0x40
}
public struct ANClip
{
	public AnimationClip data;

	public QueueProperty properties;

	public int layer;

	public Action onComplete;

	public AnimationState state;

	public float normalisedStartTime;
}
public class RootBase : MonoBehaviour
{
	[HideInInspector]
	public JK3D jk3d;

	[HideInInspector]
	public JK3DAtlasMaterial[] atlasMaterials;

	public virtual void Setup()
	{
		jk3d = GetComponentInChildren<JK3D>();
		if (!jk3d)
		{
			return;
		}
		atlasMaterials = jk3d.GetAllAtlasMaterials();
		for (int i = 0; i < atlasMaterials.Length; i++)
		{
			JK3DAtlasMaterial jK3DAtlasMaterial = atlasMaterials[i];
			if (jK3DAtlasMaterial.isLightmapped)
			{
				if (jK3DAtlasMaterial.staticMat == null)
				{
					UnityEngine.Debug.LogError("Atlas material " + jK3DAtlasMaterial.atlasName + " is BROKEN on " + ((base.transform.parent != null) ? (base.transform.parent.name + ", ") : "") + base.gameObject.name, this);
				}
				if (jK3DAtlasMaterial.dynamicMat == null)
				{
					UnityEngine.Debug.LogError("Atlas material " + jK3DAtlasMaterial.atlasName + " is BROKEN on " + ((base.transform.parent != null) ? (base.transform.parent.name + ", ") : "") + base.gameObject.name, this);
				}
			}
		}
	}

	protected virtual void OnPrebuildSelf()
	{
	}

	public virtual void OnValidate()
	{
	}

	public GameObject GetGameObjectInRoot(string name)
	{
		Transform obj = base.transform.Find(name);
		if (obj == null)
		{
			UnityEngine.Debug.LogWarning("Failed to find: '" + name + "' GameObject in scene!");
		}
		return obj.gameObject;
	}

	public static RootBase GetRoot(UnityEngine.Component component)
	{
		return GetRoot(component.gameObject);
	}

	public static RootBase GetRoot(GameObject go)
	{
		return GetRoot(go);
	}

	public static RootBase GetRoot(Scene scene)
	{
		GameObject[] rootGameObjects = scene.GetRootGameObjects();
		for (int i = 0; i < rootGameObjects.Length; i++)
		{
			RootBase component = rootGameObjects[i].GetComponent<RootBase>();
			if ((bool)component)
			{
				return component;
			}
		}
		return null;
	}
}
internal struct UIPortalable
{
	public Transform transform;

	public Portal portalFromHeadToUI;

	public Vector3 velocity;

	private MRBase owner;

	private PortalRenderer portalRenderer;

	public void OnAwakeLR(PortalRenderer portalRenderer, Transform transform)
	{
		this.transform = transform;
		this.portalRenderer = portalRenderer;
	}

	public static bool IsPortalValidToTeleportThrough(Portal portal)
	{
		if (Portal.IsPortalValidToTeleportThrough(portal))
		{
			return !portal.IsMirror;
		}
		return false;
	}

	private Vector3 SpringCriticallyDampened(Vector3 target, Vector3 pos, ref Vector3 vel, float time_90, float dt)
	{
		float num = dt * 3.75f / time_90;
		if (num >= 1f)
		{
			pos = target;
			vel = Vector3.zero;
		}
		else
		{
			Vector3 vector = target - pos - 2f * vel;
			pos += vel * num;
			vel += vector * num;
		}
		return pos;
	}

	public Vector3 TransformTargetPos(Vector3 targetPosWS, Portal portalHeadEntered)
	{
		if ((bool)portalHeadEntered && (bool)portalHeadEntered.Link)
		{
			targetPosWS = portalHeadEntered.Link.CalculatePortalObjectTransform(targetPosWS, QuaternionX.identity, Vector3X.zero).position;
		}
		if ((bool)portalFromHeadToUI)
		{
			targetPosWS = portalFromHeadToUI.CalculatePortalObjectTransform(targetPosWS, QuaternionX.identity, Vector3X.zero).position;
		}
		return targetPosWS;
	}

	public void OnEvaluateMovement(MainCamera head, Portal portalHeadEntered, bool inheritHeadVelocity, Vector3 targetPosWS, float dt, float springTimeFor90PercentMovement)
	{
		if ((bool)portalFromHeadToUI && portalFromHeadToUI.Link == null)
		{
			portalFromHeadToUI = null;
		}
		Vector3 position = head.transform.position;
		Vector3 direction = head.GetLastState().velocity;
		if ((bool)portalHeadEntered)
		{
			direction = portalHeadEntered.Link.CalculatePortalObjectTransform(Vector3.zero, Quaternion.identity, direction).direction;
		}
		if ((bool)portalFromHeadToUI)
		{
			direction = portalFromHeadToUI.CalculatePortalObjectTransform(Vector3.zero, Quaternion.identity, direction).direction;
		}
		if (inheritHeadVelocity)
		{
			velocity += direction * dt;
		}
		transform.position = SpringCriticallyDampened(targetPosWS, transform.position, ref velocity, springTimeFor90PercentMovement, dt);
		Quaternion rotation = CC.Inst.transform.rotation;
		if ((bool)portalHeadEntered)
		{
			Portal.PortalTransform portalTransform = portalHeadEntered.Link.CalculatePortalObjectTransform(position, rotation, Vector3.zero);
			position = portalTransform.position;
			rotation = portalTransform.rotation;
		}
		if ((bool)portalFromHeadToUI)
		{
			Portal.PortalTransform portalTransform2 = portalFromHeadToUI.CalculatePortalObjectTransform(position, rotation, Vector3.zero);
			position = portalTransform2.position;
			rotation = portalTransform2.rotation;
		}
		Quaternion rotation2 = Quaternion.LookRotation((transform.position - position).normalized, rotation * Vector3.up);
		transform.rotation = rotation2;
		Vector3 position2 = transform.position;
		if ((bool)portalFromHeadToUI && (bool)portalFromHeadToUI.Link)
		{
			position2 = portalFromHeadToUI.Link.CalculatePortalObjectTransform(position2, Quaternion.identity, Vector3.zero).position;
		}
		if ((bool)portalHeadEntered)
		{
			position2 = portalHeadEntered.CalculatePortalObjectTransform(position2, Quaternion.identity, Vector3.zero).position;
		}
		Portal portalOut = null;
		Portal.RaycastPortal(head.transform.position, position2, out portalOut);
		portalOut = ((portalOut != null && portalOut.Link != null) ? portalOut : null);
		portalOut = ((!portalOut) ? null : (IsPortalValidToTeleportThrough(portalOut) ? portalOut : null));
		if (!(portalOut != portalFromHeadToUI))
		{
			return;
		}
		Portal portal = (portalOut ? portalOut : portalFromHeadToUI.Link);
		if (portalHeadEntered == null)
		{
			Portal.PortalTransform portalTransform3 = portal.CalculatePortalObjectTransform(transform.position, transform.rotation, velocity);
			transform.position = portalTransform3.position;
			transform.rotation = portalTransform3.rotation;
			velocity = portalTransform3.direction;
			if (owner != portal.Link.owner)
			{
				SetOwner(portal.Link.owner);
			}
		}
		portalFromHeadToUI = portalOut;
	}

	public MRBase GetOwner()
	{
		return owner;
	}

	public void SetOwner(MRBase newOwner)
	{
		if (owner != newOwner)
		{
			MRBase old = owner;
			owner = newOwner;
			MRBase.TransferObject(old, newOwner, portalRenderer);
		}
	}

	public void ForceValidOwner(MainCamera head)
	{
		if (!owner)
		{
			MRBase mRBase = head.GetOwner();
			if (owner != mRBase)
			{
				SetOwner(mRBase);
			}
		}
	}
}
public class STC : UIContainer, IPrebuildEvent
{
	public const float BOUNDS_EXTENSION = 0.1f;

	private static STC _instance;

	private Transform containerAll;

	private UITextbox textContent;

	public float minDistance = 1.25f;

	public float maxDistance = 2f;

	public float outOfBoundsFadeSpeedIn = 4f;

	public float outOfBoundsFadeSpeedOut = 4f;

	public float screenspaceHeight = -0.6f;

	public float deadZoneYInDegrees = 10f;

	public float timeFor90PercentMovement;

	public float timeFor90PercentMovementIcon;

	private float alphaText = 1f;

	private float alphaIcon;

	private float outOfBoundsFadeSpeed;

	private bool outOfBounds;

	[SerializeField]
	private float subtitleEyeOffset;

	public AnimationCurve curveOutOfBoundsPulse;

	private const float animDur = 0.8f;

	private const float zDistance = 1f;

	private const float textDurationMin = 0.15f;

	private const float textDurationMax = 5.05f;

	private const float textLineMax = 110f;

	private const float animTimeInOut = 0.4f;

	private const float velocityDamper = 0.4f;

	private const float outOfBoundsTimeMax = 0.3f;

	[SerializeField]
	private SubtitleOutOfBoundsIcon sOOBIcon;

	private Quaternion viewRotLocalCurrent = Quaternion.identity;

	private Vector3 textContentHalfExtentsCurrent;

	private Vector3 velocity;

	private float outOfBoundsTime;

	private float advanceCountdown;

	private AnimValue<float> visibility = new AnimValue<float>(0f);

	private AnimValue<float> backgroundVisibility = new AnimValue<float>();

	private bool lastShouldShow;

	[SerializeField]
	private SubtitleAsset subtitleAsset;

	private UIPortalable subs;

	private UIPortalable icon;

	private MRBase owner;

	private PortalRenderer portalRenderer;

	public float tolerance = 0.75f;

	public float minWidth = 0.5f;

	private ConstQueue<SubtitleAsset.VOClipSubtitle.Sentence> subtitleQueue = new ConstQueue<SubtitleAsset.VOClipSubtitle.Sentence>(32);

	public static STC Inst => _instance;

	void IPrebuildEvent.OnPrebuildRoot(bool isPrefab)
	{
		sOOBIcon = GetComponentInChildren<SubtitleOutOfBoundsIcon>(includeInactive: true);
		sOOBIcon.GetComponent<SpriteRenderer>().enabled = false;
	}

	public override Wait OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
		containerAll = base.transform.GetChild(0);
		textContent = GetElement<UITextbox>("Content");
		HideAll();
		portalRenderer = textContent.GetComponent<PortalRenderer>();
		portalRenderer.OnAwakeLR();
		subs.OnAwakeLR(portalRenderer, textContent.transform);
		sOOBIcon.OnAwakeLR();
		sOOBIcon.sprite.color = new Color(1f, 1f, 1f, alphaIcon);
		sOOBIcon.sprite.enabled = true;
		icon.OnAwakeLR(sOOBIcon.portalRenderer, sOOBIcon.transform);
		textContent.transform.localPosition = CC.Inst.transform.position + CC.Inst.transform.forward;
		return Wait.PreMet;
	}

	public void Show(string eventPath, bool HACK_shouldUpdateLR = true)
	{
		SubtitleAsset.VOClipSubtitle vOClip = subtitleAsset.GetVOClip(eventPath);
		if (vOClip != null)
		{
			SubtitleAsset.VOClipSubtitle.LocalisedData localisedData = vOClip.GetLocalisedData(Localisation.Inst.CurrentLanguage);
			for (int i = 0; i < localisedData.sentences.Length; i++)
			{
				subtitleQueue.Enqueue(localisedData.sentences[i]);
			}
			AdvanceQueue(0.8f);
			if (HACK_shouldUpdateLR && LR.Inst.saveDataSettings.subtitlesEnabled)
			{
				EvaluateMovement(null, MainCamera.Inst);
			}
		}
	}

	private float GetCustomLength(float[] customLengths, int sentenceCount)
	{
		if (sentenceCount >= customLengths.Length)
		{
			return -1f;
		}
		float num = customLengths[sentenceCount];
		if (num < 0.1f)
		{
			return -1f;
		}
		return num;
	}

	public override void ShowAll()
	{
		base.ShowAll();
	}

	public override bool HideAll()
	{
		return base.HideAll();
	}

	public void EvaluateMovement(Portal portalHeadEntered, MainCamera head, CC.MovementType movementType = CC.MovementType.None)
	{
		subs.ForceValidOwner(head);
		icon.ForceValidOwner(head);
		float deltaTime = IC.DeltaTime;
		float num = minDistance;
		Vector3 position = head.transform.position;
		Vector3 vector = new Vector3(0f, screenspaceHeight, 1f);
		Vector4 v = MainCamera.Inst.cameraComp.projectionMatrix.inverse * new Vector4(vector.x, vector.y, vector.z, 1f);
		Vector3 vector2 = v.xyz() / v.w;
		vector2.z = 0f - vector2.z;
		Vector3 normalized = (CC.Inst.transform.rotation.InverseTransformRotation(head.transform.rotation) * Vector3.forward).RepY(0f).normalized;
		float num2 = Vector3.SignedAngle((viewRotLocalCurrent * Vector3.forward).RepY(0f).normalized, normalized, Vector3.up);
		if (num2 < 0f - deadZoneYInDegrees)
		{
			viewRotLocalCurrent *= Quaternion.Euler(0f, num2 + deadZoneYInDegrees, 0f);
		}
		else if (num2 > deadZoneYInDegrees)
		{
			viewRotLocalCurrent *= Quaternion.Euler(0f, num2 - deadZoneYInDegrees, 0f);
		}
		_ = (viewRotLocalCurrent * Vector3.forward).RepY(0f).normalized;
		Vector3 eulerAngles = viewRotLocalCurrent.eulerAngles;
		Quaternion quaternion = Quaternion.Euler(new Vector3(0f, eulerAngles.y, eulerAngles.z));
		Quaternion quaternion2 = CC.Inst.transform.rotation * quaternion;
		Vector3 vector3 = Vector3.Normalize((Matrix4x4.TRS(position, quaternion2, Vector3.one) * new Vector4(vector2.x, vector2.y, vector2.z, 1f)).xyz() - position);
		Vector3 vector4 = position;
		Vector3 vector5 = vector3;
		float rayDistance = maxDistance;
		Vector3 rhs = quaternion2 * Vector3.right;
		Vector3 normalized2 = Vector3.Cross(vector5, rhs).normalized;
		Quaternion rayRotWS = Quaternion.LookRotation(vector5, normalized2);
		Vector2 rayHalfExtents = new Vector2(textContentHalfExtentsCurrent.x, textContentHalfExtentsCurrent.y);
		bool castAgainstColliders = (bool)visibility.animating || base.IsShown;
		UICastHit uICastHit = UICast.Cast(vector4, rayRotWS, rayHalfExtents, rayDistance, castAgainstColliders, allowPortalTraversal: true);
		outOfBounds = uICastHit.validRayDistance < num;
		Vector3 vector6 = vector4;
		Vector3 vector7 = vector5;
		float num3 = minDistance;
		int layerMask = uICastHit.maskColliders | 0x400;
		if (Physics.Raycast(vector6, vector7, out var hitInfo, num3, layerMask, QueryTriggerInteraction.Ignore))
		{
			if (hitInfo.collider.gameObject.layer == 10)
			{
				Portal component = hitInfo.collider.gameObject.GetComponent<Portal>();
				if ((bool)component.Link && UIPortalable.IsPortalValidToTeleportThrough(component))
				{
					Vector3 localPosition = component.transform.InverseTransformPoint(hitInfo.point);
					if (component.IsLocalPointInside2DPortalShape(localPosition))
					{
						float distance = hitInfo.distance;
						Portal.PortalTransform portalTransform = component.CalculatePortalObjectTransform(hitInfo.point, QuaternionX.identity, Vector3X.zero);
						if (Physics.Raycast(portalTransform.position, portalTransform.direction, out hitInfo, num3, uICastHit.maskColliders, QueryTriggerInteraction.Ignore))
						{
							num3 = distance + hitInfo.distance;
						}
					}
				}
			}
			else
			{
				num3 = hitInfo.distance;
			}
		}
		float num4 = curveOutOfBoundsPulse.Evaluate(IC.Time % curveOutOfBoundsPulse.GetAnimLength());
		num3 *= 0.8f;
		Vector3 targetPosWS = icon.TransformTargetPos(vector6 + vector7 * num3, portalHeadEntered);
		icon.OnEvaluateMovement(head, portalHeadEntered, inheritHeadVelocity: true, targetPosWS, deltaTime, timeFor90PercentMovementIcon);
		icon.transform.localScale = sOOBIcon.localScale * num4 * num3;
		Vector3 vector8 = subs.TransformTargetPos(vector4 + vector5 * uICastHit.validRayDistance, portalHeadEntered);
		if (outOfBounds)
		{
			vector8 = textContent.transform.position;
			outOfBoundsTime = 0.3f;
			outOfBoundsFadeSpeed = outOfBoundsFadeSpeedOut;
		}
		else
		{
			outOfBoundsFadeSpeed = outOfBoundsFadeSpeedIn;
			if (alphaText == 0f)
			{
				textContent.transform.position = vector8;
			}
			if (outOfBoundsTime > 0f)
			{
				outOfBoundsTime -= Time.deltaTime;
				outOfBounds = true;
			}
		}
		subs.OnEvaluateMovement(head, portalHeadEntered, !uICastHit.isCollidingWithWorld, vector8, deltaTime, timeFor90PercentMovement);
	}

	public void UpdateAlpha(float dt, bool paused)
	{
		bool flag = LR.Inst.saveDataSettings.subtitlesEnabled;
		if (flag && advanceCountdown <= 0f)
		{
			flag = false;
		}
		if (!visibility.animating)
		{
			if (base.IsShown && visibility.Value == 0f)
			{
				HideAll();
			}
			else if (!base.IsShown && flag)
			{
				ShowAll();
			}
		}
		if (lastShouldShow != flag)
		{
			if (flag)
			{
				visibility.AnimateTo(1f, (1f - visibility.Value / 1f) * 0.8f);
			}
			else
			{
				visibility.AnimateTo(0f, visibility.Value / 1f * 0.8f);
			}
		}
		lastShouldShow = flag;
		AnimValue<float>.Update(visibility, dt);
		bool flag2 = (NexusFullScreenPass.Inst.fadeAlpha == 0f || NexusFullScreenPass.Inst.isFadeCutscene) && !paused;
		float num = outOfBoundsFadeSpeed;
		float num2 = 3f;
		if (!flag2)
		{
			num = 10f;
			num2 = 10f;
		}
		alphaText = Mathf.MoveTowards(alphaText, (!flag2 || outOfBounds) ? 0f : 1f, dt * num);
		alphaIcon = Mathf.MoveTowards(alphaIcon, (!flag2 || !outOfBounds) ? 0f : 1f, dt * num2);
		sOOBIcon.sprite.color = sOOBIcon.sprite.color.RepA(visibility.Value * Mathf.SmoothStep(0f, 1f, alphaIcon));
		textContent.color = textContent.color.RepA(visibility.Value * Mathf.SmoothStep(0f, 1f, alphaText));
	}

	public void OnUpdateLR()
	{
		float deltaTime = IC.DeltaTime;
		UpdateAlpha(deltaTime, paused: false);
		if (advanceCountdown > 0f && (advanceCountdown -= deltaTime) <= 0f)
		{
			if (subtitleQueue.Length > 0)
			{
				AdvanceQueue();
			}
			else
			{
				textContent.Clear();
			}
		}
	}

	public void ClearQueueAndStop()
	{
		subtitleQueue.Clear();
		advanceCountdown = 0f;
		textContent.Clear();
	}

	public void OnPauseUpdateLR()
	{
		UpdateAlpha(IC.RealDeltaTime, paused: true);
	}

	public void ClearSubtitleQueue()
	{
		subtitleQueue.ClearToDefault();
		advanceCountdown = 0f;
		alphaText = 0f;
		alphaIcon = 0f;
	}

	private void AdvanceQueue(float extraCountdown = 0f)
	{
		SubtitleAsset.VOClipSubtitle.Sentence sentence = subtitleQueue.Dequeue(clearToDefault: true);
		textContent.Clear();
		textContent.Append(sentence.text, 0, sentence.text.Length);
		textContentHalfExtentsCurrent = textContent.Present(returnSize: true) * 0.5f;
		textContentHalfExtentsCurrent *= tolerance;
		textContentHalfExtentsCurrent.x = Mathf.Max(textContentHalfExtentsCurrent.x, minWidth);
		advanceCountdown = sentence.length + extraCountdown;
	}
}
public class UIC : Singleton<UIC>
{
	public struct StackAnim
	{
		public enum Type
		{
			Push,
			Pop,
			PopTo,
			Clear
		}

		public Type type;

		public UIContainer popToContainer;

		public UIContainer newContainer;

		public bool suppressShowAll;
	}

	public static readonly float kSafeUIDistance = 0.5322515f;

	private Stack<UIContainer> stack = new Stack<UIContainer>(16);

	private Dictionary<Type, UIContainer> containers = new Dictionary<Type, UIContainer>();

	private ConstArray<StackAnim> queuedPushPops = new ConstArray<StackAnim>(4u);

	public void Register<T>(UIContainer container)
	{
		containers.Add(typeof(T), container);
	}

	public T Push<T>() where T : UIContainer
	{
		if (stack.Count > 16)
		{
			UnityEngine.Debug.LogError("UIC Stack has overflowed, something probably went wrong!", this);
		}
		T val = (T)containers[typeof(T)];
		queuedPushPops.Add(new StackAnim
		{
			type = StackAnim.Type.Push,
			newContainer = val
		});
		UpdateStack();
		return val;
	}

	public void Pop()
	{
		if (stack.Count <= 0)
		{
			UnityEngine.Debug.LogError("UIC Stack has underflowed, something probably went wrong!", this);
		}
		queuedPushPops.Add(new StackAnim
		{
			type = StackAnim.Type.Pop
		});
		UpdateStack();
	}

	public void PopTo<T>(bool supressShowAll = false) where T : UIContainer
	{
		PopTo(typeof(T), supressShowAll);
	}

	public void PopTo(Type type, bool suppressShowAll = false)
	{
		UIContainer popToContainer = Get(type);
		queuedPushPops.Add(new StackAnim
		{
			type = StackAnim.Type.PopTo,
			popToContainer = popToContainer,
			suppressShowAll = suppressShowAll
		});
		UpdateStack();
	}

	public void Clear()
	{
		queuedPushPops.Add(new StackAnim
		{
			type = StackAnim.Type.Clear
		});
	}

	public void ClearImmediate()
	{
		queuedPushPops.Clear();
		if (stack.Count > 0)
		{
			stack.Peek().HideAll();
			for (int num = stack.Count - 1; num >= 0; num--)
			{
				stack.Pop();
			}
		}
	}

	public bool IsShown<T>()
	{
		if (stack.Count == 0)
		{
			return false;
		}
		if (!(stack.Peek().GetType() == typeof(T)))
		{
			if (queuedPushPops.Length != 0 && (bool)queuedPushPops[0].newContainer)
			{
				return queuedPushPops[0].newContainer.GetType() == typeof(T);
			}
			return false;
		}
		return true;
	}

	public bool IsShown()
	{
		return stack.Count > 0;
	}

	public T Get<T>() where T : UIContainer
	{
		return containers[typeof(T)] as T;
	}

	public bool IsInStack<T>() where T : UIContainer
	{
		if (!stack.Contains(Get<T>()))
		{
			return IsShown<T>();
		}
		return true;
	}

	public bool IsStackAnimating()
	{
		return queuedPushPops.Length != 0;
	}

	public UIContainer Get(Type type)
	{
		return containers[type];
	}

	private void UpdateStack()
	{
		while (queuedPushPops.Length != 0)
		{
			StackAnim stackAnim = queuedPushPops[0];
			switch (stackAnim.type)
			{
			case StackAnim.Type.Push:
			{
				if (stack.Count > 0)
				{
					stack.Peek().HideAll();
				}
				UIContainer newContainer = stackAnim.newContainer;
				stackAnim.newContainer = null;
				newContainer.ShowAll();
				stack.Push(newContainer);
				break;
			}
			case StackAnim.Type.Pop:
				stack.Pop().HideAll();
				if (stack.Count > 0)
				{
					stack.Peek().ShowAll();
				}
				break;
			case StackAnim.Type.PopTo:
			{
				bool flag = true;
				while (stack.Count > 0 && !(stack.Peek() == stackAnim.popToContainer))
				{
					UIContainer uIContainer = stack.Pop();
					if (flag)
					{
						uIContainer.HideAll();
					}
					flag = false;
				}
				if (!flag && !stackAnim.suppressShowAll && stack.Count > 0)
				{
					stack.Peek().ShowAll();
				}
				break;
			}
			case StackAnim.Type.Clear:
				if (stack.Count > 0)
				{
					stack.Peek().HideAll();
				}
				stack.Clear();
				break;
			}
			queuedPushPops.RemoveAtIndex(0u);
		}
	}

	public bool OnBackButton()
	{
		if (stack.Count <= 0)
		{
			return false;
		}
		UIContainer uIContainer = stack.Peek();
		if ((bool)uIContainer)
		{
			return uIContainer.OnBackButtonPressed();
		}
		return false;
	}

	public bool OnActionButton()
	{
		if (stack.Count <= 0)
		{
			return false;
		}
		UIContainer uIContainer = stack.Peek();
		if ((bool)uIContainer)
		{
			uIContainer.OnActionButtonPressed();
			return uIContainer.ConsumesActionButton();
		}
		return false;
	}

	public bool ConsumesActionButton()
	{
		if (stack.Count <= 0)
		{
			return false;
		}
		UIContainer uIContainer = stack.Peek();
		if ((bool)uIContainer)
		{
			return uIContainer.ConsumesActionButton();
		}
		return false;
	}
}
public class VOC : MonoBehaviour
{
	public enum VOQueueProperty
	{
		Queue = 1,
		Interrupt = 2,
		OnlyPlayIfQueueEmpty = 8
	}

	[Serializable]
	public struct VOStore
	{
		public float delay;

		public string line;
	}

	public class VOClip
	{
		public string key;

		public Guid guid;

		public HagletTrigger onComplete;

		public HagletTrigger onFinished;

		public HagletTrigger onInterrupted;

		public bool hasStarted;

		public bool triggerReleased = true;

		public float delayTime;

		public FMOD.Studio.EventInstance handle;

		public FMOD.Studio.EventInstance voDuckerSnapshot;

		public Transform source;
	}

	public struct VOResult
	{
		public HagletTrigger onComplete;

		public HagletTrigger onGotToEnd;

		public HagletTrigger onInterrupted;

		public bool queueWasFull;

		public VOClip clip;
	}

	protected static VOC _instance;

	private const int kQueueSize = 16;

	private const int kVOTrackNum = 1;

	private ConstQueue<VOClip> voQueue = new ConstQueue<VOClip>(16);

	private ConstArray<HagletTrigger> triggers = new ConstArray<HagletTrigger>(96u);

	[NonSerialized]
	[HideInInspector]
	public Dictionary<string, Guid> dictKeyToGUID;

	private Dictionary<Guid, string> dictGUIDToKey;

	public FMODBankAsset stringBankAsset;

	public VOClip activeClip;

	private HagletValue<bool> isBusy;

	public HagletValue<string> activeVOKey;

	public FMODSnapshotAsset voDucker;

	private FMOD.Studio.EventInstance evtVoDucker;

	public Localisation.Language voLanguage;

	public static VOC Inst => _instance;

	public Wait IsFree => Wait.Until.False(IsBusy, 1, allowPreMetNow: true);

	public event EventHandler<VOClip> onLineStartedPlaying;

	public Wait OnAwakeLR(bool synchronous)
	{
		_instance = this;
		HagletValue.Create(out isBusy, null, initVal: false, null, 8);
		HagletValue.Create(out activeVOKey, (string)null, (string)null, (HagletEvent.IOwner)null, 8);
		for (int i = 0; i < triggers._data.Length; i++)
		{
			triggers.Add(new HagletTrigger());
		}
		voLanguage = (Localisation.Language)PlayerPrefs.GetInt("LanguageVO", 0);
		Action action = delegate
		{
			FAC.Inst.sys.getBankByID(stringBankAsset.fmodGUID, out var bank);
			bank.getStringCount(out var count);
			_ = new string[count];
			_ = new Guid[count];
			dictKeyToGUID = new Dictionary<string, Guid>(count, StringComparer.OrdinalIgnoreCase);
			dictGUIDToKey = new Dictionary<Guid, string>(count);
			string text = "event:/vo/";
			int length = text.Length;
			for (int j = 0; j < count; j++)
			{
				bank.getStringInfo(j, out var id, out var path);
				if (path.Length >= length && path.IndexOf(text, 0, length, StringComparison.OrdinalIgnoreCase) == 0)
				{
					string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(path);
					dictKeyToGUID[fileNameWithoutExtension] = id;
					dictGUIDToKey[id] = fileNameWithoutExtension;
				}
			}
		};
		if (synchronous)
		{
			action();
			return Wait.None;
		}
		FAC.AddThreadTask(action);
		return FAC.WaitThreadBusy;
	}

	public void ClearRemainingVO()
	{
		for (int i = 0; i < voQueue.Length; i++)
		{
			VOClip clip = voQueue.Dequeue();
			ReleaseTriggers(clip);
		}
	}

	public Guid GetVOGuid(string key)
	{
		if (dictKeyToGUID.TryGetValue(key, out var value))
		{
			return value;
		}
		return default(Guid);
	}

	public void OnUpdateLR()
	{
		try
		{
			if (activeClip == null)
			{
				TrySetActiveClip();
			}
			else if (activeClip.delayTime <= 0f)
			{
				if (!activeClip.hasStarted)
				{
					StartActiveClip();
					return;
				}
				if (activeClip.source != null)
				{
					activeClip.handle.set3DAttributes(activeClip.source.position.to3DAttributes());
				}
				else
				{
					activeClip.handle.set3DAttributes(CC.Inst.transform.position.to3DAttributes());
				}
				activeClip.handle.getPlaybackState(out var state);
				if (state == PLAYBACK_STATE.STOPPED)
				{
					activeClip.handle.release();
					if (activeClip.voDuckerSnapshot.isValid())
					{
						activeClip.voDuckerSnapshot.stop(STOP_MODE.ALLOWFADEOUT);
					}
					ReleaseTriggers(activeClip);
					activeClip.onComplete.Trigger();
					activeClip.onFinished.Trigger();
					activeClip = null;
					TrySetActiveClip();
					return;
				}
			}
			else
			{
				activeClip.delayTime -= IC.DeltaTime;
			}
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
		isBusy.value = IsBusy();
	}

	public void OnPauseLR(bool paused)
	{
		activeClip?.handle.setPaused(paused);
	}

	private void TrySetActiveClip()
	{
		if (voQueue.Length > 0)
		{
			activeClip = voQueue.Dequeue(clearToDefault: true);
			activeVOKey.value = activeClip.key;
		}
		else if (evtVoDucker.isValid())
		{
			evtVoDucker.stop(STOP_MODE.ALLOWFADEOUT);
		}
	}

	private void StartActiveClip()
	{
		activeClip.handle = FAC.Inst.GetEvent(activeClip.guid);
		activeClip.handle.setParameterValue("Language", Localisation.langToFMODLookup[(int)voLanguage]);
		activeClip.handle.start();
		activeClip.hasStarted = true;
		if (this.onLineStartedPlaying != null)
		{
			this.onLineStartedPlaying(this, activeClip);
		}
		EventDescription description = FAC.Inst.GetDescription(activeClip.guid);
		int length = 0;
		description.getLength(out length);
		STC.Inst.Show(activeClip.key);
		if (!evtVoDucker.isValid())
		{
			evtVoDucker = FAC.Inst.PlaySnapShot(voDucker);
		}
	}

	public bool IsVOQueueEmpty()
	{
		return voQueue.Length == 0;
	}

	public bool IsBusy()
	{
		if (activeClip != null)
		{
			return true;
		}
		if (!IsVOQueueEmpty())
		{
			return true;
		}
		return false;
	}

	public VOResult QueueVO(string eventName, VOQueueProperty properties = VOQueueProperty.Queue, float delayTime = 0f, Transform source = null)
	{
		if (!dictKeyToGUID.ContainsKey(eventName))
		{
			return default(VOResult);
		}
		return QueueVO(eventName, dictKeyToGUID[eventName], properties, delayTime, source);
	}

	public VOResult QueueVO(Guid guid, VOQueueProperty properties = VOQueueProperty.Queue, float delayTime = 0f, Transform source = null)
	{
		if (!dictGUIDToKey.ContainsKey(guid))
		{
			return default(VOResult);
		}
		return QueueVO(dictGUIDToKey[guid], guid, properties, delayTime, source);
	}

	private VOResult QueueVO(string eventName, Guid guid, VOQueueProperty properties = VOQueueProperty.Queue, float delayTime = 0f, Transform source = null)
	{
		VOResult result = default(VOResult);
		if (voQueue.Length == 16)
		{
			UnityEngine.Debug.LogError("VO Queue full, can't enqueue " + eventName);
			result.queueWasFull = true;
			return result;
		}
		if ((properties & VOQueueProperty.OnlyPlayIfQueueEmpty) != 0 && activeClip != null)
		{
			result.queueWasFull = true;
		}
		if ((properties & VOQueueProperty.Interrupt) != 0)
		{
			VOStop(interruption: true);
		}
		VOClip obj = VOClipCreate(eventName, guid, ref result, delayTime, source);
		voQueue.Enqueue(obj);
		return result;
	}

	public VOResult PlayVOImmediate(string eventName, float delayTime = 0f, Transform source = null)
	{
		if (!dictKeyToGUID.ContainsKey(eventName))
		{
			return default(VOResult);
		}
		return PlayVOImmediate(eventName, dictKeyToGUID[eventName], delayTime, source);
	}

	public VOResult PlayVOImmediate(Guid guid, float delayTime = 0f, Transform source = null)
	{
		if (!dictGUIDToKey.ContainsKey(guid))
		{
			return default(VOResult);
		}
		return PlayVOImmediate(dictGUIDToKey[guid], guid, delayTime, source);
	}

	private VOResult PlayVOImmediate(string key, Guid guid, float delayTime = 0f, Transform source = null)
	{
		VOResult result = default(VOResult);
		VOStop(interruption: true);
		activeClip = VOClipCreate(key, guid, ref result, delayTime, source);
		StartActiveClip();
		return result;
	}

	private void ReleaseTriggers(VOClip clip)
	{
		if (!clip.triggerReleased)
		{
			triggers.Add(clip.onComplete);
			triggers.Add(clip.onFinished);
			triggers.Add(clip.onInterrupted);
			clip.triggerReleased = true;
		}
	}

	public void VOStop(bool interruption = false)
	{
		if (activeClip != null)
		{
			activeClip.handle.stop(STOP_MODE.ALLOWFADEOUT);
			activeClip.handle.release();
			activeClip.voDuckerSnapshot.stop(STOP_MODE.ALLOWFADEOUT);
			activeClip.onComplete.Trigger();
			if (interruption)
			{
				activeClip.onInterrupted.Trigger();
				ClearRemainingVO();
				voQueue.ClearToDefault();
			}
			STC.Inst.ClearSubtitleQueue();
			ReleaseTriggers(activeClip);
			if (interruption)
			{
				activeClip = null;
			}
		}
	}

	private VOClip VOClipCreate(string key, Guid guid, ref VOResult result, float delayTime, Transform source = null)
	{
		VOClip vOClip = new VOClip();
		vOClip.key = key;
		vOClip.guid = guid;
		result.onComplete = (vOClip.onComplete = triggers.RemoveAtIndex(triggers.Length - 1));
		result.onInterrupted = (vOClip.onInterrupted = triggers.RemoveAtIndex(triggers.Length - 1));
		result.onGotToEnd = (vOClip.onFinished = triggers.RemoveAtIndex(triggers.Length - 1));
		vOClip.triggerReleased = false;
		vOClip.delayTime = delayTime;
		vOClip.source = source;
		result.clip = vOClip;
		return vOClip;
	}
}
public class EventListenerTest : MonoBehaviour
{
	[Event(EventName = "Function A")]
	public void FunctionA(object sender)
	{
		UnityEngine.Debug.Log("Called Function A");
	}

	[Event(EventName = "Function B")]
	public void FunctionB(object sender)
	{
		UnityEngine.Debug.Log("Called Function B");
	}
}
public class EventTriggerTest : MonoBehaviour
{
	public bool triggerA;

	public bool triggerB;

	public Event onTriggerA;

	public Event onTriggerB;

	private void Start()
	{
		onTriggerA.PrepareInvoke();
		onTriggerB.PrepareInvoke();
	}

	private void OnValidate()
	{
		if (UnityEngine.Application.isPlaying)
		{
			if (triggerA)
			{
				onTriggerA.Invoke();
				triggerA = false;
			}
			if (triggerB)
			{
				onTriggerB.Invoke();
				triggerB = false;
			}
		}
	}
}
public class AnswerMachineController : MonoBehaviour, IAwakeEvent
{
	public enum State
	{
		On_NoNewMessages,
		On_MessageWaiting,
		Off
	}

	[Serializable]
	public struct Message
	{
		public VO_Sequencer sequencer;

		[EnumFlagsField]
		public SaveDataGame.Chapter unlockChapterMask;
	}

	public Message[] messages;

	public Button playButton;

	public GameObject buttonOnState;

	public GameObject buttonOffState;

	public FMODEventAsset newMessageBeepSFX;

	public Transform speaker;

	public float blinkDelay = 1.5f;

	public float beepDelay = 10f;

	private State state;

	private int lastPlayedMessageIdx;

	private IHaglet blinkRoutine;

	private IHaglet beepRoutine;

	private IHaglet<Message> playMessageRoutine;

	private void OnDestroy()
	{
		if (blinkRoutine.started)
		{
			blinkRoutine.Stop();
		}
		if (beepRoutine.started)
		{
			beepRoutine.Stop();
		}
	}

	[Event(EventName = "Power On")]
	private void PowerOn(object sender)
	{
		state = (CheckForNewMessages() ? State.On_MessageWaiting : State.On_NoNewMessages);
		UpdateEffects();
		playButton.enabled = true;
	}

	[Event(EventName = "Power Off")]
	private void PowerOff(object sender)
	{
		state = State.Off;
		playButton.enabled = false;
	}

	[Event(EventName = "On Play Button Up")]
	private void OnPlayButtonUp(object sender)
	{
		if (!playMessageRoutine.started)
		{
			Message messageToPlay = GetMessageToPlay();
			playMessageRoutine.Start(messageToPlay);
			state = (CheckForNewMessages() ? State.On_MessageWaiting : State.On_NoNewMessages);
			UpdateEffects();
		}
	}

	private Message GetMessageToPlay()
	{
		for (int i = 0; i < messages.Length; i++)
		{
			if (LR.Inst.saveDataGame.IsChapterMaskCompleteAll(messages[i].unlockChapterMask) && !LR.Inst.saveDataGame.GetVOSequencerComplete(messages[i].sequencer.id))
			{
				lastPlayedMessageIdx = i;
				UnityEngine.Debug.Log("Playing (New) Message " + i);
				return messages[i];
			}
		}
		lastPlayedMessageIdx = (lastPlayedMessageIdx + 1) % messages.Length;
		Message message = messages[lastPlayedMessageIdx];
		if (!LR.Inst.saveDataGame.IsChapterMaskCompleteAll(message.unlockChapterMask))
		{
			lastPlayedMessageIdx = 0;
			message = messages[0];
		}
		UnityEngine.Debug.Log("Playing (Old) Message " + lastPlayedMessageIdx);
		return messages[lastPlayedMessageIdx];
	}

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		Haglet.Create(out playMessageRoutine, (Routine.Func1<Message>)PlayMessageRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out blinkRoutine, BlinkRoutine);
		Haglet.Create(out beepRoutine, BeepRoutine);
		state = State.Off;
		playButton.enabled = false;
	}

	private void OnChapterComplete(SaveDataGame.Chapter chapter)
	{
		if (state != State.Off)
		{
			state = (CheckForNewMessages() ? State.On_MessageWaiting : State.On_NoNewMessages);
			UpdateEffects();
		}
	}

	private bool CheckForNewMessages()
	{
		bool flag = false;
		for (int i = 0; i < messages.Length; i++)
		{
			if (!LR.Inst.saveDataGame.GetVOSequencerComplete(messages[i].sequencer.id))
			{
				flag |= LR.Inst.saveDataGame.IsChapterMaskCompleteAll(messages[i].unlockChapterMask);
			}
		}
		return flag;
	}

	private void UpdateEffects()
	{
		if (state == State.On_MessageWaiting)
		{
			if (!blinkRoutine.started)
			{
				blinkRoutine.Start();
			}
			if (!beepRoutine.started)
			{
				beepRoutine.Start();
			}
		}
	}

	private IEnumerator<Routine.Yield> BlinkRoutine()
	{
		while (state == State.On_MessageWaiting)
		{
			buttonOnState.SetActive(!buttonOnState.activeSelf);
			buttonOffState.SetActive(!buttonOnState.activeSelf);
			yield return Wait.For.Seconds(blinkDelay);
		}
		buttonOnState.SetActive(value: false);
		buttonOffState.SetActive(value: true);
	}

	private IEnumerator<Routine.Yield> BeepRoutine()
	{
		yield return Wait.For.Seconds(beepDelay);
		while (state == State.On_MessageWaiting)
		{
			FAC.Inst.PlayOneShot(newMessageBeepSFX, speaker);
			yield return Wait.For.Seconds(beepDelay);
		}
	}

	private IEnumerator<Routine.Yield> PlayMessageRoutine(Message msg)
	{
		msg.sequencer.SaveAsComplete(null);
		yield return msg.sequencer.PlayNextVOSection();
	}
}
public class BreakerSwitch : MonoBehaviour, IAwakeEvent, IPrepareEvent
{
	public Event OnPowerOn;

	public Event OnPowerOff;

	private HagletValue<bool> powerOn;

	public GameObject redLight;

	public GameObject greenLight;

	private IHaglet prepareEventRoutine;

	public Wait isPowerOn => Wait.Until.True(powerOn, 1, allowPreMetNow: true);

	public Wait isPowerOff => Wait.Until.False(powerOn, 1, allowPreMetNow: true);

	public bool IsPowerOn => powerOn.value;

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		HagletValue.Create(out powerOn, null, initVal: false, null, 8);
		FixedRotatableObject componentInChildren = GetComponentInChildren<FixedRotatableObject>();
		redLight.SetActive(componentInChildren.enabled);
		greenLight.SetActive(!componentInChildren.enabled);
		Haglet.Create(out prepareEventRoutine, PrepareEventRoutine);
	}

	Wait IPrepareEvent.PrepareEvents()
	{
		return prepareEventRoutine.Start();
	}

	private IEnumerator<Routine.Yield> PrepareEventRoutine()
	{
		OnPowerOn.PrepareInvoke();
		yield return Wait.For.LRUpdates(1);
		OnPowerOff.PrepareInvoke();
	}

	[Event(EventName = "Power On")]
	private void PowerOn(object sender)
	{
		if (!powerOn.value)
		{
			powerOn.value = true;
			OnPowerOn.Invoke();
			redLight.SetActive(value: false);
			greenLight.SetActive(value: true);
		}
	}

	[Event(EventName = "Power Off")]
	private void PowerOff(object sender)
	{
		if (powerOn.value)
		{
			powerOn.value = false;
			OnPowerOff.Invoke();
			redLight.SetActive(value: true);
			greenLight.SetActive(value: false);
		}
	}
}
public class ConstructP2_DrawbridgeSound : HAGIS
{
	public InteractableTarget_Animation targetInteractable;

	public FMODEventAsset soundDrawbridge;

	private FMOD.Studio.EventInstance evt;

	private float lastFrameNormTime;

	private int stopFrameCount;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		int frameCount = 2;
		while (targetInteractable.normalisedPostion <= 0.001f)
		{
			yield return Wait.For.LRLateUpdates(1);
		}
		evt = FAC.Inst.PlayOneShot(soundDrawbridge, base.transform.position);
		while (targetInteractable.normalisedPostion < 0.999f)
		{
			float normalisedPostion = targetInteractable.normalisedPostion;
			frameCount = ((normalisedPostion - lastFrameNormTime != 0f) ? 2 : Mathf.Max(0, frameCount - 1));
			bool flag = frameCount <= 0;
			if (flag && evt.isValid())
			{
				evt.stop(STOP_MODE.ALLOWFADEOUT);
			}
			else if (!flag && !evt.isValid())
			{
				evt = FAC.Inst.PlayOneShot(soundDrawbridge, base.transform.position);
				evt.setParameterValue("DrawBridgeProgress", 0.5f);
			}
			lastFrameNormTime = normalisedPostion;
			yield return Wait.For.LRLateUpdates(1);
		}
		evt.setParameterValue("DrawBridgeProgress", 1f);
	}
}
public class ConstructP5_PlatformSound : MonoBehaviour, IAwakeEvent, IPostPhysicsUpdateEvent
{
	public FMODEventAsset platformSound;

	private FMOD.Studio.EventInstance evt;

	[Tooltip("The number of degrees per second at which to set the FinalPuzzleRotate parameter to 1.")]
	public float degreeParamDivisor = 5f;

	public RotationSFX[] handles;

	private Vector3[] prevHandleEulerRot;

	private float stopTimer;

	public float speedWindow = 0.01f;

	public void OnAwakeLR(MRBase owner)
	{
		prevHandleEulerRot = new Vector3[handles.Length];
		for (int i = 0; i < handles.Length; i++)
		{
			prevHandleEulerRot[i] = handles[i].transform.rotation.eulerAngles;
		}
	}

	public void OnPostPhysicsUpdateLR()
	{
		float num = 0f;
		for (int i = 0; i < handles.Length; i++)
		{
			num = Mathf.Max(num, (prevHandleEulerRot[i] - handles[i].transform.rotation.eulerAngles).magnitude);
			prevHandleEulerRot[i] = handles[i].transform.rotation.eulerAngles;
		}
		num = Mathf.Clamp01(num / (IC.DeltaTime * degreeParamDivisor));
		if (num > speedWindow)
		{
			stopTimer = 0.1f;
			if (!evt.isValid())
			{
				evt = FAC.Inst.PlayOneShot(platformSound, base.transform.position);
			}
			evt.setParameterValue("FinalPuzzleRotate", num);
		}
		else if (stopTimer >= 0f)
		{
			stopTimer -= IC.DeltaTime;
			if (stopTimer < 0f && evt.isValid())
			{
				evt.stop(STOP_MODE.ALLOWFADEOUT);
			}
		}
	}

	private void OnDestroy()
	{
		if (evt.isValid())
		{
			evt.stop(STOP_MODE.IMMEDIATE);
		}
	}
}
public class CrystalShards_LightsensorHolder : MonoBehaviour
{
	[Event(EventName = "Light Crystal Placed")]
	public void LightCrystalPlaced(object sender)
	{
	}

	[Event(EventName = "Light Crystal Removed")]
	public void LightCrystalRemoved(object sender)
	{
	}
}
[RequireComponent(typeof(GrabObject))]
public class KeyGrabbableOnAreaEnter : MonoBehaviour, IAwakeEvent, IAreaEvent
{
	private GrabObject g;

	private bool hasBeenTriggered;

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		g = GetComponent<GrabObject>();
		g.canBeGrabbed = false;
	}

	void IAreaEvent.OnAreaEnter()
	{
		if (!hasBeenTriggered)
		{
			g.canBeGrabbed = true;
			hasBeenTriggered = true;
		}
	}

	void IAreaEvent.OnAreaExit()
	{
	}
}
public class MansfieldMirrors_MirrorSound : MonoBehaviour, IAwakeEvent, IPostPhysicsUpdateEvent
{
	public FMODEventAsset platformSound;

	public FMODEventAsset slideSound;

	private FMOD.Studio.EventInstance evt;

	[Tooltip("The number of degrees per second at which to set the FinalPuzzleRotate parameter to 1.")]
	public float degreeParamDivisor = 5f;

	public FixedRotatableObject handle;

	private Vector3 prevHandleEulerRot;

	private float stopTimer;

	public float speedWindow = 0.01f;

	public Transform soundPos;

	private float soundMovementTotal;

	public float soundMovementAdjust = 0.1f;

	public void OnAwakeLR(MRBase owner)
	{
		prevHandleEulerRot = handle.transform.rotation.eulerAngles;
	}

	public void OnPostPhysicsUpdateLR()
	{
		float magnitude = (prevHandleEulerRot - handle.transform.rotation.eulerAngles).magnitude;
		prevHandleEulerRot = handle.transform.rotation.eulerAngles;
		magnitude = Mathf.Clamp01(magnitude / (IC.DeltaTime * degreeParamDivisor));
		if (magnitude > speedWindow)
		{
			stopTimer = 0.1f;
			if (!evt.isValid())
			{
				evt = FAC.Inst.PlayOneShot(platformSound, soundPos);
			}
			evt.setParameterValue("FinalPuzzleRotate", magnitude);
		}
		else if (stopTimer >= 0f)
		{
			stopTimer -= IC.DeltaTime;
			if (stopTimer < 0f && evt.isValid())
			{
				evt.stop(STOP_MODE.ALLOWFADEOUT);
			}
		}
		soundMovementTotal += magnitude * soundMovementAdjust;
		if (soundMovementTotal > degreeParamDivisor)
		{
			soundMovementTotal -= degreeParamDivisor;
			FAC.Inst.PlayOneShot(slideSound, soundPos.position).setParameterValue("Speed", magnitude);
		}
	}

	private void OnDestroy()
	{
		if (evt.isValid())
		{
			evt.stop(STOP_MODE.IMMEDIATE);
		}
	}
}
public class MusicBoxController : MonoBehaviour, IAwakeEvent, IGrabEvent
{
	private const float OPEN_THRESHOLD = 0.01f;

	public Transform ballerinaXForm;

	public Transform ballerinaSpringXForm;

	public float ballerinaRotDegPerSec;

	public FMODEventAsset music;

	public FMODEventAsset sfxOpen;

	public FMODEventAsset sfxClose;

	public float hapticAmplitude = 0.1f;

	public float hapticFrequency = 0.5f;

	public PlacementHelperSnapPivot[] pivotsWhileClosed;

	private FMOD.Studio.EventInstance musicInst;

	private FixedRotatableObject fixedRotObj;

	private GrabObject grabObj;

	private bool hasBeenGrabbed;

	private IHaglet updateBoxRoutine;

	private float Progress
	{
		get
		{
			float num = fixedRotObj.transform.localRotation.eulerAngles.z;
			if (num > 45f)
			{
				num -= 360f;
			}
			return Mathf.InverseLerp(-35f, 35f, num);
		}
	}

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		grabObj = base.gameObject.GetComponentInAscendant<GrabObject>();
		fixedRotObj = grabObj.GetComponentInChildren<FixedRotatableObject>(includeInactive: true);
		Haglet.Create(out updateBoxRoutine, UpdateBoxRoutine, null, startNow: true);
	}

	public void Pause(bool paused)
	{
		if (!base.isActiveAndEnabled)
		{
			return;
		}
		if (musicInst.isValid())
		{
			musicInst.setPaused(paused);
		}
		if (paused)
		{
			if (updateBoxRoutine != null && updateBoxRoutine.started)
			{
				updateBoxRoutine.Stop();
			}
		}
		else if (updateBoxRoutine != null && !updateBoxRoutine.started)
		{
			updateBoxRoutine.Start();
		}
	}

	private IEnumerator<Routine.Yield> UpdateBoxRoutine()
	{
		ballerinaXForm.localRotation = QuaternionX.identity;
		ballerinaSpringXForm.localRotation = Quaternion.Euler(-90f, 0f, 0f);
		bool wasOpen = Progress > 0.01f;
		while (true)
		{
			if (!musicInst.isValid())
			{
				musicInst = FAC.Inst.PlayOneShot(music, base.transform);
				musicInst.setPaused(paused: true);
			}
			if (!base.gameObject.activeInHierarchy)
			{
				musicInst.setPaused(paused: true);
			}
			float progress = Progress;
			Quaternion localRotation = Quaternion.Euler(Mathf.Lerp(-90f, 0f, progress), 0f, 0f);
			ballerinaSpringXForm.localRotation = localRotation;
			musicInst.getPaused(out var paused);
			if (progress > 0.5f && paused)
			{
				musicInst.setPaused(paused: false);
			}
			if (progress < 0.05f && !paused)
			{
				musicInst.setPaused(paused: true);
			}
			if (musicInst.isValid() && !paused)
			{
				Hand handObjectIsGrabbed = CC.Inst.GetHandObjectIsGrabbed(grabObj);
				Hand handObjectIsGrabbed2 = CC.Inst.GetHandObjectIsGrabbed(fixedRotObj);
				if ((bool)handObjectIsGrabbed)
				{
					Hand.PulseHapticFeedback(hapticFrequency, hapticAmplitude, 0.1f, handObjectIsGrabbed);
				}
				if ((bool)handObjectIsGrabbed2)
				{
					Hand.PulseHapticFeedback(hapticFrequency, hapticAmplitude, 0.1f, handObjectIsGrabbed2);
				}
			}
			if (progress > 0.95f)
			{
				float deltaTime = IC.DeltaTime;
				ballerinaXForm.localRotation *= Quaternion.Euler(0f, ballerinaRotDegPerSec * deltaTime, 0f);
			}
			else
			{
				float y = ballerinaXForm.localRotation.eulerAngles.y;
				float target = Mathf.Round(y / 180f) * 180f;
				float y2 = Mathf.MoveTowards(y, target, ballerinaRotDegPerSec * IC.DeltaTime);
				ballerinaXForm.localRotation = Quaternion.Euler(0f, y2, 0f);
			}
			bool flag = progress > 0.01f;
			if (flag != wasOpen)
			{
				FMODEventAsset asset = (flag ? sfxOpen : sfxClose);
				FAC.Inst.PlayOneShot(asset, base.transform.position);
				wasOpen = flag;
				PlacementHelperSnapPivot[] array = pivotsWhileClosed;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].gameObject.SetActive(!flag);
				}
			}
			yield return Wait.For.LRUpdates(1);
		}
	}

	void IGrabEvent.OnGrab(GrabObject obj)
	{
		if (!hasBeenGrabbed)
		{
			fixedRotObj.Animate(45f, 1f);
			hasBeenGrabbed = true;
		}
	}

	void IGrabEvent.OnRelease()
	{
	}
}
public class Station_GondolaFlappyController : MonoBehaviour
{
	public Animation[] handStraps;

	public Animation hangingRope;

	public string handStrapAmbient;

	public string handStrapShake;

	public string hangingRopeAmbient;

	public string hangingRopeShake;

	public IHaglet<bool, float> routineShake;

	private void Awake()
	{
		Haglet.Create(out routineShake, (Routine.Func2<bool, float>)RoutineShake, (string)null, startNow: false, (int?)null, (string)null);
	}

	private IEnumerator<Routine.Yield> RoutineShake(bool stopAfter = false, float timeOverride = 0f)
	{
		float seconds = ((timeOverride == 0f) ? hangingRope[hangingRopeShake].length : timeOverride);
		PlayShake();
		yield return Wait.For.Seconds(seconds);
		if (stopAfter)
		{
			StopAnim();
		}
		else
		{
			PlayAmbient();
		}
	}

	public void PlayShake()
	{
		Animation[] array = handStraps;
		foreach (Animation obj in array)
		{
			obj.Stop();
			obj[handStrapShake].enabled = true;
			obj[handStrapShake].weight = 1f;
			obj[handStrapShake].normalizedTime = UnityEngine.Random.value;
			obj[handStrapShake].speed = 1f;
		}
		hangingRope.Play(hangingRopeShake);
	}

	public void PlayAmbient()
	{
		Animation[] array = handStraps;
		foreach (Animation obj in array)
		{
			obj.Stop();
			obj[handStrapAmbient].enabled = true;
			obj[handStrapAmbient].weight = 1f;
			obj[handStrapAmbient].normalizedTime = UnityEngine.Random.value;
			obj[handStrapAmbient].speed = 1f;
		}
		hangingRope.Play(hangingRopeAmbient);
	}

	public void StopAnim()
	{
		Animation[] array = handStraps;
		foreach (Animation obj in array)
		{
			obj.Stop();
			obj[handStrapAmbient].normalizedTime = UnityEngine.Random.value;
			obj.Sample();
		}
		hangingRope.Stop();
	}
}
[RequireComponent(typeof(Collider))]
public class CutsceneCollider : MonoBehaviour
{
	[ReadOnly]
	public Telepoint telepoint;

	[ReadOnly]
	public HagletTrigger cutSceneTrigger;
}
[Serializer.ExcludeAllFields]
public class Doorway : MonoBehaviour, IAwakeEvent, IUpdateEvent, IPrepareEvent
{
	public enum State
	{
		Open,
		Closed
	}

	public Region region;

	[Serializer.IncludeField]
	public State state = State.Closed;

	[LabelOverride("Animation")]
	public Animation anim;

	[LabelOverride("Open Animation Name")]
	public string animName;

	[Tooltip("This will cause snapping if interrupted")]
	public bool allowCloseAnimation;

	[Tooltip("Optional Animation for CLosing. WARNING: if this door can be interupted this will pop")]
	[ConditionalHide("allowCloseAnimation")]
	public string closeAnimName;

	public FMODEventAsset openSound;

	public FMODEventAsset closeSound;

	public FMODEventAsset loopingSound;

	[ConditionalHide("openSound")]
	public Transform openSoundLocation;

	[ConditionalHide("closeSound")]
	public Transform closeSoundLocation;

	[ConditionalHide("loopingSound")]
	public Transform loopingSoundLocation;

	[Range(0f, 1f)]
	public float regionEnableTime = 0.8f;

	private bool regionIsEnabled = true;

	private AnimationState animState;

	private AnimationState closeAnimState;

	public Event OnDoorwayOpen = new Event();

	public Event onDoorwayClose = new Event();

	public OcclusionPortal occlusionPortal;

	private FMOD.Studio.EventInstance evtLoopingSound;

	private bool shouldBeOpen;

	private IHaglet prepareEventRoutine;

	private IHaglet<State> animationRoutine;

	private void Start()
	{
	}

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		Haglet.Create(out animationRoutine, (Routine.Func1<State>)AnimationRoutine, (string)null, startNow: false, (int?)null, (string)null);
		animState = anim[animName];
		animState.wrapMode = WrapMode.ClampForever;
		if (allowCloseAnimation)
		{
			closeAnimState = anim[closeAnimName];
			closeAnimState.wrapMode = WrapMode.ClampForever;
		}
		if (state == State.Open)
		{
			Open(immediate: true);
		}
		else
		{
			Close(immediate: true);
		}
		occlusionPortal = GetComponent<OcclusionPortal>();
		if (occlusionPortal != null)
		{
			occlusionPortal.open = state == State.Open;
		}
		Haglet.Create(out prepareEventRoutine, PrepareEventRoutine);
	}

	Wait IPrepareEvent.PrepareEvents()
	{
		return prepareEventRoutine.Start();
	}

	private IEnumerator<Routine.Yield> PrepareEventRoutine()
	{
		OnDoorwayOpen.PrepareInvoke();
		yield return Wait.For.LRUpdates(1);
		onDoorwayClose.PrepareInvoke();
	}

	void IUpdateEvent.OnUpdateLR()
	{
		if (!animationRoutine.started)
		{
			if (state == State.Closed && shouldBeOpen)
			{
				Open();
			}
			else if (state == State.Open && !shouldBeOpen)
			{
				Close();
			}
		}
	}

	[ContextMenu("Open Doorway")]
	public void CTX_Open()
	{
		Open();
	}

	[ContextMenu("Close Doorway")]
	public void CTX_Close()
	{
		Close();
	}

	[Event(EventName = "Open")]
	public void Open(object sender)
	{
		if (state == State.Closed && (!animationRoutine.started || (animationRoutine.started && animationRoutine.arg0 == State.Closed)))
		{
			Open();
		}
		shouldBeOpen = true;
	}

	[Event(EventName = "Close")]
	public void Close(object sender)
	{
		if (state == State.Open && (!animationRoutine.started || (animationRoutine.started && animationRoutine.arg0 == State.Open)))
		{
			Close();
		}
		shouldBeOpen = false;
	}

	public Wait Open(bool immediate = false)
	{
		shouldBeOpen = true;
		if (immediate)
		{
			if (occlusionPortal != null)
			{
				occlusionPortal.open = true;
			}
			SetRegionEnabled(enabled: true);
			SampleAnimation(animState, animState.length);
			if (evtLoopingSound.isValid())
			{
				evtLoopingSound.stop(STOP_MODE.ALLOWFADEOUT);
			}
			return Wait.None;
		}
		Transform parent = (openSoundLocation ? openSoundLocation : base.transform);
		FAC.Inst.PlayOneShot(openSound, parent);
		return animationRoutine.Start(State.Open, resetIfStarted: true);
	}

	public Wait Close(bool immediate = false)
	{
		shouldBeOpen = false;
		if (immediate)
		{
			if (occlusionPortal != null)
			{
				occlusionPortal.open = false;
			}
			SetRegionEnabled(enabled: false);
			AnimationState animationState = (allowCloseAnimation ? closeAnimState : animState);
			float t = (allowCloseAnimation ? closeAnimState.length : 0f);
			SampleAnimation(animationState, t);
			if (evtLoopingSound.isValid())
			{
				evtLoopingSound.stop(STOP_MODE.ALLOWFADEOUT);
			}
			return Wait.None;
		}
		Transform parent = (closeSoundLocation ? closeSoundLocation : base.transform);
		FAC.Inst.PlayOneShot(closeSound, parent);
		return animationRoutine.Start(State.Closed, resetIfStarted: true);
	}

	private IEnumerator<Routine.Yield> AnimationRoutine(State targetState)
	{
		if (targetState == State.Closed)
		{
			SetRegionEnabled(enabled: false);
		}
		else if (occlusionPortal != null)
		{
			occlusionPortal.open = true;
		}
		if ((bool)loopingSound)
		{
			Transform parent = ((loopingSoundLocation != null) ? loopingSoundLocation : base.transform);
			evtLoopingSound = FAC.Inst.PlayOneShot(loopingSound, parent);
		}
		AnimationState animationState = ((allowCloseAnimation && targetState == State.Closed) ? closeAnimState : animState);
		float targetTime = ((targetState == State.Open || allowCloseAnimation) ? animationState.length : 0f);
		float currTime = animationState.time;
		float regionEnableTime = animationState.length * this.regionEnableTime;
		float lastTime = currTime;
		while (currTime != targetTime && lastTime > targetTime == currTime > targetTime)
		{
			if (targetState == State.Open && currTime >= regionEnableTime && !regionIsEnabled)
			{
				SetRegionEnabled(enabled: true);
			}
			lastTime = currTime;
			float deltaTime = IC.DeltaTime;
			currTime += deltaTime * ((targetState == State.Open || allowCloseAnimation) ? 1f : (-1f));
			SampleAnimation(animationState, currTime);
			yield return Wait.For.LRUpdates(1);
		}
		if (targetState == State.Open)
		{
			SetRegionEnabled(enabled: true);
			OnDoorwayOpen.Invoke();
		}
		else
		{
			onDoorwayClose.Invoke();
			if (occlusionPortal != null)
			{
				occlusionPortal.open = false;
			}
		}
		if (evtLoopingSound.isValid())
		{
			evtLoopingSound.stop(STOP_MODE.ALLOWFADEOUT);
		}
		SampleAnimation(animationState, targetTime);
		state = targetState;
	}

	private void SetRegionEnabled(bool enabled)
	{
		if (enabled && !regionIsEnabled)
		{
			region.Enable();
			regionIsEnabled = true;
		}
		else if (!enabled && regionIsEnabled)
		{
			region.Disable();
			regionIsEnabled = false;
		}
	}

	private void SampleAnimation(AnimationState state, float t)
	{
		float num = t / state.length;
		animState.enabled = animState == state;
		if (allowCloseAnimation)
		{
			closeAnimState.enabled = closeAnimState == state;
			((animState == state) ? closeAnimState : animState).normalizedTime = 1f - num;
		}
		state.speed = 0f;
		state.weight = 1f;
		state.normalizedTime = num;
	}
}
public class EGrill : MonoBehaviour, Region.IConnectionOwner, Region.IConnectionKey, PortalVariations.IUseVariantSet, IPrebuildEvent
{
	public const int MAX_AREAS = 16;

	public int areaFront;

	public int areaBack;

	private MaterialPropertyBlock mpb;

	private MeshRenderer mr;

	private Mesh egrillMesh;

	public HagletTrigger onCrossedEGrillTrigger = new HagletTrigger();

	private FMOD.Studio.EventInstance soundEmittingEvent;

	private FMOD.Studio.EventInstance soundPassThroughEvent;

	private TransformData xformData;

	private Vector2 minBounds;

	private Vector2 maxBounds;

	private PortalVariations.VariantSet? portalVariationSet;

	private static Collider[] overlapResults = new Collider[4];

	private void SetupVisuals()
	{
		if (mpb == null)
		{
			mpb = new MaterialPropertyBlock();
		}
		mr = GetComponentInChildren<MeshRenderer>();
		Vector3 localScale = xformData.xform.localScale;
		mpb.SetVector("_LocalScale", new Vector4(localScale.x, localScale.y, localScale.z, 0f));
		mr.SetPropertyBlock(mpb);
		egrillMesh = GetComponentInChildren<MeshFilter>().sharedMesh;
		minBounds = egrillMesh.bounds.min;
		maxBounds = egrillMesh.bounds.max;
	}

	void IPrebuildEvent.OnPrebuildRoot(bool isPrefab)
	{
		if (!isPrefab)
		{
			BoxCollider boxCollider = base.gameObject.AddComponent<BoxCollider>();
			Bounds bounds = GetComponentInChildren<MeshFilter>().sharedMesh.bounds;
			boxCollider.center = new Vector3(bounds.center.x, bounds.center.y, 0f);
			boxCollider.size = new Vector3(bounds.size.x, bounds.size.y, 0.01f);
		}
	}

	public void OnAwakeLR(MRBase owner)
	{
		xformData = new TransformData(base.transform);
		SetupVisuals();
		Vector3 position = xformData.position;
		Vector3 up = xformData.up;
		ConstArray<Region> constArray = new ConstArray<Region>(4u);
		Region[] regions = owner.regions;
		foreach (Region region in regions)
		{
			if (region.IsAlignedToUpDirection(up) && !(region.GetYOffset(position) <= 0f))
			{
				Vector3 position2 = GetComponentInChildren<MeshFilter>().sharedMesh.bounds.min.RepXZ(0f, 0f);
				Vector3 worldPos = base.transform.TransformPoint(position2);
				if (!(region.GetYOffset(worldPos) >= 0f) && region.IsPointInsidePolygonWS(position, inner: false))
				{
					constArray.Add(region);
				}
			}
		}
		_ = constArray.Length;
		_ = 2;
		for (int j = 0; j < constArray.Length; j++)
		{
			Region region2 = constArray[j];
			for (int k = 0; k < region2.connectedRegions.Length; k++)
			{
				Region.Connection value = region2.connectedRegions[k];
				if (value.owner is Region && constArray.Contains(value.region))
				{
					value.owner = this;
					region2.connectedRegions[k] = value;
				}
			}
		}
		soundEmittingEvent = FAC.Inst.PlayOneShot(BaseSettings<InventorySettings>.Inst.soundODZEmitting.Value, position);
		soundPassThroughEvent = FAC.Inst.PlayOneShot(BaseSettings<InventorySettings>.Inst.soundODZPassThrough.Value, position);
	}

	public void OnUpdateLR()
	{
	}

	bool Region.IConnectionOwner.IsConnectionValid(Region.IConnectionKey key, bool teleporting)
	{
		if (!teleporting)
		{
			return true;
		}
		return key == this;
	}

	public static bool RaycastGetClosest(MRBase owner, Ray ray, float raySearchDistance, out float distance, out EGrill grillFound)
	{
		return RaycastGetClosest(owner, ray.origin, ray.direction, raySearchDistance, out distance, out grillFound);
	}

	public static bool RaycastGetClosest(MRBase owner, Vector3 rayOrigin, Vector3 rayDirection, float raySearchDistance, out float distance, out EGrill grillFound)
	{
		distance = float.MaxValue;
		grillFound = null;
		bool result = false;
		if ((bool)owner)
		{
			for (int i = 0; i < owner.eGrills.Length; i++)
			{
				EGrill eGrill = owner.eGrills[i];
				if (eGrill.EGrillPlaneRaycast(rayOrigin, rayDirection, raySearchDistance, out var distance2) && distance2 < distance)
				{
					distance = distance2;
					grillFound = eGrill;
					result = true;
				}
			}
		}
		return result;
	}

	public static float GetNearestEGrill(Vector3 worldPos, MRBase owner, out EGrill nearestGrill)
	{
		float num = float.PositiveInfinity;
		nearestGrill = null;
		for (int i = 0; i < owner.eGrills.Length; i++)
		{
			float sqrMagnitude = (worldPos - owner.eGrills[i].transform.position).sqrMagnitude;
			if (sqrMagnitude < num)
			{
				num = sqrMagnitude;
				nearestGrill = owner.eGrills[i];
			}
		}
		if (nearestGrill != null)
		{
			Vector3 vector = nearestGrill.transform.InverseTransformPoint(worldPos);
			if (vector.x > nearestGrill.maxBounds.x || vector.x < nearestGrill.minBounds.x)
			{
				return float.PositiveInfinity;
			}
			if (vector.y > nearestGrill.maxBounds.y || vector.y < nearestGrill.minBounds.y)
			{
				return float.PositiveInfinity;
			}
			return Mathf.Abs(new Plane(nearestGrill.transform.forward, nearestGrill.transform.position).GetDistanceToPoint(worldPos));
		}
		return float.PositiveInfinity;
	}

	public bool EGrillPlaneRaycast(Vector3 rayOrigin, Vector3 rayDirection, float raySearchDistance, out float distance)
	{
		distance = float.MaxValue;
		bool result = false;
		Vector3 position = xformData.position;
		Vector3 forward = xformData.forward;
		float num = 0f - (forward.x * position.x + forward.y * position.y + forward.z * position.z);
		float num2 = rayDirection.x * forward.x + rayDirection.y * forward.y + rayDirection.z * forward.z;
		float num3 = 0f - (rayOrigin.x * forward.x + rayOrigin.y * forward.y + rayOrigin.z * forward.z) - num;
		if (((num2 < 0f) ? (0f - num2) : num2) >= Mathf.Epsilon * 8f)
		{
			float num4 = num3 / num2;
			if (num4 > 0f)
			{
				Vector3 position2 = default(Vector3);
				position2.x = rayOrigin.x + rayDirection.x * num4;
				position2.y = rayOrigin.y + rayDirection.y * num4;
				position2.z = rayOrigin.z + rayDirection.z * num4;
				Vector3 vector = xformData.xform.InverseTransformPoint(position2);
				if (vector.x > maxBounds.x || vector.x < minBounds.x)
				{
					return false;
				}
				if (vector.y > maxBounds.y || vector.y < minBounds.y)
				{
					return false;
				}
				if (raySearchDistance < num4)
				{
					return false;
				}
				distance = ((num4 < distance) ? num4 : distance);
				result = true;
			}
		}
		return result;
	}

	public static void UngrabAndResetHandGrabObject(Hand hand)
	{
		GrabObject grabObject = hand.InteractableHeld as GrabObject;
		if ((bool)grabObject)
		{
			hand.UngrabObject();
			TransformState lastPhysicsState = grabObject.GetLastPhysicsState();
			Transform obj = grabObject.transform;
			obj.position = lastPhysicsState.position;
			obj.rotation = lastPhysicsState.rotation;
		}
	}

	private static void CrossedEGrill(MRBase owner, int areaPrev, int areaCurr, CC.MovementType movementType, PortalVariations.VariantSet? portalVariationSet)
	{
		_ = owner.eGrillInventories;
		PlayerInventory.Inst.OnCrossedEGrill(areaCurr);
		CC inst = CC.Inst;
		if (ShouldDropItem(inst.handL.InteractableHeld as GrabObject, portalVariationSet))
		{
			UngrabAndResetHandGrabObject(inst.handL);
		}
		if (ShouldDropItem(inst.handR.InteractableHeld as GrabObject, portalVariationSet))
		{
			UngrabAndResetHandGrabObject(inst.handR);
		}
	}

	private static bool ShouldDropItem(GrabObject grabObject, PortalVariations.VariantSet? grillVariantSet)
	{
		if (!grabObject || !grillVariantSet.HasValue)
		{
			return true;
		}
		return grabObject.portalVariations.currentController == grillVariantSet.Value;
	}

	public static void OnMainCameraEvaluateMovement(MRBase owner, MainCamera mainCamera, CC.TeleportInfo teleportInfo, CC.MovementType movementType)
	{
		Vector3 position = mainCamera.transform.position;
		if ((bool)teleportInfo.eGrill)
		{
			EGrill eGrill = teleportInfo.eGrill;
			Vector3 position2 = eGrill.xformData.position;
			Vector3 forward = eGrill.xformData.forward;
			int num = ((Mathf.Sign(Vector3.Dot(position - position2, forward)) > 0f) ? eGrill.areaFront : eGrill.areaBack);
			int areaPrev = ((num == eGrill.areaFront) ? eGrill.areaBack : eGrill.areaFront);
			CrossedEGrill(owner, areaPrev, num, movementType, eGrill.portalVariationSet);
			eGrill.onCrossedEGrillTrigger.Trigger();
			return;
		}
		for (int i = 0; i < owner.eGrills.Length; i++)
		{
			EGrill eGrill2 = owner.eGrills[i];
			Vector3 position3 = eGrill2.xformData.position;
			Vector3 forward2 = eGrill2.xformData.forward;
			Vector3 position4 = mainCamera.GetLastState().position;
			float num2 = Vector3.Dot(position4 - position3, forward2);
			float num3 = Vector3.Dot(position - position3, forward2);
			float num4 = Mathf.Sign(num2);
			float num5 = Mathf.Sign(num3);
			if (num2 == 0f && num3 != 0f)
			{
				num4 = 0f - num5;
			}
			else if (num3 == 0f && num2 != 0f)
			{
				num5 = 0f - num4;
			}
			if (num4 != num5)
			{
				Vector3 rayOrigin = position4;
				Vector3 normalized = (position - position4).normalized;
				float raySearchDistance = 0.5f;
				float distance = float.MaxValue;
				if (eGrill2.EGrillPlaneRaycast(rayOrigin, normalized, raySearchDistance, out distance))
				{
					int num6 = ((num5 > 0f) ? eGrill2.areaFront : eGrill2.areaBack);
					int areaPrev2 = ((num6 == eGrill2.areaFront) ? eGrill2.areaBack : eGrill2.areaFront);
					CrossedEGrill(owner, areaPrev2, num6, movementType, eGrill2.portalVariationSet);
					eGrill2.onCrossedEGrillTrigger.Trigger();
				}
			}
		}
	}

	public void UpdateHandGrab(Hand hand)
	{
		GrabObject grabObjectHeld = hand.GrabObjectHeld;
		if ((bool)grabObjectHeld)
		{
			if (portalVariationSet.HasValue && grabObjectHeld.portalVariations.currentController != portalVariationSet.Value)
			{
				return;
			}
			Transform obj = grabObjectHeld.transform;
			Vector3 position = obj.position;
			Quaternion rotation = obj.rotation;
			Vector3 extents = grabObjectHeld.combindedBounds.extents;
			if (Physics.OverlapBoxNonAlloc(position, extents, overlapResults, rotation, 1048576) > 0)
			{
				Hand.UngrabObject(grabObjectHeld);
				Vector3 lhs = grabObjectHeld.transform.position - overlapResults[0].transform.position;
				bool flag = Vector3.Dot(lhs, overlapResults[0].transform.forward) > 0f;
				lhs = overlapResults[0].transform.forward * (flag ? 0.1f : (-0.1f));
				grabObjectHeld.transform.position += lhs;
			}
		}
		for (int i = 0; i < overlapResults.Length; i++)
		{
			overlapResults[i] = null;
		}
	}

	public void OnPostPhysicsUpdateLR(MRBase owner)
	{
		UpdateHandGrab(CC.Inst.handL);
		UpdateHandGrab(CC.Inst.handR);
		Vector3 position = xformData.position;
		Vector3 forward = xformData.forward;
		_ = xformData.xform.localScale;
		ConstArray<InteractableObject> interactableObjects = owner.interactableObjects;
		uint length = interactableObjects.Length;
		for (int i = 0; i < length; i++)
		{
			InteractableObject interactableObject = interactableObjects._data[i];
			if (interactableObject.GetType() != typeof(GrabObject))
			{
				continue;
			}
			GrabObject grabObject = (GrabObject)interactableObject;
			Transform transform = grabObject.transform;
			Vector3 position2 = grabObject.GetLastState().position;
			Vector3 position3 = transform.position;
			if (grabObject.GetLastPhysicsState().position == position3 || grabObject.pr.wentThroughPortalLastFrame || (portalVariationSet.HasValue && grabObject.portalVariations.currentController != portalVariationSet.Value))
			{
				continue;
			}
			float num = Mathf.Sign(Vector3.Dot(position2 - position, forward));
			float num2 = Mathf.Sign(Vector3.Dot(position3 - position, forward));
			if (num == num2)
			{
				continue;
			}
			Vector3 vector = forward * num;
			Vector3 normalized = (position3 - position2).normalized;
			Plane plane = new Plane(vector, position);
			Vector3 position4 = position2;
			float num3 = Vector3.Dot(plane.normal, normalized);
			if (Mathf.Abs(num3) > 0.0001f)
			{
				float num4 = 0f - Vector3.Dot(position2, plane.normal) - plane.distance;
				position4 = position2 + normalized * (num4 / num3);
			}
			Vector3 vector2 = xformData.xform.InverseTransformPoint(position4);
			if (!(vector2.x > maxBounds.x) && !(vector2.x < minBounds.x) && !(vector2.y > maxBounds.y) && !(vector2.y < minBounds.y))
			{
				if (CC.Inst.IsObjectGrabbed(grabObject))
				{
					Hand.UngrabObject(grabObject);
				}
				float num5 = Vector3.Dot(plane.normal, position3 - plane.normal * (0f - plane.distance));
				Vector3 worldPos = position3 - num5 * plane.normal + plane.normal * 0.01f;
				grabObject.pr.SetPositionAndRotation(worldPos, transform.rotation);
				float num6 = 0f;
				float num7 = 1f + num6;
				Vector3 velocityLinear = grabObject.pr.GetVelocityLinear();
				Vector3 vector3 = -vector * Vector3.Dot(vector, velocityLinear) * num7;
				grabObject.pr.SetVelocityLinear(velocityLinear + vector3);
			}
		}
	}

	void PortalVariations.IUseVariantSet.SetPortalVariant(PortalVariations portalVariation)
	{
	}

	void PortalVariations.IUseVariantSet.OnVariantSetChanged(PortalVariations.VariantSet newSet)
	{
		portalVariationSet = newSet;
	}
}
public class FrustumDetector : IDObject
{
	public enum Type
	{
		Rect,
		Circle
	}

	public float depth;

	public Type type;

	public Vector2 extents = new Vector2(1f, 1f);

	public bool targetFacesPlayer;

	[SerializeField]
	private bool oneSided;

	public float logicRadius = 100f;

	private float logicRadiusSqr = 10000f;

	public IDObjectRef linkId;

	private bool canTrigger = true;

	private bool isInside;

	private FrustumDetector _linkFrustumDetector;

	private IFrustumEvent[] frustumEvents;

	private HagletValue<bool> inside;

	private HagletValue<bool> inView;

	private FMOD.Studio.EventInstance sfxInst;

	private IHaglet triggerDelayRoutine;

	private PlayerEntryPoint Link => linkId.GetOrNull<PlayerEntryPoint>(base.gameObject);

	private FrustumDetector linkFrustumDetector
	{
		get
		{
			if ((bool)_linkFrustumDetector)
			{
				return _linkFrustumDetector;
			}
			PlayerEntryPoint link = Link;
			if ((bool)link)
			{
				_linkFrustumDetector = link.GetComponent<FrustumDetector>();
				return _linkFrustumDetector;
			}
			return null;
		}
	}

	public Wait OnInside => Wait.Until.True(inside);

	public Wait OnNotInView => Wait.Until.False(inView);

	public Wait OnInView => Wait.Until.True(inView);

	public Wait IsInView => Wait.Until.True(inView, 1, allowPreMetNow: true);

	public Wait IsNotInView => Wait.Until.False(inView, 1, allowPreMetNow: true);

	public bool IsInViewBool => inView.value;

	public bool IsNotInViewBool => !inView.value;

	public override void OnDestroy()
	{
		base.OnDestroy();
		if (triggerDelayRoutine != null)
		{
			triggerDelayRoutine.Stop();
		}
	}

	public override void OnAwakeLR(MRBase owner)
	{
		base.OnAwakeLR(owner);
		HagletValue.Create(out inside, null, initVal: false, null, 8);
		HagletValue.Create(out inView, null, initVal: false, null, 8);
		Haglet.Create(out triggerDelayRoutine, TriggerDelayRoutine, null, startNow: false, null, "Frustum");
		frustumEvents = GetComponentsInChildren<IFrustumEvent>(includeInactive: true);
		for (int i = 0; i < frustumEvents.Length; i++)
		{
			frustumEvents[i].OnAwakeLR();
		}
	}

	public void OnUpdateLR()
	{
		Vector3 headPosition = IC.GetHeadPosition();
		Quaternion headRotation = IC.GetHeadRotation();
		Camera cameraComp = MainCamera.Inst.cameraComp;
		Transform obj = base.transform;
		Vector3 position = obj.position;
		Quaternion rotation = obj.rotation;
		Vector3 up = obj.up;
		Vector3 right = obj.right;
		_ = obj.forward;
		if (!base.isActiveAndEnabled)
		{
			HagletValue<bool> hagletValue = inside;
			bool value = (inView.value = false);
			hagletValue.value = value;
			return;
		}
		float proximity = 0f;
		if (inside.value)
		{
			bool flag2 = IsInsideDepth(headPosition) || CheckFrustumContained(cameraComp, headPosition, headRotation, out proximity);
			if (isInside != flag2)
			{
				bool value = (inside.value = flag2);
				isInside = value;
			}
		}
		else
		{
			bool flag4 = CheckFrustumContained(cameraComp, headPosition, headRotation, out proximity);
			if (isInside != flag4)
			{
				bool value = (inside.value = flag4);
				isInside = value;
			}
		}
		if (proximity > 0f)
		{
			if (!sfxInst.isValid() && IDObjectRef.IsValid(linkId))
			{
				sfxInst = FAC.Inst.PlayOneShot(BaseSettings<FrustumSettings>.Inst.sfxUpdateFeedback.Value, position);
			}
			sfxInst.setParameterValue("Proximity", proximity);
		}
		else if (sfxInst.isValid())
		{
			sfxInst.stop(STOP_MODE.ALLOWFADEOUT);
		}
		PlayerEntryPoint link = Link;
		if ((bool)link && canTrigger && isInside)
		{
			if (linkFrustumDetector != null)
			{
				linkFrustumDetector.DelayTriggerUntilNotInside();
			}
			Vector3 localPosition = base.transform.InverseTransformPointUnscaled(CC.Inst.transform.position);
			Vector3 vector = link.transform.TransformPointUnscaled(localPosition);
			Quaternion quaternion = (targetFacesPlayer ? Quaternion.identity : Quaternion.Euler(0f, 180f, 0f));
			Quaternion quaternion2 = Quaternion.Inverse(rotation) * CC.Inst.transform.rotation;
			Quaternion quaternion3 = link.transform.rotation * quaternion * quaternion2;
			for (int i = 0; i < frustumEvents.Length; i++)
			{
				frustumEvents[i].OnPreFrustum();
			}
			CC.Inst.PositionReplace(vector, quaternion3, default(CC.TeleportInfo), fadeCamera: false, forceUpdateLastState: true, MovementType: false, CC.MovementType.Frustum, fadeInTime: 0f, fadeOutTime: 0f, fadeDelayTime: 0f, fadeColor: Color.clear);
			CC.Inst.SetRegion(link.telepadRegion);
			FAC.Inst.PlayOneShot(BaseSettings<FrustumSettings>.Inst.sfxCompletionFeedback.Value, link.transform.position);
			NexusFullScreenPass.Inst.ForceUpdateLastValidPosition();
			link.OnPlayerEnter();
			for (int j = 0; j < frustumEvents.Length; j++)
			{
				frustumEvents[j].OnPostFrustum();
			}
		}
		inView.value = InsideLogicRadius(headPosition, position, logicRadiusSqr) && FrustumQuadIntersect(position, right, up, extents, CC.Inst.frustumPlanes);
	}

	public bool IsInsideDepth(Vector3 position)
	{
		if (type == Type.Circle)
		{
			Vector3 v = base.transform.InverseTransformPoint(position);
			if (v.xy().magnitude > extents.x)
			{
				return false;
			}
			if (v.z < 0f - depth || v.z > 0f)
			{
				return false;
			}
			return true;
		}
		if (type == Type.Rect)
		{
			Vector3 vector = base.transform.InverseTransformPoint(position);
			if (Mathf.Abs(vector.x) > extents.x)
			{
				return false;
			}
			if (Mathf.Abs(vector.y) > extents.y)
			{
				return false;
			}
			if (vector.z < 0f - depth || vector.z > 0f)
			{
				return false;
			}
			return true;
		}
		return false;
	}

	private void DelayTriggerUntilNotInside()
	{
		triggerDelayRoutine.Start();
	}

	private IEnumerator<Routine.Yield> TriggerDelayRoutine()
	{
		canTrigger = false;
		yield return Wait.For.LRUpdates(1);
		do
		{
			yield return Wait.For.LRUpdates(1);
		}
		while (isInside || inView.value);
		canTrigger = true;
	}

	private static bool InsideLogicRadius(Vector3 headWorldPos, Vector3 detectorPos, float logicRadiusSqr)
	{
		return (headWorldPos - detectorPos).sqrMagnitude < logicRadiusSqr;
	}

	private static bool FrustumQuadIntersect(Vector3 quadPos, Vector3 quadAxisX, Vector3 quadAxisY, Vector2 quadExtents, Plane[] frustumPlanes)
	{
		for (int i = 0; i < 6; i++)
		{
			Plane plane = frustumPlanes[i];
			Vector3 normal = plane.normal;
			float num = Mathf.Sign(Vector3.Dot(quadAxisX, normal)) * (0f - quadExtents.x);
			float num2 = Mathf.Sign(Vector3.Dot(quadAxisY, normal)) * (0f - quadExtents.y);
			Vector3 vector = num * quadAxisX + num2 * quadAxisY;
			if (Vector3.Dot(quadPos - vector, normal) + plane.distance < 0f)
			{
				return false;
			}
		}
		return true;
	}

	private static Ray GetNDCPointToRay(Vector3 origin, Quaternion originRotation, Matrix4x4 projectionMatrixInv, Vector3 rayInNDC)
	{
		Ray result = default(Ray);
		result.origin = origin;
		Vector3 vector = projectionMatrixInv.MultiplyVector(rayInNDC);
		vector.z = 1f;
		result.direction = originRotation * vector;
		return result;
	}

	private bool CheckFrustumContained(Camera camera, Vector3 headWorldPos, Quaternion headWorldRotation, out float proximity)
	{
		proximity = 0f;
		Transform transform = base.transform;
		Vector3 position = transform.position;
		Vector3 forward = transform.forward;
		if (oneSided)
		{
			Vector3 normalized = (headWorldPos - position).normalized;
			if (Vector3.Dot(forward, normalized) < 0f)
			{
				return false;
			}
		}
		Plane plane = default(Plane);
		plane.normal = forward;
		plane.distance = 0f - Vector3.Dot(forward, position);
		if (!InsideLogicRadius(headWorldPos, position, logicRadiusSqr))
		{
			return false;
		}
		Matrix4x4 inverse = camera.projectionMatrix.inverse;
		Ray nDCPointToRay = GetNDCPointToRay(headWorldPos, headWorldRotation, inverse, Vector3X.LDB);
		Ray nDCPointToRay2 = GetNDCPointToRay(headWorldPos, headWorldRotation, inverse, Vector3X.LUB);
		Ray nDCPointToRay3 = GetNDCPointToRay(headWorldPos, headWorldRotation, inverse, Vector3X.RUB);
		Ray nDCPointToRay4 = GetNDCPointToRay(headWorldPos, headWorldRotation, inverse, Vector3X.RDB);
		proximity = Mathf.Clamp01(MathfX.Percent(BaseSettings<FrustumSettings>.Inst.sfxRange, 0f, Vector3.Distance(position, headWorldPos)));
		float enter = 0f;
		if (!plane.Raycast(nDCPointToRay, out enter))
		{
			return false;
		}
		Vector2 a = transform.InverseTransformPoint(nDCPointToRay.origin + nDCPointToRay.direction * enter).xy();
		if (!plane.Raycast(nDCPointToRay2, out enter))
		{
			return false;
		}
		Vector2 a2 = transform.InverseTransformPoint(nDCPointToRay2.origin + nDCPointToRay2.direction * enter).xy();
		if (!plane.Raycast(nDCPointToRay3, out enter))
		{
			return false;
		}
		Vector2 a3 = transform.InverseTransformPoint(nDCPointToRay3.origin + nDCPointToRay3.direction * enter).xy();
		if (!plane.Raycast(nDCPointToRay4, out enter))
		{
			return false;
		}
		Vector2 b = transform.InverseTransformPoint(nDCPointToRay4.origin + nDCPointToRay4.direction * enter).xy();
		switch (type)
		{
		case Type.Rect:
		{
			Vector2 vector = VectorX.Min(a, VectorX.Min(a2, VectorX.Min(a3, b)));
			Vector2 vector2 = VectorX.Max(a, VectorX.Max(a2, VectorX.Max(a3, b)));
			if (proximity > Mathf.Epsilon)
			{
				float num2 = Mathf.Min(1f + (extents.x + vector.x), 1f);
				float num3 = Mathf.Min(1f + (extents.x - vector2.x), 1f);
				float num4 = Mathf.Min(1f + (extents.y + vector.y), 1f);
				float num5 = Mathf.Min(1f + (extents.y - vector2.y), 1f);
				float a4 = Mathf.Clamp01((num2 + num3 + num4 + num5) / 4f);
				proximity = Mathf.Max(a4, proximity);
			}
			if (vector.x < 0f - extents.x)
			{
				return false;
			}
			if (vector.y < 0f - extents.y)
			{
				return false;
			}
			if (vector2.x > extents.x)
			{
				return false;
			}
			if (vector2.y > extents.y)
			{
				return false;
			}
			break;
		}
		case Type.Circle:
		{
			float num = extents.x * extents.x;
			if (a.sqrMagnitude > num)
			{
				return false;
			}
			if (a2.sqrMagnitude > num)
			{
				return false;
			}
			if (a3.sqrMagnitude > num)
			{
				return false;
			}
			if (b.sqrMagnitude > num)
			{
				return false;
			}
			break;
		}
		}
		return true;
	}
}
public class FrustumDetector3D : MonoBehaviour
{
	public enum Type
	{
		Box,
		Sphere
	}

	public Type type;

	public Vector3 extents = new Vector3(1f, 1f, 1f);

	public Vector3 extentsCenter = new Vector3(0f, 0f, 0f);

	public float logicRadius = 100f;

	private HagletValue<bool> inView;

	private HagletValue<bool> completelyInView;

	private bool ignoreFirstFrame = true;

	public Wait OnInView => Wait.Until.True(inView);

	public Wait IsInView => Wait.Until.True(inView, 1, allowPreMetNow: true);

	public bool IsInViewBool => inView.value;

	public Wait OnNotInView => Wait.Until.False(inView);

	public Wait IsNotInView => Wait.Until.False(inView, 1, allowPreMetNow: true);

	public bool IsNotInViewBool => !inView.value;

	public Wait OnCompletelyInView => Wait.Until.True(completelyInView);

	public Wait IsCompletelyInView => Wait.Until.True(completelyInView, 1, allowPreMetNow: true);

	public bool IsCompletelyInViewBool => completelyInView.value;

	public void OnAwakeLR()
	{
		HagletValue.Create(out inView, null, initVal: false, null, 8);
		HagletValue.Create(out completelyInView, null, initVal: false, null, 8);
	}

	public void OnUpdateLR()
	{
		if (ignoreFirstFrame)
		{
			ignoreFirstFrame = false;
			return;
		}
		if (!InsideLogicRadius())
		{
			inView.value = false;
			return;
		}
		switch (type)
		{
		case Type.Box:
			CheckFrustumBox(base.transform.TransformPoint(extentsCenter), base.transform.right, base.transform.up, base.transform.forward, extents, CC.Inst.frustumPlanes);
			break;
		case Type.Sphere:
			CheckFrustumSphere(base.transform.TransformPoint(extentsCenter), extents.x, CC.Inst.frustumPlanes);
			break;
		}
	}

	private bool InsideLogicRadius()
	{
		return Vector3.Distance(IC.GetHeadPosition(), base.transform.TransformPoint(extentsCenter)) < logicRadius;
	}

	public void CheckFrustumBox(Vector3 boxPos, Vector3 boxAxisX, Vector3 boxAxisY, Vector3 boxAxisZ, Vector3 boxExtents, Plane[] frustumPlanes)
	{
		bool value = true;
		bool flag = true;
		for (int i = 0; i < 6; i++)
		{
			Plane plane = frustumPlanes[i];
			Vector3 normal = plane.normal;
			float distance = plane.distance;
			float num = Mathf.Sign(Vector3.Dot(boxAxisX, normal)) * (0f - boxExtents.x);
			float num2 = Mathf.Sign(Vector3.Dot(boxAxisY, normal)) * (0f - boxExtents.y);
			float num3 = Mathf.Sign(Vector3.Dot(boxAxisZ, normal)) * (0f - boxExtents.z);
			Vector3 vector = num * boxAxisX + num2 * boxAxisY + num3 * boxAxisZ;
			Vector3 lhs = boxPos - vector;
			Vector3 lhs2 = boxPos + vector;
			if (Vector3.Dot(lhs, normal) + distance < 0f)
			{
				value = false;
			}
			flag &= Vector3.Dot(lhs2, normal) + distance > 0f;
		}
		inView.value = value;
		completelyInView.value = flag;
	}

	public void CheckFrustumSphere(Vector3 spherePos, float sphereRadius, Plane[] frustumPlanes)
	{
		bool value = true;
		bool flag = true;
		for (int i = 0; i < 6; i++)
		{
			Plane plane = frustumPlanes[i];
			Vector3 normal = plane.normal;
			float distance = plane.distance;
			if (Vector3.Dot(spherePos, normal) + distance < 0f - sphereRadius)
			{
				value = false;
			}
			flag &= Vector3.Dot(spherePos, normal) + distance > sphereRadius;
		}
		inView.value = value;
		completelyInView.value = flag;
	}
}
public class FrustumObject : IDObject, ICutsceneEvent
{
	private enum FrustumState
	{
		WAITING_FOR_LOOK_AT,
		WAITING_FOR_LOOK_AWAY,
		WAITING_FOR_UPDATE
	}

	public IDObjectRef[] stateRefs;

	public HagletTrigger OnStateChange;

	public bool isEnvironmental;

	[NonSerialized]
	public ConstArray<FrustumObjectState> states;

	private FrustumState frustumState;

	private int stateIndex;

	private bool isWaitingForCutscene;

	public FrustumObjectState GetCurrentState => states[stateIndex];

	public override void OnAwakeLR(MRBase owner)
	{
		base.OnAwakeLR(owner);
		OnStateChange = new HagletTrigger();
		states = new ConstArray<FrustumObjectState>(4u);
		for (int i = 0; i < stateRefs.Length; i++)
		{
			FrustumObjectState component = stateRefs[i].GetComponent<FrustumObjectState>(this);
			if (component != null)
			{
				component.OnAwakeLR();
				states.Add(component);
			}
		}
		frustumState = FrustumState.WAITING_FOR_LOOK_AT;
	}

	public void ResetState()
	{
		stateIndex = 0;
		frustumState = FrustumState.WAITING_FOR_LOOK_AT;
	}

	public void OnUpdateLR()
	{
		if (base.enabled)
		{
			if (states.Length > 1)
			{
				UpdateMultiState();
			}
			else if (states.Length != 0)
			{
				UpdateSingleState();
			}
		}
	}

	private void UpdateSingleState()
	{
		FrustumObjectState frustumObjectState = states[stateIndex];
		frustumObjectState.OnUpdateLR();
		if (frustumState == FrustumState.WAITING_FOR_LOOK_AT)
		{
			if (frustumObjectState.IsInView)
			{
				frustumState = FrustumState.WAITING_FOR_LOOK_AWAY;
			}
		}
		else if (frustumState == FrustumState.WAITING_FOR_LOOK_AWAY)
		{
			if (!frustumObjectState.IsInView)
			{
				if (BaseSettings<FrustumSettings>.Inst.playSfxOnLookAway)
				{
					PlaySFX(frustumObjectState.transform.position);
				}
				frustumState = FrustumState.WAITING_FOR_UPDATE;
			}
		}
		else if (frustumState == FrustumState.WAITING_FOR_UPDATE && frustumObjectState.IsInView)
		{
			frustumState = FrustumState.WAITING_FOR_LOOK_AT;
			OnStateChange.Trigger();
			if (BaseSettings<FrustumSettings>.Inst.playSfxOnLookAt)
			{
				PlaySFX(frustumObjectState.transform.position);
			}
			if (BaseSettings<FrustumSettings>.Inst.playParticlesOnLookAt)
			{
				PlayParticles(frustumObjectState);
			}
		}
	}

	private void UpdateMultiState()
	{
		int key = (int)((stateIndex + 1) % states.Length);
		FrustumObjectState frustumObjectState = states[stateIndex];
		FrustumObjectState frustumObjectState2 = states[key];
		frustumObjectState.OnUpdateLR();
		frustumObjectState2.OnUpdateLR();
		if (frustumState == FrustumState.WAITING_FOR_LOOK_AT)
		{
			if (frustumObjectState.IsInView)
			{
				frustumState = FrustumState.WAITING_FOR_LOOK_AWAY;
			}
		}
		else if (frustumState == FrustumState.WAITING_FOR_LOOK_AWAY)
		{
			if (!frustumObjectState.IsInView && !frustumObjectState2.IsInView)
			{
				if (BaseSettings<FrustumSettings>.Inst.playSfxOnLookAway)
				{
					PlaySFX(frustumObjectState2.transform.position);
				}
				frustumState = FrustumState.WAITING_FOR_UPDATE;
			}
		}
		else if (frustumState == FrustumState.WAITING_FOR_UPDATE && (frustumObjectState.IsInView || frustumObjectState2.IsInView))
		{
			frustumState = FrustumState.WAITING_FOR_LOOK_AT;
			stateIndex = key;
			OnStateChange.Trigger();
			if (BaseSettings<FrustumSettings>.Inst.playSfxOnLookAt)
			{
				PlaySFX(frustumObjectState2.transform.position);
			}
			if (BaseSettings<FrustumSettings>.Inst.playParticlesOnLookAt)
			{
				PlayParticles(frustumObjectState2);
			}
		}
	}

	private void PlayParticles(FrustumObjectState state)
	{
		Transform parent = base.transform;
		Vector3 worldPostion = state.transform.position + state.transform.rotation * state.particleEmissionCenter;
		ParticleSystem[] componentsInChildren = PSC.Inst.Get(ParticleType.FrustumParticles, worldPostion, parent).GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		foreach (ParticleSystem obj in componentsInChildren)
		{
			ParticleSystem.ShapeModule shape = obj.shape;
			shape.radius = state.particleEmissionRadius;
			obj.Play();
		}
	}

	private void PlaySFX(Vector3 worldPosition)
	{
		if (!isWaitingForCutscene && !isEnvironmental)
		{
			FAC.Inst.PlayOneShot(BaseSettings<FrustumSettings>.Inst.sfxFrustumObjectChange.Value, worldPosition);
		}
	}

	void ICutsceneEvent.OnCutsceneBegin()
	{
		isWaitingForCutscene = true;
	}

	void ICutsceneEvent.OnCutsceneEnd()
	{
		isWaitingForCutscene = false;
	}
}
public class FrustumObjectArea : MonoBehaviour
{
	public enum Type
	{
		Box,
		Sphere
	}

	public Type type;

	public Vector3 extents = new Vector3(1f, 1f, 1f);

	public Vector3 extentsCenter = new Vector3(0f, 0f, 0f);

	private HagletValue<bool> inView;

	public bool IsInView => inView.value;

	public void OnAwakeLR()
	{
		HagletValue.Create(out inView, null, initVal: false, null, 8);
	}

	public void OnUpdateLR()
	{
		inView.value = CheckFrustum() && CheckLineOfSight();
	}

	private bool CheckFrustum()
	{
		Vector3 vector = base.transform.TransformPoint(extentsCenter);
		Vector3 right = base.transform.right;
		Vector3 up = base.transform.up;
		Vector3 forward = base.transform.forward;
		Plane[] frustumPlanes = (IsInView ? CC.Inst.extendedFrustumPlanes : CC.Inst.frustumPlanes);
		return type switch
		{
			Type.Box => CheckFrustumBox(vector, right, up, forward, extents, frustumPlanes), 
			Type.Sphere => CheckFrustumSphere(vector, extents.x, frustumPlanes), 
			_ => false, 
		};
	}

	private bool CheckLineOfSight()
	{
		if (!CheckLineOfSight(base.transform.TransformPoint(extentsCenter)) && !CheckLineOfSight(base.transform.TransformPoint(extentsCenter.x + extents.x, extentsCenter.y + extents.y, extentsCenter.z - extents.z)) && !CheckLineOfSight(base.transform.TransformPoint(extentsCenter.x - extents.x, extentsCenter.y + extents.y, extentsCenter.z - extents.z)) && !CheckLineOfSight(base.transform.TransformPoint(extentsCenter.x + extents.x, extentsCenter.y + extents.y, extentsCenter.z + extents.z)) && !CheckLineOfSight(base.transform.TransformPoint(extentsCenter.x - extents.x, extentsCenter.y + extents.y, extentsCenter.z + extents.z)) && !CheckLineOfSight(base.transform.TransformPoint(extentsCenter.x + extents.x, extentsCenter.y - extents.y, extentsCenter.z - extents.z)) && !CheckLineOfSight(base.transform.TransformPoint(extentsCenter.x - extents.x, extentsCenter.y - extents.y, extentsCenter.z + extents.z)) && !CheckLineOfSight(base.transform.TransformPoint(extentsCenter.x + extents.x, extentsCenter.y - extents.y, extentsCenter.z - extents.z)))
		{
			return CheckLineOfSight(base.transform.TransformPoint(extentsCenter.x - extents.x, extentsCenter.y - extents.y, extentsCenter.z + extents.z));
		}
		return true;
	}

	private bool CheckLineOfSight(Vector3 worldPos)
	{
		Vector3 headPosition = IC.GetHeadPosition();
		Vector3 vector = worldPos - headPosition;
		Vector3 normalized = vector.normalized;
		float magnitude = vector.magnitude;
		RaycastHit hitInfo;
		return !Physics.Raycast(new Ray(headPosition, normalized), out hitInfo, magnitude, -1572897);
	}

	private bool CheckFrustumBox(Vector3 boxPos, Vector3 boxAxisX, Vector3 boxAxisY, Vector3 boxAxisZ, Vector3 boxExtents, Plane[] frustumPlanes)
	{
		for (int i = 0; i < 6; i++)
		{
			Plane plane = frustumPlanes[i];
			Vector3 normal = plane.normal;
			float distance = plane.distance;
			float num = Mathf.Sign(Vector3.Dot(boxAxisX, normal)) * (0f - boxExtents.x);
			float num2 = Mathf.Sign(Vector3.Dot(boxAxisY, normal)) * (0f - boxExtents.y);
			float num3 = Mathf.Sign(Vector3.Dot(boxAxisZ, normal)) * (0f - boxExtents.z);
			Vector3 vector = num * boxAxisX + num2 * boxAxisY + num3 * boxAxisZ;
			Vector3 lhs = boxPos - vector;
			_ = boxPos + vector;
			if (Vector3.Dot(lhs, normal) + distance < 0f)
			{
				return false;
			}
		}
		return true;
	}

	private bool CheckFrustumSphere(Vector3 spherePos, float sphereRadius, Plane[] frustumPlanes)
	{
		for (int i = 0; i < 6; i++)
		{
			Plane plane = frustumPlanes[i];
			Vector3 normal = plane.normal;
			float distance = plane.distance;
			if (Vector3.Dot(spherePos, normal) + distance < 0f - sphereRadius)
			{
				return false;
			}
		}
		return true;
	}
}
public class FrustumObjectState : MonoBehaviour
{
	public float particleEmissionRadius = 1f;

	public Vector3 particleEmissionCenter = Vector3.zero;

	private FrustumObjectArea[] detectionAreas;

	private HagletValue<bool> inView;

	public bool IsInView => inView.value;

	public void OnAwakeLR()
	{
		HagletValue.Create(out inView, null, initVal: false, null, 8);
		detectionAreas = GetComponentsInChildren<FrustumObjectArea>();
		FrustumObjectArea[] array = detectionAreas;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].OnAwakeLR();
		}
	}

	public void OnUpdateLR()
	{
		bool flag = false;
		FrustumObjectArea[] array = detectionAreas;
		foreach (FrustumObjectArea frustumObjectArea in array)
		{
			frustumObjectArea.OnUpdateLR();
			flag |= frustumObjectArea.IsInView;
		}
		inView.value = flag;
	}
}
public interface IFrustumEvent
{
	void OnAwakeLR();

	void OnPreFrustum();

	void OnPostFrustum();
}
public class IDObjectContainer
{
	public GameObject owner;

	public Dictionary<string, IDObject> idObjects = new Dictionary<string, IDObject>();
}
[Serializer.ExcludeAllFields]
public class IDObject : MonoBehaviour, IOwnerChangeListener, ISceneUnloadEvent
{
	[ReadOnly]
	[Serializer.IncludeField]
	public string id = "error";

	[ReadOnly]
	public MRBase owner;

	public virtual void OnAwakeLR(MRBase owner)
	{
		this.owner = owner;
	}

	public virtual void OnSceneUnload()
	{
		LR.Inst.DeregisterId(this);
	}

	public virtual void OnDestroy()
	{
		LR.Inst?.DeregisterId(this);
	}

	public virtual void OnOwnerChange(MRBase _oldOwner, MRBase _newOwner)
	{
		owner = _newOwner;
	}

	private SceneInfo LoadSceneInfo()
	{
		MRBase mRBase = GetRootBaseForIDObject(this) as MRBase;
		if (!mRBase)
		{
			return null;
		}
		SceneInfo sceneInfo = mRBase.info.TryLoad();
		if (!sceneInfo)
		{
			UnityEngine.Debug.LogError("ID for '" + base.gameObject.name + "' cannot be generated because the scene does not have a valid 'sceneinfo'", this);
			return null;
		}
		return sceneInfo;
	}

	public static bool IsValidID(IDObject idObj)
	{
		return true;
	}

	public static bool IsValidID(string id, GameObject objectInScene)
	{
		return true;
	}

	public static List<GameObject> GetDuplicateIDObjects(string id)
	{
		IDObject[] array = UnityEngine.Object.FindObjectsOfType<IDObject>();
		GrabObjectSpawnPoint[] array2 = UnityEngine.Object.FindObjectsOfType<GrabObjectSpawnPoint>();
		List<GameObject> list = new List<GameObject>();
		IDObject[] array3 = array;
		foreach (IDObject iDObject in array3)
		{
			if (iDObject.id == id)
			{
				list.Add(iDObject.gameObject);
			}
		}
		GrabObjectSpawnPoint[] array4 = array2;
		foreach (GrabObjectSpawnPoint grabObjectSpawnPoint in array4)
		{
			if ((bool)grabObjectSpawnPoint.prefabAsset)
			{
				GrabObject component = grabObjectSpawnPoint.prefabAsset.GetComponent<GrabObject>();
				if ((bool)component && component.id == id)
				{
					list.Add(grabObjectSpawnPoint.gameObject);
					break;
				}
			}
		}
		return list;
	}

	public static RootBase GetRootBaseForIDObject(IDObject idObj)
	{
		return idObj.GetComponentInAscendant<RootBase>();
	}

	public static T GetIDObject<T>(Dictionary<string, IDObject> dict, string id, UnityEngine.Object context = null) where T : IDObject
	{
		if (!dict.TryGetValue(id, out var value))
		{
			return null;
		}
		return (T)value;
	}

	public static bool TryGetIDObject<T>(Dictionary<string, IDObject> dict, string id, out T value, UnityEngine.Object context = null) where T : IDObject
	{
		if (!dict.TryGetValue(id, out var value2))
		{
			value = null;
			return false;
		}
		value = (T)value2;
		return true;
	}

	protected virtual void OnValidate()
	{
	}
}
[Serializable]
public class IDObjectRef
{
	public struct CachedTypeInfo
	{
		public FieldInfo[] fields;
	}

	public string id;

	[NonSerialized]
	[Serializer.Exclude]
	public IDObject obj;

	[NonSerialized]
	public MonoBehaviour monoBehaviour;

	private static Dictionary<Type, CachedTypeInfo> dictTypeToInfo;

	public override string ToString()
	{
		return id;
	}

	public bool IsRefLoaded()
	{
		if (string.IsNullOrEmpty(id))
		{
			return false;
		}
		IDObject value;
		return LR.Inst.TryGetIDObject<IDObject>(id, out value);
	}

	public bool IsRefLoadedAndAwake()
	{
		if (string.IsNullOrEmpty(id))
		{
			return false;
		}
		if (LR.Inst.TryGetIDObject<IDObject>(id, out var value) && (bool)value.owner)
		{
			return value.owner.isAwake;
		}
		return false;
	}

	public T Get<T>(UnityEngine.Object context = null) where T : IDObject
	{
		if (obj == null)
		{
			obj = LR.Inst.GetIDObject<T>(this, context);
		}
		return (T)obj;
	}

	public T GetOrNull<T>(UnityEngine.Object context = null) where T : IDObject
	{
		if (!TryGet<T>(out var value, context))
		{
			return null;
		}
		return value;
	}

	public bool TryGet<T>(out T value, UnityEngine.Object context = null) where T : IDObject
	{
		if (obj == null && !LR.Inst.TryGetIDObject<IDObject>(this, out obj, context))
		{
			value = null;
			return false;
		}
		value = (T)obj;
		return true;
	}

	public T GetComponent<T>(UnityEngine.Object context = null) where T : class
	{
		if (obj == null)
		{
			obj = Get<IDObject>(context);
		}
		if (obj == null)
		{
			return null;
		}
		return obj.GetComponent<T>();
	}

	public T GetComponentInChildren<T>(UnityEngine.Object context = null, bool disabled = false) where T : class
	{
		if (obj == null)
		{
			obj = Get<IDObject>(context);
		}
		if (obj == null)
		{
			return null;
		}
		return obj.GetComponentInChildren<T>(disabled);
	}

	public bool TryGetComponent<T>(out T value, UnityEngine.Object context = null) where T : class
	{
		if (obj == null && !TryGet<IDObject>(out obj, context))
		{
			value = null;
			return false;
		}
		value = obj.GetComponent<T>();
		return true;
	}

	public static bool IsInitialized()
	{
		return dictTypeToInfo != null;
	}

	public static void Initialize()
	{
		dictTypeToInfo = new Dictionary<Type, CachedTypeInfo>();
		Type[] types = typeof(IDObjectRef).Assembly.GetTypes();
		foreach (Type type in types)
		{
			CachedTypeInfo value = default(CachedTypeInfo);
			value.fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			List<FieldInfo> list = new List<FieldInfo>(value.fields.Length);
			FieldInfo[] fields = value.fields;
			foreach (FieldInfo fieldInfo in fields)
			{
				object[] customAttributes = fieldInfo.GetCustomAttributes(inherit: true);
				bool flag = (fieldInfo.Attributes & FieldAttributes.Public) != 0;
				Type fieldType = fieldInfo.FieldType;
				object[] customAttributes2 = fieldType.GetCustomAttributes(inherit: false);
				bool flag2 = fieldType.IsTypeOrSubType(typeof(ScriptableObject));
				object[] array = customAttributes;
				foreach (object obj in array)
				{
					if (obj.IsOfTypeOrSubType(typeof(SerializeField)))
					{
						flag = true;
					}
					else if (obj.IsOfTypeOrSubType(typeof(NonSerializedAttribute)))
					{
						flag = false;
					}
				}
				array = customAttributes2;
				for (int k = 0; k < array.Length; k++)
				{
					if (array[k].IsOfTypeOrSubType(typeof(SerializableAttribute)))
					{
						flag2 = true;
					}
				}
				if (flag && flag2)
				{
					list.Add(fieldInfo);
				}
			}
			value.fields = list.ToArray();
			dictTypeToInfo.Add(type, value);
		}
	}

	public static bool IsValid(IDObjectRef objRef)
	{
		if (objRef == null || string.IsNullOrEmpty(objRef.id))
		{
			return false;
		}
		return true;
	}

	private static void _AddIDRef(IDObjectRef idObjRef, bool includeEmptyIDs, MonoBehaviour owner, ConstArray<IDObjectRef> outRefsToGather)
	{
		idObjRef.monoBehaviour = owner;
		if (!string.IsNullOrEmpty(idObjRef.id) || includeEmptyIDs)
		{
			outRefsToGather.Add(idObjRef);
		}
	}

	public static void GatherReferencesInObject(object obj, bool includeEmptyIDs, MonoBehaviour monoBehaviour, ConstArray<IDObjectRef> outRefsToGather, HashSet<object> visited, ConstArray<string> outRefNames = null)
	{
		if (!IsInitialized())
		{
			Initialize();
		}
		if (obj == null || !visited.Add(obj))
		{
			return;
		}
		Type type = obj.GetType();
		if (type.IsArray)
		{
			Array array = (Array)obj;
			Type elementType = type.GetElementType();
			if (elementType.IsTypeOrSubType(typeof(IDObjectRef)))
			{
				IDObjectRef[] obj2 = array as IDObjectRef[];
				int num = 0;
				IDObjectRef[] array2 = obj2;
				foreach (IDObjectRef iDObjectRef in array2)
				{
					if (iDObjectRef != null)
					{
						_AddIDRef(iDObjectRef, includeEmptyIDs, monoBehaviour, outRefsToGather);
						outRefNames?.Add("(Array)[" + num + "]");
						num++;
					}
				}
			}
			else
			{
				if (elementType.IsTypeOrSubType(typeof(MonoBehaviour)))
				{
					return;
				}
				foreach (object item in array)
				{
					GatherReferencesInObject(item, includeEmptyIDs, monoBehaviour, outRefsToGather, visited, outRefNames);
				}
			}
		}
		else
		{
			if (!dictTypeToInfo.TryGetValue(type, out var value))
			{
				return;
			}
			FieldInfo[] fields = value.fields;
			foreach (FieldInfo fieldInfo in fields)
			{
				Type fieldType = fieldInfo.FieldType;
				if (fieldType.IsTypeOrSubType(typeof(IDObjectRef)))
				{
					_AddIDRef((IDObjectRef)fieldInfo.GetValue(obj), includeEmptyIDs, monoBehaviour, outRefsToGather);
					outRefNames?.Add(fieldInfo.Name);
				}
				else if (!fieldType.IsTypeOrSubType(typeof(MonoBehaviour)))
				{
					GatherReferencesInObject(fieldInfo.GetValue(obj), includeEmptyIDs, monoBehaviour, outRefsToGather, visited, outRefNames);
				}
			}
		}
	}

	public static void GatherAllReferences(MRBase mrBase, ConstArray<IDObjectRef> outRefsToGather, bool includeEmptyIDs, ConstArray<string> outRefNames = null)
	{
		MonoBehaviour[] componentsInChildren = mrBase.GetComponentsInChildren<MonoBehaviour>(includeInactive: true);
		HashSet<object> visited = new HashSet<object>();
		foreach (MonoBehaviour monoBehaviour in componentsInChildren)
		{
			GatherReferencesInObject(monoBehaviour, includeEmptyIDs, monoBehaviour, outRefsToGather, visited, outRefNames);
		}
	}
}
public interface IAreaEvent
{
	void OnAreaEnter();

	void OnAreaExit();
}
public interface ICutsceneEvent
{
	void OnCutsceneBegin();

	void OnCutsceneEnd();
}
public interface IAwakeEvent
{
	void OnAwakeLR(MRBase owner);
}
public interface ILateAwakeEvent
{
	void OnLateAwakeLR();
}
public interface IUpdateEvent
{
	void OnUpdateLR();
}
public interface ILateUpdateEvent
{
	void OnLateUpdateLR();
}
public interface IPostPhysicsUpdateEvent
{
	void OnPostPhysicsUpdateLR();
}
public interface IPauseEvent
{
	void OnPauseLR(bool paused);
}
public interface IPauseUpdate
{
	void OnPauseUpdateLR();
}
public interface IRealtimeUpdate
{
	void OnRealtimeUpdateLR();
}
public interface IPrebuildEvent
{
	void OnPrebuildRoot(bool isPrefab);
}
public interface ISceneUnloadEvent
{
	void OnSceneUnload();
}
public class AnimationDriver : MonoBehaviour, IAwakeEvent
{
	[LabelOverride("Animation")]
	public Animation anim;

	[LabelOverride("Animation Name")]
	public string animName;

	private IHaglet<float> animationRoutine;

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		Haglet.Create(out animationRoutine, (Routine.Func1<float>)AnimationRoutine, (string)null, startNow: false, (int?)null, (string)null);
	}

	[Event(EventName = "Play Forward")]
	public void PlayForward(object sender)
	{
		animationRoutine.Start(anim[animName].length, resetIfStarted: true);
	}

	[Event(EventName = "Play Reverse")]
	public void PlayReverse(object sender)
	{
		animationRoutine.Start(0f, resetIfStarted: true);
	}

	private IEnumerator<Routine.Yield> AnimationRoutine(float targetTime)
	{
		AnimationState animState = anim[animName];
		float currTime = animState.time;
		float lastTime = currTime;
		while (currTime != targetTime && lastTime > targetTime == currTime > targetTime)
		{
			lastTime = currTime;
			float deltaTime = IC.DeltaTime;
			currTime += deltaTime * ((targetTime > currTime) ? 1f : (-1f));
			animState.enabled = true;
			animState.speed = 0f;
			animState.weight = 1f;
			animState.time = currTime;
			yield return Wait.For.LRUpdates(1);
		}
	}
}
public class BrokenObjectPart : MonoBehaviour, IDoNotClone
{
	private Vector3 localStartPos;

	private Quaternion localStartRot;

	private PortalingRigidbody objPR;

	private MeshRenderer meshRenderer;

	private MaterialPropertyBlock mpb;

	public PortalingRigidbody ObjPR => objPR;

	public void Initialise(Transform rootTransform)
	{
		localStartPos = rootTransform.InverseTransformPoint(base.transform.position);
		localStartRot = Quaternion.Inverse(rootTransform.rotation) * base.transform.rotation;
		objPR = base.gameObject.GetComponent<PortalingRigidbody>();
		meshRenderer = GetComponent<MeshRenderer>();
		mpb = new MaterialPropertyBlock();
	}

	public void BreakFromObject(Vector3 collisionVelocity, Quaternion objectRotation, float bounceForce, float outwardForce)
	{
		Vector3 vector = -collisionVelocity * bounceForce;
		Vector3 vector2 = objectRotation * (localStartPos.normalized * outwardForce);
		Vector3 velocityLinear = vector + vector2;
		objPR.SetVelocityLinear(velocityLinear);
	}

	public void ResetObjectPart(Transform rootTransform)
	{
		objPR.SetVelocityLinear(Vector3.zero);
		objPR.SetVelocityAngular(Vector3.zero);
		base.transform.position = rootTransform.TransformPoint(localStartPos);
		base.transform.rotation = localStartRot * rootTransform.rotation;
		meshRenderer.SetPropertyBlock(null);
	}

	public void SetFloatProperty(string propertyName, float value)
	{
		mpb.SetFloat(propertyName, value);
		meshRenderer.SetPropertyBlock(mpb);
	}

	public void SetVectorProperty(string propertyName, Vector4 value)
	{
		mpb.SetVector(propertyName, value);
		meshRenderer.SetPropertyBlock(mpb);
	}

	public Bounds GetRendererBounds()
	{
		return meshRenderer.bounds;
	}
}
public class Button : InteractableObject
{
	public Vector3 pushedPosition;

	private Vector3 originPosition;

	public Event onButtonDown;

	public Event onButtonUp;

	public Event onButtonHeld;

	private GameObject meshObject;

	private bool beingPushed;

	private IHaglet prepareEventRoutine;

	public override void OnAwakeLR(MRBase _owner)
	{
		base.OnAwakeLR(_owner);
		meshObject = GetComponentInChildren<MeshFilter>().gameObject;
		originPosition = meshObject.transform.localPosition;
		Haglet.Create(out prepareEventRoutine, PrepareEventRoutine);
	}

	public override Wait PrepareEvents()
	{
		return prepareEventRoutine.Start();
	}

	private IEnumerator<Routine.Yield> PrepareEventRoutine()
	{
		yield return base.PrepareEvents();
		yield return Wait.For.LRUpdates(1);
		onButtonDown.PrepareInvoke();
		yield return Wait.For.LRUpdates(1);
		onButtonUp.PrepareInvoke();
		yield return Wait.For.LRUpdates(1);
		onButtonHeld.PrepareInvoke();
	}

	protected override void OnUpdateLR(float deltaTime, InteractableObject handLHeld, InteractableObject handRHeld)
	{
		if (beingPushed)
		{
			meshObject.transform.localPosition = Vector3.Lerp(meshObject.transform.localPosition, pushedPosition, 0.2f);
		}
		else
		{
			meshObject.transform.localPosition = Vector3.Lerp(meshObject.transform.localPosition, originPosition, 0.2f);
		}
	}

	public override void OnPostPhysicsUpdateLR(float deltaTime, InteractableObject handLHeld, InteractableObject handRHeld)
	{
		base.OnPostPhysicsUpdateLR(deltaTime, handLHeld, handRHeld);
		if ((object)handLHeld == this || (object)handRHeld == this)
		{
			Hand hand = (((object)handLHeld == this) ? CC.Inst.handL : CC.Inst.handR);
			float height = BaseSettings<InteractionSettings>.Inst.defaultGrabArea.height;
			if (Vector3.Distance(base.transform.position, hand.transform.position) > height)
			{
				hand.UngrabObject();
			}
		}
	}

	protected override InteractableObject OnGrabEntered(Hand hand, bool grabbedFromInventory, bool isSwappingHand)
	{
		onButtonDown.Invoke();
		beingPushed = true;
		return this;
	}

	public override void OnGrabStayed(Hand hand)
	{
		onButtonHeld.Invoke();
	}

	protected override void OnGrabExited(Hand hand)
	{
		onButtonUp.Invoke();
		beingPushed = false;
	}

	protected override bool CanBeGrabbed()
	{
		return base.isActiveAndEnabled;
	}

	public override bool CanBeFocusGrabbed()
	{
		return false;
	}

	public override void SetVelocityAngular(Vector3 velocityAngular)
	{
	}

	public override void SetVelocityLinear(Vector3 velocityLinear)
	{
	}

	public override void SetPositionAndRotation(Vector3 worldPos, Quaternion worldRot, CC.MovementType type = CC.MovementType.None)
	{
	}
}
public class CircularGrabPointMover : MonoBehaviour, IPostPhysicsUpdateEvent, IAwakeEvent
{
	private MRBase owner;

	[Range(0f, 10f)]
	public float Radius = 1f;

	[Range(0f, 180f)]
	public float forwardAngleConstraint = 180f;

	public float handOffsetDeg = -25f;

	public GrabPoint leftHandGrabPoint;

	public GrabPoint rightHandGrabPoint;

	private GPOffsetData leftGPData;

	private GPOffsetData rightGPData;

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		this.owner = owner;
		Vector3 normalized = leftHandGrabPoint.transform.localPosition.normalized;
		normalized.y = 0f;
		Vector3 vector = normalized.normalized * Radius;
		leftGPData = new GPOffsetData
		{
			posOffset = leftHandGrabPoint.transform.localPosition - vector,
			rotOffset = leftHandGrabPoint.transform.localRotation
		};
		normalized = rightHandGrabPoint.transform.localPosition.normalized;
		normalized.y = 0f;
		vector = normalized.normalized * Radius;
		rightGPData = new GPOffsetData
		{
			posOffset = rightHandGrabPoint.transform.localPosition - vector,
			rotOffset = rightHandGrabPoint.transform.localRotation
		};
	}

	void IPostPhysicsUpdateEvent.OnPostPhysicsUpdateLR()
	{
		CC inst = CC.Inst;
		if (inst.handL.owner == owner && (bool)leftHandGrabPoint)
		{
			UpdateGrabPoints(inst.handL, leftHandGrabPoint, leftGPData);
		}
		if (inst.handL.owner == owner && (bool)rightHandGrabPoint)
		{
			UpdateGrabPoints(inst.handR, rightHandGrabPoint, rightGPData);
		}
	}

	private void UpdateGrabPoints(Hand hand, GrabPoint grabPoint, GPOffsetData offsetData)
	{
		if (!(hand.grabPointHeld != grabPoint))
		{
			return;
		}
		Vector3 handPalmPosition = hand.GetHandPalmPosition();
		Quaternion rotation = hand.transform.rotation;
		Transform transform = grabPoint.transform;
		Transform transform2 = base.transform;
		Vector3 vector = transform2.InverseTransformPoint(handPalmPosition);
		float num = Radius * 2f;
		if (Mathf.Abs(vector.x) > num || Mathf.Abs(vector.z) > num)
		{
			return;
		}
		vector = vector.normalized;
		vector.y = 0f;
		vector.Normalize();
		transform.localPosition = vector * Radius;
		Vector3 vector2 = vector;
		Quaternion quaternion = Quaternion.Inverse(transform2.rotation) * rotation;
		Vector3 vector3 = Vector3.Cross(vector2, Vector3X.up);
		Vector3 rhs = quaternion * Vector3X.up;
		float f = Vector3.Dot(vector3, rhs);
		vector3 *= Mathf.Sign(f);
		Quaternion rotation2 = Quaternion.LookRotation(vector2, vector3);
		Quaternion quaternion2 = rotation2.TransformRotation(Quaternion.Euler(0f, (Quaternion.Inverse(rotation2) * quaternion).eulerAngles.y, 0f));
		Vector3 vector4 = quaternion2 * Vector3X.forward;
		Vector3 vector5 = quaternion2 * Vector3X.right;
		if (forwardAngleConstraint < 180f)
		{
			Vector3 vector6 = vector2 * -1f;
			if (Vector3.Angle(vector4, vector6) > forwardAngleConstraint)
			{
				Mathf.Sign(Vector3.Dot(vector4, Vector3X.up));
				Vector3 vector7 = Quaternion.AngleAxis(forwardAngleConstraint, vector5) * vector6;
				Vector3 upwards = Vector3.Cross(vector7, vector5);
				quaternion2 = Quaternion.LookRotation(vector7, upwards);
			}
		}
		transform.localRotation = quaternion2;
		Quaternion quaternion3 = transform.localRotation * Quaternion.Inverse(offsetData.rotOffset);
		transform.localPosition += quaternion3 * offsetData.posOffset;
		transform.localRotation *= Quaternion.AngleAxis(handOffsetDeg, transform.InverseTransformDirection(transform.right));
	}
}
public class DoNotClone : MonoBehaviour, IDoNotClone
{
}
public class ExtendableObject : InteractableObject
{
	private ExtendableSubObject subObject;

	private GrabObject parent;

	private MeshFilter objMF;

	private bool springActive;

	protected Vector3 minPoint;

	protected Vector3 maxPoint;

	protected Vector3 springVelocity = Vector3.zero;

	[Tooltip("This is where the centre of the object will be at min and max")]
	public Vector3 targetMinPoint;

	[Tooltip("This is where the centre of the object will be at min and max")]
	public Vector3 targetMaxPoint;

	[Tooltip("For subobjects these are the same as the extented sibling/parent")]
	public bool constrainX;

	[Tooltip("For subobjects these are the same as the extented sibling/parent")]
	public bool constrainY;

	[Tooltip("For subobjects these are the same as the extented sibling/parent")]
	public bool constrainZ;

	public float springTightness = 400f;

	public float springDamping = 50f;

	protected Vector3 offset;

	private bool hitMax;

	private bool hitMin;

	public override void OnAwakeLR(MRBase owner)
	{
		base.OnAwakeLR(owner);
		parent = GetComponentInParent<GrabObject>();
		subObject = base.transform.parent.GetComponentInChildren<ExtendableSubObject>();
		if ((bool)subObject)
		{
			subObject.InheritConstraints(this);
		}
		objMF = GetComponent<MeshFilter>();
		minPoint = (parent ? targetMinPoint : (base.transform.localPosition + targetMinPoint));
		maxPoint = (parent ? targetMaxPoint : (base.transform.localPosition + targetMaxPoint));
		hitMin = false;
		hitMax = false;
	}

	protected override bool CanBeGrabbed()
	{
		if ((bool)parent)
		{
			if ((bool)parent)
			{
				return CC.Inst.IsObjectGrabbed(parent);
			}
			return false;
		}
		return true;
	}

	public override bool CanBeFocusGrabbed()
	{
		return false;
	}

	protected override InteractableObject OnGrabEntered(Hand hand, bool grabbedFromInventory, bool isSwappingHand)
	{
		Vector3 vector = ((!parent) ? base.transform.parent.InverseTransformPoint(hand.transform.position) : base.transform.parent.InverseTransformPoint(hand.transform.position));
		offset = vector - base.transform.localPosition;
		springVelocity = Vector3.zero;
		springActive = false;
		if ((bool)subObject)
		{
			subObject.OnGrab(hand.transform.position);
		}
		return this;
	}

	public override void OnGrabStayed(Hand hand)
	{
		if ((bool)parent && !CC.Inst.IsObjectGrabbed(parent))
		{
			return;
		}
		Transform transform = hand.transform;
		Vector3 vector = ((!parent) ? base.transform.parent.InverseTransformPoint(transform.position) : base.transform.parent.InverseTransformPoint(transform.position));
		Vector3 localHandPos = vector - offset;
		Vector3 targetVector = GetTargetVector(localHandPos);
		base.transform.localPosition = targetVector;
		if (PastMaximum(base.transform.localPosition))
		{
			if (!hitMax)
			{
				if ((bool)subObject)
				{
					subObject.CalculateOffset(transform.position);
				}
				hitMax = true;
			}
			if ((bool)subObject && !subObject.atMax)
			{
				subObject.Move(transform.position);
				MoveMinMaxPoints();
			}
			base.transform.localPosition = maxPoint;
		}
		else if (PastMinimum(base.transform.localPosition))
		{
			if ((bool)subObject && !subObject.atMin)
			{
				if (!hitMin)
				{
					subObject.CalculateOffset(transform.position);
					hitMin = true;
				}
				subObject.Move(transform.position);
				MoveMinMaxPoints();
			}
			base.transform.localPosition = minPoint;
		}
		else
		{
			hitMin = false;
			hitMax = false;
		}
	}

	protected Vector3 GetTargetVector(Vector3 localHandPos)
	{
		float x = (constrainX ? base.transform.localPosition.x : localHandPos.x);
		float y = (constrainY ? base.transform.localPosition.y : localHandPos.y);
		float z = (constrainZ ? base.transform.localPosition.z : localHandPos.z);
		return new Vector3(x, y, z);
	}

	protected bool PastMaximum(Vector3 localPos)
	{
		if (!constrainX && localPos.x < maxPoint.x)
		{
			return true;
		}
		if (!constrainY && localPos.y < maxPoint.y)
		{
			return true;
		}
		if (!constrainZ && localPos.z < maxPoint.z)
		{
			return true;
		}
		return false;
	}

	protected bool PastMinimum(Vector3 localPos)
	{
		if (!constrainX && localPos.x > minPoint.x)
		{
			return true;
		}
		if (!constrainY && localPos.y > minPoint.y)
		{
			return true;
		}
		if (!constrainZ && localPos.z > minPoint.z)
		{
			return true;
		}
		return false;
	}

	protected override void OnGrabExited(Hand hand)
	{
		springActive = true;
	}

	protected override void OnUpdateLR(float deltaTime, InteractableObject handLHeld, InteractableObject handRHeld)
	{
		if (springActive)
		{
			float dt = Mathf.Min(IC.DeltaTime, 1f / 60f);
			if ((bool)subObject)
			{
				subObject.Spring(dt, springTightness, springDamping);
				MoveMinMaxPoints();
			}
			Spring(dt, springTightness, springDamping);
		}
	}

	protected void Spring(float dt, float springTightness, float springDamping)
	{
		float magnitude = (base.transform.localPosition - minPoint).magnitude;
		float magnitude2 = (base.transform.localPosition - maxPoint).magnitude;
		Vector3 vector = ((magnitude < magnitude2) ? minPoint : maxPoint);
		Vector3 currentSpringDisplacement = base.transform.localPosition - vector;
		Vector3 vector2 = MathfX.ForceAtEndsOfSpring(springTightness, currentSpringDisplacement, springDamping, springVelocity);
		springVelocity += vector2 * dt;
		base.transform.localPosition += springVelocity * dt;
	}

	private void MoveMinMaxPoints()
	{
		MoveMinPoint();
		MoveMaxPoint();
	}

	private void MoveMaxPoint()
	{
		maxPoint = subObject.transform.localPosition + targetMaxPoint;
	}

	private void MoveMinPoint()
	{
		minPoint = subObject.transform.localPosition + targetMinPoint;
	}

	public override void SetPositionAndRotation(Vector3 worldPos, Quaternion worldRot, CC.MovementType type = CC.MovementType.None)
	{
	}

	public override void SetVelocityAngular(Vector3 velocityAngular)
	{
	}

	public override void SetVelocityLinear(Vector3 velocityLinear)
	{
	}
}
public class ExtendableSubObject : ExtendableObject
{
	private Bounds meshBounds;

	[NonSerialized]
	public bool atMin;

	[NonSerialized]
	public bool atMax;

	public override void OnAwakeLR(MRBase owner)
	{
		base.OnAwakeLR(owner);
		springVelocity = Vector3.zero;
		meshBounds = GetComponent<MeshFilter>().sharedMesh.bounds;
		minPoint = targetMinPoint;
		maxPoint = targetMaxPoint;
	}

	public void InheritConstraints(ExtendableObject extendable)
	{
		constrainX = extendable.constrainX;
		constrainY = extendable.constrainY;
		constrainZ = extendable.constrainZ;
	}

	protected override bool CanBeGrabbed()
	{
		return false;
	}

	public override bool CanBeFocusGrabbed()
	{
		return false;
	}

	public void OnGrab(Vector3 worldHandPos)
	{
		springVelocity = Vector3.zero;
		Vector3 vector = base.transform.parent.InverseTransformPoint(worldHandPos);
		offset = vector - base.transform.localPosition;
	}

	public void Move(Vector3 worldHandPos)
	{
		Vector3 vector = base.transform.parent.InverseTransformPoint(worldHandPos);
		base.transform.localPosition = GetTargetVector(vector - offset);
		atMin = false;
		atMax = false;
		if (PastMaximum(base.transform.localPosition))
		{
			base.transform.localPosition = maxPoint;
			atMax = true;
		}
		else if (PastMinimum(base.transform.localPosition))
		{
			base.transform.localPosition = minPoint;
			atMin = true;
		}
	}

	public void CalculateOffset(Vector3 worldHandPos)
	{
		Vector3 vector = base.transform.parent.InverseTransformPoint(worldHandPos);
		offset = vector - base.transform.localPosition;
	}

	public Vector3 GetMinPoint()
	{
		return minPoint;
	}

	public Vector3 GetMaxPoint()
	{
		return maxPoint;
	}

	public Bounds GetMeshBounds()
	{
		return meshBounds;
	}

	public override void ValidateGrabPoints()
	{
	}
}
public class FixedRotatableMimic : IDObject, IMimic<FixedRotatableObject>, IMimicBase, IAwakeEvent
{
	IMimic<FixedRotatableObject> IMimic<FixedRotatableObject>.LinkedIMimic { get; set; }

	FixedRotatableObject IMimic<FixedRotatableObject>.LinkedMimicComp { get; set; }

	void IMimicBase.OnMimicEnteredPortal(Portal portal)
	{
	}

	void IMimicBase.OnMimicSwappedControl(bool inControl)
	{
	}

	void IMimicBase.OnMimicUpdate()
	{
		FixedRotatableObject linkedMimicComp = ((IMimic<FixedRotatableObject>)this).LinkedMimicComp;
		if ((bool)linkedMimicComp)
		{
			base.transform.localRotation = linkedMimicComp.transform.localRotation;
		}
	}

	bool IMimicBase.CanHaveControl()
	{
		return false;
	}
}
[Serializer.ExcludeAllFields]
public class FixedRotatableObject : InteractableObject, IMimic<FixedRotatableObject>, IMimicBase
{
	[Serializable]
	public struct GrabbableArea
	{
		public float radius;

		public float height;

		public float offset;
	}

	[Serializable]
	private struct AngularConstraint
	{
		public float angle;

		public Vector2 direction;

		public AngularConstraint(float constraintAngle)
		{
			angle = constraintAngle;
			float f = angle * ((float)Math.PI / 180f);
			direction = new Vector2(Mathf.Sin(f), Mathf.Cos(f));
		}
	}

	[Serializable]
	public struct SnapEvents
	{
		public Event OnSnapEnter;

		public Event OnSnapExit;
	}

	public GrabbableArea grabArea = new GrabbableArea
	{
		radius = 0.1f,
		height = 0.05f
	};

	public float[] snapRotations = new float[0];

	public float snapArea = 10f;

	public SnapEvents[] snapEvents;

	[ReadOnly]
	public int currentSnapIndex = -1;

	private int lastNotifiedSnapIndex = -1;

	private int currentSoundIdx;

	private int prevSoundIdx;

	[ReadOnlyAtRuntime]
	[SerializeField]
	public float coneAngle;

	public float springStrength = 500f;

	public float springDamping = 20f;

	public float startRotationDeg;

	[SerializeField]
	[HideInInspector]
	private float absSpringStrength = 500f;

	[SerializeField]
	[HideInInspector]
	private float absSpringDamping = 20f;

	[SerializeField]
	[HideInInspector]
	private Vector2[] snapRotationDirections;

	[Serializer.IncludeField]
	[SerializeField]
	private Vector2 position = new Vector2(0f, 1f);

	[Serializer.IncludeField]
	[SerializeField]
	private Vector2 lastPosition = new Vector2(0f, 1f);

	[Serializer.IncludeField]
	[SerializeField]
	private Vector2 startDirection;

	private Vector2 velocity;

	private Vector2 initialLerpDirection;

	private Vector2 finalLerpDirection;

	public bool autoReleaseAtExtents = true;

	public float angularDrag = 2f;

	private float angularVelocity;

	private float currentLerpValue;

	private float lastLerpValue = -1f;

	private float initialLerpRotation;

	private float finalLerpRotation;

	[SerializeField]
	[HideInInspector]
	private AngularConstraint minimumConstraint;

	[SerializeField]
	[HideInInspector]
	private AngularConstraint maximumConstraint;

	private Quaternion offsetRotation = Quaternion.identity;

	public bool shouldReturnToStartingAngle;

	private bool isGrabbing;

	private const float MAX_VELOCITY = 10f;

	public bool resetPositionOnAwake;

	public bool useCustomLeverSettings;

	[ConditionalHide("useCustomLeverSettings", true, true)]
	public InteractionSettings.LeverType leverType;

	[ConditionalHide("useCustomLeverSettings")]
	public InteractionSettings.LeverInfo leverInfo;

	private bool reverseLeverCurve;

	private float currentSoundTime;

	private float prevAngle;

	private float currentMovementModifier;

	[Tooltip("Minimum change in angle required to trigger the snap sound when passing the snap point.Set to something small to stop the sound from spamming if the lever isn't quite at rest")]
	public float minSoundAngleDelta = 0.1f;

	private IHaglet prepareEventRoutine;

	public float velocityToNotify = 0.15f;

	private IHaglet<float, float> routineAnimateToTarget;

	public float AngularVelocity
	{
		get
		{
			float num = Mathf.Atan2(position.x, position.y);
			float num2 = Mathf.Abs(Mathf.Atan2(lastPosition.x, lastPosition.y) - num) * 57.29578f;
			return Mathf.Clamp((Vector3.Cross(lastPosition, position).normalized == Vector3.forward) ? (0f - num2) : num2, -10f, 10f);
		}
	}

	IMimic<FixedRotatableObject> IMimic<FixedRotatableObject>.LinkedIMimic { get; set; }

	FixedRotatableObject IMimic<FixedRotatableObject>.LinkedMimicComp { get; set; }

	public float GetActualAngle(Vector2 direction)
	{
		Vector3 to = GetRotation(direction) * Vector3.forward;
		return Vector3.Angle(base.transform.parent.forward, to);
	}

	public static Quaternion GetRotation(Vector2 direction)
	{
		Vector3 normalized = new Vector3(direction.x, direction.y, 0f).normalized;
		Vector3 normalized2 = Vector3.Cross(Vector3.forward, normalized).normalized;
		return Quaternion.LookRotation(Vector3.Cross(normalized, normalized2).normalized, normalized);
	}

	public override void OnDestroy()
	{
		base.OnDestroy();
		if (routineAnimateToTarget != null)
		{
			routineAnimateToTarget.Stop();
		}
	}

	public override void OnPrebuildRoot(bool isPrefab)
	{
		base.OnPrebuildRoot(isPrefab);
		SetConeAngle(coneAngle);
		ResetPosition();
	}

	private void ResetPosition()
	{
		float f = startRotationDeg * ((float)Math.PI / 180f);
		Vector2 vector = new Vector2(Mathf.Sin(f), Mathf.Cos(f));
		position = vector;
		lastPosition = position;
		prevAngle = startRotationDeg;
	}

	public override void OnAwakeLR(MRBase owner)
	{
		base.OnAwakeLR(owner);
		ConfigureSnapEvents();
		_ = snapRotationDirections;
		Haglet.Create(out routineAnimateToTarget, (Routine.Func2<float, float>)RoutineAnimateToTarget, (string)null, startNow: false, (int?)null, (string)null);
		if (!useCustomLeverSettings)
		{
			leverInfo = BaseSettings<InteractionSettings>.Inst.GetLeverInfo(leverType);
		}
		if (resetPositionOnAwake)
		{
			ResetPosition();
		}
		CheckRotations();
		base.transform.localRotation = GetRotation(position);
		Haglet.Create(out prepareEventRoutine, PrepareEventRoutine);
	}

	public override Wait PrepareEvents()
	{
		return prepareEventRoutine.Start();
	}

	private IEnumerator<Routine.Yield> PrepareEventRoutine()
	{
		yield return base.PrepareEvents();
		yield return Wait.For.LRUpdates(1);
		for (int i = 0; i < snapEvents.Length; i++)
		{
			snapEvents[i].OnSnapEnter.PrepareInvoke();
			yield return Wait.For.LRUpdates(1);
			snapEvents[i].OnSnapExit.PrepareInvoke();
		}
	}

	protected override void OnUpdateLR(float deltaTime, InteractableObject handLHeld, InteractableObject handRHeld)
	{
		UpdateInterpolation();
		UpdateMoveSound();
	}

	public override void OnPostPhysicsUpdateLR(float deltaTime, InteractableObject handLHeld, InteractableObject handRHeld)
	{
		base.OnPostPhysicsUpdateLR(deltaTime, handLHeld, handRHeld);
		isGrabbing = (object)handLHeld == this || (object)handRHeld == this;
		float num = Mathf.Min(deltaTime, 1f / 60f);
		if (!isGrabbing)
		{
			CheckFreeRotate(num);
		}
		CheckSnapRotations(num, isGrabbing);
		if (Mathf.Abs(angularVelocity) < velocityToNotify && lastNotifiedSnapIndex != currentSnapIndex)
		{
			if (currentSnapIndex != -1)
			{
				snapEvents[currentSnapIndex].OnSnapEnter.Invoke();
			}
			else if (lastNotifiedSnapIndex != -1)
			{
				snapEvents[lastNotifiedSnapIndex].OnSnapExit.Invoke();
			}
			lastNotifiedSnapIndex = currentSnapIndex;
		}
		float constraintCorrection = CheckConstraints();
		if (isGrabbing)
		{
			Hand handHeld = (((object)handLHeld == this) ? CC.Inst.handL : CC.Inst.handR);
			CheckAutoRelease(constraintCorrection, handHeld);
		}
		base.transform.localRotation = GetRotation(position);
		float angle = GetAngle();
		float f = angle - prevAngle;
		currentSoundIdx = -1;
		for (int i = 0; i < snapRotations.Length; i++)
		{
			if (leverInfo.snapSound == null)
			{
				break;
			}
			if (Mathf.Abs(f) < minSoundAngleDelta)
			{
				break;
			}
			if ((angle <= snapRotations[i] && prevAngle > snapRotations[i]) || (angle >= snapRotations[i] && prevAngle < snapRotations[i]))
			{
				currentSoundIdx = i;
				FAC.Inst.PlayOneShot(leverInfo.snapSound, base.transform).setParameterValue("Velocity", Mathf.Clamp(Mathf.Abs(f), 0f, 10f));
				f = 0f;
				break;
			}
		}
		prevSoundIdx = currentSoundIdx;
		prevAngle = angle;
	}

	private void CheckRotations()
	{
		float num = (0f - coneAngle) / 2f;
		float num2 = coneAngle / 2f;
		reverseLeverCurve = Mathf.Abs(num2 - startRotationDeg) < Mathf.Abs(num - startRotationDeg);
		if (reverseLeverCurve)
		{
			float num3 = num;
			num = num2;
			num2 = num3;
		}
		initialLerpDirection = GetDirectionFromAngle(num);
		initialLerpRotation = num;
		finalLerpDirection = GetDirectionFromAngle(num2);
		finalLerpRotation = num2;
	}

	private bool CheckAutoRelease(float constraintCorrection, Hand handHeld)
	{
		bool flag = false;
		if (autoReleaseAtExtents && constraintCorrection * currentMovementModifier > 10f)
		{
			flag = true;
		}
		Vector3 v = base.transform.InverseTransformPoint(handHeld.transform.position);
		v.z -= grabArea.offset;
		if (Mathf.Abs(v.z) * currentMovementModifier > grabArea.height)
		{
			flag = true;
		}
		if (v.xy().sqrMagnitude * currentMovementModifier * currentMovementModifier > grabArea.radius * grabArea.radius)
		{
			flag = true;
		}
		if (flag)
		{
			handHeld.UngrabObject();
		}
		return flag;
	}

	protected override InteractableObject OnGrabEntered(Hand hand, bool grabbedFromInventory, bool isSwappingHand)
	{
		Vector3 vector = base.transform.parent.InverseTransformPoint(hand.transform.position);
		Vector2 direction = (vector - base.transform.localPosition).normalized;
		offsetRotation = GetRotation(position) * Quaternion.Inverse(GetRotation(direction));
		currentSnapIndex = -1;
		return this;
	}

	public override void OnGrabStayed(Hand hand)
	{
		Vector3 vector = base.transform.parent.InverseTransformPoint(hand.transform.position);
		currentMovementModifier = leverInfo.pullCurve.Evaluate(currentLerpValue);
		Vector2 vector2 = (vector - base.transform.localPosition).normalized;
		vector2 = Vector3.Lerp(initialLerpDirection, vector2, currentMovementModifier);
		position = offsetRotation * vector2;
		velocity = Vector2.zero;
		if (leverInfo.hapticAmpMod != 0f)
		{
			float num = Mathf.Clamp01(Mathf.Abs(lastLerpValue - currentLerpValue) * leverInfo.hapticFreqMod);
			hand.SetHapticFeedback(num, (1f + leverInfo.hapticAmpConst - currentMovementModifier) * num * leverInfo.hapticAmpMod);
		}
	}

	protected override void OnGrabExited(Hand hand)
	{
		offsetRotation = Quaternion.identity;
		if (shouldReturnToStartingAngle)
		{
			Animate(startRotationDeg, 1f);
		}
		float num = Mathf.Atan2(position.x, position.y);
		float num2 = Mathf.Abs(Mathf.Atan2(lastPosition.x, lastPosition.y) - num) * 57.29578f;
		Vector3 normalized = Vector3.Cross(lastPosition, position).normalized;
		angularVelocity = ((normalized == Vector3.forward) ? (0f - num2) : num2);
		angularVelocity = Mathf.Clamp(angularVelocity, -10f, 10f);
		lastLerpValue = -1f;
		hand.SetHapticFeedback(0f, 0f);
	}

	private void UpdateInterpolation()
	{
		lastLerpValue = currentLerpValue;
		currentLerpValue = Mathf.InverseLerp(initialLerpRotation, finalLerpRotation, GetAngle());
		currentLerpValue = Mathf.Lerp(currentLerpValue, lastLerpValue, leverInfo.lerpDamping);
	}

	private void UpdateMoveSound()
	{
		if (lastLerpValue == -1f)
		{
			lastLerpValue = currentLerpValue;
		}
		float num = Mathf.Abs(lastLerpValue - currentLerpValue);
		if (num < 0.001f)
		{
			return;
		}
		currentSoundTime += num;
		if (currentSoundTime >= leverInfo.soundPeriod)
		{
			if (leverInfo.moveSound != null)
			{
				FAC.Inst.PlayOneShot(leverInfo.moveSound, base.transform).setParameterValue("Speed", num * 10f);
			}
			currentSoundTime = 0f;
		}
	}

	public override void OnEndOfUpdate(bool inPlayerScene)
	{
		lastPosition = position;
	}

	public void SetConeAngle(float angle)
	{
		coneAngle = Mathf.Clamp(angle, 0f, 359f);
		if (coneAngle > 0f)
		{
			float constraintAngle = 0f - coneAngle / 2f;
			float constraintAngle2 = coneAngle / 2f;
			minimumConstraint = new AngularConstraint(constraintAngle);
			maximumConstraint = new AngularConstraint(constraintAngle2);
		}
	}

	private void CheckSnapRotations(float clampedDeltaTime, bool isHeld)
	{
		if (routineAnimateToTarget.started || snapRotationDirections.Length == 0)
		{
			return;
		}
		Vector2X.Normalize(position, out var normalizedVector);
		Vector2 vectorB = normalizedVector;
		float num = -1f;
		float num2 = Mathf.Cos(snapArea * ((float)Math.PI / 180f));
		int num3 = -1;
		for (int i = 0; i < snapRotationDirections.Length; i++)
		{
			Vector2 vector = snapRotationDirections[i];
			float num4 = vector.x * normalizedVector.x + vector.y * normalizedVector.y;
			if (num4 > num && num4 >= num2)
			{
				num = num4;
				vectorB.x = vector.x;
				vectorB.y = vector.y;
				num3 = i;
			}
		}
		currentSnapIndex = ((num > 0.99f) ? num3 : (-1));
		if (!isHeld && !shouldReturnToStartingAngle)
		{
			Vector2X.Subtract(position, vectorB, out var resultVector);
			Vector2X.Multiply(resultVector, 0f - absSpringStrength, out var resultVector2);
			Vector2X.Multiply(velocity, absSpringDamping, out var resultVector3);
			Vector2X.Subtract(resultVector2, resultVector3, out var resultVector4);
			Vector2X.Multiply(resultVector4, clampedDeltaTime, out var resultVector5);
			Vector2X.Add(velocity, resultVector5, out var resultVector6);
			velocity = resultVector6;
			Vector2X.Multiply(velocity, clampedDeltaTime, out var resultVector7);
			Vector2X.Add(position, resultVector7, out var resultVector8);
			position = resultVector8;
		}
	}

	public float GetAngle()
	{
		return 57.29578f * Mathf.Atan2(position.x, position.y);
	}

	private float CheckConstraints()
	{
		float result = 0f;
		if (coneAngle > 0f)
		{
			float num = Mathf.Atan2(position.x, position.y) * 57.29578f;
			if (num > maximumConstraint.angle)
			{
				position = maximumConstraint.direction;
				velocity = -velocity;
				angularVelocity = 0f;
				result = num - maximumConstraint.angle;
			}
			if (num < minimumConstraint.angle)
			{
				position = minimumConstraint.direction;
				velocity = -velocity;
				angularVelocity = 0f;
				result = minimumConstraint.angle - num;
			}
		}
		return result;
	}

	private void CheckFreeRotate(float clampedDT)
	{
		if (shouldReturnToStartingAngle)
		{
			return;
		}
		if (Mathf.Abs(angularVelocity) > 0.05f)
		{
			float num = Mathf.Atan2(position.x, position.y) * 57.29578f;
			float num2 = angularVelocity;
			float f = (num + num2) * ((float)Math.PI / 180f);
			Vector2 vector = new Vector2(Mathf.Sin(f), Mathf.Cos(f));
			position = vector;
			angularVelocity -= angularVelocity * angularDrag * clampedDT;
			if (angularDrag * clampedDT >= 1f)
			{
				angularVelocity = 0f;
			}
		}
		else
		{
			angularVelocity = 0f;
		}
	}

	protected override bool CanBeGrabbed()
	{
		if (!routineAnimateToTarget.started)
		{
			return base.enabled;
		}
		return false;
	}

	public override bool CanBeFocusGrabbed()
	{
		return false;
	}

	public override void SetVelocityLinear(Vector3 velocityLinear)
	{
	}

	public override void SetVelocityAngular(Vector3 velocityAngular)
	{
	}

	public override void SetPositionAndRotation(Vector3 worldPos, Quaternion worldRot, CC.MovementType type = CC.MovementType.None)
	{
	}

	private Vector3 ToWorldSpaceDirection(Vector2 vector)
	{
		return base.transform.parent.TransformDirection(new Vector3(vector.x, vector.y, 0f));
	}

	private IEnumerator<Routine.Yield> RoutineAnimateToTarget(float angle, float timeMax)
	{
		float num = Mathf.Atan2(position.x, position.y) * 57.29578f;
		float startAngle = num;
		float time = 0f;
		while (time < timeMax)
		{
			time += IC.DeltaTime;
			float t = Mathf.SmoothStep(0f, 1f, time / timeMax);
			float f = Mathf.Lerp(startAngle, angle, t) * ((float)Math.PI / 180f);
			Vector2 vector = new Vector2(Mathf.Sin(f), Mathf.Cos(f));
			position = vector;
			yield return Wait.For.LRUpdates(1);
		}
		position = new Vector2(Mathf.Sin(angle * ((float)Math.PI / 180f)), Mathf.Cos(angle * ((float)Math.PI / 180f)));
	}

	public void Animate(float angle, float time)
	{
		routineAnimateToTarget.Start(angle, time, resetIfStarted: true);
	}

	public Wait AnimateOnYield(float angle, float time)
	{
		return routineAnimateToTarget.Call(angle, time);
	}

	public void ForceRotation(float angle)
	{
		float f = angle * ((float)Math.PI / 180f);
		Vector2 vector = new Vector2(Mathf.Sin(f), Mathf.Cos(f));
		position = vector;
		base.transform.localRotation = GetRotation(position);
	}

	public void ConfigureSnapEvents()
	{
		if (snapEvents == null || snapRotations.Length != snapEvents.Length)
		{
			SnapEvents[] array = new SnapEvents[snapRotations.Length];
			if (snapEvents != null)
			{
				Array.Copy(snapEvents, array, Mathf.Min(snapEvents.Length, array.Length));
			}
			snapEvents = array;
		}
	}

	private Vector2 GetDirectionFromAngle(float angle)
	{
		float f = angle * ((float)Math.PI / 180f);
		float x = Mathf.Sin(f);
		float y = Mathf.Cos(f);
		return new Vector2(x, y);
	}

	void IMimicBase.OnMimicEnteredPortal(Portal portal)
	{
	}

	void IMimicBase.OnMimicSwappedControl(bool inControl)
	{
	}

	void IMimicBase.OnMimicUpdate()
	{
		FixedRotatableObject linkedMimicComp = ((IMimic<FixedRotatableObject>)this).LinkedMimicComp;
		if ((bool)linkedMimicComp)
		{
			position = linkedMimicComp.position;
		}
	}

	bool IMimicBase.CanHaveControl()
	{
		return true;
	}
}
[ExecuteInEditMode]
public class Gear : MonoBehaviour, IAwakeEvent
{
	[Range(5f, 16f)]
	public int teeth = 8;

	[ReadOnly]
	public List<Gear> childGears = new List<Gear>();

	public IDObjectRef[] interactableTargetRefs = new IDObjectRef[0];

	[HideInInspector]
	public Gear parentGear;

	public bool isLargeGear = true;

	private float lastLocalZRot;

	private int rotCount;

	private InteractableTarget[] interactableTargets;

	private PlacementHelper placementHelper;

	private const float kMaxSpeed = 5f;

	private IHaglet waitForLoadRoutine;

	public bool CanDrive
	{
		get
		{
			if (placementHelper == null)
			{
				return true;
			}
			return placementHelper.HeldGrabObject != null;
		}
	}

	public float Circumference => (float)teeth * (BaseSettings<GearSettings>.Inst.toothBaseArcSize + BaseSettings<GearSettings>.Inst.toothTipArcSize);

	public float Radius => Circumference / ((float)Math.PI * 2f);

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		Haglet.Create(out waitForLoadRoutine, WaitForLoadRoutine, null, startNow: true);
		placementHelper = GetComponentInChildren<PlacementHelper>();
		if ((bool)placementHelper)
		{
			placementHelper.OnHelperGrabObject.onInvoke += PlacementHelper_OnHelperGrabObject;
		}
	}

	public void ApplyDrive(float delta)
	{
		if (delta == 0f || ((bool)placementHelper && placementHelper.HeldGrabObject == null))
		{
			return;
		}
		if (lastLocalZRot + delta >= 360f)
		{
			rotCount++;
		}
		else if (lastLocalZRot + delta <= 0f)
		{
			rotCount--;
		}
		UpdateAnimators(delta);
		float z = MathfX.Modulus(lastLocalZRot + delta, 360f);
		base.transform.localRotation = Quaternion.Euler(0f, 0f, z);
		lastLocalZRot = z;
		foreach (Gear childGear in childGears)
		{
			float num = (float)teeth / (float)childGear.teeth;
			childGear.ApplyDrive(delta * (0f - num));
		}
	}

	public bool ConstrainDelta(float delta, out float newDelta)
	{
		bool result = false;
		newDelta = delta;
		if ((bool)placementHelper && !placementHelper.HeldGrabObject)
		{
			return result;
		}
		for (int i = 0; i < interactableTargets.Length; i++)
		{
			InteractableTarget interactableTarget = interactableTargets[i];
			if (interactableTarget.isActiveAndEnabled && interactableTarget.ConstrainDelta(newDelta / 360f, out var newDelta2))
			{
				result = true;
				newDelta = newDelta2 * 360f;
			}
		}
		foreach (Gear childGear in childGears)
		{
			float num = (float)teeth / (float)childGear.teeth;
			if (childGear.ConstrainDelta(newDelta * (0f - num), out var newDelta3))
			{
				newDelta = newDelta3 / (0f - num);
				result = true;
			}
		}
		return result;
	}

	public void UpdateAnimators(float delta)
	{
		for (int i = 0; i < interactableTargets.Length; i++)
		{
			InteractableTarget interactableTarget = interactableTargets[i];
			if (interactableTarget.isActiveAndEnabled)
			{
				interactableTarget.SetPosition(delta / 360f);
			}
		}
	}

	public virtual bool GetSnapPoint(ref float closestDist, ref InteractableTarget closestTarget)
	{
		if ((bool)placementHelper && placementHelper.HeldGrabObject == null)
		{
			return false;
		}
		bool flag = false;
		InteractableTarget[] array = interactableTargets;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].GetSnapPoint(out var closestDist2, out var closestTarget2) && Mathf.Abs(closestDist2) < Mathf.Abs(closestDist))
			{
				flag = true;
				closestDist = closestDist2;
				closestTarget = closestTarget2;
			}
		}
		foreach (Gear childGear in childGears)
		{
			flag |= childGear.GetSnapPoint(ref closestDist, ref closestTarget);
		}
		if ((bool)parentGear)
		{
			float num = (float)parentGear.teeth / (float)teeth;
			closestDist *= 0f - num;
		}
		return flag;
	}

	private IEnumerator<Routine.Yield> WaitForLoadRoutine()
	{
		_ = Wait.None;
		bool flag = true;
		while (flag)
		{
			yield return Wait.For.LRUpdates(1);
			flag = false;
			for (int i = 0; i < interactableTargetRefs.Length; i++)
			{
				flag |= !interactableTargetRefs[i].IsRefLoadedAndAwake();
			}
		}
		interactableTargets = new InteractableTarget[interactableTargetRefs.Length];
		for (int j = 0; j < interactableTargetRefs.Length; j++)
		{
			interactableTargets[j] = LR.Inst.GetIDObjectComponent<InteractableTarget>(interactableTargetRefs[j]);
		}
	}

	private void PlacementHelper_OnHelperGrabObject()
	{
	}
}
[ExecuteInEditMode]
public class GearMachine : MonoBehaviour, IAwakeEvent
{
	private struct GearData
	{
		public Vector3 lastValidLocalPosition;

		public int lastValidTeeth;

		public bool IsValid(Gear gear)
		{
			if (lastValidLocalPosition == gear.transform.localPosition)
			{
				return lastValidTeeth == gear.teeth;
			}
			return false;
		}
	}

	public Gear driveGear;

	private Gear[] childGears;

	private float soundTimer;

	private const float kMaxSpeed = 5f;

	private bool drivenThisFrame;

	private float currentAbsDelta;

	[Tooltip("If enabled, this gear machine will need to have its sounds specified below, else it will use the ones specified by \"Full Cog Turn\" and \"Partial Cog Turn\" in InteractionSettings")]
	public bool useOverrideSounds;

	[ConditionalHide("useOverrideSounds")]
	public FMODEventAsset fullTurnEventAsset;

	[ConditionalHide("useOverrideSounds")]
	public FMODEventAsset partialTurnEventAsset;

	private FMOD.Studio.EventInstance turnEventInstance;

	private Dictionary<Gear, GearData> gearToGearData = new Dictionary<Gear, GearData>();

	public bool drawGeneratedMeshes;

	private bool AllGearsMoving
	{
		get
		{
			if (childGears == null)
			{
				return false;
			}
			for (int i = 0; i < childGears.Length; i++)
			{
				if (!childGears[i].CanDrive)
				{
					return false;
				}
			}
			return true;
		}
	}

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		childGears = GetComponentsInChildren<Gear>(includeInactive: true);
		if (!useOverrideSounds)
		{
			fullTurnEventAsset = BaseSettings<InteractionSettings>.Inst.fullCogTurn;
			partialTurnEventAsset = BaseSettings<InteractionSettings>.Inst.partialCogTurn;
		}
	}

	public bool ConstrainDelta(float delta, out float newDelta)
	{
		return driveGear.ConstrainDelta(delta, out newDelta);
	}

	public void ApplyDrive(float delta)
	{
		float num = Mathf.Abs(delta);
		drivenThisFrame = num > 0f;
		driveGear.ApplyDrive(delta);
		soundTimer += num;
		float num2 = 1f / BaseSettings<InteractionSettings>.Inst.gearTurnSoundFrequency;
		if (soundTimer >= num2)
		{
			soundTimer %= num2;
			UpdateSound(num);
		}
	}

	private void UpdateSound(float absoluteDelta)
	{
		FMODEventAsset asset = (AllGearsMoving ? fullTurnEventAsset : partialTurnEventAsset);
		turnEventInstance = FAC.Inst.PlayOneShot(asset, base.transform.position);
		turnEventInstance.setParameterValue("Speed", absoluteDelta / 5f);
	}

	public bool GetSnapPoint(out float closestDist, ref InteractableTarget closestTarget)
	{
		closestDist = float.MaxValue;
		return driveGear.GetSnapPoint(ref closestDist, ref closestTarget);
	}

	private void LateUpdate()
	{
		if (!drivenThisFrame && turnEventInstance.isValid())
		{
			turnEventInstance.stop(STOP_MODE.IMMEDIATE);
		}
		drivenThisFrame = false;
		if (!UnityEngine.Application.isPlaying && (bool)driveGear)
		{
			driveGear.transform.localPosition = Vector3.zero;
			EvaluateGearPositions(driveGear);
		}
	}

	private bool EvaluateGearPositions(Gear gear, float parentDeltaZRotation = -1f)
	{
		GearData gearData = GetGearData(gear);
		if (!gearData.IsValid(gear))
		{
			SnapPosition(gear);
			if (gearData.lastValidTeeth != gear.teeth)
			{
				UpdateTeeth(gear);
			}
			EvaluateGearPositions(driveGear);
			return false;
		}
		foreach (Gear childGear in gear.childGears)
		{
			if (!EvaluateGearPositions(childGear))
			{
				EvaluateGearPositions(driveGear);
				return false;
			}
		}
		return true;
	}

	private void UpdateTeeth(Gear gear)
	{
		GearData gearData = GetGearData(gear);
		float radius = gear.Radius;
		Vector3 lastValidLocalPosition = gearData.lastValidLocalPosition;
		foreach (Gear childGear in gear.childGears)
		{
			Vector3 normalized = (lastValidLocalPosition - GetGearData(childGear).lastValidLocalPosition).normalized;
			float num = radius + childGear.Radius;
			Vector3 newLocalPos = lastValidLocalPosition - normalized * num;
			SetGearPosition(childGear, newLocalPos);
		}
		gearData.lastValidTeeth = gear.teeth;
		gearToGearData[gear] = gearData;
	}

	private void SnapPosition(Gear snappingGear)
	{
		float dist = float.MaxValue;
		Vector3 pos = snappingGear.transform.localPosition;
		Gear node = null;
		GetClosestSnappedPos(snappingGear, driveGear, ref dist, ref pos, ref node);
		SetGearPosition(snappingGear, pos);
		if (snappingGear.parentGear != node)
		{
			snappingGear.parentGear?.childGears.Remove(snappingGear);
			snappingGear.parentGear = node;
			snappingGear.parentGear?.childGears.Add(snappingGear);
		}
	}

	private void SetGearPosition(Gear gear, Vector3 newLocalPos)
	{
		GearData gearData = GetGearData(gear);
		Vector3 vector = newLocalPos - gearData.lastValidLocalPosition;
		gear.transform.localPosition = newLocalPos;
		gearData.lastValidLocalPosition = newLocalPos;
		gearToGearData[gear] = gearData;
		foreach (Gear childGear in gear.childGears)
		{
			SetGearPosition(childGear, childGear.transform.localPosition + vector);
		}
	}

	private GearData GetGearData(Gear gear)
	{
		if (!gearToGearData.TryGetValue(gear, out var value))
		{
			GearData gearData = default(GearData);
			gearData.lastValidLocalPosition = gear.transform.localPosition;
			gearData.lastValidTeeth = gear.teeth;
			value = gearData;
			gearToGearData.Add(gear, value);
		}
		return value;
	}

	private void GetClosestSnappedPos(Gear snappingGear, Gear targetGear, ref float dist, ref Vector3 pos, ref Gear node)
	{
		if (snappingGear == targetGear)
		{
			return;
		}
		CalculateNodeSnap(snappingGear.transform.localPosition, snappingGear.Radius, targetGear.transform.localPosition, targetGear.Radius, out var dist2, out var pos2);
		if (dist2 < dist)
		{
			dist = dist2;
			pos = pos2;
			node = targetGear;
		}
		foreach (Gear childGear in targetGear.childGears)
		{
			GetClosestSnappedPos(snappingGear, childGear, ref dist, ref pos, ref node);
		}
	}

	private void CalculateNodeSnap(Vector3 snappingNodePos, float snappingNodeRadius, Vector3 targetNodePos, float targetNodeRadius, out float dist, out Vector3 pos)
	{
		Vector3 normalized = (targetNodePos - snappingNodePos).normalized;
		float num = snappingNodeRadius + targetNodeRadius;
		pos = targetNodePos - normalized * num;
		dist = Vector3.Distance(snappingNodePos, pos);
	}
}
public class GearMachineDriver : MonoBehaviour, IAwakeEvent, IUpdateEvent
{
	private enum DriveDirection
	{
		FORWARD,
		REVERSE,
		STOPPED
	}

	public GearMachine gearMachine;

	public bool applyConstantDrive;

	[ConditionalHide("applyConstantDrive", true, true)]
	public float driveTime = 1f;

	[ConditionalHide("applyConstantDrive", true, true)]
	public float driveOutput = 360f;

	[ConditionalHide("applyConstantDrive", true, true)]
	public bool accumulateOutput;

	[ConditionalHide("applyConstantDrive", true, false)]
	public float constantDrivePerSec = 360f;

	private DriveDirection constantDriveDirection = DriveDirection.STOPPED;

	private float remainingDriveOutput;

	private IHaglet driveRoutine;

	public void ApplyDrive()
	{
		ApplyDrive(null);
	}

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		Haglet.Create(out driveRoutine, DriveRoutine);
	}

	void IUpdateEvent.OnUpdateLR()
	{
		if (applyConstantDrive && constantDriveDirection != DriveDirection.STOPPED)
		{
			int num = ((constantDriveDirection == DriveDirection.FORWARD) ? 1 : (-1));
			float delta = IC.DeltaTime * constantDrivePerSec * (float)num;
			gearMachine.ConstrainDelta(delta, out var newDelta);
			gearMachine.ApplyDrive(newDelta);
		}
	}

	[Event(EventName = "Apply Drive")]
	private void ApplyDrive(object sender)
	{
		if (applyConstantDrive)
		{
			constantDriveDirection = DriveDirection.FORWARD;
		}
		else
		{
			ApplyFixedDrive(driveOutput);
		}
	}

	[Event(EventName = "Apply Reverse Drive")]
	private void ApplyReverseDrive(object sender)
	{
		if (applyConstantDrive)
		{
			constantDriveDirection = DriveDirection.REVERSE;
		}
		else
		{
			ApplyFixedDrive(0f - driveOutput);
		}
	}

	private void ApplyFixedDrive(float drive)
	{
		if (remainingDriveOutput <= 0f || accumulateOutput)
		{
			remainingDriveOutput = (accumulateOutput ? (remainingDriveOutput + drive) : drive);
			if (!driveRoutine.started)
			{
				driveRoutine.Start();
			}
		}
	}

	public void StopDrive()
	{
		StopDrive(null);
	}

	[Event(EventName = "Stop Drive")]
	public void StopDrive(object sender)
	{
		if (applyConstantDrive)
		{
			constantDriveDirection = DriveDirection.STOPPED;
		}
		else
		{
			remainingDriveOutput = 0f;
		}
	}

	private IEnumerator<Routine.Yield> DriveRoutine()
	{
		float absRemainingDriveOutput = Mathf.Abs(remainingDriveOutput);
		while (absRemainingDriveOutput > 0f)
		{
			absRemainingDriveOutput = Mathf.Abs(remainingDriveOutput);
			float num = driveOutput / driveTime * IC.DeltaTime;
			num *= Mathf.Sign(remainingDriveOutput);
			float num2 = Mathf.Abs(num);
			float num3 = ((absRemainingDriveOutput > num2) ? num : remainingDriveOutput);
			remainingDriveOutput -= num3;
			gearMachine.ConstrainDelta(num3, out var newDelta);
			gearMachine.ApplyDrive(newDelta);
			yield return Wait.For.LRUpdates(1);
		}
	}
}
public interface IOwnerChangeListener
{
	void OnOwnerChange(MRBase _oldOwner, MRBase _newOwner);
}
internal interface IGrabEvent
{
	void OnGrab(GrabObject obj);

	void OnRelease();
}
[SelectionBase]
[RequireComponent(typeof(Rigidbody))]
public class GrabObject : InteractableObject, IOwnerChangeListener, IMimic<GrabObject>, IMimicBase, IPauseEvent, IPauseUpdate
{
	[Serializable]
	public struct GrabObjectSaveData : ISerializable
	{
		public bool created;

		public string sceneUIDName;

		public Vector3 gravityDirection;

		public int invEGrillIndex;

		public string[] puzzleInfoPaths;

		public Occludee occludee;

		public PortalVariations.VariantSet variantMain;

		public void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			info.AddValue("sceneUID", sceneUIDName);
			info.AddValue("gravityX", (double)gravityDirection.x);
			info.AddValue("gravityY", (double)gravityDirection.y);
			info.AddValue("gravityZ", (double)gravityDirection.z);
			info.AddValue("eGrillIdx", invEGrillIndex);
			info.AddValue("puzzleInfoLength", puzzleInfoPaths.Length);
			for (int i = 0; i < puzzleInfoPaths.Length; i++)
			{
				info.AddValue("puzzleInfos" + i, puzzleInfoPaths[i]);
			}
		}

		public GrabObjectSaveData(SerializationInfo info, StreamingContext context)
		{
			created = false;
			sceneUIDName = info.GetString("sceneUID");
			gravityDirection = new Vector3((float)info.GetDouble("gravityX"), (float)info.GetDouble("gravityY"), (float)info.GetDouble("gravityZ"));
			invEGrillIndex = info.GetInt32("eGrillIdx");
			int @int = info.GetInt32("puzzleInfoLength");
			puzzleInfoPaths = new string[@int];
			for (int i = 0; i < @int; i++)
			{
				puzzleInfoPaths[i] = info.GetString("puzzleInfos" + i);
			}
			occludee = null;
			variantMain = PortalVariations.VariantSet.Main;
		}

		public void Capture(GrabObject grabObject)
		{
			created = true;
			sceneUIDName = grabObject.owner.info.Load().sceneUIDName;
			gravityDirection = grabObject.pr.ObjGravity / PortalingRigidbody.gravityStrength;
			invEGrillIndex = grabObject.inventoryObject.ValidEGRillIndex;
			if (grabObject.connectedPuzzleInfos != null && grabObject.connectedPuzzleInfos.Length != 0)
			{
				for (int i = 0; i < grabObject.connectedPuzzleInfos.Length; i++)
				{
					puzzleInfoPaths[i] = grabObject.connectedPuzzleInfos[i].ResourcePath;
				}
			}
			occludee = grabObject.GetComponentInChildren<Occludee>();
			if ((bool)grabObject.portalVariations)
			{
				variantMain = grabObject.portalVariations.LastMain;
			}
		}
	}

	private struct InventoryEffectHandler
	{
		private const string INVENTORY_EFFECT_ON = "INVENTORY_EFFECT_ON";

		private static readonly int _LocalhandPos = Shader.PropertyToID("_LocalhandPos");

		private static readonly int _HandRadius = Shader.PropertyToID("_HandRadius");

		private static readonly int _HandRadiusGradiant = Shader.PropertyToID("_HandRadiusGradiant");

		private static readonly int _EmissiveColor = Shader.PropertyToID("_EmissiveColor");

		private static readonly int _EmissiveAmount = Shader.PropertyToID("_EmissiveAmount");

		private Material mat;

		private Material originalMat;

		private Renderer renderer;

		public InventoryEffectHandler(Renderer renderer)
		{
			this.renderer = renderer;
			originalMat = renderer.sharedMaterial;
			mat = ((originalMat == null) ? null : new Material(originalMat));
			mat?.EnableKeyword("INVENTORY_EFFECT_ON");
		}

		public void PrepareInventoryEffect(float size, Vector3 pos)
		{
			InventorySettings inst = BaseSettings<InventorySettings>.Inst;
			mat?.SetVector(_LocalhandPos, renderer.transform.InverseTransformPoint(pos));
			mat?.SetFloat(_HandRadiusGradiant, size * inst.effectGradiant);
			mat?.SetColor(_EmissiveColor, inst.effectColour);
			mat?.SetFloat(_HandRadius, size);
			mat?.SetFloat(_EmissiveAmount, 0f);
			renderer.sharedMaterial = mat;
		}

		public void DisableInventoryEffect()
		{
			renderer.sharedMaterial = originalMat;
		}

		public void UpdateHandRadius(float radius)
		{
			mat?.SetFloat(_HandRadius, radius);
		}

		public void UpdateEmissiveAmount(float amount)
		{
			mat?.SetFloat(_EmissiveAmount, amount);
		}
	}

	[Serializable]
	public class ObjectBreakSettings
	{
		[ReadOnly]
		public bool isBroken;

		public ConstArray<BrokenObjectPart> brokenPeices;

		public ConstArray<GameObject> completePeices;

		public float objectStrength;

		public float bounceForce;

		public float outwardForce;

		[NonSerialized]
		public Rigidbody[] brokenObjectRBs;
	}

	[Serializable]
	public struct IDPathInfo
	{
		public string id;

		public string localPath;

		public string typeName;
	}

	private struct SnapState
	{
		public CC.MovementType lastSnapMovement;

		public bool forceSnap;

		public Rasterizer lastRasterizer;

		public Vector3 offset;
	}

	public IDPathInfo[] idPathInfos;

	[HideInInspector]
	public PortalingRigidbody pr;

	public HagletTrigger onPositionReplace = new HagletTrigger();

	private ConstArray<MeshFilter> objMFs;

	public bool canBeGrabbed = true;

	[Serializer.IncludeField]
	public bool hasBeenGrabbed;

	public Vector3 inventoryRotation = Vector3.zero;

	private TransformState lastStateForPhysics;

	private TransformState lastValidCollisionPos;

	private ConstQueue<Vector4> lastLinearVelocity;

	private ConstQueue<Vector4> lastAngularVelocity;

	public Vector3 grabbedLinearVelocity;

	public bool autoAddedToInventory = true;

	[SerializeField]
	private bool breakable;

	[ConditionalHide("breakable")]
	public ObjectBreakSettings breakableOptions;

	private Vector3 springVelocity = Vector3.zero;

	[HideInInspector]
	public HookPoint hookPoint;

	private float oldDrag;

	private float oldAngDrag;

	private float oldMass;

	[NonSerialized]
	public Portal HACK_eyeglassPortal;

	private Region region;

	[Tooltip("Will prevent this object from being saved, causing it to reset every time the scene is loaded")]
	[Serializer.IncludeField]
	public bool allowSaving = true;

	private Material mat;

	public HagletTrigger OnObjectGrabbed = new HagletTrigger();

	public HagletTrigger OnObjectFocusGrabbed = new HagletTrigger();

	public HagletTrigger OnObjectBroken = new HagletTrigger();

	public HagletTrigger OnObjectDropped = new HagletTrigger();

	public HagletTrigger OnInventoryGrabbed = new HagletTrigger();

	private Hand handObjectIsGrabbedBy;

	public InventoryObject inventoryObject;

	[NonSerialized]
	public FMOD.Studio.EventInstance sfxHighlight;

	private MPBStore mpbStore = new MPBStore();

	[HideInInspector]
	public Hand lastGrabbedHand;

	[HideInInspector]
	public Hand currentGrabbedHand;

	[SerializeField]
	private Vector3 visualEffectsCenter = Vector3.zero;

	[SerializeField]
	[Serializer.IncludeField]
	public PuzzleInfo[] connectedPuzzleInfos;

	private HagletTrigger forceBreak = new HagletTrigger();

	[NonSerialized]
	public PortalVariations portalVariations;

	[Serializer.IncludeField]
	public GrabObjectSaveData saveData;

	[NonSerialized]
	public bool? wasActiveSelf;

	[NonSerialized]
	public PlacementHelperSnapPivot[] helperSnapPivots;

	private IPlacementEvent[] placementEvents;

	private IGrabEvent[] grabEvents;

	private AnimValue<float> ditherValue = new AnimValue<float>(1f);

	[SerializeField]
	[Tooltip("Disable this for any objects that dont want to fade if the player tries to put over their headeg Eyeglass or Occulder Wand")]
	private bool fadeNearHead = true;

	[NonSerialized]
	[HideInInspector]
	public bool FinishedWith;

	[SerializeField]
	private string inventoryObjectName = "";

	[Tooltip("Allows for specifying how far this object can move before its beam will disappear")]
	public bool beamHasCustomDistance;

	public float customBeamDistance;

	private bool _InCollision;

	private SnapState snapState;

	private IHaglet<bool> breakWhenFinishedRoutine;

	private MRBase srcOwner;

	private Vector3 srcPositionWS;

	private Vector3 srcScaleLS;

	private Vector3 srcGravityDirection;

	private Quaternion srcRotationWS;

	private bool srcIsKinematic;

	public bool IsBreakable => breakable;

	public float OldDrag => oldDrag;

	public Vector3 VisualEffectsCenter => visualEffectsCenter;

	public Vector3 VisualEffectsCenterWorldPos => base.transform.TransformPoint(visualEffectsCenter);

	[HideInInspector]
	public bool InCollision
	{
		get
		{
			return _InCollision;
		}
		private set
		{
			if (!_InCollision && value && (bool)pr)
			{
				pr.PlayCollisionSound();
			}
			_InCollision = value;
		}
	}

	IMimic<GrabObject> IMimic<GrabObject>.LinkedIMimic { get; set; }

	GrabObject IMimic<GrabObject>.LinkedMimicComp { get; set; }

	public void SpawnInventoryItem()
	{
		if (inventoryObject != null)
		{
			return;
		}
		string text = "InventoryObjects/" + inventoryObjectName;
		GameObject gameObject = null;
		GameObject gameObject2 = null;
		gameObject = Resources.Load<GameObject>(text);
		if (!gameObject)
		{
			return;
		}
		gameObject2 = UnityEngine.Object.Instantiate(gameObject, base.transform.position, base.transform.rotation, base.transform.parent);
		if ((bool)gameObject)
		{
			MeshRenderer[] componentsInChildren = gameObject2.transform.GetComponentsInChildren<MeshRenderer>(includeInactive: true);
			foreach (MeshRenderer meshRenderer in componentsInChildren)
			{
				meshRenderer.gameObject.layer = 5;
				if (meshRenderer.sharedMaterial != null)
				{
					Texture mainTexture = meshRenderer.sharedMaterial.mainTexture;
					Material material = new Material(BaseSettings<InventorySettings>.Inst.GetInventoryMaterial(meshRenderer.material.shader.name));
					material.mainTexture = mainTexture;
					meshRenderer.sharedMaterial = material;
				}
			}
			inventoryObject = gameObject2.GetComponent<InventoryObject>();
			inventoryObject.helperIcon.AddComponent<MeshRenderer>().sharedMaterial = PlayerInventory.Inst.HelperIconMat;
			inventoryObject.SetGrabObjectTarget(this);
			PlayerInventory.Inst.OnCreateInventoryObject(inventoryObject);
		}
		else
		{
			UnityEngine.Debug.LogError("Failed to find inventory object at path: " + text);
		}
	}

	public void GenerateInventoryItem()
	{
	}

	private int GetVariantIndex()
	{
		int num = (int)portalVariations.currentController;
		int activeVariantNum = portalVariations.GetActiveVariantNum();
		if (activeVariantNum != portalVariations.variants.Length && num > 0)
		{
			num = ((num > 0) ? (num - activeVariantNum) : num);
		}
		return num;
	}

	public void CaptureSaveData()
	{
		saveData.Capture(this);
	}

	public void LoadPuzzleInfos()
	{
		string[] puzzleInfoPaths = saveData.puzzleInfoPaths;
		for (int i = 0; i < puzzleInfoPaths.Length; i++)
		{
			connectedPuzzleInfos[i] = Resources.Load<PuzzleInfo>(puzzleInfoPaths[i]);
			if (!connectedPuzzleInfos[i])
			{
				UnityEngine.Debug.Log("Failed to find PuzzleInfo at path " + puzzleInfoPaths[i], this);
			}
		}
	}

	public override void OnAwakeLR(MRBase owner)
	{
		base.OnAwakeLR(owner);
		mpbStore.Initialise();
		pr = GetComponent<PortalingRigidbody>();
		placementEvents = GetComponentsInChildren<IPlacementEvent>();
		portalVariations = GetComponent<PortalVariations>();
		mpbStore.SetFloat(ShaderPID._DitherAlphaValue, 1f);
		HACK_eyeglassPortal = GetComponentInChildren<Portal>();
		hookPoint = GetComponentInChildren<HookPoint>();
		objMFs = new ConstArray<MeshFilter>(16u);
		MeshFilter[] componentsInChildren = GetComponentsInChildren<MeshFilter>();
		foreach (MeshFilter meshFilter in componentsInChildren)
		{
			if (meshFilter.GetComponent<BrokenObjectPart>() == null)
			{
				objMFs.Add(meshFilter);
			}
		}
		lastStateForPhysics = new TransformState(base.transform);
		lastValidCollisionPos = new TransformState(base.transform);
		helperSnapPivots = GetComponentsInChildren<PlacementHelperSnapPivot>(includeInactive: true);
		PlacementHelperSnapPivot[] array = helperSnapPivots;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].OnAwakeLR(this);
		}
		if (breakable)
		{
			SetupBreakableObjects();
		}
		lastLinearVelocity = new ConstQueue<Vector4>(64);
		lastAngularVelocity = new ConstQueue<Vector4>(64);
		InteractiveBeam component = UnityEngine.Object.Instantiate(BaseSettings<InteractionSettings>.Inst.interactEffectPrefab, base.transform.position, base.transform.rotation, base.transform).GetComponent<InteractiveBeam>();
		if ((bool)component)
		{
			component.OnAwakeLR(this);
			component.customDistance = beamHasCustomDistance;
			component.customSqrDistance = customBeamDistance * customBeamDistance;
		}
		FinishedWith = false;
		if (connectedPuzzleInfos != null && connectedPuzzleInfos.Length != 0)
		{
			saveData.puzzleInfoPaths = new string[connectedPuzzleInfos.Length];
			Haglet.Create(out breakWhenFinishedRoutine, (Routine.Func1<bool>)BreakWhenFinishedRoutine, (string)null, startNow: false, (int?)32, (string)null);
			breakWhenFinishedRoutine.Start(arg0: true);
		}
		grabEvents = GetComponentsInChildren<IGrabEvent>();
		inventoryObject.GatherOccludeeRenderers();
		snapState.lastSnapMovement = CC.MovementType.None;
		snapState.forceSnap = false;
		snapState.lastRasterizer = null;
		snapState.offset = Vector3.zero;
	}

	public void OnLateAwakeLR()
	{
		if (saveData.created)
		{
			pr.SetGravityDirection(saveData.gravityDirection);
			pr.SetKinematic(!hasBeenGrabbed);
			inventoryObject.ValidEGRillIndex = saveData.invEGrillIndex;
			MRBase loadedMRWithSceneUIDNameOrNull = LR.Inst.GetLoadedMRWithSceneUIDNameOrNull(saveData.sceneUIDName);
			pr.SetOwner(loadedMRWithSceneUIDNameOrNull);
			inventoryObject.SetOwner(loadedMRWithSceneUIDNameOrNull);
			if ((bool)portalVariations)
			{
				portalVariations.SetVariantToMain(saveData.variantMain);
			}
		}
		else
		{
			LR.Inst.saveDataGame.CreateSaveDataForGrabObject(this);
		}
		if (wasActiveSelf.HasValue)
		{
			base.gameObject.SetActive(wasActiveSelf.Value);
		}
	}

	private void SetupBreakableObjects()
	{
		breakableOptions.brokenPeices = new ConstArray<BrokenObjectPart>(8u);
		breakableOptions.completePeices = new ConstArray<GameObject>(4u);
		MeshRenderer[] componentsInChildren = GetComponentsInChildren<MeshRenderer>(includeInactive: true);
		foreach (MeshRenderer meshRenderer in componentsInChildren)
		{
			BrokenObjectPart component = meshRenderer.GetComponent<BrokenObjectPart>();
			if (component != null)
			{
				component.Initialise(base.transform);
				breakableOptions.brokenPeices.Add(component);
				component.gameObject.SetActive(value: false);
			}
			else
			{
				breakableOptions.completePeices.Add(meshRenderer.gameObject);
			}
		}
	}

	protected override void OnUpdateLR(float deltaTime, InteractableObject handLHeld, InteractableObject handRHeld)
	{
		if ((object)handLHeld != this && (object)handRHeld != this && !pr.GetKinematic() && pr.GetVelocityLinear().magnitude > 0f && Vector3.Distance(base.transform.position, base.transform.root.position) >= owner.objectResetDistance)
		{
			ResetToCameraPosition();
		}
		if (breakable && (pr.GetLastVelocityLinear() - pr.GetVelocityLinear()).magnitude > breakableOptions.objectStrength)
		{
			BreakObject(pr.GetLastVelocityLinear(), breakableOptions.bounceForce, breakableOptions.outwardForce);
		}
		if ((bool)ditherValue.animating)
		{
			AnimValue<float>.Update(ditherValue, IC.DeltaTime);
			mpbStore.SetFloat(ShaderPID._DitherAlphaValue, ditherValue.Value);
			pr.ApplyMaterialPropertyBlock(mpbStore);
		}
	}

	void IPauseEvent.OnPauseLR(bool paused)
	{
		if (!paused && ditherValue.vEnd != 1f)
		{
			ditherValue.AnimateTo(1f, BaseSettings<InteractionSettings>.Inst.ditherAnimTime);
		}
		pr.SetCurrentColliderEnabled(enabled: true);
	}

	void IPauseUpdate.OnPauseUpdateLR()
	{
		InteractionSettings inst = BaseSettings<InteractionSettings>.Inst;
		Vector3 vector = UIPauseMenu.Inst.GetBounds().ClosestPoint(base.transform.position);
		Vector3 position = MainCamera.Inst.transform.position;
		Vector3 vector2 = vector - position;
		Ray ray = base.transform.InverseTransformRay(position, vector2.normalized);
		bool flag = combindedBounds.IntersectRay(ray);
		pr.SetCurrentColliderEnabled(!flag);
		if (flag)
		{
			if (ditherValue.vEnd != inst.minimalDitherValue)
			{
				ditherValue.AnimateTo(inst.minimalDitherValue, inst.ditherAnimTime);
			}
		}
		else if (ditherValue.vEnd != 1f)
		{
			ditherValue.AnimateTo(1f, inst.ditherAnimTime);
		}
		if ((bool)ditherValue.animating)
		{
			AnimValue<float>.Update(ditherValue, IC.RealDeltaTime);
		}
		mpbStore.SetFloat(ShaderPID._DitherAlphaValue, ditherValue.Value);
		pr.ApplyMaterialPropertyBlock(mpbStore);
	}

	private void ResetToCameraPosition()
	{
		SetVelocityLinear(Vector3.zero);
		SetVelocityAngular(Vector3.zero);
		if (inventoryObject == null || !PlayerInventory.Inst.validInventoryObjects.Contains(inventoryObject))
		{
			ResetToInitialState();
			UnityEngine.Debug.Log($"Ungrabbed / Non-Inventory Object '{base.name}' is more than {owner.objectResetDistance}m from owner root, resetting to initial state.", base.gameObject);
		}
		else
		{
			UnityEngine.Debug.Log($"Object '{base.name}' is more than {owner.objectResetDistance}m from owner root, Moving out of view & setting kinematic.", base.gameObject);
			base.transform.position = new Vector3(5000f, 5000f, 5000f);
			pr.SetKinematic(isKinematic: true);
		}
	}

	private void BreakObject(Vector3 collisionVelocity, float bounceForce, float outwardForce)
	{
		for (int i = 0; i < breakableOptions.brokenPeices.Length; i++)
		{
			BrokenObjectPart brokenObjectPart = breakableOptions.brokenPeices[i];
			brokenObjectPart.gameObject.SetActive(value: true);
			brokenObjectPart.BreakFromObject(collisionVelocity, base.transform.rotation, bounceForce, outwardForce);
		}
		for (int j = 0; j < breakableOptions.completePeices.Length; j++)
		{
			breakableOptions.completePeices[j].SetActive(value: false);
		}
		pr.SetKinematic(isKinematic: true);
		breakableOptions.isBroken = true;
		OnObjectBroken.Trigger();
	}

	public void RepairObject()
	{
		for (int i = 0; i < breakableOptions.brokenPeices.Length; i++)
		{
			BrokenObjectPart brokenObjectPart = breakableOptions.brokenPeices[i];
			brokenObjectPart.gameObject.SetActive(value: false);
			brokenObjectPart.ResetObjectPart(base.transform);
		}
		for (int j = 0; j < breakableOptions.completePeices.Length; j++)
		{
			breakableOptions.completePeices[j].SetActive(value: true);
		}
		pr.SetKinematic(isKinematic: false);
		breakableOptions.isBroken = false;
	}

	public void ClearVelocityHistory()
	{
		lastLinearVelocity.Clear();
		lastAngularVelocity.Clear();
	}

	public override InteractableObject OnFocusGrabbed(Hand hand, out bool grabbedFromInventory)
	{
		if ((bool)hookPoint)
		{
			hookPoint.OnHandGrabEnter(grabbedFromInventory: false);
		}
		pr.SetKinematic(isKinematic: true);
		ClearVelocityHistory();
		OnObjectFocusGrabbed.Trigger();
		return base.OnFocusGrabbed(hand, out grabbedFromInventory);
	}

	public override void OnFocusGrabbing(Hand hand)
	{
		ClearVelocityHistory();
	}

	public void OnFocusGrabCancelled(Hand hand)
	{
		if ((bool)hookPoint)
		{
			hookPoint.OnHandGrabExit();
		}
		pr.SetKinematic(isKinematic: false);
		OnObjectDropped.Trigger();
	}

	[ContextMenu("Add to Inventory")]
	private void ManualAddToInventory()
	{
		if (!PlayerInventory.Inst.inventoryState.InInventory(this))
		{
			PlayerInventory.Inst.AddToInventory(this);
		}
	}

	protected override InteractableObject OnGrabEntered(Hand hand, bool grabbedFromInventory, bool isSwappingHand)
	{
		lastGrabbedHand = hand;
		currentGrabbedHand = hand;
		if (isSwappingHand)
		{
			return this;
		}
		if ((bool)hookPoint)
		{
			hookPoint.OnHandGrabEnter(grabbedFromInventory);
		}
		UpdatePhysicsState();
		ClearVelocityHistory();
		pr.SetKinematic(isKinematic: true);
		SetVelocityLinear(Vector3.zero);
		SetVelocityAngular(Vector3.zero);
		base.transform.parent = owner.transform;
		oldDrag = pr.GetDragLinear();
		oldAngDrag = pr.GetDragAngular();
		oldMass = pr.GetMass();
		pr.SetMass(float.PositiveInfinity);
		pr.SetDragLinear(float.PositiveInfinity);
		pr.SetDragAngular(float.PositiveInfinity);
		bool flag = true;
		if ((bool)portalVariations)
		{
			PortalVariations.VariantSet portalVariantSet = MainCamera.Inst.portalVariantSet;
			if (portalVariations.currentController != portalVariantSet)
			{
				if (grabbedFromInventory)
				{
					portalVariations.SetVariantToMain(portalVariations.currentController);
				}
				else
				{
					flag = false;
				}
			}
		}
		OnObjectGrabbed.Trigger();
		for (int i = 0; i < grabEvents.Length; i++)
		{
			grabEvents[i].OnGrab(this);
		}
		if (autoAddedToInventory && !PlayerInventory.Inst.inventoryState.InInventory(this))
		{
			PlayerInventory.Inst.AddToInventory(this);
		}
		if (flag)
		{
			inventoryObject.ValidEGRillIndex = PlayerInventory.Inst.CurrentEGrillIndex;
		}
		hasBeenGrabbed = true;
		if ((bool)mimic)
		{
			mimic.GetTargetMimic().GrabObject.hasBeenGrabbed = true;
		}
		return this;
	}

	public override void OnGrabStayed(Hand hand)
	{
	}

	protected override void OnGrabExited(Hand hand)
	{
		currentGrabbedHand = null;
		pr.SetMass(oldMass);
		pr.SetDragLinear(oldDrag);
		pr.SetDragAngular(oldAngDrag);
		pr.SetKinematic(isKinematic: false);
		SetVelocityLinear(GetEstimatedLinearVelocity());
		SetVelocityAngular(GetEstimatedAngularVelocity());
		if ((bool)hookPoint)
		{
			hookPoint.OnHandGrabExit();
		}
		OnObjectDropped.Trigger();
		for (int i = 0; i < grabEvents.Length; i++)
		{
			grabEvents[i].OnRelease();
		}
		for (int j = 0; j < subInteractables.Length; j++)
		{
			if (CC.Inst.IsObjectGrabbedOrFocusGrabbed(subInteractables[j]))
			{
				Hand handObjectIsGrabbed = CC.Inst.GetHandObjectIsGrabbed(subInteractables[j]);
				GrabPoint grabPointHeld = handObjectIsGrabbed.grabPointHeld;
				subInteractables[j].OnGrabStayed(handObjectIsGrabbed);
				handObjectIsGrabbed.UngrabObject();
				handObjectIsGrabbed.GrabObject(grabPointHeld, grabbedFromInventory: false, grabParent: true);
				break;
			}
		}
	}

	public void TryAttachHook()
	{
		if ((bool)hookPoint)
		{
			hookPoint.TryToHookOntoSomething();
		}
	}

	public void TryDetachHook()
	{
		if ((bool)hookPoint)
		{
			hookPoint.RemoveJoint();
		}
	}

	public Vector3 GetInstantLinearVelocity()
	{
		return (base.transform.position - lastStateForPhysics.position) / IC.DeltaTime;
	}

	public Vector3 GetInstantAngularVelocity()
	{
		float deltaTime = IC.DeltaTime;
		Quaternion quaternion = base.transform.rotation * Quaternion.Inverse(lastStateForPhysics.rotation);
		return new Vector3(quaternion.x / deltaTime, quaternion.y / deltaTime, quaternion.z / deltaTime);
	}

	public Vector3 GetEstimatedLinearVelocity()
	{
		InteractionSettings inst = BaseSettings<InteractionSettings>.Inst;
		return GetEstimation(lastLinearVelocity, IC.Time, inst.throwLinearVelocitySkip, inst.throwLinearVelocityLength, inst.throwLinearVelocityLookahead) ?? Vector3.zero;
	}

	public Vector3 GetEstimatedAngularVelocity()
	{
		InteractionSettings inst = BaseSettings<InteractionSettings>.Inst;
		return GetEstimation(lastAngularVelocity, IC.Time, inst.throwAngularVelocitySkip, inst.throwAngularVelocityLength, inst.throwAngularVelocityLookahead) ?? Vector3.zero;
	}

	private static Vector3? GetEstimation(ConstQueue<Vector4> queue, float now, float skip, float length, float lookahead)
	{
		if (queue.Length < 10)
		{
			return null;
		}
		float w = queue[0].w;
		now -= w;
		float num = now - skip;
		float start = num - length;
		Vector3 m;
		Vector3 b;
		bool estimationLine = GetEstimationLine(queue, start, num, w, out m, out b);
		Vector3? result = null;
		if (estimationLine)
		{
			result = m * (now + lookahead) + b;
		}
		return result;
	}

	private static bool GetEstimationLine(ConstQueue<Vector4> queue, float start, float end, float tBase, out Vector3 m, out Vector3 b)
	{
		int length = queue.Length;
		if (length < 1)
		{
			m = Vector3X.zero;
			b = Vector3X.zero;
			return false;
		}
		Vector4 zero = Vector4X.zero;
		Vector4 zero2 = Vector4X.zero;
		Vector3 zero3 = Vector3X.zero;
		int num = 0;
		for (int i = 0; i < length; i++)
		{
			Vector4 vector = queue[i];
			vector.w -= tBase;
			if (!(vector.w < start))
			{
				if (vector.w > end)
				{
					break;
				}
				zero += vector;
				zero2 += Vector4.Scale(vector, vector);
				zero3 += (Vector3)vector * vector.w;
				num++;
			}
		}
		float num2 = (float)num * zero2.w - zero.w * zero.w;
		if (num2 == 0f)
		{
			m = Vector3X.zero;
			b = Vector3X.zero;
			return false;
		}
		Vector3 vector2 = zero;
		m = (num * zero3 - zero.w * vector2) / num2;
		b = (vector2 * zero2.w - zero.w * zero3) / num2;
		return true;
	}

	public override void OnEndOfUpdate(bool inPlayerScene)
	{
		if ((bool)currentGrabbedHand)
		{
			Vector3 instantLinearVelocity = GetInstantLinearVelocity();
			lastLinearVelocity.Enqueue(instantLinearVelocity.V3ToV4(IC.Time), overwrite: true);
			lastAngularVelocity.Enqueue(GetInstantAngularVelocity().V3ToV4(IC.Time), overwrite: true);
			grabbedLinearVelocity = instantLinearVelocity;
		}
		if (inPlayerScene && fadeNearHead && !ditherValue.animating && !LR.Inst.IsPaused)
		{
			InteractionSettings inst = BaseSettings<InteractionSettings>.Inst;
			Vector3 vector = pr.ClosestPointOnCurrentColliderSet(MainCamera.Inst.transform.position);
			if (Vector3.Distance(vector, MainCamera.Inst.transform.position) < inst.nearFadeMaxDist || !Mathf.Approximately(ditherValue.Value, 1f))
			{
				ditherValue.Value = MainCamera.CalculateHeadDitherStrength(vector, inst.nearFadeMinDist, inst.nearFadeMaxDist);
				mpbStore.SetFloat(ShaderPID._DitherAlphaValue, ditherValue.Value);
				pr.ApplyMaterialPropertyBlock(mpbStore);
			}
		}
		UpdatePhysicsState();
	}

	public bool CheckWallCollision(Vector3 worldPosition, Quaternion worldRotation)
	{
		if ((object)currentGrabbedHand != null && (bool)currentGrabbedHand.portalFromHeadToHand)
		{
			return false;
		}
		Vector3 closestValidPos;
		bool num = CheckForCollision(worldPosition, worldRotation, out closestValidPos);
		if (num)
		{
			Vector3.Distance(closestValidPos, worldPosition);
			_ = (closestValidPos - worldPosition).normalized;
			base.transform.position = closestValidPos;
		}
		return num;
	}

	public TransformState GetLastPhysicsState()
	{
		return lastStateForPhysics;
	}

	public Vector3 GetClosestPointOnObject(Vector3 pos)
	{
		ConstArray<Collider> currentColliderSet = pr.GetCurrentColliderSet();
		Vector3 result = default(Vector3);
		float num = float.MaxValue;
		for (int i = 0; i < currentColliderSet.Length; i++)
		{
			Vector3 vector = currentColliderSet[i].ClosestPoint(pos);
			float sqrMagnitude = (vector - pos).sqrMagnitude;
			if (sqrMagnitude < num)
			{
				num = sqrMagnitude;
				result = vector;
			}
		}
		return result;
	}

	public bool CheckForCollision(Vector3 targetPos, Quaternion targetRot, out Vector3 closestValidPos)
	{
		closestValidPos = targetPos;
		if (CheckForCollisionWithPortal(targetPos, targetRot))
		{
			return false;
		}
		return !IsNextPositionValid(targetPos, targetRot, out closestValidPos);
	}

	private bool IsNextPositionValid(Vector3 targetPos, Quaternion targetRot, out Vector3 closestValidPos)
	{
		closestValidPos = targetPos;
		Vector3 position = lastValidCollisionPos.position;
		Vector3 vector = position + base.transform.rotation * combindedBounds.center;
		Vector3 vector2 = targetPos + targetRot * combindedBounds.center;
		float maxDistance = Vector3.Distance(vector2, vector);
		Vector3 vector3 = Vector3.Normalize(vector2 - vector);
		Vector3 position2 = MainCamera.Inst.transform.position;
		Vector3 direction = Vector3.Normalize(vector2 - position2);
		Ray ray = new Ray(position2, direction);
		float num = Vector3.Distance(position2, vector2);
		RaycastHit hitInfo;
		if (Physics.OverlapBox(vector2, combindedBounds.extents / 2f, targetRot, 1).Length != 0)
		{
			if (Physics.BoxCast(vector, combindedBounds.extents / 2f, vector3, out hitInfo, base.transform.rotation, maxDistance, 1))
			{
				closestValidPos = position + vector3 * hitInfo.distance;
				InCollision = true;
				return false;
			}
			closestValidPos = position;
			InCollision = true;
			return false;
		}
		if (InCollision && (EGrill.RaycastGetClosest(owner, ray, num, out var _, out var _) || Physics.Raycast(ray, num, 1)))
		{
			if (Physics.BoxCast(vector, combindedBounds.extents / 2f, vector3, out hitInfo, base.transform.rotation, maxDistance, 1))
			{
				closestValidPos = position + vector3 * hitInfo.distance;
				InCollision = true;
				return false;
			}
			closestValidPos = position;
			InCollision = true;
			return false;
		}
		InCollision = false;
		return true;
	}

	private bool CheckForCollisionWithPortal(Vector3 targetPos, Quaternion targetRot)
	{
		if (CC.Inst.IsObjectGrabbed(this))
		{
			Collider[] colliders = Physics.OverlapBox(targetPos, pr.GetEncapsulatingBounds().extents, targetRot, 1024, QueryTriggerInteraction.Collide);
			if (CheckInPortal(colliders))
			{
				return true;
			}
		}
		return false;
	}

	public bool CheckInPortal(Collider[] colliders)
	{
		bool result = false;
		for (int i = 0; i < colliders.Length; i++)
		{
			Portal component = colliders[i].GetComponent<Portal>();
			if ((bool)component && component.objectTeleportOnEnter && component != HACK_eyeglassPortal)
			{
				result = true;
				break;
			}
		}
		return result;
	}

	public bool CheckHeadLineOfSight()
	{
		RaycastHit hit;
		return CheckHeadLineOfSight(out hit);
	}

	public bool CheckHeadLineOfSight(out RaycastHit hit)
	{
		bool num = MainCamera.Inst.GetOwner() == owner;
		hit = default(RaycastHit);
		bool result = true;
		if (!num)
		{
			return false;
		}
		Vector3 headPosition = IC.GetHeadPosition();
		Vector3 normalized = (base.transform.position - headPosition).normalized;
		float magnitude = (base.transform.position - headPosition).magnitude;
		Physics.Raycast(new Ray(headPosition, normalized), out hit, magnitude, 1, QueryTriggerInteraction.Ignore);
		return result;
	}

	protected override bool CanBeGrabbed()
	{
		if (canBeGrabbed)
		{
			if (breakable)
			{
				return !breakableOptions.isBroken;
			}
			return true;
		}
		return false;
	}

	public override bool CanBeFocusGrabbed()
	{
		if (canBeGrabbed)
		{
			if (breakable)
			{
				return !breakableOptions.isBroken;
			}
			return true;
		}
		return false;
	}

	public TransformState GetLastValidCollisionState()
	{
		return lastValidCollisionPos;
	}

	public override void SetPositionAndRotation(Vector3 worldPos, Quaternion worldRot, CC.MovementType type = CC.MovementType.None)
	{
		if ((object)currentGrabbedHand != null)
		{
			if (!CheckWallCollision(worldPos, worldRot))
			{
				base.transform.position = worldPos;
				base.transform.position = SnapToRasterizers(type);
				base.transform.rotation = worldRot;
				lastValidCollisionPos.UpdateToLatestState();
			}
		}
		else
		{
			base.transform.position = worldPos;
			base.transform.rotation = worldRot;
			lastValidCollisionPos.UpdateToLatestState();
		}
		if ((bool)mimic)
		{
			mimic.UpdateMimic();
		}
	}

	public Vector3 SnapToRasterizers(CC.MovementType movementType)
	{
		float num = float.MaxValue;
		InteractionSettings inst = BaseSettings<InteractionSettings>.Inst;
		Vector3 position = base.transform.position;
		RasterizerSnapData.SnapData snapData = null;
		Vector3 vector = position;
		Vector3 vector2 = position;
		Rasterizer lastRasterizer = null;
		if (RasterizationController.Inst.rasterizedGrabObjects.Contains(this) && movementType == CC.MovementType.None)
		{
			ConstArray<Rasterizer> rasterizers = owner.rasterizers;
			for (int i = 0; i < rasterizers.Length; i++)
			{
				if (rasterizers[i].IsComplete)
				{
					continue;
				}
				RasterizerSnapData snapData2 = rasterizers[i].SnapData;
				if ((bool)snapData2 && snapData2.TryGetSnapData(id, out var data))
				{
					Vector3 vector3 = base.transform.TransformPoint(data.localCentre);
					float num2 = Vector3.Distance(vector3, data.worldPosition);
					float num3 = (data.shouldOverrideSettings ? data.snapRadius : inst.snapRadius);
					if (num2 < num3 && num2 < num)
					{
						lastRasterizer = rasterizers[i];
						vector2 = vector3;
						vector = data.worldPosition;
						snapData = data;
						num = num2;
					}
				}
			}
		}
		snapState.forceSnap |= movementType != snapState.lastSnapMovement || ((bool)snapState.lastRasterizer && snapState.lastRasterizer.IsComplete);
		snapState.lastSnapMovement = movementType;
		snapState.lastRasterizer = lastRasterizer;
		float b = ((snapData != null && snapData.shouldOverrideSettings) ? snapData.snapRadius : inst.snapRadius);
		AnimationCurve obj = ((snapData != null && snapData.shouldOverrideSettings) ? snapData.snapCurve : inst.snapCurve);
		float time = Mathf.InverseLerp(0f, b, num);
		time = obj.Evaluate(time);
		Vector3 a = vector + (position - vector2);
		a = Vector3.Lerp(a, position, time);
		if (snapState.forceSnap)
		{
			_ = Vector3.zero;
			float maxDistanceDelta = ((snapData != null && snapData.shouldOverrideSettings) ? snapData.snapSpeed : inst.snapSpeed) * IC.DeltaTime;
			Vector3 target = ((movementType == CC.MovementType.None) ? (position - a) : Vector3.zero);
			Vector3 vector4 = position - Vector3.MoveTowards(snapState.offset, target, maxDistanceDelta);
			if (Vector3.Distance(vector4, a) < 0.01f)
			{
				snapState.forceSnap = false;
			}
			a = vector4;
		}
		snapState.offset = position - a;
		return a;
	}

	public Transform GetTransformToMoveWithPortal()
	{
		return base.transform;
	}

	public override void SetVelocityLinear(Vector3 velocityLinear)
	{
		pr.SetVelocityLinear(velocityLinear);
	}

	public override void SetVelocityAngular(Vector3 velocityAngular)
	{
		pr.SetVelocityAngular(velocityAngular);
	}

	public MRBase GetOwner()
	{
		return owner;
	}

	public override void OnOwnerChange(MRBase _oldOwner, MRBase _newOwner)
	{
		base.OnOwnerChange(_oldOwner, _newOwner);
		LR.Inst.saveDataGame.TransferGrabObject(this, _oldOwner, _newOwner);
	}

	public void UpdatePhysicsState()
	{
		lastStateForPhysics.UpdateToLatestState();
	}

	public void ForceUpdateLastState()
	{
		pr.GetLastState().UpdateToLatestState();
	}

	public void OnPositionReplace()
	{
		onPositionReplace.Trigger();
	}

	public TransformState GetLastState()
	{
		return pr.GetLastState();
	}

	public void ForceBreak()
	{
		if (breakWhenFinishedRoutine == null)
		{
			Haglet.Create(out breakWhenFinishedRoutine, (Routine.Func1<bool>)BreakWhenFinishedRoutine, (string)null, startNow: false, (int?)null, (string)null);
			breakWhenFinishedRoutine.Start(arg0: false);
			forceBreak.Trigger();
		}
		else if (!breakWhenFinishedRoutine.started)
		{
			breakWhenFinishedRoutine.Start(arg0: false);
		}
		else
		{
			forceBreak.Trigger();
		}
	}

	private IEnumerator<Routine.Yield> BreakWhenFinishedRoutine(bool waitForScenes)
	{
		if (waitForScenes)
		{
			yield return LR.Inst.IsAllConnectedScenesLoaded;
		}
		InteractionSettings intSettings = BaseSettings<InteractionSettings>.Inst;
		_ = LR.Inst;
		Wait none = Wait.None;
		int num = ((connectedPuzzleInfos != null) ? connectedPuzzleInfos.Length : 0);
		for (int i = 0; i < num; i++)
		{
			none &= connectedPuzzleInfos[i].UntilComplete(SaveDataGame.PuzzleSaveType.Scene);
		}
		if (!forceBreak.happening)
		{
			yield return none | forceBreak;
		}
		yield return Routine.Yield.SpecialIndex.StopSkipping;
		PlayerInventory.Inst.MarkObjectForRemoval(this);
		InventorySettings inst = BaseSettings<InventorySettings>.Inst;
		_ = inst.handFadeInTime;
		_ = inst.handUnfillDelay;
		float waitTime2 = inst.handUnfillTime + inst.objectUnfillDelay;
		float time2 = 0f;
		Color darkGrey = Color.grey * Color.black;
		while (time2 < intSettings.shatterFadeTime)
		{
			yield return Wait.For.LRUpdates(1);
			time2 += IC.DeltaTime;
			Color value = Color.Lerp(Color.clear, darkGrey, Mathf.Clamp01(time2 / intSettings.shatterFadeTime));
			mpbStore.SetColor(ShaderPID._TintColor, value);
			pr.ApplyMaterialPropertyBlock(mpbStore);
		}
		mpbStore.SetColor(ShaderPID._TintColor, darkGrey);
		pr.ApplyMaterialPropertyBlock(mpbStore);
		time2 = 0f;
		Vector3 startScale = base.transform.localScale;
		while (time2 < intSettings.shatterTime)
		{
			yield return Wait.For.LRUpdates(1);
			time2 += IC.DeltaTime;
			float num2 = intSettings.shatterScaleCurve.Evaluate(Mathf.Clamp01(time2 / waitTime2));
			base.transform.localScale = startScale * num2;
		}
		base.transform.localScale = startScale * intSettings.shatterScaleCurve.Evaluate(1f);
		if ((bool)lastGrabbedHand && CC.Inst.IsObjectGrabbed(this))
		{
			Hand.PulseHapticFeedback(0f, 0.6f, 0.2f, lastGrabbedHand.OVRController);
		}
		Vector3 position = base.transform.TransformPoint(combindedBounds.center);
		PSC.Inst.PlayAt(ParticleType.InventoryBurst, position);
		FAC.Inst.PlayOneShot(intSettings.sfxShatter, position);
		Hand.UngrabObject(this);
		base.gameObject.SetActive(value: false);
		if ((bool)mimic)
		{
			mimic.gameObject.SetActive(value: false);
		}
		if ((bool)pr)
		{
			pr.TerminateSounds();
		}
		base.transform.localScale = startScale;
		FinishedWith = true;
		if (!Routine.Skipping)
		{
			yield return LR.Inst.Save();
		}
	}

	public override void OnDestroy()
	{
		base.OnDestroy();
		breakWhenFinishedRoutine?.Stop(complete: true);
		if ((bool)inventoryObject)
		{
			PlayerInventory.Inst.DestoryInventoryObject(inventoryObject);
		}
	}

	[ContextMenu("Log Prefab Type")]
	public void LogPrefabType()
	{
	}

	[ContextMenu("Replace with Spawner")]
	public void ReplaceWithSpawner()
	{
	}

	[ContextMenu("Log Hide Flags")]
	private void LogHideFlags()
	{
		UnityEngine.Debug.Log(base.gameObject.hideFlags.ToString());
	}

	protected override void OnDrawGizmos()
	{
	}

	public void OnPlacementGrabbed()
	{
		for (int i = 0; i < placementEvents.Length; i++)
		{
			placementEvents[i].OnPlacementGrabbed();
		}
		inventoryObject.ShowHelperIcon = true;
	}

	public void OnPlacementUngrabbed()
	{
		for (int i = 0; i < placementEvents.Length; i++)
		{
			placementEvents[i].OnPlacementUngrabbed();
		}
		inventoryObject.ShowHelperIcon = false;
	}

	void IMimicBase.OnMimicEnteredPortal(Portal portal)
	{
	}

	void IMimicBase.OnMimicSwappedControl(bool inControl)
	{
		if (inControl)
		{
			TryAttachHook();
		}
		else
		{
			TryDetachHook();
		}
	}

	void IMimicBase.OnMimicUpdate()
	{
	}

	bool IMimicBase.CanHaveControl()
	{
		return true;
	}

	public void SetInitialState()
	{
		srcOwner = owner;
		srcPositionWS = base.transform.position;
		srcScaleLS = base.transform.localScale;
		srcRotationWS = base.transform.rotation;
		srcIsKinematic = pr.GetKinematic();
		srcGravityDirection = pr.ObjGravity / PortalingRigidbody.gravityStrength;
	}

	public void ResetToInitialState()
	{
		pr.SetOwner(srcOwner);
		pr.SetVelocityLinear(Vector3.zero);
		pr.SetVelocityAngular(Vector3.zero);
		pr.SetKinematic(srcIsKinematic);
		pr.SetGravityDirection(srcGravityDirection);
		base.transform.position = srcPositionWS;
		base.transform.rotation = srcRotationWS;
		base.transform.localScale = srcScaleLS;
	}

	private static void GenerateInventoryObject()
	{
	}

	private static bool GenerateInventoryObjectValiation()
	{
		return false;
	}

	private static void GenerateAllInventoryObjects()
	{
	}
}
[ExecuteInEditMode]
public class GrabObjectSpawnPoint : MonoBehaviour
{
	public interface ISpawnerPrebuild
	{
		void OnCapture();
	}

	[Serializable]
	public struct GameObjectInfo
	{
		public bool hasIDObject;

		public ComponentInfo[] savedComponents;

		public bool AssignToGameObject(GameObject targetObject)
		{
			if (savedComponents == null)
			{
				return false;
			}
			for (int i = 0; i < savedComponents.Length; i++)
			{
				if (!savedComponents[i].AssignToComponent(targetObject))
				{
					return false;
				}
			}
			return true;
		}
	}

	[Serializable]
	public struct ComponentInfo
	{
		public string typeName;

		private Type type;

		public FieldValueInfo[] savedFields;

		public Type Type
		{
			get
			{
				if (type == null)
				{
					type = Type.GetType(typeName);
				}
				return type;
			}
		}

		public bool AssignToComponent(GameObject targetGameObject)
		{
			UnityEngine.Component component = targetGameObject.GetComponent(Type);
			if (component == null)
			{
				return false;
			}
			for (int i = 0; i < savedFields.Length; i++)
			{
				savedFields[i].ApplyTo(component);
			}
			return true;
		}

		public bool SetValue(string fieldName, object value)
		{
			for (int i = 0; i < savedFields.Length; i++)
			{
				if (savedFields[i].StoredFieldInfo.Name.Equals(fieldName))
				{
					savedFields[i].FieldValue = value;
					return true;
				}
			}
			return false;
		}

		public bool GetFieldValueByName(string fieldName, ref FieldValueInfo fieldValueInfo)
		{
			for (int i = 0; i < savedFields.Length; i++)
			{
				if (savedFields[i].StoredFieldInfo == null)
				{
					DebugX.LogWarningOnce("Null fieldinfo for: " + typeName + "," + savedFields[i].typeName);
				}
				else if (savedFields[i].StoredFieldInfo.Name.Equals(fieldName))
				{
					fieldValueInfo = savedFields[i];
					return true;
				}
			}
			return false;
		}
	}

	[Serializable]
	public struct FieldValueInfo
	{
		public string typeName;

		private Type type;

		public string fieldName;

		public string valueString;

		private object fieldValue;

		public byte[] serializedValue;

		private FieldInfo fieldInfo;

		public Type Type
		{
			get
			{
				if (type == null)
				{
					type = Type.GetType(typeName);
				}
				return type;
			}
		}

		public FieldInfo StoredFieldInfo
		{
			get
			{
				if (fieldInfo == null)
				{
					Type type = Type.GetType(typeName);
					fieldInfo = type.GetField(fieldName);
					if (fieldInfo == null)
					{
						DebugX.LogWarningOnce("Could not generate FieldInfo: " + typeName + "." + fieldName + " T: " + type.ToString());
					}
				}
				return fieldInfo;
			}
			set
			{
				fieldInfo = value;
				typeName = fieldInfo.ReflectedType.AssemblyQualifiedName;
				fieldName = fieldInfo.Name;
			}
		}

		public object FieldValue
		{
			get
			{
				if (fieldValue == null)
				{
					IFormatter formatter = new BinaryFormatter();
					MemoryStream serializationStream = new MemoryStream(serializedValue);
					fieldValue = formatter.Deserialize(serializationStream);
				}
				return fieldValue;
			}
			set
			{
				if (value == null)
				{
					UnityEngine.Debug.Log("Setting null value!");
					serializedValue = null;
					fieldValue = null;
					valueString = null;
					return;
				}
				serializedValue = new byte[0];
				BinaryFormatter binaryFormatter = new BinaryFormatter();
				MemoryStream memoryStream = new MemoryStream();
				((IFormatter)binaryFormatter).Serialize((Stream)memoryStream, value);
				serializedValue = memoryStream.GetBuffer();
				fieldValue = value;
				if (fieldValue != null)
				{
					valueString = fieldValue.ToString();
				}
			}
		}

		public void ApplyTo(object obj)
		{
			if (FieldValue == null)
			{
				UnityEngine.Debug.LogError("Null value on: " + typeName);
				return;
			}
			if (obj == null)
			{
				UnityEngine.Debug.LogError("Null obj on: " + typeName);
				return;
			}
			if (StoredFieldInfo != null)
			{
				StoredFieldInfo.SetValue(obj, FieldValue);
				return;
			}
			UnityEngine.Component component = (UnityEngine.Component)obj;
			UnityEngine.Debug.LogWarning("Missing field on GrabObject, recreate spawner to solve, speak to Josh", component.gameObject);
		}
	}

	[ReadOnly]
	public string prefabPath;

	public bool activeState;

	[Header("Must be manually edited")]
	[Tooltip("Couldnt decide whether to auto capture as it varied based on cirumtance\n Also cba with custom property drawer and attribute :P")]
	public PuzzleInfo[] connectedPuzzles;

	[HideInInspector]
	public GameObject prefabAsset;

	private static Type[] componentsToSave;

	private static Type[] validTypesToSave;

	public GrabObject Spawn(MRBase owner)
	{
		if (!prefabAsset)
		{
			return null;
		}
		if (LR.Inst.saveDataGame.ContainsGrabObject(prefabAsset.GetComponent<GrabObject>().id))
		{
			return null;
		}
		GrabObject grabObject = Spawn();
		grabObject.transform.position = base.transform.position;
		grabObject.transform.rotation = base.transform.rotation;
		grabObject.wasActiveSelf = activeState;
		grabObject.connectedPuzzleInfos = connectedPuzzles;
		DestroySpawnPoint();
		return grabObject;
	}

	private GrabObject Spawn()
	{
		if (!prefabAsset)
		{
			return null;
		}
		GrabObject component = UnityEngine.Object.Instantiate(prefabAsset, base.transform.parent).GetComponent<GrabObject>();
		if ((bool)component)
		{
			component.name = prefabAsset.name;
		}
		return component;
	}

	public void DestroySpawnPoint()
	{
		LR.Inst.OnSpawnPointDestroy(this);
		UnityEngine.Object.Destroy(base.gameObject);
	}

	static GrabObjectSpawnPoint()
	{
		componentsToSave = new Type[2]
		{
			typeof(IDObject),
			typeof(ObjectMimic)
		};
		validTypesToSave = new Type[4]
		{
			typeof(IDObjectRef),
			typeof(IDObjectRef[]),
			typeof(string),
			typeof(GrabObject.GrabObjectSaveData)
		};
	}

	private static bool IsValidFieldType(Type t)
	{
		for (int i = 0; i < validTypesToSave.Length; i++)
		{
			if (t.IsSubclassOf(validTypesToSave[i]) || t.Equals(validTypesToSave[i]))
			{
				return true;
			}
		}
		return false;
	}
}
[Serializable]
public class GrabPointConnection
{
	public GrabPoint grabPointA;

	public GrabPoint grabPointB;
}
[ExecuteInEditMode]
public class GrabPoint : MonoBehaviour, PortalVariations.IUseVariantSet, IPrebuildEvent
{
	private InteractableObject parentInteractable;

	private InteractableObject interactable;

	public float grabRadius = 0.1f;

	[SerializeField]
	private IC.Hand ICHand;

	public List<HandPoseWeight> handPose = new List<HandPoseWeight>();

	private int grabPointParentIdx;

	private int grabPointIdx;

	[SerializeField]
	private bool lockHandGizmo;

	private static GameObject gizmoHandLGO;

	private static GameObject gizmoHandRGO;

	private Mesh gizmoMesh;

	private bool isParentGrabbed;

	public bool ignoreOnInventoryObject;

	[HideInInspector]
	public PortalVariations portalVariations;

	[ReadOnly]
	public bool isSubGrabPoint;

	public InteractableObject InteractableObject
	{
		get
		{
			if (!isParentGrabbed)
			{
				return interactable;
			}
			return parentInteractable;
		}
	}

	public IC.Hand GetICHand()
	{
		return ICHand;
	}

	public void OnAwakeLR()
	{
		interactable = base.gameObject.GetComponentInAscendant<InteractableObject>();
		if (interactable == null)
		{
			return;
		}
		grabPointIdx = interactable.RegisterGrabPoint(this);
		if (interactable.isSubInteractive)
		{
			isSubGrabPoint = true;
			parentInteractable = base.gameObject.GetComponentInAscendant<GrabObject>();
			if (parentInteractable == null)
			{
				parentInteractable = base.gameObject.GetComponentInAscendant<InventoryObject>();
			}
			if ((bool)parentInteractable)
			{
				grabPointParentIdx = parentInteractable.RegisterGrabPoint(this);
			}
		}
	}

	public GrabPoint OnGrabEnter(Hand hand, bool grabbedFromInventory, bool isSwappingHand, bool isParentGrabbing)
	{
		isParentGrabbed = isParentGrabbing;
		InteractableObject interactableObject = InteractableObject.OnGrabEnter(hand, grabbedFromInventory, isSwappingHand);
		if (interactableObject != InteractableObject)
		{
			int key = InteractableObject.grabPoints.IndexOf(this);
			return interactableObject.grabPoints[key];
		}
		return this;
	}

	public void OnGrabExit()
	{
		isParentGrabbed = false;
	}

	public void SetICHand(IC.Hand hand)
	{
		ICHand = hand;
	}

	public bool IsValid(Hand hand)
	{
		if (ICHand == hand.ICHand && base.isActiveAndEnabled)
		{
			if (interactable.isSubInteractive)
			{
				Hand handObjectIsGrabbed = CC.Inst.GetHandObjectIsGrabbed(parentInteractable);
				if (handObjectIsGrabbed == null || handObjectIsGrabbed.grabPointHeld.isSubGrabPoint)
				{
					return false;
				}
			}
			return true;
		}
		return false;
	}

	public int GetIndex()
	{
		return grabPointIdx;
	}

	public void OnHighlightEnter(Hand hand, Portal portal)
	{
		InteractableObject.OnHighlightEnter(hand, this, ValidateHighlightPortal(hand, portal));
	}

	public void OnHighlightStay(Hand hand, Portal portal)
	{
		InteractableObject.OnHighlightStay(hand, ValidateHighlightPortal(hand, portal));
	}

	public void OnHighlightExit(Hand hand)
	{
		InteractableObject.OnHightlightExit(hand);
	}

	public Portal ValidateHighlightPortal(Hand hand, Portal portal)
	{
		if ((bool)portal && (bool)hand.portalFromHeadToHand)
		{
			if (portal == hand.portalFromHeadToHand)
			{
				return portal;
			}
			return null;
		}
		if (!portal && !hand.portalFromHeadToHand)
		{
			return null;
		}
		if (!portal)
		{
			return hand.portalFromHeadToHand;
		}
		return portal;
	}

	public void SetPortalVariant(PortalVariations portalVariation)
	{
		portalVariations = portalVariation;
	}

	public void OnVariantSetChanged(PortalVariations.VariantSet newSet)
	{
	}

	void IPrebuildEvent.OnPrebuildRoot(bool isPrefab)
	{
	}
}
public class HelperEffects
{
	[SerializeField]
	private Vector3 particleEffectsOffset = Vector3.zero;

	private GameObject shapeEffectObj;

	private GameObject glowEffectObj;

	private ParticleSystem linePS;

	private bool linePSActive;

	private ParticleSystem.Particle[] lineParticles;

	private GameObject[] uiArrows = new GameObject[4];

	private bool[] uiArrowsActive = new bool[4];

	private int maxParticlesPerLine;

	private float radius;

	private FMOD.Studio.EventInstance sfxEventInst;

	public void InitializeShape(Mesh mesh, Material material, Vector3 localPos, Quaternion localRot, Transform helperXForm)
	{
		shapeEffectObj = CreateUIObject(mesh, material, helperXForm);
		shapeEffectObj.transform.localPosition = localPos;
		shapeEffectObj.transform.localRotation = localRot;
	}

	public void InitializeGlow(Mesh mesh, Material material, Vector3 localPos, Quaternion localRot, Transform helperXForm)
	{
		glowEffectObj = CreateUIObject(mesh, material, helperXForm);
		glowEffectObj.transform.localPosition = localPos;
		glowEffectObj.transform.localRotation = localRot;
	}

	public void InitializeStaticParticles(Transform helperXForm)
	{
		UnityEngine.Object.Instantiate(BaseSettings<HelperSettings>.Inst.staticParticleEffect).transform.SetParent(helperXForm, worldPositionStays: false);
	}

	public void InitializeLineParticles(Transform helperXForm)
	{
		HelperSettings inst = BaseSettings<HelperSettings>.Inst;
		GameObject gameObject = UnityEngine.Object.Instantiate(inst.lineParticlePrefab);
		linePS = gameObject.GetComponent<ParticleSystem>();
		linePS.transform.SetParent(helperXForm, worldPositionStays: false);
		linePSActive = true;
		maxParticlesPerLine = inst.curveResolutionPerMetre * Mathf.CeilToInt(radius);
		lineParticles = new ParticleSystem.Particle[maxParticlesPerLine * 4];
	}

	public void InitializeArrows(Transform helperXForm)
	{
		HelperSettings inst = BaseSettings<HelperSettings>.Inst;
		for (int i = 0; i < uiArrows.Length; i++)
		{
			uiArrows[i] = CreateUIObject(inst.arrowMesh, inst.arrowMaterial, helperXForm);
			uiArrowsActive[i] = true;
		}
	}

	public void OnAwakeLR(float radius, Transform helperXForm)
	{
		this.radius = radius;
	}

	private static GameObject CreateUIObject(Mesh mesh, Material material, Transform parent)
	{
		GameObject gameObject = new GameObject(mesh.name);
		gameObject.transform.SetParent(parent, worldPositionStays: false);
		gameObject.AddComponent<MeshFilter>().sharedMesh = mesh;
		gameObject.AddComponent<MeshRenderer>().sharedMaterial = material;
		return gameObject;
	}

	public void UpdateGlow(Vector3[] localPositions, int positionCount)
	{
		float num = float.PositiveInfinity;
		for (int i = 0; i < positionCount; i++)
		{
			float sqrMagnitude = localPositions[i].sqrMagnitude;
			if (sqrMagnitude < num)
			{
				num = sqrMagnitude;
			}
		}
		float value = Mathf.Sqrt(num);
		float newVal = Mathf.InverseLerp(radius * 0.15f, radius, value);
		glowEffectObj.transform.localScale = Vector3X.one.RepY(newVal);
	}

	public void UpdateGlow(float[] sqrDistances, int arrLen)
	{
		float num = float.PositiveInfinity;
		for (int i = 0; i < arrLen; i++)
		{
			if (sqrDistances[i] < num)
			{
				num = sqrDistances[i];
			}
		}
		float value = Mathf.Sqrt(num);
		float num2 = Mathf.InverseLerp(radius * 0.15f, radius, value);
		if (num2 > 0f)
		{
			glowEffectObj.SetActive(value: true);
			glowEffectObj.transform.localScale = Vector3X.one.RepY(num2);
		}
		else
		{
			glowEffectObj.SetActive(value: false);
		}
	}

	public void HideLinePS()
	{
		if (linePSActive)
		{
			linePS.gameObject.SetActive(value: false);
			linePSActive = false;
		}
	}

	public void ShowLinePS()
	{
		if (!linePSActive)
		{
			linePS.gameObject.SetActive(value: true);
			linePSActive = true;
		}
	}

	public void UpdateLinePS(Vector3[] localPositions, int positionCount, HelperSettings settings)
	{
		if (positionCount == 0)
		{
			HideLinePS();
			return;
		}
		ShowLinePS();
		AnimationCurve particleAlphaCurve = settings.particleAlphaCurve;
		int num = positionCount * maxParticlesPerLine;
		int num2 = linePS.GetParticles(lineParticles);
		int num3 = 0;
		if (num2 < num)
		{
			linePS.Emit(num - num2);
			num2 = linePS.GetParticles(lineParticles);
		}
		for (int i = 0; i < positionCount; i++)
		{
			Vector3 vector = particleEffectsOffset;
			Vector3 vector2 = localPositions[i];
			Vector3 vector3 = vector2 - vector;
			float magnitude = vector3.magnitude;
			Vector3 normalized = vector3.normalized;
			float num4 = magnitude * settings.curveWeight;
			float num5 = (float)settings.curveResolutionPerMetre * magnitude;
			Vector3 p = particleEffectsOffset;
			Vector3 p2 = particleEffectsOffset + Vector3X.up * num4;
			Vector3 p3 = vector2 + -normalized * num4;
			Vector3 p4 = vector2;
			float num6 = 1f / num5;
			for (int j = 0; (float)j < num5; j++)
			{
				float num7 = num6 * 0.5f + num6 * (float)j;
				Vector3 position = VectorX.BezierCurve(p, p2, p3, p4, num7);
				lineParticles[num3].position = position;
				lineParticles[num3].startColor = lineParticles[num3].startColor.RepA((byte)(particleAlphaCurve.Evaluate(num7) * 255f));
				num3++;
			}
		}
		if (num2 > num3)
		{
			for (int num8 = num2 - 1; num8 >= num3; num8--)
			{
				lineParticles[num8] = default(ParticleSystem.Particle);
				num2--;
			}
		}
		linePS.SetParticles(lineParticles, num2);
	}

	public void UpdateSFX(bool shouldPlay, Transform helperXForm)
	{
		if (shouldPlay && !sfxEventInst.isValid())
		{
			sfxEventInst = FAC.Inst.PlayOneShot(BaseSettings<HelperSettings>.Inst.sfxProximityEvent, helperXForm);
		}
		else if (!shouldPlay && sfxEventInst.isValid())
		{
			sfxEventInst.stop(STOP_MODE.ALLOWFADEOUT);
		}
	}

	public void UpdateArrows(Vector3[] directionWS, int directionCount, Vector3 UpDirection)
	{
		for (int i = 0; i < uiArrows.Length; i++)
		{
			bool flag = false;
			if (i < directionCount)
			{
				flag = true;
				uiArrows[i].transform.rotation = Quaternion.LookRotation(directionWS[i], UpDirection);
			}
			if (uiArrowsActive[i] != flag)
			{
				uiArrows[i].SetActive(flag);
				uiArrowsActive[i] = flag;
			}
		}
	}

	public void ShowHideEffects(bool show)
	{
		shapeEffectObj.SetActive(show);
		glowEffectObj.SetActive(show);
	}
}
public class HookPoint : MonoBehaviour, IOwnerChangeListener
{
	public const float MAX_RADIUS = 0.5f;

	private const int MAX_DYNAMIC_TO_STATIC = 2;

	private Transform xform;

	[ReadOnly]
	[SerializeField]
	private ConfigurableJoint joint;

	[ReadOnly]
	[SerializeField]
	public GrabObject grabObjectOwner;

	[SerializeField]
	private float dragWithHook = 4f;

	private float dragWithoutHook;

	private Rigidbody rb;

	private PortalingRigidbody pr;

	[ReadOnly]
	public HookPoint hookAttachedToDynamicHook;

	private ConstArray<HookPoint> dynamicHooksAttachedToStaticHook = new ConstArray<HookPoint>(2u);

	private bool isDynamic;

	[ReadOnly]
	public bool IsJointOwner;

	private Collider[] hookColliders;

	public HagletValue<bool> hasHookedObject;

	private ConstArray<HookPoint> focusedHookPoints = new ConstArray<HookPoint>(4u);

	private Vector3[] focusedPositions = new Vector3[4];

	private float[] focusedSqrDistances = new float[4];

	public bool overrideAngularWhenHookedTo;

	[ConditionalHide("overrideAngularWhenHookedTo")]
	public ConfigurableJointMotion overrideXMotion = ConfigurableJointMotion.Free;

	[ConditionalHide("overrideAngularWhenHookedTo")]
	public ConfigurableJointMotion overrideYMotion = ConfigurableJointMotion.Free;

	[ConditionalHide("overrideAngularWhenHookedTo")]
	public ConfigurableJointMotion overrideZMotion = ConfigurableJointMotion.Free;

	[SerializeField]
	[FormerlySerializedAs("ShowHelper")]
	private bool showHelper = true;

	[SerializeField]
	private Vector3 particleEffectsOffset;

	[SerializeField]
	[FormerlySerializedAs("glowMeshOffset")]
	private Vector3 glowOffsetPos = Vector3.zero;

	[SerializeField]
	private Vector3 glowOffsetRot = Vector3.zero;

	[SerializeField]
	private Vector3 shapeOffsetPos = Vector3.zero;

	[SerializeField]
	private Vector3 shapeOffsetRot = Vector3.zero;

	[SerializeField]
	private Mesh overrideShapeMesh;

	[SerializeField]
	private Mesh overrideGlowMesh;

	private HelperEffects effects = new HelperEffects();

	private float radius;

	private HookPoint hookAttractedTo;

	private Vector3 velocity;

	public bool HasJoint => joint != null;

	public Wait OnHookedObject => Wait.Until.True(hasHookedObject, 1, allowPreMetNow: true);

	private void OnDisable()
	{
		while (dynamicHooksAttachedToStaticHook.Length != 0)
		{
			dynamicHooksAttachedToStaticHook[0].RemoveJoint(removeAttachment: false);
			RemoveAttachedHook(dynamicHooksAttachedToStaticHook[0]);
		}
	}

	public static void PartitionHooks(ConstArray<HookPoint> hooks)
	{
		int sLength = hooks.sLength;
		int num = 0;
		int num2 = sLength - 1;
		while (true)
		{
			if (num < sLength - 1 && hooks[num].isDynamic)
			{
				num++;
				continue;
			}
			while (num2 > 0 && !hooks[num2].isDynamic)
			{
				num2--;
			}
			if (num < num2)
			{
				HookPoint value = hooks[num2];
				hooks[num2] = hooks[num];
				hooks[num] = value;
				continue;
			}
			break;
		}
	}

	public static void OnAwakeLR(ConstArray<HookPoint> hooks)
	{
		for (int i = 0; i < hooks.Length; i++)
		{
			hooks[i].OnAwakeLR();
		}
		UpdateFocusedHooks(hooks, hooks.sLength);
		for (int j = 0; j < hooks.Length; j++)
		{
			HookPoint hookPoint = hooks[j];
			if (hookPoint.isDynamic)
			{
				hookPoint.TryToHookOntoSomething();
			}
		}
	}

	public void OnAwakeLR()
	{
		xform = base.transform;
		HelperSettings inst = BaseSettings<HelperSettings>.Inst;
		radius = inst.hookRadius;
		HagletValue.Create(out hasHookedObject, null, initVal: false, null, 8);
		rb = base.gameObject.GetComponentInAscendant<Rigidbody>();
		pr = rb.GetComponent<PortalingRigidbody>();
		grabObjectOwner = rb.GetComponent<GrabObject>();
		isDynamic |= grabObjectOwner;
		hookColliders = GetComponentsInChildren<Collider>();
		if (showHelper)
		{
			SetupEffects();
		}
	}

	public static void OnUpdateLR(ConstArray<HookPoint> hooks)
	{
		CC inst = CC.Inst;
		HelperSettings inst2 = BaseSettings<HelperSettings>.Inst;
		int sLength = hooks.sLength;
		for (int i = 0; i < sLength; i++)
		{
			HookPoint hookPoint = hooks[i];
			hookPoint.focusedHookPoints.ClearToDefault();
			if (hookPoint.isDynamic && (bool)hookPoint.hookAttachedToDynamicHook && !hookPoint.hookAttachedToDynamicHook.isDynamic)
			{
				hookPoint.AlignJoint(hookPoint.hookAttachedToDynamicHook);
			}
		}
		GrabObject grabObject = inst.handL.InteractableHeld as GrabObject;
		if ((bool)grabObject && (bool)grabObject.hookPoint)
		{
			grabObject.hookPoint.UpdateFocusedHooks(hooks, 0, sLength);
		}
		GrabObject grabObject2 = inst.handR.InteractableHeld as GrabObject;
		if ((bool)grabObject2 && (bool)grabObject2.hookPoint)
		{
			grabObject2.hookPoint.UpdateFocusedHooks(hooks, 0, sLength);
		}
		HelperSettings inst3 = BaseSettings<HelperSettings>.Inst;
		for (int j = 0; j < sLength; j++)
		{
			HookPoint hookPoint2 = hooks[j];
			hookPoint2.UpdateFocusedPositions();
			if (hookPoint2.isDynamic)
			{
				if ((bool)hookPoint2.hookAttractedTo)
				{
					hookPoint2.MoveToAttractingHook();
					if (Vector3.Distance(hookPoint2.hookAttractedTo.transform.position, hookPoint2.transform.position) < inst2.kinematicDistance)
					{
						hookPoint2.GenerateJoint(hookPoint2.hookAttractedTo);
						hookPoint2.SetHookAttractedTo(null);
					}
				}
				if (hookPoint2.showHelper)
				{
					if (inst.IsObjectGrabbed(hookPoint2.grabObjectOwner) || (bool)hookPoint2.hookAttractedTo)
					{
						hookPoint2.effects.UpdateLinePS(hookPoint2.focusedPositions, hookPoint2.focusedHookPoints.sLength, inst3);
					}
					else
					{
						hookPoint2.effects.HideLinePS();
					}
				}
			}
			if (hookPoint2.showHelper)
			{
				hookPoint2.effects.UpdateGlow(hookPoint2.focusedSqrDistances, hookPoint2.focusedHookPoints.sLength);
				hookPoint2.effects.UpdateSFX(hookPoint2.focusedHookPoints.Length != 0, hookPoint2.transform);
			}
		}
	}

	private void SetupEffects()
	{
		HelperSettings inst = BaseSettings<HelperSettings>.Inst;
		effects.OnAwakeLR(radius, base.transform);
		Mesh mesh = (overrideShapeMesh ? overrideShapeMesh : inst.hookShapeMesh);
		Material hookShapeMaterial = inst.hookShapeMaterial;
		Quaternion localRot = Quaternion.Euler(shapeOffsetRot);
		effects.InitializeShape(mesh, hookShapeMaterial, shapeOffsetPos, localRot, base.transform);
		Mesh mesh2 = (overrideGlowMesh ? overrideGlowMesh : inst.hookGlowMesh);
		Material hookGlowMaterial = inst.hookGlowMaterial;
		Quaternion localRot2 = Quaternion.Euler(glowOffsetRot);
		effects.InitializeGlow(mesh2, hookGlowMaterial, glowOffsetPos, localRot2, base.transform);
		if (isDynamic)
		{
			effects.InitializeLineParticles(base.transform);
		}
	}

	public void MoveToAttractingHook()
	{
		Vector3 position = base.transform.position;
		Vector3 vector = hookAttractedTo.transform.position - position;
		Vector3 vector2 = MathfX.ForceAtEndsOfSpring(BaseSettings<HelperSettings>.Inst.hookSpringStrength, -vector, BaseSettings<HelperSettings>.Inst.hookSpringDamping, velocity);
		velocity += vector2 * IC.DeltaTime;
		Vector3 vector3 = velocity * IC.DeltaTime;
		if (Mathf.Abs(vector3.x) > Mathf.Abs(vector.x))
		{
			vector3.x = vector.x;
			velocity.x = 0f;
		}
		if (Mathf.Abs(vector3.y) > Mathf.Abs(vector.y))
		{
			vector3.y = vector.y;
			velocity.y = 0f;
		}
		if (Mathf.Abs(vector3.z) > Mathf.Abs(vector.z))
		{
			vector3.z = vector.z;
			velocity.z = 0f;
		}
		Vector3 vector4 = grabObjectOwner.transform.position - base.transform.position;
		Vector3 worldPos = position + vector3 + vector4;
		grabObjectOwner.SetPositionAndRotation(worldPos, grabObjectOwner.transform.rotation);
	}

	public Collider[] GetColliders()
	{
		return hookColliders;
	}

	private void GenerateJoint(HookPoint other)
	{
		if (rb == other.rb || ((bool)other.joint && other.joint.connectedBody == rb))
		{
			return;
		}
		_ = joint != null;
		joint = rb.gameObject.AddComponent<ConfigurableJoint>();
		joint.xMotion = ConfigurableJointMotion.Limited;
		joint.yMotion = ConfigurableJointMotion.Limited;
		joint.zMotion = ConfigurableJointMotion.Limited;
		if (other.overrideAngularWhenHookedTo)
		{
			joint.angularXMotion = other.overrideXMotion;
			joint.angularYMotion = other.overrideYMotion;
			joint.angularZMotion = other.overrideZMotion;
		}
		dragWithoutHook = rb.drag;
		if (float.IsPositiveInfinity(dragWithoutHook))
		{
			if (CC.Inst.IsObjectGrabbedOrFocusGrabbed(grabObjectOwner))
			{
				dragWithoutHook = grabObjectOwner.OldDrag;
			}
			else
			{
				UnityEngine.Debug.Log("Saving infinite drag, this will break the grabobect physics!!!!!");
			}
		}
		if (!other.isDynamic)
		{
			rb.drag = dragWithHook;
		}
		joint.enableCollision = true;
		joint.anchor = rb.transform.InverseTransformPoint(xform.position);
		joint.autoConfigureConnectedAnchor = false;
		joint.connectedBody = other.rb;
		joint.connectedAnchor = other.rb.transform.InverseTransformPoint(other.xform.position);
		if ((bool)other.grabObjectOwner && CC.Inst.IsObjectGrabbed(other.grabObjectOwner))
		{
			other.IsJointOwner = true;
		}
		else
		{
			IsJointOwner = true;
		}
		hookAttachedToDynamicHook = other;
		if (other.isDynamic)
		{
			if ((bool)other.joint)
			{
				other.RemoveJoint();
				UnityEngine.Debug.Log("Other hook already has a joint, removing before assigning new joint", this);
			}
			other.hookAttachedToDynamicHook = this;
			other.joint = joint;
		}
		else
		{
			other.AddAttachedHook(this);
		}
		Collider[] array = hookColliders;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].gameObject.SetActive(value: false);
		}
		hasHookedObject.value = true;
		if ((bool)grabObjectOwner)
		{
			grabObjectOwner.inventoryObject.ShowHelperIcon = true;
		}
		if ((bool)other.grabObjectOwner)
		{
			other.grabObjectOwner.inventoryObject.ShowHelperIcon = true;
		}
		if ((bool)grabObjectOwner && grabObjectOwner.pr.justSwappedMimicTimer <= 0f)
		{
			FAC.Inst.PlayOneShot(BaseSettings<HelperSettings>.Inst.hookSound, base.transform.position);
		}
	}

	public void RemoveJoint(bool removeAttachment = true)
	{
		IsJointOwner = false;
		if ((bool)rb)
		{
			rb.drag = dragWithoutHook;
		}
		if ((bool)joint)
		{
			UnityEngine.Object.Destroy(joint);
			joint = null;
		}
		if ((bool)hookAttachedToDynamicHook)
		{
			hookAttachedToDynamicHook.hookAttachedToDynamicHook = null;
			if (!hookAttachedToDynamicHook.isDynamic && removeAttachment)
			{
				hookAttachedToDynamicHook.RemoveAttachedHook(this);
			}
			hookAttachedToDynamicHook.RemoveJoint();
			hookAttachedToDynamicHook = null;
		}
		Collider[] array = hookColliders;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].gameObject.SetActive(value: true);
		}
		hasHookedObject.value = false;
		if ((bool)grabObjectOwner)
		{
			grabObjectOwner.inventoryObject.ShowHelperIcon = false;
		}
	}

	public void RemoveAttachedHook(HookPoint hook)
	{
		dynamicHooksAttachedToStaticHook.Remove(hook);
	}

	public void AddAttachedHook(HookPoint hook)
	{
		dynamicHooksAttachedToStaticHook.Add(hook);
	}

	public void OnHandGrabEnter(bool grabbedFromInventory)
	{
		if (!grabbedFromInventory && (bool)hookAttachedToDynamicHook && isDynamic && hookAttachedToDynamicHook.isDynamic)
		{
			if (hookAttachedToDynamicHook.IsJointOwner)
			{
				hookAttachedToDynamicHook.IsJointOwner = false;
				IsJointOwner = true;
			}
			if (!CC.Inst.IsObjectGrabbed(hookAttachedToDynamicHook.grabObjectOwner))
			{
				return;
			}
		}
		RemoveJoint();
	}

	public void OnHandGrabExit()
	{
		TryToHookOntoSomething();
		ConfigurableJoint component = rb.GetComponent<ConfigurableJoint>();
		if ((bool)component && !joint)
		{
			UnityEngine.Object.Destroy(component);
			UnityEngine.Debug.Log("Extra joint found, attempting to destory again", this);
		}
	}

	private static bool CanHook(HookPoint hookA, HookPoint hookB)
	{
		if ((object)hookB == hookA)
		{
			return false;
		}
		if (!hookA.isActiveAndEnabled)
		{
			return false;
		}
		if (!hookB.isActiveAndEnabled)
		{
			return false;
		}
		if (Vector3.Distance(hookA.xform.position, hookB.xform.position) > hookA.radius + hookB.radius)
		{
			return false;
		}
		if ((object)hookB == hookA.hookAttachedToDynamicHook)
		{
			return false;
		}
		if ((object)hookB.hookAttachedToDynamicHook == hookA)
		{
			return false;
		}
		if (hookA.isDynamic && (bool)hookA.hookAttachedToDynamicHook && !hookA.hookAttachedToDynamicHook.isDynamic)
		{
			return false;
		}
		if (hookB.isDynamic && (bool)hookB.hookAttachedToDynamicHook && !hookB.hookAttachedToDynamicHook.isDynamic)
		{
			return false;
		}
		if (hookA.isDynamic && hookB.isDynamic && ((bool)hookA.hookAttachedToDynamicHook || (bool)hookB.hookAttachedToDynamicHook))
		{
			return false;
		}
		if (hookA.isDynamic && !hookB.isDynamic && hookB.dynamicHooksAttachedToStaticHook.Length == 2)
		{
			return false;
		}
		if (hookB.isDynamic && !hookA.isDynamic && hookA.dynamicHooksAttachedToStaticHook.Length == 2)
		{
			return false;
		}
		if (hookA.isDynamic && (bool)hookA.hookAttachedToDynamicHook && !hookB.isDynamic && hookB.dynamicHooksAttachedToStaticHook.Length >= 1)
		{
			return false;
		}
		if (hookB.isDynamic && (bool)hookB.hookAttachedToDynamicHook && !hookA.isDynamic && hookA.dynamicHooksAttachedToStaticHook.Length >= 1)
		{
			return false;
		}
		if (hookA.isDynamic && (bool)hookA.grabObjectOwner && !hookA.grabObjectOwner.HasControl)
		{
			return false;
		}
		if (hookB.isDynamic && (bool)hookB.grabObjectOwner && !hookB.grabObjectOwner.HasControl)
		{
			return false;
		}
		return true;
	}

	public void UpdateFocusedHooks(ConstArray<HookPoint> hooks, int startIdx, int count)
	{
		HookPoint hookPoint = null;
		Vector3 position = base.transform.position;
		int num = startIdx + count;
		for (int i = startIdx; i < num; i++)
		{
			HookPoint hookPoint2 = hooks[i];
			if (!CanHook(this, hookPoint2))
			{
				continue;
			}
			if ((bool)hookPoint)
			{
				float num2 = Vector3.Distance(hookPoint.transform.position, position);
				if (Vector3.Distance(hookPoint2.transform.position, position) < num2)
				{
					hookPoint.focusedHookPoints.Remove(this);
					focusedHookPoints.Remove(hookPoint);
					if (!focusedHookPoints.Contains(hookPoint2))
					{
						focusedHookPoints.Add(hookPoint2);
					}
					if (!hookPoint2.focusedHookPoints.Contains(this))
					{
						hookPoint2.focusedHookPoints.Add(this);
					}
					hookPoint = hookPoint2;
				}
			}
			else
			{
				if (!focusedHookPoints.Contains(hookPoint2))
				{
					focusedHookPoints.Add(hookPoint2);
				}
				if (!hookPoint2.focusedHookPoints.Contains(this))
				{
					hookPoint2.focusedHookPoints.Add(this);
				}
				hookPoint = hookPoint2;
			}
		}
	}

	public static void UpdateFocusedHooks(ConstArray<HookPoint> hooks, int arrLen)
	{
		for (int i = 0; i < arrLen; i++)
		{
			HookPoint hookPoint = hooks[i];
			if (hookPoint.isDynamic)
			{
				hookPoint.UpdateFocusedHooks(hooks, 0, arrLen);
			}
		}
	}

	private void UpdateFocusedPositions()
	{
		for (int i = 0; i < focusedHookPoints.sLength; i++)
		{
			Vector3 vector = base.transform.InverseTransformPoint(focusedHookPoints[i].transform.position);
			focusedPositions[i] = vector;
			float sqrMagnitude = vector.sqrMagnitude;
			float num = focusedHookPoints[i].radius * focusedHookPoints[i].radius;
			sqrMagnitude = ((num > sqrMagnitude) ? 0f : (sqrMagnitude - num));
			focusedSqrDistances[i] = sqrMagnitude;
		}
	}

	public void TryToHookOntoSomething()
	{
		float num = float.MaxValue;
		HookPoint hookPoint = null;
		Vector3 position = base.transform.position;
		for (int i = 0; i < focusedHookPoints.Length; i++)
		{
			HookPoint hookPoint2 = focusedHookPoints[i];
			float num2 = Vector3.Distance(position, hookPoint2.transform.position);
			if (hookPoint == null || (hookPoint.isDynamic && !hookPoint2.isDynamic) || num2 < num)
			{
				hookPoint = hookPoint2;
				num = num2;
			}
		}
		if (!hookPoint)
		{
			return;
		}
		HookPoint hookPoint3 = hookAttachedToDynamicHook;
		if ((bool)hookPoint3)
		{
			if ((bool)joint)
			{
				RemoveJoint();
			}
			else
			{
				hookPoint3.RemoveJoint();
			}
			hookPoint3.SetHookAttractedTo(hookPoint);
		}
		SetHookAttractedTo(hookPoint);
	}

	private void SetHookAttractedTo(HookPoint hook)
	{
		hookAttractedTo = hook;
		velocity = Vector3X.zero;
		grabObjectOwner.pr.SetKinematic(hook != null);
	}

	private void AlignJoint(HookPoint connectedHook)
	{
		Vector3 vector = ((pr != null) ? pr.ObjGravity : grabObjectOwner.pr.ObjGravity);
		Vector3 forward = connectedHook.xform.forward;
		Vector3 right = connectedHook.xform.right;
		Vector3 rhs = (((double)Vector3.Dot(vector, forward) > 0.99) ? right : forward);
		Vector3 normalized = Vector3.Cross(vector, rhs).normalized;
		if (Vector3.Dot(base.transform.forward, normalized) < 0f)
		{
			normalized *= -1f;
		}
		Quaternion targetRotation = Quaternion.LookRotation(normalized, -vector);
		Vector3 torque = CalculateTorque(rb, targetRotation, 100f, 1f);
		rb.AddTorque(torque, ForceMode.Force);
	}

	public static Vector3 CalculateTorque(Rigidbody rigidbody, Quaternion targetRotation, float springTightness, float springDamping)
	{
		Quaternion quaternion = Quaternion.Inverse(targetRotation);
		Vector3 vector = quaternion * rigidbody.angularVelocity;
		vector.x = 0f;
		vector.z = 0f;
		Vector3 rhs = quaternion * rigidbody.transform.forward;
		rhs.y = 0f;
		Vector3 vector2 = Vector3.Cross(Vector3.forward, rhs);
		Vector3 vector3 = (0f - springTightness) * vector2 - springDamping * vector;
		Vector3 vector4 = Vector3.Scale(Quaternion.Inverse(rigidbody.inertiaTensorRotation) * vector3, rigidbody.inertiaTensor);
		Vector3 vector5 = rigidbody.inertiaTensorRotation * vector4;
		return targetRotation * vector5;
	}

	void IOwnerChangeListener.OnOwnerChange(MRBase _oldOwner, MRBase _newOwner)
	{
		MRBase.TransferObject(_oldOwner, _newOwner, this);
	}
}
public interface IDoNotClone
{
}
public abstract class InteractableTarget : IDObject, IPrebuildEvent
{
	[Serializable]
	public struct SnapPoint
	{
		[Range(0f, 1f)]
		public float snapPosition;

		[Range(0f, 1f)]
		public float snapRange;
	}

	public float snapStrength = 300f;

	public float snapDampening = 50f;

	public SnapPoint[] snapPoints;

	[Range(-10f, 10f)]
	public float deltaModifier = 1f;

	[ReadOnly]
	[Serializer.IncludeField]
	public float normalisedPostion;

	public abstract void OnPrebuildRoot(bool isPrefab);

	public abstract bool ConstrainDelta(float delta, out float newDelta);

	public abstract void SetPosition(float delta);

	public virtual bool GetSnapPoint(out float closestDist, out InteractableTarget closestTarget)
	{
		closestDist = float.MaxValue;
		closestTarget = this;
		bool result = false;
		if (snapPoints != null)
		{
			for (int i = 0; i < snapPoints.Length; i++)
			{
				float num = MathfX.Modulus(normalisedPostion, 1f) - snapPoints[i].snapPosition;
				float num2 = Mathf.Abs(num);
				if (num2 < snapPoints[i].snapRange && num2 < Mathf.Abs(closestDist))
				{
					result = true;
					closestDist = num;
				}
			}
		}
		return result;
	}
}
[ExecuteInEditMode]
public class InteractableTarget_Animation : InteractableTarget, ILateUpdateEvent
{
	[Serializable]
	public struct SoundThreshhold
	{
		public float time;

		public FMODEventAsset sound;

		public Transform soundLocation;
	}

	[SerializeField]
	[HideInInspector]
	private Animation anim;

	[Range(0f, 1f)]
	public float intialSample;

	public bool shouldConstrain = true;

	public bool mustRestAtSnapPoint;

	private int framesSinceInput;

	private float lastDeltaPerSec;

	public bool drawGizmos;

	[ConditionalHide("drawGizmos")]
	public int gizmoSteps = 10;

	[NonSerialized]
	[HideInInspector]
	public bool Disabled;

	public SoundThreshhold[] Sounds = new SoundThreshhold[0];

	public override void OnPrebuildRoot(bool isPrefab)
	{
		anim = GetComponent<Animation>();
		normalisedPostion = intialSample;
	}

	public override void OnAwakeLR(MRBase owner)
	{
		base.OnAwakeLR(owner);
	}

	public override bool ConstrainDelta(float delta, out float newDelta)
	{
		newDelta = delta;
		if (!shouldConstrain || Disabled)
		{
			return false;
		}
		if ((bool)anim && (bool)anim.clip)
		{
			float num = normalisedPostion + delta;
			float num2 = delta * deltaModifier;
			if (num < 0f)
			{
				float num3 = num2 - num;
				newDelta = num3 / deltaModifier;
				return true;
			}
			if (num > 1f)
			{
				float num4 = num2 - (num - 1f);
				newDelta = num4 / deltaModifier;
				return true;
			}
		}
		return false;
	}

	public override void SetPosition(float delta)
	{
		if (!Disabled)
		{
			framesSinceInput = 0;
			lastDeltaPerSec = delta / IC.DeltaTime;
			SetAnimPosition(delta * deltaModifier);
		}
	}

	private void SetAnimPosition(float delta)
	{
		if (!anim || !anim.clip)
		{
			return;
		}
		float num = MathfX.Modulus(normalisedPostion, 1f);
		float num2 = MathfX.Modulus(normalisedPostion + delta, 1f);
		for (int i = 0; i < Sounds.Length; i++)
		{
			SoundThreshhold soundThreshhold = Sounds[i];
			if ((delta > 0f && num < soundThreshhold.time && num2 >= soundThreshhold.time) || (delta < 0f && num > soundThreshhold.time && num2 <= soundThreshhold.time))
			{
				FAC.Inst.PlayOneShot(soundThreshhold.sound, soundThreshhold.soundLocation);
			}
		}
		anim[anim.clip.name].enabled = true;
		anim[anim.clip.name].speed = 0f;
		anim[anim.clip.name].weight = 1f;
		anim[anim.clip.name].normalizedTime = (normalisedPostion += delta);
	}

	void ILateUpdateEvent.OnLateUpdateLR()
	{
		if (Disabled)
		{
			return;
		}
		framesSinceInput++;
		if (framesSinceInput <= 3 || !mustRestAtSnapPoint)
		{
			return;
		}
		float num = MathfX.Modulus(normalisedPostion, 1f);
		float? num2 = null;
		float? num3 = null;
		float num4 = float.PositiveInfinity;
		for (int i = 0; i < snapPoints.Length; i++)
		{
			float snapPosition = snapPoints[i].snapPosition;
			float num5 = Mathf.Abs(snapPosition - num);
			if (num5 < num4)
			{
				num3 = snapPosition;
				num4 = num5;
			}
			if (snapPosition >= num && (!num2.HasValue || snapPosition < num2))
			{
				num2 = snapPosition;
			}
		}
		float num6 = 0f;
		if (num4 < 0.05f)
		{
			num6 = num3.Value - num;
		}
		else if (num2.HasValue)
		{
			float num7 = num2.Value;
			num6 = lastDeltaPerSec * IC.DeltaTime;
			num6 = ((num6 + normalisedPostion > num7) ? (num7 - normalisedPostion) : num6);
		}
		if (num6 != 0f)
		{
			SetAnimPosition(num6 * deltaModifier);
		}
	}
}
public class InteractableTarget_Animation_GizmoPoint : MonoBehaviour
{
	public Color gizmoColor = Color.red;
}
public class InteractableTarget_Events : InteractableTarget, IUpdateEvent, IPrepareEvent
{
	[Range(0.1f, 1f)]
	public float powerDecayTime = 0.1f;

	public Event OnDriveStart;

	public Event OnDriveStop;

	private float power;

	private IHaglet prepareEventRoutine;

	public override void OnPrebuildRoot(bool isPrefab)
	{
	}

	public override void OnAwakeLR(MRBase owner)
	{
		base.OnAwakeLR(owner);
		Haglet.Create(out prepareEventRoutine, PrepareEventRoutine);
	}

	Wait IPrepareEvent.PrepareEvents()
	{
		return prepareEventRoutine.Start();
	}

	private IEnumerator<Routine.Yield> PrepareEventRoutine()
	{
		OnDriveStart.PrepareInvoke();
		yield return Wait.For.LRUpdates(1);
		OnDriveStop.PrepareInvoke();
	}

	void IUpdateEvent.OnUpdateLR()
	{
		if (power > 0f)
		{
			float deltaTime = IC.DeltaTime;
			power = ((deltaTime > power) ? 0f : (power - deltaTime));
			if (power <= 0f)
			{
				OnDriveStop.Invoke();
			}
		}
	}

	public override bool ConstrainDelta(float delta, out float newDelta)
	{
		newDelta = delta;
		return false;
	}

	public override void SetPosition(float delta)
	{
		if (power <= 0f)
		{
			OnDriveStart.Invoke();
		}
		power = powerDecayTime;
	}
}
[RequireComponent(typeof(GearMachine))]
public class InteractableTarget_GearMachine : InteractableTarget
{
	[SerializeField]
	[HideInInspector]
	private GearMachine machine;

	public override bool ConstrainDelta(float delta, out float newDelta)
	{
		if (machine.ConstrainDelta(delta * deltaModifier * 360f, out newDelta))
		{
			newDelta /= 360f;
			return true;
		}
		return false;
	}

	public override void OnPrebuildRoot(bool isPrefab)
	{
		machine = GetComponent<GearMachine>();
	}

	public override void OnAwakeLR(MRBase owner)
	{
		base.OnAwakeLR(owner);
	}

	public override void SetPosition(float delta)
	{
		float t = normalisedPostion * 360f + delta * deltaModifier * 360f;
		t = Mathf.Repeat(t, 360f);
		normalisedPostion = Mathf.InverseLerp(0f, 360f, t);
		machine.ApplyDrive(delta * deltaModifier * 360f);
	}

	public override bool GetSnapPoint(out float closestDist, out InteractableTarget closestTarget)
	{
		closestTarget = this;
		return machine.GetSnapPoint(out closestDist, ref closestTarget);
	}
}
[ExecuteInEditMode]
public class InteractableTarget_Position : InteractableTarget
{
	[SerializeField]
	[HideInInspector]
	private Vector3 startPoint;

	[SerializeField]
	[HideInInspector]
	private Vector3 endPoint;

	[Range(0f, 20f)]
	public float Length = 1f;

	[SerializeField]
	private bool startAtGreenNode;

	public override void OnPrebuildRoot(bool isPrefab)
	{
		normalisedPostion = (startAtGreenNode ? 1 : 0);
	}

	public override void OnAwakeLR(MRBase owner)
	{
		base.OnAwakeLR(owner);
		SetPosition(0f);
	}

	public override void OnDestroy()
	{
		if (UnityEngine.Application.isPlaying)
		{
			base.OnDestroy();
		}
	}

	public override void SetPosition(float delta)
	{
		_ = deltaModifier;
		normalisedPostion += delta * deltaModifier / (endPoint - startPoint).magnitude;
		normalisedPostion = Mathf.Clamp01(normalisedPostion);
		for (int i = 0; i < base.transform.childCount; i++)
		{
			base.transform.GetChild(i).localPosition = Vector3.Lerp(endPoint, startPoint, normalisedPostion);
		}
	}

	public override bool ConstrainDelta(float delta, out float newDelta)
	{
		bool result = false;
		float num = delta * deltaModifier;
		newDelta = delta;
		for (int i = 0; i < base.transform.childCount; i++)
		{
			float num2 = base.transform.GetChild(i).localPosition.y + num;
			if (num2 >= startPoint.y)
			{
				float num3 = num - (num2 - startPoint.y);
				num3 /= deltaModifier;
				if (Mathf.Abs(num3) < Mathf.Abs(newDelta))
				{
					newDelta = num3;
					result = true;
				}
			}
			else if (num2 <= endPoint.y)
			{
				float num4 = num - (num2 - endPoint.y);
				num4 /= deltaModifier;
				if (Mathf.Abs(num4) < Mathf.Abs(newDelta))
				{
					newDelta = num4;
					result = true;
				}
			}
		}
		return result;
	}
}
public class InteractableTarget_Rotation : InteractableTarget
{
	[SerializeField]
	[HideInInspector]
	private float minAngle;

	[SerializeField]
	[HideInInspector]
	private float maxAngle;

	[Range(0f, 359f)]
	public float coneAngle;

	private float totalAngle;

	public override void OnPrebuildRoot(bool isPrefab)
	{
		normalisedPostion = 0f;
	}

	public override void OnAwakeLR(MRBase owner)
	{
		base.OnAwakeLR(owner);
		totalAngle = ((coneAngle != 0f) ? (maxAngle - minAngle) : 360f);
		SetPosition(0f);
	}

	public static Quaternion GetRotation(Vector2 direction)
	{
		Vector3 normalized = new Vector3(direction.x, direction.y, 0f).normalized;
		Vector3 normalized2 = Vector3.Cross(Vector3.forward, normalized).normalized;
		return Quaternion.LookRotation(Vector3.Cross(normalized, normalized2).normalized, normalized);
	}

	public override void SetPosition(float delta)
	{
		delta *= 360f * deltaModifier;
		normalisedPostion += delta / totalAngle;
		normalisedPostion = MathfX.Modulus(normalisedPostion, 1f);
		float b = ((coneAngle != 0f) ? maxAngle : 360f);
		float z = Mathf.Lerp(minAngle, b, normalisedPostion);
		base.transform.localRotation = Quaternion.Euler(0f, 0f, z);
	}

	public override bool ConstrainDelta(float delta, out float newDelta)
	{
		bool result = false;
		newDelta = delta;
		if (coneAngle == 0f)
		{
			return result;
		}
		float num = delta * deltaModifier * 360f;
		float num2 = base.transform.localRotation.eulerAngles.z;
		if (num2 > 180f)
		{
			num2 -= 360f;
		}
		float num3 = num2 + num;
		if (num3 < minAngle)
		{
			newDelta = (minAngle - num2) / deltaModifier / 360f;
			result = true;
		}
		if (num3 > maxAngle)
		{
			newDelta = (maxAngle - num2) / deltaModifier / 360f;
			result = true;
		}
		return result;
	}
}
[Serializer.ExcludeAllFields]
public abstract class InteractableObject : IDObject, IPrebuildEvent, IPrepareEvent
{
	[Serializable]
	public struct InteractableObjectEvents
	{
		public Event objectGrab;

		public Event objectRelease;
	}

	private struct FocusHightlightData
	{
		public GrabPoint grabPoint;

		public Portal portal;
	}

	public InteractableObjectEvents objectEvents;

	[HideInInspector]
	public bool isSubInteractive;

	[SerializeField]
	[Serializer.IncludeField]
	protected ConstArray<InteractableObject> subInteractables = new ConstArray<InteractableObject>(5u);

	[SerializeField]
	[HideInInspector]
	public ProximityHighlightPoint[] highlightPoints = new ProximityHighlightPoint[0];

	private FocusHightlightData leftHandHighlight;

	private FocusHightlightData rightHandHighlight;

	private ProximityHighlightPoint.HighlightInstance leftHandInstance = new ProximityHighlightPoint.HighlightInstance();

	private ProximityHighlightPoint.HighlightInstance rightHandInstance = new ProximityHighlightPoint.HighlightInstance();

	[HideInInspector]
	public Bounds combindedBounds;

	[HideInInspector]
	public ConstArray<GrabPoint> grabPoints = new ConstArray<GrabPoint>(128u);

	public bool shouldRasterize = true;

	[ReadOnly]
	[Serializer.IncludeField]
	public ObjectMimic mimic;

	[HideInInspector]
	public float furthestGrabPointDistSqr;

	private InteractionSettings settings;

	private IHaglet prepareEventRoutine;

	private ConstArray<ProximityHighlightPoint> proximityDrawnHighlights = new ConstArray<ProximityHighlightPoint>(50u);

	public bool HasControl
	{
		get
		{
			if ((bool)mimic)
			{
				return mimic.HasControl;
			}
			return true;
		}
	}

	public override void OnOwnerChange(MRBase _oldOwner, MRBase _newOwner)
	{
		base.OnOwnerChange(_oldOwner, _newOwner);
		MRBase.TransferObject(_oldOwner, _newOwner, this);
	}

	public InteractableObject OnGrabEnter(Hand hand, bool grabbedFromInventory, bool isSwappingHand)
	{
		objectEvents.objectGrab.Invoke();
		return OnGrabEntered(hand, grabbedFromInventory, isSwappingHand);
	}

	public void OnGrabExit(Hand hand)
	{
		objectEvents.objectRelease.Invoke();
		OnGrabExited(hand);
	}

	protected abstract InteractableObject OnGrabEntered(Hand hand, bool grabbedFromInventory, bool isSwappingHand);

	public abstract void OnGrabStayed(Hand hand);

	protected abstract void OnGrabExited(Hand hand);

	public virtual void SetHandGrabTransform(Hand hand)
	{
		hand.renderingRoot.rotation = hand.grabPointHeld.transform.rotation;
		hand.renderingRoot.position = hand.grabPointHeld.transform.position;
		Vector3 vector = hand.renderingRoot.InverseTransformPointUnscaled(hand.GetHandPalmPosition());
		vector = hand.renderingRoot.rotation * -vector;
		hand.renderingRoot.transform.position += vector;
	}

	public virtual void SetPositionAndRotationForGrabPoint(Transform grabPointXForm, Vector3 worldPosition, Quaternion rotation, CC.MovementType type = CC.MovementType.None)
	{
		Vector3 point = grabPointXForm.InverseTransformPointUnscaled(base.transform.position);
		Quaternion quaternion = grabPointXForm.InverseTransformRotation(base.transform.rotation);
		Vector3 worldPos = Matrix4x4.TRS(worldPosition, rotation, Vector3.one).MultiplyPoint3x4(point);
		Quaternion worldRot = rotation * quaternion;
		SetPositionAndRotation(worldPos, worldRot, type);
		if ((bool)mimic)
		{
			mimic.UpdateMimic();
		}
	}

	public InteractableObject OnFocusGrab(Hand hand, out bool grabbedFromInventory)
	{
		return OnFocusGrabbed(hand, out grabbedFromInventory);
	}

	public virtual void OnFocusGrabbing(Hand hand)
	{
	}

	public virtual InteractableObject OnFocusGrabbed(Hand hand, out bool grabbedFromInventory)
	{
		grabbedFromInventory = false;
		return this;
	}

	public static void OnUpdateLR(ConstArray<InteractableObject> objs)
	{
		float deltaTime = IC.DeltaTime;
		CC inst = CC.Inst;
		InteractableObject interactableHeld = inst.handL.InteractableHeld;
		InteractableObject interactableHeld2 = inst.handR.InteractableHeld;
		for (int i = 0; i < objs.Length; i++)
		{
			InteractableObject interactableObject = objs[i];
			if ((bool)interactableObject && interactableObject.isActiveAndEnabled)
			{
				interactableObject.OnUpdateLR(deltaTime, interactableHeld, interactableHeld2);
			}
		}
	}

	public static void PostPhysicsUpdateLR(ConstArray<InteractableObject> objs)
	{
		float deltaTime = IC.DeltaTime;
		CC inst = CC.Inst;
		InteractableObject interactableHeld = inst.handL.InteractableHeld;
		InteractableObject interactableHeld2 = inst.handR.InteractableHeld;
		for (int i = 0; i < objs.Length; i++)
		{
			InteractableObject interactableObject = objs[i];
			if ((bool)interactableObject && interactableObject.isActiveAndEnabled)
			{
				interactableObject.OnPostPhysicsUpdateLR(deltaTime, interactableHeld, interactableHeld2);
			}
		}
	}

	protected abstract void OnUpdateLR(float deltaTime, InteractableObject handLHeld, InteractableObject handRHeld);

	public virtual void OnEndOfUpdate(bool inPlayerScene)
	{
	}

	public virtual void OnPostPhysicsUpdateLR(float deltaTime, InteractableObject handLHeld, InteractableObject handRHeld)
	{
	}

	public bool CanHold(Hand hand)
	{
		if (!base.enabled)
		{
			return false;
		}
		if (!base.gameObject.activeInHierarchy)
		{
			return false;
		}
		if (!HasControl)
		{
			return false;
		}
		return true;
	}

	public bool CanGrab(Hand hand)
	{
		if (LR.Inst.IsInCutscene)
		{
			return false;
		}
		if (!CanHold(hand))
		{
			return false;
		}
		return CanBeGrabbed();
	}

	protected abstract bool CanBeGrabbed();

	public abstract bool CanBeFocusGrabbed();

	public GrabPoint GetFocusGrabPoint(int grabPointIdx)
	{
		if (grabPointIdx >= grabPoints.sLength)
		{
			grabPointIdx = 0;
		}
		return grabPoints[grabPointIdx];
	}

	public abstract void SetVelocityLinear(Vector3 velocityLinear);

	public abstract void SetVelocityAngular(Vector3 velocityAngular);

	public abstract void SetPositionAndRotation(Vector3 worldPos, Quaternion worldRot, CC.MovementType type = CC.MovementType.None);

	public virtual bool HasTriggerColliders()
	{
		return false;
	}

	public virtual void OnPrebuildRoot(bool isPrefab)
	{
	}

	public override void OnAwakeLR(MRBase owner)
	{
		base.OnAwakeLR(owner);
		combindedBounds = InventoryObject.CalculateCombinedBounds(base.transform);
		if (objectEvents.objectGrab == null)
		{
			objectEvents.objectGrab = new Event();
		}
		if (objectEvents.objectRelease == null)
		{
			objectEvents.objectRelease = new Event();
		}
		settings = BaseSettings<InteractionSettings>.Inst;
		Haglet.Create(out prepareEventRoutine, PrepareEventRoutine);
	}

	public virtual Wait PrepareEvents()
	{
		return prepareEventRoutine.Start();
	}

	private IEnumerator<Routine.Yield> PrepareEventRoutine()
	{
		objectEvents.objectGrab.PrepareInvoke();
		yield return Wait.For.LRUpdates(1);
		objectEvents.objectRelease.PrepareInvoke();
	}

	public void IntialiseHighlight()
	{
		PortalVariations[] componentsInChildren = GetComponentsInChildren<PortalVariations>(includeInactive: true);
		highlightPoints = GetComponentsInChildren<ProximityHighlightPoint>(includeInactive: true);
		if (highlightPoints.Length == 0)
		{
			if (componentsInChildren.Length != 0)
			{
				for (int i = 0; i < componentsInChildren.Length; i++)
				{
					PortalVariations.Variant[] variants = componentsInChildren[i].variants;
					for (int j = 0; j < variants.Length; j++)
					{
						PortalVariations.Variant variant = variants[j];
						if (variant.root != null)
						{
							variant.root.AddComponent<ProximityHighlightPoint>();
						}
					}
				}
			}
			else
			{
				base.gameObject.AddComponent<ProximityHighlightPoint>();
			}
			highlightPoints = GetComponentsInChildren<ProximityHighlightPoint>(includeInactive: true);
		}
		for (int k = 0; k < highlightPoints.Length; k++)
		{
			highlightPoints[k].interactableObject = this;
		}
	}

	public int RegisterGrabPoint(GrabPoint grabPoint)
	{
		uint length = grabPoints.Length;
		grabPoints.Add(grabPoint);
		furthestGrabPointDistSqr = Mathf.Max(b: (grabPoint.transform.position - base.transform.position).sqrMagnitude, a: furthestGrabPointDistSqr);
		return (int)length;
	}

	public virtual void ValidateGrabPoints()
	{
		if (grabPoints.Length == 0)
		{
			base.gameObject.AddComponent<GrabPoint>().OnAwakeLR();
		}
	}

	public virtual bool ShouldProximityHighlight()
	{
		CC inst = CC.Inst;
		if ((CanGrab(inst.handL) || CanGrab(inst.handR)) && !isSubInteractive)
		{
			return !inst.IsObjectGrabbedOrFocusGrabbed(this);
		}
		return false;
	}

	public virtual bool ShouldFocusHighlight()
	{
		CC inst = CC.Inst;
		if (!CanGrab(inst.handL))
		{
			return CanGrab(inst.handR);
		}
		return true;
	}

	public ConstArray<ProximityHighlightPoint> GatherHighlightPoints(Portal portal, MainCamera.HighlightDrawer drawer, HashSet<ProximityHighlightPoint> lastValid, Vector3 headPos, Vector3 handLPos, Vector3 handRPos, float distanceFromPortal = 0f)
	{
		proximityDrawnHighlights.Clear();
		bool flag = leftHandHighlight.grabPoint != null && IsPortalHighlightValid(leftHandHighlight.portal, portal, leftHandHighlight.grabPoint);
		bool flag2 = rightHandHighlight.grabPoint != null && IsPortalHighlightValid(rightHandHighlight.portal, portal, rightHandHighlight.grabPoint);
		bool flag3 = ShouldFocusHighlight() && (flag || flag2);
		for (int i = 0; i < highlightPoints.Length; i++)
		{
			ProximityHighlightPoint proximityHighlightPoint = highlightPoints[i];
			bool flag4 = WithinProximityDistance(proximityHighlightPoint.transform.position, portal, distanceFromPortal, headPos, handLPos, handRPos);
			if ((!flag4 && !lastValid.Contains(proximityHighlightPoint)) || !IsPortalProximityValid(portal, proximityHighlightPoint))
			{
				continue;
			}
			bool flag5 = !flag3 && ShouldProximityHighlight();
			flag5 &= ValidateHighlightPoint(proximityHighlightPoint, portal, headPos, handLPos, handRPos, flag4, out var nodePos);
			ProximityHighlightPoint.HighLightData highlightData = proximityHighlightPoint.instance.GetHighlightData(portal, settings.highlightProximitySize);
			if (flag5 || highlightData.alpha > 0f)
			{
				highlightData.worldPos = nodePos;
				highlightData.up = CC.Inst.transform.up;
				float target = (flag5 ? 1f : 0f);
				float num = 1f / settings.highlightFadeOutTime;
				highlightData.alpha = Mathf.MoveTowards(highlightData.alpha, target, num * IC.DeltaTime);
				highlightData.color = Color.white;
				drawer.AddProxHighlight(highlightData);
				proximityHighlightPoint.instance.SetHighlightData(highlightData, portal, settings.highlightProximitySize);
				if (highlightData.alpha > 0f)
				{
					proximityDrawnHighlights.Add(proximityHighlightPoint);
				}
			}
		}
		DrawFocusHighlight(IC.Hand.Left, drawer, flag, leftHandInstance, leftHandHighlight, portal);
		DrawFocusHighlight(IC.Hand.Right, drawer, flag2, rightHandInstance, rightHandHighlight, portal);
		return proximityDrawnHighlights;
	}

	private bool ValidateHighlightPoint(ProximityHighlightPoint point, Portal portal, Vector3 headPos, Vector3 handLPos, Vector3 handRPos, bool inRange, out Vector3 nodePos)
	{
		Vector3 worldPos = (nodePos = point.transform.position);
		if ((bool)portal && (bool)portal.Link)
		{
			worldPos = portal.Link.CalculatePortalObjectTransform(worldPos, Quaternion.identity, Vector3.zero).position;
		}
		Vector3 vector = default(Vector3);
		vector.x = worldPos.x - headPos.x;
		vector.y = worldPos.y - headPos.y;
		vector.z = worldPos.z - headPos.z;
		float num = Mathf.Sqrt(vector.x * vector.x + vector.y * vector.y + vector.z * vector.z);
		vector.x /= num;
		vector.y /= num;
		vector.z /= num;
		float num2 = Vector3.Angle((IC.GetHeadRotation() * Vector3.forward).normalized, vector);
		if (inRange && num2 < settings.highlightLookAtAngle)
		{
			Ray ray = new Ray(headPos, vector);
			int num3 = 1048577;
			LR.RayPortalResult rayPortalResult = LR.RayTransformWithPortals(ray, num, num3 | 0x400);
			if (((rayPortalResult.hit.distance > num) ? null : rayPortalResult.portal) == portal)
			{
				Vector3 vector2 = default(Vector3);
				vector2.x = rayPortalResult.ray.origin.x - point.transform.position.x;
				vector2.y = rayPortalResult.ray.origin.y - point.transform.position.y;
				vector2.z = rayPortalResult.ray.origin.z - point.transform.position.z;
				num = Mathf.Sqrt(vector2.x * vector2.x + vector2.y * vector2.y + vector2.z * vector2.z);
				if (!Physics.Raycast(rayPortalResult.ray, out var _, num, num3, QueryTriggerInteraction.Ignore))
				{
					float highlightProximitySize = settings.highlightProximitySize;
					Vector3 extents = combindedBounds.extents;
					float num4 = ((!(extents.x > extents.y)) ? (((extents.y > extents.z) ? extents.y : extents.z) * 1.5f) : ((extents.x > extents.z) ? extents.x : extents.z));
					float num5 = highlightProximitySize + num4;
					Vector3 origin = default(Vector3);
					origin.x = point.transform.position.x - num5 * rayPortalResult.ray.direction.x;
					origin.y = point.transform.position.y - num5 * rayPortalResult.ray.direction.y;
					origin.z = point.transform.position.z - num5 * rayPortalResult.ray.direction.z;
					if (Physics.SphereCast(new Ray(origin, rayPortalResult.ray.direction), highlightProximitySize, out var hitInfo2, num5, 2048))
					{
						nodePos.x = origin.x + rayPortalResult.ray.direction.x * hitInfo2.distance;
						nodePos.y = origin.y + rayPortalResult.ray.direction.y * hitInfo2.distance;
						nodePos.z = origin.z + rayPortalResult.ray.direction.z * hitInfo2.distance;
						Vector3 vector3 = default(Vector3);
						vector3.x = nodePos.x - headPos.x;
						vector3.y = nodePos.y - headPos.y;
						vector3.z = nodePos.z - headPos.z;
						if (Mathf.Sqrt(vector3.x * vector3.x + vector3.y * vector3.y + vector3.z * vector3.z) < 0.25f)
						{
							return false;
						}
					}
					return true;
				}
			}
		}
		return false;
	}

	public bool WithinProximityDistance(Vector3 position, Portal portal, float distanceFromPortal, Vector3 headPos, Vector3 handLPos, Vector3 handRPos)
	{
		if (!portal)
		{
			_ = CC.Inst;
			Vector3 vector = default(Vector3);
			vector.x = position.x - headPos.x;
			vector.y = position.y - headPos.y;
			vector.z = position.z - headPos.z;
			float sqrMagnitude = vector.sqrMagnitude;
			Vector3 vector2 = default(Vector3);
			vector2.x = position.x - handLPos.x;
			vector2.y = position.y - handLPos.y;
			vector2.z = position.z - handLPos.z;
			float sqrMagnitude2 = vector2.sqrMagnitude;
			Vector3 vector3 = default(Vector3);
			vector3.x = position.x - handRPos.x;
			vector3.y = position.y - handRPos.y;
			vector3.z = position.z - handRPos.z;
			float sqrMagnitude3 = vector3.sqrMagnitude;
			float num = ((!(sqrMagnitude < sqrMagnitude2)) ? ((sqrMagnitude2 < sqrMagnitude3) ? sqrMagnitude2 : sqrMagnitude3) : ((sqrMagnitude < sqrMagnitude3) ? sqrMagnitude : sqrMagnitude3));
			float num2 = settings.highlightProximityDist * settings.highlightProximityDist;
			return num < num2;
		}
		return Vector3.Distance(position, portal.Link.GetClosestPointOnPortal(position)) <= distanceFromPortal;
	}

	public void OnHighlightEnter(Hand hand, GrabPoint grabPoint, Portal portal)
	{
		if (hand.ICHand == IC.Hand.Left)
		{
			leftHandHighlight.grabPoint = grabPoint;
			leftHandHighlight.portal = portal;
		}
		else
		{
			rightHandHighlight.grabPoint = grabPoint;
			rightHandHighlight.portal = portal;
		}
	}

	public void OnHightlightExit(Hand hand)
	{
		if (hand.ICHand == IC.Hand.Left)
		{
			leftHandHighlight.grabPoint = null;
			leftHandHighlight.portal = null;
		}
		else
		{
			rightHandHighlight.grabPoint = null;
			rightHandHighlight.portal = null;
		}
	}

	public void OnHighlightStay(Hand hand, Portal portal)
	{
		if (hand.ICHand == IC.Hand.Left)
		{
			leftHandHighlight.portal = portal;
		}
		else
		{
			rightHandHighlight.portal = portal;
		}
	}

	public bool IsPortalProximityValid(Portal portal, ProximityHighlightPoint point)
	{
		if ((bool)portal)
		{
			int layer = point.gameObject.layer;
			if (layer == 5 || layer == 19)
			{
				return false;
			}
			if (!portal.objectTeleportOnEnter)
			{
				if (point.currentVariantSet.HasValue)
				{
					return portal.portalVariantSet == point.currentVariantSet;
				}
				return false;
			}
			if (point.currentVariantSet.HasValue)
			{
				return portal.portalVariantSet == point.currentVariantSet;
			}
		}
		else if (point.currentVariantSet.HasValue)
		{
			return MainCamera.Inst.portalVariantSet == point.currentVariantSet;
		}
		return true;
	}

	public bool IsPortalHighlightValid(Portal focusPortal, Portal testportal, GrabPoint point)
	{
		if ((bool)focusPortal || (bool)testportal)
		{
			int layer = point.gameObject.layer;
			if (layer == 5 || layer == 19)
			{
				return false;
			}
		}
		if ((bool)focusPortal)
		{
			if (focusPortal.objectTeleportOnEnter)
			{
				return focusPortal == testportal;
			}
			return false;
		}
		if ((bool)point.portalVariations)
		{
			if ((bool)testportal)
			{
				if (!testportal.objectTeleportOnEnter)
				{
					return testportal.portalVariantSet == point.portalVariations.currentController;
				}
				return false;
			}
			return MainCamera.Inst.portalVariantSet == point.portalVariations.currentController;
		}
		return testportal == null;
	}

	private void DrawFocusHighlight(IC.Hand hand, MainCamera.HighlightDrawer drawer, bool isHighlighted, ProximityHighlightPoint.HighlightInstance instance, FocusHightlightData focusData, Portal portal)
	{
		ProximityHighlightPoint.HighLightData highlightData = instance.GetHighlightData(portal, settings.highlightProximitySize);
		if (!isHighlighted && !(highlightData.alpha > 0f))
		{
			return;
		}
		float highlightHighlightSize = settings.highlightHighlightSize;
		float highlightProximitySize = settings.highlightProximitySize;
		Vector3 vector = new Vector3(highlightHighlightSize, highlightHighlightSize, highlightHighlightSize);
		Vector3 vector2 = new Vector3(highlightProximitySize, highlightProximitySize, highlightProximitySize);
		Vector3 target = (isHighlighted ? vector : vector2);
		float num = highlightHighlightSize / settings.highlightScaleTime;
		highlightData.scale = Vector3.MoveTowards(highlightData.scale, target, num * IC.DeltaTime);
		Vector3 zero = Vector3.zero;
		zero = ((!isHighlighted) ? base.transform.TransformPoint(highlightData.localPos) : focusData.grabPoint.transform.position);
		Vector3 zero2 = Vector3.zero;
		zero2 = ((!(highlightData.alpha > 0f)) ? focusData.grabPoint.transform.position : base.transform.TransformPoint(highlightData.localPos));
		float highlightMoveSpeed = settings.highlightMoveSpeed;
		Vector3 position = MainCamera.Inst.transform.position;
		if ((bool)portal && (bool)portal.Link)
		{
			position = portal.Link.PortalCamera.transform.position;
		}
		float highlightProximitySize2 = settings.highlightProximitySize;
		float num2 = Mathf.Max(combindedBounds.extents.x, combindedBounds.extents.y, combindedBounds.extents.z) * 1.5f;
		float num3 = highlightProximitySize2 + num2;
		Vector3 normalized = (zero - position).normalized;
		Vector3 vector3 = zero - num3 * normalized;
		if (Physics.SphereCast(new Ray(vector3, normalized), highlightProximitySize2, out var hitInfo, num3, 2048))
		{
			Vector3 vector4 = vector3 + normalized * hitInfo.distance;
			if (Vector3.Distance(vector4, position) > 0.25f)
			{
				zero = vector4;
			}
		}
		Vector3 vector5 = Vector3.MoveTowards(zero2, zero, highlightMoveSpeed * IC.DeltaTime);
		highlightData.localPos = base.transform.InverseTransformPoint(vector5);
		highlightData.worldPos = vector5;
		highlightData.up = ((hand == IC.Hand.Left) ? (-CC.Inst.transform.up) : CC.Inst.transform.up);
		float target2 = (isHighlighted ? 1f : 0f);
		float num4 = 1f / settings.highlightFadeOutTime;
		highlightData.alpha = Mathf.MoveTowards(highlightData.alpha, target2, num4 * IC.DeltaTime);
		drawer.AddHandHighlight(highlightData);
		instance.SetHighlightData(highlightData, portal, settings.highlightProximitySize);
	}

	protected virtual void OnDrawGizmos()
	{
	}
}
public class InteractiveBeam : MonoBehaviour, IOwnerChangeListener
{
	[FormerlySerializedAs("beam")]
	public Transform xFormBeam;

	[FormerlySerializedAs("beamTop")]
	public Transform xFormTop;

	private GrabObject grabObject;

	private MeshRenderer beamMR;

	private MeshRenderer beamTopMR;

	private float alpha;

	private Transform xForm;

	private Vector3 lookAtUp;

	private Vector3 beamLocalScale;

	private Vector3 beamLocalPos;

	private GameObject go;

	private bool wasMovedTooFar;

	private MaterialPropertyBlock mpb;

	private Vector3 startPos;

	public bool customDistance;

	public float customSqrDistance;

	public void OnAwakeLR(GrabObject grabObject)
	{
		if (!xFormBeam || !xFormTop)
		{
			base.gameObject.SetActive(value: false);
			UnityEngine.Debug.LogError(base.name + " is missing beam or beamTop", this);
			return;
		}
		this.grabObject = grabObject;
		go = base.gameObject;
		xForm = base.transform;
		mpb = new MaterialPropertyBlock();
		beamMR = xFormBeam.GetComponentInChildren<MeshRenderer>();
		beamTopMR = xFormTop.GetComponentInChildren<MeshRenderer>();
		lookAtUp = -grabObject.pr.startGravityDirection.normalized;
		mpb.SetFloat(ShaderPID._Alpha, alpha);
		beamMR.enabled = !grabObject.hasBeenGrabbed;
		beamTopMR.enabled = !grabObject.hasBeenGrabbed;
		beamMR.SetPropertyBlock(mpb);
		beamTopMR.SetPropertyBlock(mpb);
		beamLocalScale = xFormBeam.localScale;
		beamLocalPos = xFormBeam.localPosition;
		startPos = base.transform.position;
	}

	void IOwnerChangeListener.OnOwnerChange(MRBase _oldOwner, MRBase _newOwner)
	{
		MRBase.TransferObject(_oldOwner, _newOwner, this);
	}

	public static void OnUpdateAll(ConstArray<InteractiveBeam> beams)
	{
		InteractionSettings inst = BaseSettings<InteractionSettings>.Inst;
		float num = 1f / inst.beamFadeTime;
		float num2 = inst.beamInnerRadius * inst.beamInnerRadius;
		float num3 = inst.beamOuterRadius * inst.beamOuterRadius - num2;
		float num4 = inst.beamFadeRadius * inst.beamFadeRadius;
		Vector3 headPosition = IC.GetHeadPosition();
		CC inst2 = CC.Inst;
		Vector3 position = inst2.handL.transform.position;
		Vector3 position2 = inst2.handR.transform.position;
		float minBeamScale = inst.minBeamScale;
		float num5 = inst.maxBeamScale - minBeamScale;
		float minTopBeamHeight = inst.minTopBeamHeight;
		float num6 = inst.maxTopBeamHeight - minTopBeamHeight;
		float num7 = inst.beamHideDistancethreshold * inst.beamHideDistancethreshold;
		float deltaTime = IC.DeltaTime;
		Vector3 vector = IC.GetHeadRotation() * Vector3.forward;
		Vector3 vector2 = default(Vector3);
		Vector3 forward = default(Vector3);
		for (int i = 0; i < beams.Length; i++)
		{
			InteractiveBeam interactiveBeam = beams[i];
			if (!interactiveBeam.go.activeInHierarchy)
			{
				continue;
			}
			bool flag = !interactiveBeam.wasMovedTooFar && !interactiveBeam.grabObject.hasBeenGrabbed && interactiveBeam.grabObject.canBeGrabbed;
			float num8 = 0f;
			float num9 = num2;
			Vector3 position3 = interactiveBeam.xForm.position;
			if (flag)
			{
				float num10 = interactiveBeam.startPos.x - position3.x;
				float num11 = interactiveBeam.startPos.y - position3.y;
				float num12 = interactiveBeam.startPos.z - position3.z;
				float num13 = num10 * num10 + num11 * num11 + num12 * num12;
				float num14 = (interactiveBeam.customDistance ? interactiveBeam.customSqrDistance : num7);
				if (num13 > num14)
				{
					flag = false;
					interactiveBeam.wasMovedTooFar = true;
				}
			}
			if (flag)
			{
				float num15 = position3.x - headPosition.x;
				float num16 = position3.y - headPosition.y;
				float num17 = position3.z - headPosition.z;
				float num18 = position3.x - position.x;
				float num19 = position3.y - position.y;
				float num20 = position3.z - position.z;
				float num21 = position3.x - position2.x;
				float num22 = position3.y - position2.y;
				float num23 = position3.z - position2.z;
				float num24 = num15 * num15 + num16 * num16 + num17 * num17;
				float num25 = num18 * num18 + num19 * num19 + num20 * num20;
				float num26 = num21 * num21 + num22 * num22 + num23 * num23;
				if (num24 < num25 && num24 < num26)
				{
					num9 = num24;
				}
				if (num25 < num26)
				{
					num9 = num25;
				}
				num9 = num26;
				if (num9 > num2 && num9 < num4)
				{
					num8 = 1f;
				}
			}
			if (interactiveBeam.alpha != num8)
			{
				interactiveBeam.alpha = Mathf.MoveTowards(interactiveBeam.alpha, num8, num * deltaTime);
				interactiveBeam.mpb.SetFloat(ShaderPID._Alpha, interactiveBeam.alpha);
				bool flag2 = interactiveBeam.alpha > 0f;
				interactiveBeam.beamMR.enabled = flag2;
				interactiveBeam.beamTopMR.enabled = flag2;
				if (flag2)
				{
					interactiveBeam.beamMR.SetPropertyBlock(interactiveBeam.mpb);
					interactiveBeam.beamTopMR.SetPropertyBlock(interactiveBeam.mpb);
				}
			}
			if (interactiveBeam.alpha > 0f)
			{
				float num27 = (num9 - num2) / num3;
				float num28 = ((num27 > 1f) ? 1f : ((num27 < 0f) ? 0f : num27));
				num27 = num27 * num27 * (3f - 2f * num27);
				interactiveBeam.beamLocalScale.y = minBeamScale + num5 * num28;
				interactiveBeam.beamLocalPos.y = minTopBeamHeight + num6 * num28;
				interactiveBeam.xFormBeam.localScale = interactiveBeam.beamLocalScale;
				interactiveBeam.xFormTop.localPosition = interactiveBeam.beamLocalPos;
				vector2.x = interactiveBeam.lookAtUp.y * vector.z - interactiveBeam.lookAtUp.z * vector.y;
				vector2.y = interactiveBeam.lookAtUp.z * vector.x - interactiveBeam.lookAtUp.x * vector.z;
				vector2.z = interactiveBeam.lookAtUp.x * vector.y - interactiveBeam.lookAtUp.y * vector.x;
				forward.x = vector2.y * interactiveBeam.lookAtUp.z - vector2.z * interactiveBeam.lookAtUp.y;
				forward.y = vector2.z * interactiveBeam.lookAtUp.x - vector2.x * interactiveBeam.lookAtUp.z;
				forward.z = vector2.x * interactiveBeam.lookAtUp.y - vector2.y * interactiveBeam.lookAtUp.x;
				LR.fast_LookRotation(ref forward, ref interactiveBeam.lookAtUp, out var ret);
				interactiveBeam.xForm.rotation = ret;
			}
		}
	}
}
public enum InvObjectState
{
	DEFAULT,
	SPAWNING,
	ADDING,
	TOREMOVE,
	REMOVING,
	HIDDEN
}
public class InventoryObject : InteractableObject
{
	public bool m_isVisible = true;

	[ReadOnly]
	public GrabObject grabObject;

	private MeshRenderer[] renderers;

	private string[] cachedRendererNames;

	private MPBStore objMPBS;

	private MeshFilter[] holoMFs;

	private bool grabbable;

	private bool isAwake;

	private Vector3 posSpringVelocity = Vector3.zero;

	private Vector3 scaleSpringVelocity = Vector3.zero;

	[NonSerialized]
	[HideInInspector]
	public Vector3 OriginalScale;

	private Bounds[] combinedBounds;

	private IOwnerChangeListener[] ownerChangeListeners;

	private Renderer[][] occludeeRenders;

	private Occludee occludee;

	[NonSerialized]
	[HideInInspector]
	public int ValidEGRillIndex;

	public bool playedEffect;

	[NonSerialized]
	[HideInInspector]
	public ParticlePrefab activeEffect;

	[NonSerialized]
	[HideInInspector]
	public InvObjectState ObjectState;

	private string objName;

	[NonSerialized]
	[HideInInspector]
	public float RemovalMarkTime;

	[NonSerialized]
	[HideInInspector]
	public bool ShowHelperIcon;

	[SerializeField]
	[HideInInspector]
	public GameObject helperIcon;

	private IHaglet<float> fadeVisibiltyRoutine;

	public Quaternion InventoryRotation => Quaternion.Euler(grabObject.inventoryRotation);

	public bool IsAwake => isAwake;

	public Vector3 Extents => Vector3.Scale(base.transform.localScale, GetBounds().extents);

	public Vector3 CentreOffset => base.transform.position - base.transform.TransformPoint(GetBounds().center);

	public void SetGrabbable(bool value)
	{
		grabbable = value;
	}

	public void SetGrabObjectTarget(GrabObject grabObject)
	{
		this.grabObject = grabObject;
	}

	public void GatherOccludeeRenderers()
	{
		Occludee occludee = (this.occludee = grabObject.GetComponentInChildren<Occludee>());
		if ((bool)occludee)
		{
			occludeeRenders = new Renderer[occludee.states.Length][];
			int siblingIndex = occludee.transform.GetSiblingIndex();
			Transform transform = ((occludee.transform == grabObject.transform) ? base.transform : base.transform.GetChild(siblingIndex));
			for (int i = 0; i < occludeeRenders.Length; i++)
			{
				int siblingIndex2 = occludee.states[i].transform.GetSiblingIndex();
				occludeeRenders[i] = transform.GetChild(siblingIndex2).GetComponentsInChildren<Renderer>(includeInactive: true);
			}
			UpdateOccludeeRenderStates();
			this.occludee.OnStateChange.onPostHappen += UpdateOccludeeRenderStates;
		}
	}

	private void UpdateOccludeeRenderStates()
	{
		int stateIndex = occludee.GetStateIndex();
		for (int i = 0; i < occludeeRenders.Length; i++)
		{
			for (int j = 0; j < occludeeRenders[i].Length; j++)
			{
				occludeeRenders[i][j].enabled = i == stateIndex;
			}
		}
	}

	public override void OnAwakeLR(MRBase owner)
	{
		if (isAwake)
		{
			return;
		}
		isAwake = true;
		base.OnAwakeLR(owner);
		objName = base.name;
		OriginalScale = base.transform.localScale;
		RemovalMarkTime = 0f;
		base.transform.localPosition = Vector3.zero;
		base.transform.localRotation = Quaternion.identity;
		base.transform.localScale = Vector3.one;
		renderers = GetComponentsInChildren<MeshRenderer>(includeInactive: true);
		holoMFs = GetComponentsInChildren<MeshFilter>(includeInactive: true);
		cachedRendererNames = new string[renderers.Length];
		for (int i = 0; i < renderers.Length; i++)
		{
			cachedRendererNames[i] = renderers[i].name;
		}
		objMPBS = new MPBStore();
		objMPBS.Initialise();
		Haglet.Create(out fadeVisibiltyRoutine, (Routine.Func1<float>)FadeVisibiltyRoutine, (string)null, startNow: false, (int?)null, (string)null);
		PortalVariations portalVariations = grabObject.portalVariations;
		if ((bool)portalVariations)
		{
			combinedBounds = new Bounds[portalVariations.variants.Length];
			for (int j = 0; j < portalVariations.variants.Length; j++)
			{
				if (portalVariations.variants[j].root != null)
				{
					combinedBounds[j] = CalculateCombinedBounds(base.transform);
				}
			}
		}
		else
		{
			combinedBounds = new Bounds[1];
			combinedBounds[0] = CalculateCombinedBounds(base.transform);
		}
		base.transform.localScale = Vector3.zero;
		helperIcon.transform.localScale = BaseSettings<InventorySettings>.Inst.HelperScaleOffset;
		SetVisible(_visible: false);
		ownerChangeListeners = GetComponentsInChildren<IOwnerChangeListener>();
		SetOwner(owner);
	}

	public void SetOwner(MRBase newOwner)
	{
		if (owner != newOwner)
		{
			MRBase oldOwner = owner;
			owner = newOwner;
			if ((bool)newOwner)
			{
				SetRenderingMask(newOwner.sceneMask);
			}
			for (int i = 0; i < ownerChangeListeners.Length; i++)
			{
				ownerChangeListeners[i].OnOwnerChange(oldOwner, newOwner);
			}
		}
	}

	public override void OnOwnerChange(MRBase _oldOwner, MRBase _newOwner)
	{
		base.OnOwnerChange(_oldOwner, _newOwner);
		if (_oldOwner != null)
		{
			base.transform.SetParent(PlayerInventory.Inst.InventoryCentre);
		}
	}

	public void SetRenderingMask(uint mask)
	{
		for (int i = 0; i < renderers.Length; i++)
		{
			renderers[i].renderingLayerMask = mask;
		}
	}

	public override bool HasTriggerColliders()
	{
		return true;
	}

	private void ResetGrabObject(MRBase newOwner)
	{
		if (grabObject.IsBreakable)
		{
			grabObject.RepairObject();
		}
		grabObject.transform.position = base.transform.position;
		grabObject.transform.rotation = base.transform.rotation;
		grabObject.pr.SetGravityDirection(-CC.Inst.transform.up);
		grabObject.GetLastState().UpdateToLatestState();
		grabObject.GetLastPhysicsState().UpdateToLatestState();
		grabObject.pr.SetOwner(newOwner);
	}

	protected override InteractableObject OnGrabEntered(Hand hand, bool grabbedFromInventory, bool isSwappingHand)
	{
		OnInventoryGrab(hand);
		grabObject.OnGrabEnter(hand, grabbedFromInventory: true, isSwappingHand: false);
		return grabObject;
	}

	public override void OnGrabStayed(Hand hand)
	{
	}

	protected override void OnGrabExited(Hand hand)
	{
	}

	public void UpdateGameObjects()
	{
		CC inst = CC.Inst;
		if (grabObject.portalVariations != null)
		{
			PortalVariations portalVariations = grabObject.portalVariations;
			Renderer[] array = portalVariations.variants[(int)portalVariations.currentController].Renderers;
			for (int i = 0; i < cachedRendererNames.Length; i++)
			{
				bool flag = false;
				Renderer[] array2 = array;
				foreach (Renderer renderer in array2)
				{
					flag = cachedRendererNames[i] == renderer.name;
					if (flag)
					{
						break;
					}
				}
				renderers[i].gameObject.SetActive(flag);
				renderers[i].renderingLayerMask = (flag ? inst.CurrentRegion.owner.sceneMask : 0u);
			}
		}
		else if (inst.CurrentRegion != null && inst.CurrentRegion.owner != null && m_isVisible)
		{
			for (int k = 0; k < renderers.Length; k++)
			{
				renderers[k].renderingLayerMask = inst.CurrentRegion.owner.sceneMask;
			}
		}
		InventorySettings inst2 = BaseSettings<InventorySettings>.Inst;
		helperIcon.SetActive(ShowHelperIcon);
		Vector3 position = MainCamera.Inst.transform.position;
		Bounds bounds = GetBounds();
		Vector3 vector = base.transform.TransformPoint(bounds.center) - position;
		Vector3 position2 = position + vector * inst2.helperPosOffset;
		helperIcon.transform.position = position2;
		helperIcon.transform.LookAt(position, inst.transform.up);
		Quaternion quaternion = Quaternion.Euler(new Vector3(90f, 0f, 0f)) * Quaternion.Inverse(InventoryRotation);
		helperIcon.transform.rotation = helperIcon.transform.rotation * quaternion;
		helperIcon.transform.localScale = inst2.HelperScaleOffset;
	}

	private bool IsVisible()
	{
		return m_isVisible;
	}

	public void SetVisible(bool _visible, bool setScale = true, bool playEffect = false)
	{
		m_isVisible = _visible;
		base.gameObject.SetActive(_visible);
		if (!_visible)
		{
			base.transform.localPosition = Vector3X.zero;
			base.transform.localScale = Vector3X.zero;
			posSpringVelocity = Vector3X.zero;
			scaleSpringVelocity = Vector3X.zero;
			SetGrabbable(value: false);
		}
		else
		{
			for (int i = 0; i < renderers.Length; i++)
			{
				renderers[i].renderingLayerMask = uint.MaxValue;
			}
		}
		m_isVisible = _visible;
	}

	public void UpdateVisible(bool _visible)
	{
		base.gameObject.SetActive(value: true);
		float @float = objMPBS.GetFloat(ShaderPID._DeadZoneAlpha);
		if (!_visible)
		{
			if (fadeVisibiltyRoutine.started && m_isVisible != _visible)
			{
				fadeVisibiltyRoutine.SetArg0(1f);
			}
			else if (@float < 1f && !fadeVisibiltyRoutine.started)
			{
				fadeVisibiltyRoutine.Start(1f);
			}
			for (int i = 0; i < renderers.Length; i++)
			{
				renderers[i].renderingLayerMask = uint.MaxValue;
			}
		}
		else if (fadeVisibiltyRoutine.started && m_isVisible != _visible)
		{
			fadeVisibiltyRoutine.SetArg0(0f);
		}
		else if (@float > 0f && !fadeVisibiltyRoutine.started)
		{
			fadeVisibiltyRoutine.Start(0f);
		}
		m_isVisible = _visible;
	}

	private IEnumerator<Routine.Yield> FadeVisibiltyRoutine(float target)
	{
		float time = 0f;
		float timeMax = BaseSettings<InventorySettings>.Inst.inventoryEGrillObjectFadeTime;
		Wait argChangeWait = Wait.None;
		while (time < timeMax)
		{
			yield return Wait.For.LRUpdates(1) | argChangeWait;
			time = ((!argChangeWait.met) ? (time + IC.DeltaTime) : (timeMax - time));
			float t = Mathf.Clamp01(time / timeMax);
			float value = Mathf.Lerp(1f - target, target, t);
			objMPBS.SetFloat(ShaderPID._DeadZoneAlpha, value);
			MPBStore mPBStore = objMPBS;
			Renderer[] array = renderers;
			mPBStore.ApplyProperties(array);
			argChangeWait = Wait.Until.ArgChange(0);
		}
	}

	public void ApplyMBP(MPBStore mpbToApply)
	{
		Renderer[] array = renderers;
		mpbToApply.ApplyProperties(array);
	}

	public void SetMPBFloat(int id, float value, bool applyNow = false)
	{
		objMPBS.SetFloat(id, value);
		if (applyNow)
		{
			MPBStore mPBStore = objMPBS;
			Renderer[] array = renderers;
			mPBStore.ApplyProperties(array);
		}
	}

	public void ScaleBasedDither()
	{
		InventorySettings inst = BaseSettings<InventorySettings>.Inst;
		float value = Mathf.InverseLerp(inst.itemMinDitherScale, inst.itemMinScale, base.transform.localScale.x);
		objMPBS.SetFloat(ShaderPID._DitherAlphaValue, value);
		MPBStore mPBStore = objMPBS;
		Renderer[] array = renderers;
		mPBStore.ApplyProperties(array);
	}

	public bool IsValid()
	{
		if (grabObject == null)
		{
			return false;
		}
		if (!grabObject.HasControl)
		{
			return false;
		}
		if (ObjectState == InvObjectState.HIDDEN)
		{
			return false;
		}
		return true;
	}

	protected override bool CanBeGrabbed()
	{
		if (grabbable)
		{
			return ObjectState == InvObjectState.DEFAULT;
		}
		return false;
	}

	public override bool CanBeFocusGrabbed()
	{
		return ObjectState == InvObjectState.DEFAULT;
	}

	public override InteractableObject OnFocusGrabbed(Hand hand, out bool grabbedFromInventory)
	{
		OnInventoryGrab(hand);
		grabbedFromInventory = true;
		return grabObject;
	}

	private void OnInventoryGrab(Hand hand)
	{
		ResetGrabObject(hand.GetOwner());
		SetGrabbable(value: false);
		grabObject.OnInventoryGrabbed.Trigger();
	}

	public override void SetVelocityLinear(Vector3 velocityLinear)
	{
	}

	public override void SetVelocityAngular(Vector3 velocityAngular)
	{
	}

	public override void SetPositionAndRotation(Vector3 worldPos, Quaternion worldRot, CC.MovementType type = CC.MovementType.None)
	{
	}

	protected override void OnUpdateLR(float deltaTime, InteractableObject handLHeld, InteractableObject handRHeld)
	{
	}

	public override bool ShouldProximityHighlight()
	{
		return false;
	}

	public Bounds GetBounds()
	{
		if (grabObject != null && grabObject.portalVariations != null)
		{
			return combinedBounds[(int)grabObject.portalVariations.currentController];
		}
		return combinedBounds[0];
	}

	public void UpdatePositionSpring(Vector3 target, InventorySettings.InventorySpring springSettings)
	{
		float num = Mathf.Min(IC.RealDeltaTime, 1f / 60f);
		posSpringVelocity = PlayerInventory.CalculateSpring(target, base.transform.position, posSpringVelocity, springSettings);
		base.transform.position += posSpringVelocity * num;
	}

	public void UpdateScaleSpring(Vector3 target, InventorySettings.InventorySpring springSettings)
	{
		float num = Mathf.Min(IC.RealDeltaTime, 1f / 60f);
		scaleSpringVelocity = PlayerInventory.CalculateSpring(target, base.transform.localScale, scaleSpringVelocity, springSettings);
		base.transform.localScale += scaleSpringVelocity * num;
	}

	public static Bounds CalculateCombinedBounds(Transform parent)
	{
		Bounds result = default(Bounds);
		MeshFilter[] componentsInChildren = parent.GetComponentsInChildren<MeshFilter>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (!(componentsInChildren[i].sharedMesh == null) && !componentsInChildren[i].GetComponent<LightSource>())
			{
				Bounds bounds = TransformBounds(componentsInChildren[i].transform, parent, componentsInChildren[i].sharedMesh.bounds);
				if (i == 0)
				{
					result = bounds;
				}
				else
				{
					result.Encapsulate(bounds);
				}
			}
		}
		return result;
	}

	public static Bounds TransformBounds(Transform currentParent, Transform newParent, Bounds bounds)
	{
		Matrix4x4 m = newParent.worldToLocalMatrix * currentParent.localToWorldMatrix;
		Matrix4x4X.TransformBounds(ref m, bounds.center, bounds.extents, out var tCenter, out var tExtents);
		return new Bounds(tCenter, tExtents * 2f);
	}

	public bool IsIntersectingHand(Hand hand)
	{
		Vector3 position = hand.GetHandPlamTransformLocalToHead().position;
		Vector3 point = base.transform.InverseTransformPoint(position);
		Bounds bounds = GetBounds();
		float num = 1f - Vector3.Distance(BaseSettings<InventorySettings>.Inst.ItemMinScale, base.transform.localScale);
		bounds.extents *= num;
		if (bounds.Contains(point))
		{
			return true;
		}
		Vector3 position2 = bounds.ClosestPoint(point);
		position2 = base.transform.TransformPoint(position2);
		return Vector3.Distance(position2, position) < BaseSettings<InventorySettings>.Inst.handSize;
	}

	public void OnAddedToInventory()
	{
		base.transform.parent = PlayerInventory.Inst.InventoryCentre;
		base.transform.localPosition = Vector3.zero;
		base.transform.localScale = Vector3.zero;
		base.transform.localRotation = Quaternion.identity;
		SetRenderingMask(MainCamera.Inst.GetOwner().sceneMask);
	}

	public void OnRemovedFromInventory(bool removeFromSaveData = true)
	{
		if (removeFromSaveData)
		{
			LR.Inst.saveDataGame.RemoveObjectToChapterInventory(MainCamera.Inst.GetOwner().GetChapter(), grabObject);
		}
		if (grabObject.owner == null)
		{
			UnityEngine.Object.Destroy(grabObject.gameObject);
		}
	}
}
public struct GPOffsetData
{
	public Vector3 posOffset;

	public Quaternion rotOffset;
}
public class LineGrabPointMover : MonoBehaviour, IPostPhysicsUpdateEvent, IAwakeEvent
{
	public GrabPoint leftHandGrabPoint;

	public GrabPoint rightHandGrabPoint;

	private GPOffsetData leftGPData;

	private GPOffsetData rightGPData;

	public float Length = 1f;

	[SerializeField]
	[HideInInspector]
	private Vector3 startPoint;

	[SerializeField]
	[HideInInspector]
	private Vector3 endPoint;

	public float gizmoNodeSize = 0.0725f;

	private Transform xform;

	private MRBase owner;

	public void OnAwakeLR(MRBase owner)
	{
		xform = base.transform;
		startPoint = Vector3X.up * (Length / 2f);
		endPoint = Vector3X.down * (Length / 2f);
		Vector3 localPosition = leftHandGrabPoint.transform.localPosition;
		Vector3 vector = MathfX.ClosestPointLineSegment(localPosition, startPoint, endPoint);
		leftGPData = new GPOffsetData
		{
			posOffset = localPosition - vector,
			rotOffset = leftHandGrabPoint.transform.localRotation
		};
		localPosition = rightHandGrabPoint.transform.localPosition;
		vector = MathfX.ClosestPointLineSegment(localPosition, startPoint, endPoint);
		rightGPData = new GPOffsetData
		{
			posOffset = localPosition - vector,
			rotOffset = rightHandGrabPoint.transform.localRotation
		};
		this.owner = owner;
	}

	void IPostPhysicsUpdateEvent.OnPostPhysicsUpdateLR()
	{
		CC inst = CC.Inst;
		if ((bool)leftHandGrabPoint)
		{
			Hand handL = inst.handL;
			Transform transform = handL.transform;
			if (handL.owner == owner && handL.grabPointHeld != leftHandGrabPoint)
			{
				UpdateGrabPoints(handL.GetHandPalmPosition(), transform.up, transform.forward, leftHandGrabPoint, leftGPData);
			}
		}
		if ((bool)rightHandGrabPoint)
		{
			Hand handR = inst.handR;
			Transform transform2 = handR.transform;
			if (handR.owner == owner && handR.grabPointHeld != rightHandGrabPoint)
			{
				UpdateGrabPoints(handR.GetHandPalmPosition(), transform2.up, transform2.forward, rightHandGrabPoint, rightGPData);
			}
		}
	}

	private void UpdateGrabPoints(Vector3 handPalmWorldPos, Vector3 handUp, Vector3 handForward, GrabPoint grabPoint, GPOffsetData offsetData)
	{
		Transform transform = grabPoint.transform;
		Vector3 vector = xform.InverseTransformVector(handForward);
		vector.y = 0f;
		Vector3X.Normalize(vector, out var _);
		Vector3 upwards = ((xform.InverseTransformVector(handUp).y < 0f) ? Vector3X.down : Vector3X.up);
		if (vector != Vector3X.zero)
		{
			transform.localRotation = Quaternion.LookRotation(vector, upwards);
		}
		Vector3 vector2 = MathfX.ClosestPointLineSegment(xform.InverseTransformPoint(handPalmWorldPos), startPoint, endPoint);
		Quaternion quaternion = transform.localRotation * Quaternion.Inverse(offsetData.rotOffset);
		transform.localPosition = vector2 + quaternion * offsetData.posOffset;
	}
}
public interface IPlacementEvent
{
	void OnPlacementGrabbed();

	void OnPlacementUngrabbed();
}
public class PlacementHelper : MonoBehaviour, IPrepareEvent
{
	public struct FocusedObject
	{
		public GrabObject obj;

		public Transform objXForm;

		public PlacementHelperSnapPivot pivot;

		public Transform pivotXForm;

		public float weightedDist;

		public Quaternion startRot;

		public float startDist;

		public bool isHeldByPlayer;

		public bool isHeldByHelper;

		public bool isInPlace;
	}

	private enum GravityDirection
	{
		Up,
		Down,
		Left,
		Right,
		Forward,
		Backward
	}

	private enum ObjectRestrictionType
	{
		None,
		Allow_Specified,
		Disallow_Specified
	}

	private const float IN_PLACE_DIST = 0.001f;

	public bool objectCanBeGrabbed = true;

	[Range(1f, 180f)]
	public float rotationToleranceDeg = 15f;

	[Range(1f, 90f)]
	public float upDirectionToleranceDeg = 55f;

	[SerializeField]
	private GravityDirection gravityDirection = GravityDirection.Down;

	[SerializeField]
	private ObjectRestrictionType objectRestrictionType;

	[SerializeField]
	private bool usesAntiGravity;

	public IDObjectRef[] specifiedObjects;

	public float[] snapRotations = new float[0];

	private Vector3 velocity;

	private float upDirectionToleranceDot;

	private FocusedObject heldObject;

	private Vector3 gravity;

	private readonly ConstArray<FocusedObject> focusedObjects = new ConstArray<FocusedObject>(4u);

	private readonly Vector3[] focusedPositions = new Vector3[4];

	private readonly Vector3[] focusedDirections = new Vector3[4];

	private readonly Collider[] colliderBuffer = new Collider[16];

	private readonly Rigidbody[] rigidbodyBuffer = new Rigidbody[8];

	private readonly GrabObject[] grabObjectBuffer = new GrabObject[4];

	[FormerlySerializedAs("ShowHelper")]
	public bool showHelper = true;

	[SerializeField]
	private bool showStaticParticles = true;

	[SerializeField]
	private float outerGrabRadius;

	[SerializeField]
	private float innerGrabRadius;

	[SerializeField]
	private Vector3 particleEffectsOffset;

	[SerializeField]
	[FormerlySerializedAs("glowMeshOffset")]
	private Vector3 glowOffsetPos = Vector3.zero;

	[SerializeField]
	private Vector3 glowOffsetRot = Vector3.zero;

	[SerializeField]
	private Vector3 shapeOffsetPos = Vector3.zero;

	[SerializeField]
	private Vector3 shapeOffsetRot = Vector3.zero;

	[SerializeField]
	private Mesh overrideShapeMesh;

	[SerializeField]
	private Mesh overrideGlowMesh;

	private HelperEffects effects = new HelperEffects();

	public Event OnHelperGrabObject;

	public Event OnHelperReleaseObject;

	private TransformData xFormData;

	private HelperSettings settings;

	private IHaglet prepareEventRoutine;

	public GrabObject HeldGrabObject => heldObject.obj;

	public HelperEffects Effects => effects;

	public void OnAwakeLR()
	{
		xFormData = new TransformData(base.transform);
		settings = BaseSettings<HelperSettings>.Inst;
		gravity = GetGravityDirection(gravityDirection);
		upDirectionToleranceDot = Mathf.Cos((float)Math.PI / 180f * upDirectionToleranceDeg);
		if (OnHelperGrabObject == null)
		{
			OnHelperGrabObject = new Event();
		}
		if (OnHelperReleaseObject == null)
		{
			OnHelperReleaseObject = new Event();
		}
		SetupEffects();
		Haglet.Create(out prepareEventRoutine, PrepareEventRoutine);
	}

	Wait IPrepareEvent.PrepareEvents()
	{
		return prepareEventRoutine.Start();
	}

	private IEnumerator<Routine.Yield> PrepareEventRoutine()
	{
		OnHelperGrabObject.PrepareInvoke();
		yield return Wait.For.LRUpdates(1);
		OnHelperReleaseObject.PrepareInvoke();
	}

	private void SetupEffects()
	{
		effects.OnAwakeLR(outerGrabRadius, base.transform);
		Mesh mesh = (overrideShapeMesh ? overrideShapeMesh : settings.placementShapeMesh);
		Material placementShapeMaterial = settings.placementShapeMaterial;
		Quaternion localRot = Quaternion.Euler(shapeOffsetRot);
		effects.InitializeShape(mesh, placementShapeMaterial, shapeOffsetPos, localRot, base.transform);
		Mesh mesh2 = (overrideGlowMesh ? overrideGlowMesh : settings.placementGlowMesh);
		Material placementGlowMaterial = settings.placementGlowMaterial;
		Quaternion localRot2 = Quaternion.Euler(glowOffsetRot);
		effects.InitializeGlow(mesh2, placementGlowMaterial, glowOffsetPos, localRot2, base.transform);
		effects.InitializeArrows(base.transform);
		effects.InitializeLineParticles(base.transform);
	}

	public void ReevaluateHelper()
	{
		if ((bool)heldObject.obj || !base.isActiveAndEnabled)
		{
			return;
		}
		for (int i = 0; i < focusedObjects.Length; i++)
		{
			FocusedObject focusedObject = focusedObjects[i];
			if (focusedObject.isHeldByPlayer && !CC.Inst.IsObjectGrabbed(focusedObject.obj))
			{
				PlacementHelperSnapPivot targetPivot = null;
				float targetPivotWeightedDist = float.MaxValue;
				if (GetObjectTargetPivot(focusedObject.obj, out targetPivot, out targetPivotWeightedDist))
				{
					focusedObject.pivot = targetPivot;
					focusedObject.weightedDist = targetPivotWeightedDist;
					SetHeldObject(focusedObject);
				}
			}
		}
	}

	public void OnUpdateLR()
	{
		xFormData.Update();
		UpdateTargetedObjects();
		UpdateHeldObjectData();
		if (heldObject.obj == null)
		{
			FocusedObject targetHeldObject = GetTargetHeldObject();
			if ((bool)targetHeldObject.obj)
			{
				SetHeldObject(targetHeldObject);
			}
		}
		if (heldObject.obj != null)
		{
			if (!heldObject.isHeldByPlayer)
			{
				if (!heldObject.isInPlace)
				{
					float deltaTime = IC.DeltaTime;
					Vector3 position = heldObject.objXForm.position;
					Quaternion rotation = heldObject.objXForm.rotation;
					Quaternion targetPivotRot = GetTargetPivotRot(heldObject.pivotXForm);
					Quaternion localRotation = heldObject.pivotXForm.rotation.InverseTransformRotation(rotation);
					Quaternion quaternion = targetPivotRot.TransformRotation(localRotation);
					Quaternion quaternion2 = xFormData.rotation.InverseTransformRotation(targetPivotRot);
					Vector3 vector = heldObject.pivotXForm.InverseTransformPoint(position);
					vector = quaternion2 * vector;
					Vector3 vector2 = xFormData.xform.TransformPoint(vector);
					Vector3 vector3 = vector2 - position;
					float magnitude = vector3.magnitude;
					if (!heldObject.isHeldByHelper)
					{
						heldObject.obj.pr.SetKinematic(isKinematic: true);
						heldObject.objXForm.SetParent(base.transform);
						heldObject.isHeldByHelper = true;
						heldObject.isInPlace = false;
						heldObject.startRot = heldObject.objXForm.rotation;
						heldObject.startDist = magnitude;
					}
					if (magnitude < 0.001f)
					{
						heldObject.isInPlace = true;
						heldObject.obj.SetPositionAndRotation(vector2, quaternion);
					}
					else
					{
						Vector3 vector4 = MathfX.ForceAtEndsOfSpring(settings.springStrength, -vector3, settings.springDamping, velocity);
						velocity += vector4 * deltaTime;
						Vector3 vector5 = velocity * deltaTime;
						if ((vector3.x < 0f) ? (vector5.x <= vector3.x) : (vector5.x >= vector3.x))
						{
							vector5.x = vector3.x;
							velocity.x = 0f;
						}
						if ((vector3.y < 0f) ? (vector5.y <= vector3.y) : (vector5.y >= vector3.y))
						{
							vector5.y = vector3.y;
							velocity.y = 0f;
						}
						if ((vector3.z < 0f) ? (vector5.z <= vector3.z) : (vector5.z >= vector3.z))
						{
							vector5.z = vector3.z;
							velocity.z = 0f;
						}
						Vector3 worldPos = position + vector5;
						Quaternion worldRot = Quaternion.Slerp(quaternion, heldObject.startRot, magnitude / heldObject.startDist);
						heldObject.obj.SetPositionAndRotation(worldPos, worldRot);
					}
				}
			}
			else
			{
				SetHeldObject(default(FocusedObject));
			}
		}
		if (!heldObject.isHeldByHelper)
		{
			UpdateLinePS();
			UpdateArrows();
			UpdateGlow();
		}
		effects.UpdateSFX(focusedObjects.Length != 0 && heldObject.obj == null, base.transform);
	}

	private void UpdateArrows()
	{
		int sLength = focusedObjects.sLength;
		int num = 0;
		for (int i = 0; i < sLength; i++)
		{
			PlacementHelperSnapPivot pivot = focusedObjects[i].pivot;
			Transform pivotXForm = focusedObjects[i].pivotXForm;
			if (pivot.showsForwardDirection)
			{
				Vector3 forward = pivotXForm.forward;
				Vector3 vector = SnapForwardDirection(forward);
				focusedDirections[num] = vector;
				num++;
			}
		}
		effects.UpdateArrows(focusedDirections, num, xFormData.up);
	}

	private void UpdateLinePS()
	{
		int sLength = focusedObjects.sLength;
		for (int i = 0; i < sLength; i++)
		{
			Vector3 vector = xFormData.xform.InverseTransformPoint(focusedObjects[i].obj.VisualEffectsCenterWorldPos);
			focusedPositions[i] = vector;
		}
		effects.UpdateLinePS(focusedPositions, sLength, settings);
	}

	private void UpdateGlow()
	{
		int sLength = focusedObjects.sLength;
		for (int i = 0; i < sLength; i++)
		{
			Vector3 vector = xFormData.xform.InverseTransformPoint(focusedObjects[i].obj.VisualEffectsCenterWorldPos);
			focusedPositions[i] = vector;
		}
		effects.UpdateGlow(focusedPositions, sLength);
	}

	private void UpdateTargetedObjects()
	{
		if (focusedObjects._dataNum != 0)
		{
			focusedObjects.ClearToDefault();
		}
		int num = Physics.OverlapSphereNonAlloc(xFormData.position, outerGrabRadius, colliderBuffer, 2048);
		int num2 = 0;
		int num3 = 0;
		for (int i = 0; i < num; i++)
		{
			Collider collider = colliderBuffer[i];
			Rigidbody attachedRigidbody = collider.attachedRigidbody;
			if (attachedRigidbody == null || rigidbodyBuffer.IndexOfRef(attachedRigidbody) >= 0)
			{
				continue;
			}
			rigidbodyBuffer[num2++] = attachedRigidbody;
			GrabObject componentInParent = attachedRigidbody.GetComponentInParent<GrabObject>();
			if (componentInParent == null || grabObjectBuffer.IndexOfRef(componentInParent) >= 0)
			{
				continue;
			}
			grabObjectBuffer[num3++] = componentInParent;
			bool flag = objectRestrictionType == ObjectRestrictionType.None;
			if (!flag)
			{
				flag = ObjectIsAllowed(componentInParent);
			}
			if (!flag)
			{
				Occludee component = componentInParent.GetComponent<Occludee>();
				IDObject iDObject = (component ? component.CurrentState.GetComponent<IDObject>() : null);
				flag = (bool)iDObject && ObjectIsAllowed(iDObject);
			}
			if (!flag)
			{
				PortalVariations component2 = componentInParent.GetComponent<PortalVariations>();
				IDObject iDObject2 = (component2 ? component2.variants[(int)component2.currentController].root.GetComponent<IDObject>() : null);
				flag = (bool)iDObject2 && ObjectIsAllowed(iDObject2);
			}
			if (flag && (usesAntiGravity || !(Vector3.Dot(gravity, componentInParent.pr.ObjGravity) < 0.99f)))
			{
				bool flag2 = CC.Inst.IsObjectGrabbedOrFocusGrabbed(componentInParent);
				float num4 = Vector3.Distance(xFormData.position, collider.ClosestPoint(xFormData.position));
				float num5 = ((heldObject.obj == componentInParent) ? outerGrabRadius : (flag2 ? outerGrabRadius : innerGrabRadius));
				if (!(num4 > num5) && GetObjectTargetPivot(componentInParent, out var targetPivot, out var targetPivotWeightedDist))
				{
					FocusedObject obj = default(FocusedObject);
					obj.obj = componentInParent;
					obj.objXForm = componentInParent.transform;
					obj.pivot = targetPivot;
					obj.pivotXForm = targetPivot.transform;
					obj.isHeldByPlayer = flag2;
					obj.weightedDist = targetPivotWeightedDist;
					focusedObjects.Add(obj);
				}
			}
		}
		if (num > 0)
		{
			Array.Clear(colliderBuffer, 0, num);
		}
		if (num2 > 0)
		{
			Array.Clear(rigidbodyBuffer, 0, num2);
		}
		if (num3 > 0)
		{
			Array.Clear(grabObjectBuffer, 0, num3);
		}
	}

	private bool ObjectIsAllowed(IDObject ID)
	{
		for (int i = 0; i < specifiedObjects.Length; i++)
		{
			if (specifiedObjects[i].id == ID.id)
			{
				return objectRestrictionType == ObjectRestrictionType.Allow_Specified;
			}
		}
		return objectRestrictionType == ObjectRestrictionType.Disallow_Specified;
	}

	private FocusedObject GetTargetHeldObject()
	{
		FocusedObject result = default(FocusedObject);
		result.weightedDist = float.MaxValue;
		for (int i = 0; i < focusedObjects.Length; i++)
		{
			FocusedObject focusedObject = focusedObjects[i];
			if (!focusedObject.isHeldByPlayer && focusedObject.weightedDist < result.weightedDist)
			{
				result = focusedObject;
			}
		}
		return result;
	}

	private void UpdateHeldObjectData()
	{
		if (heldObject.obj == null)
		{
			return;
		}
		bool flag = false;
		for (int i = 0; i < focusedObjects.Length; i++)
		{
			FocusedObject focusedObject = focusedObjects[i];
			if (focusedObject.obj == heldObject.obj)
			{
				flag = true;
				heldObject.isHeldByPlayer = focusedObject.isHeldByPlayer;
				heldObject.weightedDist = focusedObject.weightedDist;
				heldObject.pivot = focusedObject.pivot;
			}
		}
		if (!flag)
		{
			SetHeldObject(default(FocusedObject));
		}
	}

	private bool GetObjectTargetPivot(GrabObject obj, out PlacementHelperSnapPivot targetPivot, out float targetPivotWeightedDist)
	{
		targetPivot = null;
		targetPivotWeightedDist = float.MaxValue;
		PlacementHelperSnapPivot[] helperSnapPivots = obj.helperSnapPivots;
		foreach (PlacementHelperSnapPivot placementHelperSnapPivot in helperSnapPivots)
		{
			if (!placementHelperSnapPivot.gameObject.activeInHierarchy)
			{
				continue;
			}
			Transform transform = placementHelperSnapPivot.transform;
			float num = Vector3.Dot(xFormData.up, transform.up);
			if (!(num < upDirectionToleranceDot))
			{
				float num2 = (num - 1f) * -0.5f;
				float num3 = Vector3.Distance(xFormData.position, transform.position) / outerGrabRadius;
				num3 = ((num3 > 1f) ? 1f : num3);
				float num4 = num3 * settings.distWeight + num2 * (1f - settings.distWeight);
				if (num4 < targetPivotWeightedDist)
				{
					targetPivotWeightedDist = num4;
					targetPivot = placementHelperSnapPivot;
				}
			}
		}
		return (object)targetPivot != null;
	}

	private Vector3 SnapForwardDirection(Vector3 forward)
	{
		Vector3 direction = Vector3.Cross(Vector3.Cross(xFormData.up, forward), xFormData.up);
		Vector2X.Normalize(xFormData.xform.InverseTransformDirection(direction).xz(), out var normalizedVector);
		Vector2 vector = normalizedVector;
		float num = float.MinValue;
		float num2 = Mathf.Cos(rotationToleranceDeg * ((float)Math.PI / 180f));
		for (int i = 0; i < snapRotations.Length; i++)
		{
			float f = snapRotations[i] * ((float)Math.PI / 180f);
			Vector2 vector2 = new Vector2(Mathf.Sin(f), Mathf.Cos(f));
			float num3 = vector2.x * normalizedVector.x + vector2.y * normalizedVector.y;
			if (num3 > num && num3 >= num2)
			{
				num = num3;
				vector.x = vector2.x;
				vector.y = vector2.y;
			}
		}
		return xFormData.xform.TransformDirection(new Vector3(vector.x, 0f, vector.y));
	}

	private void SetHeldObject(FocusedObject obj)
	{
		if (heldObject.obj != null)
		{
			heldObject.obj.pr.SetKinematic(isKinematic: false);
			heldObject.obj.OnPlacementUngrabbed();
			heldObject.objXForm.SetParent(xFormData.xform.root);
			FAC.Inst.PlayOneShot(settings.sfxOnRelease, xFormData.xform);
		}
		if ((bool)overrideShapeMesh)
		{
			effects.ShowHideEffects(obj.obj == null);
		}
		velocity = Vector3X.zero;
		if ((bool)heldObject.obj && !objectCanBeGrabbed)
		{
			heldObject.obj.canBeGrabbed = true;
		}
		heldObject = obj;
		if ((bool)heldObject.obj)
		{
			if (!objectCanBeGrabbed)
			{
				heldObject.obj.canBeGrabbed = false;
				UnityEngine.Debug.Log(heldObject.obj.name + ": not canbegrabbed", heldObject.obj);
			}
			heldObject.obj.OnPlacementGrabbed();
			FAC.Inst.PlayOneShot(settings.sfxOnGrab, base.transform);
			effects.HideLinePS();
			OnHelperGrabObject.Invoke();
		}
		else
		{
			OnHelperReleaseObject.Invoke();
		}
	}

	private Vector3 GetGravityDirection(GravityDirection gvDir)
	{
		return gvDir switch
		{
			GravityDirection.Up => Vector3.up, 
			GravityDirection.Down => -Vector3.up, 
			GravityDirection.Right => Vector3.right, 
			GravityDirection.Left => -Vector3.right, 
			GravityDirection.Forward => Vector3.forward, 
			GravityDirection.Backward => -Vector3.forward, 
			_ => Vector3.zero, 
		};
	}

	private Quaternion GetTargetPivotRot(Transform pXForm)
	{
		return Quaternion.LookRotation(SnapForwardDirection(pXForm.forward), xFormData.up);
	}
}
public class PlacementHelperSnapPivot : MonoBehaviour
{
	public bool showsForwardDirection;

	[ReadOnly]
	public GrabObject grabObj;

	public void OnAwakeLR(GrabObject obj)
	{
		grabObj = obj;
	}

	public void OnDrawGizmosSelected()
	{
		Gizmos.matrix = base.transform.localToWorldMatrix;
		Gizmos.color = Color.cyan;
		Gizmos.DrawSphere(Vector3.zero, 0.005f);
	}
}
public class PlayerPositionInterpreter : InteractableObject
{
	public enum InterpretationMode
	{
		None,
		RelativeDistance,
		RelativeDistanceX,
		RelativeDistanceZ,
		RelativeDistanceY,
		RelativeAngleY
	}

	public InterpretationMode interpretationMode;

	public Transform relativePoint;

	public float relativeScale = 1f;

	public bool looping = true;

	[Range(0f, 1f)]
	public float sampleOffset;

	public IDObjectRef[] interactableTargetRefs = new IDObjectRef[0];

	private InteractableTarget[] interactableTargets;

	[ReadOnly]
	public float ExactValue;

	[ReadOnly]
	public float AdjustedValue;

	private IHaglet waitForLoadRoutine;

	public override void OnAwakeLR(MRBase _owner)
	{
		base.OnAwakeLR(_owner);
		if (relativePoint == null)
		{
			relativePoint = base.transform;
		}
		Haglet.Create(out waitForLoadRoutine, WaitForLoadRoutine, null, startNow: true);
	}

	private IEnumerator<Routine.Yield> WaitForLoadRoutine()
	{
		_ = Wait.None;
		bool flag = true;
		while (flag)
		{
			yield return Wait.For.LRUpdates(1);
			flag = false;
			for (int i = 0; i < interactableTargetRefs.Length; i++)
			{
				flag |= !interactableTargetRefs[i].IsRefLoadedAndAwake();
			}
		}
		interactableTargets = new InteractableTarget[interactableTargetRefs.Length];
		for (int j = 0; j < interactableTargetRefs.Length; j++)
		{
			interactableTargets[j] = LR.Inst.GetIDObjectComponent<InteractableTarget>(interactableTargetRefs[j]);
		}
	}

	protected override void OnUpdateLR(float deltaTime, InteractableObject handLHeld, InteractableObject handRHeld)
	{
		_ = ExactValue;
		float adjustedValue = AdjustedValue;
		Vector3 headPosition = IC.GetHeadPosition();
		switch (interpretationMode)
		{
		case InterpretationMode.RelativeDistanceX:
			ExactValue = headPosition.x - relativePoint.position.x;
			AdjustedValue = ExactValue * relativeScale;
			break;
		case InterpretationMode.RelativeDistanceY:
			ExactValue = headPosition.y - relativePoint.position.y;
			AdjustedValue = ExactValue * relativeScale;
			break;
		case InterpretationMode.RelativeDistanceZ:
			ExactValue = headPosition.z - relativePoint.position.z;
			AdjustedValue = ExactValue * relativeScale;
			break;
		case InterpretationMode.RelativeDistance:
			ExactValue = Vector3.Distance(relativePoint.position, headPosition);
			AdjustedValue = ExactValue * relativeScale;
			break;
		case InterpretationMode.RelativeAngleY:
		{
			Vector3 to = headPosition - relativePoint.position;
			to.y = 0f;
			bool flag = Vector3.Angle(relativePoint.right, to) <= 90f;
			float num = Vector3.Angle(relativePoint.forward, to);
			ExactValue = (flag ? (360f - num) : num) * relativeScale;
			AdjustedValue = ExactValue / 360f;
			break;
		}
		}
		AdjustedValue += sampleOffset;
		if (looping)
		{
			while (AdjustedValue < 0f)
			{
				AdjustedValue += 1f;
			}
			while (AdjustedValue > 1f)
			{
				AdjustedValue -= 1f;
			}
		}
		else
		{
			AdjustedValue = Mathf.Clamp01(AdjustedValue);
		}
		float delta = AdjustedValue - adjustedValue;
		UpdateAnimators(delta);
	}

	public void UpdateAnimators(float delta)
	{
		for (int i = 0; i < interactableTargets.Length; i++)
		{
			InteractableTarget interactableTarget = interactableTargets[i];
			if (interactableTarget.isActiveAndEnabled)
			{
				interactableTarget.SetPosition(delta);
			}
		}
	}

	protected override InteractableObject OnGrabEntered(Hand hand, bool grabbedFromInventory, bool isSwappingHand)
	{
		return this;
	}

	public override void OnGrabStayed(Hand hand)
	{
	}

	protected override void OnGrabExited(Hand hand)
	{
	}

	protected override bool CanBeGrabbed()
	{
		return false;
	}

	public override bool CanBeFocusGrabbed()
	{
		return false;
	}

	public override void SetVelocityLinear(Vector3 velocityLinear)
	{
	}

	public override void SetVelocityAngular(Vector3 velocityAngular)
	{
	}

	public override void SetPositionAndRotation(Vector3 worldPos, Quaternion worldRot, CC.MovementType type = CC.MovementType.None)
	{
	}
}
public class ProximityHighlightPoint : MonoBehaviour, PortalVariations.IUseVariantSet
{
	public class HighLightData
	{
		public float alpha;

		public Color color;

		public Vector3 localPos;

		public Vector3 scale;

		public Vector3 worldPos;

		public Vector3 up;
	}

	public class HighlightInstance
	{
		public Color defaultColor = Color.white;

		private HighLightData mainCameraHighlight = new HighLightData();

		private Dictionary<Portal, HighLightData> portalHighlights = new Dictionary<Portal, HighLightData>(16);

		public HighLightData GetHighlightData(Portal portal, float highlightSize)
		{
			if ((bool)portal)
			{
				if (portalHighlights.ContainsKey(portal))
				{
					return portalHighlights[portal];
				}
				return new HighLightData
				{
					alpha = 0f,
					color = defaultColor,
					localPos = Vector3X.zero,
					scale = 
					{
						x = highlightSize,
						y = highlightSize,
						z = highlightSize
					},
					worldPos = Vector3X.zero,
					up = Vector3X.up
				};
			}
			if (mainCameraHighlight.alpha <= 0f)
			{
				mainCameraHighlight.alpha = 0f;
				mainCameraHighlight.color = defaultColor;
				mainCameraHighlight.scale.x = highlightSize;
				mainCameraHighlight.scale.y = highlightSize;
				mainCameraHighlight.scale.z = highlightSize;
				mainCameraHighlight.localPos = Vector3X.zero;
			}
			return mainCameraHighlight;
		}

		public void SetHighlightData(HighLightData data, Portal portal, float highlightSize)
		{
			if ((bool)portal)
			{
				if (data.alpha > 0f)
				{
					portalHighlights[portal] = data;
				}
				else if (portalHighlights.ContainsKey(portal))
				{
					portalHighlights.Remove(portal);
				}
			}
			else if (data.alpha > 0f)
			{
				mainCameraHighlight = data;
			}
			else
			{
				mainCameraHighlight.alpha = 0f;
				mainCameraHighlight.color = defaultColor;
				mainCameraHighlight.scale.x = highlightSize;
				mainCameraHighlight.scale.y = highlightSize;
				mainCameraHighlight.scale.z = highlightSize;
			}
		}
	}

	[HideInInspector]
	public PortalVariations.VariantSet? currentVariantSet;

	[HideInInspector]
	public PortalVariations portalVariations;

	[HideInInspector]
	public InteractableObject interactableObject;

	[HideInInspector]
	public HighlightInstance instance = new HighlightInstance();

	public void SetPortalVariant(PortalVariations portalVariation)
	{
		portalVariations = portalVariation;
	}

	public void OnVariantSetChanged(PortalVariations.VariantSet newSet)
	{
		currentVariantSet = newSet;
	}
}
[RequireComponent(typeof(CapsuleCollider))]
public class PullyObject : InteractableObject, IPostPhysicsUpdateEvent
{
	[Serializable]
	private struct Node
	{
		public GameObject go;

		public float startT;

		public Node(PullyObject pully, float startT)
		{
			go = UnityEngine.Object.Instantiate(BaseSettings<InteractionSettings>.Inst.chainNodePrefab, pully.transform);
			go.transform.SetParent(pully.transform);
			go.hideFlags = HideFlags.NotEditable;
			this.startT = startT;
		}
	}

	[Serializer.IncludeField]
	private float tOffset;

	[ReadOnly]
	public float positionDelta;

	[ReadOnly]
	public float velocity;

	public bool inertia = true;

	private float lastGrabPosition;

	private float currentGrabPosition;

	private float soundMovementTotal;

	[SerializeField]
	[HideInInspector]
	private Node[] nodes;

	[SerializeField]
	[HideInInspector]
	private Vector3 startPoint;

	[SerializeField]
	[HideInInspector]
	private Vector3 endPoint;

	[HideInInspector]
	public float Length = 1f;

	[SerializeField]
	[HideInInspector]
	private GameObject grabPointLeft;

	[SerializeField]
	[HideInInspector]
	private GameObject grabPointRight;

	private GPOffsetData leftGPOffset;

	private GPOffsetData rightGPOffset;

	private GameObject handleIndicator;

	[FormerlySerializedAs("pullyAnimatorRefs")]
	public IDObjectRef[] interactableTargetRefs = new IDObjectRef[0];

	private InteractableTarget[] interactableTargets;

	private bool grabbed;

	private float soundGrabCooldown;

	private MPBStore mpbStore = new MPBStore();

	public FMODEventAsset secondarySound;

	[ConditionalHide("secondarySound", true, false)]
	public Transform secondarySoundSource;

	private IHaglet waitForLoadRoutine;

	public override void OnAwakeLR(MRBase _owner)
	{
		base.OnAwakeLR(_owner);
		Haglet.Create(out waitForLoadRoutine, WaitForLoadRoutine, null, startNow: true);
		handleIndicator = UnityEngine.Object.Instantiate(BaseSettings<InteractionSettings>.Inst.chainHandlePrefab, base.transform);
		Vector3 localPosition = grabPointLeft.transform.localPosition;
		Vector3 vector = MathfX.ClosestPointLineSegment(localPosition, startPoint, endPoint);
		leftGPOffset = new GPOffsetData
		{
			posOffset = localPosition - vector,
			rotOffset = grabPointLeft.transform.localRotation
		};
		localPosition = grabPointRight.transform.localPosition;
		vector = MathfX.ClosestPointLineSegment(localPosition, startPoint, endPoint);
		rightGPOffset = new GPOffsetData
		{
			posOffset = localPosition - vector,
			rotOffset = grabPointRight.transform.localRotation
		};
		mpbStore.Initialise();
	}

	private IEnumerator<Routine.Yield> WaitForLoadRoutine()
	{
		_ = Wait.None;
		bool flag = true;
		while (flag)
		{
			yield return Wait.For.LRUpdates(1);
			flag = false;
			for (int i = 0; i < interactableTargetRefs.Length; i++)
			{
				flag |= !interactableTargetRefs[i].IsRefLoadedAndAwake();
			}
		}
		interactableTargets = new InteractableTarget[interactableTargetRefs.Length];
		for (int j = 0; j < interactableTargetRefs.Length; j++)
		{
			interactableTargets[j] = LR.Inst.GetIDObjectComponent<InteractableTarget>(interactableTargetRefs[j]);
		}
	}

	public void GenerateChain()
	{
		Bounds bounds = BaseSettings<InteractionSettings>.Inst.chainNodeMesh.bounds;
		CapsuleCollider component = GetComponent<CapsuleCollider>();
		component.height = Length;
		component.radius = Mathf.Max(bounds.extents.x, bounds.extents.y);
		component.gameObject.layer = 11;
		float z = bounds.size.z;
		startPoint = Vector3.up * (Length / 2f);
		endPoint = Vector3.down * (Length / 2f);
		int num = 0;
		while (base.transform.childCount > num)
		{
			if (!base.transform.GetChild(num).GetComponent<GrabPoint>())
			{
				UnityEngine.Object.DestroyImmediate(base.transform.GetChild(num).gameObject);
				continue;
			}
			base.transform.GetChild(num).gameObject.hideFlags = HideFlags.None;
			num++;
		}
		if (nodes != null)
		{
			for (int i = 0; i < nodes.Length; i++)
			{
				if ((bool)nodes[i].go)
				{
					UnityEngine.Object.DestroyImmediate(nodes[i].go);
				}
			}
		}
		nodes = new Node[Mathf.CeilToInt(Length / z)];
		for (int j = 0; j < nodes.Length; j++)
		{
			Vector3 vector = startPoint - Vector3.up * ((float)j * z);
			float startT = VectorX.V3InverseLerpUnclamped(startPoint, endPoint, vector);
			nodes[j] = new Node(this, startT);
			nodes[j].go.transform.localPosition = vector;
			nodes[j].go.transform.localRotation = Quaternion.Euler(270f, 0f, 0f);
			nodes[j].go.transform.localScale = Vector3.one;
		}
		if (!grabPointLeft)
		{
			grabPointLeft = GenerateGrabPoint("Pully Left GrabPoint", IC.Hand.Left);
		}
		if (!grabPointRight)
		{
			grabPointRight = GenerateGrabPoint("Pully Right GrabPoint", IC.Hand.Right);
		}
	}

	public float SnapVelocity(float velocity)
	{
		float num = float.MaxValue;
		InteractableTarget interactableTarget = null;
		bool flag = false;
		for (int i = 0; i < interactableTargets.Length; i++)
		{
			InteractableTarget interactableTarget2 = interactableTargets[i];
			if (interactableTarget2.isActiveAndEnabled && interactableTarget2.GetSnapPoint(out var closestDist, out var closestTarget) && Mathf.Abs(closestDist) < Mathf.Abs(num))
			{
				flag = true;
				num = closestDist;
				interactableTarget = closestTarget;
			}
		}
		if (flag)
		{
			float num2 = Mathf.Min(IC.DeltaTime, 1f / 60f);
			float num3 = num * (0f - interactableTarget.snapStrength);
			float num4 = velocity * interactableTarget.snapDampening;
			float num5 = (num3 - num4) * num2;
			velocity += num5;
		}
		return velocity;
	}

	public bool ConstrainDelta(float delta, out float newDelta)
	{
		bool result = false;
		newDelta = delta;
		for (int i = 0; i < interactableTargets.Length; i++)
		{
			InteractableTarget interactableTarget = interactableTargets[i];
			if (interactableTarget.isActiveAndEnabled && interactableTarget.ConstrainDelta(delta, out var newDelta2))
			{
				newDelta = newDelta2;
				result = true;
			}
		}
		return result;
	}

	public void UpdateAnimators(float delta)
	{
		for (int i = 0; i < interactableTargets.Length; i++)
		{
			InteractableTarget interactableTarget = interactableTargets[i];
			if (interactableTarget.isActiveAndEnabled)
			{
				interactableTarget.SetPosition(delta);
			}
		}
	}

	public GameObject GenerateGrabPoint(string name, IC.Hand handType)
	{
		GameObject obj = new GameObject(name);
		obj.transform.parent = base.transform;
		obj.transform.localPosition = Vector3.zero;
		obj.transform.localRotation = Quaternion.identity;
		obj.transform.localScale = Vector3.one;
		obj.AddComponent<GrabPoint>().SetICHand(handType);
		return obj;
	}

	protected override InteractableObject OnGrabEntered(Hand hand, bool grabbedFromInventory, bool isSwappingHand)
	{
		grabbed = true;
		lastGrabPosition = GetGrabPosition(hand.transform.position);
		velocity = 0f;
		if (soundGrabCooldown == 0f)
		{
			soundGrabCooldown = 0.5f;
			FAC.Inst.PlayOneShot(BaseSettings<InteractionSettings>.Inst.soundChainGrab, hand.transform.position);
		}
		return this;
	}

	public override void OnGrabStayed(Hand hand)
	{
		currentGrabPosition = GetGrabPosition(hand.transform.position);
		positionDelta = currentGrabPosition - lastGrabPosition;
	}

	protected override void OnGrabExited(Hand hand)
	{
		grabbed = false;
		float num = currentGrabPosition - lastGrabPosition;
		if (inertia)
		{
			velocity = num / IC.DeltaTime;
		}
	}

	protected override void OnUpdateLR(float deltaTime, InteractableObject handLHeld, InteractableObject handRHeld)
	{
		if (waitForLoadRoutine.started)
		{
			return;
		}
		InteractionSettings inst = BaseSettings<InteractionSettings>.Inst;
		if (!grabbed)
		{
			float num = SnapVelocity(velocity);
			if (Mathf.Abs(velocity - num) > 0.5f)
			{
				SnapVelocity(velocity);
			}
			velocity = num;
			positionDelta = velocity * IC.DeltaTime;
		}
		if (Mathf.Abs(velocity) < 0.01f)
		{
			velocity = 0f;
		}
		if (velocity != 0f)
		{
			velocity *= 1f - inst.chainDrag;
		}
		if (ConstrainDelta(positionDelta, out var newDelta))
		{
			_ = velocity;
			_ = inst.chainBounce;
			velocity = velocity * -1f * inst.chainBounce;
		}
		CC inst2 = CC.Inst;
		UpdateGrabPoints(inst2.handL, grabPointLeft.transform, leftGPOffset);
		UpdateGrabPoints(inst2.handR, grabPointRight.transform, rightGPOffset);
		Vector3 vector = base.transform.InverseTransformPoint(IC.GetHeadPosition());
		Vector3 vect = vector;
		vect = vect.RepY(Mathf.Max(endPoint.y, Mathf.Min(startPoint.y, vect.y)));
		Vector2 vector2 = vect.xz().normalized * inst.chainHandleDistance;
		Vector2 vector3 = new Vector2(vector2.x * Mathf.Cos(90f) - vector2.y * Mathf.Sin(90f), vector2.y * Mathf.Cos(90f) + vector2.x * Mathf.Sin(90f));
		vect = vect.RepX(vector3.x);
		vect = vect.RepZ(vector3.y);
		handleIndicator.transform.localPosition = vect;
		vector = vector.RepY(0f);
		float sqrMagnitude = vector.sqrMagnitude;
		if (sqrMagnitude > inst.sqrVisibleDistFadeOut)
		{
			if (handleIndicator.activeSelf)
			{
				handleIndicator.SetActive(value: false);
			}
			return;
		}
		Vector3 eulerAngles = Quaternion.LookRotation(-vector, Vector3.forward).eulerAngles;
		eulerAngles += new Vector3(0f, 90f, 0f);
		handleIndicator.transform.localRotation = Quaternion.Euler(eulerAngles);
		float num2 = inst.GetUIAlpha(handleIndicator.transform.position, inst.chainHandleDistance);
		if (sqrMagnitude > inst.sqrVisibleDistFadeIn)
		{
			num2 = Mathf.Lerp(num2, 0f, (sqrMagnitude - inst.sqrVisibleDistFadeIn) / (inst.sqrVisibleDistFadeOut - inst.sqrVisibleDistFadeIn));
		}
		if (num2 > 0.01f)
		{
			if (!handleIndicator.activeSelf)
			{
				handleIndicator.SetActive(value: true);
			}
			mpbStore.SetFloat(ShaderPID._Alpha, num2);
			mpbStore.ApplyProperties(handleIndicator.GetComponent<MeshRenderer>());
		}
		else if (handleIndicator.activeSelf)
		{
			handleIndicator.SetActive(value: false);
		}
		if (positionDelta == 0f)
		{
			return;
		}
		positionDelta = newDelta;
		UpdateAnimators(positionDelta);
		float num3 = Mathf.Abs(positionDelta);
		soundGrabCooldown = Mathf.Max(0f, soundGrabCooldown - IC.DeltaTime);
		soundMovementTotal += num3;
		if (soundMovementTotal > inst.chainSoundDistance)
		{
			soundMovementTotal -= inst.chainSoundDistance;
			FMOD.Studio.EventInstance eventInstance = FAC.Inst.PlayOneShot(inst.soundChainMove, base.transform.position);
			float value = num3 / deltaTime;
			eventInstance.setParameterValue("Speed", value);
			if (secondarySound != null)
			{
				FAC.Inst.PlayOneShot(secondarySound, secondarySoundSource?.position ?? base.transform.position).setParameterValue("Speed", value);
			}
		}
		tOffset += positionDelta;
		UpdateChainNodes();
	}

	private void UpdateGrabPoints(Hand hand, Transform grabPoint, GPOffsetData offsetData)
	{
		if (hand.InteractableHeld != this)
		{
			Vector3 forward = base.transform.InverseTransformVector(hand.transform.forward);
			forward.y = 0f;
			forward.Normalize();
			Vector3 upwards = ((base.transform.InverseTransformVector(hand.transform.up).y < 0f) ? Vector3.down : Vector3.up);
			grabPoint.localRotation = Quaternion.LookRotation(forward, upwards) * offsetData.rotOffset;
			Vector3 localPosition = MathfX.ClosestPointLineSegment(base.transform.InverseTransformPoint(hand.GetHandPalmPosition()), startPoint, endPoint);
			grabPoint.localPosition = localPosition;
		}
		else
		{
			float t = lastGrabPosition + positionDelta;
			grabPoint.localPosition = Vector3.Lerp(startPoint, endPoint, t);
		}
		Quaternion quaternion = grabPoint.localRotation * Quaternion.Inverse(offsetData.rotOffset);
		grabPoint.localPosition += quaternion * offsetData.posOffset;
	}

	public override void OnEndOfUpdate(bool inPlayerScene)
	{
		base.OnEndOfUpdate(inPlayerScene);
		lastGrabPosition = currentGrabPosition;
	}

	public void ApplyVelocity()
	{
		tOffset += velocity * IC.DeltaTime;
	}

	public override bool CanBeFocusGrabbed()
	{
		return false;
	}

	protected override bool CanBeGrabbed()
	{
		return !waitForLoadRoutine.started;
	}

	public override void SetPositionAndRotation(Vector3 worldPos, Quaternion worldRot, CC.MovementType type = CC.MovementType.None)
	{
	}

	public override void SetVelocityAngular(Vector3 velocityAngular)
	{
	}

	public override void SetVelocityLinear(Vector3 velocityLinear)
	{
	}

	private float GetGrabPosition(Vector3 worldPosition)
	{
		Vector3 value = MathfX.ClosestPointLineSegment(base.transform.InverseTransformPoint(worldPosition), startPoint, endPoint);
		return VectorX.V3InverseLerpUnclamped(startPoint, endPoint, value);
	}

	private void UpdateChainNodes()
	{
		for (int i = 0; i < nodes.Length; i++)
		{
			Node node = nodes[i];
			float t = MathfX.Modulus(node.startT + tOffset, 1f);
			node.go.transform.localPosition = Vector3.Lerp(startPoint, endPoint, t);
		}
	}

	void IPostPhysicsUpdateEvent.OnPostPhysicsUpdateLR()
	{
		CC inst = CC.Inst;
		Hand hand = ((inst.handL.InteractableHeld == this) ? inst.handL : ((inst.handR.InteractableHeld == this) ? inst.handR : null));
		if ((bool)hand && Vector3.Distance(hand.transform.position, hand.grabPointHeld.transform.position) > 0.5f)
		{
			Hand.UngrabObject(this);
		}
	}

	public override void OnPrebuildRoot(bool isPrefab)
	{
		base.OnPrebuildRoot(isPrefab);
		if (!isPrefab)
		{
			GenerateChain();
		}
	}
}
public class RotatableObject : InteractableObject
{
	public float drag;

	public IDObjectRef[] interactableTargetRefs = new IDObjectRef[0];

	public bool shouldAutoRelease;

	[ConditionalHide("shouldAutoRelease")]
	public bool useCustomGrabArea;

	[ConditionalHide("useCustomGrabArea", ConditionalSourceField2 = "shouldAutoRelease")]
	public FixedRotatableObject.GrabbableArea grabArea;

	private InteractableTarget[] interactableTargets;

	private Hand handHeld;

	private float currentAngle;

	private float velocity;

	private Vector2 lastGrabDir;

	private Vector2 currGrabDir;

	private bool grabbed;

	private IHaglet waitForLoadRoutine;

	public override void OnAwakeLR(MRBase _owner)
	{
		base.OnAwakeLR(_owner);
		Haglet.Create(out waitForLoadRoutine, WaitForLoadRoutine, null, startNow: true);
		if (!useCustomGrabArea)
		{
			grabArea = BaseSettings<InteractionSettings>.Inst.defaultGrabArea;
		}
	}

	protected override void OnUpdateLR(float deltaTime, InteractableObject handLHeld, InteractableObject handRHeld)
	{
		float delta;
		if (grabbed)
		{
			delta = Vector2.SignedAngle(lastGrabDir, currGrabDir);
		}
		else
		{
			delta = velocity * IC.DeltaTime;
			float num = Mathf.Sign(velocity);
			float num2 = Mathf.Abs(velocity);
			num2 = ((num2 < 0.05f) ? 0f : (num2 - num2 * drag));
			velocity = SnapVelocity(num2 * num / 360f) * 360f;
		}
		delta = ConstrainDelta(delta);
		currentAngle += delta;
		UpdateAnimators(delta);
		base.transform.localRotation = Quaternion.Euler(0f, 0f, currentAngle);
	}

	public override void OnEndOfUpdate(bool inPlayerScene)
	{
		base.OnEndOfUpdate(inPlayerScene);
		lastGrabDir = currGrabDir;
	}

	private bool CheckAutoRelease()
	{
		if (handHeld == null || handHeld.InteractableHeld != this || !shouldAutoRelease)
		{
			return false;
		}
		bool flag = false;
		Vector3 v = base.transform.InverseTransformPoint(handHeld.transform.position);
		v.z -= grabArea.offset;
		if (Mathf.Abs(v.z) > grabArea.height)
		{
			flag = true;
		}
		if (v.xy().sqrMagnitude > grabArea.radius * grabArea.radius)
		{
			flag = true;
		}
		if (flag)
		{
			handHeld.UngrabObject();
		}
		return flag;
	}

	public float SnapVelocity(float velocity)
	{
		float num = float.MaxValue;
		InteractableTarget interactableTarget = null;
		bool flag = false;
		for (int i = 0; i < interactableTargets.Length; i++)
		{
			InteractableTarget interactableTarget2 = interactableTargets[i];
			if (interactableTarget2.isActiveAndEnabled && interactableTarget2.GetSnapPoint(out var closestDist, out var closestTarget) && Mathf.Abs(closestDist) < Mathf.Abs(num))
			{
				flag = true;
				num = closestDist;
				interactableTarget = closestTarget;
			}
		}
		if (flag)
		{
			float num2 = Mathf.Min(IC.DeltaTime, 1f / 60f);
			float num3 = num * (0f - interactableTarget.snapStrength);
			float num4 = velocity * interactableTarget.snapDampening;
			float num5 = (num3 - num4) * num2;
			velocity += num5;
		}
		return velocity;
	}

	public float ConstrainDelta(float delta)
	{
		float num = delta;
		for (int i = 0; i < interactableTargets.Length; i++)
		{
			InteractableTarget interactableTarget = interactableTargets[i];
			if (interactableTarget.isActiveAndEnabled && interactableTarget.ConstrainDelta(num / 360f, out var newDelta))
			{
				num = newDelta * 360f;
			}
		}
		return num;
	}

	public void UpdateAnimators(float delta)
	{
		for (int i = 0; i < interactableTargets.Length; i++)
		{
			InteractableTarget interactableTarget = interactableTargets[i];
			if (interactableTarget.isActiveAndEnabled)
			{
				interactableTarget.SetPosition(delta / 360f);
			}
		}
	}

	protected override InteractableObject OnGrabEntered(Hand hand, bool grabbedWithHologram, bool isSwappingHand)
	{
		lastGrabDir = (currGrabDir = base.transform.parent.InverseTransformPoint(hand.transform.position).xy().normalized);
		grabbed = true;
		handHeld = hand;
		return this;
	}

	public override void OnGrabStayed(Hand hand)
	{
		currGrabDir = base.transform.parent.InverseTransformPoint(hand.transform.position).xy().normalized;
		handHeld = hand;
		CheckAutoRelease();
	}

	protected override void OnGrabExited(Hand hand)
	{
		grabbed = false;
		currGrabDir = base.transform.parent.InverseTransformPoint(hand.transform.position).xy().normalized;
		float num = Vector2.SignedAngle(lastGrabDir, currGrabDir);
		velocity = num / IC.DeltaTime;
		handHeld = null;
	}

	private IEnumerator<Routine.Yield> WaitForLoadRoutine()
	{
		_ = Wait.None;
		bool flag = true;
		while (flag)
		{
			yield return Wait.For.LRUpdates(1);
			flag = false;
			for (int i = 0; i < interactableTargetRefs.Length; i++)
			{
				flag |= !interactableTargetRefs[i].IsRefLoadedAndAwake();
			}
		}
		interactableTargets = new InteractableTarget[interactableTargetRefs.Length];
		for (int j = 0; j < interactableTargetRefs.Length; j++)
		{
			interactableTargets[j] = LR.Inst.GetIDObjectComponent<InteractableTarget>(interactableTargetRefs[j]);
		}
	}

	protected override bool CanBeGrabbed()
	{
		return base.enabled;
	}

	public override bool CanBeFocusGrabbed()
	{
		return false;
	}

	public override void SetVelocityLinear(Vector3 velocityLinear)
	{
	}

	public override void SetVelocityAngular(Vector3 velocityAngular)
	{
	}

	public override void SetPositionAndRotation(Vector3 worldPos, Quaternion worldRot, CC.MovementType type = CC.MovementType.None)
	{
	}
}
public class InventoryStoryItem_STUB : MonoBehaviour
{
	public InventoryStoryItem storyItem;
}
public class EnableLightsOnAreaEnter : MonoBehaviour, IAreaEvent
{
	public LightSource[] lights;

	void IAreaEvent.OnAreaEnter()
	{
		if (base.isActiveAndEnabled)
		{
			LightSource[] array = lights;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].EnableLight();
			}
		}
	}

	void IAreaEvent.OnAreaExit()
	{
	}
}
[ExecuteInEditMode]
public class LightSource : MonoBehaviour, PortalVariations.IUseVariantSet, IOwnerChangeListener, ISceneUnloadEvent, IPrebuildEvent
{
	private const int CONE_RESOLUTION = 24;

	private static readonly Vector3[] coneVertsTemp = new Vector3[48];

	public float lightIntensity = 1f;

	public float lightIntensityModifier = 1f;

	public float flickerIntensityModifier = 1f;

	private PortalVariations.VariantSet? portalVariantSet;

	[NonSerialized]
	public Light lightComp;

	private MeshRenderer coneMR;

	private MeshFilter coneMF;

	[SerializeField]
	[HideInInspector]
	private Mesh coneMesh;

	[SerializeField]
	private MeshRenderer lenseMR;

	private MaterialPropertyBlock lenseMPB;

	private int _LightID = Shader.PropertyToID("_LightID");

	private float currAnimTime;

	private float animatingToTime;

	[SerializeField]
	[HideInInspector]
	private float coneRange = -1f;

	[NonSerialized]
	[HideInInspector]
	public float cachedIntensity;

	public TransformData xFormData;

	[SerializeField]
	[HideInInspector]
	private bool shouldDestroyMesh = true;

	private Action<NexusRenderPipeline> onPipelineCreation;

	private IHaglet<float> animateIntensityRoutine;

	private IHaglet animateFlickerRoutine;

	public bool LightIsEnabled => lightComp.intensity > 0f;

	private static Mesh GenerateConeMesh(float range, float coneAngle, float startOffset)
	{
		float num = Mathf.Tan(coneAngle / 2f * ((float)Math.PI / 180f));
		float num2 = startOffset * num;
		float num3 = range * num;
		Color[] array = new Color[coneVertsTemp.Length];
		int[] array2 = new int[144];
		for (int i = 0; i < 24; i++)
		{
			float num4 = (float)i / 24f;
			float f = (float)Math.PI * 2f * num4;
			coneVertsTemp[i].x = Mathf.Cos(f) * num2;
			coneVertsTemp[i].y = Mathf.Sin(f) * num2;
			coneVertsTemp[i].z = startOffset;
			array[i].a = 1f;
		}
		for (int j = 0; j < 24; j++)
		{
			float num5 = (float)j / 24f;
			float f2 = (float)Math.PI * 2f * num5;
			int num6 = j + 24;
			coneVertsTemp[num6].x = Mathf.Cos(f2) * num3;
			coneVertsTemp[num6].y = Mathf.Sin(f2) * num3;
			coneVertsTemp[num6].z = range;
			array[num6].a = 0f;
		}
		for (int k = 0; k < 24; k++)
		{
			int num7 = k * 6;
			array2[num7] = k % 24;
			array2[num7 + 1] = k % 24 + 24;
			array2[num7 + 2] = (k + 1) % 24;
			array2[num7 + 3] = k % 24 + 24;
			array2[num7 + 4] = (k + 1) % 24 + 24;
			array2[num7 + 5] = (k + 1) % 24;
		}
		Mesh mesh = new Mesh();
		mesh.vertices = coneVertsTemp;
		mesh.triangles = array2;
		mesh.colors = array;
		mesh.name = "Light Cone";
		mesh.hideFlags = HideFlags.DontSave;
		mesh.RecalculateBounds();
		mesh.UploadMeshData(markNoLongerReadable: false);
		return mesh;
	}

	private static void UpdateConeMesh(Mesh mesh, float range, float coneAngle, float startOffset)
	{
		float num = Mathf.Tan(coneAngle / 2f * ((float)Math.PI / 180f));
		float num2 = startOffset * num;
		float num3 = range * num;
		for (int i = 0; i < 24; i++)
		{
			float num4 = (float)i / 24f;
			float f = (float)Math.PI * 2f * num4;
			coneVertsTemp[i].x = Mathf.Cos(f) * num2;
			coneVertsTemp[i].y = Mathf.Sin(f) * num2;
			coneVertsTemp[i].z = startOffset;
		}
		for (int j = 0; j < 24; j++)
		{
			float num5 = (float)j / 24f;
			float f2 = (float)Math.PI * 2f * num5;
			int num6 = j + 24;
			coneVertsTemp[num6].x = Mathf.Cos(f2) * num3;
			coneVertsTemp[num6].y = Mathf.Sin(f2) * num3;
			coneVertsTemp[num6].z = range;
		}
		mesh.vertices = coneVertsTemp;
		mesh.RecalculateBounds();
		mesh.UploadMeshData(markNoLongerReadable: false);
	}

	[ContextMenu("Flicker Light")]
	public void Flicker()
	{
		if (base.isActiveAndEnabled)
		{
			animateFlickerRoutine.Start(resetIfStarted: true);
		}
	}

	[Event(EventName = "Enable Light")]
	private void EnableLight(object sender)
	{
		EnableLight();
	}

	[ContextMenu("Enable Light")]
	public void EnableLight()
	{
		if (!base.isActiveAndEnabled)
		{
			currAnimTime = (lightIntensityModifier = 1f);
			return;
		}
		bool flag = !animateIntensityRoutine.started || !Mathf.Approximately(1f, animatingToTime);
		if (flag || !animateIntensityRoutine.started)
		{
			animateIntensityRoutine.Start(1f, flag);
		}
	}

	[ContextMenu("Disable Light")]
	public void CTX_DisableLight()
	{
		DisableLight();
	}

	[Event(EventName = "Disable Light")]
	private void DisableLight(object sender)
	{
		DisableLight();
	}

	public void DisableLight()
	{
		if (!base.isActiveAndEnabled)
		{
			lightIntensityModifier = 0f;
			return;
		}
		bool flag = !animateIntensityRoutine.started || !Mathf.Approximately(0f, animatingToTime);
		if (flag || !animateIntensityRoutine.started)
		{
			animateIntensityRoutine.Start(0f, flag);
		}
	}

	private bool ShouldRestartIntensityRoutine(float targetAnimTime)
	{
		if (animateIntensityRoutine.started)
		{
			return !Mathf.Approximately(targetAnimTime, animatingToTime);
		}
		return true;
	}

	private IEnumerator<Routine.Yield> AnimateIntensityRoutine(float targetAnimTime)
	{
		animatingToTime = targetAnimTime;
		float maxAnimTime = ((currAnimTime > targetAnimTime) ? BaseSettings<LightSettings>.Inst.disableTime : BaseSettings<LightSettings>.Inst.enableTime);
		while (!Mathf.Approximately(currAnimTime, targetAnimTime))
		{
			float maxDelta = IC.DeltaTime / maxAnimTime;
			currAnimTime = Mathf.MoveTowards(currAnimTime, targetAnimTime, maxDelta);
			float num = BaseSettings<LightSettings>.Inst.lightEnableIntensityCurve.Evaluate(currAnimTime);
			lightIntensityModifier = num;
			yield return Wait.For.LRUpdates(1);
		}
	}

	private IEnumerator<Routine.Yield> AnimateFlickerRoutine()
	{
		float time = 0f;
		float timeMax = 1f;
		while (time < timeMax)
		{
			time = Mathf.MoveTowards(time, 1f, IC.DeltaTime);
			float num = BaseSettings<LightSettings>.Inst.lightFlickerIntensityCurve.Evaluate(time);
			flickerIntensityModifier = num;
			yield return Wait.For.LRUpdates(1);
		}
	}

	private void GetLightComponents()
	{
		lightComp = ((lightComp = GetComponent<Light>()) ? lightComp : null);
		coneMR = ((coneMR = GetComponent<MeshRenderer>()) ? coneMR : null);
		coneMF = ((coneMF = GetComponent<MeshFilter>()) ? coneMF : null);
	}

	protected void OnEnable()
	{
		if (onPipelineCreation == null)
		{
			onPipelineCreation = OnPipelineCreation;
		}
		GetLightComponents();
		if ((bool)lightComp && (bool)coneMR)
		{
			NexusRenderPipeline.RegisterPipelineCreationCallback(onPipelineCreation);
		}
	}

	private void OnPipelineCreation(NexusRenderPipeline rp)
	{
		MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
		int value = rp.RegisterLightForID(lightComp);
		materialPropertyBlock.SetInt(_LightID, value);
		coneMR.SetPropertyBlock(materialPropertyBlock);
	}

	public void OnAwakeLR()
	{
		if (!lightComp)
		{
			OnEnable();
		}
		UpdateConeMesh();
		lenseMPB = new MaterialPropertyBlock();
		portalVariantSet = null;
		Haglet.Create(out animateFlickerRoutine, AnimateFlickerRoutine);
		Haglet.Create(out animateIntensityRoutine, (Routine.Func1<float>)AnimateIntensityRoutine, (string)null, startNow: false, (int?)null, (string)null);
		lightIntensityModifier = ((lightIntensityModifier <= 0f) ? 0f : 1f);
		currAnimTime = lightIntensityModifier;
		xFormData = new TransformData(base.transform);
	}

	protected void OnDestroy()
	{
		if (onPipelineCreation != null)
		{
			NexusRenderPipeline.DeregisterPipelineCreationCallback(onPipelineCreation);
		}
		if ((bool)lightComp && NexusRenderPipeline.Inst != null)
		{
			NexusRenderPipeline.Inst.DeregisterLightForID(lightComp);
			lightComp = null;
		}
		if ((bool)coneMesh && shouldDestroyMesh)
		{
			UnityEngine.Object.Destroy(coneMesh);
		}
	}

	void ISceneUnloadEvent.OnSceneUnload()
	{
		OnDestroy();
	}

	public static void OnUpdateAll(ConstArray<LightSource> lightSources)
	{
		LightSettings inst = BaseSettings<LightSettings>.Inst;
		for (int i = 0; i < lightSources.Length; i++)
		{
			LightSource lightSource = lightSources[i];
			if ((bool)lightSource && (bool)lightSource.lightComp)
			{
				float num = lightSource.lightIntensity * lightSource.lightIntensityModifier * lightSource.flickerIntensityModifier;
				lightSource.lightComp.enabled = lightSource.lightComp.intensity > 0f;
				lightSource.lightComp.intensity = num;
				if ((object)lightSource.coneMR != null)
				{
					lightSource.UpdateConeMesh();
					lightSource.coneMR.enabled = num > 0f;
				}
				if ((bool)lightSource.lenseMR)
				{
					Color value = Color.Lerp(inst.lightLensColorUnlit, inst.lightLensColorLit, num);
					lightSource.lenseMPB.SetColor(ShaderPID._Color, value);
					lightSource.lenseMR.SetPropertyBlock(lightSource.lenseMPB);
				}
			}
		}
	}

	public void GetRasterizerLight(out RasterizerLightNative rLight)
	{
		Transform xform = xFormData.xform;
		rLight.position = xform.position;
		rLight.rotation = xform.rotation;
		rLight.fov = lightComp.spotAngle;
		rLight.clipPlaneNear = lightComp.shadowNearPlane;
		rLight.range = lightComp.range;
		rLight.viewMatrix = xform.worldToLocalMatrix;
		rLight.viewMatrix.m20 *= -1f;
		rLight.viewMatrix.m21 *= -1f;
		rLight.viewMatrix.m22 *= -1f;
		rLight.viewMatrix.m23 *= -1f;
		rLight.perspectiveMatrix = default(Matrix4x4);
		rLight.perspectiveMatrix.m00 = (rLight.perspectiveMatrix.m11 = 1f / (float)Math.Tan(0.5f * rLight.fov * ((float)Math.PI / 180f)));
		rLight.perspectiveMatrix.m22 = (0f - (rLight.range + rLight.clipPlaneNear)) / (rLight.range - rLight.clipPlaneNear);
		rLight.perspectiveMatrix.m23 = (0f - 2f * rLight.range * rLight.clipPlaneNear) / (rLight.range - rLight.clipPlaneNear);
		rLight.perspectiveMatrix.m32 = -1f;
		rLight.fittedPerspectiveMatrix = default(Matrix4x4);
	}

	public void SetPortalVariant(PortalVariations portalVariation)
	{
	}

	public bool IsValid(PortalVariations.VariantSet set)
	{
		if (base.isActiveAndEnabled && lightComp.enabled)
		{
			if (portalVariantSet.HasValue)
			{
				return portalVariantSet.Value == set;
			}
			return true;
		}
		return false;
	}

	void PortalVariations.IUseVariantSet.OnVariantSetChanged(PortalVariations.VariantSet newSet)
	{
		portalVariantSet = newSet;
	}

	void IOwnerChangeListener.OnOwnerChange(MRBase _oldOwner, MRBase _newOwner)
	{
		MRBase.TransferObject(_oldOwner, _newOwner, this);
	}

	private float GetLightDistAtValue(float value, Light light)
	{
		NexusRenderSettings cfg = NexusRenderPipeline.Inst.cfg;
		float num = light.range * light.range;
		float num2 = cfg.lightFalloffFactor / num;
		float num3 = 0f;
		float num4 = light.range;
		int num5 = 0;
		while (num3 <= num4)
		{
			float num6 = (num3 + num4) / 2f;
			float num7 = num6 * num6;
			float num8 = num7 / num;
			float num9 = 1f - Mathf.Min(1f, num8 * num8);
			float num10 = 1f + num2 * num7;
			float num11 = num9 / num10;
			if (Mathf.Approximately(num11, value))
			{
				return num6;
			}
			if (value < num11)
			{
				num3 = num6;
			}
			else
			{
				num4 = num6;
			}
			if (num5 > 15)
			{
				return num6;
			}
			num5++;
		}
		return 0f;
	}

	private void UpdateConeMesh(bool force = false, bool allowNew = false)
	{
		bool flag = coneRange != lightComp.range || force;
		if ((bool)coneMF && (bool)lightComp && flag)
		{
			coneRange = lightComp.range;
			if ((bool)coneMesh)
			{
				UpdateConeMesh(coneMesh, lightComp.range, lightComp.spotAngle, 0.1f);
			}
			else if (allowNew)
			{
				coneMF.sharedMesh = (coneMesh = GenerateConeMesh(lightComp.range, lightComp.spotAngle, 0.1f));
			}
		}
	}

	void IPrebuildEvent.OnPrebuildRoot(bool isPrefab)
	{
	}

	protected void Update()
	{
	}

	protected void OnDrawGizmosSelected()
	{
	}

	private static void CreateConeMeshOnSelected()
	{
	}
}
public class LightSensor : IDObject, IOwnerChangeListener, IPlacementEvent, IPrebuildEvent, IPrepareEvent
{
	public LineRenderer[] connections = new LineRenderer[0];

	public IDObjectRef[] connectionRefs = new IDObjectRef[0];

	public Color highlightTintColor = Color.yellow;

	public Event OnLit;

	public Event OnUnlit;

	private MeshRenderer mr;

	private MaterialPropertyBlock mpb;

	private MaterialPropertyBlock connectionMpb;

	private int tintColorID;

	private Color objColor = new Color(1f, 1f, 1f, 1f);

	public HagletValue<bool> isReceivingLight;

	public bool requiresHelper;

	private bool inPlacementHelper;

	public Bounds sensorBounds;

	public float boundsRadiusSqr;

	private Vector3[] testPoints;

	private ParticlePrefab receivingLightEffect;

	private Color[] connectionColors;

	private Vector3 previousPosition;

	private Quaternion previousRotation;

	private int lightsHitCount;

	private float emissive = 0.5f;

	private const int TEST_POINTS_NUM = 9;

	private static NativeArray<RaycastHit> raycastResultsNA;

	private static NativeArray<RaycastCommand> raycastCommandsNA;

	private static RaycastHit[] raycastResults;

	private static RaycastCommand[] raycastCommands;

	private static GCHandle raycastResultsHandle;

	private static GCHandle raycastCommandsHandle;

	private static int[] rayToSensorIdx;

	private static int raycastCommandsNum;

	private static JobHandle raycastJobHandle;

	private IHaglet prepareEventRoutine;

	private IHaglet waitForLoadRoutine;

	private FMOD.Studio.EventInstance sfxEventInst;

	public static void InitializeStatics()
	{
		NativeArrayOptions options = NativeArrayOptions.UninitializedMemory;
		int num = 500;
		raycastResultsNA = new NativeArray<RaycastHit>(num, Allocator.Persistent, options);
		raycastCommandsNA = new NativeArray<RaycastCommand>(num, Allocator.Persistent, options);
		raycastResults = new RaycastHit[num];
		raycastCommands = new RaycastCommand[num];
		raycastResultsHandle = GCHandle.Alloc(raycastResults, GCHandleType.Pinned);
		raycastCommandsHandle = GCHandle.Alloc(raycastCommands, GCHandleType.Pinned);
		rayToSensorIdx = new int[num];
	}

	public static void UninitializeStatics()
	{
		raycastResultsNA.Dispose();
		raycastCommandsNA.Dispose();
		raycastResultsHandle.Free();
		raycastCommandsHandle.Free();
	}

	public override void OnAwakeLR(MRBase owner)
	{
		base.OnAwakeLR(owner);
		isReceivingLight = HagletValue.Create(out isReceivingLight, null, initVal: false, null, 8);
		mr = GetComponent<MeshRenderer>();
		if ((bool)mr)
		{
			mpb = new MaterialPropertyBlock();
			tintColorID = Shader.PropertyToID("_TintColor");
			SetColorImmediate(Color.clear);
		}
		connectionColors = new Color[Mathf.Max(connections.Length, connectionRefs.Length)];
		connectionMpb = new MaterialPropertyBlock();
		connectionMpb.SetFloat("_Emissive", 0.5f);
		if (connections.Length != 0)
		{
			for (int i = 0; i < connections.Length; i++)
			{
				LineRenderer lineRenderer = connections[i];
				lineRenderer.SetPropertyBlock(connectionMpb);
				connectionColors[i] = lineRenderer.startColor;
				lineRenderer.startColor = Color.gray;
			}
		}
		else
		{
			Haglet.Create(out waitForLoadRoutine, WaitForLoadRoutine, null, startNow: true);
		}
		GeneratePoints();
		Haglet.Create(out prepareEventRoutine, PrepareEventRoutine);
	}

	Wait IPrepareEvent.PrepareEvents()
	{
		return prepareEventRoutine.Start();
	}

	private IEnumerator<Routine.Yield> PrepareEventRoutine()
	{
		OnLit.PrepareInvoke();
		yield return Wait.For.LRUpdates(1);
		OnUnlit.PrepareInvoke();
	}

	private IEnumerator<Routine.Yield> WaitForLoadRoutine()
	{
		_ = Wait.None;
		bool flag = true;
		while (flag)
		{
			yield return Wait.For.LRUpdates(1);
			flag = false;
			for (int i = 0; i < connectionRefs.Length; i++)
			{
				flag |= !connectionRefs[i].IsRefLoadedAndAwake();
			}
		}
		connections = new LineRenderer[connectionRefs.Length];
		for (int j = 0; j < connectionRefs.Length; j++)
		{
			connectionRefs[j].TryGetComponent<LineRenderer>(out var value);
			connections[j] = value;
		}
		for (int k = 0; k < connections.Length; k++)
		{
			LineRenderer lineRenderer = connections[k];
			lineRenderer.SetPropertyBlock(connectionMpb);
			connectionColors[k] = lineRenderer.startColor;
			lineRenderer.startColor = Color.gray;
		}
	}

	public unsafe static void KickOffAllRaycastCommands(ConstArray<LightSensor> sensors, ConstArray<LightSource> sources)
	{
		raycastCommandsNum = 0;
		Matrix4x4 value = default(Matrix4x4);
		Vector3 direction = default(Vector3);
		for (int i = 0; i < sensors._dataNum; i++)
		{
			LightSensor lightSensor = sensors._data[i];
			if (!lightSensor.isActiveAndEnabled)
			{
				continue;
			}
			lightSensor.lightsHitCount = 0;
			Transform transform = lightSensor.transform;
			Vector3 position = transform.position;
			LR.fast_localToWorldMatrix(transform, ref value);
			if (lightSensor.requiresHelper && !lightSensor.inPlacementHelper)
			{
				continue;
			}
			for (int j = 0; j < sources._dataNum; j++)
			{
				LightSource lightSource = sources._data[j];
				if (!lightSource || !lightSource.lightComp || !lightSource.lightComp.isActiveAndEnabled)
				{
					continue;
				}
				Light lightComp = lightSource.lightComp;
				Transform transform2 = lightComp.transform;
				Vector3 position2 = transform2.position;
				float range = lightComp.range;
				float num = range * range;
				float num2 = position.x - position2.x;
				float num3 = position.y - position2.y;
				float num4 = position.z - position2.z;
				if (num2 * num2 + num3 * num3 + num4 * num4 + lightSensor.boundsRadiusSqr > num)
				{
					continue;
				}
				Vector3 vector = transform2.rotation * Vector3X.forward;
				float num5 = Mathf.Cos(lightComp.spotAngle * 0.5f * ((float)Math.PI / 180f));
				for (int k = 0; k < lightSensor.testPoints.Length; k++)
				{
					float* ptr = (float*)(&value);
					Vector3 vector2 = lightSensor.testPoints[k];
					float num6 = *ptr * vector2.x + ptr[4] * vector2.y + ptr[8] * vector2.z + ptr[12];
					float num7 = ptr[1] * vector2.x + ptr[5] * vector2.y + ptr[9] * vector2.z + ptr[13];
					float num8 = ptr[2] * vector2.x + ptr[6] * vector2.y + ptr[10] * vector2.z + ptr[14];
					float num9 = num6 - position2.x;
					float num10 = num7 - position2.y;
					float num11 = num8 - position2.z;
					float num12 = num9 * num9 + num10 * num10 + num11 * num11;
					if (!(num12 > num))
					{
						float num13 = Mathf.Sqrt(num12);
						direction.x = num9 / num13;
						direction.y = num10 / num13;
						direction.z = num11 / num13;
						if (!(vector.x * direction.x + vector.y * direction.y + vector.z * direction.z <= num5))
						{
							rayToSensorIdx[raycastCommandsNum] = i;
							raycastCommands[raycastCommandsNum++] = new RaycastCommand(position2, direction, num13 - 0.02f, -1052673);
							lightSensor.lightsHitCount++;
						}
					}
				}
			}
		}
		UnsafeUtility.MemCpy(NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks(raycastCommandsNA), (void*)raycastCommandsHandle.AddrOfPinnedObject(), sizeof(RaycastCommand) * raycastCommandsNum);
		BatchQueryJob<RaycastCommand, RaycastHit> output = new BatchQueryJob<RaycastCommand, RaycastHit>(raycastCommandsNA, raycastResultsNA);
		JobsUtility.JobScheduleParameters parameters = new JobsUtility.JobScheduleParameters(UnsafeUtility.AddressOf(ref output), BatchQueryJobStruct<BatchQueryJob<RaycastCommand, RaycastHit>>.Initialize(), default(JobHandle), ScheduleMode.Run);
		raycastJobHandle = LR.ScheduleRaycastBatchWithLength(ref parameters, NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks(raycastCommandsNA), raycastCommandsNum, NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks(raycastResultsNA), raycastResults.Length, 1);
	}

	public unsafe static void OnUpdateAll(ConstArray<LightSensor> sensors)
	{
		raycastJobHandle.Complete();
		UnsafeUtility.MemCpy((void*)raycastResultsHandle.AddrOfPinnedObject(), NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks(raycastResultsNA), sizeof(RaycastHit) * raycastCommandsNum);
		for (int i = 0; i < raycastCommandsNum; i++)
		{
			if ((object)raycastResults[i].collider != null)
			{
				LightSensor lightSensor = sensors._data[rayToSensorIdx[i]];
				if (!raycastResults[i].transform.GetComponent<LightSensorStub>() && raycastCommands[i].distance > raycastResults[i].distance)
				{
					lightSensor.lightsHitCount--;
				}
			}
		}
		for (int j = 0; j < raycastCommandsNum; j++)
		{
			raycastResults[j] = default(RaycastHit);
		}
		UnsafeUtility.MemCpy(NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks(raycastResultsNA), (void*)raycastResultsHandle.AddrOfPinnedObject(), sizeof(RaycastHit) * raycastCommandsNum);
		float deltaTime = IC.DeltaTime;
		for (int k = 0; k < sensors._dataNum; k++)
		{
			LightSensor lightSensor2 = sensors._data[k];
			if (!lightSensor2.isActiveAndEnabled)
			{
				continue;
			}
			bool flag = lightSensor2.lightsHitCount > 0;
			bool value = lightSensor2.isReceivingLight.value;
			bool flag3 = (lightSensor2.isReceivingLight.value = flag);
			bool flag4 = flag3;
			if (!value && flag4)
			{
				lightSensor2.OnLit.Invoke();
				lightSensor2.receivingLightEffect = PSC.Inst.PlayAt(ParticleType.Light_Sensor, lightSensor2.mr.bounds.center);
				lightSensor2.receivingLightEffect.transform.SetParent(lightSensor2.transform);
				if (!lightSensor2.sfxEventInst.isValid())
				{
					lightSensor2.sfxEventInst = FAC.Inst.PlayOneShot(BaseSettings<LightSettings>.Inst.sensorReceivingLoop, lightSensor2.transform);
				}
			}
			else if (value && !flag4)
			{
				lightSensor2.OnUnlit.Invoke();
				lightSensor2.receivingLightEffect.gameObject.SetActive(value: false);
				lightSensor2.sfxEventInst.stop(STOP_MODE.ALLOWFADEOUT);
				lightSensor2.sfxEventInst = default(FMOD.Studio.EventInstance);
			}
			Color clear;
			float target;
			bool flag5;
			if (flag4)
			{
				clear = lightSensor2.highlightTintColor;
				target = 1f;
				flag5 = true;
			}
			else
			{
				clear = ColorX.clear;
				target = 0.5f;
				flag5 = false;
			}
			if (!ColorX.FastEquality(lightSensor2.objColor, clear))
			{
				lightSensor2.SetColorImmediate(ColorX.MoveTowards(lightSensor2.objColor, clear, deltaTime));
			}
			if (lightSensor2.connections.Length == 0)
			{
				continue;
			}
			float num = lightSensor2.emissive;
			lightSensor2.emissive = Mathf.MoveTowards(lightSensor2.emissive, target, deltaTime);
			if (lightSensor2.emissive != num)
			{
				lightSensor2.connectionMpb.SetFloat(ShaderPID._Emissive, lightSensor2.emissive);
				for (int l = 0; l < lightSensor2.connections.Length; l++)
				{
					LineRenderer obj = lightSensor2.connections[l];
					obj.SetPropertyBlock(lightSensor2.connectionMpb);
					Color target2 = (flag5 ? lightSensor2.connectionColors[l] : Color.gray);
					Color startColor = obj.startColor;
					startColor = (obj.startColor = ColorX.MoveTowards(startColor, target2, deltaTime));
					obj.endColor = startColor;
				}
			}
		}
	}

	private void SetColorImmediate(Color color)
	{
		if ((bool)mr)
		{
			objColor.r = color.r;
			objColor.g = color.g;
			objColor.b = color.b;
			objColor.a = color.a;
			mpb.SetColor(tintColorID, objColor);
			mr.SetPropertyBlock(mpb);
		}
	}

	void IOwnerChangeListener.OnOwnerChange(MRBase _oldOwner, MRBase _newOwner)
	{
		MRBase.TransferObject(_oldOwner, _newOwner, this);
	}

	void IPrebuildEvent.OnPrebuildRoot(bool isPrefab)
	{
		LightSensorCollision.AddStubs(base.transform);
	}

	public void OnPlacementGrabbed()
	{
		inPlacementHelper = true;
	}

	public void OnPlacementUngrabbed()
	{
		inPlacementHelper = false;
	}

	public void Reset()
	{
		MeshFilter component = GetComponent<MeshFilter>();
		if ((bool)component)
		{
			sensorBounds = component.sharedMesh.bounds;
		}
	}

	public void GeneratePoints()
	{
		if (sensorBounds.size.magnitude > 0f)
		{
			Vector3 extents = sensorBounds.extents;
			testPoints = new Vector3[9];
			testPoints[0] = sensorBounds.center;
			testPoints[1] = sensorBounds.center + new Vector3(extents.x, extents.y, extents.z);
			testPoints[2] = sensorBounds.center + new Vector3(0f - extents.x, extents.y, extents.z);
			testPoints[3] = sensorBounds.center + new Vector3(extents.x, extents.y, 0f - extents.z);
			testPoints[4] = sensorBounds.center + new Vector3(0f - extents.x, extents.y, 0f - extents.z);
			testPoints[5] = sensorBounds.center + new Vector3(extents.x, 0f - extents.y, extents.z);
			testPoints[6] = sensorBounds.center + new Vector3(0f - extents.x, 0f - extents.y, extents.z);
			testPoints[7] = sensorBounds.center + new Vector3(extents.x, 0f - extents.y, 0f - extents.z);
			testPoints[8] = sensorBounds.center + new Vector3(0f - extents.x, 0f - extents.y, 0f - extents.z);
		}
		else
		{
			testPoints = new Vector3[1];
			testPoints[0] = base.transform.TransformPoint(sensorBounds.center);
		}
		boundsRadiusSqr = sensorBounds.extents.magnitude;
		boundsRadiusSqr *= boundsRadiusSqr;
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.matrix = base.transform.localToWorldMatrix;
		Gizmos.DrawWireCube(sensorBounds.center, sensorBounds.size);
	}
}
public class LightSensorCollision : MonoBehaviour, IPrebuildEvent
{
	void IPrebuildEvent.OnPrebuildRoot(bool isPrefab)
	{
		AddStubs(base.transform);
	}

	public static void AddStubs(Transform target)
	{
		Collider[] componentsInChildren = target.GetComponentsInChildren<Collider>();
		foreach (Collider collider in componentsInChildren)
		{
			if (!collider.GetComponent<LightSensorStub>())
			{
				collider.gameObject.AddComponent<LightSensorStub>();
			}
		}
		Collider component = target.GetComponent<Collider>();
		if ((bool)component && !component.gameObject.GetComponent<LightSensorStub>())
		{
			component.gameObject.AddComponent<LightSensorStub>();
		}
	}
}
public class LightSensorStub : MonoBehaviour
{
}
public class MultiDirectionPlayerEntryPoint : PlayerEntryPoint
{
	[Serializable]
	public struct ChapterRotation
	{
		public SaveDataGame.Chapter chapter;

		public float rotation;

		public Vector3 position;
	}

	[SerializeField]
	private ChapterRotation[] chapterRotations;

	private Vector3 worldPosition;

	public override void OnAwakeLR(MRBase owner)
	{
		base.OnAwakeLR(owner);
	}

	public void SetPositionAndRotation(SaveDataGame.Chapter chapter)
	{
		for (int i = 0; i < chapterRotations.Length; i++)
		{
			if (chapterRotations[i].chapter == chapter)
			{
				base.transform.position = base.transform.TransformPoint(chapterRotations[i].position);
				base.transform.rotation = Quaternion.Euler(0f, chapterRotations[i].rotation, 0f);
				UnityEngine.Debug.Log("Set rotation! " + chapter);
				return;
			}
		}
		UnityEngine.Debug.Log("falied!" + chapter);
	}
}
public class Obelisk : IDObject
{
	private float lookAtTimer;

	private Collider obColldier;

	public Constellation constellation;

	private IHaglet obliskAnimatonRoutine;

	public override void OnAwakeLR(MRBase owner)
	{
		base.OnAwakeLR(owner);
		obColldier = GetComponentInChildren<Collider>(includeInactive: true);
		Haglet.Create(out obliskAnimatonRoutine, ObliskAnimatonRoutine, null, constellation != null);
	}

	private bool IsPlayerLookingAtObelisk()
	{
		ObeliskSettings inst = BaseSettings<ObeliskSettings>.Inst;
		Vector3 headPosition = IC.GetHeadPosition();
		Vector3 normalized = (IC.GetHeadRotation() * Vector3.forward).normalized;
		Vector3 normalized2 = (base.transform.position - headPosition).normalized;
		if (Vector3.Dot(normalized2, normalized) > inst.obeliskLookAtAccuracy)
		{
			if (Physics.Raycast(headPosition, normalized2, out var hitInfo, Vector3.Distance(headPosition, base.transform.position)))
			{
				if (hitInfo.collider == obColldier)
				{
					lookAtTimer += IC.DeltaTime;
				}
				else
				{
					lookAtTimer = 0f;
				}
			}
			else
			{
				lookAtTimer += IC.DeltaTime;
			}
		}
		else
		{
			lookAtTimer = 0f;
		}
		return lookAtTimer >= inst.obeliskLookAtTime;
	}

	private IEnumerator<Routine.Yield> ObliskAnimatonRoutine()
	{
		_ = BaseSettings<ObeliskSettings>.Inst;
		while (true)
		{
			if (MainCamera.Inst.GetOwner() == owner)
			{
				yield return constellation.FillConstellation();
			}
			yield return Wait.For.LRUpdates(1);
		}
	}
}
[Serializer.ExcludeAllFields]
public class ObeliskPuzzle : MonoBehaviour, IPrepareEvent
{
	public MRBase owner;

	public IDObjectRef puzzleReference;

	private MeshRenderer puzzleRenderer;

	private Obelisk obelisk;

	[Serializer.IncludeField]
	public bool complete;

	[NonSerialized]
	[HideInInspector]
	public bool AnimComplete;

	public bool onlyRunInScene = true;

	public Event onComplete;

	private bool wasStarted;

	private Func<bool> IsComplete;

	private Func<bool> IsAnimComplete;

	public IHaglet puzzleRoutine;

	private IHaglet puzzleCompleteRoutine;

	public Wait WaitForComplete => Wait.Until.True(IsComplete);

	public Wait WaitForAnimComplete => Wait.Until.True(IsAnimComplete);

	public Wait WaitForIncomplete => Wait.Until.False(IsComplete);

	public void OnLoadLR(MRBase owner)
	{
		if (!onlyRunInScene)
		{
			puzzleRoutine.Start(resetIfStarted: true, complete);
		}
	}

	public void OnAwakeLR(MRBase owner)
	{
		this.owner = owner;
		if (onComplete == null)
		{
			onComplete = new Event();
		}
		obelisk = GetComponentInParent<Obelisk>();
		IsComplete = () => complete;
		IsAnimComplete = () => AnimComplete;
		Haglet.Create(out puzzleCompleteRoutine, PuzzleCompleteRoutine);
		if (!onlyRunInScene)
		{
			puzzleRoutine.Start(resetIfStarted: false, complete);
		}
	}

	Wait IPrepareEvent.PrepareEvents()
	{
		onComplete.PrepareInvoke();
		return Wait.None;
	}

	public ObeliskPuzzleObject GetPuzzleObject()
	{
		return puzzleReference.GetOrNull<ObeliskPuzzleObject>(base.gameObject);
	}

	private IEnumerator<Routine.Yield> PuzzleRoutine()
	{
		wasStarted = true;
		while (IDObjectRef.IsValid(puzzleReference) && !puzzleReference.IsRefLoaded())
		{
			yield return Wait.For.LRUpdates(1);
		}
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		ObeliskPuzzleObject puzzleObject = GetPuzzleObject();
		if (!puzzleObject)
		{
			yield break;
		}
		yield return Routine.Yield.SpecialIndex.RoutineResetToHere;
		bool solved = false;
		while (!solved)
		{
			if (puzzleObject == null)
			{
				puzzleObject = GetPuzzleObject();
			}
			if (!puzzleObject)
			{
				yield return Wait.For.LRUpdates(1);
				continue;
			}
			bool flag = puzzleObject.IsAboveMatchThreshold();
			float completionTime = BaseSettings<RasterizerSettings>.Inst.requiredMatchTime;
			if (flag)
			{
				Hand.PulseHapticFeedback(1f, 0.8f, 0.2f, GetControllerMask());
			}
			while (completionTime > 0f && flag)
			{
				yield return Wait.For.LRUpdates(1);
				completionTime -= IC.DeltaTime;
				flag = puzzleObject.IsAboveMatchThreshold();
				if (Routine.Skipping)
				{
					break;
				}
			}
			if (completionTime <= 0f || Routine.Skipping)
			{
				solved = true;
			}
			yield return Wait.For.LRUpdates(1);
		}
		yield return puzzleCompleteRoutine.Call();
	}

	private OVRInput.Controller GetControllerMask()
	{
		return OVRInput.Controller.Touch | OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote;
	}

	private IEnumerator<Routine.Yield> PuzzleCompleteRoutine()
	{
		complete = true;
		onComplete.Invoke();
		yield return GetPuzzleObject().CompleteObeliskPuzzle();
		AnimComplete = true;
		yield return Wait.For.Seconds(0.5f);
	}

	public void ResetPuzzle()
	{
		ObeliskPuzzleObject orNull = puzzleReference.GetOrNull<ObeliskPuzzleObject>(base.gameObject);
		if ((bool)orNull)
		{
			orNull.Reset();
		}
		complete = false;
		puzzleRoutine.Start(resetIfStarted: true, skip: false, waitUntilCompleted: false);
	}
}
public abstract class ObeliskPuzzleObject : IDObject, IAreaEvent, IPrepareEvent, IAwakeEvent
{
	[Range(0f, 1f)]
	public float requiredMatchPercentage = 0.8f;

	[Range(0f, 1f)]
	public float feedbackStartPercentage = 0.2f;

	[SerializeField]
	[ReadOnly]
	protected float currentMatchPercentage;

	[HideInInspector]
	public bool updateFeedback = true;

	public PuzzleInfo puzzleInfo;

	public Event onComplete;

	protected Func<bool> AboveThreshold;

	public IHaglet puzzleRoutine;

	public abstract Wait CompleteObeliskPuzzle();

	public void IntializePuzzle()
	{
		if (onComplete == null)
		{
			onComplete = new Event();
		}
		if ((bool)puzzleInfo)
		{
			Haglet.Create(out puzzleRoutine, PuzzleRoutine, puzzleInfo.PuzzleName + " - " + puzzleInfo.puzzleType, startNow: false, null, "Hagis");
		}
	}

	Wait IPrepareEvent.PrepareEvents()
	{
		onComplete.PrepareInvoke();
		return Wait.None;
	}

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		if ((bool)puzzleInfo && puzzleInfo.clearProgressOnLoad)
		{
			LR.Inst.saveDataGame.UncompletePuzzleScene(puzzleInfo.PuzzleName, puzzleInfo.GetPuzzleChapter());
		}
	}

	public virtual void OnAreaEnter()
	{
		if ((bool)puzzleInfo && !puzzleRoutine.completed && !puzzleRoutine.started)
		{
			puzzleRoutine.Start(resetIfStarted: false, puzzleInfo.IsComplete(SaveDataGame.PuzzleSaveType.Scene));
		}
	}

	public virtual void OnAreaExit()
	{
	}

	public virtual float GetCurrentMatchPercentage()
	{
		return currentMatchPercentage;
	}

	public virtual bool IsAboveMatchThreshold()
	{
		return currentMatchPercentage >= requiredMatchPercentage;
	}

	public virtual Wait WaitUntilAboveThreshold()
	{
		return Wait.Until.True(AboveThreshold);
	}

	public virtual Wait WaitUntilUnderThreshold()
	{
		return Wait.Until.False(AboveThreshold);
	}

	public abstract void EvaluteFeedback();

	public abstract void Reset();

	private IEnumerator<Routine.Yield> PuzzleRoutine()
	{
		bool solved = false;
		while (!solved)
		{
			bool flag = IsAboveMatchThreshold();
			float completionTime = BaseSettings<RasterizerSettings>.Inst.requiredMatchTime;
			if (flag)
			{
				Hand.PulseHapticFeedback(1f, 0.8f, 0.2f, GetControllerMask());
			}
			while (completionTime > 0f && flag)
			{
				yield return Wait.For.LRUpdates(1);
				completionTime -= IC.DeltaTime;
				flag = IsAboveMatchThreshold();
				if (Routine.Skipping)
				{
					break;
				}
			}
			if (completionTime <= 0f || Routine.Skipping)
			{
				solved = true;
			}
			yield return Wait.For.LRUpdates(1);
		}
		yield return puzzleInfo.SetComplete();
		onComplete.Invoke();
		if (!Routine.Skipping)
		{
			yield return LR.Inst.Save();
		}
		yield return CompleteObeliskPuzzle();
		puzzleInfo.puzzleAnimComplete.Trigger();
	}

	public override void OnDestroy()
	{
		base.OnDestroy();
		if (puzzleRoutine != null && puzzleRoutine.started)
		{
			puzzleRoutine.Stop();
		}
	}

	private OVRInput.Controller GetControllerMask()
	{
		return OVRInput.Controller.Touch | OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote;
	}
}
public class OccludeeStateIndicationSpot : MonoBehaviour
{
}
public class OcclusionRing : MonoBehaviour
{
}
public class STUB_IgnoreOcclusionRenderer : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class OcclusionPortalToggle : MonoBehaviour, IRealtimeUpdate
{
	public bool setOpen;

	public PlayerAreaTrigger triggerArea;

	public OcclusionPortal[] controlledPortals;

	void IRealtimeUpdate.OnRealtimeUpdateLR()
	{
		if (triggerArea.IsHeadInsideBool)
		{
			OcclusionPortal[] array = controlledPortals;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].open = setOpen;
			}
		}
		else
		{
			OcclusionPortal[] array = controlledPortals;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].open = !setOpen;
			}
		}
	}
}
public class PlanetariumController : MonoBehaviour, IAwakeEvent, IAreaEvent
{
	public PlanetariumLever[] levers;

	public void OnAwakeLR(MRBase owner)
	{
		for (int i = 0; i < levers.Length; i++)
		{
		}
	}

	public void OnLeverPulled(PlanetariumLever lever)
	{
		for (int i = 0; i < levers.Length; i++)
		{
			if (levers[i].enabled && levers[i] != lever)
			{
				levers[i].ResetLever();
			}
		}
	}

	void IAreaEvent.OnAreaEnter()
	{
		for (int i = 0; i < levers.Length; i++)
		{
			PlanetariumLever obj = levers[i];
			int puzzlesNum = obj.chapterInfo.GetPuzzlesNum(PuzzleInfo.PuzzleType.OPTIONAL);
			int completedPuzzlesNum = obj.chapterInfo.GetCompletedPuzzlesNum(SaveDataGame.PuzzleSaveType.Progression, PuzzleInfo.PuzzleType.OPTIONAL);
			obj.SetRootStates(completedPuzzlesNum == puzzlesNum);
		}
	}

	void IAreaEvent.OnAreaExit()
	{
	}
}
public class PlanetariumDisplay : MonoBehaviour, IAreaEvent
{
	public ChapterInfo[] ChaptersRequired;

	public void OnAreaEnter()
	{
		bool flag = true;
		for (int i = 0; i < ChaptersRequired.Length; i++)
		{
			flag &= ChaptersRequired[i].IsChapterComplete();
		}
		if (!flag)
		{
			base.gameObject.SetActive(value: false);
		}
	}

	public void OnAreaExit()
	{
	}
}
public class PlanetariumLever : MonoBehaviour, IAreaEvent, IUpdateEvent
{
	private FixedRotatableObject rotatable;

	private Portal portal;

	public ChapterInfo chapterInfo;

	public GameObject portalRoot;

	public SceneInfo_BundleRef sceneInfo;

	public PuzzleInfo mainPuzzleInfo;

	private MRBase owner;

	private LeverController leverController;

	private GameObject activeRoot;

	private GameObject inactiveRoot;

	[NonSerialized]
	[HideInInspector]
	public bool DebugUnlock;

	private IHaglet unlockPortalRoutine;

	public void OnAwakeLR(MRBase owner)
	{
		this.owner = owner;
		rotatable = GetComponentInChildren<FixedRotatableObject>();
		activeRoot = base.transform.Find("ActiveRoot").gameObject;
		inactiveRoot = base.transform.Find("InactiveRoot").gameObject;
		ResetLever();
		SetRootStates(active: false);
		portal = (portalRoot ? portalRoot.GetComponentInChildren<Portal>(includeInactive: true) : null);
		if ((bool)portal)
		{
			portal.SetUnlockedState(unlocked: false, applyToLink: false);
		}
		Haglet.Create(out unlockPortalRoutine, UnlockPortalRoutine);
	}

	public void AssignLeverController(LeverController controller)
	{
		leverController = controller;
	}

	private SceneInfo GetTargetSceneInfo()
	{
		return sceneInfo.Load();
	}

	public void OnAreaEnter()
	{
		PuzzleInfo.PuzzleType puzzleType = (PuzzleInfo.PuzzleType)3;
		rotatable.enabled = DebugUnlock || chapterInfo.GetPuzzlesNum(puzzleType) == chapterInfo.GetCompletedPuzzlesNum(SaveDataGame.PuzzleSaveType.Progression, puzzleType);
		SetRootStates(rotatable.enabled);
		if ((bool)portalRoot)
		{
			portalRoot.SetActive(value: false);
			if (portal.GetPortalState() != PortalState.LOCKED)
			{
				portal.SetUnlockedState(unlocked: false, applyToLink: false);
				owner.RemoveConnectingScene(GetTargetSceneInfo());
				LR.Inst.LoadAdjacentScenes();
			}
		}
	}

	void IUpdateEvent.OnUpdateLR()
	{
		if (MainCamera.Inst.GetOwner() != owner && portal.GetPortalState() != 0 && !rotatable.enabled)
		{
			ResetLever();
		}
	}

	public void OnAreaExit()
	{
	}

	[Event(EventName = "Enable Portal")]
	public void EnablePortal(object sender)
	{
		rotatable.enabled = false;
		LR.Inst.saveDataGame.currentMansfieldPuzzle = mainPuzzleInfo;
		LR.Inst.saveDataGame.lastChapter = SaveDataGame.Chapter.Mansfield;
		LR.Inst.Save();
		SceneInfo targetSceneInfo = GetTargetSceneInfo();
		leverController.LoadScene(targetSceneInfo, this);
		if ((bool)portalRoot && !unlockPortalRoutine.started)
		{
			portalRoot.SetActive(value: true);
			unlockPortalRoutine.Start();
		}
	}

	private IEnumerator<Routine.Yield> UnlockPortalRoutine()
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		portal.SetUnlockedState(unlocked: true);
	}

	[Event(EventName = "Disable Portal")]
	public void DisablePortal(object sender)
	{
		if ((bool)portalRoot)
		{
			portalRoot.SetActive(value: false);
		}
	}

	public void SetRootStates(bool active)
	{
		activeRoot.SetActive(active);
		inactiveRoot.SetActive(!active);
	}

	public void ResetLever()
	{
		rotatable.Animate(-45f, 0.5f);
		rotatable.enabled = true;
	}
}
public class PlanetariumPanel : MonoBehaviour, IAreaEvent
{
	public GameObject completedPanel;

	public PuzzleInfo PuzzleRequired;

	public void OnAreaEnter()
	{
		if (PuzzleRequired.IsComplete(SaveDataGame.PuzzleSaveType.Progression))
		{
			completedPanel.SetActive(value: true);
			base.gameObject.SetActive(value: false);
		}
	}

	public void OnAreaExit()
	{
	}
}
internal interface IPlayerEnterEvent
{
	void OnAwakeLR();

	void OnPlayerEnter();
}
public class PlayerEntryPoint : IDObject
{
	public Region telepadRegion;

	private IPlayerEnterEvent[] playerevents;

	public override void OnAwakeLR(MRBase owner)
	{
		base.OnAwakeLR(owner);
		playerevents = GetComponentsInChildren<IPlayerEnterEvent>();
		for (int i = 0; i < playerevents.Length; i++)
		{
			playerevents[i].OnAwakeLR();
		}
	}

	public void OnPlayerEnter()
	{
		for (int i = 0; i < playerevents.Length; i++)
		{
			playerevents[i].OnPlayerEnter();
		}
	}
}
[Serializer.ExcludeAllFields]
public class InventoryState
{
	public const int KMaxSize = 128;

	[Serializer.IncludeField]
	public ConstArray<GrabObject> grabObjects = new ConstArray<GrabObject>(128u);

	public void EmptyInventoryState(bool fromSaveData)
	{
		for (int i = 0; i < grabObjects.Length; i++)
		{
			grabObjects[i].inventoryObject.OnRemovedFromInventory(fromSaveData);
		}
		grabObjects.ClearToDefault();
	}

	public void AddToInventoryList(GrabObject grabObject, bool playEffect = true)
	{
		if (!grabObjects.Contains(grabObject))
		{
			InventoryObject inventoryObject = grabObject.inventoryObject;
			grabObjects.Add(grabObject);
			inventoryObject.OnAddedToInventory();
			inventoryObject.playedEffect = false;
			if (playEffect)
			{
				PlayerInventory.Inst.OnAddToInventory();
			}
		}
		if (grabObject.allowSaving)
		{
			LR.Inst.saveDataGame.AddObjectToChapterInventory(MainCamera.Inst.GetOwner().info.Load().GetPuzzleChapter(), grabObject);
		}
		GrabObject grabObject2 = ((grabObject.mimic != null) ? grabObject.mimic.GrabObjectMimic : null);
		if ((bool)grabObject2 && !grabObjects.Contains(grabObject2))
		{
			InventoryObject inventoryObject2 = grabObject2.inventoryObject;
			grabObjects.Add(grabObject2);
			inventoryObject2.OnAddedToInventory();
		}
		if ((bool)grabObject2 && grabObject2.allowSaving)
		{
			LR.Inst.saveDataGame.AddObjectToChapterInventory(MainCamera.Inst.GetOwner().info.Load().GetPuzzleChapter(), grabObject2);
		}
	}

	public void RemoveFromInventoryList(GrabObject grabObject)
	{
		if (grabObjects.Contains(grabObject))
		{
			grabObjects.RemoveStable(grabObject);
			grabObject.inventoryObject.OnRemovedFromInventory();
		}
		GrabObject grabObject2 = ((grabObject.mimic != null) ? grabObject.mimic.GrabObjectMimic : null);
		if ((bool)grabObject2 && grabObjects.Contains(grabObject2))
		{
			grabObjects.RemoveStable(grabObject2);
			grabObject2.inventoryObject.OnRemovedFromInventory();
		}
	}

	public bool InInventory(GrabObject grabObject)
	{
		if ((bool)grabObject.mimic)
		{
			if (!grabObjects.Contains(grabObject))
			{
				return grabObjects.Contains(grabObject.mimic.GrabObjectMimic);
			}
			return true;
		}
		return grabObjects.Contains(grabObject);
	}

	public static void DeepCopy(InventoryState src, InventoryState dst)
	{
		src.grabObjects.CopyTo(dst.grabObjects);
	}
}
public enum InventoryEffectType
{
	OPEN,
	ADD
}
public enum InventoryStoryItem
{
	JOURNAL,
	ID_CARD,
	NOTICE,
	MAX
}
[Serializer.ExcludeAllFields]
public class PlayerInventory : MonoBehaviour
{
	private struct SelectedObject
	{
		public InventoryObject invObject;

		public Hand hand;

		public int index;

		private float timer;

		private bool atRest;

		public InventoryObject selectedObject
		{
			get
			{
				if (!atRest)
				{
					return null;
				}
				return invObject;
			}
		}

		public bool IsIntersectingHand()
		{
			return invObject.IsIntersectingHand(hand);
		}

		public void UpdateRest(SelectedObject other, float globalResetTime)
		{
			if (other.invObject != null && other.invObject.ValidEGRillIndex == Inst.CurrentEGrillIndex && Inst.currentEffectType == InventoryEffectType.OPEN)
			{
				if (hand == other.hand && invObject == other.invObject)
				{
					if (timer > globalResetTime)
					{
						atRest = true;
						timer = 0f;
					}
					else
					{
						timer += IC.DeltaTime;
					}
				}
				else
				{
					timer = 0f;
				}
				hand = other.hand;
				invObject = other.invObject;
				index = other.index;
			}
			else
			{
				atRest = false;
				timer = 0f;
				hand = null;
				invObject = null;
				index = -1;
			}
		}
	}

	public struct InventoryPos
	{
		public Vector3 pos;

		public Quaternion rot;
	}

	private struct ItemAnimPair
	{
		public string animName;

		public InventoryStoryItem storyItem;

		public float animDelay;

		public FMODEventAsset sfx;
	}

	protected static PlayerInventory _instance;

	private ConstArray<InventoryObject> allInventoryObjects = new ConstArray<InventoryObject>(128u);

	public ConstArray<InventoryObject> lastInventoryObjects = new ConstArray<InventoryObject>(128u);

	public ConstArray<InventoryObject> validInventoryObjects = new ConstArray<InventoryObject>(128u);

	[Serializer.IncludeField]
	public InventoryState inventoryState = new InventoryState();

	private Vector3 posSpringVelocity = Vector3.zero;

	private Vector3 scaleSpringVelocity = Vector3.zero;

	[SerializeField]
	private Transform bagXform;

	[SerializeField]
	private Transform bagUIXform;

	[SerializeField]
	private Transform ringUIXform;

	[SerializeField]
	private ParticleSystem realToFantasy_PS;

	[SerializeField]
	private ParticleSystem fantasyToReal_PS;

	private ParticleSystemRenderer[] realToFantasy_PSRs;

	private ParticleSystemRenderer[] fantasyToReal_PSRs;

	private SkinnedMeshRenderer bagSMR;

	private MeshRenderer bagUIMR;

	private MeshRenderer ringUIMR;

	private MeshRenderer bagUIOMR;

	private MeshRenderer ringUIOMR;

	private ManualAnimation bagManAnim;

	private static readonly string CH_Backpack_Enter = "CH_Backpack_Enter";

	private static readonly string CH_Backpack_Idle = "CH_Backpack_Idle";

	private static readonly string CH_Backpack_Exit = "CH_Backpack_Exit";

	private Dictionary<InventoryStoryItem, GameObject> storyItemGameObjects = new Dictionary<InventoryStoryItem, GameObject>(3);

	private ConstArray<MeshRenderer> storyItemRenderers = new ConstArray<MeshRenderer>(4u);

	private MaterialPropertyBlock bagMPB;

	private MPBStore bagUIMPB;

	private MPBStore ringUIMPB;

	public static StackedBool InventoryEnabled;

	[NonSerialized]
	[HideInInspector]
	public Transform InventoryCentre;

	private int newItemCount;

	private bool checkDistance;

	private bool objectGrabbed;

	private Vector3 openPlayerPositionWS;

	private float openTimer;

	private FMOD.Studio.EventInstance radialSFX;

	private InventoryEffectType currentEffectType;

	private int currentEGrillIndex;

	private readonly HashSet<string> tmp_referencedGrabObjects = new HashSet<string>();

	private Material helperIconMat;

	public IHaglet enterChapterRoutine;

	private IHaglet closeInventoryRoutine;

	private IHaglet inventoryRoutine;

	private ConstQueue<ItemAnimPair> itemAnimPairs = new ConstQueue<ItemAnimPair>(3);

	private IHaglet inventoryCutsceneRoutine;

	public static PlayerInventory Inst => _instance;

	public InventorySettings Settings => BaseSettings<InventorySettings>.Inst;

	public int CurrentEGrillIndex => currentEGrillIndex;

	public Material HelperIconMat => helperIconMat;

	public void OnAwakeLR()
	{
		_instance = this;
		InventoryEnabled.Reset();
		bagMPB = new MaterialPropertyBlock();
		bagMPB.SetColor(ShaderPID._Color, BaseSettings<InventorySettings>.Inst.uiColor);
		bagMPB.SetFloat(ShaderPID._TransitionAmount, 0f);
		bagSMR = bagXform.GetComponentInChildren<SkinnedMeshRenderer>();
		bagManAnim = bagXform.GetComponent<ManualAnimation>();
		bagManAnim.Initalise();
		bagSMR.SetPropertyBlock(bagMPB);
		bagSMR.gameObject.SetActive(value: false);
		GameObject gameObject = new GameObject();
		gameObject.name = "InventoryCentre";
		InventoryCentre = gameObject.transform;
		InventoryCentre.parent = base.transform;
		InventoryCentre.position = Vector3.zero;
		InventoryCentre.rotation = Quaternion.identity;
		InventoryCentre.localScale = Vector3.one;
		bagXform.SetParent(InventoryCentre);
		bagXform.localPosition = Vector3X.zero;
		bagXform.localRotation = QuaternionX.identity;
		bagUIMR = bagUIXform.GetComponent<MeshRenderer>();
		bagUIOMR = bagUIXform.GetComponentInDirectChild<MeshRenderer>();
		bagUIMPB = new MPBStore();
		bagUIMPB.Initialise();
		bagUIMPB.SetColor(ShaderPID._Color, Settings.uiColor);
		bagUIMPB.ApplyProperties(bagUIMR);
		bagUIXform.SetParent(InventoryCentre);
		bagUIXform.localPosition = Vector3X.zero;
		bagUIXform.localRotation = QuaternionX.identity;
		ringUIMR = ringUIXform.GetComponent<MeshRenderer>();
		ringUIOMR = ringUIXform.GetComponentInDirectChild<MeshRenderer>();
		ringUIMPB = new MPBStore();
		ringUIMPB.Initialise();
		ringUIMPB.SetColor(ShaderPID._Color, Settings.uiColor);
		ringUIMPB.SetFloat(ShaderPID._MaxAngle, 0f);
		ringUIMPB.ApplyProperties(ringUIMR);
		ringUIXform.SetParent(InventoryCentre);
		ringUIXform.localPosition = Vector3X.zero;
		ringUIXform.localRotation = QuaternionX.identity;
		ShowHideUI(show: false);
		realToFantasy_PSRs = realToFantasy_PS.GetComponentsInChildren<ParticleSystemRenderer>(includeInactive: true);
		fantasyToReal_PSRs = fantasyToReal_PS.GetComponentsInChildren<ParticleSystemRenderer>(includeInactive: true);
		helperIconMat = new Material(BaseSettings<HelperSettings>.Inst.placementShapeMaterial);
		InventoryStoryItem_STUB[] componentsInChildren = GetComponentsInChildren<InventoryStoryItem_STUB>();
		foreach (InventoryStoryItem_STUB inventoryStoryItem_STUB in componentsInChildren)
		{
			storyItemGameObjects.Add(inventoryStoryItem_STUB.storyItem, inventoryStoryItem_STUB.gameObject);
			inventoryStoryItem_STUB.gameObject.SetActive(LR.Inst.saveDataGame.activeInventoryStoryItems.Contains(inventoryStoryItem_STUB.storyItem));
			MeshRenderer[] componentsInChildren2 = inventoryStoryItem_STUB.GetComponentsInChildren<MeshRenderer>(includeInactive: true);
			foreach (MeshRenderer obj in componentsInChildren2)
			{
				storyItemRenderers.Add(obj);
			}
		}
		Haglet.Create(out inventoryRoutine, InventoryRoutine);
		Haglet.Create(out closeInventoryRoutine, CloseInventoryRoutine);
		Haglet.Create(out enterChapterRoutine, EnterChapterRoutine);
		Haglet.Create(out inventoryCutsceneRoutine, InventoryCutsceneRoutine);
	}

	public void OnCreateInventoryObject(InventoryObject invObj)
	{
		allInventoryObjects.Add(invObj);
	}

	public void DestoryInventoryObject(InventoryObject invObj)
	{
		allInventoryObjects.Remove(invObj);
		RemoveFromInventory(invObj.grabObject);
		invObj.SetOwner(null);
		UnityEngine.Object.Destroy(invObj.gameObject);
	}

	public void DestroyUnusedObjects()
	{
		try
		{
			LR inst = LR.Inst;
			ConstArray<MRBase> mrsLoaded = inst.mrsLoaded;
			SaveDataGame saveDataGame = inst.saveDataGame;
			for (int i = 0; i < mrsLoaded.Length; i++)
			{
				MRBase mRBase = mrsLoaded[i];
				ConstArray<string> chapterInventory = saveDataGame.GetChapterInventory(mRBase.info.Load());
				for (int j = 0; j < chapterInventory.Length; j++)
				{
					tmp_referencedGrabObjects.Add(chapterInventory[j]);
				}
			}
			ConstArray<GrabObject> grabObjects = inventoryState.grabObjects;
			for (uint num = 0u; num < grabObjects.Length; num++)
			{
				tmp_referencedGrabObjects.Add(grabObjects[num].id);
			}
			for (uint num2 = 0u; num2 < allInventoryObjects.Length; num2++)
			{
				InventoryObject inventoryObject = allInventoryObjects[num2];
				GrabObject grabObject = inventoryObject.grabObject;
				if (grabObject.owner == null && !tmp_referencedGrabObjects.Contains(grabObject.id))
				{
					grabObject.inventoryObject = null;
					UnityEngine.Object.Destroy(inventoryObject);
					UnityEngine.Object.Destroy(grabObject);
					allInventoryObjects.RemoveAtIndex(num2);
					num2--;
				}
			}
		}
		finally
		{
			allInventoryObjects.ReleaseUnusedReferences();
			tmp_referencedGrabObjects.Clear();
		}
	}

	public void OnPlayerSceneChanged(MRBase ownerOld, MRBase ownerNew)
	{
		ownerOld = (ownerOld ? ownerOld : null);
		ownerNew = (ownerNew ? ownerNew : null);
		bool num = ownerOld;
		bool flag = ownerNew;
		if (num || flag)
		{
			bool? flag2 = ownerOld?.info?.Load()?.inFantasyWorld;
			bool? flag3 = ownerNew?.info?.Load()?.inFantasyWorld;
			if ((flag2 ?? true) && !(flag3 ?? false))
			{
				OnEnteredRealWorld();
			}
			else if (((!flag2) ?? true) && (flag3 ?? true))
			{
				OnEnteredFantasyWorld();
			}
		}
		if (!flag)
		{
			return;
		}
		ConstArray<GrabObject> grabObjects = inventoryState.grabObjects;
		for (int i = 0; i < grabObjects.Length; i++)
		{
			GrabObject grabObject = grabObjects[i];
			if (grabObject.inventoryObject.owner != ownerNew)
			{
				grabObject.inventoryObject.SetOwner(ownerNew);
			}
		}
	}

	private void OnEnteredRealWorld()
	{
		OnCrossedEGrill(0);
		TriggerTransition(toFantasy: false);
	}

	private void OnEnteredFantasyWorld()
	{
		TriggerTransition(toFantasy: true);
		enterChapterRoutine.Start(resetIfStarted: true);
	}

	private IEnumerator<Routine.Yield> EnterChapterRoutine()
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		while (!LR.Inst.AreAllLoadedScenesAwake)
		{
			yield return Wait.For.Updates(1);
		}
		EmptyInventory(fromSaveData: false);
		SceneInfo sceneInfo = MainCamera.Inst.GetOwner().info.Load();
		ConstArray<string> chapterInventory = LR.Inst.saveDataGame.GetChapterInventory(sceneInfo);
		uint length = chapterInventory.Length;
		for (int i = 0; i < length; i++)
		{
			if (LR.Inst.TryGetIDObject<GrabObject>(chapterInventory[i], out var value))
			{
				AddToInventory(value, playEffect: false);
			}
		}
	}

	public void RemoveFromInventory(GrabObject grabObj)
	{
		if ((bool)grabObj && inventoryState.InInventory(grabObj))
		{
			inventoryState.RemoveFromInventoryList(grabObj);
			grabObj.OnInventoryGrabbed.onPostHappen -= OnInventoryObjectGrab;
		}
	}

	public void MarkObjectForRemoval(GrabObject grabObject)
	{
		if ((bool)grabObject && inventoryState.InInventory(grabObject))
		{
			grabObject.inventoryObject.ObjectState = InvObjectState.TOREMOVE;
			grabObject.inventoryObject.RemovalMarkTime = Time.time;
			LR.Inst.saveDataGame.RemoveObjectToChapterInventory(MainCamera.Inst.GetOwner().info.Load().GetPuzzleChapter(), grabObject);
		}
	}

	public void AddToInventory(GrabObject grabObj, bool playEffect = true)
	{
		if ((bool)grabObj && !inventoryState.InInventory(grabObj))
		{
			if (!grabObj.inventoryObject.IsAwake)
			{
				grabObj.inventoryObject.OnAwakeLR(MainCamera.Inst.GetOwner());
			}
			else
			{
				grabObj.inventoryObject.SetOwner(MainCamera.Inst.GetOwner());
			}
			newItemCount += (playEffect ? 1 : 0);
			grabObj.OnInventoryGrabbed.onPostHappen += OnInventoryObjectGrab;
			inventoryState.AddToInventoryList(grabObj, playEffect);
		}
	}

	public void EmptyInventory(bool fromSaveData)
	{
		inventoryState.EmptyInventoryState(fromSaveData);
		lastInventoryObjects.ClearToDefault();
		validInventoryObjects.ClearToDefault();
	}

	public bool IsGrabObjectInInventory(GrabObject grabObject)
	{
		return inventoryState.grabObjects.Contains(grabObject);
	}

	[ContextMenu("Grab all")]
	public void GrabAll()
	{
		MRBase owner = MainCamera.Inst.GetOwner();
		for (int i = 0; i < owner.interactableObjects.Length; i++)
		{
			GrabObject grabObject = owner.interactableObjects[i] as GrabObject;
			if (!inventoryState.InInventory(grabObject))
			{
				inventoryState.AddToInventoryList(grabObject, playEffect: false);
			}
		}
	}

	public bool IsInventoryOpen()
	{
		return inventoryRoutine.started;
	}

	public bool IsInventoryClosing()
	{
		return closeInventoryRoutine.started;
	}

	private void ShowHideUI(bool show)
	{
		bagUIMR.enabled = show;
		bagUIOMR.enabled = show;
		ringUIMR.enabled = show;
		ringUIOMR.enabled = show;
	}

	public void CheckInventoryShouldOpen()
	{
		CC inst = CC.Inst;
		IC.IHandInput inputForHand = IC.GetInputForHand(inst.handL.ICHand);
		IC.IHandInput inputForHand2 = IC.GetInputForHand(inst.handR.ICHand);
		bool buttonDown = inputForHand.GetButtonDown();
		bool buttonDown2 = inputForHand2.GetButtonDown();
		if (!buttonDown && !buttonDown2 && (inputForHand.GetButtonHeld() || inputForHand2.GetButtonHeld()) && !inventoryRoutine.started && !closeInventoryRoutine.started && InventoryEnabled.Value && !LR.Inst.IsMenuActive())
		{
			UpdateOpenTimer(IC.DeltaTime);
		}
		else if (buttonDown || buttonDown2)
		{
			if (inventoryRoutine.started)
			{
				CloseInventory();
			}
		}
		else
		{
			UpdateOpenTimer((0f - IC.DeltaTime) * 2f);
		}
	}

	public void UpdateOpenTimer(float dt)
	{
		openTimer += dt;
		openTimer = Mathf.Max(openTimer, 0f);
		if (dt > 0f && !radialSFX.isValid())
		{
			radialSFX = FAC.Inst.PlayOneShot(Settings.sfxRadialTimer, InventoryCentre);
		}
		else if (dt < 0f && radialSFX.isValid())
		{
			radialSFX.stop(STOP_MODE.ALLOWFADEOUT);
		}
		if (openTimer == 0f)
		{
			ShowHideUI(show: false);
			return;
		}
		if (openTimer > 0f && !bagUIMR.enabled)
		{
			ShowHideUI(show: true);
		}
		if (openTimer >= Settings.inventoryOpenTime)
		{
			OpenInventory(InventoryEffectType.OPEN);
			openTimer = 0f;
			ShowHideUI(show: false);
			return;
		}
		SetInventoryPosition();
		float value = Mathf.Clamp01(openTimer / Settings.inventoryOpenTime);
		ringUIMPB.SetFloat(ShaderPID._MaxAngle, value);
		value = Mathf.Clamp(openTimer / Settings.inventoryUIFadeTime, 0f, Settings.inventoryUIMaxAlpha);
		Color color = Settings.uiColor.RepA(value);
		Color color2 = Settings.uiOutlineColor.RepA(value);
		ringUIMPB.SetColor(ShaderPID._Color, color.RepA(value));
		bagUIMPB.SetColor(ShaderPID._Color, color.RepA(value));
		ringUIMPB.ApplyProperties(ringUIMR);
		bagUIMPB.ApplyProperties(bagUIMR);
		ringUIMPB.SetColor(ShaderPID._Color, color2.RepA(value));
		bagUIMPB.SetColor(ShaderPID._Color, color2.RepA(value));
		ringUIMPB.ApplyProperties(ringUIOMR);
		bagUIMPB.ApplyProperties(bagUIOMR);
	}

	public void ResetOpenTimer()
	{
		openTimer = 0f;
		ShowHideUI(show: false);
	}

	private void SetInventoryPosition(out Vector3 worldPos, out Quaternion rotation)
	{
		InventoryPos inventoryPos = CalculateInventoryPosition(new Vector2(0.2f, 0.2f));
		worldPos = inventoryPos.pos;
		rotation = inventoryPos.rot;
		InventoryCentre.position = worldPos;
		InventoryCentre.rotation = rotation;
	}

	private void SetInventoryPosition()
	{
		SetInventoryPosition(out var _, out var _);
	}

	public void OpenInventory(InventoryEffectType effectType, bool _checkDistance = true)
	{
		if (!LR.Inst.WasMenuActive() && InventoryEnabled.Value)
		{
			if (!inventoryRoutine.started && !closeInventoryRoutine.started)
			{
				posSpringVelocity = Vector3.zero;
				scaleSpringVelocity = Vector3.zero;
			}
			if (closeInventoryRoutine.started)
			{
				closeInventoryRoutine.Stop();
			}
			if (!inventoryRoutine.started)
			{
				currentEffectType = effectType;
				checkDistance = _checkDistance;
				inventoryRoutine.Start();
			}
		}
	}

	public void CloseInventory(bool stopRoutine = true)
	{
		if (newItemCount <= 0 || !InventoryEnabled.Value)
		{
			newItemCount = 0;
			if (stopRoutine && inventoryRoutine.started)
			{
				inventoryRoutine.Stop();
			}
			objectGrabbed = false;
			if (!closeInventoryRoutine.started)
			{
				closeInventoryRoutine.Start();
			}
		}
	}

	public void OnAddToInventory()
	{
		ConstArray<GrabObject> grabObjects = inventoryState.grabObjects;
		for (int i = 0; i < grabObjects.Length; i++)
		{
			InventoryObject inventoryObject = grabObjects[i].inventoryObject;
			int num = grabObjects.sLength - newItemCount;
			if (i < num)
			{
				inventoryObject.ObjectState = ((!inventoryRoutine.started) ? InvObjectState.HIDDEN : inventoryObject.ObjectState);
			}
			else if (inventoryObject.ObjectState != InvObjectState.ADDING)
			{
				inventoryObject.ObjectState = InvObjectState.SPAWNING;
			}
		}
		if (!inventoryRoutine.started)
		{
			OpenInventory(InventoryEffectType.ADD, _checkDistance: false);
		}
	}

	private void OnInventoryObjectGrab()
	{
		CC inst = CC.Inst;
		InteractableObject interactableHeld = inst.handR.InteractableHeld;
		GrabObject grabObject = (inst.handR.InteractableHighlighted as InventoryObject)?.grabObject ?? null;
		InteractableObject interactableHeld2 = inst.handL.InteractableHeld;
		GrabObject grabObject2 = (inst.handL.InteractableHighlighted as InventoryObject)?.grabObject ?? null;
		if (inventoryState.grabObjects.Length == 1)
		{
			CloseInventory();
		}
		else if (((bool)interactableHeld && interactableHeld != grabObject2) || ((bool)interactableHeld2 && interactableHeld2 != grabObject))
		{
			CloseInventory();
		}
		objectGrabbed = true;
	}

	public void OnCrossedEGrill(int areaIndex)
	{
		currentEGrillIndex = areaIndex;
	}

	public void TriggerTransition(bool toFantasy)
	{
		ParticleSystemRenderer[] particles;
		if (toFantasy)
		{
			fantasyToReal_PS.Stop();
			realToFantasy_PS.Play();
			particles = realToFantasy_PSRs;
		}
		else
		{
			realToFantasy_PS.Stop();
			fantasyToReal_PS.Play();
			particles = fantasyToReal_PSRs;
		}
		CC.Inst.TriggerTransition(toFantasy, bagSMR, bagMPB, particles);
	}

	private IEnumerator<Routine.Yield> CloseInventoryRoutine()
	{
		uint noOfObjects = validInventoryObjects.Length;
		for (int i = 0; i < noOfObjects; i++)
		{
			InventoryObject inventoryObject = validInventoryObjects[i];
			inventoryObject.SetGrabbable(value: false);
			if ((bool)inventoryObject.activeEffect)
			{
				inventoryObject.activeEffect.StopParticles();
			}
		}
		int itemsSettled = 0;
		_ = InventoryCentre.position;
		while (itemsSettled < noOfObjects)
		{
			itemsSettled = 0;
			for (int j = 0; j < noOfObjects; j++)
			{
				InventoryObject inventoryObject2 = validInventoryObjects[j];
				inventoryObject2.UpdateScaleSpring(Vector3X.zero, Settings.inventoryItemCloseSpring);
				inventoryObject2.UpdatePositionSpring(bagXform.transform.position, Settings.inventoryItemCloseSpring);
				inventoryObject2.ScaleBasedDither();
				if (inventoryObject2.transform.localScale.magnitude < 0.03f)
				{
					inventoryObject2.SetVisible(_visible: false);
					itemsSettled++;
				}
			}
			yield return Wait.For.LRRealtimeUpdates(1);
		}
		for (int k = 0; k < lastInventoryObjects.Length; k++)
		{
			InventoryObject inventoryObject3 = lastInventoryObjects[k];
			if (inventoryObject3.ObjectState != InvObjectState.REMOVING && inventoryObject3.ObjectState != InvObjectState.TOREMOVE)
			{
				inventoryObject3.ObjectState = (inventoryObject3.grabObject.FinishedWith ? InvObjectState.TOREMOVE : InvObjectState.DEFAULT);
			}
			else
			{
				RemoveFromInventory(inventoryObject3.grabObject);
			}
		}
		FAC.Inst.PlayOneShot(Settings.sfxClose, InventoryCentre.position);
		yield return bagManAnim.PlayAnimManual(LR.Inst.onRealTimeUpdate, call: true, CH_Backpack_Exit);
		bagMPB.SetFloat(ShaderPID._DitherAlphaValue, 1f);
		bagSMR.SetPropertyBlock(bagMPB);
		for (int l = 0; l < storyItemRenderers.Length; l++)
		{
			storyItemRenderers[l].SetPropertyBlock(bagMPB);
		}
		bagSMR.gameObject.SetActive(value: false);
	}

	private IEnumerator<Routine.Yield> InventoryRoutine()
	{
		float sizeSeperation;
		ConstArray<InventoryObject> constArray = PrepareInventoryObjects(out sizeSeperation);
		InventorySettings settings = BaseSettings<InventorySettings>.Inst;
		Vector3 inventorySize = new Vector3(0.2f, sizeSeperation / 2f, 0.2f);
		bool newItemAtStart = newItemCount > 0;
		_ = settings.bagCloseDelay;
		bool canGrabObjects = currentEffectType == InventoryEffectType.OPEN;
		SetInventoryPosition(out var worldPos, out var rotation);
		if (checkDistance)
		{
			openPlayerPositionWS = Vector3X.zero;
		}
		bagXform.position = InventoryCentre.position;
		bagSMR.gameObject.SetActive(value: true);
		bagManAnim.animation.Play(CH_Backpack_Enter);
		bagManAnim.animation.CrossFadeQueued(CH_Backpack_Idle);
		FAC.Inst.PlayOneShot(settings.sfxOpen, InventoryCentre.position);
		SelectedObject handRSObj = new SelectedObject
		{
			hand = CC.Inst.handR,
			index = -1
		};
		SelectedObject handLSObj = new SelectedObject
		{
			hand = CC.Inst.handL,
			index = -1
		};
		bool inventorySettled = false;
		int itemsSettled = 0;
		float unsettledTimer = settings.inventoryForceSettleTime;
		float idleTimer = settings.inventoryCloseAfterIdleTime;
		while (InventoryEnabled.Value)
		{
			inventorySettled = UpdateInventoryPosition(inventorySettled, inventorySize, out worldPos, out rotation);
			if (inventorySettled)
			{
				Vector3 up = Vector3.up;
				float num = 0f;
				float num2 = 360f / (float)constArray.Length;
				bool flag = (bool)handRSObj.selectedObject || (bool)handLSObj.selectedObject;
				bool flag2 = (bool)handRSObj.selectedObject && (bool)handLSObj.selectedObject;
				float num3 = 0f;
				int num4 = Mathf.Abs(handRSObj.index - handLSObj.index);
				if (constArray.Length > 4)
				{
					float num5 = num2 + settings.itemAngleOffset / 2f;
					float num6 = num2 + settings.itemAngleOffset;
					float num7 = 0f;
					if ((bool)handRSObj.selectedObject)
					{
						num7 += num6;
					}
					if ((bool)handLSObj.selectedObject)
					{
						num7 += num6;
					}
					num7 -= ((flag2 && num4 == 1) ? settings.itemAngleOffset : 0f);
					int length = (int)constArray.Length;
					length -= (handRSObj.selectedObject ? 1 : 0);
					length -= (handLSObj.selectedObject ? 1 : 0);
					num3 = (360f - num7) / (float)length;
					int num8 = (handRSObj.selectedObject ? handRSObj.index : handLSObj.index);
					if (flag2)
					{
						num8 = Mathf.FloorToInt((float)(handRSObj.index + handLSObj.index) / 2f);
					}
					float num9 = (float)num8 * num2;
					float num10 = ((flag2 && num4 == 1) ? num2 : num5);
					float num11 = (float)(num8 - 1) * num3 + num10;
					num = num9 - num11;
				}
				itemsSettled = 0;
				for (uint num12 = 0u; num12 < constArray.Length; num12++)
				{
					long num13 = constArray.Length - newItemCount;
					if (newItemCount > constArray.Length)
					{
						UnityEngine.Debug.LogError("More items added than currently in inventory, force closing inventory!!!!!!!");
						newItemCount = 0;
						CloseInventory(stopRoutine: false);
					}
					if (num12 > num13 && newItemAtStart)
					{
						continue;
					}
					InventoryObject inventoryObject = constArray[num12];
					bool flag3 = inventoryObject == handRSObj.selectedObject || inventoryObject == handLSObj.selectedObject;
					bool flag4 = constArray[num12].ValidEGRillIndex == currentEGrillIndex;
					inventoryObject.UpdateVisible(flag4);
					if (num12 == num13 && inventoryObject.ObjectState != InvObjectState.ADDING)
					{
						inventoryObject.ObjectState = InvObjectState.SPAWNING;
					}
					float num14;
					if (constArray.Length > 4 && flag)
					{
						_ = settings.itemAngleOffset / 2f;
						if (flag3)
						{
							num14 = num2 * (float)num12;
						}
						else
						{
							num14 = num + (float)num12 * num3;
							if ((bool)handRSObj.selectedObject && num12 > handRSObj.index)
							{
								num14 += num2;
							}
							if ((bool)handLSObj.selectedObject && num12 > handLSObj.index)
							{
								num14 += num2;
							}
							if (flag2 && (num12 > handRSObj.index || num12 > handLSObj.index))
							{
								num14 -= ((num4 == 1) ? settings.itemAngleOffset : (settings.itemAngleOffset / 2f));
							}
						}
					}
					else
					{
						num14 = 360f / (float)constArray.Length * (float)num12;
					}
					InventorySettings.InventorySpring inventoryItemPosSpring = settings.inventoryItemPosSpring;
					InventorySettings.InventorySpring springSettings = settings.inventoryItemScaleSpring;
					Vector3 vector;
					Vector3 vector2;
					switch (inventoryObject.ObjectState)
					{
					case InvObjectState.SPAWNING:
					{
						vector = CalculateItemPosition(up, sizeSeperation, num14, constArray[num12]);
						inventoryObject.transform.position = vector;
						vector2 = settings.ItemScale;
						bool flag5 = !inventoryObject.playedEffect;
						if ((!newItemAtStart) ? flag5 : (flag5 && num12 == 0))
						{
							Vector3 localPosition = InventoryCentre.InverseTransformPoint(inventoryObject.transform.position);
							Quaternion localRotation = CalculateLocalRotationToIC(vector);
							inventoryObject.activeEffect = PSC.Inst.Play(ParticleType.Inventory_Add, localPosition, localRotation, Vector3X.one, InventoryCentre);
							FAC.Inst.PlayOneShot(settings.sfxAdd, inventoryObject.transform);
							constArray[num12].playedEffect = true;
						}
						else if (inventoryObject.activeEffect?.enabled ?? false)
						{
							inventoryObject.activeEffect.transform.localPosition = InventoryCentre.InverseTransformPoint(inventoryObject.transform.position);
							inventoryObject.activeEffect.transform.localRotation = CalculateLocalRotationToIC(vector);
						}
						else
						{
							ParticlePrefab activeEffect = inventoryObject.activeEffect;
							if ((object)activeEffect != null && !activeEffect.enabled)
							{
								inventoryObject.activeEffect = null;
							}
						}
						break;
					}
					case InvObjectState.ADDING:
						vector = bagXform.position;
						vector2 = Vector3X.zero;
						springSettings = settings.inventoryItemAddSpring;
						break;
					case InvObjectState.TOREMOVE:
						if (Time.time - inventoryObject.RemovalMarkTime > settings.maxRemovalMarkTime)
						{
							inventoryObject.ObjectState = InvObjectState.HIDDEN;
							RemoveFromInventory(inventoryObject.grabObject);
							Routine.Skip();
							continue;
						}
						vector = CalculateItemPosition(up, sizeSeperation, num14, constArray[num12]);
						vector2 = settings.ItemScale;
						break;
					case InvObjectState.REMOVING:
						vector = CalculateItemPosition(up, sizeSeperation, num14, constArray[num12]);
						vector2 = Vector3X.zero;
						if (!inventoryObject.playedEffect)
						{
							Vector3 localPosition2 = InventoryCentre.InverseTransformPoint(inventoryObject.transform.position);
							PSC.Inst.Play(ParticleType.InventoryBurst, localPosition2, Quaternion.identity, Vector3X.one, InventoryCentre);
							FAC.Inst.PlayOneShot(settings.sfxRemove, inventoryObject.transform);
							inventoryObject.playedEffect = true;
						}
						break;
					default:
						vector = CalculateItemPosition(up, sizeSeperation, num14, constArray[num12]);
						vector2 = settings.ItemScale;
						if (flag)
						{
							vector2 = ((!flag3) ? settings.ItemMinScale : settings.ItemSelectedScale);
						}
						break;
					}
					inventoryObject.UpdateScaleSpring(vector2, springSettings);
					inventoryObject.UpdatePositionSpring(vector, inventoryItemPosSpring);
					inventoryObject.transform.localRotation = inventoryObject.InventoryRotation;
					if (Vector3.Distance(constArray[num12].transform.localScale, vector2) < settings.itemScaleSettleDistance)
					{
						switch (inventoryObject.ObjectState)
						{
						case InvObjectState.SPAWNING:
							if (newItemAtStart)
							{
								inventoryObject.ObjectState = InvObjectState.ADDING;
								break;
							}
							inventoryObject.ObjectState = InvObjectState.DEFAULT;
							newItemCount--;
							break;
						case InvObjectState.ADDING:
							newItemCount--;
							inventoryObject.ObjectState = ((newItemAtStart && !canGrabObjects) ? InvObjectState.HIDDEN : InvObjectState.DEFAULT);
							break;
						case InvObjectState.TOREMOVE:
							inventoryObject.ObjectState = InvObjectState.REMOVING;
							inventoryObject.playedEffect = false;
							break;
						case InvObjectState.REMOVING:
							RemoveFromInventory(inventoryObject.grabObject);
							break;
						}
					}
					else
					{
						inventoryObject.ScaleBasedDither();
					}
					if (Vector3.Distance(constArray[num12].transform.position, vector) < settings.itemPositionSettleDistance)
					{
						itemsSettled++;
					}
					if (canGrabObjects && flag4)
					{
						inventoryObject.SetGrabbable(value: true);
					}
					else
					{
						inventoryObject.SetGrabbable(value: false);
					}
				}
				if (itemsSettled == constArray.Length && openPlayerPositionWS == Vector3X.zero)
				{
					openPlayerPositionWS = IC.GetHeadPosition();
				}
			}
			yield return Wait.For.LRRealtimeLateUpdates(1);
			yield return Routine.Yield.SpecialIndex.StopSkipping;
			if (newItemAtStart && newItemCount == 0 && !canGrabObjects)
			{
				break;
			}
			constArray = PrepareInventoryObjects(out sizeSeperation);
			uint length2 = constArray.Length;
			for (int i = 0; i < length2; i++)
			{
				constArray[i].UpdateGameObjects();
			}
			bool flag6 = !handRSObj.selectedObject || !handRSObj.IsIntersectingHand() || !handLSObj.selectedObject || !handLSObj.IsIntersectingHand();
			if (canGrabObjects && constArray.Length != 0 && flag6)
			{
				GetHandIntersection(constArray, out var selectedObject, CC.Inst.handR);
				GetHandIntersection(constArray, out var selectedObject2, CC.Inst.handL);
				if (!selectedObject.invObject)
				{
					FindFocusedObject(ref selectedObject, selectedObject2, constArray, CC.Inst.handR);
				}
				if (!selectedObject2.invObject)
				{
					FindFocusedObject(ref selectedObject2, selectedObject, constArray, CC.Inst.handL);
				}
				handRSObj.UpdateRest(selectedObject, settings.grabRestTime);
				handLSObj.UpdateRest(selectedObject2, settings.grabRestTime);
			}
			CC inst = CC.Inst;
			Vector3 position = InventoryCentre.position;
			float sqrMagnitude = (inst.handR.transform.position - position).sqrMagnitude;
			float sqrMagnitude2 = (inst.handL.transform.position - position).sqrMagnitude;
			bool flag7 = inst.handR.InteractableHighlighted is InventoryObject || inst.handL.InteractableHighlighted is InventoryObject || (!inst.handR.InteractableHeld && sqrMagnitude < settings.HandInInventoryRangeSQR) || (!inst.handL.InteractableHeld && sqrMagnitude2 < settings.HandInInventoryRangeSQR);
			if (!inventorySettled)
			{
				if (!inst.freeMove.HasMoved)
				{
					unsettledTimer -= IC.DeltaTime;
				}
				if (unsettledTimer <= 0f)
				{
					inventorySettled = true;
					worldPos = InventoryCentre.position;
					rotation = InventoryCentre.rotation;
				}
			}
			else
			{
				if (flag7)
				{
					idleTimer = (objectGrabbed ? settings.inventoryCloseAfterGrabTime : settings.inventoryCloseAfterIdleTime);
				}
				else if (newItemCount == 0)
				{
					idleTimer -= IC.DeltaTime;
					unsettledTimer = settings.inventoryForceSettleTime;
				}
				bool flag8 = UIPauseMenu.Inst.currentMenuType == SceneInfo.MenuType.Tutorial;
				if (idleTimer <= 0f && !flag8)
				{
					break;
				}
			}
			if (checkDistance && openPlayerPositionWS != Vector3X.zero)
			{
				float sqrMagnitude3 = (IC.GetHeadPosition() - openPlayerPositionWS).sqrMagnitude;
				float inventoryMaxDistanceSQR = settings.InventoryMaxDistanceSQR;
				inventoryMaxDistanceSQR += ((!inst.freeMove.HasMoved) ? 0.2f : 0f);
				if (sqrMagnitude3 > inventoryMaxDistanceSQR && !flag7)
				{
					break;
				}
			}
			Vector3 worldPosition = bagSMR.bounds.ClosestPoint(MainCamera.Inst.transform.position);
			InteractionSettings inst2 = BaseSettings<InteractionSettings>.Inst;
			float num15 = MainCamera.CalculateHeadDitherStrength(worldPosition, inst2.nearFadeHandDistMin, inst2.nearFadeHandDistMax);
			Plane plane = new Plane(InventoryCentre.forward, InventoryCentre.position);
			GrabObject grabObject = inst.handL.InteractableHeld as GrabObject;
			GrabObject grabObject2 = inst.handR.InteractableHeld as GrabObject;
			float num16 = float.MaxValue;
			if ((bool)grabObject2)
			{
				num16 = GetDistanceToHeldObject(grabObject2, plane, sizeSeperation);
			}
			if ((bool)grabObject)
			{
				float distanceToHeldObject = GetDistanceToHeldObject(grabObject, plane, sizeSeperation);
				num16 = ((distanceToHeldObject < num16) ? distanceToHeldObject : num16);
			}
			if (num16 < float.MaxValue)
			{
				float num17 = Mathf.InverseLerp(inst2.nearFadeObjToInvDistMin, inst2.nearFadeObjToInvDistMax, num16);
				num15 = ((num17 < num15) ? num17 : num15);
			}
			num15 = Mathf.Max(num15, inst2.minimalDitherValue);
			if (itemsSettled == constArray.Length)
			{
				SetInventoryObjectFloatProperty(ShaderPID._DitherAlphaValue, num15, applyNow: true);
			}
			bagMPB.SetFloat(ShaderPID._DitherAlphaValue, num15);
			bagSMR.SetPropertyBlock(bagMPB);
			for (int j = 0; j < storyItemRenderers.Length; j++)
			{
				storyItemRenderers[j].SetPropertyBlock(bagMPB);
			}
		}
		CloseInventory(stopRoutine: false);
	}

	private InventoryPos CalculateInventoryPosition(Vector2 size)
	{
		InventoryPos result = default(InventoryPos);
		InventorySettings inst = BaseSettings<InventorySettings>.Inst;
		Vector3 up = CC.Inst.transform.up;
		Vector3 vector = MainCamera.Inst.transform.position + up * inst.inventoryoffset.y;
		Vector3 rhs = IC.GetHeadRotation() * Vector3X.forward;
		rhs = Vector3.Cross(Vector3.Cross(up, rhs).normalized, up).normalized;
		Quaternion quaternion = Quaternion.LookRotation(rhs, up);
		result.pos = vector + rhs * Mathf.Max(UICast.Cast(vector, quaternion, new Vector2(size.x, size.y), inst.inventoryoffset.z, castAgainstColliders: true, allowPortalTraversal: false).validRayDistance - 0.15f, 0f);
		result.rot = quaternion;
		return result;
	}

	private bool UpdateInventoryPosition(bool isSettled, Vector2 size, out Vector3 worldPos, out Quaternion worldRot)
	{
		InventorySettings inst = BaseSettings<InventorySettings>.Inst;
		InventoryPos inventoryPos = CalculateInventoryPosition(size);
		worldPos = inventoryPos.pos;
		worldRot = inventoryPos.rot;
		if (isSettled)
		{
			Vector3 position = InventoryCentre.transform.position;
			Quaternion rotation = InventoryCentre.transform.rotation;
			Vector3 headPosition = IC.GetHeadPosition();
			Vector3 vector = worldPos - headPosition;
			Vector3 vector2 = position - headPosition;
			Vector3.Angle(vector.normalized, vector2.normalized);
			if (Mathf.Abs(vector2.magnitude - vector.magnitude) < 0.5f)
			{
				worldPos = position;
				worldRot = rotation;
			}
		}
		UpdatePositionSpring(worldPos, inst.inventorySpring);
		InventoryCentre.rotation = Quaternion.Lerp(InventoryCentre.rotation, worldRot, 0.05f);
		bagXform.localPosition = inst.bagPositionOffset;
		if (bagManAnim.animation.IsPlaying(CH_Backpack_Idle))
		{
			return Vector3.Distance(InventoryCentre.position, worldPos) < inst.itemGrabRestDistance;
		}
		return false;
	}

	public void AddStoryItem(InventoryStoryItem storyItem)
	{
		ItemAnimPair itemAnimPair = default(ItemAnimPair);
		itemAnimPair.storyItem = storyItem;
		ItemAnimPair obj = itemAnimPair;
		switch (storyItem)
		{
		default:
			return;
		case InventoryStoryItem.JOURNAL:
			obj.animName = "CH_Backpack_Idle_Enter_Book";
			obj.sfx = BaseSettings<InventorySettings>.Inst.sfxJournalEnter;
			break;
		case InventoryStoryItem.ID_CARD:
			obj.animName = "CH_Backpack_Idle_Enter_ID";
			obj.sfx = BaseSettings<InventorySettings>.Inst.sfxIDEnter;
			break;
		case InventoryStoryItem.NOTICE:
			obj.animName = "CH_Backpack_Idle_Enter_Letter";
			obj.sfx = BaseSettings<InventorySettings>.Inst.sfxLetterEnter;
			break;
		}
		LR.Inst.saveDataGame.activeInventoryStoryItems.Add(storyItem);
		itemAnimPairs.Enqueue(obj);
		if (!inventoryCutsceneRoutine.started)
		{
			inventoryCutsceneRoutine.Start();
		}
	}

	public void RemoveStoryItem(InventoryStoryItem storyItem, float animDelay)
	{
		ItemAnimPair itemAnimPair = default(ItemAnimPair);
		itemAnimPair.storyItem = storyItem;
		itemAnimPair.animDelay = animDelay;
		ItemAnimPair obj = itemAnimPair;
		switch (storyItem)
		{
		default:
			return;
		case InventoryStoryItem.ID_CARD:
			obj.animName = "CH_Backpack_Idle_Exit_ID";
			obj.sfx = BaseSettings<InventorySettings>.Inst.sfxIDExit;
			break;
		case InventoryStoryItem.NOTICE:
			obj.animName = "CH_Backpack_Idle_Exit_Letter";
			obj.sfx = BaseSettings<InventorySettings>.Inst.sfxLetterExit;
			break;
		case InventoryStoryItem.JOURNAL:
			break;
		}
		LR.Inst.saveDataGame.activeInventoryStoryItems.Remove(storyItem);
		itemAnimPairs.Enqueue(obj);
		if (!inventoryCutsceneRoutine.started)
		{
			inventoryCutsceneRoutine.Start();
		}
	}

	public void ShowAllStoryItems()
	{
		foreach (KeyValuePair<InventoryStoryItem, GameObject> storyItemGameObject in storyItemGameObjects)
		{
			storyItemGameObject.Value.SetActive(value: true);
		}
	}

	[ContextMenu("Remove Story Items")]
	public void RemoveStoryItemsNoAnim()
	{
		foreach (KeyValuePair<InventoryStoryItem, GameObject> storyItemGameObject in storyItemGameObjects)
		{
			storyItemGameObject.Value.SetActive(value: false);
		}
	}

	private IEnumerator<Routine.Yield> InventoryCutsceneRoutine()
	{
		InventorySettings settings = BaseSettings<InventorySettings>.Inst;
		Vector3 size = new Vector3(0.2f, Settings.inventoryMinSeperation / 2f, 0.2f);
		SetInventoryPosition(out var worldPos, out var rotation);
		bool settled = false;
		bagXform.position = InventoryCentre.position;
		bagSMR.gameObject.SetActive(value: true);
		bagManAnim.animation.Play(CH_Backpack_Enter);
		FAC.Inst.PlayOneShot(settings.sfxOpen, InventoryCentre.position);
		while (bagManAnim.animation.isPlaying)
		{
			settled = UpdateInventoryPosition(settled, size, out worldPos, out rotation);
			yield return Wait.For.LRUpdates(1);
		}
		bagManAnim.animation.CrossFadeQueued(CH_Backpack_Idle);
		do
		{
			ItemAnimPair pair = itemAnimPairs.Dequeue(clearToDefault: true);
			GameObject item = storyItemGameObjects[pair.storyItem];
			yield return Wait.For.Seconds(pair.animDelay);
			item.SetActive(value: true);
			PSC.Inst.Play(ParticleType.StoryItemSparkle, item.transform);
			bagManAnim.animation.Play(pair.animName);
			FAC.Inst.PlayOneShot(pair.sfx, InventoryCentre.position);
			while (bagManAnim.animation.isPlaying)
			{
				settled = UpdateInventoryPosition(settled, size, out worldPos, out rotation);
				yield return Wait.For.LRUpdates(1);
			}
			if (pair.animName.Contains("Exit"))
			{
				storyItemGameObjects[pair.storyItem].SetActive(value: false);
			}
		}
		while (itemAnimPairs.Length > 0);
		FAC.Inst.PlayOneShot(settings.sfxClose, InventoryCentre.position);
		yield return bagManAnim.PlayAnimManual(LR.Inst.onRealTimeUpdate, call: true, CH_Backpack_Exit);
		bagSMR.gameObject.SetActive(value: false);
	}

	private float GetDistanceToHeldObject(GrabObject grabObject, Plane plane, float ringRadius)
	{
		Vector3 closestPointOnObject = grabObject.GetClosestPointOnObject(InventoryCentre.position);
		Vector3 vector = plane.ClosestPointOnPlane(closestPointOnObject);
		Vector3 vector2 = InventoryCentre.InverseTransformPoint(vector);
		if (!(Mathf.Abs(vector2.x) < ringRadius) || !(Mathf.Abs(vector2.y) < ringRadius))
		{
			return float.MaxValue;
		}
		return (vector - closestPointOnObject).magnitude;
	}

	public ConstArray<InventoryObject> PrepareInventoryObjects(out float sizeSeperation)
	{
		ConstArray<GrabObject> grabObjects = inventoryState.grabObjects;
		for (uint num = 0u; num < lastInventoryObjects.Length; num++)
		{
			InventoryObject inventoryObject = lastInventoryObjects[num];
			if (!grabObjects.Contains(inventoryObject.grabObject) && inventoryObject.grabObject != null)
			{
				inventoryObject.SetVisible(_visible: false);
			}
		}
		lastInventoryObjects.Clear();
		validInventoryObjects.Clear();
		float num2 = 0f;
		float num3 = 0f;
		for (int i = 0; i < grabObjects.sLength; i++)
		{
			InventoryObject inventoryObject2 = grabObjects[i].inventoryObject;
			if (inventoryObject2.IsValid())
			{
				Vector3 extents = inventoryObject2.Extents;
				float num4 = Mathf.Max(extents.x, extents.y, extents.z);
				if (num4 > num2)
				{
					num3 = num2;
					num2 = num4;
				}
				else if (num4 > num3)
				{
					num3 = num4;
				}
				validInventoryObjects.Add(inventoryObject2);
			}
			else
			{
				inventoryObject2.SetVisible(_visible: false);
			}
			lastInventoryObjects.Add(inventoryObject2);
		}
		sizeSeperation = num2 + num3;
		sizeSeperation = Mathf.Max(Settings.inventoryMinSeperation, sizeSeperation);
		return validInventoryObjects;
	}

	private Vector3 CalculateItemPosition(Vector3 intialDir, float separationDistance, float angle, InventoryObject invObject)
	{
		Vector3 vector = intialDir * separationDistance;
		vector = Quaternion.AngleAxis(angle, Vector3.forward) * vector;
		return InventoryCentre.TransformPoint(vector) + invObject.CentreOffset;
	}

	private Quaternion CalculateLocalRotationToIC(Vector3 worldPosition)
	{
		Vector3 normalized = (worldPosition - InventoryCentre.position).normalized;
		Quaternion worldRotation = Quaternion.LookRotation(InventoryCentre.forward, normalized);
		return InventoryCentre.InverseTransformRotation(worldRotation);
	}

	private void UpdatePositionSpring(Vector3 target, InventorySettings.InventorySpring springSettings)
	{
		float num = Mathf.Min(IC.DeltaTime, 1f / 60f);
		posSpringVelocity = CalculateSpring(target, InventoryCentre.position, posSpringVelocity, springSettings);
		InventoryCentre.position += posSpringVelocity * num;
	}

	private void UpdateScaleSpring(Vector3 target, InventorySettings.InventorySpring springSettings)
	{
		float num = Mathf.Min(IC.RealDeltaTime, 1f / 60f);
		scaleSpringVelocity = CalculateSpring(target, InventoryCentre.localScale, scaleSpringVelocity, springSettings);
		InventoryCentre.localScale += scaleSpringVelocity * num;
	}

	public static Vector3 CalculateSpring(Vector3 target, Vector3 current, Vector3 velocity, InventorySettings.InventorySpring springSettings)
	{
		float num = Mathf.Min(IC.RealDeltaTime, 1f / 60f);
		Vector3 vector = target - current;
		Vector3 vector2 = velocity;
		float strength = springSettings.strength;
		float dampening = springSettings.dampening;
		Vector3 vector3 = strength * vector - dampening * vector2;
		velocity += vector3 * num;
		return velocity;
	}

	private void GetHandIntersection(ConstArray<InventoryObject> objects, out SelectedObject selectedObject, Hand targetHand)
	{
		selectedObject = default(SelectedObject);
		float num = float.MaxValue;
		for (int i = 0; i < objects.Length; i++)
		{
			float num2 = float.MaxValue;
			InventoryObject inventoryObject = objects[i];
			if (!targetHand.InteractableHeld && inventoryObject.IsIntersectingHand(targetHand))
			{
				num2 = Vector3.Distance(targetHand.GetHandPlamTransformLocalToHead().position, inventoryObject.transform.position);
			}
			if (num2 < num)
			{
				selectedObject.index = i;
				selectedObject.invObject = objects[i];
				selectedObject.hand = targetHand;
				num = num2;
			}
		}
	}

	private void FindFocusedObject(ref SelectedObject selectedObject, SelectedObject otherObject, ConstArray<InventoryObject> objects, Hand hand)
	{
		InventoryObject inventoryObject = hand.InteractableHighlighted as InventoryObject;
		if ((bool)inventoryObject && inventoryObject != otherObject.invObject)
		{
			selectedObject.invObject = inventoryObject;
			selectedObject.hand = CC.Inst.handR;
			selectedObject.index = objects.IndexOf(inventoryObject);
		}
	}

	public void SetInventoryObjectFloatProperty(int id, float value, bool applyNow = false)
	{
		for (int i = 0; i < validInventoryObjects.Length; i++)
		{
			validInventoryObjects[i].SetMPBFloat(id, value, applyNow);
		}
	}
}
public class PlayerSpawnPoint : MonoBehaviour
{
}
public interface ICanEnterPortal
{
	void OnEnterPortal(Portal portal);
}
public interface IPortalEnteredEvent
{
	void OnAwakeLR(Portal portal);

	void OnPortalEntered(ICanPortal obj);
}
public interface ICanPortal
{
	bool CanEnterPortal(Portal portal);

	void OnEnterPortal(Portal portal);

	TransformState GetLastState();

	Vector3 GetWorldPosition();

	MRBase GetOwner();

	void SetOwner(MRBase owner);

	bool CanTeleport(Portal portal);
}
public enum PortalType
{
	WithinWorlds,
	BetweenWorlds,
	Mirror,
	FakeMirror,
	PassThroughMirror,
	Eyeglass,
	Stealth
}
public enum PortalAnimation
{
	OPEN,
	CLOSE
}
public enum PortalState
{
	OPEN,
	CLOSED,
	LOCKED
}
public enum PortalCameraMode
{
	Automatic,
	ManualOn,
	ManualOff
}
[Serializer.ExcludeAllFields]
public class Portal : IDObject, Region.IConnectionOwner, Region.IConnectionKey, IPauseEvent, IPauseUpdate, IPrebuildEvent, HAGIS_Generic_MultiLightSensorController.ICanToggle, IPrepareEvent
{
	public struct Edge
	{
		public int i0;

		public int i1;
	}

	private struct PortalShape
	{
		public Edge[] edges;

		public Vector3[] vertices;

		public Mesh faceMesh;

		public Mesh volumeMesh;

		public Bounds faceBounds;
	}

	public struct PortalTransform
	{
		public Vector3 position;

		public Quaternion rotation;

		public Vector3 direction;
	}

	public enum PortalSFXEvent
	{
		OPENED = 1,
		CLOSED = 2,
		LOCKED = 4,
		UNLOCKED = 8,
		TRANSITION = 0x10,
		OPEN_IDLE = 0x20,
		CLOSED_IDLE = 0x40
	}

	public static Vector2 REQUIRED_SCALE = new Vector2(1.5f, 2.5f);

	private static float EYE_NEARBY_THRESHOLD = 0.01275f;

	private const string PORTAL_SURFACE = "PORTAL_SURFACE";

	private const string PORTAL_VOLUME = "PORTAL_VOLUME";

	private static readonly int _PortalVolumeEye = Shader.PropertyToID("_PortalVolumeEye");

	private static readonly int _PORTAL_ID = Shader.PropertyToID("_PORTAL_ID");

	private static readonly int _GlowColorRGB_Step = Shader.PropertyToID("_GlowColorRGB_Step");

	private static readonly int _StepMinMax_IsLocked_AlphaClip = Shader.PropertyToID("_StepMinMax_IsLocked_AlphaClip");

	private Vector4 _StepMinMax_IsLocked_AlphaClip_Values;

	private Vector4 _GlowColorRGB_Step_Values;

	private static readonly int _Distance = Shader.PropertyToID("_Distance");

	private static readonly int _RefTex = Shader.PropertyToID("_RefTex");

	private static readonly int _Multiplier = Shader.PropertyToID("_Multiplier");

	public PortalType type;

	[Serializer.IncludeField]
	public IDObjectRef linkRef;

	[HideInInspector]
	private string storedLinkRefID;

	[HideInInspector]
	private string storedSceneUID;

	[NonSerialized]
	[HideInInspector]
	public Portal Link;

	[Tooltip("Should only be false for special cases such as holdable portals or the portal in the well")]
	public bool changesGravity = true;

	public bool objectTeleportOnEnter = true;

	public bool dontCloseOnLinkDestroyed;

	[FormerlySerializedAs("teleportOnEnter")]
	[ConditionalHide("objectTeleportOnEnter")]
	[SerializeField]
	private bool playerHeadTeleportOnEnter;

	[ConditionalHide("playerHeadTeleportOnEnter")]
	public bool twoSided;

	private IPortalEnteredEvent[] portalEvents;

	public HagletTrigger playerEnteredPortal;

	public HagletTrigger objectEnteredPortal;

	public bool flipX;

	public bool flipY;

	public bool flipZ;

	public bool isHubPortal;

	[NonSerialized]
	public Quaternion mirrorOrientationOffset = Quaternion.identity;

	[FormerlySerializedAs("isPortable")]
	[SerializeField]
	private bool isMoveable;

	[Tooltip("Standard colors available: In the color picker, click the button next to 'Swatches' and select PortalVFXColors")]
	public Color VFXColor = Color.white;

	[SerializeField]
	private Color BorderColor = Color.gray;

	public Collider[] portalColliders;

	[NonSerialized]
	[HideInInspector]
	public bool IsHoldable;

	private GrabObject parentGrabObject;

	private PortalingRigidbody PortalingRB;

	public Mesh portalMesh;

	[NonSerialized]
	public PortalVariations.VariantSet portalVariantSet;

	[SerializeField]
	private Material overrideSurfaceMaterial;

	[FormerlySerializedAs("shouldOverrideSettings")]
	public bool overrideSettingsByDefault;

	[SerializeField]
	private PortalSettings.PortalTypeSettings overrideSettings;

	[SerializeField]
	[HideInInspector]
	private Material portalMaterial;

	[SerializeField]
	[HideInInspector]
	private Material portalVolumeMaterial;

	[SerializeField]
	[HideInInspector]
	private Material defaultSurfaceMaterial;

	[SerializeField]
	[HideInInspector]
	private Material defaultSurfaceMaterialInst;

	[SerializeField]
	[HideInInspector]
	private Material unlockSurfaceMaterialInst;

	private Material currentSurfaceMaterial;

	private Material currentSurfaceMaterialInst;

	private MaterialPropertyBlock portalMPB;

	private MaterialPropertyBlock portalVolumeMPB;

	private MeshRenderer portalRenderer;

	private MeshCollider portalCollider;

	[SerializeField]
	private Renderer portalBurnmark;

	[SerializeField]
	[HideInInspector]
	private PortalCamera _PortalCamera;

	private PortalShape portalShape;

	private bool isUnlocked = true;

	[Tooltip("When enabled, portals will always open when in range, regardless of player gravity. Use sparingly!")]
	public bool ignorePlayerGravity;

	private bool inRange;

	[SerializeField]
	[Tooltip("Does this portal have a idle animation (everything but plain mirrors)")]
	private bool canAnimate;

	[SerializeField]
	[ConditionalHide("canAnimate")]
	private bool canClose;

	[SerializeField]
	[ConditionalHide("canAnimate")]
	[Tooltip("0: Standard Portals, idle and close\n1: Moroccan Door Portals, idle only\n2: Circle Portals, idle only\n3: Round Arch Portals, idle only\n4: Real-Fantasy Portals")]
	private int animationVariationSet;

	private TransformState lastState;

	private FMOD.Studio.EventInstance sfxFeedback2D;

	private FMOD.Studio.EventInstance sfxFeedback3DOpenClose;

	private FMOD.Studio.EventInstance sfxFeedback3DIdle;

	public bool mirrorsPlayerRenderers;

	[NonSerialized]
	[HideInInspector]
	public Matrix4x4 cachedPortalMatrix = Matrix4x4.identity;

	[NonSerialized]
	[HideInInspector]
	public Matrix4x4 cachedPortalMatrixInv = Matrix4x4.identity;

	[NonSerialized]
	[HideInInspector]
	public Vector4 cachedClipPlaneV = Vector4X.zero;

	[NonSerialized]
	[HideInInspector]
	public Vector4 cachedLinkClipPlaneV = Vector4X.zero;

	private TransformData cachedXFormData;

	private bool cachedUpdateEyeMask;

	private float cachedHeadZ;

	public readonly ConstArray<PortalRenderer> intersectingRenderers = new ConstArray<PortalRenderer>(32u);

	private PortalState state;

	private bool lockedOrClosedBeforePause;

	[HideInInspector]
	[SerializeField]
	private bool hasStandardPortalVFX;

	[HideInInspector]
	[SerializeField]
	private GameObject particleGodrays;

	[HideInInspector]
	[SerializeField]
	private GameObject particleDots;

	[HideInInspector]
	[SerializeField]
	private GameObject particleTrails;

	[HideInInspector]
	[SerializeField]
	private GameObject particleBurst;

	[HideInInspector]
	[SerializeField]
	private GameObject particleFlakes;

	[HideInInspector]
	public PortalCameraMode cameraMode;

	public List<Vector4> positionsArray = new List<Vector4>(4);

	private FMOD.Studio.EventInstance transferMirrorSound;

	private float portalParticleAlpha = 1f;

	[SerializeField]
	[HideInInspector]
	private ParticleSystemRenderer[] psRenderersToAlpha;

	private MaterialPropertyBlock psMPB;

	private MaterialPropertyBlock burnMPB;

	private StereoTargetEyeMask _IntersectingEyes;

	private StereoTargetEyeMask _NearbyEyes;

	private Vector3 cachedLossyScale = Vector3X.one;

	[HideInInspector]
	public PortalSettings.PortalTypeSettings typeSettings;

	[ReadOnly]
	public Region currentRegion;

	[Tooltip("The region the player enters the poral through, do not assign of this region should always be on")]
	public Region portalRegion;

	private bool portalRegionIsEnabled = true;

	public bool overrideGravity;

	[ConditionalHide("overrideGravity")]
	public Vector3 gravityOverride = Vector3.down;

	public float curveVal = 0.5f;

	private FMODEventAsset[] sfxEventRefs;

	[EnumFlagsField]
	public PortalSFXEvent sfxEvents = (PortalSFXEvent)(-1);

	public PortalSettings.PortalSFX overrideSfx;

	public bool HACK_overrideMinFrostDistance;

	[ConditionalHide("HACK_overrideMinFrostDistance")]
	public float overrideMinFrostDistance = 2f;

	public bool canOccludeThroughPortal;

	public Event OnPlayerEnterPortal = new Event();

	private SFXLoop portalLoop;

	[NonSerialized]
	[HideInInspector]
	public float openAmount;

	private CullingGroup cullingGroup;

	private BoundingSphere[] cullingSpheres;

	private int[] cullingQuery;

	private Vector3[] cullingSpherePositions;

	private bool renderingEnabled;

	private float mirrorDistance;

	[HideInInspector]
	[SerializeField]
	public Texture2D mirrorDistanceTexture;

	[HideInInspector]
	public bool IsAwake;

	public static Quaternion rotate180Y = Quaternion.Euler(0f, 180f, 0f);

	public IHaglet<SceneInfo> switchTargetPortalLink;

	public IHaglet closeAndRestoreLink;

	private IHaglet<float> portalUnlockAnimation;

	private IHaglet<PortalAnimation, bool> animatePortalRoutine;

	private IHaglet shatterMirrorRoutine;

	public bool PlayerHeadTeleportOnEnter => playerHeadTeleportOnEnter;

	public Vector3 GravityDirection
	{
		get
		{
			if (overrideGravity)
			{
				return gravityOverride;
			}
			if (!Link)
			{
				return -base.transform.up;
			}
			return -Link.transform.up;
		}
	}

	public bool IsMoveable => isMoveable;

	public PortalCamera PortalCamera => _PortalCamera;

	public bool IsUnlocked => isUnlocked;

	public bool CanClose => canClose;

	public StereoTargetEyeMask IntersectingEyes => _IntersectingEyes;

	public StereoTargetEyeMask NearbyEyes => _NearbyEyes;

	public bool IsMirror
	{
		get
		{
			if (!string.IsNullOrEmpty(linkRef.id))
			{
				return linkRef.id == id;
			}
			return true;
		}
	}

	public bool IsVisable { get; private set; }

	public void SetPlayerTeleporting(bool allow)
	{
		playerHeadTeleportOnEnter = allow;
		objectTeleportOnEnter = allow;
	}

	public TransformState GetLastState()
	{
		return lastState;
	}

	void IPrebuildEvent.OnPrebuildRoot(bool isPrefab)
	{
	}

	[ContextMenu("Set Override Settings to Default")]
	private void CopyOverrideSettings()
	{
	}

	public void CreateParticlesAndCamera()
	{
		hasStandardPortalVFX = false;
		typeSettings = (overrideSettingsByDefault ? overrideSettings : BaseSettings<PortalSettings>.Inst.GetSettings(type));
		GameObject gameObject = new GameObject(base.name + "(Camera)");
		gameObject.transform.SetParent(base.transform.parent, worldPositionStays: false);
		_PortalCamera = gameObject.AddComponent<PortalCamera>();
		_PortalCamera.OnPreBuild();
		base.gameObject.AddComponent<MeshFilter>();
		base.gameObject.AddComponent<MeshCollider>();
		base.gameObject.AddComponent<MeshRenderer>();
		if (type == PortalType.WithinWorlds)
		{
			PortalSettings.PortalTypeSettings portalTypeSettings = (overrideSettingsByDefault ? overrideSettings : BaseSettings<PortalSettings>.Inst.GetSettings(type));
			if (portalTypeSettings.particleGodRays != null && portalTypeSettings.particleDots != null && portalTypeSettings.particleTrails != null)
			{
				hasStandardPortalVFX = true;
				particleGodrays = UnityEngine.Object.Instantiate(portalTypeSettings.particleGodRays, base.transform);
				particleDots = UnityEngine.Object.Instantiate(portalTypeSettings.particleDots, base.transform);
				particleTrails = UnityEngine.Object.Instantiate(portalTypeSettings.particleTrails, base.transform);
				ParticleSystem component = particleGodrays.GetComponent<ParticleSystem>();
				ParticleSystem.MainModule main = component.main;
				main.startColor = VFXColor;
				ParticleSystem[] componentsInChildren = particleTrails.GetComponentsInChildren<ParticleSystem>();
				foreach (ParticleSystem obj in componentsInChildren)
				{
					ParticleSystem.MainModule main2 = component.main;
					main2.startColor = VFXColor;
					ParticleSystem.TrailModule trails = obj.trails;
					ParticleSystem.MinMaxGradient colorOverLifetime = trails.colorOverLifetime;
					if (colorOverLifetime.gradient != null)
					{
						GradientColorKey[] colorKeys = colorOverLifetime.gradient.colorKeys;
						for (int j = 0; j < colorKeys.Length; j++)
						{
							GradientColorKey gradientColorKey = colorKeys[j];
							gradientColorKey.color = VFXColor;
							colorKeys[j] = gradientColorKey;
						}
						colorOverLifetime.gradient.colorKeys = colorKeys;
						colorOverLifetime.colorMin = VFXColor;
						trails.colorOverLifetime = colorOverLifetime;
					}
				}
			}
		}
		if (type == PortalType.BetweenWorlds)
		{
			particleBurst = UnityEngine.Object.Instantiate(BaseSettings<PortalSettings>.Inst.HubUnlockSettings.particleTrails, base.transform);
			particleFlakes = UnityEngine.Object.Instantiate(BaseSettings<PortalSettings>.Inst.HubUnlockSettings.particleDots, base.transform);
			particleBurst.SetActive(value: false);
			particleFlakes.SetActive(value: false);
			particleFlakes.transform.localPosition = Vector3.zero;
			particleFlakes.transform.localRotation = Quaternion.identity;
			particleBurst.transform.localPosition = Vector3.zero;
			particleBurst.transform.localRotation = Quaternion.identity;
		}
		List<ParticleSystemRenderer> list = new List<ParticleSystemRenderer>();
		if ((bool)particleGodrays)
		{
			list.AddRange(particleGodrays.GetComponentsInChildren<ParticleSystemRenderer>());
		}
		if ((bool)particleDots)
		{
			list.AddRange(particleDots.GetComponentsInChildren<ParticleSystemRenderer>());
		}
		if ((bool)particleTrails)
		{
			list.AddRange(particleTrails.GetComponentsInChildren<ParticleSystemRenderer>());
		}
		psRenderersToAlpha = list.ToArray();
		Material material = (overrideSurfaceMaterial ? overrideSurfaceMaterial : typeSettings.defaultSurfaceMaterial);
		defaultSurfaceMaterial = material;
		defaultSurfaceMaterialInst = new Material(defaultSurfaceMaterial);
		unlockSurfaceMaterialInst = new Material(BaseSettings<PortalSettings>.Inst.HubUnlockSettings.defaultSurfaceMaterial);
		portalMaterial = new Material(typeSettings.basePortalMaterial);
		portalMaterial.EnableKeyword("PORTAL_SURFACE");
		portalMaterial.SetInt(ShaderPID._ZTEST, 4);
		portalVolumeMaterial = new Material(typeSettings.basePortalMaterial);
		portalVolumeMaterial.EnableKeyword("PORTAL_VOLUME");
		portalVolumeMaterial.SetInt(ShaderPID._ZTEST, 8);
	}

	public void OnAwakeLR(MRBase owner, int portalUID)
	{
		OnAwakeLR(owner);
		if ((bool)portalBurnmark)
		{
			burnMPB = new MaterialPropertyBlock();
		}
		portalVariantSet = ((type == PortalType.Mirror || type == PortalType.PassThroughMirror || type == PortalType.FakeMirror) ? PortalVariations.VariantSet.Mirror : PortalVariations.VariantSet.Main);
		cachedXFormData = new TransformData(base.transform);
		PortalSettings.PortalSFX sfx = typeSettings.sfx;
		if (!_PortalCamera)
		{
			CreateParticlesAndCamera();
		}
		sfxEventRefs = new FMODEventAsset[7]
		{
			(overrideSfx.openExplosionSFX?.Value != null) ? overrideSfx.openExplosionSFX.Value : sfx.openExplosionSFX?.Value,
			(overrideSfx.closedExplosionSFX?.Value != null) ? overrideSfx.closedExplosionSFX.Value : sfx.closedExplosionSFX?.Value,
			(overrideSfx.lockSFX?.Value != null) ? overrideSfx.lockSFX.Value : sfx.lockSFX?.Value,
			(overrideSfx.unlockSFX?.Value != null) ? overrideSfx.unlockSFX.Value : sfx.unlockSFX?.Value,
			(overrideSfx.crossingPortalSFX?.Value != null) ? overrideSfx.crossingPortalSFX.Value : sfx.crossingPortalSFX?.Value,
			(overrideSfx.openIdleSFX?.Value != null) ? overrideSfx.openIdleSFX.Value : sfx.openIdleSFX?.Value,
			(overrideSfx.closedIdleSFX?.Value != null) ? overrideSfx.closedIdleSFX.Value : sfx.closedIdleSFX?.Value
		};
		UpdateRegion();
		IsHoldable = (parentGrabObject = GetComponentInParent<GrabObject>());
		parentGrabObject = (parentGrabObject ? parentGrabObject : null);
		PortalingRB = GetComponentInParent<PortalingRigidbody>();
		portalMPB = new MaterialPropertyBlock();
		portalVolumeMPB = new MaterialPropertyBlock();
		psMPB = new MaterialPropertyBlock();
		_PortalCamera.transform.SetParent(base.transform.parent, worldPositionStays: false);
		_PortalCamera.OnAwakeLR(this, portalUID);
		mirrorDistance = (_PortalCamera.enabled ? 0f : 1f);
		portalVolumeMaterial.SetInt(_PORTAL_ID, _PortalCamera.PUID);
		currentSurfaceMaterial = defaultSurfaceMaterial;
		currentSurfaceMaterialInst = defaultSurfaceMaterialInst;
		portalRenderer = base.gameObject.GetComponent<MeshRenderer>();
		portalRenderer.sharedMaterial = portalMaterial;
		MeshFilter component = GetComponent<MeshFilter>();
		portalShape.faceMesh = GeneratePortalFaceMesh(portalMesh);
		portalShape.edges = GetExternalEdges(portalShape.faceMesh);
		portalShape.vertices = portalShape.faceMesh.vertices;
		portalShape.volumeMesh = GeneratePortalVolumeMesh(portalMesh, portalShape.edges);
		portalShape.faceBounds = portalShape.faceMesh.bounds;
		component.sharedMesh = portalShape.faceMesh;
		portalCollider = base.gameObject.GetComponent<MeshCollider>();
		portalCollider.sharedMesh = portalShape.faceMesh;
		portalCollider.convex = GetComponentInParent<Rigidbody>() != null;
		cullingGroup = new CullingGroup();
		float num = 0.4f;
		float num2 = num * 0.5f;
		float num3 = num2 * num2;
		float num4 = 0.70710677f * num;
		Vector3 vector = base.transform.TransformPoint(portalShape.faceBounds.min);
		Vector3 vector2 = base.transform.TransformPoint(portalShape.faceBounds.max);
		base.transform.rotation.GetAxes(out var right, out var up, out var _);
		Vector3 rhs = vector2 - vector;
		float num5 = Mathf.Abs(Vector3.Dot(right, rhs));
		float num6 = Mathf.Abs(Vector3.Dot(up, rhs));
		List<BoundingSphere> list = new List<BoundingSphere>();
		BoundingSphere item = default(BoundingSphere);
		item.radius = num2;
		for (float num7 = 0f - num4; num7 <= num5 + num4; num7 += num4)
		{
			Vector3 vector3 = vector + right * num7;
			for (float num8 = 0f - num4; num8 <= num6 + num4; num8 += num4)
			{
				Vector3 vector4 = vector3 + up * num8;
				if ((GetClosestPointOnPortal(vector4) - vector4).sqrMagnitude < num3)
				{
					item.position = vector4;
					list.Add(item);
				}
			}
		}
		cullingSpheres = list.ToArray();
		cullingSpherePositions = new Vector3[cullingSpheres.Length];
		cullingQuery = new int[cullingSpheres.Length];
		cullingGroup.SetBoundingSpheres(cullingSpheres);
		cullingGroup.SetBoundingSphereCount(cullingSpheres.Length);
		cullingGroup.targetCamera = MainCamera.Inst.cameraComp;
		Matrix4x4 worldToLocalMatrix = base.transform.worldToLocalMatrix;
		for (int i = 0; i < cullingSpheres.Length; i++)
		{
			cullingSpherePositions[i] = worldToLocalMatrix.MultiplyPoint3x4(cullingSpheres[i].position);
		}
		Haglet.Create(out animatePortalRoutine, (Routine.Func2<PortalAnimation, bool>)AnimatePortalRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out shatterMirrorRoutine, ShatterMirrorRoutine);
		Haglet.Create(out portalUnlockAnimation, (Routine.Func1<float>)PortalUnlockAnimationRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out switchTargetPortalLink, (Routine.Func1<SceneInfo>)SwitchTargetPortalLinkRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out closeAndRestoreLink, CloseAndRestoreLinkRoutine);
		playerEnteredPortal = new HagletTrigger();
		objectEnteredPortal = new HagletTrigger();
		bool unlocked = !Link || Link.IsUnlocked;
		SetUnlockedState(unlocked);
		if (IsUnlocked && CanClose)
		{
			ClosePortal();
		}
		else
		{
			OpenPortal();
		}
		lastState = new TransformState(base.transform);
		portalEvents = GetComponentsInChildren<IPortalEnteredEvent>();
		for (int j = 0; j < portalEvents.Length; j++)
		{
			portalEvents[j].OnAwakeLR(this);
		}
		portalLoop = GetComponentInChildren<SFXLoop>();
		ReturnPortalStub component2 = GetComponent<ReturnPortalStub>();
		if (component2 != null && component2.singleUse)
		{
			SetUnlockedState(unlocked: false);
			SetHidden(hidden: true);
			base.gameObject.SetActive(value: false);
		}
		SetPortalRenderingEnabled(renderingEnabled: false);
		_StepMinMax_IsLocked_AlphaClip_Values = currentSurfaceMaterial.GetVector(_StepMinMax_IsLocked_AlphaClip);
		_GlowColorRGB_Step_Values = currentSurfaceMaterial.GetVector(_GlowColorRGB_Step);
		UpdateShaderProperties();
		cachedLossyScale = base.transform.lossyScale;
		IsAwake = true;
	}

	Wait IPrepareEvent.PrepareEvents()
	{
		OnPlayerEnterPortal.PrepareInvoke();
		return Wait.None;
	}

	bool Region.IConnectionOwner.IsConnectionValid(Region.IConnectionKey key, bool teleporting)
	{
		return key == this;
	}

	public void AddPortalVolume(CommandBuffer cb, Camera.StereoscopicEye eye, int pass)
	{
		portalVolumeMPB.SetInt(_PortalVolumeEye, (int)eye);
		cb.DrawMesh(portalShape.volumeMesh, base.transform.localToWorldMatrix, portalVolumeMaterial, 0, pass, portalVolumeMPB);
	}

	public void AddPortalSurface(CommandBuffer cb)
	{
		if (currentSurfaceMaterialInst != null)
		{
			cb.DrawMesh(portalShape.faceMesh, cachedPortalMatrix * base.transform.localToWorldMatrix, currentSurfaceMaterialInst, 0, -1, portalMPB);
		}
	}

	public void AddPortalOffSurface(CommandBuffer cb)
	{
		if (currentSurfaceMaterialInst != null && mirrorDistance == 1f)
		{
			cb.DrawMesh(portalShape.faceMesh, base.transform.localToWorldMatrix, currentSurfaceMaterialInst, 0, -1, portalMPB);
		}
	}

	public bool AllowTeleport()
	{
		if (!base.isActiveAndEnabled)
		{
			return false;
		}
		if (!owner.isAwake)
		{
			return false;
		}
		if ((!(Link?.owner?.isAwake)) ?? true)
		{
			return false;
		}
		return true;
	}

	public void SetHidden(bool hidden)
	{
		portalRenderer.enabled = !hidden;
		portalCollider.enabled = !hidden;
	}

	public void UpdateParticlesEnabled()
	{
		if (hasStandardPortalVFX)
		{
			particleDots?.SetActive(state == PortalState.CLOSED);
			particleTrails?.SetActive(state == PortalState.OPEN);
			particleGodrays?.SetActive(state == PortalState.OPEN);
		}
	}

	public void SetUnlockedState(bool unlocked, bool applyToLink = true, bool firstUnlock = false)
	{
		if (IsUnlocked != unlocked)
		{
			isUnlocked = unlocked;
			if (applyToLink && (bool)Link && Link != this && Link.IsUnlocked != IsUnlocked && Link.type != PortalType.Stealth)
			{
				Link.SetUnlockedState(unlocked, applyToLink);
			}
			if (!unlocked && state == PortalState.OPEN)
			{
				ClosePortal();
			}
			if (unlocked && state == PortalState.LOCKED)
			{
				OpenPortal(firstUnlock);
			}
			if (!unlocked && state == PortalState.CLOSED)
			{
				state = PortalState.LOCKED;
			}
			bool flag = false;
			Portal link = Link;
			if (link != null && link != this)
			{
				Vector3 headPosition = IC.GetHeadPosition();
				bool flag2 = ((double)Vector3.SqrMagnitude(CC.Inst.transform.up - link.transform.up) < 0.0001 || ignorePlayerGravity) && (headPosition - link.transform.position).sqrMagnitude < (float)typeSettings.GetRangeSqr();
				flag |= link.IsUnlocked && flag2;
			}
			UpdateOpenCloseState(flag);
			UpdateShaderProperties();
		}
	}

	private void UpdateOpenCloseState(bool isPlayerOnSameGravityAndInRange)
	{
		if (canClose)
		{
			bool flag = IsUnlocked && inRange && AllowTeleport();
			flag = flag || isPlayerOnSameGravityAndInRange;
			if (flag && state == PortalState.CLOSED)
			{
				OpenPortal();
			}
			else if (!flag && state == PortalState.OPEN)
			{
				ClosePortal();
			}
			else if (!flag && state == PortalState.LOCKED && openAmount == 1f)
			{
				ClosePortal();
			}
			else if (flag && state == PortalState.OPEN && openAmount == 0f)
			{
				OpenPortal();
			}
		}
		UpdateParticlesEnabled();
	}

	public void OnPreCullSubmitMainCamera(ref ScriptableCullingParameters cullParams)
	{
		if (renderingEnabled)
		{
			Bounds bounds = portalRenderer.bounds;
			_PortalCamera.OnPreCullSubmitMainCamera(bounds, ref cullParams);
		}
	}

	public void OnPostCullMainCamera()
	{
		if (renderingEnabled)
		{
			IsVisable = cullingGroup.QueryIndices(visible: true, cullingQuery, 0) > 0;
			_PortalCamera.enabled = IsVisable;
			renderingEnabled = IsVisable;
		}
	}

	public void UpdateRenderingData(MRBase ownerPlayerIsIn, bool inPlayerScene, Vector3 headPos, Vector3 headLatestPos)
	{
		bool flag = false;
		if (inPlayerScene)
		{
			if (CheckPortalShouldRender())
			{
				flag = true;
				mirrorDistance = Mathf.Max(0f, mirrorDistance - IC.DeltaTime / BaseSettings<PortalSettings>.Inst.mirrorFrostTime);
			}
			else if ((MainCamera.Inst.transform.position - base.transform.position).magnitude < BaseSettings<PortalSettings>.Inst.mirrorForceDisabledDist)
			{
				if ((type == PortalType.Mirror || type == PortalType.PassThroughMirror) && mirrorDistance < 1f)
				{
					mirrorDistance = Mathf.Min(1f, mirrorDistance + IC.DeltaTime / BaseSettings<PortalSettings>.Inst.mirrorFrostTime);
					flag = mirrorDistance < 1f;
				}
			}
			else
			{
				flag = false;
			}
			if (type == PortalType.FakeMirror && flag)
			{
				Link.mirrorDistance = mirrorDistance;
			}
		}
		bool flag2 = flag != renderingEnabled;
		if (flag || flag2)
		{
			if (flag2)
			{
				SetPortalRenderingEnabled(flag);
			}
			UpdateShaderProperties();
			if (isMoveable)
			{
				Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
				for (int i = 0; i < cullingSpheres.Length; i++)
				{
					cullingSpheres[i].position = localToWorldMatrix.MultiplyPoint3x4(cullingSpherePositions[i]);
				}
				cullingGroup.SetBoundingSpheres(cullingSpheres);
			}
		}
		cachedXFormData.Update();
		Transform xform = cachedXFormData.xform;
		Vector3 localScale = xform.localScale;
		Vector3 localPosition = xform.InverseTransformPoint(headPos);
		cachedHeadZ = ((localScale.z < 0f) ? (0f - localPosition.z) : localPosition.z);
		bool flag3 = cachedHeadZ <= 0f && twoSided;
		localScale.z = (flag3 ? (-1f) : 1f);
		xform.localScale = localScale;
		if (flag)
		{
			cachedUpdateEyeMask = IsLocalPointInside2DPortalShape(localPosition);
		}
		else
		{
			cachedUpdateEyeMask = false;
		}
		Portal link = Link;
		if ((object)link == null || link.cachedXFormData == null || (!inPlayerScene && (object)link.owner != ownerPlayerIsIn) || openAmount == 0f)
		{
			return;
		}
		bool flag4 = (object)link == this;
		Transform xform2 = link.cachedXFormData.xform;
		Quaternion orientation = (flag4 ? mirrorOrientationOffset : rotate180Y);
		GetPortalMatrix(xform, xform2, orientation, flipX, flipY, flipZ, out cachedPortalMatrix);
		cachedPortalMatrixInv = Matrix4x4.Inverse(cachedPortalMatrix);
		Vector3 position = xform.position;
		Vector3 position2 = xform2.position;
		Vector3 vector = cachedXFormData.forward;
		xform2.rotation.GetAxes(out var _, out var _, out var fowrard);
		bool num = Vector3.Dot(headLatestPos - position, vector) < 0f;
		if (flag4 != flipZ)
		{
			fowrard = -fowrard;
		}
		if (num)
		{
			vector = -vector;
			fowrard = -fowrard;
		}
		cachedClipPlaneV = vector;
		cachedClipPlaneV.w = 0f - Vector3.Dot(vector, position);
		cachedLinkClipPlaneV = fowrard;
		cachedLinkClipPlaneV.w = 0f - Vector3.Dot(fowrard, position2);
		int cullingMask = PortalCamera.cameraComp.cullingMask;
		if (!objectTeleportOnEnter)
		{
			return;
		}
		Bounds bounds = this.portalRenderer.bounds;
		Vector3 min = bounds.min;
		Vector3 max = bounds.max;
		ConstArray<PortalRenderer> portalRenderers = owner.portalRenderers;
		uint length = portalRenderers.Length;
		for (int j = 0; j < length; j++)
		{
			PortalRenderer portalRenderer = portalRenderers._data[j];
			if (portalRenderer.UpdatePortalIntersection(this, min, max, cullingMask))
			{
				intersectingRenderers.Add(portalRenderer);
			}
		}
	}

	public bool IntersectsBounds(Bounds worldBounds)
	{
		Bounds lhs = portalRenderer.bounds;
		return BoundsX.Intersects(ref lhs, ref worldBounds);
	}

	public void GetPortalMatrix(out Matrix4x4 portalMatrix)
	{
		Quaternion orientation = (((object)Link == this) ? mirrorOrientationOffset : rotate180Y);
		GetPortalMatrix(base.transform, Link.transform, orientation, flipX, flipY, flipZ, out portalMatrix);
	}

	public static void GetPortalMatrix(Transform portalTransform, Transform linkTransform, Quaternion orientation, bool flipX, bool flipY, bool flipZ, out Matrix4x4 outMatrix)
	{
		Vector3 position = portalTransform.position;
		Quaternion rotation = portalTransform.rotation;
		float num = rotation.x + rotation.x;
		float num2 = rotation.y + rotation.y;
		float num3 = rotation.z + rotation.z;
		float num4 = rotation.x * num;
		float num5 = rotation.x * num2;
		float num6 = rotation.x * num3;
		float num7 = rotation.y * num2;
		float num8 = rotation.y * num3;
		float num9 = rotation.z * num3;
		float num10 = rotation.w * num;
		float num11 = rotation.w * num2;
		float num12 = rotation.w * num3;
		Matrix4x4 matrix4x = default(Matrix4x4);
		matrix4x.m00 = 1f - (num7 + num9);
		matrix4x.m10 = num5 - num12;
		matrix4x.m20 = num6 + num11;
		matrix4x.m01 = num5 + num12;
		matrix4x.m11 = 1f - (num4 + num9);
		matrix4x.m21 = num8 - num10;
		matrix4x.m02 = num6 - num11;
		matrix4x.m12 = num8 + num10;
		matrix4x.m22 = 1f - (num4 + num7);
		position.x = 0f - position.x;
		position.y = 0f - position.y;
		position.z = 0f - position.z;
		matrix4x.m03 = position.x * matrix4x.m00 + position.y * matrix4x.m01 + position.z * matrix4x.m02;
		matrix4x.m13 = position.x * matrix4x.m10 + position.y * matrix4x.m11 + position.z * matrix4x.m12;
		matrix4x.m23 = position.x * matrix4x.m20 + position.y * matrix4x.m21 + position.z * matrix4x.m22;
		if (flipX)
		{
			matrix4x.m00 *= -1f;
			matrix4x.m01 *= -1f;
			matrix4x.m02 *= -1f;
			matrix4x.m03 *= -1f;
		}
		if (flipY)
		{
			matrix4x.m10 *= -1f;
			matrix4x.m11 *= -1f;
			matrix4x.m12 *= -1f;
			matrix4x.m13 *= -1f;
		}
		if (flipZ)
		{
			matrix4x.m20 *= -1f;
			matrix4x.m21 *= -1f;
			matrix4x.m22 *= -1f;
			matrix4x.m23 *= -1f;
		}
		Vector3 position2 = linkTransform.position;
		Quaternion rotation2 = linkTransform.rotation;
		Quaternion quaternion = default(Quaternion);
		quaternion.x = rotation2.w * orientation.x + rotation2.x * orientation.w + rotation2.y * orientation.z - rotation2.z * orientation.y;
		quaternion.y = rotation2.w * orientation.y + rotation2.y * orientation.w + rotation2.z * orientation.x - rotation2.x * orientation.z;
		quaternion.z = rotation2.w * orientation.z + rotation2.z * orientation.w + rotation2.x * orientation.y - rotation2.y * orientation.x;
		quaternion.w = rotation2.w * orientation.w - rotation2.x * orientation.x - rotation2.y * orientation.y - rotation2.z * orientation.z;
		float num13 = quaternion.x + quaternion.x;
		float num14 = quaternion.y + quaternion.y;
		float num15 = quaternion.z + quaternion.z;
		float num16 = quaternion.x * num13;
		float num17 = quaternion.x * num14;
		float num18 = quaternion.x * num15;
		float num19 = quaternion.y * num14;
		float num20 = quaternion.y * num15;
		float num21 = quaternion.z * num15;
		float num22 = quaternion.w * num13;
		float num23 = quaternion.w * num14;
		float num24 = quaternion.w * num15;
		Matrix4x4 matrix4x2 = default(Matrix4x4);
		matrix4x2.m00 = 1f - (num19 + num21);
		matrix4x2.m01 = num17 - num24;
		matrix4x2.m02 = num18 + num23;
		matrix4x2.m03 = position2.x;
		matrix4x2.m10 = num17 + num24;
		matrix4x2.m11 = 1f - (num16 + num21);
		matrix4x2.m12 = num20 - num22;
		matrix4x2.m13 = position2.y;
		matrix4x2.m20 = num18 - num23;
		matrix4x2.m21 = num20 + num22;
		matrix4x2.m22 = 1f - (num16 + num19);
		matrix4x2.m23 = position2.z;
		outMatrix.m00 = matrix4x2.m00 * matrix4x.m00 + matrix4x2.m01 * matrix4x.m10 + matrix4x2.m02 * matrix4x.m20;
		outMatrix.m01 = matrix4x2.m00 * matrix4x.m01 + matrix4x2.m01 * matrix4x.m11 + matrix4x2.m02 * matrix4x.m21;
		outMatrix.m02 = matrix4x2.m00 * matrix4x.m02 + matrix4x2.m01 * matrix4x.m12 + matrix4x2.m02 * matrix4x.m22;
		outMatrix.m03 = matrix4x2.m00 * matrix4x.m03 + matrix4x2.m01 * matrix4x.m13 + matrix4x2.m02 * matrix4x.m23 + matrix4x2.m03;
		outMatrix.m10 = matrix4x2.m10 * matrix4x.m00 + matrix4x2.m11 * matrix4x.m10 + matrix4x2.m12 * matrix4x.m20;
		outMatrix.m11 = matrix4x2.m10 * matrix4x.m01 + matrix4x2.m11 * matrix4x.m11 + matrix4x2.m12 * matrix4x.m21;
		outMatrix.m12 = matrix4x2.m10 * matrix4x.m02 + matrix4x2.m11 * matrix4x.m12 + matrix4x2.m12 * matrix4x.m22;
		outMatrix.m13 = matrix4x2.m10 * matrix4x.m03 + matrix4x2.m11 * matrix4x.m13 + matrix4x2.m12 * matrix4x.m23 + matrix4x2.m13;
		outMatrix.m20 = matrix4x2.m20 * matrix4x.m00 + matrix4x2.m21 * matrix4x.m10 + matrix4x2.m22 * matrix4x.m20;
		outMatrix.m21 = matrix4x2.m20 * matrix4x.m01 + matrix4x2.m21 * matrix4x.m11 + matrix4x2.m22 * matrix4x.m21;
		outMatrix.m22 = matrix4x2.m20 * matrix4x.m02 + matrix4x2.m21 * matrix4x.m12 + matrix4x2.m22 * matrix4x.m22;
		outMatrix.m23 = matrix4x2.m20 * matrix4x.m03 + matrix4x2.m21 * matrix4x.m13 + matrix4x2.m22 * matrix4x.m23 + matrix4x2.m23;
		outMatrix.m30 = 0f;
		outMatrix.m31 = 0f;
		outMatrix.m32 = 0f;
		outMatrix.m33 = 1f;
	}

	public bool PositionIsWithinPortalVolume(Vector3 position, out float zProj)
	{
		if (IsPointInside2DPortalShape(position))
		{
			Vector3 lhs = position - base.transform.position;
			zProj = Vector3.Dot(lhs, base.transform.forward);
			return zProj <= 0f;
		}
		zProj = 0f;
		return false;
	}

	public void SetLinkRef(IDObjectRef iDObjectRef)
	{
		linkRef = iDObjectRef;
		RefreshLink(iDObjectRef.GetOrNull<Portal>());
	}

	public void SetLinkRef(Portal portal)
	{
		linkRef.id = portal.id;
		RefreshLink(portal);
	}

	private void RefreshLink(Portal newPortal = null)
	{
		if ((bool)currentRegion)
		{
			currentRegion.RemoveAllConnectionsByOwner(Link);
		}
		if ((bool)Link && (bool)Link.currentRegion)
		{
			Link.currentRegion.RemoveAllConnectionsByOwnerAndTarget(currentRegion, this);
		}
		Link = newPortal;
		_ = Link;
		SceneInfo sceneInfo = owner.info.Load();
		if (sceneInfo.allowSceneRefConnections)
		{
			owner.AddConnectingScene(sceneInfo);
		}
		if ((bool)currentRegion)
		{
			currentRegion.AddConnection(currentRegion, this);
		}
	}

	private bool IsPointInside2DPortalShape(Vector3 worldPosition)
	{
		Vector3 localPosition = base.transform.InverseTransformPoint(worldPosition);
		return IsLocalPointInside2DPortalShape(localPosition);
	}

	public bool IsLocalPointInside2DPortalShape(Vector3 localPosition)
	{
		Edge[] edges = portalShape.edges;
		Vector3[] vertices = portalShape.vertices;
		bool flag = false;
		int num = edges.Length;
		for (int i = 0; i < num; i++)
		{
			Edge edge = edges[i];
			Vector3 vector = vertices[edge.i0];
			Vector3 vector2 = vertices[edge.i1];
			if (vector.y > localPosition.y != vector2.y > localPosition.y && localPosition.x < (vector2.x - vector.x) * (localPosition.y - vector.y) / (vector2.y - vector.y) + vector.x)
			{
				flag = !flag;
			}
		}
		return flag;
	}

	public bool PositionCrossedPortalPlane(Vector3 currentPosition, Vector3 previousPosition, out Vector3 hitPoint, bool IgnoreTwoSided = false)
	{
		Vector3 endPoint = TranslateToPortalSpace(currentPosition, base.transform.position, base.transform.rotation, cachedLossyScale);
		Vector3 startPoint = TranslateToPortalSpace(previousPosition, lastState.position, lastState.rotation, cachedLossyScale);
		bool flag = RaycastPortalPlaneLocaly(startPoint, endPoint, out hitPoint);
		if (flag && !twoSided && !IgnoreTwoSided)
		{
			float num = Vector3.Dot(currentPosition - previousPosition, base.transform.forward);
			flag = flag && num < 0f;
		}
		return flag;
	}

	public bool RaycastPortalPlane(Vector3 startPoint, Vector3 endPoint, out Vector3 hitPointLocal)
	{
		Vector3 position = base.transform.position;
		Quaternion rotation = base.transform.rotation;
		Vector3 startPoint2 = TranslateToPortalSpace(startPoint, position, rotation, cachedLossyScale);
		Vector3 endPoint2 = TranslateToPortalSpace(endPoint, position, rotation, cachedLossyScale);
		return RaycastPortalPlaneLocaly(startPoint2, endPoint2, out hitPointLocal);
	}

	private bool RaycastPortalPlaneLocaly(Vector3 startPoint, Vector3 endPoint, out Vector3 hitPoint)
	{
		Vector3 vector = default(Vector3);
		vector.x = endPoint.x - startPoint.x;
		vector.y = endPoint.y - startPoint.y;
		vector.z = endPoint.z - startPoint.z;
		float num = Mathf.Sqrt(vector.x * vector.x + vector.y * vector.y + vector.z * vector.z);
		float num2 = 1f / num;
		vector.x *= num2;
		vector.y *= num2;
		vector.z *= num2;
		float num3 = Mathf.Epsilon * 8f;
		if (vector.z > num3 || vector.z < 0f - num3)
		{
			float num4 = (0f - startPoint.z) / vector.z;
			if (num4 > 0f && num4 <= num)
			{
				hitPoint.x = startPoint.x + vector.x * num4;
				hitPoint.y = startPoint.y + vector.y * num4;
				hitPoint.z = startPoint.z + vector.z * num4;
				return true;
			}
		}
		hitPoint = Vector3X.zero;
		return false;
	}

	public static Vector3 TranslateToPortalSpace(Vector3 worldPosition, Vector3 portalPos, Quaternion portalRot, Vector3 portalScale)
	{
		Vector3 vector = default(Vector3);
		vector.x = worldPosition.x - portalPos.x;
		vector.y = worldPosition.y - portalPos.y;
		vector.z = worldPosition.z - portalPos.z;
		vector = Quaternion.Inverse(portalRot) * vector;
		Vector3 vector2 = default(Vector3);
		vector2.x = 1f / portalScale.x;
		vector2.y = 1f / portalScale.y;
		vector2.z = 1f / portalScale.z;
		vector.x = vector2.x * vector.x;
		vector.y = vector2.y * vector.y;
		vector.z = vector2.z * vector.z;
		return vector;
	}

	public bool PositionCrossedPortalThreshold(Vector3 currentPosition, Vector3 previousPosition, bool IgnoreTwoSided = false)
	{
		Vector3 hitPoint = Vector3X.zero;
		if (PositionCrossedPortalPlane(currentPosition, previousPosition, out hitPoint, IgnoreTwoSided))
		{
			return IsLocalPointInside2DPortalShape(hitPoint);
		}
		return false;
	}

	public static bool RaycastPortal(Vector3 startPoint, Vector3 endPoint, out Portal portalOut)
	{
		MRBase mRBase = MainCamera.Inst.GetOwner();
		if ((bool)mRBase)
		{
			uint length = mRBase.portals.Length;
			for (int i = 0; i < length; i++)
			{
				Portal portal = mRBase.portals._data[i];
				if (portal.objectTeleportOnEnter && IsPortalValidToTeleportThrough(portal) && portal.RaycastPortal(startPoint, endPoint))
				{
					portalOut = portal;
					return true;
				}
			}
		}
		portalOut = null;
		return false;
	}

	public bool RaycastPortal(Vector3 startPoint, Vector3 endPoint)
	{
		bool flag = false;
		if (RaycastPortalPlane(startPoint, endPoint, out var hitPointLocal))
		{
			flag = IsLocalPointInside2DPortalShape(hitPointLocal);
		}
		if (flag && !twoSided)
		{
			Vector3 lhs = default(Vector3);
			lhs.x = endPoint.x - startPoint.x;
			lhs.y = endPoint.y - startPoint.y;
			lhs.z = endPoint.z - startPoint.z;
			float num = Vector3.Dot(lhs, base.transform.forward);
			flag = flag && num < 0f;
		}
		return flag;
	}

	public void DrawIntersectingRenderers(CommandBuffer cmd, bool isPortal, bool transparentPass)
	{
		_DrawIntersectingRenderers(cmd, isPortal, transparentPass);
		if ((object)Link != null)
		{
			Link._DrawIntersectingRenderers(cmd, isPortal, transparentPass);
		}
	}

	private void _DrawIntersectingRenderers(CommandBuffer cmd, bool isPortal, bool transparentPass)
	{
		if (intersectingRenderers.Length == 0)
		{
			return;
		}
		cmd.SetGlobalMatrix(ShaderPID.nexus_MatrixPortal, cachedPortalMatrix);
		cmd.SetInvertedCulling_NX(!isPortal && _PortalCamera.ViewInvertsFaces());
		PortalVariations.VariantSet set = (isPortal ? MainCamera.Inst.portalVariantSet : portalVariantSet);
		PortalRenderer[] data = intersectingRenderers._data;
		for (int i = 0; i < intersectingRenderers.Length; i++)
		{
			PortalRenderer portalRenderer = data[i];
			if (portalRenderer.Valid(set, isPortal))
			{
				portalRenderer.DrawRenderers(cmd, transparentPass);
			}
		}
	}

	private void UpdateEyeMasks(StereoTargetEyeMask eye, float eyeZ, float headZ)
	{
		bool flag = ((!twoSided) ? (eyeZ <= 0f && headZ >= 0f) : (eyeZ == 0f || headZ == 0f || (headZ > 0f && eyeZ <= 0f) || (headZ < 0f && eyeZ >= 0f)));
		_IntersectingEyes = (flag ? (_IntersectingEyes | eye) : (_IntersectingEyes & ~eye));
		bool flag2 = flag || ((!twoSided) ? (eyeZ <= EYE_NEARBY_THRESHOLD && headZ >= 0f - EYE_NEARBY_THRESHOLD) : (eyeZ <= EYE_NEARBY_THRESHOLD && eyeZ >= 0f - EYE_NEARBY_THRESHOLD));
		_NearbyEyes = (flag2 ? (_NearbyEyes | eye) : (_NearbyEyes & ~eye));
	}

	public void OnPreCullMainCamera(Vector3 eyeL, Vector3 eyeR)
	{
		if (cachedUpdateEyeMask)
		{
			Vector3 position = cachedXFormData.position;
			Vector3 forward = cachedXFormData.forward;
			float eyeZ = Vector3.Dot(eyeL - position, forward);
			float eyeZ2 = Vector3.Dot(eyeR - position, forward);
			UpdateEyeMasks(StereoTargetEyeMask.Left, eyeZ, cachedHeadZ);
			UpdateEyeMasks(StereoTargetEyeMask.Right, eyeZ2, cachedHeadZ);
		}
		else
		{
			_IntersectingEyes = StereoTargetEyeMask.None;
			_NearbyEyes = StereoTargetEyeMask.None;
		}
	}

	void HAGIS_Generic_MultiLightSensorController.ICanToggle.TogglableAwake()
	{
	}

	void HAGIS_Generic_MultiLightSensorController.ICanToggle.Toggle(bool enabled)
	{
		if (enabled && state != 0)
		{
			OpenPortal();
		}
		else if (!enabled && state != PortalState.CLOSED && state != PortalState.LOCKED)
		{
			SetUnlockedState(unlocked: false, applyToLink: false);
		}
	}

	private void SetPortalRenderingEnabled(bool renderingEnabled)
	{
		this.renderingEnabled = renderingEnabled;
		_PortalCamera.enabled = renderingEnabled;
		cullingGroup.enabled = renderingEnabled;
	}

	private bool CheckPortalShouldRender()
	{
		if (openAmount == 0f)
		{
			return false;
		}
		if (!base.enabled || !base.gameObject.activeInHierarchy)
		{
			return false;
		}
		if (Link == null)
		{
			return false;
		}
		if (!GeometryUtility.TestPlanesAABB(CC.Inst.frustumPlanes, portalRenderer.bounds))
		{
			return false;
		}
		Vector3 position = MainCamera.Inst.transform.position;
		Vector3 position2 = base.transform.position;
		Vector3 vector = position - position2;
		if (!twoSided && Vector3.Dot(vector.normalized, base.transform.forward) < -0.05f)
		{
			return false;
		}
		if (cameraMode != 0)
		{
			return cameraMode == PortalCameraMode.ManualOn;
		}
		if (IsHoldable)
		{
			return true;
		}
		if (!canClose && (type == PortalType.Mirror || type == PortalType.PassThroughMirror))
		{
			float magnitude = vector.magnitude;
			PortalSettings inst = BaseSettings<PortalSettings>.Inst;
			if (magnitude < (HACK_overrideMinFrostDistance ? overrideMinFrostDistance : inst.mirrorAlwaysEnabledDist))
			{
				return true;
			}
			if (magnitude > inst.mirrorFrostDist)
			{
				return false;
			}
			float num = Mathf.Tan(MainCamera.Inst.cameraComp.fieldOfView * 0.5f * ((float)Math.PI / 180f)) * magnitude;
			if (portalShape.faceBounds.size.x * base.transform.localScale.x * (portalShape.faceBounds.size.y * base.transform.localScale.y) / num < inst.mirrorMagicDisableNumber)
			{
				return false;
			}
		}
		return true;
	}

	public static void OnUpdateAllPortalLinks(ConstArray<Portal> portals)
	{
		for (int i = 0; i < portals._dataNum; i++)
		{
			Portal portal = portals._data[i];
			if (portal.Link == null)
			{
				portal.Link = (portal.IsMirror ? portal : portal.linkRef.GetOrNull<Portal>(portal.gameObject));
			}
		}
	}

	public static void OnUpdateAll(ConstArray<Portal> portals, bool inPlayerScene, MRBase ownerPlayerIsIn)
	{
		Vector3 headPosition = IC.GetHeadPosition();
		Vector3 up = CC.Inst.transform.up;
		float num = Mathf.Cos((float)Math.PI / 120f);
		float deltaTime = IC.DeltaTime;
		for (int i = 0; i < portals._dataNum; i++)
		{
			Portal portal = portals._data[i];
			Portal link = portal.Link;
			bool flag = inPlayerScene || ((object)link != null && (object)link.owner == ownerPlayerIsIn);
			if (!(portal.isActiveAndEnabled && flag))
			{
				continue;
			}
			Transform transform = portal.transform;
			Vector3 vector = transform.rotation * Vector3X.up;
			float num2 = up.x * vector.x;
			float num3 = up.y * vector.y;
			float num4 = up.z * vector.z;
			bool flag2 = num2 + num3 + num4 > num;
			float sqrMagnitude = (headPosition - transform.position).sqrMagnitude;
			portal.inRange = flag2 && sqrMagnitude < (float)portal.typeSettings.GetRangeSqr();
			bool flag3 = (bool)link && link != portal && link.inRange && link.isUnlocked;
			bool flag4 = portal.closeAndRestoreLink != null && portal.closeAndRestoreLink.started;
			portal.UpdateOpenCloseState((portal.inRange || flag3) && !flag4);
			if (portal.isMoveable || ((bool)portal.currentRegion && portal.currentRegion.isDynamic))
			{
				portal.UpdateRegion();
			}
			if (portal.type == PortalType.Eyeglass || portal.type == PortalType.PassThroughMirror)
			{
				portal.UpdateMirrorRipples();
			}
			float num5 = Mathf.Clamp01(Mathf.InverseLerp(100f, 10f, sqrMagnitude));
			if (portal.portalParticleAlpha != num5)
			{
				portal.portalParticleAlpha = Mathf.MoveTowards(portal.portalParticleAlpha, num5, deltaTime);
				portal.psMPB.SetColor(ShaderPID._TintColor, new Color(1f, 1f, 1f, portal.portalParticleAlpha));
				bool flag5 = portal.portalParticleAlpha != 0f;
				ParticleSystemRenderer[] array = portal.psRenderersToAlpha;
				foreach (ParticleSystemRenderer obj in array)
				{
					obj.SetPropertyBlock(portal.psMPB);
					obj.enabled = flag5;
				}
			}
			if ((object)portal.currentRegion == null)
			{
				continue;
			}
			if ((object)link == null || (object)link.currentRegion == null)
			{
				portal.currentRegion.RemoveAllConnectionsByOwner(link);
				continue;
			}
			bool flag6 = portal.currentRegion.ConnectionExists(link.currentRegion, link);
			if ((portal.state == PortalState.OPEN || ((bool)portal.Link && portal.Link.state == PortalState.OPEN)) && !flag6)
			{
				portal.currentRegion.AddConnection(link.currentRegion, link);
				link.currentRegion.AddConnection(portal.currentRegion, portal);
			}
			else if (portal.state != 0 && (!portal.Link || portal.Link.state != PortalState.OPEN) && flag6)
			{
				portal.currentRegion.RemoveConnection(link.currentRegion, link);
				link.currentRegion.RemoveConnection(portal.currentRegion, portal);
			}
		}
	}

	public void OnEndOfUpdate()
	{
		if (IsHoldable && owner == MainCamera.Inst.GetOwner())
		{
			bool flag = currentRegion != null && Link != null && Link.currentRegion != null;
			if (flag)
			{
				Bounds bounds = Link.portalRenderer.bounds;
				flag &= Physics.OverlapBox(Link.transform.position, bounds.extents, Link.transform.rotation, 1).Length == 0;
			}
			SetUnlockedState(flag);
		}
	}

	public void OnLateUpdateLR()
	{
		lastState.UpdateToLatestState();
		if (_PortalCamera.isActiveAndEnabled)
		{
			_PortalCamera.OnLateUpdateLR();
		}
	}

	void IPauseEvent.OnPauseLR(bool paused)
	{
		if (IsMirror || !canClose)
		{
			return;
		}
		if (paused)
		{
			lockedOrClosedBeforePause = state != PortalState.OPEN;
			if ((bool)Link)
			{
				lockedOrClosedBeforePause |= Link.state != PortalState.OPEN;
			}
		}
		if (!lockedOrClosedBeforePause)
		{
			SetUnlockedState(!paused);
		}
		if (!paused)
		{
			lockedOrClosedBeforePause = false;
		}
	}

	void IPauseUpdate.OnPauseUpdateLR()
	{
	}

	private IEnumerator<Routine.Yield> SwitchTargetPortalLinkRoutine(SceneInfo targetSceneInfo)
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		MRBase mRBaseWithSceneInfo = LR.Inst.GetMRBaseWithSceneInfo(targetSceneInfo);
		if (targetSceneInfo.name.Contains("_ALT_"))
		{
			mRBaseWithSceneInfo = LR.Inst.GetMRBaseWithSceneInfo(mRBaseWithSceneInfo.mimicSceneInfo);
		}
		Portal targetPortal = mRBaseWithSceneInfo.returnPortal?.portal;
		if (!(targetPortal == null))
		{
			while (!targetPortal.IsAwake)
			{
				yield return Wait.For.LRUpdates(1);
			}
			storedLinkRefID = linkRef.id;
			linkRef.id = targetPortal.id;
			linkRef.obj = targetPortal;
			RefreshLink();
			targetPortal.storedLinkRefID = targetPortal.linkRef.id;
			targetPortal.linkRef.id = id;
			targetPortal.linkRef.obj = this;
			targetPortal.RefreshLink();
			targetPortal.SetHidden(hidden: false);
		}
	}

	private IEnumerator<Routine.Yield> CloseAndRestoreLinkRoutine()
	{
		if (!string.IsNullOrEmpty(storedLinkRefID) && !(linkRef.id == storedLinkRefID))
		{
			bool singleUseReturnPortal = false;
			if (owner.returnPortal != null)
			{
				singleUseReturnPortal = owner.returnPortal.singleUse;
				_ = owner.returnPortal.lockOnClose;
			}
			if (animatePortalRoutine.started)
			{
				yield return Wait.Until.Completed(animatePortalRoutine);
			}
			yield return Wait.For.LRUpdates(1);
			if (animatePortalRoutine.started)
			{
				yield return Wait.Until.Completed(animatePortalRoutine);
			}
			if (singleUseReturnPortal)
			{
				SetHidden(hidden: true);
			}
			Link = null;
			linkRef.id = storedLinkRefID;
			linkRef.obj = null;
			RefreshLink();
			LR.Inst.LoadAdjacentScenes();
			yield return Wait.For.LRUpdates(1);
			yield return LR.Inst.IsAllConnectedScenesLoaded;
			if (animatePortalRoutine.started)
			{
				yield return Wait.Until.Completed(animatePortalRoutine);
				yield return Wait.For.LRUpdates(1);
			}
			if (!singleUseReturnPortal)
			{
				state = PortalState.CLOSED;
				isUnlocked = true;
				UpdateShaderProperties();
				UpdateParticlesEnabled();
			}
		}
	}

	public void OpenPortal(bool firstUnlock = false)
	{
		if (animatePortalRoutine != null)
		{
			animatePortalRoutine.Start(PortalAnimation.OPEN, firstUnlock, resetIfStarted: true);
			if (!firstUnlock)
			{
				state = PortalState.OPEN;
			}
		}
		UpdateParticlesEnabled();
	}

	public void ClosePortal(bool isDestroying = false)
	{
		if (animatePortalRoutine != null)
		{
			((IHagletCallable<PortalAnimation>)animatePortalRoutine).Start(PortalAnimation.CLOSE, resetIfStarted: true, skip: false, waitUntilCompleted: true);
			bool flag = (((bool)Link && Link != this && !Link.IsUnlocked) ? true : false);
			if (!IsUnlocked || flag)
			{
				state = PortalState.LOCKED;
				SetUnlockedState(unlocked: false, applyToLink: false);
				PlaySFX(PortalSFXEvent.LOCKED);
			}
			else
			{
				state = PortalState.CLOSED;
			}
		}
		UpdateParticlesEnabled();
		UpdateShaderProperties();
	}

	public Wait PlayUnlockAnimation(float voTime)
	{
		return portalUnlockAnimation.Start(voTime);
	}

	private IEnumerator<Routine.Yield> PortalUnlockAnimationRoutine(float voTime)
	{
		while (Link == null)
		{
			yield return Wait.For.LRUpdates(1);
		}
		Link.SetUnlockedState(unlocked: true, applyToLink: false);
		if (sfxFeedback2D.isValid())
		{
			sfxFeedback2D.stop(STOP_MODE.IMMEDIATE);
		}
		if (sfxFeedback3DOpenClose.isValid())
		{
			sfxFeedback3DOpenClose.stop(STOP_MODE.IMMEDIATE);
		}
		if (sfxFeedback3DIdle.isValid())
		{
			sfxFeedback3DIdle.stop(STOP_MODE.IMMEDIATE);
		}
		currentSurfaceMaterialInst = unlockSurfaceMaterialInst;
		currentSurfaceMaterial = BaseSettings<PortalSettings>.Inst.HubUnlockSettings.defaultSurfaceMaterial;
		float time = 0f;
		particleFlakes.SetActive(value: true);
		_ = typeSettings;
		AnimationCurve curve = BaseSettings<PortalSettings>.Inst.HubUnlockSettings.portalOpenCurve;
		do
		{
			time += IC.RealDeltaTime;
			float time2 = (openAmount = Mathf.Clamp01(time / voTime));
			UpdateBurnAlpha();
			_GlowColorRGB_Step_Values.w = curve.Evaluate(time2);
			portalMPB.SetVector(_GlowColorRGB_Step, _GlowColorRGB_Step_Values);
			portalRenderer.SetPropertyBlock(portalMPB);
			yield return Wait.For.LRUpdates(1);
		}
		while (time < voTime);
		currentSurfaceMaterialInst = defaultSurfaceMaterialInst;
		currentSurfaceMaterial = defaultSurfaceMaterial;
		particleFlakes.SetActive(value: false);
		particleBurst.SetActive(value: true);
	}

	private IEnumerator<Routine.Yield> AnimatePortalRoutine(PortalAnimation animation, bool firstUnlock = false)
	{
		if (sfxFeedback2D.isValid())
		{
			sfxFeedback2D.stop(STOP_MODE.IMMEDIATE);
		}
		if (sfxFeedback3DOpenClose.isValid())
		{
			sfxFeedback3DOpenClose.stop(STOP_MODE.ALLOWFADEOUT);
		}
		if (sfxFeedback3DIdle.isValid())
		{
			sfxFeedback3DIdle.stop(STOP_MODE.IMMEDIATE);
		}
		float timeMax = (IsMoveable ? typeSettings.eyeglassExpansionTime : typeSettings.expansionTime);
		float time = timeMax * ((animation == PortalAnimation.OPEN) ? openAmount : (1f - openAmount));
		if (switchTargetPortalLink.started)
		{
			yield return Wait.Until.Completed(switchTargetPortalLink);
		}
		AnimationCurve curve;
		if (animation == PortalAnimation.OPEN)
		{
			curve = typeSettings.portalOpenCurve;
			sfxFeedback3DOpenClose = PlaySFX(PortalSFXEvent.OPENED);
			sfxFeedback3DIdle = PlaySFX(PortalSFXEvent.OPEN_IDLE, forceTrack: true);
		}
		else
		{
			curve = typeSettings.portalCloseCurve;
			sfxFeedback3DOpenClose = PlaySFX(PortalSFXEvent.CLOSED);
			sfxFeedback3DIdle = PlaySFX(PortalSFXEvent.CLOSED_IDLE, forceTrack: true);
		}
		do
		{
			time += IC.RealDeltaTime;
			float num = Mathf.Clamp01(time / timeMax);
			openAmount = ((animation == PortalAnimation.OPEN) ? num : (1f - num));
			UpdateBurnAlpha();
			_GlowColorRGB_Step_Values.w = curve.Evaluate(num);
			portalMPB.SetVector(_GlowColorRGB_Step, _GlowColorRGB_Step_Values);
			portalRenderer.SetPropertyBlock(portalMPB);
			yield return Wait.For.LRRealtimeUpdates(1);
		}
		while (time < timeMax);
		if (animation == PortalAnimation.OPEN)
		{
			if ((bool)portalLoop)
			{
				portalLoop.StartEvents();
			}
			if (portalRegion != null && !portalRegionIsEnabled)
			{
				portalRegion.Enable();
				portalRegionIsEnabled = true;
			}
			if (firstUnlock)
			{
				state = PortalState.OPEN;
			}
		}
		else
		{
			if ((bool)portalLoop)
			{
				portalLoop.StopEvents();
			}
			if (portalRegion != null && portalRegionIsEnabled)
			{
				portalRegion.Disable();
				portalRegionIsEnabled = false;
			}
		}
	}

	private void UpdateBurnAlpha()
	{
		if (burnMPB != null)
		{
			float num = 1f - openAmount;
			if (num >= 1f)
			{
				portalBurnmark.SetPropertyBlock(null);
			}
			else
			{
				burnMPB.SetFloat(ShaderPID._Alpha, num);
				portalBurnmark.SetPropertyBlock(burnMPB);
			}
			portalBurnmark.enabled = num > 0f;
		}
	}

	private void UpdateShaderProperties()
	{
		currentSurfaceMaterialInst.SetInt(_PORTAL_ID, _PortalCamera.PUID);
		_GlowColorRGB_Step_Values.x = BorderColor.r;
		_GlowColorRGB_Step_Values.y = BorderColor.g;
		_GlowColorRGB_Step_Values.z = BorderColor.b;
		currentSurfaceMaterialInst.SetColor(_GlowColorRGB_Step, _GlowColorRGB_Step_Values);
		if (type == PortalType.Mirror || type == PortalType.PassThroughMirror)
		{
			currentSurfaceMaterialInst.SetFloat(_Distance, mirrorDistance);
			currentSurfaceMaterialInst.SetTexture(_RefTex, mirrorDistanceTexture);
		}
		if (positionsArray != null && positionsArray.Count > 0)
		{
			currentSurfaceMaterialInst.SetVectorArray(ShaderPID._PositionsArray, positionsArray.ToArray());
			currentSurfaceMaterialInst.SetFloat(ShaderPID._PositionArrayLength, positionsArray.Count);
		}
		currentSurfaceMaterialInst.SetVector(ShaderPID._PortalScale, base.transform.localScale.RepZ(0f));
		bool flag = !isUnlocked;
		_StepMinMax_IsLocked_AlphaClip_Values.x = typeSettings.minStep;
		_StepMinMax_IsLocked_AlphaClip_Values.y = typeSettings.maxStep;
		_StepMinMax_IsLocked_AlphaClip_Values.z = (flag ? 1 : 0);
		currentSurfaceMaterialInst.SetVector(_StepMinMax_IsLocked_AlphaClip, _StepMinMax_IsLocked_AlphaClip_Values);
		portalMaterial.CopyPropertiesFromMaterial(currentSurfaceMaterialInst);
		portalMaterial.EnableKeyword("PORTAL_SURFACE");
		portalMaterial.SetInt(ShaderPID._ZTEST, 4);
		portalMaterial.SetShaderPassEnabled("NexusPortalClear", renderingEnabled);
		portalMaterial.SetInt(ShaderPID._COLORMASK, (!renderingEnabled) ? 15 : 0);
	}

	public PortalTransform CalculatePortalObjectTransform(Vector3 worldPos, Quaternion worldRot, Vector3 worldDir)
	{
		Portal link = Link;
		if (!link)
		{
			PortalTransform result = default(PortalTransform);
			result.position = worldPos;
			result.rotation = worldRot;
			result.direction = worldDir;
			return result;
		}
		Portal portal = link;
		PortalTransform result2 = default(PortalTransform);
		Quaternion quaternion = Quaternion.Inverse(transform.rotation);
		Quaternion quaternion2 = quaternion * worldRot;
		Quaternion rotation = portal.transform.rotation;
		Vector3 a = quaternion * (worldPos - transform.position);
		Vector3 a2 = quaternion * worldDir;
		Vector3 b = new Vector3((!flipX) ? 1 : (-1), (!flipY) ? 1 : (-1), (!flipZ) ? 1 : (-1));
		Quaternion quaternion3 = ((link == this) ? Quaternion.identity : rotate180Y);
		Quaternion quaternion4 = rotation * quaternion3;
		result2.position = portal.transform.position + quaternion4 * Vector3.Scale(a, b);
		if (link == this && flipZ)
		{
			result2.rotation = portal.transform.rotation * rotate180Y * Quaternion.Inverse(transform.rotation) * worldRot;
		}
		else
		{
			result2.rotation = quaternion4 * QuaternionX.Reflect(quaternion2, flipX, flipY, flipZ);
		}
		result2.direction = quaternion4 * Vector3.Scale(a2, b);
		return result2;
	}

	public void TeleportObject(ICanPortal obj, bool allowDisallowedObjects = false, bool allowDisallowedPortal = false)
	{
		if (!IsPortalValidToTeleportThrough(this) && !allowDisallowedPortal)
		{
			return;
		}
		Portal link = Link;
		if ((bool)link && (obj.CanEnterPortal(this) || allowDisallowedObjects))
		{
			if (obj.GetOwner() != link.owner)
			{
				obj.SetOwner(link.owner);
			}
			obj.OnEnterPortal(this);
			for (int i = 0; i < portalEvents.Length; i++)
			{
				portalEvents[i].OnPortalEntered(obj);
				objectEnteredPortal.Trigger();
			}
			if (obj == MainCamera.Inst)
			{
				playerEnteredPortal.Trigger();
				OnPlayerEnterPortal.Invoke();
			}
		}
	}

	public static bool IsPortalValidToTeleportThrough(Portal portal)
	{
		if (portal.state != 0)
		{
			return false;
		}
		if (!portal.isActiveAndEnabled)
		{
			return false;
		}
		if (!portal.AllowTeleport())
		{
			return false;
		}
		bool flag = false;
		if ((object)portal.parentGrabObject != null)
		{
			Hand handObjectIsGrabbedOrFocusGrabbed = CC.Inst.GetHandObjectIsGrabbedOrFocusGrabbed(portal.parentGrabObject);
			if ((bool)handObjectIsGrabbedOrFocusGrabbed && (bool)handObjectIsGrabbedOrFocusGrabbed.InteractableFocusGrabbed)
			{
				return false;
			}
		}
		return !flag;
	}

	public static Portal PortalableEvaluateCrossingPortal(ICanPortal obj)
	{
		Vector3 worldPosition = obj.GetWorldPosition();
		TransformState transformState = obj.GetLastState();
		ConstArray<Portal> portals = obj.GetOwner().portals;
		Portal portal = null;
		float num = float.MaxValue;
		uint dataNum = portals._dataNum;
		Portal[] data = portals._data;
		Vector3 vector = default(Vector3);
		for (int i = 0; i < dataNum; i++)
		{
			Portal portal2 = data[i];
			if (portal2.isActiveAndEnabled && portal2.state == PortalState.OPEN)
			{
				Vector3 position = portal2.transform.position;
				vector.x = position.x - worldPosition.x;
				vector.y = position.y - worldPosition.y;
				vector.z = position.z - worldPosition.z;
				float num2 = vector.x * vector.x + vector.y * vector.y + vector.z * vector.z;
				if (num2 < num)
				{
					num = num2;
					portal = portal2;
				}
			}
		}
		if ((object)portal != null && IsPortalValidToTeleportThrough(portal) && obj.CanTeleport(portal) && portal.PositionCrossedPortalThreshold(worldPosition, transformState.position))
		{
			portal.TeleportObject(obj);
			return portal;
		}
		return null;
	}

	public static Portal PortalableEvaluateCrossingPortalPlane(ICanPortal obj, Portal portal)
	{
		Vector3 worldPosition = obj.GetWorldPosition();
		TransformState transformState = obj.GetLastState();
		if (obj.CanTeleport(portal) && portal.state == PortalState.OPEN && portal.AllowTeleport() && (bool)portal && portal.PositionCrossedPortalPlane(worldPosition, transformState.position, out var _))
		{
			portal.TeleportObject(obj);
			return portal;
		}
		return null;
	}

	public static void SwapPortalRef(ref Portal original, Portal newPortalToAssign)
	{
		Portal portal;
		if (original == null)
		{
			portal = newPortalToAssign;
		}
		else
		{
			_ = newPortalToAssign.Link;
			portal = null;
		}
		original = portal;
	}

	public PortalState GetPortalState()
	{
		return state;
	}

	public override void OnOwnerChange(MRBase _oldOwner, MRBase _newOwner)
	{
		MRBase.TransferObject(_oldOwner, _newOwner, this);
		base.OnOwnerChange(_oldOwner, _newOwner);
	}

	public static Portal FindClosestMirror(ConstArray<Portal> portals, Vector3 worldPosition)
	{
		PortalSettings inst = BaseSettings<PortalSettings>.Inst;
		Portal result = null;
		float num = inst.minDistanceToMirror;
		_ = Vector3.one;
		for (int i = 0; i < portals.Length; i++)
		{
			Portal portal = portals[i];
			if ((object)portal.Link == portal && portal.objectTeleportOnEnter)
			{
				float sqrMagnitude = (portal.transform.position - worldPosition).sqrMagnitude;
				if (sqrMagnitude < num)
				{
					num = sqrMagnitude;
					result = portal;
					_ = (portal.transform.position - worldPosition).normalized;
				}
			}
		}
		return result;
	}

	public Vector3 GetClosestPointOnPortalLocal(Vector3 posLocal)
	{
		Edge[] edges = portalShape.edges;
		if (edges == null)
		{
			return posLocal;
		}
		Vector3[] vertices = portalShape.vertices;
		bool flag = false;
		int num = edges.Length;
		float num2 = float.MaxValue;
		Vector3 zero = Vector3X.zero;
		Vector3 vector3 = default(Vector3);
		for (int i = 0; i < num; i++)
		{
			Edge edge = edges[i];
			Vector3 vector = vertices[edge.i0];
			Vector3 vector2 = vertices[edge.i1];
			float num3 = vector2.x - vector.x;
			float num4 = vector2.y - vector.y;
			float num5 = posLocal.x - vector.x;
			float num6 = posLocal.y - vector.y;
			if (vector.y > posLocal.y != vector2.y > posLocal.y && num5 < num3 * num6 / num4)
			{
				flag = !flag;
			}
			float num7 = num3 * num3 + num4 * num4;
			if (num7 == 0f)
			{
				vector3 = vector;
			}
			else
			{
				float num8 = (num5 * num3 + num6 * num4) / num7;
				if (num8 <= 0f)
				{
					vector3 = vector;
				}
				else if (num8 >= 1f)
				{
					vector3 = vector2;
				}
				else
				{
					vector3.x = vector.x + num3 * num8;
					vector3.y = vector.y + num4 * num8;
				}
			}
			float num9 = vector3.x - posLocal.x;
			float num10 = vector3.y - posLocal.y;
			float num11 = num9 * num9 + num10 * num10;
			if (num11 < num2)
			{
				num2 = num11;
				zero.x = vector3.x;
				zero.y = vector3.y;
			}
		}
		if (flag)
		{
			posLocal.z = 0f;
			return posLocal;
		}
		return zero;
	}

	public Vector3 GetClosestPointOnPortal(Vector3 posWS)
	{
		Vector3 posLocal = base.transform.InverseTransformPoint(posWS);
		posLocal = GetClosestPointOnPortalLocal(posLocal);
		return base.transform.TransformPoint(posLocal);
	}

	private void UpdateMirrorRipples()
	{
		positionsArray.Clear();
		PortalSettings inst = BaseSettings<PortalSettings>.Inst;
		float num = inst.rippleStartDistance * inst.rippleStartDistance;
		ConstArray<InteractableObject> interactableObjects = owner.interactableObjects;
		float num2 = float.PositiveInfinity;
		for (int i = 0; i < interactableObjects.Length; i++)
		{
			GrabObject grabObject = interactableObjects[i] as GrabObject;
			if (!grabObject)
			{
				continue;
			}
			Transform transform = grabObject.transform;
			Vector3 position = transform.position;
			if ((GetClosestPointOnPortal(position) - position).sqrMagnitude < num)
			{
				Vector3 vector = base.transform.InverseTransformPoint(position);
				float num3 = base.transform.InverseTransformPointUnscaled(position).z;
				if (twoSided)
				{
					num3 = Mathf.Abs(num3);
				}
				if (Mathf.Abs(num3) < num2)
				{
					num2 = Mathf.Abs(num3);
				}
				vector.z = Mathf.InverseLerp(inst.rippleStartDistance, 0f, num3) / 5f;
				positionsArray.Add(vector);
			}
			if (!IsMirror || !objectTeleportOnEnter || (grabObject.GetComponent<PortalVariations>()?.GetActiveVariantNum() ?? 0) < 1)
			{
				continue;
			}
			Vector3 position2 = CalculatePortalObjectTransform(position, transform.rotation, Vector3X.zero).position;
			if ((GetClosestPointOnPortal(position2) - position2).sqrMagnitude < num)
			{
				Vector3 vector2 = base.transform.InverseTransformPoint(position2);
				float z = base.transform.InverseTransformPointUnscaled(position2).z;
				z = Mathf.Abs(z);
				if (z < num2)
				{
					num2 = z;
				}
				vector2.z = Mathf.InverseLerp(inst.rippleStartDistance, 0f, z) / 5f;
				positionsArray.Add(vector2);
			}
		}
		transferMirrorSound.getPlaybackState(out var pLAYBACK_STATE);
		if (positionsArray.Count == 0 && pLAYBACK_STATE == PLAYBACK_STATE.PLAYING)
		{
			transferMirrorSound.stop(STOP_MODE.ALLOWFADEOUT);
		}
		else if (positionsArray.Count > 0 && pLAYBACK_STATE != 0 && pLAYBACK_STATE != PLAYBACK_STATE.STARTING)
		{
			transferMirrorSound = FAC.Inst.PlayOneShot(typeSettings.sfx.mirrorItemSFX.Value, base.transform);
		}
		else
		{
			transferMirrorSound.setParameterValue("ProximityMirror", Mathf.Clamp01(1f - Mathf.Sqrt(num2) * 2f));
		}
	}

	public void OnDisable()
	{
		if (sfxFeedback2D.isValid())
		{
			sfxFeedback2D.stop(STOP_MODE.IMMEDIATE);
		}
		if (sfxFeedback3DOpenClose.isValid())
		{
			sfxFeedback3DOpenClose.stop(STOP_MODE.IMMEDIATE);
		}
		if (sfxFeedback3DIdle.isValid())
		{
			sfxFeedback3DIdle.stop(STOP_MODE.IMMEDIATE);
		}
	}

	public override void OnDestroy()
	{
		base.OnDestroy();
		if (animatePortalRoutine != null)
		{
			animatePortalRoutine.Stop(complete: true);
		}
		if (sfxFeedback2D.isValid())
		{
			sfxFeedback2D.stop(STOP_MODE.IMMEDIATE);
		}
		if (sfxFeedback3DOpenClose.isValid())
		{
			sfxFeedback3DOpenClose.stop(STOP_MODE.IMMEDIATE);
		}
		if (sfxFeedback3DIdle.isValid())
		{
			sfxFeedback3DIdle.stop(STOP_MODE.IMMEDIATE);
		}
		if ((bool)Link && Link != this)
		{
			Link.Link = null;
		}
		if ((bool)currentRegion)
		{
			currentRegion.RemoveAllConnectionsByOwner(Link);
			Link?.currentRegion.RemoveAllConnectionsByOwnerAndTarget(currentRegion, this);
		}
		if (cullingGroup != null)
		{
			cullingGroup.Dispose();
		}
	}

	public static Edge[] GetExternalEdges(Mesh mesh)
	{
		List<Edge> list = new List<Edge>();
		int[] triangles = mesh.triangles;
		for (int i = 0; i < triangles.Length; i += 3)
		{
			int num = triangles[i];
			int num2 = triangles[i + 1];
			int num3 = triangles[i + 2];
			if (!MeshX.CheckIfEdgeIsDuplicated(num, num2, triangles, i))
			{
				list.Add(new Edge
				{
					i0 = num,
					i1 = num2
				});
			}
			if (!MeshX.CheckIfEdgeIsDuplicated(num2, num3, triangles, i))
			{
				list.Add(new Edge
				{
					i0 = num2,
					i1 = num3
				});
			}
			if (!MeshX.CheckIfEdgeIsDuplicated(num3, num, triangles, i))
			{
				list.Add(new Edge
				{
					i0 = num3,
					i1 = num
				});
			}
		}
		return list.ToArray();
	}

	private static Mesh GeneratePortalFaceMesh(Mesh shapeMesh)
	{
		Mesh mesh = MeshX.SimplifyMesh(shapeMesh, "Portal Face", MeshX.MeshAttribute.TexCoords);
		Vector3[] vertices = mesh.vertices;
		for (int i = 0; i < vertices.Length; i++)
		{
			vertices[i].z = 0f;
		}
		mesh.vertices = vertices;
		mesh.RecalculateBounds();
		Bounds bounds = mesh.bounds;
		bounds.extents += Vector3X.forward * (MainCamera.Inst.cameraComp.nearClipPlane + 0.001f);
		mesh.bounds = bounds;
		return mesh;
	}

	private static Mesh GeneratePortalVolumeMesh(Mesh shapeMesh, Edge[] edges)
	{
		List<Vector3> list = new List<Vector3>();
		List<int> list2 = new List<int>();
		List<Vector2> list3 = new List<Vector2>();
		Mesh mesh = MeshX.SimplifyMesh(shapeMesh, "Portal Volume", MeshX.MeshAttribute.TexCoords);
		mesh.GetVertices(list);
		mesh.GetTriangles(list2, 0);
		mesh.GetUVs(0, list3);
		int count = list.Count;
		_ = list2.Count;
		_ = list3.Count;
		for (int i = 0; i < count; i++)
		{
			Vector3 vector = list[i];
			vector.z = -1f;
			list[i] = vector;
			vector.z = 0f;
			list.Add(vector);
			list3.Add(list3[i]);
		}
		for (int j = 0; j < edges.Length; j++)
		{
			Edge edge = edges[j];
			int num = 0;
			int num2 = count;
			list2.Add(edge.i0 + num2);
			list2.Add(edge.i1 + num);
			list2.Add(edge.i0 + num);
			list2.Add(edge.i0 + num2);
			list2.Add(edge.i1 + num2);
			list2.Add(edge.i1 + num);
		}
		mesh.SetVertices(list);
		mesh.SetTriangles(list2, 0);
		mesh.SetUVs(0, list3);
		mesh.RecalculateBounds();
		return mesh;
	}

	public Region CalculateCurrentRegion(Region[] regions, Vector3 portalGravity)
	{
		Region region = null;
		float num = 0f;
		foreach (Region region2 in regions)
		{
			if (!region2.IsAlignedToUpDirection(-portalGravity))
			{
				continue;
			}
			float yOffset = region2.GetYOffset(base.transform.position);
			if (yOffset <= 0f)
			{
				continue;
			}
			if (IsMoveable)
			{
				float y = CC.Inst.transform.InverseTransformPoint(MainCamera.Inst.transform.position).y;
				if (yOffset > y + 1f)
				{
					continue;
				}
			}
			if (region2.IsPointInsidePolygonWS(base.transform.position, inner: true) && (!region || (region.isDynamic && !region2.isDynamic) || yOffset < num))
			{
				region = region2;
				num = yOffset;
			}
		}
		return region;
	}

	private void UpdateRegion()
	{
		Region region = currentRegion;
		Vector3 portalGravity = (PortalingRB ? PortalingRB.ObjGravity : (-base.transform.up));
		currentRegion = CalculateCurrentRegion(owner.regions, portalGravity);
		if (!(currentRegion == region) && (bool)region)
		{
			region.RemoveAllConnectionsByOwner(Link);
		}
	}

	public void ShatterMirror()
	{
		if (!shatterMirrorRoutine.started && IsMirror)
		{
			shatterMirrorRoutine.Start();
		}
	}

	private IEnumerator<Routine.Yield> ShatterMirrorRoutine()
	{
		float timer = 0f;
		while (timer < 1f)
		{
			yield return Wait.For.LRUpdates(1);
			timer += IC.DeltaTime;
			currentSurfaceMaterialInst.SetFloat("_Alpha", timer / 1f);
		}
	}

	private FMOD.Studio.EventInstance PlaySFX(PortalSFXEvent sfxEvent, bool forceTrack = false)
	{
		if ((sfxEvents & sfxEvent) == 0)
		{
			return default(FMOD.Studio.EventInstance);
		}
		int num = (int)Mathf.Log((float)sfxEvent, 2f);
		FMODEventAsset fMODEventAsset = sfxEventRefs[num];
		if (fMODEventAsset != null)
		{
			if (type == PortalType.Eyeglass || forceTrack)
			{
				return FAC.Inst.PlayOneShot(fMODEventAsset, base.transform);
			}
			return FAC.Inst.PlayOneShot(fMODEventAsset, base.transform.position);
		}
		return default(FMOD.Studio.EventInstance);
	}

	protected override void OnValidate()
	{
		base.OnValidate();
	}

	private static void SetupPortalAnimationSettings()
	{
	}

	public static void AddPortalParticles()
	{
	}

	private static void AddParticleEffect(GameObject psPrefab, string particleName, Transform holder, Transform portalXForm)
	{
	}

	private static Transform GetHolderXform(Portal portal)
	{
		return null;
	}

	private void OnDrawGizmos()
	{
	}

	protected void OnDrawGizmosSelected()
	{
	}

	public void DrawPortalMeshGizmo(Color color)
	{
	}

	[ContextMenu("Replace with Prefab")]
	private void ReplaceWithPrefab()
	{
	}

	[ContextMenu("Replace with Two Way Prefab")]
	private void ReplaceWithTwoWayPortalPrefab()
	{
	}
}
public class PlayMusicOnEnterPortal : MonoBehaviour, IPortalEnteredEvent
{
	public FMODEventAsset music;

	private bool triggered;

	public void OnAwakeLR(Portal portal)
	{
	}

	public void OnPortalEntered(ICanPortal obj)
	{
		if (!triggered)
		{
			LR.Inst.SetMusic(music);
			triggered = true;
		}
	}
}
public class PortalEvent_WorkshopC_Hint : MonoBehaviour, IPortalEnteredEvent
{
	public Trigger trigger;

	public float hintTime = 20f;

	public string hint;

	private HagletTrigger enteredTrigger = new HagletTrigger();

	private IHaglet hintRoutine;

	public void OnAwakeLR(Portal portal)
	{
		Haglet.Create(out hintRoutine, HintRoutine, null, startNow: true);
	}

	public void OnPortalEntered(ICanPortal obj)
	{
		enteredTrigger.Trigger();
	}

	private IEnumerator<Routine.Yield> HintRoutine()
	{
		yield return trigger.OnInsidePremet;
		yield return Wait.For.Seconds(hintTime) | enteredTrigger;
		if (!enteredTrigger.happening)
		{
			VOC.Inst.QueueVO(hint);
		}
	}
}
[ExecuteInEditMode]
public class MirrorParticle : MonoBehaviour
{
	private GrabObject parentGrabObj;

	private ParticleSystem rootPS;

	[SerializeField]
	private ParticleSystem trailPS;

	[SerializeField]
	private ParticleSystem meshPS;

	[SerializeField]
	private ParticleSystemRenderer meshPSRenderer;

	public void OnAwakeLR(GrabObject grabObject)
	{
		rootPS = GetComponent<ParticleSystem>();
		parentGrabObj = grabObject;
		base.transform.localPosition = Vector3X.zero;
	}

	public void OnUpdateLR(Portal targetPortal)
	{
		if ((bool)targetPortal && !rootPS.IsAlive(withChildren: true))
		{
			rootPS.Play();
		}
		UpdateParticleModules(targetPortal);
	}

	public void Stop()
	{
		rootPS.Stop();
	}

	private void UpdateParticleModules(Portal targetPortal)
	{
		PortalSettings inst = BaseSettings<PortalSettings>.Inst;
		Vector3 closestPointOnPortal = targetPortal.GetClosestPointOnPortal(base.transform.position);
		closestPointOnPortal.x = targetPortal.transform.position.x;
		float sqrMagnitude = (closestPointOnPortal - base.transform.position).sqrMagnitude;
		if (sqrMagnitude < inst.mirroCutoffDistance)
		{
			Stop();
		}
		base.transform.LookAt(closestPointOnPortal);
		float time = 1f - sqrMagnitude / inst.minDistanceToMirror;
		_ = trailPS.main.startSpeed.constant;
		ParticleSystem.EmissionModule emission = trailPS.emission;
		float t = inst.mpEmissionRateCurve.Evaluate(time);
		emission.rateOverTime = Mathf.Lerp(inst.mpMinParticleCount, inst.mpMaxParticleCount, t);
	}
}
[ExecuteInEditMode]
public class MirrorReflectionProbeThing : MonoBehaviour
{
	public ReflectionProbe probe;

	private MaterialPropertyBlock mpb;

	private MeshRenderer mr;

	private int _BBoxMin = Shader.PropertyToID("_BBoxMin");

	private int _BBoxMax = Shader.PropertyToID("_BBoxMax");

	private int _EnviCubeMapPos = Shader.PropertyToID("_EnviCubeMapPos");

	private void Update()
	{
		if ((bool)probe)
		{
			mr = GetComponent<MeshRenderer>();
			mpb = new MaterialPropertyBlock();
			Vector3 center = probe.center;
			Vector3 vector = probe.transform.TransformPoint(center);
			Vector3 min = probe.bounds.min;
			Vector3 max = probe.bounds.max;
			mpb.SetVector(_BBoxMin, min);
			mpb.SetVector(_BBoxMax, max);
			mpb.SetVector(_EnviCubeMapPos, vector);
			mr.SetPropertyBlock(mpb);
		}
	}
}
public class PortalAssignSelfToLink : MonoBehaviour, IAreaEvent
{
	[SerializeField]
	[HideInInspector]
	private IDObjectRef selfRef;

	[SerializeField]
	[HideInInspector]
	private Portal portal;

	private IHaglet routineOnAwakeLR;

	public void OnPrebuild()
	{
	}

	public void OnAwakeLR()
	{
		Haglet.Create(out routineOnAwakeLR, RoutineOnAwakeLR);
	}

	private IEnumerator<Routine.Yield> RoutineOnAwakeLR()
	{
		IDObjectRef.IsValid(selfRef);
		Portal link;
		while (true)
		{
			link = portal.Link;
			if (link != null)
			{
				break;
			}
			yield return Wait.For.LRUpdates(1);
		}
		link.SetLinkRef(selfRef);
	}

	void IAreaEvent.OnAreaEnter()
	{
		routineOnAwakeLR.Start(resetIfStarted: true);
	}

	void IAreaEvent.OnAreaExit()
	{
	}
}
public class PortalCameraModeController : MonoBehaviour, IRealtimeUpdate, IAwakeEvent
{
	public enum Behaviour
	{
		EnablePortal,
		DisablePortal
	}

	public Behaviour behaviour;

	public bool setToAutomaticWhenOutside = true;

	[ConditionalHide("setToAutomaticWhenOutside", true, true)]
	public bool setToOppositeWhenOutside;

	public PlayerAreaTrigger triggerArea;

	public Portal[] controlledPortals;

	private bool wasInside;

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		triggerArea.shouldUpdateWhilePausedAndInCutscene = true;
	}

	void IRealtimeUpdate.OnRealtimeUpdateLR()
	{
		bool isHeadInsideBool = triggerArea.IsHeadInsideBool;
		if (isHeadInsideBool)
		{
			PortalCameraMode cameraMode = ((behaviour == Behaviour.EnablePortal) ? PortalCameraMode.ManualOn : PortalCameraMode.ManualOff);
			Portal[] array = controlledPortals;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].cameraMode = cameraMode;
			}
		}
		else if (wasInside)
		{
			if (setToAutomaticWhenOutside)
			{
				Portal[] array = controlledPortals;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].cameraMode = PortalCameraMode.Automatic;
				}
			}
			else if (setToOppositeWhenOutside)
			{
				PortalCameraMode cameraMode2 = ((behaviour != 0) ? PortalCameraMode.ManualOn : PortalCameraMode.ManualOff);
				Portal[] array = controlledPortals;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].cameraMode = cameraMode2;
				}
			}
		}
		wasInside = isHeadInsideBool;
	}
}
public class PortalClosedIdlePS_STUB : MonoBehaviour
{
}
public class PortalExpansionPS_STUB : MonoBehaviour
{
}
public class PortalingAnimObject : MonoBehaviour, ICanPortal, IAwakeEvent
{
	[SerializeField]
	private Transform trackedXForm;

	private MRBase owner;

	private TransformState lastState;

	private Transform portaledXForm;

	private Renderer[] renderers;

	private KubrickAnimator kubrickAnimator;

	private ICanEnterPortal[] enterPortalListeners;

	private IOwnerChangeListener[] ownerChangeListeners;

	private IAreaEvent[] areaEvents;

	private ISceneUnloadEvent[] sceneUnloadEvents;

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		this.owner = owner;
		portaledXForm = base.transform;
		lastState = new TransformState(trackedXForm);
		renderers = GetComponentsInChildren<Renderer>(includeInactive: true);
		enterPortalListeners = GetComponentsInChildren<ICanEnterPortal>(includeInactive: true);
		ownerChangeListeners = GetComponentsInChildren<IOwnerChangeListener>();
		areaEvents = GetComponentsInChildren<IAreaEvent>(includeInactive: true);
		sceneUnloadEvents = GetComponentsInChildren<ISceneUnloadEvent>(includeInactive: true);
		kubrickAnimator = GetComponentInChildren<KubrickAnimator>();
	}

	public void OnLateUpdateLR()
	{
		Portal.PortalableEvaluateCrossingPortal(this);
		lastState.UpdateToLatestState();
	}

	bool ICanPortal.CanTeleport(Portal portal)
	{
		if (base.isActiveAndEnabled)
		{
			return portal.objectTeleportOnEnter;
		}
		return false;
	}

	TransformState ICanPortal.GetLastState()
	{
		return lastState;
	}

	MRBase ICanPortal.GetOwner()
	{
		return owner;
	}

	Vector3 ICanPortal.GetWorldPosition()
	{
		return trackedXForm.position;
	}

	bool ICanPortal.CanEnterPortal(Portal portal)
	{
		return true;
	}

	void ICanPortal.OnEnterPortal(Portal portal)
	{
		Portal.PortalTransform portalTransform = portal.CalculatePortalObjectTransform(portaledXForm.position, portaledXForm.rotation, default(Vector3));
		portaledXForm.position = portalTransform.position;
		portaledXForm.rotation = portalTransform.rotation;
		for (int i = 0; i < enterPortalListeners.Length; i++)
		{
			enterPortalListeners[i].OnEnterPortal(portal);
		}
	}

	public void SetOwner(MRBase newOwner)
	{
		if (owner != newOwner)
		{
			MRBase mRBase = owner;
			owner = newOwner;
			uint sceneMask = newOwner.sceneMask;
			Renderer[] array = renderers;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].renderingLayerMask = sceneMask;
			}
			MRBase.TransferObject(mRBase, newOwner, this);
			for (int j = 0; j < areaEvents.Length; j++)
			{
				MRBase.TransferObject(mRBase, newOwner, areaEvents[j]);
			}
			for (int k = 0; k < sceneUnloadEvents.Length; k++)
			{
				MRBase.TransferObject(mRBase, newOwner, sceneUnloadEvents[k]);
			}
			if ((bool)kubrickAnimator)
			{
				MRBase.TransferObject(mRBase, newOwner, kubrickAnimator);
			}
			for (int l = 0; l < ownerChangeListeners.Length; l++)
			{
				ownerChangeListeners[l].OnOwnerChange(mRBase, newOwner);
			}
		}
	}
}
public class PortalMachine : MonoBehaviour, IAwakeEvent, IUpdateEvent, IAreaEvent
{
	private MRBase owner;

	private LeverController leverController;

	private GameObject activeRoot;

	private GameObject inactiveRoot;

	public Portal portal;

	[SerializeField]
	private PlacementHelper batterySlot;

	public ChapterInfo chapterInfo;

	public ParticleSystem glowParticle;

	public ParticleSystem glowStaticParticle;

	public ParticleSystem machineSparksParticle;

	public ParticleSystem beamParticle;

	public ParticleSystem portalSparksParticle;

	[HideInInspector]
	public SceneInfo sceneToLoad;

	private UIContainer uIContainer;

	private UITextbox chapterNameUI;

	private UITextbox resetUI;

	private UITextbox completedPuzzleUI;

	private UITextbox optionalCompletedPuzzleUI;

	private UIImage displaySprite;

	private UIImage sunCompletionSprite;

	private UIImage moonCompletionSprite;

	private Animation shakeAnimation;

	[SerializeField]
	[Tooltip("Time until the first line of the VO has finished playing")]
	private float voDelay = 7f;

	public FMODEventAsset openPortalMusic;

	public FMODEventAsset openPortalSound;

	[SerializeField]
	private float resetHoldTime = 3f;

	private float currentResetTime;

	private float leverGrabAngle;

	private FixedRotatableObject lever;

	private VO_Sequencer sequencer;

	private Button resetButton;

	private int completedPuzzleCount;

	private HagletTrigger portalAlmostOpenTrigger = new HagletTrigger();

	[HideInInspector]
	private bool _hasPower;

	[Header("First Meeting Machine Only")]
	public bool lockedByPuzzles;

	[SerializeField]
	private GameObject[] puzzlePips;

	private IHaglet<object> machineShakeRoutine;

	private IHaglet<object> portalActivationRoutine;

	private IHaglet resetChapterRoutine;

	public bool HasPower
	{
		get
		{
			return _hasPower;
		}
		set
		{
			_hasPower = value;
			chapterNameUI.IsShown = value;
			completedPuzzleUI.IsShown = value;
			optionalCompletedPuzzleUI.IsShown = value;
			displaySprite.IsShown = !value;
			sunCompletionSprite.IsShown = value;
			moonCompletionSprite.IsShown = value;
			activeRoot.SetActive(value);
			inactiveRoot.SetActive(!value);
			bool flag = !(sequencer != null) || sequencer.IsComplete;
			resetButton.enabled = value && !lockedByPuzzles && flag && LR.Inst.saveDataGame.IsChapterMaskCompleteAll(SaveDataGame.Chapter.Princess);
		}
	}

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		this.owner = owner;
		lever = GetComponentInChildren<FixedRotatableObject>();
		lever.enabled = true;
		DeactivateMachine();
		portal.SetUnlockedState(unlocked: false);
		sequencer = GetComponent<VO_Sequencer>();
		resetButton = GetComponentInChildren<Button>();
		Haglet.Create(out portalActivationRoutine, (Routine.Func1<object>)PortalActivationRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out machineShakeRoutine, (Routine.Func1<object>)MachineShakeRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out resetChapterRoutine, ResetChapterRoutine);
		activeRoot = base.transform.FindDeepChild("ActiveRoot").gameObject;
		activeRoot.SetActive(_hasPower);
		inactiveRoot = base.transform.FindDeepChild("InactiveRoot").gameObject;
		inactiveRoot.SetActive(!_hasPower);
		uIContainer = GetComponentInChildren<UIContainer>();
		chapterNameUI = uIContainer.GetElement<UITextbox>("ChapterName");
		completedPuzzleUI = uIContainer.GetElement<UITextbox>("PuzzlesCompleted");
		optionalCompletedPuzzleUI = uIContainer.GetElement<UITextbox>("OptionalPuzzlesCompleted");
		resetUI = uIContainer.GetElement<UITextbox>("Reset");
		resetUI.Hide();
		displaySprite = uIContainer.GetElement<UIImage>("DisplayIcon");
		sunCompletionSprite = uIContainer.GetElement<UIImage>("SunCompletion");
		moonCompletionSprite = uIContainer.GetElement<UIImage>("MoonCompletion");
		shakeAnimation = GetComponentInChildren<Animation>();
		if (_hasPower && !lockedByPuzzles)
		{
			displaySprite.Hide();
		}
		else if (!_hasPower || lockedByPuzzles)
		{
			chapterNameUI.Hide();
			completedPuzzleUI.Hide();
			optionalCompletedPuzzleUI.Hide();
			sunCompletionSprite.Hide();
			moonCompletionSprite.Hide();
		}
		if ((bool)batterySlot)
		{
			displaySprite.spriteRenderer.sprite = BaseSettings<PortalSettings>.Inst.noBattery;
		}
		else
		{
			displaySprite.spriteRenderer.sprite = BaseSettings<PortalSettings>.Inst.noPower;
		}
	}

	void IUpdateEvent.OnUpdateLR()
	{
		float angle = lever.GetAngle();
		if (Mathf.Abs(angle - leverGrabAngle) > 35f)
		{
			float angularVelocity = lever.AngularVelocity;
			FAC.Inst.PlayOneShot(BaseSettings<PortalSettings>.Inst.handleMoveSFX.Value, base.transform.position).setParameterValue("Speed", angularVelocity);
			leverGrabAngle = angle;
		}
		if (!lever.enabled)
		{
			lever.enabled = !portalActivationRoutine.started && !portal.switchTargetPortalLink.started;
		}
	}

	public void AssignLeverController(LeverController controller)
	{
		leverController = controller;
	}

	void IAreaEvent.OnAreaEnter()
	{
		string lastLevelUIDInChapter = LR.Inst.saveDataGame.GetLastLevelUIDInChapter(chapterInfo.chapter);
		if (!string.IsNullOrEmpty(lastLevelUIDInChapter) && !LR.Inst.saveDataGame.IsChapterFinished(chapterInfo.chapter))
		{
			if (LR.Inst.saveDataGame.GetChapterVaultEnteredState(chapterInfo.chapter))
			{
				sceneToLoad = LR.Inst.GetSceneInfoWithSceneUIDName("bead");
			}
			else
			{
				sceneToLoad = LR.Inst.GetSceneInfoWithSceneUIDName(lastLevelUIDInChapter);
			}
		}
		else
		{
			sceneToLoad = chapterInfo.chapterScenes[0].Load();
		}
		GetCompletedPuzzleCount();
		bool flag = !(sequencer != null) || sequencer.IsComplete;
		resetButton.enabled = _hasPower && !lockedByPuzzles && flag && LR.Inst.saveDataGame.IsChapterMaskCompleteAll(SaveDataGame.Chapter.Princess);
		if (chapterInfo.chapter == SaveDataGame.Chapter.FirstMeeting)
		{
			UpdatePuzzlePips();
		}
		if (portal.GetPortalState() != 0 && lever.currentSnapIndex == 1)
		{
			DeactivateMachine();
			owner.RemoveConnectingScene(sceneToLoad);
		}
	}

	void IAreaEvent.OnAreaExit()
	{
		if (sceneToLoad.sceneUIDName == "bead")
		{
			DeactivateMachine();
		}
	}

	public void GetCompletedPuzzleCount()
	{
		int num = chapterInfo?.GetPuzzlesNum(PuzzleInfo.PuzzleType.MAIN) ?? 0;
		int number = chapterInfo?.GetPuzzlesNum(PuzzleInfo.PuzzleType.OPTIONAL) ?? 0;
		int num2 = chapterInfo?.GetCompletedPuzzlesNum(SaveDataGame.PuzzleSaveType.Scene, PuzzleInfo.PuzzleType.MAIN) ?? 0;
		int number2 = chapterInfo?.GetCompletedPuzzlesNum(SaveDataGame.PuzzleSaveType.Scene, PuzzleInfo.PuzzleType.OPTIONAL) ?? 0;
		completedPuzzleUI.Clear();
		completedPuzzleUI.Append(num2);
		completedPuzzleUI.Append("/");
		completedPuzzleUI.Append(num);
		completedPuzzleUI.Present();
		optionalCompletedPuzzleUI.Clear();
		optionalCompletedPuzzleUI.Append(number2);
		optionalCompletedPuzzleUI.Append("/");
		optionalCompletedPuzzleUI.Append(number);
		optionalCompletedPuzzleUI.Present();
		_ = (float)num2 / (float)num;
	}

	[Event(EventName = "Button Down")]
	public void OnResetButtonDown(object sender)
	{
		chapterNameUI.gameObject.SetActive(value: false);
		completedPuzzleUI.gameObject.SetActive(value: false);
		optionalCompletedPuzzleUI.gameObject.SetActive(value: false);
		sunCompletionSprite.gameObject.SetActive(value: false);
		moonCompletionSprite.gameObject.SetActive(value: false);
		resetUI.gameObject.SetActive(value: true);
		resetUI.SetText(GetResetText((int)resetHoldTime));
		FAC.Inst.PlayOneShot(BaseSettings<PortalSettings>.Inst.resetButtonSFX.Value, base.transform.position);
	}

	[Event(EventName = "Button Held")]
	public void OnResetButtonHeld(object sender)
	{
		float num = currentResetTime + Time.deltaTime;
		if (currentResetTime < resetHoldTime && num >= resetHoldTime)
		{
			ResetChapter();
			resetUI.SetText(GetResetText(0));
		}
		else if (currentResetTime > resetHoldTime)
		{
			if (currentResetTime > resetHoldTime + 1f)
			{
				resetButton.enabled = false;
			}
		}
		else if (num < resetHoldTime)
		{
			bool num2 = (int)(resetHoldTime - currentResetTime + 1f) != (int)(resetHoldTime - num + 1f);
			resetUI.SetText(GetResetText((int)(resetHoldTime - currentResetTime + 1f)));
			if (num2)
			{
				FAC.Inst.PlayOneShot(BaseSettings<PortalSettings>.Inst.resetCountSFX.Value, base.transform.position);
			}
		}
		currentResetTime = num;
	}

	private string GetResetText(int seconds)
	{
		return seconds switch
		{
			3 => Localisation.Retrieve("NEXUS_UI_portal_reset_progress_001"), 
			2 => Localisation.Retrieve("NEXUS_UI_portal_reset_progress_002"), 
			1 => Localisation.Retrieve("NEXUS_UI_portal_reset_progress_003"), 
			_ => Localisation.Retrieve("NEXUS_UI_portal_reset_complete"), 
		};
	}

	[Event(EventName = "Button Up")]
	public void OnResetButtonUp(object sender)
	{
		chapterNameUI.gameObject.SetActive(value: true);
		completedPuzzleUI.gameObject.SetActive(value: true);
		optionalCompletedPuzzleUI.gameObject.SetActive(value: true);
		sunCompletionSprite.gameObject.SetActive(value: true);
		moonCompletionSprite.gameObject.SetActive(value: true);
		resetUI.gameObject.SetActive(value: false);
		currentResetTime = 0f;
	}

	[Event(EventName = "Machine On")]
	public void ActivateMachine(object sender)
	{
		HasPower = true;
		GrabObject grabObject = batterySlot?.HeldGrabObject ?? null;
		if ((bool)grabObject && grabObject.canBeGrabbed)
		{
			grabObject.canBeGrabbed = false;
			batterySlot.Effects.ShowHideEffects(show: false);
			if (PlayerInventory.Inst.IsGrabObjectInInventory(grabObject))
			{
				FAC.Inst.PlayOneShot(BaseSettings<PortalSettings>.Inst.fitBatterySFX.Value, base.transform.position);
				PlayerInventory.Inst.MarkObjectForRemoval(grabObject);
				PlayerInventory.Inst.OpenInventory(InventoryEffectType.OPEN, _checkDistance: false);
				LR.Inst.Save();
			}
			FAC.Inst.PlayOneShot(BaseSettings<PortalSettings>.Inst.batteryOnSFX.Value, base.transform.position);
		}
	}

	public void DeactivateMachine()
	{
		if (lever.GetAngle() != lever.snapRotations[0])
		{
			lever.Animate(lever.snapRotations[0], 0.3f);
		}
	}

	[Event(EventName = "Lever Grab")]
	public void LeverGrab(object sender)
	{
		leverGrabAngle = lever.GetAngle();
	}

	[Event(EventName = "Lever Release")]
	public void LeverRelease(object sender)
	{
		leverGrabAngle = lever.GetAngle();
	}

	[Event(EventName = "Portal On")]
	public void ActivatePortal(object sender)
	{
		if (!portal.IsUnlocked)
		{
			float angularVelocity = lever.AngularVelocity;
			FAC.Inst.PlayOneShot(BaseSettings<PortalSettings>.Inst.handleStopSFX.Value, base.transform.position).setParameterValue("Velocity", angularVelocity);
		}
		CC.Inst.currentChapter = chapterInfo.chapter;
		LR.Inst.saveDataGame.lastChapter = chapterInfo.chapter;
		LR.Inst.Save();
		leverController.LoadScene(sceneToLoad, this);
		if (!portal.Link)
		{
			portal.switchTargetPortalLink.Start(sceneToLoad, resetIfStarted: true);
		}
		lever.enabled = false;
		if (LR.Inst.saveDataGame.activatedPortals.Contains(portal.id))
		{
			portal.SetUnlockedState(unlocked: true);
			glowStaticParticle.gameObject.SetActive(value: true);
		}
		else
		{
			portalActivationRoutine.Start(sender);
		}
	}

	[Event(EventName = "Portal Off")]
	public void DeactivatePortal(object sender)
	{
		if (portal.IsUnlocked)
		{
			float angularVelocity = lever.AngularVelocity;
			FAC.Inst.PlayOneShot(BaseSettings<PortalSettings>.Inst.handleStopSFX.Value, base.transform.position).setParameterValue("Velocity", angularVelocity);
			glowStaticParticle.gameObject.SetActive(value: false);
			portal.closeAndRestoreLink.Start(resetIfStarted: true);
			portal.SetUnlockedState(unlocked: false);
		}
	}

	private IEnumerator<Routine.Yield> MachineShakeRoutine(object sender)
	{
		yield return HAGIS.PlayAnim(shakeAnimation, "AN_PortalMachine_Start");
		HAGIS.PlayAnim(shakeAnimation, "AN_PortalMachine_Shake");
		yield return portalAlmostOpenTrigger;
		HAGIS.PlayAnim(shakeAnimation, "AN_PortalAnimation_End");
	}

	private IEnumerator<Routine.Yield> PortalActivationRoutine(object sender)
	{
		PortalSettings portalSettings = BaseSettings<PortalSettings>.Inst;
		FAC.Inst.PlayOneShot(portalSettings.leverLockSFX.Value, base.transform.position);
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		FMOD.Studio.EventInstance warmup = FAC.Inst.PlayOneShot(portalSettings.warmingUpSFX.Value, base.transform.position);
		glowParticle.gameObject.SetActive(value: true);
		machineSparksParticle.gameObject.SetActive(value: true);
		machineShakeRoutine.Start(sender);
		if (voDelay > 0f && (bool)sequencer && !sequencer.IsComplete)
		{
			sequencer.PlayNextVOSection(sender);
			do
			{
				yield return Wait.For.LRUpdates(1);
			}
			while (!(sequencer.voAsset.voiceSections[0].voiceLines[0].line == VOC.Inst.activeVOKey.value) && VOC.Inst.IsBusy() && !Routine.Skipping);
		}
		else if (voDelay > 0f && !sequencer)
		{
			do
			{
				yield return Wait.For.LRUpdates(1);
			}
			while (VOC.Inst.IsBusy() && !Routine.Skipping);
		}
		if ((bool)openPortalMusic)
		{
			LR.Inst.SetMusic(openPortalMusic);
		}
		FMOD.Studio.EventInstance portalOpenSound = FAC.Inst.PlayOneShot(openPortalSound, base.transform.position);
		Vector3 vector = beamParticle.transform.InverseTransformPoint(portal.transform.position);
		vector /= beamParticle.main.startLifetime.constant;
		ParticleSystem.VelocityOverLifetimeModule velocityOverLifetime = beamParticle.velocityOverLifetime;
		velocityOverLifetime.xMultiplier = vector.x;
		velocityOverLifetime.yMultiplier = vector.y;
		velocityOverLifetime.zMultiplier = vector.z;
		beamParticle.gameObject.SetActive(value: true);
		portalSparksParticle.transform.position = portal.transform.position;
		portalSparksParticle.transform.rotation = portal.transform.rotation;
		portalSparksParticle.gameObject.SetActive(value: true);
		portal.PlayUnlockAnimation(voDelay);
		float stopShakeAnimationDuration = shakeAnimation["AN_PortalAnimation_End"].length;
		bool portalAlmostOpen = false;
		float time = 0f;
		while (time < voDelay)
		{
			yield return Wait.For.LRUpdates(1);
			time += IC.DeltaTime;
			if (time > voDelay - stopShakeAnimationDuration && !portalAlmostOpen)
			{
				portalAlmostOpen = true;
				portalAlmostOpenTrigger.Trigger();
			}
			portalOpenSound.setParameterValue("PortalMachineOpeningPortal", Mathf.Clamp01(time / voDelay));
		}
		if ((bool)sequencer)
		{
			sequencer.SetComplete(sender);
			sequencer.SaveAsComplete(sender);
		}
		warmup.stop(STOP_MODE.ALLOWFADEOUT);
		portal.SetUnlockedState(unlocked: true, applyToLink: true, firstUnlock: true);
		lever.enabled = true;
		FAC.Inst.PlayOneShot(portalSettings.leverUnlockSFX.Value, base.transform.position);
		LR.Inst.saveDataGame.activatedPortals.Add(portal.id);
		machineSparksParticle.gameObject.SetActive(value: false);
		beamParticle.gameObject.SetActive(value: false);
		portalSparksParticle.gameObject.SetActive(value: false);
		glowParticle.gameObject.SetActive(value: false);
		glowStaticParticle.gameObject.SetActive(value: true);
	}

	public void ResetChapter()
	{
		if (!resetChapterRoutine.started)
		{
			FAC.Inst.PlayOneShot(BaseSettings<PortalSettings>.Inst.resettingSFX.Value, base.transform.position);
			resetChapterRoutine.Start();
		}
	}

	private IEnumerator<Routine.Yield> ResetChapterRoutine()
	{
		if (lever.GetAngle() != lever.snapRotations[0])
		{
			yield return lever.AnimateOnYield(lever.snapRotations[0], 0.3f);
		}
		lever.enabled = false;
		if (portal.Link != null && portal.Link.owner.returnPortal != null)
		{
			if (portal.closeAndRestoreLink.started)
			{
				yield return Wait.Until.Completed(portal.closeAndRestoreLink);
			}
			else
			{
				yield return portal.closeAndRestoreLink.Call();
			}
		}
		owner.ClearConnectedScenes();
		yield return LR.Inst.LoadAdjacentScenes();
		LR.Inst.saveDataGame.ResetChapter(chapterInfo);
		GetCompletedPuzzleCount();
		lever.enabled = true;
		sceneToLoad = chapterInfo.chapterScenes[0].Load();
		yield return LR.Inst.Save();
	}

	public void SetDisplay(Sprite newDisplay)
	{
		displaySprite.spriteRenderer.sprite = newDisplay;
	}

	public void UpdatePuzzlePips()
	{
		if (chapterInfo.chapter == SaveDataGame.Chapter.FirstMeeting)
		{
			bool flag = lockedByPuzzles;
			int chaptersComplete = (int)LR.Inst.saveDataGame.chaptersComplete;
			for (int i = 0; i < puzzlePips.Length; i++)
			{
				bool flag2 = ((chaptersComplete >> i + 1) & 1) == 1;
				puzzlePips[i].SetActive(flag2 && lockedByPuzzles);
				flag = flag && flag2;
			}
			if (flag)
			{
				chapterNameUI.Show();
				completedPuzzleUI.Show();
				optionalCompletedPuzzleUI.Show();
				sunCompletionSprite.Show();
				moonCompletionSprite.Show();
				displaySprite.Hide();
			}
		}
	}

	private void OnDestroy()
	{
		if (portalActivationRoutine != null)
		{
			portalActivationRoutine.Stop();
		}
		if (resetChapterRoutine != null)
		{
			resetChapterRoutine.Stop();
		}
	}
}
public class PortalOpenPS_STUB : MonoBehaviour
{
}
public class ReturnPortalStub : MonoBehaviour
{
	public bool singleUse;

	public bool lockOnClose;

	public Portal portal;
}
public interface ICanBeRasterized
{
	bool ShouldDraw(Rasterizer _drawingRasterizer);

	void GenerateRasterizerMesh();

	void GetRasterizerMesh(out RasterizerMesh rm);
}
[ExecuteInEditMode]
public class Rasterizable : MonoBehaviour, ICanBeRasterized, IOwnerChangeListener, PortalVariations.IUseVariantSet, IPrebuildEvent, IPlacementEvent
{
	private PortalVariations.VariantSet? portalVariantSet;

	private Rasterizer parentRasterizer;

	[SerializeField]
	[HideInInspector]
	private Mesh mesh;

	[SerializeField]
	[HideInInspector]
	private SkinnedMeshRenderer skinnedMeshRenderer;

	private RasterizerMesh rMesh;

	private bool meshValid;

	private List<Vector3> skinnedMeshVerts;

	private bool isHeldByPlacementHelper;

	private bool usesSMR;

	public TransformData xFormData;

	private Renderer rendererComp;

	public void SetPortalVariant(PortalVariations portalVariation)
	{
	}

	public void OnAwakeLR()
	{
		rendererComp = GetComponent<Renderer>();
		parentRasterizer = GetComponentInParent<Rasterizer>();
		parentRasterizer = (parentRasterizer ? parentRasterizer : null);
		if (!rendererComp)
		{
			base.enabled = false;
		}
		xFormData = new TransformData(base.transform);
	}

	bool ICanBeRasterized.ShouldDraw(Rasterizer _drawingRasterizer)
	{
		if (meshValid && base.isActiveAndEnabled && rendererComp.enabled && ((object)parentRasterizer == null || !isHeldByPlacementHelper) && (object)parentRasterizer != _drawingRasterizer)
		{
			if (portalVariantSet.HasValue)
			{
				return portalVariantSet.Value == _drawingRasterizer.PortalVariantSet;
			}
			return true;
		}
		return false;
	}

	void ICanBeRasterized.GenerateRasterizerMesh()
	{
		if (mesh == null)
		{
			if ((bool)skinnedMeshRenderer)
			{
				mesh = new Mesh();
				skinnedMeshRenderer.BakeMesh(mesh);
				skinnedMeshVerts = new List<Vector3>(mesh.vertexCount);
			}
			else
			{
				SerializeMesh();
				if (mesh == null)
				{
					return;
				}
			}
		}
		if (mesh.isReadable)
		{
			meshValid = true;
			rMesh = new RasterizerMesh(this, mesh, requiresUVs: false);
		}
	}

	void ICanBeRasterized.GetRasterizerMesh(out RasterizerMesh rm)
	{
		rMesh.worldMatrix = xFormData.xform.localToWorldMatrix;
		if (usesSMR && (bool)skinnedMeshRenderer)
		{
			skinnedMeshRenderer.BakeMesh(mesh);
			mesh.GetVertices(skinnedMeshVerts);
			Vector4[] vertices = rMesh.vertices;
			for (int i = 0; i < vertices.Length; i++)
			{
				Vector3 vector = skinnedMeshVerts[i];
				vertices[i].x = vector.x;
				vertices[i].y = vector.y;
				vertices[i].z = vector.z;
				vertices[i].w = 1f;
			}
		}
		rm = rMesh;
	}

	public void OnOwnerChange(MRBase _oldOwner, MRBase _newOwner)
	{
		MRBase.TransferObject(_oldOwner, _newOwner, this);
	}

	void PortalVariations.IUseVariantSet.OnVariantSetChanged(PortalVariations.VariantSet newSet)
	{
		portalVariantSet = newSet;
	}

	private void SerializeMesh()
	{
		MeshFilter component = GetComponent<MeshFilter>();
		if ((bool)component)
		{
			mesh = component.sharedMesh;
			return;
		}
		skinnedMeshRenderer = GetComponent<SkinnedMeshRenderer>();
		usesSMR = true;
		mesh = null;
	}

	void IPrebuildEvent.OnPrebuildRoot(bool isPrefab)
	{
	}

	void IPlacementEvent.OnPlacementGrabbed()
	{
		isHeldByPlacementHelper = true;
	}

	void IPlacementEvent.OnPlacementUngrabbed()
	{
		isHeldByPlacementHelper = false;
	}
}
internal struct Color24
{
	public byte r;

	public byte g;

	public byte b;
}
public class RasterizationController
{
	private struct MaskData
	{
		public v2i size;

		public Texture2D maskTexture;

		public Texture2D matchTexture;

		public NativeArray<byte> maskPixels;

		public NativeArray<byte> matchPixels;

		public readonly List<Rasterizer> connectedRasterizers;

		public bool Valid => maskTexture != null;

		public unsafe MaskData(Texture2D textureAsset, List<Rasterizer> connected = null)
		{
			connectedRasterizers = connected ?? new List<Rasterizer>();
			size = new v2i(textureAsset.width, textureAsset.height);
			maskTexture = textureAsset;
			matchTexture = new Texture2D(size.x, size.y, TextureFormat.Alpha8, mipChain: false)
			{
				filterMode = FilterMode.Bilinear
			};
			matchTexture.Apply();
			maskPixels = new NativeArray<byte>(size.x * size.y, Allocator.Persistent);
			matchPixels = new NativeArray<byte>(size.x * size.y, Allocator.Persistent);
			if (maskTexture.format == TextureFormat.RGBA32)
			{
				Color32* ptr = (Color32*)maskTexture.GetRawTextureData<Color32>().GetUnsafePtr();
				byte* ptr2 = (byte*)maskPixels.GetUnsafePtr();
				for (int i = 0; i < size.x * size.y; i++)
				{
					*ptr2 = ptr->r;
					ptr2++;
					ptr++;
				}
			}
			else if (maskTexture.format == TextureFormat.RGB24)
			{
				Color24* ptr3 = (Color24*)maskTexture.GetRawTextureData<Color24>().GetUnsafePtr();
				byte* ptr4 = (byte*)maskPixels.GetUnsafePtr();
				for (int j = 0; j < size.x * size.y; j++)
				{
					*ptr4 = ptr3->r;
					ptr4++;
					ptr3++;
				}
			}
		}

		public void UpdateTexture()
		{
			if (matchTexture != null)
			{
				matchTexture.LoadRawTextureData(matchPixels);
				matchTexture.Apply(updateMipmaps: true);
			}
		}

		public void ClearMainThreadData()
		{
			maskTexture = null;
			matchTexture = null;
			maskPixels.Dispose();
			matchPixels.Dispose();
		}
	}

	private struct NativeMeshHandles
	{
		public GCHandle vertices;

		public GCHandle uvs;

		public GCHandle indices;

		public void Free()
		{
			vertices.Free();
			uvs.Free();
			indices.Free();
		}
	}

	private struct RasterizerJob
	{
		public int[] meshIndicies;

		public int meshCount;

		public int[] lightIndicies;

		public int lightCount;

		public RasterizerMeshResult[] meshResults;

		public int meshResultCount;

		public RasterizerMesh clipMesh;

		public RasterizerJob(int maxMeshes, int maxLights)
		{
			meshIndicies = new int[maxMeshes];
			lightIndicies = new int[maxLights];
			meshResults = new RasterizerMeshResult[maxMeshes];
			meshCount = 0;
			lightCount = 0;
			meshResultCount = 0;
			clipMesh = default(RasterizerMesh);
		}

		public void AddLight(int lIdx)
		{
			lightIndicies[lightCount] = lIdx;
			lightCount++;
		}

		public void AddMesh(int mIdx)
		{
			meshIndicies[meshCount] = mIdx;
			meshCount++;
		}

		public void Clear()
		{
			meshCount = 0;
			lightCount = 0;
			meshResultCount = 0;
		}
	}

	private struct TextureJob
	{
		public int maskIndex;

		public int[] rasterizerJobIndicies;

		public int rasterizerJobCount;

		public int strokeTolerance;

		public int lightsRasterized;

		public float match;

		public void AddRasterizerJob(int rIdx, int stroke)
		{
			rasterizerJobIndicies[rasterizerJobCount] = rIdx;
			rasterizerJobCount++;
			strokeTolerance = Mathf.Max(strokeTolerance, stroke);
		}

		public void Clear()
		{
			maskIndex = -1;
			rasterizerJobCount = 0;
			strokeTolerance = 0;
			match = 0f;
			lightsRasterized = 0;
		}
	}

	private const int MAX_MESHES = 256;

	private const int MAX_LIGHTS = 16;

	private const int MAX_RASTERIZERS = 16;

	private const int MAX_TEXTURES = 16;

	private const int MAX_RESOLUTION = 512;

	private static RasterizationController _inst;

	public ConstArray<GrabObject> rasterizedGrabObjects = new ConstArray<GrabObject>(64u);

	private ConstArray<GrabObject> tmpRasterizedGrabObjects = new ConstArray<GrabObject>(64u);

	private readonly RasterizerMesh[] meshes;

	private int meshCount;

	private readonly RasterizerLightNative[] nativeLights;

	private int lightCount;

	private readonly RasterizerJob[] rasterizerJobs;

	private int rasterizerJobCount;

	private readonly TextureJob[] textureJobs;

	private int textureJobCount;

	private readonly Dictionary<Texture2D, int> maskDataIndexByTexture = new Dictionary<Texture2D, int>();

	private readonly ConstArray<int> maskDataToDealloc;

	private readonly MaskData[] maskData;

	private readonly int[] maskDataIndicies;

	private int maskDataCount;

	private RasterizerSettings settings;

	private int texturesUpdated;

	private float timeSinceUpdate;

	private readonly Thread thread;

	private readonly AutoResetEvent wakeThread;

	private readonly ManualResetEvent threadPaused;

	private volatile bool killThread;

	private volatile bool pauseThread;

	private volatile bool threadBusy;

	private volatile int textureJobsComplete;

	private readonly CustomSampler jobPreparePCS = CustomSampler.Create("Job Prepare");

	private readonly CustomSampler jobFreePCS = CustomSampler.Create("Job Free");

	private readonly CustomSampler textureJobPCS = CustomSampler.Create("Texture Job");

	private readonly CustomSampler rasterizerJobPCS = CustomSampler.Create("Rasterizer Job");

	private readonly CustomSampler rasterizePCS = CustomSampler.Create("Rasterize");

	private readonly CustomSampler rasterizerJobFreePCS = CustomSampler.Create("Rasterizer Job Free");

	private readonly CustomSampler edgeDetectionPCS = CustomSampler.Create("Edge Detection");

	private readonly CustomSampler tolerancePCS = CustomSampler.Create("Edge Tolerance");

	private readonly CustomSampler comparisonPCS = CustomSampler.Create("Comparison");

	private readonly CustomSampler blurPCS = CustomSampler.Create("Blur");

	private readonly CustomSampler copyPCS = CustomSampler.Create("Copy To Target");

	public static RasterizationController Inst => _inst ?? (_inst = new RasterizationController());

	private static void PrepareMeshForNative(ref RasterizerMesh mesh, out RasterizerMeshNative nativeMesh, out NativeMeshHandles handles)
	{
		handles.vertices = GCHandle.Alloc(mesh.vertices, GCHandleType.Pinned);
		handles.uvs = GCHandle.Alloc(mesh.uvs, GCHandleType.Pinned);
		handles.indices = GCHandle.Alloc(mesh.indices, GCHandleType.Pinned);
		nativeMesh.vertices = handles.vertices.AddrOfPinnedObject();
		nativeMesh.uvs = handles.uvs.AddrOfPinnedObject();
		nativeMesh.indices = handles.indices.AddrOfPinnedObject();
		nativeMesh.indicesNum = mesh.indices.Length;
		nativeMesh.worldMatrix = mesh.worldMatrix;
		nativeMesh.localBounds = mesh.localBounds;
	}

	public RasterizationController()
	{
		thread = new Thread(RasterizationThread);
		thread.Priority = System.Threading.ThreadPriority.Lowest;
		thread.IsBackground = true;
		wakeThread = new AutoResetEvent(initialState: false);
		threadPaused = new ManualResetEvent(initialState: true);
		meshes = new RasterizerMesh[256];
		nativeLights = new RasterizerLightNative[16];
		rasterizerJobs = new RasterizerJob[16];
		textureJobs = new TextureJob[16];
		maskData = new MaskData[256];
		maskDataIndicies = new int[maskData.Length];
		maskDataToDealloc = new ConstArray<int>((uint)maskData.Length);
		for (int i = 0; i < 16; i++)
		{
			rasterizerJobs[i] = new RasterizerJob(256, 16);
		}
		for (int j = 0; j < 16; j++)
		{
			textureJobs[j].rasterizerJobIndicies = new int[16];
		}
		for (int k = 0; k < maskData.Length; k++)
		{
			maskDataIndicies[k] = k;
		}
	}

	public void RegisterRasterizer(Rasterizer rasterizer)
	{
		Texture2D maskTexture = rasterizer.MaskTexture;
		if (maskTexture == null)
		{
			return;
		}
		if (!maskDataIndexByTexture.TryGetValue(maskTexture, out var value))
		{
			lock (maskDataIndicies)
			{
				value = maskDataIndicies[maskDataCount];
				maskDataCount++;
				maskData[value] = new MaskData(maskTexture);
				maskDataIndexByTexture.Add(maskTexture, value);
			}
		}
		maskData[value].connectedRasterizers.Add(rasterizer);
	}

	public void DeregisterRasterizer(Rasterizer rasterizer)
	{
		Texture2D maskTexture = rasterizer.MaskTexture;
		if (maskTexture == null)
		{
			return;
		}
		if (!maskDataIndexByTexture.TryGetValue(maskTexture, out var value))
		{
			UnityEngine.Debug.LogError("Rasterizer $" + rasterizer.name + " was deregistered but its mask texture was not found.", maskTexture);
			return;
		}
		maskData[value].connectedRasterizers.Remove(rasterizer);
		if (maskData[value].connectedRasterizers.Count != 0)
		{
			return;
		}
		maskDataIndexByTexture.Remove(maskTexture);
		lock (maskDataIndicies)
		{
			maskData[value].ClearMainThreadData();
			maskDataToDealloc.Add(value);
		}
	}

	public void UpdateRateLimited(MRBase owner)
	{
		timeSinceUpdate += IC.DeltaTimeUnclamped;
		if (settings != null && UpdateTexturesAndNotify())
		{
			float num = (float)((LR.GetPlatform() == LR.NexusPlatform.QUEST) ? settings.rasterizerPassTimeMSAndroid : settings.rasterizerPassTimeMSRift) * 0.001f;
			if (timeSinceUpdate >= num && UpdateRasterizationJobs(owner.lightSources, owner.rasterizables, owner.rasterizers))
			{
				timeSinceUpdate = ((num > 0f) ? (timeSinceUpdate % num) : 0f);
			}
		}
	}

	public bool UpdateRasterizationJobs(ConstArray<LightSource> inputLights, ConstArray<ICanBeRasterized> inputRasterizables, ConstArray<Rasterizer> inputRasterizers)
	{
		bool flag = false;
		lock (thread)
		{
			if (!threadBusy)
			{
				flag = true;
				UpdateLightsAndMeshes(inputLights, inputRasterizables);
				rasterizerJobCount = 0;
				textureJobCount = 0;
				textureJobsComplete = 0;
				texturesUpdated = 0;
				int num = Mathf.Min(inputRasterizers.sLength, 16);
				for (int i = 0; i < num; i++)
				{
					Rasterizer rasterizer = inputRasterizers[i];
					Texture2D maskTexture = rasterizer.MaskTexture;
					if (!rasterizer.isActiveAndEnabled || !maskTexture)
					{
						continue;
					}
					int num2 = rasterizerJobCount;
					RasterizerJob rasterizerJob = rasterizerJobs[num2];
					rasterizerJob.Clear();
					rasterizer.GetClipMesh(out rasterizerJob.clipMesh);
					int j;
					for (j = 0; j < textureJobCount && !(maskData[textureJobs[j].maskIndex].maskTexture == maskTexture); j++)
					{
					}
					if (j == textureJobCount)
					{
						textureJobs[textureJobCount].Clear();
						if (!maskDataIndexByTexture.TryGetValue(maskTexture, out textureJobs[textureJobCount].maskIndex))
						{
							UnityEngine.Debug.LogError($"Skipping {rasterizer} as its texture data has not been initialized.", rasterizer);
							continue;
						}
						textureJobCount++;
					}
					textureJobs[j].AddRasterizerJob(num2, rasterizer.strokeTolerance);
					AddLightsAndMeshesToRasterizerJob(rasterizer, inputLights, inputRasterizables, ref rasterizerJob);
					rasterizerJobs[num2] = rasterizerJob;
					rasterizerJobCount++;
				}
				for (int k = rasterizerJobCount; k < rasterizerJobs.Length; k++)
				{
					rasterizerJobs[k].Clear();
					rasterizerJobs[k].clipMesh = default(RasterizerMesh);
				}
				if (meshCount < meshes.Length)
				{
					Array.Clear(meshes, meshCount, meshes.Length - meshCount);
				}
			}
		}
		if (flag)
		{
			wakeThread.Set();
		}
		return flag;
	}

	public bool UpdateTexturesAndNotify()
	{
		int num = textureJobsComplete;
		for (int i = texturesUpdated; i < num; i++)
		{
			TextureJob textureJob = textureJobs[i];
			MaskData maskData = this.maskData[textureJob.maskIndex];
			if (!maskData.Valid)
			{
				continue;
			}
			maskData.UpdateTexture();
			foreach (Rasterizer connectedRasterizer in maskData.connectedRasterizers)
			{
				connectedRasterizer.UpdateFeedback(textureJob.match, maskData.matchTexture);
			}
			for (int j = 0; j < textureJob.rasterizerJobCount; j++)
			{
				RasterizerJob rasterizerJob = rasterizerJobs[textureJob.rasterizerJobIndicies[j]];
				for (int k = 0; k < rasterizerJob.meshResultCount; k++)
				{
					Rasterizable rasterizable = meshes[rasterizerJob.meshIndicies[rasterizerJob.meshResults[k].index]].rasterizable;
					if ((bool)rasterizable)
					{
						GrabObject componentInParent = rasterizable.GetComponentInParent<GrabObject>();
						if ((bool)componentInParent && !tmpRasterizedGrabObjects.Contains(componentInParent))
						{
							tmpRasterizedGrabObjects.Add(componentInParent);
						}
					}
				}
			}
		}
		bool flag = texturesUpdated >= textureJobCount;
		bool num2 = num >= textureJobCount;
		texturesUpdated = num;
		if (num2 && !flag)
		{
			Misc.Swap(ref tmpRasterizedGrabObjects, ref rasterizedGrabObjects);
			tmpRasterizedGrabObjects.ClearToDefault();
		}
		return num2;
	}

	public void PauseThread()
	{
		pauseThread = true;
		wakeThread.Set();
		if (!threadPaused.WaitOne(1000))
		{
			UnityEngine.Debug.LogError("RasterizationController thread did not pause after 1000ms.");
		}
	}

	public void ResumeThread()
	{
		pauseThread = false;
		wakeThread.Set();
	}

	public void StartThread()
	{
		settings = BaseSettings<RasterizerSettings>.Inst;
		thread.Start();
	}

	public void StopThread()
	{
		killThread = true;
		wakeThread.Set();
		if (!thread.Join(1000))
		{
			thread.Abort();
		}
	}

	private void UpdateLightsAndMeshes(ConstArray<LightSource> inputLights, ConstArray<ICanBeRasterized> inputRasterizables)
	{
		LightSource[] data = inputLights._data;
		int sLength = inputLights.sLength;
		ICanBeRasterized[] data2 = inputRasterizables._data;
		int sLength2 = inputRasterizables.sLength;
		lightCount = ((sLength < 16) ? sLength : 16);
		meshCount = ((sLength2 < 256) ? sLength2 : 256);
		for (int i = 0; i < lightCount; i++)
		{
			data[i].GetRasterizerLight(out nativeLights[i]);
		}
		for (int j = 0; j < meshCount; j++)
		{
			data2[j].GetRasterizerMesh(out meshes[j]);
		}
	}

	private void AddLightsAndMeshesToRasterizerJob(Rasterizer inputRasterizer, ConstArray<LightSource> inputLights, ConstArray<ICanBeRasterized> inputRasterizables, ref RasterizerJob rasterizerJob)
	{
		LightSource[] data = inputLights._data;
		ICanBeRasterized[] data2 = inputRasterizables._data;
		for (int i = 0; i < lightCount; i++)
		{
			if (inputRasterizer.LightRasterizable(data[i]))
			{
				rasterizerJob.AddLight(i);
			}
		}
		for (int j = 0; j < meshCount; j++)
		{
			if (data2[j].ShouldDraw(inputRasterizer))
			{
				rasterizerJob.AddMesh(j);
			}
		}
	}

	private void CollectNativeLightsAndMeshes(ref RasterizerJob rasterizerJob, RasterizerMeshNative[] nativeMeshesOut, NativeMeshHandles[] nativeMeshHandlesOut, RasterizerLightNative[] nativeLightsOut)
	{
		for (int i = 0; i < rasterizerJob.meshCount; i++)
		{
			PrepareMeshForNative(ref meshes[rasterizerJob.meshIndicies[i]], out nativeMeshesOut[i], out nativeMeshHandlesOut[i]);
		}
		for (int j = 0; j < rasterizerJob.lightCount; j++)
		{
			nativeLightsOut[j] = nativeLights[rasterizerJob.lightIndicies[j]];
		}
	}

	private unsafe void RasterizationThread()
	{
		try
		{
			RasterizerMeshNative[] array = new RasterizerMeshNative[256];
			NativeMeshHandles[] array2 = new NativeMeshHandles[256];
			RasterizerLightNative[] array3 = new RasterizerLightNative[16];
			NativeArray<byte> nativeArray = new NativeArray<byte>(262144, Allocator.Persistent);
			float[] value = new float[262144];
			while (true)
			{
				lock (thread)
				{
					threadBusy = false;
				}
				wakeThread.WaitOne(100);
				lock (thread)
				{
					if (pauseThread)
					{
						threadPaused.Set();
					}
					else
					{
						threadPaused.Reset();
					}
					if (killThread)
					{
						break;
					}
					if (textureJobCount <= textureJobsComplete)
					{
						continue;
					}
					threadBusy = true;
					goto IL_00e4;
				}
				IL_00e4:
				GCHandle gCHandle = GCHandle.Alloc(array, GCHandleType.Pinned);
				GCHandle gCHandle2 = GCHandle.Alloc(array3, GCHandleType.Pinned);
				GCHandle gCHandle3 = GCHandle.Alloc(value, GCHandleType.Pinned);
				for (int i = 0; i < textureJobCount; i++)
				{
					TextureJob textureJob = textureJobs[i];
					MaskData maskData = this.maskData[textureJob.maskIndex];
					IntPtr a = new IntPtr(nativeArray.GetUnsafePtr());
					IntPtr b = new IntPtr(maskData.matchPixels.GetUnsafePtr());
					IntPtr maskTexture = new IntPtr(maskData.maskPixels.GetUnsafePtr());
					IntPtr intPtr = new IntPtr(maskData.matchPixels.GetUnsafePtr());
					UnsafeUtility.MemClear(maskData.matchPixels.GetUnsafePtr(), maskData.matchPixels.Length);
					UnsafeUtility.MemClear(nativeArray.GetUnsafePtr(), nativeArray.Length);
					RasterizeResult rasterizeResult = default(RasterizeResult);
					for (int j = 0; j < textureJob.rasterizerJobCount; j++)
					{
						RasterizerJob rasterizerJob = rasterizerJobs[textureJob.rasterizerJobIndicies[j]];
						PrepareMeshForNative(ref rasterizerJob.clipMesh, out var nativeMesh, out var handles);
						CollectNativeLightsAndMeshes(ref rasterizerJob, array, array2, array3);
						GCHandle gCHandle4 = GCHandle.Alloc(rasterizerJob.meshResults, GCHandleType.Pinned);
						RasterizeResult rasterizeResult2 = RasterizerNative.Rasterize(b, gCHandle.AddrOfPinnedObject(), rasterizerJob.meshCount, gCHandle2.AddrOfPinnedObject(), rasterizerJob.lightCount, gCHandle3.AddrOfPinnedObject(), 0f, nativeMesh, maskData.size, gCHandle4.AddrOfPinnedObject());
						rasterizerJob.meshResultCount = rasterizeResult2.meshResultCount;
						rasterizerJobs[textureJob.rasterizerJobIndicies[j]] = rasterizerJob;
						rasterizeResult.triCountRasterized += rasterizeResult2.triCountRasterized;
						rasterizeResult.triCountTotal += rasterizeResult2.triCountTotal;
						rasterizeResult.pixelCount += rasterizeResult2.pixelCount;
						rasterizeResult.LightCountRasterized += rasterizeResult2.LightCountRasterized;
						rasterizeResult.LightCountTotal += rasterizeResult2.LightCountTotal;
						rasterizeResult.meshResultCount += rasterizeResult2.meshResultCount;
						gCHandle4.Free();
						handles.Free();
						for (int k = 0; k < rasterizerJob.meshCount; k++)
						{
							array2[k].Free();
						}
					}
					if (rasterizeResult.meshResultCount > 0)
					{
						if (settings.EdgeDetection)
						{
							Misc.Swap(ref a, ref b);
							RasterizerNative.Sobel3x3(b, a, maskData.size);
						}
						if (settings.Tolerance)
						{
							Misc.Swap(ref a, ref b);
							RasterizerNative.StrokeSimple(b, a, maskData.size, textureJob.strokeTolerance);
						}
						if (settings.Comparison)
						{
							Misc.Swap(ref a, ref b);
							textureJobs[i].match = RasterizerNative.Compare(b, a, maskTexture, maskData.size, 4);
						}
						if (settings.Blur)
						{
							Misc.Swap(ref a, ref b);
							RasterizerNative.GaussianBlur(b, a, maskData.size, 4, 5f, 1f);
						}
					}
					if (b != intPtr)
					{
						Misc.Swap(ref a, ref b);
						Buffer.MemoryCopy((void*)a, (void*)b, maskData.matchPixels.Length, maskData.matchPixels.Length);
					}
					textureJobsComplete++;
				}
				gCHandle.Free();
				gCHandle2.Free();
				gCHandle3.Free();
				lock (maskDataIndicies)
				{
					for (uint num = 0u; num < maskDataToDealloc.Length; num++)
					{
						int num2 = maskDataToDealloc[num];
						this.maskData[num2] = default(MaskData);
						maskDataCount--;
						maskDataIndicies[maskDataCount] = num2;
					}
					maskDataToDealloc.Clear();
				}
			}
			nativeArray.Dispose();
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
		finally
		{
			Profiler.EndThreadProfiling();
		}
	}
}
[ExecuteInEditMode]
public class Rasterizer : ObeliskPuzzleObject, IAreaEvent, PortalVariations.IUseVariantSet, IOwnerChangeListener
{
	[Serializable]
	public struct RasterizerTextures
	{
		public Texture2D maskTexture;

		public RasterizerSnapData snapData;
	}

	public const int MAX_STROKE = 6;

	public const int MIN_STROKE = 1;

	private static readonly int _SuccessTex = Shader.PropertyToID("_SuccessTex");

	private static readonly int _MaskTex = Shader.PropertyToID("_MaskTex");

	private static readonly int _NoiseTex = Shader.PropertyToID("_NoiseTex");

	private static readonly int _ColorLines = Shader.PropertyToID("_ColorLines");

	private static readonly int _ColorLinesIncomplete = Shader.PropertyToID("_ColorLinesIncomplete");

	private static readonly int _ColorLinesIncompleteUnderShadow = Shader.PropertyToID("_ColorLinesIncompleteUnderShadow");

	private static readonly int _ColourCompleted = Shader.PropertyToID("_ColourCompleted");

	private static readonly int _ColourFlash = Shader.PropertyToID("_ColourFlash");

	[Range(1f, 6f)]
	public int strokeTolerance = 2;

	public bool playSound = true;

	[ConditionalHide("playSound")]
	public FMODEventAsset soundSolve3DOverride;

	[ConditionalHide("playSound")]
	public FMODEventAsset soundSolve2DOverride;

	[SerializeField]
	private Transform maskXForm;

	[SerializeField]
	private Mesh mesh;

	[SerializeField]
	private ParticleSystem progressPS;

	[SerializeField]
	[ReadOnlyAtRuntime]
	private RasterizerTextures textures;

	[NonSerialized]
	public bool editMode;

	[NonSerialized]
	public RasterizerCanvas canvas;

	private RasterizerMesh clipMesh;

	private MeshFilter mf;

	private MeshRenderer mr;

	private float minParticleRoT = 5000f;

	private float maxParticleRoT = 10000f;

	private RasterizerGroup groupRoot;

	private Material[] canvasMaterials;

	private PortalVariations.VariantSet _PortalVariantSet;

	[ReadOnly]
	public PuzzleInfo.PuzzleType puzzleType;

	private IHaglet intializeRasterizerRoutine;

	private FMOD.Studio.EventInstance sfxFeedback;

	private Transform MaskXForm
	{
		get
		{
			if (!maskXForm)
			{
				return base.transform;
			}
			return maskXForm;
		}
	}

	public PortalVariations.VariantSet PortalVariantSet => _PortalVariantSet;

	public bool IsComplete
	{
		get
		{
			PuzzleInfo puzzleInfo = (groupRoot ? ((ObeliskPuzzleObject)groupRoot) : ((ObeliskPuzzleObject)this)).puzzleInfo;
			if ((bool)puzzleInfo)
			{
				return puzzleInfo.IsComplete(SaveDataGame.PuzzleSaveType.Scene);
			}
			return false;
		}
	}

	public Texture2D MaskTexture
	{
		get
		{
			return textures.maskTexture;
		}
		set
		{
			if (value != textures.maskTexture)
			{
				RasterizationController inst = RasterizationController.Inst;
				inst.DeregisterRasterizer(this);
				textures.maskTexture = value;
				mr.sharedMaterial.SetTexture(_MaskTex, textures.maskTexture);
				inst.RegisterRasterizer(this);
			}
		}
	}

	public RasterizerSnapData SnapData
	{
		get
		{
			return textures.snapData;
		}
		set
		{
			textures.snapData = value;
		}
	}

	public override void OnAreaEnter()
	{
		base.OnAreaEnter();
		base.enabled = true;
	}

	public override void OnAreaExit()
	{
		base.OnAreaExit();
		base.enabled = false;
	}

	public override void OnOwnerChange(MRBase _oldOwner, MRBase _newOwner)
	{
		base.OnOwnerChange(_oldOwner, _newOwner);
		MRBase.TransferObject(_oldOwner, _newOwner, this);
	}

	public override void OnAwakeLR(MRBase owner)
	{
		RasterizationController.Inst.RegisterRasterizer(this);
		base.OnAwakeLR(owner);
		Haglet.Create(out intializeRasterizerRoutine, IntializeRasterizerRoutine);
	}

	public Wait IntializeRasterizer()
	{
		return intializeRasterizerRoutine.Start();
	}

	private IEnumerator<Routine.Yield> IntializeRasterizerRoutine()
	{
		ApplyMaskTextureToParticleSystem();
		yield return Wait.For.LRUpdates(1);
		canvas = GetComponentInChildren<RasterizerCanvas>();
		if ((bool)canvas)
		{
			yield return canvas.OnAwakeLR(this);
		}
		yield return Wait.For.LRUpdates(1);
		if (textures.maskTexture == null)
		{
			editMode = true;
		}
		clipMesh = new RasterizerMesh(null, mesh, requiresUVs: true);
		yield return Wait.For.LRUpdates(1);
		GameObject gameObject = MaskXForm.gameObject;
		mf = gameObject.GetComponent<MeshFilter>();
		if (mf == null)
		{
			mf = gameObject.AddComponent<MeshFilter>();
		}
		mr = gameObject.GetComponent<MeshRenderer>();
		if (mr == null)
		{
			mr = gameObject.AddComponent<MeshRenderer>();
		}
		mesh.RecalculateBounds();
		mf.sharedMesh = mesh;
		mr.sharedMaterial = new Material(Shader.Find("NEXUS/Rasterizer"));
		mr.sharedMaterial.SetTexture(_MaskTex, textures.maskTexture);
		mr.sharedMaterial.SetTexture(_NoiseTex, BaseSettings<RasterizerSettings>.Inst.noiseTexture);
		mr.sharedMaterial.EnableKeyword("RUNTIME");
		mr.sharedMaterial.EnableKeyword("SHOW_NOISE");
		mr.renderingLayerMask = 0u;
		canvasMaterials = mr.sharedMaterials;
		yield return Wait.For.LRUpdates(1);
		base.enabled = false;
		AboveThreshold = () => IsAboveMatchThreshold();
		if ((bool)progressPS)
		{
			ParticleSystem.ShapeModule shape = progressPS.shape;
			shape.textureClipChannel = ParticleSystemShapeTextureChannel.Alpha;
			ParticleSystem.EmissionModule emission = progressPS.emission;
			minParticleRoT = emission.rateOverTime.constantMin;
			maxParticleRoT = emission.rateOverTime.constantMax;
		}
		if ((bool)puzzleInfo)
		{
			SetPuzzleType(puzzleInfo.puzzleType);
		}
	}

	public void SetGroupRoot(RasterizerGroup root)
	{
		groupRoot = root;
		playSound = false;
	}

	public void SetPuzzleType(PuzzleInfo.PuzzleType puzzleType)
	{
		this.puzzleType = puzzleType;
		Material sharedMaterial = mr.sharedMaterial;
		RasterizerSettings inst = BaseSettings<RasterizerSettings>.Inst;
		if (puzzleType == PuzzleInfo.PuzzleType.OPTIONAL)
		{
			sharedMaterial.SetColor(_ColorLines, inst.colorSecretShadowLines);
			sharedMaterial.SetColor(_ColorLinesIncomplete, inst.colorSecretShadowLinesIncomplete);
			sharedMaterial.SetColor(_ColorLinesIncompleteUnderShadow, inst.colorSecretShadowLinesIncompleteUnderShadow);
			sharedMaterial.SetColor(_ColourCompleted, inst.colourSecretCompleted);
			sharedMaterial.SetColor(_ColourFlash, inst.colourSecretFlash);
		}
		else
		{
			sharedMaterial.SetColor(_ColorLines, inst.colorShadowLines);
			sharedMaterial.SetColor(_ColorLinesIncomplete, inst.colorShadowLinesIncomplete);
			sharedMaterial.SetColor(_ColorLinesIncompleteUnderShadow, inst.colorShadowLinesIncompleteUnderShadow);
			sharedMaterial.SetColor(_ColourCompleted, inst.colourCompleted);
			sharedMaterial.SetColor(_ColourFlash, inst.colourFlash);
		}
	}

	public override void OnDestroy()
	{
		base.OnDestroy();
		if (sfxFeedback.isValid())
		{
			sfxFeedback.stop(STOP_MODE.IMMEDIATE);
		}
		RasterizationController.Inst.DeregisterRasterizer(this);
	}

	public void GetClipMesh(out RasterizerMesh rMesh)
	{
		rMesh = clipMesh;
		rMesh.worldMatrix = MaskXForm.localToWorldMatrix;
	}

	public Material[] GetCanvasMaterials()
	{
		return canvasMaterials;
	}

	public void UpdateFeedback(float matchPercentage, Texture2D matchTexture)
	{
		if (!LR.Inst.IsPaused && !LR.Inst.IsInCutscene)
		{
			if ((bool)mr)
			{
				mr.sharedMaterial.SetTexture(_SuccessTex, matchTexture);
			}
			if ((bool)progressPS)
			{
				ParticleSystem.ShapeModule shape = progressPS.shape;
				shape.texture = matchTexture;
			}
			currentMatchPercentage = (editMode ? 0f : matchPercentage);
			if (!groupRoot)
			{
				UpdateProgressParticles(matchPercentage);
			}
		}
	}

	public void UpdateProgressParticles(float matchPercentage)
	{
		if (updateFeedback && (bool)progressPS)
		{
			ParticleSystem.EmissionModule emission = progressPS.emission;
			emission.rateOverTime = Mathf.Lerp(minParticleRoT, maxParticleRoT, requiredMatchPercentage - matchPercentage);
			if (matchPercentage > 0f && !progressPS.isPlaying)
			{
				progressPS.Play(withChildren: false);
			}
			else if (matchPercentage <= 0f && progressPS.isPlaying)
			{
				progressPS.Stop(withChildren: false);
			}
		}
	}

	public override Wait CompleteObeliskPuzzle()
	{
		mr.sharedMaterial.EnableKeyword("DRAW_MASK");
		if ((bool)progressPS)
		{
			progressPS.transform.GetChild(0).GetComponent<ParticleSystem>().Play();
			progressPS.Stop(withChildren: false);
		}
		if (sfxFeedback.isValid())
		{
			sfxFeedback.stop(STOP_MODE.IMMEDIATE);
		}
		if (playSound && !Routine.Skipping)
		{
			if (soundSolve3DOverride != null || soundSolve2DOverride != null)
			{
				if (soundSolve3DOverride != null)
				{
					FAC.Inst.PlayOneShot(soundSolve3DOverride, base.transform.position);
				}
				if (soundSolve2DOverride != null)
				{
					FAC.Inst.PlayOneShot(soundSolve2DOverride, base.transform.position);
				}
			}
			else if (puzzleType == PuzzleInfo.PuzzleType.OPTIONAL)
			{
				FAC.Inst.PlayOneShot(BaseSettings<RasterizerSettings>.Inst.completionFeedback.SFX3DSecret.Value, base.transform.position);
				FAC.Inst.PlayOneShot(BaseSettings<RasterizerSettings>.Inst.completionFeedback.SFX2DSecret.Value, base.transform.position);
			}
			else
			{
				FAC.Inst.PlayOneShot(BaseSettings<RasterizerSettings>.Inst.completionFeedback.SFX3D.Value, base.transform.position);
				FAC.Inst.PlayOneShot(BaseSettings<RasterizerSettings>.Inst.completionFeedback.SFX2D.Value, base.transform.position);
			}
		}
		updateFeedback = false;
		if ((bool)canvas && !groupRoot)
		{
			return canvas.OnComplete(canvasMaterials);
		}
		return Wait.None;
	}

	private void OnDisable()
	{
		if (sfxFeedback.isValid())
		{
			sfxFeedback.stop(STOP_MODE.IMMEDIATE);
		}
	}

	public void OnUpdateLR()
	{
		if (updateFeedback && !groupRoot)
		{
			EvaluteFeedback();
		}
	}

	public override void Reset()
	{
		mr.sharedMaterial.DisableKeyword("DRAW_MASK");
		if ((bool)canvas)
		{
			canvas.ResetCanvas(mr.sharedMaterial);
		}
		currentMatchPercentage = 0f;
		updateFeedback = true;
	}

	public override void EvaluteFeedback()
	{
		RasterizerSettings.RasterizerFeedbackSettings rasterizerFeedbackSettings = BaseSettings<RasterizerSettings>.Inst.updateFeedback;
		float num = Mathf.InverseLerp(feedbackStartPercentage, requiredMatchPercentage, currentMatchPercentage);
		if (!sfxFeedback.isValid() && playSound)
		{
			sfxFeedback = FAC.Inst.PlayOneShot(rasterizerFeedbackSettings.SFX3D.Value, base.transform.position);
		}
		if ((bool)canvas)
		{
			canvas.UpdateFeedback(num, mr.sharedMaterial);
		}
		sfxFeedback.setParameterValue("Proximity", num);
	}

	public void SetPortalVariant(PortalVariations portalVariation)
	{
	}

	void PortalVariations.IUseVariantSet.OnVariantSetChanged(PortalVariations.VariantSet newSet)
	{
		_PortalVariantSet = newSet;
	}

	public bool LightRasterizable(LightSource light)
	{
		return light.IsValid(_PortalVariantSet);
	}

	public override void OnSceneUnload()
	{
		base.OnSceneUnload();
		for (int i = 0; i < canvasMaterials.Length; i++)
		{
			UnityEngine.Object.Destroy(canvasMaterials[i]);
		}
	}

	private void ApplyMaskTextureToParticleSystem()
	{
		GameObject gameObject = base.transform.FindDeepChild("PS_ShadowParticles_03")?.gameObject;
		if ((bool)gameObject)
		{
			ParticleSystem.ShapeModule shape = gameObject.GetComponent<ParticleSystem>().shape;
			shape.texture = textures.maskTexture;
			shape.scale = MaskXForm.localScale * 2f;
			ParticleSystem.ShapeModule shape2 = gameObject.transform.GetComponentInDirectChild<ParticleSystem>().shape;
			shape2.texture = shape.texture;
			shape2.scale = shape.scale;
		}
	}
}
public class Rasterizer_FramePiece : MonoBehaviour
{
	private enum EffectType
	{
		SCALE,
		COLOUR,
		CIRCLE,
		MERGED
	}

	[SerializeField]
	private Rasterizer_FramePiece[] connections;

	[SerializeField]
	private EffectType effectType;

	[ConditionalHide("effectType", true, 0, Inverse = true)]
	[SerializeField]
	private bool scaleX;

	[ConditionalHide("effectType", true, 0, Inverse = true)]
	[SerializeField]
	private bool scaleY;

	[ConditionalHide("effectType", true, 0, Inverse = true)]
	[SerializeField]
	private bool scaleZ;

	private Vector3 targetScale;

	private Vector3 startScale = Vector3.one;

	[SerializeField]
	private bool overrideTime;

	[ConditionalHide("overrideTime")]
	public float animTime = 0.3f;

	[ConditionalHide("effectType", true, 1, Inverse = true)]
	[SerializeField]
	private Color startColor = Color.black;

	[ConditionalHide("effectType", true, 1, Inverse = true)]
	[SerializeField]
	private Color targetColor = Color.white;

	private Color completeColor;

	[ConditionalHide("effectType", true, 2, Inverse = true)]
	[SerializeField]
	private bool rightHandSide;

	private MaterialPropertyBlock mpb;

	[SerializeField]
	[HideInInspector]
	private MeshRenderer meshRenderer;

	private bool meshRendererEnabled = true;

	[SerializeField]
	[HideInInspector]
	private RasterizerCanvas parentCanvas;

	[SerializeField]
	[HideInInspector]
	private Vector4[] leftParticlePoints;

	[SerializeField]
	[HideInInspector]
	private Vector4[] rightParticlePoints;

	private IHaglet fillRoutine;

	private Action forceFill;

	private IHaglet postCompletionRoutine;

	public static Rasterizer_FramePiece GenerateMerged(Rasterizer_FramePiece root, Transform parent)
	{
		RasterizerSettings settings = BaseSettings<RasterizerSettings>.Inst;
		Matrix4x4 w2l = parent.worldToLocalMatrix;
		List<Vector3> outVerts = new List<Vector3>();
		List<Vector3> outUVs = new List<Vector3>();
		List<int> outTris = new List<int>();
		List<Vector4> leftPP = new List<Vector4>();
		List<Vector4> rightPP = new List<Vector4>();
		float totalTime = 0f;
		if (!Merge(root, 0f))
		{
			return root;
		}
		Mesh mesh = new Mesh
		{
			name = "Merged Fill"
		};
		mesh.vertices = outVerts.ToArray();
		mesh.SetUVs(0, outUVs);
		mesh.triangles = outTris.ToArray();
		GameObject obj = new GameObject("Merged Fill");
		MeshFilter meshFilter = obj.AddComponent<MeshFilter>();
		MeshRenderer meshRenderer = obj.AddComponent<MeshRenderer>();
		Rasterizer_FramePiece rasterizer_FramePiece = obj.AddComponent<Rasterizer_FramePiece>();
		obj.transform.SetParent(parent, worldPositionStays: false);
		meshFilter.sharedMesh = mesh;
		meshRenderer.sharedMaterial = settings.mergedFillMaterial;
		rasterizer_FramePiece.leftParticlePoints = leftPP.ToArray();
		rasterizer_FramePiece.rightParticlePoints = rightPP.ToArray();
		rasterizer_FramePiece.effectType = EffectType.MERGED;
		rasterizer_FramePiece.animTime = totalTime;
		rasterizer_FramePiece.connections = new Rasterizer_FramePiece[0];
		DestroyFramePiece(root);
		return rasterizer_FramePiece;
		static void DestroyFramePiece(Rasterizer_FramePiece rfp)
		{
			Rasterizer_FramePiece[] array = rfp.connections;
			for (int i = 0; i < array.Length; i++)
			{
				DestroyFramePiece(array[i]);
			}
			if (UnityEngine.Application.isPlaying)
			{
				UnityEngine.Object.Destroy(rfp.gameObject);
			}
			else
			{
				UnityEngine.Object.DestroyImmediate(rfp.gameObject);
			}
		}
		bool Merge(Rasterizer_FramePiece rfp, float baseTime)
		{
			MeshFilter component = rfp.GetComponent<MeshFilter>();
			Matrix4x4 m = w2l * rfp.transform.localToWorldMatrix;
			bool flag = Matrix4x4X.GetPosition(ref m).x < 0f;
			Mesh sharedMesh = component.sharedMesh;
			if (!sharedMesh.isReadable)
			{
				UnityEngine.Debug.LogError("Mesh is not readable!", component);
				return false;
			}
			Vector3[] vertices = sharedMesh.vertices;
			int[] triangles = sharedMesh.triangles;
			int count = outVerts.Count;
			for (int j = 0; j < vertices.Length; j++)
			{
				outVerts.Add(m.MultiplyPoint3x4(vertices[j]));
			}
			for (int k = 0; k < triangles.Length; k++)
			{
				outTris.Add(triangles[k] + count);
			}
			if (rfp.effectType == EffectType.COLOUR)
			{
				float num = baseTime + (rfp.overrideTime ? rfp.animTime : settings.colorAnimTime);
				for (int l = 0; l < vertices.Length; l++)
				{
					outUVs.Add(new Vector3(baseTime, num, 0f));
				}
				baseTime = num;
			}
			else if (rfp.effectType == EffectType.SCALE)
			{
				float num2 = baseTime + (rfp.overrideTime ? rfp.animTime : settings.scaleAnimTime);
				float x = sharedMesh.bounds.min.x;
				float x2 = sharedMesh.bounds.max.x;
				List<Vector4> obj2 = (flag ? rightPP : leftPP);
				obj2.Add(m.MultiplyPoint3x4(new Vector3(x, 0f, 0f)).V3ToV4(baseTime));
				obj2.Add(m.MultiplyPoint3x4(new Vector3(x2, 0f, 0f)).V3ToV4(num2));
				for (int n = 0; n < vertices.Length; n++)
				{
					Vector3 vector = vertices[n];
					float t = Mathf.InverseLerp(x, x2, vector.x);
					outUVs.Add(new Vector3(0f, 0f, Mathf.Lerp(baseTime, num2, t)));
				}
				baseTime = num2;
			}
			if (baseTime > totalTime)
			{
				totalTime = baseTime;
			}
			Rasterizer_FramePiece[] array2 = rfp.connections;
			for (int num3 = 0; num3 < array2.Length; num3++)
			{
				Merge(array2[num3], baseTime);
			}
			return true;
		}
	}

	public void OnAwakeLR(RasterizerCanvas parentCanvas, ObeliskPuzzleObject puzzleObject)
	{
		this.parentCanvas = parentCanvas;
		meshRenderer = GetComponent<MeshRenderer>();
		mpb = new MaterialPropertyBlock();
		if (effectType == EffectType.SCALE)
		{
			targetScale = base.transform.localScale;
			startScale.x = ((!scaleX) ? 1 : 0);
			startScale.y = ((!scaleY) ? 1 : 0);
			startScale.z = ((!scaleZ) ? 1 : 0);
			SetScale(startScale);
			mpb.SetColor(ShaderPID._Color, Color.white);
			Haglet.Create(out fillRoutine, ScaleRoutine);
			forceFill = ForceScale;
		}
		else if (effectType == EffectType.COLOUR)
		{
			mpb.SetColor(ShaderPID._Color, startColor);
			Haglet.Create(out fillRoutine, ColorRoutine);
			forceFill = ForceColor;
		}
		else if (effectType == EffectType.CIRCLE)
		{
			mpb.SetFloat(ShaderPID._MaxAngle, 0f);
			Haglet.Create(out fillRoutine, CircleRoutine);
			forceFill = ForceCircle;
		}
		else if (effectType == EffectType.MERGED)
		{
			mpb.SetColor(ShaderPID._Color, Color.white);
			mpb.SetFloat(ShaderPID._CompletionTime, 0f);
			Haglet.Create(out fillRoutine, MergedRoutine);
			forceFill = ForceMerged;
		}
		meshRenderer.SetPropertyBlock(mpb);
		if (puzzleObject == null || puzzleObject.puzzleInfo == null)
		{
			completeColor = BaseSettings<RasterizerSettings>.Inst.colourCompleted;
		}
		else
		{
			completeColor = ((puzzleObject.puzzleInfo.puzzleType == PuzzleInfo.PuzzleType.MAIN) ? BaseSettings<RasterizerSettings>.Inst.colourCompleted : BaseSettings<RasterizerSettings>.Inst.colourSecretCompleted);
		}
		Haglet.Create(out postCompletionRoutine, PostCompletionRoutine);
	}

	public Wait PlayAnim()
	{
		return fillRoutine.Start(resetIfStarted: true);
	}

	public void ForceAnim()
	{
		forceFill();
	}

	public void PostCompletionAnim()
	{
		postCompletionRoutine.Start(resetIfStarted: true);
	}

	public void ForcePostCompletion()
	{
		ForceConnection(postCompletion: true);
		mpb.SetColor(ShaderPID._Color, completeColor);
		meshRenderer.SetPropertyBlock(mpb);
	}

	private Wait PlayConnection(bool postCompletion)
	{
		Wait none = Wait.None;
		Rasterizer_FramePiece[] array = connections;
		foreach (Rasterizer_FramePiece rasterizer_FramePiece in array)
		{
			if (postCompletion)
			{
				rasterizer_FramePiece.PostCompletionAnim();
			}
			else
			{
				none &= rasterizer_FramePiece.PlayAnim();
			}
		}
		return none;
	}

	private void ForceConnection(bool postCompletion)
	{
		Rasterizer_FramePiece[] array = connections;
		foreach (Rasterizer_FramePiece rasterizer_FramePiece in array)
		{
			if (postCompletion)
			{
				rasterizer_FramePiece.ForcePostCompletion();
			}
			else
			{
				rasterizer_FramePiece.ForceAnim();
			}
		}
	}

	private void UpdateParticleParentPosition(Vector3 worldPosition)
	{
		bool rhs = parentCanvas.transform.InverseTransformPoint(worldPosition).x < 0f;
		UpdateParticleParentPosition(worldPosition, rhs);
	}

	private void UpdateParticleParentPosition(Vector3 worldPosition, bool rhs)
	{
		parentCanvas.UpdateFrameParticlePosition(worldPosition, rhs);
	}

	public void ResetPiece()
	{
		if (effectType == EffectType.SCALE)
		{
			base.transform.localScale = startScale;
			mpb.SetColor(ShaderPID._Color, Color.white);
		}
		else
		{
			mpb.SetColor(ShaderPID._Color, startColor);
		}
		meshRenderer.SetPropertyBlock(mpb);
	}

	private IEnumerator<Routine.Yield> ScaleRoutine()
	{
		RasterizerSettings inst = BaseSettings<RasterizerSettings>.Inst;
		float time = 0f;
		float timeMax = (overrideTime ? animTime : inst.scaleAnimTime);
		while (time < timeMax)
		{
			float t = Mathf.Clamp01(time / timeMax);
			Vector3 scale = Vector3.Lerp(startScale, targetScale, t);
			if (connections.Length != 0)
			{
				Rasterizer_FramePiece[] array = connections;
				foreach (Rasterizer_FramePiece rasterizer_FramePiece in array)
				{
					Vector3 worldPosition = Vector3.Lerp(base.transform.position, rasterizer_FramePiece.transform.position, t);
					UpdateParticleParentPosition(worldPosition);
				}
			}
			SetScale(scale);
			time += IC.DeltaTime;
			yield return Wait.For.LRUpdates(1);
		}
		SetScale(targetScale);
		yield return PlayConnection(postCompletion: false);
	}

	private void SetScale(Vector3 targetScale)
	{
		base.transform.localScale = targetScale;
		bool flag = targetScale.x * targetScale.y * targetScale.z != 0f;
		if (flag != meshRendererEnabled)
		{
			meshRenderer.enabled = flag;
			meshRendererEnabled = flag;
		}
	}

	private void ForceScale()
	{
		SetScale(targetScale);
		ForceConnection(postCompletion: false);
	}

	private IEnumerator<Routine.Yield> ColorRoutine()
	{
		RasterizerSettings inst = BaseSettings<RasterizerSettings>.Inst;
		float time = 0f;
		float timeMax = (overrideTime ? animTime : inst.colorAnimTime);
		while (time < timeMax)
		{
			time += IC.DeltaTime;
			float t = Mathf.Clamp01(time / timeMax);
			Color value = Color.Lerp(startColor, targetColor, t);
			mpb.SetColor(ShaderPID._Color, value);
			meshRenderer.SetPropertyBlock(mpb);
			yield return Wait.For.LRUpdates(1);
		}
		mpb.SetColor(ShaderPID._Color, targetColor);
		meshRenderer.SetPropertyBlock(mpb);
		yield return PlayConnection(postCompletion: false);
	}

	private void ForceColor()
	{
		mpb.SetColor(ShaderPID._Color, targetColor);
		meshRenderer.SetPropertyBlock(mpb);
		ForceConnection(postCompletion: false);
	}

	private IEnumerator<Routine.Yield> CircleRoutine()
	{
		RasterizerSettings inst = BaseSettings<RasterizerSettings>.Inst;
		float time = 0f;
		float timeMax = (overrideTime ? animTime : inst.circleAnimTime);
		while (time < timeMax)
		{
			time += IC.DeltaTime;
			float t = Mathf.Clamp01(time / timeMax);
			float num = Mathf.Lerp(0f, 180f, t);
			mpb.SetFloat(ShaderPID._MaxAngle, num);
			meshRenderer.SetPropertyBlock(mpb);
			num = (rightHandSide ? (0f - num) : num);
			float x = -0.525f * Mathf.Sin(num * ((float)Math.PI / 180f));
			float y = -0.525f * Mathf.Cos(num * ((float)Math.PI / 180f));
			Vector3 worldPosition = base.transform.TransformPoint(new Vector3(x, y, 0f));
			UpdateParticleParentPosition(worldPosition, rightHandSide);
			yield return Wait.For.LRUpdates(1);
		}
		mpb.SetFloat(ShaderPID._MaxAngle, 180f);
		meshRenderer.SetPropertyBlock(mpb);
		yield return PlayConnection(postCompletion: false);
	}

	private void ForceCircle()
	{
		mpb.SetFloat(ShaderPID._MaxAngle, 180f);
		meshRenderer.SetPropertyBlock(mpb);
		ForceConnection(postCompletion: false);
	}

	private IEnumerator<Routine.Yield> MergedRoutine()
	{
		_ = BaseSettings<RasterizerSettings>.Inst;
		float time = 0f;
		int leftPPIdx = 0;
		int rightPPIdx = 0;
		while (time < animTime)
		{
			time += IC.DeltaTime;
			mpb.SetFloat(ShaderPID._CompletionTime, time);
			meshRenderer.SetPropertyBlock(mpb);
			UpdateMergerdParticlePos(leftParticlePoints, ref leftPPIdx, rhs: false, time);
			UpdateMergerdParticlePos(rightParticlePoints, ref rightPPIdx, rhs: true, time);
			yield return Wait.For.LRUpdates(1);
		}
		mpb.SetFloat(ShaderPID._CompletionTime, animTime);
		meshRenderer.SetPropertyBlock(mpb);
		yield return PlayConnection(postCompletion: false);
	}

	private void ForceMerged()
	{
		mpb.SetFloat(ShaderPID._CompletionTime, animTime);
		meshRenderer.SetPropertyBlock(mpb);
		ForceConnection(postCompletion: false);
	}

	private void UpdateMergerdParticlePos(Vector4[] points, ref int idx, bool rhs, float time)
	{
		while (idx < points.Length && time < points[idx].w)
		{
			idx++;
		}
		if (idx > 0 && idx < leftParticlePoints.Length)
		{
			Vector4 a = points[idx - 1];
			Vector4 b = points[idx];
			float t = Mathf.InverseLerp(a.w, b.w, time);
			UpdateParticleParentPosition(Vector4.Lerp(a, b, t), rhs);
		}
	}

	private IEnumerator<Routine.Yield> PostCompletionRoutine()
	{
		PlayConnection(postCompletion: true);
		Color startColor = meshRenderer.sharedMaterial.GetColor(ShaderPID._Color);
		RasterizerSettings inst = BaseSettings<RasterizerSettings>.Inst;
		float time = 0f;
		float timeMax = inst.postCompletionFadeTime;
		while (time < timeMax)
		{
			time += IC.DeltaTime;
			float t = Mathf.Clamp01(time / timeMax);
			Color value = Color.Lerp(startColor, completeColor, t);
			mpb.SetColor(ShaderPID._Color, value);
			meshRenderer.SetPropertyBlock(mpb);
			yield return Wait.For.LRUpdates(1);
		}
	}

	protected void OnDestroy()
	{
		fillRoutine?.Stop(complete: true);
	}

	public bool CheckCanMerge()
	{
		if (effectType == EffectType.CIRCLE)
		{
			return false;
		}
		Rasterizer_FramePiece[] array = connections;
		for (int i = 0; i < array.Length; i++)
		{
			if (!array[i].CheckCanMerge())
			{
				return false;
			}
		}
		return true;
	}
}
public struct RasterizerMeshNative
{
	public IntPtr vertices;

	public IntPtr uvs;

	public IntPtr indices;

	public int indicesNum;

	public Matrix4x4 worldMatrix;

	public Bounds localBounds;
}
public struct RasterizeResult
{
	public int LightCountRasterized;

	public int LightCountTotal;

	public int triCountRasterized;

	public int triCountTotal;

	public int pixelCount;

	public int meshResultCount;

	public float timeRasterizeShadowMapMs;

	public float timeRasterizeClipMeshMs;
}
internal struct RasterizerMeshResult
{
	public int trisRasterized;

	public int index;
}
public struct RasterizerLightNative
{
	public Vector3 position;

	public Quaternion rotation;

	public float clipPlaneNear;

	public float fov;

	public float range;

	public Matrix4x4 viewMatrix;

	public Matrix4x4 perspectiveMatrix;

	public Matrix4x4 fittedPerspectiveMatrix;
}
public struct RasterizerMesh
{
	public Rasterizable rasterizable;

	public Vector4[] vertices;

	public Vector2[] uvs;

	public int[] indices;

	public Matrix4x4 worldMatrix;

	public Bounds localBounds;

	public RasterizerMesh(Rasterizable rasterizable, Mesh mesh, bool requiresUVs)
	{
		this.rasterizable = rasterizable;
		Vector3[] array = mesh.vertices;
		vertices = new Vector4[array.Length];
		for (int i = 0; i < vertices.Length; i++)
		{
			Vector3 vector = array[i];
			vertices[i].x = vector.x;
			vertices[i].y = vector.y;
			vertices[i].z = vector.z;
			vertices[i].w = 1f;
		}
		uvs = mesh.uv;
		if (requiresUVs && (uvs == null || uvs.Length != vertices.Length))
		{
			UnityEngine.Debug.LogError($"This RasterizerMesh requires source mesh with UVs. Expected: {vertices.Length} got: {uvs?.Length}", rasterizable);
			uvs = new Vector2[vertices.Length];
		}
		indices = mesh.triangles;
		localBounds = mesh.bounds;
		worldMatrix = default(Matrix4x4);
	}
}
[ExecuteInEditMode]
public class RasterizerCanvas : MonoBehaviour, IPrebuildEvent
{
	private static readonly int SP_Completion = Shader.PropertyToID("_Completion");

	private static readonly int SP_Pulse = Shader.PropertyToID("_Pulse");

	private static readonly int SP_TintColor = Shader.PropertyToID("_TintColor");

	private static readonly int SP_ColorLinesIncomplete = Shader.PropertyToID("_ColorLinesIncomplete");

	private static readonly int SP_ColorLinesIncompleteUnderShadow = Shader.PropertyToID("_ColorLinesIncompleteUnderShadow");

	private static readonly int SP_ColorBackground = Shader.PropertyToID("_ColorBackground");

	private static readonly int SP_ColourCompleted = Shader.PropertyToID("_ColourCompleted");

	private static readonly int SP_ColourFlash = Shader.PropertyToID("_ColorFlash");

	private MeshRenderer canvasMeshRenderer;

	private MeshRenderer symbolMeshRenderer;

	private Animation anim;

	[HideInInspector]
	public float glowCurve;

	[HideInInspector]
	public float fillAlphaCurve;

	[HideInInspector]
	public float fillColorCurve;

	[HideInInspector]
	public float symbolFillColorCurve;

	[HideInInspector]
	public float godRayCurve;

	[HideInInspector]
	public float pulseOffset;

	[HideInInspector]
	public float pulseAlpha;

	[HideInInspector]
	public bool triggerParticles;

	[HideInInspector]
	public bool triggerFireworkSFX;

	private MaterialPropertyBlock symbolMPB;

	private Color symbolOrigColor;

	[SerializeField]
	private ParticleSystem fireworkPS;

	[SerializeField]
	private ParticleSystem completionPS;

	private RasterizerFirework_STUB fireworkSTUB;

	[SerializeField]
	private Rasterizer_FramePiece bottomCircle;

	[SerializeField]
	private ParticleSystem rightTrailPS;

	[SerializeField]
	private ParticleSystem leftTrailPS;

	private ParticlePath fireworkPath;

	[SerializeField]
	[HideInInspector]
	private float frameWidth = 1f;

	[SerializeField]
	[HideInInspector]
	private float frameHeight = 1f;

	public bool playeffects = true;

	private Rasterizer_FramePiece[] rasterizer_Framepeices;

	private ObeliskPuzzleObject puzzleObject;

	private IHaglet onAwakeLRRoutine;

	private IHaglet<Material[]> animateCompletionRoutine;

	public Wait OnAwakeLR(ObeliskPuzzleObject puzzleObject)
	{
		Haglet.Create(out onAwakeLRRoutine, OnAwakeLRRoutine);
		Haglet.Create(out animateCompletionRoutine, (Routine.Func1<Material[]>)AnimateCompletionRoutine, (string)null, startNow: false, (int?)null, (string)null);
		this.puzzleObject = puzzleObject;
		return onAwakeLRRoutine.Start();
	}

	private IEnumerator<Routine.Yield> OnAwakeLRRoutine()
	{
		anim = base.gameObject.GetComponentInAscendant<Animation>();
		anim["AN_RasterizerGlow"].layer = 1;
		yield return Wait.For.LRUpdates(1);
		if ((bool)bottomCircle)
		{
			rasterizer_Framepeices = GetComponentsInChildren<Rasterizer_FramePiece>(includeInactive: true);
			Rasterizer_FramePiece[] array = rasterizer_Framepeices;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].OnAwakeLR(this, puzzleObject);
				yield return Wait.For.LRUpdates(1);
			}
		}
		else
		{
			RasterizerSymbol_STUB componentInChildren = puzzleObject.GetComponentInChildren<RasterizerSymbol_STUB>(includeInactive: true);
			if ((bool)componentInChildren)
			{
				symbolMeshRenderer = componentInChildren.GetComponent<MeshRenderer>();
				symbolOrigColor = symbolMeshRenderer.sharedMaterial.GetColor("_TintColor");
			}
		}
		yield return Wait.For.LRUpdates(1);
		fireworkPath = puzzleObject.GetComponentInChildren<ParticlePath>(includeInactive: true);
		symbolMPB = new MaterialPropertyBlock();
	}

	public void UpdateFeedback(float completion, Material rasterizerMat)
	{
	}

	private void UpdateMaterialProperties(Material rasterizerMat)
	{
		RasterizerSettings inst = BaseSettings<RasterizerSettings>.Inst;
		rasterizerMat.SetColor(SP_Completion, new Color(glowCurve, fillAlphaCurve, fillColorCurve, godRayCurve));
		rasterizerMat.SetColor(SP_Pulse, new Color(pulseOffset, inst.pulseWidth, pulseAlpha, 0f));
		if ((bool)symbolMeshRenderer)
		{
			symbolMPB.SetColor(SP_TintColor, Color.Lerp(symbolOrigColor, Color.white, symbolFillColorCurve));
			symbolMeshRenderer.SetPropertyBlock(symbolMPB);
		}
	}

	public Wait OnComplete(Material[] rasterizerMats)
	{
		return animateCompletionRoutine.Call(rasterizerMats);
	}

	private IEnumerator<Routine.Yield> AnimateCompletionRoutine(Material[] rasterizerMats)
	{
		if ((bool)bottomCircle)
		{
			if (!Routine.Skipping)
			{
				if ((bool)rightTrailPS)
				{
					rightTrailPS.Play(withChildren: true);
				}
				if ((bool)leftTrailPS)
				{
					leftTrailPS.Play(withChildren: true);
				}
				bottomCircle.PlayAnim();
			}
			else
			{
				bottomCircle.ForceAnim();
			}
		}
		if (!Routine.Skipping)
		{
			anim.Play("AN_RasterizerGlow");
		}
		else
		{
			anim["AN_RasterizerGlow"].enabled = true;
			anim["AN_RasterizerGlow"].speed = 0f;
			anim["AN_RasterizerGlow"].weight = 1f;
			anim["AN_RasterizerGlow"].normalizedTime = 1f;
			anim.Sample();
		}
		bool lastTriggerParticlesState = triggerParticles;
		bool lastTriggerFireworkState = triggerFireworkSFX;
		FMOD.Studio.EventInstance fireworkTrailSfx = default(FMOD.Studio.EventInstance);
		while (anim.IsPlaying("AN_RasterizerGlow") || Routine.Skipping)
		{
			for (int i = 0; i < rasterizerMats.Length; i++)
			{
				UpdateMaterialProperties(rasterizerMats[i]);
			}
			if (Routine.Skipping)
			{
				break;
			}
			if (triggerParticles && !lastTriggerParticlesState && completionPS != null)
			{
				completionPS.Play();
				if ((bool)rightTrailPS)
				{
					rightTrailPS.Stop(withChildren: true);
				}
				if ((bool)leftTrailPS)
				{
					leftTrailPS.Stop(withChildren: true);
				}
			}
			if (triggerFireworkSFX && !lastTriggerFireworkState && fireworkPS != null)
			{
				FAC.Inst.PlayOneShot(BaseSettings<RasterizerSettings>.Inst.fireworkSFX.Value, fireworkPS.transform);
				fireworkTrailSfx = FAC.Inst.PlayOneShot(BaseSettings<RasterizerSettings>.Inst.fireworkTrailSFX.Value, fireworkPS.transform);
				if ((bool)fireworkPath)
				{
					fireworkPath.enabled = true;
				}
			}
			lastTriggerParticlesState = triggerParticles;
			lastTriggerFireworkState = triggerFireworkSFX;
			yield return Wait.For.LRUpdates(1);
		}
		yield return Wait.For.Seconds(BaseSettings<RasterizerSettings>.Inst.postCompletionDelayTime);
		if (fireworkTrailSfx.isValid())
		{
			fireworkTrailSfx.stop(STOP_MODE.ALLOWFADEOUT);
		}
		if ((bool)bottomCircle)
		{
			if (!Routine.Skipping)
			{
				bottomCircle.PostCompletionAnim();
			}
			else
			{
				bottomCircle.ForcePostCompletion();
			}
		}
	}

	public void UpdateFrameParticlePosition(Vector3 worldPostion, bool rightHandSide)
	{
		if (rightHandSide && (bool)rightTrailPS)
		{
			rightTrailPS.transform.position = worldPostion;
		}
		else if ((bool)leftTrailPS)
		{
			leftTrailPS.transform.position = worldPostion;
		}
	}

	public void ResetCanvas(Material rasterizerMat)
	{
		Rasterizer_FramePiece[] componentsInChildren = GetComponentsInChildren<Rasterizer_FramePiece>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].ResetPiece();
		}
		anim["AN_RasterizerGlow"].normalizedTime = 0f;
		anim["AN_RasterizerGlow"].enabled = true;
		anim["AN_RasterizerGlow"].weight = 1f;
		anim.Sample();
		anim["AN_RasterizerGlow"].enabled = false;
		UpdateMaterialProperties(rasterizerMat);
	}

	private void OnDestroy()
	{
		if (animateCompletionRoutine != null)
		{
			animateCompletionRoutine.Stop();
		}
	}

	void IPrebuildEvent.OnPrebuildRoot(bool isPrefab)
	{
	}
}
public class RasterizerFirework_STUB : MonoBehaviour
{
	private Vector3 startPosition;

	private IHaglet<float> followFireworkRoutine;

	public void FollowFirework(float speed)
	{
		if (followFireworkRoutine == null)
		{
			startPosition = base.transform.position;
			Haglet.Create(out followFireworkRoutine, (Routine.Func1<float>)FollowFireworkRoutine, (string)null, startNow: false, (int?)null, (string)null);
		}
		base.transform.position = startPosition;
		followFireworkRoutine.Start(speed, resetIfStarted: true);
	}

	public void StopFollowing()
	{
		if (followFireworkRoutine != null)
		{
			followFireworkRoutine.Stop();
		}
		else
		{
			UnityEngine.Debug.Log("Stopped firework without ever firing??");
		}
	}

	private IEnumerator<Routine.Yield> FollowFireworkRoutine(float speed)
	{
		float animTime = 1f;
		float time = 0f;
		while (time < animTime)
		{
			time += IC.DeltaTime;
			Vector3 position = base.transform.position;
			position += base.transform.up * speed * IC.DeltaTime;
			base.transform.position = position;
			yield return Wait.For.LRUpdates(1);
		}
	}

	private void OnDestroy()
	{
		if (followFireworkRoutine != null)
		{
			followFireworkRoutine.Stop();
		}
	}
}
public class RasterizerGroup : ObeliskPuzzleObject
{
	public Vector3 SFXOrigin;

	private ConstArray<Rasterizer> rasterizers = new ConstArray<Rasterizer>(10u);

	private FMOD.Studio.EventInstance sfxFeedback;

	private RasterizerCanvas canvas;

	private Material[] canvasMaterials;

	[Header("Use this for any rasterizers which are not childed to this group, DOES NOT WORK ACROSS SCENES")]
	public IDObjectRef[] groupedRasterizers;

	private IHaglet intializeRasterizerGroupRoutine;

	public override void OnAwakeLR(MRBase owner)
	{
		Haglet.Create(out intializeRasterizerGroupRoutine, IntializeRasterizerGroupRoutine);
		base.OnAwakeLR(owner);
	}

	public Wait IntializeRasterizerGroup()
	{
		return intializeRasterizerGroupRoutine.Start();
	}

	private IEnumerator<Routine.Yield> IntializeRasterizerGroupRoutine()
	{
		if (groupedRasterizers != null)
		{
			for (int i = 0; i < groupedRasterizers.Length; i++)
			{
				groupedRasterizers[i].TryGet<Rasterizer>(out var value);
				AddRasterizers(value);
			}
		}
		Rasterizer[] componentsInChildren = GetComponentsInChildren<Rasterizer>();
		for (int j = 0; j < componentsInChildren.Length; j++)
		{
			AddRasterizers(componentsInChildren[j]);
		}
		for (int k = 0; k < rasterizers.Length; k++)
		{
			rasterizers[k].SetGroupRoot(this);
		}
		if ((bool)puzzleInfo)
		{
			for (int l = 0; l < rasterizers.Length; l++)
			{
				rasterizers[l].SetPuzzleType(puzzleInfo.puzzleType);
			}
		}
		yield return Wait.For.Updates(1);
		canvas = GetComponentInChildren<RasterizerCanvas>();
		if ((bool)canvas)
		{
			yield return canvas.OnAwakeLR(this);
		}
		yield return Wait.For.Updates(1);
		canvasMaterials = new Material[rasterizers.Length];
		float num = 0f;
		for (int m = 0; m < rasterizers.Length; m++)
		{
			Rasterizer rasterizer = rasterizers[m];
			num += rasterizer.requiredMatchPercentage;
			canvasMaterials[m] = rasterizer.GetCanvasMaterials()[0];
		}
		num /= (float)rasterizers.Length;
		requiredMatchPercentage = num;
		AboveThreshold = () => IsAboveMatchThreshold();
	}

	private void AddRasterizers(Rasterizer rasterizer)
	{
		if (rasterizer != null && !rasterizers.Contains(rasterizer))
		{
			rasterizers.Add(rasterizer);
		}
	}

	public void OnUpdateLR()
	{
		currentMatchPercentage = GetCurrentMatchPercentage();
		if (updateFeedback)
		{
			EvaluteFeedback();
		}
	}

	public override float GetCurrentMatchPercentage()
	{
		float num = 0f;
		if (rasterizers == null)
		{
			return num;
		}
		for (int i = 0; i < rasterizers.Length; i++)
		{
			Rasterizer rasterizer = rasterizers[i];
			num += rasterizer.GetCurrentMatchPercentage();
		}
		return num /= (float)rasterizers.Length;
	}

	public override bool IsAboveMatchThreshold()
	{
		return GetCurrentMatchPercentage() >= requiredMatchPercentage;
	}

	public override Wait CompleteObeliskPuzzle()
	{
		if (rasterizers == null)
		{
			return Wait.None;
		}
		Wait result = CompleteObeliskGroup();
		for (int i = 0; i < rasterizers.Length; i++)
		{
			Rasterizer rasterizer = rasterizers[i];
			result &= rasterizer.CompleteObeliskPuzzle();
		}
		return result;
	}

	public Wait CompleteObeliskGroup()
	{
		if (sfxFeedback.isValid())
		{
			sfxFeedback.stop(STOP_MODE.IMMEDIATE);
		}
		if (!Routine.Skipping)
		{
			FAC.Inst.PlayOneShot(BaseSettings<RasterizerSettings>.Inst.completionFeedback.SFX3D.Value, base.transform.position);
			FAC.Inst.PlayOneShot(BaseSettings<RasterizerSettings>.Inst.completionFeedback.SFX2D.Value, base.transform.position);
		}
		updateFeedback = false;
		if ((bool)canvas)
		{
			return canvas.OnComplete(canvasMaterials);
		}
		return Wait.None;
	}

	public override void Reset()
	{
		for (int i = 0; i < rasterizers.Length; i++)
		{
			rasterizers[i].Reset();
		}
		for (int j = 0; j < canvasMaterials.Length; j++)
		{
			canvas?.ResetCanvas(canvasMaterials[j]);
		}
	}

	public override void EvaluteFeedback()
	{
		RasterizerSettings.RasterizerFeedbackSettings rasterizerFeedbackSettings = BaseSettings<RasterizerSettings>.Inst.updateFeedback;
		float num = Mathf.InverseLerp(feedbackStartPercentage, requiredMatchPercentage, currentMatchPercentage);
		Vector3 position = base.transform.TransformPoint(SFXOrigin);
		if (!sfxFeedback.isValid())
		{
			sfxFeedback = FAC.Inst.PlayOneShot(rasterizerFeedbackSettings.SFX3D.Value, position);
		}
		sfxFeedback.setParameterValue("Proximity", num);
		if (rasterizers == null)
		{
			return;
		}
		for (int i = 0; i < rasterizers.Length; i++)
		{
			Rasterizer rasterizer = rasterizers[i];
			if ((bool)rasterizer.canvas)
			{
				rasterizer.canvas.UpdateFeedback(num, null);
			}
			rasterizer.UpdateProgressParticles(currentMatchPercentage);
		}
	}

	private void OnDisable()
	{
		if (sfxFeedback.isValid())
		{
			sfxFeedback.stop(STOP_MODE.IMMEDIATE);
		}
	}
}
public class RasterizerNative
{
	private const string rasterizerLibraryKey = "RasterizerLibrary";

	private static IntPtr library;

	public static void LoadLibrary()
	{
	}

	public static void UnloadLibrary()
	{
	}

	[DllImport("Rasterizer")]
	public static extern void Initialize();

	[DllImport("Rasterizer")]
	public static extern float Sobel3x3(IntPtr outputTexture, IntPtr inputTexture, v2i textureSize);

	[DllImport("Rasterizer")]
	public static extern float StrokeSimple(IntPtr outputTexture, IntPtr inputTexture, v2i textureSize, int expandByPixels);

	[DllImport("Rasterizer")]
	public static extern float BoxDistance(IntPtr outputTexture, IntPtr inputTexture, v2i textureSize, int expandByPixels);

	[DllImport("Rasterizer")]
	public static extern float Compare(IntPtr outputTexture, IntPtr inputTexture, IntPtr maskTexture, v2i textureSize, int colorMultiplier);

	[DllImport("Rasterizer")]
	public static extern float GaussianBlur(IntPtr outputTexture, IntPtr inputTexture, v2i textureSize, int kernelSize, float falloff, float scale);

	[DllImport("Rasterizer")]
	public static extern RasterizeResult Rasterize(IntPtr outputTexture, IntPtr meshes, int meshesNum, IntPtr lights, int lightsNum, IntPtr shadowDepthTexture, float shadowDepthBias, RasterizerMeshNative clipMesh, v2i textureSize, IntPtr rasterizedMeshes);

	[DllImport("Rasterizer")]
	public static extern void SDFBlur(Color32[] outputTexture, Color32[] inputTexture, IntPtr fractalTexture, v2i textureSize, int kernalSize, int godRayLength);
}
public class RasterizerParticle_STUB : MonoBehaviour
{
}
public class RasterizerParticleSpawnNode : MonoBehaviour
{
}
public class RasterizerSnapData : ScriptableObject
{
	[Serializable]
	public class SnapData
	{
		public string name;

		public Vector3 worldPosition;

		public Vector3 localCentre;

		public bool shouldOverrideSettings;

		public float snapRadius = 0.12f;

		public float snapSpeed = 0.25f;

		public AnimationCurve snapCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);
	}

	[Serializable]
	public class SnapDataDict : SerialisableDictionary<string, SnapData>
	{
	}

	[ReadOnly]
	public SnapDataDict snapDataDict = new SnapDataDict();

	public void ClearSnapData()
	{
		snapDataDict.dict.Clear();
	}

	public void AddSnapData(GrabObject obj)
	{
		string id = obj.id;
		SnapData snapData = new SnapData();
		MeshRenderer[] componentsInChildren = obj.GetComponentsInChildren<MeshRenderer>();
		Bounds bounds = default(Bounds);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (i == 0)
			{
				bounds = componentsInChildren[i].bounds;
			}
			else
			{
				bounds.Encapsulate(bounds);
			}
		}
		snapData.name = obj.name;
		snapData.worldPosition = bounds.center;
		snapData.localCentre = obj.transform.InverseTransformPoint(bounds.center);
		snapDataDict.dict[id] = snapData;
	}

	public bool TryGetSnapData(string id, out SnapData data)
	{
		return snapDataDict.dict.TryGetValue(id, out data);
	}
}
public class RasterizerSymbol_STUB : MonoBehaviour
{
}
public class SaveDataGame
{
	public enum Chapter
	{
		None = 0,
		Princess = 2,
		Hunter = 4,
		Stargazing = 8,
		Escape = 0x10,
		Evilgate = 0x20,
		Insanity = 0x40,
		Death = 0x80,
		FirstMeeting = 0x100,
		Construct = 0x200,
		Mansfield = 0x400
	}

	public delegate void OnPuzzleCompleted();

	public enum PuzzleSaveType
	{
		Progression,
		Scene
	}

	private class ChapterDataInternal
	{
		public Dictionary<string, SceneDataInternal> sceneSaveData = new Dictionary<string, SceneDataInternal>();

		public ConstArray<string> inventoryGrabObjects = new ConstArray<string>(128u);

		public HashSet<string> puzzlesCompletedLocal = new HashSet<string>();

		public string lastSceneUIDName;

		public bool hasEnteredVault;
	}

	private class SceneDataInternal
	{
		public byte[] serializedSceneData;

		[Serializer.Exclude]
		public SceneSaveData sceneSaveData;

		public ConstArray<string> grabObjectsToSave = new ConstArray<string>(128u);
	}

	private class GrabObjectDataInternal
	{
		[Serializer.Exclude]
		public GrabObject grabObject;

		private byte[] serializedComponents;

		[Serializer.Exclude]
		private IDObject[] idObjects;

		public GrabObjectDataInternal()
		{
		}

		public GrabObjectDataInternal(GrabObject grabObject)
		{
			this.grabObject = grabObject;
			idObjects = grabObject.GetComponentsInChildren<IDObject>(includeInactive: true);
			Save();
		}

		public void Save()
		{
			if (grabObject != null && idObjects != null)
			{
				grabObject.CaptureSaveData();
				serializedComponents = Serializer.SerializeToMemory(idObjects);
			}
		}

		public void Load()
		{
			if (serializedComponents == null)
			{
				UnityEngine.Debug.LogError("Tried to load GrabObjectDataInternal with no serialized data!");
				return;
			}
			grabObject = null;
			idObjects = Serializer.DeserialiseFromMemory<IDObject[]>(serializedComponents);
			bool flag = true;
			for (int i = 0; i < idObjects.Length; i++)
			{
				flag &= LR.Inst.RegisterId(idObjects[i]);
				if (idObjects[i] is GrabObject)
				{
					if ((bool)grabObject)
					{
						UnityEngine.Debug.LogError("Found more than one GrabObject component on saved grab object!");
						continue;
					}
					grabObject = (GrabObject)idObjects[i];
					grabObject.LoadPuzzleInfos();
				}
			}
			if (!flag)
			{
				UnityEngine.Debug.LogError("Failed to register an IDObject on saved object: " + ((grabObject == null) ? "NULL GRABOBJECT" : grabObject.name));
			}
		}

		public void ClearReferences()
		{
			grabObject = null;
			idObjects = null;
		}
	}

	public const int SaveSlot = 0;

	public static readonly Chapter firstMilestoneUnlockMask = Chapter.Princess;

	public static readonly Chapter secondMilestoneUnlockMask = firstMilestoneUnlockMask | Chapter.Hunter | Chapter.Stargazing | Chapter.Escape;

	public static readonly Chapter thirdMilsetoneUnlockMask = secondMilestoneUnlockMask | Chapter.Evilgate | Chapter.Insanity | Chapter.Death;

	public static readonly Chapter fourthMilestoneUnlockMask = thirdMilsetoneUnlockMask | Chapter.FirstMeeting;

	public int currentProfileIdx;

	public Chapter lastChapter;

	public Chapter lastchapterCompletedProgression;

	public Chapter chaptersComplete;

	public PuzzleInfo currentMansfieldPuzzle;

	public bool secretDiscovered;

	public bool newGameStarted;

	public bool tutorialComplete;

	public bool stationComplete;

	public bool stationLeverPulled;

	public string lastSceneUIDName;

	public bool[] progressDoors = new bool[4];

	public HashSet<InventoryStoryItem> activeInventoryStoryItems = new HashSet<InventoryStoryItem>();

	public HashSet<string> voSequencersComplete = new HashSet<string>();

	public int mansfieldVOSequenceIdx;

	public HashSet<string> mansfieldScenesEntered = new HashSet<string>();

	public HashSet<string> mansfieldLeverPulled = new HashSet<string>();

	public HashSet<string> activatedPortals = new HashSet<string>();

	private Dictionary<string, GrabObjectDataInternal> serializedGrabObjects = new Dictionary<string, GrabObjectDataInternal>();

	public HashSet<string> puzzlesCompletedGlobal = new HashSet<string>();

	private Dictionary<Chapter, ChapterDataInternal> chapterSaveData = new Dictionary<Chapter, ChapterDataInternal>();

	public static event OnPuzzleCompleted PuzzleCompleted;

	public bool GetVOSequencerComplete(string sequencerID)
	{
		return voSequencersComplete.Contains(sequencerID);
	}

	public void SetVOSequencerComplete(string sequencerID)
	{
		voSequencersComplete.Add(sequencerID);
	}

	public bool HasPlayerEnteredMansfieldChapter(string sceneUIDName)
	{
		return mansfieldScenesEntered.Contains(sceneUIDName);
	}

	public void MansfieldSceneEntered(string sceneUIDName)
	{
		mansfieldScenesEntered.Add(sceneUIDName);
	}

	public bool HasPlayerPulledMansfieldLeverForCurrent()
	{
		return HasPlayerPulledMansfieldLever(currentMansfieldPuzzle.PuzzleName);
	}

	public bool HasPlayerPulledMansfieldLever(string puzzleName)
	{
		return mansfieldLeverPulled.Contains(puzzleName);
	}

	public void MansfieldLeverPulled()
	{
		mansfieldLeverPulled.Add(currentMansfieldPuzzle.PuzzleName);
	}

	public bool ContainsGrabObject(string id)
	{
		return serializedGrabObjects.ContainsKey(id);
	}

	public void CreateSaveDataForGrabObject(GrabObject grabObject)
	{
		if (!string.IsNullOrEmpty(grabObject.id) && grabObject.allowSaving)
		{
			serializedGrabObjects[grabObject.id] = new GrabObjectDataInternal(grabObject);
		}
	}

	public bool SpawnGrabObjectFromData(string id, out GrabObject grabObject)
	{
		if (LR.Inst.idObjects.TryGetValue(id, out var value))
		{
			grabObject = value as GrabObject;
			if (!grabObject)
			{
				UnityEngine.Debug.LogError("Saved GrabObject '" + id + "': Object already exists but is not a GrabObject!");
			}
			return false;
		}
		if (!serializedGrabObjects.TryGetValue(id, out var value2) || value2 == null)
		{
			UnityEngine.Debug.LogError("No grabObject saved with ID: " + id);
			grabObject = null;
			return false;
		}
		value2.Load();
		grabObject = value2.grabObject;
		return grabObject != null;
	}

	public bool IsPuzzleCompleted(string puzzle, PuzzleSaveType saveType, Chapter chapter)
	{
		return saveType switch
		{
			PuzzleSaveType.Scene => GetChapterPuzzles(chapter).Contains(puzzle), 
			PuzzleSaveType.Progression => puzzlesCompletedGlobal.Contains(puzzle), 
			_ => false, 
		};
	}

	public bool CompletePuzzleScene(string puzzle, Chapter chapter)
	{
		HashSet<string> chapterPuzzles = GetChapterPuzzles(chapter);
		if (!chapterPuzzles.Contains(puzzle))
		{
			chapterPuzzles.Add(puzzle);
			if (SaveDataGame.PuzzleCompleted != null)
			{
				SaveDataGame.PuzzleCompleted();
			}
			return true;
		}
		return false;
	}

	public void UncompletePuzzleScene(string puzzleName, Chapter chapter)
	{
		HashSet<string> chapterPuzzles = GetChapterPuzzles(chapter);
		if (chapterPuzzles.Contains(puzzleName))
		{
			chapterPuzzles.Remove(puzzleName);
		}
	}

	public bool CompletePuzzleProgress(string puzzle)
	{
		if (!puzzlesCompletedGlobal.Contains(puzzle))
		{
			puzzlesCompletedGlobal.Add(puzzle);
			return true;
		}
		return false;
	}

	private ChapterDataInternal GetChapterData(Chapter chapter)
	{
		if (!chapterSaveData.TryGetValue(chapter, out var value))
		{
			value = new ChapterDataInternal();
			chapterSaveData.Add(chapter, value);
		}
		return value;
	}

	public ConstArray<string> GetChapterInventory(SceneInfo sceneInfo)
	{
		Chapter puzzleChapter = sceneInfo.GetPuzzleChapter();
		return GetChapterData(puzzleChapter).inventoryGrabObjects;
	}

	public HashSet<string> GetChapterPuzzles(Chapter chapter)
	{
		return GetChapterData(chapter).puzzlesCompletedLocal;
	}

	public void AddObjectToChapterInventory(Chapter chapter, GrabObject grabObject)
	{
		ChapterDataInternal chapterData = GetChapterData(chapter);
		if (!chapterData.inventoryGrabObjects.Contains(grabObject.id))
		{
			chapterData.inventoryGrabObjects.Add(grabObject.id);
		}
	}

	public void RemoveObjectToChapterInventory(Chapter chapter, GrabObject grabObject)
	{
		ChapterDataInternal chapterData = GetChapterData(chapter);
		if (chapterData.inventoryGrabObjects.Contains(grabObject.id))
		{
			chapterData.inventoryGrabObjects.Remove(grabObject.id);
		}
	}

	public void SetLastLevelInChapter(Chapter chapter, string UIDName)
	{
		GetChapterData(chapter).lastSceneUIDName = UIDName;
	}

	public string GetLastLevelUIDInChapter(Chapter chapter)
	{
		return GetChapterData(chapter).lastSceneUIDName;
	}

	public bool GetChapterVaultEnteredState(Chapter chapter)
	{
		return GetChapterData(chapter).hasEnteredVault;
	}

	public void SetChapterVaultEnterStatus(Chapter chapter, bool entered)
	{
		GetChapterData(chapter).hasEnteredVault = entered;
	}

	public bool IsChapterFinished(Chapter chapter)
	{
		ChapterDataInternal chapterData = GetChapterData(chapter);
		if (chapterData.lastSceneUIDName == "bead")
		{
			return !chapterData.hasEnteredVault;
		}
		return false;
	}

	private SceneDataInternal GetSceneDataInternal(MRBase owner)
	{
		SceneInfo sceneInfo = owner.info.Load();
		if (!TryGetSceneDataInternal(sceneInfo, out var ssd, out var cdi))
		{
			ssd = new SceneDataInternal();
			ssd.sceneSaveData = new SceneSaveData();
			ssd.sceneSaveData.owner = owner;
			cdi.sceneSaveData.Add(sceneInfo.name, ssd);
		}
		return ssd;
	}

	private bool TryGetSceneDataInternal(SceneInfo sceneInfo, out SceneDataInternal ssd, out ChapterDataInternal cdi)
	{
		Chapter puzzleChapter = sceneInfo.GetPuzzleChapter();
		if (!chapterSaveData.TryGetValue(puzzleChapter, out cdi))
		{
			cdi = new ChapterDataInternal();
			chapterSaveData.Add(puzzleChapter, cdi);
		}
		return cdi.sceneSaveData.TryGetValue(sceneInfo.name, out ssd);
	}

	public void SceneLoad(MRBase owner)
	{
		SceneDataInternal sceneDataInternal = GetSceneDataInternal(owner);
		if (sceneDataInternal.serializedSceneData != null)
		{
			sceneDataInternal.sceneSaveData = Serializer.DeserialiseFromMemory<SceneSaveData>(sceneDataInternal.serializedSceneData);
			return;
		}
		sceneDataInternal.sceneSaveData = new SceneSaveData
		{
			owner = owner
		};
	}

	public void SceneUnload(MRBase owner)
	{
		SceneDataInternal sceneDataInternal = GetSceneDataInternal(owner);
		if (sceneDataInternal.sceneSaveData != null)
		{
			sceneDataInternal.sceneSaveData.owner = null;
		}
		ClearSceneReferences(owner);
	}

	public void SceneSave(MRBase owner)
	{
		SceneDataInternal sceneDataInternal = GetSceneDataInternal(owner);
		GrabObjectDataInternal grabObjectDataInternal = null;
		for (int i = 0; i < sceneDataInternal.grabObjectsToSave.Length; i++)
		{
			grabObjectDataInternal = null;
			if (serializedGrabObjects.TryGetValue(sceneDataInternal.grabObjectsToSave[i], out grabObjectDataInternal))
			{
				grabObjectDataInternal.Save();
			}
		}
		sceneDataInternal.serializedSceneData = Serializer.SerializeToMemory(sceneDataInternal.sceneSaveData);
	}

	public void ClearSceneReferences(MRBase owner)
	{
		SceneDataInternal sceneDataInternal = GetSceneDataInternal(owner);
		GrabObjectDataInternal grabObjectDataInternal = null;
		for (int i = 0; i < sceneDataInternal.grabObjectsToSave.Length; i++)
		{
			grabObjectDataInternal = null;
			if (serializedGrabObjects.TryGetValue(sceneDataInternal.grabObjectsToSave[i], out grabObjectDataInternal))
			{
				grabObjectDataInternal.ClearReferences();
			}
		}
	}

	public void TransferGrabObject(GrabObject grabObject, MRBase oldOwner, MRBase newOwner)
	{
		if ((bool)newOwner && grabObject.allowSaving)
		{
			string id = grabObject.id;
			SceneInfo sceneInfo = newOwner.info.Load();
			SceneInfo sceneInfo2 = (oldOwner ? oldOwner.info.Load() : LR.Inst.GetSceneInfoWithSceneUIDName(grabObject.saveData.sceneUIDName));
			if (TryGetSceneDataInternal(sceneInfo2, out var ssd, out var cdi))
			{
				ssd.grabObjectsToSave.Remove(id);
			}
			if (sceneInfo.canSave && TryGetSceneDataInternal(sceneInfo, out ssd, out cdi))
			{
				ssd.grabObjectsToSave.Add(id);
			}
		}
	}

	public SceneSaveData SceneGet(MRBase owner)
	{
		return GetSceneDataInternal(owner).sceneSaveData;
	}

	public ConstArray<string> SceneGrabObjectsGet(MRBase owner)
	{
		return GetSceneDataInternal(owner).grabObjectsToSave;
	}

	public void ResetChapter(ChapterInfo chapterInfo)
	{
		SceneInfo_BundleRef[] chapterScenes = chapterInfo.chapterScenes;
		for (int i = 0; i < chapterScenes.Length; i++)
		{
			SceneInfo sceneInfo = chapterScenes[i].Load();
			SceneReset(sceneInfo);
		}
		chapterSaveData[chapterInfo.chapter] = new ChapterDataInternal
		{
			lastSceneUIDName = chapterInfo.chapterScenes[0].Load().sceneUIDName
		};
	}

	public void SceneReset(SceneInfo sceneInfo)
	{
		if (!sceneInfo.canSave)
		{
			return;
		}
		ChapterDataInternal chapterData = GetChapterData(sceneInfo.GetPuzzleChapter());
		if (chapterData.sceneSaveData.TryGetValue(sceneInfo.name, out var _))
		{
			ConstArray<string> grabObjectsToSave = chapterData.sceneSaveData[sceneInfo.name].grabObjectsToSave;
			for (int i = 0; i < grabObjectsToSave.Length; i++)
			{
				string key = grabObjectsToSave[i];
				serializedGrabObjects.Remove(key);
			}
			RemoveAllSceneEntriesFromHashSet(voSequencersComplete, sceneInfo.sceneUIDName);
			chapterData.sceneSaveData[sceneInfo.name] = new SceneDataInternal();
		}
	}

	private void RemoveAllSceneEntriesFromHashSet<T>(HashSet<T> hashSet, string sceneUIDName) where T : IDObject
	{
		bool flag;
		do
		{
			flag = false;
			T item = null;
			foreach (T item2 in hashSet)
			{
				if (item2.id.StartsWith(sceneUIDName))
				{
					item = item2;
					flag = true;
					break;
				}
			}
			hashSet.Remove(item);
		}
		while (flag);
	}

	private void RemoveAllSceneEntriesFromHashSet(HashSet<string> hashSet, string sceneUIDName)
	{
		bool flag;
		do
		{
			flag = false;
			string item = null;
			foreach (string item2 in hashSet)
			{
				if (item2.StartsWith(sceneUIDName))
				{
					item = item2;
					flag = true;
					break;
				}
			}
			hashSet.Remove(item);
		}
		while (flag);
	}

	public void CompleteChapter(Chapter chapter)
	{
		lastChapter = chapter;
		if ((chaptersComplete & chapter) == 0)
		{
			chaptersComplete |= chapter;
			lastchapterCompletedProgression = chapter;
			UnityEngine.Debug.Log($"CHAPTER COMPLETE: {chapter}");
		}
	}

	public bool IsChapterMaskCompleteAny(Chapter chapterMask)
	{
		return (chaptersComplete & chapterMask) != 0;
	}

	public bool IsChapterMaskCompleteAll(Chapter chapterMask)
	{
		return (chaptersComplete & chapterMask) == chapterMask;
	}
}
public class SceneSaveData
{
	public MRBase owner;

	public override string ToString()
	{
		return owner.ToString();
	}
}
public class SaveDataSettings
{
	public const int SaveSlot = 1;

	public const bool logging = false;

	public int currentProfileIdx;

	public TeleportSettings.Mode inputMode = TeleportSettings.Mode.DualInput;

	public TeleportSettings.SpeedSetting teleportFadeSpeed = TeleportSettings.SpeedSetting.Fast;

	public TeleportSettings.FreeMoveRotateSetting freeMoveTurnType;

	public TeleportSettings.SpeedSetting freeMoveSpeed = TeleportSettings.SpeedSetting.Medium;

	public TeleportSettings.TurnSetting turnAmount = TeleportSettings.TurnSetting.Medium;

	public TeleportSettings.VignettePresets vignettePreset;

	public TeleportSettings.DirectionMode directionPreset;

	public OVRManager.TiledMultiResLevel foveatedRenderingLevel;

	public bool subtitlesEnabled;

	public bool hintsEnabled = true;

	public float seatingOffset;

	public bool seatingMode;

	public int[] volumeLevels = new int[3] { 5, 5, 5 };
}
public class STUB_ObeliskPuzzleGroup : MonoBehaviour
{
}
[Serializable]
public class FingerJoint : MonoBehaviour
{
	public FingerJoint parent;

	public FingerJoint child;

	public Transform pivot;

	public Transform model;

	public bool hit;

	public GrabTest hand;

	private Quaternion idleRotation;

	private IHaglet<float> rotateRoutine;

	public void SetIdleRotation()
	{
		idleRotation = pivot.rotation;
	}

	public void ResetToIdle(bool resetChild)
	{
		pivot.rotation = idleRotation;
		hit = false;
		if (resetChild && child != null)
		{
			child.ResetToIdle(resetChild);
		}
	}

	public void RotateJointAnim(float angle)
	{
		if (rotateRoutine == null)
		{
			Haglet.Create(out rotateRoutine, (Routine.Func1<float>)RotateRoutine, (string)null, startNow: false, (int?)null, (string)null);
		}
		rotateRoutine.Start(angle, resetIfStarted: true);
	}

	public bool IsRotating()
	{
		if (rotateRoutine == null)
		{
			return false;
		}
		bool flag = rotateRoutine.started;
		if (child != null)
		{
			flag |= child.IsRotating();
		}
		return flag;
	}

	public bool CanRotate()
	{
		bool flag = !hit;
		if (child != null)
		{
			flag &= child.CanRotate();
		}
		return flag;
	}

	private Vector3 GetRotationAxis()
	{
		Vector3 result = pivot.up;
		if (parent != null && parent.CanRotate())
		{
			result = parent.GetRotationAxis();
		}
		return result;
	}

	private bool CheckForContact()
	{
		Vector3 position = hand.GetTarget().ClosestPoint(pivot.position);
		if ((model.InverseTransformPoint(position) - model.localPosition).sqrMagnitude <= hand.gripTolerance)
		{
			return true;
		}
		if (child != null)
		{
			return child.CheckForContact();
		}
		return false;
	}

	private IEnumerator<Routine.Yield> RotateRoutine(float angle)
	{
		Quaternion startRotation = pivot.localRotation;
		Quaternion targetRotation = Quaternion.AngleAxis(angle, GetRotationAxis()) * pivot.localRotation;
		float timeMax = 1f / hand.gripSpeed;
		float animTime = 0f;
		while (animTime < timeMax && CanRotate())
		{
			yield return Wait.For.LRUpdates(1);
			animTime += IC.DeltaTime;
			float t = Mathf.Clamp01(animTime * hand.gripSpeed / timeMax);
			Quaternion localRotation = Quaternion.Lerp(startRotation, targetRotation, t);
			pivot.localRotation = localRotation;
			if (CheckForContact())
			{
				break;
			}
		}
		hit = true;
		if (child != null)
		{
			child.RotateJointAnim(angle);
		}
	}
}
public class GrabTest : MonoBehaviour
{
	[Serializable]
	private struct Finger
	{
		public FingerJoint root;

		public FingerJoint middle;

		public FingerJoint tip;
	}

	public bool curlFingers;

	public bool findFingers;

	public float gripTolerance = 0.5f;

	public float gripSpeed = 1f;

	[SerializeField]
	private Finger[] fingers;

	private Transform palm;

	private Collider palmCollider;

	private Collider targetCollider;

	private bool gripping;

	private void Start()
	{
		GetFingers();
		palm = base.transform.Find("Palm");
		palmCollider = palm.GetComponent<Collider>();
	}

	private void Update()
	{
		if (curlFingers)
		{
			Grip();
		}
		else
		{
			UnGrip();
		}
	}

	private void GetFingers()
	{
		Transform transform = base.transform.Find("Fingers");
		fingers = new Finger[transform.childCount];
		for (int i = 0; i < transform.childCount; i++)
		{
			Transform child = transform.GetChild(i);
			FingerJoint component = child.GetComponent<FingerJoint>();
			component.parent = null;
			component.pivot = transform.GetChild(i);
			component.model = component.pivot.GetChild(0);
			component.hand = this;
			component.SetIdleRotation();
			FingerJoint fingerJoint = (component.child = child.GetComponentInDirectChild<FingerJoint>());
			fingerJoint.parent = component;
			fingerJoint.pivot = component.pivot.GetChild(1);
			fingerJoint.model = fingerJoint.pivot.GetChild(0);
			fingerJoint.hand = this;
			fingerJoint.SetIdleRotation();
			FingerJoint fingerJoint2 = (fingerJoint.child = fingerJoint.pivot.GetComponentInDirectChild<FingerJoint>());
			fingerJoint2.parent = fingerJoint;
			fingerJoint2.pivot = fingerJoint.pivot.GetChild(1);
			fingerJoint2.model = fingerJoint2.pivot.GetChild(0);
			fingerJoint2.child = null;
			fingerJoint2.hand = this;
			fingerJoint2.SetIdleRotation();
			Finger finger = default(Finger);
			finger.root = component;
			finger.middle = fingerJoint;
			finger.tip = fingerJoint2;
			Finger finger2 = finger;
			fingers[i] = finger2;
		}
	}

	public Collider GetTarget()
	{
		return targetCollider;
	}

	[ContextMenu("Grip")]
	public void Grip()
	{
		if (gripping)
		{
			return;
		}
		gripping = true;
		Collider[] array = Physics.OverlapBox(palm.transform.position, palm.localScale, palm.rotation, -4097);
		targetCollider = null;
		float num = float.MaxValue;
		Collider[] array2 = array;
		foreach (Collider collider in array2)
		{
			float num2 = Vector3.Distance(palm.position, collider.transform.position);
			if (num2 < num)
			{
				targetCollider = collider;
				num = num2;
			}
		}
		RaycastHit hitInfo;
		if (targetCollider != null)
		{
			if (Physics.ComputePenetration(palmCollider, palmCollider.transform.position, palmCollider.transform.rotation, targetCollider, targetCollider.transform.position, targetCollider.transform.rotation, out var _, out var _) && Physics.BoxCast(palm.position - palm.right * 0.2f, palm.localScale, palm.right, out hitInfo, palm.rotation, 1f, -4097))
			{
				Vector3 vector = base.transform.InverseTransformPoint(hitInfo.point);
				Vector3 vector2 = base.transform.InverseTransformPoint(palm.position + palm.right * 0.01f);
				Vector3 vector3 = base.transform.InverseTransformPoint(targetCollider.transform.position);
				Vector3 vector4 = vector2 - vector;
				Vector3 position = vector3 + vector4;
				position = base.transform.TransformPoint(position);
				targetCollider.transform.position = position;
			}
		}
		else if (Physics.BoxCast(palm.position, palm.localScale, palm.right, out hitInfo, Quaternion.identity, 0.1f))
		{
			targetCollider = hitInfo.collider;
		}
		if (targetCollider == null)
		{
			return;
		}
		Finger[] array3 = fingers;
		for (int i = 0; i < array3.Length; i++)
		{
			Finger finger = array3[i];
			if (!finger.root.IsRotating() && finger.root.CanRotate())
			{
				finger.root.RotateJointAnim(90f);
			}
		}
	}

	[ContextMenu("UnGrip")]
	public void UnGrip()
	{
		Finger[] array = fingers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].root.ResetToIdle(resetChild: true);
		}
		gripping = false;
	}
}
public abstract class Hand : MonoBehaviour
{
	public struct FocusedGrabPointData
	{
		public GrabPoint grabPoint;

		public Portal portal;

		public bool focusGrab;
	}

	private struct GrabState
	{
		public bool onGrab;

		public bool onHold;

		public bool onRelease;
	}

	public struct HandTransform
	{
		public Vector3 worldPosition;

		public Quaternion worldRotation;
	}

	private static readonly string TRANSITION_EFFECT_ON = "TRANSITION_EFFECT_ON";

	private static readonly int _TransitionAmount = Shader.PropertyToID("_TransitionAmount");

	[NonSerialized]
	public FocusedGrabPointData lastFocusedGrabPointData;

	[NonSerialized]
	public FocusedGrabPointData currFocusedGrabPointData;

	[ReadOnly]
	public GrabPoint grabPointHighlighted;

	[ReadOnly]
	public GrabPoint grabPointHeld;

	[ReadOnly]
	public GrabPoint grabPointFocusGrabbed;

	[NonSerialized]
	public Vector3 heldObjectPosOffset;

	[NonSerialized]
	public Quaternion heldObjectRotOffset;

	[NonSerialized]
	public Transform renderingRoot;

	[NonSerialized]
	public SkinnedMeshRenderer handSMR;

	private TransformState lastState;

	[ReadOnly]
	public Portal portalFromHeadToHand;

	[ReadOnly]
	public Portal portalFromHandToObject;

	[ReadOnly]
	public Region region;

	private float grabTimestamp;

	private bool editorWaitingForGrabOnRelease;

	[ReadOnly]
	public MRBase owner;

	[ReadOnly]
	public Vector3 gravity;

	[HideInInspector]
	public Collider[] hitArray;

	public Texture2D handTexture;

	private PortalRenderer[] portalRenderers;

	private InteractableObject HACK_pickupOnPortalObject;

	private Stub_HandPalm handPalm;

	private MaterialPropertyBlock handPropertyBlock;

	private float handAlphaValue;

	private int handAlphaID;

	[SerializeField]
	private Bounds grabBounds;

	private bool didGrabSomethingThisFrame;

	private bool canGrabGrabObject = true;

	private HandAnimator[] handAnimators;

	private STUB_GhostHand ghostHand;

	private HagletTrigger preHeldObjectUpdateTrigger = new HagletTrigger();

	public HagletTrigger onGrabObject = new HagletTrigger();

	public HagletTrigger onUngrabObject = new HagletTrigger();

	[SerializeField]
	[Tooltip("Direct reference to PSs under the hand (RTF = Real To Fantasy & visa versa)")]
	private ParticleSystem transitionPS_RTF;

	[SerializeField]
	[Tooltip("Direct reference to PSs under the hand (RTF = Real To Fantasy & visa versa)")]
	private ParticleSystem transitionPS_FTR;

	[SerializeField]
	[Tooltip("Direct reference to PSs under the hand (RTF = Real To Fantasy & visa versa)")]
	private ParticleSystem grabPS;

	private bool portaledLastFrame;

	private IHaglet<GrabPoint, bool> moveToHandRoutine;

	private IHaglet<Vector3, Quaternion> handKickbackRoutine;

	private IHaglet handGlowRoutine;

	private IHaglet<float, float, float, OVRInput.Controller> pulseHapticFeedbackRoutine;

	public bool IsHoldingPortal
	{
		get
		{
			InteractableObject interactableHeld = InteractableHeld;
			if ((bool)interactableHeld && interactableHeld is GrabObject && (bool)(interactableHeld as GrabObject).HACK_eyeglassPortal)
			{
				return true;
			}
			if ((bool)InteractableFocusGrabbed && InteractableFocusGrabbed is GrabObject && (bool)(InteractableFocusGrabbed as GrabObject).HACK_eyeglassPortal)
			{
				return true;
			}
			return false;
		}
	}

	public abstract IC.Hand ICHand { get; }

	public abstract OVRInput.Controller OVRController { get; }

	public InteractableObject InteractableHeld
	{
		get
		{
			if (!(grabPointHeld == null))
			{
				return grabPointHeld.InteractableObject;
			}
			return null;
		}
	}

	public GrabObject GrabObjectHeld
	{
		get
		{
			if (!(grabPointHeld == null))
			{
				return grabPointHeld.InteractableObject as GrabObject;
			}
			return null;
		}
	}

	public InteractableObject InteractableFocusGrabbed
	{
		get
		{
			if (!(grabPointFocusGrabbed == null))
			{
				return grabPointFocusGrabbed.InteractableObject;
			}
			return null;
		}
	}

	public InteractableObject InteractableHighlighted
	{
		get
		{
			if (!(grabPointHighlighted == null))
			{
				return grabPointHighlighted.InteractableObject;
			}
			return null;
		}
	}

	public void OnAwakeLR()
	{
		ghostHand = GetComponentInChildren<STUB_GhostHand>();
		ToggleGhostHand(enabled: false);
		renderingRoot = base.transform.GetChild(0);
		handSMR = renderingRoot.GetComponentInChildren<SkinnedMeshRenderer>(includeInactive: true);
		lastState = new TransformState(base.transform);
		handPalm = GetComponentInChildren<Stub_HandPalm>(includeInactive: true);
		hitArray = new Collider[10];
		portalRenderers = GetComponentsInChildren<PortalRenderer>();
		PortalRenderer[] array = portalRenderers;
		foreach (PortalRenderer portalRenderer in array)
		{
			if (portalRenderer != null)
			{
				portalRenderer.OnAwakeLR();
			}
		}
		handPropertyBlock = new MaterialPropertyBlock();
		Haglet.Create(out moveToHandRoutine, (Routine.Func2<GrabPoint, bool>)MoveToHandRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out handKickbackRoutine, (Routine.Func2<Vector3, Quaternion>)HandKickbackRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out handGlowRoutine, HandGlowRoutine);
		Haglet.Create(out pulseHapticFeedbackRoutine, (Routine.Func4<float, float, float, OVRInput.Controller>)PulseHapticFeedbackRoutine, (string)null, startNow: false, (int?)null, (string)null);
		handAlphaID = Shader.PropertyToID("_AlphaLevel");
		handAnimators = base.gameObject.GetComponents<HandAnimator>();
		HandAnimator[] array2 = handAnimators;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].OnAwakeLR(this);
		}
	}

	private void ToggleGhostHand(bool enabled)
	{
		if ((bool)ghostHand)
		{
			ghostHand.gameObject.SetActive(enabled);
		}
	}

	public void OnUpdateLR()
	{
		HandAnimator[] array = handAnimators;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].OnUpdateLR();
		}
	}

	public void OnLateUpdateLR()
	{
		Vector3 worldPosition = handSMR.bounds.ClosestPoint(MainCamera.Inst.transform.position);
		InteractionSettings inst = BaseSettings<InteractionSettings>.Inst;
		float value = MainCamera.CalculateHeadDitherStrength(worldPosition, inst.nearFadeHandDistMin, inst.nearFadeHandDistMax);
		handPropertyBlock.SetFloat(ShaderPID._DitherAlphaValue, value);
		handSMR.SetPropertyBlock(handPropertyBlock);
	}

	public void TriggerTransition(bool toFantasy)
	{
		TeleportSettings inst = BaseSettings<TeleportSettings>.Inst;
		PulseHapticFeedback(inst.transitionHapticFreq, inst.transitionHapticAmp, inst.transitionHapticTime, this);
		FMODEventAsset asset = (toFantasy ? BaseSettings<InteractionSettings>.Inst.sfxHandEnterIllyria : BaseSettings<InteractionSettings>.Inst.sfxHandExitIllyria);
		FAC.Inst.PlayOneShot(asset, base.transform);
		if (toFantasy)
		{
			transitionPS_FTR?.Stop(withChildren: true);
			transitionPS_RTF?.Play(withChildren: true);
		}
		else
		{
			transitionPS_RTF?.Stop(withChildren: true);
			transitionPS_FTR?.Play(withChildren: true);
		}
		CC.Inst.TriggerTransition(toFantasy, handSMR, handPropertyBlock, null);
	}

	private GrabState GetGrabState()
	{
		IC.IHandInput inputForHand = IC.GetInputForHand(ICHand);
		GrabState result = default(GrabState);
		result.onGrab = inputForHand.GetGripDown() || inputForHand.GetTriggerDown();
		result.onHold = inputForHand.GetGripHeld() || inputForHand.GetTriggerHeld();
		result.onRelease = (inputForHand.GetGripUp() && !inputForHand.GetTriggerHeld()) || (inputForHand.GetTriggerUp() && !inputForHand.GetGripHeld());
		return result;
	}

	public HandTransform GetHandGrabTransform()
	{
		HandTransform result = default(HandTransform);
		result.worldPosition = transform.TransformPoint(heldObjectPosOffset);
		result.worldRotation = transform.rotation * heldObjectRotOffset;
		UnityEngine.Debug.DrawLine(transform.position, result.worldPosition, Color.magenta);
		return result;
	}

	public HandTransform GetHandGrabTransform(HandTransform customOffset)
	{
		HandTransform result = default(HandTransform);
		result.worldPosition = transform.TransformPoint(customOffset.worldPosition);
		result.worldRotation = transform.rotation * customOffset.worldRotation;
		return result;
	}

	public FocusedGrabPointData UpdateHandFocusAndGrab()
	{
		GrabState grabState = GetGrabState();
		didGrabSomethingThisFrame = false;
		_ = base.transform;
		if (editorWaitingForGrabOnRelease)
		{
			editorWaitingForGrabOnRelease = !grabState.onRelease;
		}
		FocusedGrabPointData focusedGrabPointData = default(FocusedGrabPointData);
		focusedGrabPointData.grabPoint = null;
		focusedGrabPointData.portal = null;
		focusedGrabPointData.focusGrab = false;
		if (canGrabGrabObject && !moveToHandRoutine.started && !InteractableHeld)
		{
			focusedGrabPointData.grabPoint = FindTargettedGrabPointInGrabRadius();
			if (!focusedGrabPointData.grabPoint)
			{
				focusedGrabPointData.grabPoint = FindFocusedGrabPoint(out var portal);
				focusedGrabPointData.portal = (portalFromHandToObject = portal);
				focusedGrabPointData.focusGrab = true;
			}
			if ((bool)focusedGrabPointData.grabPoint && (grabState.onGrab || grabState.onHold) && !editorWaitingForGrabOnRelease)
			{
				InteractableObject interactableObject = focusedGrabPointData.grabPoint.InteractableObject;
				grabPS.Play();
				handGlowRoutine.Start(resetIfStarted: true);
				EGrill nearestGrill = null;
				InventoryObject inventoryObject = interactableObject as InventoryObject;
				bool flag = EGrill.GetNearestEGrill(base.transform.position, owner, out nearestGrill) < 1f;
				if (interactableObject.CanBeFocusGrabbed() && !flag)
				{
					TryMoveToHand(focusedGrabPointData.grabPoint, focusedGrabPointData.portal, focusedGrabPointData.focusGrab);
				}
				else if (inventoryObject == null || inventoryObject.ValidEGRillIndex == PlayerInventory.Inst.CurrentEGrillIndex)
				{
					GrabObject(focusedGrabPointData.grabPoint);
					didGrabSomethingThisFrame = true;
				}
			}
		}
		FocusedGrabPointData result = ((InteractableHeld != null) ? default(FocusedGrabPointData) : focusedGrabPointData);
		grabPointHighlighted = result.grabPoint;
		return result;
	}

	public void UpdateHighlight()
	{
		if (currFocusedGrabPointData.grabPoint != lastFocusedGrabPointData.grabPoint)
		{
			if ((bool)lastFocusedGrabPointData.grabPoint)
			{
				lastFocusedGrabPointData.grabPoint.OnHighlightExit(this);
			}
			if ((bool)currFocusedGrabPointData.grabPoint)
			{
				currFocusedGrabPointData.grabPoint.OnHighlightEnter(this, currFocusedGrabPointData.portal);
			}
		}
		else if ((bool)currFocusedGrabPointData.grabPoint)
		{
			currFocusedGrabPointData.grabPoint.OnHighlightStay(this, currFocusedGrabPointData.portal);
		}
	}

	private GrabPoint FindTargettedGrabPointInGrabRadius()
	{
		Transform transform = base.transform;
		int num = Physics.OverlapBoxNonAlloc(transform.TransformPoint(grabBounds.center), grabBounds.extents, hitArray, transform.rotation, -4097, QueryTriggerInteraction.Collide);
		Vector3 position = transform.position;
		GrabPoint result = null;
		float num2 = float.MaxValue;
		for (int i = 0; i < num; i++)
		{
			Collider collider = hitArray[i];
			if (collider.transform.parent == transform)
			{
				continue;
			}
			InteractableObject componentInAscendant = collider.GetComponentInAscendant<InteractableObject>();
			if (!componentInAscendant || !componentInAscendant.CanGrab(this))
			{
				continue;
			}
			bool flag = componentInAscendant is InventoryObject;
			for (int j = 0; j < componentInAscendant.grabPoints.Length; j++)
			{
				GrabPoint grabPoint = componentInAscendant.grabPoints[j];
				if ((flag && grabPoint.ignoreOnInventoryObject) || !grabPoint.IsValid(this))
				{
					continue;
				}
				Vector3 position2 = grabPoint.transform.position;
				if (!grabPoint.InteractableObject.CanBeFocusGrabbed())
				{
					Vector3 forward = grabPoint.transform.forward;
					Vector3 forward2 = base.transform.forward;
					if (Vector3.Dot(forward, forward2) < 0f)
					{
						continue;
					}
				}
				Vector3 headPosition = IC.GetHeadPosition();
				Vector3 vector = componentInAscendant.transform.position - headPosition;
				float magnitude = vector.magnitude;
				Vector3 normalized = vector.normalized;
				if (!EGrill.RaycastGetClosest(owner, headPosition, normalized, magnitude, out var _, out var _))
				{
					float magnitude2 = (position2 - position).magnitude;
					float num3 = Quaternion.Angle(base.transform.rotation, grabPoint.transform.rotation) * magnitude2;
					if (num3 < num2)
					{
						num2 = num3;
						result = grabPoint;
					}
				}
			}
		}
		for (int k = 0; k < hitArray.Length; k++)
		{
			hitArray[k] = null;
		}
		return result;
	}

	public void TryMoveToHand(GrabPoint grabPointTarget, Portal portalFromBeginToObject, bool isFocusGrabbed)
	{
		if (!moveToHandRoutine.started)
		{
			moveToHandRoutine.Start(grabPointTarget, isFocusGrabbed);
		}
	}

	public void UpdateHandSingle()
	{
		GrabState grabState = GetGrabState();
		if ((bool)InteractableHeld && !InteractableHeld.CanHold(this))
		{
			UngrabObject();
		}
		if (!grabState.onHold)
		{
			canGrabGrabObject = true;
		}
		if (!InteractableHeld)
		{
			return;
		}
		if (!moveToHandRoutine.started)
		{
			InteractableHeld.OnGrabStayed(this);
		}
		if (IC.isHmdPresent)
		{
			if (!grabState.onHold)
			{
				UngrabObject(this);
			}
		}
		else if (!didGrabSomethingThisFrame && grabState.onGrab)
		{
			UngrabObject();
			editorWaitingForGrabOnRelease = !grabState.onRelease;
		}
	}

	public void EvaluateMovement(Portal portalHeadEntered, MainCamera head, CC.MovementType movementType = CC.MovementType.None)
	{
		_ = InteractableHeld;
		GrabObject grabObject = InteractableHeld as GrabObject;
		PortalingRigidbody portalingRigidbody = null;
		if ((bool)grabObject)
		{
			portalingRigidbody = grabObject.pr;
		}
		bool flag = false;
		int grabPointIdx = 0;
		HandTransform customOffset = default(HandTransform);
		bool flag2 = (movementType == CC.MovementType.FreeMove || movementType == CC.MovementType.Teleport) && (bool)portalHeadEntered;
		bool flag3 = false;
		if (!IsHoldingPortal)
		{
			Portal portalOut = null;
			if (Portal.RaycastPortal(head.transform.position, base.transform.position, out portalOut) && portalOut.Link != null)
			{
				flag3 = true;
				if (portalOut.changesGravity)
				{
					gravity = portalOut.GravityDirection;
				}
				bool flag4 = owner != portalOut.Link.owner;
				if (flag4)
				{
					SetOwner(portalOut.Link.owner);
				}
				bool flag5 = portalFromHeadToHand == null;
				if ((bool)grabObject)
				{
					if (flag4 && !flag2 && (bool)grabObject.mimic && CheckForMimicSwap(portalHeadEntered != null, flag5, portalOut))
					{
						flag = true;
					}
					else if (portalOut != portalFromHeadToHand && portalHeadEntered == null)
					{
						portalOut.TeleportObject(grabObject.pr, allowDisallowedObjects: true);
					}
				}
				if (moveToHandRoutine.started && flag5)
				{
					if ((bool)portalHeadEntered)
					{
						portalFromHandToObject = ((!portalFromHandToObject) ? portalOut : null);
					}
					else
					{
						portalFromHandToObject = ((!portalFromHandToObject) ? portalOut.Link : null);
					}
				}
				portalFromHeadToHand = portalOut;
			}
			else
			{
				gravity = -CC.Inst.transform.up;
				MRBase mRBase = MainCamera.Inst.GetOwner();
				bool flag6 = owner != mRBase;
				if (flag6)
				{
					SetOwner(mRBase);
				}
				bool flag7 = portalFromHeadToHand != null;
				if ((bool)grabObject)
				{
					if (flag2)
					{
						if (portalHeadEntered != portalFromHeadToHand)
						{
							portalHeadEntered.TeleportObject(grabObject.pr, allowDisallowedObjects: true);
						}
					}
					else if (flag6 && (bool)grabObject.mimic && CheckForMimicSwap(portalHeadEntered != null, flag7, null))
					{
						flag = true;
					}
					else if ((bool)portalFromHeadToHand && portalHeadEntered == null)
					{
						portalFromHeadToHand.Link.TeleportObject(grabObject.pr, allowDisallowedObjects: true);
					}
					else if (mRBase != grabObject.pr.GetOwner())
					{
						grabObject.pr.SetOwner(mRBase);
					}
				}
				if (moveToHandRoutine.started)
				{
					if (flag2)
					{
						portalFromHandToObject = null;
					}
					else if ((flag7 && !portalHeadEntered) || (!flag7 && (bool)portalHeadEntered))
					{
						portalFromHandToObject = ((!portalFromHandToObject) ? portalFromHeadToHand : null);
					}
				}
				portalFromHeadToHand = null;
			}
		}
		else
		{
			gravity = -CC.Inst.transform.up;
			MRBase mRBase2 = MainCamera.Inst.GetOwner();
			if (owner != mRBase2)
			{
				SetOwner(mRBase2);
				if ((bool)portalHeadEntered)
				{
					flag = true;
				}
				else
				{
					grabObject.pr.SetOwner(mRBase2);
				}
			}
			portalFromHeadToHand = null;
		}
		flag &= !handKickbackRoutine.started;
		if (flag)
		{
			customOffset.worldPosition = heldObjectPosOffset;
			customOffset.worldRotation = heldObjectRotOffset;
			grabPointIdx = grabPointHeld.GetIndex();
			UngrabObject(grabObject);
			grabObject.mimic.SwapControl();
			grabObject = grabObject.mimic.GrabObjectMimic;
			portalingRigidbody = grabObject.pr;
		}
		if ((bool)portalFromHeadToHand)
		{
			Portal.PortalTransform portalTransform = portalFromHeadToHand.CalculatePortalObjectTransform(base.transform.position, base.transform.rotation, Vector3.zero);
			base.transform.position = portalTransform.position;
			base.transform.rotation = portalTransform.rotation;
		}
		preHeldObjectUpdateTrigger.Trigger();
		if ((bool)portalingRigidbody)
		{
			HandTransform ht = (flag ? GetHandGrabTransform(customOffset) : GetHandGrabTransform());
			bool updateLastState = flag3 || (portaledLastFrame && !flag3);
			MoveRidgidbodyToHand(portalingRigidbody, ht, movementType, updateLastState);
		}
		portaledLastFrame = flag3;
		if (flag && (bool)grabObject)
		{
			GrabPoint focusGrabPoint = grabObject.GetFocusGrabPoint(grabPointIdx);
			GrabObject(focusGrabPoint);
		}
	}

	public void MoveRidgidbodyToHand(PortalingRigidbody pr, HandTransform ht, CC.MovementType movementType, bool updateLastState)
	{
		preHeldObjectUpdateTrigger.Trigger();
		GrabObject grabObject = pr.grabObject;
		if ((bool)grabObject)
		{
			grabObject.SetPositionAndRotation(ht.worldPosition, ht.worldRotation, movementType);
			if (updateLastState)
			{
				grabObject.UpdatePhysicsState();
				grabObject.GetLastState().UpdateToLatestState();
			}
		}
		if (grabObject == null && (bool)pr)
		{
			pr.SetVelocityLinear(Vector3.zero);
			pr.SetPositionAndRotation(ht.worldPosition, ht.worldRotation);
		}
	}

	private void UpdateHandPositionToInteractableObject()
	{
		InteractableHeld.SetHandGrabTransform(this);
	}

	public void OnPostPhysicsUpdateLR()
	{
		if (InteractableHeld != null)
		{
			GrabObject grabObject = InteractableHeld as GrabObject;
			if ((bool)grabObject)
			{
				ToggleGhostHand(grabObject.InCollision);
				UpdateHandPositionToInteractableObject();
			}
			else
			{
				ToggleGhostHand(enabled: false);
				UpdateHandPositionToInteractableObject();
			}
		}
		else
		{
			ToggleGhostHand(enabled: false);
			renderingRoot.localPosition = Vector3.zero;
			renderingRoot.localRotation = Quaternion.identity;
		}
		lastState.UpdateToLatestState();
	}

	public void ForceUpdateToLatestState()
	{
		GrabObject grabObject = InteractableHeld as GrabObject;
		if (!grabObject)
		{
			grabObject = InteractableFocusGrabbed as GrabObject;
		}
		if ((bool)grabObject)
		{
			if ((bool)grabObject.HACK_eyeglassPortal)
			{
				grabObject.HACK_eyeglassPortal.GetLastState().UpdateToLatestState();
			}
			grabObject.ForceUpdateLastState();
		}
		lastState.UpdateToLatestState();
	}

	public void OnPositionReplace()
	{
		GrabObject grabObject = InteractableHeld as GrabObject;
		if (!grabObject)
		{
			grabObject = InteractableFocusGrabbed as GrabObject;
		}
		if ((bool)grabObject)
		{
			grabObject.OnPositionReplace();
		}
	}

	public Transform GetModelTransform()
	{
		return handSMR.transform.parent;
	}

	public TransformState GetLastState()
	{
		return lastState;
	}

	private IEnumerator<Routine.Yield> MoveToHandRoutine(GrabPoint grabPointTarget, bool isFocusGrabbed)
	{
		Hand hand = this;
		bool grabbedFromInventory = false;
		InteractableObject interactable = grabPointTarget.InteractableObject.OnFocusGrab(hand, out grabbedFromInventory);
		if (!grabPointTarget.InteractableObject.CanBeFocusGrabbed())
		{
			yield break;
		}
		grabPointFocusGrabbed = interactable.grabPoints[grabPointTarget.GetIndex()];
		hand.canGrabGrabObject = false;
		UngrabObject(grabPointFocusGrabbed.InteractableObject);
		GrabObject grabObject = interactable as GrabObject;
		InteractionSettings settings = BaseSettings<InteractionSettings>.Inst;
		if ((bool)grabObject.HACK_eyeglassPortal)
		{
			grabObject.HACK_eyeglassPortal.SetUnlockedState(unlocked: false);
		}
		hand.heldObjectPosOffset = Vector3.zero;
		hand.heldObjectRotOffset = Quaternion.identity;
		Vector3 beginPosition = grabPointFocusGrabbed.transform.position;
		Quaternion beginRotation = grabPointFocusGrabbed.transform.rotation;
		Vector3 postPortalBeginPosition = beginPosition;
		Quaternion postPortalBeginRotation = beginRotation;
		hand.GetHandPalmPosition();
		_ = hand.transform.rotation;
		_ = Vector3.zero;
		_ = Quaternion.identity;
		float timeMax = (isFocusGrabbed ? BaseSettings<InteractionSettings>.Inst.focusGrabAnimTime : BaseSettings<InteractionSettings>.Inst.focusGrabAnimTimeGrabbed);
		float time = 0f;
		Transform grabDirXForm = base.transform.Find("GrabDirection");
		int rayLayerMask = 1024;
		LR.RayTransformWithPortals(new Ray(grabDirXForm.position, grabDirXForm.forward), settings.focusGrabMaxDistance, rayLayerMask);
		if ((bool)portalFromHandToObject && portalFromHandToObject.objectTeleportOnEnter)
		{
			Portal.PortalTransform portalTransform = portalFromHandToObject.Link.CalculatePortalObjectTransform(beginPosition, beginRotation, Vector3.zero);
			postPortalBeginPosition = portalTransform.position;
			postPortalBeginRotation = portalTransform.rotation;
		}
		if (isFocusGrabbed)
		{
			FAC.Inst.PlayOneShot(settings.sfxMove, hand.transform);
		}
		bool grabRumbleActive = false;
		AnimationCurve curve = (isFocusGrabbed ? BaseSettings<InteractionSettings>.Inst.focusGrabCurve : BaseSettings<InteractionSettings>.Inst.focusGrabCurveGrabbed);
		_ = interactable.transform;
		Transform grabPointXForm = grabPointFocusGrabbed.transform;
		bool goingThroughPortal = portalFromHandToObject;
		Portal targetPortal = portalFromHandToObject;
		while (time < timeMax)
		{
			interactable.OnFocusGrabbing(hand);
			yield return Wait.For.LRPostPhysicsUpdates(1);
			time += IC.DeltaTime;
			float num = Mathf.Clamp01(time / timeMax);
			Vector3 vector = hand.GetHandPalmPosition();
			Quaternion rotation = hand.transform.rotation;
			LR.RayPortalResult rayPortalResult = LR.RayTransformWithPortals(new Ray(grabDirXForm.position, grabDirXForm.forward), settings.focusGrabMaxDistance, rayLayerMask);
			if (!targetPortal && (bool)portalFromHandToObject)
			{
				goingThroughPortal = true;
			}
			targetPortal = portalFromHandToObject;
			bool flag = goingThroughPortal && !portalFromHandToObject;
			if (goingThroughPortal && !flag)
			{
				if (!(rayPortalResult.portal == targetPortal))
				{
					portalFromHandToObject.Link.TeleportObject(grabObject.pr);
					interactable.SetPositionAndRotationForGrabPoint(grabPointXForm, hand.transform.position, hand.transform.rotation, CC.MovementType.Teleport);
					UnityEngine.Debug.Log("Lost connection to portal, teleporting object to hand!", base.gameObject);
					break;
				}
				Portal.PortalTransform portalTransform2 = portalFromHandToObject.CalculatePortalObjectTransform(vector, rotation, Vector3X.zero);
				vector = portalTransform2.position;
				rotation = portalTransform2.rotation;
			}
			Vector3 position = MainCamera.Inst.transform.position;
			Vector3 vector2 = hand.transform.position - position;
			if (EGrill.RaycastGetClosest(owner, MainCamera.Inst.transform.position, vector2.normalized, vector2.magnitude, out var _, out var _))
			{
				grabObject.OnFocusGrabCancelled(hand);
				grabPointFocusGrabbed = null;
				break;
			}
			beginPosition = (flag ? postPortalBeginPosition : beginPosition);
			beginRotation = (flag ? postPortalBeginRotation : beginRotation);
			float t = curve.Evaluate(num);
			Vector3 worldPosition = Vector3.Lerp(beginPosition, vector, t);
			Quaternion rotation2 = Quaternion.Lerp(beginRotation, rotation, t);
			interactable.SetPositionAndRotationForGrabPoint(grabPointXForm, worldPosition, rotation2);
			if (isFocusGrabbed && (double)num >= 0.95 && !grabRumbleActive)
			{
				PulseHapticFeedback(settings.focusGrabHapticFreq, settings.focusGrabHapticAmp, settings.focusGrabHapticDuration, OVRController);
				grabRumbleActive = true;
			}
		}
		if (!grabPointFocusGrabbed)
		{
			yield break;
		}
		interactable.OnFocusGrabbing(hand);
		if ((bool)portalFromHandToObject || (((bool)portalFromHandToObject || (bool)portalFromHeadToHand) && owner != grabObject.owner))
		{
			Portal portal = (portalFromHandToObject ? portalFromHandToObject : portalFromHeadToHand);
			if (grabObject.owner != owner)
			{
				grabObject.pr.SetOwner(owner);
			}
			grabObject.pr.OnEnterPortal(portal);
			grabObject.SetPositionAndRotationForGrabPoint(grabPointXForm, hand.transform.position, hand.transform.rotation, CC.MovementType.Teleport);
		}
		hand.GrabObject(grabPointFocusGrabbed, grabbedFromInventory);
		if ((bool)grabObject.HACK_eyeglassPortal)
		{
			grabObject.HACK_eyeglassPortal.SetUnlockedState(unlocked: true);
		}
		if (isFocusGrabbed)
		{
			yield return handKickbackRoutine.Call(interactable.transform.position, interactable.transform.rotation);
		}
	}

	private IEnumerator<Routine.Yield> HandKickbackRoutine(Vector3 resetPosition, Quaternion resetRotation)
	{
		InteractionSettings settings = BaseSettings<InteractionSettings>.Inst;
		Hand hand = this;
		hand.GetModelTransform();
		Vector3 axis = ((ICHand == IC.Hand.Left) ? (-Vector3.up) : Vector3.up);
		float num = 0f;
		InteractableObject obj = hand.InteractableHeld;
		Vector3 localPositionOffset = -Vector3.forward * settings.kickbackDistance;
		Quaternion localRotationOffset = Quaternion.AngleAxis(settings.kickbackAngle, axis);
		float startTime = IC.Time;
		while (num <= settings.kickbackDuration)
		{
			yield return preHeldObjectUpdateTrigger;
			num = IC.Time - startTime;
			float time = Mathf.InverseLerp(0f, settings.kickbackDuration, num);
			float t = settings.focusGrabKickBackCurve.Evaluate(time);
			Vector3 position = Vector3.Lerp(Vector3.zero, localPositionOffset, t);
			Quaternion localRotation = Quaternion.Lerp(Quaternion.identity, localRotationOffset, t);
			Vector3 position2 = hand.transform.TransformPoint(position);
			Quaternion rotation = hand.transform.rotation.TransformRotation(localRotation);
			hand.transform.position = position2;
			hand.transform.rotation = rotation;
		}
		if ((bool)portalFromHandToObject)
		{
			GrabObject grabObject = obj as GrabObject;
			portalFromHandToObject.Link.TeleportObject(grabObject.pr);
		}
	}

	private GrabPoint FindFocusedGrabPoint(out Portal portalFromHandToObject)
	{
		GrabPoint result = null;
		portalFromHandToObject = null;
		Transform transform = base.transform.Find("GrabDirection");
		InteractionSettings inst = BaseSettings<InteractionSettings>.Inst;
		Ray ray = new Ray(transform.position, transform.forward);
		int layerMask = 132097;
		LR.RayPortalResult rayPortalResult = LR.RayTransformWithPortals(ray, inst.focusGrabMaxDistance, layerMask);
		if ((bool)rayPortalResult.portal)
		{
			MRBase mRBase = rayPortalResult.portal.Link.owner;
			GrabPoint grabPoint = FindFocusedGrabPointInScene(owner, this, ray, inst.focusGrabMaxDistance - rayPortalResult.length);
			GrabPoint grabPoint2 = FindFocusedGrabPointInScene(mRBase, this, rayPortalResult.ray, rayPortalResult.length);
			float focusGrabAnglePriority = inst.focusGrabAnglePriority;
			float focusGrabDistancePriority = inst.focusGrabDistancePriority;
			if (grabPoint == null && grabPoint2 == null)
			{
				return null;
			}
			if (grabPoint != null && grabPoint2 != null)
			{
				Vector3 from = grabPoint.transform.position - ray.origin;
				float num = Vector3.Angle(from, ray.direction);
				float magnitude = from.magnitude;
				float num2 = num * focusGrabAnglePriority * (magnitude * focusGrabDistancePriority);
				float num3 = float.MaxValue;
				Vector3 from2 = grabPoint2.transform.position - rayPortalResult.ray.origin;
				float num4 = Vector3.Angle(from2, rayPortalResult.ray.direction);
				float magnitude2 = from2.magnitude;
				num3 = num4 * focusGrabAnglePriority * (magnitude2 * focusGrabDistancePriority);
				if (num2 < num3)
				{
					portalFromHandToObject = rayPortalResult.portal;
					result = grabPoint2;
				}
				else
				{
					result = grabPoint;
				}
			}
			else if (grabPoint != null)
			{
				result = grabPoint;
			}
			else if (grabPoint2 != null)
			{
				portalFromHandToObject = rayPortalResult.portal;
				result = grabPoint2;
			}
		}
		else
		{
			result = FindFocusedGrabPointInScene(owner, this, ray, inst.focusGrabMaxDistance);
		}
		return result;
	}

	private static GrabPoint FindFocusedGrabPointInScene(MRBase owner, Hand hand, Ray handRay, float remainingDistance)
	{
		if (owner.interactableObjects == null)
		{
			return null;
		}
		InteractionSettings inst = BaseSettings<InteractionSettings>.Inst;
		float num = remainingDistance * remainingDistance;
		float focusGrabDistancePriority = inst.focusGrabDistancePriority;
		float focusGrabMaxAngle = inst.focusGrabMaxAngle;
		float focusGrabAnglePriority = inst.focusGrabAnglePriority;
		float focusGrabRaycastTolerance = inst.focusGrabRaycastTolerance;
		GrabPoint grabPoint = null;
		float num2 = float.MaxValue;
		ConstArray<InteractableObject> interactableObjects = owner.interactableObjects;
		uint length = interactableObjects.Length;
		for (int i = 0; i < length; i++)
		{
			InteractableObject interactableObject = interactableObjects._data[i];
			if (!interactableObject || !interactableObject.CanBeFocusGrabbed() || !interactableObject.CanGrab(hand) || CC.Inst.IsObjectGrabbedOrFocusGrabbed(interactableObject) || (interactableObject.transform.position - handRay.origin).sqrMagnitude - interactableObject.furthestGrabPointDistSqr > num)
			{
				continue;
			}
			Vector3 headPosition = IC.GetHeadPosition();
			Vector3 vector = interactableObject.transform.position - headPosition;
			float magnitude = vector.magnitude;
			Vector3 normalized = vector.normalized;
			if (EGrill.RaycastGetClosest(owner, headPosition, normalized, magnitude, out var distance, out var grillFound))
			{
				if ((bool)grabPoint && grabPoint.InteractableObject == interactableObject)
				{
					grabPoint = null;
					num2 = float.MaxValue;
				}
				continue;
			}
			GrabObject grabObject = interactableObject as GrabObject;
			if ((bool)grabObject)
			{
				vector = grabObject.GetLastState().position - headPosition;
				magnitude = vector.magnitude;
				normalized = vector.normalized;
				if (EGrill.RaycastGetClosest(owner, headPosition, normalized, magnitude, out distance, out grillFound))
				{
					if ((bool)grabPoint && grabPoint.InteractableObject == interactableObject)
					{
						grabPoint = null;
						num2 = float.MaxValue;
					}
					continue;
				}
			}
			bool flag = true;
			Vector3 position = interactableObject.transform.position;
			Ray ray = new Ray(handRay.origin, position - handRay.origin);
			Ray ray2 = new Ray(position, handRay.origin - position);
			float sqrMagnitude = (position - handRay.origin).sqrMagnitude;
			if (Physics.Raycast(ray, sqrMagnitude, 1, QueryTriggerInteraction.Ignore) || Physics.Raycast(ray2, sqrMagnitude, 1, QueryTriggerInteraction.Ignore))
			{
				flag = false;
			}
			bool flag2 = interactableObject is InventoryObject;
			for (int j = 0; j < interactableObject.grabPoints.Length; j++)
			{
				GrabPoint grabPoint2 = interactableObject.grabPoints[j];
				if ((flag2 && grabPoint2.ignoreOnInventoryObject) || !grabPoint2.IsValid(hand))
				{
					continue;
				}
				Vector3 position2 = grabPoint2.transform.position;
				float sqrMagnitude2 = (position2 - handRay.origin).sqrMagnitude;
				if (sqrMagnitude2 > num)
				{
					continue;
				}
				Ray ray3 = new Ray(handRay.origin, position2 - handRay.origin);
				ray2 = new Ray(position2, handRay.origin - position2);
				float num3 = Vector3.Angle(ray3.direction, handRay.direction);
				if (num3 > focusGrabMaxAngle)
				{
					continue;
				}
				float num4 = Mathf.Sqrt(sqrMagnitude2);
				float num5 = num3 * focusGrabAnglePriority * (num4 * focusGrabDistancePriority);
				if (num5 > num2)
				{
					continue;
				}
				if (!flag)
				{
					float maxDistance = num4 - focusGrabRaycastTolerance;
					if (Physics.Raycast(ray2, maxDistance, 1, QueryTriggerInteraction.Ignore))
					{
						continue;
					}
				}
				if (EGrill.RaycastGetClosest(owner, ray3, num4, out var distance2, out var grillFound2))
				{
					if ((bool)grabPoint && grabPoint.InteractableObject == interactableObject)
					{
						grabPoint = null;
						num2 = float.MaxValue;
					}
					break;
				}
				Vector3 headPosition2 = IC.GetHeadPosition();
				Vector3 vector2 = grabPoint2.InteractableObject.transform.position - headPosition2;
				float magnitude2 = vector2.magnitude;
				Vector3 normalized2 = vector2.normalized;
				if (EGrill.RaycastGetClosest(owner, headPosition2, normalized2, magnitude2, out distance2, out grillFound2))
				{
					if ((bool)grabPoint && grabPoint.InteractableObject == interactableObject)
					{
						grabPoint = null;
						num2 = float.MaxValue;
					}
					break;
				}
				grabPoint = grabPoint2;
				num2 = num5;
			}
		}
		return grabPoint;
	}

	public void GrabObject(GrabPoint targetGrabPoint, bool grabbedFromInventory = false, bool grabParent = false)
	{
		bool isSwappingHand = false;
		Hand handObjectIsGrabbed = CC.Inst.GetHandObjectIsGrabbed(targetGrabPoint.InteractableObject);
		if ((bool)handObjectIsGrabbed && handObjectIsGrabbed.InteractableHeld == targetGrabPoint.InteractableObject)
		{
			handObjectIsGrabbed.editorWaitingForGrabOnRelease = true;
			isSwappingHand = true;
			handObjectIsGrabbed.UngrabObject(shouldInformObject: false);
		}
		targetGrabPoint = targetGrabPoint.OnGrabEnter(this, grabbedFromInventory, isSwappingHand, grabParent);
		heldObjectPosOffset = targetGrabPoint.transform.InverseTransformPoint(targetGrabPoint.InteractableObject.transform.position);
		heldObjectRotOffset = Quaternion.Inverse(targetGrabPoint.transform.rotation) * targetGrabPoint.InteractableObject.transform.rotation;
		grabPointHeld = targetGrabPoint;
		grabPointFocusGrabbed = null;
		canGrabGrabObject = false;
		grabTimestamp = IC.Time;
		onGrabObject.Trigger();
	}

	public static void UngrabObject(InteractableObject interactable)
	{
		Hand handObjectIsGrabbed = CC.Inst.GetHandObjectIsGrabbed(interactable);
		if ((bool)handObjectIsGrabbed)
		{
			handObjectIsGrabbed.UngrabObject();
		}
	}

	public void UngrabObject(bool shouldInformObject = true)
	{
		InteractableObject interactableHeld = InteractableHeld;
		if (interactableHeld == null)
		{
			return;
		}
		GrabObject grabObject = interactableHeld as GrabObject;
		_ = InteractableFocusGrabbed;
		grabPointHeld.OnGrabExit();
		grabPointHeld = null;
		heldObjectPosOffset = Vector3.zero;
		if ((bool)grabObject && !grabObject.HACK_eyeglassPortal)
		{
			Portal portalOut = null;
			if (Portal.RaycastPortal(base.transform.position, grabObject.transform.position, out portalOut))
			{
				portalOut.TeleportObject(grabObject.pr, allowDisallowedObjects: true);
				grabObject.GetLastState().UpdateToLatestState();
				grabObject.GetLastPhysicsState().UpdateToLatestState();
			}
			InteractionSettings inst = BaseSettings<InteractionSettings>.Inst;
			PulseHapticFeedback(inst.dropHapticFreq, inst.dropHapticAmp, inst.dropHapticDuration, OVRController);
		}
		if (shouldInformObject)
		{
			interactableHeld.OnGrabExit(this);
		}
		if ((bool)owner)
		{
			owner.ReevaluateHelpers();
		}
		onUngrabObject.Trigger();
	}

	public MRBase GetOwner()
	{
		return owner;
	}

	public void SetOwner(MRBase newOwner)
	{
		if (!(owner != newOwner))
		{
			return;
		}
		MRBase mRBase = owner;
		owner = newOwner;
		PortalRenderer[] array = portalRenderers;
		foreach (PortalRenderer portalRenderer in array)
		{
			if (portalRenderer != null)
			{
				MRBase.TransferObject(mRBase, newOwner, portalRenderer);
			}
		}
		SceneInfo sceneInfo = mRBase?.info.Load();
		SceneInfo sceneInfo2 = newOwner?.info.Load();
		sceneInfo = ((sceneInfo == null) ? sceneInfo2 : sceneInfo);
		if (!sceneInfo.inFantasyWorld && sceneInfo2.inFantasyWorld)
		{
			TriggerTransition(toFantasy: true);
		}
		else if (sceneInfo.inFantasyWorld && !sceneInfo2.inFantasyWorld)
		{
			TriggerTransition(toFantasy: false);
		}
	}

	public bool CheckForMimicSwap(bool headEnteredPortal, bool hasPortalBetweenChanged, Portal newPortal)
	{
		int num = 0;
		if (headEnteredPortal)
		{
			num++;
		}
		if (hasPortalBetweenChanged)
		{
			num++;
			if (CheckHandCrossedPortal(portalFromHeadToHand, newPortal))
			{
				num++;
			}
		}
		return num == 1;
	}

	public bool CheckHandCrossedPortal(Portal oldPortal, Portal newPortal)
	{
		if ((bool)oldPortal)
		{
			Portal.PortalTransform portalTransform = oldPortal.Link.CalculatePortalObjectTransform(lastState.position, lastState.rotation, Vector3.zero);
			return oldPortal.PositionCrossedPortalThreshold(base.transform.position, portalTransform.position, IgnoreTwoSided: true);
		}
		return newPortal.PositionCrossedPortalThreshold(base.transform.position, lastState.position, IgnoreTwoSided: true);
	}

	public void UpdateHandTransform(bool updateHeldObject)
	{
		IC.IHandInput inputForHand = IC.GetInputForHand(ICHand);
		Vector3 position = inputForHand.GetPosition();
		Quaternion rotation = inputForHand.GetRotation();
		if (!IC.isHmdPresent)
		{
			Vector3 position2 = MainCamera.Inst.transform.TransformPoint(position);
			Quaternion rotation2 = MainCamera.Inst.transform.rotation * rotation;
			base.transform.position = position2;
			base.transform.rotation = rotation2;
		}
		else
		{
			base.transform.localPosition = position;
			base.transform.localRotation = rotation;
		}
		GrabObject grabObject = InteractableHeld as GrabObject;
		if (updateHeldObject && (bool)grabObject)
		{
			HandTransform handGrabTransform = GetHandGrabTransform();
			grabObject.SetPositionAndRotation(handGrabTransform.worldPosition, handGrabTransform.worldRotation, CC.MovementType.Teleport);
		}
	}

	public Vector3 GetPositionLocalToHead()
	{
		if ((bool)portalFromHeadToHand)
		{
			return portalFromHeadToHand.Link.CalculatePortalObjectTransform(base.transform.position, base.transform.rotation, Vector3.zero).position;
		}
		return base.transform.position;
	}

	public Portal.PortalTransform GetHandPlamTransformLocalToHead()
	{
		if ((bool)portalFromHeadToHand)
		{
			return portalFromHeadToHand.Link.CalculatePortalObjectTransform(handPalm.transform.position, handPalm.transform.rotation, Vector3.zero);
		}
		Portal.PortalTransform result = default(Portal.PortalTransform);
		result.position = handPalm.transform.position;
		result.rotation = handPalm.transform.rotation;
		result.direction = Vector3.zero;
		return result;
	}

	public Vector3 GetHandPalmPosition()
	{
		return handPalm.transform.position;
	}

	public Quaternion GetHandPalmRotation()
	{
		return handPalm.transform.rotation;
	}

	private IEnumerator<Routine.Yield> HandGlowRoutine()
	{
		InteractionSettings settings = BaseSettings<InteractionSettings>.Inst;
		handPropertyBlock.SetFloat(ShaderPID._FillAmount, 0f);
		handPropertyBlock.SetFloat(ShaderPID._FadeAmount, 0f);
		handPropertyBlock.SetColor(ShaderPID._EmissiveColor, settings.handGlowColor);
		handSMR.SetPropertyBlock(handPropertyBlock);
		handSMR.material.EnableKeyword("INVENTORY_EFFECT_ON");
		float time = 0f;
		float animTime = settings.handGrabGlowAnimTime;
		while (time < animTime)
		{
			time += IC.DeltaTime;
			float time2 = Mathf.Clamp01(time / animTime);
			float value = Mathf.Clamp01(settings.handGlowCurve.Evaluate(time2));
			handPropertyBlock.SetFloat(ShaderPID._FadeAmount, value);
			handSMR.SetPropertyBlock(handPropertyBlock);
			yield return Wait.For.LRUpdates(1);
		}
		handSMR.material.DisableKeyword("INVENTORY_EFFECT_ON");
	}

	public static void PulseHapticFeedback(float frequency, float amplitude, float duration, OVRInput.Controller controller)
	{
		CC inst = CC.Inst;
		if ((controller & OVRInput.Controller.LTouch) != 0 && (controller & OVRInput.Controller.RTouch) != 0)
		{
			PulseHapticFeedback(frequency, amplitude, duration, inst.handL);
			PulseHapticFeedback(frequency, amplitude, duration, inst.handR);
		}
		else if ((controller & OVRInput.Controller.LTrackedRemote) != 0 && (controller & OVRInput.Controller.RTrackedRemote) != 0)
		{
			PulseHapticFeedback(frequency, amplitude, duration, inst.handL);
			PulseHapticFeedback(frequency, amplitude, duration, inst.handR);
		}
		else if ((controller & OVRInput.Controller.LTouch) != 0 || (controller & OVRInput.Controller.LTrackedRemote) != 0)
		{
			PulseHapticFeedback(frequency, amplitude, duration, inst.handL);
		}
		else if ((controller & OVRInput.Controller.RTouch) != 0 || (controller & OVRInput.Controller.RTrackedRemote) != 0)
		{
			PulseHapticFeedback(frequency, amplitude, duration, inst.handR);
		}
	}

	public static void PulseHapticFeedback(float frequency, float amplitude, float duration, Hand hand)
	{
		if (hand.pulseHapticFeedbackRoutine.started)
		{
			hand.pulseHapticFeedbackRoutine.Stop();
		}
		hand.pulseHapticFeedbackRoutine.Start(frequency, amplitude, duration, hand.OVRController);
	}

	public static void StopHapticFeedback(Hand hand)
	{
		IHaglet<float, float, float, OVRInput.Controller> haglet = hand.pulseHapticFeedbackRoutine;
		if (haglet != null && haglet.started)
		{
			hand.pulseHapticFeedbackRoutine.Skip();
		}
	}

	public void SetHapticFeedback(float frequency, float amplitude)
	{
		SetHapticFeedbackForController(frequency, amplitude, OVRController);
	}

	private IEnumerator<Routine.Yield> PulseHapticFeedbackRoutine(float frequency, float amplitude, float duration, OVRInput.Controller controller)
	{
		SetHapticFeedbackForController(frequency, amplitude, controller);
		yield return Wait.For.Seconds(duration);
		SetHapticFeedbackForController(0f, 0f, controller);
	}

	private static void SetHapticFeedbackForController(float frequency, float amplitude, OVRInput.Controller controller)
	{
		if ((controller & OVRInput.Controller.LTouch) != 0)
		{
			OVRInput.SetControllerVibration(frequency, amplitude, OVRInput.Controller.LTouch);
		}
		if ((controller & OVRInput.Controller.RTouch) != 0)
		{
			OVRInput.SetControllerVibration(frequency, amplitude, OVRInput.Controller.RTouch);
		}
		if ((controller & OVRInput.Controller.LTrackedRemote) != 0)
		{
			OVRInput.SetControllerVibration(frequency, amplitude, OVRInput.Controller.LTrackedRemote);
		}
		if ((controller & OVRInput.Controller.RTrackedRemote) != 0)
		{
			OVRInput.SetControllerVibration(frequency, amplitude, OVRInput.Controller.RTrackedRemote);
		}
	}

	private void OnDrawGizmosSelected()
	{
		base.transform.Find("GrabDirection");
	}

	public void SetHandOffset(Vector3 offset)
	{
		base.transform.parent.localPosition = offset;
	}
}
[Serializable]
public class HandPoseWeight
{
	public string name;

	public float weight;

	[SerializeField]
	[HideInInspector]
	private int _hash;

	public int Hash => _hash;

	public HandPoseWeight(string name, float weight)
	{
		this.name = name;
		this.weight = weight;
		_hash = Animator.StringToHash(name);
	}
}
public class HandAnimator : MonoBehaviour
{
	private Hand hand;

	private Animator animator;

	private int Override;

	private int Fingers;

	private int Thumb;

	private int IndexFinger;

	private int FocusPose = Animator.StringToHash("FocusPose");

	private int GripTrigger = Animator.StringToHash("GripTrigger");

	private int IndexTrigger = Animator.StringToHash("IndexTrigger");

	private int IndexDown = Animator.StringToHash("IndexDown");

	private int ThumbDown = Animator.StringToHash("ThumbDown");

	private int IsGrabbing = Animator.StringToHash("IsGrabbing");

	private float overrideLayerWeight;

	private void OnEnable()
	{
		if ((bool)animator)
		{
			Override = animator.GetLayerIndex("Override");
			Fingers = animator.GetLayerIndex("Fingers");
			Thumb = animator.GetLayerIndex("Thumb");
			IndexFinger = animator.GetLayerIndex("IndexFinger");
		}
	}

	public void OnAwakeLR(Hand _hand)
	{
		hand = _hand;
		animator = GetComponentInChildren<Animator>();
	}

	public void OnUpdateLR()
	{
		IC.IHandInput inputForHand = IC.GetInputForHand(hand.ICHand);
		bool flag = !LR.Inst.IsPaused && (hand.grabPointHighlighted != null || hand.grabPointFocusGrabbed != null);
		bool indexTouch = inputForHand.GetIndexTouch();
		bool thumbTouch = inputForHand.GetThumbTouch();
		bool flag2 = hand.grabPointHeld != null;
		animator.SetBool(FocusPose, flag);
		animator.SetFloat(GripTrigger, inputForHand.GetGrip());
		animator.SetFloat(IndexTrigger, inputForHand.GetTrigger());
		animator.SetFloat(IndexDown, indexTouch ? 1f : 0f);
		animator.SetFloat(ThumbDown, thumbTouch ? 1f : 0f);
		animator.SetBool(IsGrabbing, flag2);
		if (flag2)
		{
			GrabPoint grabPointHeld = hand.grabPointHeld;
			for (int i = 0; i < grabPointHeld.handPose.Count; i++)
			{
				HandPoseWeight handPoseWeight = grabPointHeld.handPose[i];
				animator.SetFloat(handPoseWeight.Hash, handPoseWeight.weight);
			}
		}
		float target = Mathf.Max(flag ? 1f : 0f, hand.grabPointHeld ? 1f : 0f);
		float layerWeight = animator.GetLayerWeight(Override);
		overrideLayerWeight = Mathf.MoveTowards(layerWeight, target, IC.RealDeltaTime * BaseSettings<InteractionSettings>.Inst.overrideLayerWeightSpeed);
		float weight = 1f - overrideLayerWeight;
		animator.SetLayerWeight(Override, overrideLayerWeight);
		animator.SetLayerWeight(Fingers, weight);
		animator.SetLayerWeight(Thumb, weight);
		animator.SetLayerWeight(IndexFinger, weight);
	}
}
public class HandL : Hand
{
	public override IC.Hand ICHand => IC.Hand.Left;

	public override OVRInput.Controller OVRController => OVRInput.Controller.LTouch | OVRInput.Controller.LTrackedRemote;
}
public class HandR : Hand
{
	public override IC.Hand ICHand => IC.Hand.Right;

	public override OVRInput.Controller OVRController => OVRInput.Controller.RTouch | OVRInput.Controller.RTrackedRemote;
}
public class STUB_GhostHand : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class Tracker : MonoBehaviour
{
}
public class TransformData
{
	public Transform xform;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 right;

	public Vector3 up;

	public Vector3 forward;

	public TransformData(Transform pair)
	{
		xform = pair;
		Update();
	}

	public void Update()
	{
		position = xform.position;
		rotation = xform.rotation;
		rotation.GetAxes(out right, out up, out forward);
	}
}
public class TransformState
{
	public Vector3 position;

	public Vector3 velocity;

	public Quaternion rotation;

	public Transform pairTransform;

	public TransformState(Transform pair)
	{
		pairTransform = pair;
		UpdateToLatestState();
		velocity.x = (velocity.y = (velocity.z = 0f));
	}

	public void UpdateToLatestState()
	{
		Vector3 vector = pairTransform.position;
		velocity = (vector - position) / Mathf.Max(IC.RealDeltaTime, 1f / 120f);
		position = vector;
		rotation = pairTransform.rotation;
	}
}
internal interface ITriggerEvent
{
	void OnTriggerAwakeLR(Trigger trigger);

	void OnTriggerEnterLR();

	void OnTriggerStayLR();

	void OnTriggerExitLR();
}
public class Trigger : IDObject
{
	public Vector3 extents = new Vector3(0.1f, 0.1f, 0.1f);

	[ReadOnly]
	public bool isCutsceneTrigger;

	public bool anyGrabObject;

	public bool allowGrabObjectsInHands;

	public bool testHandsByThemselves;

	public bool includePlayerHands;

	public bool checkAngle;

	[ConditionalHide("checkAngle")]
	public float angleThresholdInDegrees = 10f;

	private HagletValue<bool> inside;

	private ITriggerEvent[] triggerEvents;

	public Wait OnInside => Wait.Until.True(inside);

	public Wait OnOutside => Wait.Until.False(inside);

	public Wait OnInsidePremet => Wait.Until.True(inside, 1, allowPreMetNow: true);

	public Wait OnOutisePremet => Wait.Until.False(inside, 1, allowPreMetNow: true);

	public bool IsInsideBool => inside.value;

	public override void OnAwakeLR(MRBase owner)
	{
		base.OnAwakeLR(owner);
		HagletValue.Create(out inside, null, initVal: false, null, 8);
		triggerEvents = GetComponentsInChildren<ITriggerEvent>();
		for (int i = 0; i < triggerEvents.Length; i++)
		{
			triggerEvents[i].OnTriggerAwakeLR(this);
		}
	}

	public void OnUpdateLR()
	{
		if (LR.Inst.IsPaused || (LR.Inst.IsInCutscene && !isCutsceneTrigger))
		{
			return;
		}
		if (!base.gameObject.activeInHierarchy)
		{
			inside.value = false;
			return;
		}
		if (!base.enabled)
		{
			inside.value = false;
			return;
		}
		bool flag = false;
		if (anyGrabObject)
		{
			for (int i = 0; i < owner.interactableObjects.Length; i++)
			{
				GrabObject grabObject = owner.interactableObjects[i] as GrabObject;
				if ((bool)grabObject && (allowGrabObjectsInHands || !CC.Inst.IsObjectGrabbed(grabObject)) && CheckTargetInVolume(grabObject.transform.position, grabObject.transform.rotation))
				{
					flag = true;
					break;
				}
			}
		}
		else if (testHandsByThemselves)
		{
			CC inst = CC.Inst;
			flag |= CheckTargetInVolume(inst.handL.transform.position, inst.handL.transform.rotation);
			flag |= CheckTargetInVolume(inst.handR.transform.position, inst.handR.transform.rotation);
		}
		else
		{
			flag = CheckTargetInVolume(IC.GetHeadPosition(), IC.GetHeadRotation());
			if (includePlayerHands)
			{
				CC inst2 = CC.Inst;
				flag &= CheckTargetInVolume(inst2.handL.transform.position, inst2.handL.transform.rotation);
				flag &= CheckTargetInVolume(inst2.handR.transform.position, inst2.handR.transform.rotation);
			}
		}
		if (inside.value != flag)
		{
			if (flag)
			{
				for (int j = 0; j < triggerEvents.Length; j++)
				{
					triggerEvents[j].OnTriggerEnterLR();
				}
			}
			else
			{
				for (int k = 0; k < triggerEvents.Length; k++)
				{
					triggerEvents[k].OnTriggerExitLR();
				}
			}
		}
		else if (flag)
		{
			for (int l = 0; l < triggerEvents.Length; l++)
			{
				triggerEvents[l].OnTriggerStayLR();
			}
		}
		inside.value = flag;
	}

	private bool CheckTargetInVolume(Vector3 worldPos, Quaternion worldRotation)
	{
		Vector3 vector = base.transform.InverseTransformPoint(worldPos);
		if (Mathf.Abs(vector.x) > extents.x)
		{
			return false;
		}
		if (Mathf.Abs(vector.y) > extents.y)
		{
			return false;
		}
		if (Mathf.Abs(vector.z) > extents.z)
		{
			return false;
		}
		if (checkAngle)
		{
			Vector3 lhs = worldRotation * Vector3.forward;
			Vector3 lhs2 = worldRotation * Vector3.up;
			float num = angleThresholdInDegrees * ((float)Math.PI / 180f);
			float num2 = Mathf.Acos(Vector3.Dot(lhs, base.transform.forward));
			float num3 = Mathf.Acos(Vector3.Dot(lhs2, base.transform.up));
			if (num2 > num)
			{
				return false;
			}
			if (num3 > num)
			{
				return false;
			}
		}
		return true;
	}
}
public class TrigerEvent_ObsB_FinalyEnter : MonoBehaviour, ITriggerEvent, ICutsceneEvent
{
	public Animation anim;

	public IDObjectRef otherTriggerRef;

	public string enterAnim;

	public string idleAnim;

	private Animation otherAnim;

	private IHaglet animRoutine;

	public void OnTriggerAwakeLR(Trigger trigger)
	{
		Haglet.Create(out animRoutine, AnimRoutine);
	}

	public void OnCutsceneBegin()
	{
		if (animRoutine.started)
		{
			animRoutine.Stop();
			otherAnim.Stop();
		}
	}

	public void OnCutsceneEnd()
	{
	}

	public void OnTriggerEnterLR()
	{
		otherAnim = LR.Inst.GetIDObject<IDObject>(otherTriggerRef).GetComponent<TrigerEvent_ObsB_FinalyEnter>().anim;
		if (!LR.Inst.IsInCutscene && !animRoutine.started)
		{
			animRoutine.Start();
		}
	}

	public void OnTriggerExitLR()
	{
	}

	public void OnTriggerStayLR()
	{
	}

	private IEnumerator<Routine.Yield> AnimRoutine()
	{
		anim.gameObject.SetActive(value: true);
		otherAnim.gameObject.SetActive(value: true);
		LR.Inst.GetIDObject<IDObject>(otherTriggerRef).gameObject.SetActive(value: false);
		yield return HAGIS.PlayAnim(anim, enterAnim);
		yield return HAGIS.PlayAnim(anim, idleAnim, 0.2f);
		yield return HAGIS.PlayAnim(otherAnim, enterAnim);
		yield return HAGIS.PlayAnim(otherAnim, idleAnim, 0.2f);
		base.gameObject.SetActive(value: false);
	}
}
public class TriggerEvent_MoveMimic : MonoBehaviour, IAwakeEvent
{
	public IDObjectRef remoteTriggerRef;

	[Tooltip("The mimic on this side of the trigger")]
	public IDObjectRef objectMimicRef;

	private Transform remoteTriggerTransform;

	private ObjectMimic mimic;

	private StackedBool isNotInsideTrigger;

	private IHaglet awakeRoutine;

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		Haglet.Create(out awakeRoutine, AwakeRoutine, null, startNow: true);
	}

	private IEnumerator<Routine.Yield> AwakeRoutine()
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		mimic = LR.Inst.GetIDObjectComponent<ObjectMimic>(objectMimicRef);
		PlayerAreaTrigger localTrigger = GetComponent<PlayerAreaTrigger>();
		while (localTrigger.OnTriggerEnter == null)
		{
			yield return Wait.For.Updates(1);
		}
		localTrigger.OnTriggerEnter.onInvoke += OnTriggerEnter;
		localTrigger.OnTriggerExit.onInvoke += OnTriggerExit;
		PlayerAreaTrigger remoteTrigger = remoteTriggerRef.Get<IDObject>().GetComponent<PlayerAreaTrigger>();
		remoteTriggerTransform = remoteTrigger.transform;
		while (remoteTrigger.OnTriggerEnter == null)
		{
			yield return Wait.For.Updates(1);
		}
		remoteTrigger.OnTriggerEnter.onInvoke += OnTriggerEnter;
		remoteTrigger.OnTriggerExit.onInvoke += OnTriggerExit;
	}

	private void OnTriggerEnter()
	{
		isNotInsideTrigger.Value = false;
		UpdateOverrideTransforms();
	}

	private void OnTriggerExit()
	{
		isNotInsideTrigger.Value = true;
		UpdateOverrideTransforms();
	}

	private void UpdateOverrideTransforms()
	{
		ObjectMimic targetMimic = mimic.GetTargetMimic();
		mimic.overrideTransform = (isNotInsideTrigger.Value ? null : base.transform);
		targetMimic.overrideTransform = (isNotInsideTrigger.Value ? null : remoteTriggerTransform);
	}
}
public class TriggerEvent_PlayAnim : MonoBehaviour, ITriggerEvent
{
	public Animation animComp;

	public string animToPlay;

	public bool playOnce = true;

	private bool played;

	public void OnTriggerAwakeLR(Trigger trigger)
	{
	}

	public void OnTriggerEnterLR()
	{
		if (playOnce)
		{
			if (!played)
			{
				played = true;
				HAGIS.PlayAnim(animComp, animToPlay, 0.2f);
			}
		}
		else
		{
			HAGIS.PlayAnim(animComp, animToPlay, 0.2f);
		}
	}

	public void OnTriggerStayLR()
	{
	}

	public void OnTriggerExitLR()
	{
	}
}
internal interface IAreaTriggerEvent
{
	void OnTriggerAwakeLR(BaseAreaTrigger trigger);

	void OnTriggerEnterLR();

	void OnTriggerStayLR();

	void OnTriggerExitLR();
}
public abstract class BaseAreaTrigger : MonoBehaviour, IAwakeEvent, IPrepareEvent
{
	public Event OnTriggerEnter;

	public Event OnTriggerExit;

	public Vector3 extents = new Vector3(0.1f, 0.1f, 0.1f);

	protected HagletValue<bool> isInside;

	private IAreaTriggerEvent[] triggerEvents;

	protected MRBase owner;

	private IHaglet prepareEventRoutine;

	public Wait OnInside => Wait.Until.True(isInside);

	public Wait OnOutside => Wait.Until.False(isInside);

	public Wait OnInsidePremet => Wait.Until.True(isInside, 1, allowPreMetNow: true);

	public Wait OnOutisePremet => Wait.Until.False(isInside, 1, allowPreMetNow: true);

	public bool IsInsideBool => isInside.value;

	public virtual void OnAwakeLR(MRBase owner)
	{
		this.owner = owner;
		if (OnTriggerEnter == null)
		{
			OnTriggerEnter = new Event();
		}
		if (OnTriggerExit == null)
		{
			OnTriggerExit = new Event();
		}
		triggerEvents = GetComponentsInChildren<IAreaTriggerEvent>();
		for (int i = 0; i < triggerEvents.Length; i++)
		{
			triggerEvents[i].OnTriggerAwakeLR(this);
		}
		HagletValue.Create(out isInside, null, initVal: false, null, 8);
		Haglet.Create(out prepareEventRoutine, PrepareEventRoutine);
	}

	public virtual Wait PrepareEvents()
	{
		return prepareEventRoutine.Start();
	}

	private IEnumerator<Routine.Yield> PrepareEventRoutine()
	{
		OnTriggerEnter.PrepareInvoke();
		yield return Wait.For.LRUpdates(1);
		OnTriggerExit.PrepareInvoke();
	}

	protected void UpdateTriggerEvents(bool inside)
	{
		bool value = isInside.value;
		if (value != inside)
		{
			isInside.value = inside;
			if (inside)
			{
				OnTriggerEnter.Invoke();
				for (int i = 0; i < triggerEvents.Length; i++)
				{
					triggerEvents[i].OnTriggerEnterLR();
				}
			}
			else
			{
				OnTriggerExit.Invoke();
				for (int j = 0; j < triggerEvents.Length; j++)
				{
					triggerEvents[j].OnTriggerExitLR();
				}
			}
		}
		else if (value)
		{
			for (int k = 0; k < triggerEvents.Length; k++)
			{
				triggerEvents[k].OnTriggerStayLR();
			}
		}
	}
}
public class CutsceneAreaTrigger : BaseAreaTrigger
{
	public static void OnUpdateAll(CutsceneAreaTrigger[] triggers)
	{
		Vector3 position = MainCamera.Inst.transform.position;
		if (LR.Inst.IsPaused)
		{
			return;
		}
		foreach (CutsceneAreaTrigger cutsceneAreaTrigger in triggers)
		{
			if (!cutsceneAreaTrigger.isActiveAndEnabled)
			{
				cutsceneAreaTrigger.isInside.value = false;
				continue;
			}
			bool inside = MathfX.CheckPointInVolume(cutsceneAreaTrigger.transform.InverseTransformPoint(position), cutsceneAreaTrigger.extents);
			cutsceneAreaTrigger.UpdateTriggerEvents(inside);
		}
	}
}
public class GrabObjectAreaTrigger : BaseAreaTrigger
{
	public bool allowHeld;

	public static void OnUpdateAll(GrabObjectAreaTrigger[] triggers)
	{
		if (LR.Inst.IsPaused || LR.Inst.IsInCutscene)
		{
			return;
		}
		foreach (GrabObjectAreaTrigger grabObjectAreaTrigger in triggers)
		{
			if (!grabObjectAreaTrigger.isActiveAndEnabled)
			{
				grabObjectAreaTrigger.isInside.value = false;
				continue;
			}
			bool inside = false;
			for (int j = 0; j < grabObjectAreaTrigger.owner.interactableObjects.Length; j++)
			{
				GrabObject grabObject = grabObjectAreaTrigger.owner.interactableObjects[j] as GrabObject;
				if ((bool)grabObject && (grabObjectAreaTrigger.allowHeld || !CC.Inst.IsObjectGrabbed(grabObject)) && MathfX.CheckPointInVolume(grabObjectAreaTrigger.transform.InverseTransformPoint(grabObject.transform.position), grabObjectAreaTrigger.extents))
				{
					inside = true;
					break;
				}
			}
			grabObjectAreaTrigger.UpdateTriggerEvents(inside);
		}
	}
}
public class ObjectAreaTrigger : BaseAreaTrigger
{
	public Transform targetTransform;

	public static void OnUpdateAll(ObjectAreaTrigger[] triggers)
	{
		if (LR.Inst.IsPaused || LR.Inst.IsInCutscene)
		{
			return;
		}
		foreach (ObjectAreaTrigger objectAreaTrigger in triggers)
		{
			if (!objectAreaTrigger.isActiveAndEnabled || objectAreaTrigger.targetTransform == null)
			{
				objectAreaTrigger.isInside.value = false;
				continue;
			}
			bool inside = MathfX.CheckPointInVolume(objectAreaTrigger.transform.InverseTransformPoint(objectAreaTrigger.targetTransform.position), objectAreaTrigger.extents);
			objectAreaTrigger.UpdateTriggerEvents(inside);
		}
	}
}
public class PlayerAreaTrigger : BaseAreaTrigger
{
	[Flags]
	public enum TrackingOptions
	{
		Head = 2,
		LeftHand = 4,
		RightHand = 8
	}

	[EnumFlagsField]
	public TrackingOptions trackingMode;

	public bool shouldUpdateWhilePausedAndInCutscene;

	protected HagletValue<bool> headInside;

	protected HagletValue<bool> leftHandInside;

	protected HagletValue<bool> rightHandInside;

	public Wait OnHeadInside => Wait.Until.True(headInside);

	public Wait OnHeadOutside => Wait.Until.False(headInside);

	public Wait OnHeadInsidePremet => Wait.Until.True(headInside, 1, allowPreMetNow: true);

	public Wait OnHeadOutsidePremet => Wait.Until.False(headInside, 1, allowPreMetNow: true);

	public bool IsHeadInsideBool => headInside.value;

	public Wait OnLeftHandInside => Wait.Until.True(leftHandInside);

	public Wait OnLeftHandOutside => Wait.Until.False(leftHandInside);

	public Wait OnLeftHandInsidePremet => Wait.Until.True(leftHandInside, 1, allowPreMetNow: true);

	public Wait OnLeftHandOutsidePremet => Wait.Until.False(leftHandInside, 1, allowPreMetNow: true);

	public bool IsLeftHandInsideBool => leftHandInside.value;

	public Wait OnRightHandInside => Wait.Until.True(rightHandInside);

	public Wait OnRightHandOutside => Wait.Until.False(rightHandInside);

	public Wait OnRightHandInsidePremet => Wait.Until.True(rightHandInside, 1, allowPreMetNow: true);

	public Wait OnRightHandOutsidePremet => Wait.Until.False(rightHandInside, 1, allowPreMetNow: true);

	public bool IsRightHandInsideBool => rightHandInside.value;

	public override void OnAwakeLR(MRBase owner)
	{
		base.OnAwakeLR(owner);
		HagletValue.Create(out headInside, null, initVal: false, null, 8);
		HagletValue.Create(out leftHandInside, null, initVal: false, null, 8);
		HagletValue.Create(out rightHandInside, null, initVal: false, null, 8);
	}

	public static void OnUpdateAll(PlayerAreaTrigger[] triggers)
	{
		CC inst = CC.Inst;
		_ = inst.transform.position;
		Vector3 headPosition = IC.GetHeadPosition();
		Vector3 position = inst.handL.transform.position;
		Vector3 position2 = inst.handR.transform.position;
		LR inst2 = LR.Inst;
		bool flag = inst2.IsPaused || inst2.IsInCutscene;
		Matrix4x4 value = default(Matrix4x4);
		foreach (PlayerAreaTrigger playerAreaTrigger in triggers)
		{
			if (!playerAreaTrigger.shouldUpdateWhilePausedAndInCutscene && flag)
			{
				continue;
			}
			if (!playerAreaTrigger.isActiveAndEnabled)
			{
				playerAreaTrigger.isInside.value = false;
				continue;
			}
			bool flag2 = playerAreaTrigger.trackingMode != (TrackingOptions)0;
			LR.fast_worldToLocalMatrix(playerAreaTrigger.transform, ref value);
			if ((playerAreaTrigger.trackingMode & TrackingOptions.Head) != 0)
			{
				Vector3 vector = value.MultiplyPoint3x4(headPosition);
				bool flag3 = ((vector.x > 0f) ? vector.x : (0f - vector.x)) < playerAreaTrigger.extents.x && ((vector.y > 0f) ? vector.y : (0f - vector.y)) < playerAreaTrigger.extents.y && ((vector.z > 0f) ? vector.z : (0f - vector.z)) < playerAreaTrigger.extents.z;
				if (flag3 != playerAreaTrigger.headInside.value)
				{
					playerAreaTrigger.headInside.value = flag3;
				}
				flag2 = flag2 && flag3;
			}
			if ((playerAreaTrigger.trackingMode & TrackingOptions.LeftHand) != 0)
			{
				Vector3 vector2 = value.MultiplyPoint3x4(position);
				bool flag4 = ((vector2.x > 0f) ? vector2.x : (0f - vector2.x)) < playerAreaTrigger.extents.x && ((vector2.y > 0f) ? vector2.y : (0f - vector2.y)) < playerAreaTrigger.extents.y && ((vector2.z > 0f) ? vector2.z : (0f - vector2.z)) < playerAreaTrigger.extents.z;
				if (flag4 != playerAreaTrigger.leftHandInside.value)
				{
					playerAreaTrigger.leftHandInside.value = flag4;
				}
				flag2 = flag2 && flag4;
			}
			if ((playerAreaTrigger.trackingMode & TrackingOptions.RightHand) != 0)
			{
				Vector3 vector3 = value.MultiplyPoint3x4(position2);
				bool flag5 = ((vector3.x > 0f) ? vector3.x : (0f - vector3.x)) < playerAreaTrigger.extents.x && ((vector3.y > 0f) ? vector3.y : (0f - vector3.y)) < playerAreaTrigger.extents.y && ((vector3.z > 0f) ? vector3.z : (0f - vector3.z)) < playerAreaTrigger.extents.z;
				if (flag5 != playerAreaTrigger.rightHandInside.value)
				{
					playerAreaTrigger.rightHandInside.value = flag5;
				}
				flag2 = flag2 && flag5;
			}
			playerAreaTrigger.UpdateTriggerEvents(flag2);
		}
	}
}
public class PuzzlesCompleteTrigger : MonoBehaviour, IAwakeEvent, IUpdateEvent, IPrepareEvent
{
	public Event OnPuzzlesComplete;

	public PuzzleInfo[] PuzzlesToComplete;

	public HagletTrigger PuzzlesComplete = new HagletTrigger();

	private bool AllPuzzlesComplete;

	public virtual void OnAwakeLR(MRBase owner)
	{
		if (OnPuzzlesComplete == null)
		{
			OnPuzzlesComplete = new Event();
		}
	}

	Wait IPrepareEvent.PrepareEvents()
	{
		OnPuzzlesComplete.PrepareInvoke();
		return Wait.None;
	}

	void IUpdateEvent.OnUpdateLR()
	{
		if (AllPuzzlesComplete)
		{
			return;
		}
		bool flag = true;
		for (int i = 0; i < PuzzlesToComplete.Length; i++)
		{
			if (!PuzzlesToComplete[i].IsComplete(SaveDataGame.PuzzleSaveType.Progression))
			{
				flag = false;
			}
		}
		if (flag)
		{
			AllPuzzlesComplete = true;
			OnPuzzlesComplete.Invoke();
			PuzzlesComplete.Trigger();
		}
	}
}
public class Vault_Pillar : MonoBehaviour, IAwakeEvent
{
	public enum VaultPillarAnims
	{
		UP,
		DOWN,
		IDLE
	}

	public int pillarNum;

	public SaveDataGame.Chapter pillarsChapter;

	private Animation animationComp;

	private string idleAnimation;

	private string downAnimation;

	private string upAnimation;

	private FMOD.Studio.EventInstance evtPillar;

	public float lightRot = 150f;

	public float lightRotTime = 3f;

	[HideInInspector]
	public Constellation constellation;

	[HideInInspector]
	public Telepoint telepoint;

	[HideInInspector]
	public Rasterizer rasterizer;

	[HideInInspector]
	public GameObject pillarGlow;

	[HideInInspector]
	public GameObject pillarFlame;

	[HideInInspector]
	public Material pillarGlowMat;

	[HideInInspector]
	public Material pillarFlameMat;

	private IHaglet<float> idleDelayRoutine;

	private IHaglet<VaultPillarAnims> movePillarRoutine;

	public void OnAwakeLR(MRBase owner)
	{
		idleAnimation = "AN_Vault_Pillar_0" + pillarNum + "_Idle";
		upAnimation = "AN_Vault_Pillar_0" + pillarNum + "_Up";
		downAnimation = "AN_Vault_Pillar_0" + pillarNum + "_Down";
		constellation = GetComponentInChildren<Constellation>(includeInactive: true);
		rasterizer = GetComponentInChildren<Rasterizer>(includeInactive: true);
		telepoint = GetComponentInChildren<Telepoint>(includeInactive: true);
		telepoint.Hide();
		string currentSceneUIDName = CC.Inst.currentSceneUIDName;
		SaveDataGame.Chapter chapter = SaveDataGame.Chapter.None;
		if (!string.IsNullOrEmpty(currentSceneUIDName))
		{
			chapter = LR.Inst.GetSceneInfoWithSceneUIDName(currentSceneUIDName).GetPuzzleChapter();
		}
		if (LR.Inst.saveDataGame.IsChapterMaskCompleteAll(pillarsChapter) && chapter != pillarsChapter)
		{
			rasterizer.playSound = false;
			rasterizer.CompleteObeliskPuzzle();
			constellation.FillConstellation(skip: true);
		}
		pillarGlow = base.transform.FindDeepChild("Vault_Pillar_Glow").gameObject;
		pillarFlame = base.transform.FindDeepChild("Vault_Pillar_Flame").gameObject;
		pillarGlowMat = pillarGlow.GetComponentInChildren<MeshRenderer>().material;
		pillarFlameMat = pillarFlame.GetComponentInChildren<MeshRenderer>().material;
		animationComp = GetComponentInChildren<Animation>();
		Haglet.Create(out movePillarRoutine, (Routine.Func1<VaultPillarAnims>)MovePillarRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out idleDelayRoutine, (Routine.Func1<float>)IdleDelayRoutine, (string)null, startNow: false, (int?)null, (string)null);
		idleDelayRoutine.Start(UnityEngine.Random.Range(0.1f, 1f));
	}

	public Wait Move(VaultPillarAnims move)
	{
		return movePillarRoutine.Start(move);
	}

	private IEnumerator<Routine.Yield> IdleDelayRoutine(float delay)
	{
		yield return Wait.For.Seconds(delay);
		HAGIS.PlayAnim(animationComp, GetAnimationString(VaultPillarAnims.IDLE), 0.2f);
	}

	private IEnumerator<Routine.Yield> MovePillarRoutine(VaultPillarAnims anim)
	{
		if (evtPillar.isValid())
		{
			evtPillar.stop(STOP_MODE.ALLOWFADEOUT);
		}
		evtPillar = FAC.Inst.PlayOneShot(BaseSettings<ObeliskSettings>.Inst.soundPillar, base.transform);
		yield return HAGIS.PlayAnim(animationComp, GetAnimationString(anim), 0.2f);
		evtPillar.stop(STOP_MODE.ALLOWFADEOUT);
	}

	private string GetAnimationString(VaultPillarAnims anim)
	{
		return anim switch
		{
			VaultPillarAnims.DOWN => downAnimation, 
			VaultPillarAnims.UP => upAnimation, 
			VaultPillarAnims.IDLE => idleAnimation, 
			_ => "", 
		};
	}
}
public class MansfieldVOSequence : MonoBehaviour, IAwakeEvent
{
	private MRBase owner;

	private VO_Sequencer sequencer;

	private IHaglet playVORoutine;

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		this.owner = owner;
		sequencer = GetComponent<VO_Sequencer>();
		Haglet.Create(out playVORoutine, PlayVORoutine, null, startNow: true);
	}

	[Event(EventName = "Play Next VO Section")]
	public void PlayNextVO(object sender)
	{
		SaveDataGame saveDataGame = LR.Inst.saveDataGame;
		if (!saveDataGame.HasPlayerPulledMansfieldLeverForCurrent())
		{
			sequencer.CurrentSectionIndex = saveDataGame.mansfieldVOSequenceIdx;
			sequencer.PlayNextVOSection(sender);
			if (!sequencer.IsComplete)
			{
				saveDataGame.mansfieldVOSequenceIdx++;
			}
			saveDataGame.MansfieldLeverPulled();
		}
	}

	private IEnumerator<Routine.Yield> PlayVORoutine()
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		MRBase mRBase = MainCamera.Inst.GetOwner();
		SceneInfo sceneInfo = mRBase.info.Load();
		SaveDataGame saveDataGame = LR.Inst.saveDataGame;
		if ((mRBase != owner || sceneInfo.sceneUIDName != "suez") && !saveDataGame.HasPlayerEnteredMansfieldChapter(sceneInfo.sceneUIDName))
		{
			sequencer.CurrentSectionIndex = saveDataGame.mansfieldVOSequenceIdx;
			Wait wait = sequencer.PlayNextVOSection();
			if (!sequencer.IsComplete)
			{
				saveDataGame.mansfieldVOSequenceIdx++;
			}
			saveDataGame.MansfieldSceneEntered(sceneInfo.sceneUIDName);
			yield return wait;
			yield return LR.Inst.Save();
		}
	}
}
public class VOMarker : MonoBehaviour, IAwakeEvent, IUpdateEvent
{
	public ParticleSystem particles;

	public MeshRenderer markerSymbol;

	private MPBStore mpbStore = new MPBStore();

	private float currSymbolAlpha;

	private IHaglet disableRoutine;

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		mpbStore.Initialise();
		disableRoutine = Haglet.Create(out disableRoutine, DisableRoutine);
	}

	void IUpdateEvent.OnUpdateLR()
	{
		float num = Vector3.Distance(MainCamera.Inst.transform.position, base.transform.position);
		ParticleSystem.EmissionModule emission = particles.emission;
		emission.enabled = num < BaseSettings<VOSettings>.Inst.particleEmissionDistance;
		currSymbolAlpha = BaseSettings<VOSettings>.Inst.symbolDistanceAlpha.Evaluate(num);
		mpbStore.SetFloat(ShaderPID._Alpha, currSymbolAlpha);
		if ((bool)markerSymbol)
		{
			mpbStore.ApplyProperties(markerSymbol);
			Quaternion rotation = Quaternion.LookRotation((MainCamera.Inst.transform.position - markerSymbol.transform.position).RepY(0f).normalized, markerSymbol.transform.up);
			markerSymbol.transform.rotation = rotation;
		}
	}

	public void Disable()
	{
		base.enabled = false;
		disableRoutine.Start();
	}

	private IEnumerator<Routine.Yield> DisableRoutine()
	{
		particles.Stop(withChildren: true, ParticleSystemStopBehavior.StopEmitting);
		while (currSymbolAlpha > 0f)
		{
			currSymbolAlpha = Mathf.MoveTowards(currSymbolAlpha, 0f, BaseSettings<VOSettings>.Inst.symbolDisableSpeed);
			mpbStore.SetFloat(ShaderPID._Alpha, currSymbolAlpha);
			if ((bool)markerSymbol)
			{
				mpbStore.ApplyProperties(markerSymbol);
			}
			yield return LR.Inst.onUpdate;
		}
	}
}
public abstract class BaseSettings<T> : ScriptableObject where T : BaseSettings<T>
{
	private static T _instance;

	public static T Inst => _instance;

	public static void Init(T instance)
	{
		_instance = instance;
		_instance.Init();
	}

	protected virtual void Init()
	{
	}
}
[CreateAssetMenu(fileName = "CharacterLookAtSettings", menuName = "Nexus Settings/Character LookAt Settings", order = 0)]
public class CharacterLookAtSettings : ScriptableObject
{
	[Header("Rotation Constraints")]
	public Vector3 NeckRotationExtents;

	public Vector3 HeadRotationExtents;

	public Vector3 EyesRotationExtents;

	[Header("Orientation Settings")]
	public bool NeckForwardFlipped;

	public bool HeadForwardFlipped;

	public bool EyesForwardFlipped;

	public float lookAtSpeed = 1f;
}
[CreateAssetMenu(fileName = "FrustumSettings", menuName = "Nexus Settings/Frustum Settings", order = 0)]
public class FrustumSettings : BaseSettings<FrustumSettings>
{
	public FMODEventRef sfxUpdateFeedback;

	public FMODEventRef sfxCompletionFeedback;

	public FMODEventRef sfxFrustumObjectChange;

	public float sfxRange = 2f;

	public bool playSfxOnLookAway = true;

	public bool playSfxOnLookAt;

	public bool playParticlesOnLookAt = true;

	public float fovModifier;

	public float aspectModifier;

	public LayerMask environmentCollisionMask = -1579041;

	public LayerMask occlusionCollisionMask = 4096;

	public float triggerDelay = 0.25f;
}
[CreateAssetMenu(fileName = "GameSettings", menuName = "Nexus Settings/Game Settings", order = 0)]
public class GameSettings : BaseSettings<GameSettings>
{
	public enum HintStates
	{
		Off,
		Nearby,
		Always
	}
}
[CreateAssetMenu(fileName = "GearSettings", menuName = "Nexus Settings/Gear Settings", order = 0)]
public class GearSettings : BaseSettings<GearSettings>
{
	public Mesh gizmoMesh;

	public float toothTipArcSize = 0.015f;

	public float toothBaseArcSize = 0.02f;

	public float toothHeight = 0.01f;

	public float toothDepth = 0.08f;
}
[CreateAssetMenu(fileName = "HelperSettings", menuName = "Nexus Settings/Helper Settings", order = 0)]
public class HelperSettings : BaseSettings<HelperSettings>
{
	public const int MAX_TARGETS = 4;

	[Header("Placement Helper Settings")]
	public float springStrength = 350f;

	public float springDamping = 25f;

	public float kinematicDistance = 0.05f;

	public float curveWeight = 0.5f;

	public int curveResolutionPerMetre = 16;

	public AnimationCurve particleAlphaCurve;

	[Range(0f, 1f)]
	public float distWeight = 0.5f;

	public GameObject lineParticlePrefab;

	public GameObject staticParticleEffect;

	[Header("PlacementHelper")]
	public Mesh arrowMesh;

	public Mesh placementShapeMesh;

	public Mesh placementGlowMesh;

	public Material placementShapeMaterial;

	public Material placementGlowMaterial;

	public Material arrowMaterial;

	[Header("HookHelper")]
	public Mesh hookShapeMesh;

	public Mesh hookGlowMesh;

	public Material hookShapeMaterial;

	public Material hookGlowMaterial;

	public float hookProximityScale;

	public float hookSpringStrength;

	public float hookSpringDamping;

	public FMODEventAsset hookSound;

	public float hookRadius = 0.15f;

	[Header("SoundEffects")]
	public FMODEventAsset sfxProximityEvent;

	[Header("SoundEffects")]
	public FMODEventAsset sfxOnGrab;

	[Header("SoundEffects")]
	public FMODEventAsset sfxOnRelease;
}
[CreateAssetMenu(fileName = "InteractionSettings", menuName = "Nexus Settings/Interaction Settings", order = 0)]
public class InteractionSettings : BaseSettings<InteractionSettings>
{
	[Serializable]
	public struct LeverInfo
	{
		[Tooltip("Modifies how far the lever will move relative to the hand at a given rotation. \nNOTE: reverse this curve if \"Start Rotation Deg\" is closer/more equal to the last element of Snap Rotations than the first.")]
		public AnimationCurve pullCurve;

		[Tooltip("Multiplier that is applied at the end of the haptic amplitude calculation.")]
		public float hapticAmpMod;

		[Tooltip("Multiplier applied to haptic frequency, which itself is just how far the lever moved this frame. (0-1 range, relative to the first and last snapRotations)")]
		public float hapticFreqMod;

		[Tooltip("Constant value added in at the start of the haptic mplitude calculation.")]
		public float hapticAmpConst;

		[Tooltip("amount of damping to apply when rotating the lever. Will prevent it from flickering, but will also make it feel less responsive. Flickering is caused by parts of the pullCurve being too steep; consider smoothingthat first.")]
		public float lerpDamping;

		public FMODEventAsset snapSound;

		public FMODEventAsset moveSound;

		public float soundPeriod;

		public LeverInfo(float ampMod = 0.5f, float freqMod = 40f, float ampConst = 0.5f, float damping = 0.1f, float soundPeriod = 0.25f)
		{
			pullCurve = AnimationCurve.Constant(0f, 1f, 1f);
			hapticAmpMod = ampMod;
			hapticFreqMod = freqMod;
			hapticAmpConst = ampConst;
			lerpDamping = damping;
			snapSound = null;
			moveSound = null;
			this.soundPeriod = soundPeriod;
		}
	}

	public enum LeverType
	{
		DEFAULT,
		PORTAL_MACHINE,
		HEAVY,
		VERTICAL
	}

	[Header("Focus Grab Logic Settings")]
	[Range(0f, 1f)]
	public float focusGrabAnglePriority = 1f;

	[Range(0f, 1f)]
	public float focusGrabDistancePriority = 1f;

	[Range(0f, 7f)]
	public float focusGrabMaxDistance = 2f;

	[Range(0.5f, 120f)]
	public float focusGrabMaxAngle = 25f;

	[Range(0.005f, 0.05f)]
	public float focusGrabRaycastTolerance = 0.03f;

	[Header("Focus Grab Animation Settings")]
	[Range(0f, 1.5f)]
	public float focusGrabAnimTime = 0.2f;

	[Range(0f, 1.5f)]
	public float focusGrabAnimTimeGrabbed = 0.1f;

	public AnimationCurve focusGrabCurve = new AnimationCurve();

	public AnimationCurve focusGrabCurveGrabbed = new AnimationCurve();

	[Range(0f, 1f)]
	public float focusGrabHapticFreq = 0.2f;

	[Range(0f, 1f)]
	public float focusGrabHapticAmp = 0.5f;

	public float focusGrabHapticDuration = 0.1f;

	[Header("Kickback Settings")]
	public AnimationCurve focusGrabKickBackCurve;

	public float kickbackAngle = 10f;

	public float kickbackDistance = 0.01f;

	public float kickbackDuration = 0.15f;

	[Header("Drop Settings")]
	[Range(0f, 1f)]
	public float dropHapticDuration = 0.1f;

	public float dropHapticFreq = 0.2f;

	[Range(0f, 1f)]
	public float dropHapticAmp = 0.5f;

	[Header("Beam Settings")]
	public GameObject interactEffectPrefab;

	public float beamInnerRadius = 0.5f;

	public float beamOuterRadius = 2f;

	public float beamFadeRadius = 20f;

	public float maxBeamScale = 2f;

	public float minBeamScale = 0.5f;

	public float maxTopBeamHeight = 0.5f;

	public float minTopBeamHeight = 0.1f;

	public float beamFadeTime = 0.5f;

	public float beamHideDistancethreshold = 0.2f;

	[Header("Rotator Handle Settings")]
	public GameObject rotatorHandlePrefab;

	[Tooltip("At what distance should you NOT be able to see the handle UI?")]
	public float sqrVisibleDistFadeOut = 81f;

	[Tooltip("At what distance should the handle UI be at max alpha?")]
	public float sqrVisibleDistFadeIn = 49f;

	[Header("Rotatable Object Settings")]
	public FixedRotatableObject.GrabbableArea defaultGrabArea = new FixedRotatableObject.GrabbableArea
	{
		radius = 0.6f,
		height = 0.2f,
		offset = 0.85f
	};

	[Header("Lever Settings")]
	public LeverInfo defaultLeverSettings = new LeverInfo(0.5f, 40f, 0.5f, 0.1f, 0.25f);

	public LeverInfo portalMachineSettings;

	public LeverInfo heavyLeverSettings;

	public LeverInfo verticalLeverSettings;

	[Header("Highlight Settings")]
	public Mesh highlightMesh;

	public const int maxHighlights = 50;

	public Material proxHighlightMat;

	public Material handHighlightMat;

	public float highlightProximityDist = 4f;

	public float highlightProximitySize = 0.25f;

	public float highlightHighlightSize = 0.75f;

	public float highlightFadeOutTime = 0.5f;

	public float highlightScaleTime = 0.5f;

	public float highlightMoveSpeed = 0.2f;

	public float highlightLookAtAngle = 90f;

	[Header("Shatter Settings")]
	public float shatterTime = 2f;

	public float shatterFadeTime = 2f;

	public AnimationCurve shatterScaleCurve;

	[Header("SFX Assets")]
	public FMODEventAsset sfxGravityChanged;

	public FMODEventAsset sfxHighlight;

	public FMODEventAsset sfxMove;

	public FMODEventAsset sfxShatter;

	public FMODEventAsset sfxDissolve;

	public FMODEventAsset sfxHandEnterIllyria;

	public FMODEventAsset sfxHandExitIllyria;

	public FMODEventAsset fullCogTurn;

	public FMODEventAsset partialCogTurn;

	[Header("Gear Settings")]
	public float gearTurnSoundFrequency = 1f;

	[Header("Collision Settings")]
	public float collisionDetectRange = 0.075f;

	public float springStrength = 200f;

	public float springDamping = 20f;

	[Header("Throw Settings")]
	public float throwLinearVelocitySkip = 0.01f;

	public float throwLinearVelocityLength = 0.15f;

	public float throwLinearVelocityLookahead = 0.015f;

	public float throwAngularVelocitySkip = 0.01f;

	public float throwAngularVelocityLength = 0.15f;

	public float throwAngularVelocityLookahead = 0.015f;

	[Header("Chain Settings")]
	public GameObject chainNodePrefab;

	public Mesh chainNodeMesh;

	public GameObject chainHandlePrefab;

	public float chainHandleDistance;

	[Range(0.01f, 1f)]
	public float chainDrag = 0.1f;

	[Range(0.01f, 1f)]
	public float chainBounce = 0.2f;

	[Tooltip("How much distance should the chain move before playing the sound.")]
	public float chainSoundDistance = 0.2f;

	[Tooltip("At how many m/s should the chain speed parameter be at maximum?")]
	public float chainSoundMaxSpeed = 0.4f;

	public FMODEventAsset soundChainMove;

	public FMODEventAsset soundChainGrab;

	[Header("Object Snatcher Settings")]
	public AnimationCurve objectSnatcherRotationGrabSpeed;

	public AnimationCurve objectSnatcherRotationReleaseSpeed;

	public AnimationCurve objectSnatcherLocalPosGrabCurve;

	public AnimationCurve objectSnatcherLocalPosReleaseCurve;

	[Header("Hand Animations")]
	[FormerlySerializedAs("occlusionPoseWeightSpeed")]
	public float overrideLayerWeightSpeed = 4f;

	public AnimationCurve handGlowCurve;

	public Color handGlowColor;

	public float handGrabGlowAnimTime = 1f;

	[Header("Hook Point Settings")]
	public float particleMaxDist = 2f;

	[Header("Dither Settings")]
	public float nearFadeMaxDist = 0.2f;

	public float nearFadeMinDist = 0.15f;

	public float nearFadeHandDistMax = 0.2f;

	public float nearFadeHandDistMin = 0.05f;

	public float nearFadeObjToInvDistMax = 0.12f;

	public float nearFadeObjToInvDistMin = 0.02f;

	public float minimalDitherValue = 0.1f;

	public float ditherAnimTime = 0.3f;

	[Header("Rasterizer Snap Settings")]
	[Range(0f, 2f)]
	public float snapRadius = 0.05f;

	[Range(0.1f, 2f)]
	public float snapSpeed = 1f;

	public AnimationCurve snapCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	[Header("UI Alpha Fade Settings")]
	[LabelOverride("UI Alpha Dist Curve")]
	public AnimationCurve uiAlphaDistCurve;

	[LabelOverride("UI Alpha Look At Curve")]
	public AnimationCurve uiAlphaLookAtCurve;

	[Range(0f, 180f)]
	public float lookAtMinDeg;

	[Range(0f, 180f)]
	public float lookAtMaxDeg;

	public float GetUIAlpha(Vector3 UIPosition, float radius)
	{
		float a = Mathf.Cos(lookAtMaxDeg * ((float)Math.PI / 180f));
		float b = Mathf.Cos(lookAtMinDeg * ((float)Math.PI / 180f));
		float num = Vector3.Distance(MainCamera.Inst.transform.position, UIPosition) - radius;
		float num2 = uiAlphaDistCurve.Evaluate(num / Mathf.Clamp(radius, 0f, 1f));
		Vector3 vector = UIPosition - MainCamera.Inst.transform.position;
		float f = Vector3.Dot(MainCamera.Inst.transform.forward, vector.normalized);
		float value = uiAlphaLookAtCurve.Evaluate(Mathf.Acos(f) * 57.29578f);
		float num3 = Mathf.InverseLerp(a, b, value);
		return num2 * num3;
	}

	public LeverInfo GetLeverInfo(LeverType leverType)
	{
		return leverType switch
		{
			LeverType.PORTAL_MACHINE => portalMachineSettings, 
			LeverType.HEAVY => heavyLeverSettings, 
			LeverType.VERTICAL => verticalLeverSettings, 
			_ => defaultLeverSettings, 
		};
	}
}
[CreateAssetMenu(fileName = "InventorySettings", menuName = "Nexus Settings/Inventory Settings", order = 0)]
public class InventorySettings : BaseSettings<InventorySettings>
{
	[Serializable]
	public class InventoryMaterialDictionary : SerialisableDictionary<string, Material>
	{
	}

	[Serializable]
	public struct InventorySpring
	{
		public float strength;

		public float dampening;

		public InventorySpring(float strength, float dampening)
		{
			this.strength = strength;
			this.dampening = dampening;
		}
	}

	[Header("Material Settings")]
	public Material defaultInventoryMaterial;

	public InventoryMaterialDictionary inventoryMaterialOverrides;

	[Header("General Settings")]
	[Space]
	[Tooltip("Time needed to hold button down")]
	public float inventoryOpenTime = 1f;

	[Tooltip("The local scale of each inventory item")]
	public float itemScale = 0.3f;

	[Tooltip("The local scale of each inventory item")]
	public float itemSelectedScale = 0.4f;

	[Tooltip("The color of the add and remove effect")]
	public Color effectColour = Color.white;

	[Tooltip("The size of the effect gradiant")]
	[Range(0.01f, 1f)]
	public float effectGradiant = 0.25f;

	[Tooltip("Colour for the Inventory Radial Ring")]
	public Color uiColor = Color.white;

	[Tooltip("Colour for the Inventory Radial Ring Outline")]
	public Color uiOutlineColor = Color.black;

	[Tooltip("Positional offset for the icon shown when object is in a placement helper, based on head-InvObj line")]
	public float helperPosOffset = 1.25f;

	[Tooltip("Scale multiplier for the icon shown when object is in a placement helper")]
	public float helperScaleOffset = 1.25f;

	[Space]
	[Header("SFX Settings")]
	[Space]
	[Tooltip("Open Inventory sound")]
	public FMODEventAsset sfxOpen;

	[Tooltip("Close Inventory sound")]
	public FMODEventAsset sfxClose;

	[Tooltip("Add To Inventory sound")]
	public FMODEventAsset sfxAdd;

	[Tooltip("Remove From Inventory sound")]
	public FMODEventAsset sfxRemove;

	[Tooltip("Sound for radial timer")]
	public FMODEventAsset sfxRadialTimer;

	public FMODEventRef soundODZEmitting;

	public FMODEventRef soundODZPassThrough;

	[Tooltip("Sound for radial timer")]
	public FMODEventAsset sfxJournalEnter;

	[Tooltip("Sound for radial timer")]
	public FMODEventAsset sfxIDEnter;

	[Tooltip("Sound for radial timer")]
	public FMODEventAsset sfxIDExit;

	[Tooltip("Sound for radial timer")]
	public FMODEventAsset sfxLetterEnter;

	[Tooltip("Sound for radial timer")]
	public FMODEventAsset sfxLetterExit;

	[Space]
	[Header("Inventory Settings")]
	[Space]
	[Tooltip("Time for inventoryUI to fade in/out")]
	public float inventoryUIFadeTime = 0.1f;

	[Tooltip("Time for inventoryUI to fade in/out")]
	public float inventoryUIMaxAlpha = 0.75f;

	[Tooltip("Max distance the player moves before the inventory closes")]
	public float inventoryMaxDistance = 2f;

	[Tooltip("The minimum seperation between items")]
	public float inventoryMinSeperation = 0.5f;

	[Tooltip("The distance the player moves away to close inventory")]
	public float inventoryCloseDistance = 2f;

	[Tooltip("The depth from the head the inventory appears")]
	public Vector3 inventoryoffset = new Vector3(0f, 0f, 0.5f);

	[Tooltip("The spring which controls the total inventory movement and scaling")]
	public InventorySpring inventorySpring = new InventorySpring(1f, 0.5f);

	[Tooltip("The spring which controls the item movement")]
	public InventorySpring inventoryItemPosSpring = new InventorySpring(1f, 0.5f);

	[Tooltip("The spring which controls the item Scaling")]
	public InventorySpring inventoryItemScaleSpring = new InventorySpring(1f, 0.5f);

	[Tooltip("The spring which controls the items when the inventory is closing")]
	public InventorySpring inventoryItemCloseSpring = new InventorySpring(1f, 0.5f);

	[Tooltip("The spring which controls the items when the inventory is in the add animation")]
	public InventorySpring inventoryItemAddSpring = new InventorySpring(1f, 0.5f);

	[Tooltip("Distance away the background ring is")]
	public Vector3 bagPositionOffset = new Vector3(0f, -0.05f, 0.2f);

	[Tooltip("Range which items classed as being settled/end of spring")]
	public float itemPositionSettleDistance = 0.02f;

	[Tooltip("Range which items classed as being settled/end of spring")]
	public float itemScaleSettleDistance = 0.01f;

	[Tooltip("The point at which the object will be invisible when scaling")]
	public float itemMinDitherScale = 0.15f;

	[Tooltip("Time the inventory will remain open after grabbing an item")]
	public float inventoryCloseAfterGrabTime = 1f;

	[Tooltip("Time the inventory will remain open if player has not done anything")]
	public float inventoryCloseAfterIdleTime = 2f;

	[Tooltip("Time until the inventory will settle if player is constantly looking around")]
	public float inventoryForceSettleTime = 2f;

	[Tooltip("The range at which the hand is considered in the invetory thus stopping it from closing")]
	public float handInInventoryRange = 0.5f;

	[Space]
	[Header("ODZ Settings")]
	[Tooltip("The spring which controls the item movemnt during ODZ Enter animation")]
	public InventorySpring inventoryItemEGrillEnterPosSpring = new InventorySpring(1f, 0.5f);

	[Tooltip("The spring which controls the item movemnt during ODZ Enter animation")]
	public InventorySpring inventoryItemEGrillExitPosSpring = new InventorySpring(1f, 0.5f);

	[Tooltip("How far away the objects go during ODZ animations")]
	public float inventoryEGrillOffsetMultiplier = 2f;

	[Tooltip("How long inventory objects take to fade to and from EGrill colour")]
	public float inventoryEGrillObjectFadeTime = 0.5f;

	[Space]
	[Header("Grab Settings")]
	[Space]
	[Tooltip("The time the hand has to rest on the object for before it grows")]
	public float grabRestTime = 0.5f;

	[Tooltip("The Distance from items target position it has to be before being grabbable")]
	public float itemGrabRestDistance = 0.1f;

	[Tooltip("The Size of the hand used in intersection tests")]
	public float handSize = 0.1f;

	[Tooltip("The minimum scale the non grabed objects will reach when grabbing")]
	public float itemMinScale = 0.1f;

	[Range(0f, 180f)]
	[Tooltip("The angle offset applied when an object is highlighted")]
	public float itemAngleOffset;

	[Space]
	[Header("Add To Inventory Effect Settings")]
	[Space]
	[Tooltip("The time it takes for the object to fill")]
	public float objectFillTime = 1f;

	[Tooltip("The curve that controls object filling")]
	public AnimationCurve objectFillCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	[Tooltip("The delay between the object filling and hand filling")]
	public float handFillDelay = 1f;

	[Tooltip("The time it takes for the hand effect to fill the hand")]
	public float handFillTime = 1f;

	[Tooltip("The curve which controls the hand effect Fill")]
	public AnimationCurve handFillCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	[Tooltip("The delay between the hand effect appearing and fading away")]
	public float handFadeDelay = 1f;

	[Tooltip("The time it takes for the hand effect to fade away")]
	public float bagCloseDelay = 0.3f;

	[Tooltip("The curve which controls the hand effect fade out")]
	public AnimationCurve handFadeOutCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	[Tooltip("How long the object will stay in the centre before moving up to position")]
	public float centrePosTime = 1f;

	[Tooltip("The curve which controls the object scaling when being added")]
	public AnimationCurve centreScaleCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	[Space]
	[Header("Remove from Inventory Effect Settings")]
	[Space]
	[Tooltip("The time it takes for the hand effect to fade in")]
	public float handFadeInTime = 1f;

	public AnimationCurve handFadeInCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	[Tooltip("The delay between the hand effect appearing and unfilling")]
	public float handUnfillDelay = 1f;

	[Tooltip("The time it takes for the hand effect to unfill the hand")]
	public float handUnfillTime = 1f;

	public AnimationCurve handUnfillCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	[Tooltip("The delay between the object filling and unfilling")]
	public float objectUnfillDelay = 1f;

	[Tooltip("The time it takes for the object to unfilling")]
	public float objectUnfillTime = 1f;

	[Tooltip("The curve that controls object unfilling")]
	public AnimationCurve objectUnfillCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	[Tooltip("The time until the item is auto removed from the inventory")]
	public float maxRemovalMarkTime = 120f;

	[Space]
	[Header("Story Items")]
	[Space]
	[Tooltip("Delay before anim is played after bag open anim")]
	public float itemAddAnimDelay = 0.5f;

	public float storyItemPoofDelay = 10f;

	public float storyItemShowDelay = 1.5f;

	public Vector3 ItemScale => new Vector3(itemScale, itemScale, itemScale);

	public Vector3 ItemSelectedScale => new Vector3(itemSelectedScale, itemSelectedScale, itemSelectedScale);

	public Vector3 HelperScaleOffset => new Vector3(helperScaleOffset, helperScaleOffset, helperScaleOffset);

	public float InventoryMaxDistanceSQR => inventoryMaxDistance * inventoryMaxDistance;

	public float HandInInventoryRangeSQR => handInInventoryRange * handInInventoryRange;

	public Vector3 ItemMinScale => new Vector3(itemMinScale, itemMinScale, itemMinScale);

	public Material GetInventoryMaterial(string shaderName)
	{
		if (inventoryMaterialOverrides.dict.ContainsKey(shaderName))
		{
			return inventoryMaterialOverrides.dict[shaderName];
		}
		return defaultInventoryMaterial;
	}
}
[CreateAssetMenu(fileName = "LightSettings", menuName = "Nexus Settings/Light Settings", order = 0)]
public class LightSettings : BaseSettings<LightSettings>
{
	[Header("Fixed Rotatable Settings")]
	public float fixedRotatableSpringStrength = 500f;

	public float fixedRotatableSpringDamping = 20f;

	public float fixedRotatableSnapArea = 5f;

	public float fixedRotatableAngularDrag = 2f;

	[Space]
	[Header("Animation Settings")]
	public AnimationCurve automaticRotationAnimCurve;

	public AnimationCurve lightEnableIntensityCurve;

	public AnimationCurve lightFlickerIntensityCurve;

	public float enableTime = 1f;

	public float disableTime = 1f;

	[Space]
	[Header("Light Cone Settings")]
	public float lightConeWidth = 0.05f;

	public float lightConeHeight = 0.107f;

	public int lightConeResolution = 24;

	[Space]
	[Header("Light Lens Settings")]
	public Color lightLensColorLit = Color.white;

	public Color lightLensColorUnlit = Color.gray;

	[Space]
	[Header("SFX Assets")]
	public FMODEventAsset soundLightTurnOn;

	public FMODEventAsset soundLightTurnOff;

	public FMODEventAsset sensorReceivingLoop;

	[Space]
	[Header("Indicator Settings")]
	public float indicatorVerticalOffset;

	public float indicatorOutwardOffset;
}
[CreateAssetMenu(fileName = "ObeliskSettings", menuName = "Nexus Settings/Obelisk Settings", order = 0)]
public class ObeliskSettings : BaseSettings<ObeliskSettings>
{
	public Material nodeEmptyMat;

	public Material nodeFillMat;

	public Material nodeFilledMat;

	public Material nodeEmptySilverMat;

	public Material nodeFillSilverMat;

	public Material nodeFilledSilverMat;

	public Material lineEmptyMat;

	public Material lineFillMat;

	public Material lineFilledMat;

	public Material lineEmptySilverMat;

	public Material lineFillSilverMat;

	public Material lineFilledSilverMat;

	public GameObject obeliskNode;

	public GameObject obeliskConnection;

	public float lineFillTime = 0.2f;

	public float circleFillTime = 0.2f;

	public float obeliskLookAtTime = 1f;

	[Range(0f, 1f)]
	public float maxLineFill = 1f;

	[Range(0f, 1f)]
	public float maxCircleFill = 0.75f;

	[Range(0f, 1f)]
	public float obeliskLookAtAccuracy = 0.75f;

	public FMODEventAsset soundNode;

	public FMODEventAsset soundNodeFinal;

	public FMODEventAsset soundPillar;
}
[CreateAssetMenu(fileName = " OcclusionSettings", menuName = "Nexus Settings/Occlusion Settings", order = 0)]
public class OcclusionSettings : BaseSettings<OcclusionSettings>
{
	[Serializable]
	public struct StateIndicatorSettings
	{
		public Mesh dotMesh;

		public AnimationCurve dotScaleByRadius;

		public AnimationCurve dotSpacingByRadius;

		public int endMeshDetail;

		public AnimationCurve endMeshSizeCurve;

		public float endMeshYScale;

		[LabelOverride("UI Material")]
		public Material uiMaterial;

		public float scaleDownSpeed;

		public float scaleUpSpeed;

		public float nonSelectedAlpha;

		public float selectedScale;
	}

	[Header("Logical Values")]
	public float occlusionResetPercentage = 0.15f;

	public float maxPercentageIncreaseDelta = 0.75f;

	public float maxPercentageDecreaseDelta = 0.75f;

	public float OccludabilityChangeSpeed = 0.75f;

	[Header("Feedback - On Change")]
	public FMODEventAsset sfxOnChange;

	[Range(0f, 1f)]
	public float hapticFrequencyOnChange = 0.5f;

	[Range(0f, 1f)]
	public float hapticAmplitudeOnChange = 0.25f;

	public float hapticTimeOnChange = 0.15f;

	public float pulseSpeed = 2f;

	public ParticleType occludeeParticleEffect;

	public ParticleType occluderParticleEffect;

	[Header("Feedback - Contiuous")]
	public FMODEventAsset sfxFeedback;

	public AnimationCurve alphaCurve;

	[Header("State Indicator Spots")]
	public StateIndicatorSettings stateIndicatorSettings = new StateIndicatorSettings
	{
		dotMesh = null,
		dotScaleByRadius = AnimationCurve.Linear(0.1f, 1f, 2f, 2f),
		dotSpacingByRadius = AnimationCurve.Linear(0.1f, 0.05f, 2f, 0.2f),
		endMeshDetail = 10,
		endMeshSizeCurve = AnimationCurve.EaseInOut(0f, 0.1f, 1f, 0.35f),
		endMeshYScale = 0.04f,
		uiMaterial = null,
		scaleDownSpeed = 2f,
		scaleUpSpeed = 1f,
		nonSelectedAlpha = 0.8f,
		selectedScale = 2f
	};
}
[CreateAssetMenu(fileName = "ODZSettings", menuName = "Nexus Settings/ODZ Settings", order = 0)]
public class ODZSettings : BaseSettings<ODZSettings>
{
	public FMODEventAsset impactSFX;

	public ParticleType impactParticle;
}
[CreateAssetMenu(fileName = "PortalSettings", menuName = "Nexus Settings/Portal Settings", order = 0)]
public class PortalSettings : BaseSettings<PortalSettings>
{
	public enum PortalEyeglassVariation
	{
		None,
		Frame,
		FrameFixed,
		Stand
	}

	[Serializable]
	public struct PortalTypeSettings
	{
		public Material basePortalMaterial;

		public PortalEyeglassVariation eyeglassVariation;

		public PortalSFX sfx;

		public AnimationCurve portalOpenCurve;

		public AnimationCurve portalCloseCurve;

		public float expansionTime;

		public float eyeglassExpansionTime;

		public float expansionDelay;

		public float maxStep;

		public float minStep;

		[Header("Miscs")]
		public int portalRange;

		public Material defaultSurfaceMaterial;

		[Header("Particles")]
		public GameObject particleGodRays;

		public GameObject particleDots;

		public GameObject particleTrails;

		public int GetRangeSqr()
		{
			return portalRange * portalRange;
		}
	}

	[Serializable]
	public struct PortalSFX
	{
		public FMODEventRef closedIdleSFX;

		public FMODEventRef openExplosionSFX;

		public FMODEventRef openIdleSFX;

		public FMODEventRef closedExplosionSFX;

		public FMODEventRef lockSFX;

		public FMODEventRef unlockSFX;

		public FMODEventRef crossingPortalSFX;

		public FMODEventRef mirrorItemSFX;
	}

	[FormerlySerializedAs("StandardSettings")]
	public PortalTypeSettings WithinWorldsSettings;

	[FormerlySerializedAs("FantasySettings")]
	public PortalTypeSettings BetweenWorldsSettings;

	public PortalTypeSettings MirrorSettings;

	public PortalTypeSettings FakeMirrorSettings;

	public PortalTypeSettings PassThroughMirrorSettings;

	public PortalTypeSettings StealthSettings;

	public PortalTypeSettings HubUnlockSettings;

	public PortalTypeSettings[] EyeglassSettings;

	[Header("Mirror Particles")]
	public float minDistanceToMirror = 2f;

	public float mirroCutoffDistance = 0.2f;

	public AnimationCurve mpEmissionRateCurve;

	public int mpMinParticleCount = 2;

	public int mpMaxParticleCount = 10;

	[Header("Mirror Ripple Settings")]
	public float rippleMaxSpeed = 0.2f;

	public float rippleFrequency = 0.1f;

	public float rippleAlpha = 1f;

	public float rippleMaxSize = 0.4f;

	public float rippleStartDistance = 0.5f;

	public float rippleMirrorCamFadeInDist = 0.1f;

	public AnimationCurve rippleScaleCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public AnimationCurve rippleSpeedCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	[Header("Mirror Render Settings")]
	public float mirrorAlwaysEnabledDist = 2f;

	public float mirrorFrostDist = 7f;

	public float mirrorForceDisabledDist = 10f;

	public float mirrorMagicDisableNumber = 5f;

	[Range(0f, 1f)]
	public float mirrorMinimumScreenSpacePercentage = 0.1f;

	public float mirrorFrostTime = 0.5f;

	[Header("Portal Machine Settings")]
	public FMODEventRef fitBatterySFX;

	public FMODEventRef batteryOnSFX;

	public FMODEventRef handleMoveSFX;

	public FMODEventRef handleStopSFX;

	public FMODEventRef warmingUpSFX;

	public FMODEventRef leverLockSFX;

	public FMODEventRef leverUnlockSFX;

	public FMODEventRef resetButtonSFX;

	public FMODEventRef resetCountSFX;

	public FMODEventRef resettingSFX;

	public Sprite noBattery;

	public Sprite noPower;

	public Sprite puzzles;

	[Space]
	public FMODEventAsset portalIdleSound;

	public PortalTypeSettings GetSettings(PortalType type, PortalEyeglassVariation variation = PortalEyeglassVariation.None)
	{
		return type switch
		{
			PortalType.WithinWorlds => WithinWorldsSettings, 
			PortalType.BetweenWorlds => BetweenWorldsSettings, 
			PortalType.Mirror => MirrorSettings, 
			PortalType.FakeMirror => FakeMirrorSettings, 
			PortalType.Stealth => StealthSettings, 
			PortalType.Eyeglass => Enumerable.FirstOrDefault(EyeglassSettings, (PortalTypeSettings setting) => setting.eyeglassVariation == variation), 
			PortalType.PassThroughMirror => PassThroughMirrorSettings, 
			_ => WithinWorldsSettings, 
		};
	}
}
[CreateAssetMenu(fileName = "RasterizerSettings", menuName = "Nexus Settings/Rasterizer Settings", order = 0)]
public class RasterizerSettings : BaseSettings<RasterizerSettings>
{
	[Serializable]
	public struct RasterizerFeedbackSettings
	{
		[LabelOverride("Sound Effects")]
		public bool sfxFeedbackEnabled;

		public FMODEventRef SFX2D;

		public FMODEventRef SFX3D;

		public FMODEventRef SFX2DSecret;

		public FMODEventRef SFX3DSecret;

		public float particleFeedbackEmitRate;

		public GameObject particleEffectPrefab;

		[LabelOverride("Haptic Feedback")]
		public bool hapticFeedbackEnabled;
	}

	[Space]
	[Header("Normal Colors")]
	public Color colorShadowLines;

	public Color colorShadowLinesIncomplete;

	public Color colorShadowLinesIncompleteUnderShadow;

	public Color colourCompleted;

	public Color colourFlash = Color.white;

	[Space]
	[Header("Secret Colors")]
	public Color colorSecretShadowLines;

	public Color colorSecretShadowLinesIncomplete;

	public Color colorSecretShadowLinesIncompleteUnderShadow;

	public Color colourSecretCompleted;

	public Color colourSecretFlash = Color.white;

	[Space]
	public RasterizerFeedbackSettings updateFeedback;

	public RasterizerFeedbackSettings completionFeedback;

	public FMODEventRef fireworkSFX;

	public FMODEventRef fireworkTrailSFX;

	public Texture2D noiseTexture;

	public int snapshotResolution = 2048;

	public int rasterizerPassTimeMSAndroid = 32;

	public int rasterizerPassTimeMSRift = 16;

	public float requiredMatchTime = 0.1f;

	public int snapshotStrokeMask = 3;

	public AnimationCurve curveCanvasBrightnessOnCompletion;

	[Header("Rasterizer Debug View Settings")]
	public bool EdgeDetection;

	public bool Tolerance;

	public bool Comparison;

	public bool Blur;

	[Header("Effect Settings")]
	public int strokeModifier;

	public int blurKernalSize = 9;

	public float blurIntensity = 8f;

	public AnimationCurve kernalCurve;

	public int godRayCount = 20;

	public int numberOfRayDirections = 4;

	public int godRayMinLength = 10;

	public int godRayMaxLength = 25;

	public int godRayExtents = 2;

	public int godRaySeparation = 5;

	public float pulseWidth;

	public Texture2D blurFractal;

	public Texture2D blurFractalLarge;

	[Header("Completion Effects")]
	public Material mergedFillMaterial;

	public float scaleAnimTime = 1f;

	public float colorAnimTime = 0.5f;

	public float circleAnimTime = 1.5f;

	public float postCompletionDelayTime = 1.7f;

	public float postCompletionFadeTime = 1f;
}
[CreateAssetMenu(fileName = "LayoutNameHere", menuName = "Nexus Settings/UI Settings - Start Menu Layout", order = 101)]
public class StartMenuLayout : ScriptableObject
{
	public enum StartMenuButtons
	{
		HideMenu,
		Teleport,
		MainMenu,
		Quit,
		HideMenuFake
	}

	public StartMenuButtons[] startMenuEntries;
}
[CreateAssetMenu(fileName = "TeleportSettings", menuName = "Nexus Settings/Teleport Settings", order = 0)]
public class TeleportSettings : BaseSettings<TeleportSettings>
{
	public enum Mode
	{
		Teleport,
		DualInput
	}

	public enum SpeedSetting
	{
		Slow,
		Medium,
		Fast
	}

	public enum TurnSetting
	{
		Small,
		Medium,
		Large
	}

	public enum DirectionMode
	{
		HeadRelative,
		HandRelative
	}

	public enum FreeMoveRotateSetting
	{
		Snap,
		Smooth
	}

	public enum VignettePresets
	{
		Preset1,
		Preset2,
		Preset3,
		None
	}

	[Serializable]
	public class VignettePreset
	{
		public float vignetteRadius = 0.6f;

		public float vignetteSoftness = 0.6f;

		public float vignetteStrength = 1f;

		public float vignetteFadeTime = 0.9f;
	}

	[Header("Teleporting")]
	public AnimationCurve pingScaleCurve;

	[Header("Teleporting")]
	public AnimationCurve pingAlphaCurve;

	public static Material teleportUIMaterial;

	public float telepadPointRadius = 0.4f;

	public float collisionBoxFloorAllowance = 0.3f;

	public float collisionBoxHeadClearance = 0.3f;

	public float collisionBoxExtent = 0.35f;

	public float angleFromHandToFloorForReorientation = 15f;

	public float angleFromHeadToFloorToChooseHeadForward = 60f;

	public float teleportRange = 7.5f;

	public float teleportMaxYOffset = 1.5f;

	public float teleportFadeDurationSlow = 0.2f;

	public float teleportFadeDurationMedium = 0.15f;

	public float teleportFadeDurationFast = 0.1f;

	public float cutsceneFadeDuration = 1f;

	public FMODEventRef TeleportSFX;

	public FMODEventRef cutsceneIntroSFX;

	public FMODEventRef cutsceneOutroSFX;

	[Header("Region snapping")]
	public float maxHeightToRegionSnap = 1.2f;

	public float minHeightToRegionSnap = -0.2f;

	public float maxXZDistanceToRegionSnap = 1f;

	public float farFromRegionDist = 0.5f;

	[Header("Teleport Arc")]
	public int arcNumSegments = 15;

	public float arcGravitySpeed = 1.2f;

	public float arcStartSpeed = 3.52f;

	public float arcTime = 6f;

	public float arcWidth = 0.1f;

	public float arcLengthAnimSpeed = 0.3f;

	public float arcYAngleOffset;

	public float arcMaxDotAngle = 0.4f;

	public AnimationCurve arcAlphaCurve;

	public AnimationCurve arcWidthCurve;

	public AnimationCurve arcGravityCurve;

	public AnimationCurve arcSpeedDropOffCurve;

	public Color arcStartColor;

	public Color arcEndColor;

	public Color arcColorInvalid;

	[Range(5f, 16f)]
	public int baseShapeSides = 8;

	public Material arcMaterial;

	[Header("Telepoints")]
	[LabelOverride("Default Base Color")]
	public Color defaultTelepointBaseColor;

	[LabelOverride("Cutscene Base Color")]
	public Color cutsceneTelepointBaseColor;

	[LabelOverride("Inner Radius")]
	public float telepointInnerRadius = 0.5f;

	[LabelOverride("Outer Radius")]
	public float telepointOuterRadius = 0.5f;

	[LabelOverride("Stood-On Distance")]
	public float telepointStoodOnDistance = 0.2f;

	[LabelOverride("Direction Tolerance")]
	public float telepointDirectionThresholdInDegrees = 15f;

	[LabelOverride("Ring Height By Arrow Distance")]
	public AnimationCurve telepointHeightByArrowDistanceCurve;

	[LabelOverride("Ring Height By Head Distance")]
	public AnimationCurve telepointHeightByHeadDistanceCurve;

	[LabelOverride("Arrow Alpha By Distance")]
	public AnimationCurve telepointArrowAlphaByDistanceCurve;

	[LabelOverride("Ring Alpha By Distance")]
	public AnimationCurve telepointRingAlphaByDistanceCurve;

	[LabelOverride("Outline Alpha By Distance")]
	public AnimationCurve telepointOutlineAlphaByDistanceCurve;

	[NonSerialized]
	public float telepointMaxVisibleDistance;

	[Header("Arrow")]
	public AnimationCurve telepointArrowBounceCurve;

	public float teleportArrowRestHeight = 0.1f;

	[Header("FreeMove")]
	public bool vignetteForceShow;

	public Mesh vignetteMesh;

	public Material vignetteMaterial;

	public float smallSnapAngle = 15f;

	public float mediumSnapAngle = 30f;

	public float largeSnapAngle = 45f;

	public float slowSmoothTurnSpeed = 30f;

	public float mediumSmoothTurnSpeed = 50f;

	public float fastSmoothTurnSpeed = 70f;

	[Range(0f, 90f)]
	public float freeMoveDeadZone = 20f;

	public float freeMoveSpeedSlow = 1f;

	public float freeMoveSpeedMedium = 3f;

	public float freeMoveSpeedFast = 5f;

	public float freeMoveStepHeight = 0.1f;

	public VignettePreset vignettePreset1;

	public VignettePreset vignettePreset2;

	public VignettePreset vignettePreset3;

	public VignettePreset vignetteNone;

	[Header("Letter Box")]
	public float letterBoxTime = 1.25f;

	public float letterBoxTarget = 0.35f;

	[Header("Front-facing")]
	public float frontfaceAngleToShowHint = 110f;

	public float frontfaceAngleToShowHintOnTeleport = 40f;

	public float frontfaceAngleToHideHint = 30f;

	[Header("Out of Bounds Settings")]
	public Material outOfBoundsMaterial;

	public float outOfBoundsFadeInSpeed = 5f;

	public float outOfBoundsFadeOutSpeed = 5f;

	public float outOfBoundsLerpSpeed = 5f;

	public float outOfBoundsIndicatorAlpha = 0.7f;

	public float outOfBoundsArrowYOffset = -0.2f;

	public float outOfBoundsTextYOffset = 0.2f;

	public float outOfBoundsArrowYTilt = -0.3f;

	public float outOfBoundsArrowZOffset = 1f;

	public float outOfBoundsTextZOffset = 1.5f;

	public float outOfBoundsTextFadeInitial = 0.5f;

	public float outOfBoundsTextFadeTotal = 2.5f;

	public float outOfBoundsArrowBobSpeed = 1f;

	public float outOfBoundsArrowBobDistance = 0.2f;

	public FMODSnapshotAsset outOfBoundsSnapshot;

	public float cutsceneOOBMaxFade = 0.95f;

	public float cutsceneOOBStartDist = 0.8f;

	public float cutsceneOOBMaxDist = 0.4f;

	public float cutsceneOOBPauseAlpha = 0.7f;

	[Header("Hand Transition")]
	public float transitionTime = 1.5f;

	public float transitionHapticFreq = 0.6f;

	public float transitionHapticAmp = 0.2f;

	public float transitionHapticTime = 0.1f;

	[Header("Position Markers")]
	public Color trackingHintColor = Color.red;

	[Tooltip("Angle is in dot product form, 0.707 = 45deg and 0.87 = 30deg for reference.\n cos(AngleInDegrees) to be precise")]
	public float minCCVisibleAngle = 0.83f;

	[Tooltip("Angle is in dot product form, 0.707 = 45deg and 0.87 = 30deg for reference.\n cos(AngleInDegrees) to be precise")]
	public float maxCCVisibleAnlge = 0.87f;

	[Header("Re-center Settings")]
	public bool recenterShouldFade;

	public float recenterFadeTime = 0.15f;

	[Header("Seating Settings")]
	[Tooltip("The height the player will be set at in seating mode.")]
	public float defaultPlayerHeight = 1.6f;

	[Header("DEBUG")]
	public bool DEBUG_drawRegionGraph;

	public Material DEBUG_RegionMaterial;

	public bool DEBUG_drawRegionsInGame;

	public Mode InputMode
	{
		get
		{
			return LR.Inst.saveDataSettings.inputMode;
		}
		set
		{
			LR.Inst.saveDataSettings.inputMode = value;
			LR.Inst.Save();
		}
	}

	public float TeleportFadeSpeed => LR.Inst.saveDataSettings.teleportFadeSpeed switch
	{
		SpeedSetting.Slow => teleportFadeDurationSlow, 
		SpeedSetting.Medium => teleportFadeDurationMedium, 
		_ => teleportFadeDurationFast, 
	};

	public float FreeMoveSpeed => LR.Inst.saveDataSettings.freeMoveSpeed switch
	{
		SpeedSetting.Slow => freeMoveSpeedSlow, 
		SpeedSetting.Medium => freeMoveSpeedMedium, 
		_ => freeMoveSpeedFast, 
	};

	public float TurnAmountSnap => LR.Inst.saveDataSettings.turnAmount switch
	{
		TurnSetting.Small => smallSnapAngle, 
		TurnSetting.Medium => mediumSnapAngle, 
		TurnSetting.Large => largeSnapAngle, 
		_ => 0f, 
	};

	public float TurnAmountSmooth => LR.Inst.saveDataSettings.turnAmount switch
	{
		TurnSetting.Small => slowSmoothTurnSpeed, 
		TurnSetting.Medium => mediumSmoothTurnSpeed, 
		TurnSetting.Large => fastSmoothTurnSpeed, 
		_ => 0f, 
	};

	public VignettePreset VignetteSettings => ((LR.Inst != null && LR.Inst.saveDataSettings != null) ? LR.Inst.saveDataSettings.vignettePreset : VignettePresets.None) switch
	{
		VignettePresets.Preset1 => vignettePreset1, 
		VignettePresets.Preset2 => vignettePreset2, 
		VignettePresets.Preset3 => vignettePreset3, 
		_ => vignetteNone, 
	};

	protected override void Init()
	{
		base.Init();
		telepointMaxVisibleDistance = MathfX.Max(telepointArrowAlphaByDistanceCurve[telepointArrowAlphaByDistanceCurve.length - 1].time, telepointRingAlphaByDistanceCurve[telepointRingAlphaByDistanceCurve.length - 1].time, telepointOutlineAlphaByDistanceCurve[telepointOutlineAlphaByDistanceCurve.length - 1].time);
	}
}
[CreateAssetMenu(fileName = "TutorialSettings", menuName = "Nexus Settings/Tutorial Settings", order = 0)]
public class TutorialSettings : BaseSettings<TutorialSettings>
{
	public FMODEventAsset actionCompletion;

	public FMODEventAsset stepCompletion;

	[Space]
	public FMODEventRef soundRadio;

	public FMODEventRef soundRadio2;

	public float soundRadioDelta = 5f;

	[Header("Title Card Settings")]
	public float titleCardFadeTime = 2.5f;

	public float titleCardColorFadeInTime = 1f;

	public float titleCardPreFadeTime = 0.5f;

	public float titleCardWhiteStayTime = 5f;

	public float titleCardColorFadeBetweenTime = 1f;

	public float titleCardPostFadeTime = 2f;

	public float titleCardColorFadeOutTime = 1f;

	public float titleCardTrackingSpeed = 5f;

	public float titleCardDistance = 1.1f;

	public Color titleCardFadeInColorOne = Color.white;

	public Color titleCardFadeInColorTwo = Color.white;
}
[CreateAssetMenu(fileName = "UISettings", menuName = "Nexus Settings/UI Settings", order = 100)]
public class UISettings : BaseSettings<UISettings>
{
	public StartMenuLayout[] startMenuEntries;

	[Header("Pause Menu Settings")]
	public AnimationCurve pauseMenuRepositionCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float pauseMenuRepositionDistance = 0.18f;

	public float errorMessageDist = 0.75f;

	public float errorMessageLerp = 4f;

	[Header("Tracking Circle Settings")]
	public float trackingCircleBaseHeight = 0.025f;

	public float trackingCircleMaxHeight = 0.1f;

	public float trackingCircleLerpSpeed = 8f;
}
[CreateAssetMenu(fileName = "VaultSettings", menuName = "Nexus Settings/Vault Settings", order = 0)]
public class VaultSettings : BaseSettings<VaultSettings>
{
	public FMODEventAsset soundClockTurn;

	public FMODEventAsset soundMirrorTeleport;

	public FMODEventAsset soundPillarFlame;

	public FMODEventAsset soundPillarFlame2D;

	[Space]
	[Header("Pickup Sequence")]
	public AnimationCurve lightTurnCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float domeLowerTime = 3f;

	public float domeLowerAmount;

	public AnimationCurve domeLowerCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	[Space]
	[Header("Flame and Glow")]
	public AnimationCurve glowCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float glowtime = 2f;

	public float glowIntensity = 23f;

	[Space]
	public AnimationCurve flameCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float flameTime = 2f;

	public float flameBoost = 0.9f;

	[Space]
	[Header("Fade to White")]
	public Color whiteFadeOutColor = Color.white;

	public float whiteFadeDelay = 5f;

	public float whiteFadeInTime = 2f;

	public float whiteDelay = 1f;

	public float whitefadeOutTime = 1f;
}
[CreateAssetMenu(fileName = "VOSettings", menuName = "Nexus Settings/VO Settings", order = 0)]
public class VOSettings : BaseSettings<VOSettings>
{
	public FMODEventRef secretPuzzleCompleteVO;

	public float secretPuzzleCompleteDelay = 2f;

	[Header("VO Marker Settings")]
	public float particleEmissionDistance = 2f;

	public AnimationCurve symbolDistanceAlpha = AnimationCurve.Linear(0f, 0f, 1.5f, 1f);

	public float symbolDisableSpeed = 2f;

	[Space]
	public FMODVCARef vcaSFX;

	public FMODVCARef vcaMusic;

	public FMODVCARef vcaVO;

	public FMODEventRef[] sampleEvents;

	[Space]
	public AnimationCurve ambisonicMappingCurve;
}
public class HACK_AntiLight_LightKiller : MonoBehaviour, IAreaEvent, IAwakeEvent
{
	public IDObjectRef[] lightRefs;

	private LightSource[] lights;

	public void OnAwakeLR(MRBase owner)
	{
		lights = new LightSource[lightRefs.Length];
		for (int i = 0; i < lightRefs.Length; i++)
		{
			LR.Inst.TryGetIDObjectComponent<LightSource>(lightRefs[i], out lights[i]);
			lights[i].DisableLight();
		}
	}

	public void OnAreaEnter()
	{
		for (int i = 0; i < lights.Length; i++)
		{
			lights[i].EnableLight();
		}
	}

	public void OnAreaExit()
	{
		for (int i = 0; i < lights.Length; i++)
		{
			lights[i].DisableLight();
		}
	}
}
public class HAGIS_ClifftopsA_OcclusionRegionController : HAGIS
{
	public Occludee occlusionController;

	public Region regionToToggle;

	public int regionOnState;

	public bool startEnabled;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		if (!startEnabled)
		{
			regionToToggle.Disable();
		}
		else
		{
			regionToToggle.Enable();
		}
		while (true)
		{
			if (occlusionController.GetStateIndex() == regionOnState && !regionToToggle.IsEnabled)
			{
				regionToToggle.Enable();
			}
			else if (occlusionController.GetStateIndex() != regionOnState && regionToToggle.IsEnabled)
			{
				regionToToggle.Disable();
			}
			yield return occlusionController.OnStateChange;
		}
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_ClifftopsA_PendulumSwing : HAGIS
{
	[SerializeField]
	private float swingTime;

	[SerializeField]
	private float swingAmount;

	[SerializeField]
	private float hangTime;

	public IDObjectRef pendulumRef;

	[SerializeField]
	private float swingSoundTime;

	public FMODEventAsset pendulumSound;

	public Transform trackingPos;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		AnimRotateToTarget pendulumAnim = pendulumRef.GetComponent<AnimRotateToTarget>();
		float swingMax = 180f + swingAmount;
		float swingMin = 180f - swingAmount;
		while (true)
		{
			pendulumAnim.Animate(Quaternion.Euler(0f, 0f, swingMax), swingTime, localRotation: true);
			yield return Wait.For.Seconds(swingSoundTime);
			FAC.Inst.PlayOneShot(pendulumSound, trackingPos);
			yield return Wait.For.Seconds(swingTime - swingSoundTime);
			yield return Wait.For.Seconds(hangTime);
			pendulumAnim.Animate(Quaternion.Euler(0f, 0f, swingMin), swingTime, localRotation: true);
			yield return Wait.For.Seconds(swingSoundTime);
			FAC.Inst.PlayOneShot(pendulumSound, trackingPos);
			yield return Wait.For.Seconds(swingTime - swingSoundTime);
			yield return Wait.For.Seconds(hangTime);
		}
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_ClifftopsA_RoomFourFlowOcclusion : HAGIS
{
	public PuzzleInfo puzzle1Info;

	public LightSource lightSrc;

	public AnimRotateToTarget leftDoorAnim;

	public AnimRotateToTarget rightDoorAnim;

	public Region connectingRegion;

	public GameObject telepoint1;

	public FMODEventAsset doorSound;

	public Transform doorCenter;

	private const float lightIntensity = 0.5f;

	private const float lightSpotAngle = 35f;

	private const float lightAnimtime = 1f;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		connectingRegion.Disable();
		lightSrc.EnableLight();
		telepoint1.SetActive(value: true);
		yield return WaitForPuzzle(puzzle1Info);
		lightSrc.DisableLight();
		telepoint1.SetActive(value: false);
		if (!Routine.Skipping)
		{
			FAC.Inst.PlayOneShot(doorSound, leftDoorAnim.transform.position, 0.5f);
			FAC.Inst.PlayOneShot(doorSound, rightDoorAnim.transform.position, 0.5f);
			PSC.Inst.PlayAt(ParticleType.Door_Dust, doorCenter.transform.position).transform.rotation = doorCenter.transform.rotation;
		}
		yield return leftDoorAnim.AnimateOnYield(Quaternion.Euler(0f, 90f, 0f), 2f, localRotation: true) & rightDoorAnim.AnimateOnYield(Quaternion.Euler(0f, -90f, 0f), 2f, localRotation: true);
		connectingRegion.Enable();
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_ClifftopsA_RoomOneFlow : HAGIS
{
	public PuzzleInfo prePuzzleInfo;

	public PuzzleInfo puzzle1Info;

	public LightSource lightSrc;

	public Doorway doorway;

	public Transform doorCenter;

	public GameObject telepoint1;

	public FMODEventAsset doorSound;

	private const float lightIntensity = 0.5f;

	private const float lightSpotAngle = 35f;

	private const float lightAnimtime = 1f;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		if (prePuzzleInfo != null)
		{
			lightSrc.DisableLight();
			yield return WaitForPuzzle(prePuzzleInfo);
		}
		lightSrc.EnableLight();
		telepoint1.SetActive(value: true);
		yield return WaitForPuzzle(puzzle1Info);
		lightSrc.DisableLight();
		telepoint1.SetActive(value: false);
		doorway.Open(Routine.Skipping);
		PSC.Inst.PlayAt(ParticleType.Door_Dust, doorCenter.transform.position).transform.rotation = doorCenter.transform.rotation;
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_ClifftopsA_RoomThreeOcclusionFlow : HAGIS
{
	public PuzzleInfo puzzle2Info;

	public PuzzleInfo puzzle3Info;

	public LightSource lightSrc;

	public GameObject telepoint1;

	public FMODEventAsset doorSound;

	public Doorway doorway;

	public Transform doorCenter;

	private const float lightIntensity = 0.5f;

	private const float lightSpotAngle = 35f;

	private const float lightAnimtime = 1f;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		lightSrc.DisableLight();
		yield return WaitForPuzzle(puzzle2Info);
		lightSrc.EnableLight();
		telepoint1.SetActive(value: true);
		yield return WaitForPuzzle(puzzle3Info);
		lightSrc.DisableLight();
		telepoint1.SetActive(value: false);
		doorway.Open(Routine.Skipping);
		PSC.Inst.PlayAt(ParticleType.Door_Dust, doorCenter.transform.position).transform.rotation = doorCenter.transform.rotation;
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_ClifftopsA_RoomTwoFlowOcclusion : HAGIS
{
	public PuzzleInfo puzzle1Info;

	public LightSource lightSrc;

	public AnimRotateToTarget leftDoorAnim;

	public AnimRotateToTarget rightDoorAnim;

	public Region connectingRegion;

	public GameObject telepoint1;

	public FMODEventAsset doorSound;

	public Transform doorCenter;

	private const float lightIntensity = 0.5f;

	private const float lightSpotAngle = 35f;

	private const float lightAnimtime = 1f;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		connectingRegion.Disable();
		lightSrc.EnableLight();
		telepoint1.SetActive(value: true);
		yield return WaitForPuzzle(puzzle1Info);
		lightSrc.DisableLight();
		telepoint1.SetActive(value: false);
		if (!Routine.Skipping)
		{
			FAC.Inst.PlayOneShot(doorSound, leftDoorAnim.transform.position, 0.5f);
			FAC.Inst.PlayOneShot(doorSound, rightDoorAnim.transform.position, 0.5f);
			PSC.Inst.PlayAt(ParticleType.Door_Dust, doorCenter.transform.position).transform.rotation = doorCenter.transform.rotation;
		}
		yield return leftDoorAnim.AnimateOnYield(Quaternion.Euler(0f, 90f, 0f), 2f, localRotation: true) & rightDoorAnim.AnimateOnYield(Quaternion.Euler(0f, -90f, 0f), 2f, localRotation: true);
		connectingRegion.Enable();
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_ClifftopsA_Section5_Flow : HAGIS
{
	public PuzzleInfo prePuzzleInfo;

	public LightSource lightSrc1;

	public LightSource lightSrc2;

	public PuzzleInfo puzzle1Info;

	public PuzzleInfo puzzle2Info;

	public GameObject telepoint1;

	public Occludee occludeeDoor;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		lightSrc1.DisableLight();
		lightSrc2.DisableLight();
		yield return WaitForPuzzle(prePuzzleInfo);
		lightSrc1.EnableLight();
		telepoint1.SetActive(value: true);
		yield return WaitForPuzzle(puzzle1Info);
		lightSrc1.DisableLight();
		lightSrc2.EnableLight();
		yield return WaitForPuzzle(puzzle2Info);
		lightSrc2.DisableLight();
		telepoint1.SetActive(value: false);
		occludeeDoor.isOccludable = true;
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_ClifftopsA_WellObject : HAGIS
{
	public IDObjectRef grabObjectIdRef;

	public IDObjectRef targetFrustumRef;

	private GrabObject grabObject;

	private FrustumDetector targetFrustum;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		grabObject = grabObjectIdRef.Get<GrabObject>();
		targetFrustum = targetFrustumRef.Get<FrustumDetector>();
		yield return targetFrustum.OnInside | grabObject.OnObjectGrabbed;
		grabObject.ForceBreak();
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_ClifftopsA_WellSwap : HAGIS
{
	public IDObjectRef cliffFrustumRef;

	public IDObjectRef cliffPortalRef;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		FrustumDetector frustumDetector = cliffFrustumRef.Get<FrustumDetector>();
		cliffPortalRef.Get<Portal>().gameObject.SetActive(value: false);
		frustumDetector.enabled = false;
		yield break;
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class ClifftopsB_Lamp_ForceRotate : MonoBehaviour, IUpdateEvent
{
	public FixedRotatableObject rotateLamp;

	public Trigger[] islandTriggers;

	public float[] rotations;

	private int currentInside = -1;

	public void OnUpdateLR()
	{
		for (int i = 0; i < islandTriggers.Length; i++)
		{
			if (islandTriggers[i].IsInsideBool && i != currentInside)
			{
				rotateLamp.Animate(rotations[i], 0.1f);
				currentInside = i;
			}
			else if (!islandTriggers[i].IsInsideBool && i == currentInside)
			{
				currentInside = -1;
			}
		}
	}
}
public class HAGIS_ClifftopsB_HideLornaOnFrustumAway : HAGIS
{
	public FrustumDetector3D frustum;

	public GameObject Lorna;

	public GameObject Finlay;

	public VO_Asset voAsset;

	public HagletTrigger CutsceneFinished = new HagletTrigger();

	public float minDistance;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		if (!Routine.Skipping)
		{
			yield return CutsceneFinished;
		}
		VO_Asset.VO_Section[] voiceSections = voAsset.voiceSections;
		foreach (VO_Asset.VO_Section vO_Section in voiceSections)
		{
			for (int j = 0; j < vO_Section.voiceLines.Length; j++)
			{
				VOC.Inst.QueueVO(vO_Section.voiceLines[j].line, VOC.VOQueueProperty.Queue, vO_Section.voiceLines[j].delay, base.transform);
			}
		}
		yield return Wait.Until.True(() => frustum.IsNotInViewBool && Vector3.Distance(CC.Inst.transform.position, frustum.transform.position) > minDistance);
		VOC.Inst.VOStop(interruption: true);
		Lorna.SetActive(value: false);
		Finlay.SetActive(value: false);
	}
}
public class HAGIS_ClifftopsB_MainFlow : HAGIS
{
	[Tooltip("Puzzles in order matching the obelisk")]
	public PuzzleInfo[] puzzleInfos;

	public FMODEventAsset music;

	[Space]
	[Header("Clifftop")]
	[Tooltip("Portals 1-4 and exit portal in that order")]
	public HAGIS_Simple_Cutscene exitCutscene;

	[Space]
	[Header("Island 1")]
	public Doorway firstDoorway;

	public Portal firstPortal;

	public LightSource island1Lamp;

	public GameObject telepointP1;

	[Space]
	[Header("Island 2")]
	public LightSource[] island2Lamps;

	public Region doorEntryI2;

	public Region occlusionRegion;

	public GameObject telepointP2;

	public Occludee occlusionWall;

	public Doorway doorToOpenI2;

	[Space]
	[Header("Island 3")]
	public GameObject telepointP3;

	public Animation hatchI3;

	[Space]
	[Header("Island 4")]
	public LightSource island4Lamp;

	public Animation hatchI4;

	public GameObject telepointP4;

	[Space]
	[Header("Final Door")]
	public Animation finalDoorOpen;

	public Portal vaultPortal;

	public Region exitRegion;

	public HAGIS_ClifftopsB_HideLornaOnFrustumAway hideLornaHagis;

	private float[] doorRotStartValue = new float[4];

	private bool[] doorIsOpen = new bool[4];

	private bool occDoorOpen;

	private bool basketDown;

	private bool check1;

	private bool check2;

	private IHaglet p3Routine;

	private IHaglet p4Routine;

	private IHaglet p5Routine;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		LR.Inst.SetMusic(music);
		firstPortal.enabled = false;
		vaultPortal.enabled = false;
		exitCutscene.gameObject.SetActive(value: false);
		exitRegion.Disable();
		yield return WaitForPuzzle(puzzleInfos[0]);
		telepointP1.SetActive(value: false);
		island1Lamp.DisableLight();
		firstPortal.enabled = true;
		firstDoorway.Open();
		Haglet.Create(out p3Routine, P3Routine);
		Haglet.Create(out p4Routine, P4Routine);
		Haglet.Create(out p5Routine, P5Routine);
		p3Routine.Start();
		p4Routine.Start();
		p5Routine.Start();
		yield return WaitForPuzzles(puzzleInfos);
		exitCutscene.gameObject.SetActive(value: true);
		LR.Inst.StopMusic();
		yield return exitCutscene.IsComplete;
		hideLornaHagis.CutsceneFinished.Trigger();
		finalDoorOpen.Play();
		yield return Wait.For.Seconds(3.5f);
		vaultPortal.enabled = true;
		exitRegion.Enable();
		yield return Wait.For.LRUpdates(1);
	}

	private IEnumerator<Routine.Yield> P3Routine()
	{
		doorEntryI2.Disable();
		while (!puzzleInfos[1].IsComplete(SaveDataGame.PuzzleSaveType.Scene))
		{
			if (occlusionWall.GetStateIndex() == 1 && !occlusionRegion.IsEnabled)
			{
				occlusionRegion.Enable();
			}
			else if (occlusionWall.GetStateIndex() == 0 && occlusionRegion.IsEnabled)
			{
				occlusionRegion.Disable();
			}
			yield return Wait.For.LRUpdates(1);
		}
		yield return WaitForPuzzle(puzzleInfos[1]);
		doorToOpenI2.Open();
		telepointP2.SetActive(value: false);
		doorEntryI2.Enable();
		for (int i = 0; i < island2Lamps.Length; i++)
		{
			island2Lamps[i].DisableLight();
		}
	}

	private IEnumerator<Routine.Yield> P4Routine()
	{
		yield return WaitForPuzzle(puzzleInfos[2]);
		hatchI3.Play("AN_ClifftopsB_PuzzleHatch");
		telepointP3.SetActive(value: false);
	}

	private IEnumerator<Routine.Yield> P5Routine()
	{
		yield return WaitForPuzzle(puzzleInfos[3]);
		hatchI4.Play("AN_ClifftopsB_PuzzleHatch");
		telepointP4.SetActive(value: false);
		island4Lamp.DisableLight();
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_ClifftopsB_VOTriggerController : HAGIS
{
	public PuzzleInfo[] puzzleInfos;

	public PlayerAreaTrigger[] triggers;

	private bool scriptComplete;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		for (int i = 0; i < triggers.Length; i++)
		{
			triggers[i].enabled = false;
		}
		while (!scriptComplete)
		{
			int num = 0;
			for (int j = 0; j < puzzleInfos.Length; j++)
			{
				if (puzzleInfos[j].IsComplete(SaveDataGame.PuzzleSaveType.Progression) && !triggers[j].enabled)
				{
					triggers[j].enabled = true;
					num++;
				}
			}
			if (num >= triggers.Length)
			{
				scriptComplete = true;
			}
			yield return Wait.For.Updates(1);
		}
	}
}
public class HAGIS_ClifftopsC_EntrancePortalClose : HAGIS
{
	public Portal portal;

	public Region portalRegion;

	public FrustumDetector3D frustumDetector;

	public PlayerAreaTrigger trigger;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return Wait.For.LRUpdates(5);
		Wait none = Wait.None;
		none &= trigger.OnHeadInsidePremet;
		none &= frustumDetector.IsNotInView;
		yield return none;
		portal.gameObject.SetActive(value: false);
		portalRegion.Disable();
		NexusFullScreenPass.Inst.ForceUpdateLastValidPosition();
	}
}
public class HAGIS_ClifftopsC_ExitPortalOpen : HAGIS
{
	public IDObjectRef regionRef;

	public IDObjectRef portalRef;

	public PuzzleInfo puzzle;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		IDObject exitRegion = LR.Inst.GetIDObject<IDObject>(regionRef);
		Portal portal = LR.Inst.GetIDObjectComponent<Portal>(portalRef);
		exitRegion.gameObject.SetActive(value: false);
		portal.SetUnlockedState(unlocked: false);
		yield return Wait.For.Seconds(0f);
		yield return WaitForPuzzle(puzzle);
		exitRegion.gameObject.SetActive(value: true);
		portal.SetUnlockedState(unlocked: true);
	}
}
public class HAGIS_ClifftopsC_MainFlow : HAGIS
{
	[Header("Puzzle Refs")]
	public PuzzleInfo puzzle1;

	public PuzzleInfo puzzle2;

	public PuzzleInfo puzzle3;

	public PuzzleInfo puzzle4;

	public PuzzleInfo puzzle5;

	public PuzzleInfo puzzle6;

	public PuzzleInfo puzzle7;

	public PuzzleInfo puzzle8;

	[Header("Regions")]
	public IDObjectRef secondAreaRef;

	public IDObjectRef thirdAreaRef;

	public IDObjectRef fourthAreaRef;

	public IDObjectRef endPortalRegionRef;

	[Header("obelisk")]
	public IDObjectRef obeliskRef;

	[Header("Door Animations")]
	public IDObjectRef Door1AnimRef;

	public IDObjectRef Door2AnimRef;

	public IDObjectRef Door3AnimRef;

	public IDObjectRef musicBoxRef;

	public HAGIS_Simple_Cutscene lornaCutscene;

	[Header("Puzzle Light Sources")]
	public LightSource p1LightSource;

	public LightSource p2LightSource;

	public LightSource p3LightSource;

	public LightSource p4LightSource;

	public LightSource p8LightSource;

	[Header("Telepoints")]
	public GameObject p1Telepoint;

	public GameObject p2Telepoint;

	public GameObject p3Telepoint;

	public GameObject p4Telepoint;

	public GameObject p5Telepoint;

	public GameObject p6Telepoint;

	public GameObject p7Telepoint;

	public GameObject p8Telepoint;

	[Header("Animation Timings")]
	public float p1DoorTimer;

	public float p3DoorTimer;

	public float p7DoorTimer;

	public float animBuffer;

	[Header("Cutscene Timings")]
	public float cutsceneDoorClose;

	public float musicBoxSpawnTime;

	[Header("Music")]
	public FMODEventAsset entryMusic;

	public FMODEventAsset firstPuzzleMusic;

	public FMODEventAsset backGroundMusic1;

	public FMODEventAsset backGroundMusic2;

	public FMODEventAsset cliffMusic;

	[Header("VO & Sounds")]
	public IDObjectRef cliffTriggerRef;

	public Transform belltowerTransform;

	public FMODEventAsset belltowerSound;

	protected override void OnHagisAwake()
	{
		p1LightSource.DisableLight();
		p2LightSource.DisableLight();
		p3LightSource.DisableLight();
		p4LightSource.DisableLight();
		p8LightSource.DisableLight();
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		Animation door1Anim = LR.Inst.GetIDObjectComponent<Animation>(Door1AnimRef);
		Animation door2Anim = LR.Inst.GetIDObjectComponent<Animation>(Door2AnimRef);
		Animation door3Anim = LR.Inst.GetIDObjectComponent<Animation>(Door3AnimRef);
		Region secondRegion = LR.Inst.GetIDObjectComponent<Region>(secondAreaRef);
		Region thirdRegion = LR.Inst.GetIDObjectComponent<Region>(thirdAreaRef);
		Region fourthRegion = LR.Inst.GetIDObjectComponent<Region>(fourthAreaRef);
		Region endPortalRegion = LR.Inst.GetIDObjectComponent<Region>(endPortalRegionRef);
		GrabObject musicBox = LR.Inst.GetIDObjectComponent<GrabObject>(musicBoxRef);
		Trigger cliffTrigger = LR.Inst.GetIDObjectComponent<Trigger>(cliffTriggerRef);
		secondRegion.Disable();
		thirdRegion.Disable();
		fourthRegion.Disable();
		endPortalRegion.Disable();
		musicBox.gameObject.SetActive(value: false);
		p2Telepoint.SetActive(value: false);
		p3Telepoint.SetActive(value: false);
		p4Telepoint.SetActive(value: false);
		p5Telepoint.SetActive(value: false);
		p6Telepoint.SetActive(value: false);
		p7Telepoint.SetActive(value: false);
		p8Telepoint.SetActive(value: false);
		MusicBoxController musicBoxController = musicBox.GetComponentInChildren<MusicBoxController>(includeInactive: true);
		musicBoxController.Pause(paused: true);
		lornaCutscene.gameObject.SetActive(value: false);
		LR.Inst.PlayMusicOneShot(entryMusic);
		yield return Wait.For.Seconds(1f);
		p1LightSource.EnableLight();
		yield return CHECKPOINT();
		yield return WaitForPuzzle(puzzle1);
		LR.Inst.PlayMusicOneShot(firstPuzzleMusic);
		yield return Wait.For.Seconds(p1DoorTimer);
		p1LightSource.DisableLight();
		p2LightSource.DisableLight();
		p1Telepoint.SetActive(value: false);
		p2Telepoint.SetActive(value: true);
		HAGIS.PlayAnim(door1Anim);
		PSC.Inst.PlayAt(ParticleType.Door_Dust, door1Anim.transform.position).transform.rotation = door1Anim.transform.rotation;
		p2LightSource.EnableLight();
		yield return Wait.For.Seconds(animBuffer);
		secondRegion.Enable();
		PlayBelltower();
		yield return CHECKPOINT();
		yield return WaitForPuzzle(puzzle2);
		p2LightSource.DisableLight();
		p2Telepoint.SetActive(value: false);
		p3Telepoint.SetActive(value: true);
		LR.Inst.SetMusic(backGroundMusic1);
		yield return Wait.For.Seconds(animBuffer);
		p3LightSource.EnableLight();
		yield return CHECKPOINT();
		yield return WaitForPuzzle(puzzle3);
		p3Telepoint.SetActive(value: false);
		p3LightSource.DisableLight();
		p4LightSource.DisableLight();
		lornaCutscene.gameObject.SetActive(value: true);
		yield return lornaCutscene.IsTriggered;
		yield return Wait.For.Seconds(p3DoorTimer);
		musicBoxController.Pause(paused: false);
		HAGIS.PlayAnim(door2Anim);
		PSC.Inst.PlayAt(ParticleType.Door_Dust, door2Anim.transform.position).transform.rotation = door2Anim.transform.rotation;
		yield return lornaCutscene.IsComplete;
		lornaCutscene.gameObject.SetActive(value: false);
		musicBox.gameObject.SetActive(value: true);
		thirdRegion.Enable();
		p4LightSource.EnableLight();
		p4Telepoint.SetActive(value: true);
		yield return CHECKPOINT();
		yield return musicBox.OnObjectGrabbed;
		LR.Inst.StopMusic();
		yield return CHECKPOINT();
		yield return WaitForPuzzle(puzzle4);
		p4Telepoint.SetActive(value: false);
		p5Telepoint.SetActive(value: true);
		yield return CHECKPOINT();
		yield return WaitForPuzzle(puzzle5);
		p5Telepoint.SetActive(value: false);
		p6Telepoint.SetActive(value: true);
		yield return CHECKPOINT();
		yield return WaitForPuzzle(puzzle6);
		p6Telepoint.SetActive(value: false);
		p7Telepoint.SetActive(value: true);
		yield return CHECKPOINT();
		yield return WaitForPuzzle(puzzle7);
		yield return Wait.For.Seconds(p7DoorTimer);
		p7Telepoint.SetActive(value: false);
		p8Telepoint.SetActive(value: true);
		HAGIS.PlayAnim(door3Anim);
		PSC.Inst.PlayAt(ParticleType.Door_Dust, door3Anim.transform.position).transform.rotation = door3Anim.transform.rotation;
		yield return Wait.For.Seconds(animBuffer);
		fourthRegion.Enable();
		p4LightSource.DisableLight();
		LR.Inst.SetMusic(backGroundMusic2);
		p8LightSource.EnableLight();
		yield return CHECKPOINT();
		yield return WaitForPuzzle(puzzle8);
		p8LightSource.DisableLight();
		p8Telepoint.SetActive(value: false);
		endPortalRegion.Enable();
		LR.Inst.StopMusic();
		yield return cliffTrigger.OnInsidePremet;
		LR.Inst.PlayMusicOneShot(cliffMusic);
		PlayBelltower();
	}

	private void PlayBelltower()
	{
		if (belltowerSound != null && belltowerTransform != null)
		{
			FAC.Inst.PlayOneShot(belltowerSound, belltowerTransform);
		}
	}
}
public class HAGIS_ClifftopsC_RotateLampOnPuzzle : HAGIS
{
	public AnimRotateToTarget target;

	public PuzzleInfo[] puzzleInfosToComplete;

	public float[] rotateToOnComplete;

	public FMODEventAsset rotateSound;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		if (!target)
		{
			target = GetComponent<AnimRotateToTarget>();
		}
		target.Animate(Quaternion.Euler(0f, 0f, 0f), 1f, localRotation: true);
		for (int i = 0; i < puzzleInfosToComplete.Length; i++)
		{
			yield return WaitForPuzzle(puzzleInfosToComplete[i]);
			yield return Wait.For.Seconds(3f);
			FMOD.Studio.EventInstance sound = FAC.Inst.PlayOneShot(rotateSound, target.transform.position);
			yield return target.AnimateOnYield(Quaternion.Euler(0f, 0f, rotateToOnComplete[i]), 2f, localRotation: true);
			sound.stop(STOP_MODE.ALLOWFADEOUT);
		}
	}
}
public class CubeMapController : MonoBehaviour, Region.IEvents
{
	public bool isEntranceArea;

	public Transform locationIndicator;

	public Vector3 rotationForLocationIndicator;

	public void OnEnterRegion()
	{
		if (isEntranceArea)
		{
			locationIndicator.gameObject.SetActive(value: false);
			return;
		}
		if (!locationIndicator.gameObject.activeSelf)
		{
			locationIndicator.gameObject.SetActive(value: true);
		}
		locationIndicator.transform.localRotation = Quaternion.Euler(rotationForLocationIndicator);
	}

	public void OnExitRegion()
	{
	}
}
public class HAGIS_Construct_ClosePortalOnLeaveTrigger : HAGIS
{
	public PlayerAreaTrigger areaTrigger;

	public Portal closePortal;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return areaTrigger.OnHeadOutside;
		closePortal.SetUnlockedState(unlocked: false);
		yield return Wait.For.Seconds(0.5f);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_Construct_D_Flow : HAGIS
{
	public PuzzleInfo puzzle1;

	public IDObjectRef exitPortalRef;

	public GameObject telepoint;

	public VO_Asset ghostLornaVoiceover;

	public GameObject ghostLorna;

	public FMODEventAsset music;

	public FMODEventAsset ghostLornaMusic;

	public ConstructGhostSoundController ghostSound;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		LR.Inst.SetMusic(music);
		if ((bool)ghostSound)
		{
			ghostSound.Initialise();
		}
		Portal exitPortal = LR.Inst.GetIDObjectComponent<Portal>(exitPortalRef);
		exitPortal.SetUnlockedState(unlocked: false);
		yield return WaitForPuzzle(puzzle1);
		exitPortal.SetUnlockedState(unlocked: true);
		telepoint.SetActive(value: false);
		yield return Wait.For.Seconds(2f);
		ghostLorna.SetActive(value: true);
		if ((bool)ghostSound)
		{
			ghostSound.PlayGhostSound();
		}
		LR.Inst.SetMusic(ghostLornaMusic);
		VO_Asset.VO_Section[] voiceSections = ghostLornaVoiceover.voiceSections;
		foreach (VO_Asset.VO_Section vO_Section in voiceSections)
		{
			for (int j = 0; j < vO_Section.voiceLines.Length; j++)
			{
				VOC.Inst.QueueVO(vO_Section.voiceLines[j].line, VOC.VOQueueProperty.Queue, vO_Section.voiceLines[j].delay, ghostLorna.transform);
			}
		}
		yield return VOC.Inst.IsFree;
		yield return Wait.For.Seconds(1f);
		if ((bool)ghostSound)
		{
			ghostSound.StopGhostSound();
		}
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_Construct_End_Flow : HAGIS
{
	public HAGIS_Cutscene_Base cutscene;

	public IDObjectRef finalHubSpawnPoint;

	public IDObjectRef portalRef;

	public IDObjectRef lornaRef;

	public float whiteFadeDelay = 5f;

	public float whiteFadeInTime = 2f;

	public float whiteDelay = 1f;

	public float whitefadeOutTime = 1f;

	public Color whiteFadeOutColor = Color.white;

	public AnimationCurve fadeInCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public AnimationCurve fadeOutCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		Portal portal = portalRef.GetOrNull<Portal>();
		GameObject lorna = lornaRef.GetOrNull<IDObject>().gameObject;
		portal.SetUnlockedState(unlocked: false);
		yield return Wait.For.Seconds(1f);
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		yield return Routine.Yield.SpecialIndex.StopSkipping;
		UnityEngine.Debug.Log("Levels loaded");
		PlayerEntryPoint spawnPoint = null;
		while (spawnPoint == null)
		{
			spawnPoint = LR.Inst.GetIDObjectComponent<PlayerEntryPoint>(finalHubSpawnPoint, this);
			yield return Wait.For.LRUpdates(1);
		}
		yield return cutscene.IsTriggered;
		yield return Wait.For.Seconds(whiteFadeDelay);
		CC.Inst.PositionReplace(spawnPoint, default(CC.TeleportInfo), fadeInTime: whiteFadeInTime, fadeDelayTime: whiteDelay, fadeOutTime: whitefadeOutTime, fadeCamera: true, forceUpdateLastState: true, MovementType: false, movementType: CC.MovementType.None, fadeColor: whiteFadeOutColor, fadeInCurve: fadeInCurve, fadeOutCurve: fadeOutCurve);
		portal.gameObject.SetActive(value: false);
		portal.Link.gameObject.SetActive(value: false);
		lorna.SetActive(value: false);
		yield return LR.Inst.Save();
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_Construct_P2_Drawbridge : HAGIS
{
	public Doorway drawbridge;

	public Animation catchAnimation;

	public string animationName;

	[Range(0f, 1f)]
	public float normalizedTriggerTime;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		while (catchAnimation[animationName].normalizedTime < normalizedTriggerTime)
		{
			yield return Wait.For.LRUpdates(1);
		}
		drawbridge.Open();
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_Construct_P2_DrawBridge_Region : HAGIS
{
	public InteractableTarget_Animation drawBridge;

	public Region region;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		while (true)
		{
			if (region.IsEnabled && drawBridge.normalisedPostion < 0.95f)
			{
				region.Disable();
			}
			else if (!region.IsEnabled && drawBridge.normalisedPostion >= 0.95f)
			{
				region.Enable();
			}
			yield return Wait.For.Updates(1);
		}
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_Construct_P2_Flow : HAGIS
{
	public IDObjectRef entranceTriggerRef;

	public IDObjectRef entrancePortalRef;

	public IDObjectRef exitPortalRef;

	public PuzzleInfo puzzle1;

	public Doorway doorway;

	public GameObject telepoint;

	public VO_Asset ghostLornaVoiceover;

	public GameObject ghostLorna;

	public FMODEventAsset music;

	public FMODEventAsset ghostLornaMusic;

	public ConstructGhostSoundController ghostSound;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		Portal exitPortal = LR.Inst.GetIDObjectComponent<Portal>(exitPortalRef);
		Portal entrancePortal = LR.Inst.GetIDObjectComponent<Portal>(entrancePortalRef);
		Trigger trigger = entranceTriggerRef.Get<Trigger>();
		entrancePortal.SetUnlockedState(unlocked: false);
		ghostSound.Initialise();
		LR.Inst.SetMusic(music);
		yield return trigger.OnInside;
		entrancePortal.SetUnlockedState(unlocked: false);
		entrancePortal.SetHidden(hidden: true);
		yield return WaitForPuzzle(puzzle1);
		exitPortal.gameObject.SetActive(value: true);
		telepoint.SetActive(value: false);
		doorway.Open();
		yield return Wait.For.Seconds(1.5f);
		yield return Wait.For.Seconds(2f);
		ghostLorna.SetActive(value: true);
		ghostSound.PlayGhostSound();
		LR.Inst.SetMusic(ghostLornaMusic);
		VO_Asset.VO_Section[] voiceSections = ghostLornaVoiceover.voiceSections;
		foreach (VO_Asset.VO_Section vO_Section in voiceSections)
		{
			for (int j = 0; j < vO_Section.voiceLines.Length; j++)
			{
				VOC.Inst.QueueVO(vO_Section.voiceLines[j].line, VOC.VOQueueProperty.Queue, vO_Section.voiceLines[j].delay, ghostLorna.transform);
			}
		}
		yield return VOC.Inst.IsFree;
		yield return Wait.For.Seconds(1f);
		ghostSound.StopGhostSound();
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_Construct_P3_Flow : HAGIS
{
	public IDObjectRef entranceTriggerRef;

	public IDObjectRef entrancePortalRef;

	public IDObjectRef exitPortalRef;

	public PuzzleInfo puzzle1;

	public LightSource lightSource1;

	public GameObject telepoint1;

	public VO_Asset ghostLornaVoiceover;

	public GameObject ghostLorna;

	public FMODEventAsset music;

	public FMODEventAsset ghostLornaMusic;

	public ConstructGhostSoundController ghostSound;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		Portal exitPortal = LR.Inst.GetIDObjectComponent<Portal>(exitPortalRef);
		LR.Inst.GetIDObjectComponent<Portal>(entrancePortalRef);
		entranceTriggerRef.Get<Trigger>();
		exitPortal.gameObject.SetActive(value: false);
		LR.Inst.SetMusic(music);
		ghostSound.Initialise();
		yield return WaitForPuzzle(puzzle1);
		telepoint1.SetActive(value: false);
		exitPortal.gameObject.SetActive(value: true);
		lightSource1.DisableLight();
		yield return Wait.For.Seconds(2f);
		ghostLorna.SetActive(value: true);
		ghostSound.PlayGhostSound();
		LR.Inst.SetMusic(ghostLornaMusic);
		VO_Asset.VO_Section[] voiceSections = ghostLornaVoiceover.voiceSections;
		foreach (VO_Asset.VO_Section vO_Section in voiceSections)
		{
			for (int j = 0; j < vO_Section.voiceLines.Length; j++)
			{
				VOC.Inst.QueueVO(vO_Section.voiceLines[j].line, VOC.VOQueueProperty.Queue, vO_Section.voiceLines[j].delay, ghostLorna.transform);
			}
		}
		yield return VOC.Inst.IsFree;
		yield return Wait.For.Seconds(1f);
		ghostSound.StopGhostSound();
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_Construct_P4_Flow : HAGIS
{
	public PuzzleInfo[] puzzles;

	public VO_Asset ghostLornaVoiceover;

	public GameObject ghostLorna;

	public FMODEventAsset music;

	public FMODEventAsset ghostLornaMusic;

	public ConstructGhostSoundController ghostSound;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		ghostSound.Initialise();
		LR.Inst.SetMusic(music);
		yield return WaitForPuzzles(puzzles);
		yield return Wait.For.Seconds(2f);
		ghostLorna.SetActive(value: true);
		ghostSound.PlayGhostSound();
		LR.Inst.SetMusic(ghostLornaMusic);
		VO_Asset.VO_Section[] voiceSections = ghostLornaVoiceover.voiceSections;
		foreach (VO_Asset.VO_Section vO_Section in voiceSections)
		{
			for (int j = 0; j < vO_Section.voiceLines.Length; j++)
			{
				VOC.Inst.QueueVO(vO_Section.voiceLines[j].line, VOC.VOQueueProperty.Queue, vO_Section.voiceLines[j].delay, ghostLorna.transform);
			}
		}
		yield return VOC.Inst.IsFree;
		yield return Wait.For.Seconds(1f);
		ghostSound.StopGhostSound();
	}
}
public class HAGIS_Construct_P4_Puzzle_Flow : HAGIS
{
	public PuzzleInfo puzzleInfo;

	public LightSource lightSrc;

	public GameObject telepoint;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return Wait.For.Seconds(1f);
		yield return WaitForPuzzle(puzzleInfo);
		lightSrc.DisableLight();
		telepoint.SetActive(value: false);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_Construct_P5_Flow : HAGIS, IAreaEvent
{
	public IDObjectRef entrancePortalRef;

	public IDObjectRef exitPortalRef;

	public Portal exitPortal;

	public PuzzleInfo puzzle;

	public LightSource lightSource;

	public Telepoint telepoint;

	public RasterizerGroup puzzleGroup;

	public VO_Asset ghostLornaVoiceover;

	public GameObject ghostLorna;

	public InteractableTarget_Animation shadowPieceMover;

	public Animation EndingAnimation;

	public Animation EndingRenderAnimation;

	public ParticleSystem EndingParticles;

	public Animation EndingEffect;

	[Header("Timers after effect starts:")]
	public float PortalOpenTime = 17f;

	public float EndingShakeStopTime = 15f;

	[Space]
	public PlacementHelper[] RasterizerPieceHelpers;

	public FMODEventAsset music;

	public FMODEventAsset ghostLornaMusic;

	public FMODEventAsset rasterizerSolveFinal;

	public ConstructGhostSoundController ghostSound;

	public FixedRotatableObject lightWheel;

	public GameObject lightRotator;

	public RotatableObject[] wheels;

	public GameObject greyWheelsParent;

	private void OnValidate()
	{
		PortalOpenTime = Mathf.Max(PortalOpenTime, 0f);
		EndingShakeStopTime = Mathf.Max(EndingShakeStopTime, 0f);
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		Portal iDObjectComponent = LR.Inst.GetIDObjectComponent<Portal>(entrancePortalRef);
		iDObjectComponent.SetUnlockedState(unlocked: false);
		iDObjectComponent.SetHidden(hidden: true);
		telepoint.Hide();
		exitPortal.SetUnlockedState(unlocked: false);
		ghostSound.Initialise();
		greyWheelsParent.SetActive(value: false);
		yield return Wait.For.LRUpdates(1);
		yield return VOC.Inst.IsFree;
		ghostLorna.SetActive(value: true);
		ghostSound.PlayGhostSound();
		LR.Inst.SetMusic(ghostLornaMusic);
		VO_Asset.VO_Section[] voiceSections = ghostLornaVoiceover.voiceSections;
		foreach (VO_Asset.VO_Section vO_Section in voiceSections)
		{
			for (int j = 0; j < vO_Section.voiceLines.Length; j++)
			{
				VOC.Inst.QueueVO(vO_Section.voiceLines[j].line, VOC.VOQueueProperty.Queue, vO_Section.voiceLines[j].delay, ghostLorna.transform);
			}
		}
		yield return VOC.Inst.IsFree;
		yield return Wait.For.Seconds(1f);
		exitPortal.gameObject.SetActive(value: true);
		bool anyPiecePlaced = false;
		while (!anyPiecePlaced && !puzzle.IsComplete(SaveDataGame.PuzzleSaveType.Scene))
		{
			for (int k = 0; k < RasterizerPieceHelpers.Length; k++)
			{
				anyPiecePlaced |= (bool)RasterizerPieceHelpers[k].HeldGrabObject;
			}
			yield return Wait.For.Updates(1);
			if (Routine.Skipping)
			{
				break;
			}
		}
		UnityEngine.Debug.Log("play music");
		LR.Inst.SetMusic(music);
		bool allPiecesPlaced = false;
		while (!allPiecesPlaced && !puzzle.IsComplete(SaveDataGame.PuzzleSaveType.Scene))
		{
			allPiecesPlaced = true;
			for (int l = 0; l < RasterizerPieceHelpers.Length; l++)
			{
				allPiecesPlaced &= (bool)RasterizerPieceHelpers[l].HeldGrabObject;
			}
			yield return Wait.For.Updates(1);
			if (Routine.Skipping)
			{
				break;
			}
		}
		telepoint.Show();
		LR.Inst.SetMusicParameter("prog_slow", 0.5f);
		UnityEngine.Debug.Log("prog_slow 0.5");
		UnityEngine.Debug.Log("waiting for puzzle completion");
		yield return WaitForPuzzle(puzzle);
		LR.Inst.SetMusicParameter("progress", 0.2f);
		UnityEngine.Debug.Log("progress 0.2");
		FAC.Inst.PlayOneShot(rasterizerSolveFinal, puzzleGroup.transform.position);
		telepoint.Hide();
		lightWheel.enabled = false;
		lightRotator.SetActive(value: false);
		RotatableObject[] array = wheels;
		foreach (RotatableObject obj in array)
		{
			obj.enabled = false;
			obj.transform.GetChild(0).gameObject.SetActive(value: false);
		}
		greyWheelsParent.SetActive(value: true);
		yield return VOC.Inst.IsFree;
		yield return CHECKPOINT();
		shadowPieceMover.Disabled = true;
		EndingAnimation.Play();
		EndingRenderAnimation.Play();
		HAGIS.PlayAnim(EndingEffect);
		if (PortalOpenTime > EndingShakeStopTime)
		{
			float difference = PortalOpenTime - EndingShakeStopTime;
			yield return Wait.For.Seconds(EndingShakeStopTime);
			EndingAnimation.Stop();
			yield return Wait.For.Seconds(difference);
			exitPortal.SetUnlockedState(unlocked: true);
		}
		else
		{
			float difference = EndingShakeStopTime - PortalOpenTime;
			yield return Wait.For.Seconds(PortalOpenTime);
			exitPortal.SetUnlockedState(unlocked: true);
			yield return Wait.For.Seconds(difference);
			EndingAnimation.Stop();
		}
		lightSource.DisableLight();
		greyWheelsParent.SetActive(value: false);
		array = wheels;
		foreach (RotatableObject obj2 in array)
		{
			obj2.enabled = true;
			obj2.transform.GetChild(0).gameObject.SetActive(value: true);
		}
		yield return Wait.For.Seconds(1f);
		ghostSound.StopGhostSound();
	}

	void IAreaEvent.OnAreaExit()
	{
		LR.Inst.StopMusic();
	}

	protected override bool SetDebugVisibilty()
	{
		return true;
	}
}
public class HAGIS_ConstructP4_OpenExitPortal : HAGIS
{
	public IDObjectRef portalRef;

	public PuzzleInfo[] allPuzzles;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		Portal portal = LR.Inst.GetIDObject<Portal>(portalRef);
		portal.SetUnlockedState(unlocked: false);
		yield return WaitForPuzzles(allPuzzles);
		yield return Wait.For.Seconds(2.5f);
		yield return VOC.Inst.IsFree;
		portal.SetUnlockedState(unlocked: true);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_SuperSecret_P4Portals : HAGIS
{
	public IDObjectRef entrancePortalRef;

	public IDObjectRef exitPortalARef;

	public IDObjectRef exitPortalBRef;

	public IDObjectRef exitPortalCRef;

	public IDObjectRef entranceRegionRef;

	public IDObjectRef lightSensorARef;

	public IDObjectRef lightSensorBRef;

	public IDObjectRef lightSensorCRef;

	private LightSensor sensor1;

	private LightSensor sensor2;

	private LightSensor sensor3;

	private Portal entrancePortal;

	private Region entranceRegion;

	private LightSensor activeSensor;

	private Dictionary<LightSensor, IDObjectRef> portalLinkDic = new Dictionary<LightSensor, IDObjectRef>();

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		entranceRegion = LR.Inst.GetIDObjectComponent<Region>(entranceRegionRef);
		sensor1 = LR.Inst.GetIDObjectComponent<LightSensor>(lightSensorARef);
		sensor2 = LR.Inst.GetIDObjectComponent<LightSensor>(lightSensorBRef);
		sensor3 = LR.Inst.GetIDObjectComponent<LightSensor>(lightSensorCRef);
		entrancePortal = LR.Inst.GetIDObjectComponent<Portal>(entrancePortalRef);
		portalLinkDic[sensor1] = exitPortalARef;
		portalLinkDic[sensor2] = exitPortalBRef;
		portalLinkDic[sensor3] = exitPortalCRef;
		yield return Wait.For.LRUpdates(1);
		bool first = true;
		while (true)
		{
			LightSensor lightSensor = GetActiveSensor();
			if (activeSensor != lightSensor || first)
			{
				if ((bool)lightSensor)
				{
					if (!entrancePortal.IsUnlocked)
					{
						entrancePortal.SetUnlockedState(unlocked: true);
						entranceRegion.Enable();
					}
					IDObjectRef linkRef = portalLinkDic[lightSensor];
					entrancePortal.SetLinkRef(linkRef);
				}
				else if (entrancePortal.IsUnlocked)
				{
					entrancePortal.SetUnlockedState(unlocked: false, applyToLink: false);
					entranceRegion.Disable();
				}
				first = false;
				activeSensor = lightSensor;
			}
			yield return Wait.For.LRUpdates(1);
		}
	}

	public LightSensor GetActiveSensor()
	{
		if (sensor1.isReceivingLight.value)
		{
			return sensor1;
		}
		if (sensor2.isReceivingLight.value)
		{
			return sensor2;
		}
		if (sensor3.isReceivingLight.value)
		{
			return sensor3;
		}
		return null;
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_Credits : HAGIS
{
	protected static HAGIS_Credits _instance;

	public FMODEventAsset fromEndingMusic;

	public FMODEventAsset fromMenuMusic;

	private UICredits credits;

	private SceneInfo returnScene;

	[SerializeField]
	private ChapterInfo constructChapterInfo;

	private HagletTrigger onCreditsInterrupted;

	public static HAGIS_Credits Inst => _instance;

	private void Awake()
	{
		_instance = this;
	}

	public override void OnLoadLR(MRBase owner)
	{
		base.OnLoadLR(owner);
	}

	protected override void OnHagisAwake()
	{
		base.OnHagisAwake();
		credits = GetComponentInChildren<UICredits>();
		credits.OnAwakeLR();
		credits.gameObject.SetActive(value: false);
		returnScene = Runtime.LoadAsset<SceneInfo>("Assets/_GameAssets/CustomAssets/SceneInfos/SC_TutorialSequence_LOGIC.asset");
		onCreditsInterrupted = new HagletTrigger();
		UIPauseMenu.Inst.currentMenuType = SceneInfo.MenuType.Credits;
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		bool finalHubWasLoaded = LR.Inst.IsSceneLoaded("sumy");
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		if (!LR.Inst.CurrentMusicEquals(fromEndingMusic))
		{
			LR.Inst.SetMusic(fromMenuMusic);
			if (!LR.Inst.saveDataGame.IsChapterMaskCompleteAll(SaveDataGame.Chapter.Construct))
			{
				LR.Inst.SetMusicParameter("progress", 0.1f);
			}
		}
		if (finalHubWasLoaded)
		{
			LR.Inst.saveDataGame.ResetChapter(constructChapterInfo);
			LR.Inst.Save();
		}
		IC.Inst.PauseMenuEnabled = true;
		PlayerFreeMove.FreeMoveEnabled.Reset();
		PlayerFreeMove.FreeMoveEnabled.Value = false;
		PlayerFreeMove.FreeTurnEnabled.Reset();
		PlayerFreeMove.FreeTurnEnabled.Value = false;
		PlayerTeleport.TeleportEnabled.Reset();
		PlayerTeleport.TeleportEnabled.Value = false;
		PlayerInventory.InventoryEnabled.Reset();
		PlayerInventory.InventoryEnabled.Value = false;
		CC.Inst.handL.gameObject.SetActive(value: false);
		CC.Inst.handR.gameObject.SetActive(value: false);
		CC.Inst.TrackingCircle.gameObject.SetActive(value: false);
		CC.Inst.TrackingDirection.gameObject.SetActive(value: false);
		credits.gameObject.SetActive(value: true);
		yield return credits.ShowCredits() | onCreditsInterrupted;
		if (!onCreditsInterrupted.happening)
		{
			LR.Inst.MainMenuMode = true;
			StopCredits();
			yield return LR.Inst.fadeAndSpawn.Start(0.5f, returnScene, owner);
		}
	}

	public void StopCredits()
	{
		onCreditsInterrupted.Trigger();
		credits.StopCredits();
		CC.Inst.handL.gameObject.SetActive(value: true);
		CC.Inst.handR.gameObject.SetActive(value: true);
		CC.Inst.TrackingCircle.gameObject.SetActive(value: true);
		CC.Inst.TrackingDirection.gameObject.SetActive(value: true);
		PlayerFreeMove.FreeMoveEnabled.Reset();
		PlayerFreeMove.FreeMoveEnabled.Value = true;
		PlayerFreeMove.FreeTurnEnabled.Reset();
		PlayerFreeMove.FreeTurnEnabled.Value = true;
		PlayerTeleport.TeleportEnabled.Reset();
		PlayerTeleport.TeleportEnabled.Value = true;
		PlayerInventory.InventoryEnabled.Reset();
		PlayerInventory.InventoryEnabled.Value = true;
		IC.Inst.PauseMenuEnabled = true;
	}
}
public class HAGIS_ConstructEnd_Cutscene : HAGIS_Cutscene_Base
{
	[SerializeField]
	[Space(10f)]
	public CutsceneAnimationSet[] cutsceneAnimSets;

	public FMODEventAsset cutsceneMusic;

	private CutsceneSection cutsceneSection;

	public IDObjectRef portalToHubRef;

	private Portal portalToHub;

	public PortalingAnimObject lorna;

	private IDObjectRef prevHubPortalLinkRef;

	public override void OnSetup()
	{
		cutsceneSection = new CutsceneSection
		{
			cutsceneAnimSets = cutsceneAnimSets,
			region = GetComponentInChildren<Region>(includeInactive: true),
			triggers = GetComponentsInChildren<Trigger>(includeInactive: true),
			telepoint = GetComponentInChildren<Telepoint>(includeInactive: true),
			cutsceneColliders = GetComponentsInChildren<CutsceneCollider>()
		};
		cutsceneSection.Setup(enabled: true, teleportTrigger);
		onCutsceneTriggerPremet = cutsceneSection.OnTriggerPremet;
		portalToHub = portalToHubRef.Get<Portal>();
		portalToHub.ClosePortal();
		cutsceneSection.PlayPreIdle();
	}

	public override IEnumerator<Routine.Yield> OnCutsceneLogic(bool teleported)
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		portalToHub.TeleportObject(lorna, allowDisallowedObjects: true, allowDisallowedPortal: true);
		portalToHub.gameObject.SetActive(value: true);
		portalToHub.SetUnlockedState(unlocked: true);
		portalToHub.OpenPortal();
		cutsceneSection.StopIdling();
		if ((bool)cutsceneMusic && !Routine.Skipping)
		{
			LR.Inst.StopMusic();
			LR.Inst.PlayMusicOneShot(cutsceneMusic);
		}
		PlayerTeleport.TeleportEnabled.Value = false;
		yield return playCutsceneSectionRoutine.Call(cutsceneSection, cutsceneBlend, teleported, arg3: true);
		PlayerTeleport.TeleportEnabled.Value = true;
		cutsceneSection.PlayPostIdle();
		yield return Routine.Yield.SpecialIndex.StopSkipping;
	}
}
[Serializable]
public class CutsceneAnimationSet
{
	public bool shouldIdleDisable = true;

	public bool playPreIdle;

	public IdleAnimationSet preIdle = new IdleAnimationSet();

	public IdleAnimationSet postIdle = new IdleAnimationSet();

	public IdleAnimationSet[] preIdles = new IdleAnimationSet[1];

	public bool playPostIdle;

	public IdleAnimationSet[] postIdles = new IdleAnimationSet[1];

	[FormerlySerializedAs("model")]
	public Animation modelAnim;

	[HideInInspector]
	public IdleAnimation idleAnim;

	public string[] animations;

	public bool preIdleExpanded;

	public bool postIdleExpanded;

	[NonSerialized]
	public System.Random random;

	public void Restore()
	{
		if ((preIdles == null || preIdles.Length == 0 || string.IsNullOrEmpty(preIdles[0].idle)) && !string.IsNullOrEmpty(preIdle.idle))
		{
			if (preIdles == null || preIdles.Length == 0)
			{
				preIdles = new IdleAnimationSet[1];
			}
			preIdles[0] = preIdle;
		}
		if ((postIdles == null || postIdles.Length == 0 || string.IsNullOrEmpty(postIdles[0].idle)) && !string.IsNullOrEmpty(postIdle.idle))
		{
			if (postIdles == null || postIdles.Length == 0)
			{
				postIdles = new IdleAnimationSet[1];
			}
			postIdles[0] = postIdle;
		}
	}
}
[Serializable]
public class CutsceneSection
{
	[NonSerialized]
	public int animCount;

	public Region region;

	public Telepoint telepoint;

	public Trigger[] triggers;

	public CutsceneAnimationSet[] cutsceneAnimSets;

	public CutsceneCollider[] cutsceneColliders;

	public bool shouldSyncIdleAlts;

	public Wait OnTriggerPremet
	{
		get
		{
			Wait none = Wait.None;
			Trigger[] array = triggers;
			foreach (Trigger trigger in array)
			{
				none &= trigger.OnInsidePremet;
			}
			return none;
		}
	}

	public bool InTrigger
	{
		get
		{
			bool flag = false;
			Trigger[] array = triggers;
			foreach (Trigger trigger in array)
			{
				flag |= trigger.IsInsideBool;
			}
			return flag;
		}
	}

	public void Setup(bool enabled, HagletTrigger teleportTrigger)
	{
		SetEnabled(enabled);
		telepoint.cutsceneTrigger = teleportTrigger;
		if (cutsceneColliders != null)
		{
			for (int i = 0; i < cutsceneColliders.Length; i++)
			{
				cutsceneColliders[i].telepoint = telepoint;
				cutsceneColliders[i].cutSceneTrigger = teleportTrigger;
			}
		}
		for (int j = 0; j < triggers.Length; j++)
		{
			triggers[j].isCutsceneTrigger = true;
		}
		int num = 0;
		for (int k = 0; k < cutsceneAnimSets.Length; k++)
		{
			CutsceneAnimationSet cutsceneAnimationSet = cutsceneAnimSets[k];
			cutsceneAnimationSet.idleAnim = cutsceneAnimationSet.modelAnim.GetComponent<IdleAnimation>();
			if (!cutsceneAnimationSet.idleAnim)
			{
				cutsceneAnimationSet.idleAnim = cutsceneAnimationSet.modelAnim.gameObject.AddComponent<IdleAnimation>();
				cutsceneAnimationSet.idleAnim.OnAwakeLR();
			}
			if (num == 0 || !shouldSyncIdleAlts)
			{
				num = UnityEngine.Random.Range(1, int.MaxValue);
			}
			cutsceneAnimationSet.random = new System.Random(num);
			if (cutsceneAnimationSet.shouldIdleDisable)
			{
				cutsceneAnimationSet.modelAnim.gameObject.SetActive(value: false);
			}
			animCount = Mathf.Max(animCount, cutsceneAnimationSet.animations.Length);
		}
	}

	public void SetEnabled(bool enabled)
	{
		for (int i = 0; i < triggers.Length; i++)
		{
			triggers[i].enabled = enabled;
		}
		if ((bool)telepoint)
		{
			if (enabled)
			{
				telepoint.Show();
			}
			else
			{
				telepoint.Hide();
			}
		}
	}

	public void PlayPreIdle()
	{
		for (int i = 0; i < cutsceneAnimSets.Length; i++)
		{
			if (cutsceneAnimSets[i].playPreIdle)
			{
				IdleAnimation idleAnim = cutsceneAnimSets[i].idleAnim;
				idleAnim.gameObject.SetActive(value: true);
				IdleAnimationSet preIdle = cutsceneAnimSets[i].preIdle;
				idleAnim.StartIdling(preIdle, cutsceneAnimSets[i].random);
			}
			else if (cutsceneAnimSets[i].shouldIdleDisable)
			{
				IdleAnimation idleAnim2 = cutsceneAnimSets[i].idleAnim;
				idleAnim2.gameObject.SetActive(value: false);
				idleAnim2.StopIdling();
			}
		}
	}

	public void PlayPostIdle()
	{
		for (int i = 0; i < cutsceneAnimSets.Length; i++)
		{
			if (cutsceneAnimSets[i].playPostIdle)
			{
				IdleAnimation idleAnim = cutsceneAnimSets[i].idleAnim;
				idleAnim.gameObject.SetActive(value: true);
				IdleAnimationSet postIdle = cutsceneAnimSets[i].postIdle;
				idleAnim.StartIdling(postIdle, cutsceneAnimSets[i].random);
			}
			else if (cutsceneAnimSets[i].shouldIdleDisable)
			{
				IdleAnimation idleAnim2 = cutsceneAnimSets[i].idleAnim;
				idleAnim2.gameObject.SetActive(value: false);
				idleAnim2.StopIdling();
			}
		}
	}

	public void StopIdling()
	{
		for (int i = 0; i < cutsceneAnimSets.Length; i++)
		{
			cutsceneAnimSets[i].idleAnim.StopIdling();
		}
	}
}
public abstract class HAGIS_Cutscene_Base : HAGIS, IPrepareEvent
{
	public bool startImmediately;

	public float cutsceneBlend;

	public float cutsceneDelay;

	public bool waitForFadeToStartCutscene;

	public bool waitForFadeToEnableAnims;

	public Event OnComplete = new Event();

	protected HagletValue<bool> triggered;

	protected HagletValue<bool> complete;

	protected Wait onCutsceneTriggerPremet = Wait.None;

	protected HagletTrigger teleportTrigger = new HagletTrigger();

	protected HagletValue<string> animationPlayed;

	protected Animation[] currentAnims = new Animation[2];

	protected string[] currentClipNames = new string[2];

	protected float[] currentAnimTimes = new float[2];

	public bool overrideOOBValues;

	[ConditionalHide("overrideOOBValues")]
	public float overrideOOBMaxFade = 0.95f;

	[ConditionalHide("overrideOOBValues")]
	public float overrideOOBStartDist = 0.8f;

	[ConditionalHide("overrideOOBValues")]
	public float overrideOOBMaxDist = 0.2f;

	[ConditionalHide("overrideOOBValues")]
	public float overrideOOBPauseAlpha = 0.9f;

	protected IHaglet<CutsceneSection, float, bool, bool> playCutsceneSectionRoutine;

	public IHaglet<bool> onCutsceneLogic;

	public Wait IsTriggered => Wait.Until.True(triggered, 1, allowPreMetNow: true);

	public Wait IsComplete => Wait.Until.True(complete, 1, allowPreMetNow: true);

	protected override void OnHagisAwake()
	{
		HagletValue.Create(out triggered, null, initVal: false, null, 8);
		HagletValue.Create(out complete, null, initVal: false, null, 8);
		HagletValue.Create(out animationPlayed, (string)null, (string)null, (HagletEvent.IOwner)null, 8);
		Haglet.Create(out onCutsceneLogic, (Routine.Func1<bool>)OnCutsceneLogic, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out playCutsceneSectionRoutine, (Routine.Func4<CutsceneSection, float, bool, bool>)PlayCutsceneSectionRoutine, (string)null, startNow: false, (int?)null, (string)null);
	}

	public virtual Wait PrepareEvents()
	{
		OnComplete.PrepareInvoke();
		return Wait.None;
	}

	public override void OnLoadLR(MRBase owner)
	{
		if (base.CheckpointCount != resumeCount)
		{
			onLogicBase.Start();
		}
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		if (!owner.isAwake || !owner.isLoadedRefs)
		{
			yield return Wait.For.LRUpdates(1);
		}
		OnSetup();
		if (!startImmediately)
		{
			yield return onCutsceneTriggerPremet | teleportTrigger;
		}
		bool arg = teleportTrigger.happening;
		LR.Inst.SetInCutscene(cutscene: true);
		triggered.value = true;
		yield return onCutsceneLogic.Call(arg, 1, reset: true, resuming);
		LR.Inst.SetInCutscene(cutscene: false);
		complete.value = true;
		OnComplete.Invoke();
		if (startImmediately)
		{
			PlayerTeleport.TeleportEnabled.Reset();
		}
		yield return CHECKPOINT();
		yield return Save();
	}

	private IEnumerator<Routine.Yield> PlayCutsceneSectionRoutine(CutsceneSection cutsceneSection, float blendTime, bool teleported, bool restrictMovement)
	{
		if (!waitForFadeToEnableAnims)
		{
			for (int i = 0; i < cutsceneSection.cutsceneAnimSets.Length; i++)
			{
				cutsceneSection.cutsceneAnimSets[i].modelAnim.gameObject.SetActive(value: true);
			}
		}
		for (int j = 0; j < cutsceneSection.cutsceneColliders.Length; j++)
		{
			cutsceneSection.cutsceneColliders[j].gameObject.SetActive(value: false);
		}
		if (restrictMovement)
		{
			PlayerTeleport.TeleportEnabled.Value = false;
			if (!startImmediately)
			{
				if (waitForFadeToStartCutscene)
				{
					yield return MoveToTelepoint(cutsceneSection, teleported);
				}
				else
				{
					yield return NexusFullScreenPass.Inst.StartFadeToBlack(BaseSettings<TeleportSettings>.Inst.cutsceneFadeDuration);
					MoveToTelepoint(cutsceneSection, teleported, instant: true);
					yield return Wait.For.LRRealtimeUpdates(1);
					if (waitForFadeToEnableAnims)
					{
						for (int k = 0; k < cutsceneSection.cutsceneAnimSets.Length; k++)
						{
							cutsceneSection.cutsceneAnimSets[k].modelAnim.gameObject.SetActive(value: true);
						}
					}
					NexusFullScreenPass.Inst.StartFadeToClear(BaseSettings<TeleportSettings>.Inst.cutsceneFadeDuration);
				}
			}
			if (!resuming)
			{
				Region.LockToRegion(cutsceneSection.region, owner);
			}
			NexusFullScreenPass.Inst.SetCutscene(cutsceneSection.region, overrideOOBValues, overrideOOBMaxFade, overrideOOBStartDist, overrideOOBMaxDist, overrideOOBPauseAlpha);
		}
		yield return Wait.For.Seconds(cutsceneDelay);
		for (int animIdx = 0; animIdx < cutsceneSection.animCount; animIdx++)
		{
			Wait none = Wait.None;
			for (int l = 0; l < cutsceneSection.cutsceneAnimSets.Length; l++)
			{
				CutsceneAnimationSet cutsceneAnimationSet = cutsceneSection.cutsceneAnimSets[l];
				float blendTime2 = ((animIdx == 0) ? blendTime : 0f);
				if (animIdx < cutsceneAnimationSet.animations.Length && !string.IsNullOrEmpty(cutsceneAnimationSet.animations[animIdx]))
				{
					currentAnims[l] = cutsceneAnimationSet.modelAnim;
					currentClipNames[l] = cutsceneAnimationSet.animations[animIdx];
					none &= HAGIS.PlayAnim(cutsceneAnimationSet.modelAnim, cutsceneAnimationSet.animations[animIdx], blendTime2);
					animationPlayed.value = cutsceneAnimationSet.animations[animIdx];
				}
			}
			yield return none;
			currentAnims[0] = null;
			currentAnims[1] = null;
		}
		animationPlayed.value = "";
		cutsceneSection.SetEnabled(enabled: false);
		if (restrictMovement)
		{
			if (!resuming)
			{
				Region.UnlockFromRegion(cutsceneSection.region, owner);
			}
			PlayerTeleport.TeleportEnabled.Value = true;
			NexusFullScreenPass.Inst.FinishedCutscene();
		}
		cutsceneSection.telepoint.gameObject.SetActive(value: false);
		if (CC.Inst.currentSceneUIDName == "back")
		{
			cutsceneSection.SetEnabled(enabled: true);
			cutsceneSection.telepoint.gameObject.SetActive(value: true);
		}
	}

	public abstract IEnumerator<Routine.Yield> OnCutsceneLogic(bool teleported);

	public abstract void OnSetup();

	public Wait MoveToTelepoint(CutsceneSection cutsceneSection, bool teleported, bool instant = false)
	{
		if (!resuming)
		{
			if (!teleported)
			{
				Vector3 position = cutsceneSection.telepoint.transform.position;
				Quaternion rotation = cutsceneSection.telepoint.transform.rotation;
				PlayerTeleport.OffsetCCPosRotFromMarker(position, rotation, out var ccPosition, out var ccRotation);
				if (instant)
				{
					return CC.Inst.PositionReplace(ccPosition, ccRotation, default(CC.TeleportInfo), fadeCamera: false, forceUpdateLastState: false, MovementType: false, CC.MovementType.Teleport);
				}
				return CC.Inst.PositionReplace(ccPosition, ccRotation, default(CC.TeleportInfo), fadeCamera: true, forceUpdateLastState: false, MovementType: false, CC.MovementType.Teleport, null, BaseSettings<TeleportSettings>.Inst.cutsceneFadeDuration, null, BaseSettings<TeleportSettings>.Inst.cutsceneFadeDuration);
			}
			return CC.Inst.WaitForPositionStackAnimating();
		}
		return Wait.None;
	}
}
public class HAGIS_CutSceneRepeater : HAGIS
{
	public override IEnumerator<Routine.Yield> OnLogic()
	{
		HAGIS_Cutscene_Base cutScene = GetComponent<HAGIS_Cutscene_Base>();
		Trigger trigger = GetComponentInChildren<Trigger>();
		while (true)
		{
			yield return Wait.Until.Completed(cutScene.onLogicBase);
			yield return trigger.OnOutside;
			cutScene.onLogicBase.Start();
		}
	}
}
public class HAGIS_Death_Cutscene : HAGIS
{
	[Header("Pre-Cutscene Arrival Settings")]
	public Trigger finlayArrivalTrigger;

	public Animation finlayArrivalAnim;

	public string finlayArrivalAnimName;

	[Header("Cutscene Settings")]
	public Trigger cutsceneTrigger;

	public float cutsceneBlend;

	public float cutsceneDelay;

	protected HagletValue<bool> triggered;

	protected HagletValue<bool> complete;

	protected Wait onCutsceneTriggerPremet = Wait.None;

	protected HagletTrigger teleportTrigger = new HagletTrigger();

	protected HagletValue<string> animationPlayed;

	protected Animation[] currentAnims = new Animation[2];

	protected string[] currentClipNames = new string[2];

	protected float[] currentAnimTimes = new float[2];

	public bool overrideOOBValues;

	[ConditionalHide("overrideOOBValues")]
	public float overrideOOBMaxFade = 0.95f;

	[ConditionalHide("overrideOOBValues")]
	public float overrideOOBStartDist = 0.8f;

	[ConditionalHide("overrideOOBValues")]
	public float overrideOOBMaxDist = 0.2f;

	[ConditionalHide("overrideOOBValues")]
	public float overrideOOBPauseAlpha = 0.9f;

	public FMODEventAsset cutsceneMusic;

	public CutsceneAnimationSet[] cutsceneAnimSets;

	public IDObjectRef altCutsceneRef;

	public IDObjectRef mainExitRegionRef;

	public IDObjectRef altExitRegionRef;

	[Header("Post-Cutscene Petting Settings")]
	public AnimPath finlayPettingController;

	private CutsceneSection cutsceneSection;

	public Portal exitPortal;

	protected IHaglet<CutsceneSection, float, bool> playCutsceneSectionRoutine;

	protected IHaglet<CutsceneSection, float, bool> playAltCutsceneSectionRoutine;

	public Wait IsTriggered => Wait.Until.True(triggered, 1, allowPreMetNow: true);

	public Wait IsComplete => Wait.Until.True(complete, 1, allowPreMetNow: true);

	protected override void OnHagisAwake()
	{
		HagletValue.Create(out triggered, null, initVal: false, null, 8);
		HagletValue.Create(out complete, null, initVal: false, null, 8);
		HagletValue.Create(out animationPlayed, (string)null, (string)null, (HagletEvent.IOwner)null, 8);
		Haglet.Create(out playCutsceneSectionRoutine, (Routine.Func3<CutsceneSection, float, bool>)PlayCutsceneSectionRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out playAltCutsceneSectionRoutine, (Routine.Func3<CutsceneSection, float, bool>)PlayCutsceneSectionRoutine, (string)null, startNow: false, (int?)null, (string)null);
	}

	public override void OnLoadLR(MRBase owner)
	{
		if (onLogicBase != null && base.CheckpointCount > 0)
		{
			onLogicBase.Start();
		}
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		if (finlayPettingController == null)
		{
			finlayPettingController = GetComponent<AnimPath>();
		}
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		cutsceneSection = new CutsceneSection
		{
			cutsceneAnimSets = cutsceneAnimSets,
			region = GetComponentInChildren<Region>(includeInactive: true),
			triggers = new Trigger[1] { cutsceneTrigger },
			telepoint = GetComponentInChildren<Telepoint>(includeInactive: true),
			cutsceneColliders = GetComponentsInChildren<CutsceneCollider>()
		};
		HAGIS_DeathAlt_Cutscene altCutscene = altCutsceneRef.Get<IDObject>().GetComponent<HAGIS_DeathAlt_Cutscene>();
		altCutscene.cutsceneSection = new CutsceneSection
		{
			cutsceneAnimSets = altCutscene.cutsceneAnimSets,
			region = altCutscene.GetComponentInChildren<Region>(includeInactive: true),
			triggers = new Trigger[1] { altCutscene.cutsceneTrigger },
			telepoint = altCutscene.GetComponentInChildren<Telepoint>(includeInactive: true),
			cutsceneColliders = altCutscene.GetComponentsInChildren<CutsceneCollider>()
		};
		Region mainExitRegion = LR.Inst.GetIDObjectComponent<Region>(mainExitRegionRef);
		Region altExitRegion = LR.Inst.GetIDObjectComponent<Region>(altExitRegionRef);
		mainExitRegion.Disable();
		altExitRegion.Disable();
		finlayArrivalAnim.gameObject.SetActive(value: false);
		altCutscene.finlayArrivalAnim.gameObject.SetActive(value: false);
		cutsceneSection.Setup(enabled: false, teleportTrigger);
		altCutscene.cutsceneSection.Setup(enabled: false, teleportTrigger);
		yield return finlayArrivalTrigger.OnInsidePremet | altCutscene.finlayArrivalTrigger.OnInsidePremet;
		exitPortal.ClosePortal();
		finlayArrivalAnim.gameObject.SetActive(value: true);
		altCutscene.finlayArrivalAnim.gameObject.SetActive(value: true);
		yield return AnimationX.PlayAnim(finlayArrivalAnim, finlayArrivalAnimName) & AnimationX.PlayAnim(altCutscene.finlayArrivalAnim, altCutscene.finlayArrivalAnimName);
		cutsceneSection.SetEnabled(enabled: true);
		altCutscene.cutsceneSection.SetEnabled(enabled: true);
		cutsceneSection.PlayPreIdle();
		altCutscene.cutsceneSection.PlayPreIdle();
		onCutsceneTriggerPremet = cutsceneSection.OnTriggerPremet | altCutscene.cutsceneSection.OnTriggerPremet;
		yield return onCutsceneTriggerPremet | teleportTrigger;
		bool arg = teleportTrigger.happening;
		LR.Inst.SetInCutscene(cutscene: true);
		triggered.value = true;
		cutsceneSection.StopIdling();
		altCutscene.cutsceneSection.StopIdling();
		if ((bool)cutsceneMusic)
		{
			LR.Inst.StopMusic();
			LR.Inst.PlayMusicOneShot(cutsceneMusic);
		}
		Region.LockToRegion(cutsceneSection.region, owner);
		Region.LockToRegion(altCutscene.cutsceneSection.region, altCutscene.owner);
		NexusFullScreenPass.Inst.SetCutscene(cutsceneSection.region, overrideOOBValues, overrideOOBMaxFade, overrideOOBStartDist, overrideOOBMaxDist, overrideOOBPauseAlpha, altCutscene.cutsceneSection.region);
		yield return playCutsceneSectionRoutine.Call(cutsceneSection, cutsceneBlend, arg) & playAltCutsceneSectionRoutine.Call(altCutscene.cutsceneSection, cutsceneBlend, arg);
		Region.UnlockFromRegion(cutsceneSection.region, owner);
		Region.UnlockFromRegion(altCutscene.cutsceneSection.region, altCutscene.owner);
		NexusFullScreenPass.Inst.FinishedCutscene();
		finlayPettingController.StartAnimationRoutine();
		altCutscene.finlayPettingController.StartAnimationRoutine();
		yield return Routine.Yield.SpecialIndex.StopSkipping;
		mainExitRegion.Enable();
		altExitRegion.Enable();
		LR.Inst.SetInCutscene(cutscene: false);
		complete.value = true;
		exitPortal.OpenPortal();
		yield return CHECKPOINT();
		yield return Save();
	}

	private IEnumerator<Routine.Yield> PlayCutsceneSectionRoutine(CutsceneSection cutsceneSection, float blendTime, bool teleported)
	{
		for (int i = 0; i < cutsceneSection.cutsceneAnimSets.Length; i++)
		{
			cutsceneSection.cutsceneAnimSets[i].modelAnim.gameObject.SetActive(value: true);
		}
		for (int j = 0; j < cutsceneSection.cutsceneColliders.Length; j++)
		{
			cutsceneSection.cutsceneColliders[j].gameObject.SetActive(value: false);
		}
		yield return Wait.For.Seconds(cutsceneDelay);
		for (int animIdx = 0; animIdx < cutsceneSection.animCount; animIdx++)
		{
			Wait none = Wait.None;
			for (int k = 0; k < cutsceneSection.cutsceneAnimSets.Length; k++)
			{
				CutsceneAnimationSet cutsceneAnimationSet = cutsceneSection.cutsceneAnimSets[k];
				float blendTime2 = ((animIdx == 0) ? blendTime : 0f);
				if (animIdx < cutsceneAnimationSet.animations.Length && !string.IsNullOrEmpty(cutsceneAnimationSet.animations[animIdx]))
				{
					currentAnims[k] = cutsceneAnimationSet.modelAnim;
					currentClipNames[k] = cutsceneAnimationSet.animations[animIdx];
					none &= HAGIS.PlayAnim(cutsceneAnimationSet.modelAnim, cutsceneAnimationSet.animations[animIdx], blendTime2);
					animationPlayed.value = cutsceneAnimationSet.animations[animIdx];
				}
			}
			yield return none;
			currentAnims[0] = null;
			currentAnims[1] = null;
		}
		animationPlayed.value = "";
		cutsceneSection.SetEnabled(enabled: false);
		cutsceneSection.telepoint.gameObject.SetActive(value: false);
	}

	public Wait MoveToTelepoint(CutsceneSection cutsceneSection, bool teleported, bool instant = false)
	{
		if (!resuming)
		{
			if (!teleported)
			{
				Vector3 position = cutsceneSection.telepoint.transform.position;
				Quaternion rotation = cutsceneSection.telepoint.transform.rotation;
				PlayerTeleport.OffsetCCPosRotFromMarker(position, rotation, out var ccPosition, out var ccRotation);
				if (instant)
				{
					return CC.Inst.PositionReplace(ccPosition, ccRotation, default(CC.TeleportInfo), fadeCamera: false, forceUpdateLastState: false, MovementType: false, CC.MovementType.Teleport);
				}
				return CC.Inst.PositionReplace(ccPosition, ccRotation, default(CC.TeleportInfo), fadeCamera: true, forceUpdateLastState: false, MovementType: false, CC.MovementType.Teleport, null, BaseSettings<TeleportSettings>.Inst.cutsceneFadeDuration, null, BaseSettings<TeleportSettings>.Inst.cutsceneFadeDuration);
			}
			return CC.Inst.WaitForPositionStackAnimating();
		}
		return Wait.None;
	}
}
public class HAGIS_DeathAlt_Cutscene : MonoBehaviour, IAwakeEvent
{
	[Header("Pre-Cutscene Arrival Settings")]
	public Trigger finlayArrivalTrigger;

	public Animation finlayArrivalAnim;

	public string finlayArrivalAnimName;

	[Header("Cutscene Settings")]
	public Trigger cutsceneTrigger;

	public CutsceneAnimationSet[] cutsceneAnimSets;

	[Header("Post-Cutscene Petting Settings")]
	public AnimPath finlayPettingController;

	[NonSerialized]
	public CutsceneSection cutsceneSection;

	[NonSerialized]
	public MRBase owner;

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		this.owner = owner;
	}
}
public class HAGIS_EndCableCarCutscene : HAGIS_Cutscene_Base
{
	[SerializeField]
	[Space(10f)]
	public CutsceneAnimationSet[] cutsceneAnimSets;

	private CutsceneSection cutsceneSection;

	public float whiteFadeDelay = 2.5f;

	public float whiteFadeInTime = 2f;

	public float whiteDelay = 1f;

	public float whitefadeOutTime = 1f;

	public Color whiteFadeOutColor = new Color(188f, 188f, 188f);

	public IDObjectRef mainMenuEntryPointRef;

	public Animation gondolaDoors;

	public string gondolaDoorsAnimation;

	public Animation gondolaRide;

	public string gondolaRideAnimation;

	public Animation sceneRenderAnimation;

	public string sceneRenderStartAnimation;

	public string sceneRenderGondolaAnimation;

	public ChapterInfo constructChapterInfo;

	public override void OnSetup()
	{
		cutsceneSection = new CutsceneSection
		{
			cutsceneAnimSets = cutsceneAnimSets,
			region = GetComponentInChildren<Region>(includeInactive: true),
			triggers = GetComponentsInChildren<Trigger>(includeInactive: true),
			telepoint = GetComponentInChildren<Telepoint>(includeInactive: true),
			cutsceneColliders = GetComponentsInChildren<CutsceneCollider>()
		};
		cutsceneSection.Setup(enabled: true, teleportTrigger);
		onCutsceneTriggerPremet = cutsceneSection.OnTriggerPremet;
		cutsceneSection.PlayPreIdle();
		sceneRenderAnimation.Play(sceneRenderStartAnimation);
	}

	public override IEnumerator<Routine.Yield> OnCutsceneLogic(bool teleported)
	{
		Transform ccXForm = CC.Inst.transform;
		cutsceneSection.StopIdling();
		playCutsceneSectionRoutine.Start(cutsceneSection, cutsceneBlend, teleported, arg3: true);
		yield return Wait.For.LRUpdates(1);
		yield return CC.Inst.WaitForPositionStackAnimating();
		AnimationX.PlayAnim(gondolaDoors, gondolaDoorsAnimation);
		AnimationX.PlayAnim(gondolaRide, gondolaRideAnimation);
		sceneRenderAnimation.Play(sceneRenderGondolaAnimation);
		LR.Inst.SetMusicParameter("progress", 0.1f);
		float beforeCutsceneTime = IC.Time;
		bool playedPostIdle = false;
		while ((playCutsceneSectionRoutine.started || IC.Time - beforeCutsceneTime < gondolaRide[gondolaRideAnimation].length) && !Routine.Skipping)
		{
			Transform regionTran = cutsceneSection.region.transform;
			Vector3 localPos = regionTran.InverseTransformPoint(ccXForm.position);
			yield return Wait.For.LRLateUpdates(1);
			Vector3 worldPos = regionTran.TransformPoint(localPos);
			CC.Inst.UpdateTrackingSpaceTransform(worldPos, ccXForm.rotation, updateHeldObjects: false);
			yield return Wait.For.LRUpdates(1);
			if (!playCutsceneSectionRoutine.started && !playedPostIdle)
			{
				cutsceneSection.PlayPostIdle();
				playedPostIdle = true;
			}
		}
		LR.Inst.PlatformManager.UnlockAchievement(NXAchievements.Story_Complete);
		LR.Inst.Save();
		LR.Inst.startCredits.Start(owner);
		yield return Wait.For.LRUpdates(1);
		yield return Routine.Yield.SpecialIndex.StopSkipping;
	}

	public override bool IgnoreAreaEvents()
	{
		return onCutsceneLogic.started;
	}
}
public class HAGIS_FollowObjectPivotIfActive : HAGIS
{
	public GameObject finlayIdCard;

	public GameObject replacementIdCard;

	public HAGIS_MultiPartCutscene cutscene;

	public float secondToSwitchOff = 24f;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		replacementIdCard.SetActive(value: false);
		yield return cutscene.IsTriggered;
		replacementIdCard.transform.SetParent(finlayIdCard.transform);
		replacementIdCard.transform.localRotation = Quaternion.Euler(180f, 90f, 0f);
		replacementIdCard.transform.localScale = Vector3.one;
		replacementIdCard.SetActive(value: true);
		yield return Wait.For.Seconds(secondToSwitchOff);
		replacementIdCard.SetActive(value: false);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_HunterTrophyRoom_Cutscene : HAGIS_Cutscene_Base
{
	[Tooltip("The animation components for this cutscene")]
	public CutsceneSection arrowSection;

	[Tooltip("The animation components for this cutscene")]
	public CutsceneSection cutscene;

	[Tooltip("Player must look at this transform to continue the cutscene")]
	public Transform lookAtXForm;

	[Range(-1f, 1f)]
	[Tooltip("-1 = Don't care at all, 1 = Must look absolutely perfectly at target")]
	public float lookStrictness;

	public IDObjectRef finlayAnimPathRef;

	public GameObject lornaObj;

	private AnimPath finlayAnimPath;

	private IdleAnimation idleAnim;

	private Animation finlayAnim;

	public Event cutsceneStartEvent;

	private IHaglet prepareEventRoutine;

	protected override void OnHagisAwake()
	{
		base.OnHagisAwake();
		finlayAnimPath = finlayAnimPathRef.Get<AnimPath>();
		finlayAnim = finlayAnimPath.AnimInstance;
		idleAnim = finlayAnim.GetComponentInChildren<IdleAnimation>();
		idleAnim.OnAwakeLR();
		Haglet.Create(out prepareEventRoutine, PrepareEventRoutine);
	}

	public override Wait PrepareEvents()
	{
		return prepareEventRoutine.Start();
	}

	private IEnumerator<Routine.Yield> PrepareEventRoutine()
	{
		yield return base.PrepareEvents();
		yield return Wait.For.LRUpdates(1);
		cutsceneStartEvent.PrepareInvoke();
	}

	public override void OnSetup()
	{
		for (int i = 0; i < cutscene.cutsceneAnimSets.Length; i++)
		{
			for (int j = 0; j < cutscene.cutsceneAnimSets[i].animations.Length; j++)
			{
				if (cutscene.cutsceneAnimSets[i].animations[j].Contains("Finlay"))
				{
					cutscene.cutsceneAnimSets[i].modelAnim = finlayAnimPath.AnimInstance;
					break;
				}
			}
		}
		arrowSection.Setup(enabled: true, teleportTrigger);
		cutscene.Setup(enabled: true, teleportTrigger);
		onCutsceneTriggerPremet = arrowSection.OnTriggerPremet;
		finlayAnim.transform.localPosition = Vector3.zero;
		finlayAnim.transform.localRotation = Quaternion.identity;
		cutscene.PlayPreIdle();
	}

	public override IEnumerator<Routine.Yield> OnCutsceneLogic(bool teleported)
	{
		idleAnim.StopIdling();
		yield return Wait.ForUpdate;
		lornaObj.transform.localPosition = Vector3.zero;
		PlayerTeleport.TeleportEnabled.Value = false;
		NexusFullScreenPass.Inst.SetCutscene(arrowSection.region);
		if (!resuming)
		{
			Region.LockToRegion(arrowSection.region, owner);
		}
		yield return playCutsceneSectionRoutine.Call(arrowSection, cutsceneBlend, teleported, arg3: false);
		float num;
		do
		{
			yield return Wait.For.LRUpdates(1);
			Vector3 normalized = (lookAtXForm.position - IC.GetHeadPosition()).normalized;
			Vector3 rhs = IC.GetHeadRotation() * Vector3.forward;
			num = Vector3.Dot(normalized, rhs);
		}
		while (num < lookStrictness && !Routine.Skipping);
		cutsceneStartEvent.Invoke();
		cutscene.StopIdling();
		yield return playCutsceneSectionRoutine.Call(cutscene, cutsceneBlend, teleported, arg3: false);
		lornaObj.SetActive(value: false);
		PlayerTeleport.TeleportEnabled.Value = true;
		NexusFullScreenPass.Inst.FinishedCutscene();
		if (!resuming)
		{
			Region.UnlockFromRegion(cutscene.region, owner);
		}
		cutscene.PlayPostIdle();
		finlayAnimPath.StartAnimationRoutine();
	}
}
public class HAGIS_MultiPartCutscene : HAGIS_Cutscene_Base
{
	public CutsceneSection[] cutsceneSections;

	public FMODEventAsset[] cutsceneMusic;

	public Region regionBetweenCutscenes;

	public override void OnSetup()
	{
		if (cutsceneSections.Length != 0)
		{
			for (int i = 0; i < cutsceneSections.Length; i++)
			{
				cutsceneSections[i].Setup(i == 0, teleportTrigger);
			}
			onCutsceneTriggerPremet = cutsceneSections[0].OnTriggerPremet;
			cutsceneSections[0].PlayPreIdle();
		}
	}

	public override IEnumerator<Routine.Yield> OnCutsceneLogic(bool teleported)
	{
		if (cutsceneSections.Length == 0)
		{
			yield return Wait.None;
		}
		CutsceneSection firstCutscene = cutsceneSections[0];
		for (int i = 0; i < cutsceneSections.Length; i++)
		{
			CutsceneSection cutsceneSection = cutsceneSections[i];
			if (firstCutscene != cutsceneSection)
			{
				onCutsceneTriggerPremet = cutsceneSection.OnTriggerPremet;
				cutsceneSection.PlayPreIdle();
				cutsceneSection.SetEnabled(enabled: true);
				if (!resuming && (bool)regionBetweenCutscenes)
				{
					Region.LockToRegion(regionBetweenCutscenes, owner);
				}
				yield return cutsceneSection.OnTriggerPremet | teleportTrigger;
				if (!resuming && (bool)regionBetweenCutscenes)
				{
					Region.UnlockFromRegion(regionBetweenCutscenes, owner);
				}
				teleported = teleportTrigger.happening;
			}
			cutsceneSection.StopIdling();
			if (i < cutsceneMusic.Length && !Routine.Skipping)
			{
				LR.Inst.PlayMusicOneShot(cutsceneMusic[i]);
			}
			yield return playCutsceneSectionRoutine.Start(cutsceneSection, cutsceneBlend, teleported, arg3: true, resetIfStarted: false, Routine.Skipping);
			cutsceneSection.PlayPostIdle();
			yield return Routine.Yield.SpecialIndex.StopSkipping;
		}
	}
}
public class HAGIS_Princess_Cutscene : HAGIS_Cutscene_Base
{
	[Serializable]
	public struct BarkAnims
	{
		public string anim;

		public float blendTime;
	}

	[Serializable]
	public struct AnimationPair
	{
		public string triggeringAnimation;

		public string animationToPlay;

		public Animation animationComponent;

		public IdleAnimation idleAnimation;

		public float idleBlend;
	}

	public CutsceneSection preCutscene;

	public CutsceneSection cutscene;

	public FMODEventAsset cutsceneMusic;

	public Animation barkAnimComp;

	public Region barkRegion;

	public Vector2 barkDelay = new Vector2(10f, 20f);

	[Tooltip("Number of seconds before the first time Lorna will shout at the player, after which barkDelay comes into effect")]
	public float initialBarkDelay = 10f;

	public string barkIdle;

	public BarkAnims[] barkAnimations;

	[Tooltip("Play one animation (\"Animation To Play\") on the selected Animation Component when another animation in the cutscene starts  (\"Triggering Animation\"). Set \"Idle Animation\" if the thing we want to animate has an idle component, as the idle needs to be stopped.")]
	public AnimationPair animationTriggerPair;

	public FMODSnapshotAsset muteMusicBoxSnapshot;

	public PuzzlesCompleteTrigger puzzlesAfterCutscene;

	private ConstArray<BarkAnims> shuffleList;

	private int barkIndex;

	private IHaglet muteMusicBox;

	private IHaglet finlayAnimation;

	private IHaglet barkRoutine;

	public override void OnSetup()
	{
		Haglet.Create(out barkRoutine, BarkRoutine);
		Haglet.Create(out finlayAnimation, FinlayAnimationRoutine);
		Haglet.Create(out muteMusicBox, MuteMusicBoxRoutine);
		shuffleList = new ConstArray<BarkAnims>((uint)barkAnimations.Length);
		preCutscene.Setup(enabled: true, teleportTrigger);
		cutscene.Setup(enabled: false, teleportTrigger);
		onCutsceneTriggerPremet = preCutscene.OnTriggerPremet;
		preCutscene.PlayPreIdle();
	}

	public override IEnumerator<Routine.Yield> OnCutsceneLogic(bool teleported)
	{
		preCutscene.StopIdling();
		muteMusicBox.Start();
		yield return playCutsceneSectionRoutine.Call(preCutscene, cutsceneBlend, teleported, arg3: true, 1, reset: true, resuming);
		HAGIS.PlayAnim(barkAnimComp, barkIdle, cutsceneBlend);
		onCutsceneTriggerPremet = cutscene.OnTriggerPremet;
		cutscene.SetEnabled(enabled: true);
		if (!resuming)
		{
			Region.LockToRegion(barkRegion, owner);
		}
		teleported = false;
		float barkTimer = 0f;
		float barkTime = initialBarkDelay;
		while (!teleported && !cutscene.InTrigger && !Routine.Skipping)
		{
			if (!barkRoutine.started && !barkRoutine.paused)
			{
				barkTimer += IC.DeltaTime;
				if (barkTimer >= barkTime)
				{
					barkTime = UnityEngine.Random.Range(barkDelay.x, barkDelay.y);
					barkTimer = 0f;
					barkRoutine.Start();
				}
			}
			yield return Wait.For.LRUpdates(1) | teleportTrigger;
			teleported = teleportTrigger.happening;
		}
		if (!resuming)
		{
			Region.UnlockFromRegion(barkRegion, owner);
		}
		if (barkRoutine.started)
		{
			barkRoutine.Stop();
		}
		VOC.Inst.VOStop(interruption: true);
		VOC.Inst.ClearRemainingVO();
		barkAnimComp.Stop();
		HAGIS.PlayAnim(barkAnimComp, barkIdle, cutsceneBlend);
		LR.Inst.SetMusic(cutsceneMusic);
		playCutsceneSectionRoutine.Start(cutscene, cutsceneBlend, teleported, arg3: true, resetIfStarted: false, resuming);
		yield return finlayAnimation.Call() & Wait.Until.Completed(playCutsceneSectionRoutine);
		if (Routine.Skipping && playCutsceneSectionRoutine.started)
		{
			playCutsceneSectionRoutine.Skip();
		}
		cutscene.PlayPostIdle();
	}

	private IEnumerator<Routine.Yield> MuteMusicBoxRoutine()
	{
		FMOD.Studio.EventInstance muteMusicBox = FAC.Inst.PlaySnapShot(muteMusicBoxSnapshot);
		yield return puzzlesAfterCutscene.PuzzlesComplete;
		muteMusicBox.stop(STOP_MODE.ALLOWFADEOUT);
	}

	private Wait TryPlayAnimPair(string currentAnimation)
	{
		if (animationTriggerPair.triggeringAnimation != currentAnimation || animationTriggerPair.animationComponent == null)
		{
			return Wait.None;
		}
		if (animationTriggerPair.idleAnimation != null)
		{
			animationTriggerPair.idleAnimation.StopIdling();
		}
		return HAGIS.PlayAnim(animationTriggerPair.animationComponent, animationTriggerPair.animationToPlay, animationTriggerPair.idleBlend);
	}

	private IEnumerator<Routine.Yield> FinlayAnimationRoutine()
	{
		Wait animationWait = Wait.None;
		do
		{
			yield return animationPlayed;
			animationWait &= TryPlayAnimPair(animationPlayed.value);
			if (Routine.Skipping)
			{
				animationTriggerPair.animationComponent.gameObject.SetActive(value: false);
				yield break;
			}
		}
		while (!(animationWait != Wait.None));
		yield return animationWait;
	}

	private IEnumerator<Routine.Yield> BarkRoutine()
	{
		if (barkIndex >= barkAnimations.Length)
		{
			ShuffleBarks();
			barkIndex = 0;
		}
		BarkAnims barkAnims = barkAnimations[barkIndex];
		barkIndex++;
		yield return HAGIS.PlayAnim(barkAnimComp, barkAnims.anim, barkAnims.blendTime);
		yield return Wait.For.LRUpdates(1);
		HAGIS.PlayAnim(barkAnimComp, barkIdle, cutsceneBlend);
	}

	private void ShuffleBarks()
	{
		shuffleList.Clear();
		for (int i = 0; i < barkAnimations.Length; i++)
		{
			shuffleList.Add(barkAnimations[i]);
		}
		for (int j = 0; j < barkAnimations.Length; j++)
		{
			uint num = (uint)UnityEngine.Random.Range(0f, shuffleList.Length);
			barkAnimations[j] = shuffleList[num];
			shuffleList.RemoveAtIndex(num);
		}
	}

	public override void OnDestroyCalled()
	{
		if (muteMusicBox != null)
		{
			muteMusicBox.Stop();
		}
		if (finlayAnimation != null)
		{
			finlayAnimation.Stop();
		}
		if (barkRoutine != null)
		{
			barkRoutine.Stop();
		}
	}
}
public class HAGIS_Simple_Cutscene : HAGIS_Cutscene_Base
{
	[SerializeField]
	[Space(10f)]
	public CutsceneAnimationSet[] cutsceneAnimSets;

	public FMODEventAsset cutsceneMusic;

	public FMODEventAsset afterCutsceneMusic;

	private CutsceneSection cutsceneSection;

	public override void OnSetup()
	{
		cutsceneSection = new CutsceneSection
		{
			cutsceneAnimSets = cutsceneAnimSets,
			region = GetComponentInChildren<Region>(includeInactive: true),
			triggers = GetComponentsInChildren<Trigger>(includeInactive: true),
			telepoint = GetComponentInChildren<Telepoint>(includeInactive: true),
			cutsceneColliders = GetComponentsInChildren<CutsceneCollider>()
		};
		cutsceneSection.Setup(enabled: true, teleportTrigger);
		onCutsceneTriggerPremet = cutsceneSection.OnTriggerPremet;
		cutsceneSection.PlayPreIdle();
	}

	public override IEnumerator<Routine.Yield> OnCutsceneLogic(bool teleported)
	{
		cutsceneSection.StopIdling();
		if ((bool)cutsceneMusic && !Routine.Skipping)
		{
			LR.Inst.StopMusic();
			LR.Inst.PlayMusicOneShot(cutsceneMusic);
		}
		yield return playCutsceneSectionRoutine.Call(cutsceneSection, cutsceneBlend, teleported, arg3: true);
		cutsceneSection.PlayPostIdle();
		if ((bool)afterCutsceneMusic)
		{
			LR.Inst.SetMusic(afterCutsceneMusic);
		}
		yield return Routine.Yield.SpecialIndex.StopSkipping;
	}
}
public class Demo_StartRoom_Pickup : MonoBehaviour, IAwakeEvent, ICanEnterPortal
{
	public readonly string DISSOLVE_AMOUNT_NAME = "_DissolveAmount";

	public float dissolveTime = 3f;

	public FMODEventAsset soundDissolve;

	public FMODEventAsset soundGrabbed;

	private PortalingRigidbody posterPRB;

	[HideInInspector]
	public GrabObject grabObject;

	private Material mat;

	private IHaglet<Portal> dissolveRoutine;

	private IHaglet posterRipRoutine;

	public void OnAwakeLR(MRBase owner)
	{
		grabObject = GetComponentInChildren<GrabObject>(includeInactive: true);
		posterPRB = GetComponentInChildren<PortalingRigidbody>(includeInactive: true);
		mat = GetComponentInChildren<MeshRenderer>(includeInactive: true).material;
		Haglet.Create(out dissolveRoutine, (Routine.Func1<Portal>)DissolveRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out posterRipRoutine, PosterRipRoutine);
		if ((bool)soundGrabbed)
		{
			posterRipRoutine.Start(resetIfStarted: true);
		}
	}

	private IEnumerator<Routine.Yield> DissolveRoutine(Portal portal)
	{
		grabObject.pr.GravityEnabled = false;
		grabObject.enabled = false;
		if (dissolveTime > 0f)
		{
			FMOD.Studio.EventInstance evtDissolve = FAC.Inst.PlayOneShot(soundDissolve, posterPRB.transform.position);
			float t = 0f;
			while (t < 1f)
			{
				t += Time.deltaTime / dissolveTime;
				mat.SetFloat(DISSOLVE_AMOUNT_NAME, t);
				Vector3 headPosition = IC.GetHeadPosition();
				float sqrMagnitude = (posterPRB.transform.position - headPosition).sqrMagnitude;
				float sqrMagnitude2 = (portal.transform.position - headPosition).sqrMagnitude;
				Vector3 pos = ((sqrMagnitude < sqrMagnitude2) ? posterPRB.transform.position : portal.transform.position);
				evtDissolve.set3DAttributes(pos.to3DAttributes());
				yield return Wait.For.LRUpdates(1);
			}
		}
		mat.SetFloat(DISSOLVE_AMOUNT_NAME, 1f);
		if (CC.Inst.GetHandObjectIsGrabbed(grabObject) != null)
		{
			Hand.UngrabObject(grabObject);
		}
		grabObject.gameObject.SetActive(value: false);
	}

	private IEnumerator<Routine.Yield> PosterRipRoutine()
	{
		Vector3 basePos = posterPRB.transform.position;
		while (basePos == posterPRB.transform.position)
		{
			yield return Wait.For.LRUpdates(1);
		}
		FAC.Inst.PlayOneShot(soundGrabbed, posterPRB.transform);
	}

	public void StartDissolve(Portal portal)
	{
		if (!dissolveRoutine.started)
		{
			dissolveRoutine.Start(portal);
		}
	}

	public void ResetGrabObject()
	{
		grabObject.enabled = true;
		grabObject.gameObject.SetActive(value: true);
		grabObject.ResetToInitialState();
		mat.SetFloat(DISSOLVE_AMOUNT_NAME, 0f);
		if ((bool)soundGrabbed)
		{
			posterRipRoutine.Start(resetIfStarted: true);
		}
		grabObject.pr.GravityEnabled = true;
	}

	private void OnDestroy()
	{
		dissolveRoutine?.Stop();
		posterRipRoutine?.Stop();
	}

	public void OnEnterPortal(Portal portal)
	{
		StartDissolve(portal);
	}
}
public class HAGIS_FinalHub_MainFlow : HAGIS
{
	public Portal constructEntryPortal;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		constructEntryPortal.transform.parent.gameObject.SetActive(value: false);
		yield return Wait.For.LRUpdates(1);
	}
}
public class HAGIS_GardensA_MainFlow : HAGIS
{
	public PuzzleInfo puzzle1;

	public PuzzleInfo puzzle2;

	public PuzzleInfo puzzle3;

	public PuzzleInfo puzzle4;

	public PuzzleInfo puzzle5;

	public LightSource P1Light;

	public LightSource P2Light;

	public LightSource P345Light;

	public LightSource optionalPuzzleLight;

	public GameObject telepointP2;

	public GameObject telepointP3;

	public GameObject telepointP4;

	public GameObject telepointP5;

	public AnimRotateToTarget lightRotator;

	public PlayerAreaTrigger tutorialTrigger;

	public float tutorialWait = 45f;

	public Doorway introDoorway;

	public Doorway mainDoorway;

	public Doorway exitDoorway;

	public FrustumDetector mainDoorsFrustum;

	public Animation puzzleDoorP1;

	public Animation exitDoor;

	public IDObjectRef musicBoxRef;

	private GrabObject musicBox;

	public FMODEventAsset rotateSound;

	private IHaglet tutorTimer;

	protected override void OnHagisAwake()
	{
		base.OnHagisAwake();
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return Wait.For.Seconds(10f);
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		yield return LR.Inst.IsAllConnectedScenesUnloaded;
		bool musicBoxExists = LR.Inst.TryGetIDObject<GrabObject>(musicBoxRef, out musicBox);
		if (musicBoxExists)
		{
			musicBox.gameObject.SetActive(value: false);
		}
		else
		{
			_ = Routine.Skipping;
		}
		tutorialTrigger.enabled = false;
		P2Light.DisableLight();
		P345Light.DisableLight();
		optionalPuzzleLight.DisableLight();
		yield return CHECKPOINT();
		yield return WaitForPuzzle(puzzle1);
		P1Light.DisableLight();
		yield return Wait.For.Seconds(0.9f);
		introDoorway.Open();
		P2Light.EnableLight();
		Haglet.Create(out tutorTimer, TutorTimer, null, startNow: true);
		yield return WaitForPuzzle(puzzle2);
		tutorTimer.Stop();
		telepointP2.SetActive(value: false);
		P2Light.DisableLight();
		yield return WaitForPuzzle(puzzle2);
		if (!Routine.Skipping)
		{
			yield return Wait.For.Seconds(1.5f);
		}
		if (musicBoxExists)
		{
			musicBox.gameObject.SetActive(value: true);
		}
		mainDoorway.Open();
		P345Light.EnableLight();
		optionalPuzzleLight.EnableLight();
		yield return WaitForPuzzle(puzzle3);
		telepointP3.SetActive(value: false);
		if (!Routine.Skipping)
		{
			yield return Wait.For.Seconds(3f);
		}
		FMOD.Studio.EventInstance sound1 = FAC.Inst.PlayOneShot(rotateSound, lightRotator.transform.position);
		yield return lightRotator.AnimateOnYield(Quaternion.Euler(0f, 0f, -70f), 1f, localRotation: true, Routine.Skipping);
		sound1.stop(STOP_MODE.ALLOWFADEOUT);
		yield return WaitForPuzzle(puzzle4);
		telepointP4.SetActive(value: false);
		if (!Routine.Skipping)
		{
			yield return Wait.For.Seconds(3f);
		}
		FMOD.Studio.EventInstance sound2 = FAC.Inst.PlayOneShot(rotateSound, lightRotator.transform.position);
		yield return lightRotator.AnimateOnYield(Quaternion.Euler(0f, 0f, -140f), 1f, localRotation: true, Routine.Skipping);
		UnityEngine.Debug.Log("SECOND FFS " + Routine.Skipping);
		sound2.stop(STOP_MODE.ALLOWFADEOUT);
		yield return WaitForPuzzle(puzzle5);
		telepointP5.SetActive(value: false);
		exitDoor.Play("AN_HutDoor");
		P345Light.DisableLight();
		exitDoorway.Open();
		yield return CHECKPOINT();
	}

	private IEnumerator<Routine.Yield> TutorTimer()
	{
		yield return Wait.For.Seconds(tutorialWait);
		tutorialTrigger.enabled = true;
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_GardensA_OptionalPuzzle : HAGIS
{
	public PuzzleInfo optionalPuzzle;

	public LightSource lightSource;

	public GameObject telepoint;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return WaitForPuzzle(optionalPuzzle);
		lightSource.DisableLight();
		telepoint.SetActive(value: false);
		yield return Wait.For.LRUpdates(1);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_GardensB_AppleDrop : HAGIS
{
	public PlayerAreaTrigger areaTrigger;

	public FrustumDetector3D frustumDetector;

	public Animation anim;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return areaTrigger.OnInside | frustumDetector.OnInView;
		yield return Wait.For.Seconds(0.25f);
		anim.Play("AN_GardensB_AppleFall");
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_GardensB_DisablePortal : HAGIS
{
	public IDObjectRef entryPortalRef;

	public IDObjectRef exitPortalRef;

	private Portal entryPortal;

	private Portal exitPortal;

	public bool reusable = true;

	private bool used;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		exitPortal = LR.Inst.GetIDObjectComponent<Portal>(exitPortalRef);
		SetExitPortalEnabled(enabled: false);
		while (entryPortal == null)
		{
			LR.Inst.TryGetIDObjectComponent<Portal>(entryPortalRef, out entryPortal);
			yield return Wait.For.LRUpdates(1);
		}
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		while (reusable || !used)
		{
			while (!entryPortal.playerEnteredPortal.happening)
			{
				if (exitPortal.IsUnlocked)
				{
					exitPortal.SetUnlockedState(unlocked: false, applyToLink: false);
				}
				yield return Wait.For.LRUpdates(1);
			}
			SetExitPortalEnabled(enabled: true);
			yield return Wait.For.LRUpdates(1);
			do
			{
				yield return Wait.For.LRUpdates(1);
			}
			while (false);
			SetExitPortalEnabled(enabled: false);
			used = true;
		}
	}

	private void SetExitPortalEnabled(bool enabled)
	{
		exitPortal.SetUnlockedState(enabled, applyToLink: false);
		exitPortal.SetHidden(!enabled);
		exitPortal.UpdateParticlesEnabled();
	}
}
public class HAGIS_GardensB_EndFlow : HAGIS
{
	public IDObjectRef exitDoorFrustumIDRef;

	public Doorway exitDoorway;

	public PuzzleInfo[] mainPuzzles;

	public FrustumDetector3D doorFrustum;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return WaitForPuzzles(mainPuzzles);
		yield return doorFrustum.IsInView;
		exitDoorway.Open();
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_GardensB_FinlayFly : HAGIS
{
	public HAGIS_Generic_TriggerAnimOnFrustum triggerAnim;

	public VO_Sequencer sequencer;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		sequencer.gameObject.SetActive(value: false);
		yield return triggerAnim.IsTriggered;
		yield return Wait.For.Seconds(10f);
		sequencer.gameObject.SetActive(value: true);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_GardensB_OptionalPuzzle : HAGIS
{
	public PuzzleInfo puzzle;

	public GameObject telepoint;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return Wait.For.LRUpdates(1);
		yield return WaitForPuzzle(puzzle);
		telepoint.SetActive(value: false);
	}
}
public class HAGIS_GardensC_ColliderEnableOnEmptyPlacementHelpers : HAGIS
{
	public Collider colliderToToggle;

	public IDObjectRef[] placementHelperIDs;

	private PlacementHelper[] placementHelpers;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		colliderToToggle.enabled = false;
		placementHelpers = new PlacementHelper[placementHelperIDs.Length];
		for (int i = 0; i < placementHelperIDs.Length; i++)
		{
			placementHelpers[i] = LR.Inst.GetIDObjectComponent<PlacementHelper>(placementHelperIDs[i]);
		}
		while (true)
		{
			bool flag = true;
			for (int j = 0; j < placementHelpers.Length; j++)
			{
				if (placementHelpers[j].HeldGrabObject != null)
				{
					flag = false;
				}
			}
			colliderToToggle.enabled = flag;
			yield return Wait.For.LRUpdates(1);
		}
	}
}
public class HAGIS_GardensC_MainFlow : HAGIS
{
	[Header("Puzzle One Flow")]
	public PuzzleInfo puzzleOne;

	public IDObjectRef postPuzzleOneDoorwayRef;

	public IDObjectRef puzzleOneTelepointRef;

	public IDObjectRef puzzleOneLightSourceRef;

	[Header("Puzzle Two Flow")]
	public PuzzleInfo puzzleTwo;

	public Doorway postPuzzleTwoDoorway;

	public GameObject puzzleTwoTelepoint;

	public LightSource puzzleTwoLightSource;

	[Header("Puzzle Three Flow")]
	public PuzzleInfo puzzleThree;

	public Doorway postPuzzleThreeDoorway;

	public GameObject puzzleThreeTelepoint;

	public LightSource puzzleThreeLightSource;

	public IDObjectRef puzzleThreeGrabObjectRef;

	[Header("Puzzle Four Flow")]
	public PuzzleInfo puzzleFour;

	public Doorway postPuzzleFourDoorway;

	public GameObject puzzleFourTelepoint;

	public LightSource puzzleFourLightSource;

	public IDObjectRef puzzleFourGrabObjectRef;

	[Header("Exit Flow")]
	public Portal hutPortal;

	public Doorway exitDoorway;

	public Region doorCoverRegion;

	public Region doorCoverRegion2;

	public IDObjectRef hutRegionRef;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		Doorway postPuzzleOneDoorway = postPuzzleOneDoorwayRef.Get<IDObject>().GetComponent<Doorway>();
		GameObject puzzleOneTelepoint = puzzleOneTelepointRef.Get<IDObject>().gameObject;
		LightSource puzzleOneLightSource = puzzleOneLightSourceRef.Get<IDObject>().GetComponent<LightSource>();
		GrabObject puzzleThreeGrabObject = puzzleThreeGrabObjectRef.Get<GrabObject>();
		GrabObject puzzleFourGrabObject = puzzleFourGrabObjectRef.Get<GrabObject>();
		Region hutRegion = hutRegionRef.Get<IDObject>().GetComponent<Region>();
		hutRegion.Disable();
		puzzleTwoTelepoint.SetActive(value: false);
		puzzleTwoLightSource.DisableLight();
		puzzleThreeTelepoint.SetActive(value: false);
		puzzleThreeLightSource.DisableLight();
		puzzleThreeGrabObject.canBeGrabbed = false;
		puzzleThreeGrabObject.mimic.GetTargetMimic().GrabObject.canBeGrabbed = false;
		puzzleFourTelepoint.SetActive(value: false);
		puzzleFourLightSource.DisableLight();
		puzzleFourGrabObject.canBeGrabbed = false;
		puzzleFourGrabObject.mimic.GetTargetMimic().GrabObject.canBeGrabbed = false;
		puzzleOneLightSource.EnableLight();
		puzzleOneTelepoint.SetActive(value: true);
		yield return WaitForPuzzle(puzzleOne);
		puzzleOneLightSource.DisableLight();
		puzzleOneTelepoint.SetActive(value: false);
		postPuzzleOneDoorway.Open();
		puzzleTwoLightSource.EnableLight();
		puzzleTwoTelepoint.SetActive(value: true);
		yield return WaitForPuzzle(puzzleTwo);
		puzzleTwoLightSource.DisableLight();
		puzzleTwoTelepoint.SetActive(value: false);
		postPuzzleTwoDoorway.Open();
		puzzleThreeLightSource.EnableLight();
		puzzleThreeTelepoint.SetActive(value: true);
		puzzleThreeGrabObject.canBeGrabbed = true;
		puzzleThreeGrabObject.mimic.GetTargetMimic().GrabObject.canBeGrabbed = true;
		yield return WaitForPuzzle(puzzleThree);
		puzzleThreeLightSource.DisableLight();
		puzzleThreeTelepoint.SetActive(value: false);
		postPuzzleThreeDoorway.Open();
		puzzleFourLightSource.EnableLight();
		puzzleFourTelepoint.SetActive(value: true);
		puzzleFourGrabObject.canBeGrabbed = true;
		puzzleFourGrabObject.mimic.GetTargetMimic().GrabObject.canBeGrabbed = true;
		yield return WaitForPuzzle(puzzleFour);
		puzzleFourLightSource.DisableLight();
		doorCoverRegion.Disable();
		doorCoverRegion2.Disable();
		puzzleFourTelepoint.SetActive(value: false);
		postPuzzleFourDoorway.Open();
		hutPortal.twoSided = true;
		hutPortal.Link.twoSided = true;
		exitDoorway.Open();
		hutRegion.Enable();
		LR.Inst.StopMusic();
		puzzleFourGrabObject.canBeGrabbed = false;
		puzzleFourGrabObject.mimic.GetTargetMimic().GrabObject.canBeGrabbed = false;
		yield return Wait.For.Seconds(5f);
		puzzleFourGrabObject.ForceBreak();
		puzzleFourGrabObject.mimic.GetTargetMimic().GrabObject.ForceBreak();
	}
}
public class HAGIS_GardensC_OptionalPuzzleFlow : HAGIS
{
	public PuzzleInfo puzzle;

	public LightSource lightSource;

	public GameObject telepoint;

	private Obelisk obelisk;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return Wait.For.LRUpdates(1);
		yield return WaitForPuzzle(puzzle);
		lightSource.DisableLight();
		telepoint.SetActive(value: false);
		yield return Wait.For.LRUpdates(1);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class AnimationProgresser : MonoBehaviour, HAGIS_Generic_MultiLightSensorController.ICanProgress
{
	private Animation anim;

	private string animClip;

	public Region[] regions;

	public GameObject[] linkedGameObjects;

	[Range(0f, 1f)]
	[Tooltip("Threshold above which to activate regions. 0.7 means they will activate once the animation has reached 70% completion")]
	public float regionActivateThreshold;

	[Range(0f, 1f)]
	[Tooltip("Threshold above which to activate gameobjects. 0.7 means they will activate once the animation has reached 70% completion")]
	public float gameobjectActivateThreshold;

	[NonSerialized]
	[HideInInspector]
	public float AnimTime;

	public void ProgressableAwake()
	{
		anim = GetComponentInChildren<Animation>(includeInactive: true);
		animClip = anim.clip.name;
	}

	public void ModifyProgress(float dt, float limit)
	{
		AnimationState animationState = anim[animClip];
		float normalizedTime = animationState.normalizedTime;
		float num = dt / animationState.length;
		if (normalizedTime > limit && normalizedTime + num > normalizedTime)
		{
			num *= -1f;
		}
		else if (normalizedTime <= limit && normalizedTime + num > limit)
		{
			num = Mathf.Clamp(limit - normalizedTime, Mathf.Min(dt, 0f - dt), Mathf.Max(0f - dt, dt)) / animationState.length;
		}
		float num2 = Mathf.Clamp01(animationState.normalizedTime + num);
		if (num2 != normalizedTime)
		{
			SampleAnimation(num2);
		}
		CheckRegions(num2);
		AnimTime = num2;
	}

	private void CheckRegions(float progress)
	{
		bool flag = progress >= regionActivateThreshold;
		for (int i = 0; i < regions.Length; i++)
		{
			if (flag && !regions[i].IsEnabled)
			{
				regions[i].Enable();
			}
			else if (!flag && regions[i].IsEnabled)
			{
				regions[i].Disable();
			}
		}
		bool active = progress >= gameobjectActivateThreshold;
		for (int j = 0; j < linkedGameObjects.Length; j++)
		{
			linkedGameObjects[j].SetActive(active);
		}
	}

	public void ResetProgress()
	{
		SampleAnimation(0f);
	}

	public void SkipToEnd()
	{
		SampleAnimation(1f);
	}

	private void SampleAnimation(float normalizedTime)
	{
		AnimationState animationState = anim[animClip];
		animationState.enabled = true;
		animationState.weight = 1f;
		animationState.normalizedTime = normalizedTime;
		anim.Sample();
		animationState.enabled = false;
	}
}
public class HAGIS_Generic_DisableColliderOnTrigger : HAGIS
{
	public Trigger trigVolume;

	public Collider colliderToToggle;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		while (true)
		{
			yield return trigVolume.OnInside;
			if (colliderToToggle.enabled)
			{
				colliderToToggle.enabled = false;
			}
			yield return trigVolume.OnOutside;
			if (!colliderToToggle.enabled)
			{
				colliderToToggle.enabled = true;
			}
			yield return Wait.For.LRUpdates(1);
		}
	}
}
public class HAGIS_Generic_DisableLightOnPuzzleComplete : HAGIS
{
	public LightSource lightSourceToDisable;

	public IDObjectRef[] puzzleRefs;

	public PuzzleInfo[] puzzleInfos;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		yield return WaitForPuzzles(puzzleInfos);
		lightSourceToDisable.DisableLight();
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_Generic_DisablePortalOnChapterInteract : HAGIS
{
	public IDObjectRef portalRef;

	public float maxDistance = 5f;

	public override bool ShouldSave => false;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		Portal prtl = LR.Inst.GetIDObject<Portal>(portalRef);
		CC cc = CC.Inst;
		yield return Wait.Until.True(() => (bool)cc.handL.GrabObjectHeld || (bool)cc.handR.GrabObjectHeld) | Wait.Until.True(() => Vector3.Distance(MainCamera.Inst.transform.position, prtl.transform.position) > maxDistance) | Wait.Until.True(() => LR.Inst.IsInCutscene);
		prtl.SetUnlockedState(unlocked: false);
		yield return Wait.For.Seconds(prtl.typeSettings.expansionTime);
		prtl.gameObject.SetActive(value: false);
		LR.Inst.LoadAdjacentScenes();
	}
}
public class HAGIS_Generic_DisablePortalOnLookAway : HAGIS
{
	public Portal entryPortal;

	public Portal exitPortal;

	public FrustumDetector3D[] frustumDetectors;

	public bool reusable = true;

	private bool used;

	public float disableDist = 0.5f;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		SetExitPortalEnabled(enabled: false);
		while (reusable || !used)
		{
			while (!entryPortal.playerEnteredPortal.happening)
			{
				Vector3 worldPosition = MainCamera.Inst.GetWorldPosition();
				if (Vector3.Distance(entryPortal.GetClosestPointOnPortal(worldPosition), worldPosition) < disableDist)
				{
					SetExitPortalEnabled(enabled: true);
				}
				else
				{
					SetExitPortalEnabled(enabled: false);
				}
				yield return entryPortal.playerEnteredPortal | Wait.For.LRUpdates(1);
			}
			SetExitPortalEnabled(enabled: true);
			bool shouldDisable = false;
			while (!shouldDisable)
			{
				bool flag = false;
				FrustumDetector3D[] array = frustumDetectors;
				foreach (FrustumDetector3D frustumDetector3D in array)
				{
					flag |= frustumDetector3D.IsInViewBool;
				}
				Vector3 worldPosition2 = MainCamera.Inst.GetWorldPosition();
				Vector3 closestPointOnPortal = exitPortal.GetClosestPointOnPortal(worldPosition2);
				Vector3 closestPointOnPortal2 = entryPortal.GetClosestPointOnPortal(worldPosition2);
				bool flag2 = Vector3.Distance(closestPointOnPortal, worldPosition2) < disableDist;
				bool flag3 = Vector3.Distance(closestPointOnPortal2, worldPosition2) < disableDist;
				shouldDisable = !flag && !flag2 && !flag3;
				yield return Wait.For.LRUpdates(1);
			}
			SetExitPortalEnabled(enabled: false);
			used = true;
		}
	}

	private void SetExitPortalEnabled(bool enabled)
	{
		exitPortal.SetUnlockedState(enabled, applyToLink: false);
		exitPortal.SetHidden(!enabled);
		if (enabled)
		{
			if (exitPortal.Link != entryPortal)
			{
				entryPortal.SetLinkRef(exitPortal);
			}
			if (entryPortal.Link != exitPortal)
			{
				exitPortal.SetLinkRef(entryPortal);
			}
		}
	}
}
public class HAGIS_Generic_DisablePortalOnStart : HAGIS
{
	public IDObjectRef portalRef;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		LR.Inst.GetIDObject<Portal>(portalRef).gameObject.SetActive(value: false);
		yield return Wait.For.LRUpdates(0);
	}
}
public class HAGIS_Generic_DropObjInTrigger : HAGIS
{
	public Renderer visual;

	public bool activateThis = true;

	private Trigger thisTrigger;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		thisTrigger = GetComponent<Trigger>();
		thisTrigger.enabled = false;
		visual.enabled = false;
		while (true)
		{
			if (activateThis)
			{
				if (!visual.enabled)
				{
					visual.enabled = true;
				}
				if (thisTrigger.IsInsideBool)
				{
					CC inst = CC.Inst;
					if (inst.handL.InteractableHeld != null)
					{
						Hand.UngrabObject(inst.handL.InteractableHeld);
					}
					if (inst.handR.InteractableHeld != null)
					{
						Hand.UngrabObject(inst.handR.InteractableHeld);
					}
				}
				yield return Wait.For.LRUpdates(1);
			}
			else
			{
				if (visual.enabled)
				{
					thisTrigger.enabled = false;
					visual.enabled = false;
				}
				yield return Wait.For.LRUpdates(1);
			}
		}
	}
}
public class HAGIS_Generic_EGrillForceOpenInventory : HAGIS
{
	public float inventoryOpenTime = 1.5f;

	public bool oneOff;

	private EGrill eGrill;

	protected override void OnHagisAwake()
	{
		eGrill = GetComponent<EGrill>();
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		if (Routine.Skipping && oneOff && ShouldSave)
		{
			yield break;
		}
		do
		{
			yield return eGrill.onCrossedEGrillTrigger;
			bool wasOpen = PlayerInventory.Inst.IsInventoryOpen();
			if (!wasOpen)
			{
				PlayerInventory.Inst.OpenInventory(InventoryEffectType.OPEN, _checkDistance: false);
			}
			yield return Wait.For.Seconds(inventoryOpenTime);
			if (!wasOpen)
			{
				PlayerInventory.Inst.CloseInventory();
			}
		}
		while (!oneOff);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_Generic_MultiLightSensorController : HAGIS
{
	public interface ICanProgress
	{
		void ProgressableAwake();

		void ModifyProgress(float dt, float limit);

		void ResetProgress();

		void SkipToEnd();
	}

	public interface ICanToggle
	{
		void TogglableAwake();

		void Toggle(bool enabled);
	}

	public IDObjectRef[] lightSensorRefs;

	private LightSensor[] lightSensors;

	public GameObject[] progressables;

	public GameObject[] togglables;

	private ICanProgress[] progressableObjects;

	private ICanToggle[] togglableObjects;

	public bool allowPartialProgress;

	public bool allowFullProgress;

	public bool inverseMode;

	[Tooltip("if selected, the controller will activate all connected progressables when ANY of the connected light sensors are activated. Disables partial progress for obvious reasons!")]
	public bool orMode;

	private void GetReferences()
	{
		lightSensors = new LightSensor[lightSensorRefs.Length];
		for (int i = 0; i < lightSensorRefs.Length; i++)
		{
			lightSensors[i] = LR.Inst.GetIDObjectComponent<LightSensor>(lightSensorRefs[i]);
		}
		progressableObjects = new ICanProgress[progressables.Length];
		for (int j = 0; j < progressableObjects.Length; j++)
		{
			progressableObjects[j] = progressables[j].GetComponent<ICanProgress>();
			progressableObjects[j].ProgressableAwake();
		}
		togglableObjects = new ICanToggle[togglables.Length];
		for (int k = 0; k < togglableObjects.Length; k++)
		{
			togglableObjects[k] = togglables[k].GetComponent<ICanToggle>();
			togglableObjects[k].TogglableAwake();
		}
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		GetReferences();
		while (!Routine.Skipping)
		{
			bool flag = !allowPartialProgress && !allowFullProgress;
			if (orMode)
			{
				flag = false;
			}
			int num = 0;
			for (int i = 0; i < lightSensors.Length; i++)
			{
				bool value = lightSensors[i].isReceivingLight.value;
				value = (inverseMode ? (!value) : value);
				if (orMode && value)
				{
					flag = true;
					num = lightSensors.Length;
					break;
				}
				if (allowPartialProgress || allowFullProgress)
				{
					if (value)
					{
						flag = true;
						num++;
					}
				}
				else if (!value && !orMode)
				{
					flag = false;
					break;
				}
			}
			int num2 = (flag ? 1 : (-1));
			float num3 = 1f;
			if (allowPartialProgress)
			{
				num3 = (float)num / 2f;
			}
			for (int j = 0; j < progressableObjects.Length; j++)
			{
				progressableObjects[j].ModifyProgress(Time.deltaTime * (float)num2, num3);
			}
			for (int k = 0; k < togglableObjects.Length; k++)
			{
				togglableObjects[k].Toggle(num2 > 0 && num3 == 1f);
			}
			yield return Wait.For.LRUpdates(1);
		}
	}
}
public class HAGIS_Generic_MultiPuzzleLightDeactivator : HAGIS
{
	public ObeliskPuzzle[] puzzlesToWaitOn;

	public PuzzleInfo[] puzzleInfosToWaitOn;

	public LightSource[] lightsToDisable;

	public bool makeDisableSound;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return WaitForPuzzles(puzzleInfosToWaitOn);
		LightSource[] array = lightsToDisable;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].DisableLight();
		}
	}
}
public class HAGIS_Generic_ObeliskPortalOpener : HAGIS
{
	public bool debugComplete;

	public PuzzleInfo[] mainPuzzles;

	public IDObjectRef obeliskPortalRef;

	public IDObjectRef animationObjRef;

	public bool playAnimOnComplete;

	[Tooltip("For adding a sound to the animation, plays from that object in world space.")]
	public FMODEventAsset completeExtraSound;

	private Portal obeliskPortal;

	private Animation completeAnim;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		if (obeliskPortalRef != null && !string.IsNullOrEmpty(obeliskPortalRef.id))
		{
			obeliskPortal = obeliskPortalRef.Get<Portal>();
			obeliskPortal.SetUnlockedState(unlocked: false);
		}
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		if (playAnimOnComplete && animationObjRef != null)
		{
			animationObjRef.TryGetComponent<Animation>(out completeAnim);
		}
		if (!debugComplete)
		{
			yield return WaitForPuzzles(mainPuzzles);
		}
		if (obeliskPortalRef != null && !string.IsNullOrEmpty(obeliskPortalRef.id))
		{
			obeliskPortal.SetUnlockedState(unlocked: true);
		}
		if (!playAnimOnComplete)
		{
			yield break;
		}
		if (LR.Inst.GetIDObject<IDObject>(animationObjRef).GetComponent<Animator>() != null)
		{
			LR.Inst.GetIDObjectComponent<Animator>(animationObjRef).SetTrigger("Play");
		}
		else if ((bool)completeAnim)
		{
			HAGIS.PlayAnim(completeAnim);
			if (completeExtraSound != null)
			{
				FAC.Inst.PlayOneShot(completeExtraSound, completeAnim.gameObject.transform.position);
			}
		}
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_Generic_RegionTriggerWithOcclusionState : HAGIS
{
	public GameObject occlusionState;

	public Occludee objectToCheck;

	public int[] stateToCheck;

	public Region regionToEnable;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		regionToEnable.Disable();
		while (true)
		{
			yield return objectToCheck.OnStateChange;
			for (int i = 0; i < stateToCheck.Length; i++)
			{
				if (!regionToEnable.IsEnabled && objectToCheck.GetStateIndex() == stateToCheck[i])
				{
					regionToEnable.Enable();
					break;
				}
				if (regionToEnable.IsEnabled)
				{
					regionToEnable.Disable();
				}
			}
		}
	}
}
public class HAGIS_Generic_ResetObjPositionOnLookAway : HAGIS
{
	[Serializable]
	public class ObjectsToReset
	{
		public GameObject GO;

		public Animation anim;

		[HideInInspector]
		public Vector3 defaultPos;

		[HideInInspector]
		public Vector3 defaultRot;
	}

	public HAGIS_Generic_DisablePortalOnLookAway disablePortalOnLookAway;

	public ObjectsToReset[] objectsToReset;

	protected override void OnHagisAwake()
	{
		for (int i = 0; i < objectsToReset.Length; i++)
		{
			objectsToReset[i].defaultPos = objectsToReset[i].GO.transform.position;
			objectsToReset[i].defaultRot = objectsToReset[i].GO.transform.localEulerAngles;
		}
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return Wait.For.LRUpdates(1);
		while (true)
		{
			yield return disablePortalOnLookAway.entryPortal.playerEnteredPortal;
			yield return Wait.For.LRUpdates(1);
			bool flag;
			do
			{
				yield return Wait.For.LRUpdates(1);
				flag = false;
				FrustumDetector3D[] frustumDetectors = disablePortalOnLookAway.frustumDetectors;
				foreach (FrustumDetector3D frustumDetector3D in frustumDetectors)
				{
					flag |= frustumDetector3D.IsInViewBool;
				}
			}
			while (flag);
			for (int j = 0; j < objectsToReset.Length; j++)
			{
				if (objectsToReset[j].anim != null)
				{
					objectsToReset[j].anim.Stop();
				}
				objectsToReset[j].GO.transform.position = objectsToReset[j].defaultPos;
				objectsToReset[j].GO.transform.localRotation = Quaternion.Euler(objectsToReset[j].defaultRot);
			}
		}
	}
}
public class HAGIS_Generic_SparkleUntilTrigger : HAGIS, ICutsceneEvent
{
	public ParticleSystem sparkles;

	public Trigger[] triggers;

	private HagletTrigger cutsceneStarted = new HagletTrigger();

	private HagletTrigger cutsceneEnded = new HagletTrigger();

	public void OnCutsceneBegin()
	{
		cutsceneStarted.Trigger();
	}

	public void OnCutsceneEnd()
	{
		cutsceneEnded.Trigger();
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		bool shouldPlay = true;
		while (shouldPlay)
		{
			sparkles.Play();
			Wait forever = Wait.Forever;
			Trigger[] array = triggers;
			foreach (Trigger trigger in array)
			{
				forever |= trigger.OnInsidePremet;
			}
			yield return forever | cutsceneStarted;
			if ((bool)cutsceneStarted.happening)
			{
				sparkles.Stop();
				yield return cutsceneEnded;
			}
			else
			{
				shouldPlay = false;
			}
		}
		sparkles.Stop();
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_Generic_StartEvent : HAGIS, IPrepareEvent
{
	public Event StartEvent;

	Wait IPrepareEvent.PrepareEvents()
	{
		StartEvent.PrepareInvoke();
		return Wait.None;
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		StartEvent.Invoke();
		yield return Wait.For.LRUpdates(0);
	}
}
public class HAGIS_Generic_TriggerAnimOnFrustum : HAGIS
{
	public FrustumDetector3D frustum;

	public Animation anim;

	public AnimationClip animClip;

	public IdleAnimation overrideIdleAnim;

	private IdleAnimation idleAnim;

	private HagletValue<bool> triggered;

	public Wait IsTriggered => Wait.Until.True(triggered, 1, allowPreMetNow: true);

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		idleAnim = ((overrideIdleAnim == null) ? anim.GetComponent<IdleAnimation>() : overrideIdleAnim);
		HagletValue.Create(out triggered, null, initVal: false, null, 8);
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		yield return frustum.IsInView | Wait.For.Seconds(8f);
		triggered.value = true;
		if (idleAnim != null)
		{
			idleAnim.StopIdling();
		}
		yield return HAGIS.PlayAnim(anim, animClip.name);
		if (idleAnim != null)
		{
			idleAnim.ResumeIdling();
		}
	}
}
public class HAGIS_Generic_TriggerEnableObject : HAGIS
{
	public PlayerAreaTrigger trigger;

	public GameObject gameObjectToEnable;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		gameObjectToEnable.SetActive(value: false);
		yield return trigger.OnInside;
		gameObjectToEnable.SetActive(value: true);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_Generic_TriggerRegionDisabler : HAGIS
{
	public IDObjectRef triggerRef;

	public Region regionToDisable;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		Trigger trigger;
		while (!triggerRef.TryGet<Trigger>(out trigger, base.gameObject))
		{
			yield return Wait.For.LRUpdates(1);
		}
		bool isInsideBool = trigger.IsInsideBool;
		if (isInsideBool)
		{
			regionToDisable.Enable();
		}
		else
		{
			regionToDisable.Disable();
		}
		while (true)
		{
			if (isInsideBool)
			{
				yield return trigger.OnOutside;
			}
			else
			{
				yield return trigger.OnInside;
			}
			isInsideBool = trigger.IsInsideBool;
			if (isInsideBool)
			{
				regionToDisable.Enable();
			}
			else
			{
				regionToDisable.Disable();
			}
		}
	}
}
public class HAGIS_Generic_WipeInvOnEnterScene : HAGIS
{
	public override IEnumerator<Routine.Yield> OnLogic()
	{
		PlayerInventory.Inst.EmptyInventory(fromSaveData: false);
		yield break;
	}
}
public class HAGIS_PortalOnRasterizerPuzzle : HAGIS
{
	public IDObjectRef[] helperRefs;

	public IDObjectRef m_portalRef;

	public IDObjectRef[] m_disableOnPortalEnabledRef;

	private List<PlacementHelper> helpers = new List<PlacementHelper>();

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		for (int i = 0; i < helperRefs.Length; i++)
		{
			PlacementHelper iDObjectComponent = LR.Inst.GetIDObjectComponent<PlacementHelper>(helperRefs[i]);
			if (iDObjectComponent != null)
			{
				helpers.Add(iDObjectComponent);
			}
		}
		IDObject portal = LR.Inst.GetIDObject<IDObject>(m_portalRef);
		portal.gameObject.SetActive(value: false);
		while (true)
		{
			portal.gameObject.SetActive(value: false);
			yield return Routine.Yield.SpecialIndex.StopSkipping;
			bool holding2 = false;
			while (!holding2)
			{
				holding2 = true;
				foreach (PlacementHelper helper in helpers)
				{
					holding2 &= helper.HeldGrabObject != null;
				}
				yield return Wait.For.LRUpdates(1);
			}
			portal.gameObject.SetActive(value: true);
			for (int j = 0; j < m_disableOnPortalEnabledRef.Length; j++)
			{
				IDObjectRef iDObjectRef = m_disableOnPortalEnabledRef[j];
				if (iDObjectRef.IsRefLoaded())
				{
					iDObjectRef.obj.gameObject.SetActive(value: false);
				}
			}
			if (Routine.Skipping)
			{
				yield return Routine.Yield.SpecialIndex.StopSkipping;
				yield return Wait.For.Seconds(10f);
			}
			holding2 = true;
			while (holding2)
			{
				holding2 = true;
				foreach (PlacementHelper helper2 in helpers)
				{
					holding2 &= helper2.HeldGrabObject != null;
				}
				yield return Wait.For.LRUpdates(1);
			}
			for (int k = 0; k < m_disableOnPortalEnabledRef.Length; k++)
			{
				IDObjectRef iDObjectRef2 = m_disableOnPortalEnabledRef[k];
				if (iDObjectRef2.IsRefLoaded())
				{
					iDObjectRef2.obj.gameObject.SetActive(value: true);
				}
			}
		}
	}
}
public class HAGIS_StealthPortalIdleSound : HAGIS
{
	public IDObjectRef[] stealthPortalRefs;

	private Portal[] stealthPortals;

	public FMODEventAsset stealthSound;

	private FMOD.Studio.EventInstance evtStealth;

	public string paramName = "PortalDistance";

	public float distModifier = 1f;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		stealthPortals = new Portal[stealthPortalRefs.Length];
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		for (int i = 0; i < stealthPortalRefs.Length; i++)
		{
			stealthPortals[i] = stealthPortalRefs[i].Get<Portal>();
		}
		evtStealth = FAC.Inst.GetEvent(stealthSound);
		evtStealth.setParameterValue(paramName, 10f / distModifier);
		evtStealth.set3DAttributes(base.transform.position.to3DAttributes());
		evtStealth.start();
		evtStealth.release();
		while (true)
		{
			float num = 10f;
			Vector3 position = MainCamera.Inst.transform.position;
			for (int j = 0; j < stealthPortalRefs.Length; j++)
			{
				num = Mathf.Min(num, Vector3.Distance(position, stealthPortals[j].transform.position));
			}
			evtStealth.setParameterValue(paramName, num / distModifier);
			yield return Wait.For.LRUpdates(1);
		}
	}

	protected override void OnHagisDestroyed()
	{
		evtStealth.stop(STOP_MODE.IMMEDIATE);
	}
}
public class HAGIS_VaultClearInventory : HAGIS
{
	public override IEnumerator<Routine.Yield> OnLogic()
	{
		CC inst = CC.Inst;
		GrabObject grabObject = inst.handL.InteractableHeld as GrabObject;
		GrabObject grabObject2 = inst.handR.InteractableHeld as GrabObject;
		if ((bool)grabObject)
		{
			grabObject.ForceBreak();
		}
		if ((bool)grabObject2)
		{
			grabObject2.ForceBreak();
		}
		if (PlayerInventory.Inst.inventoryState != null)
		{
			PlayerInventory.Inst.EmptyInventory(fromSaveData: false);
		}
		yield break;
	}
}
public class HAGIS_Grotto_A_CutsceneParticleHandler : HAGIS
{
	[SerializeField]
	private float scaleOverSeconds = 1f;

	[SerializeField]
	private GameObject particleGroup;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		particleGroup.transform.localScale = Vector3.zero;
		float num = Mathf.Lerp(0f, 1f, scaleOverSeconds);
		particleGroup.transform.localScale += new Vector3(num, num, num);
		yield break;
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_GrottoA_MainFlow : HAGIS
{
	public PuzzleInfo[] puzzles;

	public Trigger finlayTrigger;

	public FMODEventAsset music;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		LR.Inst.SetMusic(music);
		Wait none = Wait.None;
		for (int i = 0; i < puzzles.Length; i++)
		{
			none &= puzzles[i].UntilComplete(SaveDataGame.PuzzleSaveType.Scene);
		}
		yield return none;
		LR.Inst.StopMusic();
	}
}
public class HAGIS_GrottoA_PuzzleFlow : HAGIS
{
	public PuzzleInfo puzzle;

	public GameObject telepoint;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return Wait.For.LRUpdates(1);
		yield return WaitForPuzzle(puzzle);
		telepoint.SetActive(value: false);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
[RequireComponent(typeof(Animation))]
public class LightSensorTriggerAnim : HAGIS
{
	[Serializable]
	public struct SoundParameters
	{
		public string parameterName;

		public float parameterValue;
	}

	public IDObjectRef lightSensorRef;

	public string litAnim;

	public FMODEventAsset forwardSound;

	public FMODEventAsset reverseSound;

	public FMOD.Studio.EventInstance soundInstance;

	public bool allowSoundOverlap = true;

	public SoundParameters[] forwardParameters;

	public SoundParameters[] reverseParameters;

	public float soundPeriod = 0.5f;

	public Vector3 soundPosition;

	private Animation anim;

	private LightSensor lightSensor;

	private bool isLocked;

	private FMODEventAsset lastAssetPlayed;

	private float soundTimer;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		lightSensor = LR.Inst.GetIDObjectComponent<LightSensor>(lightSensorRef);
		isLocked = false;
		anim = GetComponent<Animation>();
		while (true)
		{
			if (lightSensor.isReceivingLight.value && !isLocked)
			{
				anim[litAnim].speed = 1f;
				anim[litAnim].time = 0f;
				anim.CrossFade(litAnim);
				isLocked = true;
			}
			if (!lightSensor.isReceivingLight.value && isLocked)
			{
				anim[litAnim].speed = -1f;
				anim[litAnim].time = anim[litAnim].length;
				anim.CrossFade(litAnim);
				isLocked = false;
			}
			if (anim.isPlaying)
			{
				soundTimer += IC.DeltaTime;
			}
			if (soundTimer > soundPeriod)
			{
				UpdateSounds(lightSensor.isReceivingLight.value);
				soundTimer %= soundPeriod;
			}
			yield return Wait.For.LRUpdates(1);
		}
	}

	private void UpdateSounds(bool forward)
	{
		FMODEventAsset fMODEventAsset = (forward ? forwardSound : reverseSound);
		SoundParameters[] array = (forward ? forwardParameters : reverseParameters);
		if (lastAssetPlayed != fMODEventAsset && soundInstance.isValid())
		{
			soundInstance.stop(STOP_MODE.IMMEDIATE);
		}
		if (allowSoundOverlap || (!soundInstance.isValid() && !(fMODEventAsset == null)))
		{
			soundInstance = FAC.Inst.PlayOneShot(fMODEventAsset, base.transform.TransformPoint(soundPosition));
			for (int i = 0; i < array.Length; i++)
			{
				soundInstance.setParameterValue(array[i].parameterName, array[i].parameterValue);
			}
		}
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_GrottoB_AnimControl : HAGIS
{
	public GameObject animLorna;

	public GameObject cliffLorna;

	public PuzzleInfo cavePuzzle;

	public Animation doorAnim;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		animLorna.SetActive(value: false);
		yield return WaitForPuzzle(cavePuzzle);
		animLorna.SetActive(value: true);
		doorAnim.Play("AN_GrottoB_CSDoor_Open");
		cliffLorna.SetActive(value: false);
		yield return animLorna.GetComponentInChildren<HAGIS_Simple_Cutscene>().IsTriggered;
		yield return Wait.For.Seconds(54f);
		doorAnim.Play("AN_GrottoB_CSDoor_Close");
		yield return Wait.For.Seconds(2f);
		animLorna.SetActive(value: false);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_GrottoB_CavePuzzle : HAGIS
{
	public IDObjectRef lightSensorRef1;

	public IDObjectRef lightSensorRef2;

	public IDObjectRef animPlinthRef;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		LightSensor Sensor1 = LR.Inst.GetIDObjectComponent<LightSensor>(lightSensorRef1);
		LightSensor Sensor2 = LR.Inst.GetIDObjectComponent<LightSensor>(lightSensorRef2);
		AnimMoveToTarget animPlinth = LR.Inst.GetIDObjectComponent<AnimMoveToTarget>(animPlinthRef);
		float targetHeightPrev = 0f;
		yield return Wait.For.Seconds(1f);
		while (true)
		{
			float num = ((Sensor1.isReceivingLight.value && Sensor2.isReceivingLight.value) ? (-0.8f) : ((!Sensor1.isReceivingLight.value && !Sensor2.isReceivingLight.value) ? 0f : (-0.4f)));
			if (num != targetHeightPrev)
			{
				targetHeightPrev = num;
				Vector3 position = animPlinth.transform.localPosition.RepY(num);
				animPlinth.Animate(position, 1f, localRotation: true);
			}
			yield return Wait.For.LRUpdates(1);
		}
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_GrottoB_DoorOnP1Complete : HAGIS
{
	public PuzzleInfo[] puzzleInfo;

	public Doorway P1Doorway;

	public Doorway P2Doorway;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return WaitForPuzzle(puzzleInfo[0]);
		P1Doorway.Open();
		yield return WaitForPuzzle(puzzleInfo[1]);
		P2Doorway.Open();
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_GrottoB_EndFlow : HAGIS
{
	private struct TransitionInfo
	{
		public Vector3 posOffset;

		public Quaternion rotOffset;

		public Region vaultLiftRegion;

		public Doorway vaultLiftDoorway;

		public Collider[] vaultLiftOOBColliders;

		public GameObject vaultWall;

		public float remainingAnimTime;

		public float transitionFadeInTime;

		public float transitionFadeDelayTime;

		public FMOD.Studio.EventInstance liftMoveEventInstance;
	}

	[Header("Grotto References")]
	public Animation liftAnim;

	public Doorway liftDoorway;

	public Region liftRegion;

	public Collider[] liftOOBColliders;

	[Header("Vault References")]
	public IDObjectRef vaultPortalRef;

	public IDObjectRef vaultLiftRef;

	public IDObjectRef vaultLiftAnimRef;

	public IDObjectRef vaultLiftDoorwayRef;

	public IDObjectRef vaultLiftRegionRef;

	public IDObjectRef vaultLiftOOBColidersRef;

	public IDObjectRef vaultWallRef;

	[Header("Flow Settings")]
	public PuzzleInfo[] mainPuzzles;

	public HAGIS_Simple_Cutscene cutscene;

	[Header("Music Settings")]
	public FMODEventAsset startMusic;

	public FMODEventAsset finalMusic;

	[Header("SFX")]
	public FMODEventAsset liftMoveUpSound;

	[Header("Transition Settings")]
	public Color transitionFadeColor = Color.white;

	public float transitionStartTime = 2.5f;

	public float transitionFadeInTime = 0.5f;

	public float transitionFadeDelayTime = 0.5f;

	public float transitionFadeOutTime = 0.5f;

	private const string LIFT_ANIMATION_NAME = "AN_GrottoLiftUp";

	private IDObject vaultWall;

	private Animation vaultLiftAnim;

	private GameObject vaultLift;

	private GameObject vaultPortal;

	private TransitionInfo transitionInfo;

	private IHaglet initialiseTransitionInfo;

	private static IHaglet<TransitionInfo> transitionRoutine;

	protected override void OnHagisAwake()
	{
		base.OnHagisAwake();
		Collider[] array = liftOOBColliders;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].gameObject.SetActive(value: false);
		}
		Haglet.Create(out transitionRoutine, (Routine.Func1<TransitionInfo>)TransitionRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out initialiseTransitionInfo, InitialiseTransitionInfo, null, startNow: true);
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		PlayerAreaTrigger trigger = GetComponentInChildren<PlayerAreaTrigger>();
		_ = liftAnim["AN_GrottoLiftUp"];
		trigger.gameObject.SetActive(value: false);
		LR.Inst.SetMusic(startMusic);
		yield return cutscene.IsComplete;
		bool flag = true;
		for (int i = 0; i < mainPuzzles.Length; i++)
		{
			if (!mainPuzzles[i].IsComplete(SaveDataGame.PuzzleSaveType.Scene))
			{
				flag = false;
			}
		}
		if (!flag)
		{
			LR.Inst.SetMusic(finalMusic);
			yield return WaitForPuzzles(mainPuzzles);
			LR.Inst.StopMusic();
		}
		yield return Routine.Yield.SpecialIndex.StopSkipping;
		if (initialiseTransitionInfo.started)
		{
			yield return Wait.Until.Completed(initialiseTransitionInfo);
		}
		yield return liftDoorway.Open();
		trigger.gameObject.SetActive(value: true);
		yield return trigger.OnInside;
		yield return liftDoorway.Close();
		Collider[] array = liftOOBColliders;
		for (int j = 0; j < array.Length; j++)
		{
			array[j].gameObject.SetActive(value: true);
		}
		yield return Wait.For.Seconds(1f);
		HAGIS.PlayAnim(liftAnim, "AN_GrottoLiftUp");
		HAGIS.PlayAnim(vaultLiftAnim, "AN_GrottoLiftUp");
		transitionInfo.liftMoveEventInstance = FAC.Inst.PlayOneShot(liftMoveUpSound, base.transform.position);
		yield return Wait.For.Seconds(transitionStartTime);
		yield return NexusFullScreenPass.Inst.StartFadeToColor(transitionFadeOutTime, transitionFadeColor);
		vaultLift.SetActive(value: true);
		vaultPortal.SetActive(value: false);
		Vector3 posOffset = liftRegion.transform.InverseTransformPoint(CC.Inst.transform.position);
		Quaternion rotOffset = liftRegion.transform.InverseTransformRotation(CC.Inst.transform.rotation);
		transitionInfo.posOffset = posOffset;
		transitionInfo.rotOffset = rotOffset;
		transitionInfo.remainingAnimTime = vaultLiftAnim["AN_GrottoLiftUp"].length - (transitionStartTime + transitionFadeOutTime);
		transitionRoutine.Start(transitionInfo);
	}

	private IEnumerator<Routine.Yield> InitialiseTransitionInfo()
	{
		yield return Routine.Yield.SpecialIndex.StopSkipping;
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		while (LR.Inst.GetLoadedMRWithSceneUIDNameOrNull("bead") == null)
		{
			yield return Wait.For.Updates(1);
		}
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		vaultLiftAnim = vaultLiftAnimRef.Get<IDObject>().GetComponent<Animation>();
		vaultLift = vaultLiftRef.Get<IDObject>().gameObject;
		vaultPortal = vaultPortalRef.Get<IDObject>().gameObject;
		Doorway component = vaultLiftDoorwayRef.Get<IDObject>().GetComponent<Doorway>();
		Region component2 = vaultLiftRegionRef.Get<IDObject>().GetComponent<Region>();
		Collider[] componentsInChildren = vaultLiftOOBColidersRef.Get<IDObject>().GetComponentsInChildren<Collider>();
		GameObject gameObject = vaultWallRef.Get<IDObject>().gameObject;
		transitionInfo = default(TransitionInfo);
		transitionInfo.vaultLiftDoorway = component;
		transitionInfo.vaultLiftRegion = component2;
		transitionInfo.transitionFadeDelayTime = transitionFadeDelayTime;
		transitionInfo.transitionFadeInTime = transitionFadeInTime;
		transitionInfo.vaultLiftOOBColliders = componentsInChildren;
		transitionInfo.vaultWall = gameObject;
	}

	private static IEnumerator<Routine.Yield> TransitionRoutine(TransitionInfo info)
	{
		yield return Wait.For.LRUpdates(1);
		info.vaultWall.SetActive(value: false);
		Vector3 worldPos = info.vaultLiftRegion.transform.TransformPoint(info.posOffset);
		Quaternion worldRot = info.vaultLiftRegion.transform.TransformRotation(info.rotOffset);
		CC.Inst.PositionReplace(worldPos, worldRot, default(CC.TeleportInfo), fadeCamera: false, forceUpdateLastState: true);
		CC.Inst.SetRegion(info.vaultLiftRegion);
		Collider[] vaultLiftOOBColliders = info.vaultLiftOOBColliders;
		for (int i = 0; i < vaultLiftOOBColliders.Length; i++)
		{
			vaultLiftOOBColliders[i].gameObject.SetActive(value: true);
		}
		yield return Wait.For.Seconds(info.transitionFadeDelayTime);
		yield return NexusFullScreenPass.Inst.StartFadeToClear(info.transitionFadeInTime);
		float seconds = info.remainingAnimTime - (info.transitionFadeDelayTime + info.transitionFadeInTime);
		yield return Wait.For.Seconds(seconds);
		if (info.liftMoveEventInstance.isValid())
		{
			info.liftMoveEventInstance.setParameterValue("GrottoBLift", 1f);
		}
		vaultLiftOOBColliders = info.vaultLiftOOBColliders;
		for (int i = 0; i < vaultLiftOOBColliders.Length; i++)
		{
			vaultLiftOOBColliders[i].gameObject.SetActive(value: false);
		}
		yield return info.vaultLiftDoorway.Open();
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_GrottoB_FinlayFly : HAGIS
{
	public Trigger trigger;

	public string flyAnim;

	private Animation anim;

	public AmbiantIdleAnimation startIdle;

	public AmbiantIdleAnimation endIdle;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		anim = GetComponent<Animation>();
		System.Random random = new System.Random();
		yield return Wait.For.LRUpdates(1);
		endIdle.StopIdling();
		yield return trigger.OnInside;
		startIdle.StopIdling();
		yield return HAGIS.PlayAnim(anim, flyAnim);
		endIdle.StartIdling(endIdle.ambiantIdle, random);
	}
}
public class HAGIS_GrottoB_IntroSensorPuzzle : HAGIS
{
	public LightSensor lightSensor;

	public AnimMoveToTarget animPlinth;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		Vector3 targetHeightPrev = new Vector3(0f, 0f, 0f);
		new Vector3(0f, 0f, 0f);
		yield return Wait.For.Seconds(1f);
		while (true)
		{
			Vector3 vector = ((!lightSensor.isReceivingLight.value) ? new Vector3(0f, -0.8f, 0f) : new Vector3(0f, -0.1f, 0f));
			if (vector != targetHeightPrev)
			{
				targetHeightPrev = vector;
				animPlinth.Animate(targetHeightPrev, 1f, localRotation: true);
			}
			yield return Wait.For.LRUpdates(1);
		}
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_GrottoB_LightSensorTriggerAnim : HAGIS
{
	private enum AnimState
	{
		REST,
		OPENING,
		CLOSING
	}

	private AnimState state;

	public IDObjectRef[] lightSensorRef;

	public IDObjectRef triggerRef;

	public Region connectionRegion;

	public bool bInvertSensor;

	private List<LightSensor> lightSensor = new List<LightSensor>();

	private Animation anim;

	private Trigger trigger;

	private FMOD.Studio.EventInstance moveSoundInstance;

	public string animationName;

	public FMODEventAsset moveSoundAsset;

	public Vector3 moveSoundSourcePos;

	private IHaglet<bool> sensorAnim;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		Haglet.Create(out sensorAnim, (Routine.Func1<bool>)SensorAnim, (string)null, startNow: false, (int?)null, (string)null);
		for (int i = 0; i < lightSensorRef.Length; i++)
		{
			lightSensor.Add(LR.Inst.GetIDObjectComponent<LightSensor>(lightSensorRef[i]));
		}
		LR.Inst.TryGetIDObjectComponent<Trigger>(triggerRef, out trigger);
		anim = GetComponent<Animation>();
		anim[animationName].enabled = true;
		anim[animationName].speed = 0f;
		anim[animationName].weight = 1f;
		anim[animationName].normalizedTime = 0f;
		while (true)
		{
			bool flag = false;
			if (!trigger || !trigger.IsInsideBool)
			{
				for (int j = 0; j < lightSensor.Count; j++)
				{
					if (lightSensor[j].isReceivingLight.value)
					{
						flag = true;
						break;
					}
				}
				bool flag2 = (bInvertSensor ? (!flag) : flag);
				if (flag2 && state != AnimState.OPENING && anim[animationName].normalizedTime != 1f)
				{
					sensorAnim.Start(arg0: true, resetIfStarted: true);
				}
				else if (!flag2 && state != AnimState.CLOSING && anim[animationName].normalizedTime != 0f)
				{
					sensorAnim.Start(arg0: false, resetIfStarted: true);
				}
			}
			yield return Wait.For.LRUpdates(1);
		}
	}

	private IEnumerator<Routine.Yield> SensorAnim(bool opening)
	{
		state = (opening ? AnimState.OPENING : AnimState.CLOSING);
		float time = anim[animationName].time;
		float targetTime = (opening ? anim[animationName].length : 0f);
		float timeOffset = Mathf.Abs(targetTime - time);
		float timer = 0f;
		if (connectionRegion != null && !opening && connectionRegion.IsEnabled)
		{
			connectionRegion.Disable();
		}
		if (!moveSoundInstance.isValid() && moveSoundAsset != null)
		{
			moveSoundInstance = FAC.Inst.PlayOneShot(moveSoundAsset, base.transform.TransformPoint(moveSoundSourcePos));
		}
		while (timer < timeOffset)
		{
			yield return Wait.For.Updates(1);
			timer += IC.DeltaTime;
			anim[animationName].enabled = true;
			anim[animationName].speed = 0f;
			anim[animationName].weight = 1f;
			anim[animationName].time = Mathf.Lerp(time, targetTime, timer / timeOffset);
		}
		if (moveSoundInstance.isValid())
		{
			moveSoundInstance.stop(STOP_MODE.IMMEDIATE);
		}
		anim[animationName].normalizedTime = (opening ? 1f : 0f);
		if (connectionRegion != null && opening && !connectionRegion.IsEnabled)
		{
			connectionRegion.Enable();
		}
		state = AnimState.REST;
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}

	private void OnDrawGizmos()
	{
		if (!(moveSoundAsset == null))
		{
			Gizmos.matrix = Matrix4x4.TRS(base.transform.position, base.transform.rotation, base.transform.lossyScale);
			Gizmos.color = Color.red;
			Gizmos.DrawSphere(moveSoundSourcePos, 0.1f);
		}
	}
}
public class HAGIS_GrottoB_TurnOffTelepoint : HAGIS
{
	public PuzzleInfo puzzle;

	public GameObject telepoint;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return Wait.For.LRUpdates(1);
		yield return WaitForPuzzle(puzzle);
		telepoint.SetActive(value: false);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
[RequireComponent(typeof(Animation))]
public class HAGIS_GrottoB_WoodChipper : HAGIS
{
	public IDObjectRef lightSensorRef;

	public IDObjectRef rasterizerPieceRef;

	public string litAnim;

	public Animation boardAnimation;

	public FMODEventAsset boardSound;

	private Animation anim;

	private LightSensor lightSensor;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		lightSensor = LR.Inst.GetIDObjectComponent<LightSensor>(lightSensorRef);
		GrabObject rasterizerPiece = LR.Inst.GetIDObject<GrabObject>(rasterizerPieceRef);
		bool rasterizerPieceInitialState = rasterizerPiece.gameObject.activeSelf;
		rasterizerPiece.gameObject.SetActive(value: false);
		anim = GetComponent<Animation>();
		bool animPlayed = false;
		while (!animPlayed)
		{
			if (lightSensor.isReceivingLight.value || Routine.Skipping)
			{
				HAGIS.PlayAnim(anim, litAnim);
				yield return Wait.For.Seconds(4f);
				animPlayed = true;
				FAC.Inst.PlayOneShot(boardSound, boardAnimation.transform.position);
				yield return HAGIS.PlayAnim(boardAnimation, "AN_GrottoB_Rasteriser_01");
				boardAnimation.gameObject.SetActive(value: false);
				if (Routine.Skipping)
				{
					rasterizerPiece.gameObject.SetActive(rasterizerPieceInitialState);
				}
				else
				{
					rasterizerPiece.gameObject.SetActive(value: true);
				}
			}
			yield return Wait.For.LRUpdates(1);
		}
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
[Serializer.ExcludeAllFields]
public abstract class HAGIS : MonoBehaviour, IAreaEvent, IOwnerChangeListener
{
	[HideInInspector]
	public MRBase owner;

	private string editorGroup;

	private bool hasStarted;

	[HideInInspector]
	public IHaglet onLogic;

	public IHaglet onLogicBase;

	[SerializeField]
	private bool shouldSave = true;

	[SerializeField]
	private bool checkpointOnComplete = true;

	[HideInInspector]
	public bool resuming;

	[Serializer.IncludeField]
	private int checkpointCount;

	protected int resumeCount;

	public virtual bool ShouldSave => shouldSave;

	protected int CheckpointCount => checkpointCount;

	public void Start()
	{
	}

	public void OnAwakeLR(MRBase owner)
	{
		this.owner = owner;
		if (SetDebugVisibilty())
		{
			editorGroup = "Hagis";
		}
		else
		{
			editorGroup = "Default";
		}
		Haglet.Create(out onLogic, OnLogic, base.gameObject.name + ": " + GetType().Name, startNow: false, null, editorGroup);
		Haglet.Create(out onLogicBase, OnLogicBase, base.gameObject.name + ": " + GetType().Name, startNow: false, null, editorGroup);
		OnHagisAwake();
	}

	public virtual void OnLoadLR(MRBase owner)
	{
		if (IgnoreAreaEvents())
		{
			onLogicBase.Start();
		}
	}

	protected virtual void OnHagisAwake()
	{
	}

	protected virtual void OnHagisDestroyed()
	{
	}

	protected virtual bool SetDebugVisibilty()
	{
		return true;
	}

	public Routine.Yield CHECKPOINT()
	{
		if (resuming)
		{
			resumeCount++;
			if (resumeCount == checkpointCount)
			{
				resuming = false;
				return Routine.Yield.SpecialIndex.StopCallStackSkipping;
			}
			return Wait.None;
		}
		if (ShouldSave)
		{
			checkpointCount++;
		}
		return Routine.Yield.SpecialIndex.StopCallStackSkipping;
	}

	public Wait Save()
	{
		if (!resuming)
		{
			return LR.Inst.Save();
		}
		return Wait.PreMet;
	}

	public void OnDestroy()
	{
		OnHagisDestroyed();
		if (onLogicBase != null && onLogicBase.started)
		{
			onLogicBase.Stop();
		}
		OnDestroyCalled();
	}

	public virtual void OnDestroyCalled()
	{
	}

	public IEnumerator<Routine.Yield> OnLogicBase()
	{
		hasStarted = true;
		if (ShouldSave && resumeCount != checkpointCount)
		{
			resuming = true;
			Routine.Skip();
		}
		yield return onLogic.Call(1, reset: true, resuming);
		if (checkpointOnComplete)
		{
			yield return CHECKPOINT();
		}
	}

	[Event(EventName = "Trigger")]
	public void Trigger(object sender)
	{
		onLogic.Trigger();
	}

	public abstract IEnumerator<Routine.Yield> OnLogic();

	public virtual bool IgnoreAreaEvents()
	{
		return onLogicBase == null;
	}

	void IAreaEvent.OnAreaEnter()
	{
		if (IgnoreAreaEvents())
		{
			return;
		}
		if (!onLogicBase.started && !hasStarted)
		{
			hasStarted = true;
			onLogicBase.Start();
		}
		else if (onLogicBase.paused)
		{
			onLogicBase.Resume();
			if (onLogic.paused)
			{
				onLogic.Resume();
			}
		}
	}

	void IAreaEvent.OnAreaExit()
	{
		if (!IgnoreAreaEvents() && onLogicBase.started)
		{
			onLogicBase.Pause();
			if (onLogic.started)
			{
				onLogic.Pause();
			}
		}
	}

	void IOwnerChangeListener.OnOwnerChange(MRBase _oldOwner, MRBase _newOwner)
	{
		MRBase.TransferObject(_oldOwner, _newOwner, this);
		owner = _newOwner;
	}

	protected Wait WaitForPuzzle(PuzzleInfo info)
	{
		return info.UntilComplete(SaveDataGame.PuzzleSaveType.Scene);
	}

	protected Wait WaitForPuzzles(PuzzleInfo[] infos)
	{
		Wait none = Wait.None;
		for (int i = 0; i < infos.Length; i++)
		{
			none &= WaitForPuzzle(infos[i]);
		}
		return none;
	}

	public static Wait PlayAnim(Animation _anim, string _clipName = "", float blendTime = 0f)
	{
		return AnimationX.PlayAnim(_anim, _clipName, blendTime);
	}
}
public class HAGIS_BatteryLight_Toggle : HAGIS
{
	public GameObject redLight;

	public GameObject greenLight;

	private PlacementHelper helper;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		helper = GetComponent<PlacementHelper>();
		redLight.SetActive(value: true);
		greenLight.SetActive(value: false);
		yield return CHECKPOINT();
		yield return Wait.UntilTriggered;
		yield return CHECKPOINT();
		redLight.SetActive(value: false);
		greenLight.SetActive(value: true);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_EnableAfterChapterComplete : HAGIS
{
	public SaveDataGame.Chapter checkChapter;

	public GameObject objectToControl;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		objectToControl.SetActive(value: false);
		while (!LR.Inst.saveDataGame.IsChapterMaskCompleteAny(checkChapter))
		{
			yield return Wait.For.Updates(1);
		}
		objectToControl.SetActive(value: true);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_Hub_Mainflow : HAGIS
{
	public IDObjectRef princessMachineRef;

	public IDObjectRef hunterMachineRef;

	public IDObjectRef stargazingMachineRef;

	public IDObjectRef escapeMachineRef;

	public IDObjectRef evilgateMachineRef;

	public IDObjectRef insanityMachineRef;

	public IDObjectRef deathMachineRef;

	public IDObjectRef firstmeetingMachineRef;

	public HAGIS_Hub_ProgressDoor milestoneDoorObs;

	public HAGIS_Hub_ProgressDoor milestoneDoorGallery;

	public HAGIS_Hub_ProgressDoor milestoneDoorDarkRoom;

	public HAGIS_Hub_ProgressDoor milestoneDoorTelescope;

	public BreakerSwitch breakerSwitch;

	public Animation cableCarAnimation;

	public Region cableCarConnectRegion;

	public IDObjectRef cableCarFunctionalityRef;

	public IDObjectRef cableCarRegionRef;

	public IDObjectRef cableCarConnectionRegionRef;

	private Wait IsComplete(SaveDataGame.Chapter c)
	{
		return Wait.Until.True(() => LR.Inst.saveDataGame.IsChapterMaskCompleteAll(c));
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		AnimationX.PlayAnim(cableCarAnimation, "", 0f, instant: true);
		cableCarConnectRegion.Disable();
		princessMachineRef.GetComponent<PortalMachine>();
		PortalMachine hunterPM = hunterMachineRef.GetComponent<PortalMachine>();
		PortalMachine stargazingPM = stargazingMachineRef.GetComponent<PortalMachine>();
		PortalMachine escapePM = escapeMachineRef.GetComponent<PortalMachine>();
		PortalMachine evilgatePM = evilgateMachineRef.GetComponent<PortalMachine>();
		PortalMachine insanityPM = insanityMachineRef.GetComponent<PortalMachine>();
		PortalMachine deathPM = deathMachineRef.GetComponent<PortalMachine>();
		PortalMachine firstmeetingPM = firstmeetingMachineRef.GetComponent<PortalMachine>();
		ConstructTransporter constructLever = GetComponentInChildren<ConstructTransporter>();
		FixedRotatableObject breakerSwitchFixedRotatable = breakerSwitch.GetComponentInChildren<FixedRotatableObject>();
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		yield return LR.Inst.IsAllConnectedScenesUnloaded;
		hunterPM.HasPower = false;
		stargazingPM.HasPower = false;
		escapePM.HasPower = false;
		evilgatePM.HasPower = false;
		insanityPM.HasPower = false;
		deathPM.HasPower = false;
		firstmeetingPM.HasPower = false;
		firstmeetingPM.lockedByPuzzles = false;
		constructLever.SetPowered(powered: false);
		yield return CHECKPOINT();
		yield return IsComplete(SaveDataGame.firstMilestoneUnlockMask);
		LR.Inst.GetIDObject<IDObject>(cableCarFunctionalityRef).gameObject.SetActive(value: false);
		LR.Inst.GetIDObjectComponent<Region>(cableCarRegionRef).Disable();
		LR.Inst.GetIDObjectComponent<Region>(cableCarConnectionRegionRef).Disable();
		yield return CHECKPOINT();
		yield return breakerSwitch.isPowerOn;
		yield return CHECKPOINT();
		milestoneDoorObs.doorUnlocked.value = true;
		milestoneDoorGallery.doorUnlocked.value = true;
		milestoneDoorDarkRoom.doorUnlocked.value = true;
		yield return Save();
		hunterPM.HasPower = true;
		stargazingPM.HasPower = true;
		escapePM.HasPower = true;
		breakerSwitchFixedRotatable.enabled = false;
		breakerSwitch.enabled = false;
		firstmeetingPM.lockedByPuzzles = true;
		firstmeetingPM.SetDisplay(BaseSettings<PortalSettings>.Inst.puzzles);
		firstmeetingPM.UpdatePuzzlePips();
		yield return IsComplete(SaveDataGame.secondMilestoneUnlockMask);
		yield return CHECKPOINT();
		evilgatePM.HasPower = true;
		insanityPM.HasPower = true;
		deathPM.HasPower = true;
		milestoneDoorTelescope.doorUnlocked.value = true;
		yield return Routine.Yield.SpecialIndex.StopSkipping;
		yield return IsComplete(SaveDataGame.thirdMilsetoneUnlockMask);
		yield return CHECKPOINT();
		firstmeetingPM.HasPower = true;
		firstmeetingPM.UpdatePuzzlePips();
		firstmeetingPM.lockedByPuzzles = false;
		yield return Routine.Yield.SpecialIndex.StopSkipping;
		yield return IsComplete(SaveDataGame.fourthMilestoneUnlockMask);
		yield return CHECKPOINT();
		constructLever.SetPowered(powered: true);
		yield return Routine.Yield.SpecialIndex.StopSkipping;
	}
}
public class HAGIS_Hub_ProgressDoor : HAGIS
{
	public enum ProgressDoorType
	{
		Planetarium,
		Gallery,
		DarkRoom,
		Telescope,
		MAX
	}

	public ProgressDoorType thisDoorType;

	public FMODEventAsset doorSound;

	public Animation doorAnim;

	public PlayerAreaTrigger areaTrigger;

	public Region doorRegion;

	public HagletValue<bool> doorUnlocked;

	protected override void OnHagisAwake()
	{
		base.OnHagisAwake();
		HagletValue.Create(out doorUnlocked, null, initVal: false, null, 8);
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		if (!LR.Inst.saveDataGame.progressDoors[(int)thisDoorType])
		{
			doorRegion.Disable();
			yield return Wait.Until.True(doorUnlocked, 1, allowPreMetNow: true);
			yield return areaTrigger.OnHeadInside;
			doorRegion.Enable();
			FAC.Inst.PlayOneShot(doorSound, base.transform.position);
			doorAnim.Play();
			LR.Inst.saveDataGame.progressDoors[(int)thisDoorType] = true;
			yield return Save();
		}
		else
		{
			AnimationX.PlayAnim(doorAnim, "", 0f, instant: true);
		}
	}
}
public class HAGIS_GameObjectToggleOnTriggerEnter : HAGIS
{
	public PlayerAreaTrigger TriggerToEnter;

	public GameObject GameObjToTurnOff;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		bool IsInside = TriggerToEnter.IsHeadInsideBool;
		GameObjToTurnOff.SetActive(value: false);
		yield return Wait.For.Updates(0);
		while (IsInside)
		{
			GameObjToTurnOff.SetActive(value: true);
		}
	}
}
public class HAGIS_Observatory_A_MainFlow : HAGIS
{
	public PuzzleInfo puzzle1;

	public PuzzleInfo puzzle2;

	public Doorway doorway;

	public Region preCutScene;

	public Region postCutScene;

	public FMODEventAsset music;

	public HAGIS_Simple_Cutscene cutScene;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		postCutScene.Disable();
		LR.Inst.SetMusic(music);
		yield return Wait.For.Seconds(0f);
		yield return WaitForPuzzle(puzzle1) & WaitForPuzzle(puzzle2);
		doorway.Open();
		LR.Inst.StopMusic();
		yield return cutScene.IsComplete;
		postCutScene.Enable();
		preCutScene.Disable();
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_Observatory_A_Obelisk : HAGIS
{
	public Region thirdFloorRegion;

	public GameObject idleVoTrigger;

	public GameObject voTriggersParent;

	public Portal portal;

	public HAGIS_Simple_Cutscene cutscene;

	public PuzzleInfo[] mainPuzzles;

	public FMODEventAsset music;

	public Trigger musicTrigger;

	public Doorway exitDoor;

	public FrustumDetector3D exitDoorFrustum;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		portal.SetUnlockedState(unlocked: false);
		idleVoTrigger.gameObject.SetActive(value: false);
		thirdFloorRegion.Disable();
		yield return musicTrigger.OnInsidePremet;
		LR.Inst.SetMusic(music);
		yield return WaitForPuzzles(mainPuzzles);
		LR.Inst.StopMusic();
		yield return exitDoorFrustum.IsInView;
		exitDoor.Open();
		thirdFloorRegion.Enable();
		idleVoTrigger.gameObject.SetActive(value: true);
		yield return cutscene.IsTriggered;
		portal.typeSettings.portalRange = 12;
		yield return Wait.For.Seconds(61f);
		portal.SetUnlockedState(unlocked: true);
		yield return cutscene.IsComplete;
		voTriggersParent.SetActive(value: false);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_Observatory_A_PuzzleFlow : HAGIS
{
	public PuzzleInfo[] puzzles;

	public LightSource lightSource;

	public GameObject telepoint;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return Wait.For.LRUpdates(1);
		yield return WaitForPuzzles(puzzles);
		lightSource.DisableLight();
		telepoint.SetActive(value: false);
	}
}
public class HAGIS_ObservatoryA_AnimControl : HAGIS
{
	public GameObject midLorna;

	public GameObject topLorna;

	public PlayerAreaTrigger areaTrig;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		topLorna.SetActive(value: false);
		yield return areaTrig.OnHeadInside;
		topLorna.SetActive(value: true);
		midLorna.SetActive(value: false);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_ObservatoryA_HideChains : HAGIS
{
	public GameObject[] chains;

	public PlayerAreaTrigger headCheck;

	private bool isActive;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		while (true)
		{
			if (headCheck.IsInsideBool && isActive)
			{
				GameObject[] array = chains;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].SetActive(value: false);
					isActive = false;
				}
			}
			else if (!headCheck.IsInsideBool && !isActive)
			{
				GameObject[] array = chains;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].SetActive(value: true);
					isActive = true;
				}
			}
			yield return Wait.For.Updates(1);
		}
	}
}
public class HAGIS_ObservatoryA_LornaSwitch : HAGIS
{
	public GameObject secondFloorLorna;

	public GameObject thirdFloorLorna;

	public PlayerAreaTrigger[] areaTriggers;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		secondFloorLorna.SetActive(value: true);
		thirdFloorLorna.SetActive(value: false);
		Wait none = Wait.None;
		for (int i = 0; i < areaTriggers.Length; i++)
		{
			none |= areaTriggers[i].OnHeadInside;
		}
		yield return none;
		UnityEngine.Debug.Log("Lets Switch Lorna");
		secondFloorLorna.SetActive(value: false);
		thirdFloorLorna.SetActive(value: true);
	}
}
public class HAGIS_ObservatoryA_VOandLights : HAGIS
{
	public Trigger bottomFloor;

	public Trigger middleFloor;

	public Light[] LowerLights = new Light[4];

	public Light[] UpperLights = new Light[4];

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		while (true)
		{
			yield return bottomFloor.OnInside;
			Light[] lowerLights = LowerLights;
			foreach (Light light in lowerLights)
			{
				if (!light.isActiveAndEnabled)
				{
					light.enabled = true;
				}
			}
			yield return bottomFloor.OnOutside;
			for (int j = 0; j < LowerLights.Length; j++)
			{
				if (!LowerLights[j].enabled)
				{
					LowerLights[j] = null;
				}
				else if (LowerLights[j] != null)
				{
					LowerLights[j].enabled = false;
				}
			}
			yield return middleFloor.OnInside;
			lowerLights = UpperLights;
			foreach (Light light2 in lowerLights)
			{
				if (!light2.isActiveAndEnabled)
				{
					light2.enabled = true;
				}
			}
			yield return middleFloor.OnOutside;
			for (int k = 0; k < UpperLights.Length; k++)
			{
				if (!UpperLights[k].enabled)
				{
					UpperLights[k] = null;
				}
				else if (UpperLights[k] != null)
				{
					UpperLights[k].enabled = false;
				}
			}
			yield return Wait.For.LRUpdates(1);
		}
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_ObservatoryB_Main : HAGIS
{
	public IDObjectRef portalRef;

	[Header("Doors to Open")]
	public Doorway groundFloorDoor;

	[Header("Puzzle 1 and 2")]
	public PuzzleInfo puzzle1;

	public PuzzleInfo puzzle2;

	public IDObjectRef lightSourceP1P2MainRef;

	public IDObjectRef lightSourceP1P2AltRef;

	public IDObjectRef doorGroundAltSceneRef;

	[Header("Puzzle 3")]
	public PuzzleInfo puzzle3;

	public IDObjectRef lightSourceP3MainRef;

	public IDObjectRef lightSourceP3AltRef;

	public IDObjectRef telepointP3Ref;

	public IDObjectRef doorTopAltSceneRef;

	[Header("Music")]
	public IDObjectRef grabPortal;

	public FMODEventAsset grabMusic;

	public IDObjectRef roofRegionRef;

	public IDObjectRef roofRegionAltRef;

	public FMODEventAsset roofMusic;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		LR.Inst.GetIDObject<Portal>(portalRef);
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		Doorway doorGroundAltScene = LR.Inst.GetIDObjectComponent<Doorway>(doorGroundAltSceneRef);
		Doorway doorTopAltScene = LR.Inst.GetIDObjectComponent<Doorway>(doorTopAltSceneRef);
		LightSource lightSourceP1P2Main = LR.Inst.GetIDObjectComponent<LightSource>(lightSourceP1P2MainRef);
		LightSource lightSourceP1P2Alt = LR.Inst.GetIDObjectComponent<LightSource>(lightSourceP1P2AltRef);
		LightSource lightSourceP3Main = LR.Inst.GetIDObjectComponent<LightSource>(lightSourceP3MainRef);
		LightSource lightSourceP3Alt = LR.Inst.GetIDObjectComponent<LightSource>(lightSourceP3AltRef);
		lightSourceP3Main.DisableLight();
		lightSourceP3Alt.DisableLight();
		Region roofRegion = LR.Inst.GetIDObjectComponent<Region>(roofRegionRef);
		Region roofRegionAlt = LR.Inst.GetIDObjectComponent<Region>(roofRegionAltRef);
		GameObject telepointP3 = LR.Inst.GetIDObjectComponent<IDObject>(telepointP3Ref).gameObject;
		yield return Wait.For.LRUpdates(1);
		if (!puzzle1.IsComplete(SaveDataGame.PuzzleSaveType.Scene) || !puzzle2.IsComplete(SaveDataGame.PuzzleSaveType.Scene))
		{
			GrabObject component = grabPortal.GetComponent<GrabObject>();
			yield return component.OnObjectGrabbed | component.OnObjectFocusGrabbed;
			LR.Inst.SetMusic(grabMusic);
			yield return WaitForPuzzle(puzzle1) & WaitForPuzzle(puzzle2);
		}
		lightSourceP1P2Main.DisableLight();
		lightSourceP1P2Alt.DisableLight();
		lightSourceP3Main.EnableLight();
		lightSourceP3Alt.EnableLight();
		groundFloorDoor.Open();
		doorGroundAltScene.Open();
		LR.Inst.StopMusic();
		yield return Wait.Until.True(() => CC.Inst.CurrentRegion == roofRegion || CC.Inst.CurrentRegion == roofRegionAlt);
		LR.Inst.SetMusic(roofMusic);
		yield return WaitForPuzzle(puzzle3);
		lightSourceP3Main.DisableLight();
		lightSourceP3Alt.DisableLight();
		doorTopAltScene.Open();
		telepointP3.SetActive(value: false);
		LR.Inst.StopMusic();
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_ObservatoryB_P1_P2 : HAGIS
{
	public PuzzleInfo puzzle;

	public GameObject telepoint;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return Wait.For.LRUpdates(1);
		yield return WaitForPuzzle(puzzle);
		telepoint.SetActive(value: false);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_ObservatoryB_VoControl : HAGIS
{
	public PlayerAreaTrigger areaTrig;

	public PlayerAreaTrigger firstTrig;

	public float secondsToWait;

	public IDObjectRef otherSceneTriggerRef;

	private PlayerAreaTrigger otherSceneTrigger;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		areaTrig.gameObject.SetActive(value: false);
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		otherSceneTrigger = LR.Inst.GetIDObjectComponent<PlayerAreaTrigger>(otherSceneTriggerRef);
		yield return firstTrig.OnInside;
		while (!otherSceneTrigger.IsInsideBool && !resuming)
		{
			yield return Wait.For.Seconds(secondsToWait);
			areaTrig.gameObject.SetActive(value: true);
		}
		areaTrig.gameObject.SetActive(value: false);
	}
}
public class HAGIS_Prototype_MirrorMovementEffect : HAGIS
{
	public AnimationCurve speedCurve;

	public IDObjectRef grabObjRef;

	private GrabObject grabObj;

	private IHaglet controlRoutine;

	private IHaglet moveRoutine;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		grabObj = LR.Inst.GetIDObjectComponent<GrabObject>(grabObjRef);
		Haglet.Create(out controlRoutine, ControlRoutine);
		Haglet.Create(out moveRoutine, MoveRoutine);
		yield break;
	}

	public void StartMovement()
	{
		Vector3 closestPointOnPortal = Portal.FindClosestMirror(owner.portals, grabObj.transform.position).GetClosestPointOnPortal(grabObj.transform.position);
		grabObj.transform.position = closestPointOnPortal;
		controlRoutine.Start();
	}

	private IEnumerator<Routine.Yield> ControlRoutine()
	{
		moveRoutine.Start();
		yield return grabObj.OnObjectGrabbed;
		moveRoutine.Stop();
	}

	private IEnumerator<Routine.Yield> MoveRoutine()
	{
		float time = 1f;
		float directionMod = 1f;
		while (true)
		{
			time += IC.DeltaTime;
			if (time > 3f)
			{
				time -= 3f;
				directionMod *= -1f;
			}
			float num = speedCurve.Evaluate(time);
			grabObj.transform.position -= grabObj.transform.forward * directionMod * num * IC.DeltaTime;
			yield return Wait.For.LRUpdates(1);
		}
	}
}
public class HAGIS_Prototype_MirrorRipple : MonoBehaviour, IPostPhysicsUpdateEvent
{
	private static readonly int _PORTAL_ID = Shader.PropertyToID("_PORTAL_ID");

	private static readonly int _Shockwave = Shader.PropertyToID("_Shockwave");

	private static readonly int _DistanceOptions = Shader.PropertyToID("_DistanceOptions");

	public GameObject rippleGO;

	private Portal connectedMirror;

	private GrabObject targetGO;

	private MaterialPropertyBlock rippleMPB;

	private MeshRenderer rippleMR;

	private FMOD.Studio.EventInstance evtRipple;

	private FMOD.Studio.EventInstance evtRippleInvert;

	private float rippleSize;

	public void OnAwakeLR(Portal mirror)
	{
		rippleMR = rippleGO.GetComponent<MeshRenderer>();
		rippleMPB = new MaterialPropertyBlock();
		connectedMirror = mirror;
		rippleGO.transform.rotation = mirror.transform.rotation;
		rippleMR.material.SetInt(_PORTAL_ID, mirror.PortalCamera.PUID);
		UnassignTarget();
	}

	public void AssignRippleTarget(GrabObject target)
	{
		targetGO = target;
		Bounds encapsulatingRendererBounds = targetGO.pr.GetEncapsulatingRendererBounds();
		base.transform.SetParent(targetGO.transform);
		base.transform.position = encapsulatingRendererBounds.center;
		base.gameObject.SetActive(value: true);
		rippleGO.SetActive(value: true);
		rippleSize = encapsulatingRendererBounds.size.magnitude;
		rippleGO.transform.localScale = Vector3X.one * rippleSize;
	}

	public GrabObject CurrentTarget()
	{
		return targetGO;
	}

	public void UnassignTarget()
	{
		targetGO = null;
		base.transform.SetParent(connectedMirror.transform.parent);
		rippleGO.transform.localScale = Vector3X.one;
		base.gameObject.SetActive(value: false);
		rippleGO.SetActive(value: false);
		evtRipple.stop(STOP_MODE.ALLOWFADEOUT);
		evtRippleInvert.stop(STOP_MODE.ALLOWFADEOUT);
	}

	void IPostPhysicsUpdateEvent.OnPostPhysicsUpdateLR()
	{
	}

	private void LateUpdate()
	{
		if ((bool)rippleMR)
		{
			rippleMR.material.SetInt(_PORTAL_ID, connectedMirror.PortalCamera.PUID);
		}
	}
}
public class HAGIS_Station_Mainflow : HAGIS
{
	private struct HackyRoutineStuct
	{
		public Region cableCarTwoRegion;

		public Region cableCarTwoDoorRegion;

		public Animation cableCarTwoAnim;

		public Animation cableCarTwoDoorAnim;

		public string cableCarTwoDoorAnimOpenName;

		public FMODEventAsset cableCarSound;

		public Collider[] cableCarTwoColliders;

		public HackyRoutineStuct(Region cableCarTwoRegion, Region cableCarTwoDoorRegion, Animation cableCarTwoAnim, Animation cableCarTwoDoorAnim, string cableCarTwoDoorAnimOpenName, Collider[] cableCarTwoColliders, FMODEventAsset cableCarSound)
		{
			this.cableCarTwoRegion = cableCarTwoRegion;
			this.cableCarTwoDoorRegion = cableCarTwoDoorRegion;
			this.cableCarTwoAnim = cableCarTwoAnim;
			this.cableCarTwoDoorAnim = cableCarTwoDoorAnim;
			this.cableCarTwoDoorAnimOpenName = cableCarTwoDoorAnimOpenName;
			this.cableCarTwoColliders = cableCarTwoColliders;
			this.cableCarSound = cableCarSound;
		}
	}

	public IDObjectRef grabObjectIDRef;

	public IDObjectRef grabObjectLetterRef;

	public IDObjectRef grabObjectJournalRef;

	public string voJournal;

	[Space]
	public Animation letterAnim;

	public string letterAnimName;

	[Space]
	public Region staffDoorRegion;

	public Animation staffDoorAnim;

	public Transform stationDoorTransform;

	public Transform stationMountainTransform;

	public FMODEventAsset soundOpening;

	public PlayerAreaTrigger doorTrigger;

	public VO_Asset voArrival;

	public FMODEventAsset soundPowerUp;

	public HagletTrigger leverPulled = new HagletTrigger();

	public HAGIS_Station_StationLever leverHagis;

	public FMODEventRef soundEarthquake;

	public FMODEventAsset soundPullyWheel;

	public FMODEventAsset soundCableCar;

	public Transform pullyWheelCenter;

	[Space]
	public VO_Asset voGondolaArrives;

	public VO_Asset voGondola;

	public Animation gondolaAnim;

	public Animation gondolaDoorAnim;

	public Station_GondolaFlappyController gondolaFlappyController;

	public string gondolaDoorShakeAnimName;

	public string gondolaDoorOpenAnimName;

	public string gondolaDoorCloseAnimName;

	public Collider[] outOfBoundsCollision;

	public string gondolaEnterAnimName;

	public string gondolaExitAnimName;

	public string gondolaIdleAnimName;

	public Animation doorsAnim;

	public Region gondolaDoorRegion;

	public Region gondolaRegion;

	public PlayerAreaTrigger gondolaTrigger;

	[Space]
	public Animation[] gondolaPulleyAnims;

	public string gondolaPulleyAnimStartUpEnter;

	public string gondolaPulleyAnimSpinEnter;

	public string gondolaPulleyAnimEndEnter;

	public string gondolaPulleyAnimStartUp;

	public string gondolaPulleyAnimSpin;

	public string gondolaPulleyAnimEnd;

	[Space]
	public FMODEventAsset soundGondolaArrives;

	public VO_Asset voGondolaLeaving;

	[Space]
	public VO_Asset voGondolaWarnings;

	public float gondolaWarningMinTime = 3f;

	public float gondolaWarningMaxTime = 10f;

	public float gondolaWarningIncrement = 1f;

	[Space]
	public float secretEndingTimeWarning;

	public VO_Asset voSecretEndingWarning;

	public float secretEndingTimeFinal;

	public VO_Asset voSecretEndingFinal;

	private float endingTimer;

	[Space]
	public IDObjectRef cableCarTwoRef;

	public IDObjectRef cableCarTwoAnimRef;

	private Animation cableCarTwoAnim;

	public string cableCarTwoAnimName;

	public IDObjectRef cableCarTwoDoorAnimRef;

	private Animation cableCarTwoDoorAnim;

	public string cableCarTwoDoorAnimName;

	public IDObjectRef cableCarTwoRegionRef;

	public IDObjectRef cableCarTwoDoorRegionRef;

	private Region cableCarTwoRegion;

	private Region cableCarTwoDoorRegion;

	private Collider[] cableCarTwoColliders;

	public IDObjectRef cableCarTwoCollisionRef;

	[Space]
	public string[] cutsceneOneAnimName;

	public float[] cutsceneOneAnimDelay;

	public string[] cutsceneTwoAnimName;

	public float[] cutsceneTwoAnimDelay;

	private IHaglet<GrabObject, InventoryStoryItem>[] storyItemRoutines;

	private IHaglet<bool> routineDoorDelayedAnimation;

	private IHaglet<HackyRoutineStuct, Vector3, Quaternion> routinePostScene;

	private IHaglet routineGondolaWarning;

	private IHaglet routineSecretEnding;

	private IHaglet<bool> routineGondolaPulleyAnim;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		Haglet.Create(out routineGondolaWarning, RoutineGondolaWarning);
		Haglet.Create(out routineSecretEnding, RoutineSecretEnding);
		Haglet.Create(out routinePostScene, (Routine.Func3<HackyRoutineStuct, Vector3, Quaternion>)RoutinePostScene, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out routineDoorDelayedAnimation, (Routine.Func1<bool>)RoutineDoorDelayedAnimation, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out routineGondolaPulleyAnim, (Routine.Func1<bool>)RoutineGondolaPulleyAnim, (string)null, startNow: false, (int?)null, (string)null);
		storyItemRoutines = new IHaglet<GrabObject, InventoryStoryItem>[3];
		for (int i = 0; i < 3; i++)
		{
			Haglet.Create(out storyItemRoutines[i], (Routine.Func2<GrabObject, InventoryStoryItem>)AddStoryItemRoutine, (string)null, startNow: false, (int?)null, (string)null);
		}
		CC cc = CC.Inst;
		staffDoorRegion.Disable();
		gondolaDoorRegion.Disable();
		HAGIS.PlayAnim(gondolaAnim, gondolaIdleAnimName);
		GrabObject grabObjectID = grabObjectIDRef.Get<GrabObject>();
		GrabObject grabObjectLetter = grabObjectLetterRef.Get<GrabObject>();
		GrabObject grabObjectJournal = grabObjectJournalRef.Get<GrabObject>();
		Collider[] array = outOfBoundsCollision;
		for (int j = 0; j < array.Length; j++)
		{
			array[j].enabled = false;
		}
		if (!Routine.Skipping)
		{
			grabObjectJournal.hasBeenGrabbed = false;
			grabObjectID.hasBeenGrabbed = false;
			grabObjectLetter.hasBeenGrabbed = false;
			yield return grabObjectJournal.OnObjectGrabbed;
			VOC.Inst.QueueVO(voJournal);
			storyItemRoutines[0].Start(grabObjectJournal, InventoryStoryItem.JOURNAL);
		}
		if (!Routine.Skipping)
		{
			grabObjectID.canBeGrabbed = true;
			yield return grabObjectID.OnObjectGrabbed;
			FAC.Inst.PlayOneShot(soundEarthquake.Value, stationMountainTransform.position);
			storyItemRoutines[1].Start(grabObjectID, InventoryStoryItem.ID_CARD);
			HAGIS.PlayAnim(letterAnim, letterAnimName);
			yield return Wait.For.Seconds(1.5f);
		}
		if (!Routine.Skipping)
		{
			grabObjectLetter.canBeGrabbed = true;
			yield return grabObjectLetter.OnObjectGrabbed;
			FAC.Inst.PlayOneShot(soundEarthquake.Value, stationMountainTransform.position);
			storyItemRoutines[2].Start(grabObjectLetter, InventoryStoryItem.NOTICE);
			yield return VOC.Inst.IsFree;
		}
		if (Routine.Skipping)
		{
			grabObjectJournal.canBeGrabbed = false;
			grabObjectJournal.gameObject.SetActive(value: false);
			grabObjectID.canBeGrabbed = false;
			grabObjectID.gameObject.SetActive(value: false);
			grabObjectLetter.canBeGrabbed = false;
			grabObjectLetter.gameObject.SetActive(value: false);
		}
		yield return CHECKPOINT();
		yield return Wait.For.Seconds(1.5f);
		staffDoorRegion.Enable();
		HAGIS.PlayAnim(staffDoorAnim);
		yield return doorTrigger.OnHeadInside;
		leverHagis.gondolaEnabled.Trigger();
		FMOD.Studio.EventInstance evtOpening = default(FMOD.Studio.EventInstance);
		FMOD.Studio.EventInstance evtPowerUp = default(FMOD.Studio.EventInstance);
		if (!Routine.Skipping)
		{
			evtPowerUp = FAC.Inst.PlayOneShot(soundPowerUp, leverHagis.transform.position);
			evtOpening = FAC.Inst.PlayOneShot(soundOpening, stationDoorTransform.position);
			routineDoorDelayedAnimation.Start(arg0: true);
			yield return Wait.For.Seconds(9.529f);
			FAC.Inst.PlayOneShot(soundEarthquake.Value, stationMountainTransform.position);
			yield return Wait.For.Seconds(2f);
		}
		yield return CHECKPOINT();
		VO_Asset.VO_Section[] voiceSections;
		if (!Routine.Skipping && !leverHagis.isLeverPulled)
		{
			voiceSections = voArrival.voiceSections;
			foreach (VO_Asset.VO_Section vO_Section in voiceSections)
			{
				for (int k = 0; k < vO_Section.voiceLines.Length; k++)
				{
					VOC.Inst.QueueVO(vO_Section.voiceLines[k].line, VOC.VOQueueProperty.Queue, vO_Section.voiceLines[k].delay, stationDoorTransform);
				}
			}
		}
		if (!leverHagis.isLeverPulled)
		{
			yield return leverPulled;
		}
		evtPowerUp.stop(STOP_MODE.ALLOWFADEOUT);
		if (!Routine.Skipping)
		{
			LR.Inst.saveDataGame.stationLeverPulled = true;
			yield return LR.Inst.Save();
		}
		yield return CHECKPOINT();
		if (!Routine.Skipping)
		{
			VOC.Inst.VOStop(interruption: true);
			if (evtOpening.isValid())
			{
				evtOpening.stop(STOP_MODE.IMMEDIATE);
			}
			float length = gondolaAnim[gondolaEnterAnimName].length;
			HAGIS.PlayAnim(gondolaAnim, gondolaEnterAnimName);
			FAC.Inst.PlayOneShot(soundGondolaArrives, stationDoorTransform.position);
			FMOD.Studio.EventInstance wheelSound = FAC.Inst.PlayOneShot(soundPullyWheel, pullyWheelCenter);
			routineDoorDelayedAnimation.Start(arg0: false, resetIfStarted: true);
			gondolaFlappyController.PlayAmbient();
			routineGondolaPulleyAnim.Start(arg0: true);
			voiceSections = voGondola.voiceSections;
			foreach (VO_Asset.VO_Section vO_Section2 in voiceSections)
			{
				for (int l = 0; l < vO_Section2.voiceLines.Length; l++)
				{
					VOC.Inst.QueueVO(vO_Section2.voiceLines[l].line, VOC.VOQueueProperty.Queue, vO_Section2.voiceLines[l].delay, stationDoorTransform);
				}
			}
			float ropeAnimLength = gondolaFlappyController.hangingRope[gondolaFlappyController.hangingRopeShake].length;
			yield return Wait.For.Seconds(length - ropeAnimLength + 2f);
			wheelSound.setParameterValue("CableCarOperation", 1f);
			gondolaFlappyController.routineShake.Call(arg0: true);
			yield return Wait.For.Seconds(ropeAnimLength - 2f);
		}
		else
		{
			AnimationX.PlayAnim(gondolaAnim, gondolaEnterAnimName, 0f, instant: true);
		}
		HAGIS.PlayAnim(gondolaDoorAnim, gondolaDoorOpenAnimName);
		while (gondolaDoorAnim.isPlaying && !Routine.Skipping)
		{
			yield return Wait.For.LRUpdates(1);
		}
		if (Routine.Skipping)
		{
			AnimationX.PlayAnim(gondolaDoorAnim, gondolaDoorOpenAnimName, 0f, instant: true);
		}
		yield return LR.Inst.Save();
		yield return CHECKPOINT();
		yield return Routine.Yield.SpecialIndex.StopSkipping;
		VOC.Inst.ClearRemainingVO();
		voiceSections = voGondolaArrives.voiceSections;
		foreach (VO_Asset.VO_Section vO_Section3 in voiceSections)
		{
			for (int m = 0; m < vO_Section3.voiceLines.Length; m++)
			{
				VOC.Inst.QueueVO(vO_Section3.voiceLines[m].line, VOC.VOQueueProperty.Queue, vO_Section3.voiceLines[m].delay, stationDoorTransform);
			}
		}
		routineGondolaWarning.Start();
		gondolaDoorRegion.Enable();
		yield return gondolaTrigger.OnInside;
		gondolaDoorRegion.Disable();
		array = outOfBoundsCollision;
		for (int j = 0; j < array.Length; j++)
		{
			array[j].enabled = true;
		}
		yield return AnimationX.PlayAnim(gondolaDoorAnim, gondolaDoorCloseAnimName);
		FAC.Inst.PlayOneShot(soundPullyWheel, pullyWheelCenter);
		FAC.Inst.PlayOneShot(soundCableCar, gondolaRegion.transform.position);
		gondolaFlappyController.routineShake.Start(arg0: false, 16f);
		routineGondolaPulleyAnim.Start(arg0: false, resetIfStarted: true);
		routineGondolaWarning.Stop();
		voiceSections = voGondolaLeaving.voiceSections;
		foreach (VO_Asset.VO_Section vO_Section4 in voiceSections)
		{
			for (int n = 0; n < vO_Section4.voiceLines.Length; n++)
			{
				VOC.Inst.QueueVO(vO_Section4.voiceLines[n].line, VOC.VOQueueProperty.Queue, vO_Section4.voiceLines[n].delay, stationDoorTransform);
			}
		}
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		_ = cableCarTwoRef?.Get<IDObject>().gameObject;
		cableCarTwoRegion = cableCarTwoRegionRef.Get<IDObject>().GetComponent<Region>();
		cableCarTwoDoorRegion = cableCarTwoDoorRegionRef.Get<IDObject>().GetComponent<Region>();
		cableCarTwoAnim = cableCarTwoAnimRef.GetComponent<Animation>();
		cableCarTwoDoorAnim = cableCarTwoDoorAnimRef.GetComponent<Animation>();
		cableCarTwoColliders = cableCarTwoCollisionRef.Get<IDObject>().GetComponentsInChildren<Collider>(includeInactive: true);
		cableCarTwoAnim[cableCarTwoAnimName].enabled = true;
		cableCarTwoAnim[cableCarTwoAnimName].normalizedTime = 0f;
		cableCarTwoAnim[cableCarTwoAnimName].weight = 1f;
		cableCarTwoAnim.Sample();
		cableCarTwoAnim[cableCarTwoAnimName].enabled = false;
		HAGIS.PlayAnim(gondolaAnim, gondolaExitAnimName);
		yield return Wait.For.Seconds(gondolaAnim[gondolaExitAnimName].length - BaseSettings<TutorialSettings>.Inst.titleCardColorFadeInTime);
		PlayerTeleport.TeleportEnabled.Value = false;
		PlayerFreeMove.FreeMoveEnabled.Value = false;
		PlayerFreeMove.FreeTurnEnabled.Value = false;
		PlayerInventory.InventoryEnabled.Value = false;
		IC.Inst.PauseMenuEnabled = false;
		IC.Inst.RecenterEnabled = false;
		yield return cc.WaitForRecenterComplete() & cc.WaitForPositionStackAnimating();
		yield return Wait.For.Updates(1);
		yield return NexusFullScreenPass.Inst.StartFadeToColor(BaseSettings<TutorialSettings>.Inst.titleCardColorFadeInTime, BaseSettings<TutorialSettings>.Inst.titleCardFadeInColorOne);
		TitleCardController.Inst.PlayTitleCard();
		float seconds = BaseSettings<TutorialSettings>.Inst.titleCardPreFadeTime + BaseSettings<TutorialSettings>.Inst.titleCardFadeTime + BaseSettings<TutorialSettings>.Inst.titleCardWhiteStayTime / 2f;
		yield return Wait.For.Seconds(seconds);
		NexusFullScreenPass.Inst.StartFadeToColor(BaseSettings<TutorialSettings>.Inst.titleCardColorFadeBetweenTime, BaseSettings<TutorialSettings>.Inst.titleCardFadeInColorTwo);
		seconds = BaseSettings<TutorialSettings>.Inst.titleCardWhiteStayTime / 2f + BaseSettings<TutorialSettings>.Inst.titleCardFadeTime + BaseSettings<TutorialSettings>.Inst.titleCardPostFadeTime;
		yield return Wait.For.Seconds(seconds);
		if ((bool)cc.handL.InteractableHeld)
		{
			cc.handL.UngrabObject();
		}
		if ((bool)cc.handR.InteractableHeld)
		{
			cc.handR.UngrabObject();
		}
		while (NexusFullScreenPass.Inst.isFadeActive)
		{
			yield return Wait.For.LRUpdates(1);
		}
		HackyRoutineStuct arg = new HackyRoutineStuct(cableCarTwoRegion, cableCarTwoDoorRegion, cableCarTwoAnim, cableCarTwoDoorAnim, gondolaDoorOpenAnimName, cableCarTwoColliders, soundCableCar);
		Vector3 arg2 = gondolaRegion.transform.InverseTransformPoint(cc.transform.position);
		Quaternion arg3 = gondolaRegion.transform.InverseTransformRotation(cc.transform.rotation);
		routinePostScene.Start(arg, arg2, arg3);
	}

	private IEnumerator<Routine.Yield> AddStoryItemRoutine(GrabObject grabObject, InventoryStoryItem storyItem)
	{
		float time = 0f;
		for (float timeMax = BaseSettings<InventorySettings>.Inst.storyItemPoofDelay; time < timeMax; time += IC.DeltaTime)
		{
			yield return Wait.For.LRUpdates(1);
			if (!CC.Inst.IsObjectGrabbedOrFocusGrabbed(grabObject) || Routine.Skipping)
			{
				break;
			}
		}
		grabObject.ForceBreak();
		yield return Wait.For.Seconds(BaseSettings<InventorySettings>.Inst.storyItemShowDelay);
		PlayerInventory.Inst.AddStoryItem(storyItem);
	}

	private IEnumerator<Routine.Yield> RoutineDoorDelayedAnimation(bool cutsceneSectionOne)
	{
		if (cutsceneSectionOne)
		{
			yield return Wait.For.Seconds(cutsceneOneAnimDelay[0]);
			HAGIS.PlayAnim(doorsAnim, cutsceneOneAnimName[0]);
			for (int i = 1; i < cutsceneOneAnimName.Length; i++)
			{
				yield return Wait.For.Seconds(cutsceneOneAnimDelay[i] - cutsceneOneAnimDelay[i - 1]);
				HAGIS.PlayAnim(doorsAnim, cutsceneOneAnimName[i]);
			}
		}
		else
		{
			yield return Wait.For.Seconds(cutsceneTwoAnimDelay[0]);
			HAGIS.PlayAnim(doorsAnim, cutsceneTwoAnimName[0]);
			for (int i = 1; i < cutsceneTwoAnimName.Length; i++)
			{
				yield return Wait.For.Seconds(cutsceneTwoAnimDelay[i] - cutsceneTwoAnimDelay[i - 1]);
				HAGIS.PlayAnim(doorsAnim, cutsceneTwoAnimName[i]);
			}
		}
	}

	private static IEnumerator<Routine.Yield> RoutinePostScene(HackyRoutineStuct hack, Vector3 posOffset, Quaternion rotOffset)
	{
		CC inst = CC.Inst;
		FMOD.Studio.EventInstance cableCarSound = FAC.Inst.PlayOneShot(hack.cableCarSound, inst.transform);
		inst.PositionReplace(hack.cableCarTwoRegion.transform.TransformPoint(posOffset), hack.cableCarTwoRegion.transform.rotation * rotOffset, default(CC.TeleportInfo), fadeCamera: false, forceUpdateLastState: true, MovementType: false, CC.MovementType.Teleport);
		inst.SetRegion(hack.cableCarTwoRegion);
		yield return Wait.For.LRUpdates(1);
		Station_GondolaFlappyController flappyController = hack.cableCarTwoAnim.GetComponentInChildren<Station_GondolaFlappyController>();
		flappyController.PlayAmbient();
		string text = hack.cableCarTwoAnim.clip.name;
		hack.cableCarTwoAnim[text].normalizedTime = 0f;
		AnimationX.PlayAnim(hack.cableCarTwoAnim);
		Collider[] array = hack.cableCarTwoColliders;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = true;
		}
		yield return NexusFullScreenPass.Inst.StartFadeToClear(BaseSettings<TutorialSettings>.Inst.titleCardColorFadeOutTime);
		PlayerTeleport.TeleportEnabled.Value = true;
		PlayerFreeMove.FreeMoveEnabled.Value = true;
		PlayerFreeMove.FreeTurnEnabled.Value = true;
		PlayerInventory.InventoryEnabled.Value = true;
		IC.Inst.PauseMenuEnabled = true;
		IC.Inst.RecenterEnabled = true;
		yield return Wait.For.Seconds(hack.cableCarTwoAnim.clip.length - BaseSettings<TutorialSettings>.Inst.titleCardColorFadeOutTime - 10f);
		cableCarSound.setParameterValue("CableCarArrive", 1f);
		float ropeAnimLength = flappyController.hangingRope[flappyController.hangingRopeShake].length;
		yield return Wait.For.Seconds(10f - ropeAnimLength);
		flappyController.routineShake.Start(arg0: true);
		yield return Wait.For.Seconds(ropeAnimLength);
		array = hack.cableCarTwoColliders;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = false;
		}
		yield return AnimationX.PlayAnim(hack.cableCarTwoDoorAnim, hack.cableCarTwoDoorAnimOpenName);
		hack.cableCarTwoDoorRegion.Enable();
		LR.Inst.saveDataGame.stationComplete = true;
		yield return LR.Inst.Save();
	}

	private IEnumerator<Routine.Yield> RoutineGondolaWarning()
	{
		yield return VOC.Inst.IsFree;
		int index = 0;
		while (true)
		{
			float seconds = UnityEngine.Random.Range(gondolaWarningMinTime + (float)index, gondolaWarningMaxTime + (float)index);
			yield return Wait.For.Seconds(seconds);
			VOC.Inst.QueueVO(voGondolaWarnings.voiceSections[0].voiceLines[index % voGondolaWarnings.voiceSections[0].voiceLines.Length].line, VOC.VOQueueProperty.Queue, 0f, stationDoorTransform);
			index++;
			yield return VOC.Inst.IsFree;
		}
	}

	private IEnumerator<Routine.Yield> RoutineSecretEnding()
	{
		endingTimer = 0f;
		while (endingTimer < secretEndingTimeWarning)
		{
			endingTimer += IC.DeltaTime;
			yield return Wait.For.LRUpdates(1);
		}
		VO_Asset.VO_Section[] voiceSections = voSecretEndingWarning.voiceSections;
		foreach (VO_Asset.VO_Section vO_Section in voiceSections)
		{
			for (int j = 0; j < vO_Section.voiceLines.Length; j++)
			{
				VOC.Inst.QueueVO(vO_Section.voiceLines[j].line, VOC.VOQueueProperty.Queue, vO_Section.voiceLines[j].delay);
			}
		}
		endingTimer = 0f;
		while (endingTimer < secretEndingTimeFinal)
		{
			endingTimer += IC.DeltaTime;
			yield return Wait.For.LRUpdates(1);
		}
		gondolaDoorRegion.Disable();
		gondolaRegion.Disable();
		voiceSections = voSecretEndingFinal.voiceSections;
		foreach (VO_Asset.VO_Section vO_Section2 in voiceSections)
		{
			for (int k = 0; k < vO_Section2.voiceLines.Length; k++)
			{
				VOC.Inst.QueueVO(vO_Section2.voiceLines[k].line, VOC.VOQueueProperty.Queue, vO_Section2.voiceLines[k].delay);
			}
		}
	}

	private IEnumerator<Routine.Yield> RoutineGondolaPulleyAnim(bool entering)
	{
		string animation = (entering ? gondolaPulleyAnimStartUpEnter : gondolaPulleyAnimStartUp);
		string clipName = (entering ? gondolaPulleyAnimStartUp : gondolaPulleyAnimStartUpEnter);
		for (int i = 1; i < gondolaPulleyAnims.Length; i++)
		{
			gondolaPulleyAnims[i].Play(animation);
		}
		yield return AnimationX.PlayAnim(gondolaPulleyAnims[0], clipName);
		animation = (entering ? gondolaPulleyAnimSpinEnter : gondolaPulleyAnimSpin);
		clipName = (entering ? gondolaPulleyAnimSpin : gondolaPulleyAnimSpinEnter);
		for (int j = 1; j < gondolaPulleyAnims.Length; j++)
		{
			HAGIS.PlayAnim(gondolaPulleyAnims[j], animation);
		}
		HAGIS.PlayAnim(gondolaPulleyAnims[0], clipName);
		if (entering)
		{
			yield return Wait.For.Seconds(gondolaPulleyAnims[0][gondolaPulleyAnimSpin].length);
			for (int k = 1; k < gondolaPulleyAnims.Length; k++)
			{
				HAGIS.PlayAnim(gondolaPulleyAnims[k], gondolaPulleyAnimEndEnter);
			}
			HAGIS.PlayAnim(gondolaPulleyAnims[0], gondolaPulleyAnimEnd);
		}
	}

	public override bool IgnoreAreaEvents()
	{
		return true;
	}
}
public class HAGIS_Station_StationLever : HAGIS
{
	public FixedRotatableObject rotatableObject;

	public HagletTrigger gondolaEnabled = new HagletTrigger();

	public HAGIS_Station_Mainflow stationFlow;

	public FMODEventAsset pullSound;

	public RotatableIndicator rotInd;

	private bool leverPulled;

	public bool isLeverPulled => leverPulled;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		rotatableObject.ForceRotation(-40f);
		rotInd.gameObject.SetActive(value: false);
		rotatableObject.enabled = false;
		if (!Routine.Skipping)
		{
			yield return gondolaEnabled;
		}
		yield return CHECKPOINT();
		rotatableObject.enabled = true;
		rotInd.gameObject.SetActive(value: true);
		while (rotatableObject.GetAngle() < 36f && !Routine.Skipping)
		{
			yield return Wait.For.LRUpdates(1);
		}
		leverPulled = true;
		stationFlow.leverPulled.Trigger();
		FAC.Inst.PlayOneShot(pullSound, base.transform);
		CC cc = CC.Inst;
		while ((cc.handL.InteractableHeld == rotatableObject || cc.handR.InteractableHeld == rotatableObject) && !Routine.Skipping)
		{
			yield return Wait.For.LRUpdates(1);
		}
		rotatableObject.enabled = false;
		rotInd.gameObject.SetActive(value: false);
	}
}
public class HAGIS_StationRadioController : HAGIS
{
	private FMOD.Studio.EventInstance musicInstance;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		if (!LR.Inst.HACK_radioRoutine.started)
		{
			LR.Inst.HACK_radioRoutine.Start(arg0: true);
		}
		LR.Inst.HACK_soundRadioDream = false;
		yield break;
	}

	protected override void OnHagisDestroyed()
	{
		musicInstance.stop(STOP_MODE.IMMEDIATE);
	}
}
public class HAGIS_CrystalShards_LightSensors_Blocker : HAGIS_CrystalShards_LightSensors_Target
{
	public Animation anim;

	public AnimationClip animationClip;

	public FMODEventAsset blockerSound;

	private FMOD.Studio.EventInstance evtBlocker;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return Wait.For.LRUpdates(1);
	}

	public override void Reaction(int lightSensorsAmt)
	{
		if (evtBlocker.isValid())
		{
			evtBlocker.stop(STOP_MODE.IMMEDIATE);
		}
		evtBlocker = FAC.Inst.PlayOneShot(blockerSound, anim.transform);
		PlayAnimation(anim, animationClip.name, 1f, goingToOriginalState: false);
	}

	public override void GoToOriginalState()
	{
		if (evtBlocker.isValid())
		{
			evtBlocker.stop(STOP_MODE.IMMEDIATE);
		}
		evtBlocker = FAC.Inst.PlayOneShot(blockerSound, anim.transform);
		PlayAnimation(anim, animationClip.name, -1f, goingToOriginalState: true);
	}

	private void Update()
	{
		if (!anim.isPlaying && evtBlocker.isValid())
		{
			evtBlocker.stop(STOP_MODE.ALLOWFADEOUT);
		}
	}
}
public class HAGIS_CrystalShards_LightSensors_Bridge : HAGIS_CrystalShards_LightSensors_Target
{
	public Animation anim;

	public AnimationClip animationClip;

	public Region bridgeRegion;

	[Tooltip("Will play the sound every x seconds.")]
	public float soundPerSec = 0.3f;

	public FMODEventAsset soundBridge;

	public AnimationCurve soundCurveAdjust = AnimationCurve.Constant(0f, 1f, 1f);

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		bridgeRegion.Disable();
		float animDiff = 0f;
		float prevTime = 0f;
		float animLen = anim[animationClip.name].length;
		while (true)
		{
			float time = anim[animationClip.name].time;
			float num = Mathf.Abs(prevTime - time) * soundCurveAdjust.Evaluate(time / animLen);
			if (num < 1f)
			{
				animDiff += num;
				if (animDiff > soundPerSec)
				{
					animDiff -= soundPerSec;
					FAC.Inst.PlayOneShot(soundBridge, base.transform.position);
				}
				prevTime = time;
			}
			yield return Wait.For.LRUpdates(1);
		}
	}

	public override void Reaction(int lightSensorsAmt)
	{
		bridgeRegion.Enable();
		PlayAnimation(anim, animationClip.name, 1f, goingToOriginalState: false);
	}

	public override void GoToOriginalState()
	{
		bridgeRegion.Disable();
		PlayAnimation(anim, animationClip.name, -1f, goingToOriginalState: true);
	}
}
public class HAGIS_CrystalShards_LightSensors_Cage : HAGIS_CrystalShards_LightSensors_Target
{
	public Animation anim;

	public AnimationClip animationClip;

	public IDObjectRef crystalRef;

	public PlacementHelper placementHelper;

	private GrabObject crystal;

	public Region cageRegion;

	public FMODEventAsset cageSound;

	private FMOD.Studio.EventInstance evtCage;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		crystal = LR.Inst.GetIDObjectComponent<GrabObject>(crystalRef);
		crystal.canBeGrabbed = false;
		cageRegion.Disable();
		yield return Wait.For.LRUpdates(1);
	}

	public override void Reaction(int lightSensorsAmt)
	{
		crystal.canBeGrabbed = true;
		if (evtCage.isValid())
		{
			evtCage.stop(STOP_MODE.IMMEDIATE);
		}
		evtCage = FAC.Inst.PlayOneShot(cageSound, anim.transform);
		cageRegion.Enable();
		PlayAnimation(anim, animationClip.name, 1f, goingToOriginalState: false);
	}

	public override void GoToOriginalState()
	{
		if (!crystal.hasBeenGrabbed)
		{
			crystal.canBeGrabbed = false;
		}
		if (evtCage.isValid())
		{
			evtCage.stop(STOP_MODE.IMMEDIATE);
		}
		evtCage = FAC.Inst.PlayOneShot(cageSound, anim.transform);
		cageRegion.Disable();
		PlayAnimation(anim, animationClip.name, -1f, goingToOriginalState: true);
	}

	private void Update()
	{
		if (!anim.isPlaying && evtCage.isValid())
		{
			evtCage.stop(STOP_MODE.ALLOWFADEOUT);
		}
	}
}
public class HAGIS_CrystalShards_LightSensors_Door : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class HAGIS_CrystalShards_LightSensors_Light : HAGIS_CrystalShards_LightSensors_Target
{
	public LightSource lightSource;

	public Light lightCone;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		lightCone.range = 0f;
		yield return Wait.For.LRUpdates(1);
	}

	public override void Reaction(int lightSensorsAmt)
	{
		if (lightSensorsAmt == 1)
		{
			lightSource.Flicker();
			lightCone.range = 8f;
			lightSource.lightIntensityModifier = 0.5f;
		}
		if (lightSensorsAmt == 2)
		{
			lightSource.Flicker();
			lightCone.range = 15f;
			lightSource.lightIntensityModifier = 1f;
		}
	}

	public override void GoToOriginalState()
	{
		lightSource.Flicker();
		lightCone.range = 0f;
		lightSource.lightIntensityModifier = 0f;
	}
}
public class HAGIS_CrystalShards_LightSensors_RasterizerCover : HAGIS_CrystalShards_LightSensors_Target
{
	public Animation[] anim;

	public AnimationClip[] animationClips;

	private int curLightSensorAmt;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return Wait.For.LRUpdates(1);
	}

	public override void Reaction(int lightSensorsAmt)
	{
		if (lightSensorsAmt > curLightSensorAmt)
		{
			for (int i = curLightSensorAmt; i < lightSensorsAmt; i++)
			{
				string animName = animationClips[i].name;
				PlayAnimation(anim[i], animName, 1f, goingToOriginalState: false);
			}
		}
		else
		{
			for (int num = curLightSensorAmt - 1; num >= lightSensorsAmt; num--)
			{
				string animName2 = animationClips[num].name;
				PlayAnimation(anim[num], animName2, -1f, goingToOriginalState: true);
			}
		}
		curLightSensorAmt = lightSensorsAmt;
	}

	public override void GoToOriginalState()
	{
		for (int num = curLightSensorAmt - 1; num >= 0; num--)
		{
			string animName = animationClips[num].name;
			PlayAnimation(anim[num], animName, -1f, goingToOriginalState: true);
		}
		curLightSensorAmt = 0;
	}
}
[RequireComponent(typeof(HAGIS_CrystalShards_LightSensors_Trigger))]
public abstract class HAGIS_CrystalShards_LightSensors_Target : HAGIS
{
	private HAGIS_CrystalShards_LightSensors_Trigger lightSensorsTrigger;

	protected override void OnHagisAwake()
	{
		lightSensorsTrigger = GetComponent<HAGIS_CrystalShards_LightSensors_Trigger>();
	}

	public abstract void Reaction(int lightSensorsAmt);

	public abstract void GoToOriginalState();

	public void PlayAnimation(Animation anim, string animName, float animSpeed, bool goingToOriginalState)
	{
		anim[animName].speed = animSpeed;
		if (anim.isPlaying)
		{
			anim[animName].time = anim[animName].time;
		}
		else if (goingToOriginalState)
		{
			anim[animName].time = anim[animName].length;
		}
		else if (!goingToOriginalState)
		{
			anim[animName].time = 0f;
		}
		anim.Play(animName);
	}
}
public class HAGIS_CrystalShards_LightSensors_Trigger : HAGIS
{
	[Serializable]
	public class LightCrystals
	{
		public PlacementHelper placementHelper;

		[HideInInspector]
		public GrabObject placedLightCrystal;

		[HideInInspector]
		public LightSensor lightSensor;

		[HideInInspector]
		public bool isActivated;
	}

	private HAGIS_CrystalShards_LightSensors_Target target;

	public LineRenderer lineRenderer;

	private Color targetColor = Color.gray;

	public LightSensor staticLightSensor;

	private bool staticLightSensorActivated;

	public LightCrystals[] lightCrystal;

	private int prevLightSensorsPlaced;

	private int curLightSensorsPlaced;

	private bool startAnim;

	private float emissive = 0.5f;

	private MaterialPropertyBlock lineRendererMPB;

	protected override void OnHagisAwake()
	{
		target = GetComponent<HAGIS_CrystalShards_LightSensors_Target>();
		if (lineRenderer != null)
		{
			lineRendererMPB = new MaterialPropertyBlock();
			lineRendererMPB.SetFloat("_Emissive", 0.5f);
			lineRenderer.SetPropertyBlock(lineRendererMPB);
			targetColor = lineRenderer.startColor;
			lineRenderer.startColor = Color.gray;
		}
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		while (true)
		{
			if (lightCrystal.Length != 0)
			{
				PlacedLightCrystals();
			}
			if (staticLightSensor != null)
			{
				if (staticLightSensor.isReceivingLight.value && !staticLightSensorActivated)
				{
					target.Reaction(1);
					staticLightSensorActivated = true;
				}
				if (!staticLightSensor.isReceivingLight.value && staticLightSensorActivated)
				{
					target.GoToOriginalState();
					staticLightSensorActivated = false;
				}
			}
			if (curLightSensorsPlaced != prevLightSensorsPlaced)
			{
				if (curLightSensorsPlaced > 0)
				{
					target.Reaction(curLightSensorsPlaced);
				}
				if (curLightSensorsPlaced == 0)
				{
					target.GoToOriginalState();
				}
				prevLightSensorsPlaced = curLightSensorsPlaced;
			}
			if (lineRenderer != null)
			{
				UpdateLineRenderer(curLightSensorsPlaced > 0 || staticLightSensorActivated);
			}
			yield return Wait.For.LRUpdates(1);
		}
	}

	private void UpdateLineRenderer(bool sensorsActive)
	{
		float num = (sensorsActive ? 1f : 0.5f);
		float num2 = emissive;
		float deltaTime = IC.DeltaTime;
		emissive = Mathf.MoveTowards(emissive, num, deltaTime);
		if (emissive != num2)
		{
			lineRendererMPB.SetFloat(ShaderPID._Emissive, emissive);
			lineRenderer.SetPropertyBlock(lineRendererMPB);
			Color color = (sensorsActive ? targetColor : Color.gray);
			Color startColor = lineRenderer.startColor;
			startColor = ColorX.MoveTowards(startColor, color, deltaTime);
			lineRenderer.startColor = startColor;
			lineRenderer.endColor = startColor;
		}
	}

	private void PlacedLightCrystals()
	{
		for (int i = 0; i < lightCrystal.Length; i++)
		{
			LightCrystals lightCrystals = lightCrystal[i];
			if ((bool)lightCrystals.placementHelper.HeldGrabObject)
			{
				lightCrystals.placedLightCrystal = lightCrystals.placementHelper.HeldGrabObject;
				lightCrystals.lightSensor = lightCrystals.placedLightCrystal.GetComponentInChildren<LightSensor>();
			}
			if ((bool)lightCrystals.lightSensor)
			{
				if (lightCrystals.lightSensor.isReceivingLight.value && !lightCrystals.isActivated)
				{
					curLightSensorsPlaced++;
					lightCrystals.isActivated = true;
				}
				if (!lightCrystals.lightSensor.isReceivingLight.value && lightCrystals.isActivated)
				{
					curLightSensorsPlaced--;
					lightCrystals.isActivated = false;
				}
			}
			if (!lightCrystals.placementHelper.HeldGrabObject)
			{
				lightCrystals.placedLightCrystal = null;
				lightCrystals.lightSensor = null;
				if (lightCrystals.isActivated)
				{
					curLightSensorsPlaced--;
				}
				lightCrystals.isActivated = false;
			}
		}
	}
}
public class HAGIS_CrystalShards_MainFlow : HAGIS
{
	public PuzzleInfo puzzle;

	public GameObject telepoint;

	public Portal exitPortal;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		exitPortal.SetHidden(hidden: true);
		exitPortal.SetUnlockedState(unlocked: false);
		yield return Wait.For.LRUpdates(1);
		yield return WaitForPuzzle(puzzle);
		telepoint.SetActive(value: false);
		exitPortal.SetHidden(hidden: false);
		exitPortal.SetUnlockedState(unlocked: true);
	}
}
public class HAGIS_SSDeceptive_ToggleRegionUnderTable : HAGIS
{
	public Trigger trigVolume;

	public Region regionToToggle;

	public Portal portalToToggle;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		portalToToggle.currentRegion = regionToToggle;
		while (true)
		{
			yield return trigVolume.OnInside;
			if (!regionToToggle.IsEnabled)
			{
				regionToToggle.Enable();
				portalToToggle.OpenPortal();
			}
			yield return trigVolume.OnOutside;
			if (regionToToggle.IsEnabled)
			{
				regionToToggle.Disable();
				portalToToggle.ClosePortal();
			}
			yield return Wait.For.LRUpdates(1);
		}
	}
}
public class HAGIS_SSTablePortal_PortalSwitcher : HAGIS
{
	public Portal roomEntrancePortal;

	public Portal loopingPortalEntryPortrait;

	public Portal loopingPortalExitPortrait;

	public Portal loopingPortalEntryLandscape;

	public Portal loopingPortalExitLandscape;

	public Region floor1;

	public Region wall1;

	public Region exitPortalRegion;

	public Transform portalWheel;

	public HAGIS stealthPortalHagis;

	private bool landscapeMode;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		SetPortalEnabled(loopingPortalEntryLandscape, enabled: false);
		SetPortalEnabled(loopingPortalExitLandscape, enabled: false);
		SetPortalEnabled(loopingPortalEntryPortrait, enabled: false);
		SetPortalEnabled(loopingPortalExitPortrait, enabled: false);
		UnityEngine.Debug.Log("waiting to pass through portal...");
		yield return Wait.Until.Completed(stealthPortalHagis.onLogicBase);
		SetPortalEnabled(roomEntrancePortal, enabled: false);
		UnityEngine.Debug.Log("Passed through portal. ");
		SetPortalEnabled(loopingPortalEntryPortrait, enabled: true);
		SetPortalEnabled(loopingPortalExitPortrait, enabled: true);
		while (true)
		{
			if (Vector3.Dot(portalWheel.up, Vector3.up) > 0.707f && (CC.Inst.CurrentRegion == wall1 || CC.Inst.CurrentRegion == floor1 || CC.Inst.CurrentRegion == loopingPortalEntryLandscape.portalRegion || CC.Inst.CurrentRegion == loopingPortalExitLandscape.portalRegion || CC.Inst.CurrentRegion == exitPortalRegion))
			{
				if (!landscapeMode)
				{
					SetPortalEnabled(loopingPortalEntryLandscape, enabled: true);
					SetPortalEnabled(loopingPortalExitLandscape, enabled: true);
					SetPortalEnabled(loopingPortalEntryPortrait, enabled: false);
					SetPortalEnabled(loopingPortalExitPortrait, enabled: false);
					landscapeMode = true;
				}
			}
			else if (landscapeMode)
			{
				SetPortalEnabled(loopingPortalEntryLandscape, enabled: false);
				SetPortalEnabled(loopingPortalExitLandscape, enabled: false);
				SetPortalEnabled(loopingPortalEntryPortrait, enabled: true);
				SetPortalEnabled(loopingPortalExitPortrait, enabled: true);
				landscapeMode = false;
			}
			yield return Wait.For.LRUpdates(1);
		}
	}

	private void SetPortalEnabled(Portal p, bool enabled)
	{
		p.gameObject.SetActive(enabled);
		Collider[] portalColliders = p.portalColliders;
		for (int i = 0; i < portalColliders.Length; i++)
		{
			portalColliders[i].enabled = enabled;
		}
	}
}
public class HAGIS_SuperSecret_Goldberg_WeightAnimator : HAGIS
{
	public AnimMoveToTarget liftMover;

	public Transform[] liftPositions;

	public Occludee occState;

	private int targetPos;

	private int currentPos;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		while (true)
		{
			targetPos = occState.GetStateIndex();
			if (targetPos != currentPos)
			{
				switch (occState.GetStateIndex())
				{
				case 0:
					liftMover.Animate(liftPositions[0].position, 2f);
					currentPos = 0;
					break;
				case 1:
					liftMover.Animate(liftPositions[1].position, 2f);
					currentPos = 1;
					break;
				case 2:
					liftMover.Animate(liftPositions[2].position, 2f);
					currentPos = 2;
					break;
				}
			}
			yield return Wait.For.Updates(1);
		}
	}
}
public class TriggerEvent_SuperSecret_Goldberg_PortalController : MonoBehaviour, ITriggerEvent
{
	public Portal targetPortal;

	public void OnTriggerAwakeLR(Trigger trigger)
	{
		targetPortal.enabled = true;
	}

	public void OnTriggerEnterLR()
	{
		targetPortal.enabled = true;
	}

	public void OnTriggerStayLR()
	{
	}

	public void OnTriggerExitLR()
	{
		targetPortal.enabled = false;
	}
}
public class HAGIS_LabDoor : HAGIS
{
	public PuzzleInfo[] puzzles;

	public Region doorRegion;

	public Doorway doorway;

	public GameObject door;

	public PlayerAreaTrigger labTrigger;

	public IDObjectRef hubEntryPoint;

	private HagletTrigger leverTrigger = new HagletTrigger();

	public FixedRotatableObject lever;

	public IDObjectRef diagramIDRef;

	private GrabObject diagram;

	public GameObject particles;

	public FMODEventAsset doorRoomMusic;

	public FMODEventAsset finalDoorRoomMusic;

	public FMODEventAsset transitionToHub;

	public float delay = 5f;

	public float fadeInTime;

	public float fadeDelay;

	public float fadeOutTime;

	public float delayFinal = 3f;

	public Color fadeOutColor;

	private VO_Sequencer sequencer;

	[Header("Crystal Glow")]
	public MeshRenderer topCrystalRenderer;

	private MPBStore mpbStore;

	private IHaglet debugSkipAllPuzzles;

	protected override void OnHagisAwake()
	{
		mpbStore = new MPBStore();
		mpbStore.Initialise();
		mpbStore.SetFloat(ShaderPID._TextureLerp, 0f);
		mpbStore.ApplyProperties(topCrystalRenderer);
		base.OnHagisAwake();
	}

	[Event(EventName = "OnLeverPulled")]
	public void OnLeverPulled(object sender)
	{
		leverTrigger.Trigger();
		particles.SetActive(value: true);
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		sequencer = GetComponentInChildren<VO_Sequencer>();
		Haglet.Create(out debugSkipAllPuzzles, DebugSkipAllPuzzles, "Skip All Lab Puzzles", startNow: true, null, "Hagis");
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		bool fullyComplete = true;
		PuzzleInfo[] array = puzzles;
		foreach (PuzzleInfo puzzleInfo in array)
		{
			if ((bool)puzzleInfo)
			{
				fullyComplete &= puzzleInfo.IsComplete(SaveDataGame.PuzzleSaveType.Progression);
			}
			else
			{
				UnityEngine.Debug.LogError("Unassigned puzzle info! Will lead to possible early door opening!", this);
			}
		}
		if (fullyComplete)
		{
			LR.Inst.SetMusic(finalDoorRoomMusic);
		}
		else
		{
			LR.Inst.SetMusic(doorRoomMusic);
		}
		PlayerEntryPoint entryPoint = LR.Inst.GetIDObject<PlayerEntryPoint>(hubEntryPoint);
		diagram = diagramIDRef.GetComponent<GrabObject>();
		lever.enabled = true;
		lever.ForceRotation(lever.startRotationDeg);
		yield return leverTrigger;
		yield return lever.AnimateOnYield(lever.startRotationDeg, 1f);
		lever.enabled = false;
		if (fullyComplete)
		{
			yield return CHECKPOINT();
			mpbStore.SetFloat(ShaderPID._TextureLerp, 1f);
			mpbStore.ApplyProperties(topCrystalRenderer);
			doorway.Open();
			LR.Inst.SetMusicParameter("progress", 0.1f);
			sequencer.PlayNextVOSection();
			yield return labTrigger.OnInside;
			sequencer.PlayNextVOSection();
			yield return diagram.OnObjectGrabbed;
			LR.Inst.SetMusicParameter("progress", 0.2f);
			yield return sequencer.PlayNextVOSection();
			LR.Inst.saveDataGame.secretDiscovered = true;
			yield return Save();
			delay = delayFinal;
		}
		PlayerInventory.Inst.EmptyInventory(fromSaveData: false);
		yield return VOC.Inst.IsFree;
		if (!fullyComplete)
		{
			FAC.Inst.PlayOneShot(transitionToHub, base.transform.position);
		}
		yield return Wait.For.Seconds(delay);
		yield return Save();
		if (!fullyComplete)
		{
			LR.Inst.StopMusic();
		}
		CC.Inst.PositionReplace(entryPoint, default(CC.TeleportInfo), fadeInTime: fadeInTime, fadeDelayTime: fadeDelay, fadeOutTime: fadeOutTime, fadeCamera: true, forceUpdateLastState: true, MovementType: false, movementType: CC.MovementType.None, fadeColor: fadeOutColor);
	}

	private IEnumerator<Routine.Yield> DebugSkipAllPuzzles()
	{
		yield return Wait.UntilTriggered;
		PuzzleInfo[] array = puzzles;
		foreach (PuzzleInfo puzzleInfo in array)
		{
			yield return puzzleInfo.SetComplete();
		}
	}
}
public class HAGIS_LabLight : HAGIS
{
	public PuzzleInfo puzzle;

	private HagletTrigger lightTrigger = new HagletTrigger();

	private GameObject glowDecal;

	private MPBStore mpb;

	private MeshRenderer renderer;

	protected override void OnHagisAwake()
	{
		glowDecal = base.transform.GetChild(0).gameObject;
		renderer = GetComponent<MeshRenderer>();
		mpb = new MPBStore();
		mpb.Initialise();
		mpb.SetFloat(ShaderPID._TextureLerp, 0f);
		mpb.ApplyProperties(renderer);
		base.OnHagisAwake();
	}

	[Event(EventName = "OnLeverPulled")]
	public void OnLeverPulled(object sender)
	{
		if (puzzle != null && puzzle.IsComplete(SaveDataGame.PuzzleSaveType.Progression))
		{
			lightTrigger.Trigger();
		}
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		glowDecal.SetActive(value: false);
		yield return lightTrigger;
		yield return CHECKPOINT();
		mpb.SetFloat(ShaderPID._TextureLerp, 1f);
		mpb.ApplyProperties(renderer);
		glowDecal.SetActive(value: true);
	}

	public override bool IgnoreAreaEvents()
	{
		return true;
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_SuperSecret_PortableHole_Door : HAGIS
{
	public Region regionToEnable;

	public InteractableTarget_Animation animHandler;

	public PlacementHelper helperToCheck;

	[Range(0f, 1f)]
	public float pointToEnable;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		regionToEnable.Disable();
		while (true)
		{
			if (!regionToEnable.IsEnabled && animHandler.normalisedPostion >= pointToEnable)
			{
				regionToEnable.Enable();
			}
			else if (regionToEnable.IsEnabled && animHandler.normalisedPostion <= pointToEnable)
			{
				regionToEnable.Disable();
			}
			yield return Wait.For.Seconds(1f);
		}
	}
}
public class HAGIS_SuperSecret_PortableHole_HoldObject : MonoBehaviour
{
	[Event(EventName = "Object in Wall")]
	private void ObjectInWall(GameObject sender)
	{
		Vector3 position = sender.transform.position;
		Quaternion rotation = sender.transform.rotation;
		Rigidbody component = sender.GetComponent<Rigidbody>();
		component.isKinematic = true;
		component.freezeRotation = true;
		sender.GetComponent<GrabObject>().SetPositionAndRotation(position, rotation);
	}
}
public class HAGIS_SuperSecret_PortableHole_ShutterDoorAlt : HAGIS
{
	public IDObjectRef otherAnimCompRef;

	public Animation localAnimComp;

	public PlayerAreaTrigger localAreaTrig;

	public AnimationClip animToPlay;

	private Animation otherAnimComp;

	private bool animActive;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return Wait.For.Seconds(3f);
		otherAnimComp = LR.Inst.GetIDObjectComponent<Animation>(otherAnimCompRef);
		while (true)
		{
			if (!animActive && localAreaTrig.IsInsideBool)
			{
				localAnimComp.Play(animToPlay.name);
				otherAnimComp.Play(animToPlay.name);
				animActive = true;
			}
			else if (animActive && !localAreaTrig.IsInsideBool)
			{
				animActive = true;
			}
			yield return Wait.For.Updates(1);
		}
	}
}
public class HAGIS_HACK_MirrorController : HAGIS
{
	public IDObjectRef leverAnimRef;

	public Portal mirrorPortal;

	private LeverAnimation leverAnim;

	private bool mirrorUpsideDown;

	private bool mirrorInPosition;

	protected override void OnHagisAwake()
	{
		base.OnHagisAwake();
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		while (!LR.Inst.AreAllLoadedScenesAwake)
		{
			yield return Wait.For.LRUpdates(1);
		}
		leverAnim = leverAnimRef.Get<LeverAnimation>();
		while (true)
		{
			mirrorUpsideDown = leverAnim.isLeverUp;
			bool flag = !mirrorUpsideDown || !mirrorInPosition;
			if (flag != mirrorPortal.IsUnlocked)
			{
				mirrorPortal.SetUnlockedState(flag);
			}
			yield return Wait.For.LRUpdates(1);
		}
	}

	[Event(EventName = "On Enter Invalid Pos")]
	public void OnInvalidPosEnter(object sender)
	{
		mirrorInPosition = true;
	}

	[Event(EventName = "On Exit Invalid Pos")]
	public void OnInvalidPosExit(object sender)
	{
		mirrorInPosition = false;
	}
}
public class HAGIS_SSMirrors_HandleObjectSwap : HAGIS
{
	public Trigger triggerVol;

	public PlacementHelper helper;

	public IDObjectRef handlesRef;

	public RotatableObject rotationPoint;

	public GameObject fixedHandle;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		fixedHandle.SetActive(value: false);
		rotationPoint.enabled = false;
		UnityEngine.Debug.Log("handle should be turned off now");
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		GrabObject grabHandle = LR.Inst.GetIDObjectComponent<GrabObject>(handlesRef);
		yield return triggerVol.OnInside;
		if (triggerVol.IsInsideBool)
		{
			UnityEngine.Debug.Log("handle should be turned on now");
			grabHandle.SetPositionAndRotation(fixedHandle.transform.position, fixedHandle.transform.rotation, CC.MovementType.Teleport);
			fixedHandle.SetActive(value: true);
			grabHandle.GetComponent<MeshRenderer>().enabled = false;
			PlayerInventory.Inst.RemoveFromInventory(grabHandle);
			grabHandle.gameObject.SetActive(value: false);
			grabHandle.enabled = false;
			rotationPoint.enabled = true;
		}
		else
		{
			yield return Wait.For.LRUpdates(1);
		}
	}
}
public class HAGIS_SSMirrors_RegionVariance : HAGIS
{
	public Region[] mainVariantRegions;

	public Region[] mirrorVariantRegions;

	private PortalVariations.VariantSet currentVariant;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		Region[] array = mirrorVariantRegions;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Disable();
		}
		yield return Wait.For.LRUpdates(1);
		while (true)
		{
			if (MainCamera.Inst.portalVariantSet != currentVariant)
			{
				currentVariant = MainCamera.Inst.portalVariantSet;
				if (currentVariant == PortalVariations.VariantSet.Main)
				{
					array = mainVariantRegions;
					for (int i = 0; i < array.Length; i++)
					{
						array[i].Enable();
					}
					array = mirrorVariantRegions;
					for (int i = 0; i < array.Length; i++)
					{
						array[i].Disable();
					}
				}
				else
				{
					array = mainVariantRegions;
					for (int i = 0; i < array.Length; i++)
					{
						array[i].Disable();
					}
					array = mirrorVariantRegions;
					for (int i = 0; i < array.Length; i++)
					{
						array[i].Enable();
					}
				}
			}
			yield return Wait.For.LRUpdates(1);
		}
	}
}
public class HAGIS_Mansfield_MirrorsWorld_MirrorReflectionHack : HAGIS
{
	public Portal mirror;

	public Texture2D defaultTex;

	public Texture2D altTex;

	public float altDist;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return Wait.For.LRUpdates(1);
		Vector3 mirrorStartPosition = mirror.transform.position;
		while (true)
		{
			Vector3 position = mirror.transform.position;
			if (Vector3.Distance(mirrorStartPosition, position) < altDist)
			{
				mirror.mirrorDistanceTexture = defaultTex;
			}
			else
			{
				mirror.mirrorDistanceTexture = altTex;
			}
			yield return Wait.For.LRUpdates(1);
		}
	}
}
public class HAGIS_Mansfield_MirrorWorld_CloseDoor : HAGIS
{
	public Doorway firstDoor;

	public PlayerAreaTrigger playerAreaTrigger;

	public Region beforeDoorClose;

	public Region afterDoorClose;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		afterDoorClose.Disable();
		yield return Wait.For.LRUpdates(1);
		while (!playerAreaTrigger.IsInsideBool)
		{
			yield return Wait.For.LRUpdates(1);
		}
		beforeDoorClose.Disable();
		afterDoorClose.Enable();
		firstDoor.Close();
	}
}
public class HAGIS_Mansfield_MirrorWorld_MainFlow : HAGIS
{
	public PuzzleInfo puzzle1;

	public PuzzleInfo puzzle2;

	public Portal exitPortal;

	public Doorway firstDoor;

	public Doorway exitDoor;

	public GameObject p1Telepoint;

	public LightSource p1Light;

	public LightSource p2Light;

	public Region exitDoorRegion;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		p2Light.DisableLight();
		exitPortal.SetUnlockedState(unlocked: false);
		exitPortal.SetHidden(hidden: true);
		yield return WaitForPuzzle(puzzle1);
		p1Light.DisableLight();
		p1Telepoint.SetActive(value: false);
		firstDoor.Open();
		p2Light.EnableLight();
		yield return WaitForPuzzle(puzzle2);
		p2Light.DisableLight();
		exitDoorRegion.Disable();
		exitDoor.Open();
		exitPortal.SetUnlockedState(unlocked: true);
		exitPortal.SetHidden(hidden: false);
		yield return Wait.For.LRUpdates(1);
	}
}
public class MirrorRotationMimic : MonoBehaviour
{
	public Transform target;

	public float speedModifier;

	private void LateUpdate()
	{
		if ((bool)target)
		{
			Quaternion rotation = base.transform.rotation;
			Vector3 vector = new Vector3(target.rotation.eulerAngles.y, rotation.eulerAngles.y, rotation.eulerAngles.z);
			base.transform.rotation = Quaternion.Euler(vector * speedModifier);
		}
	}
}
public class HAGIS_SSPortals_HandleObjectSwap : HAGIS
{
	public PlacementHelper helper;

	public IDObjectRef handlesRef;

	public FixedRotatableObject rotationPoint;

	private MeshRenderer pointHandles;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		pointHandles = rotationPoint.GetComponentInChildren<MeshRenderer>();
		pointHandles.GetComponent<MeshCollider>().enabled = false;
		pointHandles.enabled = false;
		rotationPoint.enabled = false;
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		GrabObject handles = LR.Inst.GetIDObjectComponent<GrabObject>(handlesRef);
		while (!helper.HeldGrabObject)
		{
			yield return Wait.For.LRUpdates(1);
		}
		handles.SetPositionAndRotation(pointHandles.transform.position, pointHandles.transform.rotation, CC.MovementType.Teleport);
		pointHandles.GetComponent<MeshCollider>().enabled = true;
		pointHandles.enabled = true;
		handles.GetComponent<MeshRenderer>().enabled = false;
		PlayerInventory.Inst.RemoveFromInventory(handles);
		handles.gameObject.SetActive(value: false);
		handles.enabled = false;
		rotationPoint.enabled = true;
		Wait.For.LRUpdates(1);
		yield return Wait.For.LRUpdates(1);
	}
}
public class HAGIS_SecretPuzzle_Mansfield_Stargate : HAGIS
{
	public LightSensor LeftSensor;

	public LightSensor RightSensor;

	public Portal starGate;

	public Portal catapultEntry;

	public Portal catapultExit;

	public Portal secondFloorPortal;

	public Portal islandPortal;

	public Portal roofPortal;

	public IDObjectRef secondFloorPortalRef;

	public IDObjectRef islandPortalRef;

	public IDObjectRef roofPortalRef;

	private IHaglet<bool> turnPortalOnRoutine;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		catapultEntry.cameraMode = PortalCameraMode.ManualOff;
		catapultExit.cameraMode = PortalCameraMode.ManualOff;
		starGate.SetUnlockedState(unlocked: false);
		yield break;
	}

	private void Awake()
	{
		LeftSensor.OnLit.onInvoke += turnPortalOn;
		RightSensor.OnLit.onInvoke += turnPortalOn;
		LeftSensor.OnUnlit.onInvoke += turnPortalOn;
		RightSensor.OnUnlit.onInvoke += turnPortalOn;
		Haglet.Create(out turnPortalOnRoutine, (Routine.Func1<bool>)TurnPortalOnRoutine, (string)null, startNow: false, (int?)null, (string)null);
	}

	protected override void OnHagisDestroyed()
	{
		LeftSensor.OnLit.onInvoke -= turnPortalOn;
		RightSensor.OnLit.onInvoke -= turnPortalOn;
		LeftSensor.OnUnlit.onInvoke -= turnPortalOn;
		RightSensor.OnUnlit.onInvoke -= turnPortalOn;
	}

	private void turnPortalOn()
	{
		((IHagletCallable)turnPortalOnRoutine).Start(resetIfStarted: true, skip: false, waitUntilCompleted: true);
	}

	public IEnumerator<Routine.Yield> TurnPortalOnRoutine(bool a)
	{
		if (!RightSensor.isReceivingLight.value && !LeftSensor.isReceivingLight.value)
		{
			starGate.SetUnlockedState(unlocked: false);
		}
		else if (RightSensor.isReceivingLight.value && LeftSensor.isReceivingLight.value)
		{
			if (starGate.IsUnlocked)
			{
				starGate.SetUnlockedState(unlocked: false);
				yield return Wait.For.Seconds(1f);
			}
			starGate.SetLinkRef(roofPortalRef);
			if (!roofPortal.IsUnlocked)
			{
				roofPortal.SetUnlockedState(unlocked: true);
			}
			starGate.SetUnlockedState(unlocked: true);
		}
		else if (LeftSensor.isReceivingLight.value && !RightSensor.isReceivingLight.value)
		{
			if (starGate.IsUnlocked)
			{
				starGate.SetUnlockedState(unlocked: false);
				yield return Wait.For.Seconds(1f);
			}
			starGate.SetLinkRef(secondFloorPortalRef);
			if (!secondFloorPortal.IsUnlocked)
			{
				secondFloorPortal.SetUnlockedState(unlocked: true);
			}
			starGate.SetUnlockedState(unlocked: true);
		}
		else if (RightSensor.isReceivingLight.value && !LeftSensor.isReceivingLight.value)
		{
			if (starGate.IsUnlocked)
			{
				starGate.SetUnlockedState(unlocked: false);
				yield return Wait.For.Seconds(1f);
			}
			starGate.SetLinkRef(islandPortalRef);
			if (!islandPortal.IsUnlocked)
			{
				islandPortal.SetUnlockedState(unlocked: true);
			}
			starGate.SetUnlockedState(unlocked: true);
		}
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class SuperSecret_Stargate_TubePlatform : MonoBehaviour, IAwakeEvent
{
	private enum PlatformState
	{
		LOW,
		MID,
		HIGH
	}

	public Animation platformAnim;

	public string midToBotClipName;

	public string topToMidClipName;

	public string botToTopClipName;

	public FMODEventAsset soundLong;

	public FMODEventAsset soundShort;

	public Transform soundPos;

	[SerializeField]
	private PlatformState currentState;

	private IHaglet<PlatformState> routinePlatformAnimate;

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		Haglet.Create(out routinePlatformAnimate, (Routine.Func1<PlatformState>)RoutinePlatformAnimate, (string)null, startNow: false, (int?)null, (string)null);
	}

	[Event(EventName = "Animate Platform to Attic")]
	public void AnimateToAttic(object sender)
	{
		TryPlayAnim(PlatformState.HIGH);
	}

	[Event(EventName = "Animate Platform to Middle Floor")]
	public void AnimateToMiddleFloor(object sender)
	{
		TryPlayAnim(PlatformState.MID);
	}

	[Event(EventName = "Animate Platform to Ground Floor")]
	public void AnimateToGroundFloor(object sender)
	{
		TryPlayAnim(PlatformState.LOW);
	}

	private void TryPlayAnim(PlatformState targetState)
	{
		if (targetState != currentState && routinePlatformAnimate != null && !routinePlatformAnimate.started)
		{
			routinePlatformAnimate.Start(targetState);
		}
	}

	private string GetClipNameFromTargetState(PlatformState state)
	{
		switch (currentState)
		{
		case PlatformState.LOW:
			if (state != PlatformState.HIGH)
			{
				return midToBotClipName;
			}
			return botToTopClipName;
		case PlatformState.MID:
			if (state != PlatformState.HIGH)
			{
				return midToBotClipName;
			}
			return topToMidClipName;
		case PlatformState.HIGH:
			if (state != PlatformState.MID)
			{
				return botToTopClipName;
			}
			return topToMidClipName;
		default:
			return null;
		}
	}

	private IEnumerator<Routine.Yield> RoutinePlatformAnimate(PlatformState targetState)
	{
		if (!LR.Inst.IsAllConnectedSceneLoadingUnloadingComplete() || !LR.Inst.AreAllLoadedScenesAwake)
		{
			yield break;
		}
		string clipNameFromTargetState = GetClipNameFromTargetState(targetState);
		if (clipNameFromTargetState != null)
		{
			if (Mathf.Abs(targetState - currentState) == 2)
			{
				FAC.Inst.PlayOneShot(soundLong, soundPos);
			}
			else
			{
				FAC.Inst.PlayOneShot(soundShort, soundPos);
			}
			bool reverseAnim = targetState - currentState > 0;
			AnimationState state = platformAnim[clipNameFromTargetState];
			float t = 0f;
			float animT = 0f;
			while (t < 1f)
			{
				t += Time.deltaTime / state.length;
				animT += Time.deltaTime;
				SampleAnimation(reverseAnim ? (1f - t) : t, state);
				yield return Wait.For.LRUpdates(1);
			}
			SampleAnimation((!reverseAnim) ? 1 : 0, state);
			currentState = targetState;
		}
	}

	private void SampleAnimation(float normalizedTime, AnimationState state)
	{
		state.enabled = true;
		state.weight = 1f;
		state.normalizedTime = normalizedTime;
		platformAnim.Sample();
		state.enabled = false;
	}
}
public class HAGIS_BalconyCutscene : HAGIS
{
	public FMODEventRef m_smashSound;

	public PlayerAreaTrigger trigger;

	public IDObjectRef animationRef;

	public IDObjectRef statueTopRef;

	public IDObjectRef statueBottomRef;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		Animation animation = LR.Inst.GetIDObjectComponent<Animation>(animationRef);
		GrabObject statueTopGO = statueTopRef.Get<GrabObject>();
		GrabObject statueBottomGO = statueBottomRef.Get<GrabObject>();
		Vector3 portalLocation = new Vector3(1013f, 11.236f, 0f);
		yield return trigger.OnHeadInside;
		yield return HAGIS.PlayAnim(animation);
		FAC.Inst.PlayOneShot(m_smashSound.Value, portalLocation);
		statueTopGO.pr.SetKinematic(isKinematic: false);
		statueBottomGO.pr.SetKinematic(isKinematic: false);
	}
}
public class HAGIS_ThroneA_Obelisk : HAGIS
{
	public HAGIS_Cutscene_Base LornaCutscene;

	public List<IDObjectRef> telepointRefs = new List<IDObjectRef>();

	private List<IDObject> telepoints = new List<IDObject>();

	public List<GameObject> telepointOBJ = new List<GameObject>();

	[Tooltip("Balcony/P3 light handled separately")]
	public LightSource[] lights;

	public Portal firstMeetingPortal;

	protected override void OnHagisAwake()
	{
		LightSource[] array = lights;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].DisableLight();
		}
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		firstMeetingPortal.enabled = false;
		foreach (GameObject item in telepointOBJ)
		{
			item.SetActive(value: false);
		}
		yield return Wait.For.LRUpdates(1);
		yield return LornaCutscene.IsComplete;
		yield return Routine.Yield.SpecialIndex.StopSkipping;
		LightSource[] array = lights;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].EnableLight();
		}
		foreach (GameObject item2 in telepointOBJ)
		{
			item2.SetActive(value: true);
		}
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_ThroneA_PuzzleFlow : HAGIS
{
	public PuzzleInfo puzzle;

	public LightSource lightSource;

	public GameObject telepoint;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		if (!puzzle.IsComplete(SaveDataGame.PuzzleSaveType.Scene))
		{
			yield return WaitForPuzzle(puzzle);
		}
		lightSource.DisableLight();
		telepoint.SetActive(value: false);
		yield return Wait.For.LRUpdates(1);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_ThroneRoom_B_Flow : HAGIS
{
	public HAGIS_Simple_Cutscene cutscene;

	public Portal exitPortal;

	public FMODEventAsset finishMusic;

	public PuzzleInfo[] mainPuzzles;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		exitPortal.SetUnlockedState(unlocked: false);
		cutscene.gameObject.SetActive(value: false);
		yield return WaitForPuzzles(mainPuzzles);
		cutscene.gameObject.SetActive(value: true);
		LR.Inst.StopMusic();
		yield return cutscene.IsComplete;
		LR.Inst.SetMusic(finishMusic);
		yield return Wait.For.LRUpdates(1);
		exitPortal.SetUnlockedState(unlocked: true);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_ThroneRoom_B_Puzzle : HAGIS
{
	public PuzzleInfo puzzleInfo;

	public LightSource lightSource;

	public GameObject telepoint;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return WaitForPuzzle(puzzleInfo);
		lightSource.DisableLight();
		telepoint.SetActive(value: false);
		yield return Wait.For.LRUpdates(1);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_TutorialSequence_MainFlow : HAGIS
{
	[Space]
	[Header("Tutorial")]
	public Tutorial_Base[] tutorialSteps = new Tutorial_Base[0];

	public FMODEventAsset tutorialMusic;

	[Space]
	[Header("Fade to white")]
	public IDObjectRef demoEntryPoint;

	public IDObjectRef gameIntroEntryPoint;

	public IDObjectRef gameHubEntryPoint;

	public float whiteFadeDelay = 2.5f;

	public float whiteFadeInTime = 2f;

	public float whiteDelay = 1f;

	public float whitefadeOutTime = 1f;

	public Color whiteFadeOutColor = new Color(188f, 188f, 188f);

	public ParticlePathHandler pathHandler;

	public Region currentStepRegion;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		VOC.Inst.VOStop(interruption: true);
		LR.Inst.SetMusic(tutorialMusic);
		for (int j = 0; j < tutorialSteps.Length; j++)
		{
			tutorialSteps[j].gameObject.SetActive(value: false);
			if (pathHandler != null)
			{
				tutorialSteps[j].pathHandler = pathHandler;
			}
		}
		while (!CC.Inst.isActiveAndEnabled)
		{
			yield return Wait.For.LRRealtimeUpdates(1);
		}
		PlayerTeleport.TeleportEnabled.Value = false;
		PlayerFreeMove.FreeMoveEnabled.Value = false;
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		while (!LR.Inst.awakeLR.completed)
		{
			yield return Wait.For.LRRealtimeUpdates(1);
		}
		yield return Wait.For.LRUpdates(1);
		if (LR.Inst.MainMenuMode)
		{
			LR.Inst.MainMenuMode = false;
			IC.Inst.MainMenuIntercept = true;
			if (!LR.Inst.saveDataGame.newGameStarted)
			{
				UIPauseMenu.Inst.currentMenuType = SceneInfo.MenuType.MainLimited;
			}
			else if (!LR.Inst.saveDataGame.tutorialComplete)
			{
				UIPauseMenu.Inst.currentMenuType = SceneInfo.MenuType.MainTutorial;
			}
			else
			{
				UIPauseMenu.Inst.currentMenuType = SceneInfo.MenuType.Main;
			}
			UIPauseMenuShowOptions opts = default(UIPauseMenuShowOptions);
			opts.disableFade = true;
			opts.forceFrontFacing = true;
			opts.disableParticles = true;
			UIPauseMenu.Inst.ShowPauseMenu(opts);
			while (UIPauseMenu.Inst.IsShown)
			{
				CC.Inst.UpdateInputHand();
				yield return Wait.For.LRRealtimeUpdates(1);
			}
			IC.Inst.MainMenuIntercept = false;
			UIPauseMenu.Inst.currentMenuType = SceneInfo.MenuType.Tutorial;
		}
		IC.Inst.PauseMenuEnabled = true;
		yield return Wait.For.Seconds(1f);
		LR.Inst.saveDataGame.newGameStarted = true;
		yield return LR.Inst.Save();
		SceneInfo info = ((!LR.Inst.saveDataGame.stationComplete) ? Runtime.LoadAsset<SceneInfo>("Assets/_GameAssets/CustomAssets/SceneInfos/SC_Station_A_ART.asset") : Runtime.LoadAsset<SceneInfo>("Assets/_GameAssets/CustomAssets/SceneInfos/SC_MainHub_LOGIC.asset"));
		owner.AddConnectingScene(info);
		LR.Inst.LoadAdjacentScenes();
		PlayerTeleport.TeleportEnabled.Value = true;
		PlayerFreeMove.FreeMoveEnabled.Value = true;
		for (int i = 0; i < tutorialSteps.Length; i++)
		{
			Tutorial_Base step = tutorialSteps[i];
			if (step.disableMovement)
			{
				PlayerFreeMove.FreeMoveEnabled.Value = false;
				PlayerTeleport.TeleportEnabled.Value = false;
			}
			Region nextRegion = step.stepRegion;
			if (currentStepRegion != nextRegion)
			{
				nextRegion.Enable();
				yield return Wait.For.Updates(1);
				currentStepRegion.Disable();
				currentStepRegion = nextRegion;
			}
			step.gameObject.SetActive(value: true);
			yield return step.PlayTutorialStep();
			step.gameObject.SetActive(value: false);
			if (i + 1 >= tutorialSteps.Length || !tutorialSteps[i + 1].disableMovement)
			{
				PlayerFreeMove.FreeMoveEnabled.Value = true;
				PlayerTeleport.TeleportEnabled.Value = true;
			}
			yield return Wait.For.Updates(1);
		}
		LR.Inst.StopMusic();
		yield return Routine.Yield.SpecialIndex.StopSkipping;
		PlayerFreeMove.FreeMoveEnabled.Value = false;
		PlayerTeleport.TeleportEnabled.Value = false;
		if (!LR.Inst.saveDataGame.tutorialComplete)
		{
			UIPauseMenuShowOptions opts2 = default(UIPauseMenuShowOptions);
			opts2.disableFade = true;
			opts2.disableParticles = true;
			UIPauseMenu.Inst.ShowHelperScreen(opts2);
		}
		while (UIPauseMenu.Inst.IsAnimating() || UIPauseMenu.Inst.IsShown)
		{
			yield return Wait.For.LRUpdates(1);
		}
		yield return Wait.For.Seconds(whiteFadeDelay) & LR.Inst.IsAllConnectedScenesLoaded;
		LR.Inst.HACK_soundRadioStartFade = true;
		PlayerEntryPoint playerEntryPoint = UnityEngine.Object.FindObjectOfType<HubEntryPointHolder>()?.GetTargetHubEntryPoint();
		playerEntryPoint = (playerEntryPoint ? playerEntryPoint : gameHubEntryPoint.GetOrNull<IDObject>(this)?.GetComponent<PlayerEntryPoint>());
		PlayerEntryPoint playerEntryPoint2 = gameIntroEntryPoint.GetOrNull<IDObject>(this)?.GetComponent<PlayerEntryPoint>();
		PlayerEntryPoint entryPoint = (LR.Inst.saveDataGame.stationComplete ? playerEntryPoint : playerEntryPoint2);
		LR.Inst.saveDataGame.tutorialComplete = true;
		yield return Save();
		CC.Inst.PositionReplace(entryPoint, default(CC.TeleportInfo), fadeInTime: whiteFadeInTime, fadeDelayTime: whiteFadeDelay, fadeOutTime: whitefadeOutTime, fadeCamera: true, forceUpdateLastState: true, MovementType: false, movementType: CC.MovementType.None, fadeColor: whiteFadeOutColor);
		PlayerFreeMove.FreeMoveEnabled.Value = true;
		PlayerTeleport.TeleportEnabled.Value = true;
		LR.Inst.SetInCutscene(cutscene: false);
	}
}
public class HAGIS_TrophyRoom_BurstObjectPostCutscene : HAGIS
{
	public HAGIS_HunterTrophyRoom_Cutscene cutscene;

	public float secondsToBurst = 2f;

	private IHaglet breakWhenFinishedRoutine;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		base.gameObject.SetActive(value: false);
		while (!base.gameObject.activeInHierarchy)
		{
			yield return Wait.For.Updates(1);
		}
		yield return Wait.For.Seconds(secondsToBurst);
		Haglet.Create(out breakWhenFinishedRoutine, BreakWhenFinishedRoutine, null, startNow: true);
	}

	private IEnumerator<Routine.Yield> BreakWhenFinishedRoutine()
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		InteractionSettings intSettings = BaseSettings<InteractionSettings>.Inst;
		_ = LR.Inst;
		bool complete = false;
		while (!complete)
		{
			complete = true;
			if (!complete)
			{
				yield return Wait.For.LRUpdates(1);
			}
		}
		InventorySettings inst = BaseSettings<InventorySettings>.Inst;
		_ = inst.handFadeInTime;
		_ = inst.handUnfillDelay;
		float waitTime2 = inst.handUnfillTime + inst.objectUnfillDelay;
		float time2 = 0f;
		Color darkGrey = Color.grey * Color.black;
		while (time2 < intSettings.shatterFadeTime)
		{
			yield return Wait.For.LRUpdates(1);
			time2 += IC.DeltaTime;
			Color.Lerp(Color.clear, darkGrey, Mathf.Clamp01(time2 / intSettings.shatterFadeTime));
		}
		time2 = 0f;
		Vector3 startScale = base.transform.localScale;
		while (time2 < intSettings.shatterTime)
		{
			yield return Wait.For.LRUpdates(1);
			time2 += IC.DeltaTime;
			float num = intSettings.shatterScaleCurve.Evaluate(Mathf.Clamp01(time2 / waitTime2));
			base.transform.localScale = startScale * num;
		}
		Vector3 position = base.transform.position;
		PSC.Inst.PlayAt(ParticleType.InventoryBurst, position);
		FAC.Inst.PlayOneShot(intSettings.sfxShatter, position);
		base.gameObject.SetActive(value: false);
		base.transform.localScale = startScale;
	}
}
public class HAGIS_TrophyRoom_CloseDoor : HAGIS
{
	public Doorway doorway;

	public PlayerAreaTrigger[] areaTriggers;

	public Portal entryPortal;

	public Portal exitPortal;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		while (true)
		{
			yield return Wait.UntilTriggered;
			if (!entryPortal.IsUnlocked)
			{
				exitPortal.SetHidden(hidden: false);
				entryPortal.SetHidden(hidden: false);
				entryPortal.SetUnlockedState(unlocked: true);
				UnityEngine.Debug.Log("Unlocking Portals");
			}
			else
			{
				UnityEngine.Debug.Log("Portal was not locked, not enabling");
			}
			bool enteredTrigger = false;
			while (!enteredTrigger)
			{
				PlayerAreaTrigger[] array = areaTriggers;
				foreach (PlayerAreaTrigger playerAreaTrigger in array)
				{
					enteredTrigger |= playerAreaTrigger.IsInsideBool;
				}
				yield return Wait.For.LRUpdates(1);
			}
			yield return doorway.Close();
			UnityEngine.Debug.Log("Locking Portals");
			entryPortal.SetUnlockedState(unlocked: false);
			entryPortal.SetHidden(hidden: true);
			exitPortal.SetHidden(hidden: true);
		}
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_TrophyRoom_EnablePortals : HAGIS
{
	public IDObjectRef trophyRoomToGardensBPortalRef;

	public IDObjectRef gardensBPortalRef;

	public IDObjectRef trophyRoomTriggerRef;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		Portal trophyRoomToGardensBPortal = LR.Inst.GetIDObjectComponent<Portal>(trophyRoomToGardensBPortalRef);
		Trigger trophyRoomTrigger = trophyRoomTriggerRef.Get<Trigger>();
		Portal gardensBPortal = LR.Inst.GetIDObjectComponent<Portal>(gardensBPortalRef);
		trophyRoomToGardensBPortal.SetUnlockedState(unlocked: true);
		trophyRoomToGardensBPortal.SetHidden(hidden: false);
		gardensBPortal.SetUnlockedState(unlocked: false);
		gardensBPortal.SetHidden(hidden: true);
		yield return Wait.For.LRUpdates(1);
		while (true)
		{
			yield return trophyRoomTrigger.OnInside;
			trophyRoomToGardensBPortal.SetUnlockedState(unlocked: true);
			trophyRoomToGardensBPortal.SetHidden(hidden: false);
			gardensBPortal.SetUnlockedState(unlocked: true);
			gardensBPortal.SetHidden(hidden: false);
			yield return Wait.For.LRUpdates(1);
		}
	}
}
public class HAGIS_TrophyRoom_MainFlow : HAGIS
{
	public PuzzleInfo[] puzzles;

	public LightSource lightSrc;

	public Region DisableSoundRegion;

	public TrophyRoom_Fireplace FireplaceController;

	public FMODAmbientSource fireSound;

	private IHaglet<bool> routineUpdateFireplaceSound;

	public void Awake()
	{
		Haglet.Create(out routineUpdateFireplaceSound, (Routine.Func1<bool>)UpdateFireplaceSound, (string)null, startNow: false, (int?)null, (string)null);
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		routineUpdateFireplaceSound.Start();
		yield return WaitForPuzzles(puzzles);
		lightSrc.DisableLight();
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}

	private IEnumerator<Routine.Yield> UpdateFireplaceSound(bool placeholder)
	{
		while (true)
		{
			bool flag = !FireplaceController.isUp && CC.Inst.CurrentRegion != DisableSoundRegion;
			if (flag && !fireSound.playing)
			{
				fireSound.Play();
			}
			else if (!flag && fireSound.playing)
			{
				fireSound.Stop();
			}
			yield return Wait.For.LRUpdates(1);
		}
	}
}
public class HAGIS_TrophyRoom_P1_P2 : HAGIS
{
	public PuzzleInfo puzzle;

	public GameObject telepoint;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return Wait.For.LRUpdates(1);
		yield return WaitForPuzzle(puzzle);
		telepoint.SetActive(value: false);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class HAGIS_TrophyRoom_P3_OP : HAGIS
{
	public PuzzleInfo puzzle;

	public GameObject telepoint;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return Wait.For.LRUpdates(1);
		yield return WaitForPuzzle(puzzle);
		telepoint.SetActive(value: false);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class OcclusionRegionToggle : MonoBehaviour
{
	public Region region;

	private void OnEnable()
	{
		if (!region.IsEnabled)
		{
			region.Enable();
		}
	}

	private void OnDisable()
	{
		if (region.IsEnabled)
		{
			region.Disable();
		}
	}
}
public class TrophyRoom_CloseGroundDoor : MonoBehaviour
{
	public GameObject door;

	public Animation anim;

	private Vector3 defaultPos;

	private Vector3 defaultRot;

	private void Awake()
	{
		defaultPos = door.transform.position;
		defaultRot = door.transform.localEulerAngles;
	}

	[Event(EventName = "Close Door")]
	public void CloseDoor(object sender)
	{
		anim.Stop();
		door.transform.position = defaultPos;
		door.transform.localRotation = Quaternion.Euler(defaultRot);
	}
}
public class TrophyRoom_Fireplace : MonoBehaviour, IAwakeEvent
{
	public Animation fireplaceBacking;

	public string animationName;

	public Region fireplaceRegion;

	public GameObject fireMainRoom;

	public GameObject fireplaceLight;

	public GameObject fireplaceFrontWall;

	public Vector3 gearSoundPosition;

	public bool isUp;

	public FMODEventAsset fireplaceMoveSound;

	public FMODEventAsset fireplaceGearsSound;

	private FMOD.Studio.EventInstance moveSoundInstance;

	private FMOD.Studio.EventInstance gearSoundInstance;

	private IHaglet<bool> routineDoorAnimate;

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		Haglet.Create(out routineDoorAnimate, (Routine.Func1<bool>)RoutineDoorAnimate, (string)null, startNow: false, (int?)null, (string)null);
	}

	[Event(EventName = "Animate Fireplace Backing Up")]
	public void AnimateUp(object sender)
	{
		bool flag = !LR.Inst.AreAllLoadedScenesAwake || !LR.Inst.IsAllConnectedSceneLoadingUnloadingComplete();
		fireplaceBacking[animationName].speed = 1f;
		if (!flag)
		{
			fireplaceBacking.CrossFade(animationName);
		}
		isUp = true;
		routineDoorAnimate.Start(isUp, resetIfStarted: true, flag);
	}

	[Event(EventName = "Animate Fireplace Backing Down")]
	public void AnimateDown(object sender)
	{
		bool flag = !LR.Inst.AreAllLoadedScenesAwake || !LR.Inst.IsAllConnectedSceneLoadingUnloadingComplete();
		fireplaceBacking[animationName].speed = -1f;
		if (!fireplaceBacking.isPlaying)
		{
			fireplaceBacking[animationName].time = fireplaceBacking[animationName].length;
		}
		if (!flag)
		{
			fireplaceBacking.CrossFade(animationName);
		}
		isUp = false;
		routineDoorAnimate.Start(isUp, resetIfStarted: true, flag);
	}

	private void SampleAnimation(float normalizedTime, AnimationState state)
	{
		state.enabled = true;
		state.weight = 1f;
		state.normalizedTime = normalizedTime;
		fireplaceBacking.Sample();
		state.enabled = false;
	}

	private IEnumerator<Routine.Yield> RoutineDoorAnimate(bool animUp)
	{
		if (!gearSoundInstance.isValid() && fireplaceGearsSound != null && !Routine.Skipping)
		{
			gearSoundInstance = FAC.Inst.PlayOneShot(fireplaceGearsSound, base.transform.TransformPoint(gearSoundPosition));
		}
		if (!moveSoundInstance.isValid() && fireplaceMoveSound != null && !Routine.Skipping)
		{
			moveSoundInstance = FAC.Inst.PlayOneShot(fireplaceMoveSound, base.transform.position);
		}
		if (!animUp)
		{
			if (fireplaceRegion.IsEnabled)
			{
				fireplaceRegion.Disable();
			}
			if (Routine.Skipping)
			{
				SampleAnimation(0f, fireplaceBacking[animationName]);
			}
			fireplaceFrontWall.SetActive(!animUp);
			yield return Wait.For.Seconds(fireplaceBacking[animationName].time);
			fireplaceLight.SetActive(!animUp);
			fireMainRoom.SetActive(!animUp);
		}
		else
		{
			fireplaceLight.SetActive(!animUp);
			fireMainRoom.SetActive(!animUp);
			if (Routine.Skipping)
			{
				SampleAnimation(1f, fireplaceBacking[animationName]);
			}
			yield return Wait.For.Seconds(fireplaceBacking[animationName].length - fireplaceBacking[animationName].time);
			fireplaceFrontWall.SetActive(!animUp);
			fireplaceRegion.Enable();
		}
		if (gearSoundInstance.isValid() && !Routine.Skipping)
		{
			gearSoundInstance.stop(STOP_MODE.ALLOWFADEOUT);
		}
		if (moveSoundInstance.isValid() && !Routine.Skipping)
		{
			moveSoundInstance.stop(STOP_MODE.ALLOWFADEOUT);
		}
	}
}
public class HAGIS_Tutorial_LookTarget : MonoBehaviour
{
	public float TimeToComplete = 1f;

	private float progress;

	public bool Completed => progress >= 1f;

	public void IncreaseProgress()
	{
		progress += IC.DeltaTime / TimeToComplete;
		progress = Mathf.Min(progress, 1f);
		if (Completed)
		{
			base.transform.localScale = Vector3.zero;
		}
		else
		{
			base.transform.localScale = Vector3.one * (1f + progress);
		}
	}
}
public class HAGIS_TutorialMovement : HAGIS
{
	public Portal startPortal;

	public Region portalRegion;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		startPortal.SetUnlockedState(unlocked: false, applyToLink: false);
		portalRegion.Disable();
		startPortal.gameObject.SetActive(value: false);
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		VOC.Inst.QueueVO("NEXUS_VO_demo_mansfield_001");
		VOC.VOResult vOResult = VOC.Inst.QueueVO("NEXUS_VO_demo_mansfield_002");
		yield return (vOResult.onComplete != null) ? ((Wait)vOResult.onComplete) : Wait.None;
		yield return Wait.For.Seconds(1f);
		startPortal.gameObject.SetActive(value: true);
		startPortal.SetUnlockedState(unlocked: true);
		portalRegion.Enable();
	}
}
public abstract class Tutorial_Base : MonoBehaviour, IAwakeEvent
{
	private struct AnimData
	{
		public Animation animComp;

		public string enterAnim;

		public string exitAnim;

		public string GetanimName(bool enter)
		{
			if (enter)
			{
				return enterAnim;
			}
			return exitAnim;
		}
	}

	public bool disableMovement;

	public bool triggerPathOnComplete = true;

	public Region stepRegion;

	public Region stepRegionAltA;

	public Region stepRegionAltB;

	[HideInInspector]
	public ParticlePathHandler pathHandler;

	private AnimData[] animations;

	[NonSerialized]
	[HideInInspector]
	private UIInfographic_Controller[] infographics;

	[Tooltip("The delay before anything appears")]
	public float DelayBefore;

	[Tooltip("The voice in")]
	public VOC.VOStore[] tutorialLines;

	[Tooltip("The delay after completion before stuff disappears")]
	public float DelayAfter;

	private IHaglet tutorialLogic;

	private IHaglet tutorialRoutine;

	private IHaglet<bool> animRoutine;

	public void OnAwakeLR(MRBase owner)
	{
		infographics = GetComponentsInChildren<UIInfographic_Controller>(includeInactive: true);
		Animation[] componentsInChildren = GetComponentsInChildren<Animation>();
		animations = new AnimData[componentsInChildren.Length];
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			animations[i].animComp = componentsInChildren[i];
			foreach (AnimationState item in componentsInChildren[i])
			{
				if (item.name.EndsWith("_In"))
				{
					animations[i].enterAnim = item.name;
				}
				else if (item.name.EndsWith("_Out"))
				{
					animations[i].exitAnim = item.name;
				}
			}
		}
		Haglet.Create(out tutorialRoutine, TutorialRoutine);
		Haglet.Create(out tutorialLogic, TutorialLogic);
		Haglet.Create(out animRoutine, (Routine.Func1<bool>)AnimRoutine, (string)null, startNow: false, (int?)null, (string)null);
		if (stepRegion != null && stepRegion.IsEnabled)
		{
			stepRegion.Disable();
		}
		if (stepRegionAltA != null && stepRegionAltA.IsEnabled)
		{
			stepRegionAltA.Disable();
		}
		if (stepRegionAltB != null && stepRegionAltB.IsEnabled)
		{
			stepRegionAltB.Disable();
		}
	}

	public Wait PlayTutorialStep()
	{
		return tutorialLogic.Start();
	}

	private void StartVO()
	{
		if (tutorialLines == null)
		{
			return;
		}
		for (int i = 0; i < tutorialLines.Length; i++)
		{
			VOC.VOStore vOStore = tutorialLines[i];
			if (!string.IsNullOrEmpty(vOStore.line))
			{
				VOC.Inst.QueueVO(vOStore.line, VOC.VOQueueProperty.Queue, vOStore.delay);
			}
		}
	}

	private void StartInfographics()
	{
		for (int i = 0; i < infographics.Length; i++)
		{
			infographics[i].StartInfographic();
		}
	}

	private IEnumerator<Routine.Yield> TutorialLogic()
	{
		TutorialSettings settings = BaseSettings<TutorialSettings>.Inst;
		yield return Wait.For.Seconds(DelayBefore);
		yield return animRoutine.Start(arg0: true);
		StartVO();
		StartInfographics();
		yield return tutorialRoutine.Start();
		yield return Wait.For.Updates(1);
		FAC.Inst.PlayOneShot(settings.stepCompletion, base.transform);
		if (triggerPathOnComplete)
		{
			pathHandler.ActivateNextPath();
		}
		yield return Wait.For.Seconds(DelayAfter);
		yield return animRoutine.Start(arg0: false);
	}

	protected abstract IEnumerator<Routine.Yield> TutorialRoutine();

	protected virtual IEnumerator<Routine.Yield> AnimRoutine(bool enter)
	{
		Wait wait = Wait.None;
		if (!Routine.Skipping)
		{
			AnimData[] array = animations;
			for (int i = 0; i < array.Length; i++)
			{
				AnimData animData = array[i];
				string text = animData.GetanimName(enter);
				if (!string.IsNullOrEmpty(text))
				{
					wait &= HAGIS.PlayAnim(animData.animComp, text);
				}
			}
		}
		else
		{
			AnimData[] array = animations;
			for (int i = 0; i < array.Length; i++)
			{
				AnimData animData2 = array[i];
				string value = animData2.GetanimName(enter);
				if (!string.IsNullOrEmpty(value))
				{
					animData2.animComp[value].enabled = true;
					animData2.animComp[value].normalizedTime = 1f;
					animData2.animComp[value].weight = 1f;
				}
			}
			yield return Wait.For.Updates(1);
		}
		for (int j = 0; j < infographics.Length; j++)
		{
			UIInfographic_Controller uIInfographic_Controller = infographics[j];
			Wait wait2 = uIInfographic_Controller.dissolveRoutine.Start(uIInfographic_Controller.settings.DissolveDuration, enter);
			wait &= wait2;
		}
		yield return wait;
	}
}
public class Tutorial_Chain : Tutorial_Base
{
	public Transform tutorialInteractChainObject;

	public Transform tutorialInteractChainTarget;

	protected override IEnumerator<Routine.Yield> TutorialRoutine()
	{
		while (!((tutorialInteractChainTarget.position - tutorialInteractChainObject.position).magnitude < 0.1f))
		{
			yield return Wait.For.LRUpdates(1);
			if (Routine.Skipping)
			{
				yield return Routine.Yield.SpecialIndex.StopSkipping;
				break;
			}
		}
	}
}
public class Tutorial_Cutscene : Tutorial_Base
{
	public HAGIS_Cutscene_Base tutorialCutscene;

	public IDObjectRef tutorialGrabObject;

	protected override IEnumerator<Routine.Yield> TutorialRoutine()
	{
		GrabObject grabobject = tutorialGrabObject.Get<GrabObject>();
		stepRegionAltA.Enable();
		if (!LR.Inst.saveDataGame.stationComplete)
		{
			LR.Inst.HACK_radioRoutine.Start();
		}
		yield return Wait.For.Seconds(1f);
		PlayerInventory.Inst.RemoveFromInventory(grabobject);
		grabobject.ForceBreak();
		yield return tutorialCutscene.IsTriggered;
	}
}
public class Tutorial_GrabAndInventory : Tutorial_Base
{
	public IDObjectRef tutorialGrabObject;

	public Animation tableBall;

	public Animation placementTable;

	public Animation cage;

	public UIInfographic_Controller takeBall;

	public UIInfographic_Controller takeBallExtra;

	public UIInfographic_Controller placeBall;

	public UIInfographic_Controller retrieveBall;

	public UIInfographic_Controller retrieveBallExtra;

	public VOC.VOStore VO_takeBall;

	public VOC.VOStore VO_placeBall;

	public VOC.VOStore VO_openInventory;

	public VOC.VOStore VO_grabInventoryBall;

	public PlacementHelper tutorialPlacementHelper;

	protected override IEnumerator<Routine.Yield> TutorialRoutine()
	{
		GrabObject grabobject = tutorialGrabObject.Get<GrabObject>();
		grabobject.canBeGrabbed = false;
		tableBall.gameObject.SetActive(value: true);
		takeBall.gameObject.SetActive(value: true);
		takeBallExtra.gameObject.SetActive(value: true);
		yield return HAGIS.PlayAnim(tableBall, "AN_TutorialBall_In") & takeBall.dissolveRoutine.Start(takeBall.settings.DissolveDuration, arg1: true) & takeBallExtra.dissolveRoutine.Start(takeBallExtra.settings.DissolveDuration, arg1: true);
		if (!string.IsNullOrEmpty(VO_takeBall.line))
		{
			VOC.Inst.QueueVO(VO_takeBall.line, VOC.VOQueueProperty.Queue, VO_takeBall.delay);
		}
		grabobject.canBeGrabbed = true;
		yield return grabobject.OnObjectGrabbed;
		yield return takeBall.dissolveRoutine.Start(takeBall.settings.DissolveDuration, arg1: false) & takeBallExtra.dissolveRoutine.Start(takeBallExtra.settings.DissolveDuration, arg1: false) & HAGIS.PlayAnim(tableBall, "AN_TutorialBall_Out");
		tableBall.gameObject.SetActive(value: false);
		takeBall.gameObject.SetActive(value: false);
		takeBallExtra.gameObject.SetActive(value: false);
		stepRegionAltA.Enable();
		yield return Wait.For.Updates(1);
		stepRegion.Disable();
		placementTable.gameObject.SetActive(value: true);
		placeBall.gameObject.SetActive(value: true);
		yield return HAGIS.PlayAnim(placementTable, "AN_TutorialPlaceObject_In") & placeBall.dissolveRoutine.Start(placeBall.settings.DissolveDuration, arg1: true);
		if (!string.IsNullOrEmpty(VO_placeBall.line))
		{
			VOC.Inst.QueueVO(VO_placeBall.line, VOC.VOQueueProperty.Queue, VO_placeBall.delay);
		}
		yield return Wait.Until.True(() => tutorialPlacementHelper.HeldGrabObject);
		grabobject.canBeGrabbed = false;
		PlayerInventory.InventoryEnabled.Value = false;
		yield return placeBall.dissolveRoutine.Start(placeBall.settings.DissolveDuration, arg1: false);
		placeBall.gameObject.SetActive(value: false);
		stepRegionAltB.Enable();
		yield return Wait.For.Updates(1);
		stepRegionAltA.Disable();
		cage.gameObject.SetActive(value: true);
		retrieveBall.gameObject.SetActive(value: true);
		retrieveBallExtra.gameObject.SetActive(value: true);
		yield return HAGIS.PlayAnim(cage, "AN_TutorialBirdcage_In") & retrieveBall.dissolveRoutine.Start(retrieveBall.settings.DissolveDuration, arg1: true) & retrieveBallExtra.dissolveRoutine.Start(retrieveBallExtra.settings.DissolveDuration, arg1: true);
		if (!string.IsNullOrEmpty(VO_openInventory.line))
		{
			VOC.Inst.QueueVO(VO_openInventory.line, VOC.VOQueueProperty.Queue, VO_openInventory.delay);
		}
		PlayerInventory.InventoryEnabled.Value = true;
		yield return Wait.Until.True(() => PlayerInventory.Inst.IsInventoryOpen());
		if (!string.IsNullOrEmpty(VO_grabInventoryBall.line))
		{
			VOC.Inst.QueueVO(VO_grabInventoryBall.line, VOC.VOQueueProperty.Queue, VO_grabInventoryBall.delay);
		}
		yield return grabobject.OnInventoryGrabbed;
		grabobject.canBeGrabbed = true;
		yield return HAGIS.PlayAnim(cage, "AN_TutorialBirdcage_Out") & HAGIS.PlayAnim(placementTable, "AN_TutorialPlaceObject_Out") & retrieveBall.dissolveRoutine.Start(retrieveBall.settings.DissolveDuration, arg1: false) & retrieveBallExtra.dissolveRoutine.Start(retrieveBallExtra.settings.DissolveDuration, arg1: false);
		retrieveBall.gameObject.SetActive(value: false);
		retrieveBallExtra.gameObject.SetActive(value: false);
		cage.gameObject.SetActive(value: false);
		placementTable.gameObject.SetActive(value: false);
		stepRegion.Enable();
		yield return Wait.For.Updates(1);
		stepRegionAltB.Disable();
	}

	protected override IEnumerator<Routine.Yield> AnimRoutine(bool enter)
	{
		yield break;
	}
}
public class Tutorial_Lever : Tutorial_Base
{
	public FixedRotatableObject tutorialInteractLever;

	protected override IEnumerator<Routine.Yield> TutorialRoutine()
	{
		while (!(tutorialInteractLever.GetAngle() > 39f))
		{
			yield return Wait.For.LRUpdates(1);
			if (Routine.Skipping)
			{
				yield return Routine.Yield.SpecialIndex.StopSkipping;
				break;
			}
		}
	}
}
public class Tutorial_Move : Tutorial_Base
{
	public Trigger[] tutorialMoveTriggers;

	protected override IEnumerator<Routine.Yield> TutorialRoutine()
	{
		TutorialSettings settings = BaseSettings<TutorialSettings>.Inst;
		int targetIndex = 0;
		tutorialMoveTriggers[targetIndex].gameObject.SetActive(value: true);
		while (true)
		{
			if (tutorialMoveTriggers[targetIndex].IsInsideBool || Routine.Skipping)
			{
				tutorialMoveTriggers[targetIndex].gameObject.SetActive(value: false);
				targetIndex++;
				if (targetIndex < tutorialMoveTriggers.Length)
				{
					pathHandler.ActivateNextPath();
					FAC.Inst.PlayOneShot(settings.actionCompletion, base.transform);
					tutorialMoveTriggers[targetIndex].gameObject.SetActive(value: true);
				}
			}
			if (targetIndex >= tutorialMoveTriggers.Length)
			{
				break;
			}
			yield return Wait.For.LRUpdates(1);
		}
		if (Routine.Skipping)
		{
			yield return Routine.Yield.SpecialIndex.StopSkipping;
		}
	}
}
public class Tutorial_PlaySpace : Tutorial_Base
{
	protected override IEnumerator<Routine.Yield> TutorialRoutine()
	{
		while (true)
		{
			Vector3 lhs = IC.GetHeadRotation() * Vector3.forward;
			if (!(57.29578f * Mathf.Acos(Vector3.Dot(lhs, Vector3.down)) < 30f))
			{
				yield return Wait.For.LRUpdates(1);
				if (Routine.Skipping)
				{
					yield return Routine.Yield.SpecialIndex.StopSkipping;
					break;
				}
				continue;
			}
			break;
		}
	}
}
public class Tutorial_Teleport : Tutorial_Base
{
	public Telepoint tutorialTelepoint;

	protected override IEnumerator<Routine.Yield> TutorialRoutine()
	{
		tutorialTelepoint.gameObject.SetActive(value: true);
		while (tutorialTelepoint.OnTeleport.happenCount == 0L)
		{
			yield return Wait.For.LRUpdates(1);
			if (Routine.Skipping)
			{
				yield return Routine.Yield.SpecialIndex.StopSkipping;
				break;
			}
		}
	}
}
public class Tutorial_Turning : Tutorial_Base
{
	protected override IEnumerator<Routine.Yield> TutorialRoutine()
	{
		TutorialSettings settings = BaseSettings<TutorialSettings>.Inst;
		IC.IHandInput rightHandInput = IC.GetInputForHand(IC.Hand.Right);
		bool turnedLeft = false;
		bool turnedRight = false;
		while (true)
		{
			bool flag = rightHandInput.GetAxis().magnitude > 0.2f;
			bool flag2 = !turnedLeft && !turnedRight && flag;
			if (!LR.Inst.IsPaused && flag)
			{
				turnedLeft |= rightHandInput.GetAxis().x < -0.2f;
				turnedRight |= rightHandInput.GetAxis().x > 0.2f;
			}
			if (!(turnedLeft && turnedRight))
			{
				if (flag2)
				{
					FAC.Inst.PlayOneShot(settings.actionCompletion, base.transform);
				}
				yield return Wait.For.LRUpdates(1);
				if (Routine.Skipping)
				{
					yield return Routine.Yield.SpecialIndex.StopSkipping;
					break;
				}
				continue;
			}
			break;
		}
	}
}
public class Tutorial_Wheel : Tutorial_Base
{
	public InteractableTarget_Animation targetAnimation;

	protected override IEnumerator<Routine.Yield> TutorialRoutine()
	{
		while (!(targetAnimation.normalisedPostion >= 0.99f))
		{
			yield return Wait.For.LRUpdates(1);
			if (Routine.Skipping)
			{
				yield return Routine.Yield.SpecialIndex.StopSkipping;
				break;
			}
		}
	}
}
public class HAGIS_Vault_ExitPhase : HAGIS
{
	public IDObjectRef grabObjectRef;

	public Light puzzleLight;

	public Transform lightStand;

	public Transform dome;

	public IDObjectRef demoEntryPoint;

	public Vault_Pillar[] vaultPillars;

	public FMODEventAsset vaultMusic;

	public FMODEventAsset vaultFinalMusic;

	public VO_Asset voFirstMeetingEnd;

	private VaultSettings settings;

	private IHaglet<SaveDataGame.Chapter> pillarEffectRoutine;

	private IHaglet<Vault_Pillar> lightRoutine;

	private IHaglet domeRoutine;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		Haglet.Create(out pillarEffectRoutine, (Routine.Func1<SaveDataGame.Chapter>)PillarEffectRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out lightRoutine, (Routine.Func1<Vault_Pillar>)LightRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out domeRoutine, DomeRoutine);
		LR lr = LR.Inst;
		settings = BaseSettings<VaultSettings>.Inst;
		FAC.Inst.PlayOneShot(settings.soundMirrorTeleport, CC.Inst.transform);
		SaveDataGame.Chapter currentChapter = ((LR.Inst.saveDataGame.lastChapter == SaveDataGame.Chapter.None) ? CC.Inst.currentChapter : LR.Inst.saveDataGame.lastChapter);
		if (lr.saveDataGame.GetChapterVaultEnteredState(currentChapter))
		{
			LR.Inst.LoadAdjacentScenes(forceReload: true);
		}
		FMODEventAsset music = ((currentChapter == SaveDataGame.Chapter.FirstMeeting) ? vaultFinalMusic : vaultMusic);
		LR.Inst.SetMusic(music);
		lr.saveDataGame.SetChapterVaultEnterStatus(currentChapter, entered: true);
		lr.saveDataGame.SetLastLevelInChapter(currentChapter, owner.info.Load().sceneUIDName);
		yield return lr.Save();
		if (currentChapter == SaveDataGame.Chapter.FirstMeeting)
		{
			VO_Asset.VO_Section[] voiceSections = voFirstMeetingEnd.voiceSections;
			foreach (VO_Asset.VO_Section vO_Section in voiceSections)
			{
				for (int j = 0; j < vO_Section.voiceLines.Length; j++)
				{
					VOC.Inst.QueueVO(vO_Section.voiceLines[j].line, VOC.VOQueueProperty.Queue, vO_Section.voiceLines[j].delay);
				}
			}
		}
		yield return lr.IsAllConnectedScenesLoaded;
		Vault_Pillar pillar = vaultPillars[GetPillarIndex(currentChapter)];
		pillar.telepoint.Show();
		GrabObject grabObject = lr.GetIDObjectComponent<GrabObject>(grabObjectRef, this);
		grabObject.ResetToInitialState();
		MultiDirectionPlayerEntryPoint iDObjectComponent = lr.GetIDObjectComponent<MultiDirectionPlayerEntryPoint>(demoEntryPoint, this);
		iDObjectComponent.SetPositionAndRotation(currentChapter);
		Vector3 entryPos = iDObjectComponent.transform.position;
		Quaternion entryRot = iDObjectComponent.transform.rotation;
		if (!grabObject.hasBeenGrabbed)
		{
			yield return grabObject.OnObjectGrabbed;
		}
		pillarEffectRoutine.Start(currentChapter);
		yield return lightRoutine.Start(pillar) & domeRoutine.Start();
		yield return pillar.rasterizer.puzzleInfo.UntilComplete(SaveDataGame.PuzzleSaveType.Scene);
		if (currentChapter != SaveDataGame.Chapter.FirstMeeting)
		{
			LR.Inst.StopMusic();
		}
		LR.Inst.saveDataGame.lastChapter = SaveDataGame.Chapter.None;
		if (PlayerInventory.Inst.inventoryState != null)
		{
			PlayerInventory.Inst.EmptyInventory(fromSaveData: false);
		}
		grabObject.ForceBreak();
		yield return pillar.constellation.FillConstellation();
		pillar.pillarGlow.SetActive(value: true);
		pillar.pillarFlame.SetActive(value: true);
		FAC.Inst.PlayOneShot(settings.soundPillarFlame, pillar.pillarFlame.transform.position);
		FAC.Inst.PlayOneShot(settings.soundPillarFlame2D, pillar.pillarFlame.transform.position);
		pillar.pillarFlameMat.SetFloat("_Boost", 0f);
		pillar.pillarGlowMat.SetFloat("_Intensity", 0f);
		float glowTimer = 0f;
		float flameTimer2 = 0f;
		while (glowTimer < settings.glowtime || flameTimer2 < settings.flameTime)
		{
			yield return Wait.For.LRUpdates(1);
			glowTimer += IC.DeltaTime;
			flameTimer2 += IC.DeltaTime;
			float t = settings.glowCurve.Evaluate(glowTimer / settings.glowtime);
			float t2 = settings.flameCurve.Evaluate(flameTimer2 / settings.flameTime);
			float value = Mathf.Lerp(0f, settings.glowIntensity, t);
			float value2 = Mathf.Lerp(0f, settings.flameBoost, t2);
			pillar.pillarGlowMat.SetFloat("_Intensity", value);
			pillar.pillarFlameMat.SetFloat("_Boost", value2);
		}
		yield return Wait.For.Seconds(settings.whiteFadeDelay) & VOC.Inst.IsFree;
		lr.saveDataGame.SetChapterVaultEnterStatus(currentChapter, entered: false);
		yield return lr.Save();
		NexusFullScreenPass.Inst.StartFadeToColor(settings.whiteFadeInTime, NexusFullScreenPass.offWhite);
		IC.Inst.PauseMenuEnabled = false;
		IC.Inst.RecenterEnabled = false;
		PlayerTeleport.TeleportEnabled.Value = false;
		flameTimer2 = 0f;
		Vector3 orginalScale = pillar.pillarFlame.transform.localScale;
		while (flameTimer2 < settings.whiteFadeInTime)
		{
			yield return Wait.For.LRUpdates(1);
			flameTimer2 += IC.DeltaTime;
			float t3 = settings.flameCurve.Evaluate(flameTimer2 / settings.whiteFadeInTime);
			Vector3 localScale = Vector3.Lerp(orginalScale, new Vector3(0.6f, 0.6f, 0.6f), t3);
			pillar.pillarFlame.transform.localScale = localScale;
		}
		SceneInfo sceneInfoWithSceneUIDName = LR.Inst.GetSceneInfoWithSceneUIDName("suez");
		LR.Inst.LoadPlayerIntoScene(sceneInfoWithSceneUIDName, entryPos, entryRot, shouldFadeToClearAtEndOfRoutine: true);
	}

	private IEnumerator<Routine.Yield> PillarEffectRoutine(SaveDataGame.Chapter chapter)
	{
		int pillarIndex = GetPillarIndex(chapter);
		int leftIndex = pillarIndex - 1;
		int rightIndex = pillarIndex + 1;
		bool flag = false;
		vaultPillars[pillarIndex].Move(Vault_Pillar.VaultPillarAnims.UP);
		while (!flag)
		{
			yield return Wait.For.Seconds(0.5f);
			if (leftIndex >= 0)
			{
				vaultPillars[leftIndex].Move(Vault_Pillar.VaultPillarAnims.DOWN);
			}
			if (rightIndex < vaultPillars.Length)
			{
				vaultPillars[rightIndex].Move(Vault_Pillar.VaultPillarAnims.DOWN);
			}
			leftIndex--;
			rightIndex++;
			flag = leftIndex < 0 && rightIndex > vaultPillars.Length - 1;
		}
	}

	private IEnumerator<Routine.Yield> LightRoutine(Vault_Pillar pillar)
	{
		FMOD.Studio.EventInstance evt = FAC.Inst.PlayOneShot(settings.soundClockTurn, lightStand.position);
		float timer = 0f;
		while (timer < pillar.lightRotTime)
		{
			yield return Wait.For.LRUpdates(1);
			timer += IC.DeltaTime;
			float time = timer / pillar.lightRotTime;
			lightStand.rotation = Quaternion.Lerp(Quaternion.identity, Quaternion.Euler(0f, pillar.lightRot, 0f), settings.lightTurnCurve.Evaluate(time));
		}
		evt.stop(STOP_MODE.ALLOWFADEOUT);
		puzzleLight.gameObject.SetActive(value: true);
	}

	private IEnumerator<Routine.Yield> DomeRoutine()
	{
		Vector3 originalHeight = dome.position;
		Vector3 target = originalHeight - Vector3.up * settings.domeLowerAmount;
		float timer = 0f;
		while (timer < settings.domeLowerTime)
		{
			yield return Wait.For.LRUpdates(1);
			timer += IC.DeltaTime;
			float time = timer / settings.domeLowerTime;
			dome.position = Vector3.Lerp(originalHeight, target, settings.domeLowerCurve.Evaluate(time));
		}
	}

	private int GetPillarIndex(SaveDataGame.Chapter chapter)
	{
		for (int i = 0; i < vaultPillars.Length; i++)
		{
			if (vaultPillars[i].pillarsChapter == chapter)
			{
				return i;
			}
		}
		return 0;
	}
}
public class HAGIS_Vault_HideOnFrustumAway : HAGIS
{
	public FrustumDetector3D frustum;

	public Portal portal;

	public float minDistance;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return Wait.Until.True(() => frustum.IsNotInViewBool && Vector3.Distance(CC.Inst.transform.position, portal.transform.position) > minDistance);
		portal.gameObject.SetActive(value: false);
	}
}
public class HAGIS_Workshop_A_MAIN : HAGIS
{
	public GameObject lornaGameObj;

	public float exitDoorsAnimSpeed;

	public HAGIS_Simple_Cutscene cutscene;

	public IDObjectRef mirrorRotatorRef;

	[Header("Puzzles")]
	public PuzzleInfo puzzle1;

	public PuzzleInfo puzzle2;

	public PuzzleInfo puzzle3;

	public PuzzleInfo puzzle4;

	public PuzzleInfo puzzle5;

	[Header("Animations")]
	public Doorway firstDoorway;

	public Doorway exitDoorway;

	[Header("Door Transforms for Dust Particles")]
	public Transform firstDoor;

	public Transform exitDoor;

	[Header("Regions")]
	public IDObjectRef startRegionRef;

	public IDObjectRef secondRegionRef;

	public IDObjectRef largeRoomRegionRef;

	public IDObjectRef balconyRegionRef;

	[Header("Telepoints")]
	public GameObject p1Telepoint;

	public GameObject p2Telepoint;

	public GameObject p3Telepoint;

	public GameObject p4Telepoint;

	public GameObject p5Telepoint;

	public GameObject cutSceneTelepoint;

	[Header("Triggers")]
	public IDObjectRef balconyTriggerRef;

	[Header("Portals")]
	public IDObjectRef portalToUpstairsRef;

	public IDObjectRef portalToDownstairsRef;

	[Header("Look At Detetector")]
	public IDObjectRef exitDoorlookAtDetector;

	[Header("Finlay")]
	public AnimPathNodeBehaviourFinlayPetting finlay;

	[Header("Door")]
	public FMODEventAsset doorUnlock;

	public GameObject door;

	[Header("Lights")]
	public LightSource p1PuzzleLight;

	public LightSource p3PuzzleLight;

	public LightSource p4PuzzleLight;

	public LightSource p5PuzzleLight;

	[Header("Music & Sounds")]
	public FMODEventAsset entryMusic;

	public FMODEventAsset cutsceneMusic;

	public FMODEventAsset transferMusic;

	public IDObjectRef transferGrabObject;

	public Portal transferPortal;

	public FMODEventAsset soundMirrorTurn;

	public FMODEventAsset soundFinlayAttention;

	[Header("Feather")]
	public HAGIS_Workshop_Feather featherHagis;

	protected override void OnHagisAwake()
	{
		p1PuzzleLight.DisableLight();
		p3PuzzleLight.DisableLight();
		p4PuzzleLight.DisableLight();
		p5PuzzleLight.DisableLight();
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		Region region2 = LR.Inst.GetIDObjectComponent<Region>(secondRegionRef);
		Region region3 = LR.Inst.GetIDObjectComponent<Region>(largeRoomRegionRef);
		Region balconyPortal = LR.Inst.GetIDObjectComponent<Region>(balconyRegionRef);
		Trigger balconyTrigger = LR.Inst.GetIDObjectComponent<Trigger>(balconyTriggerRef);
		Portal portalToUpstairs = LR.Inst.GetIDObjectComponent<Portal>(portalToUpstairsRef);
		Portal portalToDownstairs = LR.Inst.GetIDObjectComponent<Portal>(portalToDownstairsRef);
		LookAtDetector doorLookAtDetector = LR.Inst.GetIDObjectComponent<LookAtDetector>(exitDoorlookAtDetector);
		LR.Inst.SetMusic(entryMusic);
		AnimRotateToTarget mirrorRotator = LR.Inst.GetIDObjectComponent<AnimRotateToTarget>(mirrorRotatorRef);
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		portalToUpstairs.SetUnlockedState(unlocked: false);
		portalToDownstairs.SetUnlockedState(unlocked: false);
		region2.Disable();
		region3.Disable();
		balconyPortal.Disable();
		p2Telepoint.SetActive(value: false);
		p3Telepoint.SetActive(value: false);
		p4Telepoint.SetActive(value: false);
		p5Telepoint.SetActive(value: false);
		cutSceneTelepoint.SetActive(value: false);
		yield return Wait.For.Seconds(1f);
		lornaGameObj.SetActive(value: true);
		p1PuzzleLight.EnableLight();
		yield return WaitForPuzzle(puzzle1);
		LR.Inst.StopMusic();
		firstDoorway.Open();
		PSC.Inst.PlayAt(ParticleType.Door_Dust_Indoor, firstDoor.transform.position).transform.rotation = firstDoor.transform.rotation;
		yield return Wait.For.Seconds(1f);
		p1Telepoint.SetActive(value: false);
		cutSceneTelepoint.SetActive(value: true);
		p1PuzzleLight.DisableLight();
		yield return CHECKPOINT();
		yield return cutscene.IsTriggered;
		yield return cutscene.IsComplete;
		region2.Enable();
		region3.Enable();
		lornaGameObj.SetActive(value: false);
		yield return Wait.For.Seconds(1.1f);
		if (!finlay.enabled)
		{
			FAC.Inst.PlayOneShot(soundFinlayAttention, finlay.transform);
		}
		cutSceneTelepoint.SetActive(value: false);
		p2Telepoint.SetActive(value: true);
		p3PuzzleLight.EnableLight();
		LR.Inst.SetMusic(cutsceneMusic);
		yield return CHECKPOINT();
		yield return WaitForPuzzle(puzzle2);
		p2Telepoint.SetActive(value: false);
		FAC.Inst.PlayOneShot(soundMirrorTurn, mirrorRotator.transform.position);
		yield return mirrorRotator.AnimateOnYield(Quaternion.Euler(0f, -180f, 0f), 3f, localRotation: true);
		p2Telepoint.SetActive(value: false);
		p3Telepoint.SetActive(value: true);
		yield return CHECKPOINT();
		yield return WaitForPuzzle(puzzle3);
		portalToDownstairs.SetUnlockedState(unlocked: true);
		portalToUpstairs.SetUnlockedState(unlocked: true);
		p4Telepoint.SetActive(value: true);
		p3Telepoint.SetActive(value: false);
		balconyPortal.Enable();
		p3PuzzleLight.DisableLight();
		p4PuzzleLight.EnableLight();
		yield return balconyTrigger.OnInsidePremet;
		LR.Inst.StopMusic();
		yield return CHECKPOINT();
		GrabObject component = transferGrabObject.GetComponent<GrabObject>();
		yield return component.OnObjectGrabbed | component.OnObjectFocusGrabbed;
		yield return transferPortal.objectEnteredPortal | WaitForPuzzle(puzzle4);
		yield return Wait.For.LRUpdates(1);
		yield return transferPortal.objectEnteredPortal | WaitForPuzzle(puzzle4);
		LR.Inst.SetMusic(transferMusic);
		yield return WaitForPuzzle(puzzle4);
		p4Telepoint.SetActive(value: false);
		p5Telepoint.SetActive(value: true);
		p4PuzzleLight.DisableLight();
		p5PuzzleLight.EnableLight();
		yield return CHECKPOINT();
		yield return WaitForPuzzle(puzzle5);
		p5PuzzleLight.DisableLight();
		LR.Inst.StopMusic();
		FAC.Inst.PlayOneShot(doorUnlock, door.transform.position);
		p5Telepoint.SetActive(value: false);
		if (!Routine.Skipping)
		{
			yield return doorLookAtDetector.IsInView;
		}
		exitDoorway.Open();
		PSC.Inst.PlayAt(ParticleType.Door_Dust_Indoor, exitDoor.transform.position).transform.rotation = exitDoor.transform.rotation;
		yield return Wait.For.Seconds(1.5f);
	}
}
public class HAGIS_Workshop_A_TradableMirrorTelepoint : HAGIS
{
	public PuzzleInfo puzzle5Info;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return WaitForPuzzle(puzzle5Info);
	}
}
public class HAGIS_Workshop_C_MAIN : HAGIS
{
	public GameObject lornaGameObj;

	public float exitDoorsAnimSpeed;

	public HAGIS_Simple_Cutscene cutscene;

	public IDObjectRef mirrorRotatorRef;

	[Header("Puzzles")]
	public IDObjectRef p1Ref;

	public IDObjectRef p2Ref;

	public IDObjectRef p3Ref;

	public IDObjectRef p4Ref;

	public IDObjectRef p5Ref;

	public PuzzleInfo puzzle1;

	public PuzzleInfo puzzle2;

	public PuzzleInfo puzzle3;

	public PuzzleInfo puzzle4;

	public PuzzleInfo puzzle5;

	[Header("Animations")]
	public Animation firstDoorAnim;

	public Animation exitDoorAnim;

	[Header("Regions")]
	public IDObjectRef startRegionRef;

	public IDObjectRef cutsceneRegionRef;

	public IDObjectRef secondRegionRef;

	public IDObjectRef largeRoomRegionRef;

	public IDObjectRef exitRoomRegionRef;

	public IDObjectRef balconyRegionRef;

	[Header("Telepoints")]
	public GameObject p1Telepoint;

	public GameObject p2Telepoint;

	public GameObject p3Telepoint;

	public GameObject p4Telepoint;

	public GameObject p5Telepoint;

	public GameObject cutSceneTelepoint;

	public GameObject tradeMirrorTelepoint;

	[Header("Triggers")]
	public IDObjectRef balconyTriggerRef;

	[Header("Portals")]
	public IDObjectRef portalToUpstairsRef;

	public IDObjectRef portalToDownstairsRef;

	[Header("Look At Detetector")]
	public IDObjectRef exitDoorlookAtDetector;

	[Header("Finlay")]
	public AnimPathNodeBehaviourPetAndThrow finlay;

	[Header("Door")]
	public FMODEventAsset doorUnlock;

	public GameObject door;

	[Header("Lights")]
	public LightSource p1PuzzleLightSrc;

	public LightSource p3PuzzleLightSrc;

	public LightSource p4PuzzleLightSrc;

	public LightSource p5PuzzleLightSrc;

	[Header("Music & Sounds")]
	public FMODEventAsset entryMusic;

	public FMODEventAsset cutsceneMusic;

	public FMODEventAsset soundMirrorTurn;

	public FMODEventAsset soundFinlayAttention;

	[Header("Feather")]
	public HAGIS_Workshop_Feather featherHagis;

	[Header("Portal Items")]
	public HAGIS_Prototype_MirrorMovementEffect mirrorMovementHagis;

	protected override void OnHagisAwake()
	{
		p1PuzzleLightSrc.DisableLight();
		p3PuzzleLightSrc.DisableLight();
		p4PuzzleLightSrc.DisableLight();
		p5PuzzleLightSrc.DisableLight();
	}

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		Region region1 = LR.Inst.GetIDObjectComponent<Region>(cutsceneRegionRef);
		Region region2 = LR.Inst.GetIDObjectComponent<Region>(secondRegionRef);
		Region region3 = LR.Inst.GetIDObjectComponent<Region>(largeRoomRegionRef);
		Region region4 = LR.Inst.GetIDObjectComponent<Region>(exitRoomRegionRef);
		Region balconyPortal = LR.Inst.GetIDObjectComponent<Region>(balconyRegionRef);
		Trigger balconyTrigger = LR.Inst.GetIDObjectComponent<Trigger>(balconyTriggerRef);
		Portal portalToUpstairs = LR.Inst.GetIDObjectComponent<Portal>(portalToUpstairsRef);
		Portal portalToDownstairs = LR.Inst.GetIDObjectComponent<Portal>(portalToDownstairsRef);
		LookAtDetector doorLookAtDetector = LR.Inst.GetIDObjectComponent<LookAtDetector>(exitDoorlookAtDetector);
		LR.Inst.SetMusic(entryMusic);
		AnimRotateToTarget mirrorRotator = LR.Inst.GetIDObjectComponent<AnimRotateToTarget>(mirrorRotatorRef);
		yield return LR.Inst.IsAllConnectedScenesLoaded;
		portalToUpstairs.SetUnlockedState(unlocked: false);
		portalToDownstairs.SetUnlockedState(unlocked: false);
		region1.Disable();
		region2.Disable();
		region3.Disable();
		region4.Disable();
		balconyPortal.Disable();
		p2Telepoint.SetActive(value: false);
		p3Telepoint.SetActive(value: false);
		p4Telepoint.SetActive(value: false);
		p5Telepoint.SetActive(value: false);
		cutSceneTelepoint.SetActive(value: false);
		tradeMirrorTelepoint.SetActive(value: false);
		yield return Wait.For.Seconds(1f);
		lornaGameObj.SetActive(value: true);
		p1PuzzleLightSrc.EnableLight();
		yield return WaitForPuzzle(puzzle1);
		LR.Inst.StopMusic();
		HAGIS.PlayAnim(firstDoorAnim);
		yield return Wait.For.Seconds(1f);
		region1.Enable();
		p1Telepoint.SetActive(value: false);
		cutSceneTelepoint.SetActive(value: true);
		p1PuzzleLightSrc.DisableLight();
		yield return CHECKPOINT();
		yield return cutscene.IsTriggered;
		yield return cutscene.IsComplete;
		region2.Enable();
		region3.Enable();
		lornaGameObj.SetActive(value: false);
		yield return Wait.For.Seconds(1.1f);
		if (!finlay.HasFlownAway)
		{
			FAC.Inst.PlayOneShot(soundFinlayAttention, finlay.transform);
		}
		cutSceneTelepoint.SetActive(value: false);
		p2Telepoint.SetActive(value: true);
		p3Telepoint.SetActive(value: true);
		p3PuzzleLightSrc.EnableLight();
		LR.Inst.SetMusic(cutsceneMusic);
		yield return CHECKPOINT();
		yield return WaitForPuzzle(puzzle2);
		p2Telepoint.SetActive(value: false);
		FAC.Inst.PlayOneShot(soundMirrorTurn, mirrorRotator.transform.position);
		yield return mirrorRotator.AnimateOnYield(Quaternion.Euler(0f, 0f, 0f), 3f, localRotation: true);
		p2Telepoint.SetActive(value: false);
		p3Telepoint.SetActive(value: true);
		yield return CHECKPOINT();
		yield return WaitForPuzzle(puzzle3);
		portalToDownstairs.SetUnlockedState(unlocked: true);
		portalToUpstairs.SetUnlockedState(unlocked: true);
		p4Telepoint.SetActive(value: true);
		tradeMirrorTelepoint.SetActive(value: true);
		p3Telepoint.SetActive(value: false);
		balconyPortal.Enable();
		p3PuzzleLightSrc.DisableLight();
		p4PuzzleLightSrc.EnableLight();
		yield return balconyTrigger.OnInsidePremet;
		LR.Inst.StopMusic();
		yield return CHECKPOINT();
		mirrorMovementHagis.StartMovement();
		yield return WaitForPuzzle(puzzle4);
		p4Telepoint.SetActive(value: false);
		p5Telepoint.SetActive(value: true);
		p4PuzzleLightSrc.DisableLight();
		p5PuzzleLightSrc.EnableLight();
		yield return CHECKPOINT();
		yield return WaitForPuzzle(puzzle5);
		p5PuzzleLightSrc.DisableLight();
		LR.Inst.StopMusic();
		FAC.Inst.PlayOneShot(doorUnlock, door.transform.position);
		p5Telepoint.SetActive(value: false);
		yield return doorLookAtDetector.IsInView;
		HAGIS.PlayAnim(exitDoorAnim);
		yield return Wait.For.Seconds(1.5f);
		region4.Enable();
	}
}
public class HAGIS_Workshop_C_TradableMirrorTelepoint : HAGIS
{
	public IDObjectRef obeliskRef;

	public IDObjectRef puzzle5Ref;

	public PuzzleInfo puzzle5;

	public GameObject tradeMirrorTelepoint;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		yield return WaitForPuzzle(puzzle5);
		tradeMirrorTelepoint.SetActive(value: false);
	}
}
public class HAGIS_Workshop_Feather : HAGIS
{
	private readonly string animPart1 = "CH_Feather_WorkshopPart1";

	private readonly string animIdle1 = "CH_Feather_WorkshopIdle1";

	private readonly string animPart2 = "CH_Feather_WorkshopPart2";

	private readonly string animIdle2 = "CH_Feather_WorkshopIdle2";

	private readonly string animPart3 = "CH_Feather_WorkshopPart3";

	private readonly int _DissolveAmount = Shader.PropertyToID("_DissolveAmount");

	public Animation featherAnim;

	public Trigger startTrigger;

	public Transform mirrorXform;

	public Transform targetBone;

	public float minIdleSkipDistance = 0.5f;

	public float minDissolveDistance = 1f;

	public ParticleSystem flakes;

	private SkinnedMeshRenderer skinMeshRenderer;

	private MaterialPropertyBlock mpb;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		if (mirrorXform == null)
		{
			mirrorXform = base.transform.parent.GetComponentInChildren<Portal>().transform;
		}
		skinMeshRenderer = GetComponentInChildren<SkinnedMeshRenderer>();
		mpb = new MaterialPropertyBlock();
		featherAnim[animPart1].time = 0f;
		featherAnim[animPart1].weight = 1f;
		featherAnim[animPart1].enabled = true;
		featherAnim.Sample();
		featherAnim[animPart1].enabled = false;
		yield return startTrigger.OnInside;
		yield return Wait.For.Seconds(featherAnim[animPart1].length);
		if (!IsPlayerInRange())
		{
			featherAnim[animIdle1].wrapMode = WrapMode.Loop;
			featherAnim.Play(animIdle1);
			do
			{
				yield return Wait.For.LRUpdates(1);
			}
			while (!IsPlayerInRange());
		}
		featherAnim.CrossFade(animPart2, 0.2f);
		yield return Wait.For.Seconds(featherAnim[animPart2].length);
		if (!IsPlayerInRange())
		{
			featherAnim[animIdle2].wrapMode = WrapMode.Loop;
			featherAnim.CrossFade(animIdle2, 0.1f);
			do
			{
				yield return Wait.For.LRUpdates(1);
			}
			while (!IsPlayerInRange());
		}
		featherAnim.CrossFade(animPart3, 0.2f);
		float dissolve = 0f;
		while (dissolve < 1f)
		{
			float sqrMagnitude = (mirrorXform.position - targetBone.position).sqrMagnitude;
			dissolve = 1f - Mathf.Clamp01(sqrMagnitude / minDissolveDistance);
			if (dissolve == 1f)
			{
				skinMeshRenderer.enabled = false;
				break;
			}
			if (dissolve > 0f)
			{
				mpb.SetFloat(_DissolveAmount, dissolve);
				skinMeshRenderer.SetPropertyBlock(mpb);
				if (!flakes.isPlaying)
				{
					flakes.Play();
				}
			}
			yield return Wait.For.LRUpdates(1);
		}
	}

	private bool IsPlayerInRange()
	{
		Vector3 headPosition = IC.GetHeadPosition();
		Vector3 position = targetBone.position;
		Vector3 position2 = mirrorXform.position;
		float sqrMagnitude = (position - headPosition).sqrMagnitude;
		float sqrMagnitude2 = (position2 - headPosition).sqrMagnitude;
		if (!(sqrMagnitude <= minIdleSkipDistance))
		{
			return sqrMagnitude2 <= sqrMagnitude;
		}
		return true;
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}

	[ContextMenu("Restart OnLogic")]
	private void RestartOnLogic()
	{
		onLogicBase.Start(resetIfStarted: true);
	}
}
public class HAGIS_Workshop_B_Main : HAGIS
{
	public Doorway p1Doorway;

	public IDObjectRef mainRoomRegionRef;

	public IDObjectRef secretPortalRef;

	public IDObjectRef exitPortalRef;

	public PuzzleInfo puzzle1;

	public PuzzleInfo puzzle2;

	public PuzzleInfo puzzle3;

	public PuzzleInfo optionalPuzzle;

	public GameObject telepointP1;

	public GameObject telepointP2;

	public GameObject telepointP3;

	public GameObject telepointOP;

	public LightSource lightSourceP1;

	public LightSource lightSourceP2;

	public LightSource lightSourceP3;

	public LightSource lightSourceOP;

	public FMODEventAsset music;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		Region mainRoomRegion = LR.Inst.GetIDObjectComponent<Region>(mainRoomRegionRef);
		Portal secretPortal = LR.Inst.GetIDObjectComponent<Portal>(secretPortalRef);
		Portal exitPortal = LR.Inst.GetIDObjectComponent<Portal>(exitPortalRef);
		secretPortal.SetUnlockedState(unlocked: false);
		secretPortal.SetHidden(hidden: true);
		exitPortal.SetUnlockedState(unlocked: false);
		mainRoomRegion.Disable();
		lightSourceP2.DisableLight();
		lightSourceP3.DisableLight();
		lightSourceOP.DisableLight();
		LR.Inst.SetMusic(music);
		yield return Wait.For.LRUpdates(1);
		yield return WaitForPuzzle(puzzle1);
		p1Doorway.Open();
		if (!mainRoomRegion.IsEnabled)
		{
			mainRoomRegion.Enable();
		}
		telepointP1.SetActive(value: false);
		lightSourceP1.DisableLight();
		lightSourceP2.EnableLight();
		lightSourceP3.EnableLight();
		Wait waitforPuzzle2 = WaitForPuzzle(puzzle2);
		Wait wait = WaitForPuzzle(puzzle3);
		yield return waitforPuzzle2 | wait;
		bool puzzle2Solved = false;
		if (waitforPuzzle2.met)
		{
			lightSourceP2.DisableLight();
			telepointP2.SetActive(value: false);
			puzzle2Solved = true;
		}
		else
		{
			lightSourceP3.DisableLight();
			telepointP3.SetActive(value: false);
		}
		yield return puzzle2Solved ? WaitForPuzzle(puzzle3) : WaitForPuzzle(puzzle2);
		if (puzzle2Solved)
		{
			lightSourceP3.DisableLight();
			telepointP3.SetActive(value: false);
		}
		else
		{
			lightSourceP2.DisableLight();
			telepointP2.SetActive(value: false);
		}
		exitPortal.SetUnlockedState(unlocked: true);
		secretPortal.SetUnlockedState(unlocked: true);
		lightSourceOP.EnableLight();
		secretPortal.SetHidden(hidden: false);
		LR.Inst.StopMusic();
		yield return WaitForPuzzle(optionalPuzzle);
		lightSourceOP.DisableLight();
		telepointOP.SetActive(value: false);
		yield return Wait.For.LRUpdates(1);
	}

	protected override bool SetDebugVisibilty()
	{
		return false;
	}
}
public class AmbientAudioProbeGroup : MonoBehaviour, IPrebuildEvent
{
	[Serializable]
	private struct AmbienceProbe
	{
		public int groupIdx;

		public Vector3 position;

		public string[] parameterNames;

		public float[] parameterValues;
	}

	[SerializeField]
	private FMODEventAsset ambience;

	[SerializeField]
	private AmbienceProbe[] probes;

	[SerializeField]
	private string[] ignoredParameters;

	[SerializeField]
	private Transform[] groups;

	[SerializeField]
	private ProbeSystem probeSystem;

	private float[] paramDefaults;

	private string[] paramNames;

	private int[] paramIndicies;

	private float[] paramValues;

	private FMOD.Studio.EventInstance ambienceInstance;

	private int sfxParamIdx = -1;

	public void OnAwakeLR()
	{
		Initialize();
	}

	private void Initialize()
	{
		if (probes == null)
		{
			return;
		}
		EventDescription description = FAC.Inst.GetDescription(ambience);
		description.getParameterCount(out var count);
		paramDefaults = new float[count];
		paramIndicies = new int[count];
		paramValues = new float[count];
		paramNames = new string[count];
		for (int i = 0; i < count; i++)
		{
			description.getParameterByIndex(i, out var parameter);
			paramNames[i] = parameter.name;
			paramDefaults[i] = parameter.defaultvalue;
			paramValues[i] = 0f;
			if (Array.IndexOf(ignoredParameters, paramNames[i]) >= 0)
			{
				paramIndicies[i] = -1;
			}
			else
			{
				paramIndicies[i] = i;
			}
			if (paramNames[i] == "SFXVolume")
			{
				sfxParamIdx = i;
			}
		}
	}

	public void OnRealtimeLateUpdate(Vector3 worldPos)
	{
		AnimationCurve ambisonicMappingCurve = BaseSettings<VOSettings>.Inst.ambisonicMappingCurve;
		float num = ambisonicMappingCurve.Evaluate(0f);
		float num2 = ambisonicMappingCurve.Evaluate(1f);
		Vector3 p = base.transform.InverseTransformPoint(worldPos);
		ProbeSystem.InterpolationData interpolationData = probeSystem.GetInterpolationData(p);
		AmbienceProbe ambienceProbe = probes[interpolationData.v0];
		AmbienceProbe ambienceProbe2 = probes[interpolationData.v1];
		AmbienceProbe ambienceProbe3 = probes[interpolationData.v2];
		AmbienceProbe ambienceProbe4 = probes[interpolationData.v3];
		for (int i = 0; i < paramIndicies.Length; i++)
		{
			if (paramIndicies[i] != -1)
			{
				if (i == sfxParamIdx)
				{
					float num3 = (ambisonicMappingCurve.Evaluate((float)LR.Inst.saveDataSettings.volumeLevels[1] / 5f) - num) / (num2 - num);
					paramValues[i] = num3;
					float value = ((num3 < 0.3f) ? (num3 + 0.01f) : (num3 - 0.01f));
					ambienceInstance.setParameterValueByIndex(i, value);
					continue;
				}
				float num4 = paramDefaults[i];
				string value2 = paramNames[i];
				int num5 = Array.IndexOf(ambienceProbe.parameterNames, value2);
				int num6 = Array.IndexOf(ambienceProbe2.parameterNames, value2);
				int num7 = Array.IndexOf(ambienceProbe3.parameterNames, value2);
				int num8 = Array.IndexOf(ambienceProbe4.parameterNames, value2);
				float num9 = ((num5 < 0) ? num4 : ambienceProbe.parameterValues[num5]) * interpolationData.w0;
				float num10 = ((num6 < 0) ? num4 : ambienceProbe2.parameterValues[num6]) * interpolationData.w1;
				float num11 = ((num7 < 0) ? num4 : ambienceProbe3.parameterValues[num7]) * interpolationData.w2;
				float num12 = ((num8 < 0) ? num4 : ambienceProbe4.parameterValues[num8]) * interpolationData.w3;
				paramValues[i] = num9 + num10 + num11 + num12;
			}
		}
		ambienceInstance.setParameterValuesByIndices(paramIndicies, paramValues, paramIndicies.Length);
	}

	public void StartAmbience()
	{
		StopAmbience();
		ambienceInstance = FAC.Inst.PlayOneShot(ambience, Vector3.zero);
	}

	public void StopAmbience()
	{
		if (ambienceInstance.isValid())
		{
			ambienceInstance.stop(STOP_MODE.ALLOWFADEOUT);
		}
	}

	public float GetParameterValue(string paramName)
	{
		if (paramNames == null)
		{
			return 0f;
		}
		int num = Array.IndexOf(paramNames, paramName);
		return paramValues[num];
	}

	protected void OnDestroy()
	{
		StopAmbience();
	}

	protected void OnValidate()
	{
		if (ArrayX.IsNullOrEmpty(groups) || groups[0] != base.transform)
		{
			groups = new Transform[1] { base.transform };
		}
		if (UnityEngine.Application.isPlaying && FAC.Inst != null)
		{
			GenerateProbeSystem();
			Initialize();
		}
	}

	void IPrebuildEvent.OnPrebuildRoot(bool isPrefab)
	{
		GenerateProbeSystem();
	}

	private void GenerateProbeSystem()
	{
		if (probes != null)
		{
			Vector3[] array = new Vector3[probes.Length];
			Matrix4x4 worldToLocalMatrix = base.transform.worldToLocalMatrix;
			for (int i = 0; i < probes.Length; i++)
			{
				Matrix4x4 localToWorldMatrix = groups[probes[i].groupIdx].transform.localToWorldMatrix;
				Vector3 position = probes[i].position;
				position = localToWorldMatrix.MultiplyPoint3x4(position);
				position = worldToLocalMatrix.MultiplyPoint3x4(position);
				array[i] = position;
			}
			probeSystem = new ProbeSystem(array);
		}
	}
}
public class AnimationProgresserAudio : MonoBehaviour, IUpdateEvent
{
	public AnimationProgresser anim;

	public FMODEventAsset audioEvent;

	[Space]
	public Transform trackingPos;

	[ConditionalHide("trackingPos", true, true)]
	public Vector3 playPos;

	private FMOD.Studio.EventInstance evt;

	public float playThreshold = 0.01f;

	public void OnUpdateLR()
	{
		if (anim.AnimTime <= playThreshold || anim.AnimTime >= 1f - playThreshold)
		{
			if (evt.isValid())
			{
				evt.stop(STOP_MODE.ALLOWFADEOUT);
			}
		}
		else if (!evt.isValid())
		{
			if (trackingPos != null)
			{
				evt = FAC.Inst.PlayOneShot(audioEvent, trackingPos);
			}
			else
			{
				evt = FAC.Inst.PlayOneShot(audioEvent, base.transform.TransformPoint(playPos));
			}
		}
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Animation))]
public class AnimMeshGenerator : MonoBehaviour
{
	public Animation anim;

	public string clipName = "AN_CableCarExit";

	public int steps = 1;

	public int currentStep;

	public float meshRadius;

	public bool capturing;

	public Vector3 offset;

	[HideInInspector]
	public Mesh currentMesh;

	private bool firstFrame = true;

	private int triIndex;

	private List<Vector3> vertices = new List<Vector3>();

	private List<int> tris = new List<int>();

	private Vector3 origin;

	public void StartCapture()
	{
		currentStep = 0;
		tris.Clear();
		vertices.Clear();
		triIndex = 0;
		firstFrame = true;
		capturing = true;
		origin = base.transform.position;
		anim = GetComponent<Animation>();
	}

	private void Update()
	{
		if (!capturing)
		{
			return;
		}
		AnimationState animationState = anim[clipName];
		if ((float)currentStep <= animationState.length * animationState.clip.frameRate)
		{
			animationState.enabled = true;
			animationState.weight = 1f;
			animationState.time = (float)currentStep / animationState.clip.frameRate;
			anim.Sample();
			animationState.enabled = false;
			Vector3 vector = base.transform.position + offset;
			if (firstFrame)
			{
				origin = vector;
				firstFrame = false;
			}
			vector -= origin;
			vertices.Add(vector + Vector3.up * meshRadius);
			vertices.Add(vector + Vector3.left * meshRadius);
			vertices.Add(vector + Vector3.down * meshRadius);
			vertices.Add(vector + Vector3.right * meshRadius);
			AddCube(4 * triIndex);
			triIndex++;
			currentStep += steps;
		}
		else
		{
			animationState.enabled = true;
			animationState.weight = 1f;
			animationState.time = 0f;
			anim.Sample();
			animationState.enabled = false;
			tris.RemoveRange(tris.Count - 24, 24);
			ApplyToMesh();
			capturing = false;
		}
	}

	public void ApplyToMesh()
	{
		currentMesh = new Mesh();
		currentMesh.vertices = vertices.ToArray();
		currentMesh.triangles = tris.ToArray();
		currentMesh.RecalculateNormals();
		MeshFilter meshFilter = GetComponent<MeshFilter>();
		if (meshFilter == null)
		{
			if (GetComponent<MeshFilter>() == null)
			{
				base.gameObject.AddComponent<MeshRenderer>();
			}
			meshFilter = base.gameObject.AddComponent<MeshFilter>();
		}
		meshFilter.mesh = currentMesh;
	}

	private void AddCube(int n)
	{
		tris.AddRange(new int[24]
		{
			n + 5,
			n + 1,
			n,
			n,
			n + 4,
			n + 5,
			n + 6,
			n + 2,
			n + 1,
			n + 1,
			n + 5,
			n + 6,
			n + 7,
			n + 3,
			n + 2,
			n + 2,
			n + 6,
			n + 7,
			n + 4,
			n,
			n + 3,
			n + 3,
			n + 7,
			n + 4
		});
	}
}
public class Antilight_LeverAnimation : MonoBehaviour
{
	public Animation anim;

	public string downClip;

	public string upClip;

	[SerializeField]
	[Tooltip("Set to true if the platform starts in the up position")]
	private bool isUp;

	public float crossfadeTime = 0.2f;

	public FMODEventAsset soundPlinth;

	private FMOD.Studio.EventInstance evtPlinth;

	[Event(EventName = "Lever Down")]
	public void OnLeverDown(object sender)
	{
		PlayAnim(downClip, upClip);
	}

	[Event(EventName = "Lever Up")]
	public void OnLeverUp(object sender)
	{
		PlayAnim(upClip, downClip);
	}

	private void PlayAnim(string clipName, string altClip)
	{
		float num = crossfadeTime;
		if (anim.IsPlaying(altClip))
		{
			AnimationState animationState = anim[altClip];
			num = Mathf.Min(animationState.length - animationState.time, num);
		}
		else if (anim.IsPlaying(clipName))
		{
			return;
		}
		anim.CrossFade(clipName, num);
		if (evtPlinth.isValid())
		{
			evtPlinth.stop(STOP_MODE.IMMEDIATE);
		}
		evtPlinth = FAC.Inst.PlayOneShot(soundPlinth, base.transform);
	}

	private void Update()
	{
		if (evtPlinth.isValid() && !anim.isPlaying)
		{
			evtPlinth.stop(STOP_MODE.ALLOWFADEOUT);
		}
	}
}
[ExecuteInEditMode]
[PreBuildRemoveComponent]
public class AutoAssignLightSettings : MonoBehaviour
{
	public GameObject lightingContainer;

	public Color colorOverride;

	private void Update()
	{
		Light[] componentsInChildren = lightingContainer.GetComponentsInChildren<Light>();
		foreach (Light obj in componentsInChildren)
		{
			obj.color = colorOverride;
			GizmoSphere component = obj.GetComponent<GizmoSphere>();
			if ((bool)component)
			{
				component.color = colorOverride;
			}
		}
	}
}
public class CollisionSound : MonoBehaviour
{
	public FMODEventAsset asset;

	public bool DEBUG_logVelocity;

	[ReadOnly]
	public float lastHitVelocity;

	public void Play(float velocity)
	{
		if (base.enabled)
		{
			lastHitVelocity = velocity;
			FMOD.Studio.EventInstance @event = FAC.Inst.GetEvent(asset);
			@event.setParameterValue("Velocity", velocity);
			@event.set3DAttributes(base.transform.position.to3DAttributes());
			@event.start();
			@event.release();
		}
	}
}
public class ColorAnimator
{
	private Color _currentColor;

	private IHaglet<Color, float, AnimationCurve> colorRoutine;

	public Color CurrentColor
	{
		get
		{
			return _currentColor;
		}
		set
		{
			_currentColor = value;
		}
	}

	public ColorAnimator(string colorPropertyName = "_Color", MeshRenderer mr = null)
	{
		Haglet.Create(out colorRoutine, (Routine.Func3<Color, float, AnimationCurve>)ColorRoutine, (string)null, startNow: false, (int?)null, (string)null);
		CurrentColor = Color.clear;
	}

	private IEnumerator<Routine.Yield> ColorRoutine(Color target, float time, AnimationCurve curve)
	{
		Color beginColor = CurrentColor;
		float t = 0f;
		while (t < time)
		{
			t += IC.RealDeltaTime;
			float time2 = t / time;
			time2 = curve.Evaluate(time2);
			Color currentColor = Color.LerpUnclamped(beginColor, target, time2);
			CurrentColor = currentColor;
			yield return Wait.For.LRRealtimeUpdates(1);
		}
		CurrentColor = target;
	}

	public void ColorAnimateWithSpeed(Color targetColor, float speed, AnimationCurve curve = null)
	{
		float arg = ((Vector4)CurrentColor - (Vector4)targetColor).magnitude / speed;
		AnimationCurve arg2 = ((curve != null) ? curve : AnimationCurve.Linear(0f, 0f, 1f, 1f));
		colorRoutine.Start(targetColor, arg, arg2, resetIfStarted: true);
	}

	public Wait ColorAnimateWithTime(Color targetColor, float time, AnimationCurve curve = null)
	{
		AnimationCurve arg = ((curve != null) ? curve : AnimationCurve.Linear(0f, 0f, 1f, 1f));
		return colorRoutine.Start(targetColor, time, arg, resetIfStarted: true);
	}
}
[PreBuildRemoveComponent]
public class Comment : MonoBehaviour
{
	[TextArea(3, 20)]
	public string comment;
}
public class Constellation : MonoBehaviour, IPrebuildEvent
{
	public enum ParentTypes
	{
		NODE,
		CONNECTION,
		PARENT
	}

	[HideInInspector]
	public Transform NodeParent;

	[HideInInspector]
	public Transform ConnectionParent;

	public int nodeCount;

	private ConstArray<ConstellationNode> lastNodes = new ConstArray<ConstellationNode>(10u);

	private ConstArray<ConstellationNode> currentNodes = new ConstArray<ConstellationNode>(10u);

	[SerializeField]
	[HideInInspector]
	private ConstellationNode[] allNodes;

	public float lineWidth = 1f;

	public bool isVaultObelisk;

	private bool generated;

	private IHaglet fillConstellationRoutine;

	private IHaglet<float, Material, Material> fillMatRoutine;

	private void Reset()
	{
		if (!generated)
		{
			GameObject gameObject = GenerateChild(ParentTypes.PARENT, "Node Parent");
			NodeParent = gameObject.transform;
			GameObject gameObject2 = GenerateChild(ParentTypes.PARENT, "Connection Parent");
			ConnectionParent = gameObject2.transform;
			GenerateIsland();
			generated = true;
		}
	}

	public GameObject GenerateChild(ParentTypes type, Transform Copytransform, string name)
	{
		GameObject obj = GetGameObject(type);
		obj.name = name;
		obj.transform.parent = GetParentTransform(type);
		obj.transform.position = Copytransform.position;
		obj.transform.rotation = Copytransform.rotation;
		obj.transform.localScale = Copytransform.localScale;
		return obj;
	}

	public GameObject GenerateChild(ParentTypes type, string name)
	{
		GameObject obj = GetGameObject(type);
		obj.name = name;
		obj.transform.parent = GetParentTransform(type);
		obj.transform.localPosition = Vector3.zero;
		obj.transform.localRotation = Quaternion.identity;
		obj.transform.localScale = Vector3.one;
		return obj;
	}

	private Transform GetParentTransform(ParentTypes type)
	{
		return type switch
		{
			ParentTypes.CONNECTION => ConnectionParent, 
			ParentTypes.PARENT => base.transform, 
			ParentTypes.NODE => NodeParent, 
			_ => base.transform, 
		};
	}

	private GameObject GetGameObject(ParentTypes type)
	{
		return new GameObject();
	}

	public ConstellationNode GenerateIsland()
	{
		ConstellationNode constellationNode = GenerateChild(ParentTypes.NODE, base.transform, "Node: " + nodeCount++).AddComponent<ConstellationNode>();
		constellationNode.parentConstellation = this;
		return constellationNode;
	}

	public void OnAwakeLR()
	{
		Haglet.Create(out fillMatRoutine, (Routine.Func3<float, Material, Material>)FillMatRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out fillConstellationRoutine, FillConstellationRoutine);
		for (int i = 0; i < allNodes.Length; i++)
		{
			allNodes[i].OnAwakeLR();
		}
	}

	public Wait FillConstellation(bool skip = false)
	{
		if (fillConstellationRoutine != null && !fillConstellationRoutine.started)
		{
			return fillConstellationRoutine.Start(resetIfStarted: false, skip);
		}
		return Wait.Until.Completed(fillConstellationRoutine, 1, allowPreMetNow: true);
	}

	private IEnumerator<Routine.Yield> FillConstellationRoutine()
	{
		ObeliskSettings settings = BaseSettings<ObeliskSettings>.Inst;
		currentNodes.Clear();
		lastNodes.Clear();
		for (int i = 0; i < allNodes.Length; i++)
		{
			if (allNodes[i].NodeTo == null)
			{
				currentNodes.Add(allNodes[i]);
			}
		}
		while (currentNodes.Length != 0)
		{
			for (int j = 0; j < currentNodes.Length; j++)
			{
				currentNodes[j].PrepareNodeFill(Routine.Skipping);
			}
			if (!Routine.Skipping)
			{
				yield return FillMat(settings.circleFillTime, settings.nodeFillMat, settings.nodeFillSilverMat);
			}
			for (int k = 0; k < currentNodes.Length; k++)
			{
				currentNodes[k].SetNodeFilled(Routine.Skipping);
			}
			yield return Wait.For.LRUpdates(1);
			for (int l = 0; l < currentNodes.Length; l++)
			{
				currentNodes[l].PrepareLineFill();
			}
			if (!Routine.Skipping)
			{
				yield return FillMat(settings.lineFillTime, settings.lineFillMat, settings.lineFillSilverMat);
			}
			for (int m = 0; m < currentNodes.Length; m++)
			{
				currentNodes[m].SetLineFilled(Routine.Skipping);
			}
			yield return Wait.For.LRUpdates(1);
			lastNodes.Clear();
			currentNodes.CopyTo(lastNodes);
			currentNodes.Clear();
			for (int n = 0; n < lastNodes.Length; n++)
			{
				foreach (KeyValuePair<ConstellationNode, ConstellationNode.NodeConnection> item in lastNodes[n].nodeConnectionsFrom.dict)
				{
					currentNodes.Add(item.Key);
				}
			}
		}
	}

	private Wait FillMat(float time, Material mat, Material mat2)
	{
		mat.SetFloat("_Range", 0f);
		mat2.SetFloat("_Range", 0f);
		return fillMatRoutine.Start(time, mat, mat2);
	}

	private IEnumerator<Routine.Yield> FillMatRoutine(float time, Material fillMat, Material fillMat2)
	{
		float timer = 0f;
		while (timer < time)
		{
			yield return Wait.For.LRUpdates(1);
			timer += IC.DeltaTime;
			float value = timer / time;
			fillMat.SetFloat("_Range", value);
			fillMat2.SetFloat("_Range", value);
		}
	}

	void IPrebuildEvent.OnPrebuildRoot(bool isPrefab)
	{
		allNodes = GetComponentsInChildren<ConstellationNode>(includeInactive: true);
	}

	public void ResetNodes()
	{
		for (int i = 0; i < allNodes.Length; i++)
		{
			allNodes[i].ResetNode();
		}
	}
}
[ExecuteInEditMode]
public class ConstellationNode : MonoBehaviour, IPrebuildEvent
{
	[Serializable]
	public class NodeConnection
	{
		public GameObject connection;

		public MeshRenderer connectionRender;

		public bool isFilled;

		public NodeConnection(GameObject connection)
		{
			this.connection = connection;
			connectionRender = connection.GetComponentInChildren<MeshRenderer>();
		}
	}

	[Serializable]
	public class NodeConnectionDict : SerialisableDictionary<ConstellationNode, NodeConnection>
	{
	}

	private bool isFilled;

	private ConstArray<ConstellationNode> fillingNodes;

	[HideInInspector]
	public Constellation parentConstellation;

	[HideInInspector]
	public NodeConnectionDict nodeConnectionsFrom = new NodeConnectionDict();

	[HideInInspector]
	public ConstellationNode NodeTo;

	[SerializeField]
	[HideInInspector]
	private MeshRenderer nodeRenderer;

	public PuzzleInfo puzzleInfo;

	[ConditionalHide("puzzleInfo")]
	public SaveDataGame.PuzzleSaveType puzzleSaveType = SaveDataGame.PuzzleSaveType.Scene;

	private ObeliskSettings settings;

	public bool isFinalNode;

	private ParticlePrefab fillParticle;

	public void OnAwakeLR()
	{
		fillingNodes = new ConstArray<ConstellationNode>((uint)nodeConnectionsFrom.dict.Count);
		settings = BaseSettings<ObeliskSettings>.Inst;
		if ((bool)nodeRenderer)
		{
			Material sharedMaterial = settings.nodeEmptyMat;
			if ((bool)puzzleInfo && puzzleInfo.puzzleType == PuzzleInfo.PuzzleType.OPTIONAL)
			{
				sharedMaterial = settings.nodeEmptySilverMat;
			}
			nodeRenderer.sharedMaterial = sharedMaterial;
		}
	}

	public void PrepareNodeFill(bool skipping)
	{
		if (IsValid() && !isFilled)
		{
			isFilled = true;
			Material sharedMaterial = settings.nodeFillMat;
			if (puzzleInfo.puzzleType == PuzzleInfo.PuzzleType.OPTIONAL)
			{
				sharedMaterial = settings.nodeFillSilverMat;
			}
			nodeRenderer.sharedMaterial = sharedMaterial;
			if (!skipping)
			{
				FAC.Inst.PlayOneShot(isFinalNode ? BaseSettings<ObeliskSettings>.Inst.soundNodeFinal : BaseSettings<ObeliskSettings>.Inst.soundNode, base.transform.position);
			}
		}
	}

	public void SetNodeFilled(bool skipping = false)
	{
		if (!isFilled)
		{
			return;
		}
		Material sharedMaterial = settings.nodeFilledMat;
		if (puzzleInfo.puzzleType == PuzzleInfo.PuzzleType.OPTIONAL)
		{
			sharedMaterial = settings.nodeFilledSilverMat;
		}
		nodeRenderer.sharedMaterial = sharedMaterial;
		if (!fillParticle && !skipping)
		{
			ParticleType particleType = ((puzzleInfo.puzzleType == PuzzleInfo.PuzzleType.OPTIONAL) ? ParticleType.ObeliskStarBurst_Moon : ParticleType.ObeliskStarBurst);
			if (!parentConstellation.isVaultObelisk)
			{
				particleType = ((puzzleInfo.puzzleType == PuzzleInfo.PuzzleType.OPTIONAL) ? ParticleType.Obelisk_Moon : ParticleType.Obelisk_Sun);
			}
			fillParticle = PSC.Inst.PlayAt(particleType, base.transform.position);
			fillParticle.gameObject.transform.rotation = base.transform.rotation;
		}
	}

	public void PrepareLineFill()
	{
		fillingNodes.Clear();
		if (!IsValid())
		{
			return;
		}
		foreach (KeyValuePair<ConstellationNode, NodeConnection> item in nodeConnectionsFrom.dict)
		{
			ConstellationNode key = item.Key;
			NodeConnection value = item.Value;
			if (key.IsValid() && !value.isFilled)
			{
				fillingNodes.Add(key);
				value.connectionRender.sharedMaterial = settings.lineFillMat;
			}
		}
	}

	public void SetLineFilled(bool skipping)
	{
		for (int i = 0; i < fillingNodes.Length; i++)
		{
			NodeConnection nodeConnection = nodeConnectionsFrom.dict[fillingNodes[i]];
			nodeConnection.connectionRender.sharedMaterial = settings.lineFilledMat;
			nodeConnection.isFilled = true;
		}
		fillingNodes.Clear();
	}

	public bool IsValid()
	{
		return (!(puzzleInfo != null) || puzzleInfo.IsComplete(SaveDataGame.PuzzleSaveType.Scene)) | isFilled;
	}

	void IPrebuildEvent.OnPrebuildRoot(bool isPrefab)
	{
		nodeRenderer = GetComponentInChildren<MeshRenderer>();
	}

	public void ResetNode()
	{
		Material sharedMaterial = settings.nodeEmptyMat;
		if (puzzleInfo.puzzleType == PuzzleInfo.PuzzleType.OPTIONAL)
		{
			sharedMaterial = settings.nodeEmptySilverMat;
		}
		nodeRenderer.sharedMaterial = sharedMaterial;
		isFilled = false;
		foreach (KeyValuePair<ConstellationNode, NodeConnection> item in nodeConnectionsFrom.dict)
		{
			_ = item.Key;
			NodeConnection value = item.Value;
			value.connectionRender.sharedMaterial = settings.lineEmptyMat;
			value.isFilled = false;
		}
	}
}
public class ConstructGhostSoundController : MonoBehaviour
{
	private readonly string sfxGhostAppear = "event:/Environment/Construct/Cutscene/GhostLornaAppear";

	private readonly string sfxGhostDisappear = "event:/Environment/Construct/Cutscene/GhostLornaDisappear";

	private readonly string sfxGhostTone = "event:/Environment/Construct/Cutscene/GhostLornaTone";

	private FMOD.Studio.EventInstance evtGhostAppear;

	private FMOD.Studio.EventInstance evtGhostDisappear;

	private FMOD.Studio.EventInstance evtGhostTone;

	public Transform ghostLornaTransform;

	private bool appear = true;

	public ParticleSystem targetParticleSys;

	private IHaglet ghostLornaSoundRoutine;

	public void Initialise()
	{
		Haglet.Create(out ghostLornaSoundRoutine, GhostLornaSoundRoutine);
	}

	public void PlayGhostSound()
	{
		ghostLornaSoundRoutine.Start(resetIfStarted: true);
	}

	public void StopGhostSound()
	{
		ghostLornaSoundRoutine.Stop();
		evtGhostAppear.stop(STOP_MODE.ALLOWFADEOUT);
		evtGhostDisappear.stop(STOP_MODE.ALLOWFADEOUT);
		evtGhostTone.stop(STOP_MODE.ALLOWFADEOUT);
	}

	private IEnumerator<Routine.Yield> GhostLornaSoundRoutine()
	{
		yield return Wait.For.LRUpdates(1);
		while (true)
		{
			if (appear)
			{
				evtGhostAppear = FAC.Inst.PlayOneShot(sfxGhostAppear, ghostLornaTransform.position);
				evtGhostTone = FAC.Inst.PlayOneShot(sfxGhostTone, ghostLornaTransform.position);
			}
			else
			{
				if (evtGhostAppear.isValid())
				{
					evtGhostAppear.stop(STOP_MODE.ALLOWFADEOUT);
				}
				evtGhostDisappear = FAC.Inst.PlayOneShot(sfxGhostDisappear, ghostLornaTransform.position);
			}
			while (targetParticleSys.emission.rateOverTime.constant > 1f)
			{
				yield return Wait.For.LRUpdates(1);
			}
			if (appear)
			{
				evtGhostAppear.stop(STOP_MODE.ALLOWFADEOUT);
			}
			else
			{
				evtGhostDisappear.stop(STOP_MODE.ALLOWFADEOUT);
				evtGhostTone.stop(STOP_MODE.ALLOWFADEOUT);
			}
			while (targetParticleSys.emission.rateOverTime.constant < 1f)
			{
				yield return Wait.For.LRUpdates(1);
			}
			appear = !appear;
		}
	}

	private void OnDestroy()
	{
		evtGhostAppear.stop(STOP_MODE.IMMEDIATE);
		evtGhostDisappear.stop(STOP_MODE.IMMEDIATE);
		evtGhostTone.stop(STOP_MODE.IMMEDIATE);
	}
}
public class ConstructTransporter : MonoBehaviour, IAwakeEvent
{
	[SerializeField]
	private float fadeTime;

	[HideInInspector]
	private MRBase owner;

	public ChapterInfo constructInfo;

	public FixedRotatableObject lever;

	public FMODEventAsset ConstructSound;

	private bool hasPower;

	private GameObject activeRoot;

	private GameObject inactiveRoot;

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		this.owner = owner;
		activeRoot = base.transform.Find("ActiveRoot").gameObject;
		inactiveRoot = base.transform.Find("InactiveRoot").gameObject;
	}

	[Event(EventName = "Lever Down")]
	public void OnLeverPulled(object sender)
	{
		if (LR.Inst.fadeAndSpawn.started || !hasPower || !constructInfo)
		{
			return;
		}
		SceneInfo_BundleRef[] chapterScenes = constructInfo.chapterScenes;
		SceneInfo arg = chapterScenes[0].Load();
		SaveDataGame saveDataGame = LR.Inst.saveDataGame;
		string lastLevelUIDInChapter = saveDataGame.GetLastLevelUIDInChapter(SaveDataGame.Chapter.Construct);
		for (int i = 1; i < chapterScenes.Length; i++)
		{
			SceneInfo sceneInfo = chapterScenes[i].Load();
			if (sceneInfo.sceneUIDName == lastLevelUIDInChapter)
			{
				arg = sceneInfo;
			}
		}
		saveDataGame.lastChapter = SaveDataGame.Chapter.Construct;
		FAC.Inst.PlayOneShot(ConstructSound, base.transform.position);
		LR.Inst.StopMusic();
		LR.Inst.fadeAndSpawn.Start(fadeTime, arg, owner);
	}

	public void SetPowered(bool powered)
	{
		hasPower = powered;
		if ((bool)lever)
		{
			lever.enabled = hasPower;
		}
		if ((bool)activeRoot)
		{
			activeRoot.SetActive(powered);
		}
		if ((bool)inactiveRoot)
		{
			inactiveRoot.SetActive(!powered);
		}
	}
}
public class Credits
{
	public class Role
	{
		public string name;

		public List<string> people = new List<string>();
	}

	public class Company
	{
		public string name;

		public bool shuffle;

		public List<Role> roles = new List<Role>();
	}

	public List<Company> companies = new List<Company>();

	public static Credits Load(string resourcePath)
	{
		Credits credits = new Credits();
		TextAsset textAsset = Resources.Load<TextAsset>(resourcePath);
		if (textAsset == null)
		{
			UnityEngine.Debug.LogError("CreditsController: Failed to open 'credits_list.csv'!");
			return credits;
		}
		string[] array = textAsset.text.Split("\n"[0]);
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = array[i].Replace("\r", "");
		}
		Company company = null;
		Role role = null;
		for (int j = 0; j < array.Length; j++)
		{
			string text = array[j].Trim();
			if (array.Length != 0 && !string.IsNullOrEmpty(text) && !text.StartsWith("//"))
			{
				if (text.StartsWith("[GROUP]"))
				{
					text = text.Replace("[GROUP]", "").TrimEnd();
					company = new Company
					{
						name = text,
						shuffle = false
					};
					credits.companies.Add(company);
				}
				else if (text.StartsWith("[GROUP_SHUFFLE]"))
				{
					text = text.Replace("[GROUP_SHUFFLE]", "").TrimEnd();
					company = new Company
					{
						name = text,
						shuffle = true
					};
					credits.companies.Add(company);
				}
				else if (company == null)
				{
					UnityEngine.Debug.Log("No company defined at line: " + j);
				}
				else if (text.StartsWith("[ROLE]"))
				{
					text = text.Replace("[ROLE]", "").TrimEnd();
					role = new Role
					{
						name = text
					};
					company.roles.Add(role);
				}
				else if (role == null)
				{
					UnityEngine.Debug.Log("No role defined at line: " + j);
				}
				else if (!string.IsNullOrEmpty(text))
				{
					role.people.Add(text);
				}
			}
		}
		return credits;
	}
}
public class CustomParticleEmitter : MonoBehaviour
{
	public delegate void ParticleEmit(ParticleSystem.Particle[] particles, int start, ref int end);

	public float rate;

	public ParticleEmit onEmitParticles;

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private float overflow;

	private float lastTime;

	private void Awake()
	{
		ps = GetComponent<ParticleSystem>();
		lastTime = ps.time;
		particles = new ParticleSystem.Particle[ps.main.maxParticles];
	}

	private void LateUpdate()
	{
		Array.Clear(particles, 0, particles.Length);
		float time = ps.time;
		int particleCount = ps.particleCount;
		float num = time - lastTime;
		float num2 = rate * num + overflow;
		int num3 = Mathf.Min(particles.Length - particleCount, Mathf.FloorToInt(num2));
		int start = particleCount;
		overflow = num2 - (float)num3;
		particleCount += num3;
		int num4 = particleCount;
		ps.Emit(num3);
		ps.GetParticles(particles);
		if (onEmitParticles != null && num3 > 0)
		{
			onEmitParticles(particles, start, ref particleCount);
		}
		for (int i = particleCount; i < num4; i++)
		{
			particles[i].remainingLifetime = -1f;
		}
		overflow -= num4 - particleCount;
		ps.SetParticles(particles, particles.Length);
		lastTime = time;
	}
}
public class DuckController : UIContainer
{
	public GameObject prefab;

	private List<GameObject> instances = new List<GameObject>();

	public string text;

	public FMODEventRef sfx;

	public Shader shader0;

	public Shader shader1;

	public Texture texture0;

	public Texture texture1;

	private UITextbox info;

	private Transform zone;

	public int startingNum;

	public override Wait OnAwakeLR()
	{
		base.OnAwakeLR();
		UIButton element = GetElement<UIButton>("Add");
		UIButton element2 = GetElement<UIButton>("Remove");
		UIButton element3 = GetElement<UIButton>("AddFast");
		UIButton element4 = GetElement<UIButton>("Clear");
		info = GetElement<UITextbox>("Info");
		element.OnTapUp += ButtonAdd_OnTapUp;
		element2.OnTapUp += ButtonRemove_OnTapUp;
		element3.OnTapHeld += ButtonAddFast_OnTapHeld;
		element4.OnTapUp += ButtonClear_OnTapUp;
		zone = GetElement<UIElement>("Zone").transform;
		UpdateInfo();
		FAC.Inst.PlayOneShot(sfx.Value, zone.transform.position);
		for (int i = 0; i < startingNum; i++)
		{
			Add();
		}
		return Wait.PreMet;
	}

	private bool ButtonClear_OnTapUp(UIButton arg1)
	{
		for (int i = 0; i < instances.Count; i++)
		{
			UnityEngine.Object.Destroy(instances[i]);
		}
		instances.Clear();
		UpdateInfo();
		return true;
	}

	private void Add()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(prefab, zone);
		instances.Add(gameObject);
		if ((bool)shader0)
		{
			MeshRenderer component = gameObject.GetComponent<MeshRenderer>();
			_ = component.material;
			component.sortingOrder = instances.Count;
			if (component.sortingOrder % 2 == 0)
			{
				component.material.shader = shader0;
				component.material.mainTexture = texture0;
			}
			else
			{
				component.material.shader = shader1;
				component.material.mainTexture = texture1;
			}
			gameObject.GetComponent<AnimRotation>().rotation.z = UnityEngine.Random.Range(-30, 30);
		}
		gameObject.transform.localPosition = UnityEngine.Random.insideUnitSphere * 2f;
		UpdateInfo();
	}

	private void ButtonAddFast_OnTapHeld(UIButton obj)
	{
		Add();
	}

	private void UpdateInfo()
	{
		info.SetText(text + " #" + instances.Count);
	}

	private bool ButtonAdd_OnTapUp(UIButton arg1)
	{
		Add();
		return true;
	}

	private bool ButtonRemove_OnTapUp(UIButton arg1)
	{
		if (instances.Count > 0)
		{
			GameObject gameObject = instances[instances.Count - 1];
			UnityEngine.Object.Destroy(gameObject);
			instances.Remove(gameObject);
			UpdateInfo();
		}
		return true;
	}
}
public class DummyRef : MonoBehaviour
{
	public IDObjectRef m_dummyRef;
}
[RequireComponent(typeof(Animation))]
public class EnviromentAnimationOffset : MonoBehaviour, IAwakeEvent
{
	public Vector2 offsetRange;

	private Animation animComp;

	private IHaglet<float> animOffset;

	public void OnAwakeLR(MRBase owner)
	{
		Haglet.Create(out animOffset, (Routine.Func1<float>)AnimOffset, (string)null, startNow: false, (int?)null, (string)null);
		animComp = GetComponent<Animation>();
		if ((bool)animComp)
		{
			animComp.playAutomatically = false;
			animComp.Stop();
			animOffset.Start(UnityEngine.Random.Range(offsetRange.x, offsetRange.y));
		}
	}

	private IEnumerator<Routine.Yield> AnimOffset(float offset)
	{
		yield return Wait.For.Seconds(offset);
		if ((bool)animComp)
		{
			animComp.Play();
		}
	}
}
public class EventAnimation : MonoBehaviour
{
	public Animation anim;

	public string animName;

	private bool animPlayed;

	[Event(EventName = "Play Animation")]
	public void Play(object sender)
	{
		anim.Play(animName);
	}

	[Event(EventName = "Stop Animation")]
	public void Stop(object sender)
	{
		anim.Stop();
	}

	[Event(EventName = "Play Animation Once")]
	public void PlayOnce(object sender)
	{
		if (!animPlayed)
		{
			anim.Play(animName);
			animPlayed = true;
		}
	}

	[Event(EventName = "Allow Animation To Play Again")]
	public void AllowAnimToPlayAgain(object sender)
	{
		animPlayed = false;
	}
}
public class FloatAnimator
{
	[NonSerialized]
	[HideInInspector]
	public float CurrentValue;

	[NonSerialized]
	[HideInInspector]
	public float CurrentTarget;

	private HagletValue<bool> isFading;

	private IHaglet<float, float, float> floatRoutine;

	public Wait IsFading => Wait.Until.False(isFading, 1, allowPreMetNow: true);

	public FloatAnimator()
	{
		Haglet.Create(out floatRoutine, (Routine.Func3<float, float, float>)FloatRoutine, (string)null, startNow: false, (int?)null, (string)null);
		HagletValue.Create(out isFading, null, initVal: false, null, 8);
	}

	private IEnumerator<Routine.Yield> FloatRoutine(float start, float target, float time)
	{
		CurrentTarget = target;
		float t = 0f;
		while (t < time)
		{
			float t2 = t / time;
			float currentValue = Mathf.LerpUnclamped(start, target, t2);
			CurrentValue = currentValue;
			t += IC.RealDeltaTime;
			yield return Wait.For.LRRealtimeUpdates(1);
		}
		CurrentValue = target;
		isFading.value = false;
	}

	public Wait AnimateTo(float target, float time, bool onlyResetIfNewTarget = false)
	{
		if (onlyResetIfNewTarget && target == CurrentTarget)
		{
			return IsFading;
		}
		if (time <= 0f)
		{
			CurrentValue = target;
			CurrentTarget = target;
			return IsFading;
		}
		isFading.value = true;
		floatRoutine.Start(CurrentValue, target, time, resetIfStarted: true);
		return IsFading;
	}

	public Wait AnimateTo(float start, float target, float time)
	{
		if (time <= 0f)
		{
			CurrentValue = target;
			CurrentTarget = target;
			return IsFading;
		}
		isFading.value = true;
		floatRoutine.Start(start, target, time, resetIfStarted: true);
		return IsFading;
	}
}
public class FlyFromHandOnce : MonoBehaviour, IAwakeEvent
{
	public GrabObject objectToFly;

	public Vector3 flyVelocity;

	public FMODEventAsset sound;

	private bool hasFlown;

	private IHaglet flyRoutine;

	public void OnAwakeLR(MRBase owner)
	{
		objectToFly.OnObjectFocusGrabbed.onPostHappen += StartFlyRoutine;
		objectToFly.OnObjectGrabbed.onPostHappen += StartFlyRoutine;
		Haglet.Create(out flyRoutine, FlyRoutine);
	}

	public void OnDestroy()
	{
		objectToFly.OnObjectFocusGrabbed.onPostHappen -= StartFlyRoutine;
		objectToFly.OnObjectGrabbed.onPostHappen -= StartFlyRoutine;
	}

	private void StartFlyRoutine()
	{
		if (!hasFlown)
		{
			flyRoutine.Start();
			hasFlown = true;
			if ((bool)sound)
			{
				FAC.Inst.PlayOneShot(sound, objectToFly.transform);
			}
		}
	}

	private IEnumerator<Routine.Yield> FlyRoutine()
	{
		objectToFly.canBeGrabbed = false;
		if (objectToFly.lastGrabbedHand != null)
		{
			objectToFly.lastGrabbedHand.UngrabObject();
		}
		objectToFly.pr.SetKinematic(isKinematic: false);
		objectToFly.pr.SetVelocityLinear(flyVelocity);
		yield return Wait.For.Seconds(1f);
		objectToFly.canBeGrabbed = true;
	}
}
public class FMOD_DAGizmo : MonoBehaviour
{
	public float _minDist;

	public float _maxDist;

	public Color minColor = Color.green;

	public Color maxColor = Color.red;

	public float minDist
	{
		get
		{
			return _minDist;
		}
		set
		{
			_minDist = Mathf.Max(0f, value);
		}
	}

	public float maxDist
	{
		get
		{
			return _maxDist;
		}
		set
		{
			_maxDist = Mathf.Max(_minDist, value);
		}
	}

	private void OnDrawGizmos()
	{
		Gizmos.color = minColor;
		Gizmos.DrawWireSphere(base.transform.position, minDist);
		Gizmos.color = maxColor;
		Gizmos.DrawWireSphere(base.transform.position, maxDist);
	}
}
public class FMODAmbientSource : MonoBehaviour
{
	public FMODEventAsset assetToPlay;

	public bool updatePosition;

	protected FMOD.Studio.EventInstance evt;

	public bool playing
	{
		get
		{
			PLAYBACK_STATE playbackState = GetPlaybackState();
			if (playbackState != PLAYBACK_STATE.STOPPED)
			{
				return playbackState != PLAYBACK_STATE.STOPPING;
			}
			return false;
		}
	}

	private void OnDestroy()
	{
		Stop();
	}

	public void SetParameter(string name, float value)
	{
		evt.setParameterValue(name, value);
	}

	public ParameterInstance GetParameter(string name)
	{
		evt.getParameter(name, out var instance);
		return instance;
	}

	public ParameterInstance GetParameter(int index)
	{
		evt.getParameterByIndex(index, out var instance);
		return instance;
	}

	public PLAYBACK_STATE GetPlaybackState()
	{
		if (!evt.isValid())
		{
			return PLAYBACK_STATE.STOPPED;
		}
		if (evt.getPlaybackState(out var state) == RESULT.OK)
		{
			return state;
		}
		return PLAYBACK_STATE.STOPPED;
	}

	public void Play()
	{
		if (!(assetToPlay != null))
		{
			return;
		}
		Stop();
		evt = FAC.Inst.GetEvent(assetToPlay);
		Update3DAttributes();
		if (evt.isValid())
		{
			if (updatePosition)
			{
				FAC.Inst.RegisterTrackedEvent(evt, base.transform);
			}
			string path = "";
			FAC.Inst.GetDescription(assetToPlay).getPath(out path);
			evt.start();
			evt.release();
		}
	}

	public void Stop()
	{
		if (evt.isValid())
		{
			if (updatePosition)
			{
				FAC.Inst.UnregisterTrackedEvent(evt);
			}
			evt.stop(STOP_MODE.IMMEDIATE);
		}
	}

	public bool Is3D()
	{
		bool is3D = false;
		if ((bool)assetToPlay)
		{
			FAC.Inst.GetDescription(assetToPlay).is3D(out is3D);
		}
		return is3D;
	}

	public void Update3DAttributes()
	{
		ATTRIBUTES_3D attributes = UnityUtil.to3DAttributes(base.gameObject);
		evt.set3DAttributes(attributes);
	}
}
public class FMODAmbientSourceDistance : FMODAmbientSource
{
	public float distanceMin;

	public float distanceMax = 3f;

	public STOP_MODE stopType = STOP_MODE.IMMEDIATE;

	private void Update()
	{
		Vector3 headPosition = IC.GetHeadPosition();
		Vector3 position = base.transform.position;
		float num = Vector3.Distance(headPosition, position);
		if (num < distanceMax)
		{
			if (!evt.isValid())
			{
				Play();
			}
			evt.setParameterValue("Distance", MathfX.Percent(distanceMin, distanceMax, num));
		}
		else if (evt.isValid())
		{
			evt.stop(stopType);
		}
	}
}
public class FMODAnimEvents : MonoBehaviour
{
	public void PlayEvent(AnimationEvent evt)
	{
		FMODEventAsset asset = (FMODEventAsset)evt.objectReferenceParameter;
		FMOD.Studio.EventInstance @event = FAC.Inst.GetEvent(asset);
		if (!string.IsNullOrEmpty(evt.stringParameter))
		{
			@event.setParameterValue(evt.stringParameter, evt.floatParameter);
		}
		@event.set3DAttributes(UnityUtil.to3DAttributes(base.transform));
	}
}
public class ForceFillConstellation : MonoBehaviour, IAreaEvent
{
	public ChapterInfo chapterinfo;

	public Constellation constellation;

	public void OnAreaEnter()
	{
		if ((bool)chapterinfo)
		{
			if (chapterinfo.IsChapterComplete())
			{
				constellation.FillConstellation(skip: true);
			}
		}
		else
		{
			constellation.FillConstellation(skip: true);
		}
	}

	public void OnAreaExit()
	{
	}
}
public class ForceUp : MonoBehaviour, IUpdateEvent
{
	public Vector3 up;

	public void OnUpdateLR()
	{
		base.transform.up = up;
	}
}
public class FPSCounter : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class GrabObjectEvent : MonoBehaviour
{
	public IDObjectRef GrabObject;

	[Event(EventName = "Enable Grabbing")]
	public void EnableGrabbing(object sender)
	{
		GrabObject.GetComponent<GrabObject>().canBeGrabbed = true;
	}

	[Event(EventName = "Disable Grabbing")]
	public void DisableGrabbing(object sender)
	{
		GrabObject.GetComponent<GrabObject>().canBeGrabbed = false;
	}

	[Event(EventName = "Disable Grabbing Unless Already Grabbed")]
	public void DisableGrabbingUnlessAlreadyGrabbed(object sender)
	{
		if (!GrabObject.GetComponent<GrabObject>().hasBeenGrabbed)
		{
			GrabObject.GetComponent<GrabObject>().canBeGrabbed = false;
		}
	}
}
public class GravityDangler : MonoBehaviour, IOwnerChangeListener, ICanEnterPortal
{
	public bool angleConstraint;

	[ConditionalHide("angleConstraint")]
	public float angleLimitInDegrees;

	private Vector3 massWorldPos;

	private Vector3 massWorldVel;

	private float lengthConstraint;

	private GrabObject grabObj;

	private GravityDanglerMassPoint gravityDanglerMassPoint;

	private bool teleported;

	private Vector3 currentGravity = Vector3.zero;

	public Transform centerPoint;

	public void OnAwakeLR()
	{
		grabObj = base.gameObject.GetComponentInAscendant<GrabObject>();
		gravityDanglerMassPoint = GetComponentInChildren<GravityDanglerMassPoint>(includeInactive: true);
		massWorldPos = gravityDanglerMassPoint.transform.position;
		lengthConstraint = Vector3.Distance(massWorldPos, base.transform.position);
		grabObj.onPositionReplace.onPostHappen += OnPositionReplace;
		centerPoint = new GameObject("CenterPoint").transform;
		centerPoint.parent = grabObj.transform;
		centerPoint.position = grabObj.transform.position + grabObj.transform.InverseTransformPoint(base.transform.position) / 2f;
	}

	public void OnDestroy()
	{
		grabObj.onPositionReplace.onPostHappen -= OnPositionReplace;
	}

	public void OnEnterPortal(Portal portal)
	{
		massWorldPos = gravityDanglerMassPoint.transform.position;
		teleported = true;
	}

	public void OnLateUpdateLR()
	{
		if (teleported)
		{
			teleported = false;
			massWorldPos = gravityDanglerMassPoint.transform.position;
		}
		if (currentGravity == Vector3.zero)
		{
			currentGravity = grabObj.pr.ObjGravity;
		}
		else if (grabObj.pr.ObjGravity.normalized != currentGravity.normalized)
		{
			PSC.Inst.Play(ParticleType.Gravity_Indicator, centerPoint);
			FAC.Inst.PlayOneShot(BaseSettings<InteractionSettings>.Inst.sfxGravityChanged, base.transform.position);
			currentGravity = grabObj.pr.ObjGravity;
		}
		float deltaTime = IC.DeltaTime;
		massWorldVel += grabObj.pr.ObjGravity * deltaTime;
		massWorldPos += massWorldVel * deltaTime;
		if (angleConstraint)
		{
			Vector3 position = base.transform.position;
			Vector3 vector = -base.transform.parent.up;
			Vector3 vector2 = massWorldPos - position;
			Quaternion.FromToRotation(vector, vector2.normalized).ToAngleAxis(out var angle, out var axis);
			if (angle > angleLimitInDegrees)
			{
				Vector3 vector3 = Quaternion.AngleAxis(angleLimitInDegrees, axis) * vector * vector2.magnitude;
				Vector3 normalized = Vector3.Cross(vector3.normalized, Vector3.up).normalized;
				Vector3 vector4 = -Vector3.Cross(vector3.normalized, normalized).normalized;
				massWorldPos = position + vector3;
				float num = Vector3.Dot(vector4, massWorldVel);
				Vector3 vector5 = vector4 * num;
				massWorldVel -= vector5;
			}
		}
		Vector3 vector6 = base.transform.position - massWorldPos;
		float num2 = vector6.magnitude - lengthConstraint;
		Vector3 normalized2 = vector6.normalized;
		massWorldPos += normalized2 * num2;
		massWorldVel -= normalized2 * Vector3.Dot(normalized2, massWorldVel);
		massWorldVel *= 0.95f;
		Vector3 right = base.transform.right;
		Vector3 normalized3 = (massWorldPos - base.transform.position).normalized;
		Quaternion rotation = Quaternion.LookRotation(Vector3.Cross(normalized3, right).normalized, -normalized3);
		base.transform.rotation = rotation;
	}

	private void OnPositionReplace()
	{
		massWorldPos = gravityDanglerMassPoint.transform.position;
	}

	void IOwnerChangeListener.OnOwnerChange(MRBase _oldOwner, MRBase _newOwner)
	{
		MRBase.TransferObject(_oldOwner, _newOwner, this);
	}
}
public class GravityDanglerMassPoint : MonoBehaviour
{
}
public class HAGIS_OpenPortalOnCutsceneEnd : HAGIS
{
	public HAGIS_Cutscene_Base cutscene;

	public Portal portal;

	public override IEnumerator<Routine.Yield> OnLogic()
	{
		portal.SetUnlockedState(unlocked: false);
		yield return cutscene.IsComplete;
		portal.SetUnlockedState(unlocked: true);
	}
}
[ExecuteInEditMode]
public class HideFlagsRemover : MonoBehaviour
{
	private void Awake()
	{
		GameObjectX.SetHideFlagsRecursively(base.gameObject, HideFlags.None, includeSelf: true);
		UnityEngine.Debug.Log("Set Hide Flags to HideFlags.None Recursively from " + base.gameObject.name, base.gameObject);
		UnityEngine.Object.DestroyImmediate(this);
	}
}
public class HubEntryPointHolder : MonoBehaviour
{
	public PlayerEntryPoint[] chapterEntryPoints;

	[Space]
	public PlayerEntryPoint planetariumEntryPoint;

	public PlayerEntryPoint GetTargetHubEntryPoint()
	{
		switch (LR.Inst.saveDataGame.lastChapter)
		{
		case SaveDataGame.Chapter.Princess:
			return chapterEntryPoints[0];
		case SaveDataGame.Chapter.Hunter:
			return chapterEntryPoints[1];
		case SaveDataGame.Chapter.Stargazing:
			return chapterEntryPoints[2];
		case SaveDataGame.Chapter.Escape:
			return chapterEntryPoints[3];
		case SaveDataGame.Chapter.Evilgate:
			return chapterEntryPoints[4];
		case SaveDataGame.Chapter.Insanity:
			return chapterEntryPoints[5];
		case SaveDataGame.Chapter.Death:
			return chapterEntryPoints[6];
		case SaveDataGame.Chapter.FirstMeeting:
			return chapterEntryPoints[7];
		case SaveDataGame.Chapter.Construct:
			return chapterEntryPoints[9];
		default:
			if ((LR.Inst.saveDataGame.chaptersComplete & SaveDataGame.Chapter.Princess) == SaveDataGame.Chapter.Princess)
			{
				return planetariumEntryPoint;
			}
			return null;
		}
	}
}
public class IDPool32
{
	private const int POOL_SIZE = 32;

	private uint idPool;

	public IDPool32(uint initialValue = 0u)
	{
		idPool = initialValue;
	}

	public uint GetIDMask()
	{
		for (int i = 0; i < 32; i++)
		{
			uint num = (uint)(1 << i);
			if ((idPool & num) == 0)
			{
				idPool |= num;
				return num;
			}
		}
		return 0u;
	}

	public void ReturnIDMask(uint mask)
	{
		idPool &= ~mask;
	}

	public int GetID()
	{
		for (byte b = 0; b < 32; b++)
		{
			uint num = (uint)(1 << (int)b);
			if ((idPool & num) == 0)
			{
				idPool |= num;
				return b;
			}
		}
		return -1;
	}

	public void ReturnID(int b)
	{
		idPool &= (uint)(~(1 << b));
	}
}
public class InputPrinter : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		IndexTriggerAxis();
		HandTriggerAxis();
		Touchpads();
		Thumbsticks();
		DpadInput();
		Buttons();
		HandTriggerButtons();
		IndexTriggerButtons();
		ThumbstickButtons();
		TouchpadButtons();
		ShoulderButtons();
		IndexTriggerNearTouch();
		ThumbButtonsNearTouch();
		IndexTriggerTouch();
		ThumbstickTouch();
		ButtonsTouch();
		ThumbRestsTouch();
		TouchpadTouch();
		MouseAxis();
	}

	private void IndexTriggerAxis()
	{
		float num = OVRInput.Get(OVRInput.RawAxis1D.RIndexTrigger, OVRInput.Controller.All);
		float num2 = OVRInput.Get(OVRInput.RawAxis1D.LIndexTrigger, OVRInput.Controller.All);
		if (num != 0f || num2 != 0f)
		{
			UnityEngine.Debug.Log($"Index Trigger Input - Right: {num}; Left: {num2};");
		}
	}

	private void HandTriggerAxis()
	{
		float num = OVRInput.Get(OVRInput.RawAxis1D.RHandTrigger, OVRInput.Controller.All);
		float num2 = OVRInput.Get(OVRInput.RawAxis1D.LHandTrigger, OVRInput.Controller.All);
		if (num != 0f || num2 != 0f)
		{
			UnityEngine.Debug.Log($"Hand Trigger Input - Right: {num}; Left: {num2};");
		}
	}

	private void Touchpads()
	{
		Vector2 vector = OVRInput.Get(OVRInput.RawAxis2D.RTouchpad, OVRInput.Controller.RTouch | OVRInput.Controller.RTrackedRemote);
		Vector2 vector2 = OVRInput.Get(OVRInput.RawAxis2D.LTouchpad, OVRInput.Controller.All);
		if (vector != Vector2.zero || vector2 != Vector2.zero)
		{
			UnityEngine.Debug.Log($"Touchpad Input - Right: {vector}; Left: {vector2};");
		}
	}

	private void Thumbsticks()
	{
		Vector2 vector = OVRInput.Get(OVRInput.RawAxis2D.RThumbstick, OVRInput.Controller.RTouch | OVRInput.Controller.RTrackedRemote);
		Vector2 vector2 = OVRInput.Get(OVRInput.RawAxis2D.LThumbstick, OVRInput.Controller.All);
		if (vector != Vector2.zero || vector2 != Vector2.zero)
		{
			UnityEngine.Debug.Log($"Thumbstick Input - Right: {vector}; Left: {vector2};");
		}
	}

	private void DpadInput()
	{
		bool flag = OVRInput.Get(OVRInput.RawButton.DpadUp, OVRInput.Controller.RTouch | OVRInput.Controller.RTrackedRemote);
		bool flag2 = OVRInput.Get(OVRInput.RawButton.DpadDown, OVRInput.Controller.RTouch | OVRInput.Controller.RTrackedRemote);
		bool flag3 = OVRInput.Get(OVRInput.RawButton.DpadLeft, OVRInput.Controller.RTouch | OVRInput.Controller.RTrackedRemote);
		bool flag4 = OVRInput.Get(OVRInput.RawButton.DpadRight, OVRInput.Controller.RTouch | OVRInput.Controller.RTrackedRemote);
		if (flag || flag2 || flag3 || flag4)
		{
			UnityEngine.Debug.Log($"DPad Input - Up: {flag}; Down: {flag2}; Left: {flag3}; Right: {flag4};");
		}
	}

	private void Buttons()
	{
		bool flag = OVRInput.Get(OVRInput.RawButton.A, OVRInput.Controller.All);
		bool flag2 = OVRInput.Get(OVRInput.RawButton.B, OVRInput.Controller.All);
		bool flag3 = OVRInput.Get(OVRInput.RawButton.X, OVRInput.Controller.All);
		bool flag4 = OVRInput.Get(OVRInput.RawButton.Y, OVRInput.Controller.All);
		bool flag5 = OVRInput.Get(OVRInput.RawButton.Back, OVRInput.Controller.All);
		bool flag6 = OVRInput.Get(OVRInput.RawButton.Start, OVRInput.Controller.All);
		if (flag || flag2 || flag3 || flag4 || flag5 || flag6)
		{
			UnityEngine.Debug.Log($"Button Input - A: {flag}; B: {flag2}; X: {flag3}; Y: {flag4}; Back: {flag5}; Start: {flag6};");
		}
	}

	private void HandTriggerButtons()
	{
		bool flag = OVRInput.Get(OVRInput.RawButton.RHandTrigger, OVRInput.Controller.All);
		bool flag2 = OVRInput.Get(OVRInput.RawButton.LHandTrigger, OVRInput.Controller.All);
		if (flag || flag2)
		{
			UnityEngine.Debug.Log($"Hand Trigger Button Input - Right: {flag}; Left: {flag2};");
		}
	}

	private void IndexTriggerButtons()
	{
		bool flag = OVRInput.Get(OVRInput.RawButton.RHandTrigger, OVRInput.Controller.All);
		bool flag2 = OVRInput.Get(OVRInput.RawButton.LHandTrigger, OVRInput.Controller.All);
		if (flag || flag2)
		{
			UnityEngine.Debug.Log($"Index Trigger Button Input - Right: {flag}; Left: {flag2};");
		}
	}

	private void ThumbstickButtons()
	{
		bool flag = OVRInput.Get(OVRInput.RawButton.RHandTrigger, OVRInput.Controller.All);
		bool flag2 = OVRInput.Get(OVRInput.RawButton.LHandTrigger, OVRInput.Controller.All);
		if (flag || flag2)
		{
			UnityEngine.Debug.Log($"Thumbstick Button Input - Right: {flag}; Left: {flag2};");
		}
	}

	private void TouchpadButtons()
	{
		bool flag = OVRInput.Get(OVRInput.RawButton.RTouchpad, OVRInput.Controller.All);
		bool flag2 = OVRInput.Get(OVRInput.RawButton.LTouchpad, OVRInput.Controller.All);
		if (flag || flag2)
		{
			UnityEngine.Debug.Log($"Touchpad Button Input - Right: {flag}; Left: {flag2};");
		}
	}

	private void ShoulderButtons()
	{
		bool flag = OVRInput.Get(OVRInput.RawButton.RShoulder, OVRInput.Controller.All);
		bool flag2 = OVRInput.Get(OVRInput.RawButton.LShoulder, OVRInput.Controller.All);
		if (flag || flag2)
		{
			UnityEngine.Debug.Log($"Shoulder Button Input - Right: {flag}; Left: {flag2};");
		}
	}

	private void IndexTriggerNearTouch()
	{
		bool flag = OVRInput.Get(OVRInput.RawNearTouch.RIndexTrigger, OVRInput.Controller.All);
		bool flag2 = OVRInput.Get(OVRInput.RawNearTouch.LIndexTrigger, OVRInput.Controller.All);
		if (flag || flag2)
		{
			UnityEngine.Debug.Log(string.Format("Index Triggers Near Touch - Right: {0}; Left: {0}", flag, flag2));
		}
	}

	private void ThumbButtonsNearTouch()
	{
		bool flag = OVRInput.Get(OVRInput.RawNearTouch.RThumbButtons, OVRInput.Controller.All);
		bool flag2 = OVRInput.Get(OVRInput.RawNearTouch.LThumbButtons, OVRInput.Controller.All);
		if (flag || flag2)
		{
			UnityEngine.Debug.Log(string.Format("Thumb Buttons Near Touch - Right: {0}; Left: {0}", flag, flag2));
		}
	}

	private void IndexTriggerTouch()
	{
		bool flag = OVRInput.Get(OVRInput.RawTouch.RIndexTrigger, OVRInput.Controller.All);
		bool flag2 = OVRInput.Get(OVRInput.RawTouch.LIndexTrigger, OVRInput.Controller.All);
		if (flag || flag2)
		{
			UnityEngine.Debug.Log(string.Format("Index Triggers Touch - Right: {0}; Left: {0}", flag, flag2));
		}
	}

	private void ThumbstickTouch()
	{
		bool flag = OVRInput.Get(OVRInput.RawTouch.RThumbstick, OVRInput.Controller.All);
		bool flag2 = OVRInput.Get(OVRInput.RawTouch.LThumbstick, OVRInput.Controller.All);
		if (flag || flag2)
		{
			UnityEngine.Debug.Log(string.Format("Thumbstick Touch - Right: {0}; Left: {0}", flag, flag2));
		}
	}

	private void ButtonsTouch()
	{
		bool flag = OVRInput.Get(OVRInput.RawTouch.A, OVRInput.Controller.All);
		bool flag2 = OVRInput.Get(OVRInput.RawTouch.B, OVRInput.Controller.All);
		bool flag3 = OVRInput.Get(OVRInput.RawTouch.X, OVRInput.Controller.All);
		bool flag4 = OVRInput.Get(OVRInput.RawTouch.Y, OVRInput.Controller.All);
		if (flag || flag2 || flag3 || flag4)
		{
			UnityEngine.Debug.Log($"Button Touch Input - A: {flag}; B: {flag2}; X: {flag3}; Y: {flag4};");
		}
	}

	private void ThumbRestsTouch()
	{
		bool flag = OVRInput.Get(OVRInput.RawTouch.RThumbRest, OVRInput.Controller.All);
		bool flag2 = OVRInput.Get(OVRInput.RawTouch.LThumbRest, OVRInput.Controller.All);
		if (flag || flag2)
		{
			UnityEngine.Debug.Log(string.Format("Thumb Rest Touch Input - Right: {0}; Left {0};", flag, flag2));
		}
	}

	private void TouchpadTouch()
	{
		bool flag = OVRInput.Get(OVRInput.RawTouch.RTouchpad, OVRInput.Controller.All);
		bool flag2 = OVRInput.Get(OVRInput.RawTouch.LTouchpad, OVRInput.Controller.All);
		if (flag || flag2)
		{
			UnityEngine.Debug.Log(string.Format("Touchpad Touch Input - Right: {0}; Left {0};", flag, flag2));
		}
	}

	private void MouseAxis()
	{
		float axis = Input.GetAxis("Mouse X");
		float axis2 = Input.GetAxis("Mouse Y");
		if (axis != 0f || axis2 != 0f)
		{
			UnityEngine.Debug.Log($"Mouse Input - ({axis}, {axis2})");
		}
	}

	private void AndroidJoysticks()
	{
		float axis = Input.GetAxis("Android: Joy 1:Right_Y_Axis");
		float axis2 = Input.GetAxis("Android: Joy 1:Right_X_Axis");
		float axis3 = Input.GetAxis("Android: Joy 1:Left_Y_Axis");
		float axis4 = Input.GetAxis("Android: Joy 1:Left_X_Axis");
		if (axis != 0f || axis2 != 0f || axis3 != 0f || axis != 0f)
		{
			UnityEngine.Debug.Log($"Android Joystick Axis: Left: ({axis2}, {axis}); Right: ({axis4}, {axis3});");
		}
	}
}
public static class Layer
{
	public const int Default = 0;

	public const int IgnoreRaycast = 2;

	public const int UI = 5;

	public const int TeleportArc = 8;

	public const int Portal = 10;

	public const int Interactives = 11;

	public const int Hands = 12;

	public const int Stairways = 14;

	public const int FaceMask = 15;

	public const int JustOutOfBounds = 16;

	public const int JustPhysics = 17;

	public const int Telepoints = 18;

	public const int UIOverlay = 19;

	public const int EGrill = 20;

	public const int Background = 31;

	public const int MaskDefault = 1;

	public const int MaskIgnoreRaycast = 4;

	public const int MaskUI = 32;

	public const int MaskUIOverlay = 524288;

	public const int MaskTeleportArc = 256;

	public const int MaskPortal = 1024;

	public const int MaskInteractives = 2048;

	public const int MaskHands = 4096;

	public const int MaskStairways = 16384;

	public const int MaskFaceMask = 32768;

	public const int MaskJustOutOfBounds = 65536;

	public const int MaskJustPhysics = 131072;

	public const int MaskTelepoints = 262144;

	public const int MaskEGrill = 1048576;

	public const int MaskAll = -1;
}
public class LeverAnimation : IDObject, IAwakeEvent
{
	public IDObjectRef AnimationObject;

	public float animationDelay;

	public FMODEventAsset soundAnim;

	private bool leverAnimPlayed;

	private Animation animComp;

	private Portal portal;

	private IHaglet leverForwardRoutine;

	private IHaglet leverBackwardRoutine;

	public bool isLeverUp => leverAnimPlayed;

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		base.owner = owner;
		animComp = AnimationObject.GetComponent<Animation>();
		portal = AnimationObject.GetComponentInChildren<Portal>(null, disabled: true);
		Haglet.Create(out leverBackwardRoutine, LeverBackwardRoutine);
		Haglet.Create(out leverForwardRoutine, LeverForwardRoutine);
	}

	[Event(EventName = "Lever Forward")]
	public void LeverForward(object sender)
	{
		leverForwardRoutine.Start(resetIfStarted: true);
	}

	[Event(EventName = "Lever Backward")]
	public void LeverBackward(object sender)
	{
		leverBackwardRoutine.Start(resetIfStarted: true);
	}

	public IEnumerator<Routine.Yield> LeverForwardRoutine()
	{
		if (animComp == null)
		{
			UnityEngine.Debug.LogWarning("AnimComponent is null");
		}
		else if (animComp.clip == null)
		{
			UnityEngine.Debug.LogWarning("Default Animclip is null");
		}
		else if (!leverAnimPlayed)
		{
			yield return Wait.For.Seconds(animationDelay);
			animComp[animComp.clip.name].speed = 1f;
			animComp[animComp.clip.name].normalizedTime = 0f;
			animComp.Play();
			if ((bool)soundAnim)
			{
				FAC.Inst.PlayOneShot(soundAnim, animComp.transform.position);
			}
			if ((bool)portal)
			{
				portal.SetPlayerTeleporting(allow: false);
			}
			yield return Wait.For.Seconds(animComp.clip.length);
			if ((bool)portal)
			{
				portal.SetPlayerTeleporting(allow: true);
			}
			leverAnimPlayed = true;
		}
	}

	public IEnumerator<Routine.Yield> LeverBackwardRoutine()
	{
		if (animComp == null)
		{
			UnityEngine.Debug.LogWarning("AnimComponent is null");
		}
		else if (animComp.clip == null)
		{
			UnityEngine.Debug.LogWarning("Default Animclip is null");
		}
		else if (leverAnimPlayed)
		{
			yield return Wait.For.Seconds(animationDelay);
			animComp[animComp.clip.name].speed = -1f;
			animComp[animComp.clip.name].normalizedTime = 1f;
			animComp.Play();
			if ((bool)soundAnim)
			{
				FAC.Inst.PlayOneShot(soundAnim, animComp.transform.position);
			}
			if ((bool)portal)
			{
				portal.SetPlayerTeleporting(allow: false);
			}
			yield return Wait.For.Seconds(animComp.clip.length);
			if ((bool)portal)
			{
				portal.SetPlayerTeleporting(allow: true);
			}
			leverAnimPlayed = false;
		}
	}
}
public class LeverController : MonoBehaviour, IAwakeEvent
{
	[SerializeField]
	private SceneInfo_BundleRef labInfoRef;

	private PortalMachine[] portalMachines;

	private PlanetariumLever[] mansfieldLevers;

	private SceneInfo sceneLoaded;

	private MRBase owner;

	public SceneInfo labInfo => labInfoRef?.Load();

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		this.owner = owner;
		portalMachines = GetComponentsInChildren<PortalMachine>(includeInactive: true);
		PortalMachine[] array = portalMachines;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].AssignLeverController(this);
		}
		mansfieldLevers = GetComponentsInChildren<PlanetariumLever>(includeInactive: true);
		PlanetariumLever[] array2 = mansfieldLevers;
		foreach (PlanetariumLever obj in array2)
		{
			obj.OnAwakeLR(owner);
			obj.AssignLeverController(this);
		}
	}

	public void LoadScene(SceneInfo sceneToLoad, object sender)
	{
		owner.RemoveConnectingScene(sceneLoaded);
		owner.AddConnectingScene(sceneToLoad);
		LR.Inst.LoadAdjacentScenes();
		sceneLoaded = sceneToLoad;
		PortalMachine[] array = portalMachines;
		foreach (PortalMachine portalMachine in array)
		{
			if (portalMachine != sender)
			{
				portalMachine.DeactivateMachine();
			}
		}
		PlanetariumLever[] array2 = mansfieldLevers;
		foreach (PlanetariumLever planetariumLever in array2)
		{
			if (planetariumLever != sender)
			{
				planetariumLever.ResetLever();
			}
		}
	}

	public void DebugUnlockMansfieldPortals()
	{
		PlanetariumLever[] array = mansfieldLevers;
		foreach (PlanetariumLever obj in array)
		{
			obj.DebugUnlock = true;
			obj.OnAreaEnter();
		}
	}
}
public enum enColorchannels
{
	all,
	red,
	blue,
	green
}
public enum enWaveFunctions
{
	sinus,
	triangle,
	square,
	sawtooth,
	inverted_saw,
	noise,
	random_sin
}
public class LightFlicker : MonoBehaviour
{
	public enColorchannels colorChannel;

	public enWaveFunctions waveFunction;

	public float offset;

	public float amplitude = 1f;

	public float phase;

	public float frequency = 0.5f;

	public bool affectsIntensity = true;

	private Color originalColor;

	private float originalIntensity;

	private void Start()
	{
		originalColor = GetComponent<Light>().color;
		originalIntensity = GetComponent<Light>().intensity;
	}

	private void Update()
	{
		Light component = GetComponent<Light>();
		if (affectsIntensity)
		{
			component.intensity = originalIntensity * EvalWave();
		}
		Color color = originalColor;
		Color color2 = GetComponent<Light>().color;
		if (colorChannel == enColorchannels.all)
		{
			component.color = originalColor * EvalWave();
		}
		else if (colorChannel == enColorchannels.red)
		{
			component.color = new Color(color.r * EvalWave(), color2.g, color2.b, color2.a);
		}
		else if (colorChannel == enColorchannels.green)
		{
			component.color = new Color(color2.r, color.g * EvalWave(), color2.b, color2.a);
		}
		else
		{
			component.color = new Color(color2.r, color2.g, color.b * EvalWave(), color2.a);
		}
	}

	private float EvalWave()
	{
		float num = (Time.time + phase) * frequency;
		num -= Mathf.Floor(num);
		float num2 = ((waveFunction == enWaveFunctions.sinus) ? Mathf.Sin(num * 2f * (float)Math.PI) : ((waveFunction == enWaveFunctions.triangle) ? ((!(num < 0.5f)) ? (-4f * num + 3f) : (4f * num - 1f)) : ((waveFunction == enWaveFunctions.square) ? ((!(num < 0.5f)) ? (-1f) : 1f) : ((waveFunction == enWaveFunctions.sawtooth) ? num : ((waveFunction == enWaveFunctions.inverted_saw) ? (1f - num) : ((waveFunction == enWaveFunctions.noise) ? (1f - UnityEngine.Random.value * 4f) : ((waveFunction != enWaveFunctions.random_sin) ? 1f : (Mathf.Sin(num * 2f * (float)Math.PI) * (Time.time % 2f)))))))));
		return num2 * amplitude + offset;
	}
}
public class LightMapEmissiveAnimator : MonoBehaviour, IAwakeEvent, IUpdateEvent
{
	private Material lightMapMaterial;

	public Vector2 emissiveRange = new Vector2(1f, 1.5f);

	[Range(1f, 10f)]
	public int smoothing = 5;

	private Queue<float> smoothQueue = new Queue<float>(10);

	private float lastSum;

	public void OnAwakeLR(MRBase owner)
	{
		MeshRenderer component = GetComponent<MeshRenderer>();
		if ((bool)component)
		{
			lightMapMaterial = component.sharedMaterial;
		}
	}

	void IUpdateEvent.OnUpdateLR()
	{
		if ((bool)lightMapMaterial)
		{
			while (smoothQueue.Count >= smoothing)
			{
				lastSum -= smoothQueue.Dequeue();
			}
			float num = UnityEngine.Random.Range(emissiveRange.x, emissiveRange.y);
			smoothQueue.Enqueue(num);
			lastSum += num;
			float value = lastSum / (float)smoothQueue.Count;
			lightMapMaterial.SetFloat("_EmissiveStrength", value);
		}
	}
}
public class LoadingScreenController : MonoBehaviour
{
	private static LoadingScreenController _instance;

	public Transform bookParentTransform;

	public Camera loadingCam;

	public Animation loadingBookAnimation;

	public Animation[] objectsToAnimate;

	public float bookDist = 1.1f;

	public float loadingPreWait = 0.5f;

	public float titlePreWait = 0.5f;

	public float titlePostWait = 0.5f;

	public float bookTrackingSpeed = 5f;

	public ParticleSystem pageParticles;

	public FMODEventAsset soundBookOculus;

	public FMODEventAsset soundBookCoatsink;

	public FMODEventAsset soundPaperParticles;

	private FMOD.Studio.EventInstance eventPaperParticles;

	public IHaglet titleRoutine;

	private IHaglet animateRoutine;

	public static LoadingScreenController Inst => _instance;

	public void OnAwakeLR()
	{
		_instance = this;
		base.gameObject.SetActive(value: false);
		Haglet.Create(out animateRoutine, AnimateRoutine);
		Haglet.Create(out titleRoutine, TitleRoutine);
		if (SceneManager.GetSceneByName("SC_Splashscreen").isLoaded)
		{
			loadingCam.gameObject.SetActive(value: false);
		}
	}

	public void ShowLoadingScreen()
	{
		base.transform.root.GetComponentInChildren<CC>(includeInactive: true).gameObject.SetActive(value: false);
		base.gameObject.SetActive(value: true);
		pageParticles.Play(withChildren: true);
		animateRoutine.Start();
		IC.Inst.PauseMenuEnabled = false;
	}

	private IEnumerator<Routine.Yield> TitleRoutine()
	{
		float preWaitTimer = titlePreWait;
		while (preWaitTimer > 0f)
		{
			LR.Inst.SetVCAMusicVolume();
			LR.Inst.SetVCASFXVolume();
			LR.Inst.SetVCAVoVolume();
			if (!eventPaperParticles.isValid())
			{
				eventPaperParticles = FAC.Inst.PlayOneShot(soundPaperParticles, Vector3.forward);
			}
			preWaitTimer -= IC.RealDeltaTime;
			yield return Wait.For.LRRealtimeUpdates(1);
		}
		animateRoutine.Stop();
		loadingBookAnimation.Play("CH_CreditsBook_LoadingOutro");
		while (loadingBookAnimation.isPlaying)
		{
			yield return Wait.For.Updates(1);
		}
		bookParentTransform.gameObject.SetActive(value: false);
		for (int i = 0; i < objectsToAnimate.Length; i++)
		{
			Animation currObj = objectsToAnimate[i];
			currObj.gameObject.SetActive(value: true);
			Vector3 position = currObj.GetComponentInChildren<MeshFilter>().transform.position;
			FAC.Inst.PlayOneShot((i == 0) ? soundBookOculus : soundBookCoatsink, position);
			currObj.Play();
			while (currObj.isPlaying)
			{
				CalculateOrbitPos(currObj.transform);
				yield return Wait.For.Updates(1);
			}
			currObj.gameObject.SetActive(value: false);
		}
		pageParticles.Stop(withChildren: true, ParticleSystemStopBehavior.StopEmitting);
		yield return Wait.For.Seconds(titlePostWait);
	}

	public void HideLoadingScreen()
	{
		if (animateRoutine.started)
		{
			animateRoutine.Stop();
		}
		CC.Inst.gameObject.SetActive(value: true);
		if (!MainCamera.Inst.gameObject.activeInHierarchy)
		{
			MainCamera.Inst.gameObject.SetActive(value: true);
		}
		base.gameObject.SetActive(value: false);
		pageParticles.Stop(withChildren: true, ParticleSystemStopBehavior.StopEmittingAndClear);
		eventPaperParticles.stop(STOP_MODE.ALLOWFADEOUT);
		animateRoutine.Stop();
	}

	private IEnumerator<Routine.Yield> AnimateRoutine()
	{
		yield return Wait.For.Seconds(loadingPreWait);
		loadingBookAnimation.gameObject.SetActive(value: true);
		loadingBookAnimation.Play("CH_CreditsBook_LoadingIntro");
		while (true)
		{
			CalculateOrbitPos(bookParentTransform);
			yield return Wait.For.Updates(1);
		}
	}

	private void CalculateOrbitPos(Transform trackingObject)
	{
		Vector3 forward = loadingCam.transform.forward;
		forward.y = 0f;
		forward.Normalize();
		float t = Mathf.Clamp01(Time.deltaTime * bookTrackingSpeed);
		Vector3 b = loadingCam.transform.position + forward * bookDist;
		b = Vector3.Lerp(trackingObject.position, b, t);
		Quaternion b2 = Quaternion.LookRotation(forward, Vector3.up);
		b2 = Quaternion.Lerp(trackingObject.rotation, b2, t);
		trackingObject.position = b;
		trackingObject.rotation = b2;
	}
}
public class LoadingSphere : MonoBehaviour
{
	private MaterialPropertyBlock mpb;

	public MeshRenderer meshRenderer;

	private int shaderPropAlpha;

	public void OnAwakeLR()
	{
		mpb = new MaterialPropertyBlock();
		meshRenderer.SetPropertyBlock(mpb);
		shaderPropAlpha = Shader.PropertyToID("_Alpha");
		base.gameObject.SetActive(value: true);
	}

	public void UpdateAlpha(float alpha)
	{
		mpb.SetFloat(shaderPropAlpha, Mathf.SmoothStep(0f, 1f, Mathf.Clamp01(alpha)));
		meshRenderer.SetPropertyBlock(mpb);
		if (alpha <= 0f)
		{
			base.gameObject.SetActive(value: false);
		}
	}
}
public class LookAtDetector : MonoBehaviour, IAwakeEvent, IUpdateEvent, IPrepareEvent
{
	[SerializeField]
	private Transform targetXform;

	[Range(0.5f, 1f)]
	public float accuracy = 0.9f;

	public Bounds bounds;

	public bool shouldRaycast;

	public Event OnEnterView;

	public Event OnEnterViewOnce;

	public Event OnExitView;

	private bool hasLookedAt;

	private HagletValue<bool> inView;

	private IHaglet prepareEventRoutine;

	public Wait OnNotInView => Wait.Until.False(inView);

	public Wait OnInView => Wait.Until.True(inView);

	public Wait IsInView => Wait.Until.True(inView, 1, allowPreMetNow: true);

	public Wait IsNotInView => Wait.Until.False(inView, 1, allowPreMetNow: true);

	public bool IsInViewBool => inView.value;

	public bool IsNotInViewBool => !inView.value;

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		if (OnEnterView == null)
		{
			OnEnterView = new Event();
		}
		if (OnEnterViewOnce == null)
		{
			OnEnterViewOnce = new Event();
		}
		if (OnExitView == null)
		{
			OnExitView = new Event();
		}
		if (targetXform == null)
		{
			targetXform = base.transform;
		}
		HagletValue.Create(out inView, null, initVal: false, null, 8);
		Haglet.Create(out prepareEventRoutine, PrepareEventRoutine);
	}

	Wait IPrepareEvent.PrepareEvents()
	{
		return prepareEventRoutine.Start();
	}

	private IEnumerator<Routine.Yield> PrepareEventRoutine()
	{
		OnEnterView.PrepareInvoke();
		yield return Wait.For.LRUpdates(1);
		OnEnterViewOnce.PrepareInvoke();
		yield return Wait.For.LRUpdates(1);
		OnExitView.PrepareInvoke();
	}

	void IUpdateEvent.OnUpdateLR()
	{
		bool flag = false;
		Vector3 headPosition = IC.GetHeadPosition();
		Vector3 point = base.transform.InverseTransformPoint(headPosition);
		if (bounds.Contains(point))
		{
			Vector3 normalized = (IC.GetHeadRotation() * Vector3.forward).normalized;
			Vector3 direction = targetXform.position - headPosition;
			Vector3 normalized2 = direction.normalized;
			if (Vector3.Dot(normalized, normalized2) > accuracy)
			{
				if (shouldRaycast)
				{
					int layerMask = -1048577;
					if (Physics.Raycast(headPosition, direction, out var hitInfo, direction.magnitude, layerMask) && (bool)hitInfo.collider)
					{
						Transform transform = hitInfo.collider.transform;
						Transform parent = transform.parent;
						while (parent != null)
						{
							if (transform == targetXform)
							{
								flag = true;
								break;
							}
							transform = parent;
							parent = transform.parent;
						}
					}
				}
				else
				{
					flag = true;
				}
			}
		}
		if (inView.value == flag)
		{
			return;
		}
		inView.value = flag;
		if (flag)
		{
			OnEnterView.Invoke();
			if (!hasLookedAt)
			{
				hasLookedAt = true;
				OnEnterViewOnce.Invoke();
			}
		}
		else
		{
			OnExitView.Invoke();
		}
	}

	private void OnValidate()
	{
		if (targetXform == null)
		{
			targetXform = base.transform;
		}
	}

	protected void OnDisable()
	{
		if (inView != null)
		{
			inView.value = false;
		}
	}

	private void OnDrawGizmos()
	{
		Gizmos.matrix = base.transform.localToWorldMatrix;
		Color color = (Gizmos.color = Color.cyan);
		Gizmos.DrawWireCube(bounds.center, bounds.size);
		color.a = 0.3f;
		Gizmos.color = color;
		Gizmos.DrawCube(bounds.center, bounds.size);
	}
}
public class ManualAnimation : MonoBehaviour
{
	public Animation animation;

	private IHaglet<IHagletEvent, string, bool> playAnimManualRoutine;

	public void Initalise()
	{
		Haglet.Create(out playAnimManualRoutine, (Routine.Func3<IHagletEvent, string, bool>)PlayAnimManualRoutine, (string)null, startNow: false, (int?)null, (string)null);
	}

	private IEnumerator<Routine.Yield> PlayAnimManualRoutine(IHagletEvent updateEvent, string _clipName = "", bool instant = false)
	{
		_clipName = (string.IsNullOrEmpty(_clipName) ? animation.clip.name : _clipName);
		if (Routine.Skipping)
		{
			instant = true;
		}
		animation.Play(_clipName);
		if (instant)
		{
			animation[_clipName].enabled = true;
			animation[_clipName].normalizedTime = 1f;
			animation[_clipName].weight = 1f;
			animation.Sample();
			animation[_clipName].enabled = false;
			yield break;
		}
		AnimationState state = animation[_clipName];
		state.enabled = true;
		state.normalizedTime = 0f;
		state.weight = 1f;
		float time = 0f;
		float cliplength = state.length;
		while (time <= cliplength)
		{
			time += updateEvent.deltaTime;
			float normalizedTime = Mathf.Clamp01(time / cliplength);
			state.normalizedTime = normalizedTime;
			animation.Sample();
			yield return Wait.Until.Happening(updateEvent) | Wait.Until.ArgChange(1);
		}
		state.normalizedTime = 1f;
		animation.Sample();
	}

	public Wait PlayAnimManual(IHagletEvent updateEvent, bool call, string _clipName = "", bool instant = false)
	{
		if (!animation)
		{
			UnityEngine.Debug.Log("No animation component assigned!!!!", this);
			return Wait.None;
		}
		if (call)
		{
			return playAnimManualRoutine.Call(updateEvent, _clipName, instant);
		}
		return playAnimManualRoutine.Start(updateEvent, _clipName, instant, resetIfStarted: true);
	}
}
public class MaskController : MonoBehaviour
{
	private MeshRenderer mr;

	private MaterialPropertyBlock mpb;

	private int _Alpha = Shader.PropertyToID("_Alpha");

	private float currentAlpha = 1f;

	public void OnAwakeLR()
	{
		mpb = new MaterialPropertyBlock();
		mr = GetComponent<MeshRenderer>();
	}

	public void OnUpdateLR()
	{
		MRBase owner = MainCamera.Inst.GetOwner();
		float num = 1f;
		Vector3 position = base.transform.position;
		Vector3 right = base.transform.right;
		MaskHide[] maskHides = owner.maskHides;
		for (int i = 0; i < maskHides.Length; i++)
		{
			float b = maskHides[i].CalculateMaskAlpha(position, right);
			num = Mathf.Min(num, b);
		}
		SetAlpha(Mathf.MoveTowards(currentAlpha, num, 2f * IC.DeltaTime));
	}

	private void SetAlpha(float alpha)
	{
		currentAlpha = alpha;
		mpb.SetFloat(_Alpha, alpha);
		mr.SetPropertyBlock(mpb);
	}
}
public class MaskHide : MonoBehaviour
{
	public Portal mirror;

	public GameObject target;

	public Rasterizer rasterizer;

	public float innerRadius;

	public float outerRadius;

	private void OnDrawGizmosSelected()
	{
		if ((bool)target)
		{
			Color cyan = Color.cyan;
			_ = (target.transform.position - mirror.transform.position) / 2f + mirror.transform.position;
			cyan.a = 0.3f;
		}
	}

	public float CalculateMaskAlpha(Vector3 maskPos, Vector3 maskFwd)
	{
		if (rasterizer.GetCurrentMatchPercentage() <= 0.01f)
		{
			return 1f;
		}
		Vector3 vector = target.transform.position - mirror.transform.position;
		if (Vector3.Dot(mirror.transform.forward, vector.normalized) < 0.8f)
		{
			return 1f;
		}
		if (Vector3.Dot(maskFwd, (mirror.transform.position - maskPos).normalized) < 0.8f)
		{
			return 1f;
		}
		Vector3 b = MathfX.ClosestPointLineSegment(maskPos, mirror.transform.position, target.transform.position);
		float value = Vector3.Distance(maskPos, b);
		float t = Mathf.InverseLerp(innerRadius, outerRadius, value);
		return Mathf.Lerp(0.1f, 1f, t);
	}
}
[RequireComponent(typeof(MeshFilter))]
public class MeshBoundsDrawer : MonoBehaviour
{
}
public class MonoBehaviourEnableOnLightSensor : MonoBehaviour, IAwakeEvent, IUpdateEvent
{
	public IDObjectRef lightSensorRef;

	public MonoBehaviour monoBehaviour;

	public bool inverse;

	private LightSensor lightSensor;

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		lightSensor = LR.Inst.GetIDObjectComponent<LightSensor>(lightSensorRef);
	}

	void IUpdateEvent.OnUpdateLR()
	{
		bool num = monoBehaviour.enabled;
		bool flag = (inverse ? (!lightSensor.isReceivingLight.value) : lightSensor.isReceivingLight.value);
		if (num != flag)
		{
			monoBehaviour.enabled = flag;
		}
	}
}
public class MovementSound : MonoBehaviour
{
	public FMODEventAsset asset;

	private FMOD.Studio.EventInstance evt;

	public float stopVelocity = 0.1f;

	public float stopVelocityMin = 1f;

	public string movementParameter;

	public string stopParameter;

	[ReadOnly]
	public Vector3 currVelocity = Vector3.zero;

	[ReadOnly]
	public float currAcceleration;

	private bool eventStopped;

	private bool reachedStopVelocityMin;

	public void StartSound()
	{
		if (!evt.isValid() || eventStopped)
		{
			evt = FAC.Inst.PlayOneShot(asset, base.transform);
			eventStopped = false;
		}
		if (movementParameter == "")
		{
			movementParameter = "Velocity";
		}
		evt.setParameterValue(movementParameter, 0f);
	}

	public void UpdateSound(Vector3 velocity)
	{
		if (!base.enabled)
		{
			if (evt.isValid())
			{
				evt.stop(STOP_MODE.ALLOWFADEOUT);
			}
			return;
		}
		if (!evt.isValid() || eventStopped)
		{
			evt = FAC.Inst.PlayOneShot(asset, base.transform);
			eventStopped = false;
			evt.setParameterValue(movementParameter, 0f);
		}
		float num = (velocity - currVelocity).magnitude / IC.DeltaTime;
		currVelocity = velocity;
		if (num > stopVelocityMin)
		{
			reachedStopVelocityMin = true;
		}
		if (num < stopVelocity && reachedStopVelocityMin)
		{
			evt.setParameterValue(stopParameter, 1f);
			eventStopped = true;
			reachedStopVelocityMin = false;
		}
		currAcceleration = num;
		if (evt.isValid())
		{
			evt.setParameterValue(movementParameter, num);
		}
	}

	public void Terminate()
	{
		if (evt.isValid())
		{
			evt.stop(STOP_MODE.ALLOWFADEOUT);
		}
	}
}
public class MusicEvent : MonoBehaviour
{
	public FMODEventAsset Music;

	public string ParameterName;

	public float ParameterValue;

	[Event(EventName = "Play Music")]
	public void Play(object sender)
	{
		LR.Inst.SetMusic(Music);
	}

	[Event(EventName = "Play Music As OneShot")]
	public void PlayOneShot(object sender)
	{
		LR.Inst.PlayMusicOneShot(Music);
	}

	[Event(EventName = "Stop Music")]
	public void Stop(object sender)
	{
		LR.Inst.StopMusic();
	}

	[Event(EventName = "Set Parameter")]
	public void SetParameter(object sender)
	{
		LR.Inst.SetMusicParameter(ParameterName, ParameterValue);
	}
}
public delegate float NoiseMethod(Vector3 point, float frequency);
public enum NoiseMethodType
{
	Value,
	Perlin
}
public static class Noise
{
	public static NoiseMethod[] valueMethods = new NoiseMethod[3] { Value1D, Value2D, Value3D };

	public static NoiseMethod[] perlinMethods = new NoiseMethod[3] { Perlin1D, Perlin2D, Perlin3D };

	public static NoiseMethod[][] methods = new NoiseMethod[2][] { valueMethods, perlinMethods };

	private static int[] hash = new int[512]
	{
		151, 160, 137, 91, 90, 15, 131, 13, 201, 95,
		96, 53, 194, 233, 7, 225, 140, 36, 103, 30,
		69, 142, 8, 99, 37, 240, 21, 10, 23, 190,
		6, 148, 247, 120, 234, 75, 0, 26, 197, 62,
		94, 252, 219, 203, 117, 35, 11, 32, 57, 177,
		33, 88, 237, 149, 56, 87, 174, 20, 125, 136,
		171, 168, 68, 175, 74, 165, 71, 134, 139, 48,
		27, 166, 77, 146, 158, 231, 83, 111, 229, 122,
		60, 211, 133, 230, 220, 105, 92, 41, 55, 46,
		245, 40, 244, 102, 143, 54, 65, 25, 63, 161,
		1, 216, 80, 73, 209, 76, 132, 187, 208, 89,
		18, 169, 200, 196, 135, 130, 116, 188, 159, 86,
		164, 100, 109, 198, 173, 186, 3, 64, 52, 217,
		226, 250, 124, 123, 5, 202, 38, 147, 118, 126,
		255, 82, 85, 212, 207, 206, 59, 227, 47, 16,
		58, 17, 182, 189, 28, 42, 223, 183, 170, 213,
		119, 248, 152, 2, 44, 154, 163, 70, 221, 153,
		101, 155, 167, 43, 172, 9, 129, 22, 39, 253,
		19, 98, 108, 110, 79, 113, 224, 232, 178, 185,
		112, 104, 218, 246, 97, 228, 251, 34, 242, 193,
		238, 210, 144, 12, 191, 179, 162, 241, 81, 51,
		145, 235, 249, 14, 239, 107, 49, 192, 214, 31,
		181, 199, 106, 157, 184, 84, 204, 176, 115, 121,
		50, 45, 127, 4, 150, 254, 138, 236, 205, 93,
		222, 114, 67, 29, 24, 72, 243, 141, 128, 195,
		78, 66, 215, 61, 156, 180, 151, 160, 137, 91,
		90, 15, 131, 13, 201, 95, 96, 53, 194, 233,
		7, 225, 140, 36, 103, 30, 69, 142, 8, 99,
		37, 240, 21, 10, 23, 190, 6, 148, 247, 120,
		234, 75, 0, 26, 197, 62, 94, 252, 219, 203,
		117, 35, 11, 32, 57, 177, 33, 88, 237, 149,
		56, 87, 174, 20, 125, 136, 171, 168, 68, 175,
		74, 165, 71, 134, 139, 48, 27, 166, 77, 146,
		158, 231, 83, 111, 229, 122, 60, 211, 133, 230,
		220, 105, 92, 41, 55, 46, 245, 40, 244, 102,
		143, 54, 65, 25, 63, 161, 1, 216, 80, 73,
		209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
		135, 130, 116, 188, 159, 86, 164, 100, 109, 198,
		173, 186, 3, 64, 52, 217, 226, 250, 124, 123,
		5, 202, 38, 147, 118, 126, 255, 82, 85, 212,
		207, 206, 59, 227, 47, 16, 58, 17, 182, 189,
		28, 42, 223, 183, 170, 213, 119, 248, 152, 2,
		44, 154, 163, 70, 221, 153, 101, 155, 167, 43,
		172, 9, 129, 22, 39, 253, 19, 98, 108, 110,
		79, 113, 224, 232, 178, 185, 112, 104, 218, 246,
		97, 228, 251, 34, 242, 193, 238, 210, 144, 12,
		191, 179, 162, 241, 81, 51, 145, 235, 249, 14,
		239, 107, 49, 192, 214, 31, 181, 199, 106, 157,
		184, 84, 204, 176, 115, 121, 50, 45, 127, 4,
		150, 254, 138, 236, 205, 93, 222, 114, 67, 29,
		24, 72, 243, 141, 128, 195, 78, 66, 215, 61,
		156, 180
	};

	private const int hashMask = 255;

	private static float[] gradients1D = new float[2] { 1f, -1f };

	private const int gradientsMask1D = 1;

	private static Vector2[] gradients2D = new Vector2[8]
	{
		new Vector2(1f, 0f),
		new Vector2(-1f, 0f),
		new Vector2(0f, 1f),
		new Vector2(0f, -1f),
		new Vector2(1f, 1f).normalized,
		new Vector2(-1f, 1f).normalized,
		new Vector2(1f, -1f).normalized,
		new Vector2(-1f, -1f).normalized
	};

	private const int gradientsMask2D = 7;

	private static Vector3[] gradients3D = new Vector3[16]
	{
		new Vector3(1f, 1f, 0f),
		new Vector3(-1f, 1f, 0f),
		new Vector3(1f, -1f, 0f),
		new Vector3(-1f, -1f, 0f),
		new Vector3(1f, 0f, 1f),
		new Vector3(-1f, 0f, 1f),
		new Vector3(1f, 0f, -1f),
		new Vector3(-1f, 0f, -1f),
		new Vector3(0f, 1f, 1f),
		new Vector3(0f, -1f, 1f),
		new Vector3(0f, 1f, -1f),
		new Vector3(0f, -1f, -1f),
		new Vector3(1f, 1f, 0f),
		new Vector3(-1f, 1f, 0f),
		new Vector3(0f, -1f, 1f),
		new Vector3(0f, -1f, -1f)
	};

	private const int gradientsMask3D = 15;

	private static float sqr2 = Mathf.Sqrt(2f);

	private static float Dot(Vector2 g, float x, float y)
	{
		return g.x * x + g.y * y;
	}

	private static float Dot(Vector3 g, float x, float y, float z)
	{
		return g.x * x + g.y * y + g.z * z;
	}

	private static float Smooth(float t)
	{
		return t * t * t * (t * (t * 6f - 15f) + 10f);
	}

	public static float Value1D(Vector3 point, float frequency)
	{
		point *= frequency;
		int num = Mathf.FloorToInt(point.x);
		float t = point.x - (float)num;
		num &= 0xFF;
		int num2 = num + 1;
		int num3 = hash[num];
		int num4 = hash[num2];
		t = Smooth(t);
		return Mathf.Lerp(num3, num4, t) * 0.003921569f;
	}

	public static float Value2D(Vector3 point, float frequency)
	{
		point *= frequency;
		int num = Mathf.FloorToInt(point.x);
		int num2 = Mathf.FloorToInt(point.y);
		float t = point.x - (float)num;
		float t2 = point.y - (float)num2;
		num &= 0xFF;
		num2 &= 0xFF;
		int num3 = num + 1;
		int num4 = num2 + 1;
		int num5 = hash[num];
		int num6 = hash[num3];
		int num7 = hash[num5 + num2];
		int num8 = hash[num6 + num2];
		int num9 = hash[num5 + num4];
		int num10 = hash[num6 + num4];
		t = Smooth(t);
		return Mathf.Lerp(t: Smooth(t2), a: Mathf.Lerp(num7, num8, t), b: Mathf.Lerp(num9, num10, t)) * 0.003921569f;
	}

	public static float Value3D(Vector3 point, float frequency)
	{
		point *= frequency;
		int num = Mathf.FloorToInt(point.x);
		int num2 = Mathf.FloorToInt(point.y);
		int num3 = Mathf.FloorToInt(point.z);
		float t = point.x - (float)num;
		float t2 = point.y - (float)num2;
		float t3 = point.z - (float)num3;
		num &= 0xFF;
		num2 &= 0xFF;
		num3 &= 0xFF;
		int num4 = num + 1;
		int num5 = num2 + 1;
		int num6 = num3 + 1;
		int num7 = hash[num];
		int num8 = hash[num4];
		int num9 = hash[num7 + num2];
		int num10 = hash[num8 + num2];
		int num11 = hash[num7 + num5];
		int num12 = hash[num8 + num5];
		int num13 = hash[num9 + num3];
		int num14 = hash[num10 + num3];
		int num15 = hash[num11 + num3];
		int num16 = hash[num12 + num3];
		int num17 = hash[num9 + num6];
		int num18 = hash[num10 + num6];
		int num19 = hash[num11 + num6];
		int num20 = hash[num12 + num6];
		t = Smooth(t);
		t2 = Smooth(t2);
		return Mathf.Lerp(t: Smooth(t3), a: Mathf.Lerp(Mathf.Lerp(num13, num14, t), Mathf.Lerp(num15, num16, t), t2), b: Mathf.Lerp(Mathf.Lerp(num17, num18, t), Mathf.Lerp(num19, num20, t), t2)) * 0.003921569f;
	}

	public static float Perlin1D(Vector3 point, float frequency)
	{
		point *= frequency;
		int num = Mathf.FloorToInt(point.x);
		float num2 = point.x - (float)num;
		float num3 = num2 - 1f;
		num &= 0xFF;
		int num4 = num + 1;
		float num5 = gradients1D[hash[num] & 1];
		float num6 = gradients1D[hash[num4] & 1];
		float a = num5 * num2;
		float b = num6 * num3;
		float t = Smooth(num2);
		return Mathf.Lerp(a, b, t) * 2f;
	}

	public static float Perlin2D(Vector3 point, float frequency)
	{
		point *= frequency;
		int num = Mathf.FloorToInt(point.x);
		int num2 = Mathf.FloorToInt(point.y);
		float num3 = point.x - (float)num;
		float num4 = point.y - (float)num2;
		float x = num3 - 1f;
		float y = num4 - 1f;
		num &= 0xFF;
		num2 &= 0xFF;
		int num5 = num + 1;
		int num6 = num2 + 1;
		int num7 = hash[num];
		int num8 = hash[num5];
		Vector2 g = gradients2D[hash[num7 + num2] & 7];
		Vector2 g2 = gradients2D[hash[num8 + num2] & 7];
		Vector2 g3 = gradients2D[hash[num7 + num6] & 7];
		Vector2 g4 = gradients2D[hash[num8 + num6] & 7];
		float a = Dot(g, num3, num4);
		float b = Dot(g2, x, num4);
		float a2 = Dot(g3, num3, y);
		float b2 = Dot(g4, x, y);
		float t = Smooth(num3);
		float t2 = Smooth(num4);
		return Mathf.Lerp(Mathf.Lerp(a, b, t), Mathf.Lerp(a2, b2, t), t2) * sqr2;
	}

	public static float Perlin3D(Vector3 point, float frequency)
	{
		point *= frequency;
		int num = Mathf.FloorToInt(point.x);
		int num2 = Mathf.FloorToInt(point.y);
		int num3 = Mathf.FloorToInt(point.z);
		float num4 = point.x - (float)num;
		float num5 = point.y - (float)num2;
		float num6 = point.z - (float)num3;
		float x = num4 - 1f;
		float y = num5 - 1f;
		float z = num6 - 1f;
		num &= 0xFF;
		num2 &= 0xFF;
		num3 &= 0xFF;
		int num7 = num + 1;
		int num8 = num2 + 1;
		int num9 = num3 + 1;
		int num10 = hash[num];
		int num11 = hash[num7];
		int num12 = hash[num10 + num2];
		int num13 = hash[num11 + num2];
		int num14 = hash[num10 + num8];
		int num15 = hash[num11 + num8];
		Vector3 g = gradients3D[hash[num12 + num3] & 0xF];
		Vector3 g2 = gradients3D[hash[num13 + num3] & 0xF];
		Vector3 g3 = gradients3D[hash[num14 + num3] & 0xF];
		Vector3 g4 = gradients3D[hash[num15 + num3] & 0xF];
		Vector3 g5 = gradients3D[hash[num12 + num9] & 0xF];
		Vector3 g6 = gradients3D[hash[num13 + num9] & 0xF];
		Vector3 g7 = gradients3D[hash[num14 + num9] & 0xF];
		Vector3 g8 = gradients3D[hash[num15 + num9] & 0xF];
		float a = Dot(g, num4, num5, num6);
		float b = Dot(g2, x, num5, num6);
		float a2 = Dot(g3, num4, y, num6);
		float b2 = Dot(g4, x, y, num6);
		float a3 = Dot(g5, num4, num5, z);
		float b3 = Dot(g6, x, num5, z);
		float a4 = Dot(g7, num4, y, z);
		float b4 = Dot(g8, x, y, z);
		float t = Smooth(num4);
		float t2 = Smooth(num5);
		float t3 = Smooth(num6);
		return Mathf.Lerp(Mathf.Lerp(Mathf.Lerp(a, b, t), Mathf.Lerp(a2, b2, t), t2), Mathf.Lerp(Mathf.Lerp(a3, b3, t), Mathf.Lerp(a4, b4, t), t2), t3);
	}

	public static float Sum(NoiseMethod method, Vector3 point, float frequency, int octaves, float lacunarity, float persistence)
	{
		float num = method(point, frequency);
		float num2 = 1f;
		float num3 = 1f;
		for (int i = 1; i < octaves; i++)
		{
			frequency *= lacunarity;
			num2 *= persistence;
			num3 += num2;
			num += method(point, frequency) * num2;
		}
		return num / num3;
	}
}
public class NothingToSeeHere : MonoBehaviour
{
	private BoxCollider[] colliders;

	private float timer;

	public IHaglet routineUnlock;

	public void OnAwakeLR()
	{
		colliders = GetComponentsInChildren<BoxCollider>();
		Haglet.Create(out routineUnlock, RoutineUnlock);
	}

	public void OnRealtimeLateUpdateLR()
	{
		Hand handL = CC.Inst.handL;
		Hand handR = CC.Inst.handR;
		BoxCollider boxCollider = colliders[0];
		BoxCollider boxCollider2 = colliders[1];
		Vector3 vector = colliders[0].transform.InverseTransformPoint(handL.transform.position);
		Vector3 vector2 = colliders[1].transform.InverseTransformPoint(handR.transform.position);
		bool num = Mathf.Abs(vector.x) < boxCollider.size.x && Mathf.Abs(vector.y) < boxCollider.size.y && Mathf.Abs(vector.z) < boxCollider.size.z;
		bool flag = Mathf.Abs(vector2.x) < boxCollider2.size.x && Mathf.Abs(vector2.y) < boxCollider2.size.y && Mathf.Abs(vector2.z) < boxCollider2.size.z;
		if (num && flag)
		{
			timer += 0.1f;
			if (timer > 10f && !routineUnlock.started)
			{
				routineUnlock.Start();
			}
		}
		else
		{
			timer = 0f;
		}
	}

	private IEnumerator<Routine.Yield> RoutineUnlock()
	{
		SceneInfo mainHubInfo = LR.Inst.GetSceneInfoWithSceneUIDName("suez");
		yield return Wait.For.Seconds(2f);
		LR.Inst.saveDataGame.tutorialComplete = true;
		LR.Inst.saveDataGame.chaptersComplete = (SaveDataGame.Chapter)(-1);
		LR.Inst.Save();
		LR.Inst.LoadPlayerIntoScene(mainHubInfo);
		while (!LR.Inst.GetMRBaseWithSceneInfo(mainHubInfo))
		{
			yield return Wait.For.Updates(1);
		}
		while (!LR.Inst.GetMRBaseWithSceneInfo(mainHubInfo).isAwake)
		{
			yield return Wait.For.Updates(1);
		}
		MRBase mRBaseWithSceneInfo = LR.Inst.GetMRBaseWithSceneInfo(mainHubInfo);
		for (int i = 0; i < mRBaseWithSceneInfo.hagiss.Length; i++)
		{
			HAGIS hAGIS = mRBaseWithSceneInfo.hagiss[i];
			for (int j = 0; j < 20; j++)
			{
				hAGIS.onLogic.Skip();
			}
		}
		LeverController componentInChildren = mRBaseWithSceneInfo.GetComponentInChildren<LeverController>();
		if ((bool)componentInChildren)
		{
			componentInChildren.DebugUnlockMansfieldPortals();
		}
		LR.Inst.Save();
	}
}
public class NudgeTrigger : MonoBehaviour
{
	public Vector3 forceToApply;

	private void OnTriggerEnter(Collider other)
	{
		Rigidbody component = other.GetComponent<Rigidbody>();
		if (component != null)
		{
			component.AddForce(forceToApply, ForceMode.Impulse);
		}
	}
}
public static class NXHagletX
{
	public static Wait LRUpdates(this Wait.IFor f, int total, bool allowPreMetNow = false, bool allowPreMetLater = false)
	{
		return Wait.Until.Happening(LR.Inst.onUpdate, total, allowPreMetNow, allowPreMetLater);
	}

	public static Wait LRLateUpdates(this Wait.IFor f, int total, bool allowPreMetNow = false, bool allowPreMetLater = false)
	{
		return Wait.Until.Happening(LR.Inst.onLateUpdate, total, allowPreMetNow, allowPreMetLater);
	}

	public static Wait LRPrePhysicsUpdates(this Wait.IFor f, int total, bool allowPreMetNow = false, bool allowPreMetLater = false)
	{
		return Wait.Until.Happening(LR.Inst.onPrePhysicsUpdate, total, allowPreMetNow, allowPreMetLater);
	}

	public static Wait LRPostPhysicsUpdates(this Wait.IFor f, int total, bool allowPreMetNow = false, bool allowPreMetLater = false)
	{
		return Wait.Until.Happening(LR.Inst.onPostPhysicsUpdate, total, allowPreMetNow, allowPreMetLater);
	}

	public static Wait LRPauseUpdates(this Wait.IFor f, int total, bool allowPreMetNow = false, bool allowPreMetLater = false)
	{
		return Wait.Until.Happening(LR.Inst.onPauseUpdate, total, allowPreMetNow, allowPreMetLater);
	}

	public static Wait LRRealtimeUpdates(this Wait.IFor f, int total, bool allowPreMetNow = false, bool allowPreMetLater = false)
	{
		return Wait.Until.Happening(LR.Inst.onRealTimeUpdate, total, allowPreMetNow, allowPreMetLater);
	}

	public static Wait LRRealtimeLateUpdates(this Wait.IFor f, int total, bool allowPreMetNow = false, bool allowPreMetLater = false)
	{
		return Wait.Until.Happening(LR.Inst.onRealTimeLateUpdate, total, allowPreMetNow, allowPreMetLater);
	}
}
public class NXProf : MonoBehaviour
{
	public enum Type
	{
		Update,
		UpdateToLateUpdate,
		LateUpdate,
		LateUpdateToRender,
		RendererAll,
		RendererCull,
		RendererToNextFrame,
		MAX
	}

	public struct Timing
	{
		public float avg;

		public Stopwatch sw;
	}

	private static Timing[] timings;

	static NXProf()
	{
		timings = new Timing[7];
		for (int i = 0; i < timings.Length; i++)
		{
			timings[i].sw = new Stopwatch();
		}
	}

	[Conditional("NX_TESTING")]
	public static void Begin(Type type)
	{
		timings[(int)type].avg = Mathf.Lerp(timings[(int)type].avg, (float)timings[(int)type].sw.Elapsed.TotalSeconds, 0.05f);
		timings[(int)type].sw.Reset();
		timings[(int)type].sw.Start();
	}

	[Conditional("NX_TESTING")]
	public static void End(Type type)
	{
		timings[(int)type].sw.Stop();
	}

	public static string GetTimings()
	{
		string text = "";
		for (int i = 0; i < timings.Length; i++)
		{
			string[] obj = new string[5] { text, null, null, null, null };
			Type type = (Type)i;
			obj[1] = type.ToString();
			obj[2] = " : ";
			obj[3] = (timings[i].avg * 1000f).ToString("0.00");
			obj[4] = "ms\n";
			text = string.Concat(obj);
		}
		return text;
	}
}
public class NXProfUI : UIElement
{
	private UITextbox tb;

	private UIDebug debug;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		tb = GetComponent<UITextbox>();
		debug = base.gameObject.GetComponentInAscendant<UIDebug>();
	}

	private void Update()
	{
		if ((bool)tb)
		{
			tb.GetComponent<Renderer>().material.SetInt("_ZTEST", 8);
			debug.root.transform.position = MainCamera.Inst.transform.position + MainCamera.Inst.transform.forward * 0.5f;
			debug.root.transform.rotation = MainCamera.Inst.transform.rotation;
			tb.SetText(NXProf.GetTimings());
			tb.Present();
		}
	}
}
public class ObjectCapsuleConstrainer : MonoBehaviour, IAwakeEvent, IAreaEvent, IUpdateEvent
{
	public float radius = 0.02f;

	public float height = 0.3f;

	public IDObjectRef[] constrainedObjectRefs;

	private Vector3 v0;

	private Vector3 v1;

	private MRBase owner;

	private ConstArray<GrabObject> constrainedGrabObjs;

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		this.owner = owner;
		v0 = base.transform.TransformPoint(-Vector3.forward * (height / 2f));
		v1 = base.transform.TransformPoint(Vector3.forward * (height / 2f));
		constrainedGrabObjs = new ConstArray<GrabObject>((uint)constrainedObjectRefs.Length);
	}

	void IUpdateEvent.OnUpdateLR()
	{
		if (owner != MainCamera.Inst.GetOwner())
		{
			return;
		}
		for (int i = 0; i < constrainedGrabObjs.Length; i++)
		{
			GrabObject grabObject = constrainedGrabObjs[i];
			if (!(grabObject.owner != owner))
			{
				PortalingRigidbody pr = grabObject.pr;
				Transform transform = grabObject.transform;
				Vector3 position = transform.position;
				Vector3 vector = MathfX.ClosestPointLineSegment(position, v0, v1);
				Vector3 vector2 = position - vector;
				if (vector2.magnitude > radius)
				{
					transform.position = vector + vector2.normalized * radius;
				}
				pr.SetVelocityLinear(Vector3.ClampMagnitude(pr.GetVelocityLinear(), 1f));
				pr.SetVelocityAngular(Vector3.ClampMagnitude(pr.GetVelocityAngular(), 0.1f));
			}
		}
	}

	private void OnDrawGizmos()
	{
	}

	void IAreaEvent.OnAreaEnter()
	{
		constrainedGrabObjs.Clear();
		IDObjectRef[] array = constrainedObjectRefs;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].TryGetComponent<GrabObject>(out var value) && value.owner == owner)
			{
				Vector3 position = value.transform.position;
				Vector3 vector = MathfX.ClosestPointLineSegment(position, v0, v1);
				if ((position - vector).magnitude <= radius)
				{
					constrainedGrabObjs.Add(value);
				}
			}
		}
	}

	void IAreaEvent.OnAreaExit()
	{
	}
}
public static class ObjectCloner
{
	public struct TypeInfo
	{
		public PropertyInfo[] propertyInfo;

		public FieldInfo[] fieldInfo;
	}

	private static Dictionary<Type, TypeInfo> CachedPropertyInfo = new Dictionary<Type, TypeInfo>();

	public static GameObject CloneObject(GameObject _originalObject, Type[] _allowedTypes, Transform _parent, GameObject[] _ignoreObjects = null, bool copyActiveStates = false)
	{
		if (_originalObject.GetComponent<IDoNotClone>() != null)
		{
			return null;
		}
		if (_ignoreObjects != null)
		{
			for (int i = 0; i < _ignoreObjects.Length; i++)
			{
				if (_ignoreObjects[i] == _originalObject)
				{
					return null;
				}
			}
		}
		GameObject gameObject = new GameObject(_originalObject.name + "_clone");
		gameObject.transform.parent = _parent;
		gameObject.transform.position = _originalObject.transform.position;
		gameObject.transform.rotation = _originalObject.transform.rotation;
		gameObject.transform.localScale = _originalObject.transform.localScale;
		for (int j = 0; j < _allowedTypes.Length; j++)
		{
			UnityEngine.Component component = _originalObject.GetComponent(_allowedTypes[j]);
			if (component != null)
			{
				CopyComponent(component, gameObject);
			}
		}
		for (int k = 0; k < _originalObject.transform.childCount; k++)
		{
			CloneObject(_originalObject.transform.GetChild(k).gameObject, _allowedTypes, gameObject.transform, _ignoreObjects, copyActiveStates);
		}
		if (copyActiveStates)
		{
			gameObject.SetActive(_originalObject.activeSelf);
		}
		return gameObject;
	}

	public static UnityEngine.Component CopyComponent(UnityEngine.Component original, GameObject destination)
	{
		Type type = original.GetType();
		UnityEngine.Component component = destination.AddComponent(type);
		TypeInfo value;
		if (CachedPropertyInfo.ContainsKey(type))
		{
			value = CachedPropertyInfo[type];
		}
		else
		{
			value = default(TypeInfo);
			BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;
			value.propertyInfo = type.GetProperties(bindingAttr);
			value.fieldInfo = type.GetFields(bindingAttr);
			CachedPropertyInfo.Add(type, value);
		}
		PropertyInfo[] propertyInfo = value.propertyInfo;
		foreach (PropertyInfo propertyInfo2 in propertyInfo)
		{
			if (!propertyInfo2.CanWrite)
			{
				continue;
			}
			if (type.IsTypeOrSubType(typeof(Renderer)))
			{
				if (propertyInfo2.Name == "material" || propertyInfo2.Name == "materials")
				{
					continue;
				}
			}
			else if (type.IsTypeOrSubType(typeof(MeshFilter)) && propertyInfo2.Name == "mesh")
			{
				continue;
			}
			propertyInfo2.SetValue(component, propertyInfo2.GetValue(original, null), null);
		}
		FieldInfo[] fieldInfo = value.fieldInfo;
		foreach (FieldInfo fieldInfo2 in fieldInfo)
		{
			fieldInfo2.SetValue(component, fieldInfo2.GetValue(original));
		}
		return component;
	}
}
public interface IMimicBase
{
	void OnMimicEnteredPortal(Portal portal);

	void OnMimicSwappedControl(bool inControl);

	void OnMimicUpdate();

	bool CanHaveControl();
}
public interface IMimic<T> : IMimicBase
{
	IMimic<T> LinkedIMimic { get; set; }

	T LinkedMimicComp { get; set; }
}
[Serializer.ExcludeAllFields]
public class ObjectMimic : MonoBehaviour, IOwnerChangeListener, IAreaEvent
{
	[ReadOnly]
	public MRBase owner;

	[HideInInspector]
	public Transform overrideTransform;

	private bool m_hasControl;

	public bool m_shouldFlipZ;

	private ObjectMimic targetMimic;

	[Serializer.IncludeField]
	public IDObjectRef m_mimicObjectRef;

	private IMimicBase[] mimics;

	[NonSerialized]
	[HideInInspector]
	public PortalingRigidbody PortalingRidgidbody;

	[NonSerialized]
	[HideInInspector]
	public GrabObject GrabObject;

	public bool HasControl => m_hasControl;

	public PortalingRigidbody PortalingRidgidbodyMimic => targetMimic.PortalingRidgidbody;

	public GrabObject GrabObjectMimic => targetMimic.GrabObject;

	public ObjectMimic GetTargetMimic()
	{
		IDObject orNull = m_mimicObjectRef.GetOrNull<IDObject>(base.gameObject);
		if (!targetMimic && (bool)orNull)
		{
			targetMimic = orNull.GetComponent<ObjectMimic>();
		}
		return targetMimic;
	}

	public void OnOwnerChange(MRBase _oldOwner, MRBase _newOwner)
	{
		owner = _newOwner;
		MRBase.TransferObject(_oldOwner, _newOwner, this);
		if ((bool)targetMimic && (bool)_newOwner && (bool)targetMimic.PortalingRidgidbody)
		{
			MRBase mRBase = ((_newOwner.mimicSceneInfo == null) ? null : LR.Inst.GetMRBaseWithSceneInfo(_newOwner.mimicSceneInfo));
			targetMimic.PortalingRidgidbody.SetOwner(mRBase);
		}
	}

	public void OnAwakeLR(MRBase owner)
	{
		this.owner = owner;
		PortalingRidgidbody = GetComponent<PortalingRigidbody>();
		GrabObject = GetComponent<GrabObject>();
		mimics = GetComponents<IMimicBase>();
		UpdateMimic();
		ObjectMimic objectMimic = GetTargetMimic();
		if ((bool)objectMimic && (bool)objectMimic.owner)
		{
			objectMimic.GetTargetMimic();
			SetupIMimics<PortalingRigidbody>();
			SetupIMimics<PortalVariations>();
			SetupIMimics<GrabObject>();
			SetupIMimics<FixedRotatableObject>();
			objectMimic.UpdateMimic();
		}
	}

	public void SetupIMimics<T>()
	{
		IMimic<T> component = GetComponent<IMimic<T>>();
		T component2 = GetComponent<T>();
		IMimic<T> component3 = targetMimic.GetComponent<IMimic<T>>();
		T component4 = targetMimic.GetComponent<T>();
		if (component != null)
		{
			component.LinkedIMimic = component3;
			component.LinkedMimicComp = component4;
		}
		if (component3 != null)
		{
			component3.LinkedIMimic = component;
			component3.LinkedMimicComp = component2;
		}
	}

	public void SetUpIMimics<T>(IMimic<T> A, IMimic<T> B)
	{
		if (A != null && B != null)
		{
			A.LinkedIMimic = B;
			B.LinkedIMimic = A;
			A.LinkedMimicComp = (T)B;
			B.LinkedMimicComp = (T)A;
		}
	}

	public void SwapControl()
	{
		UpdateMimic();
		SetControl(!m_hasControl);
		targetMimic.SetControl(!m_hasControl);
	}

	public void SetControl(bool control)
	{
		m_hasControl = control;
		for (int i = 0; i < mimics.Length; i++)
		{
			mimics[i].OnMimicSwappedControl(control);
		}
		if (control && (bool)GrabObject?.hookPoint)
		{
			ConstArray<HookPoint> hookPoints = GrabObject.owner.hookPoints;
			GrabObject.hookPoint.UpdateFocusedHooks(hookPoints, 0, hookPoints.sLength);
			GrabObject.hookPoint.TryToHookOntoSomething();
		}
	}

	public void UpdateMimic()
	{
		if (!targetMimic || !targetMimic.owner)
		{
			return;
		}
		if (!m_hasControl)
		{
			if (!targetMimic.m_hasControl)
			{
				targetMimic.m_hasControl = true;
			}
			for (int i = 0; i < mimics.Length; i++)
			{
				mimics[i].OnMimicUpdate();
			}
			return;
		}
		if (targetMimic.m_hasControl)
		{
			targetMimic.m_hasControl = false;
		}
		Transform transform = targetMimic.transform;
		transform.position = GetTargetMimicPosition();
		transform.rotation = GetTargetMimicRotation();
		if (m_shouldFlipZ)
		{
			transform.localRotation *= Quaternion.AngleAxis(180f, Vector3.up);
		}
		targetMimic.UpdateMimic();
	}

	public Vector3 GetTargetMimicPosition()
	{
		Transform transform = ((!overrideTransform) ? owner.transform : overrideTransform);
		Transform obj = ((!targetMimic.overrideTransform) ? targetMimic.owner.transform : targetMimic.overrideTransform);
		Vector3 position = transform.InverseTransformPoint(base.transform.position);
		return obj.TransformPoint(position);
	}

	public Quaternion GetTargetMimicRotation()
	{
		Transform transform = ((!overrideTransform) ? owner.transform : overrideTransform);
		Transform obj = ((!targetMimic.overrideTransform) ? targetMimic.owner.transform : targetMimic.overrideTransform);
		return QuaternionX.TransformRotation(localRotation: transform.rotation.InverseTransformRotation(base.transform.rotation), rotation: obj.rotation);
	}

	private bool CanHaveControl()
	{
		bool flag = true;
		for (int i = 0; i < mimics.Length; i++)
		{
			flag &= mimics[i].CanHaveControl();
		}
		return flag;
	}

	public void CheckControl()
	{
		if (((bool)targetMimic && !targetMimic.CanHaveControl()) || !targetMimic || !m_hasControl || (!(GrabObject == null) && CC.Inst.IsObjectGrabbedOrFocusGrabbed(GrabObject)))
		{
			return;
		}
		MRBase mRBase = MainCamera.Inst.GetOwner();
		if (!mRBase)
		{
			return;
		}
		if (GrabObject == null || !GrabObject.HACK_eyeglassPortal)
		{
			Vector3 endPoint = base.transform.position;
			bool flag = mRBase == targetMimic.owner;
			if (flag)
			{
				Vector3 position = owner.transform.InverseTransformPoint(base.transform.position);
				endPoint = mRBase.transform.TransformPoint(position);
			}
			Portal portalOut = null;
			Portal.RaycastPortal(IC.GetHeadPosition(), endPoint, out portalOut);
			if (!flag && (bool)portalOut)
			{
				SwapControl();
			}
			else if (flag && !portalOut)
			{
				SwapControl();
			}
		}
		else if (mRBase == targetMimic.owner)
		{
			SwapControl();
		}
	}

	void IAreaEvent.OnAreaEnter()
	{
	}

	void IAreaEvent.OnAreaExit()
	{
	}

	public void OnAreaEnter()
	{
	}

	public void OnAreaExit()
	{
	}
}
public class OrbitingAudio : MonoBehaviour, IAwakeEvent
{
	public FMODEventAsset asset;

	[Tooltip("Radius in meters relative to this game object")]
	public float radius = 2f;

	[Tooltip("Speed in degrees per second")]
	public float speed = 1f;

	private Transform sourceTransform;

	private FMOD.Studio.EventInstance eventInstance;

	private IHaglet orbitRoutine;

	public void OnAwakeLR(MRBase owner)
	{
		Haglet.Create(out orbitRoutine, OrbitRoutine, null, startNow: true);
	}

	private IEnumerator<Routine.Yield> OrbitRoutine()
	{
		Vector3 forward = base.transform.forward;
		sourceTransform = base.transform.Find("Source");
		sourceTransform.localPosition = forward * radius;
		eventInstance = FAC.Inst.PlayOneShot(asset, sourceTransform);
		while (true)
		{
			sourceTransform.RotateAround(base.transform.position, base.transform.up, speed * IC.DeltaTime);
			yield return Wait.For.LRUpdates(1);
		}
	}

	private void OnDestroy()
	{
		if (eventInstance.isValid())
		{
			eventInstance.stop(STOP_MODE.ALLOWFADEOUT);
		}
		orbitRoutine?.Stop();
	}

	private void OnDrawGizmos()
	{
		_ = sourceTransform != null;
	}
}
public class OVROverlayNexus : MonoBehaviour
{
	public enum OverlayShape
	{
		Quad = 0,
		Cylinder = 1,
		Cubemap = 2,
		OffcenterCubemap = 4,
		Equirect = 5
	}

	public enum OverlayType
	{
		None,
		Underlay,
		Overlay
	}

	private struct LayerTexture
	{
		public Texture appTexture;

		public IntPtr appTexturePtr;

		public Texture[] swapChain;

		public IntPtr[] swapChainPtr;
	}

	private static OVROverlayNexus _instance;

	[Tooltip("Specify overlay's shape")]
	public OverlayShape currentOverlayShape = OverlayShape.Cubemap;

	private OverlayShape prevOverlayShape = OverlayShape.Cubemap;

	[NonSerialized]
	[Tooltip("The left- and right-eye Textures to show in the layer.")]
	[HideInInspector]
	public Texture[] textures = new Texture[2];

	protected IntPtr[] texturePtrs = new IntPtr[2]
	{
		IntPtr.Zero,
		IntPtr.Zero
	};

	protected bool isOverridePending;

	internal const int maxInstances = 15;

	internal static OVROverlayNexus[] instances = new OVROverlayNexus[15];

	private static Material tex2DMaterial;

	private static Material cubeMaterial;

	public Cubemap cubemapBlack;

	public Cubemap cubemapOffWhite;

	private LayerTexture[] layerTextures;

	private OVRPlugin.LayerDesc layerDesc;

	private int stageCount = -1;

	private int layerIndex = -1;

	private int layerId;

	private GCHandle layerIdHandle;

	private IntPtr layerIdPtr = IntPtr.Zero;

	private int frameIndex;

	private int prevFrameIndex = -1;

	private int framesDirtyCounter = 3;

	private Renderer rend;

	public static OVROverlayNexus Inst => _instance;

	private OVRPlugin.LayerLayout layout
	{
		get
		{
			if (textures.Length == 2 && textures[1] != null)
			{
				return OVRPlugin.LayerLayout.Stereo;
			}
			return OVRPlugin.LayerLayout.Mono;
		}
	}

	private int texturesPerStage
	{
		get
		{
			if (layout != 0)
			{
				return 1;
			}
			return 2;
		}
	}

	public void OverrideOverlayTextureInfo(Texture srcTexture, IntPtr nativePtr, XRNode node)
	{
		int num = ((node == XRNode.RightEye) ? 1 : 0);
		if (textures.Length > num)
		{
			textures[num] = srcTexture;
			texturePtrs[num] = nativePtr;
			isOverridePending = true;
		}
	}

	public void SetupColor(bool black)
	{
		textures[0] = (textures[1] = (black ? cubemapBlack : cubemapOffWhite));
		framesDirtyCounter = 3;
	}

	private bool CreateLayer(int mipLevels, int sampleCount, OVRPlugin.EyeTextureFormat etFormat, int flags, OVRPlugin.Sizei size, OVRPlugin.OverlayShape shape)
	{
		if (!layerIdHandle.IsAllocated || layerIdPtr == IntPtr.Zero)
		{
			layerIdHandle = GCHandle.Alloc(layerId, GCHandleType.Pinned);
			layerIdPtr = layerIdHandle.AddrOfPinnedObject();
		}
		if (layerIndex == -1)
		{
			for (int i = 0; i < 15; i++)
			{
				if (instances[i] == null || instances[i] == this)
				{
					layerIndex = i;
					instances[i] = this;
					break;
				}
			}
		}
		if (!isOverridePending && layerDesc.MipLevels == mipLevels && layerDesc.SampleCount == sampleCount && layerDesc.Format == etFormat && layerDesc.Layout == layout && layerDesc.LayerFlags == flags && layerDesc.TextureSize.Equals(size) && layerDesc.Shape == shape)
		{
			return false;
		}
		OVRPlugin.LayerDesc desc = OVRPlugin.CalculateLayerDesc(shape, layout, size, mipLevels, sampleCount, etFormat, flags);
		OVRPlugin.EnqueueSetupLayer(desc, 0, layerIdPtr);
		layerId = (int)layerIdHandle.Target;
		if (layerId > 0)
		{
			layerDesc = desc;
			stageCount = OVRPlugin.GetLayerTextureStageCount(layerId);
		}
		isOverridePending = false;
		return true;
	}

	private bool CreateLayerTextures(bool useMipmaps, OVRPlugin.Sizei size, bool isHdr)
	{
		bool result = false;
		if (stageCount <= 0)
		{
			return false;
		}
		if (layerTextures == null)
		{
			layerTextures = new LayerTexture[texturesPerStage];
		}
		for (int i = 0; i < texturesPerStage; i++)
		{
			if (layerTextures[i].swapChain == null)
			{
				layerTextures[i].swapChain = new Texture[stageCount];
			}
			if (layerTextures[i].swapChainPtr == null)
			{
				layerTextures[i].swapChainPtr = new IntPtr[stageCount];
			}
			for (int j = 0; j < stageCount; j++)
			{
				Texture texture = layerTextures[i].swapChain[j];
				IntPtr intPtr = layerTextures[i].swapChainPtr[j];
				if (!(texture != null) || !(intPtr != IntPtr.Zero))
				{
					if (intPtr == IntPtr.Zero)
					{
						intPtr = OVRPlugin.GetLayerTexture(layerId, j, (OVRPlugin.Eye)i);
					}
					if (!(intPtr == IntPtr.Zero))
					{
						TextureFormat format = (isHdr ? TextureFormat.RGBAHalf : TextureFormat.RGBA32);
						texture = ((currentOverlayShape == OverlayShape.Cubemap || currentOverlayShape == OverlayShape.OffcenterCubemap) ? ((Texture)Cubemap.CreateExternalTexture(size.w, format, useMipmaps, intPtr)) : ((Texture)Texture2D.CreateExternalTexture(size.w, size.h, format, useMipmaps, linear: true, intPtr)));
						layerTextures[i].swapChain[j] = texture;
						layerTextures[i].swapChainPtr[j] = intPtr;
						result = true;
					}
				}
			}
		}
		return result;
	}

	private void DestroyLayerTextures()
	{
		int num = 0;
		while (layerTextures != null && num < texturesPerStage)
		{
			if (layerTextures[num].swapChain != null)
			{
				for (int i = 0; i < stageCount; i++)
				{
					UnityEngine.Object.DestroyImmediate(layerTextures[num].swapChain[i]);
				}
			}
			num++;
		}
		layerTextures = null;
	}

	private void DestroyLayer()
	{
		if (layerIndex != -1)
		{
			OVRPlugin.EnqueueSubmitLayer(onTop: true, headLocked: false, IntPtr.Zero, IntPtr.Zero, -1, 0, OVRPose.identity.ToPosef(), Vector3.one.ToVector3f(), layerIndex, (OVRPlugin.OverlayShape)prevOverlayShape);
			instances[layerIndex] = null;
			layerIndex = -1;
		}
		if (layerIdPtr != IntPtr.Zero)
		{
			OVRPlugin.EnqueueDestroyLayer(layerIdPtr);
			layerIdPtr = IntPtr.Zero;
			layerIdHandle.Free();
			layerId = 0;
		}
		layerDesc = default(OVRPlugin.LayerDesc);
		frameIndex = 0;
		prevFrameIndex = -1;
	}

	private bool LatchLayerTextures()
	{
		for (int i = 0; i < texturesPerStage; i++)
		{
			if ((textures[i] != layerTextures[i].appTexture || layerTextures[i].appTexturePtr == IntPtr.Zero) && textures[i] != null)
			{
				RenderTexture renderTexture = textures[i] as RenderTexture;
				if ((bool)renderTexture && !renderTexture.IsCreated())
				{
					renderTexture.Create();
				}
				layerTextures[i].appTexturePtr = ((texturePtrs[i] != IntPtr.Zero) ? texturePtrs[i] : textures[i].GetNativeTexturePtr());
				if (layerTextures[i].appTexturePtr != IntPtr.Zero)
				{
					layerTextures[i].appTexture = textures[i];
				}
			}
			if (currentOverlayShape == OverlayShape.Cubemap && textures[i] as Cubemap == null)
			{
				UnityEngine.Debug.LogError("Need Cubemap texture for cube map overlay");
				return false;
			}
		}
		if (layerTextures[0].appTexture == null || layerTextures[0].appTexturePtr == IntPtr.Zero)
		{
			return false;
		}
		return true;
	}

	private OVRPlugin.LayerDesc GetCurrentLayerDesc()
	{
		OVRPlugin.LayerDesc layerDesc = default(OVRPlugin.LayerDesc);
		layerDesc.Format = OVRPlugin.EyeTextureFormat.Default;
		layerDesc.LayerFlags = 8;
		layerDesc.Layout = layout;
		layerDesc.MipLevels = 1;
		layerDesc.SampleCount = 1;
		layerDesc.Shape = (OVRPlugin.OverlayShape)currentOverlayShape;
		layerDesc.TextureSize = new OVRPlugin.Sizei
		{
			w = textures[0].width,
			h = textures[0].height
		};
		OVRPlugin.LayerDesc result = layerDesc;
		Texture2D texture2D = textures[0] as Texture2D;
		if (texture2D != null)
		{
			if (texture2D.format == TextureFormat.RGBAHalf || texture2D.format == TextureFormat.RGBAFloat)
			{
				result.Format = OVRPlugin.EyeTextureFormat.R16G16B16A16_FP;
			}
			result.MipLevels = texture2D.mipmapCount;
		}
		Cubemap cubemap = textures[0] as Cubemap;
		if (cubemap != null)
		{
			if (cubemap.format == TextureFormat.RGBAHalf || cubemap.format == TextureFormat.RGBAFloat)
			{
				result.Format = OVRPlugin.EyeTextureFormat.R16G16B16A16_FP;
			}
			result.MipLevels = cubemap.mipmapCount;
		}
		RenderTexture renderTexture = textures[0] as RenderTexture;
		if (renderTexture != null)
		{
			result.SampleCount = renderTexture.antiAliasing;
			if (renderTexture.format == RenderTextureFormat.ARGBHalf || renderTexture.format == RenderTextureFormat.ARGBFloat || renderTexture.format == RenderTextureFormat.RGB111110Float)
			{
				result.Format = OVRPlugin.EyeTextureFormat.R16G16B16A16_FP;
			}
		}
		return result;
	}

	private bool PopulateLayer(int mipLevels, bool isHdr, OVRPlugin.Sizei size, int sampleCount, int stage)
	{
		bool result = false;
		RenderTextureFormat colorFormat = (isHdr ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.ARGB32);
		for (int i = 0; i < texturesPerStage; i++)
		{
			Texture texture = layerTextures[i].swapChain[stage];
			if (texture == null)
			{
				continue;
			}
			for (int j = 0; j < mipLevels; j++)
			{
				int num = size.w >> j;
				if (num < 1)
				{
					num = 1;
				}
				int num2 = size.h >> j;
				if (num2 < 1)
				{
					num2 = 1;
				}
				RenderTextureDescriptor desc = new RenderTextureDescriptor(num, num2, colorFormat, 0);
				desc.msaaSamples = sampleCount;
				desc.useMipMap = true;
				desc.autoGenerateMips = false;
				desc.sRGB = false;
				RenderTexture temporary = RenderTexture.GetTemporary(desc);
				if (!temporary.IsCreated())
				{
					temporary.Create();
				}
				temporary.DiscardContents();
				bool flag = isHdr || QualitySettings.activeColorSpace == ColorSpace.Linear;
				flag = true;
				if (currentOverlayShape != OverlayShape.Cubemap && currentOverlayShape != OverlayShape.OffcenterCubemap)
				{
					tex2DMaterial.SetInt("_linearToSrgb", (!isHdr && flag) ? 1 : 0);
					Graphics.Blit(textures[i], temporary, tex2DMaterial);
					Graphics.CopyTexture(temporary, 0, 0, texture, 0, j);
				}
				else
				{
					for (int k = 0; k < 6; k++)
					{
						cubeMaterial.SetInt("_linearToSrgb", (!isHdr && flag) ? 1 : 0);
						cubeMaterial.SetInt("_face", k);
						Graphics.Blit(textures[i], temporary, cubeMaterial);
						Graphics.CopyTexture(temporary, 0, 0, texture, k, j);
					}
				}
				RenderTexture.ReleaseTemporary(temporary);
				result = true;
			}
		}
		return result;
	}

	private bool SubmitLayer(bool overlay, bool headLocked, OVRPose pose, Vector3 scale, int frameIndex)
	{
		int num = ((texturesPerStage >= 2) ? 1 : 0);
		bool result = OVRPlugin.EnqueueSubmitLayer(overlay, headLocked, layerTextures[0].appTexturePtr, layerTextures[num].appTexturePtr, layerId, frameIndex, pose.flipZ().ToPosef(), scale.ToVector3f(), layerIndex, (OVRPlugin.OverlayShape)currentOverlayShape);
		prevOverlayShape = currentOverlayShape;
		return result;
	}

	private void Awake()
	{
		_instance = this;
		base.gameObject.transform.parent = null;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		if (tex2DMaterial == null)
		{
			tex2DMaterial = new Material(Shader.Find("Oculus/Texture2D Blit"));
		}
		if (cubeMaterial == null)
		{
			cubeMaterial = new Material(Shader.Find("Oculus/Cubemap Blit"));
		}
		rend = GetComponent<Renderer>();
		if (textures.Length == 0)
		{
			textures = new Texture[1];
		}
		if (rend != null && textures[0] == null)
		{
			textures[0] = rend.material.mainTexture;
		}
	}

	private void OnEnable()
	{
		if (!OVRManager.isHmdPresent)
		{
			base.enabled = false;
		}
	}

	private void OnDisable()
	{
		if ((base.gameObject.hideFlags & HideFlags.DontSaveInBuild) == 0)
		{
			DestroyLayerTextures();
			DestroyLayer();
		}
	}

	private void OnDestroy()
	{
		DestroyLayerTextures();
		DestroyLayer();
	}

	private bool ComputeSubmit(ref OVRPose pose, ref Vector3 scale, ref bool overlay, ref bool headLocked)
	{
		Camera camera = ((MainCamera.Inst != null) ? MainCamera.Inst.cameraComp : ((LoadingCamera.Inst != null) ? LoadingCamera.Inst.Camera : ((SplashScreen.Inst != null) ? SplashScreen.Inst.Camera : null)));
		overlay = false;
		headLocked = false;
		Transform parent = base.transform;
		while (parent != null && !headLocked)
		{
			headLocked |= parent == camera.transform;
			parent = parent.parent;
		}
		pose = (headLocked ? base.transform.ToHeadSpacePose(camera) : base.transform.ToTrackingSpacePose(camera));
		scale = base.transform.lossyScale;
		for (int i = 0; i < 3; i++)
		{
			scale[i] /= camera.transform.lossyScale[i];
		}
		if (currentOverlayShape == OverlayShape.Cubemap)
		{
			pose.orientation *= Quaternion.AngleAxis(180f, Vector3.up);
			pose.position = camera.transform.position;
		}
		if (currentOverlayShape == OverlayShape.OffcenterCubemap)
		{
			pose.position = base.transform.position;
			if (pose.position.magnitude > 1f)
			{
				UnityEngine.Debug.LogWarning("Your cube map center offset's magnitude is greater than 1, which will cause some cube map pixel always invisible .");
				return false;
			}
		}
		if (currentOverlayShape == OverlayShape.Cylinder)
		{
			float num = scale.x / scale.z / (float)Math.PI * 180f;
			if (num > 180f)
			{
				UnityEngine.Debug.LogWarning("Cylinder overlay's arc angle has to be below 180 degree, current arc angle is " + num + " degree.");
				return false;
			}
		}
		return true;
	}

	private void LateUpdate()
	{
		if (!OVRPlugin.hasVrFocus || framesDirtyCounter <= 0)
		{
			return;
		}
		framesDirtyCounter--;
		if (textures.Length < texturesPerStage || textures[0] == null)
		{
			return;
		}
		OVRPose pose = OVRPose.identity;
		Vector3 scale = Vector3.one;
		bool overlay = false;
		bool headLocked = false;
		if (!ComputeSubmit(ref pose, ref scale, ref overlay, ref headLocked))
		{
			return;
		}
		OVRPlugin.LayerDesc currentLayerDesc = GetCurrentLayerDesc();
		bool isHdr = currentLayerDesc.Format == OVRPlugin.EyeTextureFormat.R16G16B16A16_FP;
		bool flag = CreateLayer(currentLayerDesc.MipLevels, currentLayerDesc.SampleCount, currentLayerDesc.Format, currentLayerDesc.LayerFlags, currentLayerDesc.TextureSize, currentLayerDesc.Shape);
		if (layerIndex == -1 || layerId <= 0)
		{
			return;
		}
		bool useMipmaps = currentLayerDesc.MipLevels > 1;
		flag |= CreateLayerTextures(useMipmaps, currentLayerDesc.TextureSize, isHdr);
		if (!LatchLayerTextures())
		{
			return;
		}
		if (frameIndex > prevFrameIndex)
		{
			int stage = frameIndex % stageCount;
			if (!PopulateLayer(currentLayerDesc.MipLevels, isHdr, currentLayerDesc.TextureSize, currentLayerDesc.SampleCount, stage))
			{
				return;
			}
		}
		bool flag2 = SubmitLayer(overlay, headLocked, pose, scale, frameIndex);
		prevFrameIndex = frameIndex;
		frameIndex++;
		if ((bool)rend)
		{
			rend.enabled = !flag2;
		}
	}
}
public class ParticleAttractor : MonoBehaviour
{
	private const int INITIAL_COUNT = 40;

	private MRBase owner;

	public ParticleSystem particles;

	private ParticleSystem.Particle[] particleArray = new ParticleSystem.Particle[40];

	private Transform followPoint;

	public float speed = 0.5f;

	public ParticleAttractor childParticle;

	public void Initialise(MRBase newOwner, Transform newFollowPoint)
	{
		owner = newOwner;
		followPoint = newFollowPoint;
		if (childParticle != null)
		{
			childParticle.Initialise(newOwner, newFollowPoint);
		}
	}

	public void Stop()
	{
		particles.Stop(withChildren: false, ParticleSystemStopBehavior.StopEmitting);
		if (childParticle != null)
		{
			childParticle.Stop();
		}
	}

	public void OnUpdateLR(float timeDelta)
	{
		if (particleArray.Length < particles.particleCount)
		{
			ReinitialiseParticleArray();
		}
		float t = speed * timeDelta;
		int num = particles.GetParticles(particleArray);
		for (int i = 0; i < num; i++)
		{
			particleArray[i].position = Vector3.Lerp(particleArray[i].position, followPoint.position, t);
		}
		particles.SetParticles(particleArray, num);
	}

	private void ReinitialiseParticleArray()
	{
		particleArray = new ParticleSystem.Particle[particleArray.Length * 2];
	}
}
[RequireComponent(typeof(ParticleSystem))]
public class ParticleBurstSFX : MonoBehaviour
{
	[Tooltip("Time between bursts")]
	public float DurationMin = 1f;

	[Tooltip("Time between bursts")]
	public float DurationMax = 3f;

	[Tooltip("Amount of emissions in one burst")]
	public int EmitAmountMin = 1;

	[Tooltip("Amount of emissions in one burst")]
	public int EmitAmountMax = 1;

	[Tooltip("Delay between emissions in one burst")]
	public float EmitDelayMin;

	[Tooltip("Delay between emissions in one burst")]
	public float EmitDelayMax;

	public Transform SoundLocation;

	public FMODEventAsset SFX;

	private ParticleSystem Particles;

	private float Time;

	private float CurrentDuration;

	private float CurrentEmitDelay;

	private int CurrentEmitAmount;

	private int CurrentEmitCount;

	public void Awake()
	{
		if (SoundLocation == null)
		{
			SoundLocation = base.transform;
		}
		Particles = GetComponent<ParticleSystem>();
		CurrentEmitAmount = UnityEngine.Random.Range(EmitAmountMin, EmitAmountMax + 1);
	}

	public void Update()
	{
		Time += IC.DeltaTime;
		if (Time >= CurrentDuration + CurrentEmitDelay)
		{
			Particles.Emit(1);
			FAC.Inst.PlayOneShot(SFX, SoundLocation);
			CurrentEmitCount++;
			CurrentEmitDelay += UnityEngine.Random.Range(EmitDelayMin, EmitDelayMax);
			if (CurrentEmitCount == CurrentEmitAmount)
			{
				Time = 0f;
				CurrentEmitCount = 0;
				CurrentEmitAmount = UnityEngine.Random.Range(EmitAmountMin, EmitAmountMax + 1);
				CurrentEmitDelay = 0f;
				CurrentDuration = UnityEngine.Random.Range(DurationMin, DurationMax);
			}
		}
	}
}
public class ParticlePathHandler : MonoBehaviour
{
	public ParticlePath[] paths;

	private int pathIndex;

	public void ActivateNextPath()
	{
		paths[pathIndex].enabled = true;
		pathIndex++;
	}

	public void ResetHandler()
	{
		pathIndex = 0;
	}
}
public class ParticlePrefab : MonoBehaviour, IPoolEvents
{
	[ReadOnly]
	public ParticleType particleType;

	[HideInInspector]
	public ParticleSystem[] ps;

	public int intialNum = 5;

	public int maxNum = 10;

	[HideInInspector]
	public HagletTrigger OnSpawned = new HagletTrigger();

	[HideInInspector]
	public HagletTrigger OnDespawned = new HagletTrigger();

	[NonSerialized]
	[HideInInspector]
	public bool IsPaused;

	public float duration
	{
		get
		{
			float num = 0f;
			for (int i = 0; i < ps.Length; i++)
			{
				if (ps[i].main.duration > num)
				{
					num = ps[i].main.duration;
				}
			}
			return num;
		}
	}

	public bool isVisable
	{
		get
		{
			for (int i = 0; i < ps.Length; i++)
			{
				if (ps[i].particleCount > 0)
				{
					return true;
				}
			}
			return false;
		}
	}

	public bool loop
	{
		get
		{
			for (int i = 0; i < ps.Length; i++)
			{
				if (ps[i].main.loop)
				{
					return true;
				}
			}
			return false;
		}
	}

	public bool isPlaying
	{
		get
		{
			for (int i = 0; i < ps.Length; i++)
			{
				if (ps[i].isPlaying)
				{
					return true;
				}
			}
			return false;
		}
	}

	public static string GetTypeNameFromName(string name)
	{
		return name.Remove(0, 3).Replace(" ", "_");
	}

	public static string GetTypeNameFromPath(string path)
	{
		return GetTypeNameFromName(Path.GetFileNameWithoutExtension(path));
	}

	public static ParticleType GetTypeFromName(string name)
	{
		return (ParticleType)Enum.Parse(typeof(ParticleType), GetTypeNameFromName(name));
	}

	public static ParticleType GetTypeFromPath(string name)
	{
		return (ParticleType)Enum.Parse(typeof(ParticleType), GetTypeNameFromPath(name));
	}

	public void PlayParticles()
	{
		for (int i = 0; i < ps.Length; i++)
		{
			ps[i].Play();
		}
		IsPaused = false;
	}

	public void PauseParticles()
	{
		for (int i = 0; i < ps.Length; i++)
		{
			ps[i].Pause();
		}
		IsPaused = true;
	}

	public void StopParticles(ParticleSystemStopBehavior stopType = ParticleSystemStopBehavior.StopEmittingAndClear)
	{
		for (int i = 0; i < ps.Length; i++)
		{
			ps[i].Stop(withChildren: true, stopType);
		}
		if (stopType == ParticleSystemStopBehavior.StopEmittingAndClear)
		{
			base.gameObject.SetActive(value: false);
		}
	}

	public void ClearParticles()
	{
		for (int i = 0; i < ps.Length; i++)
		{
			ps[i].Clear();
		}
	}

	public virtual void OnSpawn()
	{
		OnSpawned.Trigger();
	}

	public virtual void OnDespawn()
	{
		OnDespawned.Trigger();
	}

	public virtual void OnAllocate()
	{
	}

	public virtual void OnDeallocate()
	{
	}
}
public enum ParticleType
{
	Object_Shatter = 17170649,
	ConfirmSwapParticle = 48464889,
	Occlusion_Explosion = 194509675,
	InventoryBurst = 400662816,
	Halo = 809190360,
	Obelisk_Sun = 832044810,
	Helper_Static = 957928629,
	Door_Dust_Indoor = 1225588129,
	Tutorial_Explosion_Large = 1414767204,
	Occlusion_LensEdge = 1452535569,
	Light_Sensor = 1659915395,
	Occlusion_Explosion_1 = 1740770413,
	Hook_Attraction = -2032706203,
	ObeliskStarBurst = -1789276973,
	FrustumParticles = -1455531125,
	Interactive_Idle = -1299701025,
	InventoryGrab = -1296810728,
	Portal_VO_ParticleBurst = -1220980645,
	Finlay_Feathers = -1153183768,
	Helper = -1124900370,
	StoryItemSparkle = -1091994698,
	Tutorial_Explosion = -860621852,
	ObeliskStarBurst_Small = -753489533,
	Door_Dust = -577307973,
	ObeliskStarBurst_Moon = -576971249,
	Inventory_Add = -570796602,
	MirrorObject = -478417586,
	LensFlare = -422941466,
	Obelisk_Moon = -417641235,
	Gravity_Indicator = -392040182,
	ODZ_Impact = -277451256,
	PageParticles = -249110624,
	LightningStrike = -1008207982
}
public class PlacementHelperEvent : MonoBehaviour
{
	public IDObjectRef PlacementHelper;

	[Event(EventName = "Enable Grabbing")]
	public void EnableGrabbing(object sender)
	{
		PlacementHelper.GetComponent<PlacementHelper>().objectCanBeGrabbed = true;
	}

	[Event(EventName = "Disable Grabbing")]
	public void DisableGrabbing(object sender)
	{
		PlacementHelper.GetComponent<PlacementHelper>().objectCanBeGrabbed = false;
	}
}
public class PoofTarget_STUB : MonoBehaviour
{
	private bool allowPoof;

	private void OnEnable()
	{
		if (allowPoof)
		{
			PSC.Inst.PlayAt(ParticleType.Tutorial_Explosion, base.transform.position);
		}
	}

	private void OnDisable()
	{
		if (allowPoof)
		{
			PSC.Inst.PlayAt(ParticleType.Tutorial_Explosion, base.transform.position);
		}
	}

	public void SetPoofAllowed(bool newStatus)
	{
		allowPoof = newStatus;
	}
}
public class PortalingRigidbody : MonoBehaviour, ICanPortal, IMimic<PortalingRigidbody>, IMimicBase
{
	private const float COLLISION_SOUND_THRESHOLD = 0.3f;

	private const float COLLISION_EVENT_COOLDOWN = 0.3f;

	[HideInInspector]
	public static readonly float gravityStrength = 9.81f;

	[ReadOnly]
	public MRBase owner;

	private Rigidbody objRB;

	[HideInInspector]
	public GrabObject grabObject;

	[ReadOnly]
	public ObjectMimic mimic;

	public Vector3 startGravityDirection = new Vector3(0f, -1f, 0f);

	private Vector3 objGravity = Vector3.zero;

	private bool _gravityEnabled = true;

	private TransformState lastState;

	private ICanEnterPortal[] enterPortalListeners;

	private IOwnerChangeListener[] ownerChangeListeners;

	private IAreaEvent[] areaEvents;

	private ISceneUnloadEvent[] sceneUnloadEvents;

	private Vector3 lastObjectLinearVelocity;

	private Vector3 lastObjectAngularVelocity;

	private CollisionSound[] collisionSounds;

	private MovementSound movementSound;

	private Vector3 lastMovementPos = Vector3.zero;

	private Vector3 lastPlayerPos = Vector3.zero;

	public HagletTrigger onEnterPortal = new HagletTrigger();

	private Collider[] globalColliders;

	private ConstArray<Collider> currentColliders;

	private Renderer[] allRenderers;

	private Renderer[] globalRenderers;

	private ConstArray<Renderer> currentMeshRenderers;

	private PortalVariations portalVariations;

	private RigidbodyConstraints originalConstraints;

	private Portal lastIntersectingPortal;

	[NonSerialized]
	public bool wentThroughPortalLastFrame;

	[NonSerialized]
	[HideInInspector]
	public float justSwappedMimicTimer;

	private float collisionTimer;

	public Vector3 ObjGravity => objGravity;

	public bool GravityEnabled
	{
		get
		{
			return _gravityEnabled;
		}
		set
		{
			_gravityEnabled = value;
		}
	}

	public bool HasControl
	{
		get
		{
			if ((bool)mimic)
			{
				return mimic.HasControl;
			}
			return true;
		}
	}

	IMimic<PortalingRigidbody> IMimic<PortalingRigidbody>.LinkedIMimic { get; set; }

	PortalingRigidbody IMimic<PortalingRigidbody>.LinkedMimicComp { get; set; }

	public void OnAwakeLR(MRBase _owner)
	{
		objRB = GetComponent<Rigidbody>();
		if (objRB == null)
		{
			base.enabled = false;
			return;
		}
		objRB.useGravity = false;
		objRB.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
		originalConstraints = objRB.constraints;
		grabObject = GetComponent<GrabObject>();
		portalVariations = GetComponent<PortalVariations>();
		if ((bool)portalVariations)
		{
			portalVariations.OnVariantSetChanged += OnVariantSetChanged;
		}
		SetGravityDirection(startGravityDirection);
		owner = _owner;
		lastState = new TransformState(base.transform);
		mimic = GetComponent<ObjectMimic>();
		enterPortalListeners = GetComponentsInChildren<ICanEnterPortal>(includeInactive: true);
		ownerChangeListeners = GetComponentsInChildren<IOwnerChangeListener>();
		areaEvents = GetComponentsInChildren<IAreaEvent>(includeInactive: true);
		sceneUnloadEvents = GetComponentsInChildren<ISceneUnloadEvent>(includeInactive: true);
		collisionSounds = GetComponentsInChildren<CollisionSound>(includeInactive: true);
		movementSound = GetComponentInChildren<MovementSound>(includeInactive: true);
		if ((bool)movementSound)
		{
			movementSound.StartSound();
		}
	}

	public void GatherRenderersAndColliders()
	{
		allRenderers = GetComponentsInChildren<Renderer>(includeInactive: true);
		InteractiveBeam componentInChildren = GetComponentInChildren<InteractiveBeam>(includeInactive: true);
		if ((bool)componentInChildren)
		{
			List<Renderer> list = new List<Renderer>(allRenderers);
			Renderer[] componentsInChildren = componentInChildren.GetComponentsInChildren<Renderer>(includeInactive: true);
			foreach (Renderer item in componentsInChildren)
			{
				list.Remove(item);
			}
			allRenderers = list.ToArray();
		}
		if ((bool)portalVariations)
		{
			List<Collider> list2 = new List<Collider>();
			list2.AddRange(GetComponentsInChildren<Collider>(includeInactive: true));
			currentColliders = new ConstArray<Collider>((uint)list2.Count);
			List<Renderer> list3 = new List<Renderer>();
			list3.AddRange(allRenderers);
			currentMeshRenderers = new ConstArray<Renderer>((uint)list3.Count);
			PortalVariations.Variant[] variants = portalVariations.variants;
			for (int i = 0; i < variants.Length; i++)
			{
				PortalVariations.Variant variant = variants[i];
				if (variant.root != null)
				{
					list2.Remove(variant.root.GetComponentsInChildren<Collider>(includeInactive: true));
					list3.Remove(variant.root.GetComponentsInChildren<Renderer>(includeInactive: true));
				}
			}
			globalColliders = list2.ToArray();
			globalRenderers = list3.ToArray();
		}
		else
		{
			globalColliders = GetComponentsInChildren<Collider>(includeInactive: true);
			currentColliders = new ConstArray<Collider>((uint)globalColliders.Length);
			globalRenderers = allRenderers;
			currentMeshRenderers = new ConstArray<Renderer>((uint)globalRenderers.Length);
		}
	}

	private void SetFrozen(bool frozen)
	{
		objRB.constraints = (frozen ? RigidbodyConstraints.FreezeAll : originalConstraints);
	}

	bool ICanPortal.CanEnterPortal(Portal portal)
	{
		if ((bool)grabObject && (bool)grabObject.hookPoint)
		{
			HookPoint hookPoint = grabObject.hookPoint;
			if (hookPoint.HasJoint && !hookPoint.IsJointOwner)
			{
				return false;
			}
		}
		return true;
	}

	public void OnEnterPortal(Portal portal)
	{
		if ((bool)grabObject && (bool)grabObject.hookPoint && grabObject.hookPoint.IsJointOwner)
		{
			grabObject.hookPoint.hookAttachedToDynamicHook.grabObjectOwner.pr.OnEnterPortal(portal);
		}
		if (grabObject == null || !CC.Inst.IsObjectGrabbedOrFocusGrabbed(grabObject))
		{
			Portal.PortalTransform portalTransform = portal.CalculatePortalObjectTransform(base.transform.position, base.transform.rotation, objRB.velocity);
			base.transform.position = portalTransform.position;
			base.transform.rotation = portalTransform.rotation;
			SetVelocityLinear(portalTransform.direction);
			SetVelocityAngular(portal.CalculatePortalObjectTransform(Vector3.zero, Quaternion.identity, objRB.angularVelocity).direction);
		}
		else if ((bool)grabObject)
		{
			Hand handObjectIsFocusGrabbed = CC.Inst.GetHandObjectIsFocusGrabbed(grabObject);
			if ((bool)handObjectIsFocusGrabbed && portal.Link == handObjectIsFocusGrabbed.portalFromHandToObject)
			{
				handObjectIsFocusGrabbed.portalFromHandToObject = null;
			}
			grabObject.GetLastValidCollisionState().UpdateToLatestState();
		}
		lastState.UpdateToLatestState();
		if (portal.Link != portal && portal.changesGravity)
		{
			SetGravityDirection(portal.GravityDirection);
		}
		if (mimic != null && mimic.HasControl)
		{
			((IMimic<PortalingRigidbody>)this).LinkedIMimic?.OnMimicEnteredPortal(portal);
		}
		for (int i = 0; i < enterPortalListeners.Length; i++)
		{
			enterPortalListeners[i].OnEnterPortal(portal);
		}
		wentThroughPortalLastFrame = true;
		onEnterPortal.Trigger();
	}

	private void SetRenderingMask(uint mask)
	{
		for (int i = 0; i < allRenderers.Length; i++)
		{
			allRenderers[i].renderingLayerMask = mask;
		}
	}

	public void OnUpdateLR()
	{
		if (HasControl && GravityEnabled)
		{
			objRB.AddForce(objGravity, ForceMode.Acceleration);
		}
		if (collisionTimer > 0f)
		{
			collisionTimer -= IC.DeltaTime;
		}
		if (justSwappedMimicTimer > 0f)
		{
			justSwappedMimicTimer -= IC.DeltaTime;
		}
	}

	public void OnPostPhysicsUpdateLR()
	{
		lastState.UpdateToLatestState();
		lastObjectLinearVelocity = objRB.velocity;
		if ((bool)mimic)
		{
			mimic.UpdateMimic();
		}
		if (!movementSound)
		{
			return;
		}
		if (GetKinematic() && grabObject.currentGrabbedHand != null)
		{
			Vector3 position = grabObject.currentGrabbedHand.transform.position;
			Vector3 position2 = CC.Inst.transform.position;
			if (lastMovementPos != Vector3.zero && !CC.Inst.freeMove.HasRotated)
			{
				Vector3 vector = position - lastMovementPos;
				Vector3 vector2 = position2 - lastPlayerPos;
				Vector3 velocity = (vector - vector2) / Time.deltaTime;
				movementSound.UpdateSound(velocity);
			}
			lastMovementPos = position;
			lastPlayerPos = position2;
		}
		else
		{
			if (lastMovementPos != Vector3.zero)
			{
				lastMovementPos = Vector3.zero;
			}
			movementSound.UpdateSound(lastObjectLinearVelocity);
		}
	}

	public void SetGravityDirection(Vector3 newDirectionWorld)
	{
		Vector3 vector = newDirectionWorld * gravityStrength;
		objGravity = vector;
	}

	public TransformState GetLastState()
	{
		return lastState;
	}

	public Vector3 GetWorldPosition()
	{
		return base.transform.position;
	}

	public MRBase GetOwner()
	{
		return owner;
	}

	public void SetOwner(MRBase newOwner)
	{
		if (owner != newOwner)
		{
			MRBase mRBase = owner;
			owner = newOwner;
			if ((object)owner == null)
			{
				SetRenderingMask(0u);
				SetFrozen(frozen: true);
				base.transform.parent = LR.Inst.transform;
			}
			else
			{
				SetRenderingMask(owner.sceneMask);
				SetFrozen(frozen: false);
				base.transform.parent = owner.transform;
			}
			MRBase.TransferObject(mRBase, newOwner, this);
			for (int i = 0; i < areaEvents.Length; i++)
			{
				MRBase.TransferObject(mRBase, newOwner, areaEvents[i]);
			}
			for (int j = 0; j < sceneUnloadEvents.Length; j++)
			{
				MRBase.TransferObject(mRBase, newOwner, sceneUnloadEvents[j]);
			}
			for (int k = 0; k < ownerChangeListeners.Length; k++)
			{
				ownerChangeListeners[k].OnOwnerChange(mRBase, newOwner);
			}
		}
	}

	public bool CanTeleport(Portal portal)
	{
		if (base.isActiveAndEnabled && portal.objectTeleportOnEnter && HasControl)
		{
			if (!(grabObject == null))
			{
				if (grabObject.HACK_eyeglassPortal == null)
				{
					return !CC.Inst.IsObjectGrabbed(grabObject);
				}
				return false;
			}
			return true;
		}
		return false;
	}

	public void SetPositionAndRotation(Vector3 worldPos, Quaternion worldRot)
	{
		base.transform.position = worldPos;
		base.transform.rotation = worldRot;
		if ((bool)mimic)
		{
			mimic.UpdateMimic();
		}
	}

	public void SetRidgidbodyPosition(Vector3 worldPos)
	{
		objRB.MovePosition(worldPos);
	}

	public void SetRidgidbodyPositionAndRotation(Vector3 worldPos, Quaternion worldRot)
	{
		objRB.MovePosition(worldPos);
		objRB.MoveRotation(worldRot);
	}

	public void SetVelocityLinear(Vector3 velocityLinear)
	{
		lastObjectLinearVelocity = velocityLinear;
		objRB.velocity = velocityLinear;
	}

	public void SetVelocityAngular(Vector3 velocityAngular)
	{
		lastObjectAngularVelocity = velocityAngular;
		objRB.angularVelocity = velocityAngular;
	}

	public void SetKinematic(bool isKinematic)
	{
		objRB.isKinematic = isKinematic;
	}

	public void SetDragLinear(float drag)
	{
		objRB.drag = drag;
	}

	public void SetDragAngular(float drag)
	{
		objRB.angularDrag = drag;
	}

	public void SetMass(float mass)
	{
		objRB.mass = mass;
	}

	public Vector3 GetVelocityLinear()
	{
		return objRB.velocity;
	}

	public Vector3 GetLastVelocityLinear()
	{
		return lastObjectLinearVelocity;
	}

	public Vector3 GetVelocityAngular()
	{
		return objRB.angularVelocity;
	}

	public Vector3 GetLastVelocityAngular()
	{
		return lastObjectAngularVelocity;
	}

	public bool GetKinematic()
	{
		return objRB.isKinematic;
	}

	public float GetDragLinear()
	{
		return objRB.drag;
	}

	public float GetDragAngular()
	{
		return objRB.angularDrag;
	}

	public float GetMass()
	{
		return objRB.mass;
	}

	public void TerminateSounds()
	{
		if ((bool)movementSound)
		{
			movementSound.Terminate();
		}
	}

	void IMimicBase.OnMimicEnteredPortal(Portal portal)
	{
	}

	void IMimicBase.OnMimicSwappedControl(bool inControl)
	{
		for (int i = 0; i < allRenderers.Length; i++)
		{
			allRenderers[i].enabled = inControl;
		}
		if (inControl)
		{
			GetLastState().UpdateToLatestState();
			PortalingRigidbody linkedMimicComp = ((IMimic<PortalingRigidbody>)this).LinkedMimicComp;
			if ((bool)linkedMimicComp)
			{
				SetVelocityLinear(linkedMimicComp.GetVelocityLinear());
				SetVelocityAngular(linkedMimicComp.GetVelocityAngular());
				SetKinematic(linkedMimicComp.GetKinematic());
			}
		}
		justSwappedMimicTimer = 0.25f;
	}

	void IMimicBase.OnMimicUpdate()
	{
	}

	bool IMimicBase.CanHaveControl()
	{
		return true;
	}

	public ConstArray<Collider> GetCurrentColliderSet()
	{
		currentColliders.Clear();
		if ((bool)portalVariations)
		{
			Collider[] colliders = portalVariations.variants[(int)portalVariations.currentController].Colliders;
			for (int i = 0; i < colliders.Length; i++)
			{
				currentColliders.Add(colliders[i]);
			}
		}
		for (int j = 0; j < globalColliders.Length; j++)
		{
			if (globalColliders[j].gameObject.activeInHierarchy)
			{
				currentColliders.Add(globalColliders[j]);
			}
		}
		return currentColliders;
	}

	public Vector3 ClosestPointOnCurrentColliderSet(Vector3 worldPosition)
	{
		Vector3 result = Vector3.zero;
		float num = float.MaxValue;
		ConstArray<Collider> currentColliderSet = GetCurrentColliderSet();
		for (int i = 0; i < currentColliderSet.Length; i++)
		{
			Collider collider = currentColliderSet[i];
			if (collider.gameObject.activeInHierarchy)
			{
				Vector3 vector = collider.ClosestPoint(worldPosition);
				float sqrMagnitude = (vector - worldPosition).sqrMagnitude;
				if (sqrMagnitude < num)
				{
					result = vector;
					num = sqrMagnitude;
				}
			}
		}
		if (num != float.MaxValue)
		{
			return result;
		}
		return worldPosition;
	}

	public void SetCurrentColliderEnabled(bool enabled)
	{
		for (int i = 0; i < currentColliders.Length; i++)
		{
			currentColliders[i].enabled = enabled;
		}
	}

	public ConstArray<Renderer> GetCurrentMeshRenderersSet()
	{
		currentMeshRenderers.Clear();
		if ((bool)portalVariations)
		{
			Renderer[] renderers = portalVariations.variants[(int)portalVariations.currentController].Renderers;
			for (int i = 0; i < renderers.Length; i++)
			{
				currentMeshRenderers.Add(renderers[i]);
			}
		}
		for (int j = 0; j < globalRenderers.Length; j++)
		{
			currentMeshRenderers.Add(globalRenderers[j]);
		}
		return currentMeshRenderers;
	}

	public Bounds GetEncapsulatingBounds()
	{
		ConstArray<Collider> currentColliderSet = GetCurrentColliderSet();
		if (currentColliderSet.Length != 0)
		{
			Bounds bounds = currentColliderSet[0].bounds;
			for (int i = 1; i < currentColliderSet.Length; i++)
			{
				bounds.Encapsulate(currentColliderSet[i].bounds);
			}
			return bounds;
		}
		return default(Bounds);
	}

	public Bounds GetEncapsulatingRendererBounds()
	{
		ConstArray<Renderer> currentMeshRenderersSet = GetCurrentMeshRenderersSet();
		if (currentMeshRenderersSet.Length != 0)
		{
			Bounds bounds = currentMeshRenderersSet[0].bounds;
			for (int i = 1; i < currentMeshRenderersSet.Length; i++)
			{
				bounds.Encapsulate(currentMeshRenderersSet[i].bounds);
			}
			return bounds;
		}
		return default(Bounds);
	}

	public void ApplyMaterialPropertyBlock(MPBStore store)
	{
		ConstArray<Renderer> currentMeshRenderersSet = GetCurrentMeshRenderersSet();
		for (int i = 0; i < currentMeshRenderersSet.Length; i++)
		{
			store.ApplyProperties(currentMeshRenderersSet[i]);
		}
	}

	public void PlayCollisionSound()
	{
		if (collisionSounds != null && collisionSounds.Length != 0)
		{
			OnCollision(((grabObject != null && (bool)grabObject.currentGrabbedHand) ? grabObject.grabbedLinearVelocity : GetVelocityLinear()).magnitude);
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		PlayCollisionSound();
		if (grabObject != null && collision.gameObject.layer == 20)
		{
			Vector3 zero = Vector3.zero;
			int num = 0;
			for (int i = 0; i < collision.contactCount; i++)
			{
				zero += collision.GetContact(i).point;
				num++;
			}
			if (num > 0)
			{
				zero /= (float)num;
			}
			PSC.Inst.Play(BaseSettings<ODZSettings>.Inst.impactParticle, zero, Quaternion.LookRotation(collision.relativeVelocity.normalized), Vector3X.one);
			FAC.Inst.PlayOneShot(BaseSettings<ODZSettings>.Inst.impactSFX, zero);
		}
	}

	protected void OnCollision(float mag)
	{
		if (!ValidateCollision(mag))
		{
			return;
		}
		for (int i = 0; i < collisionSounds.Length; i++)
		{
			CollisionSound collisionSound = collisionSounds[i];
			if (collisionSound.gameObject.activeInHierarchy)
			{
				collisionSound.Play(mag);
			}
		}
		collisionTimer = 0.3f;
	}

	private bool ValidateCollision(float magnitude)
	{
		if (owner != MainCamera.Inst.GetOwner())
		{
			return false;
		}
		if (magnitude < 0.3f)
		{
			return false;
		}
		if (collisionTimer > 0f)
		{
			return false;
		}
		if (CC.Inst.PositionStackAnimating())
		{
			return false;
		}
		if (justSwappedMimicTimer > 0f)
		{
			return false;
		}
		return true;
	}

	public void OnPrePhysicsUpdateLR()
	{
		ConstArray<Portal> portals = owner.portals;
		ConstArray<Collider> currentColliderSet = GetCurrentColliderSet();
		Portal portal = null;
		Vector3 velocityLinear = GetVelocityLinear();
		for (int i = 0; i < portals.Length; i++)
		{
			Portal portal2 = portals[i];
			bool flag = false;
			if (portal2.GetPortalState() == PortalState.OPEN && portal2.portalColliders.Length != 0)
			{
				for (int j = 0; j < currentColliderSet.Length; j++)
				{
					Collider collider = currentColliderSet[j];
					Vector3 size = collider.bounds.size;
					float num = MathfX.Max(size.x, size.y, size.z);
					Vector3 center = collider.bounds.center + velocityLinear * 0.034f;
					Vector3 size2 = Vector3X.one * num;
					Bounds worldBounds = new Bounds(center, size2);
					flag |= portal2.IntersectsBounds(worldBounds);
					flag |= portal2.IntersectsBounds(collider.bounds);
				}
			}
			if (flag)
			{
				portal = portal2;
			}
		}
		SetLastIntersectingPortal(portal);
	}

	private void SetLastIntersectingPortal(Portal intersectingPortal)
	{
		if ((bool)lastIntersectingPortal)
		{
			for (int i = 0; i < lastIntersectingPortal.portalColliders.Length; i++)
			{
				SetIgnoredCollision(lastIntersectingPortal.portalColliders[i], ignored: false);
			}
		}
		lastIntersectingPortal = intersectingPortal;
		if ((bool)intersectingPortal)
		{
			for (int j = 0; j < intersectingPortal.portalColliders.Length; j++)
			{
				SetIgnoredCollision(intersectingPortal.portalColliders[j], ignored: true);
			}
		}
	}

	private void SetIgnoredCollision(Collider ignoredCollider, bool ignored)
	{
		ConstArray<Collider> currentColliderSet = GetCurrentColliderSet();
		for (int i = 0; i < currentColliderSet.Length; i++)
		{
			Physics.IgnoreCollision(currentColliderSet[i], ignoredCollider, ignored);
		}
	}

	private void OnVariantSetChanged()
	{
		SetLastIntersectingPortal(lastIntersectingPortal);
	}
}
[Serializable]
public class ProbeSystem
{
	public struct InterpolationData
	{
		public readonly int tIdx;

		public readonly float w0;

		public readonly float w1;

		public readonly float w2;

		public readonly float w3;

		public readonly int v0;

		public readonly int v1;

		public readonly int v2;

		public readonly int v3;

		public InterpolationData(int tIdx, float w0, float w1, float w2, float w3, int v0, int v1, int v2, int v3)
		{
			this.tIdx = tIdx;
			this.w0 = w0;
			this.w1 = w1;
			this.w2 = w2;
			this.w3 = w3;
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
		}
	}

	[Serializable]
	private struct Tetrahedron
	{
		public int v0;

		public int v1;

		public int v2;

		public int v3;

		public Tetrahedron(int v0, int v1, int v2, int v3)
		{
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
		}

		public bool ContainsVertex(int v)
		{
			if (v0 != v && v1 != v && v2 != v)
			{
				return v3 == v;
			}
			return true;
		}

		public void DrawGizmo(Vector3[] verts)
		{
			Gizmos.DrawLine(verts[v0], verts[v1]);
			Gizmos.DrawLine(verts[v0], verts[v2]);
			Gizmos.DrawLine(verts[v0], verts[v3]);
			Gizmos.DrawLine(verts[v1], verts[v2]);
			Gizmos.DrawLine(verts[v1], verts[v3]);
			Gizmos.DrawLine(verts[v2], verts[v3]);
		}
	}

	[Serializable]
	private struct VectorD3
	{
		public double x;

		public double y;

		public double z;

		public VectorD3(double x, double y, double z)
		{
			this.x = x;
			this.y = y;
			this.z = z;
		}

		public static VectorD3 Cross(VectorD3 a, VectorD3 b)
		{
			VectorD3 result = default(VectorD3);
			result.x = a.y * b.z - a.z * b.y;
			result.y = a.z * b.x - a.x * b.z;
			result.z = a.x * b.y - a.y * b.x;
			return result;
		}

		public static double Dot(VectorD3 a, VectorD3 b)
		{
			return a.x * b.x + a.y * b.y + a.z * b.z;
		}

		public static VectorD3 Lerp(VectorD3 a, VectorD3 b, double t)
		{
			t = ((t < 0.0) ? 0.0 : ((t > 1.0) ? 1.0 : t));
			VectorD3 result = default(VectorD3);
			result.x = a.x + (b.x - a.x) * t;
			result.y = a.y + (b.y - a.y) * t;
			result.z = a.z + (b.z - a.z) * t;
			return result;
		}

		public static VectorD3 LerpUnclamped(VectorD3 a, VectorD3 b, double t)
		{
			VectorD3 result = default(VectorD3);
			result.x = a.x + (b.x - a.x) * t;
			result.y = a.y + (b.y - a.y) * t;
			result.z = a.z + (b.z - a.z) * t;
			return result;
		}

		public static double SqrMagnitude(VectorD3 a)
		{
			return a.x * a.x + a.y * a.y + a.z * a.z;
		}

		public static double Magnitude(VectorD3 a)
		{
			return Math.Sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
		}

		public static VectorD3 Normalize(VectorD3 a)
		{
			double num = Math.Sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
			if (num > 1E-05)
			{
				a.x /= num;
				a.y /= num;
				a.z /= num;
			}
			else
			{
				a.x = (a.y = (a.z = 0.0));
			}
			return a;
		}

		public static VectorD3 operator +(VectorD3 a, VectorD3 b)
		{
			VectorD3 result = default(VectorD3);
			result.x = a.x + b.x;
			result.y = a.y + b.y;
			result.z = a.z + b.z;
			return result;
		}

		public static VectorD3 operator -(VectorD3 a, VectorD3 b)
		{
			VectorD3 result = default(VectorD3);
			result.x = a.x - b.x;
			result.y = a.y - b.y;
			result.z = a.z - b.z;
			return result;
		}

		public static VectorD3 operator -(VectorD3 a)
		{
			a.x = 0.0 - a.x;
			a.y = 0.0 - a.y;
			a.z = 0.0 - a.z;
			return a;
		}

		public static VectorD3 operator *(VectorD3 a, double d)
		{
			a.x *= d;
			a.y *= d;
			a.z *= d;
			return a;
		}

		public static VectorD3 operator *(double d, VectorD3 a)
		{
			a.x *= d;
			a.y *= d;
			a.z *= d;
			return a;
		}

		public static VectorD3 operator /(VectorD3 a, double d)
		{
			a.x /= d;
			a.y /= d;
			a.z /= d;
			return a;
		}

		public static implicit operator VectorD3(Vector3 v)
		{
			VectorD3 result = default(VectorD3);
			result.x = v.x;
			result.y = v.y;
			result.z = v.z;
			return result;
		}

		public static explicit operator Vector3(VectorD3 v)
		{
			Vector3 result = default(Vector3);
			result.x = (float)v.x;
			result.y = (float)v.y;
			result.z = (float)v.z;
			return result;
		}
	}

	private struct Circumsphere
	{
		private const double CONTAINS_TOLERANCE = 0.0001;

		private readonly VectorD3 center;

		private readonly double sqrRadius;

		public bool Valid => !double.IsPositiveInfinity(sqrRadius);

		public Circumsphere(VectorD3 a, VectorD3 b, VectorD3 c, VectorD3 d)
		{
			VectorD3 vectorD = b - a;
			VectorD3 vectorD2 = c - a;
			VectorD3 vectorD3 = d - a;
			VectorD3 plane1Position = a + vectorD * 0.5;
			VectorD3 plane2Position = a + vectorD2 * 0.5;
			VectorD3 plane2Position2 = a + vectorD3 * 0.5;
			if (true & PlanePlaneIntersection(vectorD, plane1Position, vectorD2, plane2Position, out var linePos, out var lineVec) & PlanePlaneIntersection(vectorD, plane1Position, vectorD3, plane2Position2, out var linePos2, out var lineVec2) & ClosestPointsOnTwoLines(linePos, lineVec, linePos2, lineVec2, out var closest, out var closest2))
			{
				center = VectorD3.Lerp(closest, closest2, 0.5);
				sqrRadius = VectorD3.SqrMagnitude(center - a);
			}
			else
			{
				center = new VectorD3(0.0, 0.0, 0.0);
				sqrRadius = double.PositiveInfinity;
			}
		}

		public bool Contains(VectorD3 v)
		{
			return VectorD3.SqrMagnitude(v - center) - sqrRadius < 0.0001;
		}
	}

	private struct PlaneD
	{
		private VectorD3 normal;

		private double distance;

		public PlaneD(VectorD3 a, VectorD3 b, VectorD3 c)
		{
			normal = VectorD3.Normalize(VectorD3.Cross(b - a, c - a));
			distance = 0.0 - VectorD3.Dot(normal, a);
		}

		public double GetDistanceToPoint(VectorD3 a)
		{
			return VectorD3.Dot(normal, a) + distance;
		}
	}

	private struct Face
	{
		public class EC : IEqualityComparer<Face>
		{
			private static int IntHash(int i)
			{
				i ^= i >> 17;
				i *= 830770091;
				i ^= i >> 11;
				i *= -1404298415;
				i ^= i >> 15;
				i *= 830770091;
				i ^= i >> 14;
				return i;
			}

			bool IEqualityComparer<Face>.Equals(Face lhs, Face rhs)
			{
				if ((lhs.v0 != rhs.v0 || lhs.v1 != rhs.v1 || lhs.v2 != rhs.v2) && (lhs.v0 != rhs.v0 || lhs.v1 != rhs.v2 || lhs.v2 != rhs.v1) && (lhs.v0 != rhs.v1 || lhs.v1 != rhs.v0 || lhs.v2 != rhs.v2) && (lhs.v0 != rhs.v1 || lhs.v1 != rhs.v2 || lhs.v2 != rhs.v0) && (lhs.v0 != rhs.v2 || lhs.v1 != rhs.v0 || lhs.v2 != rhs.v1))
				{
					if (lhs.v0 == rhs.v2 && lhs.v1 == rhs.v1)
					{
						return lhs.v2 == rhs.v0;
					}
					return false;
				}
				return true;
			}

			int IEqualityComparer<Face>.GetHashCode(Face face)
			{
				return IntHash(face.v0) + IntHash(face.v1) + IntHash(face.v2);
			}
		}

		public int v0;

		public int v1;

		public int v2;

		public Face(int v0, int v1, int v2)
		{
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
		}
	}

	[Serializable]
	private struct Neighbours
	{
		public int n0;

		public int n1;

		public int n2;

		public int n3;
	}

	private struct TetraFace
	{
		public int tetra;

		public int face;
	}

	private const double PLANAR_TOLERANCE = 0.0010999999940395355;

	[SerializeField]
	private VectorD3[] verts;

	[SerializeField]
	private Tetrahedron[] tetrahedra;

	[SerializeField]
	private Neighbours[] neighbourGraph;

	[SerializeField]
	private Matrix4x4[] baryMatricies;

	public int TetraCount => tetrahedra.Length;

	private static bool PlanePlaneIntersection(VectorD3 plane1Normal, VectorD3 plane1Position, VectorD3 plane2Normal, VectorD3 plane2Position, out VectorD3 linePos, out VectorD3 lineVec)
	{
		lineVec = VectorD3.Cross(plane1Normal, plane2Normal);
		VectorD3 vectorD = VectorD3.Cross(plane2Normal, lineVec);
		double num = VectorD3.Dot(plane1Normal, vectorD);
		if (Math.Abs(num) > 1E-05)
		{
			VectorD3 b = plane1Position - plane2Position;
			double num2 = VectorD3.Dot(plane1Normal, b) / num;
			linePos = plane2Position + num2 * vectorD;
			return true;
		}
		lineVec = (linePos = new VectorD3(0.0, 0.0, 0.0));
		return false;
	}

	private static bool ClosestPointsOnTwoLines(VectorD3 pos1, VectorD3 dir1, VectorD3 pos2, VectorD3 dir2, out VectorD3 closest1, out VectorD3 closest2)
	{
		double num = VectorD3.Dot(dir1, dir1);
		double num2 = VectorD3.Dot(dir1, dir2);
		double num3 = VectorD3.Dot(dir2, dir2);
		double num4 = num * num3 - num2 * num2;
		if (num4 != 0.0)
		{
			VectorD3 b = pos1 - pos2;
			double num5 = VectorD3.Dot(dir1, b);
			double num6 = VectorD3.Dot(dir2, b);
			double num7 = (num2 * num6 - num5 * num3) / num4;
			double num8 = (num * num6 - num5 * num2) / num4;
			closest1 = pos1 + dir1 * num7;
			closest2 = pos2 + dir2 * num8;
			return true;
		}
		closest1 = (closest2 = new VectorD3(0.0, 0.0, 0.0));
		return false;
	}

	private static void SetNeighbour(Dictionary<Face, TetraFace> tetraByFace, Neighbours[] neighbours, int tIdx, int fIdx, Face face, out int nIdx)
	{
		if (tetraByFace.TryGetValue(face, out var value))
		{
			nIdx = value.tetra;
			switch (value.face)
			{
			case 0:
				neighbours[value.tetra].n0 = tIdx;
				break;
			case 1:
				neighbours[value.tetra].n1 = tIdx;
				break;
			case 2:
				neighbours[value.tetra].n2 = tIdx;
				break;
			case 3:
				neighbours[value.tetra].n3 = tIdx;
				break;
			default:
				UnityEngine.Debug.LogError($"Bad tetra face index {value.tetra}:{value.face}");
				break;
			}
		}
		else
		{
			nIdx = -1;
			tetraByFace.Add(face, new TetraFace
			{
				tetra = tIdx,
				face = fIdx
			});
		}
	}

	private static void AddFace(HashSet<Face> faces, Face face)
	{
		if (!faces.Add(face))
		{
			faces.Remove(face);
		}
	}

	public ProbeSystem(Vector3[] inputVerts)
	{
		Bounds bounds = new Bounds(inputVerts[0], Vector3.zero);
		for (int i = 1; i < inputVerts.Length; i++)
		{
			bounds.Encapsulate(inputVerts[i]);
		}
		bounds.Expand(VectorX.Max(bounds.size) * 20f);
		bounds.extents = Vector3.Max(bounds.extents, Vector3.one);
		Vector3 center = bounds.center;
		Vector3 min = bounds.min;
		Vector3 max = bounds.max;
		List<VectorD3> list = new List<VectorD3>();
		for (int j = 0; j < inputVerts.Length; j++)
		{
			list.Add(inputVerts[j]);
		}
		int p1 = list.Count;
		list.Add(new Vector3(min.x, min.y, min.z));
		int p2 = list.Count;
		list.Add(new Vector3(center.x, max.y, min.z));
		int p3 = list.Count;
		list.Add(new Vector3(max.x, min.y, min.z));
		int p4 = list.Count;
		list.Add(new Vector3(center.x, center.y, max.z));
		List<Tetrahedron> list2 = new List<Tetrahedron>
		{
			new Tetrahedron(p1, p2, p3, p4)
		};
		List<Circumsphere> list3 = new List<Circumsphere>
		{
			new Circumsphere(list[p1], list[p2], list[p3], list[p4])
		};
		HashSet<Face> hashSet = new HashSet<Face>(new Face.EC());
		for (int k = 0; k < inputVerts.Length; k++)
		{
			hashSet.Clear();
			for (int l = 0; l < list2.Count; l++)
			{
				Tetrahedron tetrahedron = list2[l];
				if (list3[l].Contains(list[k]))
				{
					AddFace(hashSet, new Face(tetrahedron.v1, tetrahedron.v2, tetrahedron.v3));
					AddFace(hashSet, new Face(tetrahedron.v2, tetrahedron.v3, tetrahedron.v0));
					AddFace(hashSet, new Face(tetrahedron.v3, tetrahedron.v0, tetrahedron.v1));
					AddFace(hashSet, new Face(tetrahedron.v0, tetrahedron.v1, tetrahedron.v2));
					list2.RemoveAt(l);
					list3.RemoveAt(l);
					l--;
				}
			}
			foreach (Face item3 in hashSet)
			{
				Tetrahedron item = new Tetrahedron(item3.v0, item3.v1, item3.v2, k);
				Circumsphere item2 = new Circumsphere(list[item.v0], list[item.v1], list[item.v2], list[item.v3]);
				PlaneD planeD = new PlaneD(list[item.v0], list[item.v1], list[item.v2]);
				if (item2.Valid && Math.Abs(planeD.GetDistanceToPoint(list[item.v3])) > 0.0010999999940395355)
				{
					list2.Add(item);
					list3.Add(item2);
				}
			}
		}
		list2.RemoveAll((Tetrahedron t) => t.ContainsVertex(p1) || t.ContainsVertex(p2) || t.ContainsVertex(p3) || t.ContainsVertex(p4));
		list.RemoveRange(p1, 4);
		verts = list.ToArray();
		tetrahedra = list2.ToArray();
		neighbourGraph = new Neighbours[tetrahedra.Length];
		Dictionary<Face, TetraFace> tetraByFace = new Dictionary<Face, TetraFace>(new Face.EC());
		Neighbours neighbours = default(Neighbours);
		for (int m = 0; m < neighbourGraph.Length; m++)
		{
			Tetrahedron tetrahedron2 = tetrahedra[m];
			SetNeighbour(tetraByFace, neighbourGraph, m, 0, new Face(tetrahedron2.v1, tetrahedron2.v2, tetrahedron2.v3), out neighbours.n0);
			SetNeighbour(tetraByFace, neighbourGraph, m, 1, new Face(tetrahedron2.v2, tetrahedron2.v3, tetrahedron2.v0), out neighbours.n1);
			SetNeighbour(tetraByFace, neighbourGraph, m, 2, new Face(tetrahedron2.v3, tetrahedron2.v0, tetrahedron2.v1), out neighbours.n2);
			SetNeighbour(tetraByFace, neighbourGraph, m, 3, new Face(tetrahedron2.v0, tetrahedron2.v1, tetrahedron2.v2), out neighbours.n3);
			neighbourGraph[m] = neighbours;
		}
		baryMatricies = new Matrix4x4[tetrahedra.Length];
		for (int n = 0; n < baryMatricies.Length; n++)
		{
			Tetrahedron tetrahedron3 = tetrahedra[n];
			Vector3 vector = (Vector3)verts[tetrahedron3.v3];
			Vector3 vector2 = (Vector3)verts[tetrahedron3.v0] - vector;
			Vector3 vector3 = (Vector3)verts[tetrahedron3.v1] - vector;
			Vector3 vector4 = (Vector3)verts[tetrahedron3.v2] - vector;
			baryMatricies[n] = new Matrix4x4(vector2, vector3, vector4, new Vector4(0f, 0f, 0f, 1f)).inverse * Matrix4x4.Translate(-vector);
		}
	}

	public InterpolationData GetInterpolationData(Vector3 p)
	{
		Vector4 bary;
		int num = FindIndexForPosition(p, out bary);
		Tetrahedron tetrahedron = tetrahedra[num];
		return new InterpolationData(num, bary.x, bary.y, bary.z, bary.w, tetrahedron.v0, tetrahedron.v1, tetrahedron.v2, tetrahedron.v3);
	}

	public Vector4 GetBary(int tIdx, Vector3 p)
	{
		Vector3 vector = baryMatricies[tIdx].MultiplyPoint3x4(p);
		return new Vector4(vector.x, vector.y, vector.z, 1f - (vector.x + vector.y + vector.z));
	}

	private int FindIndexForPosition(Vector3 p, out Vector4 bary)
	{
		int num = 0;
		bary = default(Vector4);
		for (int i = 0; i < tetrahedra.Length; i++)
		{
			bary = GetBary(num, p);
			if (bary.x >= 0f && bary.y >= 0f && bary.z >= 0f && bary.w >= 0f)
			{
				break;
			}
			int num2 = ((bary.x < bary.y && bary.x < bary.z && bary.x < bary.w) ? neighbourGraph[num].n0 : ((bary.y < bary.z && bary.y < bary.w) ? neighbourGraph[num].n1 : ((!(bary.z < bary.w)) ? neighbourGraph[num].n3 : neighbourGraph[num].n2)));
			if (num2 == -1)
			{
				break;
			}
			num = num2;
		}
		return num;
	}
}
public class ProfilerLogger : MonoBehaviour
{
	private int frameCount;

	private static bool HasArg(string name)
	{
		string[] commandLineArgs = Environment.GetCommandLineArgs();
		for (int i = 0; i < commandLineArgs.Length; i++)
		{
			if (commandLineArgs[i] == name)
			{
				return true;
			}
		}
		return false;
	}

	private void Awake()
	{
	}

	private void OnDestroy()
	{
		Profiler.enabled = false;
	}

	private IEnumerator DataLogger()
	{
		while (true)
		{
			Profiler.logFile = UnityEngine.Application.persistentDataPath + "/profilerData" + frameCount.ToString("000");
			Profiler.enableBinaryLog = true;
			Profiler.enabled = true;
			for (int i = 0; i < 300; i++)
			{
				yield return new WaitForEndOfFrame();
				if (!Profiler.enabled)
				{
					Profiler.enabled = true;
				}
			}
			frameCount++;
		}
	}
}
public class PuzzleResetter : MonoBehaviour, IAwakeEvent
{
	public ObeliskPuzzle[] puzzles;

	private MRBase owner;

	private IHaglet puzzleResetRoutine;

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		this.owner = owner;
		Haglet.Create(out puzzleResetRoutine, PuzzleResetRoutine);
	}

	[Event(EventName = "Reset Puzzles")]
	public void ResetPuzzles(object sender)
	{
		puzzleResetRoutine.Start(resetIfStarted: true);
	}

	public IEnumerator<Routine.Yield> PuzzleResetRoutine()
	{
		if (puzzles != null)
		{
			yield return Wait.For.Seconds(0.5f);
			for (int i = 0; i < puzzles.Length; i++)
			{
				puzzles[i].ResetPuzzle();
			}
			owner.obelisk.constellation.ResetNodes();
		}
	}
}
public class RadioStub : MonoBehaviour
{
}
public class RegionEvent_LoadScene : IDObject, Region.IEvents, IAwakeEvent
{
	public SceneInfo_BundleRef[] sceneInfos;

	public bool requiresPortalMachine = true;

	[SerializeField]
	[ConditionalHide("requiresPortalMachine", true)]
	private PortalMachine portalMachine;

	[SerializeField]
	private Portal portal;

	public void OnEnterRegion()
	{
		if (requiresPortalMachine && (bool)portalMachine && !portalMachine.HasPower)
		{
			return;
		}
		SceneInfo sceneInfo = sceneInfos[0].Load();
		SaveDataGame.Chapter puzzleChapter = sceneInfo.GetPuzzleChapter();
		bool flag = false;
		SaveDataGame saveDataGame = LR.Inst.saveDataGame;
		if (!saveDataGame.IsChapterFinished(puzzleChapter))
		{
			string lastLevelUIDInChapter = saveDataGame.GetLastLevelUIDInChapter(puzzleChapter);
			for (int i = 1; i < sceneInfos.Length; i++)
			{
				SceneInfo sceneInfo2 = sceneInfos[i].Load();
				if (sceneInfo2.sceneUIDName == lastLevelUIDInChapter)
				{
					sceneInfo = sceneInfo2;
					flag = true;
					break;
				}
			}
		}
		if (!owner.CalculateConnectedScenes().Contains(sceneInfo))
		{
			owner.AddConnectingScene(sceneInfo);
			LR.Inst.LoadAdjacentScenes();
		}
		if (flag)
		{
			if (portal != null)
			{
				portal.switchTargetPortalLink.Start(sceneInfo);
			}
			else
			{
				UnityEngine.Debug.LogError("Tried to switch portal target to " + sceneInfo.sceneName + " but no portal assigned to regionEvent", this);
			}
		}
	}

	public void OnExitRegion()
	{
		SceneInfo info = sceneInfos[0].Load();
		owner.RemoveConnectingScene(info);
	}
}
public class RendererBoundsGizmo : MonoBehaviour
{
	private void OnDrawGizmos()
	{
		Bounds bounds = GetComponent<MeshRenderer>().bounds;
		Color red = Color.red;
		Gizmos.matrix = Matrix4x4.identity;
		Gizmos.color = red;
		Gizmos.DrawWireCube(bounds.center, bounds.size);
		red.a = 0.4f;
		Gizmos.color = red;
		Gizmos.DrawCube(bounds.center, bounds.size);
	}
}
public class RigidBodyKeepAwake : MonoBehaviour
{
	private Rigidbody rb;

	private void Start()
	{
		rb = GetComponent<Rigidbody>();
	}

	private void FixedUpdate()
	{
		rb.WakeUp();
	}
}
public class RotatableIndicator : MonoBehaviour, IAwakeEvent, IUpdateEvent
{
	public float VerticalOffset;

	public float OutwardOffset;

	private GameObject indicatorGameObject;

	private MPBStore mpbStore = new MPBStore();

	private static readonly int _Alpha = Shader.PropertyToID("_Alpha");

	public void OnAwakeLR(MRBase owner)
	{
		indicatorGameObject = UnityEngine.Object.Instantiate(BaseSettings<InteractionSettings>.Inst.rotatorHandlePrefab, base.transform);
		mpbStore.Initialise();
		if (float.IsNaN(VerticalOffset))
		{
			VerticalOffset = 0f;
		}
	}

	public void OnUpdateLR()
	{
		InteractionSettings inst = BaseSettings<InteractionSettings>.Inst;
		Vector3 headPosition = IC.GetHeadPosition();
		Vector3 vect = base.transform.InverseTransformPoint(headPosition);
		if (vect.sqrMagnitude > inst.sqrVisibleDistFadeOut)
		{
			if (indicatorGameObject.activeSelf)
			{
				indicatorGameObject.SetActive(value: false);
			}
			return;
		}
		Vector3 position = vect.RepY(0f);
		Vector3 normalized = (base.transform.TransformPoint(position) - base.transform.position).normalized;
		indicatorGameObject.transform.position = base.transform.TransformPoint(Vector3.up * VerticalOffset) + normalized * OutwardOffset;
		indicatorGameObject.transform.rotation = Quaternion.LookRotation(-normalized, base.transform.up);
		float num = inst.GetUIAlpha(indicatorGameObject.transform.position, OutwardOffset);
		if (vect.sqrMagnitude > inst.sqrVisibleDistFadeIn)
		{
			num = Mathf.Lerp(num, 0f, (vect.sqrMagnitude - inst.sqrVisibleDistFadeIn) / (inst.sqrVisibleDistFadeOut - inst.sqrVisibleDistFadeIn));
		}
		if (num > 0.01f)
		{
			if (!indicatorGameObject.activeSelf)
			{
				indicatorGameObject.SetActive(value: true);
			}
			mpbStore.SetFloat(_Alpha, num);
			mpbStore.ApplyProperties(indicatorGameObject.GetComponent<MeshRenderer>());
		}
		else if (indicatorGameObject.activeSelf)
		{
			indicatorGameObject.SetActive(value: false);
		}
	}
}
public class RotateTowardsPlayer : MonoBehaviour, IUpdateEvent
{
	public float speed = 90f;

	public void OnUpdateLR()
	{
		Vector3 headPosition = IC.GetHeadPosition();
		Vector3 position = base.transform.InverseTransformPoint(headPosition);
		position.y = 0f;
		headPosition = base.transform.TransformPoint(position);
		Vector3 forward = Quaternion.LookRotation(headPosition - base.transform.position, base.transform.up) * Vector3.left;
		base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, Quaternion.LookRotation(forward, base.transform.up), speed * IC.DeltaTime);
	}
}
public class RotationMimic : MonoBehaviour
{
	public Transform target;

	public Transform targetRelativeTo;

	public Transform rotateRelativeTo;

	public float speedModifier;

	[Space]
	public FMODEventAsset soundRotate;

	private FMOD.Studio.EventInstance evt;

	public string speedParameter = "";

	public string stopParameter = "";

	private float eventTimer;

	private Vector3 lastFrameRot;

	[Tooltip("When the parameter falls below this number, consider it stopped.")]
	public float speedWindow = 0.1f;

	[Tooltip("The degrees/second to consider the speed parameter at 1.")]
	public float speedParameterAdjustment = 5f;

	private void LateUpdate()
	{
		if (!target)
		{
			return;
		}
		Vector3 vector = ((!(targetRelativeTo != null)) ? target.rotation : targetRelativeTo.rotation.InverseTransformRotation(target.rotation)).eulerAngles * speedModifier;
		if (soundRotate != null)
		{
			Vector3 vector2 = vector - lastFrameRot;
			lastFrameRot = vector;
			float num = vector2.magnitude / (IC.DeltaTime * speedParameterAdjustment);
			if (num > speedWindow)
			{
				eventTimer = 0.1f;
				if (!evt.isValid())
				{
					evt = FAC.Inst.PlayOneShot(soundRotate, base.transform.position);
				}
				if (speedParameter != "")
				{
					evt.setParameterValue(speedParameter, num);
				}
				if (stopParameter != "")
				{
					evt.setParameterValue(stopParameter, 0f);
				}
			}
			else if (eventTimer > 0f)
			{
				eventTimer -= IC.DeltaTime;
				if (eventTimer < 0f)
				{
					if (speedParameter != "")
					{
						evt.setParameterValue(speedParameter, 0f);
					}
					if (stopParameter != "")
					{
						evt.setParameterValue(stopParameter, 1f);
					}
					else
					{
						evt.stop(STOP_MODE.ALLOWFADEOUT);
					}
				}
			}
		}
		if (rotateRelativeTo != null)
		{
			base.transform.rotation = rotateRelativeTo.rotation * Quaternion.Euler(vector);
		}
		else
		{
			base.transform.rotation = Quaternion.Euler(vector);
		}
	}

	private void OnDestroy()
	{
		if (evt.isValid())
		{
			evt.stop(STOP_MODE.IMMEDIATE);
		}
	}
}
public class RotationSFX : MonoBehaviour, IAwakeEvent, IPostPhysicsUpdateEvent
{
	public FMODEventAsset soundAsset;

	public float soundDegreeOffset = 8f;

	private Quaternion prevRotation;

	private float totalDelta;

	public bool localSpace;

	private Quaternion CurrentRotation
	{
		get
		{
			if (!localSpace)
			{
				return base.transform.rotation;
			}
			return base.transform.localRotation;
		}
	}

	public void OnAwakeLR(MRBase owner)
	{
		prevRotation = CurrentRotation;
	}

	public void OnPostPhysicsUpdateLR()
	{
		if (soundAsset != null)
		{
			float num = Quaternion.Angle(prevRotation, CurrentRotation);
			totalDelta += num;
			if (totalDelta > soundDegreeOffset)
			{
				totalDelta -= soundDegreeOffset;
				float value = Mathf.Clamp01(num / IC.DeltaTime / 360f);
				FAC.Inst.PlayOneShot(soundAsset, base.transform.position).setParameterValue("Speed", value);
			}
		}
		prevRotation = CurrentRotation;
	}
}
public class SceneInfo : ScriptableObject
{
	public enum MenuType
	{
		Tutorial,
		Hub,
		Chapter,
		Main,
		Limited,
		Credits,
		MainLimited,
		MainTutorial
	}

	public string sceneSubFolder;

	[SerializeField]
	[HideInInspector]
	public string scenePath;

	[ReadOnly]
	public string sceneName;

	public bool useCustomPrettyName;

	[SerializeField]
	[ReadOnly]
	private string _prettyName;

	[ConditionalHide("useCustomPrettyName")]
	public string customPrettyName;

	[ReadOnly]
	public int sceneUID;

	[ReadOnly]
	public string sceneUIDName;

	public bool devScene;

	public bool inFantasyWorld = true;

	public bool allowSceneRefConnections = true;

	public HagletValue<bool> isSceneAwake;

	public MenuType sceneMenuType;

	public bool canSave = true;

	public bool shouldSaveAsLast = true;

	private ChapterInfo chapterInfo;

	public string occlusionSceneName;

	public string prettyName
	{
		get
		{
			if (!useCustomPrettyName)
			{
				return _prettyName;
			}
			return customPrettyName;
		}
	}

	public bool isArtScene => sceneName.ToLower().EndsWith("art");

	public void InitAwakeValue()
	{
		HagletValue.Create(out isSceneAwake, null, initVal: false, null, 8);
	}

	public void AssignChapter(ChapterInfo chapterInfo)
	{
		if (this.chapterInfo != null)
		{
			_ = this.chapterInfo != chapterInfo;
		}
		this.chapterInfo = chapterInfo;
	}

	public SaveDataGame.Chapter GetPuzzleChapter()
	{
		if ((bool)chapterInfo)
		{
			return chapterInfo.chapter;
		}
		return SaveDataGame.Chapter.None;
	}

	public int GetSceneIndex()
	{
		if (chapterInfo == null || !shouldSaveAsLast)
		{
			return -1;
		}
		for (int i = 0; i < chapterInfo.chapterScenes.Length; i++)
		{
			if (chapterInfo.chapterScenes[i].Load().sceneUID == sceneUID)
			{
				return i;
			}
		}
		return -1;
	}
}
[Serializable]
public class SceneInfo_BundleRef : BundleRef<SceneInfo>
{
}
[CreateAssetMenu(menuName = "SceneInfoGroup", order = 0)]
public class SceneInfoGroup : ScriptableObject
{
	public SceneInfo[] scenes;

	public bool isSameArea;
}
[Serializable]
public class SceneInfoGroup_BundleRef : BundleRef<SceneInfoGroup>
{
}
[CreateAssetMenu(menuName = "SceneInfoMimicGroup", order = 0)]
public class SceneInfoMimicGroup : SceneInfoGroup
{
	public void OnValidate()
	{
		isSameArea = true;
		if (scenes.Length != 2)
		{
			Array.Resize(ref scenes, 2);
		}
	}
}
[Serializable]
public class SceneInfoMimicGroup_BundleRef : BundleRef<SceneInfoMimicGroup>
{
}
public class Screenshot : MonoBehaviour
{
	public int resWidth = 3840;

	public int resHeight = 2160;

	[Range(30f, 120f)]
	public float fieldOfView = 60f;
}
public class SeatingController : MonoBehaviour
{
	private float yOffset;

	public bool OffsetActive { get; private set; }

	public void OnAwakeLR()
	{
		OffsetActive = LR.Inst.saveDataSettings.seatingMode;
		yOffset = LR.Inst.saveDataSettings.seatingOffset;
		SetOffset();
	}

	public void SetSeating(bool seating)
	{
		if (seating || OffsetActive)
		{
			if (seating)
			{
				yOffset = 0f;
				SetOffset();
				yOffset = 0f - (CC.Inst.transform.InverseTransformPoint(MainCamera.Inst.transform.position).y - BaseSettings<TeleportSettings>.Inst.defaultPlayerHeight);
			}
			else
			{
				yOffset = 0f;
			}
			LR.Inst.saveDataSettings.seatingMode = seating;
			LR.Inst.saveDataSettings.seatingOffset = yOffset;
			LR.Inst.Save();
			SetOffset();
			OffsetActive = seating;
		}
	}

	private void SetOffset()
	{
		Vector3 localPosition = base.transform.localPosition;
		localPosition.y = yOffset;
		base.transform.localPosition = localPosition;
	}
}
[PreBuildRemoveComponent]
[SelectionBase]
public class SelectionBase : MonoBehaviour
{
}
public class SetMusicParameterBasedOnDistance : MonoBehaviour, IUpdateEvent
{
	public string ParameterName;

	public float MinDistanceParameter;

	public float MaxDistanceParameter;

	private float currentParamater;

	public void OnUpdateLR()
	{
		float t = Vector3.Distance(base.transform.position, IC.GetHeadPosition());
		float num = Mathf.Lerp(MinDistanceParameter, MaxDistanceParameter, t);
		if (num != currentParamater)
		{
			currentParamater = num;
			LR.Inst.SetMusicParameter(ParameterName, num);
		}
	}
}
public class SFXLoop : MonoBehaviour, IAwakeEvent
{
	public FMODEventAsset[] sfxAssets;

	private FMOD.Studio.EventInstance[] evts;

	public void OnAwakeLR(MRBase owner)
	{
		evts = new FMOD.Studio.EventInstance[sfxAssets.Length];
		StartEvents();
	}

	private void OnDestroy()
	{
		StopEvents();
	}

	public void StartEvents()
	{
		StopEvents();
		if (evts == null)
		{
			evts = new FMOD.Studio.EventInstance[sfxAssets.Length];
		}
		for (int i = 0; i < evts.Length; i++)
		{
			evts[i] = FAC.Inst.PlayOneShot(sfxAssets[i], base.transform);
		}
	}

	public void StopEvents()
	{
		if (evts == null)
		{
			return;
		}
		for (int i = 0; i < evts.Length; i++)
		{
			if (evts[i].isValid())
			{
				evts[i].stop(STOP_MODE.ALLOWFADEOUT);
			}
		}
	}
}
public static class ShaderPID
{
	public static readonly int unity_LightIndicesOffsetAndCount = Shader.PropertyToID("unity_LightIndicesOffsetAndCount");

	public static readonly int unity_4LightIndices0 = Shader.PropertyToID("unity_4LightIndices0");

	public static readonly int unity_4LightIndices1 = Shader.PropertyToID("unity_4LightIndices1");

	public const string FOG_LUT_BOTH = "FOG_LUT_BOTH";

	public const string FOG_LUT_DEPTH = "FOG_LUT_DEPTH";

	public const string FOG_LUT_HEIGHT = "FOG_LUT_HEIGHT";

	public const string NEXUS_OCCLUSION_ON = "NEXUS_OCCLUSION_ON";

	public const string NEXUS_DYNAMIC_LIGHTS_ON = "NEXUS_DYNAMIC_LIGHTS_ON";

	public const string NEXUS_LIGHTMAP_ON = "NEXUS_LIGHTMAP_ON";

	public const string PORTAL_TRANSFORM_MATRIX_ON = "PORTAL_TRANSFORM_MATRIX_ON";

	public const string PORTAL_RENDER_MODE_ON = "PORTAL_RENDER_MODE_ON";

	public static readonly int _OcclusionTexture = Shader.PropertyToID("_OcclusionTexture");

	public static readonly int _IDMatrix = Shader.PropertyToID("_IDMatrix");

	public static readonly int _NXWorldSpaceHeadPos = Shader.PropertyToID("_NXWorldSpaceHeadPos");

	public static readonly int _NXNearFadeParams = Shader.PropertyToID("_NXNearFadeParams");

	public static readonly int nexus_StereoMatrixV = Shader.PropertyToID("nexus_StereoMatrixV");

	public static readonly int nexus_StereoWorldSpaceCameraPos = Shader.PropertyToID("nexus_StereoWorldSpaceCameraPos");

	public static readonly int nexus_MatrixV = Shader.PropertyToID("nexus_MatrixV");

	public static readonly int nexus_WorldSpaceCameraPos = Shader.PropertyToID("nexus_WorldSpaceCameraPos");

	public static readonly int nexus_MatrixPortal = Shader.PropertyToID("nexus_MatrixPortal");

	public static readonly int nexus_LightShadowBias = Shader.PropertyToID("nexus_LightShadowBias");

	public static readonly int nexus_WorldSpaceLightPos = Shader.PropertyToID("nexus_WorldSpaceLightPos");

	public static readonly int _PortalClipEnabled = Shader.PropertyToID("_PortalClipEnabled");

	public static readonly int _PortalPlanes = Shader.PropertyToID("_PortalPlanes");

	public static readonly int _LightIDToIDX = Shader.PropertyToID("_LightIDToIDX");

	public static readonly int globalLightColor = Shader.PropertyToID("globalLightColor");

	public static readonly int globalLightPos = Shader.PropertyToID("globalLightPos");

	public static readonly int globalLightSpotDir = Shader.PropertyToID("globalLightSpotDir");

	public static readonly int globalLightAtten = Shader.PropertyToID("globalLightAtten");

	public static readonly int globalShadowProps = Shader.PropertyToID("globalShadowProps");

	public static readonly int globalLightShadow = Shader.PropertyToID("globalLightShadow");

	public static readonly int globalWorldToShadow = Shader.PropertyToID("globalWorldToShadow");

	public static readonly int globalLightSettings = Shader.PropertyToID("globalLightSettings");

	public static readonly int _CULL_FRONT = Shader.PropertyToID("_CULL_FRONT");

	public static readonly int _CULL_BACK = Shader.PropertyToID("_CULL_BACK");

	public static readonly int _STENCIL_COMP = Shader.PropertyToID("_STENCIL_COMP");

	public static readonly int _STENCIL_REF = Shader.PropertyToID("_STENCIL_REF");

	public const string FOG_ON = "FOG_ON";

	public const string SUNLIGHT_ON = "SUNLIGHT_ON";

	public const string NEXUS_GREY_CONTRAST_EFFECT_ON = "NEXUS_GREY_CONTRAST_EFFECT_ON";

	public static readonly int _FogRange = Shader.PropertyToID("_FogRange");

	public static readonly int _FogStrength = Shader.PropertyToID("_FogStrength");

	public static readonly int _FogLookUp = Shader.PropertyToID("_FogLookUp");

	public static readonly int _FogSkyboxTex = Shader.PropertyToID("_FogSkyboxTex");

	public static readonly int _SkyboxTex = Shader.PropertyToID("_SkyboxTex");

	public static readonly int _SkyboxParams = Shader.PropertyToID("_SkyboxParams");

	public static readonly int _SkyboxFadeParams = Shader.PropertyToID("_SkyboxFadeParams");

	public static readonly int _LightmapStrength = Shader.PropertyToID("_LightmapStrength");

	public static readonly int _SceneCube = Shader.PropertyToID("_SceneCube");

	public static readonly int _SunDirection = Shader.PropertyToID("_SunDirection");

	public static readonly int _SunColor_Intensity = Shader.PropertyToID("_SunColor_Intensity");

	public static readonly int _AmbientColor_Intensity = Shader.PropertyToID("_AmbientColor_Intensity");

	public static readonly int _GreyContrastEffect = Shader.PropertyToID("_GreyContrastEffect");

	public static readonly int _MinMaxValue = Shader.PropertyToID("_MinMaxValue");

	public static readonly int _ZTEST = Shader.PropertyToID("_ZTEST");

	public static readonly int _COLORMASK = Shader.PropertyToID("_COLORMASK");

	public static readonly int _TintColor = Shader.PropertyToID("_TintColor");

	public static readonly int _Alpha = Shader.PropertyToID("_Alpha");

	public static readonly int _Color = Shader.PropertyToID("_Color");

	public static readonly int _Emissive = Shader.PropertyToID("_Emissive");

	public static readonly int _DitherAlphaValue = Shader.PropertyToID("_DitherAlphaValue");

	public static readonly int _FillAmount = Shader.PropertyToID("_FillAmount");

	public static readonly int _FadeAmount = Shader.PropertyToID("_FadeAmount");

	public static readonly int _EmissiveColor = Shader.PropertyToID("_EmissiveColor");

	public const string INVENTORY_EFFECT_ON = "INVENTORY_EFFECT_ON";

	public const string TRANSITION_EFFECT_ON = "TRANSITION_EFFECT_ON";

	public static readonly int _DeadZoneAlpha = Shader.PropertyToID("_DeadZoneAlpha");

	public static readonly int _MaxAngle = Shader.PropertyToID("_MaxAngle");

	public static readonly int _TransitionAmount = Shader.PropertyToID("_TransitionAmount");

	public static readonly int _VignetteSettings = Shader.PropertyToID("_VignetteSettings");

	public static readonly int _LookAtSettings = Shader.PropertyToID("_LookAtSettings");

	public static readonly int _DepthWrite = Shader.PropertyToID("_DepthWrite");

	public static readonly int _StartColor = Shader.PropertyToID("_StartColor");

	public static readonly int _EndColour = Shader.PropertyToID("_EndColour");

	public static readonly int _PositionArrayLength = Shader.PropertyToID("_PositionArrayLength");

	public static readonly int _PositionsArray = Shader.PropertyToID("_PositionsArray");

	public static readonly int _PortalScale = Shader.PropertyToID("_PortalScale");

	public static readonly int _Occludability = Shader.PropertyToID("_Occludability");

	public static readonly int _TextureLerp = Shader.PropertyToID("_TextureLerp");

	public static readonly int _CompletionTime = Shader.PropertyToID("_CompletionTime");
}
[CreateAssetMenu]
public class ShaderVariantStorage : ScriptableObject
{
	[Serializable]
	public struct ShaderVariants
	{
		public string name;

		public Shader shader;

		[FormerlySerializedAs("variants")]
		public string[] keywords;
	}

	public ShaderVariantCollection[] svcs;

	public ShaderVariants[] variants;

	public Mesh prewarmMesh;
}
public class SimpleAnimator : MonoBehaviour
{
	[Serializable]
	public struct TargetTransform
	{
		public Vector3 position;

		public Vector3 rotation;

		public float animTime;
	}

	public TargetTransform[] targetTransforms;

	private Vector3 orignalPosition;

	private Quaternion orignalRotation;

	private IHaglet animationRoutine;

	public void OnAwakeLR()
	{
		orignalPosition = base.transform.localPosition;
		orignalRotation = base.transform.localRotation;
		Haglet.Create(out animationRoutine, AnimationRoutine);
	}

	public void StartAnimating()
	{
		if (!animationRoutine.started)
		{
			animationRoutine.Start();
		}
	}

	public void StopAnimating()
	{
		if (animationRoutine.started)
		{
			animationRoutine.Stop();
			base.transform.localPosition = orignalPosition;
			base.transform.localRotation = orignalRotation;
		}
	}

	private IEnumerator<Routine.Yield> AnimationRoutine()
	{
		float timer = 0f;
		int index = 0;
		Vector3 currentPos = base.transform.localPosition;
		Quaternion currentRot = base.transform.localRotation;
		while (targetTransforms.Length != 0)
		{
			yield return Wait.For.LRUpdates(1);
			TargetTransform targetTransform = targetTransforms[index];
			timer += IC.DeltaTime;
			Vector3 position = targetTransform.position;
			Quaternion quaternion = Quaternion.Euler(targetTransform.rotation);
			if (targetTransform.animTime > 0f)
			{
				base.transform.localPosition = Vector3.Lerp(currentPos, position, timer / targetTransform.animTime);
				base.transform.localRotation = Quaternion.Lerp(currentRot, quaternion, timer / targetTransform.animTime);
				if (timer >= targetTransform.animTime)
				{
					timer = 0f;
					index = (index + 1) % targetTransforms.Length;
					currentPos = base.transform.localPosition;
					currentRot = base.transform.localRotation;
				}
			}
			else
			{
				base.transform.localPosition = position;
				base.transform.localRotation = quaternion;
				timer = 0f;
				index = (index + 1) % targetTransforms.Length;
				currentPos = base.transform.localPosition;
				currentRot = base.transform.localRotation;
			}
		}
	}
}
public abstract class Singleton<U> : MonoBehaviour, Serializer.ISelfComposer where U : Singleton<U>
{
	public static U Inst;

	protected virtual void Awake()
	{
		Inst = (U)this;
	}

	protected virtual void OnDestroy()
	{
		Inst = null;
	}

	public virtual void Decompose(Serializer.IMemberSink members)
	{
	}

	public virtual void Recompose(Serializer.IMemberSource members)
	{
		Inst = (U)this;
	}
}
public class SoundEvent : MonoBehaviour
{
	public FMODEventAsset Sound;

	public Transform SoundLocation;

	public bool FollowTransform = true;

	public string ParameterName;

	public float ParameterValue;

	private FMOD.Studio.EventInstance SoundInst;

	[Event(EventName = "Play Sound")]
	public void Play(object sender)
	{
		Transform transform = ((SoundLocation != null) ? SoundLocation : base.transform);
		if (FollowTransform)
		{
			SoundInst = FAC.Inst.PlayOneShot(Sound, transform);
		}
		else
		{
			SoundInst = FAC.Inst.PlayOneShot(Sound, transform.position);
		}
	}

	[Event(EventName = "Stop Sound")]
	public void Stop(object sender)
	{
		SoundInst.getPlaybackState(out var state);
		if (state == PLAYBACK_STATE.PLAYING)
		{
			SoundInst.stop(STOP_MODE.ALLOWFADEOUT);
		}
	}

	[Event(EventName = "Set Parameter")]
	public void SetParameter(object sender)
	{
		SoundInst.setParameterValue(ParameterName, ParameterValue);
	}
}
public class SplashScreen : RootBase
{
	public static SplashScreen Inst;

	public NexusRenderSettings renderPipelineAsset;

	[HideInInspector]
	public Camera Camera;

	private float alpha = 1f;

	private IHaglet awakeRoutine;

	private void Awake()
	{
		GraphicsSettings.renderPipelineAsset = renderPipelineAsset;
		LR.SetClockLevels(4, 5);
		Camera = GetComponentInChildren<Camera>();
		Inst = this;
		Haglet.Create(out awakeRoutine, AwakeRoutine, null, startNow: true);
	}

	private IEnumerator<Routine.Yield> AwakeRoutine()
	{
		yield return Wait.For.Seconds(0.1f);
		LoadingSphere loadingSphere = GetComponentInChildren<LoadingSphere>(includeInactive: true);
		loadingSphere.OnAwakeLR();
		while (alpha > 0f)
		{
			alpha = Mathf.Max(0f, alpha - 0.0021666668f);
			loadingSphere.UpdateAlpha(alpha);
			yield return Wait.For.Updates(1);
		}
		OVROverlayNexus.Inst.SetupColor(black: false);
		while (OVRPlugin.hmdPresent && (!OVRPlugin.hasInputFocus || !OVRPlugin.hasVrFocus))
		{
			yield return Wait.For.Updates(1);
		}
		yield return Wait.For.Seconds(0.1f);
		UnityEngine.AsyncOperation request = SceneManager.LoadSceneAsync("SC_LevelRoot", LoadSceneMode.Additive);
		yield return Wait.Until.True(() => request.isDone && alpha <= 0f);
		while (!(LoadingScreenController.Inst != null))
		{
			yield return Wait.For.Updates(1);
		}
		SceneManager.UnloadSceneAsync(base.gameObject.scene);
		LoadingScreenController.Inst.loadingCam.gameObject.SetActive(value: true);
	}
}
public class SquareEdgeParticles : MonoBehaviour
{
	public ParticleSystem m_northSystem;

	public ParticleSystem m_eastSystem;

	public ParticleSystem m_southSystem;

	public ParticleSystem m_westSystem;

	public float xSize = 1f;

	public float ySize = 1f;

	[ContextMenu("SetSize")]
	public void SetSize()
	{
		SetSize(xSize, ySize);
	}

	private void SetSize(float _xSize, float _ySize)
	{
		ParticleSystem.ShapeModule shape = m_northSystem.shape;
		m_northSystem.transform.localPosition = Vector3.forward * _ySize;
		shape.radius = _xSize;
		ParticleSystem.ShapeModule shape2 = m_southSystem.shape;
		m_southSystem.transform.localPosition = Vector3.forward * (0f - _ySize);
		shape2.radius = _xSize;
		ParticleSystem.ShapeModule shape3 = m_eastSystem.shape;
		m_eastSystem.transform.localPosition = Vector3.right * _xSize;
		shape3.radius = _ySize;
		ParticleSystem.ShapeModule shape4 = m_westSystem.shape;
		m_westSystem.transform.localPosition = Vector3.right * (0f - _xSize);
		shape4.radius = _ySize;
	}
}
public class STUB_DoNotUnloadMe : MonoBehaviour
{
}
public class Stub_HandPalm : MonoBehaviour
{
	private void OnDrawGizmos()
	{
		Gizmos.color = Color.red;
		Gizmos.DrawSphere(base.transform.position, 0.01f);
	}
}
public class SubtitleOutOfBoundsIcon : MonoBehaviour
{
	[HideInInspector]
	public SpriteRenderer sprite;

	[HideInInspector]
	public PortalRenderer portalRenderer;

	[HideInInspector]
	public Vector3 localScale;

	public void OnAwakeLR()
	{
		sprite = GetComponentInChildren<SpriteRenderer>(includeInactive: true);
		portalRenderer = GetComponentInChildren<PortalRenderer>(includeInactive: true);
		portalRenderer.OnAwakeLR();
		localScale = base.transform.localScale;
	}
}
[ExecuteInEditMode]
public class TintColorAdjust : MonoBehaviour
{
	public Color tintColorOverride = Color.white;

	private MaterialPropertyBlock objMPB;

	private MeshRenderer mr;

	public string shaderPropertyName = "_TintColor";

	private int _Color;

	public void Start()
	{
		objMPB = new MaterialPropertyBlock();
		mr = GetComponent<MeshRenderer>();
		_Color = Shader.PropertyToID(shaderPropertyName);
		objMPB.SetColor(_Color, tintColorOverride);
		mr.SetPropertyBlock(objMPB);
	}

	public void Update()
	{
		objMPB.SetColor(_Color, tintColorOverride);
		mr.SetPropertyBlock(objMPB);
	}

	public void OnValidate()
	{
		if (objMPB == null)
		{
			objMPB = new MaterialPropertyBlock();
		}
		if (mr == null)
		{
			mr = GetComponent<MeshRenderer>();
		}
		_Color = Shader.PropertyToID(shaderPropertyName);
		objMPB.SetColor(_Color, tintColorOverride);
		mr.SetPropertyBlock(objMPB);
	}
}
public class TitleCardController : MonoBehaviour
{
	private static TitleCardController _instance;

	public MeshRenderer titleCardMR;

	private Material titleCardMat;

	private IHaglet titleCardRoutine;

	private IHaglet routineTitleCardTracking;

	public static TitleCardController Inst => _instance;

	public void OnAwakeLR()
	{
		_instance = this;
		Haglet.Create(out titleCardRoutine, TitleCardRoutine);
		Haglet.Create(out routineTitleCardTracking, RoutineTitleCardTracking);
		titleCardMat = titleCardMR.sharedMaterial;
		MainCamera.Inst.SetTitleCard(titleCardMR);
	}

	public Wait PlayTitleCard()
	{
		return titleCardRoutine.Start();
	}

	private IEnumerator<Routine.Yield> TitleCardRoutine()
	{
		TutorialSettings cardSettings = BaseSettings<TutorialSettings>.Inst;
		yield return Wait.For.Seconds(cardSettings.titleCardPreFadeTime);
		Color titleCardCol = titleCardMat.color;
		MainCamera.Inst.titleCardActive = true;
		routineTitleCardTracking.Start();
		float titleTimer3 = 0f;
		while (titleTimer3 < cardSettings.titleCardFadeTime)
		{
			titleTimer3 += IC.DeltaTime;
			titleCardCol.a = titleTimer3 / cardSettings.titleCardFadeTime;
			titleCardMat.color = titleCardCol;
			yield return Wait.For.LRUpdates(1);
		}
		titleTimer3 = 0f;
		while (titleTimer3 < cardSettings.titleCardWhiteStayTime)
		{
			titleTimer3 += IC.DeltaTime;
			yield return Wait.For.LRUpdates(1);
		}
		titleTimer3 = cardSettings.titleCardFadeTime;
		while (titleTimer3 > 0f)
		{
			titleTimer3 -= IC.DeltaTime;
			titleCardCol.a = titleTimer3 / cardSettings.titleCardFadeTime;
			titleCardMat.color = titleCardCol;
			yield return Wait.For.LRUpdates(1);
		}
		routineTitleCardTracking.Stop();
		titleCardCol.a = 0f;
		titleCardMat.color = titleCardCol;
		MainCamera.Inst.titleCardActive = false;
		yield return Wait.For.Seconds(cardSettings.titleCardPostFadeTime);
	}

	private IEnumerator<Routine.Yield> RoutineTitleCardTracking()
	{
		Transform camTs = MainCamera.Inst.transform;
		Transform titleTs = titleCardMR.transform.parent;
		TutorialSettings cardSettings = BaseSettings<TutorialSettings>.Inst;
		Vector3 forward = camTs.forward;
		forward.y = 0f;
		forward.Normalize();
		titleTs.position = camTs.position + forward * cardSettings.titleCardDistance;
		titleTs.rotation = Quaternion.LookRotation(-forward, Vector3.up);
		while (true)
		{
			forward = camTs.forward;
			forward.y = 0f;
			forward.Normalize();
			float t = Mathf.Clamp01(Time.deltaTime * cardSettings.titleCardTrackingSpeed);
			Vector3 b = camTs.position + forward * cardSettings.titleCardDistance;
			b = Vector3.Lerp(titleTs.position, b, t);
			Quaternion b2 = Quaternion.LookRotation(-forward, Vector3.up);
			b2 = Quaternion.Lerp(titleTs.rotation, b2, t);
			titleTs.position = b;
			titleTs.rotation = b2;
			yield return Wait.For.LRUpdates(1);
		}
	}
}
public struct UICastHit
{
	public bool isCollidingWithWorld;

	public float validRayDistance;

	public int maskColliders;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
public struct UICast
{
	public static bool BoxCast(Vector3 rayPos, Vector3 rayExtents, Vector3 rayDir, out RaycastHit hit, Quaternion rayRot, float rayDist, int layerMask)
	{
		if (Physics.BoxCast(rayPos, rayExtents, rayDir, out hit, rayRot, rayDist, layerMask))
		{
			return true;
		}
		return false;
	}

	public static UICastHit Cast(Vector3 rayPosWS, Quaternion rayRotWS, Vector2 rayHalfExtents, float rayDistance, bool castAgainstColliders, bool allowPortalTraversal)
	{
		UICastHit result = default(UICastHit);
		result.maskColliders = 65537;
		Vector3 vector = rayRotWS * Vector3.forward;
		int num = result.maskColliders;
		if (allowPortalTraversal)
		{
			num |= 0x400;
		}
		bool flag = false;
		result.validRayDistance = rayDistance;
		if (castAgainstColliders)
		{
			Vector3 vector2 = vector;
			Vector3 rayExtents = new Vector3(rayHalfExtents.x, rayHalfExtents.y, 0f);
			if (BoxCast(rayPosWS, rayExtents, vector2, out var hit, rayRotWS, rayDistance, num))
			{
				if (hit.collider.gameObject.layer == 10)
				{
					Portal component = hit.collider.gameObject.GetComponent<Portal>();
					if ((bool)component.Link && UIPortalable.IsPortalValidToTeleportThrough(component))
					{
						Vector3 localPosition = component.transform.InverseTransformPoint(hit.point);
						if (component.IsLocalPointInside2DPortalShape(localPosition))
						{
							Vector3 worldPos = rayPosWS + vector2 * (hit.distance + 0.01f);
							Portal.PortalTransform portalTransform = component.CalculatePortalObjectTransform(worldPos, rayRotWS, vector2);
							worldPos = portalTransform.position;
							Quaternion rotation = portalTransform.rotation;
							Vector3 direction = portalTransform.direction;
							float distance = hit.distance;
							float rayDist = rayDistance - distance;
							if (BoxCast(worldPos, rayExtents, direction, out var hit2, rotation, rayDist, result.maskColliders))
							{
								result.validRayDistance = hit2.distance + distance - 0.1f;
								flag = true;
							}
						}
					}
					else
					{
						result.validRayDistance = hit.distance - 0.1f;
						flag = true;
					}
				}
				else if (!hit.collider.GetComponent<UICastIgnoreCollision>())
				{
					result.validRayDistance = hit.distance - 0.1f;
					flag = true;
				}
			}
		}
		if (castAgainstColliders)
		{
			float num2 = float.MaxValue;
			Portal portal = null;
			if (flag)
			{
				if (Physics.Raycast(rayPosWS, vector, out var hitInfo, rayDistance, num, QueryTriggerInteraction.Ignore))
				{
					if (hitInfo.collider.gameObject.layer != 10)
					{
						if (!hitInfo.collider.GetComponent<UICastIgnoreCollision>())
						{
							flag = false;
							result.isCollidingWithWorld = true;
						}
					}
					else
					{
						Portal component2 = hitInfo.collider.gameObject.GetComponent<Portal>();
						if ((bool)component2.Link && UIPortalable.IsPortalValidToTeleportThrough(component2))
						{
							Vector3 localPosition2 = component2.transform.InverseTransformPoint(hitInfo.point);
							if (component2.IsLocalPointInside2DPortalShape(localPosition2))
							{
								num2 = hitInfo.distance;
								portal = component2;
							}
						}
					}
				}
			}
			if (flag)
			{
				float fieldOfView = MainCamera.Inst.cameraComp.fieldOfView;
				Vector3 vector3 = new Vector3(rayHalfExtents.x, rayHalfExtents.y, 0f);
				float num3 = 2f * rayDistance * Mathf.Tan(fieldOfView * 0.5f * ((float)Math.PI / 180f));
				int num4 = 5;
				for (int i = 1; i < num4; i++)
				{
					float num5 = rayDistance / (float)num4;
					if (result.isCollidingWithWorld)
					{
						break;
					}
					float num6 = (float)i * num5;
					float num7 = 2f * num6 * Mathf.Tan(fieldOfView * 0.5f * ((float)Math.PI / 180f));
					Vector3 rayExtents2 = vector3 * (num7 / num3);
					Vector3 vector4 = rayPosWS + vector * num6;
					Quaternion quaternion = rayRotWS;
					Vector3 vector5 = vector;
					float rayDist2 = rayDistance - num6;
					if (!(num6 > num2 - 0.2f) || !(num6 <= num2 + 0.2f))
					{
						if (num6 > num2 + 0.2f && (bool)portal)
						{
							Portal.PortalTransform portalTransform2 = portal.CalculatePortalObjectTransform(vector4, quaternion, vector5);
							vector4 = portalTransform2.position;
							quaternion = portalTransform2.rotation;
							vector5 = portalTransform2.direction;
						}
						if (BoxCast(vector4, rayExtents2, vector5, out var _, quaternion, rayDist2, result.maskColliders))
						{
							result.isCollidingWithWorld = true;
						}
					}
				}
			}
		}
		if (!result.isCollidingWithWorld)
		{
			result.validRayDistance = rayDistance;
		}
		return result;
	}
}
public class UICastIgnoreCollision : MonoBehaviour
{
}
public class VectorAnimator
{
	[NonSerialized]
	[HideInInspector]
	public Vector3 CurrentValue;

	[NonSerialized]
	[HideInInspector]
	public Vector3 CurrentTarget;

	private HagletValue<bool> isFading;

	private IHaglet<Vector3, Vector3, float> floatRoutine;

	public Wait IsFading => Wait.Until.False(isFading, 1, allowPreMetNow: true);

	public VectorAnimator()
	{
		Haglet.Create(out floatRoutine, (Routine.Func3<Vector3, Vector3, float>)FloatRoutine, (string)null, startNow: false, (int?)null, (string)null);
		HagletValue.Create(out isFading, null, initVal: false, null, 8);
	}

	private IEnumerator<Routine.Yield> FloatRoutine(Vector3 start, Vector3 target, float time)
	{
		CurrentTarget = target;
		float t = 0f;
		while (t < time)
		{
			float t2 = t / time;
			Vector3 currentValue = Vector3.LerpUnclamped(start, target, t2);
			CurrentValue = currentValue;
			t += IC.DeltaTime;
			yield return Wait.For.LRUpdates(1);
		}
		CurrentValue = target;
		isFading.value = false;
	}

	public Wait AnimateTo(Vector3 target, float time, bool onlyResetIfNewTarget = false)
	{
		if (onlyResetIfNewTarget && target == CurrentTarget)
		{
			return IsFading;
		}
		if (time <= 0f)
		{
			CurrentValue = target;
			CurrentTarget = target;
			return IsFading;
		}
		isFading.value = true;
		floatRoutine.Start(CurrentValue, target, time, resetIfStarted: true);
		return IsFading;
	}

	public Wait AnimateTo(Vector3 start, Vector3 target, float time)
	{
		if (time <= 0f)
		{
			CurrentValue = target;
			CurrentTarget = target;
			return IsFading;
		}
		isFading.value = true;
		floatRoutine.Start(start, target, time, resetIfStarted: true);
		return IsFading;
	}
}
public class OutOfBoundsIndicator : MonoBehaviour
{
	[ReadOnly]
	public MeshRenderer textMR;

	[ReadOnly]
	public MeshRenderer arrowMR;

	[ReadOnly]
	public MeshRenderer pointMR;

	public TextMesh returnText;

	public Transform arrowTS;

	[HideInInspector]
	public Transform textTS;

	public Transform pointTS;

	private float arrowBobTime;

	[HideInInspector]
	public bool shouldDraw;

	public void OnAwakeLR()
	{
		textMR = returnText.GetComponent<MeshRenderer>();
		textTS = returnText.transform;
		arrowMR = arrowTS.GetComponent<MeshRenderer>();
		pointMR = pointTS.GetComponent<MeshRenderer>();
		SetTextColor(0f);
	}

	public void UpdateOOB(Vector3 newPosWSText, Vector3 newPosWSArrow, Vector3 newPosWSPoint, Quaternion newRotText, Quaternion newRotArrow, Quaternion newRotPoint, float textAlpha, float newArrowBobTime, bool showOutOfBoundsIndicator)
	{
		textMR.enabled = showOutOfBoundsIndicator;
		arrowMR.enabled = showOutOfBoundsIndicator;
		pointMR.enabled = showOutOfBoundsIndicator;
		textTS.position = newPosWSText;
		textTS.rotation = newRotText;
		arrowTS.position = newPosWSArrow;
		arrowTS.rotation = newRotArrow;
		pointTS.position = newPosWSPoint;
		pointTS.rotation = newRotPoint;
		SetTextColor(textAlpha);
		arrowBobTime = newArrowBobTime;
	}

	public void SetTextColor(float alphaVal)
	{
		Color color = returnText.color;
		color.a = alphaVal;
		returnText.color = color;
	}
}
public class OutOfBoundsSystem
{
	public struct PositionData
	{
		public bool isValid;

		public bool requiredRepositionToInnerBorder;

		public bool requiredRepositionToOuterBorder;

		public Region region;

		public Region regionStoodOver;

		public Vector3 worldPos;

		public Vector3 constrainedWorldPos;
	}

	public struct CollisionData
	{
		public bool isOutOfBounds;

		public float raycastHitDistance;

		public float objectDistance;
	}

	private static Region[] connectedRegions = new Region[64];

	public static void TestOutOfBoundsPositions(MRBase owner, Vector3 gravityDir, Vector3 eyeLPos, Vector3 eyeRPos, PositionData lastValidEyeLPosData, PositionData lastValidEyeRPosData, out PositionData eyeLResult, out PositionData eyeRResult)
	{
		eyeLResult = TestOutOfBoundsPosition(owner, eyeLPos, gravityDir, lastValidEyeLPosData);
		eyeRResult = TestOutOfBoundsPosition(owner, eyeRPos, gravityDir, lastValidEyeRPosData);
		CC.Inst.teleporter.eGrillTeleportedThrough = null;
		CC.Inst.teleporter.portalTeleportedThrough = null;
	}

	public static PositionData TestOutOfBoundsPosition(MRBase owner, Vector3 targetWorldPosition, Vector3 gravityDir, PositionData lastValidPositionData)
	{
		float freeMoveStepHeight = BaseSettings<TeleportSettings>.Inst.freeMoveStepHeight;
		float maxHeightToRegionSnap = Mathf.Abs(IC.GetHeadLocalPosition().y) + freeMoveStepHeight;
		float maxXZDistanceToRegionSnap = BaseSettings<TeleportSettings>.Inst.maxXZDistanceToRegionSnap;
		PositionData result = default(PositionData);
		result.requiredRepositionToInnerBorder = true;
		result.requiredRepositionToOuterBorder = true;
		result.worldPos = targetWorldPosition;
		if (lastValidPositionData.region != null && !lastValidPositionData.region.IsEnabled)
		{
			lastValidPositionData.region = null;
		}
		Portal portalOut = CC.Inst.teleporter.portalTeleportedThrough?.Link;
		if (!portalOut)
		{
			Portal.RaycastPortal(targetWorldPosition, lastValidPositionData.worldPos, out portalOut);
		}
		Vector3 up = -gravityDir;
		Region region = lastValidPositionData.region;
		try
		{
			int num = ((!(region != null) || region.Equals(null)) ? Region.GetEnabledRegions(owner.regions, connectedRegions) : Region.GetRegionsConnectedTo(region, connectedRegions, portalOut, null, teleporting: false));
			float num2 = float.MaxValue;
			for (int i = 0; i < num; i++)
			{
				Region region2 = connectedRegions[i];
				if (!region2.IsAlignedToUpDirection(up))
				{
					continue;
				}
				Region.ValidPos validPos = region2.FindNearestValidPoint(targetWorldPosition, useMaximumConstraints: true, allowOutOfRegionEdgeSnapping: false, freeMoveStepHeight, maxHeightToRegionSnap, maxXZDistanceToRegionSnap, maintainsLocalYOffset: true);
				if (!validPos.valid || (!result.requiredRepositionToOuterBorder && validPos.requiredRepositionToOuterBorder) || (!result.requiredRepositionToInnerBorder && validPos.requiredRepositionToInnerBorder))
				{
					continue;
				}
				if (result.requiredRepositionToInnerBorder && validPos.requiredRepositionToInnerBorder)
				{
					float sqrMagnitude = (validPos.worldPos - targetWorldPosition).sqrMagnitude;
					if (sqrMagnitude > num2)
					{
						continue;
					}
					num2 = sqrMagnitude;
				}
				result.isValid = validPos.valid;
				result.region = region2;
				result.requiredRepositionToInnerBorder = validPos.requiredRepositionToInnerBorder;
				result.requiredRepositionToOuterBorder = validPos.requiredRepositionToOuterBorder;
				result.constrainedWorldPos = validPos.worldPos;
				if (!result.requiredRepositionToInnerBorder)
				{
					break;
				}
			}
		}
		finally
		{
			Array.Clear(connectedRegions, 0, connectedRegions.Length);
		}
		if (result.isValid && !result.requiredRepositionToOuterBorder)
		{
			result.regionStoodOver = result.region;
		}
		else
		{
			Region[] regions = owner.regions;
			foreach (Region region3 in regions)
			{
				if (region3.IsAlignedToUpDirection(up))
				{
					Region.ValidPos validPos2 = region3.FindNearestValidPoint(targetWorldPosition, useMaximumConstraints: true, allowOutOfRegionEdgeSnapping: false, freeMoveStepHeight, maxHeightToRegionSnap, maxXZDistanceToRegionSnap, maintainsLocalYOffset: true);
					if (validPos2.valid && !validPos2.requiredRepositionToInnerBorder)
					{
						result.regionStoodOver = validPos2.region;
						break;
					}
				}
			}
		}
		return result;
	}

	public static CollisionData TestOutOfBoundsCollision(PositionData currentPositionData, PositionData lastValidPositionData)
	{
		CollisionData result = default(CollisionData);
		if (lastValidPositionData.isValid)
		{
			Vector3 constrainedWorldPos = lastValidPositionData.constrainedWorldPos;
			Vector3 worldPos = currentPositionData.worldPos;
			Vector3 vector = worldPos - constrainedWorldPos;
			Vector3 normalized = vector.normalized;
			float magnitude = vector.magnitude;
			UnityEngine.Debug.DrawLine(constrainedWorldPos, worldPos, Color.magenta);
			int num = ~(0x21D00 | 0x100000);
			num |= 0x10000;
			float num2 = magnitude + 0.5f;
			Vector3 vector2 = constrainedWorldPos + normalized * num2;
			float num3 = float.MaxValue;
			if (!LR.Inst.IsPaused)
			{
				Vector3 hitPointLocal = default(Vector3);
				Vector3 vector3 = constrainedWorldPos;
				Vector3 endPoint = vector2;
				Portal portalOut;
				bool flag = Portal.RaycastPortal(constrainedWorldPos, vector2, out portalOut);
				if (!flag)
				{
					vector3 = MainCamera.Inst.transform.position;
					endPoint = constrainedWorldPos;
					flag = Portal.RaycastPortal(vector3, endPoint, out portalOut);
				}
				if (flag)
				{
					portalOut.RaycastPortalPlane(vector3, endPoint, out hitPointLocal);
					Vector3 b = portalOut.transform.TransformPoint(hitPointLocal);
					num3 = Vector3.Distance(vector3, b);
				}
			}
			if (Physics.Raycast(new Ray(constrainedWorldPos, normalized), out var hitInfo, num2, num) && num3 - hitInfo.distance > 0.025f)
			{
				result.isOutOfBounds = true;
				result.raycastHitDistance = hitInfo.distance;
				result.objectDistance = magnitude;
			}
		}
		return result;
	}
}
public class PlayerFreeMove
{
	[NonSerialized]
	[HideInInspector]
	public bool HasRotated;

	private bool waitForInputResetL;

	private bool waitForInputResetR;

	[NonSerialized]
	[HideInInspector]
	public bool HasMoved;

	public static StackedBool FreeMoveEnabled;

	public static StackedBool FreeTurnEnabled;

	public void OnAwakeLR()
	{
		FreeMoveEnabled.Reset();
		FreeTurnEnabled.Reset();
	}

	public bool OnUpdateMovement(Hand hand, bool justProcessInput)
	{
		Vector2 vector = IC.GetInputForHand(hand.ICHand).GetAxis();
		bool flag = vector.magnitude > 0.15f;
		HasMoved = false;
		if (!CanProcessInput(flag, hand))
		{
			return false;
		}
		if (!flag)
		{
			return false;
		}
		if (justProcessInput)
		{
			return false;
		}
		TeleportSettings inst = BaseSettings<TeleportSettings>.Inst;
		Quaternion quaternion = Quaternion.Euler(new Vector3(0f, (Quaternion.Inverse(CC.Inst.transform.rotation) * IC.GetHeadRotation()).eulerAngles.y, 0f));
		float realDeltaTime = IC.RealDeltaTime;
		float num = Mathf.Clamp01(Mathf.Abs(vector.x) + Mathf.Abs(vector.y));
		Vector3 vector2 = new Vector3(0f, num);
		Vector3 vector3 = new Vector3(0f, 0f - num);
		if (Vector3.Angle(vector2, vector) < inst.freeMoveDeadZone)
		{
			vector = vector2;
		}
		else if (Vector3.Angle(vector3, vector) < inst.freeMoveDeadZone)
		{
			vector = vector3;
		}
		Vector3 worldFloorPosition = CC.Inst.GetWorldFloorPosition(NexusFullScreenPass.Inst.isFadeActive ? CC.Inst.LastHeadPos.constrainedWorldPos : IC.GetHeadPosition());
		Quaternion quaternion2 = ((LR.Inst.saveDataSettings.directionPreset == TeleportSettings.DirectionMode.HeadRelative) ? CC.Inst.transform.rotation : hand.transform.rotation);
		MRBase targetOwner = ((LR.Inst.saveDataSettings.directionPreset == TeleportSettings.DirectionMode.HeadRelative) ? MainCamera.Inst.GetOwner() : hand.GetOwner());
		Vector3 vector4 = worldFloorPosition + quaternion2 * quaternion * vector.xNy() * inst.FreeMoveSpeed * realDeltaTime;
		Region.ValidPos nearestTelepadRegion = CC.Inst.GetNearestTelepadRegion(targetOwner, vector4);
		Stairway.ValidPos nearestStairway = CC.Inst.GetNearestStairway(targetOwner, vector4);
		if (nearestStairway.valid && nearestTelepadRegion.valid)
		{
			float num2 = Vector3.Distance(vector4, nearestStairway.worldPos);
			float num3 = Vector3.Distance(vector4, nearestTelepadRegion.worldPos);
			Vector3 headWorldPos = ((num2 < num3) ? nearestStairway.worldPos : nearestTelepadRegion.worldPos);
			bool flag2 = nearestTelepadRegion.requiredRepositionToInnerBorder || nearestTelepadRegion.requiredRepositionToOuterBorder;
			if (!nearestStairway.requiredEdgeRepositioning && !flag2)
			{
				return MovePlayer(headWorldPos, quaternion2);
			}
			if (!nearestStairway.requiredEdgeRepositioning)
			{
				return MovePlayer(nearestStairway.worldPos, quaternion2);
			}
			if (!flag2)
			{
				return MovePlayer(nearestTelepadRegion.worldPos, quaternion2);
			}
			return MovePlayer(headWorldPos, quaternion2);
		}
		if (nearestTelepadRegion.valid)
		{
			return MovePlayer(nearestTelepadRegion.worldPos, quaternion2);
		}
		if (nearestStairway.valid)
		{
			return MovePlayer(nearestStairway.worldPos, quaternion2);
		}
		return false;
	}

	private bool MovePlayer(Vector3 headWorldPos, Quaternion worldRot)
	{
		CC inst = CC.Inst;
		Vector3 constrainedWorldPos = inst.LastHeadPos.constrainedWorldPos;
		Vector3 worldFloorPosition = inst.GetWorldFloorPosition(constrainedWorldPos);
		if (NexusFullScreenPass.Inst.isFadeActive)
		{
			Vector3 normalized = (inst.GetWorldFloorPosition(IC.GetHeadPosition()) - worldFloorPosition).normalized;
			Vector3 normalized2 = (headWorldPos - worldFloorPosition).normalized;
			if ((double)Vector3.Dot(normalized, normalized2) > -0.707)
			{
				return HasMoved = false;
			}
		}
		Vector3 worldPos = CC.Inst.CalculateCCPosFromHeadPos(headWorldPos, checkOOB: true);
		inst.PositionReplace(worldPos, worldRot, default(CC.TeleportInfo), fadeCamera: false, forceUpdateLastState: false, MovementType: false, CC.MovementType.FreeMove);
		return HasMoved = true;
	}

	public bool OnUpdateRotation(Hand hand, bool justProcessInput)
	{
		Vector2 axis = IC.GetInputForHand(hand.ICHand).GetAxis();
		bool inputDirectionHeld = axis.magnitude > 0.2f;
		if (!CanProcessInput(inputDirectionHeld, hand))
		{
			return false;
		}
		if (justProcessInput)
		{
			return false;
		}
		Quaternion rotation = CC.Inst.transform.rotation;
		float angle = 0f;
		bool flag = false;
		if (Mathf.Abs(axis.x) > 0.5f)
		{
			bool flag2 = LR.Inst.saveDataSettings.freeMoveTurnType == TeleportSettings.FreeMoveRotateSetting.Snap;
			if (!HasRotated && flag2)
			{
				HasRotated = true;
				flag = true;
				float num = Mathf.Sign(axis.x);
				angle = BaseSettings<TeleportSettings>.Inst.TurnAmountSnap * num;
				rotation *= Quaternion.Euler(0f, BaseSettings<TeleportSettings>.Inst.TurnAmountSnap * num, 0f);
			}
			else if (!flag2)
			{
				flag = true;
				float num2 = Mathf.Sign(axis.x);
				float num3 = BaseSettings<TeleportSettings>.Inst.TurnAmountSmooth * IC.DeltaTime;
				angle = num3 * num2;
				rotation *= Quaternion.Euler(0f, num3 * num2, 0f);
			}
		}
		else
		{
			HasRotated = false;
		}
		Vector3 position = CC.Inst.transform.position;
		if (flag)
		{
			position = Vector3X.RotatePointAroundPivot(position, IC.GetHeadPosition(), angle, CC.Inst.transform.up);
			CC.Inst.PositionReplace(position, rotation, default(CC.TeleportInfo), fadeCamera: false, forceUpdateLastState: false, MovementType: false, CC.MovementType.FreeMove);
			return true;
		}
		return false;
	}

	public void UpdateTeleported(bool haveTeleportedL, bool haveTeleportedR)
	{
		if (haveTeleportedL)
		{
			waitForInputResetL = true;
		}
		if (haveTeleportedR)
		{
			waitForInputResetR = true;
		}
	}

	private bool CanProcessInput(bool inputDirectionHeld, Hand hand)
	{
		if (hand.ICHand == IC.Hand.Left)
		{
			if (waitForInputResetL)
			{
				if (!inputDirectionHeld)
				{
					waitForInputResetL = false;
				}
				return false;
			}
			return true;
		}
		if (waitForInputResetR)
		{
			if (!inputDirectionHeld)
			{
				waitForInputResetR = false;
			}
			return false;
		}
		return true;
	}
}
[Serializable]
public class PlayerTeleport
{
	private struct Edge
	{
		public int i0;

		public int i1;
	}

	private struct TeleportArc
	{
		public MeshRenderer mr;

		public MeshFilter mf;

		public Mesh mesh;

		public Vector3[] vertices;

		public Quaternion[] verticesRotation;

		public Vector3[] baseMeshVerts;

		public int baseMeshVertCount;

		public Vector3[] normals;

		public Vector2[] uvs;

		public int[] indices;

		public Edge[] edges;

		public TeleportUIHelper UITools;

		public bool showing;

		public bool invalid;

		public float intersectionTime;

		public float length;

		public int vertexPairNum;

		public int vertexIdxCrossingPortal;
	}

	private struct CastArcResult
	{
		public bool hit;

		public Ray lastRayInArc;

		public float lastDistInArc;

		public Portal portalIntersected;

		public EGrill eGrillIntersected;

		public bool wasEGrillEncounterBeforePortal;

		public Vector3 hitWorldPoint;

		public Vector3 hitWorldNormal;

		public CutsceneCollider cutsceneCollider;
	}

	private struct ArcMarker
	{
		public Vector3 worldPosStart;

		public Vector3 worldPosEndPrev;

		public Vector3 worldPosEnd;

		public Vector3 worldVelStart;

		public Vector3 worldVelEnd;

		public Vector3 worldGravity;

		public Quaternion worldRotStart;

		public float timeElapsed;
	}

	private struct RegionResult
	{
		public Region region;

		public Region.ValidPos validPos;
	}

	[HideInInspector]
	public TelepadArrow telepadArrow;

	[HideInInspector]
	public TeleportCross teleportCross;

	private bool showingTeleportArrow;

	private bool showingTeleportCross;

	private Vector2 lastGoodAnalogDirection;

	private static Region[] connectedRegions = new Region[64];

	private static Region[] enabledRegions = new Region[64];

	public static StackedBool TeleportEnabled;

	public static bool TeleportHasStartedThisFrame;

	public Portal portalTeleportedThrough;

	public EGrill eGrillTeleportedThrough;

	private TeleportArc arc;

	private Hand arcHand;

	private Hand rotationHand;

	public void OnAwakeLR()
	{
		TeleportEnabled.Reset();
		if (!TeleportSettings.teleportUIMaterial)
		{
			TeleportSettings.teleportUIMaterial = new Material(Shader.Find("NEXUS/Color"));
		}
		if (!BaseSettings<TeleportSettings>.Inst.arcMaterial)
		{
			BaseSettings<TeleportSettings>.Inst.arcMaterial = new Material(Shader.Find("NEXUS/Color"));
		}
		telepadArrow = LR.Inst.GetComponentInChildren<TelepadArrow>(includeInactive: true);
		telepadArrow.OnAwakeLR();
		teleportCross = LR.Inst.GetComponentInChildren<TeleportCross>(includeInactive: true);
		teleportCross.OnAwakeLR();
		GameObject gameObject = new GameObject("TeleportArc");
		gameObject.transform.SetParent(CC.Inst.transform, worldPositionStays: false);
		arc.mr = gameObject.AddComponent<MeshRenderer>();
		arc.mr.receiveShadows = false;
		arc.mr.shadowCastingMode = ShadowCastingMode.Off;
		arc.mr.motionVectorGenerationMode = MotionVectorGenerationMode.ForceNoMotion;
		arc.mr.lightProbeUsage = LightProbeUsage.Off;
		arc.mr.sharedMaterial = BaseSettings<TeleportSettings>.Inst.arcMaterial;
		arc.mr.renderingLayerMask = uint.MaxValue;
		arc.mesh = new Mesh();
		arc.baseMeshVerts = CreateBaseShape();
		arc.baseMeshVertCount = arc.baseMeshVerts.Length;
		int arcNumSegments = BaseSettings<TeleportSettings>.Inst.arcNumSegments;
		arc.vertices = new Vector3[arcNumSegments * arc.baseMeshVertCount];
		arc.verticesRotation = new Quaternion[arcNumSegments];
		arc.normals = new Vector3[arcNumSegments * arc.baseMeshVertCount];
		arc.uvs = new Vector2[arcNumSegments * arc.baseMeshVertCount];
		int num = (arc.vertices.Length / 2 - 1) * 6;
		arc.indices = new int[num * 2];
		arc.mf = gameObject.AddComponent<MeshFilter>();
		arc.mf.sharedMesh = arc.mesh;
		arc.UITools = new TeleportUIHelper(arc.mr, BaseSettings<TeleportSettings>.Inst.arcStartColor);
		arc.mesh.vertices = arc.vertices;
	}

	public static void AddActiveRegionsToRegionArray(ConstArray<Region> localRegions, Region[] allRegions)
	{
		foreach (Region region in allRegions)
		{
			if (region.IsEnabled)
			{
				localRegions.Add(region);
			}
		}
	}

	public static void UpdateStairwayArrayWithActiveStairways(ConstArray<Stairway> localStairways, Stairway[] allStairways)
	{
		localStairways.Clear();
		foreach (Stairway stairway in allStairways)
		{
			if (stairway.isActiveAndEnabled)
			{
				localStairways.Add(stairway);
			}
		}
	}

	private Vector3[] CreateBaseShape()
	{
		int baseShapeSides = BaseSettings<TeleportSettings>.Inst.baseShapeSides;
		Vector3[] array = new Vector3[baseShapeSides + 1];
		int num = 360 / baseShapeSides;
		for (int i = 0; i < baseShapeSides; i++)
		{
			float x = Mathf.Cos((float)(i * num) * (float)Math.PI / 180f);
			float y = Mathf.Sin((float)(i * num) * (float)Math.PI / 180f);
			array[i] = new Vector3(x, y, 0f);
		}
		array[baseShapeSides] = array[0];
		arc.edges = new Edge[baseShapeSides];
		for (int j = 0; j < baseShapeSides; j++)
		{
			Edge edge = default(Edge);
			edge.i0 = j;
			edge.i1 = j + 1;
			arc.edges[j] = edge;
		}
		return array;
	}

	private void ArcMarkerStep(ref ArcMarker current, float dt)
	{
		current.worldPosEndPrev = current.worldPosEnd;
		Vector3 worldGravity = current.worldGravity;
		current.worldVelEnd += worldGravity * dt;
		current.worldPosEnd += current.worldVelEnd * dt;
	}

	private void CreateVertAndIndices(Vector3 markerPos, Quaternion markerRot, float distance, ref int vertIndex, ref int indicesIdx, bool isStartPair)
	{
		markerPos = CC.Inst.transform.InverseTransformPoint(markerPos);
		markerRot = Quaternion.Inverse(CC.Inst.transform.rotation) * markerRot;
		for (int i = 0; i < arc.baseMeshVertCount; i++)
		{
			int num = vertIndex + i;
			Vector3 normalized = (markerRot * arc.baseMeshVerts[i]).normalized;
			arc.normals[num] = normalized;
			arc.vertices[num] = markerPos;
			arc.uvs[num] = new Vector2((float)i / (float)(arc.baseMeshVertCount - 1), arc.length);
		}
		arc.verticesRotation[vertIndex / arc.baseMeshVertCount] = markerRot;
		arc.length += distance;
		if (!isStartPair)
		{
			int num2 = vertIndex - arc.baseMeshVertCount;
			Edge[] edges = arc.edges;
			for (int j = 0; j < edges.Length; j++)
			{
				Edge edge = edges[j];
				arc.indices[indicesIdx++] = edge.i0 + vertIndex;
				arc.indices[indicesIdx++] = edge.i0 + num2;
				arc.indices[indicesIdx++] = edge.i1 + num2;
				arc.indices[indicesIdx++] = edge.i0 + vertIndex;
				arc.indices[indicesIdx++] = edge.i1 + num2;
				arc.indices[indicesIdx++] = edge.i1 + vertIndex;
			}
		}
		vertIndex += arc.baseMeshVertCount;
	}

	private CastArcResult CastArc(Hand hand)
	{
		CastArcResult result = default(CastArcResult);
		if ((bool)hand.portalFromHeadToHand && hand.portalFromHeadToHand.IsHoldable)
		{
			return result;
		}
		TeleportSettings inst = BaseSettings<TeleportSettings>.Inst;
		Transform transform = hand.transform;
		Vector3 position = transform.position;
		_ = transform.rotation;
		Vector3 gravity = hand.gravity;
		int arcNumSegments = inst.arcNumSegments;
		float num = inst.arcTime / (float)arcNumSegments;
		arc.vertexPairNum = 0;
		arc.length = 0f;
		arc.vertexIdxCrossingPortal = -1;
		ArcMarker current = default(ArcMarker);
		current.worldPosStart = position;
		current.worldPosEnd = current.worldPosStart;
		current.worldRotStart = CalculateMarkerRotation(gravity, transform.forward, transform.forward);
		current.worldGravity = gravity * inst.arcGravitySpeed;
		float num2 = Vector3.Dot(hand.transform.forward, -gravity);
		float num3 = ((num2 >= inst.arcMaxDotAngle) ? inst.arcSpeedDropOffCurve.Evaluate(num2) : 1f);
		current.worldVelStart = current.worldRotStart * Vector3.forward * (inst.arcStartSpeed * num3);
		current.worldVelEnd = current.worldVelStart;
		UnityEngine.Debug.DrawRay(position, transform.forward, Color.cyan);
		Array.Clear(arc.indices, 0, arc.indices.Length);
		int indicesIdx = 0;
		MRBase owner = hand.owner;
		bool isStartPair = true;
		Vector3 vector = gravity;
		for (int i = 0; i < arcNumSegments; i++)
		{
			float num4 = inst.arcGravitySpeed * inst.arcGravityCurve.Evaluate((float)i / (float)arcNumSegments);
			current.worldGravity = vector * num4;
			ArcMarkerStep(ref current, num);
			Vector3 worldPosEndPrev = current.worldPosEndPrev;
			Vector3 vector2 = current.worldPosEnd - current.worldPosEndPrev;
			Ray ray = (result.lastRayInArc = new Ray(worldPosEndPrev, vector2.normalized));
			float num5 = 0.1f;
			float num6 = (result.lastDistInArc = vector2.magnitude + num5);
			if (EGrill.RaycastGetClosest(owner, ray, num6, out var _, out var grillFound))
			{
				result.wasEGrillEncounterBeforePortal = !result.portalIntersected;
				result.eGrillIntersected = grillFound;
			}
			QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.Ignore;
			int layerMask = 1281;
			if (Physics.Raycast(ray, out var hitInfo, num6, layerMask, queryTriggerInteraction))
			{
				current.worldPosEnd = ray.origin + ray.direction * hitInfo.distance;
				float num7 = hitInfo.distance / current.worldVelEnd.magnitude;
				current.timeElapsed += num7;
				if (hitInfo.collider.gameObject.layer != 10)
				{
					result.hit = true;
					CutsceneCollider component = hitInfo.collider.gameObject.GetComponent<CutsceneCollider>();
					if ((bool)component)
					{
						result.cutsceneCollider = component;
						result.hitWorldPoint = component.telepoint.transform.position;
						result.hitWorldNormal = component.telepoint.transform.up;
					}
					else
					{
						result.hitWorldPoint = hitInfo.point;
						result.hitWorldNormal = hitInfo.normal;
					}
					Vector3 normalized = (current.worldPosEnd - current.worldPosEndPrev).normalized;
					Portal portalIntersected = result.portalIntersected;
					if ((object)portalIntersected == null)
					{
						_ = transform.forward;
					}
					else
					{
						_ = portalIntersected.transform.forward;
					}
					Quaternion markerRot = CalculateMarkerRotation(current.worldGravity, normalized, transform.forward);
					CreateVertAndIndices(current.worldPosEnd, markerRot, num6, ref arc.vertexPairNum, ref indicesIdx, isStartPair);
					break;
				}
				Portal component2 = hitInfo.collider.GetComponent<Portal>();
				Vector3 normalized2 = (current.worldPosEnd - current.worldPosEndPrev).normalized;
				Quaternion markerRot2 = CalculateMarkerRotation(current.worldGravity, -component2.transform.forward, transform.forward);
				CreateVertAndIndices(current.worldPosEnd, markerRot2, hitInfo.distance, ref arc.vertexPairNum, ref indicesIdx, isStartPair);
				if (!component2.PlayerHeadTeleportOnEnter || component2.IsHoldable || component2.GetPortalState() != 0 || component2.Link == null)
				{
					break;
				}
				isStartPair = true;
				Portal.PortalTransform portalTransform = component2.CalculatePortalObjectTransform(current.worldPosEnd, current.worldRotStart, ray.direction);
				Vector3 direction = portalTransform.direction;
				Vector3 worldPosEnd = portalTransform.position + direction * (num6 - hitInfo.distance);
				current.worldPosStart = (current.worldPosEndPrev = portalTransform.position);
				current.worldPosEnd = worldPosEnd;
				current.worldRotStart = portalTransform.rotation;
				current.worldVelStart = component2.CalculatePortalObjectTransform(Vector3.zero, Quaternion.identity, current.worldVelEnd).direction;
				current.worldVelEnd = current.worldVelStart;
				num4 = inst.arcGravitySpeed * inst.arcGravityCurve.Evaluate((float)i / (float)arcNumSegments);
				vector = component2.GravityDirection;
				current.worldGravity = vector * num4;
				markerRot2 = CalculateMarkerRotation(current.worldGravity, component2.Link.transform.forward, transform.forward);
				arc.vertexIdxCrossingPortal = arc.vertexPairNum;
				CreateVertAndIndices(current.worldPosStart, markerRot2, 0f, ref arc.vertexPairNum, ref indicesIdx, isStartPair);
				i++;
				isStartPair = false;
				normalized2 = (current.worldPosEnd - current.worldPosEndPrev).normalized;
				markerRot2 = CalculateMarkerRotation(current.worldGravity, normalized2, transform.forward);
				CreateVertAndIndices(current.worldPosEnd, markerRot2, num6 - hitInfo.distance, ref arc.vertexPairNum, ref indicesIdx, isStartPair);
				i++;
				result.portalIntersected = component2;
				owner = component2.Link.owner;
				ArcMarkerStep(ref current, num);
			}
			else
			{
				current.timeElapsed += num;
				Vector3 normalized3 = (current.worldPosEnd - current.worldPosEndPrev).normalized;
				Quaternion markerRot3 = CalculateMarkerRotation(current.worldGravity, normalized3, transform.forward);
				CreateVertAndIndices(current.worldPosEndPrev, markerRot3, num6, ref arc.vertexPairNum, ref indicesIdx, isStartPair);
			}
			isStartPair = false;
		}
		arc.intersectionTime = Mathf.MoveTowards(arc.intersectionTime, current.timeElapsed, inst.arcLengthAnimSpeed * IC.RealDeltaTime);
		if (result.hit)
		{
			result.hit = arc.intersectionTime == current.timeElapsed;
		}
		if (arc.vertexIdxCrossingPortal == -1)
		{
			arc.vertexIdxCrossingPortal = arc.vertexPairNum + 1;
		}
		if ((bool)hand.portalFromHeadToHand)
		{
			result.hit = false;
		}
		return result;
	}

	private Quaternion CalculateMarkerRotation(Vector3 markerGravity, Vector3 markerForward, Vector3 startForward)
	{
		if (markerForward == Vector3.zero)
		{
			UnityEngine.Debug.LogError("markerRotation was zero, investigate how forward was set before the call");
			return Quaternion.identity;
		}
		Vector3 normalized = Vector3.Cross(-markerGravity, startForward).normalized;
		Vector3 normalized2 = Vector3.Cross(markerForward, normalized).normalized;
		return Quaternion.LookRotation(markerForward, normalized2);
	}

	private void UpdateArcMesh()
	{
		TeleportSettings inst = BaseSettings<TeleportSettings>.Inst;
		int num = ((arc.vertexIdxCrossingPortal == arc.vertexPairNum + 1) ? arc.vertexPairNum : (arc.vertexPairNum - arc.baseMeshVertCount));
		for (int i = 0; i < arc.vertexPairNum; i += arc.baseMeshVertCount)
		{
			float num2 = (float)i / (float)num;
			if (i >= arc.vertexIdxCrossingPortal)
			{
				num2 = (float)(i - arc.baseMeshVertCount) / (float)num;
			}
			float num3 = arc.UITools.objColor.a - num2;
			float b = inst.arcWidth * 0.1f * num3;
			b = (arc.showing ? Mathf.Max(0f, b) : 0f);
			Vector3 vector = arc.vertices[i];
			for (int j = 0; j < arc.baseMeshVertCount; j++)
			{
				int num4 = i + j;
				arc.vertices[num4] = vector + arc.normals[num4] * b;
				arc.uvs[num4].y /= arc.length;
			}
		}
		arc.mesh.vertices = arc.vertices;
		arc.mesh.normals = arc.normals;
		arc.mesh.uv = arc.uvs;
		arc.mesh.SetIndices(arc.indices, MeshTopology.Triangles, 0);
		arc.mesh.RecalculateBounds();
	}

	private static RegionResult FindBestNearbyRegionToWorldPos(Vector3 hitPosWS, Vector3 hitNormalWS, Vector3 gravity, Portal portalArcIsCrossing, Region.IConnectionKey keyPortal, Region.IConnectionKey keyEGrill, Hand hand)
	{
		try
		{
			float num = float.MaxValue;
			RegionResult result = default(RegionResult);
			Vector3 up = -gravity;
			int offsetIdx = Region.GetEnabledRegions(MainCamera.Inst.GetOwner().regions, enabledRegions);
			if ((bool)portalArcIsCrossing && portalArcIsCrossing.owner != portalArcIsCrossing.Link.owner)
			{
				offsetIdx = Region.GetEnabledRegions(portalArcIsCrossing.Link.owner.regions, enabledRegions, offsetIdx);
			}
			TeleportSettings inst = BaseSettings<TeleportSettings>.Inst;
			Transform transform = CC.Inst.transform;
			int regionsConnectedTo = Region.GetRegionsConnectedTo(CC.Inst.LastValidRegion, connectedRegions, keyPortal, keyEGrill, teleporting: true);
			Region[] array = connectedRegions;
			for (int i = 0; i < regionsConnectedTo; i++)
			{
				Region region = array[i];
				if (!region.IsAlignedToUpDirection(up))
				{
					continue;
				}
				Region.ValidPos validPos = region.FindNearestValidPoint(hitPosWS, useMaximumConstraints: true, allowOutOfRegionEdgeSnapping: true, inst.minHeightToRegionSnap, inst.maxHeightToRegionSnap, inst.maxXZDistanceToRegionSnap);
				if (!validPos.valid)
				{
					continue;
				}
				if (Vector3.Dot(hitNormalWS, -gravity) < Mathf.Cos(45f))
				{
					Vector2 rhs = region.transform.InverseTransformDirection(hitNormalWS).xz();
					rhs.Normalize();
					Vector2 vector = region.transform.InverseTransformPoint(hitPosWS).xz();
					if (Vector2.Dot((region.transform.InverseTransformPoint(validPos.worldPos).xz() - vector).normalized, rhs) < 0f)
					{
						continue;
					}
				}
				if (validPos.requiredRepositionToOuterBorder && (bool)hand)
				{
					Vector2 vector2 = region.transform.InverseTransformPoint(hitPosWS).xz();
					Vector2 vector3 = region.transform.InverseTransformPoint(validPos.worldPos).xz();
					Vector2 vector4 = region.transform.InverseTransformPoint(hand.transform.position).xz();
					float num2 = Vector3.Distance(vector4, vector2);
					if (Vector3.Distance(vector4, vector3) > num2)
					{
						continue;
					}
				}
				Vector3 position;
				Vector3 lhs;
				if ((bool)portalArcIsCrossing)
				{
					Portal.PortalTransform portalTransform = portalArcIsCrossing.CalculatePortalObjectTransform(transform.position, transform.rotation, transform.up);
					position = portalTransform.position;
					lhs = portalTransform.direction;
				}
				else if ((bool)hand && (bool)hand.portalFromHeadToHand)
				{
					Portal.PortalTransform portalTransform2 = hand.portalFromHeadToHand.CalculatePortalObjectTransform(transform.position, transform.rotation, transform.up);
					position = portalTransform2.position;
					lhs = portalTransform2.direction;
				}
				else
				{
					position = transform.position;
					lhs = transform.up;
				}
				Vector3 rhs2 = validPos.worldPos - position;
				if (!(Mathf.Abs(Vector3.Dot(lhs, rhs2)) > inst.teleportMaxYOffset))
				{
					float num3 = Vector3.Distance(validPos.worldPos, hitPosWS);
					if (num3 < num)
					{
						num = num3;
						result.validPos = validPos;
						result.region = region;
					}
				}
			}
			return result;
		}
		finally
		{
			Array.Clear(enabledRegions, 0, enabledRegions.Length);
			Array.Clear(connectedRegions, 0, connectedRegions.Length);
		}
	}

	public bool OnUpdateLR()
	{
		portalTeleportedThrough = null;
		eGrillTeleportedThrough = null;
		if ((bool)arcHand)
		{
			IC.IHandInput inputForHand = IC.GetInputForHand(arcHand.ICHand);
			if (IC.GetInputForHand(rotationHand.ICHand).GetBackDown())
			{
				Hand hand = arcHand;
				arcHand = rotationHand;
				rotationHand = hand;
			}
			else if (!inputForHand.GetBackUp() && !inputForHand.GetBackHeld())
			{
				arcHand = null;
				rotationHand = null;
			}
		}
		else
		{
			IC.IHandInput inputForHand2 = IC.GetInputForHand(IC.Hand.Left);
			IC.IHandInput inputForHand3 = IC.GetInputForHand(IC.Hand.Right);
			if (inputForHand2.GetBackDown())
			{
				CC inst = CC.Inst;
				arcHand = inst.handL;
				rotationHand = inst.handR;
			}
			else if (inputForHand3.GetBackDown())
			{
				CC inst2 = CC.Inst;
				arcHand = inst2.handR;
				rotationHand = inst2.handL;
			}
		}
		TeleportSettings inst3 = BaseSettings<TeleportSettings>.Inst;
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		TeleportHasStartedThisFrame = false;
		if ((bool)arcHand)
		{
			Vector3 gravity = arcHand.gravity;
			Vector3 vector = arcHand.transform.rotation * Vector3.forward;
			vector = (vector - gravity * Vector3.Dot(vector, gravity)).normalized;
			Vector3 normalized = Vector3.Cross(-gravity, vector).normalized;
			Vector3 normalized2 = Vector3.Cross(vector, normalized).normalized;
			Quaternion quaternion = Quaternion.LookRotation(vector, normalized2);
			IC.IHandInput inputForHand4 = IC.GetInputForHand(arcHand.ICHand);
			IC.IHandInput inputForHand5 = IC.GetInputForHand(rotationHand.ICHand);
			flag = inputForHand4.GetBackUp();
			Quaternion identity = Quaternion.identity;
			if (!flag)
			{
				lastGoodAnalogDirection = inputForHand5.GetAxis();
			}
			Vector3 forward = new Vector3(lastGoodAnalogDirection.x, 0f, lastGoodAnalogDirection.y);
			if (forward.magnitude < 0.025f)
			{
				identity = Quaternion.identity;
			}
			else
			{
				forward.Normalize();
				identity = Quaternion.LookRotation(forward, Vector3.up);
			}
			quaternion *= identity;
			Telepoint telepoint = null;
			if (TeleportEnabled.Value && LR.Inst.AreAllLoadedScenesAwake && NexusFullScreenPass.Inst.IsClear() && !IC.Inst.MainMenuIntercept)
			{
				Vector3 to = -CC.Inst.transform.up;
				if (!(Vector3.Angle(arcHand.transform.rotation * Vector3.forward, to) < inst3.angleFromHandToFloorForReorientation))
				{
					flag2 = ((!arcHand.portalFromHeadToHand || !arcHand.portalFromHeadToHand.IsHoldable) ? true : false);
				}
				else
				{
					flag2 = false;
					if (!CC.Inst.telepointStoodOn || !CC.Inst.telepointStoodOn.IsAngleSnappingRequired())
					{
						flag3 = true;
						Vector3 direction = IC.GetHeadRotation() * Vector3.forward;
						Vector3 direction2 = IC.GetHeadRotation() * Vector3.up;
						Vector3 vector2 = CC.Inst.transform.InverseTransformDirection(direction);
						if (Vector3.Angle(vector2, -Vector3.up) < inst3.angleFromHeadToFloorToChooseHeadForward)
						{
							vector2 = CC.Inst.transform.InverseTransformDirection(direction2);
						}
						Vector3 vector3 = vector2;
						vector3.y = 0f;
						vector3 = vector3.normalized;
						vector3 = CC.Inst.transform.TransformDirection(vector3);
						Quaternion quaternion2 = Quaternion.LookRotation(vector3, CC.Inst.transform.up) * identity;
						telepadArrow.transform.position = CC.Inst.transform.position + CC.Inst.transform.up * -0.5f;
						telepadArrow.transform.rotation = quaternion2;
						if ((bool)CC.Inst.telepointStoodOn)
						{
							telepoint = CC.Inst.telepointStoodOn;
						}
						Vector3 vector4 = CC.Inst.GetWorldFloorPosition(IC.GetHeadPosition());
						RegionResult regionResult = FindBestNearbyRegionToWorldPos(vector4, CC.Inst.transform.up, -CC.Inst.transform.up, null, null, null, null);
						if ((bool)regionResult.region)
						{
							vector4 = SneakyConstrainPlayer(regionResult.region, identity, vector4);
						}
						OffsetCCPosRotFromMarker(vector4, quaternion2, out var ccPosition, out var ccRotation);
						if (flag)
						{
							CC.TeleportInfo teleportInfo = default(CC.TeleportInfo);
							if (regionResult.region.isDynamic)
							{
								teleportInfo.region = regionResult.region;
							}
							CC.Inst.PositionReplace(ccPosition, ccRotation, teleportInfo, fadeCamera: true, forceUpdateLastState: false, MovementType: false, CC.MovementType.Teleport);
							FAC.Inst.PlayOneShot(inst3.TeleportSFX.Value, ccPosition);
							TeleportHasStartedThisFrame = true;
							arcHand = null;
							rotationHand = null;
						}
					}
				}
			}
			if (flag2)
			{
				MRBase owner = arcHand.GetOwner();
				Vector3 zero = Vector3.zero;
				CastArcResult castArcResult = CastArc(arcHand);
				if (castArcResult.hit)
				{
					Portal portalIntersected = castArcResult.portalIntersected;
					Vector3 gravity2 = (portalIntersected ? (-portalIntersected.Link.transform.up) : arcHand.gravity);
					if ((bool)portalIntersected)
					{
						quaternion = portalIntersected.CalculatePortalObjectTransform(Vector3.zero, quaternion, Vector3.zero).rotation;
					}
					RegionResult regionResult2 = FindBestNearbyRegionToWorldPos(castArcResult.hitWorldPoint, castArcResult.hitWorldNormal, gravity2, portalIntersected, portalIntersected ? portalIntersected.Link : null, castArcResult.eGrillIntersected, arcHand);
					if (regionResult2.validPos.valid)
					{
						zero = regionResult2.validPos.worldPos;
						float num = float.MaxValue;
						Telepoint telepoint2 = null;
						if ((bool)castArcResult.cutsceneCollider)
						{
							telepoint2 = castArcResult.cutsceneCollider.telepoint;
						}
						else
						{
							for (int i = 0; i < owner.telepoints.Length; i++)
							{
								Telepoint telepoint3 = owner.telepoints[i];
								if (telepoint3.isActiveAndEnabled && !telepoint3.IsHidden && (LR.Inst.saveDataSettings.hintsEnabled || telepoint3.IsCutsceneTelepoint || telepoint3.IsTutorialTelepoint))
								{
									float sqrMagnitude = (telepoint3.transform.position - zero).sqrMagnitude;
									if (sqrMagnitude < num)
									{
										num = sqrMagnitude;
										telepoint2 = telepoint3;
									}
								}
							}
						}
						if ((bool)telepoint2 && Vector3.Distance(telepoint2.transform.position, zero) < inst3.telepointOuterRadius)
						{
							telepoint = telepoint2;
							zero = telepoint2.transform.position;
							quaternion = telepoint.transform.rotation;
						}
						Vector3 vector5 = (portalIntersected ? portalIntersected.Link.transform.up : CC.Inst.transform.up) * inst3.teleportArrowRestHeight;
						telepadArrow.transform.position = zero + vector5;
						telepadArrow.transform.rotation = quaternion;
						if ((bool)portalIntersected)
						{
							Vector3 vector6 = -CC.Inst.transform.up;
							Vector3 vector7 = -portalIntersected.transform.up;
							if ((double)Vector3.SqrMagnitude(vector6 - vector7) < 0.0001)
							{
								flag3 = true;
							}
						}
						else
						{
							flag3 = true;
						}
						zero = SneakyConstrainPlayer(regionResult2.region, identity, zero);
						if (flag && flag3)
						{
							Portal portalFromHeadToHand = arcHand.portalFromHeadToHand;
							Portal portal = (((bool)portalIntersected && (bool)portalFromHeadToHand) ? null : ((!portalIntersected) ? portalFromHeadToHand : portalIntersected));
							Vector3 targetHeadFloorPos;
							Quaternion targetRotation;
							if ((bool)portal)
							{
								Portal.PortalTransform portalTransform = portal.Link.CalculatePortalObjectTransform(zero, quaternion, Vector3.zero);
								targetHeadFloorPos = portalTransform.position;
								targetRotation = portalTransform.rotation;
							}
							else
							{
								targetHeadFloorPos = zero;
								targetRotation = quaternion;
							}
							OffsetCCPosRotFromMarker(targetHeadFloorPos, targetRotation, out var ccPosition2, out var ccRotation2);
							TrackingDirectionHint.Inst.EvaluateAngleToShowHint(inst3.frontfaceAngleToShowHintOnTeleport);
							CC.TeleportInfo teleportInfo2 = default(CC.TeleportInfo);
							teleportInfo2.portal = portalIntersected;
							teleportInfo2.wasEGrillEncounterBeforePortal = castArcResult.wasEGrillEncounterBeforePortal;
							teleportInfo2.eGrill = castArcResult.eGrillIntersected;
							if (regionResult2.region.isDynamic)
							{
								teleportInfo2.region = regionResult2.region;
							}
							if ((bool)telepoint)
							{
								telepoint.OnTeleport.Trigger();
							}
							if ((bool)castArcResult.cutsceneCollider || ((bool)telepoint && telepoint.cutsceneTrigger != null))
							{
								CC.Inst.PositionReplace(ccPosition2, ccRotation2, teleportInfo2, fadeCamera: true, forceUpdateLastState: false, MovementType: false, CC.MovementType.Teleport, null, BaseSettings<TeleportSettings>.Inst.cutsceneFadeDuration, null, BaseSettings<TeleportSettings>.Inst.cutsceneFadeDuration, null, null, castArcResult.portalIntersected, castArcResult.eGrillIntersected);
								if ((bool)castArcResult.cutsceneCollider)
								{
									castArcResult.cutsceneCollider.cutSceneTrigger.Trigger();
								}
								else
								{
									telepoint.cutsceneTrigger.Trigger();
								}
							}
							else
							{
								CC.Inst.PositionReplace(ccPosition2, ccRotation2, teleportInfo2, fadeCamera: true, forceUpdateLastState: false, MovementType: false, CC.MovementType.Teleport, null, null, null, null, null, null, castArcResult.portalIntersected, castArcResult.eGrillIntersected);
							}
							FAC.Inst.PlayOneShot(inst3.TeleportSFX.Value, ccPosition2);
							TeleportHasStartedThisFrame = true;
							arcHand = null;
							rotationHand = null;
						}
					}
					else
					{
						Vector3 normalized3 = (-castArcResult.lastRayInArc.direction + castArcResult.hitWorldNormal).normalized;
						Vector3 vector8 = -castArcResult.lastRayInArc.direction * inst3.teleportArrowRestHeight;
						teleportCross.transform.position = castArcResult.hitWorldPoint + vector8;
						teleportCross.transform.rotation = Quaternion.LookRotation(CC.Inst.transform.up, normalized3);
					}
				}
				else
				{
					Vector3 vector9 = -castArcResult.lastRayInArc.direction * inst3.teleportArrowRestHeight;
					Vector3 vector10 = castArcResult.hitWorldPoint + castArcResult.lastRayInArc.direction * castArcResult.lastDistInArc;
					teleportCross.transform.position = vector10 + vector9;
					teleportCross.transform.up = -castArcResult.lastRayInArc.direction;
				}
			}
		}
		UpdateArcMesh();
		if (flag)
		{
			arc.intersectionTime = 0f;
		}
		if (showingTeleportArrow != flag3)
		{
			showingTeleportArrow = flag3;
			if (flag3)
			{
				telepadArrow.OnShow(1f, 0.2f);
			}
			else
			{
				telepadArrow.OnHide();
			}
		}
		if (showingTeleportCross == (flag3 || !flag2))
		{
			showingTeleportCross = !flag3 && flag2;
			if (showingTeleportCross)
			{
				teleportCross.OnShow(1f, 0.2f);
			}
			else
			{
				teleportCross.OnHide();
			}
		}
		if (arc.showing != flag2)
		{
			arc.showing = flag2;
			if (flag2)
			{
				arc.UITools.AlphaAnimateTo(1f, 0.3f, 0f);
			}
			else
			{
				arc.UITools.AlphaAnimateTo(0f, 0.1f, 0f);
			}
		}
		if (arc.invalid == flag3 && !TeleportHasStartedThisFrame)
		{
			arc.invalid = !flag3;
			if (!flag3)
			{
				arc.mr.sharedMaterial.SetColor(ShaderPID._StartColor, inst3.arcColorInvalid);
				arc.mr.sharedMaterial.SetColor(ShaderPID._EndColour, inst3.arcColorInvalid);
			}
			else
			{
				arc.mr.sharedMaterial.SetColor(ShaderPID._StartColor, inst3.arcStartColor);
				arc.mr.sharedMaterial.SetColor(ShaderPID._EndColour, inst3.arcEndColor);
			}
		}
		telepadArrow.OnUpdateLR();
		return TeleportHasStartedThisFrame;
	}

	public static Vector3 SneakyConstrainPlayer(Region region, Quaternion inputRotation, Vector3 targetPosThroughPortal)
	{
		Transform transform = CC.Inst.transform;
		TeleportSettings inst = BaseSettings<TeleportSettings>.Inst;
		Vector3 vector = transform.InverseTransformPoint(IC.GetHeadPosition());
		vector.y = 0f;
		Vector3 vector2 = transform.TransformPoint(inputRotation * vector) - transform.position;
		Vector3 vector3 = targetPosThroughPortal + vector2;
		Region.ValidPos validPos = region.FindNearestValidPoint(vector3, useMaximumConstraints: false, allowOutOfRegionEdgeSnapping: true, inst.minHeightToRegionSnap, inst.maxHeightToRegionSnap, inst.maxXZDistanceToRegionSnap);
		if (validPos.requiredRepositionToInnerBorder)
		{
			targetPosThroughPortal += validPos.worldPos - vector3;
		}
		return targetPosThroughPortal;
	}

	public static void OffsetCCPosRotFromMarker(Vector3 targetHeadFloorPos, Quaternion targetRotation, out Vector3 ccPosition, out Quaternion ccRotation)
	{
		CC inst = CC.Inst;
		ccPosition = inst.CalculateCCPosFromHeadPos(targetHeadFloorPos, checkOOB: false);
		ccRotation = targetRotation;
		Quaternion quaternion = ccRotation * Quaternion.Inverse(MainCamera.CalculateHeadForwardRotation());
		ccPosition = Vector3X.RotatePointAroundPivot(ccPosition, targetHeadFloorPos, quaternion);
		ccRotation = quaternion * inst.transform.rotation;
	}
}
[ExecuteInEditMode]
public class Region : MonoBehaviour, Region.IConnectionOwner
{
	public interface IConnectionKey
	{
	}

	public interface IConnectionOwner
	{
		bool IsConnectionValid(IConnectionKey key, bool teleporting);
	}

	public interface IEvents
	{
		void OnEnterRegion();

		void OnExitRegion();
	}

	public struct Connection
	{
		public Region region;

		public IConnectionOwner owner;

		public Connection(Region region, IConnectionOwner owner)
		{
			this.region = region;
			this.owner = owner;
		}
	}

	private class ReferenceEqualityComparer : IEqualityComparer, IEqualityComparer<object>
	{
		public static readonly ReferenceEqualityComparer Default = new ReferenceEqualityComparer();

		bool IEqualityComparer<object>.Equals(object x, object y)
		{
			return x == y;
		}

		bool IEqualityComparer.Equals(object x, object y)
		{
			return x == y;
		}

		int IEqualityComparer<object>.GetHashCode(object obj)
		{
			return RuntimeHelpers.GetHashCode(obj);
		}

		int IEqualityComparer.GetHashCode(object obj)
		{
			return RuntimeHelpers.GetHashCode(obj);
		}
	}

	public struct Bounds
	{
		public Vector3 center;

		public Vector3 extents;
	}

	public struct ValidPos
	{
		public Region region;

		public bool valid;

		public bool requiredRepositionToInnerBorder;

		public bool requiredRepositionToOuterBorder;

		public Vector3 worldPos;
	}

	public const uint MAX_REGION_SEARCH_RESULTS = 64u;

	public const float ALIGNMENT_TOLERANCE = 0.99f;

	private Matrix4x4 localToWorldCached;

	private Matrix4x4 worldToLocalCached;

	private Bounds worldSpaceBounds;

	public MRBase owner;

	[HideInInspector]
	public Shape[] shapes;

	[HideInInspector]
	public bool showShapesList;

	public ConstArray<Connection> connectedRegions = new ConstArray<Connection>(32u);

	[SerializeField]
	public bool isDynamic;

	[Tooltip("If set to anything but 0, will use this value to tell if you're too far from region and start an OOB fade.")]
	[SerializeField]
	public float overrideFarFromRegionDist;

	private Mesh mesh;

	private int disabledCounter;

	private Vector3 positionPrev = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);

	private bool requiresUpdate;

	private Vector3 frameEarlyPos;

	[NonSerialized]
	[HideInInspector]
	public Vector3 DynamicOffset;

	private IEvents[] regionEvents;

	private TransformData xformData;

	private static HashSet<Region> testedRegions = new HashSet<Region>(ReferenceEqualityComparer.Default);

	public Bounds WorldSpaceBounds => worldSpaceBounds;

	public bool IsEnabled => disabledCounter == 0;

	public bool MeshHasValidVertices => !ArrayX.IsNullOrEmpty(mesh?.vertices);

	public bool MeshHasValidNormals => !ArrayX.IsNullOrEmpty(mesh?.normals);

	public void OnAwakeLR(MRBase owner)
	{
		xformData = new TransformData(base.transform);
		this.owner = owner;
		UpdateBounds();
		regionEvents = GetComponentsInChildren<IEvents>();
	}

	protected void OnDestroy()
	{
		for (int i = 0; i < connectedRegions.Length; i++)
		{
			connectedRegions[i].region.OnConnectedRegionDestroyed(this);
		}
	}

	private void OnConnectedRegionDestroyed(Region destroyed)
	{
		for (uint num = 0u; num < connectedRegions.Length; num++)
		{
			if (connectedRegions[num].region == destroyed)
			{
				connectedRegions.RemoveAtIndex(num);
				num--;
			}
		}
		connectedRegions.ReleaseUnusedReferences();
	}

	public static void OnUpdateAll(Region[] regions)
	{
		int num = regions.Length;
		for (int i = 0; i < num; i++)
		{
			Region region = regions[i];
			if (region.isDynamic)
			{
				Vector3 position = region.xformData.xform.position;
				if (region.positionPrev.x != position.x || region.positionPrev.y != position.y || region.positionPrev.z != position.z)
				{
					region.positionPrev = position;
					region.requiresUpdate = true;
				}
				if (region.requiresUpdate)
				{
					region.xformData.Update();
					region.UpdateBounds();
				}
			}
		}
		for (int j = 0; j < num; j++)
		{
			Region region2 = regions[j];
			if (!region2.requiresUpdate)
			{
				continue;
			}
			for (int k = 0; k < num; k++)
			{
				Region regionB = regions[k];
				if (j != k)
				{
					EvaluateConnection(region2, regionB);
				}
			}
			region2.frameEarlyPos = region2.xformData.position;
			region2.requiresUpdate = false;
		}
	}

	public void OnUpdateLR()
	{
	}

	public void OnLateUpdateLR()
	{
		if (isDynamic)
		{
			Vector3 position = base.transform.position;
			DynamicOffset = position - frameEarlyPos;
		}
	}

	private void OnEnable()
	{
	}

	[Conditional("UNITY_EDITOR")]
	public void EDITOR_UpdateXformData()
	{
		if (!UnityEngine.Application.isPlaying)
		{
			if (xformData == null)
			{
				xformData = new TransformData(base.transform);
			}
			xformData.Update();
		}
	}

	public bool IsAlignedToUpDirection(Vector3 up)
	{
		return up.x * xformData.up.x + up.y * xformData.up.y + up.z * xformData.up.z > 0.99f;
	}

	public float GetYOffset(Vector3 worldPos)
	{
		return xformData.xform.InverseTransformPoint(worldPos).y;
	}

	public bool Raycast(Ray ray, out float distance, out Vector3 hitPosWorld)
	{
		hitPosWorld = Vector3.zero;
		if (new Plane(xformData.up, xformData.position).Raycast(ray, out distance))
		{
			Vector3 vector = ray.origin + ray.direction * distance;
			Vector2 localPos = xformData.xform.InverseTransformPoint(vector).ToXZ();
			if (IsPointInsidePolygon(localPos, inner: false))
			{
				hitPosWorld = vector;
				return true;
			}
		}
		return false;
	}

	public Vector3 GetRandomPosition(float yOffset)
	{
		Vector3 vector = worldSpaceBounds.center - worldSpaceBounds.extents;
		Vector3 vector2 = worldSpaceBounds.center + worldSpaceBounds.extents;
		Vector3 worldPos = default(Vector3);
		worldPos.x = UnityEngine.Random.Range(vector.x, vector2.x);
		worldPos.y = UnityEngine.Random.Range(vector.y, vector2.y);
		worldPos.z = UnityEngine.Random.Range(vector.z, vector2.z);
		worldPos = FindNearestValidPoint(worldPos, useMaximumConstraints: false, allowOutOfRegionEdgeSnapping: true, 0f, 0f, 0f).worldPos;
		return worldPos + yOffset * xformData.up;
	}

	public float GetArea()
	{
		float num = 0f;
		Shape[] array = shapes;
		foreach (Shape shape in array)
		{
			num += shape.GetArea();
		}
		return num;
	}

	public float GetBoundsArea()
	{
		Vector3 vector = WorldSpaceBounds.extents * 2f;
		return Mathf.Abs(vector.x * vector.z);
	}

	public ValidPos FindNearestValidPoint(Vector3 worldPos, bool useMaximumConstraints, bool allowOutOfRegionEdgeSnapping, float minHeightToRegionSnap, float maxHeightToRegionSnap, float maxXZDistanceToRegionSnap, bool maintainsLocalYOffset = false)
	{
		ValidPos result = default(ValidPos);
		result.region = this;
		Vector3 vector = xformData.xform.InverseTransformPoint(worldPos);
		if (useMaximumConstraints && vector.y < 0f - minHeightToRegionSnap)
		{
			return result;
		}
		if (useMaximumConstraints && vector.y > maxHeightToRegionSnap)
		{
			return result;
		}
		Vector2 vector2 = default(Vector2);
		vector2.x = vector.x;
		vector2.y = vector.z;
		Vector2 localPos = Vector2X.zero;
		if (IsPointInsidePolygon(vector2, inner: false))
		{
			result.valid = true;
			localPos = vector2;
		}
		else if (allowOutOfRegionEdgeSnapping)
		{
			Vector2 vector3 = ClosestLocalPosOnEdge(vector2, inner: false);
			double num = Math.Sqrt((vector3.x - vector2.x) * (vector3.x - vector2.x) + (vector3.y - vector2.y) * (vector3.y - vector2.y));
			if (!useMaximumConstraints || num < (double)maxXZDistanceToRegionSnap)
			{
				result.valid = true;
				result.requiredRepositionToOuterBorder = true;
				localPos = vector3;
			}
		}
		if (result.valid && !IsPointInsidePolygon(vector2, inner: true))
		{
			localPos = ClosestLocalPosOnEdge(localPos, inner: true);
			result.requiredRepositionToInnerBorder = true;
		}
		Vector3 position = default(Vector3);
		position.x = localPos.x;
		position.y = (maintainsLocalYOffset ? vector.y : 0f);
		position.z = localPos.y;
		result.worldPos = xformData.xform.TransformPoint(position);
		return result;
	}

	public bool IsPointInsidePolygonWS(Vector3 worldPos, bool inner)
	{
		Vector3 v = xformData.xform.InverseTransformPoint(worldPos);
		return IsPointInsidePolygon(v.xz(), inner);
	}

	public bool IsPointInsidePolygon(Vector2 localPos, bool inner)
	{
		bool flag = false;
		for (int i = 0; i < shapes.Length; i++)
		{
			Vector2[] array = (inner ? shapes[i].pointsInner : shapes[i].points);
			int num = 0;
			int num2 = array.Length - 1;
			while (num < array.Length)
			{
				Vector2 vector = array[num];
				Vector2 vector2 = array[num2];
				if (vector.y > localPos.y != vector2.y > localPos.y && localPos.x < (vector2.x - vector.x) * (localPos.y - vector.y) / (vector2.y - vector.y) + vector.x)
				{
					flag = !flag;
				}
				num2 = num++;
			}
		}
		return flag;
	}

	public Vector2 ClosestLocalPosOnEdge(Vector2 localPos, bool inner)
	{
		Vector2 result = Vector2X.zero;
		float num = float.MaxValue;
		Vector2 vector3 = default(Vector2);
		for (int i = 0; i < shapes.Length; i++)
		{
			Vector2[] array = (inner ? shapes[i].pointsInner : shapes[i].points);
			int num2 = array.Length;
			int num3 = 0;
			int num4 = array.Length - 1;
			while (num3 < num2)
			{
				Vector2 vector = array[num3];
				Vector2 vector2 = array[num4];
				float num5 = vector2.x - vector.x;
				float num6 = vector2.y - vector.y;
				float num7 = localPos.x - vector.x;
				float num8 = localPos.y - vector.y;
				float num9 = num5 * num5 + num6 * num6;
				if (num9 == 0f)
				{
					vector3 = vector;
				}
				else
				{
					float num10 = (num7 * num5 + num8 * num6) / num9;
					if (num10 <= 0f)
					{
						vector3 = vector;
					}
					else if (num10 >= 1f)
					{
						vector3 = vector2;
					}
					else
					{
						vector3.x = vector.x + num5 * num10;
						vector3.y = vector.y + num6 * num10;
					}
				}
				float num11 = localPos.x - vector3.x;
				float num12 = localPos.y - vector3.y;
				float num13 = num11 * num11 + num12 * num12;
				if (num13 < num)
				{
					num = num13;
					result = vector3;
				}
				num4 = num3++;
			}
		}
		return result;
	}

	[ContextMenu("Enable")]
	public void Enable()
	{
		if (disabledCounter > 0)
		{
			disabledCounter--;
		}
	}

	[ContextMenu("Disable")]
	public void Disable()
	{
		disabledCounter++;
	}

	public void UpdateMeshDisplay()
	{
		mesh = CompositeShape.CalculatePolygonNormalsAndRenderMesh(shapes);
	}

	public static ValidPos GetClosestValidPos(Vector3 up, Vector3 worldPos, Region[] regions, int regionsLength)
	{
		ValidPos result = default(ValidPos);
		float num = float.MaxValue;
		Vector3 vector = default(Vector3);
		for (int i = 0; i < regionsLength; i++)
		{
			Region region = regions[i];
			if (up.x * region.xformData.up.x + up.y * region.xformData.up.y + up.z * region.xformData.up.z < 0.99f)
			{
				continue;
			}
			ValidPos validPos = region.FindNearestValidPoint(worldPos, useMaximumConstraints: false, allowOutOfRegionEdgeSnapping: true, 0f, 0f, 0f);
			if (!validPos.valid)
			{
				continue;
			}
			vector.x = worldPos.x - validPos.worldPos.x;
			vector.y = worldPos.y - validPos.worldPos.y;
			vector.z = worldPos.z - validPos.worldPos.z;
			float num2 = (float)Math.Sqrt(vector.x * vector.x + vector.y * vector.y + vector.z * vector.z);
			if (result.valid)
			{
				if (result.requiredRepositionToInnerBorder && !validPos.requiredRepositionToInnerBorder)
				{
					result = validPos;
					num = num2;
				}
				else if (num2 < num)
				{
					result = validPos;
					num = num2;
				}
			}
			else
			{
				result = validPos;
				num = num2;
			}
		}
		return result;
	}

	public static ValidPos GetClosestValidPos(Vector3 up, Vector3 worldPos, Region[] regions)
	{
		return GetClosestValidPos(up, worldPos, regions, regions.Length);
	}

	public static int GetRegionsConnectedTo(Region startRegion, Region[] regionArrayToFill, IConnectionKey key0, IConnectionKey key1, bool teleporting)
	{
		int idx = 0;
		if ((object)startRegion == null || !startRegion.IsEnabled)
		{
			return idx;
		}
		try
		{
			GetRegionsConnectedToRecursive(startRegion, regionArrayToFill, ref idx, key0, key1, teleporting);
			return idx;
		}
		finally
		{
			testedRegions.Clear();
		}
	}

	private static void GetRegionsConnectedToRecursive(Region startRegion, Region[] regionArrayToFill, ref int idx, IConnectionKey key0, IConnectionKey key1, bool teleporting)
	{
		if (!testedRegions.Add(startRegion) || !startRegion.IsEnabled)
		{
			return;
		}
		regionArrayToFill[idx] = startRegion;
		idx++;
		Connection[] data = startRegion.connectedRegions._data;
		int sLength = startRegion.connectedRegions.sLength;
		for (int i = 0; i < sLength; i++)
		{
			Connection connection = data[i];
			if (connection.owner.IsConnectionValid(key0, teleporting) || connection.owner.IsConnectionValid(key1, teleporting))
			{
				GetRegionsConnectedToRecursive(connection.region, regionArrayToFill, ref idx, key0, key1, teleporting);
			}
		}
	}

	public static int GetEnabledRegions(Region[] srcArray, Region[] destArray, int offsetIdx = 0)
	{
		int num = srcArray.Length;
		int num2 = offsetIdx;
		for (int i = 0; i < num; i++)
		{
			if (srcArray[i].IsEnabled)
			{
				destArray[num2] = srcArray[i];
				num2++;
			}
		}
		return num2;
	}

	public static void EvaluateConnection(Region regionA, Region regionB)
	{
		Connection connection;
		bool flag = regionA.ConnectionExists(regionB, regionA, out connection);
		bool flag2 = regionA.CheckRegionOverlap(regionB);
		if (flag && !flag2)
		{
			regionA.RemoveConnection(regionB, regionA);
			regionB.RemoveConnection(regionA, regionB);
		}
		else if (!flag && flag2)
		{
			regionA.AddConnection(regionB, regionA);
			regionB.AddConnection(regionA, regionB);
		}
	}

	public static void EvaluateRegions(Region[] regions)
	{
		for (int i = 0; i < regions.Length; i++)
		{
			for (int j = i + 1; j < regions.Length; j++)
			{
				EvaluateConnection(regions[i], regions[j]);
			}
		}
	}

	private bool IsFirstPointInsideOtherRegion(Region otherRegion)
	{
		for (int i = 0; i < shapes.Length; i++)
		{
			Shape shape = shapes[i];
			int num = 0;
			if (num < shape.pointsInner.Length)
			{
				Vector2 point = shape.pointsInner[num];
				Vector2 point2 = localToWorldCached.MultiplyPoint2x4_XZPlane(point);
				Vector2 localPos = otherRegion.worldToLocalCached.MultiplyPoint2x4_XZPlane(point2);
				if (otherRegion.IsPointInsidePolygon(localPos, inner: true))
				{
					return true;
				}
				return false;
			}
		}
		return false;
	}

	private bool CheckRegionOverlap(Region otherRegion)
	{
		if (Vector3.Dot(xformData.up, otherRegion.xformData.up) < 0.99f)
		{
			return false;
		}
		Vector3 center = worldSpaceBounds.center;
		Vector3 extents = worldSpaceBounds.extents;
		Vector3 center2 = otherRegion.worldSpaceBounds.center;
		Vector3 extents2 = otherRegion.worldSpaceBounds.extents;
		if (!(center.x - extents.x <= center2.x + extents2.x) || !(center.x + extents.x >= center2.x - extents2.x) || !(center.y - extents.y <= center2.y + extents2.y) || !(center.y + extents.y >= center2.y - extents2.y) || !(center.z - extents.z <= center2.z + extents2.z) || !(center.z + extents.z >= center2.z - extents2.z))
		{
			return false;
		}
		if (IsFirstPointInsideOtherRegion(otherRegion))
		{
			return true;
		}
		if (otherRegion.IsFirstPointInsideOtherRegion(this))
		{
			return true;
		}
		for (int i = 0; i < shapes.Length; i++)
		{
			Vector2[] pointsInner = shapes[i].pointsInner;
			for (int j = 0; j < otherRegion.shapes.Length; j++)
			{
				Vector2[] pointsInner2 = otherRegion.shapes[j].pointsInner;
				Vector2[] array;
				Vector2[] array2;
				Matrix4x4 result;
				if (pointsInner.Length < pointsInner2.Length)
				{
					array = pointsInner;
					array2 = pointsInner2;
					Matrix4x4X.Multiply(ref otherRegion.worldToLocalCached, ref localToWorldCached, out result);
				}
				else
				{
					array = pointsInner2;
					array2 = pointsInner;
					Matrix4x4X.Multiply(ref worldToLocalCached, ref otherRegion.localToWorldCached, out result);
				}
				int num = array.Length;
				int num2 = array2.Length;
				for (int k = 0; k < num; k++)
				{
					Vector2 vector = Matrix4x4X.MultiplyPoint2x4_XZPlane(ref result, array[k]);
					Vector2 vector2 = Matrix4x4X.MultiplyPoint2x4_XZPlane(ref result, array[(k + 1) % num]);
					for (int l = 0; l < num2; l++)
					{
						Vector2 vector3 = array2[l];
						Vector2 vector4 = array2[(l + 1) % num2];
						float num3 = (vector2.x - vector.x) * (vector4.y - vector3.y) - (vector2.y - vector.y) * (vector4.x - vector3.x);
						if (num3 > 0f - Mathf.Epsilon && num3 < Mathf.Epsilon)
						{
							continue;
						}
						float num4 = (vector.y - vector3.y) * (vector4.x - vector3.x) - (vector.x - vector3.x) * (vector4.y - vector3.y);
						float num5 = (vector.y - vector3.y) * (vector2.x - vector.x) - (vector.x - vector3.x) * (vector2.y - vector.y);
						if ((!(num4 > 0f - Mathf.Epsilon) || !(num4 < Mathf.Epsilon)) && (!(num5 > 0f - Mathf.Epsilon) || !(num5 < Mathf.Epsilon)))
						{
							float num6 = num4 / num3;
							float num7 = num5 / num3;
							if (num6 > 0f && num6 < 1f && num7 > 0f && num7 < 1f)
							{
								return true;
							}
						}
					}
				}
			}
		}
		return false;
	}

	public bool ConnectionExists(Region region, IConnectionOwner owner)
	{
		for (int i = 0; i < connectedRegions._dataNum; i++)
		{
			Connection connection = connectedRegions._data[i];
			if ((object)connection.region == region && connection.owner == owner)
			{
				return true;
			}
		}
		return false;
	}

	private bool ConnectionExists(Region region, IConnectionOwner owner, out Connection connection)
	{
		for (int i = 0; i < connectedRegions._dataNum; i++)
		{
			Connection connection2 = connectedRegions._data[i];
			if ((object)connection2.region == region && connection2.owner == owner)
			{
				connection = connection2;
				return true;
			}
		}
		connection = default(Connection);
		return false;
	}

	public void AddConnection(Region region, IConnectionOwner owner)
	{
		if (!ConnectionExists(region, owner, out var _))
		{
			connectedRegions.Add(new Connection(region, owner));
		}
	}

	public void RemoveConnection(Region region, IConnectionOwner owner)
	{
		if (ConnectionExists(region, owner, out var connection))
		{
			connectedRegions.Remove(connection);
		}
	}

	public void RemoveAllConnectionsByOwner(object owner)
	{
		int num = 0;
		while (num < connectedRegions.Length)
		{
			Connection objectT = connectedRegions[num];
			if (objectT.owner == owner)
			{
				connectedRegions.Remove(objectT);
			}
			else
			{
				num++;
			}
		}
	}

	public void RemoveAllConnectionsByOwnerAndTarget(Region region, IConnectionOwner owner)
	{
		int num = 0;
		while (num < connectedRegions.Length)
		{
			Connection objectT = connectedRegions[num];
			if (objectT.owner == owner && objectT.region == region)
			{
				connectedRegions.Remove(objectT);
			}
			else
			{
				num++;
			}
		}
	}

	bool IConnectionOwner.IsConnectionValid(IConnectionKey key, bool teleporting)
	{
		return true;
	}

	private void UpdateBounds()
	{
		Vector2 v = default(Vector2);
		bool flag = false;
		for (int i = 0; i < shapes.Length; i++)
		{
			for (int j = 0; j < shapes[i].points.Length; j++)
			{
				flag = true;
				v = shapes[i].points[j];
			}
		}
		worldSpaceBounds = default(Bounds);
		if (!flag)
		{
			return;
		}
		localToWorldCached = xformData.xform.localToWorldMatrix;
		worldToLocalCached = xformData.xform.worldToLocalMatrix;
		float freeMoveStepHeight = BaseSettings<TeleportSettings>.Inst.freeMoveStepHeight;
		Vector3 zero = Vector3X.zero;
		Vector3 vector = localToWorldCached.MultiplyPoint3x4(v.xNy(0f - freeMoveStepHeight));
		Vector3 vector2 = localToWorldCached.MultiplyPoint3x4(v.xNy(freeMoveStepHeight));
		for (int k = 0; k < shapes.Length; k++)
		{
			Shape shape = shapes[k];
			for (int l = 0; l < shape.points.Length; l++)
			{
				Vector2 vector3 = shape.points[l];
				zero.x = vector3.x;
				zero.z = vector3.y;
				zero.y = 0f - freeMoveStepHeight;
				Vector3 vector4 = localToWorldCached.MultiplyPoint3x4(zero);
				zero.y = freeMoveStepHeight;
				Vector3 vector5 = localToWorldCached.MultiplyPoint3x4(zero);
				if (vector.x > vector4.x)
				{
					vector.x = vector4.x;
				}
				if (vector.y > vector4.y)
				{
					vector.y = vector4.y;
				}
				if (vector.z > vector4.z)
				{
					vector.z = vector4.z;
				}
				if (vector.x > vector5.x)
				{
					vector.x = vector5.x;
				}
				if (vector.y > vector5.y)
				{
					vector.y = vector5.y;
				}
				if (vector.z > vector5.z)
				{
					vector.z = vector5.z;
				}
				if (vector2.x < vector4.x)
				{
					vector2.x = vector4.x;
				}
				if (vector2.y < vector4.y)
				{
					vector2.y = vector4.y;
				}
				if (vector2.z < vector4.z)
				{
					vector2.z = vector4.z;
				}
				if (vector2.x < vector5.x)
				{
					vector2.x = vector5.x;
				}
				if (vector2.y < vector5.y)
				{
					vector2.y = vector5.y;
				}
				if (vector2.z < vector5.z)
				{
					vector2.z = vector5.z;
				}
			}
		}
		worldSpaceBounds.center = (vector + vector2) * 0.5f;
		worldSpaceBounds.extents = (vector2 - vector) * 0.5f;
	}

	public static void LockToRegion(Region regionToLockTo, MRBase owner)
	{
		Region[] regions = owner.regions;
		foreach (Region region in regions)
		{
			if (region != regionToLockTo)
			{
				region.Disable();
			}
		}
		NexusFullScreenPass.Inst.ForceUpdateLastValidPosition();
	}

	public static void UnlockFromRegion(Region regionToUnlockFrom, MRBase owner)
	{
		Region[] regions = owner.regions;
		foreach (Region region in regions)
		{
			if (region != regionToUnlockFrom)
			{
				region.Enable();
			}
		}
		NexusFullScreenPass.Inst.ForceUpdateLastValidPosition();
	}

	public void OnEnterRegion()
	{
		for (int i = 0; i < regionEvents.Length; i++)
		{
			regionEvents[i].OnEnterRegion();
		}
	}

	public void OnExitRegion()
	{
		for (int i = 0; i < regionEvents.Length; i++)
		{
			regionEvents[i].OnExitRegion();
		}
	}
}
[RequireComponent(typeof(MeshCollider))]
public class Stairway : MonoBehaviour, IAwakeEvent, IUpdateEvent, Region.IConnectionOwner, IPrebuildEvent
{
	[Serializable]
	private struct Edge
	{
		public int i0;

		public int i1;

		public Vector3 v0;

		public Vector3 v1;

		public Vector3 up;

		public Vector3 right;

		public Vector3 forward;

		public Edge(int _i0, int _i1, Vector3 _v0, Vector3 _v1, Vector3 _up, Vector3 _right, Vector3 _forward)
		{
			i0 = _i0;
			i1 = _i1;
			v0 = _v0;
			v1 = _v1;
			up = _up;
			right = _right;
			forward = _forward;
		}

		public Vector3 ToVector()
		{
			return v1 - v0;
		}

		public Vector3 ToDirection()
		{
			return (v1 - v0).normalized;
		}
	}

	public struct ValidPos
	{
		public Stairway stairway;

		public Vector3 worldPos;

		public bool valid;

		public bool requiredEdgeRepositioning;

		public bool requiredPlaneRepositioning;
	}

	public MRBase owner;

	[SerializeField]
	private Edge[] stairwayEdges;

	private MeshCollider meshCollider;

	private Mesh mesh;

	private Region[] connectedRegions;

	bool Region.IConnectionOwner.IsConnectionValid(Region.IConnectionKey key, bool teleporting)
	{
		return true;
	}

	public ValidPos FindNearestValidPoint(Vector3 worldTargetPos, Vector3 upDir)
	{
		Vector3 vector = base.transform.InverseTransformPoint(worldTargetPos);
		ValidPos validPos = default(ValidPos);
		validPos.stairway = this;
		if (Vector3.Dot(base.transform.up, upDir) < 0.99f)
		{
			return validPos;
		}
		float freeMoveStepHeight = BaseSettings<TeleportSettings>.Inst.freeMoveStepHeight;
		float maxXZDistanceToRegionSnap = BaseSettings<TeleportSettings>.Inst.maxXZDistanceToRegionSnap;
		Ray ray = new Ray(worldTargetPos + upDir * freeMoveStepHeight, -upDir);
		RaycastHit hitInfo = default(RaycastHit);
		if (meshCollider.Raycast(ray, out hitInfo, freeMoveStepHeight * 2f))
		{
			validPos.worldPos = hitInfo.point;
			validPos.valid = true;
		}
		else if (stairwayEdges != null)
		{
			ValidPos result = validPos;
			float num = float.MaxValue;
			Edge[] array = stairwayEdges;
			for (int i = 0; i < array.Length; i++)
			{
				Edge edge = array[i];
				Matrix4x4 matrix4x = Matrix4x4.TRS(edge.v0, Quaternion.LookRotation(edge.ToDirection(), edge.up), Vector3.one);
				Matrix4x4 inverse = matrix4x.inverse;
				Plane plane = new Plane(edge.up, edge.v0);
				Ray ray2 = new Ray(vector + Vector3.up * freeMoveStepHeight, Vector3.down);
				if (!plane.Raycast(ray2, out var enter) || enter > freeMoveStepHeight * 2f)
				{
					continue;
				}
				Vector3 point = inverse.MultiplyPoint3x4(ray2.GetPoint(enter));
				if (point.x < 0f)
				{
					Vector3 zero = Vector3.zero;
					Vector3 vector2 = inverse.MultiplyPoint3x4(edge.v1);
					bool flag = point.z < zero.z || point.z > vector2.z;
					if (flag)
					{
						point.z = Mathf.Clamp(point.z, zero.z, vector2.z);
					}
					point.x = 0f;
					Vector3 position = matrix4x.MultiplyPoint3x4(point);
					Vector3 vector3 = base.transform.TransformPoint(position);
					float num2 = Vector3.Distance(vector3, worldTargetPos);
					Vector3 vector4 = vector3 - worldTargetPos;
					if (!(Mathf.Abs(vector4.y) > freeMoveStepHeight * 2f) && !(Mathf.Abs(vector4.x) > maxXZDistanceToRegionSnap) && !(Mathf.Abs(vector4.z) > maxXZDistanceToRegionSnap) && num2 < num)
					{
						result.requiredPlaneRepositioning = flag;
						result.worldPos = vector3;
						result.valid = true;
						result.requiredEdgeRepositioning = true;
						num = num2;
					}
				}
			}
			if (result.valid)
			{
				return result;
			}
		}
		return validPos;
	}

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		this.owner = owner;
		base.gameObject.layer = 14;
		meshCollider = GetComponent<MeshCollider>();
		MeshFilter component = GetComponent<MeshFilter>();
		mesh = component.sharedMesh;
		connectedRegions = GetConnectedRegions(owner.regions, mesh.vertices, base.transform);
		UpdateRegionConnections();
		pb_Object component2 = GetComponent<pb_Object>();
		MeshRenderer component3 = GetComponent<MeshRenderer>();
		component2.dontDestroyMeshOnDelete = true;
		UnityEngine.Object.Destroy(component2);
		UnityEngine.Object.Destroy(component3);
	}

	void IUpdateEvent.OnUpdateLR()
	{
	}

	void IPrebuildEvent.OnPrebuildRoot(bool isPrefab)
	{
		Region[] componentsInChildren = base.transform.root.GetComponentsInChildren<Region>();
		IdentifyStairwayEdges(this, componentsInChildren);
	}

	protected void OnDestroy()
	{
		if (connectedRegions != null)
		{
			Region[] array = connectedRegions;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].RemoveAllConnectionsByOwner(this);
			}
		}
	}

	protected void OnEnable()
	{
		UpdateRegionConnections();
	}

	protected void OnDisable()
	{
		UpdateRegionConnections();
	}

	private void UpdateRegionConnections()
	{
		if (connectedRegions == null)
		{
			return;
		}
		bool flag = base.isActiveAndEnabled;
		Region[] array = connectedRegions;
		foreach (Region region in array)
		{
			Region[] array2 = connectedRegions;
			foreach (Region region2 in array2)
			{
				if (!(region == region2) && region.ConnectionExists(region2, this) != flag)
				{
					if (flag)
					{
						region.AddConnection(region2, this);
						region2.AddConnection(region, this);
					}
					else
					{
						region.RemoveConnection(region2, this);
						region2.RemoveConnection(region, this);
					}
				}
			}
		}
	}

	public static bool IsAlignedToRegions(Region[] regions, Vector3[] verts, Transform stairwayTransform)
	{
		foreach (Vector3 position in verts)
		{
			Vector3 worldPos = stairwayTransform.TransformPoint(position);
			bool flag = false;
			foreach (Region targetRegion in regions)
			{
				flag |= PositionIsValidOnRegion(targetRegion, worldPos, stairwayTransform.up);
			}
			if (!flag)
			{
				return false;
			}
		}
		return true;
	}

	public static Region[] GetConnectedRegions(Region[] regions, Vector3[] verts, Transform stairwayTransform)
	{
		List<Region> list = new List<Region>();
		foreach (Vector3 position in verts)
		{
			Vector3 worldPos = stairwayTransform.TransformPoint(position);
			foreach (Region region in regions)
			{
				if (!list.Contains(region) && PositionIsValidOnRegion(region, worldPos, stairwayTransform.up))
				{
					list.Add(region);
				}
			}
		}
		return list.ToArray();
	}

	private static bool PositionIsValidOnRegion(Region targetRegion, Vector3 worldPos, Vector3 stairwayUpDirection)
	{
		if (!targetRegion.IsAlignedToUpDirection(stairwayUpDirection))
		{
			return false;
		}
		Region.ValidPos validPos = targetRegion.FindNearestValidPoint(worldPos, useMaximumConstraints: true, allowOutOfRegionEdgeSnapping: true, 0.01f, 0.01f, BaseSettings<TeleportSettings>.Inst.maxXZDistanceToRegionSnap);
		if (!validPos.valid)
		{
			return false;
		}
		if (validPos.requiredRepositionToInnerBorder && Vector3.Distance(validPos.worldPos, worldPos) > 0.001f)
		{
			return false;
		}
		return true;
	}

	public static void IdentifyStairwayEdges(Stairway stairway, Region[] regions)
	{
		List<Edge> list = new List<Edge>();
		MeshFilter component = stairway.GetComponent<MeshFilter>();
		Edge[] externalEdges = GetExternalEdges(component.sharedMesh);
		Vector3[] vertices = component.sharedMesh.vertices;
		foreach (Edge edge in externalEdges)
		{
			if (IsStairwayEdge(stairway.transform, edge, vertices, regions))
			{
				list.Add(edge);
			}
		}
		stairway.stairwayEdges = list.ToArray();
	}

	private static bool IsStairwayEdge(Transform stairTransform, Edge edge, Vector3[] verts, Region[] regions)
	{
		Vector3 worldPos = stairTransform.TransformPoint(verts[edge.i0]);
		Vector3 worldPos2 = stairTransform.TransformPoint(verts[edge.i1]);
		Region.ValidPos closestValidPos = Region.GetClosestValidPos(stairTransform.up, worldPos, regions);
		Region.ValidPos closestValidPos2 = Region.GetClosestValidPos(stairTransform.up, worldPos2, regions);
		return closestValidPos.region != closestValidPos2.region;
	}

	private static Edge[] GetExternalEdges(Mesh mesh)
	{
		List<Edge> list = new List<Edge>();
		int[] triangles = mesh.triangles;
		Vector3[] vertices = mesh.vertices;
		for (int i = 0; i < triangles.Length; i += 3)
		{
			int num = triangles[i];
			int num2 = triangles[i + 1];
			int num3 = triangles[i + 2];
			Vector3 vector = vertices[num];
			Vector3 vector2 = vertices[num2];
			Vector3 vector3 = vertices[num3];
			Vector3 normalized = Vector3.Cross(vector2 - vector, vector3 - vector).normalized;
			if (!MeshX.CheckIfEdgeIsDuplicated(vector, vector2, triangles, vertices, i))
			{
				Vector3 normalized2 = (vector2 - vector).normalized;
				Vector3 right = Vector3.Cross(normalized, normalized2);
				list.Add(new Edge(num, num2, vector, vector2, normalized, right, normalized2));
			}
			if (!MeshX.CheckIfEdgeIsDuplicated(vector2, vector3, triangles, vertices, i))
			{
				Vector3 normalized3 = (vector3 - vector2).normalized;
				Vector3 right2 = Vector3.Cross(normalized, normalized3);
				list.Add(new Edge(num2, num3, vector2, vector3, normalized, right2, normalized3));
			}
			if (!MeshX.CheckIfEdgeIsDuplicated(vector3, vector, triangles, vertices, i))
			{
				Vector3 normalized4 = (vector - vector3).normalized;
				Vector3 right3 = Vector3.Cross(normalized, normalized4);
				list.Add(new Edge(num3, num, vector3, vector, normalized, right3, normalized4));
			}
		}
		return list.ToArray();
	}
}
public class TelepadArrow : MonoBehaviour, IPrebuildEvent
{
	private TeleportUIHelper helper;

	[SerializeField]
	private MeshRenderer mr;

	public bool IsVisible => helper.LiveTargetScale.x > 0f;

	void IPrebuildEvent.OnPrebuildRoot(bool isPrefab)
	{
		mr = GetComponent<MeshRenderer>();
		mr.enabled = false;
	}

	public void OnAwakeLR()
	{
		mr.enabled = true;
		helper = new TeleportUIHelper(mr, BaseSettings<TeleportSettings>.Inst.arcStartColor);
		helper.SetAlphaImmediate(1f);
		helper.SetScaleImmediate(Vector3.zero);
	}

	public void OnUpdateLR()
	{
	}

	public void OnShow(float showAlpha, float delay = 0f)
	{
		helper.AnimateScale(1f, 0.1f, delay);
	}

	public void OnHide()
	{
		helper.AnimateScale(0f, 0.05f, 0f);
	}
}
public class TelepadMovePrompt : MonoBehaviour
{
}
public class Telepoint : MonoBehaviour, IPrebuildEvent
{
	public bool frontFacingDirectionRequired;

	[ReadOnly]
	public HagletTrigger cutsceneTrigger;

	public HagletTrigger OnTeleport = new HagletTrigger();

	[SerializeField]
	[HideInInspector]
	private bool _isTutorialTelepoint;

	[SerializeField]
	[HideInInspector]
	private bool _isCutsceneTelepoint;

	private MaterialPropertyBlock mpb;

	private MeshRenderer arrowMR;

	private MeshRenderer ringMR;

	private MeshRenderer outlineMR;

	private float currentArrowAlpha;

	private float targetArrowAlpha;

	private float currentRingAlpha;

	private float targetRingAlpha;

	private float currentOutlineAlpha;

	private float targetOutlineAlpha;

	private float currentHeight;

	private float targetHeight;

	private float currentEnabled;

	private float targetEnabled;

	private float wasEnabled;

	private Transform xForm;

	private Transform ringXF;

	private Transform arrowXF;

	private Vector3 up;

	public bool IsHidden => targetEnabled == 0f;

	public bool IsTutorialTelepoint => _isTutorialTelepoint;

	public bool IsCutsceneTelepoint => _isCutsceneTelepoint;

	void IPrebuildEvent.OnPrebuildRoot(bool isPrefab)
	{
		base.gameObject.SetActive(value: false);
		_isCutsceneTelepoint = GetComponentInParent<HAGIS_Cutscene_Base>() != null || GetComponentInParent<HAGIS_Death_Cutscene>() != null || GetComponentInParent<HAGIS_DeathAlt_Cutscene>() != null;
		_isTutorialTelepoint = base.gameObject.scene.name == "SC_TutorialSequence_LOGIC";
	}

	[ContextMenu("Hide")]
	public void Hide()
	{
		targetEnabled = 0f;
	}

	[ContextMenu("Show")]
	public void Show()
	{
		targetEnabled = 1f;
	}

	protected void OnEnable()
	{
		targetEnabled = wasEnabled;
		currentEnabled = 0f;
	}

	protected void OnDisable()
	{
		wasEnabled = targetEnabled;
		targetEnabled = 0f;
	}

	public void OnAwakeLR()
	{
		TeleportSettings inst = BaseSettings<TeleportSettings>.Inst;
		Color value = (_isCutsceneTelepoint ? inst.cutsceneTelepointBaseColor : inst.defaultTelepointBaseColor);
		mpb = new MaterialPropertyBlock();
		mpb.SetColor(ShaderPID._Color, value);
		mpb.SetFloat(ShaderPID._Alpha, 0f);
		xForm = base.transform;
		up = xForm.up;
		TelepointRing componentInChildren = GetComponentInChildren<TelepointRing>(includeInactive: true);
		TelepointArrow componentInChildren2 = GetComponentInChildren<TelepointArrow>(includeInactive: true);
		TelepointOutline componentInChildren3 = GetComponentInChildren<TelepointOutline>(includeInactive: true);
		ringXF = componentInChildren.transform;
		arrowXF = componentInChildren2.transform;
		ringMR = componentInChildren.GetComponent<MeshRenderer>();
		arrowMR = componentInChildren2.GetComponent<MeshRenderer>();
		outlineMR = componentInChildren3.GetComponent<MeshRenderer>();
		ringXF.localScale = new Vector3(1f, 1f, 0f);
		ringMR.SetPropertyBlock(mpb);
		arrowMR.SetPropertyBlock(mpb);
		outlineMR.SetPropertyBlock(mpb);
		ringMR.enabled = false;
		arrowMR.enabled = false;
		outlineMR.enabled = false;
		componentInChildren2.transform.localPosition = new Vector3(0f, inst.teleportArrowRestHeight, 0f);
		wasEnabled = (targetEnabled = (currentEnabled = 1f));
		base.gameObject.SetActive(value: true);
	}

	public bool IsAngleSnappingRequired()
	{
		if (CC.Inst.trackingMode == TrackingMode.FrontFacing)
		{
			return frontFacingDirectionRequired;
		}
		return false;
	}

	public static void OnUpdateLR(Telepoint[] telepoints)
	{
		Vector3 headPosition = IC.GetHeadPosition();
		CC inst = CC.Inst;
		Vector3 vector = inst.transform.up;
		TelepadArrow telepadArrow = inst.teleporter.telepadArrow;
		bool isVisible = telepadArrow.IsVisible;
		Vector3 position = telepadArrow.transform.position;
		TeleportSettings inst2 = BaseSettings<TeleportSettings>.Inst;
		float num = inst2.telepointStoodOnDistance * inst2.telepointStoodOnDistance;
		bool hintsEnabled = LR.Inst.saveDataSettings.hintsEnabled;
		AnimationCurve telepointArrowAlphaByDistanceCurve = inst2.telepointArrowAlphaByDistanceCurve;
		AnimationCurve telepointRingAlphaByDistanceCurve = inst2.telepointRingAlphaByDistanceCurve;
		AnimationCurve telepointOutlineAlphaByDistanceCurve = inst2.telepointOutlineAlphaByDistanceCurve;
		float num2 = inst2.telepointMaxVisibleDistance * inst2.telepointMaxVisibleDistance;
		float maxDelta = 5f * Time.deltaTime;
		foreach (Telepoint telepoint in telepoints)
		{
			if ((hintsEnabled || telepoint._isCutsceneTelepoint || telepoint._isTutorialTelepoint) && (telepoint.targetEnabled != 0f || telepoint.currentEnabled != 0f) && vector.x * telepoint.up.x + telepoint.up.y * telepoint.up.y + vector.z * telepoint.up.z > 0.99f)
			{
				if (telepoint.currentEnabled != telepoint.targetEnabled)
				{
					telepoint.currentEnabled = Mathf.MoveTowards(telepoint.currentEnabled, telepoint.targetEnabled, maxDelta);
				}
				Vector3 vector2 = telepoint.xForm.InverseTransformPoint(headPosition);
				vector2.y = 0f;
				float sqrMagnitude = vector2.sqrMagnitude;
				if (sqrMagnitude < num)
				{
					inst.telepointStoodOn = telepoint;
				}
				else if ((object)inst.telepointStoodOn == telepoint)
				{
					inst.telepointStoodOn = null;
				}
				float num3;
				if (isVisible)
				{
					Vector3 vector3 = telepoint.xForm.InverseTransformPoint(position);
					vector3.y = 0f;
					num3 = vector3.sqrMagnitude;
				}
				else
				{
					num3 = float.PositiveInfinity;
				}
				if (((sqrMagnitude < num3) ? sqrMagnitude : num3) < num2)
				{
					float num4 = Mathf.Sqrt(sqrMagnitude);
					float num5 = inst2.telepointHeightByHeadDistanceCurve.Evaluate(num4);
					float num6 = Mathf.Sqrt(num3);
					float num7 = inst2.telepointHeightByArrowDistanceCurve.Evaluate(num6);
					float time = ((num4 < num6) ? num4 : num6);
					if (num5 > num7 || num4 < num6)
					{
						telepoint.targetHeight = num5;
					}
					else
					{
						telepoint.targetHeight = num7;
					}
					telepoint.targetArrowAlpha = telepoint.currentEnabled * telepointArrowAlphaByDistanceCurve.Evaluate(time);
					telepoint.targetRingAlpha = telepoint.currentEnabled * telepointRingAlphaByDistanceCurve.Evaluate(time);
					telepoint.targetOutlineAlpha = telepoint.currentEnabled * telepointOutlineAlphaByDistanceCurve.Evaluate(time);
				}
				else
				{
					telepoint.targetHeight = (telepoint.targetArrowAlpha = (telepoint.targetOutlineAlpha = (telepoint.targetRingAlpha = 0f)));
				}
			}
			else
			{
				telepoint.targetHeight = (telepoint.targetArrowAlpha = (telepoint.targetOutlineAlpha = (telepoint.targetRingAlpha = 0f)));
				if ((object)inst.telepointStoodOn == telepoint)
				{
					inst.telepointStoodOn = null;
				}
			}
			if (telepoint.targetHeight != telepoint.currentHeight)
			{
				telepoint.currentHeight = Mathf.MoveTowards(telepoint.currentHeight, telepoint.targetHeight, maxDelta);
				telepoint.ringXF.localScale = new Vector3(1f, 1f, telepoint.currentHeight);
				telepoint.arrowXF.localPosition = new Vector3(0f, Mathf.Lerp(0f, inst2.teleportArrowRestHeight, telepoint.currentHeight), 0f);
			}
			if (telepoint.targetRingAlpha != telepoint.currentRingAlpha)
			{
				telepoint.currentRingAlpha = Mathf.MoveTowards(telepoint.currentRingAlpha, telepoint.targetRingAlpha, maxDelta);
				telepoint.mpb.SetFloat(ShaderPID._Alpha, telepoint.currentRingAlpha);
				telepoint.ringMR.SetPropertyBlock(telepoint.mpb);
				telepoint.ringMR.enabled = telepoint.currentRingAlpha > 0f;
			}
			if (telepoint.targetOutlineAlpha != telepoint.currentOutlineAlpha)
			{
				telepoint.currentOutlineAlpha = Mathf.MoveTowards(telepoint.currentOutlineAlpha, telepoint.targetOutlineAlpha, maxDelta);
				telepoint.mpb.SetFloat(ShaderPID._Alpha, telepoint.currentOutlineAlpha);
				telepoint.outlineMR.SetPropertyBlock(telepoint.mpb);
				telepoint.outlineMR.enabled = telepoint.currentOutlineAlpha > 0f;
			}
			if (telepoint.targetArrowAlpha != telepoint.currentArrowAlpha)
			{
				telepoint.currentArrowAlpha = Mathf.MoveTowards(telepoint.currentArrowAlpha, telepoint.targetArrowAlpha, maxDelta);
				telepoint.mpb.SetFloat(ShaderPID._Alpha, telepoint.currentArrowAlpha);
				telepoint.arrowMR.SetPropertyBlock(telepoint.mpb);
				telepoint.arrowMR.enabled = telepoint.currentArrowAlpha > 0f;
			}
		}
	}
}
public class TelepointArrow : MonoBehaviour
{
}
public class TelepointOutline : MonoBehaviour
{
}
public class TelepointRing : MonoBehaviour
{
}
public class TeleportCross : MonoBehaviour, IPrebuildEvent
{
	private TeleportUIHelper helper;

	[SerializeField]
	private MeshRenderer mr;

	public bool IsVisible => helper.LiveTargetScale.x > 0f;

	void IPrebuildEvent.OnPrebuildRoot(bool isPrefab)
	{
		mr = GetComponent<MeshRenderer>();
		mr.enabled = false;
	}

	public void OnAwakeLR()
	{
		mr.enabled = true;
		helper = new TeleportUIHelper(mr, BaseSettings<TeleportSettings>.Inst.arcColorInvalid);
		helper.SetAlphaImmediate(1f);
		helper.SetScaleImmediate(Vector3.zero);
	}

	public void OnUpdateLR()
	{
	}

	public void OnShow(float showAlpha, float delay = 0f)
	{
		helper.AnimateScale(1f, 0.1f, delay);
	}

	public void OnHide()
	{
		helper.AnimateScale(0f, 0.05f, 0f);
	}
}
public class TeleportUIHelper
{
	private MeshRenderer[] objMRs;

	private Vector3[] objScales;

	private Vector3[] objScalesStart;

	private MaterialPropertyBlock objMPB;

	private int shaderColorID;

	public Color objColor = new Color(1f, 1f, 1f, 0f);

	private Color tintColor = new Color(1f, 1f, 1f, 1f);

	private Vector3 _liveTargetScale;

	[NonSerialized]
	[HideInInspector]
	public bool IsFocusing;

	private IHaglet<float, float, float> alphaRoutine;

	private IHaglet<Color> colorRoutine;

	private IHaglet<Vector3, Vector3> pingRoutine;

	private IHaglet focusRoutine;

	private IHaglet<bool> scaleFocusInOutRoutine;

	private IHaglet<Vector3, float, float, AnimationCurve> scaleRoutine;

	public Vector3 LiveTargetScale
	{
		get
		{
			return _liveTargetScale;
		}
		set
		{
			_liveTargetScale = value;
		}
	}

	public bool IsScaling
	{
		get
		{
			if (!scaleRoutine.started)
			{
				return scaleFocusInOutRoutine.started;
			}
			return true;
		}
	}

	public bool IsScalingFocus => scaleFocusInOutRoutine.started;

	private Vector3 FocusSize => Vector3.one * 0.3f * (1f + Mathf.Sin(Time.timeSinceLevelLoad * 5f) * 0.1f);

	public TeleportUIHelper(MeshRenderer mr, Color color)
		: this(new MeshRenderer[1] { mr }, color)
	{
	}

	public TeleportUIHelper(MeshRenderer[] mrs, Color color)
	{
		objMRs = mrs;
		objMPB = new MaterialPropertyBlock();
		shaderColorID = Shader.PropertyToID("_Color");
		objColor = color;
		objScales = new Vector3[mrs.Length];
		objScalesStart = new Vector3[mrs.Length];
		for (int i = 0; i < objScales.Length; i++)
		{
			objScales[i] = mrs[i].transform.localScale;
		}
		SetAlphaImmediate(0f);
		Haglet.Create(out alphaRoutine, (Routine.Func3<float, float, float>)AlphaRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out colorRoutine, (Routine.Func1<Color>)ColorRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out pingRoutine, (Routine.Func2<Vector3, Vector3>)PingRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out focusRoutine, FocusRoutine);
		Haglet.Create(out scaleFocusInOutRoutine, (Routine.Func1<bool>)ScaleFocusInOutRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out scaleRoutine, (Routine.Func4<Vector3, float, float, AnimationCurve>)ScaleRoutine, (string)null, startNow: false, (int?)null, (string)null);
	}

	public void AlphaAnimateTo(float targetAlpha, float duration, float delay)
	{
		alphaRoutine.Start(targetAlpha, delay, duration, resetIfStarted: true);
	}

	public void ColorAnimateTo(Color targetColor)
	{
		colorRoutine.Start(targetColor, resetIfStarted: true);
	}

	public void AnimatePing()
	{
		if (!pingRoutine.started)
		{
			if (focusRoutine.started)
			{
				StopFocus(immediate: true);
			}
			pingRoutine.Start();
		}
	}

	public void StopPing()
	{
		if (pingRoutine.started)
		{
			pingRoutine.Stop();
		}
	}

	public void AnimateScale(float targetScale, float time, float delay, AnimationCurve curve = null)
	{
		scaleRoutine.Start(Vector3.one * targetScale, time, delay, curve, resetIfStarted: true);
	}

	public void AnimateScale(Vector3 targetScale, float time, float delay, AnimationCurve curve = null)
	{
		scaleRoutine.Start(targetScale, time, delay, curve, resetIfStarted: true);
	}

	public void AnimateFocus()
	{
		if (pingRoutine.started)
		{
			StopPing();
		}
		focusRoutine.Start(resetIfStarted: true);
	}

	public void StopFocus(bool immediate = false)
	{
		if (immediate)
		{
			focusRoutine.Stop(complete: true);
		}
		else
		{
			scaleFocusInOutRoutine.Start(arg0: false, resetIfStarted: true);
		}
		IsFocusing = false;
	}

	public void SetAlphaImmediate(float targetAlpha)
	{
		objColor.a = targetAlpha;
		objMPB.SetColor(shaderColorID, objColor * tintColor);
		MeshRenderer[] array = objMRs;
		foreach (MeshRenderer obj in array)
		{
			obj.SetPropertyBlock(objMPB);
			obj.enabled = targetAlpha >= 0f;
		}
	}

	public void SetAdditionalTintColor(Color color)
	{
		tintColor.r = color.r;
		tintColor.g = color.g;
		tintColor.b = color.b;
		objMPB.SetColor(shaderColorID, objColor * tintColor);
		MeshRenderer[] array = objMRs;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetPropertyBlock(objMPB);
		}
	}

	public void SetAdditionalTintAlpha(float alpha)
	{
		tintColor.a = alpha;
		objMPB.SetColor(shaderColorID, objColor * tintColor);
		MeshRenderer[] array = objMRs;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetPropertyBlock(objMPB);
		}
	}

	public void SetColorImmediate(Color color)
	{
		objColor.r = color.r;
		objColor.g = color.g;
		objColor.b = color.b;
		objMPB.SetColor(shaderColorID, objColor * tintColor);
		MeshRenderer[] array = objMRs;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetPropertyBlock(objMPB);
		}
	}

	public void SetScaleImmediate(Vector3 scale)
	{
		bool enabled = scale == Vector3X.zero;
		MeshRenderer[] array = objMRs;
		foreach (MeshRenderer obj in array)
		{
			obj.transform.localScale = scale;
			obj.enabled = enabled;
		}
	}

	private IEnumerator<Routine.Yield> AlphaRoutine(float targetAlpha, float delay, float duration)
	{
		if (delay > 0f)
		{
			yield return Wait.For.Seconds(delay);
		}
		float beginAlpha = objColor.a;
		float time = 0f;
		while (time < duration)
		{
			time += IC.DeltaTime;
			float t = time / duration;
			float alphaImmediate = Mathf.LerpUnclamped(beginAlpha, targetAlpha, t);
			SetAlphaImmediate(alphaImmediate);
			yield return Wait.For.LRUpdates(1);
		}
		SetAlphaImmediate(targetAlpha);
	}

	private IEnumerator<Routine.Yield> ColorRoutine(Color target)
	{
		float num = 7f;
		float magnitude = (objColor.GetRGB() - target.GetRGB()).magnitude;
		Color beginColor = objColor;
		float timeMax = magnitude / num;
		float time = 0f;
		while (time < timeMax)
		{
			time += IC.DeltaTime;
			float t = time / timeMax;
			Color colorImmediate = Color.Lerp(beginColor, target, t);
			SetColorImmediate(colorImmediate);
			yield return Wait.For.LRUpdates(1);
		}
	}

	private IEnumerator<Routine.Yield> PingRoutine(Vector3 from, Vector3 to)
	{
		UnityEngine.Debug.Log(from + to);
		int i = 0;
		while (i < 3)
		{
			float timeMax = 2f;
			float time = 0f;
			int j;
			while (time < timeMax)
			{
				time += IC.DeltaTime;
				float time2 = time / timeMax;
				MeshRenderer[] array = objMRs;
				for (j = 0; j < array.Length; j++)
				{
					array[j].transform.localScale = Vector3.one * BaseSettings<TeleportSettings>.Inst.telepadPointRadius * BaseSettings<TeleportSettings>.Inst.pingScaleCurve.Evaluate(time2);
				}
				SetAlphaImmediate(BaseSettings<TeleportSettings>.Inst.pingAlphaCurve.Evaluate(time2));
				yield return Wait.For.LRUpdates(1);
			}
			j = i + 1;
			i = j;
		}
	}

	private IEnumerator<Routine.Yield> FocusRoutine()
	{
		IsFocusing = true;
		yield return scaleFocusInOutRoutine.Start(arg0: true, resetIfStarted: true);
		while (IsFocusing)
		{
			MeshRenderer[] array = objMRs;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].transform.localScale = FocusSize;
			}
			yield return Wait.For.LRUpdates(1);
		}
	}

	private IEnumerator<Routine.Yield> ScaleFocusInOutRoutine(bool scaleIn)
	{
		SetAlphaImmediate(1f);
		Vector3 startScale = objMRs[0].transform.localScale;
		float animTime = 0.15f;
		float t = 0f;
		while (t < animTime)
		{
			t += IC.DeltaTime;
			Vector3 b = (scaleIn ? FocusSize : Vector3.zero);
			MeshRenderer[] array = objMRs;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].transform.localScale = Vector3.Lerp(startScale, b, MathfX.EaseInOutCurve(t / animTime));
			}
			yield return Wait.For.LRUpdates(1);
		}
		for (int j = 0; j < objMRs.Length; j++)
		{
			objMRs[j].enabled = !scaleIn;
		}
	}

	private IEnumerator<Routine.Yield> ScaleRoutine(Vector3 targetScale, float time, float delay, AnimationCurve curve)
	{
		if (targetScale != Vector3X.zero)
		{
			for (int i = 0; i < objMRs.Length; i++)
			{
				objMRs[i].enabled = true;
			}
		}
		LiveTargetScale = targetScale;
		yield return Wait.For.Seconds(delay);
		for (int j = 0; j < objMRs.Length; j++)
		{
			objScalesStart[j] = objMRs[j].transform.localScale;
		}
		float t = 0f;
		while (t < time)
		{
			t += IC.DeltaTime;
			float t2 = curve?.Evaluate(t / time) ?? (t / time);
			for (int k = 0; k < objMRs.Length; k++)
			{
				MeshRenderer obj = objMRs[k];
				Vector3 a = objScalesStart[k];
				targetScale = LiveTargetScale;
				Vector3 b = Vector3.Scale(objScales[k], targetScale);
				obj.transform.localScale = Vector3.LerpUnclamped(a, b, t2);
			}
			yield return Wait.For.LRUpdates(1);
		}
		bool flag = targetScale == Vector3X.zero;
		for (int l = 0; l < objMRs.Length; l++)
		{
			MeshRenderer meshRenderer = objMRs[l];
			_ = ref objScalesStart[l];
			Vector3 localScale = Vector3.Scale(objScales[l], targetScale);
			meshRenderer.transform.localScale = localScale;
			if (flag)
			{
				meshRenderer.enabled = false;
			}
		}
	}
}
public class TrackingCircle : MonoBehaviour
{
	[ReadOnly]
	public MeshRenderer mr;

	[ReadOnly]
	public MeshFilter mf;

	public Color color;

	private float alphaOrig;

	private float baseYOffset;

	[NonSerialized]
	[HideInInspector]
	public float yOffset;

	private int shaderIDColor;

	public float ringRadius = 0.4f;

	private MaterialPropertyBlock mpb;

	public Transform ringParent;

	public Transform feetParent;

	private RaycastHit[] hitArray = new RaycastHit[4];

	public void OnAwakeLR()
	{
		mr = GetComponent<MeshRenderer>();
		mf = GetComponent<MeshFilter>();
		mpb = new MaterialPropertyBlock();
		shaderIDColor = Shader.PropertyToID("_Color");
		color = mr.sharedMaterial.GetColor(shaderIDColor);
		alphaOrig = color.a;
		baseYOffset = BaseSettings<UISettings>.Inst.trackingCircleBaseHeight;
		yOffset = baseYOffset;
	}

	public void OnUpdateLR()
	{
		bool boundaryVisible = OVRPlugin.GetBoundaryVisible();
		Vector3 headPosition = IC.GetHeadPosition();
		Vector3 normalized = (base.transform.position - headPosition).normalized;
		float num = Vector3.Dot(MainCamera.Inst.transform.forward, normalized);
		boundaryVisible |= num > BaseSettings<TeleportSettings>.Inst.minCCVisibleAngle;
		yOffset = baseYOffset;
		Transform transform = (boundaryVisible ? ringParent : feetParent);
		Vector3 up = CC.Inst.transform.up;
		float y = base.transform.parent.position.y;
		float num2 = baseYOffset;
		float trackingCircleMaxHeight = BaseSettings<UISettings>.Inst.trackingCircleMaxHeight;
		for (int i = 0; i < transform.childCount; i++)
		{
			float num3 = trackingCircleMaxHeight - num2;
			Vector3 position = transform.GetChild(i).transform.position;
			position.y = y + trackingCircleMaxHeight;
			if (Physics.RaycastNonAlloc(position, -up, hitArray, num3 + 0.001f, -1, QueryTriggerInteraction.Ignore) <= 0)
			{
				continue;
			}
			RaycastHit[] array = hitArray;
			for (int j = 0; j < array.Length; j++)
			{
				RaycastHit raycastHit = array[j];
				if (raycastHit.collider != null)
				{
					num2 = Mathf.Max(num2, trackingCircleMaxHeight - raycastHit.distance);
				}
			}
		}
		yOffset = num2 + 0.001f;
		Vector3 localPosition = base.transform.localPosition;
		yOffset = Mathf.Lerp(localPosition.y, yOffset, IC.RealDeltaTime * BaseSettings<UISettings>.Inst.trackingCircleLerpSpeed);
		localPosition.y = yOffset;
		base.transform.localPosition = localPosition;
		color.a = Mathf.MoveTowards(color.a, boundaryVisible ? alphaOrig : 0f, IC.RealDeltaTime);
		mpb.SetColor(shaderIDColor, color);
		mr.SetPropertyBlock(mpb);
		bool activeState = color.a > 0f;
		mr.enabled = activeState;
		CC.Inst.TrackingDirection.OnUpdateLR(mpb, activeState);
	}
}
public class TrackingDirection : MonoBehaviour
{
	private MeshRenderer[] mrs;

	public void OnAwakeLR()
	{
		mrs = GetComponentsInChildren<MeshRenderer>();
	}

	public void OnUpdateLR(MaterialPropertyBlock mpb, bool activeState)
	{
		MeshRenderer[] array = mrs;
		foreach (MeshRenderer obj in array)
		{
			obj.SetPropertyBlock(mpb);
			obj.gameObject.SetActive(activeState);
		}
	}
}
public class TrackingDirectionHint : MonoBehaviour
{
	protected static TrackingDirectionHint _instance;

	private TeleportUIHelper helperBar;

	private TrackingHintArrow[] arrows;

	[ReadOnly]
	public TextMesh tm;

	private bool isVisible;

	public static TrackingDirectionHint Inst => _instance;

	public void OnAwakeLR()
	{
		_instance = this;
		Color trackingHintColor = BaseSettings<TeleportSettings>.Inst.trackingHintColor;
		trackingHintColor.a = 0f;
		tm = GetComponentInChildren<TextMesh>();
		MeshRenderer[] componentsInChildren = GetComponentInChildren<TrackingHintBackground>(includeInactive: true).GetComponentsInChildren<MeshRenderer>(includeInactive: true);
		helperBar = new TeleportUIHelper(componentsInChildren, trackingHintColor);
		arrows = GetComponentsInChildren<TrackingHintArrow>(includeInactive: true);
		TrackingHintArrow[] array = arrows;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].OnAwakeLR();
		}
	}

	public void EvaluateAngleToShowHint(float requiredAngleLookingAwayInDegrees)
	{
		bool flag = false;
		if (CC.Inst.trackingMode == TrackingMode.FrontFacing)
		{
			Vector3 direction = IC.GetHeadRotation() * Vector3.forward;
			Vector3 to = CC.Inst.transform.InverseTransformDirection(direction);
			to.y = 0f;
			to.Normalize();
			if (!isVisible)
			{
				if (Vector3.Angle(Vector3.forward, to) > requiredAngleLookingAwayInDegrees)
				{
					flag = true;
				}
			}
			else
			{
				float frontfaceAngleToHideHint = BaseSettings<TeleportSettings>.Inst.frontfaceAngleToHideHint;
				flag = Vector3.Angle(Vector3.forward, to) > frontfaceAngleToHideHint;
			}
		}
		else
		{
			flag = false;
		}
		TrackingHintArrow[] array;
		if (isVisible != flag)
		{
			isVisible = flag;
			if (flag)
			{
				helperBar.AlphaAnimateTo(1f, 0.5f, 0f);
				array = arrows;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].uiTools.AlphaAnimateTo(0.25f, 0.5f, 0f);
				}
			}
			else
			{
				helperBar.AlphaAnimateTo(0f, 0.5f, 0f);
				array = arrows;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].uiTools.AlphaAnimateTo(0f, 0.5f, 0f);
				}
			}
		}
		array = arrows;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].OnUpdateLR();
		}
		tm.color = tm.color.RepA(helperBar.objColor.a);
	}

	public void OnUpdateLR()
	{
		EvaluateAngleToShowHint(BaseSettings<TeleportSettings>.Inst.frontfaceAngleToShowHint);
	}
}
public class TrackingFootprint : MonoBehaviour
{
}
public class TrackingHintArrow : MonoBehaviour
{
	[HideInInspector]
	public TeleportUIHelper uiTools;

	public float animateAlpha = 1f;

	public void OnAwakeLR()
	{
		uiTools = new TeleportUIHelper(GetComponentsInChildren<MeshRenderer>(), Color.white);
	}

	public void OnUpdateLR()
	{
		uiTools.SetAdditionalTintAlpha(animateAlpha);
	}
}
public class TrackingHintBackground : MonoBehaviour
{
}
public class DLLImportHotloader
{
	public static FuncDelegate GetDelegate<FuncDelegate>(IntPtr library, string functionName) where FuncDelegate : class
	{
		return Marshal.GetDelegateForFunctionPointer(GetProcAddress(library, functionName), typeof(FuncDelegate)) as FuncDelegate;
	}

	public static Result Invoke<Result, FuncDelegate>(IntPtr library, string functionName, params object[] pars)
	{
		IntPtr procAddress = GetProcAddress(library, functionName);
		if (procAddress == IntPtr.Zero)
		{
			UnityEngine.Debug.LogWarning("Could not gain reference to method address.");
			return default(Result);
		}
		return (Result)Marshal.GetDelegateForFunctionPointer(procAddress, typeof(FuncDelegate)).DynamicInvoke(pars);
	}

	public static void Invoke<FuncDelegate>(IntPtr library, string functionName, params object[] pars)
	{
		IntPtr procAddress = GetProcAddress(library, functionName);
		if (procAddress == IntPtr.Zero)
		{
			UnityEngine.Debug.LogWarning("Could not gain reference to method address.");
		}
		else
		{
			Marshal.GetDelegateForFunctionPointer(procAddress, typeof(FuncDelegate)).DynamicInvoke(pars);
		}
	}

	[DllImport("kernel32", SetLastError = true)]
	[return: MarshalAs(UnmanagedType.Bool)]
	public static extern bool FreeLibrary(IntPtr hModule);

	[DllImport("kernel32", CharSet = CharSet.Unicode, SetLastError = true)]
	public static extern IntPtr LoadLibrary(string lpFileName);

	[DllImport("kernel32")]
	public static extern IntPtr GetProcAddress(IntPtr hModule, string procedureName);
}
[CreateAssetMenu(fileName = "ChapterInfo", menuName = "Nexus Puzzle/Chapter Info", order = 0)]
public class ChapterInfo : ScriptableObject
{
	public SaveDataGame.Chapter chapter;

	public SceneInfo_BundleRef[] chapterScenes;

	public PuzzleInfo[] puzzles;

	private Func<bool> ChapterComplete;

	private void OnEnable()
	{
		ChapterComplete = () => IsChapterComplete();
		if (puzzles != null)
		{
			for (int i = 0; i < puzzles.Length; i++)
			{
				puzzles[i].AssignChapter(this);
			}
		}
		if (chapterScenes != null)
		{
			for (int j = 0; j < chapterScenes.Length; j++)
			{
				chapterScenes[j].Load().AssignChapter(this);
			}
		}
	}

	public Wait UntilChapterComplete()
	{
		return Wait.Until.True(ChapterComplete, 1, allowPreMetNow: true);
	}

	public bool IsChapterComplete(SaveDataGame.PuzzleSaveType completionType = SaveDataGame.PuzzleSaveType.Progression)
	{
		if (completionType == SaveDataGame.PuzzleSaveType.Progression)
		{
			return LR.Inst.saveDataGame.IsChapterMaskCompleteAll(chapter);
		}
		int puzzlesNum = GetPuzzlesNum(PuzzleInfo.PuzzleType.MAIN);
		return GetCompletedPuzzlesNum(SaveDataGame.PuzzleSaveType.Scene, PuzzleInfo.PuzzleType.MAIN) == puzzlesNum;
	}

	public Wait UntilPuzzlesComplete(SaveDataGame.PuzzleSaveType saveType, PuzzleInfo.PuzzleType puzzleType)
	{
		Wait none = Wait.None;
		for (int i = 0; i < puzzles.Length; i++)
		{
			PuzzleInfo puzzleInfo = puzzles[i];
			if ((puzzleInfo.puzzleType & puzzleType) != 0)
			{
				none &= puzzleInfo.UntilComplete(saveType);
			}
		}
		return none;
	}

	public int GetCompletedPuzzlesNum(SaveDataGame.PuzzleSaveType saveType, PuzzleInfo.PuzzleType puzzleType)
	{
		int num = 0;
		for (int i = 0; i < puzzles.Length; i++)
		{
			PuzzleInfo puzzleInfo = puzzles[i];
			if ((puzzleType & puzzleInfo.puzzleType) != 0 && puzzleInfo.IsComplete(saveType))
			{
				num++;
			}
		}
		return num;
	}

	public int GetPuzzlesNum(PuzzleInfo.PuzzleType puzzleType)
	{
		int num = 0;
		for (int i = 0; i < puzzles.Length; i++)
		{
			PuzzleInfo puzzleInfo = puzzles[i];
			if ((puzzleType & puzzleInfo.puzzleType) != 0)
			{
				num++;
			}
		}
		return num;
	}

	public void EvaluateCompletionStatus()
	{
		if (!IsChapterComplete())
		{
			int puzzlesNum = GetPuzzlesNum(PuzzleInfo.PuzzleType.MAIN);
			if (GetCompletedPuzzlesNum(SaveDataGame.PuzzleSaveType.Progression, PuzzleInfo.PuzzleType.MAIN) >= puzzlesNum)
			{
				LR.Inst.saveDataGame.CompleteChapter(chapter);
			}
		}
	}

	public static SaveDataGame.Chapter GetChapterFromSceneUID(string sceneUID)
	{
		switch (sceneUID)
		{
		case "hull":
		case "bert":
			return SaveDataGame.Chapter.Princess;
		case "curd":
		case "ulan":
		case "hade":
			return SaveDataGame.Chapter.Hunter;
		case "vico":
		case "yard":
			return SaveDataGame.Chapter.Stargazing;
		case "chin":
			return SaveDataGame.Chapter.Escape;
		case "haag":
		case "crop":
			return SaveDataGame.Chapter.Evilgate;
		case "darg":
			return SaveDataGame.Chapter.Insanity;
		case "ossa":
		case "oryx":
		case "elie":
		case "ugly":
			return SaveDataGame.Chapter.Death;
		case "paly":
			return SaveDataGame.Chapter.FirstMeeting;
		case "ahem":
		case "plop":
		case "ware":
		case "bors":
		case "auto":
		case "funk":
		case "crow":
			return SaveDataGame.Chapter.Construct;
		default:
			return SaveDataGame.Chapter.None;
		}
	}
}
[CreateAssetMenu(fileName = "Scene_PuzzleType_PuzzleName", menuName = "Nexus Puzzle/Puzzle Info", order = 0)]
public class PuzzleInfo : ScriptableObject
{
	public enum PuzzleType
	{
		MAIN = 1,
		OPTIONAL
	}

	[ReadOnly]
	[SerializeField]
	private string _resourcePath;

	[NonSerialized]
	[HideInInspector]
	public string PuzzleName;

	public PuzzleType puzzleType = PuzzleType.MAIN;

	private Func<bool> IsCompleteLocal;

	private Func<bool> IsCompleteGlobal;

	private ChapterInfo chapterInfo;

	public HagletTrigger puzzleAnimComplete = new HagletTrigger();

	public bool clearProgressOnLoad;

	public string ResourcePath => _resourcePath;

	private void OnEnable()
	{
		PuzzleName = base.name;
		IsCompleteLocal = () => IsComplete(SaveDataGame.PuzzleSaveType.Scene);
		IsCompleteGlobal = () => IsComplete(SaveDataGame.PuzzleSaveType.Progression);
	}

	public void AssignChapter(ChapterInfo chapterInfo)
	{
		if (this.chapterInfo != null)
		{
			_ = this.chapterInfo != chapterInfo;
		}
		this.chapterInfo = chapterInfo;
	}

	public SaveDataGame.Chapter GetPuzzleChapter()
	{
		if ((bool)chapterInfo)
		{
			return chapterInfo.chapter;
		}
		return SaveDataGame.Chapter.None;
	}

	public Wait SetComplete()
	{
		UnityEngine.Debug.Log("Puzzle " + base.name + " completed");
		bool flag = false;
		SaveDataGame saveDataGame = LR.Inst.saveDataGame;
		if (saveDataGame.CompletePuzzleScene(chapter: GetPuzzleChapter(), puzzle: PuzzleName))
		{
			flag = true;
		}
		if (saveDataGame.CompletePuzzleProgress(PuzzleName))
		{
			if ((bool)chapterInfo)
			{
				chapterInfo.EvaluateCompletionStatus();
			}
			flag = true;
		}
		if (flag)
		{
			return LR.Inst.Save();
		}
		return Wait.PreMet;
	}

	public bool IsComplete(SaveDataGame.PuzzleSaveType saveType)
	{
		return LR.Inst.saveDataGame.IsPuzzleCompleted(chapter: GetPuzzleChapter(), puzzle: PuzzleName, saveType: saveType);
	}

	public Wait UntilComplete(SaveDataGame.PuzzleSaveType saveType)
	{
		return saveType switch
		{
			SaveDataGame.PuzzleSaveType.Scene => Wait.Until.True(IsCompleteLocal, 1, allowPreMetNow: true), 
			SaveDataGame.PuzzleSaveType.Progression => Wait.Until.True(IsCompleteGlobal, 1, allowPreMetNow: true), 
			_ => Wait.None, 
		};
	}
}
public class DebugNativeRendering : MonoBehaviour
{
	private CommandBuffer cb;

	[DllImport("RenderingPlugin")]
	public static extern IntPtr LinkDebug([MarshalAs(UnmanagedType.FunctionPtr)] IntPtr debugCal);

	private static void DebugWrapper(string log)
	{
		UnityEngine.Debug.Log(log);
	}

	[DllImport("RenderingPlugin")]
	public static extern IntPtr GetDepthCopyEvent();

	[DllImport("RenderingPlugin")]
	public static extern IntPtr GetRestoreDepthWithMeshEvent();

	private void Awake()
	{
		LinkDebug(Marshal.GetFunctionPointerForDelegate<Action<string>>(DebugWrapper));
		cb = new CommandBuffer();
		cb.name = "Book Contents";
		BuildCommandBuffer();
		Camera.main.AddCommandBuffer(CameraEvent.AfterForwardOpaque, cb);
	}

	private void BuildCommandBuffer()
	{
		cb.Clear();
		cb.IssuePluginEvent(GetDepthCopyEvent(), 0);
	}
}
public class LoadingCamera : MonoBehaviour, NexusRenderPipeline.ICameraEvents
{
	private static LoadingCamera _instance;

	private const string SUNLIGHT_ON = "SUNLIGHT_ON";

	private readonly int _SunDirection = Shader.PropertyToID("_SunDirection");

	private readonly int _SunColor_Intensity = Shader.PropertyToID("_SunColor_Intensity");

	private readonly int _AmbientColor_Intensity = Shader.PropertyToID("_AmbientColor_Intensity");

	private CommandBuffer onSetupCameraPropertiesCB;

	private CommandBuffer onPostTransparentCB;

	public Sunlight sunlight;

	public Color ambientColorIntensity = new Color(0.3f, 0.3f, 0.3f, 1f);

	public Texture2D skybox;

	private Matrix4x4[] viewMatrices = new Matrix4x4[2];

	[HideInInspector]
	public Camera Camera;

	public static LoadingCamera Inst => _instance;

	bool NexusRenderPipeline.ICameraEvents.ShouldDraw => true;

	bool NexusRenderPipeline.ICameraEvents.EventsEnabled => true;

	bool NexusRenderPipeline.ICameraEvents.ShouldDrawOverlayPass => false;

	RenderStateBlock NexusRenderPipeline.ICameraEvents.CameraRenderState => default(RenderStateBlock);

	private void Awake()
	{
		_instance = this;
		Camera = GetComponent<Camera>();
		onSetupCameraPropertiesCB = new CommandBuffer
		{
			name = "Loading Camera Properties"
		};
		onPostTransparentCB = new CommandBuffer
		{
			name = "Loading Camera Post-transparent"
		};
	}

	public void OnLateUpdateLR()
	{
		if (FAC.Initialized && FAC.Inst.sys.isValid())
		{
			ATTRIBUTES_3D attributes = default(ATTRIBUTES_3D);
			attributes.position = base.transform.position.toFMODVector();
			attributes.forward = base.transform.forward.toFMODVector();
			attributes.up = base.transform.up.toFMODVector();
			attributes.velocity = Vector3.zero.toFMODVector();
			FAC.Inst.sys.setListenerAttributes(0, attributes);
		}
	}

	void NexusRenderPipeline.ICameraEvents.OnPreCullParams(Camera cam)
	{
	}

	void NexusRenderPipeline.ICameraEvents.OnPreCullSubmit(Camera cam, bool willDraw, ref ScriptableCullingParameters cullParams, bool willDrawFrontOfPortal, ref ScriptableCullingParameters cullParamsFrontOfPortal)
	{
	}

	void NexusRenderPipeline.ICameraEvents.OnPostCull(Camera cam)
	{
	}

	CommandBuffer NexusRenderPipeline.ICameraEvents.OnPreOpaque(Camera cam, ref DrawRendererSettings drawSettings, ref FilterRenderersSettings filterSettings)
	{
		filterSettings.renderingLayerMask = uint.MaxValue;
		return null;
	}

	CommandBuffer NexusRenderPipeline.ICameraEvents.OnPostOpaque(Camera cam)
	{
		return null;
	}

	CommandBuffer NexusRenderPipeline.ICameraEvents.OnPortalStencil(Camera cam)
	{
		return null;
	}

	CommandBuffer NexusRenderPipeline.ICameraEvents.OnPortalClear(Camera cam)
	{
		return null;
	}

	CommandBuffer NexusRenderPipeline.ICameraEvents.OnPreTransparent(Camera cam, ref DrawRendererSettings drawSettings, ref FilterRenderersSettings filterSettings)
	{
		return null;
	}

	CommandBuffer NexusRenderPipeline.ICameraEvents.OnPostTransparent(Camera cam)
	{
		onPostTransparentCB.Clear();
		if (NexusFullScreenPass.Inst != null)
		{
			NexusFullScreenPass.Inst.DrawFullscreenPassToCommandBuffer(onPostTransparentCB);
		}
		if ((bool)UIErrorPrompt.Inst && UIErrorPrompt.Inst.CurrentError)
		{
			UIErrorPrompt.Inst.DrawError(onPostTransparentCB);
		}
		return onPostTransparentCB;
	}

	CommandBuffer NexusRenderPipeline.ICameraEvents.OnSetupCameraProperties(Camera cam, CommandBuffer camPropsCMB)
	{
		cam.GetViewMatrices(out viewMatrices[0], out viewMatrices[1]);
		camPropsCMB.SetViewMatrices_NX(cam.stereoEnabled, viewMatrices);
		camPropsCMB.DisableShaderKeyword("PORTAL_TRANSFORM_MATRIX_ON");
		camPropsCMB.SetGlobalVector(ShaderPID._PortalClipEnabled, Vector4X.zero);
		camPropsCMB.DisableShaderKeyword("PORTAL_RENDER_MODE_ON");
		camPropsCMB.SetGlobalInt(ShaderPID._STENCIL_COMP, 8);
		camPropsCMB.SetGlobalInt(ShaderPID._STENCIL_REF, 0);
		camPropsCMB.SetInvertedCulling_NX(inverted: false);
		if (onSetupCameraPropertiesCB == null)
		{
			Awake();
		}
		Vector4 value = -sunlight.transform.forward;
		Vector4 value2 = sunlight.lightColor;
		value2.w = sunlight.intensity;
		onSetupCameraPropertiesCB.EnableShaderKeyword("SUNLIGHT_ON");
		onSetupCameraPropertiesCB.SetGlobalVector(_SunDirection, value);
		onSetupCameraPropertiesCB.SetGlobalVector(_SunColor_Intensity, value2);
		onSetupCameraPropertiesCB.SetGlobalVector(_AmbientColor_Intensity, ambientColorIntensity);
		onSetupCameraPropertiesCB.SetSkybox_NX(skybox, new Vector2(0.5f, 0.5f), 1f);
		return onSetupCameraPropertiesCB;
	}

	bool NexusRenderPipeline.ICameraEvents.ShouldDrawLight(Camera cam, VisibleLight visibleLight)
	{
		return false;
	}
}
public class MainCamera : MonoBehaviour, ICanPortal, NexusRenderPipeline.ICameraEvents
{
	public enum EyePositions
	{
		Left,
		Right,
		Centre
	}

	public class HighlightDrawer
	{
		private ConstArray<ProximityHighlightPoint.HighLightData> proxHighlights = new ConstArray<ProximityHighlightPoint.HighLightData>(50u);

		private ConstArray<ProximityHighlightPoint.HighLightData> handHighlights = new ConstArray<ProximityHighlightPoint.HighLightData>(2u);

		private Color[] colorBuffer = new Color[50];

		private float[] alphaBuffer = new float[50];

		private Matrix4x4[] matrixBuffer = new Matrix4x4[50];

		public void AddProxHighlight(ProximityHighlightPoint.HighLightData data)
		{
			if (proxHighlights.Length < proxHighlights.MaxSize)
			{
				proxHighlights.Add(data);
			}
		}

		public void AddHandHighlight(ProximityHighlightPoint.HighLightData data)
		{
			if (handHighlights.Length < handHighlights.MaxSize)
			{
				handHighlights.Add(data);
			}
		}

		public void DrawHighlights(CommandBuffer buff, Vector3 cameraPos)
		{
			if (proxHighlights.Length != 0)
			{
				FillBuffers(proxHighlights, cameraPos);
				Mesh highlightMesh = BaseSettings<InteractionSettings>.Inst.highlightMesh;
				Material proxHighlightMat = BaseSettings<InteractionSettings>.Inst.proxHighlightMat;
				proxHighlightMat.SetColorArray("_Color", colorBuffer);
				proxHighlightMat.SetFloatArray("_Alpha", alphaBuffer);
				buff.DrawMeshInstanced(highlightMesh, 0, proxHighlightMat, -1, matrixBuffer, (int)proxHighlights.Length);
			}
			if (handHighlights.Length != 0)
			{
				FillBuffers(handHighlights, cameraPos);
				Mesh highlightMesh2 = BaseSettings<InteractionSettings>.Inst.highlightMesh;
				Material handHighlightMat = BaseSettings<InteractionSettings>.Inst.handHighlightMat;
				handHighlightMat.SetColorArray("_Color", colorBuffer);
				handHighlightMat.SetFloatArray("_Alpha", alphaBuffer);
				buff.DrawMeshInstanced(highlightMesh2, 0, handHighlightMat, -1, matrixBuffer, (int)handHighlights.Length);
			}
		}

		public void FillBuffers(ConstArray<ProximityHighlightPoint.HighLightData> data, Vector3 cameraPos)
		{
			for (int i = 0; i < data.Length; i++)
			{
				colorBuffer[i] = data[i].color;
				alphaBuffer[i] = data[i].alpha;
				Quaternion q = Quaternion.LookRotation((cameraPos - data[i].worldPos).normalized, data[i].up);
				matrixBuffer[i] = Matrix4x4.TRS(data[i].worldPos, q, data[i].scale);
			}
		}

		public void ResetHightlights()
		{
			proxHighlights.Clear();
			handHighlights.Clear();
		}
	}

	public static MainCamera Inst;

	[NonSerialized]
	public Camera cameraComp;

	private Portal leftEyeIntPortal;

	private Portal leftEyeNearPortal;

	private Portal rightEyeIntPortal;

	private Portal rightEyeNearPortal;

	private readonly Vector4[] portalPlanes = new Vector4[2];

	[ReadOnly]
	private MRBase owner;

	private TransformState lastState;

	[NonSerialized]
	[HideInInspector]
	public PortalVariations.VariantSet portalVariantSet;

	private CommandBuffer onPreOpaqueCB;

	private CommandBuffer onPortalStencilCB;

	private CommandBuffer onPortalClearCB;

	private CommandBuffer onPreTransparentCB;

	private CommandBuffer onPostTransparentCB;

	private CommandBuffer onPreStereoEndRenderCB;

	public NexusFullScreenPass fullScreenPass;

	private readonly Matrix4x4[] viewMatrices = new Matrix4x4[2];

	private PortalRenderer portalRenderer;

	private HighlightDrawer highlightDrawer = new HighlightDrawer();

	private MeshRenderer titleCardMR;

	private Material titleCardMat;

	[HideInInspector]
	public bool titleCardActive;

	private RenderStateBlock disabledStencilState;

	private HashSet<ProximityHighlightPoint> lastActiveHighlights = new HashSet<ProximityHighlightPoint>();

	private HashSet<ProximityHighlightPoint> activeHighlights = new HashSet<ProximityHighlightPoint>();

	bool NexusRenderPipeline.ICameraEvents.ShouldDraw => true;

	bool NexusRenderPipeline.ICameraEvents.ShouldDrawOverlayPass => fullScreenPass.fadeAlpha > 0f;

	bool NexusRenderPipeline.ICameraEvents.EventsEnabled => cameraComp != null;

	RenderStateBlock NexusRenderPipeline.ICameraEvents.CameraRenderState => disabledStencilState;

	public void OnAwakeLR()
	{
		Inst = this;
		cameraComp = GetComponent<Camera>();
		cameraComp.clearFlags = CameraClearFlags.Color;
		cameraComp.useOcclusionCulling = true;
		portalRenderer = GetComponentInChildren<PortalRenderer>();
		if (portalRenderer != null)
		{
			portalRenderer.OnAwakeLR(drawsInPortals: false);
		}
		lastState = new TransformState(base.transform);
		disabledStencilState = new RenderStateBlock(RenderStateMask.Stencil)
		{
			stencilState = new StencilState(enabled: false, byte.MaxValue, byte.MaxValue, CompareFunction.Always, StencilOp.Keep, StencilOp.Keep, StencilOp.Keep)
		};
		onPreOpaqueCB = CreateCB("Pre-opaque");
		onPortalStencilCB = CreateCB("Portal Stencil");
		onPortalClearCB = CreateCB("Portal Clear");
		onPreTransparentCB = CreateCB("Pre-transparent");
		onPostTransparentCB = CreateCB("Post-transparent");
		onPreStereoEndRenderCB = CreateCB("Pre-StereoEndRender");
		portalVariantSet = PortalVariations.DEFAULT_SET;
		fullScreenPass = new NexusFullScreenPass();
		fullScreenPass.OnAwakeMainCamera();
		NexusRenderPipeline.AddPipelineCallback(NexusRenderPipeline.PipelineEvent.PreStereoEndRender, OnPreStereoEndRender);
		NexusRenderPipeline.AddPipelineCallback(NexusRenderPipeline.PipelineEvent.End, OnRenderPipelineEnd);
	}

	protected void OnDestroy()
	{
		ReleaseCB(onPreOpaqueCB);
		ReleaseCB(onPreTransparentCB);
		ReleaseCB(onPostTransparentCB);
		ReleaseCB(onPreStereoEndRenderCB);
		NexusRenderPipeline.RemovePipelineCallback(NexusRenderPipeline.PipelineEvent.PreStereoEndRender, OnPreStereoEndRender);
		NexusRenderPipeline.RemovePipelineCallback(NexusRenderPipeline.PipelineEvent.End, OnRenderPipelineEnd);
	}

	private static void ReleaseCB(CommandBuffer cb)
	{
		if (cb != null)
		{
			cb.Clear();
			cb.Release();
		}
	}

	public void OnUpdateLR()
	{
		fullScreenPass.OnUpdateLR(owner);
	}

	public void OnLateUpdateLR()
	{
		GatherHighlights();
	}

	public void OnRealtimeLateUpdateLR()
	{
		fullScreenPass.UpdateOutOfBounds();
		Transform transform = base.transform;
		Vector3 position = transform.position;
		if (owner != null && owner.ambientProbes != null)
		{
			owner.ambientProbes.OnRealtimeLateUpdate(position);
		}
		if (FAC.Inst.sys.isValid())
		{
			ATTRIBUTES_3D attributes = default(ATTRIBUTES_3D);
			attributes.position = position.toFMODVector();
			attributes.forward = transform.forward.toFMODVector();
			attributes.up = transform.up.toFMODVector();
			attributes.velocity = Vector3.zero.toFMODVector();
			FAC.Inst.sys.setListenerAttributes(0, attributes);
		}
	}

	public void OnPauseLR(bool paused)
	{
		if (paused)
		{
			highlightDrawer.ResetHightlights();
		}
	}

	private CommandBuffer CreateCB(string name)
	{
		return new CommandBuffer
		{
			name = "Main Camera " + name
		};
	}

	public void GetEyePositions(out Vector3 left, out Vector3 right)
	{
		cameraComp.GetViewMatrices(out var viewL, out var viewR);
		left = Matrix4x4X.GetPositionFromViewMatrixV3(ref viewL);
		right = Matrix4x4X.GetPositionFromViewMatrixV3(ref viewR);
	}

	public void EvaluateMovement(CC.TeleportInfo teleportInfo, CC.MovementType movementType = CC.MovementType.None)
	{
		CC inst = CC.Inst;
		if (inst.handL.IsHoldingPortal && (bool)inst.handL.GrabObjectHeld)
		{
			inst.handL.MoveRidgidbodyToHand(inst.handL.GrabObjectHeld.pr, inst.handL.GetHandGrabTransform(), movementType, updateLastState: false);
		}
		if (inst.handR.IsHoldingPortal && (bool)inst.handR.GrabObjectHeld)
		{
			inst.handR.MoveRidgidbodyToHand(inst.handR.GrabObjectHeld.pr, inst.handR.GetHandGrabTransform(), movementType, updateLastState: false);
		}
		bool flag = inst.handL.IsHoldingPortal || inst.handR.IsHoldingPortal;
		Portal portal = null;
		int num;
		int num2;
		if (movementType != CC.MovementType.Teleport)
		{
			num = ((movementType == CC.MovementType.FreeMove) ? 1 : 0);
			if (num == 0)
			{
				num2 = 1;
				goto IL_00c7;
			}
		}
		else
		{
			num = 1;
		}
		num2 = ((!flag) ? 1 : 0);
		goto IL_00c7;
		IL_00c7:
		bool flag2 = (byte)num2 != 0;
		if (num == 0 || teleportInfo.wasEGrillEncounterBeforePortal)
		{
			EGrill.OnMainCameraEvaluateMovement(owner, this, teleportInfo, movementType);
		}
		if (flag2)
		{
			Portal portal2 = ((!(teleportInfo.portal != null)) ? Portal.PortalableEvaluateCrossingPortal(this) : Portal.PortalableEvaluateCrossingPortalPlane(this, teleportInfo.portal));
			portal = portal2;
		}
		inst.handL.EvaluateMovement(portal, this, movementType);
		inst.handR.EvaluateMovement(portal, this, movementType);
		STC.Inst.EvaluateMovement(portal, this, movementType);
		if (GetOwner() != null)
		{
			if ((bool)portal && !teleportInfo.wasEGrillEncounterBeforePortal)
			{
				EGrill.OnMainCameraEvaluateMovement(owner, this, teleportInfo, movementType);
			}
			lastState.UpdateToLatestState();
		}
	}

	public void OnEnterPortalPreMove(Portal portal)
	{
	}

	bool ICanPortal.CanEnterPortal(Portal portal)
	{
		return true;
	}

	public void OnEnterPortal(Portal portal)
	{
		CC inst = CC.Inst;
		Transform transform = inst.transform;
		Portal.PortalTransform portalTransform = portal.CalculatePortalObjectTransform(transform.position, transform.rotation, Vector3.zero);
		transform.position = portalTransform.position;
		transform.rotation = portalTransform.rotation;
		Portal.PortalTransform portalTransform2 = portal.CalculatePortalObjectTransform(lastState.position, lastState.rotation, Vector3.zero);
		lastState.position = portalTransform2.position;
		lastState.rotation = portalTransform2.rotation;
		FMODEventAsset fMODEventAsset = portal.overrideSfx.crossingPortalSFX.Value ?? portal.typeSettings.sfx.crossingPortalSFX.Value;
		if (fMODEventAsset != null)
		{
			FAC.Inst.PlayOneShot(fMODEventAsset, portalTransform.position);
		}
		if (owner != null)
		{
			PortalVariations.VariantSet variantSet = portal.portalVariantSet;
			PortalVariations.VariantSet variantSet2 = portalVariantSet;
			if (variantSet2 != variantSet)
			{
				portal.portalVariantSet = variantSet2;
				portalVariantSet = variantSet;
				ConstArray<PortalVariations> portalVariations = owner.portalVariations;
				for (int i = 0; i < portalVariations.Length; i++)
				{
					portalVariations[i].OnMainVariantChanged(variantSet, variantSet2);
				}
			}
		}
		inst.CancelPushPopRoutineTeleport();
		fullScreenPass.ForceUpdateLastValidPosition();
	}

	public TransformState GetLastState()
	{
		return lastState;
	}

	public Vector3 GetWorldPosition()
	{
		return IC.GetHeadPosition();
	}

	public MRBase GetOwner()
	{
		return owner;
	}

	public void SetOwner(MRBase ownerNew)
	{
		MRBase mRBase = owner;
		if (owner == ownerNew)
		{
			return;
		}
		if (portalRenderer != null)
		{
			MRBase.TransferObject(mRBase, ownerNew, portalRenderer);
		}
		if (portalRenderer != null)
		{
			CC.Inst.SetOwner(ownerNew);
		}
		if (!(owner == null))
		{
			LR.Inst.NotifyOnAreaExit(mRBase, ownerNew);
			if (owner.ambientProbes != null)
			{
				owner.ambientProbes.StopAmbience();
			}
		}
		owner = ownerNew;
		if (!(owner == null))
		{
			LR.Inst.NotifyOnAreaEnter(mRBase, ownerNew);
			SceneInfo sceneInfo = ownerNew?.info?.Load();
			SceneInfo sceneInfo2 = mRBase?.info?.Load();
			SaveDataGame.Chapter puzzleChapter = sceneInfo.GetPuzzleChapter();
			if (puzzleChapter != 0 && sceneInfo2 != null)
			{
				int sceneIndex = sceneInfo2.GetSceneIndex();
				if (sceneInfo.GetSceneIndex() > sceneIndex)
				{
					LR.Inst.saveDataGame.SetLastLevelInChapter(puzzleChapter, sceneInfo.sceneUIDName);
					if (!LR.Inst.saveAfterScenesLoaded.started)
					{
						LR.Inst.saveAfterScenesLoaded.Start();
					}
				}
			}
			string sceneUIDName = sceneInfo.sceneUIDName;
			if (sceneUIDName != "hair")
			{
				CC.Inst.currentSceneUIDName = sceneUIDName;
			}
			if (sceneUIDName == "suez")
			{
				SaveDataGame.Chapter currentChapter = CC.Inst.currentChapter;
				switch (currentChapter)
				{
				case SaveDataGame.Chapter.Princess:
				case SaveDataGame.Chapter.Hunter:
				case SaveDataGame.Chapter.Stargazing:
				case SaveDataGame.Chapter.Escape:
				case SaveDataGame.Chapter.Evilgate:
				case SaveDataGame.Chapter.Insanity:
				case SaveDataGame.Chapter.Death:
				case SaveDataGame.Chapter.FirstMeeting:
					if (LR.Inst.saveDataGame.IsChapterMaskCompleteAny(currentChapter))
					{
						float num = Mathf.Log((float)currentChapter, 2f);
						num -= 1f;
						LR.Inst.PlatformManager.UnlockAchievement((NXAchievements)num);
					}
					break;
				default:
				{
					string text = mRBase?.info.Load().sceneUIDName ?? "";
					if (LR.Inst.saveDataGame.secretDiscovered && text == "gowd")
					{
						LR.Inst.PlatformManager.UnlockAchievement(NXAchievements.MansfieldsLab_Unlocked);
					}
					break;
				}
				}
			}
			if (owner.ambientProbes != null)
			{
				owner.ambientProbes.StartAmbience();
			}
		}
		PlayerInventory.Inst.OnPlayerSceneChanged(mRBase, ownerNew);
		if (owner != null && (bool)owner.returnPortal)
		{
			owner.returnPortal.portal.closeAndRestoreLink.Start(resetIfStarted: true);
		}
	}

	public Transform GetTransformToMoveWithPortal()
	{
		return base.transform;
	}

	public bool CanTeleport(Portal portal)
	{
		return portal.PlayerHeadTeleportOnEnter;
	}

	private void SetVariantRendering(PortalVariations.VariantSet variant)
	{
		PortalVariations[] data = owner.portalVariations._data;
		uint dataNum = owner.portalVariations._dataNum;
		for (int i = 0; i < dataNum; i++)
		{
			data[i].EnableVariantRendering(variant);
		}
	}

	public static Quaternion CalculateHeadForwardRotation()
	{
		Vector3 rhs = IC.GetHeadRotation() * Vector3X.forward;
		Vector3 normalized = CC.Inst.transform.up.normalized;
		rhs = Vector3.Cross(Vector3.Cross(normalized, rhs).normalized, normalized).normalized;
		return Quaternion.LookRotation(rhs, CC.Inst.transform.up);
	}

	public static Vector3 CalculateHeadLockedUIPos(Vector3 currentPos, float height, float distance, float velocityDamper)
	{
		Quaternion quaternion = Quaternion.Inverse(CC.Inst.transform.rotation) * IC.GetHeadRotation();
		Vector3 headLocalPosition = IC.GetHeadLocalPosition();
		Vector3 vector = CC.Inst.transform.InverseTransformPoint(currentPos) - headLocalPosition;
		Vector2 normalized = new Vector2(vector.x, vector.z).normalized;
		Vector3 vector2 = quaternion * Vector3.forward;
		Vector2 normalized2 = new Vector2(vector2.x, vector2.z).normalized;
		ComplexAngle a = new ComplexAngle(normalized.x, normalized.y);
		ComplexAngle b = new ComplexAngle(normalized2.x, normalized2.y);
		float f = ComplexAngle.GetEulerBetween(a, b) * 57.29578f;
		Vector2 direction = ComplexAngle.Nlerp(a, b, Mathf.Abs(f) * velocityDamper * IC.DeltaTime).direction;
		Vector3 position = new Vector3(headLocalPosition.x + direction.x * distance, height, headLocalPosition.z + direction.y * distance);
		return CC.Inst.transform.TransformPoint(position);
	}

	public static float CalculateHeadDitherStrength(Vector3 worldPosition, float minDist, float maxDist)
	{
		float magnitude = (worldPosition - Inst.transform.position).magnitude;
		return Mathf.InverseLerp(minDist, maxDist, magnitude);
	}

	private void AddClipPlanes(CommandBuffer cmd)
	{
		if ((object)leftEyeIntPortal != null || (object)rightEyeIntPortal != null)
		{
			Vector2 zero = Vector2.zero;
			if ((object)leftEyeIntPortal != null)
			{
				zero.x = 1f;
				portalPlanes[0] = leftEyeIntPortal.cachedClipPlaneV;
			}
			if ((object)rightEyeIntPortal != null)
			{
				zero.y = 1f;
				portalPlanes[1] = rightEyeIntPortal.cachedClipPlaneV;
			}
			cmd.SetGlobalVector(ShaderPID._PortalClipEnabled, zero);
			cmd.SetGlobalVectorArray(ShaderPID._PortalPlanes, portalPlanes);
		}
		else
		{
			cmd.SetGlobalVector(ShaderPID._PortalClipEnabled, Vector4X.zero);
		}
	}

	private void AddDefaultState(CommandBuffer cmd)
	{
		cameraComp.GetViewMatrices(out viewMatrices[0], out viewMatrices[1]);
		cmd.SetViewMatrices_NX(cameraComp.stereoEnabled, viewMatrices);
		cmd.DisableShaderKeyword("PORTAL_TRANSFORM_MATRIX_ON");
		cmd.DisableShaderKeyword("PORTAL_RENDER_MODE_ON");
		cmd.SetGlobalInt(ShaderPID._STENCIL_COMP, 3);
		cmd.SetGlobalInt(ShaderPID._STENCIL_REF, 0);
		cmd.SetInvertedCulling_NX(inverted: false);
	}

	void NexusRenderPipeline.ICameraEvents.OnPreCullParams(Camera cam)
	{
		leftEyeIntPortal = (leftEyeNearPortal = (rightEyeIntPortal = (rightEyeNearPortal = null)));
		if (!owner)
		{
			return;
		}
		GetEyePositions(out var left, out var right);
		Portal[] data = owner.portals._data;
		uint length = owner.portals.Length;
		for (int i = 0; i < length; i++)
		{
			Portal portal = data[i];
			if (portal.gameObject.activeSelf)
			{
				portal.OnPreCullMainCamera(left, right);
				StereoTargetEyeMask intersectingEyes = portal.IntersectingEyes;
				StereoTargetEyeMask nearbyEyes = portal.NearbyEyes;
				if ((object)leftEyeIntPortal == null && (intersectingEyes & StereoTargetEyeMask.Left) != 0)
				{
					leftEyeIntPortal = portal;
				}
				if ((object)leftEyeNearPortal == null && (nearbyEyes & StereoTargetEyeMask.Left) != 0)
				{
					leftEyeNearPortal = portal;
				}
				if ((object)rightEyeIntPortal == null && (intersectingEyes & StereoTargetEyeMask.Right) != 0)
				{
					rightEyeIntPortal = portal;
				}
				if ((object)rightEyeNearPortal == null && (nearbyEyes & StereoTargetEyeMask.Right) != 0)
				{
					rightEyeNearPortal = portal;
				}
			}
		}
		owner.sceneRenderSettings.ApplyCameraProperties(cameraComp);
		SetVariantRendering(portalVariantSet);
	}

	void NexusRenderPipeline.ICameraEvents.OnPreCullSubmit(Camera cam, bool willDraw, ref ScriptableCullingParameters cullParams, bool willDrawFrontOfPortal, ref ScriptableCullingParameters cullParamsFrontOfPortal)
	{
		if (!owner)
		{
			return;
		}
		ConstArray<Portal> portals = owner.portals;
		for (int i = 0; i < portals.Length; i++)
		{
			Portal portal = portals[i];
			if (portal.PortalCamera.isActiveAndEnabled)
			{
				portal.OnPreCullSubmitMainCamera(ref cullParams);
			}
		}
	}

	void NexusRenderPipeline.ICameraEvents.OnPostCull(Camera cam)
	{
		if (!owner)
		{
			return;
		}
		Portal[] data = owner.portals._data;
		uint length = owner.portals.Length;
		for (int i = 0; i < length; i++)
		{
			Portal portal = data[i];
			if (portal.gameObject.activeSelf)
			{
				portal.OnPostCullMainCamera();
			}
		}
	}

	CommandBuffer NexusRenderPipeline.ICameraEvents.OnSetupCameraProperties(Camera cam, CommandBuffer camPropsCMB)
	{
		AddDefaultState(camPropsCMB);
		AddClipPlanes(camPropsCMB);
		return owner?.sceneRenderSettings?.ShaderPropertiesCMD;
	}

	private void DrawPortalIntersections(CommandBuffer buffer, bool transparentPass)
	{
		buffer.EnableShaderKeyword("PORTAL_TRANSFORM_MATRIX_ON");
		ConstArray<Portal> portals = owner.portals;
		for (int i = 0; i < portals.Length; i++)
		{
			portals[i].DrawIntersectingRenderers(buffer, isPortal: false, transparentPass);
		}
		buffer.DisableShaderKeyword("PORTAL_TRANSFORM_MATRIX_ON");
		buffer.SetInvertedCulling_NX(inverted: false);
	}

	CommandBuffer NexusRenderPipeline.ICameraEvents.OnPreOpaque(Camera cam, ref DrawRendererSettings drawSettings, ref FilterRenderersSettings filterSettings)
	{
		onPreOpaqueCB.Clear();
		if ((bool)owner)
		{
			filterSettings.renderingLayerMask = owner.sceneMask;
			DrawPortalIntersections(onPreOpaqueCB, transparentPass: false);
		}
		return onPreOpaqueCB;
	}

	CommandBuffer NexusRenderPipeline.ICameraEvents.OnPostOpaque(Camera cam)
	{
		return null;
	}

	CommandBuffer NexusRenderPipeline.ICameraEvents.OnPortalStencil(Camera cam)
	{
		onPortalStencilCB.Clear();
		if ((bool)leftEyeNearPortal)
		{
			leftEyeNearPortal.AddPortalVolume(onPortalStencilCB, Camera.StereoscopicEye.Left, 0);
		}
		if ((bool)rightEyeNearPortal)
		{
			rightEyeNearPortal.AddPortalVolume(onPortalStencilCB, Camera.StereoscopicEye.Right, 0);
		}
		return onPortalStencilCB;
	}

	CommandBuffer NexusRenderPipeline.ICameraEvents.OnPortalClear(Camera cam)
	{
		onPortalClearCB.Clear();
		if ((bool)leftEyeNearPortal)
		{
			leftEyeNearPortal.AddPortalVolume(onPortalClearCB, Camera.StereoscopicEye.Left, 1);
		}
		if ((bool)rightEyeNearPortal)
		{
			rightEyeNearPortal.AddPortalVolume(onPortalClearCB, Camera.StereoscopicEye.Right, 1);
		}
		return onPortalClearCB;
	}

	CommandBuffer NexusRenderPipeline.ICameraEvents.OnPreTransparent(Camera cam, ref DrawRendererSettings drawSettings, ref FilterRenderersSettings filterSettings)
	{
		onPreTransparentCB.Clear();
		if ((bool)owner)
		{
			for (int i = 0; i < owner.portals.Length; i++)
			{
				Portal portal = owner.portals[i];
				if (portal.type == PortalType.Mirror || portal.type == PortalType.PassThroughMirror)
				{
					portal.AddPortalOffSurface(onPreTransparentCB);
				}
			}
			filterSettings.renderingLayerMask = owner.sceneMask;
			DrawPortalIntersections(onPreTransparentCB, transparentPass: true);
		}
		return onPreTransparentCB;
	}

	CommandBuffer NexusRenderPipeline.ICameraEvents.OnPostTransparent(Camera cam)
	{
		onPostTransparentCB.Clear();
		highlightDrawer.DrawHighlights(onPostTransparentCB, base.transform.position);
		NexusFullScreenPass.Inst.DrawFullscreenPassToCommandBuffer(onPostTransparentCB);
		if (titleCardActive)
		{
			AddTitleCard(onPostTransparentCB);
		}
		return onPostTransparentCB;
	}

	bool NexusRenderPipeline.ICameraEvents.ShouldDrawLight(Camera cam, VisibleLight visibleLight)
	{
		if (!owner)
		{
			return false;
		}
		return owner.gameObject.scene == visibleLight.light.gameObject.scene;
	}

	private void AddTitleCard(CommandBuffer cb)
	{
		cb.DrawRenderer(titleCardMR, titleCardMat);
	}

	public void SetTitleCard(MeshRenderer mr)
	{
		titleCardMR = mr;
		titleCardMat = mr.sharedMaterial;
	}

	private CommandBuffer OnRenderPipelineEnd()
	{
		ConstArray<MRBase> mrsLoaded = LR.Inst.mrsLoaded;
		MRBase[] data = mrsLoaded._data;
		int sLength = mrsLoaded.sLength;
		for (int i = 0; i < sLength; i++)
		{
			MRBase mRBase = data[i];
			if (mRBase.isAwake)
			{
				PortalVariations.RestoreRenderingState(mRBase.portalVariations);
				PortalRenderer.RestoreRenderingState(mRBase.portalRenderers);
				Portal[] data2 = mRBase.portals._data;
				int sLength2 = mRBase.portals.sLength;
				for (int j = 0; j < sLength2; j++)
				{
					data2[j].intersectingRenderers.ClearToDefault();
				}
			}
		}
		return null;
	}

	private CommandBuffer OnPreStereoEndRender()
	{
		onPreStereoEndRenderCB.Clear();
		if ((bool)UIErrorPrompt.Inst && UIErrorPrompt.Inst.CurrentError)
		{
			UIErrorPrompt.Inst.DrawError(onPreStereoEndRenderCB);
		}
		return onPreStereoEndRenderCB;
	}

	private void GatherHighlights()
	{
		highlightDrawer.ResetHightlights();
		Vector3 headPosition = IC.GetHeadPosition();
		Vector3 position = CC.Inst.handL.transform.position;
		Vector3 position2 = CC.Inst.handR.transform.position;
		if (!owner)
		{
			lastActiveHighlights.Clear();
			return;
		}
		float highlightProximityDist = BaseSettings<InteractionSettings>.Inst.highlightProximityDist;
		for (int i = 0; i < owner.interactableObjects._dataNum; i++)
		{
			InteractableObject interactableObject = owner.interactableObjects[i];
			if (interactableObject.highlightPoints.Length != 0 && interactableObject.isActiveAndEnabled && (interactableObject.ShouldProximityHighlight() || interactableObject.ShouldFocusHighlight()))
			{
				ConstArray<ProximityHighlightPoint> constArray = interactableObject.GatherHighlightPoints(null, highlightDrawer, lastActiveHighlights, headPosition, position, position2);
				for (int j = 0; j < constArray.Length; j++)
				{
					activeHighlights.Add(constArray[j]);
				}
			}
		}
		for (int k = 0; k < owner.portals.Length; k++)
		{
			Portal portal = owner.portals[k];
			Portal link = portal.Link;
			portal.PortalCamera.HighlightDrawer.ResetHightlights();
			if ((object)link == null || !portal.IsAwake || !portal.IsVisable || portal.GetPortalState() != 0)
			{
				continue;
			}
			float num = MathfX.Min(Vector3.Distance(portal.GetClosestPointOnPortal(headPosition), headPosition), Vector3.Distance(portal.GetClosestPointOnPortal(position), position), Vector3.Distance(portal.GetClosestPointOnPortal(position2), position2));
			if (!(num <= highlightProximityDist))
			{
				continue;
			}
			float distanceFromPortal = highlightProximityDist - num;
			if ((object)link.owner == null || link.owner.interactableObjects == null)
			{
				continue;
			}
			for (int l = 0; l < link.owner.interactableObjects.Length; l++)
			{
				InteractableObject interactableObject2 = portal.owner.interactableObjects[l];
				if ((bool)interactableObject2 && interactableObject2.highlightPoints.Length != 0 && interactableObject2.isActiveAndEnabled && (interactableObject2.ShouldProximityHighlight() || interactableObject2.ShouldFocusHighlight()))
				{
					ConstArray<ProximityHighlightPoint> constArray2 = interactableObject2.GatherHighlightPoints(portal, portal.PortalCamera.HighlightDrawer, lastActiveHighlights, headPosition, position, position2, distanceFromPortal);
					for (int m = 0; m < constArray2.Length; m++)
					{
						activeHighlights.Add(constArray2[m]);
					}
				}
			}
		}
		lastActiveHighlights.Clear();
		foreach (ProximityHighlightPoint activeHighlight in activeHighlights)
		{
			lastActiveHighlights.Add(activeHighlight);
		}
		activeHighlights.Clear();
	}
}
public class MeshCombine : MonoBehaviour, IPrebuildEvent
{
	public int sortOrder;

	public bool generateCollider;

	public bool cullBackFaces;

	public void Combine(Vector3[] viewpoints)
	{
		MeshCombiner.Combine(GetComponentsInChildren<MeshRenderer>(), base.transform, generateCollider, sortOrder, cullBackFaces ? viewpoints : null);
	}

	void IPrebuildEvent.OnPrebuildRoot(bool isPrefab)
	{
		MeshCombiner.Combine(GetComponentsInChildren<MeshRenderer>(), base.transform, generateCollider, sortOrder);
	}
}
public static class MeshCombiner
{
	private class MergedMesh
	{
		public List<Vector3> mergedVertices = new List<Vector3>();

		public List<Vector3> mergedNormals = new List<Vector3>();

		public List<Vector4> mergedTangents = new List<Vector4>();

		public List<Color> mergedColors = new List<Color>();

		public List<Vector2> mergedUV0s = new List<Vector2>();

		public List<Vector2> mergedUV1s = new List<Vector2>();

		public List<Vector2> mergedUV2s = new List<Vector2>();

		public List<Vector2> mergedUV3s = new List<Vector2>();

		public List<int> mergedIndices = new List<int>();

		public bool expectNormals;

		public bool expectTangents;

		public bool expectColors;

		public bool expectUV0;

		public bool expectUV1;

		public bool expectUV2;

		public bool expectUV3;

		public Mesh firstMesh;

		public Material sharedMaterial;
	}

	public static void Combine(MeshRenderer[] mrs, Transform parent, bool generateCollider = false, int sortOrder = 0, Vector3[] backFaceCullViewpoints = null)
	{
		int num = -1;
		Dictionary<Material, List<MergedMesh>> dictionary = new Dictionary<Material, List<MergedMesh>>();
		for (uint num2 = 0u; num2 < mrs.Length; num2++)
		{
			MeshRenderer meshRenderer = mrs[num2];
			if (num == -1)
			{
				num = meshRenderer.lightmapIndex;
			}
			MeshFilter component = meshRenderer.GetComponent<MeshFilter>();
			if (meshRenderer.sharedMaterial == null)
			{
				UnityEngine.Debug.LogError("MeshRenderer has a null material", meshRenderer);
			}
			else
			{
				if (component == null)
				{
					continue;
				}
				if (component.sharedMesh == null)
				{
					UnityEngine.Debug.LogError("MeshFilter '" + component.name + "' has a null mesh.", component);
					continue;
				}
				if (component.sharedMesh.subMeshCount > 1)
				{
					UnityEngine.Debug.LogWarning("Mesh has multiple sub-meshes and cannot be batched!", component);
					continue;
				}
				if (component.sharedMesh.normals == null)
				{
					UnityEngine.Debug.LogWarning("Mesh has multiple sub-meshes and cannot be batched!", component);
					continue;
				}
				Mesh sharedMesh = component.sharedMesh;
				Vector3[] array = sharedMesh.vertices;
				Vector3[] array2 = sharedMesh.normals;
				Vector4[] array3 = sharedMesh.tangents;
				Color[] array4 = sharedMesh.colors;
				Vector2[] array5 = sharedMesh.uv;
				Vector2[] array6 = sharedMesh.uv2;
				Vector2[] array7 = sharedMesh.uv3;
				Vector2[] array8 = sharedMesh.uv4;
				int[] array9 = sharedMesh.triangles;
				if (!dictionary.TryGetValue(meshRenderer.sharedMaterial, out var value))
				{
					value = new List<MergedMesh>();
					dictionary.Add(meshRenderer.sharedMaterial, value);
				}
				MergedMesh mergedMesh = null;
				if (value.Count != 0)
				{
					mergedMesh = value[value.Count - 1];
					if (mergedMesh.mergedVertices.Count + array.Length > 60000)
					{
						mergedMesh = null;
					}
				}
				if (mergedMesh == null)
				{
					mergedMesh = new MergedMesh();
					mergedMesh.expectNormals = !ArrayX.IsNullOrEmpty(array2);
					mergedMesh.expectTangents = !ArrayX.IsNullOrEmpty(array3);
					mergedMesh.expectColors = !ArrayX.IsNullOrEmpty(array4);
					mergedMesh.expectUV0 = !ArrayX.IsNullOrEmpty(array5);
					mergedMesh.expectUV1 = !ArrayX.IsNullOrEmpty(array6);
					mergedMesh.expectUV2 = !ArrayX.IsNullOrEmpty(array7);
					mergedMesh.expectUV3 = !ArrayX.IsNullOrEmpty(array8);
					mergedMesh.firstMesh = sharedMesh;
					mergedMesh.sharedMaterial = meshRenderer.sharedMaterial;
					value.Add(mergedMesh);
				}
				if (ArrayX.IsNullOrEmpty(array2) == mergedMesh.expectNormals && array2.Length != array.Length)
				{
					UnityEngine.Debug.LogError("Mesh " + sharedMesh.name + " has inconsistant normals compared with " + mergedMesh.firstMesh, component);
					continue;
				}
				if (ArrayX.IsNullOrEmpty(array3) == mergedMesh.expectTangents && array3.Length != array.Length)
				{
					UnityEngine.Debug.LogError("Mesh " + sharedMesh.name + " has inconsistant tangents compared with " + mergedMesh.firstMesh, component);
					continue;
				}
				if (ArrayX.IsNullOrEmpty(array4) == mergedMesh.expectColors && array4.Length != array.Length)
				{
					UnityEngine.Debug.LogError("Mesh " + sharedMesh.name + " has inconsistant colors compared with " + mergedMesh.firstMesh, component);
					continue;
				}
				if (ArrayX.IsNullOrEmpty(array5) == mergedMesh.expectUV0 && array5.Length != array.Length)
				{
					UnityEngine.Debug.LogError("Mesh " + sharedMesh.name + " has inconsistant UV1's compared with " + mergedMesh.firstMesh, component);
					continue;
				}
				if (ArrayX.IsNullOrEmpty(array6) == mergedMesh.expectUV1 && array6.Length != array.Length)
				{
					UnityEngine.Debug.LogError("Mesh " + sharedMesh.name + " has inconsistant UV2's compared with " + mergedMesh.firstMesh, component);
					continue;
				}
				if (ArrayX.IsNullOrEmpty(array7) == mergedMesh.expectUV2 && array7.Length != array.Length)
				{
					UnityEngine.Debug.LogError("Mesh " + sharedMesh.name + " has inconsistant UV3's compared with " + mergedMesh.firstMesh, component);
					continue;
				}
				if (ArrayX.IsNullOrEmpty(array8) == mergedMesh.expectUV3 && array8.Length != array.Length)
				{
					UnityEngine.Debug.LogError("Mesh " + sharedMesh.name + " has inconsistant UV4's compared with " + mergedMesh.firstMesh, component);
					continue;
				}
				if (!ArrayX.IsNullOrEmpty(backFaceCullViewpoints))
				{
					List<int> list = new List<int>(array9.Length);
					int[] array10 = new int[array.Length];
					int[] array11 = Enumerable.Range(0, array.Length).ToArray();
					bool flag = false;
					Matrix4x4 localToWorldMatrix = meshRenderer.transform.localToWorldMatrix;
					_ = localToWorldMatrix.inverse.transpose;
					for (int i = 0; i < array9.Length; i += 3)
					{
						Vector3 v = array[array9[i]];
						Vector3 v2 = array[array9[i + 1]];
						Vector3 v3 = array[array9[i + 2]];
						Vector3 vector = localToWorldMatrix * v.V3ToV4(1f);
						Vector3 vector2 = localToWorldMatrix * v2.V3ToV4(1f);
						Vector3 vector3 = localToWorldMatrix * v3.V3ToV4(1f);
						Vector3 vector4 = (vector + vector2 + vector3) / 3f;
						Vector3 normalized = (vector2 - vector).normalized;
						Vector3 normalized2 = Vector3.Cross((vector2 - vector3).normalized, normalized).normalized;
						foreach (Vector3 vector5 in backFaceCullViewpoints)
						{
							if (Vector3.Dot(normalized2, (vector5 - vector4).normalized) > 0f)
							{
								list.Add(array9[i]);
								list.Add(array9[i + 1]);
								list.Add(array9[i + 2]);
								break;
							}
						}
					}
					HashSet<int> hashSet = new HashSet<int>(list);
					for (int k = 0; k < array.Length; k++)
					{
						if (!hashSet.Contains(k))
						{
							array10[k] = -1;
							flag = true;
						}
					}
					if (flag)
					{
						List<Vector3> list2 = new List<Vector3>();
						List<Vector3> list3 = new List<Vector3>();
						List<Vector4> list4 = new List<Vector4>();
						List<Color> list5 = new List<Color>();
						List<Vector2> list6 = new List<Vector2>();
						List<Vector2> list7 = new List<Vector2>();
						List<Vector2> list8 = new List<Vector2>();
						List<Vector2> list9 = new List<Vector2>();
						List<int> list10 = new List<int>();
						int num3 = 0;
						for (int l = 0; l < array.Length; l++)
						{
							array11[l] = l - num3;
							if (array10[l] == -1)
							{
								num3++;
								continue;
							}
							list2.Add(array[l]);
							if (mergedMesh.expectNormals)
							{
								list3.Add(array2[l]);
							}
							if (mergedMesh.expectTangents)
							{
								list4.Add(array3[l]);
							}
							if (mergedMesh.expectColors)
							{
								list5.Add(array4[l]);
							}
							if (mergedMesh.expectUV0)
							{
								list6.Add(array5[l]);
							}
							if (mergedMesh.expectUV1)
							{
								list7.Add(array6[l]);
							}
							if (mergedMesh.expectUV2)
							{
								list8.Add(array7[l]);
							}
							if (mergedMesh.expectUV3)
							{
								list9.Add(array8[l]);
							}
						}
						for (int m = 0; m < list.Count; m += 3)
						{
							list10.Add(array11[list[m]]);
							list10.Add(array11[list[m + 1]]);
							list10.Add(array11[list[m + 2]]);
						}
						array = list2.ToArray();
						array9 = list10.ToArray();
						if (mergedMesh.expectNormals)
						{
							array2 = list3.ToArray();
						}
						if (mergedMesh.expectTangents)
						{
							array3 = list4.ToArray();
						}
						if (mergedMesh.expectColors)
						{
							array4 = list5.ToArray();
						}
						if (mergedMesh.expectUV0)
						{
							array5 = list6.ToArray();
						}
						if (mergedMesh.expectUV1)
						{
							array6 = list7.ToArray();
						}
						if (mergedMesh.expectUV2)
						{
							array7 = list8.ToArray();
						}
						if (mergedMesh.expectUV3)
						{
							array8 = list9.ToArray();
						}
					}
				}
				int count = mergedMesh.mergedVertices.Count;
				Matrix4x4 localToWorldMatrix2 = meshRenderer.transform.localToWorldMatrix;
				Matrix4x4 transpose = localToWorldMatrix2.inverse.transpose;
				Vector4 lightmapScaleOffset = meshRenderer.lightmapScaleOffset;
				Vector4 vector6 = new Vector4(0f, 0f, 0f, 1f);
				for (int n = 0; n < array.Length; n++)
				{
					vector6.x = array[n].x;
					vector6.y = array[n].y;
					vector6.z = array[n].z;
					vector6.w = 1f;
					vector6 = localToWorldMatrix2 * vector6;
					array[n].x = vector6.x;
					array[n].y = vector6.y;
					array[n].z = vector6.z;
				}
				mergedMesh.mergedVertices.AddRange(array);
				if (mergedMesh.expectNormals)
				{
					Vector4 vector7 = new Vector4(0f, 0f, 0f, 0f);
					for (int num4 = 0; num4 < array2.Length; num4++)
					{
						vector7.x = array2[num4].x;
						vector7.y = array2[num4].y;
						vector7.z = array2[num4].z;
						vector7.w = 0f;
						vector7 = transpose * vector7;
						array2[num4].x = vector7.x;
						array2[num4].y = vector7.y;
						array2[num4].z = vector7.z;
					}
					mergedMesh.mergedNormals.AddRange(array2);
				}
				if (mergedMesh.expectTangents)
				{
					mergedMesh.mergedTangents.AddRange(array3);
				}
				if (mergedMesh.expectColors)
				{
					mergedMesh.mergedColors.AddRange(array4);
				}
				if (mergedMesh.expectUV0)
				{
					mergedMesh.mergedUV0s.AddRange(array5);
				}
				if (mergedMesh.expectUV1)
				{
					Vector2 vector8 = new Vector2(0f, 0f);
					for (int num5 = 0; num5 < array6.Length; num5++)
					{
						vector8.x = array6[num5].x;
						vector8.y = array6[num5].y;
						vector8.x = vector8.x * lightmapScaleOffset.x + lightmapScaleOffset.z;
						vector8.y = vector8.y * lightmapScaleOffset.y + lightmapScaleOffset.w;
						array6[num5].x = vector8.x;
						array6[num5].y = vector8.y;
					}
					mergedMesh.mergedUV1s.AddRange(array6);
				}
				if (mergedMesh.expectUV2)
				{
					mergedMesh.mergedUV2s.AddRange(array7);
				}
				if (mergedMesh.expectUV3)
				{
					mergedMesh.mergedUV3s.AddRange(array8);
				}
				for (int num6 = 0; num6 < array9.Length; num6++)
				{
					array9[num6] += count;
				}
				mergedMesh.mergedIndices.AddRange(array9);
				GameObject gameObject = meshRenderer.gameObject;
				UnityEngine.Object.DestroyImmediate(meshRenderer, allowDestroyingAssets: true);
				UnityEngine.Object.DestroyImmediate(component, allowDestroyingAssets: true);
				if (gameObject.GetComponents<UnityEngine.Component>().Length <= 1 && gameObject.transform.childCount == 0)
				{
					UnityEngine.Object.DestroyImmediate(gameObject, allowDestroyingAssets: true);
				}
			}
		}
		foreach (KeyValuePair<Material, List<MergedMesh>> item in dictionary)
		{
			for (int num7 = 0; num7 < item.Value.Count; num7++)
			{
				MergedMesh mergedMesh2 = item.Value[num7];
				string name = $"COMBINED_{parent.name}_{mergedMesh2.sharedMaterial.name}_{num7}";
				Mesh sharedMesh2 = new Mesh
				{
					vertices = mergedMesh2.mergedVertices.ToArray(),
					normals = mergedMesh2.mergedNormals.ToArray(),
					tangents = mergedMesh2.mergedTangents.ToArray(),
					colors = mergedMesh2.mergedColors.ToArray(),
					uv = mergedMesh2.mergedUV0s.ToArray(),
					uv2 = mergedMesh2.mergedUV1s.ToArray(),
					uv3 = mergedMesh2.mergedUV2s.ToArray(),
					uv4 = mergedMesh2.mergedUV3s.ToArray(),
					triangles = mergedMesh2.mergedIndices.ToArray(),
					name = name
				};
				GameObject gameObject2 = new GameObject(name);
				gameObject2.transform.parent = parent;
				gameObject2.AddComponent<MeshFilter>().sharedMesh = sharedMesh2;
				MeshRenderer meshRenderer2 = gameObject2.AddComponent<MeshRenderer>();
				meshRenderer2.sharedMaterial = mergedMesh2.sharedMaterial;
				meshRenderer2.sortingOrder = sortOrder;
				meshRenderer2.lightmapIndex = num;
				meshRenderer2.lightmapScaleOffset = new Vector4(1f, 1f, 0f, 0f);
				if (generateCollider)
				{
					gameObject2.AddComponent<MeshCollider>().sharedMesh = sharedMesh2;
				}
			}
		}
	}
}
public class MPBStore
{
	private MaterialPropertyBlock propertyBlock;

	private MaterialPropertyBlock storeBlock;

	private ConstArray<int> colorIds = new ConstArray<int>(10u);

	private ConstArray<int> floatIds = new ConstArray<int>(10u);

	private ConstArray<int> floatArrayIds = new ConstArray<int>(10u);

	private ConstArray<int> intIds = new ConstArray<int>(10u);

	private ConstArray<int> matrixIds = new ConstArray<int>(10u);

	private ConstArray<int> matrixArrayIds = new ConstArray<int>(10u);

	private ConstArray<int> textureIds = new ConstArray<int>(10u);

	private ConstArray<int> vectorIds = new ConstArray<int>(10u);

	private ConstArray<int> vectorArrayIds = new ConstArray<int>(10u);

	public void Initialise()
	{
		propertyBlock = new MaterialPropertyBlock();
		storeBlock = new MaterialPropertyBlock();
	}

	public void SetColor(int id, Color value)
	{
		propertyBlock.SetColor(id, value);
		if (!colorIds.Contains(id))
		{
			colorIds.Add(id);
		}
	}

	public void ClearColorID(int id)
	{
		if (colorIds.Contains(id))
		{
			colorIds.Remove(id);
		}
	}

	public Color GetColor(int id)
	{
		return storeBlock.GetColor(id);
	}

	public void SetFloat(int id, float value)
	{
		propertyBlock.SetFloat(id, value);
		if (!floatIds.Contains(id))
		{
			floatIds.Add(id);
		}
	}

	public void ClearFloatID(int id)
	{
		if (floatIds.Contains(id))
		{
			floatIds.Remove(id);
		}
	}

	public float GetFloat(int id)
	{
		return storeBlock.GetFloat(id);
	}

	public void SetFloatArray(int id, float[] value)
	{
		propertyBlock.SetFloatArray(id, value);
		if (!floatArrayIds.Contains(id))
		{
			floatArrayIds.Add(id);
		}
	}

	public void ClearFloatArrayID(int id)
	{
		if (floatArrayIds.Contains(id))
		{
			floatArrayIds.Remove(id);
		}
	}

	public float[] GetFloatArray(int id)
	{
		return storeBlock.GetFloatArray(id);
	}

	public void SetInt(int id, int value)
	{
		propertyBlock.SetInt(id, value);
		if (!intIds.Contains(id))
		{
			intIds.Add(id);
		}
	}

	public void ClearIntID(int id)
	{
		if (intIds.Contains(id))
		{
			intIds.Remove(id);
		}
	}

	public int GetInt(int id)
	{
		return storeBlock.GetInt(id);
	}

	public void SetMatrix(int id, Matrix4x4 value)
	{
		propertyBlock.SetMatrix(id, value);
		if (!matrixIds.Contains(id))
		{
			matrixIds.Add(id);
		}
	}

	public void ClearMatrixID(int id)
	{
		if (matrixIds.Contains(id))
		{
			matrixIds.Remove(id);
		}
	}

	public Matrix4x4 GetMatrix(int id)
	{
		return storeBlock.GetMatrix(id);
	}

	public void SetMatrixArray(int id, Matrix4x4[] value)
	{
		propertyBlock.SetMatrixArray(id, value);
		if (!matrixArrayIds.Contains(id))
		{
			matrixArrayIds.Add(id);
		}
	}

	public void ClearMatrixArrayID(int id)
	{
		if (matrixArrayIds.Contains(id))
		{
			matrixArrayIds.Remove(id);
		}
	}

	public Matrix4x4[] GetMatrixArray(int id)
	{
		return storeBlock.GetMatrixArray(id);
	}

	public void SetTexture(int id, Texture value)
	{
		propertyBlock.SetTexture(id, value);
		if (!textureIds.Contains(id))
		{
			textureIds.Add(id);
		}
	}

	public void ClearTextureID(int id)
	{
		if (textureIds.Contains(id))
		{
			textureIds.Remove(id);
		}
	}

	public Texture GetTexture(int id)
	{
		return storeBlock.GetTexture(id);
	}

	public void SetVector(int id, Vector4 value)
	{
		propertyBlock.SetVector(id, value);
		if (!vectorIds.Contains(id))
		{
			vectorIds.Add(id);
		}
	}

	public void ClearVectorID(int id)
	{
		if (vectorIds.Contains(id))
		{
			vectorIds.Remove(id);
		}
	}

	public Vector4 GetVector(int id)
	{
		return storeBlock.GetVector(id);
	}

	public void SetVectorArray(int id, Vector4[] value)
	{
		propertyBlock.SetVectorArray(id, value);
		if (!vectorArrayIds.Contains(id))
		{
			vectorArrayIds.Add(id);
		}
	}

	public void ClearVectorArrayID(int id)
	{
		if (vectorArrayIds.Contains(id))
		{
			vectorArrayIds.Remove(id);
		}
	}

	public Vector4[] GetVectorArray(int id)
	{
		return storeBlock.GetVectorArray(id);
	}

	public void ApplyProperties(Renderer renderer)
	{
		renderer.GetPropertyBlock(storeBlock);
		for (int i = 0; i < colorIds.Length; i++)
		{
			storeBlock.SetColor(colorIds[i], propertyBlock.GetColor(colorIds[i]));
		}
		for (int j = 0; j < floatIds.Length; j++)
		{
			storeBlock.SetFloat(floatIds[j], propertyBlock.GetFloat(floatIds[j]));
		}
		for (int k = 0; k < floatArrayIds.Length; k++)
		{
			storeBlock.SetFloatArray(floatArrayIds[k], propertyBlock.GetFloatArray(floatArrayIds[k]));
		}
		for (int l = 0; l < intIds.Length; l++)
		{
			storeBlock.SetInt(intIds[l], propertyBlock.GetInt(intIds[l]));
		}
		for (int m = 0; m < matrixIds.Length; m++)
		{
			storeBlock.SetMatrix(matrixIds[m], propertyBlock.GetMatrix(matrixIds[m]));
		}
		for (int n = 0; n < matrixArrayIds.Length; n++)
		{
			storeBlock.SetMatrixArray(matrixArrayIds[n], propertyBlock.GetMatrixArray(matrixArrayIds[n]));
		}
		for (int num = 0; num < textureIds.Length; num++)
		{
			storeBlock.SetTexture(textureIds[num], propertyBlock.GetTexture(textureIds[num]));
		}
		for (int num2 = 0; num2 < vectorIds.Length; num2++)
		{
			storeBlock.SetVector(vectorIds[num2], propertyBlock.GetVector(vectorIds[num2]));
		}
		for (int num3 = 0; num3 < vectorArrayIds.Length; num3++)
		{
			storeBlock.SetVectorArray(vectorArrayIds[num3], propertyBlock.GetVectorArray(vectorArrayIds[num3]));
		}
		renderer.SetPropertyBlock(storeBlock);
	}

	public void ApplyProperties(Renderer[] renderers)
	{
		int num = renderers.Length;
		for (int i = 0; i < num; i++)
		{
			ApplyProperties(renderers[i]);
		}
	}
}
[Serializer.ExcludeAllFields]
public class MultiLightmapController : MonoBehaviour, IPrebuildEvent
{
	[Serializable]
	private class LightingScenario
	{
		public GameObject lightingRoot;

		public Texture2D[] lightmaps;

		public LightmapsMode lightmapsMode;
	}

	[SerializeField]
	private LightingScenario[] lightingSetups;

	private MRBase owner;

	[Serializer.IncludeField]
	[SerializeField]
	[HideInInspector]
	private int activeIndex;

	private string filePath;

	private bool lastBakeSaved = true;

	[HideInInspector]
	public bool lightmapsFinalized = true;

	public bool SafeToChange => lastBakeSaved;

	public string GetCurrentLightingName()
	{
		return lightingSetups[activeIndex]?.lightingRoot?.name ?? "";
	}

	[Event(EventName = "Change Light Map (Runtime)")]
	public void ChangeLightMapRunTime(object sender)
	{
		activeIndex++;
		if (activeIndex >= lightingSetups.Length)
		{
			activeIndex = 0;
		}
		ApplyCurrentLightingRuntime();
	}

	public void OnAwakeLR(MRBase owner)
	{
		UnityEngine.Debug.Log($"Waking up controller with index: {activeIndex}");
		SetLightMap(activeIndex);
	}

	public void SetLightMap(int index)
	{
	}

	private void ApplyCurrentLightingRuntime()
	{
	}

	void IPrebuildEvent.OnPrebuildRoot(bool isPrefab)
	{
		activeIndex = 0;
		LightingScenario[] array = lightingSetups;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].lightingRoot.SetActive(value: false);
		}
	}
}
public class NexusFullScreenPass
{
	private static NexusFullScreenPass _instance;

	[NonSerialized]
	[HideInInspector]
	public Mesh fullscreenMesh;

	public Mesh vignetteMesh;

	public Mesh newVignetteMesh;

	public static Color offWhite = new Color(0.9137255f, 0.9137255f, 0.9137255f, 1f);

	private static Color outOfBoundsColor = new Color(0.075f, 0.075f, 0.075f, 1f);

	private MaterialPropertyBlock propertyBlockOutOfBounds;

	private MaterialPropertyBlock propertyBlockVignette;

	private Color tintColor;

	private ColorAnimator outOfBoundsColorAnimator;

	private OutOfBoundsSystem.PositionData lastValidEyePosL;

	private OutOfBoundsSystem.PositionData lastValidEyePosR;

	private Vector3 lastValidStairwayPos;

	[HideInInspector]
	public bool isFadeActive;

	[HideInInspector]
	public bool isFadeOOB;

	[HideInInspector]
	public bool isFadeCutscene;

	private bool outOfBoundsTriggered;

	private float outOfBoundsTime;

	[HideInInspector]
	public float fadeAlpha;

	private float lastFadeAlpha;

	private Color currTargetColor;

	private FMOD.Studio.EventInstance outOfBoundsSnapshot;

	private ConstArray<Region> cutsceneRegions = new ConstArray<Region>(2u);

	private bool useOverrideCutscene;

	private float oobMaxFade;

	private float oobStartDist;

	private float oobMaxDist;

	private float oobPauseAlpha;

	private Vector3 lastValidStaticPosition;

	private bool lastValidStaticPositionRecorded;

	private bool walkedOntoStairway;

	private bool walkedOntoStairwayTriggered;

	private FloatAnimator vignetteStrengthAnimator = new FloatAnimator();

	public Vector4 vignetteSettings = new Vector4(0.8f, 0.5f, 0f, 0f);

	public Vector4 lookAtSettings = new Vector4(0.8f, 0.5f, 0f, 0f);

	public Vector3 lookAtDirectionTarget;

	public float lookAtProximityTarget;

	[HideInInspector]
	public ColorAnimator fadeAnimator = new ColorAnimator();

	public float errorOverride;

	public static NexusFullScreenPass Inst => _instance;

	public MaterialPropertyBlock PropertyBlockOutOfBounds
	{
		get
		{
			propertyBlockOutOfBounds.SetColor(ShaderPID._Color, tintColor);
			return propertyBlockOutOfBounds;
		}
	}

	public MaterialPropertyBlock PropertyBlockVignette
	{
		get
		{
			UpdateVignetteSettings();
			propertyBlockVignette.SetVector(ShaderPID._VignetteSettings, vignetteSettings);
			propertyBlockVignette.SetVector(ShaderPID._LookAtSettings, lookAtSettings);
			return propertyBlockVignette;
		}
	}

	public bool IsClear()
	{
		return tintColor.a <= 0f;
	}

	public void OnAwakeMainCamera()
	{
		_instance = this;
		fullscreenMesh = new Mesh
		{
			vertices = new Vector3[4]
			{
				new Vector3(-1f, -1f, 0f),
				new Vector3(-1f, 1f, 0f),
				new Vector3(1f, -1f, 0f),
				new Vector3(1f, 1f, 0f)
			},
			triangles = new int[6] { 0, 1, 2, 2, 1, 3 },
			uv = new Vector2[4]
			{
				new Vector2(0f, 0f),
				new Vector2(0f, 1f),
				new Vector2(1f, 0f),
				new Vector2(1f, 1f)
			}
		};
		propertyBlockOutOfBounds = new MaterialPropertyBlock();
		propertyBlockVignette = new MaterialPropertyBlock();
	}

	public void InitSnapshot()
	{
		outOfBoundsSnapshot = FAC.Inst.PlaySnapShot(BaseSettings<TeleportSettings>.Inst.outOfBoundsSnapshot);
		outOfBoundsSnapshot.setParameterValue("Filter", 0f);
	}

	public void OnUpdateLR(MRBase owner)
	{
		TeleportSettings.VignettePreset vignettePreset = BaseSettings<TeleportSettings>.Inst.VignetteSettings;
		if (CC.Inst.freeMove.HasMoved || BaseSettings<TeleportSettings>.Inst.vignetteForceShow)
		{
			vignetteStrengthAnimator.AnimateTo(vignettePreset.vignetteStrength, vignettePreset.vignetteFadeTime, onlyResetIfNewTarget: true);
		}
		else
		{
			vignetteStrengthAnimator.AnimateTo(0f, vignettePreset.vignetteFadeTime, onlyResetIfNewTarget: true);
		}
	}

	private void UpdateVignetteSettings()
	{
		TeleportSettings.VignettePreset vignettePreset = BaseSettings<TeleportSettings>.Inst.VignetteSettings;
		vignetteSettings.x = vignettePreset.vignetteRadius;
		vignetteSettings.y = vignettePreset.vignetteSoftness;
		vignetteSettings.z = vignetteStrengthAnimator.CurrentValue;
		vignetteSettings.w = ((!CanVignetteShow()) ? 1 : 0);
	}

	public bool CanVignetteShow()
	{
		if (tintColor.a < 0.05f)
		{
			return true;
		}
		return false;
	}

	public void ForceUpdateLastValidPosition()
	{
		MRBase owner = MainCamera.Inst.GetOwner();
		MainCamera.Inst.GetEyePositions(out var left, out var right);
		Vector3 gravityDir = -CC.Inst.transform.up;
		OutOfBoundsSystem.TestOutOfBoundsPositions(owner, gravityDir, left, right, lastValidEyePosL, lastValidEyePosR, out var eyeLResult, out var eyeRResult);
		eyeLResult.region = eyeLResult.regionStoodOver;
		eyeRResult.region = eyeRResult.regionStoodOver;
		lastValidEyePosL = eyeLResult;
		lastValidEyePosR = eyeRResult;
	}

	public void UpdateOutOfBounds()
	{
		MainCamera inst = MainCamera.Inst;
		MRBase owner = inst.GetOwner();
		CC inst2 = CC.Inst;
		LR inst3 = LR.Inst;
		if (!inst2 || !owner || !inst.gameObject.activeInHierarchy)
		{
			return;
		}
		TeleportSettings inst4 = BaseSettings<TeleportSettings>.Inst;
		UIPauseMenu inst5 = UIPauseMenu.Inst;
		Vector3 position = inst5.transform.position;
		Transform transform = inst2.transform;
		Transform transform2 = inst.transform;
		Vector3 position2 = transform2.position;
		Vector3 position3 = transform.position;
		Vector3 up = transform.up;
		Vector3 gravityDir = -up;
		float realDeltaTime = IC.RealDeltaTime;
		isFadeCutscene = false;
		inst.GetEyePositions(out var left, out var right);
		OutOfBoundsSystem.TestOutOfBoundsPositions(owner, gravityDir, left, right, lastValidEyePosL, lastValidEyePosR, out var eyeLResult, out var eyeRResult);
		OutOfBoundsSystem.CollisionData collisionData = OutOfBoundsSystem.TestOutOfBoundsCollision(eyeLResult, lastValidEyePosL);
		OutOfBoundsSystem.CollisionData collisionData2 = OutOfBoundsSystem.TestOutOfBoundsCollision(eyeRResult, lastValidEyePosR);
		float a = 0f;
		float b = 0f;
		bool num = !eyeLResult.isValid && (bool)eyeLResult.regionStoodOver && eyeLResult.region != lastValidEyePosL.region;
		bool flag = !eyeRResult.isValid && (bool)eyeRResult.regionStoodOver && eyeRResult.region != lastValidEyePosR.region;
		float num2 = inst4.farFromRegionDist;
		if (lastValidEyePosL.region != null && lastValidEyePosL.region.overrideFarFromRegionDist != 0f)
		{
			num2 = lastValidEyePosL.region.overrideFarFromRegionDist;
		}
		bool flag2 = (eyeLResult.worldPos - eyeLResult.constrainedWorldPos).magnitude > num2;
		bool flag3 = (eyeRResult.worldPos - eyeRResult.constrainedWorldPos).magnitude > num2;
		bool flag4 = false;
		if (flag2 || flag3)
		{
			Vector3 worldFloorPosition = CC.Inst.GetWorldFloorPosition(IC.GetHeadPosition());
			flag4 = !CC.Inst.CheckStairwayCollision(owner, worldFloorPosition);
			if (!flag4)
			{
				lastValidStairwayPos = worldFloorPosition;
			}
			if (flag2)
			{
				flag2 = flag4;
			}
			if (flag3)
			{
				flag3 = flag4;
			}
			if (!walkedOntoStairwayTriggered)
			{
				walkedOntoStairway = !flag4;
				walkedOntoStairwayTriggered = true;
			}
		}
		else
		{
			walkedOntoStairway = false;
			walkedOntoStairwayTriggered = false;
		}
		float num3 = fadeAlpha;
		float sqrMagnitude = (position - position2).sqrMagnitude;
		bool flag5 = num || flag;
		bool flag6 = flag2 || flag3;
		bool flag7 = !flag5 && inst3.IsPaused && inst5.IsShown && sqrMagnitude > 3f;
		isFadeOOB = flag5 || flag7 || flag6;
		bool flag8 = inst5.IsShown && inst5.requiresFullScreenFade;
		if (isFadeOOB || flag8)
		{
			b = (a = Mathf.MoveTowards(num3, 1f, realDeltaTime * inst4.outOfBoundsFadeInSpeed));
		}
		else if (collisionData.isOutOfBounds || collisionData2.isOutOfBounds)
		{
			if (collisionData.isOutOfBounds)
			{
				float value = Mathf.Clamp(collisionData.raycastHitDistance - collisionData.objectDistance, 0.02f, 0.08f);
				a = Mathf.Lerp(1f, 0f, Mathf.InverseLerp(0.02f, 0.08f, value));
				isFadeOOB = true;
			}
			if (collisionData2.isOutOfBounds)
			{
				float value2 = Mathf.Clamp(collisionData2.raycastHitDistance - collisionData2.objectDistance, 0.02f, 0.08f);
				b = Mathf.Lerp(1f, 0f, Mathf.InverseLerp(0.02f, 0.08f, value2));
				isFadeOOB = true;
			}
		}
		else if (num3 > 0f)
		{
			b = (a = Mathf.MoveTowards(num3, 0f, realDeltaTime * inst4.outOfBoundsFadeInSpeed));
		}
		float num4 = Mathf.Max(a, b);
		bool flag9 = isFadeOOB && !inst5.IsShown && num4 > inst4.outOfBoundsIndicatorAlpha;
		if (eyeLResult.isValid && eyeRResult.isValid && !collisionData.isOutOfBounds && !collisionData2.isOutOfBounds)
		{
			lastValidEyePosL = eyeLResult;
			lastValidEyePosR = eyeRResult;
		}
		float num5 = 0f;
		Region region = null;
		MRBase owner2 = inst.GetOwner();
		for (int i = 0; i < cutsceneRegions.sLength; i++)
		{
			if (cutsceneRegions[i].owner == owner2)
			{
				region = cutsceneRegions[i];
				break;
			}
		}
		if (region != null && !inst3.IsPaused)
		{
			Vector2 vector = region.transform.InverseTransformPoint(position2).ToXZ();
			Vector2 vector2 = region.ClosestLocalPosOnEdge(vector, inner: false);
			float magnitude = (vector - vector2).magnitude;
			if (magnitude < oobStartDist)
			{
				num5 = (1f - Mathf.Clamp01((magnitude - oobMaxDist) / oobStartDist)) * oobMaxFade;
				isFadeOOB = true;
				isFadeCutscene = true;
			}
			if (num5 > oobPauseAlpha && !isFadeActive)
			{
				VOC.Inst.OnPauseLR(paused: true);
				FAC.Inst.GetBus("bus:/Submix").setPaused(paused: true);
				Time.timeScale = 0f;
				IC.Inst.PauseMenuEnabled = false;
				IC.Inst.RecenterEnabled = false;
			}
			else if (Time.timeScale < 1f && !isFadeActive)
			{
				VOC.Inst.OnPauseLR(paused: false);
				FAC.Inst.GetBus("bus:/Submix").setPaused(paused: false);
				Time.timeScale = 1f;
				IC.Inst.PauseMenuEnabled = true;
				IC.Inst.RecenterEnabled = true;
			}
		}
		if (!Mathf.Approximately(num4, 1f))
		{
			float f = num4 - fadeAlpha;
			float num6 = Mathf.Abs(f);
			float num7 = Mathf.Clamp((realDeltaTime != 0f) ? (num6 / realDeltaTime) : 0f, 0f, inst4.outOfBoundsFadeOutSpeed) * realDeltaTime * Mathf.Sign(f);
			num4 = Mathf.Clamp01(fadeAlpha + num7);
		}
		fadeAlpha = Mathf.Max(num4, num5, errorOverride);
		outOfBoundsSnapshot.setParameterValue("Filter", fadeAlpha);
		isFadeActive = (isFadeActive ? (num4 >= 0.5f) : (num4 == 1f));
		bool flag10 = inst3.IsAllConnectedSceneLoadingUnloadingComplete() && IC.Inst.PauseMenuEnabled && !inst5.IsShown;
		if (isFadeActive)
		{
			if (!outOfBoundsTriggered)
			{
				outOfBoundsTriggered = true;
				PlayerTeleport.TeleportEnabled.Value = false;
				if (flag10 && !inst3.IsPaused)
				{
					inst3.Pause(paused: true, lockMovement: false);
					UnityEngine.Debug.Log("Pausing as player is OOB");
				}
			}
			if (!lastValidStaticPositionRecorded)
			{
				lastValidStaticPositionRecorded = true;
				lastValidStaticPosition = (walkedOntoStairway ? lastValidStairwayPos : Vector3.Lerp(lastValidEyePosL.constrainedWorldPos, lastValidEyePosR.constrainedWorldPos, 0.5f));
			}
		}
		else
		{
			if (outOfBoundsTriggered)
			{
				outOfBoundsTriggered = false;
				PlayerTeleport.TeleportEnabled.Value = true;
				if (flag10 && inst3.IsPaused)
				{
					inst3.Pause(paused: false, lockMovement: false);
					UnityEngine.Debug.Log("Resuming as player is in bounds");
				}
			}
			lastValidStaticPositionRecorded = false;
		}
		OutOfBoundsIndicator oOBIndicator = inst2.OOBIndicator;
		Vector3 forward = transform2.forward;
		Vector3 vector3 = Vector3.ProjectOnPlane(position2 - position3, up);
		Vector3 normalized = Vector3.ProjectOnPlane(forward, up).normalized;
		float t = Mathf.Clamp01(realDeltaTime * inst4.outOfBoundsLerpSpeed);
		Vector3 vector4 = position3 + vector3;
		Vector3 vector5 = (inst5.IsShown ? position : (lastValidStaticPositionRecorded ? lastValidStaticPosition : (walkedOntoStairway ? lastValidStairwayPos : Vector3.Lerp(lastValidEyePosL.constrainedWorldPos, lastValidEyePosR.constrainedWorldPos, 0.5f))));
		Vector3 newPosWSText = Vector3.Lerp(b: vector4 + normalized * inst4.outOfBoundsTextZOffset + up * inst4.outOfBoundsTextYOffset, a: oOBIndicator.textTS.position, t: t);
		Vector3 b3 = vector4 + normalized * inst4.outOfBoundsArrowZOffset + up * inst4.outOfBoundsArrowYOffset;
		b3 = Vector3.Lerp(oOBIndicator.arrowTS.position, b3, t);
		Vector3 vector6 = vector5 - position3;
		Vector3 newPosWSPoint = position3 + Vector3.ProjectOnPlane(vector6, up);
		Quaternion b4 = Quaternion.LookRotation(normalized, up);
		b4 = Quaternion.Lerp(oOBIndicator.textTS.rotation, b4, t);
		Quaternion b5 = Quaternion.LookRotation(Vector3.ProjectOnPlane(vector5 - position2, up).normalized + up * inst4.outOfBoundsArrowYTilt, up);
		b5 = Quaternion.Lerp(oOBIndicator.arrowTS.rotation, b5, t);
		Quaternion newRotPoint = Quaternion.LookRotation(transform.forward, up);
		float newArrowBobTime;
		float textAlpha;
		if (flag9)
		{
			outOfBoundsTime += realDeltaTime;
			newArrowBobTime = inst4.outOfBoundsArrowBobDistance * Mathf.Sin((float)Math.PI * outOfBoundsTime * inst4.outOfBoundsArrowBobSpeed);
			textAlpha = Mathf.Clamp01((outOfBoundsTime - inst4.outOfBoundsTextFadeInitial) / inst4.outOfBoundsTextFadeTotal);
		}
		else
		{
			textAlpha = 0f;
			newArrowBobTime = 0f;
			outOfBoundsTime = 0f;
		}
		oOBIndicator.UpdateOOB(newPosWSText, b3, newPosWSPoint, b4, b5, newRotPoint, textAlpha, newArrowBobTime, flag9);
		inst2.TrackingCircle.OnUpdateLR();
	}

	public void SetCutscene(Region regionA, bool overrideValues = false, float maxFade = 0f, float startDist = 0f, float maxDist = 0f, float pauseAlpha = 0f, Region regionB = null)
	{
		cutsceneRegions.Add(regionA);
		if ((bool)regionB)
		{
			cutsceneRegions.Add(regionB);
		}
		useOverrideCutscene = overrideValues;
		if (useOverrideCutscene)
		{
			oobMaxFade = maxFade;
			oobStartDist = startDist;
			oobMaxDist = maxDist;
			oobPauseAlpha = pauseAlpha;
		}
		else
		{
			TeleportSettings inst = BaseSettings<TeleportSettings>.Inst;
			oobMaxFade = inst.cutsceneOOBMaxFade;
			oobStartDist = inst.cutsceneOOBStartDist;
			oobMaxDist = inst.cutsceneOOBMaxDist;
			oobPauseAlpha = inst.cutsceneOOBPauseAlpha;
		}
	}

	public void FinishedCutscene()
	{
		cutsceneRegions.ClearToDefault();
	}

	public Wait StartFadeToClear(float fadeTime, AnimationCurve animationCurve = null)
	{
		return fadeAnimator.ColorAnimateWithTime(Color.clear, fadeTime, animationCurve);
	}

	public Wait StartFadeToBlack(float fadeTime, float fadeStrength = 1f, AnimationCurve animationCurve = null)
	{
		return fadeAnimator.ColorAnimateWithTime(Color.black.RepA(fadeStrength), fadeTime, animationCurve);
	}

	public Wait StartFadeToColor(float fadeTime, Color color, float fadeStrength = 1f, AnimationCurve animationCurve = null)
	{
		return fadeAnimator.ColorAnimateWithTime(color.RepA(fadeStrength), fadeTime, animationCurve);
	}

	public void DrawFullscreenPassToCommandBuffer(CommandBuffer cb)
	{
		if (!(fullscreenMesh == null))
		{
			if (lastFadeAlpha == 0f && fadeAlpha > 0f)
			{
				currTargetColor = (isFadeOOB ? outOfBoundsColor : offWhite);
			}
			if (lastFadeAlpha != fadeAlpha)
			{
				lastFadeAlpha = fadeAlpha;
			}
			Color currentColor = fadeAnimator.CurrentColor;
			tintColor = Color.Lerp(currentColor, currTargetColor, fadeAlpha);
			tintColor.a = Mathf.Max(currentColor.a, fadeAlpha);
			cb.DrawMesh(BaseSettings<TeleportSettings>.Inst.vignetteMesh, Matrix4x4.identity, BaseSettings<TeleportSettings>.Inst.vignetteMaterial, 0, 0, PropertyBlockVignette);
			if (tintColor.a > 0f)
			{
				int value = ((fadeAlpha > 0f) ? 1 : 0);
				cb.SetGlobalInt(ShaderPID._DepthWrite, value);
				cb.DrawMesh(fullscreenMesh, Matrix4x4.identity, BaseSettings<TeleportSettings>.Inst.outOfBoundsMaterial, 0, 0, PropertyBlockOutOfBounds);
			}
		}
	}

	public void UpdateLastValidPosDynamic(Vector3 offset)
	{
		lastValidEyePosL.worldPos += offset;
		lastValidEyePosL.constrainedWorldPos += offset;
		lastValidEyePosR.worldPos += offset;
		lastValidEyePosR.constrainedWorldPos += offset;
	}
}
public class NexusRenderPipeline : RenderPipeline
{
	public interface ICameraEvents
	{
		bool ShouldDraw { get; }

		bool ShouldDrawOverlayPass { get; }

		bool EventsEnabled { get; }

		RenderStateBlock CameraRenderState { get; }

		void OnPreCullParams(Camera cam);

		void OnPreCullSubmit(Camera cam, bool willDraw, ref ScriptableCullingParameters cullParams, bool willDrawFrontOfPortal, ref ScriptableCullingParameters cullParamsFrontOfPortal);

		void OnPostCull(Camera cam);

		CommandBuffer OnSetupCameraProperties(Camera cam, CommandBuffer camPropsCMB);

		CommandBuffer OnPreOpaque(Camera cam, ref DrawRendererSettings drawSettings, ref FilterRenderersSettings filterSettings);

		CommandBuffer OnPostOpaque(Camera cam);

		CommandBuffer OnPortalStencil(Camera cam);

		CommandBuffer OnPortalClear(Camera cam);

		CommandBuffer OnPreTransparent(Camera cam, ref DrawRendererSettings drawSettings, ref FilterRenderersSettings filterSettings);

		CommandBuffer OnPostTransparent(Camera cam);

		bool ShouldDrawLight(Camera cam, VisibleLight visibleLight);
	}

	public enum PipelineEvent
	{
		Start,
		End,
		PreStereoEndRender
	}

	private struct PipelineEventHandler
	{
		public readonly Func<CommandBuffer> callback;

		public readonly bool executeInEditMode;

		public PipelineEventHandler(Func<CommandBuffer> callback, bool executeInEditMode)
		{
			this.callback = callback;
			this.executeInEditMode = executeInEditMode;
		}
	}

	private struct CameraData
	{
		public readonly int[] lightIndicies;

		public Camera camera;

		public ICameraEvents camEvents;

		public ScriptableCullingParameters cullParams;

		public CullResults cullResults;

		public ScriptableCullingParameters cullParamsFrontOfPortal;

		public CullResults cullResultsFrontOfPortal;

		public bool stereo;

		public bool shouldDraw;

		public bool shouldDrawFrontOfPortal;

		public int lightCount;

		public int shadowIdxOffset;

		public RenderStateBlock stateBlock;

		public bool isPortal;

		private readonly NexusRenderSettings cfg;

		public CameraData(NexusRenderSettings cfg)
		{
			this.cfg = cfg;
			lightIndicies = new int[MAX_RENDERED_LIGHTS_PER_CAMERA];
			camera = null;
			camEvents = null;
			cullParams = default(ScriptableCullingParameters);
			cullParamsFrontOfPortal = default(ScriptableCullingParameters);
			cullResults = default(CullResults);
			cullResultsFrontOfPortal = default(CullResults);
			stereo = false;
			shouldDraw = false;
			shouldDrawFrontOfPortal = false;
			lightCount = 0;
			shadowIdxOffset = 0;
			stateBlock = default(RenderStateBlock);
			isPortal = false;
		}

		public void Init(Camera camera)
		{
			this.camera = camera;
			camEvents = camera.GetComponent<ICameraEvents>();
			stereo = camera.stereoEnabled && XRSettings.isDeviceActive;
			shouldDraw = camera.enabled || camera.cameraType != CameraType.Game;
			isPortal = camera.GetComponent<PortalCamera>() != null;
			if (camEvents != null)
			{
				if (shouldDraw)
				{
					shouldDraw = camEvents.ShouldDraw;
				}
				if (shouldDrawFrontOfPortal)
				{
					shouldDrawFrontOfPortal = camEvents.ShouldDraw;
				}
				if (!camEvents.EventsEnabled)
				{
					camEvents = null;
				}
				if (camEvents != null)
				{
					stateBlock = camEvents.CameraRenderState;
				}
			}
		}

		public void Release()
		{
			camera = null;
			camEvents = null;
			cullParams = default(ScriptableCullingParameters);
			cullParamsFrontOfPortal = default(ScriptableCullingParameters);
			cullResults = default(CullResults);
			cullResultsFrontOfPortal = default(CullResults);
		}

		public void OnPreCullParams()
		{
			if (camEvents == null)
			{
				return;
			}
			try
			{
				camEvents.OnPreCullParams(camera);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
			finally
			{
			}
		}

		public void OnPreCullSubmit()
		{
			if (camEvents == null)
			{
				return;
			}
			try
			{
				camEvents.OnPreCullSubmit(camera, shouldDraw, ref cullParams, shouldDrawFrontOfPortal, ref cullParamsFrontOfPortal);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
			finally
			{
			}
		}

		public void OnPostCull()
		{
			if (camEvents == null)
			{
				return;
			}
			try
			{
				camEvents.OnPostCull(camera);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
			finally
			{
			}
		}

		public void OnPreOpaque(ScriptableRenderContext ctx, ref DrawRendererSettings drawSettings, ref FilterRenderersSettings filterSettings)
		{
			if (camEvents == null)
			{
				return;
			}
			try
			{
				CommandBuffer commandBuffer = camEvents.OnPreOpaque(camera, ref drawSettings, ref filterSettings);
				if (commandBuffer != null)
				{
					ctx.ExecuteCommandBuffer(commandBuffer);
				}
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
			finally
			{
			}
		}

		public void OnPostOpaque(ScriptableRenderContext ctx)
		{
			if (camEvents == null)
			{
				return;
			}
			try
			{
				CommandBuffer commandBuffer = camEvents.OnPostOpaque(camera);
				if (commandBuffer != null)
				{
					ctx.ExecuteCommandBuffer(commandBuffer);
				}
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
			finally
			{
			}
		}

		public void OnPortalStencil(ScriptableRenderContext ctx)
		{
			if (camEvents == null)
			{
				return;
			}
			try
			{
				CommandBuffer commandBuffer = camEvents.OnPortalStencil(camera);
				if (commandBuffer != null)
				{
					ctx.ExecuteCommandBuffer(commandBuffer);
				}
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
			finally
			{
			}
		}

		public void OnPortalClear(ScriptableRenderContext ctx)
		{
			if (camEvents == null)
			{
				return;
			}
			try
			{
				CommandBuffer commandBuffer = camEvents.OnPortalClear(camera);
				if (commandBuffer != null)
				{
					ctx.ExecuteCommandBuffer(commandBuffer);
				}
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
			finally
			{
			}
		}

		public void OnPreTransparent(ScriptableRenderContext ctx, ref DrawRendererSettings drawSettings, ref FilterRenderersSettings filterSettings)
		{
			if (camEvents == null)
			{
				return;
			}
			try
			{
				CommandBuffer commandBuffer = camEvents.OnPreTransparent(camera, ref drawSettings, ref filterSettings);
				if (commandBuffer != null)
				{
					ctx.ExecuteCommandBuffer(commandBuffer);
				}
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
			finally
			{
			}
		}

		public void OnPostTransparent(ScriptableRenderContext ctx)
		{
			if (camEvents == null)
			{
				return;
			}
			try
			{
				CommandBuffer commandBuffer = camEvents.OnPostTransparent(camera);
				if (commandBuffer != null)
				{
					ctx.ExecuteCommandBuffer(commandBuffer);
				}
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
			finally
			{
			}
		}

		public void UpdateCullParams(ScriptableRenderContext ctx, bool portalCamera)
		{
			shouldDraw = CullResults.GetCullingParameters(camera, stereo, out cullParams);
			if (portalCamera)
			{
				shouldDrawFrontOfPortal = CullResults.GetCullingParameters(camera, stereo, out cullParamsFrontOfPortal);
			}
			else
			{
				shouldDrawFrontOfPortal = false;
			}
		}

		public void SubmitCull(ScriptableRenderContext ctx)
		{
			if (shouldDraw)
			{
				CullResults.Cull(ref cullParams, ctx, ref cullResults);
			}
			if (shouldDrawFrontOfPortal)
			{
				CullResults.Cull(ref cullParamsFrontOfPortal, ctx, ref cullResultsFrontOfPortal);
			}
		}

		public void UpdateLights(int curLightCount)
		{
			List<VisibleLight> visibleLights = cullResults.visibleLights;
			int[] lightIndexMap = cullResults.GetLightIndexMap();
			int num = 0;
			Vector3 position = camera.transform.position;
			lightCount = 0;
			for (int i = 0; i < visibleLights.Count; i++)
			{
				VisibleLight visibleLight = visibleLights[i];
				Vector2 size = visibleLight.screenRect.size;
				_ = (visibleLight.light.transform.position - position).magnitude;
				if (lightCount < lightIndicies.Length && LightInRange(position, visibleLight.light.transform.position, visibleLight.screenRect.size, visibleLight.range, cfg.lightSizeOnScreenEndFade, cfg.lightFadeRadiusMargin))
				{
					ICameraEvents cameraEvents = camEvents;
					if (cameraEvents == null || cameraEvents.ShouldDrawLight(camera, visibleLight))
					{
						lightIndexMap[i] -= num;
						lightIndicies[lightCount] = i;
						lightCount++;
						continue;
					}
				}
				lightIndexMap[i] = -1;
				num++;
			}
			cullResults.SetLightIndexMap(lightIndexMap);
			shadowIdxOffset = curLightCount;
		}

		public void SetupCameraProperties(ScriptableRenderContext ctx, CommandBuffer cmd, bool setupUnityDefaults)
		{
			if (setupUnityDefaults)
			{
				ctx.SetupCameraProperties(camera, stereo);
			}
			cmd.Clear();
			cmd.SetGlobalVector(ShaderPID._NXWorldSpaceHeadPos, camera.transform.position.V3ToV4(1f));
			cmd.SetGlobalVector(ShaderPID._NXNearFadeParams, new Vector4(cfg.nearFadeMinDist, cfg.nearFadeMaxDist, 0f, 0f));
			if (camEvents != null)
			{
				try
				{
					CommandBuffer commandBuffer = camEvents.OnSetupCameraProperties(camera, cmd);
					if (commandBuffer != null)
					{
						ctx.ExecuteCommandBuffer(commandBuffer);
					}
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
				}
				finally
				{
				}
			}
			ctx.ExecuteCommandBuffer(cmd);
		}

		public void Clear(ScriptableRenderContext ctx, CommandBuffer cmd)
		{
			if (camera.clearFlags != CameraClearFlags.Nothing)
			{
				cmd.Clear();
				cmd.ClearRenderTarget(clearDepth: true, camera.clearFlags == CameraClearFlags.Color, camera.backgroundColor);
				ctx.ExecuteCommandBuffer(cmd);
			}
		}

		public void StartMultiEye(ScriptableRenderContext ctx)
		{
			if (stereo)
			{
				ctx.StartMultiEye(camera);
			}
		}

		public void StopMultiEye(ScriptableRenderContext ctx)
		{
			if (stereo)
			{
				ctx.StopMultiEye(camera);
			}
		}
	}

	private static NexusRenderPipeline _Inst;

	private static Action<NexusRenderPipeline> onCreation;

	private static readonly List<PipelineEventHandler>[] pipelineHandlers = new List<PipelineEventHandler>[3]
	{
		new List<PipelineEventHandler>(),
		new List<PipelineEventHandler>(),
		new List<PipelineEventHandler>()
	};

	public static readonly int MAX_RENDERED_CAMERAS = 4;

	public static readonly int MAX_RENDERED_LIGHTS_PER_CAMERA = 8;

	public static readonly int MAX_RENDERED_SHADOWS_PER_CAMERA = 4;

	public static readonly int MAX_RENDERED_SHADOWS = MAX_RENDERED_CAMERAS * MAX_RENDERED_SHADOWS_PER_CAMERA;

	public static readonly int MAX_LIGHT_IDS = 32;

	private const int SH_COEFFICIENTS = 7;

	private static readonly CustomSampler onPreCullParamsPCS = CustomSampler.Create("OnPreCullParams");

	private static readonly CustomSampler onPreCullSubmitPCS = CustomSampler.Create("OnPreCullSubmit");

	private static readonly CustomSampler onPostCullPCS = CustomSampler.Create("OnPostCull");

	private static readonly CustomSampler onPreOpaquePCS = CustomSampler.Create("OnPreOpaque");

	private static readonly CustomSampler onPostOpaquePCS = CustomSampler.Create("OnPostOpaque");

	private static readonly CustomSampler onPortalStencilPCS = CustomSampler.Create("OnPortalStencil");

	private static readonly CustomSampler onPortalClearPCS = CustomSampler.Create("OnPortalClear");

	private static readonly CustomSampler onPreTransparentPCS = CustomSampler.Create("OnPreTransparent");

	private static readonly CustomSampler onPostTransparentPCS = CustomSampler.Create("OnPostTransparent");

	private static readonly CustomSampler onSetupCameraPropertiesPCS = CustomSampler.Create("OnSetupCameraProperties");

	public readonly NexusRenderSettings cfg;

	private RenderTexture globalLightShadow;

	private Material skyboxMat;

	private Material flatShadingMat;

	private Material fogLUTShadingMat;

	private Material fogLUTDepthShadingMat;

	private Material fogLUTHeightShadingMat;

	private readonly Matrix4x4[] globalWorldToShadow;

	private readonly Vector4[] globalShadowProps;

	private readonly CommandBuffer shadowSetupCMD;

	private readonly Vector4[] globalLightColor;

	private readonly Vector4[] globalLightPos;

	private readonly Vector4[] globalLightSpotDir;

	private readonly Vector4[] globalLightAtten;

	private readonly float[] globalLightShadowScale;

	private readonly CommandBuffer lightSetupCMD;

	private readonly CommandBuffer reflProbeSetupCMD;

	private readonly CommandBuffer clearCMD;

	private readonly CommandBuffer cameraPropertiesCMD;

	private readonly CommandBuffer skyboxCMD;

	private readonly ShaderPassName nullSPN;

	private readonly ShaderPassName baseSPN = new ShaderPassName("NexusBase");

	private readonly ShaderPassName portalStencilSPN = new ShaderPassName("NexusPortalBase");

	private readonly ShaderPassName portalClearSPN = new ShaderPassName("NexusPortalClear");

	private readonly ShaderPassName transparentDepthOnlySPN = new ShaderPassName("NexusTransparentDepthOnly");

	private readonly CameraData[] cameraDataArray = new CameraData[MAX_RENDERED_CAMERAS];

	private readonly float[] lightIDToLightIdx = new float[MAX_LIGHT_IDS];

	private readonly IDPool32 lightIDPool = new IDPool32();

	private readonly Dictionary<Light, int> lightToID = new Dictionary<Light, int>();

	public const int transparentRQMin = 3000;

	public const int transparentRQMax = 5000;

	private readonly RenderQueueRange opaqueRQR = new RenderQueueRange
	{
		min = 0,
		max = 2449
	};

	private readonly RenderQueueRange postOpaqueRQR = new RenderQueueRange
	{
		min = 2450,
		max = 2999
	};

	private readonly RenderQueueRange transparentRQR = new RenderQueueRange
	{
		min = 3000,
		max = 5000
	};

	private readonly RenderStateBlock portalSurfaceState = new RenderStateBlock(RenderStateMask.Raster);

	private OVRPlugin.TiledMultiResLevel multiResLevel = (OVRPlugin.TiledMultiResLevel)(-1);

	private readonly string[] reflectionProbeShaderName = new string[4] { "_globalReflectionProbe0", "_globalReflectionProbe1", "_globalReflectionProbe2", "_globalReflectionProbe3" };

	public static NexusRenderPipeline Inst => _Inst;

	public static void AddPipelineCallback(PipelineEvent evt, Func<CommandBuffer> callback, bool executeInEditMode = false)
	{
		pipelineHandlers[(int)evt].Add(new PipelineEventHandler(callback, executeInEditMode));
	}

	public static void RemovePipelineCallback(PipelineEvent evt, Func<CommandBuffer> callback)
	{
		int num = 0;
		List<PipelineEventHandler> list = pipelineHandlers[(int)evt];
		for (int i = 0; i < list.Count; i++)
		{
			PipelineEventHandler value = list[i];
			if (value.callback == callback)
			{
				num++;
			}
			else if (num > 0)
			{
				list[i - num] = value;
			}
		}
		if (num > 0)
		{
			list.RemoveRange(list.Count - num, num);
		}
	}

	private static void OnPipelineEvent(PipelineEvent evt, ScriptableRenderContext ctx)
	{
		foreach (PipelineEventHandler item in pipelineHandlers[(int)evt])
		{
			if (item.callback != null)
			{
				CommandBuffer commandBuffer = item.callback();
				if (commandBuffer != null)
				{
					ctx.ExecuteCommandBuffer(commandBuffer);
				}
			}
		}
	}

	public static void RegisterPipelineCreationCallback(Action<NexusRenderPipeline> action)
	{
		onCreation = (Action<NexusRenderPipeline>)Delegate.Remove(onCreation, action);
		onCreation = (Action<NexusRenderPipeline>)Delegate.Combine(onCreation, action);
		if (_Inst != null)
		{
			action(_Inst);
		}
	}

	public static void DeregisterPipelineCreationCallback(Action<NexusRenderPipeline> action)
	{
		onCreation = (Action<NexusRenderPipeline>)Delegate.Remove(onCreation, action);
	}

	private static void DestroyResource(UnityEngine.Object resource)
	{
		if (!(resource == null))
		{
			UnityEngine.Object.Destroy(resource);
		}
	}

	private static void ReleaseCB(CommandBuffer cb)
	{
		if (cb != null)
		{
			cb.Clear();
			cb.Release();
		}
	}

	private static RenderTextureDescriptor GetScreenRTD()
	{
		if (XRSettings.enabled)
		{
			return XRSettings.eyeTextureDesc;
		}
		RenderTextureDescriptor result = default(RenderTextureDescriptor);
		result.dimension = TextureDimension.Tex2D;
		result.volumeDepth = 1;
		result.width = Screen.width;
		result.height = Screen.height;
		result.depthBufferBits = 24;
		result.colorFormat = RenderTextureFormat.ARGB32;
		result.msaaSamples = QualitySettings.antiAliasing;
		result.vrUsage = VRTextureUsage.None;
		return result;
	}

	private static void SetRenderingFeatures()
	{
		Shader.globalRenderPipeline = "NexusRenderPipeline";
		SupportedRenderingFeatures.active = new SupportedRenderingFeatures
		{
			reflectionProbeSupportFlags = SupportedRenderingFeatures.ReflectionProbeSupportFlags.None,
			defaultMixedLightingMode = SupportedRenderingFeatures.LightmapMixedBakeMode.IndirectOnly,
			supportedMixedLightingModes = (SupportedRenderingFeatures.LightmapMixedBakeMode.IndirectOnly | SupportedRenderingFeatures.LightmapMixedBakeMode.Shadowmask),
			supportedLightmapBakeTypes = (LightmapBakeType.Realtime | LightmapBakeType.Baked),
			supportedLightmapsModes = LightmapsMode.NonDirectional,
			rendererSupportsLightProbeProxyVolumes = false,
			rendererSupportsMotionVectors = false,
			rendererSupportsReceiveShadows = false,
			rendererSupportsReflectionProbes = false
		};
	}

	private static void UnsetRenderingFeatures()
	{
		Shader.globalRenderPipeline = "";
		SupportedRenderingFeatures.active = new SupportedRenderingFeatures();
	}

	private static bool LightInRange(Vector3 camPos, Vector3 lightPos, Vector2 screenRectSize, float lightRange, float minSize, float radiusMargin)
	{
		if (screenRectSize.x * screenRectSize.y >= minSize)
		{
			return true;
		}
		float sqrMagnitude = (camPos - lightPos).sqrMagnitude;
		float num = lightRange + radiusMargin;
		num *= num;
		return sqrMagnitude <= num;
	}

	private static float GetLightFadeFactor(Vector3 camPos, Vector3 lightPos, float lightRange, Rect screenRect, float areaFadeEnd, float areaFadeStart, float rangeFadeMargin)
	{
		Vector2 size = screenRect.size;
		float value = size.x * size.y;
		float a = Mathf.InverseLerp(areaFadeEnd, areaFadeStart, value);
		float magnitude = (lightPos - camPos).magnitude;
		float t = Mathf.InverseLerp(lightRange + rangeFadeMargin, lightRange, magnitude);
		return Mathf.Lerp(a, 1f, t);
	}

	public NexusRenderPipeline(NexusRenderSettings cfg)
	{
		_Inst = this;
		this.cfg = cfg;
		SetRenderingFeatures();
		for (int i = 0; i < cameraDataArray.Length; i++)
		{
			cameraDataArray[i] = new CameraData(cfg);
		}
		globalLightColor = new Vector4[MAX_RENDERED_LIGHTS_PER_CAMERA];
		globalLightPos = new Vector4[MAX_RENDERED_LIGHTS_PER_CAMERA];
		globalLightSpotDir = new Vector4[MAX_RENDERED_LIGHTS_PER_CAMERA];
		globalLightAtten = new Vector4[MAX_RENDERED_LIGHTS_PER_CAMERA];
		globalShadowProps = new Vector4[MAX_RENDERED_SHADOWS];
		globalWorldToShadow = new Matrix4x4[MAX_RENDERED_SHADOWS];
		shadowSetupCMD = new CommandBuffer
		{
			name = "Setup Shadowmap"
		};
		lightSetupCMD = new CommandBuffer
		{
			name = "Setup Light Variables"
		};
		reflProbeSetupCMD = new CommandBuffer
		{
			name = "Setup Reflection Probe Variables"
		};
		clearCMD = new CommandBuffer
		{
			name = "Clear"
		};
		cameraPropertiesCMD = new CommandBuffer
		{
			name = "Set Camera Properties"
		};
		skyboxCMD = new CommandBuffer
		{
			name = "Skybox"
		};
		portalSurfaceState.rasterState = new RasterState(CullMode.Off, 0, 0f, depthClip: false);
		CreatePipelineResources(force: true);
		if (onCreation != null)
		{
			try
			{
				onCreation(this);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
		}
	}

	private void CreatePipelineResources(bool force)
	{
		if (!globalLightShadow || force)
		{
			globalLightShadow = new RenderTexture(new RenderTextureDescriptor
			{
				dimension = TextureDimension.Tex2DArray,
				volumeDepth = MAX_RENDERED_SHADOWS,
				width = cfg.shadowMapResolution,
				height = cfg.shadowMapResolution,
				depthBufferBits = 24,
				colorFormat = RenderTextureFormat.Depth,
				msaaSamples = 1
			});
			globalLightShadow.Create();
			skyboxMat = new Material(Shader.Find("NEXUS/Skybox"));
			flatShadingMat = new Material(Shader.Find("NEXUS/FlatShading"));
			Shader shader = Shader.Find("NEXUS/FogLUTShading");
			fogLUTShadingMat = new Material(shader);
			fogLUTShadingMat.EnableKeyword("FOG_LUT_BOTH");
			fogLUTDepthShadingMat = new Material(shader);
			fogLUTDepthShadingMat.EnableKeyword("FOG_LUT_DEPTH");
			fogLUTHeightShadingMat = new Material(shader);
			fogLUTHeightShadingMat.EnableKeyword("FOG_LUT_HEIGHT");
			RenderTexture renderTexture = globalLightShadow;
			Material material = skyboxMat;
			Material material2 = flatShadingMat;
			Material material3 = fogLUTShadingMat;
			Material material4 = fogLUTDepthShadingMat;
			HideFlags hideFlags2 = (fogLUTHeightShadingMat.hideFlags = HideFlags.DontUnloadUnusedAsset);
			HideFlags hideFlags4 = (material4.hideFlags = hideFlags2);
			HideFlags hideFlags6 = (material3.hideFlags = hideFlags4);
			HideFlags hideFlags8 = (material2.hideFlags = hideFlags6);
			HideFlags hideFlags10 = (material.hideFlags = hideFlags8);
			renderTexture.hideFlags = hideFlags10;
		}
	}

	private void DestroyPipelineResources()
	{
		DestroyResource(globalLightShadow);
		DestroyResource(skyboxMat);
		DestroyResource(flatShadingMat);
		DestroyResource(fogLUTShadingMat);
		DestroyResource(fogLUTDepthShadingMat);
		DestroyResource(fogLUTHeightShadingMat);
	}

	public override void Dispose()
	{
		base.Dispose();
		UnsetRenderingFeatures();
		DestroyPipelineResources();
		ReleaseCameraData();
		ReleaseCB(shadowSetupCMD);
		ReleaseCB(lightSetupCMD);
		ReleaseCB(clearCMD);
		ReleaseCB(skyboxCMD);
		ReleaseCB(cameraPropertiesCMD);
		ReleaseCB(reflProbeSetupCMD);
	}

	private void ReleaseCameraData()
	{
		for (int i = 0; i < cameraDataArray.Length; i++)
		{
			cameraDataArray[i].Release();
		}
	}

	public int RegisterLightForID(Light light)
	{
		if (!lightToID.TryGetValue(light, out var value))
		{
			value = lightIDPool.GetID();
			if (value >= 0)
			{
				lightToID[light] = value;
			}
			else
			{
				UnityEngine.Debug.LogError($"Tried to register {light} for light ID but ran out of IDs.", light);
			}
		}
		return value;
	}

	public void DeregisterLightForID(Light light)
	{
		if (lightToID.TryGetValue(light, out var value))
		{
			lightIDPool.ReturnID(value);
			lightToID.Remove(light);
		}
	}

	public void ApplyDefaultSkyboxProperties(CommandBuffer cb)
	{
		cb.SetSkybox_NX(cfg.defaultSkybox, new Vector2(0.5f, 0.5f), 1f);
	}

	public override void Render(ScriptableRenderContext ctx, Camera[] cameras)
	{
		if (cfg.passToggleTransparent != 0 && cfg.passToggleTransparent != NexusRenderSettings.PassToggle.EnabledMainCam)
		{
			if (cfg.disableTransparentPassTimer > 0f)
			{
				cfg.disableTransparentPassTimer -= 1f / 72f;
			}
			else
			{
				cfg.passToggleTransparent = NexusRenderSettings.PassToggle.EnabledAll;
			}
		}
		base.Render(ctx, cameras);
		try
		{
			if (ArrayX.IsNullOrEmpty(cameras) || base.disposed)
			{
				return;
			}
			CreatePipelineResources(force: false);
			GetScreenRTD();
			int num = Mathf.Min(cameras.Length, cameraDataArray.Length);
			if (true)
			{
				OVRPlugin.TiledMultiResLevel tiledMultiResLevel = ((num > 1) ? OVRPlugin.TiledMultiResLevel.LMSHigh : OVRPlugin.TiledMultiResLevel.LMSMedium);
				if (multiResLevel != tiledMultiResLevel)
				{
					multiResLevel = tiledMultiResLevel;
					OVRPlugin.tiledMultiResLevel = multiResLevel;
				}
			}
			OnPipelineEvent(PipelineEvent.Start, ctx);
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				Camera camera = cameras[i];
				CameraData cameraData = cameraDataArray[i];
				try
				{
					cameraData.Init(camera);
					if (!cameraData.shouldDraw)
					{
						continue;
					}
					cameraData.OnPreCullParams();
					cameraData.UpdateCullParams(ctx, cameraData.isPortal);
					cameraData.OnPreCullSubmit();
					cameraData.SubmitCull(ctx);
					cameraData.OnPostCull();
					if (!cameraData.shouldDraw)
					{
						continue;
					}
					cameraData.UpdateLights(num2);
					num2 += cameraData.lightCount;
					for (int j = 0; j < MAX_RENDERED_LIGHTS_PER_CAMERA; j++)
					{
						int num3 = cameraData.shadowIdxOffset + j;
						if (j < cameraData.lightCount && j < MAX_RENDERED_SHADOWS_PER_CAMERA && !cfg.disableShadowMapping)
						{
							int vLightIdx = cameraData.lightIndicies[j];
							globalShadowProps[num3].x = (DrawShadowmap(ctx, cameraData.cullResults, vLightIdx, num3) ? 1 : 0);
						}
						else if (j < MAX_RENDERED_SHADOWS)
						{
							globalShadowProps[num3].x = 0f;
						}
					}
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
				}
				finally
				{
					cameraDataArray[i] = cameraData;
					ctx.Submit();
				}
			}
			for (int k = 0; k < num; k++)
			{
				try
				{
					CameraData cameraData2 = cameraDataArray[k];
					if (cameraData2.shouldDraw)
					{
						bool flag = k == 0;
						cameraData2.SetupCameraProperties(ctx, cameraPropertiesCMD, flag);
						cameraData2.StartMultiEye(ctx);
						cameraData2.Clear(ctx, clearCMD);
						DrawRendererSettings drawRendererSettings = new DrawRendererSettings(cameraData2.camera, baseSPN);
						drawRendererSettings.sorting.flags = SortFlags.CommonOpaque;
						drawRendererSettings.rendererConfiguration = RendererConfiguration.PerObjectLightmaps;
						drawRendererSettings.flags = DrawRendererFlags.EnableDynamicBatching | DrawRendererFlags.EnableInstancing;
						DrawRendererSettings drawSettings = drawRendererSettings;
						FilterRenderersSettings filterRenderersSettings = new FilterRenderersSettings(initializeValues: true);
						filterRenderersSettings.renderQueueRange = opaqueRQR;
						FilterRenderersSettings filterSettings = filterRenderersSettings;
						cameraData2.OnPreOpaque(ctx, ref drawSettings, ref filterSettings);
						if (cameraData2.isPortal)
						{
							SetupLighting(ctx, ref drawSettings, cameraData2.camera.transform.position, cameraData2.cullResultsFrontOfPortal.visibleLights, cameraData2.lightIndicies, 0, cameraData2.shadowIdxOffset);
							ctx.DrawRenderers(cameraData2.cullResultsFrontOfPortal.visibleRenderers, ref drawSettings, filterSettings, cameraData2.stateBlock);
						}
						SetupLighting(ctx, ref drawSettings, cameraData2.camera.transform.position, cameraData2.cullResults.visibleLights, cameraData2.lightIndicies, cameraData2.lightCount, cameraData2.shadowIdxOffset);
						switch (cfg.debugShading)
						{
						case NexusRenderSettings.DebugShadingMode.Flat:
							drawSettings.SetOverrideMaterial(flatShadingMat, 0);
							break;
						case NexusRenderSettings.DebugShadingMode.FogLUT:
							drawSettings.SetOverrideMaterial(fogLUTShadingMat, 0);
							break;
						case NexusRenderSettings.DebugShadingMode.FogLUTDepth:
							drawSettings.SetOverrideMaterial(fogLUTDepthShadingMat, 0);
							break;
						case NexusRenderSettings.DebugShadingMode.FogLUTHeight:
							drawSettings.SetOverrideMaterial(fogLUTHeightShadingMat, 0);
							break;
						}
						if (cfg.passToggleOpaque == NexusRenderSettings.PassToggle.EnabledAll || (cfg.passToggleOpaque == NexusRenderSettings.PassToggle.EnabledMainCam && flag) || (cfg.passToggleOpaque == NexusRenderSettings.PassToggle.EnabledPortalCams && !flag))
						{
							ctx.DrawRenderers(cameraData2.cullResults.visibleRenderers, ref drawSettings, filterSettings, cameraData2.stateBlock);
						}
						drawSettings.SetOverrideMaterial(null, -1);
						cameraData2.OnPostOpaque(ctx);
						if (cfg.skyboxMesh != null && !cfg.disableSkybox)
						{
							skyboxCMD.Clear();
							skyboxCMD.DrawMesh(cfg.skyboxMesh, Matrix4x4.identity, skyboxMat);
							ctx.ExecuteCommandBuffer(skyboxCMD);
						}
						if (cfg.passToggleOpaque == NexusRenderSettings.PassToggle.EnabledAll || (cfg.passToggleOpaque == NexusRenderSettings.PassToggle.EnabledMainCam && flag) || (cfg.passToggleOpaque == NexusRenderSettings.PassToggle.EnabledPortalCams && !flag))
						{
							drawSettings.SetShaderPassName(0, baseSPN);
							filterSettings.renderQueueRange = postOpaqueRQR;
							ctx.DrawRenderers(cameraData2.cullResults.visibleRenderers, ref drawSettings, filterSettings, cameraData2.stateBlock);
						}
						if (flag)
						{
							cameraData2.OnPortalStencil(ctx);
							drawSettings.SetShaderPassName(0, portalStencilSPN);
							filterSettings.renderQueueRange = opaqueRQR;
							ctx.DrawRenderers(cameraData2.cullResults.visibleRenderers, ref drawSettings, filterSettings, portalSurfaceState);
							cameraData2.OnPortalClear(ctx);
							drawSettings.SetShaderPassName(0, portalClearSPN);
							ctx.DrawRenderers(cameraData2.cullResults.visibleRenderers, ref drawSettings, filterSettings, portalSurfaceState);
						}
						cameraData2.StopMultiEye(ctx);
					}
				}
				catch (Exception exception2)
				{
					UnityEngine.Debug.LogException(exception2);
				}
				finally
				{
					ctx.Submit();
				}
			}
			for (int num4 = num - 1; num4 >= 0; num4--)
			{
				try
				{
					CameraData cameraData3 = cameraDataArray[num4];
					if (cameraData3.shouldDraw)
					{
						bool flag2 = num4 == 0;
						cameraData3.SetupCameraProperties(ctx, cameraPropertiesCMD, setupUnityDefaults: false);
						cameraData3.StartMultiEye(ctx);
						DrawRendererSettings drawRendererSettings = new DrawRendererSettings(cameraData3.camera, transparentDepthOnlySPN);
						drawRendererSettings.sorting.flags = SortFlags.CommonTransparent;
						drawRendererSettings.rendererConfiguration = RendererConfiguration.PerObjectLightmaps;
						drawRendererSettings.flags = DrawRendererFlags.EnableDynamicBatching | DrawRendererFlags.EnableInstancing;
						DrawRendererSettings drawSettings2 = drawRendererSettings;
						int num5 = -1;
						ICameraEvents camEvents = cameraData3.camEvents;
						if (camEvents != null && camEvents.ShouldDrawOverlayPass)
						{
							num5 &= -528385;
						}
						FilterRenderersSettings filterRenderersSettings = new FilterRenderersSettings(initializeValues: true);
						filterRenderersSettings.renderQueueRange = transparentRQR;
						filterRenderersSettings.layerMask = num5;
						FilterRenderersSettings filterSettings2 = filterRenderersSettings;
						SetupLighting(ctx, ref drawSettings2, cameraData3.camera.transform.position, cameraData3.cullResults.visibleLights, cameraData3.lightIndicies, cameraData3.lightCount, cameraData3.shadowIdxOffset);
						cameraData3.OnPreTransparent(ctx, ref drawSettings2, ref filterSettings2);
						if (cfg.passToggleTransparent == NexusRenderSettings.PassToggle.EnabledAll || (cfg.passToggleTransparent == NexusRenderSettings.PassToggle.EnabledMainCam && flag2) || (cfg.passToggleTransparent == NexusRenderSettings.PassToggle.EnabledPortalCams && !flag2))
						{
							drawSettings2.SetShaderPassName(0, transparentDepthOnlySPN);
							ctx.DrawRenderers(cameraData3.cullResults.visibleRenderers, ref drawSettings2, filterSettings2, cameraData3.stateBlock);
							if (cameraData3.isPortal)
							{
								SetupLighting(ctx, ref drawSettings2, cameraData3.camera.transform.position, cameraData3.cullResultsFrontOfPortal.visibleLights, cameraData3.lightIndicies, 0, cameraData3.shadowIdxOffset);
								ctx.DrawRenderers(cameraData3.cullResultsFrontOfPortal.visibleRenderers, ref drawSettings2, filterSettings2, cameraData3.stateBlock);
							}
						}
						SetupLighting(ctx, ref drawSettings2, cameraData3.camera.transform.position, cameraData3.cullResults.visibleLights, cameraData3.lightIndicies, cameraData3.lightCount, cameraData3.shadowIdxOffset);
						drawSettings2.SetShaderPassName(0, baseSPN);
						if (cfg.passToggleTransparent == NexusRenderSettings.PassToggle.EnabledAll || (cfg.passToggleTransparent == NexusRenderSettings.PassToggle.EnabledMainCam && flag2) || (cfg.passToggleTransparent == NexusRenderSettings.PassToggle.EnabledPortalCams && !flag2))
						{
							ctx.DrawRenderers(cameraData3.cullResults.visibleRenderers, ref drawSettings2, filterSettings2, cameraData3.stateBlock);
						}
						if (cameraData3.isPortal)
						{
							SetupLighting(ctx, ref drawSettings2, cameraData3.camera.transform.position, cameraData3.cullResultsFrontOfPortal.visibleLights, cameraData3.lightIndicies, 0, cameraData3.shadowIdxOffset);
							ctx.DrawRenderers(cameraData3.cullResultsFrontOfPortal.visibleRenderers, ref drawSettings2, filterSettings2, cameraData3.stateBlock);
						}
						cameraData3.OnPostTransparent(ctx);
						cameraData3.StopMultiEye(ctx);
					}
				}
				catch (Exception exception3)
				{
					UnityEngine.Debug.LogException(exception3);
				}
				finally
				{
					ctx.Submit();
				}
			}
			if (num > 0 && cameraDataArray[0].shouldDraw)
			{
				CameraData cameraData4 = cameraDataArray[0];
				ICameraEvents camEvents2 = cameraData4.camEvents;
				if (camEvents2 != null && camEvents2.ShouldDrawOverlayPass)
				{
					try
					{
						cameraData4.SetupCameraProperties(ctx, cameraPropertiesCMD, setupUnityDefaults: false);
						cameraData4.StartMultiEye(ctx);
						DrawRendererSettings drawRendererSettings = new DrawRendererSettings(cameraData4.camera, baseSPN);
						drawRendererSettings.sorting.flags = SortFlags.CommonOpaque;
						drawRendererSettings.rendererConfiguration = RendererConfiguration.PerObjectLightmaps;
						drawRendererSettings.flags = DrawRendererFlags.EnableDynamicBatching | DrawRendererFlags.EnableInstancing;
						DrawRendererSettings drawSettings3 = drawRendererSettings;
						FilterRenderersSettings filterRenderersSettings = new FilterRenderersSettings(initializeValues: true);
						filterRenderersSettings.renderQueueRange = opaqueRQR;
						filterRenderersSettings.layerMask = 528384;
						FilterRenderersSettings filterSettings3 = filterRenderersSettings;
						if (!cfg.disableOverlayPass)
						{
							ctx.DrawRenderers(cameraData4.cullResults.visibleRenderers, ref drawSettings3, filterSettings3, cameraData4.stateBlock);
						}
						filterSettings3.renderQueueRange = transparentRQR;
						drawSettings3.sorting.flags = SortFlags.CommonTransparent;
						if (!cfg.disableOverlayPass)
						{
							ctx.DrawRenderers(cameraData4.cullResults.visibleRenderers, ref drawSettings3, filterSettings3, cameraData4.stateBlock);
						}
						cameraData4.StopMultiEye(ctx);
					}
					catch (Exception exception4)
					{
						UnityEngine.Debug.LogException(exception4);
					}
					finally
					{
						ctx.Submit();
					}
				}
			}
			CameraData cameraData5 = cameraDataArray[0];
			if (cameraData5.stereo)
			{
				cameraData5.SetupCameraProperties(ctx, cameraPropertiesCMD, setupUnityDefaults: false);
				ctx.StartMultiEye(cameraData5.camera);
				OnPipelineEvent(PipelineEvent.PreStereoEndRender, ctx);
				ctx.StopMultiEye(cameraData5.camera);
				ctx.StereoEndRender(cameraData5.camera);
				ctx.Submit();
			}
			OnPipelineEvent(PipelineEvent.End, ctx);
		}
		finally
		{
			ReleaseCameraData();
		}
	}

	private bool DrawShadowmap(ScriptableRenderContext ctx, CullResults cullResults, int vLightIdx, int shadowIdx)
	{
		VisibleLight visibleLight = cullResults.visibleLights[vLightIdx];
		Light light = visibleLight.light;
		if (light.shadows == LightShadows.None)
		{
			return false;
		}
		if (!cullResults.GetShadowCasterBounds(vLightIdx, out var _))
		{
			return false;
		}
		DrawShadowsSettings settings = new DrawShadowsSettings(cullResults, vLightIdx);
		int shadowMapResolution = cfg.shadowMapResolution;
		Matrix4x4 viewMatrix;
		Matrix4x4 projMatrix;
		if (visibleLight.lightType == LightType.Spot)
		{
			if (!cullResults.ComputeSpotShadowMatricesAndCullingPrimitives(vLightIdx, out viewMatrix, out projMatrix, out settings.splitData))
			{
				return false;
			}
		}
		else
		{
			if (visibleLight.lightType != LightType.Directional)
			{
				return false;
			}
			if (!cullResults.ComputeDirectionalShadowMatricesAndCullingPrimitives(vLightIdx, 0, 1, Vector3.one, shadowMapResolution, light.shadowNearPlane, out viewMatrix, out projMatrix, out settings.splitData))
			{
				return false;
			}
		}
		float num = 1f;
		Rect screenRect = visibleLight.screenRect;
		Vector2 size = screenRect.size;
		float value = size.x * size.y;
		num = Mathf.InverseLerp(cfg.shadowRectScaleEnd, cfg.shadowRectScaleStart, value);
		num = Mathf.Lerp(cfg.shadowMapMinScale, 1f, num);
		num *= cfg.shadowMapScale;
		num = (float)Mathf.RoundToInt((float)shadowMapResolution * num) / (float)shadowMapResolution;
		Matrix4x4 identity = Matrix4x4.identity;
		identity.m00 = 0.5f * num;
		identity.m11 = 0.5f * num;
		identity.m22 = 0.5f;
		identity.m03 = 0.5f;
		identity.m13 = 0.5f;
		identity.m23 = 0.5f;
		float num2 = Mathf.Max(cfg.minShadowBias, light.shadowBias);
		float z = light.shadowNormalBias * globalLightShadow.texelSize.x;
		if (SystemInfo.usesReversedZBuffer)
		{
			identity.m22 *= -1f;
			num2 *= -1f;
		}
		globalWorldToShadow[shadowIdx] = identity * projMatrix * viewMatrix;
		shadowSetupCMD.Clear();
		shadowSetupCMD.SetRenderTarget(globalLightShadow.colorBuffer, globalLightShadow.depthBuffer, 0, CubemapFace.Unknown, shadowIdx);
		shadowSetupCMD.ClearRenderTarget(clearDepth: true, clearColor: true, Color.black);
		float num3 = (float)shadowMapResolution * num + 2f;
		float num4 = ((float)shadowMapResolution - num3) * 0.5f;
		shadowSetupCMD.SetViewport(new Rect(num4, num4, num3, num3));
		shadowSetupCMD.SetViewProjectionMatrices(viewMatrix, projMatrix);
		shadowSetupCMD.SetGlobalVector(ShaderPID.nexus_LightShadowBias, new Vector4(num2, (visibleLight.lightType == LightType.Directional) ? 1f : 0f, z, 0f));
		shadowSetupCMD.SetGlobalVector(ShaderPID.nexus_WorldSpaceLightPos, (visibleLight.lightType == LightType.Directional) ? (-light.transform.forward.V3ToV4(0f)) : light.transform.position.V3ToV4(1f));
		ctx.ExecuteCommandBuffer(shadowSetupCMD);
		ctx.DrawShadows(ref settings);
		return true;
	}

	private void SetupReflectionProbeShaderVariables(List<VisibleReflectionProbe> probes, int probesCount, ScriptableRenderContext ctx)
	{
		reflProbeSetupCMD.Clear();
		int num = 4;
		probesCount = Mathf.Min(probesCount, num);
		for (int i = 0; i < probesCount; i++)
		{
			VisibleReflectionProbe visibleReflectionProbe = probes[i];
			reflProbeSetupCMD.SetGlobalTexture(reflectionProbeShaderName[i], visibleReflectionProbe.texture);
		}
		for (int j = probesCount; j < num; j++)
		{
			reflProbeSetupCMD.SetGlobalTexture(reflectionProbeShaderName[j], (Texture)null);
		}
		ctx.ExecuteCommandBuffer(reflProbeSetupCMD);
	}

	private void SetupLighting(ScriptableRenderContext ctx, ref DrawRendererSettings drawSettings, Vector3 camPos, List<VisibleLight> lights, int[] lightIndicies, int lightCount, int shadowIdxOffset)
	{
		for (int i = 0; i < lightIDToLightIdx.Length; i++)
		{
			lightIDToLightIdx[i] = -1f;
		}
		for (int j = 0; j < lightCount; j++)
		{
			int index = lightIndicies[j];
			VisibleLight visibleLight = lights[index];
			float lightFadeFactor = GetLightFadeFactor(camPos, visibleLight.light.transform.position, visibleLight.range, visibleLight.screenRect, cfg.lightSizeOnScreenEndFade, cfg.lightSizeOnScreenStartFade, cfg.lightFadeRadiusMargin);
			globalLightColor[j] = visibleLight.light.color;
			globalLightColor[j].w = visibleLight.light.intensity * lightFadeFactor;
			if (visibleLight.lightType == LightType.Directional)
			{
				Vector4 column = visibleLight.localToWorld.GetColumn(2);
				globalLightPos[j].Set(0f - column.x, 0f - column.y, 0f - column.z, 0f);
			}
			else
			{
				Vector4 column2 = visibleLight.localToWorld.GetColumn(3);
				globalLightPos[j].Set(column2.x, column2.y, column2.z, 1f);
			}
			float num = visibleLight.range * visibleLight.range;
			float newZ = ((visibleLight.lightType == LightType.Directional) ? 0f : (cfg.lightFalloffFactor / num));
			if (visibleLight.lightType == LightType.Spot)
			{
				Vector4 column3 = visibleLight.localToWorld.GetColumn(2);
				float num2 = (float)Math.PI / 180f * visibleLight.spotAngle;
				float num3 = Mathf.Cos(num2 * 0.25f);
				float num4 = Mathf.Cos(num2 * 0.5f);
				float num5 = num3 - num4;
				globalLightSpotDir[j].Set(0f - column3.x, 0f - column3.y, 0f - column3.z, 0f);
				globalLightAtten[j].Set(num4, (num5 != 0f) ? (1f / num5) : 1f, newZ, num);
			}
			else
			{
				globalLightSpotDir[j].Set(0f, 0f, 1f, 0f);
				globalLightAtten[j].Set(-1f, 1f, newZ, num);
			}
			Light light = visibleLight.light;
			if (lightToID.TryGetValue(light, out var value))
			{
				lightIDToLightIdx[value] = j;
			}
		}
		lightSetupCMD.Clear();
		if (lightCount > 0)
		{
			drawSettings.rendererConfiguration |= RendererConfiguration.PerObjectLightIndices8;
			lightSetupCMD.SetGlobalVectorArray(ShaderPID.globalLightColor, globalLightColor);
			lightSetupCMD.SetGlobalVectorArray(ShaderPID.globalLightPos, globalLightPos);
			lightSetupCMD.SetGlobalVectorArray(ShaderPID.globalLightSpotDir, globalLightSpotDir);
			lightSetupCMD.SetGlobalVectorArray(ShaderPID.globalLightAtten, globalLightAtten);
			lightSetupCMD.SetGlobalVectorArray(ShaderPID.globalShadowProps, globalShadowProps);
			lightSetupCMD.SetGlobalTexture(ShaderPID.globalLightShadow, globalLightShadow);
			lightSetupCMD.SetGlobalMatrixArray(ShaderPID.globalWorldToShadow, globalWorldToShadow);
		}
		else
		{
			drawSettings.rendererConfiguration &= ~(RendererConfiguration.ProvideLightIndices | RendererConfiguration.PerObjectLightIndices8);
			lightSetupCMD.SetGlobalVector(ShaderPID.unity_LightIndicesOffsetAndCount, Vector4X.zero);
			lightSetupCMD.SetGlobalVector(ShaderPID.unity_4LightIndices0, Vector4X.zero);
			lightSetupCMD.SetGlobalVector(ShaderPID.unity_4LightIndices1, Vector4X.zero);
		}
		lightSetupCMD.SetGlobalVector(ShaderPID.globalLightSettings, new Vector4(lightCount, shadowIdxOffset, 0f, 0f));
		lightSetupCMD.SetGlobalFloatArray(ShaderPID._LightIDToIDX, lightIDToLightIdx);
		lightSetupCMD.SetShaderKeyword_NX("NEXUS_LIGHTMAP_ON", cfg.debugShading != NexusRenderSettings.DebugShadingMode.Unlit);
		lightSetupCMD.SetShaderKeyword_NX("NEXUS_DYNAMIC_LIGHTS_ON", cfg.debugShading != NexusRenderSettings.DebugShadingMode.Unlit);
		ctx.ExecuteCommandBuffer(lightSetupCMD);
	}

	private static void GetShaderConstantsFromNormalizedSH(ref SphericalHarmonicsL2 ambientProbe, Vector4[] outCoefficients)
	{
		for (int i = 0; i < 3; i++)
		{
			outCoefficients[i].x = ambientProbe[i, 3];
			outCoefficients[i].y = ambientProbe[i, 1];
			outCoefficients[i].z = ambientProbe[i, 2];
			outCoefficients[i].w = ambientProbe[i, 0] - ambientProbe[i, 6];
			outCoefficients[i + 3].x = ambientProbe[i, 4];
			outCoefficients[i + 3].y = ambientProbe[i, 5];
			outCoefficients[i + 3].z = ambientProbe[i, 6] * 3f;
			outCoefficients[i + 3].w = ambientProbe[i, 7];
		}
		outCoefficients[6].x = ambientProbe[0, 8];
		outCoefficients[6].y = ambientProbe[1, 8];
		outCoefficients[6].z = ambientProbe[2, 8];
		outCoefficients[6].w = 1f;
	}
}
public static class MaterialNexusX
{
	public static void SetKeyword_NX(this Material mat, string keyword, bool enabled)
	{
		if (enabled)
		{
			mat.EnableKeyword(keyword);
		}
		else
		{
			mat.DisableKeyword(keyword);
		}
	}
}
public static class CameraNexusX
{
	public static void GetViewMatrices(this Camera cameraComp, out Matrix4x4 viewL, out Matrix4x4 viewR)
	{
		if (cameraComp.stereoEnabled)
		{
			viewL = cameraComp.GetStereoViewMatrix(Camera.StereoscopicEye.Left);
			viewR = cameraComp.GetStereoViewMatrix(Camera.StereoscopicEye.Right);
		}
		else
		{
			viewL = (viewR = cameraComp.worldToCameraMatrix);
		}
	}
}
public static class CommandBufferNexusX
{
	private static readonly Vector4[] steroCamPositions = new Vector4[2];

	public static void SetInvertedCulling_NX(this CommandBuffer cmd, bool inverted)
	{
		cmd.SetGlobalInt(ShaderPID._CULL_FRONT, (!inverted) ? 1 : 2);
		cmd.SetGlobalInt(ShaderPID._CULL_BACK, inverted ? 1 : 2);
	}

	public static void SetViewMatrices_NX(this CommandBuffer cmd, bool stereo, Matrix4x4[] matrices)
	{
		if (stereo)
		{
			steroCamPositions[0] = Matrix4x4X.GetPositionFromViewMatrix(ref matrices[0]);
			steroCamPositions[1] = Matrix4x4X.GetPositionFromViewMatrix(ref matrices[1]);
			cmd.SetGlobalMatrixArray(ShaderPID.nexus_StereoMatrixV, matrices);
			cmd.SetGlobalVectorArray(ShaderPID.nexus_StereoWorldSpaceCameraPos, steroCamPositions);
		}
		else
		{
			cmd.SetGlobalMatrix(ShaderPID.nexus_MatrixV, matrices[0]);
			cmd.SetGlobalVector(ShaderPID.nexus_WorldSpaceCameraPos, Matrix4x4X.GetPositionFromViewMatrix(ref matrices[0]));
		}
	}

	public static void SetShaderKeyword_NX(this CommandBuffer cmd, string keyword, bool enabled)
	{
		if (enabled)
		{
			cmd.EnableShaderKeyword(keyword);
		}
		else
		{
			cmd.DisableShaderKeyword(keyword);
		}
	}

	public static void SetSkybox_NX(this CommandBuffer cmd, Texture2D skybox, Vector2 center, float tiles)
	{
		Vector4 value = default(Vector4);
		value.x = center.x;
		value.y = center.y;
		value.z = tiles;
		value.w = (skybox ? (skybox.mipmapCount - 1) : 0);
		cmd.SetGlobalTexture(ShaderPID._SkyboxTex, skybox);
		cmd.SetGlobalVector(ShaderPID._SkyboxParams, value);
	}
}
public class NexusRenderSettings : RenderPipelineAsset
{
	public enum DebugShadingMode
	{
		None,
		Flat,
		Unlit,
		FogLUT,
		FogLUTDepth,
		FogLUTHeight
	}

	public enum PassToggle
	{
		EnabledAll,
		EnabledMainCam,
		EnabledPortalCams,
		EnabledNone
	}

	public int shadowMapResolution = 512;

	public float minShadowBias = 0.001f;

	public float lightFalloffFactor = 25f;

	public DebugShadingMode debugShading;

	public int maxReflectionProbes = 1;

	public Material defaultMaterial;

	public Shader defaultShader;

	public float nearFadeMaxDist = 5f;

	public float nearFadeMinDist = 0.3f;

	public Mesh skyboxMesh;

	public Texture2D defaultSkybox;

	public float shadowMapScale = 1f;

	public bool portalCamerasUseOcclusionCulling = true;

	public bool debugNoLighting;

	public bool debugNoShadows;

	public Texture2D defaultFogLookup;

	public Texture3D fogNoise;

	[NonSerialized]
	public bool disableShadowMapping;

	[NonSerialized]
	public bool disableOverlayPass;

	[NonSerialized]
	public bool disableSkybox;

	[NonSerialized]
	public PassToggle passToggleOpaque;

	[NonSerialized]
	public PassToggle passToggleTransparent;

	public float disableTransparentPassTimer;

	[Range(0f, 0.1f)]
	public float lightSizeOnScreenStartFade = 0.05f;

	[Range(0f, 0.1f)]
	public float lightSizeOnScreenEndFade = 0.025f;

	public float shadowRectScaleEnd;

	public float shadowRectScaleStart = 1f;

	public float shadowMapMinScale = 0.25f;

	public float lightFadeRadiusMargin = 0.5f;

	public override Material GetDefaultMaterial()
	{
		return defaultMaterial;
	}

	public override Shader GetDefaultShader()
	{
		return defaultShader;
	}

	protected override IRenderPipeline InternalCreatePipeline()
	{
		return new NexusRenderPipeline(this);
	}
}
public class PortalCamera : MonoBehaviour, NexusRenderPipeline.ICameraEvents
{
	private enum FrustumPlane
	{
		Left = 0,
		Right = 1,
		Bottom = 2,
		Top = 3,
		Near = 4,
		Far = 5,
		Count = 6,
		First = 0
	}

	private Portal portal;

	private int _PUID;

	[NonSerialized]
	public Camera cameraComp;

	private CommandBuffer onPreOpaqueCB;

	private CommandBuffer onPostTransparentCB;

	private readonly Vector4[] portalPlanes = new Vector4[2];

	private readonly Matrix4x4[] viewMatrices = new Matrix4x4[2];

	private readonly Plane[] frustumPlanes = new Plane[6];

	private readonly Vector3[] tmp_bCorners = new Vector3[8];

	private Matrix4x4 cullingProjOffset;

	private Matrix4x4 cullingView;

	private float cullMatrixNear;

	private RenderStateBlock stateOverride;

	private MainCamera.HighlightDrawer highlightDrawer = new MainCamera.HighlightDrawer();

	private Matrix4x4 cullingMatrixDebug;

	public int PUID => _PUID;

	public MainCamera.HighlightDrawer HighlightDrawer => highlightDrawer;

	bool NexusRenderPipeline.ICameraEvents.ShouldDraw
	{
		get
		{
			if (portal != null && portal.owner != null)
			{
				Portal link = portal.Link;
				if (link != null && link.owner != null)
				{
					return link.owner.isAwake;
				}
			}
			return false;
		}
	}

	bool NexusRenderPipeline.ICameraEvents.EventsEnabled => true;

	bool NexusRenderPipeline.ICameraEvents.ShouldDrawOverlayPass => false;

	RenderStateBlock NexusRenderPipeline.ICameraEvents.CameraRenderState => stateOverride;

	public void OnAwakeLR(Portal portal, int portalUID)
	{
		_PUID = portalUID;
		this.portal = portal;
		cameraComp = GetComponent<Camera>();
		cameraComp.CopyFrom(MainCamera.Inst.cameraComp);
		cameraComp.cullingMask = (portal.IsMirror ? GetMirrorCullingMask() : GetPortalCullingMask());
		cameraComp.clearFlags = CameraClearFlags.Nothing;
		cameraComp.depth = portalUID;
		cameraComp.enabled = base.enabled;
		cameraComp.useOcclusionCulling = true;
		onPreOpaqueCB = CreateCB("Pre-opaque");
		onPostTransparentCB = CreateCB("Post-transparent");
		stateOverride = new RenderStateBlock(RenderStateMask.Stencil)
		{
			stencilReference = _PUID,
			stencilState = new StencilState(enabled: true, byte.MaxValue, byte.MaxValue, CompareFunction.Equal)
		};
	}

	private int GetMirrorCullingMask()
	{
		return -787489;
	}

	private int GetPortalCullingMask()
	{
		return -1025;
	}

	public void OnPreCullSubmitMainCamera(Bounds pBounds, ref ScriptableCullingParameters cullParams)
	{
		portal.owner.sceneRenderSettings.ApplyCameraProperties(cameraComp);
		FastBounds fastBounds = default(FastBounds);
		fastBounds.center = (fastBounds.extents = Vector3X.zero);
		fastBounds.unityBounds = pBounds;
		Matrix4x4X.TransformBounds(ref cullParams.cullStereoView, fastBounds.center, fastBounds.extents, out fastBounds.center, out fastBounds.extents);
		BoundsX.GetCorners(ref fastBounds.unityBounds, tmp_bCorners);
		cullMatrixNear = 0f - tmp_bCorners[4].z;
		tmp_bCorners[0] = Matrix4x4X.ClampedPositionProjection(ref cullParams.cullStereoProj, tmp_bCorners[0]);
		tmp_bCorners[1] = Matrix4x4X.ClampedPositionProjection(ref cullParams.cullStereoProj, tmp_bCorners[1]);
		tmp_bCorners[2] = Matrix4x4X.ClampedPositionProjection(ref cullParams.cullStereoProj, tmp_bCorners[2]);
		tmp_bCorners[3] = Matrix4x4X.ClampedPositionProjection(ref cullParams.cullStereoProj, tmp_bCorners[3]);
		tmp_bCorners[4] = Matrix4x4X.ClampedPositionProjection(ref cullParams.cullStereoProj, tmp_bCorners[4]);
		tmp_bCorners[5] = Matrix4x4X.ClampedPositionProjection(ref cullParams.cullStereoProj, tmp_bCorners[5]);
		tmp_bCorners[6] = Matrix4x4X.ClampedPositionProjection(ref cullParams.cullStereoProj, tmp_bCorners[6]);
		tmp_bCorners[7] = Matrix4x4X.ClampedPositionProjection(ref cullParams.cullStereoProj, tmp_bCorners[7]);
		fastBounds.center = tmp_bCorners[0];
		fastBounds.extents = Vector3X.zero;
		BoundsX.Encapsulate(ref fastBounds.unityBounds, tmp_bCorners, 1, 7);
		Matrix4x4X.TranslateScale(fastBounds.center.x, fastBounds.center.y, 0f, fastBounds.extents.x, fastBounds.extents.y, 1f, out cullingProjOffset);
		cullingProjOffset = Matrix4x4.Inverse(cullingProjOffset);
		cullingView = cullParams.cullStereoView * portal.cachedPortalMatrixInv;
	}

	public bool ViewInvertsFaces()
	{
		int num = 0;
		if (portal.flipX)
		{
			num++;
		}
		if (portal.flipY)
		{
			num++;
		}
		if (portal.flipZ)
		{
			num++;
		}
		return num % 2 == 1;
	}

	protected void OnEnable()
	{
		if (cameraComp != null)
		{
			cameraComp.enabled = true;
		}
	}

	protected void OnDisable()
	{
		if (cameraComp != null)
		{
			cameraComp.enabled = false;
		}
	}

	protected void OnDestroy()
	{
		ReleaseCB(onPreOpaqueCB);
		ReleaseCB(onPostTransparentCB);
	}

	private static void ReleaseCB(CommandBuffer cb)
	{
		if (cb != null)
		{
			cb.Clear();
			cb.Release();
		}
	}

	private void SetVariantRendering(PortalVariations.VariantSet variant, Portal portal)
	{
		ConstArray<PortalVariations> portalVariations = portal.Link.owner.portalVariations;
		PortalVariations[] data = portalVariations._data;
		uint dataNum = portalVariations._dataNum;
		for (int i = 0; i < dataNum; i++)
		{
			data[i].EnableVariantRendering(variant);
		}
	}

	private void AddClipPlanes(CommandBuffer cmd)
	{
		StereoTargetEyeMask intersectingEyes = portal.IntersectingEyes;
		bool flag = (intersectingEyes & StereoTargetEyeMask.Left) == 0;
		bool flag2 = (intersectingEyes & StereoTargetEyeMask.Right) == 0;
		if (flag || flag2)
		{
			Vector2 zero = Vector2.zero;
			if (flag)
			{
				zero.x = 1f;
				portalPlanes[0] = portal.cachedLinkClipPlaneV;
			}
			if (flag2)
			{
				zero.y = 1f;
				portalPlanes[1] = portal.cachedLinkClipPlaneV;
			}
			cmd.SetGlobalVector(ShaderPID._PortalClipEnabled, zero);
			cmd.SetGlobalVectorArray(ShaderPID._PortalPlanes, portalPlanes);
		}
		else
		{
			cmd.SetGlobalVector(ShaderPID._PortalClipEnabled, Vector4X.zero);
		}
	}

	private void AddStencilSetup(CommandBuffer cmd)
	{
		cmd.SetGlobalInt(ShaderPID._STENCIL_COMP, 3);
		cmd.SetGlobalInt(ShaderPID._STENCIL_REF, _PUID);
	}

	private void AddViewVariables(CommandBuffer cmd)
	{
		MainCamera.Inst.cameraComp.GetViewMatrices(out viewMatrices[0], out viewMatrices[1]);
		viewMatrices[0] *= portal.cachedPortalMatrixInv;
		viewMatrices[1] *= portal.cachedPortalMatrixInv;
		cmd.SetViewMatrices_NX(cameraComp.stereoEnabled, viewMatrices);
		cmd.SetInvertedCulling_NX(ViewInvertsFaces());
		cmd.EnableShaderKeyword("PORTAL_RENDER_MODE_ON");
	}

	private CommandBuffer CreateCB(string name)
	{
		return new CommandBuffer
		{
			name = $"{portal.name} ({_PUID}) {name}"
		};
	}

	public void UpdateRenderingData()
	{
	}

	void NexusRenderPipeline.ICameraEvents.OnPreCullParams(Camera cam)
	{
		Camera camera = MainCamera.Inst.cameraComp;
		Matrix4x4 cachedPortalMatrix = portal.cachedPortalMatrix;
		Matrix4x4 cameraToWorldMatrix = camera.cameraToWorldMatrix;
		cameraToWorldMatrix = cachedPortalMatrix * cameraToWorldMatrix;
		cameraComp.transform.position = Matrix4x4X.GetPosition(ref cameraToWorldMatrix);
		cameraComp.transform.rotation = Quaternion.LookRotation(-Matrix4x4X.GetAxisZ(ref cameraToWorldMatrix), Matrix4x4X.GetAxisY(ref cameraToWorldMatrix));
		SetVariantRendering(portal.portalVariantSet, portal);
	}

	void NexusRenderPipeline.ICameraEvents.OnPreCullSubmit(Camera cam, bool willDraw, ref ScriptableCullingParameters cullParams, bool willDrawFrontOfPortal, ref ScriptableCullingParameters cullParamsFrontOfPortal)
	{
		if (portal.IntersectingEyes == StereoTargetEyeMask.None)
		{
			Matrix4x4 matrix4x = cullingProjOffset * cullParams.cullStereoProj;
			Matrix4x4 matrix4x2 = matrix4x;
			float num = 2f * matrix4x.m23 / (2f * matrix4x.m22 - 2f);
			float num2 = (matrix4x.m22 - 1f) * num / (matrix4x.m22 + 1f);
			num = cullMatrixNear;
			matrix4x.m22 = (0f - (num2 + num)) / (num2 - num);
			matrix4x.m23 = (0f - 2f * num2 * num) / (num2 - num);
			float num3 = 2f * matrix4x2.m23 / (2f * matrix4x2.m22 - 2f);
			float num4 = (matrix4x2.m22 - 1f) * num3 / (matrix4x2.m22 + 1f);
			num4 = cullMatrixNear;
			matrix4x2.m22 = (0f - (num4 + num3)) / (num4 - num3);
			matrix4x2.m23 = (0f - 2f * num4 * num3) / (num4 - num3);
			Matrix4x4 cullingMatrix = matrix4x * cullingView;
			Matrix4x4 matrix4x3 = matrix4x2 * cullingView;
			cullParams.cullStereoProj = matrix4x;
			cullParams.cullStereoView = cullingView;
			cullParams.cullingMatrix = cullingMatrix;
			if (NexusRenderPipeline.Inst.cfg.portalCamerasUseOcclusionCulling)
			{
				cullParams.cullingFlags |= CullFlag.OcclusionCull;
			}
			else
			{
				cullParams.cullingFlags &= ~CullFlag.OcclusionCull;
			}
			cullParamsFrontOfPortal.cullStereoProj = matrix4x2;
			cullParamsFrontOfPortal.cullStereoView = cullingView;
			cullParamsFrontOfPortal.cullingMatrix = matrix4x3;
			cullParamsFrontOfPortal.cullingFlags &= ~CullFlag.OcclusionCull;
			GeometryUtility.CalculateFrustumPlanes(matrix4x3, frustumPlanes);
			for (int i = 0; i < 6; i++)
			{
				cullParamsFrontOfPortal.SetCullingPlane(i, frustumPlanes[i]);
			}
			cullingMatrixDebug = matrix4x2;
		}
	}

	void NexusRenderPipeline.ICameraEvents.OnPostCull(Camera cam)
	{
	}

	CommandBuffer NexusRenderPipeline.ICameraEvents.OnSetupCameraProperties(Camera cam, CommandBuffer camPropsCMB)
	{
		AddClipPlanes(camPropsCMB);
		AddStencilSetup(camPropsCMB);
		AddViewVariables(camPropsCMB);
		return portal.Link.owner.sceneRenderSettings?.ShaderPropertiesCMD;
	}

	private void DrawPortalIntersections(CommandBuffer buffer, bool transparentPass)
	{
		buffer.EnableShaderKeyword("PORTAL_TRANSFORM_MATRIX_ON");
		portal.DrawIntersectingRenderers(buffer, isPortal: true, transparentPass);
		buffer.DisableShaderKeyword("PORTAL_TRANSFORM_MATRIX_ON");
	}

	CommandBuffer NexusRenderPipeline.ICameraEvents.OnPreOpaque(Camera cam, ref DrawRendererSettings drawSettings, ref FilterRenderersSettings filterSettings)
	{
		Portal link = portal.Link;
		filterSettings.renderingLayerMask = link.owner.sceneMask;
		onPreOpaqueCB.Clear();
		DrawPortalIntersections(onPreOpaqueCB, transparentPass: false);
		if (portal.mirrorsPlayerRenderers)
		{
			Portal.GetPortalMatrix(portal.transform, portal.Link.transform, Quaternion.identity, link.flipX, link.flipY, !link.flipZ, out var outMatrix);
			onPreOpaqueCB.EnableShaderKeyword("PORTAL_TRANSFORM_MATRIX_ON");
			onPreOpaqueCB.SetGlobalMatrix(ShaderPID.nexus_MatrixPortal, outMatrix);
			onPreOpaqueCB.SetInvertedCulling_NX(link.PortalCamera.ViewInvertsFaces());
			Renderer[] componentsInChildren = MainCamera.Inst.GetComponentsInChildren<Renderer>();
			foreach (Renderer renderer in componentsInChildren)
			{
				onPreOpaqueCB.DrawRenderer(renderer, renderer.sharedMaterial, 0, 0);
			}
			CC inst = CC.Inst;
			onPreOpaqueCB.DrawRenderer(inst.handL.handSMR, inst.handL.handSMR.sharedMaterial, 0, 0);
			onPreOpaqueCB.DrawRenderer(inst.handR.handSMR, inst.handR.handSMR.sharedMaterial, 0, 0);
			onPreOpaqueCB.DisableShaderKeyword("PORTAL_TRANSFORM_MATRIX_ON");
		}
		AddViewVariables(onPreOpaqueCB);
		return onPreOpaqueCB;
	}

	CommandBuffer NexusRenderPipeline.ICameraEvents.OnPostOpaque(Camera cam)
	{
		return null;
	}

	CommandBuffer NexusRenderPipeline.ICameraEvents.OnPortalStencil(Camera cam)
	{
		return null;
	}

	CommandBuffer NexusRenderPipeline.ICameraEvents.OnPortalClear(Camera cam)
	{
		return null;
	}

	CommandBuffer NexusRenderPipeline.ICameraEvents.OnPreTransparent(Camera cam, ref DrawRendererSettings drawSettings, ref FilterRenderersSettings filterSettings)
	{
		Portal link = portal.Link;
		filterSettings.renderingLayerMask = link.owner.sceneMask;
		return null;
	}

	CommandBuffer NexusRenderPipeline.ICameraEvents.OnPostTransparent(Camera cam)
	{
		onPostTransparentCB.Clear();
		DrawPortalIntersections(onPostTransparentCB, transparentPass: true);
		highlightDrawer.DrawHighlights(onPostTransparentCB, base.transform.position);
		highlightDrawer.ResetHightlights();
		portal.AddPortalSurface(onPostTransparentCB);
		return onPostTransparentCB;
	}

	bool NexusRenderPipeline.ICameraEvents.ShouldDrawLight(Camera cam, VisibleLight visibleLight)
	{
		return portal.Link.gameObject.scene == visibleLight.light.gameObject.scene;
	}

	public void OnLateUpdateLR()
	{
	}

	public void OnPreBuild()
	{
		base.enabled = false;
		base.gameObject.AddComponent<Camera>().enabled = false;
	}
}
public class PortalRenderer : MonoBehaviour, IOwnerChangeListener, PortalVariations.IUseVariantSet
{
	private PortalVariations.VariantSet? variantSet;

	private Renderer[] renderers;

	private bool[] renderersEnabled;

	private ObjectMimic objectMimic;

	private Vector3 min;

	private Vector3 max;

	private bool isEnabled;

	private Portal intersectingPortal;

	private bool drawsInPortals;

	private Material[] originalMaterials;

	private int layerMask;

	public static void UpdateRenderingData(ConstArray<PortalRenderer> portalRenderers)
	{
		PortalRenderer[] data = portalRenderers._data;
		int sLength = portalRenderers.sLength;
		for (int i = 0; i < sLength; i++)
		{
			data[i].UpdateRenderingData();
		}
	}

	public static void UpdateRenderingDataComplete(ConstArray<PortalRenderer> portalRenderers)
	{
		PortalRenderer[] data = portalRenderers._data;
		int sLength = portalRenderers.sLength;
		for (int i = 0; i < sLength; i++)
		{
			data[i].intersectingPortal = null;
		}
	}

	public static void RestoreRenderingState(ConstArray<PortalRenderer> portalRenderers)
	{
	}

	public void OnAwakeLR(bool drawsInPortals = true)
	{
		renderers = (from r in GetComponentsInChildren<Renderer>()
			where !(r is ParticleSystemRenderer) && !r.GetComponent<LightSource>()
			select r).ToArray();
		renderersEnabled = new bool[renderers.Length];
		objectMimic = GetComponentInParent<ObjectMimic>();
		this.drawsInPortals = drawsInPortals;
		layerMask = 1 << base.gameObject.layer;
		originalMaterials = new Material[renderers.Length];
		for (int i = 0; i < renderers.Length; i++)
		{
			Material sharedMaterial = renderers[i].sharedMaterial;
			originalMaterials[i] = sharedMaterial;
		}
	}

	protected void OnDestroy()
	{
	}

	public bool UpdatePortalIntersection(Portal portal, Vector3 pMin, Vector3 pMax, int portalCullMask)
	{
		object obj = intersectingPortal;
		if (obj != null && obj != portal)
		{
			return false;
		}
		if ((portalCullMask & layerMask) == 0)
		{
			return false;
		}
		if (!isEnabled)
		{
			return false;
		}
		int num;
		if (min.x <= pMax.x && max.x >= pMin.x && min.y <= pMax.y && max.y >= pMin.y && min.z <= pMax.z)
		{
			num = ((max.z >= pMin.z) ? 1 : 0);
			if (num != 0)
			{
				intersectingPortal = portal;
			}
		}
		else
		{
			num = 0;
		}
		return (byte)num != 0;
	}

	private void UpdateRenderingData()
	{
		isEnabled = objectMimic == null || objectMimic.HasControl;
		if (!isEnabled)
		{
			return;
		}
		min = Vector3X.positiveInfinity;
		max = Vector3X.negativeInfinity;
		if (renderers.Length == 0)
		{
			min = (max = base.transform.position);
			return;
		}
		for (int i = 0; i < renderers.Length; i++)
		{
			Renderer renderer = renderers[i];
			bool flag = renderer != null && renderer.enabled && renderer.gameObject.activeInHierarchy;
			renderersEnabled[i] = flag;
			if (flag)
			{
				Bounds bounds = renderer.bounds;
				Vector3 vector = bounds.min;
				Vector3 vector2 = bounds.max;
				min.x = ((vector.x < min.x) ? vector.x : min.x);
				max.x = ((vector2.x > max.x) ? vector2.x : max.x);
				min.y = ((vector.y < min.y) ? vector.y : min.y);
				max.y = ((vector2.y > max.y) ? vector2.y : max.y);
				min.z = ((vector.z < min.z) ? vector.z : min.z);
				max.z = ((vector2.z > max.z) ? vector2.z : max.z);
			}
		}
	}

	public void DrawRenderers(CommandBuffer cmd, bool transparentPass)
	{
		for (int i = 0; i < renderers.Length; i++)
		{
			if (renderersEnabled[i])
			{
				Renderer renderer = renderers[i];
				Material material = originalMaterials[i];
				int renderQueue = material.renderQueue;
				bool flag = renderQueue >= 3000 || renderQueue <= 5000;
				if (transparentPass == flag)
				{
					cmd.DrawRenderer(renderer, material, 0, 0);
				}
			}
		}
	}

	public bool Valid(PortalVariations.VariantSet set, bool isPortal)
	{
		if (drawsInPortals || !isPortal)
		{
			if (variantSet.HasValue)
			{
				return variantSet.Value == set;
			}
			return true;
		}
		return false;
	}

	public void SetPortalVariant(PortalVariations portalVariation)
	{
	}

	void PortalVariations.IUseVariantSet.OnVariantSetChanged(PortalVariations.VariantSet newSet)
	{
		variantSet = newSet;
	}

	void IOwnerChangeListener.OnOwnerChange(MRBase _oldOwner, MRBase _newOwner)
	{
		MRBase.TransferObject(_oldOwner, _newOwner, this);
	}
}
public class PortalVariations : MonoBehaviour, ICanEnterPortal, IOwnerChangeListener, IMimic<PortalVariations>, IMimicBase
{
	public interface IUseVariantSet
	{
		void SetPortalVariant(PortalVariations portalVariation);

		void OnVariantSetChanged(VariantSet newSet);
	}

	public enum VariantSet
	{
		Main,
		Mirror
	}

	[Serializable]
	public struct Variant
	{
		public GameObject root;

		private VariantSet set;

		private Renderer[] renderers;

		private Light[] lights;

		private Collider[] colliders;

		private Behaviour[] controlBehaviours;

		private bool[] rendererWasEnabled;

		private bool[] lightWasEnabled;

		private IUseVariantSet[] setUsers;

		public bool CanControl
		{
			get
			{
				if ((object)root != null && colliders != null)
				{
					return colliders.Length != 0;
				}
				return false;
			}
		}

		public Collider[] Colliders => colliders;

		public Renderer[] Renderers => renderers;

		public Behaviour[] ControlBehaviours => controlBehaviours;

		public void Init(VariantSet initialSet, PortalVariations variation)
		{
			root = (root ? root : null);
			if (root == null)
			{
				renderers = new Renderer[0];
				rendererWasEnabled = new bool[0];
				lights = new Light[0];
				lightWasEnabled = new bool[0];
				colliders = new Collider[0];
				controlBehaviours = new Behaviour[0];
				setUsers = new IUseVariantSet[0];
			}
			else
			{
				renderers = root.GetComponentsInChildren<Renderer>();
				rendererWasEnabled = new bool[renderers.Length];
				lights = root.GetComponentsInChildren<Light>();
				lightWasEnabled = new bool[lights.Length];
				colliders = root.GetComponentsInChildren<Collider>();
				controlBehaviours = GetControlBehaviours(root).ToArray();
				setUsers = root.GetComponentsInChildren<IUseVariantSet>();
				SetVariantSet(initialSet);
			}
			int num = setUsers.Length;
			for (int i = 0; i < num; i++)
			{
				setUsers[i].SetPortalVariant(variation);
			}
		}

		public void SetVariantSet(VariantSet newSet)
		{
			set = newSet;
			int num = setUsers.Length;
			for (int i = 0; i < num; i++)
			{
				setUsers[i].OnVariantSetChanged(newSet);
			}
		}

		public void SetControl(bool inControl)
		{
			int num = colliders.Length;
			for (int i = 0; i < num; i++)
			{
				colliders[i].enabled = inControl;
			}
			num = controlBehaviours.Length;
			for (int j = 0; j < num; j++)
			{
				controlBehaviours[j].enabled = inControl;
			}
		}

		public void SetRendering(bool enabled)
		{
			int num = renderers.Length;
			for (int i = 0; i < num; i++)
			{
				if (rendererWasEnabled[i])
				{
					renderers[i].enabled = enabled;
				}
			}
			num = lights.Length;
			for (int j = 0; j < num; j++)
			{
				if (lightWasEnabled[j])
				{
					lights[j].enabled = enabled;
				}
			}
		}

		public void SaveRenderingState()
		{
			int num = renderers.Length;
			for (int i = 0; i < num; i++)
			{
				rendererWasEnabled[i] = renderers[i].enabled;
			}
			num = lights.Length;
			for (int j = 0; j < num; j++)
			{
				lightWasEnabled[j] = lights[j].enabled;
			}
		}

		public void RestoreRenderingState()
		{
			int num = renderers.Length;
			for (int i = 0; i < num; i++)
			{
				if (rendererWasEnabled[i])
				{
					renderers[i].enabled = true;
				}
			}
			num = lights.Length;
			for (int j = 0; j < num; j++)
			{
				if (lightWasEnabled[j])
				{
					lights[j].enabled = true;
				}
			}
		}
	}

	public class CopyHelper : MonoBehaviour
	{
		public GameObject orginalRoot;
	}

	public const int VARIANT_COUNT = 2;

	public static readonly VariantSet DEFAULT_SET = VariantSet.Main;

	private static readonly Type[] controlBehaviourTypes = new Type[3]
	{
		typeof(GrabPoint),
		typeof(CollisionSound),
		typeof(PlacementHelperSnapPivot)
	};

	[SerializeField]
	public Variant[] variants;

	public VariantSet currentController;

	private bool anyVariantCanControl;

	private VariantSet lastMain;

	private bool renderingSetIsSet;

	private VariantSet renderingSet;

	public VariantSet LastMain => lastMain;

	IMimic<PortalVariations> IMimic<PortalVariations>.LinkedIMimic { get; set; }

	PortalVariations IMimic<PortalVariations>.LinkedMimicComp { get; set; }

	public event Action OnVariantSetChanged;

	private static List<Behaviour> GetControlBehaviours(GameObject root)
	{
		List<Behaviour> list = new List<Behaviour>();
		Type[] array = controlBehaviourTypes;
		foreach (Type type in array)
		{
			UnityEngine.Component[] componentsInChildren = root.GetComponentsInChildren(type);
			foreach (UnityEngine.Component component in componentsInChildren)
			{
				list.Add(component as Behaviour);
			}
		}
		return list;
	}

	public static void SaveRenderingState(ConstArray<PortalVariations> portalVariations)
	{
		PortalVariations[] data = portalVariations._data;
		int sLength = portalVariations.sLength;
		for (int i = 0; i < sLength; i++)
		{
			data[i].SaveRenderingState();
		}
	}

	public static void RestoreRenderingState(ConstArray<PortalVariations> portalVariations)
	{
		PortalVariations[] data = portalVariations._data;
		int sLength = portalVariations.sLength;
		for (int i = 0; i < sLength; i++)
		{
			data[i].RestoreRenderingState();
		}
	}

	public int GetVariantionNum()
	{
		if (variants == null)
		{
			return 0;
		}
		return variants.Length;
	}

	public int GetActiveVariantNum()
	{
		int num = 0;
		if (variants == null)
		{
			return num;
		}
		for (int i = 0; i < variants.Length; i++)
		{
			num += ((variants[i].root != null) ? 1 : 0);
		}
		return num;
	}

	public void OnAwakeLR()
	{
		if (variants == null)
		{
			return;
		}
		for (int i = 0; i < variants.Length; i++)
		{
			variants[i].Init((VariantSet)i, this);
		}
		int num = GetComponentsInChildren<Collider>().Length;
		int num2 = GetControlBehaviours(base.gameObject).Count;
		for (int j = 0; j < variants.Length; j++)
		{
			num -= variants[j].Colliders.Length;
			num2 -= variants[j].ControlBehaviours.Length;
		}
		anyVariantCanControl = num > 0 && num2 > 0;
		int k = 0;
		GameObject gameObject = null;
		for (; k < variants.Length; k++)
		{
			if (anyVariantCanControl || variants[k].CanControl)
			{
				gameObject = variants[k].root;
				variants[k].SetControl(inControl: true);
				currentController = (VariantSet)k;
				break;
			}
		}
		for (k++; k < variants.Length; k++)
		{
			if (variants[k].root != gameObject)
			{
				variants[k].SetControl(inControl: false);
			}
		}
		SaveRenderingState();
	}

	public void SaveRenderingState()
	{
		int num = variants.Length;
		for (int i = 0; i < num; i++)
		{
			variants[i].SaveRenderingState();
		}
	}

	public void RestoreRenderingState()
	{
		int num = variants.Length;
		for (int i = 0; i < num; i++)
		{
			variants[i].RestoreRenderingState();
		}
		renderingSetIsSet = false;
	}

	public void EnableVariantRendering(VariantSet variantSet)
	{
		if (renderingSetIsSet && variantSet == renderingSet)
		{
			return;
		}
		if (renderingSetIsSet)
		{
			variants[(int)variantSet].SetRendering(enabled: true);
		}
		GameObject root = variants[(int)variantSet].root;
		int num = variants.Length;
		for (int i = 0; i < num; i++)
		{
			Variant variant = variants[i];
			if ((object)variant.root != root)
			{
				variant.SetRendering(enabled: false);
			}
		}
		renderingSetIsSet = true;
		renderingSet = variantSet;
	}

	public void SetVariantToMain(VariantSet newMain)
	{
		VariantSet portalVariantSet = MainCamera.Inst.portalVariantSet;
		int num = (int)portalVariantSet;
		int num2 = (int)currentController;
		if (anyVariantCanControl || variants[(int)newMain].CanControl)
		{
			variants[num2].SetControl(inControl: false);
			variants[(int)newMain].SetControl(inControl: true);
			currentController = portalVariantSet;
		}
		else
		{
			currentController = newMain;
		}
		lastMain = ((lastMain == newMain) ? portalVariantSet : newMain);
		Misc.Swap(ref variants[num], ref variants[(int)newMain]);
		variants[num].SetVariantSet(portalVariantSet);
		variants[(int)newMain].SetVariantSet(newMain);
		this.OnVariantSetChanged?.Invoke();
	}

	public void OnMainVariantChanged(VariantSet newMain, VariantSet oldMain)
	{
		if (oldMain != newMain && (anyVariantCanControl || variants[(int)newMain].CanControl))
		{
			variants[(int)oldMain].SetControl(inControl: false);
			variants[(int)newMain].SetControl(inControl: true);
		}
	}

	public void OnEnterPortal(Portal portal)
	{
		SetVariantToMain(portal.portalVariantSet);
		((IMimic<PortalVariations>)this).LinkedIMimic?.OnMimicEnteredPortal(portal);
	}

	void IOwnerChangeListener.OnOwnerChange(MRBase _oldOwner, MRBase _newOwner)
	{
		MRBase.TransferObject(_oldOwner, _newOwner, this);
	}

	void IMimicBase.OnMimicEnteredPortal(Portal portal)
	{
		SetVariantToMain(portal.portalVariantSet);
	}

	void IMimicBase.OnMimicSwappedControl(bool inControl)
	{
	}

	void IMimicBase.OnMimicUpdate()
	{
	}

	bool IMimicBase.CanHaveControl()
	{
		return true;
	}
}
public class SortingLayer : MonoBehaviour
{
	public int orderInLayer;

	private void OnValidate()
	{
		GetComponent<Renderer>().sortingOrder = orderInLayer;
	}
}
public class StaticBatch : MonoBehaviour
{
}
public class StaticBatchViewpoint : MonoBehaviour
{
}
public class Sunlight : MonoBehaviour
{
	public Color lightColor = Color.white;

	public float intensity = 1f;
}
public class UIAlphaFade : MonoBehaviour
{
	private UIElement element;

	private IHaglet<float, float, float> routineAlpha;

	private void Awake()
	{
		element = GetComponent<UIElement>();
		Haglet.Create(out routineAlpha, (Routine.Func3<float, float, float>)RoutineAlpha, (string)null, startNow: false, (int?)null, (string)null);
	}

	private void OnDestroy()
	{
		routineAlpha.Stop();
	}

	public Wait Animate(float time, float alphaStart, float alphaEnd)
	{
		routineAlpha.Stop();
		routineAlpha.Reset();
		routineAlpha.Start(time, alphaStart, alphaEnd);
		return Wait.Until.Completed(routineAlpha);
	}

	private IEnumerator<Routine.Yield> RoutineAlpha(float time, float alphaStart, float alphaEnd)
	{
		float t = 0f;
		while (t < time)
		{
			t += IC.DeltaTime;
			float t2 = t / time;
			element.alpha = Mathf.Lerp(alphaStart, alphaEnd, t2);
			yield return Wait.For.LRUpdates(1);
		}
	}
}
public class Crosshair : UIContainer
{
	public enum CrosshairMode
	{
		Default,
		Framerate,
		Off
	}

	public static Crosshair Inst;

	private Transform crosshairParent;

	private UIImage sprite;

	private UIImage spriteDebugFrameRate;

	[HideInInspector]
	public float defaultCrossHairDist = 2f;

	private CrosshairMode _crosshairMode;

	public static Vector3 cursorPos => Inst.sprite.transform.position;

	public CrosshairMode CrosshairDisplayMode
	{
		get
		{
			return _crosshairMode;
		}
		set
		{
			_crosshairMode = value;
			switch (_crosshairMode)
			{
			case CrosshairMode.Default:
				sprite.enabled = true;
				spriteDebugFrameRate.enabled = false;
				break;
			case CrosshairMode.Framerate:
				sprite.enabled = false;
				spriteDebugFrameRate.enabled = true;
				break;
			case CrosshairMode.Off:
				sprite.enabled = false;
				spriteDebugFrameRate.enabled = false;
				break;
			}
			sprite.gameObject.SetActive(sprite.enabled);
			spriteDebugFrameRate.gameObject.SetActive(spriteDebugFrameRate.enabled);
		}
	}

	public override Wait OnAwakeLR()
	{
		Inst = this;
		Initialise();
		crosshairParent = base.transform.GetChild(0);
		sprite = GetElement<UIImage>("Context");
		spriteDebugFrameRate = GetElement<UIImage>("FrameDebugger");
		spriteDebugFrameRate.gameObject.SetActive(value: false);
		CrosshairDisplayMode = CrosshairMode.Default;
		SetCrosshairDistance(6f);
		return Wait.PreMet;
	}

	public void OnUpdateLR()
	{
		if (_crosshairMode != CrosshairMode.Off)
		{
			int num = 526369;
			int num2 = 524320;
			Transform handRayTransform = CC.Inst.GetHandRayTransform();
			crosshairParent.parent = handRayTransform;
			crosshairParent.localPosition = Vector3.zero;
			crosshairParent.localRotation = Quaternion.identity;
			Ray handRay = CC.Inst.GetHandRay();
			int layerMask = ((NexusFullScreenPass.Inst.fadeAlpha > 0f) ? num2 : num);
			if (Physics.Raycast(handRay.origin, handRay.direction, out var hitInfo, float.MaxValue, layerMask))
			{
				SetCrosshairDistance(hitInfo.distance * 0.99f);
			}
			else
			{
				SetCrosshairDistance(defaultCrossHairDist);
			}
		}
	}

	private void SetCrosshairDistance(float distance)
	{
		Vector3 localPosition = Vector3.forward * distance * 0.95f;
		Vector3 localScale = Vector3.one * distance;
		Transform obj = crosshairParent;
		obj.localPosition = localPosition;
		obj.localScale = localScale;
	}
}
public class UIButton : UIElement
{
	private bool disabled;

	public Color disabledColor;

	[HideInInspector]
	public UITextbox textbox;

	[HideInInspector]
	public UITextbox childTextbox;

	[HideInInspector]
	public UIImage image;

	[HideInInspector]
	public UIImage[] childImages;

	public object userData;

	public bool Disabled
	{
		get
		{
			return disabled;
		}
		set
		{
			disabled = value;
			this.OnChangeDisabled(this);
		}
	}

	public event Action<UIButton> OnTapDown;

	public event Action<UIButton> OnTapHeld;

	public event Func<UIButton, bool> OnTapUp;

	public event Action<UIButton> OnFocusEnter;

	public event Action<UIButton> OnFocusExit;

	public event Action<UIButton> OnFocusStay;

	public event Action<UIButton> OnChangeDisabled;

	public void Start()
	{
	}

	public override void OnAwakeLR()
	{
		textbox = GetComponent<UITextbox>();
		childTextbox = GetComponentInChildren<UITextbox>(includeInactive: true);
		image = GetComponent<UIImage>();
		childImages = GetComponentsInChildren<UIImage>(includeInactive: true);
		if (disabled)
		{
			if ((bool)textbox)
			{
				textbox.color = disabledColor;
			}
			if ((bool)image)
			{
				image.color = disabledColor;
			}
		}
	}

	public void ClearTapUp()
	{
		this.OnTapUp = null;
	}

	public virtual void TapDown()
	{
		if (base.enabled && !disabled && this.OnTapDown != null)
		{
			this.OnTapDown(this);
		}
	}

	public virtual void TapHeld()
	{
		if (base.enabled && !disabled && this.OnTapHeld != null)
		{
			this.OnTapHeld(this);
		}
	}

	public virtual bool TapUp()
	{
		if (base.enabled && !disabled)
		{
			bool result = false;
			if (this.OnTapUp != null)
			{
				result = this.OnTapUp(this);
			}
			return result;
		}
		return false;
	}

	public virtual void FocusEnter()
	{
		if (base.enabled && !disabled && this.OnFocusEnter != null)
		{
			this.OnFocusEnter(this);
		}
	}

	public virtual void FocusExit()
	{
		if (this.OnFocusExit != null)
		{
			this.OnFocusExit(this);
		}
	}

	public virtual void FocusStay()
	{
		if (base.enabled && !disabled && this.OnFocusStay != null)
		{
			this.OnFocusStay(this);
		}
	}

	public override void OnAlphaSet(float alpha)
	{
		if (textbox != null)
		{
			textbox.alpha = alpha;
		}
		if (childTextbox != null)
		{
			childTextbox.alpha = alpha;
		}
		if (image != null)
		{
			image.alpha = alpha;
		}
		UIImage[] array = childImages;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].alpha = alpha;
		}
	}
}
[RequireComponent(typeof(UIButton))]
public class UIButtonHighlight : UIElement
{
	public Color colorHighlight;

	public bool toggleChildImages;

	private UIButton button;

	public override void OnAwakeLR()
	{
		button = GetComponent<UIButton>();
	}

	public override void OnStartLR()
	{
		if ((bool)button.image)
		{
			Color colorOriginal2 = button.image.color;
			button.OnFocusEnter += delegate(UIButton b)
			{
				b.image.color = (b.Disabled ? b.disabledColor : colorHighlight);
			};
			button.OnFocusExit += delegate(UIButton b)
			{
				b.image.color = (b.Disabled ? b.disabledColor : colorOriginal2);
			};
			button.OnChangeDisabled += delegate(UIButton b)
			{
				b.image.color = (b.Disabled ? b.disabledColor : colorOriginal2);
			};
		}
		if ((bool)button.textbox)
		{
			Color colorOriginal = button.textbox.color;
			button.OnFocusEnter += delegate(UIButton b)
			{
				b.textbox.color = (b.Disabled ? b.disabledColor : colorHighlight);
			};
			button.OnFocusExit += delegate(UIButton b)
			{
				b.textbox.color = (b.Disabled ? b.disabledColor : colorOriginal);
			};
			button.OnChangeDisabled += delegate(UIButton b)
			{
				b.textbox.color = (b.Disabled ? b.disabledColor : colorOriginal);
			};
		}
		if (button.childImages.Length == 0)
		{
			return;
		}
		if (toggleChildImages)
		{
			button.OnFocusEnter += delegate(UIButton b)
			{
				for (int m = 0; m < b.childImages.Length; m++)
				{
					b.childImages[m].Show();
				}
			};
			button.OnFocusExit += delegate(UIButton b)
			{
				for (int l = 0; l < b.childImages.Length; l++)
				{
					b.childImages[l].Hide();
				}
			};
			return;
		}
		Color[] childColors = new Color[button.childImages.Length];
		for (int i = 0; i < button.childImages.Length; i++)
		{
			childColors[i] = button.childImages[i].color;
		}
		button.OnFocusEnter += delegate(UIButton b)
		{
			for (int k = 0; k < b.childImages.Length; k++)
			{
				b.childImages[k].color = colorHighlight;
			}
		};
		button.OnFocusExit += delegate(UIButton b)
		{
			for (int j = 0; j < b.childImages.Length; j++)
			{
				b.childImages[j].color = childColors[j];
			}
		};
	}

	public override void Show()
	{
		base.Show();
		if (toggleChildImages && button.childImages.Length != 0)
		{
			for (int i = 0; i < button.childImages.Length; i++)
			{
				button.childImages[i].Hide();
			}
		}
	}
}
[RequireComponent(typeof(UIButton))]
public class UIButtonImageHighlight : UIElement
{
	private Sprite baseImage;

	private Sprite baseImageHighlight;

	public Sprite highlightImage;

	public bool swapOut;

	[ConditionalHide("swapOut")]
	public Sprite altImage;

	[ConditionalHide("swapOut")]
	public Sprite altImageHighlight;

	[ConditionalHide("swapOut")]
	public bool swapOutMuted;

	[ConditionalHide("swapOutMuted")]
	public Sprite baseImageMuted;

	[ConditionalHide("swapOutMuted")]
	public Sprite baseImageHighlightMuted;

	[ConditionalHide("swapOutMuted")]
	public Sprite altImageMuted;

	[ConditionalHide("swapOutMuted")]
	public Sprite altImageHighlightMuted;

	private SpriteRenderer sr;

	private UIButton button;

	private bool highlighted;

	private bool swapped;

	private bool muted;

	public override void OnAwakeLR()
	{
		button = GetComponent<UIButton>();
	}

	public override void OnStartLR()
	{
		if ((bool)button.image)
		{
			sr = button.image.spriteRenderer;
			baseImage = sr.sprite;
			baseImageHighlight = highlightImage;
			button.OnFocusEnter += delegate
			{
				highlighted = true;
				SetImage();
			};
			button.OnFocusExit += delegate
			{
				highlighted = false;
				SetImage();
			};
		}
		else
		{
			UnityEngine.Debug.LogError("UIButtonImageHighlight couldn't find a parent UIImage! Should this component be here?", this);
		}
	}

	public override void Show()
	{
		base.Show();
		SetImage();
	}

	public void SetSwappedImage(bool val)
	{
		if (swapOut && swapped != val)
		{
			swapped = val;
			SetImage();
		}
	}

	public void SetMutedImage(bool val)
	{
		if (swapOutMuted && muted != val)
		{
			muted = val;
			SetImage();
		}
	}

	private void SetImage()
	{
		sr.sprite = ((!muted) ? ((!swapped) ? (highlighted ? baseImageHighlight : baseImage) : (highlighted ? altImageHighlight : altImage)) : ((!swapped) ? (highlighted ? baseImageHighlightMuted : baseImageMuted) : (highlighted ? altImageHighlightMuted : altImageMuted)));
	}
}
[Serializer.ExcludeAllFieldsFromAssignablesTo]
[Serializer.ExcludeAllFields]
public class UIContainer : MonoBehaviour
{
	protected UIElement[] elements;

	protected UIContainer[] containers;

	private SpriteRenderer[] allImages;

	private UITextbox[] allText;

	[NonSerialized]
	public HagletTrigger OnShow = new HagletTrigger();

	[NonSerialized]
	public HagletTrigger OnHide = new HagletTrigger();

	[HideInInspector]
	public HagletFlag Shown = new HagletFlag();

	[HideInInspector]
	public bool allowShowHideCommands = true;

	private bool isShown;

	private float _alpha = 1f;

	private float _parentAlpha = 1f;

	private bool _interactable = true;

	public bool IsShown
	{
		get
		{
			return isShown;
		}
		set
		{
			if (isShown != value)
			{
				if (value)
				{
					ShowAll();
				}
				else
				{
					HideAll();
				}
			}
		}
	}

	public virtual void Initialise()
	{
		elements = GetComponentsInChildren<UIElement>(includeInactive: true);
		List<UIElement> list = new List<UIElement>(elements);
		int num = 0;
		while (num < list.Count)
		{
			if (list[num].GetComponentInAscendant<UIContainer>() != this)
			{
				list.RemoveAt(num);
			}
			else
			{
				num++;
			}
		}
		elements = list.ToArray();
		List<UIContainer> list2 = new List<UIContainer>();
		GetComponentsInChildren(includeInactive: true, list2);
		int num2 = 0;
		while (num2 < list2.Count)
		{
			UIContainer uIContainer = list2[num2];
			if (uIContainer.transform.parent.GetComponentInAscendant<UIContainer>() != this || uIContainer == this)
			{
				list2.RemoveAt(num2);
			}
			else
			{
				num2++;
			}
		}
		containers = list2.ToArray();
		ReconstructAllOrderedElementLists();
	}

	public virtual Wait OnAwakeLR()
	{
		return Wait.PreMet;
	}

	public virtual void ShowAll()
	{
		base.gameObject.SetActive(value: true);
		isShown = true;
		int num = elements.Length;
		while (--num >= 0)
		{
			if (elements[num].allowShowHideCommands)
			{
				elements[num].Show();
			}
		}
		int num2 = containers.Length;
		while (--num2 >= 0)
		{
			if (containers[num2].allowShowHideCommands)
			{
				containers[num2].ShowAll();
			}
		}
		OnBecameVisible();
	}

	public float GetAlpha()
	{
		return _alpha;
	}

	public void SetAlpha(float alpha)
	{
		_alpha = alpha;
		for (int i = 0; i < elements.Length; i++)
		{
			elements[i]._SetParentAlpha(_alpha * _parentAlpha);
		}
		for (int j = 0; j < containers.Length; j++)
		{
			containers[j]._SetParentAlpha(_alpha * _parentAlpha);
		}
	}

	public void _SetParentAlpha(float alpha)
	{
		_parentAlpha = alpha;
		for (int i = 0; i < elements.Length; i++)
		{
			elements[i]._SetParentAlpha(_alpha * _parentAlpha);
		}
		for (int j = 0; j < containers.Length; j++)
		{
			containers[j]._SetParentAlpha(_alpha * _parentAlpha);
		}
	}

	public void SetInteractable(bool interactable)
	{
		_interactable = interactable;
		for (int i = 0; i < elements.Length; i++)
		{
			elements[i]._SetInteractable(interactable);
		}
		for (int j = 0; j < containers.Length; j++)
		{
			containers[j].SetInteractable(interactable);
		}
	}

	protected void ReconstructAllOrderedElementLists()
	{
		allImages = GetComponentsInChildren<SpriteRenderer>(includeInactive: true);
		allImages = GetComponentsInChildren<SpriteRenderer>(includeInactive: true);
	}

	public void AddToRenderOrder(int spriteOrderJump)
	{
		int i = 0;
		for (int num = allImages.Length; i < num; i++)
		{
			allImages[i].sortingOrder += spriteOrderJump;
		}
		int j = 0;
		for (int num2 = allText.Length; j < num2; j++)
		{
			allText[j].sortingOrder += spriteOrderJump;
			allText[j].UpdateSortingOrder();
		}
	}

	public void ShowAtIndex(uint index)
	{
		isShown = true;
		elements[index].Show();
	}

	public virtual bool HideAll()
	{
		isShown = false;
		int num = elements.Length;
		while (--num >= 0)
		{
			if (elements[num].allowShowHideCommands)
			{
				elements[num].Hide();
			}
		}
		int num2 = containers.Length;
		while (--num2 >= 0)
		{
			if (containers[num2].allowShowHideCommands)
			{
				containers[num2].HideAll();
			}
		}
		Shown.Clear();
		OnHide.Trigger();
		return true;
	}

	public T GetElement<T>(string name, string parentName = null, string grandParentName = null) where T : UIElement
	{
		for (int i = 0; i < elements.Length; i++)
		{
			UIElement uIElement = elements[i];
			if (uIElement is T && name == uIElement.name && (parentName == null || uIElement.transform.parent.name == parentName) && (grandParentName == null || uIElement.transform.parent.parent.name == grandParentName))
			{
				return (T)uIElement;
			}
		}
		UnityEngine.Debug.LogError("UI: Failed to find element '" + name + "' in container '" + base.name + "'");
		return null;
	}

	public T TryGetElement<T>(string name, string parentName = null, string grandParentName = null) where T : UIElement
	{
		for (int i = 0; i < elements.Length; i++)
		{
			UIElement uIElement = elements[i];
			if (uIElement is T && name == uIElement.name && (parentName == null || uIElement.transform.parent.name == parentName) && (grandParentName == null || uIElement.transform.parent.parent.name == grandParentName))
			{
				return (T)uIElement;
			}
		}
		return null;
	}

	public T GetElement<T>(int index) where T : UIElement
	{
		return elements[index] as T;
	}

	public UIContainer GetContainer(string name)
	{
		UIContainer containerOrNull = GetContainerOrNull(name);
		if (containerOrNull == null)
		{
			UnityEngine.Debug.LogError("UI: Failed to find container '" + name + "' in parent container '" + base.name + "'", this);
		}
		return containerOrNull;
	}

	public UIContainer GetContainerOrNull(string name)
	{
		for (int i = 0; i < containers.Length; i++)
		{
			UIContainer uIContainer = containers[i];
			if (uIContainer.name == name)
			{
				return uIContainer;
			}
		}
		return null;
	}

	public UIContainer[] GetContainers()
	{
		return containers;
	}

	protected void OnBecameVisible()
	{
		Shown.Set();
		OnShow.Trigger();
	}

	public virtual bool OnBackButtonPressed()
	{
		Singleton<UIC>.Inst.Pop();
		return true;
	}

	public virtual void OnActionButtonPressed()
	{
	}

	public virtual bool ConsumesActionButton()
	{
		return false;
	}

	public void ToggleButtons(bool value)
	{
		for (int i = 0; i < elements.Length; i++)
		{
			if ((bool)(elements[i] as UIButton))
			{
				elements[i].enabled = value;
			}
		}
	}
}
public class UIElement : MonoBehaviour
{
	[HideInInspector]
	public bool allowShowHideCommands;

	private float _alpha = 1f;

	private float _parentAlpha = 1f;

	[HideInInspector]
	public bool interactable = true;

	public bool IsShown
	{
		get
		{
			return base.gameObject.activeSelf;
		}
		set
		{
			if (value)
			{
				Show();
			}
			else
			{
				Hide();
			}
		}
	}

	public virtual Color color { get; set; }

	public float alpha
	{
		get
		{
			return _alpha;
		}
		set
		{
			_alpha = value;
			OnAlphaSet(alphaInContainer);
		}
	}

	public float alphaInContainer => _alpha * _parentAlpha;

	public virtual void OnAwakeLR()
	{
		allowShowHideCommands = true;
	}

	public virtual void OnStartLR()
	{
	}

	public virtual void Show()
	{
		if (!IsShown)
		{
			base.gameObject.SetActive(value: true);
		}
	}

	public virtual void Hide()
	{
		if (IsShown)
		{
			base.gameObject.SetActive(value: false);
		}
	}

	public virtual void OnAlphaSet(float alpha)
	{
	}

	public void _SetParentAlpha(float alpha)
	{
		_parentAlpha = alpha;
		OnAlphaSet(alphaInContainer);
	}

	public void _SetInteractable(bool interact)
	{
		interactable = interact;
	}
}
public class UIFPS : UIContainer
{
	private UITextbox text;

	private int frameCounter;

	private float timeCounter;

	private float lastFramerate;

	private float refreshTime = 0.25f;

	public override Wait OnAwakeLR()
	{
		base.OnAwakeLR();
		text = GetElement<UITextbox>("FPS");
		return Wait.PreMet;
	}

	private void Update()
	{
		if (timeCounter < refreshTime)
		{
			timeCounter += IC.DeltaTime;
			frameCounter++;
		}
		else
		{
			lastFramerate = (float)frameCounter / timeCounter;
			frameCounter = 0;
			timeCounter = 0f;
		}
		if ((bool)text)
		{
			text.SetText("FPS: " + lastFramerate);
		}
	}
}
public class UIImage : UIElement
{
	[HideInInspector]
	public SpriteRenderer spriteRenderer;

	public bool allowRadialFill;

	public bool platformDependent;

	[ConditionalHide("platformDependent")]
	public LR.NexusPlatform platform;

	private int radialCutoffID;

	private Material mat;

	public override Color color
	{
		get
		{
			return spriteRenderer.color;
		}
		set
		{
			spriteRenderer.color = value;
		}
	}

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		spriteRenderer = GetComponent<SpriteRenderer>();
		Color color = spriteRenderer.color;
		if (allowRadialFill)
		{
			color.r = 1f;
			mat = spriteRenderer.material;
			PrepareRadialMaterial(mat, spriteRenderer.sprite);
			radialCutoffID = Shader.PropertyToID("_MaxAngle");
		}
		spriteRenderer.color = color;
	}

	public override void Show()
	{
		if (!platformDependent || LR.GetPlatform() == platform)
		{
			base.Show();
		}
		else
		{
			Hide();
		}
	}

	public void SetImage(Sprite sprite)
	{
		spriteRenderer.sprite = sprite;
	}

	public override void OnAlphaSet(float alpha)
	{
		spriteRenderer.color = spriteRenderer.color.RepA(alpha);
	}

	public static void PrepareRadialMaterial(Material radialMaterial, Sprite radialSprite)
	{
		Texture2D texture = radialSprite.texture;
		Rect textureRect = radialSprite.textureRect;
		Vector4 value = new Vector4(textureRect.center.x / (float)texture.width, textureRect.center.y / (float)texture.height, 0f - (float)texture.width / (float)texture.height, 0f);
		radialMaterial.SetVector("_RadialUVCenter", value);
	}

	public void SetRadialBarFill(float value)
	{
		mat.SetFloat(radialCutoffID, value);
	}
}
public class UIMeter : UIElement
{
	public UIButton icon;

	public UIButtonImageHighlight iconHighlight;

	public UIButton[] pips;

	public UIButtonImageHighlight[] pipsHighlight;
}
[RequireComponent(typeof(TextMesh))]
public class UITextbox : UIElement, Localisation.IUseLocalisation
{
	private struct LocalisedKeyNum
	{
		public string keyOrString;

		public bool isKey;

		public int? num;
	}

	public Font font;

	public Material fontMaterial;

	public string localisationKey;

	public bool localisedForController;

	public string controllerLocalisationKey;

	public bool enforceEnglish;

	public bool disableLocalisedFont;

	private ConstArray<LocalisedKeyNum> localisationKeys = new ConstArray<LocalisedKeyNum>(16u);

	private ConstArray<LocalisedKeyNum> tempKeyArray = new ConstArray<LocalisedKeyNum>(16u);

	[TextArea(3, 10)]
	public string text;

	public float wrapWidth = 0.3f;

	public int sortingOrder = -1;

	public bool wordWrap = true;

	public Vector3 colliderSizeOverride = -Vector3.one;

	private MeshRenderer meshRenderer;

	private TextMesh textMesh;

	private BoxCollider boxCollider;

	private const int MAX_STRING_SIZE = 512;

	private static string strInternal;

	private static StringBuilder strBuilder;

	private static UITextbox currentClient;

	public Action OnTextPresented;

	public Action<UITextbox, Vector3> OnTextPresentedWithSize;

	private float _height;

	private float baseCharSize;

	[Tooltip("Should have 6 entries, in order that the Localisation.Language enum is in i.e. 0 = English, 1 = French, 2 = Spanish, etc. Value 0 means use default.")]
	public float[] charSizeArray = new float[6];

	private bool HACK_initalised;

	[FormerlySerializedAs("DisableDepth")]
	[SerializeField]
	private bool disableDepth;

	private static char[] _intToStrBuffer;

	private const string _numberToken = "[NUMBER]";

	private static FieldInfo SBFI_m_ChunkChars;

	private static FieldInfo SBFI_m_ChunkPrevious;

	public string TextVisible => textMesh.text;

	public TextMesh TextMesh => textMesh;

	public override Color color
	{
		get
		{
			return textMesh.color;
		}
		set
		{
			textMesh.color = value;
		}
	}

	public TextAlignment alignment
	{
		get
		{
			return textMesh.alignment;
		}
		set
		{
			textMesh.alignment = value;
		}
	}

	static UITextbox()
	{
		strBuilder = new StringBuilder(512, 512);
		currentClient = null;
		_intToStrBuffer = new char[10];
		SBFI_m_ChunkChars = GetSBField("m_ChunkChars");
		SBFI_m_ChunkPrevious = GetSBField("m_ChunkPrevious");
		strInternal = GarbageFreeString(strBuilder);
	}

	public override void OnAwakeLR()
	{
		textMesh = GetComponent<TextMesh>();
		meshRenderer = GetComponent<MeshRenderer>();
		boxCollider = GetComponent<BoxCollider>();
		baseCharSize = textMesh.characterSize;
		for (int i = 0; i < charSizeArray.Length; i++)
		{
			if (Mathf.Approximately(charSizeArray[i], 0f))
			{
				charSizeArray[i] = baseCharSize;
			}
		}
		LocalisedKeyNum obj = default(LocalisedKeyNum);
		if (!string.IsNullOrEmpty(localisationKey))
		{
			obj.keyOrString = localisationKey;
			obj.isKey = true;
			obj.num = null;
		}
		else
		{
			obj.keyOrString = textMesh.text;
			obj.isKey = false;
			obj.num = null;
		}
		localisationKeys.Add(obj);
		if (font != null && !disableLocalisedFont)
		{
			string fontName = font.name;
			SetFont(Localisation.GetFontByName(fontName), Localisation.GetFontMaterialByName(fontName));
		}
		OnLanguageChanged(Localisation.Inst.CurrentLanguage);
		UITextboxEndBits component = GetComponent<UITextboxEndBits>();
		if (component != null)
		{
			component.OnAwake(this);
		}
		HACK_initalised = true;
	}

	private void OnEnable()
	{
		Localisation.Inst.AddUsesLocalisation(this);
		if (HACK_initalised)
		{
			OnLanguageChanged(Localisation.Inst.CurrentLanguage);
		}
	}

	private void OnDisable()
	{
		Localisation.Inst.RemoveUsesLocalisation(this);
	}

	public void Clear()
	{
		currentClient = this;
		strBuilder.Length = 0;
		localisationKeys.Clear();
		_height = 0f;
	}

	public void Append(int number)
	{
		LocalisedKeyNum obj = default(LocalisedKeyNum);
		obj.keyOrString = string.Empty;
		obj.isKey = false;
		obj.num = number;
		localisationKeys.Add(obj);
		uint number2;
		if (number < 0)
		{
			strBuilder.Append('-');
			number2 = (uint)(-number);
		}
		else
		{
			number2 = (uint)number;
		}
		Append(number2);
	}

	public void Append(uint number)
	{
		uint num = 0u;
		do
		{
			uint num2 = number % 10;
			_intToStrBuffer[num++] = (char)(48 + num2);
			number /= 10;
		}
		while (number != 0);
		while (num != 0)
		{
			strBuilder.Append(_intToStrBuffer[--num]);
		}
	}

	public void Append(string source, int startIndex, int count)
	{
		float num = 0.1f;
		float num2 = 0f;
		float num3 = textMesh.characterSize * num;
		Font font = textMesh.font;
		float num4 = num3 * (float)font.lineHeight;
		int num5 = 0;
		int num6 = startIndex + count;
		if (wordWrap)
		{
			int num7 = startIndex;
			int num8 = startIndex;
			float num9 = 0f;
			for (int i = startIndex; i < num6; i++)
			{
				char c = source[i];
				switch (c)
				{
				case ' ':
				case '\\':
					num7 = i + 1;
					num9 = num2;
					break;
				case '\n':
					strBuilder.Append(source, num8, i - num8);
					num8 = i;
					num7 = i;
					num5++;
					_height += num4;
					num2 = 0f;
					break;
				}
				if (!font.GetCharacterInfo(c, out var info))
				{
					continue;
				}
				float num10 = (float)info.advance * num3;
				num2 += num10;
				if (!(num2 > wrapWidth))
				{
					continue;
				}
				int num11 = num7 - num8;
				float num12 = num2 - num9;
				if (num11 == 0)
				{
					num11 = i - num8;
					num12 = 0f;
					num7 = i;
					if (num11 == 0)
					{
						num11 = 1;
						num7 = i + 1;
					}
					else
					{
						i--;
					}
				}
				strBuilder.Append(source, num8, num11);
				strBuilder.Append("\n");
				num8 += num11;
				num2 = num12;
				num5++;
				_height += num4;
			}
			if (num8 != num6)
			{
				strBuilder.Append(source, num8, num6 - num8);
				_height += num4;
			}
		}
		else
		{
			strBuilder.Append(source, startIndex, count);
		}
	}

	public void Append(string source, bool isKey = false)
	{
		if (!isKey)
		{
			LocalisedKeyNum obj = default(LocalisedKeyNum);
			obj.keyOrString = source;
			obj.isKey = false;
			obj.num = null;
			localisationKeys.Add(obj);
		}
		Append(source, 0, source.Length);
	}

	public Vector3 SetText(string text, bool returnSize = false)
	{
		if (text == null)
		{
			return Vector3.zero;
		}
		Clear();
		Append(text, 0, text.Length);
		return Present(returnSize);
	}

	public Vector3 SetNumber(int number, bool returnSize = false)
	{
		Clear();
		Append(number);
		return Present(returnSize);
	}

	public Vector3 SetKey(string key, bool returnSize = false)
	{
		Clear();
		AppendKey(key);
		return Present(returnSize);
	}

	public Vector3 SetKey(string key, int number, bool numberIsCurrency = false, bool returnSize = false)
	{
		Clear();
		AppendKey(key, number, numberIsCurrency);
		return Present(returnSize);
	}

	public void OnLanguageChanged(Localisation.Language newLanguage)
	{
		if (disableLocalisedFont)
		{
			return;
		}
		if (font != null && fontMaterial != null)
		{
			Localisation.SetLocalisedFont(this);
		}
		bool flag = enforceEnglish || newLanguage == Localisation.Language.ENGLISH;
		textMesh.characterSize = (flag ? baseCharSize : charSizeArray[(int)newLanguage]);
		if (localisationKeys.Length == 0)
		{
			return;
		}
		if (localisationKeys.Length == 1)
		{
			LocalisedKeyNum localisedKeyNum = localisationKeys[0];
			if (!localisedKeyNum.isKey)
			{
				if (localisedKeyNum.num.HasValue)
				{
					SetNumber(localisedKeyNum.num.Value);
				}
				else
				{
					SetText(localisedKeyNum.keyOrString);
				}
				return;
			}
			string key = ((!localisedForController) ? localisedKeyNum.keyOrString : controllerLocalisationKey);
			if (localisedKeyNum.num.HasValue)
			{
				SetKey(key, localisedKeyNum.num.Value);
			}
			else
			{
				SetKey(key);
			}
			return;
		}
		tempKeyArray.Clear();
		for (int i = 0; i < localisationKeys.Length; i++)
		{
			tempKeyArray.Add(localisationKeys[i]);
		}
		Clear();
		for (int j = 0; j < tempKeyArray.Length; j++)
		{
			LocalisedKeyNum localisedKeyNum2 = tempKeyArray[j];
			if (!localisedKeyNum2.isKey)
			{
				if (localisedKeyNum2.num.HasValue)
				{
					Append(localisedKeyNum2.num.Value);
				}
				else
				{
					Append(localisedKeyNum2.keyOrString);
				}
			}
			else if (localisedKeyNum2.num.HasValue)
			{
				AppendKey(localisedKeyNum2.keyOrString, localisedKeyNum2.num.Value);
			}
			else
			{
				AppendKey(localisedKeyNum2.keyOrString);
			}
		}
		Present();
	}

	public void AppendKey(string key)
	{
		LocalisedKeyNum obj = default(LocalisedKeyNum);
		obj.keyOrString = key;
		obj.isKey = true;
		obj.num = null;
		localisationKeys.Add(obj);
		string text = Localisation.Retrieve(key);
		Append(text ?? string.Empty, isKey: true);
	}

	public void AppendKey(string key, int number, bool numberIsCurrency = false)
	{
		LocalisedKeyNum obj = default(LocalisedKeyNum);
		obj.keyOrString = key;
		obj.isKey = true;
		obj.num = number;
		localisationKeys.Add(obj);
		string text = Localisation.Retrieve(key);
		int num = text.IndexOf("[NUMBER]");
		if (num != -1)
		{
			int num2 = num + "[NUMBER]".Length;
			if (numberIsCurrency && num - 1 >= 0 && number == 0 && text[num - 1] == 'K')
			{
				num--;
			}
			Append(text, 0, num);
			uint number2;
			if (number < 0)
			{
				strBuilder.Append('-');
				number2 = (uint)(-number);
			}
			else
			{
				number2 = (uint)number;
			}
			Append(number2);
			Append(text, num2, text.Length - num2);
		}
		else
		{
			Append(text);
		}
	}

	public override void OnAlphaSet(float alpha)
	{
		textMesh.color = textMesh.color.RepA(alpha);
	}

	public void UpdateSortingOrder()
	{
		meshRenderer.sortingOrder = sortingOrder;
	}

	public Vector3 Present(bool returnSize = false)
	{
		strBuilder.Append('\0');
		try
		{
			textMesh.text = UpdateString(strInternal, strBuilder);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
		UpdateSortingOrder();
		bool flag = boxCollider != null;
		Vector3 vector = ((returnSize || flag || OnTextPresentedWithSize != null) ? GetSize(textMesh, strInternal) : default(Vector3));
		if (flag)
		{
			boxCollider.size = vector.RepZ(boxCollider.size.z);
			Vector3 center = default(Vector3);
			switch (textMesh.anchor)
			{
			case TextAnchor.UpperLeft:
			case TextAnchor.MiddleLeft:
			case TextAnchor.LowerLeft:
				center.x = boxCollider.size.x / 2f;
				break;
			case TextAnchor.UpperCenter:
			case TextAnchor.MiddleCenter:
			case TextAnchor.LowerCenter:
				center.x = 0f;
				break;
			case TextAnchor.UpperRight:
			case TextAnchor.MiddleRight:
			case TextAnchor.LowerRight:
				center.x = (0f - boxCollider.size.x) / 2f;
				break;
			}
			switch (textMesh.anchor)
			{
			case TextAnchor.LowerLeft:
			case TextAnchor.LowerCenter:
			case TextAnchor.LowerRight:
				center.y = boxCollider.size.y / 2f;
				break;
			case TextAnchor.MiddleLeft:
			case TextAnchor.MiddleCenter:
			case TextAnchor.MiddleRight:
				center.y = 0f;
				break;
			case TextAnchor.UpperLeft:
			case TextAnchor.UpperCenter:
			case TextAnchor.UpperRight:
				center.y = (0f - boxCollider.size.y) / 2f;
				break;
			}
			boxCollider.center = center;
			boxCollider.size = new Vector3((colliderSizeOverride.x >= 0f) ? colliderSizeOverride.x : boxCollider.size.x, (colliderSizeOverride.y >= 0f) ? colliderSizeOverride.y : boxCollider.size.y, (colliderSizeOverride.z >= 0f) ? colliderSizeOverride.z : boxCollider.size.z);
		}
		if (OnTextPresented != null)
		{
			OnTextPresented();
		}
		if (OnTextPresentedWithSize != null)
		{
			OnTextPresentedWithSize(this, vector);
		}
		currentClient = null;
		return vector;
	}

	public Vector3 GetSize()
	{
		return GetSize(TextMesh, strInternal);
	}

	private static Vector3 GetSize(TextMesh mesh, string meshText, int overrideFontSize = -1)
	{
		Vector3 result = new Vector3(0f, mesh.font.lineHeight, 0f);
		float num = 0f;
		int i = 0;
		for (int length = meshText.Length; i < length && meshText[i] != 0; i++)
		{
			if (mesh.font.GetCharacterInfo(meshText[i], out var info, (overrideFontSize == -1) ? mesh.fontSize : overrideFontSize, mesh.fontStyle))
			{
				num += (float)info.advance;
			}
			if (meshText[i] == '\n')
			{
				result.x = Mathf.Max(num, result.x);
				result.y += mesh.font.lineHeight;
				num = 0f;
			}
		}
		result.x = Mathf.Max(num, result.x);
		result *= mesh.characterSize * 0.1f;
		result.z = 0.02f;
		return result;
	}

	private static FieldInfo GetSBField(string name)
	{
		return typeof(StringBuilder).GetField(name, BindingFlags.Instance | BindingFlags.NonPublic);
	}

	private unsafe static void wstrcpy(char* dest, char* src, int charCount)
	{
		long num = (long)charCount * 2L;
		Buffer.MemoryCopy(src, dest, num, num);
	}

	private static char[] GetSBChunk(StringBuilder sb, out int chunkOffset, out int chunkLength)
	{
		char[] array = (char[])SBFI_m_ChunkChars.GetValue(sb);
		chunkOffset = sb.Capacity - array.Length;
		chunkLength = sb.Length - chunkOffset;
		return array;
	}

	public unsafe static string UpdateString(string str, StringBuilder sb)
	{
		StringBuilder stringBuilder = sb;
		fixed (char* ptr = str)
		{
			char* ptr2 = ptr;
			do
			{
				int chunkOffset;
				int chunkLength;
				char[] sBChunk = GetSBChunk(stringBuilder, out chunkOffset, out chunkLength);
				if (chunkLength > 0)
				{
					if ((ulong)((long)chunkLength + (long)chunkOffset) > (ulong)str.Length || chunkLength > sBChunk.Length)
					{
						throw new ArgumentOutOfRangeException("chunkLength");
					}
					fixed (char* src = sBChunk)
					{
						wstrcpy(ptr2 + chunkOffset, src, chunkLength);
					}
				}
				stringBuilder = (StringBuilder)SBFI_m_ChunkPrevious.GetValue(stringBuilder);
			}
			while (stringBuilder != null);
		}
		return str;
	}

	public static string GarbageFreeString(StringBuilder sb)
	{
		return new string('\0', sb.Capacity);
	}

	public void SetFont(Font font, Material fontMaterial)
	{
		this.font = font;
		this.fontMaterial = fontMaterial;
		if (textMesh != null && meshRenderer != null)
		{
			textMesh.font = font;
			if (disableDepth)
			{
				fontMaterial = new Material(fontMaterial);
				fontMaterial.SetInt("_ZTEST", 8);
			}
			meshRenderer.sharedMaterial = fontMaterial;
		}
	}
}
public class UITextboxArrow : MonoBehaviour
{
	private UITextbox textbox;

	private BoxCollider thisColl;

	private float baseWidth;

	private bool left;

	public void Awake()
	{
		textbox = base.transform.parent.GetComponent<UITextbox>();
		thisColl = GetComponent<BoxCollider>();
		baseWidth = thisColl.size.x;
		left = base.name == "Arrow Left";
		UITextbox uITextbox = textbox;
		uITextbox.OnTextPresented = (Action)Delegate.Combine(uITextbox.OnTextPresented, new Action(AdjustArrow));
	}

	private void AdjustArrow()
	{
		Vector3 size = textbox.GetSize();
		int num = ((!left) ? 1 : (-1));
		float num2 = 0.5f * (size.x + baseWidth * base.transform.localScale.x);
		Vector3 localPosition = base.transform.localPosition;
		localPosition.x = num2 * (float)num;
		base.transform.localPosition = localPosition;
		float num3 = 0.5f * (size.x + baseWidth * base.transform.localScale.x * 2f);
		float num4 = num3 / 2f - (num3 - num2);
		Vector3 size2 = thisColl.size;
		size2.x = num3 / base.transform.localScale.x;
		thisColl.size = size2;
		Vector3 center = thisColl.center;
		center.x = num4 / base.transform.localScale.x;
		thisColl.center = center;
	}
}
[RequireComponent(typeof(UITextbox))]
public class UITextboxEndBits : MonoBehaviour
{
	public Transform endBitLeft;

	public Transform endBitRight;

	private UITextbox textbox;

	public void OnAwake(UITextbox textbox)
	{
		this.textbox = textbox;
		UITextbox uITextbox = this.textbox;
		uITextbox.OnTextPresented = (Action)Delegate.Combine(uITextbox.OnTextPresented, new Action(AdjustEndBits));
	}

	private void AdjustEndBits()
	{
		float num = 0.5f * (textbox.GetSize().x + 0.4f * base.transform.localScale.x);
		Vector3 localPosition = endBitLeft.localPosition;
		localPosition.x = 0f - num;
		endBitLeft.localPosition = localPosition;
		localPosition.x = num;
		endBitRight.localPosition = localPosition;
	}
}
[CreateAssetMenu(fileName = "InfographicSetup", menuName = "Nexus Settings/Infographic Setup", order = 0)]
public class InfographicSetup : ScriptableObject
{
	public Material DissolveMaterial;

	public float DissolveDuration;

	public FMODEventAsset FadeInSound;

	public FMODEventAsset FadeOutSound;

	public UIInfographic_Controller.InfographicSettings[] setups;

	public void UnloadAssets()
	{
		UIInfographic_Controller.InfographicSettings[] array = setups;
		for (int i = 0; i < array.Length; i++)
		{
			UIInfographic_Controller.InfographicSettings infographicSettings = array[i];
			Sprite[] infoFramesQuest = infographicSettings.infoFramesQuest;
			for (int j = 0; j < infoFramesQuest.Length; j++)
			{
				Resources.UnloadAsset(infoFramesQuest[j]);
			}
			infoFramesQuest = infographicSettings.infoFramesRift;
			for (int j = 0; j < infoFramesQuest.Length; j++)
			{
				Resources.UnloadAsset(infoFramesQuest[j]);
			}
		}
	}
}
public class UIInfographic_Controller : MonoBehaviour, IAwakeEvent
{
	public enum InfographicType
	{
		clickStick,
		cutscene,
		foot,
		grip,
		holdA,
		move,
		teleport,
		turn,
		none
	}

	[Serializable]
	public struct InfographicSettings
	{
		public InfographicType infoType;

		public float timeBetweenFrames;

		public Sprite[] infoFramesRift;

		public Sprite[] infoFramesQuest;

		public Sprite[] GetInfoFrames()
		{
			bool flag = LR.GetPlatform() == LR.NexusPlatform.QUEST;
			Sprite[] array = (flag ? infoFramesQuest : infoFramesRift);
			if (array.Length < 1)
			{
				string text = (flag ? "Oculus Quest" : "Oculus Rift");
				UnityEngine.Debug.LogError(string.Concat("Tried to access infographic frames of tpye (", infoType, ") for the ", text, " but there are no frames available"));
			}
			return array;
		}
	}

	private Dictionary<InfographicType, InfographicSettings> infographics = new Dictionary<InfographicType, InfographicSettings>();

	public InfographicType infoToPlay;

	public MeshRenderer easel;

	public MeshRenderer painting;

	public ParticleSystem dissolveParticle;

	public Renderer[] graphicRenderers;

	private SpriteRenderer infoRenderer;

	private Sprite[] currentInfoFrames;

	private float currentTimeBetweenFrames = 0.25f;

	public InfographicSetup settings;

	private IHaglet infoRoutine;

	public IHaglet<float, bool> dissolveRoutine;

	public void OnAwakeLR(MRBase owner)
	{
		InitInfographicController();
	}

	private void InitInfographicController()
	{
		infoRenderer = GetComponentInChildren<SpriteRenderer>(includeInactive: true);
		InitInfoDictionary();
		Haglet.Create(out infoRoutine, InfoRoutine);
		Haglet.Create(out dissolveRoutine, (Routine.Func2<float, bool>)DissolveRoutine, (string)null, startNow: false, (int?)null, (string)null);
		InitFirstFrame();
	}

	private void InitInfoDictionary()
	{
		InfographicSettings[] setups = settings.setups;
		if (setups.Length < 1)
		{
			UnityEngine.Debug.LogError("Failed to initialise infographics! Infographic settings array is empty!");
		}
		for (int i = 0; i < setups.Length; i++)
		{
			infographics.Add(setups[i].infoType, setups[i]);
		}
	}

	private void InitFirstFrame()
	{
		if (infoToPlay != InfographicType.none)
		{
			currentInfoFrames = infographics[infoToPlay].GetInfoFrames();
			infoRenderer.sprite = currentInfoFrames[0];
		}
	}

	public void StartInfographic()
	{
		if (infoRoutine.started)
		{
			UnityEngine.Debug.LogError("Infographic trying to play when it's already started!");
			return;
		}
		if (infoToPlay == InfographicType.none)
		{
			infoRenderer.enabled = false;
			return;
		}
		infoRenderer.enabled = true;
		currentInfoFrames = infographics[infoToPlay].GetInfoFrames();
		currentTimeBetweenFrames = infographics[infoToPlay].timeBetweenFrames;
		infoRenderer.sprite = currentInfoFrames[0];
		infoRoutine.Start();
	}

	public void StartInfographic(InfographicType newInfoType)
	{
		if (infoRoutine.started)
		{
			UnityEngine.Debug.LogError("Infographic trying to play when it's already started!");
			return;
		}
		infoToPlay = newInfoType;
		if (infoToPlay == InfographicType.none)
		{
			infoRenderer.enabled = false;
			return;
		}
		infoRenderer.enabled = true;
		currentInfoFrames = infographics[infoToPlay].GetInfoFrames();
		currentTimeBetweenFrames = infographics[infoToPlay].timeBetweenFrames;
		infoRenderer.sprite = currentInfoFrames[0];
		infoRoutine.Start();
	}

	private IEnumerator<Routine.Yield> InfoRoutine()
	{
		int i = 0;
		while (true)
		{
			yield return Wait.For.Seconds(currentTimeBetweenFrames);
			i++;
			if (i > currentInfoFrames.Length - 1)
			{
				i = 0;
			}
			infoRenderer.sprite = currentInfoFrames[i];
		}
	}

	public IEnumerator<Routine.Yield> DissolveRoutine(float duration, bool reverse)
	{
		if (!reverse)
		{
			if (infoRoutine != null)
			{
				infoRoutine.Stop();
			}
			currentInfoFrames = null;
		}
		if (!reverse)
		{
			FAC.Inst.PlayOneShot(settings.FadeOutSound, easel.transform.position);
		}
		else
		{
			FAC.Inst.PlayOneShot(settings.FadeInSound, easel.transform.position);
		}
		settings.DissolveMaterial.SetFloat("_Fade", reverse ? 1 : 0);
		_ = easel.material;
		_ = painting.material;
		easel.material = settings.DissolveMaterial;
		painting.material = settings.DissolveMaterial;
		dissolveParticle.gameObject.SetActive(value: true);
		if (dissolveParticle.isStopped)
		{
			dissolveParticle.Play(withChildren: true);
		}
		for (int i = 0; i < graphicRenderers.Length; i++)
		{
			graphicRenderers[i].gameObject.SetActive(value: false);
		}
		Vector3 localTop = new Vector3(0f, 0.637f, 0.112f);
		Vector3 localBottom = new Vector3(0f, -0.721f, 0f);
		float time = 0f;
		while (time <= duration && !Routine.Skipping)
		{
			time = Mathf.Min(time + IC.DeltaTime, duration);
			float num = time / duration;
			if (reverse)
			{
				num = 1f - num;
			}
			settings.DissolveMaterial.SetFloat("_Fade", num);
			Vector3 localPosition = Vector3.Lerp(localTop, localBottom, num);
			dissolveParticle.transform.localPosition = localPosition;
			if (!(time < duration))
			{
				break;
			}
			yield return Wait.For.LRUpdates(1);
		}
		if (reverse)
		{
			for (int j = 0; j < graphicRenderers.Length; j++)
			{
				graphicRenderers[j].gameObject.SetActive(value: true);
			}
		}
		dissolveParticle.Stop(withChildren: true, ParticleSystemStopBehavior.StopEmitting);
	}

	private void OnDestroy()
	{
		if (infoRoutine != null)
		{
			infoRoutine.Stop();
		}
		if (settings != null)
		{
			settings.UnloadAssets();
			Resources.UnloadAsset(settings);
		}
	}
}
[Serializable]
public class UIBookPage
{
	public UIContainer PageLeft;

	public UIContainer PageRight;

	public virtual void OnAwakeLR()
	{
	}

	public virtual void ShowAll()
	{
		if ((bool)PageLeft)
		{
			PageLeft.ShowAll();
		}
		if ((bool)PageRight)
		{
			PageRight.ShowAll();
		}
	}

	public virtual void HideAll()
	{
		if ((bool)PageLeft)
		{
			PageLeft.HideAll();
		}
		if ((bool)PageRight)
		{
			PageRight.HideAll();
		}
	}

	public virtual void SetAlpha(float alpha)
	{
		if ((bool)PageLeft)
		{
			PageLeft.SetAlpha(alpha);
		}
		if ((bool)PageRight)
		{
			PageRight.SetAlpha(alpha);
		}
	}

	public virtual void ToggleButtons(bool value)
	{
		if ((bool)PageLeft)
		{
			PageLeft.ToggleButtons(value);
		}
		if ((bool)PageRight)
		{
			PageRight.ToggleButtons(value);
		}
	}

	public virtual bool ReturnMenu()
	{
		return false;
	}
}
public class UICredits : UIContainer
{
	private struct CreditsSetup
	{
		public UIContainer container;

		public UITextbox textboxCompany;

		public UITextbox textboxRole;

		public UIContainer containerNames;

		public UITextbox[] textboxNames;

		public UIImage imageSnapshot;
	}

	public Sprite[] creditsImages;

	private Credits credits;

	private System.Random random;

	private readonly string[] creditsSetupNames = new string[1] { "FullLength" };

	private float[] creditsSetupWeights;

	private float[] creditsImageWeights;

	private bool HACK_running;

	private CreditsSetup[] creditsSetups;

	private UIContainer endSlate;

	private IHaglet creditsRoutine;

	private IHaglet<UIContainer, float, float, bool> creditsStartFadeRoutine;

	private IHaglet<UIContainer, float, float, bool> creditsSetupFadeRoutine;

	private IHaglet<UIContainer, float, float, bool> namesStartFadeRoutine;

	private IHaglet<UIElement, float, float, bool> titleAlphaAnimateRoutine;

	private IHaglet<UIElement, float, float, bool> companyAlphaAnimateRoutine;

	private IHaglet<UIElement, float, float, bool> roleAlphaAnimateRoutine;

	[SerializeField]
	[Tooltip("Fade time for the first and last screens")]
	private float fadeTimeStartEnd = 0.75f;

	[SerializeField]
	[Tooltip("Fade time for all but the first and last screens")]
	private float fadeTimeMiddle = 0.5f;

	[SerializeField]
	[Tooltip("Number of seconds each credits screen hangs around for")]
	private float creditScreenStayTime = 1.45f;

	private UIImage imgBackground;

	private UITextbox txtTitle;

	private int currentSetupIndex;

	public float creditsDist = 1.1f;

	[Tooltip("Controls how quickly the credits will follow the camera. 1 = always in front, 0 = will never move")]
	[Range(0f, 1f)]
	public float lerpFactor = 0.1f;

	private IHaglet updateRoutine;

	private IHaglet<float, float> fadeEndSlateRoutine;

	private bool paused;

	public override Wait OnAwakeLR()
	{
		base.OnAwakeLR();
		imgBackground = GetElement<UIImage>("Background");
		txtTitle = GetElement<UITextbox>("Title");
		credits = Credits.Load("credits");
		random = new System.Random();
		creditsSetups = new CreditsSetup[creditsSetupNames.Length];
		for (int i = 0; i < creditsSetupNames.Length; i++)
		{
			CreditsSetup creditsSetup = default(CreditsSetup);
			UIContainer uIContainer = (creditsSetup.container = GetContainer(creditsSetupNames[i]));
			creditsSetup.textboxCompany = uIContainer.GetElement<UITextbox>("Company");
			creditsSetup.textboxRole = uIContainer.GetElement<UITextbox>("Role");
			creditsSetup.containerNames = uIContainer.GetContainer("Names");
			creditsSetup.textboxNames = new UITextbox[4]
			{
				creditsSetup.containerNames.GetElement<UITextbox>("Name0"),
				creditsSetup.containerNames.GetElement<UITextbox>("Name1"),
				creditsSetup.containerNames.GetElement<UITextbox>("Name2"),
				creditsSetup.containerNames.GetElement<UITextbox>("Name3")
			};
			if (creditsSetupNames[i] != "FullLength")
			{
				creditsSetup.imageSnapshot = uIContainer.GetElement<UIImage>("Snapshot");
			}
			creditsSetups[i] = creditsSetup;
			creditsSetup.container.HideAll();
		}
		endSlate = GetContainer("EndSlate");
		creditsSetupWeights = new float[creditsSetupNames.Length];
		ResetSetupWeights();
		creditsImageWeights = new float[creditsImages.Length];
		ResetImageWeights();
		Haglet.Create(out creditsRoutine, CreditsRoutine);
		Haglet.Create(out creditsStartFadeRoutine, (Routine.Func4<UIContainer, float, float, bool>)StartFadeRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out creditsSetupFadeRoutine, (Routine.Func4<UIContainer, float, float, bool>)StartFadeRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out namesStartFadeRoutine, (Routine.Func4<UIContainer, float, float, bool>)StartFadeRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out titleAlphaAnimateRoutine, (Routine.Func4<UIElement, float, float, bool>)AlphaAnimateRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out companyAlphaAnimateRoutine, (Routine.Func4<UIElement, float, float, bool>)AlphaAnimateRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out roleAlphaAnimateRoutine, (Routine.Func4<UIElement, float, float, bool>)AlphaAnimateRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out fadeEndSlateRoutine, (Routine.Func2<float, float>)FadeEndSlateRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out updateRoutine, UpdateRoutine);
		HideAll();
		return Wait.PreMet;
	}

	public Wait ShowCredits()
	{
		if (creditsRoutine.started)
		{
			return Wait.None;
		}
		ResetSetupWeights();
		ResetImageWeights();
		return creditsRoutine.Start();
	}

	private static void Shuffle<T>(IList<T> list, System.Random rnd)
	{
		for (int i = 0; i < list.Count; i++)
		{
			Swap(list, i, rnd.Next(i, list.Count));
		}
	}

	private static void Swap<T>(IList<T> list, int i, int j)
	{
		T value = list[i];
		list[i] = list[j];
		list[j] = value;
	}

	private void CalculateOrbitPos(Transform trackingObject)
	{
		MainCamera inst = MainCamera.Inst;
		Vector3 forward = inst.transform.forward;
		forward.y = 0f;
		forward = forward.normalized * creditsDist;
		Vector3 vector = trackingObject.transform.position - inst.transform.position;
		vector.y = 0f;
		vector = vector.normalized * creditsDist;
		float b = Vector3.SignedAngle(vector, forward, Vector3.up);
		b = Mathf.Lerp(0f, b, lerpFactor);
		trackingObject.transform.position = inst.transform.position + Quaternion.Euler(0f, b, 0f) * vector;
		trackingObject.transform.LookAt(inst.transform.position);
		trackingObject.transform.Rotate(0f, 180f, 0f);
	}

	private IEnumerator<Routine.Yield> UpdateRoutine()
	{
		while (true)
		{
			CalculateOrbitPos(base.transform);
			yield return Wait.ForUpdate;
			base.gameObject.SetActive(!LR.Inst.IsPaused);
		}
	}

	private IEnumerator<Routine.Yield> CreditsRoutine()
	{
		HACK_running = true;
		float num = 2f;
		base.transform.position = IC.Inst.transform.position + Vector3.forward * num;
		updateRoutine.Start();
		base.ShowAll();
		for (int i = 0; i < credits.companies.Count; i++)
		{
			Credits.Company company2 = credits.companies[i];
			if (company2.shuffle)
			{
				for (int j = 0; j < company2.roles.Count; j++)
				{
					Shuffle(company2.roles[j].people, random);
				}
				Shuffle(company2.roles, random);
			}
		}
		bool isVisible = false;
		currentSetupIndex = WeightedRandomSelect(creditsSetupWeights);
		creditsSetupWeights[currentSetupIndex] = 0f;
		bool setupChanged = true;
		for (int k = 0; k < creditsSetups.Length; k++)
		{
			if (k != currentSetupIndex)
			{
				creditsSetups[k].container.SetAlpha(0f);
			}
		}
		endSlate.SetAlpha(0f);
		if (creditsSetups[currentSetupIndex].imageSnapshot != null)
		{
			int num2 = WeightedRandomSelect(creditsImageWeights);
			creditsSetups[currentSetupIndex].imageSnapshot.SetImage(creditsImages[num2]);
		}
		int cIdx = 0;
		while (cIdx < credits.companies.Count)
		{
			Credits.Company company = credits.companies[cIdx];
			Credits.Company companyNext = credits.companies[Mathf.Min(cIdx + 1, credits.companies.Count - 1)];
			int num6;
			for (int rIdx = 0; rIdx < company.roles.Count; rIdx = num6)
			{
				Credits.Role role = company.roles[rIdx];
				Credits.Role roleNext = company.roles[Mathf.Min(rIdx + 1, company.roles.Count - 1)];
				bool isLastRole = rIdx == company.roles.Count - 1;
				for (int personGroupIdx = 0; personGroupIdx < role.people.Count; personGroupIdx += 4)
				{
					bool isLastGroup = personGroupIdx + 4 >= role.people.Count;
					int num3 = Mathf.Min(role.people.Count, personGroupIdx + 4);
					creditsSetups[currentSetupIndex].containerNames.HideAll();
					int num4 = 0;
					for (int l = personGroupIdx; l < num3; l++)
					{
						string text = role.people[l];
						creditsSetups[currentSetupIndex].textboxNames[num4++].SetText(text);
					}
					creditsSetups[currentSetupIndex].container.ShowAll();
					for (int m = num4; m < 4; m++)
					{
						creditsSetups[currentSetupIndex].textboxNames[m].Hide();
					}
					creditsSetups[currentSetupIndex].textboxCompany.SetText(company.name);
					creditsSetups[currentSetupIndex].textboxRole.SetText(role.name);
					if (!isVisible)
					{
						isVisible = true;
						creditsSetups[currentSetupIndex].containerNames.SetAlpha(1f);
						SetAlpha(0f);
						yield return creditsStartFadeRoutine.Start(this, 1f, fadeTimeStartEnd);
					}
					else if (setupChanged)
					{
						if (creditsSetups[currentSetupIndex].imageSnapshot != null)
						{
							int num5 = WeightedRandomSelect(creditsImageWeights);
							if (num5 == -1)
							{
								ResetImageWeights();
								num5 = WeightedRandomSelect(creditsImageWeights);
							}
							creditsImageWeights[num5] = 0f;
							creditsSetups[currentSetupIndex].imageSnapshot.SetImage(creditsImages[num5]);
						}
						creditsSetups[currentSetupIndex].containerNames.SetAlpha(1f);
						yield return creditsSetupFadeRoutine.Start(creditsSetups[currentSetupIndex].container, 1f, fadeTimeMiddle);
					}
					else
					{
						companyAlphaAnimateRoutine.Start(creditsSetups[currentSetupIndex].textboxCompany, 1f, fadeTimeMiddle);
						roleAlphaAnimateRoutine.Start(creditsSetups[currentSetupIndex].textboxRole, 1f, fadeTimeMiddle);
						yield return namesStartFadeRoutine.Start(creditsSetups[currentSetupIndex].containerNames, 1f, fadeTimeMiddle);
					}
					yield return Wait.For.Seconds(creditScreenStayTime);
					int nextSetupIndex = (isLastGroup ? WeightedRandomSelect(creditsSetupWeights) : currentSetupIndex);
					if (nextSetupIndex == -1)
					{
						ResetSetupWeights();
						nextSetupIndex = WeightedRandomSelect(creditsSetupWeights);
					}
					creditsSetupWeights[nextSetupIndex] = 0f;
					setupChanged = nextSetupIndex != currentSetupIndex;
					if (setupChanged)
					{
						yield return creditsSetupFadeRoutine.Start(creditsSetups[currentSetupIndex].container, 0f, fadeTimeMiddle);
					}
					else
					{
						if (isLastGroup && isLastRole && company.name != companyNext.name)
						{
							companyAlphaAnimateRoutine.Start(creditsSetups[currentSetupIndex].textboxCompany, 0f, fadeTimeMiddle);
							roleAlphaAnimateRoutine.Start(creditsSetups[currentSetupIndex].textboxRole, 0f, fadeTimeMiddle);
						}
						if (isLastGroup && role.name != roleNext.name)
						{
							roleAlphaAnimateRoutine.Start(creditsSetups[currentSetupIndex].textboxRole, 0f, fadeTimeMiddle);
						}
						yield return namesStartFadeRoutine.Start(creditsSetups[currentSetupIndex].containerNames, 0f, fadeTimeMiddle);
					}
					yield return Wait.For.Updates(1);
					currentSetupIndex = nextSetupIndex;
				}
				num6 = rIdx + 1;
			}
			num6 = cIdx + 1;
			cIdx = num6;
		}
		titleAlphaAnimateRoutine.Start(txtTitle, 0f, fadeTimeMiddle, arg3: false);
		companyAlphaAnimateRoutine.Start(creditsSetups[currentSetupIndex].textboxCompany, 0f, fadeTimeMiddle);
		yield return roleAlphaAnimateRoutine.Start(creditsSetups[currentSetupIndex].textboxRole, 0f, fadeTimeMiddle);
		yield return fadeEndSlateRoutine.Call(4f, 0.3f);
		yield return creditsStartFadeRoutine.Start(this, 0f, fadeTimeStartEnd, arg3: false);
		base.HideAll();
		for (int n = 0; n < creditsSetups.Length; n++)
		{
			creditsSetups[n].container.HideAll();
		}
		yield return Wait.For.Seconds(0.6f);
		HACK_running = false;
		updateRoutine.Stop();
	}

	private IEnumerator<Routine.Yield> StartFadeRoutine(UIContainer container, float targetVal, float fadeLength, bool hideOnComplete = false)
	{
		float fadeStartVal = container.GetAlpha();
		float t = 0f;
		while (t < 1f)
		{
			t += Time.deltaTime / fadeLength;
			container.SetAlpha(Mathf.Lerp(fadeStartVal, targetVal, t));
			yield return Wait.For.LRUpdates(1);
		}
		if (hideOnComplete)
		{
			HideAll();
		}
	}

	private IEnumerator<Routine.Yield> AlphaAnimateRoutine(UIElement element, float alphaTarget, float duration, bool hideOnComplete = false)
	{
		float t = 0f;
		float alphaStart = element.alpha;
		while (t < duration)
		{
			t += Time.deltaTime;
			element.alpha = Mathf.Lerp(alphaStart, alphaTarget, t / duration);
			yield return Wait.For.LRUpdates(1);
		}
		if (hideOnComplete)
		{
			element.Hide();
		}
	}

	private IEnumerator<Routine.Yield> FadeEndSlateRoutine(float showTime, float fadeTime)
	{
		endSlate.SetAlpha(0f);
		float t2 = 0f;
		while (t2 < 1f)
		{
			t2 += Time.deltaTime / fadeTime;
			endSlate.SetAlpha(t2);
			yield return Wait.For.LRUpdates(1);
		}
		endSlate.SetAlpha(1f);
		yield return Wait.For.Seconds(showTime);
		t2 = 1f;
		while (t2 > 0f)
		{
			t2 -= Time.deltaTime / fadeTime;
			endSlate.SetAlpha(t2);
			yield return Wait.For.LRUpdates(1);
		}
		endSlate.SetAlpha(0f);
	}

	private void ResetSetupWeights()
	{
		for (int i = 0; i < creditsSetupWeights.Length; i++)
		{
			creditsSetupWeights[i] = 1f;
		}
	}

	private void ResetImageWeights()
	{
		for (int i = 0; i < creditsImageWeights.Length; i++)
		{
			creditsImageWeights[i] = 1f;
		}
	}

	public void Pause(bool pause)
	{
		if (HACK_running && pause != paused)
		{
			if (!pause)
			{
				ToggleBackgroundVisibility(value: true);
			}
			paused = pause;
		}
	}

	private void ToggleBackgroundVisibility(bool value)
	{
		imgBackground.IsShown = value;
		txtTitle.IsShown = value;
		creditsSetups[currentSetupIndex].container.IsShown = value;
		creditsSetups[currentSetupIndex].container.SetAlpha(value ? 1f : 0f);
		ShowAll();
	}

	private static int WeightedRandomSelect(float[] weights)
	{
		float num = 0f;
		for (int i = 0; i < weights.Length; i++)
		{
			num += weights[i];
		}
		float num2 = UnityEngine.Random.Range(0f, num);
		float num3 = 0f;
		for (int j = 0; j < weights.Length; j++)
		{
			if (!(weights[j] <= 0f))
			{
				num3 += weights[j];
				if (num3 >= num2)
				{
					return j;
				}
			}
		}
		return -1;
	}

	public void StopCredits()
	{
		creditsRoutine?.Stop();
		creditsStartFadeRoutine?.Stop();
		creditsSetupFadeRoutine?.Stop();
		namesStartFadeRoutine?.Stop();
		companyAlphaAnimateRoutine?.Stop();
		roleAlphaAnimateRoutine?.Stop();
		fadeEndSlateRoutine?.Stop();
		updateRoutine?.Stop();
		HideAll();
	}

	private void OnDestroy()
	{
		StopCredits();
	}
}
public class UIDebug : UIContainer
{
	public static UIDebug Inst;

	private const float fadeDur = 0.3f;

	public Transform root;

	private UIContainer containerNavButtons;

	private UIContainer containerMainMenu;

	private UIContainer containerProfilingMenu;

	private UIContainer containerMiscMenu;

	private UIContainer containerHagisCallStack;

	private UIContainer containerHagisEntry;

	private UIContainer containerDebugValues;

	private UIContainer containerVignetteSettings;

	private UIContainer containerRecording;

	private UIContainer containerCurrMenu;

	private UIContainer containerPerformanceTest;

	private UIContainer containerAchievements;

	private UITextbox textBoxRevision;

	private UIButton buttonUpArrow;

	private UIButton buttonDownArrow;

	private UIButton buttonBigUpArrow;

	private UIButton buttonBigDownArrow;

	private UIButton buttonReturnArrow;

	private Func<UIButton, bool> openMenu;

	private bool lockedToIC;

	public bool LockecToIC
	{
		get
		{
			return lockedToIC;
		}
		set
		{
			if (lockedToIC != value)
			{
				lockedToIC = value;
				if (lockedToIC)
				{
					base.transform.SetParent(IC.Inst.transform);
				}
				else
				{
					base.transform.SetParent(null);
				}
			}
		}
	}

	private event Action<int> _scrollAction;

	public event Action<int> scrollAction
	{
		add
		{
			if (value != null)
			{
				_scrollAction += value;
				UIButton uIButton = buttonBigUpArrow;
				UIButton uIButton2 = buttonUpArrow;
				UIButton uIButton3 = buttonBigDownArrow;
				bool flag2 = (buttonDownArrow.IsShown = true);
				bool flag4 = (uIButton3.IsShown = flag2);
				bool flag6 = (uIButton2.IsShown = flag4);
				uIButton.IsShown = flag6;
			}
		}
		remove
		{
			if (value != null)
			{
				_scrollAction -= value;
			}
		}
	}

	public override Wait OnAwakeLR()
	{
		base.OnAwakeLR();
		Inst = this;
		root = base.transform.GetChild(0);
		int num = containers.Length;
		while (--num >= 0)
		{
			containers[num].allowShowHideCommands = false;
		}
		int num2 = elements.Length;
		while (--num2 >= 0)
		{
			elements[num2].allowShowHideCommands = false;
		}
		containerMainMenu = (containerCurrMenu = GetContainer("Main Menu"));
		containerProfilingMenu = GetContainer("Profiling Menu");
		containerProfilingMenu.transform.localPosition = Vector3.zero;
		containerMiscMenu = GetContainer("Misc Menu");
		containerMiscMenu.transform.localPosition = Vector3.zero;
		containerHagisCallStack = GetContainer("Hagis Call Stack Menu");
		containerHagisCallStack.transform.localPosition = Vector3.zero;
		containerHagisEntry = GetContainer("Hagis Entry Menu");
		containerHagisEntry.transform.localPosition = Vector3.zero;
		containerDebugValues = GetContainer("Debug Menu");
		containerDebugValues.transform.localPosition = Vector3.zero;
		containerVignetteSettings = GetContainer("Vignette Settings");
		containerVignetteSettings.transform.localPosition = Vector3.zero;
		containerRecording = GetContainer("Recording Menu");
		containerRecording.transform.localPosition = Vector3.zero;
		containerPerformanceTest = GetContainer("Framerate Test Options");
		containerPerformanceTest.transform.localPosition = Vector3.zero;
		containerAchievements = GetContainer("Achievement Menu");
		containerAchievements.transform.localPosition = Vector3.zero;
		containerNavButtons = GetContainer("NavButtons");
		buttonUpArrow = containerNavButtons.GetElement<UIButton>("Up Arrow");
		buttonDownArrow = containerNavButtons.GetElement<UIButton>("Down Arrow");
		buttonBigUpArrow = containerNavButtons.GetElement<UIButton>("BigUp Arrow");
		buttonBigDownArrow = containerNavButtons.GetElement<UIButton>("BigDown Arrow");
		buttonReturnArrow = containerNavButtons.GetElement<UIButton>("Return Arrow");
		textBoxRevision = GetElement<UITextbox>("Revision");
		openMenu = delegate(UIButton button)
		{
			SetCurrentContainer((UIContainer)button.userData);
			return true;
		};
		buttonUpArrow.OnTapUp += delegate
		{
			if (this._scrollAction != null)
			{
				this._scrollAction(1);
			}
			return true;
		};
		buttonDownArrow.OnTapUp += delegate
		{
			if (this._scrollAction != null)
			{
				this._scrollAction(-1);
			}
			return true;
		};
		buttonBigUpArrow.OnTapUp += delegate
		{
			if (this._scrollAction != null)
			{
				this._scrollAction(5);
			}
			return true;
		};
		buttonBigDownArrow.OnTapUp += delegate
		{
			if (this._scrollAction != null)
			{
				this._scrollAction(-5);
			}
			return true;
		};
		buttonReturnArrow.OnTapUp += delegate
		{
			ReturnToParentMenu();
			return true;
		};
		buttonReturnArrow.userData = containerMainMenu;
		HideAll();
		UIButton element = containerMainMenu.GetElement<UIButton>("Profiling");
		element.OnTapUp += openMenu;
		element.userData = containerProfilingMenu;
		UIButton element2 = containerMainMenu.GetElement<UIButton>("Misc");
		element2.OnTapUp += openMenu;
		element2.userData = containerMiscMenu;
		UIButton element3 = containerMainMenu.GetElement<UIButton>("Areas");
		element3.OnTapUp += openMenu;
		element3.userData = GetContainer("Areas Menu");
		UIButton element4 = containerMainMenu.GetElement<UIButton>("Hagis");
		element4.OnTapUp += openMenu;
		element4.userData = containerHagisCallStack;
		UIButton element5 = containerMainMenu.GetElement<UIButton>("Debug Values");
		element5.OnTapUp += openMenu;
		element5.userData = containerDebugValues;
		UIButton element6 = containerMainMenu.GetElement<UIButton>("Vignette Settings");
		element6.OnTapUp += openMenu;
		element6.userData = containerVignetteSettings;
		UIButton element7 = containerMainMenu.GetElement<UIButton>("Framerate Test");
		element7.OnTapUp += openMenu;
		element7.userData = containerPerformanceTest;
		UIButton element8 = containerMainMenu.GetElement<UIButton>("Achievements");
		element8.OnTapUp += openMenu;
		element8.userData = containerAchievements;
		containerMainMenu.GetElement<UIButton>("Return To Hub").OnTapUp += delegate
		{
			if (!LR.Inst.IsAllConnectedSceneLoadingUnloadingComplete())
			{
				return false;
			}
			SceneInfo sceneInfoWithSceneUIDName4 = LR.Inst.GetSceneInfoWithSceneUIDName("suez");
			LR.Inst.LoadPlayerIntoScene(sceneInfoWithSceneUIDName4);
			return true;
		};
		containerMainMenu.GetElement<UIButton>("Start Vertical Slice").OnTapUp += delegate
		{
			if (!LR.Inst.IsAllConnectedSceneLoadingUnloadingComplete())
			{
				return false;
			}
			LR.Inst.GetSceneInfoWithSceneUIDName("gatt");
			SceneInfo sceneInfoWithSceneUIDName3 = LR.Inst.GetSceneInfoWithSceneUIDName("hair");
			LR.Inst.LoadPlayerIntoScene(sceneInfoWithSceneUIDName3);
			return true;
		};
		UIButton element9 = containerMainMenu.GetElement<UIButton>("Input Recording");
		element9.OnTapUp += openMenu;
		element9.userData = containerRecording;
		containerMainMenu.GetElement<UIButton>("Clear Save Data").OnTapUp += delegate
		{
			if (!LR.Inst.IsAllConnectedSceneLoadingUnloadingComplete())
			{
				return false;
			}
			LR.Inst.saveDataGame.chaptersComplete = SaveDataGame.Chapter.None;
			LR.Inst.Save();
			SceneInfo sceneInfoWithSceneUIDName2 = LR.Inst.GetSceneInfoWithSceneUIDName("suez");
			LR.Inst.LoadPlayerIntoScene(sceneInfoWithSceneUIDName2);
			return true;
		};
		containerMainMenu.GetElement<UIButton>("Force Complete Save Data").OnTapUp += delegate
		{
			if (!LR.Inst.IsAllConnectedSceneLoadingUnloadingComplete())
			{
				return false;
			}
			LR.Inst.saveDataGame.tutorialComplete = true;
			LR.Inst.saveDataGame.chaptersComplete = (SaveDataGame.Chapter)(-1);
			LR.Inst.Save();
			SceneInfo sceneInfoWithSceneUIDName = LR.Inst.GetSceneInfoWithSceneUIDName("suez");
			LR.Inst.LoadPlayerIntoScene(sceneInfoWithSceneUIDName);
			return true;
		};
		return Wait.PreMet;
	}

	public void PositionToLeft()
	{
		Vector3 headPosition = IC.GetHeadPosition();
		root.position = new Vector3(-0.56f, 1.01f, -0.3f);
		root.LookAt(root.position + (root.position - headPosition), Vector3.up);
	}

	public override void ShowAll()
	{
		base.ShowAll();
		UIContainer[] array = containers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].HideAll();
		}
		containerMainMenu.ShowAll();
		containerNavButtons.ShowAll();
		containerCurrMenu = containerMainMenu;
		buttonReturnArrow.IsShown = false;
		float num = 0.8f;
		Vector3 headPosition = IC.GetHeadPosition();
		Vector3 vector = IC.GetHeadRotation() * Vector3.forward;
		root.position = headPosition + vector * num;
		Vector3 upwards = IC.GetHeadRotation() * Vector3.up;
		root.rotation = Quaternion.LookRotation(vector, upwards);
	}

	public override bool HideAll()
	{
		base.HideAll();
		int num = containers.Length;
		while (--num >= 0)
		{
			containers[num].HideAll();
		}
		UIButton uIButton = buttonBigUpArrow;
		UIButton uIButton2 = buttonUpArrow;
		UIButton uIButton3 = buttonBigDownArrow;
		bool flag2 = (buttonDownArrow.IsShown = false);
		bool flag4 = (uIButton3.IsShown = flag2);
		bool flag6 = (uIButton2.IsShown = flag4);
		uIButton.IsShown = flag6;
		base.gameObject.SetActive(value: false);
		return true;
	}

	public void SetCurrentContainer(UIContainer container)
	{
		containerCurrMenu.HideAll();
		containerCurrMenu = container;
		containerCurrMenu.ShowAll();
		buttonReturnArrow.IsShown = containerCurrMenu != containerMainMenu;
	}

	private void ReturnToParentMenu()
	{
		if (containerCurrMenu == containerHagisEntry)
		{
			SetCurrentContainer(containerHagisCallStack);
		}
		else
		{
			SetCurrentContainer(containerMainMenu);
		}
	}
}
public class UIDebug_Achievements : UIContainer
{
	private UITextbox[] stats;

	private IHaglet refreshProgressRoutine;

	public override Wait OnAwakeLR()
	{
		base.OnAwakeLR();
		base.transform.localPosition = Vector3.zero;
		UIContainer container = GetContainer("UnlockStats");
		stats = container.GetComponentsInChildren<UITextbox>(includeInactive: true);
		Haglet.Create(out refreshProgressRoutine, RefreshProgressRoutine);
		GetElement<UIButton>("Refresh").OnTapUp += delegate
		{
			refreshProgressRoutine.Start(resetIfStarted: true);
			return true;
		};
		GetElement<UIButton>("Reset").OnTapUp += delegate
		{
			LR.Inst.PlatformManager.ResetAchievementProgress();
			return true;
		};
		GetElement<UIButton>("UnlockTest2Ach").OnTapUp += delegate
		{
			LR.Inst.PlatformManager.UnlockAchievement(NXAchievements.Testing2);
			return true;
		};
		return Wait.PreMet;
	}

	private IEnumerator<Routine.Yield> RefreshProgressRoutine()
	{
		LR.Inst.PlatformManager.CheckAchievementProgress();
		yield return Wait.For.Seconds(1f);
		bool[] achievementProgress = LR.Inst.PlatformManager.GetAchievementProgress();
		UITextbox[] array = stats;
		foreach (UITextbox uITextbox in array)
		{
			string text = (achievementProgress[uITextbox.transform.GetSiblingIndex()] ? "Unlocked" : "Not Unlocked");
			uITextbox.SetText(text);
		}
	}
}
public class UIDebug_Areas : UIContainer
{
	public struct DebugMenuArea
	{
		public string buttonTxt;

		public SceneInfo info;
	}

	private int scroll;

	private Action<int> scrollAction;

	private UIContainer containerAreaButtons;

	private List<DebugMenuArea> AreaInfos = new List<DebugMenuArea>();

	public override Wait OnAwakeLR()
	{
		base.OnAwakeLR();
		base.transform.localPosition = Vector3.zero;
		containerAreaButtons = GetContainer("Area Buttons");
		RefreshAreas();
		Func<UIButton, bool> value = delegate(UIButton button)
		{
			DebugMenuArea debugAreaInfo = GetDebugAreaInfo(button.textbox.TextVisible);
			LR.Inst.LoadPlayerIntoScene(debugAreaInfo.info);
			UIDebug.Inst.HideAll();
			return true;
		};
		int i = 0;
		for (int childCount = containerAreaButtons.transform.childCount; i < childCount; i++)
		{
			UIButton component = containerAreaButtons.transform.GetChild(i).GetComponent<UIButton>();
			if (component != null)
			{
				component.OnTapUp += value;
				component.userData = component;
			}
		}
		scrollAction = delegate(int dir)
		{
			scroll -= dir;
			UpdateButtons();
		};
		return Wait.PreMet;
	}

	public override void ShowAll()
	{
		base.ShowAll();
		scroll = 0;
		UIDebug.Inst.scrollAction += scrollAction;
		UpdateButtons();
	}

	public override bool HideAll()
	{
		UIDebug.Inst.scrollAction -= scrollAction;
		base.HideAll();
		base.gameObject.SetActive(value: false);
		return true;
	}

	private void RefreshAreas()
	{
		AreaInfos.Clear();
	}

	private void UpdateButtons()
	{
		RefreshAreas();
		int i = 0;
		for (int childCount = containerAreaButtons.transform.childCount; i < childCount; i++)
		{
			if (i < AreaInfos.Count)
			{
				containerAreaButtons.transform.GetChild(i).gameObject.SetActive(value: true);
				UITextbox component = containerAreaButtons.transform.GetChild(i).GetComponent<UITextbox>();
				if (component != null)
				{
					component.SetText(GetDebugAreaInfo(i).buttonTxt);
				}
			}
			else
			{
				containerAreaButtons.transform.GetChild(i).gameObject.SetActive(value: false);
			}
		}
	}

	private DebugMenuArea GetDebugAreaInfo(int listPos)
	{
		int index = (listPos + scroll).Wrap(AreaInfos.Count);
		return AreaInfos[index];
	}

	private DebugMenuArea GetDebugAreaInfo(string btnText)
	{
		for (int i = 0; i < AreaInfos.Count; i++)
		{
			if (AreaInfos[i].buttonTxt == btnText)
			{
				return AreaInfos[i];
			}
		}
		return default(DebugMenuArea);
	}
}
public class UIDebug_Debug : UIContainer
{
	protected static UIDebug_Debug _instance;

	private List<string> debugKeys = new List<string>();

	private List<string> debugValues = new List<string>();

	private HagletTrigger OnValueChangeTrigger;

	private UIContainer containerDebugLabels;

	private int scroll;

	private Action<int> scrollAction;

	private IHaglet updateRoutine;

	public static UIDebug_Debug Inst => _instance;

	public override Wait OnAwakeLR()
	{
		_instance = this;
		base.OnAwakeLR();
		base.transform.localPosition = Vector3.zero;
		containerDebugLabels = GetContainer("Debug Value Labels");
		scrollAction = delegate(int dir)
		{
			scroll -= dir;
			UpdateDebugValues();
		};
		OnValueChangeTrigger = new HagletTrigger();
		updateRoutine = Haglet.Create(out updateRoutine, UpdateRoutine);
		return Wait.PreMet;
	}

	public override void ShowAll()
	{
		base.ShowAll();
		scroll = 0;
		UIDebug.Inst.scrollAction += scrollAction;
		UpdateDebugValues();
		updateRoutine.Start();
	}

	public override bool HideAll()
	{
		UIDebug.Inst.scrollAction -= scrollAction;
		base.HideAll();
		base.gameObject.SetActive(value: false);
		if (updateRoutine != null && updateRoutine.started)
		{
			updateRoutine.Stop();
		}
		return true;
	}

	private IEnumerator<Routine.Yield> UpdateRoutine()
	{
		while (true)
		{
			yield return Wait.For.LRUpdates(1);
			UpdateDebugValues();
		}
	}

	private void UpdateDebugValues()
	{
		int i = 0;
		for (int childCount = containerDebugLabels.transform.childCount; i < childCount; i++)
		{
			if (i < debugKeys.Count)
			{
				containerDebugLabels.transform.GetChild(i).gameObject.SetActive(value: true);
				UITextbox component = containerDebugLabels.transform.GetChild(i).GetComponent<UITextbox>();
				if (component != null)
				{
					int index = (i + scroll).Wrap(debugKeys.Count);
					string text = $"{debugKeys[index]}:\t{debugValues[index]}";
					component.SetText(text);
				}
			}
			else
			{
				containerDebugLabels.transform.GetChild(i).gameObject.SetActive(value: false);
			}
		}
	}

	private int GetIndexOfKey(string key)
	{
		for (int i = 0; i < debugKeys.Count; i++)
		{
			if (key == debugKeys[i])
			{
				return i;
			}
		}
		return -1;
	}

	[Conditional("NX_DEBUG")]
	public void AddValue(string key, string value)
	{
		GetIndexOfKey(key);
		debugKeys.Add(key);
		debugValues.Add(value);
	}

	[Conditional("NX_DEBUG")]
	public void UpdateValue(string key, string value)
	{
		int indexOfKey = GetIndexOfKey(key);
		if (indexOfKey != -1)
		{
			debugValues[indexOfKey] = value;
		}
	}

	[Conditional("NX_DEBUG")]
	public void RemoveValue(string key)
	{
		int indexOfKey = GetIndexOfKey(key);
		debugKeys.RemoveAt(indexOfKey);
		debugValues.RemoveAt(indexOfKey);
	}
}
public class UIDebug_FramerateTestOptions : UIContainer
{
	private readonly string[] adjustableValues = new string[4] { "Vertical", "Horizontal", "Frames Per Test", "Positions Per Region" };

	private Dictionary<string, int> valueNamePairs = new Dictionary<string, int>();

	private Dictionary<string, UITextbox> textNamePairs = new Dictionary<string, UITextbox>();

	public override Wait OnAwakeLR()
	{
		base.OnAwakeLR();
		base.transform.localPosition = Vector3.zero;
		for (int i = 0; i < adjustableValues.Length; i++)
		{
			if (!valueNamePairs.ContainsKey(adjustableValues[i]))
			{
				valueNamePairs.Add(adjustableValues[i], 1);
			}
			if (!textNamePairs.ContainsKey(adjustableValues[i]))
			{
				textNamePairs.Add(adjustableValues[i], GetElement<UITextbox>(adjustableValues[i] + " Value"));
			}
			InitialiseButton(adjustableValues[i]);
		}
		GetElement<UIButton>("Test Current Scene").OnTapUp += delegate
		{
			MRBase owner = MainCamera.Inst.GetOwner();
			FramerateTester framerateTester = owner.GetComponentInChildren<FramerateTester>();
			if (framerateTester == null)
			{
				framerateTester = owner.gameObject.AddComponent<FramerateTester>();
			}
			framerateTester.horizontalRes = valueNamePairs["Vertical"];
			framerateTester.verticalRes = valueNamePairs["Horizontal"];
			framerateTester.testFrames = valueNamePairs["Frames Per Test"];
			framerateTester.Initialise(LR.Inst.GetTestPositions(owner, valueNamePairs["Positions Per Region"], 1.78f), valueNamePairs["Horizontal"], valueNamePairs["Vertical"], valueNamePairs["Frames Per Test"]);
			framerateTester.RunTest(MainCamera.Inst.cameraComp, 3f, owner.gameObject.scene.name);
			return true;
		};
		return Wait.PreMet;
	}

	private void InitialiseButton(string baseName)
	{
		GetElement<UIButton>(baseName + " Increment").OnTapUp += delegate
		{
			valueNamePairs[baseName]++;
			textNamePairs[baseName].SetText(valueNamePairs[baseName].ToString());
			return true;
		};
		GetElement<UIButton>(baseName + " Decrement").OnTapUp += delegate
		{
			if (valueNamePairs[baseName] - 1 == 0)
			{
				return true;
			}
			valueNamePairs[baseName]--;
			textNamePairs[baseName].SetText(valueNamePairs[baseName].ToString());
			return true;
		};
	}
}
public class UIDebug_Hagis : UIContainer
{
	private IHaglet haglet;

	private UIContainer buttonContainer;

	public override Wait OnAwakeLR()
	{
		base.OnAwakeLR();
		buttonContainer = GetContainer("Hagis Buttons");
		base.transform.localPosition = Vector3.zero;
		return Wait.PreMet;
	}

	public void SetEntry(IHaglet haglet)
	{
		this.haglet = haglet;
	}

	public override void ShowAll()
	{
		base.ShowAll();
		UpdateLabels();
		UpdateButtons();
	}

	private void UpdateLabels()
	{
		GetElement<UITextbox>("File").SetText("Not Available");
		GetElement<UITextbox>("State").SetText("Not Available");
	}

	private void UpdateButtons()
	{
		buttonContainer.GetElement<UIButton>("Stop").OnTapUp += delegate
		{
			haglet.Stop();
			UpdateLabels();
			return true;
		};
		buttonContainer.GetElement<UIButton>("Complete").OnTapUp += delegate
		{
			haglet.Stop(complete: true);
			UpdateLabels();
			return true;
		};
		buttonContainer.GetElement<UIButton>("Reset").OnTapUp += delegate
		{
			haglet.Reset();
			UpdateLabels();
			return true;
		};
		buttonContainer.GetElement<UIButton>("Resume").OnTapUp += delegate
		{
			haglet.Resume();
			UpdateLabels();
			return true;
		};
		buttonContainer.GetElement<UIButton>("Pause").OnTapUp += delegate
		{
			haglet.Pause();
			UpdateLabels();
			return true;
		};
	}
}
public class UIDebug_HagisCallStack : UIContainer
{
	private struct HagisEntry
	{
		public string name;

		public IHaglet haglet;
	}

	private UIContainer hagisButtonContainer;

	private UIContainer skipButtonContainer;

	private UIDebug_Hagis hagisMenu;

	private ConstArray<HagisEntry> entryArray = new ConstArray<HagisEntry>(32u);

	private int scroll;

	private Action<int> scrollAction;

	public override Wait OnAwakeLR()
	{
		base.OnAwakeLR();
		hagisMenu = (UIDebug_Hagis)UIDebug.Inst.GetContainer("Hagis Entry Menu");
		base.transform.localPosition = Vector3.zero;
		hagisButtonContainer = GetContainer("Hagis Buttons");
		skipButtonContainer = GetContainer("Skip Buttons");
		scrollAction = delegate(int dir)
		{
			scroll -= dir;
			UpdateButtons();
		};
		return Wait.PreMet;
	}

	public override void ShowAll()
	{
		base.ShowAll();
		scroll = 0;
		UIDebug.Inst.scrollAction += scrollAction;
		UpdateButtons();
	}

	public override bool HideAll()
	{
		UIDebug.Inst.scrollAction -= scrollAction;
		base.HideAll();
		base.gameObject.SetActive(value: false);
		return true;
	}

	private void RefreshCallStack()
	{
		Haglet.allTopLevel.GetEnumerator();
		entryArray.Clear();
	}

	private void UpdateButtons()
	{
		RefreshCallStack();
		for (int i = 0; i < hagisButtonContainer.transform.childCount; i++)
		{
			GameObject gameObject = hagisButtonContainer.transform.GetChild(i).gameObject;
			GameObject gameObject2 = skipButtonContainer.transform.GetChild(i).gameObject;
			if (i >= entryArray.Length)
			{
				gameObject.SetActive(value: false);
				gameObject2.SetActive(value: false);
				continue;
			}
			gameObject.SetActive(value: true);
			gameObject2.SetActive(value: true);
			int key = (i + scroll).Wrap(entryArray.sLength);
			HagisEntry hagisEntry = entryArray[key];
			gameObject.GetComponent<UITextbox>().SetText(hagisEntry.name);
			SetButtonFunction(gameObject.GetComponent<UIButton>(), gameObject2.GetComponent<UIButton>(), hagisEntry.haglet);
		}
	}

	private void SetButtonFunction(UIButton hagisButton, UIButton skipButton, IHaglet targetHaglet)
	{
		hagisButton.ClearTapUp();
		hagisButton.OnTapUp += delegate
		{
			hagisMenu.SetEntry(targetHaglet);
			UIDebug.Inst.SetCurrentContainer(hagisMenu);
			return true;
		};
		skipButton.ClearTapUp();
		skipButton.OnTapUp += delegate
		{
			targetHaglet.Skip();
			UpdateButtons();
			return true;
		};
	}
}
public class UIDebug_Misc : UIContainer
{
	private int clockLevelGPU;

	private int clockLevelCPU;

	public override Wait OnAwakeLR()
	{
		base.OnAwakeLR();
		base.transform.localPosition = Vector3.zero;
		GetElement<UIButton>("ToggleICLock").OnTapUp += delegate
		{
			UIDebug.Inst.LockecToIC = !UIDebug.Inst.LockecToIC;
			GetElement<UITextbox>("UILockState").SetText(UIDebug.Inst.LockecToIC ? "Locked" : "Unlocked");
			return true;
		};
		UpdateCameraMode();
		GetElement<UIButton>("CameraMode").OnTapUp += delegate
		{
			BaseSettings<TeleportSettings>.Inst.InputMode = BaseSettings<TeleportSettings>.Inst.InputMode.Next();
			UpdateCameraMode();
			return true;
		};
		UpdateMovementSpeed();
		GetElement<UIButton>("MovementSpeed").OnTapUp += delegate
		{
			LR.Inst.saveDataSettings.freeMoveSpeed = LR.Inst.saveDataSettings.freeMoveSpeed.Next();
			LR.Inst.Save();
			UpdateMovementSpeed();
			return true;
		};
		UpdateFoveatedRendering();
		GetElement<UIButton>("FoveatedRendering").OnTapUp += delegate
		{
			LR.SetMultiResLevel(OVRPlugin.tiledMultiResLevel.Next());
			UpdateFoveatedRendering();
			return true;
		};
		UpdateTimescale();
		GetElement<UIButton>("Timescale").OnTapUp += delegate
		{
			float timeScale = Time.timeScale;
			timeScale = ((timeScale != 1f) ? 1f : 10f);
			Time.timeScale = timeScale;
			UpdateTimescale();
			return true;
		};
		GetElement<UIButton>("TriggerTransition").OnTapUp += delegate(UIButton button)
		{
			NexusRenderPipeline.Inst.cfg.portalCamerasUseOcclusionCulling = !NexusRenderPipeline.Inst.cfg.portalCamerasUseOcclusionCulling;
			button.textbox.SetText("OcclusionCull: " + NexusRenderPipeline.Inst.cfg.portalCamerasUseOcclusionCulling);
			return true;
		};
		GetElement<UIButton>("ClearInventory").OnTapUp += delegate
		{
			ClearInventory();
			return true;
		};
		GetElement<UIButton>("UnlockMansfield").OnTapUp += delegate
		{
			LeverController componentInChildren = MainCamera.Inst.GetOwner().GetComponentInChildren<LeverController>();
			if ((bool)componentInChildren)
			{
				componentInChildren.DebugUnlockMansfieldPortals();
			}
			return true;
		};
		GetElement<UIButton>("Debug Shading").OnTapUp += delegate(UIButton button)
		{
			if (NexusRenderPipeline.Inst.cfg.debugShading == NexusRenderSettings.DebugShadingMode.Flat)
			{
				NexusRenderPipeline.Inst.cfg.debugShading = NexusRenderSettings.DebugShadingMode.Unlit;
			}
			else if (NexusRenderPipeline.Inst.cfg.debugShading == NexusRenderSettings.DebugShadingMode.Unlit)
			{
				NexusRenderPipeline.Inst.cfg.debugShading = NexusRenderSettings.DebugShadingMode.None;
			}
			else
			{
				NexusRenderPipeline.Inst.cfg.debugShading = NexusRenderSettings.DebugShadingMode.Flat;
			}
			button.textbox.SetText("R: DebugShading: " + NexusRenderPipeline.Inst.cfg.debugShading);
			return true;
		};
		GetElement<UIButton>("Opaque Pass").OnTapUp += delegate(UIButton button)
		{
			NexusRenderPipeline.Inst.cfg.passToggleOpaque = NexusRenderPipeline.Inst.cfg.passToggleOpaque.Next();
			button.textbox.SetText("R: OpaquePass: " + NexusRenderPipeline.Inst.cfg.passToggleOpaque);
			return true;
		};
		GetElement<UIButton>("Transparent Pass").OnTapUp += delegate(UIButton button)
		{
			NexusRenderPipeline.Inst.cfg.passToggleTransparent = NexusRenderPipeline.Inst.cfg.passToggleTransparent.Next();
			NexusRenderPipeline.Inst.cfg.disableTransparentPassTimer = 10f;
			button.textbox.SetText("R: TransparentPass: " + NexusRenderPipeline.Inst.cfg.passToggleTransparent);
			return true;
		};
		GetElement<UIButton>("Overlay Pass").OnTapUp += delegate(UIButton button)
		{
			NexusRenderPipeline.Inst.cfg.disableOverlayPass = !NexusRenderPipeline.Inst.cfg.disableOverlayPass;
			button.textbox.SetText("R: OverlayPass: " + !NexusRenderPipeline.Inst.cfg.disableOverlayPass);
			return true;
		};
		GetElement<UIButton>("ShadowMap Pass").OnTapUp += delegate(UIButton button)
		{
			NexusRenderPipeline.Inst.cfg.disableShadowMapping = !NexusRenderPipeline.Inst.cfg.disableShadowMapping;
			button.textbox.SetText("R: ShadowMapPass: " + !NexusRenderPipeline.Inst.cfg.disableShadowMapping);
			return true;
		};
		GetElement<UIButton>("Skybox Pass").OnTapUp += delegate(UIButton button)
		{
			NexusRenderPipeline.Inst.cfg.disableSkybox = !NexusRenderPipeline.Inst.cfg.disableSkybox;
			button.textbox.SetText("R: SkyboxPass: " + !NexusRenderPipeline.Inst.cfg.disableSkybox);
			return true;
		};
		GetElement<UIButton>("DisableShaderShadows").OnTapUp += delegate(UIButton button)
		{
			NexusRenderPipeline.Inst.cfg.debugNoShadows = !NexusRenderPipeline.Inst.cfg.debugNoShadows;
			button.textbox.SetText("R: DisableShaderShadows: " + NexusRenderPipeline.Inst.cfg.debugNoShadows);
			return true;
		};
		GetElement<UIButton>("DisableShaderLighting").OnTapUp += delegate(UIButton button)
		{
			NexusRenderPipeline.Inst.cfg.debugNoLighting = !NexusRenderPipeline.Inst.cfg.debugNoLighting;
			button.textbox.SetText("R: DisableShaderLighting: " + NexusRenderPipeline.Inst.cfg.debugNoLighting);
			return true;
		};
		GetElement<UIButton>("ViewportScale").OnTapUp += delegate(UIButton button)
		{
			if (XRSettings.renderViewportScale == 1f)
			{
				XRSettings.renderViewportScale = 0.5f;
			}
			else if (XRSettings.renderViewportScale == 0.5f)
			{
				XRSettings.renderViewportScale = 0.25f;
			}
			else
			{
				XRSettings.renderViewportScale = 1f;
			}
			button.textbox.SetText("R: ViewportScale: " + XRSettings.renderViewportScale);
			return true;
		};
		GetElement<UIButton>("ShadowMapScale").OnTapUp += delegate(UIButton button)
		{
			if (NexusRenderPipeline.Inst.cfg.shadowMapScale == 1f)
			{
				NexusRenderPipeline.Inst.cfg.shadowMapScale = 0.5f;
			}
			else if (NexusRenderPipeline.Inst.cfg.shadowMapScale == 0.5f)
			{
				NexusRenderPipeline.Inst.cfg.shadowMapScale = 0.25f;
			}
			else
			{
				NexusRenderPipeline.Inst.cfg.shadowMapScale = 1f;
			}
			button.textbox.SetText("R: ShadowMapScale: " + NexusRenderPipeline.Inst.cfg.shadowMapScale);
			return true;
		};
		clockLevelCPU = OVRManager.cpuLevel;
		clockLevelGPU = OVRManager.gpuLevel;
		UIButton element = GetElement<UIButton>("GPUClock");
		element.OnTapUp += delegate(UIButton button)
		{
			clockLevelGPU++;
			if (clockLevelGPU > 5)
			{
				clockLevelGPU = 0;
			}
			button.textbox.SetText("GPUClock: " + clockLevelGPU);
			LR.SetClockLevels(clockLevelCPU, clockLevelGPU);
			return true;
		};
		UIButton element2 = GetElement<UIButton>("CPUClock");
		element2.OnTapUp += delegate(UIButton button)
		{
			clockLevelCPU++;
			if (clockLevelCPU > 5)
			{
				clockLevelCPU = 0;
			}
			button.textbox.SetText("CPUClock: " + clockLevelCPU);
			LR.SetClockLevels(clockLevelCPU, clockLevelGPU);
			return true;
		};
		element.textbox.SetText("GPUClock: " + clockLevelGPU);
		element2.textbox.SetText("CPUClock: " + clockLevelCPU);
		UIButton langTextEntryButton = GetElement<UIButton>("LanguageEntry Text");
		langTextEntryButton.OnTapUp += delegate
		{
			int num4 = (int)(Localisation.Inst.CurrentLanguage + 1) % 6;
			Localisation.Inst.ChangeLanguage((Localisation.Language)num4);
			UITextbox textbox4 = langTextEntryButton.textbox;
			Localisation.Language language4 = (Localisation.Language)num4;
			textbox4.SetText(language4.ToString());
			return true;
		};
		GetElement<UIButton>("Language Text").OnTapUp += delegate
		{
			int num3 = (int)(Localisation.Inst.CurrentLanguage + 1) % 6;
			Localisation.Inst.ChangeLanguage((Localisation.Language)num3);
			UITextbox textbox3 = langTextEntryButton.textbox;
			Localisation.Language language3 = (Localisation.Language)num3;
			textbox3.SetText(language3.ToString());
			return true;
		};
		UIButton langVOEntryButton = GetElement<UIButton>("LanguageEntry VO");
		langVOEntryButton.OnTapUp += delegate
		{
			int num2 = (int)(VOC.Inst.voLanguage + 1) % 6;
			VOC.Inst.voLanguage = (Localisation.Language)num2;
			PlayerPrefs.SetInt("LanguageVO", num2);
			UITextbox textbox2 = langVOEntryButton.textbox;
			Localisation.Language language2 = (Localisation.Language)num2;
			textbox2.SetText(language2.ToString());
			return true;
		};
		GetElement<UIButton>("Language VO").OnTapUp += delegate
		{
			int num = (int)(VOC.Inst.voLanguage + 1) % 6;
			VOC.Inst.voLanguage = (Localisation.Language)num;
			PlayerPrefs.SetInt("LanguageVO", num);
			UITextbox textbox = langVOEntryButton.textbox;
			Localisation.Language language = (Localisation.Language)num;
			textbox.SetText(language.ToString());
			return true;
		};
		return Wait.PreMet;
	}

	private void UpdateCameraMode()
	{
		GetElement<UITextbox>("CameraModeState").SetText(BaseSettings<TeleportSettings>.Inst.InputMode.ToString());
	}

	private void UpdateFoveatedRendering()
	{
		GetElement<UITextbox>("FoveatedRenderingValue").SetText(OVRPlugin.tiledMultiResLevel.ToString());
	}

	private void UpdateMovementSpeed()
	{
		GetElement<UITextbox>("MovementSpeedValue").SetText(LR.Inst.saveDataSettings.freeMoveSpeed.ToString());
	}

	private void UpdateTimescale()
	{
		GetElement<UITextbox>("TimescaleValue").SetText(Time.timeScale.ToString());
	}

	private void UpdateWorld()
	{
		UITextbox element = GetElement<UITextbox>("CurrentWorld");
		bool flag = element.TextMesh.text == "Real";
		CC inst = CC.Inst;
		inst.handL.TriggerTransition(flag);
		inst.handR.TriggerTransition(flag);
		PlayerInventory.Inst.TriggerTransition(flag);
		element.SetText(flag ? "Fantasy" : "Real");
	}

	private void ClearInventory()
	{
		PlayerInventory.Inst.EmptyInventory(fromSaveData: true);
	}

	public override void ShowAll()
	{
		base.ShowAll();
		GetElement<UIButton>("LanguageEntry Text").textbox.SetText(Localisation.Inst.CurrentLanguage.ToString());
		GetElement<UIButton>("LanguageEntry VO").textbox.SetText(VOC.Inst.voLanguage.ToString());
	}
}
public class UIDebug_Recording : UIContainer
{
	private UIContainer listContainer;

	private FileInfo[] recordingFiles;

	private int scroll;

	private Action<int> scrollAction;

	private UIButton recordBtn;

	public override Wait OnAwakeLR()
	{
		base.OnAwakeLR();
		listContainer = GetContainer("Recording Names");
		base.transform.localPosition = Vector3.zero;
		scrollAction = delegate(int dir)
		{
			scroll -= dir;
			UpdateButtons();
		};
		recordBtn = GetElement<UIButton>("Recording");
		recordBtn.ClearTapUp();
		recordBtn.OnTapUp += delegate
		{
			UIDebug.Inst.IsShown = false;
			Crosshair.Inst.CrosshairDisplayMode = Crosshair.CrosshairMode.Off;
			if (!IC.IsReplaying)
			{
				if (IC.IsRecording)
				{
					IC.RecordingStop();
				}
				else
				{
					IC.RecordingStart();
				}
			}
			return true;
		};
		UIButton element = GetElement<UIButton>("Open Folder");
		element.ClearTapUp();
		element.OnTapUp += delegate
		{
			IC.OpenRecordingsFolder();
			return true;
		};
		return Wait.PreMet;
	}

	public override void ShowAll()
	{
		base.ShowAll();
		scroll = 0;
		UIDebug.Inst.scrollAction += scrollAction;
		recordBtn.textbox.SetText(IC.IsRecording ? "Stop Recording" : (IC.IsReplaying ? "Tadaaaaaaa!" : "Start Recording"));
		UpdateButtons();
	}

	public override bool HideAll()
	{
		UIDebug.Inst.scrollAction -= scrollAction;
		base.HideAll();
		base.gameObject.SetActive(value: false);
		return true;
	}

	private void RefreshFileList()
	{
		DirectoryInfo directoryInfo = new DirectoryInfo(IC.RecordingPath);
		recordingFiles = (directoryInfo.Exists ? directoryInfo.GetFiles("*.bin", SearchOption.AllDirectories) : new FileInfo[0]);
		Array.Sort(recordingFiles, (FileInfo a, FileInfo b) => a.LastWriteTimeUtc.CompareTo(b.LastWriteTimeUtc));
	}

	private void UpdateButtons()
	{
		RefreshFileList();
		for (int i = 0; i < listContainer.transform.childCount; i++)
		{
			GameObject gameObject = listContainer.transform.GetChild(i).gameObject;
			if (i >= recordingFiles.Length)
			{
				gameObject.SetActive(value: false);
				continue;
			}
			int index = (i + scroll).Wrap(recordingFiles.Length);
			gameObject.SetActive(value: true);
			string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(recordingFiles[index].Name);
			UITextbox component = gameObject.GetComponent<UITextbox>();
			UIButton component2 = gameObject.GetComponent<UIButton>();
			component.SetText(fileNameWithoutExtension);
			component2.ClearTapUp();
			component2.OnTapUp += delegate
			{
				UIDebug.Inst.IsShown = false;
				Crosshair.Inst.CrosshairDisplayMode = Crosshair.CrosshairMode.Off;
				IC.Replay(recordingFiles[index].FullName);
				return true;
			};
		}
	}
}
public class UIDebug_Vignette_Settings : UIContainer
{
	public override Wait OnAwakeLR()
	{
		base.OnAwakeLR();
		base.transform.localPosition = Vector3.zero;
		UpdateVignetteSettings();
		GetElement<UIButton>("Force Show").OnTapUp += delegate
		{
			BaseSettings<TeleportSettings>.Inst.vignetteForceShow = !BaseSettings<TeleportSettings>.Inst.vignetteForceShow;
			UpdateVignetteSettings();
			return true;
		};
		GetElement<UIButton>("Strength").OnTapUp += delegate
		{
			TeleportSettings.VignettePreset vignetteSettings4 = BaseSettings<TeleportSettings>.Inst.VignetteSettings;
			vignetteSettings4.vignetteStrength += 0.1f;
			if (vignetteSettings4.vignetteStrength > 2f)
			{
				vignetteSettings4.vignetteStrength = 0.5f;
			}
			UpdateVignetteSettings();
			return true;
		};
		GetElement<UIButton>("Radius").OnTapUp += delegate
		{
			TeleportSettings.VignettePreset vignetteSettings3 = BaseSettings<TeleportSettings>.Inst.VignetteSettings;
			vignetteSettings3.vignetteRadius += 0.1f;
			if (vignetteSettings3.vignetteRadius > 1f)
			{
				vignetteSettings3.vignetteRadius = 0.3f;
			}
			UpdateVignetteSettings();
			return true;
		};
		GetElement<UIButton>("Smoothness").OnTapUp += delegate
		{
			TeleportSettings.VignettePreset vignetteSettings2 = BaseSettings<TeleportSettings>.Inst.VignetteSettings;
			vignetteSettings2.vignetteSoftness += 0.1f;
			if (vignetteSettings2.vignetteSoftness > 1f)
			{
				vignetteSettings2.vignetteSoftness = 0.2f;
			}
			UpdateVignetteSettings();
			return true;
		};
		GetElement<UIButton>("Fade Time").OnTapUp += delegate
		{
			TeleportSettings.VignettePreset vignetteSettings = BaseSettings<TeleportSettings>.Inst.VignetteSettings;
			vignetteSettings.vignetteFadeTime += 0.1f;
			if (vignetteSettings.vignetteFadeTime > 1f)
			{
				vignetteSettings.vignetteFadeTime = 0f;
			}
			UpdateVignetteSettings();
			return true;
		};
		return Wait.PreMet;
	}

	private void UpdateVignetteSettings()
	{
		TeleportSettings.VignettePreset vignetteSettings = BaseSettings<TeleportSettings>.Inst.VignetteSettings;
		GetElement<UITextbox>("Force Show Value").SetText(BaseSettings<TeleportSettings>.Inst.vignetteForceShow ? "True" : "False");
		GetElement<UITextbox>("Strength Value").SetText(vignetteSettings.vignetteStrength.ToString());
		GetElement<UITextbox>("Radius Value").SetText(vignetteSettings.vignetteRadius.ToString());
		GetElement<UITextbox>("Smoothness Value").SetText(vignetteSettings.vignetteSoftness.ToString());
		GetElement<UITextbox>("Fade Time Value").SetText(vignetteSettings.vignetteFadeTime.ToString());
	}
}
public class UIErrorPrompt : UIContainer, IPrebuildEvent
{
	public enum ErrorType
	{
		ControllerDisconnect,
		HeadsetDisconnect,
		MAX
	}

	public static UIErrorPrompt Inst;

	[HideInInspector]
	public ErrorType CurrentErrorType;

	private UITextbox errorMessage;

	private bool prePaused;

	public MeshRenderer textRend;

	public MeshRenderer bgRend;

	[NonSerialized]
	[HideInInspector]
	public bool CurrentError;

	private Transform currentCameraTs;

	private bool currLoadingMode = true;

	void IPrebuildEvent.OnPrebuildRoot(bool isPrefab)
	{
		textRend.enabled = false;
		bgRend.enabled = false;
	}

	public override void Initialise()
	{
		base.Initialise();
		Inst = this;
		errorMessage = GetElement<UITextbox>("Text");
		base.gameObject.SetActive(value: false);
		textRend.material.SetInt("_ZTEST", 8);
		bgRend.material.SetInt("_ZTEST", 8);
		textRend.enabled = true;
		bgRend.enabled = true;
	}

	public void UpdateCamera(Transform newCamTs, bool loadingMode)
	{
		currentCameraTs = newCamTs;
		currLoadingMode = loadingMode;
	}

	public void UpdateError()
	{
		float t = Time.unscaledDeltaTime * BaseSettings<UISettings>.Inst.errorMessageLerp;
		Vector3 b = currentCameraTs.position + currentCameraTs.forward * BaseSettings<UISettings>.Inst.errorMessageDist;
		Quaternion rotation = currentCameraTs.rotation;
		base.transform.position = Vector3.Lerp(base.transform.position, b, t);
		base.transform.rotation = Quaternion.Lerp(base.transform.rotation, rotation, t);
		SetErrorMessage();
	}

	public void ShowErrorMessage()
	{
		CurrentError = true;
		base.gameObject.SetActive(value: true);
		base.transform.position = currentCameraTs.position + currentCameraTs.forward * BaseSettings<UISettings>.Inst.errorMessageDist;
		base.transform.rotation = currentCameraTs.rotation;
		CurrentErrorType = ((!IC.Inst.HeadsetIsActive()) ? ErrorType.HeadsetDisconnect : ErrorType.ControllerDisconnect);
		IC.Inst.InputIntercept = true;
		SetErrorMessage(checkOnly: false);
		if (!currLoadingMode)
		{
			prePaused = LR.Inst.IsPaused;
			if (!prePaused)
			{
				LR.Inst.Pause(paused: true);
			}
		}
		if (LR.Inst.allowUpdates)
		{
			NexusFullScreenPass.Inst.errorOverride = 0.8f;
		}
	}

	public void SetErrorMessage(bool checkOnly = true)
	{
		if (CurrentErrorType == ErrorType.ControllerDisconnect && !IC.Inst.HeadsetIsActive())
		{
			CurrentErrorType = ErrorType.HeadsetDisconnect;
		}
		else if (CurrentErrorType == ErrorType.HeadsetDisconnect && IC.Inst.HeadsetIsActive() && !IC.Inst.ControllersAreActive())
		{
			CurrentErrorType = ErrorType.ControllerDisconnect;
		}
		else if (checkOnly)
		{
			return;
		}
		string text = "";
		if (LR.GetPlatform() == LR.NexusPlatform.RIFT)
		{
			switch (CurrentErrorType)
			{
			case ErrorType.ControllerDisconnect:
				text = Localisation.Retrieve(currLoadingMode ? "NEXUS_compliance_text_005" : "NEXUS_compliance_text_007");
				break;
			case ErrorType.HeadsetDisconnect:
				text = Localisation.Retrieve(currLoadingMode ? "NEXUS_compliance_text_001" : "NEXUS_compliance_text_002");
				break;
			}
		}
		else
		{
			switch (CurrentErrorType)
			{
			case ErrorType.ControllerDisconnect:
				text = Localisation.Retrieve(currLoadingMode ? "NEXUS_compliance_text_006" : "NEXUS_compliance_text_008");
				break;
			case ErrorType.HeadsetDisconnect:
				text = Localisation.Retrieve(currLoadingMode ? "NEXUS_compliance_text_002" : "NEXUS_compliance_text_002");
				break;
			}
		}
		errorMessage.SetText(text);
		errorMessage.Present();
	}

	public void DismissErrorMessage()
	{
		if (LR.Inst.allowUpdates)
		{
			NexusFullScreenPass.Inst.errorOverride = 0f;
		}
		if (!currLoadingMode && !prePaused)
		{
			LR.Inst.Pause(paused: false);
		}
		IC.Inst.InputIntercept = false;
		CurrentError = false;
		base.gameObject.SetActive(value: false);
	}

	public void DrawError(CommandBuffer buffer)
	{
		buffer.DrawRenderer(bgRend, bgRend.sharedMaterial);
		buffer.DrawRenderer(textRend, textRend.sharedMaterial);
	}
}
[Serializable]
public class UIInfoPage : UIBookPage
{
	private UIButton backButton;

	private UIButton continueButton;

	private UIButton returnButton;

	public bool platformSpecific;

	[ConditionalHide("platformSpecific")]
	public bool questSpecific;

	public event Action ContinueAction;

	public event Action BackAction;

	public override void OnAwakeLR()
	{
		if ((bool)PageLeft)
		{
			backButton = PageLeft.TryGetElement<UIButton>("Back");
			if ((bool)backButton)
			{
				backButton.OnTapUp += delegate
				{
					this.BackAction();
					return true;
				};
			}
			returnButton = PageLeft.GetElement<UIButton>("Return");
			if ((bool)returnButton)
			{
				returnButton.OnTapUp += delegate
				{
					UIPauseMenu.Inst.CloseBook();
					return true;
				};
			}
		}
		if (!PageRight)
		{
			return;
		}
		continueButton = PageRight.TryGetElement<UIButton>("Continue");
		if ((bool)continueButton)
		{
			continueButton.OnTapUp += delegate
			{
				this.ContinueAction();
				return true;
			};
		}
	}

	public override bool ReturnMenu()
	{
		UIPauseMenu.Inst.CloseBook();
		return true;
	}
}
public struct UIPauseMenuShowOptions
{
	public bool forceFrontFacing;

	public bool disableFade;

	public bool disableParticles;
}
public struct MenuPos
{
	public Vector3 pos;

	public Quaternion rot;
}
public class UIPauseMenu : UIContainer
{
	private enum OpenBookPage
	{
		Options,
		HowToPlay,
		Confirm,
		Helper
	}

	public static UIPauseMenu Inst;

	public float fadeTime = 0.2f;

	private ManualAnimation manAnim;

	private static readonly string CH_BookUI_DefaultEnter = "CH_BookUI_DefaultEnter";

	private static readonly string CH_BookUI_DefaultExit = "CH_BookUI_DefaultExit";

	private static readonly string CH_BookUI_TransClosedToOpen = "CH_BookUI_TransClosedToOpen";

	private static readonly string CH_BookUI_TransOpenToClosed = "CH_BookUI_TransOpenToClosed";

	private SkinnedMeshRenderer coverSMR;

	private UIContainer startMenu;

	private UIButton hideMenuButton;

	private UIButton hideMenuFakeButton;

	private UIButton teleportButton;

	private UIButton mainMenuButton;

	private UIButton quitButton;

	private UIButton optionsButton;

	private UIButton howToPlayButton;

	private bool isOpen;

	public UIPauseMenu_Options options;

	public UIPauseMenu_HeightAdjust heightAdjust;

	public UIPauseMenu_MovementOptions movementOptions;

	public UIPauseMenu_GameOptions gameOptions;

	public UIPauseMenu_Confirmation confirmPrompt;

	public UIPauseMenu_Helper helper;

	public UIInfoPage[] infoPages;

	[Space]
	public FMODEventAsset soundMenuPage;

	public FMODEventAsset soundMenuSelect;

	public FMODEventAsset soundMenuClose;

	public FMODEventAsset soundMenuOpen;

	public FMODEventAsset soundMenuAppear;

	public FMODEventAsset soundMenuDisappear;

	[Space]
	public Transform[] transformMenuPosThree = new Transform[3];

	public Transform[] transformMenuPosTwo = new Transform[2];

	public IDObjectRef stationResumeEntryPoint;

	private ParticleSystem pageParticles;

	private UIBookPage currentPage;

	private int pageIndex = -1;

	private SceneInfo targetScene;

	[NonSerialized]
	public SceneInfo.MenuType currentMenuType = SceneInfo.MenuType.Chapter;

	[HideInInspector]
	public bool requiresFullScreenFade;

	public IHaglet onAwakeLRRoutine;

	private bool isRepositioning;

	private IHaglet<UIBookPage, int, bool> setCurrentPageRoutine;

	private IHaglet<bool, UIPauseMenuShowOptions> showAllRoutine;

	public IHaglet closeGameRoutine;

	public IHaglet hideAllRoutine;

	private IHaglet<OpenBookPage, UIPauseMenu_Confirmation.ConfirmType> openBookRoutine;

	private IHaglet<bool> closeBookRoutine;

	private IHaglet bookRegionTracking;

	private IHaglet fadeAndMoveRoutine;

	public override Wait OnAwakeLR()
	{
		Haglet.Create(out onAwakeLRRoutine, OnAwakeLRRoutine);
		return base.OnAwakeLR() & onAwakeLRRoutine.Start();
	}

	private IEnumerator<Routine.Yield> OnAwakeLRRoutine()
	{
		Inst = this;
		int num = containers.Length;
		while (--num >= 0)
		{
			containers[num].allowShowHideCommands = false;
		}
		int num2 = elements.Length;
		while (--num2 >= 0)
		{
			elements[num2].allowShowHideCommands = false;
		}
		pageParticles = GetComponentInChildren<ParticleSystem>();
		manAnim = GetElement<UIElement>("CH_BookUI").GetComponent<ManualAnimation>();
		manAnim.Initalise();
		coverSMR = base.transform.FindDeepChild("Ref_SM_MansfieldsJournal_Cover").GetComponent<SkinnedMeshRenderer>();
		Haglet.Create(out openBookRoutine, (Routine.Func2<OpenBookPage, UIPauseMenu_Confirmation.ConfirmType>)OpenBookRoutine, (string)null, startNow: false, (int?)null, (string)null);
		yield return Wait.For.Updates(1);
		Haglet.Create(out closeBookRoutine, (Routine.Func1<bool>)CloseBookRoutine, (string)null, startNow: false, (int?)null, (string)null);
		yield return Wait.For.Updates(1);
		Haglet.Create(out bookRegionTracking, BookRegionTracking);
		yield return Wait.For.Updates(1);
		Haglet.Create(out setCurrentPageRoutine, (Routine.Func3<UIBookPage, int, bool>)SetCurrentPageRoutine, (string)null, startNow: false, (int?)null, (string)null);
		yield return Wait.For.Updates(1);
		Haglet.Create(out showAllRoutine, (Routine.Func2<bool, UIPauseMenuShowOptions>)ShowAllRoutine, (string)null, startNow: false, (int?)null, (string)null);
		yield return Wait.For.Updates(1);
		Haglet.Create(out hideAllRoutine, HideAllRoutine);
		yield return Wait.For.Updates(1);
		Haglet.Create(out fadeAndMoveRoutine, FadeAndMoveRoutine);
		yield return Wait.For.Updates(1);
		Haglet.Create(out closeGameRoutine, CloseGameRoutine);
		yield return Wait.For.Updates(1);
		startMenu = GetContainer("Start Menu");
		teleportButton = startMenu.GetElement<UIButton>("Teleport");
		teleportButton.OnTapUp += delegate
		{
			if (currentMenuType == SceneInfo.MenuType.Main)
			{
				TeleportBehaviour();
			}
			else
			{
				UIPauseMenu_Confirmation.ConfirmType arg = UIPauseMenu_Confirmation.ConfirmType.MAX;
				switch (currentMenuType)
				{
				case SceneInfo.MenuType.Tutorial:
					arg = UIPauseMenu_Confirmation.ConfirmType.skip;
					break;
				case SceneInfo.MenuType.Chapter:
					arg = UIPauseMenu_Confirmation.ConfirmType.hub;
					break;
				case SceneInfo.MenuType.Hub:
					arg = UIPauseMenu_Confirmation.ConfirmType.tutorial;
					break;
				}
				VOC.Inst.VOStop();
				STC.Inst.ClearQueueAndStop();
				openBookRoutine.Start(OpenBookPage.Confirm, arg);
			}
			return true;
		};
		yield return Wait.For.Updates(1);
		mainMenuButton = startMenu.GetElement<UIButton>("TeleportAlt");
		mainMenuButton.OnTapUp += delegate
		{
			openBookRoutine.Start(OpenBookPage.Confirm, UIPauseMenu_Confirmation.ConfirmType.mainMenu);
			return true;
		};
		hideMenuButton = startMenu.GetElement<UIButton>("HideMenu");
		hideMenuButton.OnTapUp += delegate
		{
			if (currentMenuType == SceneInfo.MenuType.Main)
			{
				openBookRoutine.Start(OpenBookPage.Confirm, UIPauseMenu_Confirmation.ConfirmType.newGame);
				return true;
			}
			if (currentMenuType == SceneInfo.MenuType.MainLimited)
			{
				openBookRoutine.Start(OpenBookPage.Helper);
				return true;
			}
			if (currentMenuType == SceneInfo.MenuType.MainTutorial)
			{
				helper.firstShown = true;
			}
			LR.Inst.Pause(paused: false);
			HideBook();
			return true;
		};
		hideMenuFakeButton = startMenu.GetElement<UIButton>("HideMenuFake");
		hideMenuFakeButton.OnTapUp += delegate
		{
			helper.firstShown = true;
			LR.Inst.Pause(paused: false);
			HideBook();
			return true;
		};
		quitButton = startMenu.GetElement<UIButton>("Quit");
		quitButton.OnTapUp += delegate
		{
			openBookRoutine.Start(OpenBookPage.Confirm, UIPauseMenu_Confirmation.ConfirmType.quit);
			return true;
		};
		optionsButton = startMenu.GetElement<UIButton>("Options");
		optionsButton.OnTapUp += delegate
		{
			openBookRoutine.Start();
			return true;
		};
		howToPlayButton = startMenu.GetElement<UIButton>("How To Play");
		howToPlayButton.OnTapUp += delegate
		{
			openBookRoutine.Start(OpenBookPage.HowToPlay);
			return true;
		};
		yield return Wait.For.Updates(1);
		options.OnAwakeLR();
		yield return Wait.For.Updates(1);
		heightAdjust.OnAwakeLR();
		yield return Wait.For.Updates(1);
		movementOptions.OnAwakeLR();
		yield return Wait.For.Updates(1);
		gameOptions.OnAwakeLR();
		yield return Wait.For.Updates(1);
		confirmPrompt.OnAwakeLR();
		yield return Wait.For.Updates(1);
		helper.OnAwakeLR();
		yield return Wait.For.Updates(1);
		for (int i = 0; i < infoPages.Length; i++)
		{
			infoPages[i].OnAwakeLR();
			yield return Wait.For.Updates(1);
			infoPages[i].BackAction += Back;
			infoPages[i].ContinueAction += Continue;
		}
	}

	public void OnRealtimeUpdateLR()
	{
		if (base.IsShown)
		{
			MenuPos menuPos = CalculateTargetPositionAndRotation(default(UIPauseMenuShowOptions));
			Vector3 position = base.transform.InverseTransformPoint(menuPos.pos);
			float num = Mathf.Abs(position.y);
			if (num > BaseSettings<UISettings>.Inst.pauseMenuRepositionDistance)
			{
				isRepositioning = true;
			}
			else if (num < 0.01f)
			{
				isRepositioning = false;
			}
			if (isRepositioning)
			{
				float time = Mathf.InverseLerp(0f, BaseSettings<UISettings>.Inst.pauseMenuRepositionDistance, num);
				float num2 = BaseSettings<UISettings>.Inst.pauseMenuRepositionCurve.Evaluate(time);
				position.x = 0f;
				position.z = 0f;
				Vector3 target = base.transform.TransformPoint(position);
				base.transform.position = Vector3.MoveTowards(base.transform.position, target, num2 * IC.RealDeltaTime);
			}
		}
	}

	public void TeleportBehaviour()
	{
		LR.Inst.MainMenuMode = false;
		LR.Inst.Pause(paused: false);
		HideBook();
		fadeAndMoveRoutine.Start();
		if (currentMenuType == SceneInfo.MenuType.Tutorial)
		{
			PlayerInventory.InventoryEnabled.Reset();
			LR.Inst.saveDataGame.tutorialComplete = true;
			LR.Inst.Save();
		}
		else if (currentMenuType == SceneInfo.MenuType.Credits)
		{
			HAGIS_Credits.Inst.StopCredits();
		}
		else if (currentMenuType == SceneInfo.MenuType.Hub || currentMenuType == SceneInfo.MenuType.Chapter)
		{
			LR.Inst.Save();
		}
		VOC.Inst.VOStop();
		STC.Inst.ClearQueueAndStop();
		LR.Inst.StopMusic();
	}

	public void MainMenuBehaviour()
	{
		LR.Inst.MainMenuMode = true;
		LR.Inst.Pause(paused: false);
		HideBook();
		fadeAndMoveRoutine.Start();
		STC.Inst.ClearQueueAndStop();
		LR.Inst.Save();
		VOC.Inst.VOStop();
		LR.Inst.StopMusic();
	}

	public void NewGameBehaviour()
	{
		if (LR.Inst.saveDataGame.tutorialComplete)
		{
			NewGameStart();
		}
		else
		{
			SetPage(helper);
		}
	}

	public void NewGameStart()
	{
		LR.Inst.ClearSave();
		SceneInfo info = Runtime.LoadAsset<SceneInfo>("Assets/_GameAssets/CustomAssets/SceneInfos/SC_Station_A_ART.asset");
		LR.Inst.SceneLoad(info, fadeToBlack: false);
		LR.Inst.Pause(paused: false);
		HideBook();
	}

	private void Continue()
	{
		int nextPage = GetNextPage();
		UIInfoPage page = GetPage(nextPage);
		if (page != null)
		{
			SetPage(page, nextPage);
		}
		else
		{
			CloseBook();
		}
	}

	private void Back()
	{
		int lastPage = GetLastPage();
		UIInfoPage page = GetPage(lastPage);
		if (page != null)
		{
			SetPage(page, lastPage);
		}
		else
		{
			CloseBook();
		}
	}

	public void ShowPauseMenu(UIPauseMenuShowOptions opts)
	{
		if (showAllRoutine.started)
		{
			return;
		}
		ShowAll();
		requiresFullScreenFade = !opts.disableFade;
		OrderMenuButtons();
		ShowHideMenuButtons();
		UpdateLabels();
		switch (currentMenuType)
		{
		case SceneInfo.MenuType.Limited:
			targetScene = LR.Inst.GetSceneInfoWithSceneUIDName("hair");
			break;
		case SceneInfo.MenuType.Tutorial:
			targetScene = LR.Inst.GetSceneInfoWithSceneUIDName(LR.Inst.saveDataGame.stationComplete ? "suez" : "dene");
			break;
		case SceneInfo.MenuType.Hub:
			targetScene = LR.Inst.GetSceneInfoWithSceneUIDName("hair");
			break;
		case SceneInfo.MenuType.Chapter:
			targetScene = LR.Inst.GetSceneInfoWithSceneUIDName("suez");
			break;
		case SceneInfo.MenuType.Main:
			if (LR.Inst.saveDataGame.tutorialComplete)
			{
				if (!LR.Inst.saveDataGame.stationComplete)
				{
					targetScene = LR.Inst.GetSceneInfoWithSceneUIDName("dene");
				}
				else
				{
					targetScene = LR.Inst.GetSceneInfoWithSceneUIDName("suez");
				}
			}
			break;
		case SceneInfo.MenuType.Credits:
			targetScene = LR.Inst.GetSceneInfoWithSceneUIDName("hair");
			CC.Inst.handL.gameObject.SetActive(value: true);
			CC.Inst.handR.gameObject.SetActive(value: true);
			CC.Inst.TrackingCircle.gameObject.SetActive(value: true);
			CC.Inst.TrackingDirection.gameObject.SetActive(value: true);
			break;
		}
		showAllRoutine.Start(arg0: false, opts);
	}

	private void OrderMenuButtons()
	{
		StartMenuLayout.StartMenuButtons[] startMenuEntries = BaseSettings<UISettings>.Inst.startMenuEntries[(int)currentMenuType].startMenuEntries;
		Transform[] array = ((startMenuEntries.Length == 3) ? transformMenuPosThree : transformMenuPosTwo);
		for (int i = 0; i < startMenuEntries.Length; i++)
		{
			UIButton uIButton = hideMenuButton;
			switch (startMenuEntries[i])
			{
			case StartMenuLayout.StartMenuButtons.HideMenu:
				uIButton = hideMenuButton;
				break;
			case StartMenuLayout.StartMenuButtons.HideMenuFake:
				uIButton = hideMenuFakeButton;
				break;
			case StartMenuLayout.StartMenuButtons.Teleport:
				uIButton = teleportButton;
				break;
			case StartMenuLayout.StartMenuButtons.MainMenu:
				uIButton = mainMenuButton;
				break;
			case StartMenuLayout.StartMenuButtons.Quit:
				uIButton = quitButton;
				break;
			}
			uIButton.transform.localPosition = array[i].localPosition;
		}
	}

	private void ShowHideMenuButtons()
	{
		StartMenuLayout.StartMenuButtons[] startMenuEntries = BaseSettings<UISettings>.Inst.startMenuEntries[(int)currentMenuType].startMenuEntries;
		startMenu.ShowAll();
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = false;
		for (int i = 0; i < startMenuEntries.Length; i++)
		{
			switch (startMenuEntries[i])
			{
			case StartMenuLayout.StartMenuButtons.HideMenuFake:
				flag = true;
				break;
			case StartMenuLayout.StartMenuButtons.Teleport:
				flag2 = true;
				break;
			case StartMenuLayout.StartMenuButtons.MainMenu:
				flag3 = true;
				break;
			case StartMenuLayout.StartMenuButtons.Quit:
				flag4 = true;
				break;
			}
		}
		hideMenuFakeButton.IsShown = flag;
		teleportButton.IsShown = flag2;
		mainMenuButton.IsShown = flag3;
		quitButton.IsShown = flag4;
	}

	public void UpdateLabels()
	{
		string text = "";
		string text2 = "";
		string text3 = "";
		string text4 = "";
		string text5 = "";
		switch (currentMenuType)
		{
		case SceneInfo.MenuType.Tutorial:
			text = Localisation.Retrieve("NEXUS_UI_main_menu_text_005");
			text3 = Localisation.Retrieve("NEXUS_UI_main_menu_text_006");
			break;
		case SceneInfo.MenuType.Hub:
			text = Localisation.Retrieve("NEXUS_UI_main_menu_text_005");
			text3 = Localisation.Retrieve("NEXUS_UI_main_menu_text_008");
			text4 = Localisation.Retrieve("NEXUS_UI_main_menu_text_001");
			break;
		case SceneInfo.MenuType.Chapter:
			text = Localisation.Retrieve("NEXUS_UI_main_menu_text_005");
			text3 = Localisation.Retrieve("NEXUS_UI_main_menu_text_007");
			break;
		case SceneInfo.MenuType.Main:
			text = Localisation.Retrieve("NEXUS_UI_main_menu_text_003");
			text3 = Localisation.Retrieve("NEXUS_UI_main_menu_text_004");
			text5 = Localisation.Retrieve("NEXUS_UI_main_menu_text_010");
			break;
		case SceneInfo.MenuType.MainLimited:
			text = Localisation.Retrieve("NEXUS_UI_main_menu_text_003");
			text5 = Localisation.Retrieve("NEXUS_UI_main_menu_text_010");
			break;
		case SceneInfo.MenuType.MainTutorial:
			text = Localisation.Retrieve("NEXUS_UI_main_menu_text_003");
			text2 = Localisation.Retrieve("NEXUS_UI_main_menu_text_004");
			text5 = Localisation.Retrieve("NEXUS_UI_main_menu_text_010");
			break;
		case SceneInfo.MenuType.Limited:
			text = Localisation.Retrieve("NEXUS_UI_main_menu_text_005");
			text4 = Localisation.Retrieve("NEXUS_UI_main_menu_text_001");
			break;
		case SceneInfo.MenuType.Credits:
			text = Localisation.Retrieve("NEXUS_UI_main_menu_text_005");
			text4 = Localisation.Retrieve("NEXUS_UI_main_menu_text_001");
			break;
		}
		if (text != "")
		{
			hideMenuButton.textbox.SetText(text);
			hideMenuButton.textbox.Present();
		}
		if (text2 != "")
		{
			hideMenuFakeButton.textbox.SetText(text2);
			hideMenuFakeButton.textbox.Present();
		}
		if (text3 != "")
		{
			teleportButton.textbox.SetText(text3);
			teleportButton.textbox.Present();
		}
		if (text4 != "")
		{
			mainMenuButton.textbox.SetText(text4);
			mainMenuButton.textbox.Present();
		}
		if (text5 != "")
		{
			quitButton.textbox.SetText(text5);
			quitButton.textbox.Present();
		}
	}

	public override void ShowAll()
	{
		base.ShowAll();
		UIContainer[] array = containers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].HideAll();
		}
	}

	public override bool HideAll()
	{
		base.HideAll();
		int num = containers.Length;
		while (--num >= 0)
		{
			containers[num].HideAll();
		}
		base.gameObject.SetActive(value: false);
		if (currentMenuType == SceneInfo.MenuType.Credits)
		{
			CC.Inst.handL.gameObject.SetActive(value: false);
			CC.Inst.handR.gameObject.SetActive(value: false);
			CC.Inst.TrackingCircle.gameObject.SetActive(value: false);
			CC.Inst.TrackingDirection.gameObject.SetActive(value: false);
		}
		return true;
	}

	public static MenuPos CalculateMenuPosition(Vector3 localOffsetFromHead, Vector3 localSize, TrackingMode trackingMode = TrackingMode.Full360)
	{
		MenuPos result = default(MenuPos);
		if (!LR.Inst.hasFocus)
		{
			trackingMode = TrackingMode.FrontFacing;
		}
		Vector3 headPosition = IC.GetHeadPosition();
		Vector3 rhs = ((trackingMode == TrackingMode.Full360) ? (IC.GetHeadRotation() * Vector3X.forward) : CC.Inst.transform.forward);
		Vector3 up = CC.Inst.transform.up;
		Vector3 normalized = Vector3.Cross(up, rhs).normalized;
		rhs = Vector3.Cross(normalized, up).normalized;
		result.rot = Quaternion.LookRotation(rhs, up);
		result.pos = headPosition;
		result.pos += normalized * localOffsetFromHead.x;
		result.pos += up * localOffsetFromHead.y;
		result.pos += rhs * localOffsetFromHead.z;
		if (!LR.Inst.hasFocus)
		{
			Vector3 vector = CC.Inst.transform.InverseTransformPoint(result.pos);
			vector.RepY(IC.GetProfileEyeHeight(1f));
			result.pos = CC.Inst.transform.TransformPoint(vector);
		}
		return result;
	}

	public MenuPos CalculateTargetPositionAndRotation(UIPauseMenuShowOptions opts)
	{
		Vector3 localOffsetFromHead = new Vector3(0f, -0.15f, 0.8f);
		Vector3 localSize = new Vector3(0.5f, 0.5f, 0.15f);
		return CalculateMenuPosition(localOffsetFromHead, localSize, (!opts.forceFrontFacing) ? CC.Inst.trackingMode : TrackingMode.FrontFacing);
	}

	public void RefreshPosition(UIPauseMenuShowOptions opts)
	{
		MenuPos menuPos = CalculateTargetPositionAndRotation(opts);
		base.transform.position = menuPos.pos;
		base.transform.rotation = menuPos.rot;
	}

	public Bounds GetBounds()
	{
		return coverSMR.bounds;
	}

	public int GetNextPage()
	{
		_ = LR.Inst.saveDataSettings.inputMode;
		int num = pageIndex + 1;
		UIInfoPage page = GetPage(num);
		while (page != null && page.platformSpecific && !page.questSpecific)
		{
			num++;
			page = GetPage(num);
		}
		return num;
	}

	public int GetLastPage()
	{
		_ = LR.Inst.saveDataSettings.inputMode;
		int num = pageIndex - 1;
		UIInfoPage page = GetPage(num);
		while (page != null && page.platformSpecific && !page.questSpecific)
		{
			num--;
			page = GetPage(num);
		}
		return num;
	}

	public Wait SetPage(UIBookPage newPage, int index = -1, bool immediate = false, bool silent = false, UIPauseMenu_Confirmation.ConfirmType confirmType = UIPauseMenu_Confirmation.ConfirmType.MAX)
	{
		if (confirmType != UIPauseMenu_Confirmation.ConfirmType.MAX)
		{
			((UIPauseMenu_Confirmation)newPage).currConfirmType = confirmType;
		}
		if (immediate)
		{
			setCurrentPageRoutine.Stop();
			if (currentPage != null)
			{
				currentPage.HideAll();
			}
			if (newPage != null)
			{
				newPage.ShowAll();
				newPage.SetAlpha(1f);
			}
			currentPage = newPage;
			pageIndex = index;
			return Wait.None;
		}
		return setCurrentPageRoutine.Start(newPage, index, silent, resetIfStarted: true);
	}

	public UIInfoPage GetPage(int page)
	{
		_ = LR.Inst.saveDataSettings.inputMode;
		if (page < 0 || page >= infoPages.Length)
		{
			return null;
		}
		return infoPages[page];
	}

	public Wait CloseBook(bool CloseMenu = false)
	{
		if (!closeBookRoutine.started)
		{
			return closeBookRoutine.Start(CloseMenu);
		}
		return Wait.None;
	}

	private IEnumerator<Routine.Yield> SetCurrentPageRoutine(UIBookPage newPage, int index, bool silent)
	{
		if (currentPage != null)
		{
			currentPage.ToggleButtons(value: false);
		}
		newPage?.ToggleButtons(value: false);
		if (!silent)
		{
			FAC.Inst.PlayOneShot(soundMenuPage, base.transform.position);
		}
		if (currentPage != null)
		{
			float timer2 = 0f;
			while (timer2 < fadeTime)
			{
				yield return Wait.For.LRRealtimeUpdates(1);
				timer2 += IC.RealDeltaTime;
				currentPage.SetAlpha(1f - timer2 / fadeTime);
			}
			currentPage.HideAll();
		}
		if (newPage != null)
		{
			newPage.ShowAll();
			newPage.SetAlpha(0f);
			float timer2 = 0f;
			while (timer2 < fadeTime)
			{
				yield return Wait.For.LRRealtimeUpdates(1);
				timer2 += IC.RealDeltaTime;
				newPage.SetAlpha(timer2 / fadeTime);
			}
		}
		if (currentPage != null)
		{
			currentPage.ToggleButtons(value: true);
		}
		newPage?.ToggleButtons(value: true);
		currentPage = newPage;
		pageIndex = index;
	}

	public void ShowHelperScreen(UIPauseMenuShowOptions opts)
	{
		ShowAll();
		showAllRoutine.Start(arg0: true, opts);
	}

	private IEnumerator<Routine.Yield> ShowAllRoutine(bool goToHelper, UIPauseMenuShowOptions opts)
	{
		FAC.Inst.PlayOneShot(soundMenuAppear, base.transform.position);
		RefreshPosition(opts);
		hideMenuButton.enabled = false;
		hideMenuFakeButton.enabled = false;
		teleportButton.enabled = false;
		mainMenuButton.enabled = false;
		quitButton.enabled = false;
		optionsButton.enabled = false;
		howToPlayButton.enabled = false;
		if (!opts.disableParticles)
		{
			pageParticles.Play(withChildren: true);
		}
		yield return manAnim.PlayAnimManual(LR.Inst.onRealTimeUpdate, call: true, CH_BookUI_DefaultEnter);
		hideMenuButton.enabled = true;
		hideMenuFakeButton.enabled = true;
		teleportButton.enabled = true;
		mainMenuButton.enabled = true;
		quitButton.enabled = true;
		optionsButton.enabled = true;
		howToPlayButton.enabled = true;
		if (goToHelper)
		{
			openBookRoutine.Start(OpenBookPage.Helper);
		}
	}

	public Wait HideBook()
	{
		if (!hideAllRoutine.started)
		{
			return hideAllRoutine.Start();
		}
		return Wait.Until.Completed(hideAllRoutine);
	}

	public IEnumerator<Routine.Yield> CloseGameRoutine()
	{
		yield return LR.Inst.Save();
		yield return HideBook() & NexusFullScreenPass.Inst.StartFadeToBlack(0.5f);
		yield return Wait.For.Seconds(0.5f);
		UnityEngine.Application.Quit();
	}

	public IEnumerator<Routine.Yield> HideAllRoutine()
	{
		if (showAllRoutine.started)
		{
			yield return Wait.Until.Completed(showAllRoutine, 1, allowPreMetNow: true);
		}
		FAC.Inst.PlayOneShot(soundMenuDisappear, base.transform.position);
		if (isOpen)
		{
			yield return CloseBook(CloseMenu: true);
		}
		bookRegionTracking.Start();
		yield return HAGIS.PlayAnim(manAnim.animation, CH_BookUI_DefaultExit);
		bookRegionTracking.Stop();
		HideAll();
	}

	private IEnumerator<Routine.Yield> OpenBookRoutine(OpenBookPage openPage = OpenBookPage.Options, UIPauseMenu_Confirmation.ConfirmType confirm = UIPauseMenu_Confirmation.ConfirmType.MAX)
	{
		FAC.Inst.PlayOneShot(soundMenuOpen, base.transform.position);
		hideMenuButton.enabled = false;
		hideMenuFakeButton.enabled = false;
		teleportButton.enabled = false;
		mainMenuButton.enabled = false;
		quitButton.enabled = false;
		optionsButton.enabled = false;
		howToPlayButton.enabled = false;
		SetPage(null, -1, immediate: true);
		yield return manAnim.PlayAnimManual(LR.Inst.onRealTimeUpdate, call: true, CH_BookUI_TransClosedToOpen);
		switch (openPage)
		{
		case OpenBookPage.Options:
			yield return SetPage(options, -1, immediate: false, silent: true);
			break;
		case OpenBookPage.HowToPlay:
		{
			int nextPage = GetNextPage();
			UIInfoPage page = GetPage(nextPage);
			yield return SetPage(page, nextPage, immediate: false, silent: true);
			break;
		}
		case OpenBookPage.Confirm:
			yield return SetPage(confirmPrompt, -1, immediate: false, silent: true, confirm);
			break;
		case OpenBookPage.Helper:
			yield return SetPage(helper, -1, immediate: false, silent: true);
			break;
		}
		isOpen = true;
	}

	private IEnumerator<Routine.Yield> CloseBookRoutine(bool closing)
	{
		FAC.Inst.PlayOneShot(soundMenuClose, base.transform.position);
		yield return SetPage(null);
		yield return manAnim.PlayAnimManual(LR.Inst.onRealTimeUpdate, call: true, CH_BookUI_TransOpenToClosed);
		if (!closing)
		{
			hideMenuButton.enabled = true;
			hideMenuFakeButton.enabled = true;
			teleportButton.enabled = true;
			mainMenuButton.enabled = true;
			quitButton.enabled = true;
			optionsButton.enabled = true;
			howToPlayButton.enabled = true;
		}
		isOpen = false;
	}

	private IEnumerator<Routine.Yield> BookRegionTracking()
	{
		while (true)
		{
			if ((bool)CC.Inst.CurrentRegion && CC.Inst.CurrentRegion.isDynamic)
			{
				Vector3 position = base.transform.position;
				position += CC.Inst.CurrentRegion.DynamicOffset;
				base.transform.position = position;
			}
			yield return Wait.For.LRLateUpdates(1);
		}
	}

	public void SetCreditsTarget()
	{
		targetScene = LR.Inst.GetSceneInfoWithSceneUIDName("paty");
	}

	private IEnumerator<Routine.Yield> FadeAndMoveRoutine()
	{
		IC.Inst.PauseMenuEnabled = false;
		VOC.Inst.VOStop(interruption: true);
		for (int i = 0; i < LR.Inst.mrsLoaded.Length; i++)
		{
			LR.Inst.mrsLoaded[i].StopAllAnimations();
		}
		FAC.Inst.GetBus("bus:/Submix").stopAllEvents(STOP_MODE.ALLOWFADEOUT);
		yield return NexusFullScreenPass.Inst.StartFadeToColor(0.5f, NexusFullScreenPass.offWhite);
		SceneInfo.MenuType lastMenu = currentMenuType;
		_ = LR.Inst.saveDataGame.lastChapter;
		LR.Inst.SetInCutscene(cutscene: false);
		PlayerInventory.Inst.EmptyInventory(fromSaveData: false);
		PlayerInventory.Inst.TriggerTransition(toFantasy: false);
		yield return LR.Inst.LoadPlayerIntoScene(targetScene, null, null, shouldFadeToClearAtEndOfRoutine: false);
		if (LR.Inst.saveDataGame.stationLeverPulled && targetScene.sceneUIDName == "dene")
		{
			PlayerEntryPoint orNull = stationResumeEntryPoint.GetOrNull<PlayerEntryPoint>();
			if (orNull != null)
			{
				CC.Inst.PositionReplace(orNull, default(CC.TeleportInfo), fadeCamera: false);
			}
		}
		HubEntryPointHolder hubEntryPointHolder = UnityEngine.Object.FindObjectOfType<HubEntryPointHolder>();
		PlayerEntryPoint playerEntryPoint = null;
		if ((bool)hubEntryPointHolder)
		{
			if (CC.Inst.currentChapter == SaveDataGame.Chapter.Mansfield || LR.Inst.saveDataGame.lastChapter == SaveDataGame.Chapter.Mansfield)
			{
				playerEntryPoint = hubEntryPointHolder.planetariumEntryPoint;
			}
			else if (targetScene.sceneUIDName == "suez")
			{
				playerEntryPoint = hubEntryPointHolder.GetTargetHubEntryPoint();
			}
		}
		if (playerEntryPoint != null)
		{
			CC.Inst.PositionReplace(playerEntryPoint, default(CC.TeleportInfo), fadeCamera: false);
		}
		NexusFullScreenPass.Inst.ForceUpdateLastValidPosition();
		if (lastMenu == SceneInfo.MenuType.Credits)
		{
			CC.Inst.handL.gameObject.SetActive(value: true);
			CC.Inst.handR.gameObject.SetActive(value: true);
			CC.Inst.TrackingCircle.gameObject.SetActive(value: true);
			CC.Inst.TrackingDirection.gameObject.SetActive(value: true);
		}
		PlayerInventory.InventoryEnabled.Reset();
		IC.Inst.PauseMenuEnabled = true;
		yield return NexusFullScreenPass.Inst.StartFadeToClear(0.5f);
	}

	public bool IsAnimating()
	{
		if (!closeBookRoutine.started && !openBookRoutine.started && !showAllRoutine.started)
		{
			return hideAllRoutine.started;
		}
		return true;
	}

	public bool InputReturnMenu()
	{
		if (!setCurrentPageRoutine.started && !IsAnimating())
		{
			if (currentPage != null)
			{
				return currentPage.ReturnMenu();
			}
			if (currentMenuType != SceneInfo.MenuType.Main && currentMenuType != SceneInfo.MenuType.MainLimited)
			{
				LR.Inst.Pause(paused: false);
				HideBook();
				return true;
			}
		}
		return false;
	}
}
[Serializable]
public class UIPauseMenu_Confirmation : UIBookPage
{
	public enum ConfirmType
	{
		quit,
		tutorial,
		newGame,
		hub,
		mainMenu,
		skip,
		MAX
	}

	private struct ConfirmStruct
	{
		public ConfirmType confirmType;

		public string locKeyPrompt;

		public string locKeyWarning;

		public ConfirmStruct(ConfirmType confirmType, string locKeyPrompt, string locKeyWarning)
		{
			this.confirmType = confirmType;
			this.locKeyPrompt = locKeyPrompt;
			this.locKeyWarning = locKeyWarning;
		}
	}

	private UITextbox promptText;

	private UITextbox warningText;

	private UIPauseMenu pauseMenu;

	[NonSerialized]
	public ConfirmType currConfirmType;

	private ConfirmStruct[] confirmStruct = new ConfirmStruct[6]
	{
		new ConfirmStruct(ConfirmType.quit, "NEXUS_UI_main_menu_text_013", "NEXUS_UI_main_menu_text_019"),
		new ConfirmStruct(ConfirmType.tutorial, "NEXUS_UI_main_menu_text_014", "NEXUS_UI_main_menu_text_019"),
		new ConfirmStruct(ConfirmType.newGame, "NEXUS_UI_main_menu_text_015", "NEXUS_UI_main_menu_text_020"),
		new ConfirmStruct(ConfirmType.hub, "NEXUS_UI_main_menu_text_016", "NEXUS_UI_main_menu_text_019"),
		new ConfirmStruct(ConfirmType.mainMenu, "NEXUS_UI_main_menu_text_017", "NEXUS_UI_main_menu_text_019"),
		new ConfirmStruct(ConfirmType.skip, "NEXUS_UI_main_menu_text_018", "NEXUS_UI_main_menu_text_021")
	};

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		pauseMenu = UIPauseMenu.Inst;
		promptText = PageLeft.GetElement<UITextbox>("Prompt Text");
		warningText = PageRight.GetElement<UITextbox>("Warning Text");
		PageLeft.GetElement<UIButton>("Confirm Button").OnTapUp += delegate
		{
			switch (currConfirmType)
			{
			case ConfirmType.quit:
				pauseMenu.closeGameRoutine.Start();
				break;
			case ConfirmType.newGame:
				pauseMenu.NewGameBehaviour();
				break;
			case ConfirmType.mainMenu:
				if (UIPauseMenu.Inst.currentMenuType == SceneInfo.MenuType.Credits)
				{
					HAGIS_Credits.Inst.StopCredits();
				}
				pauseMenu.MainMenuBehaviour();
				break;
			case ConfirmType.tutorial:
			case ConfirmType.hub:
			case ConfirmType.skip:
				pauseMenu.TeleportBehaviour();
				break;
			}
			return true;
		};
		PageLeft.GetElement<UIButton>("Cancel Button").OnTapUp += delegate
		{
			ReturnMenu();
			return true;
		};
	}

	public override void ShowAll()
	{
		base.ShowAll();
		promptText.SetText(Localisation.Retrieve(confirmStruct[(int)currConfirmType].locKeyPrompt));
		promptText.Present();
		warningText.SetText(Localisation.Retrieve(confirmStruct[(int)currConfirmType].locKeyWarning));
		warningText.Present();
	}

	public override bool ReturnMenu()
	{
		pauseMenu.CloseBook();
		return true;
	}
}
[Serializable]
public class UIPauseMenu_GameOptions : UIBookPage
{
	private UIPauseMenu pauseMenu;

	private UITextbox subtitleText;

	private UITextbox puzzleText;

	private UITextbox sensorText;

	private UITextbox sensorTitle;

	private UITextbox subLangTitle;

	private UITextbox subLangText;

	private UITextbox voLangTitle;

	private UITextbox voLangText;

	private UIButton textLangLeft;

	private UIButton textLangRight;

	private UIButton voiceLangLeft;

	private UIButton voiceLangRight;

	private UIMeter[] audioMeters = new UIMeter[3];

	private int[] audioLevel = new int[3];

	private string[] audioNames = new string[3] { "Audio Music", "Audio SFX", "Audio Voice" };

	private bool[] muted = new bool[3];

	private FMOD.Studio.EventInstance evt;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		pauseMenu = UIPauseMenu.Inst;
		audioMeters[0] = PageLeft.GetElement<UIMeter>("Audio Music");
		audioMeters[1] = PageLeft.GetElement<UIMeter>("Audio SFX");
		audioMeters[2] = PageLeft.GetElement<UIMeter>("Audio Voice");
		for (int i = 0; i < 3; i++)
		{
			audioLevel[i] = LR.Inst.saveDataSettings.volumeLevels[i];
			muted[i] = audioLevel[i] == 0;
			if (muted[i])
			{
				audioLevel[i] = 5;
			}
		}
		PageLeft.GetElement<UIButton>("Back").OnTapUp += delegate
		{
			pauseMenu.SetPage(pauseMenu.options);
			return true;
		};
		puzzleText = PageLeft.GetElement<UITextbox>("Puzzle Hints Value");
		PageLeft.GetElement<UIButton>("Arrow Left", "Puzzle Hints Value").OnTapUp += (UIButton button) => UpdatePuzzleHints();
		PageLeft.GetElement<UIButton>("Arrow Right", "Puzzle Hints Value").OnTapUp += (UIButton button) => UpdatePuzzleHints();
		sensorTitle = PageRight.GetElement<UITextbox>("Sensor Mode");
		sensorText = PageRight.GetElement<UITextbox>("Sensor Mode Value");
		for (int j = 0; j < audioMeters.Length; j++)
		{
			int currMeterIdx = j;
			UIMeter currAudioMeter = audioMeters[j];
			audioMeters[j].icon.OnTapUp += delegate
			{
				bool flag = !muted[currMeterIdx];
				muted[currMeterIdx] = flag;
				currAudioMeter.iconHighlight.SetSwappedImage(flag);
				for (int m = 0; m < currAudioMeter.pips.Length; m++)
				{
					currAudioMeter.pipsHighlight[m].SetMutedImage(flag);
				}
				LR.Inst.saveDataSettings.volumeLevels[currMeterIdx] = ((!flag) ? audioLevel[currMeterIdx] : 0);
				LR.Inst.Save();
				switch (currMeterIdx)
				{
				case 0:
					LR.Inst.SetVCAMusicVolume();
					break;
				case 1:
					LR.Inst.SetVCASFXVolume();
					break;
				case 2:
					LR.Inst.SetVCAVoVolume();
					break;
				}
				if (evt.isValid())
				{
					evt.stop(STOP_MODE.IMMEDIATE);
				}
				evt = FAC.Inst.PlayOneShot(BaseSettings<VOSettings>.Inst.sampleEvents[currMeterIdx].Value, MainCamera.Inst.transform);
				return true;
			};
			audioMeters[j].iconHighlight.SetSwappedImage(muted[j]);
			for (int k = 0; k < audioMeters[j].pips.Length; k++)
			{
				int currPipIdx = k;
				currAudioMeter.pips[k].OnTapUp += delegate
				{
					muted[currMeterIdx] = false;
					currAudioMeter.iconHighlight.SetSwappedImage(val: false);
					audioLevel[currMeterIdx] = currPipIdx + 1;
					for (int l = 0; l < currAudioMeter.pips.Length; l++)
					{
						currAudioMeter.pipsHighlight[l].SetSwappedImage(audioLevel[currMeterIdx] - 1 == l);
						currAudioMeter.pipsHighlight[l].SetMutedImage(val: false);
					}
					LR.Inst.saveDataSettings.volumeLevels[currMeterIdx] = currPipIdx + 1;
					LR.Inst.Save();
					switch (currMeterIdx)
					{
					case 0:
						LR.Inst.SetVCAMusicVolume();
						break;
					case 1:
						LR.Inst.SetVCASFXVolume();
						break;
					case 2:
						LR.Inst.SetVCAVoVolume();
						break;
					}
					if (evt.isValid())
					{
						evt.stop(STOP_MODE.IMMEDIATE);
					}
					evt = FAC.Inst.PlayOneShot(BaseSettings<VOSettings>.Inst.sampleEvents[currMeterIdx].Value, MainCamera.Inst.transform);
					return true;
				};
				currAudioMeter.pipsHighlight[k].SetSwappedImage(audioLevel[currMeterIdx] - 1 == k);
				currAudioMeter.pipsHighlight[k].SetMutedImage(muted[j]);
			}
		}
		subLangTitle = PageRight.GetElement<UITextbox>("Text Language");
		subLangText = PageRight.GetElement<UITextbox>("Text Language Value");
		voLangTitle = PageRight.GetElement<UITextbox>("Voiceover Language");
		voLangText = PageRight.GetElement<UITextbox>("Voiceover Language Value");
		subtitleText = PageRight.GetElement<UITextbox>("Subtitles Value");
		PageRight.GetElement<UIButton>("Arrow Left", "Subtitles Value").OnTapUp += (UIButton button) => UpdateSubtitles();
		PageRight.GetElement<UIButton>("Arrow Right", "Subtitles Value").OnTapUp += (UIButton button) => UpdateSubtitles();
		textLangLeft = PageRight.GetElement<UIButton>("Arrow Left", "Text Language Value");
		textLangRight = PageRight.GetElement<UIButton>("Arrow Right", "Text Language Value");
		voiceLangLeft = PageRight.GetElement<UIButton>("Arrow Left", "Voiceover Language Value");
		voiceLangRight = PageRight.GetElement<UIButton>("Arrow Right", "Voiceover Language Value");
		textLangLeft.OnTapUp += delegate
		{
			int language2 = (int)(Localisation.Inst.CurrentLanguage - 1 + 6) % 6;
			Localisation.Inst.ChangeLanguage((Localisation.Language)language2);
			UpdateGameOptions();
			pauseMenu.UpdateLabels();
			return true;
		};
		textLangRight.OnTapUp += delegate
		{
			int language = (int)(Localisation.Inst.CurrentLanguage + 1) % 6;
			Localisation.Inst.ChangeLanguage((Localisation.Language)language);
			UpdateGameOptions();
			pauseMenu.UpdateLabels();
			return true;
		};
		voiceLangLeft.OnTapUp += delegate
		{
			int num2 = (int)(VOC.Inst.voLanguage - 1 + 6) % 6;
			VOC.Inst.voLanguage = (Localisation.Language)num2;
			PlayerPrefs.SetInt("LanguageVO", num2);
			UpdateGameOptions();
			return true;
		};
		voiceLangRight.OnTapUp += delegate
		{
			int num = (int)(VOC.Inst.voLanguage + 1) % 6;
			VOC.Inst.voLanguage = (Localisation.Language)num;
			PlayerPrefs.SetInt("LanguageVO", num);
			UpdateGameOptions();
			return true;
		};
	}

	private bool UpdatePuzzleHints()
	{
		LR.Inst.saveDataSettings.hintsEnabled = !LR.Inst.saveDataSettings.hintsEnabled;
		LR.Inst.Save();
		UpdateGameOptions();
		return true;
	}

	private bool UpdateSubtitles()
	{
		LR.Inst.saveDataSettings.subtitlesEnabled = !LR.Inst.saveDataSettings.subtitlesEnabled;
		LR.Inst.Save();
		UpdateGameOptions();
		return true;
	}

	public override void ShowAll()
	{
		base.ShowAll();
		sensorTitle.Hide();
		sensorText.Hide();
		UpdateGameOptions(playSound: false);
	}

	private void UpdateGameOptions(bool playSound = true)
	{
		subtitleText.SetText(LR.Inst.saveDataSettings.subtitlesEnabled ? Localisation.Retrieve("NEXUS_UI_game_options_text_008") : Localisation.Retrieve("NEXUS_UI_game_options_text_009"));
		subtitleText.Present();
		puzzleText.SetText(LR.Inst.saveDataSettings.hintsEnabled ? Localisation.Retrieve("NEXUS_UI_game_options_text_008") : Localisation.Retrieve("NEXUS_UI_game_options_text_009"));
		puzzleText.Present();
		subLangText.SetText(Localisation.Retrieve(Localisation.Language_String[(int)Localisation.Inst.CurrentLanguage]));
		subLangText.Present();
		voLangText.SetText(Localisation.Retrieve(Localisation.Language_String[(int)VOC.Inst.voLanguage]));
		voLangText.Present();
		if (playSound)
		{
			FAC.Inst.PlayOneShot(pauseMenu.soundMenuSelect, pauseMenu.transform.position);
		}
	}

	public override bool ReturnMenu()
	{
		pauseMenu.SetPage(pauseMenu.options);
		return true;
	}
}
[Serializable]
public class UIPauseMenu_HeightAdjust : UIBookPage
{
	private enum PageMode
	{
		Seated,
		Standing,
		SwapToSeated,
		SwapToStanding
	}

	private UIPauseMenu pauseMenu;

	private UIButton calibrateButton;

	private UIButton modeLeftButton;

	private UIButton modeRightButton;

	private UITextbox settingText;

	private UITextbox explanationText1;

	private UITextbox explanationText2;

	private UIImage imageSitting;

	private UIImage imageStanding;

	private PageMode currPageMode;

	private IHaglet<bool> fadeRoutine;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		Haglet.Create(out fadeRoutine, (Routine.Func1<bool>)FadeRoutine, (string)null, startNow: false, (int?)null, (string)null);
		pauseMenu = UIPauseMenu.Inst;
		calibrateButton = PageRight.GetElement<UIButton>("Calibrate");
		modeLeftButton = PageLeft.GetElement<UIButton>("Arrow Left", "Setting Value");
		modeRightButton = PageLeft.GetElement<UIButton>("Arrow Right", "Setting Value");
		settingText = PageLeft.GetElement<UITextbox>("Setting Value");
		explanationText1 = PageRight.GetElement<UITextbox>("Explanation Text 1");
		explanationText2 = PageRight.GetElement<UITextbox>("Explanation Text 2");
		imageSitting = PageRight.GetElement<UIImage>("Image Sitting");
		imageStanding = PageRight.GetElement<UIImage>("Image Standing");
		CheckInitialMode();
		calibrateButton.OnTapUp += delegate
		{
			bool arg = currPageMode == PageMode.SwapToSeated || currPageMode == PageMode.Seated;
			fadeRoutine.Start(arg);
			return true;
		};
		modeLeftButton.OnTapUp += delegate
		{
			ChangeMode();
			return true;
		};
		modeRightButton.OnTapUp += delegate
		{
			ChangeMode();
			return true;
		};
		PageLeft.GetElement<UIButton>("Back").OnTapUp += delegate
		{
			pauseMenu.SetPage(pauseMenu.options);
			return true;
		};
	}

	private IEnumerator<Routine.Yield> FadeRoutine(bool seat)
	{
		calibrateButton.interactable = false;
		modeLeftButton.interactable = false;
		modeRightButton.interactable = false;
		yield return NexusFullScreenPass.Inst.StartFadeToBlack(BaseSettings<TeleportSettings>.Inst.TeleportFadeSpeed);
		CC.Inst.seatingController.SetSeating(seat);
		if (currPageMode == PageMode.SwapToSeated)
		{
			currPageMode = PageMode.Seated;
		}
		else if (currPageMode == PageMode.SwapToStanding)
		{
			currPageMode = PageMode.Standing;
		}
		UpdateScreen();
		UIPauseMenu.Inst.RefreshPosition(default(UIPauseMenuShowOptions));
		yield return Wait.For.LRRealtimeUpdates(1);
		yield return NexusFullScreenPass.Inst.StartFadeToClear(BaseSettings<TeleportSettings>.Inst.TeleportFadeSpeed);
		calibrateButton.interactable = true;
		modeLeftButton.interactable = true;
		modeRightButton.interactable = true;
	}

	private void ChangeMode()
	{
		switch (currPageMode)
		{
		case PageMode.Seated:
			currPageMode = PageMode.SwapToStanding;
			break;
		case PageMode.Standing:
			currPageMode = PageMode.SwapToSeated;
			break;
		case PageMode.SwapToSeated:
			currPageMode = PageMode.Standing;
			break;
		case PageMode.SwapToStanding:
			currPageMode = PageMode.Seated;
			break;
		}
		UpdateScreen();
	}

	public override void ShowAll()
	{
		base.ShowAll();
		CheckInitialMode();
		UpdateScreen();
	}

	private void CheckInitialMode()
	{
		if (CC.Inst.seatingController.OffsetActive)
		{
			currPageMode = PageMode.Seated;
		}
		else
		{
			currPageMode = PageMode.Standing;
		}
	}

	private void UpdateScreen()
	{
		switch (currPageMode)
		{
		case PageMode.Seated:
			settingText.SetText(Localisation.Retrieve("NEXUS_UI_height_text_011"));
			settingText.Present();
			calibrateButton.Disabled = false;
			calibrateButton.textbox.SetText(Localisation.Retrieve("NEXUS_UI_height_text_013"));
			calibrateButton.textbox.Present();
			explanationText1.SetText(Localisation.Retrieve("NEXUS_UI_height_text_005"));
			explanationText1.Present();
			explanationText2.SetText(Localisation.Retrieve("NEXUS_UI_height_text_006"));
			explanationText2.Present();
			imageSitting.Show();
			imageStanding.Hide();
			break;
		case PageMode.Standing:
			settingText.SetText(Localisation.Retrieve("NEXUS_UI_height_text_010"));
			settingText.Present();
			calibrateButton.Disabled = true;
			calibrateButton.textbox.SetText(Localisation.Retrieve("NEXUS_UI_height_text_012"));
			calibrateButton.textbox.Present();
			explanationText1.SetText("");
			explanationText1.Present();
			explanationText2.SetText("");
			explanationText2.Present();
			imageSitting.Hide();
			imageStanding.Show();
			break;
		case PageMode.SwapToSeated:
			settingText.SetText(Localisation.Retrieve("NEXUS_UI_height_text_011"));
			settingText.Present();
			calibrateButton.Disabled = false;
			calibrateButton.textbox.SetText(Localisation.Retrieve("NEXUS_UI_height_text_012"));
			calibrateButton.textbox.Present();
			explanationText1.SetText(Localisation.Retrieve("NEXUS_UI_height_text_003"));
			explanationText1.Present();
			explanationText2.SetText(Localisation.Retrieve("NEXUS_UI_height_text_004"));
			explanationText2.Present();
			imageSitting.Show();
			imageStanding.Hide();
			break;
		case PageMode.SwapToStanding:
			settingText.SetText(Localisation.Retrieve("NEXUS_UI_height_text_010"));
			settingText.Present();
			calibrateButton.Disabled = false;
			calibrateButton.textbox.SetText(Localisation.Retrieve("NEXUS_UI_height_text_012"));
			calibrateButton.textbox.Present();
			explanationText1.SetText(Localisation.Retrieve("NEXUS_UI_height_text_007"));
			explanationText1.Present();
			explanationText2.SetText(Localisation.Retrieve("NEXUS_UI_height_text_008"));
			explanationText2.Present();
			imageSitting.Hide();
			imageStanding.Show();
			break;
		}
	}

	public override bool ReturnMenu()
	{
		pauseMenu.SetPage(pauseMenu.options);
		return true;
	}
}
[Serializable]
public class UIPauseMenu_Helper : UIBookPage
{
	private UIPauseMenu pauseMenu;

	private UITextbox titleText;

	private UITextbox text1;

	private UITextbox text2;

	private UIImage icon1;

	private UIImage icon2;

	[NonSerialized]
	public bool firstShown;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		pauseMenu = UIPauseMenu.Inst;
		titleText = PageLeft.GetElement<UITextbox>("Title");
		text1 = PageLeft.GetElement<UITextbox>("Text 1");
		text2 = PageLeft.GetElement<UITextbox>("Text 2");
		icon1 = PageLeft.GetElement<UIImage>("Icon 1");
		icon2 = PageLeft.GetElement<UIImage>("Icon 2");
		PageLeft.GetElement<UIButton>("Confirm Button").OnTapUp += delegate
		{
			if (!firstShown)
			{
				firstShown = true;
				pauseMenu.NewGameStart();
			}
			else
			{
				LR.Inst.Pause(paused: false);
				pauseMenu.HideBook();
			}
			return true;
		};
	}

	public override void ShowAll()
	{
		base.ShowAll();
		if (firstShown)
		{
			titleText.SetText(Localisation.Retrieve("NEXUS_UI_helper_screen_004"));
			titleText.Present();
			text1.SetText(Localisation.Retrieve("NEXUS_UI_helper_screen_005"));
			text1.Present();
			text2.SetText(Localisation.Retrieve("NEXUS_UI_helper_screen_006"));
			text2.Present();
			icon1.Hide();
		}
		else
		{
			icon2.Hide();
		}
	}
}
[Serializable]
public class UIPauseMenu_MovementOptions : UIBookPage
{
	private UITextbox modeText;

	private UITextbox turnTypeText;

	private UITextbox speedTextHeader;

	private UITextbox moveFadeTextHeader;

	private UIButton[] walkSpeedButtons = new UIButton[3];

	private UIButtonImageHighlight[] walkSpeedHighlights = new UIButtonImageHighlight[3];

	private UIButton[] teleFadeButtons = new UIButton[3];

	private UIButtonImageHighlight[] teleFadeHighlights = new UIButtonImageHighlight[3];

	private UIButton[] turnAmountButtons = new UIButton[3];

	private UIButtonImageHighlight[] turnAmountHighlights = new UIButtonImageHighlight[3];

	private UIButton[] moveFadeButtons = new UIButton[4];

	private UIButtonImageHighlight[] moveFadeHighlights = new UIButtonImageHighlight[4];

	private UIPauseMenu pauseMenu;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		pauseMenu = UIPauseMenu.Inst;
		PageLeft.GetElement<UIButton>("Back").OnTapUp += delegate
		{
			pauseMenu.SetPage(pauseMenu.options);
			return true;
		};
		modeText = PageLeft.GetElement<UITextbox>("Movement Mode Value");
		PageLeft.GetElement<UIButton>("Arrow Left", "Movement Mode Value").OnTapUp += delegate
		{
			BaseSettings<TeleportSettings>.Inst.InputMode = BaseSettings<TeleportSettings>.Inst.InputMode.Previous();
			return UpdateFreemoveOptions(playSound: false, save: true);
		};
		PageLeft.GetElement<UIButton>("Arrow Right", "Movement Mode Value").OnTapUp += delegate
		{
			BaseSettings<TeleportSettings>.Inst.InputMode = BaseSettings<TeleportSettings>.Inst.InputMode.Next();
			return UpdateFreemoveOptions(playSound: false, save: true);
		};
		turnTypeText = PageLeft.GetElement<UITextbox>("Turn Type Value");
		PageLeft.GetElement<UIButton>("Arrow Left", "Turn Type Value").OnTapUp += delegate
		{
			LR.Inst.saveDataSettings.freeMoveTurnType = LR.Inst.saveDataSettings.freeMoveTurnType.Previous();
			return UpdateFreemoveOptions(playSound: false, save: true);
		};
		PageLeft.GetElement<UIButton>("Arrow Right", "Turn Type Value").OnTapUp += delegate
		{
			LR.Inst.saveDataSettings.freeMoveTurnType = LR.Inst.saveDataSettings.freeMoveTurnType.Next();
			return UpdateFreemoveOptions(playSound: false, save: true);
		};
		speedTextHeader = PageLeft.GetElement<UITextbox>("Walk Speed");
		walkSpeedButtons[0] = PageLeft.GetElement<UIButton>("Small", "Walk Speed Value");
		walkSpeedHighlights[0] = PageLeft.GetElement<UIButtonImageHighlight>("Small", "Walk Speed Value");
		walkSpeedButtons[0].OnTapUp += delegate
		{
			LR.Inst.saveDataSettings.freeMoveSpeed = TeleportSettings.SpeedSetting.Slow;
			return UpdateFreemoveOptions(playSound: false, save: true);
		};
		walkSpeedButtons[1] = PageLeft.GetElement<UIButton>("Mid", "Walk Speed Value");
		walkSpeedHighlights[1] = PageLeft.GetElement<UIButtonImageHighlight>("Mid", "Walk Speed Value");
		walkSpeedButtons[1].OnTapUp += delegate
		{
			LR.Inst.saveDataSettings.freeMoveSpeed = TeleportSettings.SpeedSetting.Medium;
			return UpdateFreemoveOptions(playSound: false, save: true);
		};
		walkSpeedButtons[2] = PageLeft.GetElement<UIButton>("Big", "Walk Speed Value");
		walkSpeedHighlights[2] = PageLeft.GetElement<UIButtonImageHighlight>("Big", "Walk Speed Value");
		walkSpeedButtons[2].OnTapUp += delegate
		{
			LR.Inst.saveDataSettings.freeMoveSpeed = TeleportSettings.SpeedSetting.Fast;
			return UpdateFreemoveOptions(playSound: false, save: true);
		};
		teleFadeButtons[0] = PageRight.GetElement<UIButton>("Small", "Teleport Fade Time Value");
		teleFadeHighlights[0] = PageRight.GetElement<UIButtonImageHighlight>("Small", "Teleport Fade Time Value");
		teleFadeButtons[0].OnTapUp += delegate
		{
			LR.Inst.saveDataSettings.teleportFadeSpeed = TeleportSettings.SpeedSetting.Slow;
			return UpdateFreemoveOptions(playSound: false, save: true);
		};
		teleFadeButtons[1] = PageRight.GetElement<UIButton>("Mid", "Teleport Fade Time Value");
		teleFadeHighlights[1] = PageRight.GetElement<UIButtonImageHighlight>("Mid", "Teleport Fade Time Value");
		teleFadeButtons[1].OnTapUp += delegate
		{
			LR.Inst.saveDataSettings.teleportFadeSpeed = TeleportSettings.SpeedSetting.Medium;
			return UpdateFreemoveOptions(playSound: false, save: true);
		};
		teleFadeButtons[2] = PageRight.GetElement<UIButton>("Big", "Teleport Fade Time Value");
		teleFadeHighlights[2] = PageRight.GetElement<UIButtonImageHighlight>("Big", "Teleport Fade Time Value");
		teleFadeButtons[2].OnTapUp += delegate
		{
			LR.Inst.saveDataSettings.teleportFadeSpeed = TeleportSettings.SpeedSetting.Fast;
			return UpdateFreemoveOptions(playSound: false, save: true);
		};
		turnAmountButtons[0] = PageRight.GetElement<UIButton>("Small", "Turn Amount Value");
		turnAmountHighlights[0] = PageRight.GetElement<UIButtonImageHighlight>("Small", "Turn Amount Value");
		turnAmountButtons[0].OnTapUp += delegate
		{
			LR.Inst.saveDataSettings.turnAmount = TeleportSettings.TurnSetting.Small;
			return UpdateFreemoveOptions(playSound: false, save: true);
		};
		turnAmountButtons[1] = PageRight.GetElement<UIButton>("Mid", "Turn Amount Value");
		turnAmountHighlights[1] = PageRight.GetElement<UIButtonImageHighlight>("Mid", "Turn Amount Value");
		turnAmountButtons[1].OnTapUp += delegate
		{
			LR.Inst.saveDataSettings.turnAmount = TeleportSettings.TurnSetting.Medium;
			return UpdateFreemoveOptions(playSound: false, save: true);
		};
		turnAmountButtons[2] = PageRight.GetElement<UIButton>("Big", "Turn Amount Value");
		turnAmountHighlights[2] = PageRight.GetElement<UIButtonImageHighlight>("Big", "Turn Amount Value");
		turnAmountButtons[2].OnTapUp += delegate
		{
			LR.Inst.saveDataSettings.turnAmount = TeleportSettings.TurnSetting.Large;
			return UpdateFreemoveOptions(playSound: false, save: true);
		};
		moveFadeTextHeader = PageRight.GetElement<UITextbox>("Move Fade");
		moveFadeButtons[0] = PageRight.GetElement<UIButton>("None", "Move Fade Value");
		moveFadeHighlights[0] = PageRight.GetElement<UIButtonImageHighlight>("None", "Move Fade Value");
		moveFadeButtons[0].OnTapUp += delegate
		{
			LR.Inst.saveDataSettings.vignettePreset = TeleportSettings.VignettePresets.None;
			return UpdateFreemoveOptions(playSound: false, save: true);
		};
		moveFadeButtons[1] = PageRight.GetElement<UIButton>("Small", "Move Fade Value");
		moveFadeHighlights[1] = PageRight.GetElement<UIButtonImageHighlight>("Small", "Move Fade Value");
		moveFadeButtons[1].OnTapUp += delegate
		{
			LR.Inst.saveDataSettings.vignettePreset = TeleportSettings.VignettePresets.Preset1;
			return UpdateFreemoveOptions(playSound: false, save: true);
		};
		moveFadeButtons[2] = PageRight.GetElement<UIButton>("Mid", "Move Fade Value");
		moveFadeHighlights[2] = PageRight.GetElement<UIButtonImageHighlight>("Mid", "Move Fade Value");
		moveFadeButtons[2].OnTapUp += delegate
		{
			LR.Inst.saveDataSettings.vignettePreset = TeleportSettings.VignettePresets.Preset2;
			return UpdateFreemoveOptions(playSound: false, save: true);
		};
		moveFadeButtons[3] = PageRight.GetElement<UIButton>("Big", "Move Fade Value");
		moveFadeHighlights[3] = PageRight.GetElement<UIButtonImageHighlight>("Big", "Move Fade Value");
		moveFadeButtons[3].OnTapUp += delegate
		{
			LR.Inst.saveDataSettings.vignettePreset = TeleportSettings.VignettePresets.Preset3;
			return UpdateFreemoveOptions(playSound: false, save: true);
		};
		UpdateFreemoveOptions(playSound: false);
	}

	public override void ShowAll()
	{
		base.ShowAll();
		UpdateFreemoveOptions(playSound: false);
	}

	private bool UpdateFreemoveOptions(bool playSound = true, bool save = false)
	{
		if (save)
		{
			LR.Inst.Save();
		}
		string key = "";
		switch (LR.Inst.saveDataSettings.inputMode)
		{
		case TeleportSettings.Mode.DualInput:
			key = "NEXUS_UI_game_options_text_017";
			break;
		case TeleportSettings.Mode.Teleport:
			key = "NEXUS_UI_movement_text_003";
			break;
		}
		modeText.SetText(Localisation.Retrieve(key));
		modeText.Present();
		string key2 = "";
		switch (LR.Inst.saveDataSettings.freeMoveTurnType)
		{
		case TeleportSettings.FreeMoveRotateSetting.Snap:
			key2 = "NEXUS_UI_movement_text_005";
			break;
		case TeleportSettings.FreeMoveRotateSetting.Smooth:
			key2 = "NEXUS_UI_movement_text_006";
			break;
		}
		turnTypeText.SetText(Localisation.Retrieve(key2));
		turnTypeText.Present();
		if (LR.Inst.saveDataSettings.inputMode == TeleportSettings.Mode.Teleport)
		{
			speedTextHeader.Hide();
			for (int i = 0; i < walkSpeedButtons.Length; i++)
			{
				walkSpeedButtons[i].Hide();
			}
		}
		else
		{
			speedTextHeader.Show();
			walkSpeedHighlights[0].SetSwappedImage(LR.Inst.saveDataSettings.freeMoveSpeed == TeleportSettings.SpeedSetting.Slow);
			walkSpeedHighlights[1].SetSwappedImage(LR.Inst.saveDataSettings.freeMoveSpeed == TeleportSettings.SpeedSetting.Medium);
			walkSpeedHighlights[2].SetSwappedImage(LR.Inst.saveDataSettings.freeMoveSpeed == TeleportSettings.SpeedSetting.Fast);
			for (int j = 0; j < walkSpeedButtons.Length; j++)
			{
				walkSpeedButtons[j].Show();
			}
		}
		teleFadeHighlights[0].SetSwappedImage(LR.Inst.saveDataSettings.teleportFadeSpeed == TeleportSettings.SpeedSetting.Slow);
		teleFadeHighlights[1].SetSwappedImage(LR.Inst.saveDataSettings.teleportFadeSpeed == TeleportSettings.SpeedSetting.Medium);
		teleFadeHighlights[2].SetSwappedImage(LR.Inst.saveDataSettings.teleportFadeSpeed == TeleportSettings.SpeedSetting.Fast);
		turnAmountHighlights[0].SetSwappedImage(LR.Inst.saveDataSettings.turnAmount == TeleportSettings.TurnSetting.Small);
		turnAmountHighlights[1].SetSwappedImage(LR.Inst.saveDataSettings.turnAmount == TeleportSettings.TurnSetting.Medium);
		turnAmountHighlights[2].SetSwappedImage(LR.Inst.saveDataSettings.turnAmount == TeleportSettings.TurnSetting.Large);
		if (LR.Inst.saveDataSettings.inputMode == TeleportSettings.Mode.Teleport)
		{
			moveFadeTextHeader.Hide();
			for (int k = 0; k < moveFadeButtons.Length; k++)
			{
				moveFadeButtons[k].Hide();
			}
		}
		else
		{
			moveFadeTextHeader.Show();
			moveFadeHighlights[0].SetSwappedImage(LR.Inst.saveDataSettings.vignettePreset == TeleportSettings.VignettePresets.None);
			moveFadeHighlights[1].SetSwappedImage(LR.Inst.saveDataSettings.vignettePreset == TeleportSettings.VignettePresets.Preset1);
			moveFadeHighlights[2].SetSwappedImage(LR.Inst.saveDataSettings.vignettePreset == TeleportSettings.VignettePresets.Preset2);
			moveFadeHighlights[3].SetSwappedImage(LR.Inst.saveDataSettings.vignettePreset == TeleportSettings.VignettePresets.Preset3);
			for (int l = 0; l < moveFadeButtons.Length; l++)
			{
				moveFadeButtons[l].Show();
			}
		}
		if (playSound)
		{
			FAC.Inst.PlayOneShot(pauseMenu.soundMenuSelect, pauseMenu.transform.position);
		}
		return true;
	}

	public override bool ReturnMenu()
	{
		pauseMenu.SetPage(pauseMenu.options);
		return true;
	}
}
[Serializable]
public class UIPauseMenu_Options : UIBookPage
{
	private UIPauseMenu pauseMenu;

	private UIButton creditsButton;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		pauseMenu = UIPauseMenu.Inst;
		PageLeft.GetElement<UIButton>("Game").OnTapUp += delegate
		{
			pauseMenu.SetPage(pauseMenu.gameOptions);
			return true;
		};
		PageLeft.GetElement<UIButton>("Height Mode").OnTapUp += delegate
		{
			pauseMenu.SetPage(pauseMenu.heightAdjust);
			return true;
		};
		PageLeft.GetElement<UIButton>("Movement").OnTapUp += delegate
		{
			pauseMenu.SetPage(pauseMenu.movementOptions);
			return true;
		};
		PageLeft.GetElement<UIButton>("Back").OnTapUp += delegate
		{
			UIPauseMenu.Inst.CloseBook();
			return true;
		};
		creditsButton = PageLeft.GetElement<UIButton>("Credits");
		creditsButton.OnTapUp += delegate
		{
			LR.Inst.StopMusic();
			pauseMenu.SetCreditsTarget();
			pauseMenu.TeleportBehaviour();
			return true;
		};
	}

	public override void ShowAll()
	{
		base.ShowAll();
		if (pauseMenu.currentMenuType != SceneInfo.MenuType.Main && pauseMenu.currentMenuType != SceneInfo.MenuType.MainLimited)
		{
			creditsButton.Hide();
		}
	}

	public override bool ReturnMenu()
	{
		pauseMenu.CloseBook();
		return true;
	}
}
public class UISubButton : UIElement
{
	[HideInInspector]
	public UIButton parentButton;

	public override void OnAwakeLR()
	{
		base.OnAwakeLR();
		parentButton = base.gameObject.GetComponentInAscendant<UIButton>();
	}
}
public class UITutorial : UIContainer, IUpdateEvent, IGrabEvent
{
	public TextMesh Text;

	public float FollowSpeed = 0.05f;

	public float Height = 0.03f;

	public float DistanceFromPlayer = 0.8f;

	public Vector3 HeadOffset;

	public float FollowSpeedClose = 0.05f;

	public float HeightClose;

	public float DistanceFromPlayerClose = 0.48f;

	public Vector3 HeadOffsetClose;

	public GameObject[] TutorialSteps;

	[HideInInspector]
	public bool CloseToFace;

	private bool isGrabbing;

	private Rigidbody rb;

	private PortalingRigidbody portalRB;

	private Vector3 releaseVelocityLinear;

	private Vector3 releaseVelocityAngular;

	public static UITutorial Inst;

	public bool IsGrabbing => isGrabbing;

	public override Wait OnAwakeLR()
	{
		base.OnAwakeLR();
		Inst = this;
		rb = GetComponent<Rigidbody>();
		portalRB = GetComponent<PortalingRigidbody>();
		return Wait.PreMet;
	}

	void IGrabEvent.OnGrab(GrabObject obj)
	{
		isGrabbing = true;
	}

	void IGrabEvent.OnRelease()
	{
		isGrabbing = false;
		rb.isKinematic = true;
		releaseVelocityLinear = portalRB.GetLastVelocityLinear();
		releaseVelocityAngular = portalRB.GetLastVelocityAngular();
	}

	public void OnUpdateLR()
	{
		try
		{
			if (!isGrabbing)
			{
				RefreshPosition();
			}
		}
		catch
		{
		}
	}

	public void RefreshPosition()
	{
		float y = (CloseToFace ? HeightClose : Height);
		float z = (CloseToFace ? DistanceFromPlayerClose : DistanceFromPlayer);
		if (!CloseToFace)
		{
			_ = HeadOffset;
		}
		else
		{
			_ = HeadOffsetClose;
		}
		MenuPos menuPos = UIPauseMenu.CalculateMenuPosition(new Vector3(0f, y, z), Vector3.zero);
		Vector3 vector = IC.GetHeadPosition() - HeadOffset - menuPos.pos;
		menuPos.rot = Quaternion.LookRotation(-vector, CC.Inst.transform.up);
		Vector3 a = base.transform.position + releaseVelocityLinear * Time.deltaTime;
		Quaternion a2 = base.transform.rotation * Quaternion.Euler(releaseVelocityAngular);
		releaseVelocityLinear *= 1f - FollowSpeed;
		releaseVelocityAngular *= 1f - FollowSpeed;
		base.transform.position = Vector3.Lerp(a, menuPos.pos, FollowSpeed);
		base.transform.rotation = Quaternion.Lerp(a2, menuPos.rot, FollowSpeed);
	}

	public void ShowTutorialStep(int step)
	{
		for (int i = 0; i < TutorialSteps.Length; i++)
		{
			TutorialSteps[i].SetActive(value: false);
		}
		TutorialSteps[step].SetActive(value: true);
	}

	public void SetText(string text)
	{
		Text.text = text;
	}
}
public class MainHub_VO_Flow : MonoBehaviour, IAwakeEvent, IAreaEvent
{
	private MRBase owner;

	[Header("Milestone1")]
	public IDObjectRef batteryRef;

	public float batteryHintWait = 30f;

	[Header("Milestone3 -1")]
	public VO_Sequencer[] postPrincessVOSequencers;

	private BreakerSwitch breakerSwitch;

	public VO_Sequencer[] milestone3Sequencers;

	[Header("Milestone4")]
	public VO_Sequencer[] milestone4Sequencers;

	public VO_Sequencer[] milestone4HintSequencers;

	public float firstMeetingPushTimer = 180f;

	[Header("Milestone5")]
	public VO_Sequencer postFMSequencer;

	public float constructPushTimer = 180f;

	private IHaglet<GrabObject> grabBatteryRoutine;

	private IHaglet postMilestone4Routine;

	private IHaglet milestone5Routine;

	void IAwakeEvent.OnAwakeLR(MRBase owner)
	{
		this.owner = owner;
		breakerSwitch = owner.GetComponentInChildren<BreakerSwitch>();
		Haglet.Create(out grabBatteryRoutine, (Routine.Func1<GrabObject>)GrabBatteryRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out postMilestone4Routine, PostMilestone4Routine);
		Haglet.Create(out milestone5Routine, Milestone5Routine);
	}

	void IAreaEvent.OnAreaEnter()
	{
	}

	void IAreaEvent.OnAreaExit()
	{
		grabBatteryRoutine.Stop();
		postMilestone4Routine.Stop();
		milestone5Routine.Stop();
	}

	[Event(EventName = "Start Battery Hint")]
	private void GrabBatteryHint(object sender)
	{
		GrabObject grabObject = batteryRef.Get<GrabObject>(this);
		if ((bool)grabObject && !grabObject.hasBeenGrabbed && !grabBatteryRoutine.started)
		{
			grabBatteryRoutine.Start(grabObject);
		}
	}

	private IEnumerator<Routine.Yield> GrabBatteryRoutine(GrabObject battery)
	{
		while (!battery.hasBeenGrabbed)
		{
			yield return Wait.For.Seconds(batteryHintWait);
			yield return VOC.Inst.IsFree;
			if (!battery.hasBeenGrabbed)
			{
				VOC.Inst.QueueVO("NEXUS_VO_mansfield_hints_001");
				continue;
			}
			break;
		}
	}

	[Event(EventName = "Play Post Chapter VO")]
	public void OnPostChapter(object sender)
	{
		switch (LR.Inst.saveDataGame.lastchapterCompletedProgression)
		{
		case SaveDataGame.Chapter.Princess:
			PlayPostPrincessVO();
			break;
		case SaveDataGame.Chapter.Hunter:
		case SaveDataGame.Chapter.Stargazing:
		case SaveDataGame.Chapter.Escape:
			PlayMilestone3VO();
			break;
		case SaveDataGame.Chapter.Evilgate:
		case SaveDataGame.Chapter.Insanity:
		case SaveDataGame.Chapter.Death:
			PlayMilestone4VO();
			break;
		case SaveDataGame.Chapter.FirstMeeting:
			milestone5Routine.Start();
			break;
		}
	}

	private void PlayPostPrincessVO()
	{
		if (!postPrincessVOSequencers[0].IsComplete)
		{
			postPrincessVOSequencers[0].PlayNextVOSection();
		}
		else
		{
			_ = breakerSwitch.IsPowerOn;
		}
	}

	private void PlayMilestone3VO()
	{
		int num = -1;
		SaveDataGame saveDataGame = LR.Inst.saveDataGame;
		num += (saveDataGame.IsChapterFinished(SaveDataGame.Chapter.Hunter) ? 1 : 0);
		num += (saveDataGame.IsChapterFinished(SaveDataGame.Chapter.Stargazing) ? 1 : 0);
		num += (saveDataGame.IsChapterFinished(SaveDataGame.Chapter.Escape) ? 1 : 0);
		if (num != -1)
		{
			milestone3Sequencers[num].PlayNextVOSection();
		}
	}

	private void PlayMilestone4VO()
	{
		int num = -1;
		SaveDataGame saveDataGame = LR.Inst.saveDataGame;
		num += (saveDataGame.IsChapterFinished(SaveDataGame.Chapter.Evilgate) ? 1 : 0);
		num += (saveDataGame.IsChapterFinished(SaveDataGame.Chapter.Insanity) ? 1 : 0);
		num += (saveDataGame.IsChapterFinished(SaveDataGame.Chapter.Death) ? 1 : 0);
		switch (num)
		{
		case 2:
			if (!milestone4Sequencers[num].IsComplete)
			{
				postMilestone4Routine.Start();
			}
			break;
		case -1:
			return;
		}
		milestone4Sequencers[num].PlayNextVOSection();
	}

	private IEnumerator<Routine.Yield> PostMilestone4Routine()
	{
		while (true)
		{
			yield return Wait.For.Seconds(firstMeetingPushTimer);
			yield return VOC.Inst.IsFree;
			yield return Wait.For.Seconds(3f);
			VOC.Inst.QueueVO("NEXUS_VO_mansfield_hints_018");
			yield return VOC.Inst.IsFree;
			yield return Wait.For.Updates(1);
		}
	}

	private IEnumerator<Routine.Yield> Milestone5Routine()
	{
		yield return postFMSequencer.PlayNextVOSection();
		while (MainCamera.Inst.GetOwner() == owner)
		{
			yield return Wait.For.Seconds(constructPushTimer);
			yield return VOC.Inst.IsFree;
			yield return Wait.For.Seconds(3f);
			VOC.Inst.QueueVO("NEXUS_VO_mansfield_hints_019");
			yield return VOC.Inst.IsFree;
			yield return Wait.For.Updates(1);
		}
	}
}
public class VO_Asset : ScriptableObject
{
	[Serializable]
	public class VO_Section
	{
		public VOC.VOStore[] voiceLines;
	}

	public VO_Section[] voiceSections;
}
public class VO_Sequencer : IDObject, IAwakeEvent, ILateAwakeEvent, IPrepareEvent
{
	public Transform audioLocation;

	[LabelOverride("VO Asset")]
	public VO_Asset voAsset;

	public bool shuffle;

	public bool interrupts;

	public bool repeats;

	public bool autoSaveOnComplete;

	public float minSequencingDelay;

	public float maxSequencingDelay;

	public VOMarker marker;

	public FMODEventAsset musicOneShot;

	[ReadOnly]
	[SerializeField]
	private bool isComplete;

	private int[] sectionIndexOrder;

	private int currentSectionIndex;

	private HagletTrigger enabledStateChanged = new HagletTrigger();

	public Event OnComplete = new Event();

	private ConstArray<Event> ignoredEvents = new ConstArray<Event>(10u);

	private IHaglet sequencerRoutine;

	public bool IsComplete => isComplete;

	public int CurrentSectionIndex
	{
		get
		{
			return currentSectionIndex;
		}
		set
		{
			currentSectionIndex = value;
		}
	}

	private void Start()
	{
	}

	public override void OnAwakeLR(MRBase owner)
	{
		isComplete = LR.Inst.saveDataGame.GetVOSequencerComplete(id);
		if (voAsset == null)
		{
			base.enabled = false;
			return;
		}
		sectionIndexOrder = new int[voAsset.voiceSections.Length];
		for (int i = 0; i < sectionIndexOrder.Length; i++)
		{
			sectionIndexOrder[i] = i;
		}
		if (shuffle)
		{
			sectionIndexOrder.Shuffle();
		}
		Haglet.Create(out sequencerRoutine, SequencerRoutine);
	}

	Wait IPrepareEvent.PrepareEvents()
	{
		OnComplete.PrepareInvoke();
		return Wait.None;
	}

	void ILateAwakeEvent.OnLateAwakeLR()
	{
		if (isComplete)
		{
			OnComplete.Invoke();
		}
	}

	[Event(EventName = "Play Next VO Section")]
	public void PlayNextVOSection(object sender)
	{
		if (IsValidEventSource(sender))
		{
			PlayNextVOSection();
		}
	}

	[Event(EventName = "Resume Auto-Sequencing")]
	public void ResumeAutoSequencing(object sender)
	{
		if (!isComplete && IsValidEventSource(sender))
		{
			switch (sequencerRoutine.state)
			{
			case Haglet.State.Stopped:
				sequencerRoutine.Start();
				break;
			case Haglet.State.Paused:
				sequencerRoutine.Resume();
				break;
			}
		}
	}

	[Event(EventName = "Pause Auto-Sequencing")]
	public void PauseAutoSequencing(object sender)
	{
		if (!isComplete && IsValidEventSource(sender) && sequencerRoutine.state == Haglet.State.Started)
		{
			sequencerRoutine.Pause();
		}
	}

	[Event(EventName = "Set Ignored Trigger Source")]
	public void SetIgnoredTriggerSource(object sender)
	{
		if (!isComplete && IsValidEventSource(sender) && sender is Event obj)
		{
			ignoredEvents.Add(obj);
		}
	}

	[Event(EventName = "Set As Complete")]
	public void SetComplete(object sender)
	{
		if (!isComplete && IsValidEventSource(sender))
		{
			isComplete = true;
			OnComplete.Invoke();
			if (autoSaveOnComplete)
			{
				SaveAsComplete(this);
			}
		}
	}

	[Event(EventName = "Save As Complete")]
	public void SaveAsComplete(object sender)
	{
		LR.Inst.saveDataGame.SetVOSequencerComplete(id);
	}

	[Event(EventName = "Force Stop & Clear VOC")]
	public void ForceStopVOC(object sender)
	{
		VOC.Inst.VOStop(interruption: true);
	}

	[Event(EventName = "Set Enabled")]
	public void SetEnabled(object sender)
	{
		base.enabled = true;
		enabledStateChanged.Trigger();
	}

	[Event(EventName = "Set Disabled")]
	public void SetDisabled(object sender)
	{
		base.enabled = false;
		enabledStateChanged.Trigger();
	}

	private bool IsValidEventSource(object sender)
	{
		if (sender == this)
		{
			return true;
		}
		if (sender is Event objectT)
		{
			return !ignoredEvents.Contains(objectT);
		}
		return false;
	}

	public Wait PlayNextVOSection()
	{
		if (!base.enabled || isComplete)
		{
			return Wait.None;
		}
		VO_Asset.VO_Section vO_Section = voAsset.voiceSections[sectionIndexOrder[currentSectionIndex]];
		VOC.VOResult? vOResult = null;
		VOC.VOResult? vOResult2 = null;
		for (int i = 0; i < vO_Section.voiceLines.Length; i++)
		{
			VOC.VOStore vOStore = vO_Section.voiceLines[i];
			VOC.VOQueueProperty properties = ((!interrupts) ? VOC.VOQueueProperty.Queue : VOC.VOQueueProperty.Interrupt);
			vOResult = VOC.Inst.QueueVO(vOStore.line, properties, vOStore.delay, audioLocation);
			if (vOResult.Value.queueWasFull)
			{
				vOResult = vOResult2;
				break;
			}
			vOResult2 = vOResult;
		}
		currentSectionIndex++;
		if (currentSectionIndex == sectionIndexOrder.Length)
		{
			if (repeats)
			{
				currentSectionIndex = 0;
			}
			else
			{
				SetComplete(this);
			}
		}
		if (musicOneShot != null)
		{
			LR.Inst.PlayMusicOneShot(musicOneShot);
		}
		if (!vOResult.HasValue || vOResult.Value.onComplete == null)
		{
			return Wait.None;
		}
		return Wait.Until.Happening(vOResult.Value.onComplete);
	}

	private IEnumerator<Routine.Yield> SequencerRoutine()
	{
		while (!isComplete)
		{
			if (base.enabled)
			{
				float seconds = UnityEngine.Random.Range(minSequencingDelay, maxSequencingDelay);
				yield return Wait.For.Seconds(seconds);
				if (!isComplete)
				{
					yield return PlayNextVOSection();
				}
			}
			else
			{
				yield return enabledStateChanged;
			}
		}
	}
}
public class VO_Trigger_Area : VO_Trigger_BaseShuffle, ITriggerEvent
{
	void ITriggerEvent.OnTriggerAwakeLR(Trigger trigger)
	{
	}

	void ITriggerEvent.OnTriggerEnterLR()
	{
		if (base.enabled && requiredPuzzlesCompleted)
		{
			PlayVOLines();
			base.enabled = false;
		}
	}

	void ITriggerEvent.OnTriggerStayLR()
	{
	}

	void ITriggerEvent.OnTriggerExitLR()
	{
	}
}
public class VO_Trigger_AreaChronological : VO_Trigger_Base, ITriggerEvent
{
	void ITriggerEvent.OnTriggerAwakeLR(Trigger trigger)
	{
	}

	void ITriggerEvent.OnTriggerEnterLR()
	{
		if (base.enabled && requiredPuzzlesCompleted)
		{
			base.enabled = false;
		}
	}

	void ITriggerEvent.OnTriggerStayLR()
	{
	}

	void ITriggerEvent.OnTriggerExitLR()
	{
	}
}
public abstract class VO_Trigger_Base : MonoBehaviour, IAwakeEvent
{
	[Tooltip("The Transform that the audio should sound like it is playing from, if left blank it should default to the player's head position.")]
	public Transform audioLocation;

	[Tooltip("VO asset containing the VO lines for this trigger")]
	public VO_Asset asset;

	[Tooltip("References to puzzles that must be completed before this VO can trigger.")]
	public List<IDObjectRef> requiredCompletedPuzzles = new List<IDObjectRef>();

	public List<PuzzleInfo> requiredCompletedPuzzleInfos = new List<PuzzleInfo>();

	public VOMarker marker;

	protected bool requiredPuzzlesCompleted;

	protected int[] lineIndexOrder = new int[0];

	protected Action d_VOResult_OnComplete;

	public virtual void OnAwakeLR(MRBase owner)
	{
		if (asset == null)
		{
			base.enabled = false;
			return;
		}
		lineIndexOrder = new int[asset.voiceSections.Length];
		for (int i = 0; i < lineIndexOrder.Length; i++)
		{
			lineIndexOrder[i] = i;
		}
		SaveDataGame.PuzzleCompleted += Obelisk_PuzzleCompleted;
		EvaluateRequiredPuzzles();
		d_VOResult_OnComplete = VOResult_OnComplete;
	}

	protected virtual void OnRequiredPuzzlesCompleted()
	{
	}

	private void Obelisk_PuzzleCompleted()
	{
		if (!requiredPuzzlesCompleted)
		{
			EvaluateRequiredPuzzles();
			if (requiredPuzzlesCompleted)
			{
				OnRequiredPuzzlesCompleted();
			}
		}
	}

	private void EvaluateRequiredPuzzles()
	{
		bool flag = true;
		for (int i = 0; i < requiredCompletedPuzzleInfos.Count; i++)
		{
			if (!requiredCompletedPuzzleInfos[i].IsComplete(SaveDataGame.PuzzleSaveType.Scene))
			{
				flag = false;
			}
		}
		requiredPuzzlesCompleted = flag;
	}

	protected void PlayVOLines(bool disableMarker = true)
	{
		VOC.VOResult? vOResult = null;
		for (int i = 0; i < lineIndexOrder.Length; i++)
		{
			_ = lineIndexOrder[i];
			VO_Asset.VO_Section vO_Section = asset.voiceSections[i];
			for (int j = 0; j < vO_Section.voiceLines.Length; j++)
			{
				VOC.VOStore vOStore = vO_Section.voiceLines[j];
				vOResult = VOC.Inst.QueueVO(vOStore.line, VOC.VOQueueProperty.Queue, vOStore.delay, audioLocation);
			}
		}
		if (vOResult.HasValue && disableMarker && !vOResult.Value.queueWasFull)
		{
			vOResult.Value.onComplete.onPostHappen += VOResult_OnComplete;
		}
	}

	private void VOResult_OnComplete()
	{
		marker?.Disable();
	}

	public void OnDestroy()
	{
		SaveDataGame.PuzzleCompleted -= Obelisk_PuzzleCompleted;
	}
}
public abstract class VO_Trigger_BaseShuffle : VO_Trigger_Base
{
	[Tooltip("If true, voice lines in the list will play in a random order.")]
	public bool shuffleList;

	public override void OnAwakeLR(MRBase owner)
	{
		base.OnAwakeLR(owner);
		if (shuffleList)
		{
			lineIndexOrder.Shuffle();
		}
	}
}
public class VO_Trigger_LookAt : VO_Trigger_BaseShuffle, ITriggerEvent
{
	[Tooltip("Target Frustum Detector, found in children if left blank")]
	public FrustumDetector3D frustum;

	public override void OnAwakeLR(MRBase owner)
	{
		base.OnAwakeLR(owner);
		if (!frustum)
		{
			frustum = base.gameObject.GetComponentInChildren<FrustumDetector3D>();
		}
	}

	void ITriggerEvent.OnTriggerAwakeLR(Trigger trigger)
	{
	}

	void ITriggerEvent.OnTriggerEnterLR()
	{
		if (base.enabled && requiredPuzzlesCompleted && frustum.IsInViewBool)
		{
			PlayVOLines();
			base.enabled = false;
		}
	}

	void ITriggerEvent.OnTriggerStayLR()
	{
	}

	void ITriggerEvent.OnTriggerExitLR()
	{
	}
}
public class VO_Trigger_ObjectHeld : VO_Trigger_BaseShuffle, IGrabEvent
{
	void IGrabEvent.OnGrab(GrabObject obj)
	{
		if (base.enabled && requiredPuzzlesCompleted)
		{
			PlayVOLines();
			base.enabled = false;
		}
	}

	void IGrabEvent.OnRelease()
	{
	}
}
public class VO_Trigger_PuzzleComplete : VO_Trigger_Base
{
	protected override void OnRequiredPuzzlesCompleted()
	{
		PlayVOLines();
	}
}
public class VO_Trigger_PuzzleCompleteChronological : VO_Trigger_Base
{
	protected override void OnRequiredPuzzlesCompleted()
	{
	}
}
public class VO_Trigger_PuzzleHint : VO_Trigger_BaseShuffle, ITriggerEvent
{
	[Tooltip("The puzzle object which should be completed. Once completed, the hint will no longer play")]
	public IDObjectRef puzzle;

	[Tooltip("The puzzle object which should be completed. Once completed, the hint will no longer play")]
	public PuzzleInfo puzzleInfo;

	[Tooltip("The time player must remain in the trigger for the hint to play")]
	public float hintTime = 60f;

	void ITriggerEvent.OnTriggerAwakeLR(Trigger trigger)
	{
	}

	void ITriggerEvent.OnTriggerEnterLR()
	{
	}

	void ITriggerEvent.OnTriggerStayLR()
	{
		if (!base.enabled || !requiredPuzzlesCompleted)
		{
			return;
		}
		if (puzzleInfo.IsComplete(SaveDataGame.PuzzleSaveType.Scene))
		{
			base.enabled = false;
			return;
		}
		hintTime -= IC.DeltaTime;
		if (hintTime <= 0f)
		{
			PlayVOLines();
			base.enabled = false;
		}
	}

	void ITriggerEvent.OnTriggerExitLR()
	{
	}
}
public class AEMesh : ScriptableObject, IJK3DCustomMesh
{
	[HideInInspector]
	public Mesh serializedMesh;

	public static List<string> forceReimportPaths = new List<string>();

	[Header("UV2 Settings")]
	[Space]
	public bool UV2GenerateUVS;

	[Range(0f, 100f)]
	public int UV2PixelMargin = 8;

	[Range(0.0001f, 90f)]
	public float UV2HardAngle = 50f;

	[Range(0.01f, 1f)]
	public float UV2AngleError = 0.08f;

	[Range(0f, 1f)]
	public float UV2AreaError = 0.15f;

	public bool CopyUV2ToUV1;

	public Mesh GetMesh()
	{
		return serializedMesh;
	}

	public Material GetMaterial()
	{
		return null;
	}
}
public class AEMeshAsset : ScriptableObject
{
	public Mesh mesh;

	public Material material;
}
[Serializable]
public class AnimValue<T>
{
	public Action OnComplete;

	public Action OnInterrupted;

	public Func<float, float> Interpolate;

	public static readonly Func<float, float> Linear = (float x) => x;

	public T vStart;

	public T vEnd;

	public T vCurrent;

	private float animTime;

	private float animTimeMax = 1f;

	private float delayTime;

	public HagletFlag _animating = new HagletFlag();

	public HagletCondition animating => _animating;

	public float Duration => animTimeMax;

	public T Value
	{
		get
		{
			return vCurrent;
		}
		set
		{
			vCurrent = (vStart = (vEnd = value));
		}
	}

	public AnimValue()
	{
	}

	public AnimValue(T value)
	{
		AnimateTo(value, 0f);
	}

	public HagletCondition AnimateTo(T value, float duration, float delay = 0f)
	{
		_animating.set = true;
		if (!_animating.set)
		{
			vCurrent = (vStart = (vEnd = value));
		}
		if ((bool)animating && OnInterrupted != null)
		{
			OnInterrupted();
		}
		vStart = vCurrent;
		vEnd = value;
		animTime = (animTimeMax = duration);
		delayTime = delay;
		return animating;
	}

	private float _UpdateInternals(float step)
	{
		if (delayTime > 0f)
		{
			delayTime -= step;
		}
		else
		{
			if (animTimeMax <= 0f)
			{
				animTimeMax = 1f;
				animTime = 0f;
			}
			if (animTime > 0f)
			{
				animTime -= step;
			}
			else if ((bool)animating)
			{
				_animating.set = false;
				if (OnComplete != null)
				{
					OnComplete();
				}
			}
		}
		float num = 1f - animTime / animTimeMax;
		if (num > 1f)
		{
			num = 1f;
		}
		else if (num < 0f)
		{
			num = 0f;
		}
		if (Interpolate == null)
		{
			return Mathf.SmoothStep(0f, 1f, num);
		}
		return Interpolate(num);
	}

	public static Color Update(AnimValue<Color> @this)
	{
		return Update(@this, Time.deltaTime);
	}

	public static Color Update(AnimValue<Color> @this, float step)
	{
		return @this.vCurrent = Color.Lerp(@this.vStart, @this.vEnd, @this._UpdateInternals(step));
	}

	public static float Update(AnimValue<float> @this)
	{
		return Update(@this, Time.deltaTime);
	}

	public static float Update(AnimValue<float> @this, float step)
	{
		return @this.vCurrent = @this.vStart + (@this.vEnd - @this.vStart) * @this._UpdateInternals(step);
	}

	public static Vector2 Update(AnimValue<Vector2> @this)
	{
		return Update(@this, Time.deltaTime);
	}

	public static Vector2 Update(AnimValue<Vector2> @this, float step)
	{
		return @this.vCurrent = Vector2.Lerp(@this.vStart, @this.vEnd, @this._UpdateInternals(step));
	}

	public static Vector3 Update(AnimValue<Vector3> @this)
	{
		return Update(@this, Time.deltaTime);
	}

	public static Vector3 Update(AnimValue<Vector3> @this, float step)
	{
		return @this.vCurrent = Vector3.Lerp(@this.vStart, @this.vEnd, @this._UpdateInternals(step));
	}

	public static Vector4 Update(AnimValue<Vector4> @this)
	{
		return Update(@this, Time.deltaTime);
	}

	public static Vector4 Update(AnimValue<Vector4> @this, float step)
	{
		return @this.vCurrent = Vector4.Lerp(@this.vStart, @this.vEnd, @this._UpdateInternals(step));
	}

	public static Quaternion Update(AnimValue<Quaternion> @this)
	{
		return Update(@this, Time.deltaTime);
	}

	public static Quaternion Update(AnimValue<Quaternion> @this, float step)
	{
		return @this.vCurrent = Quaternion.Slerp(@this.vStart, @this.vEnd, @this._UpdateInternals(step));
	}

	public static ComplexAngle Update(AnimValue<ComplexAngle> @this)
	{
		return Update(@this, Time.deltaTime);
	}

	public static ComplexAngle Update(AnimValue<ComplexAngle> @this, float step)
	{
		return @this.vCurrent = ComplexAngle.Slerp(@this.vStart, @this.vEnd, @this._UpdateInternals(step));
	}

	public static T Update(AnimValue<T> @this)
	{
		return Update(@this, Time.deltaTime);
	}

	public static T Update(AnimValue<T> @this, float step)
	{
		throw new NotImplementedException();
	}
}
[Serializable]
public class AnimFuncQueue
{
	private struct Func
	{
		public float time;

		public Action func;

		public Action<object> funcWithUserData;

		public object userData;
	}

	private Func[] funcs;

	private uint funcsNum;

	public AnimFuncQueue(int maxSize = 2)
	{
		funcs = new Func[maxSize];
	}

	public void Update(float timeStep)
	{
		uint num = 0u;
		while (num < funcsNum)
		{
			if (funcs[num].time > 0f)
			{
				funcs[num].time -= timeStep;
				if (funcs[num].time < 0f)
				{
					if (funcs[num].func != null)
					{
						funcs[num].func();
					}
					else
					{
						funcs[num].funcWithUserData(funcs[num].userData);
					}
					funcsNum--;
					if (num != funcsNum)
					{
						funcs[num] = funcs[funcsNum];
						continue;
					}
				}
			}
			num++;
		}
	}

	public void Update()
	{
		Update(Time.deltaTime);
	}

	public void Queue(Action func, float time)
	{
		if (funcsNum == funcs.Length)
		{
			UnityEngine.Debug.LogError("AnimFuncQueue: Ran out of space!");
			return;
		}
		if (time < 0f)
		{
			func();
			return;
		}
		funcs[funcsNum].func = func;
		funcs[funcsNum].time = time;
		funcsNum++;
	}

	public void Queue(Action<object> func, float time, object userData)
	{
		if (funcsNum == funcs.Length)
		{
			UnityEngine.Debug.LogError("AnimFuncQueue: Ran out of space!");
			return;
		}
		if (time < 0f)
		{
			func(userData);
			return;
		}
		funcs[funcsNum].funcWithUserData = func;
		funcs[funcsNum].userData = userData;
		funcs[funcsNum].time = time;
		funcsNum++;
	}
}
internal static class AnimationX
{
	private static IHaglet<Animation, IHagletEvent, string, bool> playAnimManualRoutine;

	public static float GetAnimLength(this AnimationCurve curve)
	{
		if (curve == null)
		{
			return 0f;
		}
		if (curve.length == 0)
		{
			return 0f;
		}
		return curve[curve.length - 1].time;
	}

	public static Wait PlayAnim(Animation _anim, string _clipName = "", float blendTime = 0f, bool instant = false)
	{
		_clipName = (string.IsNullOrEmpty(_clipName) ? _anim.clip.name : _clipName);
		_anim.CrossFade(_clipName, blendTime);
		if (Routine.Skipping)
		{
			instant = true;
		}
		if (!instant)
		{
			_anim.CrossFade(_clipName, blendTime);
			return Wait.For.Seconds(_anim[_clipName].length);
		}
		_anim[_clipName].enabled = true;
		_anim[_clipName].normalizedTime = 1f;
		_anim[_clipName].weight = 1f;
		_anim.Sample();
		_anim[_clipName].enabled = false;
		return Wait.None;
	}

	private static IEnumerator<Routine.Yield> PlayAnimManualRoutine(Animation _anim, IHagletEvent updateEvent, string _clipName = "", bool instant = false)
	{
		_clipName = (string.IsNullOrEmpty(_clipName) ? _anim.clip.name : _clipName);
		if (Routine.Skipping)
		{
			instant = true;
		}
		_anim.Play(_clipName);
		if (instant)
		{
			_anim[_clipName].enabled = true;
			_anim[_clipName].normalizedTime = 1f;
			_anim[_clipName].weight = 1f;
			_anim.Sample();
			_anim[_clipName].enabled = false;
			yield break;
		}
		AnimationState state = _anim[_clipName];
		state.enabled = true;
		state.normalizedTime = 0f;
		state.weight = 1f;
		float time = 0f;
		float cliplength = state.length;
		while (time <= cliplength)
		{
			time += updateEvent.deltaTime;
			float normalizedTime = Mathf.Clamp01(time / cliplength);
			state.normalizedTime = normalizedTime;
			_anim.Sample();
			yield return Wait.Until.Happening(updateEvent) | Wait.Until.ArgChange(1);
		}
	}

	public static Wait PlayAnimManual(Animation _anim, IHagletEvent updateEvent, bool call, string _clipName = "", bool instant = false)
	{
		if (playAnimManualRoutine == null)
		{
			Haglet.Create(out playAnimManualRoutine, (Routine.Func4<Animation, IHagletEvent, string, bool>)PlayAnimManualRoutine, (string)null, startNow: false, (int?)null, (string)null);
		}
		if (call)
		{
			return playAnimManualRoutine.Call(_anim, updateEvent, _clipName, instant);
		}
		return playAnimManualRoutine.Start(_anim, updateEvent, _clipName, instant, resetIfStarted: true);
	}

	public static void ChangeAnimManualUpdate(IHagletEvent newUpdateEvent)
	{
		IHaglet<Animation, IHagletEvent, string, bool> haglet = playAnimManualRoutine;
		if (haglet != null && haglet.started)
		{
			playAnimManualRoutine.SetArg1(newUpdateEvent);
		}
	}

	public static void PauseAnimation(this Animation anim, string clipName)
	{
		AnimationState animationState = anim[clipName];
		animationState.enabled = false;
		animationState.speed = 0f;
		anim.enabled = false;
	}

	public static void ResumeAnimation(this Animation anim, string clipName)
	{
		anim.enabled = true;
		AnimationState animationState = anim[clipName];
		animationState.enabled = true;
		animationState.speed = 1f;
	}
}
public class FramerateTester : TestingBase
{
	[Serializable]
	public struct NodeInfo : ICSVWritable, IJUnitXMLWritable, IHorizontalCSVWritable
	{
		public float frameTime;

		public float targetFrameTime;

		public Vector3 worldPos;

		public Quaternion worldRotation;

		public string name;

		string IJUnitXMLWritable.Classname => name;

		string IJUnitXMLWritable.Name => worldPos.ToString();

		bool IJUnitXMLWritable.Valid
		{
			get
			{
				if (targetFrameTime > 0f)
				{
					return frameTime > 0f;
				}
				return false;
			}
		}

		bool IJUnitXMLWritable.Passed => frameTime <= targetFrameTime;

		float IJUnitXMLWritable.Time => frameTime;

		string IJUnitXMLWritable.FailureType => "Target Frametime exceeded";

		string IJUnitXMLWritable.FailureMessage => $"Expected:{targetFrameTime}, Actual: {frameTime}";

		string IJUnitXMLWritable.FailureText => string.Empty;

		public string ToCSVRecord()
		{
			return frameTime + ",\"" + worldPos.ToString() + "\",\"" + worldRotation.eulerAngles.ToString() + "\"";
		}

		public string GetNthRowValue(int row)
		{
			return row switch
			{
				0 => name, 
				1 => frameTime.ToString(), 
				2 => worldPos.ToString(), 
				_ => "INVALID_INDEX", 
			};
		}

		public Vector3 GetViewDirection()
		{
			return worldRotation * Vector3.forward;
		}
	}

	public bool showGizmos;

	[Tooltip("framerate below which gizmos will not be drawn. Only affects gizmo drawing.")]
	public float frameRateThreshold;

	public NodeInfo[] recordedFrames = new NodeInfo[0];

	[HideInInspector]
	public Vector3 currentPositionTested;

	[HideInInspector]
	public Quaternion currentRotationTested;

	[HideInInspector]
	public int horizontalRes;

	[HideInInspector]
	public int verticalRes;

	[HideInInspector]
	public int testFrames;

	public float targetFPS;

	private Quaternion rightRotation;

	private Quaternion[] startRotations;

	private Vector3[] testNodes;

	private Transform cameraTransform;

	private int frameArrayIndex;

	private int[] horizontalFieldsToWrite;

	private IHaglet<Camera, float, string> testActiveScene;

	private IHaglet<Camera, string> testAllNodes;

	private IHaglet<Vector3, Quaternion> testSinglePosition;

	public static FramerateTester Inst { get; private set; }

	public override string kFileNamePostfix => "_perfData";

	public override string kLocalOutputPath => "/PerformanceData/";

	public override bool IsTesting
	{
		get
		{
			if (!testSinglePosition.started && !testActiveScene.started)
			{
				return testAllNodes.started;
			}
			return true;
		}
	}

	protected void Awake()
	{
		if (Inst != null)
		{
			UnityEngine.Object.Destroy(Inst);
		}
		Inst = this;
		Haglet.Create(out testAllNodes, (Routine.Func2<Camera, string>)TestAllNodesRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out testSinglePosition, (Routine.Func2<Vector3, Quaternion>)TestSinglePositionRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out testActiveScene, (Routine.Func3<Camera, float, string>)TestActiveSceneRoutine, (string)null, startNow: false, (int?)null, (string)null);
	}

	protected void OnDestroy()
	{
		if (Inst == this)
		{
			Inst = null;
		}
	}

	public void Initialise(Vector3[] positions, int horizontal, int vertical, int frames, int[] horizontalFields = null)
	{
		horizontalRes = horizontal;
		verticalRes = vertical;
		testFrames = frames;
		testNodes = positions;
		InitialiseRotations();
		horizontalFieldsToWrite = horizontalFields;
	}

	private void InitialiseRotations()
	{
		rightRotation = Quaternion.Euler(0f, 360 / verticalRes, 0f);
		startRotations = new Quaternion[horizontalRes + 2];
		recordedFrames = new NodeInfo[startRotations.Length * verticalRes * testNodes.Length * testFrames];
		for (int i = 0; i <= horizontalRes; i++)
		{
			float x = i * 180 / (horizontalRes + 1) - 90;
			startRotations[i] = Quaternion.Euler(x, 0f, 0f);
		}
		startRotations[horizontalRes + 1] = Quaternion.Euler(90f, 0f, 0f);
	}

	public void RunTest(Camera camera, float delay = 0f, string fileName = null)
	{
		testActiveScene.Start(camera, delay, fileName);
	}

	public Wait RunTestYield(Camera camera, float delay = 0f, string fileName = null)
	{
		return testActiveScene.Call(camera, delay, fileName);
	}

	private IEnumerator<Routine.Yield> TestActiveSceneRoutine(Camera camera, float delay = 0f, string fileName = null)
	{
		UnityEngine.Debug.Log("Testing: " + fileName);
		if (delay > 0f)
		{
			yield return Wait.For.RealSeconds(delay);
		}
		GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced);
		GC.WaitForPendingFinalizers();
		yield return testAllNodes.Call(camera, fileName);
		cameraTransform.localPosition = Vector3.up;
		cameraTransform.localRotation = Quaternion.identity;
	}

	private IEnumerator<Routine.Yield> TestAllNodesRoutine(Camera camera, string fileName = null)
	{
		if (testFrames < 1)
		{
			UnityEngine.Debug.LogError("Failed Performance Test, testFrames was zero");
			yield return Wait.For.LRRealtimeUpdates(3);
			yield break;
		}
		cameraTransform = camera.transform;
		frameArrayIndex = 0;
		for (int i = 0; i < testNodes.Length; i++)
		{
			cameraTransform.position = testNodes[i];
			for (int j = 0; j < startRotations.Length; j++)
			{
				cameraTransform.rotation = startRotations[j];
				yield return testSinglePosition.Call(testNodes[i], startRotations[j]);
			}
		}
		_ = 1f / targetFPS;
		for (int k = 0; k < recordedFrames.Length; k++)
		{
			recordedFrames[k].name = fileName;
			recordedFrames[k].targetFrameTime = targetFPS;
		}
	}

	private IEnumerator<Routine.Yield> TestSinglePositionRoutine(Vector3 position, Quaternion rotation)
	{
		Quaternion currentRotation = rotation;
		currentPositionTested = position;
		for (int j = 0; j < verticalRes; j++)
		{
			currentRotation = rightRotation * currentRotation;
			recordedFrames[frameArrayIndex].worldPos = position;
			recordedFrames[frameArrayIndex].worldRotation = currentRotation;
			double totalFrameTime = 0.0;
			for (int i = 0; i < testFrames; i++)
			{
				totalFrameTime += (double)Time.unscaledDeltaTime;
				cameraTransform.position = position;
				cameraTransform.rotation = currentRotation;
				currentRotationTested = currentRotation;
				yield return Wait.For.LRRealtimeUpdates(1);
			}
			recordedFrames[frameArrayIndex].frameTime = (float)(totalFrameTime / (double)testFrames);
			frameArrayIndex++;
		}
	}

	public void WriteStatsToCSV(string fileName)
	{
		List<NodeInfo> list = new List<NodeInfo>(recordedFrames);
		list.RemoveAll((NodeInfo rf) => rf.frameTime <= 0f);
		list.Sort((NodeInfo f1, NodeInfo f2) => (f1.frameTime > f2.frameTime) ? 1 : (-1));
		float frameTime = list[(int)((float)(list.Count / 2) + 0.5f)].frameTime;
		float frameTime2 = list[(int)((float)list.Count / 4f + 0.5f)].frameTime;
		float frameTime3 = list[(int)((float)list.Count / 4f + (float)list.Count / 2f + 0.5f)].frameTime;
		float frameTime4 = list[list.Count - 1].frameTime;
		float frameTime5 = list[0].frameTime;
		float num = 0f;
		for (int i = 0; i < list.Count; i++)
		{
			num += list[i].frameTime;
		}
		num /= (float)list.Count;
		fileName = fileName.Replace(" ", "");
		using StreamWriter streamWriter = new StreamWriter(new FileStream(GetUniqueFilePath(".CSV", "FTEST_" + fileName), FileMode.Create, FileAccess.Write, FileShare.ReadWrite));
		streamWriter.WriteLine("\"Max\",\"Min\",\"Upper Quartile\",\"LowerQuartile\",\"Median\",\"Average\"");
		streamWriter.WriteLine(frameTime4 + "," + frameTime5 + "," + frameTime3 + "," + frameTime2 + "," + frameTime + "," + num);
	}

	public void WriteToFiles(OutputFileType fileType, string fileName)
	{
		try
		{
			if (fileType.HasFlag(OutputFileType.Binary))
			{
				UnityEngine.Debug.Log("Writing to binary");
				WriteToBinaryFile(recordedFrames, fileName);
			}
			if (fileType.HasFlag(OutputFileType.CSV))
			{
				UnityEngine.Debug.Log("Writing to CSV");
				WriteToCSV(recordedFrames, fileName);
			}
			if (fileType.HasFlag(OutputFileType.XML))
			{
				UnityEngine.Debug.Log("Writing to XML");
				WriteToJUnitXML(recordedFrames, fileName);
			}
			if (fileType.HasFlag(OutputFileType.HorizontalCSV))
			{
				UnityEngine.Debug.Log("Writing to Horizontal CSV");
				WriteToHorizontalCSV(recordedFrames, "H_" + fileName, horizontalFieldsToWrite);
			}
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogError("Writing to file failed!");
			UnityEngine.Debug.LogException(exception);
		}
	}

	public bool LoadSavedBinary(string path)
	{
		return TestingBase.LoadBinaryFileAsStructs<NodeInfo>(path, out recordedFrames);
	}
}
public class FramerateTestNode : MonoBehaviour
{
}
[CreateAssetMenu(fileName = "FramerateTestSettings", menuName = "Nexus Settings/Framerate Test Settings")]
public class FramerateTestSettings : BaseSettings<FramerateTestSettings>
{
	public SceneInfoGroup[] sceneGroupsToTest;

	public SceneInfo[] individualScenesToTest;

	public float positionsPerUnit = 0.2f;

	public int targetFPS = 72;

	public int horizontalOrientations = 3;

	public int verticalOrientations = 3;

	public int framesToTest = 10;

	[EnumFlagsField]
	public TestingBase.OutputFileType outputFileType;

	public int[] horizontalCSVFields = new int[2] { 0, 2 };
}
public abstract class TestingBase : MonoBehaviour
{
	public interface ICSVWritable
	{
		string ToCSVRecord();
	}

	public interface IHorizontalCSVWritable
	{
		string GetNthRowValue(int row);
	}

	public interface IJUnitXMLWritable
	{
		string Classname { get; }

		string Name { get; }

		bool Passed { get; }

		bool Valid { get; }

		float Time { get; }

		string FailureType { get; }

		string FailureMessage { get; }

		string FailureText { get; }
	}

	[Flags]
	public enum OutputFileType
	{
		None = 0,
		Binary = 1,
		CSV = 2,
		XML = 4,
		HorizontalCSV = 8,
		All = 0xF
	}

	public abstract string kLocalOutputPath { get; }

	public abstract string kFileNamePostfix { get; }

	public abstract bool IsTesting { get; }

	protected void WriteToBinaryFile<T>(T[] structArray, string fileName = null) where T : struct
	{
		UnityEngine.Debug.Log("writing " + structArray.Length + " to binary");
		using Stream stream = File.OpenWrite(GetUniqueFilePath(".bin", fileName));
		int count = Marshal.SizeOf(typeof(T));
		for (int i = 0; i < structArray.Length; i++)
		{
			UnityEngine.Debug.Log("Writing: " + i);
			stream.Write(Serialize(structArray[i]), 0, count);
		}
	}

	protected void WriteToCSV<T>(T[] structArray, string fileName = null) where T : struct, ICSVWritable
	{
		using StreamWriter streamWriter = new StreamWriter(new FileStream(GetUniqueFilePath(".CSV", fileName), FileMode.Create, FileAccess.Write, FileShare.ReadWrite));
		for (int i = 0; i < structArray.Length; i++)
		{
			streamWriter.WriteLine(structArray[i].ToCSVRecord());
		}
	}

	protected void WriteToJUnitXML<T>(T[] structArray, string fileName) where T : struct, IJUnitXMLWritable
	{
		FileStream stream = new FileStream(GetUniqueFilePath(".xml", fileName), FileMode.Create, FileAccess.Write, FileShare.ReadWrite);
		string text = "";
		int num = 0;
		float num2 = 0f;
		for (int i = 0; i < structArray.Length; i++)
		{
			if (structArray[i].Valid)
			{
				bool passed = structArray[i].Passed;
				float time = structArray[i].Time;
				string text2 = $"<testcase classname=\"{structArray[i].Classname} \" name=\"{structArray[i].Name}\"  time=\"{time}\"";
				num2 += time;
				if (passed)
				{
					text2 += "/>\n";
				}
				else
				{
					num++;
					text2 += ">\n";
					text2 = text2 + "<failure type=\"" + structArray[i].FailureType + "\" message = \"" + structArray[i].FailureMessage + "\">" + structArray[i].FailureText + "</failure>";
					text2 += "</testcase>\n";
				}
				text += text2;
			}
		}
		string text3 = $"<testsuite name=\"{fileName}\" tests=\"{structArray.Length}\" failures=\"{num}\" time =\"{num2}\">";
		text3 = text3 + "\n" + text + "</testsuite>";
		using StreamWriter streamWriter = new StreamWriter(stream);
		streamWriter.Write(text3);
	}

	protected void WriteToHorizontalCSV<T>(T[] structArray, string fileName, int[] layersToWrite) where T : struct, IHorizontalCSVWritable
	{
		fileName = fileName.Replace(" ", "");
		using StreamWriter streamWriter = new StreamWriter(new FileStream(GetUniqueFilePath(".CSV", fileName), FileMode.Create, FileAccess.Write, FileShare.ReadWrite));
		for (int i = 0; i < layersToWrite.Length; i++)
		{
			for (int j = 0; j < structArray.Length; j++)
			{
				if (j < structArray.Length - 1)
				{
					streamWriter.Write(structArray[j].GetNthRowValue(layersToWrite[i]) + ",");
				}
				else
				{
					streamWriter.WriteLine(structArray[j].GetNthRowValue(layersToWrite[i]));
				}
			}
		}
	}

	protected virtual string GetFilePathWithoutExtension(string fileName)
	{
		string text = ((fileName != null) ? fileName : SceneManager.GetActiveScene().name);
		string text2 = UnityEngine.Application.persistentDataPath + kLocalOutputPath;
		if (!Directory.Exists(text2))
		{
			Directory.CreateDirectory(text2);
		}
		return text2 + text + kFileNamePostfix;
	}

	protected string GetUniqueFilePath(string extension, string fileName)
	{
		string text = GetFilePathWithoutExtension(fileName) + extension;
		int num = 0;
		while (File.Exists(text))
		{
			num++;
			text = GetFilePathWithoutExtension(fileName) + "_" + num + extension;
		}
		return text;
	}

	public static bool LoadBinaryFileAsStructs<T>(string path, out T[] outputArray) where T : struct
	{
		if (!File.Exists(path))
		{
			outputArray = null;
			return false;
		}
		byte[] array = new byte[Marshal.SizeOf(typeof(T))];
		using (Stream stream = File.OpenRead(path))
		{
			int num = (int)(stream.Length / array.Length);
			outputArray = new T[num];
			int num2 = 0;
			while (stream.Read(array, 0, array.Length) == array.Length)
			{
				outputArray[num2] = Deserialize<T>(array);
				num2++;
			}
		}
		if (outputArray == null || outputArray.Length == 0)
		{
			return false;
		}
		return true;
	}

	public static byte[] Serialize<T>(T s) where T : struct
	{
		int num = Marshal.SizeOf(typeof(T));
		byte[] array = new byte[num];
		IntPtr intPtr = Marshal.AllocHGlobal(num);
		try
		{
			Marshal.StructureToPtr(s, intPtr, fDeleteOld: true);
			Marshal.Copy(intPtr, array, 0, num);
			return array;
		}
		finally
		{
			Marshal.FreeHGlobal(intPtr);
		}
	}

	public static byte[] SerializeNonAlloc<T>(T s, byte[] array) where T : struct
	{
		int num = Marshal.SizeOf(typeof(T));
		if (num != array.Length)
		{
			UnityEngine.Debug.LogError("Serialize failed: mismatch between supplied array length and struct size");
			return null;
		}
		IntPtr intPtr = Marshal.AllocHGlobal(num);
		try
		{
			Marshal.StructureToPtr(s, intPtr, fDeleteOld: true);
			Marshal.Copy(intPtr, array, 0, num);
			return array;
		}
		finally
		{
			Marshal.FreeHGlobal(intPtr);
		}
	}

	public static T Deserialize<T>(byte[] array) where T : struct
	{
		int num = Marshal.SizeOf(typeof(T));
		if (num != array.Length)
		{
			UnityEngine.Debug.LogError("Deserialize failed: mismatch between supplied array length and struct size");
			return new T();
		}
		IntPtr intPtr = Marshal.AllocHGlobal(num);
		try
		{
			Marshal.Copy(array, 0, intPtr, num);
			return (T)Marshal.PtrToStructure(intPtr, typeof(T));
		}
		finally
		{
			Marshal.FreeHGlobal(intPtr);
		}
	}
}
public class PreBuildRemoveComponentAttribute : Attribute
{
}
public class PrebuildRemoveGameobject : ValidationIgnore
{
}
public abstract class _SafeRef
{
}
public class SafeRef<T> : _SafeRef where T : UnityEngine.Object
{
	[SerializeField]
	private T _value;

	[SerializeField]
	private string path;

	public T Value
	{
		get
		{
			return _value;
		}
		set
		{
			_value = value;
		}
	}
}
[Serializable]
public class GameObject_SafeRef : SafeRef<GameObject>
{
}
[Serializable]
public class Transform_SafeRef : SafeRef<Transform>
{
}
[Serializable]
public class AnimationClip_SafeRef : SafeRef<AnimationClip>
{
}
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Property | AttributeTargets.Field, Inherited = true)]
public class ConditionalHideAttribute : PropertyAttribute
{
	public string ConditionalSourceField = "";

	public string ConditionalSourceField2 = "";

	public bool HideInInspector = true;

	public bool Inverse;

	public int targetEnumValue;

	public ConditionalHideAttribute(string conditionalSourceField)
	{
		ConditionalSourceField = conditionalSourceField;
		HideInInspector = true;
		Inverse = false;
	}

	public ConditionalHideAttribute(string conditionalSourceField, bool hideInInspector)
	{
		ConditionalSourceField = conditionalSourceField;
		HideInInspector = hideInInspector;
		Inverse = false;
	}

	public ConditionalHideAttribute(string conditionalSourceField, bool hideInInspector, bool inverse)
	{
		ConditionalSourceField = conditionalSourceField;
		HideInInspector = hideInInspector;
		Inverse = inverse;
	}

	public ConditionalHideAttribute(string conditionalSourceField, bool hideInInspector, int targetEnumValue)
	{
		ConditionalSourceField = conditionalSourceField;
		HideInInspector = hideInInspector;
		this.targetEnumValue = targetEnumValue;
	}

	public ConditionalHideAttribute(bool hideInInspector = true)
	{
		ConditionalSourceField = "";
		HideInInspector = hideInInspector;
		Inverse = false;
	}
}
public class LabelOverrideAttribute : PropertyAttribute
{
	public string label;

	public LabelOverrideAttribute(string label)
	{
		this.label = label;
	}
}
public class NonSceneAssetAttribute : PropertyAttribute
{
}
public class ReadOnlyAtRuntimeAttribute : PropertyAttribute
{
}
public class ReadOnlyAttribute : PropertyAttribute
{
}
[PreBuildRemoveComponent]
public class AlignToSurfaceNormal : MonoBehaviour
{
	public enum AlignmentAxis
	{
		FORWARD,
		BACKWARD,
		UP,
		DOWN,
		LEFT,
		RIGHT
	}

	private class Triangle
	{
		public Vector3 vert1;

		public Vector3 vert2;

		public Vector3 vert3;

		public Triangle(Vector3 v1, Vector3 v2, Vector3 v3)
		{
			vert1 = v1;
			vert2 = v2;
			vert3 = v3;
		}
	}

	public AlignmentAxis axis;

	public bool setsPosition;

	[ConditionalHide("setsPosition")]
	public float positionOffset = 0.001f;
}
public class DebugBoxCollider : MonoBehaviour
{
	[Range(0f, 1f)]
	public float alpha = 0.3f;

	private void OnDrawGizmos()
	{
		BoxCollider component = GetComponent<BoxCollider>();
		if ((bool)component)
		{
			Gizmos.matrix = base.transform.localToWorldMatrix;
			Color green = Color.green;
			green.a = alpha;
			Gizmos.color = green;
			Gizmos.DrawCube(component.center, component.size);
		}
	}
}
public class DebugViewMesh : MonoBehaviour
{
	public enum Type
	{
		Normals
	}

	public Type type;

	private Mesh mesh;

	public void OnDrawGizmosSelected()
	{
		if (!mesh)
		{
			MeshFilter component = GetComponent<MeshFilter>();
			if ((bool)component)
			{
				mesh = component.sharedMesh;
			}
			return;
		}
		Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
		for (int i = 0; i < mesh.vertexCount; i++)
		{
			Vector3 start = localToWorldMatrix.MultiplyPoint3x4(mesh.vertices[i]);
			if (type == Type.Normals)
			{
				Vector3 vector = mesh.normals[i];
				UnityEngine.Debug.DrawRay(start, localToWorldMatrix * new Vector4(vector.x, vector.y, vector.z, 0f) * 0.1f, Color.green, 0f, depthTest: true);
			}
		}
	}
}
public class DebugViewXForm : MonoBehaviour
{
	public float scale = 0.1f;
}
public class GizmoMeshCollider : MonoBehaviour
{
}
public class GizmoSphere : MonoBehaviour
{
	public Color color = Color.white;

	public float radius = 0.1f;

	public bool showForward;
}
[PreBuildRemoveComponent]
[ExecuteInEditMode]
public class Snap : MonoBehaviour
{
	public float scale = 0.1f;

	public Vector3 offset = new Vector3(0f, 0f, 0f);
}
public class EnumFlagsFieldAttribute : PropertyAttribute
{
}
public class FMODBankAsset : FMODBaseAsset
{
	public string bankFilePath;
}
[Serializable]
public class FMODBankRef : SafeRef<FMODBankAsset>
{
}
public class FMODBaseAsset : ScriptableObject
{
	[ReadOnly]
	public string path;

	[SerializeField]
	private string fmodGUIDStr;

	private Guid? _fmodGUID;

	public Guid fmodGUID
	{
		get
		{
			if (!_fmodGUID.HasValue)
			{
				_fmodGUID = new Guid(fmodGUIDStr);
			}
			return _fmodGUID.Value;
		}
		set
		{
			if (_fmodGUID != value)
			{
				_fmodGUID = value;
				fmodGUIDStr = _fmodGUID.ToString();
			}
		}
	}

	public override bool Equals(object o)
	{
		FMODBaseAsset fMODBaseAsset = o as FMODBaseAsset;
		if (fMODBaseAsset != null)
		{
			return fmodGUID.Equals(fMODBaseAsset.fmodGUID);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return fmodGUID.GetHashCode();
	}

	public override string ToString()
	{
		return path + " " + fmodGUIDStr;
	}
}
public class FMODBusAsset : FMODBaseAsset
{
	[Serializable]
	public class FMODBusRef : SafeRef<FMODBusAsset>
	{
	}

	public Bus GetInstance(FMOD.Studio.System sys)
	{
		sys.getBusByID(base.fmodGUID, out var bus);
		return bus;
	}
}
public class FMODEventAsset : FMODBaseAsset
{
	public EventDescription GetDescription(FMOD.Studio.System sys)
	{
		sys.getEventByID(base.fmodGUID, out var _event);
		if (!_event.isValid())
		{
			sys.getEvent(path, out _event);
		}
		return _event;
	}

	public FMOD.Studio.EventInstance GetInstance(FMOD.Studio.System sys)
	{
		GetDescription(sys).createInstance(out var instance);
		return instance;
	}
}
[Serializable]
public class FMODEventRef : SafeRef<FMODEventAsset>
{
}
public class FMODSnapshotAsset : FMODBaseAsset
{
	public EventDescription GetDescription(FMOD.Studio.System sys)
	{
		sys.getEventByID(base.fmodGUID, out var _event);
		return _event;
	}

	public FMOD.Studio.EventInstance GetInstance(FMOD.Studio.System sys)
	{
		GetDescription(sys).createInstance(out var instance);
		return instance;
	}
}
[Serializable]
public class FMODSnapshotRef : SafeRef<FMODSnapshotAsset>
{
}
public class FMODVCAAsset : FMODBaseAsset
{
}
[Serializable]
public class FMODVCARef : SafeRef<FMODVCAAsset>
{
}
public static class FMODInitEnums
{
	[Flags]
	public enum LowLevelInitFlags
	{
		Normal = 0,
		StreamFromUpdate = 1,
		MixFromUpdate = 2,
		Righthanded3D = 4,
		ChannelLowpass = 0x100,
		ChannelDistanceFilter = 0x200,
		ProfileEnable = 0x10000,
		Vol0BecomesVirtual = 0x20000,
		GeometryUseClosest = 0x40000,
		PreferDolbyDownmix = 0x80000,
		ThreadUnsafe = 0x100000,
		ProfileMeterAll = 0x200000
	}

	[Flags]
	public enum StudioInitFlags
	{
		Normal = 0,
		LiveUpdate = 1,
		AllowMissingPlugins = 2,
		SynchronousUpdate = 4
	}

	public static LowLevelInitFlags ToUnityLLIF(this FMOD.INITFLAGS fmodllif)
	{
		return (LowLevelInitFlags)fmodllif;
	}

	public static FMOD.INITFLAGS ToFMODLLIF(this LowLevelInitFlags unityllif)
	{
		return (FMOD.INITFLAGS)unityllif;
	}

	public static StudioInitFlags ToUnitySIF(this FMOD.Studio.INITFLAGS fmodsif)
	{
		return (StudioInitFlags)fmodsif;
	}

	public static FMOD.Studio.INITFLAGS ToFMODSIF(this StudioInitFlags unitysif)
	{
		return (FMOD.Studio.INITFLAGS)unitysif;
	}
}
public class FAC : MonoBehaviour
{
	private class _ShutdownWorkerThread : MonoBehaviour
	{
		private const int timeout = 3500;

		private void OnApplicationQuit()
		{
			lock (workerThreadSignal)
			{
				workerThreadRun = false;
				workerThreadTask = null;
				workerThreadSignal.Set();
			}
			if (!workerThread.Join(3500))
			{
				UnityEngine.Debug.LogError(workerThread.Name + " did not terminate after " + 3500 + "ms.");
			}
		}
	}

	public delegate void BankLoadCallback(Bank bank, LOADING_STATE bankState, LOADING_STATE sampleState);

	private struct DelayedEventInstance
	{
		private readonly FMOD.Studio.EventInstance evt;

		private readonly float activationTime;

		private readonly Transform parent;

		public DelayedEventInstance(FMOD.Studio.EventInstance evt, float delay, Transform parent = null)
		{
			this.evt = evt;
			activationTime = Time.time + delay;
			this.parent = parent;
		}

		public bool Update(float currentTime)
		{
			if (!evt.isValid())
			{
				return true;
			}
			if (currentTime >= activationTime)
			{
				evt.start();
				evt.release();
				if (parent != null)
				{
					Inst.RegisterTrackedEvent(evt, parent);
				}
				return true;
			}
			return false;
		}
	}

	private struct TrackedEventInstance
	{
		private readonly FMOD.Studio.EventInstance evt;

		private Transform parent;

		public TrackedEventInstance(FMOD.Studio.EventInstance evt, Transform parent)
		{
			this.evt = evt;
			this.parent = parent;
		}

		public void SetParent(Transform parent)
		{
			this.parent = parent;
		}

		public Transform GetParent()
		{
			return parent;
		}

		public bool Update()
		{
			bool flag = evt.isValid();
			if (!flag || parent == null)
			{
				if (flag)
				{
					evt.stop(STOP_MODE.ALLOWFADEOUT);
				}
				parent = null;
				return true;
			}
			parent.rotation.GetAxes(out var _, out var up, out var fowrard);
			ATTRIBUTES_3D attributes = default(ATTRIBUTES_3D);
			attributes.up.x = up.x;
			attributes.up.y = up.y;
			attributes.up.z = up.z;
			attributes.forward.x = fowrard.x;
			attributes.forward.y = fowrard.y;
			attributes.forward.z = fowrard.z;
			Vector3 position = parent.position;
			attributes.position.x = position.x;
			attributes.position.y = position.y;
			attributes.position.z = position.z;
			attributes.velocity.x = (attributes.velocity.y = (attributes.velocity.z = 0f));
			evt.set3DAttributes(attributes);
			return false;
		}

		public void Stop()
		{
			if (evt.isValid())
			{
				evt.stop(STOP_MODE.ALLOWFADEOUT);
			}
		}
	}

	private class EventInstanceEQ : EqualityComparer<FMOD.Studio.EventInstance>
	{
		public override bool Equals(FMOD.Studio.EventInstance x, FMOD.Studio.EventInstance y)
		{
			return x.Equals(y);
		}

		public override int GetHashCode(FMOD.Studio.EventInstance evt)
		{
			return evt.GetHashCode();
		}
	}

	private struct GuidAOT
	{
		public class GuidEQ : EqualityComparer<GuidAOT>
		{
			public override bool Equals(GuidAOT x, GuidAOT y)
			{
				return x.theGuid.Equals(y.theGuid);
			}

			public override int GetHashCode(GuidAOT obj)
			{
				return obj.theGuid.GetHashCode();
			}
		}

		private Guid theGuid;

		private GuidAOT(Guid theGuid)
		{
			this.theGuid = theGuid;
		}

		public static implicit operator Guid(GuidAOT guidAOT)
		{
			return guidAOT.theGuid;
		}

		public static implicit operator GuidAOT(Guid guidSys)
		{
			return new GuidAOT(guidSys);
		}
	}

	private struct LoadingTracker
	{
		private readonly Bank bank;

		private readonly BankLoadCallback callback;

		private bool unloadBank;

		private bool completeLoadUnload;

		public LoadingTracker(FMOD.Studio.System sys, string bankPath, bool incSampleData, BankLoadCallback callback)
		{
			RESULT rESULT = sys.loadBankFile(bankPath, LOAD_BANK_FLAGS.NONBLOCKING, out bank);
			if (rESULT != 0)
			{
				UnityEngine.Debug.LogWarning("Couldn't start bank loading: " + rESULT);
			}
			completeLoadUnload = incSampleData;
			unloadBank = false;
			this.callback = callback;
		}

		public LoadingTracker(Bank bank, bool unloadBank, bool completeLoadUnload, BankLoadCallback callback)
		{
			this.bank = bank;
			this.unloadBank = unloadBank;
			this.completeLoadUnload = completeLoadUnload;
			this.callback = callback;
		}

		public bool Update()
		{
			bank.getLoadingState(out var state);
			bank.getSampleLoadingState(out var state2);
			if (unloadBank)
			{
				if (completeLoadUnload)
				{
					if (state != 0)
					{
						if (state == LOADING_STATE.LOADED && CommandSucceeded(bank.unload(), "Unload command failed."))
						{
							return false;
						}
						IsExpectedLoadingState(state, LOADING_STATE.UNLOADED, "Unloading failed.");
						return MakeCallback(bank, state, state2);
					}
				}
				else if (state2 != 0)
				{
					if (state2 == LOADING_STATE.LOADED && CommandSucceeded(bank.unloadSampleData(), "Unload sample data command failed."))
					{
						return false;
					}
					IsExpectedLoadingState(state2, LOADING_STATE.UNLOADED, "Sample data unloading failed.");
					return MakeCallback(bank, state, state2);
				}
			}
			else if (state != LOADING_STATE.LOADING)
			{
				if (IsExpectedLoadingState(state, LOADING_STATE.LOADED, "Loading failed."))
				{
					if (!completeLoadUnload)
					{
						return MakeCallback(bank, state, state2);
					}
					if (state2 != LOADING_STATE.LOADING)
					{
						if (state2 == LOADING_STATE.UNLOADED && CommandSucceeded(bank.loadSampleData(), "Load sample data command failed."))
						{
							return false;
						}
						IsExpectedLoadingState(state2, LOADING_STATE.LOADED, "Sample data loading failed.");
						return MakeCallback(bank, state, state2);
					}
				}
				else
				{
					unloadBank = true;
					completeLoadUnload = true;
					if (!CommandSucceeded(bank.unload(), "Unload command failed."))
					{
						UnityEngine.Debug.LogWarning("Bank load encountered an error and unloading failed. Bank not cleaned up.");
						return MakeCallback(bank, state, state2);
					}
				}
			}
			return false;
		}

		private bool CommandSucceeded(RESULT result, string errMessage)
		{
			if (result != 0)
			{
				if (bank.getPath(out var path) != 0)
				{
					path = "failed to retrieve path";
				}
				UnityEngine.Debug.LogWarning("(" + path + ") " + errMessage);
				return false;
			}
			return true;
		}

		private bool IsExpectedLoadingState(LOADING_STATE loadingState, LOADING_STATE expectedState, string errMessage)
		{
			if (loadingState != expectedState)
			{
				if (bank.getPath(out var path) != 0)
				{
					path = "failed to retrieve path";
				}
				UnityEngine.Debug.LogWarning("(" + path + ") " + ((loadingState == LOADING_STATE.ERROR) ? errMessage : "In unexpected loading state."));
				return false;
			}
			return true;
		}

		private bool MakeCallback(Bank bank, LOADING_STATE bankState, LOADING_STATE sampleState)
		{
			if (callback != null)
			{
				try
				{
					callback(bank, bankState, sampleState);
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
				}
			}
			return true;
		}
	}

	public const string mainBankPath = "Banks/Master Bank.bank";

	public const string stringBankPath = "Banks/Master Bank.strings.bank";

	private static FAC _inst;

	[Header("Init flags for the studio system and backing low level system")]
	[EnumFlagsField]
	public FMODInitEnums.LowLevelInitFlags lowLevelInitFlags;

	[EnumFlagsField]
	public FMODInitEnums.StudioInitFlags studioInitFlags;

	[Header("FMOD and FMOD Studio additional options")]
	[Tooltip("Maximum number of voices FMOD will allow to be created simultaneously. Does not affect maximum number of audible actual voices.")]
	public int maxVirtualVoices;

	[Tooltip("Effective volume at which a voice is considered inaudible and becomes virtualized.")]
	public float virtualVolume;

	[Header("FAC initialization options")]
	[Tooltip("Run the system initialization from a seperate managed thread")]
	public bool threadedInitialization = true;

	[Tooltip("Plugins to load on initialization. Not the full path to the binary to allow for auto platform plugin selection. [PathToPluginsFolder]/[PluginName]")]
	public string[] pluginPaths;

	private object initLock = new object();

	private volatile bool initialized;

	private Action onInitialized;

	private readonly Dictionary<GuidAOT, EventDescription> descriptionByGuid = new Dictionary<GuidAOT, EventDescription>(new GuidAOT.GuidEQ());

	private readonly Dictionary<string, EventDescription> descriptionByPath = new Dictionary<string, EventDescription>();

	private readonly List<DelayedEventInstance> delayedEvents = new List<DelayedEventInstance>();

	private readonly List<FMOD.Studio.EventInstance> trackedEventsToRemove = new List<FMOD.Studio.EventInstance>();

	private readonly Dictionary<FMOD.Studio.EventInstance, TrackedEventInstance> trackedEvents = new Dictionary<FMOD.Studio.EventInstance, TrackedEventInstance>(new EventInstanceEQ());

	private readonly List<LoadingTracker> loadingTrackers = new List<LoadingTracker>();

	private FMOD.Studio.System _sys;

	[HideInInspector]
	public Bank lastLoadedBank;

	[HideInInspector]
	public bool lastBankLoadSuccess = true;

	private IHaglet<string, bool> loadBankAsyncRoutine;

	private IHaglet<Bank> loadBankSamplesAsyncRoutine;

	private IHaglet<Bank, bool> unloadBankAsyncRoutine;

	public static IHaglet<string, string> unpackFileFromJarRoutine;

	private static IntPtr cls_AssetCopy_g;

	private static IntPtr mth_AssetCopy_copyAsset;

	private static volatile bool workerThreadRun;

	private static volatile Thread workerThread;

	private static volatile Action workerThreadTask;

	private static readonly AutoResetEvent workerThreadSignal = new AutoResetEvent(initialState: false);

	private static Func<bool> ThreadBusy = _ThreadBusy;

	public static FAC Inst => _inst;

	public static bool Initialized
	{
		get
		{
			if (_inst != null)
			{
				return _inst.initialized;
			}
			return false;
		}
	}

	public bool loadingUnloading => loadingTrackers.Count > 0;

	public FMOD.Studio.System sys => _sys;

	public static Wait WaitThreadBusy => Wait.Until.False(ThreadBusy, 1, allowPreMetNow: true);

	private static FMOD.Studio.System CreateFMODSSys(int maxVirtualVoices, float virtualVolume, FMOD.INITFLAGS llInitFlags, FMOD.Studio.INITFLAGS studioInitFlags)
	{
		RESULT rESULT = FMOD.Studio.System.create(out var studiosystem);
		if (rESULT != 0)
		{
			UnityEngine.Debug.LogError("Failed to create system: " + rESULT);
			return default(FMOD.Studio.System);
		}
		FMOD.ADVANCEDSETTINGS settings = default(FMOD.ADVANCEDSETTINGS);
		studiosystem.getLowLevelSystem(out var system);
		studioInitFlags &= ~FMOD.Studio.INITFLAGS.LIVEUPDATE;
		if ((studioInitFlags & FMOD.Studio.INITFLAGS.LIVEUPDATE) == FMOD.Studio.INITFLAGS.LIVEUPDATE)
		{
			settings.profilePort = 9265;
		}
		settings.vol0virtualvol = virtualVolume;
		system.setAdvancedSettings(ref settings);
		rESULT = studiosystem.initialize(maxVirtualVoices, studioInitFlags, llInitFlags, IntPtr.Zero);
		if (rESULT != 0)
		{
			UnityEngine.Debug.LogError("Failed to initialize system: " + rESULT);
			studiosystem.release();
			return default(FMOD.Studio.System);
		}
		if ((studioInitFlags & FMOD.Studio.INITFLAGS.LIVEUPDATE) == FMOD.Studio.INITFLAGS.LIVEUPDATE)
		{
			studiosystem.flushCommands();
			rESULT = studiosystem.update();
			if (rESULT == RESULT.ERR_NET_SOCKET_ERROR)
			{
				UnityEngine.Debug.LogWarning("Live update failed: socket in already in use. Reinitializing without live update");
				studiosystem.release();
				return CreateFMODSSys(maxVirtualVoices, virtualVolume, llInitFlags, studioInitFlags & ~FMOD.Studio.INITFLAGS.LIVEUPDATE);
			}
		}
		return studiosystem;
	}

	public void Awake()
	{
		_inst = this;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		FACMisc.PrefetchUnityPaths();
		Haglet.Create(out loadBankAsyncRoutine, (Routine.Func2<string, bool>)LoadBankAsyncRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out loadBankSamplesAsyncRoutine, (Routine.Func1<Bank>)LoadBankSamplesAsyncRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out unloadBankAsyncRoutine, (Routine.Func2<Bank, bool>)UnloadBankAsyncRoutine, (string)null, startNow: false, (int?)null, (string)null);
		Haglet.Create(out unpackFileFromJarRoutine, (Routine.Func2<string, string>)UnpackFileFromJarRoutine, (string)null, startNow: false, (int?)null, (string)null);
		using (AndroidJavaClass androidJavaClass2 = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))
		{
			using AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.coatsink.tools.assetcopy.AssetCopy");
			cls_AssetCopy_g = AndroidJNI.NewGlobalRef(androidJavaClass.GetRawClass());
			mth_AssetCopy_copyAsset = AndroidJNI.GetStaticMethodID(cls_AssetCopy_g, "copyAsset", "(Ljava/lang/String;Ljava/lang/String;)V");
			AndroidJavaObject @static = androidJavaClass2.GetStatic<AndroidJavaObject>("currentActivity");
			androidJavaClass.CallStatic("setActivity", @static);
		}
		workerThread = new Thread((ThreadStart)delegate
		{
			try
			{
				AndroidJNI.AttachCurrentThread();
				UnityEngine.Debug.Log("FMOD worker thread started and JNI attached.");
				while (workerThreadRun)
				{
					try
					{
						workerThreadSignal.WaitOne();
						if (workerThreadRun && workerThreadTask != null)
						{
							lock (workerThreadSignal)
							{
								workerThreadTask();
								workerThreadTask = null;
							}
						}
					}
					catch (Exception exception)
					{
						UnityEngine.Debug.LogException(exception);
					}
				}
			}
			catch (Exception exception2)
			{
				UnityEngine.Debug.LogException(exception2);
			}
			finally
			{
				AndroidJNI.DetachCurrentThread();
				UnityEngine.Debug.Log("FMOD worker thread terminating and JNI detached.");
			}
		});
		GameObject obj = new GameObject("FMOD Worker Shut Down");
		obj.AddComponent<_ShutdownWorkerThread>();
		UnityEngine.Object.DontDestroyOnLoad(obj);
		obj.hideFlags = HideFlags.HideInHierarchy;
		workerThreadRun = true;
		workerThread.Name = "FMOD Worker";
		workerThread.IsBackground = true;
		workerThread.Start();
		FACMisc.EnforceLibraryOrder();
		Action action = delegate
		{
			try
			{
				_sys = CreateFMODSSys(maxVirtualVoices, virtualVolume, lowLevelInitFlags.ToFMODLLIF(), studioInitFlags.ToFMODSIF());
				if (pluginPaths != null)
				{
					for (int i = 0; i < pluginPaths.Length; i++)
					{
						LoadPlugin(pluginPaths[i]);
					}
				}
			}
			finally
			{
				lock (initLock)
				{
					if (onInitialized != null)
					{
						onInitialized();
						onInitialized = null;
					}
					initialized = true;
				}
			}
		};
		if (threadedInitialization)
		{
			AddThreadTask(action);
		}
		else
		{
			action();
		}
	}

	public void AddOnInitialized(Action onInitialized)
	{
		lock (initLock)
		{
			if (initialized)
			{
				onInitialized();
			}
			else
			{
				this.onInitialized = (Action)Delegate.Combine(this.onInitialized, onInitialized);
			}
		}
	}

	public void RemoveOnInitialized(Action onInitialized)
	{
		lock (initLock)
		{
			this.onInitialized = (Action)Delegate.Remove(this.onInitialized, onInitialized);
		}
	}

	public bool LoadPlugin(string pluginName)
	{
		if (!_sys.hasHandle())
		{
			return false;
		}
		string pluginPath = GetPluginPath(pluginName);
		_sys.getLowLevelSystem(out var system);
		uint handle;
		RESULT rESULT = system.loadPlugin(pluginPath, out handle);
		if (rESULT != 0)
		{
			UnityEngine.Debug.LogError("Error loading plugin at path " + pluginPath + " : " + rESULT);
			return false;
		}
		return true;
	}

	public bool LoadBankSync(string bankPath, bool includeSamples, out Bank bank)
	{
		if (!_sys.hasHandle())
		{
			bank = default(Bank);
			return false;
		}
		RESULT rESULT = _sys.loadBankFile(bankPath, LOAD_BANK_FLAGS.NORMAL, out bank);
		if (rESULT != 0)
		{
			UnityEngine.Debug.LogError("Error loading bank at path \"" + bankPath + "\" : " + rESULT);
			if (!initialized)
			{
				UnityEngine.Debug.LogError("Loading banks before initialized, big fucking no-no!");
			}
			return false;
		}
		if (includeSamples)
		{
			LoadBankSamplesSync(bank);
		}
		return true;
	}

	public bool LoadBankSamplesSync(Bank bank)
	{
		if (!_sys.hasHandle())
		{
			return false;
		}
		RESULT path2 = bank.getPath(out var path);
		if (bank.getPath(out path) != 0)
		{
			path = "failed to retrieve path :" + path2;
		}
		path2 = bank.loadSampleData();
		if (path2 != 0)
		{
			UnityEngine.Debug.LogError("(" + path + ") Load sample data failed: " + path2);
			return false;
		}
		while (true)
		{
			_sys.update();
			bank.getSampleLoadingState(out var state);
			switch (state)
			{
			case LOADING_STATE.LOADING:
				continue;
			case LOADING_STATE.LOADED:
				return true;
			}
			UnityEngine.Debug.LogWarning("(" + path + ") Load sample data ended in state: " + path2);
			return false;
		}
	}

	public bool UnloadBankSync(Bank bank, bool justSamples)
	{
		if (!_sys.hasHandle())
		{
			return false;
		}
		RESULT path2 = bank.getPath(out var path);
		if (bank.getPath(out path) != 0)
		{
			path = "failed to retrieve path :" + path2;
		}
		path2 = (justSamples ? bank.unloadSampleData() : bank.unload());
		if (path2 != 0)
		{
			UnityEngine.Debug.LogError("(" + path + ") Unload sample data failed: " + path2);
			return false;
		}
		LOADING_STATE state;
		do
		{
			_sys.update();
			path2 = (justSamples ? bank.getSampleLoadingState(out state) : bank.getLoadingState(out state));
		}
		while (state == LOADING_STATE.UNLOADING && path2 == RESULT.OK);
		if (state != LOADING_STATE.UNLOADED)
		{
			UnityEngine.Debug.LogError("(" + path + ") Unload sample data ended in state: " + state);
			return false;
		}
		return true;
	}

	public Wait LoadBankAsync(string bankPath, bool includeSamples)
	{
		return loadBankAsyncRoutine.Call(bankPath, includeSamples);
	}

	private IEnumerator<Routine.Yield> LoadBankAsyncRoutine(string bankPath, bool includeSamples)
	{
		if (!_sys.hasHandle())
		{
			lastLoadedBank = default(Bank);
			lastBankLoadSuccess = false;
			yield break;
		}
		RESULT rESULT = _sys.loadBankFile(bankPath, LOAD_BANK_FLAGS.NONBLOCKING, out lastLoadedBank);
		if (rESULT != 0)
		{
			UnityEngine.Debug.LogError("Error loading bank at path \"" + bankPath + "\" : " + rESULT);
			if (!initialized)
			{
				UnityEngine.Debug.LogError("Loading banks before initialized, big fucking no-no!");
			}
			lastBankLoadSuccess = false;
			yield break;
		}
		_sys.update();
		lastLoadedBank.getLoadingState(out var state);
		while (true)
		{
			switch (state)
			{
			case LOADING_STATE.LOADING:
				yield return Wait.For.Updates(1);
				break;
			default:
				UnityEngine.Debug.LogError("(" + bankPath + ") Loading Bank ended in state: " + state);
				lastBankLoadSuccess = false;
				yield break;
			case LOADING_STATE.LOADED:
				if (includeSamples)
				{
					yield return LoadBankSamplesAsync(lastLoadedBank);
				}
				lastBankLoadSuccess = true;
				yield break;
			}
			_sys.update();
			lastLoadedBank.getLoadingState(out state);
		}
	}

	public Wait LoadBankSamplesAsync(Bank bank)
	{
		return loadBankSamplesAsyncRoutine.Call(bank);
	}

	private IEnumerator<Routine.Yield> LoadBankSamplesAsyncRoutine(Bank bank)
	{
		if (!_sys.hasHandle())
		{
			yield break;
		}
		RESULT res2 = bank.getPath(out var bankPath);
		if (bank.getPath(out bankPath) != 0)
		{
			bankPath = "failed to retrieve path :" + res2;
		}
		res2 = bank.loadSampleData();
		if (res2 != 0)
		{
			UnityEngine.Debug.LogError("(" + bankPath + ") Load sample data failed: " + res2);
			yield break;
		}
		_sys.update();
		lastLoadedBank.getSampleLoadingState(out var state);
		while (true)
		{
			switch (state)
			{
			case LOADING_STATE.LOADING:
				yield return Wait.For.Updates(1);
				break;
			default:
				UnityEngine.Debug.LogWarning("(" + bankPath + ") Load sample data ended in state: " + res2);
				yield break;
			case LOADING_STATE.LOADED:
				yield break;
			}
			_sys.update();
			lastLoadedBank.getSampleLoadingState(out state);
		}
	}

	public Wait UnloadBankAsync(Bank bank, bool justSamples)
	{
		return unloadBankAsyncRoutine.Call(bank, justSamples);
	}

	private IEnumerator<Routine.Yield> UnloadBankAsyncRoutine(Bank bank, bool justSamples)
	{
		if (!_sys.hasHandle())
		{
			yield break;
		}
		RESULT path = bank.getPath(out var bankPath);
		if (bank.getPath(out bankPath) != 0)
		{
			bankPath = "failed to retrieve path :" + path;
		}
		path = (justSamples ? bank.unloadSampleData() : bank.unload());
		if (path != 0)
		{
			UnityEngine.Debug.LogError("(" + bankPath + ") Unload sample data failed: " + path);
			yield break;
		}
		_sys.update();
		path = (justSamples ? bank.getSampleLoadingState(out var state) : bank.getLoadingState(out state));
		while (state == LOADING_STATE.UNLOADING && path == RESULT.OK)
		{
			yield return Wait.For.Updates(1);
			_sys.update();
			path = (justSamples ? bank.getSampleLoadingState(out state) : bank.getLoadingState(out state));
		}
		if (state != LOADING_STATE.UNLOADED)
		{
			UnityEngine.Debug.LogError("(" + bankPath + ") Unload sample data ended in state: " + state);
		}
	}

	public void PopulateEventGUIDS()
	{
		if (!_sys.hasHandle())
		{
			return;
		}
		descriptionByGuid.Clear();
		_sys.getBankList(out var array);
		Bank[] array2 = array;
		foreach (Bank bank in array2)
		{
			bank.getEventList(out var array3);
			EventDescription[] array4 = array3;
			for (int j = 0; j < array4.Length; j++)
			{
				EventDescription value = array4[j];
				value.getID(out var id);
				value.getPath(out var path);
				descriptionByGuid[id] = value;
				descriptionByPath[path] = value;
			}
		}
	}

	public void ClearEventInstances()
	{
		if (!_sys.hasHandle())
		{
			return;
		}
		descriptionByGuid.Clear();
		_sys.getBankList(out var array);
		Bank[] array2 = array;
		foreach (Bank bank in array2)
		{
			bank.getEventList(out var array3);
			EventDescription[] array4 = array3;
			foreach (EventDescription eventDescription in array4)
			{
				eventDescription.getInstanceList(out var array5);
				for (int k = 0; k < array5.Length; k++)
				{
					array5[k].stop(STOP_MODE.IMMEDIATE);
					array5[k].release();
					array5[k] = default(FMOD.Studio.EventInstance);
				}
			}
		}
	}

	public void ShowInstanceCount()
	{
		if (!_sys.hasHandle())
		{
			return;
		}
		int num = 0;
		descriptionByGuid.Clear();
		_sys.getBankList(out var array);
		Bank[] array2 = array;
		foreach (Bank bank in array2)
		{
			bank.getEventList(out var array3);
			EventDescription[] array4 = array3;
			foreach (EventDescription eventDescription in array4)
			{
				int count = 0;
				eventDescription.getInstanceCount(out count);
				num += count;
			}
		}
		UnityEngine.Debug.Log(num);
	}

	public void LoadBank(string bankPath, bool includeSamples, BankLoadCallback callback)
	{
		loadingTrackers.Add(new LoadingTracker(_sys, bankPath, includeSamples, callback));
	}

	public void LoadBankSamples(Bank bank, BankLoadCallback callback)
	{
		loadingTrackers.Add(new LoadingTracker(bank, unloadBank: false, completeLoadUnload: true, callback));
	}

	public void UnloadBank(Bank bank, bool justSamples, BankLoadCallback callback)
	{
		loadingTrackers.Add(new LoadingTracker(bank, unloadBank: true, !justSamples, callback));
	}

	public EventDescription GetDescription(FMODEventAsset asset)
	{
		if (asset == null)
		{
			return default(EventDescription);
		}
		if (TryGetDescription(asset.fmodGUID, out var evtDesc) || TryGetDescription(asset.path, out evtDesc))
		{
			return evtDesc;
		}
		return default(EventDescription);
	}

	public EventDescription GetDescription(string path)
	{
		if (TryGetDescription(path, out var evtDesc))
		{
			return evtDesc;
		}
		return default(EventDescription);
	}

	public EventDescription GetDescription(Guid fmodGUID)
	{
		if (TryGetDescription(fmodGUID, out var evtDesc))
		{
			return evtDesc;
		}
		return default(EventDescription);
	}

	private bool TryGetDescription(Guid fmodGUID, out EventDescription evtDesc)
	{
		if (descriptionByGuid.TryGetValue(fmodGUID, out evtDesc))
		{
			return true;
		}
		if (_sys.hasHandle() && _sys.getEventByID(fmodGUID, out evtDesc) == RESULT.OK)
		{
			descriptionByGuid[fmodGUID] = evtDesc;
			return true;
		}
		evtDesc = default(EventDescription);
		return false;
	}

	private bool TryGetDescription(string path, out EventDescription evtDesc)
	{
		if (descriptionByPath.TryGetValue(path, out evtDesc))
		{
			return true;
		}
		if (_sys.hasHandle() && _sys.getEvent(path, out evtDesc) == RESULT.OK)
		{
			descriptionByPath[path] = evtDesc;
			return true;
		}
		evtDesc = default(EventDescription);
		return false;
	}

	public void ReleaseAllInstances()
	{
		_sys.release();
		if (!_sys.isValid())
		{
			_sys = CreateFMODSSys(maxVirtualVoices, virtualVolume, lowLevelInitFlags.ToFMODLLIF(), studioInitFlags.ToFMODSIF());
		}
	}

	public FMOD.Studio.EventInstance GetEvent(FMODEventAsset asset)
	{
		if (asset == null)
		{
			return default(FMOD.Studio.EventInstance);
		}
		if (TryGetEvent(asset.fmodGUID, out var evtInst) || TryGetEvent(asset.path, out evtInst))
		{
			return evtInst;
		}
		return default(FMOD.Studio.EventInstance);
	}

	public FMOD.Studio.EventInstance GetEvent(string path)
	{
		if (TryGetEvent(path, out var evtInst))
		{
			return evtInst;
		}
		return default(FMOD.Studio.EventInstance);
	}

	public FMOD.Studio.EventInstance GetEvent(Guid fmodGUID)
	{
		if (TryGetEvent(fmodGUID, out var evtInst))
		{
			return evtInst;
		}
		return default(FMOD.Studio.EventInstance);
	}

	private bool TryGetEvent(Guid fmodGUID, out FMOD.Studio.EventInstance evtInst)
	{
		if (TryGetDescription(fmodGUID, out var evtDesc))
		{
			return evtDesc.createInstance(out evtInst) == RESULT.OK;
		}
		evtInst = default(FMOD.Studio.EventInstance);
		return false;
	}

	private bool TryGetEvent(string path, out FMOD.Studio.EventInstance evtInst)
	{
		if (TryGetDescription(path, out var evtDesc))
		{
			return evtDesc.createInstance(out evtInst) == RESULT.OK;
		}
		evtInst = default(FMOD.Studio.EventInstance);
		return false;
	}

	public FMOD.Studio.EventInstance PlaySnapShot(FMODSnapshotAsset asset)
	{
		if (asset == null)
		{
			return default(FMOD.Studio.EventInstance);
		}
		if (TryGetEvent(asset.fmodGUID, out var evtInst) || TryGetEvent(asset.path, out evtInst))
		{
			return PlayAsOneShot(evtInst);
		}
		return default(FMOD.Studio.EventInstance);
	}

	public FMOD.Studio.EventInstance PlayOneShot(FMODEventAsset asset, Vector3 position, float volume = 1f, float delay = 0f)
	{
		return PlayAsOneShot(GetEvent(asset), position, volume, delay);
	}

	public FMOD.Studio.EventInstance PlayOneShot(string path, Vector3 position, float volume = 1f, float delay = 0f)
	{
		return PlayAsOneShot(GetEvent(path), position, volume, delay);
	}

	public FMOD.Studio.EventInstance PlayOneShot(Guid fmodGUID, Vector3 position, float volume = 1f, float delay = 0f)
	{
		return PlayAsOneShot(GetEvent(fmodGUID), position, volume, delay);
	}

	public FMOD.Studio.EventInstance PlayOneShot(FMODEventAsset asset, Transform parent, float volume = 1f, float delay = 0f)
	{
		return PlayAsOneShot(GetEvent(asset), parent, volume, delay);
	}

	public FMOD.Studio.EventInstance PlayOneShot(string path, Transform parent, float volume = 1f, float delay = 0f)
	{
		return PlayAsOneShot(GetEvent(path), parent, volume, delay);
	}

	public FMOD.Studio.EventInstance PlayOneShot(Guid fmodGUID, Transform parent, float volume = 1f, float delay = 0f)
	{
		return PlayAsOneShot(GetEvent(fmodGUID), parent, volume, delay);
	}

	public FMOD.Studio.EventInstance PlayAsOneShot(FMOD.Studio.EventInstance eventInstance, Transform parent, float volume = 1f, float delay = 0f)
	{
		PlayAsOneShot(eventInstance, parent.position, volume, delay);
		if (delay <= 0f)
		{
			RegisterTrackedEvent(eventInstance, parent);
		}
		return eventInstance;
	}

	public FMOD.Studio.EventInstance PlayAsOneShot(FMOD.Studio.EventInstance eventInstance, Vector3 position = default(Vector3), float volume = 1f, float delay = 0f)
	{
		if (eventInstance.isValid())
		{
			ATTRIBUTES_3D attributes = position.to3DAttributes();
			eventInstance.set3DAttributes(attributes);
			eventInstance.setVolume(volume);
			if (delay > 0f)
			{
				delayedEvents.Add(new DelayedEventInstance(eventInstance, delay));
			}
			else
			{
				eventInstance.start();
				eventInstance.release();
			}
		}
		return eventInstance;
	}

	public void RegisterTrackedEvent(FMOD.Studio.EventInstance evt, Transform parent)
	{
		trackedEvents[evt] = new TrackedEventInstance(evt, parent);
	}

	public void UnregisterTrackedEvent(FMOD.Studio.EventInstance evt)
	{
		trackedEvents.Remove(evt);
	}

	public void ReparentTrackedEvent(FMOD.Studio.EventInstance evt, Transform parent)
	{
		trackedEvents[evt].SetParent(parent);
	}

	public Transform GetTrackedEventParent(FMOD.Studio.EventInstance evt)
	{
		return trackedEvents[evt].GetParent();
	}

	public void ClearPositionTrackedEvents()
	{
		foreach (KeyValuePair<FMOD.Studio.EventInstance, TrackedEventInstance> trackedEvent in trackedEvents)
		{
			trackedEvent.Value.Stop();
		}
		trackedEvents.Clear();
	}

	protected void OnDestroy()
	{
		if (_sys.isValid())
		{
			_sys.release();
		}
	}

	public Bus GetBus(string busPath)
	{
		_sys.getBus(busPath, out var bus);
		return bus;
	}

	public VCA GetVCA(string vcaPath)
	{
		_sys.getVCA(vcaPath, out var vca);
		return vca;
	}

	public VCA GetVCAByGuid(Guid guid)
	{
		_sys.getVCAByID(guid, out var vca);
		return vca;
	}

	protected void LateUpdate()
	{
		int num = 0;
		while (num < loadingTrackers.Count)
		{
			if (loadingTrackers[num].Update())
			{
				loadingTrackers.RemoveAt(num);
			}
			else
			{
				num++;
			}
		}
		int num2 = 0;
		float time = Time.time;
		for (int i = 0; i < delayedEvents.Count; i++)
		{
			DelayedEventInstance value = delayedEvents[i];
			if (value.Update(time))
			{
				num2++;
			}
			else if (num2 > 0)
			{
				delayedEvents[i - num2] = value;
			}
		}
		if (num2 > 0)
		{
			delayedEvents.RemoveRange(delayedEvents.Count - num2, num2);
		}
		foreach (KeyValuePair<FMOD.Studio.EventInstance, TrackedEventInstance> trackedEvent in trackedEvents)
		{
			if (trackedEvent.Value.Update())
			{
				trackedEventsToRemove.Add(trackedEvent.Key);
			}
		}
		foreach (FMOD.Studio.EventInstance item in trackedEventsToRemove)
		{
			trackedEvents.Remove(item);
		}
		trackedEventsToRemove.Clear();
		if (_sys.hasHandle())
		{
			_sys.update();
		}
	}

	public static void AddThreadTask(Action task)
	{
		lock (workerThreadSignal)
		{
			workerThreadTask = (Action)Delegate.Combine(workerThreadTask, task);
			workerThreadSignal.Set();
		}
	}

	private static bool _ThreadBusy()
	{
		return workerThreadTask != null;
	}

	public static IEnumerator<Routine.Yield> UnpackFileFromJarRoutine(string sourceAssetPath, string destUnpackedPath)
	{
		AddThreadTask(delegate
		{
			Directory.CreateDirectory(Path.GetDirectoryName(destUnpackedPath));
			if (File.Exists(destUnpackedPath))
			{
				File.Delete(destUnpackedPath);
			}
			try
			{
				AndroidJNI.PushLocalFrame(5);
				jvalue jvalue = default(jvalue);
				jvalue.l = AndroidJNI.NewStringUTF(sourceAssetPath);
				jvalue jvalue2 = jvalue;
				jvalue = default(jvalue);
				jvalue.l = AndroidJNI.NewStringUTF(destUnpackedPath);
				jvalue jvalue3 = jvalue;
				AndroidJNI.CallStaticVoidMethod(cls_AssetCopy_g, mth_AssetCopy_copyAsset, new jvalue[2] { jvalue2, jvalue3 });
			}
			finally
			{
				AndroidJNI.PopLocalFrame(IntPtr.Zero);
			}
		});
		yield return WaitThreadBusy;
		yield return Wait.For.Seconds(1f);
	}

	internal static string GetPluginPath(string pseudoPath)
	{
		string fileName = Path.GetFileName(pseudoPath);
		string text = "lib" + fileName + ".so";
		string text2 = new DirectoryInfo(FACMisc.PersistentDataPath).Parent.Name;
		return string.Concat("/data/data/" + text2 + "/lib/", text);
	}
}
public static class FACMisc
{
	private static bool librayOrderRan;

	public static string DataPath { get; private set; }

	public static string StreamingAssetsPath { get; private set; }

	public static string PersistentDataPath { get; private set; }

	public static void PrefetchUnityPaths()
	{
		DataPath = UnityEngine.Application.dataPath;
		StreamingAssetsPath = UnityEngine.Application.streamingAssetsPath;
		PersistentDataPath = UnityEngine.Application.persistentDataPath;
	}

	public static void EnforceLibraryOrder()
	{
		if (!librayOrderRan)
		{
			librayOrderRan = true;
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("java.lang.System");
			androidJavaClass.CallStatic("loadLibrary", "fmod");
			androidJavaClass.CallStatic("loadLibrary", "fmodstudio");
			Memory.GetStats(out var _, out var _);
			Util.ParseID("", out var _);
		}
	}

	public static VECTOR toFMODVector(this Vector3 vec)
	{
		VECTOR result = default(VECTOR);
		result.x = vec.x;
		result.y = vec.y;
		result.z = vec.z;
		return result;
	}

	public static ATTRIBUTES_3D to3DAttributes(this Vector3 pos)
	{
		ATTRIBUTES_3D result = default(ATTRIBUTES_3D);
		result.forward = Vector3.forward.toFMODVector();
		result.up = Vector3.up.toFMODVector();
		result.position = pos.toFMODVector();
		return result;
	}

	public static ATTRIBUTES_3D to3DAttributes(GameObject go, Rigidbody rigidbody = null)
	{
		ATTRIBUTES_3D result = default(ATTRIBUTES_3D);
		result.forward = go.transform.forward.toFMODVector();
		result.up = go.transform.up.toFMODVector();
		result.position = go.transform.position.toFMODVector();
		if ((bool)rigidbody)
		{
			result.velocity = rigidbody.velocity.toFMODVector();
		}
		return result;
	}

	public static string GetUnpackedPath(string path)
	{
		return PersistentDataPath + "/" + path;
	}

	private static bool GetDescription(FMODEventAsset fmodAsset, out EventDescription desc)
	{
		return FAC.Inst.sys.getEventByID(fmodAsset.fmodGUID, out desc) == RESULT.OK;
	}

	public static float GetDuration(FMODEventAsset fmodAsset)
	{
		if ((object)fmodAsset == null)
		{
			return 1f;
		}
		if (!GetDescription(fmodAsset, out var desc))
		{
			return 1f;
		}
		desc.getLength(out var length);
		desc.isOneshot(out var oneshot);
		return (float)length * 0.001f * (float)(oneshot ? 1 : 10);
	}

	public static string GetDisplayName(FMODEventAsset fmodAsset)
	{
		if ((object)fmodAsset == null)
		{
			return "No clip set";
		}
		if (!GetDescription(fmodAsset, out var desc))
		{
			return "Failed to load description";
		}
		desc.getPath(out var path);
		desc.isOneshot(out var oneshot);
		string text = Path.GetFileName(path);
		if (!oneshot)
		{
			text += " WARNING! FMOD Event is not oneshot and will loop forever!";
		}
		return text;
	}

	public static void PreloadAsset(FMODEventAsset fmodAsset)
	{
		if ((object)fmodAsset != null && GetDescription(fmodAsset, out var desc))
		{
			desc.loadSampleData();
		}
	}

	public static void UnloadAsset(FMODEventAsset fmodAsset)
	{
		if ((object)fmodAsset != null && GetDescription(fmodAsset, out var desc))
		{
			desc.unloadSampleData();
		}
	}
}
public class FMODEventSource : MonoBehaviour
{
	public enum DisableMode
	{
		Ignore,
		Stop,
		StopAndRelease,
		FadeoutStop,
		FadeoutStopAndRelease,
		Pause
	}

	public FMODEventAsset assetToPlay;

	public bool startOnAwake = true;

	public float volume = 1f;

	public DisableMode disableMode = DisableMode.Stop;

	private FMOD.Studio.EventInstance evt;

	private bool wasPlaying;

	private bool wasPaused;

	private FAC manager;

	private Vector3? _boundsSize;

	public bool playing
	{
		get
		{
			PLAYBACK_STATE playbackState = GetPlaybackState();
			if (playbackState != PLAYBACK_STATE.STOPPED)
			{
				return playbackState != PLAYBACK_STATE.STOPPING;
			}
			return false;
		}
	}

	public Bounds bounds
	{
		get
		{
			if (!_boundsSize.HasValue && assetToPlay != null)
			{
				float distance = 0f;
				EventDescription description = assetToPlay.GetDescription(manager.sys);
				if (description.isValid())
				{
					description.getMaximumDistance(out distance);
				}
				_boundsSize = Vector3.one * (distance * 2f);
			}
			return new Bounds(base.transform.position, _boundsSize.HasValue ? _boundsSize.Value : Vector3.zero);
		}
	}

	public void Play(bool updatePositionImmediately = true)
	{
		CacheEventInstance();
		if (updatePositionImmediately)
		{
			Update3DAttributes();
		}
		if (evt.isValid())
		{
			evt.start();
			evt.setVolume(volume);
		}
	}

	public void SetVolume(float volume)
	{
		this.volume = volume;
		if (evt.isValid())
		{
			evt.setVolume(this.volume);
		}
	}

	public float GetVolume()
	{
		return volume;
	}

	public void Pause()
	{
		if (evt.isValid())
		{
			evt.setPaused(paused: true);
		}
	}

	public void Resume()
	{
		if (evt.isValid())
		{
			evt.setPaused(paused: false);
		}
	}

	public void Stop()
	{
		if (evt.isValid())
		{
			evt.stop(STOP_MODE.ALLOWFADEOUT);
		}
	}

	public ParameterInstance GetParameter(string name)
	{
		evt.getParameter(name, out var instance);
		return instance;
	}

	public ParameterInstance GetParameter(int index)
	{
		evt.getParameterByIndex(index, out var instance);
		return instance;
	}

	public PLAYBACK_STATE GetPlaybackState()
	{
		if (!evt.isValid())
		{
			return PLAYBACK_STATE.STOPPED;
		}
		if (evt.getPlaybackState(out var state) == RESULT.OK)
		{
			return state;
		}
		return PLAYBACK_STATE.STOPPED;
	}

	private void Awake()
	{
		manager = FAC.Inst;
		manager.AddOnInitialized(OnFMODInit);
	}

	private void OnFMODInit()
	{
		CacheEventInstance();
		if (startOnAwake)
		{
			Play(updatePositionImmediately: false);
		}
	}

	private void CacheEventInstance()
	{
		if (assetToPlay != null && !evt.isValid())
		{
			evt = manager.GetEvent(assetToPlay);
		}
	}

	private void OnDestroy()
	{
		if (evt.isValid())
		{
			if (GetPlaybackState() != PLAYBACK_STATE.STOPPED)
			{
				evt.stop(STOP_MODE.IMMEDIATE);
			}
			evt.release();
			evt = default(FMOD.Studio.EventInstance);
		}
		manager.RemoveOnInitialized(OnFMODInit);
	}

	private void OnEnable()
	{
		CacheEventInstance();
		if (evt.isValid())
		{
			evt.setPaused(wasPaused);
			if (wasPlaying && !playing)
			{
				evt.start();
			}
		}
	}

	private void OnDisable()
	{
		if (!evt.isValid())
		{
			return;
		}
		wasPlaying = playing;
		evt.getPaused(out wasPaused);
		if (disableMode == DisableMode.Ignore)
		{
			return;
		}
		if (disableMode == DisableMode.Pause)
		{
			if (!wasPaused)
			{
				evt.setPaused(paused: true);
			}
			return;
		}
		if (wasPlaying)
		{
			evt.stop((disableMode != DisableMode.FadeoutStop && disableMode != DisableMode.FadeoutStopAndRelease) ? STOP_MODE.IMMEDIATE : STOP_MODE.ALLOWFADEOUT);
		}
		if (disableMode == DisableMode.StopAndRelease || disableMode == DisableMode.FadeoutStopAndRelease)
		{
			evt.release();
		}
	}

	public bool HasFinished()
	{
		if (!evt.isValid())
		{
			return true;
		}
		return GetPlaybackState() == PLAYBACK_STATE.STOPPED;
	}

	private void Update()
	{
		if (evt.isValid())
		{
			Update3DAttributes();
		}
		else
		{
			evt = default(FMOD.Studio.EventInstance);
		}
	}

	private void Update3DAttributes()
	{
		ATTRIBUTES_3D attributes = UnityUtil.to3DAttributes(base.gameObject);
		evt.set3DAttributes(attributes);
	}
}
public static class FMODMisc
{
	private static bool _lowLevelSystemLoaded;

	public static bool lowLevelSystemLoaded
	{
		get
		{
			return _lowLevelSystemLoaded;
		}
		private set
		{
			_lowLevelSystemLoaded = value;
		}
	}

	public static bool ForceLoadLowLevelBinary()
	{
		if (lowLevelSystemLoaded)
		{
			return true;
		}
		AndroidJavaObject androidJavaObject = null;
		using (AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))
		{
			androidJavaObject = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
		}
		UnityEngine.Debug.Log("FMOD ANDROID AUDIOTRACK: " + ((androidJavaObject == null) ? "ERROR NO ACTIVITY" : "VALID ACTIVITY!"));
		using (AndroidJavaClass androidJavaClass2 = new AndroidJavaClass("org.fmod.FMOD"))
		{
			if (androidJavaClass2 != null)
			{
				UnityEngine.Debug.Log("FMOD ANDROID AUDIOTRACK: assigning activity to fmod java");
				androidJavaClass2.CallStatic("init", androidJavaObject);
			}
			else
			{
				UnityEngine.Debug.Log("FMOD ANDROID AUDIOTRACK: ERROR NO FMOD JAVA");
			}
		}
		UnityUtil.Log("loading binaries: fmodstudio and fmod");
		AndroidJavaClass androidJavaClass3 = new AndroidJavaClass("java.lang.System");
		androidJavaClass3.CallStatic("loadLibrary", "fmod");
		androidJavaClass3.CallStatic("loadLibrary", "fmodstudio");
		if (Memory.GetStats(out var _, out var _) != 0)
		{
			UnityEngine.Debug.LogError("ForceLoadLowLevelBinary failed");
			return false;
		}
		lowLevelSystemLoaded = true;
		return true;
	}
}
public interface IPoolEvents
{
	void OnSpawn();

	void OnDespawn();

	void OnAllocate();

	void OnDeallocate();
}
public abstract class GameObjectPool<T, W> : MonoBehaviour where T : UnityEngine.Component where W : GameObjectPool<T, W>.GOFromPool
{
	public class GOFromPool : MonoBehaviour
	{
		[NonSerialized]
		public PoolReferences pr;

		public virtual void OnReady()
		{
		}

		public virtual void OnStop()
		{
		}

		protected virtual void OnDisable()
		{
			IPoolEvents[] eventComps = pr.eventComps;
			for (int i = 0; i < eventComps.Length; i++)
			{
				eventComps[i].OnDespawn();
			}
			OnStop();
			if (base.gameObject.activeSelf || pr == null)
			{
				return;
			}
			if (pr.pool == null)
			{
				eventComps = pr.eventComps;
				for (int i = 0; i < eventComps.Length; i++)
				{
					eventComps[i].OnDeallocate();
				}
				UnityEngine.Object.Destroy(base.gameObject);
			}
			else
			{
				pr.pool.Return(pr);
			}
		}
	}

	public class PoolReferences
	{
		public GameObjectPool<T, W> pool;

		public readonly T component;

		public readonly W watcher;

		public readonly GameObject go;

		public readonly IPoolEvents[] eventComps;

		public PoolReferences(GameObjectPool<T, W> pool_, T component_, W watcher_, GameObject go_)
		{
			pool = pool_;
			component = component_;
			watcher = watcher_;
			go = go_;
			eventComps = go_.GetComponentsInChildren<IPoolEvents>();
		}
	}

	public T sourcePrefab;

	public int initialSize;

	public int maxSize;

	public PoolUpdateRunner updateRunner;

	protected List<PoolReferences> divers = new List<PoolReferences>();

	protected List<PoolReferences> available = new List<PoolReferences>();

	protected List<PoolReferences> activeInstances = new List<PoolReferences>();

	private Action update;

	public IEnumerable<PoolReferences> _activeObjects => activeInstances;

	public int TotalInstCount => divers.Count + available.Count + activeInstances.Count;

	public int ActiveInstCount => activeInstances.Count;

	public int AvailableInstCount => available.Count;

	public virtual void Init(bool fillImmediately = true)
	{
		update = UpdatePool;
		if (maxSize > 0 && maxSize < initialSize)
		{
			maxSize = initialSize;
		}
		if (fillImmediately)
		{
			for (int i = 0; i < initialSize; i++)
			{
				AddInstance();
			}
		}
		else
		{
			updateRunner.RunUpdate(update);
		}
	}

	private void AddInstance()
	{
		T val = UnityEngine.Object.Instantiate(sourcePrefab);
		val.transform.parent = base.transform;
		val.gameObject.SetActive(value: false);
		W val2 = val.gameObject.AddComponent<W>();
		val2.pr = new PoolReferences(this, val, val2, val.gameObject);
		val2.hideFlags = HideFlags.HideInInspector;
		available.Add(val2.pr);
		OnAllocate(val, val2);
		IPoolEvents[] eventComps = val2.pr.eventComps;
		for (int i = 0; i < eventComps.Length; i++)
		{
			eventComps[i].OnAllocate();
		}
	}

	private void UpdatePool()
	{
		if (TotalInstCount < initialSize)
		{
			AddInstance();
			if (TotalInstCount < initialSize)
			{
				updateRunner.RunUpdate(update);
			}
		}
		for (int num = divers.Count - 1; num >= 0; num--)
		{
			PoolReferences poolReferences = divers[num];
			if (poolReferences.go == null)
			{
				UnityEngine.Debug.LogError("Pooled GameObject has been destroyed from " + base.name, this);
			}
			else
			{
				poolReferences.go.transform.parent = base.transform;
				available.Add(poolReferences);
			}
		}
		divers.Clear();
	}

	protected virtual PoolReferences GetRef(Transform parent, Vector3 worldPosition, bool active)
	{
		PoolReferences poolReferences = null;
		IPoolEvents[] eventComps;
		if (available.Count > 0)
		{
			poolReferences = available[available.Count - 1];
			available.RemoveAt(available.Count - 1);
		}
		else
		{
			T val = UnityEngine.Object.Instantiate(sourcePrefab);
			val.gameObject.SetActive(active);
			W val2 = val.gameObject.AddComponent<W>();
			poolReferences = (val2.pr = new PoolReferences(this, val, val2, val.gameObject));
			val2.hideFlags = HideFlags.HideInInspector;
			OnAllocate(val, val2);
			eventComps = val2.pr.eventComps;
			for (int i = 0; i < eventComps.Length; i++)
			{
				eventComps[i].OnAllocate();
			}
		}
		poolReferences.go.transform.parent = parent;
		poolReferences.go.transform.position = worldPosition;
		if (active)
		{
			poolReferences.go.SetActive(value: true);
		}
		poolReferences.watcher.OnReady();
		eventComps = poolReferences.eventComps;
		for (int i = 0; i < eventComps.Length; i++)
		{
			eventComps[i].OnSpawn();
		}
		activeInstances.Add(poolReferences);
		return poolReferences;
	}

	public virtual T Get(Vector3 worldPostion = default(Vector3), Transform parent = null, bool active = true)
	{
		return GetRef(parent, worldPostion, active).component;
	}

	public virtual T Get(out W watcher, Vector3 worldPostion, Transform parent = null, bool active = true)
	{
		PoolReferences @ref = GetRef(parent, worldPostion, active);
		watcher = @ref.watcher;
		return @ref.component;
	}

	protected virtual void Return(PoolReferences pr)
	{
		activeInstances.Remove(pr);
		if (maxSize > available.Count + divers.Count)
		{
			pr.go.SetActive(value: false);
			divers.Add(pr);
			updateRunner.RunUpdate(update);
			return;
		}
		IPoolEvents[] eventComps = pr.eventComps;
		for (int i = 0; i < eventComps.Length; i++)
		{
			eventComps[i].OnDeallocate();
		}
		UnityEngine.Object.Destroy(pr.watcher);
		UnityEngine.Object.Destroy(pr.go);
	}

	protected virtual void OnAllocate(T newObject, W newWatcher)
	{
	}

	public override string ToString()
	{
		return sourcePrefab.name + " Pool";
	}
}
public class TransformFromPool : GameObjectPool<Transform, TransformFromPool>.GOFromPool
{
}
public class TransformPool : GameObjectPool<Transform, TransformFromPool>
{
}
public class PoolUpdateRunner : MonoBehaviour
{
	private readonly Action[] updatesToRun = new Action[2];

	private int cutr;

	public void RunUpdate(Action update)
	{
		ref Action reference = ref updatesToRun[cutr];
		reference = (Action)Delegate.Remove(reference, update);
		ref Action reference2 = ref updatesToRun[cutr];
		reference2 = (Action)Delegate.Combine(reference2, update);
	}

	private void Update()
	{
		int num = cutr;
		if (updatesToRun[num] != null)
		{
			cutr = (cutr + 1) % updatesToRun.Length;
			updatesToRun[num]();
			updatesToRun[num] = null;
		}
	}
}
[Serializable]
public class JK3DAtlasMaterial
{
	public string atlasName;

	public string atlasPath;

	public Material staticMat;

	public Material dynamicMat;

	public bool isLightmapped;
}
[Serializable]
public class JK3DAtlasMaterials : ConstArray<JK3DAtlasMaterial>
{
	public JK3DAtlasMaterials(uint size)
		: base(size)
	{
	}

	private JK3DAtlasMaterials()
	{
	}
}
[ExecuteInEditMode]
public class JK3D : MonoBehaviour
{
	private const int kMaxMaterials = 32;

	[ReadOnly]
	[SerializeField]
	private JK3DAtlasMaterials atlasMaterials;

	public JK3DAtlasMaterial[] GetAllAtlasMaterials()
	{
		return atlasMaterials.ToArray();
	}
}
public enum AtlasAutoImportSetting
{
	AllAtlases,
	SceneAtlases,
	Disabled
}
public interface IJK3DCustomMesh
{
	Mesh GetMesh();

	Material GetMaterial();
}
public static class JK3DCustomMesh
{
	public static bool ValidType(UnityEngine.Object obj)
	{
		if (obj == null)
		{
			return false;
		}
		return typeof(IJK3DCustomMesh).IsAssignableFrom(obj.GetType());
	}
}
public class JK3DAtlas : ScriptableObject
{
	[Serializable]
	public struct AdditionalTexture
	{
		public string shaderProperty;

		public Texture texture;
	}

	public struct TextureGroup
	{
		public Texture2D albedo;

		public Color vertexColour;

		public Texture2D specularSmoothness;

		public Color specularColor;

		public Texture2D emissive;

		public Texture2D normal;

		public Texture2D mask;

		public override int GetHashCode()
		{
			return albedo.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			return ((TextureGroup)obj).albedo == albedo;
		}
	}

	public string searchStringOverride = "";

	public float fillPercentage;

	public bool texturesResized;

	public static AtlasAutoImportSetting kAtlasImportSettings = AtlasAutoImportSetting.SceneAtlases;

	[NonSerialized]
	public static bool ForceJK3DRefNotToSync = false;

	public bool lightmapBatch = true;

	public string searchString = "";

	[FormerlySerializedAs("renderQueue")]
	public int renderQueueStatic = -1;

	public int renderQueueDynamic = -1;

	public MeshX.MeshAttribute meshAttributes = MeshX.MeshAttribute.Normals | MeshX.MeshAttribute.Tangents | MeshX.MeshAttribute.Colors | MeshX.MeshAttribute.TexCoords | MeshX.MeshAttribute.TexCoord2s;

	public List<AdditionalTexture> additionalTextures = new List<AdditionalTexture>();

	private const string kAtlasDataFolderName = "AtlasData";

	private const string kAtlasTexturesFolderName = "AtlasTextures";

	[HideInInspector]
	public JK3DAtlas atlasToCopyFrom;
}
[Serializable]
public class JK3DAtlasData : ScriptableObject
{
	[Serializable]
	public class MeshModReference
	{
		[SerializeField]
		public Mesh modifiedMesh;

		[SerializeField]
		public Mesh atlasedMesh;

		[SerializeField]
		public List<string> linkedScenes = new List<string>();

		[SerializeField]
		public List<JK3DReference> linkedPrefabs = new List<JK3DReference>();

		[SerializeField]
		public MeshModContainer meshModContainer;

		[SerializeField]
		private int _hashValue;
	}

	[Serializable]
	public class MeshModContainer
	{
		[SerializeField]
		public Mesh atlasedMesh;

		[SerializeField]
		public byte[] meshMod;

		public MeshModContainer(Mesh atlasedMesh, BaseSerializableMeshMod meshMod)
		{
			this.atlasedMesh = atlasedMesh;
			this.meshMod = meshMod.Serialise();
		}

		public MeshModContainer(MeshModContainer meshModContainer)
		{
			atlasedMesh = meshModContainer.atlasedMesh;
			meshMod = new byte[meshModContainer.meshMod.Length];
			Array.Copy(meshModContainer.meshMod, meshMod, meshMod.Length);
		}

		public override bool Equals(object obj)
		{
			if (!(obj is MeshModContainer { meshMod: not null } meshModContainer) || meshMod == null)
			{
				return false;
			}
			if (meshModContainer.meshMod.Length != meshMod.Length)
			{
				return false;
			}
			for (int i = 0; i < meshMod.Length; i++)
			{
				if (meshMod[i] != meshModContainer.meshMod[i])
				{
					return false;
				}
			}
			return atlasedMesh.Equals(meshModContainer.atlasedMesh);
		}

		public override int GetHashCode()
		{
			int num = -1175439788;
			if (atlasedMesh != null)
			{
				num = num * -1521134295 + atlasedMesh.GetHashCode();
			}
			if (meshMod != null)
			{
				int num2 = 0;
				for (int i = 0; i < meshMod.Length; i++)
				{
					num2 += meshMod[i];
				}
				num = num * -1521134295 + num2;
			}
			return num;
		}
	}

	[Serializable]
	public class TextureReference
	{
		public string textureName;

		public string textureGUID;

		public Vector2 textureSize;
	}

	[Serializable]
	public class AtlasTextureData
	{
		public TextureReference diffuse;

		public TextureReference specularSmoothness;

		public TextureReference emissive;

		public TextureReference normal;

		public TextureReference mask;

		public Rect textureRect;
	}

	public string atlasGuid;

	[HideInInspector]
	public bool justSaved;

	public List<Mesh> meshes = new List<Mesh>();

	public List<Mesh> modifiedMeshes = new List<Mesh>();

	public List<AtlasTextureData> atlasTextureData = new List<AtlasTextureData>();

	public List<MeshModReference> meshModReferences = new List<MeshModReference>();

	public Material staticMat;

	public Material dynamicMat;

	private Dictionary<MeshModContainer, MeshModReference> modifiedMeshDict = new Dictionary<MeshModContainer, MeshModReference>();

	public Dictionary<MeshModContainer, MeshModReference> ModifiedMeshDict
	{
		get
		{
			if (modifiedMeshDict != null)
			{
				_ = modifiedMeshDict.Count;
				_ = modifiedMeshes.Count;
			}
			return modifiedMeshDict;
		}
	}

	public Mesh GetMeshWithModelName(string name)
	{
		foreach (Mesh mesh in meshes)
		{
			if (!(mesh == null) && mesh.name == name)
			{
				return mesh;
			}
		}
		return null;
	}

	private Mesh GetMeshCopy(Mesh source, string meshName, Mesh destination)
	{
		Vector3[] vertices = source.vertices;
		Color[] colors = source.ValidAtrribArray(source.colors);
		Vector2[] uv = source.ValidAtrribArray(source.uv);
		Vector2[] uv2 = source.ValidAtrribArray(source.uv2);
		Vector3[] normals = source.ValidAtrribArray(source.normals);
		Vector4[] tangents = source.ValidAtrribArray(source.tangents);
		int[] indices = source.GetIndices(0);
		destination.Clear();
		destination.name = meshName;
		destination.vertices = vertices;
		destination.normals = normals;
		destination.colors = colors;
		destination.tangents = tangents;
		destination.uv = uv;
		destination.uv2 = uv2;
		destination.SetIndices(indices, source.GetTopology(0), 0);
		destination.RecalculateBounds();
		return destination;
	}

	private void UpdateModifiedDictionary()
	{
		modifiedMeshDict = new Dictionary<MeshModContainer, MeshModReference>();
		bool flag = false;
		for (int i = 0; i < meshModReferences.Count; i++)
		{
			if (!modifiedMeshDict.ContainsKey(meshModReferences[i].meshModContainer))
			{
				modifiedMeshDict.Add(meshModReferences[i].meshModContainer, meshModReferences[i]);
			}
			else if (meshModReferences[i].meshModContainer == null && !flag)
			{
				string text = ((meshModReferences[i].modifiedMesh == null) ? ("for: " + meshModReferences[i].modifiedMesh.name) : "");
				UnityEngine.Debug.LogError("Null mesh mod data found " + text);
				flag = true;
			}
		}
	}
}
public class JK3DEmissiveSettings : JK3DMeshMod<JK3DEmissiveSettings.EmissiveMeshMod>
{
	[Serializable]
	public class EmissiveMeshMod : BaseSerializableMeshMod
	{
		public float dynamicStrength = 1f;

		public float bakedStrength = 1f;

		[HideInInspector]
		public float bakedStrengthPrev = 1f;

		public override void Apply(Mesh destination)
		{
			_ = destination.vertices;
			List<Vector4> list = new List<Vector4>();
			for (int i = 0; i < destination.vertices.Length && i < destination.uv2.Length; i++)
			{
				list.Add(new Vector4(destination.uv2[i].x, destination.uv2[i].y, dynamicStrength, bakedStrength));
			}
			destination.SetUVs(1, list);
		}

		public override bool Equals(object other)
		{
			EmissiveMeshMod emissiveMeshMod = other as EmissiveMeshMod;
			if (other == null)
			{
				return false;
			}
			if (dynamicStrength == emissiveMeshMod.dynamicStrength)
			{
				return bakedStrength == emissiveMeshMod.bakedStrength;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (-1907966390 * -1521134295 + dynamicStrength.GetHashCode()) * -1521134295 + bakedStrength.GetHashCode();
		}
	}

	[HideInInspector]
	public float dynamicStrength = 1f;

	[HideInInspector]
	public float bakedStrength = 1f;

	[HideInInspector]
	public float bakedStrengthPrev = 1f;

	private JK3DEmissiveSettings()
	{
		baseSettings = new EmissiveMeshMod();
	}
}
public interface IMeshMod
{
}
[Serializable]
public abstract class BaseSerializableMeshMod
{
	public BaseSerializableMeshMod()
	{
	}

	public static BaseSerializableMeshMod Deserialize(byte[] baseSerializableMeshMod)
	{
		using MemoryStream serializationStream = new MemoryStream(baseSerializableMeshMod);
		return (BaseSerializableMeshMod)new BinaryFormatter().Deserialize(serializationStream);
	}

	public byte[] Serialise()
	{
		using MemoryStream memoryStream = new MemoryStream();
		new BinaryFormatter().Serialize(memoryStream, this);
		return memoryStream.GetBuffer();
	}

	public abstract void Apply(Mesh destination);
}
public abstract class JK3DMeshMod<T> : MonoBehaviour, IMeshMod where T : BaseSerializableMeshMod, new()
{
	[ReadOnly]
	public Mesh meshClone;

	[SerializeField]
	protected T baseSettings;

	[HideInInspector]
	private bool restored;
}
[ExecuteInEditMode]
public class JK3DReference : MonoBehaviour
{
	public static int GetHashCodeFromMeshMod(JK3DAtlasData atlasData, Mesh sourceMesh, BaseSerializableMeshMod meshMod)
	{
		int hashCode = atlasData.name.GetHashCode();
		int hashCode2 = hashCode.GetHashCode();
		hashCode2 = ((hashCode2 > 0) ? (-hashCode2) : hashCode2);
		hashCode *= hashCode2 + meshMod.GetHashCode();
		return hashCode * (hashCode2 + sourceMesh.name.GetHashCode());
	}

	public static void CopyMesh(Mesh destination, Mesh source)
	{
		destination.Clear();
		destination.name = source.name;
		destination.vertices = source.vertices;
		destination.normals = source.normals;
		destination.colors = source.colors;
		destination.uv = source.uv;
		destination.uv2 = source.uv2;
		destination.uv3 = source.uv3;
		destination.uv4 = source.uv4;
		destination.uv5 = source.uv5;
		destination.uv6 = source.uv6;
		destination.uv7 = source.uv7;
		destination.uv8 = source.uv8;
		destination.colors32 = source.colors32;
		destination.SetIndices(source.GetIndices(0), source.GetTopology(0), 0);
		destination.RecalculateBounds();
	}
}
public class JK3DUV2Colorer : JK3DMeshMod<JK3DUV2Colorer.UV2ColorerMeshMod>
{
	[Serializable]
	public class UV2ColorerMeshMod : BaseSerializableMeshMod
	{
		public Vector2 uv2;

		public bool additive;

		public bool clamp01;

		public override void Apply(Mesh destination)
		{
			Vector3[] vertices = destination.vertices;
			Vector2[] array = destination.uv2;
			if (array == null || array.Length != vertices.Length)
			{
				array = new Vector2[vertices.Length];
			}
			if (additive)
			{
				if (destination.uv2 != null && destination.uv2.Length == array.Length)
				{
					if (clamp01)
					{
						for (int i = 0; i < array.Length; i++)
						{
							array[i].x = Mathf.Clamp01(uv2.x);
							array[i].y = Mathf.Clamp01(array[i].y + uv2.y);
						}
					}
					else
					{
						for (int j = 0; j < array.Length; j++)
						{
							array[j].x = uv2.x;
							array[j].y += uv2.y;
						}
					}
				}
				else
				{
					for (int k = 0; k < array.Length; k++)
					{
						array[k] = uv2;
					}
				}
			}
			else if (clamp01)
			{
				for (int l = 0; l < array.Length; l++)
				{
					array[l].x = Mathf.Clamp01(uv2.x);
					array[l].y = Mathf.Clamp01(uv2.y);
				}
			}
			else
			{
				for (int m = 0; m < array.Length; m++)
				{
					array[m] = uv2;
				}
			}
			destination.uv2 = array;
		}

		public override int GetHashCode()
		{
			return ((1136551442 * -1521134295 + EqualityComparer<Vector2>.Default.GetHashCode(uv2)) * -1521134295 + additive.GetHashCode()) * -1521134295 + clamp01.GetHashCode();
		}
	}

	[HideInInspector]
	public Vector2 uv2;

	[HideInInspector]
	public bool additive;

	[HideInInspector]
	public bool clamp01;
}
public class JK3DVertexColorer : JK3DMeshMod<JK3DVertexColorer.VertexColorerMeshMod>
{
	[Serializable]
	public class VertexColorerMeshMod : BaseSerializableMeshMod, ISerializable
	{
		public Color color;

		public bool additive;

		public bool clamp01;

		public VertexColorerMeshMod()
		{
		}

		public override void Apply(Mesh destination)
		{
			Vector3[] vertices = destination.vertices;
			Color[] array = destination.colors;
			if (array == null || array.Length != vertices.Length)
			{
				array = new Color[vertices.Length];
			}
			if (additive)
			{
				if (destination.colors != null && destination.colors.Length == array.Length)
				{
					if (clamp01)
					{
						for (int i = 0; i < array.Length; i++)
						{
							array[i].r = Mathf.Clamp01(destination.colors[i].r + color.r);
							array[i].g = Mathf.Clamp01(destination.colors[i].g + color.g);
							array[i].b = Mathf.Clamp01(destination.colors[i].b + color.b);
							array[i].a = Mathf.Clamp01(destination.colors[i].a + color.a);
						}
					}
					else
					{
						for (int j = 0; j < array.Length; j++)
						{
							array[j] = destination.colors[j] + color;
						}
					}
				}
				else
				{
					for (int k = 0; k < array.Length; k++)
					{
						array[k] = color;
					}
				}
			}
			else
			{
				for (int l = 0; l < array.Length; l++)
				{
					array[l] = color;
				}
			}
			destination.colors = array;
		}

		public override int GetHashCode()
		{
			return ((1049965578 * -1521134295 + EqualityComparer<Color>.Default.GetHashCode(color)) * -1521134295 + additive.GetHashCode()) * -1521134295 + clamp01.GetHashCode();
		}

		public void SetColor(Color col)
		{
			color = col;
		}

		public void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			info.AddValue("additive", additive, typeof(bool));
			info.AddValue("clamp01", clamp01, typeof(bool));
			info.AddValue("color.r", color.r, typeof(float));
			info.AddValue("color.g", color.g, typeof(float));
			info.AddValue("color.b", color.b, typeof(float));
			info.AddValue("color.a", color.a, typeof(float));
		}

		public VertexColorerMeshMod(SerializationInfo info, StreamingContext context)
		{
			additive = (bool)info.GetValue("additive", typeof(bool));
			clamp01 = (bool)info.GetValue("clamp01", typeof(bool));
			color = default(Color);
			color.r = (float)info.GetValue("color.r", typeof(float));
			color.g = (float)info.GetValue("color.g", typeof(float));
			color.b = (float)info.GetValue("color.b", typeof(float));
			color.a = (float)info.GetValue("color.a", typeof(float));
		}
	}

	[HideInInspector]
	public Color color;

	[HideInInspector]
	public bool additive;

	[HideInInspector]
	public bool clamp01;
}
public class KubrickEventComment : MonoBehaviour
{
	[KubrickAnimFunc]
	private void Comment(string comment)
	{
		UnityEngine.Debug.Log("KU: " + comment);
	}
}
public class KubrickEventLogTest : MonoBehaviour
{
	[KubrickAnimFunc]
	private void TestEventAnim(int testValues)
	{
		UnityEngine.Debug.Log("KU: " + testValues);
	}

	[KubrickAnimFunc]
	private void TestEventAnim(int value0, bool value1, float value2)
	{
		UnityEngine.Debug.Log("KU: " + value0 + ", " + value1.ToString() + ", " + value2);
	}
}
public class KubrickAnimFunc : Attribute
{
	public bool ExecuteInEditMode { get; set; }
}
public class KubrickAnimator : MonoBehaviour
{
	public KubrickAnimClip[] animClips;

	private Animation animComp;

	private UnityEngine.Component[][] clipEventTargets;

	private List<string> animClipNames = new List<string>();

	private int[] currentIndexEvents;

	private bool _init;

	public event Action<WrapMode> finishedAnimationEvent;

	public event Action<WrapMode> startAnimationEvent;

	private void Awake()
	{
		animComp = GetComponent<Animation>();
		if (animComp == null)
		{
			animComp = base.gameObject.AddComponent<Animation>();
		}
		animComp.animatePhysics = false;
		for (int i = 0; i < animClips.Length; i++)
		{
			if (animClips[i] == null)
			{
				UnityEngine.Debug.LogError("Kubrick: Anim clip is null! This may cause issues.", base.gameObject);
				continue;
			}
			animClipNames.Add(animClips[i].clipRef.name);
			AnimationEvent animationEvent = new AnimationEvent();
			animationEvent.intParameter = i;
			animationEvent.time = 0f;
			animationEvent.functionName = "StartAnimation";
			animClips[i].clipRef.AddEvent(animationEvent);
			AnimationEvent animationEvent2 = new AnimationEvent();
			animationEvent2.intParameter = i;
			animationEvent2.time = animClips[i].clipRef.length;
			animationEvent2.functionName = "FinishAnimation";
			animClips[i].clipRef.AddEvent(animationEvent2);
		}
		clipEventTargets = new UnityEngine.Component[animClips.Length][];
		for (int j = 0; j < animClips.Length; j++)
		{
			clipEventTargets[j] = new UnityEngine.Component[animClips[j].events.Count];
			for (int k = 0; k < animClips[j].events.Count; k++)
			{
				KubrickAnimEvent kubrickAnimEvent = animClips[j].events[k];
				clipEventTargets[j][k] = kubrickAnimEvent.GetAnimFuncComponent(base.gameObject, animClips[j]);
			}
		}
		currentIndexEvents = new int[animClipNames.Count];
	}

	private void Start()
	{
		KubrickAnimClip[] array = animClips;
		for (int i = 0; i < array.Length; i++)
		{
			foreach (KubrickAnimEvent @event in array[i].events)
			{
				@event.data.Preload();
			}
		}
		_init = true;
	}

	public void OnDestroy()
	{
		if (!_init)
		{
			return;
		}
		KubrickAnimClip[] array = animClips;
		for (int i = 0; i < array.Length; i++)
		{
			foreach (KubrickAnimEvent @event in array[i].events)
			{
				@event.data.Unload();
			}
		}
	}

	public void SetTime(float newTime)
	{
		for (int i = 0; i < animClipNames.Count; i++)
		{
			List<KubrickAnimEvent> events = animClips[i].events;
			currentIndexEvents[i] = 0;
			_ = animComp[animClipNames[i]];
			while (currentIndexEvents[i] < events.Count && newTime > events[currentIndexEvents[i]].time)
			{
				currentIndexEvents[i]++;
			}
		}
	}

	public void StartAnimation(int clipID)
	{
		if (!base.isActiveAndEnabled)
		{
			return;
		}
		SetTime(0f);
		if (clipID < animClipNames.Count)
		{
			AnimationState animationState = animComp[animClipNames[clipID]];
			if (this.startAnimationEvent != null)
			{
				this.startAnimationEvent(animationState.wrapMode);
			}
		}
	}

	public void FinishAnimation(int clipID)
	{
		if (clipID < animClipNames.Count)
		{
			AnimationState animationState = animComp[animClipNames[clipID]];
			if (animationState.wrapMode == WrapMode.Loop)
			{
				SetTime(animationState.length);
				SetTime(0f);
			}
			else
			{
				SetTime(animationState.length);
			}
			if (this.finishedAnimationEvent != null)
			{
				this.finishedAnimationEvent(animationState.wrapMode);
			}
		}
	}

	private void Update()
	{
		for (int i = 0; i < animClipNames.Count; i++)
		{
			AnimationState animationState = animComp[animClipNames[i]];
			if (!animationState.enabled || !(Mathf.Abs(animationState.speed) > 0f))
			{
				continue;
			}
			float num = animationState.time % animationState.length;
			_ = animationState.normalizedTime % 1f;
			List<KubrickAnimEvent> events = animClips[i].events;
			while (currentIndexEvents[i] < events.Count)
			{
				KubrickAnimEvent kubrickAnimEvent = events[currentIndexEvents[i]];
				if (!(num > kubrickAnimEvent.time))
				{
					break;
				}
				UnityEngine.Component component = clipEventTargets[i][currentIndexEvents[i]];
				if (component != null)
				{
					kubrickAnimEvent.Invoke(component);
				}
				currentIndexEvents[i]++;
			}
		}
	}

	public float GetCurrentClipTime()
	{
		for (int i = 0; i < animClipNames.Count; i++)
		{
			AnimationState animationState = animComp[animClipNames[i]];
			if (animationState.enabled && Mathf.Abs(animationState.speed) > 0f)
			{
				return animationState.time % animationState.length;
			}
		}
		return 0f;
	}

	[ContextMenu("Look for Duplicates")]
	private void LookForDuplicates()
	{
		bool flag = false;
		for (int i = 0; i < animClips.Length; i++)
		{
			KubrickAnimClip kubrickAnimClip = animClips[i];
			int num = 1;
			for (int j = 0; j < animClips.Length; j++)
			{
				if (i != j && kubrickAnimClip == animClips[j])
				{
					num++;
				}
			}
			if (num > 1)
			{
				UnityEngine.Debug.Log($"Found multiple ({num}) entries of '{kubrickAnimClip.clipRef}'!!!!, index: {i}");
				flag = true;
			}
		}
		if (!flag)
		{
			UnityEngine.Debug.Log("No duplicates, your good!");
		}
	}
}
[Serializable]
public class KubrickAnimClip : ScriptableObject
{
	public AnimationClip clipRef;

	[NonSerialized]
	[HideInInspector]
	public new string name;

	public List<KubrickAnimEvent> events = new List<KubrickAnimEvent>();

	public float Duration { get; private set; }

	public override string ToString()
	{
		return name;
	}

	public void AcquireDuration()
	{
		if (clipRef == null)
		{
			Duration = 0f;
			for (int i = 0; i < events.Count; i++)
			{
				events[i].data.AcquireDuration();
				Duration = Mathf.Max(Duration, events[i].time + events[i].GetDuration());
			}
		}
	}
}
[Serializable]
public struct KubrickAnimEvent
{
	public class Comparer : IComparer<KubrickAnimEvent>
	{
		public int Compare(KubrickAnimEvent evtA, KubrickAnimEvent evtB)
		{
			if (evtA.time != evtB.time)
			{
				return (int)Mathf.Sign(evtA.time - evtB.time);
			}
			return evtA.GetHashCode() - evtB.GetHashCode();
		}
	}

	public float time;

	public KubrickAnimEventBase data;

	public int row;

	public static readonly IComparer<KubrickAnimEvent> chronOrder = new Comparer();

	public void Invoke(object target)
	{
		data.Invoke(target);
	}

	public float GetDuration()
	{
		if (data == null)
		{
			return 1f;
		}
		data.AcquireDuration();
		return data.Duration;
	}

	public string GetDisplayName()
	{
		if (!(data != null))
		{
			return "MISSING DATA!";
		}
		return data.GetDisplayName();
	}

	public UnityEngine.Component GetAnimFuncComponent(GameObject context, KubrickAnimClip clip)
	{
		Type type = typeof(KubrickAnimClip).Assembly.GetType(data.targetType);
		UnityEngine.Component component = context.GetComponent(type);
		if (component == null)
		{
			UnityEngine.Debug.LogError("Kubrick: Animation Event - Event target component " + type.Name + " could not be found on the target of clip " + (clip.clipRef ? clip.clipRef.name : "unknown!") + " with the owner " + context.name, context);
		}
		return component;
	}

	public KubrickAnimEvent Clone()
	{
		KubrickAnimEvent result = default(KubrickAnimEvent);
		result.time = time;
		result.data = UnityEngine.Object.Instantiate(data);
		result.row = row;
		return result;
	}
}
public abstract class KubrickAnimEventBase : ScriptableObject
{
	public const BindingFlags INVOKE_BINDING = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;

	public const BindingFlags META_BINDING = BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;

	[HideInInspector]
	[SerializeField]
	public string targetType;

	[HideInInspector]
	[SerializeField]
	protected float _duration = 0.1f;

	protected MethodInfo invokeMI;

	protected MethodInfo durationMI;

	protected MethodInfo displayNameMI;

	protected MethodInfo preloadMI;

	protected MethodInfo unloadMI;

	public float Duration => _duration;

	public abstract Type DeclaringType { get; }

	public abstract Type[] ParameterTypes { get; }

	public abstract string MethodName { get; }

	private void Start()
	{
		Initialise();
	}

	private void OnEnable()
	{
		Initialise();
	}

	protected void Initialise()
	{
		if (!(invokeMI != null))
		{
			Type declaringType = DeclaringType;
			string methodName = MethodName;
			invokeMI = declaringType.GetMethod(methodName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, ParameterTypes, null);
			durationMI = declaringType.GetMethod(methodName + "_GetDuration", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, ParameterTypes, null);
			displayNameMI = declaringType.GetMethod(methodName + "_GetDisplayName", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, ParameterTypes, null);
			preloadMI = declaringType.GetMethod(methodName + "_Preload", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, ParameterTypes, null);
			unloadMI = declaringType.GetMethod(methodName + "_Unload", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, ParameterTypes, null);
			InitialiseDelegates();
		}
	}

	protected abstract void InitialiseDelegates();

	public virtual void Invoke(object target)
	{
		if (invokeMI == null)
		{
			UnityEngine.Debug.Log(MethodName + " delegate was null at runtime, this should never happen (ask Tom E)");
			Initialise();
		}
	}

	public abstract void AcquireDuration();

	public abstract string GetDisplayName();

	public abstract void Preload();

	public abstract void Unload();
}
public class KubrickAutoPlay : MonoBehaviour
{
	public string animationName;

	public Animation anim;

	public KubrickAnimator kubrickAnimatorNew;

	private void Start()
	{
		anim.Play(animationName);
		kubrickAnimatorNew.finishedAnimationEvent += FinishedAnim;
		kubrickAnimatorNew.startAnimationEvent += StartAnim;
	}

	public void FinishedAnim(WrapMode wrapMode)
	{
		UnityEngine.Debug.Log("Finish: " + wrapMode);
	}

	public void StartAnim(WrapMode wrapMode)
	{
		UnityEngine.Debug.Log("Start: " + wrapMode);
	}
}
public static class KubrickResources
{
	private class _ShutdownWorkerThread : MonoBehaviour
	{
		private const int timeout = 3500;

		private void OnApplicationQuit()
		{
			lock (workerThreadSignal)
			{
				workerThreadRun = false;
				workerThreadTask = null;
				workerThreadSignal.Set();
			}
			if (!workerThread.Join(3500))
			{
				UnityEngine.Debug.LogError(workerThread.Name + " did not terminate after " + 3500 + "ms.");
			}
		}
	}

	public class BundleSpec
	{
		public string name;

		public string fileName;

		public BundleSpec(string name)
		{
			this.name = name;
			fileName = "assetbundles/" + name + ".unity3d";
		}
	}

	public class AssetBundleWrapper
	{
		public enum LoadState
		{
			UNLOADED,
			LOADING,
			LOADED
		}

		public BundleSpec bundleSpec;

		public AssetBundle bundle;

		public AssetFolder[] assetPaths;

		public IHaglet loadRoutine;

		public LoadState loadState;

		public IEnumerator<Routine.Yield> LoadBundleRoutine()
		{
			if (loadState != 0)
			{
				yield break;
			}
			loadState = LoadState.LOADING;
			if (0 == 0)
			{
				string path = UnityEngine.Application.streamingAssetsPath + "/" + bundleSpec.fileName;
				AssetBundleCreateRequest bReq = AssetBundle.LoadFromFileAsync(path);
				yield return Wait.Until.True(() => bReq.isDone);
				bundle = bReq.assetBundle;
				string[] assetNames = bundle.GetAllAssetNames();
				AddThreadTask(delegate
				{
					assetPaths = Digest(assetNames);
					assetNames.BuildDictionaries(bundle, ref _assets, ref _resources);
				});
				yield return Wait.Until.False(ThreadBusy, 1, allowPreMetNow: true);
			}
			loadState = LoadState.LOADED;
		}
	}

	public struct BundleMapper
	{
		public AssetBundle bundle;

		public string assetBundlePath;
	}

	public class AssetFolder
	{
		public string folder;

		public List<string> assetPaths;

		public int endIdx;

		public int nameIdx;

		public HashSet<AssetFolder> dependants = new HashSet<AssetFolder>();

		public static AssetFolder NewAPFromPath(string path)
		{
			AssetFolder assetFolder = new AssetFolder();
			assetFolder.endIdx = (Path.HasExtension(path) ? path.LastIndexOf('.') : path.Length);
			assetFolder.nameIdx = path.LastIndexOf(Path.AltDirectorySeparatorChar);
			assetFolder.folder = path.Truncate(path.LastIndexOf(Path.AltDirectorySeparatorChar));
			assetFolder.assetPaths = new List<string>();
			assetFolder.assetPaths.Add(path);
			return assetFolder;
		}

		public static bool AddPath(AssetFolder ap, string path)
		{
			int maxLen = path.LastIndexOf(Path.AltDirectorySeparatorChar);
			string text = path.Truncate(maxLen);
			if (ap.folder != text)
			{
				return false;
			}
			if (ap.assetPaths.Contains(path))
			{
				return true;
			}
			ap.assetPaths.Add(path);
			return true;
		}

		public string GetIndividualMatch(string filter, int filterEndIdx)
		{
			for (int i = 0; i < assetPaths.Count; i++)
			{
				string text = assetPaths[i];
				int j = 0;
				for (int num = Mathf.Min(filterEndIdx, endIdx); j < num; j++)
				{
					if (text[endIdx - 1 - j] != filter[filterEndIdx - 1 - j])
					{
						return text;
					}
				}
			}
			return null;
		}

		public bool FolderMatch(string filter, int filterEndIdx)
		{
			int i = 0;
			for (int num = Mathf.Min(nameIdx, filterEndIdx); i < num; i++)
			{
				if (folder[nameIdx - 1 - i] != filter[filterEndIdx - 1 - i])
				{
					return false;
				}
			}
			return true;
		}
	}

	private static bool initialised = false;

	private static readonly BundleSpec[] bundleSpecs = new BundleSpec[4]
	{
		new BundleSpec("core"),
		new BundleSpec("external"),
		new BundleSpec("core_scenes"),
		new BundleSpec("external_scenes")
	};

	public static Dictionary<string, List<string>> dependentsFromLastBuild = new Dictionary<string, List<string>>();

	private const string bundlesInEditorPrefsKey = "KubrickResources - Use Bundles In Editor";

	private const string bundleIDKeyFormat = "KubrickResources - {0} ID";

	private static AssetBundleWrapper[] bundles;

	private static Dictionary<string, BundleMapper> _assets = new Dictionary<string, BundleMapper>();

	private static Dictionary<string, BundleMapper> _resources = new Dictionary<string, BundleMapper>();

	private static IHaglet unpackFileFromJarRoutine;

	private static IntPtr cls_AssetCopy_g;

	private static IntPtr mth_AssetCopy_copyAsset;

	private static volatile bool workerThreadRun;

	private static volatile Thread workerThread;

	private static volatile Action workerThreadTask;

	private static readonly AutoResetEvent workerThreadSignal = new AutoResetEvent(initialState: false);

	public static Func<bool> ThreadBusy = _ThreadBusy;

	public static bool wasLoaded = false;

	private static readonly string unityResourcesPathSeg = Path.AltDirectorySeparatorChar + "Resources" + Path.AltDirectorySeparatorChar;

	private static string destUnpackedPath;

	private static string sourceAssetPath;

	public static bool isInitialised()
	{
		return initialised;
	}

	public static void AddThreadTask(Action task)
	{
		lock (workerThreadSignal)
		{
			workerThreadTask = (Action)Delegate.Combine(workerThreadTask, task);
			workerThreadSignal.Set();
		}
	}

	private static bool _ThreadBusy()
	{
		return workerThreadTask != null;
	}

	public static void Initialise()
	{
		if (initialised)
		{
			return;
		}
		bundles = new AssetBundleWrapper[bundleSpecs.Length];
		for (int i = 0; i < bundles.Length; i++)
		{
			bundles[i] = new AssetBundleWrapper();
			bundles[i].bundleSpec = bundleSpecs[i];
			Haglet.Create(out bundles[i].loadRoutine, bundles[i].LoadBundleRoutine);
		}
		Haglet.Create(out unpackFileFromJarRoutine, UnpackFileFromJarRoutine);
		using (AndroidJavaClass androidJavaClass2 = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))
		{
			using AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.coatsink.tools.assetcopy.AssetCopy");
			cls_AssetCopy_g = AndroidJNI.NewGlobalRef(androidJavaClass.GetRawClass());
			mth_AssetCopy_copyAsset = AndroidJNI.GetStaticMethodID(cls_AssetCopy_g, "copyAsset", "(Ljava/lang/String;Ljava/lang/String;)V");
			AndroidJavaObject @static = androidJavaClass2.GetStatic<AndroidJavaObject>("currentActivity");
			androidJavaClass.CallStatic("setActivity", @static);
		}
		workerThread = new Thread((ThreadStart)delegate
		{
			try
			{
				AndroidJNI.AttachCurrentThread();
				UnityEngine.Debug.Log("KubrickResources worker thread started and JNI attached.");
				while (workerThreadRun)
				{
					try
					{
						workerThreadSignal.WaitOne();
						if (workerThreadRun && workerThreadTask != null)
						{
							lock (workerThreadSignal)
							{
								workerThreadTask();
								workerThreadTask = null;
							}
						}
					}
					catch (Exception exception)
					{
						UnityEngine.Debug.LogException(exception);
					}
				}
			}
			catch (Exception exception2)
			{
				UnityEngine.Debug.LogException(exception2);
			}
			finally
			{
				AndroidJNI.DetachCurrentThread();
				UnityEngine.Debug.Log("KubrickResources worker thread terminating and JNI detached.");
			}
		});
		GameObject gameObject = new GameObject("KubrickResources Thread Shutter Downer");
		gameObject.AddComponent<_ShutdownWorkerThread>();
		UnityEngine.Object.DontDestroyOnLoad(gameObject);
		gameObject.hideFlags = HideFlags.HideInHierarchy;
		workerThreadRun = true;
		workerThread.Name = "KubrickResources Worker Thread";
		workerThread.IsBackground = true;
		workerThread.Start();
		initialised = true;
	}

	public static void LoadBundle(string bundlePath, bool immediate = false)
	{
		AssetBundleWrapper[] array = bundles;
		foreach (AssetBundleWrapper assetBundleWrapper in array)
		{
			if (assetBundleWrapper.bundleSpec.fileName == bundlePath)
			{
				if (!immediate)
				{
					assetBundleWrapper.loadRoutine.Start();
				}
				else
				{
					UnityEngine.Debug.LogError("Attempted to call LoadBundleImmediate outside of editor.");
				}
				return;
			}
		}
		string text = "Could not find bundle within bundle list at path: " + bundlePath + "\n Bundles are listed below: \n";
		array = bundles;
		foreach (AssetBundleWrapper assetBundleWrapper2 in array)
		{
			text = text + assetBundleWrapper2.bundleSpec.fileName + "\n";
		}
		UnityEngine.Debug.LogError(text);
	}

	private static void TryLoadBundle(ref AssetBundle bundle, string bundleAssetPath, ref AssetFolder[] paths)
	{
		UnityEngine.Debug.Log("[KubrickResources] Loading bundle " + bundleAssetPath);
		bundle = AssetBundle.LoadFromFile(bundleAssetPath);
		if (bundle == null)
		{
			paths = null;
			LogError("Failed to load bundle from \"{0}\"!", bundleAssetPath);
		}
		string[] allAssetNames = bundle.GetAllAssetNames();
		paths = Digest(allAssetNames);
		allAssetNames.BuildDictionaries(bundle, ref _assets, ref _resources);
	}

	public static AssetFolder[] Digest(string[] paths)
	{
		List<AssetFolder> list = new List<AssetFolder>();
		Dictionary<string, AssetFolder> dictionary = new Dictionary<string, AssetFolder>();
		foreach (string text in paths)
		{
			string key = text.ToLower().Truncate(text.LastIndexOf(Path.AltDirectorySeparatorChar));
			if (dictionary.TryGetValue(key, out var value))
			{
				AssetFolder.AddPath(value, text);
				continue;
			}
			value = AssetFolder.NewAPFromPath(text);
			dictionary.Add(key, value);
			list.Add(value);
		}
		return list.ToArray();
	}

	private static void BuildDictionaries(this string[] paths, AssetBundle assetBundle, ref Dictionary<string, BundleMapper> dAssets, ref Dictionary<string, BundleMapper> dResources)
	{
		string text = unityResourcesPathSeg.ToLower();
		for (int i = 0; i < paths.Length; i++)
		{
			string text2 = paths[i].ToLower();
			BundleMapper bundleMapper = default(BundleMapper);
			bundleMapper.bundle = assetBundle;
			bundleMapper.assetBundlePath = text2;
			BundleMapper value = bundleMapper;
			dAssets.Add(text2, value);
			if (text2.Contains(text))
			{
				int num = text2.IndexOf(text) + text.Length;
				int num2 = text2.LastIndexOf('.');
				string key = text2.Substring(num, num2 - num);
				dResources.Add(key, value);
			}
		}
	}

	public static T LoadFirstAsset<T>(string filter, Type type = null, bool throwOnError = false) where T : UnityEngine.Object
	{
		filter = filter.ToLower();
		BundleMapper bundleMapper = default(BundleMapper);
		bundleMapper.bundle = null;
		bundleMapper.assetBundlePath = null;
		if (_assets.ContainsKey(filter))
		{
			bundleMapper = _assets[filter];
		}
		if (bundleMapper.assetBundlePath == null)
		{
			if (throwOnError)
			{
				throw new FileNotFoundException($"No resource asset found matching filter \"{filter}\"!");
			}
			LogError("No resource asset found matching filter \"{0}\"", filter);
			return null;
		}
		return CastAssetObject<T>(bundleMapper.bundle.LoadAsset(bundleMapper.assetBundlePath));
	}

	public static T LoadFirstResource<T>(string filter, bool throwOnError = false) where T : UnityEngine.Object
	{
		T val = Resources.Load<T>(filter);
		if (val == null)
		{
			if (throwOnError)
			{
				throw new FileNotFoundException($"No resource asset found matching filter \"{filter}\"!");
			}
			LogError("No resource asset found matching filter \"{0}\"", filter);
		}
		return val;
	}

	public static T[] LoadAllResources<T>(string filter, bool throwOnError = false, bool silent = false, string nameContainFilter = null) where T : UnityEngine.Object
	{
		T[] array = Resources.LoadAll<T>(filter);
		if (ArrayX.IsNullOrEmpty(array))
		{
			if (throwOnError)
			{
				throw new FileNotFoundException($"No resources found matching filter \"{filter}\"!");
			}
			LogError("No resource assets found matching filter \"{0}\"", filter);
		}
		return array;
	}

	public static BundleMapper[] GetAssetMappings(string filter, string nameContainFilter = null)
	{
		filter = filter.ToLower();
		List<BundleMapper> list = new List<BundleMapper>();
		bool flag = Path.HasExtension(filter);
		int filterEndIdx = (flag ? filter.LastIndexOf('.') : filter.Length);
		if (nameContainFilter != null)
		{
			nameContainFilter = nameContainFilter.ToLower();
		}
		for (int i = 0; i < bundles.Length; i++)
		{
			AssetBundleWrapper assetBundleWrapper = bundles[i];
			AssetFolder[] assetPaths = assetBundleWrapper.assetPaths;
			if (assetPaths == null)
			{
				continue;
			}
			foreach (AssetFolder assetFolder in assetPaths)
			{
				if (!assetFolder.FolderMatch(filter, filterEndIdx))
				{
					continue;
				}
				if (flag)
				{
					string individualMatch = assetFolder.GetIndividualMatch(filter, filterEndIdx);
					if (individualMatch != null)
					{
						list.Add(new BundleMapper
						{
							bundle = assetBundleWrapper.bundle,
							assetBundlePath = individualMatch
						});
						break;
					}
					continue;
				}
				for (int k = 0; k < assetFolder.assetPaths.Count; k++)
				{
					string text = assetFolder.assetPaths[k];
					if (nameContainFilter != null)
					{
						int startIndex = text.LastIndexOf('/') + 1;
						if (text.IndexOf(nameContainFilter, startIndex, StringComparison.Ordinal) < 0)
						{
							continue;
						}
					}
					list.Add(new BundleMapper
					{
						bundle = assetBundleWrapper.bundle,
						assetBundlePath = text
					});
				}
			}
		}
		return list.ToArray();
	}

	private static T CastAssetObject<T>(UnityEngine.Object obj) where T : UnityEngine.Object
	{
		T val = obj as T;
		if (val == null)
		{
			GameObject gameObject = obj as GameObject;
			if (gameObject != null)
			{
				val = gameObject.GetComponent<T>();
			}
		}
		return val;
	}

	private static void LogError(string format, object arg1 = null, object arg2 = null)
	{
		UnityEngine.Debug.LogErrorFormat("[KubrickResources] " + format, arg1, arg2);
	}

	public static Routine.Yield UnpackFileFromJar(string sourcePath, string destPath)
	{
		sourceAssetPath = sourcePath;
		destUnpackedPath = destPath;
		return unpackFileFromJarRoutine.Call();
	}

	public static IEnumerator<Routine.Yield> UnpackFileFromJarRoutine()
	{
		AddThreadTask(delegate
		{
			Directory.CreateDirectory(Path.GetDirectoryName(destUnpackedPath));
			if (File.Exists(destUnpackedPath))
			{
				File.Delete(destUnpackedPath);
			}
			try
			{
				AndroidJNI.PushLocalFrame(5);
				jvalue jvalue = default(jvalue);
				jvalue.l = AndroidJNI.NewStringUTF(sourceAssetPath);
				jvalue jvalue2 = jvalue;
				jvalue = default(jvalue);
				jvalue.l = AndroidJNI.NewStringUTF(destUnpackedPath);
				jvalue jvalue3 = jvalue;
				AndroidJNI.CallStaticVoidMethod(cls_AssetCopy_g, mth_AssetCopy_copyAsset, new jvalue[2] { jvalue2, jvalue3 });
			}
			finally
			{
				AndroidJNI.PopLocalFrame(IntPtr.Zero);
			}
		});
		yield return Wait.Until.False(ThreadBusy, 1, allowPreMetNow: true);
		UnityEngine.Debug.Log("[RESOURCES] write of '" + destUnpackedPath + "' completed.");
	}
}
[Serializable]
public struct ComplexAngle
{
	public float r;

	public float i;

	public const float cwRevRadians = (float)Math.PI * -2f;

	public const float cwRevDegrees = 360f;

	public static readonly ComplexAngle radian = FromEuler(1f);

	public static readonly ComplexAngle cwDegree = FromEuler(-360f);

	public static readonly ComplexAngle cwRev = FromEuler((float)Math.PI * -2f);

	public static readonly ComplexAngle zero = FromEuler(0f);

	public static readonly ComplexAngle cwQuarter = FromEuler(-(float)Math.PI / 2f);

	public static readonly ComplexAngle cwHalf = FromEuler(-(float)Math.PI);

	public static readonly ComplexAngle cwThreeQuarters = FromEuler(-4.712389f);

	public float euler => Mathf.Atan2(i, r);

	public Vector2 direction => new Vector2(r, i);

	public Vector3 directionXZ => new Vector3(r, 0f, i);

	public Vector3 directionXY => new Vector3(r, i, 0f);

	public Vector3 directionYZ => new Vector3(0f, r, i);

	public ComplexAngle normalize
	{
		get
		{
			ComplexAngle result = default(ComplexAngle);
			float num = 1f / Mathf.Sqrt(r * r + i * i);
			result.r = r * num;
			result.i = i * num;
			return result;
		}
	}

	public ComplexAngle conjugate => new ComplexAngle(r, 0f - i);

	public ComplexAngle(float r, float c)
	{
		this.r = r;
		i = c;
	}

	public override string ToString()
	{
		return $"({r}, {i})";
	}

	public static ComplexAngle FromEuler(float angle)
	{
		ComplexAngle result = default(ComplexAngle);
		result.r = Mathf.Cos(angle);
		result.i = Mathf.Sin(angle);
		return result;
	}

	public static ComplexAngle FromVec(Vector2 dir)
	{
		dir = dir.normalized;
		return new ComplexAngle(dir.x, dir.y);
	}

	public static ComplexAngle FromVecXZ(Vector3 dir)
	{
		Vector2 normalized = new Vector2(dir.x, dir.z).normalized;
		return new ComplexAngle(normalized.x, normalized.y);
	}

	public static ComplexAngle FromVecPrenormalized(Vector2 direction)
	{
		return new ComplexAngle(direction.x, direction.y);
	}

	public static ComplexAngle FromVecXYPrenormalized(Vector3 direction)
	{
		return new ComplexAngle(direction.x, direction.y);
	}

	public static ComplexAngle FromVecYZPrenormalized(Vector3 direction)
	{
		return new ComplexAngle(direction.y, direction.z);
	}

	public static ComplexAngle FromVecXZPrenormalized(Vector3 direction)
	{
		return new ComplexAngle(direction.x, direction.z);
	}

	public static Vector2 operator *(ComplexAngle a, Vector2 b)
	{
		return new Vector2(a.r * b.x - a.i * b.y, a.r * b.y + a.i * b.x);
	}

	public static ComplexAngle operator *(ComplexAngle a, float s)
	{
		return new ComplexAngle(a.r * s, a.i * s);
	}

	public static ComplexAngle operator -(ComplexAngle a, ComplexAngle b)
	{
		return new ComplexAngle(a.r - b.r, a.i - b.i);
	}

	public static ComplexAngle operator +(ComplexAngle a, ComplexAngle b)
	{
		return new ComplexAngle(a.r + b.r, a.i + b.i);
	}

	public static ComplexAngle operator *(ComplexAngle a, ComplexAngle b)
	{
		return new ComplexAngle(a.r * b.r - a.i * b.i, a.r * b.i + a.i * b.r);
	}

	public static float GetEulerBetween(ComplexAngle a, ComplexAngle b)
	{
		return (a * b.conjugate).euler;
	}

	public static ComplexAngle Nlerp(ComplexAngle a, ComplexAngle b, float t)
	{
		ComplexAngle complexAngle = default(ComplexAngle);
		complexAngle.r = a.r + (b.r - a.r) * t;
		complexAngle.i = a.i + (b.i - a.i) * t;
		return complexAngle.normalize;
	}

	public static ComplexAngle Slerp(ComplexAngle a, ComplexAngle b, float t)
	{
		t = Mathf.Clamp01(t);
		float num = a.r * b.r + a.i * b.i;
		if (num > 0.9995f)
		{
			return Nlerp(a, b, t);
		}
		ComplexAngle complexAngle = ((!(num < -0.995f)) ? (b - a * num).normalize : new ComplexAngle(0f - a.i, a.r));
		num = Mathf.Clamp(num, -1f, 1f);
		float f = Mathf.Acos(num) * t;
		return a * Mathf.Cos(f) + complexAngle * Mathf.Sin(f);
	}
}
[Serializable]
public struct v2i
{
	private class EQComparer : EqualityComparer<v2i>
	{
		public override bool Equals(v2i v1, v2i v2)
		{
			return v1 == v2;
		}

		public override int GetHashCode(v2i v)
		{
			return v.GetHashCode();
		}
	}

	public int x;

	public int y;

	public static readonly v2i zero = new v2i(0, 0);

	public static readonly v2i one = new v2i(1, 1);

	public static readonly v2i left = new v2i(-1, 0);

	public static readonly v2i right = new v2i(1, 0);

	public static readonly v2i up = new v2i(0, 1);

	public static readonly v2i down = new v2i(0, -1);

	public static readonly EqualityComparer<v2i> eqComparer = new EQComparer();

	public float Magnitude => Mathf.Sqrt(x * x + y * y);

	public int this[uint index]
	{
		get
		{
			return index switch
			{
				0u => x, 
				1u => y, 
				_ => int.MaxValue, 
			};
		}
		set
		{
			if (index == 0)
			{
				x = value;
			}
			if (index == 1)
			{
				y = value;
			}
		}
	}

	public v2i(int x, int y)
	{
		this.x = x;
		this.y = y;
	}

	public v2i(Vector2 v)
	{
		x = (int)v.x;
		y = (int)v.y;
	}

	public static v2i operator +(v2i lhs, v2i rhs)
	{
		return new v2i(lhs.x + rhs.x, lhs.y + rhs.y);
	}

	public static v2i operator -(v2i lhs, v2i rhs)
	{
		return new v2i(lhs.x - rhs.x, lhs.y - rhs.y);
	}

	public static v2i operator *(v2i lhs, int scalar)
	{
		return new v2i(lhs.x * scalar, lhs.y * scalar);
	}

	public static v2i operator /(v2i lhs, int scalar)
	{
		return new v2i(lhs.x / scalar, lhs.y / scalar);
	}

	public static v2i operator -(v2i v0)
	{
		return new v2i(-v0.x, -v0.y);
	}

	public static v2i operator +(v2i v0, OctDir dir)
	{
		Vector3 vector = dir.ToV3XZ();
		return new v2i(v0.x + (int)vector.x, v0.y + (int)vector.z);
	}

	public static v2i operator -(v2i v0, OctDir dir)
	{
		Vector3 vector = dir.ToV3XZ();
		return new v2i(v0.x - (int)vector.x, v0.y - (int)vector.z);
	}

	public static v2i Scale(v2i v0, v2i v1)
	{
		return new v2i(v0.x * v1.x, v0.y * v1.y);
	}

	public static v2i InvScale(v2i v0, v2i v1)
	{
		return new v2i(v0.x / v1.x, v0.y / v1.y);
	}

	public static Vector2 InvScaleFloat(v2i v0, v2i v1)
	{
		return new Vector2((float)v0.x / (float)v1.x, (float)v0.y / (float)v1.y);
	}

	public static v2i Min(v2i v0, v2i v1)
	{
		return new v2i(Math.Min(v0.x, v1.x), Math.Min(v0.y, v1.y));
	}

	public static v2i Max(v2i v0, v2i v1)
	{
		return new v2i(Math.Max(v0.x, v1.x), Math.Max(v0.y, v1.y));
	}

	public static int Dot(v2i v0, v2i v1)
	{
		return v0.x * v1.x + v0.y * v1.y;
	}

	public static int DistanceSqr(v2i v0, v2i v1)
	{
		v2i obj = v0 - v1;
		return Dot(obj, obj);
	}

	public static float Distance(v2i v0, v2i v1)
	{
		if (v0 == v1)
		{
			return 0f;
		}
		v2i obj = v0 - v1;
		return Mathf.Sqrt(Dot(obj, obj));
	}

	public static int ManhattanDistance(v2i v0, v2i v1)
	{
		return Mathf.Abs(v0.x - v1.x) + Mathf.Abs(v0.y - v1.y);
	}

	public static bool IsNeighbour(v2i v0, v2i v1)
	{
		v2i v2i2 = v0 - v1;
		if (v2i2.x >= -1 && v2i2.x <= 1 && v2i2.y >= -1)
		{
			return v2i2.y <= 1;
		}
		return false;
	}

	public static v2i Normalize(v2i dir)
	{
		if (dir == zero)
		{
			return dir;
		}
		float num = Mathf.Sqrt(Dot(dir, dir));
		v2i result = default(v2i);
		result.x = (int)((float)dir.x / num);
		result.y = (int)((float)dir.y / num);
		return result;
	}

	public static v2i DirectionXZ(Vector3 direction)
	{
		v2i result = default(v2i);
		result.x = ((Mathf.Abs(direction.x) > 0.35355338f) ? ((direction.x > 0f) ? 1 : (-1)) : 0);
		result.y = ((Mathf.Abs(direction.z) > 0.35355338f) ? ((direction.z > 0f) ? 1 : (-1)) : 0);
		return result;
	}

	public static Vector3 DirectionXZ(v2i direction)
	{
		return new Vector3(direction.x, 0f, direction.y).normalized;
	}

	public static bool operator ==(v2i lhs, v2i rhs)
	{
		if (lhs.x != rhs.x)
		{
			return false;
		}
		if (lhs.y != rhs.y)
		{
			return false;
		}
		return true;
	}

	public static bool operator !=(v2i lhs, v2i rhs)
	{
		return !(lhs == rhs);
	}

	public v2i SimpleClamped(float newMaxMag)
	{
		float num = x;
		float num2 = y;
		float num3 = num * num + num2 * num2;
		if (num3 <= newMaxMag * newMaxMag)
		{
			return this;
		}
		float num4 = newMaxMag / Mathf.Sqrt(num3);
		return new v2i(Mathf.FloorToInt(num * num4), Mathf.FloorToInt(num2 * num4));
	}

	public override string ToString()
	{
		return "{" + x + ", " + y + "}";
	}

	public override bool Equals(object obj)
	{
		if (obj == null)
		{
			return false;
		}
		if (!(obj is v2i v2i2))
		{
			return false;
		}
		if (base.Equals(obj))
		{
			return this == v2i2;
		}
		return false;
	}

	public override int GetHashCode()
	{
		int num = 1;
		num = 31 * num + x;
		return 31 * num + y;
	}
}
public class CompositeShape
{
	public static Mesh CalculatePolygonNormalsAndRenderMesh(Shape[] shapes)
	{
		for (int i = 0; i < shapes.Length; i++)
		{
			if (shapes[i].normals == null || shapes[i].normals.Length != shapes[i].points.Length)
			{
				shapes[i].normals = new Vector2[shapes[i].points.Length];
			}
			if (shapes[i].pointsInner == null || shapes[i].pointsInner.Length != shapes[i].points.Length)
			{
				shapes[i].pointsInner = new Vector2[shapes[i].points.Length];
			}
		}
		List<CompositeShapeData> list = new List<CompositeShapeData>();
		for (int j = 0; j < shapes.Length; j++)
		{
			CompositeShapeData compositeShapeData = new CompositeShapeData(shapes[j].points, j);
			if (compositeShapeData.IsValidShape)
			{
				list.Add(compositeShapeData);
			}
		}
		for (int k = 0; k < list.Count; k++)
		{
			for (int l = 0; l < list.Count; l++)
			{
				if (k != l && list[k].IsParentOf(list[l]))
				{
					list[l].parents.Add(list[k]);
				}
			}
		}
		CompositeShapeData[] array = list.Where((CompositeShapeData x) => x.parents.Count % 2 != 0).ToArray();
		foreach (CompositeShapeData compositeShapeData2 in array)
		{
			compositeShapeData2.parents.OrderByDescending((CompositeShapeData x) => x.parents.Count).First().holes.Add(compositeShapeData2);
		}
		CompositeShapeData[] array2 = list.Where((CompositeShapeData x) => x.parents.Count % 2 == 0).ToArray();
		array = array2;
		for (int m = 0; m < array.Length; m++)
		{
			array[m].RemoveOverlappingHoles();
		}
		List<Polygon> list2 = new List<Polygon>();
		foreach (CompositeShapeData compositeShapeData3 in array2)
		{
			Polygon polygon = new Polygon(compositeShapeData3.points, compositeShapeData3.holes.Select((CompositeShapeData h) => h.points).ToArray());
			int num = compositeShapeData3.points.Length;
			int num2 = 0;
			int num3 = num - 1;
			while (num2 < num)
			{
				int num4 = (num2 + 1) % num;
				Vector2 vector = compositeShapeData3.points[num3];
				Vector2 vector2 = compositeShapeData3.points[num2];
				Vector2 vector3 = compositeShapeData3.points[num4];
				Vector2 normalized = VectorX.Cross(vector - vector2).normalized;
				Vector2 normalized2 = VectorX.Cross(vector2 - vector3).normalized;
				Vector2 vector4 = (normalized + normalized2).normalized;
				if (polygon.isHullReversed)
				{
					vector4 = -vector4;
				}
				shapes[compositeShapeData3.shapeIdx].normals[num2] = vector4;
				shapes[compositeShapeData3.shapeIdx].pointsInner[num2] = vector2 + vector4 * 0.5f;
				num3 = num2++;
			}
			for (int num5 = 0; num5 < compositeShapeData3.holes.Count; num5++)
			{
				CompositeShapeData compositeShapeData4 = compositeShapeData3.holes[num5];
				int num6 = compositeShapeData4.points.Length;
				int num7 = 0;
				int num8 = num6 - 1;
				while (num7 < num6)
				{
					int num9 = (num7 + 1) % num6;
					Vector2 vector5 = compositeShapeData4.points[num8];
					Vector2 vector6 = compositeShapeData4.points[num7];
					Vector2 vector7 = compositeShapeData4.points[num9];
					Vector2 normalized3 = VectorX.Cross(vector6 - vector5).normalized;
					Vector2 normalized4 = VectorX.Cross(vector7 - vector6).normalized;
					Vector2 vector8 = (normalized3 + normalized4).normalized;
					if (!polygon.isHoleReversed[num5])
					{
						vector8 = -vector8;
					}
					shapes[compositeShapeData4.shapeIdx].normals[num7] = vector8;
					shapes[compositeShapeData4.shapeIdx].pointsInner[num7] = vector6 + vector8 * 0.65f;
					num8 = num7++;
				}
			}
			list2.Add(polygon);
		}
		Vector3[] array3 = list2.SelectMany((Polygon x) => x.points.Select((Vector2 v2) => new Vector3(v2.x, 0f, v2.y))).ToArray();
		List<int> list3 = new List<int>();
		int num10 = 0;
		for (int num11 = 0; num11 < list2.Count; num11++)
		{
			int[] array4 = new Triangulator(list2[num11]).Triangulate();
			for (int num12 = 0; num12 < array4.Length; num12++)
			{
				list3.Add(array4[num12] + num10);
			}
			num10 += list2[num11].numPoints;
		}
		int[] triangles = list3.ToArray();
		return new Mesh
		{
			vertices = array3,
			triangles = triangles,
			normals = array3.Select((Vector3 x) => Vector3.up).ToArray()
		};
	}
}
public class CompositeShapeData
{
	public struct LineSegment
	{
		public readonly Vector2 a;

		public readonly Vector2 b;

		public LineSegment(Vector2 a, Vector2 b)
		{
			this.a = a;
			this.b = b;
		}
	}

	public readonly Vector2[] points;

	public readonly Polygon polygon;

	public readonly int[] triangles;

	public readonly int shapeIdx;

	public List<CompositeShapeData> parents = new List<CompositeShapeData>();

	public List<CompositeShapeData> holes = new List<CompositeShapeData>();

	public bool IsValidShape { get; private set; }

	public CompositeShapeData(Vector2[] points, int shapeIdx)
	{
		this.points = points;
		this.shapeIdx = shapeIdx;
		IsValidShape = points.Length >= 3 && !IntersectsWithSelf();
		if (IsValidShape)
		{
			polygon = new Polygon(this.points);
			Triangulator triangulator = new Triangulator(polygon);
			triangles = triangulator.Triangulate();
		}
	}

	public void RemoveOverlappingHoles()
	{
		for (int i = 0; i < holes.Count; i++)
		{
			for (int j = i + 1; j < holes.Count; j++)
			{
				if (holes[i].OverlapsPartially(holes[j]))
				{
					holes[i].IsValidShape = false;
					break;
				}
			}
		}
		for (int num = holes.Count - 1; num >= 0; num--)
		{
			if (!holes[num].IsValidShape)
			{
				holes.RemoveAt(num);
			}
		}
	}

	public bool IsParentOf(CompositeShapeData otherShape)
	{
		if (otherShape.parents.Contains(this))
		{
			return true;
		}
		if (parents.Contains(otherShape))
		{
			return false;
		}
		bool flag = false;
		for (int i = 0; i < triangles.Length; i += 3)
		{
			if (Maths2D.PointInTriangle(polygon.points[triangles[i]], polygon.points[triangles[i + 1]], polygon.points[triangles[i + 2]], otherShape.points[0]))
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			return false;
		}
		for (int j = 0; j < points.Length; j++)
		{
			LineSegment lineSegment = new LineSegment(points[j], points[(j + 1) % points.Length]);
			for (int k = 0; k < otherShape.points.Length; k++)
			{
				LineSegment lineSegment2 = new LineSegment(otherShape.points[k], otherShape.points[(k + 1) % otherShape.points.Length]);
				if (Maths2D.LineSegmentsIntersect(lineSegment.a, lineSegment.b, lineSegment2.a, lineSegment2.b))
				{
					return false;
				}
			}
		}
		return true;
	}

	public bool OverlapsPartially(CompositeShapeData otherShape)
	{
		for (int i = 0; i < points.Length; i++)
		{
			LineSegment lineSegment = new LineSegment(points[i], points[(i + 1) % points.Length]);
			for (int j = 0; j < otherShape.points.Length; j++)
			{
				LineSegment lineSegment2 = new LineSegment(otherShape.points[j], otherShape.points[(j + 1) % otherShape.points.Length]);
				if (Maths2D.LineSegmentsIntersect(lineSegment.a, lineSegment.b, lineSegment2.a, lineSegment2.b))
				{
					return true;
				}
			}
		}
		return false;
	}

	public bool IntersectsWithSelf()
	{
		for (int i = 0; i < points.Length; i++)
		{
			LineSegment lineSegment = new LineSegment(points[i], points[(i + 1) % points.Length]);
			for (int j = i + 2; j < points.Length; j++)
			{
				if ((j + 1) % points.Length != i)
				{
					LineSegment lineSegment2 = new LineSegment(points[j], points[(j + 1) % points.Length]);
					if (Maths2D.LineSegmentsIntersect(lineSegment.a, lineSegment.b, lineSegment2.a, lineSegment2.b))
					{
						return true;
					}
				}
			}
		}
		return false;
	}
}
public static class ExtensionMethods
{
	public static Vector2 ToXZ(this Vector3 v3)
	{
		return new Vector2(v3.x, v3.z);
	}
}
[Serializable]
public struct Shape
{
	public Vector2[] points;

	public Vector2[] pointsInner;

	public Vector2[] normals;

	public float GetArea()
	{
		float num = 0f;
		for (int i = 0; i < points.Length; i++)
		{
			int num2 = (i + 1) % points.Length;
			num += points[i].x * points[num2].y;
			num -= points[i].y * points[num2].x;
		}
		if (num == 0f)
		{
			return num;
		}
		return Mathf.Abs(num / 2f);
	}
}
[Serializable]
public class GameObject_BundleRef : BundleRef<GameObject>
{
}
[Serializable]
public class Transform_BundleRef : BundleRef<Transform>
{
}
public class EmptyBehaviour : MonoBehaviour
{
}
public class PlayerPrefsX
{
	private enum ArrayType
	{
		Float,
		Int32,
		Bool,
		String,
		Vector2,
		Vector3,
		Quaternion,
		Color
	}

	private static int endianDiff1;

	private static int endianDiff2;

	private static int idx;

	private static byte[] byteBlock;

	public static bool SetBool(string name, bool value)
	{
		try
		{
			PlayerPrefs.SetInt(name, value ? 1 : 0);
		}
		catch
		{
			return false;
		}
		return true;
	}

	public static bool GetBool(string name)
	{
		return PlayerPrefs.GetInt(name) == 1;
	}

	public static bool GetBool(string name, bool defaultValue)
	{
		if (PlayerPrefs.HasKey(name))
		{
			return GetBool(name);
		}
		return defaultValue;
	}

	public static bool SetVector2(string key, Vector2 vector)
	{
		return SetFloatArray(key, new float[2] { vector.x, vector.y });
	}

	private static Vector2 GetVector2(string key)
	{
		float[] floatArray = GetFloatArray(key);
		if (floatArray.Length < 2)
		{
			return Vector2.zero;
		}
		return new Vector2(floatArray[0], floatArray[1]);
	}

	public static Vector2 GetVector2(string key, Vector2 defaultValue)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetVector2(key);
		}
		return defaultValue;
	}

	public static bool SetVector3(string key, Vector3 vector)
	{
		return SetFloatArray(key, new float[3] { vector.x, vector.y, vector.z });
	}

	public static Vector3 GetVector3(string key)
	{
		float[] floatArray = GetFloatArray(key);
		if (floatArray.Length < 3)
		{
			return Vector3.zero;
		}
		return new Vector3(floatArray[0], floatArray[1], floatArray[2]);
	}

	public static Vector3 GetVector3(string key, Vector3 defaultValue)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetVector3(key);
		}
		return defaultValue;
	}

	public static bool SetQuaternion(string key, Quaternion vector)
	{
		return SetFloatArray(key, new float[4] { vector.x, vector.y, vector.z, vector.w });
	}

	public static Quaternion GetQuaternion(string key)
	{
		float[] floatArray = GetFloatArray(key);
		if (floatArray.Length < 4)
		{
			return Quaternion.identity;
		}
		return new Quaternion(floatArray[0], floatArray[1], floatArray[2], floatArray[3]);
	}

	public static Quaternion GetQuaternion(string key, Quaternion defaultValue)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetQuaternion(key);
		}
		return defaultValue;
	}

	public static bool SetColor(string key, Color color)
	{
		return SetFloatArray(key, new float[4] { color.r, color.g, color.b, color.a });
	}

	public static Color GetColor(string key)
	{
		float[] floatArray = GetFloatArray(key);
		if (floatArray.Length < 4)
		{
			return new Color(0f, 0f, 0f, 0f);
		}
		return new Color(floatArray[0], floatArray[1], floatArray[2], floatArray[3]);
	}

	public static Color GetColor(string key, Color defaultValue)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetColor(key);
		}
		return defaultValue;
	}

	public static bool SetBoolArray(string key, bool[] boolArray)
	{
		if (boolArray.Length == 0)
		{
			UnityEngine.Debug.LogError("The bool array cannot have 0 entries when setting " + key);
			return false;
		}
		byte[] array = new byte[(boolArray.Length + 7) / 8 + 5];
		array[0] = Convert.ToByte(ArrayType.Bool);
		new BitArray(boolArray).CopyTo(array, 5);
		Initialize();
		ConvertInt32ToBytes(boolArray.Length, array);
		return SaveBytes(key, array);
	}

	public static bool[] GetBoolArray(string key)
	{
		if (PlayerPrefs.HasKey(key))
		{
			byte[] array = Convert.FromBase64String(PlayerPrefs.GetString(key));
			if (array.Length < 6)
			{
				UnityEngine.Debug.LogError("Corrupt preference file for " + key);
				return new bool[0];
			}
			if (array[0] != 2)
			{
				UnityEngine.Debug.LogError(key + " is not a boolean array");
				return new bool[0];
			}
			Initialize();
			byte[] array2 = new byte[array.Length - 5];
			Array.Copy(array, 5, array2, 0, array2.Length);
			BitArray obj = new BitArray(array2)
			{
				Length = ConvertBytesToInt32(array)
			};
			bool[] array3 = new bool[obj.Count];
			obj.CopyTo(array3, 0);
			return array3;
		}
		return new bool[0];
	}

	public static bool[] GetBoolArray(string key, bool defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetBoolArray(key);
		}
		bool[] array = new bool[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	public static bool SetStringArray(string key, string[] stringArray)
	{
		if (stringArray.Length == 0)
		{
			UnityEngine.Debug.LogError("The string array cannot have 0 entries when setting " + key);
			return false;
		}
		byte[] array = new byte[stringArray.Length + 1];
		array[0] = Convert.ToByte(ArrayType.String);
		Initialize();
		for (int i = 0; i < stringArray.Length; i++)
		{
			if (stringArray[i] == null)
			{
				UnityEngine.Debug.LogError("Can't save null entries in the string array when setting " + key);
				return false;
			}
			if (stringArray[i].Length > 255)
			{
				UnityEngine.Debug.LogError("Strings cannot be longer than 255 characters when setting " + key);
				return false;
			}
			array[idx++] = (byte)stringArray[i].Length;
		}
		try
		{
			PlayerPrefs.SetString(key, Convert.ToBase64String(array) + "|" + string.Join("", stringArray));
		}
		catch
		{
			return false;
		}
		return true;
	}

	public static string[] GetStringArray(string key)
	{
		if (PlayerPrefs.HasKey(key))
		{
			string @string = PlayerPrefs.GetString(key);
			int num = @string.IndexOf("|"[0]);
			if (num < 4)
			{
				UnityEngine.Debug.LogError("Corrupt preference file for " + key);
				return new string[0];
			}
			byte[] array = Convert.FromBase64String(@string.Substring(0, num));
			if (array[0] != 3)
			{
				UnityEngine.Debug.LogError(key + " is not a string array");
				return new string[0];
			}
			Initialize();
			int num2 = array.Length - 1;
			string[] array2 = new string[num2];
			int num3 = num + 1;
			for (int i = 0; i < num2; i++)
			{
				int num4 = array[idx++];
				if (num3 + num4 > @string.Length)
				{
					UnityEngine.Debug.LogError("Corrupt preference file for " + key);
					return new string[0];
				}
				array2[i] = @string.Substring(num3, num4);
				num3 += num4;
			}
			return array2;
		}
		return new string[0];
	}

	public static string[] GetStringArray(string key, string defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetStringArray(key);
		}
		string[] array = new string[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	public static bool SetIntArray(string key, int[] intArray)
	{
		return SetValue(key, intArray, ArrayType.Int32, 1, ConvertFromInt);
	}

	public static bool SetFloatArray(string key, float[] floatArray)
	{
		return SetValue(key, floatArray, ArrayType.Float, 1, ConvertFromFloat);
	}

	public static bool SetVector2Array(string key, Vector2[] vector2Array)
	{
		return SetValue(key, vector2Array, ArrayType.Vector2, 2, ConvertFromVector2);
	}

	public static bool SetVector3Array(string key, Vector3[] vector3Array)
	{
		return SetValue(key, vector3Array, ArrayType.Vector3, 3, ConvertFromVector3);
	}

	public static bool SetQuaternionArray(string key, Quaternion[] quaternionArray)
	{
		return SetValue(key, quaternionArray, ArrayType.Quaternion, 4, ConvertFromQuaternion);
	}

	public static bool SetColorArray(string key, Color[] colorArray)
	{
		return SetValue(key, colorArray, ArrayType.Color, 4, ConvertFromColor);
	}

	private static bool SetValue<T>(string key, T array, ArrayType arrayType, int vectorNumber, Action<T, byte[], int> convert) where T : IList
	{
		if (array.Count == 0)
		{
			UnityEngine.Debug.LogError("The " + arrayType.ToString() + " array cannot have 0 entries when setting " + key);
			return false;
		}
		byte[] array2 = new byte[4 * array.Count * vectorNumber + 1];
		array2[0] = Convert.ToByte(arrayType);
		Initialize();
		for (int i = 0; i < array.Count; i++)
		{
			convert(array, array2, i);
		}
		return SaveBytes(key, array2);
	}

	private static void ConvertFromInt(int[] array, byte[] bytes, int i)
	{
		ConvertInt32ToBytes(array[i], bytes);
	}

	private static void ConvertFromFloat(float[] array, byte[] bytes, int i)
	{
		ConvertFloatToBytes(array[i], bytes);
	}

	private static void ConvertFromVector2(Vector2[] array, byte[] bytes, int i)
	{
		ConvertFloatToBytes(array[i].x, bytes);
		ConvertFloatToBytes(array[i].y, bytes);
	}

	private static void ConvertFromVector3(Vector3[] array, byte[] bytes, int i)
	{
		ConvertFloatToBytes(array[i].x, bytes);
		ConvertFloatToBytes(array[i].y, bytes);
		ConvertFloatToBytes(array[i].z, bytes);
	}

	private static void ConvertFromQuaternion(Quaternion[] array, byte[] bytes, int i)
	{
		ConvertFloatToBytes(array[i].x, bytes);
		ConvertFloatToBytes(array[i].y, bytes);
		ConvertFloatToBytes(array[i].z, bytes);
		ConvertFloatToBytes(array[i].w, bytes);
	}

	private static void ConvertFromColor(Color[] array, byte[] bytes, int i)
	{
		ConvertFloatToBytes(array[i].r, bytes);
		ConvertFloatToBytes(array[i].g, bytes);
		ConvertFloatToBytes(array[i].b, bytes);
		ConvertFloatToBytes(array[i].a, bytes);
	}

	public static int[] GetIntArray(string key)
	{
		List<int> list = new List<int>();
		GetValue(key, list, ArrayType.Int32, 1, ConvertToInt);
		return list.ToArray();
	}

	public static int[] GetIntArray(string key, int defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetIntArray(key);
		}
		int[] array = new int[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	public static float[] GetFloatArray(string key)
	{
		List<float> list = new List<float>();
		GetValue(key, list, ArrayType.Float, 1, ConvertToFloat);
		return list.ToArray();
	}

	public static float[] GetFloatArray(string key, float defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetFloatArray(key);
		}
		float[] array = new float[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	public static Vector2[] GetVector2Array(string key)
	{
		List<Vector2> list = new List<Vector2>();
		GetValue(key, list, ArrayType.Vector2, 2, ConvertToVector2);
		return list.ToArray();
	}

	public static Vector2[] GetVector2Array(string key, Vector2 defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetVector2Array(key);
		}
		Vector2[] array = new Vector2[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	public static Vector3[] GetVector3Array(string key)
	{
		List<Vector3> list = new List<Vector3>();
		GetValue(key, list, ArrayType.Vector3, 3, ConvertToVector3);
		return list.ToArray();
	}

	public static Vector3[] GetVector3Array(string key, Vector3 defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetVector3Array(key);
		}
		Vector3[] array = new Vector3[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	public static Quaternion[] GetQuaternionArray(string key)
	{
		List<Quaternion> list = new List<Quaternion>();
		GetValue(key, list, ArrayType.Quaternion, 4, ConvertToQuaternion);
		return list.ToArray();
	}

	public static Quaternion[] GetQuaternionArray(string key, Quaternion defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetQuaternionArray(key);
		}
		Quaternion[] array = new Quaternion[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	public static Color[] GetColorArray(string key)
	{
		List<Color> list = new List<Color>();
		GetValue(key, list, ArrayType.Color, 4, ConvertToColor);
		return list.ToArray();
	}

	public static Color[] GetColorArray(string key, Color defaultValue, int defaultSize)
	{
		if (PlayerPrefs.HasKey(key))
		{
			return GetColorArray(key);
		}
		Color[] array = new Color[defaultSize];
		for (int i = 0; i < defaultSize; i++)
		{
			array[i] = defaultValue;
		}
		return array;
	}

	private static void GetValue<T>(string key, T list, ArrayType arrayType, int vectorNumber, Action<T, byte[]> convert) where T : IList
	{
		if (!PlayerPrefs.HasKey(key))
		{
			return;
		}
		byte[] array = Convert.FromBase64String(PlayerPrefs.GetString(key));
		if ((array.Length - 1) % (vectorNumber * 4) != 0)
		{
			UnityEngine.Debug.LogError("Corrupt preference file for " + key);
			return;
		}
		if ((ArrayType)array[0] != arrayType)
		{
			UnityEngine.Debug.LogError(key + " is not a " + arrayType.ToString() + " array");
			return;
		}
		Initialize();
		int num = (array.Length - 1) / (vectorNumber * 4);
		for (int i = 0; i < num; i++)
		{
			convert(list, array);
		}
	}

	private static void ConvertToInt(List<int> list, byte[] bytes)
	{
		list.Add(ConvertBytesToInt32(bytes));
	}

	private static void ConvertToFloat(List<float> list, byte[] bytes)
	{
		list.Add(ConvertBytesToFloat(bytes));
	}

	private static void ConvertToVector2(List<Vector2> list, byte[] bytes)
	{
		list.Add(new Vector2(ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes)));
	}

	private static void ConvertToVector3(List<Vector3> list, byte[] bytes)
	{
		list.Add(new Vector3(ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes)));
	}

	private static void ConvertToQuaternion(List<Quaternion> list, byte[] bytes)
	{
		list.Add(new Quaternion(ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes)));
	}

	private static void ConvertToColor(List<Color> list, byte[] bytes)
	{
		list.Add(new Color(ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes), ConvertBytesToFloat(bytes)));
	}

	public static void ShowArrayType(string key)
	{
		byte[] array = Convert.FromBase64String(PlayerPrefs.GetString(key));
		if (array.Length != 0)
		{
			ArrayType arrayType = (ArrayType)array[0];
			UnityEngine.Debug.Log(key + " is a " + arrayType.ToString() + " array");
		}
	}

	private static void Initialize()
	{
		if (BitConverter.IsLittleEndian)
		{
			endianDiff1 = 0;
			endianDiff2 = 0;
		}
		else
		{
			endianDiff1 = 3;
			endianDiff2 = 1;
		}
		if (byteBlock == null)
		{
			byteBlock = new byte[4];
		}
		idx = 1;
	}

	private static bool SaveBytes(string key, byte[] bytes)
	{
		try
		{
			PlayerPrefs.SetString(key, Convert.ToBase64String(bytes));
		}
		catch
		{
			return false;
		}
		return true;
	}

	private static void ConvertFloatToBytes(float f, byte[] bytes)
	{
		byteBlock = BitConverter.GetBytes(f);
		ConvertTo4Bytes(bytes);
	}

	private static float ConvertBytesToFloat(byte[] bytes)
	{
		ConvertFrom4Bytes(bytes);
		return BitConverter.ToSingle(byteBlock, 0);
	}

	private static void ConvertInt32ToBytes(int i, byte[] bytes)
	{
		byteBlock = BitConverter.GetBytes(i);
		ConvertTo4Bytes(bytes);
	}

	private static int ConvertBytesToInt32(byte[] bytes)
	{
		ConvertFrom4Bytes(bytes);
		return BitConverter.ToInt32(byteBlock, 0);
	}

	private static void ConvertTo4Bytes(byte[] bytes)
	{
		bytes[idx] = byteBlock[endianDiff1];
		bytes[idx + 1] = byteBlock[1 + endianDiff2];
		bytes[idx + 2] = byteBlock[2 - endianDiff2];
		bytes[idx + 3] = byteBlock[3 - endianDiff1];
		idx += 4;
	}

	private static void ConvertFrom4Bytes(byte[] bytes)
	{
		byteBlock[endianDiff1] = bytes[idx];
		byteBlock[1 + endianDiff2] = bytes[idx + 1];
		byteBlock[2 - endianDiff2] = bytes[idx + 2];
		byteBlock[3 - endianDiff1] = bytes[idx + 3];
		idx += 4;
	}
}
[Serializable]
public class ScriptableResource : ScriptableObject
{
	[ReadOnly]
	[SerializeField]
	private string _resourcePath;

	public string resourcePath => _resourcePath;

	protected virtual bool requiresResourceFolder => true;

	protected virtual void OnValidate()
	{
	}
}
public class SubtitleAsset : ScriptableObject
{
	[Serializable]
	public class StringSubtitleDictionary : SerialisableDictionary<string, VOClipSubtitle>
	{
	}

	[Serializable]
	public class VOClipSubtitle
	{
		[Serializable]
		public class LanguageSentenceDictionary : SerialisableDictionary<Localisation.Language, LocalisedData>
		{
		}

		[Serializable]
		public class Sentence
		{
			public string text;

			public float length;

			public float conflictedLength = -1f;
		}

		[Serializable]
		public class LocalisedData
		{
			public Localisation.Language language;

			public Sentence[] sentences;

			public bool hasCustomLengths;

			public bool HasLocalisation { get; private set; }

			public bool isConflicted
			{
				get
				{
					for (int i = 0; i < sentences.Length; i++)
					{
						float length = sentences[i].length;
						float conflictedLength = sentences[i].conflictedLength;
						if (conflictedLength > 0f && Mathf.Abs(conflictedLength - length) > 0.05f)
						{
							return true;
						}
					}
					return false;
				}
			}

			public float totalLength
			{
				get
				{
					if (sentences == null || sentences.Length == 0)
					{
						return 0f;
					}
					float num = 0f;
					for (int i = 0; i < sentences.Length; i++)
					{
						num += sentences[i].length;
					}
					return num;
				}
			}

			public LocalisedData(Localisation.Language language, Sentence[] sentences, bool hasLocalisation)
			{
				this.language = language;
				this.sentences = sentences;
				HasLocalisation = hasLocalisation;
				hasCustomLengths = false;
			}

			public bool SentencesEqual(LocalisedData obj)
			{
				if (obj.sentences.Length != sentences.Length)
				{
					return false;
				}
				for (int i = 0; i < sentences.Length; i++)
				{
					if (!StringsEqual(sentences[i].text, obj.sentences[i].text))
					{
						return false;
					}
				}
				return true;
			}

			private bool StringsEqual(string s1, string s2)
			{
				if (s1.Length != s2.Length)
				{
					return false;
				}
				for (int i = 0; i < s1.Length; i++)
				{
					if (s1[i] != s2[i])
					{
						return false;
					}
				}
				return true;
			}

			public void ResolveConflict(bool keepCustomLengths)
			{
				for (int i = 0; i < sentences.Length; i++)
				{
					if (!keepCustomLengths)
					{
						sentences[i].length = sentences[i].conflictedLength;
					}
					sentences[i].conflictedLength = -1f;
				}
			}
		}

		public FMODEventAsset fmodEvent;

		public VONameType speaker;

		[SerializeField]
		private LanguageSentenceDictionary languageToSentencesDict = new LanguageSentenceDictionary();

		public bool HasAnyConflicts
		{
			get
			{
				for (int i = 0; i < 6; i++)
				{
					Localisation.Language key = (Localisation.Language)i;
					if (languageToSentencesDict.dict.TryGetValue(key, out var value) && value.isConflicted)
					{
						return true;
					}
				}
				return false;
			}
		}

		public LocalisedData GetLocalisedData(Localisation.Language language)
		{
			if (!languageToSentencesDict.dict.ContainsKey(language))
			{
				UnityEngine.Debug.Log("Language " + language.ToString() + " not found!");
				return null;
			}
			return languageToSentencesDict.dict[language];
		}

		public void OverwriteLocalisedData(Localisation.Language language, LocalisedData data)
		{
			languageToSentencesDict.dict[language] = data;
		}

		public static VOClipSubtitle CreateClip(FMODEventAsset asset, VONameType nameOverride = VONameType.NONE)
		{
			VOClipSubtitle vOClipSubtitle = new VOClipSubtitle();
			vOClipSubtitle.fmodEvent = asset;
			vOClipSubtitle.speaker = nameOverride;
			if (vOClipSubtitle.speaker == VONameType.NONE)
			{
				for (int i = 0; i < 13; i++)
				{
					if (asset.name.Contains(((VONameType)i).ToString().ToLower()))
					{
						vOClipSubtitle.speaker = (VONameType)i;
						break;
					}
				}
			}
			Localisation.RefreshDataBase();
			vOClipSubtitle.RebuildSentences();
			return vOClipSubtitle;
		}

		public void RebuildSentences(bool keepLengths = false, Localisation.Language specificLanguage = Localisation.Language.LANGUAGE_MAX)
		{
			float num = Mathf.Max(FACMisc.GetDuration(fmodEvent), 1f);
			if (Localisation.IsKeyValid(fmodEvent.name))
			{
				for (int i = 0; i < 6; i++)
				{
					Localisation.Language language = (Localisation.Language)i;
					if (specificLanguage != Localisation.Language.LANGUAGE_MAX && language != specificLanguage)
					{
						continue;
					}
					string text = Localisation.RetrieveSpecific(fmodEvent.name, language);
					bool flag = !string.IsNullOrEmpty(text) && text != "[Missing Text]";
					Sentence[] array = new Sentence[1]
					{
						new Sentence
						{
							text = fmodEvent.name,
							length = num
						}
					};
					if (flag)
					{
						array = GenerateDefaultSentences(text, num, speaker, language);
					}
					LocalisedData value = new LocalisedData(language, array, flag);
					if (keepLengths && languageToSentencesDict.dict.ContainsKey(language) && languageToSentencesDict.dict[language].sentences.Length == array.Length)
					{
						LocalisedData localisedData = languageToSentencesDict.dict[language];
						for (int j = 0; j < array.Length; j++)
						{
							float length = localisedData.sentences[j].length;
							localisedData.sentences[j] = array[j];
							localisedData.sentences[j].length = length;
						}
					}
					else if (specificLanguage != Localisation.Language.LANGUAGE_MAX && languageToSentencesDict.dict.ContainsKey(language))
					{
						languageToSentencesDict.dict[language] = value;
					}
					else
					{
						languageToSentencesDict.dict.Add(language, value);
					}
				}
			}
			else
			{
				for (int k = 0; k < 6; k++)
				{
					Sentence[] sentences = new Sentence[1]
					{
						new Sentence
						{
							text = fmodEvent.name,
							length = num
						}
					};
					Localisation.Language language2 = (Localisation.Language)k;
					LocalisedData value2 = new LocalisedData(language2, sentences, hasLocalisation: false);
					languageToSentencesDict.dict.Add(language2, value2);
				}
			}
		}

		public void ResolveConflicts(bool keepCustomLengths)
		{
			for (int i = 0; i < 6; i++)
			{
				Localisation.Language key = (Localisation.Language)i;
				LocalisedData localisedData = languageToSentencesDict.dict[key];
				if (localisedData.isConflicted)
				{
					localisedData.ResolveConflict(keepCustomLengths);
				}
			}
		}

		private static bool IsLineTerminated(string text, int index, bool includeSpaces = false)
		{
			char c = text[index];
			switch (c)
			{
			case '!':
			case ';':
			case '?':
			case '':
				return true;
			case '.':
				if (index >= text.Length - 1)
				{
					return true;
				}
				if (text[index + 1] == '.')
				{
					return false;
				}
				return true;
			default:
				if (includeSpaces && c == '\u3000')
				{
					return true;
				}
				return index == text.Length - 1;
			}
		}

		public static Sentence[] GenerateDefaultSentences(string text, float clipLength, VONameType speaker, Localisation.Language language)
		{
			List<Sentence> list = new List<Sentence>();
			string text2 = "";
			if (Localisation.IsKeyValid("SUBTITLE_NAME_" + speaker))
			{
				text2 = Localisation.RetrieveSpecific("SUBTITLE_NAME_" + speaker, language) + ((language == Localisation.Language.FRENCH) ? " : " : ": ");
			}
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			for (int i = 0; i < text.Length; i++)
			{
				if (!IsLineTerminated(text, i, language == Localisation.Language.JAPANESE))
				{
					continue;
				}
				int num4 = i + 1;
				if (num4 < text.Length)
				{
					char c = text[num4];
					if (c == '\'' || c == '' || c == '' || c == '"')
					{
						num4++;
						i++;
					}
				}
				num2 = num;
				num = num4;
				Sentence sentence = new Sentence();
				int num5 = num - num2;
				sentence.text = text.Substring(num2, num5);
				float num6 = (float)num5 / (float)text.Length;
				sentence.length = clipLength * num6;
				list.Add(sentence);
				num3++;
			}
			if (list.Count > 0)
			{
				list[0].text = text2 + list[0].text;
			}
			return list.ToArray();
		}
	}

	public const string SUBTITLE_ASSET_PATH = "Assets/_GameAssets/CustomAssets/SubtitleTimingsMasterAsset.asset";

	public const string FMOD_EVENT_PATH_VO = "Assets/FMOD/Assets/Event/vo";

	public const float MIN_SUBTITLE_LENGTH = 1f;

	public StringSubtitleDictionary keyToClipDict = new StringSubtitleDictionary();

	public VOClipSubtitle GetVOClip(string key)
	{
		if (!Contains(key))
		{
			return null;
		}
		return keyToClipDict.dict[key];
	}

	public bool Contains(string key)
	{
		return keyToClipDict.dict.ContainsKey(key);
	}
}
public enum VONameType : byte
{
	NONE,
	LORNA,
	MANSFIELD,
	JARRED,
	OFFICER,
	TRAINEE,
	RECORDING,
	UNKNOWN,
	DJ,
	MISSCLARKE,
	ZOE,
	MOLLY,
	OFFICERLORNA,
	NAMETYPE_MAX
}
public static class SVN
{
	public struct Info
	{
		private static readonly char[] lineSplit = new char[1] { ':' };

		public readonly string path;

		public readonly string workingCopyRootPath;

		public readonly string url;

		public readonly string relativeUrl;

		public readonly string repositoryRoot;

		public readonly string repositoryRootUUID;

		public readonly int revision;

		public readonly string nodeKind;

		public readonly string schedule;

		public readonly string lastChangedAuthor;

		public readonly int lastChangedRevision;

		public readonly string lastChangedDate;

		public Info(string svnInfoOutput)
		{
			path = "";
			workingCopyRootPath = "";
			url = "";
			relativeUrl = "";
			repositoryRoot = "";
			repositoryRootUUID = "";
			revision = -1;
			nodeKind = "";
			schedule = "";
			lastChangedAuthor = "";
			lastChangedRevision = -1;
			lastChangedDate = "";
			string[] array = svnInfoOutput.Split('\n');
			for (int i = 0; i < array.Length; i++)
			{
				string[] array2 = array[i].Split(lineSplit, 2);
				if (array2.Length == 2)
				{
					array2[0] = array2[0].Trim();
					array2[1] = array2[1].Trim();
					switch (array2[0])
					{
					case "Path":
						path = array2[1];
						break;
					case "Working Copy Root Path":
						workingCopyRootPath = array2[1];
						break;
					case "URL":
						url = array2[1];
						break;
					case "Relative URL":
						relativeUrl = array2[1];
						break;
					case "Repository Root":
						repositoryRoot = array2[1];
						break;
					case "Repository UUID":
						repositoryRootUUID = array2[1];
						break;
					case "Revision":
						revision = int.Parse(array2[1]);
						break;
					case "Node Kind":
						nodeKind = array2[1];
						break;
					case "Schedule":
						schedule = array2[1];
						break;
					case "Last Changed Author":
						lastChangedAuthor = array2[1];
						break;
					case "Last Changed Rev":
						lastChangedRevision = int.Parse(array2[1]);
						break;
					case "Last Changed Date":
						lastChangedDate = array2[1];
						break;
					}
				}
			}
		}
	}

	public static readonly bool supported;

	static SVN()
	{
		supported = ShellCommand.Exists("svn");
	}

	public static string RunSVNCommand(string command, string args, int timeoutMS = 500)
	{
		string result = "";
		try
		{
			Process process = new Process
			{
				StartInfo = new ProcessStartInfo("svn", $"{command} {args}")
				{
					RedirectStandardOutput = true,
					RedirectStandardError = true,
					UseShellExecute = false,
					CreateNoWindow = true
				}
			};
			process.Start();
			if (process.WaitForExit(timeoutMS))
			{
				result = process.StandardOutput.ReadToEnd();
			}
			else
			{
				process.Kill();
			}
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError($"Exception when running command \"{command}\": {ex.Message}");
		}
		return result;
	}

	public static Info GetInfo(string path)
	{
		return new Info(RunSVNCommand("info", $"\"{path}\""));
	}

	public static bool NeedsLock(string path)
	{
		string text = RunSVNCommand("propget", $"svn:needs-lock \"{path}\"");
		if (text != null)
		{
			return text.Length > 0;
		}
		return false;
	}

	public static string Lock(params string[] paths)
	{
		return RunSVNCommand("lock", string.Join(" ", paths.Select((string path) => $"\"{path}\"").ToArray()));
	}

	public static string Unlock(params string[] paths)
	{
		return RunSVNCommand("unlock", string.Join(" ", paths.Select((string path) => $"\"{path}\"").ToArray()));
	}

	public static string Delete(params string[] paths)
	{
		return RunSVNCommand("delete", string.Join(" ", paths.Select((string path) => $"\"{path}\"").ToArray()));
	}

	public static string Move(string src, string dst)
	{
		return RunSVNCommand("move", src + " " + dst);
	}

	public static string Rename(string src, string dst)
	{
		return RunSVNCommand("rename", src + " " + dst);
	}

	public static string Copy(string src, string dst)
	{
		return RunSVNCommand("copy", src + " " + dst);
	}

	public static Dictionary<string, string> SVNInfo()
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		string[] array = ShellCommand.ExecuteSyncNoException("svn", "info \"" + UnityEngine.Application.dataPath + "\\..\"").Split('\n');
		for (int i = 0; i < array.Length; i++)
		{
			string[] array2 = array[i].Split(new char[1] { ':' }, 2);
			if (array2.Length == 2)
			{
				dictionary.Add(array2[0].Trim(), array2[1].Trim());
			}
		}
		return dictionary;
	}
}
public static class TortoiseSVN
{
	public static readonly bool supported;

	static TortoiseSVN()
	{
		supported = ShellCommand.Exists("tortoiseproc");
	}

	public static void Lock(params string[] paths)
	{
		ShellCommand.ExecuteSync("tortoiseproc", $"/command:lock /path:\"{ToPathArgumentValue(paths)}\"");
	}

	public static void Unlock(params string[] paths)
	{
		ShellCommand.ExecuteSync("tortoiseproc", $"/command:unlock /path:\"{ToPathArgumentValue(paths)}\"");
	}

	public static void Update(params string[] paths)
	{
		ShellCommand.ExecuteASync("tortoiseproc", $"/command:update /path:\"{ToPathArgumentValue(paths)}\"");
	}

	public static void Log(params string[] paths)
	{
		ShellCommand.ExecuteASync("tortoiseproc", $"/command:log /path:\"{ToPathArgumentValue(paths)}\"");
	}

	public static void CheckForModifications(params string[] paths)
	{
		ShellCommand.ExecuteASync("tortoiseproc", $"/command:diff /path:\"{ToPathArgumentValue(paths)}\"");
	}

	public static void Cleanup(params string[] paths)
	{
		ShellCommand.ExecuteASync("tortoiseproc", $"/command:cleanup /path:\"{ToPathArgumentValue(paths)}\"");
	}

	public static void Revert(params string[] paths)
	{
		ShellCommand.ExecuteASync("tortoiseproc", $"/command:revert /path:\"{ToPathArgumentValue(paths)}\"");
	}

	public static void Commit(params string[] paths)
	{
		ShellCommand.ExecuteASync("tortoiseproc", $"/command:commit /path:\"{ToPathArgumentValue(paths)}\"");
	}

	private static string ToPathArgumentValue(params string[] paths)
	{
		return string.Join("*", paths);
	}
}
public class ValidateGameObjectActive : MonoBehaviour
{
	public bool shouldBeActive;
}
[PreBuildRemoveComponent]
public class ValidationIgnore : MonoBehaviour
{
}
public class AmbiantIdleAnimation_StartIdleKubrick : KubrickAnimEventBase
{
	private delegate void InvokeDelegate(AmbiantIdleAnimation target);

	private delegate float AcquireDurationDelegate();

	private delegate string GetDisplayNameDelegate();

	private delegate void PreloadDelegate();

	private delegate void UnloadDelegate();

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	private PreloadDelegate preload;

	private UnloadDelegate unload;

	private Type[] _ParameterTypes = new Type[0];

	public override Type DeclaringType => typeof(AmbiantIdleAnimation);

	public override Type[] ParameterTypes => _ParameterTypes;

	public override string MethodName => "StartIdleKubrick";

	protected override void InitialiseDelegates()
	{
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, invokeMI);
		if (durationMI != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), durationMI);
		}
		if (displayNameMI != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), displayNameMI);
		}
		if (preloadMI != null)
		{
			preload = (PreloadDelegate)Delegate.CreateDelegate(typeof(PreloadDelegate), preloadMI);
		}
		if (unloadMI != null)
		{
			unload = (UnloadDelegate)Delegate.CreateDelegate(typeof(UnloadDelegate), unloadMI);
		}
	}

	public override void Invoke(object target)
	{
		base.Invoke(target);
		try
		{
			invoke((AmbiantIdleAnimation)target);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void AcquireDuration()
	{
		Initialise();
		if (acquireDuration == null)
		{
			return;
		}
		try
		{
			_duration = acquireDuration();
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override string GetDisplayName()
	{
		Initialise();
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		try
		{
			return getDisplayName();
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
	}

	public override void Preload()
	{
		Initialise();
		if (preload == null)
		{
			return;
		}
		try
		{
			preload();
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void Unload()
	{
		Initialise();
		if (unload == null)
		{
			return;
		}
		try
		{
			unload();
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}
}
public class AmbiantIdleAnimation_StopIdleKubrick : KubrickAnimEventBase
{
	private delegate void InvokeDelegate(AmbiantIdleAnimation target);

	private delegate float AcquireDurationDelegate();

	private delegate string GetDisplayNameDelegate();

	private delegate void PreloadDelegate();

	private delegate void UnloadDelegate();

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	private PreloadDelegate preload;

	private UnloadDelegate unload;

	private Type[] _ParameterTypes = new Type[0];

	public override Type DeclaringType => typeof(AmbiantIdleAnimation);

	public override Type[] ParameterTypes => _ParameterTypes;

	public override string MethodName => "StopIdleKubrick";

	protected override void InitialiseDelegates()
	{
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, invokeMI);
		if (durationMI != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), durationMI);
		}
		if (displayNameMI != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), displayNameMI);
		}
		if (preloadMI != null)
		{
			preload = (PreloadDelegate)Delegate.CreateDelegate(typeof(PreloadDelegate), preloadMI);
		}
		if (unloadMI != null)
		{
			unload = (UnloadDelegate)Delegate.CreateDelegate(typeof(UnloadDelegate), unloadMI);
		}
	}

	public override void Invoke(object target)
	{
		base.Invoke(target);
		try
		{
			invoke((AmbiantIdleAnimation)target);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void AcquireDuration()
	{
		Initialise();
		if (acquireDuration == null)
		{
			return;
		}
		try
		{
			_duration = acquireDuration();
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override string GetDisplayName()
	{
		Initialise();
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		try
		{
			return getDisplayName();
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
	}

	public override void Preload()
	{
		Initialise();
		if (preload == null)
		{
			return;
		}
		try
		{
			preload();
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void Unload()
	{
		Initialise();
		if (unload == null)
		{
			return;
		}
		try
		{
			unload();
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}
}
public class AnimationSFX_PlaySFX : KubrickAnimEventBase
{
	private delegate void InvokeDelegate(AnimationSFX target, FMODEventAsset _sfx, string _xFormName, bool _track);

	private delegate float AcquireDurationDelegate(FMODEventAsset _sfx, string _xFormName, bool _track);

	private delegate string GetDisplayNameDelegate(FMODEventAsset _sfx, string _xFormName, bool _track);

	private delegate void PreloadDelegate(FMODEventAsset _sfx, string _xFormName, bool _track);

	private delegate void UnloadDelegate(FMODEventAsset _sfx, string _xFormName, bool _track);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	private PreloadDelegate preload;

	private UnloadDelegate unload;

	public FMODEventAsset _sfx;

	public string _xFormName;

	public bool _track;

	private Type[] _ParameterTypes = new Type[3]
	{
		typeof(FMODEventAsset),
		typeof(string),
		typeof(bool)
	};

	public override Type DeclaringType => typeof(AnimationSFX);

	public override Type[] ParameterTypes => _ParameterTypes;

	public override string MethodName => "PlaySFX";

	protected override void InitialiseDelegates()
	{
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, invokeMI);
		if (durationMI != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), durationMI);
		}
		if (displayNameMI != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), displayNameMI);
		}
		if (preloadMI != null)
		{
			preload = (PreloadDelegate)Delegate.CreateDelegate(typeof(PreloadDelegate), preloadMI);
		}
		if (unloadMI != null)
		{
			unload = (UnloadDelegate)Delegate.CreateDelegate(typeof(UnloadDelegate), unloadMI);
		}
	}

	public override void Invoke(object target)
	{
		base.Invoke(target);
		try
		{
			invoke((AnimationSFX)target, _sfx, _xFormName, _track);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void AcquireDuration()
	{
		Initialise();
		if (acquireDuration == null)
		{
			return;
		}
		try
		{
			_duration = acquireDuration(_sfx, _xFormName, _track);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override string GetDisplayName()
	{
		Initialise();
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		try
		{
			return getDisplayName(_sfx, _xFormName, _track);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
	}

	public override void Preload()
	{
		Initialise();
		if (preload == null)
		{
			return;
		}
		try
		{
			preload(_sfx, _xFormName, _track);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void Unload()
	{
		Initialise();
		if (unload == null)
		{
			return;
		}
		try
		{
			unload(_sfx, _xFormName, _track);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}
}
public class CharacterLookAt_UpdateLookAtWeights : KubrickAnimEventBase
{
	private delegate void InvokeDelegate(CharacterLookAt target, Vector3 _neckWeight, Vector3 _headWeight, Vector3 _eyeWeight, float _animationTime);

	private delegate float AcquireDurationDelegate(Vector3 _neckWeight, Vector3 _headWeight, Vector3 _eyeWeight, float _animationTime);

	private delegate string GetDisplayNameDelegate(Vector3 _neckWeight, Vector3 _headWeight, Vector3 _eyeWeight, float _animationTime);

	private delegate void PreloadDelegate(Vector3 _neckWeight, Vector3 _headWeight, Vector3 _eyeWeight, float _animationTime);

	private delegate void UnloadDelegate(Vector3 _neckWeight, Vector3 _headWeight, Vector3 _eyeWeight, float _animationTime);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	private PreloadDelegate preload;

	private UnloadDelegate unload;

	public Vector3 _neckWeight;

	public Vector3 _headWeight;

	public Vector3 _eyeWeight;

	public float _animationTime;

	private Type[] _ParameterTypes = new Type[4]
	{
		typeof(Vector3),
		typeof(Vector3),
		typeof(Vector3),
		typeof(float)
	};

	public override Type DeclaringType => typeof(CharacterLookAt);

	public override Type[] ParameterTypes => _ParameterTypes;

	public override string MethodName => "UpdateLookAtWeights";

	protected override void InitialiseDelegates()
	{
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, invokeMI);
		if (durationMI != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), durationMI);
		}
		if (displayNameMI != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), displayNameMI);
		}
		if (preloadMI != null)
		{
			preload = (PreloadDelegate)Delegate.CreateDelegate(typeof(PreloadDelegate), preloadMI);
		}
		if (unloadMI != null)
		{
			unload = (UnloadDelegate)Delegate.CreateDelegate(typeof(UnloadDelegate), unloadMI);
		}
	}

	public override void Invoke(object target)
	{
		base.Invoke(target);
		try
		{
			invoke((CharacterLookAt)target, _neckWeight, _headWeight, _eyeWeight, _animationTime);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void AcquireDuration()
	{
		Initialise();
		if (acquireDuration == null)
		{
			return;
		}
		try
		{
			_duration = acquireDuration(_neckWeight, _headWeight, _eyeWeight, _animationTime);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override string GetDisplayName()
	{
		Initialise();
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		try
		{
			return getDisplayName(_neckWeight, _headWeight, _eyeWeight, _animationTime);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
	}

	public override void Preload()
	{
		Initialise();
		if (preload == null)
		{
			return;
		}
		try
		{
			preload(_neckWeight, _headWeight, _eyeWeight, _animationTime);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void Unload()
	{
		Initialise();
		if (unload == null)
		{
			return;
		}
		try
		{
			unload(_neckWeight, _headWeight, _eyeWeight, _animationTime);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}
}
public class CharacterVoice_PlayVoiceClip : KubrickAnimEventBase
{
	private delegate void InvokeDelegate(CharacterVoice target, FMODEventAsset _voiceClip, string _xFormPathOverride, bool _stopPrevious, bool _isSFX);

	private delegate float AcquireDurationDelegate(FMODEventAsset _voiceClip, string _xFormPathOverride, bool _stopPrevious, bool _isSFX);

	private delegate string GetDisplayNameDelegate(FMODEventAsset _voiceClip, string _xFormPathOverride, bool _stopPrevious, bool _isSFX);

	private delegate void PreloadDelegate(FMODEventAsset _voiceClip, string _xFormPathOverride, bool _stopPrevious, bool _isSFX);

	private delegate void UnloadDelegate(FMODEventAsset _voiceClip, string _xFormPathOverride, bool _stopPrevious, bool _isSFX);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	private PreloadDelegate preload;

	private UnloadDelegate unload;

	public FMODEventAsset _voiceClip;

	public string _xFormPathOverride;

	public bool _stopPrevious;

	public bool _isSFX;

	private Type[] _ParameterTypes = new Type[4]
	{
		typeof(FMODEventAsset),
		typeof(string),
		typeof(bool),
		typeof(bool)
	};

	public override Type DeclaringType => typeof(CharacterVoice);

	public override Type[] ParameterTypes => _ParameterTypes;

	public override string MethodName => "PlayVoiceClip";

	protected override void InitialiseDelegates()
	{
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, invokeMI);
		if (durationMI != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), durationMI);
		}
		if (displayNameMI != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), displayNameMI);
		}
		if (preloadMI != null)
		{
			preload = (PreloadDelegate)Delegate.CreateDelegate(typeof(PreloadDelegate), preloadMI);
		}
		if (unloadMI != null)
		{
			unload = (UnloadDelegate)Delegate.CreateDelegate(typeof(UnloadDelegate), unloadMI);
		}
	}

	public override void Invoke(object target)
	{
		base.Invoke(target);
		try
		{
			invoke((CharacterVoice)target, _voiceClip, _xFormPathOverride, _stopPrevious, _isSFX);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void AcquireDuration()
	{
		Initialise();
		if (acquireDuration == null)
		{
			return;
		}
		try
		{
			_duration = acquireDuration(_voiceClip, _xFormPathOverride, _stopPrevious, _isSFX);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override string GetDisplayName()
	{
		Initialise();
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		try
		{
			return getDisplayName(_voiceClip, _xFormPathOverride, _stopPrevious, _isSFX);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
	}

	public override void Preload()
	{
		Initialise();
		if (preload == null)
		{
			return;
		}
		try
		{
			preload(_voiceClip, _xFormPathOverride, _stopPrevious, _isSFX);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void Unload()
	{
		Initialise();
		if (unload == null)
		{
			return;
		}
		try
		{
			unload(_voiceClip, _xFormPathOverride, _stopPrevious, _isSFX);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}
}
public class KubrickEventComment_Comment : KubrickAnimEventBase
{
	private delegate void InvokeDelegate(KubrickEventComment target, string _comment);

	private delegate float AcquireDurationDelegate(string _comment);

	private delegate string GetDisplayNameDelegate(string _comment);

	private delegate void PreloadDelegate(string _comment);

	private delegate void UnloadDelegate(string _comment);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	private PreloadDelegate preload;

	private UnloadDelegate unload;

	public string _comment;

	private Type[] _ParameterTypes = new Type[1] { typeof(string) };

	public override Type DeclaringType => typeof(KubrickEventComment);

	public override Type[] ParameterTypes => _ParameterTypes;

	public override string MethodName => "Comment";

	protected override void InitialiseDelegates()
	{
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, invokeMI);
		if (durationMI != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), durationMI);
		}
		if (displayNameMI != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), displayNameMI);
		}
		if (preloadMI != null)
		{
			preload = (PreloadDelegate)Delegate.CreateDelegate(typeof(PreloadDelegate), preloadMI);
		}
		if (unloadMI != null)
		{
			unload = (UnloadDelegate)Delegate.CreateDelegate(typeof(UnloadDelegate), unloadMI);
		}
	}

	public override void Invoke(object target)
	{
		base.Invoke(target);
		try
		{
			invoke((KubrickEventComment)target, _comment);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void AcquireDuration()
	{
		Initialise();
		if (acquireDuration == null)
		{
			return;
		}
		try
		{
			_duration = acquireDuration(_comment);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override string GetDisplayName()
	{
		Initialise();
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		try
		{
			return getDisplayName(_comment);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
	}

	public override void Preload()
	{
		Initialise();
		if (preload == null)
		{
			return;
		}
		try
		{
			preload(_comment);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void Unload()
	{
		Initialise();
		if (unload == null)
		{
			return;
		}
		try
		{
			unload(_comment);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}
}
public class KubrickEventIDObjectSetActive_IDObjectSetActive : KubrickAnimEventBase
{
	private delegate void InvokeDelegate(KubrickEventIDObjectSetActive target, string _customName, string _id, bool _active);

	private delegate float AcquireDurationDelegate(string _customName, string _id, bool _active);

	private delegate string GetDisplayNameDelegate(string _customName, string _id, bool _active);

	private delegate void PreloadDelegate(string _customName, string _id, bool _active);

	private delegate void UnloadDelegate(string _customName, string _id, bool _active);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	private PreloadDelegate preload;

	private UnloadDelegate unload;

	public string _customName;

	public string _id;

	public bool _active;

	private Type[] _ParameterTypes = new Type[3]
	{
		typeof(string),
		typeof(string),
		typeof(bool)
	};

	public override Type DeclaringType => typeof(KubrickEventIDObjectSetActive);

	public override Type[] ParameterTypes => _ParameterTypes;

	public override string MethodName => "IDObjectSetActive";

	protected override void InitialiseDelegates()
	{
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, invokeMI);
		if (durationMI != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), durationMI);
		}
		if (displayNameMI != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), displayNameMI);
		}
		if (preloadMI != null)
		{
			preload = (PreloadDelegate)Delegate.CreateDelegate(typeof(PreloadDelegate), preloadMI);
		}
		if (unloadMI != null)
		{
			unload = (UnloadDelegate)Delegate.CreateDelegate(typeof(UnloadDelegate), unloadMI);
		}
	}

	public override void Invoke(object target)
	{
		base.Invoke(target);
		try
		{
			invoke((KubrickEventIDObjectSetActive)target, _customName, _id, _active);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void AcquireDuration()
	{
		Initialise();
		if (acquireDuration == null)
		{
			return;
		}
		try
		{
			_duration = acquireDuration(_customName, _id, _active);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override string GetDisplayName()
	{
		Initialise();
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		try
		{
			return getDisplayName(_customName, _id, _active);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
	}

	public override void Preload()
	{
		Initialise();
		if (preload == null)
		{
			return;
		}
		try
		{
			preload(_customName, _id, _active);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void Unload()
	{
		Initialise();
		if (unload == null)
		{
			return;
		}
		try
		{
			unload(_customName, _id, _active);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}
}
public class KubrickEventLogTest_TestEventAnim : KubrickAnimEventBase
{
	private delegate void InvokeDelegate(KubrickEventLogTest target, int _value0, bool _value1, float _value2);

	private delegate float AcquireDurationDelegate(int _value0, bool _value1, float _value2);

	private delegate string GetDisplayNameDelegate(int _value0, bool _value1, float _value2);

	private delegate void PreloadDelegate(int _value0, bool _value1, float _value2);

	private delegate void UnloadDelegate(int _value0, bool _value1, float _value2);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	private PreloadDelegate preload;

	private UnloadDelegate unload;

	public int _value0;

	public bool _value1;

	public float _value2;

	private Type[] _ParameterTypes = new Type[3]
	{
		typeof(int),
		typeof(bool),
		typeof(float)
	};

	public override Type DeclaringType => typeof(KubrickEventLogTest);

	public override Type[] ParameterTypes => _ParameterTypes;

	public override string MethodName => "TestEventAnim";

	protected override void InitialiseDelegates()
	{
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, invokeMI);
		if (durationMI != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), durationMI);
		}
		if (displayNameMI != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), displayNameMI);
		}
		if (preloadMI != null)
		{
			preload = (PreloadDelegate)Delegate.CreateDelegate(typeof(PreloadDelegate), preloadMI);
		}
		if (unloadMI != null)
		{
			unload = (UnloadDelegate)Delegate.CreateDelegate(typeof(UnloadDelegate), unloadMI);
		}
	}

	public override void Invoke(object target)
	{
		base.Invoke(target);
		try
		{
			invoke((KubrickEventLogTest)target, _value0, _value1, _value2);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void AcquireDuration()
	{
		Initialise();
		if (acquireDuration == null)
		{
			return;
		}
		try
		{
			_duration = acquireDuration(_value0, _value1, _value2);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override string GetDisplayName()
	{
		Initialise();
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		try
		{
			return getDisplayName(_value0, _value1, _value2);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
	}

	public override void Preload()
	{
		Initialise();
		if (preload == null)
		{
			return;
		}
		try
		{
			preload(_value0, _value1, _value2);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void Unload()
	{
		Initialise();
		if (unload == null)
		{
			return;
		}
		try
		{
			unload(_value0, _value1, _value2);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}
}
public class KubrickEventPlayAnim_PlayAnim : KubrickAnimEventBase
{
	private delegate void InvokeDelegate(KubrickEventPlayAnim target, AnimationClip _clip);

	private delegate float AcquireDurationDelegate(AnimationClip _clip);

	private delegate string GetDisplayNameDelegate(AnimationClip _clip);

	private delegate void PreloadDelegate(AnimationClip _clip);

	private delegate void UnloadDelegate(AnimationClip _clip);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	private PreloadDelegate preload;

	private UnloadDelegate unload;

	public AnimationClip _clip;

	private Type[] _ParameterTypes = new Type[1] { typeof(AnimationClip) };

	public override Type DeclaringType => typeof(KubrickEventPlayAnim);

	public override Type[] ParameterTypes => _ParameterTypes;

	public override string MethodName => "PlayAnim";

	protected override void InitialiseDelegates()
	{
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, invokeMI);
		if (durationMI != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), durationMI);
		}
		if (displayNameMI != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), displayNameMI);
		}
		if (preloadMI != null)
		{
			preload = (PreloadDelegate)Delegate.CreateDelegate(typeof(PreloadDelegate), preloadMI);
		}
		if (unloadMI != null)
		{
			unload = (UnloadDelegate)Delegate.CreateDelegate(typeof(UnloadDelegate), unloadMI);
		}
	}

	public override void Invoke(object target)
	{
		base.Invoke(target);
		try
		{
			invoke((KubrickEventPlayAnim)target, _clip);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void AcquireDuration()
	{
		Initialise();
		if (acquireDuration == null)
		{
			return;
		}
		try
		{
			_duration = acquireDuration(_clip);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override string GetDisplayName()
	{
		Initialise();
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		try
		{
			return getDisplayName(_clip);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
	}

	public override void Preload()
	{
		Initialise();
		if (preload == null)
		{
			return;
		}
		try
		{
			preload(_clip);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void Unload()
	{
		Initialise();
		if (unload == null)
		{
			return;
		}
		try
		{
			unload(_clip);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}
}
public class KubrickEventPlayParticle_IDObjectSetActive : KubrickAnimEventBase
{
	private delegate void InvokeDelegate(KubrickEventPlayParticle target, string _customName, string _id, bool _active);

	private delegate float AcquireDurationDelegate(string _customName, string _id, bool _active);

	private delegate string GetDisplayNameDelegate(string _customName, string _id, bool _active);

	private delegate void PreloadDelegate(string _customName, string _id, bool _active);

	private delegate void UnloadDelegate(string _customName, string _id, bool _active);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	private PreloadDelegate preload;

	private UnloadDelegate unload;

	public string _customName;

	public string _id;

	public bool _active;

	private Type[] _ParameterTypes = new Type[3]
	{
		typeof(string),
		typeof(string),
		typeof(bool)
	};

	public override Type DeclaringType => typeof(KubrickEventPlayParticle);

	public override Type[] ParameterTypes => _ParameterTypes;

	public override string MethodName => "IDObjectSetActive";

	protected override void InitialiseDelegates()
	{
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, invokeMI);
		if (durationMI != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), durationMI);
		}
		if (displayNameMI != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), displayNameMI);
		}
		if (preloadMI != null)
		{
			preload = (PreloadDelegate)Delegate.CreateDelegate(typeof(PreloadDelegate), preloadMI);
		}
		if (unloadMI != null)
		{
			unload = (UnloadDelegate)Delegate.CreateDelegate(typeof(UnloadDelegate), unloadMI);
		}
	}

	public override void Invoke(object target)
	{
		base.Invoke(target);
		try
		{
			invoke((KubrickEventPlayParticle)target, _customName, _id, _active);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void AcquireDuration()
	{
		Initialise();
		if (acquireDuration == null)
		{
			return;
		}
		try
		{
			_duration = acquireDuration(_customName, _id, _active);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override string GetDisplayName()
	{
		Initialise();
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		try
		{
			return getDisplayName(_customName, _id, _active);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
	}

	public override void Preload()
	{
		Initialise();
		if (preload == null)
		{
			return;
		}
		try
		{
			preload(_customName, _id, _active);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void Unload()
	{
		Initialise();
		if (unload == null)
		{
			return;
		}
		try
		{
			unload(_customName, _id, _active);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}
}
public class KubrickEventRemoveStoryItem_RemoveStoryItem : KubrickAnimEventBase
{
	private delegate void InvokeDelegate(KubrickEventRemoveStoryItem target, InventoryStoryItem _storyItem, float _delay);

	private delegate float AcquireDurationDelegate(InventoryStoryItem _storyItem, float _delay);

	private delegate string GetDisplayNameDelegate(InventoryStoryItem _storyItem, float _delay);

	private delegate void PreloadDelegate(InventoryStoryItem _storyItem, float _delay);

	private delegate void UnloadDelegate(InventoryStoryItem _storyItem, float _delay);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	private PreloadDelegate preload;

	private UnloadDelegate unload;

	public InventoryStoryItem _storyItem;

	public float _delay;

	private Type[] _ParameterTypes = new Type[2]
	{
		typeof(InventoryStoryItem),
		typeof(float)
	};

	public override Type DeclaringType => typeof(KubrickEventRemoveStoryItem);

	public override Type[] ParameterTypes => _ParameterTypes;

	public override string MethodName => "RemoveStoryItem";

	protected override void InitialiseDelegates()
	{
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, invokeMI);
		if (durationMI != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), durationMI);
		}
		if (displayNameMI != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), displayNameMI);
		}
		if (preloadMI != null)
		{
			preload = (PreloadDelegate)Delegate.CreateDelegate(typeof(PreloadDelegate), preloadMI);
		}
		if (unloadMI != null)
		{
			unload = (UnloadDelegate)Delegate.CreateDelegate(typeof(UnloadDelegate), unloadMI);
		}
	}

	public override void Invoke(object target)
	{
		base.Invoke(target);
		try
		{
			invoke((KubrickEventRemoveStoryItem)target, _storyItem, _delay);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void AcquireDuration()
	{
		Initialise();
		if (acquireDuration == null)
		{
			return;
		}
		try
		{
			_duration = acquireDuration(_storyItem, _delay);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override string GetDisplayName()
	{
		Initialise();
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		try
		{
			return getDisplayName(_storyItem, _delay);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
	}

	public override void Preload()
	{
		Initialise();
		if (preload == null)
		{
			return;
		}
		try
		{
			preload(_storyItem, _delay);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void Unload()
	{
		Initialise();
		if (unload == null)
		{
			return;
		}
		try
		{
			unload(_storyItem, _delay);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}
}
public class PortalAnimate_LockPortal : KubrickAnimEventBase
{
	private delegate void InvokeDelegate(PortalAnimate target, bool _locked);

	private delegate float AcquireDurationDelegate(bool _locked);

	private delegate string GetDisplayNameDelegate(bool _locked);

	private delegate void PreloadDelegate(bool _locked);

	private delegate void UnloadDelegate(bool _locked);

	private InvokeDelegate invoke;

	private AcquireDurationDelegate acquireDuration;

	private GetDisplayNameDelegate getDisplayName;

	private PreloadDelegate preload;

	private UnloadDelegate unload;

	public bool _locked;

	private Type[] _ParameterTypes = new Type[1] { typeof(bool) };

	public override Type DeclaringType => typeof(PortalAnimate);

	public override Type[] ParameterTypes => _ParameterTypes;

	public override string MethodName => "LockPortal";

	protected override void InitialiseDelegates()
	{
		invoke = (InvokeDelegate)Delegate.CreateDelegate(typeof(InvokeDelegate), null, invokeMI);
		if (durationMI != null)
		{
			acquireDuration = (AcquireDurationDelegate)Delegate.CreateDelegate(typeof(AcquireDurationDelegate), durationMI);
		}
		if (displayNameMI != null)
		{
			getDisplayName = (GetDisplayNameDelegate)Delegate.CreateDelegate(typeof(GetDisplayNameDelegate), displayNameMI);
		}
		if (preloadMI != null)
		{
			preload = (PreloadDelegate)Delegate.CreateDelegate(typeof(PreloadDelegate), preloadMI);
		}
		if (unloadMI != null)
		{
			unload = (UnloadDelegate)Delegate.CreateDelegate(typeof(UnloadDelegate), unloadMI);
		}
	}

	public override void Invoke(object target)
	{
		base.Invoke(target);
		try
		{
			invoke((PortalAnimate)target, _locked);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void AcquireDuration()
	{
		Initialise();
		if (acquireDuration == null)
		{
			return;
		}
		try
		{
			_duration = acquireDuration(_locked);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override string GetDisplayName()
	{
		Initialise();
		if (getDisplayName == null)
		{
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
		try
		{
			return getDisplayName(_locked);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
			return GetType().ToString().RemoveUpToChar('_', includeChar: true);
		}
	}

	public override void Preload()
	{
		Initialise();
		if (preload == null)
		{
			return;
		}
		try
		{
			preload(_locked);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	public override void Unload()
	{
		Initialise();
		if (unload == null)
		{
			return;
		}
		try
		{
			unload(_locked);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}
}
public class BufferedAudioStream
{
	private const bool VerboseLogging = false;

	private AudioSource audio;

	private float[] audioBuffer;

	private int writePos;

	private const float bufferLengthSeconds = 0.25f;

	private const int sampleRate = 48000;

	private const int bufferSize = 12000;

	private const float playbackDelayTimeSeconds = 0.05f;

	private float playbackDelayRemaining;

	private float remainingBufferTime;

	public BufferedAudioStream(AudioSource audio)
	{
		audioBuffer = new float[12000];
		this.audio = audio;
		audio.loop = true;
		audio.clip = AudioClip.Create("", 12000, 1, 48000, stream: false);
		Stop();
	}

	public void Update()
	{
		if (remainingBufferTime > 0f)
		{
			if (!audio.isPlaying && remainingBufferTime > 0.05f)
			{
				playbackDelayRemaining -= Time.deltaTime;
				if (playbackDelayRemaining <= 0f)
				{
					audio.Play();
				}
			}
			if (audio.isPlaying)
			{
				remainingBufferTime -= Time.deltaTime;
				if (remainingBufferTime < 0f)
				{
					remainingBufferTime = 0f;
				}
			}
		}
		if (remainingBufferTime <= 0f)
		{
			if (audio.isPlaying)
			{
				UnityEngine.Debug.Log("Buffer empty, stopping " + DateTime.Now);
				Stop();
			}
			else if (writePos != 0)
			{
				UnityEngine.Debug.LogError("writePos non zero while not playing, how did this happen?");
			}
		}
	}

	private void Stop()
	{
		audio.Stop();
		audio.time = 0f;
		writePos = 0;
		playbackDelayRemaining = 0.05f;
	}

	public void AddData(float[] samples)
	{
		int num = samples.Length;
		if (writePos > audioBuffer.Length)
		{
			throw new Exception();
		}
		do
		{
			int num2 = num;
			int num3 = audioBuffer.Length - writePos;
			if (num2 > num3)
			{
				num2 = num3;
			}
			Array.Copy(samples, 0, audioBuffer, writePos, num2);
			num -= num2;
			writePos += num2;
			if (writePos > audioBuffer.Length)
			{
				throw new Exception();
			}
			if (writePos == audioBuffer.Length)
			{
				writePos = 0;
			}
		}
		while (num > 0);
		remainingBufferTime += (float)samples.Length / 48000f;
		audio.clip.SetData(audioBuffer, 0);
	}
}
public class OVRBoundary
{
	public enum Node
	{
		HandLeft = 3,
		HandRight = 4,
		Head = 9
	}

	public enum BoundaryType
	{
		OuterBoundary = 1,
		PlayArea = 0x100
	}

	public struct BoundaryTestResult
	{
		public bool IsTriggering;

		public float ClosestDistance;

		public Vector3 ClosestPoint;

		public Vector3 ClosestPointNormal;
	}

	public struct BoundaryLookAndFeel
	{
		public Color Color;
	}

	private static int cachedVector3fSize = Marshal.SizeOf(typeof(OVRPlugin.Vector3f));

	private static OVRNativeBuffer cachedGeometryNativeBuffer = new OVRNativeBuffer(0);

	private static float[] cachedGeometryManagedBuffer = new float[0];

	public bool GetConfigured()
	{
		return OVRPlugin.GetBoundaryConfigured();
	}

	public BoundaryTestResult TestNode(Node node, BoundaryType boundaryType)
	{
		OVRPlugin.BoundaryTestResult boundaryTestResult = OVRPlugin.TestBoundaryNode((OVRPlugin.Node)node, (OVRPlugin.BoundaryType)boundaryType);
		BoundaryTestResult result = default(BoundaryTestResult);
		result.IsTriggering = boundaryTestResult.IsTriggering == OVRPlugin.Bool.True;
		result.ClosestDistance = boundaryTestResult.ClosestDistance;
		result.ClosestPoint = boundaryTestResult.ClosestPoint.FromFlippedZVector3f();
		result.ClosestPointNormal = boundaryTestResult.ClosestPointNormal.FromFlippedZVector3f();
		return result;
	}

	public BoundaryTestResult TestPoint(Vector3 point, BoundaryType boundaryType)
	{
		OVRPlugin.BoundaryTestResult boundaryTestResult = OVRPlugin.TestBoundaryPoint(point.ToFlippedZVector3f(), (OVRPlugin.BoundaryType)boundaryType);
		BoundaryTestResult result = default(BoundaryTestResult);
		result.IsTriggering = boundaryTestResult.IsTriggering == OVRPlugin.Bool.True;
		result.ClosestDistance = boundaryTestResult.ClosestDistance;
		result.ClosestPoint = boundaryTestResult.ClosestPoint.FromFlippedZVector3f();
		result.ClosestPointNormal = boundaryTestResult.ClosestPointNormal.FromFlippedZVector3f();
		return result;
	}

	public void SetLookAndFeel(BoundaryLookAndFeel lookAndFeel)
	{
		OVRPlugin.BoundaryLookAndFeel boundaryLookAndFeel = default(OVRPlugin.BoundaryLookAndFeel);
		boundaryLookAndFeel.Color = lookAndFeel.Color.ToColorf();
		OVRPlugin.SetBoundaryLookAndFeel(boundaryLookAndFeel);
	}

	public void ResetLookAndFeel()
	{
		OVRPlugin.ResetBoundaryLookAndFeel();
	}

	public Vector3[] GetGeometry(BoundaryType boundaryType)
	{
		int pointsCount = 0;
		if (OVRPlugin.GetBoundaryGeometry2((OVRPlugin.BoundaryType)boundaryType, IntPtr.Zero, ref pointsCount) && pointsCount > 0)
		{
			int num = pointsCount * cachedVector3fSize;
			if (cachedGeometryNativeBuffer.GetCapacity() < num)
			{
				cachedGeometryNativeBuffer.Reset(num);
			}
			int num2 = pointsCount * 3;
			if (cachedGeometryManagedBuffer.Length < num2)
			{
				cachedGeometryManagedBuffer = new float[num2];
			}
			if (OVRPlugin.GetBoundaryGeometry2((OVRPlugin.BoundaryType)boundaryType, cachedGeometryNativeBuffer.GetPointer(), ref pointsCount))
			{
				Marshal.Copy(cachedGeometryNativeBuffer.GetPointer(), cachedGeometryManagedBuffer, 0, num2);
				Vector3[] array = new Vector3[pointsCount];
				for (int i = 0; i < pointsCount; i++)
				{
					array[i] = new OVRPlugin.Vector3f
					{
						x = cachedGeometryManagedBuffer[3 * i],
						y = cachedGeometryManagedBuffer[3 * i + 1],
						z = cachedGeometryManagedBuffer[3 * i + 2]
					}.FromFlippedZVector3f();
				}
				return array;
			}
		}
		return new Vector3[0];
	}

	public Vector3 GetDimensions(BoundaryType boundaryType)
	{
		return OVRPlugin.GetBoundaryDimensions((OVRPlugin.BoundaryType)boundaryType).FromVector3f();
	}

	public bool GetVisible()
	{
		return OVRPlugin.GetBoundaryVisible();
	}

	public void SetVisible(bool value)
	{
		OVRPlugin.SetBoundaryVisible(value);
	}
}
[ExecuteInEditMode]
public class OVRCameraRig : MonoBehaviour
{
	public bool usePerEyeCameras;

	public bool useFixedUpdateForTracking;

	protected bool _skipUpdate;

	protected readonly string trackingSpaceName = "TrackingSpace";

	protected readonly string trackerAnchorName = "TrackerAnchor";

	protected readonly string leftEyeAnchorName = "LeftEyeAnchor";

	protected readonly string centerEyeAnchorName = "CenterEyeAnchor";

	protected readonly string rightEyeAnchorName = "RightEyeAnchor";

	protected readonly string leftHandAnchorName = "LeftHandAnchor";

	protected readonly string rightHandAnchorName = "RightHandAnchor";

	protected Camera _centerEyeCamera;

	protected Camera _leftEyeCamera;

	protected Camera _rightEyeCamera;

	public Camera leftEyeCamera
	{
		get
		{
			if (!usePerEyeCameras)
			{
				return _centerEyeCamera;
			}
			return _leftEyeCamera;
		}
	}

	public Camera rightEyeCamera
	{
		get
		{
			if (!usePerEyeCameras)
			{
				return _centerEyeCamera;
			}
			return _rightEyeCamera;
		}
	}

	public Transform trackingSpace { get; private set; }

	public Transform leftEyeAnchor { get; private set; }

	public Transform centerEyeAnchor { get; private set; }

	public Transform rightEyeAnchor { get; private set; }

	public Transform leftHandAnchor { get; private set; }

	public Transform rightHandAnchor { get; private set; }

	public Transform trackerAnchor { get; private set; }

	public event Action<OVRCameraRig> UpdatedAnchors;

	protected virtual void Awake()
	{
		_skipUpdate = true;
		EnsureGameObjectIntegrity();
	}

	protected virtual void Start()
	{
		UpdateAnchors();
	}

	protected virtual void FixedUpdate()
	{
		if (useFixedUpdateForTracking)
		{
			UpdateAnchors();
		}
	}

	protected virtual void Update()
	{
		_skipUpdate = false;
		if (!useFixedUpdateForTracking)
		{
			UpdateAnchors();
		}
	}

	protected virtual void UpdateAnchors()
	{
		EnsureGameObjectIntegrity();
		if (UnityEngine.Application.isPlaying)
		{
			if (_skipUpdate)
			{
				centerEyeAnchor.FromOVRPose(OVRPose.identity, isLocal: true);
				leftEyeAnchor.FromOVRPose(OVRPose.identity, isLocal: true);
				rightEyeAnchor.FromOVRPose(OVRPose.identity, isLocal: true);
				return;
			}
			bool monoscopic = OVRManager.instance.monoscopic;
			OVRPose pose = OVRManager.tracker.GetPose();
			trackerAnchor.localRotation = pose.orientation;
			centerEyeAnchor.localRotation = InputTracking.GetLocalRotation(XRNode.CenterEye);
			leftEyeAnchor.localRotation = (monoscopic ? centerEyeAnchor.localRotation : InputTracking.GetLocalRotation(XRNode.LeftEye));
			rightEyeAnchor.localRotation = (monoscopic ? centerEyeAnchor.localRotation : InputTracking.GetLocalRotation(XRNode.RightEye));
			leftHandAnchor.localRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.LTouch);
			rightHandAnchor.localRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTouch);
			trackerAnchor.localPosition = pose.position;
			centerEyeAnchor.localPosition = InputTracking.GetLocalPosition(XRNode.CenterEye);
			leftEyeAnchor.localPosition = (monoscopic ? centerEyeAnchor.localPosition : InputTracking.GetLocalPosition(XRNode.LeftEye));
			rightEyeAnchor.localPosition = (monoscopic ? centerEyeAnchor.localPosition : InputTracking.GetLocalPosition(XRNode.RightEye));
			leftHandAnchor.localPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.LTouch);
			rightHandAnchor.localPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTouch);
			RaiseUpdatedAnchorsEvent();
		}
	}

	protected virtual void RaiseUpdatedAnchorsEvent()
	{
		if (this.UpdatedAnchors != null)
		{
			this.UpdatedAnchors(this);
		}
	}

	public virtual void EnsureGameObjectIntegrity()
	{
		bool flag = OVRManager.instance != null && OVRManager.instance.monoscopic;
		if (trackingSpace == null)
		{
			trackingSpace = ConfigureAnchor(null, trackingSpaceName);
		}
		if (leftEyeAnchor == null)
		{
			leftEyeAnchor = ConfigureAnchor(trackingSpace, leftEyeAnchorName);
		}
		if (centerEyeAnchor == null)
		{
			centerEyeAnchor = ConfigureAnchor(trackingSpace, centerEyeAnchorName);
		}
		if (rightEyeAnchor == null)
		{
			rightEyeAnchor = ConfigureAnchor(trackingSpace, rightEyeAnchorName);
		}
		if (leftHandAnchor == null)
		{
			leftHandAnchor = ConfigureAnchor(trackingSpace, leftHandAnchorName);
		}
		if (rightHandAnchor == null)
		{
			rightHandAnchor = ConfigureAnchor(trackingSpace, rightHandAnchorName);
		}
		if (trackerAnchor == null)
		{
			trackerAnchor = ConfigureAnchor(trackingSpace, trackerAnchorName);
		}
		if (_centerEyeCamera == null || _leftEyeCamera == null || _rightEyeCamera == null)
		{
			_centerEyeCamera = centerEyeAnchor.GetComponent<Camera>();
			_leftEyeCamera = leftEyeAnchor.GetComponent<Camera>();
			_rightEyeCamera = rightEyeAnchor.GetComponent<Camera>();
			if (_centerEyeCamera == null)
			{
				_centerEyeCamera = centerEyeAnchor.gameObject.AddComponent<Camera>();
				_centerEyeCamera.tag = "MainCamera";
			}
			if (_leftEyeCamera == null)
			{
				_leftEyeCamera = leftEyeAnchor.gameObject.AddComponent<Camera>();
				_leftEyeCamera.tag = "MainCamera";
			}
			if (_rightEyeCamera == null)
			{
				_rightEyeCamera = rightEyeAnchor.gameObject.AddComponent<Camera>();
				_rightEyeCamera.tag = "MainCamera";
			}
			_centerEyeCamera.stereoTargetEye = StereoTargetEyeMask.Both;
			_leftEyeCamera.stereoTargetEye = StereoTargetEyeMask.Left;
			_rightEyeCamera.stereoTargetEye = StereoTargetEyeMask.Right;
		}
		if (flag && !OVRPlugin.EyeTextureArrayEnabled)
		{
			if (_centerEyeCamera.stereoTargetEye != StereoTargetEyeMask.Left)
			{
				_centerEyeCamera.stereoTargetEye = StereoTargetEyeMask.Left;
			}
		}
		else if (_centerEyeCamera.stereoTargetEye != StereoTargetEyeMask.Both)
		{
			_centerEyeCamera.stereoTargetEye = StereoTargetEyeMask.Both;
		}
		if (_centerEyeCamera.enabled == usePerEyeCameras || _leftEyeCamera.enabled == !usePerEyeCameras || _rightEyeCamera.enabled == (!usePerEyeCameras || (flag && !OVRPlugin.EyeTextureArrayEnabled)))
		{
			_skipUpdate = true;
		}
		_centerEyeCamera.enabled = !usePerEyeCameras;
		_leftEyeCamera.enabled = usePerEyeCameras;
		_rightEyeCamera.enabled = usePerEyeCameras && (!flag || OVRPlugin.EyeTextureArrayEnabled);
	}

	protected virtual Transform ConfigureAnchor(Transform root, string name)
	{
		Transform transform = ((root != null) ? base.transform.Find(root.name + "/" + name) : null);
		if (transform == null)
		{
			transform = base.transform.Find(name);
		}
		if (transform == null)
		{
			transform = new GameObject(name).transform;
		}
		transform.name = name;
		transform.parent = ((root != null) ? root : base.transform);
		transform.localScale = Vector3.one;
		transform.localPosition = Vector3.zero;
		transform.localRotation = Quaternion.identity;
		return transform;
	}

	public virtual Matrix4x4 ComputeTrackReferenceMatrix()
	{
		if (centerEyeAnchor == null)
		{
			UnityEngine.Debug.LogError("centerEyeAnchor is required");
			return Matrix4x4.identity;
		}
		OVRPose oVRPose = default(OVRPose);
		oVRPose.position = InputTracking.GetLocalPosition(XRNode.Head);
		oVRPose.orientation = InputTracking.GetLocalRotation(XRNode.Head);
		OVRPose oVRPose2 = oVRPose.Inverse();
		Matrix4x4 matrix4x = Matrix4x4.TRS(oVRPose2.position, oVRPose2.orientation, Vector3.one);
		return centerEyeAnchor.localToWorldMatrix * matrix4x;
	}
}
public static class OVRExtensions
{
	public static OVRPose ToTrackingSpacePose(this Transform transform, Camera camera)
	{
		OVRPose oVRPose = default(OVRPose);
		oVRPose.position = InputTracking.GetLocalPosition(XRNode.Head);
		oVRPose.orientation = InputTracking.GetLocalRotation(XRNode.Head);
		return oVRPose * transform.ToHeadSpacePose(camera);
	}

	public static OVRPose ToWorldSpacePose(OVRPose trackingSpacePose)
	{
		OVRPose oVRPose = default(OVRPose);
		oVRPose.position = InputTracking.GetLocalPosition(XRNode.Head);
		oVRPose.orientation = InputTracking.GetLocalRotation(XRNode.Head);
		OVRPose oVRPose2 = oVRPose.Inverse() * trackingSpacePose;
		return Camera.main.transform.ToOVRPose() * oVRPose2;
	}

	public static OVRPose ToHeadSpacePose(this Transform transform, Camera camera)
	{
		return camera.transform.ToOVRPose().Inverse() * transform.ToOVRPose();
	}

	internal static OVRPose ToOVRPose(this Transform t, bool isLocal = false)
	{
		OVRPose result = default(OVRPose);
		result.orientation = (isLocal ? t.localRotation : t.rotation);
		result.position = (isLocal ? t.localPosition : t.position);
		return result;
	}

	internal static void FromOVRPose(this Transform t, OVRPose pose, bool isLocal = false)
	{
		if (isLocal)
		{
			t.localRotation = pose.orientation;
			t.localPosition = pose.position;
		}
		else
		{
			t.rotation = pose.orientation;
			t.position = pose.position;
		}
	}

	internal static OVRPose ToOVRPose(this OVRPlugin.Posef p)
	{
		OVRPose result = default(OVRPose);
		result.position = new Vector3(p.Position.x, p.Position.y, 0f - p.Position.z);
		result.orientation = new Quaternion(0f - p.Orientation.x, 0f - p.Orientation.y, p.Orientation.z, p.Orientation.w);
		return result;
	}

	internal static OVRTracker.Frustum ToFrustum(this OVRPlugin.Frustumf f)
	{
		OVRTracker.Frustum result = default(OVRTracker.Frustum);
		result.nearZ = f.zNear;
		result.farZ = f.zFar;
		result.fov = new Vector2
		{
			x = 57.29578f * f.fovX,
			y = 57.29578f * f.fovY
		};
		return result;
	}

	internal static Color FromColorf(this OVRPlugin.Colorf c)
	{
		Color result = default(Color);
		result.r = c.r;
		result.g = c.g;
		result.b = c.b;
		result.a = c.a;
		return result;
	}

	internal static OVRPlugin.Colorf ToColorf(this Color c)
	{
		OVRPlugin.Colorf result = default(OVRPlugin.Colorf);
		result.r = c.r;
		result.g = c.g;
		result.b = c.b;
		result.a = c.a;
		return result;
	}

	internal static Vector3 FromVector3f(this OVRPlugin.Vector3f v)
	{
		Vector3 result = default(Vector3);
		result.x = v.x;
		result.y = v.y;
		result.z = v.z;
		return result;
	}

	internal static Vector3 FromFlippedZVector3f(this OVRPlugin.Vector3f v)
	{
		Vector3 result = default(Vector3);
		result.x = v.x;
		result.y = v.y;
		result.z = 0f - v.z;
		return result;
	}

	internal static OVRPlugin.Vector3f ToVector3f(this Vector3 v)
	{
		OVRPlugin.Vector3f result = default(OVRPlugin.Vector3f);
		result.x = v.x;
		result.y = v.y;
		result.z = v.z;
		return result;
	}

	internal static OVRPlugin.Vector3f ToFlippedZVector3f(this Vector3 v)
	{
		OVRPlugin.Vector3f result = default(OVRPlugin.Vector3f);
		result.x = v.x;
		result.y = v.y;
		result.z = 0f - v.z;
		return result;
	}

	internal static Quaternion FromQuatf(this OVRPlugin.Quatf q)
	{
		Quaternion result = default(Quaternion);
		result.x = q.x;
		result.y = q.y;
		result.z = q.z;
		result.w = q.w;
		return result;
	}

	internal static Quaternion FromFlippedZQuatf(this OVRPlugin.Quatf q)
	{
		Quaternion result = default(Quaternion);
		result.x = 0f - q.x;
		result.y = 0f - q.y;
		result.z = q.z;
		result.w = q.w;
		return result;
	}

	internal static OVRPlugin.Quatf ToQuatf(this Quaternion q)
	{
		OVRPlugin.Quatf result = default(OVRPlugin.Quatf);
		result.x = q.x;
		result.y = q.y;
		result.z = q.z;
		result.w = q.w;
		return result;
	}

	internal static OVRPlugin.Quatf ToFlippedZQuatf(this Quaternion q)
	{
		OVRPlugin.Quatf result = default(OVRPlugin.Quatf);
		result.x = 0f - q.x;
		result.y = 0f - q.y;
		result.z = q.z;
		result.w = q.w;
		return result;
	}
}
[Serializable]
public struct OVRPose
{
	public Vector3 position;

	public Quaternion orientation;

	public static OVRPose identity
	{
		get
		{
			OVRPose result = default(OVRPose);
			result.position = Vector3.zero;
			result.orientation = Quaternion.identity;
			return result;
		}
	}

	public override bool Equals(object obj)
	{
		if (obj is OVRPose)
		{
			return this == (OVRPose)obj;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return position.GetHashCode() ^ orientation.GetHashCode();
	}

	public static bool operator ==(OVRPose x, OVRPose y)
	{
		if (x.position == y.position)
		{
			return x.orientation == y.orientation;
		}
		return false;
	}

	public static bool operator !=(OVRPose x, OVRPose y)
	{
		return !(x == y);
	}

	public static OVRPose operator *(OVRPose lhs, OVRPose rhs)
	{
		OVRPose result = default(OVRPose);
		result.position = lhs.position + lhs.orientation * rhs.position;
		result.orientation = lhs.orientation * rhs.orientation;
		return result;
	}

	public OVRPose Inverse()
	{
		OVRPose result = default(OVRPose);
		result.orientation = Quaternion.Inverse(orientation);
		result.position = result.orientation * -position;
		return result;
	}

	internal OVRPose flipZ()
	{
		OVRPose result = this;
		result.position.z = 0f - result.position.z;
		result.orientation.z = 0f - result.orientation.z;
		result.orientation.w = 0f - result.orientation.w;
		return result;
	}

	internal OVRPlugin.Posef ToPosef()
	{
		OVRPlugin.Posef result = default(OVRPlugin.Posef);
		result.Position = position.ToVector3f();
		result.Orientation = orientation.ToQuatf();
		return result;
	}
}
public class OVRNativeBuffer : IDisposable
{
	private bool disposed;

	private int m_numBytes;

	private IntPtr m_ptr = IntPtr.Zero;

	public OVRNativeBuffer(int numBytes)
	{
		Reallocate(numBytes);
	}

	~OVRNativeBuffer()
	{
		Dispose(disposing: false);
	}

	public void Reset(int numBytes)
	{
		Reallocate(numBytes);
	}

	public int GetCapacity()
	{
		return m_numBytes;
	}

	public IntPtr GetPointer(int byteOffset = 0)
	{
		if (byteOffset < 0 || byteOffset >= m_numBytes)
		{
			return IntPtr.Zero;
		}
		if (byteOffset != 0)
		{
			return new IntPtr(m_ptr.ToInt64() + byteOffset);
		}
		return m_ptr;
	}

	public void Dispose()
	{
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}

	private void Dispose(bool disposing)
	{
		if (!disposed)
		{
			Release();
			disposed = true;
		}
	}

	private void Reallocate(int numBytes)
	{
		Release();
		if (numBytes > 0)
		{
			m_ptr = Marshal.AllocHGlobal(numBytes);
			m_numBytes = numBytes;
		}
		else
		{
			m_ptr = IntPtr.Zero;
			m_numBytes = 0;
		}
	}

	private void Release()
	{
		if (m_ptr != IntPtr.Zero)
		{
			Marshal.FreeHGlobal(m_ptr);
			m_ptr = IntPtr.Zero;
			m_numBytes = 0;
		}
	}
}
public class OVRDebugHeadController : MonoBehaviour
{
	[SerializeField]
	public bool AllowPitchLook;

	[SerializeField]
	public bool AllowYawLook = true;

	[SerializeField]
	public bool InvertPitch;

	[SerializeField]
	public float GamePad_PitchDegreesPerSec = 90f;

	[SerializeField]
	public float GamePad_YawDegreesPerSec = 90f;

	[SerializeField]
	public bool AllowMovement;

	[SerializeField]
	public float ForwardSpeed = 2f;

	[SerializeField]
	public float StrafeSpeed = 2f;

	protected OVRCameraRig CameraRig;

	private void Awake()
	{
		OVRCameraRig[] componentsInChildren = base.gameObject.GetComponentsInChildren<OVRCameraRig>();
		if (componentsInChildren.Length == 0)
		{
			UnityEngine.Debug.LogWarning("OVRCamParent: No OVRCameraRig attached.");
		}
		else if (componentsInChildren.Length > 1)
		{
			UnityEngine.Debug.LogWarning("OVRCamParent: More then 1 OVRCameraRig attached.");
		}
		else
		{
			CameraRig = componentsInChildren[0];
		}
	}

	private void Start()
	{
	}

	private void Update()
	{
		if (AllowMovement)
		{
			float y = OVRInput.Get(OVRInput.RawAxis2D.LThumbstick).y;
			float x = OVRInput.Get(OVRInput.RawAxis2D.LThumbstick).x;
			Vector3 vector = CameraRig.centerEyeAnchor.rotation * Vector3.forward * y * Time.deltaTime * ForwardSpeed;
			Vector3 vector2 = CameraRig.centerEyeAnchor.rotation * Vector3.right * x * Time.deltaTime * StrafeSpeed;
			base.transform.position += vector + vector2;
		}
		if (XRDevice.isPresent || (!AllowYawLook && !AllowPitchLook))
		{
			return;
		}
		Quaternion quaternion = base.transform.rotation;
		if (AllowYawLook)
		{
			quaternion = Quaternion.AngleAxis(OVRInput.Get(OVRInput.RawAxis2D.RThumbstick).x * Time.deltaTime * GamePad_YawDegreesPerSec, Vector3.up) * quaternion;
		}
		if (AllowPitchLook)
		{
			float num = OVRInput.Get(OVRInput.RawAxis2D.RThumbstick).y;
			if (Mathf.Abs(num) > 0.0001f)
			{
				if (InvertPitch)
				{
					num *= -1f;
				}
				Quaternion quaternion2 = Quaternion.AngleAxis(num * Time.deltaTime * GamePad_PitchDegreesPerSec, Vector3.left);
				quaternion *= quaternion2;
			}
		}
		base.transform.rotation = quaternion;
	}
}
public class OVRDisplay
{
	public struct EyeFov
	{
		public float UpFov;

		public float DownFov;

		public float LeftFov;

		public float RightFov;
	}

	public struct EyeRenderDesc
	{
		public Vector2 resolution;

		public Vector2 fov;

		public EyeFov fullFov;
	}

	public struct LatencyData
	{
		public float render;

		public float timeWarp;

		public float postPresent;

		public float renderError;

		public float timeWarpError;
	}

	private bool needsConfigureTexture;

	private EyeRenderDesc[] eyeDescs = new EyeRenderDesc[2];

	private bool recenterRequested;

	private int recenterRequestedFrameCount = int.MaxValue;

	public Vector3 acceleration
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return Vector3.zero;
			}
			return OVRPlugin.GetNodeAcceleration(OVRPlugin.Node.Head, OVRPlugin.Step.Render).FromFlippedZVector3f();
		}
	}

	public Vector3 angularAcceleration
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return Vector3.zero;
			}
			return OVRPlugin.GetNodeAngularAcceleration(OVRPlugin.Node.Head, OVRPlugin.Step.Render).FromFlippedZVector3f() * 57.29578f;
		}
	}

	public Vector3 velocity
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return Vector3.zero;
			}
			return OVRPlugin.GetNodeVelocity(OVRPlugin.Node.Head, OVRPlugin.Step.Render).FromFlippedZVector3f();
		}
	}

	public Vector3 angularVelocity
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return Vector3.zero;
			}
			return OVRPlugin.GetNodeAngularVelocity(OVRPlugin.Node.Head, OVRPlugin.Step.Render).FromFlippedZVector3f() * 57.29578f;
		}
	}

	public LatencyData latency
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return default(LatencyData);
			}
			string input = OVRPlugin.latency;
			Regex regex = new Regex("Render: ([0-9]+[.][0-9]+)ms, TimeWarp: ([0-9]+[.][0-9]+)ms, PostPresent: ([0-9]+[.][0-9]+)ms", RegexOptions.None);
			LatencyData result = default(LatencyData);
			Match match = regex.Match(input);
			if (match.Success)
			{
				result.render = float.Parse(match.Groups[1].Value);
				result.timeWarp = float.Parse(match.Groups[2].Value);
				result.postPresent = float.Parse(match.Groups[3].Value);
			}
			return result;
		}
	}

	public float appFramerate
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return 0f;
			}
			return OVRPlugin.GetAppFramerate();
		}
	}

	public int recommendedMSAALevel
	{
		get
		{
			int num = OVRPlugin.recommendedMSAALevel;
			if (num == 1)
			{
				num = 0;
			}
			return num;
		}
	}

	public float[] displayFrequenciesAvailable => OVRPlugin.systemDisplayFrequenciesAvailable;

	public float displayFrequency
	{
		get
		{
			return OVRPlugin.systemDisplayFrequency;
		}
		set
		{
			OVRPlugin.systemDisplayFrequency = value;
		}
	}

	public event Action RecenteredPose;

	public OVRDisplay()
	{
		UpdateTextures();
	}

	public void Update()
	{
		UpdateTextures();
		if (recenterRequested && Time.frameCount > recenterRequestedFrameCount)
		{
			if (this.RecenteredPose != null)
			{
				this.RecenteredPose();
			}
			recenterRequested = false;
			recenterRequestedFrameCount = int.MaxValue;
		}
	}

	public void RecenterPose()
	{
		InputTracking.Recenter();
		recenterRequested = true;
		recenterRequestedFrameCount = Time.frameCount;
	}

	public EyeRenderDesc GetEyeRenderDesc(XRNode eye)
	{
		return eyeDescs[(int)eye];
	}

	private void UpdateTextures()
	{
		ConfigureEyeDesc(XRNode.LeftEye);
		ConfigureEyeDesc(XRNode.RightEye);
	}

	private void ConfigureEyeDesc(XRNode eye)
	{
		if (OVRManager.isHmdPresent)
		{
			OVRPlugin.Sizei eyeTextureSize = OVRPlugin.GetEyeTextureSize((OVRPlugin.Eye)eye);
			eyeDescs[(int)eye] = default(EyeRenderDesc);
			eyeDescs[(int)eye].resolution = new Vector2(eyeTextureSize.w, eyeTextureSize.h);
			if (OVRPlugin.GetNodeFrustum2((OVRPlugin.Node)eye, out var frustum))
			{
				eyeDescs[(int)eye].fullFov.LeftFov = 57.29578f * Mathf.Atan(frustum.Fov.LeftTan);
				eyeDescs[(int)eye].fullFov.RightFov = 57.29578f * Mathf.Atan(frustum.Fov.RightTan);
				eyeDescs[(int)eye].fullFov.UpFov = 57.29578f * Mathf.Atan(frustum.Fov.UpTan);
				eyeDescs[(int)eye].fullFov.DownFov = 57.29578f * Mathf.Atan(frustum.Fov.DownTan);
			}
			else
			{
				OVRPlugin.Frustumf eyeFrustum = OVRPlugin.GetEyeFrustum((OVRPlugin.Eye)eye);
				eyeDescs[(int)eye].fullFov.LeftFov = 57.29578f * eyeFrustum.fovX * 0.5f;
				eyeDescs[(int)eye].fullFov.RightFov = 57.29578f * eyeFrustum.fovX * 0.5f;
				eyeDescs[(int)eye].fullFov.UpFov = 57.29578f * eyeFrustum.fovY * 0.5f;
				eyeDescs[(int)eye].fullFov.DownFov = 57.29578f * eyeFrustum.fovY * 0.5f;
			}
			float num = Mathf.Max(eyeDescs[(int)eye].fullFov.LeftFov, eyeDescs[(int)eye].fullFov.RightFov);
			float num2 = Mathf.Max(eyeDescs[(int)eye].fullFov.UpFov, eyeDescs[(int)eye].fullFov.DownFov);
			eyeDescs[(int)eye].fov.x = num * 2f;
			eyeDescs[(int)eye].fov.y = num2 * 2f;
			if (!OVRPlugin.AsymmetricFovEnabled)
			{
				eyeDescs[(int)eye].fullFov.LeftFov = num;
				eyeDescs[(int)eye].fullFov.RightFov = num;
				eyeDescs[(int)eye].fullFov.UpFov = num2;
				eyeDescs[(int)eye].fullFov.DownFov = num2;
			}
		}
	}
}
public static class OVRHaptics
{
	public static class Config
	{
		public static int SampleRateHz { get; private set; }

		public static int SampleSizeInBytes { get; private set; }

		public static int MinimumSafeSamplesQueued { get; private set; }

		public static int MinimumBufferSamplesCount { get; private set; }

		public static int OptimalBufferSamplesCount { get; private set; }

		public static int MaximumBufferSamplesCount { get; private set; }

		static Config()
		{
			Load();
		}

		public static void Load()
		{
			OVRPlugin.HapticsDesc controllerHapticsDesc = OVRPlugin.GetControllerHapticsDesc(2u);
			SampleRateHz = controllerHapticsDesc.SampleRateHz;
			SampleSizeInBytes = controllerHapticsDesc.SampleSizeInBytes;
			MinimumSafeSamplesQueued = controllerHapticsDesc.MinimumSafeSamplesQueued;
			MinimumBufferSamplesCount = controllerHapticsDesc.MinimumBufferSamplesCount;
			OptimalBufferSamplesCount = controllerHapticsDesc.OptimalBufferSamplesCount;
			MaximumBufferSamplesCount = controllerHapticsDesc.MaximumBufferSamplesCount;
		}
	}

	public class OVRHapticsChannel
	{
		private OVRHapticsOutput m_output;

		public OVRHapticsChannel(uint outputIndex)
		{
			m_output = m_outputs[outputIndex];
		}

		public void Preempt(OVRHapticsClip clip)
		{
			m_output.Preempt(clip);
		}

		public void Queue(OVRHapticsClip clip)
		{
			m_output.Queue(clip);
		}

		public void Mix(OVRHapticsClip clip)
		{
			m_output.Mix(clip);
		}

		public void Clear()
		{
			m_output.Clear();
		}
	}

	private class OVRHapticsOutput
	{
		private class ClipPlaybackTracker
		{
			public int ReadCount { get; set; }

			public OVRHapticsClip Clip { get; set; }

			public ClipPlaybackTracker(OVRHapticsClip clip)
			{
				Clip = clip;
			}
		}

		private bool m_lowLatencyMode = true;

		private bool m_paddingEnabled = true;

		private int m_prevSamplesQueued;

		private float m_prevSamplesQueuedTime;

		private int m_numPredictionHits;

		private int m_numPredictionMisses;

		private int m_numUnderruns;

		private List<ClipPlaybackTracker> m_pendingClips = new List<ClipPlaybackTracker>();

		private uint m_controller;

		private OVRNativeBuffer m_nativeBuffer = new OVRNativeBuffer(Config.MaximumBufferSamplesCount * Config.SampleSizeInBytes);

		private OVRHapticsClip m_paddingClip = new OVRHapticsClip();

		public OVRHapticsOutput(uint controller)
		{
			m_paddingEnabled = false;
			m_controller = controller;
		}

		public void Process()
		{
			OVRPlugin.HapticsState controllerHapticsState = OVRPlugin.GetControllerHapticsState(m_controller);
			float num = Time.realtimeSinceStartup - m_prevSamplesQueuedTime;
			if (m_prevSamplesQueued > 0)
			{
				int num2 = m_prevSamplesQueued - (int)(num * (float)Config.SampleRateHz + 0.5f);
				if (num2 < 0)
				{
					num2 = 0;
				}
				if (controllerHapticsState.SamplesQueued - num2 == 0)
				{
					m_numPredictionHits++;
				}
				else
				{
					m_numPredictionMisses++;
				}
				if (num2 > 0 && controllerHapticsState.SamplesQueued == 0)
				{
					m_numUnderruns++;
				}
				m_prevSamplesQueued = controllerHapticsState.SamplesQueued;
				m_prevSamplesQueuedTime = Time.realtimeSinceStartup;
			}
			int num3 = Config.OptimalBufferSamplesCount;
			if (m_lowLatencyMode)
			{
				float num4 = 1000f / (float)Config.SampleRateHz;
				int num5 = (int)Mathf.Ceil(num * 1000f / num4);
				int num6 = Config.MinimumSafeSamplesQueued + num5;
				if (num6 < num3)
				{
					num3 = num6;
				}
			}
			if (controllerHapticsState.SamplesQueued > num3)
			{
				return;
			}
			if (num3 > Config.MaximumBufferSamplesCount)
			{
				num3 = Config.MaximumBufferSamplesCount;
			}
			if (num3 > controllerHapticsState.SamplesAvailable)
			{
				num3 = controllerHapticsState.SamplesAvailable;
			}
			int num7 = 0;
			int num8 = 0;
			while (num7 < num3 && num8 < m_pendingClips.Count)
			{
				int num9 = num3 - num7;
				int num10 = m_pendingClips[num8].Clip.Count - m_pendingClips[num8].ReadCount;
				if (num9 > num10)
				{
					num9 = num10;
				}
				if (num9 > 0)
				{
					int length = num9 * Config.SampleSizeInBytes;
					int byteOffset = num7 * Config.SampleSizeInBytes;
					int startIndex = m_pendingClips[num8].ReadCount * Config.SampleSizeInBytes;
					Marshal.Copy(m_pendingClips[num8].Clip.Samples, startIndex, m_nativeBuffer.GetPointer(byteOffset), length);
					m_pendingClips[num8].ReadCount += num9;
					num7 += num9;
				}
				num8++;
			}
			int num11 = m_pendingClips.Count - 1;
			while (num11 >= 0 && m_pendingClips.Count > 0)
			{
				if (m_pendingClips[num11].ReadCount >= m_pendingClips[num11].Clip.Count)
				{
					m_pendingClips.RemoveAt(num11);
				}
				num11--;
			}
			if (m_paddingEnabled)
			{
				int num12 = num3 - (controllerHapticsState.SamplesQueued + num7);
				if (num12 < Config.MinimumBufferSamplesCount - num7)
				{
					num12 = Config.MinimumBufferSamplesCount - num7;
				}
				if (num12 > controllerHapticsState.SamplesAvailable)
				{
					num12 = controllerHapticsState.SamplesAvailable;
				}
				if (num12 > 0)
				{
					int length2 = num12 * Config.SampleSizeInBytes;
					int byteOffset2 = num7 * Config.SampleSizeInBytes;
					int startIndex2 = 0;
					Marshal.Copy(m_paddingClip.Samples, startIndex2, m_nativeBuffer.GetPointer(byteOffset2), length2);
					num7 += num12;
				}
			}
			if (num7 > 0)
			{
				OVRPlugin.HapticsBuffer hapticsBuffer = default(OVRPlugin.HapticsBuffer);
				hapticsBuffer.Samples = m_nativeBuffer.GetPointer();
				hapticsBuffer.SamplesCount = num7;
				OVRPlugin.SetControllerHaptics(m_controller, hapticsBuffer);
				m_prevSamplesQueued = OVRPlugin.GetControllerHapticsState(m_controller).SamplesQueued;
				m_prevSamplesQueuedTime = Time.realtimeSinceStartup;
			}
		}

		public void Preempt(OVRHapticsClip clip)
		{
			m_pendingClips.Clear();
			m_pendingClips.Add(new ClipPlaybackTracker(clip));
		}

		public void Queue(OVRHapticsClip clip)
		{
			m_pendingClips.Add(new ClipPlaybackTracker(clip));
		}

		public void Mix(OVRHapticsClip clip)
		{
			int num = 0;
			int num2 = 0;
			int num3 = clip.Count;
			while (num3 > 0 && num < m_pendingClips.Count)
			{
				int num4 = m_pendingClips[num].Clip.Count - m_pendingClips[num].ReadCount;
				num3 -= num4;
				num2 += num4;
				num++;
			}
			if (num3 > 0)
			{
				num2 += num3;
				num3 = 0;
			}
			if (num > 0)
			{
				OVRHapticsClip oVRHapticsClip = new OVRHapticsClip(num2);
				int i = 0;
				for (int j = 0; j < num; j++)
				{
					OVRHapticsClip clip2 = m_pendingClips[j].Clip;
					for (int k = m_pendingClips[j].ReadCount; k < clip2.Count; k++)
					{
						if (Config.SampleSizeInBytes == 1)
						{
							byte sample = 0;
							if (i < clip.Count && k < clip2.Count)
							{
								sample = (byte)Mathf.Clamp(clip.Samples[i] + clip2.Samples[k], 0, 255);
								i++;
							}
							else if (k < clip2.Count)
							{
								sample = clip2.Samples[k];
							}
							oVRHapticsClip.WriteSample(sample);
						}
					}
				}
				for (; i < clip.Count; i++)
				{
					if (Config.SampleSizeInBytes == 1)
					{
						oVRHapticsClip.WriteSample(clip.Samples[i]);
					}
				}
				m_pendingClips[0] = new ClipPlaybackTracker(oVRHapticsClip);
				for (int l = 1; l < num; l++)
				{
					m_pendingClips.RemoveAt(1);
				}
			}
			else
			{
				m_pendingClips.Add(new ClipPlaybackTracker(clip));
			}
		}

		public void Clear()
		{
			m_pendingClips.Clear();
		}
	}

	public static readonly OVRHapticsChannel[] Channels;

	public static readonly OVRHapticsChannel LeftChannel;

	public static readonly OVRHapticsChannel RightChannel;

	private static readonly OVRHapticsOutput[] m_outputs;

	static OVRHaptics()
	{
		Config.Load();
		m_outputs = new OVRHapticsOutput[2]
		{
			new OVRHapticsOutput(1u),
			new OVRHapticsOutput(2u)
		};
		Channels = new OVRHapticsChannel[2]
		{
			LeftChannel = new OVRHapticsChannel(0u),
			RightChannel = new OVRHapticsChannel(1u)
		};
	}

	public static void Process()
	{
		Config.Load();
		for (int i = 0; i < m_outputs.Length; i++)
		{
			m_outputs[i].Process();
		}
	}
}
public class OVRHapticsClip
{
	public int Count { get; private set; }

	public int Capacity { get; private set; }

	public byte[] Samples { get; private set; }

	public OVRHapticsClip()
	{
		Capacity = OVRHaptics.Config.MaximumBufferSamplesCount;
		Samples = new byte[Capacity * OVRHaptics.Config.SampleSizeInBytes];
	}

	public OVRHapticsClip(int capacity)
	{
		Capacity = ((capacity >= 0) ? capacity : 0);
		Samples = new byte[Capacity * OVRHaptics.Config.SampleSizeInBytes];
	}

	public OVRHapticsClip(byte[] samples, int samplesCount)
	{
		Samples = samples;
		Capacity = Samples.Length / OVRHaptics.Config.SampleSizeInBytes;
		Count = ((samplesCount >= 0) ? samplesCount : 0);
	}

	public OVRHapticsClip(OVRHapticsClip a, OVRHapticsClip b)
	{
		int count = a.Count;
		if (b.Count > count)
		{
			count = b.Count;
		}
		Capacity = count;
		Samples = new byte[Capacity * OVRHaptics.Config.SampleSizeInBytes];
		for (int i = 0; i < a.Count || i < b.Count; i++)
		{
			if (OVRHaptics.Config.SampleSizeInBytes == 1)
			{
				byte sample = 0;
				if (i < a.Count && i < b.Count)
				{
					sample = (byte)Mathf.Clamp(a.Samples[i] + b.Samples[i], 0, 255);
				}
				else if (i < a.Count)
				{
					sample = a.Samples[i];
				}
				else if (i < b.Count)
				{
					sample = b.Samples[i];
				}
				WriteSample(sample);
			}
		}
	}

	public OVRHapticsClip(AudioClip audioClip, int channel = 0)
	{
		float[] array = new float[audioClip.samples * audioClip.channels];
		audioClip.GetData(array, 0);
		InitializeFromAudioFloatTrack(array, audioClip.frequency, audioClip.channels, channel);
	}

	public void WriteSample(byte sample)
	{
		if (Count < Capacity)
		{
			if (OVRHaptics.Config.SampleSizeInBytes == 1)
			{
				Samples[Count * OVRHaptics.Config.SampleSizeInBytes] = sample;
			}
			Count++;
		}
	}

	public void Reset()
	{
		Count = 0;
	}

	private void InitializeFromAudioFloatTrack(float[] sourceData, double sourceFrequency, int sourceChannelCount, int sourceChannel)
	{
		double num = (sourceFrequency + 1E-06) / (double)OVRHaptics.Config.SampleRateHz;
		if (num < 1.0)
		{
			return;
		}
		int num2 = (int)num;
		double num3 = num - (double)num2;
		double num4 = 0.0;
		int num5 = sourceData.Length;
		Count = 0;
		Capacity = num5 / sourceChannelCount / num2 + 1;
		Samples = new byte[Capacity * OVRHaptics.Config.SampleSizeInBytes];
		int num6 = sourceChannel % sourceChannelCount;
		while (num6 < num5)
		{
			if (OVRHaptics.Config.SampleSizeInBytes == 1)
			{
				WriteSample((byte)(Mathf.Clamp01(Mathf.Abs(sourceData[num6])) * 255f));
			}
			num6 += num2 * sourceChannelCount;
			num4 += num3;
			if ((int)num4 > 0)
			{
				num6 += (int)num4 * sourceChannelCount;
				num4 -= (double)(int)num4;
			}
		}
	}
}
public static class OVRInput
{
	[Flags]
	public enum Button
	{
		None = 0,
		One = 1,
		Two = 2,
		Three = 4,
		Four = 8,
		Start = 0x100,
		Back = 0x200,
		PrimaryShoulder = 0x1000,
		PrimaryIndexTrigger = 0x2000,
		PrimaryHandTrigger = 0x4000,
		PrimaryThumbstick = 0x8000,
		PrimaryThumbstickUp = 0x10000,
		PrimaryThumbstickDown = 0x20000,
		PrimaryThumbstickLeft = 0x40000,
		PrimaryThumbstickRight = 0x80000,
		PrimaryTouchpad = 0x400,
		SecondaryShoulder = 0x100000,
		SecondaryIndexTrigger = 0x200000,
		SecondaryHandTrigger = 0x400000,
		SecondaryThumbstick = 0x800000,
		SecondaryThumbstickUp = 0x1000000,
		SecondaryThumbstickDown = 0x2000000,
		SecondaryThumbstickLeft = 0x4000000,
		SecondaryThumbstickRight = 0x8000000,
		SecondaryTouchpad = 0x800,
		DpadUp = 0x10,
		DpadDown = 0x20,
		DpadLeft = 0x40,
		DpadRight = 0x80,
		Up = 0x10000000,
		Down = 0x20000000,
		Left = 0x40000000,
		Right = int.MinValue,
		Any = -1
	}

	[Flags]
	public enum RawButton
	{
		None = 0,
		A = 1,
		B = 2,
		X = 0x100,
		Y = 0x200,
		Start = 0x100000,
		Back = 0x200000,
		LShoulder = 0x800,
		LIndexTrigger = 0x10000000,
		LHandTrigger = 0x20000000,
		LThumbstick = 0x400,
		LThumbstickUp = 0x10,
		LThumbstickDown = 0x20,
		LThumbstickLeft = 0x40,
		LThumbstickRight = 0x80,
		LTouchpad = 0x40000000,
		RShoulder = 8,
		RIndexTrigger = 0x4000000,
		RHandTrigger = 0x8000000,
		RThumbstick = 4,
		RThumbstickUp = 0x1000,
		RThumbstickDown = 0x2000,
		RThumbstickLeft = 0x4000,
		RThumbstickRight = 0x8000,
		RTouchpad = int.MinValue,
		DpadUp = 0x10000,
		DpadDown = 0x20000,
		DpadLeft = 0x40000,
		DpadRight = 0x80000,
		Any = -1
	}

	[Flags]
	public enum Touch
	{
		None = 0,
		One = 1,
		Two = 2,
		Three = 4,
		Four = 8,
		PrimaryIndexTrigger = 0x2000,
		PrimaryThumbstick = 0x8000,
		PrimaryThumbRest = 0x1000,
		PrimaryTouchpad = 0x400,
		SecondaryIndexTrigger = 0x200000,
		SecondaryThumbstick = 0x800000,
		SecondaryThumbRest = 0x100000,
		SecondaryTouchpad = 0x800,
		Any = -1
	}

	[Flags]
	public enum RawTouch
	{
		None = 0,
		A = 1,
		B = 2,
		X = 0x100,
		Y = 0x200,
		LIndexTrigger = 0x1000,
		LThumbstick = 0x400,
		LThumbRest = 0x800,
		LTouchpad = 0x40000000,
		RIndexTrigger = 0x10,
		RThumbstick = 4,
		RThumbRest = 8,
		RTouchpad = int.MinValue,
		Any = -1
	}

	[Flags]
	public enum NearTouch
	{
		None = 0,
		PrimaryIndexTrigger = 1,
		PrimaryThumbButtons = 2,
		SecondaryIndexTrigger = 4,
		SecondaryThumbButtons = 8,
		Any = -1
	}

	[Flags]
	public enum RawNearTouch
	{
		None = 0,
		LIndexTrigger = 1,
		LThumbButtons = 2,
		RIndexTrigger = 4,
		RThumbButtons = 8,
		Any = -1
	}

	[Flags]
	public enum Axis1D
	{
		None = 0,
		PrimaryIndexTrigger = 1,
		PrimaryHandTrigger = 4,
		SecondaryIndexTrigger = 2,
		SecondaryHandTrigger = 8,
		Any = -1
	}

	[Flags]
	public enum RawAxis1D
	{
		None = 0,
		LIndexTrigger = 1,
		LHandTrigger = 4,
		RIndexTrigger = 2,
		RHandTrigger = 8,
		Any = -1
	}

	[Flags]
	public enum Axis2D
	{
		None = 0,
		PrimaryThumbstick = 1,
		PrimaryTouchpad = 4,
		SecondaryThumbstick = 2,
		SecondaryTouchpad = 8,
		Any = -1
	}

	[Flags]
	public enum RawAxis2D
	{
		None = 0,
		LThumbstick = 1,
		LTouchpad = 4,
		RThumbstick = 2,
		RTouchpad = 8,
		Any = -1
	}

	[Flags]
	public enum Controller
	{
		None = 0,
		LTouch = 1,
		RTouch = 2,
		Touch = 3,
		Remote = 4,
		Gamepad = 0x10,
		Touchpad = 0x8000000,
		LTrackedRemote = 0x1000000,
		RTrackedRemote = 0x2000000,
		Active = int.MinValue,
		All = -1
	}

	public enum Handedness
	{
		Unsupported,
		LeftHanded,
		RightHanded
	}

	private abstract class OVRControllerBase
	{
		public class VirtualButtonMap
		{
			public RawButton None;

			public RawButton One;

			public RawButton Two;

			public RawButton Three;

			public RawButton Four;

			public RawButton Start;

			public RawButton Back;

			public RawButton PrimaryShoulder;

			public RawButton PrimaryIndexTrigger;

			public RawButton PrimaryHandTrigger;

			public RawButton PrimaryThumbstick;

			public RawButton PrimaryThumbstickUp;

			public RawButton PrimaryThumbstickDown;

			public RawButton PrimaryThumbstickLeft;

			public RawButton PrimaryThumbstickRight;

			public RawButton PrimaryTouchpad;

			public RawButton SecondaryShoulder;

			public RawButton SecondaryIndexTrigger;

			public RawButton SecondaryHandTrigger;

			public RawButton SecondaryThumbstick;

			public RawButton SecondaryThumbstickUp;

			public RawButton SecondaryThumbstickDown;

			public RawButton SecondaryThumbstickLeft;

			public RawButton SecondaryThumbstickRight;

			public RawButton SecondaryTouchpad;

			public RawButton DpadUp;

			public RawButton DpadDown;

			public RawButton DpadLeft;

			public RawButton DpadRight;

			public RawButton Up;

			public RawButton Down;

			public RawButton Left;

			public RawButton Right;

			public RawButton ToRawMask(Button virtualMask)
			{
				RawButton rawButton = RawButton.None;
				if (virtualMask == Button.None)
				{
					return RawButton.None;
				}
				if ((virtualMask & Button.One) != 0)
				{
					rawButton |= One;
				}
				if ((virtualMask & Button.Two) != 0)
				{
					rawButton |= Two;
				}
				if ((virtualMask & Button.Three) != 0)
				{
					rawButton |= Three;
				}
				if ((virtualMask & Button.Four) != 0)
				{
					rawButton |= Four;
				}
				if ((virtualMask & Button.Start) != 0)
				{
					rawButton |= Start;
				}
				if ((virtualMask & Button.Back) != 0)
				{
					rawButton |= Back;
				}
				if ((virtualMask & Button.PrimaryShoulder) != 0)
				{
					rawButton |= PrimaryShoulder;
				}
				if ((virtualMask & Button.PrimaryIndexTrigger) != 0)
				{
					rawButton |= PrimaryIndexTrigger;
				}
				if ((virtualMask & Button.PrimaryHandTrigger) != 0)
				{
					rawButton |= PrimaryHandTrigger;
				}
				if ((virtualMask & Button.PrimaryThumbstick) != 0)
				{
					rawButton |= PrimaryThumbstick;
				}
				if ((virtualMask & Button.PrimaryThumbstickUp) != 0)
				{
					rawButton |= PrimaryThumbstickUp;
				}
				if ((virtualMask & Button.PrimaryThumbstickDown) != 0)
				{
					rawButton |= PrimaryThumbstickDown;
				}
				if ((virtualMask & Button.PrimaryThumbstickLeft) != 0)
				{
					rawButton |= PrimaryThumbstickLeft;
				}
				if ((virtualMask & Button.PrimaryThumbstickRight) != 0)
				{
					rawButton |= PrimaryThumbstickRight;
				}
				if ((virtualMask & Button.PrimaryTouchpad) != 0)
				{
					rawButton |= PrimaryTouchpad;
				}
				if ((virtualMask & Button.SecondaryShoulder) != 0)
				{
					rawButton |= SecondaryShoulder;
				}
				if ((virtualMask & Button.SecondaryIndexTrigger) != 0)
				{
					rawButton |= SecondaryIndexTrigger;
				}
				if ((virtualMask & Button.SecondaryHandTrigger) != 0)
				{
					rawButton |= SecondaryHandTrigger;
				}
				if ((virtualMask & Button.SecondaryThumbstick) != 0)
				{
					rawButton |= SecondaryThumbstick;
				}
				if ((virtualMask & Button.SecondaryThumbstickUp) != 0)
				{
					rawButton |= SecondaryThumbstickUp;
				}
				if ((virtualMask & Button.SecondaryThumbstickDown) != 0)
				{
					rawButton |= SecondaryThumbstickDown;
				}
				if ((virtualMask & Button.SecondaryThumbstickLeft) != 0)
				{
					rawButton |= SecondaryThumbstickLeft;
				}
				if ((virtualMask & Button.SecondaryThumbstickRight) != 0)
				{
					rawButton |= SecondaryThumbstickRight;
				}
				if ((virtualMask & Button.SecondaryTouchpad) != 0)
				{
					rawButton |= SecondaryTouchpad;
				}
				if ((virtualMask & Button.DpadUp) != 0)
				{
					rawButton |= DpadUp;
				}
				if ((virtualMask & Button.DpadDown) != 0)
				{
					rawButton |= DpadDown;
				}
				if ((virtualMask & Button.DpadLeft) != 0)
				{
					rawButton |= DpadLeft;
				}
				if ((virtualMask & Button.DpadRight) != 0)
				{
					rawButton |= DpadRight;
				}
				if ((virtualMask & Button.Up) != 0)
				{
					rawButton |= Up;
				}
				if ((virtualMask & Button.Down) != 0)
				{
					rawButton |= Down;
				}
				if ((virtualMask & Button.Left) != 0)
				{
					rawButton |= Left;
				}
				if (((uint)virtualMask & 0x80000000u) != 0)
				{
					rawButton |= Right;
				}
				return rawButton;
			}
		}

		public class VirtualTouchMap
		{
			public RawTouch None;

			public RawTouch One;

			public RawTouch Two;

			public RawTouch Three;

			public RawTouch Four;

			public RawTouch PrimaryIndexTrigger;

			public RawTouch PrimaryThumbstick;

			public RawTouch PrimaryThumbRest;

			public RawTouch PrimaryTouchpad;

			public RawTouch SecondaryIndexTrigger;

			public RawTouch SecondaryThumbstick;

			public RawTouch SecondaryThumbRest;

			public RawTouch SecondaryTouchpad;

			public RawTouch ToRawMask(Touch virtualMask)
			{
				RawTouch rawTouch = RawTouch.None;
				if (virtualMask == Touch.None)
				{
					return RawTouch.None;
				}
				if ((virtualMask & Touch.One) != 0)
				{
					rawTouch |= One;
				}
				if ((virtualMask & Touch.Two) != 0)
				{
					rawTouch |= Two;
				}
				if ((virtualMask & Touch.Three) != 0)
				{
					rawTouch |= Three;
				}
				if ((virtualMask & Touch.Four) != 0)
				{
					rawTouch |= Four;
				}
				if ((virtualMask & Touch.PrimaryIndexTrigger) != 0)
				{
					rawTouch |= PrimaryIndexTrigger;
				}
				if ((virtualMask & Touch.PrimaryThumbstick) != 0)
				{
					rawTouch |= PrimaryThumbstick;
				}
				if ((virtualMask & Touch.PrimaryThumbRest) != 0)
				{
					rawTouch |= PrimaryThumbRest;
				}
				if ((virtualMask & Touch.PrimaryTouchpad) != 0)
				{
					rawTouch |= PrimaryTouchpad;
				}
				if ((virtualMask & Touch.SecondaryIndexTrigger) != 0)
				{
					rawTouch |= SecondaryIndexTrigger;
				}
				if ((virtualMask & Touch.SecondaryThumbstick) != 0)
				{
					rawTouch |= SecondaryThumbstick;
				}
				if ((virtualMask & Touch.SecondaryThumbRest) != 0)
				{
					rawTouch |= SecondaryThumbRest;
				}
				if ((virtualMask & Touch.SecondaryTouchpad) != 0)
				{
					rawTouch |= SecondaryTouchpad;
				}
				return rawTouch;
			}
		}

		public class VirtualNearTouchMap
		{
			public RawNearTouch None;

			public RawNearTouch PrimaryIndexTrigger;

			public RawNearTouch PrimaryThumbButtons;

			public RawNearTouch SecondaryIndexTrigger;

			public RawNearTouch SecondaryThumbButtons;

			public RawNearTouch ToRawMask(NearTouch virtualMask)
			{
				RawNearTouch rawNearTouch = RawNearTouch.None;
				if (virtualMask == NearTouch.None)
				{
					return RawNearTouch.None;
				}
				if ((virtualMask & NearTouch.PrimaryIndexTrigger) != 0)
				{
					rawNearTouch |= PrimaryIndexTrigger;
				}
				if ((virtualMask & NearTouch.PrimaryThumbButtons) != 0)
				{
					rawNearTouch |= PrimaryThumbButtons;
				}
				if ((virtualMask & NearTouch.SecondaryIndexTrigger) != 0)
				{
					rawNearTouch |= SecondaryIndexTrigger;
				}
				if ((virtualMask & NearTouch.SecondaryThumbButtons) != 0)
				{
					rawNearTouch |= SecondaryThumbButtons;
				}
				return rawNearTouch;
			}
		}

		public class VirtualAxis1DMap
		{
			public RawAxis1D None;

			public RawAxis1D PrimaryIndexTrigger;

			public RawAxis1D PrimaryHandTrigger;

			public RawAxis1D SecondaryIndexTrigger;

			public RawAxis1D SecondaryHandTrigger;

			public RawAxis1D ToRawMask(Axis1D virtualMask)
			{
				RawAxis1D rawAxis1D = RawAxis1D.None;
				if (virtualMask == Axis1D.None)
				{
					return RawAxis1D.None;
				}
				if ((virtualMask & Axis1D.PrimaryIndexTrigger) != 0)
				{
					rawAxis1D |= PrimaryIndexTrigger;
				}
				if ((virtualMask & Axis1D.PrimaryHandTrigger) != 0)
				{
					rawAxis1D |= PrimaryHandTrigger;
				}
				if ((virtualMask & Axis1D.SecondaryIndexTrigger) != 0)
				{
					rawAxis1D |= SecondaryIndexTrigger;
				}
				if ((virtualMask & Axis1D.SecondaryHandTrigger) != 0)
				{
					rawAxis1D |= SecondaryHandTrigger;
				}
				return rawAxis1D;
			}
		}

		public class VirtualAxis2DMap
		{
			public RawAxis2D None;

			public RawAxis2D PrimaryThumbstick;

			public RawAxis2D PrimaryTouchpad;

			public RawAxis2D SecondaryThumbstick;

			public RawAxis2D SecondaryTouchpad;

			public RawAxis2D ToRawMask(Axis2D virtualMask)
			{
				RawAxis2D rawAxis2D = RawAxis2D.None;
				if (virtualMask == Axis2D.None)
				{
					return RawAxis2D.None;
				}
				if ((virtualMask & Axis2D.PrimaryThumbstick) != 0)
				{
					rawAxis2D |= PrimaryThumbstick;
				}
				if ((virtualMask & Axis2D.PrimaryTouchpad) != 0)
				{
					rawAxis2D |= PrimaryTouchpad;
				}
				if ((virtualMask & Axis2D.SecondaryThumbstick) != 0)
				{
					rawAxis2D |= SecondaryThumbstick;
				}
				if ((virtualMask & Axis2D.SecondaryTouchpad) != 0)
				{
					rawAxis2D |= SecondaryTouchpad;
				}
				return rawAxis2D;
			}
		}

		public Controller controllerType;

		public VirtualButtonMap buttonMap = new VirtualButtonMap();

		public VirtualTouchMap touchMap = new VirtualTouchMap();

		public VirtualNearTouchMap nearTouchMap = new VirtualNearTouchMap();

		public VirtualAxis1DMap axis1DMap = new VirtualAxis1DMap();

		public VirtualAxis2DMap axis2DMap = new VirtualAxis2DMap();

		public OVRPlugin.ControllerState4 previousState;

		public OVRPlugin.ControllerState4 currentState;

		public bool shouldApplyDeadzone = true;

		public OVRControllerBase()
		{
			ConfigureButtonMap();
			ConfigureTouchMap();
			ConfigureNearTouchMap();
			ConfigureAxis1DMap();
			ConfigureAxis2DMap();
		}

		public virtual Controller Update()
		{
			OVRPlugin.ControllerState4 controllerState = OVRPlugin.GetControllerState4((uint)controllerType);
			if (controllerState.LIndexTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 268435456u;
			}
			if (controllerState.LHandTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 536870912u;
			}
			if (controllerState.LThumbstick.y >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 16u;
			}
			if (controllerState.LThumbstick.y <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 32u;
			}
			if (controllerState.LThumbstick.x <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 64u;
			}
			if (controllerState.LThumbstick.x >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 128u;
			}
			if (controllerState.RIndexTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 67108864u;
			}
			if (controllerState.RHandTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 134217728u;
			}
			if (controllerState.RThumbstick.y >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 4096u;
			}
			if (controllerState.RThumbstick.y <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 8192u;
			}
			if (controllerState.RThumbstick.x <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 16384u;
			}
			if (controllerState.RThumbstick.x >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 32768u;
			}
			previousState = currentState;
			currentState = controllerState;
			return (Controller)((int)currentState.ConnectedControllers & (int)controllerType);
		}

		public virtual void SetControllerVibration(float frequency, float amplitude)
		{
			OVRPlugin.SetControllerVibration((uint)controllerType, frequency, amplitude);
		}

		public virtual void RecenterController()
		{
			OVRPlugin.RecenterTrackingOrigin(OVRPlugin.RecenterFlags.Controllers);
		}

		public virtual bool WasRecentered()
		{
			return false;
		}

		public virtual byte GetRecenterCount()
		{
			return 0;
		}

		public virtual byte GetBatteryPercentRemaining()
		{
			return 0;
		}

		public abstract void ConfigureButtonMap();

		public abstract void ConfigureTouchMap();

		public abstract void ConfigureNearTouchMap();

		public abstract void ConfigureAxis1DMap();

		public abstract void ConfigureAxis2DMap();

		public RawButton ResolveToRawMask(Button virtualMask)
		{
			return buttonMap.ToRawMask(virtualMask);
		}

		public RawTouch ResolveToRawMask(Touch virtualMask)
		{
			return touchMap.ToRawMask(virtualMask);
		}

		public RawNearTouch ResolveToRawMask(NearTouch virtualMask)
		{
			return nearTouchMap.ToRawMask(virtualMask);
		}

		public RawAxis1D ResolveToRawMask(Axis1D virtualMask)
		{
			return axis1DMap.ToRawMask(virtualMask);
		}

		public RawAxis2D ResolveToRawMask(Axis2D virtualMask)
		{
			return axis2DMap.ToRawMask(virtualMask);
		}
	}

	private class OVRControllerTouch : OVRControllerBase
	{
		public OVRControllerTouch()
		{
			controllerType = Controller.Touch;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.A;
			buttonMap.Two = RawButton.B;
			buttonMap.Three = RawButton.X;
			buttonMap.Four = RawButton.Y;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.None;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.LHandTrigger;
			buttonMap.PrimaryThumbstick = RawButton.LThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.LThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.LThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.LThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.LThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.SecondaryHandTrigger = RawButton.RHandTrigger;
			buttonMap.SecondaryThumbstick = RawButton.RThumbstick;
			buttonMap.SecondaryThumbstickUp = RawButton.RThumbstickUp;
			buttonMap.SecondaryThumbstickDown = RawButton.RThumbstickDown;
			buttonMap.SecondaryThumbstickLeft = RawButton.RThumbstickLeft;
			buttonMap.SecondaryThumbstickRight = RawButton.RThumbstickRight;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.None;
			buttonMap.DpadDown = RawButton.None;
			buttonMap.DpadLeft = RawButton.None;
			buttonMap.DpadRight = RawButton.None;
			buttonMap.Up = RawButton.LThumbstickUp;
			buttonMap.Down = RawButton.LThumbstickDown;
			buttonMap.Left = RawButton.LThumbstickLeft;
			buttonMap.Right = RawButton.LThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.A;
			touchMap.Two = RawTouch.B;
			touchMap.Three = RawTouch.X;
			touchMap.Four = RawTouch.Y;
			touchMap.PrimaryIndexTrigger = RawTouch.LIndexTrigger;
			touchMap.PrimaryThumbstick = RawTouch.LThumbstick;
			touchMap.PrimaryThumbRest = RawTouch.LThumbRest;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.RIndexTrigger;
			touchMap.SecondaryThumbstick = RawTouch.RThumbstick;
			touchMap.SecondaryThumbRest = RawTouch.RThumbRest;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.LIndexTrigger;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.LThumbButtons;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.RIndexTrigger;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.RThumbButtons;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.LHandTrigger;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.RHandTrigger;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.LThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.RThumbstick;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}

		public override bool WasRecentered()
		{
			return currentState.LRecenterCount + currentState.RRecenterCount != previousState.LRecenterCount + previousState.RRecenterCount;
		}

		public override byte GetRecenterCount()
		{
			return (byte)(currentState.LRecenterCount + currentState.RRecenterCount);
		}

		public override byte GetBatteryPercentRemaining()
		{
			byte lBatteryPercentRemaining = currentState.LBatteryPercentRemaining;
			byte rBatteryPercentRemaining = currentState.RBatteryPercentRemaining;
			if (lBatteryPercentRemaining > rBatteryPercentRemaining)
			{
				return rBatteryPercentRemaining;
			}
			return lBatteryPercentRemaining;
		}
	}

	private class OVRControllerLTouch : OVRControllerBase
	{
		public OVRControllerLTouch()
		{
			controllerType = Controller.LTouch;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.X;
			buttonMap.Two = RawButton.Y;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.None;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.LHandTrigger;
			buttonMap.PrimaryThumbstick = RawButton.LThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.LThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.LThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.LThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.LThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.None;
			buttonMap.DpadDown = RawButton.None;
			buttonMap.DpadLeft = RawButton.None;
			buttonMap.DpadRight = RawButton.None;
			buttonMap.Up = RawButton.LThumbstickUp;
			buttonMap.Down = RawButton.LThumbstickDown;
			buttonMap.Left = RawButton.LThumbstickLeft;
			buttonMap.Right = RawButton.LThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.X;
			touchMap.Two = RawTouch.Y;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.LIndexTrigger;
			touchMap.PrimaryThumbstick = RawTouch.LThumbstick;
			touchMap.PrimaryThumbRest = RawTouch.LThumbRest;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.LIndexTrigger;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.LThumbButtons;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.LHandTrigger;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.LThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}

		public override bool WasRecentered()
		{
			return currentState.LRecenterCount != previousState.LRecenterCount;
		}

		public override byte GetRecenterCount()
		{
			return currentState.LRecenterCount;
		}

		public override byte GetBatteryPercentRemaining()
		{
			return currentState.LBatteryPercentRemaining;
		}
	}

	private class OVRControllerRTouch : OVRControllerBase
	{
		public OVRControllerRTouch()
		{
			controllerType = Controller.RTouch;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.A;
			buttonMap.Two = RawButton.B;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.None;
			buttonMap.Back = RawButton.None;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.RHandTrigger;
			buttonMap.PrimaryThumbstick = RawButton.RThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.RThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.RThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.RThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.RThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.None;
			buttonMap.DpadDown = RawButton.None;
			buttonMap.DpadLeft = RawButton.None;
			buttonMap.DpadRight = RawButton.None;
			buttonMap.Up = RawButton.RThumbstickUp;
			buttonMap.Down = RawButton.RThumbstickDown;
			buttonMap.Left = RawButton.RThumbstickLeft;
			buttonMap.Right = RawButton.RThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.A;
			touchMap.Two = RawTouch.B;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.RIndexTrigger;
			touchMap.PrimaryThumbstick = RawTouch.RThumbstick;
			touchMap.PrimaryThumbRest = RawTouch.RThumbRest;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.RIndexTrigger;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.RThumbButtons;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.RHandTrigger;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.RThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}

		public override bool WasRecentered()
		{
			return currentState.RRecenterCount != previousState.RRecenterCount;
		}

		public override byte GetRecenterCount()
		{
			return currentState.RRecenterCount;
		}

		public override byte GetBatteryPercentRemaining()
		{
			return currentState.RBatteryPercentRemaining;
		}
	}

	private class OVRControllerRemote : OVRControllerBase
	{
		public OVRControllerRemote()
		{
			controllerType = Controller.Remote;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.Start;
			buttonMap.Two = RawButton.Back;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.None;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.None;
			buttonMap.PrimaryThumbstickUp = RawButton.None;
			buttonMap.PrimaryThumbstickDown = RawButton.None;
			buttonMap.PrimaryThumbstickLeft = RawButton.None;
			buttonMap.PrimaryThumbstickRight = RawButton.None;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.DpadUp;
			buttonMap.Down = RawButton.DpadDown;
			buttonMap.Left = RawButton.DpadLeft;
			buttonMap.Right = RawButton.DpadRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.None;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.None;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerGamepadPC : OVRControllerBase
	{
		public OVRControllerGamepadPC()
		{
			controllerType = Controller.Gamepad;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.A;
			buttonMap.Two = RawButton.B;
			buttonMap.Three = RawButton.X;
			buttonMap.Four = RawButton.Y;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.LShoulder;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.LThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.LThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.LThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.LThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.LThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.RShoulder;
			buttonMap.SecondaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.RThumbstick;
			buttonMap.SecondaryThumbstickUp = RawButton.RThumbstickUp;
			buttonMap.SecondaryThumbstickDown = RawButton.RThumbstickDown;
			buttonMap.SecondaryThumbstickLeft = RawButton.RThumbstickLeft;
			buttonMap.SecondaryThumbstickRight = RawButton.RThumbstickRight;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.LThumbstickUp;
			buttonMap.Down = RawButton.LThumbstickDown;
			buttonMap.Left = RawButton.LThumbstickLeft;
			buttonMap.Right = RawButton.LThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.LThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.RThumbstick;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerGamepadMac : OVRControllerBase
	{
		private enum AxisGPC
		{
			None = -1,
			LeftXAxis,
			LeftYAxis,
			RightXAxis,
			RightYAxis,
			LeftTrigger,
			RightTrigger,
			DPad_X_Axis,
			DPad_Y_Axis,
			Max
		}

		public enum ButtonGPC
		{
			None = -1,
			A,
			B,
			X,
			Y,
			Up,
			Down,
			Left,
			Right,
			Start,
			Back,
			LStick,
			RStick,
			LeftShoulder,
			RightShoulder,
			Max
		}

		private bool initialized;

		private const string DllName = "OVRGamepad";

		public OVRControllerGamepadMac()
		{
			controllerType = Controller.Gamepad;
			initialized = OVR_GamepadController_Initialize();
		}

		~OVRControllerGamepadMac()
		{
			if (initialized)
			{
				OVR_GamepadController_Destroy();
			}
		}

		public override Controller Update()
		{
			if (!initialized)
			{
				return Controller.None;
			}
			OVRPlugin.ControllerState4 controllerState = default(OVRPlugin.ControllerState4);
			if (OVR_GamepadController_Update())
			{
				controllerState.ConnectedControllers = 16u;
			}
			if (OVR_GamepadController_GetButton(0))
			{
				controllerState.Buttons |= 1u;
			}
			if (OVR_GamepadController_GetButton(1))
			{
				controllerState.Buttons |= 2u;
			}
			if (OVR_GamepadController_GetButton(2))
			{
				controllerState.Buttons |= 256u;
			}
			if (OVR_GamepadController_GetButton(3))
			{
				controllerState.Buttons |= 512u;
			}
			if (OVR_GamepadController_GetButton(4))
			{
				controllerState.Buttons |= 65536u;
			}
			if (OVR_GamepadController_GetButton(5))
			{
				controllerState.Buttons |= 131072u;
			}
			if (OVR_GamepadController_GetButton(6))
			{
				controllerState.Buttons |= 262144u;
			}
			if (OVR_GamepadController_GetButton(7))
			{
				controllerState.Buttons |= 524288u;
			}
			if (OVR_GamepadController_GetButton(8))
			{
				controllerState.Buttons |= 1048576u;
			}
			if (OVR_GamepadController_GetButton(9))
			{
				controllerState.Buttons |= 2097152u;
			}
			if (OVR_GamepadController_GetButton(10))
			{
				controllerState.Buttons |= 1024u;
			}
			if (OVR_GamepadController_GetButton(11))
			{
				controllerState.Buttons |= 4u;
			}
			if (OVR_GamepadController_GetButton(12))
			{
				controllerState.Buttons |= 2048u;
			}
			if (OVR_GamepadController_GetButton(13))
			{
				controllerState.Buttons |= 8u;
			}
			controllerState.LThumbstick.x = OVR_GamepadController_GetAxis(0);
			controllerState.LThumbstick.y = OVR_GamepadController_GetAxis(1);
			controllerState.RThumbstick.x = OVR_GamepadController_GetAxis(2);
			controllerState.RThumbstick.y = OVR_GamepadController_GetAxis(3);
			controllerState.LIndexTrigger = OVR_GamepadController_GetAxis(4);
			controllerState.RIndexTrigger = OVR_GamepadController_GetAxis(5);
			if (controllerState.LIndexTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 268435456u;
			}
			if (controllerState.LHandTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 536870912u;
			}
			if (controllerState.LThumbstick.y >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 16u;
			}
			if (controllerState.LThumbstick.y <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 32u;
			}
			if (controllerState.LThumbstick.x <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 64u;
			}
			if (controllerState.LThumbstick.x >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 128u;
			}
			if (controllerState.RIndexTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 67108864u;
			}
			if (controllerState.RHandTrigger >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 134217728u;
			}
			if (controllerState.RThumbstick.y >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 4096u;
			}
			if (controllerState.RThumbstick.y <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 8192u;
			}
			if (controllerState.RThumbstick.x <= 0f - AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 16384u;
			}
			if (controllerState.RThumbstick.x >= AXIS_AS_BUTTON_THRESHOLD)
			{
				controllerState.Buttons |= 32768u;
			}
			previousState = currentState;
			currentState = controllerState;
			return (Controller)((int)currentState.ConnectedControllers & (int)controllerType);
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.A;
			buttonMap.Two = RawButton.B;
			buttonMap.Three = RawButton.X;
			buttonMap.Four = RawButton.Y;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.LShoulder;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.LThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.LThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.LThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.LThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.LThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.RShoulder;
			buttonMap.SecondaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.RThumbstick;
			buttonMap.SecondaryThumbstickUp = RawButton.RThumbstickUp;
			buttonMap.SecondaryThumbstickDown = RawButton.RThumbstickDown;
			buttonMap.SecondaryThumbstickLeft = RawButton.RThumbstickLeft;
			buttonMap.SecondaryThumbstickRight = RawButton.RThumbstickRight;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.LThumbstickUp;
			buttonMap.Down = RawButton.LThumbstickDown;
			buttonMap.Left = RawButton.LThumbstickLeft;
			buttonMap.Right = RawButton.LThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.LThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.RThumbstick;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}

		public override void SetControllerVibration(float frequency, float amplitude)
		{
			float frequency2 = frequency * 200f;
			OVR_GamepadController_SetVibration(0, amplitude, frequency2);
		}

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool OVR_GamepadController_Initialize();

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool OVR_GamepadController_Destroy();

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool OVR_GamepadController_Update();

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern float OVR_GamepadController_GetAxis(int axis);

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool OVR_GamepadController_GetButton(int button);

		[DllImport("OVRGamepad", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool OVR_GamepadController_SetVibration(int node, float strength, float frequency);
	}

	private class OVRControllerGamepadAndroid : OVRControllerBase
	{
		public OVRControllerGamepadAndroid()
		{
			controllerType = Controller.Gamepad;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.A;
			buttonMap.Two = RawButton.B;
			buttonMap.Three = RawButton.X;
			buttonMap.Four = RawButton.Y;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.LShoulder;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.LThumbstick;
			buttonMap.PrimaryThumbstickUp = RawButton.LThumbstickUp;
			buttonMap.PrimaryThumbstickDown = RawButton.LThumbstickDown;
			buttonMap.PrimaryThumbstickLeft = RawButton.LThumbstickLeft;
			buttonMap.PrimaryThumbstickRight = RawButton.LThumbstickRight;
			buttonMap.PrimaryTouchpad = RawButton.None;
			buttonMap.SecondaryShoulder = RawButton.RShoulder;
			buttonMap.SecondaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.RThumbstick;
			buttonMap.SecondaryThumbstickUp = RawButton.RThumbstickUp;
			buttonMap.SecondaryThumbstickDown = RawButton.RThumbstickDown;
			buttonMap.SecondaryThumbstickLeft = RawButton.RThumbstickLeft;
			buttonMap.SecondaryThumbstickRight = RawButton.RThumbstickRight;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.LThumbstickUp;
			buttonMap.Down = RawButton.LThumbstickDown;
			buttonMap.Left = RawButton.LThumbstickLeft;
			buttonMap.Right = RawButton.LThumbstickRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.None;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.None;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.LThumbstick;
			axis2DMap.PrimaryTouchpad = RawAxis2D.None;
			axis2DMap.SecondaryThumbstick = RawAxis2D.RThumbstick;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerTouchpad : OVRControllerBase
	{
		private OVRPlugin.Vector2f moveAmount;

		private float maxTapMagnitude = 0.1f;

		private float minMoveMagnitude = 0.15f;

		public OVRControllerTouchpad()
		{
			controllerType = Controller.Touchpad;
		}

		public override Controller Update()
		{
			Controller result = base.Update();
			if (GetDown(RawTouch.LTouchpad, Controller.Touchpad))
			{
				moveAmount = currentState.LTouchpad;
			}
			if (GetUp(RawTouch.LTouchpad, Controller.Touchpad))
			{
				moveAmount.x = previousState.LTouchpad.x - moveAmount.x;
				moveAmount.y = previousState.LTouchpad.y - moveAmount.y;
				Vector2 vector = new Vector2(moveAmount.x, moveAmount.y);
				float magnitude = vector.magnitude;
				if (magnitude < maxTapMagnitude)
				{
					currentState.Buttons |= 1048576u;
					currentState.Buttons |= 1073741824u;
					return result;
				}
				if (magnitude >= minMoveMagnitude)
				{
					vector.Normalize();
					if (Mathf.Abs(vector.x) > Mathf.Abs(vector.y))
					{
						if (vector.x < 0f)
						{
							currentState.Buttons |= 262144u;
							return result;
						}
						currentState.Buttons |= 524288u;
						return result;
					}
					if (vector.y < 0f)
					{
						currentState.Buttons |= 131072u;
						return result;
					}
					currentState.Buttons |= 65536u;
				}
			}
			return result;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.LTouchpad;
			buttonMap.Two = RawButton.Back;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.None;
			buttonMap.PrimaryHandTrigger = RawButton.None;
			buttonMap.PrimaryThumbstick = RawButton.None;
			buttonMap.PrimaryThumbstickUp = RawButton.None;
			buttonMap.PrimaryThumbstickDown = RawButton.None;
			buttonMap.PrimaryThumbstickLeft = RawButton.None;
			buttonMap.PrimaryThumbstickRight = RawButton.None;
			buttonMap.PrimaryTouchpad = RawButton.LTouchpad;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.DpadUp;
			buttonMap.Down = RawButton.DpadDown;
			buttonMap.Left = RawButton.DpadLeft;
			buttonMap.Right = RawButton.DpadRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.LTouchpad;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.None;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.LTouchpad;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.None;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.None;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.None;
			axis2DMap.PrimaryTouchpad = RawAxis2D.LTouchpad;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}
	}

	private class OVRControllerLTrackedRemote : OVRControllerBase
	{
		private bool emitSwipe;

		private OVRPlugin.Vector2f moveAmount;

		private float minMoveMagnitude = 0.3f;

		public OVRControllerLTrackedRemote()
		{
			controllerType = Controller.LTrackedRemote;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.LTouchpad;
			buttonMap.Two = RawButton.Back;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.LIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.LHandTrigger;
			buttonMap.PrimaryThumbstick = RawButton.None;
			buttonMap.PrimaryThumbstickUp = RawButton.None;
			buttonMap.PrimaryThumbstickDown = RawButton.None;
			buttonMap.PrimaryThumbstickLeft = RawButton.None;
			buttonMap.PrimaryThumbstickRight = RawButton.None;
			buttonMap.PrimaryTouchpad = RawButton.LTouchpad;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.DpadUp;
			buttonMap.Down = RawButton.DpadDown;
			buttonMap.Left = RawButton.DpadLeft;
			buttonMap.Right = RawButton.DpadRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.LTouchpad;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.LIndexTrigger;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.LTouchpad;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.LIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.LHandTrigger;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.None;
			axis2DMap.PrimaryTouchpad = RawAxis2D.LTouchpad;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}

		public override Controller Update()
		{
			Controller result = base.Update();
			if (GetDown(RawTouch.LTouchpad, Controller.LTrackedRemote))
			{
				emitSwipe = true;
				moveAmount = currentState.LTouchpad;
			}
			if (GetDown(RawButton.LTouchpad, Controller.LTrackedRemote))
			{
				emitSwipe = false;
			}
			if (GetUp(RawTouch.LTouchpad, Controller.LTrackedRemote) && emitSwipe)
			{
				emitSwipe = false;
				moveAmount.x = previousState.LTouchpad.x - moveAmount.x;
				moveAmount.y = previousState.LTouchpad.y - moveAmount.y;
				Vector2 vector = new Vector2(moveAmount.x, moveAmount.y);
				if (vector.magnitude >= minMoveMagnitude)
				{
					vector.Normalize();
					if (Mathf.Abs(vector.x) > Mathf.Abs(vector.y))
					{
						if (vector.x < 0f)
						{
							currentState.Buttons |= 262144u;
							return result;
						}
						currentState.Buttons |= 524288u;
						return result;
					}
					if (vector.y < 0f)
					{
						currentState.Buttons |= 131072u;
						return result;
					}
					currentState.Buttons |= 65536u;
				}
			}
			return result;
		}

		public override bool WasRecentered()
		{
			return currentState.LRecenterCount != previousState.LRecenterCount;
		}

		public override byte GetRecenterCount()
		{
			return currentState.LRecenterCount;
		}

		public override byte GetBatteryPercentRemaining()
		{
			return currentState.LBatteryPercentRemaining;
		}
	}

	private class OVRControllerRTrackedRemote : OVRControllerBase
	{
		private bool emitSwipe;

		private OVRPlugin.Vector2f moveAmount;

		private float minMoveMagnitude = 0.3f;

		public OVRControllerRTrackedRemote()
		{
			controllerType = Controller.RTrackedRemote;
		}

		public override void ConfigureButtonMap()
		{
			buttonMap.None = RawButton.None;
			buttonMap.One = RawButton.RTouchpad;
			buttonMap.Two = RawButton.Back;
			buttonMap.Three = RawButton.None;
			buttonMap.Four = RawButton.None;
			buttonMap.Start = RawButton.Start;
			buttonMap.Back = RawButton.Back;
			buttonMap.PrimaryShoulder = RawButton.None;
			buttonMap.PrimaryIndexTrigger = RawButton.RIndexTrigger;
			buttonMap.PrimaryHandTrigger = RawButton.RHandTrigger;
			buttonMap.PrimaryThumbstick = RawButton.None;
			buttonMap.PrimaryThumbstickUp = RawButton.None;
			buttonMap.PrimaryThumbstickDown = RawButton.None;
			buttonMap.PrimaryThumbstickLeft = RawButton.None;
			buttonMap.PrimaryThumbstickRight = RawButton.None;
			buttonMap.PrimaryTouchpad = RawButton.RTouchpad;
			buttonMap.SecondaryShoulder = RawButton.None;
			buttonMap.SecondaryIndexTrigger = RawButton.None;
			buttonMap.SecondaryHandTrigger = RawButton.None;
			buttonMap.SecondaryThumbstick = RawButton.None;
			buttonMap.SecondaryThumbstickUp = RawButton.None;
			buttonMap.SecondaryThumbstickDown = RawButton.None;
			buttonMap.SecondaryThumbstickLeft = RawButton.None;
			buttonMap.SecondaryThumbstickRight = RawButton.None;
			buttonMap.SecondaryTouchpad = RawButton.None;
			buttonMap.DpadUp = RawButton.DpadUp;
			buttonMap.DpadDown = RawButton.DpadDown;
			buttonMap.DpadLeft = RawButton.DpadLeft;
			buttonMap.DpadRight = RawButton.DpadRight;
			buttonMap.Up = RawButton.DpadUp;
			buttonMap.Down = RawButton.DpadDown;
			buttonMap.Left = RawButton.DpadLeft;
			buttonMap.Right = RawButton.DpadRight;
		}

		public override void ConfigureTouchMap()
		{
			touchMap.None = RawTouch.None;
			touchMap.One = RawTouch.RTouchpad;
			touchMap.Two = RawTouch.None;
			touchMap.Three = RawTouch.None;
			touchMap.Four = RawTouch.None;
			touchMap.PrimaryIndexTrigger = RawTouch.RIndexTrigger;
			touchMap.PrimaryThumbstick = RawTouch.None;
			touchMap.PrimaryThumbRest = RawTouch.None;
			touchMap.PrimaryTouchpad = RawTouch.RTouchpad;
			touchMap.SecondaryIndexTrigger = RawTouch.None;
			touchMap.SecondaryThumbstick = RawTouch.None;
			touchMap.SecondaryThumbRest = RawTouch.None;
			touchMap.SecondaryTouchpad = RawTouch.None;
		}

		public override void ConfigureNearTouchMap()
		{
			nearTouchMap.None = RawNearTouch.None;
			nearTouchMap.PrimaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.PrimaryThumbButtons = RawNearTouch.None;
			nearTouchMap.SecondaryIndexTrigger = RawNearTouch.None;
			nearTouchMap.SecondaryThumbButtons = RawNearTouch.None;
		}

		public override void ConfigureAxis1DMap()
		{
			axis1DMap.None = RawAxis1D.None;
			axis1DMap.PrimaryIndexTrigger = RawAxis1D.RIndexTrigger;
			axis1DMap.PrimaryHandTrigger = RawAxis1D.RHandTrigger;
			axis1DMap.SecondaryIndexTrigger = RawAxis1D.None;
			axis1DMap.SecondaryHandTrigger = RawAxis1D.None;
		}

		public override void ConfigureAxis2DMap()
		{
			axis2DMap.None = RawAxis2D.None;
			axis2DMap.PrimaryThumbstick = RawAxis2D.None;
			axis2DMap.PrimaryTouchpad = RawAxis2D.RTouchpad;
			axis2DMap.SecondaryThumbstick = RawAxis2D.None;
			axis2DMap.SecondaryTouchpad = RawAxis2D.None;
		}

		public override Controller Update()
		{
			Controller result = base.Update();
			if (GetDown(RawTouch.RTouchpad, Controller.RTrackedRemote))
			{
				emitSwipe = true;
				moveAmount = currentState.RTouchpad;
			}
			if (GetDown(RawButton.RTouchpad, Controller.RTrackedRemote))
			{
				emitSwipe = false;
			}
			if (GetUp(RawTouch.RTouchpad, Controller.RTrackedRemote) && emitSwipe)
			{
				emitSwipe = false;
				moveAmount.x = previousState.RTouchpad.x - moveAmount.x;
				moveAmount.y = previousState.RTouchpad.y - moveAmount.y;
				Vector2 vector = new Vector2(moveAmount.x, moveAmount.y);
				if (vector.magnitude >= minMoveMagnitude)
				{
					vector.Normalize();
					if (Mathf.Abs(vector.x) > Mathf.Abs(vector.y))
					{
						if (vector.x < 0f)
						{
							currentState.Buttons |= 262144u;
							return result;
						}
						currentState.Buttons |= 524288u;
						return result;
					}
					if (vector.y < 0f)
					{
						currentState.Buttons |= 131072u;
						return result;
					}
					currentState.Buttons |= 65536u;
				}
			}
			return result;
		}

		public override bool WasRecentered()
		{
			return currentState.RRecenterCount != previousState.RRecenterCount;
		}

		public override byte GetRecenterCount()
		{
			return currentState.RRecenterCount;
		}

		public override byte GetBatteryPercentRemaining()
		{
			return currentState.RBatteryPercentRemaining;
		}
	}

	private static readonly float AXIS_AS_BUTTON_THRESHOLD;

	private static readonly float AXIS_DEADZONE_THRESHOLD;

	private static List<OVRControllerBase> controllers;

	private static Controller activeControllerType;

	private static Controller connectedControllerTypes;

	private static OVRPlugin.Step stepType;

	private static int fixedUpdateCount;

	private static bool _pluginSupportsActiveController;

	private static bool _pluginSupportsActiveControllerCached;

	private static Version _pluginSupportsActiveControllerMinVersion;

	private static bool pluginSupportsActiveController
	{
		get
		{
			if (!_pluginSupportsActiveControllerCached)
			{
				_pluginSupportsActiveController = false && OVRPlugin.version >= _pluginSupportsActiveControllerMinVersion;
				_pluginSupportsActiveControllerCached = true;
			}
			return _pluginSupportsActiveController;
		}
	}

	static OVRInput()
	{
		AXIS_AS_BUTTON_THRESHOLD = 0.5f;
		AXIS_DEADZONE_THRESHOLD = 0.2f;
		activeControllerType = Controller.None;
		connectedControllerTypes = Controller.None;
		stepType = OVRPlugin.Step.Render;
		fixedUpdateCount = 0;
		_pluginSupportsActiveController = false;
		_pluginSupportsActiveControllerCached = false;
		_pluginSupportsActiveControllerMinVersion = new Version(1, 9, 0);
		controllers = new List<OVRControllerBase>
		{
			new OVRControllerGamepadAndroid(),
			new OVRControllerTouchpad(),
			new OVRControllerLTrackedRemote(),
			new OVRControllerRTrackedRemote(),
			new OVRControllerTouch(),
			new OVRControllerLTouch(),
			new OVRControllerRTouch()
		};
	}

	public static void Update()
	{
		connectedControllerTypes = Controller.None;
		stepType = OVRPlugin.Step.Render;
		fixedUpdateCount = 0;
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			connectedControllerTypes |= oVRControllerBase.Update();
			if ((connectedControllerTypes & oVRControllerBase.controllerType) != 0)
			{
				RawTouch rawMask = RawTouch.Any;
				if (Get(RawButton.Any, oVRControllerBase.controllerType) || Get(rawMask, oVRControllerBase.controllerType))
				{
					activeControllerType = oVRControllerBase.controllerType;
				}
			}
		}
		if ((activeControllerType == Controller.LTouch || activeControllerType == Controller.RTouch) && (connectedControllerTypes & Controller.Touch) == Controller.Touch)
		{
			activeControllerType = Controller.Touch;
		}
		if ((connectedControllerTypes & activeControllerType) == 0)
		{
			activeControllerType = Controller.None;
		}
		if (activeControllerType == Controller.None)
		{
			if ((connectedControllerTypes & Controller.RTrackedRemote) != 0)
			{
				activeControllerType = Controller.RTrackedRemote;
			}
			else if ((connectedControllerTypes & Controller.LTrackedRemote) != 0)
			{
				activeControllerType = Controller.LTrackedRemote;
			}
		}
		if (pluginSupportsActiveController)
		{
			connectedControllerTypes = (Controller)OVRPlugin.GetConnectedControllers();
			activeControllerType = (Controller)OVRPlugin.GetActiveController();
		}
	}

	public static void FixedUpdate()
	{
		stepType = OVRPlugin.Step.Physics;
		double predictionSeconds = (double)fixedUpdateCount * (double)Time.fixedDeltaTime / (double)Mathf.Max(Time.timeScale, 1E-06f);
		fixedUpdateCount++;
		OVRPlugin.UpdateNodePhysicsPoses(0, predictionSeconds);
	}

	public static bool GetControllerOrientationTracked(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodeOrientationTracked(OVRPlugin.Node.HandLeft);
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodeOrientationTracked(OVRPlugin.Node.HandRight);
		default:
			return false;
		}
	}

	public static bool GetControllerPositionTracked(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.HandLeft);
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.HandRight);
		default:
			return false;
		}
	}

	public static Vector3 GetLocalControllerPosition(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodePose(OVRPlugin.Node.HandLeft, stepType).ToOVRPose().position;
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodePose(OVRPlugin.Node.HandRight, stepType).ToOVRPose().position;
		default:
			return Vector3.zero;
		}
	}

	public static Vector3 GetLocalControllerVelocity(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodeVelocity(OVRPlugin.Node.HandLeft, stepType).FromFlippedZVector3f();
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodeVelocity(OVRPlugin.Node.HandRight, stepType).FromFlippedZVector3f();
		default:
			return Vector3.zero;
		}
	}

	public static Vector3 GetLocalControllerAcceleration(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodeAcceleration(OVRPlugin.Node.HandLeft, stepType).FromFlippedZVector3f();
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodeAcceleration(OVRPlugin.Node.HandRight, stepType).FromFlippedZVector3f();
		default:
			return Vector3.zero;
		}
	}

	public static Quaternion GetLocalControllerRotation(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodePose(OVRPlugin.Node.HandLeft, stepType).ToOVRPose().orientation;
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodePose(OVRPlugin.Node.HandRight, stepType).ToOVRPose().orientation;
		default:
			return Quaternion.identity;
		}
	}

	public static Vector3 GetLocalControllerAngularVelocity(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodeAngularVelocity(OVRPlugin.Node.HandLeft, stepType).FromFlippedZVector3f();
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodeAngularVelocity(OVRPlugin.Node.HandRight, stepType).FromFlippedZVector3f();
		default:
			return Vector3.zero;
		}
	}

	public static Vector3 GetLocalControllerAngularAcceleration(Controller controllerType)
	{
		switch (controllerType)
		{
		case Controller.LTouch:
		case Controller.LTrackedRemote:
			return OVRPlugin.GetNodeAngularAcceleration(OVRPlugin.Node.HandLeft, stepType).FromFlippedZVector3f();
		case Controller.RTouch:
		case Controller.RTrackedRemote:
			return OVRPlugin.GetNodeAngularAcceleration(OVRPlugin.Node.HandRight, stepType).FromFlippedZVector3f();
		default:
			return Vector3.zero;
		}
	}

	public static Handedness GetDominantHand()
	{
		return (Handedness)OVRPlugin.GetDominantHand();
	}

	public static bool Get(Button virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButton(virtualMask, RawButton.None, controllerMask);
	}

	public static bool Get(RawButton rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButton(Button.None, rawMask, controllerMask);
	}

	private static bool GetResolvedButton(Button virtualMask, RawButton rawMask, Controller controllerMask)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawButton rawButton = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.Buttons & (uint)rawButton) != 0)
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool GetDown(Button virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButtonDown(virtualMask, RawButton.None, controllerMask);
	}

	public static bool GetDown(RawButton rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButtonDown(Button.None, rawMask, controllerMask);
	}

	private static bool GetResolvedButtonDown(Button virtualMask, RawButton rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawButton rawButton = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.previousState.Buttons & (uint)rawButton) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.Buttons & (uint)rawButton) != 0 && (oVRControllerBase.previousState.Buttons & (uint)rawButton) == 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static bool GetUp(Button virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButtonUp(virtualMask, RawButton.None, controllerMask);
	}

	public static bool GetUp(RawButton rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedButtonUp(Button.None, rawMask, controllerMask);
	}

	private static bool GetResolvedButtonUp(Button virtualMask, RawButton rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawButton rawButton = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.Buttons & (uint)rawButton) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.Buttons & (uint)rawButton) == 0 && (oVRControllerBase.previousState.Buttons & (uint)rawButton) != 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static bool Get(Touch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouch(virtualMask, RawTouch.None, controllerMask);
	}

	public static bool Get(RawTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouch(Touch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedTouch(Touch virtualMask, RawTouch rawMask, Controller controllerMask)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawTouch rawTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.Touches & (uint)rawTouch) != 0)
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool GetDown(Touch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouchDown(virtualMask, RawTouch.None, controllerMask);
	}

	public static bool GetDown(RawTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouchDown(Touch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedTouchDown(Touch virtualMask, RawTouch rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawTouch rawTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.previousState.Touches & (uint)rawTouch) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.Touches & (uint)rawTouch) != 0 && (oVRControllerBase.previousState.Touches & (uint)rawTouch) == 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static bool GetUp(Touch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouchUp(virtualMask, RawTouch.None, controllerMask);
	}

	public static bool GetUp(RawTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedTouchUp(Touch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedTouchUp(Touch virtualMask, RawTouch rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawTouch rawTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.Touches & (uint)rawTouch) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.Touches & (uint)rawTouch) == 0 && (oVRControllerBase.previousState.Touches & (uint)rawTouch) != 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static bool Get(NearTouch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouch(virtualMask, RawNearTouch.None, controllerMask);
	}

	public static bool Get(RawNearTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouch(NearTouch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedNearTouch(NearTouch virtualMask, RawNearTouch rawMask, Controller controllerMask)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawNearTouch rawNearTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.NearTouches & (uint)rawNearTouch) != 0)
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool GetDown(NearTouch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouchDown(virtualMask, RawNearTouch.None, controllerMask);
	}

	public static bool GetDown(RawNearTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouchDown(NearTouch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedNearTouchDown(NearTouch virtualMask, RawNearTouch rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawNearTouch rawNearTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.previousState.NearTouches & (uint)rawNearTouch) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.NearTouches & (uint)rawNearTouch) != 0 && (oVRControllerBase.previousState.NearTouches & (uint)rawNearTouch) == 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static bool GetUp(NearTouch virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouchUp(virtualMask, RawNearTouch.None, controllerMask);
	}

	public static bool GetUp(RawNearTouch rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedNearTouchUp(NearTouch.None, rawMask, controllerMask);
	}

	private static bool GetResolvedNearTouchUp(NearTouch virtualMask, RawNearTouch rawMask, Controller controllerMask)
	{
		bool result = false;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				RawNearTouch rawNearTouch = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
				if ((oVRControllerBase.currentState.NearTouches & (uint)rawNearTouch) != 0)
				{
					return false;
				}
				if ((oVRControllerBase.currentState.NearTouches & (uint)rawNearTouch) == 0 && (oVRControllerBase.previousState.NearTouches & (uint)rawNearTouch) != 0)
				{
					result = true;
				}
			}
		}
		return result;
	}

	public static float Get(Axis1D virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedAxis1D(virtualMask, RawAxis1D.None, controllerMask);
	}

	public static float Get(RawAxis1D rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedAxis1D(Axis1D.None, rawMask, controllerMask);
	}

	private static float GetResolvedAxis1D(Axis1D virtualMask, RawAxis1D rawMask, Controller controllerMask)
	{
		float num = 0f;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (!ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				continue;
			}
			RawAxis1D rawAxis1D = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
			if ((RawAxis1D.LIndexTrigger & rawAxis1D) != 0)
			{
				float num2 = oVRControllerBase.currentState.LIndexTrigger;
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					num2 = CalculateDeadzone(num2, AXIS_DEADZONE_THRESHOLD);
				}
				num = CalculateAbsMax(num, num2);
			}
			if ((RawAxis1D.RIndexTrigger & rawAxis1D) != 0)
			{
				float num3 = oVRControllerBase.currentState.RIndexTrigger;
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					num3 = CalculateDeadzone(num3, AXIS_DEADZONE_THRESHOLD);
				}
				num = CalculateAbsMax(num, num3);
			}
			if ((RawAxis1D.LHandTrigger & rawAxis1D) != 0)
			{
				float num4 = oVRControllerBase.currentState.LHandTrigger;
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					num4 = CalculateDeadzone(num4, AXIS_DEADZONE_THRESHOLD);
				}
				num = CalculateAbsMax(num, num4);
			}
			if ((RawAxis1D.RHandTrigger & rawAxis1D) != 0)
			{
				float num5 = oVRControllerBase.currentState.RHandTrigger;
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					num5 = CalculateDeadzone(num5, AXIS_DEADZONE_THRESHOLD);
				}
				num = CalculateAbsMax(num, num5);
			}
		}
		return num;
	}

	public static Vector2 Get(Axis2D virtualMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedAxis2D(virtualMask, RawAxis2D.None, controllerMask);
	}

	public static Vector2 Get(RawAxis2D rawMask, Controller controllerMask = Controller.Active)
	{
		return GetResolvedAxis2D(Axis2D.None, rawMask, controllerMask);
	}

	private static Vector2 GetResolvedAxis2D(Axis2D virtualMask, RawAxis2D rawMask, Controller controllerMask)
	{
		Vector2 vector = Vector2.zero;
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (!ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				continue;
			}
			RawAxis2D rawAxis2D = rawMask | oVRControllerBase.ResolveToRawMask(virtualMask);
			if ((RawAxis2D.LThumbstick & rawAxis2D) != 0)
			{
				Vector2 vector2 = new Vector2(oVRControllerBase.currentState.LThumbstick.x, oVRControllerBase.currentState.LThumbstick.y);
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					vector2 = CalculateDeadzone(vector2, AXIS_DEADZONE_THRESHOLD);
				}
				vector = CalculateAbsMax(vector, vector2);
			}
			if ((RawAxis2D.LTouchpad & rawAxis2D) != 0)
			{
				Vector2 b = new Vector2(oVRControllerBase.currentState.LTouchpad.x, oVRControllerBase.currentState.LTouchpad.y);
				vector = CalculateAbsMax(vector, b);
			}
			if ((RawAxis2D.RThumbstick & rawAxis2D) != 0)
			{
				Vector2 vector3 = new Vector2(oVRControllerBase.currentState.RThumbstick.x, oVRControllerBase.currentState.RThumbstick.y);
				if (oVRControllerBase.shouldApplyDeadzone)
				{
					vector3 = CalculateDeadzone(vector3, AXIS_DEADZONE_THRESHOLD);
				}
				vector = CalculateAbsMax(vector, vector3);
			}
			if ((RawAxis2D.RTouchpad & rawAxis2D) != 0)
			{
				Vector2 b2 = new Vector2(oVRControllerBase.currentState.RTouchpad.x, oVRControllerBase.currentState.RTouchpad.y);
				vector = CalculateAbsMax(vector, b2);
			}
		}
		return vector;
	}

	public static Controller GetConnectedControllers()
	{
		return connectedControllerTypes;
	}

	public static bool IsControllerConnected(Controller controller)
	{
		return (connectedControllerTypes & controller) == controller;
	}

	public static Controller GetActiveController()
	{
		return activeControllerType;
	}

	public static void SetControllerVibration(float frequency, float amplitude, Controller controllerMask = Controller.Active)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				oVRControllerBase.SetControllerVibration(frequency, amplitude);
			}
		}
	}

	public static void RecenterController(Controller controllerMask = Controller.Active)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				oVRControllerBase.RecenterController();
			}
		}
	}

	public static bool GetControllerWasRecentered(Controller controllerMask = Controller.Active)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		bool flag = false;
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				flag |= oVRControllerBase.WasRecentered();
			}
		}
		return flag;
	}

	public static byte GetControllerRecenterCount(Controller controllerMask = Controller.Active)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		byte result = 0;
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				result = oVRControllerBase.GetRecenterCount();
				break;
			}
		}
		return result;
	}

	public static byte GetControllerBatteryPercentRemaining(Controller controllerMask = Controller.Active)
	{
		if (((uint)controllerMask & 0x80000000u) != 0)
		{
			controllerMask |= activeControllerType;
		}
		byte result = 0;
		for (int i = 0; i < controllers.Count; i++)
		{
			OVRControllerBase oVRControllerBase = controllers[i];
			if (ShouldResolveController(oVRControllerBase.controllerType, controllerMask))
			{
				result = oVRControllerBase.GetBatteryPercentRemaining();
				break;
			}
		}
		return result;
	}

	private static Vector2 CalculateAbsMax(Vector2 a, Vector2 b)
	{
		float sqrMagnitude = a.sqrMagnitude;
		float sqrMagnitude2 = b.sqrMagnitude;
		if (sqrMagnitude >= sqrMagnitude2)
		{
			return a;
		}
		return b;
	}

	private static float CalculateAbsMax(float a, float b)
	{
		float num = ((a >= 0f) ? a : (0f - a));
		float num2 = ((b >= 0f) ? b : (0f - b));
		if (num >= num2)
		{
			return a;
		}
		return b;
	}

	public static Vector2 CalculateDeadzone(Vector2 a, float deadzone)
	{
		if (a.sqrMagnitude <= deadzone * deadzone)
		{
			return Vector2.zero;
		}
		a *= (a.magnitude - deadzone) / (1f - deadzone);
		if (a.sqrMagnitude > 1f)
		{
			return a.normalized;
		}
		return a;
	}

	public static float CalculateDeadzone(float a, float deadzone)
	{
		float num = ((a >= 0f) ? a : (0f - a));
		if (num <= deadzone)
		{
			return 0f;
		}
		a *= (num - deadzone) / (1f - deadzone);
		if (a * a > 1f)
		{
			if (!(a >= 0f))
			{
				return -1f;
			}
			return 1f;
		}
		return a;
	}

	private static bool ShouldResolveController(Controller controllerType, Controller controllerMask)
	{
		bool result = false;
		if ((controllerType & controllerMask) == controllerType)
		{
			result = true;
		}
		if ((controllerMask & Controller.Touch) == Controller.Touch && (controllerType & Controller.Touch) != 0 && (controllerType & Controller.Touch) != Controller.Touch)
		{
			result = false;
		}
		return result;
	}
}
public class OVRLayerAttribute : PropertyAttribute
{
}
public class OVRManager : MonoBehaviour
{
	public enum TrackingOrigin
	{
		EyeLevel,
		FloorLevel
	}

	public enum EyeTextureFormat
	{
		Default = 0,
		R16G16B16A16_FP = 2,
		R11G11B10_FP = 3
	}

	public enum TiledMultiResLevel
	{
		Off,
		LMSLow,
		LMSMedium,
		LMSHigh
	}

	private static OVRProfile _profile;

	private IEnumerable<Camera> disabledCameras;

	private float prevTimeScale;

	private static bool _isHmdPresentCached = false;

	private static bool _isHmdPresent = false;

	private static bool _wasHmdPresent = false;

	private static bool _hasVrFocusCached = false;

	private static bool _hasVrFocus = false;

	private static bool _hadVrFocus = false;

	private static bool _hadInputFocus = true;

	[Header("Performance/Quality")]
	[Tooltip("If true, distortion rendering work is submitted a quarter-frame early to avoid pipeline stalls and increase CPU-GPU parallelism.")]
	public bool queueAhead = true;

	[Tooltip("If true, Unity will use the optimal antialiasing level for quality/performance on the current hardware.")]
	public bool useRecommendedMSAALevel;

	[SerializeField]
	[Tooltip("If true, both eyes will see the same image, rendered from the center eye pose, saving performance.")]
	private bool _monoscopic;

	[Tooltip("If true, dynamic resolution will be enabled On PC")]
	public bool enableAdaptiveResolution;

	[Range(0.5f, 2f)]
	[Tooltip("Min RenderScale the app can reach under adaptive resolution mode")]
	public float minRenderScale = 0.7f;

	[Range(0.5f, 2f)]
	[Tooltip("Max RenderScale the app can reach under adaptive resolution mode")]
	public float maxRenderScale = 1f;

	[Header("Tracking")]
	[SerializeField]
	[Tooltip("Defines the current tracking origin type.")]
	private TrackingOrigin _trackingOriginType;

	[Tooltip("If true, head tracking will affect the position of each OVRCameraRig's cameras.")]
	public bool usePositionTracking = true;

	[HideInInspector]
	public bool useRotationTracking = true;

	[Tooltip("If true, the distance between the user's eyes will affect the position of each OVRCameraRig's cameras.")]
	public bool useIPDInPositionTracking = true;

	[Tooltip("If true, each scene load will cause the head pose to reset.")]
	public bool resetTrackerOnLoad;

	[Tooltip("If true, the Reset View in the universal menu will cause the pose to be reset. This should generally be enabled for applications with a stationary position in the virtual world and will allow the View Reset command to place the person back to a predefined location (such as a cockpit seat). Set this to false if you have a locomotion system because resetting the view would effectively teleport the player to potentially invalid locations.")]
	public bool AllowRecenter = true;

	[SerializeField]
	[Tooltip("Specifies HMD recentering behavior when controller recenter is performed. True recenters the HMD as well, false does not.")]
	private bool _reorientHMDOnControllerRecenter = true;

	private static bool _isUserPresentCached = false;

	private static bool _isUserPresent = false;

	private static bool _wasUserPresent = false;

	private static bool prevAudioOutIdIsCached = false;

	private static bool prevAudioInIdIsCached = false;

	private static string prevAudioOutId = string.Empty;

	private static string prevAudioInId = string.Empty;

	private static bool wasPositionTracked = false;

	internal static string UnityAlphaOrBetaVersionWarningMessage = "WARNING: It's not recommended to use Unity alpha/beta release in Oculus development. Use a stable release if you encounter any issue.";

	private bool multipleMainCameraWarningPresented;

	public static OVRManager instance { get; private set; }

	public static OVRDisplay display { get; private set; }

	public static OVRTracker tracker { get; private set; }

	public static OVRBoundary boundary { get; private set; }

	public static OVRProfile profile
	{
		get
		{
			if (_profile == null)
			{
				_profile = new OVRProfile();
			}
			return _profile;
		}
	}

	public static bool isHmdPresent
	{
		get
		{
			if (!_isHmdPresentCached)
			{
				_isHmdPresentCached = true;
				_isHmdPresent = OVRPlugin.hmdPresent;
			}
			return _isHmdPresent;
		}
		private set
		{
			_isHmdPresentCached = true;
			_isHmdPresent = value;
		}
	}

	public static string audioOutId => OVRPlugin.audioOutId;

	public static string audioInId => OVRPlugin.audioInId;

	public static bool hasVrFocus
	{
		get
		{
			if (!_hasVrFocusCached)
			{
				_hasVrFocusCached = true;
				_hasVrFocus = OVRPlugin.hasVrFocus;
			}
			return _hasVrFocus;
		}
		private set
		{
			_hasVrFocusCached = true;
			_hasVrFocus = value;
		}
	}

	public static bool hasInputFocus => OVRPlugin.hasInputFocus;

	public bool chromatic
	{
		get
		{
			if (!isHmdPresent)
			{
				return false;
			}
			return OVRPlugin.chromatic;
		}
		set
		{
			if (isHmdPresent)
			{
				OVRPlugin.chromatic = value;
			}
		}
	}

	public bool monoscopic
	{
		get
		{
			if (!isHmdPresent)
			{
				return _monoscopic;
			}
			return OVRPlugin.monoscopic;
		}
		set
		{
			if (isHmdPresent)
			{
				OVRPlugin.monoscopic = value;
				_monoscopic = value;
			}
		}
	}

	public int vsyncCount
	{
		get
		{
			if (!isHmdPresent)
			{
				return 1;
			}
			return OVRPlugin.vsyncCount;
		}
		set
		{
			if (isHmdPresent)
			{
				OVRPlugin.vsyncCount = value;
			}
		}
	}

	public static float batteryLevel
	{
		get
		{
			if (!isHmdPresent)
			{
				return 1f;
			}
			return OVRPlugin.batteryLevel;
		}
	}

	public static float batteryTemperature
	{
		get
		{
			if (!isHmdPresent)
			{
				return 0f;
			}
			return OVRPlugin.batteryTemperature;
		}
	}

	public static int batteryStatus
	{
		get
		{
			if (!isHmdPresent)
			{
				return -1;
			}
			return (int)OVRPlugin.batteryStatus;
		}
	}

	public static float volumeLevel
	{
		get
		{
			if (!isHmdPresent)
			{
				return 0f;
			}
			return OVRPlugin.systemVolume;
		}
	}

	public static int cpuLevel
	{
		get
		{
			if (!isHmdPresent)
			{
				return 2;
			}
			return OVRPlugin.cpuLevel;
		}
		set
		{
			if (isHmdPresent)
			{
				OVRPlugin.cpuLevel = value;
			}
		}
	}

	public static int gpuLevel
	{
		get
		{
			if (!isHmdPresent)
			{
				return 2;
			}
			return OVRPlugin.gpuLevel;
		}
		set
		{
			if (isHmdPresent)
			{
				OVRPlugin.gpuLevel = value;
			}
		}
	}

	public static bool isPowerSavingActive
	{
		get
		{
			if (!isHmdPresent)
			{
				return false;
			}
			return OVRPlugin.powerSaving;
		}
	}

	public static EyeTextureFormat eyeTextureFormat
	{
		get
		{
			return (EyeTextureFormat)OVRPlugin.GetDesiredEyeTextureFormat();
		}
		set
		{
			OVRPlugin.SetDesiredEyeTextureFormat((OVRPlugin.EyeTextureFormat)value);
		}
	}

	public static bool tiledMultiResSupported => OVRPlugin.tiledMultiResSupported;

	public static TiledMultiResLevel tiledMultiResLevel
	{
		get
		{
			if (!OVRPlugin.tiledMultiResSupported)
			{
				UnityEngine.Debug.LogWarning("Tiled-based Multi-resolution feature is not supported");
			}
			return (TiledMultiResLevel)OVRPlugin.tiledMultiResLevel;
		}
		set
		{
			if (!OVRPlugin.tiledMultiResSupported)
			{
				UnityEngine.Debug.LogWarning("Tiled-based Multi-resolution feature is not supported");
			}
			OVRPlugin.tiledMultiResLevel = (OVRPlugin.TiledMultiResLevel)value;
		}
	}

	public static bool gpuUtilSupported => OVRPlugin.gpuUtilSupported;

	public static float gpuUtilLevel
	{
		get
		{
			if (!OVRPlugin.gpuUtilSupported)
			{
				UnityEngine.Debug.LogWarning("GPU Util is not supported");
			}
			return OVRPlugin.gpuUtilLevel;
		}
	}

	public TrackingOrigin trackingOriginType
	{
		get
		{
			if (!isHmdPresent)
			{
				return _trackingOriginType;
			}
			return (TrackingOrigin)OVRPlugin.GetTrackingOriginType();
		}
		set
		{
			if (isHmdPresent && OVRPlugin.SetTrackingOriginType((OVRPlugin.TrackingOrigin)value))
			{
				_trackingOriginType = value;
			}
		}
	}

	public bool reorientHMDOnControllerRecenter
	{
		get
		{
			if (!isHmdPresent)
			{
				return false;
			}
			return OVRPlugin.GetReorientHMDOnControllerRecenter();
		}
		set
		{
			if (isHmdPresent)
			{
				OVRPlugin.SetReorientHMDOnControllerRecenter(value);
			}
		}
	}

	public bool isSupportedPlatform { get; private set; }

	public bool isUserPresent
	{
		get
		{
			if (!_isUserPresentCached)
			{
				_isUserPresentCached = true;
				_isUserPresent = OVRPlugin.userPresent;
			}
			return _isUserPresent;
		}
		private set
		{
			_isUserPresentCached = true;
			_isUserPresent = value;
		}
	}

	public static Version utilitiesVersion => OVRPlugin.wrapperVersion;

	public static Version pluginVersion => OVRPlugin.version;

	public static Version sdkVersion => OVRPlugin.nativeSDKVersion;

	public static event Action HMDAcquired;

	public static event Action HMDLost;

	public static event Action HMDMounted;

	public static event Action HMDUnmounted;

	public static event Action VrFocusAcquired;

	public static event Action VrFocusLost;

	public static event Action InputFocusAcquired;

	public static event Action InputFocusLost;

	public static event Action AudioOutChanged;

	public static event Action AudioInChanged;

	public static event Action TrackingAcquired;

	public static event Action TrackingLost;

	[Obsolete]
	public static event Action HSWDismissed;

	public static bool IsAdaptiveResSupportedByEngine()
	{
		return UnityEngine.Application.unityVersion != "2017.1.0f1";
	}

	internal static bool IsUnityAlphaOrBetaVersion()
	{
		string unityVersion = UnityEngine.Application.unityVersion;
		int num = unityVersion.Length - 1;
		while (num >= 0 && unityVersion[num] >= '0' && unityVersion[num] <= '9')
		{
			num--;
		}
		if (num >= 0 && (unityVersion[num] == 'a' || unityVersion[num] == 'b'))
		{
			return true;
		}
		return false;
	}

	private void Awake()
	{
		if (instance != null)
		{
			base.enabled = false;
			UnityEngine.Object.DestroyImmediate(this);
			return;
		}
		instance = this;
		UnityEngine.Debug.Log(string.Concat("Unity v", UnityEngine.Application.unityVersion, ", Oculus Utilities v", OVRPlugin.wrapperVersion, ", OVRPlugin v", OVRPlugin.version, ", SDK v", OVRPlugin.nativeSDKVersion, "."));
		if (IsUnityAlphaOrBetaVersion())
		{
			UnityEngine.Debug.LogWarning(UnityAlphaOrBetaVersionWarningMessage);
		}
		RuntimePlatform platform = UnityEngine.Application.platform;
		if (platform == RuntimePlatform.Android || platform == RuntimePlatform.OSXEditor || platform == RuntimePlatform.OSXPlayer || platform == RuntimePlatform.WindowsEditor || platform == RuntimePlatform.WindowsPlayer)
		{
			isSupportedPlatform = true;
		}
		else
		{
			isSupportedPlatform = false;
		}
		if (!isSupportedPlatform)
		{
			UnityEngine.Debug.LogWarning("This platform is unsupported");
			return;
		}
		chromatic = false;
		Initialize();
		if (resetTrackerOnLoad)
		{
			display.RecenterPose();
		}
	}

	private void Initialize()
	{
		if (display == null)
		{
			display = new OVRDisplay();
		}
		if (tracker == null)
		{
			tracker = new OVRTracker();
		}
		if (boundary == null)
		{
			boundary = new OVRBoundary();
		}
		reorientHMDOnControllerRecenter = _reorientHMDOnControllerRecenter;
	}

	private void Update()
	{
		if (OVRPlugin.shouldQuit)
		{
			UnityEngine.Application.Quit();
		}
		if (AllowRecenter && OVRPlugin.shouldRecenter)
		{
			display.RecenterPose();
		}
		if (trackingOriginType != _trackingOriginType)
		{
			trackingOriginType = _trackingOriginType;
		}
		tracker.isEnabled = usePositionTracking;
		OVRPlugin.rotation = useRotationTracking;
		OVRPlugin.useIPDInPositionTracking = useIPDInPositionTracking;
		isHmdPresent = OVRPlugin.hmdPresent;
		if (useRecommendedMSAALevel && QualitySettings.antiAliasing != display.recommendedMSAALevel)
		{
			UnityEngine.Debug.Log("The current MSAA level is " + QualitySettings.antiAliasing + ", but the recommended MSAA level is " + display.recommendedMSAALevel + ". Switching to the recommended level.");
			QualitySettings.antiAliasing = display.recommendedMSAALevel;
		}
		if (monoscopic != _monoscopic)
		{
			monoscopic = _monoscopic;
		}
		if (_wasHmdPresent && !isHmdPresent)
		{
			try
			{
				if (OVRManager.HMDLost != null)
				{
					OVRManager.HMDLost();
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex);
			}
		}
		if (!_wasHmdPresent && isHmdPresent)
		{
			try
			{
				if (OVRManager.HMDAcquired != null)
				{
					OVRManager.HMDAcquired();
				}
			}
			catch (Exception ex2)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex2);
			}
		}
		_wasHmdPresent = isHmdPresent;
		isUserPresent = OVRPlugin.userPresent;
		if (_wasUserPresent && !isUserPresent)
		{
			try
			{
				if (OVRManager.HMDUnmounted != null)
				{
					OVRManager.HMDUnmounted();
				}
			}
			catch (Exception ex3)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex3);
			}
		}
		if (!_wasUserPresent && isUserPresent)
		{
			try
			{
				if (OVRManager.HMDMounted != null)
				{
					OVRManager.HMDMounted();
				}
			}
			catch (Exception ex4)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex4);
			}
		}
		_wasUserPresent = isUserPresent;
		hasVrFocus = OVRPlugin.hasVrFocus;
		if (_hadVrFocus && !hasVrFocus)
		{
			try
			{
				if (OVRManager.VrFocusLost != null)
				{
					OVRManager.VrFocusLost();
				}
			}
			catch (Exception ex5)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex5);
			}
		}
		if (!_hadVrFocus && hasVrFocus)
		{
			try
			{
				if (OVRManager.VrFocusAcquired != null)
				{
					OVRManager.VrFocusAcquired();
				}
			}
			catch (Exception ex6)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex6);
			}
		}
		_hadVrFocus = hasVrFocus;
		bool flag = OVRPlugin.hasInputFocus;
		if (_hadInputFocus && !flag)
		{
			try
			{
				if (OVRManager.InputFocusLost != null)
				{
					OVRManager.InputFocusLost();
				}
			}
			catch (Exception ex7)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex7);
			}
		}
		if (!_hadInputFocus && flag)
		{
			try
			{
				if (OVRManager.InputFocusAcquired != null)
				{
					OVRManager.InputFocusAcquired();
				}
			}
			catch (Exception ex8)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex8);
			}
		}
		_hadInputFocus = flag;
		string text = OVRPlugin.audioOutId;
		if (!prevAudioOutIdIsCached)
		{
			prevAudioOutId = text;
			prevAudioOutIdIsCached = true;
		}
		else if (text != prevAudioOutId)
		{
			try
			{
				if (OVRManager.AudioOutChanged != null)
				{
					OVRManager.AudioOutChanged();
				}
			}
			catch (Exception ex9)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex9);
			}
			prevAudioOutId = text;
		}
		string text2 = OVRPlugin.audioInId;
		if (!prevAudioInIdIsCached)
		{
			prevAudioInId = text2;
			prevAudioInIdIsCached = true;
		}
		else if (text2 != prevAudioInId)
		{
			try
			{
				if (OVRManager.AudioInChanged != null)
				{
					OVRManager.AudioInChanged();
				}
			}
			catch (Exception ex10)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex10);
			}
			prevAudioInId = text2;
		}
		if (wasPositionTracked && !tracker.isPositionTracked)
		{
			try
			{
				if (OVRManager.TrackingLost != null)
				{
					OVRManager.TrackingLost();
				}
			}
			catch (Exception ex11)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex11);
			}
		}
		if (!wasPositionTracked && tracker.isPositionTracked)
		{
			try
			{
				if (OVRManager.TrackingAcquired != null)
				{
					OVRManager.TrackingAcquired();
				}
			}
			catch (Exception ex12)
			{
				UnityEngine.Debug.LogError("Caught Exception: " + ex12);
			}
		}
		wasPositionTracked = tracker.isPositionTracked;
		display.Update();
		OVRInput.Update();
	}

	private Camera FindMainCamera()
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag("MainCamera");
		List<Camera> list = new List<Camera>(4);
		GameObject[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			Camera component = array2[i].GetComponent<Camera>();
			if (component != null && component.enabled)
			{
				OVRCameraRig componentInParent = component.GetComponentInParent<OVRCameraRig>();
				if (componentInParent != null && componentInParent.trackingSpace != null)
				{
					list.Add(component);
				}
			}
		}
		if (list.Count == 0)
		{
			return Camera.main;
		}
		if (list.Count == 1)
		{
			return list[0];
		}
		if (!multipleMainCameraWarningPresented)
		{
			UnityEngine.Debug.LogWarning("Multiple MainCamera found. Assume the real MainCamera is the camera with the least depth");
			multipleMainCameraWarningPresented = true;
		}
		list.Sort((Camera c0, Camera c1) => (!(c0.depth < c1.depth)) ? ((c0.depth > c1.depth) ? 1 : 0) : (-1));
		return list[0];
	}

	private void OnDisable()
	{
	}

	private void LateUpdate()
	{
		OVRHaptics.Process();
	}

	private void FixedUpdate()
	{
		OVRInput.FixedUpdate();
	}

	public void ReturnToLauncher()
	{
		PlatformUIConfirmQuit();
	}

	public static void PlatformUIConfirmQuit()
	{
		if (isHmdPresent)
		{
			OVRPlugin.ShowUI(OVRPlugin.PlatformUI.ConfirmQuit);
		}
	}
}
public abstract class OVROnCompleteListener : AndroidJavaProxy
{
	public OVROnCompleteListener()
		: base("com.oculus.svclib.OnCompleteListener")
	{
	}

	public abstract void onSuccess();

	public abstract void onFailure();
}
public class OVROverlay : MonoBehaviour
{
	public enum OverlayShape
	{
		Quad = 0,
		Cylinder = 1,
		Cubemap = 2,
		OffcenterCubemap = 4,
		Equirect = 5
	}

	public enum OverlayType
	{
		None,
		Underlay,
		Overlay
	}

	private struct LayerTexture
	{
		public Texture appTexture;

		public IntPtr appTexturePtr;

		public Texture[] swapChain;

		public IntPtr[] swapChainPtr;
	}

	[Tooltip("Specify overlay's type")]
	public OverlayType currentOverlayType = OverlayType.Overlay;

	[Tooltip("If true, the texture's content is copied to the compositor each frame.")]
	public bool isDynamic;

	[Tooltip("If true, the layer would be used to present protected content (e.g. HDCP). The flag is effective only on PC.")]
	public bool isProtectedContent;

	[Tooltip("The compositionDepth defines the order of the OVROverlays in composition. The overlay/underlay with smaller compositionDepth would be composited in the front of the overlay/underlay with larger compositionDepth.")]
	public int compositionDepth;

	[Tooltip("Specify overlay's shape")]
	public OverlayShape currentOverlayShape;

	private OverlayShape prevOverlayShape;

	[Tooltip("The left- and right-eye Textures to show in the layer.")]
	public Texture[] textures = new Texture[2];

	protected IntPtr[] texturePtrs = new IntPtr[2]
	{
		IntPtr.Zero,
		IntPtr.Zero
	};

	protected bool isOverridePending;

	internal const int maxInstances = 15;

	internal static OVROverlay[] instances = new OVROverlay[15];

	private static Material tex2DMaterial;

	private static Material cubeMaterial;

	private LayerTexture[] layerTextures;

	private OVRPlugin.LayerDesc layerDesc;

	private int stageCount = -1;

	private int layerIndex = -1;

	private int layerId;

	private GCHandle layerIdHandle;

	private IntPtr layerIdPtr = IntPtr.Zero;

	private int frameIndex;

	private int prevFrameIndex = -1;

	private Renderer rend;

	private OVRPlugin.LayerLayout layout
	{
		get
		{
			if (textures.Length == 2 && textures[1] != null)
			{
				return OVRPlugin.LayerLayout.Stereo;
			}
			return OVRPlugin.LayerLayout.Mono;
		}
	}

	private int texturesPerStage
	{
		get
		{
			if (layout != 0)
			{
				return 1;
			}
			return 2;
		}
	}

	public void OverrideOverlayTextureInfo(Texture srcTexture, IntPtr nativePtr, XRNode node)
	{
		int num = ((node == XRNode.RightEye) ? 1 : 0);
		if (textures.Length > num)
		{
			textures[num] = srcTexture;
			texturePtrs[num] = nativePtr;
			isOverridePending = true;
		}
	}

	private bool CreateLayer(int mipLevels, int sampleCount, OVRPlugin.EyeTextureFormat etFormat, int flags, OVRPlugin.Sizei size, OVRPlugin.OverlayShape shape)
	{
		if (!layerIdHandle.IsAllocated || layerIdPtr == IntPtr.Zero)
		{
			layerIdHandle = GCHandle.Alloc(layerId, GCHandleType.Pinned);
			layerIdPtr = layerIdHandle.AddrOfPinnedObject();
		}
		if (layerIndex == -1)
		{
			for (int i = 0; i < 15; i++)
			{
				if (instances[i] == null || instances[i] == this)
				{
					layerIndex = i;
					instances[i] = this;
					break;
				}
			}
		}
		if (!isOverridePending && layerDesc.MipLevels == mipLevels && layerDesc.SampleCount == sampleCount && layerDesc.Format == etFormat && layerDesc.Layout == layout && layerDesc.LayerFlags == flags && layerDesc.TextureSize.Equals(size) && layerDesc.Shape == shape)
		{
			return false;
		}
		OVRPlugin.LayerDesc desc = OVRPlugin.CalculateLayerDesc(shape, layout, size, mipLevels, sampleCount, etFormat, flags);
		OVRPlugin.EnqueueSetupLayer(desc, compositionDepth, layerIdPtr);
		layerId = (int)layerIdHandle.Target;
		if (layerId > 0)
		{
			layerDesc = desc;
			stageCount = OVRPlugin.GetLayerTextureStageCount(layerId);
		}
		isOverridePending = false;
		return true;
	}

	private bool CreateLayerTextures(bool useMipmaps, OVRPlugin.Sizei size, bool isHdr)
	{
		bool result = false;
		if (stageCount <= 0)
		{
			return false;
		}
		if (layerTextures == null)
		{
			layerTextures = new LayerTexture[texturesPerStage];
		}
		for (int i = 0; i < texturesPerStage; i++)
		{
			if (layerTextures[i].swapChain == null)
			{
				layerTextures[i].swapChain = new Texture[stageCount];
			}
			if (layerTextures[i].swapChainPtr == null)
			{
				layerTextures[i].swapChainPtr = new IntPtr[stageCount];
			}
			for (int j = 0; j < stageCount; j++)
			{
				Texture texture = layerTextures[i].swapChain[j];
				IntPtr intPtr = layerTextures[i].swapChainPtr[j];
				if (!(texture != null) || !(intPtr != IntPtr.Zero))
				{
					if (intPtr == IntPtr.Zero)
					{
						intPtr = OVRPlugin.GetLayerTexture(layerId, j, (OVRPlugin.Eye)i);
					}
					if (!(intPtr == IntPtr.Zero))
					{
						TextureFormat format = (isHdr ? TextureFormat.RGBAHalf : TextureFormat.RGBA32);
						texture = ((currentOverlayShape == OverlayShape.Cubemap || currentOverlayShape == OverlayShape.OffcenterCubemap) ? ((Texture)Cubemap.CreateExternalTexture(size.w, format, useMipmaps, intPtr)) : ((Texture)Texture2D.CreateExternalTexture(size.w, size.h, format, useMipmaps, linear: true, intPtr)));
						layerTextures[i].swapChain[j] = texture;
						layerTextures[i].swapChainPtr[j] = intPtr;
						result = true;
					}
				}
			}
		}
		return result;
	}

	private void DestroyLayerTextures()
	{
		int num = 0;
		while (layerTextures != null && num < texturesPerStage)
		{
			if (layerTextures[num].swapChain != null)
			{
				for (int i = 0; i < stageCount; i++)
				{
					UnityEngine.Object.DestroyImmediate(layerTextures[num].swapChain[i]);
				}
			}
			num++;
		}
		layerTextures = null;
	}

	private void DestroyLayer()
	{
		if (layerIndex != -1)
		{
			OVRPlugin.EnqueueSubmitLayer(onTop: true, headLocked: false, IntPtr.Zero, IntPtr.Zero, -1, 0, OVRPose.identity.ToPosef(), Vector3.one.ToVector3f(), layerIndex, (OVRPlugin.OverlayShape)prevOverlayShape);
			instances[layerIndex] = null;
			layerIndex = -1;
		}
		if (layerIdPtr != IntPtr.Zero)
		{
			OVRPlugin.EnqueueDestroyLayer(layerIdPtr);
			layerIdPtr = IntPtr.Zero;
			layerIdHandle.Free();
			layerId = 0;
		}
		layerDesc = default(OVRPlugin.LayerDesc);
		frameIndex = 0;
		prevFrameIndex = -1;
	}

	private bool LatchLayerTextures()
	{
		for (int i = 0; i < texturesPerStage; i++)
		{
			if ((textures[i] != layerTextures[i].appTexture || layerTextures[i].appTexturePtr == IntPtr.Zero) && textures[i] != null)
			{
				RenderTexture renderTexture = textures[i] as RenderTexture;
				if ((bool)renderTexture && !renderTexture.IsCreated())
				{
					renderTexture.Create();
				}
				layerTextures[i].appTexturePtr = ((texturePtrs[i] != IntPtr.Zero) ? texturePtrs[i] : textures[i].GetNativeTexturePtr());
				if (layerTextures[i].appTexturePtr != IntPtr.Zero)
				{
					layerTextures[i].appTexture = textures[i];
				}
			}
			if (currentOverlayShape == OverlayShape.Cubemap && textures[i] as Cubemap == null)
			{
				UnityEngine.Debug.LogError("Need Cubemap texture for cube map overlay");
				return false;
			}
		}
		if (layerTextures[0].appTexture == null || layerTextures[0].appTexturePtr == IntPtr.Zero)
		{
			return false;
		}
		return true;
	}

	private OVRPlugin.LayerDesc GetCurrentLayerDesc()
	{
		OVRPlugin.LayerDesc layerDesc = default(OVRPlugin.LayerDesc);
		layerDesc.Format = OVRPlugin.EyeTextureFormat.Default;
		layerDesc.LayerFlags = 8;
		layerDesc.Layout = layout;
		layerDesc.MipLevels = 1;
		layerDesc.SampleCount = 1;
		layerDesc.Shape = (OVRPlugin.OverlayShape)currentOverlayShape;
		layerDesc.TextureSize = new OVRPlugin.Sizei
		{
			w = textures[0].width,
			h = textures[0].height
		};
		OVRPlugin.LayerDesc result = layerDesc;
		Texture2D texture2D = textures[0] as Texture2D;
		if (texture2D != null)
		{
			if (texture2D.format == TextureFormat.RGBAHalf || texture2D.format == TextureFormat.RGBAFloat)
			{
				result.Format = OVRPlugin.EyeTextureFormat.R16G16B16A16_FP;
			}
			result.MipLevels = texture2D.mipmapCount;
		}
		Cubemap cubemap = textures[0] as Cubemap;
		if (cubemap != null)
		{
			if (cubemap.format == TextureFormat.RGBAHalf || cubemap.format == TextureFormat.RGBAFloat)
			{
				result.Format = OVRPlugin.EyeTextureFormat.R16G16B16A16_FP;
			}
			result.MipLevels = cubemap.mipmapCount;
		}
		RenderTexture renderTexture = textures[0] as RenderTexture;
		if (renderTexture != null)
		{
			result.SampleCount = renderTexture.antiAliasing;
			if (renderTexture.format == RenderTextureFormat.ARGBHalf || renderTexture.format == RenderTextureFormat.ARGBFloat || renderTexture.format == RenderTextureFormat.RGB111110Float)
			{
				result.Format = OVRPlugin.EyeTextureFormat.R16G16B16A16_FP;
			}
		}
		if (isProtectedContent)
		{
			result.LayerFlags |= 64;
		}
		return result;
	}

	private bool PopulateLayer(int mipLevels, bool isHdr, OVRPlugin.Sizei size, int sampleCount, int stage)
	{
		bool result = false;
		RenderTextureFormat colorFormat = (isHdr ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.ARGB32);
		for (int i = 0; i < texturesPerStage; i++)
		{
			Texture texture = layerTextures[i].swapChain[stage];
			if (texture == null)
			{
				continue;
			}
			for (int j = 0; j < mipLevels; j++)
			{
				int num = size.w >> j;
				if (num < 1)
				{
					num = 1;
				}
				int num2 = size.h >> j;
				if (num2 < 1)
				{
					num2 = 1;
				}
				RenderTextureDescriptor desc = new RenderTextureDescriptor(num, num2, colorFormat, 0);
				desc.msaaSamples = sampleCount;
				desc.useMipMap = true;
				desc.autoGenerateMips = false;
				desc.sRGB = false;
				RenderTexture temporary = RenderTexture.GetTemporary(desc);
				if (!temporary.IsCreated())
				{
					temporary.Create();
				}
				temporary.DiscardContents();
				bool flag = isHdr || QualitySettings.activeColorSpace == ColorSpace.Linear;
				flag = true;
				if (currentOverlayShape != OverlayShape.Cubemap && currentOverlayShape != OverlayShape.OffcenterCubemap)
				{
					tex2DMaterial.SetInt("_linearToSrgb", (!isHdr && flag) ? 1 : 0);
					Graphics.Blit(textures[i], temporary, tex2DMaterial);
					Graphics.CopyTexture(temporary, 0, 0, texture, 0, j);
				}
				else
				{
					for (int k = 0; k < 6; k++)
					{
						cubeMaterial.SetInt("_linearToSrgb", (!isHdr && flag) ? 1 : 0);
						cubeMaterial.SetInt("_face", k);
						Graphics.Blit(textures[i], temporary, cubeMaterial);
						Graphics.CopyTexture(temporary, 0, 0, texture, k, j);
					}
				}
				RenderTexture.ReleaseTemporary(temporary);
				result = true;
			}
		}
		return result;
	}

	private bool SubmitLayer(bool overlay, bool headLocked, OVRPose pose, Vector3 scale, int frameIndex)
	{
		int num = ((texturesPerStage >= 2) ? 1 : 0);
		bool result = OVRPlugin.EnqueueSubmitLayer(overlay, headLocked, layerTextures[0].appTexturePtr, layerTextures[num].appTexturePtr, layerId, frameIndex, pose.flipZ().ToPosef(), scale.ToVector3f(), layerIndex, (OVRPlugin.OverlayShape)currentOverlayShape);
		prevOverlayShape = currentOverlayShape;
		return result;
	}

	private void Awake()
	{
		UnityEngine.Debug.Log("Overlay Awake");
		if (tex2DMaterial == null)
		{
			tex2DMaterial = new Material(Shader.Find("Oculus/Texture2D Blit"));
		}
		if (cubeMaterial == null)
		{
			cubeMaterial = new Material(Shader.Find("Oculus/Cubemap Blit"));
		}
		rend = GetComponent<Renderer>();
		if (textures.Length == 0)
		{
			textures = new Texture[1];
		}
		if (rend != null && textures[0] == null)
		{
			textures[0] = rend.material.mainTexture;
		}
	}

	private void OnEnable()
	{
		if (!OVRManager.isHmdPresent)
		{
			base.enabled = false;
		}
	}

	private void OnDisable()
	{
		if ((base.gameObject.hideFlags & HideFlags.DontSaveInBuild) == 0)
		{
			DestroyLayerTextures();
			DestroyLayer();
		}
	}

	private void OnDestroy()
	{
		DestroyLayerTextures();
		DestroyLayer();
	}

	private bool ComputeSubmit(ref OVRPose pose, ref Vector3 scale, ref bool overlay, ref bool headLocked)
	{
		Camera main = Camera.main;
		overlay = currentOverlayType == OverlayType.Overlay;
		headLocked = false;
		Transform parent = base.transform;
		while (parent != null && !headLocked)
		{
			headLocked |= parent == main.transform;
			parent = parent.parent;
		}
		pose = (headLocked ? base.transform.ToHeadSpacePose(main) : base.transform.ToTrackingSpacePose(main));
		scale = base.transform.lossyScale;
		for (int i = 0; i < 3; i++)
		{
			scale[i] /= main.transform.lossyScale[i];
		}
		if (currentOverlayShape == OverlayShape.Cubemap)
		{
			pose.orientation *= Quaternion.AngleAxis(180f, Vector3.up);
			pose.position = main.transform.position;
		}
		if (currentOverlayShape == OverlayShape.OffcenterCubemap)
		{
			pose.position = base.transform.position;
			if (pose.position.magnitude > 1f)
			{
				UnityEngine.Debug.LogWarning("Your cube map center offset's magnitude is greater than 1, which will cause some cube map pixel always invisible .");
				return false;
			}
		}
		if (currentOverlayShape == OverlayShape.Cylinder)
		{
			float num = scale.x / scale.z / (float)Math.PI * 180f;
			if (num > 180f)
			{
				UnityEngine.Debug.LogWarning("Cylinder overlay's arc angle has to be below 180 degree, current arc angle is " + num + " degree.");
				return false;
			}
		}
		return true;
	}

	private void LateUpdate()
	{
		if (currentOverlayType == OverlayType.None || textures.Length < texturesPerStage || textures[0] == null)
		{
			return;
		}
		OVRPose pose = OVRPose.identity;
		Vector3 scale = Vector3.one;
		bool overlay = false;
		bool headLocked = false;
		if (!ComputeSubmit(ref pose, ref scale, ref overlay, ref headLocked))
		{
			return;
		}
		OVRPlugin.LayerDesc currentLayerDesc = GetCurrentLayerDesc();
		bool isHdr = currentLayerDesc.Format == OVRPlugin.EyeTextureFormat.R16G16B16A16_FP;
		bool flag = CreateLayer(currentLayerDesc.MipLevels, currentLayerDesc.SampleCount, currentLayerDesc.Format, currentLayerDesc.LayerFlags, currentLayerDesc.TextureSize, currentLayerDesc.Shape);
		if (layerIndex == -1 || layerId <= 0)
		{
			return;
		}
		bool useMipmaps = currentLayerDesc.MipLevels > 1;
		flag |= CreateLayerTextures(useMipmaps, currentLayerDesc.TextureSize, isHdr);
		if (layerTextures[0].appTexture as RenderTexture != null)
		{
			isDynamic = true;
		}
		if (!LatchLayerTextures())
		{
			return;
		}
		if (frameIndex > prevFrameIndex)
		{
			int stage = frameIndex % stageCount;
			if (!PopulateLayer(currentLayerDesc.MipLevels, isHdr, currentLayerDesc.TextureSize, currentLayerDesc.SampleCount, stage))
			{
				return;
			}
		}
		bool flag2 = SubmitLayer(overlay, headLocked, pose, scale, frameIndex);
		prevFrameIndex = frameIndex;
		if (isDynamic)
		{
			frameIndex++;
		}
		if ((bool)rend)
		{
			rend.enabled = !flag2;
		}
	}
}
public class OVRPlatformMenu : MonoBehaviour
{
	public enum eHandler
	{
		ShowConfirmQuit,
		RetreatOneLevel
	}

	private enum eBackButtonAction
	{
		NONE,
		SHORT_PRESS
	}

	private OVRInput.RawButton inputCode = OVRInput.RawButton.Back;

	public eHandler shortPressHandler;

	public Func<bool> OnShortPress;

	private static Stack<string> sceneStack = new Stack<string>();

	private eBackButtonAction HandleBackButtonState()
	{
		eBackButtonAction result = eBackButtonAction.NONE;
		if (OVRInput.GetDown(inputCode))
		{
			result = eBackButtonAction.SHORT_PRESS;
		}
		return result;
	}

	private void Awake()
	{
		if (shortPressHandler == eHandler.RetreatOneLevel && OnShortPress == null)
		{
			OnShortPress = RetreatOneLevel;
		}
		if (!OVRManager.isHmdPresent)
		{
			base.enabled = false;
		}
		else
		{
			sceneStack.Push(SceneManager.GetActiveScene().name);
		}
	}

	private void ShowConfirmQuitMenu()
	{
		UnityEngine.Debug.Log("[PlatformUI-ConfirmQuit] Showing @ " + Time.time);
		OVRManager.PlatformUIConfirmQuit();
	}

	private static bool RetreatOneLevel()
	{
		if (sceneStack.Count > 1)
		{
			SceneManager.LoadSceneAsync(sceneStack.Pop());
			return false;
		}
		return true;
	}

	private void Update()
	{
		if (HandleBackButtonState() == eBackButtonAction.SHORT_PRESS && (OnShortPress == null || OnShortPress()))
		{
			ShowConfirmQuitMenu();
		}
	}
}
public static class OVRPlugin
{
	[StructLayout(LayoutKind.Sequential)]
	private class GUID
	{
		public int a;

		public short b;

		public short c;

		public byte d0;

		public byte d1;

		public byte d2;

		public byte d3;

		public byte d4;

		public byte d5;

		public byte d6;

		public byte d7;
	}

	public enum Bool
	{
		False,
		True
	}

	public enum Result
	{
		Success = 0,
		Failure = -1000,
		Failure_InvalidParameter = -1001,
		Failure_NotInitialized = -1002,
		Failure_InvalidOperation = -1003,
		Failure_Unsupported = -1004,
		Failure_NotYetImplemented = -1005,
		Failure_OperationFailed = -1006,
		Failure_InsufficientSize = -1007
	}

	public enum CameraStatus
	{
		CameraStatus_None = 0,
		CameraStatus_Connected = 1,
		CameraStatus_Calibrating = 2,
		CameraStatus_CalibrationFailed = 3,
		CameraStatus_Calibrated = 4,
		CameraStatus_EnumSize = int.MaxValue
	}

	public enum Eye
	{
		None = -1,
		Left,
		Right,
		Count
	}

	public enum Tracker
	{
		None = -1,
		Zero,
		One,
		Two,
		Three,
		Count
	}

	public enum Node
	{
		None = -1,
		EyeLeft,
		EyeRight,
		EyeCenter,
		HandLeft,
		HandRight,
		TrackerZero,
		TrackerOne,
		TrackerTwo,
		TrackerThree,
		Head,
		DeviceObjectZero,
		Count
	}

	public enum Controller
	{
		None = 0,
		LTouch = 1,
		RTouch = 2,
		Touch = 3,
		Remote = 4,
		Gamepad = 16,
		Touchpad = 134217728,
		LTrackedRemote = 16777216,
		RTrackedRemote = 33554432,
		Active = int.MinValue,
		All = -1
	}

	public enum Handedness
	{
		Unsupported,
		LeftHanded,
		RightHanded
	}

	public enum TrackingOrigin
	{
		EyeLevel,
		FloorLevel,
		Count
	}

	public enum RecenterFlags
	{
		Default = 0,
		Controllers = 1073741824,
		IgnoreAll = int.MinValue,
		Count = -2147483647
	}

	public enum BatteryStatus
	{
		Charging,
		Discharging,
		Full,
		NotCharging,
		Unknown
	}

	public enum EyeTextureFormat
	{
		Default = 0,
		R8G8B8A8_sRGB = 0,
		R8G8B8A8 = 1,
		R16G16B16A16_FP = 2,
		R11G11B10_FP = 3,
		B8G8R8A8_sRGB = 4,
		B8G8R8A8 = 5,
		R5G6B5 = 11,
		EnumSize = int.MaxValue
	}

	public enum PlatformUI
	{
		None = -1,
		ConfirmQuit = 1,
		GlobalMenuTutorial = 2
	}

	public enum SystemRegion
	{
		Unspecified,
		Japan,
		China
	}

	public enum SystemHeadset
	{
		None = 0,
		GearVR_R320 = 1,
		GearVR_R321 = 2,
		GearVR_R322 = 3,
		GearVR_R323 = 4,
		GearVR_R324 = 5,
		GearVR_R325 = 6,
		Oculus_Go = 7,
		Rift_DK1 = 4096,
		Rift_DK2 = 4097,
		Rift_CV1 = 4098
	}

	public enum OverlayShape
	{
		Quad = 0,
		Cylinder = 1,
		Cubemap = 2,
		OffcenterCubemap = 4,
		Equirect = 5
	}

	public enum Step
	{
		Render = -1,
		Physics
	}

	public enum CameraDevice
	{
		None = 0,
		WebCamera0 = 100,
		WebCamera1 = 101,
		ZEDCamera = 300
	}

	public enum CameraDeviceDepthSensingMode
	{
		Standard,
		Fill
	}

	public enum CameraDeviceDepthQuality
	{
		Low,
		Medium,
		High
	}

	public enum TiledMultiResLevel
	{
		Off = 0,
		LMSLow = 1,
		LMSMedium = 2,
		LMSHigh = 3,
		EnumSize = int.MaxValue
	}

	public struct CameraDeviceIntrinsicsParameters
	{
		private float fx;

		private float fy;

		private float cx;

		private float cy;

		private double disto0;

		private double disto1;

		private double disto2;

		private double disto3;

		private double disto4;

		private float v_fov;

		private float h_fov;

		private float d_fov;

		private int w;

		private int h;
	}

	private enum OverlayFlag
	{
		None = 0,
		OnTop = 1,
		HeadLocked = 2,
		ShapeFlag_Quad = 0,
		ShapeFlag_Cylinder = 16,
		ShapeFlag_Cubemap = 32,
		ShapeFlag_OffcenterCubemap = 64,
		ShapeFlagRangeMask = 240
	}

	public struct Vector2f
	{
		public float x;

		public float y;
	}

	public struct Vector3f
	{
		public float x;

		public float y;

		public float z;

		public static readonly Vector3f zero = new Vector3f
		{
			x = 0f,
			y = 0f,
			z = 0f
		};

		public override string ToString()
		{
			return $"{x}, {y}, {z}";
		}
	}

	public struct Quatf
	{
		public float x;

		public float y;

		public float z;

		public float w;

		public static readonly Quatf identity = new Quatf
		{
			x = 0f,
			y = 0f,
			z = 0f,
			w = 1f
		};

		public override string ToString()
		{
			return $"{x}, {y}, {z}, {w}";
		}
	}

	public struct Posef
	{
		public Quatf Orientation;

		public Vector3f Position;

		public static readonly Posef identity = new Posef
		{
			Orientation = Quatf.identity,
			Position = Vector3f.zero
		};

		public override string ToString()
		{
			return $"Position ({Position}), Orientation({Orientation})";
		}
	}

	public struct PoseStatef
	{
		public Posef Pose;

		public Vector3f Velocity;

		public Vector3f Acceleration;

		public Vector3f AngularVelocity;

		public Vector3f AngularAcceleration;

		private double Time;
	}

	public struct ControllerState4
	{
		public uint ConnectedControllers;

		public uint Buttons;

		public uint Touches;

		public uint NearTouches;

		public float LIndexTrigger;

		public float RIndexTrigger;

		public float LHandTrigger;

		public float RHandTrigger;

		public Vector2f LThumbstick;

		public Vector2f RThumbstick;

		public Vector2f LTouchpad;

		public Vector2f RTouchpad;

		public byte LBatteryPercentRemaining;

		public byte RBatteryPercentRemaining;

		public byte LRecenterCount;

		public byte RRecenterCount;

		public byte Reserved_27;

		public byte Reserved_26;

		public byte Reserved_25;

		public byte Reserved_24;

		public byte Reserved_23;

		public byte Reserved_22;

		public byte Reserved_21;

		public byte Reserved_20;

		public byte Reserved_19;

		public byte Reserved_18;

		public byte Reserved_17;

		public byte Reserved_16;

		public byte Reserved_15;

		public byte Reserved_14;

		public byte Reserved_13;

		public byte Reserved_12;

		public byte Reserved_11;

		public byte Reserved_10;

		public byte Reserved_09;

		public byte Reserved_08;

		public byte Reserved_07;

		public byte Reserved_06;

		public byte Reserved_05;

		public byte Reserved_04;

		public byte Reserved_03;

		public byte Reserved_02;

		public byte Reserved_01;

		public byte Reserved_00;

		public ControllerState4(ControllerState2 cs)
		{
			ConnectedControllers = cs.ConnectedControllers;
			Buttons = cs.Buttons;
			Touches = cs.Touches;
			NearTouches = cs.NearTouches;
			LIndexTrigger = cs.LIndexTrigger;
			RIndexTrigger = cs.RIndexTrigger;
			LHandTrigger = cs.LHandTrigger;
			RHandTrigger = cs.RHandTrigger;
			LThumbstick = cs.LThumbstick;
			RThumbstick = cs.RThumbstick;
			LTouchpad = cs.LTouchpad;
			RTouchpad = cs.RTouchpad;
			LBatteryPercentRemaining = 0;
			RBatteryPercentRemaining = 0;
			LRecenterCount = 0;
			RRecenterCount = 0;
			Reserved_27 = 0;
			Reserved_26 = 0;
			Reserved_25 = 0;
			Reserved_24 = 0;
			Reserved_23 = 0;
			Reserved_22 = 0;
			Reserved_21 = 0;
			Reserved_20 = 0;
			Reserved_19 = 0;
			Reserved_18 = 0;
			Reserved_17 = 0;
			Reserved_16 = 0;
			Reserved_15 = 0;
			Reserved_14 = 0;
			Reserved_13 = 0;
			Reserved_12 = 0;
			Reserved_11 = 0;
			Reserved_10 = 0;
			Reserved_09 = 0;
			Reserved_08 = 0;
			Reserved_07 = 0;
			Reserved_06 = 0;
			Reserved_05 = 0;
			Reserved_04 = 0;
			Reserved_03 = 0;
			Reserved_02 = 0;
			Reserved_01 = 0;
			Reserved_00 = 0;
		}
	}

	public struct ControllerState2
	{
		public uint ConnectedControllers;

		public uint Buttons;

		public uint Touches;

		public uint NearTouches;

		public float LIndexTrigger;

		public float RIndexTrigger;

		public float LHandTrigger;

		public float RHandTrigger;

		public Vector2f LThumbstick;

		public Vector2f RThumbstick;

		public Vector2f LTouchpad;

		public Vector2f RTouchpad;

		public ControllerState2(ControllerState cs)
		{
			ConnectedControllers = cs.ConnectedControllers;
			Buttons = cs.Buttons;
			Touches = cs.Touches;
			NearTouches = cs.NearTouches;
			LIndexTrigger = cs.LIndexTrigger;
			RIndexTrigger = cs.RIndexTrigger;
			LHandTrigger = cs.LHandTrigger;
			RHandTrigger = cs.RHandTrigger;
			LThumbstick = cs.LThumbstick;
			RThumbstick = cs.RThumbstick;
			LTouchpad = new Vector2f
			{
				x = 0f,
				y = 0f
			};
			RTouchpad = new Vector2f
			{
				x = 0f,
				y = 0f
			};
		}
	}

	public struct ControllerState
	{
		public uint ConnectedControllers;

		public uint Buttons;

		public uint Touches;

		public uint NearTouches;

		public float LIndexTrigger;

		public float RIndexTrigger;

		public float LHandTrigger;

		public float RHandTrigger;

		public Vector2f LThumbstick;

		public Vector2f RThumbstick;
	}

	public struct HapticsBuffer
	{
		public IntPtr Samples;

		public int SamplesCount;
	}

	public struct HapticsState
	{
		public int SamplesAvailable;

		public int SamplesQueued;
	}

	public struct HapticsDesc
	{
		public int SampleRateHz;

		public int SampleSizeInBytes;

		public int MinimumSafeSamplesQueued;

		public int MinimumBufferSamplesCount;

		public int OptimalBufferSamplesCount;

		public int MaximumBufferSamplesCount;
	}

	public struct AppPerfFrameStats
	{
		public int HmdVsyncIndex;

		public int AppFrameIndex;

		public int AppDroppedFrameCount;

		public float AppMotionToPhotonLatency;

		public float AppQueueAheadTime;

		public float AppCpuElapsedTime;

		public float AppGpuElapsedTime;

		public int CompositorFrameIndex;

		public int CompositorDroppedFrameCount;

		public float CompositorLatency;

		public float CompositorCpuElapsedTime;

		public float CompositorGpuElapsedTime;

		public float CompositorCpuStartToGpuEndElapsedTime;

		public float CompositorGpuEndToVsyncElapsedTime;
	}

	public struct AppPerfStats
	{
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 5)]
		public AppPerfFrameStats[] FrameStats;

		public int FrameStatsCount;

		public Bool AnyFrameStatsDropped;

		public float AdaptiveGpuPerformanceScale;
	}

	public struct Sizei
	{
		public int w;

		public int h;
	}

	public struct Sizef
	{
		public float w;

		public float h;
	}

	public struct Vector2i
	{
		public int x;

		public int y;
	}

	public struct Recti
	{
		private Vector2i Pos;

		private Sizei Size;
	}

	public struct Rectf
	{
		private Vector2f Pos;

		private Sizef Size;
	}

	public struct Frustumf
	{
		public float zNear;

		public float zFar;

		public float fovX;

		public float fovY;
	}

	public struct Frustumf2
	{
		public float zNear;

		public float zFar;

		public Fovf Fov;
	}

	public enum BoundaryType
	{
		OuterBoundary = 1,
		PlayArea = 0x100
	}

	public struct BoundaryTestResult
	{
		public Bool IsTriggering;

		public float ClosestDistance;

		public Vector3f ClosestPoint;

		public Vector3f ClosestPointNormal;
	}

	public struct BoundaryLookAndFeel
	{
		public Colorf Color;
	}

	public struct BoundaryGeometry
	{
		public BoundaryType BoundaryType;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
		public Vector3f[] Points;

		public int PointsCount;
	}

	public struct Colorf
	{
		public float r;

		public float g;

		public float b;

		public float a;
	}

	public struct Fovf
	{
		public float UpTan;

		public float DownTan;

		public float LeftTan;

		public float RightTan;
	}

	public struct CameraIntrinsics
	{
		public bool IsValid;

		public double LastChangedTimeSeconds;

		public Fovf FOVPort;

		public float VirtualNearPlaneDistanceMeters;

		public float VirtualFarPlaneDistanceMeters;

		public Sizei ImageSensorPixelResolution;
	}

	public struct CameraExtrinsics
	{
		public bool IsValid;

		public double LastChangedTimeSeconds;

		public CameraStatus CameraStatusData;

		public Node AttachedToNode;

		public Posef RelativePose;
	}

	public enum LayerLayout
	{
		Stereo = 0,
		Mono = 1,
		DoubleWide = 2,
		Array = 3,
		EnumSize = 15
	}

	public enum LayerFlags
	{
		Static = 1,
		LoadingScreen = 2,
		SymmetricFov = 4,
		TextureOriginAtBottomLeft = 8,
		ChromaticAberrationCorrection = 0x10,
		NoAllocation = 0x20,
		ProtectedContent = 0x40
	}

	public struct LayerDesc
	{
		public OverlayShape Shape;

		public LayerLayout Layout;

		public Sizei TextureSize;

		public int MipLevels;

		public int SampleCount;

		public EyeTextureFormat Format;

		public int LayerFlags;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]
		public Fovf[] Fov;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]
		public Rectf[] VisibleRect;

		public Sizei MaxViewportSize;

		private EyeTextureFormat DepthFormat;

		public override string ToString()
		{
			string text = ", ";
			return Shape.ToString() + text + Layout.ToString() + text + TextureSize.w + "x" + TextureSize.h + text + MipLevels + text + SampleCount + text + Format.ToString() + text + LayerFlags;
		}
	}

	public struct LayerSubmit
	{
		private int LayerId;

		private int TextureStage;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]
		private Recti[] ViewportRect;

		private Posef Pose;

		private int LayerSubmitFlags;
	}

	private static class OVRP_0_1_0
	{
		public static readonly Version version = new Version(0, 1, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Sizei ovrp_GetEyeTextureSize(Eye eyeId);
	}

	private static class OVRP_0_1_1
	{
		public static readonly Version version = new Version(0, 1, 1);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetOverlayQuad2(Bool onTop, Bool headLocked, IntPtr texture, IntPtr device, Posef pose, Vector3f scale);
	}

	private static class OVRP_0_1_2
	{
		public static readonly Version version = new Version(0, 1, 2);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodePose(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetControllerVibration(uint controllerMask, float frequency, float amplitude);
	}

	private static class OVRP_0_1_3
	{
		public static readonly Version version = new Version(0, 1, 3);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodeVelocity(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodeAcceleration(Node nodeId);
	}

	private static class OVRP_0_5_0
	{
		public static readonly Version version = new Version(0, 5, 0);
	}

	private static class OVRP_1_0_0
	{
		public static readonly Version version = new Version(1, 0, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern TrackingOrigin ovrp_GetTrackingOriginType();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetTrackingOriginType(TrackingOrigin originType);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetTrackingCalibratedOrigin();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_RecenterTrackingOrigin(uint flags);
	}

	private static class OVRP_1_1_0
	{
		public static readonly Version version = new Version(1, 1, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetInitialized();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetVersion")]
		private static extern IntPtr _ovrp_GetVersion();

		public static string ovrp_GetVersion()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetVersion());
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetNativeSDKVersion")]
		private static extern IntPtr _ovrp_GetNativeSDKVersion();

		public static string ovrp_GetNativeSDKVersion()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetNativeSDKVersion());
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrp_GetAudioOutId();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrp_GetAudioInId();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetEyeTextureScale();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetEyeTextureScale(float value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetTrackingOrientationSupported();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetTrackingOrientationEnabled();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetTrackingOrientationEnabled(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetTrackingPositionSupported();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetTrackingPositionEnabled();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetTrackingPositionEnabled(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetNodePresent(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetNodeOrientationTracked(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetNodePositionTracked(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Frustumf ovrp_GetNodeFrustum(Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern ControllerState ovrp_GetControllerState(uint controllerMask);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovrp_GetSystemCpuLevel();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetSystemCpuLevel(int value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovrp_GetSystemGpuLevel();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetSystemGpuLevel(int value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetSystemPowerSavingMode();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetSystemDisplayFrequency();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovrp_GetSystemVSyncCount();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetSystemVolume();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern BatteryStatus ovrp_GetSystemBatteryStatus();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetSystemBatteryLevel();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetSystemBatteryTemperature();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetSystemProductName")]
		private static extern IntPtr _ovrp_GetSystemProductName();

		public static string ovrp_GetSystemProductName()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetSystemProductName());
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_ShowSystemUI(PlatformUI ui);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetAppMonoscopic();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetAppMonoscopic(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetAppHasVrFocus();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetAppShouldQuit();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetAppShouldRecenter();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetAppLatencyTimings")]
		private static extern IntPtr _ovrp_GetAppLatencyTimings();

		public static string ovrp_GetAppLatencyTimings()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetAppLatencyTimings());
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetUserPresent();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetUserIPD();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetUserIPD(float value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetUserEyeDepth();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetUserEyeDepth(float value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetUserEyeHeight();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetUserEyeHeight(float value);
	}

	private static class OVRP_1_2_0
	{
		public static readonly Version version = new Version(1, 2, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetSystemVSyncCount(int vsyncCount);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrpi_SetTrackingCalibratedOrigin();
	}

	private static class OVRP_1_3_0
	{
		public static readonly Version version = new Version(1, 3, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetEyeOcclusionMeshEnabled();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetEyeOcclusionMeshEnabled(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetSystemHeadphonesPresent();
	}

	private static class OVRP_1_5_0
	{
		public static readonly Version version = new Version(1, 5, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemRegion ovrp_GetSystemRegion();
	}

	private static class OVRP_1_6_0
	{
		public static readonly Version version = new Version(1, 6, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetTrackingIPDEnabled();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetTrackingIPDEnabled(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern HapticsDesc ovrp_GetControllerHapticsDesc(uint controllerMask);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern HapticsState ovrp_GetControllerHapticsState(uint controllerMask);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetControllerHaptics(uint controllerMask, HapticsBuffer hapticsBuffer);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetOverlayQuad3(uint flags, IntPtr textureLeft, IntPtr textureRight, IntPtr device, Posef pose, Vector3f scale, int layerIndex);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetEyeRecommendedResolutionScale();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetAppCpuStartToGpuEndTime();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovrp_GetSystemRecommendedMSAALevel();
	}

	private static class OVRP_1_7_0
	{
		public static readonly Version version = new Version(1, 7, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetAppChromaticCorrection();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetAppChromaticCorrection(Bool value);
	}

	private static class OVRP_1_8_0
	{
		public static readonly Version version = new Version(1, 8, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetBoundaryConfigured();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern BoundaryTestResult ovrp_TestBoundaryNode(Node nodeId, BoundaryType boundaryType);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern BoundaryTestResult ovrp_TestBoundaryPoint(Vector3f point, BoundaryType boundaryType);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetBoundaryLookAndFeel(BoundaryLookAndFeel lookAndFeel);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_ResetBoundaryLookAndFeel();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern BoundaryGeometry ovrp_GetBoundaryGeometry(BoundaryType boundaryType);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Vector3f ovrp_GetBoundaryDimensions(BoundaryType boundaryType);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetBoundaryVisible();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetBoundaryVisible(Bool value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_Update2(int stateId, int frameIndex, double predictionSeconds);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodePose2(int stateId, Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodeVelocity2(int stateId, Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Posef ovrp_GetNodeAcceleration2(int stateId, Node nodeId);
	}

	private static class OVRP_1_9_0
	{
		public static readonly Version version = new Version(1, 9, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemHeadset ovrp_GetSystemHeadsetType();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Controller ovrp_GetActiveController();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Controller ovrp_GetConnectedControllers();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetBoundaryGeometry2(BoundaryType boundaryType, IntPtr points, ref int pointsCount);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern AppPerfStats ovrp_GetAppPerfStats();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_ResetAppPerfStats();
	}

	private static class OVRP_1_10_0
	{
		public static readonly Version version = new Version(1, 10, 0);
	}

	private static class OVRP_1_11_0
	{
		public static readonly Version version = new Version(1, 11, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_SetDesiredEyeTextureFormat(EyeTextureFormat value);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern EyeTextureFormat ovrp_GetDesiredEyeTextureFormat();
	}

	private static class OVRP_1_12_0
	{
		public static readonly Version version = new Version(1, 12, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrp_GetAppFramerate();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern PoseStatef ovrp_GetNodePoseState(Step stepId, Node nodeId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern ControllerState2 ovrp_GetControllerState2(uint controllerMask);
	}

	private static class OVRP_1_15_0
	{
		public const int OVRP_EXTERNAL_CAMERA_NAME_SIZE = 32;

		public static readonly Version version = new Version(1, 15, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_InitializeMixedReality();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_ShutdownMixedReality();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetMixedRealityInitialized();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_UpdateExternalCamera();

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetExternalCameraCount(out int cameraCount);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetExternalCameraName(int cameraId, [MarshalAs(UnmanagedType.LPArray, SizeConst = 32)] char[] cameraName);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetExternalCameraIntrinsics(int cameraId, out CameraIntrinsics cameraIntrinsics);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetExternalCameraExtrinsics(int cameraId, out CameraExtrinsics cameraExtrinsics);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_CalculateLayerDesc(OverlayShape shape, LayerLayout layout, ref Sizei textureSize, int mipLevels, int sampleCount, EyeTextureFormat format, int layerFlags, ref LayerDesc layerDesc);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_EnqueueSetupLayer(ref LayerDesc desc, IntPtr layerId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_EnqueueDestroyLayer(IntPtr layerId);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetLayerTextureStageCount(int layerId, ref int layerTextureStageCount);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetLayerTexturePtr(int layerId, int stage, Eye eyeId, ref IntPtr textureHandle);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_EnqueueSubmitLayer(uint flags, IntPtr textureLeft, IntPtr textureRight, int layerId, int frameIndex, ref Posef pose, ref Vector3f scale, int layerIndex);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetNodeFrustum2(Node nodeId, out Frustumf2 nodeFrustum);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Bool ovrp_GetEyeTextureArrayEnabled();
	}

	private static class OVRP_1_16_0
	{
		public static readonly Version version = new Version(1, 16, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetControllerState4(uint controllerMask, ref ControllerState4 controllerState);
	}

	private static class OVRP_1_17_0
	{
		public static readonly Version version = new Version(1, 17, 0);
	}

	private static class OVRP_1_18_0
	{
		public static readonly Version version = new Version(1, 18, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_SetHandNodePoseStateLatency(double latencyInSeconds);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetHandNodePoseStateLatency(out double latencyInSeconds);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetAppHasInputFocus(out Bool appHasInputFocus);
	}

	private static class OVRP_1_19_0
	{
		public static readonly Version version = new Version(1, 19, 0);
	}

	private static class OVRP_1_21_0
	{
		public static readonly Version version = new Version(1, 21, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetTiledMultiResSupported(out Bool foveationSupported);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetTiledMultiResLevel(out TiledMultiResLevel level);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_SetTiledMultiResLevel(TiledMultiResLevel level);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetGPUUtilSupported(out Bool gpuUtilSupported);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetGPUUtilLevel(out float gpuUtil);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetSystemDisplayFrequency2(out float systemDisplayFrequency);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetSystemDisplayAvailableFrequencies(IntPtr systemDisplayAvailableFrequencies, out int numFrequencies);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_SetSystemDisplayFrequency(float requestedFrequency);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetAppAsymmetricFov(out Bool useAsymmetricFov);
	}

	private static class OVRP_1_28_0
	{
		public static readonly Version version = new Version(1, 28, 0);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetDominantHand(out Handedness dominantHand);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_GetReorientHMDOnControllerRecenter(out Bool recenter);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_SetReorientHMDOnControllerRecenter(Bool recenter);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_SendEvent(string name, string param);

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
		public static extern Result ovrp_EnqueueSetupLayer2(ref LayerDesc desc, int compositionDepth, IntPtr layerId);
	}

	public const bool isSupportedPlatform = true;

	public static readonly Version wrapperVersion = OVRP_1_28_0.version;

	private static Version _version;

	private static Version _nativeSDKVersion;

	private const int OverlayShapeFlagShift = 4;

	public const int AppPerfFrameStatsMaxCount = 5;

	private static GUID _nativeAudioOutGuid = new GUID();

	private static Guid _cachedAudioOutGuid;

	private static string _cachedAudioOutString;

	private static GUID _nativeAudioInGuid = new GUID();

	private static Guid _cachedAudioInGuid;

	private static string _cachedAudioInString;

	private static OVRNativeBuffer _nativeSystemDisplayFrequenciesAvailable = null;

	private static float[] _cachedSystemDisplayFrequenciesAvailable = null;

	private const string pluginName = "OVRPlugin";

	private static Version _versionZero = new Version(0, 0, 0);

	public static Version version
	{
		get
		{
			if (_version == null)
			{
				try
				{
					string text = OVRP_1_1_0.ovrp_GetVersion();
					if (text != null)
					{
						text = text.Split('-')[0];
						_version = new Version(text);
					}
					else
					{
						_version = _versionZero;
					}
				}
				catch
				{
					_version = _versionZero;
				}
				if (_version == OVRP_0_5_0.version)
				{
					_version = OVRP_0_1_0.version;
				}
				if (_version > _versionZero && _version < OVRP_1_3_0.version)
				{
					throw new PlatformNotSupportedException(string.Concat("Oculus Utilities version ", wrapperVersion, " is too new for OVRPlugin version ", _version.ToString(), ". Update to the latest version of Unity."));
				}
			}
			return _version;
		}
	}

	public static Version nativeSDKVersion
	{
		get
		{
			if (_nativeSDKVersion == null)
			{
				try
				{
					string empty = string.Empty;
					empty = ((!(version >= OVRP_1_1_0.version)) ? _versionZero.ToString() : OVRP_1_1_0.ovrp_GetNativeSDKVersion());
					if (empty != null)
					{
						empty = empty.Split('-')[0];
						_nativeSDKVersion = new Version(empty);
					}
					else
					{
						_nativeSDKVersion = _versionZero;
					}
				}
				catch
				{
					_nativeSDKVersion = _versionZero;
				}
			}
			return _nativeSDKVersion;
		}
	}

	public static bool initialized => OVRP_1_1_0.ovrp_GetInitialized() == Bool.True;

	public static bool chromatic
	{
		get
		{
			if (version >= OVRP_1_7_0.version)
			{
				if (initialized)
				{
					return OVRP_1_7_0.ovrp_GetAppChromaticCorrection() == Bool.True;
				}
				return false;
			}
			return false;
		}
		set
		{
			if (initialized && version >= OVRP_1_7_0.version)
			{
				OVRP_1_7_0.ovrp_SetAppChromaticCorrection(ToBool(value));
			}
		}
	}

	public static bool monoscopic
	{
		get
		{
			if (initialized)
			{
				return OVRP_1_1_0.ovrp_GetAppMonoscopic() == Bool.True;
			}
			return false;
		}
		set
		{
			if (initialized)
			{
				OVRP_1_1_0.ovrp_SetAppMonoscopic(ToBool(value));
			}
		}
	}

	public static bool rotation
	{
		get
		{
			if (initialized)
			{
				return OVRP_1_1_0.ovrp_GetTrackingOrientationEnabled() == Bool.True;
			}
			return false;
		}
		set
		{
			if (initialized)
			{
				OVRP_1_1_0.ovrp_SetTrackingOrientationEnabled(ToBool(value));
			}
		}
	}

	public static bool position
	{
		get
		{
			if (initialized)
			{
				return OVRP_1_1_0.ovrp_GetTrackingPositionEnabled() == Bool.True;
			}
			return false;
		}
		set
		{
			if (initialized)
			{
				OVRP_1_1_0.ovrp_SetTrackingPositionEnabled(ToBool(value));
			}
		}
	}

	public static bool useIPDInPositionTracking
	{
		get
		{
			if (initialized && version >= OVRP_1_6_0.version)
			{
				return OVRP_1_6_0.ovrp_GetTrackingIPDEnabled() == Bool.True;
			}
			return true;
		}
		set
		{
			if (initialized && version >= OVRP_1_6_0.version)
			{
				OVRP_1_6_0.ovrp_SetTrackingIPDEnabled(ToBool(value));
			}
		}
	}

	public static bool positionSupported
	{
		get
		{
			if (initialized)
			{
				return OVRP_1_1_0.ovrp_GetTrackingPositionSupported() == Bool.True;
			}
			return false;
		}
	}

	public static bool positionTracked
	{
		get
		{
			if (initialized)
			{
				return OVRP_1_1_0.ovrp_GetNodePositionTracked(Node.EyeCenter) == Bool.True;
			}
			return false;
		}
	}

	public static bool powerSaving
	{
		get
		{
			if (initialized)
			{
				return OVRP_1_1_0.ovrp_GetSystemPowerSavingMode() == Bool.True;
			}
			return false;
		}
	}

	public static bool hmdPresent
	{
		get
		{
			if (initialized)
			{
				return OVRP_1_1_0.ovrp_GetNodePresent(Node.EyeCenter) == Bool.True;
			}
			return false;
		}
	}

	public static bool userPresent
	{
		get
		{
			if (initialized)
			{
				return OVRP_1_1_0.ovrp_GetUserPresent() == Bool.True;
			}
			return false;
		}
	}

	public static bool headphonesPresent
	{
		get
		{
			if (initialized)
			{
				return OVRP_1_3_0.ovrp_GetSystemHeadphonesPresent() == Bool.True;
			}
			return false;
		}
	}

	public static int recommendedMSAALevel
	{
		get
		{
			if (initialized && version >= OVRP_1_6_0.version)
			{
				return OVRP_1_6_0.ovrp_GetSystemRecommendedMSAALevel();
			}
			return 2;
		}
	}

	public static SystemRegion systemRegion
	{
		get
		{
			if (initialized && version >= OVRP_1_5_0.version)
			{
				return OVRP_1_5_0.ovrp_GetSystemRegion();
			}
			return SystemRegion.Unspecified;
		}
	}

	public static string audioOutId
	{
		get
		{
			try
			{
				if (_nativeAudioOutGuid == null)
				{
					_nativeAudioOutGuid = new GUID();
				}
				IntPtr intPtr = OVRP_1_1_0.ovrp_GetAudioOutId();
				if (intPtr != IntPtr.Zero)
				{
					Marshal.PtrToStructure(intPtr, _nativeAudioOutGuid);
					Guid guid = new Guid(_nativeAudioOutGuid.a, _nativeAudioOutGuid.b, _nativeAudioOutGuid.c, _nativeAudioOutGuid.d0, _nativeAudioOutGuid.d1, _nativeAudioOutGuid.d2, _nativeAudioOutGuid.d3, _nativeAudioOutGuid.d4, _nativeAudioOutGuid.d5, _nativeAudioOutGuid.d6, _nativeAudioOutGuid.d7);
					if (guid != _cachedAudioOutGuid)
					{
						_cachedAudioOutGuid = guid;
						_cachedAudioOutString = _cachedAudioOutGuid.ToString();
					}
					return _cachedAudioOutString;
				}
			}
			catch
			{
			}
			return string.Empty;
		}
	}

	public static string audioInId
	{
		get
		{
			try
			{
				if (_nativeAudioInGuid == null)
				{
					_nativeAudioInGuid = new GUID();
				}
				IntPtr intPtr = OVRP_1_1_0.ovrp_GetAudioInId();
				if (intPtr != IntPtr.Zero)
				{
					Marshal.PtrToStructure(intPtr, _nativeAudioInGuid);
					Guid guid = new Guid(_nativeAudioInGuid.a, _nativeAudioInGuid.b, _nativeAudioInGuid.c, _nativeAudioInGuid.d0, _nativeAudioInGuid.d1, _nativeAudioInGuid.d2, _nativeAudioInGuid.d3, _nativeAudioInGuid.d4, _nativeAudioInGuid.d5, _nativeAudioInGuid.d6, _nativeAudioInGuid.d7);
					if (guid != _cachedAudioInGuid)
					{
						_cachedAudioInGuid = guid;
						_cachedAudioInString = _cachedAudioInGuid.ToString();
					}
					return _cachedAudioInString;
				}
			}
			catch
			{
			}
			return string.Empty;
		}
	}

	public static bool hasVrFocus => OVRP_1_1_0.ovrp_GetAppHasVrFocus() == Bool.True;

	public static bool hasInputFocus
	{
		get
		{
			if (version >= OVRP_1_18_0.version)
			{
				Bool appHasInputFocus = Bool.False;
				if (OVRP_1_18_0.ovrp_GetAppHasInputFocus(out appHasInputFocus) == Result.Success)
				{
					return appHasInputFocus == Bool.True;
				}
				return false;
			}
			return true;
		}
	}

	public static bool shouldQuit => OVRP_1_1_0.ovrp_GetAppShouldQuit() == Bool.True;

	public static bool shouldRecenter => OVRP_1_1_0.ovrp_GetAppShouldRecenter() == Bool.True;

	public static string productName => OVRP_1_1_0.ovrp_GetSystemProductName();

	public static string latency => OVRP_1_1_0.ovrp_GetAppLatencyTimings();

	public static float eyeDepth
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetUserEyeDepth();
		}
		set
		{
			OVRP_1_1_0.ovrp_SetUserEyeDepth(value);
		}
	}

	public static float eyeHeight
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetUserEyeHeight();
		}
		set
		{
			OVRP_1_1_0.ovrp_SetUserEyeHeight(value);
		}
	}

	public static float batteryLevel => OVRP_1_1_0.ovrp_GetSystemBatteryLevel();

	public static float batteryTemperature => OVRP_1_1_0.ovrp_GetSystemBatteryTemperature();

	public static int cpuLevel
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetSystemCpuLevel();
		}
		set
		{
			OVRP_1_1_0.ovrp_SetSystemCpuLevel(value);
		}
	}

	public static int gpuLevel
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetSystemGpuLevel();
		}
		set
		{
			OVRP_1_1_0.ovrp_SetSystemGpuLevel(value);
		}
	}

	public static int vsyncCount
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetSystemVSyncCount();
		}
		set
		{
			OVRP_1_2_0.ovrp_SetSystemVSyncCount(value);
		}
	}

	public static float systemVolume => OVRP_1_1_0.ovrp_GetSystemVolume();

	public static float ipd
	{
		get
		{
			return OVRP_1_1_0.ovrp_GetUserIPD();
		}
		set
		{
			OVRP_1_1_0.ovrp_SetUserIPD(value);
		}
	}

	public static bool occlusionMesh
	{
		get
		{
			return OVRP_1_3_0.ovrp_GetEyeOcclusionMeshEnabled() == Bool.True;
		}
		set
		{
			OVRP_1_3_0.ovrp_SetEyeOcclusionMeshEnabled(ToBool(value));
		}
	}

	public static BatteryStatus batteryStatus => OVRP_1_1_0.ovrp_GetSystemBatteryStatus();

	public static bool tiledMultiResSupported
	{
		get
		{
			if (version >= OVRP_1_21_0.version)
			{
				if (OVRP_1_21_0.ovrp_GetTiledMultiResSupported(out var foveationSupported) == Result.Success)
				{
					return foveationSupported == Bool.True;
				}
				return false;
			}
			return false;
		}
	}

	public static TiledMultiResLevel tiledMultiResLevel
	{
		get
		{
			if (version >= OVRP_1_21_0.version && tiledMultiResSupported)
			{
				OVRP_1_21_0.ovrp_GetTiledMultiResLevel(out var level);
				return level;
			}
			return TiledMultiResLevel.Off;
		}
		set
		{
			if (version >= OVRP_1_21_0.version && tiledMultiResSupported)
			{
				OVRP_1_21_0.ovrp_SetTiledMultiResLevel(value);
			}
		}
	}

	public static bool gpuUtilSupported
	{
		get
		{
			if (version >= OVRP_1_21_0.version)
			{
				if (OVRP_1_21_0.ovrp_GetGPUUtilSupported(out var @bool) == Result.Success)
				{
					return @bool == Bool.True;
				}
				return false;
			}
			return false;
		}
	}

	public static float gpuUtilLevel
	{
		get
		{
			if (version >= OVRP_1_21_0.version && gpuUtilSupported)
			{
				if (OVRP_1_21_0.ovrp_GetGPUUtilLevel(out var gpuUtil) == Result.Success)
				{
					return gpuUtil;
				}
				return 0f;
			}
			return 0f;
		}
	}

	public static float[] systemDisplayFrequenciesAvailable
	{
		get
		{
			if (_cachedSystemDisplayFrequenciesAvailable == null)
			{
				_cachedSystemDisplayFrequenciesAvailable = new float[0];
				if (version >= OVRP_1_21_0.version)
				{
					int numFrequencies = 0;
					if (OVRP_1_21_0.ovrp_GetSystemDisplayAvailableFrequencies(IntPtr.Zero, out numFrequencies) == Result.Success && numFrequencies > 0)
					{
						int num = numFrequencies;
						_nativeSystemDisplayFrequenciesAvailable = new OVRNativeBuffer(4 * num);
						if (OVRP_1_21_0.ovrp_GetSystemDisplayAvailableFrequencies(_nativeSystemDisplayFrequenciesAvailable.GetPointer(), out numFrequencies) == Result.Success)
						{
							int num2 = ((numFrequencies <= num) ? numFrequencies : num);
							if (num2 > 0)
							{
								_cachedSystemDisplayFrequenciesAvailable = new float[num2];
								Marshal.Copy(_nativeSystemDisplayFrequenciesAvailable.GetPointer(), _cachedSystemDisplayFrequenciesAvailable, 0, num2);
							}
						}
					}
				}
			}
			return _cachedSystemDisplayFrequenciesAvailable;
		}
	}

	public static float systemDisplayFrequency
	{
		get
		{
			if (version >= OVRP_1_21_0.version)
			{
				if (OVRP_1_21_0.ovrp_GetSystemDisplayFrequency2(out var result) == Result.Success)
				{
					return result;
				}
				return 0f;
			}
			if (version >= OVRP_1_1_0.version)
			{
				return OVRP_1_1_0.ovrp_GetSystemDisplayFrequency();
			}
			return 0f;
		}
		set
		{
			if (version >= OVRP_1_21_0.version)
			{
				OVRP_1_21_0.ovrp_SetSystemDisplayFrequency(value);
			}
		}
	}

	public static bool AsymmetricFovEnabled
	{
		get
		{
			if (version >= OVRP_1_21_0.version)
			{
				Bool useAsymmetricFov = Bool.False;
				if (OVRP_1_21_0.ovrp_GetAppAsymmetricFov(out useAsymmetricFov) != 0)
				{
					return false;
				}
				return useAsymmetricFov == Bool.True;
			}
			return false;
		}
	}

	public static bool EyeTextureArrayEnabled
	{
		get
		{
			if (version >= OVRP_1_15_0.version)
			{
				return OVRP_1_15_0.ovrp_GetEyeTextureArrayEnabled() == Bool.True;
			}
			return false;
		}
	}

	public static Frustumf GetEyeFrustum(Eye eyeId)
	{
		return OVRP_1_1_0.ovrp_GetNodeFrustum((Node)eyeId);
	}

	public static Sizei GetEyeTextureSize(Eye eyeId)
	{
		return OVRP_0_1_0.ovrp_GetEyeTextureSize(eyeId);
	}

	public static Posef GetTrackerPose(Tracker trackerId)
	{
		return GetNodePose((Node)(trackerId + 5), Step.Render);
	}

	public static Frustumf GetTrackerFrustum(Tracker trackerId)
	{
		return OVRP_1_1_0.ovrp_GetNodeFrustum((Node)(trackerId + 5));
	}

	public static bool ShowUI(PlatformUI ui)
	{
		return OVRP_1_1_0.ovrp_ShowSystemUI(ui) == Bool.True;
	}

	public static bool EnqueueSubmitLayer(bool onTop, bool headLocked, IntPtr leftTexture, IntPtr rightTexture, int layerId, int frameIndex, Posef pose, Vector3f scale, int layerIndex = 0, OverlayShape shape = OverlayShape.Quad)
	{
		if (version >= OVRP_1_6_0.version)
		{
			uint num = 0u;
			if (onTop)
			{
				num |= 1u;
			}
			if (headLocked)
			{
				num |= 2u;
			}
			if (shape == OverlayShape.Cylinder || shape == OverlayShape.Cubemap)
			{
				if (!(version >= OVRP_1_7_0.version))
				{
					return false;
				}
				num |= (uint)((int)shape << 4);
			}
			if (shape == OverlayShape.OffcenterCubemap)
			{
				if (!(version >= OVRP_1_11_0.version))
				{
					return false;
				}
				num |= (uint)((int)shape << 4);
			}
			if (shape == OverlayShape.Equirect)
			{
				if (!(version >= OVRP_1_21_0.version))
				{
					return false;
				}
				num |= (uint)((int)shape << 4);
			}
			if (version >= OVRP_1_15_0.version && layerId != -1)
			{
				return OVRP_1_15_0.ovrp_EnqueueSubmitLayer(num, leftTexture, rightTexture, layerId, frameIndex, ref pose, ref scale, layerIndex) == Result.Success;
			}
			return OVRP_1_6_0.ovrp_SetOverlayQuad3(num, leftTexture, rightTexture, IntPtr.Zero, pose, scale, layerIndex) == Bool.True;
		}
		if (layerIndex != 0)
		{
			return false;
		}
		return OVRP_0_1_1.ovrp_SetOverlayQuad2(ToBool(onTop), ToBool(headLocked), leftTexture, IntPtr.Zero, pose, scale) == Bool.True;
	}

	public static LayerDesc CalculateLayerDesc(OverlayShape shape, LayerLayout layout, Sizei textureSize, int mipLevels, int sampleCount, EyeTextureFormat format, int layerFlags)
	{
		LayerDesc layerDesc = default(LayerDesc);
		if (version >= OVRP_1_15_0.version)
		{
			OVRP_1_15_0.ovrp_CalculateLayerDesc(shape, layout, ref textureSize, mipLevels, sampleCount, format, layerFlags, ref layerDesc);
		}
		return layerDesc;
	}

	public static bool EnqueueSetupLayer(LayerDesc desc, int compositionDepth, IntPtr layerID)
	{
		if (version >= OVRP_1_28_0.version)
		{
			return OVRP_1_28_0.ovrp_EnqueueSetupLayer2(ref desc, compositionDepth, layerID) == Result.Success;
		}
		if (version >= OVRP_1_15_0.version)
		{
			if (compositionDepth != 0)
			{
				UnityEngine.Debug.LogWarning("Use Oculus Plugin 1.28.0 or above to support non-zero compositionDepth");
			}
			return OVRP_1_15_0.ovrp_EnqueueSetupLayer(ref desc, layerID) == Result.Success;
		}
		return false;
	}

	public static bool EnqueueDestroyLayer(IntPtr layerID)
	{
		if (version >= OVRP_1_15_0.version)
		{
			return OVRP_1_15_0.ovrp_EnqueueDestroyLayer(layerID) == Result.Success;
		}
		return false;
	}

	public static IntPtr GetLayerTexture(int layerId, int stage, Eye eyeId)
	{
		IntPtr textureHandle = IntPtr.Zero;
		if (version >= OVRP_1_15_0.version)
		{
			OVRP_1_15_0.ovrp_GetLayerTexturePtr(layerId, stage, eyeId, ref textureHandle);
		}
		return textureHandle;
	}

	public static int GetLayerTextureStageCount(int layerId)
	{
		int layerTextureStageCount = 1;
		if (version >= OVRP_1_15_0.version)
		{
			OVRP_1_15_0.ovrp_GetLayerTextureStageCount(layerId, ref layerTextureStageCount);
		}
		return layerTextureStageCount;
	}

	public static bool UpdateNodePhysicsPoses(int frameIndex, double predictionSeconds)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_Update2(0, frameIndex, predictionSeconds) == Bool.True;
		}
		return false;
	}

	public static Posef GetNodePose(Node nodeId, Step stepId)
	{
		if (version >= OVRP_1_12_0.version)
		{
			return OVRP_1_12_0.ovrp_GetNodePoseState(stepId, nodeId).Pose;
		}
		if (version >= OVRP_1_8_0.version && stepId == Step.Physics)
		{
			return OVRP_1_8_0.ovrp_GetNodePose2(0, nodeId);
		}
		return OVRP_0_1_2.ovrp_GetNodePose(nodeId);
	}

	public static Vector3f GetNodeVelocity(Node nodeId, Step stepId)
	{
		if (version >= OVRP_1_12_0.version)
		{
			return OVRP_1_12_0.ovrp_GetNodePoseState(stepId, nodeId).Velocity;
		}
		if (version >= OVRP_1_8_0.version && stepId == Step.Physics)
		{
			return OVRP_1_8_0.ovrp_GetNodeVelocity2(0, nodeId).Position;
		}
		return OVRP_0_1_3.ovrp_GetNodeVelocity(nodeId).Position;
	}

	public static Vector3f GetNodeAngularVelocity(Node nodeId, Step stepId)
	{
		if (version >= OVRP_1_12_0.version)
		{
			return OVRP_1_12_0.ovrp_GetNodePoseState(stepId, nodeId).AngularVelocity;
		}
		return default(Vector3f);
	}

	public static Vector3f GetNodeAcceleration(Node nodeId, Step stepId)
	{
		if (version >= OVRP_1_12_0.version)
		{
			return OVRP_1_12_0.ovrp_GetNodePoseState(stepId, nodeId).Acceleration;
		}
		if (version >= OVRP_1_8_0.version && stepId == Step.Physics)
		{
			return OVRP_1_8_0.ovrp_GetNodeAcceleration2(0, nodeId).Position;
		}
		return OVRP_0_1_3.ovrp_GetNodeAcceleration(nodeId).Position;
	}

	public static Vector3f GetNodeAngularAcceleration(Node nodeId, Step stepId)
	{
		if (version >= OVRP_1_12_0.version)
		{
			return OVRP_1_12_0.ovrp_GetNodePoseState(stepId, nodeId).AngularAcceleration;
		}
		return default(Vector3f);
	}

	public static bool GetNodePresent(Node nodeId)
	{
		return OVRP_1_1_0.ovrp_GetNodePresent(nodeId) == Bool.True;
	}

	public static bool GetNodeOrientationTracked(Node nodeId)
	{
		return OVRP_1_1_0.ovrp_GetNodeOrientationTracked(nodeId) == Bool.True;
	}

	public static bool GetNodePositionTracked(Node nodeId)
	{
		return OVRP_1_1_0.ovrp_GetNodePositionTracked(nodeId) == Bool.True;
	}

	public static ControllerState GetControllerState(uint controllerMask)
	{
		return OVRP_1_1_0.ovrp_GetControllerState(controllerMask);
	}

	public static ControllerState2 GetControllerState2(uint controllerMask)
	{
		if (version >= OVRP_1_12_0.version)
		{
			return OVRP_1_12_0.ovrp_GetControllerState2(controllerMask);
		}
		return new ControllerState2(OVRP_1_1_0.ovrp_GetControllerState(controllerMask));
	}

	public static ControllerState4 GetControllerState4(uint controllerMask)
	{
		if (version >= OVRP_1_16_0.version)
		{
			ControllerState4 controllerState = default(ControllerState4);
			OVRP_1_16_0.ovrp_GetControllerState4(controllerMask, ref controllerState);
			return controllerState;
		}
		return new ControllerState4(GetControllerState2(controllerMask));
	}

	public static bool SetControllerVibration(uint controllerMask, float frequency, float amplitude)
	{
		return OVRP_0_1_2.ovrp_SetControllerVibration(controllerMask, frequency, amplitude) == Bool.True;
	}

	public static HapticsDesc GetControllerHapticsDesc(uint controllerMask)
	{
		if (version >= OVRP_1_6_0.version)
		{
			return OVRP_1_6_0.ovrp_GetControllerHapticsDesc(controllerMask);
		}
		return default(HapticsDesc);
	}

	public static HapticsState GetControllerHapticsState(uint controllerMask)
	{
		if (version >= OVRP_1_6_0.version)
		{
			return OVRP_1_6_0.ovrp_GetControllerHapticsState(controllerMask);
		}
		return default(HapticsState);
	}

	public static bool SetControllerHaptics(uint controllerMask, HapticsBuffer hapticsBuffer)
	{
		if (version >= OVRP_1_6_0.version)
		{
			return OVRP_1_6_0.ovrp_SetControllerHaptics(controllerMask, hapticsBuffer) == Bool.True;
		}
		return false;
	}

	public static float GetEyeRecommendedResolutionScale()
	{
		if (version >= OVRP_1_6_0.version)
		{
			return OVRP_1_6_0.ovrp_GetEyeRecommendedResolutionScale();
		}
		return 1f;
	}

	public static float GetAppCpuStartToGpuEndTime()
	{
		if (version >= OVRP_1_6_0.version)
		{
			return OVRP_1_6_0.ovrp_GetAppCpuStartToGpuEndTime();
		}
		return 0f;
	}

	public static bool GetBoundaryConfigured()
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_GetBoundaryConfigured() == Bool.True;
		}
		return false;
	}

	public static BoundaryTestResult TestBoundaryNode(Node nodeId, BoundaryType boundaryType)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_TestBoundaryNode(nodeId, boundaryType);
		}
		return default(BoundaryTestResult);
	}

	public static BoundaryTestResult TestBoundaryPoint(Vector3f point, BoundaryType boundaryType)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_TestBoundaryPoint(point, boundaryType);
		}
		return default(BoundaryTestResult);
	}

	public static bool SetBoundaryLookAndFeel(BoundaryLookAndFeel lookAndFeel)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_SetBoundaryLookAndFeel(lookAndFeel) == Bool.True;
		}
		return false;
	}

	public static bool ResetBoundaryLookAndFeel()
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_ResetBoundaryLookAndFeel() == Bool.True;
		}
		return false;
	}

	public static BoundaryGeometry GetBoundaryGeometry(BoundaryType boundaryType)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_GetBoundaryGeometry(boundaryType);
		}
		return default(BoundaryGeometry);
	}

	public static bool GetBoundaryGeometry2(BoundaryType boundaryType, IntPtr points, ref int pointsCount)
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_GetBoundaryGeometry2(boundaryType, points, ref pointsCount) == Bool.True;
		}
		pointsCount = 0;
		return false;
	}

	public static AppPerfStats GetAppPerfStats()
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_GetAppPerfStats();
		}
		return default(AppPerfStats);
	}

	public static bool ResetAppPerfStats()
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_ResetAppPerfStats() == Bool.True;
		}
		return false;
	}

	public static float GetAppFramerate()
	{
		if (version >= OVRP_1_12_0.version)
		{
			return OVRP_1_12_0.ovrp_GetAppFramerate();
		}
		return 0f;
	}

	public static bool SetHandNodePoseStateLatency(double latencyInSeconds)
	{
		if (version >= OVRP_1_18_0.version)
		{
			if (OVRP_1_18_0.ovrp_SetHandNodePoseStateLatency(latencyInSeconds) == Result.Success)
			{
				return true;
			}
			return false;
		}
		return false;
	}

	public static double GetHandNodePoseStateLatency()
	{
		if (version >= OVRP_1_18_0.version)
		{
			double latencyInSeconds = 0.0;
			if (OVRP_1_18_0.ovrp_GetHandNodePoseStateLatency(out latencyInSeconds) == Result.Success)
			{
				return latencyInSeconds;
			}
			return 0.0;
		}
		return 0.0;
	}

	public static EyeTextureFormat GetDesiredEyeTextureFormat()
	{
		if (version >= OVRP_1_11_0.version)
		{
			uint num = (uint)OVRP_1_11_0.ovrp_GetDesiredEyeTextureFormat();
			if (num == 1)
			{
				num = 0u;
			}
			return (EyeTextureFormat)num;
		}
		return EyeTextureFormat.Default;
	}

	public static bool SetDesiredEyeTextureFormat(EyeTextureFormat value)
	{
		if (version >= OVRP_1_11_0.version)
		{
			return OVRP_1_11_0.ovrp_SetDesiredEyeTextureFormat(value) == Bool.True;
		}
		return false;
	}

	public static bool InitializeMixedReality()
	{
		if (version >= OVRP_1_15_0.version)
		{
			return OVRP_1_15_0.ovrp_InitializeMixedReality() == Result.Success;
		}
		return false;
	}

	public static bool ShutdownMixedReality()
	{
		if (version >= OVRP_1_15_0.version)
		{
			return OVRP_1_15_0.ovrp_ShutdownMixedReality() == Result.Success;
		}
		return false;
	}

	public static bool IsMixedRealityInitialized()
	{
		if (version >= OVRP_1_15_0.version)
		{
			return OVRP_1_15_0.ovrp_GetMixedRealityInitialized() == Bool.True;
		}
		return false;
	}

	public static int GetExternalCameraCount()
	{
		if (version >= OVRP_1_15_0.version)
		{
			int cameraCount = 0;
			if (OVRP_1_15_0.ovrp_GetExternalCameraCount(out cameraCount) != 0)
			{
				return 0;
			}
			return cameraCount;
		}
		return 0;
	}

	public static bool UpdateExternalCamera()
	{
		if (version >= OVRP_1_15_0.version)
		{
			return OVRP_1_15_0.ovrp_UpdateExternalCamera() == Result.Success;
		}
		return false;
	}

	public static bool GetMixedRealityCameraInfo(int cameraId, out CameraExtrinsics cameraExtrinsics, out CameraIntrinsics cameraIntrinsics)
	{
		cameraExtrinsics = default(CameraExtrinsics);
		cameraIntrinsics = default(CameraIntrinsics);
		if (version >= OVRP_1_15_0.version)
		{
			bool result = true;
			if (OVRP_1_15_0.ovrp_GetExternalCameraExtrinsics(cameraId, out cameraExtrinsics) != 0)
			{
				result = false;
			}
			if (OVRP_1_15_0.ovrp_GetExternalCameraIntrinsics(cameraId, out cameraIntrinsics) != 0)
			{
				result = false;
			}
			return result;
		}
		return false;
	}

	public static Vector3f GetBoundaryDimensions(BoundaryType boundaryType)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_GetBoundaryDimensions(boundaryType);
		}
		return default(Vector3f);
	}

	public static bool GetBoundaryVisible()
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_GetBoundaryVisible() == Bool.True;
		}
		return false;
	}

	public static bool SetBoundaryVisible(bool value)
	{
		if (version >= OVRP_1_8_0.version)
		{
			return OVRP_1_8_0.ovrp_SetBoundaryVisible(ToBool(value)) == Bool.True;
		}
		return false;
	}

	public static SystemHeadset GetSystemHeadsetType()
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_GetSystemHeadsetType();
		}
		return SystemHeadset.None;
	}

	public static Controller GetActiveController()
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_GetActiveController();
		}
		return Controller.None;
	}

	public static Controller GetConnectedControllers()
	{
		if (version >= OVRP_1_9_0.version)
		{
			return OVRP_1_9_0.ovrp_GetConnectedControllers();
		}
		return Controller.None;
	}

	private static Bool ToBool(bool b)
	{
		if (!b)
		{
			return Bool.False;
		}
		return Bool.True;
	}

	public static TrackingOrigin GetTrackingOriginType()
	{
		return OVRP_1_0_0.ovrp_GetTrackingOriginType();
	}

	public static bool SetTrackingOriginType(TrackingOrigin originType)
	{
		return OVRP_1_0_0.ovrp_SetTrackingOriginType(originType) == Bool.True;
	}

	public static Posef GetTrackingCalibratedOrigin()
	{
		return OVRP_1_0_0.ovrp_GetTrackingCalibratedOrigin();
	}

	public static bool SetTrackingCalibratedOrigin()
	{
		return OVRP_1_2_0.ovrpi_SetTrackingCalibratedOrigin() == Bool.True;
	}

	public static bool RecenterTrackingOrigin(RecenterFlags flags)
	{
		return OVRP_1_0_0.ovrp_RecenterTrackingOrigin((uint)flags) == Bool.True;
	}

	public static bool GetNodeFrustum2(Node nodeId, out Frustumf2 frustum)
	{
		frustum = default(Frustumf2);
		if (version >= OVRP_1_15_0.version)
		{
			if (OVRP_1_15_0.ovrp_GetNodeFrustum2(nodeId, out frustum) != 0)
			{
				return false;
			}
			return true;
		}
		return false;
	}

	public static Handedness GetDominantHand()
	{
		if (version >= OVRP_1_28_0.version && OVRP_1_28_0.ovrp_GetDominantHand(out var dominantHand) == Result.Success)
		{
			return dominantHand;
		}
		return Handedness.Unsupported;
	}

	public static bool GetReorientHMDOnControllerRecenter()
	{
		if (version < OVRP_1_28_0.version || OVRP_1_28_0.ovrp_GetReorientHMDOnControllerRecenter(out var recenter) != 0)
		{
			return false;
		}
		return recenter == Bool.True;
	}

	public static bool SetReorientHMDOnControllerRecenter(bool recenterSetting)
	{
		Bool recenter = (recenterSetting ? Bool.True : Bool.False);
		if (version < OVRP_1_28_0.version || OVRP_1_28_0.ovrp_SetReorientHMDOnControllerRecenter(recenter) != 0)
		{
			return false;
		}
		return true;
	}

	public static bool SendEvent(string name, string param = "")
	{
		if (version >= OVRP_1_28_0.version)
		{
			return OVRP_1_28_0.ovrp_SendEvent(name, param) == Result.Success;
		}
		return false;
	}
}
public class OVRProfile : UnityEngine.Object
{
	[Obsolete]
	public enum State
	{
		NOT_TRIGGERED,
		LOADING,
		READY,
		ERROR
	}

	[Obsolete]
	public string id => "000abc123def";

	[Obsolete]
	public string userName => "Oculus User";

	[Obsolete]
	public string locale => "en_US";

	public float ipd => Vector3.Distance(OVRPlugin.GetNodePose(OVRPlugin.Node.EyeLeft, OVRPlugin.Step.Render).ToOVRPose().position, OVRPlugin.GetNodePose(OVRPlugin.Node.EyeRight, OVRPlugin.Step.Render).ToOVRPose().position);

	public float eyeHeight => OVRPlugin.eyeHeight;

	public float eyeDepth => OVRPlugin.eyeDepth;

	public float neckHeight => eyeHeight - 0.075f;

	[Obsolete]
	public State state => State.READY;
}
public class OVRTracker
{
	public struct Frustum
	{
		public float nearZ;

		public float farZ;

		public Vector2 fov;
	}

	public bool isPresent
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return false;
			}
			return OVRPlugin.positionSupported;
		}
	}

	public bool isPositionTracked => OVRPlugin.positionTracked;

	public bool isEnabled
	{
		get
		{
			if (!OVRManager.isHmdPresent)
			{
				return false;
			}
			return OVRPlugin.position;
		}
		set
		{
			if (OVRManager.isHmdPresent)
			{
				OVRPlugin.position = value;
			}
		}
	}

	public int count
	{
		get
		{
			int num = 0;
			for (int i = 0; i < 4; i++)
			{
				if (GetPresent(i))
				{
					num++;
				}
			}
			return num;
		}
	}

	public Frustum GetFrustum(int tracker = 0)
	{
		if (!OVRManager.isHmdPresent)
		{
			return default(Frustum);
		}
		return OVRPlugin.GetTrackerFrustum((OVRPlugin.Tracker)tracker).ToFrustum();
	}

	public OVRPose GetPose(int tracker = 0)
	{
		if (!OVRManager.isHmdPresent)
		{
			return OVRPose.identity;
		}
		OVRPose oVRPose;
		switch (tracker)
		{
		case 0:
			oVRPose = OVRPlugin.GetNodePose(OVRPlugin.Node.TrackerZero, OVRPlugin.Step.Render).ToOVRPose();
			break;
		case 1:
			oVRPose = OVRPlugin.GetNodePose(OVRPlugin.Node.TrackerOne, OVRPlugin.Step.Render).ToOVRPose();
			break;
		case 2:
			oVRPose = OVRPlugin.GetNodePose(OVRPlugin.Node.TrackerTwo, OVRPlugin.Step.Render).ToOVRPose();
			break;
		case 3:
			oVRPose = OVRPlugin.GetNodePose(OVRPlugin.Node.TrackerThree, OVRPlugin.Step.Render).ToOVRPose();
			break;
		default:
			return OVRPose.identity;
		}
		OVRPose result = default(OVRPose);
		result.position = oVRPose.position;
		result.orientation = oVRPose.orientation * Quaternion.Euler(0f, 180f, 0f);
		return result;
	}

	public bool GetPoseValid(int tracker = 0)
	{
		if (!OVRManager.isHmdPresent)
		{
			return false;
		}
		return tracker switch
		{
			0 => OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.TrackerZero), 
			1 => OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.TrackerOne), 
			2 => OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.TrackerTwo), 
			3 => OVRPlugin.GetNodePositionTracked(OVRPlugin.Node.TrackerThree), 
			_ => false, 
		};
	}

	public bool GetPresent(int tracker = 0)
	{
		if (!OVRManager.isHmdPresent)
		{
			return false;
		}
		return tracker switch
		{
			0 => OVRPlugin.GetNodePresent(OVRPlugin.Node.TrackerZero), 
			1 => OVRPlugin.GetNodePresent(OVRPlugin.Node.TrackerOne), 
			2 => OVRPlugin.GetNodePresent(OVRPlugin.Node.TrackerTwo), 
			3 => OVRPlugin.GetNodePresent(OVRPlugin.Node.TrackerThree), 
			_ => false, 
		};
	}
}
public class OVRChromaticAberration : MonoBehaviour
{
	public OVRInput.RawButton toggleButton = OVRInput.RawButton.X;

	private bool chromatic;

	private void Start()
	{
		OVRManager.instance.chromatic = chromatic;
	}

	private void Update()
	{
		if (OVRInput.GetDown(toggleButton))
		{
			chromatic = !chromatic;
			OVRManager.instance.chromatic = chromatic;
		}
	}
}
public class OVRCubemapCapture : MonoBehaviour
{
	public bool autoTriggerAfterLaunch = true;

	public float autoTriggerDelay = 1f;

	private float autoTriggerElapse;

	public KeyCode triggeredByKey = KeyCode.F8;

	public string pathName;

	public int cubemapSize = 2048;

	private void Update()
	{
		if (autoTriggerAfterLaunch)
		{
			autoTriggerElapse += Time.deltaTime;
			if (autoTriggerElapse >= autoTriggerDelay)
			{
				autoTriggerAfterLaunch = false;
				TriggerCubemapCapture(base.transform.position, cubemapSize, pathName);
			}
		}
		if (Input.GetKeyDown(triggeredByKey))
		{
			TriggerCubemapCapture(base.transform.position, cubemapSize, pathName);
		}
	}

	public static void TriggerCubemapCapture(Vector3 capturePos, int cubemapSize = 2048, string pathName = null)
	{
		GameObject obj = new GameObject("CubemapCamera", typeof(Camera));
		obj.hideFlags = HideFlags.HideAndDontSave;
		obj.transform.position = capturePos;
		obj.transform.rotation = Quaternion.identity;
		Camera component = obj.GetComponent<Camera>();
		component.farClipPlane = 10000f;
		component.enabled = false;
		Cubemap cubemap = new Cubemap(cubemapSize, TextureFormat.RGB24, mipChain: false);
		RenderIntoCubemap(component, cubemap);
		SaveCubemapCapture(cubemap, pathName);
		UnityEngine.Object.DestroyImmediate(cubemap);
		UnityEngine.Object.DestroyImmediate(obj);
	}

	public static void RenderIntoCubemap(Camera ownerCamera, Cubemap outCubemap)
	{
		int width = outCubemap.width;
		int height = outCubemap.height;
		CubemapFace[] array = new CubemapFace[6]
		{
			CubemapFace.PositiveX,
			CubemapFace.NegativeX,
			CubemapFace.PositiveY,
			CubemapFace.NegativeY,
			CubemapFace.PositiveZ,
			CubemapFace.NegativeZ
		};
		Vector3[] array2 = new Vector3[6]
		{
			new Vector3(0f, 90f, 0f),
			new Vector3(0f, -90f, 0f),
			new Vector3(-90f, 0f, 0f),
			new Vector3(90f, 0f, 0f),
			new Vector3(0f, 0f, 0f),
			new Vector3(0f, 180f, 0f)
		};
		RenderTexture active = RenderTexture.active;
		float fieldOfView = ownerCamera.fieldOfView;
		float aspect = ownerCamera.aspect;
		Quaternion rotation = ownerCamera.transform.rotation;
		RenderTexture renderTexture = new RenderTexture(width, height, 24);
		renderTexture.antiAliasing = 8;
		renderTexture.dimension = TextureDimension.Tex2D;
		renderTexture.hideFlags = HideFlags.HideAndDontSave;
		Texture2D texture2D = new Texture2D(width, height, TextureFormat.RGB24, mipChain: false);
		texture2D.hideFlags = HideFlags.HideAndDontSave;
		ownerCamera.targetTexture = renderTexture;
		ownerCamera.fieldOfView = 90f;
		ownerCamera.aspect = 1f;
		Color[] array3 = new Color[texture2D.height * texture2D.width];
		for (int i = 0; i < array.Length; i++)
		{
			ownerCamera.transform.eulerAngles = array2[i];
			ownerCamera.Render();
			RenderTexture.active = renderTexture;
			texture2D.ReadPixels(new Rect(0f, 0f, width, height), 0, 0);
			Color[] pixels = texture2D.GetPixels();
			for (int j = 0; j < height; j++)
			{
				for (int k = 0; k < width; k++)
				{
					array3[j * width + k] = pixels[(height - 1 - j) * width + k];
				}
			}
			outCubemap.SetPixels(array3, array[i]);
		}
		outCubemap.SmoothEdges();
		RenderTexture.active = active;
		ownerCamera.fieldOfView = fieldOfView;
		ownerCamera.aspect = aspect;
		ownerCamera.transform.rotation = rotation;
		ownerCamera.targetTexture = active;
		UnityEngine.Object.DestroyImmediate(texture2D);
		UnityEngine.Object.DestroyImmediate(renderTexture);
	}

	public static bool SaveCubemapCapture(Cubemap cubemap, string pathName = null)
	{
		int width = cubemap.width;
		int height = cubemap.height;
		int num = 0;
		int y = 0;
		bool flag = true;
		string text;
		string text2;
		if (string.IsNullOrEmpty(pathName))
		{
			text = UnityEngine.Application.persistentDataPath + "/OVR_ScreenShot360/";
			text2 = null;
		}
		else
		{
			text = Path.GetDirectoryName(pathName);
			text2 = Path.GetFileName(pathName);
			if (text[text.Length - 1] != '/' || text[text.Length - 1] != '\\')
			{
				text += "/";
			}
		}
		if (string.IsNullOrEmpty(text2))
		{
			text2 = "OVR_" + DateTime.Now.ToString("hh_mm_ss") + ".png";
		}
		string extension = Path.GetExtension(text2);
		if (extension == ".png")
		{
			flag = true;
		}
		else
		{
			if (!(extension == ".jpg"))
			{
				UnityEngine.Debug.LogError("Unsupported file format" + extension);
				return false;
			}
			flag = false;
		}
		try
		{
			Directory.CreateDirectory(text);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("Failed to create path " + text + " since " + ex.ToString());
			return false;
		}
		Texture2D texture2D = new Texture2D(width * 6, height, TextureFormat.RGB24, mipChain: false);
		if (texture2D == null)
		{
			UnityEngine.Debug.LogError("[OVRScreenshotWizard] Failed creating the texture!");
			return false;
		}
		CubemapFace[] array = new CubemapFace[6]
		{
			CubemapFace.PositiveX,
			CubemapFace.NegativeX,
			CubemapFace.PositiveY,
			CubemapFace.NegativeY,
			CubemapFace.PositiveZ,
			CubemapFace.NegativeZ
		};
		for (int i = 0; i < array.Length; i++)
		{
			Color[] array2 = null;
			Color[] pixels = cubemap.GetPixels(array[i]);
			array2 = new Color[pixels.Length];
			for (int j = 0; j < height; j++)
			{
				for (int k = 0; k < width; k++)
				{
					array2[j * width + k] = pixels[(height - 1 - j) * width + k];
				}
			}
			texture2D.SetPixels(num, y, width, height, array2);
			num += width;
		}
		try
		{
			byte[] bytes = (flag ? texture2D.EncodeToPNG() : texture2D.EncodeToJPG());
			File.WriteAllBytes(text + text2, bytes);
			UnityEngine.Debug.Log("Cubemap file created " + text + text2);
		}
		catch (Exception ex2)
		{
			UnityEngine.Debug.LogError("Failed to save cubemap file since " + ex2.ToString());
			return false;
		}
		UnityEngine.Object.DestroyImmediate(texture2D);
		return true;
	}
}
public class OVRDebugInfo : MonoBehaviour
{
	private GameObject debugUIManager;

	private GameObject debugUIObject;

	private GameObject riftPresent;

	private GameObject fps;

	private GameObject ipd;

	private GameObject fov;

	private GameObject height;

	private GameObject depth;

	private GameObject resolutionEyeTexture;

	private GameObject latencies;

	private GameObject texts;

	private string strRiftPresent;

	private string strFPS;

	private string strIPD;

	private string strFOV;

	private string strHeight;

	private string strDepth;

	private string strResolutionEyeTexture;

	private string strLatencies;

	private float updateInterval = 0.5f;

	private float accum;

	private int frames;

	private float timeLeft;

	private bool initUIComponent;

	private bool isInited;

	private float offsetY = 55f;

	private float riftPresentTimeout;

	private bool showVRVars;

	private void Awake()
	{
		debugUIManager = new GameObject();
		debugUIManager.name = "DebugUIManager";
		debugUIManager.transform.parent = GameObject.Find("LeftEyeAnchor").transform;
		RectTransform rectTransform = debugUIManager.AddComponent<RectTransform>();
		rectTransform.sizeDelta = new Vector2(100f, 100f);
		rectTransform.localScale = new Vector3(0.001f, 0.001f, 0.001f);
		rectTransform.localPosition = new Vector3(0.01f, 0.17f, 0.53f);
		rectTransform.localEulerAngles = Vector3.zero;
		Canvas canvas = debugUIManager.AddComponent<Canvas>();
		canvas.renderMode = RenderMode.WorldSpace;
		canvas.pixelPerfect = false;
	}

	private void Update()
	{
		if (initUIComponent && !isInited)
		{
			InitUIComponents();
		}
		if (Input.GetKeyDown(KeyCode.Space) && riftPresentTimeout < 0f)
		{
			initUIComponent = true;
			showVRVars = !showVRVars;
		}
		UpdateDeviceDetection();
		if (showVRVars)
		{
			debugUIManager.SetActive(value: true);
			UpdateVariable();
			UpdateStrings();
		}
		else
		{
			debugUIManager.SetActive(value: false);
		}
	}

	private void OnDestroy()
	{
		isInited = false;
	}

	private void InitUIComponents()
	{
		float num = 0f;
		int fontSize = 20;
		debugUIObject = new GameObject();
		debugUIObject.name = "DebugInfo";
		debugUIObject.transform.parent = GameObject.Find("DebugUIManager").transform;
		debugUIObject.transform.localPosition = new Vector3(0f, 100f, 0f);
		debugUIObject.transform.localEulerAngles = Vector3.zero;
		debugUIObject.transform.localScale = new Vector3(1f, 1f, 1f);
		if (!string.IsNullOrEmpty(strFPS))
		{
			fps = VariableObjectManager(fps, "FPS", num -= offsetY, strFPS, fontSize);
		}
		if (!string.IsNullOrEmpty(strIPD))
		{
			ipd = VariableObjectManager(ipd, "IPD", num -= offsetY, strIPD, fontSize);
		}
		if (!string.IsNullOrEmpty(strFOV))
		{
			fov = VariableObjectManager(fov, "FOV", num -= offsetY, strFOV, fontSize);
		}
		if (!string.IsNullOrEmpty(strHeight))
		{
			height = VariableObjectManager(height, "Height", num -= offsetY, strHeight, fontSize);
		}
		if (!string.IsNullOrEmpty(strDepth))
		{
			depth = VariableObjectManager(depth, "Depth", num -= offsetY, strDepth, fontSize);
		}
		if (!string.IsNullOrEmpty(strResolutionEyeTexture))
		{
			resolutionEyeTexture = VariableObjectManager(resolutionEyeTexture, "Resolution", num -= offsetY, strResolutionEyeTexture, fontSize);
		}
		if (!string.IsNullOrEmpty(strLatencies))
		{
			latencies = VariableObjectManager(latencies, "Latency", num -= offsetY, strLatencies, 17);
			num = 0f;
		}
		initUIComponent = false;
		isInited = true;
	}

	private void UpdateVariable()
	{
		UpdateIPD();
		UpdateEyeHeightOffset();
		UpdateEyeDepthOffset();
		UpdateFOV();
		UpdateResolutionEyeTexture();
		UpdateLatencyValues();
		UpdateFPS();
	}

	private void UpdateStrings()
	{
		if (!(debugUIObject == null))
		{
			if (!string.IsNullOrEmpty(strFPS))
			{
				fps.GetComponentInChildren<Text>().text = strFPS;
			}
			if (!string.IsNullOrEmpty(strIPD))
			{
				ipd.GetComponentInChildren<Text>().text = strIPD;
			}
			if (!string.IsNullOrEmpty(strFOV))
			{
				fov.GetComponentInChildren<Text>().text = strFOV;
			}
			if (!string.IsNullOrEmpty(strResolutionEyeTexture))
			{
				resolutionEyeTexture.GetComponentInChildren<Text>().text = strResolutionEyeTexture;
			}
			if (!string.IsNullOrEmpty(strLatencies))
			{
				latencies.GetComponentInChildren<Text>().text = strLatencies;
				latencies.GetComponentInChildren<Text>().fontSize = 14;
			}
			if (!string.IsNullOrEmpty(strHeight))
			{
				height.GetComponentInChildren<Text>().text = strHeight;
			}
			if (!string.IsNullOrEmpty(strDepth))
			{
				depth.GetComponentInChildren<Text>().text = strDepth;
			}
		}
	}

	private void RiftPresentGUI(GameObject guiMainOBj)
	{
		riftPresent = ComponentComposition(riftPresent);
		riftPresent.transform.SetParent(guiMainOBj.transform);
		riftPresent.name = "RiftPresent";
		RectTransform component = riftPresent.GetComponent<RectTransform>();
		component.localPosition = new Vector3(0f, 0f, 0f);
		component.localScale = new Vector3(1f, 1f, 1f);
		component.localEulerAngles = Vector3.zero;
		Text componentInChildren = riftPresent.GetComponentInChildren<Text>();
		componentInChildren.text = strRiftPresent;
		componentInChildren.fontSize = 20;
	}

	private void UpdateDeviceDetection()
	{
		if (riftPresentTimeout >= 0f)
		{
			riftPresentTimeout -= Time.deltaTime;
		}
	}

	private GameObject VariableObjectManager(GameObject gameObject, string name, float posY, string str, int fontSize)
	{
		gameObject = ComponentComposition(gameObject);
		gameObject.name = name;
		gameObject.transform.SetParent(debugUIObject.transform);
		RectTransform component = gameObject.GetComponent<RectTransform>();
		component.localPosition = new Vector3(0f, posY -= offsetY, 0f);
		Text componentInChildren = gameObject.GetComponentInChildren<Text>();
		componentInChildren.text = str;
		componentInChildren.fontSize = fontSize;
		gameObject.transform.localEulerAngles = Vector3.zero;
		component.localScale = new Vector3(1f, 1f, 1f);
		return gameObject;
	}

	private GameObject ComponentComposition(GameObject GO)
	{
		GO = new GameObject();
		GO.AddComponent<RectTransform>();
		GO.AddComponent<CanvasRenderer>();
		GO.AddComponent<Image>();
		GO.GetComponent<RectTransform>().sizeDelta = new Vector2(350f, 50f);
		GO.GetComponent<Image>().color = new Color(0.02745098f, 0.1764706f, 0.2784314f, 40f / 51f);
		texts = new GameObject();
		texts.AddComponent<RectTransform>();
		texts.AddComponent<CanvasRenderer>();
		texts.AddComponent<Text>();
		texts.GetComponent<RectTransform>().sizeDelta = new Vector2(350f, 50f);
		texts.GetComponent<Text>().font = Resources.GetBuiltinResource(typeof(Font), "Arial.ttf") as Font;
		texts.GetComponent<Text>().alignment = TextAnchor.MiddleCenter;
		texts.transform.SetParent(GO.transform);
		texts.name = "TextBox";
		return GO;
	}

	private void UpdateIPD()
	{
		strIPD = $"IPD (mm): {OVRManager.profile.ipd * 1000f:F4}";
	}

	private void UpdateEyeHeightOffset()
	{
		float eyeHeight = OVRManager.profile.eyeHeight;
		strHeight = $"Eye Height (m): {eyeHeight:F3}";
	}

	private void UpdateEyeDepthOffset()
	{
		float eyeDepth = OVRManager.profile.eyeDepth;
		strDepth = $"Eye Depth (m): {eyeDepth:F3}";
	}

	private void UpdateFOV()
	{
		strFOV = $"FOV (deg): {OVRManager.display.GetEyeRenderDesc(XRNode.LeftEye).fov.y:F3}";
	}

	private void UpdateResolutionEyeTexture()
	{
		OVRDisplay.EyeRenderDesc eyeRenderDesc = OVRManager.display.GetEyeRenderDesc(XRNode.LeftEye);
		OVRDisplay.EyeRenderDesc eyeRenderDesc2 = OVRManager.display.GetEyeRenderDesc(XRNode.RightEye);
		float renderViewportScale = XRSettings.renderViewportScale;
		float num = (int)(renderViewportScale * (eyeRenderDesc.resolution.x + eyeRenderDesc2.resolution.x));
		float num2 = (int)(renderViewportScale * Mathf.Max(eyeRenderDesc.resolution.y, eyeRenderDesc2.resolution.y));
		strResolutionEyeTexture = $"Resolution : {num} x {num2}";
	}

	private void UpdateLatencyValues()
	{
	}

	private void UpdateFPS()
	{
		timeLeft -= Time.unscaledDeltaTime;
		accum += Time.unscaledDeltaTime;
		frames++;
		if ((double)timeLeft <= 0.0)
		{
			float num = (float)frames / accum;
			strFPS = $"FPS: {num:F2}";
			timeLeft += updateInterval;
			accum = 0f;
			frames = 0;
		}
	}
}
public class OVRGazePointer : MonoBehaviour
{
	private Transform gazeIcon;

	[Tooltip("Should the pointer be hidden when not over interactive objects.")]
	public bool hideByDefault = true;

	[Tooltip("Time after leaving interactive object before pointer fades.")]
	public float showTimeoutPeriod = 1f;

	[Tooltip("Time after mouse pointer becoming inactive before pointer unfades.")]
	public float hideTimeoutPeriod = 0.1f;

	[Tooltip("Keep a faint version of the pointer visible while using a mouse")]
	public bool dimOnHideRequest = true;

	[Tooltip("Angular scale of pointer")]
	public float depthScaleMultiplier = 0.03f;

	public Transform rayTransform;

	private float depth;

	private float hideUntilTime;

	private int positionSetsThisFrame;

	private float lastShowRequestTime;

	private float lastHideRequestTime;

	[Tooltip("Radius of the cursor. Used for preventing geometry intersections.")]
	public float cursorRadius = 1f;

	private OVRProgressIndicator progressIndicator;

	private static OVRGazePointer _instance;

	public bool hidden { get; private set; }

	public float currentScale { get; private set; }

	public static OVRGazePointer instance
	{
		get
		{
			if (_instance == null)
			{
				UnityEngine.Debug.Log(string.Format("Instanciating GazePointer", 0));
				_instance = UnityEngine.Object.Instantiate((OVRGazePointer)Resources.Load("Prefabs/GazePointerRing", typeof(OVRGazePointer)));
			}
			return _instance;
		}
	}

	public float visibilityStrength
	{
		get
		{
			float a = ((!hideByDefault) ? 1f : Mathf.Clamp01(1f - (Time.time - lastShowRequestTime) / showTimeoutPeriod));
			float b = ((!(lastHideRequestTime + hideTimeoutPeriod > Time.time)) ? 1f : (dimOnHideRequest ? 0.1f : 0f));
			return Mathf.Min(a, b);
		}
	}

	public float SelectionProgress
	{
		get
		{
			if (!progressIndicator)
			{
				return 0f;
			}
			return progressIndicator.currentProgress;
		}
		set
		{
			if ((bool)progressIndicator)
			{
				progressIndicator.currentProgress = value;
			}
		}
	}

	public void Awake()
	{
		currentScale = 1f;
		if (_instance != null && _instance != this)
		{
			base.enabled = false;
			UnityEngine.Object.DestroyImmediate(this);
		}
		else
		{
			_instance = this;
			gazeIcon = base.transform.Find("GazeIcon");
			progressIndicator = base.transform.GetComponent<OVRProgressIndicator>();
		}
	}

	private void Update()
	{
		if (rayTransform == null && Camera.main != null)
		{
			rayTransform = Camera.main.transform;
		}
		base.transform.position = rayTransform.position + rayTransform.forward * depth;
		if (visibilityStrength == 0f && !hidden)
		{
			Hide();
		}
		else if (visibilityStrength > 0f && hidden)
		{
			Show();
		}
	}

	public void SetPosition(Vector3 pos, Vector3 normal)
	{
		base.transform.position = pos;
		Quaternion rotation = base.transform.rotation;
		rotation.SetLookRotation(normal, rayTransform.up);
		base.transform.rotation = rotation;
		depth = (rayTransform.position - pos).magnitude;
		currentScale = depth * depthScaleMultiplier;
		base.transform.localScale = new Vector3(currentScale, currentScale, currentScale);
		positionSetsThisFrame++;
	}

	public void SetPosition(Vector3 pos)
	{
		SetPosition(pos, rayTransform.forward);
	}

	public float GetCurrentRadius()
	{
		return cursorRadius * currentScale;
	}

	private void LateUpdate()
	{
		if (positionSetsThisFrame == 0)
		{
			Quaternion rotation = base.transform.rotation;
			rotation.SetLookRotation(rayTransform.forward, rayTransform.up);
			base.transform.rotation = rotation;
		}
		Quaternion rotation2 = gazeIcon.rotation;
		rotation2.SetLookRotation(base.transform.rotation * new Vector3(0f, 0f, 1f));
		gazeIcon.rotation = rotation2;
		positionSetsThisFrame = 0;
	}

	public void RequestHide()
	{
		if (!dimOnHideRequest)
		{
			Hide();
		}
		lastHideRequestTime = Time.time;
	}

	public void RequestShow()
	{
		Show();
		lastShowRequestTime = Time.time;
	}

	private void Hide()
	{
		foreach (Transform item in base.transform)
		{
			item.gameObject.SetActive(value: false);
		}
		if ((bool)GetComponent<Renderer>())
		{
			GetComponent<Renderer>().enabled = false;
		}
		hidden = true;
	}

	private void Show()
	{
		foreach (Transform item in base.transform)
		{
			item.gameObject.SetActive(value: true);
		}
		if ((bool)GetComponent<Renderer>())
		{
			GetComponent<Renderer>().enabled = true;
		}
		hidden = false;
	}
}
public class OVRGearVrControllerTest : MonoBehaviour
{
	public class BoolMonitor
	{
		public delegate bool BoolGenerator();

		private string m_name = "";

		private BoolGenerator m_generator;

		private bool m_prevValue;

		private bool m_currentValue;

		private bool m_currentValueRecentlyChanged;

		private float m_displayTimeout;

		private float m_displayTimer;

		public BoolMonitor(string name, BoolGenerator generator, float displayTimeout = 0.5f)
		{
			m_name = name;
			m_generator = generator;
			m_displayTimeout = displayTimeout;
		}

		public void Update()
		{
			m_prevValue = m_currentValue;
			m_currentValue = m_generator();
			if (m_currentValue != m_prevValue)
			{
				m_currentValueRecentlyChanged = true;
				m_displayTimer = m_displayTimeout;
			}
			if (m_displayTimer > 0f)
			{
				m_displayTimer -= Time.deltaTime;
				if (m_displayTimer <= 0f)
				{
					m_currentValueRecentlyChanged = false;
					m_displayTimer = 0f;
				}
			}
		}

		public void AppendToStringBuilder(ref StringBuilder sb)
		{
			sb.Append(m_name);
			if (m_currentValue && m_currentValueRecentlyChanged)
			{
				sb.Append(": *True*\n");
			}
			else if (m_currentValue)
			{
				sb.Append(":  True \n");
			}
			else if (!m_currentValue && m_currentValueRecentlyChanged)
			{
				sb.Append(": *False*\n");
			}
			else if (!m_currentValue)
			{
				sb.Append(":  False \n");
			}
		}
	}

	public Text uiText;

	private List<BoolMonitor> monitors;

	private StringBuilder data;

	private static string prevConnected = "";

	private static BoolMonitor controllers = new BoolMonitor("Controllers Changed", () => OVRInput.GetConnectedControllers().ToString() != prevConnected);

	private void Start()
	{
		if (uiText != null)
		{
			uiText.supportRichText = false;
		}
		data = new StringBuilder(2048);
		monitors = new List<BoolMonitor>
		{
			new BoolMonitor("WasRecentered", () => OVRInput.GetControllerWasRecentered()),
			new BoolMonitor("One", () => OVRInput.Get(OVRInput.Button.One)),
			new BoolMonitor("OneDown", () => OVRInput.GetDown(OVRInput.Button.One)),
			new BoolMonitor("OneUp", () => OVRInput.GetUp(OVRInput.Button.One)),
			new BoolMonitor("One (Touch)", () => OVRInput.Get(OVRInput.Touch.One)),
			new BoolMonitor("OneDown (Touch)", () => OVRInput.GetDown(OVRInput.Touch.One)),
			new BoolMonitor("OneUp (Touch)", () => OVRInput.GetUp(OVRInput.Touch.One)),
			new BoolMonitor("Two", () => OVRInput.Get(OVRInput.Button.Two)),
			new BoolMonitor("TwoDown", () => OVRInput.GetDown(OVRInput.Button.Two)),
			new BoolMonitor("TwoUp", () => OVRInput.GetUp(OVRInput.Button.Two)),
			new BoolMonitor("PrimaryIndexTrigger", () => OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger)),
			new BoolMonitor("PrimaryIndexTriggerDown", () => OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger)),
			new BoolMonitor("PrimaryIndexTriggerUp", () => OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger)),
			new BoolMonitor("PrimaryIndexTrigger (Touch)", () => OVRInput.Get(OVRInput.Touch.PrimaryIndexTrigger)),
			new BoolMonitor("PrimaryIndexTriggerDown (Touch)", () => OVRInput.GetDown(OVRInput.Touch.PrimaryIndexTrigger)),
			new BoolMonitor("PrimaryIndexTriggerUp (Touch)", () => OVRInput.GetUp(OVRInput.Touch.PrimaryIndexTrigger)),
			new BoolMonitor("PrimaryHandTrigger", () => OVRInput.Get(OVRInput.Button.PrimaryHandTrigger)),
			new BoolMonitor("PrimaryHandTriggerDown", () => OVRInput.GetDown(OVRInput.Button.PrimaryHandTrigger)),
			new BoolMonitor("PrimaryHandTriggerUp", () => OVRInput.GetUp(OVRInput.Button.PrimaryHandTrigger)),
			new BoolMonitor("Up", () => OVRInput.Get(OVRInput.Button.Up)),
			new BoolMonitor("Down", () => OVRInput.Get(OVRInput.Button.Down)),
			new BoolMonitor("Left", () => OVRInput.Get(OVRInput.Button.Left)),
			new BoolMonitor("Right", () => OVRInput.Get(OVRInput.Button.Right)),
			new BoolMonitor("Touchpad (Click)", () => OVRInput.Get(OVRInput.Button.PrimaryTouchpad)),
			new BoolMonitor("TouchpadDown (Click)", () => OVRInput.GetDown(OVRInput.Button.PrimaryTouchpad)),
			new BoolMonitor("TouchpadUp (Click)", () => OVRInput.GetUp(OVRInput.Button.PrimaryTouchpad)),
			new BoolMonitor("Touchpad (Touch)", () => OVRInput.Get(OVRInput.Touch.PrimaryTouchpad)),
			new BoolMonitor("TouchpadDown (Touch)", () => OVRInput.GetDown(OVRInput.Touch.PrimaryTouchpad)),
			new BoolMonitor("TouchpadUp (Touch)", () => OVRInput.GetUp(OVRInput.Touch.PrimaryTouchpad)),
			new BoolMonitor("Start", () => OVRInput.Get(OVRInput.RawButton.Start)),
			new BoolMonitor("StartDown", () => OVRInput.GetDown(OVRInput.RawButton.Start)),
			new BoolMonitor("StartUp", () => OVRInput.GetUp(OVRInput.RawButton.Start)),
			new BoolMonitor("Back", () => OVRInput.Get(OVRInput.RawButton.Back)),
			new BoolMonitor("BackDown", () => OVRInput.GetDown(OVRInput.RawButton.Back)),
			new BoolMonitor("BackUp", () => OVRInput.GetUp(OVRInput.RawButton.Back)),
			new BoolMonitor("A", () => OVRInput.Get(OVRInput.RawButton.A)),
			new BoolMonitor("ADown", () => OVRInput.GetDown(OVRInput.RawButton.A)),
			new BoolMonitor("AUp", () => OVRInput.GetUp(OVRInput.RawButton.A))
		};
	}

	private void Update()
	{
		OVRInput.Controller activeController = OVRInput.GetActiveController();
		data.Length = 0;
		byte controllerRecenterCount = OVRInput.GetControllerRecenterCount();
		data.AppendFormat("RecenterCount: {0}\n", controllerRecenterCount);
		byte controllerBatteryPercentRemaining = OVRInput.GetControllerBatteryPercentRemaining();
		data.AppendFormat("Battery: {0}\n", controllerBatteryPercentRemaining);
		float appFramerate = OVRPlugin.GetAppFramerate();
		data.AppendFormat("Framerate: {0:F2}\n", appFramerate);
		string arg = activeController.ToString();
		data.AppendFormat("Active: {0}\n", arg);
		string arg2 = OVRInput.GetConnectedControllers().ToString();
		data.AppendFormat("Connected: {0}\n", arg2);
		data.AppendFormat("PrevConnected: {0}\n", prevConnected);
		controllers.Update();
		controllers.AppendToStringBuilder(ref data);
		prevConnected = arg2;
		Quaternion localControllerRotation = OVRInput.GetLocalControllerRotation(activeController);
		data.AppendFormat("Orientation: ({0:F2}, {1:F2}, {2:F2}, {3:F2})\n", localControllerRotation.x, localControllerRotation.y, localControllerRotation.z, localControllerRotation.w);
		Vector3 localControllerAngularVelocity = OVRInput.GetLocalControllerAngularVelocity(activeController);
		data.AppendFormat("AngVel: ({0:F2}, {1:F2}, {2:F2})\n", localControllerAngularVelocity.x, localControllerAngularVelocity.y, localControllerAngularVelocity.z);
		Vector3 localControllerAngularAcceleration = OVRInput.GetLocalControllerAngularAcceleration(activeController);
		data.AppendFormat("AngAcc: ({0:F2}, {1:F2}, {2:F2})\n", localControllerAngularAcceleration.x, localControllerAngularAcceleration.y, localControllerAngularAcceleration.z);
		Vector3 localControllerPosition = OVRInput.GetLocalControllerPosition(activeController);
		data.AppendFormat("Position: ({0:F2}, {1:F2}, {2:F2})\n", localControllerPosition.x, localControllerPosition.y, localControllerPosition.z);
		Vector3 localControllerVelocity = OVRInput.GetLocalControllerVelocity(activeController);
		data.AppendFormat("Vel: ({0:F2}, {1:F2}, {2:F2})\n", localControllerVelocity.x, localControllerVelocity.y, localControllerVelocity.z);
		Vector3 localControllerAcceleration = OVRInput.GetLocalControllerAcceleration(activeController);
		data.AppendFormat("Acc: ({0:F2}, {1:F2}, {2:F2})\n", localControllerAcceleration.x, localControllerAcceleration.y, localControllerAcceleration.z);
		Vector2 vector = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad);
		data.AppendFormat("PrimaryTouchpad: ({0:F2}, {1:F2})\n", vector.x, vector.y);
		Vector2 vector2 = OVRInput.Get(OVRInput.Axis2D.SecondaryTouchpad);
		data.AppendFormat("SecondaryTouchpad: ({0:F2}, {1:F2})\n", vector2.x, vector2.y);
		float num = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger);
		data.AppendFormat("PrimaryIndexTriggerAxis1D: ({0:F2})\n", num);
		float num2 = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger);
		data.AppendFormat("PrimaryHandTriggerAxis1D: ({0:F2})\n", num2);
		for (int i = 0; i < monitors.Count; i++)
		{
			monitors[i].Update();
			monitors[i].AppendToStringBuilder(ref data);
		}
		if (uiText != null)
		{
			uiText.text = data.ToString();
		}
	}
}
public class OVRGrabbable : MonoBehaviour
{
	[SerializeField]
	protected bool m_allowOffhandGrab = true;

	[SerializeField]
	protected bool m_snapPosition;

	[SerializeField]
	protected bool m_snapOrientation;

	[SerializeField]
	protected Transform m_snapOffset;

	[SerializeField]
	protected Collider[] m_grabPoints;

	protected bool m_grabbedKinematic;

	protected Collider m_grabbedCollider;

	protected OVRGrabber m_grabbedBy;

	public bool allowOffhandGrab => m_allowOffhandGrab;

	public bool isGrabbed => m_grabbedBy != null;

	public bool snapPosition => m_snapPosition;

	public bool snapOrientation => m_snapOrientation;

	public Transform snapOffset => m_snapOffset;

	public OVRGrabber grabbedBy => m_grabbedBy;

	public Transform grabbedTransform => m_grabbedCollider.transform;

	public Rigidbody grabbedRigidbody => m_grabbedCollider.attachedRigidbody;

	public Collider[] grabPoints => m_grabPoints;

	public virtual void GrabBegin(OVRGrabber hand, Collider grabPoint)
	{
		m_grabbedBy = hand;
		m_grabbedCollider = grabPoint;
		base.gameObject.GetComponent<Rigidbody>().isKinematic = true;
	}

	public virtual void GrabEnd(Vector3 linearVelocity, Vector3 angularVelocity)
	{
		Rigidbody component = base.gameObject.GetComponent<Rigidbody>();
		component.isKinematic = m_grabbedKinematic;
		component.velocity = linearVelocity;
		component.angularVelocity = angularVelocity;
		m_grabbedBy = null;
		m_grabbedCollider = null;
	}

	private void Awake()
	{
		if (m_grabPoints.Length == 0)
		{
			Collider component = GetComponent<Collider>();
			if (component == null)
			{
				throw new ArgumentException("Grabbables cannot have zero grab points and no collider -- please add a grab point or collider.");
			}
			m_grabPoints = new Collider[1] { component };
		}
	}

	protected virtual void Start()
	{
		m_grabbedKinematic = GetComponent<Rigidbody>().isKinematic;
	}

	private void OnDestroy()
	{
		if (m_grabbedBy != null)
		{
			m_grabbedBy.ForceRelease(this);
		}
	}
}
[RequireComponent(typeof(Rigidbody))]
public class OVRGrabber : MonoBehaviour
{
	public float grabBegin = 0.55f;

	public float grabEnd = 0.35f;

	[SerializeField]
	protected bool m_parentHeldObject;

	[SerializeField]
	protected Transform m_gripTransform;

	[SerializeField]
	protected Collider[] m_grabVolumes;

	[SerializeField]
	protected OVRInput.Controller m_controller;

	[SerializeField]
	protected Transform m_parentTransform;

	protected bool m_grabVolumeEnabled = true;

	protected Vector3 m_lastPos;

	protected Quaternion m_lastRot;

	protected Quaternion m_anchorOffsetRotation;

	protected Vector3 m_anchorOffsetPosition;

	protected float m_prevFlex;

	protected OVRGrabbable m_grabbedObj;

	protected Vector3 m_grabbedObjectPosOff;

	protected Quaternion m_grabbedObjectRotOff;

	protected Dictionary<OVRGrabbable, int> m_grabCandidates = new Dictionary<OVRGrabbable, int>();

	protected bool operatingWithoutOVRCameraRig = true;

	public OVRGrabbable grabbedObject => m_grabbedObj;

	public void ForceRelease(OVRGrabbable grabbable)
	{
		if (m_grabbedObj != null && m_grabbedObj == grabbable)
		{
			GrabEnd();
		}
	}

	protected virtual void Awake()
	{
		m_anchorOffsetPosition = base.transform.localPosition;
		m_anchorOffsetRotation = base.transform.localRotation;
		OVRCameraRig oVRCameraRig = null;
		if (base.transform.parent != null && base.transform.parent.parent != null)
		{
			oVRCameraRig = base.transform.parent.parent.GetComponent<OVRCameraRig>();
		}
		if (oVRCameraRig != null)
		{
			oVRCameraRig.UpdatedAnchors += delegate
			{
				OnUpdatedAnchors();
			};
			operatingWithoutOVRCameraRig = false;
		}
	}

	protected virtual void Start()
	{
		m_lastPos = base.transform.position;
		m_lastRot = base.transform.rotation;
		if (m_parentTransform == null)
		{
			if (base.gameObject.transform.parent != null)
			{
				m_parentTransform = base.gameObject.transform.parent.transform;
				return;
			}
			m_parentTransform = new GameObject().transform;
			m_parentTransform.position = Vector3.zero;
			m_parentTransform.rotation = Quaternion.identity;
		}
	}

	private void FixedUpdate()
	{
		if (operatingWithoutOVRCameraRig)
		{
			OnUpdatedAnchors();
		}
	}

	private void OnUpdatedAnchors()
	{
		Vector3 localControllerPosition = OVRInput.GetLocalControllerPosition(m_controller);
		Quaternion localControllerRotation = OVRInput.GetLocalControllerRotation(m_controller);
		Vector3 vector = m_parentTransform.TransformPoint(m_anchorOffsetPosition + localControllerPosition);
		Quaternion rot = m_parentTransform.rotation * localControllerRotation * m_anchorOffsetRotation;
		GetComponent<Rigidbody>().MovePosition(vector);
		GetComponent<Rigidbody>().MoveRotation(rot);
		if (!m_parentHeldObject)
		{
			MoveGrabbedObject(vector, rot);
		}
		m_lastPos = base.transform.position;
		m_lastRot = base.transform.rotation;
		float prevFlex = m_prevFlex;
		m_prevFlex = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller);
		CheckForGrabOrRelease(prevFlex);
	}

	private void OnDestroy()
	{
		if (m_grabbedObj != null)
		{
			GrabEnd();
		}
	}

	private void OnTriggerEnter(Collider otherCollider)
	{
		OVRGrabbable oVRGrabbable = otherCollider.GetComponent<OVRGrabbable>() ?? otherCollider.GetComponentInParent<OVRGrabbable>();
		if (!(oVRGrabbable == null))
		{
			int value = 0;
			m_grabCandidates.TryGetValue(oVRGrabbable, out value);
			m_grabCandidates[oVRGrabbable] = value + 1;
		}
	}

	private void OnTriggerExit(Collider otherCollider)
	{
		OVRGrabbable oVRGrabbable = otherCollider.GetComponent<OVRGrabbable>() ?? otherCollider.GetComponentInParent<OVRGrabbable>();
		if (oVRGrabbable == null)
		{
			return;
		}
		int value = 0;
		if (m_grabCandidates.TryGetValue(oVRGrabbable, out value))
		{
			if (value > 1)
			{
				m_grabCandidates[oVRGrabbable] = value - 1;
			}
			else
			{
				m_grabCandidates.Remove(oVRGrabbable);
			}
		}
	}

	protected void CheckForGrabOrRelease(float prevFlex)
	{
		if (m_prevFlex >= grabBegin && prevFlex < grabBegin)
		{
			GrabBegin();
		}
		else if (m_prevFlex <= grabEnd && prevFlex > grabEnd)
		{
			GrabEnd();
		}
	}

	protected virtual void GrabBegin()
	{
		float num = float.MaxValue;
		OVRGrabbable oVRGrabbable = null;
		Collider grabPoint = null;
		foreach (OVRGrabbable key in m_grabCandidates.Keys)
		{
			if (key.isGrabbed && !key.allowOffhandGrab)
			{
				continue;
			}
			for (int i = 0; i < key.grabPoints.Length; i++)
			{
				Collider collider = key.grabPoints[i];
				Vector3 vector = collider.ClosestPointOnBounds(m_gripTransform.position);
				float sqrMagnitude = (m_gripTransform.position - vector).sqrMagnitude;
				if (sqrMagnitude < num)
				{
					num = sqrMagnitude;
					oVRGrabbable = key;
					grabPoint = collider;
				}
			}
		}
		GrabVolumeEnable(enabled: false);
		if (!(oVRGrabbable != null))
		{
			return;
		}
		if (oVRGrabbable.isGrabbed)
		{
			oVRGrabbable.grabbedBy.OffhandGrabbed(oVRGrabbable);
		}
		m_grabbedObj = oVRGrabbable;
		m_grabbedObj.GrabBegin(this, grabPoint);
		m_lastPos = base.transform.position;
		m_lastRot = base.transform.rotation;
		if (m_grabbedObj.snapPosition)
		{
			m_grabbedObjectPosOff = m_gripTransform.localPosition;
			if ((bool)m_grabbedObj.snapOffset)
			{
				Vector3 position = m_grabbedObj.snapOffset.position;
				if (m_controller == OVRInput.Controller.LTouch)
				{
					position.x = 0f - position.x;
				}
				m_grabbedObjectPosOff += position;
			}
		}
		else
		{
			Vector3 vector2 = m_grabbedObj.transform.position - base.transform.position;
			vector2 = Quaternion.Inverse(base.transform.rotation) * vector2;
			m_grabbedObjectPosOff = vector2;
		}
		if (m_grabbedObj.snapOrientation)
		{
			m_grabbedObjectRotOff = m_gripTransform.localRotation;
			if ((bool)m_grabbedObj.snapOffset)
			{
				m_grabbedObjectRotOff = m_grabbedObj.snapOffset.rotation * m_grabbedObjectRotOff;
			}
		}
		else
		{
			Quaternion grabbedObjectRotOff = Quaternion.Inverse(base.transform.rotation) * m_grabbedObj.transform.rotation;
			m_grabbedObjectRotOff = grabbedObjectRotOff;
		}
		MoveGrabbedObject(m_lastPos, m_lastRot, forceTeleport: true);
		if (m_parentHeldObject)
		{
			m_grabbedObj.transform.parent = base.transform;
		}
	}

	protected virtual void MoveGrabbedObject(Vector3 pos, Quaternion rot, bool forceTeleport = false)
	{
		if (!(m_grabbedObj == null))
		{
			Rigidbody grabbedRigidbody = m_grabbedObj.grabbedRigidbody;
			Vector3 position = pos + rot * m_grabbedObjectPosOff;
			Quaternion quaternion = rot * m_grabbedObjectRotOff;
			if (forceTeleport)
			{
				grabbedRigidbody.transform.position = position;
				grabbedRigidbody.transform.rotation = quaternion;
			}
			else
			{
				grabbedRigidbody.MovePosition(position);
				grabbedRigidbody.MoveRotation(quaternion);
			}
		}
	}

	protected void GrabEnd()
	{
		if (m_grabbedObj != null)
		{
			OVRPose oVRPose = default(OVRPose);
			oVRPose.position = OVRInput.GetLocalControllerPosition(m_controller);
			oVRPose.orientation = OVRInput.GetLocalControllerRotation(m_controller);
			OVRPose oVRPose2 = oVRPose;
			oVRPose = default(OVRPose);
			oVRPose.position = m_anchorOffsetPosition;
			oVRPose.orientation = m_anchorOffsetRotation;
			OVRPose oVRPose3 = oVRPose;
			oVRPose2 *= oVRPose3;
			OVRPose oVRPose4 = base.transform.ToOVRPose() * oVRPose2.Inverse();
			Vector3 linearVelocity = oVRPose4.orientation * OVRInput.GetLocalControllerVelocity(m_controller);
			Vector3 angularVelocity = oVRPose4.orientation * OVRInput.GetLocalControllerAngularVelocity(m_controller);
			GrabbableRelease(linearVelocity, angularVelocity);
		}
		GrabVolumeEnable(enabled: true);
	}

	protected void GrabbableRelease(Vector3 linearVelocity, Vector3 angularVelocity)
	{
		m_grabbedObj.GrabEnd(linearVelocity, angularVelocity);
		if (m_parentHeldObject)
		{
			m_grabbedObj.transform.parent = null;
		}
		m_grabbedObj = null;
	}

	protected virtual void GrabVolumeEnable(bool enabled)
	{
		if (m_grabVolumeEnabled != enabled)
		{
			m_grabVolumeEnabled = enabled;
			for (int i = 0; i < m_grabVolumes.Length; i++)
			{
				m_grabVolumes[i].enabled = m_grabVolumeEnabled;
			}
			if (!m_grabVolumeEnabled)
			{
				m_grabCandidates.Clear();
			}
		}
	}

	protected virtual void OffhandGrabbed(OVRGrabbable grabbable)
	{
		if (m_grabbedObj == grabbable)
		{
			GrabbableRelease(Vector3.zero, Vector3.zero);
		}
	}
}
public class OVRGridCube : MonoBehaviour
{
	public KeyCode GridKey = KeyCode.G;

	private GameObject CubeGrid;

	private bool CubeGridOn;

	private bool CubeSwitchColorOld;

	private bool CubeSwitchColor;

	private int gridSizeX = 6;

	private int gridSizeY = 4;

	private int gridSizeZ = 6;

	private float gridScale = 0.3f;

	private float cubeScale = 0.03f;

	private OVRCameraRig CameraController;

	private void Update()
	{
		UpdateCubeGrid();
	}

	public void SetOVRCameraController(ref OVRCameraRig cameraController)
	{
		CameraController = cameraController;
	}

	private void UpdateCubeGrid()
	{
		if (Input.GetKeyDown(GridKey))
		{
			if (!CubeGridOn)
			{
				CubeGridOn = true;
				UnityEngine.Debug.LogWarning("CubeGrid ON");
				if (CubeGrid != null)
				{
					CubeGrid.SetActive(value: true);
				}
				else
				{
					CreateCubeGrid();
				}
			}
			else
			{
				CubeGridOn = false;
				UnityEngine.Debug.LogWarning("CubeGrid OFF");
				if (CubeGrid != null)
				{
					CubeGrid.SetActive(value: false);
				}
			}
		}
		if (CubeGrid != null)
		{
			CubeSwitchColor = !OVRManager.tracker.isPositionTracked;
			if (CubeSwitchColor != CubeSwitchColorOld)
			{
				CubeGridSwitchColor(CubeSwitchColor);
			}
			CubeSwitchColorOld = CubeSwitchColor;
		}
	}

	private void CreateCubeGrid()
	{
		UnityEngine.Debug.LogWarning("Create CubeGrid");
		CubeGrid = new GameObject("CubeGrid");
		CubeGrid.layer = CameraController.gameObject.layer;
		for (int i = -gridSizeX; i <= gridSizeX; i++)
		{
			for (int j = -gridSizeY; j <= gridSizeY; j++)
			{
				for (int k = -gridSizeZ; k <= gridSizeZ; k++)
				{
					int num = 0;
					if ((i == 0 && j == 0) || (i == 0 && k == 0) || (j == 0 && k == 0))
					{
						num = ((i != 0 || j != 0 || k != 0) ? 1 : 2);
					}
					GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);
					obj.GetComponent<BoxCollider>().enabled = false;
					obj.layer = CameraController.gameObject.layer;
					Renderer component = obj.GetComponent<Renderer>();
					component.shadowCastingMode = ShadowCastingMode.Off;
					component.receiveShadows = false;
					switch (num)
					{
					case 0:
						component.material.color = Color.red;
						break;
					case 1:
						component.material.color = Color.white;
						break;
					default:
						component.material.color = Color.yellow;
						break;
					}
					obj.transform.position = new Vector3((float)i * gridScale, (float)j * gridScale, (float)k * gridScale);
					float num2 = 0.7f;
					if (num == 1)
					{
						num2 = 1f;
					}
					if (num == 2)
					{
						num2 = 2f;
					}
					obj.transform.localScale = new Vector3(cubeScale * num2, cubeScale * num2, cubeScale * num2);
					obj.transform.parent = CubeGrid.transform;
				}
			}
		}
	}

	private void CubeGridSwitchColor(bool CubeSwitchColor)
	{
		Color color = Color.red;
		if (CubeSwitchColor)
		{
			color = Color.blue;
		}
		foreach (Transform item in CubeGrid.transform)
		{
			Material material = item.GetComponent<Renderer>().material;
			if (material.color == Color.red || material.color == Color.blue)
			{
				material.color = color;
			}
		}
	}
}
public class OVRModeParms : MonoBehaviour
{
	public OVRInput.RawButton resetButton = OVRInput.RawButton.X;

	private void Start()
	{
		if (!OVRManager.isHmdPresent)
		{
			base.enabled = false;
		}
		else
		{
			InvokeRepeating("TestPowerStateMode", 10f, 10f);
		}
	}

	private void Update()
	{
		if (OVRInput.GetDown(resetButton))
		{
			OVRPlugin.cpuLevel = 0;
			OVRPlugin.gpuLevel = 1;
		}
	}

	private void TestPowerStateMode()
	{
		if (OVRPlugin.powerSaving)
		{
			UnityEngine.Debug.Log("POWER SAVE MODE ACTIVATED");
		}
	}
}
public class OVRMonoscopic : MonoBehaviour
{
	public OVRInput.RawButton toggleButton = OVRInput.RawButton.B;

	private bool monoscopic;

	private void Update()
	{
		if (OVRInput.GetDown(toggleButton))
		{
			monoscopic = !monoscopic;
			OVRManager.instance.monoscopic = monoscopic;
		}
	}
}
[RequireComponent(typeof(CharacterController))]
public class OVRPlayerController : MonoBehaviour
{
	public float Acceleration = 0.1f;

	public float Damping = 0.3f;

	public float BackAndSideDampen = 0.5f;

	public float JumpForce = 0.3f;

	public float RotationAmount = 1.5f;

	public float RotationRatchet = 45f;

	[Tooltip("The player will rotate in fixed steps if Snap Rotation is enabled.")]
	public bool SnapRotation = true;

	[Tooltip("How many fixed speeds to use with linear movement? 0=linear control")]
	public int FixedSpeedSteps;

	public bool HmdResetsY = true;

	public bool HmdRotatesY = true;

	public float GravityModifier = 0.379f;

	public bool useProfileData = true;

	[NonSerialized]
	public float CameraHeight;

	[NonSerialized]
	public bool Teleported;

	public bool EnableLinearMovement = true;

	public bool EnableRotation = true;

	protected CharacterController Controller;

	protected OVRCameraRig CameraRig;

	private float MoveScale = 1f;

	private Vector3 MoveThrottle = Vector3.zero;

	private float FallSpeed;

	private OVRPose? InitialPose;

	private float MoveScaleMultiplier = 1f;

	private float RotationScaleMultiplier = 1f;

	private bool SkipMouseRotation = true;

	private bool HaltUpdateMovement;

	private bool prevHatLeft;

	private bool prevHatRight;

	private float SimulationRate = 60f;

	private float buttonRotation;

	private bool ReadyToSnapTurn;

	public float InitialYRotation { get; private set; }

	public event Action<Transform> TransformUpdated;

	public event Action CameraUpdated;

	public event Action PreCharacterMove;

	private void Start()
	{
		Vector3 localPosition = CameraRig.transform.localPosition;
		localPosition.z = OVRManager.profile.eyeDepth;
		CameraRig.transform.localPosition = localPosition;
	}

	private void Awake()
	{
		Controller = base.gameObject.GetComponent<CharacterController>();
		if (Controller == null)
		{
			UnityEngine.Debug.LogWarning("OVRPlayerController: No CharacterController attached.");
		}
		OVRCameraRig[] componentsInChildren = base.gameObject.GetComponentsInChildren<OVRCameraRig>();
		if (componentsInChildren.Length == 0)
		{
			UnityEngine.Debug.LogWarning("OVRPlayerController: No OVRCameraRig attached.");
		}
		else if (componentsInChildren.Length > 1)
		{
			UnityEngine.Debug.LogWarning("OVRPlayerController: More then 1 OVRCameraRig attached.");
		}
		else
		{
			CameraRig = componentsInChildren[0];
		}
		InitialYRotation = base.transform.rotation.eulerAngles.y;
	}

	private void OnEnable()
	{
		OVRManager.display.RecenteredPose += ResetOrientation;
		if (CameraRig != null)
		{
			CameraRig.UpdatedAnchors += UpdateTransform;
		}
	}

	private void OnDisable()
	{
		OVRManager.display.RecenteredPose -= ResetOrientation;
		if (CameraRig != null)
		{
			CameraRig.UpdatedAnchors -= UpdateTransform;
		}
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Q))
		{
			buttonRotation -= RotationRatchet;
		}
		if (Input.GetKeyDown(KeyCode.E))
		{
			buttonRotation += RotationRatchet;
		}
	}

	protected virtual void UpdateController()
	{
		if (useProfileData)
		{
			if (!InitialPose.HasValue)
			{
				InitialPose = new OVRPose
				{
					position = CameraRig.transform.localPosition,
					orientation = CameraRig.transform.localRotation
				};
			}
			Vector3 localPosition = CameraRig.transform.localPosition;
			if (OVRManager.instance.trackingOriginType == OVRManager.TrackingOrigin.EyeLevel)
			{
				localPosition.y = OVRManager.profile.eyeHeight - 0.5f * Controller.height + Controller.center.y;
			}
			else if (OVRManager.instance.trackingOriginType == OVRManager.TrackingOrigin.FloorLevel)
			{
				localPosition.y = 0f - 0.5f * Controller.height + Controller.center.y;
			}
			CameraRig.transform.localPosition = localPosition;
		}
		else if (InitialPose.HasValue)
		{
			CameraRig.transform.localPosition = InitialPose.Value.position;
			CameraRig.transform.localRotation = InitialPose.Value.orientation;
			InitialPose = null;
		}
		CameraHeight = CameraRig.centerEyeAnchor.localPosition.y;
		if (this.CameraUpdated != null)
		{
			this.CameraUpdated();
		}
		UpdateMovement();
		Vector3 zero = Vector3.zero;
		float num = 1f + Damping * SimulationRate * Time.deltaTime;
		MoveThrottle.x /= num;
		MoveThrottle.y = ((MoveThrottle.y > 0f) ? (MoveThrottle.y / num) : MoveThrottle.y);
		MoveThrottle.z /= num;
		zero += MoveThrottle * SimulationRate * Time.deltaTime;
		if (Controller.isGrounded && FallSpeed <= 0f)
		{
			FallSpeed = Physics.gravity.y * (GravityModifier * 0.002f);
		}
		else
		{
			FallSpeed += Physics.gravity.y * (GravityModifier * 0.002f) * SimulationRate * Time.deltaTime;
		}
		zero.y += FallSpeed * SimulationRate * Time.deltaTime;
		if (Controller.isGrounded && MoveThrottle.y <= base.transform.lossyScale.y * 0.001f)
		{
			float num2 = Mathf.Max(Controller.stepOffset, new Vector3(zero.x, 0f, zero.z).magnitude);
			zero -= num2 * Vector3.up;
		}
		if (this.PreCharacterMove != null)
		{
			this.PreCharacterMove();
			Teleported = false;
		}
		Vector3 vector = Vector3.Scale(Controller.transform.localPosition + zero, new Vector3(1f, 0f, 1f));
		Controller.Move(zero);
		Vector3 vector2 = Vector3.Scale(Controller.transform.localPosition, new Vector3(1f, 0f, 1f));
		if (vector != vector2)
		{
			MoveThrottle += (vector2 - vector) / (SimulationRate * Time.deltaTime);
		}
	}

	public virtual void UpdateMovement()
	{
		if (HaltUpdateMovement)
		{
			return;
		}
		if (EnableLinearMovement)
		{
			bool flag = Input.GetKey(KeyCode.W) || Input.GetKey(KeyCode.UpArrow);
			bool flag2 = Input.GetKey(KeyCode.A) || Input.GetKey(KeyCode.LeftArrow);
			bool flag3 = Input.GetKey(KeyCode.D) || Input.GetKey(KeyCode.RightArrow);
			bool flag4 = Input.GetKey(KeyCode.S) || Input.GetKey(KeyCode.DownArrow);
			bool flag5 = false;
			if (OVRInput.Get(OVRInput.Button.DpadUp))
			{
				flag = true;
				flag5 = true;
			}
			if (OVRInput.Get(OVRInput.Button.DpadDown))
			{
				flag4 = true;
				flag5 = true;
			}
			MoveScale = 1f;
			if ((flag && flag2) || (flag && flag3) || (flag4 && flag2) || (flag4 && flag3))
			{
				MoveScale = 0.70710677f;
			}
			if (!Controller.isGrounded)
			{
				MoveScale = 0f;
			}
			MoveScale *= SimulationRate * Time.deltaTime;
			float num = Acceleration * 0.1f * MoveScale * MoveScaleMultiplier;
			if (flag5 || Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift))
			{
				num *= 2f;
			}
			Vector3 eulerAngles = base.transform.rotation.eulerAngles;
			eulerAngles.z = (eulerAngles.x = 0f);
			Quaternion quaternion = Quaternion.Euler(eulerAngles);
			if (flag)
			{
				MoveThrottle += quaternion * (base.transform.lossyScale.z * num * Vector3.forward);
			}
			if (flag4)
			{
				MoveThrottle += quaternion * (base.transform.lossyScale.z * num * BackAndSideDampen * Vector3.back);
			}
			if (flag2)
			{
				MoveThrottle += quaternion * (base.transform.lossyScale.x * num * BackAndSideDampen * Vector3.left);
			}
			if (flag3)
			{
				MoveThrottle += quaternion * (base.transform.lossyScale.x * num * BackAndSideDampen * Vector3.right);
			}
			num = Acceleration * 0.1f * MoveScale * MoveScaleMultiplier;
			Vector2 vector = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick);
			if (FixedSpeedSteps > 0)
			{
				vector.y = Mathf.Round(vector.y * (float)FixedSpeedSteps) / (float)FixedSpeedSteps;
				vector.x = Mathf.Round(vector.x * (float)FixedSpeedSteps) / (float)FixedSpeedSteps;
			}
			if (vector.y > 0f)
			{
				MoveThrottle += quaternion * (vector.y * base.transform.lossyScale.z * num * Vector3.forward);
			}
			if (vector.y < 0f)
			{
				MoveThrottle += quaternion * (Mathf.Abs(vector.y) * base.transform.lossyScale.z * num * BackAndSideDampen * Vector3.back);
			}
			if (vector.x < 0f)
			{
				MoveThrottle += quaternion * (Mathf.Abs(vector.x) * base.transform.lossyScale.x * num * BackAndSideDampen * Vector3.left);
			}
			if (vector.x > 0f)
			{
				MoveThrottle += quaternion * (vector.x * base.transform.lossyScale.x * num * BackAndSideDampen * Vector3.right);
			}
		}
		if (!EnableRotation)
		{
			return;
		}
		Vector3 eulerAngles2 = base.transform.rotation.eulerAngles;
		float num2 = SimulationRate * Time.deltaTime * RotationAmount * RotationScaleMultiplier;
		bool flag6 = OVRInput.Get(OVRInput.Button.PrimaryShoulder);
		if (flag6 && !prevHatLeft)
		{
			eulerAngles2.y -= RotationRatchet;
		}
		prevHatLeft = flag6;
		bool flag7 = OVRInput.Get(OVRInput.Button.SecondaryShoulder);
		if (flag7 && !prevHatRight)
		{
			eulerAngles2.y += RotationRatchet;
		}
		prevHatRight = flag7;
		eulerAngles2.y += buttonRotation;
		buttonRotation = 0f;
		if (SnapRotation)
		{
			if (OVRInput.Get(OVRInput.Button.SecondaryThumbstickLeft))
			{
				if (ReadyToSnapTurn)
				{
					eulerAngles2.y -= RotationRatchet;
					ReadyToSnapTurn = false;
				}
			}
			else if (OVRInput.Get(OVRInput.Button.SecondaryThumbstickRight))
			{
				if (ReadyToSnapTurn)
				{
					eulerAngles2.y += RotationRatchet;
					ReadyToSnapTurn = false;
				}
			}
			else
			{
				ReadyToSnapTurn = true;
			}
		}
		else
		{
			Vector2 vector2 = OVRInput.Get(OVRInput.Axis2D.SecondaryThumbstick);
			eulerAngles2.y += vector2.x * num2;
		}
		base.transform.rotation = Quaternion.Euler(eulerAngles2);
	}

	public void UpdateTransform(OVRCameraRig rig)
	{
		Transform trackingSpace = CameraRig.trackingSpace;
		Transform centerEyeAnchor = CameraRig.centerEyeAnchor;
		if (HmdRotatesY && !Teleported)
		{
			Vector3 position = trackingSpace.position;
			Quaternion rotation = trackingSpace.rotation;
			base.transform.rotation = Quaternion.Euler(0f, centerEyeAnchor.rotation.eulerAngles.y, 0f);
			trackingSpace.position = position;
			trackingSpace.rotation = rotation;
		}
		UpdateController();
		if (this.TransformUpdated != null)
		{
			this.TransformUpdated(trackingSpace);
		}
	}

	public bool Jump()
	{
		if (!Controller.isGrounded)
		{
			return false;
		}
		MoveThrottle += new Vector3(0f, base.transform.lossyScale.y * JumpForce, 0f);
		return true;
	}

	public void Stop()
	{
		Controller.Move(Vector3.zero);
		MoveThrottle = Vector3.zero;
		FallSpeed = 0f;
	}

	public void GetMoveScaleMultiplier(ref float moveScaleMultiplier)
	{
		moveScaleMultiplier = MoveScaleMultiplier;
	}

	public void SetMoveScaleMultiplier(float moveScaleMultiplier)
	{
		MoveScaleMultiplier = moveScaleMultiplier;
	}

	public void GetRotationScaleMultiplier(ref float rotationScaleMultiplier)
	{
		rotationScaleMultiplier = RotationScaleMultiplier;
	}

	public void SetRotationScaleMultiplier(float rotationScaleMultiplier)
	{
		RotationScaleMultiplier = rotationScaleMultiplier;
	}

	public void GetSkipMouseRotation(ref bool skipMouseRotation)
	{
		skipMouseRotation = SkipMouseRotation;
	}

	public void SetSkipMouseRotation(bool skipMouseRotation)
	{
		SkipMouseRotation = skipMouseRotation;
	}

	public void GetHaltUpdateMovement(ref bool haltUpdateMovement)
	{
		haltUpdateMovement = HaltUpdateMovement;
	}

	public void SetHaltUpdateMovement(bool haltUpdateMovement)
	{
		HaltUpdateMovement = haltUpdateMovement;
	}

	public void ResetOrientation()
	{
		if (HmdResetsY && !HmdRotatesY)
		{
			Vector3 eulerAngles = base.transform.rotation.eulerAngles;
			eulerAngles.y = InitialYRotation;
			base.transform.rotation = Quaternion.Euler(eulerAngles);
		}
	}
}
public class OVRProgressIndicator : MonoBehaviour
{
	public MeshRenderer progressImage;

	[Range(0f, 1f)]
	public float currentProgress = 0.7f;

	private void Awake()
	{
		progressImage.sortingOrder = 150;
	}

	private void Update()
	{
		progressImage.sharedMaterial.SetFloat("_AlphaCutoff", 1f - currentProgress);
	}
}
[RequireComponent(typeof(Canvas))]
public class OVRRaycaster : GraphicRaycaster, IPointerEnterHandler, IEventSystemHandler
{
	private struct RaycastHit
	{
		public Graphic graphic;

		public Vector3 worldPos;

		public bool fromMouse;
	}

	[Tooltip("A world space pointer for this canvas")]
	public GameObject pointer;

	public int sortOrder;

	[NonSerialized]
	private Canvas m_Canvas;

	[NonSerialized]
	private List<RaycastHit> m_RaycastResults = new List<RaycastHit>();

	[NonSerialized]
	private static readonly List<RaycastHit> s_SortedGraphics = new List<RaycastHit>();

	private Canvas canvas
	{
		get
		{
			if (m_Canvas != null)
			{
				return m_Canvas;
			}
			m_Canvas = GetComponent<Canvas>();
			return m_Canvas;
		}
	}

	public override Camera eventCamera => canvas.worldCamera;

	public override int sortOrderPriority => sortOrder;

	protected OVRRaycaster()
	{
	}

	private void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList, Ray ray, bool checkForBlocking)
	{
		if (canvas == null)
		{
			return;
		}
		float num = float.MaxValue;
		if (checkForBlocking && base.blockingObjects != 0)
		{
			float farClipPlane = eventCamera.farClipPlane;
			if (base.blockingObjects == BlockingObjects.ThreeD || base.blockingObjects == BlockingObjects.All)
			{
				UnityEngine.RaycastHit[] array = Physics.RaycastAll(ray, farClipPlane, m_BlockingMask);
				if (array.Length != 0 && array[0].distance < num)
				{
					num = array[0].distance;
				}
			}
			if (base.blockingObjects == BlockingObjects.TwoD || base.blockingObjects == BlockingObjects.All)
			{
				RaycastHit2D[] rayIntersectionAll = Physics2D.GetRayIntersectionAll(ray, farClipPlane, m_BlockingMask);
				if (rayIntersectionAll.Length != 0 && rayIntersectionAll[0].fraction * farClipPlane < num)
				{
					num = rayIntersectionAll[0].fraction * farClipPlane;
				}
			}
		}
		m_RaycastResults.Clear();
		GraphicRaycast(canvas, ray, m_RaycastResults);
		for (int i = 0; i < m_RaycastResults.Count; i++)
		{
			GameObject gameObject = m_RaycastResults[i].graphic.gameObject;
			bool flag = true;
			if (base.ignoreReversedGraphics)
			{
				Vector3 direction = ray.direction;
				Vector3 rhs = gameObject.transform.rotation * Vector3.forward;
				flag = Vector3.Dot(direction, rhs) > 0f;
			}
			if (eventCamera.transform.InverseTransformPoint(m_RaycastResults[i].worldPos).z <= 0f)
			{
				flag = false;
			}
			if (flag)
			{
				float num2 = Vector3.Distance(ray.origin, m_RaycastResults[i].worldPos);
				if (!(num2 >= num))
				{
					RaycastResult raycastResult = default(RaycastResult);
					raycastResult.gameObject = gameObject;
					raycastResult.module = this;
					raycastResult.distance = num2;
					raycastResult.index = resultAppendList.Count;
					raycastResult.depth = m_RaycastResults[i].graphic.depth;
					raycastResult.worldPosition = m_RaycastResults[i].worldPos;
					RaycastResult item = raycastResult;
					resultAppendList.Add(item);
				}
			}
		}
	}

	public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)
	{
		if (eventData.IsVRPointer())
		{
			Raycast(eventData, resultAppendList, eventData.GetRay(), checkForBlocking: true);
		}
	}

	public void RaycastPointer(PointerEventData eventData, List<RaycastResult> resultAppendList)
	{
		if (pointer != null && pointer.activeInHierarchy)
		{
			Raycast(eventData, resultAppendList, new Ray(eventCamera.transform.position, (pointer.transform.position - eventCamera.transform.position).normalized), checkForBlocking: false);
		}
	}

	private void GraphicRaycast(Canvas canvas, Ray ray, List<RaycastHit> results)
	{
		IList<Graphic> graphicsForCanvas = GraphicRegistry.GetGraphicsForCanvas(canvas);
		s_SortedGraphics.Clear();
		RaycastHit item = default(RaycastHit);
		for (int i = 0; i < graphicsForCanvas.Count; i++)
		{
			Graphic graphic = graphicsForCanvas[i];
			if (graphic.depth != -1 && !(pointer == graphic.gameObject) && RayIntersectsRectTransform(graphic.rectTransform, ray, out var worldPos))
			{
				Vector2 sp = eventCamera.WorldToScreenPoint(worldPos);
				if (graphic.Raycast(sp, eventCamera))
				{
					item.graphic = graphic;
					item.worldPos = worldPos;
					item.fromMouse = false;
					s_SortedGraphics.Add(item);
				}
			}
		}
		s_SortedGraphics.Sort((RaycastHit g1, RaycastHit g2) => g2.graphic.depth.CompareTo(g1.graphic.depth));
		for (int j = 0; j < s_SortedGraphics.Count; j++)
		{
			results.Add(s_SortedGraphics[j]);
		}
	}

	public Vector2 GetScreenPosition(RaycastResult raycastResult)
	{
		return eventCamera.WorldToScreenPoint(raycastResult.worldPosition);
	}

	private static bool RayIntersectsRectTransform(RectTransform rectTransform, Ray ray, out Vector3 worldPos)
	{
		Vector3[] array = new Vector3[4];
		rectTransform.GetWorldCorners(array);
		if (!new Plane(array[0], array[1], array[2]).Raycast(ray, out var enter))
		{
			worldPos = Vector3.zero;
			return false;
		}
		Vector3 point = ray.GetPoint(enter);
		Vector3 vector = array[3] - array[0];
		Vector3 vector2 = array[1] - array[0];
		float num = Vector3.Dot(point - array[0], vector);
		float num2 = Vector3.Dot(point - array[0], vector2);
		if (num < vector.sqrMagnitude && num2 < vector2.sqrMagnitude && num >= 0f && num2 >= 0f)
		{
			worldPos = array[0] + num2 * vector2 / vector2.sqrMagnitude + num * vector / vector.sqrMagnitude;
			return true;
		}
		worldPos = Vector3.zero;
		return false;
	}

	public bool IsFocussed()
	{
		OVRInputModule oVRInputModule = EventSystem.current.currentInputModule as OVRInputModule;
		if ((bool)oVRInputModule)
		{
			return oVRInputModule.activeGraphicRaycaster == this;
		}
		return false;
	}

	public void OnPointerEnter(PointerEventData e)
	{
		if (e.IsVRPointer())
		{
			(EventSystem.current.currentInputModule as OVRInputModule).activeGraphicRaycaster = this;
		}
	}
}
public class OVRResetOrientation : MonoBehaviour
{
	public OVRInput.RawButton resetButton = OVRInput.RawButton.Y;

	private void Update()
	{
		if (OVRInput.GetDown(resetButton))
		{
			OVRManager.display.RecenterPose();
		}
	}
}
public class OVRSceneSampleController : MonoBehaviour
{
	public KeyCode quitKey = KeyCode.Escape;

	public Texture fadeInTexture;

	public float speedRotationIncrement = 0.05f;

	private OVRPlayerController playerController;

	private OVRCameraRig cameraController;

	public string layerName = "Default";

	private bool visionMode = true;

	private OVRGridCube gridCube;

	private void Awake()
	{
		OVRCameraRig[] componentsInChildren = base.gameObject.GetComponentsInChildren<OVRCameraRig>();
		if (componentsInChildren.Length == 0)
		{
			UnityEngine.Debug.LogWarning("OVRMainMenu: No OVRCameraRig attached.");
		}
		else if (componentsInChildren.Length > 1)
		{
			UnityEngine.Debug.LogWarning("OVRMainMenu: More then 1 OVRCameraRig attached.");
		}
		else
		{
			cameraController = componentsInChildren[0];
		}
		OVRPlayerController[] componentsInChildren2 = base.gameObject.GetComponentsInChildren<OVRPlayerController>();
		if (componentsInChildren2.Length == 0)
		{
			UnityEngine.Debug.LogWarning("OVRMainMenu: No OVRPlayerController attached.");
		}
		else if (componentsInChildren2.Length > 1)
		{
			UnityEngine.Debug.LogWarning("OVRMainMenu: More then 1 OVRPlayerController attached.");
		}
		else
		{
			playerController = componentsInChildren2[0];
		}
	}

	private void Start()
	{
		if (!UnityEngine.Application.isEditor)
		{
			Cursor.visible = false;
			Cursor.lockState = CursorLockMode.Locked;
		}
		if (cameraController != null)
		{
			gridCube = base.gameObject.AddComponent<OVRGridCube>();
			gridCube.SetOVRCameraController(ref cameraController);
		}
	}

	private void Update()
	{
		UpdateRecenterPose();
		UpdateVisionMode();
		if (playerController != null)
		{
			UpdateSpeedAndRotationScaleMultiplier();
		}
		if (Input.GetKeyDown(KeyCode.F11))
		{
			Screen.fullScreen = !Screen.fullScreen;
		}
		if (Input.GetKeyDown(KeyCode.M))
		{
			XRSettings.showDeviceView = !XRSettings.showDeviceView;
		}
	}

	private void UpdateVisionMode()
	{
		if (Input.GetKeyDown(KeyCode.F2))
		{
			visionMode ^= visionMode;
			OVRManager.tracker.isEnabled = visionMode;
		}
	}

	private void UpdateSpeedAndRotationScaleMultiplier()
	{
		float moveScaleMultiplier = 0f;
		playerController.GetMoveScaleMultiplier(ref moveScaleMultiplier);
		if (Input.GetKeyDown(KeyCode.Alpha7))
		{
			moveScaleMultiplier -= speedRotationIncrement;
		}
		else if (Input.GetKeyDown(KeyCode.Alpha8))
		{
			moveScaleMultiplier += speedRotationIncrement;
		}
		playerController.SetMoveScaleMultiplier(moveScaleMultiplier);
		float rotationScaleMultiplier = 0f;
		playerController.GetRotationScaleMultiplier(ref rotationScaleMultiplier);
		if (Input.GetKeyDown(KeyCode.Alpha9))
		{
			rotationScaleMultiplier -= speedRotationIncrement;
		}
		else if (Input.GetKeyDown(KeyCode.Alpha0))
		{
			rotationScaleMultiplier += speedRotationIncrement;
		}
		playerController.SetRotationScaleMultiplier(rotationScaleMultiplier);
	}

	private void UpdateRecenterPose()
	{
		if (Input.GetKeyDown(KeyCode.R))
		{
			OVRManager.display.RecenterPose();
		}
	}
}
public class OVRScreenFade : MonoBehaviour
{
	[Tooltip("Fade duration")]
	public float fadeTime = 2f;

	[Tooltip("Screen color at maximum fade")]
	public Color fadeColor = new Color(0.01f, 0.01f, 0.01f, 1f);

	public bool fadeOnStart = true;

	public int renderQueue = 5000;

	private float uiFadeAlpha;

	private MeshRenderer fadeRenderer;

	private MeshFilter fadeMesh;

	private Material fadeMaterial;

	private bool isFading;

	public float currentAlpha { get; private set; }

	private void Awake()
	{
		fadeMaterial = new Material(Shader.Find("Oculus/Unlit Transparent Color"));
		fadeMesh = base.gameObject.AddComponent<MeshFilter>();
		fadeRenderer = base.gameObject.AddComponent<MeshRenderer>();
		Mesh mesh = new Mesh();
		fadeMesh.mesh = mesh;
		Vector3[] array = new Vector3[4];
		float num = 2f;
		float num2 = 2f;
		float z = 1f;
		array[0] = new Vector3(0f - num, 0f - num2, z);
		array[1] = new Vector3(num, 0f - num2, z);
		array[2] = new Vector3(0f - num, num2, z);
		array[3] = new Vector3(num, num2, z);
		mesh.vertices = array;
		mesh.triangles = new int[6] { 0, 2, 1, 2, 3, 1 };
		mesh.normals = new Vector3[4]
		{
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(1f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f)
		};
		SetFadeLevel(0f);
	}

	public void FadeOut()
	{
		StartCoroutine(Fade(0f, 1f));
	}

	private void OnLevelFinishedLoading(int level)
	{
		StartCoroutine(Fade(1f, 0f));
	}

	private void Start()
	{
		if (fadeOnStart)
		{
			StartCoroutine(Fade(1f, 0f));
		}
	}

	private void OnEnable()
	{
		if (!fadeOnStart)
		{
			SetFadeLevel(0f);
		}
	}

	private void OnDestroy()
	{
		if (fadeRenderer != null)
		{
			UnityEngine.Object.Destroy(fadeRenderer);
		}
		if (fadeMaterial != null)
		{
			UnityEngine.Object.Destroy(fadeMaterial);
		}
		if (fadeMesh != null)
		{
			UnityEngine.Object.Destroy(fadeMesh);
		}
	}

	public void SetUIFade(float level)
	{
		uiFadeAlpha = Mathf.Clamp01(level);
		SetMaterialAlpha();
	}

	public void SetFadeLevel(float level)
	{
		currentAlpha = level;
		SetMaterialAlpha();
	}

	private IEnumerator Fade(float startAlpha, float endAlpha)
	{
		float elapsedTime = 0f;
		while (elapsedTime < fadeTime)
		{
			elapsedTime += Time.deltaTime;
			currentAlpha = Mathf.Lerp(startAlpha, endAlpha, Mathf.Clamp01(elapsedTime / fadeTime));
			SetMaterialAlpha();
			yield return new WaitForEndOfFrame();
		}
	}

	private void SetMaterialAlpha()
	{
		Color color = fadeColor;
		color.a = Mathf.Max(currentAlpha, uiFadeAlpha);
		isFading = color.a > 0f;
		if (fadeMaterial != null)
		{
			fadeMaterial.color = color;
			fadeMaterial.renderQueue = renderQueue;
			fadeRenderer.material = fadeMaterial;
			fadeRenderer.enabled = isFading;
		}
	}
}
public class OVRTrackedRemote : MonoBehaviour
{
	public GameObject m_modelGearVrController;

	public GameObject m_modelOculusGoController;

	public OVRInput.Controller m_controller;

	private bool m_isOculusGo;

	private bool m_prevControllerConnected;

	private bool m_prevControllerConnectedCached;

	private void Start()
	{
		m_isOculusGo = OVRPlugin.productName == "Oculus Go";
	}

	private void Update()
	{
		bool flag = OVRInput.IsControllerConnected(m_controller);
		if (flag != m_prevControllerConnected || !m_prevControllerConnectedCached)
		{
			m_modelOculusGoController.SetActive(flag && m_isOculusGo);
			m_modelGearVrController.SetActive(flag && !m_isOculusGo);
			m_prevControllerConnected = flag;
			m_prevControllerConnectedCached = true;
		}
	}
}
public class OVRWaitCursor : MonoBehaviour
{
	public Vector3 rotateSpeeds = new Vector3(0f, 0f, -60f);

	private void Update()
	{
		base.transform.Rotate(rotateSpeeds * Time.smoothDeltaTime);
	}
}
namespace Assets.OVR.Scripts
{
	public class Record
	{
		public string category;

		public string message;

		public Record(string cat, string msg)
		{
			category = cat;
			message = msg;
		}
	}
	public class RangedRecord : Record
	{
		public float value;

		public float min;

		public float max;

		public RangedRecord(string cat, string msg, float val, float minVal, float maxVal)
			: base(cat, msg)
		{
			value = val;
			min = minVal;
			max = maxVal;
		}
	}
	public delegate void FixMethodDelegate(UnityEngine.Object obj, bool isLastInSet, int selectedIndex);
	public class FixRecord : Record
	{
		public FixMethodDelegate fixMethod;

		public UnityEngine.Object targetObject;

		public string[] buttonNames;

		public bool complete;

		public FixRecord(string cat, string msg, FixMethodDelegate fix, UnityEngine.Object target, string[] buttons)
			: base(cat, msg)
		{
			buttonNames = buttons;
			fixMethod = fix;
			targetObject = target;
			complete = false;
		}
	}
}
namespace UnityEngine.EventSystems
{
	public class OVRInputModule : PointerInputModule
	{
		[Obsolete("Mode is no longer needed on input module as it handles both mouse and keyboard simultaneously.", false)]
		public enum InputMode
		{
			Mouse,
			Buttons
		}

		[Tooltip("Object which points with Z axis. E.g. CentreEyeAnchor from OVRCameraRig")]
		public Transform rayTransform;

		[Tooltip("Gamepad button to act as gaze click")]
		public OVRInput.Button joyPadClickButton = OVRInput.Button.One;

		[Tooltip("Keyboard button to act as gaze click")]
		public KeyCode gazeClickKey = KeyCode.Space;

		[Header("Physics")]
		[Tooltip("Perform an sphere cast to determine correct depth for gaze pointer")]
		public bool performSphereCastForGazepointer;

		[Tooltip("Match the gaze pointer normal to geometry normal for physics colliders")]
		public bool matchNormalOnPhysicsColliders;

		[Header("Gamepad Stick Scroll")]
		[Tooltip("Enable scrolling with the right stick on a gamepad")]
		public bool useRightStickScroll = true;

		[Tooltip("Deadzone for right stick to prevent accidental scrolling")]
		public float rightStickDeadZone = 0.15f;

		[Header("Touchpad Swipe Scroll")]
		[Tooltip("Enable scrolling by swiping the GearVR touchpad")]
		public bool useSwipeScroll = true;

		[Tooltip("Minimum trackpad movement in pixels to start swiping")]
		public float swipeDragThreshold = 2f;

		[Tooltip("Distance scrolled when swipe scroll occurs")]
		public float swipeDragScale = 1f;

		[Tooltip("Invert X axis on touchpad")]
		public bool InvertSwipeXAxis;

		[NonSerialized]
		public OVRRaycaster activeGraphicRaycaster;

		[Header("Dragging")]
		[Tooltip("Minimum pointer movement in degrees to start dragging")]
		public float angleDragThreshold = 1f;

		private float m_NextAction;

		private Vector2 m_LastMousePosition;

		private Vector2 m_MousePosition;

		[Header("Standalone Input Module")]
		[SerializeField]
		private string m_HorizontalAxis = "Horizontal";

		[SerializeField]
		private string m_VerticalAxis = "Vertical";

		[SerializeField]
		private string m_SubmitButton = "Submit";

		[SerializeField]
		private string m_CancelButton = "Cancel";

		[SerializeField]
		private float m_InputActionsPerSecond = 10f;

		[SerializeField]
		private bool m_AllowActivationOnMobileDevice;

		protected Dictionary<int, OVRPointerEventData> m_VRRayPointerData = new Dictionary<int, OVRPointerEventData>();

		private readonly MouseState m_MouseState = new MouseState();

		[Obsolete("Mode is no longer needed on input module as it handles both mouse and keyboard simultaneously.", false)]
		public InputMode inputMode => InputMode.Mouse;

		public bool allowActivationOnMobileDevice
		{
			get
			{
				return m_AllowActivationOnMobileDevice;
			}
			set
			{
				m_AllowActivationOnMobileDevice = value;
			}
		}

		public float inputActionsPerSecond
		{
			get
			{
				return m_InputActionsPerSecond;
			}
			set
			{
				m_InputActionsPerSecond = value;
			}
		}

		public string horizontalAxis
		{
			get
			{
				return m_HorizontalAxis;
			}
			set
			{
				m_HorizontalAxis = value;
			}
		}

		public string verticalAxis
		{
			get
			{
				return m_VerticalAxis;
			}
			set
			{
				m_VerticalAxis = value;
			}
		}

		public string submitButton
		{
			get
			{
				return m_SubmitButton;
			}
			set
			{
				m_SubmitButton = value;
			}
		}

		public string cancelButton
		{
			get
			{
				return m_CancelButton;
			}
			set
			{
				m_CancelButton = value;
			}
		}

		protected OVRInputModule()
		{
		}

		public override void UpdateModule()
		{
			m_LastMousePosition = m_MousePosition;
			m_MousePosition = Input.mousePosition;
		}

		public override bool IsModuleSupported()
		{
			if (!m_AllowActivationOnMobileDevice)
			{
				return Input.mousePresent;
			}
			return true;
		}

		public override bool ShouldActivateModule()
		{
			if (!base.ShouldActivateModule())
			{
				return false;
			}
			return Input.GetButtonDown(m_SubmitButton) | Input.GetButtonDown(m_CancelButton) | !Mathf.Approximately(Input.GetAxisRaw(m_HorizontalAxis), 0f) | !Mathf.Approximately(Input.GetAxisRaw(m_VerticalAxis), 0f) | ((m_MousePosition - m_LastMousePosition).sqrMagnitude > 0f) | Input.GetMouseButtonDown(0);
		}

		public override void ActivateModule()
		{
			base.ActivateModule();
			m_MousePosition = Input.mousePosition;
			m_LastMousePosition = Input.mousePosition;
			GameObject gameObject = base.eventSystem.currentSelectedGameObject;
			if (gameObject == null)
			{
				gameObject = base.eventSystem.firstSelectedGameObject;
			}
			base.eventSystem.SetSelectedGameObject(gameObject, GetBaseEventData());
		}

		public override void DeactivateModule()
		{
			base.DeactivateModule();
			ClearSelection();
		}

		private bool SendSubmitEventToSelectedObject()
		{
			if (base.eventSystem.currentSelectedGameObject == null)
			{
				return false;
			}
			BaseEventData baseEventData = GetBaseEventData();
			if (Input.GetButtonDown(m_SubmitButton))
			{
				ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, baseEventData, ExecuteEvents.submitHandler);
			}
			if (Input.GetButtonDown(m_CancelButton))
			{
				ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, baseEventData, ExecuteEvents.cancelHandler);
			}
			return baseEventData.used;
		}

		private bool AllowMoveEventProcessing(float time)
		{
			return Input.GetButtonDown(m_HorizontalAxis) | Input.GetButtonDown(m_VerticalAxis) | (time > m_NextAction);
		}

		private Vector2 GetRawMoveVector()
		{
			Vector2 zero = Vector2.zero;
			zero.x = Input.GetAxisRaw(m_HorizontalAxis);
			zero.y = Input.GetAxisRaw(m_VerticalAxis);
			if (Input.GetButtonDown(m_HorizontalAxis))
			{
				if (zero.x < 0f)
				{
					zero.x = -1f;
				}
				if (zero.x > 0f)
				{
					zero.x = 1f;
				}
			}
			if (Input.GetButtonDown(m_VerticalAxis))
			{
				if (zero.y < 0f)
				{
					zero.y = -1f;
				}
				if (zero.y > 0f)
				{
					zero.y = 1f;
				}
			}
			return zero;
		}

		private bool SendMoveEventToSelectedObject()
		{
			float unscaledTime = Time.unscaledTime;
			if (!AllowMoveEventProcessing(unscaledTime))
			{
				return false;
			}
			Vector2 rawMoveVector = GetRawMoveVector();
			AxisEventData axisEventData = GetAxisEventData(rawMoveVector.x, rawMoveVector.y, 0.6f);
			if (!Mathf.Approximately(axisEventData.moveVector.x, 0f) || !Mathf.Approximately(axisEventData.moveVector.y, 0f))
			{
				ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, axisEventData, ExecuteEvents.moveHandler);
			}
			m_NextAction = unscaledTime + 1f / m_InputActionsPerSecond;
			return axisEventData.used;
		}

		private bool SendUpdateEventToSelectedObject()
		{
			if (base.eventSystem.currentSelectedGameObject == null)
			{
				return false;
			}
			BaseEventData baseEventData = GetBaseEventData();
			ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, baseEventData, ExecuteEvents.updateSelectedHandler);
			return baseEventData.used;
		}

		private void ProcessMousePress(MouseButtonEventData data)
		{
			PointerEventData buttonData = data.buttonData;
			GameObject gameObject = buttonData.pointerCurrentRaycast.gameObject;
			if (data.PressedThisFrame())
			{
				buttonData.eligibleForClick = true;
				buttonData.delta = Vector2.zero;
				buttonData.dragging = false;
				buttonData.useDragThreshold = true;
				buttonData.pressPosition = buttonData.position;
				if (buttonData.IsVRPointer())
				{
					buttonData.SetSwipeStart(Input.mousePosition);
				}
				buttonData.pointerPressRaycast = buttonData.pointerCurrentRaycast;
				DeselectIfSelectionChanged(gameObject, buttonData);
				GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(gameObject, buttonData, ExecuteEvents.pointerDownHandler);
				if (gameObject2 == null)
				{
					gameObject2 = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				}
				float unscaledTime = Time.unscaledTime;
				if (gameObject2 == buttonData.lastPress)
				{
					if (unscaledTime - buttonData.clickTime < 0.3f)
					{
						int clickCount = buttonData.clickCount + 1;
						buttonData.clickCount = clickCount;
					}
					else
					{
						buttonData.clickCount = 1;
					}
					buttonData.clickTime = unscaledTime;
				}
				else
				{
					buttonData.clickCount = 1;
				}
				buttonData.pointerPress = gameObject2;
				buttonData.rawPointerPress = gameObject;
				buttonData.clickTime = unscaledTime;
				buttonData.pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(gameObject);
				if (buttonData.pointerDrag != null)
				{
					ExecuteEvents.Execute(buttonData.pointerDrag, buttonData, ExecuteEvents.initializePotentialDrag);
				}
			}
			if (data.ReleasedThisFrame())
			{
				ExecuteEvents.Execute(buttonData.pointerPress, buttonData, ExecuteEvents.pointerUpHandler);
				GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				if (buttonData.pointerPress == eventHandler && buttonData.eligibleForClick)
				{
					ExecuteEvents.Execute(buttonData.pointerPress, buttonData, ExecuteEvents.pointerClickHandler);
				}
				else if (buttonData.pointerDrag != null)
				{
					ExecuteEvents.ExecuteHierarchy(gameObject, buttonData, ExecuteEvents.dropHandler);
				}
				buttonData.eligibleForClick = false;
				buttonData.pointerPress = null;
				buttonData.rawPointerPress = null;
				if (buttonData.pointerDrag != null && buttonData.dragging)
				{
					ExecuteEvents.Execute(buttonData.pointerDrag, buttonData, ExecuteEvents.endDragHandler);
				}
				buttonData.dragging = false;
				buttonData.pointerDrag = null;
				if (gameObject != buttonData.pointerEnter)
				{
					HandlePointerExitAndEnter(buttonData, null);
					HandlePointerExitAndEnter(buttonData, gameObject);
				}
			}
		}

		private void ProcessMouseEvent(MouseState mouseData)
		{
			bool pressed = mouseData.AnyPressesThisFrame();
			bool released = mouseData.AnyReleasesThisFrame();
			MouseButtonEventData eventData = mouseData.GetButtonState(PointerEventData.InputButton.Left).eventData;
			if (UseMouse(pressed, released, eventData.buttonData))
			{
				ProcessMousePress(eventData);
				ProcessMove(eventData.buttonData);
				ProcessDrag(eventData.buttonData);
				ProcessMousePress(mouseData.GetButtonState(PointerEventData.InputButton.Right).eventData);
				ProcessDrag(mouseData.GetButtonState(PointerEventData.InputButton.Right).eventData.buttonData);
				ProcessMousePress(mouseData.GetButtonState(PointerEventData.InputButton.Middle).eventData);
				ProcessDrag(mouseData.GetButtonState(PointerEventData.InputButton.Middle).eventData.buttonData);
				if (!Mathf.Approximately(eventData.buttonData.scrollDelta.sqrMagnitude, 0f))
				{
					ExecuteEvents.ExecuteHierarchy(ExecuteEvents.GetEventHandler<IScrollHandler>(eventData.buttonData.pointerCurrentRaycast.gameObject), eventData.buttonData, ExecuteEvents.scrollHandler);
				}
			}
		}

		public override void Process()
		{
			bool flag = SendUpdateEventToSelectedObject();
			if (base.eventSystem.sendNavigationEvents)
			{
				if (!flag)
				{
					flag |= SendMoveEventToSelectedObject();
				}
				if (!flag)
				{
					SendSubmitEventToSelectedObject();
				}
			}
			ProcessMouseEvent(GetGazePointerData());
		}

		private static bool UseMouse(bool pressed, bool released, PointerEventData pointerData)
		{
			if (pressed || released || IsPointerMoving(pointerData) || pointerData.IsScrolling())
			{
				return true;
			}
			return false;
		}

		protected void CopyFromTo(OVRPointerEventData from, OVRPointerEventData to)
		{
			to.position = from.position;
			to.delta = from.delta;
			to.scrollDelta = from.scrollDelta;
			to.pointerCurrentRaycast = from.pointerCurrentRaycast;
			to.pointerEnter = from.pointerEnter;
			to.worldSpaceRay = from.worldSpaceRay;
		}

		protected new void CopyFromTo(PointerEventData from, PointerEventData to)
		{
			to.position = from.position;
			to.delta = from.delta;
			to.scrollDelta = from.scrollDelta;
			to.pointerCurrentRaycast = from.pointerCurrentRaycast;
			to.pointerEnter = from.pointerEnter;
		}

		protected bool GetPointerData(int id, out OVRPointerEventData data, bool create)
		{
			if (!m_VRRayPointerData.TryGetValue(id, out data) && create)
			{
				data = new OVRPointerEventData(base.eventSystem)
				{
					pointerId = id
				};
				m_VRRayPointerData.Add(id, data);
				return true;
			}
			return false;
		}

		protected new void ClearSelection()
		{
			BaseEventData baseEventData = GetBaseEventData();
			foreach (PointerEventData value in m_PointerData.Values)
			{
				HandlePointerExitAndEnter(value, null);
			}
			foreach (OVRPointerEventData value2 in m_VRRayPointerData.Values)
			{
				HandlePointerExitAndEnter(value2, null);
			}
			m_PointerData.Clear();
			base.eventSystem.SetSelectedGameObject(null, baseEventData);
		}

		private static Vector3 GetRectTransformNormal(RectTransform rectTransform)
		{
			Vector3[] array = new Vector3[4];
			rectTransform.GetWorldCorners(array);
			Vector3 lhs = array[3] - array[0];
			Vector3 rhs = array[1] - array[0];
			rectTransform.GetWorldCorners(array);
			return Vector3.Cross(lhs, rhs).normalized;
		}

		protected virtual MouseState GetGazePointerData()
		{
			GetPointerData(-1, out var data, create: true);
			data.Reset();
			data.worldSpaceRay = new Ray(rayTransform.position, rayTransform.forward);
			data.scrollDelta = GetExtraScrollDelta();
			data.button = PointerEventData.InputButton.Left;
			data.useDragThreshold = true;
			base.eventSystem.RaycastAll(data, m_RaycastResultCache);
			RaycastResult raycastResult2 = (data.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache));
			m_RaycastResultCache.Clear();
			OVRRaycaster oVRRaycaster = raycastResult2.module as OVRRaycaster;
			if ((bool)oVRRaycaster)
			{
				data.position = oVRRaycaster.GetScreenPosition(raycastResult2);
				RectTransform component = raycastResult2.gameObject.GetComponent<RectTransform>();
				if (component != null)
				{
					Vector3 worldPosition = raycastResult2.worldPosition;
					Vector3 rectTransformNormal = GetRectTransformNormal(component);
					OVRGazePointer.instance.SetPosition(worldPosition, rectTransformNormal);
					OVRGazePointer.instance.RequestShow();
				}
			}
			OVRPhysicsRaycaster oVRPhysicsRaycaster = raycastResult2.module as OVRPhysicsRaycaster;
			if ((bool)oVRPhysicsRaycaster)
			{
				Vector3 worldPosition2 = raycastResult2.worldPosition;
				if (performSphereCastForGazepointer)
				{
					List<RaycastResult> list = new List<RaycastResult>();
					oVRPhysicsRaycaster.Spherecast(data, list, OVRGazePointer.instance.GetCurrentRadius());
					if (list.Count > 0 && list[0].distance < raycastResult2.distance)
					{
						worldPosition2 = list[0].worldPosition;
					}
				}
				data.position = oVRPhysicsRaycaster.GetScreenPos(raycastResult2.worldPosition);
				OVRGazePointer.instance.RequestShow();
				if (matchNormalOnPhysicsColliders)
				{
					OVRGazePointer.instance.SetPosition(worldPosition2, raycastResult2.worldNormal);
				}
				else
				{
					OVRGazePointer.instance.SetPosition(worldPosition2);
				}
			}
			GetPointerData(-2, out var data2, create: true);
			CopyFromTo(data, data2);
			data2.button = PointerEventData.InputButton.Right;
			GetPointerData(-3, out var data3, create: true);
			CopyFromTo(data, data3);
			data3.button = PointerEventData.InputButton.Middle;
			m_MouseState.SetButtonState(PointerEventData.InputButton.Left, GetGazeButtonState(), data);
			m_MouseState.SetButtonState(PointerEventData.InputButton.Right, PointerEventData.FramePressState.NotChanged, data2);
			m_MouseState.SetButtonState(PointerEventData.InputButton.Middle, PointerEventData.FramePressState.NotChanged, data3);
			return m_MouseState;
		}

		protected MouseState GetCanvasPointerData()
		{
			GetPointerData(-1, out PointerEventData data, create: true);
			data.Reset();
			data.position = Vector2.zero;
			data.scrollDelta = Input.mouseScrollDelta;
			data.button = PointerEventData.InputButton.Left;
			if ((bool)activeGraphicRaycaster)
			{
				activeGraphicRaycaster.RaycastPointer(data, m_RaycastResultCache);
				RaycastResult raycastResult2 = (data.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache));
				m_RaycastResultCache.Clear();
				OVRRaycaster oVRRaycaster = raycastResult2.module as OVRRaycaster;
				if ((bool)oVRRaycaster)
				{
					Vector2 screenPosition = oVRRaycaster.GetScreenPosition(raycastResult2);
					data.delta = screenPosition - data.position;
					data.position = screenPosition;
				}
			}
			GetPointerData(-2, out PointerEventData data2, create: true);
			CopyFromTo(data, data2);
			data2.button = PointerEventData.InputButton.Right;
			GetPointerData(-3, out PointerEventData data3, create: true);
			CopyFromTo(data, data3);
			data3.button = PointerEventData.InputButton.Middle;
			m_MouseState.SetButtonState(PointerEventData.InputButton.Left, StateForMouseButton(0), data);
			m_MouseState.SetButtonState(PointerEventData.InputButton.Right, StateForMouseButton(1), data2);
			m_MouseState.SetButtonState(PointerEventData.InputButton.Middle, StateForMouseButton(2), data3);
			return m_MouseState;
		}

		private bool ShouldStartDrag(PointerEventData pointerEvent)
		{
			if (!pointerEvent.useDragThreshold)
			{
				return true;
			}
			if (!pointerEvent.IsVRPointer())
			{
				return (pointerEvent.pressPosition - pointerEvent.position).sqrMagnitude >= (float)(base.eventSystem.pixelDragThreshold * base.eventSystem.pixelDragThreshold);
			}
			if (useSwipeScroll && ((Vector3)pointerEvent.GetSwipeStart() - Input.mousePosition).magnitude > swipeDragThreshold)
			{
				return true;
			}
			Vector3 position = pointerEvent.pressEventCamera.transform.position;
			Vector3 normalized = (pointerEvent.pointerPressRaycast.worldPosition - position).normalized;
			Vector3 normalized2 = (pointerEvent.pointerCurrentRaycast.worldPosition - position).normalized;
			return Vector3.Dot(normalized, normalized2) < Mathf.Cos((float)Math.PI / 180f * angleDragThreshold);
		}

		private static bool IsPointerMoving(PointerEventData pointerEvent)
		{
			if (pointerEvent.IsVRPointer())
			{
				return true;
			}
			return pointerEvent.IsPointerMoving();
		}

		protected Vector2 SwipeAdjustedPosition(Vector2 originalPosition, PointerEventData pointerEvent)
		{
			if (useSwipeScroll)
			{
				Vector2 vector = (Vector2)Input.mousePosition - pointerEvent.GetSwipeStart();
				if (InvertSwipeXAxis)
				{
					vector.x *= -1f;
				}
				return originalPosition + vector * swipeDragScale;
			}
			return originalPosition;
		}

		protected override void ProcessDrag(PointerEventData pointerEvent)
		{
			Vector2 position = pointerEvent.position;
			bool flag = IsPointerMoving(pointerEvent);
			if (flag && pointerEvent.pointerDrag != null && !pointerEvent.dragging && ShouldStartDrag(pointerEvent))
			{
				if (pointerEvent.IsVRPointer())
				{
					pointerEvent.position = SwipeAdjustedPosition(position, pointerEvent);
				}
				ExecuteEvents.Execute(pointerEvent.pointerDrag, pointerEvent, ExecuteEvents.beginDragHandler);
				pointerEvent.dragging = true;
			}
			if (pointerEvent.dragging && flag && pointerEvent.pointerDrag != null)
			{
				if (pointerEvent.IsVRPointer())
				{
					pointerEvent.position = SwipeAdjustedPosition(position, pointerEvent);
				}
				if (pointerEvent.pointerPress != pointerEvent.pointerDrag)
				{
					ExecuteEvents.Execute(pointerEvent.pointerPress, pointerEvent, ExecuteEvents.pointerUpHandler);
					pointerEvent.eligibleForClick = false;
					pointerEvent.pointerPress = null;
					pointerEvent.rawPointerPress = null;
				}
				ExecuteEvents.Execute(pointerEvent.pointerDrag, pointerEvent, ExecuteEvents.dragHandler);
			}
		}

		protected virtual PointerEventData.FramePressState GetGazeButtonState()
		{
			bool flag = Input.GetKeyDown(gazeClickKey) || OVRInput.GetDown(joyPadClickButton);
			bool flag2 = Input.GetKeyUp(gazeClickKey) || OVRInput.GetUp(joyPadClickButton);
			flag |= Input.GetMouseButtonDown(0);
			flag2 |= Input.GetMouseButtonUp(0);
			if (flag && flag2)
			{
				return PointerEventData.FramePressState.PressedAndReleased;
			}
			if (flag)
			{
				return PointerEventData.FramePressState.Pressed;
			}
			if (flag2)
			{
				return PointerEventData.FramePressState.Released;
			}
			return PointerEventData.FramePressState.NotChanged;
		}

		protected Vector2 GetExtraScrollDelta()
		{
			Vector2 result = default(Vector2);
			if (useRightStickScroll)
			{
				Vector2 result2 = OVRInput.Get(OVRInput.Axis2D.SecondaryThumbstick);
				if (Mathf.Abs(result2.x) < rightStickDeadZone)
				{
					result2.x = 0f;
				}
				if (Mathf.Abs(result2.y) < rightStickDeadZone)
				{
					result2.y = 0f;
				}
				return result2;
			}
			return result;
		}
	}
	[RequireComponent(typeof(OVRCameraRig))]
	public class OVRPhysicsRaycaster : BaseRaycaster
	{
		protected const int kNoEventMaskSet = -1;

		[SerializeField]
		protected LayerMask m_EventMask = -1;

		public int sortOrder = 20;

		public override Camera eventCamera => GetComponent<OVRCameraRig>().leftEyeCamera;

		public virtual int depth
		{
			get
			{
				if (!(eventCamera != null))
				{
					return 16777215;
				}
				return (int)eventCamera.depth;
			}
		}

		public override int sortOrderPriority => sortOrder;

		public int finalEventMask
		{
			get
			{
				if (!(eventCamera != null))
				{
					return -1;
				}
				return eventCamera.cullingMask & (int)m_EventMask;
			}
		}

		public LayerMask eventMask
		{
			get
			{
				return m_EventMask;
			}
			set
			{
				m_EventMask = value;
			}
		}

		protected OVRPhysicsRaycaster()
		{
		}

		public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)
		{
			if (eventCamera == null || !eventData.IsVRPointer())
			{
				return;
			}
			Ray ray = eventData.GetRay();
			float maxDistance = eventCamera.farClipPlane - eventCamera.nearClipPlane;
			RaycastHit[] array = Physics.RaycastAll(ray, maxDistance, finalEventMask);
			if (array.Length > 1)
			{
				Array.Sort(array, (RaycastHit r1, RaycastHit r2) => r1.distance.CompareTo(r2.distance));
			}
			if (array.Length != 0)
			{
				int i = 0;
				for (int num = array.Length; i < num; i++)
				{
					RaycastResult raycastResult = default(RaycastResult);
					raycastResult.gameObject = array[i].collider.gameObject;
					raycastResult.module = this;
					raycastResult.distance = array[i].distance;
					raycastResult.index = resultAppendList.Count;
					raycastResult.worldPosition = array[0].point;
					raycastResult.worldNormal = array[0].normal;
					RaycastResult item = raycastResult;
					resultAppendList.Add(item);
				}
			}
		}

		public void Spherecast(PointerEventData eventData, List<RaycastResult> resultAppendList, float radius)
		{
			if (eventCamera == null || !eventData.IsVRPointer())
			{
				return;
			}
			Ray ray = eventData.GetRay();
			float maxDistance = eventCamera.farClipPlane - eventCamera.nearClipPlane;
			RaycastHit[] array = Physics.SphereCastAll(ray, radius, maxDistance, finalEventMask);
			if (array.Length > 1)
			{
				Array.Sort(array, (RaycastHit r1, RaycastHit r2) => r1.distance.CompareTo(r2.distance));
			}
			if (array.Length != 0)
			{
				int i = 0;
				for (int num = array.Length; i < num; i++)
				{
					RaycastResult raycastResult = default(RaycastResult);
					raycastResult.gameObject = array[i].collider.gameObject;
					raycastResult.module = this;
					raycastResult.distance = array[i].distance;
					raycastResult.index = resultAppendList.Count;
					raycastResult.worldPosition = array[0].point;
					raycastResult.worldNormal = array[0].normal;
					RaycastResult item = raycastResult;
					resultAppendList.Add(item);
				}
			}
		}

		public Vector2 GetScreenPos(Vector3 worldPosition)
		{
			return eventCamera.WorldToScreenPoint(worldPosition);
		}
	}
	public class OVRPointerEventData : PointerEventData
	{
		public Ray worldSpaceRay;

		public Vector2 swipeStart;

		public OVRPointerEventData(EventSystem eventSystem)
			: base(eventSystem)
		{
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine("<b>Position</b>: " + base.position);
			stringBuilder.AppendLine("<b>delta</b>: " + base.delta);
			stringBuilder.AppendLine("<b>eligibleForClick</b>: " + base.eligibleForClick);
			stringBuilder.AppendLine("<b>pointerEnter</b>: " + base.pointerEnter);
			stringBuilder.AppendLine("<b>pointerPress</b>: " + base.pointerPress);
			stringBuilder.AppendLine("<b>lastPointerPress</b>: " + base.lastPress);
			stringBuilder.AppendLine("<b>pointerDrag</b>: " + base.pointerDrag);
			stringBuilder.AppendLine("<b>worldSpaceRay</b>: " + worldSpaceRay);
			stringBuilder.AppendLine("<b>swipeStart</b>: " + swipeStart);
			stringBuilder.AppendLine("<b>Use Drag Threshold</b>: " + base.useDragThreshold);
			return stringBuilder.ToString();
		}
	}
	public static class PointerEventDataExtension
	{
		public static bool IsVRPointer(this PointerEventData pointerEventData)
		{
			return pointerEventData is OVRPointerEventData;
		}

		public static Ray GetRay(this PointerEventData pointerEventData)
		{
			return (pointerEventData as OVRPointerEventData).worldSpaceRay;
		}

		public static Vector2 GetSwipeStart(this PointerEventData pointerEventData)
		{
			return (pointerEventData as OVRPointerEventData).swipeStart;
		}

		public static void SetSwipeStart(this PointerEventData pointerEventData, Vector2 start)
		{
			(pointerEventData as OVRPointerEventData).swipeStart = start;
		}
	}
}
namespace Oculus.Platform
{
	public class AbuseReportOptions
	{
		private IntPtr Handle;

		public AbuseReportOptions()
		{
			Handle = CAPI.ovr_AbuseReportOptions_Create();
		}

		public void SetPreventPeopleChooser(bool value)
		{
			CAPI.ovr_AbuseReportOptions_SetPreventPeopleChooser(Handle, value);
		}

		public void SetReportType(AbuseReportType value)
		{
			CAPI.ovr_AbuseReportOptions_SetReportType(Handle, value);
		}

		public static explicit operator IntPtr(AbuseReportOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~AbuseReportOptions()
		{
			CAPI.ovr_AbuseReportOptions_Destroy(Handle);
		}
	}
	public enum AbuseReportType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("OBJECT")]
		Object,
		[Description("USER")]
		User
	}
	public enum AchievementType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SIMPLE")]
		Simple,
		[Description("BITFIELD")]
		Bitfield,
		[Description("COUNT")]
		Count
	}
	public class AndroidPlatform
	{
		public bool Initialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			return CAPI.ovr_UnityInitWrapper(appId);
		}

		public Request<PlatformInitialize> AsyncInitialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			return new Request<PlatformInitialize>(CAPI.ovr_UnityInitWrapperAsynchronous(appId));
		}
	}
	public class ApplicationOptions
	{
		private IntPtr Handle;

		public ApplicationOptions()
		{
			Handle = CAPI.ovr_ApplicationOptions_Create();
		}

		public void SetDeeplinkMessage(string value)
		{
			CAPI.ovr_ApplicationOptions_SetDeeplinkMessage(Handle, value);
		}

		public static explicit operator IntPtr(ApplicationOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~ApplicationOptions()
		{
			CAPI.ovr_ApplicationOptions_Destroy(Handle);
		}
	}
	public static class Callback
	{
		private class RequestCallback
		{
			private Message.Callback messageCallback;

			public RequestCallback()
			{
			}

			public RequestCallback(Message.Callback callback)
			{
				messageCallback = callback;
			}

			public virtual void HandleMessage(Message msg)
			{
				if (messageCallback != null)
				{
					messageCallback(msg);
				}
			}
		}

		private sealed class RequestCallback<T> : RequestCallback
		{
			private Message<T>.Callback callback;

			public RequestCallback(Message<T>.Callback callback)
			{
				this.callback = callback;
			}

			public override void HandleMessage(Message msg)
			{
				if (callback != null)
				{
					if (!hasRegisteredRoomInviteNotificationHandler && msg.Type == Message.MessageType.Notification_Room_InviteAccepted)
					{
						pendingRoomInviteNotifications.Add(msg);
					}
					else if (msg is Message<T>)
					{
						callback((Message<T>)msg);
					}
					else
					{
						UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
					}
				}
			}
		}

		private static Dictionary<ulong, RequestCallback> requestIDsToCallbacks = new Dictionary<ulong, RequestCallback>();

		private static Dictionary<Message.MessageType, RequestCallback> notificationCallbacks = new Dictionary<Message.MessageType, RequestCallback>();

		private static bool hasRegisteredRoomInviteNotificationHandler = false;

		private static List<Message> pendingRoomInviteNotifications = new List<Message>();

		internal static void SetNotificationCallback<T>(Message.MessageType type, Message<T>.Callback callback)
		{
			if (callback == null)
			{
				throw new Exception("Cannot provide a null notification callback.");
			}
			notificationCallbacks[type] = new RequestCallback<T>(callback);
			if (type == Message.MessageType.Notification_Room_InviteAccepted)
			{
				FlushRoomInviteNotificationQueue();
			}
		}

		internal static void SetNotificationCallback(Message.MessageType type, Message.Callback callback)
		{
			if (callback == null)
			{
				throw new Exception("Cannot provide a null notification callback.");
			}
			notificationCallbacks[type] = new RequestCallback(callback);
		}

		internal static void OnComplete<T>(Request<T> request, Message<T>.Callback callback)
		{
			requestIDsToCallbacks[request.RequestID] = new RequestCallback<T>(callback);
		}

		internal static void OnComplete(Request request, Message.Callback callback)
		{
			requestIDsToCallbacks[request.RequestID] = new RequestCallback(callback);
		}

		internal static void RunCallbacks()
		{
			while (true)
			{
				Message message = Message.PopMessage();
				if (message != null)
				{
					HandleMessage(message);
					continue;
				}
				break;
			}
		}

		internal static void RunLimitedCallbacks(uint limit)
		{
			for (int i = 0; i < limit; i++)
			{
				Message message = Message.PopMessage();
				if (message != null)
				{
					HandleMessage(message);
					continue;
				}
				break;
			}
		}

		private static void FlushRoomInviteNotificationQueue()
		{
			hasRegisteredRoomInviteNotificationHandler = true;
			foreach (Message pendingRoomInviteNotification in pendingRoomInviteNotifications)
			{
				HandleMessage(pendingRoomInviteNotification);
			}
			pendingRoomInviteNotifications.Clear();
		}

		private static void HandleMessage(Message msg)
		{
			if (requestIDsToCallbacks.TryGetValue(msg.RequestID, out var value))
			{
				try
				{
					value.HandleMessage(msg);
					return;
				}
				finally
				{
					requestIDsToCallbacks.Remove(msg.RequestID);
				}
			}
			if (notificationCallbacks.TryGetValue(msg.Type, out value))
			{
				value.HandleMessage(msg);
			}
		}
	}
	public class CallbackRunner : MonoBehaviour
	{
		public bool IsPersistantBetweenSceneLoads = true;

		[DllImport("ovrplatformloader")]
		private static extern void ovr_UnityResetTestPlatform();

		private void Awake()
		{
			if (UnityEngine.Object.FindObjectOfType<CallbackRunner>() != this)
			{
				UnityEngine.Debug.LogWarning("You only need one instance of CallbackRunner");
			}
			if (IsPersistantBetweenSceneLoads)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		private void Update()
		{
			Request.RunCallbacks();
		}

		private void OnDestroy()
		{
		}
	}
	public class CAPI
	{
		public struct ovrKeyValuePair
		{
			public string key_;

			private KeyValuePairType valueType_;

			public string stringValue_;

			public int intValue_;

			public double doubleValue_;

			public ovrKeyValuePair(string key, string value)
			{
				key_ = key;
				valueType_ = KeyValuePairType.String;
				stringValue_ = value;
				intValue_ = 0;
				doubleValue_ = 0.0;
			}

			public ovrKeyValuePair(string key, int value)
			{
				key_ = key;
				valueType_ = KeyValuePairType.Int;
				intValue_ = value;
				stringValue_ = null;
				doubleValue_ = 0.0;
			}

			public ovrKeyValuePair(string key, double value)
			{
				key_ = key;
				valueType_ = KeyValuePairType.Double;
				doubleValue_ = value;
				stringValue_ = null;
				intValue_ = 0;
			}
		}

		public struct ovrMatchmakingCriterion
		{
			public string key_;

			public MatchmakingCriterionImportance importance_;

			public IntPtr parameterArray;

			public uint parameterArrayCount;

			public ovrMatchmakingCriterion(string key, MatchmakingCriterionImportance importance)
			{
				key_ = key;
				importance_ = importance;
				parameterArray = IntPtr.Zero;
				parameterArrayCount = 0u;
			}
		}

		public struct ovrMatchmakingCustomQueryData
		{
			public IntPtr dataArray;

			public uint dataArrayCount;

			public IntPtr criterionArray;

			public uint criterionArrayCount;
		}

		public struct OculusInitParams
		{
			public int sType;

			public string email;

			public string password;

			public ulong appId;

			public string uriPrefixOverride;
		}

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void FilterCallback([In][Out][MarshalAs(UnmanagedType.LPArray, SizeConst = 480)] short[] pcmData, UIntPtr pcmDataLength, int frequency, int numChannels);

		public const string DLL_NAME = "ovrplatformloader";

		private static UTF8Encoding nativeStringEncoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);

		public const int VoipFilterBufferSize = 480;

		public static IntPtr ArrayOfStructsToIntPtr(Array ar)
		{
			int num = 0;
			for (int i = 0; i < ar.Length; i++)
			{
				num += Marshal.SizeOf(ar.GetValue(i));
			}
			IntPtr intPtr = Marshal.AllocHGlobal(num);
			IntPtr intPtr2 = intPtr;
			for (int j = 0; j < ar.Length; j++)
			{
				Marshal.StructureToPtr(ar.GetValue(j), intPtr2, fDeleteOld: false);
				intPtr2 = (IntPtr)((long)intPtr2 + Marshal.SizeOf(ar.GetValue(j)));
			}
			return intPtr;
		}

		public static ovrKeyValuePair[] DictionaryToOVRKeyValuePairs(Dictionary<string, object> dict)
		{
			if (dict == null || dict.Count == 0)
			{
				return null;
			}
			ovrKeyValuePair[] array = new ovrKeyValuePair[dict.Count];
			int num = 0;
			foreach (KeyValuePair<string, object> item in dict)
			{
				if (item.Value.GetType() == typeof(int))
				{
					array[num] = new ovrKeyValuePair(item.Key, (int)item.Value);
				}
				else if (item.Value.GetType() == typeof(string))
				{
					array[num] = new ovrKeyValuePair(item.Key, (string)item.Value);
				}
				else
				{
					if (!(item.Value.GetType() == typeof(double)))
					{
						throw new Exception("Only int, double or string are allowed types in CustomQuery.data");
					}
					array[num] = new ovrKeyValuePair(item.Key, (double)item.Value);
				}
				num++;
			}
			return array;
		}

		public static byte[] IntPtrToByteArray(IntPtr data, ulong size)
		{
			byte[] array = new byte[size];
			Marshal.Copy(data, array, 0, (int)size);
			return array;
		}

		public static Dictionary<string, string> DataStoreFromNative(IntPtr pointer)
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			int num = (int)(uint)ovr_DataStore_GetNumKeys(pointer);
			for (int i = 0; i < num; i++)
			{
				string key = ovr_DataStore_GetKey(pointer, i);
				dictionary[key] = ovr_DataStore_GetValue(pointer, key);
			}
			return dictionary;
		}

		public static string StringFromNative(IntPtr pointer)
		{
			if (pointer == IntPtr.Zero)
			{
				return null;
			}
			int nativeStringLengthNotIncludingNullTerminator = GetNativeStringLengthNotIncludingNullTerminator(pointer);
			byte[] array = new byte[nativeStringLengthNotIncludingNullTerminator];
			Marshal.Copy(pointer, array, 0, nativeStringLengthNotIncludingNullTerminator);
			return nativeStringEncoding.GetString(array);
		}

		public static int GetNativeStringLengthNotIncludingNullTerminator(IntPtr pointer)
		{
			int i;
			for (i = 0; Marshal.ReadByte(pointer, i) != 0; i++)
			{
			}
			return i;
		}

		public static DateTime DateTimeFromNative(ulong seconds_since_the_one_true_epoch)
		{
			return new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(seconds_since_the_one_true_epoch).ToLocalTime();
		}

		public static byte[] BlobFromNative(uint size, IntPtr pointer)
		{
			byte[] array = new byte[size];
			for (int i = 0; i < (int)size; i++)
			{
				array[i] = Marshal.ReadByte(pointer, i);
			}
			return array;
		}

		public static byte[] FiledataFromNative(uint size, IntPtr pointer)
		{
			byte[] array = new byte[size];
			Marshal.Copy(pointer, array, 0, (int)size);
			return array;
		}

		public static IntPtr StringToNative(string s)
		{
			if (s == null)
			{
				throw new Exception("StringFromNative: null argument");
			}
			int byteCount = nativeStringEncoding.GetByteCount(s);
			byte[] array = new byte[byteCount + 1];
			nativeStringEncoding.GetBytes(s, 0, s.Length, array, 0);
			IntPtr intPtr = Marshal.AllocCoTaskMem(byteCount + 1);
			Marshal.Copy(array, 0, intPtr, byteCount + 1);
			return intPtr;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UnityInitWrapper(string appId);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UnityInitGlobals(IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_UnityInitWrapperAsynchronous(string appId);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UnityInitWrapperStandalone(string accessToken, IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Platform_InitializeStandaloneOculus(ref OculusInitParams init);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PlatformInitializeWithAccessToken(ulong appId, string accessToken);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UnityInitWrapperWindows(string appId, IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_UnityInitWrapperWindowsAsynchronous(string appId, IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_SetDeveloperAccessToken(string accessToken);

		public static string ovr_GetLoggedInUserLocale()
		{
			return StringFromNative(ovr_GetLoggedInUserLocale_Native());
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_GetLoggedInUserLocale")]
		private static extern IntPtr ovr_GetLoggedInUserLocale_Native();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_PopMessage();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_FreeMessage(IntPtr message);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_NetworkingPeer_GetSendPolicy(IntPtr networkingPeer);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Voip_CreateEncoder();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_DestroyEncoder(IntPtr encoder);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Voip_CreateDecoder();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_DestroyDecoder(IntPtr decoder);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipDecoder_Decode(IntPtr obj, byte[] compressedData, ulong compressedSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Microphone_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_Destroy(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetSystemVoipPassthrough(bool passthrough);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetSystemVoipMicrophoneMuted(VoipMuteState muted);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UnityResetTestPlatform();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_HTTP_GetWithMessageType(string url, int messageType);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_CrashApplication();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetMicrophoneFilterCallback(FilterCallback cb);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetMicrophoneFilterCallbackWithFixedSizeBuffer(FilterCallback cb, UIntPtr bufferSizeElements);

		public static void LogNewEvent(string eventName, Dictionary<string, string> values)
		{
			IntPtr intPtr = StringToNative(eventName);
			int num = values?.Count ?? 0;
			IntPtr[] array = new IntPtr[num * 2];
			if (num > 0)
			{
				int num2 = 0;
				foreach (KeyValuePair<string, string> value in values)
				{
					array[num2 * 2] = StringToNative(value.Key);
					array[num2 * 2 + 1] = StringToNative(value.Value);
					num2++;
				}
			}
			ovr_Log_NewEvent(intPtr, array, (UIntPtr)(ulong)num);
			Marshal.FreeCoTaskMem(intPtr);
			IntPtr[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				Marshal.FreeCoTaskMem(array2[i]);
			}
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Log_NewEvent(IntPtr eventName, IntPtr[] values, UIntPtr length);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_ApplicationLifecycle_GetLaunchDetails();

		public static ulong ovr_HTTP_StartTransfer(string url, ovrKeyValuePair[] headers)
		{
			IntPtr intPtr = StringToNative(url);
			UIntPtr numItems = (UIntPtr)(ulong)headers.Length;
			ulong result = ovr_HTTP_StartTransfer_Native(intPtr, headers, numItems);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_StartTransfer")]
		private static extern ulong ovr_HTTP_StartTransfer_Native(IntPtr url, ovrKeyValuePair[] headers, UIntPtr numItems);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_HTTP_Write(ulong transferId, byte[] bytes, UIntPtr length);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_HTTP_WriteEOM(ulong transferId);

		public static string ovr_Message_GetStringForJavascript(IntPtr message)
		{
			return StringFromNative(ovr_Message_GetStringForJavascript_Native(message));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Message_GetStringForJavascript")]
		private static extern IntPtr ovr_Message_GetStringForJavascript_Native(IntPtr message);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_Accept(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_AcceptForCurrentRoom();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_Close(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_CloseForCurrentRoom();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_Connect(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_IsConnected(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Net_Ping(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Net_ReadPacket();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_SendPacket(ulong userID, UIntPtr length, byte[] bytes, SendPolicy policy);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_SendPacketToCurrentRoom(UIntPtr length, byte[] bytes, SendPolicy policy);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_Party_PluginGetSharedMemHandle();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipMuteState ovr_Party_PluginGetVoipMicrophoneMuted();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Party_PluginGetVoipPassthrough();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemVoipStatus ovr_Party_PluginGetVoipStatus();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_Accept(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipDtxState ovr_Voip_GetIsConnectionUsingDtx(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipBitrate ovr_Voip_GetLocalBitrate(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetOutputBufferMaxSize();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCM(ulong senderID, short[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMFloat(ulong senderID, float[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMSize(ulong senderID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMWithTimestamp(ulong senderID, short[] outputBuffer, UIntPtr outputBufferNumElements, uint[] timestamp);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMWithTimestampFloat(ulong senderID, float[] outputBuffer, UIntPtr outputBufferNumElements, uint[] timestamp);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipBitrate ovr_Voip_GetRemoteBitrate(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Voip_GetSyncTimestamp(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_Voip_GetSyncTimestampDifference(uint lhs, uint rhs);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipMuteState ovr_Voip_GetSystemVoipMicrophoneMuted();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemVoipStatus ovr_Voip_GetSystemVoipStatus();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetMicrophoneMuted(VoipMuteState state);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetNewConnectionOptions(IntPtr voipOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetOutputSampleRate(VoipSampleRate rate);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_Start(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_Stop(ulong userID);

		public static ulong ovr_Achievements_AddCount(string name, ulong count)
		{
			IntPtr intPtr = StringToNative(name);
			ulong result = ovr_Achievements_AddCount_Native(intPtr, count);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Achievements_AddCount")]
		private static extern ulong ovr_Achievements_AddCount_Native(IntPtr name, ulong count);

		public static ulong ovr_Achievements_AddFields(string name, string fields)
		{
			IntPtr intPtr = StringToNative(name);
			IntPtr intPtr2 = StringToNative(fields);
			ulong result = ovr_Achievements_AddFields_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Achievements_AddFields")]
		private static extern ulong ovr_Achievements_AddFields_Native(IntPtr name, IntPtr fields);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetAllDefinitions();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetAllProgress();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetDefinitionsByName(string[] names, int count);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetProgressByName(string[] names, int count);

		public static ulong ovr_Achievements_Unlock(string name)
		{
			IntPtr intPtr = StringToNative(name);
			ulong result = ovr_Achievements_Unlock_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Achievements_Unlock")]
		private static extern ulong ovr_Achievements_Unlock_Native(IntPtr name);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_ExecuteCoordinatedLaunch(ulong appID, ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_GetInstalledApplications();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_GetVersion();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_LaunchOtherApp(ulong appID, IntPtr deeplink_options);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_ApplicationLifecycle_GetRegisteredPIDs();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_ApplicationLifecycle_GetSessionKey();

		public static ulong ovr_ApplicationLifecycle_RegisterSessionKey(string sessionKey)
		{
			IntPtr intPtr = StringToNative(sessionKey);
			ulong result = ovr_ApplicationLifecycle_RegisterSessionKey_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationLifecycle_RegisterSessionKey")]
		private static extern ulong ovr_ApplicationLifecycle_RegisterSessionKey_Native(IntPtr sessionKey);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_Delete(ulong assetFileID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_DeleteById(ulong assetFileID);

		public static ulong ovr_AssetFile_DeleteByName(string assetFileName)
		{
			IntPtr intPtr = StringToNative(assetFileName);
			ulong result = ovr_AssetFile_DeleteByName_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFile_DeleteByName")]
		private static extern ulong ovr_AssetFile_DeleteByName_Native(IntPtr assetFileName);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_Download(ulong assetFileID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_DownloadById(ulong assetFileID);

		public static ulong ovr_AssetFile_DownloadByName(string assetFileName)
		{
			IntPtr intPtr = StringToNative(assetFileName);
			ulong result = ovr_AssetFile_DownloadByName_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFile_DownloadByName")]
		private static extern ulong ovr_AssetFile_DownloadByName_Native(IntPtr assetFileName);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_DownloadCancel(ulong assetFileID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_DownloadCancelById(ulong assetFileID);

		public static ulong ovr_AssetFile_DownloadCancelByName(string assetFileName)
		{
			IntPtr intPtr = StringToNative(assetFileName);
			ulong result = ovr_AssetFile_DownloadCancelByName_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFile_DownloadCancelByName")]
		private static extern ulong ovr_AssetFile_DownloadCancelByName_Native(IntPtr assetFileName);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_GetList();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_Status(ulong assetFileID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_StatusById(ulong assetFileID);

		public static ulong ovr_AssetFile_StatusByName(string assetFileName)
		{
			IntPtr intPtr = StringToNative(assetFileName);
			ulong result = ovr_AssetFile_StatusByName_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFile_StatusByName")]
		private static extern ulong ovr_AssetFile_StatusByName_Native(IntPtr assetFileName);

		public static ulong ovr_Avatar_UpdateMetaData(string avatarMetaData, string imageFilePath)
		{
			IntPtr intPtr = StringToNative(avatarMetaData);
			IntPtr intPtr2 = StringToNative(imageFilePath);
			ulong result = ovr_Avatar_UpdateMetaData_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Avatar_UpdateMetaData")]
		private static extern ulong ovr_Avatar_UpdateMetaData_Native(IntPtr avatarMetaData, IntPtr imageFilePath);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Cal_FinalizeApplication(ulong groupingObject, ulong[] userIDs, int numUserIDs, ulong finalized_application_ID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Cal_GetSuggestedApplications(ulong groupingObject, ulong[] userIDs, int numUserIDs);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Cal_ProposeApplication(ulong groupingObject, ulong[] userIDs, int numUserIDs, ulong proposed_application_ID);

		public static ulong ovr_CloudStorage_Delete(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_Delete_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_Delete")]
		private static extern ulong ovr_CloudStorage_Delete_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_Load(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_Load_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_Load")]
		private static extern ulong ovr_CloudStorage_Load_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_LoadBucketMetadata(string bucket)
		{
			IntPtr intPtr = StringToNative(bucket);
			ulong result = ovr_CloudStorage_LoadBucketMetadata_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadBucketMetadata")]
		private static extern ulong ovr_CloudStorage_LoadBucketMetadata_Native(IntPtr bucket);

		public static ulong ovr_CloudStorage_LoadConflictMetadata(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_LoadConflictMetadata_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadConflictMetadata")]
		private static extern ulong ovr_CloudStorage_LoadConflictMetadata_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_LoadHandle(string handle)
		{
			IntPtr intPtr = StringToNative(handle);
			ulong result = ovr_CloudStorage_LoadHandle_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadHandle")]
		private static extern ulong ovr_CloudStorage_LoadHandle_Native(IntPtr handle);

		public static ulong ovr_CloudStorage_LoadMetadata(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_LoadMetadata_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadMetadata")]
		private static extern ulong ovr_CloudStorage_LoadMetadata_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_ResolveKeepLocal(string bucket, string key, string remoteHandle)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			IntPtr intPtr3 = StringToNative(remoteHandle);
			ulong result = ovr_CloudStorage_ResolveKeepLocal_Native(intPtr, intPtr2, intPtr3);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_ResolveKeepLocal")]
		private static extern ulong ovr_CloudStorage_ResolveKeepLocal_Native(IntPtr bucket, IntPtr key, IntPtr remoteHandle);

		public static ulong ovr_CloudStorage_ResolveKeepRemote(string bucket, string key, string remoteHandle)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			IntPtr intPtr3 = StringToNative(remoteHandle);
			ulong result = ovr_CloudStorage_ResolveKeepRemote_Native(intPtr, intPtr2, intPtr3);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_ResolveKeepRemote")]
		private static extern ulong ovr_CloudStorage_ResolveKeepRemote_Native(IntPtr bucket, IntPtr key, IntPtr remoteHandle);

		public static ulong ovr_CloudStorage_Save(string bucket, string key, byte[] data, uint dataSize, long counter, string extraData)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			IntPtr intPtr3 = StringToNative(extraData);
			ulong result = ovr_CloudStorage_Save_Native(intPtr, intPtr2, data, dataSize, counter, intPtr3);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_Save")]
		private static extern ulong ovr_CloudStorage_Save_Native(IntPtr bucket, IntPtr key, byte[] data, uint dataSize, long counter, IntPtr extraData);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CloudStorage2_GetUserDirectoryPath();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Entitlement_GetIsViewerEntitled();

		public static ulong ovr_GraphAPI_Get(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_GraphAPI_Get_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_GraphAPI_Get")]
		private static extern ulong ovr_GraphAPI_Get_Native(IntPtr url);

		public static ulong ovr_GraphAPI_Post(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_GraphAPI_Post_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_GraphAPI_Post")]
		private static extern ulong ovr_GraphAPI_Post_Native(IntPtr url);

		public static ulong ovr_HTTP_Get(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_HTTP_Get_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_Get")]
		private static extern ulong ovr_HTTP_Get_Native(IntPtr url);

		public static ulong ovr_HTTP_GetToFile(string url, string diskFile)
		{
			IntPtr intPtr = StringToNative(url);
			IntPtr intPtr2 = StringToNative(diskFile);
			ulong result = ovr_HTTP_GetToFile_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_GetToFile")]
		private static extern ulong ovr_HTTP_GetToFile_Native(IntPtr url, IntPtr diskFile);

		public static ulong ovr_HTTP_MultiPartPost(string url, string filepath_param_name, string filepath, string access_token, ovrKeyValuePair[] post_params)
		{
			IntPtr intPtr = StringToNative(url);
			IntPtr intPtr2 = StringToNative(filepath_param_name);
			IntPtr intPtr3 = StringToNative(filepath);
			IntPtr intPtr4 = StringToNative(access_token);
			UIntPtr numItems = (UIntPtr)(ulong)post_params.Length;
			ulong result = ovr_HTTP_MultiPartPost_Native(intPtr, intPtr2, intPtr3, intPtr4, post_params, numItems);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			Marshal.FreeCoTaskMem(intPtr4);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_MultiPartPost")]
		private static extern ulong ovr_HTTP_MultiPartPost_Native(IntPtr url, IntPtr filepath_param_name, IntPtr filepath, IntPtr access_token, ovrKeyValuePair[] post_params, UIntPtr numItems);

		public static ulong ovr_HTTP_Post(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_HTTP_Post_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_Post")]
		private static extern ulong ovr_HTTP_Post_Native(IntPtr url);

		public static ulong ovr_IAP_ConsumePurchase(string sku)
		{
			IntPtr intPtr = StringToNative(sku);
			ulong result = ovr_IAP_ConsumePurchase_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_IAP_ConsumePurchase")]
		private static extern ulong ovr_IAP_ConsumePurchase_Native(IntPtr sku);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_IAP_GetProductsBySKU(string[] skus, int count);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_IAP_GetViewerPurchases();

		public static ulong ovr_IAP_LaunchCheckoutFlow(string sku)
		{
			IntPtr intPtr = StringToNative(sku);
			ulong result = ovr_IAP_LaunchCheckoutFlow_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_IAP_LaunchCheckoutFlow")]
		private static extern ulong ovr_IAP_LaunchCheckoutFlow_Native(IntPtr sku);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LanguagePack_GetCurrent();

		public static ulong ovr_LanguagePack_SetCurrent(string tag)
		{
			IntPtr intPtr = StringToNative(tag);
			ulong result = ovr_LanguagePack_SetCurrent_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LanguagePack_SetCurrent")]
		private static extern ulong ovr_LanguagePack_SetCurrent_Native(IntPtr tag);

		public static ulong ovr_Leaderboard_GetEntries(string leaderboardName, int limit, LeaderboardFilterType filter, LeaderboardStartAt startAt)
		{
			IntPtr intPtr = StringToNative(leaderboardName);
			ulong result = ovr_Leaderboard_GetEntries_Native(intPtr, limit, filter, startAt);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Leaderboard_GetEntries")]
		private static extern ulong ovr_Leaderboard_GetEntries_Native(IntPtr leaderboardName, int limit, LeaderboardFilterType filter, LeaderboardStartAt startAt);

		public static ulong ovr_Leaderboard_GetEntriesAfterRank(string leaderboardName, int limit, ulong afterRank)
		{
			IntPtr intPtr = StringToNative(leaderboardName);
			ulong result = ovr_Leaderboard_GetEntriesAfterRank_Native(intPtr, limit, afterRank);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Leaderboard_GetEntriesAfterRank")]
		private static extern ulong ovr_Leaderboard_GetEntriesAfterRank_Native(IntPtr leaderboardName, int limit, ulong afterRank);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Leaderboard_GetNextEntries(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Leaderboard_GetPreviousEntries(IntPtr handle);

		public static ulong ovr_Leaderboard_WriteEntry(string leaderboardName, long score, byte[] extraData, uint extraDataLength, bool forceUpdate)
		{
			IntPtr intPtr = StringToNative(leaderboardName);
			ulong result = ovr_Leaderboard_WriteEntry_Native(intPtr, score, extraData, extraDataLength, forceUpdate);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Leaderboard_WriteEntry")]
		private static extern ulong ovr_Leaderboard_WriteEntry_Native(IntPtr leaderboardName, long score, byte[] extraData, uint extraDataLength, bool forceUpdate);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_GetStatus();

		public static ulong ovr_Livestreaming_IsAllowedForApplication(string packageName)
		{
			IntPtr intPtr = StringToNative(packageName);
			ulong result = ovr_Livestreaming_IsAllowedForApplication_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Livestreaming_IsAllowedForApplication")]
		private static extern ulong ovr_Livestreaming_IsAllowedForApplication_Native(IntPtr packageName);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_PauseStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_ResumeStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_StartPartyStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_StartStream(LivestreamingAudience audience, LivestreamingMicrophoneStatus micStatus);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_StopPartyStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_StopStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_UpdateCommentsOverlayVisibility(bool isVisible);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_UpdateMicStatus(LivestreamingMicrophoneStatus micStatus);

		public static ulong ovr_Matchmaking_Browse(string pool, IntPtr customQueryData)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Browse_Native(intPtr, customQueryData);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Browse")]
		private static extern ulong ovr_Matchmaking_Browse_Native(IntPtr pool, IntPtr customQueryData);

		public static ulong ovr_Matchmaking_Browse2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Browse2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Browse2")]
		private static extern ulong ovr_Matchmaking_Browse2_Native(IntPtr pool, IntPtr matchmakingOptions);

		public static ulong ovr_Matchmaking_Cancel(string pool, string requestHash)
		{
			IntPtr intPtr = StringToNative(pool);
			IntPtr intPtr2 = StringToNative(requestHash);
			ulong result = ovr_Matchmaking_Cancel_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Cancel")]
		private static extern ulong ovr_Matchmaking_Cancel_Native(IntPtr pool, IntPtr requestHash);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_Cancel2();

		public static ulong ovr_Matchmaking_CreateAndEnqueueRoom(string pool, uint maxUsers, bool subscribeToUpdates, IntPtr customQueryData)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateAndEnqueueRoom_Native(intPtr, maxUsers, subscribeToUpdates, customQueryData);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateAndEnqueueRoom")]
		private static extern ulong ovr_Matchmaking_CreateAndEnqueueRoom_Native(IntPtr pool, uint maxUsers, bool subscribeToUpdates, IntPtr customQueryData);

		public static ulong ovr_Matchmaking_CreateAndEnqueueRoom2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateAndEnqueueRoom2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateAndEnqueueRoom2")]
		private static extern ulong ovr_Matchmaking_CreateAndEnqueueRoom2_Native(IntPtr pool, IntPtr matchmakingOptions);

		public static ulong ovr_Matchmaking_CreateRoom(string pool, uint maxUsers, bool subscribeToUpdates)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateRoom_Native(intPtr, maxUsers, subscribeToUpdates);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateRoom")]
		private static extern ulong ovr_Matchmaking_CreateRoom_Native(IntPtr pool, uint maxUsers, bool subscribeToUpdates);

		public static ulong ovr_Matchmaking_CreateRoom2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateRoom2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateRoom2")]
		private static extern ulong ovr_Matchmaking_CreateRoom2_Native(IntPtr pool, IntPtr matchmakingOptions);

		public static ulong ovr_Matchmaking_Enqueue(string pool, IntPtr customQueryData)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Enqueue_Native(intPtr, customQueryData);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Enqueue")]
		private static extern ulong ovr_Matchmaking_Enqueue_Native(IntPtr pool, IntPtr customQueryData);

		public static ulong ovr_Matchmaking_Enqueue2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Enqueue2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Enqueue2")]
		private static extern ulong ovr_Matchmaking_Enqueue2_Native(IntPtr pool, IntPtr matchmakingOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_EnqueueRoom(ulong roomID, IntPtr customQueryData);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_EnqueueRoom2(ulong roomID, IntPtr matchmakingOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_GetAdminSnapshot();

		public static ulong ovr_Matchmaking_GetStats(string pool, uint maxLevel, MatchmakingStatApproach approach)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_GetStats_Native(intPtr, maxLevel, approach);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_GetStats")]
		private static extern ulong ovr_Matchmaking_GetStats_Native(IntPtr pool, uint maxLevel, MatchmakingStatApproach approach);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_JoinRoom(ulong roomID, bool subscribeToUpdates);

		public static ulong ovr_Matchmaking_ReportResultInsecure(ulong roomID, ovrKeyValuePair[] data)
		{
			UIntPtr numItems = (UIntPtr)(ulong)data.Length;
			return ovr_Matchmaking_ReportResultInsecure_Native(roomID, data, numItems);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_ReportResultInsecure")]
		private static extern ulong ovr_Matchmaking_ReportResultInsecure_Native(ulong roomID, ovrKeyValuePair[] data, UIntPtr numItems);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_StartMatch(ulong roomID);

		public static ulong ovr_Media_ShareToFacebook(string postTextSuggestion, string filePath, MediaContentType contentType)
		{
			IntPtr intPtr = StringToNative(postTextSuggestion);
			IntPtr intPtr2 = StringToNative(filePath);
			ulong result = ovr_Media_ShareToFacebook_Native(intPtr, intPtr2, contentType);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Media_ShareToFacebook")]
		private static extern ulong ovr_Media_ShareToFacebook_Native(IntPtr postTextSuggestion, IntPtr filePath, MediaContentType contentType);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Notification_GetRoomInvites();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Notification_MarkAsRead(ulong notificationID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GatherInApplication(ulong partyID, ulong appID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Get(ulong partyID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GetCurrent();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GetCurrentForUser(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Invite(ulong partyID, ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Join(ulong partyID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Leave(ulong partyID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_CreateAndJoinPrivate(RoomJoinPolicy joinPolicy, uint maxUsers, bool subscribeToUpdates);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_CreateAndJoinPrivate2(RoomJoinPolicy joinPolicy, uint maxUsers, IntPtr roomOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Get(ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetCurrent();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetCurrentForUser(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetInvitableUsers();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetInvitableUsers2(IntPtr roomOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetModeratedRooms();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetSocialRooms(ulong appID);

		public static ulong ovr_Room_InviteUser(ulong roomID, string inviteToken)
		{
			IntPtr intPtr = StringToNative(inviteToken);
			ulong result = ovr_Room_InviteUser_Native(roomID, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_InviteUser")]
		private static extern ulong ovr_Room_InviteUser_Native(ulong roomID, IntPtr inviteToken);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Join(ulong roomID, bool subscribeToUpdates);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Join2(ulong roomID, IntPtr roomOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_KickUser(ulong roomID, ulong userID, int kickDurationSeconds);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_LaunchInvitableUserFlow(ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Leave(ulong roomID);

		public static ulong ovr_Room_SetDescription(ulong roomID, string description)
		{
			IntPtr intPtr = StringToNative(description);
			ulong result = ovr_Room_SetDescription_Native(roomID, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_SetDescription")]
		private static extern ulong ovr_Room_SetDescription_Native(ulong roomID, IntPtr description);

		public static ulong ovr_Room_UpdateDataStore(ulong roomID, ovrKeyValuePair[] data)
		{
			UIntPtr numItems = (UIntPtr)(ulong)data.Length;
			return ovr_Room_UpdateDataStore_Native(roomID, data, numItems);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_UpdateDataStore")]
		private static extern ulong ovr_Room_UpdateDataStore_Native(ulong roomID, ovrKeyValuePair[] data, UIntPtr numItems);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdateMembershipLockStatus(ulong roomID, RoomMembershipLockStatus membershipLockStatus);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdateOwner(ulong roomID, ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdatePrivateRoomJoinPolicy(ulong roomID, RoomJoinPolicy newJoinPolicy);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_SystemPermissions_GetStatus(PermissionType permType);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_SystemPermissions_LaunchDeeplink(PermissionType permType);

		public static ulong ovr_User_CancelRecordingForReportFlow(string recordingUUID)
		{
			IntPtr intPtr = StringToNative(recordingUUID);
			ulong result = ovr_User_CancelRecordingForReportFlow_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_CancelRecordingForReportFlow")]
		private static extern ulong ovr_User_CancelRecordingForReportFlow_Native(IntPtr recordingUUID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_Get(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetAccessToken();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLinkedAccounts(IntPtr userOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUser();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUserFriends();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUserFriendsAndRooms();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUserRecentlyMetUsersAndRooms(IntPtr userOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetOrgScopedID(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetSdkAccounts();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetUserProof();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchBlockFlow(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchFriendRequestFlow(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchProfile(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchReportFlow(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchReportFlow2(ulong optionalUserID, IntPtr abuseReportOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchUnblockFlow(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_NewEntitledTestUser();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_NewTestUser();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_NewTestUserFriends();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_StartRecordingForReportFlow();

		public static ulong ovr_User_StopRecordingAndLaunchReportFlow(ulong optionalUserID, string optionalRecordingUUID)
		{
			IntPtr intPtr = StringToNative(optionalRecordingUUID);
			ulong result = ovr_User_StopRecordingAndLaunchReportFlow_Native(optionalUserID, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_StopRecordingAndLaunchReportFlow")]
		private static extern ulong ovr_User_StopRecordingAndLaunchReportFlow_Native(ulong optionalUserID, IntPtr optionalRecordingUUID);

		public static ulong ovr_User_StopRecordingAndLaunchReportFlow2(ulong optionalUserID, string optionalRecordingUUID, IntPtr abuseReportOptions)
		{
			IntPtr intPtr = StringToNative(optionalRecordingUUID);
			ulong result = ovr_User_StopRecordingAndLaunchReportFlow2_Native(optionalUserID, intPtr, abuseReportOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_StopRecordingAndLaunchReportFlow2")]
		private static extern ulong ovr_User_StopRecordingAndLaunchReportFlow2_Native(ulong optionalUserID, IntPtr optionalRecordingUUID, IntPtr abuseReportOptions);

		public static ulong ovr_User_TestUserCreateDeviceManifest(string deviceID, ulong[] appIDs, int numAppIDs)
		{
			IntPtr intPtr = StringToNative(deviceID);
			ulong result = ovr_User_TestUserCreateDeviceManifest_Native(intPtr, appIDs, numAppIDs);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_TestUserCreateDeviceManifest")]
		private static extern ulong ovr_User_TestUserCreateDeviceManifest_Native(IntPtr deviceID, ulong[] appIDs, int numAppIDs);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Voip_SetSystemVoipSuppressed(bool suppressed);

		public static string ovr_AbuseReportRecording_GetRecordingUuid(IntPtr obj)
		{
			return StringFromNative(ovr_AbuseReportRecording_GetRecordingUuid_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AbuseReportRecording_GetRecordingUuid")]
		private static extern IntPtr ovr_AbuseReportRecording_GetRecordingUuid_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_AchievementDefinition_GetBitfieldLength(IntPtr obj);

		public static string ovr_AchievementDefinition_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementDefinition_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementDefinition_GetName")]
		private static extern IntPtr ovr_AchievementDefinition_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AchievementDefinition_GetTarget(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern AchievementType ovr_AchievementDefinition_GetType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AchievementDefinitionArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_AchievementDefinitionArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementDefinitionArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementDefinitionArray_GetNextUrl")]
		private static extern IntPtr ovr_AchievementDefinitionArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_AchievementDefinitionArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementDefinitionArray_HasNextPage(IntPtr obj);

		public static string ovr_AchievementProgress_GetBitfield(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementProgress_GetBitfield_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgress_GetBitfield")]
		private static extern IntPtr ovr_AchievementProgress_GetBitfield_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AchievementProgress_GetCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementProgress_GetIsUnlocked(IntPtr obj);

		public static string ovr_AchievementProgress_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementProgress_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgress_GetName")]
		private static extern IntPtr ovr_AchievementProgress_GetName_Native(IntPtr obj);

		public static DateTime ovr_AchievementProgress_GetUnlockTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_AchievementProgress_GetUnlockTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgress_GetUnlockTime")]
		private static extern ulong ovr_AchievementProgress_GetUnlockTime_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AchievementProgressArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_AchievementProgressArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementProgressArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgressArray_GetNextUrl")]
		private static extern IntPtr ovr_AchievementProgressArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_AchievementProgressArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementProgressArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementUpdate_GetJustUnlocked(IntPtr obj);

		public static string ovr_AchievementUpdate_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementUpdate_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementUpdate_GetName")]
		private static extern IntPtr ovr_AchievementUpdate_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_ApplicationVersion_GetCurrentCode(IntPtr obj);

		public static string ovr_ApplicationVersion_GetCurrentName(IntPtr obj)
		{
			return StringFromNative(ovr_ApplicationVersion_GetCurrentName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationVersion_GetCurrentName")]
		private static extern IntPtr ovr_ApplicationVersion_GetCurrentName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_ApplicationVersion_GetLatestCode(IntPtr obj);

		public static string ovr_ApplicationVersion_GetLatestName(IntPtr obj)
		{
			return StringFromNative(ovr_ApplicationVersion_GetLatestName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationVersion_GetLatestName")]
		private static extern IntPtr ovr_ApplicationVersion_GetLatestName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetDetails_GetAssetId(IntPtr obj);

		public static string ovr_AssetDetails_GetAssetType(IntPtr obj)
		{
			return StringFromNative(ovr_AssetDetails_GetAssetType_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetDetails_GetAssetType")]
		private static extern IntPtr ovr_AssetDetails_GetAssetType_Native(IntPtr obj);

		public static string ovr_AssetDetails_GetDownloadStatus(IntPtr obj)
		{
			return StringFromNative(ovr_AssetDetails_GetDownloadStatus_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetDetails_GetDownloadStatus")]
		private static extern IntPtr ovr_AssetDetails_GetDownloadStatus_Native(IntPtr obj);

		public static string ovr_AssetDetails_GetFilepath(IntPtr obj)
		{
			return StringFromNative(ovr_AssetDetails_GetFilepath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetDetails_GetFilepath")]
		private static extern IntPtr ovr_AssetDetails_GetFilepath_Native(IntPtr obj);

		public static string ovr_AssetDetails_GetIapStatus(IntPtr obj)
		{
			return StringFromNative(ovr_AssetDetails_GetIapStatus_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetDetails_GetIapStatus")]
		private static extern IntPtr ovr_AssetDetails_GetIapStatus_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AssetDetails_GetLanguage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AssetDetailsArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_AssetDetailsArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDeleteResult_GetAssetFileId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDeleteResult_GetAssetId(IntPtr obj);

		public static string ovr_AssetFileDeleteResult_GetFilepath(IntPtr obj)
		{
			return StringFromNative(ovr_AssetFileDeleteResult_GetFilepath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFileDeleteResult_GetFilepath")]
		private static extern IntPtr ovr_AssetFileDeleteResult_GetFilepath_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AssetFileDeleteResult_GetSuccess(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadCancelResult_GetAssetFileId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadCancelResult_GetAssetId(IntPtr obj);

		public static string ovr_AssetFileDownloadCancelResult_GetFilepath(IntPtr obj)
		{
			return StringFromNative(ovr_AssetFileDownloadCancelResult_GetFilepath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFileDownloadCancelResult_GetFilepath")]
		private static extern IntPtr ovr_AssetFileDownloadCancelResult_GetFilepath_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AssetFileDownloadCancelResult_GetSuccess(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadResult_GetAssetId(IntPtr obj);

		public static string ovr_AssetFileDownloadResult_GetFilepath(IntPtr obj)
		{
			return StringFromNative(ovr_AssetFileDownloadResult_GetFilepath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFileDownloadResult_GetFilepath")]
		private static extern IntPtr ovr_AssetFileDownloadResult_GetFilepath_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadUpdate_GetAssetFileId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadUpdate_GetAssetId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_AssetFileDownloadUpdate_GetBytesTotal(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_AssetFileDownloadUpdate_GetBytesTransferred(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AssetFileDownloadUpdate_GetCompleted(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_CalApplicationFinalized_GetCountdownMS(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CalApplicationFinalized_GetID(IntPtr obj);

		public static string ovr_CalApplicationFinalized_GetLaunchDetails(IntPtr obj)
		{
			return StringFromNative(ovr_CalApplicationFinalized_GetLaunchDetails_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CalApplicationFinalized_GetLaunchDetails")]
		private static extern IntPtr ovr_CalApplicationFinalized_GetLaunchDetails_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CalApplicationProposed_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CalApplicationSuggestion_GetID(IntPtr obj);

		public static string ovr_CalApplicationSuggestion_GetSocialContext(IntPtr obj)
		{
			return StringFromNative(ovr_CalApplicationSuggestion_GetSocialContext_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CalApplicationSuggestion_GetSocialContext")]
		private static extern IntPtr ovr_CalApplicationSuggestion_GetSocialContext_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CalApplicationSuggestionArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_CalApplicationSuggestionArray_GetSize(IntPtr obj);

		public static string ovr_CloudStorage2UserDirectoryPathResponse_GetPath(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorage2UserDirectoryPathResponse_GetPath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage2UserDirectoryPathResponse_GetPath")]
		private static extern IntPtr ovr_CloudStorage2UserDirectoryPathResponse_GetPath_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CloudStorageConflictMetadata_GetLocal(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CloudStorageConflictMetadata_GetRemote(IntPtr obj);

		public static string ovr_CloudStorageData_GetBucket(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageData_GetBucket_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageData_GetBucket")]
		private static extern IntPtr ovr_CloudStorageData_GetBucket_Native(IntPtr obj);

		public static byte[] ovr_CloudStorageData_GetData(IntPtr obj)
		{
			return FiledataFromNative(ovr_CloudStorageData_GetDataSize(obj), ovr_CloudStorageData_GetData_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageData_GetData")]
		private static extern IntPtr ovr_CloudStorageData_GetData_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_CloudStorageData_GetDataSize(IntPtr obj);

		public static string ovr_CloudStorageData_GetKey(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageData_GetKey_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageData_GetKey")]
		private static extern IntPtr ovr_CloudStorageData_GetKey_Native(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetBucket(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetBucket_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetBucket")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetBucket_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_CloudStorageMetadata_GetCounter(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_CloudStorageMetadata_GetDataSize(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetExtraData(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetExtraData_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetExtraData")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetExtraData_Native(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetKey(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetKey_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetKey")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetKey_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CloudStorageMetadata_GetSaveTime(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern CloudStorageDataStatus ovr_CloudStorageMetadata_GetStatus(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetVersionHandle(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetVersionHandle_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetVersionHandle")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetVersionHandle_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CloudStorageMetadataArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_CloudStorageMetadataArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadataArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadataArray_GetNextUrl")]
		private static extern IntPtr ovr_CloudStorageMetadataArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_CloudStorageMetadataArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_CloudStorageMetadataArray_HasNextPage(IntPtr obj);

		public static string ovr_CloudStorageUpdateResponse_GetBucket(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageUpdateResponse_GetBucket_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageUpdateResponse_GetBucket")]
		private static extern IntPtr ovr_CloudStorageUpdateResponse_GetBucket_Native(IntPtr obj);

		public static string ovr_CloudStorageUpdateResponse_GetKey(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageUpdateResponse_GetKey_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageUpdateResponse_GetKey")]
		private static extern IntPtr ovr_CloudStorageUpdateResponse_GetKey_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern CloudStorageUpdateStatus ovr_CloudStorageUpdateResponse_GetStatus(IntPtr obj);

		public static string ovr_CloudStorageUpdateResponse_GetVersionHandle(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageUpdateResponse_GetVersionHandle_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageUpdateResponse_GetVersionHandle")]
		private static extern IntPtr ovr_CloudStorageUpdateResponse_GetVersionHandle_Native(IntPtr obj);

		public static uint ovr_DataStore_Contains(IntPtr obj, string key)
		{
			IntPtr intPtr = StringToNative(key);
			uint result = ovr_DataStore_Contains_Native(obj, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DataStore_Contains")]
		private static extern uint ovr_DataStore_Contains_Native(IntPtr obj, IntPtr key);

		public static string ovr_DataStore_GetKey(IntPtr obj, int index)
		{
			return StringFromNative(ovr_DataStore_GetKey_Native(obj, index));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DataStore_GetKey")]
		private static extern IntPtr ovr_DataStore_GetKey_Native(IntPtr obj, int index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_DataStore_GetNumKeys(IntPtr obj);

		public static string ovr_DataStore_GetValue(IntPtr obj, string key)
		{
			IntPtr intPtr = StringToNative(key);
			string result = StringFromNative(ovr_DataStore_GetValue_Native(obj, intPtr));
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DataStore_GetValue")]
		private static extern IntPtr ovr_DataStore_GetValue_Native(IntPtr obj, IntPtr key);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_Error_GetCode(IntPtr obj);

		public static string ovr_Error_GetDisplayableMessage(IntPtr obj)
		{
			return StringFromNative(ovr_Error_GetDisplayableMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Error_GetDisplayableMessage")]
		private static extern IntPtr ovr_Error_GetDisplayableMessage_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_Error_GetHttpCode(IntPtr obj);

		public static string ovr_Error_GetMessage(IntPtr obj)
		{
			return StringFromNative(ovr_Error_GetMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Error_GetMessage")]
		private static extern IntPtr ovr_Error_GetMessage_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_HttpTransferUpdate_GetBytes(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_HttpTransferUpdate_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_HttpTransferUpdate_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_HttpTransferUpdate_IsCompleted(IntPtr obj);

		public static string ovr_InstalledApplication_GetApplicationId(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetApplicationId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetApplicationId")]
		private static extern IntPtr ovr_InstalledApplication_GetApplicationId_Native(IntPtr obj);

		public static string ovr_InstalledApplication_GetPackageName(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetPackageName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetPackageName")]
		private static extern IntPtr ovr_InstalledApplication_GetPackageName_Native(IntPtr obj);

		public static string ovr_InstalledApplication_GetStatus(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetStatus_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetStatus")]
		private static extern IntPtr ovr_InstalledApplication_GetStatus_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_InstalledApplication_GetVersionCode(IntPtr obj);

		public static string ovr_InstalledApplication_GetVersionName(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetVersionName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetVersionName")]
		private static extern IntPtr ovr_InstalledApplication_GetVersionName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_InstalledApplicationArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_InstalledApplicationArray_GetSize(IntPtr obj);

		public static string ovr_LanguagePackInfo_GetEnglishName(IntPtr obj)
		{
			return StringFromNative(ovr_LanguagePackInfo_GetEnglishName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LanguagePackInfo_GetEnglishName")]
		private static extern IntPtr ovr_LanguagePackInfo_GetEnglishName_Native(IntPtr obj);

		public static string ovr_LanguagePackInfo_GetNativeName(IntPtr obj)
		{
			return StringFromNative(ovr_LanguagePackInfo_GetNativeName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LanguagePackInfo_GetNativeName")]
		private static extern IntPtr ovr_LanguagePackInfo_GetNativeName_Native(IntPtr obj);

		public static string ovr_LanguagePackInfo_GetTag(IntPtr obj)
		{
			return StringFromNative(ovr_LanguagePackInfo_GetTag_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LanguagePackInfo_GetTag")]
		private static extern IntPtr ovr_LanguagePackInfo_GetTag_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchBlockFlowResult_GetDidBlock(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchBlockFlowResult_GetDidCancel(IntPtr obj);

		public static string ovr_LaunchDetails_GetDeeplinkMessage(IntPtr obj)
		{
			return StringFromNative(ovr_LaunchDetails_GetDeeplinkMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LaunchDetails_GetDeeplinkMessage")]
		private static extern IntPtr ovr_LaunchDetails_GetDeeplinkMessage_Native(IntPtr obj);

		public static string ovr_LaunchDetails_GetLaunchSource(IntPtr obj)
		{
			return StringFromNative(ovr_LaunchDetails_GetLaunchSource_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LaunchDetails_GetLaunchSource")]
		private static extern IntPtr ovr_LaunchDetails_GetLaunchSource_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern LaunchType ovr_LaunchDetails_GetLaunchType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LaunchDetails_GetRoomID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LaunchDetails_GetUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchFriendRequestFlowResult_GetDidCancel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchFriendRequestFlowResult_GetDidSendRequest(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchReportFlowResult_GetDidCancel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LaunchReportFlowResult_GetUserReportId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchUnblockFlowResult_GetDidCancel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchUnblockFlowResult_GetDidUnblock(IntPtr obj);

		public static byte[] ovr_LeaderboardEntry_GetExtraData(IntPtr obj)
		{
			return BlobFromNative(ovr_LeaderboardEntry_GetExtraDataLength(obj), ovr_LeaderboardEntry_GetExtraData_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntry_GetExtraData")]
		private static extern IntPtr ovr_LeaderboardEntry_GetExtraData_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_LeaderboardEntry_GetExtraDataLength(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LeaderboardEntry_GetRank(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_LeaderboardEntry_GetScore(IntPtr obj);

		public static DateTime ovr_LeaderboardEntry_GetTimestamp(IntPtr obj)
		{
			return DateTimeFromNative(ovr_LeaderboardEntry_GetTimestamp_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntry_GetTimestamp")]
		private static extern ulong ovr_LeaderboardEntry_GetTimestamp_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LeaderboardEntry_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LeaderboardEntryArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_LeaderboardEntryArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_LeaderboardEntryArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntryArray_GetNextUrl")]
		private static extern IntPtr ovr_LeaderboardEntryArray_GetNextUrl_Native(IntPtr obj);

		public static string ovr_LeaderboardEntryArray_GetPreviousUrl(IntPtr obj)
		{
			return StringFromNative(ovr_LeaderboardEntryArray_GetPreviousUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntryArray_GetPreviousUrl")]
		private static extern IntPtr ovr_LeaderboardEntryArray_GetPreviousUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_LeaderboardEntryArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LeaderboardEntryArray_GetTotalCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LeaderboardEntryArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LeaderboardEntryArray_HasPreviousPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LeaderboardUpdateStatus_GetDidUpdate(IntPtr obj);

		public static string ovr_LinkedAccount_GetAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_LinkedAccount_GetAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LinkedAccount_GetAccessToken")]
		private static extern IntPtr ovr_LinkedAccount_GetAccessToken_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ServiceProvider ovr_LinkedAccount_GetServiceProvider(IntPtr obj);

		public static string ovr_LinkedAccount_GetUserId(IntPtr obj)
		{
			return StringFromNative(ovr_LinkedAccount_GetUserId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LinkedAccount_GetUserId")]
		private static extern IntPtr ovr_LinkedAccount_GetUserId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LinkedAccountArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_LinkedAccountArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingApplicationStatus_GetStreamingEnabled(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern LivestreamingStartStatus ovr_LivestreamingStartResult_GetStreamingResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetCommentsVisible(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetIsPaused(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetLivestreamingEnabled(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LivestreamingStatus_GetLivestreamingType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetMicEnabled(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LivestreamingVideoStats_GetCommentCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LivestreamingVideoStats_GetReactionCount(IntPtr obj);

		public static string ovr_LivestreamingVideoStats_GetTotalViews(IntPtr obj)
		{
			return StringFromNative(ovr_LivestreamingVideoStats_GetTotalViews_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LivestreamingVideoStats_GetTotalViews")]
		private static extern IntPtr ovr_LivestreamingVideoStats_GetTotalViews_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingAdminSnapshot_GetCandidates(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshot_GetMyCurrentThreshold(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_MatchmakingAdminSnapshotCandidate_GetCanMatch(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshotCandidate_GetMyTotalScore(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshotCandidate_GetTheirCurrentThreshold(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshotCandidate_GetTheirTotalScore(IntPtr obj);

		public static string ovr_MatchmakingAdminSnapshotCandidate_GetTraceId(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingAdminSnapshotCandidate_GetTraceId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingAdminSnapshotCandidate_GetTraceId")]
		private static extern IntPtr ovr_MatchmakingAdminSnapshotCandidate_GetTraceId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingAdminSnapshotCandidateArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingAdminSnapshotCandidateArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingBrowseResult_GetEnqueueResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingBrowseResult_GetRooms(IntPtr obj);

		public static string ovr_MatchmakingCandidate_GetEntryHash(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingCandidate_GetEntryHash_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingCandidate_GetEntryHash")]
		private static extern IntPtr ovr_MatchmakingCandidate_GetEntryHash_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_MatchmakingCandidate_GetUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingCandidateArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_MatchmakingCandidateArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingCandidateArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingCandidateArray_GetNextUrl")]
		private static extern IntPtr ovr_MatchmakingCandidateArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingCandidateArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_MatchmakingCandidateArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueueResult_GetAdminSnapshot(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetAverageWait(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetMatchesInLastHourCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetMaxExpectedWait(IntPtr obj);

		public static string ovr_MatchmakingEnqueueResult_GetPool(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingEnqueueResult_GetPool_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingEnqueueResult_GetPool")]
		private static extern IntPtr ovr_MatchmakingEnqueueResult_GetPool_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetRecentMatchPercentage(IntPtr obj);

		public static string ovr_MatchmakingEnqueueResult_GetRequestHash(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingEnqueueResult_GetRequestHash_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingEnqueueResult_GetRequestHash")]
		private static extern IntPtr ovr_MatchmakingEnqueueResult_GetRequestHash_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueueResultAndRoom_GetMatchmakingEnqueueResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueueResultAndRoom_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_MatchmakingEnqueuedUser_GetAdditionalUserID(IntPtr obj, uint index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueuedUser_GetAdditionalUserIDsSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueuedUser_GetCustomData(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueuedUser_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueuedUserArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingEnqueuedUserArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_MatchmakingNotification_GetAddedByUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingNotification_GetRoom(IntPtr obj);

		public static string ovr_MatchmakingNotification_GetTraceId(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingNotification_GetTraceId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingNotification_GetTraceId")]
		private static extern IntPtr ovr_MatchmakingNotification_GetTraceId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingRoom_GetPingTime(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingRoom_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_MatchmakingRoom_HasPingTime(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingRoomArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingRoomArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetDrawCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetLossCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetSkillLevel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetWinCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAbuseReportRecording(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAchievementDefinitionArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAchievementProgressArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAchievementUpdate(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetApplicationVersion(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetDetails(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetDetailsArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetFileDeleteResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetFileDownloadCancelResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetFileDownloadResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetFileDownloadUpdate(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCalApplicationFinalized(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCalApplicationProposed(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCalApplicationSuggestionArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageConflictMetadata(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageData(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageMetadata(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageMetadataArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageUpdateResponse(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetError(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetHttpTransferUpdate(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetInstalledApplicationArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLaunchBlockFlowResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLaunchFriendRequestFlowResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLaunchReportFlowResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLaunchUnblockFlowResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLeaderboardEntryArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLeaderboardUpdateStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLinkedAccountArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingApplicationStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingStartResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingVideoStats(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingAdminSnapshot(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingBrowseResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingEnqueueResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingEnqueueResultAndRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingRoomArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingStats(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetNativeMessage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetNetworkingPeer(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetOrgScopedID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetParty(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPartyID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPidArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPingResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPlatformInitialize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetProductArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPurchase(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPurchaseArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Message_GetRequestID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoomArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoomInviteNotification(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoomInviteNotificationArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetSdkAccountArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetShareMediaResult(IntPtr obj);

		public static string ovr_Message_GetString(IntPtr obj)
		{
			return StringFromNative(ovr_Message_GetString_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Message_GetString")]
		private static extern IntPtr ovr_Message_GetString_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetSystemPermission(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetSystemVoipState(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern Message.MessageType ovr_Message_GetType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserAndRoomArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserProof(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserReportID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Message_IsError(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetNumSamplesAvailable(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetOutputBufferMaxSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetPCM(IntPtr obj, short[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetPCMFloat(IntPtr obj, float[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_ReadData(IntPtr obj, float[] outputBuffer, UIntPtr outputBufferSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_SetAcceptableRecordingDelayHint(IntPtr obj, UIntPtr delayMs);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_Start(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_Stop(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_NetworkingPeer_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern PeerConnectionState ovr_NetworkingPeer_GetState(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_OrgScopedID_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Packet_Free(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Packet_GetBytes(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SendPolicy ovr_Packet_GetSendPolicy(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Packet_GetSenderID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Packet_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetInvitedUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetLeader(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PartyID_GetID(IntPtr obj);

		public static string ovr_Pid_GetId(IntPtr obj)
		{
			return StringFromNative(ovr_Pid_GetId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Pid_GetId")]
		private static extern IntPtr ovr_Pid_GetId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_PidArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_PidArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PingResult_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PingResult_GetPingTimeUsec(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_PingResult_IsTimeout(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern PlatformInitializeResult ovr_PlatformInitialize_GetResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Price_GetAmountInHundredths(IntPtr obj);

		public static string ovr_Price_GetCurrency(IntPtr obj)
		{
			return StringFromNative(ovr_Price_GetCurrency_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Price_GetCurrency")]
		private static extern IntPtr ovr_Price_GetCurrency_Native(IntPtr obj);

		public static string ovr_Price_GetFormatted(IntPtr obj)
		{
			return StringFromNative(ovr_Price_GetFormatted_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Price_GetFormatted")]
		private static extern IntPtr ovr_Price_GetFormatted_Native(IntPtr obj);

		public static string ovr_Product_GetDescription(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetDescription_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetDescription")]
		private static extern IntPtr ovr_Product_GetDescription_Native(IntPtr obj);

		public static string ovr_Product_GetFormattedPrice(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetFormattedPrice_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetFormattedPrice")]
		private static extern IntPtr ovr_Product_GetFormattedPrice_Native(IntPtr obj);

		public static string ovr_Product_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetName")]
		private static extern IntPtr ovr_Product_GetName_Native(IntPtr obj);

		public static string ovr_Product_GetSKU(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetSKU_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetSKU")]
		private static extern IntPtr ovr_Product_GetSKU_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_ProductArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_ProductArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_ProductArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ProductArray_GetNextUrl")]
		private static extern IntPtr ovr_ProductArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_ProductArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_ProductArray_HasNextPage(IntPtr obj);

		public static DateTime ovr_Purchase_GetExpirationTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_Purchase_GetExpirationTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Purchase_GetExpirationTime")]
		private static extern ulong ovr_Purchase_GetExpirationTime_Native(IntPtr obj);

		public static DateTime ovr_Purchase_GetGrantTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_Purchase_GetGrantTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Purchase_GetGrantTime")]
		private static extern ulong ovr_Purchase_GetGrantTime_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Purchase_GetPurchaseID(IntPtr obj);

		public static string ovr_Purchase_GetSKU(IntPtr obj)
		{
			return StringFromNative(ovr_Purchase_GetSKU_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Purchase_GetSKU")]
		private static extern IntPtr ovr_Purchase_GetSKU_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_PurchaseArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_PurchaseArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_PurchaseArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_PurchaseArray_GetNextUrl")]
		private static extern IntPtr ovr_PurchaseArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_PurchaseArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_PurchaseArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetApplicationID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetDataStore(IntPtr obj);

		public static string ovr_Room_GetDescription(IntPtr obj)
		{
			return StringFromNative(ovr_Room_GetDescription_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_GetDescription")]
		private static extern IntPtr ovr_Room_GetDescription_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetInvitedUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Room_GetIsMembershipLocked(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern RoomJoinPolicy ovr_Room_GetJoinPolicy(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern RoomJoinability ovr_Room_GetJoinability(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetMatchedUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Room_GetMaxUsers(IntPtr obj);

		public static string ovr_Room_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_Room_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_GetName")]
		private static extern IntPtr ovr_Room_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetOwner(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern RoomType ovr_Room_GetType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Room_GetVersion(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RoomArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_RoomArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_RoomArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomArray_GetNextUrl")]
		private static extern IntPtr ovr_RoomArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_RoomArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_RoomArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RoomInviteNotification_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RoomInviteNotification_GetRoomID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RoomInviteNotification_GetSenderID(IntPtr obj);

		public static DateTime ovr_RoomInviteNotification_GetSentTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_RoomInviteNotification_GetSentTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomInviteNotification_GetSentTime")]
		private static extern ulong ovr_RoomInviteNotification_GetSentTime_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RoomInviteNotificationArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_RoomInviteNotificationArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_RoomInviteNotificationArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomInviteNotificationArray_GetNextUrl")]
		private static extern IntPtr ovr_RoomInviteNotificationArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_RoomInviteNotificationArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_RoomInviteNotificationArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SdkAccountType ovr_SdkAccount_GetAccountType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_SdkAccount_GetUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_SdkAccountArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_SdkAccountArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ShareMediaStatus ovr_ShareMediaResult_GetStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_SystemPermission_GetHasPermission(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern PermissionGrantStatus ovr_SystemPermission_GetPermissionGrantStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipMuteState ovr_SystemVoipState_GetMicrophoneMuted(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemVoipStatus ovr_SystemVoipState_GetStatus(IntPtr obj);

		public static string ovr_TestUser_GetAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_TestUser_GetAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUser_GetAccessToken")]
		private static extern IntPtr ovr_TestUser_GetAccessToken_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_TestUser_GetAppAccessArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_TestUser_GetFbAppAccessArray(IntPtr obj);

		public static string ovr_TestUser_GetFriendAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_TestUser_GetFriendAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUser_GetFriendAccessToken")]
		private static extern IntPtr ovr_TestUser_GetFriendAccessToken_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_TestUser_GetFriendAppAccessArray(IntPtr obj);

		public static string ovr_TestUser_GetUserAlias(IntPtr obj)
		{
			return StringFromNative(ovr_TestUser_GetUserAlias_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUser_GetUserAlias")]
		private static extern IntPtr ovr_TestUser_GetUserAlias_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUser_GetUserFbid(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUser_GetUserId(IntPtr obj);

		public static string ovr_TestUserAppAccess_GetAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_TestUserAppAccess_GetAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUserAppAccess_GetAccessToken")]
		private static extern IntPtr ovr_TestUserAppAccess_GetAccessToken_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUserAppAccess_GetAppId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUserAppAccess_GetUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_TestUserAppAccessArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_TestUserAppAccessArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetID(IntPtr obj);

		public static string ovr_User_GetImageUrl(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetImageUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetImageUrl")]
		private static extern IntPtr ovr_User_GetImageUrl_Native(IntPtr obj);

		public static string ovr_User_GetInviteToken(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetInviteToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetInviteToken")]
		private static extern IntPtr ovr_User_GetInviteToken_Native(IntPtr obj);

		public static string ovr_User_GetOculusID(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetOculusID_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetOculusID")]
		private static extern IntPtr ovr_User_GetOculusID_Native(IntPtr obj);

		public static string ovr_User_GetPresence(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetPresence_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetPresence")]
		private static extern IntPtr ovr_User_GetPresence_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UserPresenceStatus ovr_User_GetPresenceStatus(IntPtr obj);

		public static string ovr_User_GetSmallImageUrl(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetSmallImageUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetSmallImageUrl")]
		private static extern IntPtr ovr_User_GetSmallImageUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserAndRoom_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserAndRoom_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserAndRoomArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_UserAndRoomArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_UserAndRoomArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_UserAndRoomArray_GetNextUrl")]
		private static extern IntPtr ovr_UserAndRoomArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_UserAndRoomArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UserAndRoomArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_UserArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_UserArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_UserArray_GetNextUrl")]
		private static extern IntPtr ovr_UserArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_UserArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UserArray_HasNextPage(IntPtr obj);

		public static string ovr_UserProof_GetNonce(IntPtr obj)
		{
			return StringFromNative(ovr_UserProof_GetNonce_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_UserProof_GetNonce")]
		private static extern IntPtr ovr_UserProof_GetNonce_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UserReportID_GetDidCancel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_UserReportID_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipDecoder_Decode(IntPtr obj, byte[] compressedData, UIntPtr compressedSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_VoipDecoder_GetDecodedPCM(IntPtr obj, float[] outputBuffer, UIntPtr outputBufferSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipEncoder_AddPCM(IntPtr obj, float[] inputData, uint inputSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_VoipEncoder_GetCompressedData(IntPtr obj, byte[] outputBuffer, UIntPtr intputSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_VoipEncoder_GetCompressedDataSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AbuseReportOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_AbuseReportOptions_Destroy(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_AbuseReportOptions_SetPreventPeopleChooser(IntPtr handle, bool value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_AbuseReportOptions_SetReportType(IntPtr handle, AbuseReportType value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_ApplicationOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_ApplicationOptions_Destroy(IntPtr handle);

		public static void ovr_ApplicationOptions_SetDeeplinkMessage(IntPtr handle, string value)
		{
			IntPtr intPtr = StringToNative(value);
			ovr_ApplicationOptions_SetDeeplinkMessage_Native(handle, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationOptions_SetDeeplinkMessage")]
		private static extern void ovr_ApplicationOptions_SetDeeplinkMessage_Native(IntPtr handle, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_Destroy(IntPtr handle);

		public static void ovr_MatchmakingOptions_SetCreateRoomDataStoreString(IntPtr handle, string key, string value)
		{
			IntPtr intPtr = StringToNative(key);
			IntPtr intPtr2 = StringToNative(value);
			ovr_MatchmakingOptions_SetCreateRoomDataStoreString_Native(handle, intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetCreateRoomDataStoreString")]
		private static extern void ovr_MatchmakingOptions_SetCreateRoomDataStoreString_Native(IntPtr handle, IntPtr key, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_ClearCreateRoomDataStore(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_SetCreateRoomJoinPolicy(IntPtr handle, RoomJoinPolicy value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_SetCreateRoomMaxUsers(IntPtr handle, uint value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_AddEnqueueAdditionalUser(IntPtr handle, ulong value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_ClearEnqueueAdditionalUsers(IntPtr handle);

		public static void ovr_MatchmakingOptions_SetEnqueueDataSettingsInt(IntPtr handle, string key, int value)
		{
			IntPtr intPtr = StringToNative(key);
			ovr_MatchmakingOptions_SetEnqueueDataSettingsInt_Native(handle, intPtr, value);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueDataSettingsInt")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueDataSettingsInt_Native(IntPtr handle, IntPtr key, int value);

		public static void ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble(IntPtr handle, string key, double value)
		{
			IntPtr intPtr = StringToNative(key);
			ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble_Native(handle, intPtr, value);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble_Native(IntPtr handle, IntPtr key, double value);

		public static void ovr_MatchmakingOptions_SetEnqueueDataSettingsString(IntPtr handle, string key, string value)
		{
			IntPtr intPtr = StringToNative(key);
			IntPtr intPtr2 = StringToNative(value);
			ovr_MatchmakingOptions_SetEnqueueDataSettingsString_Native(handle, intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueDataSettingsString")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueDataSettingsString_Native(IntPtr handle, IntPtr key, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_ClearEnqueueDataSettings(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_SetEnqueueIsDebug(IntPtr handle, bool value);

		public static void ovr_MatchmakingOptions_SetEnqueueQueryKey(IntPtr handle, string value)
		{
			IntPtr intPtr = StringToNative(value);
			ovr_MatchmakingOptions_SetEnqueueQueryKey_Native(handle, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueQueryKey")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueQueryKey_Native(IntPtr handle, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RoomOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_Destroy(IntPtr handle);

		public static void ovr_RoomOptions_SetDataStoreString(IntPtr handle, string key, string value)
		{
			IntPtr intPtr = StringToNative(key);
			IntPtr intPtr2 = StringToNative(value);
			ovr_RoomOptions_SetDataStoreString_Native(handle, intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomOptions_SetDataStoreString")]
		private static extern void ovr_RoomOptions_SetDataStoreString_Native(IntPtr handle, IntPtr key, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_ClearDataStore(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetExcludeRecentlyMet(IntPtr handle, bool value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetMaxUserResults(IntPtr handle, uint value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetOrdering(IntPtr handle, UserOrdering value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetRecentlyMetTimeWindow(IntPtr handle, TimeWindow value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetRoomId(IntPtr handle, ulong value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetTurnOffUpdates(IntPtr handle, bool value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_Destroy(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_SetMaxUsers(IntPtr handle, uint value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_AddServiceProvider(IntPtr handle, ServiceProvider value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_ClearServiceProviders(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_SetTimeWindow(IntPtr handle, TimeWindow value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_VoipOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipOptions_Destroy(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipOptions_SetBitrateForNewConnections(IntPtr handle, VoipBitrate value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipOptions_SetCreateNewConnectionUseDtx(IntPtr handle, VoipDtxState value);
	}
	public enum CloudStorageDataStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("IN_SYNC")]
		InSync,
		[Description("NEEDS_DOWNLOAD")]
		NeedsDownload,
		[Description("REMOTE_DOWNLOADING")]
		RemoteDownloading,
		[Description("NEEDS_UPLOAD")]
		NeedsUpload,
		[Description("LOCAL_UPLOADING")]
		LocalUploading,
		[Description("IN_CONFLICT")]
		InConflict
	}
	public enum CloudStorageUpdateStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("OK")]
		Ok,
		[Description("BETTER_VERSION_STORED")]
		BetterVersionStored,
		[Description("MANUAL_MERGE_REQUIRED")]
		ManualMergeRequired
	}
	public interface IMicrophone
	{
		void Start();

		void Stop();

		float[] Update();
	}
	public interface IVoipPCMSource
	{
		int GetPCM(float[] dest, int length);

		void SetSenderID(ulong senderID);

		void Update();

		int PeekSizeElements();
	}
	public enum KeyValuePairType
	{
		[Description("STRING")]
		String,
		[Description("INTEGER")]
		Int,
		[Description("DOUBLE")]
		Double,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum LaunchType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("NORMAL")]
		Normal,
		[Description("INVITE")]
		Invite,
		[Description("COORDINATED")]
		Coordinated,
		[Description("DEEPLINK")]
		Deeplink
	}
	public enum LeaderboardFilterType
	{
		[Description("NONE")]
		None,
		[Description("FRIENDS")]
		Friends,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum LeaderboardStartAt
	{
		[Description("TOP")]
		Top,
		[Description("CENTERED_ON_VIEWER")]
		CenteredOnViewer,
		[Description("CENTERED_ON_VIEWER_OR_TOP")]
		CenteredOnViewerOrTop,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum LivestreamingAudience
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("PUBLIC")]
		Public,
		[Description("FRIENDS")]
		Friends,
		[Description("ONLY_ME")]
		OnlyMe
	}
	public enum LivestreamingMicrophoneStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MICROPHONE_ON")]
		MicrophoneOn,
		[Description("MICROPHONE_OFF")]
		MicrophoneOff
	}
	public enum LivestreamingStartStatus
	{
		[Description("SUCCESS")]
		Success = 1,
		[Description("UNKNOWN")]
		Unknown = 0,
		[Description("NO_PACKAGE_SET")]
		NoPackageSet = -1,
		[Description("NO_FB_CONNECT")]
		NoFbConnect = -2,
		[Description("NO_SESSION_ID")]
		NoSessionId = -3,
		[Description("MISSING_PARAMETERS")]
		MissingParameters = -4
	}
	public enum MatchmakingCriterionImportance
	{
		[Description("REQUIRED")]
		Required,
		[Description("HIGH")]
		High,
		[Description("MEDIUM")]
		Medium,
		[Description("LOW")]
		Low,
		[Description("UNKNOWN")]
		Unknown
	}
	public class MatchmakingOptions
	{
		private IntPtr Handle;

		public MatchmakingOptions()
		{
			Handle = CAPI.ovr_MatchmakingOptions_Create();
		}

		public void SetCreateRoomDataStore(string key, string value)
		{
			CAPI.ovr_MatchmakingOptions_SetCreateRoomDataStoreString(Handle, key, value);
		}

		public void ClearCreateRoomDataStore()
		{
			CAPI.ovr_MatchmakingOptions_ClearCreateRoomDataStore(Handle);
		}

		public void SetCreateRoomJoinPolicy(RoomJoinPolicy value)
		{
			CAPI.ovr_MatchmakingOptions_SetCreateRoomJoinPolicy(Handle, value);
		}

		public void SetCreateRoomMaxUsers(uint value)
		{
			CAPI.ovr_MatchmakingOptions_SetCreateRoomMaxUsers(Handle, value);
		}

		public void AddEnqueueAdditionalUser(ulong userID)
		{
			CAPI.ovr_MatchmakingOptions_AddEnqueueAdditionalUser(Handle, userID);
		}

		public void ClearEnqueueAdditionalUsers()
		{
			CAPI.ovr_MatchmakingOptions_ClearEnqueueAdditionalUsers(Handle);
		}

		public void SetEnqueueDataSettings(string key, int value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueDataSettingsInt(Handle, key, value);
		}

		public void SetEnqueueDataSettings(string key, double value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble(Handle, key, value);
		}

		public void SetEnqueueDataSettings(string key, string value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueDataSettingsString(Handle, key, value);
		}

		public void ClearEnqueueDataSettings()
		{
			CAPI.ovr_MatchmakingOptions_ClearEnqueueDataSettings(Handle);
		}

		public void SetEnqueueIsDebug(bool value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueIsDebug(Handle, value);
		}

		public void SetEnqueueQueryKey(string value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueQueryKey(Handle, value);
		}

		public static explicit operator IntPtr(MatchmakingOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~MatchmakingOptions()
		{
			CAPI.ovr_MatchmakingOptions_Destroy(Handle);
		}
	}
	public enum MatchmakingStatApproach
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("TRAILING")]
		Trailing,
		[Description("SWINGY")]
		Swingy
	}
	public enum MediaContentType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("PHOTO")]
		Photo
	}
	public abstract class Message<T> : Message
	{
		public new delegate void Callback(Message<T> message);

		private T data;

		public T Data => data;

		public Message(IntPtr c_message)
			: base(c_message)
		{
			if (!base.IsError)
			{
				data = GetDataFromMessage(c_message);
			}
		}

		protected abstract T GetDataFromMessage(IntPtr c_message);
	}
	public class Message
	{
		public delegate void Callback(Message message);

		public enum MessageType : uint
		{
			Unknown = 0u,
			Achievements_AddCount = 65495601u,
			Achievements_AddFields = 346693929u,
			Achievements_GetAllDefinitions = 64177549u,
			Achievements_GetAllProgress = 1335877149u,
			Achievements_GetDefinitionsByName = 1653670332u,
			Achievements_GetNextAchievementDefinitionArrayPage = 712888917u,
			Achievements_GetNextAchievementProgressArrayPage = 792913703u,
			Achievements_GetProgressByName = 354837425u,
			Achievements_Unlock = 1497156573u,
			ApplicationLifecycle_GetRegisteredPIDs = 82169698u,
			ApplicationLifecycle_GetSessionKey = 984570141u,
			ApplicationLifecycle_RegisterSessionKey = 1303818232u,
			Application_GetVersion = 1751583246u,
			Application_LaunchOtherApp = 1424151032u,
			AssetFile_Delete = 1834842246u,
			AssetFile_DeleteById = 1525206354u,
			AssetFile_DeleteByName = 1108001231u,
			AssetFile_Download = 289710021u,
			AssetFile_DownloadById = 755009938u,
			AssetFile_DownloadByName = 1664536314u,
			AssetFile_DownloadCancel = 134927303u,
			AssetFile_DownloadCancelById = 1365611796u,
			AssetFile_DownloadCancelByName = 1147858170u,
			AssetFile_GetList = 1258057588u,
			AssetFile_Status = 47394656u,
			AssetFile_StatusById = 1570069816u,
			AssetFile_StatusByName = 1104140880u,
			CloudStorage_Delete = 685393261u,
			CloudStorage_GetNextCloudStorageMetadataArrayPage = 1544004335u,
			CloudStorage_Load = 1082420033u,
			CloudStorage_LoadBucketMetadata = 1931977997u,
			CloudStorage_LoadConflictMetadata = 1146770162u,
			CloudStorage_LoadHandle = 845863478u,
			CloudStorage_LoadMetadata = 65446546u,
			CloudStorage_ResolveKeepLocal = 811109637u,
			CloudStorage_ResolveKeepRemote = 1965400838u,
			CloudStorage_Save = 1270570030u,
			Entitlement_GetIsViewerEntitled = 409688241u,
			IAP_ConsumePurchase = 532378329u,
			IAP_GetNextProductArrayPage = 467225263u,
			IAP_GetNextPurchaseArrayPage = 1196886677u,
			IAP_GetProductsBySKU = 2124073717u,
			IAP_GetViewerPurchases = 974095385u,
			IAP_LaunchCheckoutFlow = 1067126029u,
			LanguagePack_GetCurrent = 529592533u,
			LanguagePack_SetCurrent = 1531952096u,
			Leaderboard_GetEntries = 1572030284u,
			Leaderboard_GetEntriesAfterRank = 406293487u,
			Leaderboard_GetNextEntries = 1310751961u,
			Leaderboard_GetPreviousEntries = 1224858304u,
			Leaderboard_WriteEntry = 293587198u,
			Livestreaming_GetStatus = 1218079125u,
			Livestreaming_PauseStream = 916223619u,
			Livestreaming_ResumeStream = 575827343u,
			Matchmaking_Browse = 509948616u,
			Matchmaking_Browse2 = 1715641947u,
			Matchmaking_Cancel = 543705519u,
			Matchmaking_Cancel2 = 285117908u,
			Matchmaking_CreateAndEnqueueRoom = 1615617480u,
			Matchmaking_CreateAndEnqueueRoom2 = 693889755u,
			Matchmaking_CreateRoom = 54203178u,
			Matchmaking_CreateRoom2 = 1231922052u,
			Matchmaking_Enqueue = 1086418033u,
			Matchmaking_Enqueue2 = 303174325u,
			Matchmaking_EnqueueRoom = 1888108644u,
			Matchmaking_EnqueueRoom2 = 1428741028u,
			Matchmaking_GetAdminSnapshot = 1008820116u,
			Matchmaking_GetStats = 1123849272u,
			Matchmaking_JoinRoom = 1295177725u,
			Matchmaking_ReportResultInsecure = 439800205u,
			Matchmaking_StartMatch = 1154746693u,
			Media_ShareToFacebook = 14912239u,
			Notification_GetNextRoomInviteNotificationArrayPage = 102890359u,
			Notification_GetRoomInvites = 1871801234u,
			Notification_MarkAsRead = 1903319523u,
			Party_GetCurrent = 1200830304u,
			Room_CreateAndJoinPrivate = 1977017207u,
			Room_CreateAndJoinPrivate2 = 1513775683u,
			Room_Get = 1704628152u,
			Room_GetCurrent = 161916164u,
			Room_GetCurrentForUser = 234887141u,
			Room_GetInvitableUsers = 506615698u,
			Room_GetInvitableUsers2 = 1330899120u,
			Room_GetModeratedRooms = 159645047u,
			Room_GetNextRoomArrayPage = 1317239238u,
			Room_InviteUser = 1093266451u,
			Room_Join = 382373641u,
			Room_Join2 = 1303059522u,
			Room_KickUser = 1233344310u,
			Room_LaunchInvitableUserFlow = 843047539u,
			Room_Leave = 1916281973u,
			Room_SetDescription = 809796911u,
			Room_UpdateDataStore = 40779816u,
			Room_UpdateMembershipLockStatus = 923514796u,
			Room_UpdateOwner = 850803997u,
			Room_UpdatePrivateRoomJoinPolicy = 289473179u,
			User_Get = 1808768583u,
			User_GetAccessToken = 111696574u,
			User_GetLoggedInUser = 1131361373u,
			User_GetLoggedInUserFriends = 1484532365u,
			User_GetLoggedInUserFriendsAndRooms = 1585908615u,
			User_GetLoggedInUserRecentlyMetUsersAndRooms = 694139440u,
			User_GetNextUserAndRoomArrayPage = 2143146719u,
			User_GetNextUserArrayPage = 645723971u,
			User_GetOrgScopedID = 418426907u,
			User_GetSdkAccounts = 1733454467u,
			User_GetUserProof = 578880643u,
			User_LaunchFriendRequestFlow = 151303576u,
			User_LaunchProfile = 171537047u,
			Voip_SetSystemVoipSuppressed = 1161808298u,
			Notification_ApplicationLifecycle_LaunchIntentChanged = 78859427u,
			Notification_AssetFile_DownloadUpdate = 803015885u,
			Notification_Cal_FinalizeApplication = 1963741337u,
			Notification_Cal_ProposeApplication = 779375093u,
			Notification_HTTP_Transfer = 2111073839u,
			Notification_Livestreaming_StatusChange = 575101294u,
			Notification_Matchmaking_MatchFound = 197393623u,
			Notification_Networking_ConnectionStateChange = 1577243802u,
			Notification_Networking_PeerConnectRequest = 1295114959u,
			Notification_Networking_PingResult = 1360343058u,
			Notification_Room_InviteAccepted = 1829794225u,
			Notification_Room_InviteReceived = 1783209300u,
			Notification_Room_RoomUpdate = 1626094639u,
			Notification_Voip_ConnectRequest = 908343318u,
			Notification_Voip_StateChange = 888120928u,
			Notification_Voip_SystemVoipState = 1490179237u,
			Platform_InitializeWithAccessToken = 896085803u,
			Platform_InitializeStandaloneOculus = 1375260172u,
			Platform_InitializeAndroidAsynchronous = 450037684u,
			Platform_InitializeWindowsAsynchronous = 1839708815u
		}

		internal delegate Message ExtraMessageTypesHandler(IntPtr messageHandle, MessageType message_type);

		private MessageType type;

		private ulong requestID;

		private Oculus.Platform.Models.Error error;

		public MessageType Type => type;

		public bool IsError => error != null;

		public ulong RequestID => requestID;

		internal static ExtraMessageTypesHandler HandleExtraMessageTypes { private get; set; }

		public Message(IntPtr c_message)
		{
			type = CAPI.ovr_Message_GetType(c_message);
			bool num = CAPI.ovr_Message_IsError(c_message);
			requestID = CAPI.ovr_Message_GetRequestID(c_message);
			if (num)
			{
				IntPtr obj = CAPI.ovr_Message_GetError(c_message);
				error = new Oculus.Platform.Models.Error(CAPI.ovr_Error_GetCode(obj), CAPI.ovr_Error_GetMessage(obj), CAPI.ovr_Error_GetHttpCode(obj));
			}
			else if (Core.LogMessages)
			{
				string text = CAPI.ovr_Message_GetString(c_message);
				if (text != null)
				{
					UnityEngine.Debug.Log(text);
				}
				else
				{
					UnityEngine.Debug.Log($"null message string {c_message}");
				}
			}
		}

		~Message()
		{
		}

		public virtual Oculus.Platform.Models.Error GetError()
		{
			return error;
		}

		public virtual PingResult GetPingResult()
		{
			return null;
		}

		public virtual NetworkingPeer GetNetworkingPeer()
		{
			return null;
		}

		public virtual HttpTransferUpdate GetHttpTransferUpdate()
		{
			return null;
		}

		public virtual PlatformInitialize GetPlatformInitialize()
		{
			return null;
		}

		public virtual AbuseReportRecording GetAbuseReportRecording()
		{
			return null;
		}

		public virtual AchievementDefinitionList GetAchievementDefinitions()
		{
			return null;
		}

		public virtual AchievementProgressList GetAchievementProgressList()
		{
			return null;
		}

		public virtual AchievementUpdate GetAchievementUpdate()
		{
			return null;
		}

		public virtual ApplicationVersion GetApplicationVersion()
		{
			return null;
		}

		public virtual AssetDetails GetAssetDetails()
		{
			return null;
		}

		public virtual AssetDetailsList GetAssetDetailsList()
		{
			return null;
		}

		public virtual AssetFileDeleteResult GetAssetFileDeleteResult()
		{
			return null;
		}

		public virtual AssetFileDownloadCancelResult GetAssetFileDownloadCancelResult()
		{
			return null;
		}

		public virtual AssetFileDownloadResult GetAssetFileDownloadResult()
		{
			return null;
		}

		public virtual AssetFileDownloadUpdate GetAssetFileDownloadUpdate()
		{
			return null;
		}

		public virtual CalApplicationFinalized GetCalApplicationFinalized()
		{
			return null;
		}

		public virtual CalApplicationProposed GetCalApplicationProposed()
		{
			return null;
		}

		public virtual CalApplicationSuggestionList GetCalApplicationSuggestionList()
		{
			return null;
		}

		public virtual CloudStorageConflictMetadata GetCloudStorageConflictMetadata()
		{
			return null;
		}

		public virtual CloudStorageData GetCloudStorageData()
		{
			return null;
		}

		public virtual CloudStorageMetadata GetCloudStorageMetadata()
		{
			return null;
		}

		public virtual CloudStorageMetadataList GetCloudStorageMetadataList()
		{
			return null;
		}

		public virtual CloudStorageUpdateResponse GetCloudStorageUpdateResponse()
		{
			return null;
		}

		public virtual InstalledApplicationList GetInstalledApplicationList()
		{
			return null;
		}

		public virtual LaunchBlockFlowResult GetLaunchBlockFlowResult()
		{
			return null;
		}

		public virtual LaunchFriendRequestFlowResult GetLaunchFriendRequestFlowResult()
		{
			return null;
		}

		public virtual LaunchReportFlowResult GetLaunchReportFlowResult()
		{
			return null;
		}

		public virtual LaunchUnblockFlowResult GetLaunchUnblockFlowResult()
		{
			return null;
		}

		public virtual bool GetLeaderboardDidUpdate()
		{
			return false;
		}

		public virtual LeaderboardEntryList GetLeaderboardEntryList()
		{
			return null;
		}

		public virtual LinkedAccountList GetLinkedAccountList()
		{
			return null;
		}

		public virtual LivestreamingApplicationStatus GetLivestreamingApplicationStatus()
		{
			return null;
		}

		public virtual LivestreamingStartResult GetLivestreamingStartResult()
		{
			return null;
		}

		public virtual LivestreamingStatus GetLivestreamingStatus()
		{
			return null;
		}

		public virtual LivestreamingVideoStats GetLivestreamingVideoStats()
		{
			return null;
		}

		public virtual MatchmakingAdminSnapshot GetMatchmakingAdminSnapshot()
		{
			return null;
		}

		public virtual MatchmakingBrowseResult GetMatchmakingBrowseResult()
		{
			return null;
		}

		public virtual MatchmakingEnqueueResult GetMatchmakingEnqueueResult()
		{
			return null;
		}

		public virtual MatchmakingEnqueueResultAndRoom GetMatchmakingEnqueueResultAndRoom()
		{
			return null;
		}

		public virtual MatchmakingStats GetMatchmakingStats()
		{
			return null;
		}

		public virtual OrgScopedID GetOrgScopedID()
		{
			return null;
		}

		public virtual Party GetParty()
		{
			return null;
		}

		public virtual PartyID GetPartyID()
		{
			return null;
		}

		public virtual PidList GetPidList()
		{
			return null;
		}

		public virtual ProductList GetProductList()
		{
			return null;
		}

		public virtual Purchase GetPurchase()
		{
			return null;
		}

		public virtual PurchaseList GetPurchaseList()
		{
			return null;
		}

		public virtual Room GetRoom()
		{
			return null;
		}

		public virtual RoomInviteNotification GetRoomInviteNotification()
		{
			return null;
		}

		public virtual RoomInviteNotificationList GetRoomInviteNotificationList()
		{
			return null;
		}

		public virtual RoomList GetRoomList()
		{
			return null;
		}

		public virtual SdkAccountList GetSdkAccountList()
		{
			return null;
		}

		public virtual ShareMediaResult GetShareMediaResult()
		{
			return null;
		}

		public virtual string GetString()
		{
			return null;
		}

		public virtual SystemPermission GetSystemPermission()
		{
			return null;
		}

		public virtual SystemVoipState GetSystemVoipState()
		{
			return null;
		}

		public virtual User GetUser()
		{
			return null;
		}

		public virtual UserAndRoomList GetUserAndRoomList()
		{
			return null;
		}

		public virtual UserList GetUserList()
		{
			return null;
		}

		public virtual UserProof GetUserProof()
		{
			return null;
		}

		public virtual UserReportID GetUserReportID()
		{
			return null;
		}

		internal static Message ParseMessageHandle(IntPtr messageHandle)
		{
			if (messageHandle.ToInt64() == 0L)
			{
				return null;
			}
			Message message = null;
			MessageType messageType = CAPI.ovr_Message_GetType(messageHandle);
			switch (messageType)
			{
			case MessageType.Achievements_GetAllDefinitions:
			case MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			case MessageType.Achievements_GetDefinitionsByName:
				message = new MessageWithAchievementDefinitions(messageHandle);
				break;
			case MessageType.Achievements_GetProgressByName:
			case MessageType.Achievements_GetNextAchievementProgressArrayPage:
			case MessageType.Achievements_GetAllProgress:
				message = new MessageWithAchievementProgressList(messageHandle);
				break;
			case MessageType.Achievements_AddCount:
			case MessageType.Achievements_AddFields:
			case MessageType.Achievements_Unlock:
				message = new MessageWithAchievementUpdate(messageHandle);
				break;
			case MessageType.Application_GetVersion:
				message = new MessageWithApplicationVersion(messageHandle);
				break;
			case MessageType.AssetFile_Status:
			case MessageType.LanguagePack_GetCurrent:
			case MessageType.AssetFile_StatusByName:
			case MessageType.AssetFile_StatusById:
				message = new MessageWithAssetDetails(messageHandle);
				break;
			case MessageType.AssetFile_GetList:
				message = new MessageWithAssetDetailsList(messageHandle);
				break;
			case MessageType.AssetFile_DeleteByName:
			case MessageType.AssetFile_DeleteById:
			case MessageType.AssetFile_Delete:
				message = new MessageWithAssetFileDeleteResult(messageHandle);
				break;
			case MessageType.AssetFile_DownloadCancel:
			case MessageType.AssetFile_DownloadCancelByName:
			case MessageType.AssetFile_DownloadCancelById:
				message = new MessageWithAssetFileDownloadCancelResult(messageHandle);
				break;
			case MessageType.AssetFile_Download:
			case MessageType.AssetFile_DownloadById:
			case MessageType.LanguagePack_SetCurrent:
			case MessageType.AssetFile_DownloadByName:
				message = new MessageWithAssetFileDownloadResult(messageHandle);
				break;
			case MessageType.Notification_AssetFile_DownloadUpdate:
				message = new MessageWithAssetFileDownloadUpdate(messageHandle);
				break;
			case MessageType.Notification_Cal_FinalizeApplication:
				message = new MessageWithCalApplicationFinalized(messageHandle);
				break;
			case MessageType.Notification_Cal_ProposeApplication:
				message = new MessageWithCalApplicationProposed(messageHandle);
				break;
			case MessageType.CloudStorage_LoadConflictMetadata:
				message = new MessageWithCloudStorageConflictMetadata(messageHandle);
				break;
			case MessageType.CloudStorage_LoadHandle:
			case MessageType.CloudStorage_Load:
				message = new MessageWithCloudStorageData(messageHandle);
				break;
			case MessageType.CloudStorage_LoadMetadata:
				message = new MessageWithCloudStorageMetadataUnderLocal(messageHandle);
				break;
			case MessageType.CloudStorage_GetNextCloudStorageMetadataArrayPage:
			case MessageType.CloudStorage_LoadBucketMetadata:
				message = new MessageWithCloudStorageMetadataList(messageHandle);
				break;
			case MessageType.CloudStorage_Delete:
			case MessageType.CloudStorage_ResolveKeepLocal:
			case MessageType.CloudStorage_Save:
			case MessageType.CloudStorage_ResolveKeepRemote:
				message = new MessageWithCloudStorageUpdateResponse(messageHandle);
				break;
			case MessageType.User_LaunchProfile:
			case MessageType.Matchmaking_Cancel2:
			case MessageType.Entitlement_GetIsViewerEntitled:
			case MessageType.Matchmaking_ReportResultInsecure:
			case MessageType.IAP_ConsumePurchase:
			case MessageType.Matchmaking_Cancel:
			case MessageType.Room_LaunchInvitableUserFlow:
			case MessageType.Room_UpdateOwner:
			case MessageType.Matchmaking_StartMatch:
			case MessageType.ApplicationLifecycle_RegisterSessionKey:
			case MessageType.Notification_MarkAsRead:
				message = new Message(messageHandle);
				break;
			case MessageType.User_LaunchFriendRequestFlow:
				message = new MessageWithLaunchFriendRequestFlowResult(messageHandle);
				break;
			case MessageType.Leaderboard_GetEntriesAfterRank:
			case MessageType.Leaderboard_GetPreviousEntries:
			case MessageType.Leaderboard_GetNextEntries:
			case MessageType.Leaderboard_GetEntries:
				message = new MessageWithLeaderboardEntryList(messageHandle);
				break;
			case MessageType.Leaderboard_WriteEntry:
				message = new MessageWithLeaderboardDidUpdate(messageHandle);
				break;
			case MessageType.Notification_Livestreaming_StatusChange:
			case MessageType.Livestreaming_ResumeStream:
			case MessageType.Livestreaming_PauseStream:
			case MessageType.Livestreaming_GetStatus:
				message = new MessageWithLivestreamingStatus(messageHandle);
				break;
			case MessageType.Matchmaking_GetAdminSnapshot:
				message = new MessageWithMatchmakingAdminSnapshot(messageHandle);
				break;
			case MessageType.Matchmaking_Browse:
			case MessageType.Matchmaking_Browse2:
				message = new MessageWithMatchmakingBrowseResult(messageHandle);
				break;
			case MessageType.Matchmaking_Enqueue2:
			case MessageType.Matchmaking_Enqueue:
			case MessageType.Matchmaking_EnqueueRoom2:
			case MessageType.Matchmaking_EnqueueRoom:
				message = new MessageWithMatchmakingEnqueueResult(messageHandle);
				break;
			case MessageType.Matchmaking_CreateAndEnqueueRoom2:
			case MessageType.Matchmaking_CreateAndEnqueueRoom:
				message = new MessageWithMatchmakingEnqueueResultAndRoom(messageHandle);
				break;
			case MessageType.Matchmaking_GetStats:
				message = new MessageWithMatchmakingStatsUnderMatchmakingStats(messageHandle);
				break;
			case MessageType.User_GetOrgScopedID:
				message = new MessageWithOrgScopedID(messageHandle);
				break;
			case MessageType.Party_GetCurrent:
				message = new MessageWithPartyUnderCurrentParty(messageHandle);
				break;
			case MessageType.ApplicationLifecycle_GetRegisteredPIDs:
				message = new MessageWithPidList(messageHandle);
				break;
			case MessageType.IAP_GetNextProductArrayPage:
			case MessageType.IAP_GetProductsBySKU:
				message = new MessageWithProductList(messageHandle);
				break;
			case MessageType.IAP_LaunchCheckoutFlow:
				message = new MessageWithPurchase(messageHandle);
				break;
			case MessageType.IAP_GetViewerPurchases:
			case MessageType.IAP_GetNextPurchaseArrayPage:
				message = new MessageWithPurchaseList(messageHandle);
				break;
			case MessageType.Room_Get:
				message = new MessageWithRoom(messageHandle);
				break;
			case MessageType.Room_GetCurrent:
			case MessageType.Room_GetCurrentForUser:
				message = new MessageWithRoomUnderCurrentRoom(messageHandle);
				break;
			case MessageType.Room_UpdateDataStore:
			case MessageType.Matchmaking_CreateRoom:
			case MessageType.Room_UpdatePrivateRoomJoinPolicy:
			case MessageType.Room_Join:
			case MessageType.Room_SetDescription:
			case MessageType.Room_UpdateMembershipLockStatus:
			case MessageType.Room_InviteUser:
			case MessageType.Matchmaking_CreateRoom2:
			case MessageType.Room_KickUser:
			case MessageType.Matchmaking_JoinRoom:
			case MessageType.Room_Join2:
			case MessageType.Room_CreateAndJoinPrivate2:
			case MessageType.Notification_Room_RoomUpdate:
			case MessageType.Room_Leave:
			case MessageType.Room_CreateAndJoinPrivate:
				message = new MessageWithRoomUnderViewerRoom(messageHandle);
				break;
			case MessageType.Room_GetModeratedRooms:
			case MessageType.Room_GetNextRoomArrayPage:
				message = new MessageWithRoomList(messageHandle);
				break;
			case MessageType.Notification_Room_InviteReceived:
				message = new MessageWithRoomInviteNotification(messageHandle);
				break;
			case MessageType.Notification_GetNextRoomInviteNotificationArrayPage:
			case MessageType.Notification_GetRoomInvites:
				message = new MessageWithRoomInviteNotificationList(messageHandle);
				break;
			case MessageType.User_GetSdkAccounts:
				message = new MessageWithSdkAccountList(messageHandle);
				break;
			case MessageType.Media_ShareToFacebook:
				message = new MessageWithShareMediaResult(messageHandle);
				break;
			case MessageType.Notification_ApplicationLifecycle_LaunchIntentChanged:
			case MessageType.User_GetAccessToken:
			case MessageType.ApplicationLifecycle_GetSessionKey:
			case MessageType.Application_LaunchOtherApp:
			case MessageType.Notification_Room_InviteAccepted:
				message = new MessageWithString(messageHandle);
				break;
			case MessageType.Voip_SetSystemVoipSuppressed:
				message = new MessageWithSystemVoipState(messageHandle);
				break;
			case MessageType.User_GetLoggedInUser:
			case MessageType.User_Get:
				message = new MessageWithUser(messageHandle);
				break;
			case MessageType.User_GetLoggedInUserRecentlyMetUsersAndRooms:
			case MessageType.User_GetLoggedInUserFriendsAndRooms:
			case MessageType.User_GetNextUserAndRoomArrayPage:
				message = new MessageWithUserAndRoomList(messageHandle);
				break;
			case MessageType.Room_GetInvitableUsers:
			case MessageType.User_GetNextUserArrayPage:
			case MessageType.Room_GetInvitableUsers2:
			case MessageType.User_GetLoggedInUserFriends:
				message = new MessageWithUserList(messageHandle);
				break;
			case MessageType.User_GetUserProof:
				message = new MessageWithUserProof(messageHandle);
				break;
			case MessageType.Notification_Networking_PeerConnectRequest:
			case MessageType.Notification_Networking_ConnectionStateChange:
				message = new MessageWithNetworkingPeer(messageHandle);
				break;
			case MessageType.Notification_Networking_PingResult:
				message = new MessageWithPingResult(messageHandle);
				break;
			case MessageType.Notification_Matchmaking_MatchFound:
				message = new MessageWithMatchmakingNotification(messageHandle);
				break;
			case MessageType.Notification_Voip_StateChange:
			case MessageType.Notification_Voip_ConnectRequest:
				message = new MessageWithNetworkingPeer(messageHandle);
				break;
			case MessageType.Notification_Voip_SystemVoipState:
				message = new MessageWithSystemVoipState(messageHandle);
				break;
			case MessageType.Notification_HTTP_Transfer:
				message = new MessageWithHttpTransferUpdate(messageHandle);
				break;
			case MessageType.Platform_InitializeAndroidAsynchronous:
			case MessageType.Platform_InitializeWithAccessToken:
			case MessageType.Platform_InitializeStandaloneOculus:
			case MessageType.Platform_InitializeWindowsAsynchronous:
				message = new MessageWithPlatformInitialize(messageHandle);
				break;
			default:
				message = PlatformInternal.ParseMessageHandle(messageHandle, messageType);
				if (message == null)
				{
					UnityEngine.Debug.LogError($"Unrecognized message type {messageType}\n");
				}
				break;
			}
			return message;
		}

		public static Message PopMessage()
		{
			if (!Core.IsInitialized())
			{
				return null;
			}
			IntPtr intPtr = CAPI.ovr_PopMessage();
			Message result = ParseMessageHandle(intPtr);
			CAPI.ovr_FreeMessage(intPtr);
			return result;
		}
	}
	public class MessageWithAbuseReportRecording : Message<AbuseReportRecording>
	{
		public MessageWithAbuseReportRecording(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AbuseReportRecording GetAbuseReportRecording()
		{
			return base.Data;
		}

		protected override AbuseReportRecording GetDataFromMessage(IntPtr c_message)
		{
			return new AbuseReportRecording(CAPI.ovr_Message_GetAbuseReportRecording(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithAchievementDefinitions : Message<AchievementDefinitionList>
	{
		public MessageWithAchievementDefinitions(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AchievementDefinitionList GetAchievementDefinitions()
		{
			return base.Data;
		}

		protected override AchievementDefinitionList GetDataFromMessage(IntPtr c_message)
		{
			return new AchievementDefinitionList(CAPI.ovr_Message_GetAchievementDefinitionArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithAchievementProgressList : Message<AchievementProgressList>
	{
		public MessageWithAchievementProgressList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AchievementProgressList GetAchievementProgressList()
		{
			return base.Data;
		}

		protected override AchievementProgressList GetDataFromMessage(IntPtr c_message)
		{
			return new AchievementProgressList(CAPI.ovr_Message_GetAchievementProgressArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithAchievementUpdate : Message<AchievementUpdate>
	{
		public MessageWithAchievementUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AchievementUpdate GetAchievementUpdate()
		{
			return base.Data;
		}

		protected override AchievementUpdate GetDataFromMessage(IntPtr c_message)
		{
			return new AchievementUpdate(CAPI.ovr_Message_GetAchievementUpdate(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithApplicationVersion : Message<ApplicationVersion>
	{
		public MessageWithApplicationVersion(IntPtr c_message)
			: base(c_message)
		{
		}

		public override ApplicationVersion GetApplicationVersion()
		{
			return base.Data;
		}

		protected override ApplicationVersion GetDataFromMessage(IntPtr c_message)
		{
			return new ApplicationVersion(CAPI.ovr_Message_GetApplicationVersion(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithAssetDetails : Message<AssetDetails>
	{
		public MessageWithAssetDetails(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetDetails GetAssetDetails()
		{
			return base.Data;
		}

		protected override AssetDetails GetDataFromMessage(IntPtr c_message)
		{
			return new AssetDetails(CAPI.ovr_Message_GetAssetDetails(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithAssetDetailsList : Message<AssetDetailsList>
	{
		public MessageWithAssetDetailsList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetDetailsList GetAssetDetailsList()
		{
			return base.Data;
		}

		protected override AssetDetailsList GetDataFromMessage(IntPtr c_message)
		{
			return new AssetDetailsList(CAPI.ovr_Message_GetAssetDetailsArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithAssetFileDeleteResult : Message<AssetFileDeleteResult>
	{
		public MessageWithAssetFileDeleteResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetFileDeleteResult GetAssetFileDeleteResult()
		{
			return base.Data;
		}

		protected override AssetFileDeleteResult GetDataFromMessage(IntPtr c_message)
		{
			return new AssetFileDeleteResult(CAPI.ovr_Message_GetAssetFileDeleteResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithAssetFileDownloadCancelResult : Message<AssetFileDownloadCancelResult>
	{
		public MessageWithAssetFileDownloadCancelResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetFileDownloadCancelResult GetAssetFileDownloadCancelResult()
		{
			return base.Data;
		}

		protected override AssetFileDownloadCancelResult GetDataFromMessage(IntPtr c_message)
		{
			return new AssetFileDownloadCancelResult(CAPI.ovr_Message_GetAssetFileDownloadCancelResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithAssetFileDownloadResult : Message<AssetFileDownloadResult>
	{
		public MessageWithAssetFileDownloadResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetFileDownloadResult GetAssetFileDownloadResult()
		{
			return base.Data;
		}

		protected override AssetFileDownloadResult GetDataFromMessage(IntPtr c_message)
		{
			return new AssetFileDownloadResult(CAPI.ovr_Message_GetAssetFileDownloadResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithAssetFileDownloadUpdate : Message<AssetFileDownloadUpdate>
	{
		public MessageWithAssetFileDownloadUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetFileDownloadUpdate GetAssetFileDownloadUpdate()
		{
			return base.Data;
		}

		protected override AssetFileDownloadUpdate GetDataFromMessage(IntPtr c_message)
		{
			return new AssetFileDownloadUpdate(CAPI.ovr_Message_GetAssetFileDownloadUpdate(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithCalApplicationFinalized : Message<CalApplicationFinalized>
	{
		public MessageWithCalApplicationFinalized(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CalApplicationFinalized GetCalApplicationFinalized()
		{
			return base.Data;
		}

		protected override CalApplicationFinalized GetDataFromMessage(IntPtr c_message)
		{
			return new CalApplicationFinalized(CAPI.ovr_Message_GetCalApplicationFinalized(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithCalApplicationProposed : Message<CalApplicationProposed>
	{
		public MessageWithCalApplicationProposed(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CalApplicationProposed GetCalApplicationProposed()
		{
			return base.Data;
		}

		protected override CalApplicationProposed GetDataFromMessage(IntPtr c_message)
		{
			return new CalApplicationProposed(CAPI.ovr_Message_GetCalApplicationProposed(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithCalApplicationSuggestionList : Message<CalApplicationSuggestionList>
	{
		public MessageWithCalApplicationSuggestionList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CalApplicationSuggestionList GetCalApplicationSuggestionList()
		{
			return base.Data;
		}

		protected override CalApplicationSuggestionList GetDataFromMessage(IntPtr c_message)
		{
			return new CalApplicationSuggestionList(CAPI.ovr_Message_GetCalApplicationSuggestionArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithCloudStorageConflictMetadata : Message<CloudStorageConflictMetadata>
	{
		public MessageWithCloudStorageConflictMetadata(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageConflictMetadata GetCloudStorageConflictMetadata()
		{
			return base.Data;
		}

		protected override CloudStorageConflictMetadata GetDataFromMessage(IntPtr c_message)
		{
			return new CloudStorageConflictMetadata(CAPI.ovr_Message_GetCloudStorageConflictMetadata(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithCloudStorageData : Message<CloudStorageData>
	{
		public MessageWithCloudStorageData(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageData GetCloudStorageData()
		{
			return base.Data;
		}

		protected override CloudStorageData GetDataFromMessage(IntPtr c_message)
		{
			return new CloudStorageData(CAPI.ovr_Message_GetCloudStorageData(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithCloudStorageMetadataUnderLocal : Message<CloudStorageMetadata>
	{
		public MessageWithCloudStorageMetadataUnderLocal(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageMetadata GetCloudStorageMetadata()
		{
			return base.Data;
		}

		protected override CloudStorageMetadata GetDataFromMessage(IntPtr c_message)
		{
			return new CloudStorageMetadata(CAPI.ovr_Message_GetCloudStorageMetadata(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithCloudStorageMetadataList : Message<CloudStorageMetadataList>
	{
		public MessageWithCloudStorageMetadataList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageMetadataList GetCloudStorageMetadataList()
		{
			return base.Data;
		}

		protected override CloudStorageMetadataList GetDataFromMessage(IntPtr c_message)
		{
			return new CloudStorageMetadataList(CAPI.ovr_Message_GetCloudStorageMetadataArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithCloudStorageUpdateResponse : Message<CloudStorageUpdateResponse>
	{
		public MessageWithCloudStorageUpdateResponse(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageUpdateResponse GetCloudStorageUpdateResponse()
		{
			return base.Data;
		}

		protected override CloudStorageUpdateResponse GetDataFromMessage(IntPtr c_message)
		{
			return new CloudStorageUpdateResponse(CAPI.ovr_Message_GetCloudStorageUpdateResponse(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithInstalledApplicationList : Message<InstalledApplicationList>
	{
		public MessageWithInstalledApplicationList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override InstalledApplicationList GetInstalledApplicationList()
		{
			return base.Data;
		}

		protected override InstalledApplicationList GetDataFromMessage(IntPtr c_message)
		{
			return new InstalledApplicationList(CAPI.ovr_Message_GetInstalledApplicationArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithLaunchBlockFlowResult : Message<LaunchBlockFlowResult>
	{
		public MessageWithLaunchBlockFlowResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LaunchBlockFlowResult GetLaunchBlockFlowResult()
		{
			return base.Data;
		}

		protected override LaunchBlockFlowResult GetDataFromMessage(IntPtr c_message)
		{
			return new LaunchBlockFlowResult(CAPI.ovr_Message_GetLaunchBlockFlowResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithLaunchFriendRequestFlowResult : Message<LaunchFriendRequestFlowResult>
	{
		public MessageWithLaunchFriendRequestFlowResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LaunchFriendRequestFlowResult GetLaunchFriendRequestFlowResult()
		{
			return base.Data;
		}

		protected override LaunchFriendRequestFlowResult GetDataFromMessage(IntPtr c_message)
		{
			return new LaunchFriendRequestFlowResult(CAPI.ovr_Message_GetLaunchFriendRequestFlowResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithLaunchReportFlowResult : Message<LaunchReportFlowResult>
	{
		public MessageWithLaunchReportFlowResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LaunchReportFlowResult GetLaunchReportFlowResult()
		{
			return base.Data;
		}

		protected override LaunchReportFlowResult GetDataFromMessage(IntPtr c_message)
		{
			return new LaunchReportFlowResult(CAPI.ovr_Message_GetLaunchReportFlowResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithLaunchUnblockFlowResult : Message<LaunchUnblockFlowResult>
	{
		public MessageWithLaunchUnblockFlowResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LaunchUnblockFlowResult GetLaunchUnblockFlowResult()
		{
			return base.Data;
		}

		protected override LaunchUnblockFlowResult GetDataFromMessage(IntPtr c_message)
		{
			return new LaunchUnblockFlowResult(CAPI.ovr_Message_GetLaunchUnblockFlowResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithLeaderboardEntryList : Message<LeaderboardEntryList>
	{
		public MessageWithLeaderboardEntryList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LeaderboardEntryList GetLeaderboardEntryList()
		{
			return base.Data;
		}

		protected override LeaderboardEntryList GetDataFromMessage(IntPtr c_message)
		{
			return new LeaderboardEntryList(CAPI.ovr_Message_GetLeaderboardEntryArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithLinkedAccountList : Message<LinkedAccountList>
	{
		public MessageWithLinkedAccountList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LinkedAccountList GetLinkedAccountList()
		{
			return base.Data;
		}

		protected override LinkedAccountList GetDataFromMessage(IntPtr c_message)
		{
			return new LinkedAccountList(CAPI.ovr_Message_GetLinkedAccountArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithLivestreamingApplicationStatus : Message<LivestreamingApplicationStatus>
	{
		public MessageWithLivestreamingApplicationStatus(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingApplicationStatus GetLivestreamingApplicationStatus()
		{
			return base.Data;
		}

		protected override LivestreamingApplicationStatus GetDataFromMessage(IntPtr c_message)
		{
			return new LivestreamingApplicationStatus(CAPI.ovr_Message_GetLivestreamingApplicationStatus(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithLivestreamingStartResult : Message<LivestreamingStartResult>
	{
		public MessageWithLivestreamingStartResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingStartResult GetLivestreamingStartResult()
		{
			return base.Data;
		}

		protected override LivestreamingStartResult GetDataFromMessage(IntPtr c_message)
		{
			return new LivestreamingStartResult(CAPI.ovr_Message_GetLivestreamingStartResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithLivestreamingStatus : Message<LivestreamingStatus>
	{
		public MessageWithLivestreamingStatus(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingStatus GetLivestreamingStatus()
		{
			return base.Data;
		}

		protected override LivestreamingStatus GetDataFromMessage(IntPtr c_message)
		{
			return new LivestreamingStatus(CAPI.ovr_Message_GetLivestreamingStatus(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithLivestreamingVideoStats : Message<LivestreamingVideoStats>
	{
		public MessageWithLivestreamingVideoStats(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingVideoStats GetLivestreamingVideoStats()
		{
			return base.Data;
		}

		protected override LivestreamingVideoStats GetDataFromMessage(IntPtr c_message)
		{
			return new LivestreamingVideoStats(CAPI.ovr_Message_GetLivestreamingVideoStats(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithMatchmakingAdminSnapshot : Message<MatchmakingAdminSnapshot>
	{
		public MessageWithMatchmakingAdminSnapshot(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingAdminSnapshot GetMatchmakingAdminSnapshot()
		{
			return base.Data;
		}

		protected override MatchmakingAdminSnapshot GetDataFromMessage(IntPtr c_message)
		{
			return new MatchmakingAdminSnapshot(CAPI.ovr_Message_GetMatchmakingAdminSnapshot(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithMatchmakingEnqueueResult : Message<MatchmakingEnqueueResult>
	{
		public MessageWithMatchmakingEnqueueResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingEnqueueResult GetMatchmakingEnqueueResult()
		{
			return base.Data;
		}

		protected override MatchmakingEnqueueResult GetDataFromMessage(IntPtr c_message)
		{
			return new MatchmakingEnqueueResult(CAPI.ovr_Message_GetMatchmakingEnqueueResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithMatchmakingEnqueueResultAndRoom : Message<MatchmakingEnqueueResultAndRoom>
	{
		public MessageWithMatchmakingEnqueueResultAndRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingEnqueueResultAndRoom GetMatchmakingEnqueueResultAndRoom()
		{
			return base.Data;
		}

		protected override MatchmakingEnqueueResultAndRoom GetDataFromMessage(IntPtr c_message)
		{
			return new MatchmakingEnqueueResultAndRoom(CAPI.ovr_Message_GetMatchmakingEnqueueResultAndRoom(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithMatchmakingStatsUnderMatchmakingStats : Message<MatchmakingStats>
	{
		public MessageWithMatchmakingStatsUnderMatchmakingStats(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingStats GetMatchmakingStats()
		{
			return base.Data;
		}

		protected override MatchmakingStats GetDataFromMessage(IntPtr c_message)
		{
			return new MatchmakingStats(CAPI.ovr_Message_GetMatchmakingStats(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithOrgScopedID : Message<OrgScopedID>
	{
		public MessageWithOrgScopedID(IntPtr c_message)
			: base(c_message)
		{
		}

		public override OrgScopedID GetOrgScopedID()
		{
			return base.Data;
		}

		protected override OrgScopedID GetDataFromMessage(IntPtr c_message)
		{
			return new OrgScopedID(CAPI.ovr_Message_GetOrgScopedID(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithParty : Message<Party>
	{
		public MessageWithParty(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Party GetParty()
		{
			return base.Data;
		}

		protected override Party GetDataFromMessage(IntPtr c_message)
		{
			return new Party(CAPI.ovr_Message_GetParty(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithPartyUnderCurrentParty : Message<Party>
	{
		public MessageWithPartyUnderCurrentParty(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Party GetParty()
		{
			return base.Data;
		}

		protected override Party GetDataFromMessage(IntPtr c_message)
		{
			return new Party(CAPI.ovr_Message_GetParty(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithPartyID : Message<PartyID>
	{
		public MessageWithPartyID(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PartyID GetPartyID()
		{
			return base.Data;
		}

		protected override PartyID GetDataFromMessage(IntPtr c_message)
		{
			return new PartyID(CAPI.ovr_Message_GetPartyID(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithPidList : Message<PidList>
	{
		public MessageWithPidList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PidList GetPidList()
		{
			return base.Data;
		}

		protected override PidList GetDataFromMessage(IntPtr c_message)
		{
			return new PidList(CAPI.ovr_Message_GetPidArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithProductList : Message<ProductList>
	{
		public MessageWithProductList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override ProductList GetProductList()
		{
			return base.Data;
		}

		protected override ProductList GetDataFromMessage(IntPtr c_message)
		{
			return new ProductList(CAPI.ovr_Message_GetProductArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithPurchase : Message<Purchase>
	{
		public MessageWithPurchase(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Purchase GetPurchase()
		{
			return base.Data;
		}

		protected override Purchase GetDataFromMessage(IntPtr c_message)
		{
			return new Purchase(CAPI.ovr_Message_GetPurchase(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithPurchaseList : Message<PurchaseList>
	{
		public MessageWithPurchaseList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PurchaseList GetPurchaseList()
		{
			return base.Data;
		}

		protected override PurchaseList GetDataFromMessage(IntPtr c_message)
		{
			return new PurchaseList(CAPI.ovr_Message_GetPurchaseArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithRoom : Message<Room>
	{
		public MessageWithRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Room GetRoom()
		{
			return base.Data;
		}

		protected override Room GetDataFromMessage(IntPtr c_message)
		{
			return new Room(CAPI.ovr_Message_GetRoom(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithRoomUnderCurrentRoom : Message<Room>
	{
		public MessageWithRoomUnderCurrentRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Room GetRoom()
		{
			return base.Data;
		}

		protected override Room GetDataFromMessage(IntPtr c_message)
		{
			return new Room(CAPI.ovr_Message_GetRoom(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithRoomUnderViewerRoom : Message<Room>
	{
		public MessageWithRoomUnderViewerRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Room GetRoom()
		{
			return base.Data;
		}

		protected override Room GetDataFromMessage(IntPtr c_message)
		{
			return new Room(CAPI.ovr_Message_GetRoom(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithRoomList : Message<RoomList>
	{
		public MessageWithRoomList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override RoomList GetRoomList()
		{
			return base.Data;
		}

		protected override RoomList GetDataFromMessage(IntPtr c_message)
		{
			return new RoomList(CAPI.ovr_Message_GetRoomArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithRoomInviteNotification : Message<RoomInviteNotification>
	{
		public MessageWithRoomInviteNotification(IntPtr c_message)
			: base(c_message)
		{
		}

		public override RoomInviteNotification GetRoomInviteNotification()
		{
			return base.Data;
		}

		protected override RoomInviteNotification GetDataFromMessage(IntPtr c_message)
		{
			return new RoomInviteNotification(CAPI.ovr_Message_GetRoomInviteNotification(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithRoomInviteNotificationList : Message<RoomInviteNotificationList>
	{
		public MessageWithRoomInviteNotificationList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override RoomInviteNotificationList GetRoomInviteNotificationList()
		{
			return base.Data;
		}

		protected override RoomInviteNotificationList GetDataFromMessage(IntPtr c_message)
		{
			return new RoomInviteNotificationList(CAPI.ovr_Message_GetRoomInviteNotificationArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithSdkAccountList : Message<SdkAccountList>
	{
		public MessageWithSdkAccountList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override SdkAccountList GetSdkAccountList()
		{
			return base.Data;
		}

		protected override SdkAccountList GetDataFromMessage(IntPtr c_message)
		{
			return new SdkAccountList(CAPI.ovr_Message_GetSdkAccountArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithShareMediaResult : Message<ShareMediaResult>
	{
		public MessageWithShareMediaResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override ShareMediaResult GetShareMediaResult()
		{
			return base.Data;
		}

		protected override ShareMediaResult GetDataFromMessage(IntPtr c_message)
		{
			return new ShareMediaResult(CAPI.ovr_Message_GetShareMediaResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithString : Message<string>
	{
		public MessageWithString(IntPtr c_message)
			: base(c_message)
		{
		}

		public override string GetString()
		{
			return base.Data;
		}

		protected override string GetDataFromMessage(IntPtr c_message)
		{
			return CAPI.ovr_Message_GetString(c_message);
		}
	}
	public class MessageWithSystemPermission : Message<SystemPermission>
	{
		public MessageWithSystemPermission(IntPtr c_message)
			: base(c_message)
		{
		}

		public override SystemPermission GetSystemPermission()
		{
			return base.Data;
		}

		protected override SystemPermission GetDataFromMessage(IntPtr c_message)
		{
			return new SystemPermission(CAPI.ovr_Message_GetSystemPermission(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithSystemVoipState : Message<SystemVoipState>
	{
		public MessageWithSystemVoipState(IntPtr c_message)
			: base(c_message)
		{
		}

		public override SystemVoipState GetSystemVoipState()
		{
			return base.Data;
		}

		protected override SystemVoipState GetDataFromMessage(IntPtr c_message)
		{
			return new SystemVoipState(CAPI.ovr_Message_GetSystemVoipState(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithUser : Message<User>
	{
		public MessageWithUser(IntPtr c_message)
			: base(c_message)
		{
		}

		public override User GetUser()
		{
			return base.Data;
		}

		protected override User GetDataFromMessage(IntPtr c_message)
		{
			return new User(CAPI.ovr_Message_GetUser(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithUserAndRoomList : Message<UserAndRoomList>
	{
		public MessageWithUserAndRoomList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserAndRoomList GetUserAndRoomList()
		{
			return base.Data;
		}

		protected override UserAndRoomList GetDataFromMessage(IntPtr c_message)
		{
			return new UserAndRoomList(CAPI.ovr_Message_GetUserAndRoomArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithUserList : Message<UserList>
	{
		public MessageWithUserList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserList GetUserList()
		{
			return base.Data;
		}

		protected override UserList GetDataFromMessage(IntPtr c_message)
		{
			return new UserList(CAPI.ovr_Message_GetUserArray(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithUserProof : Message<UserProof>
	{
		public MessageWithUserProof(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserProof GetUserProof()
		{
			return base.Data;
		}

		protected override UserProof GetDataFromMessage(IntPtr c_message)
		{
			return new UserProof(CAPI.ovr_Message_GetUserProof(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithUserReportID : Message<UserReportID>
	{
		public MessageWithUserReportID(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserReportID GetUserReportID()
		{
			return base.Data;
		}

		protected override UserReportID GetDataFromMessage(IntPtr c_message)
		{
			return new UserReportID(CAPI.ovr_Message_GetUserReportID(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithNetworkingPeer : Message<NetworkingPeer>
	{
		public MessageWithNetworkingPeer(IntPtr c_message)
			: base(c_message)
		{
		}

		public override NetworkingPeer GetNetworkingPeer()
		{
			return base.Data;
		}

		protected override NetworkingPeer GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNetworkingPeer(c_message);
			return new NetworkingPeer(CAPI.ovr_NetworkingPeer_GetID(obj), CAPI.ovr_NetworkingPeer_GetState(obj));
		}
	}
	public class MessageWithPingResult : Message<PingResult>
	{
		public MessageWithPingResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PingResult GetPingResult()
		{
			return base.Data;
		}

		protected override PingResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetPingResult(c_message);
			bool flag = CAPI.ovr_PingResult_IsTimeout(obj);
			return new PingResult(CAPI.ovr_PingResult_GetID(obj), flag ? null : new ulong?(CAPI.ovr_PingResult_GetPingTimeUsec(obj)));
		}
	}
	public class MessageWithLeaderboardDidUpdate : Message<bool>
	{
		public MessageWithLeaderboardDidUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override bool GetLeaderboardDidUpdate()
		{
			return base.Data;
		}

		protected override bool GetDataFromMessage(IntPtr c_message)
		{
			return CAPI.ovr_LeaderboardUpdateStatus_GetDidUpdate(CAPI.ovr_Message_GetLeaderboardUpdateStatus(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithMatchmakingNotification : Message<Room>
	{
		public MessageWithMatchmakingNotification(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Room GetRoom()
		{
			return base.Data;
		}

		protected override Room GetDataFromMessage(IntPtr c_message)
		{
			return new Room(CAPI.ovr_Message_GetRoom(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithMatchmakingBrowseResult : Message<MatchmakingBrowseResult>
	{
		public MessageWithMatchmakingBrowseResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingEnqueueResult GetMatchmakingEnqueueResult()
		{
			return base.Data.EnqueueResult;
		}

		public override RoomList GetRoomList()
		{
			return base.Data.Rooms;
		}

		protected override MatchmakingBrowseResult GetDataFromMessage(IntPtr c_message)
		{
			return new MatchmakingBrowseResult(CAPI.ovr_Message_GetMatchmakingBrowseResult(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithHttpTransferUpdate : Message<HttpTransferUpdate>
	{
		public MessageWithHttpTransferUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override HttpTransferUpdate GetHttpTransferUpdate()
		{
			return base.Data;
		}

		protected override HttpTransferUpdate GetDataFromMessage(IntPtr c_message)
		{
			return new HttpTransferUpdate(CAPI.ovr_Message_GetHttpTransferUpdate(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public class MessageWithPlatformInitialize : Message<PlatformInitialize>
	{
		public MessageWithPlatformInitialize(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PlatformInitialize GetPlatformInitialize()
		{
			return base.Data;
		}

		protected override PlatformInitialize GetDataFromMessage(IntPtr c_message)
		{
			return new PlatformInitialize(CAPI.ovr_Message_GetPlatformInitialize(CAPI.ovr_Message_GetNativeMessage(c_message)));
		}
	}
	public sealed class Packet : IDisposable
	{
		private readonly ulong size;

		private readonly IntPtr packetHandle;

		public ulong SenderID => CAPI.ovr_Packet_GetSenderID(packetHandle);

		public ulong Size => size;

		public SendPolicy Policy => CAPI.ovr_Packet_GetSendPolicy(packetHandle);

		public Packet(IntPtr packetHandle)
		{
			this.packetHandle = packetHandle;
			size = (ulong)CAPI.ovr_Packet_GetSize(packetHandle);
		}

		public ulong ReadBytes(byte[] destination)
		{
			if ((ulong)destination.LongLength < size)
			{
				throw new ArgumentException($"Destination array was not big enough to hold {size} bytes");
			}
			Marshal.Copy(CAPI.ovr_Packet_GetBytes(packetHandle), destination, 0, (int)size);
			return size;
		}

		~Packet()
		{
			Dispose();
		}

		public void Dispose()
		{
			CAPI.ovr_Packet_Free(packetHandle);
			GC.SuppressFinalize(this);
		}
	}
	public enum PeerConnectionState
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("CONNECTED")]
		Connected,
		[Description("TIMEOUT")]
		Timeout,
		[Description("CLOSED")]
		Closed
	}
	public enum PermissionGrantStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("GRANTED")]
		Granted,
		[Description("DENIED")]
		Denied,
		[Description("BLOCKED")]
		Blocked
	}
	public enum PermissionType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MICROPHONE")]
		Microphone,
		[Description("WRITE_EXTERNAL_STORAGE")]
		WriteExternalStorage
	}
	public sealed class Core
	{
		private static bool IsPlatformInitialized;

		public static bool LogMessages;

		public static bool IsInitialized()
		{
			return IsPlatformInitialized;
		}

		internal static void ForceInitialized()
		{
			IsPlatformInitialized = true;
		}

		private static string getAppID(string appId = null)
		{
			string appIDFromConfig = GetAppIDFromConfig();
			if (string.IsNullOrEmpty(appId))
			{
				if (string.IsNullOrEmpty(appIDFromConfig))
				{
					throw new UnityException("Update your app id by selecting 'Oculus Platform' -> 'Edit Settings'");
				}
				appId = appIDFromConfig;
			}
			else if (!string.IsNullOrEmpty(appIDFromConfig))
			{
				UnityEngine.Debug.LogWarningFormat("The 'Oculus App Id ({0})' field in 'Oculus Platform/Edit Settings' is being overridden by the App Id ({1}) that you passed in to Platform.Core.Initialize.  You should only specify this in one place.  We recommend the menu location.", appIDFromConfig, appId);
			}
			return appId;
		}

		public static Request<PlatformInitialize> AsyncInitialize(string appId = null)
		{
			appId = getAppID(appId);
			Request<PlatformInitialize> request;
			if (UnityEngine.Application.isEditor && PlatformSettings.UseStandalonePlatform)
			{
				request = new StandalonePlatform().InitializeInEditor();
			}
			else if (UnityEngine.Application.platform == RuntimePlatform.WindowsEditor || UnityEngine.Application.platform == RuntimePlatform.WindowsPlayer)
			{
				request = new WindowsPlatform().AsyncInitialize(appId);
			}
			else
			{
				if (UnityEngine.Application.platform != RuntimePlatform.Android)
				{
					throw new NotImplementedException("Oculus platform is not implemented on this platform yet.");
				}
				request = new AndroidPlatform().AsyncInitialize(appId);
			}
			IsPlatformInitialized = request != null;
			if (!IsPlatformInitialized)
			{
				throw new UnityException("Oculus Platform failed to initialize.");
			}
			if (LogMessages)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.Core.LogMessages is set to true. This will cause extra heap allocations, and should not be used outside of testing and debugging.");
			}
			new GameObject("Oculus.Platform.CallbackRunner").AddComponent<CallbackRunner>();
			return request;
		}

		public static void Initialize(string appId = null)
		{
			appId = getAppID(appId);
			if (UnityEngine.Application.isEditor && PlatformSettings.UseStandalonePlatform)
			{
				IsPlatformInitialized = new StandalonePlatform().InitializeInEditor() != null;
			}
			else if (UnityEngine.Application.platform == RuntimePlatform.WindowsEditor || UnityEngine.Application.platform == RuntimePlatform.WindowsPlayer)
			{
				IsPlatformInitialized = new WindowsPlatform().Initialize(appId);
			}
			else
			{
				if (UnityEngine.Application.platform != RuntimePlatform.Android)
				{
					throw new NotImplementedException("Oculus platform is not implemented on this platform yet.");
				}
				IsPlatformInitialized = new AndroidPlatform().Initialize(appId);
			}
			if (!IsPlatformInitialized)
			{
				throw new UnityException("Oculus Platform failed to initialize.");
			}
			if (LogMessages)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.Core.LogMessages is set to true. This will cause extra heap allocations, and should not be used outside of testing and debugging.");
			}
			new GameObject("Oculus.Platform.CallbackRunner").AddComponent<CallbackRunner>();
		}

		private static string GetAppIDFromConfig()
		{
			if (UnityEngine.Application.platform == RuntimePlatform.Android)
			{
				return PlatformSettings.MobileAppID;
			}
			return PlatformSettings.AppID;
		}
	}
	public static class ApplicationLifecycle
	{
		public static LaunchDetails GetLaunchDetails()
		{
			return new LaunchDetails(CAPI.ovr_ApplicationLifecycle_GetLaunchDetails());
		}
	}
	public static class Rooms
	{
		public static Request<Room> UpdateDataStore(ulong roomID, Dictionary<string, string> data)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovrKeyValuePair[] array = new CAPI.ovrKeyValuePair[data.Count];
				int num = 0;
				foreach (KeyValuePair<string, string> datum in data)
				{
					array[num++] = new CAPI.ovrKeyValuePair(datum.Key, datum.Value);
				}
				return new Request<Room>(CAPI.ovr_Room_UpdateDataStore(roomID, array));
			}
			return null;
		}

		[Obsolete("Deprecated in favor of SetRoomInviteAcceptedNotificationCallback")]
		public static void SetRoomInviteNotificationCallback(Message<string>.Callback callback)
		{
			SetRoomInviteAcceptedNotificationCallback(callback);
		}

		public static Request<Room> CreateAndJoinPrivate(RoomJoinPolicy joinPolicy, uint maxUsers, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_CreateAndJoinPrivate(joinPolicy, maxUsers, subscribeToUpdates));
			}
			return null;
		}

		public static Request<Room> CreateAndJoinPrivate2(RoomJoinPolicy joinPolicy, uint maxUsers, RoomOptions roomOptions)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_CreateAndJoinPrivate2(joinPolicy, maxUsers, (IntPtr)roomOptions));
			}
			return null;
		}

		public static Request<Room> Get(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_Get(roomID));
			}
			return null;
		}

		public static Request<Room> GetCurrent()
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_GetCurrent());
			}
			return null;
		}

		public static Request<Room> GetCurrentForUser(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_GetCurrentForUser(userID));
			}
			return null;
		}

		public static Request<UserList> GetInvitableUsers()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_Room_GetInvitableUsers());
			}
			return null;
		}

		public static Request<UserList> GetInvitableUsers2(RoomOptions roomOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_Room_GetInvitableUsers2((IntPtr)roomOptions));
			}
			return null;
		}

		public static Request<RoomList> GetModeratedRooms()
		{
			if (Core.IsInitialized())
			{
				return new Request<RoomList>(CAPI.ovr_Room_GetModeratedRooms());
			}
			return null;
		}

		public static Request<Room> InviteUser(ulong roomID, string inviteToken)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_InviteUser(roomID, inviteToken));
			}
			return null;
		}

		public static Request<Room> Join(ulong roomID, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_Join(roomID, subscribeToUpdates));
			}
			return null;
		}

		public static Request<Room> Join2(ulong roomID, RoomOptions roomOptions)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_Join2(roomID, (IntPtr)roomOptions));
			}
			return null;
		}

		public static Request<Room> KickUser(ulong roomID, ulong userID, int kickDurationSeconds)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_KickUser(roomID, userID, kickDurationSeconds));
			}
			return null;
		}

		public static Request LaunchInvitableUserFlow(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Room_LaunchInvitableUserFlow(roomID));
			}
			return null;
		}

		public static Request<Room> Leave(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_Leave(roomID));
			}
			return null;
		}

		public static Request<Room> SetDescription(ulong roomID, string description)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_SetDescription(roomID, description));
			}
			return null;
		}

		public static Request<Room> UpdateMembershipLockStatus(ulong roomID, RoomMembershipLockStatus membershipLockStatus)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_UpdateMembershipLockStatus(roomID, membershipLockStatus));
			}
			return null;
		}

		public static Request UpdateOwner(ulong roomID, ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Room_UpdateOwner(roomID, userID));
			}
			return null;
		}

		public static Request<Room> UpdatePrivateRoomJoinPolicy(ulong roomID, RoomJoinPolicy newJoinPolicy)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Room_UpdatePrivateRoomJoinPolicy(roomID, newJoinPolicy));
			}
			return null;
		}

		public static void SetRoomInviteAcceptedNotificationCallback(Message<string>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Room_InviteAccepted, callback);
		}

		public static void SetRoomInviteReceivedNotificationCallback(Message<RoomInviteNotification>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Room_InviteReceived, callback);
		}

		public static void SetUpdateNotificationCallback(Message<Room>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Room_RoomUpdate, callback);
		}

		public static Request<RoomList> GetNextRoomListPage(RoomList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextRoomListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<RoomList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1317239238));
			}
			return null;
		}
	}
	public static class Matchmaking
	{
		public class CustomQuery
		{
			public struct Criterion
			{
				public string key;

				public MatchmakingCriterionImportance importance;

				public Dictionary<string, object> parameters;

				public Criterion(string key_, MatchmakingCriterionImportance importance_)
				{
					key = key_;
					importance = importance_;
					parameters = null;
				}
			}

			public Dictionary<string, object> data;

			public Criterion[] criteria;

			public IntPtr ToUnmanaged()
			{
				CAPI.ovrMatchmakingCustomQueryData structure = default(CAPI.ovrMatchmakingCustomQueryData);
				if (criteria != null && criteria.Length != 0)
				{
					structure.criterionArrayCount = (uint)criteria.Length;
					CAPI.ovrMatchmakingCriterion[] array = new CAPI.ovrMatchmakingCriterion[criteria.Length];
					for (int i = 0; i < criteria.Length; i++)
					{
						array[i].importance_ = criteria[i].importance;
						array[i].key_ = criteria[i].key;
						if (criteria[i].parameters != null && criteria[i].parameters.Count > 0)
						{
							array[i].parameterArrayCount = (uint)criteria[i].parameters.Count;
							array[i].parameterArray = CAPI.ArrayOfStructsToIntPtr(CAPI.DictionaryToOVRKeyValuePairs(criteria[i].parameters));
						}
						else
						{
							array[i].parameterArrayCount = 0u;
							array[i].parameterArray = IntPtr.Zero;
						}
					}
					structure.criterionArray = CAPI.ArrayOfStructsToIntPtr(array);
				}
				else
				{
					structure.criterionArrayCount = 0u;
					structure.criterionArray = IntPtr.Zero;
				}
				if (data != null && data.Count > 0)
				{
					structure.dataArrayCount = (uint)data.Count;
					structure.dataArray = CAPI.ArrayOfStructsToIntPtr(CAPI.DictionaryToOVRKeyValuePairs(data));
				}
				else
				{
					structure.dataArrayCount = 0u;
					structure.dataArray = IntPtr.Zero;
				}
				IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(structure));
				Marshal.StructureToPtr(structure, intPtr, fDeleteOld: true);
				return intPtr;
			}
		}

		public static Request ReportResultsInsecure(ulong roomID, Dictionary<string, int> data)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovrKeyValuePair[] array = new CAPI.ovrKeyValuePair[data.Count];
				int num = 0;
				foreach (KeyValuePair<string, int> datum in data)
				{
					array[num++] = new CAPI.ovrKeyValuePair(datum.Key, datum.Value);
				}
				return new Request(CAPI.ovr_Matchmaking_ReportResultInsecure(roomID, array));
			}
			return null;
		}

		public static Request<MatchmakingStats> GetStats(string pool, uint maxLevel, MatchmakingStatApproach approach = MatchmakingStatApproach.Trailing)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingStats>(CAPI.ovr_Matchmaking_GetStats(pool, maxLevel, approach));
			}
			return null;
		}

		public static Request<MatchmakingBrowseResult> Browse(string pool, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingBrowseResult>(CAPI.ovr_Matchmaking_Browse(pool, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingBrowseResult> Browse2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingBrowseResult>(CAPI.ovr_Matchmaking_Browse2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request Cancel(string pool, string requestHash)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_Cancel(pool, requestHash));
			}
			return null;
		}

		public static Request Cancel()
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_Cancel2());
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResultAndRoom> CreateAndEnqueueRoom(string pool, uint maxUsers, bool subscribeToUpdates = false, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResultAndRoom>(CAPI.ovr_Matchmaking_CreateAndEnqueueRoom(pool, maxUsers, subscribeToUpdates, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResultAndRoom> CreateAndEnqueueRoom2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResultAndRoom>(CAPI.ovr_Matchmaking_CreateAndEnqueueRoom2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<Room> CreateRoom(string pool, uint maxUsers, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Matchmaking_CreateRoom(pool, maxUsers, subscribeToUpdates));
			}
			return null;
		}

		public static Request<Room> CreateRoom2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Matchmaking_CreateRoom2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> Enqueue(string pool, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_Enqueue(pool, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> Enqueue2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_Enqueue2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> EnqueueRoom(ulong roomID, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_EnqueueRoom(roomID, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> EnqueueRoom2(ulong roomID, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_EnqueueRoom2(roomID, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<MatchmakingAdminSnapshot> GetAdminSnapshot()
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingAdminSnapshot>(CAPI.ovr_Matchmaking_GetAdminSnapshot());
			}
			return null;
		}

		public static Request<Room> JoinRoom(ulong roomID, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Room>(CAPI.ovr_Matchmaking_JoinRoom(roomID, subscribeToUpdates));
			}
			return null;
		}

		public static Request StartMatch(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_StartMatch(roomID));
			}
			return null;
		}

		public static void SetMatchFoundNotificationCallback(Message<Room>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Matchmaking_MatchFound, callback);
		}
	}
	public static class Net
	{
		public static Packet ReadPacket()
		{
			if (!Core.IsInitialized())
			{
				return null;
			}
			IntPtr intPtr = CAPI.ovr_Net_ReadPacket();
			if (intPtr == IntPtr.Zero)
			{
				return null;
			}
			return new Packet(intPtr);
		}

		public static bool SendPacket(ulong userID, byte[] bytes, SendPolicy policy)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_SendPacket(userID, (UIntPtr)(ulong)bytes.Length, bytes, policy);
			}
			return false;
		}

		public static void Connect(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_Connect(userID);
			}
		}

		public static void Accept(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_Accept(userID);
			}
		}

		public static void Close(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_Close(userID);
			}
		}

		public static bool IsConnected(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_IsConnected(userID);
			}
			return false;
		}

		public static bool SendPacketToCurrentRoom(byte[] bytes, SendPolicy policy)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_SendPacketToCurrentRoom((UIntPtr)(ulong)bytes.Length, bytes, policy);
			}
			return false;
		}

		public static bool AcceptForCurrentRoom()
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_AcceptForCurrentRoom();
			}
			return false;
		}

		public static void CloseForCurrentRoom()
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_CloseForCurrentRoom();
			}
		}

		public static Request<PingResult> Ping(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<PingResult>(CAPI.ovr_Net_Ping(userID));
			}
			return null;
		}

		public static void SetConnectionStateChangedCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Networking_ConnectionStateChange, callback);
		}

		public static void SetPeerConnectRequestCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Networking_PeerConnectRequest, callback);
		}

		public static void SetPingResultNotificationCallback(Message<PingResult>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Networking_PingResult, callback);
		}
	}
	public static class Leaderboards
	{
		public static Request<LeaderboardEntryList> GetNextEntries(LeaderboardEntryList list)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1310751961));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetPreviousEntries(LeaderboardEntryList list)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_HTTP_GetWithMessageType(list.PreviousUrl, 1224858304));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetEntries(string leaderboardName, int limit, LeaderboardFilterType filter, LeaderboardStartAt startAt)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_Leaderboard_GetEntries(leaderboardName, limit, filter, startAt));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetEntriesAfterRank(string leaderboardName, int limit, ulong afterRank)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_Leaderboard_GetEntriesAfterRank(leaderboardName, limit, afterRank));
			}
			return null;
		}

		public static Request<bool> WriteEntry(string leaderboardName, long score, byte[] extraData = null, bool forceUpdate = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<bool>(CAPI.ovr_Leaderboard_WriteEntry(leaderboardName, score, extraData, (extraData != null) ? ((uint)extraData.Length) : 0u, forceUpdate));
			}
			return null;
		}
	}
	public static class Voip
	{
		public static void Start(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_Start(userID);
			}
		}

		public static void Accept(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_Accept(userID);
			}
		}

		public static void Stop(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_Stop(userID);
			}
		}

		public static void SetMicrophoneFilterCallback(CAPI.FilterCallback callback)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_SetMicrophoneFilterCallbackWithFixedSizeBuffer(callback, (UIntPtr)480uL);
			}
		}

		public static void SetMicrophoneMuted(VoipMuteState state)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_SetMicrophoneMuted(state);
			}
		}

		public static VoipMuteState GetSystemVoipMicrophoneMuted()
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetSystemVoipMicrophoneMuted();
			}
			return VoipMuteState.Unknown;
		}

		public static SystemVoipStatus GetSystemVoipStatus()
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetSystemVoipStatus();
			}
			return SystemVoipStatus.Unknown;
		}

		public static VoipDtxState GetIsConnectionUsingDtx(ulong peerID)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetIsConnectionUsingDtx(peerID);
			}
			return VoipDtxState.Unknown;
		}

		public static VoipBitrate GetLocalBitrate(ulong peerID)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetLocalBitrate(peerID);
			}
			return VoipBitrate.Unknown;
		}

		public static VoipBitrate GetRemoteBitrate(ulong peerID)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetRemoteBitrate(peerID);
			}
			return VoipBitrate.Unknown;
		}

		public static void SetNewConnectionOptions(VoipOptions voipOptions)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_SetNewConnectionOptions((IntPtr)voipOptions);
			}
		}

		public static Request<SystemVoipState> SetSystemVoipSuppressed(bool suppressed)
		{
			if (Core.IsInitialized())
			{
				return new Request<SystemVoipState>(CAPI.ovr_Voip_SetSystemVoipSuppressed(suppressed));
			}
			return null;
		}

		public static void SetVoipConnectRequestCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Voip_ConnectRequest, callback);
		}

		public static void SetVoipStateChangeCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Voip_StateChange, callback);
		}

		public static void SetSystemVoipStateNotificationCallback(Message<SystemVoipState>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Voip_SystemVoipState, callback);
		}
	}
	public static class Achievements
	{
		public static Request<AchievementUpdate> AddCount(string name, ulong count)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementUpdate>(CAPI.ovr_Achievements_AddCount(name, count));
			}
			return null;
		}

		public static Request<AchievementUpdate> AddFields(string name, string fields)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementUpdate>(CAPI.ovr_Achievements_AddFields(name, fields));
			}
			return null;
		}

		public static Request<AchievementDefinitionList> GetAllDefinitions()
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementDefinitionList>(CAPI.ovr_Achievements_GetAllDefinitions());
			}
			return null;
		}

		public static Request<AchievementProgressList> GetAllProgress()
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementProgressList>(CAPI.ovr_Achievements_GetAllProgress());
			}
			return null;
		}

		public static Request<AchievementDefinitionList> GetDefinitionsByName(string[] names)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementDefinitionList>(CAPI.ovr_Achievements_GetDefinitionsByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Request<AchievementProgressList> GetProgressByName(string[] names)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementProgressList>(CAPI.ovr_Achievements_GetProgressByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Request<AchievementUpdate> Unlock(string name)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementUpdate>(CAPI.ovr_Achievements_Unlock(name));
			}
			return null;
		}

		public static Request<AchievementDefinitionList> GetNextAchievementDefinitionListPage(AchievementDefinitionList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextAchievementDefinitionListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<AchievementDefinitionList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 712888917));
			}
			return null;
		}

		public static Request<AchievementProgressList> GetNextAchievementProgressListPage(AchievementProgressList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextAchievementProgressListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<AchievementProgressList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 792913703));
			}
			return null;
		}
	}
	public static class Application
	{
		public static Request<ApplicationVersion> GetVersion()
		{
			if (Core.IsInitialized())
			{
				return new Request<ApplicationVersion>(CAPI.ovr_Application_GetVersion());
			}
			return null;
		}

		public static Request<string> LaunchOtherApp(ulong appID, ApplicationOptions deeplink_options = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<string>(CAPI.ovr_Application_LaunchOtherApp(appID, (IntPtr)deeplink_options));
			}
			return null;
		}
	}
	public static class AssetFile
	{
		public static Request<AssetFileDeleteResult> Delete(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDeleteResult>(CAPI.ovr_AssetFile_Delete(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDeleteResult> DeleteById(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDeleteResult>(CAPI.ovr_AssetFile_DeleteById(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDeleteResult> DeleteByName(string assetFileName)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDeleteResult>(CAPI.ovr_AssetFile_DeleteByName(assetFileName));
			}
			return null;
		}

		public static Request<AssetFileDownloadResult> Download(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadResult>(CAPI.ovr_AssetFile_Download(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDownloadResult> DownloadById(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadResult>(CAPI.ovr_AssetFile_DownloadById(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDownloadResult> DownloadByName(string assetFileName)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadResult>(CAPI.ovr_AssetFile_DownloadByName(assetFileName));
			}
			return null;
		}

		public static Request<AssetFileDownloadCancelResult> DownloadCancel(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadCancelResult>(CAPI.ovr_AssetFile_DownloadCancel(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDownloadCancelResult> DownloadCancelById(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadCancelResult>(CAPI.ovr_AssetFile_DownloadCancelById(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDownloadCancelResult> DownloadCancelByName(string assetFileName)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadCancelResult>(CAPI.ovr_AssetFile_DownloadCancelByName(assetFileName));
			}
			return null;
		}

		public static Request<AssetDetailsList> GetList()
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetailsList>(CAPI.ovr_AssetFile_GetList());
			}
			return null;
		}

		public static Request<AssetDetails> Status(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetails>(CAPI.ovr_AssetFile_Status(assetFileID));
			}
			return null;
		}

		public static Request<AssetDetails> StatusById(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetails>(CAPI.ovr_AssetFile_StatusById(assetFileID));
			}
			return null;
		}

		public static Request<AssetDetails> StatusByName(string assetFileName)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetails>(CAPI.ovr_AssetFile_StatusByName(assetFileName));
			}
			return null;
		}

		public static void SetDownloadUpdateNotificationCallback(Message<AssetFileDownloadUpdate>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_AssetFile_DownloadUpdate, callback);
		}
	}
	public static class Avatar
	{
	}
	public static class Cal
	{
	}
	public static class CloudStorage
	{
		public static Request<CloudStorageUpdateResponse> Delete(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_Delete(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageData> Load(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageData>(CAPI.ovr_CloudStorage_Load(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageMetadataList> LoadBucketMetadata(string bucket)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageMetadataList>(CAPI.ovr_CloudStorage_LoadBucketMetadata(bucket));
			}
			return null;
		}

		public static Request<CloudStorageConflictMetadata> LoadConflictMetadata(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageConflictMetadata>(CAPI.ovr_CloudStorage_LoadConflictMetadata(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageData> LoadHandle(string handle)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageData>(CAPI.ovr_CloudStorage_LoadHandle(handle));
			}
			return null;
		}

		public static Request<CloudStorageMetadata> LoadMetadata(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageMetadata>(CAPI.ovr_CloudStorage_LoadMetadata(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageUpdateResponse> ResolveKeepLocal(string bucket, string key, string remoteHandle)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_ResolveKeepLocal(bucket, key, remoteHandle));
			}
			return null;
		}

		public static Request<CloudStorageUpdateResponse> ResolveKeepRemote(string bucket, string key, string remoteHandle)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_ResolveKeepRemote(bucket, key, remoteHandle));
			}
			return null;
		}

		public static Request<CloudStorageUpdateResponse> Save(string bucket, string key, byte[] data, long counter, string extraData)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_Save(bucket, key, data, (data != null) ? ((uint)data.Length) : 0u, counter, extraData));
			}
			return null;
		}

		public static Request<CloudStorageMetadataList> GetNextCloudStorageMetadataListPage(CloudStorageMetadataList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextCloudStorageMetadataListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageMetadataList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1544004335));
			}
			return null;
		}
	}
	public static class CloudStorage2
	{
	}
	public static class Entitlements
	{
		public static Request IsUserEntitledToApplication()
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Entitlement_GetIsViewerEntitled());
			}
			return null;
		}
	}
	public static class GraphAPI
	{
	}
	public static class HTTP
	{
	}
	public static class IAP
	{
		public static Request ConsumePurchase(string sku)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_IAP_ConsumePurchase(sku));
			}
			return null;
		}

		public static Request<ProductList> GetProductsBySKU(string[] skus)
		{
			if (Core.IsInitialized())
			{
				return new Request<ProductList>(CAPI.ovr_IAP_GetProductsBySKU(skus, (skus != null) ? skus.Length : 0));
			}
			return null;
		}

		public static Request<PurchaseList> GetViewerPurchases()
		{
			if (Core.IsInitialized())
			{
				return new Request<PurchaseList>(CAPI.ovr_IAP_GetViewerPurchases());
			}
			return null;
		}

		public static Request<Purchase> LaunchCheckoutFlow(string sku)
		{
			if (Core.IsInitialized())
			{
				if (UnityEngine.Application.isEditor)
				{
					throw new NotImplementedException("LaunchCheckoutFlow() is not implemented in the editor yet.");
				}
				return new Request<Purchase>(CAPI.ovr_IAP_LaunchCheckoutFlow(sku));
			}
			return null;
		}

		public static Request<ProductList> GetNextProductListPage(ProductList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextProductListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<ProductList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 467225263));
			}
			return null;
		}

		public static Request<PurchaseList> GetNextPurchaseListPage(PurchaseList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextPurchaseListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<PurchaseList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1196886677));
			}
			return null;
		}
	}
	public static class LanguagePack
	{
		public static Request<AssetDetails> GetCurrent()
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetails>(CAPI.ovr_LanguagePack_GetCurrent());
			}
			return null;
		}

		public static Request<AssetFileDownloadResult> SetCurrent(string tag)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadResult>(CAPI.ovr_LanguagePack_SetCurrent(tag));
			}
			return null;
		}
	}
	public static class Livestreaming
	{
		public static Request<LivestreamingStatus> GetStatus()
		{
			if (Core.IsInitialized())
			{
				return new Request<LivestreamingStatus>(CAPI.ovr_Livestreaming_GetStatus());
			}
			return null;
		}

		public static Request<LivestreamingStatus> PauseStream()
		{
			if (Core.IsInitialized())
			{
				return new Request<LivestreamingStatus>(CAPI.ovr_Livestreaming_PauseStream());
			}
			return null;
		}

		public static Request<LivestreamingStatus> ResumeStream()
		{
			if (Core.IsInitialized())
			{
				return new Request<LivestreamingStatus>(CAPI.ovr_Livestreaming_ResumeStream());
			}
			return null;
		}

		public static void SetStatusUpdateNotificationCallback(Message<LivestreamingStatus>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Livestreaming_StatusChange, callback);
		}
	}
	public static class Media
	{
		public static Request<ShareMediaResult> ShareToFacebook(string postTextSuggestion, string filePath, MediaContentType contentType)
		{
			if (Core.IsInitialized())
			{
				return new Request<ShareMediaResult>(CAPI.ovr_Media_ShareToFacebook(postTextSuggestion, filePath, contentType));
			}
			return null;
		}
	}
	public static class Notifications
	{
		public static Request<RoomInviteNotificationList> GetRoomInviteNotifications()
		{
			if (Core.IsInitialized())
			{
				return new Request<RoomInviteNotificationList>(CAPI.ovr_Notification_GetRoomInvites());
			}
			return null;
		}

		public static Request MarkAsRead(ulong notificationID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Notification_MarkAsRead(notificationID));
			}
			return null;
		}

		public static Request<RoomInviteNotificationList> GetNextRoomInviteNotificationListPage(RoomInviteNotificationList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextRoomInviteNotificationListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<RoomInviteNotificationList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 102890359));
			}
			return null;
		}
	}
	public static class Parties
	{
		public static Request<Party> GetCurrent()
		{
			if (Core.IsInitialized())
			{
				return new Request<Party>(CAPI.ovr_Party_GetCurrent());
			}
			return null;
		}
	}
	public static class Users
	{
		public static Request<User> Get(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<User>(CAPI.ovr_User_Get(userID));
			}
			return null;
		}

		public static Request<string> GetAccessToken()
		{
			if (Core.IsInitialized())
			{
				return new Request<string>(CAPI.ovr_User_GetAccessToken());
			}
			return null;
		}

		public static Request<User> GetLoggedInUser()
		{
			if (Core.IsInitialized())
			{
				return new Request<User>(CAPI.ovr_User_GetLoggedInUser());
			}
			return null;
		}

		public static Request<UserList> GetLoggedInUserFriends()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_User_GetLoggedInUserFriends());
			}
			return null;
		}

		public static Request<UserAndRoomList> GetLoggedInUserFriendsAndRooms()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserAndRoomList>(CAPI.ovr_User_GetLoggedInUserFriendsAndRooms());
			}
			return null;
		}

		public static Request<UserAndRoomList> GetLoggedInUserRecentlyMetUsersAndRooms(UserOptions userOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<UserAndRoomList>(CAPI.ovr_User_GetLoggedInUserRecentlyMetUsersAndRooms((IntPtr)userOptions));
			}
			return null;
		}

		public static Request<OrgScopedID> GetOrgScopedID(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<OrgScopedID>(CAPI.ovr_User_GetOrgScopedID(userID));
			}
			return null;
		}

		public static Request<SdkAccountList> GetSdkAccounts()
		{
			if (Core.IsInitialized())
			{
				return new Request<SdkAccountList>(CAPI.ovr_User_GetSdkAccounts());
			}
			return null;
		}

		public static Request<UserProof> GetUserProof()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserProof>(CAPI.ovr_User_GetUserProof());
			}
			return null;
		}

		public static Request<LaunchFriendRequestFlowResult> LaunchFriendRequestFlow(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<LaunchFriendRequestFlowResult>(CAPI.ovr_User_LaunchFriendRequestFlow(userID));
			}
			return null;
		}

		public static Request LaunchProfile(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_User_LaunchProfile(userID));
			}
			return null;
		}

		public static Request<UserAndRoomList> GetNextUserAndRoomListPage(UserAndRoomList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextUserAndRoomListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<UserAndRoomList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 2143146719));
			}
			return null;
		}

		public static Request<UserList> GetNextUserListPage(UserList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Oculus.Platform.GetNextUserListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 645723971));
			}
			return null;
		}
	}
	public enum PlatformInitializeResult
	{
		[Description("SUCCESS")]
		Success = 0,
		[Description("UNINITIALIZED")]
		Uninitialized = -1,
		[Description("PRE_LOADED")]
		PreLoaded = -2,
		[Description("FILE_INVALID")]
		FileInvalid = -3,
		[Description("SIGNATURE_INVALID")]
		SignatureInvalid = -4,
		[Description("UNABLE_TO_VERIFY")]
		UnableToVerify = -5,
		[Description("VERSION_MISMATCH")]
		VersionMismatch = -6,
		[Description("UNKNOWN")]
		Unknown = -7,
		[Description("INVALID_CREDENTIALS")]
		InvalidCredentials = -8,
		[Description("NOT_ENTITLED")]
		NotEntitled = -9
	}
	public static class PlatformInternal
	{
		public enum MessageTypeInternal : uint
		{
			Application_ExecuteCoordinatedLaunch = 645772532u,
			Application_GetInstalledApplications = 1376744524u,
			Avatar_UpdateMetaData = 2077219214u,
			Cal_FinalizeApplication = 497667029u,
			Cal_GetSuggestedApplications = 1450209301u,
			Cal_ProposeApplication = 1317270237u,
			CloudStorage2_GetUserDirectoryPath = 1990471406u,
			GraphAPI_Get = 822018158u,
			GraphAPI_Post = 1990567876u,
			HTTP_Get = 1874211363u,
			HTTP_GetToFile = 1317133401u,
			HTTP_MultiPartPost = 1480774160u,
			HTTP_Post = 1798743375u,
			Livestreaming_IsAllowedForApplication = 191729014u,
			Livestreaming_StartPartyStream = 2066701532u,
			Livestreaming_StartStream = 1343932350u,
			Livestreaming_StopPartyStream = 661065560u,
			Livestreaming_StopStream = 1155796426u,
			Livestreaming_UpdateCommentsOverlayVisibility = 528318516u,
			Livestreaming_UpdateMicStatus = 475495815u,
			Party_Create = 450042703u,
			Party_GatherInApplication = 1921499523u,
			Party_Get = 1586058173u,
			Party_GetCurrentForUser = 1489764138u,
			Party_Invite = 901104867u,
			Party_Join = 1744993395u,
			Party_Leave = 848430801u,
			Room_CreateOrUpdateAndJoinNamed = 2089683601u,
			Room_GetNamedRooms = 125660812u,
			Room_GetSocialRooms = 1636310390u,
			SystemPermissions_GetStatus = 493497353u,
			SystemPermissions_LaunchDeeplink = 442139697u,
			User_CancelRecordingForReportFlow = 65065289u,
			User_GetLinkedAccounts = 1469314134u,
			User_LaunchBlockFlow = 1876305192u,
			User_LaunchReportFlow = 1449304081u,
			User_LaunchReportFlow2 = 2139314275u,
			User_LaunchUnblockFlow = 346172055u,
			User_NewEntitledTestUser = 292822787u,
			User_NewTestUser = 921194380u,
			User_NewTestUserFriends = 517416647u,
			User_StartRecordingForReportFlow = 1819161571u,
			User_StopRecordingAndLaunchReportFlow = 1618513035u,
			User_StopRecordingAndLaunchReportFlow2 = 432190251u,
			User_TestUserCreateDeviceManifest = 1701884605u
		}

		public static class HTTP
		{
			public static void SetHttpTransferUpdateCallback(Message<HttpTransferUpdate>.Callback callback)
			{
				Callback.SetNotificationCallback(Message.MessageType.Notification_HTTP_Transfer, callback);
			}
		}

		public static void CrashApplication()
		{
			CAPI.ovr_CrashApplication();
		}

		internal static Message ParseMessageHandle(IntPtr messageHandle, Message.MessageType messageType)
		{
			Message result = null;
			switch ((MessageTypeInternal)messageType)
			{
			case MessageTypeInternal.User_StartRecordingForReportFlow:
				result = new MessageWithAbuseReportRecording(messageHandle);
				break;
			case MessageTypeInternal.Cal_FinalizeApplication:
				result = new MessageWithCalApplicationFinalized(messageHandle);
				break;
			case MessageTypeInternal.Cal_GetSuggestedApplications:
				result = new MessageWithCalApplicationSuggestionList(messageHandle);
				break;
			case MessageTypeInternal.User_CancelRecordingForReportFlow:
			case MessageTypeInternal.Livestreaming_UpdateMicStatus:
			case MessageTypeInternal.Application_ExecuteCoordinatedLaunch:
			case MessageTypeInternal.Livestreaming_StopPartyStream:
			case MessageTypeInternal.Party_Leave:
			case MessageTypeInternal.Cal_ProposeApplication:
			case MessageTypeInternal.User_TestUserCreateDeviceManifest:
				result = new Message(messageHandle);
				break;
			case MessageTypeInternal.Application_GetInstalledApplications:
				result = new MessageWithInstalledApplicationList(messageHandle);
				break;
			case MessageTypeInternal.User_LaunchBlockFlow:
				result = new MessageWithLaunchBlockFlowResult(messageHandle);
				break;
			case MessageTypeInternal.User_LaunchReportFlow2:
				result = new MessageWithLaunchReportFlowResult(messageHandle);
				break;
			case MessageTypeInternal.User_LaunchUnblockFlow:
				result = new MessageWithLaunchUnblockFlowResult(messageHandle);
				break;
			case MessageTypeInternal.User_GetLinkedAccounts:
				result = new MessageWithLinkedAccountList(messageHandle);
				break;
			case MessageTypeInternal.Livestreaming_IsAllowedForApplication:
				result = new MessageWithLivestreamingApplicationStatus(messageHandle);
				break;
			case MessageTypeInternal.Livestreaming_StartStream:
			case MessageTypeInternal.Livestreaming_StartPartyStream:
				result = new MessageWithLivestreamingStartResult(messageHandle);
				break;
			case MessageTypeInternal.Livestreaming_UpdateCommentsOverlayVisibility:
				result = new MessageWithLivestreamingStatus(messageHandle);
				break;
			case MessageTypeInternal.Livestreaming_StopStream:
				result = new MessageWithLivestreamingVideoStats(messageHandle);
				break;
			case MessageTypeInternal.Party_Get:
				result = new MessageWithParty(messageHandle);
				break;
			case MessageTypeInternal.Party_GetCurrentForUser:
				result = new MessageWithPartyUnderCurrentParty(messageHandle);
				break;
			case MessageTypeInternal.Party_Create:
			case MessageTypeInternal.Party_Invite:
			case MessageTypeInternal.Party_Join:
			case MessageTypeInternal.Party_GatherInApplication:
				result = new MessageWithPartyID(messageHandle);
				break;
			case MessageTypeInternal.Room_CreateOrUpdateAndJoinNamed:
				result = new MessageWithRoomUnderViewerRoom(messageHandle);
				break;
			case MessageTypeInternal.Room_GetNamedRooms:
			case MessageTypeInternal.Room_GetSocialRooms:
				result = new MessageWithRoomList(messageHandle);
				break;
			case MessageTypeInternal.User_NewEntitledTestUser:
			case MessageTypeInternal.User_NewTestUserFriends:
			case MessageTypeInternal.GraphAPI_Get:
			case MessageTypeInternal.User_NewTestUser:
			case MessageTypeInternal.HTTP_GetToFile:
			case MessageTypeInternal.HTTP_MultiPartPost:
			case MessageTypeInternal.HTTP_Post:
			case MessageTypeInternal.HTTP_Get:
			case MessageTypeInternal.CloudStorage2_GetUserDirectoryPath:
			case MessageTypeInternal.GraphAPI_Post:
			case MessageTypeInternal.Avatar_UpdateMetaData:
				result = new MessageWithString(messageHandle);
				break;
			case MessageTypeInternal.SystemPermissions_LaunchDeeplink:
			case MessageTypeInternal.SystemPermissions_GetStatus:
				result = new MessageWithSystemPermission(messageHandle);
				break;
			case MessageTypeInternal.User_StopRecordingAndLaunchReportFlow2:
			case MessageTypeInternal.User_LaunchReportFlow:
			case MessageTypeInternal.User_StopRecordingAndLaunchReportFlow:
				result = new MessageWithUserReportID(messageHandle);
				break;
			}
			return result;
		}
	}
	public sealed class PlatformSettings : ScriptableObject
	{
		[SerializeField]
		private string ovrAppID = "";

		[SerializeField]
		private string ovrMobileAppID = "";

		[SerializeField]
		private bool ovrUseStandalonePlatform = true;

		[SerializeField]
		private bool ovrEnableARM64Support;

		private static PlatformSettings instance;

		public static string AppID
		{
			get
			{
				return Instance.ovrAppID;
			}
			set
			{
				Instance.ovrAppID = value;
			}
		}

		public static string MobileAppID
		{
			get
			{
				return Instance.ovrMobileAppID;
			}
			set
			{
				Instance.ovrMobileAppID = value;
			}
		}

		public static bool UseStandalonePlatform
		{
			get
			{
				return Instance.ovrUseStandalonePlatform;
			}
			set
			{
				Instance.ovrUseStandalonePlatform = value;
			}
		}

		public static bool EnableARM64Support
		{
			get
			{
				return Instance.ovrEnableARM64Support;
			}
			set
			{
				Instance.ovrEnableARM64Support = value;
			}
		}

		public static PlatformSettings Instance
		{
			get
			{
				if (instance == null)
				{
					instance = Resources.Load<PlatformSettings>("OculusPlatformSettings");
					if (instance == null)
					{
						instance = ScriptableObject.CreateInstance<PlatformSettings>();
					}
				}
				return instance;
			}
			set
			{
				instance = value;
			}
		}
	}
	public sealed class Request<T> : Request
	{
		public Request(ulong requestID)
			: base(requestID)
		{
		}

		public Request<T> OnComplete(Message<T>.Callback callback)
		{
			Callback.OnComplete(this, callback);
			return this;
		}
	}
	public class Request
	{
		public ulong RequestID { get; set; }

		public Request(ulong requestID)
		{
			RequestID = requestID;
		}

		public Request OnComplete(Message.Callback callback)
		{
			Callback.OnComplete(this, callback);
			return this;
		}

		public static void RunCallbacks(uint limit = 0u)
		{
			if (limit == 0)
			{
				Callback.RunCallbacks();
			}
			else
			{
				Callback.RunLimitedCallbacks(limit);
			}
		}
	}
	public enum RoomJoinability
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ARE_IN")]
		AreIn,
		[Description("ARE_KICKED")]
		AreKicked,
		[Description("CAN_JOIN")]
		CanJoin,
		[Description("IS_FULL")]
		IsFull,
		[Description("NO_VIEWER")]
		NoViewer,
		[Description("POLICY_PREVENTS")]
		PolicyPrevents
	}
	public enum RoomJoinPolicy
	{
		[Description("NONE")]
		None,
		[Description("EVERYONE")]
		Everyone,
		[Description("FRIENDS_OF_MEMBERS")]
		FriendsOfMembers,
		[Description("FRIENDS_OF_OWNER")]
		FriendsOfOwner,
		[Description("INVITED_USERS")]
		InvitedUsers,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum RoomMembershipLockStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("LOCK")]
		Lock,
		[Description("UNLOCK")]
		Unlock
	}
	public class RoomOptions
	{
		private IntPtr Handle;

		public RoomOptions()
		{
			Handle = CAPI.ovr_RoomOptions_Create();
		}

		public void SetDataStore(string key, string value)
		{
			CAPI.ovr_RoomOptions_SetDataStoreString(Handle, key, value);
		}

		public void ClearDataStore()
		{
			CAPI.ovr_RoomOptions_ClearDataStore(Handle);
		}

		public void SetExcludeRecentlyMet(bool value)
		{
			CAPI.ovr_RoomOptions_SetExcludeRecentlyMet(Handle, value);
		}

		public void SetMaxUserResults(uint value)
		{
			CAPI.ovr_RoomOptions_SetMaxUserResults(Handle, value);
		}

		public void SetOrdering(UserOrdering value)
		{
			CAPI.ovr_RoomOptions_SetOrdering(Handle, value);
		}

		public void SetRecentlyMetTimeWindow(TimeWindow value)
		{
			CAPI.ovr_RoomOptions_SetRecentlyMetTimeWindow(Handle, value);
		}

		public void SetRoomId(ulong value)
		{
			CAPI.ovr_RoomOptions_SetRoomId(Handle, value);
		}

		public void SetTurnOffUpdates(bool value)
		{
			CAPI.ovr_RoomOptions_SetTurnOffUpdates(Handle, value);
		}

		public static explicit operator IntPtr(RoomOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~RoomOptions()
		{
			CAPI.ovr_RoomOptions_Destroy(Handle);
		}
	}
	public enum RoomType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MATCHMAKING")]
		Matchmaking,
		[Description("MODERATED")]
		Moderated,
		[Description("PRIVATE")]
		Private,
		[Description("SOLO")]
		Solo
	}
	public enum SdkAccountType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("OCULUS")]
		Oculus,
		[Description("FACEBOOK_GAMEROOM")]
		FacebookGameroom
	}
	public enum SendPolicy
	{
		[Description("UNRELIABLE")]
		Unreliable,
		[Description("RELIABLE")]
		Reliable,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum ServiceProvider
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("DROPBOX")]
		Dropbox,
		[Description("FACEBOOK")]
		Facebook,
		[Description("GOOGLE")]
		Google,
		[Description("INSTAGRAM")]
		Instagram,
		[Description("REMOTE_MEDIA")]
		RemoteMedia
	}
	public enum ShareMediaStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SHARED")]
		Shared,
		[Description("CANCELED")]
		Canceled
	}
	public sealed class StandalonePlatform
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void UnityLogDelegate(IntPtr tag, IntPtr msg);

		public Request<PlatformInitialize> InitializeInEditor()
		{
			if (string.IsNullOrEmpty(PlatformSettings.MobileAppID))
			{
				throw new UnityException("Update your App ID by selecting 'Oculus Platform' -> 'Edit Settings'");
			}
			string mobileAppID = PlatformSettings.MobileAppID;
			if (string.IsNullOrEmpty(StandalonePlatformSettings.OculusPlatformTestUserAccessToken))
			{
				throw new UnityException("Update your standalone credentials by selecting 'Oculus Platform' -> 'Edit Settings'");
			}
			string oculusPlatformTestUserAccessToken = StandalonePlatformSettings.OculusPlatformTestUserAccessToken;
			CAPI.ovr_UnityResetTestPlatform();
			CAPI.ovr_UnityInitGlobals(IntPtr.Zero);
			return new Request<PlatformInitialize>(CAPI.ovr_PlatformInitializeWithAccessToken(ulong.Parse(mobileAppID), oculusPlatformTestUserAccessToken));
		}
	}
	public sealed class StandalonePlatformSettings
	{
		public static string OculusPlatformTestUserEmail
		{
			get
			{
				return string.Empty;
			}
			set
			{
			}
		}

		public static string OculusPlatformTestUserPassword
		{
			get
			{
				return string.Empty;
			}
			set
			{
			}
		}

		public static string OculusPlatformTestUserAccessToken
		{
			get
			{
				return string.Empty;
			}
			set
			{
			}
		}
	}
	public enum SystemVoipStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("UNAVAILABLE")]
		Unavailable,
		[Description("SUPPRESSED")]
		Suppressed,
		[Description("ACTIVE")]
		Active
	}
	public enum TimeWindow
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ONE_HOUR")]
		OneHour,
		[Description("ONE_DAY")]
		OneDay,
		[Description("ONE_WEEK")]
		OneWeek,
		[Description("THIRTY_DAYS")]
		ThirtyDays,
		[Description("NINETY_DAYS")]
		NinetyDays
	}
	public class UserOptions
	{
		private IntPtr Handle;

		public UserOptions()
		{
			Handle = CAPI.ovr_UserOptions_Create();
		}

		public void SetMaxUsers(uint value)
		{
			CAPI.ovr_UserOptions_SetMaxUsers(Handle, value);
		}

		public void AddServiceProvider(ServiceProvider value)
		{
			CAPI.ovr_UserOptions_AddServiceProvider(Handle, value);
		}

		public void ClearServiceProviders()
		{
			CAPI.ovr_UserOptions_ClearServiceProviders(Handle);
		}

		public void SetTimeWindow(TimeWindow value)
		{
			CAPI.ovr_UserOptions_SetTimeWindow(Handle, value);
		}

		public static explicit operator IntPtr(UserOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~UserOptions()
		{
			CAPI.ovr_UserOptions_Destroy(Handle);
		}
	}
	public enum UserOrdering
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("NONE")]
		None,
		[Description("PRESENCE_ALPHABETICAL")]
		PresenceAlphabetical
	}
	public enum UserPresenceStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ONLINE")]
		Online,
		[Description("OFFLINE")]
		Offline
	}
	public class VoipAudioSourceHiLevel : MonoBehaviour
	{
		public class FilterReadDelegate : MonoBehaviour
		{
			public VoipAudioSourceHiLevel parent;

			private float[] scratchBuffer;

			private void Awake()
			{
				int num = (int)(uint)CAPI.ovr_Voip_GetOutputBufferMaxSize();
				scratchBuffer = new float[num];
			}

			private void OnAudioFilterRead(float[] data, int channels)
			{
				int num = data.Length / channels;
				int num2 = num;
				if (num2 > scratchBuffer.Length)
				{
					Array.Clear(data, 0, data.Length);
					throw new Exception($"Audio system tried to pull {num} bytes, max voip internal ring buffer size {scratchBuffer.Length}");
				}
				int num3 = parent.pcmSource.PeekSizeElements();
				if (num3 < num2)
				{
					if (verboseLogging)
					{
						UnityEngine.Debug.LogFormat("Voip starved! Want {0}, but only have {1} available", num2, num3);
					}
					return;
				}
				int pCM = parent.pcmSource.GetPCM(scratchBuffer, num2);
				if (pCM < num2)
				{
					UnityEngine.Debug.LogWarningFormat("GetPCM() returned {0} samples, expected {1}", pCM, num2);
					return;
				}
				int num4 = 0;
				float num5 = -1f;
				for (int i = 0; i < num; i++)
				{
					float num6 = scratchBuffer[i];
					for (int j = 0; j < channels; j++)
					{
						data[num4++] = num6;
						if (num6 > num5)
						{
							num5 = num6;
						}
					}
				}
				parent.peakAmplitude = num5;
			}
		}

		private int initialPlaybackDelayMS;

		public AudioSource audioSource;

		public float peakAmplitude;

		protected IVoipPCMSource pcmSource;

		private static int audioSystemPlaybackFrequency;

		private static bool verboseLogging;

		public ulong senderID
		{
			set
			{
				pcmSource.SetSenderID(value);
			}
		}

		protected void Stop()
		{
		}

		private VoipSampleRate SampleRateToEnum(int rate)
		{
			return rate switch
			{
				48000 => VoipSampleRate.HZ48000, 
				44100 => VoipSampleRate.HZ44100, 
				24000 => VoipSampleRate.HZ24000, 
				_ => VoipSampleRate.Unknown, 
			};
		}

		protected void Awake()
		{
			CreatePCMSource();
			if (audioSource == null)
			{
				audioSource = base.gameObject.AddComponent<AudioSource>();
			}
			audioSource.gameObject.AddComponent<FilterReadDelegate>();
			audioSource.gameObject.GetComponent<FilterReadDelegate>().parent = this;
			initialPlaybackDelayMS = 40;
			audioSystemPlaybackFrequency = AudioSettings.outputSampleRate;
			CAPI.ovr_Voip_SetOutputSampleRate(SampleRateToEnum(audioSystemPlaybackFrequency));
			if (verboseLogging)
			{
				UnityEngine.Debug.LogFormat("freq {0}", audioSystemPlaybackFrequency);
			}
		}

		private void Start()
		{
			audioSource.Stop();
		}

		protected virtual void CreatePCMSource()
		{
			pcmSource = new VoipPCMSourceNative();
		}

		protected static int MSToElements(int ms)
		{
			return ms * audioSystemPlaybackFrequency / 1000;
		}

		private void Update()
		{
			pcmSource.Update();
			if (!audioSource.isPlaying && pcmSource.PeekSizeElements() >= MSToElements(initialPlaybackDelayMS))
			{
				if (verboseLogging)
				{
					UnityEngine.Debug.LogFormat("buffered {0} elements, starting playback", pcmSource.PeekSizeElements());
				}
				audioSource.Play();
			}
		}
	}
	public enum VoipBitrate
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("B16000")]
		B16000,
		[Description("B24000")]
		B24000,
		[Description("B32000")]
		B32000,
		[Description("B64000")]
		B64000,
		[Description("B96000")]
		B96000,
		[Description("B128000")]
		B128000
	}
	public enum VoipDtxState
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ENABLED")]
		Enabled,
		[Description("DISABLED")]
		Disabled
	}
	public enum VoipMuteState
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MUTED")]
		Muted,
		[Description("UNMUTED")]
		Unmuted
	}
	public class VoipOptions
	{
		private IntPtr Handle;

		public VoipOptions()
		{
			Handle = CAPI.ovr_VoipOptions_Create();
		}

		public void SetBitrateForNewConnections(VoipBitrate value)
		{
			CAPI.ovr_VoipOptions_SetBitrateForNewConnections(Handle, value);
		}

		public void SetCreateNewConnectionUseDtx(VoipDtxState value)
		{
			CAPI.ovr_VoipOptions_SetCreateNewConnectionUseDtx(Handle, value);
		}

		public static explicit operator IntPtr(VoipOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~VoipOptions()
		{
			CAPI.ovr_VoipOptions_Destroy(Handle);
		}
	}
	public class VoipPCMSourceNative : IVoipPCMSource
	{
		private ulong senderID;

		public int GetPCM(float[] dest, int length)
		{
			return (int)(uint)CAPI.ovr_Voip_GetPCMFloat(senderID, dest, (UIntPtr)(ulong)length);
		}

		public void SetSenderID(ulong senderID)
		{
			this.senderID = senderID;
		}

		public int PeekSizeElements()
		{
			return (int)(uint)CAPI.ovr_Voip_GetPCMSize(senderID);
		}

		public void Update()
		{
		}
	}
	public enum VoipSampleRate
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("HZ24000")]
		HZ24000,
		[Description("HZ44100")]
		HZ44100,
		[Description("HZ48000")]
		HZ48000
	}
	public class WindowsPlatform
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void UnityLogDelegate(IntPtr tag, IntPtr msg);

		private void CPPLogCallback(IntPtr tag, IntPtr message)
		{
			UnityEngine.Debug.Log($"{Marshal.PtrToStringAnsi(tag)}: {Marshal.PtrToStringAnsi(message)}");
		}

		private IntPtr getCallbackPointer()
		{
			return IntPtr.Zero;
		}

		public bool Initialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			CAPI.ovr_UnityInitWrapperWindows(appId, getCallbackPointer());
			return true;
		}

		public Request<PlatformInitialize> AsyncInitialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			return new Request<PlatformInitialize>(CAPI.ovr_UnityInitWrapperWindowsAsynchronous(appId, getCallbackPointer()));
		}
	}
}
namespace Oculus.Platform.Models
{
	public class AbuseReportRecording
	{
		public readonly string RecordingUuid;

		public AbuseReportRecording(IntPtr o)
		{
			RecordingUuid = CAPI.ovr_AbuseReportRecording_GetRecordingUuid(o);
		}
	}
	public class AchievementDefinition
	{
		public readonly AchievementType Type;

		public readonly string Name;

		public readonly uint BitfieldLength;

		public readonly ulong Target;

		public AchievementDefinition(IntPtr o)
		{
			Type = CAPI.ovr_AchievementDefinition_GetType(o);
			Name = CAPI.ovr_AchievementDefinition_GetName(o);
			BitfieldLength = CAPI.ovr_AchievementDefinition_GetBitfieldLength(o);
			Target = CAPI.ovr_AchievementDefinition_GetTarget(o);
		}
	}
	public class AchievementDefinitionList : DeserializableList<AchievementDefinition>
	{
		public AchievementDefinitionList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_AchievementDefinitionArray_GetSize(a);
			_Data = new List<AchievementDefinition>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new AchievementDefinition(CAPI.ovr_AchievementDefinitionArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_AchievementDefinitionArray_GetNextUrl(a);
		}
	}
	public class AchievementProgress
	{
		public readonly string Bitfield;

		public readonly ulong Count;

		public readonly bool IsUnlocked;

		public readonly string Name;

		public readonly DateTime UnlockTime;

		public AchievementProgress(IntPtr o)
		{
			Bitfield = CAPI.ovr_AchievementProgress_GetBitfield(o);
			Count = CAPI.ovr_AchievementProgress_GetCount(o);
			IsUnlocked = CAPI.ovr_AchievementProgress_GetIsUnlocked(o);
			Name = CAPI.ovr_AchievementProgress_GetName(o);
			UnlockTime = CAPI.ovr_AchievementProgress_GetUnlockTime(o);
		}
	}
	public class AchievementProgressList : DeserializableList<AchievementProgress>
	{
		public AchievementProgressList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_AchievementProgressArray_GetSize(a);
			_Data = new List<AchievementProgress>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new AchievementProgress(CAPI.ovr_AchievementProgressArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_AchievementProgressArray_GetNextUrl(a);
		}
	}
	public class AchievementUpdate
	{
		public readonly bool JustUnlocked;

		public readonly string Name;

		public AchievementUpdate(IntPtr o)
		{
			JustUnlocked = CAPI.ovr_AchievementUpdate_GetJustUnlocked(o);
			Name = CAPI.ovr_AchievementUpdate_GetName(o);
		}
	}
	public class ApplicationVersion
	{
		public readonly int CurrentCode;

		public readonly string CurrentName;

		public readonly int LatestCode;

		public readonly string LatestName;

		public ApplicationVersion(IntPtr o)
		{
			CurrentCode = CAPI.ovr_ApplicationVersion_GetCurrentCode(o);
			CurrentName = CAPI.ovr_ApplicationVersion_GetCurrentName(o);
			LatestCode = CAPI.ovr_ApplicationVersion_GetLatestCode(o);
			LatestName = CAPI.ovr_ApplicationVersion_GetLatestName(o);
		}
	}
	public class AssetDetails
	{
		public readonly ulong AssetId;

		public readonly string AssetType;

		public readonly string DownloadStatus;

		public readonly string Filepath;

		public readonly string IapStatus;

		public readonly LanguagePackInfo LanguageOptional;

		[Obsolete("Deprecated in favor of LanguageOptional")]
		public readonly LanguagePackInfo Language;

		public AssetDetails(IntPtr o)
		{
			AssetId = CAPI.ovr_AssetDetails_GetAssetId(o);
			AssetType = CAPI.ovr_AssetDetails_GetAssetType(o);
			DownloadStatus = CAPI.ovr_AssetDetails_GetDownloadStatus(o);
			Filepath = CAPI.ovr_AssetDetails_GetFilepath(o);
			IapStatus = CAPI.ovr_AssetDetails_GetIapStatus(o);
			IntPtr intPtr = CAPI.ovr_AssetDetails_GetLanguage(o);
			Language = new LanguagePackInfo(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				LanguageOptional = null;
			}
			else
			{
				LanguageOptional = Language;
			}
		}
	}
	public class AssetDetailsList : DeserializableList<AssetDetails>
	{
		public AssetDetailsList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_AssetDetailsArray_GetSize(a);
			_Data = new List<AssetDetails>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new AssetDetails(CAPI.ovr_AssetDetailsArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class AssetFileDeleteResult
	{
		public readonly ulong AssetFileId;

		public readonly ulong AssetId;

		public readonly string Filepath;

		public readonly bool Success;

		public AssetFileDeleteResult(IntPtr o)
		{
			AssetFileId = CAPI.ovr_AssetFileDeleteResult_GetAssetFileId(o);
			AssetId = CAPI.ovr_AssetFileDeleteResult_GetAssetId(o);
			Filepath = CAPI.ovr_AssetFileDeleteResult_GetFilepath(o);
			Success = CAPI.ovr_AssetFileDeleteResult_GetSuccess(o);
		}
	}
	public class AssetFileDownloadCancelResult
	{
		public readonly ulong AssetFileId;

		public readonly ulong AssetId;

		public readonly string Filepath;

		public readonly bool Success;

		public AssetFileDownloadCancelResult(IntPtr o)
		{
			AssetFileId = CAPI.ovr_AssetFileDownloadCancelResult_GetAssetFileId(o);
			AssetId = CAPI.ovr_AssetFileDownloadCancelResult_GetAssetId(o);
			Filepath = CAPI.ovr_AssetFileDownloadCancelResult_GetFilepath(o);
			Success = CAPI.ovr_AssetFileDownloadCancelResult_GetSuccess(o);
		}
	}
	public class AssetFileDownloadResult
	{
		public readonly ulong AssetId;

		public readonly string Filepath;

		public AssetFileDownloadResult(IntPtr o)
		{
			AssetId = CAPI.ovr_AssetFileDownloadResult_GetAssetId(o);
			Filepath = CAPI.ovr_AssetFileDownloadResult_GetFilepath(o);
		}
	}
	public class AssetFileDownloadUpdate
	{
		public readonly ulong AssetFileId;

		public readonly ulong AssetId;

		public readonly uint BytesTotal;

		public readonly int BytesTransferred;

		public readonly bool Completed;

		public AssetFileDownloadUpdate(IntPtr o)
		{
			AssetFileId = CAPI.ovr_AssetFileDownloadUpdate_GetAssetFileId(o);
			AssetId = CAPI.ovr_AssetFileDownloadUpdate_GetAssetId(o);
			BytesTotal = CAPI.ovr_AssetFileDownloadUpdate_GetBytesTotal(o);
			BytesTransferred = CAPI.ovr_AssetFileDownloadUpdate_GetBytesTransferred(o);
			Completed = CAPI.ovr_AssetFileDownloadUpdate_GetCompleted(o);
		}
	}
	public class CalApplicationFinalized
	{
		public readonly int CountdownMS;

		public readonly ulong ID;

		public readonly string LaunchDetails;

		public CalApplicationFinalized(IntPtr o)
		{
			CountdownMS = CAPI.ovr_CalApplicationFinalized_GetCountdownMS(o);
			ID = CAPI.ovr_CalApplicationFinalized_GetID(o);
			LaunchDetails = CAPI.ovr_CalApplicationFinalized_GetLaunchDetails(o);
		}
	}
	public class CalApplicationProposed
	{
		public readonly ulong ID;

		public CalApplicationProposed(IntPtr o)
		{
			ID = CAPI.ovr_CalApplicationProposed_GetID(o);
		}
	}
	public class CalApplicationSuggestion
	{
		public readonly ulong ID;

		public readonly string SocialContext;

		public CalApplicationSuggestion(IntPtr o)
		{
			ID = CAPI.ovr_CalApplicationSuggestion_GetID(o);
			SocialContext = CAPI.ovr_CalApplicationSuggestion_GetSocialContext(o);
		}
	}
	public class CalApplicationSuggestionList : DeserializableList<CalApplicationSuggestion>
	{
		public CalApplicationSuggestionList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_CalApplicationSuggestionArray_GetSize(a);
			_Data = new List<CalApplicationSuggestion>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new CalApplicationSuggestion(CAPI.ovr_CalApplicationSuggestionArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class CloudStorageConflictMetadata
	{
		public readonly CloudStorageMetadata Local;

		public readonly CloudStorageMetadata Remote;

		public CloudStorageConflictMetadata(IntPtr o)
		{
			Local = new CloudStorageMetadata(CAPI.ovr_CloudStorageConflictMetadata_GetLocal(o));
			Remote = new CloudStorageMetadata(CAPI.ovr_CloudStorageConflictMetadata_GetRemote(o));
		}
	}
	public class CloudStorageData
	{
		public readonly string Bucket;

		public readonly byte[] Data;

		public readonly uint DataSize;

		public readonly string Key;

		public CloudStorageData(IntPtr o)
		{
			Bucket = CAPI.ovr_CloudStorageData_GetBucket(o);
			Data = CAPI.ovr_CloudStorageData_GetData(o);
			DataSize = CAPI.ovr_CloudStorageData_GetDataSize(o);
			Key = CAPI.ovr_CloudStorageData_GetKey(o);
		}
	}
	public class CloudStorageMetadata
	{
		public readonly string Bucket;

		public readonly long Counter;

		public readonly uint DataSize;

		public readonly string ExtraData;

		public readonly string Key;

		public readonly ulong SaveTime;

		public readonly CloudStorageDataStatus Status;

		public readonly string VersionHandle;

		public CloudStorageMetadata(IntPtr o)
		{
			Bucket = CAPI.ovr_CloudStorageMetadata_GetBucket(o);
			Counter = CAPI.ovr_CloudStorageMetadata_GetCounter(o);
			DataSize = CAPI.ovr_CloudStorageMetadata_GetDataSize(o);
			ExtraData = CAPI.ovr_CloudStorageMetadata_GetExtraData(o);
			Key = CAPI.ovr_CloudStorageMetadata_GetKey(o);
			SaveTime = CAPI.ovr_CloudStorageMetadata_GetSaveTime(o);
			Status = CAPI.ovr_CloudStorageMetadata_GetStatus(o);
			VersionHandle = CAPI.ovr_CloudStorageMetadata_GetVersionHandle(o);
		}
	}
	public class CloudStorageMetadataList : DeserializableList<CloudStorageMetadata>
	{
		public CloudStorageMetadataList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_CloudStorageMetadataArray_GetSize(a);
			_Data = new List<CloudStorageMetadata>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new CloudStorageMetadata(CAPI.ovr_CloudStorageMetadataArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_CloudStorageMetadataArray_GetNextUrl(a);
		}
	}
	public class CloudStorageUpdateResponse
	{
		public readonly string Bucket;

		public readonly string Key;

		public readonly CloudStorageUpdateStatus Status;

		public readonly string VersionHandle;

		public CloudStorageUpdateResponse(IntPtr o)
		{
			Bucket = CAPI.ovr_CloudStorageUpdateResponse_GetBucket(o);
			Key = CAPI.ovr_CloudStorageUpdateResponse_GetKey(o);
			Status = CAPI.ovr_CloudStorageUpdateResponse_GetStatus(o);
			VersionHandle = CAPI.ovr_CloudStorageUpdateResponse_GetVersionHandle(o);
		}
	}
	public class DeserializableList<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
	{
		protected List<T> _Data;

		protected string _NextUrl;

		protected string _PreviousUrl;

		public int Count => _Data.Count;

		bool ICollection<T>.IsReadOnly => ((ICollection<T>)_Data).IsReadOnly;

		public T this[int index]
		{
			get
			{
				return _Data[index];
			}
			set
			{
				_Data[index] = value;
			}
		}

		[Obsolete("Use IList interface on the DeserializableList object instead.", false)]
		public List<T> Data => _Data;

		public bool HasNextPage => !string.IsNullOrEmpty(NextUrl);

		public bool HasPreviousPage => !string.IsNullOrEmpty(PreviousUrl);

		public string NextUrl => _NextUrl;

		public string PreviousUrl => _PreviousUrl;

		public int IndexOf(T obj)
		{
			return _Data.IndexOf(obj);
		}

		public void Add(T item)
		{
			_Data.Add(item);
		}

		public void Clear()
		{
			_Data.Clear();
		}

		public bool Contains(T item)
		{
			return _Data.Contains(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			_Data.CopyTo(array, arrayIndex);
		}

		public IEnumerator<T> GetEnumerator()
		{
			return _Data.GetEnumerator();
		}

		public void Insert(int index, T item)
		{
			_Data.Insert(index, item);
		}

		public bool Remove(T item)
		{
			return _Data.Remove(item);
		}

		public void RemoveAt(int index)
		{
			_Data.RemoveAt(index);
		}

		private IEnumerator GetEnumerator1()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator1();
		}
	}
	public class Error
	{
		public readonly int Code;

		public readonly int HttpCode;

		public readonly string Message;

		public Error(int code, string message, int httpCode)
		{
			Message = message;
			Code = code;
			HttpCode = httpCode;
		}
	}
	public class HttpTransferUpdate
	{
		public readonly ulong ID;

		public readonly byte[] Payload;

		public readonly bool IsCompleted;

		public HttpTransferUpdate(IntPtr o)
		{
			ID = CAPI.ovr_HttpTransferUpdate_GetID(o);
			IsCompleted = CAPI.ovr_HttpTransferUpdate_IsCompleted(o);
			long num = (long)(ulong)CAPI.ovr_HttpTransferUpdate_GetSize(o);
			Payload = new byte[num];
			Marshal.Copy(CAPI.ovr_Packet_GetBytes(o), Payload, 0, (int)num);
		}
	}
	public class InstalledApplication
	{
		public readonly string ApplicationId;

		public readonly string PackageName;

		public readonly string Status;

		public readonly int VersionCode;

		public readonly string VersionName;

		public InstalledApplication(IntPtr o)
		{
			ApplicationId = CAPI.ovr_InstalledApplication_GetApplicationId(o);
			PackageName = CAPI.ovr_InstalledApplication_GetPackageName(o);
			Status = CAPI.ovr_InstalledApplication_GetStatus(o);
			VersionCode = CAPI.ovr_InstalledApplication_GetVersionCode(o);
			VersionName = CAPI.ovr_InstalledApplication_GetVersionName(o);
		}
	}
	public class InstalledApplicationList : DeserializableList<InstalledApplication>
	{
		public InstalledApplicationList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_InstalledApplicationArray_GetSize(a);
			_Data = new List<InstalledApplication>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new InstalledApplication(CAPI.ovr_InstalledApplicationArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class LanguagePackInfo
	{
		public readonly string EnglishName;

		public readonly string NativeName;

		public readonly string Tag;

		public LanguagePackInfo(IntPtr o)
		{
			EnglishName = CAPI.ovr_LanguagePackInfo_GetEnglishName(o);
			NativeName = CAPI.ovr_LanguagePackInfo_GetNativeName(o);
			Tag = CAPI.ovr_LanguagePackInfo_GetTag(o);
		}
	}
	public class LaunchBlockFlowResult
	{
		public readonly bool DidBlock;

		public readonly bool DidCancel;

		public LaunchBlockFlowResult(IntPtr o)
		{
			DidBlock = CAPI.ovr_LaunchBlockFlowResult_GetDidBlock(o);
			DidCancel = CAPI.ovr_LaunchBlockFlowResult_GetDidCancel(o);
		}
	}
	public class LaunchDetails
	{
		public readonly string DeeplinkMessage;

		public readonly string LaunchSource;

		public readonly LaunchType LaunchType;

		public readonly ulong RoomID;

		public readonly UserList UsersOptional;

		[Obsolete("Deprecated in favor of UsersOptional")]
		public readonly UserList Users;

		public LaunchDetails(IntPtr o)
		{
			DeeplinkMessage = CAPI.ovr_LaunchDetails_GetDeeplinkMessage(o);
			LaunchSource = CAPI.ovr_LaunchDetails_GetLaunchSource(o);
			LaunchType = CAPI.ovr_LaunchDetails_GetLaunchType(o);
			RoomID = CAPI.ovr_LaunchDetails_GetRoomID(o);
			IntPtr intPtr = CAPI.ovr_LaunchDetails_GetUsers(o);
			Users = new UserList(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				UsersOptional = null;
			}
			else
			{
				UsersOptional = Users;
			}
		}
	}
	public class LaunchFriendRequestFlowResult
	{
		public readonly bool DidCancel;

		public readonly bool DidSendRequest;

		public LaunchFriendRequestFlowResult(IntPtr o)
		{
			DidCancel = CAPI.ovr_LaunchFriendRequestFlowResult_GetDidCancel(o);
			DidSendRequest = CAPI.ovr_LaunchFriendRequestFlowResult_GetDidSendRequest(o);
		}
	}
	public class LaunchReportFlowResult
	{
		public readonly bool DidCancel;

		public readonly ulong UserReportId;

		public LaunchReportFlowResult(IntPtr o)
		{
			DidCancel = CAPI.ovr_LaunchReportFlowResult_GetDidCancel(o);
			UserReportId = CAPI.ovr_LaunchReportFlowResult_GetUserReportId(o);
		}
	}
	public class LaunchUnblockFlowResult
	{
		public readonly bool DidCancel;

		public readonly bool DidUnblock;

		public LaunchUnblockFlowResult(IntPtr o)
		{
			DidCancel = CAPI.ovr_LaunchUnblockFlowResult_GetDidCancel(o);
			DidUnblock = CAPI.ovr_LaunchUnblockFlowResult_GetDidUnblock(o);
		}
	}
	public class LeaderboardEntry
	{
		public readonly byte[] ExtraData;

		public readonly int Rank;

		public readonly long Score;

		public readonly DateTime Timestamp;

		public readonly User User;

		public LeaderboardEntry(IntPtr o)
		{
			ExtraData = CAPI.ovr_LeaderboardEntry_GetExtraData(o);
			Rank = CAPI.ovr_LeaderboardEntry_GetRank(o);
			Score = CAPI.ovr_LeaderboardEntry_GetScore(o);
			Timestamp = CAPI.ovr_LeaderboardEntry_GetTimestamp(o);
			User = new User(CAPI.ovr_LeaderboardEntry_GetUser(o));
		}
	}
	public class LeaderboardEntryList : DeserializableList<LeaderboardEntry>
	{
		public readonly ulong TotalCount;

		public LeaderboardEntryList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_LeaderboardEntryArray_GetSize(a);
			_Data = new List<LeaderboardEntry>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new LeaderboardEntry(CAPI.ovr_LeaderboardEntryArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			TotalCount = CAPI.ovr_LeaderboardEntryArray_GetTotalCount(a);
			_PreviousUrl = CAPI.ovr_LeaderboardEntryArray_GetPreviousUrl(a);
			_NextUrl = CAPI.ovr_LeaderboardEntryArray_GetNextUrl(a);
		}
	}
	public class LinkedAccount
	{
		public readonly string AccessToken;

		public readonly ServiceProvider ServiceProvider;

		public readonly string UserId;

		public LinkedAccount(IntPtr o)
		{
			AccessToken = CAPI.ovr_LinkedAccount_GetAccessToken(o);
			ServiceProvider = CAPI.ovr_LinkedAccount_GetServiceProvider(o);
			UserId = CAPI.ovr_LinkedAccount_GetUserId(o);
		}
	}
	public class LinkedAccountList : DeserializableList<LinkedAccount>
	{
		public LinkedAccountList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_LinkedAccountArray_GetSize(a);
			_Data = new List<LinkedAccount>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new LinkedAccount(CAPI.ovr_LinkedAccountArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class LivestreamingApplicationStatus
	{
		public readonly bool StreamingEnabled;

		public LivestreamingApplicationStatus(IntPtr o)
		{
			StreamingEnabled = CAPI.ovr_LivestreamingApplicationStatus_GetStreamingEnabled(o);
		}
	}
	public class LivestreamingStartResult
	{
		public readonly LivestreamingStartStatus StreamingResult;

		public LivestreamingStartResult(IntPtr o)
		{
			StreamingResult = CAPI.ovr_LivestreamingStartResult_GetStreamingResult(o);
		}
	}
	public class LivestreamingStatus
	{
		public readonly bool CommentsVisible;

		public readonly bool IsPaused;

		public readonly bool LivestreamingEnabled;

		public readonly int LivestreamingType;

		public readonly bool MicEnabled;

		public LivestreamingStatus(IntPtr o)
		{
			CommentsVisible = CAPI.ovr_LivestreamingStatus_GetCommentsVisible(o);
			IsPaused = CAPI.ovr_LivestreamingStatus_GetIsPaused(o);
			LivestreamingEnabled = CAPI.ovr_LivestreamingStatus_GetLivestreamingEnabled(o);
			LivestreamingType = CAPI.ovr_LivestreamingStatus_GetLivestreamingType(o);
			MicEnabled = CAPI.ovr_LivestreamingStatus_GetMicEnabled(o);
		}
	}
	public class LivestreamingVideoStats
	{
		public readonly int CommentCount;

		public readonly int ReactionCount;

		public readonly string TotalViews;

		public LivestreamingVideoStats(IntPtr o)
		{
			CommentCount = CAPI.ovr_LivestreamingVideoStats_GetCommentCount(o);
			ReactionCount = CAPI.ovr_LivestreamingVideoStats_GetReactionCount(o);
			TotalViews = CAPI.ovr_LivestreamingVideoStats_GetTotalViews(o);
		}
	}
	public class MatchmakingAdminSnapshot
	{
		public readonly MatchmakingAdminSnapshotCandidateList Candidates;

		public readonly double MyCurrentThreshold;

		public MatchmakingAdminSnapshot(IntPtr o)
		{
			Candidates = new MatchmakingAdminSnapshotCandidateList(CAPI.ovr_MatchmakingAdminSnapshot_GetCandidates(o));
			MyCurrentThreshold = CAPI.ovr_MatchmakingAdminSnapshot_GetMyCurrentThreshold(o);
		}
	}
	public class MatchmakingAdminSnapshotCandidate
	{
		public readonly bool CanMatch;

		public readonly double MyTotalScore;

		public readonly double TheirCurrentThreshold;

		public readonly double TheirTotalScore;

		public readonly string TraceId;

		public MatchmakingAdminSnapshotCandidate(IntPtr o)
		{
			CanMatch = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetCanMatch(o);
			MyTotalScore = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetMyTotalScore(o);
			TheirCurrentThreshold = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetTheirCurrentThreshold(o);
			TheirTotalScore = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetTheirTotalScore(o);
			TraceId = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetTraceId(o);
		}
	}
	public class MatchmakingAdminSnapshotCandidateList : DeserializableList<MatchmakingAdminSnapshotCandidate>
	{
		public MatchmakingAdminSnapshotCandidateList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_MatchmakingAdminSnapshotCandidateArray_GetSize(a);
			_Data = new List<MatchmakingAdminSnapshotCandidate>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new MatchmakingAdminSnapshotCandidate(CAPI.ovr_MatchmakingAdminSnapshotCandidateArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class MatchmakingBrowseResult
	{
		public readonly MatchmakingEnqueueResult EnqueueResult;

		public readonly RoomList Rooms;

		public MatchmakingBrowseResult(IntPtr o)
		{
			EnqueueResult = new MatchmakingEnqueueResult(CAPI.ovr_MatchmakingBrowseResult_GetEnqueueResult(o));
			Rooms = new RoomList(CAPI.ovr_MatchmakingBrowseResult_GetRooms(o));
		}
	}
	public class MatchmakingEnqueuedUser
	{
		public readonly Dictionary<string, string> CustomData;

		public readonly User UserOptional;

		[Obsolete("Deprecated in favor of UserOptional")]
		public readonly User User;

		public MatchmakingEnqueuedUser(IntPtr o)
		{
			CustomData = CAPI.DataStoreFromNative(CAPI.ovr_MatchmakingEnqueuedUser_GetCustomData(o));
			IntPtr intPtr = CAPI.ovr_MatchmakingEnqueuedUser_GetUser(o);
			User = new User(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				UserOptional = null;
			}
			else
			{
				UserOptional = User;
			}
		}
	}
	public class MatchmakingEnqueuedUserList : DeserializableList<MatchmakingEnqueuedUser>
	{
		public MatchmakingEnqueuedUserList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_MatchmakingEnqueuedUserArray_GetSize(a);
			_Data = new List<MatchmakingEnqueuedUser>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new MatchmakingEnqueuedUser(CAPI.ovr_MatchmakingEnqueuedUserArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class MatchmakingEnqueueResult
	{
		public readonly MatchmakingAdminSnapshot AdminSnapshotOptional;

		[Obsolete("Deprecated in favor of AdminSnapshotOptional")]
		public readonly MatchmakingAdminSnapshot AdminSnapshot;

		public readonly uint AverageWait;

		public readonly uint MatchesInLastHourCount;

		public readonly uint MaxExpectedWait;

		public readonly string Pool;

		public readonly uint RecentMatchPercentage;

		public readonly string RequestHash;

		public MatchmakingEnqueueResult(IntPtr o)
		{
			IntPtr intPtr = CAPI.ovr_MatchmakingEnqueueResult_GetAdminSnapshot(o);
			AdminSnapshot = new MatchmakingAdminSnapshot(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				AdminSnapshotOptional = null;
			}
			else
			{
				AdminSnapshotOptional = AdminSnapshot;
			}
			AverageWait = CAPI.ovr_MatchmakingEnqueueResult_GetAverageWait(o);
			MatchesInLastHourCount = CAPI.ovr_MatchmakingEnqueueResult_GetMatchesInLastHourCount(o);
			MaxExpectedWait = CAPI.ovr_MatchmakingEnqueueResult_GetMaxExpectedWait(o);
			Pool = CAPI.ovr_MatchmakingEnqueueResult_GetPool(o);
			RecentMatchPercentage = CAPI.ovr_MatchmakingEnqueueResult_GetRecentMatchPercentage(o);
			RequestHash = CAPI.ovr_MatchmakingEnqueueResult_GetRequestHash(o);
		}
	}
	public class MatchmakingEnqueueResultAndRoom
	{
		public readonly MatchmakingEnqueueResult MatchmakingEnqueueResult;

		public readonly Room Room;

		public MatchmakingEnqueueResultAndRoom(IntPtr o)
		{
			MatchmakingEnqueueResult = new MatchmakingEnqueueResult(CAPI.ovr_MatchmakingEnqueueResultAndRoom_GetMatchmakingEnqueueResult(o));
			Room = new Room(CAPI.ovr_MatchmakingEnqueueResultAndRoom_GetRoom(o));
		}
	}
	public class MatchmakingStats
	{
		public readonly uint DrawCount;

		public readonly uint LossCount;

		public readonly uint SkillLevel;

		public readonly uint WinCount;

		public MatchmakingStats(IntPtr o)
		{
			DrawCount = CAPI.ovr_MatchmakingStats_GetDrawCount(o);
			LossCount = CAPI.ovr_MatchmakingStats_GetLossCount(o);
			SkillLevel = CAPI.ovr_MatchmakingStats_GetSkillLevel(o);
			WinCount = CAPI.ovr_MatchmakingStats_GetWinCount(o);
		}
	}
	public class NetworkingPeer
	{
		public ulong ID { get; private set; }

		public PeerConnectionState State { get; private set; }

		public NetworkingPeer(ulong id, PeerConnectionState state)
		{
			ID = id;
			State = state;
		}
	}
	public class OrgScopedID
	{
		public readonly ulong ID;

		public OrgScopedID(IntPtr o)
		{
			ID = CAPI.ovr_OrgScopedID_GetID(o);
		}
	}
	public class Party
	{
		public readonly ulong ID;

		public readonly UserList InvitedUsersOptional;

		[Obsolete("Deprecated in favor of InvitedUsersOptional")]
		public readonly UserList InvitedUsers;

		public readonly User LeaderOptional;

		[Obsolete("Deprecated in favor of LeaderOptional")]
		public readonly User Leader;

		public readonly Room RoomOptional;

		[Obsolete("Deprecated in favor of RoomOptional")]
		public readonly Room Room;

		public readonly UserList UsersOptional;

		[Obsolete("Deprecated in favor of UsersOptional")]
		public readonly UserList Users;

		public Party(IntPtr o)
		{
			ID = CAPI.ovr_Party_GetID(o);
			IntPtr intPtr = CAPI.ovr_Party_GetInvitedUsers(o);
			InvitedUsers = new UserList(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				InvitedUsersOptional = null;
			}
			else
			{
				InvitedUsersOptional = InvitedUsers;
			}
			IntPtr intPtr2 = CAPI.ovr_Party_GetLeader(o);
			Leader = new User(intPtr2);
			if (intPtr2 == IntPtr.Zero)
			{
				LeaderOptional = null;
			}
			else
			{
				LeaderOptional = Leader;
			}
			IntPtr intPtr3 = CAPI.ovr_Party_GetRoom(o);
			Room = new Room(intPtr3);
			if (intPtr3 == IntPtr.Zero)
			{
				RoomOptional = null;
			}
			else
			{
				RoomOptional = Room;
			}
			IntPtr intPtr4 = CAPI.ovr_Party_GetUsers(o);
			Users = new UserList(intPtr4);
			if (intPtr4 == IntPtr.Zero)
			{
				UsersOptional = null;
			}
			else
			{
				UsersOptional = Users;
			}
		}
	}
	public class PartyID
	{
		public readonly ulong ID;

		public PartyID(IntPtr o)
		{
			ID = CAPI.ovr_PartyID_GetID(o);
		}
	}
	public class Pid
	{
		public readonly string Id;

		public Pid(IntPtr o)
		{
			Id = CAPI.ovr_Pid_GetId(o);
		}
	}
	public class PidList : DeserializableList<Pid>
	{
		public PidList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_PidArray_GetSize(a);
			_Data = new List<Pid>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Pid(CAPI.ovr_PidArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class PingResult
	{
		private ulong? pingTimeUsec;

		public ulong ID { get; private set; }

		public ulong PingTimeUsec
		{
			get
			{
				if (!pingTimeUsec.HasValue)
				{
					return 0uL;
				}
				return pingTimeUsec.Value;
			}
		}

		public bool IsTimeout => !pingTimeUsec.HasValue;

		public PingResult(ulong id, ulong? pingTimeUsec)
		{
			ID = id;
			this.pingTimeUsec = pingTimeUsec;
		}
	}
	public class PlatformInitialize
	{
		public readonly PlatformInitializeResult Result;

		public PlatformInitialize(IntPtr o)
		{
			Result = CAPI.ovr_PlatformInitialize_GetResult(o);
		}
	}
	public class Product
	{
		public readonly string Description;

		public readonly string FormattedPrice;

		public readonly string Name;

		public readonly string Sku;

		public Product(IntPtr o)
		{
			Description = CAPI.ovr_Product_GetDescription(o);
			FormattedPrice = CAPI.ovr_Product_GetFormattedPrice(o);
			Name = CAPI.ovr_Product_GetName(o);
			Sku = CAPI.ovr_Product_GetSKU(o);
		}
	}
	public class ProductList : DeserializableList<Product>
	{
		public ProductList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_ProductArray_GetSize(a);
			_Data = new List<Product>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Product(CAPI.ovr_ProductArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_ProductArray_GetNextUrl(a);
		}
	}
	public class Purchase
	{
		public readonly DateTime ExpirationTime;

		public readonly DateTime GrantTime;

		public readonly ulong ID;

		public readonly string Sku;

		public Purchase(IntPtr o)
		{
			ExpirationTime = CAPI.ovr_Purchase_GetExpirationTime(o);
			GrantTime = CAPI.ovr_Purchase_GetGrantTime(o);
			ID = CAPI.ovr_Purchase_GetPurchaseID(o);
			Sku = CAPI.ovr_Purchase_GetSKU(o);
		}
	}
	public class PurchaseList : DeserializableList<Purchase>
	{
		public PurchaseList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_PurchaseArray_GetSize(a);
			_Data = new List<Purchase>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Purchase(CAPI.ovr_PurchaseArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_PurchaseArray_GetNextUrl(a);
		}
	}
	public class Room
	{
		public readonly ulong ApplicationID;

		public readonly Dictionary<string, string> DataStore;

		public readonly string Description;

		public readonly ulong ID;

		public readonly UserList InvitedUsersOptional;

		[Obsolete("Deprecated in favor of InvitedUsersOptional")]
		public readonly UserList InvitedUsers;

		public readonly bool IsMembershipLocked;

		public readonly RoomJoinPolicy JoinPolicy;

		public readonly RoomJoinability Joinability;

		public readonly MatchmakingEnqueuedUserList MatchedUsersOptional;

		[Obsolete("Deprecated in favor of MatchedUsersOptional")]
		public readonly MatchmakingEnqueuedUserList MatchedUsers;

		public readonly uint MaxUsers;

		public readonly string Name;

		public readonly User OwnerOptional;

		[Obsolete("Deprecated in favor of OwnerOptional")]
		public readonly User Owner;

		public readonly RoomType Type;

		public readonly UserList UsersOptional;

		[Obsolete("Deprecated in favor of UsersOptional")]
		public readonly UserList Users;

		public readonly uint Version;

		public Room(IntPtr o)
		{
			ApplicationID = CAPI.ovr_Room_GetApplicationID(o);
			DataStore = CAPI.DataStoreFromNative(CAPI.ovr_Room_GetDataStore(o));
			Description = CAPI.ovr_Room_GetDescription(o);
			ID = CAPI.ovr_Room_GetID(o);
			IntPtr intPtr = CAPI.ovr_Room_GetInvitedUsers(o);
			InvitedUsers = new UserList(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				InvitedUsersOptional = null;
			}
			else
			{
				InvitedUsersOptional = InvitedUsers;
			}
			IsMembershipLocked = CAPI.ovr_Room_GetIsMembershipLocked(o);
			JoinPolicy = CAPI.ovr_Room_GetJoinPolicy(o);
			Joinability = CAPI.ovr_Room_GetJoinability(o);
			IntPtr intPtr2 = CAPI.ovr_Room_GetMatchedUsers(o);
			MatchedUsers = new MatchmakingEnqueuedUserList(intPtr2);
			if (intPtr2 == IntPtr.Zero)
			{
				MatchedUsersOptional = null;
			}
			else
			{
				MatchedUsersOptional = MatchedUsers;
			}
			MaxUsers = CAPI.ovr_Room_GetMaxUsers(o);
			Name = CAPI.ovr_Room_GetName(o);
			IntPtr intPtr3 = CAPI.ovr_Room_GetOwner(o);
			Owner = new User(intPtr3);
			if (intPtr3 == IntPtr.Zero)
			{
				OwnerOptional = null;
			}
			else
			{
				OwnerOptional = Owner;
			}
			Type = CAPI.ovr_Room_GetType(o);
			IntPtr intPtr4 = CAPI.ovr_Room_GetUsers(o);
			Users = new UserList(intPtr4);
			if (intPtr4 == IntPtr.Zero)
			{
				UsersOptional = null;
			}
			else
			{
				UsersOptional = Users;
			}
			Version = CAPI.ovr_Room_GetVersion(o);
		}
	}
	public class RoomList : DeserializableList<Room>
	{
		public RoomList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_RoomArray_GetSize(a);
			_Data = new List<Room>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Room(CAPI.ovr_RoomArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_RoomArray_GetNextUrl(a);
		}
	}
	public class RoomInviteNotification
	{
		public readonly ulong ID;

		public readonly ulong RoomID;

		public readonly ulong SenderID;

		public readonly DateTime SentTime;

		public RoomInviteNotification(IntPtr o)
		{
			ID = CAPI.ovr_RoomInviteNotification_GetID(o);
			RoomID = CAPI.ovr_RoomInviteNotification_GetRoomID(o);
			SenderID = CAPI.ovr_RoomInviteNotification_GetSenderID(o);
			SentTime = CAPI.ovr_RoomInviteNotification_GetSentTime(o);
		}
	}
	public class RoomInviteNotificationList : DeserializableList<RoomInviteNotification>
	{
		public RoomInviteNotificationList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_RoomInviteNotificationArray_GetSize(a);
			_Data = new List<RoomInviteNotification>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new RoomInviteNotification(CAPI.ovr_RoomInviteNotificationArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_RoomInviteNotificationArray_GetNextUrl(a);
		}
	}
	public class SdkAccount
	{
		public readonly SdkAccountType AccountType;

		public readonly ulong UserId;

		public SdkAccount(IntPtr o)
		{
			AccountType = CAPI.ovr_SdkAccount_GetAccountType(o);
			UserId = CAPI.ovr_SdkAccount_GetUserId(o);
		}
	}
	public class SdkAccountList : DeserializableList<SdkAccount>
	{
		public SdkAccountList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_SdkAccountArray_GetSize(a);
			_Data = new List<SdkAccount>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new SdkAccount(CAPI.ovr_SdkAccountArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class ShareMediaResult
	{
		public readonly ShareMediaStatus Status;

		public ShareMediaResult(IntPtr o)
		{
			Status = CAPI.ovr_ShareMediaResult_GetStatus(o);
		}
	}
	public class SystemPermission
	{
		public readonly bool HasPermission;

		public readonly PermissionGrantStatus PermissionGrantStatus;

		public SystemPermission(IntPtr o)
		{
			HasPermission = CAPI.ovr_SystemPermission_GetHasPermission(o);
			PermissionGrantStatus = CAPI.ovr_SystemPermission_GetPermissionGrantStatus(o);
		}
	}
	public class SystemVoipState
	{
		public readonly VoipMuteState MicrophoneMuted;

		public readonly SystemVoipStatus Status;

		public SystemVoipState(IntPtr o)
		{
			MicrophoneMuted = CAPI.ovr_SystemVoipState_GetMicrophoneMuted(o);
			Status = CAPI.ovr_SystemVoipState_GetStatus(o);
		}
	}
	public class User
	{
		public readonly ulong ID;

		public readonly string ImageURL;

		public readonly string InviteToken;

		public readonly string OculusID;

		public readonly string Presence;

		public readonly UserPresenceStatus PresenceStatus;

		public readonly string SmallImageUrl;

		public User(IntPtr o)
		{
			ID = CAPI.ovr_User_GetID(o);
			ImageURL = CAPI.ovr_User_GetImageUrl(o);
			InviteToken = CAPI.ovr_User_GetInviteToken(o);
			OculusID = CAPI.ovr_User_GetOculusID(o);
			Presence = CAPI.ovr_User_GetPresence(o);
			PresenceStatus = CAPI.ovr_User_GetPresenceStatus(o);
			SmallImageUrl = CAPI.ovr_User_GetSmallImageUrl(o);
		}
	}
	public class UserList : DeserializableList<User>
	{
		public UserList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_UserArray_GetSize(a);
			_Data = new List<User>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new User(CAPI.ovr_UserArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_UserArray_GetNextUrl(a);
		}
	}
	public class UserAndRoom
	{
		public readonly Room RoomOptional;

		[Obsolete("Deprecated in favor of RoomOptional")]
		public readonly Room Room;

		public readonly User User;

		public UserAndRoom(IntPtr o)
		{
			IntPtr intPtr = CAPI.ovr_UserAndRoom_GetRoom(o);
			Room = new Room(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				RoomOptional = null;
			}
			else
			{
				RoomOptional = Room;
			}
			User = new User(CAPI.ovr_UserAndRoom_GetUser(o));
		}
	}
	public class UserAndRoomList : DeserializableList<UserAndRoom>
	{
		public UserAndRoomList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_UserAndRoomArray_GetSize(a);
			_Data = new List<UserAndRoom>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new UserAndRoom(CAPI.ovr_UserAndRoomArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_UserAndRoomArray_GetNextUrl(a);
		}
	}
	public class UserProof
	{
		public readonly string Value;

		public UserProof(IntPtr o)
		{
			Value = CAPI.ovr_UserProof_GetNonce(o);
		}
	}
	public class UserReportID
	{
		public readonly bool DidCancel;

		public readonly ulong ID;

		public UserReportID(IntPtr o)
		{
			DidCancel = CAPI.ovr_UserReportID_GetDidCancel(o);
			ID = CAPI.ovr_UserReportID_GetID(o);
		}
	}
}
namespace ROBERT
{
	public static class BuildTime
	{
		public const string bundleTableName = "BundleTable";
	}
	public abstract class _BundleRef
	{
	}
	public class BundleRef<T> : _BundleRef where T : UnityEngine.Object
	{
		[SerializeField]
		private int dummy;

		public string path;

		public string guid;

		private T cached;

		private bool isCached;

		public T Load()
		{
			if (isCached)
			{
				return cached;
			}
			cached = Runtime.LoadAsset<T>(path);
			if ((bool)cached)
			{
				isCached = true;
			}
			return cached;
		}

		public T TryLoad()
		{
			if (isCached)
			{
				return cached;
			}
			cached = Runtime.LoadAsset<T>(path, logErrorOnFailure: false);
			if ((bool)cached)
			{
				isCached = true;
			}
			return cached;
		}
	}
	public static class Runtime
	{
		public static BundleTable bundleTable;

		private static Dictionary<string, AssetBundle> dynamicBundles = new Dictionary<string, AssetBundle>();

		private static Dictionary<string, AssetBundle> constantBundles = new Dictionary<string, AssetBundle>();

		private static IHaglet loadAllBundles;

		private static UnityEngine.Object asyncLoadedAsset = null;

		private static IHaglet<string, bool, Type> loadAssetAsyncRoutine;

		public static void Initialise()
		{
			Haglet.Create(out loadAssetAsyncRoutine, (Routine.Func3<string, bool, Type>)LoadAssetAsyncRoutine, (string)null, startNow: false, (int?)null, (string)null);
			if (!bundleTable)
			{
				bundleTable = Resources.Load<BundleTable>("BundleTable");
				loadAllBundles = Haglet.Create(out loadAllBundles, _LoadAllBundles);
			}
		}

		public static void UnloadAllBundles()
		{
			AssetBundle.UnloadAllAssetBundles(unloadAllObjects: true);
			dynamicBundles.Clear();
			constantBundles.Clear();
		}

		public static void UnloadDynamicBundles()
		{
			foreach (KeyValuePair<string, AssetBundle> dynamicBundle in dynamicBundles)
			{
				dynamicBundle.Value.Unload(unloadAllLoadedObjects: true);
			}
			dynamicBundles.Clear();
		}

		public static Wait LoadConstantBundle(string bundlePath)
		{
			Haglet.Create(out IHaglet<string, bool> hag, (Routine.Func2<string, bool>)_LoadBundle, (string)null, startNow: false, (int?)null, (string)null);
			hag.Start(bundlePath, arg1: false);
			return Wait.Until.Completed(hag);
		}

		public static Wait LoadDynamicBundle(string bundlePath)
		{
			Haglet.Create(out IHaglet<string, bool> hag, (Routine.Func2<string, bool>)_LoadBundle, (string)null, startNow: false, (int?)null, (string)null);
			hag.Start(bundlePath, arg1: false);
			return Wait.Until.Completed(hag);
		}

		public static Wait LoadAllBundles()
		{
			loadAllBundles.Start();
			return Wait.Until.Completed(loadAllBundles);
		}

		private static IEnumerator<Routine.Yield> _LoadBundle(string bundlePath, bool isDynamicBundle)
		{
			bool bundleInConstantList = constantBundles.ContainsKey(bundlePath);
			bool bundleInDynamicList = dynamicBundles.ContainsKey(bundlePath);
			if ((isDynamicBundle && bundleInConstantList) || (!isDynamicBundle && bundleInDynamicList))
			{
				yield return Wait.For.Updates(1);
			}
			if (!bundleInConstantList && !bundleInDynamicList)
			{
				string path = Path.Combine(UnityEngine.Application.streamingAssetsPath, bundlePath);
				AssetBundleCreateRequest bReq = AssetBundle.LoadFromFileAsync(path);
				yield return Wait.Until.True(() => bReq.isDone);
				if (bReq.assetBundle == null)
				{
					UnityEngine.Debug.LogError("ROBERT: Failed to load bundle '" + bundlePath + "'");
				}
				else if (isDynamicBundle)
				{
					dynamicBundles.Add(bundlePath, bReq.assetBundle);
				}
				else
				{
					constantBundles.Add(bundlePath, bReq.assetBundle);
				}
			}
			else
			{
				yield return Wait.For.Updates(1);
			}
		}

		private static IEnumerator<Routine.Yield> _LoadAllBundles()
		{
			string[] bundlePaths = bundleTable.bundlePaths;
			foreach (string arg in bundlePaths)
			{
				Haglet.Create(out IHaglet<string, bool> hag, (Routine.Func2<string, bool>)_LoadBundle, (string)null, startNow: false, (int?)null, (string)null);
				hag.Start(arg, arg1: false);
				yield return Wait.Until.Completed(hag);
			}
		}

		public static T LoadAsset<T>(string path, bool logErrorOnFailure = true) where T : UnityEngine.Object
		{
			if (!bundleTable)
			{
				return null;
			}
			if (!bundleTable.mapPathToBundle.dict.TryGetValue(path, out var value))
			{
				return null;
			}
			if (!constantBundles.TryGetValue(value, out var value2) && !dynamicBundles.TryGetValue(value, out value2))
			{
				return null;
			}
			UnityEngine.Object @object = value2.LoadAsset(path);
			if (typeof(T).IsTypeOrSubType(typeof(UnityEngine.Component)))
			{
				GameObject gameObject = @object as GameObject;
				if (!gameObject)
				{
					return null;
				}
				return gameObject.GetComponent<T>();
			}
			T val = @object as T;
			if (!val)
			{
				T[] array = value2.LoadAssetWithSubAssets<T>(path);
				if (array.Length != 0)
				{
					return array[0];
				}
			}
			return val;
		}

		public static T GetAsyncLoadedObject<T>() where T : UnityEngine.Object
		{
			return asyncLoadedAsset as T;
		}

		public static Wait LoadAssetAsync<T>(string path, bool logErrorOnFailure)
		{
			return loadAssetAsyncRoutine.Call(path, logErrorOnFailure, typeof(T));
		}

		public static Wait LoadAssetAsync(string path, Type T, bool logErrorOnFailure)
		{
			return loadAssetAsyncRoutine.Call(path, logErrorOnFailure, T);
		}

		private static IEnumerator<Routine.Yield> LoadAssetAsyncRoutine(string path, bool logErrorOnFailure, Type T)
		{
			asyncLoadedAsset = null;
			_ = logErrorOnFailure;
			if (!bundleTable || !bundleTable.mapPathToBundle.dict.TryGetValue(path, out var value) || (!constantBundles.TryGetValue(value, out var bundle) && !dynamicBundles.TryGetValue(value, out bundle)))
			{
				yield break;
			}
			AssetBundleRequest request = bundle.LoadAssetAsync(path);
			yield return Wait.Until.True(() => request.isDone);
			UnityEngine.Object asset = request.asset;
			if (T.IsTypeOrSubType(typeof(UnityEngine.Component)))
			{
				GameObject gameObject = asset as GameObject;
				if ((bool)gameObject)
				{
					asyncLoadedAsset = gameObject.GetComponent(T);
				}
				yield break;
			}
			if (asset.IsOfTypeOrSubType(T))
			{
				AssetBundleRequest requests = bundle.LoadAssetWithSubAssetsAsync(path, T);
				while (!requests.isDone)
				{
					yield return Wait.For.Updates(1);
				}
				UnityEngine.Object[] allAssets = requests.allAssets;
				if (allAssets.Length != 0)
				{
					asyncLoadedAsset = allAssets[0];
					yield break;
				}
			}
			asyncLoadedAsset = asset;
		}

		public static string FindBundleWithAsset(string assetName)
		{
			string text = "";
			foreach (KeyValuePair<string, AssetBundle> constantBundle in constantBundles)
			{
				AssetBundle value = constantBundle.Value;
				if (value.Contains(assetName))
				{
					text = text + value.name + "\n";
				}
			}
			foreach (KeyValuePair<string, AssetBundle> dynamicBundle in dynamicBundles)
			{
				AssetBundle value2 = dynamicBundle.Value;
				if (value2.Contains(assetName))
				{
					text = text + value2.name + "\n";
				}
			}
			return text;
		}

		public static string PrintLoadedBundles()
		{
			string text = "";
			foreach (KeyValuePair<string, AssetBundle> constantBundle in constantBundles)
			{
				AssetBundle value = constantBundle.Value;
				text = text + value.name + " cst\n";
			}
			foreach (KeyValuePair<string, AssetBundle> dynamicBundle in dynamicBundles)
			{
				AssetBundle value2 = dynamicBundle.Value;
				text = ((!(dynamicBundle.Value == null)) ? (text + value2.name + " dyn\n") : (text + "ERROR: " + dynamicBundle.Key + "\n"));
			}
			return text;
		}
	}
	public class BundleTable : ScriptableObject
	{
		[Serializable]
		public class DictStringToString : SerialisableDictionary<string, string>
		{
		}

		[HideInInspector]
		public DictStringToString mapPathToBundle = new DictStringToString();

		[ReadOnly]
		public string[] bundlePaths;
	}
}
namespace Sebastian.Geometry
{
	public static class Maths2D
	{
		public static float PseudoDistanceFromPointToLine(Vector2 a, Vector2 b, Vector2 c)
		{
			return Mathf.Abs((c.x - a.x) * (0f - b.y + a.y) + (c.y - a.y) * (b.x - a.x));
		}

		public static int SideOfLine(Vector2 a, Vector2 b, Vector2 c)
		{
			return (int)Mathf.Sign((c.x - a.x) * (0f - b.y + a.y) + (c.y - a.y) * (b.x - a.x));
		}

		public static int SideOfLine(float ax, float ay, float bx, float by, float cx, float cy)
		{
			return (int)Mathf.Sign((cx - ax) * (0f - by + ay) + (cy - ay) * (bx - ax));
		}

		public static bool PointInTriangle(Vector2 a, Vector2 b, Vector2 c, Vector2 p)
		{
			float num = 0.5f * ((0f - b.y) * c.x + a.y * (0f - b.x + c.x) + a.x * (b.y - c.y) + b.x * c.y);
			float num2 = 1f / (2f * num) * (a.y * c.x - a.x * c.y + (c.y - a.y) * p.x + (a.x - c.x) * p.y);
			float num3 = 1f / (2f * num) * (a.x * b.y - a.y * b.x + (a.y - b.y) * p.x + (b.x - a.x) * p.y);
			if (num2 >= 0f && num3 >= 0f)
			{
				return num2 + num3 <= 1f;
			}
			return false;
		}

		public static bool LineSegmentsIntersect(Vector2 a, Vector2 b, Vector2 c, Vector2 d)
		{
			float num = (b.x - a.x) * (d.y - c.y) - (b.y - a.y) * (d.x - c.x);
			if (Mathf.Approximately(num, 0f))
			{
				return false;
			}
			float num2 = (a.y - c.y) * (d.x - c.x) - (a.x - c.x) * (d.y - c.y);
			float num3 = (a.y - c.y) * (b.x - a.x) - (a.x - c.x) * (b.y - a.y);
			if (Mathf.Approximately(num2, 0f) || Mathf.Approximately(num3, 0f))
			{
				return false;
			}
			float num4 = num2 / num;
			float num5 = num3 / num;
			if (num4 > 0f && num4 < 1f)
			{
				if (num5 > 0f)
				{
					return num5 < 1f;
				}
				return false;
			}
			return false;
		}
	}
	public class Polygon
	{
		public readonly Vector2[] points;

		public readonly int numPoints;

		public readonly int numHullPoints;

		public readonly int[] numPointsPerHole;

		public readonly int numHoles;

		private readonly int[] holeStartIndices;

		public bool isHullReversed;

		public bool[] isHoleReversed;

		public Polygon(Vector2[] hull, Vector2[][] holes)
		{
			numHullPoints = hull.Length;
			numHoles = holes.GetLength(0);
			numPointsPerHole = new int[numHoles];
			holeStartIndices = new int[numHoles];
			isHoleReversed = new bool[numHoles];
			int num = 0;
			for (int i = 0; i < holes.GetLength(0); i++)
			{
				numPointsPerHole[i] = holes[i].Length;
				holeStartIndices[i] = numHullPoints + num;
				num += numPointsPerHole[i];
			}
			numPoints = numHullPoints + num;
			points = new Vector2[numPoints];
			isHullReversed = !PointsAreCounterClockwise(hull);
			for (int j = 0; j < numHullPoints; j++)
			{
				points[j] = hull[isHullReversed ? (numHullPoints - 1 - j) : j];
			}
			for (int k = 0; k < numHoles; k++)
			{
				isHoleReversed[k] = PointsAreCounterClockwise(holes[k]);
				for (int l = 0; l < holes[k].Length; l++)
				{
					points[IndexOfPointInHole(l, k)] = holes[k][isHoleReversed[k] ? (holes[k].Length - l - 1) : l];
				}
			}
		}

		public Polygon(Vector2[] hull)
			: this(hull, new Vector2[0][])
		{
		}

		private bool PointsAreCounterClockwise(Vector2[] testPoints)
		{
			float num = 0f;
			for (int i = 0; i < testPoints.Length; i++)
			{
				int num2 = (i + 1) % testPoints.Length;
				num += (testPoints[num2].x - testPoints[i].x) * (testPoints[num2].y + testPoints[i].y);
			}
			return num < 0f;
		}

		public int IndexOfFirstPointInHole(int holeIndex)
		{
			return holeStartIndices[holeIndex];
		}

		public int IndexOfPointInHole(int index, int holeIndex)
		{
			return holeStartIndices[holeIndex] + index;
		}

		public Vector2 GetHolePoint(int index, int holeIndex)
		{
			return points[holeStartIndices[holeIndex] + index];
		}
	}
	public class Triangulator
	{
		public struct HoleData
		{
			public readonly int holeIndex;

			public readonly int bridgeIndex;

			public readonly Vector2 bridgePoint;

			public HoleData(int holeIndex, int bridgeIndex, Vector2 bridgePoint)
			{
				this.holeIndex = holeIndex;
				this.bridgeIndex = bridgeIndex;
				this.bridgePoint = bridgePoint;
			}
		}

		public class Vertex
		{
			public readonly Vector2 position;

			public readonly int index;

			public bool isConvex;

			public Vertex(Vector2 position, int index, bool isConvex)
			{
				this.position = position;
				this.index = index;
				this.isConvex = isConvex;
			}
		}

		private LinkedList<Vertex> vertsInClippedPolygon;

		private int[] tris;

		private int triIndex;

		public Triangulator(Polygon polygon)
		{
			int num = 2 * polygon.numHoles;
			int num2 = polygon.numPoints + num;
			tris = new int[(num2 - 2) * 3];
			vertsInClippedPolygon = GenerateVertexList(polygon);
		}

		public int[] Triangulate()
		{
			while (vertsInClippedPolygon.Count >= 3)
			{
				bool flag = false;
				LinkedListNode<Vertex> linkedListNode = vertsInClippedPolygon.First;
				for (int i = 0; i < vertsInClippedPolygon.Count; i++)
				{
					LinkedListNode<Vertex> linkedListNode2 = linkedListNode.Previous ?? vertsInClippedPolygon.Last;
					LinkedListNode<Vertex> linkedListNode3 = linkedListNode.Next ?? vertsInClippedPolygon.First;
					if (linkedListNode.Value.isConvex && !TriangleContainsVertex(linkedListNode2.Value, linkedListNode.Value, linkedListNode3.Value))
					{
						if (!linkedListNode2.Value.isConvex)
						{
							LinkedListNode<Vertex> linkedListNode4 = linkedListNode2.Previous ?? vertsInClippedPolygon.Last;
							linkedListNode2.Value.isConvex = IsConvex(linkedListNode4.Value.position, linkedListNode2.Value.position, linkedListNode3.Value.position);
						}
						if (!linkedListNode3.Value.isConvex)
						{
							LinkedListNode<Vertex> linkedListNode5 = linkedListNode3.Next ?? vertsInClippedPolygon.First;
							linkedListNode3.Value.isConvex = IsConvex(linkedListNode2.Value.position, linkedListNode3.Value.position, linkedListNode5.Value.position);
						}
						tris[triIndex * 3 + 2] = linkedListNode2.Value.index;
						tris[triIndex * 3 + 1] = linkedListNode.Value.index;
						tris[triIndex * 3] = linkedListNode3.Value.index;
						triIndex++;
						flag = true;
						vertsInClippedPolygon.Remove(linkedListNode);
						break;
					}
					linkedListNode = linkedListNode3;
				}
				if (!flag)
				{
					UnityEngine.Debug.LogError("Error triangulating mesh. Aborted.");
					return null;
				}
			}
			return tris;
		}

		private LinkedList<Vertex> GenerateVertexList(Polygon polygon)
		{
			LinkedList<Vertex> linkedList = new LinkedList<Vertex>();
			LinkedListNode<Vertex> linkedListNode = null;
			for (int i = 0; i < polygon.numHullPoints; i++)
			{
				int num = (i - 1 + polygon.numHullPoints) % polygon.numHullPoints;
				int num2 = (i + 1) % polygon.numHullPoints;
				bool isConvex = IsConvex(polygon.points[num], polygon.points[i], polygon.points[num2]);
				Vertex value = new Vertex(polygon.points[i], i, isConvex);
				linkedListNode = ((linkedListNode != null) ? linkedList.AddAfter(linkedListNode, value) : linkedList.AddFirst(value));
			}
			List<HoleData> list = new List<HoleData>();
			for (int j = 0; j < polygon.numHoles; j++)
			{
				Vector2 bridgePoint = new Vector2(float.MinValue, 0f);
				int bridgeIndex = 0;
				for (int k = 0; k < polygon.numPointsPerHole[j]; k++)
				{
					if (polygon.GetHolePoint(k, j).x > bridgePoint.x)
					{
						bridgePoint = polygon.GetHolePoint(k, j);
						bridgeIndex = k;
					}
				}
				list.Add(new HoleData(j, bridgeIndex, bridgePoint));
			}
			list.Sort((HoleData x, HoleData y) => (!(x.bridgePoint.x > y.bridgePoint.x)) ? 1 : (-1));
			foreach (HoleData item in list)
			{
				Vector2 b = new Vector2(float.MaxValue, item.bridgePoint.y);
				List<LinkedListNode<Vertex>> list2 = new List<LinkedListNode<Vertex>>();
				LinkedListNode<Vertex> linkedListNode2 = null;
				for (linkedListNode = linkedList.First; linkedListNode != null; linkedListNode = linkedListNode.Next)
				{
					LinkedListNode<Vertex> linkedListNode3 = ((linkedListNode.Next == null) ? linkedList.First : linkedListNode.Next);
					Vector2 position = linkedListNode.Value.position;
					Vector2 position2 = linkedListNode3.Value.position;
					if ((position.x > item.bridgePoint.x || position2.x > item.bridgePoint.x) && position.y > item.bridgePoint.y != position2.y > item.bridgePoint.y)
					{
						float num3 = position2.x;
						if (!Mathf.Approximately(position.x, position2.x))
						{
							float y2 = item.bridgePoint.y;
							float num4 = (position.y - position2.y) / (position.x - position2.x);
							float num5 = position2.y - num4 * position2.x;
							num3 = (y2 - num5) / num4;
						}
						if (num3 > item.bridgePoint.x)
						{
							LinkedListNode<Vertex> linkedListNode4 = ((position.x > position2.x) ? linkedListNode : linkedListNode3);
							bool flag = Mathf.Approximately(num3, b.x);
							bool flag2 = linkedListNode4.Previous != null && item.bridgePoint.y > linkedListNode4.Previous.Value.position.y;
							if ((!flag || flag2) && (num3 < b.x || flag))
							{
								b.x = num3;
								linkedListNode2 = linkedListNode4;
							}
						}
					}
					if (linkedListNode != linkedListNode2 && !linkedListNode.Value.isConvex && position.x > item.bridgePoint.x)
					{
						list2.Add(linkedListNode);
					}
				}
				LinkedListNode<Vertex> linkedListNode5 = linkedListNode2;
				foreach (LinkedListNode<Vertex> item2 in list2)
				{
					if (item2.Value.index != linkedListNode2.Value.index && Maths2D.PointInTriangle(item.bridgePoint, b, linkedListNode2.Value.position, item2.Value.position))
					{
						bool flag3 = linkedListNode5.Value.position == item2.Value.position;
						float num6 = Mathf.Abs(item.bridgePoint.y - linkedListNode5.Value.position.y);
						if (Mathf.Abs(item.bridgePoint.y - item2.Value.position.y) < num6 || flag3)
						{
							linkedListNode5 = item2;
						}
					}
				}
				linkedListNode = linkedListNode5;
				for (int l = item.bridgeIndex; l <= polygon.numPointsPerHole[item.holeIndex] + item.bridgeIndex; l++)
				{
					int index = linkedListNode.Value.index;
					int num7 = polygon.IndexOfPointInHole(l % polygon.numPointsPerHole[item.holeIndex], item.holeIndex);
					int num8 = polygon.IndexOfPointInHole((l + 1) % polygon.numPointsPerHole[item.holeIndex], item.holeIndex);
					if (l == polygon.numPointsPerHole[item.holeIndex] + item.bridgeIndex)
					{
						num8 = linkedListNode5.Value.index;
					}
					bool isConvex2 = IsConvex(polygon.points[index], polygon.points[num7], polygon.points[num8]);
					Vertex value2 = new Vertex(polygon.points[num7], num7, isConvex2);
					linkedListNode = linkedList.AddAfter(linkedListNode, value2);
				}
				Vector2 v = ((linkedListNode.Next == null) ? linkedList.First.Value.position : linkedListNode.Next.Value.position);
				bool isConvex3 = IsConvex(item.bridgePoint, linkedListNode5.Value.position, v);
				Vertex value3 = new Vertex(linkedListNode5.Value.position, linkedListNode5.Value.index, isConvex3);
				linkedList.AddAfter(linkedListNode, value3);
				LinkedListNode<Vertex> linkedListNode6 = ((linkedListNode5.Previous == null) ? linkedList.Last : linkedListNode5.Previous);
				LinkedListNode<Vertex> linkedListNode7 = ((linkedListNode5.Next == null) ? linkedList.First : linkedListNode5.Next);
				linkedListNode5.Value.isConvex = IsConvex(linkedListNode6.Value.position, linkedListNode5.Value.position, linkedListNode7.Value.position);
			}
			return linkedList;
		}

		private bool TriangleContainsVertex(Vertex v0, Vertex v1, Vertex v2)
		{
			LinkedListNode<Vertex> linkedListNode = vertsInClippedPolygon.First;
			for (int i = 0; i < vertsInClippedPolygon.Count; i++)
			{
				if (!linkedListNode.Value.isConvex)
				{
					Vertex value = linkedListNode.Value;
					if (value.index != v0.index && value.index != v1.index && value.index != v2.index && Maths2D.PointInTriangle(v0.position, v1.position, v2.position, value.position))
					{
						return true;
					}
				}
				linkedListNode = linkedListNode.Next;
			}
			return false;
		}

		private bool IsConvex(Vector2 v0, Vector2 v1, Vector2 v2)
		{
			return Maths2D.SideOfLine(v0, v2, v1) == -1;
		}
	}
}
namespace FMOD
{
	public class VERSION
	{
		public const int number = 69637;

		public const string dll = "fmod";
	}
	public class CONSTANTS
	{
		public const int MAX_CHANNEL_WIDTH = 32;

		public const int MAX_LISTENERS = 8;

		public const int REVERB_MAXINSTANCES = 4;

		public const int MAX_SYSTEMS = 8;
	}
	public enum RESULT
	{
		OK,
		ERR_BADCOMMAND,
		ERR_CHANNEL_ALLOC,
		ERR_CHANNEL_STOLEN,
		ERR_DMA,
		ERR_DSP_CONNECTION,
		ERR_DSP_DONTPROCESS,
		ERR_DSP_FORMAT,
		ERR_DSP_INUSE,
		ERR_DSP_NOTFOUND,
		ERR_DSP_RESERVED,
		ERR_DSP_SILENCE,
		ERR_DSP_TYPE,
		ERR_FILE_BAD,
		ERR_FILE_COULDNOTSEEK,
		ERR_FILE_DISKEJECTED,
		ERR_FILE_EOF,
		ERR_FILE_ENDOFDATA,
		ERR_FILE_NOTFOUND,
		ERR_FORMAT,
		ERR_HEADER_MISMATCH,
		ERR_HTTP,
		ERR_HTTP_ACCESS,
		ERR_HTTP_PROXY_AUTH,
		ERR_HTTP_SERVER_ERROR,
		ERR_HTTP_TIMEOUT,
		ERR_INITIALIZATION,
		ERR_INITIALIZED,
		ERR_INTERNAL,
		ERR_INVALID_FLOAT,
		ERR_INVALID_HANDLE,
		ERR_INVALID_PARAM,
		ERR_INVALID_POSITION,
		ERR_INVALID_SPEAKER,
		ERR_INVALID_SYNCPOINT,
		ERR_INVALID_THREAD,
		ERR_INVALID_VECTOR,
		ERR_MAXAUDIBLE,
		ERR_MEMORY,
		ERR_MEMORY_CANTPOINT,
		ERR_NEEDS3D,
		ERR_NEEDSHARDWARE,
		ERR_NET_CONNECT,
		ERR_NET_SOCKET_ERROR,
		ERR_NET_URL,
		ERR_NET_WOULD_BLOCK,
		ERR_NOTREADY,
		ERR_OUTPUT_ALLOCATED,
		ERR_OUTPUT_CREATEBUFFER,
		ERR_OUTPUT_DRIVERCALL,
		ERR_OUTPUT_FORMAT,
		ERR_OUTPUT_INIT,
		ERR_OUTPUT_NODRIVERS,
		ERR_PLUGIN,
		ERR_PLUGIN_MISSING,
		ERR_PLUGIN_RESOURCE,
		ERR_PLUGIN_VERSION,
		ERR_RECORD,
		ERR_REVERB_CHANNELGROUP,
		ERR_REVERB_INSTANCE,
		ERR_SUBSOUNDS,
		ERR_SUBSOUND_ALLOCATED,
		ERR_SUBSOUND_CANTMOVE,
		ERR_TAGNOTFOUND,
		ERR_TOOMANYCHANNELS,
		ERR_TRUNCATED,
		ERR_UNIMPLEMENTED,
		ERR_UNINITIALIZED,
		ERR_UNSUPPORTED,
		ERR_VERSION,
		ERR_EVENT_ALREADY_LOADED,
		ERR_EVENT_LIVEUPDATE_BUSY,
		ERR_EVENT_LIVEUPDATE_MISMATCH,
		ERR_EVENT_LIVEUPDATE_TIMEOUT,
		ERR_EVENT_NOTFOUND,
		ERR_STUDIO_UNINITIALIZED,
		ERR_STUDIO_NOT_LOADED,
		ERR_INVALID_STRING,
		ERR_ALREADY_LOCKED,
		ERR_NOT_LOCKED,
		ERR_RECORD_DISCONNECTED,
		ERR_TOOMANYSAMPLES
	}
	public enum CHANNELCONTROL_TYPE
	{
		CHANNEL,
		CHANNELGROUP
	}
	public struct VECTOR
	{
		public float x;

		public float y;

		public float z;
	}
	public struct ATTRIBUTES_3D
	{
		public VECTOR position;

		public VECTOR velocity;

		public VECTOR forward;

		public VECTOR up;
	}
	public struct ASYNCREADINFO
	{
		public IntPtr handle;

		public uint offset;

		public uint sizebytes;

		public int priority;

		public IntPtr userdata;

		public IntPtr buffer;

		public uint bytesread;

		public ASYNCREADINFO_DONE_CALLBACK done;
	}
	public enum OUTPUTTYPE
	{
		AUTODETECT,
		UNKNOWN,
		NOSOUND,
		WAVWRITER,
		NOSOUND_NRT,
		WAVWRITER_NRT,
		DSOUND,
		WINMM,
		WASAPI,
		ASIO,
		PULSEAUDIO,
		ALSA,
		COREAUDIO,
		XAUDIO,
		PS3,
		AUDIOTRACK,
		OPENSL,
		WIIU,
		AUDIOOUT,
		AUDIO3D,
		ATMOS,
		WEBAUDIO,
		NNAUDIO,
		WINSONIC,
		MAX
	}
	public enum DEBUG_MODE
	{
		TTY,
		FILE,
		CALLBACK
	}
	[Flags]
	public enum DEBUG_FLAGS : uint
	{
		NONE = 0u,
		ERROR = 1u,
		WARNING = 2u,
		LOG = 4u,
		TYPE_MEMORY = 0x100u,
		TYPE_FILE = 0x200u,
		TYPE_CODEC = 0x400u,
		TYPE_TRACE = 0x800u,
		DISPLAY_TIMESTAMPS = 0x10000u,
		DISPLAY_LINENUMBERS = 0x20000u,
		DISPLAY_THREAD = 0x40000u
	}
	[Flags]
	public enum MEMORY_TYPE : uint
	{
		NORMAL = 0u,
		STREAM_FILE = 1u,
		STREAM_DECODE = 2u,
		SAMPLEDATA = 4u,
		DSP_BUFFER = 8u,
		PLUGIN = 0x10u,
		XBOX360_PHYSICAL = 0x100000u,
		PERSISTENT = 0x200000u,
		SECONDARY = 0x400000u,
		ALL = uint.MaxValue
	}
	public enum SPEAKERMODE
	{
		DEFAULT,
		RAW,
		MONO,
		STEREO,
		QUAD,
		SURROUND,
		_5POINT1,
		_7POINT1,
		_7POINT1POINT4,
		MAX
	}
	public enum SPEAKER
	{
		FRONT_LEFT,
		FRONT_RIGHT,
		FRONT_CENTER,
		LOW_FREQUENCY,
		SURROUND_LEFT,
		SURROUND_RIGHT,
		BACK_LEFT,
		BACK_RIGHT,
		TOP_FRONT_LEFT,
		TOP_FRONT_RIGHT,
		TOP_BACK_LEFT,
		TOP_BACK_RIGHT,
		MAX
	}
	[Flags]
	public enum CHANNELMASK : uint
	{
		FRONT_LEFT = 1u,
		FRONT_RIGHT = 2u,
		FRONT_CENTER = 4u,
		LOW_FREQUENCY = 8u,
		SURROUND_LEFT = 0x10u,
		SURROUND_RIGHT = 0x20u,
		BACK_LEFT = 0x40u,
		BACK_RIGHT = 0x80u,
		BACK_CENTER = 0x100u,
		MONO = 1u,
		STEREO = 3u,
		LRC = 7u,
		QUAD = 0x33u,
		SURROUND = 0x37u,
		_5POINT1 = 0x3Fu,
		_5POINT1_REARS = 0xCFu,
		_7POINT0 = 0xF7u,
		_7POINT1 = 0xFFu
	}
	public enum CHANNELORDER
	{
		DEFAULT,
		WAVEFORMAT,
		PROTOOLS,
		ALLMONO,
		ALLSTEREO,
		ALSA,
		MAX
	}
	public enum PLUGINTYPE
	{
		OUTPUT,
		CODEC,
		DSP,
		MAX
	}
	public struct PLUGINLIST
	{
		private PLUGINTYPE type;

		private IntPtr description;
	}
	[Flags]
	public enum INITFLAGS : uint
	{
		NORMAL = 0u,
		STREAM_FROM_UPDATE = 1u,
		MIX_FROM_UPDATE = 2u,
		_3D_RIGHTHANDED = 4u,
		CHANNEL_LOWPASS = 0x100u,
		CHANNEL_DISTANCEFILTER = 0x200u,
		PROFILE_ENABLE = 0x10000u,
		VOL0_BECOMES_VIRTUAL = 0x20000u,
		GEOMETRY_USECLOSEST = 0x40000u,
		PREFER_DOLBY_DOWNMIX = 0x80000u,
		THREAD_UNSAFE = 0x100000u,
		PROFILE_METER_ALL = 0x200000u,
		DISABLE_SRS_HIGHPASSFILTER = 0x400000u
	}
	public enum SOUND_TYPE
	{
		UNKNOWN,
		AIFF,
		ASF,
		DLS,
		FLAC,
		FSB,
		IT,
		MIDI,
		MOD,
		MPEG,
		OGGVORBIS,
		PLAYLIST,
		RAW,
		S3M,
		USER,
		WAV,
		XM,
		XMA,
		AUDIOQUEUE,
		AT9,
		VORBIS,
		MEDIA_FOUNDATION,
		MEDIACODEC,
		FADPCM,
		MAX
	}
	public enum SOUND_FORMAT
	{
		NONE,
		PCM8,
		PCM16,
		PCM24,
		PCM32,
		PCMFLOAT,
		BITSTREAM,
		MAX
	}
	[Flags]
	public enum MODE : uint
	{
		DEFAULT = 0u,
		LOOP_OFF = 1u,
		LOOP_NORMAL = 2u,
		LOOP_BIDI = 4u,
		_2D = 8u,
		_3D = 0x10u,
		CREATESTREAM = 0x80u,
		CREATESAMPLE = 0x100u,
		CREATECOMPRESSEDSAMPLE = 0x200u,
		OPENUSER = 0x400u,
		OPENMEMORY = 0x800u,
		OPENMEMORY_POINT = 0x10000000u,
		OPENRAW = 0x1000u,
		OPENONLY = 0x2000u,
		ACCURATETIME = 0x4000u,
		MPEGSEARCH = 0x8000u,
		NONBLOCKING = 0x10000u,
		UNIQUE = 0x20000u,
		_3D_HEADRELATIVE = 0x40000u,
		_3D_WORLDRELATIVE = 0x80000u,
		_3D_INVERSEROLLOFF = 0x100000u,
		_3D_LINEARROLLOFF = 0x200000u,
		_3D_LINEARSQUAREROLLOFF = 0x400000u,
		_3D_INVERSETAPEREDROLLOFF = 0x800000u,
		_3D_CUSTOMROLLOFF = 0x4000000u,
		_3D_IGNOREGEOMETRY = 0x40000000u,
		IGNORETAGS = 0x2000000u,
		LOWMEM = 0x8000000u,
		LOADSECONDARYRAM = 0x20000000u,
		VIRTUAL_PLAYFROMSTART = 0x80000000u
	}
	public enum OPENSTATE
	{
		READY,
		LOADING,
		ERROR,
		CONNECTING,
		BUFFERING,
		SEEKING,
		PLAYING,
		SETPOSITION,
		MAX
	}
	public enum SOUNDGROUP_BEHAVIOR
	{
		BEHAVIOR_FAIL,
		BEHAVIOR_MUTE,
		BEHAVIOR_STEALLOWEST,
		MAX
	}
	public enum CHANNELCONTROL_CALLBACK_TYPE
	{
		END,
		VIRTUALVOICE,
		SYNCPOINT,
		OCCLUSION,
		MAX
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct CHANNELCONTROL_DSP_INDEX
	{
		public const int HEAD = -1;

		public const int FADER = -2;

		public const int TAIL = -3;
	}
	public enum ERRORCALLBACK_INSTANCETYPE
	{
		NONE,
		SYSTEM,
		CHANNEL,
		CHANNELGROUP,
		CHANNELCONTROL,
		SOUND,
		SOUNDGROUP,
		DSP,
		DSPCONNECTION,
		GEOMETRY,
		REVERB3D,
		STUDIO_SYSTEM,
		STUDIO_EVENTDESCRIPTION,
		STUDIO_EVENTINSTANCE,
		STUDIO_PARAMETERINSTANCE,
		STUDIO_BUS,
		STUDIO_VCA,
		STUDIO_BANK,
		STUDIO_COMMANDREPLAY
	}
	public struct ERRORCALLBACK_INFO
	{
		public RESULT result;

		public ERRORCALLBACK_INSTANCETYPE instancetype;

		public IntPtr instance;

		public StringWrapper functionname;

		public StringWrapper functionparams;
	}
	[Flags]
	public enum SYSTEM_CALLBACK_TYPE : uint
	{
		DEVICELISTCHANGED = 1u,
		DEVICELOST = 2u,
		MEMORYALLOCATIONFAILED = 4u,
		THREADCREATED = 8u,
		BADDSPCONNECTION = 0x10u,
		PREMIX = 0x20u,
		POSTMIX = 0x40u,
		ERROR = 0x80u,
		MIDMIX = 0x100u,
		THREADDESTROYED = 0x200u,
		PREUPDATE = 0x400u,
		POSTUPDATE = 0x800u,
		RECORDLISTCHANGED = 0x1000u,
		ALL = uint.MaxValue
	}
	public delegate RESULT ASYNCREADINFO_DONE_CALLBACK(IntPtr info, RESULT result);
	public delegate RESULT DEBUG_CALLBACK(DEBUG_FLAGS flags, StringWrapper file, int line, StringWrapper func, StringWrapper message);
	public delegate RESULT SYSTEM_CALLBACK(IntPtr systemraw, SYSTEM_CALLBACK_TYPE type, IntPtr commanddata1, IntPtr commanddata2, IntPtr userdata);
	public delegate RESULT CHANNEL_CALLBACK(IntPtr channelraw, CHANNELCONTROL_TYPE controltype, CHANNELCONTROL_CALLBACK_TYPE type, IntPtr commanddata1, IntPtr commanddata2);
	public delegate RESULT SOUND_NONBLOCKCALLBACK(IntPtr soundraw, RESULT result);
	public delegate RESULT SOUND_PCMREADCALLBACK(IntPtr soundraw, IntPtr data, uint datalen);
	public delegate RESULT SOUND_PCMSETPOSCALLBACK(IntPtr soundraw, int subsound, uint position, TIMEUNIT postype);
	public delegate RESULT FILE_OPENCALLBACK(StringWrapper name, ref uint filesize, ref IntPtr handle, IntPtr userdata);
	public delegate RESULT FILE_CLOSECALLBACK(IntPtr handle, IntPtr userdata);
	public delegate RESULT FILE_READCALLBACK(IntPtr handle, IntPtr buffer, uint sizebytes, ref uint bytesread, IntPtr userdata);
	public delegate RESULT FILE_SEEKCALLBACK(IntPtr handle, uint pos, IntPtr userdata);
	public delegate RESULT FILE_ASYNCREADCALLBACK(IntPtr handle, IntPtr info, IntPtr userdata);
	public delegate RESULT FILE_ASYNCCANCELCALLBACK(IntPtr handle, IntPtr userdata);
	public delegate IntPtr MEMORY_ALLOC_CALLBACK(uint size, MEMORY_TYPE type, StringWrapper sourcestr);
	public delegate IntPtr MEMORY_REALLOC_CALLBACK(IntPtr ptr, uint size, MEMORY_TYPE type, StringWrapper sourcestr);
	public delegate void MEMORY_FREE_CALLBACK(IntPtr ptr, MEMORY_TYPE type, StringWrapper sourcestr);
	public delegate float CB_3D_ROLLOFFCALLBACK(IntPtr channelraw, float distance);
	public enum DSP_RESAMPLER
	{
		DEFAULT,
		NOINTERP,
		LINEAR,
		CUBIC,
		SPLINE,
		MAX
	}
	public enum DSPCONNECTION_TYPE
	{
		STANDARD,
		SIDECHAIN,
		SEND,
		SEND_SIDECHAIN,
		MAX
	}
	public enum TAGTYPE
	{
		UNKNOWN,
		ID3V1,
		ID3V2,
		VORBISCOMMENT,
		SHOUTCAST,
		ICECAST,
		ASF,
		MIDI,
		PLAYLIST,
		FMOD,
		USER,
		MAX
	}
	public enum TAGDATATYPE
	{
		BINARY,
		INT,
		FLOAT,
		STRING,
		STRING_UTF16,
		STRING_UTF16BE,
		STRING_UTF8,
		CDTOC,
		MAX
	}
	public struct TAG
	{
		public TAGTYPE type;

		public TAGDATATYPE datatype;

		public StringWrapper name;

		public IntPtr data;

		public uint datalen;

		public bool updated;
	}
	[Flags]
	public enum TIMEUNIT : uint
	{
		MS = 1u,
		PCM = 2u,
		PCMBYTES = 4u,
		RAWBYTES = 8u,
		PCMFRACTION = 0x10u,
		MODORDER = 0x100u,
		MODROW = 0x200u,
		MODPATTERN = 0x400u
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct PORT_INDEX
	{
		public const ulong NONE = ulong.MaxValue;
	}
	public struct CREATESOUNDEXINFO
	{
		public int cbsize;

		public uint length;

		public uint fileoffset;

		public int numchannels;

		public int defaultfrequency;

		public SOUND_FORMAT format;

		public uint decodebuffersize;

		public int initialsubsound;

		public int numsubsounds;

		public IntPtr inclusionlist;

		public int inclusionlistnum;

		public IntPtr pcmreadcallback_handle;

		public IntPtr pcmsetposcallback_handle;

		public IntPtr nonblockcallback_handle;

		public IntPtr dlsname;

		public IntPtr encryptionkey;

		public int maxpolyphony;

		public IntPtr userdata;

		public SOUND_TYPE suggestedsoundtype;

		public IntPtr fileuseropen_handle;

		public IntPtr fileuserclose_handle;

		public IntPtr fileuserread_handle;

		public IntPtr fileuserseek_handle;

		public IntPtr fileuserasyncread_handle;

		public IntPtr fileuserasynccancel_handle;

		public IntPtr fileuserdata;

		public int filebuffersize;

		public CHANNELORDER channelorder;

		public CHANNELMASK channelmask;

		public IntPtr initialsoundgroup;

		public uint initialseekposition;

		public TIMEUNIT initialseekpostype;

		public int ignoresetfilesystem;

		public uint audioqueuepolicy;

		public uint minmidigranularity;

		public int nonblockthreadid;

		public IntPtr fsbguid;

		public SOUND_PCMREADCALLBACK pcmreadcallback
		{
			set
			{
				pcmreadcallback_handle = ((value == null) ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value));
			}
		}

		public SOUND_PCMSETPOSCALLBACK pcmsetposcallback
		{
			set
			{
				pcmsetposcallback_handle = ((value == null) ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value));
			}
		}

		public SOUND_NONBLOCKCALLBACK nonblockcallback
		{
			set
			{
				nonblockcallback_handle = ((value == null) ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value));
			}
		}

		public FILE_OPENCALLBACK fileuseropen
		{
			set
			{
				fileuseropen_handle = ((value == null) ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value));
			}
		}

		public FILE_CLOSECALLBACK fileuserclose
		{
			set
			{
				fileuserclose_handle = ((value == null) ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value));
			}
		}

		public FILE_READCALLBACK fileuserread
		{
			set
			{
				fileuserread_handle = ((value == null) ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value));
			}
		}

		public FILE_SEEKCALLBACK fileuserseek
		{
			set
			{
				fileuserseek_handle = ((value == null) ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value));
			}
		}

		public FILE_ASYNCREADCALLBACK fileuserasyncread
		{
			set
			{
				fileuserasyncread_handle = ((value == null) ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value));
			}
		}

		public FILE_ASYNCCANCELCALLBACK fileuserasynccancel
		{
			set
			{
				fileuserasynccancel_handle = ((value == null) ? IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value));
			}
		}
	}
	public struct REVERB_PROPERTIES
	{
		public float DecayTime;

		public float EarlyDelay;

		public float LateDelay;

		public float HFReference;

		public float HFDecayRatio;

		public float Diffusion;

		public float Density;

		public float LowShelfFrequency;

		public float LowShelfGain;

		public float HighCut;

		public float EarlyLateMix;

		public float WetLevel;

		public REVERB_PROPERTIES(float decayTime, float earlyDelay, float lateDelay, float hfReference, float hfDecayRatio, float diffusion, float density, float lowShelfFrequency, float lowShelfGain, float highCut, float earlyLateMix, float wetLevel)
		{
			DecayTime = decayTime;
			EarlyDelay = earlyDelay;
			LateDelay = lateDelay;
			HFReference = hfReference;
			HFDecayRatio = hfDecayRatio;
			Diffusion = diffusion;
			Density = density;
			LowShelfFrequency = lowShelfFrequency;
			LowShelfGain = lowShelfGain;
			HighCut = highCut;
			EarlyLateMix = earlyLateMix;
			WetLevel = wetLevel;
		}
	}
	public class PRESET
	{
		public static REVERB_PROPERTIES OFF()
		{
			return new REVERB_PROPERTIES(1000f, 7f, 11f, 5000f, 100f, 100f, 100f, 250f, 0f, 20f, 96f, -80f);
		}

		public static REVERB_PROPERTIES GENERIC()
		{
			return new REVERB_PROPERTIES(1500f, 7f, 11f, 5000f, 83f, 100f, 100f, 250f, 0f, 14500f, 96f, -8f);
		}

		public static REVERB_PROPERTIES PADDEDCELL()
		{
			return new REVERB_PROPERTIES(170f, 1f, 2f, 5000f, 10f, 100f, 100f, 250f, 0f, 160f, 84f, -7.8f);
		}

		public static REVERB_PROPERTIES ROOM()
		{
			return new REVERB_PROPERTIES(400f, 2f, 3f, 5000f, 83f, 100f, 100f, 250f, 0f, 6050f, 88f, -9.4f);
		}

		public static REVERB_PROPERTIES BATHROOM()
		{
			return new REVERB_PROPERTIES(1500f, 7f, 11f, 5000f, 54f, 100f, 60f, 250f, 0f, 2900f, 83f, 0.5f);
		}

		public static REVERB_PROPERTIES LIVINGROOM()
		{
			return new REVERB_PROPERTIES(500f, 3f, 4f, 5000f, 10f, 100f, 100f, 250f, 0f, 160f, 58f, -19f);
		}

		public static REVERB_PROPERTIES STONEROOM()
		{
			return new REVERB_PROPERTIES(2300f, 12f, 17f, 5000f, 64f, 100f, 100f, 250f, 0f, 7800f, 71f, -8.5f);
		}

		public static REVERB_PROPERTIES AUDITORIUM()
		{
			return new REVERB_PROPERTIES(4300f, 20f, 30f, 5000f, 59f, 100f, 100f, 250f, 0f, 5850f, 64f, -11.7f);
		}

		public static REVERB_PROPERTIES CONCERTHALL()
		{
			return new REVERB_PROPERTIES(3900f, 20f, 29f, 5000f, 70f, 100f, 100f, 250f, 0f, 5650f, 80f, -9.8f);
		}

		public static REVERB_PROPERTIES CAVE()
		{
			return new REVERB_PROPERTIES(2900f, 15f, 22f, 5000f, 100f, 100f, 100f, 250f, 0f, 20000f, 59f, -11.3f);
		}

		public static REVERB_PROPERTIES ARENA()
		{
			return new REVERB_PROPERTIES(7200f, 20f, 30f, 5000f, 33f, 100f, 100f, 250f, 0f, 4500f, 80f, -9.6f);
		}

		public static REVERB_PROPERTIES HANGAR()
		{
			return new REVERB_PROPERTIES(10000f, 20f, 30f, 5000f, 23f, 100f, 100f, 250f, 0f, 3400f, 72f, -7.4f);
		}

		public static REVERB_PROPERTIES CARPETTEDHALLWAY()
		{
			return new REVERB_PROPERTIES(300f, 2f, 30f, 5000f, 10f, 100f, 100f, 250f, 0f, 500f, 56f, -24f);
		}

		public static REVERB_PROPERTIES HALLWAY()
		{
			return new REVERB_PROPERTIES(1500f, 7f, 11f, 5000f, 59f, 100f, 100f, 250f, 0f, 7800f, 87f, -5.5f);
		}

		public static REVERB_PROPERTIES STONECORRIDOR()
		{
			return new REVERB_PROPERTIES(270f, 13f, 20f, 5000f, 79f, 100f, 100f, 250f, 0f, 9000f, 86f, -6f);
		}

		public static REVERB_PROPERTIES ALLEY()
		{
			return new REVERB_PROPERTIES(1500f, 7f, 11f, 5000f, 86f, 100f, 100f, 250f, 0f, 8300f, 80f, -9.8f);
		}

		public static REVERB_PROPERTIES FOREST()
		{
			return new REVERB_PROPERTIES(1500f, 162f, 88f, 5000f, 54f, 79f, 100f, 250f, 0f, 760f, 94f, -12.3f);
		}

		public static REVERB_PROPERTIES CITY()
		{
			return new REVERB_PROPERTIES(1500f, 7f, 11f, 5000f, 67f, 50f, 100f, 250f, 0f, 4050f, 66f, -26f);
		}

		public static REVERB_PROPERTIES MOUNTAINS()
		{
			return new REVERB_PROPERTIES(1500f, 300f, 100f, 5000f, 21f, 27f, 100f, 250f, 0f, 1220f, 82f, -24f);
		}

		public static REVERB_PROPERTIES QUARRY()
		{
			return new REVERB_PROPERTIES(1500f, 61f, 25f, 5000f, 83f, 100f, 100f, 250f, 0f, 3400f, 100f, -5f);
		}

		public static REVERB_PROPERTIES PLAIN()
		{
			return new REVERB_PROPERTIES(1500f, 179f, 100f, 5000f, 50f, 21f, 100f, 250f, 0f, 1670f, 65f, -28f);
		}

		public static REVERB_PROPERTIES PARKINGLOT()
		{
			return new REVERB_PROPERTIES(1700f, 8f, 12f, 5000f, 100f, 100f, 100f, 250f, 0f, 20000f, 56f, -19.5f);
		}

		public static REVERB_PROPERTIES SEWERPIPE()
		{
			return new REVERB_PROPERTIES(2800f, 14f, 21f, 5000f, 14f, 80f, 60f, 250f, 0f, 3400f, 66f, 1.2f);
		}

		public static REVERB_PROPERTIES UNDERWATER()
		{
			return new REVERB_PROPERTIES(1500f, 7f, 11f, 5000f, 10f, 100f, 100f, 250f, 0f, 500f, 92f, 7f);
		}
	}
	public struct ADVANCEDSETTINGS
	{
		public int cbSize;

		public int maxMPEGCodecs;

		public int maxADPCMCodecs;

		public int maxXMACodecs;

		public int maxVorbisCodecs;

		public int maxAT9Codecs;

		public int maxFADPCMCodecs;

		public int maxPCMCodecs;

		public int ASIONumChannels;

		public IntPtr ASIOChannelList;

		public IntPtr ASIOSpeakerList;

		public float HRTFMinAngle;

		public float HRTFMaxAngle;

		public float HRTFFreq;

		public float vol0virtualvol;

		public uint defaultDecodeBufferSize;

		public ushort profilePort;

		public uint geometryMaxFadeTime;

		public float distanceFilterCenterFreq;

		public int reverb3Dinstance;

		public int DSPBufferPoolSize;

		public uint stackSizeStream;

		public uint stackSizeNonBlocking;

		public uint stackSizeMixer;

		public DSP_RESAMPLER resamplerMethod;

		public uint commandQueueSize;

		public uint randomSeed;
	}
	[Flags]
	public enum DRIVER_STATE : uint
	{
		CONNECTED = 1u,
		DEFAULT = 2u
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct Factory
	{
		public static RESULT System_Create(out System system)
		{
			return FMOD5_System_Create(out system.handle);
		}

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_Create(out IntPtr system);
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct Memory
	{
		public static RESULT Initialize(IntPtr poolmem, int poollen, MEMORY_ALLOC_CALLBACK useralloc, MEMORY_REALLOC_CALLBACK userrealloc, MEMORY_FREE_CALLBACK userfree, MEMORY_TYPE memtypeflags)
		{
			return FMOD5_Memory_Initialize(poolmem, poollen, useralloc, userrealloc, userfree, memtypeflags);
		}

		public static RESULT GetStats(out int currentalloced, out int maxalloced)
		{
			return GetStats(out currentalloced, out maxalloced, blocking: false);
		}

		public static RESULT GetStats(out int currentalloced, out int maxalloced, bool blocking)
		{
			return FMOD5_Memory_GetStats(out currentalloced, out maxalloced, blocking);
		}

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Memory_Initialize(IntPtr poolmem, int poollen, MEMORY_ALLOC_CALLBACK useralloc, MEMORY_REALLOC_CALLBACK userrealloc, MEMORY_FREE_CALLBACK userfree, MEMORY_TYPE memtypeflags);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Memory_GetStats(out int currentalloced, out int maxalloced, bool blocking);
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct Debug
	{
		public static RESULT Initialize(DEBUG_FLAGS flags, DEBUG_MODE mode, DEBUG_CALLBACK callback, string filename)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD5_Debug_Initialize(flags, mode, callback, threadSafeEncoding.byteFromStringUTF8(filename));
		}

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Debug_Initialize(DEBUG_FLAGS flags, DEBUG_MODE mode, DEBUG_CALLBACK callback, byte[] filename);
	}
	public struct System
	{
		public IntPtr handle;

		public RESULT release()
		{
			return FMOD5_System_Release(handle);
		}

		public RESULT setOutput(OUTPUTTYPE output)
		{
			return FMOD5_System_SetOutput(handle, output);
		}

		public RESULT getOutput(out OUTPUTTYPE output)
		{
			return FMOD5_System_GetOutput(handle, out output);
		}

		public RESULT getNumDrivers(out int numdrivers)
		{
			return FMOD5_System_GetNumDrivers(handle, out numdrivers);
		}

		public RESULT getDriverInfo(int id, out string name, int namelen, out Guid guid, out int systemrate, out SPEAKERMODE speakermode, out int speakermodechannels)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(namelen);
			RESULT result = FMOD5_System_GetDriverInfo(handle, id, intPtr, namelen, out guid, out systemrate, out speakermode, out speakermodechannels);
			using (StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper())
			{
				name = threadSafeEncoding.stringFromNative(intPtr);
			}
			Marshal.FreeHGlobal(intPtr);
			return result;
		}

		public RESULT getDriverInfo(int id, out Guid guid, out int systemrate, out SPEAKERMODE speakermode, out int speakermodechannels)
		{
			return FMOD5_System_GetDriverInfo(handle, id, IntPtr.Zero, 0, out guid, out systemrate, out speakermode, out speakermodechannels);
		}

		public RESULT setDriver(int driver)
		{
			return FMOD5_System_SetDriver(handle, driver);
		}

		public RESULT getDriver(out int driver)
		{
			return FMOD5_System_GetDriver(handle, out driver);
		}

		public RESULT setSoftwareChannels(int numsoftwarechannels)
		{
			return FMOD5_System_SetSoftwareChannels(handle, numsoftwarechannels);
		}

		public RESULT getSoftwareChannels(out int numsoftwarechannels)
		{
			return FMOD5_System_GetSoftwareChannels(handle, out numsoftwarechannels);
		}

		public RESULT setSoftwareFormat(int samplerate, SPEAKERMODE speakermode, int numrawspeakers)
		{
			return FMOD5_System_SetSoftwareFormat(handle, samplerate, speakermode, numrawspeakers);
		}

		public RESULT getSoftwareFormat(out int samplerate, out SPEAKERMODE speakermode, out int numrawspeakers)
		{
			return FMOD5_System_GetSoftwareFormat(handle, out samplerate, out speakermode, out numrawspeakers);
		}

		public RESULT setDSPBufferSize(uint bufferlength, int numbuffers)
		{
			return FMOD5_System_SetDSPBufferSize(handle, bufferlength, numbuffers);
		}

		public RESULT getDSPBufferSize(out uint bufferlength, out int numbuffers)
		{
			return FMOD5_System_GetDSPBufferSize(handle, out bufferlength, out numbuffers);
		}

		public RESULT setFileSystem(FILE_OPENCALLBACK useropen, FILE_CLOSECALLBACK userclose, FILE_READCALLBACK userread, FILE_SEEKCALLBACK userseek, FILE_ASYNCREADCALLBACK userasyncread, FILE_ASYNCCANCELCALLBACK userasynccancel, int blockalign)
		{
			return FMOD5_System_SetFileSystem(handle, useropen, userclose, userread, userseek, userasyncread, userasynccancel, blockalign);
		}

		public RESULT attachFileSystem(FILE_OPENCALLBACK useropen, FILE_CLOSECALLBACK userclose, FILE_READCALLBACK userread, FILE_SEEKCALLBACK userseek)
		{
			return FMOD5_System_AttachFileSystem(handle, useropen, userclose, userread, userseek);
		}

		public RESULT setAdvancedSettings(ref ADVANCEDSETTINGS settings)
		{
			settings.cbSize = Marshal.SizeOf(settings);
			return FMOD5_System_SetAdvancedSettings(handle, ref settings);
		}

		public RESULT getAdvancedSettings(ref ADVANCEDSETTINGS settings)
		{
			settings.cbSize = Marshal.SizeOf(settings);
			return FMOD5_System_GetAdvancedSettings(handle, ref settings);
		}

		public RESULT setCallback(SYSTEM_CALLBACK callback, SYSTEM_CALLBACK_TYPE callbackmask)
		{
			return FMOD5_System_SetCallback(handle, callback, callbackmask);
		}

		public RESULT setPluginPath(string path)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD5_System_SetPluginPath(handle, threadSafeEncoding.byteFromStringUTF8(path));
		}

		public RESULT loadPlugin(string filename, out uint handle, uint priority)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD5_System_LoadPlugin(this.handle, threadSafeEncoding.byteFromStringUTF8(filename), out handle, priority);
		}

		public RESULT loadPlugin(string filename, out uint handle)
		{
			return loadPlugin(filename, out handle, 0u);
		}

		public RESULT unloadPlugin(uint handle)
		{
			return FMOD5_System_UnloadPlugin(this.handle, handle);
		}

		public RESULT getNumNestedPlugins(uint handle, out int count)
		{
			return FMOD5_System_GetNumNestedPlugins(this.handle, handle, out count);
		}

		public RESULT getNestedPlugin(uint handle, int index, out uint nestedhandle)
		{
			return FMOD5_System_GetNestedPlugin(this.handle, handle, index, out nestedhandle);
		}

		public RESULT getNumPlugins(PLUGINTYPE plugintype, out int numplugins)
		{
			return FMOD5_System_GetNumPlugins(handle, plugintype, out numplugins);
		}

		public RESULT getPluginHandle(PLUGINTYPE plugintype, int index, out uint handle)
		{
			return FMOD5_System_GetPluginHandle(this.handle, plugintype, index, out handle);
		}

		public RESULT getPluginInfo(uint handle, out PLUGINTYPE plugintype, out string name, int namelen, out uint version)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(namelen);
			RESULT result = FMOD5_System_GetPluginInfo(this.handle, handle, out plugintype, intPtr, namelen, out version);
			using (StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper())
			{
				name = threadSafeEncoding.stringFromNative(intPtr);
			}
			Marshal.FreeHGlobal(intPtr);
			return result;
		}

		public RESULT getPluginInfo(uint handle, out PLUGINTYPE plugintype, out uint version)
		{
			return FMOD5_System_GetPluginInfo(this.handle, handle, out plugintype, IntPtr.Zero, 0, out version);
		}

		public RESULT setOutputByPlugin(uint handle)
		{
			return FMOD5_System_SetOutputByPlugin(this.handle, handle);
		}

		public RESULT getOutputByPlugin(out uint handle)
		{
			return FMOD5_System_GetOutputByPlugin(this.handle, out handle);
		}

		public RESULT createDSPByPlugin(uint handle, out DSP dsp)
		{
			return FMOD5_System_CreateDSPByPlugin(this.handle, handle, out dsp.handle);
		}

		public RESULT getDSPInfoByPlugin(uint handle, out IntPtr description)
		{
			return FMOD5_System_GetDSPInfoByPlugin(this.handle, handle, out description);
		}

		public RESULT registerDSP(ref DSP_DESCRIPTION description, out uint handle)
		{
			return FMOD5_System_RegisterDSP(this.handle, ref description, out handle);
		}

		public RESULT init(int maxchannels, INITFLAGS flags, IntPtr extradriverdata)
		{
			return FMOD5_System_Init(handle, maxchannels, flags, extradriverdata);
		}

		public RESULT close()
		{
			return FMOD5_System_Close(handle);
		}

		public RESULT update()
		{
			return FMOD5_System_Update(handle);
		}

		public RESULT setSpeakerPosition(SPEAKER speaker, float x, float y, bool active)
		{
			return FMOD5_System_SetSpeakerPosition(handle, speaker, x, y, active);
		}

		public RESULT getSpeakerPosition(SPEAKER speaker, out float x, out float y, out bool active)
		{
			return FMOD5_System_GetSpeakerPosition(handle, speaker, out x, out y, out active);
		}

		public RESULT setStreamBufferSize(uint filebuffersize, TIMEUNIT filebuffersizetype)
		{
			return FMOD5_System_SetStreamBufferSize(handle, filebuffersize, filebuffersizetype);
		}

		public RESULT getStreamBufferSize(out uint filebuffersize, out TIMEUNIT filebuffersizetype)
		{
			return FMOD5_System_GetStreamBufferSize(handle, out filebuffersize, out filebuffersizetype);
		}

		public RESULT set3DSettings(float dopplerscale, float distancefactor, float rolloffscale)
		{
			return FMOD5_System_Set3DSettings(handle, dopplerscale, distancefactor, rolloffscale);
		}

		public RESULT get3DSettings(out float dopplerscale, out float distancefactor, out float rolloffscale)
		{
			return FMOD5_System_Get3DSettings(handle, out dopplerscale, out distancefactor, out rolloffscale);
		}

		public RESULT set3DNumListeners(int numlisteners)
		{
			return FMOD5_System_Set3DNumListeners(handle, numlisteners);
		}

		public RESULT get3DNumListeners(out int numlisteners)
		{
			return FMOD5_System_Get3DNumListeners(handle, out numlisteners);
		}

		public RESULT set3DListenerAttributes(int listener, ref VECTOR pos, ref VECTOR vel, ref VECTOR forward, ref VECTOR up)
		{
			return FMOD5_System_Set3DListenerAttributes(handle, listener, ref pos, ref vel, ref forward, ref up);
		}

		public RESULT get3DListenerAttributes(int listener, out VECTOR pos, out VECTOR vel, out VECTOR forward, out VECTOR up)
		{
			return FMOD5_System_Get3DListenerAttributes(handle, listener, out pos, out vel, out forward, out up);
		}

		public RESULT set3DRolloffCallback(CB_3D_ROLLOFFCALLBACK callback)
		{
			return FMOD5_System_Set3DRolloffCallback(handle, callback);
		}

		public RESULT mixerSuspend()
		{
			return FMOD5_System_MixerSuspend(handle);
		}

		public RESULT mixerResume()
		{
			return FMOD5_System_MixerResume(handle);
		}

		public RESULT getDefaultMixMatrix(SPEAKERMODE sourcespeakermode, SPEAKERMODE targetspeakermode, float[] matrix, int matrixhop)
		{
			return FMOD5_System_GetDefaultMixMatrix(handle, sourcespeakermode, targetspeakermode, matrix, matrixhop);
		}

		public RESULT getSpeakerModeChannels(SPEAKERMODE mode, out int channels)
		{
			return FMOD5_System_GetSpeakerModeChannels(handle, mode, out channels);
		}

		public RESULT getVersion(out uint version)
		{
			return FMOD5_System_GetVersion(handle, out version);
		}

		public RESULT getOutputHandle(out IntPtr handle)
		{
			return FMOD5_System_GetOutputHandle(this.handle, out handle);
		}

		public RESULT getChannelsPlaying(out int channels, out int realchannels)
		{
			return FMOD5_System_GetChannelsPlaying(handle, out channels, out realchannels);
		}

		public RESULT getCPUUsage(out float dsp, out float stream, out float geometry, out float update, out float total)
		{
			return FMOD5_System_GetCPUUsage(handle, out dsp, out stream, out geometry, out update, out total);
		}

		public RESULT getFileUsage(out long sampleBytesRead, out long streamBytesRead, out long otherBytesRead)
		{
			return FMOD5_System_GetFileUsage(handle, out sampleBytesRead, out streamBytesRead, out otherBytesRead);
		}

		public RESULT getSoundRAM(out int currentalloced, out int maxalloced, out int total)
		{
			return FMOD5_System_GetSoundRAM(handle, out currentalloced, out maxalloced, out total);
		}

		public RESULT createSound(string name, MODE mode, ref CREATESOUNDEXINFO exinfo, out Sound sound)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD5_System_CreateSound(handle, threadSafeEncoding.byteFromStringUTF8(name), mode, ref exinfo, out sound.handle);
		}

		public RESULT createSound(byte[] data, MODE mode, ref CREATESOUNDEXINFO exinfo, out Sound sound)
		{
			return FMOD5_System_CreateSound(handle, data, mode, ref exinfo, out sound.handle);
		}

		public RESULT createSound(IntPtr name_or_data, MODE mode, ref CREATESOUNDEXINFO exinfo, out Sound sound)
		{
			return FMOD5_System_CreateSound(handle, name_or_data, mode, ref exinfo, out sound.handle);
		}

		public RESULT createSound(string name, MODE mode, out Sound sound)
		{
			CREATESOUNDEXINFO exinfo = default(CREATESOUNDEXINFO);
			exinfo.cbsize = Marshal.SizeOf(exinfo);
			return createSound(name, mode, ref exinfo, out sound);
		}

		public RESULT createStream(string name, MODE mode, ref CREATESOUNDEXINFO exinfo, out Sound sound)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD5_System_CreateStream(handle, threadSafeEncoding.byteFromStringUTF8(name), mode, ref exinfo, out sound.handle);
		}

		public RESULT createStream(byte[] data, MODE mode, ref CREATESOUNDEXINFO exinfo, out Sound sound)
		{
			return FMOD5_System_CreateStream(handle, data, mode, ref exinfo, out sound.handle);
		}

		public RESULT createStream(IntPtr name_or_data, MODE mode, ref CREATESOUNDEXINFO exinfo, out Sound sound)
		{
			return FMOD5_System_CreateStream(handle, name_or_data, mode, ref exinfo, out sound.handle);
		}

		public RESULT createStream(string name, MODE mode, out Sound sound)
		{
			CREATESOUNDEXINFO exinfo = default(CREATESOUNDEXINFO);
			exinfo.cbsize = Marshal.SizeOf(exinfo);
			return createStream(name, mode, ref exinfo, out sound);
		}

		public RESULT createDSP(ref DSP_DESCRIPTION description, out DSP dsp)
		{
			return FMOD5_System_CreateDSP(handle, ref description, out dsp.handle);
		}

		public RESULT createDSPByType(DSP_TYPE type, out DSP dsp)
		{
			return FMOD5_System_CreateDSPByType(handle, type, out dsp.handle);
		}

		public RESULT createChannelGroup(string name, out ChannelGroup channelgroup)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD5_System_CreateChannelGroup(handle, threadSafeEncoding.byteFromStringUTF8(name), out channelgroup.handle);
		}

		public RESULT createSoundGroup(string name, out SoundGroup soundgroup)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD5_System_CreateSoundGroup(handle, threadSafeEncoding.byteFromStringUTF8(name), out soundgroup.handle);
		}

		public RESULT createReverb3D(out Reverb3D reverb)
		{
			return FMOD5_System_CreateReverb3D(handle, out reverb.handle);
		}

		public RESULT playSound(Sound sound, ChannelGroup channelGroup, bool paused, out Channel channel)
		{
			return FMOD5_System_PlaySound(handle, sound.handle, channelGroup.handle, paused, out channel.handle);
		}

		public RESULT playDSP(DSP dsp, ChannelGroup channelGroup, bool paused, out Channel channel)
		{
			return FMOD5_System_PlayDSP(handle, dsp.handle, channelGroup.handle, paused, out channel.handle);
		}

		public RESULT getChannel(int channelid, out Channel channel)
		{
			return FMOD5_System_GetChannel(handle, channelid, out channel.handle);
		}

		public RESULT getMasterChannelGroup(out ChannelGroup channelgroup)
		{
			return FMOD5_System_GetMasterChannelGroup(handle, out channelgroup.handle);
		}

		public RESULT getMasterSoundGroup(out SoundGroup soundgroup)
		{
			return FMOD5_System_GetMasterSoundGroup(handle, out soundgroup.handle);
		}

		public RESULT attachChannelGroupToPort(uint portType, ulong portIndex, ChannelGroup channelgroup, bool passThru = false)
		{
			return FMOD5_System_AttachChannelGroupToPort(handle, portType, portIndex, channelgroup.handle, passThru);
		}

		public RESULT detachChannelGroupFromPort(ChannelGroup channelgroup)
		{
			return FMOD5_System_DetachChannelGroupFromPort(handle, channelgroup.handle);
		}

		public RESULT setReverbProperties(int instance, ref REVERB_PROPERTIES prop)
		{
			return FMOD5_System_SetReverbProperties(handle, instance, ref prop);
		}

		public RESULT getReverbProperties(int instance, out REVERB_PROPERTIES prop)
		{
			return FMOD5_System_GetReverbProperties(handle, instance, out prop);
		}

		public RESULT lockDSP()
		{
			return FMOD5_System_LockDSP(handle);
		}

		public RESULT unlockDSP()
		{
			return FMOD5_System_UnlockDSP(handle);
		}

		public RESULT getRecordNumDrivers(out int numdrivers, out int numconnected)
		{
			return FMOD5_System_GetRecordNumDrivers(handle, out numdrivers, out numconnected);
		}

		public RESULT getRecordDriverInfo(int id, out string name, int namelen, out Guid guid, out int systemrate, out SPEAKERMODE speakermode, out int speakermodechannels, out DRIVER_STATE state)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(namelen);
			RESULT result = FMOD5_System_GetRecordDriverInfo(handle, id, intPtr, namelen, out guid, out systemrate, out speakermode, out speakermodechannels, out state);
			using (StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper())
			{
				name = threadSafeEncoding.stringFromNative(intPtr);
			}
			Marshal.FreeHGlobal(intPtr);
			return result;
		}

		public RESULT getRecordDriverInfo(int id, out Guid guid, out int systemrate, out SPEAKERMODE speakermode, out int speakermodechannels, out DRIVER_STATE state)
		{
			return FMOD5_System_GetRecordDriverInfo(handle, id, IntPtr.Zero, 0, out guid, out systemrate, out speakermode, out speakermodechannels, out state);
		}

		public RESULT getRecordPosition(int id, out uint position)
		{
			return FMOD5_System_GetRecordPosition(handle, id, out position);
		}

		public RESULT recordStart(int id, Sound sound, bool loop)
		{
			return FMOD5_System_RecordStart(handle, id, sound.handle, loop);
		}

		public RESULT recordStop(int id)
		{
			return FMOD5_System_RecordStop(handle, id);
		}

		public RESULT isRecording(int id, out bool recording)
		{
			return FMOD5_System_IsRecording(handle, id, out recording);
		}

		public RESULT createGeometry(int maxpolygons, int maxvertices, out Geometry geometry)
		{
			return FMOD5_System_CreateGeometry(handle, maxpolygons, maxvertices, out geometry.handle);
		}

		public RESULT setGeometrySettings(float maxworldsize)
		{
			return FMOD5_System_SetGeometrySettings(handle, maxworldsize);
		}

		public RESULT getGeometrySettings(out float maxworldsize)
		{
			return FMOD5_System_GetGeometrySettings(handle, out maxworldsize);
		}

		public RESULT loadGeometry(IntPtr data, int datasize, out Geometry geometry)
		{
			return FMOD5_System_LoadGeometry(handle, data, datasize, out geometry.handle);
		}

		public RESULT getGeometryOcclusion(ref VECTOR listener, ref VECTOR source, out float direct, out float reverb)
		{
			return FMOD5_System_GetGeometryOcclusion(handle, ref listener, ref source, out direct, out reverb);
		}

		public RESULT setNetworkProxy(string proxy)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD5_System_SetNetworkProxy(handle, threadSafeEncoding.byteFromStringUTF8(proxy));
		}

		public RESULT getNetworkProxy(out string proxy, int proxylen)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(proxylen);
			RESULT result = FMOD5_System_GetNetworkProxy(handle, intPtr, proxylen);
			using (StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper())
			{
				proxy = threadSafeEncoding.stringFromNative(intPtr);
			}
			Marshal.FreeHGlobal(intPtr);
			return result;
		}

		public RESULT setNetworkTimeout(int timeout)
		{
			return FMOD5_System_SetNetworkTimeout(handle, timeout);
		}

		public RESULT getNetworkTimeout(out int timeout)
		{
			return FMOD5_System_GetNetworkTimeout(handle, out timeout);
		}

		public RESULT setUserData(IntPtr userdata)
		{
			return FMOD5_System_SetUserData(handle, userdata);
		}

		public RESULT getUserData(out IntPtr userdata)
		{
			return FMOD5_System_GetUserData(handle, out userdata);
		}

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_Release(IntPtr system);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_SetOutput(IntPtr system, OUTPUTTYPE output);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetOutput(IntPtr system, out OUTPUTTYPE output);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetNumDrivers(IntPtr system, out int numdrivers);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetDriverInfo(IntPtr system, int id, IntPtr name, int namelen, out Guid guid, out int systemrate, out SPEAKERMODE speakermode, out int speakermodechannels);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_SetDriver(IntPtr system, int driver);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetDriver(IntPtr system, out int driver);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_SetSoftwareChannels(IntPtr system, int numsoftwarechannels);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetSoftwareChannels(IntPtr system, out int numsoftwarechannels);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_SetSoftwareFormat(IntPtr system, int samplerate, SPEAKERMODE speakermode, int numrawspeakers);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetSoftwareFormat(IntPtr system, out int samplerate, out SPEAKERMODE speakermode, out int numrawspeakers);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_SetDSPBufferSize(IntPtr system, uint bufferlength, int numbuffers);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetDSPBufferSize(IntPtr system, out uint bufferlength, out int numbuffers);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_SetFileSystem(IntPtr system, FILE_OPENCALLBACK useropen, FILE_CLOSECALLBACK userclose, FILE_READCALLBACK userread, FILE_SEEKCALLBACK userseek, FILE_ASYNCREADCALLBACK userasyncread, FILE_ASYNCCANCELCALLBACK userasynccancel, int blockalign);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_AttachFileSystem(IntPtr system, FILE_OPENCALLBACK useropen, FILE_CLOSECALLBACK userclose, FILE_READCALLBACK userread, FILE_SEEKCALLBACK userseek);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_SetAdvancedSettings(IntPtr system, ref ADVANCEDSETTINGS settings);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetAdvancedSettings(IntPtr system, ref ADVANCEDSETTINGS settings);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_SetCallback(IntPtr system, SYSTEM_CALLBACK callback, SYSTEM_CALLBACK_TYPE callbackmask);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_SetPluginPath(IntPtr system, byte[] path);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_LoadPlugin(IntPtr system, byte[] filename, out uint handle, uint priority);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_UnloadPlugin(IntPtr system, uint handle);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetNumNestedPlugins(IntPtr system, uint handle, out int count);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetNestedPlugin(IntPtr system, uint handle, int index, out uint nestedhandle);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetNumPlugins(IntPtr system, PLUGINTYPE plugintype, out int numplugins);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetPluginHandle(IntPtr system, PLUGINTYPE plugintype, int index, out uint handle);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetPluginInfo(IntPtr system, uint handle, out PLUGINTYPE plugintype, IntPtr name, int namelen, out uint version);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_SetOutputByPlugin(IntPtr system, uint handle);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetOutputByPlugin(IntPtr system, out uint handle);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_CreateDSPByPlugin(IntPtr system, uint handle, out IntPtr dsp);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetDSPInfoByPlugin(IntPtr system, uint handle, out IntPtr description);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_RegisterDSP(IntPtr system, ref DSP_DESCRIPTION description, out uint handle);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_Init(IntPtr system, int maxchannels, INITFLAGS flags, IntPtr extradriverdata);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_Close(IntPtr system);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_Update(IntPtr system);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_SetSpeakerPosition(IntPtr system, SPEAKER speaker, float x, float y, bool active);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetSpeakerPosition(IntPtr system, SPEAKER speaker, out float x, out float y, out bool active);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_SetStreamBufferSize(IntPtr system, uint filebuffersize, TIMEUNIT filebuffersizetype);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetStreamBufferSize(IntPtr system, out uint filebuffersize, out TIMEUNIT filebuffersizetype);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_Set3DSettings(IntPtr system, float dopplerscale, float distancefactor, float rolloffscale);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_Get3DSettings(IntPtr system, out float dopplerscale, out float distancefactor, out float rolloffscale);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_Set3DNumListeners(IntPtr system, int numlisteners);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_Get3DNumListeners(IntPtr system, out int numlisteners);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_Set3DListenerAttributes(IntPtr system, int listener, ref VECTOR pos, ref VECTOR vel, ref VECTOR forward, ref VECTOR up);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_Get3DListenerAttributes(IntPtr system, int listener, out VECTOR pos, out VECTOR vel, out VECTOR forward, out VECTOR up);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_Set3DRolloffCallback(IntPtr system, CB_3D_ROLLOFFCALLBACK callback);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_MixerSuspend(IntPtr system);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_MixerResume(IntPtr system);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetDefaultMixMatrix(IntPtr system, SPEAKERMODE sourcespeakermode, SPEAKERMODE targetspeakermode, float[] matrix, int matrixhop);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetSpeakerModeChannels(IntPtr system, SPEAKERMODE mode, out int channels);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetVersion(IntPtr system, out uint version);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetOutputHandle(IntPtr system, out IntPtr handle);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetChannelsPlaying(IntPtr system, out int channels, out int realchannels);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetCPUUsage(IntPtr system, out float dsp, out float stream, out float geometry, out float update, out float total);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetFileUsage(IntPtr system, out long sampleBytesRead, out long streamBytesRead, out long otherBytesRead);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetSoundRAM(IntPtr system, out int currentalloced, out int maxalloced, out int total);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_CreateSound(IntPtr system, byte[] name_or_data, MODE mode, ref CREATESOUNDEXINFO exinfo, out IntPtr sound);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_CreateSound(IntPtr system, IntPtr name_or_data, MODE mode, ref CREATESOUNDEXINFO exinfo, out IntPtr sound);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_CreateStream(IntPtr system, byte[] name_or_data, MODE mode, ref CREATESOUNDEXINFO exinfo, out IntPtr sound);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_CreateStream(IntPtr system, IntPtr name_or_data, MODE mode, ref CREATESOUNDEXINFO exinfo, out IntPtr sound);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_CreateDSP(IntPtr system, ref DSP_DESCRIPTION description, out IntPtr dsp);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_CreateDSPByType(IntPtr system, DSP_TYPE type, out IntPtr dsp);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_CreateChannelGroup(IntPtr system, byte[] name, out IntPtr channelgroup);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_CreateSoundGroup(IntPtr system, byte[] name, out IntPtr soundgroup);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_CreateReverb3D(IntPtr system, out IntPtr reverb);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_PlaySound(IntPtr system, IntPtr sound, IntPtr channelGroup, bool paused, out IntPtr channel);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_PlayDSP(IntPtr system, IntPtr dsp, IntPtr channelGroup, bool paused, out IntPtr channel);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetChannel(IntPtr system, int channelid, out IntPtr channel);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetMasterChannelGroup(IntPtr system, out IntPtr channelgroup);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetMasterSoundGroup(IntPtr system, out IntPtr soundgroup);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_AttachChannelGroupToPort(IntPtr system, uint portType, ulong portIndex, IntPtr channelgroup, bool passThru);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_DetachChannelGroupFromPort(IntPtr system, IntPtr channelgroup);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_SetReverbProperties(IntPtr system, int instance, ref REVERB_PROPERTIES prop);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetReverbProperties(IntPtr system, int instance, out REVERB_PROPERTIES prop);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_LockDSP(IntPtr system);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_UnlockDSP(IntPtr system);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetRecordNumDrivers(IntPtr system, out int numdrivers, out int numconnected);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetRecordDriverInfo(IntPtr system, int id, IntPtr name, int namelen, out Guid guid, out int systemrate, out SPEAKERMODE speakermode, out int speakermodechannels, out DRIVER_STATE state);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetRecordPosition(IntPtr system, int id, out uint position);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_RecordStart(IntPtr system, int id, IntPtr sound, bool loop);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_RecordStop(IntPtr system, int id);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_IsRecording(IntPtr system, int id, out bool recording);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_CreateGeometry(IntPtr system, int maxpolygons, int maxvertices, out IntPtr geometry);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_SetGeometrySettings(IntPtr system, float maxworldsize);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetGeometrySettings(IntPtr system, out float maxworldsize);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_LoadGeometry(IntPtr system, IntPtr data, int datasize, out IntPtr geometry);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetGeometryOcclusion(IntPtr system, ref VECTOR listener, ref VECTOR source, out float direct, out float reverb);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_SetNetworkProxy(IntPtr system, byte[] proxy);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetNetworkProxy(IntPtr system, IntPtr proxy, int proxylen);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_SetNetworkTimeout(IntPtr system, int timeout);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetNetworkTimeout(IntPtr system, out int timeout);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_SetUserData(IntPtr system, IntPtr userdata);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_System_GetUserData(IntPtr system, out IntPtr userdata);

		public bool hasHandle()
		{
			return handle != IntPtr.Zero;
		}

		public void clearHandle()
		{
			handle = IntPtr.Zero;
		}
	}
	public struct Sound
	{
		public IntPtr handle;

		public RESULT release()
		{
			return FMOD5_Sound_Release(handle);
		}

		public RESULT getSystemObject(out System system)
		{
			return FMOD5_Sound_GetSystemObject(handle, out system.handle);
		}

		public RESULT @lock(uint offset, uint length, out IntPtr ptr1, out IntPtr ptr2, out uint len1, out uint len2)
		{
			return FMOD5_Sound_Lock(handle, offset, length, out ptr1, out ptr2, out len1, out len2);
		}

		public RESULT unlock(IntPtr ptr1, IntPtr ptr2, uint len1, uint len2)
		{
			return FMOD5_Sound_Unlock(handle, ptr1, ptr2, len1, len2);
		}

		public RESULT setDefaults(float frequency, int priority)
		{
			return FMOD5_Sound_SetDefaults(handle, frequency, priority);
		}

		public RESULT getDefaults(out float frequency, out int priority)
		{
			return FMOD5_Sound_GetDefaults(handle, out frequency, out priority);
		}

		public RESULT set3DMinMaxDistance(float min, float max)
		{
			return FMOD5_Sound_Set3DMinMaxDistance(handle, min, max);
		}

		public RESULT get3DMinMaxDistance(out float min, out float max)
		{
			return FMOD5_Sound_Get3DMinMaxDistance(handle, out min, out max);
		}

		public RESULT set3DConeSettings(float insideconeangle, float outsideconeangle, float outsidevolume)
		{
			return FMOD5_Sound_Set3DConeSettings(handle, insideconeangle, outsideconeangle, outsidevolume);
		}

		public RESULT get3DConeSettings(out float insideconeangle, out float outsideconeangle, out float outsidevolume)
		{
			return FMOD5_Sound_Get3DConeSettings(handle, out insideconeangle, out outsideconeangle, out outsidevolume);
		}

		public RESULT set3DCustomRolloff(ref VECTOR points, int numpoints)
		{
			return FMOD5_Sound_Set3DCustomRolloff(handle, ref points, numpoints);
		}

		public RESULT get3DCustomRolloff(out IntPtr points, out int numpoints)
		{
			return FMOD5_Sound_Get3DCustomRolloff(handle, out points, out numpoints);
		}

		public RESULT getSubSound(int index, out Sound subsound)
		{
			return FMOD5_Sound_GetSubSound(handle, index, out subsound.handle);
		}

		public RESULT getSubSoundParent(out Sound parentsound)
		{
			return FMOD5_Sound_GetSubSoundParent(handle, out parentsound.handle);
		}

		public RESULT getName(out string name, int namelen)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(namelen);
			RESULT result = FMOD5_Sound_GetName(handle, intPtr, namelen);
			using (StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper())
			{
				name = threadSafeEncoding.stringFromNative(intPtr);
			}
			Marshal.FreeHGlobal(intPtr);
			return result;
		}

		public RESULT getLength(out uint length, TIMEUNIT lengthtype)
		{
			return FMOD5_Sound_GetLength(handle, out length, lengthtype);
		}

		public RESULT getFormat(out SOUND_TYPE type, out SOUND_FORMAT format, out int channels, out int bits)
		{
			return FMOD5_Sound_GetFormat(handle, out type, out format, out channels, out bits);
		}

		public RESULT getNumSubSounds(out int numsubsounds)
		{
			return FMOD5_Sound_GetNumSubSounds(handle, out numsubsounds);
		}

		public RESULT getNumTags(out int numtags, out int numtagsupdated)
		{
			return FMOD5_Sound_GetNumTags(handle, out numtags, out numtagsupdated);
		}

		public RESULT getTag(string name, int index, out TAG tag)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD5_Sound_GetTag(handle, threadSafeEncoding.byteFromStringUTF8(name), index, out tag);
		}

		public RESULT getOpenState(out OPENSTATE openstate, out uint percentbuffered, out bool starving, out bool diskbusy)
		{
			return FMOD5_Sound_GetOpenState(handle, out openstate, out percentbuffered, out starving, out diskbusy);
		}

		public RESULT readData(IntPtr buffer, uint lenbytes, out uint read)
		{
			return FMOD5_Sound_ReadData(handle, buffer, lenbytes, out read);
		}

		public RESULT seekData(uint pcm)
		{
			return FMOD5_Sound_SeekData(handle, pcm);
		}

		public RESULT setSoundGroup(SoundGroup soundgroup)
		{
			return FMOD5_Sound_SetSoundGroup(handle, soundgroup.handle);
		}

		public RESULT getSoundGroup(out SoundGroup soundgroup)
		{
			return FMOD5_Sound_GetSoundGroup(handle, out soundgroup.handle);
		}

		public RESULT getNumSyncPoints(out int numsyncpoints)
		{
			return FMOD5_Sound_GetNumSyncPoints(handle, out numsyncpoints);
		}

		public RESULT getSyncPoint(int index, out IntPtr point)
		{
			return FMOD5_Sound_GetSyncPoint(handle, index, out point);
		}

		public RESULT getSyncPointInfo(IntPtr point, out string name, int namelen, out uint offset, TIMEUNIT offsettype)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(namelen);
			RESULT result = FMOD5_Sound_GetSyncPointInfo(handle, point, intPtr, namelen, out offset, offsettype);
			using (StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper())
			{
				name = threadSafeEncoding.stringFromNative(intPtr);
			}
			Marshal.FreeHGlobal(intPtr);
			return result;
		}

		public RESULT getSyncPointInfo(IntPtr point, out uint offset, TIMEUNIT offsettype)
		{
			return FMOD5_Sound_GetSyncPointInfo(handle, point, IntPtr.Zero, 0, out offset, offsettype);
		}

		public RESULT addSyncPoint(uint offset, TIMEUNIT offsettype, string name, out IntPtr point)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD5_Sound_AddSyncPoint(handle, offset, offsettype, threadSafeEncoding.byteFromStringUTF8(name), out point);
		}

		public RESULT deleteSyncPoint(IntPtr point)
		{
			return FMOD5_Sound_DeleteSyncPoint(handle, point);
		}

		public RESULT setMode(MODE mode)
		{
			return FMOD5_Sound_SetMode(handle, mode);
		}

		public RESULT getMode(out MODE mode)
		{
			return FMOD5_Sound_GetMode(handle, out mode);
		}

		public RESULT setLoopCount(int loopcount)
		{
			return FMOD5_Sound_SetLoopCount(handle, loopcount);
		}

		public RESULT getLoopCount(out int loopcount)
		{
			return FMOD5_Sound_GetLoopCount(handle, out loopcount);
		}

		public RESULT setLoopPoints(uint loopstart, TIMEUNIT loopstarttype, uint loopend, TIMEUNIT loopendtype)
		{
			return FMOD5_Sound_SetLoopPoints(handle, loopstart, loopstarttype, loopend, loopendtype);
		}

		public RESULT getLoopPoints(out uint loopstart, TIMEUNIT loopstarttype, out uint loopend, TIMEUNIT loopendtype)
		{
			return FMOD5_Sound_GetLoopPoints(handle, out loopstart, loopstarttype, out loopend, loopendtype);
		}

		public RESULT getMusicNumChannels(out int numchannels)
		{
			return FMOD5_Sound_GetMusicNumChannels(handle, out numchannels);
		}

		public RESULT setMusicChannelVolume(int channel, float volume)
		{
			return FMOD5_Sound_SetMusicChannelVolume(handle, channel, volume);
		}

		public RESULT getMusicChannelVolume(int channel, out float volume)
		{
			return FMOD5_Sound_GetMusicChannelVolume(handle, channel, out volume);
		}

		public RESULT setMusicSpeed(float speed)
		{
			return FMOD5_Sound_SetMusicSpeed(handle, speed);
		}

		public RESULT getMusicSpeed(out float speed)
		{
			return FMOD5_Sound_GetMusicSpeed(handle, out speed);
		}

		public RESULT setUserData(IntPtr userdata)
		{
			return FMOD5_Sound_SetUserData(handle, userdata);
		}

		public RESULT getUserData(out IntPtr userdata)
		{
			return FMOD5_Sound_GetUserData(handle, out userdata);
		}

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_Release(IntPtr sound);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetSystemObject(IntPtr sound, out IntPtr system);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_Lock(IntPtr sound, uint offset, uint length, out IntPtr ptr1, out IntPtr ptr2, out uint len1, out uint len2);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_Unlock(IntPtr sound, IntPtr ptr1, IntPtr ptr2, uint len1, uint len2);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_SetDefaults(IntPtr sound, float frequency, int priority);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetDefaults(IntPtr sound, out float frequency, out int priority);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_Set3DMinMaxDistance(IntPtr sound, float min, float max);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_Get3DMinMaxDistance(IntPtr sound, out float min, out float max);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_Set3DConeSettings(IntPtr sound, float insideconeangle, float outsideconeangle, float outsidevolume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_Get3DConeSettings(IntPtr sound, out float insideconeangle, out float outsideconeangle, out float outsidevolume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_Set3DCustomRolloff(IntPtr sound, ref VECTOR points, int numpoints);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_Get3DCustomRolloff(IntPtr sound, out IntPtr points, out int numpoints);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetSubSound(IntPtr sound, int index, out IntPtr subsound);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetSubSoundParent(IntPtr sound, out IntPtr parentsound);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetName(IntPtr sound, IntPtr name, int namelen);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetLength(IntPtr sound, out uint length, TIMEUNIT lengthtype);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetFormat(IntPtr sound, out SOUND_TYPE type, out SOUND_FORMAT format, out int channels, out int bits);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetNumSubSounds(IntPtr sound, out int numsubsounds);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetNumTags(IntPtr sound, out int numtags, out int numtagsupdated);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetTag(IntPtr sound, byte[] name, int index, out TAG tag);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetOpenState(IntPtr sound, out OPENSTATE openstate, out uint percentbuffered, out bool starving, out bool diskbusy);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_ReadData(IntPtr sound, IntPtr buffer, uint lenbytes, out uint read);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_SeekData(IntPtr sound, uint pcm);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_SetSoundGroup(IntPtr sound, IntPtr soundgroup);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetSoundGroup(IntPtr sound, out IntPtr soundgroup);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetNumSyncPoints(IntPtr sound, out int numsyncpoints);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetSyncPoint(IntPtr sound, int index, out IntPtr point);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetSyncPointInfo(IntPtr sound, IntPtr point, IntPtr name, int namelen, out uint offset, TIMEUNIT offsettype);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_AddSyncPoint(IntPtr sound, uint offset, TIMEUNIT offsettype, byte[] name, out IntPtr point);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_DeleteSyncPoint(IntPtr sound, IntPtr point);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_SetMode(IntPtr sound, MODE mode);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetMode(IntPtr sound, out MODE mode);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_SetLoopCount(IntPtr sound, int loopcount);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetLoopCount(IntPtr sound, out int loopcount);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_SetLoopPoints(IntPtr sound, uint loopstart, TIMEUNIT loopstarttype, uint loopend, TIMEUNIT loopendtype);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetLoopPoints(IntPtr sound, out uint loopstart, TIMEUNIT loopstarttype, out uint loopend, TIMEUNIT loopendtype);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetMusicNumChannels(IntPtr sound, out int numchannels);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_SetMusicChannelVolume(IntPtr sound, int channel, float volume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetMusicChannelVolume(IntPtr sound, int channel, out float volume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_SetMusicSpeed(IntPtr sound, float speed);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetMusicSpeed(IntPtr sound, out float speed);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_SetUserData(IntPtr sound, IntPtr userdata);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Sound_GetUserData(IntPtr sound, out IntPtr userdata);

		public bool hasHandle()
		{
			return handle != IntPtr.Zero;
		}

		public void clearHandle()
		{
			handle = IntPtr.Zero;
		}
	}
	internal interface IChannelControl
	{
		RESULT getSystemObject(out System system);

		RESULT stop();

		RESULT setPaused(bool paused);

		RESULT getPaused(out bool paused);

		RESULT setVolume(float volume);

		RESULT getVolume(out float volume);

		RESULT setVolumeRamp(bool ramp);

		RESULT getVolumeRamp(out bool ramp);

		RESULT getAudibility(out float audibility);

		RESULT setPitch(float pitch);

		RESULT getPitch(out float pitch);

		RESULT setMute(bool mute);

		RESULT getMute(out bool mute);

		RESULT setReverbProperties(int instance, float wet);

		RESULT getReverbProperties(int instance, out float wet);

		RESULT setLowPassGain(float gain);

		RESULT getLowPassGain(out float gain);

		RESULT setMode(MODE mode);

		RESULT getMode(out MODE mode);

		RESULT setCallback(CHANNEL_CALLBACK callback);

		RESULT isPlaying(out bool isplaying);

		RESULT setPan(float pan);

		RESULT setMixLevelsOutput(float frontleft, float frontright, float center, float lfe, float surroundleft, float surroundright, float backleft, float backright);

		RESULT setMixLevelsInput(float[] levels, int numlevels);

		RESULT setMixMatrix(float[] matrix, int outchannels, int inchannels, int inchannel_hop);

		RESULT getMixMatrix(float[] matrix, out int outchannels, out int inchannels, int inchannel_hop);

		RESULT getDSPClock(out ulong dspclock, out ulong parentclock);

		RESULT setDelay(ulong dspclock_start, ulong dspclock_end, bool stopchannels);

		RESULT getDelay(out ulong dspclock_start, out ulong dspclock_end, out bool stopchannels);

		RESULT addFadePoint(ulong dspclock, float volume);

		RESULT setFadePointRamp(ulong dspclock, float volume);

		RESULT removeFadePoints(ulong dspclock_start, ulong dspclock_end);

		RESULT getFadePoints(ref uint numpoints, ulong[] point_dspclock, float[] point_volume);

		RESULT getDSP(int index, out DSP dsp);

		RESULT addDSP(int index, DSP dsp);

		RESULT removeDSP(DSP dsp);

		RESULT getNumDSPs(out int numdsps);

		RESULT setDSPIndex(DSP dsp, int index);

		RESULT getDSPIndex(DSP dsp, out int index);

		RESULT set3DAttributes(ref VECTOR pos, ref VECTOR vel, ref VECTOR alt_pan_pos);

		RESULT get3DAttributes(out VECTOR pos, out VECTOR vel, out VECTOR alt_pan_pos);

		RESULT set3DMinMaxDistance(float mindistance, float maxdistance);

		RESULT get3DMinMaxDistance(out float mindistance, out float maxdistance);

		RESULT set3DConeSettings(float insideconeangle, float outsideconeangle, float outsidevolume);

		RESULT get3DConeSettings(out float insideconeangle, out float outsideconeangle, out float outsidevolume);

		RESULT set3DConeOrientation(ref VECTOR orientation);

		RESULT get3DConeOrientation(out VECTOR orientation);

		RESULT set3DCustomRolloff(ref VECTOR points, int numpoints);

		RESULT get3DCustomRolloff(out IntPtr points, out int numpoints);

		RESULT set3DOcclusion(float directocclusion, float reverbocclusion);

		RESULT get3DOcclusion(out float directocclusion, out float reverbocclusion);

		RESULT set3DSpread(float angle);

		RESULT get3DSpread(out float angle);

		RESULT set3DLevel(float level);

		RESULT get3DLevel(out float level);

		RESULT set3DDopplerLevel(float level);

		RESULT get3DDopplerLevel(out float level);

		RESULT set3DDistanceFilter(bool custom, float customLevel, float centerFreq);

		RESULT get3DDistanceFilter(out bool custom, out float customLevel, out float centerFreq);

		RESULT setUserData(IntPtr userdata);

		RESULT getUserData(out IntPtr userdata);
	}
	public struct Channel : IChannelControl
	{
		public IntPtr handle;

		public RESULT setFrequency(float frequency)
		{
			return FMOD5_Channel_SetFrequency(handle, frequency);
		}

		public RESULT getFrequency(out float frequency)
		{
			return FMOD5_Channel_GetFrequency(handle, out frequency);
		}

		public RESULT setPriority(int priority)
		{
			return FMOD5_Channel_SetPriority(handle, priority);
		}

		public RESULT getPriority(out int priority)
		{
			return FMOD5_Channel_GetPriority(handle, out priority);
		}

		public RESULT setPosition(uint position, TIMEUNIT postype)
		{
			return FMOD5_Channel_SetPosition(handle, position, postype);
		}

		public RESULT getPosition(out uint position, TIMEUNIT postype)
		{
			return FMOD5_Channel_GetPosition(handle, out position, postype);
		}

		public RESULT setChannelGroup(ChannelGroup channelgroup)
		{
			return FMOD5_Channel_SetChannelGroup(handle, channelgroup.handle);
		}

		public RESULT getChannelGroup(out ChannelGroup channelgroup)
		{
			return FMOD5_Channel_GetChannelGroup(handle, out channelgroup.handle);
		}

		public RESULT setLoopCount(int loopcount)
		{
			return FMOD5_Channel_SetLoopCount(handle, loopcount);
		}

		public RESULT getLoopCount(out int loopcount)
		{
			return FMOD5_Channel_GetLoopCount(handle, out loopcount);
		}

		public RESULT setLoopPoints(uint loopstart, TIMEUNIT loopstarttype, uint loopend, TIMEUNIT loopendtype)
		{
			return FMOD5_Channel_SetLoopPoints(handle, loopstart, loopstarttype, loopend, loopendtype);
		}

		public RESULT getLoopPoints(out uint loopstart, TIMEUNIT loopstarttype, out uint loopend, TIMEUNIT loopendtype)
		{
			return FMOD5_Channel_GetLoopPoints(handle, out loopstart, loopstarttype, out loopend, loopendtype);
		}

		public RESULT isVirtual(out bool isvirtual)
		{
			return FMOD5_Channel_IsVirtual(handle, out isvirtual);
		}

		public RESULT getCurrentSound(out Sound sound)
		{
			return FMOD5_Channel_GetCurrentSound(handle, out sound.handle);
		}

		public RESULT getIndex(out int index)
		{
			return FMOD5_Channel_GetIndex(handle, out index);
		}

		public RESULT getSystemObject(out System system)
		{
			return FMOD5_Channel_GetSystemObject(handle, out system.handle);
		}

		public RESULT stop()
		{
			return FMOD5_Channel_Stop(handle);
		}

		public RESULT setPaused(bool paused)
		{
			return FMOD5_Channel_SetPaused(handle, paused);
		}

		public RESULT getPaused(out bool paused)
		{
			return FMOD5_Channel_GetPaused(handle, out paused);
		}

		public RESULT setVolume(float volume)
		{
			return FMOD5_Channel_SetVolume(handle, volume);
		}

		public RESULT getVolume(out float volume)
		{
			return FMOD5_Channel_GetVolume(handle, out volume);
		}

		public RESULT setVolumeRamp(bool ramp)
		{
			return FMOD5_Channel_SetVolumeRamp(handle, ramp);
		}

		public RESULT getVolumeRamp(out bool ramp)
		{
			return FMOD5_Channel_GetVolumeRamp(handle, out ramp);
		}

		public RESULT getAudibility(out float audibility)
		{
			return FMOD5_Channel_GetAudibility(handle, out audibility);
		}

		public RESULT setPitch(float pitch)
		{
			return FMOD5_Channel_SetPitch(handle, pitch);
		}

		public RESULT getPitch(out float pitch)
		{
			return FMOD5_Channel_GetPitch(handle, out pitch);
		}

		public RESULT setMute(bool mute)
		{
			return FMOD5_Channel_SetMute(handle, mute);
		}

		public RESULT getMute(out bool mute)
		{
			return FMOD5_Channel_GetMute(handle, out mute);
		}

		public RESULT setReverbProperties(int instance, float wet)
		{
			return FMOD5_Channel_SetReverbProperties(handle, instance, wet);
		}

		public RESULT getReverbProperties(int instance, out float wet)
		{
			return FMOD5_Channel_GetReverbProperties(handle, instance, out wet);
		}

		public RESULT setLowPassGain(float gain)
		{
			return FMOD5_Channel_SetLowPassGain(handle, gain);
		}

		public RESULT getLowPassGain(out float gain)
		{
			return FMOD5_Channel_GetLowPassGain(handle, out gain);
		}

		public RESULT setMode(MODE mode)
		{
			return FMOD5_Channel_SetMode(handle, mode);
		}

		public RESULT getMode(out MODE mode)
		{
			return FMOD5_Channel_GetMode(handle, out mode);
		}

		public RESULT setCallback(CHANNEL_CALLBACK callback)
		{
			return FMOD5_Channel_SetCallback(handle, callback);
		}

		public RESULT isPlaying(out bool isplaying)
		{
			return FMOD5_Channel_IsPlaying(handle, out isplaying);
		}

		public RESULT setPan(float pan)
		{
			return FMOD5_Channel_SetPan(handle, pan);
		}

		public RESULT setMixLevelsOutput(float frontleft, float frontright, float center, float lfe, float surroundleft, float surroundright, float backleft, float backright)
		{
			return FMOD5_Channel_SetMixLevelsOutput(handle, frontleft, frontright, center, lfe, surroundleft, surroundright, backleft, backright);
		}

		public RESULT setMixLevelsInput(float[] levels, int numlevels)
		{
			return FMOD5_Channel_SetMixLevelsInput(handle, levels, numlevels);
		}

		public RESULT setMixMatrix(float[] matrix, int outchannels, int inchannels, int inchannel_hop)
		{
			return FMOD5_Channel_SetMixMatrix(handle, matrix, outchannels, inchannels, inchannel_hop);
		}

		public RESULT getMixMatrix(float[] matrix, out int outchannels, out int inchannels, int inchannel_hop)
		{
			return FMOD5_Channel_GetMixMatrix(handle, matrix, out outchannels, out inchannels, inchannel_hop);
		}

		public RESULT getDSPClock(out ulong dspclock, out ulong parentclock)
		{
			return FMOD5_Channel_GetDSPClock(handle, out dspclock, out parentclock);
		}

		public RESULT setDelay(ulong dspclock_start, ulong dspclock_end, bool stopchannels)
		{
			return FMOD5_Channel_SetDelay(handle, dspclock_start, dspclock_end, stopchannels);
		}

		public RESULT getDelay(out ulong dspclock_start, out ulong dspclock_end, out bool stopchannels)
		{
			return FMOD5_Channel_GetDelay(handle, out dspclock_start, out dspclock_end, out stopchannels);
		}

		public RESULT addFadePoint(ulong dspclock, float volume)
		{
			return FMOD5_Channel_AddFadePoint(handle, dspclock, volume);
		}

		public RESULT setFadePointRamp(ulong dspclock, float volume)
		{
			return FMOD5_Channel_SetFadePointRamp(handle, dspclock, volume);
		}

		public RESULT removeFadePoints(ulong dspclock_start, ulong dspclock_end)
		{
			return FMOD5_Channel_RemoveFadePoints(handle, dspclock_start, dspclock_end);
		}

		public RESULT getFadePoints(ref uint numpoints, ulong[] point_dspclock, float[] point_volume)
		{
			return FMOD5_Channel_GetFadePoints(handle, ref numpoints, point_dspclock, point_volume);
		}

		public RESULT getDSP(int index, out DSP dsp)
		{
			return FMOD5_Channel_GetDSP(handle, index, out dsp.handle);
		}

		public RESULT addDSP(int index, DSP dsp)
		{
			return FMOD5_Channel_AddDSP(handle, index, dsp.handle);
		}

		public RESULT removeDSP(DSP dsp)
		{
			return FMOD5_Channel_RemoveDSP(handle, dsp.handle);
		}

		public RESULT getNumDSPs(out int numdsps)
		{
			return FMOD5_Channel_GetNumDSPs(handle, out numdsps);
		}

		public RESULT setDSPIndex(DSP dsp, int index)
		{
			return FMOD5_Channel_SetDSPIndex(handle, dsp.handle, index);
		}

		public RESULT getDSPIndex(DSP dsp, out int index)
		{
			return FMOD5_Channel_GetDSPIndex(handle, dsp.handle, out index);
		}

		public RESULT set3DAttributes(ref VECTOR pos, ref VECTOR vel, ref VECTOR alt_pan_pos)
		{
			return FMOD5_Channel_Set3DAttributes(handle, ref pos, ref vel, ref alt_pan_pos);
		}

		public RESULT get3DAttributes(out VECTOR pos, out VECTOR vel, out VECTOR alt_pan_pos)
		{
			return FMOD5_Channel_Get3DAttributes(handle, out pos, out vel, out alt_pan_pos);
		}

		public RESULT set3DMinMaxDistance(float mindistance, float maxdistance)
		{
			return FMOD5_Channel_Set3DMinMaxDistance(handle, mindistance, maxdistance);
		}

		public RESULT get3DMinMaxDistance(out float mindistance, out float maxdistance)
		{
			return FMOD5_Channel_Get3DMinMaxDistance(handle, out mindistance, out maxdistance);
		}

		public RESULT set3DConeSettings(float insideconeangle, float outsideconeangle, float outsidevolume)
		{
			return FMOD5_Channel_Set3DConeSettings(handle, insideconeangle, outsideconeangle, outsidevolume);
		}

		public RESULT get3DConeSettings(out float insideconeangle, out float outsideconeangle, out float outsidevolume)
		{
			return FMOD5_Channel_Get3DConeSettings(handle, out insideconeangle, out outsideconeangle, out outsidevolume);
		}

		public RESULT set3DConeOrientation(ref VECTOR orientation)
		{
			return FMOD5_Channel_Set3DConeOrientation(handle, ref orientation);
		}

		public RESULT get3DConeOrientation(out VECTOR orientation)
		{
			return FMOD5_Channel_Get3DConeOrientation(handle, out orientation);
		}

		public RESULT set3DCustomRolloff(ref VECTOR points, int numpoints)
		{
			return FMOD5_Channel_Set3DCustomRolloff(handle, ref points, numpoints);
		}

		public RESULT get3DCustomRolloff(out IntPtr points, out int numpoints)
		{
			return FMOD5_Channel_Get3DCustomRolloff(handle, out points, out numpoints);
		}

		public RESULT set3DOcclusion(float directocclusion, float reverbocclusion)
		{
			return FMOD5_Channel_Set3DOcclusion(handle, directocclusion, reverbocclusion);
		}

		public RESULT get3DOcclusion(out float directocclusion, out float reverbocclusion)
		{
			return FMOD5_Channel_Get3DOcclusion(handle, out directocclusion, out reverbocclusion);
		}

		public RESULT set3DSpread(float angle)
		{
			return FMOD5_Channel_Set3DSpread(handle, angle);
		}

		public RESULT get3DSpread(out float angle)
		{
			return FMOD5_Channel_Get3DSpread(handle, out angle);
		}

		public RESULT set3DLevel(float level)
		{
			return FMOD5_Channel_Set3DLevel(handle, level);
		}

		public RESULT get3DLevel(out float level)
		{
			return FMOD5_Channel_Get3DLevel(handle, out level);
		}

		public RESULT set3DDopplerLevel(float level)
		{
			return FMOD5_Channel_Set3DDopplerLevel(handle, level);
		}

		public RESULT get3DDopplerLevel(out float level)
		{
			return FMOD5_Channel_Get3DDopplerLevel(handle, out level);
		}

		public RESULT set3DDistanceFilter(bool custom, float customLevel, float centerFreq)
		{
			return FMOD5_Channel_Set3DDistanceFilter(handle, custom, customLevel, centerFreq);
		}

		public RESULT get3DDistanceFilter(out bool custom, out float customLevel, out float centerFreq)
		{
			return FMOD5_Channel_Get3DDistanceFilter(handle, out custom, out customLevel, out centerFreq);
		}

		public RESULT setUserData(IntPtr userdata)
		{
			return FMOD5_Channel_SetUserData(handle, userdata);
		}

		public RESULT getUserData(out IntPtr userdata)
		{
			return FMOD5_Channel_GetUserData(handle, out userdata);
		}

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetFrequency(IntPtr channel, float frequency);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetFrequency(IntPtr channel, out float frequency);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetPriority(IntPtr channel, int priority);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetPriority(IntPtr channel, out int priority);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetPosition(IntPtr channel, uint position, TIMEUNIT postype);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetPosition(IntPtr channel, out uint position, TIMEUNIT postype);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetChannelGroup(IntPtr channel, IntPtr channelgroup);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetChannelGroup(IntPtr channel, out IntPtr channelgroup);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetLoopCount(IntPtr channel, int loopcount);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetLoopCount(IntPtr channel, out int loopcount);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetLoopPoints(IntPtr channel, uint loopstart, TIMEUNIT loopstarttype, uint loopend, TIMEUNIT loopendtype);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetLoopPoints(IntPtr channel, out uint loopstart, TIMEUNIT loopstarttype, out uint loopend, TIMEUNIT loopendtype);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_IsVirtual(IntPtr channel, out bool isvirtual);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetCurrentSound(IntPtr channel, out IntPtr sound);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetIndex(IntPtr channel, out int index);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetSystemObject(IntPtr channel, out IntPtr system);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_Stop(IntPtr channel);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetPaused(IntPtr channel, bool paused);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetPaused(IntPtr channel, out bool paused);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetVolume(IntPtr channel, float volume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetVolume(IntPtr channel, out float volume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetVolumeRamp(IntPtr channel, bool ramp);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetVolumeRamp(IntPtr channel, out bool ramp);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetAudibility(IntPtr channel, out float audibility);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetPitch(IntPtr channel, float pitch);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetPitch(IntPtr channel, out float pitch);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetMute(IntPtr channel, bool mute);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetMute(IntPtr channel, out bool mute);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetReverbProperties(IntPtr channel, int instance, float wet);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetReverbProperties(IntPtr channel, int instance, out float wet);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetLowPassGain(IntPtr channel, float gain);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetLowPassGain(IntPtr channel, out float gain);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetMode(IntPtr channel, MODE mode);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetMode(IntPtr channel, out MODE mode);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetCallback(IntPtr channel, CHANNEL_CALLBACK callback);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_IsPlaying(IntPtr channel, out bool isplaying);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetPan(IntPtr channel, float pan);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetMixLevelsOutput(IntPtr channel, float frontleft, float frontright, float center, float lfe, float surroundleft, float surroundright, float backleft, float backright);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetMixLevelsInput(IntPtr channel, float[] levels, int numlevels);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetMixMatrix(IntPtr channel, float[] matrix, int outchannels, int inchannels, int inchannel_hop);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetMixMatrix(IntPtr channel, float[] matrix, out int outchannels, out int inchannels, int inchannel_hop);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetDSPClock(IntPtr channel, out ulong dspclock, out ulong parentclock);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetDelay(IntPtr channel, ulong dspclock_start, ulong dspclock_end, bool stopchannels);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetDelay(IntPtr channel, out ulong dspclock_start, out ulong dspclock_end, out bool stopchannels);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_AddFadePoint(IntPtr channel, ulong dspclock, float volume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetFadePointRamp(IntPtr channel, ulong dspclock, float volume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_RemoveFadePoints(IntPtr channel, ulong dspclock_start, ulong dspclock_end);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetFadePoints(IntPtr channel, ref uint numpoints, ulong[] point_dspclock, float[] point_volume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetDSP(IntPtr channel, int index, out IntPtr dsp);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_AddDSP(IntPtr channel, int index, IntPtr dsp);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_RemoveDSP(IntPtr channel, IntPtr dsp);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetNumDSPs(IntPtr channel, out int numdsps);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetDSPIndex(IntPtr channel, IntPtr dsp, int index);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetDSPIndex(IntPtr channel, IntPtr dsp, out int index);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_Set3DAttributes(IntPtr channel, ref VECTOR pos, ref VECTOR vel, ref VECTOR alt_pan_pos);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_Get3DAttributes(IntPtr channel, out VECTOR pos, out VECTOR vel, out VECTOR alt_pan_pos);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_Set3DMinMaxDistance(IntPtr channel, float mindistance, float maxdistance);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_Get3DMinMaxDistance(IntPtr channel, out float mindistance, out float maxdistance);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_Set3DConeSettings(IntPtr channel, float insideconeangle, float outsideconeangle, float outsidevolume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_Get3DConeSettings(IntPtr channel, out float insideconeangle, out float outsideconeangle, out float outsidevolume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_Set3DConeOrientation(IntPtr channel, ref VECTOR orientation);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_Get3DConeOrientation(IntPtr channel, out VECTOR orientation);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_Set3DCustomRolloff(IntPtr channel, ref VECTOR points, int numpoints);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_Get3DCustomRolloff(IntPtr channel, out IntPtr points, out int numpoints);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_Set3DOcclusion(IntPtr channel, float directocclusion, float reverbocclusion);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_Get3DOcclusion(IntPtr channel, out float directocclusion, out float reverbocclusion);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_Set3DSpread(IntPtr channel, float angle);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_Get3DSpread(IntPtr channel, out float angle);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_Set3DLevel(IntPtr channel, float level);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_Get3DLevel(IntPtr channel, out float level);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_Set3DDopplerLevel(IntPtr channel, float level);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_Get3DDopplerLevel(IntPtr channel, out float level);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_Set3DDistanceFilter(IntPtr channel, bool custom, float customLevel, float centerFreq);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_Get3DDistanceFilter(IntPtr channel, out bool custom, out float customLevel, out float centerFreq);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_SetUserData(IntPtr channel, IntPtr userdata);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Channel_GetUserData(IntPtr channel, out IntPtr userdata);

		public bool hasHandle()
		{
			return handle != IntPtr.Zero;
		}

		public void clearHandle()
		{
			handle = IntPtr.Zero;
		}
	}
	public struct ChannelGroup : IChannelControl
	{
		public IntPtr handle;

		public RESULT release()
		{
			return FMOD5_ChannelGroup_Release(handle);
		}

		public RESULT addGroup(ChannelGroup group, bool propagatedspclock, out DSPConnection connection)
		{
			return FMOD5_ChannelGroup_AddGroup(handle, group.handle, propagatedspclock, out connection.handle);
		}

		public RESULT getNumGroups(out int numgroups)
		{
			return FMOD5_ChannelGroup_GetNumGroups(handle, out numgroups);
		}

		public RESULT getGroup(int index, out ChannelGroup group)
		{
			return FMOD5_ChannelGroup_GetGroup(handle, index, out group.handle);
		}

		public RESULT getParentGroup(out ChannelGroup group)
		{
			return FMOD5_ChannelGroup_GetParentGroup(handle, out group.handle);
		}

		public RESULT getName(out string name, int namelen)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(namelen);
			RESULT result = FMOD5_ChannelGroup_GetName(handle, intPtr, namelen);
			using (StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper())
			{
				name = threadSafeEncoding.stringFromNative(intPtr);
			}
			Marshal.FreeHGlobal(intPtr);
			return result;
		}

		public RESULT getNumChannels(out int numchannels)
		{
			return FMOD5_ChannelGroup_GetNumChannels(handle, out numchannels);
		}

		public RESULT getChannel(int index, out Channel channel)
		{
			return FMOD5_ChannelGroup_GetChannel(handle, index, out channel.handle);
		}

		public RESULT getSystemObject(out System system)
		{
			return FMOD5_ChannelGroup_GetSystemObject(handle, out system.handle);
		}

		public RESULT stop()
		{
			return FMOD5_ChannelGroup_Stop(handle);
		}

		public RESULT setPaused(bool paused)
		{
			return FMOD5_ChannelGroup_SetPaused(handle, paused);
		}

		public RESULT getPaused(out bool paused)
		{
			return FMOD5_ChannelGroup_GetPaused(handle, out paused);
		}

		public RESULT setVolume(float volume)
		{
			return FMOD5_ChannelGroup_SetVolume(handle, volume);
		}

		public RESULT getVolume(out float volume)
		{
			return FMOD5_ChannelGroup_GetVolume(handle, out volume);
		}

		public RESULT setVolumeRamp(bool ramp)
		{
			return FMOD5_ChannelGroup_SetVolumeRamp(handle, ramp);
		}

		public RESULT getVolumeRamp(out bool ramp)
		{
			return FMOD5_ChannelGroup_GetVolumeRamp(handle, out ramp);
		}

		public RESULT getAudibility(out float audibility)
		{
			return FMOD5_ChannelGroup_GetAudibility(handle, out audibility);
		}

		public RESULT setPitch(float pitch)
		{
			return FMOD5_ChannelGroup_SetPitch(handle, pitch);
		}

		public RESULT getPitch(out float pitch)
		{
			return FMOD5_ChannelGroup_GetPitch(handle, out pitch);
		}

		public RESULT setMute(bool mute)
		{
			return FMOD5_ChannelGroup_SetMute(handle, mute);
		}

		public RESULT getMute(out bool mute)
		{
			return FMOD5_ChannelGroup_GetMute(handle, out mute);
		}

		public RESULT setReverbProperties(int instance, float wet)
		{
			return FMOD5_ChannelGroup_SetReverbProperties(handle, instance, wet);
		}

		public RESULT getReverbProperties(int instance, out float wet)
		{
			return FMOD5_ChannelGroup_GetReverbProperties(handle, instance, out wet);
		}

		public RESULT setLowPassGain(float gain)
		{
			return FMOD5_ChannelGroup_SetLowPassGain(handle, gain);
		}

		public RESULT getLowPassGain(out float gain)
		{
			return FMOD5_ChannelGroup_GetLowPassGain(handle, out gain);
		}

		public RESULT setMode(MODE mode)
		{
			return FMOD5_ChannelGroup_SetMode(handle, mode);
		}

		public RESULT getMode(out MODE mode)
		{
			return FMOD5_ChannelGroup_GetMode(handle, out mode);
		}

		public RESULT setCallback(CHANNEL_CALLBACK callback)
		{
			return FMOD5_ChannelGroup_SetCallback(handle, callback);
		}

		public RESULT isPlaying(out bool isplaying)
		{
			return FMOD5_ChannelGroup_IsPlaying(handle, out isplaying);
		}

		public RESULT setPan(float pan)
		{
			return FMOD5_ChannelGroup_SetPan(handle, pan);
		}

		public RESULT setMixLevelsOutput(float frontleft, float frontright, float center, float lfe, float surroundleft, float surroundright, float backleft, float backright)
		{
			return FMOD5_ChannelGroup_SetMixLevelsOutput(handle, frontleft, frontright, center, lfe, surroundleft, surroundright, backleft, backright);
		}

		public RESULT setMixLevelsInput(float[] levels, int numlevels)
		{
			return FMOD5_ChannelGroup_SetMixLevelsInput(handle, levels, numlevels);
		}

		public RESULT setMixMatrix(float[] matrix, int outchannels, int inchannels, int inchannel_hop)
		{
			return FMOD5_ChannelGroup_SetMixMatrix(handle, matrix, outchannels, inchannels, inchannel_hop);
		}

		public RESULT getMixMatrix(float[] matrix, out int outchannels, out int inchannels, int inchannel_hop)
		{
			return FMOD5_ChannelGroup_GetMixMatrix(handle, matrix, out outchannels, out inchannels, inchannel_hop);
		}

		public RESULT getDSPClock(out ulong dspclock, out ulong parentclock)
		{
			return FMOD5_ChannelGroup_GetDSPClock(handle, out dspclock, out parentclock);
		}

		public RESULT setDelay(ulong dspclock_start, ulong dspclock_end, bool stopchannels)
		{
			return FMOD5_ChannelGroup_SetDelay(handle, dspclock_start, dspclock_end, stopchannels);
		}

		public RESULT getDelay(out ulong dspclock_start, out ulong dspclock_end, out bool stopchannels)
		{
			return FMOD5_ChannelGroup_GetDelay(handle, out dspclock_start, out dspclock_end, out stopchannels);
		}

		public RESULT addFadePoint(ulong dspclock, float volume)
		{
			return FMOD5_ChannelGroup_AddFadePoint(handle, dspclock, volume);
		}

		public RESULT setFadePointRamp(ulong dspclock, float volume)
		{
			return FMOD5_ChannelGroup_SetFadePointRamp(handle, dspclock, volume);
		}

		public RESULT removeFadePoints(ulong dspclock_start, ulong dspclock_end)
		{
			return FMOD5_ChannelGroup_RemoveFadePoints(handle, dspclock_start, dspclock_end);
		}

		public RESULT getFadePoints(ref uint numpoints, ulong[] point_dspclock, float[] point_volume)
		{
			return FMOD5_ChannelGroup_GetFadePoints(handle, ref numpoints, point_dspclock, point_volume);
		}

		public RESULT getDSP(int index, out DSP dsp)
		{
			return FMOD5_ChannelGroup_GetDSP(handle, index, out dsp.handle);
		}

		public RESULT addDSP(int index, DSP dsp)
		{
			return FMOD5_ChannelGroup_AddDSP(handle, index, dsp.handle);
		}

		public RESULT removeDSP(DSP dsp)
		{
			return FMOD5_ChannelGroup_RemoveDSP(handle, dsp.handle);
		}

		public RESULT getNumDSPs(out int numdsps)
		{
			return FMOD5_ChannelGroup_GetNumDSPs(handle, out numdsps);
		}

		public RESULT setDSPIndex(DSP dsp, int index)
		{
			return FMOD5_ChannelGroup_SetDSPIndex(handle, dsp.handle, index);
		}

		public RESULT getDSPIndex(DSP dsp, out int index)
		{
			return FMOD5_ChannelGroup_GetDSPIndex(handle, dsp.handle, out index);
		}

		public RESULT set3DAttributes(ref VECTOR pos, ref VECTOR vel, ref VECTOR alt_pan_pos)
		{
			return FMOD5_ChannelGroup_Set3DAttributes(handle, ref pos, ref vel, ref alt_pan_pos);
		}

		public RESULT get3DAttributes(out VECTOR pos, out VECTOR vel, out VECTOR alt_pan_pos)
		{
			return FMOD5_ChannelGroup_Get3DAttributes(handle, out pos, out vel, out alt_pan_pos);
		}

		public RESULT set3DMinMaxDistance(float mindistance, float maxdistance)
		{
			return FMOD5_ChannelGroup_Set3DMinMaxDistance(handle, mindistance, maxdistance);
		}

		public RESULT get3DMinMaxDistance(out float mindistance, out float maxdistance)
		{
			return FMOD5_ChannelGroup_Get3DMinMaxDistance(handle, out mindistance, out maxdistance);
		}

		public RESULT set3DConeSettings(float insideconeangle, float outsideconeangle, float outsidevolume)
		{
			return FMOD5_ChannelGroup_Set3DConeSettings(handle, insideconeangle, outsideconeangle, outsidevolume);
		}

		public RESULT get3DConeSettings(out float insideconeangle, out float outsideconeangle, out float outsidevolume)
		{
			return FMOD5_ChannelGroup_Get3DConeSettings(handle, out insideconeangle, out outsideconeangle, out outsidevolume);
		}

		public RESULT set3DConeOrientation(ref VECTOR orientation)
		{
			return FMOD5_ChannelGroup_Set3DConeOrientation(handle, ref orientation);
		}

		public RESULT get3DConeOrientation(out VECTOR orientation)
		{
			return FMOD5_ChannelGroup_Get3DConeOrientation(handle, out orientation);
		}

		public RESULT set3DCustomRolloff(ref VECTOR points, int numpoints)
		{
			return FMOD5_ChannelGroup_Set3DCustomRolloff(handle, ref points, numpoints);
		}

		public RESULT get3DCustomRolloff(out IntPtr points, out int numpoints)
		{
			return FMOD5_ChannelGroup_Get3DCustomRolloff(handle, out points, out numpoints);
		}

		public RESULT set3DOcclusion(float directocclusion, float reverbocclusion)
		{
			return FMOD5_ChannelGroup_Set3DOcclusion(handle, directocclusion, reverbocclusion);
		}

		public RESULT get3DOcclusion(out float directocclusion, out float reverbocclusion)
		{
			return FMOD5_ChannelGroup_Get3DOcclusion(handle, out directocclusion, out reverbocclusion);
		}

		public RESULT set3DSpread(float angle)
		{
			return FMOD5_ChannelGroup_Set3DSpread(handle, angle);
		}

		public RESULT get3DSpread(out float angle)
		{
			return FMOD5_ChannelGroup_Get3DSpread(handle, out angle);
		}

		public RESULT set3DLevel(float level)
		{
			return FMOD5_ChannelGroup_Set3DLevel(handle, level);
		}

		public RESULT get3DLevel(out float level)
		{
			return FMOD5_ChannelGroup_Get3DLevel(handle, out level);
		}

		public RESULT set3DDopplerLevel(float level)
		{
			return FMOD5_ChannelGroup_Set3DDopplerLevel(handle, level);
		}

		public RESULT get3DDopplerLevel(out float level)
		{
			return FMOD5_ChannelGroup_Get3DDopplerLevel(handle, out level);
		}

		public RESULT set3DDistanceFilter(bool custom, float customLevel, float centerFreq)
		{
			return FMOD5_ChannelGroup_Set3DDistanceFilter(handle, custom, customLevel, centerFreq);
		}

		public RESULT get3DDistanceFilter(out bool custom, out float customLevel, out float centerFreq)
		{
			return FMOD5_ChannelGroup_Get3DDistanceFilter(handle, out custom, out customLevel, out centerFreq);
		}

		public RESULT setUserData(IntPtr userdata)
		{
			return FMOD5_ChannelGroup_SetUserData(handle, userdata);
		}

		public RESULT getUserData(out IntPtr userdata)
		{
			return FMOD5_ChannelGroup_GetUserData(handle, out userdata);
		}

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Release(IntPtr channelgroup);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_AddGroup(IntPtr channelgroup, IntPtr group, bool propogatedspclocks, out IntPtr connection);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetNumGroups(IntPtr channelgroup, out int numgroups);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetGroup(IntPtr channelgroup, int index, out IntPtr group);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetParentGroup(IntPtr channelgroup, out IntPtr group);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetName(IntPtr channelgroup, IntPtr name, int namelen);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetNumChannels(IntPtr channelgroup, out int numchannels);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetChannel(IntPtr channelgroup, int index, out IntPtr channel);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetSystemObject(IntPtr channelgroup, out IntPtr system);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Stop(IntPtr channelgroup);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_SetPaused(IntPtr channelgroup, bool paused);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetPaused(IntPtr channelgroup, out bool paused);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_SetVolume(IntPtr channelgroup, float volume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetVolume(IntPtr channelgroup, out float volume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_SetVolumeRamp(IntPtr channelgroup, bool ramp);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetVolumeRamp(IntPtr channelgroup, out bool ramp);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetAudibility(IntPtr channelgroup, out float audibility);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_SetPitch(IntPtr channelgroup, float pitch);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetPitch(IntPtr channelgroup, out float pitch);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_SetMute(IntPtr channelgroup, bool mute);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetMute(IntPtr channelgroup, out bool mute);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_SetReverbProperties(IntPtr channelgroup, int instance, float wet);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetReverbProperties(IntPtr channelgroup, int instance, out float wet);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_SetLowPassGain(IntPtr channelgroup, float gain);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetLowPassGain(IntPtr channelgroup, out float gain);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_SetMode(IntPtr channelgroup, MODE mode);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetMode(IntPtr channelgroup, out MODE mode);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_SetCallback(IntPtr channelgroup, CHANNEL_CALLBACK callback);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_IsPlaying(IntPtr channelgroup, out bool isplaying);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_SetPan(IntPtr channelgroup, float pan);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_SetMixLevelsOutput(IntPtr channelgroup, float frontleft, float frontright, float center, float lfe, float surroundleft, float surroundright, float backleft, float backright);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_SetMixLevelsInput(IntPtr channelgroup, float[] levels, int numlevels);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_SetMixMatrix(IntPtr channelgroup, float[] matrix, int outchannels, int inchannels, int inchannel_hop);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetMixMatrix(IntPtr channelgroup, float[] matrix, out int outchannels, out int inchannels, int inchannel_hop);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetDSPClock(IntPtr channelgroup, out ulong dspclock, out ulong parentclock);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_SetDelay(IntPtr channelgroup, ulong dspclock_start, ulong dspclock_end, bool stopchannels);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetDelay(IntPtr channelgroup, out ulong dspclock_start, out ulong dspclock_end, out bool stopchannels);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_AddFadePoint(IntPtr channelgroup, ulong dspclock, float volume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_SetFadePointRamp(IntPtr channelgroup, ulong dspclock, float volume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_RemoveFadePoints(IntPtr channelgroup, ulong dspclock_start, ulong dspclock_end);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetFadePoints(IntPtr channelgroup, ref uint numpoints, ulong[] point_dspclock, float[] point_volume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetDSP(IntPtr channelgroup, int index, out IntPtr dsp);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_AddDSP(IntPtr channelgroup, int index, IntPtr dsp);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_RemoveDSP(IntPtr channelgroup, IntPtr dsp);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetNumDSPs(IntPtr channelgroup, out int numdsps);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_SetDSPIndex(IntPtr channelgroup, IntPtr dsp, int index);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetDSPIndex(IntPtr channelgroup, IntPtr dsp, out int index);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Set3DAttributes(IntPtr channelgroup, ref VECTOR pos, ref VECTOR vel, ref VECTOR alt_pan_pos);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Get3DAttributes(IntPtr channelgroup, out VECTOR pos, out VECTOR vel, out VECTOR alt_pan_pos);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Set3DMinMaxDistance(IntPtr channelgroup, float mindistance, float maxdistance);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Get3DMinMaxDistance(IntPtr channelgroup, out float mindistance, out float maxdistance);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Set3DConeSettings(IntPtr channelgroup, float insideconeangle, float outsideconeangle, float outsidevolume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Get3DConeSettings(IntPtr channelgroup, out float insideconeangle, out float outsideconeangle, out float outsidevolume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Set3DConeOrientation(IntPtr channelgroup, ref VECTOR orientation);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Get3DConeOrientation(IntPtr channelgroup, out VECTOR orientation);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Set3DCustomRolloff(IntPtr channelgroup, ref VECTOR points, int numpoints);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Get3DCustomRolloff(IntPtr channelgroup, out IntPtr points, out int numpoints);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Set3DOcclusion(IntPtr channelgroup, float directocclusion, float reverbocclusion);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Get3DOcclusion(IntPtr channelgroup, out float directocclusion, out float reverbocclusion);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Set3DSpread(IntPtr channelgroup, float angle);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Get3DSpread(IntPtr channelgroup, out float angle);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Set3DLevel(IntPtr channelgroup, float level);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Get3DLevel(IntPtr channelgroup, out float level);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Set3DDopplerLevel(IntPtr channelgroup, float level);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Get3DDopplerLevel(IntPtr channelgroup, out float level);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Set3DDistanceFilter(IntPtr channelgroup, bool custom, float customLevel, float centerFreq);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_Get3DDistanceFilter(IntPtr channelgroup, out bool custom, out float customLevel, out float centerFreq);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_SetUserData(IntPtr channelgroup, IntPtr userdata);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_ChannelGroup_GetUserData(IntPtr channelgroup, out IntPtr userdata);

		public bool hasHandle()
		{
			return handle != IntPtr.Zero;
		}

		public void clearHandle()
		{
			handle = IntPtr.Zero;
		}
	}
	public struct SoundGroup
	{
		public IntPtr handle;

		public RESULT release()
		{
			return FMOD5_SoundGroup_Release(handle);
		}

		public RESULT getSystemObject(out System system)
		{
			return FMOD5_SoundGroup_GetSystemObject(handle, out system.handle);
		}

		public RESULT setMaxAudible(int maxaudible)
		{
			return FMOD5_SoundGroup_SetMaxAudible(handle, maxaudible);
		}

		public RESULT getMaxAudible(out int maxaudible)
		{
			return FMOD5_SoundGroup_GetMaxAudible(handle, out maxaudible);
		}

		public RESULT setMaxAudibleBehavior(SOUNDGROUP_BEHAVIOR behavior)
		{
			return FMOD5_SoundGroup_SetMaxAudibleBehavior(handle, behavior);
		}

		public RESULT getMaxAudibleBehavior(out SOUNDGROUP_BEHAVIOR behavior)
		{
			return FMOD5_SoundGroup_GetMaxAudibleBehavior(handle, out behavior);
		}

		public RESULT setMuteFadeSpeed(float speed)
		{
			return FMOD5_SoundGroup_SetMuteFadeSpeed(handle, speed);
		}

		public RESULT getMuteFadeSpeed(out float speed)
		{
			return FMOD5_SoundGroup_GetMuteFadeSpeed(handle, out speed);
		}

		public RESULT setVolume(float volume)
		{
			return FMOD5_SoundGroup_SetVolume(handle, volume);
		}

		public RESULT getVolume(out float volume)
		{
			return FMOD5_SoundGroup_GetVolume(handle, out volume);
		}

		public RESULT stop()
		{
			return FMOD5_SoundGroup_Stop(handle);
		}

		public RESULT getName(out string name, int namelen)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(namelen);
			RESULT result = FMOD5_SoundGroup_GetName(handle, intPtr, namelen);
			using (StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper())
			{
				name = threadSafeEncoding.stringFromNative(intPtr);
			}
			Marshal.FreeHGlobal(intPtr);
			return result;
		}

		public RESULT getNumSounds(out int numsounds)
		{
			return FMOD5_SoundGroup_GetNumSounds(handle, out numsounds);
		}

		public RESULT getSound(int index, out Sound sound)
		{
			return FMOD5_SoundGroup_GetSound(handle, index, out sound.handle);
		}

		public RESULT getNumPlaying(out int numplaying)
		{
			return FMOD5_SoundGroup_GetNumPlaying(handle, out numplaying);
		}

		public RESULT setUserData(IntPtr userdata)
		{
			return FMOD5_SoundGroup_SetUserData(handle, userdata);
		}

		public RESULT getUserData(out IntPtr userdata)
		{
			return FMOD5_SoundGroup_GetUserData(handle, out userdata);
		}

		[DllImport("fmod")]
		private static extern RESULT FMOD5_SoundGroup_Release(IntPtr soundgroup);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_SoundGroup_GetSystemObject(IntPtr soundgroup, out IntPtr system);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_SoundGroup_SetMaxAudible(IntPtr soundgroup, int maxaudible);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_SoundGroup_GetMaxAudible(IntPtr soundgroup, out int maxaudible);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_SoundGroup_SetMaxAudibleBehavior(IntPtr soundgroup, SOUNDGROUP_BEHAVIOR behavior);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_SoundGroup_GetMaxAudibleBehavior(IntPtr soundgroup, out SOUNDGROUP_BEHAVIOR behavior);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_SoundGroup_SetMuteFadeSpeed(IntPtr soundgroup, float speed);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_SoundGroup_GetMuteFadeSpeed(IntPtr soundgroup, out float speed);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_SoundGroup_SetVolume(IntPtr soundgroup, float volume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_SoundGroup_GetVolume(IntPtr soundgroup, out float volume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_SoundGroup_Stop(IntPtr soundgroup);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_SoundGroup_GetName(IntPtr soundgroup, IntPtr name, int namelen);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_SoundGroup_GetNumSounds(IntPtr soundgroup, out int numsounds);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_SoundGroup_GetSound(IntPtr soundgroup, int index, out IntPtr sound);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_SoundGroup_GetNumPlaying(IntPtr soundgroup, out int numplaying);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_SoundGroup_SetUserData(IntPtr soundgroup, IntPtr userdata);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_SoundGroup_GetUserData(IntPtr soundgroup, out IntPtr userdata);

		public bool hasHandle()
		{
			return handle != IntPtr.Zero;
		}

		public void clearHandle()
		{
			handle = IntPtr.Zero;
		}
	}
	public struct DSP
	{
		public IntPtr handle;

		public RESULT release()
		{
			return FMOD5_DSP_Release(handle);
		}

		public RESULT getSystemObject(out System system)
		{
			return FMOD5_DSP_GetSystemObject(handle, out system.handle);
		}

		public RESULT addInput(DSP target, out DSPConnection connection, DSPCONNECTION_TYPE type)
		{
			return FMOD5_DSP_AddInput(handle, target.handle, out connection.handle, type);
		}

		public RESULT disconnectFrom(DSP target, DSPConnection connection)
		{
			return FMOD5_DSP_DisconnectFrom(handle, target.handle, connection.handle);
		}

		public RESULT disconnectAll(bool inputs, bool outputs)
		{
			return FMOD5_DSP_DisconnectAll(handle, inputs, outputs);
		}

		public RESULT getNumInputs(out int numinputs)
		{
			return FMOD5_DSP_GetNumInputs(handle, out numinputs);
		}

		public RESULT getNumOutputs(out int numoutputs)
		{
			return FMOD5_DSP_GetNumOutputs(handle, out numoutputs);
		}

		public RESULT getInput(int index, out DSP input, out DSPConnection inputconnection)
		{
			return FMOD5_DSP_GetInput(handle, index, out input.handle, out inputconnection.handle);
		}

		public RESULT getOutput(int index, out DSP output, out DSPConnection outputconnection)
		{
			return FMOD5_DSP_GetOutput(handle, index, out output.handle, out outputconnection.handle);
		}

		public RESULT setActive(bool active)
		{
			return FMOD5_DSP_SetActive(handle, active);
		}

		public RESULT getActive(out bool active)
		{
			return FMOD5_DSP_GetActive(handle, out active);
		}

		public RESULT setBypass(bool bypass)
		{
			return FMOD5_DSP_SetBypass(handle, bypass);
		}

		public RESULT getBypass(out bool bypass)
		{
			return FMOD5_DSP_GetBypass(handle, out bypass);
		}

		public RESULT setWetDryMix(float prewet, float postwet, float dry)
		{
			return FMOD5_DSP_SetWetDryMix(handle, prewet, postwet, dry);
		}

		public RESULT getWetDryMix(out float prewet, out float postwet, out float dry)
		{
			return FMOD5_DSP_GetWetDryMix(handle, out prewet, out postwet, out dry);
		}

		public RESULT setChannelFormat(CHANNELMASK channelmask, int numchannels, SPEAKERMODE source_speakermode)
		{
			return FMOD5_DSP_SetChannelFormat(handle, channelmask, numchannels, source_speakermode);
		}

		public RESULT getChannelFormat(out CHANNELMASK channelmask, out int numchannels, out SPEAKERMODE source_speakermode)
		{
			return FMOD5_DSP_GetChannelFormat(handle, out channelmask, out numchannels, out source_speakermode);
		}

		public RESULT getOutputChannelFormat(CHANNELMASK inmask, int inchannels, SPEAKERMODE inspeakermode, out CHANNELMASK outmask, out int outchannels, out SPEAKERMODE outspeakermode)
		{
			return FMOD5_DSP_GetOutputChannelFormat(handle, inmask, inchannels, inspeakermode, out outmask, out outchannels, out outspeakermode);
		}

		public RESULT reset()
		{
			return FMOD5_DSP_Reset(handle);
		}

		public RESULT setParameterFloat(int index, float value)
		{
			return FMOD5_DSP_SetParameterFloat(handle, index, value);
		}

		public RESULT setParameterInt(int index, int value)
		{
			return FMOD5_DSP_SetParameterInt(handle, index, value);
		}

		public RESULT setParameterBool(int index, bool value)
		{
			return FMOD5_DSP_SetParameterBool(handle, index, value);
		}

		public RESULT setParameterData(int index, byte[] data)
		{
			return FMOD5_DSP_SetParameterData(handle, index, Marshal.UnsafeAddrOfPinnedArrayElement(data, 0), (uint)data.Length);
		}

		public RESULT getParameterFloat(int index, out float value)
		{
			return FMOD5_DSP_GetParameterFloat(handle, index, out value, IntPtr.Zero, 0);
		}

		public RESULT getParameterInt(int index, out int value)
		{
			return FMOD5_DSP_GetParameterInt(handle, index, out value, IntPtr.Zero, 0);
		}

		public RESULT getParameterBool(int index, out bool value)
		{
			return FMOD5_DSP_GetParameterBool(handle, index, out value, IntPtr.Zero, 0);
		}

		public RESULT getParameterData(int index, out IntPtr data, out uint length)
		{
			return FMOD5_DSP_GetParameterData(handle, index, out data, out length, IntPtr.Zero, 0);
		}

		public RESULT getNumParameters(out int numparams)
		{
			return FMOD5_DSP_GetNumParameters(handle, out numparams);
		}

		public RESULT getParameterInfo(int index, out DSP_PARAMETER_DESC desc)
		{
			return FMOD5_DSP_GetParameterInfo(handle, index, out desc);
		}

		public RESULT getDataParameterIndex(int datatype, out int index)
		{
			return FMOD5_DSP_GetDataParameterIndex(handle, datatype, out index);
		}

		public RESULT showConfigDialog(IntPtr hwnd, bool show)
		{
			return FMOD5_DSP_ShowConfigDialog(handle, hwnd, show);
		}

		public RESULT getInfo(out string name, out uint version, out int channels, out int configwidth, out int configheight)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(32);
			RESULT result = FMOD5_DSP_GetInfo(handle, intPtr, out version, out channels, out configwidth, out configheight);
			using (StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper())
			{
				name = threadSafeEncoding.stringFromNative(intPtr);
			}
			Marshal.FreeHGlobal(intPtr);
			return result;
		}

		public RESULT getInfo(out uint version, out int channels, out int configwidth, out int configheight)
		{
			return FMOD5_DSP_GetInfo(handle, IntPtr.Zero, out version, out channels, out configwidth, out configheight);
		}

		public RESULT getType(out DSP_TYPE type)
		{
			return FMOD5_DSP_GetType(handle, out type);
		}

		public RESULT getIdle(out bool idle)
		{
			return FMOD5_DSP_GetIdle(handle, out idle);
		}

		public RESULT setUserData(IntPtr userdata)
		{
			return FMOD5_DSP_SetUserData(handle, userdata);
		}

		public RESULT getUserData(out IntPtr userdata)
		{
			return FMOD5_DSP_GetUserData(handle, out userdata);
		}

		public RESULT setMeteringEnabled(bool inputEnabled, bool outputEnabled)
		{
			return FMOD5_DSP_SetMeteringEnabled(handle, inputEnabled, outputEnabled);
		}

		public RESULT getMeteringEnabled(out bool inputEnabled, out bool outputEnabled)
		{
			return FMOD5_DSP_GetMeteringEnabled(handle, out inputEnabled, out outputEnabled);
		}

		public RESULT getMeteringInfo(IntPtr zero, out DSP_METERING_INFO outputInfo)
		{
			return FMOD5_DSP_GetMeteringInfo(handle, zero, out outputInfo);
		}

		public RESULT getMeteringInfo(out DSP_METERING_INFO inputInfo, IntPtr zero)
		{
			return FMOD5_DSP_GetMeteringInfo(handle, out inputInfo, zero);
		}

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_Release(IntPtr dsp);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_GetSystemObject(IntPtr dsp, out IntPtr system);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_AddInput(IntPtr dsp, IntPtr target, out IntPtr connection, DSPCONNECTION_TYPE type);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_DisconnectFrom(IntPtr dsp, IntPtr target, IntPtr connection);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_DisconnectAll(IntPtr dsp, bool inputs, bool outputs);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_GetNumInputs(IntPtr dsp, out int numinputs);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_GetNumOutputs(IntPtr dsp, out int numoutputs);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_GetInput(IntPtr dsp, int index, out IntPtr input, out IntPtr inputconnection);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_GetOutput(IntPtr dsp, int index, out IntPtr output, out IntPtr outputconnection);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_SetActive(IntPtr dsp, bool active);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_GetActive(IntPtr dsp, out bool active);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_SetBypass(IntPtr dsp, bool bypass);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_GetBypass(IntPtr dsp, out bool bypass);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_SetWetDryMix(IntPtr dsp, float prewet, float postwet, float dry);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_GetWetDryMix(IntPtr dsp, out float prewet, out float postwet, out float dry);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_SetChannelFormat(IntPtr dsp, CHANNELMASK channelmask, int numchannels, SPEAKERMODE source_speakermode);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_GetChannelFormat(IntPtr dsp, out CHANNELMASK channelmask, out int numchannels, out SPEAKERMODE source_speakermode);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_GetOutputChannelFormat(IntPtr dsp, CHANNELMASK inmask, int inchannels, SPEAKERMODE inspeakermode, out CHANNELMASK outmask, out int outchannels, out SPEAKERMODE outspeakermode);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_Reset(IntPtr dsp);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_SetParameterFloat(IntPtr dsp, int index, float value);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_SetParameterInt(IntPtr dsp, int index, int value);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_SetParameterBool(IntPtr dsp, int index, bool value);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_SetParameterData(IntPtr dsp, int index, IntPtr data, uint length);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_GetParameterFloat(IntPtr dsp, int index, out float value, IntPtr valuestr, int valuestrlen);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_GetParameterInt(IntPtr dsp, int index, out int value, IntPtr valuestr, int valuestrlen);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_GetParameterBool(IntPtr dsp, int index, out bool value, IntPtr valuestr, int valuestrlen);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_GetParameterData(IntPtr dsp, int index, out IntPtr data, out uint length, IntPtr valuestr, int valuestrlen);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_GetNumParameters(IntPtr dsp, out int numparams);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_GetParameterInfo(IntPtr dsp, int index, out DSP_PARAMETER_DESC desc);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_GetDataParameterIndex(IntPtr dsp, int datatype, out int index);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_ShowConfigDialog(IntPtr dsp, IntPtr hwnd, bool show);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_GetInfo(IntPtr dsp, IntPtr name, out uint version, out int channels, out int configwidth, out int configheight);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_GetType(IntPtr dsp, out DSP_TYPE type);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_GetIdle(IntPtr dsp, out bool idle);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_SetUserData(IntPtr dsp, IntPtr userdata);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSP_GetUserData(IntPtr dsp, out IntPtr userdata);

		[DllImport("fmod")]
		public static extern RESULT FMOD5_DSP_SetMeteringEnabled(IntPtr dsp, bool inputEnabled, bool outputEnabled);

		[DllImport("fmod")]
		public static extern RESULT FMOD5_DSP_GetMeteringEnabled(IntPtr dsp, out bool inputEnabled, out bool outputEnabled);

		[DllImport("fmod")]
		public static extern RESULT FMOD5_DSP_GetMeteringInfo(IntPtr dsp, IntPtr zero, out DSP_METERING_INFO outputInfo);

		[DllImport("fmod")]
		public static extern RESULT FMOD5_DSP_GetMeteringInfo(IntPtr dsp, out DSP_METERING_INFO inputInfo, IntPtr zero);

		public bool hasHandle()
		{
			return handle != IntPtr.Zero;
		}

		public void clearHandle()
		{
			handle = IntPtr.Zero;
		}
	}
	public struct DSPConnection
	{
		public IntPtr handle;

		public RESULT getInput(out DSP input)
		{
			return FMOD5_DSPConnection_GetInput(handle, out input.handle);
		}

		public RESULT getOutput(out DSP output)
		{
			return FMOD5_DSPConnection_GetOutput(handle, out output.handle);
		}

		public RESULT setMix(float volume)
		{
			return FMOD5_DSPConnection_SetMix(handle, volume);
		}

		public RESULT getMix(out float volume)
		{
			return FMOD5_DSPConnection_GetMix(handle, out volume);
		}

		public RESULT setMixMatrix(float[] matrix, int outchannels, int inchannels, int inchannel_hop)
		{
			return FMOD5_DSPConnection_SetMixMatrix(handle, matrix, outchannels, inchannels, inchannel_hop);
		}

		public RESULT getMixMatrix(float[] matrix, out int outchannels, out int inchannels, int inchannel_hop)
		{
			return FMOD5_DSPConnection_GetMixMatrix(handle, matrix, out outchannels, out inchannels, inchannel_hop);
		}

		public RESULT getType(out DSPCONNECTION_TYPE type)
		{
			return FMOD5_DSPConnection_GetType(handle, out type);
		}

		public RESULT setUserData(IntPtr userdata)
		{
			return FMOD5_DSPConnection_SetUserData(handle, userdata);
		}

		public RESULT getUserData(out IntPtr userdata)
		{
			return FMOD5_DSPConnection_GetUserData(handle, out userdata);
		}

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSPConnection_GetInput(IntPtr dspconnection, out IntPtr input);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSPConnection_GetOutput(IntPtr dspconnection, out IntPtr output);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSPConnection_SetMix(IntPtr dspconnection, float volume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSPConnection_GetMix(IntPtr dspconnection, out float volume);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSPConnection_SetMixMatrix(IntPtr dspconnection, float[] matrix, int outchannels, int inchannels, int inchannel_hop);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSPConnection_GetMixMatrix(IntPtr dspconnection, float[] matrix, out int outchannels, out int inchannels, int inchannel_hop);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSPConnection_GetType(IntPtr dspconnection, out DSPCONNECTION_TYPE type);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSPConnection_SetUserData(IntPtr dspconnection, IntPtr userdata);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_DSPConnection_GetUserData(IntPtr dspconnection, out IntPtr userdata);

		public bool hasHandle()
		{
			return handle != IntPtr.Zero;
		}

		public void clearHandle()
		{
			handle = IntPtr.Zero;
		}
	}
	public struct Geometry
	{
		public IntPtr handle;

		public RESULT release()
		{
			return FMOD5_Geometry_Release(handle);
		}

		public RESULT addPolygon(float directocclusion, float reverbocclusion, bool doublesided, int numvertices, VECTOR[] vertices, out int polygonindex)
		{
			return FMOD5_Geometry_AddPolygon(handle, directocclusion, reverbocclusion, doublesided, numvertices, vertices, out polygonindex);
		}

		public RESULT getNumPolygons(out int numpolygons)
		{
			return FMOD5_Geometry_GetNumPolygons(handle, out numpolygons);
		}

		public RESULT getMaxPolygons(out int maxpolygons, out int maxvertices)
		{
			return FMOD5_Geometry_GetMaxPolygons(handle, out maxpolygons, out maxvertices);
		}

		public RESULT getPolygonNumVertices(int index, out int numvertices)
		{
			return FMOD5_Geometry_GetPolygonNumVertices(handle, index, out numvertices);
		}

		public RESULT setPolygonVertex(int index, int vertexindex, ref VECTOR vertex)
		{
			return FMOD5_Geometry_SetPolygonVertex(handle, index, vertexindex, ref vertex);
		}

		public RESULT getPolygonVertex(int index, int vertexindex, out VECTOR vertex)
		{
			return FMOD5_Geometry_GetPolygonVertex(handle, index, vertexindex, out vertex);
		}

		public RESULT setPolygonAttributes(int index, float directocclusion, float reverbocclusion, bool doublesided)
		{
			return FMOD5_Geometry_SetPolygonAttributes(handle, index, directocclusion, reverbocclusion, doublesided);
		}

		public RESULT getPolygonAttributes(int index, out float directocclusion, out float reverbocclusion, out bool doublesided)
		{
			return FMOD5_Geometry_GetPolygonAttributes(handle, index, out directocclusion, out reverbocclusion, out doublesided);
		}

		public RESULT setActive(bool active)
		{
			return FMOD5_Geometry_SetActive(handle, active);
		}

		public RESULT getActive(out bool active)
		{
			return FMOD5_Geometry_GetActive(handle, out active);
		}

		public RESULT setRotation(ref VECTOR forward, ref VECTOR up)
		{
			return FMOD5_Geometry_SetRotation(handle, ref forward, ref up);
		}

		public RESULT getRotation(out VECTOR forward, out VECTOR up)
		{
			return FMOD5_Geometry_GetRotation(handle, out forward, out up);
		}

		public RESULT setPosition(ref VECTOR position)
		{
			return FMOD5_Geometry_SetPosition(handle, ref position);
		}

		public RESULT getPosition(out VECTOR position)
		{
			return FMOD5_Geometry_GetPosition(handle, out position);
		}

		public RESULT setScale(ref VECTOR scale)
		{
			return FMOD5_Geometry_SetScale(handle, ref scale);
		}

		public RESULT getScale(out VECTOR scale)
		{
			return FMOD5_Geometry_GetScale(handle, out scale);
		}

		public RESULT save(IntPtr data, out int datasize)
		{
			return FMOD5_Geometry_Save(handle, data, out datasize);
		}

		public RESULT setUserData(IntPtr userdata)
		{
			return FMOD5_Geometry_SetUserData(handle, userdata);
		}

		public RESULT getUserData(out IntPtr userdata)
		{
			return FMOD5_Geometry_GetUserData(handle, out userdata);
		}

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Geometry_Release(IntPtr geometry);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Geometry_AddPolygon(IntPtr geometry, float directocclusion, float reverbocclusion, bool doublesided, int numvertices, VECTOR[] vertices, out int polygonindex);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Geometry_GetNumPolygons(IntPtr geometry, out int numpolygons);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Geometry_GetMaxPolygons(IntPtr geometry, out int maxpolygons, out int maxvertices);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Geometry_GetPolygonNumVertices(IntPtr geometry, int index, out int numvertices);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Geometry_SetPolygonVertex(IntPtr geometry, int index, int vertexindex, ref VECTOR vertex);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Geometry_GetPolygonVertex(IntPtr geometry, int index, int vertexindex, out VECTOR vertex);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Geometry_SetPolygonAttributes(IntPtr geometry, int index, float directocclusion, float reverbocclusion, bool doublesided);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Geometry_GetPolygonAttributes(IntPtr geometry, int index, out float directocclusion, out float reverbocclusion, out bool doublesided);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Geometry_SetActive(IntPtr geometry, bool active);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Geometry_GetActive(IntPtr geometry, out bool active);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Geometry_SetRotation(IntPtr geometry, ref VECTOR forward, ref VECTOR up);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Geometry_GetRotation(IntPtr geometry, out VECTOR forward, out VECTOR up);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Geometry_SetPosition(IntPtr geometry, ref VECTOR position);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Geometry_GetPosition(IntPtr geometry, out VECTOR position);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Geometry_SetScale(IntPtr geometry, ref VECTOR scale);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Geometry_GetScale(IntPtr geometry, out VECTOR scale);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Geometry_Save(IntPtr geometry, IntPtr data, out int datasize);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Geometry_SetUserData(IntPtr geometry, IntPtr userdata);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Geometry_GetUserData(IntPtr geometry, out IntPtr userdata);

		public bool hasHandle()
		{
			return handle != IntPtr.Zero;
		}

		public void clearHandle()
		{
			handle = IntPtr.Zero;
		}
	}
	public struct Reverb3D
	{
		public IntPtr handle;

		public RESULT release()
		{
			return FMOD5_Reverb3D_Release(handle);
		}

		public RESULT set3DAttributes(ref VECTOR position, float mindistance, float maxdistance)
		{
			return FMOD5_Reverb3D_Set3DAttributes(handle, ref position, mindistance, maxdistance);
		}

		public RESULT get3DAttributes(ref VECTOR position, ref float mindistance, ref float maxdistance)
		{
			return FMOD5_Reverb3D_Get3DAttributes(handle, ref position, ref mindistance, ref maxdistance);
		}

		public RESULT setProperties(ref REVERB_PROPERTIES properties)
		{
			return FMOD5_Reverb3D_SetProperties(handle, ref properties);
		}

		public RESULT getProperties(ref REVERB_PROPERTIES properties)
		{
			return FMOD5_Reverb3D_GetProperties(handle, ref properties);
		}

		public RESULT setActive(bool active)
		{
			return FMOD5_Reverb3D_SetActive(handle, active);
		}

		public RESULT getActive(out bool active)
		{
			return FMOD5_Reverb3D_GetActive(handle, out active);
		}

		public RESULT setUserData(IntPtr userdata)
		{
			return FMOD5_Reverb3D_SetUserData(handle, userdata);
		}

		public RESULT getUserData(out IntPtr userdata)
		{
			return FMOD5_Reverb3D_GetUserData(handle, out userdata);
		}

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Reverb3D_Release(IntPtr reverb);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Reverb3D_Set3DAttributes(IntPtr reverb, ref VECTOR position, float mindistance, float maxdistance);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Reverb3D_Get3DAttributes(IntPtr reverb, ref VECTOR position, ref float mindistance, ref float maxdistance);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Reverb3D_SetProperties(IntPtr reverb, ref REVERB_PROPERTIES properties);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Reverb3D_GetProperties(IntPtr reverb, ref REVERB_PROPERTIES properties);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Reverb3D_SetActive(IntPtr reverb, bool active);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Reverb3D_GetActive(IntPtr reverb, out bool active);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Reverb3D_SetUserData(IntPtr reverb, IntPtr userdata);

		[DllImport("fmod")]
		private static extern RESULT FMOD5_Reverb3D_GetUserData(IntPtr reverb, out IntPtr userdata);

		public bool hasHandle()
		{
			return handle != IntPtr.Zero;
		}

		public void clearHandle()
		{
			handle = IntPtr.Zero;
		}
	}
	public struct StringWrapper
	{
		private IntPtr nativeUtf8Ptr;

		public static implicit operator string(StringWrapper fstring)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return threadSafeEncoding.stringFromNative(fstring.nativeUtf8Ptr);
		}
	}
	internal static class StringHelper
	{
		public class ThreadSafeEncoding : IDisposable
		{
			public bool inUse;

			private UTF8Encoding encoding = new UTF8Encoding();

			private byte[] encodedBuffer = new byte[128];

			private char[] decodedBuffer = new char[128];

			private int roundUpPowerTwo(int number)
			{
				int num;
				for (num = 1; num <= number; num *= 2)
				{
				}
				return num;
			}

			public byte[] byteFromStringUTF8(string s)
			{
				if (s == null)
				{
					return null;
				}
				if (encoding.GetMaxByteCount(s.Length) + 1 > encodedBuffer.Length)
				{
					int num = encoding.GetByteCount(s) + 1;
					if (num > encodedBuffer.Length)
					{
						encodedBuffer = new byte[roundUpPowerTwo(num)];
					}
				}
				int bytes = encoding.GetBytes(s, 0, s.Length, encodedBuffer, 0);
				encodedBuffer[bytes] = 0;
				return encodedBuffer;
			}

			public string stringFromNative(IntPtr nativePtr)
			{
				if (nativePtr == IntPtr.Zero)
				{
					return "";
				}
				int i;
				for (i = 0; Marshal.ReadByte(nativePtr, i) != 0; i++)
				{
				}
				if (i == 0)
				{
					return "";
				}
				if (i > encodedBuffer.Length)
				{
					encodedBuffer = new byte[roundUpPowerTwo(i)];
				}
				Marshal.Copy(nativePtr, encodedBuffer, 0, i);
				if (encoding.GetMaxCharCount(i) > decodedBuffer.Length)
				{
					int charCount = encoding.GetCharCount(encodedBuffer, 0, i);
					if (charCount > decodedBuffer.Length)
					{
						decodedBuffer = new char[roundUpPowerTwo(charCount)];
					}
				}
				int chars = encoding.GetChars(encodedBuffer, 0, i, decodedBuffer, 0);
				return new string(decodedBuffer, 0, chars);
			}

			public void Dispose()
			{
				inUse = false;
			}
		}

		[ThreadStatic]
		private static ThreadSafeEncoding internalHelper;

		public static ThreadSafeEncoding GetFreeHelper()
		{
			if (internalHelper == null)
			{
				internalHelper = new ThreadSafeEncoding();
			}
			if (internalHelper.inUse)
			{
				throw new Exception("Nested use of FMOD.StringHelper.ThreadSafeEncoding!");
			}
			internalHelper.inUse = true;
			return internalHelper;
		}
	}
	public struct DSP_BUFFER_ARRAY
	{
		public int numbuffers;

		public int[] buffernumchannels;

		public CHANNELMASK[] bufferchannelmask;

		public IntPtr[] buffers;

		public SPEAKERMODE speakermode;
	}
	public enum DSP_PROCESS_OPERATION
	{
		PROCESS_PERFORM,
		PROCESS_QUERY
	}
	public struct COMPLEX
	{
		public float real;

		public float imag;
	}
	public enum DSP_PAN_SURROUND_FLAGS
	{
		DEFAULT,
		ROTATION_NOT_BIASED
	}
	public delegate RESULT DSP_CREATECALLBACK(ref DSP_STATE dsp_state);
	public delegate RESULT DSP_RELEASECALLBACK(ref DSP_STATE dsp_state);
	public delegate RESULT DSP_RESETCALLBACK(ref DSP_STATE dsp_state);
	public delegate RESULT DSP_SETPOSITIONCALLBACK(ref DSP_STATE dsp_state, uint pos);
	public delegate RESULT DSP_READCALLBACK(ref DSP_STATE dsp_state, IntPtr inbuffer, IntPtr outbuffer, uint length, int inchannels, ref int outchannels);
	public delegate RESULT DSP_SHOULDIPROCESS_CALLBACK(ref DSP_STATE dsp_state, bool inputsidle, uint length, CHANNELMASK inmask, int inchannels, SPEAKERMODE speakermode);
	public delegate RESULT DSP_PROCESS_CALLBACK(ref DSP_STATE dsp_state, uint length, ref DSP_BUFFER_ARRAY inbufferarray, ref DSP_BUFFER_ARRAY outbufferarray, bool inputsidle, DSP_PROCESS_OPERATION op);
	public delegate RESULT DSP_SETPARAM_FLOAT_CALLBACK(ref DSP_STATE dsp_state, int index, float value);
	public delegate RESULT DSP_SETPARAM_INT_CALLBACK(ref DSP_STATE dsp_state, int index, int value);
	public delegate RESULT DSP_SETPARAM_BOOL_CALLBACK(ref DSP_STATE dsp_state, int index, bool value);
	public delegate RESULT DSP_SETPARAM_DATA_CALLBACK(ref DSP_STATE dsp_state, int index, IntPtr data, uint length);
	public delegate RESULT DSP_GETPARAM_FLOAT_CALLBACK(ref DSP_STATE dsp_state, int index, ref float value, IntPtr valuestr);
	public delegate RESULT DSP_GETPARAM_INT_CALLBACK(ref DSP_STATE dsp_state, int index, ref int value, IntPtr valuestr);
	public delegate RESULT DSP_GETPARAM_BOOL_CALLBACK(ref DSP_STATE dsp_state, int index, ref bool value, IntPtr valuestr);
	public delegate RESULT DSP_GETPARAM_DATA_CALLBACK(ref DSP_STATE dsp_state, int index, ref IntPtr data, ref uint length, IntPtr valuestr);
	public delegate RESULT DSP_SYSTEM_REGISTER_CALLBACK(ref DSP_STATE dsp_state);
	public delegate RESULT DSP_SYSTEM_DEREGISTER_CALLBACK(ref DSP_STATE dsp_state);
	public delegate RESULT DSP_SYSTEM_MIX_CALLBACK(ref DSP_STATE dsp_state, int stage);
	public delegate IntPtr DSP_ALLOC_FUNC(uint size, MEMORY_TYPE type, StringWrapper sourcestr);
	public delegate IntPtr DSP_REALLOC_FUNC(IntPtr ptr, uint size, MEMORY_TYPE type, StringWrapper sourcestr);
	public delegate void DSP_FREE_FUNC(IntPtr ptr, MEMORY_TYPE type, StringWrapper sourcestr);
	public delegate void DSP_LOG_FUNC(DEBUG_FLAGS level, StringWrapper file, int line, StringWrapper function, StringWrapper format);
	public delegate RESULT DSP_GETSAMPLERATE_FUNC(ref DSP_STATE dsp_state, ref int rate);
	public delegate RESULT DSP_GETBLOCKSIZE_FUNC(ref DSP_STATE dsp_state, ref uint blocksize);
	public delegate RESULT DSP_GETSPEAKERMODE_FUNC(ref DSP_STATE dsp_state, ref int speakermode_mixer, ref int speakermode_output);
	public delegate RESULT DSP_GETCLOCK_FUNC(ref DSP_STATE dsp_state, out ulong clock, out uint offset, out uint length);
	public delegate RESULT DSP_GETLISTENERATTRIBUTES_FUNC(ref DSP_STATE dsp_state, ref int numlisteners, IntPtr attributes);
	public delegate RESULT DSP_GETUSERDATA_FUNC(ref DSP_STATE dsp_state, out IntPtr userdata);
	public delegate RESULT DSP_DFT_FFTREAL_FUNC(ref DSP_STATE dsp_state, int size, IntPtr signal, IntPtr dft, IntPtr window, int signalhop);
	public delegate RESULT DSP_DFT_IFFTREAL_FUNC(ref DSP_STATE dsp_state, int size, IntPtr dft, IntPtr signal, IntPtr window, int signalhop);
	public delegate RESULT DSP_PAN_SUMMONOMATRIX_FUNC(ref DSP_STATE dsp_state, int sourceSpeakerMode, float lowFrequencyGain, float overallGain, IntPtr matrix);
	public delegate RESULT DSP_PAN_SUMSTEREOMATRIX_FUNC(ref DSP_STATE dsp_state, int sourceSpeakerMode, float pan, float lowFrequencyGain, float overallGain, int matrixHop, IntPtr matrix);
	public delegate RESULT DSP_PAN_SUMSURROUNDMATRIX_FUNC(ref DSP_STATE dsp_state, int sourceSpeakerMode, int targetSpeakerMode, float direction, float extent, float rotation, float lowFrequencyGain, float overallGain, int matrixHop, IntPtr matrix, DSP_PAN_SURROUND_FLAGS flags);
	public delegate RESULT DSP_PAN_SUMMONOTOSURROUNDMATRIX_FUNC(ref DSP_STATE dsp_state, int targetSpeakerMode, float direction, float extent, float lowFrequencyGain, float overallGain, int matrixHop, IntPtr matrix);
	public delegate RESULT DSP_PAN_SUMSTEREOTOSURROUNDMATRIX_FUNC(ref DSP_STATE dsp_state, int targetSpeakerMode, float direction, float extent, float rotation, float lowFrequencyGain, float overallGain, int matrixHop, IntPtr matrix);
	public delegate RESULT DSP_PAN_GETROLLOFFGAIN_FUNC(ref DSP_STATE dsp_state, DSP_PAN_3D_ROLLOFF_TYPE rolloff, float distance, float mindistance, float maxdistance, out float gain);
	public enum DSP_TYPE
	{
		UNKNOWN,
		MIXER,
		OSCILLATOR,
		LOWPASS,
		ITLOWPASS,
		HIGHPASS,
		ECHO,
		FADER,
		FLANGE,
		DISTORTION,
		NORMALIZE,
		LIMITER,
		PARAMEQ,
		PITCHSHIFT,
		CHORUS,
		VSTPLUGIN,
		WINAMPPLUGIN,
		ITECHO,
		COMPRESSOR,
		SFXREVERB,
		LOWPASS_SIMPLE,
		DELAY,
		TREMOLO,
		LADSPAPLUGIN,
		SEND,
		RETURN,
		HIGHPASS_SIMPLE,
		PAN,
		THREE_EQ,
		FFT,
		LOUDNESS_METER,
		ENVELOPEFOLLOWER,
		CONVOLUTIONREVERB,
		CHANNELMIX,
		TRANSCEIVER,
		OBJECTPAN,
		MULTIBAND_EQ
	}
	public enum DSP_PARAMETER_TYPE
	{
		FLOAT,
		INT,
		BOOL,
		DATA
	}
	public enum DSP_PARAMETER_FLOAT_MAPPING_TYPE
	{
		DSP_PARAMETER_FLOAT_MAPPING_TYPE_LINEAR,
		DSP_PARAMETER_FLOAT_MAPPING_TYPE_AUTO,
		DSP_PARAMETER_FLOAT_MAPPING_TYPE_PIECEWISE_LINEAR
	}
	public struct DSP_PARAMETER_FLOAT_MAPPING_PIECEWISE_LINEAR
	{
		public int numpoints;

		public IntPtr pointparamvalues;

		public IntPtr pointpositions;
	}
	public struct DSP_PARAMETER_FLOAT_MAPPING
	{
		public DSP_PARAMETER_FLOAT_MAPPING_TYPE type;

		public DSP_PARAMETER_FLOAT_MAPPING_PIECEWISE_LINEAR piecewiselinearmapping;
	}
	public struct DSP_PARAMETER_DESC_FLOAT
	{
		public float min;

		public float max;

		public float defaultval;

		public DSP_PARAMETER_FLOAT_MAPPING mapping;
	}
	public struct DSP_PARAMETER_DESC_INT
	{
		public int min;

		public int max;

		public int defaultval;

		public bool goestoinf;

		public IntPtr valuenames;
	}
	public struct DSP_PARAMETER_DESC_BOOL
	{
		public bool defaultval;

		public IntPtr valuenames;
	}
	public struct DSP_PARAMETER_DESC_DATA
	{
		public int datatype;
	}
	[StructLayout(LayoutKind.Explicit)]
	public struct DSP_PARAMETER_DESC_UNION
	{
		[FieldOffset(0)]
		public DSP_PARAMETER_DESC_FLOAT floatdesc;

		[FieldOffset(0)]
		public DSP_PARAMETER_DESC_INT intdesc;

		[FieldOffset(0)]
		public DSP_PARAMETER_DESC_BOOL booldesc;

		[FieldOffset(0)]
		public DSP_PARAMETER_DESC_DATA datadesc;
	}
	public struct DSP_PARAMETER_DESC
	{
		public DSP_PARAMETER_TYPE type;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
		public char[] name;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
		public char[] label;

		public string description;

		public DSP_PARAMETER_DESC_UNION desc;
	}
	public enum DSP_PARAMETER_DATA_TYPE
	{
		DSP_PARAMETER_DATA_TYPE_USER = 0,
		DSP_PARAMETER_DATA_TYPE_OVERALLGAIN = -1,
		DSP_PARAMETER_DATA_TYPE_3DATTRIBUTES = -2,
		DSP_PARAMETER_DATA_TYPE_SIDECHAIN = -3,
		DSP_PARAMETER_DATA_TYPE_FFT = -4,
		DSP_PARAMETER_DATA_TYPE_3DATTRIBUTES_MULTI = -5
	}
	public struct DSP_PARAMETER_OVERALLGAIN
	{
		public float linear_gain;

		public float linear_gain_additive;
	}
	public struct DSP_PARAMETER_3DATTRIBUTES
	{
		public ATTRIBUTES_3D relative;

		public ATTRIBUTES_3D absolute;
	}
	public struct DSP_PARAMETER_3DATTRIBUTES_MULTI
	{
		public int numlisteners;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
		public ATTRIBUTES_3D[] relative;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
		public float[] weight;

		public ATTRIBUTES_3D absolute;
	}
	public struct DSP_PARAMETER_SIDECHAIN
	{
		public int sidechainenable;
	}
	public struct DSP_PARAMETER_FFT
	{
		public int length;

		public int numchannels;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
		private IntPtr[] spectrum_internal;

		public float[][] spectrum
		{
			get
			{
				float[][] array = new float[numchannels][];
				for (int i = 0; i < numchannels; i++)
				{
					array[i] = new float[length];
					Marshal.Copy(spectrum_internal[i], array[i], 0, length);
				}
				return array;
			}
		}
	}
	public struct DSP_DESCRIPTION
	{
		public uint pluginsdkversion;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
		public char[] name;

		public uint version;

		public int numinputbuffers;

		public int numoutputbuffers;

		public DSP_CREATECALLBACK create;

		public DSP_RELEASECALLBACK release;

		public DSP_RESETCALLBACK reset;

		public DSP_READCALLBACK read;

		public DSP_PROCESS_CALLBACK process;

		public DSP_SETPOSITIONCALLBACK setposition;

		public int numparameters;

		public IntPtr paramdesc;

		public DSP_SETPARAM_FLOAT_CALLBACK setparameterfloat;

		public DSP_SETPARAM_INT_CALLBACK setparameterint;

		public DSP_SETPARAM_BOOL_CALLBACK setparameterbool;

		public DSP_SETPARAM_DATA_CALLBACK setparameterdata;

		public DSP_GETPARAM_FLOAT_CALLBACK getparameterfloat;

		public DSP_GETPARAM_INT_CALLBACK getparameterint;

		public DSP_GETPARAM_BOOL_CALLBACK getparameterbool;

		public DSP_GETPARAM_DATA_CALLBACK getparameterdata;

		public DSP_SHOULDIPROCESS_CALLBACK shouldiprocess;

		public IntPtr userdata;

		public DSP_SYSTEM_REGISTER_CALLBACK sys_register;

		public DSP_SYSTEM_DEREGISTER_CALLBACK sys_deregister;

		public DSP_SYSTEM_MIX_CALLBACK sys_mix;
	}
	public struct DSP_STATE_DFT_FUNCTIONS
	{
		public DSP_DFT_FFTREAL_FUNC fftreal;

		public DSP_DFT_IFFTREAL_FUNC inversefftreal;
	}
	public struct DSP_STATE_PAN_FUNCTIONS
	{
		public DSP_PAN_SUMMONOMATRIX_FUNC summonomatrix;

		public DSP_PAN_SUMSTEREOMATRIX_FUNC sumstereomatrix;

		public DSP_PAN_SUMSURROUNDMATRIX_FUNC sumsurroundmatrix;

		public DSP_PAN_SUMMONOTOSURROUNDMATRIX_FUNC summonotosurroundmatrix;

		public DSP_PAN_SUMSTEREOTOSURROUNDMATRIX_FUNC sumstereotosurroundmatrix;

		public DSP_PAN_GETROLLOFFGAIN_FUNC getrolloffgain;
	}
	public struct DSP_STATE_FUNCTIONS
	{
		private DSP_ALLOC_FUNC alloc;

		private DSP_REALLOC_FUNC realloc;

		private DSP_FREE_FUNC free;

		private DSP_GETSAMPLERATE_FUNC getsamplerate;

		private DSP_GETBLOCKSIZE_FUNC getblocksize;

		private IntPtr dft;

		private IntPtr pan;

		private DSP_GETSPEAKERMODE_FUNC getspeakermode;

		private DSP_GETCLOCK_FUNC getclock;

		private DSP_GETLISTENERATTRIBUTES_FUNC getlistenerattributes;

		private DSP_LOG_FUNC log;

		private DSP_GETUSERDATA_FUNC getuserdata;
	}
	public struct DSP_STATE
	{
		public IntPtr instance;

		public IntPtr plugindata;

		public uint channelmask;

		public int source_speakermode;

		public IntPtr sidechaindata;

		public int sidechainchannels;

		public IntPtr functions;

		public int systemobject;
	}
	public struct DSP_METERING_INFO
	{
		public int numsamples;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
		public float[] peaklevel;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
		public float[] rmslevel;

		public short numchannels;
	}
	public enum DSP_OSCILLATOR
	{
		TYPE,
		RATE
	}
	public enum DSP_LOWPASS
	{
		CUTOFF,
		RESONANCE
	}
	public enum DSP_ITLOWPASS
	{
		CUTOFF,
		RESONANCE
	}
	public enum DSP_HIGHPASS
	{
		CUTOFF,
		RESONANCE
	}
	public enum DSP_ECHO
	{
		DELAY,
		FEEDBACK,
		DRYLEVEL,
		WETLEVEL
	}
	public enum DSP_FADER
	{
		GAIN
	}
	public enum DSP_DELAY
	{
		CH0,
		CH1,
		CH2,
		CH3,
		CH4,
		CH5,
		CH6,
		CH7,
		CH8,
		CH9,
		CH10,
		CH11,
		CH12,
		CH13,
		CH14,
		CH15,
		MAXDELAY
	}
	public enum DSP_FLANGE
	{
		MIX,
		DEPTH,
		RATE
	}
	public enum DSP_TREMOLO
	{
		FREQUENCY,
		DEPTH,
		SHAPE,
		SKEW,
		DUTY,
		SQUARE,
		PHASE,
		SPREAD
	}
	public enum DSP_DISTORTION
	{
		LEVEL
	}
	public enum DSP_NORMALIZE
	{
		FADETIME,
		THRESHHOLD,
		MAXAMP
	}
	public enum DSP_LIMITER
	{
		RELEASETIME,
		CEILING,
		MAXIMIZERGAIN,
		MODE
	}
	public enum DSP_PARAMEQ
	{
		CENTER,
		BANDWIDTH,
		GAIN
	}
	public enum DSP_MULTIBAND_EQ
	{
		A_FILTER,
		A_FREQUENCY,
		A_Q,
		A_GAIN,
		B_FILTER,
		B_FREQUENCY,
		B_Q,
		B_GAIN,
		C_FILTER,
		C_FREQUENCY,
		C_Q,
		C_GAIN,
		D_FILTER,
		D_FREQUENCY,
		D_Q,
		D_GAIN,
		E_FILTER,
		E_FREQUENCY,
		E_Q,
		E_GAIN
	}
	public enum DSP_MULTIBAND_EQ_FILTER_TYPE
	{
		DISABLED,
		LOWPASS_12DB,
		LOWPASS_24DB,
		LOWPASS_48DB,
		HIGHPASS_12DB,
		HIGHPASS_24DB,
		HIGHPASS_48DB,
		LOWSHELF,
		HIGHSHELF,
		PEAKING,
		BANDPASS,
		NOTCH,
		ALLPASS
	}
	public enum DSP_PITCHSHIFT
	{
		PITCH,
		FFTSIZE,
		OVERLAP,
		MAXCHANNELS
	}
	public enum DSP_CHORUS
	{
		MIX,
		RATE,
		DEPTH
	}
	public enum DSP_ITECHO
	{
		WETDRYMIX,
		FEEDBACK,
		LEFTDELAY,
		RIGHTDELAY,
		PANDELAY
	}
	public enum DSP_COMPRESSOR
	{
		THRESHOLD,
		RATIO,
		ATTACK,
		RELEASE,
		GAINMAKEUP,
		USESIDECHAIN,
		LINKED
	}
	public enum DSP_SFXREVERB
	{
		DECAYTIME,
		EARLYDELAY,
		LATEDELAY,
		HFREFERENCE,
		HFDECAYRATIO,
		DIFFUSION,
		DENSITY,
		LOWSHELFFREQUENCY,
		LOWSHELFGAIN,
		HIGHCUT,
		EARLYLATEMIX,
		WETLEVEL,
		DRYLEVEL
	}
	public enum DSP_LOWPASS_SIMPLE
	{
		CUTOFF
	}
	public enum DSP_SEND
	{
		RETURNID,
		LEVEL
	}
	public enum DSP_RETURN
	{
		ID,
		INPUT_SPEAKER_MODE
	}
	public enum DSP_HIGHPASS_SIMPLE
	{
		CUTOFF
	}
	public enum DSP_PAN_2D_STEREO_MODE_TYPE
	{
		DISTRIBUTED,
		DISCRETE
	}
	public enum DSP_PAN_MODE_TYPE
	{
		MONO,
		STEREO,
		SURROUND
	}
	public enum DSP_PAN_3D_ROLLOFF_TYPE
	{
		LINEARSQUARED,
		LINEAR,
		INVERSE,
		INVERSETAPERED,
		CUSTOM
	}
	public enum DSP_PAN_3D_EXTENT_MODE_TYPE
	{
		AUTO,
		USER,
		OFF
	}
	public enum DSP_PAN
	{
		MODE,
		_2D_STEREO_POSITION,
		_2D_DIRECTION,
		_2D_EXTENT,
		_2D_ROTATION,
		_2D_LFE_LEVEL,
		_2D_STEREO_MODE,
		_2D_STEREO_SEPARATION,
		_2D_STEREO_AXIS,
		ENABLED_SPEAKERS,
		_3D_POSITION,
		_3D_ROLLOFF,
		_3D_MIN_DISTANCE,
		_3D_MAX_DISTANCE,
		_3D_EXTENT_MODE,
		_3D_SOUND_SIZE,
		_3D_MIN_EXTENT,
		_3D_PAN_BLEND,
		LFE_UPMIX_ENABLED,
		OVERALL_GAIN,
		SURROUND_SPEAKER_MODE,
		_2D_HEIGHT_BLEND
	}
	public enum DSP_THREE_EQ_CROSSOVERSLOPE_TYPE
	{
		_12DB,
		_24DB,
		_48DB
	}
	public enum DSP_THREE_EQ
	{
		LOWGAIN,
		MIDGAIN,
		HIGHGAIN,
		LOWCROSSOVER,
		HIGHCROSSOVER,
		CROSSOVERSLOPE
	}
	public enum DSP_FFT_WINDOW
	{
		RECT,
		TRIANGLE,
		HAMMING,
		HANNING,
		BLACKMAN,
		BLACKMANHARRIS
	}
	public enum DSP_FFT
	{
		WINDOWSIZE,
		WINDOWTYPE,
		SPECTRUMDATA,
		DOMINANT_FREQ
	}
	public enum DSP_ENVELOPEFOLLOWER
	{
		ATTACK,
		RELEASE,
		ENVELOPE,
		USESIDECHAIN
	}
	public enum DSP_CONVOLUTION_REVERB
	{
		IR,
		WET,
		DRY,
		LINKED
	}
	public enum DSP_CHANNELMIX_OUTPUT
	{
		DEFAULT,
		ALLMONO,
		ALLSTEREO,
		ALLQUAD,
		ALL5POINT1,
		ALL7POINT1,
		ALLLFE
	}
	public enum DSP_CHANNELMIX
	{
		OUTPUTGROUPING,
		GAIN_CH0,
		GAIN_CH1,
		GAIN_CH2,
		GAIN_CH3,
		GAIN_CH4,
		GAIN_CH5,
		GAIN_CH6,
		GAIN_CH7,
		GAIN_CH8,
		GAIN_CH9,
		GAIN_CH10,
		GAIN_CH11,
		GAIN_CH12,
		GAIN_CH13,
		GAIN_CH14,
		GAIN_CH15,
		GAIN_CH16,
		GAIN_CH17,
		GAIN_CH18,
		GAIN_CH19,
		GAIN_CH20,
		GAIN_CH21,
		GAIN_CH22,
		GAIN_CH23,
		GAIN_CH24,
		GAIN_CH25,
		GAIN_CH26,
		GAIN_CH27,
		GAIN_CH28,
		GAIN_CH29,
		GAIN_CH30,
		GAIN_CH31
	}
	public enum DSP_TRANSCEIVER_SPEAKERMODE
	{
		AUTO = -1,
		MONO,
		STEREO,
		SURROUND
	}
	public enum DSP_TRANSCEIVER
	{
		TRANSMIT,
		GAIN,
		CHANNEL,
		TRANSMITSPEAKERMODE
	}
	public enum DSP_OBJECTPAN
	{
		_3D_POSITION,
		_3D_ROLLOFF,
		_3D_MIN_DISTANCE,
		_3D_MAX_DISTANCE,
		_3D_EXTENT_MODE,
		_3D_SOUND_SIZE,
		_3D_MIN_EXTENT,
		OVERALL_GAIN,
		OUTPUTGAIN
	}
	public class Error
	{
		public static string String(RESULT errcode)
		{
			return errcode switch
			{
				RESULT.OK => "No errors.", 
				RESULT.ERR_BADCOMMAND => "Tried to call a function on a data type that does not allow this type of functionality (ie calling Sound::lock on a streaming sound).", 
				RESULT.ERR_CHANNEL_ALLOC => "Error trying to allocate a channel.", 
				RESULT.ERR_CHANNEL_STOLEN => "The specified channel has been reused to play another sound.", 
				RESULT.ERR_DMA => "DMA Failure.  See debug output for more information.", 
				RESULT.ERR_DSP_CONNECTION => "DSP connection error.  Connection possibly caused a cyclic dependency or connected dsps with incompatible buffer counts.", 
				RESULT.ERR_DSP_DONTPROCESS => "DSP return code from a DSP process query callback.  Tells mixer not to call the process callback and therefore not consume CPU.  Use this to optimize the DSP graph.", 
				RESULT.ERR_DSP_FORMAT => "DSP Format error.  A DSP unit may have attempted to connect to this network with the wrong format, or a matrix may have been set with the wrong size if the target unit has a specified channel map.", 
				RESULT.ERR_DSP_INUSE => "DSP is already in the mixer's DSP network. It must be removed before being reinserted or released.", 
				RESULT.ERR_DSP_NOTFOUND => "DSP connection error.  Couldn't find the DSP unit specified.", 
				RESULT.ERR_DSP_RESERVED => "DSP operation error.  Cannot perform operation on this DSP as it is reserved by the system.", 
				RESULT.ERR_DSP_SILENCE => "DSP return code from a DSP process query callback.  Tells mixer silence would be produced from read, so go idle and not consume CPU.  Use this to optimize the DSP graph.", 
				RESULT.ERR_DSP_TYPE => "DSP operation cannot be performed on a DSP of this type.", 
				RESULT.ERR_FILE_BAD => "Error loading file.", 
				RESULT.ERR_FILE_COULDNOTSEEK => "Couldn't perform seek operation.  This is a limitation of the medium (ie netstreams) or the file format.", 
				RESULT.ERR_FILE_DISKEJECTED => "Media was ejected while reading.", 
				RESULT.ERR_FILE_EOF => "End of file unexpectedly reached while trying to read essential data (truncated?).", 
				RESULT.ERR_FILE_ENDOFDATA => "End of current chunk reached while trying to read data.", 
				RESULT.ERR_FILE_NOTFOUND => "File not found.", 
				RESULT.ERR_FORMAT => "Unsupported file or audio format.", 
				RESULT.ERR_HEADER_MISMATCH => "There is a version mismatch between the FMOD header and either the FMOD Studio library or the FMOD Low Level library.", 
				RESULT.ERR_HTTP => "A HTTP error occurred. This is a catch-all for HTTP errors not listed elsewhere.", 
				RESULT.ERR_HTTP_ACCESS => "The specified resource requires authentication or is forbidden.", 
				RESULT.ERR_HTTP_PROXY_AUTH => "Proxy authentication is required to access the specified resource.", 
				RESULT.ERR_HTTP_SERVER_ERROR => "A HTTP server error occurred.", 
				RESULT.ERR_HTTP_TIMEOUT => "The HTTP request timed out.", 
				RESULT.ERR_INITIALIZATION => "FMOD was not initialized correctly to support this function.", 
				RESULT.ERR_INITIALIZED => "Cannot call this command after System::init.", 
				RESULT.ERR_INTERNAL => "An error occurred that wasn't supposed to.  Contact support.", 
				RESULT.ERR_INVALID_FLOAT => "Value passed in was a NaN, Inf or denormalized float.", 
				RESULT.ERR_INVALID_HANDLE => "An invalid object handle was used.", 
				RESULT.ERR_INVALID_PARAM => "An invalid parameter was passed to this function.", 
				RESULT.ERR_INVALID_POSITION => "An invalid seek position was passed to this function.", 
				RESULT.ERR_INVALID_SPEAKER => "An invalid speaker was passed to this function based on the current speaker mode.", 
				RESULT.ERR_INVALID_SYNCPOINT => "The syncpoint did not come from this sound handle.", 
				RESULT.ERR_INVALID_THREAD => "Tried to call a function on a thread that is not supported.", 
				RESULT.ERR_INVALID_VECTOR => "The vectors passed in are not unit length, or perpendicular.", 
				RESULT.ERR_MAXAUDIBLE => "Reached maximum audible playback count for this sound's soundgroup.", 
				RESULT.ERR_MEMORY => "Not enough memory or resources.", 
				RESULT.ERR_MEMORY_CANTPOINT => "Can't use FMOD_OPENMEMORY_POINT on non PCM source data, or non mp3/xma/adpcm data if FMOD_CREATECOMPRESSEDSAMPLE was used.", 
				RESULT.ERR_NEEDS3D => "Tried to call a command on a 2d sound when the command was meant for 3d sound.", 
				RESULT.ERR_NEEDSHARDWARE => "Tried to use a feature that requires hardware support.", 
				RESULT.ERR_NET_CONNECT => "Couldn't connect to the specified host.", 
				RESULT.ERR_NET_SOCKET_ERROR => "A socket error occurred.  This is a catch-all for socket-related errors not listed elsewhere.", 
				RESULT.ERR_NET_URL => "The specified URL couldn't be resolved.", 
				RESULT.ERR_NET_WOULD_BLOCK => "Operation on a non-blocking socket could not complete immediately.", 
				RESULT.ERR_NOTREADY => "Operation could not be performed because specified sound/DSP connection is not ready.", 
				RESULT.ERR_OUTPUT_ALLOCATED => "Error initializing output device, but more specifically, the output device is already in use and cannot be reused.", 
				RESULT.ERR_OUTPUT_CREATEBUFFER => "Error creating hardware sound buffer.", 
				RESULT.ERR_OUTPUT_DRIVERCALL => "A call to a standard soundcard driver failed, which could possibly mean a bug in the driver or resources were missing or exhausted.", 
				RESULT.ERR_OUTPUT_FORMAT => "Soundcard does not support the specified format.", 
				RESULT.ERR_OUTPUT_INIT => "Error initializing output device.", 
				RESULT.ERR_OUTPUT_NODRIVERS => "The output device has no drivers installed.  If pre-init, FMOD_OUTPUT_NOSOUND is selected as the output mode.  If post-init, the function just fails.", 
				RESULT.ERR_PLUGIN => "An unspecified error has been returned from a plugin.", 
				RESULT.ERR_PLUGIN_MISSING => "A requested output, dsp unit type or codec was not available.", 
				RESULT.ERR_PLUGIN_RESOURCE => "A resource that the plugin requires cannot be found. (ie the DLS file for MIDI playback)", 
				RESULT.ERR_PLUGIN_VERSION => "A plugin was built with an unsupported SDK version.", 
				RESULT.ERR_RECORD => "An error occurred trying to initialize the recording device.", 
				RESULT.ERR_REVERB_CHANNELGROUP => "Reverb properties cannot be set on this channel because a parent channelgroup owns the reverb connection.", 
				RESULT.ERR_REVERB_INSTANCE => "Specified instance in FMOD_REVERB_PROPERTIES couldn't be set. Most likely because it is an invalid instance number or the reverb doesn't exist.", 
				RESULT.ERR_SUBSOUNDS => "The error occurred because the sound referenced contains subsounds when it shouldn't have, or it doesn't contain subsounds when it should have.  The operation may also not be able to be performed on a parent sound.", 
				RESULT.ERR_SUBSOUND_ALLOCATED => "This subsound is already being used by another sound, you cannot have more than one parent to a sound.  Null out the other parent's entry first.", 
				RESULT.ERR_SUBSOUND_CANTMOVE => "Shared subsounds cannot be replaced or moved from their parent stream, such as when the parent stream is an FSB file.", 
				RESULT.ERR_TAGNOTFOUND => "The specified tag could not be found or there are no tags.", 
				RESULT.ERR_TOOMANYCHANNELS => "The sound created exceeds the allowable input channel count.  This can be increased using the 'maxinputchannels' parameter in System::setSoftwareFormat.", 
				RESULT.ERR_TRUNCATED => "The retrieved string is too long to fit in the supplied buffer and has been truncated.", 
				RESULT.ERR_UNIMPLEMENTED => "Something in FMOD hasn't been implemented when it should be! contact support!", 
				RESULT.ERR_UNINITIALIZED => "This command failed because System::init or System::setDriver was not called.", 
				RESULT.ERR_UNSUPPORTED => "A command issued was not supported by this object.  Possibly a plugin without certain callbacks specified.", 
				RESULT.ERR_VERSION => "The version number of this file format is not supported.", 
				RESULT.ERR_EVENT_ALREADY_LOADED => "The specified bank has already been loaded.", 
				RESULT.ERR_EVENT_LIVEUPDATE_BUSY => "The live update connection failed due to the game already being connected.", 
				RESULT.ERR_EVENT_LIVEUPDATE_MISMATCH => "The live update connection failed due to the game data being out of sync with the tool.", 
				RESULT.ERR_EVENT_LIVEUPDATE_TIMEOUT => "The live update connection timed out.", 
				RESULT.ERR_EVENT_NOTFOUND => "The requested event, bus or vca could not be found.", 
				RESULT.ERR_STUDIO_UNINITIALIZED => "The Studio::System object is not yet initialized.", 
				RESULT.ERR_STUDIO_NOT_LOADED => "The specified resource is not loaded, so it can't be unloaded.", 
				RESULT.ERR_INVALID_STRING => "An invalid string was passed to this function.", 
				RESULT.ERR_ALREADY_LOCKED => "The specified resource is already locked.", 
				RESULT.ERR_NOT_LOCKED => "The specified resource is not locked, so it can't be unlocked.", 
				RESULT.ERR_RECORD_DISCONNECTED => "The specified recording driver has been disconnected.", 
				RESULT.ERR_TOOMANYSAMPLES => "The length provided exceed the allowable limit.", 
				_ => "Unknown error.", 
			};
		}
	}
}
namespace FMOD.Studio
{
	public static class UnityUtil
	{
		public static VECTOR toFMODVector(this Vector3 vec)
		{
			VECTOR result = default(VECTOR);
			result.x = vec.x;
			result.y = vec.y;
			result.z = vec.z;
			return result;
		}

		public static ATTRIBUTES_3D to3DAttributes(this Vector3 pos)
		{
			ATTRIBUTES_3D result = default(ATTRIBUTES_3D);
			result.forward = Vector3.forward.toFMODVector();
			result.up = Vector3.up.toFMODVector();
			result.position = pos.toFMODVector();
			return result;
		}

		public static ATTRIBUTES_3D to3DAttributes(GameObject go, Rigidbody rigidbody = null)
		{
			ATTRIBUTES_3D result = default(ATTRIBUTES_3D);
			Transform transform = go.transform;
			result.forward = transform.forward.toFMODVector();
			result.up = transform.up.toFMODVector();
			result.position = transform.position.toFMODVector();
			if ((bool)rigidbody)
			{
				result.velocity = rigidbody.velocity.toFMODVector();
			}
			return result;
		}

		public static ATTRIBUTES_3D to3DAttributes(Transform t)
		{
			ATTRIBUTES_3D result = default(ATTRIBUTES_3D);
			result.forward = t.forward.toFMODVector();
			result.up = t.up.toFMODVector();
			result.position = t.position.toFMODVector();
			return result;
		}

		public static void Log(string msg)
		{
		}

		public static void LogWarning(string msg)
		{
			UnityEngine.Debug.LogWarning(msg);
		}

		public static void LogError(string msg)
		{
			UnityEngine.Debug.LogError(msg);
		}

		public static bool ForceLoadLowLevelBinary()
		{
			AndroidJavaObject androidJavaObject = null;
			using (AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))
			{
				androidJavaObject = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			}
			UnityEngine.Debug.Log("FMOD ANDROID AUDIOTRACK: " + ((androidJavaObject == null) ? "ERROR NO ACTIVITY" : "VALID ACTIVITY!"));
			using (AndroidJavaClass androidJavaClass2 = new AndroidJavaClass("org.fmod.FMOD"))
			{
				if (androidJavaClass2 != null)
				{
					UnityEngine.Debug.Log("FMOD ANDROID AUDIOTRACK: assigning activity to fmod java");
					androidJavaClass2.CallStatic("init", androidJavaObject);
				}
				else
				{
					UnityEngine.Debug.Log("FMOD ANDROID AUDIOTRACK: ERROR NO FMOD JAVA");
				}
			}
			Log("loading binaries: fmodstudio and fmod");
			AndroidJavaClass androidJavaClass3 = new AndroidJavaClass("java.lang.System");
			androidJavaClass3.CallStatic("loadLibrary", "fmod");
			androidJavaClass3.CallStatic("loadLibrary", "fmodstudio");
			Log("Attempting to call Memory_GetStats");
			if (!ERRCHECK(Memory.GetStats(out var _, out var _)))
			{
				LogError("Memory_GetStats returned an error");
				return false;
			}
			Log("Calling Memory_GetStats succeeded!");
			return true;
		}

		public static bool ERRCHECK(RESULT result)
		{
			if (result != 0)
			{
				LogWarning("FMOD Error (" + result.ToString() + "): " + Error.String(result));
			}
			return result == RESULT.OK;
		}
	}
	public class STUDIO_VERSION
	{
		public const string dll = "fmodstudio";
	}
	public enum STOP_MODE
	{
		ALLOWFADEOUT,
		IMMEDIATE
	}
	public enum LOADING_STATE
	{
		UNLOADING,
		UNLOADED,
		LOADING,
		LOADED,
		ERROR
	}
	public struct PROGRAMMER_SOUND_PROPERTIES
	{
		public StringWrapper name;

		public IntPtr sound;

		public int subsoundIndex;
	}
	public struct TIMELINE_MARKER_PROPERTIES
	{
		public StringWrapper name;

		public int position;
	}
	public struct TIMELINE_BEAT_PROPERTIES
	{
		public int bar;

		public int beat;

		public int position;

		public float tempo;

		public int timesignatureupper;

		public int timesignaturelower;
	}
	public struct ADVANCEDSETTINGS
	{
		public int cbsize;

		public int commandqueuesize;

		public int handleinitialsize;

		public int studioupdateperiod;

		public int idlesampledatapoolsize;
	}
	public struct CPU_USAGE
	{
		public float dspusage;

		public float streamusage;

		public float geometryusage;

		public float updateusage;

		public float studiousage;
	}
	public struct BUFFER_INFO
	{
		public int currentusage;

		public int peakusage;

		public int capacity;

		public int stallcount;

		public float stalltime;
	}
	public struct BUFFER_USAGE
	{
		public BUFFER_INFO studiocommandqueue;

		public BUFFER_INFO studiohandle;
	}
	public struct BANK_INFO
	{
		public int size;

		public IntPtr userdata;

		public int userdatalength;

		public FILE_OPENCALLBACK opencallback;

		public FILE_CLOSECALLBACK closecallback;

		public FILE_READCALLBACK readcallback;

		public FILE_SEEKCALLBACK seekcallback;
	}
	[Flags]
	public enum SYSTEM_CALLBACK_TYPE : uint
	{
		PREUPDATE = 1u,
		POSTUPDATE = 2u,
		BANK_UNLOAD = 4u,
		ALL = uint.MaxValue
	}
	public delegate RESULT SYSTEM_CALLBACK(IntPtr systemraw, SYSTEM_CALLBACK_TYPE type, IntPtr parameters, IntPtr userdata);
	public enum PARAMETER_TYPE
	{
		GAME_CONTROLLED,
		AUTOMATIC_DISTANCE,
		AUTOMATIC_EVENT_CONE_ANGLE,
		AUTOMATIC_EVENT_ORIENTATION,
		AUTOMATIC_DIRECTION,
		AUTOMATIC_ELEVATION,
		AUTOMATIC_LISTENER_ORIENTATION
	}
	public struct PARAMETER_DESCRIPTION
	{
		public StringWrapper name;

		public int index;

		public float minimum;

		public float maximum;

		public float defaultvalue;

		public PARAMETER_TYPE type;
	}
	internal enum LOAD_MEMORY_MODE
	{
		LOAD_MEMORY,
		LOAD_MEMORY_POINT
	}
	internal enum LOAD_MEMORY_ALIGNMENT
	{
		VALUE = 0x20
	}
	public struct SOUND_INFO
	{
		public IntPtr name_or_data;

		public MODE mode;

		public CREATESOUNDEXINFO exinfo;

		public int subsoundindex;

		public string name
		{
			get
			{
				using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
				return ((mode & (MODE.OPENMEMORY | MODE.OPENMEMORY_POINT)) == 0) ? threadSafeEncoding.stringFromNative(name_or_data) : string.Empty;
			}
		}
	}
	public enum USER_PROPERTY_TYPE
	{
		INTEGER,
		BOOLEAN,
		FLOAT,
		STRING
	}
	public struct USER_PROPERTY
	{
		public StringWrapper name;

		public USER_PROPERTY_TYPE type;

		private Union_IntBoolFloatString value;

		public int intValue()
		{
			if (type != 0)
			{
				return -1;
			}
			return value.intvalue;
		}

		public bool boolValue()
		{
			if (type != USER_PROPERTY_TYPE.BOOLEAN)
			{
				return false;
			}
			return value.boolvalue;
		}

		public float floatValue()
		{
			if (type != USER_PROPERTY_TYPE.FLOAT)
			{
				return -1f;
			}
			return value.floatvalue;
		}

		public string stringValue()
		{
			if (type != USER_PROPERTY_TYPE.STRING)
			{
				return "";
			}
			return value.stringvalue;
		}
	}
	[StructLayout(LayoutKind.Explicit)]
	internal struct Union_IntBoolFloatString
	{
		[FieldOffset(0)]
		public int intvalue;

		[FieldOffset(0)]
		public bool boolvalue;

		[FieldOffset(0)]
		public float floatvalue;

		[FieldOffset(0)]
		public StringWrapper stringvalue;
	}
	[Flags]
	public enum INITFLAGS : uint
	{
		NORMAL = 0u,
		LIVEUPDATE = 1u,
		ALLOW_MISSING_PLUGINS = 2u,
		SYNCHRONOUS_UPDATE = 4u,
		DEFERRED_CALLBACKS = 8u,
		LOAD_FROM_UPDATE = 0x10u
	}
	[Flags]
	public enum LOAD_BANK_FLAGS : uint
	{
		NORMAL = 0u,
		NONBLOCKING = 1u,
		DECOMPRESS_SAMPLES = 2u
	}
	[Flags]
	public enum COMMANDCAPTURE_FLAGS : uint
	{
		NORMAL = 0u,
		FILEFLUSH = 1u,
		SKIP_INITIAL_STATE = 2u
	}
	[Flags]
	public enum COMMANDREPLAY_FLAGS : uint
	{
		NORMAL = 0u,
		SKIP_CLEANUP = 1u,
		FAST_FORWARD = 2u
	}
	public enum PLAYBACK_STATE
	{
		PLAYING,
		SUSTAINING,
		STOPPED,
		STARTING,
		STOPPING
	}
	public enum EVENT_PROPERTY
	{
		CHANNELPRIORITY,
		SCHEDULE_DELAY,
		SCHEDULE_LOOKAHEAD,
		MINIMUM_DISTANCE,
		MAXIMUM_DISTANCE
	}
	public struct PLUGIN_INSTANCE_PROPERTIES
	{
		public IntPtr name;

		public IntPtr dsp;
	}
	[Flags]
	public enum EVENT_CALLBACK_TYPE : uint
	{
		CREATED = 1u,
		DESTROYED = 2u,
		STARTING = 4u,
		STARTED = 8u,
		RESTARTED = 0x10u,
		STOPPED = 0x20u,
		START_FAILED = 0x40u,
		CREATE_PROGRAMMER_SOUND = 0x80u,
		DESTROY_PROGRAMMER_SOUND = 0x100u,
		PLUGIN_CREATED = 0x200u,
		PLUGIN_DESTROYED = 0x400u,
		TIMELINE_MARKER = 0x800u,
		TIMELINE_BEAT = 0x1000u,
		SOUND_PLAYED = 0x2000u,
		SOUND_STOPPED = 0x4000u,
		ALL = uint.MaxValue
	}
	public delegate RESULT EVENT_CALLBACK(EVENT_CALLBACK_TYPE type, EventInstance eventInstance, IntPtr parameters);
	public delegate RESULT COMMANDREPLAY_FRAME_CALLBACK(CommandReplay replay, int commandIndex, float currentTime, IntPtr userdata);
	public delegate RESULT COMMANDREPLAY_LOAD_BANK_CALLBACK(CommandReplay replay, Guid guid, StringWrapper bankFilename, LOAD_BANK_FLAGS flags, out Bank bank, IntPtr userdata);
	public delegate RESULT COMMANDREPLAY_CREATE_INSTANCE_CALLBACK(CommandReplay replay, EventDescription eventDescription, IntPtr originalHandle, out EventInstance instance, IntPtr userdata);
	public enum INSTANCETYPE
	{
		NONE,
		SYSTEM,
		EVENTDESCRIPTION,
		EVENTINSTANCE,
		PARAMETERINSTANCE,
		BUS,
		VCA,
		BANK,
		COMMANDREPLAY
	}
	public struct COMMAND_INFO
	{
		private StringWrapper commandname;

		public int parentcommandindex;

		public int framenumber;

		public float frametime;

		public INSTANCETYPE instancetype;

		public INSTANCETYPE outputtype;

		public uint instancehandle;

		public uint outputhandle;
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct Util
	{
		public static RESULT ParseID(string idString, out Guid id)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD_Studio_ParseID(threadSafeEncoding.byteFromStringUTF8(idString), out id);
		}

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_ParseID(byte[] idString, out Guid id);
	}
	public struct System
	{
		public IntPtr handle;

		public static RESULT create(out System studiosystem)
		{
			return FMOD_Studio_System_Create(out studiosystem.handle, 69637u);
		}

		public RESULT setAdvancedSettings(ADVANCEDSETTINGS settings)
		{
			settings.cbsize = Marshal.SizeOf(typeof(ADVANCEDSETTINGS));
			return FMOD_Studio_System_SetAdvancedSettings(handle, ref settings);
		}

		public RESULT getAdvancedSettings(out ADVANCEDSETTINGS settings)
		{
			settings.cbsize = Marshal.SizeOf(typeof(ADVANCEDSETTINGS));
			return FMOD_Studio_System_GetAdvancedSettings(handle, out settings);
		}

		public RESULT initialize(int maxchannels, INITFLAGS studioFlags, FMOD.INITFLAGS flags, IntPtr extradriverdata)
		{
			return FMOD_Studio_System_Initialize(handle, maxchannels, studioFlags, flags, extradriverdata);
		}

		public RESULT release()
		{
			return FMOD_Studio_System_Release(handle);
		}

		public RESULT update()
		{
			return FMOD_Studio_System_Update(handle);
		}

		public RESULT getLowLevelSystem(out FMOD.System system)
		{
			return FMOD_Studio_System_GetLowLevelSystem(handle, out system.handle);
		}

		public RESULT getEvent(string path, out EventDescription _event)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD_Studio_System_GetEvent(handle, threadSafeEncoding.byteFromStringUTF8(path), out _event.handle);
		}

		public RESULT getBus(string path, out Bus bus)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD_Studio_System_GetBus(handle, threadSafeEncoding.byteFromStringUTF8(path), out bus.handle);
		}

		public RESULT getVCA(string path, out VCA vca)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD_Studio_System_GetVCA(handle, threadSafeEncoding.byteFromStringUTF8(path), out vca.handle);
		}

		public RESULT getBank(string path, out Bank bank)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD_Studio_System_GetBank(handle, threadSafeEncoding.byteFromStringUTF8(path), out bank.handle);
		}

		public RESULT getEventByID(Guid guid, out EventDescription _event)
		{
			return FMOD_Studio_System_GetEventByID(handle, ref guid, out _event.handle);
		}

		public RESULT getBusByID(Guid guid, out Bus bus)
		{
			return FMOD_Studio_System_GetBusByID(handle, ref guid, out bus.handle);
		}

		public RESULT getVCAByID(Guid guid, out VCA vca)
		{
			return FMOD_Studio_System_GetVCAByID(handle, ref guid, out vca.handle);
		}

		public RESULT getBankByID(Guid guid, out Bank bank)
		{
			return FMOD_Studio_System_GetBankByID(handle, ref guid, out bank.handle);
		}

		public RESULT getSoundInfo(string key, out SOUND_INFO info)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD_Studio_System_GetSoundInfo(handle, threadSafeEncoding.byteFromStringUTF8(key), out info);
		}

		public RESULT lookupID(string path, out Guid guid)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD_Studio_System_LookupID(handle, threadSafeEncoding.byteFromStringUTF8(path), out guid);
		}

		public RESULT lookupPath(Guid guid, out string path)
		{
			path = null;
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			IntPtr intPtr = Marshal.AllocHGlobal(256);
			int retrieved = 0;
			RESULT rESULT = FMOD_Studio_System_LookupPath(handle, ref guid, intPtr, 256, out retrieved);
			if (rESULT == RESULT.ERR_TRUNCATED)
			{
				Marshal.FreeHGlobal(intPtr);
				intPtr = Marshal.AllocHGlobal(retrieved);
				rESULT = FMOD_Studio_System_LookupPath(handle, ref guid, intPtr, retrieved, out retrieved);
			}
			if (rESULT == RESULT.OK)
			{
				path = threadSafeEncoding.stringFromNative(intPtr);
			}
			Marshal.FreeHGlobal(intPtr);
			return rESULT;
		}

		public RESULT getNumListeners(out int numlisteners)
		{
			return FMOD_Studio_System_GetNumListeners(handle, out numlisteners);
		}

		public RESULT setNumListeners(int numlisteners)
		{
			return FMOD_Studio_System_SetNumListeners(handle, numlisteners);
		}

		public RESULT getListenerAttributes(int listener, out ATTRIBUTES_3D attributes)
		{
			return FMOD_Studio_System_GetListenerAttributes(handle, listener, out attributes);
		}

		public RESULT setListenerAttributes(int listener, ATTRIBUTES_3D attributes)
		{
			return FMOD_Studio_System_SetListenerAttributes(handle, listener, ref attributes);
		}

		public RESULT getListenerWeight(int listener, out float weight)
		{
			return FMOD_Studio_System_GetListenerWeight(handle, listener, out weight);
		}

		public RESULT setListenerWeight(int listener, float weight)
		{
			return FMOD_Studio_System_SetListenerWeight(handle, listener, weight);
		}

		public RESULT loadBankFile(string name, LOAD_BANK_FLAGS flags, out Bank bank)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD_Studio_System_LoadBankFile(handle, threadSafeEncoding.byteFromStringUTF8(name), flags, out bank.handle);
		}

		public RESULT loadBankMemory(byte[] buffer, LOAD_BANK_FLAGS flags, out Bank bank)
		{
			GCHandle gCHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
			IntPtr buffer2 = gCHandle.AddrOfPinnedObject();
			RESULT result = FMOD_Studio_System_LoadBankMemory(handle, buffer2, buffer.Length, LOAD_MEMORY_MODE.LOAD_MEMORY, flags, out bank.handle);
			gCHandle.Free();
			return result;
		}

		public RESULT loadBankCustom(BANK_INFO info, LOAD_BANK_FLAGS flags, out Bank bank)
		{
			info.size = Marshal.SizeOf(info);
			return FMOD_Studio_System_LoadBankCustom(handle, ref info, flags, out bank.handle);
		}

		public RESULT unloadAll()
		{
			return FMOD_Studio_System_UnloadAll(handle);
		}

		public RESULT flushCommands()
		{
			return FMOD_Studio_System_FlushCommands(handle);
		}

		public RESULT flushSampleLoading()
		{
			return FMOD_Studio_System_FlushSampleLoading(handle);
		}

		public RESULT startCommandCapture(string path, COMMANDCAPTURE_FLAGS flags)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD_Studio_System_StartCommandCapture(handle, threadSafeEncoding.byteFromStringUTF8(path), flags);
		}

		public RESULT stopCommandCapture()
		{
			return FMOD_Studio_System_StopCommandCapture(handle);
		}

		public RESULT loadCommandReplay(string path, COMMANDREPLAY_FLAGS flags, out CommandReplay replay)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD_Studio_System_LoadCommandReplay(handle, threadSafeEncoding.byteFromStringUTF8(path), flags, out replay.handle);
		}

		public RESULT getBankCount(out int count)
		{
			return FMOD_Studio_System_GetBankCount(handle, out count);
		}

		public RESULT getBankList(out Bank[] array)
		{
			array = null;
			RESULT rESULT = FMOD_Studio_System_GetBankCount(handle, out var count);
			if (rESULT != 0)
			{
				return rESULT;
			}
			if (count == 0)
			{
				array = new Bank[0];
				return rESULT;
			}
			IntPtr[] array2 = new IntPtr[count];
			rESULT = FMOD_Studio_System_GetBankList(handle, array2, count, out var count2);
			if (rESULT != 0)
			{
				return rESULT;
			}
			if (count2 > count)
			{
				count2 = count;
			}
			array = new Bank[count2];
			for (int i = 0; i < count2; i++)
			{
				array[i].handle = array2[i];
			}
			return RESULT.OK;
		}

		public RESULT getCPUUsage(out CPU_USAGE usage)
		{
			return FMOD_Studio_System_GetCPUUsage(handle, out usage);
		}

		public RESULT getBufferUsage(out BUFFER_USAGE usage)
		{
			return FMOD_Studio_System_GetBufferUsage(handle, out usage);
		}

		public RESULT resetBufferUsage()
		{
			return FMOD_Studio_System_ResetBufferUsage(handle);
		}

		public RESULT setCallback(SYSTEM_CALLBACK callback, SYSTEM_CALLBACK_TYPE callbackmask = SYSTEM_CALLBACK_TYPE.ALL)
		{
			return FMOD_Studio_System_SetCallback(handle, callback, callbackmask);
		}

		public RESULT getUserData(out IntPtr userdata)
		{
			return FMOD_Studio_System_GetUserData(handle, out userdata);
		}

		public RESULT setUserData(IntPtr userdata)
		{
			return FMOD_Studio_System_SetUserData(handle, userdata);
		}

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_Create(out IntPtr studiosystem, uint headerversion);

		[DllImport("fmodstudio")]
		private static extern bool FMOD_Studio_System_IsValid(IntPtr studiosystem);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_SetAdvancedSettings(IntPtr studiosystem, ref ADVANCEDSETTINGS settings);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_GetAdvancedSettings(IntPtr studiosystem, out ADVANCEDSETTINGS settings);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_Initialize(IntPtr studiosystem, int maxchannels, INITFLAGS studioFlags, FMOD.INITFLAGS flags, IntPtr extradriverdata);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_Release(IntPtr studiosystem);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_Update(IntPtr studiosystem);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_GetLowLevelSystem(IntPtr studiosystem, out IntPtr system);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_GetEvent(IntPtr studiosystem, byte[] path, out IntPtr description);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_GetBus(IntPtr studiosystem, byte[] path, out IntPtr bus);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_GetVCA(IntPtr studiosystem, byte[] path, out IntPtr vca);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_GetBank(IntPtr studiosystem, byte[] path, out IntPtr bank);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_GetEventByID(IntPtr studiosystem, ref Guid guid, out IntPtr description);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_GetBusByID(IntPtr studiosystem, ref Guid guid, out IntPtr bus);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_GetVCAByID(IntPtr studiosystem, ref Guid guid, out IntPtr vca);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_GetBankByID(IntPtr studiosystem, ref Guid guid, out IntPtr bank);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_GetSoundInfo(IntPtr studiosystem, byte[] key, out SOUND_INFO info);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_LookupID(IntPtr studiosystem, byte[] path, out Guid guid);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_LookupPath(IntPtr studiosystem, ref Guid guid, IntPtr path, int size, out int retrieved);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_GetNumListeners(IntPtr studiosystem, out int numlisteners);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_SetNumListeners(IntPtr studiosystem, int numlisteners);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_GetListenerAttributes(IntPtr studiosystem, int listener, out ATTRIBUTES_3D attributes);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_SetListenerAttributes(IntPtr studiosystem, int listener, ref ATTRIBUTES_3D attributes);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_GetListenerWeight(IntPtr studiosystem, int listener, out float weight);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_SetListenerWeight(IntPtr studiosystem, int listener, float weight);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_LoadBankFile(IntPtr studiosystem, byte[] filename, LOAD_BANK_FLAGS flags, out IntPtr bank);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_LoadBankMemory(IntPtr studiosystem, IntPtr buffer, int length, LOAD_MEMORY_MODE mode, LOAD_BANK_FLAGS flags, out IntPtr bank);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_LoadBankCustom(IntPtr studiosystem, ref BANK_INFO info, LOAD_BANK_FLAGS flags, out IntPtr bank);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_UnloadAll(IntPtr studiosystem);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_FlushCommands(IntPtr studiosystem);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_FlushSampleLoading(IntPtr studiosystem);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_StartCommandCapture(IntPtr studiosystem, byte[] path, COMMANDCAPTURE_FLAGS flags);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_StopCommandCapture(IntPtr studiosystem);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_LoadCommandReplay(IntPtr studiosystem, byte[] path, COMMANDREPLAY_FLAGS flags, out IntPtr commandReplay);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_GetBankCount(IntPtr studiosystem, out int count);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_GetBankList(IntPtr studiosystem, IntPtr[] array, int capacity, out int count);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_GetCPUUsage(IntPtr studiosystem, out CPU_USAGE usage);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_GetBufferUsage(IntPtr studiosystem, out BUFFER_USAGE usage);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_ResetBufferUsage(IntPtr studiosystem);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_SetCallback(IntPtr studiosystem, SYSTEM_CALLBACK callback, SYSTEM_CALLBACK_TYPE callbackmask);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_GetUserData(IntPtr studiosystem, out IntPtr userdata);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_System_SetUserData(IntPtr studiosystem, IntPtr userdata);

		public bool hasHandle()
		{
			return handle != IntPtr.Zero;
		}

		public void clearHandle()
		{
			handle = IntPtr.Zero;
		}

		public bool isValid()
		{
			if (hasHandle())
			{
				return FMOD_Studio_System_IsValid(handle);
			}
			return false;
		}
	}
	public struct EventDescription
	{
		public IntPtr handle;

		public RESULT getID(out Guid id)
		{
			return FMOD_Studio_EventDescription_GetID(handle, out id);
		}

		public RESULT getPath(out string path)
		{
			path = null;
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			IntPtr intPtr = Marshal.AllocHGlobal(256);
			int retrieved = 0;
			RESULT rESULT = FMOD_Studio_EventDescription_GetPath(handle, intPtr, 256, out retrieved);
			if (rESULT == RESULT.ERR_TRUNCATED)
			{
				Marshal.FreeHGlobal(intPtr);
				intPtr = Marshal.AllocHGlobal(retrieved);
				rESULT = FMOD_Studio_EventDescription_GetPath(handle, intPtr, retrieved, out retrieved);
			}
			if (rESULT == RESULT.OK)
			{
				path = threadSafeEncoding.stringFromNative(intPtr);
			}
			Marshal.FreeHGlobal(intPtr);
			return rESULT;
		}

		public RESULT getParameterCount(out int count)
		{
			return FMOD_Studio_EventDescription_GetParameterCount(handle, out count);
		}

		public RESULT getParameterByIndex(int index, out PARAMETER_DESCRIPTION parameter)
		{
			return FMOD_Studio_EventDescription_GetParameterByIndex(handle, index, out parameter);
		}

		public RESULT getParameter(string name, out PARAMETER_DESCRIPTION parameter)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD_Studio_EventDescription_GetParameter(handle, threadSafeEncoding.byteFromStringUTF8(name), out parameter);
		}

		public RESULT getUserPropertyCount(out int count)
		{
			return FMOD_Studio_EventDescription_GetUserPropertyCount(handle, out count);
		}

		public RESULT getUserPropertyByIndex(int index, out USER_PROPERTY property)
		{
			return FMOD_Studio_EventDescription_GetUserPropertyByIndex(handle, index, out property);
		}

		public RESULT getUserProperty(string name, out USER_PROPERTY property)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD_Studio_EventDescription_GetUserProperty(handle, threadSafeEncoding.byteFromStringUTF8(name), out property);
		}

		public RESULT getLength(out int length)
		{
			return FMOD_Studio_EventDescription_GetLength(handle, out length);
		}

		public RESULT getMinimumDistance(out float distance)
		{
			return FMOD_Studio_EventDescription_GetMinimumDistance(handle, out distance);
		}

		public RESULT getMaximumDistance(out float distance)
		{
			return FMOD_Studio_EventDescription_GetMaximumDistance(handle, out distance);
		}

		public RESULT getSoundSize(out float size)
		{
			return FMOD_Studio_EventDescription_GetSoundSize(handle, out size);
		}

		public RESULT isSnapshot(out bool snapshot)
		{
			return FMOD_Studio_EventDescription_IsSnapshot(handle, out snapshot);
		}

		public RESULT isOneshot(out bool oneshot)
		{
			return FMOD_Studio_EventDescription_IsOneshot(handle, out oneshot);
		}

		public RESULT isStream(out bool isStream)
		{
			return FMOD_Studio_EventDescription_IsStream(handle, out isStream);
		}

		public RESULT is3D(out bool is3D)
		{
			return FMOD_Studio_EventDescription_Is3D(handle, out is3D);
		}

		public RESULT hasCue(out bool cue)
		{
			return FMOD_Studio_EventDescription_HasCue(handle, out cue);
		}

		public RESULT createInstance(out EventInstance instance)
		{
			return FMOD_Studio_EventDescription_CreateInstance(handle, out instance.handle);
		}

		public RESULT getInstanceCount(out int count)
		{
			return FMOD_Studio_EventDescription_GetInstanceCount(handle, out count);
		}

		public RESULT getInstanceList(out EventInstance[] array)
		{
			array = null;
			RESULT rESULT = FMOD_Studio_EventDescription_GetInstanceCount(handle, out var count);
			if (rESULT != 0)
			{
				return rESULT;
			}
			if (count == 0)
			{
				array = new EventInstance[0];
				return rESULT;
			}
			IntPtr[] array2 = new IntPtr[count];
			rESULT = FMOD_Studio_EventDescription_GetInstanceList(handle, array2, count, out var count2);
			if (rESULT != 0)
			{
				return rESULT;
			}
			if (count2 > count)
			{
				count2 = count;
			}
			array = new EventInstance[count2];
			for (int i = 0; i < count2; i++)
			{
				array[i].handle = array2[i];
			}
			return RESULT.OK;
		}

		public RESULT loadSampleData()
		{
			return FMOD_Studio_EventDescription_LoadSampleData(handle);
		}

		public RESULT unloadSampleData()
		{
			return FMOD_Studio_EventDescription_UnloadSampleData(handle);
		}

		public RESULT getSampleLoadingState(out LOADING_STATE state)
		{
			return FMOD_Studio_EventDescription_GetSampleLoadingState(handle, out state);
		}

		public RESULT releaseAllInstances()
		{
			return FMOD_Studio_EventDescription_ReleaseAllInstances(handle);
		}

		public RESULT setCallback(EVENT_CALLBACK callback, EVENT_CALLBACK_TYPE callbackmask = EVENT_CALLBACK_TYPE.ALL)
		{
			return FMOD_Studio_EventDescription_SetCallback(handle, callback, callbackmask);
		}

		public RESULT getUserData(out IntPtr userdata)
		{
			return FMOD_Studio_EventDescription_GetUserData(handle, out userdata);
		}

		public RESULT setUserData(IntPtr userdata)
		{
			return FMOD_Studio_EventDescription_SetUserData(handle, userdata);
		}

		[DllImport("fmodstudio")]
		private static extern bool FMOD_Studio_EventDescription_IsValid(IntPtr eventdescription);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_GetID(IntPtr eventdescription, out Guid id);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_GetPath(IntPtr eventdescription, IntPtr path, int size, out int retrieved);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_GetParameterCount(IntPtr eventdescription, out int count);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_GetParameterByIndex(IntPtr eventdescription, int index, out PARAMETER_DESCRIPTION parameter);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_GetParameter(IntPtr eventdescription, byte[] name, out PARAMETER_DESCRIPTION parameter);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_GetUserPropertyCount(IntPtr eventdescription, out int count);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_GetUserPropertyByIndex(IntPtr eventdescription, int index, out USER_PROPERTY property);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_GetUserProperty(IntPtr eventdescription, byte[] name, out USER_PROPERTY property);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_GetLength(IntPtr eventdescription, out int length);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_GetMinimumDistance(IntPtr eventdescription, out float distance);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_GetMaximumDistance(IntPtr eventdescription, out float distance);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_GetSoundSize(IntPtr eventdescription, out float size);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_IsSnapshot(IntPtr eventdescription, out bool snapshot);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_IsOneshot(IntPtr eventdescription, out bool oneshot);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_IsStream(IntPtr eventdescription, out bool isStream);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_Is3D(IntPtr eventdescription, out bool is3D);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_HasCue(IntPtr eventdescription, out bool cue);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_CreateInstance(IntPtr eventdescription, out IntPtr instance);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_GetInstanceCount(IntPtr eventdescription, out int count);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_GetInstanceList(IntPtr eventdescription, IntPtr[] array, int capacity, out int count);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_LoadSampleData(IntPtr eventdescription);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_UnloadSampleData(IntPtr eventdescription);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_GetSampleLoadingState(IntPtr eventdescription, out LOADING_STATE state);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_ReleaseAllInstances(IntPtr eventdescription);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_SetCallback(IntPtr eventdescription, EVENT_CALLBACK callback, EVENT_CALLBACK_TYPE callbackmask);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_GetUserData(IntPtr eventdescription, out IntPtr userdata);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventDescription_SetUserData(IntPtr eventdescription, IntPtr userdata);

		public bool hasHandle()
		{
			return handle != IntPtr.Zero;
		}

		public void clearHandle()
		{
			handle = IntPtr.Zero;
		}

		public bool isValid()
		{
			if (hasHandle())
			{
				return FMOD_Studio_EventDescription_IsValid(handle);
			}
			return false;
		}
	}
	public struct EventInstance
	{
		public IntPtr handle;

		public RESULT getDescription(out EventDescription description)
		{
			return FMOD_Studio_EventInstance_GetDescription(handle, out description.handle);
		}

		public RESULT getVolume(out float volume, out float finalvolume)
		{
			return FMOD_Studio_EventInstance_GetVolume(handle, out volume, out finalvolume);
		}

		public RESULT setVolume(float volume)
		{
			return FMOD_Studio_EventInstance_SetVolume(handle, volume);
		}

		public RESULT getPitch(out float pitch, out float finalpitch)
		{
			return FMOD_Studio_EventInstance_GetPitch(handle, out pitch, out finalpitch);
		}

		public RESULT setPitch(float pitch)
		{
			return FMOD_Studio_EventInstance_SetPitch(handle, pitch);
		}

		public RESULT get3DAttributes(out ATTRIBUTES_3D attributes)
		{
			return FMOD_Studio_EventInstance_Get3DAttributes(handle, out attributes);
		}

		public RESULT set3DAttributes(ATTRIBUTES_3D attributes)
		{
			return FMOD_Studio_EventInstance_Set3DAttributes(handle, ref attributes);
		}

		public RESULT getListenerMask(out uint mask)
		{
			return FMOD_Studio_EventInstance_GetListenerMask(handle, out mask);
		}

		public RESULT setListenerMask(uint mask)
		{
			return FMOD_Studio_EventInstance_SetListenerMask(handle, mask);
		}

		public RESULT getProperty(EVENT_PROPERTY index, out float value)
		{
			return FMOD_Studio_EventInstance_GetProperty(handle, index, out value);
		}

		public RESULT setProperty(EVENT_PROPERTY index, float value)
		{
			return FMOD_Studio_EventInstance_SetProperty(handle, index, value);
		}

		public RESULT getReverbLevel(int index, out float level)
		{
			return FMOD_Studio_EventInstance_GetReverbLevel(handle, index, out level);
		}

		public RESULT setReverbLevel(int index, float level)
		{
			return FMOD_Studio_EventInstance_SetReverbLevel(handle, index, level);
		}

		public RESULT getPaused(out bool paused)
		{
			return FMOD_Studio_EventInstance_GetPaused(handle, out paused);
		}

		public RESULT setPaused(bool paused)
		{
			return FMOD_Studio_EventInstance_SetPaused(handle, paused);
		}

		public RESULT start()
		{
			return FMOD_Studio_EventInstance_Start(handle);
		}

		public RESULT stop(STOP_MODE mode)
		{
			return FMOD_Studio_EventInstance_Stop(handle, mode);
		}

		public RESULT getTimelinePosition(out int position)
		{
			return FMOD_Studio_EventInstance_GetTimelinePosition(handle, out position);
		}

		public RESULT setTimelinePosition(int position)
		{
			return FMOD_Studio_EventInstance_SetTimelinePosition(handle, position);
		}

		public RESULT getPlaybackState(out PLAYBACK_STATE state)
		{
			return FMOD_Studio_EventInstance_GetPlaybackState(handle, out state);
		}

		public RESULT getChannelGroup(out ChannelGroup group)
		{
			return FMOD_Studio_EventInstance_GetChannelGroup(handle, out group.handle);
		}

		public RESULT release()
		{
			return FMOD_Studio_EventInstance_Release(handle);
		}

		public RESULT isVirtual(out bool virtualState)
		{
			return FMOD_Studio_EventInstance_IsVirtual(handle, out virtualState);
		}

		public RESULT getParameter(string name, out ParameterInstance instance)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD_Studio_EventInstance_GetParameter(handle, threadSafeEncoding.byteFromStringUTF8(name), out instance.handle);
		}

		public RESULT getParameterCount(out int count)
		{
			return FMOD_Studio_EventInstance_GetParameterCount(handle, out count);
		}

		public RESULT getParameterByIndex(int index, out ParameterInstance instance)
		{
			return FMOD_Studio_EventInstance_GetParameterByIndex(handle, index, out instance.handle);
		}

		public RESULT getParameterValue(string name, out float value, out float finalvalue)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD_Studio_EventInstance_GetParameterValue(handle, threadSafeEncoding.byteFromStringUTF8(name), out value, out finalvalue);
		}

		public RESULT setParameterValue(string name, float value)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD_Studio_EventInstance_SetParameterValue(handle, threadSafeEncoding.byteFromStringUTF8(name), value);
		}

		public RESULT getParameterValueByIndex(int index, out float value, out float finalvalue)
		{
			return FMOD_Studio_EventInstance_GetParameterValueByIndex(handle, index, out value, out finalvalue);
		}

		public RESULT setParameterValueByIndex(int index, float value)
		{
			return FMOD_Studio_EventInstance_SetParameterValueByIndex(handle, index, value);
		}

		public RESULT setParameterValuesByIndices(int[] indices, float[] values, int count)
		{
			return FMOD_Studio_EventInstance_SetParameterValuesByIndices(handle, indices, values, count);
		}

		public RESULT triggerCue()
		{
			return FMOD_Studio_EventInstance_TriggerCue(handle);
		}

		public RESULT setCallback(EVENT_CALLBACK callback, EVENT_CALLBACK_TYPE callbackmask = EVENT_CALLBACK_TYPE.ALL)
		{
			return FMOD_Studio_EventInstance_SetCallback(handle, callback, callbackmask);
		}

		public RESULT getUserData(out IntPtr userdata)
		{
			return FMOD_Studio_EventInstance_GetUserData(handle, out userdata);
		}

		public RESULT setUserData(IntPtr userdata)
		{
			return FMOD_Studio_EventInstance_SetUserData(handle, userdata);
		}

		[DllImport("fmodstudio")]
		private static extern bool FMOD_Studio_EventInstance_IsValid(IntPtr _event);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_GetDescription(IntPtr _event, out IntPtr description);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_GetVolume(IntPtr _event, out float volume, out float finalvolume);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_SetVolume(IntPtr _event, float volume);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_GetPitch(IntPtr _event, out float pitch, out float finalpitch);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_SetPitch(IntPtr _event, float pitch);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_Get3DAttributes(IntPtr _event, out ATTRIBUTES_3D attributes);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_Set3DAttributes(IntPtr _event, ref ATTRIBUTES_3D attributes);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_GetListenerMask(IntPtr _event, out uint mask);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_SetListenerMask(IntPtr _event, uint mask);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_GetProperty(IntPtr _event, EVENT_PROPERTY index, out float value);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_SetProperty(IntPtr _event, EVENT_PROPERTY index, float value);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_GetReverbLevel(IntPtr _event, int index, out float level);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_SetReverbLevel(IntPtr _event, int index, float level);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_GetPaused(IntPtr _event, out bool paused);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_SetPaused(IntPtr _event, bool paused);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_Start(IntPtr _event);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_Stop(IntPtr _event, STOP_MODE mode);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_GetTimelinePosition(IntPtr _event, out int position);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_SetTimelinePosition(IntPtr _event, int position);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_GetPlaybackState(IntPtr _event, out PLAYBACK_STATE state);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_GetChannelGroup(IntPtr _event, out IntPtr group);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_Release(IntPtr _event);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_IsVirtual(IntPtr _event, out bool virtualState);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_GetParameter(IntPtr _event, byte[] name, out IntPtr parameter);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_GetParameterByIndex(IntPtr _event, int index, out IntPtr parameter);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_GetParameterCount(IntPtr _event, out int count);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_GetParameterValue(IntPtr _event, byte[] name, out float value, out float finalvalue);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_SetParameterValue(IntPtr _event, byte[] name, float value);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_GetParameterValueByIndex(IntPtr _event, int index, out float value, out float finalvalue);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_SetParameterValueByIndex(IntPtr _event, int index, float value);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_SetParameterValuesByIndices(IntPtr _event, int[] indices, float[] values, int count);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_TriggerCue(IntPtr _event);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_SetCallback(IntPtr _event, EVENT_CALLBACK callback, EVENT_CALLBACK_TYPE callbackmask);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_GetUserData(IntPtr _event, out IntPtr userdata);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_EventInstance_SetUserData(IntPtr _event, IntPtr userdata);

		public bool hasHandle()
		{
			return handle != IntPtr.Zero;
		}

		public void clearHandle()
		{
			handle = IntPtr.Zero;
		}

		public bool isValid()
		{
			if (hasHandle())
			{
				return FMOD_Studio_EventInstance_IsValid(handle);
			}
			return false;
		}
	}
	public struct ParameterInstance
	{
		public IntPtr handle;

		public RESULT getDescription(out PARAMETER_DESCRIPTION description)
		{
			return FMOD_Studio_ParameterInstance_GetDescription(handle, out description);
		}

		public RESULT getValue(out float value)
		{
			return FMOD_Studio_ParameterInstance_GetValue(handle, out value);
		}

		public RESULT setValue(float value)
		{
			return FMOD_Studio_ParameterInstance_SetValue(handle, value);
		}

		[DllImport("fmodstudio")]
		private static extern bool FMOD_Studio_ParameterInstance_IsValid(IntPtr parameter);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_ParameterInstance_GetDescription(IntPtr parameter, out PARAMETER_DESCRIPTION description);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_ParameterInstance_GetValue(IntPtr parameter, out float value);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_ParameterInstance_SetValue(IntPtr parameter, float value);

		public bool hasHandle()
		{
			return handle != IntPtr.Zero;
		}

		public void clearHandle()
		{
			handle = IntPtr.Zero;
		}

		public bool isValid()
		{
			if (hasHandle())
			{
				return FMOD_Studio_ParameterInstance_IsValid(handle);
			}
			return false;
		}
	}
	public struct Bus
	{
		public IntPtr handle;

		public RESULT getID(out Guid id)
		{
			return FMOD_Studio_Bus_GetID(handle, out id);
		}

		public RESULT getPath(out string path)
		{
			path = null;
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			IntPtr intPtr = Marshal.AllocHGlobal(256);
			int retrieved = 0;
			RESULT rESULT = FMOD_Studio_Bus_GetPath(handle, intPtr, 256, out retrieved);
			if (rESULT == RESULT.ERR_TRUNCATED)
			{
				Marshal.FreeHGlobal(intPtr);
				intPtr = Marshal.AllocHGlobal(retrieved);
				rESULT = FMOD_Studio_Bus_GetPath(handle, intPtr, retrieved, out retrieved);
			}
			if (rESULT == RESULT.OK)
			{
				path = threadSafeEncoding.stringFromNative(intPtr);
			}
			Marshal.FreeHGlobal(intPtr);
			return rESULT;
		}

		public RESULT getVolume(out float volume, out float finalvolume)
		{
			return FMOD_Studio_Bus_GetVolume(handle, out volume, out finalvolume);
		}

		public RESULT setVolume(float volume)
		{
			return FMOD_Studio_Bus_SetVolume(handle, volume);
		}

		public RESULT getPaused(out bool paused)
		{
			return FMOD_Studio_Bus_GetPaused(handle, out paused);
		}

		public RESULT setPaused(bool paused)
		{
			return FMOD_Studio_Bus_SetPaused(handle, paused);
		}

		public RESULT getMute(out bool mute)
		{
			return FMOD_Studio_Bus_GetMute(handle, out mute);
		}

		public RESULT setMute(bool mute)
		{
			return FMOD_Studio_Bus_SetMute(handle, mute);
		}

		public RESULT stopAllEvents(STOP_MODE mode)
		{
			return FMOD_Studio_Bus_StopAllEvents(handle, mode);
		}

		public RESULT lockChannelGroup()
		{
			return FMOD_Studio_Bus_LockChannelGroup(handle);
		}

		public RESULT unlockChannelGroup()
		{
			return FMOD_Studio_Bus_UnlockChannelGroup(handle);
		}

		public RESULT getChannelGroup(out ChannelGroup group)
		{
			return FMOD_Studio_Bus_GetChannelGroup(handle, out group.handle);
		}

		[DllImport("fmodstudio")]
		private static extern bool FMOD_Studio_Bus_IsValid(IntPtr bus);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bus_GetID(IntPtr bus, out Guid id);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bus_GetPath(IntPtr bus, IntPtr path, int size, out int retrieved);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bus_GetVolume(IntPtr bus, out float volume, out float finalvolume);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bus_SetVolume(IntPtr bus, float value);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bus_GetPaused(IntPtr bus, out bool paused);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bus_SetPaused(IntPtr bus, bool paused);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bus_GetMute(IntPtr bus, out bool mute);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bus_SetMute(IntPtr bus, bool mute);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bus_StopAllEvents(IntPtr bus, STOP_MODE mode);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bus_LockChannelGroup(IntPtr bus);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bus_UnlockChannelGroup(IntPtr bus);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bus_GetChannelGroup(IntPtr bus, out IntPtr group);

		public bool hasHandle()
		{
			return handle != IntPtr.Zero;
		}

		public void clearHandle()
		{
			handle = IntPtr.Zero;
		}

		public bool isValid()
		{
			if (hasHandle())
			{
				return FMOD_Studio_Bus_IsValid(handle);
			}
			return false;
		}
	}
	public struct VCA
	{
		public IntPtr handle;

		public RESULT getID(out Guid id)
		{
			return FMOD_Studio_VCA_GetID(handle, out id);
		}

		public RESULT getPath(out string path)
		{
			path = null;
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			IntPtr intPtr = Marshal.AllocHGlobal(256);
			int retrieved = 0;
			RESULT rESULT = FMOD_Studio_VCA_GetPath(handle, intPtr, 256, out retrieved);
			if (rESULT == RESULT.ERR_TRUNCATED)
			{
				Marshal.FreeHGlobal(intPtr);
				intPtr = Marshal.AllocHGlobal(retrieved);
				rESULT = FMOD_Studio_VCA_GetPath(handle, intPtr, retrieved, out retrieved);
			}
			if (rESULT == RESULT.OK)
			{
				path = threadSafeEncoding.stringFromNative(intPtr);
			}
			Marshal.FreeHGlobal(intPtr);
			return rESULT;
		}

		public RESULT getVolume(out float volume, out float finalvolume)
		{
			return FMOD_Studio_VCA_GetVolume(handle, out volume, out finalvolume);
		}

		public RESULT setVolume(float volume)
		{
			return FMOD_Studio_VCA_SetVolume(handle, volume);
		}

		[DllImport("fmodstudio")]
		private static extern bool FMOD_Studio_VCA_IsValid(IntPtr vca);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_VCA_GetID(IntPtr vca, out Guid id);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_VCA_GetPath(IntPtr vca, IntPtr path, int size, out int retrieved);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_VCA_GetVolume(IntPtr vca, out float volume, out float finalvolume);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_VCA_SetVolume(IntPtr vca, float value);

		public bool hasHandle()
		{
			return handle != IntPtr.Zero;
		}

		public void clearHandle()
		{
			handle = IntPtr.Zero;
		}

		public bool isValid()
		{
			if (hasHandle())
			{
				return FMOD_Studio_VCA_IsValid(handle);
			}
			return false;
		}
	}
	public struct Bank
	{
		public IntPtr handle;

		public RESULT getID(out Guid id)
		{
			return FMOD_Studio_Bank_GetID(handle, out id);
		}

		public RESULT getPath(out string path)
		{
			path = null;
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			IntPtr intPtr = Marshal.AllocHGlobal(256);
			int retrieved = 0;
			RESULT rESULT = FMOD_Studio_Bank_GetPath(handle, intPtr, 256, out retrieved);
			if (rESULT == RESULT.ERR_TRUNCATED)
			{
				Marshal.FreeHGlobal(intPtr);
				intPtr = Marshal.AllocHGlobal(retrieved);
				rESULT = FMOD_Studio_Bank_GetPath(handle, intPtr, retrieved, out retrieved);
			}
			if (rESULT == RESULT.OK)
			{
				path = threadSafeEncoding.stringFromNative(intPtr);
			}
			Marshal.FreeHGlobal(intPtr);
			return rESULT;
		}

		public RESULT unload()
		{
			return FMOD_Studio_Bank_Unload(handle);
		}

		public RESULT loadSampleData()
		{
			return FMOD_Studio_Bank_LoadSampleData(handle);
		}

		public RESULT unloadSampleData()
		{
			return FMOD_Studio_Bank_UnloadSampleData(handle);
		}

		public RESULT getLoadingState(out LOADING_STATE state)
		{
			return FMOD_Studio_Bank_GetLoadingState(handle, out state);
		}

		public RESULT getSampleLoadingState(out LOADING_STATE state)
		{
			return FMOD_Studio_Bank_GetSampleLoadingState(handle, out state);
		}

		public RESULT getStringCount(out int count)
		{
			return FMOD_Studio_Bank_GetStringCount(handle, out count);
		}

		public RESULT getStringInfo(int index, out Guid id, out string path)
		{
			path = null;
			id = Guid.Empty;
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			IntPtr intPtr = Marshal.AllocHGlobal(256);
			int retrieved = 0;
			RESULT rESULT = FMOD_Studio_Bank_GetStringInfo(handle, index, out id, intPtr, 256, out retrieved);
			if (rESULT == RESULT.ERR_TRUNCATED)
			{
				Marshal.FreeHGlobal(intPtr);
				intPtr = Marshal.AllocHGlobal(retrieved);
				rESULT = FMOD_Studio_Bank_GetStringInfo(handle, index, out id, intPtr, retrieved, out retrieved);
			}
			if (rESULT == RESULT.OK)
			{
				path = threadSafeEncoding.stringFromNative(intPtr);
			}
			Marshal.FreeHGlobal(intPtr);
			return rESULT;
		}

		public RESULT getEventCount(out int count)
		{
			return FMOD_Studio_Bank_GetEventCount(handle, out count);
		}

		public RESULT getEventList(out EventDescription[] array)
		{
			array = null;
			RESULT rESULT = FMOD_Studio_Bank_GetEventCount(handle, out var count);
			if (rESULT != 0)
			{
				return rESULT;
			}
			if (count == 0)
			{
				array = new EventDescription[0];
				return rESULT;
			}
			IntPtr[] array2 = new IntPtr[count];
			rESULT = FMOD_Studio_Bank_GetEventList(handle, array2, count, out var count2);
			if (rESULT != 0)
			{
				return rESULT;
			}
			if (count2 > count)
			{
				count2 = count;
			}
			array = new EventDescription[count2];
			for (int i = 0; i < count2; i++)
			{
				array[i].handle = array2[i];
			}
			return RESULT.OK;
		}

		public RESULT getBusCount(out int count)
		{
			return FMOD_Studio_Bank_GetBusCount(handle, out count);
		}

		public RESULT getBusList(out Bus[] array)
		{
			array = null;
			RESULT rESULT = FMOD_Studio_Bank_GetBusCount(handle, out var count);
			if (rESULT != 0)
			{
				return rESULT;
			}
			if (count == 0)
			{
				array = new Bus[0];
				return rESULT;
			}
			IntPtr[] array2 = new IntPtr[count];
			rESULT = FMOD_Studio_Bank_GetBusList(handle, array2, count, out var count2);
			if (rESULT != 0)
			{
				return rESULT;
			}
			if (count2 > count)
			{
				count2 = count;
			}
			array = new Bus[count2];
			for (int i = 0; i < count2; i++)
			{
				array[i].handle = array2[i];
			}
			return RESULT.OK;
		}

		public RESULT getVCACount(out int count)
		{
			return FMOD_Studio_Bank_GetVCACount(handle, out count);
		}

		public RESULT getVCAList(out VCA[] array)
		{
			array = null;
			RESULT rESULT = FMOD_Studio_Bank_GetVCACount(handle, out var count);
			if (rESULT != 0)
			{
				return rESULT;
			}
			if (count == 0)
			{
				array = new VCA[0];
				return rESULT;
			}
			IntPtr[] array2 = new IntPtr[count];
			rESULT = FMOD_Studio_Bank_GetVCAList(handle, array2, count, out var count2);
			if (rESULT != 0)
			{
				return rESULT;
			}
			if (count2 > count)
			{
				count2 = count;
			}
			array = new VCA[count2];
			for (int i = 0; i < count2; i++)
			{
				array[i].handle = array2[i];
			}
			return RESULT.OK;
		}

		public RESULT getUserData(out IntPtr userdata)
		{
			return FMOD_Studio_Bank_GetUserData(handle, out userdata);
		}

		public RESULT setUserData(IntPtr userdata)
		{
			return FMOD_Studio_Bank_SetUserData(handle, userdata);
		}

		[DllImport("fmodstudio")]
		private static extern bool FMOD_Studio_Bank_IsValid(IntPtr bank);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bank_GetID(IntPtr bank, out Guid id);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bank_GetPath(IntPtr bank, IntPtr path, int size, out int retrieved);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bank_Unload(IntPtr bank);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bank_LoadSampleData(IntPtr bank);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bank_UnloadSampleData(IntPtr bank);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bank_GetLoadingState(IntPtr bank, out LOADING_STATE state);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bank_GetSampleLoadingState(IntPtr bank, out LOADING_STATE state);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bank_GetStringCount(IntPtr bank, out int count);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bank_GetStringInfo(IntPtr bank, int index, out Guid id, IntPtr path, int size, out int retrieved);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bank_GetEventCount(IntPtr bank, out int count);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bank_GetEventList(IntPtr bank, IntPtr[] array, int capacity, out int count);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bank_GetBusCount(IntPtr bank, out int count);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bank_GetBusList(IntPtr bank, IntPtr[] array, int capacity, out int count);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bank_GetVCACount(IntPtr bank, out int count);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bank_GetVCAList(IntPtr bank, IntPtr[] array, int capacity, out int count);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bank_GetUserData(IntPtr bank, out IntPtr userdata);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_Bank_SetUserData(IntPtr bank, IntPtr userdata);

		public bool hasHandle()
		{
			return handle != IntPtr.Zero;
		}

		public void clearHandle()
		{
			handle = IntPtr.Zero;
		}

		public bool isValid()
		{
			if (hasHandle())
			{
				return FMOD_Studio_Bank_IsValid(handle);
			}
			return false;
		}
	}
	public struct CommandReplay
	{
		public IntPtr handle;

		public RESULT getSystem(out System system)
		{
			return FMOD_Studio_CommandReplay_GetSystem(handle, out system.handle);
		}

		public RESULT getLength(out float totalTime)
		{
			return FMOD_Studio_CommandReplay_GetLength(handle, out totalTime);
		}

		public RESULT getCommandCount(out int count)
		{
			return FMOD_Studio_CommandReplay_GetCommandCount(handle, out count);
		}

		public RESULT getCommandInfo(int commandIndex, out COMMAND_INFO info)
		{
			return FMOD_Studio_CommandReplay_GetCommandInfo(handle, commandIndex, out info);
		}

		public RESULT getCommandString(int commandIndex, out string description)
		{
			description = null;
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			int num = 256;
			IntPtr intPtr = Marshal.AllocHGlobal(256);
			RESULT rESULT = FMOD_Studio_CommandReplay_GetCommandString(handle, commandIndex, intPtr, num);
			while (true)
			{
				switch (rESULT)
				{
				case RESULT.ERR_TRUNCATED:
					goto IL_002b;
				case RESULT.OK:
					description = threadSafeEncoding.stringFromNative(intPtr);
					break;
				}
				break;
				IL_002b:
				Marshal.FreeHGlobal(intPtr);
				num *= 2;
				intPtr = Marshal.AllocHGlobal(num);
				rESULT = FMOD_Studio_CommandReplay_GetCommandString(handle, commandIndex, intPtr, num);
			}
			Marshal.FreeHGlobal(intPtr);
			return rESULT;
		}

		public RESULT getCommandAtTime(float time, out int commandIndex)
		{
			return FMOD_Studio_CommandReplay_GetCommandAtTime(handle, time, out commandIndex);
		}

		public RESULT setBankPath(string bankPath)
		{
			using StringHelper.ThreadSafeEncoding threadSafeEncoding = StringHelper.GetFreeHelper();
			return FMOD_Studio_CommandReplay_SetBankPath(handle, threadSafeEncoding.byteFromStringUTF8(bankPath));
		}

		public RESULT start()
		{
			return FMOD_Studio_CommandReplay_Start(handle);
		}

		public RESULT stop()
		{
			return FMOD_Studio_CommandReplay_Stop(handle);
		}

		public RESULT seekToTime(float time)
		{
			return FMOD_Studio_CommandReplay_SeekToTime(handle, time);
		}

		public RESULT seekToCommand(int commandIndex)
		{
			return FMOD_Studio_CommandReplay_SeekToCommand(handle, commandIndex);
		}

		public RESULT getPaused(out bool paused)
		{
			return FMOD_Studio_CommandReplay_GetPaused(handle, out paused);
		}

		public RESULT setPaused(bool paused)
		{
			return FMOD_Studio_CommandReplay_SetPaused(handle, paused);
		}

		public RESULT getPlaybackState(out PLAYBACK_STATE state)
		{
			return FMOD_Studio_CommandReplay_GetPlaybackState(handle, out state);
		}

		public RESULT getCurrentCommand(out int commandIndex, out float currentTime)
		{
			return FMOD_Studio_CommandReplay_GetCurrentCommand(handle, out commandIndex, out currentTime);
		}

		public RESULT release()
		{
			return FMOD_Studio_CommandReplay_Release(handle);
		}

		public RESULT setFrameCallback(COMMANDREPLAY_FRAME_CALLBACK callback)
		{
			return FMOD_Studio_CommandReplay_SetFrameCallback(handle, callback);
		}

		public RESULT setLoadBankCallback(COMMANDREPLAY_LOAD_BANK_CALLBACK callback)
		{
			return FMOD_Studio_CommandReplay_SetLoadBankCallback(handle, callback);
		}

		public RESULT setCreateInstanceCallback(COMMANDREPLAY_CREATE_INSTANCE_CALLBACK callback)
		{
			return FMOD_Studio_CommandReplay_SetCreateInstanceCallback(handle, callback);
		}

		public RESULT getUserData(out IntPtr userdata)
		{
			return FMOD_Studio_CommandReplay_GetUserData(handle, out userdata);
		}

		public RESULT setUserData(IntPtr userdata)
		{
			return FMOD_Studio_CommandReplay_SetUserData(handle, userdata);
		}

		[DllImport("fmodstudio")]
		private static extern bool FMOD_Studio_CommandReplay_IsValid(IntPtr replay);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_CommandReplay_GetSystem(IntPtr replay, out IntPtr system);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_CommandReplay_GetLength(IntPtr replay, out float totalTime);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_CommandReplay_GetCommandCount(IntPtr replay, out int count);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_CommandReplay_GetCommandInfo(IntPtr replay, int commandIndex, out COMMAND_INFO info);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_CommandReplay_GetCommandString(IntPtr replay, int commandIndex, IntPtr description, int capacity);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_CommandReplay_GetCommandAtTime(IntPtr replay, float time, out int commandIndex);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_CommandReplay_SetBankPath(IntPtr replay, byte[] bankPath);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_CommandReplay_Start(IntPtr replay);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_CommandReplay_Stop(IntPtr replay);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_CommandReplay_SeekToTime(IntPtr replay, float time);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_CommandReplay_SeekToCommand(IntPtr replay, int commandIndex);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_CommandReplay_GetPaused(IntPtr replay, out bool paused);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_CommandReplay_SetPaused(IntPtr replay, bool paused);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_CommandReplay_GetPlaybackState(IntPtr replay, out PLAYBACK_STATE state);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_CommandReplay_GetCurrentCommand(IntPtr replay, out int commandIndex, out float currentTime);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_CommandReplay_Release(IntPtr replay);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_CommandReplay_SetFrameCallback(IntPtr replay, COMMANDREPLAY_FRAME_CALLBACK callback);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_CommandReplay_SetLoadBankCallback(IntPtr replay, COMMANDREPLAY_LOAD_BANK_CALLBACK callback);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_CommandReplay_SetCreateInstanceCallback(IntPtr replay, COMMANDREPLAY_CREATE_INSTANCE_CALLBACK callback);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_CommandReplay_GetUserData(IntPtr replay, out IntPtr userdata);

		[DllImport("fmodstudio")]
		private static extern RESULT FMOD_Studio_CommandReplay_SetUserData(IntPtr replay, IntPtr userdata);

		public bool hasHandle()
		{
			return handle != IntPtr.Zero;
		}

		public void clearHandle()
		{
			handle = IntPtr.Zero;
		}

		public bool isValid()
		{
			if (hasHandle())
			{
				return FMOD_Studio_CommandReplay_IsValid(handle);
			}
			return false;
		}
	}
}
namespace Occlusion
{
	public abstract class OcclusionBehaviourBase : MonoBehaviour, IAwakeEvent
	{
		public Occludee occlusionObject;

		protected OcclusionObjectState currentState;

		private IHaglet updateRoutine;

		protected abstract void OnBehaviourAwake();

		protected abstract void OnStateChanged();

		void IAwakeEvent.OnAwakeLR(MRBase owner)
		{
			currentState = occlusionObject.CurrentState;
			Haglet.Create(out updateRoutine, UpdateRoutine, null, startNow: true);
			OnBehaviourAwake();
		}

		private IEnumerator<Routine.Yield> UpdateRoutine()
		{
			while (true)
			{
				yield return Routine.Yield.SpecialIndex.StopSkipping;
				yield return occlusionObject.OnStateChange;
				currentState = occlusionObject.CurrentState;
				OnStateChanged();
			}
		}
	}
	public class OcclusionStateAnimator : OcclusionBehaviourBase
	{
		public AnimationClip[] animationClips;

		public Animation animator;

		private int clipIndex;

		public FMODEventAsset soundAnim;

		private FMOD.Studio.EventInstance evt;

		private IHaglet waitForAnimRoutine;

		protected override void OnBehaviourAwake()
		{
			clipIndex = 0;
			Haglet.Create(out waitForAnimRoutine, WaitForAnimRoutine);
			waitForAnimRoutine.Start();
		}

		protected override void OnStateChanged()
		{
			waitForAnimRoutine.Start(resetIfStarted: true);
		}

		private IEnumerator<Routine.Yield> WaitForAnimRoutine()
		{
			int num = clipIndex;
			clipIndex = (clipIndex + 1) % animationClips.Length;
			if ((bool)soundAnim)
			{
				if (evt.isValid())
				{
					evt.stop(STOP_MODE.ALLOWFADEOUT);
				}
				evt = FAC.Inst.PlayOneShot(soundAnim, base.transform.position);
			}
			yield return AnimationX.PlayAnim(animator, animationClips[num].name);
			if (evt.isValid())
			{
				evt.stop(STOP_MODE.ALLOWFADEOUT);
			}
		}

		private void OnDestroy()
		{
			if (evt.isValid())
			{
				evt.stop(STOP_MODE.IMMEDIATE);
			}
		}
	}
	public class OcclusionStateToggle : OcclusionBehaviourBase
	{
		protected override void OnBehaviourAwake()
		{
			SetCurrentStateActive();
		}

		protected override void OnStateChanged()
		{
			SetCurrentStateActive();
			UpdateHeldGrabPoint(CC.Inst.handL);
			UpdateHeldGrabPoint(CC.Inst.handR);
		}

		private void SetCurrentStateActive()
		{
			for (int i = 0; i < occlusionObject.states.Length; i++)
			{
				OcclusionObjectState occlusionObjectState = occlusionObject.states[i];
				if (occlusionObjectState == currentState)
				{
					occlusionObjectState.gameObject.SetActive(value: true);
				}
				else
				{
					occlusionObjectState.gameObject.SetActive(value: false);
				}
			}
		}

		private void UpdateHeldGrabPoint(Hand hand)
		{
			GrabPoint grabPointHeld = hand.grabPointHeld;
			if (!grabPointHeld)
			{
				return;
			}
			GrabObject grabObject = grabPointHeld.InteractableObject as GrabObject;
			if (!grabObject || !(grabObject == occlusionObject.grabObject))
			{
				return;
			}
			GrabPointConnection[] grabPointConnections = occlusionObject.grabPointConnections;
			foreach (GrabPointConnection grabPointConnection in grabPointConnections)
			{
				if (grabPointConnection.grabPointA == grabPointHeld)
				{
					hand.UngrabObject();
					hand.GrabObject(grabPointConnection.grabPointB);
				}
				else if (grabPointConnection.grabPointB == grabPointHeld)
				{
					hand.UngrabObject();
					hand.GrabObject(grabPointConnection.grabPointA);
				}
			}
		}
	}
	public class DetectionController
	{
		private struct ViewpointData
		{
			public Matrix4x4 projection;

			public Matrix4x4 combine;

			public Matrix4x4 combineInv;

			public Vector3 headPos;

			public Vector3 leftEyePos;

			public Vector3 rightEyePos;
		}

		private const int Max_Objects = 30;

		private const int Max_Rays = 50;

		private static DetectionController _inst;

		private Dictionary<Collider, IOccluder> occluderColliders = new Dictionary<Collider, IOccluder>(60);

		private ConstArray<IOccluder> occluders = new ConstArray<IOccluder>(30u);

		private ConstArray<IOccludee> occludees = new ConstArray<IOccludee>(30u);

		private ConstArray<IOccludee> validOccludees = new ConstArray<IOccludee>(30u);

		private HashSet<IOccludee> solvedOccludees = new HashSet<IOccludee>();

		private Dictionary<IOccludee, List<IOccluder>> occulusionPairs = new Dictionary<IOccludee, List<IOccluder>>(30);

		private Dictionary<IOccluder, float> occluderPercentages = new Dictionary<IOccluder, float>(30);

		private NativeArray<RaycastHit> results;

		private RaycastHit[] resultsBuffer = new RaycastHit[50];

		private NativeArray<RaycastCommand> commands;

		private RaycastCommand[] commandsBuffer = new RaycastCommand[50];

		private GCHandle commandsHandle;

		private GCHandle resultsHandle;

		public static DetectionController Inst => _inst ?? (_inst = new DetectionController());

		public static void EnsureInstance()
		{
			if (_inst == null)
			{
				_inst = new DetectionController();
			}
		}

		public DetectionController()
		{
			results = new NativeArray<RaycastHit>(50, Allocator.Persistent);
			commands = new NativeArray<RaycastCommand>(50, Allocator.Persistent);
			resultsHandle = GCHandle.Alloc(resultsBuffer, GCHandleType.Pinned);
			commandsHandle = GCHandle.Alloc(commandsBuffer, GCHandleType.Pinned);
		}

		~DetectionController()
		{
			results.Dispose();
			commands.Dispose();
			resultsHandle.Free();
			commandsHandle.Free();
		}

		private static void AddRaycastCommands(IOccludee occludee, ref Matrix4x4 proj, ref Matrix4x4 combine, ref Matrix4x4 iCombine, Vector3 headPos, Vector3 leftEyePos, Vector3 rightEyePos, ref RaycastCommand[] commandsBuffer, ref int commandIndex)
		{
			OcclusionTestPoint[] testPoints = occludee.GetTestPoints(calculate: true, ref proj, ref combine, ref iCombine);
			Vector3 direction = default(Vector3);
			foreach (OcclusionTestPoint obj in testPoints)
			{
				Vector3 pos = obj.pos;
				Vector3 vector = Vector3X.zero;
				switch (obj.eyePosition)
				{
				case MainCamera.EyePositions.Centre:
					vector = headPos;
					break;
				case MainCamera.EyePositions.Left:
					vector = leftEyePos;
					break;
				case MainCamera.EyePositions.Right:
					vector = rightEyePos;
					break;
				}
				direction.x = vector.x - pos.x;
				direction.y = vector.y - pos.y;
				direction.z = vector.z - pos.z;
				float num = Mathf.Sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
				direction /= num;
				commandsBuffer[commandIndex] = new RaycastCommand(pos, direction, num, 3073);
				commandIndex++;
			}
		}

		public unsafe void OnUpdateLR()
		{
			try
			{
				int commandIndex = 0;
				MainCamera inst = MainCamera.Inst;
				MRBase owner = inst.GetOwner();
				Vector3 headPosition = IC.GetHeadPosition();
				IC.GetHeadRotation();
				inst.GetEyePositions(out var left, out var right);
				List<ViewpointData> list = new List<ViewpointData>();
				bool flag = false;
				for (int i = 0; i < owner.portals._dataNum; i++)
				{
					Portal portal = owner.portals[i];
					if (portal.canOccludeThroughPortal)
					{
						flag = true;
						if (portal.PortalCamera.enabled)
						{
							ViewpointData item = default(ViewpointData);
							item.projection = portal.PortalCamera.cameraComp.projectionMatrix;
							portal.GetPortalMatrix(out var portalMatrix);
							Matrix4x4 matrix4x = portalMatrix * inst.transform.localToWorldMatrix;
							item.combine = item.projection * matrix4x.inverse;
							item.combineInv = item.combine.inverse;
							item.headPos = portal.CalculatePortalObjectTransform(headPosition, QuaternionX.identity, Vector3X.zero).position;
							item.leftEyePos = portal.CalculatePortalObjectTransform(left, QuaternionX.identity, Vector3X.zero).position;
							item.rightEyePos = portal.CalculatePortalObjectTransform(right, QuaternionX.identity, Vector3X.zero).position;
							list.Add(item);
						}
					}
				}
				if (!flag)
				{
					ViewpointData item2 = default(ViewpointData);
					item2.projection = inst.cameraComp.projectionMatrix;
					item2.combine = item2.projection * inst.transform.worldToLocalMatrix;
					item2.combineInv = item2.combine.inverse;
					item2.headPos = headPosition;
					item2.leftEyePos = left;
					item2.rightEyePos = right;
					list.Add(item2);
				}
				for (int j = 0; j < occludees.Length; j++)
				{
					IOccludee occludee = occludees[j];
					if (occludee.GetOwner() == owner && occludee.UpdateShouldTest(!flag))
					{
						validOccludees.Add(occludee);
						for (int k = 0; k < list.Count; k++)
						{
							ViewpointData viewpointData = list[k];
							AddRaycastCommands(occludee, ref viewpointData.projection, ref viewpointData.combine, ref viewpointData.combineInv, viewpointData.headPos, viewpointData.leftEyePos, viewpointData.rightEyePos, ref commandsBuffer, ref commandIndex);
						}
					}
					else
					{
						occludee.OnOccludeeUpdate(0f);
					}
				}
				UnsafeUtility.MemCpy(NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks(commands), (void*)commandsHandle.AddrOfPinnedObject(), sizeof(RaycastCommand) * commandsBuffer.Length);
				BatchQueryJob<RaycastCommand, RaycastHit> output = new BatchQueryJob<RaycastCommand, RaycastHit>(commands, results);
				JobsUtility.JobScheduleParameters parameters = new JobsUtility.JobScheduleParameters(UnsafeUtility.AddressOf(ref output), BatchQueryJobStruct<BatchQueryJob<RaycastCommand, RaycastHit>>.Initialize(), default(JobHandle), ScheduleMode.Batched);
				LR.ScheduleRaycastBatchWithLength(ref parameters, NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks(commands), commandIndex, NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks(results), commandIndex, 1).Complete();
				commandIndex = 0;
				UnsafeUtility.MemCpy((void*)resultsHandle.AddrOfPinnedObject(), NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks(results), sizeof(RaycastHit) * resultsBuffer.Length);
				Vector3 vector = default(Vector3);
				for (int l = 0; l < validOccludees.Length; l++)
				{
					IOccludee occludee2 = validOccludees[l];
					float num = 0f;
					int num2 = 0;
					int num3 = 0;
					for (int m = 0; m < list.Count; m++)
					{
						num2 = 0;
						num3 = 0;
						ViewpointData viewpointData2 = list[m];
						OcclusionTestPoint[] testPoints = validOccludees[l].GetTestPoints(calculate: false, ref viewpointData2.projection, ref viewpointData2.combine, ref viewpointData2.combineInv);
						int num4 = testPoints.Length;
						for (int n = 0; n < num4; n++)
						{
							RaycastHit hitInfo = resultsBuffer[commandIndex];
							commandIndex++;
							OcclusionTestPoint occlusionTestPoint = testPoints[n];
							Vector3 pos = occlusionTestPoint.pos;
							if (!(hitInfo.collider != null))
							{
								continue;
							}
							if (occluderColliders.TryGetValue(hitInfo.collider, out var value))
							{
								PortalVariations.VariantSet? currentVarientSet = value.GetCurrentVarientSet();
								Vector3 origin = Vector3X.zero;
								switch (occlusionTestPoint.eyePosition)
								{
								case MainCamera.EyePositions.Centre:
									origin = viewpointData2.headPos;
									break;
								case MainCamera.EyePositions.Left:
									origin = viewpointData2.leftEyePos;
									break;
								case MainCamera.EyePositions.Right:
									origin = viewpointData2.rightEyePos;
									break;
								}
								bool flag2 = true;
								vector.x = pos.x - origin.x;
								vector.y = pos.y - origin.y;
								vector.z = pos.z - origin.z;
								float num5 = Mathf.Sqrt(vector.x * vector.x + vector.y * vector.y + vector.z * vector.z);
								vector /= num5;
								if (!flag)
								{
									if (Physics.Raycast(origin, vector, out hitInfo, num5, 3073))
									{
										IOccluder value2;
										bool flag3 = occluderColliders.TryGetValue(hitInfo.collider, out value2) && value2 == value;
										if (flag3)
										{
											num3++;
										}
										flag2 = flag2 && flag3;
									}
								}
								else if (Physics.Raycast(pos, -vector, out hitInfo, num5, 1024))
								{
									PortalVariations.VariantSet? currentVariantSet = occludee2.GetCurrentVariantSet();
									if (currentVarientSet.HasValue && currentVariantSet.HasValue)
									{
										bool flag4 = currentVarientSet.Value == currentVariantSet.Value;
										if (flag4)
										{
											num3++;
										}
										flag2 = flag2 && flag4;
									}
								}
								if (flag2)
								{
									if (!occulusionPairs.ContainsKey(occludee2))
									{
										occulusionPairs[occludee2] = new List<IOccluder>();
										occulusionPairs[occludee2].Add(value);
									}
									else if (!occulusionPairs[occludee2].Contains(value))
									{
										occulusionPairs[occludee2].Add(value);
									}
								}
							}
							num2++;
						}
						int num6 = ((!flag) ? 1 : num4);
						if (num3 >= num6 && num2 == num4)
						{
							solvedOccludees.Add(occludee2);
							num = 1f;
							break;
						}
						float num7 = Mathf.Min((float)num2 / (float)num4, (float)num3 / (float)num6);
						if (num7 > num)
						{
							num = num7;
						}
					}
					if (!occulusionPairs.ContainsKey(occludee2))
					{
						continue;
					}
					List<IOccluder> list2 = occulusionPairs[occludee2];
					for (int num8 = 0; num8 < list2.Count; num8++)
					{
						IOccluder key = list2[num8];
						if (occluderPercentages.ContainsKey(key))
						{
							occluderPercentages[key] = Mathf.Max(num, occluderPercentages[key]);
						}
						else
						{
							occluderPercentages[key] = num;
						}
					}
				}
				for (int num9 = 0; num9 < occluders.Length; num9++)
				{
					IOccluder occluder = occluders[num9];
					if (!occluderPercentages.TryGetValue(occluder, out var value3))
					{
						value3 = 0f;
					}
					occluder.OcclusionPercentage = value3;
					occluder.OnOccluderUpdate();
				}
				for (int num10 = 0; num10 < validOccludees.Length; num10++)
				{
					IOccludee occludee3 = validOccludees[num10];
					if (occulusionPairs.TryGetValue(occludee3, out var value4))
					{
						float num11 = 1f;
						for (int num12 = 0; num12 < value4.Count; num12++)
						{
							num11 = Mathf.Min(value4[num12].OcclusionPercentage, num11);
						}
						occludee3.OnOccludeeUpdate(num11);
						if (solvedOccludees.Contains(occludee3) && occludee3.CanChange && Mathf.Approximately(num11, 1f))
						{
							occludee3.OnOccludeeStateChange();
							for (int num13 = 0; num13 < value4.Count; num13++)
							{
								value4[num13].OnOccludedObjectChanged(occludee3);
							}
						}
					}
					else
					{
						occludee3.OnOccludeeUpdate(0f);
					}
				}
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
			finally
			{
				validOccludees.ClearToDefault();
				occluderPercentages.Clear();
				solvedOccludees.Clear();
				occulusionPairs.Clear();
				Array.Clear(resultsBuffer, 0, resultsBuffer.Length);
				UnsafeUtility.MemCpy(NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks(results), (void*)resultsHandle.AddrOfPinnedObject(), sizeof(RaycastHit) * resultsBuffer.Length);
			}
		}

		public void RegisterOccludee(IOccludee obj)
		{
			occludees.Add(obj);
		}

		public void DeregisterOccludee(IOccludee obj)
		{
			occludees.Remove(obj);
		}

		public void RegisterOccluder(IOccluder obj)
		{
			Collider[] colliders = obj.GetColliders();
			for (int i = 0; i < colliders.Length; i++)
			{
				occluderColliders[colliders[i]] = obj;
			}
			occluders.Add(obj);
		}

		public void DeregisterOccluder(IOccluder obj)
		{
			Collider[] colliders = obj.GetColliders();
			for (int i = 0; i < colliders.Length; i++)
			{
				occluderColliders.Remove(colliders[i]);
			}
			occluders.Remove(obj);
		}
	}
	public class OcclusionTestPoint
	{
		public Vector3 pos;

		public MainCamera.EyePositions eyePosition;
	}
	public interface IOccludee
	{
		bool CanChange { get; }

		void OnOccludeeAwake(MRBase owner);

		void OnOccludeeUpdate(float occlusionPercentage);

		void OnOccludeeStateChange();

		MRBase GetOwner();

		bool UpdateShouldTest(bool shouldOcclusionCheck);

		OcclusionTestPoint[] GetTestPoints(bool calculate, ref Matrix4x4 proj, ref Matrix4x4 combine, ref Matrix4x4 icombine);

		PortalVariations.VariantSet? GetCurrentVariantSet();
	}
	[Serializer.ExcludeAllFields]
	public class Occludee : MonoBehaviour, IOccludee, IOwnerChangeListener, PortalVariations.IUseVariantSet, IPrepareEvent
	{
		public OcclusionObjectState[] states = new OcclusionObjectState[0];

		[Serializer.IncludeField]
		private int currentObjStateIdx;

		public HagletTrigger OnStateChange = new HagletTrigger();

		private bool waitingForReset;

		public Vector3 particleSpawnPoint;

		public Vector3 particleScale = Vector3.one;

		public FMODEventAsset sfxOnChange;

		public bool playVFXOnChange = true;

		private float occludability = 1f;

		private MPBStore mpbStore = new MPBStore();

		private bool isAwake;

		[NonSerialized]
		public GrabObject grabObject;

		public GrabPointConnection[] grabPointConnections;

		public Event onOcclude;

		private bool onOccludeFired;

		private MRBase owner;

		private OcclusionTestPoint[] occulusionTestPoints = new OcclusionTestPoint[5];

		[SerializeField]
		[HideInInspector]
		public bool isOccludable = true;

		private CullingGroup cullingGroup;

		private BoundingSphere[] cullingSpheres;

		private Bounds currentRenderingBounds;

		private PortalVariations.VariantSet? currentVariantSet;

		public OcclusionObjectState CurrentState => states[currentObjStateIdx];

		public bool CanChange
		{
			get
			{
				if (!waitingForReset)
				{
					return isOccludable;
				}
				return false;
			}
		}

		protected void Awake()
		{
			DetectionController.Inst.RegisterOccludee(this);
		}

		Wait IPrepareEvent.PrepareEvents()
		{
			onOcclude.PrepareInvoke();
			return Wait.None;
		}

		protected void OnDestroy()
		{
			DetectionController.Inst.DeregisterOccludee(this);
		}

		void IOccludee.OnOccludeeAwake(MRBase owner)
		{
			this.owner = owner;
			mpbStore.Initialise();
			mpbStore.SetFloat(ShaderPID._Occludability, occludability);
			cullingSpheres = new BoundingSphere[states.Length];
			cullingGroup = new CullingGroup();
			cullingGroup.targetCamera = MainCamera.Inst.cameraComp;
			for (int i = 0; i < occulusionTestPoints.Length; i++)
			{
				occulusionTestPoints[i] = new OcclusionTestPoint();
			}
			OcclusionObjectState[] array = states;
			for (int j = 0; j < array.Length; j++)
			{
				array[j].OnAwakeLR(mpbStore);
			}
			isAwake = true;
			grabObject = GetComponentInParent<GrabObject>();
		}

		void IOccludee.OnOccludeeUpdate(float occlusionPercentage)
		{
			if (!isAwake)
			{
				return;
			}
			if (waitingForReset && occlusionPercentage < BaseSettings<OcclusionSettings>.Inst.occlusionResetPercentage)
			{
				waitingForReset = false;
			}
			float num = (isOccludable ? 1f : 0f);
			if (occludability != num)
			{
				occludability = Mathf.MoveTowards(occludability, num, BaseSettings<OcclusionSettings>.Inst.OccludabilityChangeSpeed * IC.DeltaTime);
				mpbStore.SetFloat(ShaderPID._Occludability, occludability);
				OcclusionObjectState[] array = states;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].UpdateMPB(mpbStore);
				}
			}
		}

		void IOccludee.OnOccludeeStateChange()
		{
			int num = (currentObjStateIdx + 1) % states.Length;
			currentObjStateIdx = num;
			OnStateChange.Trigger();
			FAC.Inst.PlayOneShot(sfxOnChange, base.transform.position);
			waitingForReset = true;
			if (playVFXOnChange)
			{
				PSC.Inst.Play(BaseSettings<OcclusionSettings>.Inst.occludeeParticleEffect, particleSpawnPoint, Quaternion.identity, particleScale, base.transform);
			}
			if (!onOccludeFired)
			{
				onOccludeFired = true;
				onOcclude.Invoke();
			}
		}

		public int GetStateIndex()
		{
			return currentObjStateIdx;
		}

		public void UpdateCullingBounds()
		{
		}

		private void OnDrawGizmos()
		{
			Gizmos.matrix = base.transform.localToWorldMatrix;
			Gizmos.color = Color.yellow;
			Gizmos.DrawSphere(particleSpawnPoint, 0.1f);
		}

		private void OnValidate()
		{
			if (UnityEngine.Application.isPlaying)
			{
				return;
			}
			new MaterialPropertyBlock();
			MPBStore mPBStore = new MPBStore();
			mPBStore.Initialise();
			occludability = (isOccludable ? 1f : 0f);
			mPBStore.SetFloat(ShaderPID._Occludability, occludability);
			OcclusionObjectState[] array = states;
			foreach (OcclusionObjectState occlusionObjectState in array)
			{
				if ((bool)occlusionObjectState)
				{
					occlusionObjectState.UpdateMPB(mPBStore);
				}
			}
		}

		MRBase IOccludee.GetOwner()
		{
			return owner;
		}

		PortalVariations.VariantSet? IOccludee.GetCurrentVariantSet()
		{
			return currentVariantSet;
		}

		public void OnOwnerChange(MRBase _oldOwner, MRBase _newOwner)
		{
			owner = _newOwner;
		}

		public OcclusionTestPoint[] GetTestPoints(bool calculate, ref Matrix4x4 proj, ref Matrix4x4 combine, ref Matrix4x4 icombine)
		{
			if (calculate)
			{
				CalculateTestPoints(ref proj, ref combine, ref icombine);
			}
			return occulusionTestPoints;
		}

		private unsafe void CalculateTestPoints(ref Matrix4x4 proj, ref Matrix4x4 combine, ref Matrix4x4 icombine)
		{
			FastBounds fastBounds = default(FastBounds);
			fastBounds.center = Vector3X.zero;
			fastBounds.extents = Vector3X.zero;
			fastBounds.unityBounds = currentRenderingBounds;
			fastBounds.extents.x *= 0.5f;
			fastBounds.extents.y *= 0.5f;
			fastBounds.extents.z *= 0.5f;
			BoundsX.GetCorners(ref fastBounds.unityBounds, out var RUF, out var RDF, out var LUF, out var LDF, out var RUB, out var RDB, out var LUB, out var LDB);
			Vector3 vector2 = default(Vector3);
			fixed (float* ptr = &combine.m00)
			{
				Vector3 vector = RUF;
				vector2.x = *ptr * vector.x + ptr[4] * vector.y + ptr[8] * vector.z + ptr[12];
				vector2.y = ptr[1] * vector.x + ptr[5] * vector.y + ptr[9] * vector.z + ptr[13];
				vector2.z = 0f - (ptr[3] * vector.x + ptr[7] * vector.y + ptr[11] * vector.z + ptr[15]);
				vector2.x = vector2.x / vector2.z / 2f + 0.5f;
				vector2.y = vector2.y / vector2.z / 2f + 0.5f;
				RUF = vector2;
				vector = RDF;
				vector2.x = *ptr * vector.x + ptr[4] * vector.y + ptr[8] * vector.z + ptr[12];
				vector2.y = ptr[1] * vector.x + ptr[5] * vector.y + ptr[9] * vector.z + ptr[13];
				vector2.z = 0f - (ptr[3] * vector.x + ptr[7] * vector.y + ptr[11] * vector.z + ptr[15]);
				vector2.x = vector2.x / vector2.z / 2f + 0.5f;
				vector2.y = vector2.y / vector2.z / 2f + 0.5f;
				RDF = vector2;
				vector = LUF;
				vector2.x = *ptr * vector.x + ptr[4] * vector.y + ptr[8] * vector.z + ptr[12];
				vector2.y = ptr[1] * vector.x + ptr[5] * vector.y + ptr[9] * vector.z + ptr[13];
				vector2.z = 0f - (ptr[3] * vector.x + ptr[7] * vector.y + ptr[11] * vector.z + ptr[15]);
				vector2.x = vector2.x / vector2.z / 2f + 0.5f;
				vector2.y = vector2.y / vector2.z / 2f + 0.5f;
				LUF = vector2;
				vector = LDF;
				vector2.x = *ptr * vector.x + ptr[4] * vector.y + ptr[8] * vector.z + ptr[12];
				vector2.y = ptr[1] * vector.x + ptr[5] * vector.y + ptr[9] * vector.z + ptr[13];
				vector2.z = 0f - (ptr[3] * vector.x + ptr[7] * vector.y + ptr[11] * vector.z + ptr[15]);
				vector2.x = vector2.x / vector2.z / 2f + 0.5f;
				vector2.y = vector2.y / vector2.z / 2f + 0.5f;
				LDF = vector2;
				vector = RUB;
				vector2.x = *ptr * vector.x + ptr[4] * vector.y + ptr[8] * vector.z + ptr[12];
				vector2.y = ptr[1] * vector.x + ptr[5] * vector.y + ptr[9] * vector.z + ptr[13];
				vector2.z = 0f - (ptr[3] * vector.x + ptr[7] * vector.y + ptr[11] * vector.z + ptr[15]);
				vector2.x = vector2.x / vector2.z / 2f + 0.5f;
				vector2.y = vector2.y / vector2.z / 2f + 0.5f;
				RUB = vector2;
				vector = RDB;
				vector2.x = *ptr * vector.x + ptr[4] * vector.y + ptr[8] * vector.z + ptr[12];
				vector2.y = ptr[1] * vector.x + ptr[5] * vector.y + ptr[9] * vector.z + ptr[13];
				vector2.z = 0f - (ptr[3] * vector.x + ptr[7] * vector.y + ptr[11] * vector.z + ptr[15]);
				vector2.x = vector2.x / vector2.z / 2f + 0.5f;
				vector2.y = vector2.y / vector2.z / 2f + 0.5f;
				RDB = vector2;
				vector = LUB;
				vector2.x = *ptr * vector.x + ptr[4] * vector.y + ptr[8] * vector.z + ptr[12];
				vector2.y = ptr[1] * vector.x + ptr[5] * vector.y + ptr[9] * vector.z + ptr[13];
				vector2.z = 0f - (ptr[3] * vector.x + ptr[7] * vector.y + ptr[11] * vector.z + ptr[15]);
				vector2.x = vector2.x / vector2.z / 2f + 0.5f;
				vector2.y = vector2.y / vector2.z / 2f + 0.5f;
				LUB = vector2;
				vector = LDB;
				vector2.x = *ptr * vector.x + ptr[4] * vector.y + ptr[8] * vector.z + ptr[12];
				vector2.y = ptr[1] * vector.x + ptr[5] * vector.y + ptr[9] * vector.z + ptr[13];
				vector2.z = 0f - (ptr[3] * vector.x + ptr[7] * vector.y + ptr[11] * vector.z + ptr[15]);
				vector2.x = vector2.x / vector2.z / 2f + 0.5f;
				vector2.y = vector2.y / vector2.z / 2f + 0.5f;
				LDB = vector2;
			}
			fastBounds.center = RUF;
			fastBounds.extents = Vector3X.zero;
			BoundsX.Encapsulate(ref fastBounds.unityBounds, RDF);
			BoundsX.Encapsulate(ref fastBounds.unityBounds, LUF);
			BoundsX.Encapsulate(ref fastBounds.unityBounds, LDF);
			BoundsX.Encapsulate(ref fastBounds.unityBounds, RUB);
			BoundsX.Encapsulate(ref fastBounds.unityBounds, RDB);
			BoundsX.Encapsulate(ref fastBounds.unityBounds, LUB);
			BoundsX.Encapsulate(ref fastBounds.unityBounds, LDB);
			BoundsX.GetCorners(ref fastBounds.unityBounds, out RUF, out RDF, out LUF, out LDF, out RUB, out RDB, out LUB, out LDB);
			fixed (float* ptr2 = &proj.m00)
			{
				fixed (float* ptr3 = &icombine.m00)
				{
					Vector3 vector = RUF;
					vector.x = 1f - vector.x * 2f;
					vector.y = 1f - vector.y * 2f;
					vector.z = (ptr2[10] * vector.z + ptr2[14]) / (ptr2[11] * vector.z + ptr2[15]);
					vector2.x = *ptr3 * vector.x + ptr3[4] * vector.y + ptr3[8] * vector.z + ptr3[12];
					vector2.y = ptr3[1] * vector.x + ptr3[5] * vector.y + ptr3[9] * vector.z + ptr3[13];
					vector2.z = ptr3[2] * vector.x + ptr3[6] * vector.y + ptr3[10] * vector.z + ptr3[14];
					float num = ptr3[3] * vector.x + ptr3[7] * vector.y + ptr3[11] * vector.z + ptr3[15];
					vector2.x /= num;
					vector2.y /= num;
					vector2.z /= num;
					RUF = vector2;
					vector = RDF;
					vector.x = 1f - vector.x * 2f;
					vector.y = 1f - vector.y * 2f;
					vector.z = (ptr2[10] * vector.z + ptr2[14]) / (ptr2[11] * vector.z + ptr2[15]);
					vector2.x = *ptr3 * vector.x + ptr3[4] * vector.y + ptr3[8] * vector.z + ptr3[12];
					vector2.y = ptr3[1] * vector.x + ptr3[5] * vector.y + ptr3[9] * vector.z + ptr3[13];
					vector2.z = ptr3[2] * vector.x + ptr3[6] * vector.y + ptr3[10] * vector.z + ptr3[14];
					float num2 = ptr3[3] * vector.x + ptr3[7] * vector.y + ptr3[11] * vector.z + ptr3[15];
					vector2.x /= num2;
					vector2.y /= num2;
					vector2.z /= num2;
					RDF = vector2;
					vector = LUF;
					vector.x = 1f - vector.x * 2f;
					vector.y = 1f - vector.y * 2f;
					vector.z = (ptr2[10] * vector.z + ptr2[14]) / (ptr2[11] * vector.z + ptr2[15]);
					vector2.x = *ptr3 * vector.x + ptr3[4] * vector.y + ptr3[8] * vector.z + ptr3[12];
					vector2.y = ptr3[1] * vector.x + ptr3[5] * vector.y + ptr3[9] * vector.z + ptr3[13];
					vector2.z = ptr3[2] * vector.x + ptr3[6] * vector.y + ptr3[10] * vector.z + ptr3[14];
					float num3 = ptr3[3] * vector.x + ptr3[7] * vector.y + ptr3[11] * vector.z + ptr3[15];
					vector2.x /= num3;
					vector2.y /= num3;
					vector2.z /= num3;
					LUF = vector2;
					vector = LDF;
					vector.x = 1f - vector.x * 2f;
					vector.y = 1f - vector.y * 2f;
					vector.z = (ptr2[10] * vector.z + ptr2[14]) / (ptr2[11] * vector.z + ptr2[15]);
					vector2.x = *ptr3 * vector.x + ptr3[4] * vector.y + ptr3[8] * vector.z + ptr3[12];
					vector2.y = ptr3[1] * vector.x + ptr3[5] * vector.y + ptr3[9] * vector.z + ptr3[13];
					vector2.z = ptr3[2] * vector.x + ptr3[6] * vector.y + ptr3[10] * vector.z + ptr3[14];
					float num4 = ptr3[3] * vector.x + ptr3[7] * vector.y + ptr3[11] * vector.z + ptr3[15];
					vector2.x /= num4;
					vector2.y /= num4;
					vector2.z /= num4;
					LDF = vector2;
					vector = RUB;
					vector.x = 1f - vector.x * 2f;
					vector.y = 1f - vector.y * 2f;
					vector.z = (ptr2[10] * vector.z + ptr2[14]) / (ptr2[11] * vector.z + ptr2[15]);
					vector2.x = *ptr3 * vector.x + ptr3[4] * vector.y + ptr3[8] * vector.z + ptr3[12];
					vector2.y = ptr3[1] * vector.x + ptr3[5] * vector.y + ptr3[9] * vector.z + ptr3[13];
					vector2.z = ptr3[2] * vector.x + ptr3[6] * vector.y + ptr3[10] * vector.z + ptr3[14];
					float num5 = ptr3[3] * vector.x + ptr3[7] * vector.y + ptr3[11] * vector.z + ptr3[15];
					vector2.x /= num5;
					vector2.y /= num5;
					vector2.z /= num5;
					RUB = vector2;
					vector = RDB;
					vector.x = 1f - vector.x * 2f;
					vector.y = 1f - vector.y * 2f;
					vector.z = (ptr2[10] * vector.z + ptr2[14]) / (ptr2[11] * vector.z + ptr2[15]);
					vector2.x = *ptr3 * vector.x + ptr3[4] * vector.y + ptr3[8] * vector.z + ptr3[12];
					vector2.y = ptr3[1] * vector.x + ptr3[5] * vector.y + ptr3[9] * vector.z + ptr3[13];
					vector2.z = ptr3[2] * vector.x + ptr3[6] * vector.y + ptr3[10] * vector.z + ptr3[14];
					float num6 = ptr3[3] * vector.x + ptr3[7] * vector.y + ptr3[11] * vector.z + ptr3[15];
					vector2.x /= num6;
					vector2.y /= num6;
					vector2.z /= num6;
					RDB = vector2;
					vector = LUB;
					vector.x = 1f - vector.x * 2f;
					vector.y = 1f - vector.y * 2f;
					vector.z = (ptr2[10] * vector.z + ptr2[14]) / (ptr2[11] * vector.z + ptr2[15]);
					vector2.x = *ptr3 * vector.x + ptr3[4] * vector.y + ptr3[8] * vector.z + ptr3[12];
					vector2.y = ptr3[1] * vector.x + ptr3[5] * vector.y + ptr3[9] * vector.z + ptr3[13];
					vector2.z = ptr3[2] * vector.x + ptr3[6] * vector.y + ptr3[10] * vector.z + ptr3[14];
					float num7 = ptr3[3] * vector.x + ptr3[7] * vector.y + ptr3[11] * vector.z + ptr3[15];
					vector2.x /= num7;
					vector2.y /= num7;
					vector2.z /= num7;
					LUB = vector2;
					vector = LDB;
					vector.x = 1f - vector.x * 2f;
					vector.y = 1f - vector.y * 2f;
					vector.z = (ptr2[10] * vector.z + ptr2[14]) / (ptr2[11] * vector.z + ptr2[15]);
					vector2.x = *ptr3 * vector.x + ptr3[4] * vector.y + ptr3[8] * vector.z + ptr3[12];
					vector2.y = ptr3[1] * vector.x + ptr3[5] * vector.y + ptr3[9] * vector.z + ptr3[13];
					vector2.z = ptr3[2] * vector.x + ptr3[6] * vector.y + ptr3[10] * vector.z + ptr3[14];
					float num8 = ptr3[3] * vector.x + ptr3[7] * vector.y + ptr3[11] * vector.z + ptr3[15];
					vector2.x /= num8;
					vector2.y /= num8;
					vector2.z /= num8;
					LDB = vector2;
				}
			}
			occulusionTestPoints[0].pos = LUB;
			occulusionTestPoints[0].eyePosition = MainCamera.EyePositions.Left;
			occulusionTestPoints[1].pos = LDB;
			occulusionTestPoints[1].eyePosition = MainCamera.EyePositions.Left;
			occulusionTestPoints[2].pos = RUB;
			occulusionTestPoints[2].eyePosition = MainCamera.EyePositions.Right;
			occulusionTestPoints[3].pos = RDB;
			occulusionTestPoints[3].eyePosition = MainCamera.EyePositions.Right;
			occulusionTestPoints[4].pos.x = RUB.x + (LDB.x - RUB.x) * 0.5f;
			occulusionTestPoints[4].pos.y = RUB.y + (LDB.y - RUB.y) * 0.5f;
			occulusionTestPoints[4].pos.z = RUB.z + (LDB.z - RUB.z) * 0.5f;
			occulusionTestPoints[4].eyePosition = MainCamera.EyePositions.Centre;
		}

		public bool UpdateShouldTest(bool shouldOcclusionCheck)
		{
			if (base.isActiveAndEnabled)
			{
				currentRenderingBounds = states[currentObjStateIdx].GetBounds();
				if (!shouldOcclusionCheck)
				{
					return true;
				}
				FastBounds fastBounds = default(FastBounds);
				fastBounds.center = Vector3X.zero;
				fastBounds.extents = Vector3X.zero;
				fastBounds.unityBounds = currentRenderingBounds;
				cullingSpheres[currentObjStateIdx].radius = ((!(fastBounds.extents.x > fastBounds.extents.y)) ? ((fastBounds.extents.y > fastBounds.extents.z) ? fastBounds.extents.y : fastBounds.extents.z) : ((fastBounds.extents.x > fastBounds.extents.z) ? fastBounds.extents.x : fastBounds.extents.z));
				cullingSpheres[currentObjStateIdx].position = fastBounds.center;
				cullingGroup.SetBoundingSpheres(cullingSpheres);
				cullingGroup.SetBoundingSphereCount(cullingSpheres.Length);
				if (!cullingGroup.IsVisible(currentObjStateIdx))
				{
					return waitingForReset;
				}
				return true;
			}
			return false;
		}

		void PortalVariations.IUseVariantSet.SetPortalVariant(PortalVariations portalVariation)
		{
		}

		void PortalVariations.IUseVariantSet.OnVariantSetChanged(PortalVariations.VariantSet newSet)
		{
			currentVariantSet = newSet;
		}
	}
	[ExecuteInEditMode]
	public class OccludeeStateIndicator : MonoBehaviour, IAwakeEvent, IUpdateEvent
	{
		private struct UIElement
		{
			public MeshRenderer renderer;

			public float currentScale;

			private float baseAngle;

			private float baseScale;

			public float Scale
			{
				get
				{
					return currentScale;
				}
				set
				{
					currentScale = value;
					renderer.transform.localScale = Vector3X.one * (currentScale * baseScale);
				}
			}

			public float AngularScale => baseAngle * currentScale;

			public UIElement(MeshRenderer renderer, float baseAngle, float baseScale = 1f)
			{
				this.renderer = renderer;
				this.baseAngle = baseAngle;
				this.baseScale = baseScale;
				currentScale = 1f;
				Scale = 1f;
			}
		}

		public Occludee occludee;

		[Range(0.1f, 2f)]
		public float radius = 1f;

		private UIElement[] uiElements;

		private MPBStore mpbStore = new MPBStore();

		private static readonly int _Alpha = Shader.PropertyToID("_Alpha");

		private UIElement endMeshLeft;

		private UIElement endMeshRight;

		private OcclusionSettings.StateIndicatorSettings settings;

		void IAwakeEvent.OnAwakeLR(MRBase owner)
		{
			if (radius == 0f)
			{
				radius = 0.1f;
			}
			settings = BaseSettings<OcclusionSettings>.Inst.stateIndicatorSettings;
			float num = Mathf.Atan(settings.endMeshSizeCurve.Evaluate(radius) / radius) * 57.29578f;
			Mesh mesh = GenerateMesh(isFlipped: false, num);
			Mesh mesh2 = GenerateMesh(isFlipped: true, num);
			uiElements = new UIElement[occludee.states.Length];
			endMeshLeft = new UIElement(CreateMeshObject(mesh, "End Mesh Left ").GetComponent<MeshRenderer>(), num);
			endMeshRight = new UIElement(CreateMeshObject(mesh2, "End Mesh Right").GetComponent<MeshRenderer>(), num);
			Mesh dotMesh = settings.dotMesh;
			float baseAngle = Mathf.Atan(settings.dotSpacingByRadius.Evaluate(radius) / radius) * 57.29578f;
			for (int i = 0; i < uiElements.Length; i++)
			{
				GameObject gameObject = CreateMeshObject(dotMesh, $"State Indicator Spot {i}");
				uiElements[i] = new UIElement(gameObject.GetComponent<MeshRenderer>(), baseAngle, settings.dotScaleByRadius.Evaluate(radius));
			}
			mpbStore.Initialise();
		}

		void IUpdateEvent.OnUpdateLR()
		{
			settings = BaseSettings<OcclusionSettings>.Inst.stateIndicatorSettings;
			Quaternion rotation = Quaternion.LookRotation((CC.Inst.transform.position - base.transform.position).RepY(0f).normalized, base.transform.up);
			base.transform.rotation = rotation;
			int stateIndex = occludee.GetStateIndex();
			for (int i = 0; i < uiElements.Length; i++)
			{
				if (uiElements[i].Scale != 1f && i != stateIndex)
				{
					uiElements[i].Scale = Mathf.MoveTowards(uiElements[i].Scale, 1f, settings.scaleDownSpeed * IC.DeltaTime);
				}
				if (uiElements[i].Scale != settings.selectedScale && i == stateIndex)
				{
					uiElements[i].Scale = Mathf.MoveTowards(uiElements[i].Scale, settings.selectedScale, settings.scaleUpSpeed * IC.DeltaTime);
				}
			}
			float num = 0f;
			for (int j = 0; j < uiElements.Length; j++)
			{
				num += uiElements[j].AngularScale;
			}
			float num2 = num / 2f;
			Quaternion localRotation = Quaternion.LookRotation(PointOnCircle(num2, radius, Vector3.right, Vector3.forward).normalized, base.transform.up);
			endMeshLeft.renderer.transform.localRotation = localRotation;
			for (int k = 0; k < uiElements.Length; k++)
			{
				float num3 = uiElements[k].AngularScale / 2f;
				num2 -= num3;
				Vector3 localPosition = PointOnCircle(num2, radius, Vector3.right, Vector3.forward);
				Quaternion localRotation2 = Quaternion.LookRotation(localPosition.normalized, base.transform.up);
				uiElements[k].renderer.transform.localRotation = localRotation2;
				uiElements[k].renderer.transform.localPosition = localPosition;
				num2 -= num3;
			}
			Quaternion localRotation3 = Quaternion.LookRotation(PointOnCircle(num2, radius, Vector3.right, Vector3.forward).normalized, base.transform.up);
			endMeshRight.renderer.transform.localRotation = localRotation3;
			float uIAlpha = BaseSettings<InteractionSettings>.Inst.GetUIAlpha(base.transform.position, radius);
			for (int l = 0; l < uiElements.Length; l++)
			{
				float num4 = ((l != occludee.GetStateIndex()) ? settings.nonSelectedAlpha : 1f);
				mpbStore.SetFloat(_Alpha, uIAlpha * num4);
				mpbStore.ApplyProperties(uiElements[l].renderer);
			}
			mpbStore.SetFloat(_Alpha, uIAlpha);
			mpbStore.ApplyProperties(endMeshLeft.renderer);
			mpbStore.ApplyProperties(endMeshRight.renderer);
		}

		private GameObject CreateMeshObject(Mesh mesh, string name)
		{
			GameObject obj = new GameObject(name);
			obj.transform.SetParent(base.transform, worldPositionStays: false);
			obj.AddComponent<MeshFilter>().sharedMesh = mesh;
			obj.AddComponent<MeshRenderer>().material = settings.uiMaterial;
			return obj;
		}

		private void OnDrawGizmos()
		{
		}

		private Mesh GenerateMesh(bool isFlipped, float angle)
		{
			OcclusionSettings inst = BaseSettings<OcclusionSettings>.Inst;
			int endMeshDetail = inst.stateIndicatorSettings.endMeshDetail;
			List<Vector3> list = new List<Vector3>();
			List<int> list2 = new List<int>();
			List<Vector3> list3 = new List<Vector3>();
			for (int i = 0; i < endMeshDetail; i++)
			{
				float angleDeg = angle / (float)(endMeshDetail - 1) * (float)i;
				Vector3 vector = PointOnCircle(angleDeg, radius, isFlipped ? (-Vector3.right) : Vector3.right, Vector3.forward);
				if (i != 0)
				{
					list.Add(vector);
					list3.Add(vector.normalized);
					int num = i * 3 - 1;
					list2.Add(num);
					list2.Add(num + (isFlipped ? (-1) : 2));
					list2.Add(num + (isFlipped ? 2 : (-1)));
					list2.Add(num);
					list2.Add(num + (isFlipped ? 1 : (-2)));
					list2.Add(num + ((!isFlipped) ? 1 : (-2)));
					if (i != 1)
					{
						list2.Add(num);
						list2.Add(num + (isFlipped ? (-3) : (-1)));
						list2.Add(num + (isFlipped ? (-1) : (-3)));
						list2.Add(num);
						list2.Add(num + (isFlipped ? (-2) : (-3)));
						list2.Add(num + (isFlipped ? (-3) : (-2)));
					}
				}
				list.Add(vector - Vector3.up * inst.stateIndicatorSettings.endMeshYScale);
				list3.Add(vector.normalized);
				list.Add(vector + Vector3.up * inst.stateIndicatorSettings.endMeshYScale);
				list3.Add(vector.normalized);
			}
			Mesh mesh = new Mesh();
			mesh.SetVertices(list);
			mesh.SetTriangles(list2, 0);
			mesh.SetNormals(list3);
			return mesh;
		}

		private Vector3 PointOnCircle(float angleDeg, float radius, Vector3 xVec, Vector3 yVec)
		{
			float f = angleDeg * ((float)Math.PI / 180f);
			float num = Mathf.Sin(f) * radius;
			float num2 = Mathf.Cos(f) * radius;
			return xVec * num + yVec * num2;
		}
	}
	public interface IOccluder
	{
		float OcclusionPercentage { get; set; }

		void OnOccluderAwake(MRBase owner);

		void OnOccluderUpdate();

		void OnOccludedObjectChanged(IOccludee occludee);

		MRBase GetOwner();

		PortalVariations.VariantSet? GetCurrentVarientSet();

		Collider[] GetColliders();
	}
	public class Occluder : MonoBehaviour, IOccluder, IOwnerChangeListener, PortalVariations.IUseVariantSet
	{
		private static readonly int _Occlusion = Shader.PropertyToID("_Occlusion");

		private static readonly int _PulsePos = Shader.PropertyToID("_PulsePos");

		private FMOD.Studio.EventInstance sfxFeedback;

		private MeshRenderer mr;

		private MaterialPropertyBlock mpb;

		private ParticleSystem burstParticles;

		private MRBase owner;

		public bool overrideColliders;

		[SerializeField]
		private Collider[] colliders;

		private PortalVariations.VariantSet? currentVariantSet;

		public IHaglet pulseRoutine;

		private float _OcclusionPercentage;

		float IOccluder.OcclusionPercentage
		{
			get
			{
				return _OcclusionPercentage;
			}
			set
			{
				float num = ((value > _OcclusionPercentage) ? BaseSettings<OcclusionSettings>.Inst.maxPercentageIncreaseDelta : BaseSettings<OcclusionSettings>.Inst.maxPercentageDecreaseDelta);
				_OcclusionPercentage = Mathf.MoveTowards(_OcclusionPercentage, value, num * IC.DeltaTime);
			}
		}

		protected void Awake()
		{
			if (!overrideColliders)
			{
				colliders = GetComponentsInChildren<Collider>(includeInactive: true);
			}
			DetectionController.Inst.RegisterOccluder(this);
		}

		protected void OnDestroy()
		{
			DetectionController.Inst.DeregisterOccluder(this);
		}

		private void SetAlphaImmediate(float alpha)
		{
			if (mpb != null)
			{
				mr.GetPropertyBlock(mpb);
				mpb.SetFloat(_Occlusion, alpha);
				mr.SetPropertyBlock(mpb);
			}
		}

		void IOccluder.OnOccluderAwake(MRBase owner)
		{
			this.owner = owner;
			mpb = new MaterialPropertyBlock();
			mr = GetComponent<MeshRenderer>();
			mr.GetPropertyBlock(mpb);
			SetAlphaImmediate(0f);
			burstParticles = GetComponentInChildren<ParticleSystem>();
			if ((bool)burstParticles)
			{
				burstParticles.Stop();
			}
			Haglet.Create(out pulseRoutine, PulseRoutine);
		}

		void IOccluder.OnOccluderUpdate()
		{
			float alphaImmediate = BaseSettings<OcclusionSettings>.Inst.alphaCurve.Evaluate(_OcclusionPercentage);
			SetAlphaImmediate(alphaImmediate);
		}

		void IOccluder.OnOccludedObjectChanged(IOccludee occludee)
		{
			OcclusionSettings inst = BaseSettings<OcclusionSettings>.Inst;
			FAC.Inst.PlayOneShot(inst.sfxOnChange, base.transform.position);
			pulseRoutine.Start(resetIfStarted: true);
		}

		PortalVariations.VariantSet? IOccluder.GetCurrentVarientSet()
		{
			return currentVariantSet;
		}

		private IEnumerator<Routine.Yield> PulseRoutine()
		{
			float pulsePos = 0f;
			PSC.Inst.Play(BaseSettings<OcclusionSettings>.Inst.occluderParticleEffect, Vector3X.zero, QuaternionX.identity, Vector3X.one, base.transform);
			while (!Mathf.Approximately(pulsePos, 1f))
			{
				pulsePos = Mathf.MoveTowards(pulsePos, 1f, IC.DeltaTime * BaseSettings<OcclusionSettings>.Inst.pulseSpeed);
				mr.GetPropertyBlock(mpb);
				mpb.SetFloat(_PulsePos, pulsePos);
				mr.SetPropertyBlock(mpb);
				yield return Wait.For.LRUpdates(1);
			}
			mr.GetPropertyBlock(mpb);
			mpb.SetFloat(_PulsePos, 0f);
			mr.SetPropertyBlock(mpb);
		}

		public void OnOwnerChange(MRBase _oldOwner, MRBase _newOwner)
		{
			owner = _newOwner;
		}

		MRBase IOccluder.GetOwner()
		{
			return owner;
		}

		public Collider[] GetColliders()
		{
			return colliders;
		}

		void PortalVariations.IUseVariantSet.SetPortalVariant(PortalVariations portalVariation)
		{
		}

		void PortalVariations.IUseVariantSet.OnVariantSetChanged(PortalVariations.VariantSet newSet)
		{
			currentVariantSet = newSet;
		}
	}
	public enum State
	{
		OutOfViewFrustum,
		OccludedByEnvironment,
		OccludedByOcclusionCollision,
		InView
	}
	public static class Data
	{
		public const int ID_RANGE = 32;

		public const int ID_MATRIX_SIZE = 1024;
	}
	public class OcclusionObjectState : MonoBehaviour
	{
		private Renderer[] renderers;

		private ConstArray<Renderer> occulsionRenderers;

		public void OnAwakeLR(MPBStore store)
		{
			Renderer[] componentsInChildren = GetComponentsInChildren<MeshRenderer>();
			renderers = componentsInChildren;
			occulsionRenderers = new ConstArray<Renderer>((uint)renderers.Length);
			componentsInChildren = renderers;
			foreach (Renderer renderer in componentsInChildren)
			{
				store.ApplyProperties(renderer);
				if (!renderer.GetComponent<STUB_IgnoreOcclusionRenderer>())
				{
					occulsionRenderers.Add(renderer);
				}
			}
		}

		public void UpdateMPB(MPBStore store)
		{
			Renderer[] array = renderers;
			foreach (Renderer renderer in array)
			{
				store.ApplyProperties(renderer);
			}
		}

		public Bounds GetBounds()
		{
			Bounds into = default(Bounds);
			for (int i = 0; i < occulsionRenderers.Length; i++)
			{
				if (i == 0)
				{
					into = occulsionRenderers[i].bounds;
				}
				else
				{
					BoundsX.Encapsulate(ref into, occulsionRenderers[i].bounds);
				}
			}
			return into;
		}
	}
}
namespace Coatsink
{
	[RequireComponent(typeof(Animation))]
	public class SimpleAnimationControl : MonoBehaviour
	{
		[HideInInspector]
		[SerializeField]
		private Animation anim;

		[Header("Changing the animation clip or", order = 0)]
		[Header("the normalised flag in play mode", order = 1)]
		[Header("is not currently supported.", order = 2)]
		[Space(25f, order = 3)]
		public float timeOffset;

		public float speed = 1f;

		public bool normalisedTimeOffset = true;

		public bool normalisedSpeed = true;

		private AnimationState animState;

		private float prevTimeOffset;

		private void Reset()
		{
			anim = GetComponent<Animation>();
		}

		private void OnValidate()
		{
			if (anim == null)
			{
				anim = GetComponent<Animation>();
			}
			if (UnityEngine.Application.isPlaying && !(anim.clip == null) && animState != null)
			{
				Apply();
			}
		}

		private void Start()
		{
			if (anim == null)
			{
				anim = GetComponent<Animation>();
			}
			if (!(anim.clip == null))
			{
				animState = anim[anim.clip.name];
				prevTimeOffset = 0f;
				Apply();
			}
		}

		private void Apply()
		{
			if (normalisedTimeOffset)
			{
				animState.normalizedTime += timeOffset - prevTimeOffset;
			}
			else
			{
				animState.time += timeOffset - prevTimeOffset;
			}
			if (normalisedSpeed)
			{
				animState.normalizedSpeed = speed;
			}
			else
			{
				animState.speed = speed;
			}
			prevTimeOffset = timeOffset;
		}
	}
	[Serializable]
	public class SerialisableDictionary<TK, TV> : ISerializationCallbackReceiver
	{
		[SerializeField]
		private TK[] keys;

		[SerializeField]
		private TV[] vals;

		public bool autoReconstruct = true;

		private Dictionary<TK, TV> dict_;

		public Dictionary<TK, TV> dict
		{
			get
			{
				if (unconstructed)
				{
					InternalReconstruct();
				}
				return dict_;
			}
		}

		private bool unconstructed
		{
			get
			{
				if (keys == null)
				{
					return dict_ == null;
				}
				return true;
			}
		}

		public void Reconstruct()
		{
			if (unconstructed)
			{
				InternalReconstruct();
			}
		}

		public void OnBeforeSerialize()
		{
			if (unconstructed)
			{
				return;
			}
			int count = dict_.Count;
			if (count == 0)
			{
				return;
			}
			keys = new TK[count];
			vals = new TV[count];
			int num = 0;
			foreach (KeyValuePair<TK, TV> item in dict_)
			{
				keys[num] = item.Key;
				vals[num++] = item.Value;
			}
		}

		private void InternalReconstruct()
		{
			int num = ((keys != null) ? keys.Length : 0);
			dict_ = new Dictionary<TK, TV>(num);
			if (num != 0)
			{
				CollectionsX.Zip(keys, vals, dict_.Add);
			}
			keys = null;
			vals = null;
		}

		public void OnAfterDeserialize()
		{
			if (autoReconstruct)
			{
				InternalReconstruct();
			}
		}
	}
	[Serializable]
	public class SerialisableHashSet<T> : HashSet<T>, ISerializationCallbackReceiver
	{
		[SerializeField]
		private T[] entries;

		public SerialisableHashSet()
		{
		}

		public SerialisableHashSet(IEnumerable<T> pop)
			: base(pop)
		{
		}

		public void OnBeforeSerialize()
		{
			entries = this.ToArray();
		}

		public void OnAfterDeserialize()
		{
			Clear();
			UnionWith(entries);
			entries = null;
		}
	}
}
namespace Coatsink.Common
{
	public static class Panic
	{
		public static class ConstArray
		{
			[Conditional("CS_DEBUG")]
			public static void ValidateIndex<T>(uint index, int dataLen)
			{
				if (index < 0 || index >= dataLen)
				{
					Throw("Specified an invalid index {0} of ConstArray<{1}> (count: {2})!", index, typeof(T).Name, dataLen);
				}
			}
		}

		public static class ReflectionX
		{
			[Conditional("CS_DEBUG")]
			public static void ValidateCreateDynamicMethod(Type declaringType, Type fieldType, string fieldName, bool getter)
			{
				if (declaringType == null)
				{
					Throw("Specified a null type while trying to create a dynamic {0} for {1} {2}.{3}!", getter ? "getter" : "setter", (fieldType != null) ? fieldType.Name : "[unknown]", declaringType.FullName, fieldName);
				}
				if (fieldName == null)
				{
					Throw("Specified a null fieldName while trying to create a dynamic {0} for {1} {2}.{3}!", getter ? "getter" : "setter", (fieldType != null) ? fieldType.Name : "[unknown]", declaringType.FullName, fieldName);
				}
			}

			[Conditional("CS_DEBUG")]
			public static void ValidateCreateDynamicMethod(FieldInfo field, bool getter)
			{
				if (field == null)
				{
					Throw("Specified a null (or missing) field while trying to create a dynamic {0}!", getter ? "getter" : "setter");
				}
			}

			[Conditional("CS_DEBUG")]
			public static void ValidateIteratorType(Type type)
			{
				if (!type.IsIterator())
				{
					Throw("Specified non-iterator type '{0}'!", (type != null) ? type.Name : "null");
				}
			}

			[Conditional("CS_DEBUG")]
			public static void ValidateIteratorType<T>(Type type)
			{
				if (!type.IsIterator<T>())
				{
					Throw("Specified non-iterator type '{0}'!", (type != null) ? type.Name : "null");
				}
			}

			public static void ThrowMissingIteratorMethod(Type type)
			{
				Throw("Failed to find a corresponding method for iterator type {0}!", type);
			}

			public static void ThrowInvalidReturn(object value)
			{
				Throw("Attempted to emit invalid return value {0}!", value);
			}
		}

		public static class DynamicProperty
		{
			[Conditional("CS_DEBUG")]
			public static void ValidateDynamicProperty(object obj, string fieldName, int paramIdx, Type support, Type editorSupport)
			{
				if (obj == null)
				{
					Throw("Specified a null obj while trying to create a DynamicProperty for {0}!", fieldName ?? ("parameter " + paramIdx));
				}
				if (fieldName == null && paramIdx < 0)
				{
					Throw("Specified a null fieldName and invalid paramIdx while trying to create a DynamicProperty of {0}!", obj ?? "[null obj]");
				}
			}

			[Conditional("CS_DEBUG")]
			public static void WarnDynamicSupportOutdated(string methodName)
			{
				UnityEngine.Debug.LogWarningFormat("Warning! Failed to find {0}! Your dynamic support assembly is likely out of date and needs to be rebuilt!", methodName);
			}

			[Conditional("CS_DEBUG")]
			public static void ValidateFieldIndex<T>(object obj, int paramIdx, Coatsink.Common.ReflectionX.OptionalFieldInfo[] paramFields)
			{
				if (paramIdx >= paramFields.Length)
				{
					Throw("Specified an invalid paramIdx while trying to create a DynamicProperty<{0}> of {1}!", typeof(T), obj ?? "[null obj]");
				}
				if (paramFields[paramIdx].type != typeof(T))
				{
					Throw("Specified an invalid parameter type (expected {0}) while trying to create a DynamicProperty<{1}> of {2}!", paramFields[paramIdx].type, typeof(T), obj ?? "[null obj]");
				}
			}
		}

		public static class Enumerable
		{
			[Conditional("CS_DEBUG")]
			public static void ValidatePooled(IEnumerable enumerable, int cap)
			{
				if (enumerable == null)
				{
					Throw("specified a null enumerable when constructing a PooledEnumerable!");
				}
				if (enumerable.GetEnumerator().GetType().GetField("<>1__state", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) == null)
				{
					Throw("specified an incompatible enumerable when constructing an PooledEnumerable!");
				}
				if (cap < 1 || cap > 100)
				{
					Throw("specified an invalid initial capacity when constructing an PooledEnumerable!");
				}
			}
		}

		public static class Haglet
		{
			public class CalleeStoppedException : PanicException
			{
				public CalleeStoppedException(IHaglet caller, IHaglet callee)
					: base("Callee '{0}' of '{1}' was stopped!", callee, caller)
				{
				}
			}

			public class SkipFailException : PanicException
			{
				public SkipFailException(IHaglet current, int clauseIdx, string clauseDescr)
					: base("'{0}' broke down during a skip at clause {1}: \"{2}\"!", current, clauseIdx, clauseDescr)
				{
				}
			}

			public static Exception GetHang(IHaglet hag)
			{
				return Get("'{0}' exceeded the maximum allowed number of executions without waiting, stopping, or pausing at {1}:{2}.", hag, (hag.fileName != null) ? Path.GetFileName(hag.fileName) : "[unknown file]", (hag.lineNumber != -1) ? hag.lineNumber.ToString() : "[unknown line]");
			}

			public static Exception GetWaitFailed(IHaglet hag)
			{
				return Get("'{0}' failed its wait condition at {1}:{2}.", hag, (hag.fileName != null) ? Path.GetFileName(hag.fileName) : "[unknown file]", (hag.lineNumber != -1) ? hag.lineNumber.ToString() : "[unknown line]");
			}

			public static Exception GetInvalidWait(IHaglet hag)
			{
				return Get("'{0}' used an invalid wait!", hag);
			}

			public static CalleeStoppedException GetCalleeStoppedException(IHaglet caller, IHaglet callee)
			{
				return new CalleeStoppedException(caller, callee);
			}

			public static SkipFailException GetSkipFailException(IHaglet current, int clauseIdx, Coatsink.Common.Haglet.Clause clause)
			{
				string clauseDescr = "[Clause.ToString() failed!]";
				try
				{
					clauseDescr = clause.ToString();
				}
				catch (Exception)
				{
				}
				return new SkipFailException(current, clauseIdx, clauseDescr);
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void WarnSupportFailure(HagletDynamicSupport.IteratorMethodInfo method, Exception exc)
			{
				UnityEngine.Debug.LogWarningFormat("Haglet failed to generate a support class for {0}.{1} and will use reflection instead!\nException: {2}", method.iteratorType.DeclaringType.PrettyName(), method.methodName, exc);
			}

			public static void ThrowSupportFailure(HagletDynamicSupport.IteratorMethodInfo method, Exception exc)
			{
				Throw("Haglet failed to use reflection to support {0}.{1}!\nException: {2}", method.iteratorType.DeclaringType.PrettyName(), method.methodName, exc);
			}

			public static void WarnAssemblyInvalid(bool gonnaRebuild = false)
			{
				UnityEngine.Debug.LogError("Haglet's dynamic support assemblies appear to be invalid or out of date!" + (gonnaRebuild ? " Support will be rebuilt now." : ""));
			}

			public static void ThrowSupportCastFailure(IEnumerator<Routine.Yield> iterator, HagletDynamicSupport.IServer support)
			{
				Throw("The the method given to Haglet.Create(...) was too different from the routine ({0}) it returned! To minimise the chance of fallback or failure, please only directly pass routine methods (those using 'yield return') to Haglet.Create(...). This can also be caused by the method not using one or more of the parameters.", iterator.GetType().PrettyName());
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateInRoutine()
			{
				if (!Coatsink.Common.Haglet.inOne)
				{
					Throw("Called a method that doesn't apply outside of a routine!");
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateReset(IHaglet hag)
			{
				if (hag.moving)
				{
					Throw("Called Reset() on '{0}' from inside its own method!", hag);
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateMarkResetPoint(IHaglet hag)
			{
				if (hag.moving)
				{
					Throw("Called MarkResetPoint() on '{0}' from inside its own method!", hag);
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateStop(IHaglet hag)
			{
				if (hag.moving)
				{
					Throw("Called Stop() on '{0}' from inside its own method!", hag);
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateEvent(IHaglet hag, IHagletEvent e)
			{
				if (e == null)
				{
					Throw("Attempted to use a missing IHagletEvent during {0}!", hag);
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateClause(byte ci, byte rev, IHaglet hag)
			{
				if (!hag.IsValidClause(ci, rev))
				{
					Throw(GetInvalidWait(hag));
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateOperands(Wait wa, Wait wb, IHaglet hag, Coatsink.Common.Haglet.Clause.Type op)
			{
				bool flag = false;
				bool flag2 = false;
				if (wa.si != Routine.Yield.SpecialIndex.START && wa.si != Routine.Yield.SpecialIndex.WaitPreMet && wa.si != Routine.Yield.SpecialIndex.WaitForever)
				{
					flag = true;
				}
				if (wb.si != Routine.Yield.SpecialIndex.START && wb.si != Routine.Yield.SpecialIndex.WaitPreMet && wb.si != Routine.Yield.SpecialIndex.WaitForever)
				{
					flag2 = true;
				}
				if (op == Coatsink.Common.Haglet.Clause.Type.Sequence && wa.si != Routine.Yield.SpecialIndex.START && wb.si == Routine.Yield.SpecialIndex.WaitPreMet)
				{
					Throw("Called a Wait sequence operator with a second operand that's already met!", hag);
				}
				if (flag && flag2)
				{
					if (wa.ci == wb.ci)
					{
						Throw("Called a Wait operator during '{0}' using the same operand twice! (Clause {1}: \"{2}\")", hag, wa.ci, hag.GetClauseDescription(wa.ci));
					}
					if ((hag.GetClauseFlags(wa.ci) & Coatsink.Common.Haglet.Clause.Flags.Operand) != 0)
					{
						Throw("Called a Wait operator during '{0}' using an operand that was already used with another operator! (Clause {1}: \"{2}\")", hag, wa.ci, hag.GetClauseDescription(wa.ci));
					}
					if ((hag.GetClauseFlags(wb.ci) & Coatsink.Common.Haglet.Clause.Flags.Operand) != 0)
					{
						Throw("Called a Wait operator during '{0}' using an operand that was already used with another operator! (Clause {1}: \"{2}\")", hag, wb.ci, hag.GetClauseDescription(wb.ci));
					}
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateResponderRemove(IHagletEvent evt, HagletEvent.IResponder resp)
			{
				if (resp == null)
				{
					Throw("Called Remove(null) on '{0}'!", evt);
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ThrowResponderRemove(IHagletEvent evt)
			{
				Throw("Called Remove(...) on '{0}' with an unrelated responder!", evt);
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void LogResponderException(IHagletEvent evt, HagletEvent.IResponder resp, Exception exc)
			{
				UnityEngine.Debug.LogException(Get(null, "During '{0}', '{1}' threw {2}!", evt, resp.name, exc));
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateWaitTotal(IHaglet hag, int total)
			{
				if (total < 0 || total > 65535)
				{
					Throw("Specified an invalid or excessive wait total ({0}) during '{1}'!", total, hag);
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateValue<T>(IHaglet hag, IHagletValue<T> hVal)
			{
				if (hVal == null)
				{
					Throw("Specified a null IHagletValue during '{0}'!", hag);
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateWaitForSeconds(IHaglet hag, float seconds)
			{
				if (seconds < 0f)
				{
					Throw("Specified an invalid amount of time ({0}) during '{1}'!", seconds, hag);
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateSpecialYield(Routine.Yield.SpecialIndex idx)
			{
				switch (idx)
				{
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateHasOwner(bool needsOne = true)
			{
				if (needsOne && Routine.Owner == null)
				{
					Throw("Tried to use the co-routine mechanism with no owning MonoBehaviour!");
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidatePause(IHaglet hag)
			{
				if (hag.executing)
				{
					Throw("Tried to pause '{0}' while it was executing!", hag);
				}
				if (!hag.started)
				{
					Throw("Tried to pause '{0}' when it was not started!", hag);
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateResume(IHaglet hag)
			{
				if (!hag.pausedInCallStack)
				{
					Throw("Tried to resume '{1}' when it was not paused!", hag);
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateStart(IHaglet startee, IHaglet current, bool resetIfStarted)
			{
				if (startee.executing)
				{
					Throw("Tried to start '{0}' while it was executing!", startee);
				}
				if ((startee.started || startee.paused) && !resetIfStarted)
				{
					Throw("Tried to start '{0}' when it was started or paused, without specifying 'resetIfStarted'!", startee);
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateCall(IHaglet callee, IHaglet current, int total)
			{
				if (current == null)
				{
					Throw("Tried to call '{0}' outside of a routine!", callee);
				}
				if (callee.caller != null)
				{
					Throw("Tried to call '{0}' in '{1}' when it was already being called by '{2}'!", callee, current, callee.caller);
				}
				if (callee.started || callee.paused)
				{
					Throw("Tried to call '{0}' in '{1}' when it was already started!", callee, current, callee.caller);
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateInternalGoto(IHaglet hag, int? id = null)
			{
				if (hag.iLatestGoto == null)
				{
					Throw("Tried to use the goto mechanism without [Routine.UsesGoto] ({0})!", hag);
				}
				if (id.HasValue && !hag.IsValidGoto(id.Value))
				{
					Throw("Specified unknown goto id ({0}) in {1}!", id, hag);
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateHagletValueSet<T>(HagletValue<T> hVal)
			{
				if ((bool)hVal.happening)
				{
					Throw("Assigned to HagletValue '{0}' while already doing so!", hVal);
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateRoutineMethod(MethodInfo method, ParameterInfo[] @params)
			{
				if (@params.Length >= 5 && (@params.Length != 5 || !@params[4].ParameterType.IsGenericType || !(@params[4].ParameterType.GetGenericTypeDefinition() == typeof(Routine.Return<>))))
				{
					Throw("Method {0} {1}.{2}({3}) has invalid parameters! Haglet only supports up to 4 parameters and one optional return.", method.ReturnType.PrettyName(), method.DeclaringType.PrettyName(), method.Name, string.Join(", ", (from p in method.GetParameters()
						select $"{p.Attributes} {p.ParameterType.PrettyName()} {p.Name}").ToArray()));
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateCoroutineUpdate(Coatsink.Common.Haglet hag, int coroutineStack)
			{
				if (coroutineStack == 0)
				{
					Throw("Used StartCoroutine(...) or directly called MoveNext() on {0}.", hag);
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateTrigger(IHaglet hag)
			{
				if (hag.executing)
				{
					Throw("Tried to trigger '{0}' while it was executing!", hag);
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateDirectGoto(IHaglet hag)
			{
				if (hag.iLatestGoto == null)
				{
					Throw("Tried to use the goto mechanism without [Routine.UsesGoto] ({0})!", hag);
				}
				if (hag.executing)
				{
					Throw("Tried to call Goto() on '{0}' while it was executing!", hag);
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateClausesNotFull(IHaglet hag, int length)
			{
				if (length >= 32767)
				{
					Throw("'{0}' tried to expand its clause array beyond the maximum of {1}!", hag, short.MaxValue);
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void WarnClauseArrayExpansion(IHaglet hag, int oldLen, int newLen, string fileName, int lineNum)
			{
				UnityEngine.Debug.LogWarningFormat("'{0}' had to expand its clause array from {1} to {2} at {3}:{4}!", hag, oldLen, newLen, (fileName != null) ? Path.GetFileName(fileName) : "[unknown file]", (lineNum != 0) ? lineNum.ToString() : "[unknown line]");
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateClauseRevision(IHaglet hag, byte rev, int ci, Coatsink.Common.Haglet.Clause clause)
			{
				if (rev == byte.MaxValue)
				{
					Throw("'{0}' tried revise a clause {1} ({2}) beyond the maximum allowed revisions ({3})!", hag, ci, clause, byte.MaxValue);
				}
			}

			[Conditional("CS_DEBUG")]
			[Conditional("UNITY_EDITOR")]
			[Conditional("DEVELOPMENT_BUILD")]
			[Conditional("HG_DEBUG")]
			public static void ValidateArgIndex(IHaglet hag, int arg)
			{
				if (arg < 0 || arg >= hag.argCount)
				{
					Throw("Specific invalid argument index {0} in '{1}' (arg count {2})!", arg, hag, hag.argCount);
				}
			}
		}

		[Conditional("NX_TESTING")]
		public static void NX(UnityEngine.Object source, string str, params object[] paramsIn)
		{
			UnityEngine.Debug.LogErrorFormat(source, str, paramsIn);
			UnityEngine.Debug.Break();
		}

		[Conditional("NX_TESTING")]
		public static void NX(string str, params object[] paramsIn)
		{
		}

		[Conditional("NX_TESTING")]
		public static void NX(bool condition, UnityEngine.Object source, string str, params object[] paramsIn)
		{
		}

		[Conditional("NX_TESTING")]
		public static void NX(bool condition, string str, params object[] paramsIn)
		{
		}

		public static void Throw(Exception exc)
		{
			if (UnityEngine.Application.isPlaying)
			{
				UnityEngine.Debug.Break();
			}
			throw exc;
		}

		public static void Throw(string str, params object[] args)
		{
			Throw(Get(str, args));
		}

		public static PanicException Get(string str, params object[] args)
		{
			return new PanicException(string.Format(str, args));
		}

		public static PanicException Get(Exception inner, string str, params object[] args)
		{
			return new PanicException(inner, string.Format(str, args));
		}
	}
	public static class ComponentX
	{
		public static int GetFirstComponentTypePresent(this GameObject thisGo, out UnityEngine.Component component, params Type[] types)
		{
			for (int i = 0; i < types.Length; i++)
			{
				component = thisGo.GetComponent(types[i]);
				if (component != null)
				{
					return i;
				}
			}
			component = null;
			return -1;
		}

		public static int GetFirstComponentTypePresent(this UnityEngine.Component thisComp, out UnityEngine.Component component, params Type[] types)
		{
			for (int i = 0; i < types.Length; i++)
			{
				component = thisComp.GetComponent(types[i]);
				if (component != null)
				{
					return i;
				}
			}
			component = null;
			return -1;
		}

		public static int GetFirstBehaviourTypePresent(this GameObject thisGo, out Behaviour behaviour, bool includeDisabled = true, params Type[] types)
		{
			for (int i = 0; i < types.Length; i++)
			{
				behaviour = thisGo.GetComponent(types[i]) as Behaviour;
				if (behaviour != null && (includeDisabled || behaviour.enabled))
				{
					return i;
				}
			}
			behaviour = null;
			return -1;
		}

		public static int GetFirstBehaviourTypePresent(this UnityEngine.Component thisComp, out Behaviour behaviour, bool includeDisabled = true, params Type[] types)
		{
			for (int i = 0; i < types.Length; i++)
			{
				behaviour = thisComp.GetComponent(types[i]) as Behaviour;
				if (behaviour != null && (includeDisabled || behaviour.enabled))
				{
					return i;
				}
			}
			behaviour = null;
			return -1;
		}

		public static T GetComponentInAscendant<T>(this GameObject go, bool includeSelf = true, int depth = -1) where T : class
		{
			Transform transform = (includeSelf ? go.transform : go.transform.parent);
			while (transform != null)
			{
				T component = transform.GetComponent<T>();
				if (component != null && !component.Equals(null))
				{
					return component;
				}
				depth--;
				if (depth == 0)
				{
					break;
				}
				transform = transform.parent;
			}
			return null;
		}

		public static T GetComponentInAscendant<T>(this UnityEngine.Component comp, bool includeSelf = true, int depth = -1) where T : class
		{
			Transform transform = (includeSelf ? comp.transform : comp.transform.parent);
			while (transform != null)
			{
				T component = transform.GetComponent<T>();
				if (component != null && !component.Equals(null))
				{
					return component;
				}
				depth--;
				if (depth == 0)
				{
					break;
				}
				transform = transform.parent;
			}
			return null;
		}

		public static T GetComponentInDirectChild<T>(this UnityEngine.Component comp, bool includeSelf = false, bool includeInactive = true) where T : class
		{
			return comp.gameObject.GetComponentInDirectChild<T>(includeSelf, includeInactive);
		}

		public static T GetComponentInDirectChild<T>(this GameObject gameObject, bool includeSelf = false, bool includeInactive = true) where T : class
		{
			Transform transform = gameObject.transform;
			foreach (Transform item in transform)
			{
				if ((!(item == transform) || includeSelf) && (item.gameObject.activeInHierarchy || includeInactive))
				{
					T component = item.GetComponent<T>();
					if (component != null)
					{
						return component;
					}
				}
			}
			return null;
		}

		public static T GetOrAddComponent<T>(this GameObject gameObject) where T : UnityEngine.Component
		{
			T component = gameObject.GetComponent<T>();
			if (component == null)
			{
				return gameObject.AddComponent<T>();
			}
			return component;
		}

		public static T GetOrAddComponent<T>(this GameObject gameObject, out bool added) where T : UnityEngine.Component
		{
			T component = gameObject.GetComponent<T>();
			if (component == null)
			{
				added = true;
				return gameObject.AddComponent<T>();
			}
			added = false;
			return component;
		}
	}
	public static class CollectionsX
	{
		public struct IndexValuePair<T> : IEquatable<IndexValuePair<T>>
		{
			public readonly int index;

			public readonly T value;

			public IndexValuePair(int index, T value)
			{
				this.index = index;
				this.value = value;
			}

			public bool Equals(IndexValuePair<T> other)
			{
				if (index == other.index && EqualityComparer<T>.Default.Equals(value, other.value))
				{
					return true;
				}
				return false;
			}
		}

		public struct Perm<T1, T2>
		{
			public T1 t1;

			public T2 e2;

			public Perm(T1 t1, T2 t2)
			{
				this.t1 = t1;
				e2 = t2;
			}
		}

		public struct Perm<T1, T2, T3>
		{
			public T1 t1;

			public T2 t2;

			public T3 t3;

			public Perm(T1 t1, T2 t2, T3 t3)
			{
				this.t1 = t1;
				this.t2 = t2;
				this.t3 = t3;
			}
		}

		public struct Perm<T1, T2, T3, T4>
		{
			public T1 t1;

			public T2 t2;

			public T3 t3;

			public T4 t4;

			public Perm(T1 t1, T2 t2, T3 t3, T4 t4)
			{
				this.t1 = t1;
				this.t2 = t2;
				this.t3 = t3;
				this.t4 = t4;
			}
		}

		public enum SetGrowMode
		{
			Min_10_Then_150_Percent,
			Incremental
		}

		public struct SeqMatch<T>
		{
			public T t;

			public int seq;

			public int pos;

			public SeqMatch(int seq, int pos, T t)
			{
				this.seq = seq;
				this.pos = pos;
				this.t = t;
			}
		}

		public static T[] Generate<T>(int qty) where T : new()
		{
			T[] array = new T[qty];
			while (--qty >= 0)
			{
				array[qty] = new T();
			}
			return array;
		}

		public static T[] Generate<T>(int qty, T initVal)
		{
			T[] array = new T[qty];
			while (--qty >= 0)
			{
				array[qty] = initVal;
			}
			return array;
		}

		public static List<T> GenerateList<T>(int qty) where T : new()
		{
			List<T> list = new List<T>(qty);
			while (--qty >= 0)
			{
				list.Add(new T());
			}
			return list;
		}

		public static T[] Population<T>(Func<T> generator, int qty)
		{
			T[] array = new T[qty];
			while (--qty >= 0)
			{
				array[qty] = generator();
			}
			return array;
		}

		public static void Remove<T>(this List<T> list, params IEnumerable<T>[] ranges)
		{
			for (int i = 0; i < ranges.Length; i++)
			{
				foreach (T item in ranges[i])
				{
					list.Remove(item);
				}
			}
		}

		public static T GetValueAtWrappedOffset<T>(this IList<T> list, T member, int offset)
		{
			return list[(list.IndexOf(member) + offset).Wrap(list.Count)];
		}

		public static bool ContainsName(this IList<GameObject> enumerable, string name)
		{
			if (enumerable.FirstOfName(name) == null)
			{
				return false;
			}
			return true;
		}

		public static T FirstOfName<T>(this IList<T> list, string name) where T : UnityEngine.Object
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				T val = list[i];
				if (val.name == name)
				{
					return val;
				}
			}
			return null;
		}

		public static T RemoveByName<T>(this IList<T> list, string name, bool single = true) where T : UnityEngine.Object
		{
			int i = 0;
			for (int count = list.Count; i < count; i++)
			{
				T val = list[i];
				if (val.name == name)
				{
					list.RemoveAt(i--);
					if (single)
					{
						return val;
					}
				}
			}
			return null;
		}

		public static T[] Concat<T>(params T[][] arrays)
		{
			int num = 0;
			int num2 = 0;
			T[][] array = arrays;
			foreach (T[] array2 in array)
			{
				num += array2.Length;
			}
			T[] array3 = new T[num];
			array = arrays;
			foreach (T[] array4 in array)
			{
				array4.CopyTo(array3, num2);
				num2 += array4.Length;
			}
			return array3;
		}

		public static T FirstOrDefault<T>(this IList<T> source, Func<T, bool> predicate = null, T defaultVal = default(T))
		{
			if (predicate == null)
			{
				if (source.Count == 1)
				{
					return source[0];
				}
			}
			else
			{
				int i = 0;
				for (int count = source.Count; i < count; i++)
				{
					if (predicate(source[i]))
					{
						return source[i];
					}
				}
			}
			return defaultVal;
		}

		public static bool TryFirst<T>(this IList<T> source, ref T destination, Func<T, bool> predicate = null, T defaultVal = default(T))
		{
			if (source.Count == 0)
			{
				destination = defaultVal;
			}
			else
			{
				if (predicate == null)
				{
					destination = source[0];
					return true;
				}
				int i = 0;
				for (int count = source.Count; i < count; i++)
				{
					if (predicate(source[i]))
					{
						destination = source[i];
						return true;
					}
				}
				destination = defaultVal;
			}
			return false;
		}

		public static IEnumerable<T> ConcatArgs<T>(this IEnumerable<T> collection, params T[] newMembers)
		{
			return collection.Concat(newMembers);
		}

		public static IEnumerable<T> UnionArgs<T>(this IEnumerable<T> collection, params T[] newMembers)
		{
			return collection.Union(newMembers);
		}

		public static IEnumerable<T> RemoveWithIndices<T>(this IEnumerable<T> source, IEnumerable<int> indices)
		{
			int count = source.Count();
			IEnumerable<int> wrappedIndeces = indices.Select((int idx) => idx.Wrap(count));
			return from elem in source.ZipWithIndices()
				where !wrappedIndeces.Contains(elem.index)
				select elem.value;
		}

		public static IEnumerable<T> RemoveWithIndices<T>(this IEnumerable<T> collection, params int[] indices)
		{
			return collection.RemoveWithIndices((IEnumerable<int>)indices);
		}

		public static T[] RemoveValues<T>(this T[] array, params T[] values)
		{
			List<T> list = new List<T>(array.Length);
			int i = 0;
			for (int num = array.Length; i < num; i++)
			{
				if (!values.Contains(array[i]))
				{
					list.Add(array[i]);
				}
			}
			return list.ToArray();
		}

		public static T[] InsertValuesAtIndices<T>(this T[] array, IDictionary<int, T[]> newMembers)
		{
			int num = array.Length;
			int num2 = num;
			foreach (KeyValuePair<int, T[]> newMember in newMembers)
			{
				num2 += newMember.Value.Length;
			}
			T[] array2 = new T[num2];
			int num3 = 0;
			int num4 = 0;
			T[] value;
			while (num4 < num)
			{
				if (newMembers.TryGetValue(num4, out value))
				{
					value.CopyTo(array2, num3);
					num3 += value.Length;
				}
				array2[num3++] = array[num4++];
			}
			if (newMembers.TryGetValue(num, out value))
			{
				value.CopyTo(array2, num3);
			}
			return array2;
		}

		public static T[] InsertValueAtIndex<T>(this T[] array, T newMember, int newIndex = -1)
		{
			if (newIndex == -1)
			{
				newIndex = array.Length;
			}
			int num = array.Length + 1;
			T[] array2 = new T[num];
			int num2 = newIndex;
			while (--num2 >= 0)
			{
				array2[num2] = array[num2];
			}
			array2[newIndex] = newMember;
			int num3 = num;
			while (--num3 > newIndex)
			{
				array2[num3] = array[num3];
			}
			return array2;
		}

		public static IEnumerable<IndexValuePair<T>> ZipWithIndices<T>(this IEnumerable<T> enumerable)
		{
			int index = 0;
			foreach (T item in enumerable)
			{
				yield return new IndexValuePair<T>(index++, item);
			}
		}

		public static void SetValues<T>(this T[] array, params T[] values)
		{
			Array.Copy(values, array, Mathf.Min(array.Length, values.Length));
		}

		public static IEnumerable<T> Sequence<T>(params T[] elements)
		{
			return elements;
		}

		public static IEnumerable<T> SimpleShuffle<T>(this IEnumerable<T> enumerable)
		{
			return enumerable.OrderBy((T idx) => UnityEngine.Random.value);
		}

		public static T[] ToArray<T>(this IEnumerable<T> enumerable, int initialSize)
		{
			List<T> list = new List<T>(initialSize);
			list.AddRange(enumerable);
			return list.ToArray();
		}

		public static IEnumerable<Perm<T1, T2>> GetPermutations<T1, T2>(IEnumerable<T1> col1, IEnumerable<T2> col2)
		{
			foreach (T1 t1 in col1)
			{
				foreach (T2 item in col2)
				{
					yield return new Perm<T1, T2>(t1, item);
				}
			}
		}

		public static IEnumerable<Perm<T1, T2, T3>> GetPermutations<T1, T2, T3>(IEnumerable<T1> col1, IEnumerable<T2> col2, IEnumerable<T3> col3)
		{
			foreach (T1 t1 in col1)
			{
				foreach (T2 t2 in col2)
				{
					foreach (T3 item in col3)
					{
						yield return new Perm<T1, T2, T3>(t1, t2, item);
					}
				}
			}
		}

		public static IEnumerable<Perm<T1, T2, T3, T4>> GetPermutations<T1, T2, T3, T4>(IEnumerable<T1> col1, IEnumerable<T2> col2, IEnumerable<T3> col3, IEnumerable<T4> col4)
		{
			foreach (T1 t1 in col1)
			{
				foreach (T2 t2 in col2)
				{
					foreach (T3 t3 in col3)
					{
						foreach (T4 item in col4)
						{
							yield return new Perm<T1, T2, T3, T4>(t1, t2, t3, item);
						}
					}
				}
			}
		}

		public static void Zip<T1, T2>(T1[] col1, T2[] col2, Action<T1, T2> zipper)
		{
			int num = Math.Min(col1.Length, col2.Length);
			for (int i = 0; i < num; i++)
			{
				zipper(col1[i], col2[i]);
			}
		}

		public static void Zip<T1, T2>(IEnumerable<T1> col1, IEnumerable<T2> col2, Action<T1, T2> zipper)
		{
			IEnumerator<T1> enumerator = col1.GetEnumerator();
			IEnumerator<T2> enumerator2 = col2.GetEnumerator();
			while (enumerator.MoveNext() & enumerator2.MoveNext())
			{
				zipper(enumerator.Current, enumerator2.Current);
			}
		}

		public static int IndexOf<T>(this IEnumerable<T> enumerable, T val)
		{
			int num = 0;
			foreach (T item in enumerable)
			{
				if (EqualityComparer<T>.Default.Equals(item, val))
				{
					return num;
				}
				num++;
			}
			return -1;
		}

		public static void ShuffleArray<T>(T[] array)
		{
			for (int num = array.Length - 1; num > 0; num--)
			{
				int num2 = UnityEngine.Random.Range(0, num);
				T val = array[num];
				array[num] = array[num2];
				array[num2] = val;
			}
		}

		public static void Order<T>(ref T smaller, ref T larger) where T : IComparable<T>
		{
			if (smaller.CompareTo(larger) > 0)
			{
				Misc.Swap(ref smaller, ref larger);
			}
		}

		public static int SetAddAndGrow_C<T>(ref T[] arr, T mem, SetGrowMode growMode = SetGrowMode.Min_10_Then_150_Percent) where T : class
		{
			int num = 0;
			int num2 = arr.Length;
			while (true)
			{
				if (num < num2)
				{
					if (EqualityComparer<T>.Default.Equals(arr[num], mem))
					{
						return num;
					}
					if (arr[num] == null)
					{
						for (int i = num + 1; i < num2; i++)
						{
							if (EqualityComparer<T>.Default.Equals(arr[i], mem))
							{
								return i;
							}
						}
						break;
					}
					num++;
					continue;
				}
				int num3 = num2 + 1;
				if (growMode == SetGrowMode.Min_10_Then_150_Percent)
				{
					num3 = Mathf.Min(10, Mathf.CeilToInt((float)num2 * 1.5f));
				}
				UnityEngine.Debug.LogErrorFormat("Had to garbage {0}[{1}] and replace with {0}[{2}]!", typeof(T).PrettyName(), num2, num3);
				Array.Resize(ref arr, num3);
				break;
			}
			arr[num] = mem;
			return num;
		}

		public static int SetAddAndGrow_S<T>(ref T[] arr, T mem, SetGrowMode growMode = SetGrowMode.Min_10_Then_150_Percent, T? nullVal = null) where T : struct
		{
			int i = 0;
			int num = arr.Length;
			if (!nullVal.HasValue)
			{
				for (; i < num; i++)
				{
					if (EqualityComparer<T>.Default.Equals(arr[i], mem))
					{
						return i;
					}
				}
			}
			else
			{
				T value = nullVal.Value;
				while (i < num)
				{
					if (EqualityComparer<T>.Default.Equals(arr[i], mem))
					{
						return i;
					}
					if (!EqualityComparer<T>.Default.Equals(arr[i], value))
					{
						i++;
						continue;
					}
					goto IL_0069;
				}
			}
			int num2 = num + 1;
			if (growMode == SetGrowMode.Min_10_Then_150_Percent)
			{
				num2 = Mathf.Min(10, Mathf.CeilToInt((float)num * 1.5f));
			}
			UnityEngine.Debug.LogErrorFormat("Had to garbage {0}[{1}] and replace with {0}[{2}]!", typeof(T).PrettyName(), num, num2);
			Array.Resize(ref arr, num2);
			goto IL_00f5;
			IL_00f5:
			arr[i] = mem;
			return i;
			IL_0069:
			for (int j = i + 1; j < num; j++)
			{
				if (EqualityComparer<T>.Default.Equals(arr[j], mem))
				{
					return j;
				}
			}
			goto IL_00f5;
		}

		public static IEnumerable<IEnumerable<T>> GetAllOrders<T>(this IEnumerable<T> set, IEnumerable<T> subset = null)
		{
			if (subset == null)
			{
				subset = new T[0];
			}
			if (!set.Any())
			{
				yield return subset;
			}
			for (int i = 0; i < set.Count(); i++)
			{
				IEnumerable<T> set2 = set.Take(i).Concat(set.Skip(i + 1));
				foreach (IEnumerable<T> allOrder in set2.GetAllOrders(subset.Concat(set.Skip(i).Take(1))))
				{
					yield return allOrder;
				}
			}
		}

		public static bool TryPop<T>(this Stack<T> stack, out T value)
		{
			if (stack == null)
			{
				value = default(T);
				return false;
			}
			if (stack.Count == 0)
			{
				value = default(T);
				return false;
			}
			value = stack.Pop();
			return true;
		}

		public static IEnumerable<SeqMatch<T>> GetSequences<T>(this IEnumerable<T> source, params T[][] sequences)
		{
			return source.GetSequences((Func<T, T, bool>)EqualityComparer<T>.Default.Equals, sequences);
		}

		public static IEnumerable<SeqMatch<T1>> GetSequences<T1, T2>(this IEnumerable<T1> ts, Func<T1, T2, bool> comparison, params T2[][] sequences)
		{
			int seqCount = sequences.Length;
			int[] seqSizes = new int[seqCount];
			int[] checkIndeces = new int[seqCount];
			for (int j = 0; j < seqCount; j++)
			{
				seqSizes[j] = sequences[j].Length;
			}
			foreach (T1 t in ts)
			{
				int i = 0;
				while (i < seqCount)
				{
					if (comparison(t, sequences[i][checkIndeces[i]]))
					{
						yield return new SeqMatch<T1>(i, checkIndeces[i], t);
						if (++checkIndeces[i] == seqSizes[i])
						{
							checkIndeces[i] = 0;
						}
					}
					else
					{
						checkIndeces[i] = 0;
					}
					int num = i + 1;
					i = num;
				}
			}
		}

		public static void AddToList<K, V>(this Dictionary<K, List<V>> dict, K key, V value)
		{
			if (!dict.TryGetValue(key, out var value2))
			{
				value2 = (dict[key] = new List<V>());
			}
			value2.Add(value);
		}

		public static PooledEnumerable<T> GetPooled<T>(this IEnumerable<T> enumerable, int cap = 1, bool preallocate = true)
		{
			PooledEnumerable<T> pooledEnumerable = enumerable as PooledEnumerable<T>;
			if (pooledEnumerable == null)
			{
				pooledEnumerable = new PooledEnumerable<T>(enumerable, cap, preallocate);
			}
			return pooledEnumerable;
		}

		public static PooledEnumerable GetPooled(this IEnumerable enumerable, int cap = 1, bool preallocate = true)
		{
			PooledEnumerable pooledEnumerable = enumerable as PooledEnumerable;
			if (pooledEnumerable == null)
			{
				pooledEnumerable = new PooledEnumerable(enumerable, cap, preallocate);
			}
			return pooledEnumerable;
		}

		public static PresteppedEnumerable<T> GetPrestepped<T>(this IEnumerable<T> enumerable)
		{
			PresteppedEnumerable<T> presteppedEnumerable = enumerable as PresteppedEnumerable<T>;
			if (presteppedEnumerable == null)
			{
				presteppedEnumerable = new PresteppedEnumerable<T>(enumerable);
			}
			return presteppedEnumerable;
		}

		public static PresteppedEnumerable GetPrestepped(this IEnumerable enumerable)
		{
			PresteppedEnumerable presteppedEnumerable = enumerable as PresteppedEnumerable;
			if (presteppedEnumerable == null)
			{
				presteppedEnumerable = new PresteppedEnumerable(enumerable);
			}
			return presteppedEnumerable;
		}

		public static ResettableEnumerable<T> GetResettable<T>(this IEnumerable<T> enumerable, bool stepAfterReset = false)
		{
			ResettableEnumerable<T> resettableEnumerable = enumerable as ResettableEnumerable<T>;
			if (resettableEnumerable == null)
			{
				resettableEnumerable = new ResettableEnumerable<T>(enumerable, stepAfterReset);
			}
			return resettableEnumerable;
		}

		public static ResettableEnumerable GetResettable(this IEnumerable enumerable, bool stepAfterReset = false)
		{
			ResettableEnumerable resettableEnumerable = enumerable as ResettableEnumerable;
			if (resettableEnumerable == null)
			{
				resettableEnumerable = new ResettableEnumerable(enumerable, stepAfterReset);
			}
			return resettableEnumerable;
		}
	}
	[Serializable]
	public class ConstArray<T>
	{
		public T[] _data;

		[SerializeField]
		[HideInInspector]
		public uint _dataNum;

		public T this[uint key]
		{
			get
			{
				return _data[key];
			}
			set
			{
				_data[key] = value;
			}
		}

		public T this[int key]
		{
			get
			{
				return _data[key];
			}
			set
			{
				_data[key] = value;
			}
		}

		public uint Length => _dataNum;

		public int sLength => (int)_dataNum;

		public int MaxSize => _data.Length;

		public ConstArray(uint size)
		{
			_data = new T[size];
		}

		public ConstArray(uint size, T[] data)
			: this(size)
		{
			_dataNum = (uint)Mathf.Min(data.Length, _data.Length);
			Array.Copy(data, _data, _dataNum);
			if (data.Length > _dataNum)
			{
				UnityEngine.Debug.LogError("Array too large: Max:" + size + " Initial:" + data.Length);
			}
		}

		protected ConstArray()
		{
		}

		public void Add(T obj)
		{
			if (_dataNum < _data.Length)
			{
				_data[_dataNum] = obj;
				_dataNum++;
			}
			else
			{
				UnityEngine.Debug.LogError("Array Out of Bounds: Increase Size (" + _data[0].ToString() + ")");
			}
		}

		public void Insert(T obj, uint index)
		{
			if (index > _dataNum)
			{
				Add(obj);
			}
			else if (_dataNum < _data.Length)
			{
				_dataNum++;
				_ = ref _data[index];
				T val = _data[index];
				for (uint num = index + 1; num < _dataNum; num++)
				{
					T val2 = _data[num];
					_data[num] = val;
					val = val2;
				}
				_data[index] = obj;
			}
			else
			{
				UnityEngine.Debug.LogError("Array Out of Bounds: Increase Size (" + _data[0].ToString() + ")");
			}
		}

		public int IndexOf(T objectT)
		{
			return Array.IndexOf(_data, objectT, 0, (int)_dataNum);
		}

		public bool Contains(T objectT)
		{
			return Array.IndexOf(_data, objectT, 0, (int)_dataNum) >= 0;
		}

		public void Remove(T objectT, bool clearToDefault = true)
		{
			int num = Array.IndexOf(_data, objectT, 0, (int)_dataNum);
			if (num >= 0)
			{
				_data[num] = _data[_dataNum - 1];
				_dataNum--;
				if (clearToDefault)
				{
					_data[_dataNum] = default(T);
				}
			}
		}

		public T RemoveAtIndex(uint index, bool clearToDefault = true)
		{
			T result = _data[index];
			_data[index] = _data[_dataNum - 1];
			_dataNum--;
			if (clearToDefault)
			{
				_data[_dataNum] = default(T);
			}
			return result;
		}

		public void RemoveStable(T objectT, bool clearToDefault = true)
		{
			int num = Array.IndexOf(_data, objectT, 0, (int)_dataNum);
			if (num >= 0)
			{
				RemoveAtIndexStable((uint)num, clearToDefault);
			}
		}

		public void RemoveAtIndexStable(uint index, bool clearToDefault = true)
		{
			for (uint num = index; num < _dataNum - 1; num++)
			{
				_data[num] = _data[num + 1];
			}
			_dataNum--;
			if (clearToDefault)
			{
				_data[_dataNum] = default(T);
			}
		}

		public void Clear()
		{
			_dataNum = 0u;
		}

		public void ClearToDefault()
		{
			Array.Clear(_data, 0, _data.Length);
			_dataNum = 0u;
		}

		public void ReleaseUnusedReferences()
		{
			if (_dataNum < _data.Length)
			{
				Array.Clear(_data, (int)_dataNum, _data.Length - (int)_dataNum);
			}
		}

		public T[] ToArray()
		{
			T[] array = new T[_dataNum];
			for (int i = 0; i < _dataNum; i++)
			{
				array[i] = _data[i];
			}
			return array;
		}

		public void CopyTo(ConstArray<T> dest)
		{
			T[] data = dest._data;
			uint num = Math.Min((uint)data.Length, _dataNum);
			for (int i = 0; i < data.Length; i++)
			{
				data[i] = ((i < num) ? _data[i] : default(T));
			}
			dest._dataNum = num;
		}
	}
	public class ConstQueue<T>
	{
		public T[] _data;

		public int _front;

		public int _length;

		public int MaxSize => _data.Length;

		public int Length => _length;

		public T this[int index]
		{
			get
			{
				return _data[(_front + index) % _data.Length];
			}
			set
			{
				_data[(_front + index) % _data.Length] = value;
			}
		}

		public ConstQueue(int size)
		{
			_data = new T[size];
			_front = 0;
			_length = 0;
		}

		public void Enqueue(T obj, bool overwrite = false)
		{
			bool flag = _length == _data.Length;
			if (flag && !overwrite)
			{
				UnityEngine.Debug.LogError("Attempted to enqueue to full queue with overwrite false");
				return;
			}
			int num = (_front + _length) % _data.Length;
			_data[num] = obj;
			if (flag)
			{
				_front = (_front + 1) % _data.Length;
			}
			else
			{
				_length++;
			}
		}

		public T Dequeue(bool clearToDefault = false)
		{
			if (_length == 0)
			{
				UnityEngine.Debug.LogError("Attempted to dequeue from empty queue");
				return default(T);
			}
			T result = _data[_front];
			if (clearToDefault)
			{
				_data[_front] = default(T);
			}
			_front = (_front + 1) % _data.Length;
			_length--;
			return result;
		}

		public T Peek()
		{
			if (_length == 0)
			{
				UnityEngine.Debug.LogError("Attempted to peek empty queue");
				return default(T);
			}
			return _data[_front];
		}

		public void Clear()
		{
			_front = 0;
			_length = 0;
		}

		public void ClearToDefault()
		{
			Array.Clear(_data, 0, _data.Length);
			_front = 0;
			_length = 0;
		}

		[Conditional("CS_DEBUG")]
		private void ValidateIndex(int index)
		{
			if (index < 0 || index > _length)
			{
				throw new IndexOutOfRangeException("Index " + index + " is out of range (0 - " + _length + ")");
			}
		}
	}
	public static class ArrayX
	{
		public static bool IsNullOrEmpty(Array array)
		{
			if (array != null)
			{
				return array.Length == 0;
			}
			return true;
		}

		public static int IndexOfRef<T>(this T[] array, T value) where T : class
		{
			int num = array.Length;
			for (int i = 0; i < num; i++)
			{
				if (array[i] == value)
				{
					return i;
				}
			}
			return -1;
		}

		public static bool Contains(this Array array, object value)
		{
			int num = array.Length;
			while (--num >= 0)
			{
				if (array.GetValue(num) == value)
				{
					return true;
				}
			}
			return false;
		}

		public static bool HasDuplicates(this Array array)
		{
			int num = array.Length;
			while (--num >= 0)
			{
				int num2 = array.Length;
				while (--num2 >= 0)
				{
					if (num != num2 && array.GetValue(num) == array.GetValue(num2))
					{
						return true;
					}
				}
			}
			return false;
		}

		public static void Shuffle<T>(this T[] array)
		{
			int num = array.Length;
			while (num > 1)
			{
				num--;
				int num2 = UnityEngine.Random.Range(0, num);
				T val = array[num2];
				array[num2] = array[num];
				array[num] = val;
			}
		}

		public static void Insert<T>(ref T[] array, T value, int valueIndex)
		{
			int num = array.Length;
			Array.Resize(ref array, 1 + num);
			Array array2 = Array.CreateInstance(typeof(T), num - valueIndex);
			Array.Copy(array, valueIndex, array2, 0, array2.Length);
			Array.Copy(array2, 0, array, valueIndex + 1, array2.Length);
			array[valueIndex] = value;
		}

		public static void RemoveAt<T>(ref T[] array, int index)
		{
			int num = array.Length;
			int length = array.Length - index - 1;
			Array.Copy(array, index + 1, array, index, length);
			Array.Resize(ref array, num - 1);
		}

		public static bool ContentsEqual<T>(T[] a1, T[] a2)
		{
			if (a1 == a2)
			{
				return true;
			}
			if (a1 == null || a2 == null)
			{
				return false;
			}
			int num = a1.Length;
			if (a2.Length != num)
			{
				return false;
			}
			EqualityComparer<T> @default = EqualityComparer<T>.Default;
			for (int i = 0; i < num; i++)
			{
				if (!@default.Equals(a1[i], a2[i]))
				{
					return false;
				}
			}
			return true;
		}

		public static T[] CroppedBy<T>(this T[] arr, int count)
		{
			if (arr == null)
			{
				return null;
			}
			int num = arr.Length;
			if (num <= count)
			{
				return new T[0];
			}
			num -= count;
			T[] array = new T[num];
			Array.Copy(arr, array, num);
			return array;
		}

		public static bool AnyNull<T>(this T[] arr) where T : class
		{
			int i = 0;
			for (int num = arr.Length; i < num; i++)
			{
				if (arr[i] == null)
				{
					return true;
				}
			}
			return false;
		}

		public static int MemberCount<T>(this T[] arr) where T : class
		{
			int num = 0;
			if (arr != null)
			{
				int i = 0;
				for (int num2 = arr.Length; i < num2; i++)
				{
					if (arr[i] != null)
					{
						num++;
					}
				}
			}
			return num;
		}
	}
	public class PanicException : Exception
	{
		public PanicException(string str, params object[] args)
			: base(string.Format(str, args))
		{
		}

		public PanicException(Exception inner, string str, params object[] args)
			: base(string.Format(str, args), inner)
		{
		}
	}
	public static class DebugX
	{
		public delegate void DrawLine(Vector3 posA, Vector3 posB, Color color);

		private static readonly HashSet<string> loggedStrings = new HashSet<string>();

		[Conditional("UNITY_EDITOR")]
		public static void DrawALine(Vector3 posA, Vector3 posB, Color color, DrawLine drawLineDelegate)
		{
			drawLineDelegate(posA, posB, color);
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawALine(Vector3 posA, Vector3 posB, Color color)
		{
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawRay(Vector3 pos, Vector3 dir, Color color, DrawLine drawLineDelegate)
		{
			drawLineDelegate(pos, pos + dir, color);
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawRay(Vector3 pos, Vector3 dir, Color color)
		{
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawX(Vector3 centre, float size, Color color, float duration = 0f, bool depthTest = true)
		{
			size *= 0.5f;
			UnityEngine.Debug.DrawLine(centre + new Vector3(0f - size, 0f - size, 0f - size), centre + new Vector3(size, size, size), color, duration, depthTest);
			UnityEngine.Debug.DrawLine(centre + new Vector3(0f - size, 0f - size, size), centre + new Vector3(size, size, 0f - size), color, duration, depthTest);
			UnityEngine.Debug.DrawLine(centre + new Vector3(0f - size, size, 0f - size), centre + new Vector3(size, 0f - size, size), color, duration, depthTest);
			UnityEngine.Debug.DrawLine(centre + new Vector3(0f - size, size, size), centre + new Vector3(size, 0f - size, 0f - size), color, duration, depthTest);
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawX(Vector3 centre, float size, Color color, DrawLine drawlineDelegate)
		{
			size *= 0.5f;
			drawlineDelegate(centre + new Vector3(0f - size, 0f - size, 0f - size), centre + new Vector3(size, size, size), color);
			drawlineDelegate(centre + new Vector3(0f - size, 0f - size, size), centre + new Vector3(size, size, 0f - size), color);
			drawlineDelegate(centre + new Vector3(0f - size, size, 0f - size), centre + new Vector3(size, 0f - size, size), color);
			drawlineDelegate(centre + new Vector3(0f - size, size, size), centre + new Vector3(size, 0f - size, 0f - size), color);
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawBox(Vector3 position, Quaternion rotation, Vector3 extents, Color color, float duration = 0f, bool depthTest = true)
		{
			Vector3 vector = position + rotation * new Vector3(extents.x, extents.y, extents.z);
			Vector3 vector2 = position + rotation * new Vector3(extents.x, extents.y, 0f - extents.z);
			Vector3 vector3 = position + rotation * new Vector3(extents.x, 0f - extents.y, extents.z);
			Vector3 vector4 = position + rotation * new Vector3(extents.x, 0f - extents.y, 0f - extents.z);
			Vector3 vector5 = position + rotation * new Vector3(0f - extents.x, extents.y, extents.z);
			Vector3 vector6 = position + rotation * new Vector3(0f - extents.x, extents.y, 0f - extents.z);
			Vector3 vector7 = position + rotation * new Vector3(0f - extents.x, 0f - extents.y, extents.z);
			Vector3 vector8 = position + rotation * new Vector3(0f - extents.x, 0f - extents.y, 0f - extents.z);
			UnityEngine.Debug.DrawLine(vector, vector2, color, duration, depthTest);
			UnityEngine.Debug.DrawLine(vector2, vector4, color, duration, depthTest);
			UnityEngine.Debug.DrawLine(vector4, vector3, color, duration, depthTest);
			UnityEngine.Debug.DrawLine(vector3, vector, color, duration, depthTest);
			UnityEngine.Debug.DrawLine(vector5, vector6, color, duration, depthTest);
			UnityEngine.Debug.DrawLine(vector6, vector8, color, duration, depthTest);
			UnityEngine.Debug.DrawLine(vector8, vector7, color, duration, depthTest);
			UnityEngine.Debug.DrawLine(vector7, vector5, color, duration, depthTest);
			UnityEngine.Debug.DrawLine(vector, vector5, color, duration, depthTest);
			UnityEngine.Debug.DrawLine(vector2, vector6, color, duration, depthTest);
			UnityEngine.Debug.DrawLine(vector3, vector7, color, duration, depthTest);
			UnityEngine.Debug.DrawLine(vector4, vector8, color, duration, depthTest);
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawBox(Matrix4x4 localToWorld, Vector3 center, Vector3 extents, Color color, DrawLine drawLineDelegate)
		{
			Vector3 vector = localToWorld.MultiplyPoint3x4(center + new Vector3(extents.x, extents.y, extents.z));
			Vector3 vector2 = localToWorld.MultiplyPoint3x4(center + new Vector3(extents.x, extents.y, 0f - extents.z));
			Vector3 vector3 = localToWorld.MultiplyPoint3x4(center + new Vector3(extents.x, 0f - extents.y, extents.z));
			Vector3 vector4 = localToWorld.MultiplyPoint3x4(center + new Vector3(extents.x, 0f - extents.y, 0f - extents.z));
			Vector3 vector5 = localToWorld.MultiplyPoint3x4(center + new Vector3(0f - extents.x, extents.y, extents.z));
			Vector3 vector6 = localToWorld.MultiplyPoint3x4(center + new Vector3(0f - extents.x, extents.y, 0f - extents.z));
			Vector3 vector7 = localToWorld.MultiplyPoint3x4(center + new Vector3(0f - extents.x, 0f - extents.y, extents.z));
			Vector3 vector8 = localToWorld.MultiplyPoint3x4(center + new Vector3(0f - extents.x, 0f - extents.y, 0f - extents.z));
			drawLineDelegate(vector, vector2, color);
			drawLineDelegate(vector2, vector4, color);
			drawLineDelegate(vector4, vector3, color);
			drawLineDelegate(vector3, vector, color);
			drawLineDelegate(vector5, vector6, color);
			drawLineDelegate(vector6, vector8, color);
			drawLineDelegate(vector8, vector7, color);
			drawLineDelegate(vector7, vector5, color);
			drawLineDelegate(vector, vector5, color);
			drawLineDelegate(vector2, vector6, color);
			drawLineDelegate(vector3, vector7, color);
			drawLineDelegate(vector4, vector8, color);
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawCircle(Vector3 pos, Vector3 rotationUp, Vector3 rotationRight, float radius, Color color, DrawLine drawLineDelegate)
		{
			for (int i = 0; i < 32; i++)
			{
				Vector3 localPointOnCircle = GetLocalPointOnCircle(rotationRight, rotationUp, radius, 32, i);
				Vector3 localPointOnCircle2 = GetLocalPointOnCircle(rotationRight, rotationUp, radius, 32, i + 1);
				drawLineDelegate(pos + localPointOnCircle, pos + localPointOnCircle2, color);
			}
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawCircle(Vector3 pos, Vector3 rotationUp, Vector3 rotationRight, float radius, Color color)
		{
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawCircle(Vector3 pos, Vector3 normal, float radius, Color color)
		{
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawCircle(Vector3 pos, Vector3 normal, float radius, Color color, DrawLine drawLineDelegate)
		{
			VectorX.OrthoNormal(normal, out var _, out var _);
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawSphere(Vector3 pos, Vector3 rotationUp, float radius, Color color, DrawLine drawLineDelegate)
		{
			VectorX.OrthoNormal(rotationUp, out var _, out var _);
			for (int i = 0; i < 2; i++)
			{
				Quaternion.AngleAxis(90 * i, rotationUp);
			}
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawCone(Vector3 pos, Vector3 dir, float height, float halfAngleInDegrees, Color color)
		{
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawCone(Vector3 pos, Vector3 dir, float height, float halfAngleInDegrees, Color color, DrawLine drawLineDelegate)
		{
			VectorX.OrthoNormal(dir, out var up, out var right);
			float num = height / Mathf.Cos(halfAngleInDegrees * ((float)Math.PI / 180f));
			float num2 = Mathf.Sqrt(num * num - height * height);
			Vector3 vector = dir * height;
			drawLineDelegate(pos, pos + vector + up * num2, color);
			drawLineDelegate(pos, pos + vector - up * num2, color);
			drawLineDelegate(pos, pos + vector + right * num2, color);
			drawLineDelegate(pos, pos + vector - right * num2, color);
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawCylinder(Vector3 pos, Vector3 up, Vector3 right, Vector3 forward, float radius, float length, Color color, DrawLine drawLineDelegate)
		{
			float num = length / 2f;
			Vector3 vector = pos + (0f - num) * forward;
			Vector3 vector2 = pos + num * forward;
			for (int i = 0; i < 8; i++)
			{
				Vector3 localPointOnCircle = GetLocalPointOnCircle(right, up, radius, 8, i);
				drawLineDelegate(vector + localPointOnCircle, vector2 + localPointOnCircle, color);
			}
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawCylinder(Vector3 pos, Vector3 up, Vector3 right, Vector3 forward, float radius, float length, Color color)
		{
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawCylinder(Vector3 pos, Vector3 normal, float radius, float length, Color color)
		{
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawCylinder(Vector3 pos, Vector3 forward, float radius, float length, Color color, DrawLine drawLineDelegate)
		{
			VectorX.OrthoNormal(forward, out var _, out var _);
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawArrow(Vector3 pos, Vector3 right, Vector3 forward, Vector2 baseSize, Vector2 tipSize, Color color, DrawLine drawLineDelegate)
		{
			Vector3 vector = pos + -forward * baseSize.y + -right * (baseSize.x / 2f);
			Vector3 vector2 = pos + -forward * baseSize.y + right * (baseSize.x / 2f);
			Vector3 vector3 = pos + -right * (baseSize.x / 2f);
			Vector3 vector4 = pos + right * (baseSize.x / 2f);
			Vector3 vector5 = pos + -right * (tipSize.x / 2f);
			Vector3 vector6 = pos + right * (tipSize.x / 2f);
			Vector3 vector7 = pos + forward * tipSize.y;
			drawLineDelegate(vector7, vector5, color);
			drawLineDelegate(vector5, vector3, color);
			drawLineDelegate(vector3, vector, color);
			drawLineDelegate(vector, vector2, color);
			drawLineDelegate(vector2, vector4, color);
			drawLineDelegate(vector4, vector6, color);
			drawLineDelegate(vector6, vector7, color);
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawArrow(Vector3 pos, Vector3 right, Vector3 forward, Vector2 baseSize, Vector2 tipSize, Color color)
		{
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawOrthoNormal(Vector3 pos, Vector3 right, Vector3 up, Vector3 forward, DrawLine drawLineDelegate, float duration = 0f)
		{
			drawLineDelegate(pos, pos + right, Color.red);
			drawLineDelegate(pos, pos + up, Color.green);
			drawLineDelegate(pos, pos + forward, Color.blue);
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawOrthoNormal(Vector3 pos, Quaternion rotation, DrawLine drawLineDelegate, float size = 1f, float duration = 0f)
		{
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawOrthoNormal(Vector3 pos, Quaternion rotation, float size = 1f, float duration = 0f)
		{
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawOrthoNormal(Vector3 pos, Vector3 right, Vector3 up, Vector3 forward, float duration = 0f)
		{
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawRectangle(Vector3 pos, Vector3 up, Vector3 right, Color color)
		{
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawRectangle(Vector3 pos, Vector3 up, Vector3 right, Color color, DrawLine drawLineDelegate)
		{
			Vector3 vector = pos + up + right;
			Vector3 vector2 = pos - up + right;
			Vector3 vector3 = pos - up - right;
			Vector3 vector4 = pos + up - right;
			drawLineDelegate(vector, vector2, color);
			drawLineDelegate(vector2, vector3, color);
			drawLineDelegate(vector3, vector4, color);
			drawLineDelegate(vector4, vector, color);
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawMatrix(Matrix4x4 matrix)
		{
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawFrustum(Matrix4x4 frustum, Matrix4x4 localToWorld, Color color, float duration = 0f, bool flipZ = false)
		{
			Matrix4x4 inverse = frustum.inverse;
			float num = (flipZ ? (-1f) : 1f);
			Vector4 vector = inverse * new Vector4(-1f, -1f, -1f, 1f);
			Vector4 vector2 = inverse * new Vector4(-1f, 1f, -1f, 1f);
			Vector4 vector3 = inverse * new Vector4(1f, 1f, -1f, 1f);
			Vector4 vector4 = inverse * new Vector4(1f, -1f, -1f, 1f);
			Vector4 vector5 = inverse * new Vector4(-1f, -1f, 1f, 1f);
			Vector4 vector6 = inverse * new Vector4(-1f, 1f, 1f, 1f);
			Vector4 vector7 = inverse * new Vector4(1f, 1f, 1f, 1f);
			Vector4 vector8 = inverse * new Vector4(1f, -1f, 1f, 1f);
			vector = new Vector4(vector.x / vector.w, vector.y / vector.w, vector.z / vector.w * num, 1f);
			vector2 = new Vector4(vector2.x / vector2.w, vector2.y / vector2.w, vector2.z / vector2.w * num, 1f);
			vector3 = new Vector4(vector3.x / vector3.w, vector3.y / vector3.w, vector3.z / vector3.w * num, 1f);
			vector4 = new Vector4(vector4.x / vector4.w, vector4.y / vector4.w, vector4.z / vector4.w * num, 1f);
			vector5 = new Vector4(vector5.x / vector5.w, vector5.y / vector5.w, vector5.z / vector5.w * num, 1f);
			vector6 = new Vector4(vector6.x / vector6.w, vector6.y / vector6.w, vector6.z / vector6.w * num, 1f);
			vector7 = new Vector4(vector7.x / vector7.w, vector7.y / vector7.w, vector7.z / vector7.w * num, 1f);
			vector8 = new Vector4(vector8.x / vector8.w, vector8.y / vector8.w, vector8.z / vector8.w * num, 1f);
			vector = localToWorld * vector;
			vector2 = localToWorld * vector2;
			vector3 = localToWorld * vector3;
			vector4 = localToWorld * vector4;
			vector5 = localToWorld * vector5;
			vector6 = localToWorld * vector6;
			vector7 = localToWorld * vector7;
			vector8 = localToWorld * vector8;
			UnityEngine.Debug.DrawLine(vector, vector2, color, duration);
			UnityEngine.Debug.DrawLine(vector2, vector3, color, duration);
			UnityEngine.Debug.DrawLine(vector3, vector4, color, duration);
			UnityEngine.Debug.DrawLine(vector4, vector, color, duration);
			UnityEngine.Debug.DrawLine(vector5, vector6, color, duration);
			UnityEngine.Debug.DrawLine(vector6, vector7, color, duration);
			UnityEngine.Debug.DrawLine(vector7, vector8, color, duration);
			UnityEngine.Debug.DrawLine(vector8, vector5, color, duration);
			UnityEngine.Debug.DrawLine(vector, vector5, color, duration);
			UnityEngine.Debug.DrawLine(vector2, vector6, color, duration);
			UnityEngine.Debug.DrawLine(vector3, vector7, color, duration);
			UnityEngine.Debug.DrawLine(vector4, vector8, color, duration);
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawHemiSphere(Vector3 pos, Vector3 up, Vector3 right, float radius, Color color, DrawLine drawLineDelegate)
		{
			for (int i = 0; i < 4; i++)
			{
				Quaternion.AngleAxis(45 * i, up);
			}
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawHemiSphere(Vector3 pos, Vector3 rotationUp, Vector3 rotationRight, float radius, Color color)
		{
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawCapsule(Vector3 pos, Vector3 up, Vector3 right, Vector3 forward, float radius, float length, Color color, DrawLine drawLineDelegate)
		{
			float num = length / 2f;
			Vector3 vector = pos + (0f - num) * forward;
			Vector3 vector2 = pos + num * forward;
			for (int i = 0; i < 8; i++)
			{
				Vector3 localPointOnCircle = GetLocalPointOnCircle(right, up, radius, 8, i);
				drawLineDelegate(vector + localPointOnCircle, vector2 + localPointOnCircle, color);
			}
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawCapsule(Vector3 pos, Vector3 up, Vector3 right, Vector3 forward, float radius, float length, Color color)
		{
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawCapsule(Vector3 pos, Vector3 normal, float radius, float length, Color color)
		{
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawCapsule(Vector3 pos, Vector3 forward, float radius, float length, Color color, DrawLine drawLineDelegate)
		{
			VectorX.OrthoNormal(forward, out var _, out var _);
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawSemiCircle(Vector3 pos, Vector3 rotationUp, Vector3 rotationRight, float radius, Color color, DrawLine drawLineDelegate)
		{
			for (int i = 0; i < 16; i++)
			{
				Vector3 localPointOnCircle = GetLocalPointOnCircle(rotationRight, rotationUp, radius, 32, i);
				Vector3 localPointOnCircle2 = GetLocalPointOnCircle(rotationRight, rotationUp, radius, 32, i + 1);
				drawLineDelegate(pos + localPointOnCircle, pos + localPointOnCircle2, color);
			}
			Vector3 localPointOnCircle3 = GetLocalPointOnCircle(rotationRight, rotationUp, radius, 32, 0);
			Vector3 localPointOnCircle4 = GetLocalPointOnCircle(rotationRight, rotationUp, radius, 32, 16);
			drawLineDelegate(pos + localPointOnCircle3, pos + localPointOnCircle4, color);
		}

		[Conditional("UNITY_EDITOR")]
		public static void DrawSemiCircle(Vector3 pos, Vector3 rotationUp, Vector3 rotationRight, float radius, Color color)
		{
		}

		private static Vector3 GetLocalPointOnCircle(Vector3 rotationRight, Vector3 rotationUp, float radius, int resolution, int index)
		{
			float num = (float)index / (float)resolution;
			return (-rotationRight * Mathf.Cos((float)Math.PI * 2f * num) + rotationUp * Mathf.Sin((float)Math.PI * 2f * num)) * radius;
		}

		public static void GizmosDrawLine(Vector3 posA, Vector3 posB, Color color)
		{
			Color color2 = Gizmos.color;
			Matrix4x4 matrix = Gizmos.matrix;
			Gizmos.color = color;
			Gizmos.matrix = Matrix4x4.identity;
			Gizmos.DrawLine(posA, posB);
			Gizmos.color = color2;
			Gizmos.matrix = matrix;
		}

		public static void DebugDrawLine(Vector3 posA, Vector3 posB, Color color)
		{
			UnityEngine.Debug.DrawLine(posA, posB, color);
		}

		public static void ClearConsole()
		{
			UnityEngine.Debug.ClearDeveloperConsole();
		}

		[Conditional("UNITY_EDITOR")]
		public static void LogException(Exception exception, UnityEngine.Object context = null)
		{
			UnityEngine.Debug.LogException(exception, context);
		}

		[Conditional("UNITY_EDITOR")]
		public static void LogError(string logMessage, UnityEngine.Object context = null)
		{
			UnityEngine.Debug.LogError(logMessage, context);
		}

		[Conditional("UNITY_EDITOR")]
		public static void LogWarning(string logMessage, UnityEngine.Object context = null)
		{
			UnityEngine.Debug.LogWarning(logMessage, context);
		}

		[Conditional("UNITY_EDITOR")]
		public static void Log(string logMessage, UnityEngine.Object context = null)
		{
			UnityEngine.Debug.Log(logMessage, context);
		}

		[Conditional("UNITY_EDITOR")]
		public static void LogFormat(string logMessage, params object[] args)
		{
			UnityEngine.Debug.LogFormat(logMessage, args);
		}

		public static void LogOnce(string logMessage, UnityEngine.Object context = null)
		{
			if (loggedStrings.Add(logMessage))
			{
				UnityEngine.Debug.Log(logMessage, context);
			}
		}

		public static void LogWarningOnce(string logMessage, UnityEngine.Object context = null)
		{
			if (loggedStrings.Add(logMessage))
			{
				UnityEngine.Debug.LogWarning(logMessage, context);
			}
		}

		public static void LogErrorOnce(string logMessage, UnityEngine.Object context = null)
		{
			if (loggedStrings.Add(logMessage))
			{
				UnityEngine.Debug.LogError(logMessage, context);
			}
		}
	}
	public struct DynamicProperty<T>
	{
		private struct Field : IEquatable<Field>
		{
			public readonly Type declaringType;

			public readonly string name;

			public readonly int index;

			public Field(Type declaringType, string name, int index)
			{
				this.declaringType = declaringType;
				this.name = name;
				this.index = index;
			}

			public bool Equals(Field other)
			{
				if (declaringType == other.declaringType && name == other.name && index == other.index)
				{
					return true;
				}
				UnityEngine.Debug.Log("");
				return false;
			}
		}

		private readonly Func<object, T> get;

		private readonly Action<object, T> set;

		private readonly object obj;

		private static readonly Dictionary<Field, DynamicProperty<T>> cache;

		private static readonly Dictionary<Type, ReflectionX.OptionalFieldInfo[]> paramFieldCache;

		static DynamicProperty()
		{
			cache = new Dictionary<Field, DynamicProperty<T>>(100);
			paramFieldCache = new Dictionary<Type, ReflectionX.OptionalFieldInfo[]>(100);
		}

		private DynamicProperty(object obj, string fieldName, int paramIdx, bool required, Type support, Type editorSupport)
		{
			this = default(DynamicProperty<T>);
			Type type = obj.GetType();
			if (!cache.TryGetValue(new Field(type, fieldName, paramIdx), out this))
			{
				if (support != null)
				{
					string dynamicGetSetName;
					string dynamicGetSetName2;
					if (fieldName != null)
					{
						dynamicGetSetName = type.GetDynamicGetSetName(fieldName, getter: true);
						dynamicGetSetName2 = type.GetDynamicGetSetName(fieldName, getter: false);
					}
					else
					{
						dynamicGetSetName = type.GetDynamicGetSetName(paramIdx, getter: true);
						dynamicGetSetName2 = type.GetDynamicGetSetName(paramIdx, getter: false);
					}
					MethodInfo method = support.GetMethod(dynamicGetSetName, BindingFlags.Static | BindingFlags.Public);
					MethodInfo method2 = support.GetMethod(dynamicGetSetName2, BindingFlags.Static | BindingFlags.Public);
					if (method == null && editorSupport != null)
					{
						method = editorSupport.GetMethod(dynamicGetSetName, BindingFlags.Static | BindingFlags.Public);
						method2 = editorSupport.GetMethod(dynamicGetSetName2, BindingFlags.Static | BindingFlags.Public);
					}
					if (method != null)
					{
						get = (Func<object, T>)Delegate.CreateDelegate(typeof(Func<object, T>), method);
						set = (Action<object, T>)Delegate.CreateDelegate(typeof(Action<object, T>), method2);
					}
				}
				if (get == null && required)
				{
					if (fieldName != null)
					{
						get = obj.CreateDynamicGetter<T>(fieldName);
						set = obj.CreateDynamicSetter<T>(fieldName);
					}
					else
					{
						if (!paramFieldCache.TryGetValue(type, out var value))
						{
							value = (paramFieldCache[type] = type.GetIteratorParameterFields().ToArray());
						}
						if (value[paramIdx].info != null)
						{
							get = value[paramIdx].info.CreateDynamicGetter<T>();
							set = value[paramIdx].info.CreateDynamicSetter<T>();
						}
						else
						{
							get = type.CreateDynamicGetterFake<T>(fieldName);
							set = type.CreateDynamicSetterFake<T>(fieldName);
						}
					}
				}
				cache[new Field(type, fieldName, paramIdx)] = this;
			}
			this.obj = obj;
		}

		public DynamicProperty(object obj, string fieldName, bool required = true, Type support = null, Type editorSupport = null)
			: this(obj, fieldName, 0, required, support, editorSupport)
		{
		}

		public DynamicProperty(IEnumerator obj, int paramIndex, bool required = true, Type support = null, Type editorSupport = null)
			: this(obj, null, paramIndex, required, support, editorSupport)
		{
		}

		public T Get()
		{
			return get(obj);
		}

		public void Set(T value)
		{
			set(obj, value);
		}

		public static implicit operator bool(DynamicProperty<T> prop)
		{
			return prop.obj != null;
		}
	}
	public static class DynamicPropertyX
	{
		public static DynamicProperty<FT> GetDynamicProperty<FT>(this object obj, string fieldName, bool required = true, Type support = null, Type editorSupport = null)
		{
			return new DynamicProperty<FT>(obj, fieldName, required, support, editorSupport);
		}

		public static DynamicProperty<FT> GetDynamicProperty<FT>(this IEnumerator obj, int paramIndex, bool required = true, Type support = null, Type editorSupport = null)
		{
			return new DynamicProperty<FT>(obj, paramIndex, required, support, editorSupport);
		}

		public static string GetDynamicGetSetName(this Type declaringType, string fieldName, bool getter)
		{
			return declaringType.FullName.Replace('.', '+') + (getter ? "+get_" : "+set_") + fieldName;
		}

		public static string GetDynamicGetSetName(this Type declaringType, int paramIdx, bool getter)
		{
			return declaringType.GetDynamicGetSetName("$P" + paramIdx, getter);
		}

		public static string GetDynamicGetSetName(this FieldInfo field, bool getter)
		{
			return field.DeclaringType.GetDynamicGetSetName(field.GetLocalVarName() ?? field.Name, getter);
		}

		public static string GetLocalVarName(this FieldInfo field)
		{
			int num = field.Name.IndexOf(">__");
			if (num == -1)
			{
				return null;
			}
			return field.Name.Substring(1, num - 1);
		}
	}
	public static class EnumX
	{
		public static T Next<T>(this T src) where T : struct
		{
			if (!typeof(T).IsEnum)
			{
				throw new ArgumentException($"Argumnent {typeof(T).FullName} is not an Enum");
			}
			T[] array = (T[])Enum.GetValues(src.GetType());
			int num = Array.IndexOf(array, src) + 1;
			if (array.Length != num)
			{
				return array[num];
			}
			return array[0];
		}

		public static T Previous<T>(this T src) where T : struct
		{
			if (!typeof(T).IsEnum)
			{
				throw new ArgumentException($"Argumnent {typeof(T).FullName} is not an Enum");
			}
			T[] array = (T[])Enum.GetValues(src.GetType());
			int num = Array.IndexOf(array, src) - 1;
			if (num >= 0)
			{
				return array[num];
			}
			return array[array.Length - 1];
		}
	}
	public class InspectorButton : PropertyAttribute
	{
		public interface IPressable
		{
			void Press();
		}

		public readonly string title;

		public InspectorButton(string title = null)
		{
			this.title = title;
		}
	}
	public static class MeshX
	{
		[Flags]
		public enum MeshAttribute
		{
			Normals = 1,
			Tangents = 2,
			Colors = 4,
			TexCoords = 8,
			TexCoord2s = 0x10
		}

		private const float vertDist = 0.005f;

		private const float normalDiff = 0.001f;

		private const float tangentDiff = 0.001f;

		private const float colorDist = 0.001f;

		private const float uvDist = 0.001f;

		private const float uv2Dist = 0.001f;

		[Conditional("UNITY_EDITOR")]
		public static void FrustumToMesh(Matrix4x4 frustum, ref Mesh mesh)
		{
			Matrix4x4 inverse = frustum.inverse;
			Vector4 vector = inverse * new Vector4(-1f, -1f, -1f, 1f);
			Vector4 vector2 = inverse * new Vector4(-1f, 1f, -1f, 1f);
			Vector4 vector3 = inverse * new Vector4(1f, 1f, -1f, 1f);
			Vector4 vector4 = inverse * new Vector4(1f, -1f, -1f, 1f);
			Vector4 vector5 = inverse * new Vector4(-1f, -1f, 1f, 1f);
			Vector4 vector6 = inverse * new Vector4(-1f, 1f, 1f, 1f);
			Vector4 vector7 = inverse * new Vector4(1f, 1f, 1f, 1f);
			Vector4 vector8 = inverse * new Vector4(1f, -1f, 1f, 1f);
			Vector3[] array = new Vector3[8];
			_ = new Vector3[8];
			int[] array2 = new int[24];
			array[0] = new Vector3(vector.x / vector.w, vector.y / vector.w, vector.z / vector.w);
			array[1] = new Vector3(vector2.x / vector2.w, vector2.y / vector2.w, vector2.z / vector2.w);
			array[2] = new Vector3(vector3.x / vector3.w, vector3.y / vector3.w, vector3.z / vector3.w);
			array[3] = new Vector3(vector4.x / vector4.w, vector4.y / vector4.w, vector4.z / vector4.w);
			array[4] = new Vector3(vector5.x / vector5.w, vector5.y / vector5.w, vector5.z / vector5.w);
			array[5] = new Vector3(vector6.x / vector6.w, vector6.y / vector6.w, vector6.z / vector6.w);
			array[6] = new Vector3(vector7.x / vector7.w, vector7.y / vector7.w, vector7.z / vector7.w);
			array[7] = new Vector3(vector8.x / vector8.w, vector8.y / vector8.w, vector8.z / vector8.w);
			array2[0] = 0;
			array2[6] = 2;
			array2[12] = 1;
			array2[18] = 3;
			array2[1] = 3;
			array2[7] = 1;
			array2[13] = 0;
			array2[19] = 2;
			array2[2] = 7;
			array2[8] = 5;
			array2[14] = 4;
			array2[20] = 6;
			array2[3] = 0;
			array2[9] = 2;
			array2[15] = 1;
			array2[21] = 3;
			array2[4] = 7;
			array2[10] = 5;
			array2[16] = 4;
			array2[22] = 6;
			array2[5] = 4;
			array2[11] = 6;
			array2[17] = 5;
			array2[23] = 7;
			mesh.vertices = array;
			mesh.triangles = array2;
			mesh.RecalculateNormals();
		}

		public static bool CheckIfEdgeIsDuplicated(Vector3 v0, Vector3 v1, int[] indices, Vector3[] vertices, int triangleIdx)
		{
			for (int i = 0; i < indices.Length; i += 3)
			{
				if (i != triangleIdx)
				{
					Vector3 vector = vertices[indices[i]];
					Vector3 vector2 = vertices[indices[i + 1]];
					Vector3 vector3 = vertices[indices[i + 2]];
					if (CheckIfEdgeIsDuplicate(v0, v1, vector, vector2))
					{
						return true;
					}
					if (CheckIfEdgeIsDuplicate(v0, v1, vector2, vector3))
					{
						return true;
					}
					if (CheckIfEdgeIsDuplicate(v0, v1, vector3, vector))
					{
						return true;
					}
				}
			}
			return false;
		}

		public static bool CheckIfEdgeIsDuplicate(Vector3 v0, Vector3 v1, Vector3 j0, Vector3 j1)
		{
			float magnitude = (j0 - v0).magnitude;
			float magnitude2 = (j1 - v0).magnitude;
			float magnitude3 = (j0 - v1).magnitude;
			float magnitude4 = (j1 - v1).magnitude;
			if (magnitude < 0.05f && magnitude4 < 0.05f)
			{
				return true;
			}
			if (magnitude3 < 0.05f && magnitude2 < 0.05f)
			{
				return true;
			}
			return false;
		}

		public static bool CheckIfEdgeIsDuplicated(int i0, int i1, int[] indices, int triangleIdx)
		{
			for (int j = 0; j < indices.Length; j += 3)
			{
				if (j != triangleIdx)
				{
					int num = indices[j];
					int num2 = indices[j + 1];
					int num3 = indices[j + 2];
					if (CheckIfEdgeIsDuplicate(i0, i1, num, num2))
					{
						return true;
					}
					if (CheckIfEdgeIsDuplicate(i0, i1, num2, num3))
					{
						return true;
					}
					if (CheckIfEdgeIsDuplicate(i0, i1, num3, num))
					{
						return true;
					}
				}
			}
			return false;
		}

		public static bool CheckIfEdgeIsDuplicate(int i0, int i1, int j0, int j1)
		{
			if (i0 == j0 && i1 == j1)
			{
				return true;
			}
			if (i0 == j1 && i1 == j0)
			{
				return true;
			}
			return false;
		}

		public static bool HasAttribs(this MeshAttribute a, MeshAttribute b)
		{
			return (a & b) == b;
		}

		public static T[] ValidAtrribArray<T>(this Mesh mesh, T[] attribArray)
		{
			if (attribArray != null && mesh.vertexCount == attribArray.Length)
			{
				return attribArray;
			}
			return null;
		}

		public static Mesh SimplifyMesh(Mesh source, string meshName, MeshAttribute meshAttributes, Mesh destination = null)
		{
			Vector3[] array = source.vertices;
			Color[] array2 = (meshAttributes.HasAttribs(MeshAttribute.Colors) ? source.ValidAtrribArray(source.colors) : null);
			Vector2[] array3 = (meshAttributes.HasAttribs(MeshAttribute.TexCoords) ? source.ValidAtrribArray(source.uv) : null);
			Vector2[] array4 = (meshAttributes.HasAttribs(MeshAttribute.TexCoord2s) ? source.ValidAtrribArray(source.uv2) : null);
			Vector3[] array5 = (meshAttributes.HasAttribs(MeshAttribute.Normals) ? source.ValidAtrribArray(source.normals) : null);
			Vector4[] array6 = (meshAttributes.HasAttribs(MeshAttribute.Tangents) ? source.ValidAtrribArray(source.tangents) : null);
			int[] indices = source.GetIndices(0);
			int num = 0;
			int[] array7 = new int[array.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array7[i] = -1;
			}
			for (int j = 0; j < array.Length; j++)
			{
				if (array7[j] != -1)
				{
					continue;
				}
				for (int k = j + 1; k < array.Length; k++)
				{
					if (array7[k] == -1 && (array[j] - array[k]).magnitude <= 0.005f && (array3 == null || (array3[j] - array3[k]).magnitude <= 0.001f) && (array4 == null || (array4[j] - array4[k]).magnitude <= 0.001f) && (array2 == null || ((Vector4)(array2[j] - array2[k])).magnitude <= 0.001f) && (array5 == null || 1f - Vector3.Dot(array5[j].normalized, array5[k].normalized) <= 0.001f) && (array6 == null || 1f - Vector4.Dot(array6[j].normalized, array6[k].normalized) <= 0.001f))
					{
						array7[k] = j;
						num++;
					}
				}
			}
			if (num > 0)
			{
				int[] array8 = Enumerable.Range(0, array.Length).ToArray();
				List<Vector3> list = new List<Vector3>();
				List<Vector3> list2 = new List<Vector3>();
				List<Vector4> list3 = new List<Vector4>();
				List<Vector2> list4 = new List<Vector2>();
				List<Vector2> list5 = new List<Vector2>();
				List<Color> list6 = new List<Color>();
				num = 0;
				for (int l = 0; l < array8.Length; l++)
				{
					array8[l] = l - num;
					if (array7[l] != -1)
					{
						num++;
						continue;
					}
					list.Add(array[l]);
					if (array3 != null)
					{
						list4.Add(array3[l]);
					}
					if (array4 != null)
					{
						list5.Add(array4[l]);
					}
					if (array2 != null)
					{
						list6.Add(array2[l]);
					}
					if (array5 != null)
					{
						list2.Add(array5[l]);
					}
					if (array6 != null)
					{
						list3.Add(array6[l]);
					}
				}
				for (int m = 0; m < indices.Length; m++)
				{
					int num2 = indices[m];
					if (array7[num2] != -1)
					{
						num2 = array7[num2];
					}
					indices[m] = array8[num2];
				}
				array = list.ToArray();
				array3 = ((array3 == null) ? null : list4.ToArray());
				array4 = ((array4 == null) ? null : list5.ToArray());
				array2 = ((array2 == null) ? null : list6.ToArray());
				array5 = ((array5 == null) ? null : list2.ToArray());
				array6 = ((array6 == null) ? null : list3.ToArray());
			}
			Mesh obj = destination ?? new Mesh();
			obj.Clear();
			obj.name = meshName;
			obj.vertices = array;
			obj.normals = array5;
			obj.colors = array2;
			obj.tangents = array6;
			obj.uv = array3;
			obj.uv2 = array4;
			obj.SetIndices(indices, source.GetTopology(0), 0);
			obj.RecalculateBounds();
			return obj;
		}

		public static Vector3[] SmoothNormals(Mesh mesh)
		{
			int[] triangles = mesh.triangles;
			Vector3[] vertices = mesh.vertices;
			_ = mesh.normals;
			Vector3[] array = new Vector3[vertices.Length];
			Dictionary<int, List<Vector3>> dictionary = new Dictionary<int, List<Vector3>>();
			for (int i = 0; i < triangles.Length; i += 3)
			{
				int num = triangles[i];
				int num2 = triangles[i + 1];
				int num3 = triangles[i + 2];
				Vector3 vector = vertices[num];
				Vector3 vector2 = vertices[num2];
				Vector3 vector3 = vertices[num3];
				Vector3 vector4 = Vector3.Cross(vector2 - vector, vector3 - vector);
				float num4 = Vector3.Angle(vector2 - vector, vector3 - vector);
				float num5 = Vector3.Angle(vector3 - vector2, vector - vector2);
				float num6 = Vector3.Angle(vector - vector3, vector2 - vector3);
				dictionary.AddToList(num, vector4 * num4);
				dictionary.AddToList(num2, vector4 * num5);
				dictionary.AddToList(num3, vector4 * num6);
			}
			for (int j = 0; j < vertices.Length; j++)
			{
				Vector3 zero = Vector3.zero;
				List<Vector3> list = dictionary[j];
				for (int k = 0; k < list.Count; k++)
				{
					zero += list[k];
				}
				zero.Normalize();
				array[j] = zero;
			}
			return array;
		}
	}
	public static class Misc
	{
		public static T OrIfNull<T>(this T objA, T objB) where T : UnityEngine.Object
		{
			if (!objA)
			{
				return objB;
			}
			return objA;
		}

		public static bool IsOneOf<T>(this T tThis, params T[] tParams) where T : class
		{
			foreach (T val in tParams)
			{
				if (tThis == val)
				{
					return true;
				}
			}
			return false;
		}

		public static void Swap<T>(ref T a, ref T b)
		{
			T val = a;
			a = b;
			b = val;
		}

		public static T PushTo<T>(this T lt, ref T rt)
		{
			T result = rt;
			rt = lt;
			return result;
		}

		public static bool IsIdentifier(this string str)
		{
			if (string.IsNullOrEmpty(str))
			{
				return false;
			}
			if (!char.IsLetter(str[0]) && str[0] != '_')
			{
				return false;
			}
			for (int i = 1; i < str.Length; i++)
			{
				if (!char.IsLetterOrDigit(str[i]) && str[i] != '_')
				{
					return false;
				}
			}
			return true;
		}

		public static void CopyTo(this Stream input, Stream output, byte[] buffer)
		{
			int count;
			while ((count = input.Read(buffer, 0, buffer.Length)) > 0)
			{
				output.Write(buffer, 0, count);
			}
		}

		public static void MeshDeepCopy(Mesh destMesh, Mesh srcMesh)
		{
			destMesh.name = srcMesh.name;
			destMesh.Clear();
			destMesh.vertices = srcMesh.vertices;
			destMesh.normals = srcMesh.normals;
			destMesh.tangents = srcMesh.tangents;
			destMesh.uv = srcMesh.uv;
			destMesh.uv2 = srcMesh.uv2;
			destMesh.uv3 = srcMesh.uv3;
			destMesh.uv4 = srcMesh.uv4;
			destMesh.colors = srcMesh.colors;
			destMesh.colors32 = srcMesh.colors32;
			destMesh.triangles = srcMesh.triangles;
			destMesh.boneWeights = srcMesh.boneWeights;
			destMesh.bounds = srcMesh.bounds;
		}

		public static Mesh AllocateLightmappedMesh(Mesh srcMesh, Vector4 lightmapScaleOffset)
		{
			Mesh mesh = new Mesh();
			mesh.name = "LM_" + srcMesh.name;
			mesh.vertices = srcMesh.vertices;
			mesh.triangles = srcMesh.triangles;
			mesh.uv = srcMesh.uv;
			mesh.normals = srcMesh.normals;
			mesh.colors = srcMesh.colors;
			mesh.tangents = srcMesh.tangents;
			Vector2[] uv = srcMesh.uv2;
			if (uv == null || uv.Length == 0)
			{
				UnityEngine.Debug.LogWarning("'" + srcMesh.name + "' has no UV2's!", srcMesh);
				return mesh;
			}
			for (int i = 0; i < uv.Length; i++)
			{
				uv[i].x = uv[i].x * lightmapScaleOffset.x + lightmapScaleOffset.z;
				uv[i].y = uv[i].y * lightmapScaleOffset.y + lightmapScaleOffset.w;
			}
			mesh.uv2 = uv;
			return mesh;
		}

		public static void TryMakeFTPFolder(string url)
		{
			Stream stream = null;
			FtpWebResponse ftpWebResponse = null;
			try
			{
				FtpWebRequest obj = (FtpWebRequest)WebRequest.Create(url);
				obj.ReadWriteTimeout = 1000;
				obj.Credentials = new NetworkCredential("anonymous", "");
				obj.Method = "MKD";
				obj.UseBinary = true;
				ftpWebResponse = (FtpWebResponse)obj.GetResponse();
				stream = ftpWebResponse.GetResponseStream();
				stream.Close();
				stream = null;
				ftpWebResponse.Close();
				ftpWebResponse = null;
			}
			catch (WebException ex)
			{
				ex.Message.Contains("already exists");
			}
			catch (Exception ex2)
			{
				stream?.Close();
				ftpWebResponse?.Close();
				throw ex2;
			}
		}

		public static void TryCopyLocalFileToFTP(string path, string url)
		{
			Stream stream = null;
			FtpWebResponse ftpWebResponse = null;
			try
			{
				byte[] array = File.ReadAllBytes(path);
				FtpWebRequest obj = (FtpWebRequest)WebRequest.Create(url);
				obj.ReadWriteTimeout = 1000;
				obj.Credentials = new NetworkCredential("anonymous", "");
				obj.Method = "STOR";
				obj.ContentLength = array.Length;
				stream = obj.GetRequestStream();
				stream.Write(array, 0, array.Length);
				stream.Close();
				stream = null;
				ftpWebResponse = (FtpWebResponse)obj.GetResponse();
				ftpWebResponse.Close();
				ftpWebResponse = null;
			}
			catch (Exception ex)
			{
				stream?.Close();
				ftpWebResponse?.Close();
				throw ex;
			}
		}

		public static string ExtractStreamingAssetsToDataPath(string filepathInStreamingAssets)
		{
			string url = string.Concat("jar:file://" + UnityEngine.Application.dataPath + "!/assets", "/", filepathInStreamingAssets);
			string text = UnityEngine.Application.persistentDataPath + "/" + filepathInStreamingAssets;
			Directory.CreateDirectory(Path.GetDirectoryName(text));
			if (File.Exists(text))
			{
				File.Delete(text);
			}
			WWW wWW = new WWW(url);
			while (!wWW.isDone)
			{
			}
			UnityEngine.Debug.Log("Android unpacked jar path: " + text);
			File.WriteAllBytes(text, wWW.bytes);
			return text;
		}

		public static Transform FindDeepChild(this Transform aParent, string aName)
		{
			Transform transform = aParent.Find(aName);
			if (transform != null)
			{
				return transform;
			}
			for (int i = 0; i < aParent.childCount; i++)
			{
				transform = aParent.GetChild(i).FindDeepChild(aName);
				if (transform != null)
				{
					return transform;
				}
			}
			return null;
		}
	}
	public static class Wrapper
	{
		public static Wrapper<T> Around<T>(T valIn = default(T))
		{
			return new Wrapper<T>(valIn);
		}
	}
	[Serializable]
	public class Wrapper<T>
	{
		public T val;

		public Wrapper(T valIn)
		{
			val = valIn;
		}

		public static explicit operator T(Wrapper<T> wrapper)
		{
			return wrapper.val;
		}

		public override string ToString()
		{
			if (val == null)
			{
				return "null";
			}
			return val.ToString();
		}
	}
	public static class CLArguments
	{
		public static Dictionary<string, List<string>> _commandLineArgs;

		public static Dictionary<string, List<string>> commandLineArgs
		{
			get
			{
				if (_commandLineArgs == null)
				{
					_commandLineArgs = new Dictionary<string, List<string>>();
					string[] array = Environment.GetCommandLineArgs();
					for (int i = 0; i < array.Length; i++)
					{
						if (array[i].StartsWith("-"))
						{
							string key = array[i].Substring(1);
							string item = ((i < array.Length - 1 && !array[i + 1].StartsWith("-")) ? array[i + 1] : null);
							if (_commandLineArgs.TryGetValue(key, out var value))
							{
								value.Add(item);
								continue;
							}
							value = new List<string>();
							value.Add(item);
							_commandLineArgs.Add(key, value);
						}
					}
				}
				return _commandLineArgs;
			}
		}

		public static string GetArgument(string keyname, string defaultValue)
		{
			if (!commandLineArgs.TryGetValue(keyname, out var value))
			{
				return defaultValue;
			}
			return value[0];
		}

		public static string[] GetArgumentsOrNull(string keyname)
		{
			if (!commandLineArgs.TryGetValue(keyname, out var value))
			{
				return null;
			}
			return value.ToArray();
		}

		public static bool GetArgumentExists(string keyname)
		{
			return commandLineArgs.ContainsKey(keyname);
		}

		public static int GetIntArgument(string keyname, int defaultValue)
		{
			int result = defaultValue;
			if (commandLineArgs.TryGetValue(keyname, out var value))
			{
				result = int.Parse(value[0]);
			}
			return result;
		}

		public static T FirstOrDefault<T>(this IEnumerable<T> source, Func<T, bool> predicate, T defaultVal)
		{
			foreach (T item in source)
			{
				if (predicate(item))
				{
					return item;
				}
			}
			return defaultVal;
		}

		public static string Truncate(this string str, int maxLen)
		{
			if (str.Length > maxLen)
			{
				return str.Substring(0, maxLen);
			}
			return str;
		}
	}
	public struct StackedBool
	{
		private int count;

		public bool Value
		{
			get
			{
				return count == 0;
			}
			set
			{
				count += ((!value) ? 1 : (-1));
				count = Mathf.Max(count, 0);
			}
		}

		public void Reset()
		{
			count = 0;
		}
	}
	public static class Paths
	{
		[ThreadStatic]
		private static StringBuilder builder;

		public static void Init(int capacity = 256, int maxCapacity = 4096, bool overwrite = false)
		{
			if (builder == null || overwrite)
			{
				builder = new StringBuilder(capacity, maxCapacity);
			}
		}

		public static void Cleanup()
		{
			builder = null;
		}

		public static string Make(string seg1, string seg2, string seg3 = null, string seg4 = null, string seg5 = null, string seg6 = null, string seg7 = null)
		{
			Init();
			AppendSegment(seg1, seg2);
			AppendSegment(seg2, seg3);
			AppendSegment(seg3, seg4);
			AppendSegment(seg4, seg5);
			AppendSegment(seg5, seg6);
			AppendSegment(seg6, appendSeparator: false);
			return FinishMake();
		}

		public static string Make<T>(IEnumerable<T> segs)
		{
			Init();
			IEnumerator<T> enumerator = segs.GetEnumerator();
			bool flag = enumerator.MoveNext();
			while (flag)
			{
				T current = enumerator.Current;
				flag = enumerator.MoveNext();
				T current2 = enumerator.Current;
				AppendSegment(current.ToString(), flag && !string.IsNullOrEmpty(current2.ToString()));
			}
			return FinishMake();
		}

		public static string Make<T>(IList<T> segs)
		{
			Init();
			int num = -1;
			int count = segs.Count;
			int num2 = count - 1;
			while (++num < count)
			{
				AppendSegment(segs[num].ToString(), num < num2 && !string.IsNullOrEmpty(segs[num + 1].ToString()));
			}
			return FinishMake();
		}

		public static string ToAltPath(this string path)
		{
			return path.Replace(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
		}

		public static string GetScenePath(this GameObject gameObject, bool includeSelf = true)
		{
			if (gameObject == null)
			{
				return null;
			}
			Init();
			if (includeSelf)
			{
				PrependSegment(gameObject.transform);
			}
			else
			{
				if (gameObject.transform.parent == null)
				{
					return null;
				}
				PrependSegment(gameObject.transform.parent);
			}
			return FinishMake();
		}

		public static string GetAnimationPath(this GameObject gameObject)
		{
			Transform transform = gameObject.transform;
			string text;
			if (transform.GetComponent<Animation>() != null)
			{
				text = "/";
			}
			else
			{
				text = transform.name;
				transform = transform.parent;
				while (transform != null && transform.GetComponent<Animation>() == null)
				{
					text = transform.name + "/" + text;
					transform = transform.parent;
				}
			}
			return text;
		}

		public static List<string> GetFilesInDirectoryWithFilter(string dir, string filter)
		{
			List<string> list = new List<string>();
			list.AddRange(Directory.GetFiles(dir, filter));
			string[] directories = Directory.GetDirectories(dir);
			foreach (string dir2 in directories)
			{
				list.AddRange(GetFilesInDirectoryWithFilter(dir2, filter));
			}
			return list;
		}

		private static void AppendSegment(string segment, bool appendSeparator = true)
		{
			if (!string.IsNullOrEmpty(segment))
			{
				int capacity = builder.Capacity;
				builder.Append(segment);
				if (appendSeparator)
				{
					builder.Append(Path.AltDirectorySeparatorChar);
				}
				if (builder.Capacity != capacity)
				{
					UnityEngine.Debug.LogWarningFormat("Coatsink.Common.Paths.builder had to increase its capacity from {0} to {1}.", capacity, builder.Capacity);
				}
			}
		}

		private static void AppendSegment(string segment, string nextSegment)
		{
			AppendSegment(segment, !string.IsNullOrEmpty(nextSegment));
		}

		private static void PrependSegment(Transform tform)
		{
			Transform parent = tform.parent;
			if (parent != null)
			{
				PrependSegment(parent);
			}
			builder.Append(Path.AltDirectorySeparatorChar);
			builder.Append(tform.name);
		}

		private static string FinishMake()
		{
			string result = builder.ToString();
			builder.Remove(0, builder.Length);
			return result;
		}
	}
	public class PooledEnumerable : IEnumerable
	{
		protected class Enumerator : IDisposable, IEnumerator
		{
			private readonly PooledEnumerable owner;

			public readonly IEnumerator enumerator;

			public bool retained;

			private static readonly object normalResetPoint = 0;

			private static readonly object prestepResetPoint = 1;

			object IEnumerator.Current => enumerator.Current;

			public Enumerator(PooledEnumerable owner)
			{
				this.owner = owner;
				enumerator = owner.enumerable.GetEnumerator();
			}

			protected Enumerator(PooledEnumerable owner, IEnumerator enumerator)
			{
				this.owner = owner;
				this.enumerator = enumerator;
			}

			bool IEnumerator.MoveNext()
			{
				return enumerator.MoveNext();
			}

			public void Reset()
			{
				enumerator.Reset();
			}

			protected virtual void Dispose(bool disposing)
			{
				if (retained && disposing)
				{
					owner.ReleaseFrame(this);
				}
			}

			void IDisposable.Dispose()
			{
				Dispose(disposing: true);
			}
		}

		private readonly ResettableEnumerable enumerable;

		protected readonly bool preallocate;

		private Enumerator[] enumerators;

		public PooledEnumerable(IEnumerable enumerable, int cap = 1, bool preallocate = true)
		{
			this.enumerable = enumerable.GetResettable();
			this.preallocate = preallocate;
			enumerators = new Enumerator[cap];
			if (preallocate)
			{
				for (int i = 0; i < cap; i++)
				{
					enumerators[i] = new Enumerator(this);
				}
			}
		}

		protected PooledEnumerable(IEnumerable enumerable, bool preallocate = true)
		{
			this.enumerable = enumerable.GetResettable();
			this.preallocate = preallocate;
		}

		public IEnumerator GetEnumerator()
		{
			return GetEnumerator(RetainEnumerator());
		}

		protected int RetainEnumerator()
		{
			int num = 0;
			int enumeratorsCount = GetEnumeratorsCount();
			Enumerator enumerator;
			while (true)
			{
				if (num < enumeratorsCount)
				{
					enumerator = GetEnumerator(num);
					if (enumerator == null)
					{
						enumerator = CreateEnumerator(num);
						break;
					}
					if (!enumerator.retained)
					{
						break;
					}
					num++;
					continue;
				}
				ExpandPool(enumeratorsCount = Mathf.CeilToInt((float)enumeratorsCount * 1.5f));
				enumerator = CreateEnumerator(num);
				if (preallocate)
				{
					for (int i = num + 1; i < enumeratorsCount; i++)
					{
						CreateEnumerator(i);
					}
				}
				break;
			}
			enumerator.retained = true;
			return num;
		}

		protected virtual int GetEnumeratorsCount()
		{
			return enumerators.Length;
		}

		protected virtual Enumerator GetEnumerator(int i)
		{
			return enumerators[i];
		}

		protected virtual Enumerator CreateEnumerator(int i)
		{
			return enumerators[i] = new Enumerator(this);
		}

		protected virtual void ExpandPool(int newSize)
		{
			Array.Resize(ref enumerators, newSize);
		}

		private void ReleaseFrame(Enumerator frame)
		{
			enumerable.Reset(frame.enumerator);
			frame.retained = false;
		}
	}
	public class PooledEnumerable<T> : PooledEnumerable, IEnumerable<T>, IEnumerable
	{
		protected new class Enumerator : PooledEnumerable.Enumerator, IDisposable, IEnumerator<T>, IEnumerator
		{
			public new readonly IEnumerator<T> enumerator;

			T IEnumerator<T>.Current => enumerator.Current;

			public Enumerator(PooledEnumerable<T> owner, IEnumerator<T> enumerator = null)
				: base(owner, enumerator = owner.enumerable.GetEnumerator())
			{
				this.enumerator = enumerator;
			}
		}

		private readonly ResettableEnumerable<T> enumerable;

		private Enumerator[] enumerators;

		public PooledEnumerable(IEnumerable<T> enumerable, int cap = 1, bool preallocate = true)
			: base(enumerable = enumerable.GetResettable(), preallocate)
		{
			this.enumerable = enumerable.GetResettable();
			enumerators = new Enumerator[cap];
			if (preallocate)
			{
				for (int i = 0; i < cap; i++)
				{
					enumerators[i] = new Enumerator(this);
				}
			}
		}

		public new IEnumerator<T> GetEnumerator()
		{
			return enumerators[RetainEnumerator()];
		}

		protected override int GetEnumeratorsCount()
		{
			return enumerators.Length;
		}

		protected override PooledEnumerable.Enumerator GetEnumerator(int i)
		{
			return enumerators[i];
		}

		protected override PooledEnumerable.Enumerator CreateEnumerator(int i)
		{
			return enumerators[i] = new Enumerator(this);
		}

		protected override void ExpandPool(int newSize)
		{
			Array.Resize(ref enumerators, newSize);
		}
	}
	public class PresteppedEnumerable : IEnumerable
	{
		private readonly IEnumerable enumerable;

		public PresteppedEnumerable(IEnumerable enumerable)
		{
			this.enumerable = enumerable;
		}

		public IEnumerator GetEnumerator()
		{
			IEnumerator enumerator = enumerable.GetEnumerator();
			enumerator.MoveNext();
			return enumerator;
		}
	}
	public class PresteppedEnumerable<T> : PresteppedEnumerable, IEnumerable<T>, IEnumerable
	{
		private readonly IEnumerable<T> enumerable;

		public PresteppedEnumerable(IEnumerable<T> enumerable)
			: base(enumerable)
		{
			this.enumerable = enumerable;
		}

		public new IEnumerator<T> GetEnumerator()
		{
			IEnumerator<T> enumerator = enumerable.GetEnumerator();
			enumerator.MoveNext();
			return enumerator;
		}
	}
	[StructLayout(LayoutKind.Explicit)]
	public struct primitive : IConvertible
	{
		[FieldOffset(0)]
		public bool @bool;

		[FieldOffset(0)]
		public char @char;

		[FieldOffset(0)]
		public byte @byte;

		[FieldOffset(0)]
		public ushort @ushort;

		[FieldOffset(0)]
		public uint @uint;

		[FieldOffset(0)]
		public ulong @ulong;

		[FieldOffset(0)]
		public sbyte @sbyte;

		[FieldOffset(0)]
		public short @short;

		[FieldOffset(0)]
		public int @int;

		[FieldOffset(0)]
		public long @long;

		[FieldOffset(0)]
		public float @float;

		[FieldOffset(0)]
		public double @double;

		[FieldOffset(0)]
		public bool bool0;

		[FieldOffset(1)]
		public bool bool1;

		[FieldOffset(2)]
		public bool bool2;

		[FieldOffset(3)]
		public bool bool3;

		[FieldOffset(4)]
		public bool bool4;

		[FieldOffset(5)]
		public bool bool5;

		[FieldOffset(6)]
		public bool bool6;

		[FieldOffset(7)]
		public bool bool7;

		[FieldOffset(0)]
		public byte byte0;

		[FieldOffset(1)]
		public byte byte1;

		[FieldOffset(2)]
		public byte byte2;

		[FieldOffset(3)]
		public byte byte3;

		[FieldOffset(4)]
		public byte byte4;

		[FieldOffset(5)]
		public byte byte5;

		[FieldOffset(6)]
		public byte byte6;

		[FieldOffset(7)]
		public byte byte7;

		[FieldOffset(0)]
		public sbyte sbyte0;

		[FieldOffset(1)]
		public sbyte sbyte1;

		[FieldOffset(2)]
		public sbyte sbyte2;

		[FieldOffset(3)]
		public sbyte sbyte3;

		[FieldOffset(4)]
		public sbyte sbyte4;

		[FieldOffset(5)]
		public sbyte sbyte5;

		[FieldOffset(6)]
		public sbyte sbyte6;

		[FieldOffset(7)]
		public sbyte sbyte7;

		[FieldOffset(0)]
		public int int0;

		[FieldOffset(4)]
		public int int1;

		[FieldOffset(0)]
		public float float0;

		[FieldOffset(4)]
		public float float1;

		public primitive(bool val)
		{
			this = default(primitive);
			@bool = val;
		}

		public primitive(char val)
		{
			this = default(primitive);
			@char = val;
		}

		public primitive(byte val)
		{
			this = default(primitive);
			@byte = val;
		}

		public primitive(ushort val)
		{
			this = default(primitive);
			@ushort = val;
		}

		public primitive(uint val)
		{
			this = default(primitive);
			@uint = val;
		}

		public primitive(ulong val)
		{
			this = default(primitive);
			@ulong = val;
		}

		public primitive(sbyte val)
		{
			this = default(primitive);
			@sbyte = val;
		}

		public primitive(short val)
		{
			this = default(primitive);
			@short = val;
		}

		public primitive(int val)
		{
			this = default(primitive);
			@int = val;
		}

		public primitive(long val)
		{
			this = default(primitive);
			@long = val;
		}

		public primitive(float val)
		{
			this = default(primitive);
			@float = val;
		}

		public primitive(double val)
		{
			this = default(primitive);
			@double = val;
		}

		public primitive(DateTime val)
		{
			this = default(primitive);
			@long = val.ToBinary();
		}

		public primitive(IntPtr val)
		{
			this = default(primitive);
			if (IntPtr.Size == 4)
			{
				@int = val.ToInt32();
			}
			else
			{
				@long = val.ToInt64();
			}
		}

		public primitive(UIntPtr val)
		{
			this = default(primitive);
			if (UIntPtr.Size == 4)
			{
				@uint = val.ToUInt32();
			}
			else
			{
				@ulong = val.ToUInt64();
			}
		}

		public primitive(decimal val)
		{
			this = default(primitive);
			@double = (double)val;
		}

		public primitive(int val0, int val1)
		{
			this = default(primitive);
			int0 = val0;
			int1 = val1;
		}

		public primitive(object obj)
			: this(obj, Convert.GetTypeCode(obj))
		{
		}

		public primitive(object obj, TypeCode code)
		{
			this = default(primitive);
			switch (code)
			{
			case TypeCode.Boolean:
				@bool = (bool)obj;
				break;
			case TypeCode.Char:
				@char = (char)obj;
				break;
			case TypeCode.Byte:
				@byte = (byte)obj;
				break;
			case TypeCode.UInt16:
				@ushort = (ushort)obj;
				break;
			case TypeCode.UInt32:
				@uint = (uint)obj;
				break;
			case TypeCode.UInt64:
				@ulong = (ulong)obj;
				break;
			case TypeCode.SByte:
				@sbyte = (sbyte)obj;
				break;
			case TypeCode.Int16:
				@short = (short)obj;
				break;
			case TypeCode.Int32:
				@int = (int)obj;
				break;
			case TypeCode.Int64:
				@long = (long)obj;
				break;
			case TypeCode.Single:
				@float = (float)obj;
				break;
			case TypeCode.Double:
				@double = (double)obj;
				break;
			case TypeCode.DateTime:
				@long = ((DateTime)obj).ToBinary();
				break;
			case TypeCode.Decimal:
				break;
			}
		}

		public static implicit operator primitive(bool val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(char val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(byte val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(ushort val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(uint val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(ulong val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(sbyte val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(short val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(int val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(long val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(float val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(double val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(DateTime val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(IntPtr val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(UIntPtr val)
		{
			return new primitive(val);
		}

		public static implicit operator primitive(decimal val)
		{
			return new primitive(val);
		}

		public static implicit operator bool(primitive prim)
		{
			return prim.@bool;
		}

		public static implicit operator char(primitive prim)
		{
			return prim.@char;
		}

		public static implicit operator byte(primitive prim)
		{
			return prim.@byte;
		}

		public static implicit operator ushort(primitive prim)
		{
			return prim.@ushort;
		}

		public static implicit operator uint(primitive prim)
		{
			return prim.@uint;
		}

		public static implicit operator ulong(primitive prim)
		{
			return prim.@ulong;
		}

		public static implicit operator sbyte(primitive prim)
		{
			return prim.@sbyte;
		}

		public static implicit operator short(primitive prim)
		{
			return prim.@short;
		}

		public static implicit operator int(primitive prim)
		{
			return prim.@int;
		}

		public static implicit operator long(primitive prim)
		{
			return prim.@long;
		}

		public static implicit operator float(primitive prim)
		{
			return prim.@float;
		}

		public static implicit operator double(primitive prim)
		{
			return prim.@double;
		}

		public static implicit operator DateTime(primitive prim)
		{
			return DateTime.FromBinary(prim.@long);
		}

		public static implicit operator IntPtr(primitive prim)
		{
			if (IntPtr.Size != 4)
			{
				return new IntPtr(prim.@long);
			}
			return new IntPtr(prim.@int);
		}

		public static implicit operator UIntPtr(primitive prim)
		{
			if (UIntPtr.Size != 4)
			{
				return new UIntPtr(prim.@ulong);
			}
			return new UIntPtr(prim.@uint);
		}

		public static implicit operator decimal(primitive prim)
		{
			return new decimal(prim.@double);
		}

		public string ToString(TypeCode code)
		{
			return code switch
			{
				TypeCode.Boolean => @bool.ToString(), 
				TypeCode.Char => @char.ToString(), 
				TypeCode.Byte => @byte.ToString(), 
				TypeCode.UInt16 => @ushort.ToString(), 
				TypeCode.UInt32 => @uint.ToString(), 
				TypeCode.UInt64 => @ulong.ToString(), 
				TypeCode.SByte => @sbyte.ToString(), 
				TypeCode.Int16 => @short.ToString(), 
				TypeCode.Int32 => @int.ToString(), 
				TypeCode.Int64 => @long.ToString(), 
				TypeCode.Single => @float.ToString(), 
				TypeCode.Double => @double.ToString(), 
				TypeCode.DateTime => DateTime.FromBinary(@long).ToString(), 
				_ => null, 
			};
		}

		public string ToString(TypeCode code, string format)
		{
			return code switch
			{
				TypeCode.Boolean => @bool.ToString(), 
				TypeCode.Char => @char.ToString(), 
				TypeCode.Byte => @byte.ToString(format), 
				TypeCode.UInt16 => @ushort.ToString(format), 
				TypeCode.UInt32 => @uint.ToString(format), 
				TypeCode.UInt64 => @ulong.ToString(format), 
				TypeCode.SByte => @sbyte.ToString(format), 
				TypeCode.Int16 => @short.ToString(format), 
				TypeCode.Int32 => @int.ToString(format), 
				TypeCode.Int64 => @long.ToString(format), 
				TypeCode.Single => @float.ToString(format), 
				TypeCode.Double => @double.ToString(format), 
				TypeCode.DateTime => DateTime.FromBinary(@long).ToString(format), 
				_ => null, 
			};
		}

		public object Get(TypeCode code)
		{
			return code switch
			{
				TypeCode.Boolean => @bool, 
				TypeCode.Char => @char, 
				TypeCode.Byte => @byte, 
				TypeCode.UInt16 => @ushort, 
				TypeCode.UInt32 => @uint, 
				TypeCode.UInt64 => @ulong, 
				TypeCode.SByte => @sbyte, 
				TypeCode.Int16 => @short, 
				TypeCode.Int32 => @int, 
				TypeCode.Int64 => @long, 
				TypeCode.Single => @float, 
				TypeCode.Double => @double, 
				TypeCode.DateTime => DateTime.FromBinary(@long), 
				_ => null, 
			};
		}

		public byte GetByte(int i)
		{
			return i switch
			{
				0 => byte0, 
				1 => byte1, 
				2 => byte2, 
				3 => byte3, 
				4 => byte4, 
				5 => byte5, 
				6 => byte6, 
				7 => byte7, 
				_ => throw new IndexOutOfRangeException(), 
			};
		}

		public void SetByte(int i, byte val)
		{
			switch (i)
			{
			case 0:
				byte0 = val;
				break;
			case 1:
				byte1 = val;
				break;
			case 2:
				byte2 = val;
				break;
			case 3:
				byte3 = val;
				break;
			case 4:
				byte4 = val;
				break;
			case 5:
				byte5 = val;
				break;
			case 6:
				byte6 = val;
				break;
			case 7:
				byte7 = val;
				break;
			default:
				throw new IndexOutOfRangeException();
			}
		}

		public sbyte GetSByte(int i)
		{
			return i switch
			{
				0 => sbyte0, 
				1 => sbyte1, 
				2 => sbyte2, 
				3 => sbyte3, 
				4 => sbyte4, 
				5 => sbyte5, 
				6 => sbyte6, 
				7 => sbyte7, 
				_ => throw new IndexOutOfRangeException(), 
			};
		}

		public void SetSByte(int i, sbyte val)
		{
			switch (i)
			{
			case 0:
				sbyte0 = val;
				break;
			case 1:
				sbyte1 = val;
				break;
			case 2:
				sbyte2 = val;
				break;
			case 3:
				sbyte3 = val;
				break;
			case 4:
				sbyte4 = val;
				break;
			case 5:
				sbyte5 = val;
				break;
			case 6:
				sbyte6 = val;
				break;
			case 7:
				sbyte7 = val;
				break;
			default:
				throw new IndexOutOfRangeException();
			}
		}

		public static bool operator ==(primitive left, primitive right)
		{
			return left.@long == right.@long;
		}

		public static bool operator !=(primitive left, primitive right)
		{
			return left.@long != right.@long;
		}

		public override bool Equals(object obj)
		{
			return base.Equals(obj);
		}

		public override int GetHashCode()
		{
			return @int;
		}

		public TypeCode GetTypeCode()
		{
			throw new NotImplementedException();
		}

		public bool ToBoolean(IFormatProvider provider)
		{
			return @bool;
		}

		public byte ToByte(IFormatProvider provider)
		{
			return @byte;
		}

		public char ToChar(IFormatProvider provider)
		{
			return @char;
		}

		public DateTime ToDateTime(IFormatProvider provider)
		{
			return this;
		}

		public decimal ToDecimal(IFormatProvider provider)
		{
			return this;
		}

		public double ToDouble(IFormatProvider provider)
		{
			return @double;
		}

		public short ToInt16(IFormatProvider provider)
		{
			return @short;
		}

		public int ToInt32(IFormatProvider provider)
		{
			return @int;
		}

		public long ToInt64(IFormatProvider provider)
		{
			return @long;
		}

		public sbyte ToSByte(IFormatProvider provider)
		{
			return @sbyte;
		}

		public float ToSingle(IFormatProvider provider)
		{
			return @float;
		}

		public string ToString(IFormatProvider provider)
		{
			throw new NotImplementedException();
		}

		public object ToType(Type conversionType, IFormatProvider provider)
		{
			throw new NotImplementedException();
		}

		public ushort ToUInt16(IFormatProvider provider)
		{
			return @ushort;
		}

		public uint ToUInt32(IFormatProvider provider)
		{
			return @uint;
		}

		public ulong ToUInt64(IFormatProvider provider)
		{
			return @ulong;
		}
	}
	public static class PrimitiveExtensions
	{
		public static Type GetCodedType(this TypeCode code)
		{
			return code switch
			{
				TypeCode.Boolean => typeof(bool), 
				TypeCode.Char => typeof(char), 
				TypeCode.Byte => typeof(byte), 
				TypeCode.UInt16 => typeof(ushort), 
				TypeCode.UInt32 => typeof(uint), 
				TypeCode.UInt64 => typeof(ulong), 
				TypeCode.SByte => typeof(sbyte), 
				TypeCode.Int16 => typeof(short), 
				TypeCode.Int32 => typeof(int), 
				TypeCode.Int64 => typeof(long), 
				TypeCode.Single => typeof(float), 
				TypeCode.Double => typeof(double), 
				TypeCode.DateTime => typeof(DateTime), 
				TypeCode.String => typeof(string), 
				_ => null, 
			};
		}
	}
	public struct oprimitive
	{
		public readonly TypeCode type;

		public readonly primitive prim;

		public readonly object obj;

		public oprimitive(bool val)
			: this(TypeCode.Boolean, val)
		{
		}

		public oprimitive(char val)
			: this(TypeCode.Char, val)
		{
		}

		public oprimitive(byte val)
			: this(TypeCode.Byte, val)
		{
		}

		public oprimitive(ushort val)
			: this(TypeCode.UInt16, val)
		{
		}

		public oprimitive(uint val)
			: this(TypeCode.UInt32, val)
		{
		}

		public oprimitive(ulong val)
			: this(TypeCode.UInt64, val)
		{
		}

		public oprimitive(sbyte val)
			: this(TypeCode.SByte, val)
		{
		}

		public oprimitive(short val)
			: this(TypeCode.Int16, val)
		{
		}

		public oprimitive(int val)
			: this(TypeCode.Int32, val)
		{
		}

		public oprimitive(long val)
			: this(TypeCode.Int64, val)
		{
		}

		public oprimitive(float val)
			: this(TypeCode.Single, val)
		{
		}

		public oprimitive(double val)
			: this(TypeCode.Double, val)
		{
		}

		public oprimitive(DateTime val)
			: this(TypeCode.DateTime, val)
		{
		}

		public oprimitive(string str)
		{
			if (str != null)
			{
				type = TypeCode.String;
				prim = str.Length;
			}
			else
			{
				type = TypeCode.Empty;
				prim = 0;
			}
			obj = str;
		}

		public oprimitive(TypeCode type, primitive prim)
		{
			this.type = type;
			this.prim = prim;
			obj = null;
		}

		public oprimitive(object obj)
		{
			type = Convert.GetTypeCode(obj);
			prim = new primitive(obj);
			this.obj = obj;
		}

		public static implicit operator oprimitive(bool val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(char val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(byte val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(ushort val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(uint val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(ulong val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(sbyte val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(short val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(int val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(long val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(float val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(double val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(DateTime val)
		{
			return new oprimitive(val);
		}

		public static implicit operator oprimitive(string val)
		{
			return new oprimitive((val != null) ? val : null);
		}

		public static implicit operator bool(oprimitive sprim)
		{
			return sprim.prim.@bool;
		}

		public static implicit operator char(oprimitive sprim)
		{
			return sprim.prim.@char;
		}

		public static implicit operator byte(oprimitive sprim)
		{
			return sprim.prim.@byte;
		}

		public static implicit operator ushort(oprimitive sprim)
		{
			return sprim.prim.@ushort;
		}

		public static implicit operator uint(oprimitive sprim)
		{
			return sprim.prim.@uint;
		}

		public static implicit operator ulong(oprimitive sprim)
		{
			return sprim.prim.@ulong;
		}

		public static implicit operator sbyte(oprimitive sprim)
		{
			return sprim.prim.@sbyte;
		}

		public static implicit operator short(oprimitive sprim)
		{
			return sprim.prim.@short;
		}

		public static implicit operator int(oprimitive sprim)
		{
			return sprim.prim.@int;
		}

		public static implicit operator long(oprimitive sprim)
		{
			return sprim.prim.@long;
		}

		public static implicit operator float(oprimitive sprim)
		{
			return sprim.prim.@float;
		}

		public static implicit operator double(oprimitive sprim)
		{
			return sprim.prim.@double;
		}

		public static implicit operator DateTime(oprimitive sprim)
		{
			return DateTime.FromBinary(sprim.prim.@long);
		}

		public static implicit operator string(oprimitive sprim)
		{
			return sprim.ToString();
		}

		public override string ToString()
		{
			if (type == TypeCode.String)
			{
				return (string)obj;
			}
			return prim.ToString(type);
		}

		public object Get()
		{
			switch (type)
			{
			case TypeCode.Object:
			case TypeCode.String:
				return obj;
			case TypeCode.Empty:
				return null;
			default:
				return prim.Get(type);
			}
		}

		public static bool operator ==(oprimitive left, oprimitive right)
		{
			if (left.type != right.type)
			{
				return false;
			}
			if (left.prim != right.prim)
			{
				return false;
			}
			if (left.obj != right.obj)
			{
				return false;
			}
			return true;
		}

		public static bool operator !=(oprimitive left, oprimitive right)
		{
			if (left.type != right.type)
			{
				return true;
			}
			if (left.prim != right.prim)
			{
				return true;
			}
			if (left.obj != right.obj)
			{
				return true;
			}
			return false;
		}

		public override bool Equals(object obj)
		{
			return base.Equals(obj);
		}

		public override int GetHashCode()
		{
			if (type != TypeCode.Object && type != TypeCode.String)
			{
				return prim.@long.GetHashCode();
			}
			if (obj == null)
			{
				return 0;
			}
			return obj.GetHashCode();
		}
	}
	public static class Extensions
	{
		public static bool TryWrite(this BinaryWriter writer, TypeCode code, primitive pr)
		{
			switch (code)
			{
			case TypeCode.Boolean:
				writer.Write(pr.@bool);
				return true;
			case TypeCode.Char:
				writer.Write(pr.@char);
				return true;
			case TypeCode.Byte:
				writer.Write(pr.@byte);
				return true;
			case TypeCode.UInt16:
				writer.Write(pr.@ushort);
				return true;
			case TypeCode.UInt32:
				writer.Write(pr.@uint);
				return true;
			case TypeCode.UInt64:
				writer.Write(pr.@ulong);
				return true;
			case TypeCode.SByte:
				writer.Write(pr.@sbyte);
				return true;
			case TypeCode.Int16:
				writer.Write(pr.@short);
				return true;
			case TypeCode.Int32:
				writer.Write(pr.@int);
				return true;
			case TypeCode.Int64:
				writer.Write(pr.@long);
				return true;
			case TypeCode.Single:
				writer.Write(pr.@float);
				return true;
			case TypeCode.Double:
				writer.Write(pr.@double);
				return true;
			case TypeCode.DateTime:
				writer.Write(pr.@long);
				return true;
			default:
				return false;
			}
		}

		public static bool TryRead(this BinaryReader reader, TypeCode code, ref primitive pr)
		{
			switch (code)
			{
			case TypeCode.Boolean:
				pr = reader.ReadBoolean();
				return true;
			case TypeCode.Char:
				pr = reader.ReadChar();
				return true;
			case TypeCode.Byte:
				pr = reader.ReadByte();
				return true;
			case TypeCode.UInt16:
				pr = reader.ReadUInt16();
				return true;
			case TypeCode.UInt32:
				pr = reader.ReadUInt32();
				return true;
			case TypeCode.UInt64:
				pr = reader.ReadUInt64();
				return true;
			case TypeCode.SByte:
				pr = reader.ReadSByte();
				return true;
			case TypeCode.Int16:
				pr = reader.ReadInt16();
				return true;
			case TypeCode.Int32:
				pr = reader.ReadInt32();
				return true;
			case TypeCode.Int64:
				pr = reader.ReadInt64();
				return true;
			case TypeCode.Single:
				pr = reader.ReadSingle();
				return true;
			case TypeCode.Double:
				pr = reader.ReadDouble();
				return true;
			case TypeCode.DateTime:
				pr = reader.ReadInt64();
				return true;
			default:
				return false;
			}
		}

		public static primitive ToPrim(this long val)
		{
			return new primitive(val);
		}
	}
	public static class ReflectionX
	{
		public static class CastTo<T>
		{
			private static class Cache<S>
			{
				public static readonly Func<S, T> caster = Get();

				private static Func<S, T> Get()
				{
					return ((Expression<Func<S, T>>)((S source) => (T)source)).Compile();
				}
			}

			public static T From<S>(S s)
			{
				return Cache<S>.caster(s);
			}
		}

		public struct OptionalFieldInfo
		{
			public Type type;

			public string name;

			public FieldInfo info;
		}

		public enum MemberX
		{
			InterfaceCount = 1,
			Interface = 2,
			FieldCount = 4,
			Field = 8,
			FieldName = 0x10,
			FieldType = 0x20,
			FieldReqModCount = 0x40,
			FieldReqMod = 0x80,
			FieldOptModCount = 0x100,
			FieldOptMod = 0x200,
			FieldAttribs = 0x400,
			PropertyCount = 0x800,
			Property = 0x1000,
			PropertyName = 0x2000,
			PropertyType = 0x4000,
			PropertyAttribs = 0x8000,
			MethodCount = 0x10000,
			Method = 0x20000,
			MethodName = 0x40000,
			MethodReturnType = 0x80000,
			MethodAttribs = 0x100000,
			MethodConventions = 0x200000,
			MethodParamCount = 0x400000,
			MethodParam = 0x800000
		}

		public struct MemberXInst
		{
			[StructLayout(LayoutKind.Explicit)]
			public struct Details
			{
				[FieldOffset(0)]
				public int token;

				[FieldOffset(0)]
				public int count;

				[FieldOffset(0)]
				public FieldAttributes fieldAttribs;

				[FieldOffset(0)]
				public PropertyAttributes propAttribs;

				[FieldOffset(0)]
				public MethodAttributes methodAttribs;

				[FieldOffset(0)]
				public CallingConventions conventions;
			}

			public MemberX mem;

			public string name;

			public Details details;

			public MemberInfo info;

			public MemberXInst(MemberX mem, MemberInfo info)
			{
				this = default(MemberXInst);
				this.mem = mem;
				details.token = ((info != null) ? info.MetadataToken : 0);
				this.info = info;
			}

			public MemberXInst(MemberX mem, int count)
			{
				this = default(MemberXInst);
				this.mem = mem;
				details.count = count;
			}

			public MemberXInst(MemberX mem, string name)
			{
				this = default(MemberXInst);
				this.mem = mem;
				this.name = name;
			}

			public MemberXInst(MemberX mem, FieldAttributes fieldAttribs)
			{
				this = default(MemberXInst);
				this.mem = mem;
				details.fieldAttribs = fieldAttribs;
			}

			public MemberXInst(MemberX mem, PropertyAttributes propAttribs)
			{
				this = default(MemberXInst);
				this.mem = mem;
				details.propAttribs = propAttribs;
			}

			public MemberXInst(MemberX mem, MethodAttributes methodAttribs)
			{
				this = default(MemberXInst);
				this.mem = mem;
				details.methodAttribs = methodAttribs;
			}

			public MemberXInst(MemberX mem, CallingConventions conventions)
			{
				this = default(MemberXInst);
				this.mem = mem;
				details.conventions = conventions;
			}
		}

		public enum OpX
		{
			None,
			Add,
			And,
			PushArgList,
			Box,
			Branch,
			Break,
			Call,
			Cast,
			Compare,
			ThrowOnInf,
			Constrain,
			Convert,
			CopyBlock,
			CopyValue,
			Div,
			Dupe,
			EndFilter,
			EndFinally,
			InitBlock,
			InitValue,
			IsInst,
			Jump,
			PushArg,
			PushValue,
			PushElement,
			PushField,
			PushNativeMethod,
			PushValueAtAddr,
			PushLength,
			PushLocal,
			PushNull,
			PushObject,
			PushStaticField,
			PushString,
			PushToken,
			PushNativeVirtMethod,
			LeaveProtRegion,
			PushByteAlloc,
			PushRef,
			Multiply,
			Negate,
			PushNewArray,
			PushNewObject,
			NoOp,
			Not,
			Or,
			Pop,
			ReadOnly,
			PushRefType,
			PushRefAddr,
			Remainder,
			Return,
			Rethrow,
			ShiftLeft,
			ShiftRight,
			PushSizeOf,
			ArgPush,
			SetElement,
			SetField,
			SetValueAtAddr,
			SetLocal,
			SetStaticField,
			Sub,
			Switch,
			TailCall,
			Throw,
			Unaligned,
			Unbox,
			Volatile,
			Xor,
			DeclareLocal,
			LabelCount,
			Label,
			Case,
			MarkLabel,
			EndSwitch
		}

		[Flags]
		public enum OpXFlags : long
		{
			None = 0L,
			ThrowOnOverFlow = 1L,
			FromUnsigned = 2L,
			FromSigned = 4L,
			IfEqual = 8L,
			IfGreater = 0x10L,
			IfLesser = 0x20L,
			IfUnequal = 0x40L,
			IfFalse = 0x80L,
			IfTrue = 0x100L,
			FromStack = 0x200L,
			Virtual = 0x400L,
			ToNativeInt = 0x800L,
			ToUnsigned = 0x1000L,
			ToInt8 = 0x2000L,
			ToInt16 = 0x4000L,
			ToInt32 = 0x8000L,
			ToInt64 = 0x10000L,
			ToFloat32 = 0x20000L,
			ToFloat64 = 0x40000L,
			ToAddress = 0x80000L,
			NonVirtual = 0x100000L,
			ToOwnType = 0x200000L,
			CM1 = 0x400000L,
			C0 = 0x800000L,
			C1 = 0x1000000L,
			C2 = 0x2000000L,
			C3 = 0x4000000L,
			C4 = 0x8000000L,
			C5 = 0x10000000L,
			C6 = 0x20000000L,
			C7 = 0x40000000L,
			C8 = 0x80000000L,
			Int8Arg = 0x100000000L,
			Int16Arg = 0x200000000L,
			Int32Arg = 0x400000000L,
			Int64Arg = 0x800000000L,
			FromNativeInt = 0x1000000000L,
			FromInt8 = 0x2000000000L,
			FromElement = 0x4000000000L,
			AllowOverflow = 0x8000000000L,
			FromArg = 0x10000000000L,
			FromAddress = 0x20000000000L,
			ToReference = 0x40000000000L,
			ToManagedPointer = 0x80000000000L,
			ToOtherType = 0x100000000000L,
			FromInt16 = 0x200000000000L,
			FromInt32 = 0x400000000000L,
			FromInt64 = 0x800000000000L,
			FromFloat32 = 0x1000000000000L,
			FromFloat64 = 0x2000000000000L,
			AtLeast = 0x4000000000000000L
		}

		public struct OpXFlagsPair
		{
			public OpX op;

			public OpXFlags flags;

			public static implicit operator OpXFlagsPair(OpX op)
			{
				return op.With(OpXFlags.AtLeast, OpXFlags.None);
			}

			public static bool operator ==(OpXFlagsPair l, OpXFlagsPair r)
			{
				if (l.op == r.op)
				{
					return l.flags == r.flags;
				}
				return false;
			}

			public static bool operator !=(OpXFlagsPair l, OpXFlagsPair r)
			{
				return !(l == r);
			}

			public override bool Equals(object obj)
			{
				if (!(obj is OpXFlagsPair opXFlagsPair))
				{
					return false;
				}
				return this == opXFlagsPair;
			}

			public override int GetHashCode()
			{
				return op.GetHashCode() | flags.GetHashCode();
			}
		}

		public class OpXID
		{
			public delegate void Emitter(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo);

			public readonly OpXFlagsPair id;

			public readonly int codeIdx;

			public readonly int opLength;

			public readonly int argLength;

			public readonly Emitter Emit;

			public OpXID(OpX op, OpXFlags flags = OpXFlags.None, int codeIdx = -1, int opLength = 0, int argLength = 0, Emitter Emit = null)
			{
				id.op = op;
				id.flags = flags;
				this.codeIdx = codeIdx;
				this.Emit = Emit;
			}

			public override string ToString()
			{
				return $"{id.op} ({id.flags})";
			}

			public override int GetHashCode()
			{
				return codeIdx;
			}
		}

		public struct OpXInst
		{
			public int index;

			public OpXID id;

			public primitive arg;

			public MemberInfo member;

			public OpXInst(OpXID id, int index, primitive arg = default(primitive), MemberInfo member = null)
			{
				this.index = index;
				this.id = id;
				this.arg = arg;
				this.member = member;
				index += id.opLength + id.argLength;
			}

			public override string ToString()
			{
				return arg.ToString();
			}
		}

		private struct PreID
		{
			public OpXFlagsPair pair;

			public OpCode code;

			public PreID(OpCode c, OpX o, OpXFlags f = OpXFlags.None)
			{
				pair = o.With(f, OpXFlags.None);
				code = c;
			}
		}

		[Serializable]
		[CompilerGenerated]
		private sealed class <>c
		{
			public static readonly <>c <>9 = new <>c();

			public static OpXID.Emitter <>9__89_0;

			public static OpXID.Emitter <>9__89_1;

			public static OpXID.Emitter <>9__89_2;

			public static OpXID.Emitter <>9__89_3;

			public static OpXID.Emitter <>9__89_4;

			public static OpXID.Emitter <>9__89_5;

			public static OpXID.Emitter <>9__89_6;

			public static OpXID.Emitter <>9__89_7;

			public static OpXID.Emitter <>9__89_8;

			public static OpXID.Emitter <>9__89_9;

			public static OpXID.Emitter <>9__89_10;

			public static OpXID.Emitter <>9__89_11;

			public static OpXID.Emitter <>9__89_12;

			public static OpXID.Emitter <>9__89_13;

			public static OpXID.Emitter <>9__89_14;

			public static OpXID.Emitter <>9__89_15;

			public static OpXID.Emitter <>9__89_16;

			internal void <RetainOpXPrecache>b__89_0(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(opCodes[oi.id.codeIdx]);
			}

			internal void <RetainOpXPrecache>b__89_1(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(opCodes[oi.id.codeIdx], oi.arg.@byte);
			}

			internal void <RetainOpXPrecache>b__89_2(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(opCodes[oi.id.codeIdx], oi.arg.@short);
			}

			internal void <RetainOpXPrecache>b__89_3(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(opCodes[oi.id.codeIdx], oi.arg.@int);
			}

			internal void <RetainOpXPrecache>b__89_4(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(opCodes[oi.id.codeIdx], oi.arg.@long);
			}

			internal void <RetainOpXPrecache>b__89_5(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(opCodes[oi.id.codeIdx], ls[oi.arg.@int]);
			}

			internal void <RetainOpXPrecache>b__89_6(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(opCodes[oi.id.codeIdx], ((MethodInfo)oi.member) ?? ((MethodInfo)mo.ResolveMethod(oi.arg.@int)));
			}

			internal void <RetainOpXPrecache>b__89_7(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(opCodes[oi.id.codeIdx], ((ConstructorInfo)oi.member) ?? ((ConstructorInfo)mo.ResolveMethod(oi.arg.@int)));
			}

			internal void <RetainOpXPrecache>b__89_8(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(opCodes[oi.id.codeIdx], ((FieldInfo)oi.member) ?? mo.ResolveField(oi.arg.@int));
			}

			internal void <RetainOpXPrecache>b__89_9(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(opCodes[oi.id.codeIdx], ((Type)oi.member) ?? mo.ResolveType(oi.arg.@int));
			}

			internal void <RetainOpXPrecache>b__89_10(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.DeclareLocal(((Type)oi.member) ?? mo.ResolveType(oi.arg.@int));
			}

			internal void <RetainOpXPrecache>b__89_11(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				ls = new Dictionary<int, Label>(oi.arg.@int);
			}

			internal void <RetainOpXPrecache>b__89_12(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				ls[oi.arg] = g.DefineLabel();
			}

			internal void <RetainOpXPrecache>b__89_13(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				ls = new Dictionary<int, Label>(oi.arg.@int);
			}

			internal void <RetainOpXPrecache>b__89_14(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				cs = new Label[oi.arg.@int];
			}

			internal void <RetainOpXPrecache>b__89_15(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				cs[oi.arg.int0] = ls[oi.arg.int1];
			}

			internal void <RetainOpXPrecache>b__89_16(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(OpCodes.Switch, cs);
				cs = null;
			}
		}

		public const OpXFlags argSizeFlags = OpXFlags.Int8Arg | OpXFlags.Int16Arg | OpXFlags.Int32Arg | OpXFlags.Int64Arg;

		public const OpXFlags toTypeFlags = OpXFlags.ToInt8 | OpXFlags.ToInt16 | OpXFlags.ToInt32 | OpXFlags.ToInt64 | OpXFlags.ToFloat32 | OpXFlags.ToFloat64;

		public const OpXFlags constValFlags = OpXFlags.CM1 | OpXFlags.C0 | OpXFlags.C1 | OpXFlags.C2 | OpXFlags.C3 | OpXFlags.C4 | OpXFlags.C5 | OpXFlags.C6 | OpXFlags.C7 | OpXFlags.C8;

		private static OpCode[] opCodes;

		private static Dictionary<short, OpXID> opXIDsByValue;

		private static Dictionary<OpXFlagsPair, OpXID> opXIDsByPair;

		public static OpXID declareLocalOp { get; private set; }

		public static OpXID labelCountOp { get; private set; }

		public static OpXID labelOp { get; private set; }

		public static OpXID caseOp { get; private set; }

		public static OpXID markLabelOp { get; private set; }

		public static OpXID endSwitchOp { get; private set; }

		public static bool IsOfTypeOrSubType(this object obj, Type type)
		{
			Type type2 = obj.GetType();
			if (!(type2 == type))
			{
				return type2.IsSubclassOf(type);
			}
			return true;
		}

		public static bool IsTypeOrSubType(this Type type1, Type type2)
		{
			if (!(type1 == type2))
			{
				return type1.IsSubclassOf(type2);
			}
			return true;
		}

		public static FieldInfo[] GetPublicInstFields(this object obj)
		{
			return obj.GetType().GetFields(BindingFlags.Instance | BindingFlags.Public);
		}

		public static bool IsSubclassOfRawGeneric(this Type type, Type rawGenericType)
		{
			if (type == rawGenericType)
			{
				return false;
			}
			while (type != null && type != typeof(object))
			{
				if (rawGenericType == (type.IsGenericType ? type.GetGenericTypeDefinition() : type))
				{
					return true;
				}
				type = type.BaseType;
			}
			return false;
		}

		public static bool HasAttr<T>(this MemberInfo element, bool inherit = false) where T : Attribute
		{
			return Attribute.IsDefined(element, typeof(T), inherit);
		}

		public static T GetAttr<T>(this MemberInfo element, bool inherit = false) where T : Attribute
		{
			return (T)Attribute.GetCustomAttribute(element, typeof(T), inherit);
		}

		public static bool IsBacking(this FieldInfo field)
		{
			if (field.HasAttr<CompilerGeneratedAttribute>() && field.Name.StartsWith("<"))
			{
				return field.Name.EndsWith(">k__BackingField");
			}
			return false;
		}

		public static PropertyInfo GetBackedProperty(this FieldInfo field)
		{
			string name = field.Name.Substring(1, field.Name.IndexOf('>') - 1);
			return field.DeclaringType.GetProperty(name, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
		}

		public static int PrimitiveSize(this Type type)
		{
			if (type == typeof(bool))
			{
				return 1;
			}
			if (type == typeof(char))
			{
				return 2;
			}
			if (type == typeof(sbyte))
			{
				return 1;
			}
			if (type == typeof(short))
			{
				return 2;
			}
			if (type == typeof(int))
			{
				return 4;
			}
			if (type == typeof(long))
			{
				return 8;
			}
			if (type == typeof(byte))
			{
				return 1;
			}
			if (type == typeof(ushort))
			{
				return 2;
			}
			if (type == typeof(uint))
			{
				return 4;
			}
			if (type == typeof(ulong))
			{
				return 8;
			}
			if (type == typeof(float))
			{
				return 4;
			}
			if (type == typeof(double))
			{
				return 8;
			}
			throw new InvalidOperationException();
		}

		public static bool IsIterator(this Type type)
		{
			if (type != null && type.IsClass && type.IsSealed && typeof(IEnumerator).IsAssignableFrom(type) && (type.HasAttr<CompilerGeneratedAttribute>() || (type.DeclaringType != null && type.DeclaringType.HasAttr<CompilerGeneratedAttribute>())))
			{
				return true;
			}
			return false;
		}

		public static bool IsIterator<T>(this Type type)
		{
			if (type.IsIterator() && typeof(IEnumerator<T>).IsAssignableFrom(type))
			{
				return true;
			}
			return false;
		}

		public static MethodInfo GetIteratorMethod(this Type iterType)
		{
			_ = iterType.Name;
			MethodInfo[] methods = iterType.DeclaringType.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			int i = 0;
			for (int num = methods.Length; i < num; i++)
			{
				MethodInfo methodInfo = methods[i];
				IteratorStateMachineAttribute attr = methodInfo.GetAttr<IteratorStateMachineAttribute>();
				if (attr != null && attr.StateMachineType == (iterType.IsGenericType ? iterType.GetGenericTypeDefinition() : iterType))
				{
					return methodInfo;
				}
			}
			Panic.ReflectionX.ThrowMissingIteratorMethod(iterType);
			return null;
		}

		public static IEnumerable<OptionalFieldInfo> GetIteratorParameterFields(this Type iteratorType, MethodInfo method = null)
		{
			if (method == null)
			{
				method = iteratorType.GetIteratorMethod();
			}
			ParameterInfo[] @params = method.GetParameters();
			int i = 0;
			int j = @params.Length;
			while (i < j)
			{
				yield return new OptionalFieldInfo
				{
					type = @params[i].ParameterType,
					name = @params[i].Name,
					info = iteratorType.GetField(@params[i].Name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
				};
				int num = i + 1;
				i = num;
			}
		}

		public static FieldInfo Find(this FieldInfo[] fields, string name = null, bool fullMatch = true, Type type = null)
		{
			int i = 0;
			for (int num = fields.Length; i < num; i++)
			{
				if ((name == null || (fullMatch ? (fields[i].Name == name) : fields[i].Name.Contains(name))) && (type == null || fields[i].FieldType == type))
				{
					return fields[i];
				}
			}
			return null;
		}

		public static Func<object, FT> CreateDynamicGetter<FT>(this FieldInfo field, bool required = true)
		{
			return (Func<object, FT>)field.CreateDynamicGetSet(getter: true, required).CreateDelegate(typeof(Func<object, FT>));
		}

		public static Func<object, FT> CreateDynamicGetter<FT>(this object obj, string fieldName, bool required = true)
		{
			return (Func<object, FT>)obj.GetType().CreateDynamicGetSet<FT>(fieldName, getter: true, required).CreateDelegate(typeof(Func<object, FT>));
		}

		public static Func<object, FT> CreateDynamicGetterFake<FT>(this Type type, string fieldName, bool required = true)
		{
			return (Func<object, FT>)type.CreateDynamicGetSetFake<FT>(fieldName, getter: true, required).CreateDelegate(typeof(Func<object, FT>));
		}

		public static Action<object, FT> CreateDynamicSetter<FT>(this FieldInfo field, bool required = true)
		{
			return (Action<object, FT>)field.CreateDynamicGetSet(getter: false, required).CreateDelegate(typeof(Action<object, FT>));
		}

		public static Action<object, FT> CreateDynamicSetter<FT>(this object obj, string fieldName, bool required = true)
		{
			return (Action<object, FT>)obj.GetType().CreateDynamicGetSet<FT>(fieldName, getter: false, required).CreateDelegate(typeof(Action<object, FT>));
		}

		public static Action<object, FT> CreateDynamicSetterFake<FT>(this Type type, string fieldName, bool required = true)
		{
			return (Action<object, FT>)type.CreateDynamicGetSetFake<FT>(fieldName, getter: false, required).CreateDelegate(typeof(Action<object, FT>));
		}

		public static DynamicMethod CreateDynamicGetSet<FT>(this Type type, string fieldName, bool getter, bool required = true)
		{
			FieldInfo field = type.GetField(fieldName, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			if (field == null && !required)
			{
				return type.CreateDynamicGetSetFake<FT>(fieldName, getter, required);
			}
			return field.CreateDynamicGetSet(getter, required);
		}

		public static DynamicMethod CreateDynamicGetSet(this FieldInfo field, bool getter, bool required = true)
		{
			DynamicMethod dynamicMethod = null;
			try
			{
				Type returnType = (getter ? field.FieldType : null);
				Type[] parameterTypes = ((!getter) ? new Type[2]
				{
					typeof(object),
					field.FieldType
				} : new Type[1] { typeof(object) });
				dynamicMethod = new DynamicMethod(field.GetDynamicGetSetName(getter), returnType, parameterTypes, restrictedSkipVisibility: true);
				dynamicMethod.GetILGenerator().EmitGetSet(field, getter);
			}
			catch
			{
				if (required)
				{
					throw;
				}
			}
			return dynamicMethod;
		}

		public static DynamicMethod CreateDynamicGetSetFake<FT>(this Type type, string fieldName, bool getter, bool required = true)
		{
			DynamicMethod dynamicMethod = null;
			try
			{
				Type returnType = (getter ? typeof(FT) : null);
				Type[] parameterTypes = ((!getter) ? new Type[2]
				{
					typeof(object),
					typeof(FT)
				} : new Type[1] { typeof(object) });
				dynamicMethod = new DynamicMethod(type.GetDynamicGetSetName(fieldName, getter), returnType, parameterTypes, restrictedSkipVisibility: true);
				dynamicMethod.GetILGenerator().EmitGetSetFake(typeof(FT), getter);
			}
			catch
			{
				if (required)
				{
					throw;
				}
			}
			return dynamicMethod;
		}

		public static void EmitGetSet(this ILGenerator gen, FieldInfo field, bool getter)
		{
			if (getter)
			{
				if (field.IsStatic)
				{
					gen.Emit(OpCodes.Ldsfld, field);
				}
				else
				{
					gen.Emit(OpCodes.Ldarg_0);
					gen.Emit(OpCodes.Ldfld, field);
				}
			}
			else if (field.IsStatic)
			{
				gen.Emit(OpCodes.Ldarg_1);
				gen.Emit(OpCodes.Stsfld, field);
			}
			else
			{
				gen.Emit(OpCodes.Ldarg_0);
				gen.Emit(OpCodes.Ldarg_1);
				gen.Emit(OpCodes.Stfld, field);
			}
			gen.Emit(OpCodes.Ret);
		}

		public static void EmitGetSetFake(this ILGenerator gen, Type fieldType, bool getter)
		{
			if (getter)
			{
				gen.DeclareLocal(fieldType);
				gen.Emit(OpCodes.Ldloca_S, (short)0);
				gen.Emit(OpCodes.Initobj, fieldType);
				gen.Emit(OpCodes.Ldloc_0);
			}
			gen.Emit(OpCodes.Ret);
		}

		public static void EmitIntSwitch(this ILGenerator gen, int @default, params KeyValuePair<int, int>[] cases)
		{
			int i = 0;
			for (int num = cases.Length; i < num; i++)
			{
				Label label = gen.DefineLabel();
				Label label2 = gen.DefineLabel();
				gen.Emit(OpCodes.Ldarg_0);
				gen.Emit(OpCodes.Ldc_I4, cases[i].Key);
				gen.Emit(OpCodes.Beq, label);
				gen.Emit(OpCodes.Br, label2);
				gen.MarkLabel(label);
				gen.Emit(OpCodes.Ldc_I4, cases[i].Value);
				gen.Emit(OpCodes.Ret);
				gen.MarkLabel(label2);
			}
			gen.Emit(OpCodes.Ldc_I4, @default);
			gen.Emit(OpCodes.Ret);
		}

		public static void EmitReturnValue(this ILGenerator gen, bool value)
		{
			gen.Emit(value ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
			gen.Emit(OpCodes.Ret);
		}

		public static void EmitReturnValue(this ILGenerator gen, string value)
		{
			if (value != null)
			{
				gen.Emit(OpCodes.Ldstr, value);
			}
			else
			{
				gen.Emit(OpCodes.Ldnull);
			}
			gen.Emit(OpCodes.Ret);
		}

		public static void EmitReturnValue(this ILGenerator gen, int value)
		{
			gen.Emit(OpCodes.Ldc_I4, value);
			gen.Emit(OpCodes.Ret);
		}

		public static void EmitReturnValue(this ILGenerator gen, object value)
		{
			switch (Convert.GetTypeCode(value))
			{
			case TypeCode.Boolean:
				gen.Emit(OpCodes.Ldc_I4_S, (short)(((bool)value) ? 1 : 0));
				break;
			case TypeCode.Empty:
				gen.Emit(OpCodes.Ldnull);
				break;
			case TypeCode.Char:
				gen.Emit(OpCodes.Ldc_I4_S, (char)value);
				break;
			case TypeCode.SByte:
				gen.Emit(OpCodes.Ldc_I4_S, (sbyte)value);
				break;
			case TypeCode.Byte:
				gen.Emit(OpCodes.Ldc_I4, (int)(byte)value);
				break;
			case TypeCode.Int16:
				gen.Emit(OpCodes.Ldc_I4, (int)(short)value);
				break;
			case TypeCode.UInt16:
				gen.Emit(OpCodes.Ldc_I4, (ushort)value);
				break;
			case TypeCode.Int32:
				gen.Emit(OpCodes.Ldc_I4, (int)value);
				break;
			case TypeCode.UInt32:
				gen.Emit(OpCodes.Ldc_I8, (uint)value);
				gen.Emit(OpCodes.Conv_U4);
				break;
			case TypeCode.Int64:
				gen.Emit(OpCodes.Ldc_I8, (long)value);
				break;
			case TypeCode.UInt64:
				if ((ulong)value >= long.MaxValue)
				{
					gen.Emit(OpCodes.Ldc_I8, (long)((ulong)value - long.MaxValue - long.MaxValue));
				}
				else
				{
					gen.Emit(OpCodes.Ldc_I8, (long)(ulong)value);
				}
				gen.Emit(OpCodes.Conv_U8);
				break;
			case TypeCode.Single:
				gen.Emit(OpCodes.Ldc_R4, (float)value);
				break;
			case TypeCode.Double:
				gen.Emit(OpCodes.Ldc_R8, (double)value);
				break;
			case TypeCode.String:
				gen.Emit(OpCodes.Ldstr, (string)value);
				break;
			default:
				Panic.ReflectionX.ThrowInvalidReturn(value);
				break;
			}
			gen.Emit(OpCodes.Ret);
		}

		public static void EmitSimpleMethod(this ILGenerator gen, object returnValue = null, Type returnType = null)
		{
			gen.EmitStubMethod(returnValue, returnType);
		}

		public static void EmitStubMethod(this ILGenerator gen, object returnValue = null, Type returnType = null)
		{
			if (returnValue != null)
			{
				gen.EmitReturnValue(returnValue);
				return;
			}
			if (returnType == null || returnType == typeof(void))
			{
				gen.EmitReturn();
				return;
			}
			if (returnType.IsClass)
			{
				gen.EmitReturnValue(null);
				return;
			}
			gen.DeclareLocal(returnType);
			gen.Emit(OpCodes.Ldloca_S, 0);
			gen.Emit(OpCodes.Initobj, returnType);
			gen.Emit(OpCodes.Ldloc_0);
			gen.Emit(OpCodes.Ret);
		}

		public static void EmitReturn(this ILGenerator gen)
		{
			gen.Emit(OpCodes.Ret);
		}

		public static ILGenerator EmitIL(this MethodBuilder methodBuilder, IEnumerable<OpXInst> il, Module module)
		{
			ILGenerator iLGenerator = methodBuilder.GetILGenerator();
			iLGenerator.EmitIL(il, module);
			return iLGenerator;
		}

		public static void EmitIL(this ILGenerator gen, IEnumerable<OpXInst> il, Module module)
		{
			Dictionary<int, Label> ls = null;
			Label[] cs = null;
			foreach (OpXInst item in il)
			{
				if (ls != null && ls.TryGetValue(item.index, out var value))
				{
					gen.MarkLabel(value);
				}
				item.id.Emit(gen, item, ref ls, ref cs, module);
			}
		}

		public static void EmitAll(this TypeBuilder typeBuilder, IEnumerable<MemberXInst> members)
		{
			IEnumerator<MemberXInst> enumerator = members.GetEnumerator();
			typeBuilder.AddInterfaces(enumerator);
			typeBuilder.DefineFields(enumerator);
			typeBuilder.DefineProperties(enumerator);
			typeBuilder.DefineMethods(enumerator);
		}

		public static void AddInterfaces(this TypeBuilder typeBuilder, IEnumerator<MemberXInst> memEnum)
		{
			memEnum.MoveNext();
			int i = 0;
			for (int count = memEnum.Current.details.count; i < count; i++)
			{
				typeBuilder.AddInterface(memEnum);
			}
		}

		public static void AddInterface(this TypeBuilder typeBuilder, IEnumerator<MemberXInst> memEnum)
		{
			memEnum.MoveNext();
			typeBuilder.AddInterfaceImplementation((Type)memEnum.Current.info);
		}

		public static void DefineFields(this TypeBuilder typeBuilder, IEnumerator<MemberXInst> memEnum)
		{
			memEnum.MoveNext();
			int i = 0;
			for (int count = memEnum.Current.details.count; i < count; i++)
			{
				typeBuilder.DefineField(memEnum);
			}
		}

		public static void DefineField(this TypeBuilder typeBuilder, IEnumerator<MemberXInst> memEnum)
		{
			memEnum.MoveNext();
			memEnum.MoveNext();
			string name = memEnum.Current.name;
			memEnum.MoveNext();
			Type type = (Type)memEnum.Current.info;
			memEnum.MoveNext();
			int count = memEnum.Current.details.count;
			Type[] array = new Type[count];
			for (int i = 0; i < count; i++)
			{
				memEnum.MoveNext();
				array[i] = (Type)memEnum.Current.info;
			}
			memEnum.MoveNext();
			int count2 = memEnum.Current.details.count;
			Type[] array2 = new Type[count2];
			for (int j = 0; j < count2; j++)
			{
				memEnum.MoveNext();
				array2[j] = (Type)memEnum.Current.info;
			}
			memEnum.MoveNext();
			FieldAttributes fieldAttribs = memEnum.Current.details.fieldAttribs;
			typeBuilder.DefineField(name, type, array, array2, fieldAttribs);
		}

		public static void DefineProperties(this TypeBuilder typeBuilder, IEnumerator<MemberXInst> memEnum)
		{
			memEnum.MoveNext();
			int i = 0;
			for (int count = memEnum.Current.details.count; i < count; i++)
			{
				typeBuilder.DefineProperty(memEnum);
			}
		}

		public static void DefineProperty(this TypeBuilder typeBuilder, IEnumerator<MemberXInst> memEnum)
		{
			memEnum.MoveNext();
			memEnum.MoveNext();
			string name = memEnum.Current.name;
			memEnum.MoveNext();
			Type returnType = (Type)memEnum.Current.info;
			memEnum.MoveNext();
			PropertyAttributes propAttribs = memEnum.Current.details.propAttribs;
			typeBuilder.DefineProperty(name, propAttribs, returnType, null);
		}

		public static void DefineMethods(this TypeBuilder typeBuilder, IEnumerator<MemberXInst> memEnum)
		{
			memEnum.MoveNext();
			int i = 0;
			for (int count = memEnum.Current.details.count; i < count; i++)
			{
				typeBuilder.DefineMethod(memEnum);
			}
		}

		public static MethodBuilder DefineMethod(this TypeBuilder typeBuilder, IEnumerator<MemberXInst> memEnum)
		{
			MemberInfo source;
			return typeBuilder.DefineMethod<MemberInfo>(memEnum, out source);
		}

		public static MethodBuilder DefineMethod<T>(this TypeBuilder typeBuilder, IEnumerator<MemberXInst> memEnum, out T source) where T : MemberInfo
		{
			memEnum.MoveNext();
			source = (T)memEnum.Current.info;
			memEnum.MoveNext();
			string name = memEnum.Current.name;
			memEnum.MoveNext();
			Type returnType = (Type)memEnum.Current.info;
			memEnum.MoveNext();
			MethodAttributes methodAttribs = memEnum.Current.details.methodAttribs;
			memEnum.MoveNext();
			CallingConventions conventions = memEnum.Current.details.conventions;
			memEnum.MoveNext();
			Type[] array = new Type[memEnum.Current.details.count];
			int i = 0;
			for (int num = array.Length; i < num; i++)
			{
				memEnum.MoveNext();
				array[i] = (Type)memEnum.Current.info;
			}
			return typeBuilder.DefineMethod(name, methodAttribs, conventions, returnType, array);
		}

		public static bool Got(this OpXFlags flags, OpXFlags f0, OpXFlags f1 = OpXFlags.None, OpXFlags f2 = OpXFlags.None, OpXFlags f3 = OpXFlags.None, OpXFlags f4 = OpXFlags.None)
		{
			return (flags & (f0 | f1 | f2 | f3 | f4)) == (f0 | f1 | f2 | f3 | f4);
		}

		public static OpXFlags ArgSizeFlag(this OpXFlags flags)
		{
			return flags & (OpXFlags.Int8Arg | OpXFlags.Int16Arg | OpXFlags.Int32Arg | OpXFlags.Int64Arg);
		}

		public static OpXFlags EndTypeFlags(this OpXFlags flags)
		{
			return flags & (OpXFlags.ToInt8 | OpXFlags.ToInt16 | OpXFlags.ToInt32 | OpXFlags.ToInt64 | OpXFlags.ToFloat32 | OpXFlags.ToFloat64);
		}

		public static OpXFlagsPair With(this OpX op, OpXFlags flags = OpXFlags.None, OpXFlags atLeast = OpXFlags.None)
		{
			OpXFlagsPair result = default(OpXFlagsPair);
			result.op = op;
			result.flags = ((flags != OpXFlags.None) ? flags : (atLeast | OpXFlags.AtLeast));
			return result;
		}

		private static void RetainOpXPrecache()
		{
			if (opXIDsByValue != null)
			{
				return;
			}
			PreID[] array = new PreID[219]
			{
				new PreID(OpCodes.Add, OpX.Add, OpXFlags.FromSigned | OpXFlags.AllowOverflow),
				new PreID(OpCodes.Add_Ovf, OpX.Add, OpXFlags.ThrowOnOverFlow | OpXFlags.FromSigned),
				new PreID(OpCodes.Add_Ovf_Un, OpX.Add, OpXFlags.ThrowOnOverFlow | OpXFlags.FromUnsigned),
				new PreID(OpCodes.And, OpX.And, OpXFlags.None),
				new PreID(OpCodes.Arglist, OpX.PushArgList, OpXFlags.None),
				new PreID(OpCodes.Beq, OpX.Branch, OpXFlags.IfEqual),
				new PreID(OpCodes.Beq_S, OpX.Branch, OpXFlags.IfEqual),
				new PreID(OpCodes.Bge, OpX.Branch, OpXFlags.FromSigned | OpXFlags.IfEqual | OpXFlags.IfGreater),
				new PreID(OpCodes.Bge_S, OpX.Branch, OpXFlags.FromSigned | OpXFlags.IfEqual | OpXFlags.IfGreater),
				new PreID(OpCodes.Bge_Un, OpX.Branch, OpXFlags.FromUnsigned | OpXFlags.IfEqual | OpXFlags.IfGreater),
				new PreID(OpCodes.Bge_Un_S, OpX.Branch, OpXFlags.FromUnsigned | OpXFlags.IfEqual | OpXFlags.IfGreater),
				new PreID(OpCodes.Bgt, OpX.Branch, OpXFlags.FromSigned | OpXFlags.IfGreater),
				new PreID(OpCodes.Bgt_S, OpX.Branch, OpXFlags.FromSigned | OpXFlags.IfGreater),
				new PreID(OpCodes.Bgt_Un, OpX.Branch, OpXFlags.FromUnsigned | OpXFlags.IfGreater),
				new PreID(OpCodes.Bgt_Un_S, OpX.Branch, OpXFlags.FromUnsigned | OpXFlags.IfGreater),
				new PreID(OpCodes.Ble, OpX.Branch, OpXFlags.FromSigned | OpXFlags.IfEqual | OpXFlags.IfLesser),
				new PreID(OpCodes.Ble_S, OpX.Branch, OpXFlags.FromSigned | OpXFlags.IfEqual | OpXFlags.IfLesser),
				new PreID(OpCodes.Ble_Un, OpX.Branch, OpXFlags.FromUnsigned | OpXFlags.IfEqual | OpXFlags.IfLesser),
				new PreID(OpCodes.Ble_Un_S, OpX.Branch, OpXFlags.FromUnsigned | OpXFlags.IfEqual | OpXFlags.IfLesser),
				new PreID(OpCodes.Blt, OpX.Branch, OpXFlags.FromSigned | OpXFlags.IfLesser),
				new PreID(OpCodes.Blt_S, OpX.Branch, OpXFlags.FromSigned | OpXFlags.IfLesser),
				new PreID(OpCodes.Blt_Un, OpX.Branch, OpXFlags.FromUnsigned | OpXFlags.IfLesser),
				new PreID(OpCodes.Blt_Un_S, OpX.Branch, OpXFlags.FromUnsigned | OpXFlags.IfLesser),
				new PreID(OpCodes.Bne_Un, OpX.Branch, OpXFlags.FromUnsigned | OpXFlags.IfUnequal),
				new PreID(OpCodes.Bne_Un_S, OpX.Branch, OpXFlags.FromUnsigned | OpXFlags.IfUnequal),
				new PreID(OpCodes.Box, OpX.Box, OpXFlags.None),
				new PreID(OpCodes.Br, OpX.Branch, OpXFlags.None),
				new PreID(OpCodes.Br_S, OpX.Branch, OpXFlags.None),
				new PreID(OpCodes.Break, OpX.Break, OpXFlags.None),
				new PreID(OpCodes.Brfalse, OpX.Branch, OpXFlags.IfFalse),
				new PreID(OpCodes.Brfalse_S, OpX.Branch, OpXFlags.IfFalse),
				new PreID(OpCodes.Brtrue, OpX.Branch, OpXFlags.IfTrue),
				new PreID(OpCodes.Brtrue_S, OpX.Branch, OpXFlags.IfTrue),
				new PreID(OpCodes.Call, OpX.Call, OpXFlags.NonVirtual | OpXFlags.FromArg),
				new PreID(OpCodes.Calli, OpX.Call, OpXFlags.FromStack | OpXFlags.NonVirtual),
				new PreID(OpCodes.Callvirt, OpX.Call, OpXFlags.FromStack | OpXFlags.Virtual),
				new PreID(OpCodes.Castclass, OpX.Cast, OpXFlags.None),
				new PreID(OpCodes.Ceq, OpX.Compare, OpXFlags.IfEqual),
				new PreID(OpCodes.Cgt, OpX.Compare, OpXFlags.FromSigned | OpXFlags.IfGreater),
				new PreID(OpCodes.Cgt_Un, OpX.Compare, OpXFlags.FromUnsigned | OpXFlags.IfGreater),
				new PreID(OpCodes.Ckfinite, OpX.ThrowOnInf, OpXFlags.None),
				new PreID(OpCodes.Clt, OpX.Compare, OpXFlags.FromSigned | OpXFlags.IfLesser),
				new PreID(OpCodes.Clt_Un, OpX.Compare, OpXFlags.FromUnsigned | OpXFlags.IfLesser),
				new PreID(OpCodes.Constrained, OpX.Constrain, OpXFlags.None),
				new PreID(OpCodes.Conv_I, OpX.Convert, OpXFlags.FromSigned | OpXFlags.ToNativeInt | OpXFlags.AllowOverflow),
				new PreID(OpCodes.Conv_Ovf_I, OpX.Convert, OpXFlags.ThrowOnOverFlow | OpXFlags.FromSigned | OpXFlags.ToNativeInt),
				new PreID(OpCodes.Conv_Ovf_I_Un, OpX.Convert, OpXFlags.ThrowOnOverFlow | OpXFlags.FromUnsigned | OpXFlags.ToNativeInt),
				new PreID(OpCodes.Conv_I1, OpX.Convert, OpXFlags.FromSigned | OpXFlags.ToInt8 | OpXFlags.AllowOverflow),
				new PreID(OpCodes.Conv_Ovf_I1, OpX.Convert, OpXFlags.ThrowOnOverFlow | OpXFlags.FromSigned | OpXFlags.ToInt8),
				new PreID(OpCodes.Conv_Ovf_I1_Un, OpX.Convert, OpXFlags.ThrowOnOverFlow | OpXFlags.FromUnsigned | OpXFlags.ToInt8),
				new PreID(OpCodes.Conv_I2, OpX.Convert, OpXFlags.FromSigned | OpXFlags.ToInt16 | OpXFlags.AllowOverflow),
				new PreID(OpCodes.Conv_Ovf_I2, OpX.Convert, OpXFlags.ThrowOnOverFlow | OpXFlags.FromSigned | OpXFlags.ToInt16),
				new PreID(OpCodes.Conv_Ovf_I2_Un, OpX.Convert, OpXFlags.ThrowOnOverFlow | OpXFlags.FromUnsigned | OpXFlags.ToInt16),
				new PreID(OpCodes.Conv_I4, OpX.Convert, OpXFlags.FromSigned | OpXFlags.ToInt32 | OpXFlags.AllowOverflow),
				new PreID(OpCodes.Conv_Ovf_I4, OpX.Convert, OpXFlags.ThrowOnOverFlow | OpXFlags.FromSigned | OpXFlags.ToInt32),
				new PreID(OpCodes.Conv_Ovf_I4_Un, OpX.Convert, OpXFlags.ThrowOnOverFlow | OpXFlags.FromUnsigned | OpXFlags.ToInt32),
				new PreID(OpCodes.Conv_I8, OpX.Convert, OpXFlags.FromSigned | OpXFlags.ToInt64 | OpXFlags.AllowOverflow),
				new PreID(OpCodes.Conv_Ovf_I8, OpX.Convert, OpXFlags.ThrowOnOverFlow | OpXFlags.FromSigned | OpXFlags.ToInt64),
				new PreID(OpCodes.Conv_Ovf_I8_Un, OpX.Convert, OpXFlags.ThrowOnOverFlow | OpXFlags.FromUnsigned | OpXFlags.ToInt64),
				new PreID(OpCodes.Conv_U, OpX.Convert, OpXFlags.FromSigned | OpXFlags.ToNativeInt | OpXFlags.ToUnsigned | OpXFlags.AllowOverflow),
				new PreID(OpCodes.Conv_Ovf_U, OpX.Convert, OpXFlags.ThrowOnOverFlow | OpXFlags.FromSigned | OpXFlags.ToNativeInt | OpXFlags.ToUnsigned),
				new PreID(OpCodes.Conv_Ovf_U_Un, OpX.Convert, OpXFlags.ThrowOnOverFlow | OpXFlags.FromUnsigned | OpXFlags.ToNativeInt | OpXFlags.ToUnsigned),
				new PreID(OpCodes.Conv_U1, OpX.Convert, OpXFlags.FromSigned | OpXFlags.ToUnsigned | OpXFlags.ToInt8 | OpXFlags.AllowOverflow),
				new PreID(OpCodes.Conv_Ovf_U1, OpX.Convert, OpXFlags.ThrowOnOverFlow | OpXFlags.FromSigned | OpXFlags.ToUnsigned | OpXFlags.ToInt8),
				new PreID(OpCodes.Conv_Ovf_U1_Un, OpX.Convert, OpXFlags.ThrowOnOverFlow | OpXFlags.FromUnsigned | OpXFlags.ToUnsigned | OpXFlags.ToInt8),
				new PreID(OpCodes.Conv_U2, OpX.Convert, OpXFlags.FromSigned | OpXFlags.ToUnsigned | OpXFlags.ToInt16 | OpXFlags.AllowOverflow),
				new PreID(OpCodes.Conv_Ovf_U2, OpX.Convert, OpXFlags.ThrowOnOverFlow | OpXFlags.FromSigned | OpXFlags.ToUnsigned | OpXFlags.ToInt16),
				new PreID(OpCodes.Conv_Ovf_U2_Un, OpX.Convert, OpXFlags.ThrowOnOverFlow | OpXFlags.FromUnsigned | OpXFlags.ToUnsigned | OpXFlags.ToInt16),
				new PreID(OpCodes.Conv_U4, OpX.Convert, OpXFlags.FromSigned | OpXFlags.ToUnsigned | OpXFlags.ToInt32 | OpXFlags.AllowOverflow),
				new PreID(OpCodes.Conv_Ovf_U4, OpX.Convert, OpXFlags.ThrowOnOverFlow | OpXFlags.FromSigned | OpXFlags.ToUnsigned | OpXFlags.ToInt32),
				new PreID(OpCodes.Conv_Ovf_U4_Un, OpX.Convert, OpXFlags.ThrowOnOverFlow | OpXFlags.FromUnsigned | OpXFlags.ToUnsigned | OpXFlags.ToInt32),
				new PreID(OpCodes.Conv_U8, OpX.Convert, OpXFlags.FromSigned | OpXFlags.ToUnsigned | OpXFlags.ToInt64 | OpXFlags.AllowOverflow),
				new PreID(OpCodes.Conv_Ovf_U8, OpX.Convert, OpXFlags.ThrowOnOverFlow | OpXFlags.FromSigned | OpXFlags.ToUnsigned | OpXFlags.ToInt64),
				new PreID(OpCodes.Conv_Ovf_U8_Un, OpX.Convert, OpXFlags.ThrowOnOverFlow | OpXFlags.FromUnsigned | OpXFlags.ToUnsigned | OpXFlags.ToInt64),
				new PreID(OpCodes.Conv_R_Un, OpX.Convert, OpXFlags.FromUnsigned | OpXFlags.ToFloat32),
				new PreID(OpCodes.Conv_R4, OpX.Convert, OpXFlags.FromSigned | OpXFlags.ToFloat32),
				new PreID(OpCodes.Conv_R8, OpX.Convert, OpXFlags.FromSigned | OpXFlags.ToFloat64),
				new PreID(OpCodes.Cpblk, OpX.CopyBlock, OpXFlags.None),
				new PreID(OpCodes.Cpobj, OpX.CopyValue, OpXFlags.None),
				new PreID(OpCodes.Div, OpX.Div, OpXFlags.None),
				new PreID(OpCodes.Div_Un, OpX.Div, OpXFlags.FromUnsigned),
				new PreID(OpCodes.Dup, OpX.Dupe, OpXFlags.None),
				new PreID(OpCodes.Endfilter, OpX.EndFilter, OpXFlags.None),
				new PreID(OpCodes.Endfinally, OpX.EndFinally, OpXFlags.None),
				new PreID(OpCodes.Initblk, OpX.InitBlock, OpXFlags.None),
				new PreID(OpCodes.Initobj, OpX.InitValue, OpXFlags.None),
				new PreID(OpCodes.Isinst, OpX.IsInst, OpXFlags.None),
				new PreID(OpCodes.Jmp, OpX.Jump, OpXFlags.None),
				new PreID(OpCodes.Ldarg, OpX.PushArg, OpXFlags.FromArg),
				new PreID(OpCodes.Ldarg_S, OpX.PushArg, OpXFlags.FromArg),
				new PreID(OpCodes.Ldarg_0, OpX.PushArg, OpXFlags.C0),
				new PreID(OpCodes.Ldarg_1, OpX.PushArg, OpXFlags.C1),
				new PreID(OpCodes.Ldarg_2, OpX.PushArg, OpXFlags.C2),
				new PreID(OpCodes.Ldarg_3, OpX.PushArg, OpXFlags.C3),
				new PreID(OpCodes.Ldarga, OpX.PushArg, OpXFlags.ToAddress | OpXFlags.FromArg),
				new PreID(OpCodes.Ldarga_S, OpX.PushArg, OpXFlags.ToAddress | OpXFlags.FromArg),
				new PreID(OpCodes.Ldc_I4, OpX.PushValue, OpXFlags.ToInt32 | OpXFlags.FromArg),
				new PreID(OpCodes.Ldc_I4_S, OpX.PushValue, OpXFlags.ToInt32 | OpXFlags.FromArg),
				new PreID(OpCodes.Ldc_I4_0, OpX.PushValue, OpXFlags.ToInt32 | OpXFlags.C0),
				new PreID(OpCodes.Ldc_I4_1, OpX.PushValue, OpXFlags.ToInt32 | OpXFlags.C1),
				new PreID(OpCodes.Ldc_I4_2, OpX.PushValue, OpXFlags.ToInt32 | OpXFlags.C2),
				new PreID(OpCodes.Ldc_I4_3, OpX.PushValue, OpXFlags.ToInt32 | OpXFlags.C3),
				new PreID(OpCodes.Ldc_I4_4, OpX.PushValue, OpXFlags.ToInt32 | OpXFlags.C4),
				new PreID(OpCodes.Ldc_I4_5, OpX.PushValue, OpXFlags.ToInt32 | OpXFlags.C5),
				new PreID(OpCodes.Ldc_I4_6, OpX.PushValue, OpXFlags.ToInt32 | OpXFlags.C6),
				new PreID(OpCodes.Ldc_I4_7, OpX.PushValue, OpXFlags.ToInt32 | OpXFlags.C7),
				new PreID(OpCodes.Ldc_I4_8, OpX.PushValue, OpXFlags.ToInt32 | OpXFlags.C8),
				new PreID(OpCodes.Ldc_I4_M1, OpX.PushValue, OpXFlags.ToInt32 | OpXFlags.CM1),
				new PreID(OpCodes.Ldc_I8, OpX.PushValue, OpXFlags.ToInt64 | OpXFlags.FromArg),
				new PreID(OpCodes.Ldc_R4, OpX.PushValue, OpXFlags.ToFloat32 | OpXFlags.FromArg),
				new PreID(OpCodes.Ldc_R8, OpX.PushValue, OpXFlags.ToFloat64 | OpXFlags.FromArg),
				new PreID(OpCodes.Ldelem, OpX.PushElement, OpXFlags.ToOtherType),
				new PreID(OpCodes.Ldelem_I, OpX.PushElement, OpXFlags.ToNativeInt),
				new PreID(OpCodes.Ldelem_I1, OpX.PushElement, OpXFlags.FromSigned | OpXFlags.ToInt8),
				new PreID(OpCodes.Ldelem_I2, OpX.PushElement, OpXFlags.FromSigned | OpXFlags.ToInt16),
				new PreID(OpCodes.Ldelem_I4, OpX.PushElement, OpXFlags.FromSigned | OpXFlags.ToInt32),
				new PreID(OpCodes.Ldelem_I8, OpX.PushElement, OpXFlags.FromSigned | OpXFlags.ToInt64),
				new PreID(OpCodes.Ldelem_R4, OpX.PushElement, OpXFlags.ToFloat32),
				new PreID(OpCodes.Ldelem_R8, OpX.PushElement, OpXFlags.ToFloat64),
				new PreID(OpCodes.Ldelem_Ref, OpX.PushElement, OpXFlags.ToReference),
				new PreID(OpCodes.Ldelem_U1, OpX.PushElement, OpXFlags.ToUnsigned | OpXFlags.ToInt8),
				new PreID(OpCodes.Ldelem_U2, OpX.PushElement, OpXFlags.ToUnsigned | OpXFlags.ToInt16),
				new PreID(OpCodes.Ldelem_U4, OpX.PushElement, OpXFlags.ToUnsigned | OpXFlags.ToInt32),
				new PreID(OpCodes.Ldelema, OpX.PushElement, OpXFlags.FromAddress | OpXFlags.ToManagedPointer),
				new PreID(OpCodes.Ldfld, OpX.PushField, OpXFlags.ToOwnType),
				new PreID(OpCodes.Ldflda, OpX.PushField, OpXFlags.ToAddress),
				new PreID(OpCodes.Ldftn, OpX.PushNativeMethod, OpXFlags.None),
				new PreID(OpCodes.Ldind_I, OpX.PushValueAtAddr, OpXFlags.ToNativeInt | OpXFlags.FromNativeInt),
				new PreID(OpCodes.Ldind_I1, OpX.PushValueAtAddr, OpXFlags.FromSigned | OpXFlags.ToInt32 | OpXFlags.FromInt8),
				new PreID(OpCodes.Ldind_I2, OpX.PushValueAtAddr, OpXFlags.FromSigned | OpXFlags.ToInt32 | OpXFlags.FromInt16),
				new PreID(OpCodes.Ldind_I4, OpX.PushValueAtAddr, OpXFlags.FromSigned | OpXFlags.ToInt32 | OpXFlags.FromInt32),
				new PreID(OpCodes.Ldind_I8, OpX.PushValueAtAddr, OpXFlags.FromSigned | OpXFlags.ToInt64),
				new PreID(OpCodes.Ldind_R4, OpX.PushValueAtAddr, OpXFlags.ToFloat32 | OpXFlags.FromFloat32),
				new PreID(OpCodes.Ldind_R8, OpX.PushValueAtAddr, OpXFlags.ToFloat32 | OpXFlags.FromFloat64),
				new PreID(OpCodes.Ldind_Ref, OpX.PushValueAtAddr, OpXFlags.FromAddress | OpXFlags.ToReference),
				new PreID(OpCodes.Ldind_U1, OpX.PushValueAtAddr, OpXFlags.FromUnsigned | OpXFlags.ToInt32 | OpXFlags.FromInt8),
				new PreID(OpCodes.Ldind_U2, OpX.PushValueAtAddr, OpXFlags.FromUnsigned | OpXFlags.ToInt32 | OpXFlags.FromInt16),
				new PreID(OpCodes.Ldind_U4, OpX.PushValueAtAddr, OpXFlags.FromUnsigned | OpXFlags.ToInt32 | OpXFlags.FromInt32),
				new PreID(OpCodes.Ldlen, OpX.PushLength, OpXFlags.None),
				new PreID(OpCodes.Ldloc, OpX.PushLocal, OpXFlags.FromArg),
				new PreID(OpCodes.Ldloc_S, OpX.PushLocal, OpXFlags.FromArg),
				new PreID(OpCodes.Ldloc_0, OpX.PushLocal, OpXFlags.C0),
				new PreID(OpCodes.Ldloc_1, OpX.PushLocal, OpXFlags.C1),
				new PreID(OpCodes.Ldloc_2, OpX.PushLocal, OpXFlags.C2),
				new PreID(OpCodes.Ldloc_3, OpX.PushLocal, OpXFlags.C3),
				new PreID(OpCodes.Ldloca, OpX.PushLocal, OpXFlags.ToAddress),
				new PreID(OpCodes.Ldloca_S, OpX.PushLocal, OpXFlags.ToAddress),
				new PreID(OpCodes.Ldnull, OpX.PushNull, OpXFlags.None),
				new PreID(OpCodes.Ldobj, OpX.PushObject, OpXFlags.None),
				new PreID(OpCodes.Ldsfld, OpX.PushStaticField, OpXFlags.ToOwnType),
				new PreID(OpCodes.Ldsflda, OpX.PushStaticField, OpXFlags.ToAddress),
				new PreID(OpCodes.Ldobj, OpX.PushObject, OpXFlags.None),
				new PreID(OpCodes.Ldstr, OpX.PushString, OpXFlags.None),
				new PreID(OpCodes.Ldtoken, OpX.PushToken, OpXFlags.None),
				new PreID(OpCodes.Ldvirtftn, OpX.PushNativeVirtMethod, OpXFlags.None),
				new PreID(OpCodes.Leave, OpX.LeaveProtRegion, OpXFlags.None),
				new PreID(OpCodes.Leave_S, OpX.LeaveProtRegion, OpXFlags.None),
				new PreID(OpCodes.Localloc, OpX.PushByteAlloc, OpXFlags.None),
				new PreID(OpCodes.Mkrefany, OpX.PushRef, OpXFlags.None),
				new PreID(OpCodes.Mul, OpX.Multiply, OpXFlags.FromSigned | OpXFlags.AllowOverflow),
				new PreID(OpCodes.Mul_Ovf, OpX.Multiply, OpXFlags.ThrowOnOverFlow | OpXFlags.FromSigned),
				new PreID(OpCodes.Mul_Ovf_Un, OpX.Multiply, OpXFlags.ThrowOnOverFlow | OpXFlags.FromUnsigned),
				new PreID(OpCodes.Neg, OpX.Negate, OpXFlags.None),
				new PreID(OpCodes.Newarr, OpX.PushNewArray, OpXFlags.None),
				new PreID(OpCodes.Newobj, OpX.PushNewObject, OpXFlags.None),
				new PreID(OpCodes.Nop, OpX.NoOp, OpXFlags.None),
				new PreID(OpCodes.Not, OpX.Not, OpXFlags.None),
				new PreID(OpCodes.Or, OpX.Or, OpXFlags.None),
				new PreID(OpCodes.Pop, OpX.Pop, OpXFlags.None),
				new PreID(OpCodes.Readonly, OpX.ReadOnly, OpXFlags.None),
				new PreID(OpCodes.Refanytype, OpX.PushRefType, OpXFlags.None),
				new PreID(OpCodes.Refanyval, OpX.PushRefAddr, OpXFlags.None),
				new PreID(OpCodes.Rem, OpX.Remainder, OpXFlags.None),
				new PreID(OpCodes.Rem_Un, OpX.Remainder, OpXFlags.None),
				new PreID(OpCodes.Ret, OpX.Return, OpXFlags.None),
				new PreID(OpCodes.Rethrow, OpX.Rethrow, OpXFlags.None),
				new PreID(OpCodes.Shl, OpX.ShiftLeft, OpXFlags.None),
				new PreID(OpCodes.Shr, OpX.ShiftRight, OpXFlags.None),
				new PreID(OpCodes.Shr_Un, OpX.ShiftRight, OpXFlags.None),
				new PreID(OpCodes.Sizeof, OpX.PushSizeOf, OpXFlags.None),
				new PreID(OpCodes.Starg, OpX.ArgPush, OpXFlags.None),
				new PreID(OpCodes.Starg_S, OpX.ArgPush, OpXFlags.None),
				new PreID(OpCodes.Stelem, OpX.SetElement, OpXFlags.ToOtherType),
				new PreID(OpCodes.Stelem_I, OpX.SetElement, OpXFlags.ToNativeInt),
				new PreID(OpCodes.Stelem_I1, OpX.SetElement, OpXFlags.FromSigned | OpXFlags.ToInt8),
				new PreID(OpCodes.Stelem_I2, OpX.SetElement, OpXFlags.FromSigned | OpXFlags.ToInt16),
				new PreID(OpCodes.Stelem_I4, OpX.SetElement, OpXFlags.FromSigned | OpXFlags.ToInt32),
				new PreID(OpCodes.Stelem_I8, OpX.SetElement, OpXFlags.FromSigned | OpXFlags.ToInt64),
				new PreID(OpCodes.Stelem_R4, OpX.SetElement, OpXFlags.ToFloat32),
				new PreID(OpCodes.Stelem_R8, OpX.SetElement, OpXFlags.ToFloat64),
				new PreID(OpCodes.Stelem_Ref, OpX.SetElement, OpXFlags.ToReference),
				new PreID(OpCodes.Stfld, OpX.SetField, OpXFlags.None),
				new PreID(OpCodes.Stind_I, OpX.SetValueAtAddr, OpXFlags.ToNativeInt),
				new PreID(OpCodes.Stind_I1, OpX.SetValueAtAddr, OpXFlags.FromSigned | OpXFlags.ToInt8),
				new PreID(OpCodes.Stind_I2, OpX.SetValueAtAddr, OpXFlags.FromSigned | OpXFlags.ToInt16),
				new PreID(OpCodes.Stind_I4, OpX.SetValueAtAddr, OpXFlags.FromSigned | OpXFlags.ToInt32),
				new PreID(OpCodes.Stind_I8, OpX.SetValueAtAddr, OpXFlags.FromSigned | OpXFlags.ToInt64),
				new PreID(OpCodes.Stind_R4, OpX.SetValueAtAddr, OpXFlags.ToFloat32),
				new PreID(OpCodes.Stind_R8, OpX.SetValueAtAddr, OpXFlags.ToFloat64),
				new PreID(OpCodes.Stind_Ref, OpX.SetValueAtAddr, OpXFlags.ToReference),
				new PreID(OpCodes.Stloc, OpX.SetLocal, OpXFlags.FromArg),
				new PreID(OpCodes.Stloc_S, OpX.SetLocal, OpXFlags.FromArg),
				new PreID(OpCodes.Stloc_0, OpX.SetLocal, OpXFlags.C0),
				new PreID(OpCodes.Stloc_1, OpX.SetLocal, OpXFlags.C1),
				new PreID(OpCodes.Stloc_2, OpX.SetLocal, OpXFlags.C2),
				new PreID(OpCodes.Stloc_3, OpX.SetLocal, OpXFlags.C3),
				new PreID(OpCodes.Stobj, OpX.SetValueAtAddr, OpXFlags.None),
				new PreID(OpCodes.Stsfld, OpX.SetStaticField, OpXFlags.None),
				new PreID(OpCodes.Sub, OpX.Sub, OpXFlags.FromSigned | OpXFlags.AllowOverflow),
				new PreID(OpCodes.Sub_Ovf, OpX.Sub, OpXFlags.ThrowOnOverFlow | OpXFlags.FromSigned),
				new PreID(OpCodes.Sub_Ovf_Un, OpX.Sub, OpXFlags.ThrowOnOverFlow | OpXFlags.FromUnsigned),
				new PreID(OpCodes.Switch, OpX.Switch, OpXFlags.None),
				new PreID(OpCodes.Tailcall, OpX.TailCall, OpXFlags.None),
				new PreID(OpCodes.Throw, OpX.Throw, OpXFlags.None),
				new PreID(OpCodes.Unaligned, OpX.Unaligned, OpXFlags.None),
				new PreID(OpCodes.Unbox, OpX.Unbox, OpXFlags.ToOwnType),
				new PreID(OpCodes.Unbox_Any, OpX.Unbox, OpXFlags.ToOtherType),
				new PreID(OpCodes.Volatile, OpX.Volatile, OpXFlags.None),
				new PreID(OpCodes.Xor, OpX.Xor, OpXFlags.None)
			};
			int num = array.Length;
			opCodes = new OpCode[num];
			opXIDsByValue = new Dictionary<short, OpXID>(num);
			opXIDsByPair = new Dictionary<OpXFlagsPair, OpXID>(num);
			OpXID.Emitter emitter = delegate(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(opCodes[oi.id.codeIdx]);
			};
			OpXID.Emitter emitter2 = delegate(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(opCodes[oi.id.codeIdx], oi.arg.@byte);
			};
			OpXID.Emitter emitter3 = delegate(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(opCodes[oi.id.codeIdx], oi.arg.@short);
			};
			OpXID.Emitter emitter4 = delegate(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(opCodes[oi.id.codeIdx], oi.arg.@int);
			};
			OpXID.Emitter emitter5 = delegate(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(opCodes[oi.id.codeIdx], oi.arg.@long);
			};
			OpXID.Emitter emitter6 = delegate(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(opCodes[oi.id.codeIdx], ls[oi.arg.@int]);
			};
			OpXID.Emitter emitter7 = delegate(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(opCodes[oi.id.codeIdx], ((MethodInfo)oi.member) ?? ((MethodInfo)mo.ResolveMethod(oi.arg.@int)));
			};
			OpXID.Emitter emitter8 = delegate(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(opCodes[oi.id.codeIdx], ((ConstructorInfo)oi.member) ?? ((ConstructorInfo)mo.ResolveMethod(oi.arg.@int)));
			};
			OpXID.Emitter emitter9 = delegate(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(opCodes[oi.id.codeIdx], ((FieldInfo)oi.member) ?? mo.ResolveField(oi.arg.@int));
			};
			OpXID.Emitter emitter10 = delegate(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(opCodes[oi.id.codeIdx], ((Type)oi.member) ?? mo.ResolveType(oi.arg.@int));
			};
			OpXID.Emitter emit = delegate(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.DeclareLocal(((Type)oi.member) ?? mo.ResolveType(oi.arg.@int));
			};
			OpXID.Emitter emit2 = delegate(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				ls = new Dictionary<int, Label>(oi.arg.@int);
			};
			OpXID.Emitter emit3 = delegate(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				ls[oi.arg] = g.DefineLabel();
			};
			OpXID.Emitter emit4 = delegate(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				ls = new Dictionary<int, Label>(oi.arg.@int);
			};
			if (<>c.<>9__89_14 == null)
			{
				<>c.<>9__89_14 = delegate(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
				{
					cs = new Label[oi.arg.@int];
				};
			}
			OpXID.Emitter emit5 = delegate(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				cs[oi.arg.int0] = ls[oi.arg.int1];
			};
			OpXID.Emitter emit6 = delegate(ILGenerator g, OpXInst oi, ref Dictionary<int, Label> ls, ref Label[] cs, Module mo)
			{
				g.Emit(OpCodes.Switch, cs);
				cs = null;
			};
			for (int i = 0; i < num; i++)
			{
				int opLength = (((array[i].code.Value & 0xFF00) == 0) ? 1 : 2);
				int argLength = 0;
				OpXID.Emitter emitter11 = null;
				switch (array[i].code.OperandType)
				{
				case OperandType.ShortInlineBrTarget:
				case OperandType.ShortInlineI:
				case OperandType.ShortInlineVar:
					array[i].pair.flags |= OpXFlags.Int8Arg;
					emitter11 = emitter2;
					break;
				case OperandType.InlineVar:
					array[i].pair.flags |= OpXFlags.Int16Arg;
					emitter11 = emitter3;
					break;
				case OperandType.InlineBrTarget:
				case OperandType.InlineField:
				case OperandType.InlineI:
				case OperandType.InlineMethod:
				case OperandType.InlineSig:
				case OperandType.InlineString:
				case OperandType.InlineSwitch:
				case OperandType.InlineTok:
				case OperandType.InlineType:
				case OperandType.ShortInlineR:
					array[i].pair.flags |= OpXFlags.Int32Arg;
					emitter11 = emitter4;
					break;
				case OperandType.InlineI8:
				case OperandType.InlineR:
					array[i].pair.flags |= OpXFlags.Int64Arg;
					emitter11 = emitter5;
					break;
				default:
					emitter11 = emitter;
					break;
				}
				switch (array[i].pair.op)
				{
				case OpX.Branch:
					emitter11 = emitter6;
					break;
				case OpX.Box:
				case OpX.Cast:
				case OpX.InitValue:
				case OpX.IsInst:
				case OpX.Unbox:
					emitter11 = emitter10;
					break;
				case OpX.PushField:
				case OpX.SetField:
					emitter11 = emitter9;
					break;
				case OpX.Call:
					emitter11 = emitter7;
					break;
				case OpX.PushElement:
					if ((array[i].pair.flags & (OpXFlags.FromAddress | OpXFlags.ToOtherType)) != OpXFlags.None)
					{
						emitter11 = emitter10;
					}
					break;
				case OpX.PushNewObject:
					emitter11 = emitter8;
					break;
				}
				opCodes[i] = array[i].code;
				OpXID value = new OpXID(array[i].pair.op, array[i].pair.flags, i, opLength, argLength, emitter11);
				opXIDsByValue[array[i].code.Value] = value;
				opXIDsByPair[array[i].pair] = value;
			}
			declareLocalOp = new OpXID(OpX.DeclareLocal, OpXFlags.None, -1, 0, 0, emit);
			labelCountOp = new OpXID(OpX.LabelCount, OpXFlags.None, -1, 0, 0, emit2);
			labelOp = new OpXID(OpX.Label, OpXFlags.None, -1, 0, 0, emit3);
			caseOp = new OpXID(OpX.Case, OpXFlags.None, -1, 0, 4, emit5);
			endSwitchOp = new OpXID(OpX.EndSwitch, OpXFlags.None, -1, 0, 0, emit6);
			markLabelOp = new OpXID(OpX.MarkLabel, OpXFlags.None, -1, 0, 0, emit4);
		}

		public static IEnumerable<OpXInst> ParseIL(this MethodInfo method, Type[] typeGenArgs, Type[] methodGenArgs, params OpXFlagsPair[] selectors)
		{
			return ParseIL(method, null, typeGenArgs, methodGenArgs, selectors).GetPrestepped();
		}

		private static IEnumerable<OpXInst> ParseIL(MethodInfo method, byte[] il, Type[] typeGenArgs, Type[] methodGenArgs, OpXFlagsPair[] selectors)
		{
			RetainOpXPrecache();
			IList<LocalVariableInfo> locals = method.GetMethodBody().LocalVariables;
			if (il == null)
			{
				il = method.GetMethodBody().GetILAsByteArray();
			}
			bool selecting = selectors != null && selectors.Length != 0;
			OpXID switchOpID = opXIDsByValue[OpCodes.Switch.Value];
			yield return default(OpXInst);
			int j = 0;
			int m = locals.Count;
			while (j < m)
			{
				yield return new OpXInst(declareLocalOp, 0, locals[j].LocalType.MetadataToken, locals[j].LocalType);
				int num = j + 1;
				j = num;
			}
			short value;
			int valueSize;
			OpXID id;
			int argSize;
			if (!selecting || CheckSelected(switchOpID, selectors))
			{
				if (!selecting || CheckSelected(labelCountOp, selectors))
				{
					int num2 = 0;
					int num3 = 0;
					int num4 = il.Length;
					while (num3 < num4)
					{
						StepILParse(num3, il, out value, out valueSize, out id, out argSize);
						num3 += valueSize;
						switch (id.id.op)
						{
						case OpX.Branch:
							num2++;
							break;
						case OpX.Switch:
						{
							int num5 = ParseILArg(num3, il, id.id.flags);
							num2 += num5;
							num3 += num5 * 4;
							break;
						}
						}
						num3 += argSize;
					}
					yield return new OpXInst(labelCountOp, 0, num2);
				}
				if (!selecting || CheckSelected(labelOp, selectors))
				{
					m = 0;
					j = il.Length;
					while (m < j)
					{
						StepILParse(m, il, out value, out valueSize, out id, out argSize);
						m += valueSize;
						switch (id.id.op)
						{
						case OpX.Branch:
						{
							primitive primitive2 = ParseILArg(m, il, id.id.flags);
							int num7 = (((id.id.flags & (OpXFlags.Int8Arg | OpXFlags.Int16Arg | OpXFlags.Int32Arg | OpXFlags.Int64Arg)) == OpXFlags.Int8Arg) ? primitive2.@sbyte : primitive2.@int);
							yield return new OpXInst(labelOp, m, m + argSize + num7);
							break;
						}
						case OpX.Switch:
						{
							int caseCount2 = ParseILArg(m, il, id.id.flags);
							int origin2 = m + argSize + caseCount2 * 4;
							int ci2 = 0;
							while (ci2 < caseCount2)
							{
								int startIndex = m + argSize + ci2 * 4;
								int num6 = BitConverter.ToInt32(il, startIndex);
								yield return new OpXInst(labelOp, m, origin2 + num6);
								int num = ci2 + 1;
								ci2 = num;
							}
							m += caseCount2 * 4;
							break;
						}
						}
						m += argSize;
					}
				}
			}
			j = 0;
			m = il.Length;
			while (j < m)
			{
				StepILParse(j, il, out value, out valueSize, out id, out argSize);
				primitive arg = ParseILArg(j + valueSize, il, id.id.flags);
				MemberInfo member = null;
				switch (id.id.op)
				{
				case OpX.Branch:
				{
					int num8 = j + valueSize + argSize;
					switch (id.id.flags & (OpXFlags.Int8Arg | OpXFlags.Int16Arg | OpXFlags.Int32Arg | OpXFlags.Int64Arg))
					{
					case OpXFlags.Int8Arg:
						arg.@sbyte += (sbyte)num8;
						break;
					case OpXFlags.Int16Arg:
						arg.@short += (short)num8;
						break;
					case OpXFlags.Int32Arg:
						arg.@int += num8;
						break;
					case OpXFlags.Int64Arg:
						arg.@long += num8;
						break;
					}
					break;
				}
				case OpX.Box:
				case OpX.Cast:
				case OpX.InitValue:
				case OpX.IsInst:
					member = method.Module.ResolveType(arg.@int, typeGenArgs, methodGenArgs);
					break;
				case OpX.PushField:
				case OpX.SetField:
					member = method.Module.ResolveField(arg.@int, typeGenArgs, methodGenArgs);
					break;
				case OpX.Call:
					member = method.Module.ResolveMethod(arg.@int, typeGenArgs, methodGenArgs);
					break;
				}
				if (!selecting || CheckSelected(id, selectors))
				{
					yield return new OpXInst(id, j, arg, member);
				}
				j += valueSize;
				OpX op = id.id.op;
				if (op == OpX.Switch)
				{
					int origin2 = ParseILArg(j, il, id.id.flags);
					if (CheckSelected(caseOp, selectors))
					{
						int caseCount2 = j + argSize + origin2 * 4;
						int ci2 = 0;
						while (ci2 < origin2)
						{
							int num9 = j + argSize + ci2 * 4;
							int num10 = BitConverter.ToInt32(il, num9);
							yield return new OpXInst(caseOp, num9, new primitive(ci2, caseCount2 + num10));
							int num = ci2 + 1;
							ci2 = num;
						}
					}
					yield return new OpXInst(endSwitchOp, j);
					j += origin2 * 4;
				}
				j += argSize;
			}
		}

		public static bool CheckSelected(OpXID id, OpXFlagsPair[] selectors)
		{
			int i = 0;
			for (int num = selectors.Length; i < num; i++)
			{
				if (selectors[i].op != id.id.op)
				{
					continue;
				}
				if ((selectors[i].flags & OpXFlags.AtLeast) != OpXFlags.None)
				{
					OpXFlags opXFlags = selectors[i].flags & ~OpXFlags.AtLeast;
					if ((id.id.flags & opXFlags) == opXFlags)
					{
						return true;
					}
				}
				else if (id.id.flags == selectors[i].flags)
				{
					return true;
				}
			}
			return false;
		}

		private static int GetOpCodeSize(short opCodeValue)
		{
			if ((opCodeValue & 0xFF00) == 0)
			{
				return 1;
			}
			return 2;
		}

		private static void StepILParse(int index, byte[] il, out short value, out int valueSize, out OpXID id, out int argSize)
		{
			value = il[index];
			if (value == 254)
			{
				value = (short)(il[index + 1] | 0xFE00);
				valueSize = 2;
			}
			else
			{
				valueSize = 1;
			}
			try
			{
				id = opXIDsByValue[value];
			}
			catch (KeyNotFoundException)
			{
				string text = null;
				FieldInfo[] fields = typeof(OpCodes).GetFields(BindingFlags.Static);
				int num = 0;
				while (true)
				{
					if (num < fields.Length)
					{
						OpCode opCode = (OpCode)fields[num].GetValue(null);
						if (opCode.Value == value)
						{
							text = opCode.Name;
							break;
						}
						num++;
						continue;
					}
					text = value.ToString();
					break;
				}
				UnityEngine.Debug.LogErrorFormat("ReflectionX.ParseIL() hit unrecognised op code {0} at {1:X4}! Substituted Nop.", text, index);
				id = opXIDsByValue[OpCodes.Nop.Value];
			}
			switch (id.id.flags & (OpXFlags.Int8Arg | OpXFlags.Int16Arg | OpXFlags.Int32Arg | OpXFlags.Int64Arg))
			{
			default:
				argSize = 0;
				break;
			case OpXFlags.Int8Arg:
				argSize = 1;
				break;
			case OpXFlags.Int16Arg:
				argSize = 2;
				break;
			case OpXFlags.Int32Arg:
				argSize = 4;
				break;
			case OpXFlags.Int64Arg:
				argSize = 8;
				break;
			}
		}

		private static primitive ParseILArg(int index, byte[] il, OpXFlags flags)
		{
			return (flags & (OpXFlags.Int8Arg | OpXFlags.Int16Arg | OpXFlags.Int32Arg | OpXFlags.Int64Arg)) switch
			{
				OpXFlags.Int8Arg => (sbyte)il[index], 
				OpXFlags.Int16Arg => BitConverter.ToInt16(il, index), 
				OpXFlags.Int32Arg => BitConverter.ToInt32(il, index), 
				OpXFlags.Int64Arg => BitConverter.ToInt64(il, index), 
				_ => (flags & (OpXFlags.CM1 | OpXFlags.C0 | OpXFlags.C1 | OpXFlags.C2 | OpXFlags.C3 | OpXFlags.C4 | OpXFlags.C5 | OpXFlags.C6 | OpXFlags.C7 | OpXFlags.C8)) switch
				{
					OpXFlags.CM1 => -1, 
					OpXFlags.C0 => 0, 
					OpXFlags.C1 => 1, 
					OpXFlags.C2 => 2, 
					OpXFlags.C3 => 3, 
					OpXFlags.C4 => 4, 
					OpXFlags.C5 => 5, 
					OpXFlags.C6 => 6, 
					OpXFlags.C7 => 7, 
					OpXFlags.C8 => 8, 
					_ => default(primitive), 
				}, 
			};
		}

		public static IEnumerable<OpXInst> Substitute(this IEnumerable<OpXInst> opInsts, FieldInfo oldField, FieldInfo newField, StringBuilder log = null)
		{
			log.LogBeginSubstitution(MemberTypes.Field, oldField, newField);
			if (oldField == null || newField == null)
			{
				foreach (OpXInst opInst in opInsts)
				{
					yield return opInst;
				}
				yield break;
			}
			foreach (OpXInst opInst2 in opInsts)
			{
				OpX op = opInst2.id.id.op;
				if ((op == OpX.PushField || op == OpX.SetField) && opInst2.member == oldField)
				{
					log.LogSubstitution(oldField, newField, opInst2);
					yield return new OpXInst(opInst2.id, opInst2.index, newField.MetadataToken, newField);
				}
				else
				{
					yield return opInst2;
				}
			}
		}

		public static IEnumerable<OpXInst> Substitute(this IEnumerable<OpXInst> opInsts, Type oldType, Type newType, bool includeMembers = true, StringBuilder log = null)
		{
			log.LogBeginSubstitution(MemberTypes.TypeInfo, oldType, newType);
			if (oldType == null || newType == null)
			{
				foreach (OpXInst opInst in opInsts)
				{
					yield return opInst;
				}
				yield break;
			}
			if (includeMembers)
			{
				foreach (OpXInst opInst2 in opInsts)
				{
					switch (opInst2.id.id.op)
					{
					case OpX.Box:
					case OpX.Cast:
					case OpX.InitValue:
					case OpX.IsInst:
					case OpX.DeclareLocal:
						if (opInst2.member == oldType)
						{
							log.LogSubstitution(oldType, newType, opInst2);
							yield return new OpXInst(opInst2.id, opInst2.index, newType.MetadataToken, newType);
							continue;
						}
						break;
					case OpX.PushField:
					case OpX.SetField:
						if (opInst2.member.DeclaringType == oldType)
						{
							FieldInfo fieldInfo = (FieldInfo)opInst2.member;
							BindingFlags bindingFlags2 = BindingFlags.DeclaredOnly;
							bindingFlags2 |= (((fieldInfo.Attributes & FieldAttributes.Public) != 0) ? BindingFlags.Public : BindingFlags.NonPublic);
							bindingFlags2 |= (((fieldInfo.Attributes & FieldAttributes.Static) != 0) ? BindingFlags.Static : BindingFlags.Instance);
							FieldInfo field = newType.GetField(fieldInfo.Name, bindingFlags2);
							log.LogSubstitution(fieldInfo, field, opInst2);
							yield return new OpXInst(opInst2.id, opInst2.index, field.MetadataToken, field);
							continue;
						}
						break;
					case OpX.Call:
						if (opInst2.member.DeclaringType == oldType)
						{
							MethodInfo methodInfo = (MethodInfo)opInst2.member;
							BindingFlags bindingFlags = BindingFlags.DeclaredOnly;
							bindingFlags |= (((methodInfo.Attributes & MethodAttributes.Public) != 0) ? BindingFlags.Public : BindingFlags.NonPublic);
							bindingFlags |= (((methodInfo.Attributes & MethodAttributes.Static) != 0) ? BindingFlags.Static : BindingFlags.Instance);
							MethodInfo method = newType.GetMethod(methodInfo.Name, bindingFlags);
							log.LogSubstitution(methodInfo, method, opInst2);
							yield return new OpXInst(opInst2.id, opInst2.index, method.MetadataToken, method);
							continue;
						}
						break;
					}
					yield return opInst2;
				}
				yield break;
			}
			foreach (OpXInst opInst3 in opInsts)
			{
				switch (opInst3.id.id.op)
				{
				case OpX.Box:
				case OpX.Cast:
				case OpX.InitValue:
				case OpX.IsInst:
				case OpX.DeclareLocal:
					if (opInst3.member == oldType)
					{
						log.LogSubstitution(oldType, newType, opInst3);
						yield return new OpXInst(opInst3.id, opInst3.index, newType.MetadataToken, newType);
						continue;
					}
					break;
				}
				yield return opInst3;
			}
		}

		public static IEnumerable<OpXInst> Substitute(this IEnumerable<OpXInst> opInsts, MethodInfo oldMethod, MethodInfo newMethod, StringBuilder log = null)
		{
			log.LogBeginSubstitution(MemberTypes.Method, oldMethod, newMethod);
			if (oldMethod == null || newMethod == null)
			{
				foreach (OpXInst opInst in opInsts)
				{
					yield return opInst;
				}
				yield break;
			}
			foreach (OpXInst opInst2 in opInsts)
			{
				OpX op = opInst2.id.id.op;
				if (op == OpX.Call && opInst2.member == oldMethod)
				{
					log.LogSubstitution(oldMethod, newMethod, opInst2);
					yield return new OpXInst(opInst2.id, opInst2.index, newMethod.MetadataToken, newMethod);
				}
				else
				{
					yield return opInst2;
				}
			}
		}

		private static void LogBeginSubstitution(this StringBuilder log, MemberTypes memType, MemberInfo oldMem, MemberInfo newMem)
		{
			log?.AppendFormat("Begun substituting {0} {1}.{2} for {3}.{4}\n", (oldMem != null) ? oldMem.MemberType : memType, (oldMem != null && oldMem.DeclaringType != null) ? oldMem.DeclaringType.Name : null, (oldMem != null) ? oldMem.Name : "null", (newMem != null && newMem.DeclaringType != null) ? newMem.DeclaringType.Name : null, (newMem != null) ? newMem.Name : "null");
		}

		private static void LogSubstitution(this StringBuilder log, MemberInfo oldMem, MemberInfo newMem, OpXInst opInst)
		{
			log?.AppendFormat("Substituted {0} {1}.{2} for {3}.{4} at IL_{5:X4} ({6} {7})\n", oldMem.MemberType, (oldMem.DeclaringType != null) ? oldMem.DeclaringType.Name : null, oldMem.Name, (newMem.DeclaringType != null) ? newMem.DeclaringType.Name : null, newMem.Name, opInst.index, opInst.id.id.op, opInst.id.id.flags);
		}

		public static IEnumerable<MemberXInst> Parse(this Type type, MemberX include = (MemberX)(-1))
		{
			if (type.IsGenericTypeDefinition || type.ContainsGenericParameters || type.IsPrimitive || !(type != typeof(object)))
			{
				yield break;
			}
			if ((include & (MemberX)3) != 0)
			{
				Type[] interfaces3 = type.GetInterfaces();
				int i = 0;
				for (int num = interfaces3.Length; i < num; i++)
				{
					if (interfaces3[i].IsGenericTypeDefinition)
					{
						interfaces3[i] = interfaces3[i].MakeGenericType(type.GetGenericArguments());
					}
				}
				if ((include & MemberX.InterfaceCount) != 0)
				{
					yield return new MemberXInst(MemberX.InterfaceCount, interfaces3.Length);
				}
				if ((include & MemberX.Interface) != 0)
				{
					Type[] array = interfaces3;
					foreach (Type info in array)
					{
						yield return new MemberXInst(MemberX.Interface, info);
					}
				}
			}
			if ((include & (MemberX)2044) != 0)
			{
				FieldInfo[] fields = type.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
				if ((include & MemberX.FieldCount) != 0)
				{
					yield return new MemberXInst(MemberX.FieldCount, fields.Length);
				}
				if ((include & (MemberX)2040) != 0)
				{
					FieldInfo[] array2 = fields;
					foreach (FieldInfo field in array2)
					{
						if ((include & MemberX.Field) != 0)
						{
							yield return new MemberXInst(MemberX.Field, field);
						}
						if ((include & MemberX.FieldName) != 0)
						{
							yield return new MemberXInst(MemberX.FieldName, field.Name);
						}
						if ((include & MemberX.FieldType) != 0)
						{
							yield return new MemberXInst(MemberX.FieldType, field.FieldType);
						}
						if ((include & (MemberX)192) != 0)
						{
							Type[] interfaces3 = field.GetRequiredCustomModifiers();
							if ((include & MemberX.FieldReqModCount) != 0)
							{
								yield return new MemberXInst(MemberX.FieldReqModCount, interfaces3.Length);
							}
							if ((include & MemberX.FieldReqMod) != 0)
							{
								Type[] array = interfaces3;
								foreach (Type info2 in array)
								{
									yield return new MemberXInst(MemberX.FieldReqMod, info2);
								}
							}
						}
						if ((include & (MemberX)768) != 0)
						{
							Type[] interfaces3 = field.GetOptionalCustomModifiers();
							if ((include & MemberX.FieldOptModCount) != 0)
							{
								yield return new MemberXInst(MemberX.FieldOptModCount, interfaces3.Length);
							}
							if ((include & MemberX.FieldOptMod) != 0)
							{
								Type[] array = interfaces3;
								foreach (Type info3 in array)
								{
									yield return new MemberXInst(MemberX.FieldOptMod, info3);
								}
							}
						}
						if ((include & MemberX.FieldAttribs) != 0)
						{
							yield return new MemberXInst(MemberX.FieldAttribs, field.Attributes);
						}
					}
				}
			}
			if ((include & (MemberX)63488) != 0)
			{
				PropertyInfo[] properties = type.GetProperties(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
				if ((include & MemberX.PropertyCount) != 0)
				{
					yield return new MemberXInst(MemberX.PropertyCount, properties.Length);
				}
				if ((include & (MemberX)61440) != 0)
				{
					PropertyInfo[] array3 = properties;
					foreach (PropertyInfo property in array3)
					{
						if ((include & MemberX.Property) != 0)
						{
							yield return new MemberXInst(MemberX.Property, property);
						}
						if ((include & MemberX.PropertyName) != 0)
						{
							yield return new MemberXInst(MemberX.PropertyName, property.Name);
						}
						if ((include & MemberX.PropertyType) != 0)
						{
							yield return new MemberXInst(MemberX.PropertyType, property.PropertyType);
						}
						if ((include & MemberX.PropertyAttribs) != 0)
						{
							yield return new MemberXInst(MemberX.PropertyAttribs, property.Attributes);
						}
					}
				}
			}
			if ((include & (MemberX)14090240) == 0)
			{
				yield break;
			}
			MethodInfo[] methods = type.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			if ((include & MemberX.MethodCount) != 0)
			{
				int num2 = 0;
				MethodInfo[] array4 = methods;
				foreach (MethodInfo methodInfo in array4)
				{
					if (!methodInfo.IsGenericMethod && !methodInfo.ContainsGenericParameters && !methodInfo.IsGenericMethodDefinition)
					{
						num2++;
					}
				}
				yield return new MemberXInst(MemberX.MethodCount, num2);
			}
			if ((include & (MemberX)14024704) == 0)
			{
				yield break;
			}
			MethodInfo[] array5 = methods;
			foreach (MethodInfo methodInfo2 in array5)
			{
				if (methodInfo2.IsGenericMethod || methodInfo2.ContainsGenericParameters || methodInfo2.IsGenericMethodDefinition)
				{
					continue;
				}
				foreach (MemberXInst item in methodInfo2.Parse(include))
				{
					yield return item;
				}
			}
		}

		public static IEnumerable<MemberXInst> Parse(this MethodInfo method, MemberX include = (MemberX)(-1))
		{
			if ((include & MemberX.Method) != 0)
			{
				yield return new MemberXInst(MemberX.Method, method);
			}
			if ((include & MemberX.MethodName) != 0)
			{
				yield return new MemberXInst(MemberX.MethodName, method.Name);
			}
			if ((include & MemberX.MethodReturnType) != 0)
			{
				yield return new MemberXInst(MemberX.MethodReturnType, method.ReturnType);
			}
			if ((include & MemberX.MethodAttribs) != 0)
			{
				yield return new MemberXInst(MemberX.MethodAttribs, method.Attributes);
			}
			if ((include & MemberX.MethodConventions) != 0)
			{
				yield return new MemberXInst(MemberX.MethodConventions, method.CallingConvention);
			}
			if ((include & (MemberX)12582912) == 0)
			{
				yield break;
			}
			ParameterInfo[] @params = method.GetParameters();
			if ((include & MemberX.MethodParamCount) != 0)
			{
				yield return new MemberXInst(MemberX.MethodParamCount, @params.Length);
			}
			if ((include & MemberX.MethodParam) != 0)
			{
				ParameterInfo[] array = @params;
				foreach (ParameterInfo parameterInfo in array)
				{
					yield return new MemberXInst(MemberX.MethodParam, parameterInfo.ParameterType);
				}
			}
		}

		public static IEnumerable<MemberXInst> Substitute<T>(this IEnumerable<MemberXInst> source, T oldT, T newT) where T : MemberInfo
		{
			foreach (MemberXInst item in source)
			{
				switch (item.mem)
				{
				case MemberX.Interface:
				case MemberX.FieldType:
				case MemberX.PropertyType:
				case MemberX.MethodReturnType:
				case MemberX.MethodParam:
					if (item.details.token == oldT.MetadataToken)
					{
						yield return new MemberXInst(item.mem, newT.MetadataToken);
						continue;
					}
					break;
				}
				yield return item;
			}
		}
	}
	public interface IResettableEnumerator : IEnumerator, IEnumerable
	{
	}
	public class ResettableEnumerable : IEnumerable
	{
		protected class Enumerator : IResettableEnumerator, IEnumerator, IEnumerable
		{
			public readonly IEnumerator enumerator;

			private readonly ResettableEnumerable enumerable;

			public object Current => enumerator.Current;

			public Enumerator(ResettableEnumerable enumerable, IEnumerator enumerator = null)
			{
				this.enumerable = enumerable;
				this.enumerator = enumerator ?? enumerable.enumerable.GetEnumerator();
			}

			public IEnumerator GetEnumerator()
			{
				Reset();
				return this;
			}

			public bool MoveNext()
			{
				return enumerator.MoveNext();
			}

			public void Reset()
			{
				enumerable.Reset(this);
			}
		}

		private readonly IEnumerable enumerable;

		protected FieldInfo sourcePC;

		protected object resetPoint;

		protected readonly bool stepAfterReset;

		public ResettableEnumerable(IEnumerable enumerable, bool stepAfterReset = false)
		{
			this.enumerable = enumerable;
			this.stepAfterReset = stepAfterReset;
		}

		public IResettableEnumerator GetEnumerator()
		{
			Enumerator enumerator = new Enumerator(this);
			SetUp(enumerator);
			return enumerator;
		}

		protected void SetUp(Enumerator enumerator)
		{
			if (sourcePC == null)
			{
				sourcePC = enumerator.enumerator.GetType().GetField("<>1__state", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				resetPoint = sourcePC.GetValue(enumerator.enumerator);
			}
			if (stepAfterReset)
			{
				enumerator.MoveNext();
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public bool Reset(IEnumerator enumerator)
		{
			if (!(enumerator is Enumerator resettable))
			{
				return false;
			}
			Reset(resettable);
			return true;
		}

		private void Reset(Enumerator resettable)
		{
			sourcePC.SetValue(resettable.enumerator, resetPoint);
			if (stepAfterReset)
			{
				resettable.enumerator.MoveNext();
			}
		}
	}
	public interface IResettableEnumerator<T> : IEnumerator<T>, IEnumerator, IDisposable, IEnumerable<T>, IEnumerable, IResettableEnumerator
	{
	}
	public class ResettableEnumerable<T> : ResettableEnumerable, IEnumerable<T>, IEnumerable
	{
		private new class Enumerator : ResettableEnumerable.Enumerator, IResettableEnumerator<T>, IEnumerator<T>, IEnumerator, IDisposable, IEnumerable<T>, IEnumerable, IResettableEnumerator
		{
			public new readonly IEnumerator<T> enumerator;

			private readonly ResettableEnumerable<T> enumerable;

			public new T Current => enumerator.Current;

			public Enumerator(ResettableEnumerable<T> enumerable, IEnumerator<T> enumerator = null)
				: base(enumerable, enumerator = enumerable.enumerable.GetEnumerator())
			{
				this.enumerable = enumerable;
				this.enumerator = enumerator;
			}

			public void Dispose()
			{
			}

			public new IEnumerator<T> GetEnumerator()
			{
				Reset();
				return this;
			}
		}

		private readonly IEnumerable<T> enumerable;

		public ResettableEnumerable(IEnumerable<T> enumerable, bool stepAfterReset = false)
			: base(enumerable, stepAfterReset)
		{
			this.enumerable = enumerable;
		}

		public new IResettableEnumerator<T> GetEnumerator()
		{
			Enumerator enumerator = new Enumerator(this);
			SetUp(enumerator);
			return enumerator;
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	[Flags]
	public enum SaveLoadResult
	{
		None = 0,
		Pending = 1,
		Init = 2,
		Metadata = 4,
		Save = 8,
		Load = 0x10,
		Delete = 0x20,
		Success = 0x40,
		Failure = 0x80,
		Busy = 0x100,
		Subsystem = 0x200,
		MissingData = 0x400,
		CorruptedData = 0x800,
		InsufficientSpace = 0x1000,
		Cancelled = 0x2000
	}
	public struct LoadResult
	{
		public SaveLoadResult result;

		public Stream stream;

		public LoadResult(SaveLoadResult result, Stream stream = null)
		{
			this.result = result;
			this.stream = stream;
		}

		public static implicit operator LoadResult(SaveLoadResult result)
		{
			return new LoadResult(result);
		}

		public static implicit operator SaveLoadResult(LoadResult lr)
		{
			return lr.result;
		}

		public static LoadResult operator |(LoadResult l, SaveLoadResult r)
		{
			l.result |= r;
			return l;
		}
	}
	public static class SaveLoadResultX
	{
		public static bool Is(this SaveLoadResult res, SaveLoadResult check1, SaveLoadResult check2 = SaveLoadResult.None, SaveLoadResult check3 = SaveLoadResult.None)
		{
			return (res & (check1 | check2 | check3)) != 0;
		}

		public static bool ResultedIn(this SaveLoadResult res, SaveLoadResult check1, SaveLoadResult check2 = SaveLoadResult.None, SaveLoadResult check3 = SaveLoadResult.None)
		{
			return res.Is(check1, check2, check3);
		}

		public static bool Succeeded(this SaveLoadResult res)
		{
			return res.Is(SaveLoadResult.Success);
		}

		public static bool IsSuccess(this SaveLoadResult res)
		{
			return res.Is(SaveLoadResult.Success);
		}

		public static bool Failed(this SaveLoadResult res)
		{
			return res.Is(SaveLoadResult.Failure);
		}

		public static bool IsFailure(this SaveLoadResult res)
		{
			return res.Is(SaveLoadResult.Failure);
		}

		public static bool IsCorrupted(this SaveLoadResult res)
		{
			if (res.Is(SaveLoadResult.Failure))
			{
				return res.Is(SaveLoadResult.CorruptedData);
			}
			return false;
		}

		public static bool IsPending(this SaveLoadResult res)
		{
			return res.Is(SaveLoadResult.Pending);
		}

		public static bool IsNone(this SaveLoadResult res)
		{
			return res == SaveLoadResult.None;
		}

		public static bool Exists(this SaveLoadResult res)
		{
			if (!res.IsPending())
			{
				return !res.IsNone();
			}
			return false;
		}

		public static bool DidNotComplete(this SaveLoadResult res)
		{
			return res.Is(SaveLoadResult.Pending);
		}

		public static bool WillCompleteLater(this SaveLoadResult res)
		{
			return res.Is(SaveLoadResult.Pending);
		}

		public static bool Completed(this SaveLoadResult res)
		{
			if (!res.IsPending())
			{
				return !res.IsNone();
			}
			return false;
		}
	}
	public static class SceneX
	{
		public static bool IsAncestorOf(this UnityEngine.Component a, UnityEngine.Component c)
		{
			Transform parent = c.transform.parent;
			while ((object)parent != null)
			{
				if ((object)parent == a)
				{
					return true;
				}
				parent = parent.parent;
			}
			return false;
		}

		public static UnityEngine.Component GetClosestInAncestry<TA, TB>(this UnityEngine.Component c, out TA aa, out TB ab, bool includeSelf) where TA : UnityEngine.Component where TB : UnityEngine.Component
		{
			aa = null;
			ab = null;
			Transform transform = (includeSelf ? c.transform : c.transform.parent);
			while (transform != null)
			{
				if ((object)(aa = transform.GetComponent<TA>()) != null)
				{
					return aa;
				}
				if ((object)(ab = transform.GetComponent<TB>()) != null)
				{
					return ab;
				}
				transform = transform.parent;
			}
			return null;
		}

		public static void SetLocalPosY(this Transform xform, float y)
		{
			xform.localPosition = xform.localPosition.RepY(y);
		}

		public static IEnumerable<T> FindAll<T>(string sceneName, int rootCap = 10, int depthCap = 10, int perGOCap = 1) where T : UnityEngine.Component
		{
			return _FindAll<T>(sceneName, rootCap, depthCap, perGOCap).GetPrestepped();
		}

		private static IEnumerable<T> _FindAll<T>(string sceneName, int rootCap = 10, int depthCap = 10, int perGOCap = 1) where T : UnityEngine.Component
		{
			List<GameObject> roots = new List<GameObject>(10);
			Stack<KeyValuePair<Transform, int>> stack = new Stack<KeyValuePair<Transform, int>>(depthCap);
			List<T> results = new List<T>(perGOCap);
			yield return null;
			Scene sceneByName = SceneManager.GetSceneByName(sceneName);
			roots.Clear();
			stack.Clear();
			results.Clear();
			sceneByName.GetRootGameObjects(roots);
			int ri = 0;
			int rc = roots.Count;
			while (ri < rc)
			{
				KeyValuePair<Transform, int> value = new KeyValuePair<Transform, int>(roots[ri].transform, 0);
				stack.Push(value);
				int num;
				do
				{
					int ti = value.Value;
					int tc = value.Key.childCount;
					while (ti < tc)
					{
						Transform child = roots[ri].transform.GetChild(ti);
						child.GetComponents(results);
						int ci = 0;
						int cc = results.Count;
						while (ci < cc)
						{
							yield return results[ci];
							num = ci + 1;
							ci = num;
						}
						results.Clear();
						if (child.childCount > 0)
						{
							stack.Push(new KeyValuePair<Transform, int>(child, 0));
							break;
						}
						num = ti + 1;
						ti = num;
					}
				}
				while (CollectionsX.TryPop(stack, out value));
				num = ri + 1;
				ri = num;
			}
			roots.Clear();
			stack.Clear();
			results.Clear();
		}
	}
	public static class ShellCommand
	{
		public static bool Exists(string command, bool defaultTo = false)
		{
			try
			{
				UnityEngine.Debug.LogWarning("Cannot currently check command existance on this platform.");
				return defaultTo;
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError($"Exception when running \"where\" command for \"{command}\": {ex.Message}");
				return defaultTo;
			}
		}

		public static string ExecuteSync(string command, string args)
		{
			try
			{
				ProcessStartInfo processStartInfo = new ProcessStartInfo(command, args);
				processStartInfo.RedirectStandardOutput = true;
				processStartInfo.RedirectStandardError = true;
				processStartInfo.UseShellExecute = false;
				processStartInfo.CreateNoWindow = true;
				Process process = new Process();
				process.StartInfo = processStartInfo;
				process.Start();
				process.WaitForExit();
				return process.StandardOutput.ReadToEnd();
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError($"Exception when running command \"{command}\": {ex.Message}");
			}
			return "";
		}

		public static bool ExecuteASync(string command, string args)
		{
			try
			{
				ProcessStartInfo processStartInfo = new ProcessStartInfo(command, args);
				processStartInfo.RedirectStandardOutput = true;
				processStartInfo.RedirectStandardError = true;
				processStartInfo.UseShellExecute = false;
				processStartInfo.CreateNoWindow = true;
				return new Process
				{
					StartInfo = processStartInfo
				}.Start();
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError($"Exception when running command \"{command}\": {ex.Message}");
			}
			return false;
		}

		public static string ExecuteSyncNoException(string command, string args)
		{
			try
			{
				ProcessStartInfo processStartInfo = new ProcessStartInfo(command, args);
				processStartInfo.RedirectStandardOutput = true;
				processStartInfo.RedirectStandardError = true;
				processStartInfo.UseShellExecute = false;
				processStartInfo.CreateNoWindow = true;
				Process process = new Process();
				process.StartInfo = processStartInfo;
				process.Start();
				process.WaitForExit();
				return process.StandardOutput.ReadToEnd();
			}
			catch
			{
			}
			return "";
		}

		public static bool ExecuteASyncNoException(string command, string args)
		{
			try
			{
				ProcessStartInfo processStartInfo = new ProcessStartInfo(command, args);
				processStartInfo.RedirectStandardOutput = true;
				processStartInfo.RedirectStandardError = true;
				processStartInfo.UseShellExecute = false;
				processStartInfo.CreateNoWindow = true;
				return new Process
				{
					StartInfo = processStartInfo
				}.Start();
			}
			catch
			{
			}
			return false;
		}
	}
	public abstract class SingletonMonoBehaviour<T> : MonoBehaviour where T : SingletonMonoBehaviour<T>
	{
		protected static T _Inst;

		public static T Inst => _Inst ?? (_Inst = UnityEngine.Object.FindObjectOfType<T>());

		public static bool InstExists => _Inst != null;

		protected virtual void Awake()
		{
			if (!(_Inst == this))
			{
				_Inst = (T)this;
			}
		}

		protected virtual void OnDestroy()
		{
			_Inst = null;
		}
	}
	public abstract class SingletonMonoBehaviour<BT, IT> : MonoBehaviour where BT : SingletonMonoBehaviour<BT, IT>, IT
	{
		protected static BT _Inst;

		public static IT Inst => (IT)(_Inst ?? (_Inst = UnityEngine.Object.FindObjectOfType<BT>()));

		public static bool InstExists => _Inst != null;

		protected virtual void Awake()
		{
			if (!(_Inst == this))
			{
				_Inst = (BT)this;
			}
		}

		protected virtual void OnDestroy()
		{
			_Inst = null;
		}
	}
	public static class StringX
	{
		public static string StringSplitIntoLines(string text, int maxCharsInLine)
		{
			StringBuilder stringBuilder = new StringBuilder();
			int num = 0;
			int num2 = 0;
			for (int i = 0; i < text.Length; i++)
			{
				if (char.IsWhiteSpace(text[i]))
				{
					num = i + 1;
				}
				if (i - num2 > maxCharsInLine)
				{
					stringBuilder.Append(text, num2, num - num2);
					stringBuilder.Append("\n");
					num2 = num;
				}
			}
			if (num2 != text.Length)
			{
				stringBuilder.Append(text, num2, text.Length - num2);
			}
			return stringBuilder.ToString();
		}

		public static string RemoveUpToChar(this string str, char chr, bool includeChar = false)
		{
			for (int i = 0; i < str.Length; i++)
			{
				if (str[i] == chr)
				{
					if (includeChar)
					{
						return str.Remove(0, i + 1);
					}
					return str.Remove(0, i);
				}
			}
			return str;
		}

		public static bool IsNullOrWhiteSpace(string str)
		{
			if (string.IsNullOrEmpty(str))
			{
				return true;
			}
			for (int i = 0; i < str.Length; i++)
			{
				if (!char.IsWhiteSpace(str[i]))
				{
					return false;
				}
			}
			return true;
		}

		public static void AddFormat(this IList<string> stringList, string format, params object[] args)
		{
			stringList.Add(string.Format(format, args));
		}

		public static string PrettyName(this Type type)
		{
			StringBuilder stringBuilder = new StringBuilder(64);
			stringBuilder.AppendPrettyName(type);
			return stringBuilder.ToString();
		}

		public static void AppendPrettyName(this StringBuilder builder, Type type)
		{
			builder.Append(type.Name);
			if (type.IsGenericType)
			{
				builder.Remove(builder.Length - 2, 2);
				builder.Append('<');
				Type[] genericArguments = type.GetGenericArguments();
				builder.AppendPrettyName(genericArguments[0]);
				int i = 1;
				for (int num = genericArguments.Length; i < num; i++)
				{
					builder.Append(", ");
					builder.AppendPrettyName(genericArguments[i]);
				}
				builder.Append('>');
			}
			else if (type.IsArray && type.GetArrayRank() > 1)
			{
				builder.Remove(builder.Length - 1, 1);
				for (int j = 1; j < type.GetArrayRank(); j++)
				{
					builder.Append(',');
				}
				builder.Append(']');
			}
		}

		public static int WriteCropped(this TextWriter writer, int size, string str)
		{
			int i = 0;
			for (int num = ((str.Length < size) ? str.Length : size); i < num; i++)
			{
				writer.Write(str[i]);
			}
			return i;
		}

		public static void WriteFixed(this TextWriter writer, int size, string str)
		{
			for (int i = writer.WriteCropped(size, str); i < size; i++)
			{
				writer.Write(' ');
			}
		}

		public static void WriteFixed(this TextWriter writer, int size, string format, object arg0, object arg1 = null, object arg2 = null, object arg3 = null)
		{
			writer.WriteFixed(size, string.Format(format, arg0, arg1, arg2, arg3));
		}

		public static int GetHashCode(this string thisStr, int start, int length)
		{
			int num = start + length;
			int num2 = 0;
			for (int i = start; i < num; i++)
			{
				num2 = (num2 << 5) - (num2 + thisStr[i]);
			}
			return num2;
		}

		[Conditional("CS_DEBUG")]
		[Conditional("CS_TESTING")]
		public static void DebugFormat(ref string outStr, string format, params object[] args)
		{
			outStr = string.Format(format, args);
		}
	}
	[Serializable]
	public class HagletFlag : HagletCondition
	{
		public bool set;

		public override bool isTrue => set;

		public HagletFlag()
		{
		}

		public HagletFlag(bool setIn)
		{
			set = setIn;
		}

		public void Set()
		{
			set = true;
		}

		public void Clear()
		{
			set = false;
		}
	}
	public class TransformAtOrientation : HagletCondition
	{
		public Transform tform;

		public Vector3 worldFwd;

		public Vector3 worldUp;

		public Vector3 localFwd;

		public Vector3 localUp;

		public Transform dirTform;

		public float tol;

		public override bool isTrue
		{
			get
			{
				if (dirTform != null)
				{
					worldFwd = dirTform.forward;
					worldUp = dirTform.up;
				}
				float num = Vector3.Angle(tform.TransformDirection(localFwd), worldFwd);
				float num2 = Vector3.Angle(tform.TransformDirection(localUp), worldUp);
				if (num <= tol)
				{
					return num2 <= tol;
				}
				return false;
			}
		}
	}
	public class TransformAtPosition : HagletCondition
	{
		public Transform tform;

		public Vector3 targWorldPos;

		public Vector3 localOrigin;

		public Transform targTform;

		public float tol;

		public override bool isTrue
		{
			get
			{
				if (targTform != null)
				{
					targWorldPos = targTform.position;
				}
				return Vector3.Distance(tform.TransformPoint(localOrigin), targWorldPos) <= tol;
			}
		}
	}
	[Serializable]
	public class HagletButton : HagletTrigger
	{
		public HagletButton()
			: base(null, null, 50)
		{
		}

		public HagletButton(string name, IOwner owner = null, int listCap = 8)
			: base(name, owner, listCap)
		{
		}
	}
	public interface IHagletTrigger
	{
		void Trigger();
	}
	public class HagletTrigger : HagletEvent, IHagletTrigger
	{
		public HagletTrigger(string name = null, IOwner owner = null, int listCap = 8)
			: base(name, owner, listCap)
		{
		}

		public void Trigger(float deltaTime, bool skipping = false)
		{
			Happen(deltaTime, skipping);
		}

		public void Trigger()
		{
			Happen();
		}
	}
	public abstract class Haglet : IHaglet, IHagletCallable, IHagletTrigger, Wait.IClient, Wait.IUntil, Wait.IFor, HagletEvent.IResponder, HagletEvent.IOwner, IEnumerator
	{
		public enum State
		{
			Stopped,
			Started,
			Paused,
			Completed
		}

		private enum ClauseStatus
		{
			Ready,
			Started,
			Complete,
			Pending,
			EarlyExit,
			Exception,
			AtTotal
		}

		private sealed class Haglet4R<AT0, AT1, AT2, AT3, RT> : Haglet, IHagletReturn<AT0, AT1, AT2, AT3, RT>, IHaglet<AT0, AT1, AT2, AT3>, IHaglet<AT0, AT1, AT2>, IHaglet<AT0, AT1>, IHaglet<AT0>, IHaglet, IHagletCallable, IHagletTrigger, IHagletCallable<AT0>, IHagletCallable<AT0, AT1>, IHagletCallable<AT0, AT1, AT2>, IHagletCallable<AT0, AT1, AT2, AT3>, IHagletReturn<AT0, AT1, AT2, RT>, IHagletReturn<AT0, AT1, RT>, IHagletReturn<AT0, RT>, IHagletReturn<RT>, IHagletCallableReturn<RT>, IHagletCallableReturn<AT0, RT>, IHagletCallableReturn<AT0, AT1, RT>, IHagletCallableReturn<AT0, AT1, AT2, RT>, IHagletCallableReturn<AT0, AT1, AT2, AT3, RT>
		{
			private new readonly HagletDynamicSupport.IServer<AT0, AT1, AT2, AT3, RT> support;

			public AT0 arg0 => support.GetArg0(iterator);

			public AT1 arg1 => support.GetArg1(iterator);

			public AT2 arg2 => support.GetArg2(iterator);

			public AT3 arg3 => support.GetArg3(iterator);

			public RT peekReturnValue => support.GetReturnValue(iterator);

			public RT popReturnValue
			{
				get
				{
					RT returnValue = support.GetReturnValue(iterator);
					support.ClearReturnValue(iterator);
					return returnValue;
				}
			}

			public Haglet4R(IEnumerator<Routine.Yield> iterator, string name, bool startNow, int? initWaitCap, string editorGroup)
				: base(iterator)
			{
				try
				{
					support = (HagletDynamicSupport.IServer<AT0, AT1, AT2, AT3, RT>)base.support;
				}
				catch (InvalidCastException)
				{
					Panic.Haglet.ThrowSupportCastFailure(iterator, base.support);
				}
				if (support != null)
				{
					if (string.IsNullOrEmpty(name))
					{
						name = ((support.defaultName == null) ? "Unnamed" : support.defaultName);
					}
					else if (name.Contains("{0}"))
					{
						name = string.Format(name, support.defaultName);
					}
					base.name = name;
					if (!initWaitCap.HasValue)
					{
						initWaitCap = support.initialWaitCapacity;
					}
					if (initWaitCap.Value > 0)
					{
						clauses = new Clause[initWaitCap.Value];
					}
					HagletValue.Create(out _state, name + " State", State.Stopped, this);
					_state.onPreHappen += delegate
					{
						LogStateChange(_state.value);
					};
					base.owner = support.GetThis(iterator) as MonoBehaviour;
					if (support.usesGoto)
					{
						HagletValue.Create(out _latestGoto, name + " Last Goto", 0, this);
					}
					try
					{
						support.SetArg0(iterator, support.arg0Default);
					}
					catch
					{
					}
					try
					{
						support.SetArg1(iterator, support.arg1Default);
					}
					catch
					{
					}
					try
					{
						support.SetArg2(iterator, support.arg2Default);
					}
					catch
					{
					}
					try
					{
						support.SetArg3(iterator, support.arg3Default);
					}
					catch
					{
					}
					try
					{
						support.GetArg0(iterator);
					}
					catch
					{
					}
					try
					{
						support.GetArg1(iterator);
					}
					catch
					{
					}
					try
					{
						support.GetArg2(iterator);
					}
					catch
					{
					}
					try
					{
						support.GetArg3(iterator);
					}
					catch
					{
					}
					try
					{
						support.SetPCBoxed(iterator, int.MaxValue);
					}
					catch
					{
					}
					try
					{
						iterator.MoveNext();
					}
					catch
					{
					}
					try
					{
						support.ResetLocals(iterator);
					}
					catch
					{
					}
					try
					{
						_ = iterator.Current;
					}
					catch
					{
					}
					if (startNow)
					{
						Start(resetIfStarted: false, skip: false, waitUntilCompleted: false);
					}
				}
			}

			public void SetArg0(AT0 val, primitive? waitID)
			{
				if (!base.stopped && !base.completed && !base.executing)
				{
					support.SetArg0(iterator, val);
					TryExecute(new ExecParams(ExecContext.ArgChange, 0, waitID.HasValue ? waitID.Value : ((primitive)val.GetHashCode())));
				}
			}

			public void SetArg1(AT1 val, primitive? waitID)
			{
				if (!base.stopped && !base.completed && !base.executing)
				{
					support.SetArg1(iterator, val);
					TryExecute(new ExecParams(ExecContext.ArgChange, 1, waitID.HasValue ? waitID.Value : ((primitive)val.GetHashCode())));
				}
			}

			public void SetArg2(AT2 val, primitive? waitID)
			{
				if (!base.stopped && !base.completed && !base.executing)
				{
					support.SetArg2(iterator, val);
					TryExecute(new ExecParams(ExecContext.ArgChange, 2, waitID.HasValue ? waitID.Value : ((primitive)val.GetHashCode())));
				}
			}

			public void SetArg3(AT3 val, primitive? waitID)
			{
				if (!base.stopped && !base.completed && !base.executing)
				{
					support.SetArg3(iterator, val);
					TryExecute(new ExecParams(ExecContext.ArgChange, 3, waitID.HasValue ? waitID.Value : ((primitive)val.GetHashCode())));
				}
			}

			public Wait Call(AT0 arg0, AT1 arg1, AT2 arg2, AT3 arg3, int total = 1, bool reset = true, bool skip = false, bool requireComplete = true)
			{
				if (total == 0)
				{
					return Wait.PreMet;
				}
				support.SetArg0(iterator, arg0);
				support.SetArg1(iterator, arg1);
				support.SetArg2(iterator, arg2);
				support.SetArg3(iterator, arg3);
				return base.Call(total, reset, skip, requireComplete);
			}

			public Wait Call(AT0 arg0, AT1 arg1, AT2 arg2, int total = 1, bool reset = true, bool skip = false, bool requireComplete = true)
			{
				return Call(arg0, arg1, arg2, support.arg3Default, total, reset, skip, requireComplete);
			}

			public Wait Call(AT0 arg0, AT1 arg1, int total = 1, bool reset = true, bool skip = false, bool requireComplete = true)
			{
				return Call(arg0, arg1, support.arg2Default, support.arg3Default, total, reset, skip, requireComplete);
			}

			public Wait Call(AT0 arg0, int total = 1, bool reset = true, bool skip = false, bool requireComplete = true)
			{
				return Call(arg0, support.arg1Default, support.arg2Default, support.arg3Default, total, reset, skip, requireComplete);
			}

			public override Wait Call(int total = 1, bool reset = true, bool skip = false, bool requireComplete = true)
			{
				return Call(support.arg0Default, support.arg1Default, support.arg2Default, support.arg3Default, total, reset, skip, requireComplete);
			}

			public Wait Start(AT0 arg0, AT1 arg1, AT2 arg2, AT3 arg3, bool resetIfStarted = false, bool skip = false, bool waitUntilCompleted = true)
			{
				if ((base.started || base.paused) && !resetIfStarted)
				{
					if (!waitUntilCompleted)
					{
						return Wait.None;
					}
					return Wait.Until.Completed(this);
				}
				support.SetArg0(iterator, arg0);
				support.SetArg1(iterator, arg1);
				support.SetArg2(iterator, arg2);
				support.SetArg3(iterator, arg3);
				if ((base.started || base.paused) && resetIfStarted)
				{
					Reset();
					if (!waitUntilCompleted)
					{
						return Wait.None;
					}
					return Wait.Until.Completed(this);
				}
				return base.Start(resetIfStarted, skip, waitUntilCompleted);
			}

			public Wait Start(AT0 arg0, AT1 arg1, AT2 arg2, bool resetIfStarted = false, bool skip = false, bool waitUntilCompleted = true)
			{
				return Start(arg0, arg1, arg2, support.arg3Default, resetIfStarted, skip, waitUntilCompleted);
			}

			public Wait Start(AT0 arg0, AT1 arg1, bool resetIfStarted = false, bool skip = false, bool waitUntilCompleted = true)
			{
				return Start(arg0, arg1, support.arg2Default, support.arg3Default, resetIfStarted, skip, waitUntilCompleted);
			}

			public Wait Start(AT0 arg0, bool resetIfStarted = false, bool skip = false, bool waitUntilCompleted = true)
			{
				return Start(arg0, support.arg1Default, support.arg2Default, support.arg3Default, resetIfStarted, skip, waitUntilCompleted);
			}

			public override Wait Start(bool resetIfStarted = false, bool skip = false, bool waitUntilCompleted = true)
			{
				return Start(support.arg0Default, support.arg1Default, support.arg2Default, support.arg3Default, resetIfStarted, skip, waitUntilCompleted);
			}

			protected override void ResetArgs()
			{
				support.SetArg0(iterator, support.arg0Default);
				support.SetArg1(iterator, support.arg1Default);
				support.SetArg2(iterator, support.arg2Default);
				support.SetArg3(iterator, support.arg3Default);
			}
		}

		public struct Clause
		{
			public enum Type : byte
			{
				Clear,
				UntilEvent,
				ForSeconds,
				ForRealSeconds,
				ForCondValue,
				ForFuncValue,
				ForHagValue,
				Subtotal,
				Sequence,
				UntilTriggered,
				Call,
				ForCoroutineUpdate,
				GotoSelector,
				UntilArgChange
			}

			[Flags]
			public enum Flags : byte
			{
				Started = 1,
				AllowPreMet = 2,
				Isolate = 4,
				ThenSkip = 8,
				Operand = 0x10
			}

			public struct ForSecondsData
			{
				public float totalSecs;

				public float tallySecs;
			}

			public struct ForRealSecondsData
			{
				public float totalSecs;

				public float endTime;
			}

			public struct ForCondValueData
			{
				public bool value;
			}

			public struct ForFuncValueData
			{
				public bool value;
			}

			public struct ForHagValueData
			{
				public int? enterValueID;

				public int? exitValueID;

				public int enterValueComparison;

				public int exitValueComparison;
			}

			public struct OperatorData
			{
				public byte subtotal;

				public byte subtally;

				public primitive operands;
			}

			public struct UntilTriggeredData
			{
				public int? arg;
			}

			public struct CallData
			{
				public bool reset;

				public bool requireComplete;
			}

			public struct GotoSelectorData
			{
				public bool allowLatest;
			}

			public struct ArgChangeData
			{
				public byte? arg;

				public primitive? valWaitID;
			}

			[StructLayout(LayoutKind.Explicit)]
			public struct Specific
			{
				[FieldOffset(0)]
				public ForSecondsData fsc;

				[FieldOffset(0)]
				public ForRealSecondsData frs;

				[FieldOffset(0)]
				public ForCondValueData fcv;

				[FieldOffset(0)]
				public ForFuncValueData ffv;

				[FieldOffset(0)]
				public ForHagValueData fhv;

				[FieldOffset(0)]
				public OperatorData opr;

				[FieldOffset(0)]
				public UntilTriggeredData utr;

				[FieldOffset(0)]
				public CallData cll;

				[FieldOffset(0)]
				public GotoSelectorData gts;

				[FieldOffset(0)]
				public ArgChangeData ach;
			}

			public Type type;

			public Flags flags;

			public ushort tally;

			public ushort total;

			public byte rev;

			public IHagletEvent @event;

			public IHagletCondition cond;

			public Func<bool> func;

			public Func<int> gotoSelector;

			public IHagletValue hVal;

			public Haglet callee;

			public int @goto;

			public Specific s;

			[ThreadStatic]
			private static StringBuilder toStringBuilder;

			public Clause(byte revision = 0, ushort tally = 0, ushort total = 0)
			{
				this = default(Clause);
				rev = revision;
				this.tally = tally;
				this.total = total;
			}

			public override string ToString()
			{
				if (toStringBuilder == null)
				{
					toStringBuilder = new StringBuilder(100);
				}
				ToString(toStringBuilder);
				string result = toStringBuilder.ToString();
				toStringBuilder.Length = 0;
				return result;
			}

			public void ToString(StringBuilder builder)
			{
				int num;
				switch (type)
				{
				case Type.Clear:
					builder.Append("Clear");
					return;
				case Type.UntilEvent:
					builder.AppendFormat("Until");
					break;
				case Type.ForSeconds:
					builder.AppendFormat("For Seconds ({0:0.00}/{1:0.00}) On", s.fsc.tallySecs, s.fsc.totalSecs);
					break;
				case Type.ForRealSeconds:
					builder.AppendFormat("For Real Seconds ({0} ({1}) On", s.frs.totalSecs, Time.realtimeSinceStartup - (s.frs.endTime - s.frs.totalSecs));
					break;
				case Type.ForCondValue:
					builder.AppendFormat("Until {0} Is {1} On", cond, s.fcv.value);
					break;
				case Type.ForFuncValue:
					builder.AppendFormat("Until Func<bool> Is {0} On", s.ffv.value);
					break;
				case Type.ForHagValue:
				{
					string text = "==";
					if (s.fhv.enterValueComparison < 0)
					{
						text = "<";
					}
					else if (s.fhv.enterValueComparison > 0)
					{
						text = ">";
					}
					string text2 = "==";
					if (s.fhv.exitValueComparison < 0)
					{
						text2 = "<";
					}
					else if (s.fhv.exitValueComparison > 0)
					{
						text2 = ">";
					}
					if (!s.fhv.enterValueID.HasValue)
					{
						builder.AppendFormat("Until Exitting {0} Value Of ID {1}", text2, hVal.ValueIDToString(s.fhv.exitValueID.Value));
					}
					else if (!s.fhv.exitValueID.HasValue)
					{
						builder.AppendFormat("Until Entering {0} Value Of ID {1}", text, hVal.ValueIDToString(s.fhv.enterValueID.Value));
					}
					else
					{
						builder.AppendFormat("Until Switching From {0} Value Of ID {1} To {2} Value Of ID {3}", text, hVal.ValueIDToString(s.fhv.exitValueID.Value), text2, hVal.ValueIDToString(s.fhv.enterValueID.Value));
					}
					if (hVal != @event)
					{
						builder.Append(" (On ");
						builder.Append(hVal);
						builder.Append(")");
					}
					builder.Append(" On");
					break;
				}
				case Type.Subtotal:
					builder.AppendFormat("Until Subtotal of ", s.opr.subtotal);
					goto IL_0322;
				case Type.Sequence:
					builder.Append("Until Sequence ");
					goto IL_0322;
				case Type.UntilTriggered:
					builder.Append("Until Triggered");
					if (s.utr.arg.HasValue)
					{
						builder.Append(' ');
						builder.Append(s.utr.arg.Value);
					}
					break;
				case Type.Call:
					builder.Append("Call ");
					builder.Append(callee.ToString());
					break;
				case Type.ForCoroutineUpdate:
					builder.Append("For Coroutine Update");
					break;
				case Type.GotoSelector:
					builder.Append("For Newly Selected Goto On");
					break;
				case Type.UntilArgChange:
					{
						builder.Append("Until Arg ");
						if (s.ach.arg.HasValue)
						{
							builder.Append(s.ach.arg.Value);
							builder.Append(" Changed");
							if (s.ach.valWaitID.HasValue)
							{
								builder.Append(" To ");
								builder.Append(s.ach.valWaitID.Value.@ulong);
							}
						}
						else
						{
							builder.Append(" Changed");
						}
						break;
					}
					IL_0322:
					num = 0;
					for (byte b = 0; b < 8; b++)
					{
						if (GetOperand(s.opr.operands, b, out var opi))
						{
							if (num++ >= 1)
							{
								builder.Append(", ");
							}
							builder.AppendFormat("{0:D2}", opi);
						}
					}
					builder.Append(" - (");
					builder.Append(s.opr.subtally);
					builder.Append('/');
					builder.Append(s.opr.subtotal);
					builder.Append(')');
					break;
				}
				if (@event != null)
				{
					builder.Append(' ');
					builder.Append(@event.name);
				}
				builder.Append(" - (");
				builder.Append(tally);
				builder.Append('/');
				builder.Append(total);
				builder.Append(')');
			}
		}

		[Flags]
		public enum ExecContext : ushort
		{
			None = 0,
			Start = 1,
			Stop = 2,
			Complete = 4,
			Event = 8,
			Trigger = 0x10,
			CoroutineUpdate = 0x20,
			PostMove = 0x40,
			Skip = 0x80,
			SkipClause = 0x100,
			FromCallee = 0x200,
			FromCaller = 0x400,
			Resume = 0x800,
			Reset = 0x1000,
			Goto = 0x2000,
			ArgChange = 0x4000
		}

		[StructLayout(LayoutKind.Explicit)]
		private struct ExecParams
		{
			[FieldOffset(0)]
			public ExecContext contexts;

			[FieldOffset(2)]
			public int @goto;

			[FieldOffset(2)]
			public byte clause;

			[FieldOffset(2)]
			public int triggerArg;

			[FieldOffset(2)]
			public byte arg;

			[FieldOffset(3)]
			public primitive argValWaitID;

			public ExecParams(ExecContext contexts)
			{
				this.contexts = contexts;
				@goto = 0;
				clause = 0;
				triggerArg = 0;
				arg = 0;
				argValWaitID = 0uL;
			}

			public ExecParams(ExecContext contexts, int gotoOrTriggerArg)
			{
				this.contexts = contexts;
				clause = 0;
				triggerArg = 0;
				arg = 0;
				argValWaitID = 0uL;
				if (contexts == ExecContext.Goto)
				{
					triggerArg = 0;
					@goto = gotoOrTriggerArg;
				}
				else
				{
					@goto = 0;
					triggerArg = gotoOrTriggerArg;
				}
			}

			public ExecParams(ExecContext contexts, byte clause)
			{
				this.contexts = contexts;
				@goto = 0;
				triggerArg = 0;
				arg = 0;
				argValWaitID = 0uL;
				this.clause = clause;
			}

			public ExecParams(ExecContext contexts, byte arg, primitive argValWaitID)
			{
				this.contexts = contexts;
				@goto = 0;
				clause = 0;
				triggerArg = 0;
				this.arg = arg;
				this.argValWaitID = argValWaitID;
			}
		}

		[Serializable]
		public struct ID
		{
			public string name;

			public string editorGroup;

			public string ownerPath;

			public string ownerName;

			public int ownerInstID;

			public ID(IHaglet hag)
			{
				name = hag.name;
				editorGroup = null;
				if (hag.owner != null)
				{
					ownerPath = hag.owner.gameObject.GetScenePath(includeSelf: false);
					ownerName = hag.owner.name;
					ownerInstID = hag.owner.GetInstanceID();
				}
				else
				{
					ownerPath = (ownerName = null);
					ownerInstID = 0;
				}
			}

			public override bool Equals(object other)
			{
				if (!(other is ID iD))
				{
					return false;
				}
				return this == iD;
			}

			public override int GetHashCode()
			{
				return (((((-1675422229 * -1521134295 + base.GetHashCode()) * -1521134295 + EqualityComparer<string>.Default.GetHashCode(name)) * -1521134295 + EqualityComparer<string>.Default.GetHashCode(editorGroup)) * -1521134295 + EqualityComparer<string>.Default.GetHashCode(ownerPath)) * -1521134295 + EqualityComparer<string>.Default.GetHashCode(ownerName)) * -1521134295 + ownerInstID;
			}

			public static bool operator ==(ID left, ID right)
			{
				if (left.name == right.name && ((string.IsNullOrEmpty(left.editorGroup) && string.IsNullOrEmpty(right.editorGroup)) || left.editorGroup == right.editorGroup) && ((string.IsNullOrEmpty(left.ownerPath) && string.IsNullOrEmpty(right.ownerPath)) || left.ownerPath == right.ownerPath) && ((string.IsNullOrEmpty(left.ownerName) && string.IsNullOrEmpty(right.ownerName)) || left.ownerName == right.ownerName) && left.ownerInstID == right.ownerInstID)
				{
					return true;
				}
				return false;
			}

			public static bool operator !=(ID left, ID right)
			{
				return !(left == right);
			}

			public override string ToString()
			{
				return name;
			}

			public void TryFindOwner(out GameObject go, out MonoBehaviour mb)
			{
				go = null;
				mb = null;
				if (string.IsNullOrEmpty(ownerPath))
				{
					go = GameObject.Find(ownerName);
					return;
				}
				GameObject gameObject = GameObject.Find(ownerPath);
				if (!(gameObject == null))
				{
					Transform transform = gameObject.transform.Find(ownerName);
					if (!(transform == null))
					{
						go = transform.gameObject;
					}
				}
			}
		}

		[Serializable]
		public struct CallStackTraceEntry
		{
			public ID id;

			public string stateName;

			public bool isPaused;

			public int depth;

			public int state;

			public CallStackTraceEntry(IHaglet hag, int depth)
			{
				id = hag.id;
				this.depth = depth;
				state = hag.latestGoto;
				stateName = hag.GetGotoName();
				isPaused = hag.pausedInCallStack;
			}

			public bool Match(IHaglet hag, int depth)
			{
				if (id == hag.id && this.depth == depth && state == hag.latestGoto && isPaused == hag.pausedInCallStack)
				{
					return true;
				}
				return false;
			}
		}

		[Serializable]
		public struct Inspection
		{
			[Serializable]
			public struct Clause
			{
				public string str;

				public int depth;

				public int depthOrder;

				public int lineNumber;

				public string fileName;

				public ID calleeID;
			}

			[Serializable]
			public struct LogLine
			{
				public enum Type
				{
					StateChange,
					General,
					Goto,
					SkipStart,
					SkipStop,
					Exception,
					ClauseExpansion
				}

				[Serializable]
				public struct Frame
				{
					public string declaringTypeName;

					public string methodName;

					public string fileName;

					public int lineNum;
				}

				public Type type;

				public int timeStamp0;

				public int timeStamp1;

				public State newState;

				public string general;

				public string @goto;

				public int prevSize;

				public int newSize;

				public Frame[] frames;
			}

			public ID[] callStackIDs;

			public string fileName;

			public string lastGotoName;

			public State state;

			public bool pausedInCallStack;

			public int pc;

			public int lineNumber;

			public Clause[] clauses;

			public int logInitCap;

			public int logMaxLength;

			public LogLine[] log;
		}

		protected readonly IEnumerator<Routine.Yield> iterator;

		protected readonly HagletDynamicSupport.IServer support;

		private HagletDynamicSupport.ILocalsRecorder localsRecorder;

		private HagletValue<State> _state;

		private Clause[] clauses;

		private short resetPoint;

		private short primeClauseIdx;

		private IHagletEvent[] ownedEvents;

		private int ownedEventCount;

		private static Haglet _current;

		private Haglet _caller;

		private ExecParams execParams;

		private Func<Wait, Wait> _waitBasis;

		private int coroutineStack;

		private HagletValue<int> _latestGoto;

		private static readonly List<IHaglet> _allTopLevel;

		public const int defaultInitialWaitCapacity = 5;

		public const int logDefaultInitialCapacity = 50;

		public const int logDefaultMaximumLength = 500;

		private static object[] cachedBoxedIntegers;

		private Queue<Inspection.LogLine> log;

		public static IHaglet current => _current;

		public int lineNumber { get; private set; }

		public string fileName { get; private set; }

		public string name { get; protected set; }

		public int argCount => support.argCount;

		public State state => _state.value;

		public IHagletValue<State> iState => _state;

		public bool started => _state.value == State.Started;

		public bool stopped => _state.value == State.Stopped;

		public bool pausedInCallStack
		{
			get
			{
				if (!paused)
				{
					if (caller != null)
					{
						return caller.pausedInCallStack;
					}
					return false;
				}
				return true;
			}
		}

		public bool paused => _state.value == State.Paused;

		public bool completed => _state.value == State.Completed;

		public bool isCurrent => current == this;

		public bool executing => execParams.contexts != ExecContext.None;

		public bool moving { get; private set; }

		public IHaglet caller => _caller;

		public bool skipping
		{
			get
			{
				if ((execParams.contexts & ExecContext.Skip) == 0)
				{
					if (_caller != null)
					{
						return _caller.skipping;
					}
					return false;
				}
				return true;
			}
		}

		public int triggerArg => execParams.triggerArg;

		public int latestGoto
		{
			get
			{
				if (_latestGoto == null)
				{
					return 0;
				}
				return _latestGoto.value;
			}
		}

		public IHagletValue<int> iLatestGoto => _latestGoto;

		public bool isBeingTriggered => (execParams.contexts & ExecContext.Trigger) != 0;

		public MonoBehaviour owner { get; protected set; }

		public static bool inOne => _current != null;

		public bool waitEnabled { get; set; }

		public static IHagletEvent fallbackCheck => HagletEvent.onDefaultUpdate;

		public static IEnumerable<IHaglet> allTopLevel => _allTopLevel;

		public string editorGroup { get; protected set; }

		public double deltaTime
		{
			get
			{
				if (skipping)
				{
					return 0.01666666753590107;
				}
				if ((execParams.contexts & ExecContext.CoroutineUpdate) != 0)
				{
					return Time.deltaTime;
				}
				if ((execParams.contexts & ExecContext.Event) != 0)
				{
					return HagletEvent.current.deltaTime;
				}
				return 0.0;
			}
		}

		public double accumulatedTime
		{
			get
			{
				if ((execParams.contexts & ExecContext.CoroutineUpdate) != 0)
				{
					return Time.time;
				}
				if ((execParams.contexts & ExecContext.Event) != 0)
				{
					return HagletEvent.current.accumulatedTime;
				}
				return 0.0;
			}
		}

		public int directCalleeCount
		{
			get
			{
				int num = 0;
				if (!moving && primeClauseIdx != -1)
				{
					int i = 0;
					for (int num2 = clauses.Length; i < num2; i++)
					{
						if (clauses[i].type == Clause.Type.Call)
						{
							num++;
						}
					}
				}
				return num;
			}
		}

		public int? changingArg
		{
			get
			{
				if ((execParams.contexts & ExecContext.ArgChange) == 0)
				{
					return null;
				}
				return execParams.arg;
			}
		}

		object IEnumerator.Current => null;

		Func<Wait, Wait> Wait.IClient.waitBasis
		{
			set
			{
				_waitBasis = value;
			}
		}

		public ID id => new ID(this);

		public ID[] callStackIDs
		{
			get
			{
				int num = 1;
				for (Haglet haglet = _caller; haglet != null; haglet = haglet._caller)
				{
					num++;
				}
				ID[] array = new ID[num];
				array[--num] = id;
				for (Haglet haglet2 = _caller; haglet2 != null; haglet2 = haglet2._caller)
				{
					array[--num] = haglet2.id;
				}
				return array;
			}
		}

		public event Action<State> onPostStateChange
		{
			add
			{
				_state.onPostValueChange += value;
			}
			remove
			{
				_state.onPostValueChange -= value;
			}
		}

		public event Action<int, int> onGoto;

		public event Action<Exception, Inspection> onException;

		public event Action<IHaglet, Exception> onCalleeException;

		public static event Action<IHaglet, Exception, Inspection> onAnyException;

		public override string ToString()
		{
			return name;
		}

		public static bool In(IHaglet h)
		{
			return _current == h;
		}

		static Haglet()
		{
			_allTopLevel = new List<IHaglet>(100);
			cachedBoxedIntegers = new object[100];
			for (int i = 0; i < 100; i++)
			{
				cachedBoxedIntegers[i] = i;
			}
		}

		protected Haglet(IEnumerator<Routine.Yield> iterator)
		{
			this.iterator = iterator;
			support = HagletDynamicSupport.GetServer(iterator);
			IHagletEvent[] array = new HagletEvent[6];
			ownedEvents = array;
			primeClauseIdx = -1;
			waitEnabled = true;
		}

		public virtual Wait Start(bool resetIfStarted = false, bool skip = false, bool waitUntilCompleted = true)
		{
			if (started || paused)
			{
				if (resetIfStarted)
				{
					Reset();
				}
				if (!waitUntilCompleted)
				{
					return Wait.None;
				}
				return Wait.Until.Completed(this, 1, allowPreMetNow: true);
			}
			ApplyResetPoint();
			execParams.contexts = ExecContext.Start;
			_state.value = State.Started;
			if (skip)
			{
				execParams.contexts |= ExecContext.Skip;
			}
			Execute();
			if (!waitUntilCompleted)
			{
				return Wait.None;
			}
			return Wait.Until.Completed(this, 1, allowPreMetNow: true);
		}

		public virtual Wait Call(int total = 1, bool reset = true, bool skip = false, bool requireComplete = true)
		{
			if (!_current.waitEnabled)
			{
				return Wait.None;
			}
			if (total == 0)
			{
				return Wait.PreMet;
			}
			byte clearClause = _current.GetClearClause();
			_current.clauses[clearClause].type = Clause.Type.Call;
			_current.clauses[clearClause].callee = this;
			_current.clauses[clearClause].total = (ushort)total;
			_current.clauses[clearClause].s.cll.reset = reset;
			_current.clauses[clearClause].s.cll.requireComplete = requireComplete;
			_caller = _current;
			return new Wait(clearClause, _current);
		}

		private void CancelCall()
		{
			_caller = null;
			ResetArgs();
		}

		protected abstract void ResetArgs();

		public void Stop(bool complete = false)
		{
			TryExecute(new ExecParams(complete ? ExecContext.Complete : ExecContext.Stop));
		}

		public void Pause()
		{
			_state.value = State.Paused;
		}

		public void Resume()
		{
			TryExecute(new ExecParams(ExecContext.Resume));
		}

		public virtual void Reset()
		{
			TryExecute(new ExecParams(ExecContext.Reset));
		}

		public void MarkResetPoint()
		{
			resetPoint = support.GetPC(iterator);
			if (localsRecorder != null)
			{
				localsRecorder.RecordFrom(iterator);
			}
		}

		public void Trigger()
		{
			Trigger(0);
		}

		public void Trigger(int arg)
		{
			TryExecute(new ExecParams(ExecContext.Trigger, arg));
		}

		public void Trigger<T>(T arg) where T : struct, IConvertible
		{
			Trigger(arg.ToInt32(null));
		}

		public bool TryTrigger()
		{
			if (executing)
			{
				return false;
			}
			TryExecute(new ExecParams(ExecContext.Trigger));
			return true;
		}

		public bool TryTrigger(int arg)
		{
			if (executing)
			{
				return false;
			}
			TryExecute(new ExecParams(ExecContext.Trigger, arg));
			return true;
		}

		public bool TryTrigger<T>(T arg) where T : struct, IConvertible
		{
			if (executing)
			{
				return false;
			}
			TryExecute(new ExecParams(ExecContext.Trigger, arg.ToInt32(null)));
			return true;
		}

		public void Goto(int id)
		{
			TryExecute(new ExecParams(ExecContext.Goto, id));
		}

		public DynamicProperty<T> GetLocalVar<T>(string name, bool required = true)
		{
			return iterator.GetDynamicProperty<T>(name, required);
		}

		public void Skip()
		{
			LogSkipStart();
			if (executing)
			{
				execParams.contexts |= ExecContext.Skip;
			}
			else if (started || paused)
			{
				TryExecute(new ExecParams(ExecContext.Skip));
			}
			else
			{
				Start(resetIfStarted: false, skip: true, waitUntilCompleted: false);
			}
		}

		public static bool IsValidGotoID(int id)
		{
			for (int i = 0; i < 31; i++)
			{
				if (id == 1 << i)
				{
					return true;
				}
			}
			return false;
		}

		public static int GetStateIDBitIndex(int id)
		{
			for (int i = 0; i < 31; i++)
			{
				if (id == 1 << i)
				{
					return i;
				}
			}
			return -1;
		}

		public string GetGotoName()
		{
			if (_latestGoto == null)
			{
				return null;
			}
			if (_latestGoto.value == 0)
			{
				return null;
			}
			return GetGotoName(_latestGoto.value);
		}

		public string GetGotoName(int id)
		{
			return support.GetGotoNameFromID(id) ?? $"1 << {GetStateIDBitIndex(id)}";
		}

		public bool IsValidClause(byte ci, byte rev)
		{
			return true;
		}

		public Clause.Flags GetClauseFlags(byte ci)
		{
			if (clauses == null || ci > clauses.Length)
			{
				return (Clause.Flags)0;
			}
			return clauses[ci].flags;
		}

		public string GetClauseDescription(byte ci)
		{
			if (clauses == null || ci > clauses.Length)
			{
				return null;
			}
			return clauses[ci].ToString();
		}

		public bool IsValidGoto(int id)
		{
			return support.GetGotoPCFromID(id) != -1;
		}

		public void Log(string log)
		{
			LogGeneral(log);
		}

		public void Log(string logFormat, object arg0)
		{
			LogGeneral(string.Format(logFormat, arg0));
		}

		public void Log(string logFormat, object arg0, object arg1)
		{
			LogGeneral(string.Format(logFormat, arg0, arg1));
		}

		public void Log(string logFormat, object arg0, object arg1, object arg2)
		{
			LogGeneral(string.Format(logFormat, arg0, arg1, arg2));
		}

		public void Log(string logFormat, params object[] args)
		{
			LogGeneral(string.Format(logFormat, args));
		}

		[Conditional("CS_DEBUG")]
		private void GetIsValidClause(ref bool valid, byte ci, byte rev)
		{
			valid = false;
			if (clauses != null && ci < clauses.Length && clauses[ci].rev == rev)
			{
				valid = true;
			}
		}

		public byte GetClauseRevision(short i)
		{
			return clauses[i].rev;
		}

		private void StartAsCallee()
		{
			_state.value = State.Started;
			if (started)
			{
				execParams.contexts = ExecContext.Start;
				Execute();
			}
		}

		bool IEnumerator.MoveNext()
		{
			if (stopped || completed)
			{
				return false;
			}
			TryExecute(new ExecParams(ExecContext.CoroutineUpdate));
			return coroutineStack > 0;
		}

		void IEnumerator.Reset()
		{
		}

		private void LockInClause(byte ci)
		{
			clauses[ci].rev = 0;
			if (clauses[ci].type != Clause.Type.Subtotal && clauses[ci].type != Clause.Type.Sequence)
			{
				return;
			}
			for (byte b = 0; b < 8; b++)
			{
				if (GetOperand(ci, b, out var opi))
				{
					LockInClause(opi);
				}
			}
		}

		void HagletEvent.IResponder.OnEvent()
		{
			TryExecute(new ExecParams(ExecContext.Event));
		}

		void HagletEvent.IResponder.OnEventCancel(HagletEvent @event)
		{
			Stop();
		}

		private void TryExecute(ExecParams @params)
		{
			Haglet lt = this.PushTo(ref _current);
			if ((@params.contexts & ExecContext.FromCaller) == 0)
			{
				if (!executing && !stopped && !completed)
				{
					if ((object)owner != null && owner == null)
					{
						execParams.contexts = ExecContext.Stop;
					}
					else
					{
						execParams = @params;
					}
					if (_caller == null)
					{
						goto IL_009d;
					}
					_caller.TryExecute(new ExecParams(ExecContext.FromCallee));
				}
				goto IL_0239;
			}
			execParams.contexts |= @params.contexts;
			goto IL_009d;
			IL_0209:
			bool didGoto;
			int arg;
			if (didGoto && this.onGoto != null)
			{
				this.onGoto(arg, _latestGoto.value);
				if (!started)
				{
					goto IL_0239;
				}
			}
			Execute();
			goto IL_0239;
			IL_009d:
			if ((execParams.contexts & (ExecContext.Stop | ExecContext.Complete | ExecContext.Reset)) != 0)
			{
				ClearPrimeClause(revise: false, retainTallyAndTotal: false);
				if ((execParams.contexts & (ExecContext.Stop | ExecContext.Complete)) != 0)
				{
					RemoveFromTopLevelList();
					bool flag = (execParams.contexts & ExecContext.Complete) != 0;
					_state.value = (flag ? State.Completed : State.Stopped);
					if (flag)
					{
						support.ResetLocals(iterator);
					}
					goto IL_0239;
				}
				ApplyResetPoint();
			}
			if (skipping)
			{
				_state.value = State.Started;
			}
			else if ((execParams.contexts & ExecContext.Resume) != 0)
			{
				if (!paused)
				{
					goto IL_0239;
				}
				_state.value = State.Started;
			}
			arg = ((_latestGoto != null) ? _latestGoto.value : 0);
			didGoto = false;
			if ((execParams.contexts & ExecContext.Goto) != 0)
			{
				ClearPrimeClause(revise: false, retainTallyAndTotal: false);
				LogGoto(execParams.@goto);
				support.SetPCToGoto(iterator, execParams.@goto);
				_latestGoto.value = execParams.@goto;
				didGoto = true;
			}
			else if (primeClauseIdx != -1)
			{
				Exception exc = null;
				ClauseStatus clauseStatus = UpdateClause((byte)primeClauseIdx, ref didGoto, ref exc);
				if (clauseStatus != ClauseStatus.Pending)
				{
					if (clauseStatus == ClauseStatus.Exception)
					{
						HandleException(exc);
					}
					else if (started)
					{
						goto IL_0209;
					}
				}
				goto IL_0239;
			}
			goto IL_0209;
			IL_0239:
			execParams = default(ExecParams);
			lt.PushTo(ref _current);
		}

		private void ClearPrimeClause(bool revise, bool retainTallyAndTotal)
		{
			if (primeClauseIdx != -1)
			{
				ClearClause((byte)primeClauseIdx, revise, retainTallyAndTotal);
				primeClauseIdx = -1;
			}
		}

		private void RemoveFromTopLevelList()
		{
		}

		private void ApplyResetPoint()
		{
			ClearAllClauses(revise: false, retainTally: false);
			if (cachedBoxedIntegers.Length <= resetPoint)
			{
				int num = cachedBoxedIntegers.Length;
				int num2 = Mathf.CeilToInt((float)cachedBoxedIntegers.Length * 1.5f);
				Array.Resize(ref cachedBoxedIntegers, num2);
				for (int i = num; i < num2; i++)
				{
					cachedBoxedIntegers[i] = i;
				}
			}
			support.SetPCBoxed(iterator, cachedBoxedIntegers[resetPoint]);
			if (_latestGoto != null)
			{
				_latestGoto.value = 0;
			}
			try
			{
				if (localsRecorder != null)
				{
					localsRecorder.ApplyTo(iterator);
				}
				else
				{
					support.ResetLocals(iterator);
				}
			}
			catch
			{
				if (HagletDynamicSupport.assembliesInUse)
				{
					Panic.Haglet.WarnAssemblyInvalid();
				}
				throw;
			}
		}

		private void Execute()
		{
			Haglet lt = this.PushTo(ref _current);
			int num = 0;
			while (true)
			{
				ClearPrimeClause(revise: false, retainTallyAndTotal: true);
				Wait.IClient newClient = Wait.Push(this);
				bool flag = false;
				int arg = ((_latestGoto != null) ? _latestGoto.value : 0);
				bool didGoto = false;
				try
				{
					moving = true;
					flag = !iterator.MoveNext();
				}
				catch (Exception exc)
				{
					moving = false;
					HandleException(exc);
					break;
				}
				finally
				{
					moving = false;
					Wait.Push(newClient);
				}
				Routine.Yield yield = iterator.Current;
				if (flag)
				{
					ClearAllClauses(revise: false, retainTally: false);
					RemoveFromTopLevelList();
					_state.value = State.Completed;
					support.ResetLocals(iterator);
					break;
				}
				bool flag2 = true;
				Routine.Yield.Data data = yield.data;
				while (true)
				{
					Exception ex;
					Routine.Yield.SpecialIndex si;
					switch (data.special.si)
					{
					case Routine.Yield.SpecialIndex.START:
					case Routine.Yield.SpecialIndex.WaitPreMet:
					case Routine.Yield.SpecialIndex.WaitForever:
						ClearAllClauses(revise: false, retainTally: false);
						goto IL_03ff;
					case Routine.Yield.SpecialIndex.RoutineReset:
						ApplyResetPoint();
						goto IL_05d7;
					case Routine.Yield.SpecialIndex.RoutineResetToHere:
						ClearAllClauses(revise: false, retainTally: false);
						MarkResetPoint();
						goto IL_05d7;
					case Routine.Yield.SpecialIndex.RoutineStop:
						ClearAllClauses(revise: false, retainTally: false);
						RemoveFromTopLevelList();
						_state.value = State.Stopped;
						break;
					case Routine.Yield.SpecialIndex.RoutineComplete:
						ClearAllClauses(revise: false, retainTally: false);
						RemoveFromTopLevelList();
						_state.value = State.Completed;
						support.ResetLocals(iterator);
						break;
					case Routine.Yield.SpecialIndex.RoutineStartsHere:
						MarkResetPoint();
						goto case Routine.Yield.SpecialIndex.RoutineStop;
					case Routine.Yield.SpecialIndex.WaitUntilTriggered:
						data.clause.ci = ((Wait.IUntil)this).Triggered(1, allowPreMetNow: false, allowPreMetLater: false).ci;
						goto IL_03ff;
					case Routine.Yield.SpecialIndex.WaitForUpdate:
						data.clause.ci = ((Wait.IFor)this).Updates(1, allowPreMetNow: false, allowPreMetLater: false, asCoroutine: false).ci;
						goto IL_03ff;
					case Routine.Yield.SpecialIndex.WaitForLateUpdate:
						data.clause.ci = ((Wait.IUntil)this).Happening((IHagletEvent)HagletEvent.onDefaultLateUpdate, 1, allowPreMetNow: false, allowPreMetLater: false).ci;
						goto IL_03ff;
					case Routine.Yield.SpecialIndex.WaitForFixedUpdate:
						data.clause.ci = ((Wait.IUntil)this).Happening((IHagletEvent)HagletEvent.onDefaultFixedUpdate, 1, allowPreMetNow: false, allowPreMetLater: false).ci;
						goto IL_03ff;
					case Routine.Yield.SpecialIndex.WaitForCoroutineUpdate:
						data.clause.ci = ((Wait.IFor)this).Updates(1, allowPreMetNow: false, allowPreMetLater: false, asCoroutine: true).ci;
						goto IL_03ff;
					case Routine.Yield.SpecialIndex.WaitUntilArgChange:
						data.clause.ci = ((Wait.IUntil)this).ArgChange(1, allowPreMetNow: false, allowPreMetLater: false).ci;
						goto IL_03ff;
					case Routine.Yield.SpecialIndex.MarkGoto:
						ClearAllClauses(revise: false, retainTally: false);
						LogGoto(data.special.gotoID);
						_latestGoto.value = data.special.gotoID;
						didGoto = true;
						goto IL_05d7;
					case Routine.Yield.SpecialIndex.Goto:
						ClearAllClauses(revise: false, retainTally: false);
						LogGoto(data.special.gotoID);
						support.SetPCToGoto(iterator, data.special.gotoID);
						_latestGoto.value = data.special.gotoID;
						didGoto = true;
						goto IL_05d7;
					case Routine.Yield.SpecialIndex.StopSkipping:
						if ((execParams.contexts & ExecContext.Skip) != 0)
						{
							execParams.contexts &= ~ExecContext.Skip;
							LogSkipStop();
						}
						goto IL_05d7;
					case Routine.Yield.SpecialIndex.StopCallStackSkipping:
					{
						for (Haglet haglet = _caller; haglet != null; haglet = haglet._caller)
						{
							if ((haglet.execParams.contexts & ExecContext.Skip) != 0)
							{
								haglet.execParams.contexts &= ~ExecContext.Skip;
								haglet.LogSkipStop();
							}
						}
						goto case Routine.Yield.SpecialIndex.StopSkipping;
					}
					case Routine.Yield.SpecialIndex.GotoNext:
					{
						int num2 = _latestGoto.value << 1;
						ClearAllClauses(revise: false, retainTally: false);
						LogGoto(num2);
						support.SetPCToGoto(iterator, num2);
						_latestGoto.value = num2;
						didGoto = true;
						goto IL_05d7;
					}
					default:
						{
							if (!IsValidClause(data.clause.ci, data.clause.rev))
							{
								HandleException(Panic.Haglet.GetInvalidWait(this));
								break;
							}
							goto IL_03ff;
						}
						IL_03ff:
						if (_waitBasis != null && flag2)
						{
							newClient = Wait.Push(this);
							flag2 = false;
							ex = null;
							try
							{
								Wait wait = data.special.si switch
								{
									Routine.Yield.SpecialIndex.START => _waitBasis(Wait.None), 
									Routine.Yield.SpecialIndex.WaitPreMet => _waitBasis(Wait.PreMet), 
									Routine.Yield.SpecialIndex.WaitForever => _waitBasis(Wait.Forever), 
									_ => _waitBasis(new Wait(data.clause.ci, this)), 
								};
								data.clause.ci = wait.ci;
								data.clause.rev = wait.rev;
							}
							catch (Exception ex2)
							{
								ex = ex2;
							}
							goto IL_04ce;
						}
						si = data.special.si;
						if (si - 235 > (Routine.Yield.SpecialIndex)1)
						{
							if (si == Routine.Yield.SpecialIndex.WaitForever)
							{
								ClearAllClauses(revise: false, retainTally: false);
								RemoveFromTopLevelList();
								_state.value = State.Stopped;
							}
							else
							{
								primeClauseIdx = data.clause.ci;
								LockInClause((byte)primeClauseIdx);
								byte b = 0;
								byte b2 = (byte)clauses.Length;
								while (b < b2)
								{
									if (clauses[b].rev != 0)
									{
										ClearClause(b, revise: false, retainTallyAndTotal: false);
									}
									b++;
								}
								execParams.contexts |= ExecContext.PostMove;
								Exception exc2 = null;
								ClauseStatus clauseStatus = UpdateClause((byte)primeClauseIdx, ref didGoto, ref exc2);
								if (clauseStatus == ClauseStatus.Pending)
								{
									break;
								}
								if (clauseStatus == ClauseStatus.Exception)
								{
									HandleException(exc2);
									break;
								}
								if (!started)
								{
									break;
								}
							}
						}
						else
						{
							ClearAllClauses(revise: false, retainTally: false);
						}
						goto IL_05d7;
						IL_05d7:
						if (didGoto && this.onGoto != null)
						{
							this.onGoto(arg, _latestGoto.value);
						}
						execParams.contexts &= ~ExecContext.PostMove;
						if (num < 1000)
						{
							goto end_IL_00c3;
						}
						HandleException(Panic.Haglet.GetHang(this));
						break;
					}
					goto end_IL_000e;
					IL_04ce:
					Wait.Push(newClient);
					if (ex != null)
					{
						HandleException(ex);
						goto end_IL_000e;
					}
					continue;
					end_IL_00c3:
					break;
				}
				num++;
				continue;
				end_IL_000e:
				break;
			}
			lt.PushTo(ref _current);
			execParams.contexts = ExecContext.None;
		}

		private ClauseStatus UpdateClause(byte ci, ref bool didGoto, ref Exception exc)
		{
			if (clauses[ci].tally == clauses[ci].total)
			{
				return ClauseStatus.AtTotal;
			}
			ClauseStatus clauseStatus = (((clauses[ci].flags & Clause.Flags.Started) != 0) ? ClauseStatus.Started : ClauseStatus.Ready);
			while (true)
			{
				switch (clauseStatus)
				{
				case ClauseStatus.Ready:
					clauseStatus = StartClause(ci);
					break;
				case ClauseStatus.Started:
					clauseStatus = ((!skipping && ((execParams.contexts & ExecContext.SkipClause) == 0 || execParams.clause != ci)) ? ((!ClauseShouldExecute(ci)) ? ClauseStatus.Pending : ExecuteClause(ci, ref didGoto, ref exc)) : SkipClause(ci, ref didGoto, ref exc));
					break;
				case ClauseStatus.Pending:
					if (skipping || ((execParams.contexts & ExecContext.SkipClause) != 0 && execParams.clause == ci))
					{
						clauseStatus = SkipClause(ci, ref didGoto, ref exc);
						break;
					}
					return ClauseStatus.Pending;
				case ClauseStatus.Complete:
					StopClause(ci);
					clauseStatus = TallyClause(ci, ref didGoto);
					break;
				case ClauseStatus.EarlyExit:
				case ClauseStatus.Exception:
					StopClause(ci);
					return clauseStatus;
				case ClauseStatus.AtTotal:
					return ClauseStatus.AtTotal;
				}
			}
		}

		private ClauseStatus StartClause(byte ci)
		{
			clauses[ci].flags |= Clause.Flags.Started;
			if (clauses[ci].@event != null)
			{
				clauses[ci].@event.Push(this);
			}
			switch (clauses[ci].type)
			{
			case Clause.Type.ForRealSeconds:
				clauses[ci].s.frs.endTime = Time.realtimeSinceStartup + clauses[ci].s.frs.totalSecs;
				goto case Clause.Type.ForSeconds;
			case Clause.Type.ForSeconds:
			case Clause.Type.ForCondValue:
			case Clause.Type.ForFuncValue:
			case Clause.Type.ForHagValue:
			case Clause.Type.ForCoroutineUpdate:
			case Clause.Type.GotoSelector:
				if (clauses[ci].@event == null)
				{
					PushAsCoroutine();
				}
				break;
			case Clause.Type.Subtotal:
			case Clause.Type.Sequence:
				return ClauseStatus.Started;
			case Clause.Type.Call:
				if (clauses[ci].s.cll.reset)
				{
					clauses[ci].callee.ApplyResetPoint();
				}
				clauses[ci].callee.StartAsCallee();
				return ClauseStatus.Started;
			}
			if ((clauses[ci].flags & Clause.Flags.AllowPreMet) == 0)
			{
				return ClauseStatus.Pending;
			}
			return ClauseStatus.Started;
		}

		private bool ClauseShouldExecute(byte ci)
		{
			if ((execParams.contexts & (ExecContext.FromCallee | ExecContext.Resume)) != 0)
			{
				Clause.Type type = clauses[ci].type;
				if (type - 7 <= Clause.Type.UntilEvent || type == Clause.Type.Call)
				{
					return true;
				}
				return false;
			}
			if (pausedInCallStack)
			{
				return false;
			}
			if (clauses[ci].@event != null)
			{
				if ((execParams.contexts & ExecContext.Event) != 0 && clauses[ci].@event == HagletEvent.current)
				{
					return true;
				}
				return false;
			}
			switch (clauses[ci].type)
			{
			case Clause.Type.ForSeconds:
			case Clause.Type.ForRealSeconds:
				if ((execParams.contexts & ExecContext.PostMove) == 0 && (execParams.contexts & ExecContext.CoroutineUpdate) != 0)
				{
					return true;
				}
				return false;
			case Clause.Type.ForCondValue:
			case Clause.Type.ForFuncValue:
			case Clause.Type.ForHagValue:
			case Clause.Type.ForCoroutineUpdate:
				return (execParams.contexts & ExecContext.CoroutineUpdate) != 0;
			case Clause.Type.UntilArgChange:
				if ((execParams.contexts & ExecContext.ArgChange) != 0 && (!clauses[ci].s.ach.arg.HasValue || execParams.arg == clauses[ci].s.ach.arg))
				{
					if (clauses[ci].s.ach.valWaitID.HasValue)
					{
						primitive argValWaitID = execParams.argValWaitID;
						primitive? valWaitID = clauses[ci].s.ach.valWaitID;
						if (!(argValWaitID == valWaitID))
						{
							goto IL_01fe;
						}
					}
					return true;
				}
				goto IL_01fe;
			default:
				{
					return true;
				}
				IL_01fe:
				return false;
			}
		}

		private ClauseStatus ExecuteClause(byte ci, ref bool didGoto, ref Exception exc, int triggerArg = 0, int skipClauseIdx = -1)
		{
			switch (clauses[ci].type)
			{
			case Clause.Type.ForSeconds:
			{
				float num = ((clauses[ci].@event != null) ? HagletEvent.current.deltaTime : Time.deltaTime);
				if ((clauses[ci].s.fsc.tallySecs += num) < clauses[ci].s.fsc.totalSecs)
				{
					return ClauseStatus.Pending;
				}
				return ClauseStatus.Complete;
			}
			case Clause.Type.ForRealSeconds:
				if (Time.realtimeSinceStartup < clauses[ci].s.frs.endTime)
				{
					return ClauseStatus.Pending;
				}
				return ClauseStatus.Complete;
			case Clause.Type.ForCondValue:
				if (clauses[ci].cond.isTrue != clauses[ci].s.fcv.value)
				{
					return ClauseStatus.Pending;
				}
				return ClauseStatus.Complete;
			case Clause.Type.ForFuncValue:
				if (clauses[ci].func() != clauses[ci].s.ffv.value)
				{
					return ClauseStatus.Pending;
				}
				return ClauseStatus.Complete;
			case Clause.Type.ForHagValue:
				if (clauses[ci].@event != clauses[ci].hVal)
				{
					if (clauses[ci].s.fhv.enterValueID.HasValue)
					{
						if (clauses[ci].hVal.CompareValueToValueOfID(clauses[ci].s.fhv.enterValueID.Value) == clauses[ci].s.fhv.enterValueComparison)
						{
							break;
						}
					}
					else if (clauses[ci].hVal.CompareValueToValueOfID(clauses[ci].s.fhv.exitValueID.Value) != clauses[ci].s.fhv.exitValueComparison)
					{
						break;
					}
					return ClauseStatus.Pending;
				}
				if (clauses[ci].s.fhv.enterValueID.HasValue && clauses[ci].hVal.enterValueID.HasValue && clauses[ci].hVal.CompareValuesOfIDs(clauses[ci].hVal.enterValueID.Value, clauses[ci].s.fhv.enterValueID.Value) == clauses[ci].s.fhv.enterValueComparison)
				{
					return ClauseStatus.Complete;
				}
				if (clauses[ci].s.fhv.exitValueID.HasValue && clauses[ci].hVal.exitValueID.HasValue && clauses[ci].hVal.CompareValuesOfIDs(clauses[ci].hVal.exitValueID.Value, clauses[ci].s.fhv.exitValueID.Value) == clauses[ci].s.fhv.exitValueComparison)
				{
					return ClauseStatus.Complete;
				}
				return ClauseStatus.Pending;
			case Clause.Type.Subtotal:
			case Clause.Type.Sequence:
			{
				clauses[ci].s.opr.subtally = 0;
				for (byte b = 0; b < 8; b++)
				{
					if (GetOperand(ci, b, out var opi))
					{
						switch (UpdateClause(opi, ref didGoto, ref exc))
						{
						case ClauseStatus.AtTotal:
							if (++clauses[ci].s.opr.subtally == clauses[ci].s.opr.subtotal)
							{
								return ClauseStatus.Complete;
							}
							break;
						case ClauseStatus.Pending:
							if (clauses[ci].type == Clause.Type.Sequence)
							{
								return ClauseStatus.Pending;
							}
							break;
						case ClauseStatus.EarlyExit:
							return ClauseStatus.EarlyExit;
						case ClauseStatus.Exception:
							return ClauseStatus.Exception;
						}
					}
				}
				return ClauseStatus.Pending;
			}
			case Clause.Type.UntilTriggered:
				if ((execParams.contexts & ExecContext.Trigger) == 0)
				{
					return ClauseStatus.Pending;
				}
				if (clauses[ci].s.utr.arg.HasValue && clauses[ci].s.utr.arg != execParams.triggerArg)
				{
					return ClauseStatus.Pending;
				}
				return ClauseStatus.Complete;
			case Clause.Type.Call:
			{
				if (clauses[ci].callee.stopped)
				{
					if (clauses[ci].s.cll.requireComplete)
					{
						exc = Panic.Haglet.GetCalleeStoppedException(this, clauses[ci].callee);
						return ClauseStatus.Exception;
					}
					return ClauseStatus.Complete;
				}
				if (clauses[ci].callee.completed)
				{
					return ClauseStatus.Complete;
				}
				bool num2 = (execParams.contexts & ExecContext.Resume) != 0;
				bool flag = (execParams.contexts & ExecContext.FromCallee) != 0;
				if (num2 || (flag && clauses[ci].callee.executing))
				{
					clauses[ci].callee.TryExecute(new ExecParams(ExecContext.FromCaller));
					if (clauses[ci].callee.stopped)
					{
						if (clauses[ci].s.cll.requireComplete)
						{
							exc = Panic.Haglet.GetCalleeStoppedException(this, clauses[ci].callee);
							return ClauseStatus.Exception;
						}
						return ClauseStatus.Complete;
					}
					if (clauses[ci].callee.completed)
					{
						return ClauseStatus.Complete;
					}
					if (skipping)
					{
						exc = Panic.Haglet.GetSkipFailException(this, ci, clauses[ci]);
						return ClauseStatus.Exception;
					}
				}
				return ClauseStatus.Pending;
			}
			case Clause.Type.GotoSelector:
			{
				int value = _latestGoto.value;
				try
				{
					value = clauses[ci].gotoSelector();
				}
				catch (Exception ex)
				{
					exc = ex;
					return ClauseStatus.Exception;
				}
				if (!clauses[ci].s.gts.allowLatest && value == _latestGoto.value)
				{
					return ClauseStatus.Pending;
				}
				clauses[ci].@goto = value;
				return ClauseStatus.Complete;
			}
			}
			return ClauseStatus.Complete;
		}

		private ClauseStatus SkipClause(byte ci, ref bool didGoto, ref Exception exc)
		{
			switch (clauses[ci].type)
			{
			case Clause.Type.Subtotal:
			case Clause.Type.Sequence:
			{
				clauses[ci].s.opr.subtally = 0;
				for (byte b = 0; b < 8; b++)
				{
					if (GetOperand(ci, b, out var opi))
					{
						switch (UpdateClause(opi, ref didGoto, ref exc))
						{
						case ClauseStatus.AtTotal:
							if (++clauses[ci].s.opr.subtally == clauses[ci].s.opr.subtotal)
							{
								return ClauseStatus.Complete;
							}
							break;
						case ClauseStatus.EarlyExit:
							return ClauseStatus.EarlyExit;
						case ClauseStatus.Pending:
							if (!skipping)
							{
								return ClauseStatus.Pending;
							}
							exc = Panic.Haglet.GetSkipFailException(this, opi, clauses[opi]);
							break;
						}
					}
				}
				return ClauseStatus.Exception;
			}
			case Clause.Type.Call:
				if (!clauses[ci].callee.started && !clauses[ci].callee.pausedInCallStack)
				{
					break;
				}
				clauses[ci].callee.TryExecute(new ExecParams(ExecContext.FromCaller));
				if (clauses[ci].callee.started || clauses[ci].callee.paused)
				{
					if (!skipping)
					{
						return ClauseStatus.Pending;
					}
					exc = Panic.Haglet.GetSkipFailException(this, ci, clauses[ci]);
					return ClauseStatus.Exception;
				}
				if (clauses[ci].s.cll.requireComplete && !clauses[ci].callee.completed)
				{
					exc = Panic.Haglet.GetCalleeStoppedException(this, clauses[ci].callee);
					return ClauseStatus.Exception;
				}
				break;
			}
			return ClauseStatus.Complete;
		}

		private ClauseStatus TallyClause(byte ci, ref bool didGoto)
		{
			if (++clauses[ci].tally == clauses[ci].total)
			{
				if (clauses[ci].@goto != 0)
				{
					bool flag = latestGoto != clauses[ci].@goto;
					if (clauses[ci].type == Clause.Type.GotoSelector && clauses[ci].s.gts.allowLatest)
					{
						flag = true;
					}
					if (flag)
					{
						LogGoto(clauses[ci].@goto, ci);
						support.SetPCToGoto(iterator, clauses[ci].@goto);
						_latestGoto.value = clauses[ci].@goto;
						didGoto = true;
					}
				}
				if ((clauses[ci].flags & Clause.Flags.ThenSkip) != 0)
				{
					Skip();
				}
				return ClauseStatus.AtTotal;
			}
			ResetClause(ci);
			return ClauseStatus.Ready;
		}

		private void ResetClause(byte ci)
		{
			switch (clauses[ci].type)
			{
			case Clause.Type.ForSeconds:
				clauses[ci].s.fsc.tallySecs = 0f;
				break;
			case Clause.Type.ForRealSeconds:
				clauses[ci].s.frs.endTime = Time.realtimeSinceStartup + clauses[ci].s.frs.totalSecs;
				break;
			case Clause.Type.Subtotal:
			case Clause.Type.Sequence:
			{
				for (byte b = 0; b < 8; b++)
				{
					if (GetOperand(ci, b, out var opi))
					{
						ResetClause(opi);
						clauses[opi].tally = 0;
					}
				}
				break;
			}
			case Clause.Type.Call:
				if (!clauses[ci].callee.executing)
				{
					clauses[ci].callee.Reset();
				}
				break;
			case Clause.Type.ForCondValue:
			case Clause.Type.ForFuncValue:
			case Clause.Type.ForHagValue:
			case Clause.Type.UntilTriggered:
				break;
			}
		}

		private void StopClause(byte ci)
		{
			clauses[ci].flags &= ~Clause.Flags.Started;
			if (clauses[ci].@event != null)
			{
				clauses[ci].@event.Pop(this);
			}
			switch (clauses[ci].type)
			{
			case Clause.Type.ForSeconds:
			case Clause.Type.ForRealSeconds:
			case Clause.Type.ForCondValue:
			case Clause.Type.ForFuncValue:
			case Clause.Type.ForHagValue:
			case Clause.Type.ForCoroutineUpdate:
			case Clause.Type.GotoSelector:
				if (clauses[ci].@event == null)
				{
					PopAsCoroutine();
				}
				break;
			case Clause.Type.Subtotal:
			case Clause.Type.Sequence:
			{
				for (byte b = 0; b < 8; b++)
				{
					if (GetOperand(ci, b, out var opi) && (clauses[opi].flags & Clause.Flags.Started) != 0)
					{
						StopClause(opi);
					}
				}
				break;
			}
			case Clause.Type.Call:
				if (clauses[ci].callee.started || clauses[ci].callee.paused)
				{
					clauses[ci].callee.TryExecute(new ExecParams(ExecContext.Stop | ExecContext.FromCaller));
				}
				break;
			case Clause.Type.UntilTriggered:
				break;
			}
		}

		private void ClearClause(byte ci, bool revise, bool retainTallyAndTotal, bool propagate = true)
		{
			if ((clauses[ci].flags & Clause.Flags.Started) != 0)
			{
				StopClause(ci);
			}
			switch (clauses[ci].type)
			{
			case Clause.Type.Subtotal:
			case Clause.Type.Sequence:
			{
				if (!propagate)
				{
					break;
				}
				for (byte b = 0; b < 8; b++)
				{
					if (GetOperand(ci, b, out var opi))
					{
						ClearClause(opi, revise, retainTallyAndTotal);
					}
				}
				break;
			}
			case Clause.Type.Call:
				clauses[ci].callee.CancelCall();
				break;
			}
			clauses[ci] = new Clause((byte)(revise ? ((uint)(clauses[ci].rev + 1)) : 0u), (ushort)(retainTallyAndTotal ? clauses[ci].tally : 0), (ushort)(retainTallyAndTotal ? clauses[ci].total : 0));
		}

		private void ClearAllClauses(bool revise, bool retainTally)
		{
			if (clauses != null)
			{
				primeClauseIdx = -1;
				byte b = 0;
				byte b2 = (byte)clauses.Length;
				while (b < b2)
				{
					ClearClause(b, revise, retainTally);
					b++;
				}
			}
		}

		private byte GetOperandCount(byte ci)
		{
			byte b = 0;
			for (byte b2 = 0; b2 < 8; b2++)
			{
				if (GetOperand(ci, b2, out var _))
				{
					b++;
				}
			}
			return b;
		}

		private bool GetOperand(byte ci, byte opsi, out byte opi)
		{
			return GetOperand(clauses[ci].s.opr.operands, opsi, out opi);
		}

		public static bool GetOperand(primitive operands, byte opsi, out byte opi)
		{
			byte @byte = operands.GetByte(opsi);
			if (@byte == 0)
			{
				opi = 0;
				return false;
			}
			opi = (byte)(@byte - 1);
			return true;
		}

		private void SetOperand(byte ci, byte opsi, byte opi)
		{
			SetOperand(ref clauses[ci].s.opr.operands, opsi, opi);
		}

		private static void SetOperand(ref primitive subclauses, byte opsi, byte opi)
		{
			subclauses.SetByte(opsi, (byte)(opi + 1));
		}

		private void HandleException(Exception exc)
		{
			UnityEngine.Debug.LogException(exc, owner);
			LogException(exc);
			Inspection inspection = Inspect();
			ClearAllClauses(revise: false, retainTally: false);
			RemoveFromTopLevelList();
			_state.value = State.Stopped;
			if (this.onException != null)
			{
				this.onException(exc, inspection);
			}
			if (_caller != null && _caller.onCalleeException != null)
			{
				_caller.onCalleeException(this, exc);
			}
			if (Haglet.onAnyException != null)
			{
				Haglet.onAnyException(this, exc, inspection);
			}
		}

		public byte GetClearClause()
		{
			byte b = 0;
			if (clauses != null)
			{
				int num = clauses.Length;
				while (b < num)
				{
					if (clauses[b].type != 0)
					{
						b++;
						continue;
					}
					goto IL_006a;
				}
			}
			Array.Resize(ref clauses, Mathf.Clamp(Mathf.CeilToInt((float)(int)b * 1.5f), 3, 235));
			UpdateClauseSourceInfo(b);
			LogClauseExpansion(b, clauses.Length);
			goto IL_006a;
			IL_006a:
			clauses[b].rev++;
			clauses[b].tally = (clauses[b].total = 0);
			UpdateClauseSourceInfo(b);
			return b;
		}

		private void UpdateClauseSourceInfo(ushort ci)
		{
		}

		public static StackFrame GetCurrentRoutineFrame()
		{
			StackTrace stackTrace = new StackTrace(2, fNeedFileInfo: true);
			for (int i = 0; i < stackTrace.FrameCount; i++)
			{
				StackFrame frame = stackTrace.GetFrame(i);
				Type declaringType = frame.GetMethod().DeclaringType;
				if (declaringType.IsIterator<Routine.Yield>())
				{
					return frame;
				}
				if (declaringType.DeclaringType.IsIterator<Routine.Yield>())
				{
					return frame;
				}
			}
			return null;
		}

		private void PushAsCoroutine()
		{
			if (++coroutineStack == 1 && (execParams.contexts & ExecContext.CoroutineUpdate) == 0)
			{
				owner.StartCoroutine(this);
			}
		}

		private void PopAsCoroutine()
		{
			if (--coroutineStack == 0 && (execParams.contexts & ExecContext.CoroutineUpdate) == 0)
			{
				owner.StopCoroutine(this);
			}
		}

		Wait Wait.IUntil.Happening(IHagletEvent @event, int total, bool allowPreMetNow, bool allowPreMetLater)
		{
			if (skipping || !waitEnabled)
			{
				return Wait.None;
			}
			if (total == 0)
			{
				return Wait.PreMet;
			}
			if (allowPreMetNow && (bool)@event.happening && --total == 0)
			{
				return Wait.PreMet;
			}
			byte clearClause = GetClearClause();
			clauses[clearClause].type = Clause.Type.UntilEvent;
			clauses[clearClause].@event = @event;
			clauses[clearClause].total = (ushort)total;
			if (allowPreMetLater)
			{
				clauses[clearClause].flags = Clause.Flags.AllowPreMet;
			}
			return new Wait(clearClause, this);
		}

		Wait Wait.IUntil.True(IHagletCondition cond, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
		{
			return ((Wait.IFor)this).Value(cond, val: true, total, allowPreMetNow, allowPreMetLater, check, asCoroutine);
		}

		Wait Wait.IUntil.False(IHagletCondition cond, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
		{
			return ((Wait.IFor)this).Value(cond, val: false, total, allowPreMetNow, allowPreMetLater, check, asCoroutine);
		}

		Wait Wait.IUntil.True(Func<bool> func, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
		{
			return ((Wait.IFor)this).Value(func, value: true, total, allowPreMetNow, allowPreMetLater, check, asCoroutine);
		}

		Wait Wait.IUntil.False(Func<bool> func, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
		{
			return ((Wait.IFor)this).Value(func, value: false, total, allowPreMetNow, allowPreMetLater, check, asCoroutine);
		}

		Wait Wait.IUntil.True(IHagletValue<bool> hVal, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
		{
			return ((Wait.IFor)this).Value(hVal, val: true, total, allowPreMetNow, allowPreMetLater, check ?? hVal, asCoroutine);
		}

		Wait Wait.IUntil.False(IHagletValue<bool> hVal, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
		{
			return ((Wait.IFor)this).Value(hVal, val: false, total, allowPreMetNow, allowPreMetLater, check ?? hVal, asCoroutine);
		}

		Wait Wait.IUntil.Entered<T>(IHagletValue<T> hVal, T enterVal, int total, bool allowPreMetNow, bool allowPreMetLater)
		{
			return WaitForHagletValue(hVal, enterVal, true, 0, total, allowPreMetNow, allowPreMetLater, null, asCoroutine: false);
		}

		Wait Wait.IUntil.Exitted<T>(IHagletValue<T> hVal, T exitVal, int total, bool allowPreMetNow, bool allowPreMetLater)
		{
			return WaitForHagletValue(hVal, exitVal, false, 0, total, allowPreMetNow, allowPreMetLater, null, asCoroutine: false);
		}

		Wait Wait.IUntil.Switched<T>(IHagletValue<T> hVal, T exitVal, T enterVal, int total, bool allowPreMetNow, bool allowPreMetLater)
		{
			if (skipping || !waitEnabled)
			{
				return Wait.None;
			}
			if (hVal == null)
			{
				return Wait.None;
			}
			if (total == 0)
			{
				return Wait.PreMet;
			}
			int num = hVal.Declare(exitVal);
			int num2 = hVal.Declare(enterVal);
			if (allowPreMetNow && (bool)hVal.happening && hVal.exitValueID == num && hVal.enterValueID == num2 && --total == 0)
			{
				return Wait.PreMet;
			}
			byte clearClause = GetClearClause();
			clauses[clearClause].type = Clause.Type.ForHagValue;
			clauses[clearClause].@event = hVal;
			clauses[clearClause].total = (ushort)total;
			clauses[clearClause].hVal = hVal;
			clauses[clearClause].s.fhv.exitValueID = num;
			clauses[clearClause].s.fhv.enterValueID = num2;
			if (allowPreMetLater)
			{
				clauses[clearClause].flags = Clause.Flags.AllowPreMet;
			}
			return new Wait(clearClause, this);
		}

		Wait Wait.IUntil.Changed<T>(IHagletValue<T> hVal, int total, bool allowPreMetNow, bool allowPreMetLater)
		{
			return ((Wait.IUntil)this).Happening((IHagletEvent)hVal, total, allowPreMetNow, allowPreMetLater);
		}

		Wait Wait.IUntil.Greater<T>(IHagletValue<T> hVal, T val, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
		{
			return WaitForHagletValue(hVal, val, true, 1, total, allowPreMetNow, allowPreMetLater, check, asCoroutine);
		}

		Wait Wait.IUntil.Smaller<T>(IHagletValue<T> hVal, T val, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
		{
			return WaitForHagletValue(hVal, val, true, -1, total, allowPreMetNow, allowPreMetLater, check, asCoroutine);
		}

		Wait Wait.IUntil.Triggered(int total, bool allowPreMetNow, bool allowPreMetLater)
		{
			return WaitUntilTriggered(null, total, allowPreMetNow, allowPreMetLater);
		}

		Wait Wait.IUntil.Triggered(int arg, int total, bool allowPreMetNow, bool allowPreMetLater)
		{
			return WaitUntilTriggered(arg, total, allowPreMetNow, allowPreMetLater);
		}

		Wait Wait.IUntil.Triggered<T>(T arg, int total, bool allowPreMetNow, bool allowPreMetLater)
		{
			return WaitUntilTriggered(arg.ToInt32(null), total, allowPreMetNow, allowPreMetLater);
		}

		Wait Wait.IUntil.ArgChange(int arg, int total, bool allowPreMetNow, bool allowPreMetLater)
		{
			return WaitUntilArgChange((byte)arg, null, total, allowPreMetNow, allowPreMetLater);
		}

		Wait Wait.IUntil.ArgChange(int total, bool allowPreMetNow, bool allowPreMetLater)
		{
			return WaitUntilArgChange(null, null, total, allowPreMetNow, allowPreMetLater);
		}

		Wait Wait.IFor.Updates(int total, bool allowPreMetNow, bool allowPreMetLater, bool asCoroutine)
		{
			if (asCoroutine || (!HagletBehaviourTime.anyExist && owner != null))
			{
				if (skipping || !waitEnabled)
				{
					return Wait.None;
				}
				if (allowPreMetNow && (execParams.contexts & ExecContext.CoroutineUpdate) != 0 && --total == 0)
				{
					return Wait.PreMet;
				}
				byte clearClause = GetClearClause();
				clauses[clearClause].type = Clause.Type.ForCoroutineUpdate;
				clauses[clearClause].total = (ushort)total;
				if (allowPreMetLater)
				{
					clauses[clearClause].flags = Clause.Flags.AllowPreMet;
				}
				return new Wait(clearClause, this);
			}
			return ((Wait.IUntil)this).Happening((IHagletEvent)HagletEvent.onDefaultUpdate, total, allowPreMetNow, allowPreMetLater);
		}

		Wait Wait.IFor.LateUpdates(int total, bool allowPreMetNow, bool allowPreMetLater)
		{
			return ((Wait.IUntil)this).Happening((IHagletEvent)HagletEvent.onDefaultLateUpdate, total, allowPreMetNow, allowPreMetLater);
		}

		Wait Wait.IFor.FixedUpdates(int total, bool allowPreMetNow, bool allowPreMetLater)
		{
			return ((Wait.IUntil)this).Happening((IHagletEvent)HagletEvent.onDefaultFixedUpdate, total, allowPreMetNow, allowPreMetLater);
		}

		Wait Wait.IFor.Seconds(float seconds, int total, IHagletEvent check, bool asCoroutine)
		{
			return WaitForSeconds(seconds, total, Clause.Type.ForSeconds, check, asCoroutine);
		}

		Wait Wait.IFor.RealSeconds(float seconds, int total, IHagletEvent check, bool asCoroutine)
		{
			return WaitForSeconds(seconds, total, Clause.Type.ForRealSeconds, check, asCoroutine);
		}

		Wait Wait.IFor.Value(IHagletCondition cond, bool val, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
		{
			if (skipping || !waitEnabled)
			{
				return Wait.None;
			}
			if (cond == null)
			{
				return Wait.None;
			}
			if (total == 0)
			{
				return Wait.PreMet;
			}
			if (allowPreMetNow && cond.isTrue == val && --total == 0)
			{
				return Wait.PreMet;
			}
			byte clearClause = GetClearClause();
			clauses[clearClause].type = Clause.Type.ForCondValue;
			clauses[clearClause].@event = ((check != null) ? check : ((asCoroutine || (!HagletBehaviourTime.anyExist && owner != null)) ? null : fallbackCheck));
			clauses[clearClause].total = (ushort)total;
			clauses[clearClause].cond = cond;
			clauses[clearClause].s.fcv.value = val;
			if (allowPreMetLater)
			{
				clauses[clearClause].flags = Clause.Flags.AllowPreMet;
			}
			return new Wait(clearClause, this);
		}

		Wait Wait.IFor.Value(Func<bool> func, bool val, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
		{
			if (skipping || !waitEnabled)
			{
				return Wait.None;
			}
			if (func == null)
			{
				return Wait.None;
			}
			if (total == 0)
			{
				return Wait.PreMet;
			}
			if (allowPreMetNow && func() == val && --total == 0)
			{
				return Wait.PreMet;
			}
			byte clearClause = GetClearClause();
			clauses[clearClause].type = Clause.Type.ForFuncValue;
			clauses[clearClause].@event = ((check != null) ? check : ((asCoroutine || (!HagletBehaviourTime.anyExist && owner != null)) ? null : fallbackCheck));
			clauses[clearClause].total = (ushort)total;
			clauses[clearClause].func = func;
			clauses[clearClause].s.ffv.value = val;
			if (allowPreMetLater)
			{
				clauses[clearClause].flags = Clause.Flags.AllowPreMet;
			}
			return new Wait(clearClause, this);
		}

		Wait Wait.IFor.Value<T>(IHagletValue<T> hVal, T val, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
		{
			return WaitForHagletValue(hVal, val, null, 0, total, allowPreMetNow, allowPreMetLater, check, asCoroutine);
		}

		Wait Wait.IFor.GotoSelector(Func<int> selector, bool allowPreMetLater, bool allowGotoLatest, IHagletEvent check, bool asCoroutine)
		{
			if (skipping || !waitEnabled)
			{
				return Wait.None;
			}
			byte clearClause = GetClearClause();
			clauses[clearClause].type = Clause.Type.GotoSelector;
			clauses[clearClause].@event = ((check != null) ? check : ((asCoroutine || (!HagletBehaviourTime.anyExist && owner != null)) ? null : fallbackCheck));
			clauses[clearClause].gotoSelector = selector;
			clauses[clearClause].total = 1;
			if (allowPreMetLater)
			{
				clauses[clearClause].flags = Clause.Flags.AllowPreMet;
			}
			clauses[clearClause].s.gts.allowLatest = allowGotoLatest;
			return new Wait(clearClause, this);
		}

		Wait Wait.IFor.ArgValueWithID<T>(int arg, T value, primitive? id, int total, bool allowPreMetNow, bool allowPreMetLater)
		{
			return WaitUntilArgChange((byte)arg, id ?? new primitive?(value.GetHashCode()), total, allowPreMetNow, allowPreMetLater);
		}

		Wait Wait.IFor.ArgValue<T>(int arg, T value, int total, bool allowPreMetNow, bool allowPreMetLater)
		{
			return WaitUntilArgChange((byte)arg, value.ToUInt64(null), total, allowPreMetNow, allowPreMetLater);
		}

		Wait Wait.IFor.ArgValue(int arg, ulong value, int total, bool allowPreMetNow, bool allowPreMetLater)
		{
			return WaitUntilArgChange((byte)arg, value, total, allowPreMetNow, allowPreMetLater);
		}

		Wait Wait.IFor.ArgValue(int arg, double value, int total, bool allowPreMetNow, bool allowPreMetLater)
		{
			return WaitUntilArgChange((byte)arg, value, total, allowPreMetNow, allowPreMetLater);
		}

		Wait Wait.IFor.ArgValue(int arg, float value, int total, bool allowPreMetNow, bool allowPreMetLater)
		{
			return WaitUntilArgChange((byte)arg, value, total, allowPreMetNow, allowPreMetLater);
		}

		Wait Wait.IFor.ArgValue(int arg, UnityEngine.Object value, int total, bool allowPreMetNow, bool allowPreMetLater)
		{
			return WaitUntilArgChange((byte)arg, value.GetInstanceID(), total, allowPreMetNow, allowPreMetLater);
		}

		Wait Wait.IFor.Any(Wait waitA, Wait waitB)
		{
			return WaitForTwo(waitA, waitB, Clause.Type.Subtotal, 1);
		}

		Wait Wait.IFor.All(Wait waitA, Wait waitB)
		{
			return WaitForTwo(waitA, waitB, Clause.Type.Subtotal, 2);
		}

		Wait Wait.IFor.Sequence(Wait waitA, Wait waitB)
		{
			return WaitForTwo(waitA, waitB, Clause.Type.Sequence, 2);
		}

		Wait Wait.IFor.Total(Wait wait, int multiple)
		{
			if (skipping)
			{
				return Wait.None;
			}
			if (wait == Wait.None)
			{
				return Wait.None;
			}
			clauses[wait.ci].total = (ushort)(clauses[wait.ci].total * multiple);
			return wait;
		}

		Wait Wait.IClient.Isolate(Wait wait)
		{
			clauses[wait.ci].flags |= Clause.Flags.Isolate;
			return wait;
		}

		bool Wait.IClient.GetMet(Wait wait)
		{
			return clauses[wait.ci].tally == clauses[wait.ci].total;
		}

		ushort Wait.IClient.GetTally(Wait wait)
		{
			return clauses[wait.ci].tally;
		}

		ushort Wait.IClient.GetTotal(Wait wait)
		{
			return clauses[wait.ci].total;
		}

		float Wait.IClient.GetTallySeconds(Wait wait)
		{
			return clauses[wait.ci].s.fsc.tallySecs;
		}

		Wait Wait.IClient.SetGoto(Wait wait, int @goto, bool allowGotoLatest)
		{
			if (skipping)
			{
				return Wait.None;
			}
			if (wait == Wait.None)
			{
				return Wait.None;
			}
			if (wait == Wait.PreMet)
			{
				return Wait.PreMet;
			}
			if (!allowGotoLatest && latestGoto != 0 && @goto == latestGoto)
			{
				ClearClause(wait.ci, revise: true, retainTallyAndTotal: false);
				return Wait.None;
			}
			clauses[wait.ci].@goto = @goto;
			return wait;
		}

		Wait Wait.IClient.RestrictToGotos(Wait wait, int gotos)
		{
			if (skipping)
			{
				return Wait.None;
			}
			if (wait == Wait.None)
			{
				return Wait.None;
			}
			if (wait == Wait.PreMet)
			{
				return Wait.PreMet;
			}
			if ((latestGoto & gotos) != 0)
			{
				return wait;
			}
			ClearClause(wait.ci, revise: true, retainTallyAndTotal: false);
			return Wait.None;
		}

		Wait Wait.IClient.SetSkip(Wait wait)
		{
			if (skipping)
			{
				return Wait.None;
			}
			if (wait == Wait.None)
			{
				return Wait.None;
			}
			if (wait == Wait.PreMet)
			{
				Skip();
				return Wait.None;
			}
			clauses[wait.ci].flags |= Clause.Flags.ThenSkip;
			return wait;
		}

		private Wait WaitForSeconds(float seconds, int total, Clause.Type type, IHagletEvent check, bool asCoroutine = false)
		{
			if (skipping || !waitEnabled)
			{
				return Wait.None;
			}
			if (seconds == 0f)
			{
				return Wait.PreMet;
			}
			if (total == 0)
			{
				return Wait.PreMet;
			}
			byte clearClause = GetClearClause();
			clauses[clearClause].type = type;
			clauses[clearClause].@event = ((check != null) ? check : ((asCoroutine || (!HagletBehaviourTime.anyExist && owner != null)) ? null : fallbackCheck));
			clauses[clearClause].total = (ushort)total;
			clauses[clearClause].s.fsc.totalSecs = seconds;
			return new Wait(clearClause, this);
		}

		private Wait WaitForHagletValue<T>(IHagletValue<T> hVal, T value, bool? enter, int comparison, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
		{
			if (skipping || !waitEnabled)
			{
				return Wait.None;
			}
			if (total == 0)
			{
				return Wait.PreMet;
			}
			if (allowPreMetNow && (!enter.HasValue || enter.Value) && hVal.CompareTo(value) == comparison && --total == 0)
			{
				return Wait.PreMet;
			}
			int value2 = hVal.Declare(value);
			byte clearClause = GetClearClause();
			clauses[clearClause].type = Clause.Type.ForHagValue;
			ref Clause reference = ref clauses[clearClause];
			IHagletEvent @event;
			if (check == null)
			{
				IHagletEvent hagletEvent = (asCoroutine ? null : hVal);
				@event = hagletEvent;
			}
			else
			{
				@event = check;
			}
			reference.@event = @event;
			clauses[clearClause].total = (ushort)total;
			clauses[clearClause].hVal = hVal;
			if (allowPreMetLater)
			{
				clauses[clearClause].flags = Clause.Flags.AllowPreMet;
			}
			if (!enter.HasValue || enter.Value)
			{
				clauses[clearClause].s.fhv.enterValueID = value2;
				clauses[clearClause].s.fhv.enterValueComparison = comparison;
			}
			else
			{
				clauses[clearClause].s.fhv.exitValueID = value2;
				clauses[clearClause].s.fhv.exitValueComparison = comparison;
			}
			return new Wait(clearClause, this);
		}

		private Wait WaitUntilArgChange(byte? arg, primitive? valWaitID, int total, bool allowPreMetNow, bool allowPreMetLater)
		{
			if (skipping || !waitEnabled)
			{
				return Wait.None;
			}
			if (total == 0)
			{
				return Wait.PreMet;
			}
			if (allowPreMetNow && (execParams.contexts & ExecContext.ArgChange) != 0 && (!arg.HasValue || execParams.arg == arg))
			{
				if (valWaitID.HasValue)
				{
					primitive argValWaitID = execParams.argValWaitID;
					primitive? primitive2 = valWaitID;
					if (!(argValWaitID == primitive2))
					{
						goto IL_00c9;
					}
				}
				if (--total == 0)
				{
					return Wait.PreMet;
				}
			}
			goto IL_00c9;
			IL_00c9:
			byte clearClause = GetClearClause();
			clauses[clearClause].type = Clause.Type.UntilArgChange;
			clauses[clearClause].total = (ushort)total;
			clauses[clearClause].s.ach.arg = arg;
			clauses[clearClause].s.ach.valWaitID = valWaitID;
			if (allowPreMetLater)
			{
				clauses[clearClause].flags = Clause.Flags.AllowPreMet;
			}
			return new Wait(clearClause, this);
		}

		private Wait WaitUntilTriggered(int? arg, int total, bool allowPreMetNow, bool allowPreMetLater)
		{
			if (skipping || !waitEnabled)
			{
				return Wait.None;
			}
			if (total == 0)
			{
				return Wait.PreMet;
			}
			if (allowPreMetNow && (execParams.contexts & ExecContext.Trigger) != 0 && --total == 0)
			{
				return Wait.PreMet;
			}
			byte clearClause = GetClearClause();
			clauses[clearClause].type = Clause.Type.UntilTriggered;
			clauses[clearClause].total = (ushort)total;
			clauses[clearClause].s.utr.arg = arg;
			if (allowPreMetLater)
			{
				clauses[clearClause].flags = Clause.Flags.AllowPreMet;
			}
			return new Wait(clearClause, this);
		}

		private Wait WaitForTwo(Wait wa, Wait wb, Clause.Type type, byte subtotal)
		{
			if (skipping || !waitEnabled)
			{
				bool flag = wa.ci < ((clauses != null) ? clauses.Length : 0) && clauses[wa.ci].type == Clause.Type.Call;
				bool flag2 = wb.ci < ((clauses != null) ? clauses.Length : 0) && clauses[wb.ci].type == Clause.Type.Call;
				if (flag && !flag2)
				{
					return wa;
				}
				if (!flag && flag2)
				{
					return wb;
				}
				if (!flag && !flag2)
				{
					return Wait.None;
				}
			}
			if (wa.si == Routine.Yield.SpecialIndex.START)
			{
				return wb;
			}
			if (wb.si == Routine.Yield.SpecialIndex.START)
			{
				return wa;
			}
			if (wa.si == Routine.Yield.SpecialIndex.WaitPreMet && wb.si == Routine.Yield.SpecialIndex.WaitPreMet)
			{
				return Wait.PreMet;
			}
			switch (subtotal)
			{
			case 1:
				switch (wa.si)
				{
				case Routine.Yield.SpecialIndex.WaitPreMet:
					if (wb.si != Routine.Yield.SpecialIndex.WaitPreMet && wb.si != Routine.Yield.SpecialIndex.WaitForever)
					{
						ClearClause(wb.ci, revise: true, retainTallyAndTotal: false);
					}
					return Wait.PreMet;
				case Routine.Yield.SpecialIndex.WaitForever:
					return wb;
				}
				switch (wb.si)
				{
				case Routine.Yield.SpecialIndex.WaitPreMet:
					ClearClause(wa.ci, revise: true, retainTallyAndTotal: false);
					return Wait.PreMet;
				case Routine.Yield.SpecialIndex.WaitForever:
					return wa;
				}
				break;
			case 2:
				switch (type)
				{
				case Clause.Type.Subtotal:
					switch (wa.si)
					{
					case Routine.Yield.SpecialIndex.WaitPreMet:
						return wb;
					case Routine.Yield.SpecialIndex.WaitForever:
						if (wb.si != Routine.Yield.SpecialIndex.WaitPreMet && wb.si != Routine.Yield.SpecialIndex.WaitForever)
						{
							ClearClause(wb.ci, revise: true, retainTallyAndTotal: false);
						}
						return Wait.Forever;
					}
					switch (wb.si)
					{
					case Routine.Yield.SpecialIndex.WaitPreMet:
						return wa;
					case Routine.Yield.SpecialIndex.WaitForever:
						ClearClause(wa.ci, revise: true, retainTallyAndTotal: false);
						return Wait.Forever;
					}
					break;
				case Clause.Type.Sequence:
				{
					switch (wa.si)
					{
					case Routine.Yield.SpecialIndex.WaitPreMet:
						return wb;
					case Routine.Yield.SpecialIndex.WaitForever:
						if (wb.si != Routine.Yield.SpecialIndex.WaitPreMet && wb.si != Routine.Yield.SpecialIndex.WaitForever)
						{
							ClearClause(wb.ci, revise: true, retainTallyAndTotal: false);
						}
						return Wait.Forever;
					}
					Routine.Yield.SpecialIndex si = wb.si;
					if (si == Routine.Yield.SpecialIndex.WaitForever)
					{
						ClearClause(wa.ci, revise: true, retainTallyAndTotal: false);
						return Wait.Forever;
					}
					break;
				}
				}
				break;
			}
			bool flag3;
			bool flag4;
			byte b;
			Wait wait;
			if ((clauses[wa.ci].flags & Clause.Flags.Isolate) == 0 && (clauses[wb.ci].flags & Clause.Flags.Isolate) == 0)
			{
				flag3 = clauses[wa.ci].type == type;
				flag4 = clauses[wb.ci].type == type;
				if (flag3 && flag4)
				{
					byte operandCount = GetOperandCount(wa.ci);
					byte operandCount2 = GetOperandCount(wb.ci);
					b = (byte)(operandCount + operandCount2);
					if (b < 16)
					{
						if (type != Clause.Type.Subtotal)
						{
							if (type == Clause.Type.Sequence)
							{
								goto IL_03c3;
							}
						}
						else if ((subtotal == 1 && clauses[wa.ci].s.opr.subtotal == 1 && clauses[wb.ci].s.opr.subtotal == 1) || (subtotal == 2 && clauses[wa.ci].s.opr.subtotal == operandCount && clauses[wb.ci].s.opr.subtotal == operandCount2))
						{
							goto IL_03c3;
						}
					}
				}
				else if (flag3 || flag4)
				{
					wait = (flag3 ? wa : wb);
					if (GetOperandCount(wait.ci) < 8)
					{
						if (type != Clause.Type.Subtotal)
						{
							if (type == Clause.Type.Sequence)
							{
								goto IL_0602;
							}
						}
						else if (clauses[wait.ci].s.opr.subtotal == ((subtotal == 1) ? 1 : GetOperandCount(wait.ci)))
						{
							goto IL_0602;
						}
					}
				}
			}
			byte clearClause = GetClearClause();
			clauses[clearClause].type = type;
			clauses[clearClause].s.opr.subtotal = subtotal;
			clauses[clearClause].total = 1;
			clauses[clearClause].flags = Clause.Flags.AllowPreMet;
			SetOperand(clearClause, 0, wa.ci);
			SetOperand(clearClause, 1, wb.ci);
			clauses[wa.ci].rev++;
			clauses[wb.ci].rev++;
			return new Wait(clearClause, this);
			IL_0602:
			primitive subclauses = default(primitive);
			byte b2 = 0;
			if (flag4)
			{
				SetOperand(ref subclauses, b2++, wa.ci);
			}
			for (byte b3 = 0; b3 < 8; b3++)
			{
				if (GetOperand(wait.ci, b3, out var opi))
				{
					SetOperand(ref subclauses, b2++, opi);
				}
			}
			if (flag3)
			{
				SetOperand(ref subclauses, b2++, wb.ci);
			}
			clauses[wait.ci].s.opr.operands = subclauses;
			clauses[wait.ci].rev++;
			if (subtotal == 2)
			{
				clauses[wait.ci].s.opr.subtotal++;
			}
			UpdateClauseSourceInfo(wait.ci);
			return new Wait(wait.ci, this);
			IL_03c3:
			primitive subclauses2 = default(primitive);
			primitive subclauses3 = default(primitive);
			byte b4 = 0;
			for (byte b5 = 0; b5 < 8; b5++)
			{
				if (GetOperand(wa.ci, b5, out var opi2))
				{
					SetOperand(ref subclauses2, b4++, opi2);
				}
			}
			for (byte b6 = 0; b6 < 8; b6++)
			{
				if (GetOperand(wb.ci, b6, out var opi3))
				{
					if (b4 < 8)
					{
						SetOperand(ref subclauses2, b4++, opi3);
					}
					else
					{
						SetOperand(ref subclauses3, (byte)(b4++ - 7), opi3);
					}
				}
			}
			clauses[wa.ci].rev++;
			clauses[wa.ci].s.opr.operands = subclauses2;
			UpdateClauseSourceInfo(wa.ci);
			if (b <= 8)
			{
				ClearClause(wb.ci, revise: true, retainTallyAndTotal: false, propagate: false);
				clauses[wa.ci].s.opr.subtotal = b;
				return new Wait(wa.ci, this);
			}
			SetOperand(ref subclauses3, 0, wa.ci);
			clauses[wb.ci].rev++;
			clauses[wb.ci].s.opr.operands = subclauses3;
			clauses[wa.ci].s.opr.subtotal = 8;
			clauses[wb.ci].s.opr.subtotal = (byte)(b + 1 - 8);
			UpdateClauseSourceInfo(wb.ci);
			return new Wait(wb.ci, this);
		}

		void HagletEvent.IOwner.Own(IHagletEvent @event)
		{
			if (ownedEventCount == ownedEvents.Length)
			{
				Array.Resize(ref ownedEvents, Mathf.CeilToInt((float)ownedEventCount * 1.5f));
			}
			ownedEvents[ownedEventCount++] = @event;
		}

		public static IHaglet Create(Routine.Func func, string name = null, bool startNow = false, int? initWaitCap = null, string editorGroup = null)
		{
			return new Haglet4R<int, int, int, int, int>(func?.Invoke(), name, startNow, initWaitCap, editorGroup);
		}

		public static IHaglet Create(out IHaglet hag, Routine.Func func, string name = null, bool startNow = false, int? initWaitCap = null, string editorGroup = null)
		{
			IEnumerator<Routine.Yield> enumerator = func?.Invoke();
			return hag = new Haglet4R<int, int, int, int, int>(enumerator, name, startNow, initWaitCap, editorGroup);
		}

		public static IHaglet<AT0> Create<AT0>(out IHaglet<AT0> hag, Routine.Func1<AT0> func, string name = null, bool startNow = false, int? initWaitCap = null, string editorGroup = null)
		{
			IEnumerator<Routine.Yield> enumerator = func?.Invoke(default(AT0));
			return hag = new Haglet4R<AT0, int, int, int, int>(enumerator, name, startNow, initWaitCap, editorGroup);
		}

		public static IHaglet<AT0, AT1> Create<AT0, AT1>(out IHaglet<AT0, AT1> hag, Routine.Func2<AT0, AT1> func, string name = null, bool startNow = false, int? initWaitCap = null, string editorGroup = null)
		{
			IEnumerator<Routine.Yield> enumerator = func?.Invoke(default(AT0), default(AT1));
			return hag = new Haglet4R<AT0, AT1, int, int, int>(enumerator, name, startNow, initWaitCap, editorGroup);
		}

		public static IHaglet<AT0, AT1, AT2> Create<AT0, AT1, AT2>(out IHaglet<AT0, AT1, AT2> hag, Routine.Func3<AT0, AT1, AT2> func, string name = null, bool startNow = false, int? initWaitCap = null, string editorGroup = null)
		{
			IEnumerator<Routine.Yield> enumerator = func?.Invoke(default(AT0), default(AT1), default(AT2));
			return hag = new Haglet4R<AT0, AT1, AT2, int, int>(enumerator, name, startNow, initWaitCap, editorGroup);
		}

		public static IHaglet<AT0, AT1, AT2, AT3> Create<AT0, AT1, AT2, AT3>(out IHaglet<AT0, AT1, AT2, AT3> hag, Routine.Func4<AT0, AT1, AT2, AT3> func, string name = null, bool startNow = false, int? initWaitCap = null, string editorGroup = null)
		{
			IEnumerator<Routine.Yield> enumerator = func?.Invoke(default(AT0), default(AT1), default(AT2), default(AT3));
			return hag = new Haglet4R<AT0, AT1, AT2, AT3, int>(enumerator, name, startNow, initWaitCap, editorGroup);
		}

		public static IHagletReturn<RT> Create<RT>(out IHagletReturn<RT> hag, Routine.FuncR<RT> func, string name = null, bool startNow = false, int? initWaitCap = null, string editorGroup = null)
		{
			IEnumerator<Routine.Yield> enumerator = func?.Invoke(default(Routine.Return<RT>));
			return hag = new Haglet4R<int, int, int, int, RT>(enumerator, name, startNow, initWaitCap, editorGroup);
		}

		public static IHagletReturn<AT0, RT> Create<AT0, RT>(out IHagletReturn<AT0, RT> hag, Routine.Func1R<AT0, RT> func, string name = null, bool startNow = false, int? initWaitCap = null, string editorGroup = null)
		{
			IEnumerator<Routine.Yield> enumerator = func?.Invoke(default(AT0), default(Routine.Return<RT>));
			return hag = new Haglet4R<AT0, int, int, int, RT>(enumerator, name, startNow, initWaitCap, editorGroup);
		}

		public static IHagletReturn<AT0, AT1, RT> Create<AT0, AT1, RT>(out IHagletReturn<AT0, AT1, RT> hag, Routine.Func2R<AT0, AT1, RT> func, string name = null, bool startNow = false, int? initWaitCap = null, string editorGroup = null)
		{
			IEnumerator<Routine.Yield> enumerator = func?.Invoke(default(AT0), default(AT1), default(Routine.Return<RT>));
			return hag = new Haglet4R<AT0, AT1, int, int, RT>(enumerator, name, startNow, initWaitCap, editorGroup);
		}

		public static IHagletReturn<AT0, AT1, AT2, RT> Create<AT0, AT1, AT2, RT>(out IHagletReturn<AT0, AT1, AT2, RT> hag, Routine.Func3R<AT0, AT1, AT2, RT> func, string name = null, bool startNow = false, int? initWaitCap = null, string editorGroup = null)
		{
			IEnumerator<Routine.Yield> enumerator = func?.Invoke(default(AT0), default(AT1), default(AT2), default(Routine.Return<RT>));
			return hag = new Haglet4R<AT0, AT1, AT2, int, RT>(enumerator, name, startNow, initWaitCap, editorGroup);
		}

		public static IHagletReturn<AT0, AT1, AT2, AT3, RT> Create<AT0, AT1, AT2, AT3, RT>(out IHagletReturn<AT0, AT1, AT2, AT3, RT> hag, Routine.Func4R<AT0, AT1, AT2, AT3, RT> func, string name = null, bool startNow = false, int? initWaitCap = null, string editorGroup = null)
		{
			IEnumerator<Routine.Yield> enumerator = func?.Invoke(default(AT0), default(AT1), default(AT2), default(AT3), default(Routine.Return<RT>));
			return hag = new Haglet4R<AT0, AT1, AT2, AT3, RT>(enumerator, name, startNow, initWaitCap, editorGroup);
		}

		public static bool Compare(ref Inspection l, ref Inspection r)
		{
			if (ArrayX.ContentsEqual(l.callStackIDs, r.callStackIDs) && ((string.IsNullOrEmpty(l.fileName) && string.IsNullOrEmpty(r.fileName)) || l.fileName == r.fileName) && ((string.IsNullOrEmpty(l.lastGotoName) && string.IsNullOrEmpty(r.lastGotoName)) || l.lastGotoName == r.lastGotoName) && l.state == r.state && l.pausedInCallStack == r.pausedInCallStack && l.pc == r.pc && l.lineNumber == r.lineNumber && ArrayX.ContentsEqual(l.clauses, r.clauses) && l.logInitCap == r.logInitCap && l.logMaxLength == r.logMaxLength && ArrayX.ContentsEqual(l.log, r.log))
			{
				return true;
			}
			return false;
		}

		public static IHaglet FindFirstStarted(ID id)
		{
			foreach (IHaglet item in allTopLevel)
			{
				if (item.id == id)
				{
					return item;
				}
				IHaglet haglet2 = item.FindFirstCallee(id, recursive: true);
				if (haglet2 != null)
				{
					return haglet2;
				}
			}
			return null;
		}

		public static IHaglet FindFirstStarted(ID[] stack)
		{
			if (stack == null || stack.Length == 0)
			{
				return null;
			}
			int num = stack.Length;
			foreach (IHaglet item in allTopLevel)
			{
				if (item.id != stack[0])
				{
					continue;
				}
				IHaglet haglet2 = item;
				int num2 = 1;
				while (true)
				{
					if (num2 < num)
					{
						if ((haglet2 = haglet2.FindFirstCallee(stack[num2], recursive: false)) == null)
						{
							break;
						}
						num2++;
						continue;
					}
					return haglet2;
				}
			}
			return null;
		}

		public string GetNameStack()
		{
			return Paths.Make(callStackIDs);
		}

		public void CallStackTrace(List<CallStackTraceEntry> trace, ref int count, ref int matchCount)
		{
			int num = 0;
			Haglet haglet = this;
			while ((haglet = haglet._caller) != null)
			{
				num++;
			}
			if (trace.Count <= count)
			{
				trace.Add(new CallStackTraceEntry(this, num));
			}
			else if (trace[count].Match(this, num))
			{
				matchCount++;
			}
			else
			{
				trace[count] = new CallStackTraceEntry(this, num);
			}
			count++;
			if (clauses == null)
			{
				return;
			}
			int i = 0;
			for (int num2 = clauses.Length; i < num2; i++)
			{
				if (clauses[i].type == Clause.Type.Call && !clauses[i].callee.stopped && !clauses[i].callee.completed)
				{
					clauses[i].callee.CallStackTrace(trace, ref count, ref matchCount);
				}
			}
		}

		public Inspection Inspect()
		{
			Inspection insp = default(Inspection);
			insp.callStackIDs = callStackIDs;
			insp.fileName = fileName;
			insp.lastGotoName = GetGotoName();
			insp.state = state;
			insp.pausedInCallStack = pausedInCallStack;
			insp.pc = support.GetPC(iterator);
			insp.lineNumber = lineNumber;
			insp.logInitCap = support.logInitialCapacity;
			insp.logMaxLength = support.logMaximumLength;
			if (log != null)
			{
				insp.log = new Inspection.LogLine[log.Count];
				log.CopyTo(insp.log, 0);
			}
			else
			{
				insp.log = new Inspection.LogLine[0];
			}
			if (primeClauseIdx == -1)
			{
				insp.clauses = null;
				return insp;
			}
			insp.clauses = new Inspection.Clause[clauses.Length];
			int i = 0;
			for (int num = insp.clauses.Length; i < num; i++)
			{
				insp.clauses[i].str = $"[{i:D2}] {clauses[i].ToString()}";
				insp.clauses[i].depth = -1;
				if (clauses[i].type == Clause.Type.Call)
				{
					insp.clauses[i].calleeID = clauses[i].callee.id;
				}
			}
			int depthOrder = 0;
			SetOperandDepth(ref insp, (byte)primeClauseIdx, 0, ref depthOrder);
			return insp;
		}

		private void SetOperandDepth(ref Inspection insp, byte ci, int depth, ref int depthOrder)
		{
			insp.clauses[ci].depth = depth;
			insp.clauses[ci].depthOrder = depthOrder++;
			if (clauses[ci].type != Clause.Type.Subtotal && clauses[ci].type != Clause.Type.Sequence)
			{
				return;
			}
			for (byte b = 0; b < 8; b++)
			{
				if (GetOperand(ci, b, out var opi))
				{
					SetOperandDepth(ref insp, opi, depth + 1, ref depthOrder);
				}
			}
		}

		public IHaglet FindFirstCallee(ID id, bool recursive)
		{
			if (primeClauseIdx == -1)
			{
				return null;
			}
			return FindFirstCallee((byte)primeClauseIdx, id, recursive);
		}

		private IHaglet FindFirstCallee(byte ci, ID id, bool recursive)
		{
			if (clauses != null)
			{
				switch (clauses[ci].type)
				{
				case Clause.Type.Call:
					if (clauses[ci].callee.id == id)
					{
						return clauses[ci].callee;
					}
					if (recursive)
					{
						return clauses[ci].callee.FindFirstCallee(id, recursive: true);
					}
					break;
				case Clause.Type.Subtotal:
				case Clause.Type.Sequence:
				{
					for (byte b = 0; b < 8; b++)
					{
						if (GetOperand(ci, b, out var opi))
						{
							IHaglet haglet = FindFirstCallee(opi, id, recursive);
							if (haglet != null)
							{
								return haglet;
							}
						}
					}
					break;
				}
				}
			}
			return null;
		}

		public void ClearLog()
		{
			if (log != null)
			{
				log.Clear();
			}
		}

		private void LogStateChange(State newState)
		{
			if (log != null)
			{
				Inspection.LogLine logLine = default(Inspection.LogLine);
				logLine.type = Inspection.LogLine.Type.StateChange;
				logLine.newState = newState;
				Inspection.LogLine logLine2 = logLine;
				Log(logLine2);
			}
		}

		private void LogGoto(int id, int clauseIdx = -1)
		{
			if (log != null)
			{
				Inspection.LogLine logLine = default(Inspection.LogLine);
				logLine.type = Inspection.LogLine.Type.Goto;
				logLine.@goto = support.GetGotoNameFromID(id) ?? id.ToString();
				Inspection.LogLine logLine2 = logLine;
				Log(logLine2);
			}
		}

		private void LogGeneral(string general)
		{
			if (log != null)
			{
				Inspection.LogLine logLine = default(Inspection.LogLine);
				logLine.type = Inspection.LogLine.Type.General;
				logLine.general = general;
				Inspection.LogLine logLine2 = logLine;
				Log(logLine2);
			}
		}

		private void LogSkipStart()
		{
			if (log != null)
			{
				Inspection.LogLine logLine = default(Inspection.LogLine);
				logLine.type = Inspection.LogLine.Type.SkipStart;
				Inspection.LogLine logLine2 = logLine;
				Log(logLine2);
			}
		}

		private void LogSkipStop()
		{
			if (log != null)
			{
				Inspection.LogLine logLine = default(Inspection.LogLine);
				logLine.type = Inspection.LogLine.Type.SkipStop;
				Inspection.LogLine logLine2 = logLine;
				Log(logLine2);
			}
		}

		private void LogException(Exception exc)
		{
			if (log == null)
			{
				log = new Queue<Inspection.LogLine>(5);
			}
			StackFrame[] frames = new StackTrace(exc, fNeedFileInfo: true).GetFrames();
			StackFrame[] frames2 = new StackTrace(3, fNeedFileInfo: true).GetFrames();
			Inspection.LogLine logLine = default(Inspection.LogLine);
			logLine.type = Inspection.LogLine.Type.Exception;
			logLine.general = $"{exc.GetType().Name}: {exc.Message.Split('\n')[0]}";
			logLine.frames = new Inspection.LogLine.Frame[frames.Length + frames2.Length];
			Inspection.LogLine logLine2 = logLine;
			int i = 0;
			for (int num = logLine2.frames.Length; i < num; i++)
			{
				StackFrame stackFrame = ((i < frames.Length) ? frames[i] : frames2[i - frames.Length]);
				MethodBase method = stackFrame.GetMethod();
				string text = "[unidentified method]";
				string declaringTypeName = "[unidentified type]";
				if (method != null)
				{
					text = method.Name;
					declaringTypeName = method.DeclaringType.Name;
					if (method.DeclaringType.IsIterator<Routine.Yield>() && method.Name == "MoveNext")
					{
						text = method.DeclaringType.GetIteratorMethod().Name;
						declaringTypeName = method.DeclaringType.DeclaringType.Name;
					}
				}
				logLine2.frames[i].declaringTypeName = declaringTypeName;
				logLine2.frames[i].methodName = text.Substring(text.LastIndexOf('.') + 1);
				logLine2.frames[i].fileName = stackFrame.GetFileName();
				logLine2.frames[i].lineNum = stackFrame.GetFileLineNumber();
			}
			Log(logLine2);
		}

		private void LogClauseExpansion(int prevSize, int newSize)
		{
			if (log != null)
			{
				Inspection.LogLine logLine = default(Inspection.LogLine);
				logLine.type = Inspection.LogLine.Type.ClauseExpansion;
				logLine.prevSize = prevSize;
				logLine.newSize = newSize;
				Inspection.LogLine logLine2 = logLine;
				Log(logLine2);
			}
		}

		private void Log(Inspection.LogLine logLine)
		{
			if (logLine.frames == null)
			{
				logLine.frames = new Inspection.LogLine.Frame[1]
				{
					new Inspection.LogLine.Frame
					{
						fileName = fileName,
						lineNum = lineNumber
					}
				};
			}
			primitive primitive2 = new primitive(DateTime.Now);
			logLine.timeStamp0 = primitive2.int0;
			logLine.timeStamp1 = primitive2.int1;
			if (log.Count == support.logMaximumLength)
			{
				log.Dequeue();
			}
			log.Enqueue(logLine);
		}
	}
	public static class HagletX
	{
		public static Wait Started(this Wait.IUntil u, IHaglet hag, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false)
		{
			return Wait.Until.Entered(hag.iState, Haglet.State.Started, total, allowPreMetNow, allowPreMetLater);
		}

		public static Wait Stopped(this Wait.IUntil u, IHaglet hag, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false)
		{
			return Wait.Until.Entered(hag.iState, Haglet.State.Stopped, total, allowPreMetNow, allowPreMetLater);
		}

		public static Wait Paused(this Wait.IUntil u, IHaglet hag, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false)
		{
			return Wait.Until.Entered(hag.iState, Haglet.State.Paused, total, allowPreMetNow, allowPreMetLater);
		}

		public static Wait Unpaused(this Wait.IUntil u, IHaglet hag, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false)
		{
			return Wait.Until.Exitted(hag.iState, Haglet.State.Paused, total, allowPreMetNow, allowPreMetLater);
		}

		public static Wait Completed(this Wait.IUntil u, IHaglet hag, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false)
		{
			return Wait.Until.Entered(hag.iState, Haglet.State.Completed, total, allowPreMetNow, allowPreMetLater);
		}
	}
	public static class Routine
	{
		[AttributeUsage(AttributeTargets.Method)]
		public class DefaultNameAttribute : Attribute
		{
			public string name;

			public DefaultNameAttribute(string name)
			{
				this.name = name;
			}
		}

		[AttributeUsage(AttributeTargets.Method)]
		public class DefaultEditorGroupAttribute : Attribute
		{
			public string group;

			public DefaultEditorGroupAttribute(string group)
			{
				this.group = group;
			}
		}

		[AttributeUsage(AttributeTargets.Method)]
		public class InitialWaitCapacity : Attribute
		{
			public int cap;

			public InitialWaitCapacity(int cap = 5)
			{
				this.cap = Mathf.Clamp(cap, 0, 100);
			}
		}

		[AttributeUsage(AttributeTargets.Method)]
		public class UsesGotoAttribute : Attribute
		{
		}

		[AttributeUsage(AttributeTargets.Method)]
		public class EnableLogging : Attribute
		{
			public int initCap;

			public int maxLength;

			public EnableLogging(int initCap = 50, int maxLength = 500)
			{
				this.initCap = Mathf.Clamp(initCap, 0, 100);
				this.maxLength = Mathf.Clamp(maxLength, 1, 10000);
			}
		}

		public struct Yield
		{
			public enum SpecialIndex : byte
			{
				START = 235,
				WaitNone = 235,
				WaitPreMet = 236,
				WaitForever = 237,
				RoutineReset = 238,
				RoutineResetToHere = 239,
				RoutineStop = 240,
				RoutineStartsHere = 241,
				RoutineComplete = 242,
				WaitUntilTriggered = 243,
				WaitForUpdate = 244,
				WaitForLateUpdate = 245,
				WaitForFixedUpdate = 246,
				WaitForCoroutineUpdate = 247,
				WaitUntilArgChange = 248,
				MarkGoto = 249,
				Goto = 250,
				StopSkipping = 251,
				StopCallStackSkipping = 252,
				GotoNext = 253
			}

			public struct WaitData
			{
				public byte ci;

				public byte rev;

				public WaitData(byte i, byte r)
				{
					ci = i;
					rev = r;
				}
			}

			public struct SpecialData
			{
				public SpecialIndex si;

				public int gotoID;

				public SpecialData(SpecialIndex i, int gotoID)
				{
					si = i;
					this.gotoID = gotoID;
				}
			}

			[StructLayout(LayoutKind.Explicit)]
			public struct Data
			{
				[FieldOffset(0)]
				public WaitData clause;

				[FieldOffset(0)]
				public SpecialData special;

				public Data(byte i, byte r)
				{
					special = default(SpecialData);
					clause = new WaitData(i, r);
				}

				public Data(SpecialIndex i, int gotoID)
				{
					clause = default(WaitData);
					special = new SpecialData(i, gotoID);
				}
			}

			public readonly Data data;

			public static implicit operator Yield(SpecialIndex si)
			{
				return new Yield(si);
			}

			public static implicit operator Yield(Wait wait)
			{
				return new Yield(wait.ci, wait.rev);
			}

			public static implicit operator Yield(int id)
			{
				return new Yield(SpecialIndex.MarkGoto, id);
			}

			public static implicit operator Yield(Func<bool> func)
			{
				return Wait.Until.True(func);
			}

			public static implicit operator Yield(Func<int> selector)
			{
				return Wait.For.GotoSelector(selector);
			}

			private Yield(byte i, byte r = 0)
			{
				data = new Data(i, r);
			}

			private Yield(SpecialIndex i, int gotoID = 0)
			{
				data = new Data(i, gotoID);
			}

			public static Yield GetGoto(int id)
			{
				return new Yield(SpecialIndex.Goto, id);
			}
		}

		public struct Return<RT>
		{
			public RT value;

			public static implicit operator Return<RT>(RT value)
			{
				return new Return<RT>(value);
			}

			public static implicit operator RT(Return<RT> ret)
			{
				return ret.value;
			}

			public static implicit operator Yield(Return<RT> ret)
			{
				return Yield.SpecialIndex.RoutineComplete;
			}

			public Return(RT value)
			{
				this.value = value;
			}

			public override string ToString()
			{
				return value.ToString();
			}
		}

		public delegate IEnumerator<Yield> Func();

		public delegate IEnumerator<Yield> Func1<AT0>(AT0 a0);

		public delegate IEnumerator<Yield> Func2<AT0, AT1>(AT0 a0, AT1 a1);

		public delegate IEnumerator<Yield> Func3<AT0, AT1, AT2>(AT0 a0, AT1 a1, AT2 a2);

		public delegate IEnumerator<Yield> Func4<AT0, AT1, AT2, AT3>(AT0 a0, AT1 a1, AT2 a2, AT3 a3);

		public delegate IEnumerator<Yield> FuncR<RT>(Return<RT> ret);

		public delegate IEnumerator<Yield> Func1R<AT0, RT>(AT0 a0, Return<RT> ret);

		public delegate IEnumerator<Yield> Func2R<AT0, AT1, RT>(AT0 a0, AT1 a1, Return<RT> ret);

		public delegate IEnumerator<Yield> Func3R<AT0, AT1, AT2, RT>(AT0 a0, AT1 a1, AT2 a2, Return<RT> ret);

		public delegate IEnumerator<Yield> Func4R<AT0, AT1, AT2, AT3, RT>(AT0 a0, AT1 a1, AT2 a2, AT3 a3, Return<RT> ret);

		public const Yield.SpecialIndex Reset = Yield.SpecialIndex.RoutineReset;

		public const Yield.SpecialIndex ResetToHere = Yield.SpecialIndex.RoutineResetToHere;

		public const Yield.SpecialIndex Stop = Yield.SpecialIndex.RoutineStop;

		public const Yield.SpecialIndex Complete = Yield.SpecialIndex.RoutineComplete;

		public const Yield.SpecialIndex StartsHere = Yield.SpecialIndex.RoutineStartsHere;

		public const Yield.SpecialIndex StopSkipping = Yield.SpecialIndex.StopSkipping;

		public const Yield.SpecialIndex StopCallStackSkipping = Yield.SpecialIndex.StopCallStackSkipping;

		public const Yield.SpecialIndex GotoNext = Yield.SpecialIndex.GotoNext;

		public static IHaglet Current => Haglet.current;

		public static string Name => Haglet.current.name;

		public static MonoBehaviour Owner => Haglet.current.owner;

		public static bool InOne => Haglet.inOne;

		public static double DeltaTime => Haglet.current.deltaTime;

		public static float DeltaTimeF => (float)DeltaTime;

		public static double AccumulatedTime => Haglet.current.accumulatedTime;

		public static float AccumulatedTimeF => (float)AccumulatedTime;

		public static int LatestGoto => Haglet.current.latestGoto;

		public static bool Skipping => Haglet.current.skipping;

		public static bool IsBeingTriggered => Haglet.current.isBeingTriggered;

		public static int? TriggerArg => Haglet.current.triggerArg;

		public static int? ChangingArg => Haglet.current.changingArg;

		public static bool WaitEnabled
		{
			get
			{
				return Haglet.current.waitEnabled;
			}
			set
			{
				Haglet.current.waitEnabled = value;
			}
		}

		public static event Action<Haglet.State> OnPostStateChange
		{
			add
			{
				Haglet.current.onPostStateChange += value;
			}
			remove
			{
				Haglet.current.onPostStateChange -= value;
			}
		}

		public static event Action<int, int> OnGoto
		{
			add
			{
				Haglet.current.onGoto += value;
			}
			remove
			{
				Haglet.current.onGoto -= value;
			}
		}

		public static string GetNameStack()
		{
			return Haglet.current.GetNameStack();
		}

		public static bool In(IHaglet h)
		{
			return Haglet.In(h);
		}

		public static Yield Goto(int id)
		{
			return Yield.GetGoto(id);
		}

		public static Yield Goto<T>(T id) where T : struct, IConvertible
		{
			return Yield.GetGoto(id.ToInt32(null));
		}

		public static Yield StartOf<T>(T id) where T : struct, IConvertible
		{
			return id.ToInt32(null);
		}

		public static string GetGotoName(int id)
		{
			return Haglet.current.GetGotoName();
		}

		public static void Skip()
		{
			Haglet.current.Skip();
		}

		[Conditional("HG_DEBUG")]
		public static void Log(string log)
		{
			Haglet.current.Log(log);
		}

		[Conditional("HG_DEBUG")]
		public static void Log(string logFormat, object arg0)
		{
			Haglet.current.Log(logFormat, arg0);
		}

		[Conditional("HG_DEBUG")]
		public static void Log(string logFormat, object arg0, object arg1)
		{
			Haglet.current.Log(logFormat, arg0, arg1);
		}

		[Conditional("HG_DEBUG")]
		public static void Log(string logFormat, object arg0, object arg1, object arg2)
		{
			Haglet.current.Log(logFormat, arg0, arg1, arg2);
		}

		[Conditional("HG_DEBUG")]
		public static void Log(string logFormat, params object[] args)
		{
			Haglet.current.Log(logFormat, args);
		}
	}
	public abstract class HagletBehaviour : MonoBehaviour
	{
		public enum Event
		{
			Enabled = int.MinValue,
			Disabled,
			LateUpdate,
			FixedUpdate,
			ApplicationPause,
			ApplicationUnpause,
			ApplicationFocus,
			ApplicationUnfocus,
			ApplicationQuit,
			BecameVisible,
			BecameInvisible,
			TriggerEnter,
			TriggerExit,
			TriggerEnter2D,
			TriggerExit2D,
			Destroy
		}

		private IHaglet _haglet;

		private DynamicProperty<Collider> otherColliderVar;

		private DynamicProperty<Collider2D> otherCollider2DVar;

		protected virtual string hagletName => base.name;

		protected virtual byte initWaitCap => 10;

		protected virtual int initResetPoint => -1;

		protected virtual string editorGroup => "Default";

		protected virtual void Start()
		{
			IEnumerator<Routine.Yield> obj = Run();
			Haglet.Create(out _haglet, Run, hagletName, startNow: true, initWaitCap, editorGroup);
			otherColliderVar = obj.GetDynamicProperty<Collider>("otherCollider", required: false);
			otherCollider2DVar = obj.GetDynamicProperty<Collider2D>("otherCollider", required: false);
		}

		protected abstract IEnumerator<Routine.Yield> Run();

		protected Wait WaitUntil(Event @event, int total = 1)
		{
			return Wait.Until.Triggered((int)@event, total);
		}

		protected void StartHaglet()
		{
			_haglet.Start();
		}

		protected void StopHaglet()
		{
			_haglet.Stop();
		}

		protected void ResetHaglet()
		{
			_haglet.Reset();
		}

		protected void PauseHaglet()
		{
			_haglet.Pause();
		}

		protected void ResumeHaglet()
		{
			_haglet.Resume();
		}

		protected virtual void OnEnable()
		{
			_haglet.Trigger(int.MinValue);
		}

		protected virtual void OnDisable()
		{
			_haglet.Trigger(-2147483647);
		}

		protected void TriggerHagletLateUpdate()
		{
			_haglet.Trigger(-2147483646);
		}

		protected void TriggerHagletFixedUpate()
		{
			_haglet.Trigger(-2147483645);
		}

		protected virtual void OnApplicationPause(bool pause)
		{
			_haglet.Trigger(pause ? (-2147483644) : (-2147483643));
		}

		protected virtual void OnApplicationFocus(bool focus)
		{
			_haglet.Trigger(focus ? (-2147483642) : (-2147483641));
		}

		protected virtual void OnApplicationQuit()
		{
			_haglet.Trigger(-2147483640);
		}

		protected virtual void OnBecameVisible()
		{
			_haglet.Trigger(-2147483639);
		}

		protected virtual void OnBecameInvisible()
		{
			_haglet.Trigger(-2147483638);
		}

		protected virtual void OnTriggerEnter(Collider other)
		{
			_haglet.Trigger(-2147483637);
			if ((bool)otherColliderVar)
			{
				otherColliderVar.Set(other);
			}
		}

		protected virtual void OnTriggerExit(Collider other)
		{
			_haglet.Trigger(-2147483636);
			if ((bool)otherColliderVar)
			{
				otherColliderVar.Set(other);
			}
		}

		protected virtual void OnTriggerEnter2D(Collider2D other)
		{
			_haglet.Trigger(-2147483635);
			if ((bool)otherCollider2DVar)
			{
				otherCollider2DVar.Set(other);
			}
		}

		protected virtual void OnTriggerExit2D(Collider2D other)
		{
			_haglet.Trigger(-2147483634);
			if ((bool)otherCollider2DVar)
			{
				otherCollider2DVar.Set(other);
			}
		}

		protected virtual void OnDestroy()
		{
			_haglet.Trigger(-2147483633);
		}
	}
	[ExecuteInEditMode]
	public class HagletBehaviourTime : MonoBehaviour, HagletEvent.IOwner
	{
		private static readonly HagletTrigger _onDefaultUpdate;

		private static readonly HagletTrigger _onDefaultLateUpdate;

		private static readonly HagletTrigger _onDefaultFixedUpdate;

		private static readonly HagletTrigger _onRealUpdate;

		private static readonly HagletTrigger _onRealLateUpdate;

		private HagletTrigger _onUpdate;

		private HagletTrigger _onLateUpdate;

		private HagletTrigger _onFixedUpdate;

		[SerializeField]
		private int updateListCap;

		[SerializeField]
		private int lateUpdateListCap;

		[SerializeField]
		private int fixedUpdateListCap;

		[SerializeField]
		private bool provideDefaultUpdates = true;

		[SerializeField]
		private bool provideRealUpdates = true;

		[SerializeField]
		private bool cancelOnDestroy = true;

		[SerializeField]
		private bool executeInEditMode;

		[SerializeField]
		private bool dontDestroyOnLoad;

		public float timeScale = 1f;

		private bool startSkip;

		private static int count;

		private const float skipDeltaTime = 1f / 60f;

		public static HagletBehaviourTime @default { get; private set; }

		public static HagletEvent onDefaultUpdate => _onDefaultUpdate;

		public static HagletEvent onDefaultLateUpdate => _onDefaultLateUpdate;

		public static HagletEvent onDefaultFixedUpdate => _onDefaultFixedUpdate;

		public static HagletEvent onRealUpdate => _onRealUpdate;

		public static HagletEvent onRealLateUpdate => _onRealLateUpdate;

		public HagletEvent onUpdate => _onUpdate;

		public HagletEvent onLateUpdate => _onLateUpdate;

		public HagletEvent onFixedUpdate => _onFixedUpdate;

		public static bool anyExist => count > 0;

		public bool skipping { get; private set; }

		static HagletBehaviourTime()
		{
			_onDefaultUpdate = new HagletTrigger("Default Update", null, 100);
			_onDefaultLateUpdate = new HagletTrigger("Default Late Update", null, 100);
			_onDefaultFixedUpdate = new HagletTrigger("Default Fixed Update", null, 100);
			_onRealUpdate = new HagletTrigger("Real Update", null, 100);
			_onRealLateUpdate = new HagletTrigger("Real Late Update", null, 100);
		}

		private void Awake()
		{
			if (UnityEngine.Application.isPlaying && dontDestroyOnLoad)
			{
				UnityEngine.Object.DontDestroyOnLoad(this);
			}
			_onUpdate = (provideDefaultUpdates ? _onDefaultUpdate : new HagletTrigger(base.name + " Update", this, updateListCap));
			_onLateUpdate = (provideDefaultUpdates ? _onDefaultLateUpdate : new HagletTrigger(base.name + " Late Update", this, lateUpdateListCap));
			_onFixedUpdate = (provideDefaultUpdates ? _onDefaultFixedUpdate : new HagletTrigger(base.name + " Fixed Update", this, fixedUpdateListCap));
			if (provideDefaultUpdates)
			{
				@default = this;
			}
			count++;
		}

		private void OnDestroy()
		{
			if (count != 0)
			{
				if (cancelOnDestroy)
				{
					_onUpdate.Cancel();
					_onLateUpdate.Cancel();
					_onFixedUpdate.Cancel();
				}
				if (provideDefaultUpdates)
				{
					@default = null;
				}
				count--;
			}
		}

		private void Update()
		{
			if (!UnityEngine.Application.isPlaying && !executeInEditMode)
			{
				return;
			}
			if (startSkip)
			{
				startSkip = false;
				skipping = true;
				Skip();
				return;
			}
			if (provideRealUpdates)
			{
				_onRealUpdate.Trigger(Time.unscaledDeltaTime);
			}
			_onUpdate.Trigger(Time.deltaTime * timeScale);
		}

		private void LateUpdate()
		{
			if (UnityEngine.Application.isPlaying || executeInEditMode)
			{
				if (provideRealUpdates)
				{
					_onRealLateUpdate.Trigger(Time.unscaledDeltaTime);
				}
				_onLateUpdate.Trigger(Time.deltaTime * timeScale);
			}
		}

		private void FixedUpdate()
		{
			if (UnityEngine.Application.isPlaying || executeInEditMode)
			{
				_onFixedUpdate.Trigger(Time.fixedDeltaTime * timeScale);
			}
		}

		public void StartSkipping()
		{
			startSkip = true;
		}

		public void StopSkipping()
		{
			startSkip = false;
			skipping = false;
		}

		private void Skip()
		{
			float num = 0f;
			float num2 = 0f;
			float num3 = 1f / 60f * timeScale;
			for (; num < 600f; num += 1f / 60f)
			{
				_onUpdate.Trigger(num3, skipping: true);
				for (num2 += num3; num2 > Time.fixedDeltaTime; num2 -= Time.fixedDeltaTime)
				{
					_onFixedUpdate.Trigger(Time.fixedDeltaTime, skipping: true);
				}
				_onLateUpdate.Trigger(num3, skipping: true);
			}
		}

		void HagletEvent.IOwner.Own(IHagletEvent @event)
		{
		}

		public void StackTrace(TextWriter writer, int indent = 0, bool includeEvents = false)
		{
			for (int i = 0; i < indent * 4; i++)
			{
				writer.Write(' ');
			}
			writer.Write(base.name);
			writer.Write("\r\n");
			indent++;
			_onUpdate.EventStackTrace(writer, indent, includeEvents);
			_onFixedUpdate.EventStackTrace(writer, indent, includeEvents);
			_onLateUpdate.EventStackTrace(writer, indent, includeEvents);
		}
	}
	public class HagletBundle : ScriptableObject
	{
		[Serializable]
		public class Task
		{
			public string methodPrettyName;

			public string strParamValue;

			public long primParamVal;

			[NonSerialized]
			public bool open;
		}

		public List<Task> tasks;

		private void Awake()
		{
			tasks = new List<Task>();
		}
	}
	public interface IHagletCondition
	{
		bool isTrue { get; }
	}
	public abstract class HagletCondition : IHagletCondition
	{
		private class True : HagletCondition
		{
			public override bool isTrue => true;
		}

		private class False : HagletCondition
		{
			public override bool isTrue => false;
		}

		public static readonly HagletCondition @true = new True();

		public static readonly HagletCondition @false = new False();

		public abstract bool isTrue { get; }

		public static implicit operator bool(HagletCondition cond)
		{
			return cond?.isTrue ?? false;
		}

		public static implicit operator Wait(HagletCondition cond)
		{
			return Wait.Until.True(cond);
		}

		public static implicit operator Routine.Yield(HagletCondition cond)
		{
			return (Wait)cond;
		}

		public static Wait operator &(HagletCondition cond, Wait wait)
		{
			return (Wait)cond & wait;
		}

		public static Wait operator |(HagletCondition cond, Wait wait)
		{
			return (Wait)cond | wait;
		}

		public static Wait operator *(HagletCondition cond, int total)
		{
			return (Wait)cond * total;
		}

		public static Wait operator +(HagletCondition cond, Wait wait)
		{
			return (Wait)cond + wait;
		}

		public static Wait operator &(int states, HagletCondition cond)
		{
			return states & (Wait)cond;
		}
	}
	public class HagletFuncBool : HagletCondition
	{
		private readonly Func<bool> func;

		public override bool isTrue => func();

		public HagletFuncBool(Func<bool> func)
		{
			this.func = func;
		}
	}
	public static class HagletDynamicSupport
	{
		public interface IServer
		{
			bool usesGoto { get; }

			string defaultName { get; }

			string defaultEditorGroup { get; }

			int argCount { get; }

			int initialWaitCapacity { get; }

			int logInitialCapacity { get; }

			int logMaximumLength { get; }

			bool Serves(IEnumerator<Routine.Yield> iterator);

			object GetThis(IEnumerator<Routine.Yield> iterator);

			short GetPC(IEnumerator<Routine.Yield> iterator);

			void SetPC(IEnumerator<Routine.Yield> iterator, short pc);

			void SetPCBoxed(IEnumerator<Routine.Yield> iterator, object pc);

			void SetPCToGoto(IEnumerator<Routine.Yield> iterator, int gotoID);

			void ResetLocals(IEnumerator<Routine.Yield> iterator);

			ILocalsRecorder GetLocalsRecorder();

			short GetGotoPCFromID(int id);

			string GetGotoNameFromID(int id);

			int GetGotoIDFromName(string name);
		}

		public interface IServer<AT0, AT1, AT2, AT3, RT> : IServer
		{
			AT0 arg0Default { get; }

			AT1 arg1Default { get; }

			AT2 arg2Default { get; }

			AT3 arg3Default { get; }

			AT0 GetArg0(IEnumerator<Routine.Yield> iterator);

			void SetArg0(IEnumerator<Routine.Yield> iterator, AT0 pc);

			AT1 GetArg1(IEnumerator<Routine.Yield> iterator);

			void SetArg1(IEnumerator<Routine.Yield> iterator, AT1 pc);

			AT2 GetArg2(IEnumerator<Routine.Yield> iterator);

			void SetArg2(IEnumerator<Routine.Yield> iterator, AT2 pc);

			AT3 GetArg3(IEnumerator<Routine.Yield> iterator);

			void SetArg3(IEnumerator<Routine.Yield> iterator, AT3 pc);

			RT GetReturnValue(IEnumerator<Routine.Yield> iterator);

			void ClearReturnValue(IEnumerator<Routine.Yield> iterator);
		}

		public interface ILocalsRecorder
		{
			void RecordFrom(IEnumerator<Routine.Yield> iterator);

			void ApplyTo(IEnumerator<Routine.Yield> iterator);
		}

		public struct GotoInfo
		{
			public readonly int id;

			public readonly short pc;

			public readonly string name;

			public GotoInfo(int id, short pc, string name)
			{
				this.id = id;
				this.pc = pc;
				this.name = name;
			}
		}

		public struct LocalInfo
		{
			public readonly FieldInfo field;

			public readonly FieldInfo gateway;

			public LocalInfo(FieldInfo field, FieldInfo gateway = null)
			{
				this.field = field;
				this.gateway = gateway;
			}
		}

		public struct IteratorFieldsInfo
		{
			public readonly FieldInfo arg0;

			public readonly FieldInfo arg1;

			public readonly FieldInfo arg2;

			public readonly FieldInfo arg3;

			public readonly FieldInfo @return;

			public readonly FieldInfo @this;

			public readonly FieldInfo pc;

			public readonly LocalInfo[] locals;

			public IteratorFieldsInfo(FieldInfo arg0, FieldInfo arg1, FieldInfo arg2, FieldInfo arg3, FieldInfo @return, FieldInfo @this, FieldInfo pc, LocalInfo[] locals)
			{
				this.arg0 = arg0;
				this.arg1 = arg1;
				this.arg2 = arg2;
				this.arg3 = arg3;
				this.@return = @return;
				this.@this = @this;
				this.pc = pc;
				this.locals = locals;
			}

			public IteratorFieldsInfo(Type iterType, string arg0Name, string arg1Name, string arg2Name, string arg3Name, string returnName, string thisName, string pcName, string[] localNames, string[] gatewayNames)
			{
				arg0 = ((arg0Name != null) ? iterType.GetField(arg0Name, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) : null);
				arg1 = ((arg1Name != null) ? iterType.GetField(arg1Name, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) : null);
				arg2 = ((arg2Name != null) ? iterType.GetField(arg2Name, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) : null);
				arg3 = ((arg3Name != null) ? iterType.GetField(arg3Name, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) : null);
				@return = ((returnName != null) ? iterType.GetField(returnName, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) : null);
				this.@this = ((thisName != null) ? iterType.GetField(thisName, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) : null);
				pc = iterType.GetField(pcName, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				if (localNames != null)
				{
					int num = localNames.Length;
					locals = new LocalInfo[num];
					for (int i = 0; i < num; i++)
					{
						locals[i] = new LocalInfo(iterType.GetField(localNames[i], BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic), (gatewayNames[i] != null) ? iterType.GetField(gatewayNames[i], BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) : null);
					}
				}
				else
				{
					locals = null;
				}
			}

			public bool Equals(IteratorFieldsInfo other)
			{
				if (arg0 == other.arg0 && arg1 == other.arg1 && arg2 == other.arg2 && arg3 == other.arg3 && @return == other.@return && this.@this == other.@this && pc == other.pc && ArrayX.ContentsEqual(locals, other.locals))
				{
					return true;
				}
				return false;
			}

			public override bool Equals(object obj)
			{
				return Equals((IteratorFieldsInfo)obj);
			}

			public override int GetHashCode()
			{
				int num = -1091847573;
				if (arg0 != null)
				{
					num = num * -150010037 + arg0.Name.GetHashCode();
				}
				if (arg1 != null)
				{
					num = num * -150010037 + arg1.Name.GetHashCode();
				}
				if (arg2 != null)
				{
					num = num * -150010037 + arg2.Name.GetHashCode();
				}
				if (arg3 != null)
				{
					num = num * -150010037 + arg3.Name.GetHashCode();
				}
				if (@return != null)
				{
					num = num * -150010037 + @return.Name.GetHashCode();
				}
				num = num * -150010037 + (this.@this != null).GetHashCode();
				if (locals != null)
				{
					int num2 = locals.Length;
					while (--num2 >= 0)
					{
						num = num * -150010037 + locals[num2].field.FieldType.FullName.GetHashCode();
						num = num * -150010037 + locals[num2].field.Name.GetHashCode();
						if (locals[num2].gateway != null)
						{
							num = num * -150010037 + locals[num2].gateway.FieldType.FullName.GetHashCode();
							num = num * -150010037 + locals[num2].gateway.Name.GetHashCode();
						}
					}
				}
				return num;
			}
		}

		public class IteratorMethodInfo
		{
			[Flags]
			public enum Warning
			{
				UnresettableLocal = 1,
				MissingThisField = 2
			}

			public readonly Type iteratorType;

			public readonly MethodInfo method;

			public readonly string methodName;

			public readonly int argCount;

			public readonly Type arg0Type;

			public readonly Type arg1Type;

			public readonly Type arg2Type;

			public readonly Type arg3Type;

			public readonly Type returnType;

			public readonly object arg0Default;

			public readonly object arg1Default;

			public readonly object arg2Default;

			public readonly object arg3Default;

			public readonly string defaultName;

			public readonly string defaultEditorGroup;

			public readonly int initWaitCap;

			public readonly int logInitCap;

			public readonly int logMaxLength;

			public readonly GotoInfo[] gotos;

			public readonly IteratorFieldsInfo fields;

			public IteratorMethodInfo(Type iteratorType)
			{
				this.iteratorType = iteratorType;
				method = iteratorType.GetIteratorMethod();
				ParameterInfo[] parameters = method.GetParameters();
				int num = parameters.Length;
				int num2 = num - 1;
				FieldInfo[] array = iteratorType.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				FieldInfo field = iteratorType.GetField("<>1__state", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				FieldInfo field2 = iteratorType.GetField("<>4__this", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				FieldInfo arg = null;
				FieldInfo arg2 = null;
				FieldInfo arg3 = null;
				FieldInfo arg4 = null;
				FieldInfo @return = null;
				methodName = method.Name;
				argCount = num;
				if (num > 0 && parameters[num2].ParameterType.IsGenericType && parameters[num2].ParameterType.GetGenericTypeDefinition() == typeof(Routine.Return<>))
				{
					returnType = parameters[num2].ParameterType.GetGenericArguments()[0];
					@return = array.Find(parameters[num2].Name);
					argCount--;
				}
				if (argCount > 0)
				{
					arg0Type = parameters[0].ParameterType;
					arg = array.Find(parameters[0].Name);
				}
				if (argCount > 1)
				{
					arg1Type = parameters[1].ParameterType;
					arg2 = array.Find(parameters[1].Name);
				}
				if (argCount > 2)
				{
					arg2Type = parameters[2].ParameterType;
					arg3 = array.Find(parameters[2].Name);
				}
				if (argCount > 3)
				{
					arg3Type = parameters[3].ParameterType;
					arg4 = array.Find(parameters[3].Name);
				}
				List<LocalInfo> list = new List<LocalInfo>(10);
				int i = 0;
				for (int num3 = array.Length; i < num3; i++)
				{
					if (array[i].Name[0] == '<' && array[i].Name[1] != '>')
					{
						list.Add(new LocalInfo(array[i]));
					}
				}
				Type[] nestedTypes = iteratorType.GetNestedTypes(BindingFlags.DeclaredOnly | BindingFlags.NonPublic);
				if (!ArrayX.IsNullOrEmpty(nestedTypes))
				{
					string name = iteratorType.Name;
					int length = name.LastIndexOf(">c__Iterator") + 12;
					string value = name.Substring(0, length).Replace(">c__Iterator", ">c__AnonStore");
					int j = 0;
					for (int num4 = nestedTypes.Length; j < num4; j++)
					{
						if (!nestedTypes[j].Name.StartsWith(value))
						{
							continue;
						}
						FieldInfo fieldInfo = array.Find("$locvar", fullMatch: false, nestedTypes[j]);
						if (fieldInfo == null)
						{
							continue;
						}
						FieldInfo[] array2 = nestedTypes[j].GetFields(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
						int k = 0;
						for (int num5 = array2.Length; k < num5; k++)
						{
							if (array2[k].Name.IsIdentifier())
							{
								list.Add(new LocalInfo(array2[k], fieldInfo));
							}
						}
					}
				}
				arg0Default = ((argCount > 0) ? parameters[0].RawDefaultValue : null);
				arg1Default = ((argCount > 1) ? parameters[1].RawDefaultValue : null);
				arg2Default = ((argCount > 2) ? parameters[2].RawDefaultValue : null);
				arg3Default = ((argCount > 3) ? parameters[3].RawDefaultValue : null);
				if (arg0Default == DBNull.Value)
				{
					arg0Default = null;
				}
				if (arg1Default == DBNull.Value)
				{
					arg1Default = null;
				}
				if (arg2Default == DBNull.Value)
				{
					arg2Default = null;
				}
				if (arg3Default == DBNull.Value)
				{
					arg3Default = null;
				}
				Routine.DefaultNameAttribute attr = method.GetAttr<Routine.DefaultNameAttribute>();
				if (attr != null)
				{
					defaultName = attr.name;
				}
				if (defaultName == null || defaultName.Contains("{0}"))
				{
					string arg5 = iteratorType.DeclaringType.PrettyName();
					string text = $"{arg5}.{((methodName[0] != '_') ? methodName : methodName.Substring(1, methodName.Length - 1))}";
					defaultName = ((defaultName == null) ? text : string.Format(defaultName, text));
				}
				Routine.DefaultEditorGroupAttribute attr2 = method.GetAttr<Routine.DefaultEditorGroupAttribute>();
				defaultEditorGroup = ((attr2 != null) ? attr2.group : "Default");
				initWaitCap = method.GetAttr<Routine.InitialWaitCapacity>()?.cap ?? 5;
				Routine.EnableLogging attr3 = method.GetAttr<Routine.EnableLogging>(inherit: true);
				logInitCap = attr3?.initCap ?? (-1);
				logMaxLength = attr3?.maxLength ?? (-1);
				if (method.HasAttr<Routine.UsesGotoAttribute>())
				{
					gotos = GetGotos(iteratorType, field);
				}
				fields = new IteratorFieldsInfo(arg, arg2, arg3, arg4, @return, field2, field, (list.Count > 0) ? list.ToArray() : null);
			}

			private GotoInfo[] GetGotos(Type iteratorType, FieldInfo pcField)
			{
				GotoInfo[] array = new GotoInfo[32];
				Dictionary<int, string> dictionary = new Dictionary<int, string>(10);
				FieldInfo[] array2 = iteratorType.DeclaringType.GetFields(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
				int i = 0;
				for (int num = array2.Length; i < num; i++)
				{
					if (array2[i].IsLiteral && array2[i].FieldType == typeof(int))
					{
						dictionary[(int)array2[i].GetValue(null)] = array2[i].Name;
					}
				}
				MethodInfo methodInfo = iteratorType.GetMethod("MoveNext", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				ReflectionX.OpXFlagsPair opXFlagsPair = ReflectionX.OpX.PushValue.With(ReflectionX.OpXFlags.None, ReflectionX.OpXFlags.ToInt32);
				ReflectionX.OpX opX = ReflectionX.OpX.SetField;
				ReflectionX.OpXFlagsPair opXFlagsPair2 = ReflectionX.OpX.Call.With(ReflectionX.OpXFlags.NonVirtual | ReflectionX.OpXFlags.Int32Arg | ReflectionX.OpXFlags.FromArg, ReflectionX.OpXFlags.None);
				ReflectionX.OpXFlagsPair[] array3 = new ReflectionX.OpXFlagsPair[2] { opXFlagsPair, opX };
				ReflectionX.OpXFlagsPair[] array4 = new ReflectionX.OpXFlagsPair[1] { opXFlagsPair2 };
				_ = new ReflectionX.OpXFlagsPair[2][] { array3, array4 };
				IEnumerable<ReflectionX.OpXInst> enumerable = methodInfo.ParseIL(null, null, opXFlagsPair, opX, opXFlagsPair2);
				MethodInfo methodInfo2 = typeof(Routine.Yield).GetMethod("op_Implicit", new Type[1] { typeof(int) });
				MethodInfo methodInfo3 = typeof(Routine).GetMethod("StartOf");
				int num2 = -1;
				int num3 = 0;
				string value = null;
				int num4 = 0;
				int num5 = 0;
				foreach (ReflectionX.OpXInst item in enumerable)
				{
					switch (item.id.id.op)
					{
					case ReflectionX.OpX.PushValue:
						num2 = item.arg.@int;
						break;
					case ReflectionX.OpX.SetField:
						if (num2 != -1 && num3 != 0 && iteratorType.Module.ResolveField(item.arg) == pcField)
						{
							if ((num4 & num3) != 0)
							{
								UnityEngine.Debug.LogErrorFormat("Goto {0}.{1}[{2}] (1 << {3}) has been used more than once! Only one 'yield return {2};' / 'yield return 1 >> {3};' can work (see HagletTest.States).", iteratorType.DeclaringType.PrettyName(), iteratorType.GetIteratorMethod().Name, value ?? "unnamed", Haglet.GetStateIDBitIndex(num2));
							}
							else
							{
								num4 |= num3;
								array[num5++] = new GotoInfo(num3, (short)num2, value);
								num3 = 0;
								value = null;
							}
						}
						break;
					case ReflectionX.OpX.Call:
					{
						MethodInfo methodInfo4 = iteratorType.Module.ResolveMethod(item.arg) as MethodInfo;
						if (methodInfo4 == null)
						{
							break;
						}
						if (methodInfo4 == methodInfo2)
						{
							num3 = num2;
							dictionary.TryGetValue(num2, out value);
						}
						else if (methodInfo4.IsGenericMethod && methodInfo4.GetGenericMethodDefinition() == methodInfo3)
						{
							Type type = methodInfo4.GetGenericArguments()[0];
							if (type.IsEnum)
							{
								if (type.DeclaringType == iteratorType.DeclaringType && Enum.IsDefined(type, num2))
								{
									num3 = num2;
									value = Enum.GetName(type, num3);
								}
							}
							else if (type == typeof(int))
							{
								num3 = num2;
								dictionary.TryGetValue(num2, out value);
							}
						}
						if (num3 != 0 && !Haglet.IsValidGotoID(num3))
						{
							UnityEngine.Debug.LogErrorFormat("A goto in {0}.{1} (\"{2}\") has an invalid identifier! A unique '1 << #' integer value is required. Declare goto identifiers as constants alongside the method to allow naming (see HagletTest.States).", iteratorType.DeclaringType.PrettyName(), iteratorType.GetIteratorMethod().Name, value ?? "unnamed");
							num3 = 0;
						}
						break;
					}
					}
				}
				return array;
			}

			public override bool Equals(object obj)
			{
				if (obj is IteratorMethodInfo iteratorMethodInfo && iteratorType == iteratorMethodInfo.iteratorType && methodName == iteratorMethodInfo.methodName && argCount == iteratorMethodInfo.argCount && arg0Type == iteratorMethodInfo.arg0Type && arg1Type == iteratorMethodInfo.arg1Type && arg2Type == iteratorMethodInfo.arg2Type && arg3Type == iteratorMethodInfo.arg3Type && returnType == iteratorMethodInfo.returnType && fields.Equals(iteratorMethodInfo.fields) && arg0Default == iteratorMethodInfo.arg0Default && arg1Default == iteratorMethodInfo.arg1Default && arg2Default == iteratorMethodInfo.arg2Default && arg3Default == iteratorMethodInfo.arg3Default && defaultName == iteratorMethodInfo.defaultName && defaultEditorGroup == iteratorMethodInfo.defaultEditorGroup && initWaitCap == iteratorMethodInfo.initWaitCap && logInitCap == iteratorMethodInfo.logInitCap && logMaxLength == iteratorMethodInfo.logMaxLength && ArrayX.ContentsEqual(gotos, iteratorMethodInfo.gotos))
				{
					return true;
				}
				return false;
			}

			public override int GetHashCode()
			{
				int num = -664979872;
				num = num * -1521134295 + iteratorType.FullName.GetHashCode();
				num = num * -1521134295 + methodName.GetHashCode();
				num = num * -1521134295 + argCount;
				if (arg0Type != null)
				{
					num = num * -1521134295 + arg0Type.FullName.GetHashCode();
				}
				if (arg1Type != null)
				{
					num = num * -1521134295 + arg1Type.FullName.GetHashCode();
				}
				if (arg2Type != null)
				{
					num = num * -1521134295 + arg2Type.FullName.GetHashCode();
				}
				if (arg3Type != null)
				{
					num = num * -1521134295 + arg3Type.FullName.GetHashCode();
				}
				if (returnType != null)
				{
					num = num * -1521134295 + returnType.FullName.GetHashCode();
				}
				num = num * -1521134295 + fields.GetHashCode();
				if (arg0Default != null)
				{
					num = num * -1521134295 + arg0Default.GetHashCode();
				}
				if (arg1Default != null)
				{
					num = num * -1521134295 + arg1Default.GetHashCode();
				}
				if (arg2Default != null)
				{
					num = num * -1521134295 + arg2Default.GetHashCode();
				}
				if (arg3Default != null)
				{
					num = num * -1521134295 + arg3Default.GetHashCode();
				}
				if (defaultName != null)
				{
					num = num * -1521134295 + defaultName.GetHashCode();
				}
				if (defaultEditorGroup != null)
				{
					num = num * -1521134295 + defaultEditorGroup.GetHashCode();
				}
				num = num * -1521134295 + initWaitCap;
				num = num * -1521134295 + logInitCap;
				num = num * -1521134295 + logMaxLength;
				if (gotos != null)
				{
					for (int i = 0; i < 32; i++)
					{
						if (gotos[i].id != 0)
						{
							num = num * -1521134295 + gotos[i].id;
							num = num * -1521134295 + gotos[i].pc;
							if (gotos[i].name != null)
							{
								num = num * -1521134295 + gotos[i].name.GetHashCode();
							}
						}
					}
				}
				return num;
			}

			public void GetDigest(StringBuilder builder, ref int warningCount, ref Warning warningTypes)
			{
				string arg = iteratorType.DeclaringType.FullName.Replace('+', '.');
				builder.AppendFormat("[Routine.DefaultName(\"{0}\")]", defaultName);
				builder.AppendFormat("\n[Routine.DefaultEditorGroup(\"{0}\")]", defaultEditorGroup ?? "null");
				builder.AppendFormat("\n[Routine.InitialWaitCapacity({0})]", initWaitCap);
				if (logInitCap >= 0)
				{
					builder.AppendFormat("\n[Routine.EnableLogging({0}, {1})]", logInitCap, logMaxLength);
				}
				if (gotos != null)
				{
					builder.Append("\n[Routine.UsesGoto]");
				}
				builder.AppendFormat("\n{0}.{1}(", arg, methodName);
				bool flag = false;
				if (!method.IsStatic)
				{
					builder.AppendFormat("{0} this", method.DeclaringType.Name);
					flag = true;
				}
				if (arg0Type != null)
				{
					if (flag)
					{
						builder.Append(", ");
					}
					else
					{
						flag = true;
					}
					builder.AppendFormat("{0} {1}", arg0Type.Name, (fields.arg0 != null) ? fields.arg0.Name : "[unused]");
					if (arg0Default != null)
					{
						builder.AppendFormat(" = {0}", arg0Default);
					}
				}
				if (arg1Type != null)
				{
					builder.AppendFormat(", {0} {1}", arg1Type.Name, (fields.arg1 != null) ? fields.arg1.Name : "[unused]");
					if (arg1Default != null)
					{
						builder.AppendFormat(" = {0}", arg1Default);
					}
				}
				if (arg2Type != null)
				{
					builder.AppendFormat(", {0} {1}", arg2Type.Name, (fields.arg2 != null) ? fields.arg2.Name : "[unused]");
					if (arg2Default != null)
					{
						builder.AppendFormat(" = {0}", arg2Default);
					}
				}
				if (arg3Type != null)
				{
					builder.AppendFormat(", {0} {1}", arg3Type.Name, (fields.arg3 != null) ? fields.arg3.Name : "[unused]");
					if (arg3Default != null)
					{
						builder.AppendFormat(" = {0}", arg3Default);
					}
				}
				if (returnType != null)
				{
					if (flag)
					{
						builder.Append(", ");
					}
					builder.AppendFormat("Routine.Return<{0}> {1}", returnType.Name, (fields.@return != null) ? fields.@return.Name : "[unused]");
				}
				builder.Append(')');
				if (!method.IsStatic && typeof(MonoBehaviour).IsAssignableFrom(method.DeclaringType) && this == null)
				{
					warningCount++;
					warningTypes |= Warning.MissingThisField;
					builder.AppendFormat(" (WARNING: {0})", Warning.MissingThisField);
				}
				builder.Append('\n');
				if (fields.locals != null)
				{
					builder.Append("\tlocals:\n");
					int i = 0;
					for (int num = fields.locals.Length; i < num; i++)
					{
						builder.AppendFormat("\t\t{0} {1}", fields.locals[i].field.FieldType.Name, fields.locals[i].field.GetLocalVarName() ?? fields.locals[i].field.Name);
						if (fields.locals[i].gateway != null)
						{
							warningCount++;
							warningTypes |= Warning.UnresettableLocal;
							builder.AppendFormat(" (WARNING: {0})", Warning.UnresettableLocal);
						}
						builder.Append('\n');
					}
				}
				else
				{
					builder.Append("\tlocals: 0\n");
				}
				if (gotos == null)
				{
					return;
				}
				builder.Append("\tgotos:\n");
				GotoInfo[] array = gotos;
				for (int j = 0; j < array.Length; j++)
				{
					GotoInfo gotoInfo = array[j];
					if (gotoInfo.id != 0)
					{
						builder.AppendFormat("\t\t{0}: {1}\n", gotoInfo.name ?? ("1 << " + Haglet.GetStateIDBitIndex(gotoInfo.id)), gotoInfo.pc);
					}
				}
			}

			public override string ToString()
			{
				return $"IteratorMethodInfo for {iteratorType}";
			}
		}

		public class ReflectionLocalsRecorder : ILocalsRecorder
		{
			public LocalInfo[] locals;

			public object[] values;

			public ReflectionLocalsRecorder(LocalInfo[] locals)
			{
				this.locals = locals;
				values = new object[this.locals.Length];
			}

			public void RecordFrom(IEnumerator<Routine.Yield> iterator)
			{
				int i = 0;
				for (int num = locals.Length; i < num; i++)
				{
					object obj = ((locals[i].gateway != null) ? locals[i].gateway.GetValue(iterator) : iterator);
					if (obj != null)
					{
						values[i] = locals[i].field.GetValue(obj);
					}
				}
			}

			public void ApplyTo(IEnumerator<Routine.Yield> iterator)
			{
				int i = 0;
				for (int num = locals.Length; i < num; i++)
				{
					object obj = ((locals[i].gateway != null) ? locals[i].gateway.GetValue(iterator) : iterator);
					if (obj != null)
					{
						locals[i].field.SetValue(obj, values[i]);
					}
				}
			}
		}

		private abstract class ReflectionServer : IServer
		{
			public IteratorMethodInfo info;

			public bool usesGoto => info.gotos != null;

			public string defaultName => info.defaultName;

			public string defaultEditorGroup => info.defaultEditorGroup;

			public int argCount => info.argCount;

			public int initialWaitCapacity => info.initWaitCap;

			public int logInitialCapacity => info.logInitCap;

			public int logMaximumLength => info.logMaxLength;

			public bool Serves(IEnumerator<Routine.Yield> iterator)
			{
				return iterator.GetType() == info.iteratorType;
			}

			public object GetThis(IEnumerator<Routine.Yield> iterator)
			{
				if (info.fields.@this == null)
				{
					return null;
				}
				return info.fields.@this.GetValue(iterator);
			}

			public short GetPC(IEnumerator<Routine.Yield> iterator)
			{
				return (short)(int)info.fields.pc.GetValue(iterator);
			}

			public void SetPC(IEnumerator<Routine.Yield> iterator, short pc)
			{
				info.fields.pc.SetValue(iterator, (int)pc);
			}

			public void SetPCBoxed(IEnumerator<Routine.Yield> iterator, object pc)
			{
				info.fields.pc.SetValue(iterator, pc);
			}

			public void SetPCToGoto(IEnumerator<Routine.Yield> iterator, int gotoID)
			{
				SetPC(iterator, GetGotoPCFromID(gotoID));
			}

			public void ResetLocals(IEnumerator<Routine.Yield> iterator)
			{
				if (info.fields.locals == null)
				{
					return;
				}
				int i = 0;
				for (int num = info.fields.locals.Length; i < num; i++)
				{
					object obj = ((info.fields.locals[i].gateway != null) ? info.fields.locals[i].gateway.GetValue(iterator) : iterator);
					if (obj != null)
					{
						info.fields.locals[i].field.SetValue(obj, null);
					}
				}
			}

			public ILocalsRecorder GetLocalsRecorder()
			{
				if (info.fields.locals == null)
				{
					return null;
				}
				return new ReflectionLocalsRecorder(info.fields.locals);
			}

			public short GetGotoPCFromID(int id)
			{
				if (info.gotos != null)
				{
					int i = 0;
					for (int num = info.gotos.Length; i < num; i++)
					{
						if (info.gotos[i].id == id)
						{
							return info.gotos[i].pc;
						}
					}
				}
				return -1;
			}

			public string GetGotoNameFromID(int id)
			{
				if (info.gotos != null)
				{
					int i = 0;
					for (int num = info.gotos.Length; i < num; i++)
					{
						if (info.gotos[i].id == id)
						{
							return info.gotos[i].name;
						}
					}
				}
				return null;
			}

			public int GetGotoIDFromName(string name)
			{
				if (info.gotos != null)
				{
					int i = 0;
					for (int num = info.gotos.Length; i < num; i++)
					{
						if (info.gotos[i].name == name)
						{
							return info.gotos[i].id;
						}
					}
				}
				return 0;
			}

			public abstract void CacheArgDefaults();
		}

		private class ReflectionServer<AT0, AT1, AT2, AT3, RT> : ReflectionServer, IServer<AT0, AT1, AT2, AT3, RT>, IServer
		{
			public AT0 arg0Default { get; set; }

			public AT1 arg1Default { get; set; }

			public AT2 arg2Default { get; set; }

			public AT3 arg3Default { get; set; }

			public AT0 GetArg0(IEnumerator<Routine.Yield> iterator)
			{
				if (info.fields.arg0 == null)
				{
					return default(AT0);
				}
				return (AT0)info.fields.arg0.GetValue(iterator);
			}

			public void SetArg0(IEnumerator<Routine.Yield> iterator, AT0 a0)
			{
				if (!(info.fields.arg0 == null))
				{
					info.fields.arg0.SetValue(iterator, a0);
				}
			}

			public AT1 GetArg1(IEnumerator<Routine.Yield> iterator)
			{
				if (info.fields.arg1 == null)
				{
					return default(AT1);
				}
				return (AT1)info.fields.arg1.GetValue(iterator);
			}

			public void SetArg1(IEnumerator<Routine.Yield> iterator, AT1 a1)
			{
				if (!(info.fields.arg1 == null))
				{
					info.fields.arg1.SetValue(iterator, a1);
				}
			}

			public AT2 GetArg2(IEnumerator<Routine.Yield> iterator)
			{
				if (info.fields.arg2 == null)
				{
					return default(AT2);
				}
				return (AT2)info.fields.arg2.GetValue(iterator);
			}

			public void SetArg2(IEnumerator<Routine.Yield> iterator, AT2 a2)
			{
				if (!(info.fields.arg2 == null))
				{
					info.fields.arg2.SetValue(iterator, a2);
				}
			}

			public AT3 GetArg3(IEnumerator<Routine.Yield> iterator)
			{
				if (info.fields.arg3 == null)
				{
					return default(AT3);
				}
				return (AT3)info.fields.arg3.GetValue(iterator);
			}

			public void SetArg3(IEnumerator<Routine.Yield> iterator, AT3 a3)
			{
				if (!(info.fields.arg3 == null))
				{
					info.fields.arg3.SetValue(iterator, a3);
				}
			}

			public override void CacheArgDefaults()
			{
				arg0Default = ((info.arg0Default != null) ? ((AT0)info.arg0Default) : default(AT0));
				arg1Default = ((info.arg1Default != null) ? ((AT1)info.arg1Default) : default(AT1));
				arg2Default = ((info.arg2Default != null) ? ((AT2)info.arg2Default) : default(AT2));
				arg3Default = ((info.arg3Default != null) ? ((AT3)info.arg3Default) : default(AT3));
			}

			public RT GetReturnValue(IEnumerator<Routine.Yield> iterator)
			{
				if (info.fields.@return == null)
				{
					return default(RT);
				}
				return ((Routine.Return<RT>)info.fields.@return.GetValue(iterator)).value;
			}

			public void ClearReturnValue(IEnumerator<Routine.Yield> iterator)
			{
				if (!(info.fields.@return == null))
				{
					info.fields.@return.SetValue(iterator, null);
				}
			}

			public override string ToString()
			{
				return $"ReflectionServer for {info.iteratorType}";
			}
		}

		private class ServerTemplate<AT0, AT1, AT2, AT3, RT> : IServer<AT0, AT1, AT2, AT3, RT>, IServer
		{
			public class IteratorTemplate : IEnumerator<Routine.Yield>, IEnumerator, IDisposable
			{
				public int pc;

				public object @this;

				public AT0 arg0;

				public AT1 arg1;

				public AT2 arg2;

				public AT3 arg3;

				public Routine.Return<RT> ret;

				public Routine.Yield Current
				{
					get
					{
						throw new NotImplementedException();
					}
				}

				object IEnumerator.Current
				{
					get
					{
						throw new NotImplementedException();
					}
				}

				public void Dispose()
				{
					throw new NotImplementedException();
				}

				public bool MoveNext()
				{
					throw new NotImplementedException();
				}

				public void Reset()
				{
					throw new NotImplementedException();
				}
			}

			public IteratorFieldsInfo fields;

			public string defaultName
			{
				get
				{
					throw new NotImplementedException();
				}
			}

			public string defaultEditorGroup
			{
				get
				{
					throw new NotImplementedException();
				}
			}

			public int argCount
			{
				get
				{
					throw new NotImplementedException();
				}
			}

			public int initialWaitCapacity
			{
				get
				{
					throw new NotImplementedException();
				}
			}

			public bool usesGoto
			{
				get
				{
					throw new NotImplementedException();
				}
			}

			public int logInitialCapacity
			{
				get
				{
					throw new NotImplementedException();
				}
			}

			public int logMaximumLength
			{
				get
				{
					throw new NotImplementedException();
				}
			}

			public AT0 arg0Default => default(AT0);

			public AT1 arg1Default => default(AT1);

			public AT2 arg2Default => default(AT2);

			public AT3 arg3Default => default(AT3);

			public ServerTemplate()
			{
				fields = new IteratorFieldsInfo(typeof(IteratorTemplate), "", "", "", "", "", "", "", new string[1] { "" }, new string[1] { "" });
			}

			public bool Serves(IEnumerator<Routine.Yield> iterator)
			{
				return iterator is IteratorTemplate;
			}

			public object GetThis(IEnumerator<Routine.Yield> iterator)
			{
				return ((IteratorTemplate)iterator).@this;
			}

			public short GetPC(IEnumerator<Routine.Yield> iterator)
			{
				return (short)(int)fields.pc.GetValue(iterator);
			}

			public void SetPC(IEnumerator<Routine.Yield> iterator, short pc)
			{
				fields.pc.SetValue(iterator, (int)pc);
			}

			public void SetPCBoxed(IEnumerator<Routine.Yield> iterator, object pc)
			{
				fields.pc.SetValue(iterator, pc);
			}

			public void SetPCToGoto(IEnumerator<Routine.Yield> iterator, int gotoID)
			{
				SetPC(iterator, GetGotoPCFromID(gotoID));
			}

			public void ResetLocals(IEnumerator<Routine.Yield> iterator)
			{
				if (fields.locals == null)
				{
					return;
				}
				int i = 0;
				for (int num = fields.locals.Length; i < num; i++)
				{
					object obj = ((fields.locals[i].gateway != null) ? fields.locals[i].gateway.GetValue(iterator) : iterator);
					if (obj != null)
					{
						fields.locals[i].field.SetValue(obj, null);
					}
				}
			}

			public ILocalsRecorder GetLocalsRecorder()
			{
				if (fields.locals == null)
				{
					return null;
				}
				return new ReflectionLocalsRecorder(fields.locals);
			}

			public short GetGotoPCFromID(int id)
			{
				throw new NotImplementedException();
			}

			public string GetGotoNameFromID(int id)
			{
				throw new NotImplementedException();
			}

			public int GetGotoIDFromName(string name)
			{
				throw new NotImplementedException();
			}

			public AT0 GetArg0(IEnumerator<Routine.Yield> iterator)
			{
				return ((IteratorTemplate)iterator).arg0;
			}

			public void SetArg0(IEnumerator<Routine.Yield> iterator, AT0 arg0)
			{
				((IteratorTemplate)iterator).arg0 = arg0;
			}

			public AT1 GetArg1(IEnumerator<Routine.Yield> iterator)
			{
				return ((IteratorTemplate)iterator).arg1;
			}

			public void SetArg1(IEnumerator<Routine.Yield> iterator, AT1 arg1)
			{
				((IteratorTemplate)iterator).arg1 = arg1;
			}

			public AT2 GetArg2(IEnumerator<Routine.Yield> iterator)
			{
				return ((IteratorTemplate)iterator).arg2;
			}

			public void SetArg2(IEnumerator<Routine.Yield> iterator, AT2 arg2)
			{
				((IteratorTemplate)iterator).arg2 = arg2;
			}

			public AT3 GetArg3(IEnumerator<Routine.Yield> iterator)
			{
				return ((IteratorTemplate)iterator).arg3;
			}

			public void SetArg3(IEnumerator<Routine.Yield> iterator, AT3 arg3)
			{
				((IteratorTemplate)iterator).arg3 = arg3;
			}

			public RT GetReturnValue(IEnumerator<Routine.Yield> iterator)
			{
				return ((IteratorTemplate)iterator).ret.value;
			}

			public void ClearReturnValue(IEnumerator<Routine.Yield> iterator)
			{
				((IteratorTemplate)iterator).ret = default(RT);
			}
		}

		public const string assemblyFormat = "Haglet-{0}-02";

		public const string assetPathRegular = "Plugins/Coatsink";

		public const string assetPathEditor = "Plugins/Coatsink/Editor";

		public const string assemblyExtension = ".dll";

		private const int serverListPadding = 30;

		private static Dictionary<Type, IServer> servers;

		private const string resetMenuPath = "Haglet/Reset Dynamic Support";

		private const string clearMenuPath = "Haglet/Clear Dynamic Support";

		private const string useReflectionMenuPath = "Haglet/Use Reflection Instead Of Code Generation";

		private const string useReflectionPrefsKey = "Haglet, Use Reflection Instead Of Code Generation";

		private const string deepLoggingMenuPath = "Haglet/Deep-Log Dynamic Support";

		private const string deepLoggingPrefsKey = "Haglet, Deep-Log Dynamic Support";

		private static Dictionary<Type, IteratorMethodInfo> cache;

		private const BindingFlags instDecl = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;

		public static bool assembliesInUse { get; private set; }

		public static void Retain(bool forceLog = false)
		{
			if (servers != null)
			{
				return;
			}
			StringBuilder log = null;
			int warningCount = 0;
			IteratorMethodInfo.Warning warningTypes = (IteratorMethodInfo.Warning)0;
			servers = null;
			Type[] types = Assembly.Load("Assembly-CSharp").GetTypes();
			Type[] array = new Type[0];
			int num = 0;
			Type[] array2 = types;
			for (int i = 0; i < array2.Length; i++)
			{
				if (array2[i].IsIterator<Routine.Yield>())
				{
					num++;
				}
			}
			array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				if (array2[i].IsIterator<Routine.Yield>())
				{
					num++;
				}
			}
			servers = new Dictionary<Type, IServer>(num + 30);
			array2 = types;
			foreach (Type type in array2)
			{
				if (type.IsIterator<Routine.Yield>())
				{
					try
					{
						CreateAndCacheServer(type, ref warningCount, ref warningTypes, log);
					}
					catch (Exception)
					{
					}
				}
			}
			array2 = array;
			foreach (Type type2 in array2)
			{
				if (type2.IsIterator<Routine.Yield>())
				{
					try
					{
						CreateAndCacheServer(type2, ref warningCount, ref warningTypes, log);
					}
					catch (Exception)
					{
					}
				}
			}
		}

		public static void Release()
		{
			UnityEngine.Debug.Log("Haglet dynamic support is cleared and will be rebuilt when next needed.");
			servers = null;
		}

		public static string GetAssemblyPath(string src, bool editor = false)
		{
			return string.Format("{0}/{1}/{2}{3}", UnityEngine.Application.dataPath, editor ? "Plugins/Coatsink/Editor" : "Plugins/Coatsink", GetAssemblyName(src), ".dll");
		}

		public static string GetAssemblyName(string src)
		{
			return $"Haglet-{src}-02";
		}

		public static IServer GetServer(IEnumerator<Routine.Yield> iterator)
		{
			Retain();
			if (iterator == null)
			{
				return null;
			}
			if (servers.TryGetValue(iterator.GetType(), out var value))
			{
				return value;
			}
			int warningCount = 0;
			IteratorMethodInfo.Warning warningTypes = (IteratorMethodInfo.Warning)0;
			return CreateAndCacheServer(iterator.GetType(), ref warningCount, ref warningTypes);
		}

		private static IServer CreateAndCacheServer(Type iteratorType, ref int warningCount, ref IteratorMethodInfo.Warning warningTypes, StringBuilder log = null)
		{
			IServer server = null;
			IteratorMethodInfo iteratorMethodInfo = new IteratorMethodInfo(iteratorType);
			if (log != null)
			{
				iteratorMethodInfo.GetDigest(log, ref warningCount, ref warningTypes);
			}
			try
			{
				server = CreateCodeGenServer(iteratorMethodInfo, log);
			}
			catch (Exception)
			{
				goto IL_0028;
			}
			goto IL_003d;
			IL_003d:
			servers.Add(iteratorType, server);
			return server;
			IL_0028:
			try
			{
				server = CreateReflectionServer(iteratorMethodInfo);
			}
			catch (Exception exc)
			{
				Panic.Haglet.ThrowSupportFailure(iteratorMethodInfo, exc);
			}
			goto IL_003d;
		}

		private static IServer CreateCodeGenServer(IteratorMethodInfo method, StringBuilder log = null)
		{
			string text = $"Haglet-{method.iteratorType.Assembly.GetName().Name}-02";
			return (IServer)Activator.CreateInstance(CreateServerType(AppDomain.CurrentDomain.DefineDynamicAssembly(new AssemblyName(text), AssemblyBuilderAccess.Run).DefineDynamicModule(text), method, log));
		}

		private static IServer CreateReflectionServer(IteratorMethodInfo info)
		{
			ReflectionServer obj = (ReflectionServer)Activator.CreateInstance(typeof(ReflectionServer<, , , , >).MakeGenericType(info.arg0Type ?? typeof(int), info.arg1Type ?? typeof(int), info.arg2Type ?? typeof(int), info.arg3Type ?? typeof(int), info.returnType ?? typeof(int)));
			obj.info = info;
			obj.CacheArgDefaults();
			return obj;
		}

		public static Type CreateServerType(ModuleBuilder modBuilder, IteratorMethodInfo info, StringBuilder log = null)
		{
			ConstructorBuilder constructorBuilder = null;
			LocalInfo[] locals = info.fields.locals;
			Type[] array = new Type[5]
			{
				info.arg0Type ?? typeof(int),
				info.arg1Type ?? typeof(int),
				info.arg2Type ?? typeof(int),
				info.arg3Type ?? typeof(int),
				info.returnType ?? typeof(int)
			};
			Type type = typeof(ServerTemplate<, , , , >).MakeGenericType(array);
			Type type2 = typeof(ServerTemplate<, , , , >).GetNestedType("IteratorTemplate").MakeGenericType(array);
			FieldInfo field = type2.GetField("pc", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			FieldInfo field2 = type2.GetField("this", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			FieldInfo field3 = type2.GetField("arg0", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			FieldInfo field4 = type2.GetField("arg1", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			FieldInfo field5 = type2.GetField("arg2", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			FieldInfo field6 = type2.GetField("arg3", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			FieldInfo field7 = type2.GetField("ret", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			MethodInfo method = type.GetMethod("SetPC", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			MethodInfo method2 = type.GetMethod("GetGotoPCFromID", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			FieldInfo field8 = type.GetField("fields", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			IEnumerator<ReflectionX.MemberXInst> enumerator = type.Parse().GetEnumerator();
			string name = info.iteratorType.FullName + "_Server";
			TypeBuilder typeBuilder = modBuilder.DefineType(name, TypeAttributes.Public);
			typeBuilder.AddInterfaces(enumerator);
			typeBuilder.DefineFields(enumerator);
			typeBuilder.DefineProperties(enumerator);
			FieldInfo field9 = typeBuilder.GetField("fields", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			enumerator.MoveNext();
			int count = enumerator.Current.details.count;
			MethodInfo[] array2 = new MethodInfo[count];
			MethodBuilder[] array3 = new MethodBuilder[count];
			MethodInfo newMethod = null;
			MethodInfo newMethod2 = null;
			for (int i = 0; i < count; i++)
			{
				array3[i] = typeBuilder.DefineMethod<MethodInfo>(enumerator, out array2[i]);
				string name2 = array3[i].Name;
				if (!(name2 == "SetPC"))
				{
					if (name2 == "GetGotoPCFromID")
					{
						newMethod2 = array3[i];
					}
				}
				else
				{
					newMethod = array3[i];
				}
			}
			log?.AppendFormat("Begun translating template for {0}.{1}...\n", info.iteratorType.DeclaringType.Name, info.iteratorType.Name);
			for (int j = 0; j < count; j++)
			{
				ILGenerator iLGenerator = array3[j].GetILGenerator();
				log?.AppendFormat("Translating method {0}...\n", array3[j].Name);
				switch (array3[j].Name)
				{
				case "get_defaultName":
					iLGenerator.EmitReturnValue(info.defaultName);
					continue;
				case "get_defaultEditorGroup":
					iLGenerator.EmitReturnValue(info.defaultEditorGroup);
					continue;
				case "get_argCount":
					iLGenerator.EmitReturnValue(info.argCount);
					continue;
				case "get_initialWaitCapacity":
					iLGenerator.EmitReturnValue(info.initWaitCap);
					continue;
				case "get_usesGoto":
					iLGenerator.EmitReturnValue(info.gotos != null);
					continue;
				case "get_logInitialCapacity":
					iLGenerator.EmitReturnValue(info.logInitCap);
					continue;
				case "get_logMaximumLength":
					iLGenerator.EmitReturnValue(info.logMaxLength);
					continue;
				case "GetGotoPCFromID":
					if (info.gotos != null)
					{
						array3[j].EmitGetGotoPCFromID(info.gotos);
					}
					else
					{
						iLGenerator.EmitReturnValue(-1);
					}
					continue;
				case "GetGotoNameFromID":
					if (info.gotos != null)
					{
						array3[j].EmitGetGotoNameFromID(info.gotos);
					}
					else
					{
						iLGenerator.EmitReturnValue(null);
					}
					continue;
				case "GetGotoIDFromName":
					if (info.gotos != null)
					{
						array3[j].EmitGetGotoIDFromName(info.gotos);
					}
					else
					{
						iLGenerator.EmitReturnValue(0);
					}
					continue;
				case "GetThis":
					if (!(info.fields.@this == null))
					{
						break;
					}
					goto IL_0943;
				case "GetArg0":
				case "SetArg0":
					if (!(info.fields.arg0 == null))
					{
						break;
					}
					goto IL_0943;
				case "GetArg1":
				case "SetArg1":
					if (!(info.fields.arg1 == null))
					{
						break;
					}
					goto IL_0943;
				case "GetArg2":
				case "SetArg2":
					if (!(info.fields.arg2 == null))
					{
						break;
					}
					goto IL_0943;
				case "GetArg3":
				case "SetArg3":
					if (!(info.fields.arg3 == null))
					{
						break;
					}
					goto IL_0943;
				case "get_arg0Default":
					if (info.arg0Default != null)
					{
						iLGenerator.EmitStubMethod(info.arg0Default);
						continue;
					}
					goto IL_0943;
				case "get_arg1Default":
					if (info.arg1Default != null)
					{
						iLGenerator.EmitStubMethod(info.arg1Default);
						continue;
					}
					goto IL_0943;
				case "get_arg2Default":
					if (info.arg2Default != null)
					{
						iLGenerator.EmitStubMethod(info.arg2Default);
						continue;
					}
					goto IL_0943;
				case "get_arg3Default":
					if (info.arg3Default != null)
					{
						iLGenerator.EmitStubMethod(info.arg3Default);
						continue;
					}
					goto IL_0943;
				case "GetReturnValue":
				case "ClearReturnValue":
					if (!(info.fields.@return == null))
					{
						break;
					}
					goto IL_0943;
				case "ResetLocals":
				case "GetLocalsRecorder":
					{
						log?.Append("Emitting exact copy...\n");
						IEnumerable<ReflectionX.OpXInst> il = array2[j].ParseIL(array, array2[j].GetGenericArguments()).Substitute(field8, field9).Substitute(type2, info.iteratorType);
						iLGenerator.EmitIL(il, type.Module);
						continue;
					}
					IL_0943:
					log?.Append("Emitting stub\n");
					iLGenerator.EmitStubMethod(null, array3[j].ReturnType);
					continue;
				}
				log?.Append("Emitting default...\n");
				IEnumerable<ReflectionX.OpXInst> il2 = array2[j].ParseIL(array, array2[j].GetGenericArguments()).Substitute(field, info.fields.pc, log).Substitute(field2, info.fields.@this, log)
					.Substitute(field3, info.fields.arg0, log)
					.Substitute(field4, info.fields.arg1, log)
					.Substitute(field5, info.fields.arg2, log)
					.Substitute(field6, info.fields.arg3, log)
					.Substitute(field7, info.fields.@return, log)
					.Substitute(method, newMethod, log)
					.Substitute(method2, newMethod2, log)
					.Substitute(type, typeBuilder, includeMembers: true, log)
					.Substitute(type2, info.iteratorType, includeMembers: true, log);
				iLGenerator.EmitIL(il2, type.Module);
			}
			ConstructorInfo constructor = type.GetConstructor(Type.EmptyTypes);
			ILGenerator iLGenerator2 = typeBuilder.DefineConstructor(constructor.Attributes, constructor.CallingConvention, Type.EmptyTypes).GetILGenerator();
			iLGenerator2.Emit(OpCodes.Ldarg_0);
			iLGenerator2.Emit(OpCodes.Call, typeof(object).GetConstructor(Type.EmptyTypes));
			iLGenerator2.Emit(OpCodes.Ldarg_0);
			iLGenerator2.Emit(OpCodes.Ldtoken, info.iteratorType);
			iLGenerator2.Emit(OpCodes.Call, typeof(Type).GetMethod("GetTypeFromHandle", new Type[1] { typeof(RuntimeTypeHandle) }));
			if (info.fields.arg0 != null)
			{
				iLGenerator2.Emit(OpCodes.Ldstr, info.fields.arg0.Name);
			}
			else
			{
				iLGenerator2.Emit(OpCodes.Ldnull);
			}
			if (info.fields.arg1 != null)
			{
				iLGenerator2.Emit(OpCodes.Ldstr, info.fields.arg1.Name);
			}
			else
			{
				iLGenerator2.Emit(OpCodes.Ldnull);
			}
			if (info.fields.arg2 != null)
			{
				iLGenerator2.Emit(OpCodes.Ldstr, info.fields.arg2.Name);
			}
			else
			{
				iLGenerator2.Emit(OpCodes.Ldnull);
			}
			if (info.fields.arg3 != null)
			{
				iLGenerator2.Emit(OpCodes.Ldstr, info.fields.arg3.Name);
			}
			else
			{
				iLGenerator2.Emit(OpCodes.Ldnull);
			}
			if (info.fields.@return != null)
			{
				iLGenerator2.Emit(OpCodes.Ldstr, info.fields.@return.Name);
			}
			else
			{
				iLGenerator2.Emit(OpCodes.Ldnull);
			}
			if (info.fields.@this != null)
			{
				iLGenerator2.Emit(OpCodes.Ldstr, info.fields.@this.Name);
			}
			else
			{
				iLGenerator2.Emit(OpCodes.Ldnull);
			}
			iLGenerator2.Emit(OpCodes.Ldstr, info.fields.pc.Name);
			if (info.fields.locals != null)
			{
				int num = info.fields.locals.Length;
				iLGenerator2.Emit(OpCodes.Ldc_I4, num);
				iLGenerator2.Emit(OpCodes.Newarr, typeof(string));
				for (int k = 0; k < num; k++)
				{
					iLGenerator2.Emit(OpCodes.Dup);
					iLGenerator2.Emit(OpCodes.Ldc_I4, k);
					iLGenerator2.Emit(OpCodes.Ldstr, info.fields.locals[k].field.Name);
					iLGenerator2.Emit(OpCodes.Stelem_Ref);
				}
				iLGenerator2.Emit(OpCodes.Ldc_I4, num);
				iLGenerator2.Emit(OpCodes.Newarr, typeof(string));
				for (int l = 0; l < num; l++)
				{
					iLGenerator2.Emit(OpCodes.Dup);
					iLGenerator2.Emit(OpCodes.Ldc_I4, l);
					if (info.fields.locals[l].gateway != null)
					{
						iLGenerator2.Emit(OpCodes.Ldstr, info.fields.locals[l].gateway.Name);
					}
					else
					{
						iLGenerator2.Emit(OpCodes.Ldnull);
					}
					iLGenerator2.Emit(OpCodes.Stelem_Ref);
				}
			}
			else
			{
				iLGenerator2.Emit(OpCodes.Ldnull);
				iLGenerator2.Emit(OpCodes.Ldnull);
			}
			ConstructorInfo constructor2 = typeof(IteratorFieldsInfo).GetConstructor(new Type[10]
			{
				typeof(Type),
				typeof(string),
				typeof(string),
				typeof(string),
				typeof(string),
				typeof(string),
				typeof(string),
				typeof(string),
				typeof(string[]),
				typeof(string[])
			});
			iLGenerator2.Emit(OpCodes.Newobj, constructor2);
			iLGenerator2.Emit(OpCodes.Stfld, typeBuilder.GetField("fields", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
			iLGenerator2.Emit(OpCodes.Ret);
			return typeBuilder.CreateType();
		}

		private static void EmitGetGotoPCFromID(this MethodBuilder builder, GotoInfo[] gotos)
		{
			ILGenerator iLGenerator = builder.GetILGenerator();
			int i = 0;
			for (int num = gotos.Length; i < num; i++)
			{
				if (gotos[i].id != 0)
				{
					Label label = iLGenerator.DefineLabel();
					Label label2 = iLGenerator.DefineLabel();
					iLGenerator.Emit(OpCodes.Ldarg_1);
					iLGenerator.Emit(OpCodes.Ldc_I4, gotos[i].id);
					iLGenerator.Emit(OpCodes.Beq, label);
					iLGenerator.Emit(OpCodes.Br, label2);
					iLGenerator.MarkLabel(label);
					iLGenerator.Emit(OpCodes.Ldc_I4, (int)gotos[i].pc);
					iLGenerator.Emit(OpCodes.Ret);
					iLGenerator.MarkLabel(label2);
				}
			}
			iLGenerator.Emit(OpCodes.Ldc_I4_M1);
			iLGenerator.Emit(OpCodes.Ret);
		}

		private static void EmitGetGotoNameFromID(this MethodBuilder builder, GotoInfo[] gotos)
		{
			ILGenerator iLGenerator = builder.GetILGenerator();
			int i = 0;
			for (int num = gotos.Length; i < num; i++)
			{
				if (gotos[i].id != 0 && gotos[i].name != null)
				{
					Label label = iLGenerator.DefineLabel();
					Label label2 = iLGenerator.DefineLabel();
					iLGenerator.Emit(OpCodes.Ldarg_1);
					iLGenerator.Emit(OpCodes.Ldc_I4, gotos[i].id);
					iLGenerator.Emit(OpCodes.Beq, label);
					iLGenerator.Emit(OpCodes.Br, label2);
					iLGenerator.MarkLabel(label);
					iLGenerator.Emit(OpCodes.Ldstr, gotos[i].name);
					iLGenerator.Emit(OpCodes.Ret);
					iLGenerator.MarkLabel(label2);
				}
			}
			iLGenerator.Emit(OpCodes.Ldnull);
			iLGenerator.Emit(OpCodes.Ret);
		}

		private static void EmitGetGotoIDFromName(this MethodBuilder builder, GotoInfo[] gotos)
		{
			ILGenerator iLGenerator = builder.GetILGenerator();
			int i = 0;
			for (int num = gotos.Length; i < num; i++)
			{
				if (gotos[i].id != 0 && gotos[i].name != null)
				{
					Label label = iLGenerator.DefineLabel();
					Label label2 = iLGenerator.DefineLabel();
					iLGenerator.Emit(OpCodes.Ldarg_1);
					iLGenerator.Emit(OpCodes.Ldstr, gotos[i].name);
					iLGenerator.Emit(OpCodes.Beq, label);
					iLGenerator.Emit(OpCodes.Br, label2);
					iLGenerator.MarkLabel(label);
					iLGenerator.Emit(OpCodes.Ldc_I4, gotos[i].id);
					iLGenerator.Emit(OpCodes.Ret);
					iLGenerator.MarkLabel(label2);
				}
			}
			iLGenerator.Emit(OpCodes.Ldc_I4_0);
			iLGenerator.Emit(OpCodes.Ret);
		}

		public static IteratorMethodInfo GetIteratorMethodInfo(this Type iteratorType)
		{
			IteratorMethodInfo value = null;
			if (cache == null)
			{
				cache = new Dictionary<Type, IteratorMethodInfo>(100);
			}
			else if (cache.TryGetValue(iteratorType, out value))
			{
				return value;
			}
			return cache[iteratorType] = new IteratorMethodInfo(iteratorType);
		}
	}
	public interface IHagletEvent
	{
		string name { get; }

		float deltaTime { get; }

		double accumulatedTime { get; }

		ulong happenCount { get; }

		HagletCondition happening { get; }

		event Action onPreHappen;

		event Action onPostHappen;

		void Push(HagletEvent.IResponder responder);

		void Pop(HagletEvent.IResponder responder);

		void EventStackTrace(TextWriter writer, int indent = 0, bool includeEvents = false);
	}
	public abstract class HagletEvent : IHagletEvent
	{
		public interface IResponder
		{
			string name { get; }

			void OnEvent();

			void OnEventCancel(HagletEvent @event);
		}

		public interface IOwner
		{
			void Own(IHagletEvent @event);
		}

		private struct Entry
		{
			public IResponder responder;

			public IResponder prevResponder;

			public int count;

			public override string ToString()
			{
				return string.Format("R: {0} - PR: {1} - C{2}", (responder != null) ? responder.name : "null", (prevResponder != null) ? prevResponder.name : "null", count);
			}
		}

		[ThreadStatic]
		private static HagletEvent _current;

		private Entry[] entries;

		private int responderCount;

		private HagletFlag _happening;

		private HagletFlag _skipping;

		public static HagletEvent current => _current;

		public static HagletEvent onDefaultUpdate => HagletBehaviourTime.onDefaultUpdate;

		public static HagletEvent onDefaultLateUpdate => HagletBehaviourTime.onDefaultLateUpdate;

		public static HagletEvent onDefaultFixedUpdate => HagletBehaviourTime.onDefaultFixedUpdate;

		public static HagletEvent onRealUpdate => HagletBehaviourTime.onRealUpdate;

		public static HagletEvent onRealLateUpdate => HagletBehaviourTime.onRealLateUpdate;

		public string name { get; private set; }

		public HagletCondition happening => _happening;

		public HagletCondition skipping => _skipping;

		public float deltaTime { get; private set; }

		public double accumulatedTime { get; private set; }

		public float accumulatedTimeF => (float)accumulatedTime;

		public ulong happenCount { get; private set; }

		public event Action onPreHappen;

		public event Action onPostHappen;

		public event Action onNextPreHappen;

		public event Action onNextPostHappen;

		protected HagletEvent(string name = null, IOwner owner = null, int initRespCap = 16)
		{
			this.name = name ?? "HagletEvent";
			entries = new Entry[initRespCap];
			_happening = new HagletFlag(setIn: false);
			_skipping = new HagletFlag(setIn: false);
			owner?.Own(this);
		}

		protected bool Happen(float deltaTime = 0f, bool skipping = false)
		{
			bool result = true;
			if (!_happening.set)
			{
				lock (this)
				{
					ulong num = happenCount + 1;
					happenCount = num;
					if (this.onNextPreHappen != null)
					{
						this.onNextPreHappen();
						this.onNextPreHappen = null;
					}
					if (this.onPreHappen != null)
					{
						this.onPreHappen();
					}
					bool flag;
					if (flag = responderCount > 0)
					{
						int i = 0;
						for (int num2 = entries.Length; i < num2; i++)
						{
							entries[i].prevResponder = entries[i].responder;
						}
						HagletEvent hagletEvent = this.PushTo(ref _current);
						_happening.set = true;
						_skipping.set = skipping;
						this.deltaTime = deltaTime;
						accumulatedTime += deltaTime;
						int j = 0;
						for (int num3 = entries.Length; j < num3; j++)
						{
							if (entries[j].prevResponder != null)
							{
								try
								{
									entries[j].prevResponder.OnEvent();
								}
								catch (Exception)
								{
								}
								entries[j].prevResponder = null;
							}
						}
						_happening.set = (_skipping.set = false);
						_current = hagletEvent;
					}
					if (this.onNextPostHappen != null)
					{
						this.onNextPostHappen();
						this.onNextPostHappen = null;
					}
					if (this.onPostHappen != null)
					{
						this.onPostHappen();
					}
					result = flag;
				}
			}
			return result;
		}

		public void Push(IResponder responder)
		{
			lock (this)
			{
				int num = 0;
				int num2 = entries.Length;
				while (true)
				{
					if (num < num2)
					{
						if (entries[num].responder == responder)
						{
							entries[num].count++;
							return;
						}
						if (entries[num].responder == null)
						{
							for (int i = num + 1; i < num2; i++)
							{
								if (entries[i].responder == responder)
								{
									entries[i].count++;
									return;
								}
							}
							break;
						}
						num++;
						continue;
					}
					Array.Resize(ref entries, Mathf.Max(10, Mathf.CeilToInt((float)num2 * 1.5f)));
					UnityEngine.Debug.LogWarningFormat("HagletEvent {0} automatically increased its responder capacity to {1}", name, entries.Length);
					break;
				}
				entries[num].responder = responder;
				entries[num].count = 1;
				responderCount++;
			}
		}

		public void Pop(IResponder responder)
		{
			lock (this)
			{
				if (responderCount == 0)
				{
					return;
				}
				int i = 0;
				for (int num = entries.Length; i < num; i++)
				{
					if (entries[i].responder == responder)
					{
						if (--entries[i].count == 0)
						{
							entries[i].responder = null;
							responderCount--;
						}
						break;
					}
				}
			}
		}

		public void Cancel()
		{
			lock (this)
			{
				if (responderCount == 0)
				{
					return;
				}
				int i = 0;
				for (int num = entries.Length; i < num; i++)
				{
					if (entries[i].responder != null)
					{
						entries[i].responder.OnEventCancel(this);
						entries[i].responder = null;
						entries[i].count = 0;
					}
				}
			}
		}

		public void EventStackTrace(TextWriter writer, int indent = 0, bool includeEvents = false)
		{
			if (includeEvents)
			{
				for (int i = 0; i < indent * 4; i++)
				{
					writer.Write(' ');
				}
				writer.Write(name);
				writer.Write('\n');
				indent++;
			}
		}

		public void SetMinimumResponderCapacity(int cap)
		{
			if (entries.Length < cap)
			{
				Array.Resize(ref entries, cap);
			}
		}

		public override string ToString()
		{
			return name;
		}

		public static implicit operator Wait(HagletEvent @event)
		{
			return Wait.Until.Happening(@event);
		}

		public static implicit operator Routine.Yield(HagletEvent @event)
		{
			return (Wait)@event;
		}

		public static Wait operator &(HagletEvent @event, Wait wait)
		{
			return (Wait)@event & wait;
		}

		public static Wait operator |(HagletEvent @event, Wait wait)
		{
			return (Wait)@event | wait;
		}

		public static Wait operator *(HagletEvent @event, int total)
		{
			return (Wait)@event * total;
		}

		public static Wait operator +(HagletEvent @event, Wait wait)
		{
			return (Wait)@event + wait;
		}

		public static Wait operator &(int states, HagletEvent @event)
		{
			return states & (Wait)@event;
		}
	}
	public interface IHaglet : IHagletCallable, IHagletTrigger
	{
		Haglet.ID id { get; }

		Haglet.ID[] callStackIDs { get; }

		int lineNumber { get; }

		string fileName { get; }

		IHaglet caller { get; }

		MonoBehaviour owner { get; }

		double deltaTime { get; }

		double accumulatedTime { get; }

		int directCalleeCount { get; }

		bool waitEnabled { get; set; }

		int? changingArg { get; }

		string GetNameStack();

		string GetGotoName();

		string GetGotoName(int id);

		Haglet.Inspection Inspect();

		IHaglet FindFirstCallee(Haglet.ID id, bool recursive);

		void CallStackTrace(List<Haglet.CallStackTraceEntry> trace, ref int count, ref int matchCount);

		void ClearLog();

		void Reset();

		void MarkResetPoint();

		void Trigger(int arg);

		void Trigger<T>(T arg) where T : struct, IConvertible;

		bool TryTrigger();

		bool TryTrigger(int arg);

		bool TryTrigger<T>(T arg) where T : struct, IConvertible;

		void Goto(int id);

		DynamicProperty<T> GetLocalVar<T>(string name, bool required = true);

		void Skip();

		bool IsValidClause(byte ci, byte rev);

		Haglet.Clause.Flags GetClauseFlags(byte ci);

		string GetClauseDescription(byte ci);

		bool IsValidGoto(int id);

		void Log(string log);

		void Log(string logFormat, object arg0);

		void Log(string logFormat, object arg0, object arg1);

		void Log(string logFormat, object arg0, object arg1, object arg2);

		void Log(string logFormat, params object[] args);
	}
	public interface IHagletCallable
	{
		string name { get; }

		string editorGroup { get; }

		int argCount { get; }

		Haglet.State state { get; }

		IHagletValue<Haglet.State> iState { get; }

		bool started { get; }

		bool stopped { get; }

		bool pausedInCallStack { get; }

		bool paused { get; }

		bool completed { get; }

		bool isCurrent { get; }

		bool executing { get; }

		bool moving { get; }

		bool skipping { get; }

		int triggerArg { get; }

		IHagletValue<int> iLatestGoto { get; }

		int latestGoto { get; }

		bool isBeingTriggered { get; }

		event Action<Haglet.State> onPostStateChange;

		event Action<int, int> onGoto;

		event Action<Exception, Haglet.Inspection> onException;

		Wait Call(int total = 1, bool reset = true, bool skip = false, bool requireComplete = true);

		Wait Start(bool resetIfStarted = false, bool skip = false, bool waitUntilCompleted = true);

		void Stop(bool complete = false);

		void Pause();

		void Resume();
	}
	public interface IHagletCallable<AT0> : IHagletCallable
	{
		Wait Start(AT0 arg0, bool resetIfStarted = false, bool skip = false, bool waitUntilCompleted = true);

		Wait Call(AT0 arg0, int total = 1, bool reset = true, bool skip = false, bool requireComplete = true);
	}
	public interface IHaglet<AT0> : IHaglet, IHagletCallable, IHagletTrigger, IHagletCallable<AT0>
	{
		AT0 arg0 { get; }

		void SetArg0(AT0 val, primitive? waitID = null);
	}
	public interface IHagletCallable<AT0, AT1> : IHaglet<AT0>, IHaglet, IHagletCallable, IHagletTrigger, IHagletCallable<AT0>
	{
		Wait Start(AT0 arg0, AT1 arg1, bool resetIfStarted = false, bool skip = false, bool waitUntilCompleted = true);

		Wait Call(AT0 arg0, AT1 arg1, int total = 1, bool reset = true, bool skip = false, bool requireComplete = true);
	}
	public interface IHaglet<AT0, AT1> : IHaglet<AT0>, IHaglet, IHagletCallable, IHagletTrigger, IHagletCallable<AT0>, IHagletCallable<AT0, AT1>
	{
		AT1 arg1 { get; }

		void SetArg1(AT1 val, primitive? waitID = null);
	}
	public interface IHagletCallable<AT0, AT1, AT2> : IHagletCallable<AT0, AT1>, IHaglet<AT0>, IHaglet, IHagletCallable, IHagletTrigger, IHagletCallable<AT0>
	{
		Wait Start(AT0 arg0, AT1 arg1, AT2 arg2, bool resetIfStarted = false, bool skip = false, bool waitUntilCompleted = true);

		Wait Call(AT0 arg0, AT1 arg1, AT2 arg2, int total = 1, bool reset = true, bool skip = false, bool requireComplete = true);
	}
	public interface IHaglet<AT0, AT1, AT2> : IHaglet<AT0, AT1>, IHaglet<AT0>, IHaglet, IHagletCallable, IHagletTrigger, IHagletCallable<AT0>, IHagletCallable<AT0, AT1>, IHagletCallable<AT0, AT1, AT2>
	{
		AT2 arg2 { get; }

		void SetArg2(AT2 val, primitive? waitID = null);
	}
	public interface IHagletCallable<AT0, AT1, AT2, AT3> : IHagletCallable<AT0, AT1, AT2>, IHagletCallable<AT0, AT1>, IHaglet<AT0>, IHaglet, IHagletCallable, IHagletTrigger, IHagletCallable<AT0>
	{
		Wait Start(AT0 arg0, AT1 arg1, AT2 arg2, AT3 arg3, bool resetIfStarted = false, bool skip = false, bool waitUntilCompleted = true);

		Wait Call(AT0 arg0, AT1 arg1, AT2 arg2, AT3 arg3, int total = 1, bool reset = true, bool skip = false, bool requireComplete = true);
	}
	public interface IHaglet<AT0, AT1, AT2, AT3> : IHaglet<AT0, AT1, AT2>, IHaglet<AT0, AT1>, IHaglet<AT0>, IHaglet, IHagletCallable, IHagletTrigger, IHagletCallable<AT0>, IHagletCallable<AT0, AT1>, IHagletCallable<AT0, AT1, AT2>, IHagletCallable<AT0, AT1, AT2, AT3>
	{
		AT3 arg3 { get; }

		void SetArg3(AT3 val, primitive? waitID = null);
	}
	public interface IHagletCallableReturn<RT> : IHagletCallable
	{
		RT popReturnValue { get; }

		RT peekReturnValue { get; }
	}
	public interface IHagletCallableReturn<AT0, RT> : IHagletCallable<AT0>, IHagletCallable, IHagletCallableReturn<RT>
	{
	}
	public interface IHagletCallableReturn<AT0, AT1, RT> : IHagletCallable<AT0, AT1>, IHaglet<AT0>, IHaglet, IHagletCallable, IHagletTrigger, IHagletCallable<AT0>, IHagletCallableReturn<RT>
	{
	}
	public interface IHagletCallableReturn<AT0, AT1, AT2, RT> : IHagletCallable<AT0, AT1, AT2>, IHagletCallable<AT0, AT1>, IHaglet<AT0>, IHaglet, IHagletCallable, IHagletTrigger, IHagletCallable<AT0>, IHagletCallableReturn<RT>
	{
	}
	public interface IHagletCallableReturn<AT0, AT1, AT2, AT3, RT> : IHagletCallable<AT0, AT1, AT2, AT3>, IHagletCallable<AT0, AT1, AT2>, IHagletCallable<AT0, AT1>, IHaglet<AT0>, IHaglet, IHagletCallable, IHagletTrigger, IHagletCallable<AT0>, IHagletCallableReturn<RT>
	{
	}
	public interface IHagletReturn<RT> : IHaglet, IHagletCallable, IHagletTrigger, IHagletCallableReturn<RT>
	{
	}
	public interface IHagletReturn<AT0, RT> : IHaglet<AT0>, IHaglet, IHagletCallable, IHagletTrigger, IHagletCallable<AT0>, IHagletReturn<RT>, IHagletCallableReturn<RT>, IHagletCallableReturn<AT0, RT>
	{
	}
	public interface IHagletReturn<AT0, AT1, RT> : IHaglet<AT0, AT1>, IHaglet<AT0>, IHaglet, IHagletCallable, IHagletTrigger, IHagletCallable<AT0>, IHagletCallable<AT0, AT1>, IHagletReturn<AT0, RT>, IHagletReturn<RT>, IHagletCallableReturn<RT>, IHagletCallableReturn<AT0, RT>, IHagletCallableReturn<AT0, AT1, RT>
	{
	}
	public interface IHagletReturn<AT0, AT1, AT2, RT> : IHaglet<AT0, AT1, AT2>, IHaglet<AT0, AT1>, IHaglet<AT0>, IHaglet, IHagletCallable, IHagletTrigger, IHagletCallable<AT0>, IHagletCallable<AT0, AT1>, IHagletCallable<AT0, AT1, AT2>, IHagletReturn<AT0, AT1, RT>, IHagletReturn<AT0, RT>, IHagletReturn<RT>, IHagletCallableReturn<RT>, IHagletCallableReturn<AT0, RT>, IHagletCallableReturn<AT0, AT1, RT>, IHagletCallableReturn<AT0, AT1, AT2, RT>
	{
	}
	public interface IHagletReturn<AT0, AT1, AT2, AT3, RT> : IHaglet<AT0, AT1, AT2, AT3>, IHaglet<AT0, AT1, AT2>, IHaglet<AT0, AT1>, IHaglet<AT0>, IHaglet, IHagletCallable, IHagletTrigger, IHagletCallable<AT0>, IHagletCallable<AT0, AT1>, IHagletCallable<AT0, AT1, AT2>, IHagletCallable<AT0, AT1, AT2, AT3>, IHagletReturn<AT0, AT1, AT2, RT>, IHagletReturn<AT0, AT1, RT>, IHagletReturn<AT0, RT>, IHagletReturn<RT>, IHagletCallableReturn<RT>, IHagletCallableReturn<AT0, RT>, IHagletCallableReturn<AT0, AT1, RT>, IHagletCallableReturn<AT0, AT1, AT2, RT>, IHagletCallableReturn<AT0, AT1, AT2, AT3, RT>
	{
	}
	public static class IHagletX
	{
		public static void SetArg0<AT0>(this IHaglet<AT0> hag, AT0 val) where AT0 : struct, IConvertible
		{
			hag.SetArg0(val, val.ToInt64(null));
		}

		public static void SetArg0(this IHaglet<ulong> hag, ulong val)
		{
			hag.SetArg0(val, val);
		}

		public static void SetArg0(this IHaglet<double> hag, double val)
		{
			hag.SetArg0(val, val);
		}

		public static void SetArg0(this IHaglet<float> hag, float val)
		{
			hag.SetArg0(val, val);
		}

		public static void SetArg0(this IHaglet<UnityEngine.Object> hag, UnityEngine.Object val)
		{
			hag.SetArg0(val, (ulong)val.GetInstanceID());
		}

		public static void SetArg1<AT0, AT1>(this IHaglet<AT0, AT1> hag, AT1 val) where AT1 : struct, IConvertible
		{
			hag.SetArg1(val, val.ToInt64(null));
		}

		public static void SetArg1<AT0>(this IHaglet<AT0, ulong> hag, ulong val)
		{
			hag.SetArg1(val, val);
		}

		public static void SetArg1<AT0>(this IHaglet<AT0, double> hag, double val)
		{
			hag.SetArg1(val, val);
		}

		public static void SetArg1<AT0>(this IHaglet<AT0, float> hag, float val)
		{
			hag.SetArg1(val, val);
		}

		public static void SetArg1<AT0>(this IHaglet<AT0, UnityEngine.Object> hag, UnityEngine.Object val)
		{
			hag.SetArg1(val, (ulong)val.GetInstanceID());
		}

		public static void SetArg2<AT0, AT1, AT2>(this IHaglet<AT0, AT1, AT2> hag, AT2 val) where AT2 : struct, IConvertible
		{
			hag.SetArg2(val, val.ToInt64(null));
		}

		public static void SetArg2<AT0, AT1>(this IHaglet<AT0, AT1, ulong> hag, ulong val)
		{
			hag.SetArg2(val, val);
		}

		public static void SetArg2<AT0, AT1>(this IHaglet<AT0, AT1, double> hag, double val)
		{
			hag.SetArg2(val, val);
		}

		public static void SetArg2<AT0, AT1>(this IHaglet<AT0, AT1, float> hag, float val)
		{
			hag.SetArg2(val, val);
		}

		public static void SetArg3<AT0, AT1>(this IHaglet<AT0, AT1, UnityEngine.Object> hag, UnityEngine.Object val)
		{
			hag.SetArg2(val, (ulong)val.GetInstanceID());
		}

		public static void SetArg3<AT0, AT1, AT2, AT3>(this IHaglet<AT0, AT1, AT2, AT3> hag, AT3 val) where AT3 : struct, IConvertible
		{
			hag.SetArg3(val, val.ToInt64(null));
		}

		public static void SetArg3<AT0, AT1, AT2>(this IHaglet<AT0, AT1, AT2, ulong> hag, ulong val)
		{
			hag.SetArg3(val, val);
		}

		public static void SetArg3<AT0, AT1, AT2>(this IHaglet<AT0, AT1, AT2, double> hag, double val)
		{
			hag.SetArg3(val, val);
		}

		public static void SetArg3<AT0, AT1, AT2>(this IHaglet<AT0, AT1, AT2, float> hag, float val)
		{
			hag.SetArg3(val, val);
		}

		public static void SetArg3<AT0, AT1, AT2>(this IHaglet<AT0, AT1, AT2, UnityEngine.Object> hag, UnityEngine.Object val)
		{
			hag.SetArg3(val, (ulong)val.GetInstanceID());
		}
	}
	[StructLayout(LayoutKind.Explicit)]
	public struct Wait
	{
		public interface IUntil
		{
			Wait Happening(IHagletEvent @event, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false);

			Wait True(IHagletCondition cond, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false, IHagletEvent check = null, bool asCoroutine = false);

			Wait False(IHagletCondition cond, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false, IHagletEvent check = null, bool asCoroutine = false);

			Wait True(Func<bool> func, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false, IHagletEvent check = null, bool asCoroutine = false);

			Wait False(Func<bool> func, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false, IHagletEvent check = null, bool asCoroutine = false);

			Wait True(IHagletValue<bool> hVal, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false, IHagletEvent check = null, bool asCoroutine = false);

			Wait False(IHagletValue<bool> hVal, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false, IHagletEvent check = null, bool asCoroutine = false);

			Wait Entered<T>(IHagletValue<T> hVal, T enterVal, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false);

			Wait Exitted<T>(IHagletValue<T> hVal, T exitVal, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false);

			Wait Switched<T>(IHagletValue<T> hVal, T enterVal, T exitVal, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false);

			Wait Changed<T>(IHagletValue<T> hVal, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false);

			Wait Greater<T>(IHagletValue<T> func, T val, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false, IHagletEvent check = null, bool asCoroutine = false);

			Wait Smaller<T>(IHagletValue<T> func, T val, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false, IHagletEvent check = null, bool asCoroutine = false);

			Wait Triggered(int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false);

			Wait Triggered(int arg, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false);

			Wait Triggered<T>(T arg, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false) where T : struct, IConvertible;

			Wait ArgChange(int arg, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false);

			Wait ArgChange(int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false);
		}

		public interface IFor
		{
			Wait Updates(int total, bool allowPreMetNow = false, bool allowPreMetLater = false, bool asCoroutine = false);

			Wait LateUpdates(int total, bool allowPreMetNow = false, bool allowPreMetLater = false);

			Wait FixedUpdates(int total, bool allowPreMetNow = false, bool allowPreMetLater = false);

			Wait Seconds(float seconds, int total = 1, IHagletEvent check = null, bool asCoroutine = false);

			Wait RealSeconds(float seconds, int total = 1, IHagletEvent check = null, bool asCoroutine = false);

			Wait Value(IHagletCondition cond, bool val, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false, IHagletEvent check = null, bool asCoroutine = false);

			Wait Value(Func<bool> func, bool value, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false, IHagletEvent check = null, bool asCoroutine = false);

			Wait Value<T>(IHagletValue<T> func, T val, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false, IHagletEvent check = null, bool asCoroutine = false);

			Wait GotoSelector(Func<int> selector, bool allowPreMetLater = false, bool allowGotoLatest = false, IHagletEvent check = null, bool asCoroutine = false);

			Wait ArgValueWithID<T>(int arg, T value, primitive? id = null, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false);

			Wait ArgValue<T>(int arg, T value, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false) where T : struct, IConvertible;

			Wait ArgValue(int arg, ulong value, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false);

			Wait ArgValue(int arg, double value, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false);

			Wait ArgValue(int arg, float value, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false);

			Wait ArgValue(int arg, UnityEngine.Object value, int total = 1, bool allowPreMetNow = false, bool allowPreMetLater = false);

			Wait Any(Wait waitA, Wait waitB);

			Wait All(Wait waitA, Wait waitB);

			Wait Sequence(Wait waitA, Wait waitB);

			Wait Total(Wait wait, int multiple);
		}

		public interface IClient : IUntil, IFor
		{
			Func<Wait, Wait> waitBasis { set; }

			Wait Isolate(Wait wait);

			bool GetMet(Wait wait);

			ushort GetTally(Wait wait);

			ushort GetTotal(Wait wait);

			float GetTallySeconds(Wait wait);

			Wait SetGoto(Wait wait, int state, bool allowGotoLatest = true);

			Wait RestrictToGotos(Wait wait, int states);

			Wait SetSkip(Wait wait);
		}

		private sealed class Stub : IClient, IUntil, IFor
		{
			Func<Wait, Wait> IClient.waitBasis
			{
				set
				{
				}
			}

			Wait IUntil.Happening(IHagletEvent @event, int total, bool allowPreMetNow, bool allowPreMetLater)
			{
				return None;
			}

			Wait IUntil.True(IHagletCondition cond, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
			{
				return None;
			}

			Wait IUntil.False(IHagletCondition cond, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
			{
				return None;
			}

			Wait IUntil.True(Func<bool> func, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
			{
				return None;
			}

			Wait IUntil.False(Func<bool> func, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
			{
				return None;
			}

			Wait IUntil.True(IHagletValue<bool> hVal, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
			{
				return None;
			}

			Wait IUntil.False(IHagletValue<bool> hVal, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
			{
				return None;
			}

			Wait IUntil.Entered<T>(IHagletValue<T> hVal, T enterVal, int total, bool allowPreMetNow, bool allowPreMetLater)
			{
				return None;
			}

			Wait IUntil.Exitted<T>(IHagletValue<T> hVal, T exitVal, int total, bool allowPreMetNow, bool allowPreMetLater)
			{
				return None;
			}

			Wait IUntil.Switched<T>(IHagletValue<T> hVal, T enterVal, T exitVal, int total, bool allowPreMetNow, bool allowPreMetLater)
			{
				return None;
			}

			Wait IUntil.Changed<T>(IHagletValue<T> hVal, int total, bool allowPreMetNow, bool allowPreMetLater)
			{
				return None;
			}

			Wait IUntil.Greater<T>(IHagletValue<T> func, T val, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
			{
				return None;
			}

			Wait IUntil.Smaller<T>(IHagletValue<T> func, T val, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
			{
				return None;
			}

			Wait IUntil.Triggered(int total, bool allowPreMetNow, bool allowPreMetLater)
			{
				return None;
			}

			Wait IUntil.Triggered(int arg, int total, bool allowPreMetNow, bool allowPreMetLater)
			{
				return None;
			}

			Wait IUntil.Triggered<T>(T arg, int total, bool allowPreMetNow, bool allowPreMetLater)
			{
				return None;
			}

			Wait IUntil.ArgChange(int arg, int total, bool allowPreMetNow, bool allowPreMetLater)
			{
				return None;
			}

			Wait IUntil.ArgChange(int total, bool allowPreMetNow, bool allowPreMetLater)
			{
				return None;
			}

			Wait IFor.Updates(int total, bool allowPreMetNow, bool allowPreMetLater, bool asCoroutine)
			{
				return None;
			}

			Wait IFor.LateUpdates(int total, bool allowPreMetNow, bool allowPreMetLater)
			{
				return None;
			}

			Wait IFor.FixedUpdates(int total, bool allowPreMetNow, bool allowPreMetLater)
			{
				return None;
			}

			Wait IFor.Seconds(float seconds, int total, IHagletEvent check, bool asCoroutine)
			{
				return None;
			}

			Wait IFor.RealSeconds(float seconds, int total, IHagletEvent check, bool asCoroutine)
			{
				return None;
			}

			Wait IFor.Value(IHagletCondition cond, bool val, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
			{
				return None;
			}

			Wait IFor.Value(Func<bool> func, bool val, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
			{
				return None;
			}

			Wait IFor.Value<T>(IHagletValue<T> func, T val, int total, bool allowPreMetNow, bool allowPreMetLater, IHagletEvent check, bool asCoroutine)
			{
				return None;
			}

			Wait IFor.GotoSelector(Func<int> selector, bool allowPreMetLater, bool allowGotoLatest, IHagletEvent check, bool asCoroutine)
			{
				return None;
			}

			Wait IFor.ArgValueWithID<T>(int arg, T value, primitive? id, int total, bool allowPreMetNow, bool allowPreMetLater)
			{
				return None;
			}

			Wait IFor.ArgValue<T>(int arg, T value, int total, bool allowPreMetNow, bool allowPreMetLater)
			{
				return None;
			}

			Wait IFor.ArgValue(int arg, ulong value, int total, bool allowPreMetNow, bool allowPreMetLater)
			{
				return None;
			}

			Wait IFor.ArgValue(int arg, double value, int total, bool allowPreMetNow, bool allowPreMetLater)
			{
				return None;
			}

			Wait IFor.ArgValue(int arg, float value, int total, bool allowPreMetNow, bool allowPreMetLater)
			{
				return None;
			}

			Wait IFor.ArgValue(int arg, UnityEngine.Object value, int total, bool allowPreMetNow, bool allowPreMetLater)
			{
				return None;
			}

			Wait IFor.Any(Wait waitA, Wait waitB)
			{
				return None;
			}

			Wait IFor.All(Wait waitA, Wait waitB)
			{
				return None;
			}

			Wait IFor.Sequence(Wait waitA, Wait waitB)
			{
				return None;
			}

			Wait IFor.Total(Wait wait, int multiple)
			{
				return None;
			}

			bool IClient.GetMet(Wait wait)
			{
				return false;
			}

			ushort IClient.GetTally(Wait wait)
			{
				return 0;
			}

			ushort IClient.GetTotal(Wait wait)
			{
				return 0;
			}

			float IClient.GetTallySeconds(Wait wait)
			{
				return 0f;
			}

			Wait IClient.Isolate(Wait wait)
			{
				return None;
			}

			Wait IClient.SetGoto(Wait wait, int state, bool allowGotoLatest)
			{
				return None;
			}

			Wait IClient.RestrictToGotos(Wait wait, int states)
			{
				return None;
			}

			Wait IClient.SetSkip(Wait wait)
			{
				return None;
			}
		}

		public static readonly Wait None = new Wait(Routine.Yield.SpecialIndex.START);

		public static readonly Wait PreMet = new Wait(Routine.Yield.SpecialIndex.WaitPreMet);

		public static readonly Wait Forever = new Wait(Routine.Yield.SpecialIndex.WaitForever);

		public static readonly Routine.Yield.SpecialIndex UntilTriggered = Routine.Yield.SpecialIndex.WaitUntilTriggered;

		public static readonly Routine.Yield.SpecialIndex ForUpdate = Routine.Yield.SpecialIndex.WaitForUpdate;

		public static readonly Routine.Yield.SpecialIndex ForLateUpdate = Routine.Yield.SpecialIndex.WaitForLateUpdate;

		public static readonly Routine.Yield.SpecialIndex ForFixedUpdate = Routine.Yield.SpecialIndex.WaitForFixedUpdate;

		public static readonly Routine.Yield.SpecialIndex ForCoroutineUpdate = Routine.Yield.SpecialIndex.WaitForCoroutineUpdate;

		public static readonly Routine.Yield.SpecialIndex UntilArgChange = Routine.Yield.SpecialIndex.WaitUntilArgChange;

		[ThreadStatic]
		private static IClient client = new Stub();

		[FieldOffset(0)]
		public readonly byte ci;

		[FieldOffset(0)]
		public readonly Routine.Yield.SpecialIndex si;

		[FieldOffset(2)]
		public readonly byte rev;

		public static IUntil Until => client;

		public static IFor For => client;

		public static Func<Wait, Wait> basis
		{
			set
			{
				client.waitBasis = value;
			}
		}

		public bool met
		{
			get
			{
				switch (si)
				{
				case Routine.Yield.SpecialIndex.WaitPreMet:
					return true;
				case Routine.Yield.SpecialIndex.START:
				case Routine.Yield.SpecialIndex.WaitForever:
					return false;
				default:
					return client.GetMet(this);
				}
			}
		}

		public ushort tally => client.GetTally(this);

		public ushort total => client.GetTotal(this);

		public float tallySeconds => client.GetTallySeconds(this);

		public static Wait operator &(Wait termA, Wait termB)
		{
			return For.All(termA, termB);
		}

		public static Wait operator |(Wait termA, Wait termB)
		{
			return For.Any(termA, termB);
		}

		public static Wait operator *(Wait termA, int total)
		{
			return For.Total(termA, total);
		}

		public static Wait operator +(Wait termA, Wait termB)
		{
			return For.Sequence(termA, termB);
		}

		public static Wait operator &(int states, Wait wait)
		{
			return client.RestrictToGotos(wait, states);
		}

		public static implicit operator Wait(Func<bool> func)
		{
			return Until.True(func);
		}

		public static implicit operator Wait(Func<int> selector)
		{
			return For.GotoSelector(selector);
		}

		public static IClient Push(IClient newClient)
		{
			return newClient.PushTo(ref client);
		}

		private Wait(byte ci, byte r)
		{
			si = (Routine.Yield.SpecialIndex)0;
			this.ci = ci;
			rev = r;
		}

		private Wait(Routine.Yield.SpecialIndex si)
		{
			ci = 0;
			this.si = si;
			rev = 0;
		}

		public Wait(byte ci, Haglet h)
		{
			si = (Routine.Yield.SpecialIndex)0;
			this.ci = ci;
			rev = h.GetClauseRevision(ci);
		}

		public Wait Isolate()
		{
			return client.Isolate(this);
		}

		public Wait Goto<T>(T id, bool allowGotoLatest = true) where T : struct, IConvertible
		{
			return client.SetGoto(this, id.ToInt32(null), allowGotoLatest);
		}

		public Wait ThenSkip()
		{
			return client.SetSkip(this);
		}

		public static bool operator ==(Wait l, Wait r)
		{
			if (l.si == r.si && l.ci == r.ci)
			{
				return l.rev == r.rev;
			}
			return false;
		}

		public static bool operator !=(Wait l, Wait r)
		{
			if (l.si == r.si && l.ci == r.ci)
			{
				return l.rev != r.rev;
			}
			return true;
		}

		public override string ToString()
		{
			if (ci < 0)
			{
				return si.ToString();
			}
			return $"{ci:D2} (r{rev})";
		}

		public override bool Equals(object obj)
		{
			if (!(obj is Wait wait))
			{
				return false;
			}
			if (ci == wait.ci && si == wait.si)
			{
				return rev == wait.rev;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return ((-195525156 * -1521134295 + ci.GetHashCode()) * -1521134295 + si.GetHashCode()) * -1521134295 + rev.GetHashCode();
		}
	}
	[Serializable]
	public class HagletOrientRigidbody
	{
		public float strengthPerRadian;

		public float dampening;

		public Rigidbody rigidbody;

		public Vector3 targWorldFwd;

		public Vector3 targWorldUp;

		public Vector3 localFwd;

		public Vector3 localUp;

		public IEnumerator<Routine.Yield> Run()
		{
			if (!HagletEvent.onDefaultFixedUpdate.happening)
			{
				yield return Wait.ForFixedUpdate;
			}
			while (true)
			{
				if (!(rigidbody == null))
				{
					Vector3 vector = Vector3.Cross(targWorldFwd.normalized, rigidbody.transform.TransformDirection(localFwd));
					if (vector.x != 0f || vector.y != 0f || vector.z != 0f)
					{
						float magnitude = vector.magnitude;
						Vector3 vector2 = vector / magnitude;
						float num = (float)Math.Asin(magnitude);
						rigidbody.AddTorque(vector2 * (0f - strengthPerRadian * num));
					}
					Vector3 vector3 = Vector3.Cross(targWorldUp.normalized, rigidbody.transform.TransformDirection(localUp));
					if (vector3.x != 0f || vector3.y != 0f || vector3.z != 0f)
					{
						float magnitude2 = vector3.magnitude;
						Vector3 vector4 = vector3 / magnitude2;
						float num2 = (float)Math.Asin(magnitude2);
						rigidbody.AddTorque(vector4 * (0f - strengthPerRadian * num2));
					}
					rigidbody.AddTorque((0f - dampening) * rigidbody.angularVelocity);
				}
				yield return Wait.ForFixedUpdate;
			}
		}
	}
	[Serializable]
	public class HagletPositionRigidbody
	{
		public float strengthPerDist;

		public float dampeningPerSpeed;

		public float maxForce;

		public Rigidbody rigidbody;

		public Vector3 targWorldPos;

		public Vector3 localOrigin;

		public IEnumerator<Routine.Yield> Run()
		{
			if (!HagletEvent.onDefaultFixedUpdate.happening)
			{
				yield return Wait.ForFixedUpdate;
			}
			while (true)
			{
				if (!(rigidbody == null))
				{
					Transform transform = rigidbody.transform;
					Vector3 vector = targWorldPos - transform.TransformPoint(localOrigin);
					rigidbody.AddForce((strengthPerDist * vector).ClampedToMagnitude(maxForce));
					rigidbody.AddForce(((0f - dampeningPerSpeed) * rigidbody.velocity).ClampedToMagnitude(maxForce));
				}
				yield return Wait.ForFixedUpdate;
			}
		}
	}
	public static class HagletUI
	{
		public struct FadeParams
		{
			public Graphic graphic;

			public CanvasGroup canvas;

			public float startAlpha;

			public float endAlpha;

			public float delay;

			public float duration;

			public MathfX.SineRemapEaseType? easeType;

			public IHagletEvent update;

			public FadeParams(Graphic graphic, CanvasGroup canvas, float startAlpha, float endAlpha, float duration, float delay = 0f, MathfX.SineRemapEaseType? easeType = null, IHagletEvent update = null)
			{
				this.graphic = graphic;
				this.canvas = canvas;
				this.startAlpha = startAlpha;
				this.endAlpha = endAlpha;
				this.duration = duration;
				this.delay = delay;
				this.easeType = easeType;
				this.update = update;
			}

			public void ApplyTime(float t)
			{
				float num = startAlpha;
				num = ((t == duration) ? endAlpha : (easeType.HasValue ? MathfX.SineRemapLerp(t, easeType.Value, 0f, duration, startAlpha, endAlpha) : Mathf.Lerp(startAlpha, endAlpha, t / duration)));
				if (graphic != null)
				{
					graphic.color = graphic.color.RepA(num);
				}
				if (canvas != null)
				{
					canvas.alpha = num;
				}
			}
		}

		public struct CountUpwardsParams
		{
			public Text text;

			public int total;

			public float duration;

			public float delay;

			public string format;

			public MathfX.SineRemapEaseType? easeType;

			public IHagletEvent update;

			public CountUpwardsParams(Text text, int total, float duration, float delay = 0f, string format = null, MathfX.SineRemapEaseType? easeType = null, IHagletEvent update = null)
			{
				this.text = text;
				this.total = total;
				this.duration = duration;
				this.delay = delay;
				this.format = format;
				this.easeType = easeType;
				this.update = update;
			}

			public void ApplyTime(float t)
			{
				int num = 0;
				num = ((t == duration) ? total : (easeType.HasValue ? Mathf.RoundToInt(MathfX.SineRemapLerp(t, easeType.Value, 0f, duration, 0f, total)) : Mathf.RoundToInt(Mathf.Lerp(0f, total, t / duration))));
				text.text = num.ToString(format);
			}
		}

		[Routine.InitialWaitCapacity(1)]
		public static IEnumerator<Routine.Yield> Fade(FadeParams @params)
		{
			@params.ApplyTime(0f);
			yield return Wait.For.RealSeconds(@params.delay, 1, @params.update);
			for (float t = 0f; t < @params.duration; t += Time.unscaledDeltaTime)
			{
				@params.ApplyTime(t);
				yield return (@params.update != null) ? Wait.Until.Happening(@params.update) : Wait.For.Updates(1);
			}
			@params.ApplyTime(@params.duration);
		}

		[Routine.InitialWaitCapacity(1)]
		public static IEnumerator<Routine.Yield> CountUpwards(CountUpwardsParams @params)
		{
			@params.ApplyTime(0f);
			yield return Wait.For.RealSeconds(@params.delay, 1, @params.update);
			for (float t = 0f; t < @params.duration; t += Time.unscaledDeltaTime)
			{
				@params.ApplyTime(t);
				yield return (@params.update != null) ? Wait.Until.Happening(@params.update) : Wait.For.Updates(1);
			}
			@params.ApplyTime(@params.duration);
		}
	}
	public interface IHagletValue : IHagletEvent
	{
		bool changing { get; }

		int? enterValueID { get; }

		int? exitValueID { get; }

		int? CompareValueToValueOfID(int id);

		string ValueIDToString(int id);

		int? CompareValuesOfIDs(int idA, int idB);
	}
	public interface IHagletValue<T> : IHagletValue, IHagletEvent
	{
		T value { get; }

		event Action<T> onPostValueChange;

		int Declare(T value);

		int? CompareTo(T other);
	}
	public abstract class HagletValue : HagletEvent
	{
		public int? enterValueID { get; protected set; }

		public int? exitValueID { get; protected set; }

		public static HagletValue<T> Create<T>(out HagletValue<T> hVal, string name = null, T initVal = default(T), IOwner owner = null, int initRespCap = 8)
		{
			return hVal = new Generic<T>(name, initVal, owner, initRespCap);
		}

		public static HagletValue<bool> Create(out HagletValue<bool> hVal, string name = null, bool initVal = false, IOwner owner = null, int initRespCap = 8)
		{
			return hVal = new Bool(name, initVal, owner, initRespCap);
		}

		public static HagletValue<int> Create(out HagletValue<int> hVal, string name = null, int initVal = 0, IOwner owner = null, int initRespCap = 8)
		{
			return hVal = new Int(name, initVal, owner, initRespCap);
		}

		public static HagletValue<T> CreateUO<T>(out HagletValue<T> hVal, string name = null, T initVal = null, IOwner owner = null, int initRespCap = 8) where T : UnityEngine.Object
		{
			return hVal = new UnityObject<T>(name, initVal, owner, initRespCap);
		}

		public HagletValue(string name = null, IOwner owner = null, int initRespCap = 8)
			: base(name, owner, initRespCap)
		{
		}

		public abstract string ValueIDToString(int id);

		public virtual int? CompareValueToValueOfID(int id)
		{
			return null;
		}

		public virtual int? CompareValuesOfIDs(int idA, int idB)
		{
			return null;
		}
	}
	public abstract class HagletValue<T> : HagletValue, IHagletValue<T>, IHagletValue, IHagletEvent
	{
		protected T _value;

		public bool changing { get; set; }

		public virtual T value
		{
			get
			{
				return _value;
			}
			set
			{
				if (!EqualityComparer<T>.Default.Equals(value, _value))
				{
					changing = true;
					base.exitValueID = TryGetValueID(_value);
					base.enterValueID = TryGetValueID(value);
					_value = value;
					Happen();
					int? num2 = (base.enterValueID = null);
					base.exitValueID = num2;
					changing = false;
					if (this.onPostValueChange != null)
					{
						this.onPostValueChange(value);
					}
				}
			}
		}

		public event Action<T> onPostValueChange;

		protected HagletValue(string name = null, T initVal = default(T), IOwner owner = null, int initRespCap = 8)
			: base(name, owner, initRespCap)
		{
			_value = initVal;
		}

		public int Declare(T value)
		{
			int valueID = GetValueID(value);
			if ((bool)base.happening && !base.enterValueID.HasValue && EqualityComparer<T>.Default.Equals(value, this.value))
			{
				base.enterValueID = valueID;
			}
			return valueID;
		}

		protected abstract int GetValueID(T value);

		protected abstract int? TryGetValueID(T value);

		public override int? CompareValueToValueOfID(int id)
		{
			if (GetValueID(_value) == id)
			{
				return 0;
			}
			return null;
		}

		public virtual int? CompareTo(T other)
		{
			return Comparer<T>.Default.Compare(_value, other);
		}
	}
	internal class Generic<T> : HagletValue<T>
	{
		private readonly List<T> watchedValues;

		public Generic(string name = null, T initVal = default(T), IOwner owner = null, int initWatchCap = 2, int initRespCap = 8)
			: base(name, initVal, owner, initRespCap)
		{
			watchedValues = new List<T>(initWatchCap);
		}

		protected override int GetValueID(T value)
		{
			int num = watchedValues.IndexOf(value);
			if (num != -1)
			{
				return num;
			}
			watchedValues.Add(value);
			return watchedValues.Count - 1;
		}

		protected override int? TryGetValueID(T value)
		{
			int num = watchedValues.IndexOf(value);
			if (num == -1)
			{
				return null;
			}
			return num;
		}

		public override string ToString()
		{
			return $"{base.name} ({_value})";
		}

		public override string ValueIDToString(int id)
		{
			if (id < 0 || id >= watchedValues.Count)
			{
				return null;
			}
			return watchedValues[id].ToString();
		}

		public override int? CompareValuesOfIDs(int idA, int idB)
		{
			return Comparer<T>.Default.Compare(watchedValues[idA], watchedValues[idB]);
		}
	}
	internal class Bool : HagletValue<bool>
	{
		public Bool(string name = null, bool initVal = false, IOwner owner = null, int initRespCap = 8)
			: base(name, initVal, owner, initRespCap)
		{
		}

		protected override int GetValueID(bool value)
		{
			if (!value)
			{
				return 0;
			}
			return 1;
		}

		protected override int? TryGetValueID(bool value)
		{
			return value ? 1 : 0;
		}

		public override string ValueIDToString(int id)
		{
			return id switch
			{
				0 => false.ToString(), 
				1 => true.ToString(), 
				_ => null, 
			};
		}

		public override int? CompareValuesOfIDs(int idA, int idB)
		{
			bool flag = false;
			bool flag2 = false;
			switch (idA)
			{
			case 1:
				flag = true;
				break;
			default:
				return null;
			case 0:
				break;
			}
			switch (idB)
			{
			case 1:
				flag2 = true;
				break;
			default:
				return null;
			case 0:
				break;
			}
			return flag.CompareTo(flag2);
		}
	}
	internal class Int : HagletValue<int>
	{
		public Int(string name = null, int initVal = 0, IOwner owner = null, int initRespCap = 8)
			: base(name, initVal, owner, initRespCap)
		{
		}

		protected override int GetValueID(int value)
		{
			return value;
		}

		protected override int? TryGetValueID(int value)
		{
			return value;
		}

		public override string ValueIDToString(int id)
		{
			return id.ToString();
		}

		public override int? CompareValueToValueOfID(int id)
		{
			return id.CompareTo(value);
		}

		public override int? CompareValuesOfIDs(int idA, int idB)
		{
			return idA.CompareTo(idB);
		}
	}
	internal class UnityObject<T> : HagletValue<T> where T : UnityEngine.Object
	{
		public UnityObject(string name = null, T initVal = null, IOwner owner = null, int initRespCap = 8)
			: base(name, initVal, owner, initRespCap)
		{
		}

		protected override int GetValueID(T value)
		{
			if (!(value != null))
			{
				return 0;
			}
			return value.GetInstanceID();
		}

		protected override int? TryGetValueID(T value)
		{
			return (value != null) ? value.GetInstanceID() : 0;
		}

		public override string ValueIDToString(int id)
		{
			return "Unity Object";
		}

		public override int? CompareTo(T other)
		{
			return null;
		}
	}
	public static class Bitwise
	{
		[StructLayout(LayoutKind.Explicit)]
		public struct TypeUnion
		{
			[FieldOffset(0)]
			public int Int32Bits;

			[FieldOffset(0)]
			public float FloatBits;
		}

		public static long IntsToLong(int msbs, int lsbs)
		{
			return ((long)msbs << 32) | (uint)lsbs;
		}

		public static void LongToInts(long theLong, out int msbs, out int lsbs)
		{
			msbs = (int)(theLong >> 32);
			lsbs = (int)(theLong & 0xFFFFFFFFu);
		}

		public static int BitRotate_u32(int value, int shift)
		{
			return (value << shift) | (value >> 32 - shift);
		}

		public static int BitRotate_u16(int value, int shift)
		{
			return ((value << shift) & 0xFFFF) | (value >> 8 - shift);
		}

		public static int BitRotate_u8(int value, int shift)
		{
			return ((value << shift) & 0xFF) | (value >> 8 - shift);
		}

		public static float PackVector2ToFloat(Vector2 input, float scale = 10000f)
		{
			short num = (short)(input.x * scale);
			short num2 = (short)(input.y * scale);
			TypeUnion typeUnion = default(TypeUnion);
			typeUnion.Int32Bits = (num << 16) | (num2 & 0xFFFF);
			return typeUnion.FloatBits;
		}

		public static Vector2 UnPackFloatToVector2(float input, float scale = 10000f)
		{
			TypeUnion typeUnion = default(TypeUnion);
			typeUnion.FloatBits = input;
			short num = (short)((typeUnion.Int32Bits >> 16) & 0xFFFF);
			short num2 = (short)(typeUnion.Int32Bits & 0xFFFF);
			float num3 = 1f / scale;
			return new Vector2((float)num * num3, (float)num2 * num3);
		}

		public static int PackVector2ToInt32(Vector2 v)
		{
			return 0 | (int)(v.x * 255f) | ((int)(v.y * 255f) << 8);
		}

		public static Vector2 UnpackInt32ToVector2(int v)
		{
			Vector2 result = new Vector2(result.x = (float)(v & 0xFF) / 255f, result.y = (float)((v >> 8) & 0xFF) / 255f);
			return result;
		}
	}
	[StructLayout(LayoutKind.Explicit)]
	public struct FastBounds
	{
		[FieldOffset(0)]
		public Bounds unityBounds;

		[FieldOffset(0)]
		public Vector3 center;

		[FieldOffset(12)]
		public Vector3 extents;
	}
	public static class BoundsX
	{
		public static void ShiftCenter(ref Bounds bounds, float x, float y, float z)
		{
			Vector3 center = bounds.center;
			center.x += x;
			center.y += y;
			center.z += z;
			bounds.center = center;
		}

		public static bool Intersects(ref Bounds lhs, ref Bounds rhs)
		{
			FastBounds fastBounds = default(FastBounds);
			fastBounds.center = Vector3X.zero;
			fastBounds.extents = Vector3X.zero;
			fastBounds.unityBounds = lhs;
			FastBounds fastBounds2 = default(FastBounds);
			fastBounds2.center = Vector3X.zero;
			fastBounds2.extents = Vector3X.zero;
			fastBounds2.unityBounds = rhs;
			Vector3 center = fastBounds.center;
			Vector3 extents = fastBounds.extents;
			Vector3 center2 = fastBounds2.center;
			Vector3 extents2 = fastBounds2.extents;
			if (center.x - extents.x <= center2.x + extents2.x && center.x + extents.x >= center2.x - extents2.x && center.y - extents.y <= center2.y + extents2.y && center.y + extents.y >= center2.y - extents2.y && center.z - extents.z <= center2.z + extents2.z)
			{
				return center.z + extents.z >= center2.z - extents2.z;
			}
			return false;
		}

		public static void GetCorners(ref Bounds b, out Vector3 RUF, out Vector3 RDF, out Vector3 LUF, out Vector3 LDF, out Vector3 RUB, out Vector3 RDB, out Vector3 LUB, out Vector3 LDB)
		{
			FastBounds fastBounds = default(FastBounds);
			fastBounds.center = Vector3X.zero;
			fastBounds.extents = Vector3X.zero;
			fastBounds.unityBounds = b;
			Vector3 center = fastBounds.center;
			Vector3 extents = fastBounds.extents;
			RUF.x = (RDF.x = (RUB.x = (RDB.x = center.x + extents.x)));
			LUF.x = (LDF.x = (LUB.x = (LDB.x = center.x - extents.x)));
			RUF.y = (LUF.y = (RUB.y = (LUB.y = center.y + extents.y)));
			RDF.y = (LDF.y = (RDB.y = (LDB.y = center.y - extents.y)));
			RUF.z = (RDF.z = (LUF.z = (LDF.z = center.z + extents.z)));
			RUB.z = (RDB.z = (LUB.z = (LDB.z = center.z - extents.z)));
		}

		public static void GetCorners(ref Bounds b, Vector3[] corners)
		{
			FastBounds fastBounds = default(FastBounds);
			fastBounds.center = Vector3X.zero;
			fastBounds.extents = Vector3X.zero;
			fastBounds.unityBounds = b;
			Vector3 center = fastBounds.center;
			Vector3 extents = fastBounds.extents;
			Vector3 vector = default(Vector3);
			Vector3 vector2 = default(Vector3);
			Vector3 vector3 = default(Vector3);
			Vector3 vector4 = default(Vector3);
			vector.x = (vector2.x = (vector3.x = (vector4.x = center.x + extents.x)));
			Vector3 vector5 = default(Vector3);
			Vector3 vector6 = default(Vector3);
			Vector3 vector7 = default(Vector3);
			Vector3 vector8 = default(Vector3);
			vector5.x = (vector6.x = (vector7.x = (vector8.x = center.x - extents.x)));
			vector.y = (vector5.y = (vector3.y = (vector7.y = center.y + extents.y)));
			vector2.y = (vector6.y = (vector4.y = (vector8.y = center.y - extents.y)));
			vector.z = (vector2.z = (vector5.z = (vector6.z = center.z + extents.z)));
			vector3.z = (vector4.z = (vector7.z = (vector8.z = center.z - extents.z)));
			corners[0] = vector;
			corners[1] = vector2;
			corners[2] = vector5;
			corners[3] = vector6;
			corners[4] = vector3;
			corners[5] = vector4;
			corners[6] = vector7;
			corners[7] = vector8;
		}

		public static void Encapsulate(ref Bounds into, Bounds from)
		{
			FastBounds fastBounds = default(FastBounds);
			fastBounds.center = Vector3X.zero;
			fastBounds.extents = Vector3X.zero;
			fastBounds.unityBounds = into;
			FastBounds fastBounds2 = default(FastBounds);
			fastBounds2.center = Vector3X.zero;
			fastBounds2.extents = Vector3X.zero;
			fastBounds2.unityBounds = from;
			Vector3 vector = default(Vector3);
			vector.x = fastBounds2.center.x - fastBounds2.extents.x;
			vector.y = fastBounds2.center.y - fastBounds2.extents.y;
			vector.z = fastBounds2.center.z - fastBounds2.extents.z;
			Vector3 vector2 = default(Vector3);
			vector2.x = fastBounds2.center.x + fastBounds2.extents.x;
			vector2.y = fastBounds2.center.y + fastBounds2.extents.y;
			vector2.z = fastBounds2.center.z + fastBounds2.extents.z;
			Vector3 vector3 = default(Vector3);
			vector3.x = fastBounds.center.x - fastBounds.extents.x;
			vector3.y = fastBounds.center.y - fastBounds.extents.y;
			vector3.z = fastBounds.center.z - fastBounds.extents.z;
			Vector3 vector4 = default(Vector3);
			vector4.x = fastBounds.center.x + fastBounds.extents.x;
			vector4.y = fastBounds.center.y + fastBounds.extents.y;
			vector4.z = fastBounds.center.z + fastBounds.extents.z;
			Vector3 vector5 = default(Vector3);
			vector5.x = ((vector.x < vector3.x) ? vector.x : vector3.x);
			vector5.y = ((vector.y < vector3.y) ? vector.y : vector3.y);
			vector5.z = ((vector.z < vector3.z) ? vector.z : vector3.z);
			Vector3 vector6 = default(Vector3);
			vector6.x = ((vector2.x > vector4.x) ? vector2.x : vector4.x);
			vector6.y = ((vector2.y > vector4.y) ? vector2.y : vector4.y);
			vector6.z = ((vector2.z > vector4.z) ? vector2.z : vector4.z);
			Vector3 vector7 = default(Vector3);
			vector7.x = vector6.x - vector5.x;
			vector7.y = vector6.y - vector5.y;
			vector7.z = vector6.z - vector5.z;
			fastBounds.extents.x = vector7.x * 0.5f;
			fastBounds.extents.y = vector7.y * 0.5f;
			fastBounds.extents.z = vector7.z * 0.5f;
			fastBounds.center.x = vector5.x + fastBounds.extents.x;
			fastBounds.center.y = vector5.y + fastBounds.extents.y;
			fastBounds.center.z = vector5.z + fastBounds.extents.z;
			into = fastBounds.unityBounds;
		}

		public static void Encapsulate(ref Bounds into, Vector3 point)
		{
			FastBounds fastBounds = default(FastBounds);
			fastBounds.center = Vector3X.zero;
			fastBounds.extents = Vector3X.zero;
			fastBounds.unityBounds = into;
			Vector3 vector = default(Vector3);
			vector.x = fastBounds.center.x - fastBounds.extents.x;
			vector.y = fastBounds.center.y - fastBounds.extents.y;
			vector.z = fastBounds.center.z - fastBounds.extents.z;
			Vector3 vector2 = default(Vector3);
			vector2.x = fastBounds.center.x + fastBounds.extents.x;
			vector2.y = fastBounds.center.y + fastBounds.extents.y;
			vector2.z = fastBounds.center.z + fastBounds.extents.z;
			Vector3 vector3 = default(Vector3);
			vector3.x = ((point.x < vector.x) ? point.x : vector.x);
			vector3.y = ((point.y < vector.y) ? point.y : vector.y);
			vector3.z = ((point.z < vector.z) ? point.z : vector.z);
			Vector3 vector4 = default(Vector3);
			vector4.x = ((point.x > vector2.x) ? point.x : vector2.x);
			vector4.y = ((point.y > vector2.y) ? point.y : vector2.y);
			vector4.z = ((point.z > vector2.z) ? point.z : vector2.z);
			Vector3 vector5 = default(Vector3);
			vector5.x = vector4.x - vector3.x;
			vector5.y = vector4.y - vector3.y;
			vector5.z = vector4.z - vector3.z;
			fastBounds.extents.x = vector5.x * 0.5f;
			fastBounds.extents.y = vector5.y * 0.5f;
			fastBounds.extents.z = vector5.z * 0.5f;
			fastBounds.center.x = vector3.x + fastBounds.extents.x;
			fastBounds.center.y = vector3.y + fastBounds.extents.y;
			fastBounds.center.z = vector3.z + fastBounds.extents.z;
			into = fastBounds.unityBounds;
		}

		public static void Encapsulate(ref Bounds into, Vector3[] points, int start, int len)
		{
			FastBounds fastBounds = default(FastBounds);
			fastBounds.center = Vector3X.zero;
			fastBounds.extents = Vector3X.zero;
			fastBounds.unityBounds = into;
			Vector3 vector = default(Vector3);
			vector.x = fastBounds.center.x - fastBounds.extents.x;
			vector.y = fastBounds.center.y - fastBounds.extents.y;
			vector.z = fastBounds.center.z - fastBounds.extents.z;
			Vector3 vector2 = default(Vector3);
			vector2.x = fastBounds.center.x + fastBounds.extents.x;
			vector2.y = fastBounds.center.y + fastBounds.extents.y;
			vector2.z = fastBounds.center.z + fastBounds.extents.z;
			for (int i = start; i < len; i++)
			{
				Vector3 vector3 = points[i];
				if (vector3.x < vector.x)
				{
					vector.x = vector3.x;
				}
				else if (vector3.x > vector2.x)
				{
					vector2.x = vector3.x;
				}
				if (vector3.y < vector.y)
				{
					vector.y = vector3.y;
				}
				else if (vector3.y > vector2.y)
				{
					vector2.y = vector3.y;
				}
				if (vector3.z < vector.z)
				{
					vector.z = vector3.z;
				}
				else if (vector3.z > vector2.z)
				{
					vector2.z = vector3.z;
				}
			}
			Vector3 vector4 = default(Vector3);
			vector4.x = vector2.x - vector.x;
			vector4.y = vector2.y - vector.y;
			vector4.z = vector2.z - vector.z;
			fastBounds.extents.x = vector4.x * 0.5f;
			fastBounds.extents.y = vector4.y * 0.5f;
			fastBounds.extents.z = vector4.z * 0.5f;
			fastBounds.center.x = vector.x + fastBounds.extents.x;
			fastBounds.center.y = vector.y + fastBounds.extents.y;
			fastBounds.center.z = vector.z + fastBounds.extents.z;
			into = fastBounds.unityBounds;
		}
	}
	public static class ColorX
	{
		public static readonly Color red = new Color(1f, 0f, 0f, 1f);

		public static readonly Color green = new Color(0f, 1f, 0f, 1f);

		public static readonly Color blue = new Color(0f, 0f, 1f, 1f);

		public static readonly Color white = new Color(1f, 1f, 1f, 1f);

		public static readonly Color black = new Color(0f, 0f, 0f, 1f);

		public static readonly Color yellow = new Color(1f, 47f / 51f, 0.015686275f, 1f);

		public static readonly Color cyan = new Color(0f, 1f, 1f, 1f);

		public static readonly Color magenta = new Color(1f, 0f, 1f, 1f);

		public static readonly Color gray = new Color(0.5f, 0.5f, 0.5f, 1f);

		public static readonly Color grey = new Color(0.5f, 0.5f, 0.5f, 1f);

		public static readonly Color clear = new Color(0f, 0f, 0f, 0f);

		public static Color RGB(int r, int g, int b, int a = 255)
		{
			Color result = default(Color);
			result.r = (float)r / 255f;
			result.g = (float)g / 255f;
			result.b = (float)b / 255f;
			result.a = (float)a / 255f;
			return result;
		}

		public static Color RepR(this Color color, float newVal)
		{
			color.r = newVal;
			return color;
		}

		public static Color RepG(this Color color, float newVal)
		{
			color.g = newVal;
			return color;
		}

		public static Color RepB(this Color color, float newVal)
		{
			color.b = newVal;
			return color;
		}

		public static Color RepA(this Color color, float newVal)
		{
			color.a = newVal;
			return color;
		}

		public static Color32 RepR(this Color32 color, byte newVal)
		{
			color.r = newVal;
			return color;
		}

		public static Color32 RepG(this Color32 color, byte newVal)
		{
			color.g = newVal;
			return color;
		}

		public static Color32 RepB(this Color32 color, byte newVal)
		{
			color.b = newVal;
			return color;
		}

		public static Color32 RepA(this Color32 color, byte newVal)
		{
			color.a = newVal;
			return color;
		}

		public static Color RepRGB(this Color color, Vector3 rgb)
		{
			color.r = rgb.x;
			color.g = rgb.y;
			color.b = rgb.z;
			return color;
		}

		public static Vector3 GetRGB(this Color color)
		{
			return new Vector3(color.r, color.g, color.b);
		}

		public static Color From(Vector3 rgb, float a)
		{
			return new Color(rgb.x, rgb.y, rgb.z, a);
		}

		public static Color MoveTowards(Color current, Color target, float maxDistanceDelta)
		{
			Color color = default(Color);
			color.r = target.r - current.r;
			color.g = target.g - current.g;
			color.b = target.b - current.b;
			color.a = target.a - current.a;
			float num = Mathf.Sqrt(color.r * color.r + color.g * color.g + color.b * color.b + color.a * color.a);
			if (!(num <= maxDistanceDelta) && num != 0f)
			{
				return current + color / num * maxDistanceDelta;
			}
			return target;
		}

		public static bool FastEquality(Color lhs, Color rhs)
		{
			if (lhs.r == rhs.r && lhs.g == rhs.g && lhs.b == rhs.b)
			{
				return lhs.a == rhs.a;
			}
			return false;
		}
	}
	public static class GameObjectX
	{
		public static void SetHideFlagsRecursively(GameObject gameObj, HideFlags flag, bool includeSelf)
		{
			Transform transform = gameObj.transform;
			if (includeSelf)
			{
				gameObj.hideFlags = flag;
			}
			foreach (Transform item in transform)
			{
				item.gameObject.hideFlags = flag;
				SetHideFlagsRecursively(item.gameObject, flag, includeSelf: false);
			}
		}
	}
	public static class MathfX
	{
		public enum SineRemapEaseType
		{
			In,
			Out,
			InOut,
			None
		}

		public const float tau = (float)Math.PI * 2f;

		public const float radsPerDeg = (float)Math.PI / 180f;

		public const float epsilon = 1E-06f;

		public static float Modulus(float value, float modulus)
		{
			return value - modulus * Mathf.Floor(value / modulus);
		}

		public static float Percent(float min, float max, float value)
		{
			return (value - min) / (max - min);
		}

		public static bool CloseTo(this float source, float other, float maxDist)
		{
			return Mathf.Abs(source - other) < maxDist;
		}

		public static bool CheckPointInVolume(Vector3 localPos, Vector3 extents)
		{
			if (Mathf.Abs(localPos.x) > extents.x)
			{
				return false;
			}
			if (Mathf.Abs(localPos.y) > extents.y)
			{
				return false;
			}
			if (Mathf.Abs(localPos.z) > extents.z)
			{
				return false;
			}
			return true;
		}

		public static Vector3 ClosestPointLineSegment(Vector3 point, Vector3 start, Vector3 end)
		{
			Vector3 vector = end - start;
			float sqrMagnitude = vector.sqrMagnitude;
			if ((double)sqrMagnitude == 0.0)
			{
				return start;
			}
			float num = Vector3.Dot(point - start, vector) / sqrMagnitude;
			if (num < 0f)
			{
				return start;
			}
			if (num > 1f)
			{
				return end;
			}
			return start + vector * num;
		}

		public static Vector2 ClosestPointLineSegment2D(Vector2 point, Vector2 start, Vector2 end)
		{
			float num = end.x - start.x;
			float num2 = end.y - start.y;
			float num3 = num * num + num2 * num2;
			if (num3 == 0f)
			{
				return start;
			}
			float num4 = point.x - start.x;
			float num5 = point.y - start.y;
			float num6 = (num4 * num + num5 * num2) / num3;
			if (num6 < 0f)
			{
				return start;
			}
			if (num6 > 1f)
			{
				return end;
			}
			return new Vector2(start.x + num * num6, start.y + num2 * num6);
		}

		public static bool IntersectFrustumCube(Vector3 boxPos, Vector3 boxAxisX, Vector3 boxAxisY, Vector3 boxAxisZ, Vector3 boxExtents, Plane[] frustumPlanes)
		{
			for (int i = 0; i < 6; i++)
			{
				Plane plane = frustumPlanes[i];
				Vector3 normal = plane.normal;
				float distance = plane.distance;
				float num = Mathf.Sign(Vector3.Dot(boxAxisX, normal)) * (0f - boxExtents.x);
				float num2 = Mathf.Sign(Vector3.Dot(boxAxisY, normal)) * (0f - boxExtents.y);
				float num3 = Mathf.Sign(Vector3.Dot(boxAxisZ, normal)) * (0f - boxExtents.z);
				Vector3 vector = num * boxAxisX + num2 * boxAxisY + num3 * boxAxisZ;
				Vector3 lhs = boxPos - vector;
				_ = boxPos + vector;
				if (Vector3.Dot(lhs, normal) + distance < 0f)
				{
					return false;
				}
			}
			return true;
		}

		public static bool IntersectFrustumSphere(Vector3 spherePos, float sphereRadius, Plane[] frustumPlanes)
		{
			for (int i = 0; i < 6; i++)
			{
				Plane plane = frustumPlanes[i];
				Vector3 normal = plane.normal;
				float distance = plane.distance;
				if (Vector3.Dot(spherePos, normal) + distance < 0f - sphereRadius)
				{
					return false;
				}
			}
			return true;
		}

		public static bool IntersectSegmentRectangle(Vector2 seg0, Vector2 seg1, Vector2 rectMin, Vector2 rectMax)
		{
			float x = seg0.x;
			float y = seg0.y;
			float x2 = seg1.x;
			float y2 = seg1.y;
			Vector2 vector = new Vector2(rectMin.x, rectMin.y);
			Vector2 vector2 = new Vector2(rectMin.x, rectMax.y);
			Vector2 vector3 = new Vector2(rectMax.x, rectMin.y);
			Vector2 vector4 = new Vector2(rectMax.x, rectMax.y);
			int num = 0;
			num |= (((y2 - y) * vector.x + (x - x2) * vector.y + (x2 * y - x * y2) >= 0f) ? 1 : 0);
			num |= (int)((((y2 - y) * vector2.x + (x - x2) * vector2.y + (x2 * y - x * y2) >= 0f) ? 1u : 0u) << 1);
			num |= (int)((((y2 - y) * vector3.x + (x - x2) * vector3.y + (x2 * y - x * y2) >= 0f) ? 1u : 0u) << 2);
			num |= (int)((((y2 - y) * vector4.x + (x - x2) * vector4.y + (x2 * y - x * y2) >= 0f) ? 1u : 0u) << 3);
			if (num == 15 || num == 0)
			{
				return false;
			}
			if (x > rectMax.x && x2 > rectMax.x)
			{
				return false;
			}
			if (x < rectMin.x && x2 < rectMin.x)
			{
				return false;
			}
			if (y > rectMax.y && y2 > rectMax.y)
			{
				return false;
			}
			if (y < rectMin.y && y2 < rectMin.y)
			{
				return false;
			}
			return true;
		}

		public static float LinearRemapLerp(float value, float valueStart = 0f, float valueEnd = 1f, float resultStart = 0f, float resultEnd = 1f)
		{
			float num = valueEnd - valueStart;
			float num2 = resultEnd - resultStart;
			float num3 = (value - valueStart) / num;
			return resultStart + num3 * num2;
		}

		public static float SineRemapLerp(float value, SineRemapEaseType easeType = SineRemapEaseType.InOut, float valueStart = 0f, float valueEnd = 1f, float resultStart = 0f, float resultEnd = 1f)
		{
			float resultStart2;
			float resultEnd2;
			float valueStart2;
			float valueEnd2;
			switch (easeType)
			{
			case SineRemapEaseType.In:
				resultStart2 = 4.712389f;
				resultEnd2 = (float)Math.PI * 2f;
				valueStart2 = -1f;
				valueEnd2 = 0f;
				break;
			case SineRemapEaseType.Out:
				resultStart2 = 0f;
				resultEnd2 = (float)Math.PI / 2f;
				valueStart2 = 0f;
				valueEnd2 = 1f;
				break;
			case SineRemapEaseType.InOut:
				resultStart2 = 4.712389f;
				resultEnd2 = (float)Math.PI / 2f;
				valueStart2 = -1f;
				valueEnd2 = 1f;
				break;
			default:
				return LinearRemapLerp(value, valueStart, valueEnd, resultStart, resultEnd);
			}
			return LinearRemapLerp(Mathf.Sin(LinearRemapLerp(value, valueStart, valueEnd, resultStart2, resultEnd2)), valueStart2, valueEnd2, resultStart, resultEnd);
		}

		public static int Wrap(this int left, int right)
		{
			return (left % right + right) % right;
		}

		public static float Wrap(this float left, float right)
		{
			return (left % right + right) % right;
		}

		public static float Max(float a, float b, float c)
		{
			if (!(a <= b))
			{
				if (!(a <= c))
				{
					return a;
				}
				return c;
			}
			if (!(b <= c))
			{
				return b;
			}
			return c;
		}

		public static void CalculateFrustumPlanes(ref Matrix4x4 mat, Plane[] planes)
		{
			planes[0].normal = new Vector3(mat.m30 + mat.m00, mat.m31 + mat.m01, mat.m32 + mat.m02);
			planes[0].distance = mat.m33 + mat.m03;
			planes[1].normal = new Vector3(mat.m30 - mat.m00, mat.m31 - mat.m01, mat.m32 - mat.m02);
			planes[1].distance = mat.m33 - mat.m03;
			planes[2].normal = new Vector3(mat.m30 + mat.m10, mat.m31 + mat.m11, mat.m32 + mat.m12);
			planes[2].distance = mat.m33 + mat.m13;
			planes[3].normal = new Vector3(mat.m30 - mat.m10, mat.m31 - mat.m11, mat.m32 - mat.m12);
			planes[3].distance = mat.m33 - mat.m13;
			planes[4].normal = new Vector3(mat.m30 + mat.m20, mat.m31 + mat.m21, mat.m32 + mat.m22);
			planes[4].distance = mat.m33 + mat.m23;
			planes[5].normal = new Vector3(mat.m30 - mat.m20, mat.m31 - mat.m21, mat.m32 - mat.m22);
			planes[5].distance = mat.m33 - mat.m23;
			for (uint num = 0u; num < 6; num++)
			{
				float magnitude = planes[num].normal.magnitude;
				planes[num].normal /= magnitude;
				planes[num].distance /= magnitude;
			}
		}

		public static Quaternion LockedAxisBillboard(Vector3 position, Vector3 forward, Vector3 eye)
		{
			return Quaternion.LookRotation(forward, (eye - position).normalized);
		}

		public static float ForceAtEndsOfSpring(float springConst, float currentSpringDisplacement, float dampingCoefficient, float velocity)
		{
			return (0f - Mathf.Abs(springConst)) * currentSpringDisplacement - Mathf.Abs(dampingCoefficient) * velocity;
		}

		public static Vector3 ForceAtEndsOfSpring(float springConst, Vector3 currentSpringDisplacement, float dampingCoefficient, Vector3 velocity)
		{
			return (0f - Mathf.Abs(springConst)) * currentSpringDisplacement - Mathf.Abs(dampingCoefficient) * velocity;
		}

		public static Vector2 ForceAtEndsOfSpring(float springConst, Vector2 currentSpringDisplacement, float dampingCoefficient, Vector2 velocity)
		{
			return (0f - Mathf.Abs(springConst)) * currentSpringDisplacement - Mathf.Abs(dampingCoefficient) * velocity;
		}

		public static Bounds GetWorldBounds(this GameObject go)
		{
			Bounds result = ((go.GetComponent<Renderer>() == null) ? new Bounds(go.transform.position, Vector3.zero) : go.GetComponent<Renderer>().bounds);
			foreach (Transform item in go.transform)
			{
				result.Encapsulate(item.gameObject.GetWorldBounds());
			}
			return result;
		}

		public static Vector3 CatmullRom(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
		{
			return 0.5f * (2f * p1 + (p2 - p0) * t + (2f * p0 - 5f * p1 + 4f * p2 - p3) * t * t + (3f * p1 - p0 - 3f * p2 + p3) * t * t * t);
		}

		public static Vector3 Cubic(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t, float tension)
		{
			float num = t * t;
			float w = num * t;
			return _CubicEvaluate(p0, p1, p2, p3, new Vector4(1f, t, num, w), tension);
		}

		public static Vector3 CubicDeravative(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t, float tension)
		{
			float num = t * t;
			return _CubicEvaluate(p0, p1, p2, p3, new Vector4(0f, 1f, 2f * t, 3f * num), tension);
		}

		public static Vector3 _CubicEvaluate(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, Vector4 coef, float tension)
		{
			float num = 0f - tension;
			float num2 = 2f * tension;
			float num3 = tension - 3f;
			float num4 = 3f - 2f * tension;
			float num5 = 0f - tension;
			float num6 = 0f - tension;
			float num7 = 2f - tension;
			float num8 = tension - 2f;
			float x = p1.x;
			float num9 = num * p0.x + tension * p2.x;
			float num10 = num2 * p0.x + num3 * p1.x + num4 * p2.x + num5 * p3.x;
			float num11 = num6 * p0.x + num7 * p1.x + num8 * p2.x + tension * p3.x;
			float y = p1.y;
			float num12 = num * p0.y + tension * p2.y;
			float num13 = num2 * p0.y + num3 * p1.y + num4 * p2.y + num5 * p3.y;
			float num14 = num6 * p0.y + num7 * p1.y + num8 * p2.y + tension * p3.y;
			float z = p1.z;
			float num15 = num * p0.z + tension * p2.z;
			float num16 = num2 * p0.z + num3 * p1.z + num4 * p2.z + num5 * p3.z;
			float num17 = num6 * p0.z + num7 * p1.z + num8 * p2.z + tension * p3.z;
			float x2 = coef.x * x + coef.y * num9 + coef.z * num10 + coef.w * num11;
			float y2 = coef.x * y + coef.y * num12 + coef.z * num13 + coef.w * num14;
			float z2 = coef.x * z + coef.y * num15 + coef.z * num16 + coef.w * num17;
			return new Vector3(x2, y2, z2);
		}

		public static float Step(float edge, float x)
		{
			return (!(x < edge)) ? 1 : 0;
		}

		public static float EaseInCurve(float t)
		{
			return 1f - Mathf.Sin((Mathf.Clamp01(t) + 1f) * (float)Math.PI * 0.5f);
		}

		public static float EaseOutCurve(float t)
		{
			return Mathf.Sin(Mathf.Clamp01(t) * (float)Math.PI * 0.5f);
		}

		public static float EaseInOutCurve(float t)
		{
			return Mathf.Sin(Mathf.Clamp01(t) * (float)Math.PI + 4.712389f) * 0.5f + 0.5f;
		}

		public static Vector3 MoveTowardsClamped(Vector3 current, Vector3 target, float maxDistanceDelta, float maxMagnitude)
		{
			Vector3 vector = target - current;
			float magnitude = vector.magnitude;
			if (magnitude <= maxDistanceDelta || magnitude == 0f)
			{
				return target;
			}
			if (magnitude > maxMagnitude)
			{
				Vector3 vector2 = Vector3.ClampMagnitude(vector, maxMagnitude);
				Vector3 vector3 = vector - vector2;
				current += vector3;
			}
			return current + vector / magnitude * maxDistanceDelta;
		}

		public static float BounceCurve(float t)
		{
			if (t >= 1f)
			{
				return 1f;
			}
			if (t <= 0f)
			{
				return 0f;
			}
			return 0.6f + Mathf.Sin(Mathf.Clamp01(t) * (float)Math.PI * 1.25f - 1.5142477f) * 0.6f;
		}

		public static float Bezier(float[] p, float t)
		{
			if (p.Length == 3)
			{
				return Mathf.Lerp(p[0], p[1], t);
			}
			if (p.Length < 2)
			{
				UnityEngine.Debug.LogError("WARNING: A class attempted to get a Bezier Curve with less than two points!");
				return 0f;
			}
			float num = p.Length - 2;
			float num2 = p.Length - 1;
			float num3 = Mathf.Pow(1f - t, num2) * p[0];
			for (int i = 1; (float)i < num2; i++)
			{
				num3 += num2 * Mathf.Pow(1f - t, num - (float)(i - 1)) * Mathf.Pow(t, i) * p[i];
			}
			return num3 + Mathf.Pow(t, num2) * p[p.Length - 1];
		}

		public static T GetClosestObject<T>(T[] objArray, Vector3 worldPosition, int start = 0, int length = -1, bool requiredActive = false) where T : UnityEngine.Component
		{
			if (length == -1)
			{
				length = objArray.Length;
			}
			float num = float.MaxValue;
			T result = null;
			int num2 = start + length;
			for (int i = start; i < num2; i++)
			{
				if (!requiredActive || objArray[i].gameObject.activeInHierarchy)
				{
					float sqrMagnitude = (objArray[i].transform.position - worldPosition).sqrMagnitude;
					if (sqrMagnitude < num)
					{
						num = sqrMagnitude;
						result = objArray[i];
					}
				}
			}
			return result;
		}

		public static T GetClosestObject<T>(ConstArray<T> objArray, Vector3 worldPosition, int start = 0, int length = -1, bool requiredActive = false) where T : UnityEngine.Component
		{
			if (length == -1)
			{
				length = (int)objArray.Length;
			}
			return GetClosestObject(objArray._data, worldPosition, start, length, requiredActive);
		}

		public static T GetClosestMonoBehaviour<T>(T[] objArray, Vector3 worldPosition, int start = 0, int length = -1, bool requiredActiveAndEnabled = false) where T : MonoBehaviour
		{
			if (length == -1)
			{
				length = objArray.Length;
			}
			float num = float.MaxValue;
			T result = null;
			int num2 = start + length;
			for (int i = start; i < num2; i++)
			{
				if (!requiredActiveAndEnabled || objArray[i].isActiveAndEnabled)
				{
					float sqrMagnitude = (objArray[i].transform.position - worldPosition).sqrMagnitude;
					if (sqrMagnitude < num)
					{
						num = sqrMagnitude;
						result = objArray[i];
					}
				}
			}
			return result;
		}

		public static T GetClosestMonoBehaviour<T>(ConstArray<T> objArray, Vector3 worldPosition, int start = 0, int length = -1, bool requiredActiveAndEnabled = false) where T : MonoBehaviour
		{
			if (length == -1)
			{
				length = (int)objArray.Length;
			}
			return GetClosestMonoBehaviour(objArray._data, worldPosition, start, length, requiredActiveAndEnabled);
		}

		public static T GetClosestCollider<T>(T[] objArray, Vector3 worldPosition, int start = 0, int length = -1, bool requiredActiveAndEnabled = false) where T : Collider
		{
			if (length == -1)
			{
				length = objArray.Length;
			}
			float num = float.MaxValue;
			T result = null;
			int num2 = start + length;
			for (int i = start; i < num2; i++)
			{
				if (!requiredActiveAndEnabled || (objArray[i].gameObject.activeInHierarchy && objArray[i].enabled))
				{
					float sqrMagnitude = (objArray[i].transform.position - worldPosition).sqrMagnitude;
					if (sqrMagnitude < num)
					{
						num = sqrMagnitude;
						result = objArray[i];
					}
				}
			}
			return result;
		}

		public static T GetClosestCollider<T>(ConstArray<T> objArray, Vector3 worldPosition, int start = 0, int length = -1, bool requiredActiveAndEnabled = false) where T : Collider
		{
			if (length == -1)
			{
				length = (int)objArray.Length;
			}
			return GetClosestCollider(objArray._data, worldPosition, start, length, requiredActiveAndEnabled);
		}

		public static bool EqualAbs(float a, float b, float epsilon = 1E-06f)
		{
			return Mathf.Abs(a - b) < epsilon;
		}

		public static bool IntersectRayTriangle(Ray ray, Vector3 triVert1, Vector3 triVert2, Vector3 triVert3, out Vector3 barycentricCoord, out float distance)
		{
			barycentricCoord = Vector3.zero;
			distance = 0f;
			Vector3 vector = triVert2 - triVert1;
			Vector3 vector2 = triVert3 - triVert1;
			Vector3 rhs = Vector3.Cross(ray.direction, vector2);
			float num = Vector3.Dot(vector, rhs);
			if (EqualAbs(num, 0f))
			{
				return false;
			}
			float num2 = 1f / num;
			Vector3 lhs = ray.origin - triVert1;
			barycentricCoord.x = num2 * Vector3.Dot(lhs, rhs);
			if (barycentricCoord.x < 0f)
			{
				return false;
			}
			if (barycentricCoord.x > 1f)
			{
				return false;
			}
			Vector3 rhs2 = Vector3.Cross(lhs, vector);
			barycentricCoord.y = num2 * Vector3.Dot(ray.direction, rhs2);
			if (barycentricCoord.y < 0f)
			{
				return false;
			}
			if ((double)(barycentricCoord.y + barycentricCoord.x) > 1.0)
			{
				return false;
			}
			distance = num2 * Vector3.Dot(vector2, rhs2);
			if (distance < 0f)
			{
				return false;
			}
			barycentricCoord.z = 1f - barycentricCoord.x - barycentricCoord.y;
			return true;
		}

		public static bool IntersectRayAABB(Ray ray, Bounds aabb, float min = float.MinValue, float max = float.MaxValue)
		{
			Vector3 min2 = aabb.min;
			Vector3 max2 = aabb.max;
			for (int i = 0; i < 3; i++)
			{
				if (EqualAbs(ray.direction[i], 0f) && (ray.origin[i] < min2[i] || ray.origin[i] > max2[i]))
				{
					return false;
				}
				float num = 1f / ray.direction[i];
				float num2 = (min2[i] - ray.origin[i]) * num;
				float num3 = (max2[i] - ray.origin[i]) * num;
				if (num2 > num3)
				{
					float num4 = num2;
					num2 = num3;
					num3 = num4;
				}
				if (num2 > min)
				{
					min = num2;
				}
				if (num3 < max)
				{
					max = num3;
				}
				if (min > max)
				{
					return false;
				}
				if (max < 0f)
				{
					return false;
				}
			}
			return true;
		}

		public static float Min(float a, float b, float c)
		{
			if (a < b && a < c)
			{
				return a;
			}
			if (b < c)
			{
				return b;
			}
			return c;
		}

		public static float Min(float a, float b, float c, float d)
		{
			if (a < b && a < c && a < d)
			{
				return a;
			}
			if (b < c && b < d)
			{
				return b;
			}
			if (c < d)
			{
				return c;
			}
			return d;
		}

		public static float Min(float a, float b, float c, float d, float e)
		{
			if (a < b && a < c && a < d && a < e)
			{
				return a;
			}
			if (b < c && b < d && b < e)
			{
				return b;
			}
			if (c < d && c < e)
			{
				return c;
			}
			if (d < e)
			{
				return d;
			}
			return e;
		}
	}
	public static class QuaternionX
	{
		public static readonly Quaternion identity = Quaternion.identity;

		public static Quaternion Multiply(Quaternion q, float f)
		{
			q.x *= f;
			q.y *= f;
			q.z *= f;
			q.w *= f;
			return q;
		}

		public static Quaternion Add(Quaternion q0, Quaternion q1)
		{
			q0.x += q1.x;
			q0.y += q1.y;
			q0.z += q1.z;
			q0.w += q1.w;
			return q0;
		}

		public static Quaternion Subtract(Quaternion q0, Quaternion q1)
		{
			q0.x -= q1.x;
			q0.y -= q1.y;
			q0.z -= q1.z;
			q0.w -= q1.w;
			return q0;
		}

		public static Quaternion Normalize(Quaternion q0)
		{
			float f = q0.x * q0.x + q0.y * q0.y + q0.z * q0.z + q0.w * q0.w;
			float num = 1f / Mathf.Sqrt(f);
			q0.x *= num;
			q0.y *= num;
			q0.z *= num;
			q0.w *= num;
			return q0;
		}

		public static Quaternion Reflect(Quaternion quaternion, bool flipX, bool flipY, bool flipZ)
		{
			if (flipX)
			{
				quaternion.y = 0f - quaternion.y;
				quaternion.z = 0f - quaternion.z;
			}
			if (flipY)
			{
				quaternion.x = 0f - quaternion.x;
				quaternion.z = 0f - quaternion.z;
			}
			if (flipZ)
			{
				quaternion.x = 0f - quaternion.x;
				quaternion.y = 0f - quaternion.y;
			}
			return quaternion;
		}

		public static Quaternion InverseTransformRotation(this Quaternion rotation, Quaternion worldRotation)
		{
			return Quaternion.Inverse(rotation) * worldRotation;
		}

		public static Quaternion TransformRotation(this Quaternion rotation, Quaternion localRotation)
		{
			return rotation * localRotation;
		}

		public static void GetAxes(this Quaternion rot, out Vector3 right, out Vector3 up, out Vector3 fowrard)
		{
			float num = rot.x * 2f;
			float num2 = rot.y * 2f;
			float num3 = rot.z * 2f;
			float num4 = rot.x * num;
			float num5 = rot.y * num2;
			float num6 = rot.z * num3;
			float num7 = rot.x * num2;
			float num8 = rot.x * num3;
			float num9 = rot.y * num3;
			float num10 = rot.w * num;
			float num11 = rot.w * num2;
			float num12 = rot.w * num3;
			right.x = 1f - (num5 + num6);
			right.y = num7 + num12;
			right.z = num8 - num11;
			up.x = num7 - num12;
			up.y = 1f - (num4 + num6);
			up.z = num9 + num10;
			fowrard.x = num8 + num11;
			fowrard.y = num9 - num10;
			fowrard.z = 1f - (num4 + num5);
		}
	}
	public static class Matrix4x4X
	{
		public static Vector3 MultiplyPointProjection(Vector3 point, ref Matrix4x4 matrix)
		{
			Vector4 vector = point;
			vector.w = 1f;
			vector = matrix * vector;
			point.x = vector.x / vector.w;
			point.y = vector.y / vector.w;
			point.z = vector.z / vector.w;
			return point;
		}

		public static Matrix4x4 Add(Matrix4x4 lhs, Matrix4x4 rhs)
		{
			lhs.m00 += rhs.m00;
			lhs.m01 += rhs.m01;
			lhs.m02 += rhs.m02;
			lhs.m03 += rhs.m03;
			lhs.m10 += rhs.m10;
			lhs.m11 += rhs.m11;
			lhs.m12 += rhs.m12;
			lhs.m13 += rhs.m13;
			lhs.m20 += rhs.m20;
			lhs.m21 += rhs.m21;
			lhs.m22 += rhs.m22;
			lhs.m23 += rhs.m23;
			lhs.m30 += rhs.m30;
			lhs.m31 += rhs.m31;
			lhs.m32 += rhs.m32;
			lhs.m33 += rhs.m33;
			return lhs;
		}

		public static void Multiply(ref Matrix4x4 lhs, ref Matrix4x4 rhs, out Matrix4x4 result)
		{
			result.m00 = lhs.m00 * rhs.m00 + lhs.m01 * rhs.m10 + lhs.m02 * rhs.m20 + lhs.m03 * rhs.m30;
			result.m01 = lhs.m00 * rhs.m01 + lhs.m01 * rhs.m11 + lhs.m02 * rhs.m21 + lhs.m03 * rhs.m31;
			result.m02 = lhs.m00 * rhs.m02 + lhs.m01 * rhs.m12 + lhs.m02 * rhs.m22 + lhs.m03 * rhs.m32;
			result.m03 = lhs.m00 * rhs.m03 + lhs.m01 * rhs.m13 + lhs.m02 * rhs.m23 + lhs.m03 * rhs.m33;
			result.m10 = lhs.m10 * rhs.m00 + lhs.m11 * rhs.m10 + lhs.m12 * rhs.m20 + lhs.m13 * rhs.m30;
			result.m11 = lhs.m10 * rhs.m01 + lhs.m11 * rhs.m11 + lhs.m12 * rhs.m21 + lhs.m13 * rhs.m31;
			result.m12 = lhs.m10 * rhs.m02 + lhs.m11 * rhs.m12 + lhs.m12 * rhs.m22 + lhs.m13 * rhs.m32;
			result.m13 = lhs.m10 * rhs.m03 + lhs.m11 * rhs.m13 + lhs.m12 * rhs.m23 + lhs.m13 * rhs.m33;
			result.m20 = lhs.m20 * rhs.m00 + lhs.m21 * rhs.m10 + lhs.m22 * rhs.m20 + lhs.m23 * rhs.m30;
			result.m21 = lhs.m20 * rhs.m01 + lhs.m21 * rhs.m11 + lhs.m22 * rhs.m21 + lhs.m23 * rhs.m31;
			result.m22 = lhs.m20 * rhs.m02 + lhs.m21 * rhs.m12 + lhs.m22 * rhs.m22 + lhs.m23 * rhs.m32;
			result.m23 = lhs.m20 * rhs.m03 + lhs.m21 * rhs.m13 + lhs.m22 * rhs.m23 + lhs.m23 * rhs.m33;
			result.m30 = lhs.m30 * rhs.m00 + lhs.m31 * rhs.m10 + lhs.m32 * rhs.m20 + lhs.m33 * rhs.m30;
			result.m31 = lhs.m30 * rhs.m01 + lhs.m31 * rhs.m11 + lhs.m32 * rhs.m21 + lhs.m33 * rhs.m31;
			result.m32 = lhs.m30 * rhs.m02 + lhs.m31 * rhs.m12 + lhs.m32 * rhs.m22 + lhs.m33 * rhs.m32;
			result.m33 = lhs.m30 * rhs.m03 + lhs.m31 * rhs.m13 + lhs.m32 * rhs.m23 + lhs.m33 * rhs.m33;
		}

		public static void TranslateScale(float tx, float ty, float tz, float sx, float sy, float sz, out Matrix4x4 m)
		{
			m.m00 = sx;
			m.m01 = 0f;
			m.m02 = 0f;
			m.m03 = tx;
			m.m10 = 0f;
			m.m11 = sy;
			m.m12 = 0f;
			m.m13 = ty;
			m.m20 = 0f;
			m.m21 = 0f;
			m.m22 = sz;
			m.m23 = tz;
			m.m30 = 0f;
			m.m31 = 0f;
			m.m32 = 0f;
			m.m33 = 1f;
		}

		public static void TransformBounds(ref Matrix4x4 m, Vector3 center, Vector3 extents, out Vector3 tCenter, out Vector3 tExtents)
		{
			Vector3 vector = default(Vector3);
			vector.x = center.x - extents.x;
			vector.y = center.y - extents.y;
			vector.z = center.z - extents.z;
			Vector3 vector2 = default(Vector3);
			vector2.x = center.x + extents.x;
			vector2.y = center.y + extents.y;
			vector2.z = center.z + extents.z;
			Vector4 vector3 = default(Vector4);
			vector3.x = m.m00 * vector2.x;
			vector3.y = m.m10 * vector2.x;
			vector3.z = m.m20 * vector2.x;
			vector3.w = m.m30 * vector2.x;
			Vector4 vector4 = default(Vector4);
			vector4.x = m.m01 * vector2.y;
			vector4.y = m.m11 * vector2.y;
			vector4.z = m.m21 * vector2.y;
			vector4.w = m.m31 * vector2.y;
			Vector4 vector5 = default(Vector4);
			vector5.x = m.m02 * vector2.z;
			vector5.y = m.m12 * vector2.z;
			vector5.z = m.m22 * vector2.z;
			vector5.w = m.m32 * vector2.z;
			Vector4 vector6 = default(Vector4);
			vector6.x = m.m00 * vector.x;
			vector6.y = m.m10 * vector.x;
			vector6.z = m.m20 * vector.x;
			vector6.w = m.m30 * vector.x;
			Vector4 vector7 = default(Vector4);
			vector7.x = m.m01 * vector.y;
			vector7.y = m.m11 * vector.y;
			vector7.z = m.m21 * vector.y;
			vector7.w = m.m31 * vector.y;
			Vector4 vector8 = default(Vector4);
			vector8.x = m.m02 * vector.z;
			vector8.y = m.m12 * vector.z;
			vector8.z = m.m22 * vector.z;
			vector8.w = m.m32 * vector.z;
			float num = 1f / (vector3.w + vector4.w + vector5.w + m.m33);
			Vector3 vector9 = default(Vector3);
			vector9.x = num * (vector3.x + vector4.x + vector5.x + m.m03);
			vector9.y = num * (vector3.y + vector4.y + vector5.y + m.m13);
			vector9.z = num * (vector3.z + vector4.z + vector5.z + m.m23);
			vector = vector9;
			vector2 = vector9;
			num = 1f / (vector3.w + vector7.w + vector5.w + m.m33);
			vector9.x = num * (vector3.x + vector7.x + vector5.x + m.m03);
			vector9.y = num * (vector3.y + vector7.y + vector5.y + m.m13);
			vector9.z = num * (vector3.z + vector7.z + vector5.z + m.m23);
			if (vector9.x < vector.x)
			{
				vector.x = vector9.x;
			}
			else if (vector9.x > vector2.x)
			{
				vector2.x = vector9.x;
			}
			if (vector9.y < vector.y)
			{
				vector.y = vector9.y;
			}
			else if (vector9.y > vector2.y)
			{
				vector2.y = vector9.y;
			}
			if (vector9.z < vector.z)
			{
				vector.z = vector9.z;
			}
			else if (vector9.z > vector2.z)
			{
				vector2.z = vector9.z;
			}
			num = 1f / (vector6.w + vector4.w + vector5.w + m.m33);
			vector9.x = num * (vector6.x + vector4.x + vector5.x + m.m03);
			vector9.y = num * (vector6.y + vector4.y + vector5.y + m.m13);
			vector9.z = num * (vector6.z + vector4.z + vector5.z + m.m23);
			if (vector9.x < vector.x)
			{
				vector.x = vector9.x;
			}
			else if (vector9.x > vector2.x)
			{
				vector2.x = vector9.x;
			}
			if (vector9.y < vector.y)
			{
				vector.y = vector9.y;
			}
			else if (vector9.y > vector2.y)
			{
				vector2.y = vector9.y;
			}
			if (vector9.z < vector.z)
			{
				vector.z = vector9.z;
			}
			else if (vector9.z > vector2.z)
			{
				vector2.z = vector9.z;
			}
			num = 1f / (vector6.w + vector7.w + vector5.w + m.m33);
			vector9.x = num * (vector6.x + vector7.x + vector5.x + m.m03);
			vector9.y = num * (vector6.y + vector7.y + vector5.y + m.m13);
			vector9.z = num * (vector6.z + vector7.z + vector5.z + m.m23);
			if (vector9.x < vector.x)
			{
				vector.x = vector9.x;
			}
			else if (vector9.x > vector2.x)
			{
				vector2.x = vector9.x;
			}
			if (vector9.y < vector.y)
			{
				vector.y = vector9.y;
			}
			else if (vector9.y > vector2.y)
			{
				vector2.y = vector9.y;
			}
			if (vector9.z < vector.z)
			{
				vector.z = vector9.z;
			}
			else if (vector9.z > vector2.z)
			{
				vector2.z = vector9.z;
			}
			num = 1f / (vector3.w + vector4.w + vector8.w + m.m33);
			vector9.x = num * (vector3.x + vector4.x + vector8.x + m.m03);
			vector9.y = num * (vector3.y + vector4.y + vector8.y + m.m13);
			vector9.z = num * (vector3.z + vector4.z + vector8.z + m.m23);
			if (vector9.x < vector.x)
			{
				vector.x = vector9.x;
			}
			else if (vector9.x > vector2.x)
			{
				vector2.x = vector9.x;
			}
			if (vector9.y < vector.y)
			{
				vector.y = vector9.y;
			}
			else if (vector9.y > vector2.y)
			{
				vector2.y = vector9.y;
			}
			if (vector9.z < vector.z)
			{
				vector.z = vector9.z;
			}
			else if (vector9.z > vector2.z)
			{
				vector2.z = vector9.z;
			}
			num = 1f / (vector3.w + vector7.w + vector8.w + m.m33);
			vector9.x = num * (vector3.x + vector7.x + vector8.x + m.m03);
			vector9.y = num * (vector3.y + vector7.y + vector8.y + m.m13);
			vector9.z = num * (vector3.z + vector7.z + vector8.z + m.m23);
			if (vector9.x < vector.x)
			{
				vector.x = vector9.x;
			}
			else if (vector9.x > vector2.x)
			{
				vector2.x = vector9.x;
			}
			if (vector9.y < vector.y)
			{
				vector.y = vector9.y;
			}
			else if (vector9.y > vector2.y)
			{
				vector2.y = vector9.y;
			}
			if (vector9.z < vector.z)
			{
				vector.z = vector9.z;
			}
			else if (vector9.z > vector2.z)
			{
				vector2.z = vector9.z;
			}
			num = 1f / (vector6.w + vector4.w + vector8.w + m.m33);
			vector9.x = num * (vector6.x + vector4.x + vector8.x + m.m03);
			vector9.y = num * (vector6.y + vector4.y + vector8.y + m.m13);
			vector9.z = num * (vector6.z + vector4.z + vector8.z + m.m23);
			if (vector9.x < vector.x)
			{
				vector.x = vector9.x;
			}
			else if (vector9.x > vector2.x)
			{
				vector2.x = vector9.x;
			}
			if (vector9.y < vector.y)
			{
				vector.y = vector9.y;
			}
			else if (vector9.y > vector2.y)
			{
				vector2.y = vector9.y;
			}
			if (vector9.z < vector.z)
			{
				vector.z = vector9.z;
			}
			else if (vector9.z > vector2.z)
			{
				vector2.z = vector9.z;
			}
			num = 1f / (vector6.w + vector7.w + vector8.w + m.m33);
			vector9.x = num * (vector6.x + vector7.x + vector8.x + m.m03);
			vector9.y = num * (vector6.y + vector7.y + vector8.y + m.m13);
			vector9.z = num * (vector6.z + vector7.z + vector8.z + m.m23);
			if (vector9.x < vector.x)
			{
				vector.x = vector9.x;
			}
			else if (vector9.x > vector2.x)
			{
				vector2.x = vector9.x;
			}
			if (vector9.y < vector.y)
			{
				vector.y = vector9.y;
			}
			else if (vector9.y > vector2.y)
			{
				vector2.y = vector9.y;
			}
			if (vector9.z < vector.z)
			{
				vector.z = vector9.z;
			}
			else if (vector9.z > vector2.z)
			{
				vector2.z = vector9.z;
			}
			tExtents.x = (vector2.x - vector.x) * 0.5f;
			tExtents.y = (vector2.y - vector.y) * 0.5f;
			tExtents.z = (vector2.z - vector.z) * 0.5f;
			tCenter.x = vector.x + tExtents.x;
			tCenter.y = vector.y + tExtents.y;
			tCenter.z = vector.z + tExtents.z;
		}

		public static Vector3 ClampedPositionProjection(ref Matrix4x4 proj, Vector3 viewPos)
		{
			viewPos.z = ((viewPos.z >= -1E-07f) ? (-1E-07f) : viewPos.z);
			float num = 1f / (proj.m30 * viewPos.x + proj.m31 * viewPos.y + proj.m32 * viewPos.z + proj.m33);
			viewPos.x = num * (proj.m00 * viewPos.x + proj.m01 * viewPos.y + proj.m02 * viewPos.z + proj.m03);
			viewPos.y = num * (proj.m10 * viewPos.x + proj.m11 * viewPos.y + proj.m12 * viewPos.z + proj.m13);
			viewPos.z = num * (proj.m20 * viewPos.x + proj.m21 * viewPos.y + proj.m22 * viewPos.z + proj.m23);
			viewPos.x = ((viewPos.x > 1f) ? 1f : ((viewPos.x < -1f) ? (-1f) : viewPos.x));
			viewPos.y = ((viewPos.y > 1f) ? 1f : ((viewPos.y < -1f) ? (-1f) : viewPos.y));
			viewPos.z = ((viewPos.z > 1f) ? 1f : ((viewPos.z < -1f) ? (-1f) : viewPos.z));
			return viewPos;
		}

		public static Matrix4x4 CrossProductMatrix(Vector3 vector)
		{
			return new Matrix4x4(new Vector4(0f, 0f - vector.z, vector.y, 0f), new Vector4(vector.z, 0f, 0f - vector.x, 0f), new Vector4(0f - vector.y, vector.x, 0f, 0f), new Vector4(0f, 0f, 0f, 0f));
		}

		public static Vector2 MultiplyPoint2x4_XZPlane(this Matrix4x4 m, Vector2 point)
		{
			Vector2 result = default(Vector2);
			result.x = m.m00 * point.x + m.m02 * point.y + m.m03;
			result.y = m.m20 * point.x + m.m22 * point.y + m.m23;
			return result;
		}

		public static Vector2 MultiplyPoint2x4_XZPlane(ref Matrix4x4 m, Vector2 point)
		{
			Vector2 result = default(Vector2);
			result.x = m.m00 * point.x + m.m02 * point.y + m.m03;
			result.y = m.m20 * point.x + m.m22 * point.y + m.m23;
			return result;
		}

		public static Vector4 GetPositionFromViewMatrix(ref Matrix4x4 view)
		{
			Vector4 result = default(Vector4);
			result.x = 0f - (view.m00 * view.m03 + view.m10 * view.m13 + view.m20 * view.m23);
			result.y = 0f - (view.m01 * view.m03 + view.m11 * view.m13 + view.m21 * view.m23);
			result.z = 0f - (view.m02 * view.m03 + view.m12 * view.m13 + view.m22 * view.m23);
			result.w = 1f;
			return result;
		}

		public static Vector3 GetPositionFromViewMatrixV3(ref Matrix4x4 view)
		{
			Vector3 result = default(Vector3);
			result.x = 0f - (view.m00 * view.m03 + view.m10 * view.m13 + view.m20 * view.m23);
			result.y = 0f - (view.m01 * view.m03 + view.m11 * view.m13 + view.m21 * view.m23);
			result.z = 0f - (view.m02 * view.m03 + view.m12 * view.m13 + view.m22 * view.m23);
			return result;
		}

		public static Vector3 GetPosition(ref Matrix4x4 m)
		{
			return new Vector3(m.m03, m.m13, m.m23);
		}

		public static Vector3 GetAxisX(ref Matrix4x4 m)
		{
			return new Vector3(m.m00, m.m10, m.m20);
		}

		public static Vector3 GetAxisY(ref Matrix4x4 m)
		{
			return new Vector3(m.m01, m.m11, m.m21);
		}

		public static Vector3 GetAxisZ(ref Matrix4x4 m)
		{
			return new Vector3(m.m02, m.m12, m.m22);
		}

		public static void GetAxes(ref Matrix4x4 m, out Vector3 right, out Vector3 up, out Vector3 forward)
		{
			right.x = m.m00;
			right.y = m.m10;
			right.z = m.m20;
			up.x = m.m01;
			up.y = m.m11;
			up.z = m.m21;
			forward.x = m.m02;
			forward.y = m.m12;
			forward.z = m.m22;
		}
	}
	public struct Matrix2x2
	{
		public float m00;

		public float m01;

		public float m10;

		public float m11;

		public static readonly Matrix2x2 Identity = new Matrix2x2(1f, 0f, 0f, 1f);

		public Matrix2x2(float m00, float m01, float m10, float m11)
		{
			this.m00 = m00;
			this.m01 = m01;
			this.m10 = m10;
			this.m11 = m11;
		}

		public static Matrix2x2 Rotation(float angle)
		{
			float num = Mathf.Cos(angle);
			float num2 = Mathf.Sin(angle);
			return new Matrix2x2(num, 0f - num2, num2, num);
		}

		public static Matrix2x2 RotationFromVec2(Vector2 vec)
		{
			return new Matrix2x2(vec.x, 0f - vec.y, vec.y, vec.x);
		}

		public static float Mat22GetAngle(Matrix2x2 mat)
		{
			return Mathf.Atan2(mat.m01, mat.m00);
		}

		public static Matrix2x2 Mat22Inverse(Matrix2x2 mat)
		{
			float num = mat.m00 * mat.m11 - mat.m01 * mat.m10;
			if (num != 0f)
			{
				num = 1f / num;
			}
			return new Matrix2x2(num * mat.m11, (0f - num) * mat.m01, (0f - num) * mat.m10, num * mat.m00);
		}

		public static Vector2 operator *(Matrix2x2 mat, Vector2 vec)
		{
			return new Vector2(Vector2.Dot(new Vector2(mat.m00, mat.m01), vec), Vector2.Dot(new Vector2(mat.m10, mat.m11), vec));
		}
	}
	public enum OctDir
	{
		Up,
		UpRight,
		Right,
		DownRight,
		Down,
		DownLeft,
		Left,
		UpLeft
	}
	public static class OctDirX
	{
		public static float AngleCW(this OctDir to, OctDir from = OctDir.Up, float circumference = 360f)
		{
			return ((float)to - (float)from) * (circumference * 0.125f);
		}

		public static OctDir ToSimpleDir(this float angle, float up = 0f, float circumference = 360f)
		{
			return (OctDir)((Mathf.RoundToInt((angle - up) / (circumference / 8f)) % 8 + 8) % 8);
		}

		public static Vector3 ToV3XZ(this OctDir dir)
		{
			switch (dir)
			{
			case OctDir.Up:
			{
				Vector3 result = default(Vector3);
				result.x = 0f;
				result.z = 1f;
				return result;
			}
			case OctDir.UpRight:
			{
				Vector3 result = default(Vector3);
				result.x = 1f;
				result.z = 1f;
				return result;
			}
			case OctDir.Right:
			{
				Vector3 result = default(Vector3);
				result.x = 1f;
				result.z = 0f;
				return result;
			}
			case OctDir.DownRight:
			{
				Vector3 result = default(Vector3);
				result.x = 1f;
				result.z = -1f;
				return result;
			}
			case OctDir.Down:
			{
				Vector3 result = default(Vector3);
				result.x = 0f;
				result.z = -1f;
				return result;
			}
			case OctDir.DownLeft:
			{
				Vector3 result = default(Vector3);
				result.x = -1f;
				result.z = -1f;
				return result;
			}
			case OctDir.Left:
			{
				Vector3 result = default(Vector3);
				result.x = -1f;
				result.z = 0f;
				return result;
			}
			default:
			{
				Vector3 result = default(Vector3);
				result.x = -1f;
				result.z = 1f;
				return result;
			}
			}
		}

		public static v2i ToV2i(this OctDir dir)
		{
			switch (dir)
			{
			case OctDir.Up:
			{
				v2i result = default(v2i);
				result.x = 0;
				result.y = 1;
				return result;
			}
			case OctDir.UpRight:
			{
				v2i result = default(v2i);
				result.x = 1;
				result.y = 1;
				return result;
			}
			case OctDir.Right:
			{
				v2i result = default(v2i);
				result.x = 1;
				result.y = 0;
				return result;
			}
			case OctDir.DownRight:
			{
				v2i result = default(v2i);
				result.x = 1;
				result.y = -1;
				return result;
			}
			case OctDir.Down:
			{
				v2i result = default(v2i);
				result.x = 0;
				result.y = -1;
				return result;
			}
			case OctDir.DownLeft:
			{
				v2i result = default(v2i);
				result.x = -1;
				result.y = -1;
				return result;
			}
			case OctDir.Left:
			{
				v2i result = default(v2i);
				result.x = -1;
				result.y = 0;
				return result;
			}
			default:
			{
				v2i result = default(v2i);
				result.x = -1;
				result.y = 1;
				return result;
			}
			}
		}

		public static OctDir ToSimpleDirXZ(this Vector3 vect)
		{
			if (vect.x == 0f)
			{
				if (!(vect.z > 0f))
				{
					return OctDir.Down;
				}
				return OctDir.Up;
			}
			if (vect.z == 0f)
			{
				if (!(vect.x > 0f))
				{
					return OctDir.Left;
				}
				return OctDir.Right;
			}
			vect = vect.normalized;
			if (vect.z > 0.9238795f)
			{
				return OctDir.Up;
			}
			if (vect.z < -0.9238795f)
			{
				return OctDir.Down;
			}
			bool flag = vect.x > 0f;
			if (vect.z > 0.38268343f)
			{
				if (!flag)
				{
					return OctDir.UpLeft;
				}
				return OctDir.UpRight;
			}
			if (vect.z > -0.38268343f)
			{
				if (!flag)
				{
					return OctDir.Left;
				}
				return OctDir.Right;
			}
			if (!flag)
			{
				return OctDir.DownLeft;
			}
			return OctDir.DownRight;
		}

		public static OctDir Negative(this OctDir dir)
		{
			int num = (int)(dir + 4);
			if (num > 7)
			{
				num -= 8;
			}
			return (OctDir)num;
		}
	}
	public static class RandomX
	{
		public static bool randomBool => UnityEngine.Random.Range(0, 2) == 1;

		public static float RandomSignedRange(float min, float max)
		{
			float num = UnityEngine.Random.Range(min, max * 2f);
			if (!(num > max))
			{
				return num;
			}
			return num * -0.5f;
		}

		public static bool PercentChance(this int chance)
		{
			return UnityEngine.Random.Range(0, 100) <= chance;
		}

		public static bool PercentChance(this float chance)
		{
			return UnityEngine.Random.Range(float.Epsilon, 100f) <= chance;
		}

		public static float RandomSign(this float val)
		{
			if (!randomBool)
			{
				return 0f - val;
			}
			return val;
		}

		public static T RandomElement<T>(this T[] array)
		{
			return array[UnityEngine.Random.Range(0, array.Length)];
		}

		public static double NextDouble(this System.Random random, double min, double max)
		{
			return random.NextDouble() * (max - min) + min;
		}
	}
	public static class RectX
	{
		public static bool Overlaps(this Rect rect, IList<Rect> others)
		{
			for (int i = 0; i < others.Count; i++)
			{
				if (rect.Overlaps(others[i]))
				{
					return true;
				}
			}
			return false;
		}

		public static Rect TranslatedBy(this Rect rect, Vector2 centerDelta)
		{
			rect.center += centerDelta;
			return rect;
		}

		public static Rect RecenteredTo(this Rect rect, Vector2 newCenter)
		{
			rect.center = newCenter;
			return rect;
		}

		public static Rect RecenteredBy(this Rect rect, Vector2 offset)
		{
			rect.center += offset;
			return rect;
		}

		public static Rect LerpPosition(Rect start, Rect end, float t)
		{
			return LerpPosition(start, end.center, t);
		}

		public static Rect LerpPosition(Rect start, Vector2 endCenter, float t)
		{
			start.center = Vector2.Lerp(start.center, endCenter, t);
			return start;
		}

		public static Rect RectOfCenterAndSize(Vector2 position, Vector2 size)
		{
			Vector2 vector = position - size / 2f;
			return new Rect(vector.x, vector.y, size.x, size.y);
		}

		public static Rect RectOfSize(Vector2 size)
		{
			return new Rect(0f, 0f, size.x, size.y);
		}

		public static Vector2 XMinYMax(this Rect rect)
		{
			return new Vector2(rect.xMin, rect.yMax);
		}

		public static Vector2 XMaxYMin(this Rect rect)
		{
			return new Vector2(rect.xMax, rect.yMin);
		}

		public static Vector2 XMinYCtr(this Rect rect)
		{
			return new Vector2(rect.xMin, rect.center.y);
		}

		public static Vector2 XMaxYCtr(this Rect rect)
		{
			return new Vector2(rect.xMax, rect.center.y);
		}

		public static Vector2 XCtrYMin(this Rect rect)
		{
			return new Vector2(rect.center.x, rect.yMin);
		}

		public static Vector2 XCtrYMax(this Rect rect)
		{
			return new Vector2(rect.center.x, rect.yMax);
		}

		public static Vector2[] BorderPoints(this Rect rect)
		{
			return new Vector2[8]
			{
				rect.min,
				rect.XMinYCtr(),
				rect.XMinYMax(),
				rect.XCtrYMax(),
				rect.max,
				rect.XMaxYCtr(),
				rect.XMaxYMin(),
				rect.XCtrYMin()
			};
		}

		public static Vector2[] CornerPoints(this Rect rect)
		{
			return new Vector2[4]
			{
				rect.min,
				rect.XMaxYMin(),
				rect.max,
				rect.XMinYMax()
			};
		}

		public static Vector2[] CornerPoints(this Rect rect, Vector2[] outArr)
		{
			outArr[0] = rect.min;
			outArr[1] = rect.XMaxYMin();
			outArr[2] = rect.max;
			outArr[3] = rect.XMinYMax();
			return outArr;
		}

		public static Rect ExpandedFromCenterBy(this Rect rect, Vector2 expansion)
		{
			rect.yMin -= expansion.y * 0.5f;
			rect.yMax += expansion.y;
			rect.xMin -= expansion.x * 0.5f;
			rect.xMax += expansion.x;
			return rect;
		}

		public static bool Contain(this IList<Rect> rects, Vector2 vect)
		{
			int num = rects.Count;
			while (--num >= 0)
			{
				if (rects[num].Contains(vect))
				{
					return true;
				}
			}
			return false;
		}

		public static Rect SubtractBorder(this Rect rect, float x, float y)
		{
			rect.x += x;
			rect.y += y;
			rect.width -= x * 2f;
			rect.height -= y * 2f;
			return rect;
		}
	}
	public static class TransformX
	{
		public static Vector3 TransformPointUnscaled(this Transform transform, Vector3 localPosition)
		{
			return Matrix4x4.TRS(transform.position, transform.rotation, Vector3.one).MultiplyPoint3x4(localPosition);
		}

		public static Vector3 InverseTransformPointUnscaled(this Transform transform, Vector3 worldPosition)
		{
			return Matrix4x4.TRS(transform.position, transform.rotation, Vector3.one).inverse.MultiplyPoint3x4(worldPosition);
		}

		public static Quaternion TransformRotation(this Transform transform, Quaternion localRotation)
		{
			return transform.rotation * localRotation;
		}

		public static Quaternion InverseTransformRotation(this Transform transform, Quaternion worldRotation)
		{
			return Quaternion.Inverse(transform.rotation) * worldRotation;
		}

		public static Ray TransformRay(this Transform transform, Ray localRay)
		{
			return new Ray(transform.TransformPoint(localRay.origin), transform.TransformDirection(localRay.direction));
		}

		public static Ray TransformRay(this Transform transform, Vector3 localPosition, Vector3 localDirection)
		{
			Ray localRay = new Ray(localPosition, localDirection);
			return transform.TransformRay(localRay);
		}

		public static Ray InverseTransformRay(this Transform transform, Ray worldRay)
		{
			return new Ray(transform.InverseTransformPoint(worldRay.origin), transform.InverseTransformDirection(worldRay.direction));
		}

		public static Ray InverseTransformRay(this Transform transform, Vector3 worldPosition, Vector3 worldDirection)
		{
			Ray worldRay = new Ray(worldPosition, worldDirection);
			return transform.InverseTransformRay(worldRay);
		}
	}
	public static class Vector2X
	{
		public static readonly Vector2 one = new Vector2(1f, 1f);

		public static readonly Vector2 zero = new Vector2(0f, 0f);

		public static readonly Vector2 n_one = new Vector2(-1f, -1f);

		public static readonly Vector2 maxValue = new Vector2(float.MaxValue, float.MaxValue);

		public static readonly Vector2 positiveInfinity = new Vector2(float.PositiveInfinity, float.PositiveInfinity);

		public static readonly Vector2 right = new Vector2(1f, 0f);

		public static readonly Vector2 left = new Vector2(-1f, 0f);

		public static readonly Vector2 up = new Vector2(0f, 1f);

		public static readonly Vector2 down = new Vector2(0f, -1f);

		public static readonly Vector2 RU = new Vector2(1f, 1f);

		public static readonly Vector2 RD = new Vector2(1f, -1f);

		public static readonly Vector2 LU = new Vector2(-1f, 1f);

		public static readonly Vector2 LD = new Vector2(-1f, -1f);

		public static void Normalize(Vector2 vector, out Vector2 normalizedVector)
		{
			normalizedVector = vector;
			float magnitude = vector.magnitude;
			if (magnitude > 1E-05f)
			{
				normalizedVector.x /= magnitude;
				normalizedVector.y /= magnitude;
			}
			else
			{
				normalizedVector = zero;
			}
		}

		public static void Multiply(Vector2 vectorA, Vector2 vectorB, out Vector2 resultVector)
		{
			resultVector.x = vectorA.x * vectorB.x;
			resultVector.y = vectorA.y * vectorB.y;
		}

		public static void Multiply(Vector2 vectorA, float value, out Vector2 resultVector)
		{
			resultVector.x = vectorA.x * value;
			resultVector.y = vectorA.y * value;
		}

		public static void Subtract(Vector2 vectorA, Vector2 vectorB, out Vector2 resultVector)
		{
			resultVector.x = vectorA.x - vectorB.x;
			resultVector.y = vectorA.y - vectorB.y;
		}

		public static void Add(Vector2 vectorA, Vector2 vectorB, out Vector2 resultVector)
		{
			resultVector.x = vectorA.x + vectorB.x;
			resultVector.y = vectorA.y + vectorB.y;
		}
	}
	public static class Vector3X
	{
		public static readonly Vector3 one = new Vector3(1f, 1f, 1f);

		public static readonly Vector3 zero = new Vector3(0f, 0f, 0f);

		public static readonly Vector3 n_one = new Vector3(-1f, -1f, -1f);

		public static readonly Vector3 positiveInfinity = new Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity);

		public static readonly Vector3 negativeInfinity = new Vector3(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity);

		public static readonly Vector3 right = new Vector3(1f, 0f, 0f);

		public static readonly Vector3 left = new Vector3(-1f, 0f, 0f);

		public static readonly Vector3 up = new Vector3(0f, 1f, 0f);

		public static readonly Vector3 down = new Vector3(0f, -1f, 0f);

		public static readonly Vector3 forward = new Vector3(0f, 0f, 1f);

		public static readonly Vector3 backward = new Vector3(0f, 0f, -1f);

		public static readonly Vector3 RUF = new Vector3(1f, 1f, 1f);

		public static readonly Vector3 RDF = new Vector3(1f, -1f, 1f);

		public static readonly Vector3 LUF = new Vector3(-1f, 1f, 1f);

		public static readonly Vector3 LDF = new Vector3(-1f, -1f, 1f);

		public static readonly Vector3 RUB = new Vector3(1f, 1f, -1f);

		public static readonly Vector3 RDB = new Vector3(1f, -1f, -1f);

		public static readonly Vector3 LUB = new Vector3(-1f, 1f, -1f);

		public static readonly Vector3 LDB = new Vector3(-1f, -1f, -1f);

		public static void Normalize(Vector3 vector, out Vector3 normalizedVector)
		{
			normalizedVector = vector;
			float magnitude = vector.magnitude;
			if (magnitude > 1E-05f)
			{
				normalizedVector.x /= magnitude;
				normalizedVector.y /= magnitude;
				normalizedVector.z /= magnitude;
			}
			else
			{
				normalizedVector = zero;
			}
		}

		public static Vector3 RotatePointAroundPivot(Vector3 point, Vector3 pivot, float angle, Vector3 axis)
		{
			Quaternion rotation = Quaternion.AngleAxis(angle, axis);
			return RotatePointAroundPivot(point, pivot, rotation);
		}

		public static Vector3 RotatePointAroundPivot(Vector3 point, Vector3 pivot, Quaternion rotation)
		{
			Vector3 vector = point - pivot;
			vector = rotation * vector;
			return vector + pivot;
		}
	}
	public static class Vector4X
	{
		public static readonly Vector4 one = new Vector4(1f, 1f, 1f, 1f);

		public static readonly Vector4 zero = new Vector4(0f, 0f, 0f, 0f);

		public static readonly Vector4 n_one = new Vector4(-1f, -1f, -1f, -1f);

		public static readonly Vector4 right = new Vector4(1f, 0f, 0f, 0f);

		public static readonly Vector4 left = new Vector4(-1f, 0f, 0f, 0f);

		public static readonly Vector4 up = new Vector4(0f, 1f, 0f, 0f);

		public static readonly Vector4 down = new Vector4(0f, -1f, 0f, 0f);

		public static readonly Vector4 forward = new Vector4(0f, 0f, 1f, 0f);

		public static readonly Vector4 backward = new Vector4(0f, 0f, -1f, 0f);

		public static Vector4 Clamp(Vector4 v, Vector4 min, Vector4 max)
		{
			v.x = ((v.x < min.x) ? min.x : ((v.x > max.x) ? max.x : v.x));
			v.y = ((v.y < min.y) ? min.y : ((v.y > max.y) ? max.y : v.y));
			v.z = ((v.z < min.z) ? min.z : ((v.z > max.z) ? max.z : v.z));
			v.w = ((v.w < min.w) ? min.w : ((v.w > max.w) ? max.w : v.w));
			return v;
		}

		public static Vector4 PerspectiveDivide(this Vector4 v)
		{
			float num = 1f / v.w;
			v.x *= num;
			v.y *= num;
			v.z *= num;
			v.w = 1f;
			return v;
		}
	}
	public static class VectorX
	{
		public static float Min(Vector3 v)
		{
			return Mathf.Min(v.x, Mathf.Min(v.y, v.z));
		}

		public static float Max(Vector3 v)
		{
			return Mathf.Max(v.x, Mathf.Max(v.y, v.z));
		}

		public static float Min(Vector2 v)
		{
			return Mathf.Min(v.x, v.y);
		}

		public static float Max(Vector2 v)
		{
			return Mathf.Max(v.x, v.y);
		}

		public static Vector2 Min(Vector2 a, Vector2 b)
		{
			return new Vector2(Mathf.Min(a.x, b.x), Mathf.Min(a.y, b.y));
		}

		public static Vector2 Max(Vector2 a, Vector2 b)
		{
			return new Vector2(Mathf.Max(a.x, b.x), Mathf.Max(a.y, b.y));
		}

		public static Vector2 Cross(Vector2 v)
		{
			return new Vector2(v.y, 0f - v.x);
		}

		public static Vector3 Multiply(Vector3 a, Vector3 b)
		{
			return new Vector3(a.x * b.x, a.y * b.y, a.z * b.z);
		}

		public static void OrthoNormal(Vector3 foward, out Vector3 up, out Vector3 right)
		{
			if (Mathf.Abs(foward.x) < Mathf.Abs(foward.y) || Mathf.Abs(foward.x) < Mathf.Abs(foward.z))
			{
				up = Vector3.Cross(foward, new Vector3(1f, 0f, 0f));
			}
			else if (Mathf.Abs(foward.y) < Mathf.Abs(foward.z))
			{
				up = Vector3.Cross(foward, new Vector3(0f, 1f, 0f));
			}
			else
			{
				up = Vector3.Cross(foward, new Vector3(0f, 0f, 1f));
			}
			right = Vector3.Cross(foward, up);
		}

		public static Vector2? IntersectionWith(this Ray2D ray1, Ray2D ray2)
		{
			Vector2 origin = ray1.origin;
			Vector2 vector = origin + ray1.direction;
			float num = vector.y - origin.y;
			float num2 = origin.x - vector.x;
			float num3 = num * origin.x + num2 * origin.y;
			Vector2 origin2 = ray2.origin;
			Vector2 vector2 = origin2 + ray2.direction;
			float num4 = vector2.y - origin2.y;
			float num5 = origin2.x - vector2.x;
			float num6 = num4 * origin2.x + num5 * origin2.y;
			float num7 = num * num5 - num4 * num2;
			if (num7 == 0f)
			{
				return null;
			}
			num7 = 1f / num7;
			return new Vector2(num5 * num3 - num2 * num6, num * num6 - num4 * num3) * num7;
		}

		public static Vector3 V2ToV3(this Vector2 v2, float z)
		{
			return new Vector3(v2.x, v2.y, z);
		}

		public static Vector2 xz(this Vector3 v)
		{
			return new Vector2(v.x, v.z);
		}

		public static Vector2 xy(this Vector3 v)
		{
			return new Vector2(v.x, v.y);
		}

		public static Vector3 xNy(this Vector2 v, float n = 0f)
		{
			return new Vector3(v.x, n, v.y);
		}

		public static Vector3 xyz(this Vector4 v)
		{
			return new Vector3(v.x, v.y, v.z);
		}

		public static Vector4 V2ToV4(this Vector2 v2, float z, float w)
		{
			Vector4 result = default(Vector4);
			result.x = v2.x;
			result.y = v2.y;
			result.z = z;
			result.w = w;
			return result;
		}

		public static Vector4 V3ToV4(this Vector3 v3, float w)
		{
			Vector4 result = default(Vector4);
			result.x = v3.x;
			result.y = v3.y;
			result.z = v3.z;
			result.w = w;
			return result;
		}

		public static Vector3 RepX(this Vector3 vect, float newVal)
		{
			vect.x = newVal;
			return vect;
		}

		public static Vector3 RepY(this Vector3 vect, float newVal)
		{
			vect.y = newVal;
			return vect;
		}

		public static Vector3 RepZ(this Vector3 vect, float newVal)
		{
			vect.z = newVal;
			return vect;
		}

		public static Vector3 RepXY(this Vector3 vect, float newX, float newY)
		{
			vect.x = newX;
			vect.y = newY;
			return vect;
		}

		public static Vector3 RepXZ(this Vector3 vect, float newX, float newZ)
		{
			vect.x = newX;
			vect.z = newZ;
			return vect;
		}

		public static Vector3 RepYZ(this Vector3 vect, float newY, float newZ)
		{
			vect.y = newY;
			vect.z = newZ;
			return vect;
		}

		public static Vector3 ScaleX(this Vector3 vect, float scale)
		{
			vect.x *= scale;
			return vect;
		}

		public static Vector3 ScaleY(this Vector3 vect, float scale)
		{
			vect.y *= scale;
			return vect;
		}

		public static Vector3 ScaleZ(this Vector3 vect, float scale)
		{
			vect.z *= scale;
			return vect;
		}

		public static Vector3 ScaleXY(this Vector3 vect, float scaleX, float scaleY)
		{
			vect.x *= scaleX;
			vect.y *= scaleY;
			return vect;
		}

		public static Vector3 ScaleXZ(this Vector3 vect, float scaleX, float scaleZ)
		{
			vect.x *= scaleX;
			vect.z *= scaleZ;
			return vect;
		}

		public static Vector3 ScaleYZ(this Vector3 vect, float scaleY, float scaleZ)
		{
			vect.y *= scaleY;
			vect.z *= scaleZ;
			return vect;
		}

		public static Vector2 RepX(this Vector2 vect, float newVal)
		{
			vect.x = newVal;
			return vect;
		}

		public static Vector2 RepY(this Vector2 vect, float newVal)
		{
			vect.y = newVal;
			return vect;
		}

		public static Vector2 ScaleX(this Vector2 vect, float scale)
		{
			vect.x *= scale;
			return vect;
		}

		public static Vector2 ScaleY(this Vector2 vect, float scale)
		{
			vect.y *= scale;
			return vect;
		}

		public static Vector3Int RepX(this Vector3Int vect, int newVal)
		{
			vect.x = newVal;
			return vect;
		}

		public static Vector3Int RepY(this Vector3Int vect, int newVal)
		{
			vect.y = newVal;
			return vect;
		}

		public static Vector3Int RepZ(this Vector3Int vect, int newVal)
		{
			vect.z = newVal;
			return vect;
		}

		public static Vector2Int RepX(this Vector2Int vect, int newVal)
		{
			vect.x = newVal;
			return vect;
		}

		public static Vector2Int RepY(this Vector2Int vect, int newVal)
		{
			vect.y = newVal;
			return vect;
		}

		public static Vector3Int ToVector3Int(this Vector3 vect)
		{
			return new Vector3Int(Mathf.RoundToInt(vect.x), Mathf.RoundToInt(vect.y), Mathf.RoundToInt(vect.z));
		}

		public static Vector2Int ToVector2Int(this Vector2 vect)
		{
			return new Vector2Int(Mathf.RoundToInt(vect.x), Mathf.RoundToInt(vect.y));
		}

		public static Vector3 ClampedToMagnitude(this Vector3 vect, float magClamp)
		{
			float num = magClamp * magClamp;
			if (vect.sqrMagnitude > num)
			{
				return vect.normalized * magClamp;
			}
			return vect;
		}

		public static Vector2 ClampedToMagnitude(this Vector2 vect, float magClamp)
		{
			float num = magClamp * magClamp;
			if (vect.sqrMagnitude > num)
			{
				return vect.normalized * magClamp;
			}
			return vect;
		}

		public static Vector2 Rounded(this Vector2 vect)
		{
			vect.x = Mathf.Round(vect.x);
			vect.y = Mathf.Round(vect.y);
			return vect;
		}

		public static Vector2 ClosestTo(this IList<Vector2> vects, Vector2 target)
		{
			float num = float.PositiveInfinity;
			Vector2 result = Vector2.zero;
			for (int i = 0; i < vects.Count; i++)
			{
				float sqrMagnitude = (target - vects[i]).sqrMagnitude;
				if (sqrMagnitude < num)
				{
					result = vects[i];
					num = sqrMagnitude;
				}
			}
			return result;
		}

		public static bool IsCloseTo(this Vector2 vect, Vector2 other, float maxDist)
		{
			float num = maxDist * maxDist;
			return (vect - other).sqrMagnitude < num;
		}

		public static Vector3 V3LerpNoClamp(Vector3 from, Vector3 to, float t)
		{
			return new Vector3(from.x + (to.x - from.x) * t, from.y + (to.y - from.y) * t, from.z + (to.z - from.z) * t);
		}

		public static float V3InverseLerpUnclamped(Vector3 a, Vector3 b, Vector3 value)
		{
			Vector3 vector = b - a;
			return Vector3.Dot(value - a, vector) / Vector3.Dot(vector, vector);
		}

		public static Vector3 BezierCurve(Vector3[] p, float t)
		{
			if (p.Length == 2)
			{
				return Vector3.Lerp(p[0], p[1], t);
			}
			if (p.Length < 2)
			{
				UnityEngine.Debug.LogError("WARNING: A class attempted to get a Bezier Curve with less than two points!");
				return Vector3.zero;
			}
			float num = p.Length - 2;
			float num2 = p.Length - 1;
			Vector3 vector = Mathf.Pow(1f - t, num2) * p[0];
			for (int i = 1; (float)i < num2; i++)
			{
				vector += num2 * Mathf.Pow(1f - t, num - (float)(i - 1)) * Mathf.Pow(t, i) * p[i];
			}
			return vector + Mathf.Pow(t, num2) * p[p.Length - 1];
		}

		public static Vector3 BezierCurve(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
		{
			float num = 1f - t;
			Vector3 result = default(Vector3);
			result.x = num * num * num * p0.x;
			result.y = num * num * num * p0.y;
			result.z = num * num * num * p0.z;
			result.x += 3f * (num * num) * t * p1.x;
			result.y += 3f * (num * num) * t * p1.y;
			result.z += 3f * (num * num) * t * p1.z;
			result.x += 3f * num * (t * t) * p2.x;
			result.y += 3f * num * (t * t) * p2.y;
			result.z += 3f * num * (t * t) * p2.z;
			result.x += t * t * t * p3.x;
			result.y += t * t * t * p3.y;
			result.z += t * t * t * p3.z;
			return result;
		}

		public static Vector3 Reciprocal(this Vector3 vect)
		{
			vect.x = 1f / vect.x;
			vect.y = 1f / vect.y;
			vect.z = 1f / vect.z;
			return vect;
		}

		public static Vector3 Abs(this Vector3 vect)
		{
			vect.x = Mathf.Abs(vect.x);
			vect.y = Mathf.Abs(vect.y);
			vect.z = Mathf.Abs(vect.z);
			return vect;
		}

		public static bool Approximately(Vector3 lhs, Vector3 rhs)
		{
			if (Mathf.Approximately(lhs.x, rhs.x) && Mathf.Approximately(lhs.y, rhs.y))
			{
				return Mathf.Approximately(lhs.z, rhs.z);
			}
			return false;
		}
	}
	public static class SaveLoad
	{
		public delegate void ResultHandler(SaveLoadResult result);

		public struct DataHeader
		{
			public string title;

			public string subtitle;

			public string details;

			[NonSerialized]
			public Texture2D icon;

			[SerializeField]
			private byte[] _iconData;

			public byte[] iconData
			{
				get
				{
					return _iconData;
				}
				set
				{
					_iconData = value;
				}
			}

			public DataHeader(string title = null, string subtitle = null, string details = null, Texture2D icon = null)
			{
				this.title = title;
				this.subtitle = subtitle;
				this.details = details;
				this.icon = icon;
				_iconData = null;
			}

			public void EncodeIcon()
			{
				_iconData = ((icon != null) ? icon.EncodeToPNG() : null);
			}

			public void DecodeIcon()
			{
				if (_iconData == null)
				{
					icon = null;
					return;
				}
				icon = new Texture2D(0, 0);
				bool num = icon.LoadImage(_iconData);
				_iconData = null;
				if (num)
				{
					return;
				}
				throw new FormatException();
			}
		}

		public struct Metadata
		{
			public bool exists;

			public DataHeader header;

			public DateTime saveTime;
		}

		public class DispatchRunner : MonoBehaviour
		{
			private void Update()
			{
				RunDispatch();
			}
		}

		private struct RequestSave
		{
			public DataHeader header;

			public object dataObject;
		}

		private const int kMetadataSlot = -1;

		private static int retentions = 0;

		private static int slotQty;

		private static volatile ResultHandler handleResult = null;

		private static volatile Metadata[] metadata;

		private static volatile int slot = 0;

		private static volatile object dataObject;

		private static volatile bool silent;

		public static volatile byte[] streamBuffer;

		public static volatile Stream outStream;

		public static readonly string folderName = "Save Data";

		public static Func<bool> fakeMetadataFailureFunc;

		public static Func<bool> fakeSaveFailureFunc;

		public static Func<bool> fakeSaveSuccessFunc;

		public static Func<bool> fakeLoadFailureFunc;

		public static Func<bool> fakeMissingDataFunc;

		public static Func<bool> fakeDeleteFailureFunc;

		private static RequestSave requestSave;

		private static string bufferFileName = "_temp";

		private static string folderPath;

		private static string[] finalFilePaths;

		private static string[] writerFilePaths;

		private static Thread thread;

		private static AutoResetEvent signalToThread;

		private static AutoResetEvent signalToDispatchRoutine;

		private static volatile SaveLoadResult threadFlags;

		private static BinaryReader[] fileReaders;

		private static BinaryWriter[] fileWriters;

		public static bool initialised => retentions > 0;

		public static bool busy { get; private set; }

		public static bool fakeMetadataFailure
		{
			get
			{
				if (fakeMetadataFailureFunc != null)
				{
					return fakeMetadataFailureFunc();
				}
				return false;
			}
		}

		public static bool fakeSaveFailure
		{
			get
			{
				if (fakeSaveFailureFunc != null)
				{
					return fakeSaveFailureFunc();
				}
				return false;
			}
		}

		public static bool fakeSaveSuccess
		{
			get
			{
				if (fakeSaveSuccessFunc != null)
				{
					return fakeSaveSuccessFunc();
				}
				return false;
			}
		}

		public static bool fakeLoadFailure
		{
			get
			{
				if (fakeLoadFailureFunc != null)
				{
					return fakeLoadFailureFunc();
				}
				return false;
			}
		}

		public static bool fakeMissingData
		{
			get
			{
				if (fakeMissingDataFunc != null)
				{
					return fakeMissingDataFunc();
				}
				return false;
			}
		}

		public static bool fakeDeleteFailure
		{
			get
			{
				if (fakeDeleteFailureFunc != null)
				{
					return fakeDeleteFailureFunc();
				}
				return false;
			}
		}

		public static SaveLoadResult Retain(int slotQty = 1, ResultHandler handleResultIn = null, bool unthreaded = false, Scene? updaterScene = null, bool silent = false, bool log = false, string basePath = null)
		{
			if (slotQty < 1 || slotQty > 10)
			{
				throw new ArgumentOutOfRangeException("slotQtyIn");
			}
			if (retentions++ > 0 || busy)
			{
				return Dispatch(SaveLoadResult.Init | SaveLoadResult.Success, handleResultIn);
			}
			try
			{
				Serializer.Retain(silent);
				SubInit(slotQty, basePath, updaterScene);
				SaveLoad.slotQty = slotQty;
				streamBuffer = new byte[4096];
				if (!silent)
				{
					UnityEngine.Debug.Log("SaveLoad initialised.");
				}
				if (fakeMetadataFailure)
				{
					Release();
					return Dispatch(SaveLoadResult.Init | SaveLoadResult.Metadata | SaveLoadResult.Failure | SaveLoadResult.Subsystem, handleResultIn);
				}
				return SubInitMetadata(handleResultIn, unthreaded, silent);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
				Release(silent);
				return Dispatch(SaveLoadResult.Init | SaveLoadResult.Metadata | SaveLoadResult.Failure | SaveLoadResult.Subsystem, handleResultIn);
			}
		}

		public static void Release(bool silent = false)
		{
			if (retentions == 0)
			{
				UnityEngine.Debug.LogError("SaveLoad over-released!");
			}
			else if (--retentions <= 0)
			{
				metadata = null;
				SubRelease();
				Serializer.Release(silent);
				slotQty = 0;
				streamBuffer = null;
				busy = false;
				if (!silent)
				{
					UnityEngine.Debug.Log("SaveLoad cleaned up.");
				}
			}
		}

		public static void ResetMetadata()
		{
			ValidateUsage();
			metadata = new Metadata[slotQty];
		}

		public static bool GetMetadata(ref Metadata metadataOut, int slot = 0)
		{
			ValidateUsage(slot);
			if (metadata == null)
			{
				return false;
			}
			if (!metadata[slot].exists)
			{
				return false;
			}
			metadataOut = metadata[slot];
			return true;
		}

		public static bool DataSavedInSlot(int slot = 0)
		{
			try
			{
				ValidateUsage();
			}
			catch (Exception message)
			{
				UnityEngine.Debug.LogError(message);
				return false;
			}
			return metadata[slot].exists;
		}

		public static SaveLoadResult Save(DataHeader header, object dataObject, ResultHandler handleResult = null, int slot = 0, bool unthreaded = false, bool silent = false)
		{
			if (dataObject == null)
			{
				throw new ArgumentNullException("dataObjectIn");
			}
			ValidateUsage(slot);
			if (fakeSaveSuccess)
			{
				return Dispatch(SaveLoadResult.Save | SaveLoadResult.Success, handleResult);
			}
			if (fakeSaveFailure)
			{
				return Dispatch(SaveLoadResult.Save | SaveLoadResult.Failure | SaveLoadResult.Subsystem, handleResult);
			}
			if (!UnityEngine.Application.isPlaying)
			{
				unthreaded = true;
			}
			try
			{
				return SubSave(header, dataObject, handleResult, slot, unthreaded, silent);
			}
			catch (Exception exception)
			{
				busy = false;
				UnityEngine.Debug.LogException(exception);
				return Dispatch(SaveLoadResult.Save | SaveLoadResult.Failure | SaveLoadResult.Subsystem, handleResult);
			}
		}

		public static SaveLoadResult Load(ResultHandler handleResult = null, int slot = 0, Stream outStream = null, bool unthreaded = false, bool silent = false)
		{
			ValidateUsage(slot);
			if (fakeMissingData)
			{
				return Dispatch(SaveLoadResult.Load | SaveLoadResult.Failure | SaveLoadResult.MissingData, handleResult);
			}
			if (fakeLoadFailure)
			{
				return Dispatch(SaveLoadResult.Load | SaveLoadResult.Failure | SaveLoadResult.Subsystem, handleResult);
			}
			if (!UnityEngine.Application.isPlaying)
			{
				unthreaded = true;
			}
			try
			{
				return SubLoad(handleResult, slot, outStream, unthreaded, silent);
			}
			catch (Exception exception)
			{
				busy = false;
				UnityEngine.Debug.LogException(exception);
				return Dispatch(SaveLoadResult.Load | SaveLoadResult.Failure | SaveLoadResult.Subsystem, handleResult);
			}
		}

		public static SaveLoadResult Delete(ResultHandler handleResultIn = null, int slot = 0, bool unthreaded = false, bool silent = false)
		{
			ValidateUsage(slot);
			if (fakeDeleteFailure)
			{
				return Dispatch(SaveLoadResult.Delete | SaveLoadResult.Failure | SaveLoadResult.Subsystem, handleResultIn);
			}
			if (!UnityEngine.Application.isPlaying)
			{
				unthreaded = true;
			}
			try
			{
				return SubDelete(handleResultIn, slot, unthreaded, silent);
			}
			catch (Exception exception)
			{
				busy = false;
				UnityEngine.Debug.LogException(exception);
				return Dispatch(SaveLoadResult.Delete | SaveLoadResult.Failure | SaveLoadResult.Subsystem, handleResultIn);
			}
		}

		public static T GetAndClearLastLoadedObject<T>() where T : class
		{
			if (dataObject == null)
			{
				return null;
			}
			if (!(dataObject is T result))
			{
				return null;
			}
			dataObject = null;
			return result;
		}

		private static void ValidateUsage(int slot = 0)
		{
			if (!initialised)
			{
				throw new InvalidOperationException("SaveLoad must be initialised before use.");
			}
			if (busy)
			{
				throw new InvalidOperationException("SaveLoad is busy.");
			}
			if (slot < 0 || slot >= slotQty)
			{
				throw new ArgumentOutOfRangeException("slot");
			}
		}

		private static SaveLoadResult Dispatch(SaveLoadResult result, ResultHandler handleResult = null)
		{
			if (handleResult != null)
			{
				handleResult(result);
			}
			else if (SaveLoad.handleResult != null)
			{
				ResultHandler resultHandler = SaveLoad.handleResult;
				SaveLoad.handleResult = null;
				resultHandler(result);
			}
			return result;
		}

		private static void SubInit(int slotQty, string basePath, Scene? updaterScene = null)
		{
			try
			{
				folderPath = Paths.Make(basePath, folderName);
				Directory.CreateDirectory(folderPath);
				finalFilePaths = new string[slotQty + 1];
				writerFilePaths = new string[slotQty + 1];
				fileReaders = new BinaryReader[finalFilePaths.Length];
				fileWriters = new BinaryWriter[writerFilePaths.Length];
				finalFilePaths[0] = Paths.Make(folderPath, "Meta");
				writerFilePaths[0] = finalFilePaths[0] + bufferFileName;
				int num = -1;
				while (++num < slotQty)
				{
					finalFilePaths[num + 1] = Paths.Make(folderPath, "Slot" + (num + 1));
					writerFilePaths[num + 1] = finalFilePaths[num + 1] + bufferFileName;
				}
				for (int i = 0; i < writerFilePaths.Length; i++)
				{
					fileWriters[i] = new BinaryWriter(new FileStream(writerFilePaths[i], FileMode.OpenOrCreate, FileAccess.Write, FileShare.Read));
				}
				for (int j = 0; j < finalFilePaths.Length; j++)
				{
					fileReaders[j] = new BinaryReader(new FileStream(finalFilePaths[j], FileMode.OpenOrCreate, FileAccess.Read, FileShare.ReadWrite));
				}
				signalToThread = new AutoResetEvent(initialState: false);
				signalToDispatchRoutine = new AutoResetEvent(initialState: false);
				thread = new Thread(Thread);
				thread.Name = "SaveLoad Worker Thread";
				thread.IsBackground = true;
				thread.Start();
			}
			catch (Exception ex)
			{
				SubRelease();
				UnityEngine.Debug.LogException(ex);
				throw ex;
			}
		}

		private static void SubRelease()
		{
			if (fileReaders != null)
			{
				BinaryReader[] array = fileReaders;
				foreach (BinaryReader binaryReader in array)
				{
					try
					{
						binaryReader?.Close();
					}
					catch (Exception exception)
					{
						UnityEngine.Debug.LogException(exception);
					}
				}
			}
			if (fileWriters != null)
			{
				BinaryWriter[] array2 = fileWriters;
				foreach (BinaryWriter binaryWriter in array2)
				{
					try
					{
						binaryWriter?.Close();
					}
					catch (Exception exception2)
					{
						UnityEngine.Debug.LogException(exception2);
					}
				}
			}
			if (thread != null)
			{
				thread.Abort();
			}
			folderPath = null;
			fileReaders = null;
			fileWriters = null;
			writerFilePaths = null;
			finalFilePaths = null;
			signalToThread = null;
			signalToDispatchRoutine = null;
			thread = null;
		}

		private static SaveLoadResult SubInitMetadata(ResultHandler handleResultIn, bool unthreaded, bool silent)
		{
			if (unthreaded)
			{
				SaveLoadResult saveLoadResult = ImmediateInitMetadata(silent);
				if (saveLoadResult.IsSuccess())
				{
					try
					{
						DecodeAllIcons();
					}
					catch
					{
						metadata = null;
						saveLoadResult = SaveLoadResult.Init | SaveLoadResult.Metadata | SaveLoadResult.Failure | SaveLoadResult.CorruptedData;
					}
				}
				return Dispatch(saveLoadResult, handleResultIn);
			}
			return SendToThread(SaveLoadResult.Metadata, handleResultIn, -1, silent);
		}

		private static SaveLoadResult SubSave(DataHeader header, object dataObject, ResultHandler handleResult, int slot, bool unthreaded, bool silent)
		{
			header.EncodeIcon();
			if (unthreaded)
			{
				return Dispatch(ImmediateSave(header.title, header.subtitle, header.details, header.icon, header.iconData, dataObject, slot, silent), handleResult);
			}
			requestSave.header = header;
			requestSave.dataObject = dataObject;
			return SendToThread(SaveLoadResult.Save, handleResult, slot, silent);
		}

		private static SaveLoadResult SubLoad(ResultHandler handleResult, int slot, Stream outStream, bool unthreaded, bool silent)
		{
			if (unthreaded)
			{
				return Dispatch(ImmediateLoad(slot, outStream, silent), handleResult);
			}
			SaveLoad.outStream = outStream;
			return SendToThread(SaveLoadResult.Load, handleResult, slot, silent);
		}

		private static SaveLoadResult SubDelete(ResultHandler handleResult, int slot, bool unthreaded, bool silent)
		{
			if (unthreaded)
			{
				return Dispatch(ImmediateDelete(slot, silent), handleResult);
			}
			return SendToThread(SaveLoadResult.Delete, handleResult, slot, silent);
		}

		private static BinaryReader PrepareReader(int slotIdx)
		{
			slotIdx++;
			fileReaders[slotIdx].BaseStream.Position = 0L;
			return fileReaders[slotIdx];
		}

		private static BinaryWriter PrepareWriter(int slotIdx)
		{
			slotIdx++;
			fileWriters[slotIdx].Seek(0, SeekOrigin.Begin);
			return fileWriters[slotIdx];
		}

		private static BinaryWriter FlushWriter(int slotIdx)
		{
			slotIdx++;
			fileWriters[slotIdx].BaseStream.SetLength(fileWriters[slotIdx].BaseStream.Position);
			fileWriters[slotIdx].Flush();
			return fileWriters[slotIdx];
		}

		private static void DecodeAllIcons()
		{
			int num = metadata.Length;
			while (--num >= 0)
			{
				DataHeader header = metadata[num].header;
				header.DecodeIcon();
				metadata[num].header = header;
			}
		}

		private static SaveLoadResult SendToThread(SaveLoadResult flags, ResultHandler handleResult, int slot, bool silent)
		{
			busy = true;
			SaveLoad.handleResult = handleResult;
			SaveLoad.slot = slot;
			SaveLoad.silent = silent;
			threadFlags = flags;
			signalToThread.Set();
			return flags | SaveLoadResult.Pending;
		}

		private static void SendToDispatch(SaveLoadResult result)
		{
			threadFlags = result;
			signalToDispatchRoutine.Set();
		}

		private static void Thread()
		{
			while (true)
			{
				signalToThread.WaitOne();
				switch (threadFlags)
				{
				case SaveLoadResult.Metadata:
					SendToDispatch(ImmediateInitMetadata(silent));
					break;
				case SaveLoadResult.Save:
					SendToDispatch(ImmediateSave(requestSave.header.title, requestSave.header.subtitle, requestSave.header.details, requestSave.header.icon, requestSave.header.iconData, requestSave.dataObject, slot, silent));
					break;
				case SaveLoadResult.Load:
					SendToDispatch(ImmediateLoad(slot, outStream, silent));
					break;
				case SaveLoadResult.Delete:
					SendToDispatch(ImmediateDelete(slot, silent));
					break;
				}
			}
		}

		private static Metadata[] MetaDataDeserializeFromReader(BinaryReader br)
		{
			Metadata[] array = new Metadata[br.ReadInt32()];
			for (int i = 0; i < array.Length; i++)
			{
				array[i].exists = br.ReadBoolean();
				array[i].header.title = br.ReadString();
				array[i].header.subtitle = br.ReadString();
				array[i].header.details = br.ReadString();
				array[i].header.iconData = br.ReadBytes(br.ReadInt32());
				array[i].saveTime = DateTime.FromBinary(br.ReadInt64());
			}
			return array;
		}

		private static void MetaDataSerializeToWriter(BinaryWriter bw, Metadata[] metas)
		{
			bw.Write(metas.Length);
			for (int i = 0; i < metas.Length; i++)
			{
				bw.Write(metas[i].exists);
				bw.Write(metas[i].header.title);
				bw.Write(metas[i].header.subtitle);
				bw.Write(metas[i].header.details);
				bw.Write(metas[i].header.iconData.Length);
				bw.Write(metas[i].header.iconData);
				bw.Write(metas[i].saveTime.ToBinary());
			}
		}

		private static SaveLoadResult ImmediateInitMetadata(bool silent)
		{
			if (TryStartRead(fileReaders[0], finalFilePaths[0]).Is(SaveLoadResult.MissingData))
			{
				try
				{
					metadata = new Metadata[slotQty];
				}
				catch
				{
					return SaveLoadResult.Metadata | SaveLoadResult.Failure | SaveLoadResult.Subsystem;
				}
				return SaveLoadResult.Metadata | SaveLoadResult.Success;
			}
			try
			{
				metadata = MetaDataDeserializeFromReader(PrepareReader(-1));
				if (metadata.Length < slotQty)
				{
					Metadata[] array = new Metadata[slotQty];
					for (int i = 0; i < metadata.Length; i++)
					{
						array[i] = metadata[i];
					}
					metadata = array;
				}
				else if (metadata.Length > slotQty)
				{
					Metadata[] array2 = new Metadata[slotQty];
					for (int j = 0; j < slotQty; j++)
					{
						array2[j] = metadata[j];
					}
					metadata = array2;
				}
				if (!silent)
				{
					UnityEngine.Debug.LogFormat("SaveLoad read from \"{0}\".", finalFilePaths[0]);
				}
			}
			catch
			{
				return SaveLoadResult.Metadata | SaveLoadResult.Failure | SaveLoadResult.Subsystem;
			}
			return SaveLoadResult.Metadata | SaveLoadResult.Success;
		}

		private static SaveLoadResult ImmediateSave(string title, string subtitle, string details, Texture2D icon, byte[] iconData, object dataObject, int slot, bool silent)
		{
			try
			{
				BinaryWriter binaryWriter = PrepareWriter(slot);
				if (dataObject is Stream input)
				{
					binaryWriter.Write((byte)0);
					input.CopyTo(binaryWriter.BaseStream, streamBuffer);
				}
				else
				{
					binaryWriter.Write((byte)1);
					Serializer.SerializeToWriter(dataObject, binaryWriter);
				}
				FlushWriter(slot);
				if (!FlipSaveDoubleBufferForSlot(slot))
				{
					return SaveLoadResult.Save | SaveLoadResult.Failure | SaveLoadResult.Subsystem;
				}
				if (!silent)
				{
					UnityEngine.Debug.LogFormat("SaveLoad wrote to \"{0}\".", writerFilePaths[slot + 1]);
				}
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
				return SaveLoadResult.Save | SaveLoadResult.Failure | SaveLoadResult.Subsystem;
			}
			metadata[slot].exists = true;
			metadata[slot].header.title = title;
			metadata[slot].header.subtitle = subtitle;
			metadata[slot].header.details = details;
			metadata[slot].header.icon = icon;
			metadata[slot].header.iconData = iconData;
			metadata[slot].saveTime = DateTime.Now;
			try
			{
				MetaDataSerializeToWriter(PrepareWriter(-1), metadata);
				FlushWriter(-1);
				if (!FlipSaveDoubleBufferForSlot(-1))
				{
					return SaveLoadResult.Save | SaveLoadResult.Failure | SaveLoadResult.Subsystem;
				}
				if (!silent)
				{
					UnityEngine.Debug.LogFormat("SaveLoad wrote to \"{0}\".", writerFilePaths[0]);
				}
			}
			catch
			{
				return SaveLoadResult.Metadata | SaveLoadResult.Save | SaveLoadResult.Failure | SaveLoadResult.Subsystem;
			}
			finally
			{
				metadata[slot].header.iconData = null;
			}
			return SaveLoadResult.Metadata | SaveLoadResult.Save | SaveLoadResult.Success;
		}

		private static bool FlipSaveDoubleBufferForSlot(int slotIdx)
		{
			slotIdx++;
			try
			{
				string destFileName = finalFilePaths[slotIdx];
				File.Copy(writerFilePaths[slotIdx], destFileName, overwrite: true);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
				return false;
			}
			return true;
		}

		private static SaveLoadResult ImmediateLoad(int slot, Stream outStream, bool silent)
		{
			SaveLoadResult saveLoadResult = TryStartRead(fileReaders[slot + 1], finalFilePaths[slot + 1]);
			if (saveLoadResult.IsFailure())
			{
				return SaveLoadResult.Load | saveLoadResult;
			}
			try
			{
				BinaryReader binaryReader = PrepareReader(slot);
				bool flag = binaryReader.ReadByte() == 0;
				if (outStream != null)
				{
					binaryReader.BaseStream.CopyTo(outStream, streamBuffer);
				}
				else if (flag)
				{
					dataObject = binaryReader.ReadBytes((int)binaryReader.BaseStream.Length - 1);
				}
				else
				{
					dataObject = Serializer.DeserialiseFromReader<object>(binaryReader);
				}
				if (!silent)
				{
					UnityEngine.Debug.LogFormat("SaveLoad read from \"{0}\".", finalFilePaths[slot + 1]);
				}
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
				return SaveLoadResult.Load | SaveLoadResult.Failure | SaveLoadResult.CorruptedData;
			}
			return SaveLoadResult.Load | SaveLoadResult.Success;
		}

		private static SaveLoadResult ImmediateDelete(int slotIn, bool silent)
		{
			try
			{
				PrepareWriter(slotIn);
				FlushWriter(slotIn);
				if (!FlipSaveDoubleBufferForSlot(slotIn))
				{
					return SaveLoadResult.Save | SaveLoadResult.Failure | SaveLoadResult.Subsystem;
				}
				if (!silent)
				{
					UnityEngine.Debug.LogFormat("SaveLoad deleted \"{0}\".", finalFilePaths[slotIn + 1]);
				}
			}
			catch (DirectoryNotFoundException)
			{
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
				return SaveLoadResult.Delete | SaveLoadResult.Failure | SaveLoadResult.Subsystem;
			}
			metadata[slotIn] = default(Metadata);
			try
			{
				BinaryWriter output = PrepareWriter(-1);
				Serializer.SerializeToWriter(metadata, output);
				FlushWriter(-1);
				if (!FlipSaveDoubleBufferForSlot(-1))
				{
					return SaveLoadResult.Save | SaveLoadResult.Failure | SaveLoadResult.Subsystem;
				}
				if (!silent)
				{
					UnityEngine.Debug.LogFormat("SaveLoad wrote to \"{0}\".", finalFilePaths[0]);
				}
			}
			catch
			{
				return SaveLoadResult.Metadata | SaveLoadResult.Delete | SaveLoadResult.Failure | SaveLoadResult.Subsystem;
			}
			return SaveLoadResult.Metadata | SaveLoadResult.Delete | SaveLoadResult.Success;
		}

		private static SaveLoadResult TryStartRead(BinaryReader fileReader, string path)
		{
			try
			{
				return (fileReader.BaseStream.Length > 0) ? SaveLoadResult.Success : (SaveLoadResult.Failure | SaveLoadResult.MissingData);
			}
			catch (FileNotFoundException)
			{
				return SaveLoadResult.Failure | SaveLoadResult.MissingData;
			}
			catch (DirectoryNotFoundException)
			{
				return SaveLoadResult.Failure | SaveLoadResult.MissingData;
			}
			catch (IsolatedStorageException ex3)
			{
				return SaveLoadResult.Failure | (ex3.Message.StartsWith("Could not find") ? SaveLoadResult.MissingData : SaveLoadResult.Subsystem);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
				return SaveLoadResult.Failure | SaveLoadResult.Subsystem;
			}
		}

		public static void RunDispatch()
		{
			if (signalToDispatchRoutine == null || !signalToDispatchRoutine.WaitOne(0))
			{
				return;
			}
			SaveLoadResult saveLoadResult = threadFlags;
			threadFlags = SaveLoadResult.None;
			busy = false;
			if (saveLoadResult.Is(SaveLoadResult.Metadata, SaveLoadResult.Success))
			{
				try
				{
					DecodeAllIcons();
				}
				catch
				{
					metadata = null;
					saveLoadResult = SaveLoadResult.Metadata | SaveLoadResult.Failure | SaveLoadResult.CorruptedData;
				}
			}
			Dispatch(saveLoadResult);
		}

		public static void BackupFiles()
		{
			ValidateUsage();
			UnityEngine.Debug.Log("Backing up SaveLoad files...");
			string text = "ftp://10.140.19.142/SaveLoad_Backups";
			UnityEngine.Debug.LogFormat("Creating {0}...", text);
			Misc.TryMakeFTPFolder(text);
			string text2 = text + "/" + DateTime.Now.ToString("dd-MM HH-mm-ss") + $" ({SystemInfo.deviceName}) ({SystemInfo.deviceModel})";
			UnityEngine.Debug.LogFormat("Creating {0}...", text2);
			Misc.TryMakeFTPFolder(text2);
			string[] array = finalFilePaths;
			foreach (string path in array)
			{
				string fileName = Path.GetFileName(path);
				if (!File.Exists(path))
				{
					UnityEngine.Debug.LogFormat("File \"{0}\" does not exist to backup!", fileName);
					continue;
				}
				string text3 = text2 + "/" + fileName;
				UnityEngine.Debug.LogFormat("Backing up \"{0}\" to \"{1}\"!", fileName, text3);
				Misc.TryCopyLocalFileToFTP(path, text3);
			}
			UnityEngine.Debug.Log("SaveLoad files backup complete!");
		}
	}
	public abstract class SerialisableSingletonMonoBehaviour<T> : SingletonMonoBehaviour<T>, Serializer.ISelfComposer where T : SerialisableSingletonMonoBehaviour<T>
	{
		public virtual void Decompose(Serializer.IMemberSink members)
		{
		}

		public virtual void Recompose(Serializer.IMemberSource members)
		{
			SingletonMonoBehaviour<T>._Inst = (T)this;
		}
	}
	public abstract class SerialisableSingletonMonoBehaviour<BT, IT> : SingletonMonoBehaviour<BT, IT>, Serializer.ISelfComposer where BT : SerialisableSingletonMonoBehaviour<BT, IT>, IT
	{
		public virtual void Decompose(Serializer.IMemberSink members)
		{
		}

		public virtual void Recompose(Serializer.IMemberSource members)
		{
			SingletonMonoBehaviour<BT, IT>._Inst = (BT)this;
		}
	}
	public static class Serializer
	{
		private class ColorConstructor : IExternalConstructor
		{
			public void Deconstruct(object obj, Type type, BinaryWriter writer)
			{
				Color color = (Color)obj;
				writer.Write(color.r);
				writer.Write(color.g);
				writer.Write(color.b);
				writer.Write(color.a);
			}

			public object Reconstruct(Type type, BinaryReader reader)
			{
				return new Color(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
			}
		}

		private class Vector3Constructor : IExternalConstructor
		{
			public void Deconstruct(object obj, Type type, BinaryWriter writer)
			{
				Vector3 vector = (Vector3)obj;
				writer.Write(vector.x);
				writer.Write(vector.y);
				writer.Write(vector.z);
			}

			public object Reconstruct(Type type, BinaryReader reader)
			{
				return new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
			}
		}

		private class Vector2Constructor : IExternalConstructor
		{
			public void Deconstruct(object obj, Type type, BinaryWriter writer)
			{
				Vector2 vector = (Vector2)obj;
				writer.Write(vector.x);
				writer.Write(vector.y);
			}

			public object Reconstruct(Type type, BinaryReader reader)
			{
				return new Vector2(reader.ReadSingle(), reader.ReadSingle());
			}
		}

		private class NameSorter : IComparer<KeyValuePair<string, int>>
		{
			public int Compare(KeyValuePair<string, int> x, KeyValuePair<string, int> y)
			{
				return string.Compare(x.Key, y.Key);
			}
		}

		[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
		public class ExcludeAllFields : Attribute
		{
		}

		[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
		public class ExcludeAllFieldsFromAssignablesTo : Attribute
		{
		}

		[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
		public class ExcludeAssignablesTo : Attribute
		{
		}

		[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Property | AttributeTargets.Field)]
		public class Exclude : Attribute
		{
		}

		[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
		public class IncludeField : Attribute
		{
		}

		[AttributeUsage(AttributeTargets.Class)]
		public class ExcludeEnabled : Attribute
		{
		}

		[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
		public abstract class ExternalConstructor : Attribute, IExternalConstructor
		{
			public abstract void Deconstruct(object obj, Type type, BinaryWriter writer);

			public abstract object Reconstruct(Type type, BinaryReader reader);
		}

		[AttributeUsage(AttributeTargets.Class)]
		public abstract class ExternalResourceAcquisitor : Attribute
		{
			public abstract void Deacquire(ScriptableResource obj, Type type, BinaryWriter writer);

			public abstract ScriptableResource Reacquire(string path, Type type, BinaryReader reader);
		}

		[AttributeUsage(AttributeTargets.Class)]
		public abstract class ExternalPrefabReacquisitor : Attribute
		{
			public abstract void Deacquire(Serializer_Prefab instance, BinaryWriter writer);

			public abstract GameObject Reacquire(string path, BinaryReader reader);
		}

		public interface ISelfConstructor
		{
			void Deconstruct(BinaryWriter writer);
		}

		public interface IExternalConstructor
		{
			void Deconstruct(object obj, Type type, BinaryWriter writer);

			object Reconstruct(Type type, BinaryReader reader);
		}

		public interface IMemberSink
		{
			object this[string name] { set; }
		}

		public interface IMemberSource
		{
			object this[string name] { get; }

			bool TryGet<T>(string name, ref T val);

			T Get<T>(string name);
		}

		public interface ISelfComposer
		{
			void Decompose(IMemberSink members);

			void Recompose(IMemberSource members);
		}

		public interface IUnityObjectSerializer
		{
			void SerializePrefabInstance(BinaryWriter writer, Serializer_Prefab prefabInstance);

			GameObject DeserializePrefabInstance(BinaryReader reader, GameObject prefab);

			void SerializeGameObject(BinaryWriter writer, GameObject gameObject);

			GameObject DeserializeGameObject(BinaryReader reader);

			void SerializeComponent(BinaryWriter writer, UnityEngine.Component component);

			UnityEngine.Component DeserializeComponent(BinaryReader reader, Type type);
		}

		private class ReferenceEqualityComparer : IEqualityComparer, IEqualityComparer<object>
		{
			public static readonly ReferenceEqualityComparer Default = new ReferenceEqualityComparer();

			bool IEqualityComparer<object>.Equals(object x, object y)
			{
				return x == y;
			}

			bool IEqualityComparer.Equals(object x, object y)
			{
				return x == y;
			}

			int IEqualityComparer<object>.GetHashCode(object obj)
			{
				return RuntimeHelpers.GetHashCode(obj);
			}

			int IEqualityComparer.GetHashCode(object obj)
			{
				return RuntimeHelpers.GetHashCode(obj);
			}
		}

		private class TypeProperties
		{
			private const BindingFlags incFields = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;

			public readonly Type type;

			public readonly Type arrayType;

			public readonly bool cachedTypeIsValue;

			public readonly bool cachedTypeIsPrimitive;

			public readonly bool actualTypeAssignFieldInfo;

			public readonly bool actualTypeAssignType;

			public readonly bool excluded;

			public readonly string assemblyQualifiedName;

			public readonly FieldProperties[] fields;

			public readonly Attribute[] attribs;

			public readonly Attribute[] inheritedAttribs;

			public TypeProperties(Type type)
			{
				this.type = type;
				arrayType = type.GetElementType();
				assemblyQualifiedName = type.AssemblyQualifiedName;
				excluded = type.ExcludedBySerializer();
				actualTypeAssignFieldInfo = typeof(FieldInfo).IsAssignableFrom(type);
				actualTypeAssignType = typeof(Type).IsAssignableFrom(type);
				Type type2 = arrayType ?? type;
				HashSet<Attribute> thisAttribs = new HashSet<Attribute>(type2.GetCustomAttributes(inherit: false).Cast<Attribute>());
				cachedTypeIsValue = type2.IsValueType;
				cachedTypeIsPrimitive = type2.IsPrimitive;
				attribs = thisAttribs.ToArray();
				inheritedAttribs = (from Attribute a in type2.GetCustomAttributes(inherit: true)
					where !thisAttribs.Contains(a)
					select a).ToArray();
				if (excluded)
				{
					fields = new FieldProperties[0];
					return;
				}
				ParameterExpression parameterExpression = null;
				ParameterExpression parameterExpression2 = Expression.Parameter(typeof(object), "object");
				Expression expression = Expression.ConvertChecked(parameterExpression2, type);
				if (arrayType != null)
				{
					parameterExpression = Expression.Parameter(typeof(int), "index");
					expression = Expression.ArrayIndex(expression, parameterExpression);
				}
				List<FieldProperties> list = new List<FieldProperties>();
				Stack<FieldInfo> fieldStack = new Stack<FieldInfo>();
				CollectFieldProperties(type2, list, fieldStack, expression, parameterExpression2, parameterExpression, "");
				fields = list.ToArray();
			}

			public int GetLength(object obj)
			{
				if (!(arrayType == null))
				{
					return (obj as Array).Length;
				}
				return 1;
			}

			private static void CollectFieldProperties(Type type, List<FieldProperties> propList, Stack<FieldInfo> fieldStack, Expression ownerExpr, ParameterExpression targetPExpr, ParameterExpression indexerPExpr, string ownerField)
			{
				int i = 0;
				for (int count = extraExcludeAllFieldsFromAssignablesTo.Count; i < count; i++)
				{
					if (extraExcludeAllFieldsFromAssignablesTo[i].IsAssignableFrom(type))
					{
						return;
					}
				}
				if (type.HasAttr<ExcludeAllFieldsFromAssignablesTo>(inherit: true))
				{
					return;
				}
				Type type2 = type;
				while (type2 != null)
				{
					if (!extraExcludeAllFields.Contains(type2))
					{
						bool flag = type2.HasAttr<ExcludeAllFields>(inherit: true);
						FieldInfo[] array = type2.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
						foreach (FieldInfo fieldInfo in array)
						{
							if (flag)
							{
								if (!fieldInfo.HasAttr<IncludeField>())
								{
									continue;
								}
							}
							else if (fieldInfo.HasAttr<Exclude>())
							{
								continue;
							}
							string text = ownerField + "." + fieldInfo.Name;
							if (fieldInfo.FieldType.IsValueType && !fieldInfo.FieldType.IsConvertableToPrimitve())
							{
								fieldStack.Push(fieldInfo);
								CollectFieldProperties(fieldInfo.FieldType, propList, fieldStack, Expression.Field(ownerExpr, fieldInfo), targetPExpr, indexerPExpr, text);
								fieldStack.Pop();
							}
							else
							{
								propList.Add(new FieldProperties(fieldInfo, fieldStack, ownerExpr, targetPExpr, indexerPExpr, text));
							}
						}
					}
					type2 = type2.BaseType;
				}
			}

			public T GetAttr<T>(bool inherit = false) where T : Attribute
			{
				Type typeFromHandle = typeof(T);
				for (int i = 0; i < attribs.Length; i++)
				{
					if (attribs[i].IsOfTypeOrSubType(typeFromHandle))
					{
						return (T)attribs[i];
					}
				}
				if (inherit)
				{
					for (int j = 0; j < inheritedAttribs.Length; j++)
					{
						if (inheritedAttribs[j].IsOfTypeOrSubType(typeFromHandle))
						{
							return (T)inheritedAttribs[j];
						}
					}
				}
				return null;
			}

			public bool HasAttr<T>(bool inherit = false) where T : Attribute
			{
				return GetAttr<T>(inherit) != null;
			}
		}

		private class FieldProperties
		{
			private static MethodInfo dtToBinary = typeof(DateTime).GetMethod("ToBinary", BindingFlags.Instance | BindingFlags.Public);

			public readonly FieldInfo field;

			public readonly Attribute[] attribs;

			public readonly TypeCode typeCode;

			public readonly string fullName;

			public readonly Func<object, primitive> GetPrimitive;

			public readonly Func<object, object> GetObject;

			public readonly Func<object, int, primitive> GetPrimitiveIndexed;

			public readonly Func<object, int, object> GetObjectIndexed;

			private readonly FieldInfo[] fieldStack;

			private readonly object[] objStack;

			public FieldProperties(FieldInfo field, Stack<FieldInfo> fieldStack, Expression ownerExpr, ParameterExpression targetPExpr, ParameterExpression indexerPExpr, string fullName)
			{
				IEnumerable<Attribute> enumerable = field.GetCustomAttributes(inherit: false).Cast<Attribute>();
				Type fieldType = field.FieldType;
				this.field = field;
				this.fullName = fullName;
				this.fieldStack = fieldStack.ToArray();
				objStack = new object[this.fieldStack.Length];
				typeCode = Type.GetTypeCode(fieldType);
				if (field.IsBacking())
				{
					PropertyInfo backedProperty = field.GetBackedProperty();
					if (backedProperty != null)
					{
						enumerable = enumerable.Concat(backedProperty.GetCustomAttributes(inherit: false).Cast<Attribute>());
					}
				}
				attribs = enumerable.ToArray();
				Expression expression = Expression.Field(ownerExpr, field);
				if (fieldType.IsConvertableToPrimitve())
				{
					if (fieldType == typeof(DateTime))
					{
						expression = Expression.ConvertChecked(expression, typeof(DateTime));
						expression = Expression.Call(expression, dtToBinary);
					}
					else if (fieldType.IsEnum)
					{
						expression = Expression.ConvertChecked(expression, Enum.GetUnderlyingType(fieldType));
					}
					expression = Expression.ConvertChecked(expression, typeof(primitive));
					GetObject = null;
					GetObjectIndexed = null;
					if (indexerPExpr == null)
					{
						GetPrimitive = Expression.Lambda<Func<object, primitive>>(expression, new ParameterExpression[1] { targetPExpr }).Compile();
						GetPrimitiveIndexed = null;
					}
					else
					{
						GetPrimitive = null;
						GetPrimitiveIndexed = Expression.Lambda<Func<object, int, primitive>>(expression, new ParameterExpression[2] { targetPExpr, indexerPExpr }).Compile();
					}
				}
				else
				{
					expression = Expression.ConvertChecked(expression, typeof(object));
					GetPrimitive = null;
					GetPrimitiveIndexed = null;
					if (indexerPExpr == null)
					{
						GetObject = Expression.Lambda<Func<object, object>>(expression, new ParameterExpression[1] { targetPExpr }).Compile();
						GetObjectIndexed = null;
					}
					else
					{
						GetObject = null;
						GetObjectIndexed = Expression.Lambda<Func<object, int, object>>(expression, new ParameterExpression[2] { targetPExpr, indexerPExpr }).Compile();
					}
				}
			}

			public void SetObjectValue(object objOwner, object objVal)
			{
				object obj = objOwner;
				for (int num = fieldStack.Length - 1; num >= 0; num--)
				{
					objStack[num] = obj;
					obj = fieldStack[num].GetValue(obj);
				}
				field.SetValue(obj, objVal);
				for (int i = 0; i < fieldStack.Length; i++)
				{
					fieldStack[i].SetValue(objStack[i], obj);
					obj = objStack[i];
				}
				for (int j = 0; j < objStack.Length; j++)
				{
					objStack[j] = null;
				}
			}

			public void SetObjectValueIndexed(Array array, int index, object objVal)
			{
				object value = array.GetValue(index);
				SetObjectValue(value, objVal);
				array.SetValue(value, index);
			}

			public T GetAttr<T>() where T : Attribute
			{
				Type typeFromHandle = typeof(T);
				for (int i = 0; i < attribs.Length; i++)
				{
					if (attribs[i].IsOfTypeOrSubType(typeFromHandle))
					{
						return (T)attribs[i];
					}
				}
				return null;
			}

			public bool HasAttr<T>() where T : Attribute
			{
				return GetAttr<T>() != null;
			}
		}

		private struct DeconstructedObject
		{
			public object obj;

			public Type type;

			public byte hint;

			public int memIdx;

			public int memQty;

			public int elementSize;
		}

		private static class Hint
		{
			public const byte None = 0;

			public const byte String = 1;

			public const byte Enum = 2;

			public const byte Resource = 3;

			public const byte Type = 4;

			public const byte FieldInfo = 5;

			public const byte Array = 6;

			public const byte GameObject = 7;

			public const byte Component = 8;
		}

		private struct DeconstructedPrefab
		{
			public byte order;

			public Serializer_Prefab instance;
		}

		private struct DeconstructedMember
		{
			public struct Value
			{
				public byte typeCode;

				public bool custom;

				public int index;

				public primitive prim;
			}

			public string name;

			public Value key;

			public Value val;
		}

		private class CustomMemberBuffer : IMemberSink, IMemberSource
		{
			public Dictionary<string, object> members = new Dictionary<string, object>(64);

			public object this[string name]
			{
				get
				{
					return members[name];
				}
				set
				{
					members[name] = value;
				}
			}

			public bool TryGet<T>(string name, ref T val)
			{
				if (members.TryGetValue(name, out var value))
				{
					val = (T)value;
					return true;
				}
				return false;
			}

			public T Get<T>(string name)
			{
				return (T)members[name];
			}
		}

		private static int retentions = 0;

		private const int initialObjectCapacity = 65536;

		private const int initialMemberCapacity = 524288;

		private const int initialParsedPrefabCapacity = 128;

		private const int initialBufferBufferSize = 2048;

		private const int nullValue = -1;

		private const int excluded = -2;

		private static DeconstructedObject[] deconObjs;

		private static int objQty;

		private static int memQty;

		private static int prefabQty;

		private static Dictionary<object, int> deconObjIdxs;

		private static DeconstructedPrefab[] deconPrefabs;

		private static DeconstructedMember[] deconMems;

		private static CustomMemberBuffer customMemberBuffer;

		private static object[] constrParams;

		private static byte[] bufferBuffer;

		private static Dictionary<Type, FieldInfo[]> fieldCache;

		private static List<FieldInfo> fieldBuffer;

		private static Dictionary<Type, IExternalConstructor> extraExternalConstructor;

		private static HashSet<Type> extraExcludeAllFields;

		private static HashSet<Type> extraExclude;

		private static List<Type> extraExcludeAllFieldsFromAssignablesTo;

		private static List<Type> extraExcludeAssignablesTo;

		private static List<Serializer_Prefab> prefabCompBuffer;

		private static Dictionary<Type, TypeProperties> typePropsCache;

		private static IUnityObjectSerializer unityObjectSerializer;

		private static Dictionary<string, GameObject> spawnedPrefabInstances;

		private static Type genericEqCompTemplate = typeof(EqualityComparer<>).Assembly.GetType("System.Collections.Generic.GenericEqualityComparer`1");

		private static TextWriter debugLog;

		private static Stack<string> logStack = new Stack<string>(32);

		private static string logFolderPath;

		private static int mainThreadID;

		private static Dictionary<Type, int> instanceCounts;

		public static bool initialised => retentions > 0;

		public static void SetUnityObjectSerializer(IUnityObjectSerializer serializer)
		{
			unityObjectSerializer = serializer;
		}

		public static void Retain(bool silent = false, string logFolder = null)
		{
			if (retentions++ > 0)
			{
				return;
			}
			try
			{
				deconObjs = new DeconstructedObject[65536];
				deconObjIdxs = new Dictionary<object, int>(65536, ReferenceEqualityComparer.Default);
				deconPrefabs = new DeconstructedPrefab[128];
				deconMems = new DeconstructedMember[524288];
				customMemberBuffer = new CustomMemberBuffer();
				constrParams = new object[1];
				bufferBuffer = new byte[2048];
				fieldCache = new Dictionary<Type, FieldInfo[]>(65);
				fieldBuffer = new List<FieldInfo>(128);
				prefabCompBuffer = new List<Serializer_Prefab>(1);
				typePropsCache = new Dictionary<Type, TypeProperties>();
				spawnedPrefabInstances = new Dictionary<string, GameObject>(128);
				extraExternalConstructor = new Dictionary<Type, IExternalConstructor>(64)
				{
					{
						typeof(Color),
						new ColorConstructor()
					},
					{
						typeof(Vector3),
						new Vector3Constructor()
					},
					{
						typeof(Vector2),
						new Vector2Constructor()
					}
				};
				extraExcludeAllFields = new HashSet<Type>
				{
					typeof(UnityEngine.Object),
					typeof(MonoBehaviour),
					typeof(UnityEngine.Component),
					typeof(Type),
					typeof(FieldInfo)
				};
				extraExcludeAllFieldsFromAssignablesTo = new List<Type>(64)
				{
					typeof(Renderer),
					typeof(IntPtr),
					typeof(UIntPtr)
				};
				extraExclude = new HashSet<Type>
				{
					typeof(AnimationCurve),
					typeof(Material),
					typeof(Texture2D),
					typeof(Font)
				};
				extraExcludeAssignablesTo = new List<Type>(64)
				{
					typeof(Delegate),
					typeof(Attribute),
					typeof(Stream),
					typeof(Exception)
				};
				logFolderPath = ((logFolder == null) ? UnityEngine.Application.persistentDataPath : logFolder);
				mainThreadID = Thread.CurrentThread.ManagedThreadId;
				if (!silent)
				{
					UnityEngine.Debug.Log("Serializer initialised.");
				}
			}
			catch (Exception)
			{
				Release(silent);
				throw;
			}
		}

		public static void Release(bool silent = false)
		{
			if (retentions == 0)
			{
				UnityEngine.Debug.LogError("Serializer over-released!");
			}
			else if (--retentions <= 0)
			{
				deconObjs = null;
				deconObjIdxs = null;
				deconPrefabs = null;
				deconMems = null;
				customMemberBuffer = null;
				constrParams = null;
				bufferBuffer = null;
				fieldCache = null;
				fieldBuffer = null;
				prefabCompBuffer = null;
				extraExcludeAllFields = null;
				extraExclude = null;
				extraExcludeAssignablesTo = null;
				extraExternalConstructor = null;
				logFolderPath = null;
				mainThreadID = 0;
				if (!silent)
				{
					UnityEngine.Debug.Log("Serializer cleaned up.");
				}
			}
		}

		public static void PrecacheTypes(IEnumerable<Type> rootTypes, IEnumerable<Type> nonRecursuveTypes, IEnumerable<Assembly> subclassAssemblies)
		{
			HashSet<Type> hashSet = new HashSet<Type>();
			foreach (Type rootType in rootTypes)
			{
				if (hashSet.Add(rootType))
				{
					PrecacheTypes(hashSet, rootType);
				}
			}
			foreach (Type nonRecursuveType in nonRecursuveTypes)
			{
				if (hashSet.Add(nonRecursuveType))
				{
					PrecacheTypes(hashSet, nonRecursuveType, recurse: false);
				}
			}
			Type[] array = (from t in subclassAssemblies.Concat(typePropsCache.Keys.Select((Type t) => t.Assembly)).Distinct().SelectMany((Assembly a) => a.GetTypes())
				where !typePropsCache.ContainsKey(t)
				where t != typeof(object) && t.IsClass
				select t).ToArray();
			Type[] array2 = typePropsCache.Keys.Where((Type t) => t != typeof(object)).ToArray();
			Type[] array3 = array;
			foreach (Type type in array3)
			{
				if (hashSet.Contains(type))
				{
					continue;
				}
				Type[] array4 = array2;
				foreach (Type type2 in array4)
				{
					if (type2.IsAssignableFrom(type))
					{
						PrecacheTypes(hashSet, type, !type2.HasAttr<ExcludeAllFieldsFromAssignablesTo>(inherit: true));
						break;
					}
				}
			}
		}

		private static Type GetDefaultComparerType(Type interfaceType)
		{
			Type type = interfaceType.GetGenericArguments()[0];
			return typeof(EqualityComparer<>).MakeGenericType(type).GetProperty("Default", BindingFlags.Static | BindingFlags.Public).GetValue(null)
				.GetType();
		}

		private static void PrecacheTypes(HashSet<Type> foundTypes, Type type, bool recurse = true)
		{
			if (type.IsGenericTypeDefinition)
			{
				return;
			}
			TypeProperties typeProperties = type.GetTypeProperties();
			if (typeProperties.arrayType != null && foundTypes.Add(typeProperties.arrayType))
			{
				PrecacheTypes(foundTypes, typeProperties.arrayType);
			}
			if (!recurse || typeProperties.excluded || type.HasAttr<ExternalResourceAcquisitor>(inherit: true) || type.HasAttr<ExcludeAllFieldsFromAssignablesTo>(inherit: true) || extraExcludeAllFields.Contains(type) || extraExcludeAllFieldsFromAssignablesTo.Where((Type eeaffat) => eeaffat.IsAssignableFrom(type)).Any())
			{
				return;
			}
			bool excludeByDefault = type.HasAttr<ExcludeAllFields>(inherit: true);
			foreach (Type item in from fi in typeProperties.fields
				where (!excludeByDefault) ? (!fi.HasAttr<Exclude>()) : fi.HasAttr<IncludeField>()
				select fi.field.FieldType into fType
				where !fType.IsValueType
				select fType)
			{
				if (!foundTypes.Add(item))
				{
					continue;
				}
				if (item.IsClass)
				{
					PrecacheTypes(foundTypes, item);
				}
				else if (item.IsGenericType && typeof(IEqualityComparer<>).IsAssignableFrom(item.GetGenericTypeDefinition()))
				{
					Type defaultComparerType = GetDefaultComparerType(item);
					if (foundTypes.Add(defaultComparerType))
					{
						PrecacheTypes(foundTypes, defaultComparerType);
					}
				}
			}
		}

		public static void SerializeToWriter(object obj, BinaryWriter output, string overrideLogPath = null)
		{
			Retain();
			int i = 0;
			try
			{
				Deconstruct(obj, deconObjs.Length - 1);
				output.Write(prefabQty);
				byte b = 0;
				while (WritePrefabInstances(output, b++, prefabQty))
				{
				}
				output.Write(objQty);
				for (; i < objQty; i++)
				{
					WriteObject(output, i);
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogException(ex);
				throw ex;
			}
			finally
			{
				ClearAllCache();
				Release();
			}
		}

		public static void SerializeToStream(object obj, Stream output, string overrideLogPath = null)
		{
			using BinaryWriter output2 = new BinaryWriter(output, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: true), leaveOpen: true);
			SerializeToWriter(obj, output2, overrideLogPath);
		}

		public static void SerializeToFile(object obj, string path, string overrideLogPath = null)
		{
			Directory.CreateDirectory(Path.GetDirectoryName(path));
			using FileStream output = File.Create(path);
			SerializeToStream(obj, output, overrideLogPath);
		}

		public static byte[] SerializeToMemory(object obj, int capacity = -1, string overrideLogPath = null)
		{
			using MemoryStream memoryStream = ((capacity > 0) ? new MemoryStream(capacity) : new MemoryStream());
			SerializeToStream(obj, memoryStream, overrideLogPath);
			return memoryStream.GetBuffer();
		}

		public static int SerializeToMemory(object obj, byte[] memory, bool clearRemainder = true, int startIndex = 0, int count = -1, string overrideLogPath = null)
		{
			int num = 0;
			using (MemoryStream memoryStream = new MemoryStream(memory, startIndex, (count > 0) ? count : memory.Length))
			{
				SerializeToStream(obj, memoryStream, overrideLogPath);
				num = (int)memoryStream.Position;
			}
			if (clearRemainder)
			{
				Array.Clear(memory, num, memory.Length - num);
			}
			return num;
		}

		public static T DeserialiseFromReader<T>(BinaryReader input, string overrideLogPath = null) where T : class
		{
			Retain();
			int i = 0;
			try
			{
				prefabQty = input.ReadInt32();
				for (int j = 0; j < prefabQty; j++)
				{
					ReadPrefabInstance(input);
				}
				objQty = input.ReadInt32();
				ValidateObjectCap(objQty);
				for (; i < objQty; i++)
				{
					ReadObject(input, ref deconObjs[i], i);
				}
				for (i--; i >= 0; i--)
				{
					ReconstructMembers(input, ref deconObjs[i]);
				}
				i = objQty;
				for (i--; i >= 0; i--)
				{
					SelfRecompose(input, i, ref deconObjs[i]);
				}
				return (T)deconObjs[0].obj;
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogException(ex);
				throw ex;
			}
			finally
			{
				ClearAllCache();
				Release();
			}
		}

		public static T DeserialiseFromStream<T>(Stream input, string overrideLogPath = null) where T : class
		{
			using BinaryReader input2 = new BinaryReader(input, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: true), leaveOpen: true);
			return DeserialiseFromReader<T>(input2, overrideLogPath);
		}

		public static T DeserialiseFromFile<T>(string path, string overrideLogPath = null) where T : class
		{
			using FileStream input = File.OpenRead(path);
			return DeserialiseFromStream<T>(input, overrideLogPath);
		}

		public static T DeserialiseFromMemory<T>(byte[] memory, int startIndex = 0, int byteCount = -1, string overrideLogPath = null) where T : class
		{
			using MemoryStream input = new MemoryStream(memory, startIndex, (byteCount > 0) ? byteCount : memory.Length, writable: false);
			return DeserialiseFromStream<T>(input, overrideLogPath);
		}

		public static void AddExternalConstructor<T>(IExternalConstructor constructor)
		{
			extraExternalConstructor[typeof(T)] = constructor;
		}

		public static void RemoveExternalConstructor<T>(IExternalConstructor constructor)
		{
			extraExternalConstructor.Remove(typeof(T));
		}

		public static void AddExcludeAllFields<T>()
		{
			extraExcludeAllFields.Add(typeof(T));
		}

		public static void RemoveExcludeAllFields<T>()
		{
			extraExcludeAllFields.Remove(typeof(T));
		}

		public static void AddExclude<T>()
		{
			extraExclude.Add(typeof(T));
		}

		public static void RemoveExclude<T>()
		{
			extraExclude.Remove(typeof(T));
		}

		public static void AddExcludeAssignablesTo<T>()
		{
			extraExcludeAssignablesTo.Add(typeof(T));
		}

		public static void RemoveExcludeAssignablesTo<T>()
		{
			extraExcludeAssignablesTo.Remove(typeof(T));
		}

		private static bool IsConvertableToPrimitve(this Type type)
		{
			if (!type.IsPrimitive && !type.IsEnum)
			{
				return type == typeof(DateTime);
			}
			return true;
		}

		private static void ClearAllCache()
		{
			constrParams[0] = null;
			Array.Clear(deconObjs, 0, objQty);
			Array.Clear(deconMems, 0, memQty);
			Array.Clear(deconPrefabs, 0, prefabQty);
			objQty = (memQty = (prefabQty = 0));
			customMemberBuffer.members.Clear();
			deconObjIdxs.Clear();
			spawnedPrefabInstances.Clear();
		}

		private static TypeProperties GetTypeProperties(this Type type)
		{
			if (type == null)
			{
				return null;
			}
			if (!typePropsCache.TryGetValue(type, out var value))
			{
				value = new TypeProperties(type);
				typePropsCache[type] = value;
			}
			return value;
		}

		private static void GetIncludedFields(this Type type, List<FieldInfo> listToFill)
		{
			int i = 0;
			for (int count = extraExcludeAllFieldsFromAssignablesTo.Count; i < count; i++)
			{
				if (extraExcludeAllFieldsFromAssignablesTo[i].IsAssignableFrom(type))
				{
					return;
				}
			}
			TypeProperties typeProperties = type.GetTypeProperties();
			if (typeProperties.HasAttr<ExcludeAllFieldsFromAssignablesTo>(inherit: true))
			{
				return;
			}
			Type type2 = type;
			while (type2 != null)
			{
				if (!extraExcludeAllFields.Contains(type2))
				{
					bool flag = type2.HasAttr<ExcludeAllFields>(inherit: true);
					FieldProperties[] fields = typeProperties.fields;
					int j = 0;
					for (int num = fields.Length; j < num; j++)
					{
						FieldProperties fieldProperties = fields[j];
						if (flag)
						{
							if (!fieldProperties.HasAttr<IncludeField>())
							{
								continue;
							}
						}
						else if (fieldProperties.HasAttr<Exclude>())
						{
							continue;
						}
						listToFill.Add(fieldProperties.field);
					}
				}
				type2 = type2.BaseType;
				typeProperties = type2.GetTypeProperties();
			}
		}

		public static FieldInfo[] GetIncludedFields(this Type type)
		{
			try
			{
				Retain(silent: true);
				List<FieldInfo> list = new List<FieldInfo>();
				type.GetIncludedFields(list);
				return list.ToArray();
			}
			finally
			{
				Release();
			}
		}

		private static void ValidateObjectCap(int reqIdx)
		{
			if (reqIdx >= deconObjs.Length)
			{
				int num = Mathf.CeilToInt((float)reqIdx * 1.5f);
				UnityEngine.Debug.LogFormat("Serializer increased its object capacity from {0} to {1}", deconObjs.Length, num);
				Array.Resize(ref deconObjs, num);
			}
		}

		private static void ValidateMemberCap(int reqIdx)
		{
			if (reqIdx >= deconMems.Length)
			{
				int num = Mathf.CeilToInt((float)reqIdx * 1.5f);
				UnityEngine.Debug.LogFormat("Serializer increased its member capacity from {0} to {1}", deconMems.Length, num);
				Array.Resize(ref deconMems, num);
			}
		}

		private static void ValidatePrefabCap(int reqIdx)
		{
			if (reqIdx >= deconPrefabs.Length)
			{
				int num = Mathf.CeilToInt((float)reqIdx * 1.5f);
				UnityEngine.Debug.LogFormat("Serializer increased its prefab capacity from {0} to {1}", deconPrefabs.Length, num);
				Array.Resize(ref deconPrefabs, num);
			}
		}

		private static int Deconstruct(object obj, int referrerIdx)
		{
			bool flag;
			int value;
			Type type;
			UnityEngine.Object @object;
			if (obj != deconObjs[referrerIdx].obj)
			{
				flag = !(obj is ValueType);
				if (!flag || !deconObjIdxs.TryGetValue(obj, out value))
				{
					type = obj.GetType();
					TypeProperties typeProperties = type.GetTypeProperties();
					if (!typeProperties.excluded)
					{
						@object = null;
						ScriptableResource scriptableResource = null;
						if (flag)
						{
							@object = obj as UnityEngine.Object;
							if ((object)@object != null)
							{
								if (@object == null)
								{
									value = -1;
									goto IL_06a6;
								}
								scriptableResource = @object as ScriptableResource;
							}
						}
						ValidateObjectCap(objQty + 1);
						value = objQty++;
						if (flag)
						{
							deconObjIdxs[obj] = value;
						}
						deconObjs[value].type = type;
						deconObjs[value].obj = obj;
						deconObjs[value].memIdx = memQty;
						if (flag)
						{
							if (obj is string)
							{
								deconObjs[value].hint = 1;
							}
							else
							{
								if ((object)scriptableResource != null)
								{
									deconObjs[value].hint = 3;
									if (scriptableResource.resourcePath != null)
									{
										goto IL_06a6;
									}
								}
								if (typeProperties.actualTypeAssignFieldInfo)
								{
									deconObjs[value].hint = 5;
								}
								else if (typeProperties.actualTypeAssignType)
								{
									deconObjs[value].hint = 4;
								}
								else
								{
									if (!(obj is Array array))
									{
										goto IL_036e;
									}
									deconObjs[value].hint = 6;
									if (typeProperties.cachedTypeIsPrimitive)
									{
										deconObjs[value].memQty = array.Length;
									}
									else
									{
										int length = typeProperties.GetLength(deconObjs[value].obj);
										object[] array2 = (typeProperties.cachedTypeIsValue ? null : (deconObjs[value].obj as object[]));
										int num = deconObjs[value].memIdx;
										deconObjs[value].elementSize = ((array2 != null) ? 1 : typeProperties.fields.Length);
										for (int i = 0; i < length; i++)
										{
											if (array2 == null)
											{
												for (int j = 0; j < typeProperties.fields.Length; j++)
												{
													deconObjs[value].memQty++;
													memQty++;
													ValidateMemberCap(memQty);
												}
											}
											else
											{
												deconObjs[value].memQty++;
												memQty++;
												ValidateMemberCap(memQty);
											}
										}
										for (int k = 0; k < length; k++)
										{
											if (array2 == null)
											{
												for (int l = 0; l < typeProperties.fields.Length; l++)
												{
													FieldProperties fieldProperties = typeProperties.fields[l];
													deconMems[num].name = fieldProperties.fullName;
													deconMems[num].key.index = l;
													DeconstructIndexedFieldProperties(fieldProperties, k, value, ref deconMems[num].val);
													num++;
												}
											}
											else
											{
												DeconstructObjectMember(array2[k], value, ref deconMems[num].val);
												num++;
											}
										}
									}
								}
							}
						}
						else
						{
							if (!type.IsEnum)
							{
								goto IL_036e;
							}
							UnityEngine.Debug.Log("ENUM AS OBJECT!");
							deconObjs[value].hint = 2;
						}
					}
					else
					{
						value = -2;
					}
				}
			}
			else
			{
				value = referrerIdx;
			}
			goto IL_06a6;
			IL_06a6:
			return value;
			IL_036e:
			if (flag)
			{
				GameObject gameObject = null;
				UnityEngine.Component component = null;
				if ((object)@object != null)
				{
					gameObject = @object as GameObject;
					component = @object as UnityEngine.Component;
					TryDeconstructPrefab(gameObject, component, ref prefabQty);
				}
				if ((object)gameObject != null)
				{
					int num2 = memQty++;
					deconMems[num2].name = "activeSelf";
					deconMems[num2].val.typeCode = 3;
					deconMems[num2].val.prim = gameObject.activeSelf;
					deconObjs[value].memQty++;
					deconObjs[value].hint = 7;
					return value;
				}
				if ((object)component != null)
				{
					deconObjs[value].memQty++;
					int num3 = memQty++;
					deconMems[num3].name = "gameObject.activeSelf";
					deconMems[num3].val.typeCode = 3;
					deconMems[num3].val.prim = component.gameObject.activeSelf;
					_ = 4;
					if (obj is MonoBehaviour monoBehaviour && !type.HasAttr<ExcludeEnabled>())
					{
						deconObjs[value].memQty++;
						num3 = memQty++;
						deconMems[num3].name = "enabled";
						deconMems[num3].val.typeCode = 3;
						deconMems[num3].val.prim = monoBehaviour.enabled;
					}
					deconObjs[value].hint = 8;
				}
			}
			if (obj is ISelfComposer selfComposer)
			{
				int num4 = deconObjs[value].memIdx + deconObjs[value].memQty;
				selfComposer.Decompose(customMemberBuffer);
				int count = customMemberBuffer.members.Count;
				deconObjs[value].memQty += count;
				memQty += count;
				ValidateMemberCap(memQty);
				QueryFields(value);
				foreach (KeyValuePair<string, object> member in customMemberBuffer.members)
				{
					deconMems[num4].name = member.Key;
					DeconstructObjectMember(member.Value, value, ref deconMems[num4].val);
					deconMems[num4].key.custom = true;
					num4++;
				}
				customMemberBuffer.members.Clear();
				DeconstructFields(value, num4);
				return value;
			}
			int startmi = deconObjs[value].memIdx + deconObjs[value].memQty;
			QueryFields(value);
			DeconstructFields(value, startmi);
			return value;
		}

		public static bool ExcludedBySerializer(this Type type)
		{
			try
			{
				Retain();
				if (extraExclude.Contains(type))
				{
					return true;
				}
				int i = 0;
				for (int count = extraExcludeAssignablesTo.Count; i < count; i++)
				{
					if (extraExcludeAssignablesTo[i].IsAssignableFrom(type))
					{
						return true;
					}
				}
				if (type.HasAttr<Exclude>())
				{
					return true;
				}
				if (type.HasAttr<ExcludeAssignablesTo>(inherit: true))
				{
					return true;
				}
				return false;
			}
			finally
			{
				Release();
			}
		}

		private static void QueryFields(int objIdx)
		{
			TypeProperties typeProperties = deconObjs[objIdx].type.GetTypeProperties();
			for (int i = 0; i < typeProperties.fields.Length; i++)
			{
				deconMems[memQty].key.index = i;
				deconObjs[objIdx].memQty++;
				memQty++;
				ValidateMemberCap(memQty);
			}
		}

		private static void DeconstructFields(int objIdx, int startmi)
		{
			TypeProperties typeProperties = deconObjs[objIdx].type.GetTypeProperties();
			int num = deconObjs[objIdx].memQty - (startmi - deconObjs[objIdx].memIdx);
			for (int i = 0; i < num; i++)
			{
				int num2 = startmi + i;
				int index = deconMems[num2].key.index;
				FieldProperties fieldProperties = typeProperties.fields[index];
				deconMems[num2].name = fieldProperties.fullName;
				DeconstructFieldProperties(fieldProperties, objIdx, ref deconMems[num2].val);
			}
		}

		private static void DeconstructFieldProperties(FieldProperties fProps, int objIdx, ref DeconstructedMember.Value deconVal)
		{
			if (fProps.GetObject != null)
			{
				DeconstructObjectMember(fProps.GetObject(deconObjs[objIdx].obj), objIdx, ref deconVal);
			}
			else if (fProps.GetPrimitive != null)
			{
				DeconstructPrimitiveMember(fProps.GetPrimitive(deconObjs[objIdx].obj), fProps.typeCode, objIdx, ref deconVal);
			}
			else
			{
				UnityEngine.Debug.LogError("No Getter Found!");
			}
		}

		private static void DeconstructIndexedFieldProperties(FieldProperties fProps, int arrIdx, int objIdx, ref DeconstructedMember.Value deconVal)
		{
			if (fProps.GetObjectIndexed != null)
			{
				DeconstructObjectMember(fProps.GetObjectIndexed(deconObjs[objIdx].obj, arrIdx), objIdx, ref deconVal);
			}
			else if (fProps.GetPrimitiveIndexed != null)
			{
				DeconstructPrimitiveMember(fProps.GetPrimitiveIndexed(deconObjs[objIdx].obj, arrIdx), fProps.typeCode, objIdx, ref deconVal);
			}
			else
			{
				UnityEngine.Debug.LogError("No Getter Found!");
			}
		}

		private static void DeconstructPrimitiveMember(primitive val, TypeCode typeCode, int objIdx, ref DeconstructedMember.Value deconVal)
		{
			deconVal.typeCode = (byte)typeCode;
			deconVal.prim = val;
		}

		private static void DeconstructObjectMember(object val, int objIdx, ref DeconstructedMember.Value deconVal)
		{
			TypeCode typeCode = Convert.GetTypeCode(val);
			if (typeCode != 0)
			{
				if (typeCode != TypeCode.Object && typeCode != TypeCode.String)
				{
					DeconstructPrimitiveMember(new primitive(val, typeCode), typeCode, objIdx, ref deconVal);
					return;
				}
				deconVal.typeCode = 1;
				deconVal.index = Deconstruct(val, objIdx);
				if (deconVal.index != -1)
				{
					return;
				}
			}
			deconVal.typeCode = 0;
		}

		private static void TryDeconstructPrefab(GameObject go, UnityEngine.Component comp, ref int runningPrefabIdx)
		{
			Transform transform;
			if ((object)comp != null)
			{
				transform = comp.transform;
			}
			else
			{
				if ((object)go == null)
				{
					return;
				}
				transform = go.transform;
			}
			transform.GetComponentsInParent(includeInactive: true, prefabCompBuffer);
			if (prefabCompBuffer.Count == 0)
			{
				return;
			}
			Serializer_Prefab serializer_Prefab = prefabCompBuffer[0];
			prefabCompBuffer.Clear();
			_ = serializer_Prefab.resourcePath;
			for (int i = 0; i < runningPrefabIdx; i++)
			{
				if ((object)deconPrefabs[i].instance == serializer_Prefab)
				{
					return;
				}
			}
			int num = runningPrefabIdx++;
			ValidatePrefabCap(num);
			deconPrefabs[num].instance = serializer_Prefab;
			for (int j = 0; j < num; j++)
			{
				if (deconPrefabs[j].instance.IsAncestorOf(serializer_Prefab) && deconPrefabs[j].order >= deconPrefabs[num].order)
				{
					deconPrefabs[num].order = (byte)(deconPrefabs[j].order + 1);
				}
			}
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void StartLogging(string logName, bool serialising, string path)
		{
			try
			{
				string text = string.Format("Srz {0}{1} ({2})", DateTime.Now.ToString("dd-MM-yy HH-mm-ss.ffff"), serialising ? "" : " (de)", logName);
				if (path == null)
				{
					path = text;
					char[] invalidFileNameChars = Path.GetInvalidFileNameChars();
					foreach (char oldChar in invalidFileNameChars)
					{
						path = path.Replace(oldChar, '_');
					}
					path = Paths.Make(logFolderPath, path + ".log");
				}
				debugLog = File.CreateText(path);
				debugLog.Write(text);
				debugLog.Flush();
				instanceCounts = new Dictionary<Type, int>(400);
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogFormat("Serializer could not begin logging due to {0}", ex);
			}
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void LogDeconstructionStart()
		{
			if (debugLog != null)
			{
				debugLog.Write("\n\nDeconstructing...\n\n");
				debugLog.Flush();
			}
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void LogObjectDeconstruct(int idx, int ownerIdx, int prefabQty)
		{
			if (debugLog == null)
			{
				return;
			}
			if (idx >= 0)
			{
				debugLog.Write("[{0:D5}] ", idx);
			}
			else
			{
				debugLog.WriteFixed(8, "");
			}
			foreach (string item in logStack.Reverse())
			{
				debugLog.Write(item);
			}
			debugLog.Write(" = ");
			switch (idx)
			{
			case -1:
				debugLog.Write("null");
				break;
			case -2:
				debugLog.Write("excluded");
				break;
			default:
			{
				if (idx == ownerIdx)
				{
					debugLog.Write("self");
					break;
				}
				debugLog.Write("({0}) ", deconObjs[idx].type.PrettyName());
				if (deconObjs[idx].obj is ICollection collection)
				{
					debugLog.Write('(');
					debugLog.Write("size: ");
					debugLog.Write(collection.Count);
					debugLog.Write(')');
				}
				else if (deconObjs[idx].obj is string str)
				{
					debugLog.Write('"');
					debugLog.WriteCropped(13, str);
					debugLog.Write('"');
				}
				else if (typeof(Type).IsAssignableFrom(deconObjs[idx].type))
				{
					debugLog.Write(((Type)deconObjs[idx].obj).PrettyName());
				}
				else if (Thread.CurrentThread.ManagedThreadId == mainThreadID)
				{
					debugLog.WriteCropped(15, deconObjs[idx].obj.ToString());
				}
				else
				{
					debugLog.Write("(can't stringify off the main thread)");
				}
				Transform transform = null;
				GameObject gameObject;
				UnityEngine.Component component;
				if ((gameObject = deconObjs[idx].obj as GameObject) != null)
				{
					transform = gameObject.transform;
				}
				else if ((component = deconObjs[idx].obj as UnityEngine.Component) != null)
				{
					transform = component.transform;
				}
				if (!(transform != null))
				{
					break;
				}
				for (int i = 0; i < prefabQty; i++)
				{
					if ((object)deconPrefabs[i].instance == transform)
					{
						debugLog.Write(" (prefab: \"");
						debugLog.Write(deconPrefabs[i].instance.resourcePath);
						debugLog.Write("\")");
						break;
					}
				}
				break;
			}
			}
			debugLog.Write('\n');
			debugLog.Flush();
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void LogPrimParse(string fieldName, DeconstructedMember.Value valRec)
		{
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void LogPrimParse(DeconstructedMember.Value valRec)
		{
			if (debugLog == null)
			{
				return;
			}
			TypeCode typeCode = (TypeCode)valRec.typeCode;
			debugLog.WriteFixed(8, "");
			foreach (string item in logStack.Reverse())
			{
				debugLog.Write(item);
			}
			debugLog.Write(" = ({0}) {1}\n", typeCode, valRec.prim.ToString(typeCode));
			debugLog.Flush();
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void LogPushMember(string name)
		{
			if (debugLog != null)
			{
				logStack.Push("." + name);
			}
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void LogPushMemberParse(int idx)
		{
			if (debugLog != null)
			{
				logStack.Push($"[{idx:D2}]");
			}
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void LogPushMemberParse(bool key)
		{
			if (debugLog != null)
			{
				logStack.Push(key ? ".key" : ".val");
			}
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void LogPopMember()
		{
			if (debugLog != null)
			{
				logStack.Pop();
			}
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void LogPrefabReadWriteStart()
		{
			if (debugLog != null)
			{
				debugLog.Write("\n\n{0} prefabs...\n\n", prefabQty);
				debugLog.Flush();
			}
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void LogPrefabReadWrite(long pos, string prefabPath, string parentPath, string name, Vector3 position, Exception exc = null)
		{
			if (debugLog != null)
			{
				debugLog.Write("{0:D7}: \"{1}\" => \"{2}/", pos, prefabPath, parentPath);
				debugLog.Write(name);
				debugLog.Write("\" (local pos: {0:F2}, {1:F2}, {2:F2})", position.x, position.y, position.z);
				if (exc != null)
				{
					debugLog.Write(" {0}", exc.Message);
				}
				debugLog.Write('\n');
				debugLog.Flush();
			}
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void LogObjectReadWriteStart()
		{
			if (debugLog != null)
			{
				debugLog.Write("\n\n{0} objects and {1} members...\n\n", objQty, memQty);
			}
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void LogObjectReadWrite(long pos, int idx, Type type)
		{
			if (debugLog != null)
			{
				debugLog.Write("{0:D7}: [{1:D5}]\n", pos, idx);
				Type type2 = type;
				while ((object)type2 != typeof(object) && (object)type2 != typeof(ValueType))
				{
					int value = 0;
					instanceCounts.TryGetValue(type2, out value);
					instanceCounts[type2] = value + 1;
					type2 = type2.BaseType;
				}
				debugLog.Flush();
			}
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void LogArrMemberReadWrite(long pos, int ind, string name, DeconstructedMember.Value valRec)
		{
			if (debugLog != null)
			{
				debugLog.Write("{0:D7}: \t[{1:D2}] => ", pos, ind);
				debugLog.WriteFixed(15, name);
				debugLog.Write(" = ");
			}
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void LogListMemberReadWrite(long pos, int mi, DeconstructedMember.Value valRec)
		{
			if (debugLog != null)
			{
				debugLog.Write("{0:D7}: \t[{1:D2}] => ", pos, mi);
			}
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void LogDictMemberReadWrite(long pos, DeconstructedMember.Value keyRec, DeconstructedMember.Value valRec)
		{
			if (debugLog != null)
			{
				debugLog.Write("{0:D7}: \tkey => ", pos);
				debugLog.Write("{0:D7}: \tval => ", pos);
			}
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void LogRegularMemberReadWrite(long pos, string name, DeconstructedMember.Value valRec)
		{
			if (debugLog != null)
			{
				debugLog.Write("{0:D7}: \t", pos);
				debugLog.WriteFixed(15, name);
				debugLog.Write(" = ");
			}
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void LogMemberReadWrite(DeconstructedMember.Value valRec)
		{
			TypeCode typeCode = (TypeCode)valRec.typeCode;
			if (typeCode == TypeCode.Empty)
			{
				goto IL_0053;
			}
			if (typeCode == TypeCode.Object || typeCode == TypeCode.String)
			{
				if (valRec.index == -1)
				{
					goto IL_0053;
				}
				if (valRec.index == -2)
				{
					debugLog.Write("excluded\n");
				}
				else
				{
					debugLog.Write("[{0:D5}]\n", valRec.index);
				}
			}
			else
			{
				debugLog.Write("({0}) {1}\n", typeCode, valRec.prim.ToString(typeCode));
			}
			goto IL_0086;
			IL_0086:
			debugLog.Flush();
			return;
			IL_0053:
			debugLog.Write("null\n");
			goto IL_0086;
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void LogFailedReacquisition(Type type, string path, int idx)
		{
			if (debugLog != null)
			{
				debugLog.Write("Failed to reacquire [{0:D5}] ", idx);
				debugLog.Write(type.PrettyName());
				debugLog.Write(" at \"");
				debugLog.Write(path);
				debugLog.Write("\"\n");
				debugLog.Flush();
			}
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void LogFailedReconstruction(Type type, int idx)
		{
			if (debugLog != null)
			{
				debugLog.Write("Failed to reconstruct ");
				debugLog.Write(type.PrettyName());
				debugLog.Write(" [{0:D5}]\n", idx);
				debugLog.Flush();
			}
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void LogException(Exception exc, int idx)
		{
			if (debugLog != null)
			{
				debugLog.Write("\nAt object [{0:D5}], got exception {1}\n", idx, exc);
				debugLog.Flush();
			}
		}

		[Conditional("CS_SERIALIZER_LOG")]
		private static void EndLogging(string overrideLogPath)
		{
			if (debugLog == null)
			{
				return;
			}
			debugLog.Write("\nInstance counts ({0}):\n\n", instanceCounts.Count);
			foreach (KeyValuePair<string, int> item in from ic in instanceCounts
				select new KeyValuePair<string, int>(ic.Key.PrettyName(), ic.Value) into ic
				orderby ic.Value descending
				select ic)
			{
				debugLog.Write("\t{0, -45}{1}\n", item.Key, item.Value);
			}
			debugLog.Flush();
			debugLog.Close();
			debugLog = null;
			instanceCounts = null;
		}

		public static GameObject GameObjectFind(string sceneName, string path)
		{
			string key = sceneName + "/" + path;
			if (spawnedPrefabInstances.TryGetValue(key, out var value))
			{
				return value;
			}
			Scene sceneByName = SceneManager.GetSceneByName(sceneName);
			if (!sceneByName.IsValid())
			{
				return null;
			}
			int num = 1;
			int num2 = 0;
			int num3 = num;
			while (num3 < path.Length && path[num3] != '/')
			{
				num3++;
				num2++;
			}
			string text = path.Substring(num, num2);
			path = path.Remove(0, num2 + 1);
			if (path.Length > 0)
			{
				path = path.Remove(0, 1);
			}
			GameObject result = null;
			GameObject[] rootGameObjects = sceneByName.GetRootGameObjects();
			foreach (GameObject gameObject in rootGameObjects)
			{
				if (gameObject.name == text)
				{
					Transform transform = gameObject.transform.Find(path);
					if ((bool)transform)
					{
						result = transform.gameObject;
						break;
					}
				}
			}
			return result;
		}

		private static void ReadPrefabInstance(BinaryReader reader)
		{
			_ = reader.BaseStream.Position;
			string text = "";
			try
			{
				GameObject gameObject = null;
				text = reader.ReadString();
				string text2 = (reader.ReadBoolean() ? reader.ReadString() : null);
				gameObject = ((text2 == null) ? Resources.Load<GameObject>(text) : Type.GetType(text2, throwOnError: true).GetAttr<ExternalPrefabReacquisitor>(inherit: true).Reacquire(text, reader));
				if ((object)gameObject == null)
				{
					throw new Exception("Could not find prefab at recorded path '" + text + "'");
				}
				if (unityObjectSerializer != null)
				{
					unityObjectSerializer.DeserializePrefabInstance(reader, gameObject);
				}
				else
				{
					DeserializePrefabInstanceDefault(reader, gameObject, deserializeParentPath: true, UnityEngine.Object.Instantiate(gameObject));
				}
			}
			catch (Exception ex)
			{
				throw ex;
			}
		}

		private static void ReadObject(BinaryReader reader, ref DeconstructedObject record, int objIdx)
		{
			record.type = Type.GetType(reader.ReadString(), throwOnError: true);
			if (record.type == typeof(string))
			{
				record.obj = reader.ReadString();
				return;
			}
			if (record.type.IsEnum)
			{
				record.obj = Enum.ToObject(record.type, reader.ReadUInt64());
				return;
			}
			if (typeof(ScriptableResource).IsAssignableFrom(record.type) && reader.ReadBoolean())
			{
				string path = reader.ReadString();
				ExternalResourceAcquisitor attr;
				if ((attr = record.type.GetAttr<ExternalResourceAcquisitor>(inherit: true)) != null)
				{
					record.obj = attr.Reacquire(path, record.type, reader);
				}
				else
				{
					record.obj = Resources.Load<UnityEngine.Object>(path);
				}
				_ = record.obj;
				return;
			}
			if (typeof(Type).IsAssignableFrom(record.type))
			{
				record.obj = Type.GetType(reader.ReadString());
				return;
			}
			if (typeof(FieldInfo).IsAssignableFrom(record.type))
			{
				string typeName = reader.ReadString();
				string name = reader.ReadString();
				Type type = Type.GetType(typeName);
				record.obj = type.GetField(name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				return;
			}
			record.memQty = reader.ReadInt32();
			try
			{
				IExternalConstructor value;
				if (typeof(GameObject).IsAssignableFrom(record.type))
				{
					if (unityObjectSerializer != null)
					{
						record.obj = unityObjectSerializer.DeserializeGameObject(reader);
					}
					else
					{
						record.obj = DeserializeGameObjectDefault(reader);
					}
					if (record.obj != null)
					{
					}
				}
				else if (typeof(UnityEngine.Component).IsAssignableFrom(record.type))
				{
					if (unityObjectSerializer != null)
					{
						record.obj = unityObjectSerializer.DeserializeComponent(reader, record.type);
					}
					else
					{
						record.obj = DeserializeComponentDefault(reader, record.type);
					}
					if (record.obj != null)
					{
					}
				}
				else if ((value = record.type.GetAttr<ExternalConstructor>()) != null)
				{
					record.obj = value.Reconstruct(record.type, reader);
				}
				else if (extraExternalConstructor.TryGetValue(record.type, out value))
				{
					record.obj = value.Reconstruct(record.type, reader);
				}
				else if (typeof(ISelfConstructor).IsAssignableFrom(record.type))
				{
					constrParams[0] = reader;
					record.obj = Activator.CreateInstance(record.type, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, constrParams, null);
				}
				else if (typeof(ScriptableObject).IsAssignableFrom(record.type))
				{
					record.obj = ScriptableObject.CreateInstance(record.type);
				}
				else
				{
					if (record.type.IsArray)
					{
						int num = reader.ReadInt32();
						Array array = (Array)(record.obj = Array.CreateInstance(record.type.GetElementType(), num));
						if (record.type.GetElementType().IsPrimitive)
						{
							if (array is byte[] buffer)
							{
								reader.Read(buffer, 0, record.memQty);
							}
							else
							{
								int num2 = record.memQty * record.type.GetElementType().PrimitiveSize();
								for (int i = 0; i < num2; i += bufferBuffer.Length)
								{
									int count = Mathf.Min(bufferBuffer.Length, num2 - i);
									reader.Read(bufferBuffer, 0, count);
									Buffer.BlockCopy(bufferBuffer, 0, array, i, count);
								}
							}
							record.memQty = 0;
							return;
						}
						record.memIdx = memQty;
						record.elementSize = reader.ReadInt32();
						int num3 = record.memIdx;
						if (record.type.GetTypeProperties().cachedTypeIsValue)
						{
							for (int j = 0; j < num; j++)
							{
								for (int k = 0; k < record.elementSize; k++)
								{
									deconMems[num3].name = reader.ReadString();
									ReadMemberValue(reader, ref deconMems[num3].val);
									num3++;
								}
							}
							record.memQty = num3 - record.memIdx;
						}
						else
						{
							for (int l = 0; l < record.memQty; l++)
							{
								_ = reader.BaseStream.Position;
								int num4 = record.memIdx + l;
								ReadMemberValue(reader, ref deconMems[num4].val);
								deconMems[num4].key.custom = reader.ReadBoolean();
							}
						}
						memQty += record.memQty;
						return;
					}
					record.obj = Activator.CreateInstance(record.type, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, null, null);
				}
				if (record.memQty == 0)
				{
					return;
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogException(ex);
				throw ex;
			}
			record.memIdx = memQty;
			memQty += record.memQty;
			ValidateMemberCap(record.memIdx + record.memQty);
			for (int m = 0; m < record.memQty; m++)
			{
				_ = reader.BaseStream.Position;
				int num5 = record.memIdx + m;
				deconMems[num5].name = reader.ReadString();
				ReadMemberValue(reader, ref deconMems[num5].val);
				deconMems[num5].key.custom = reader.ReadBoolean();
			}
		}

		private static void ReadMemberValue(BinaryReader reader, ref DeconstructedMember.Value val)
		{
			val.typeCode = reader.ReadByte();
			TypeCode typeCode = (TypeCode)val.typeCode;
			if (typeCode != 0 && !reader.TryRead(typeCode, ref val.prim))
			{
				val.index = reader.ReadInt32();
			}
		}

		private static void ReconstructMembers(BinaryReader reader, ref DeconstructedObject record)
		{
			if (record.obj == null || record.memQty == 0)
			{
				return;
			}
			int i = 0;
			object val;
			if (record.obj is Array { Length: var length } array)
			{
				int num = record.memIdx;
				TypeProperties typeProperties = record.type.GetTypeProperties();
				object[] array2 = (typeProperties.cachedTypeIsValue ? null : (record.obj as object[]));
				if (array2 == null)
				{
					for (int j = 0; j < length; j++)
					{
						for (int k = 0; k < record.elementSize; k++)
						{
							if (!ReconstructMemberValue(deconMems[num].val, out val))
							{
								continue;
							}
							FieldProperties[] fields = typeProperties.fields;
							foreach (FieldProperties fieldProperties in fields)
							{
								if (fieldProperties.fullName == deconMems[num].name)
								{
									fieldProperties.SetObjectValueIndexed(array, j, val);
									break;
								}
							}
							num++;
						}
					}
				}
				else
				{
					for (int m = 0; m < length; m++)
					{
						ReconstructMemberValue(deconMems[record.memIdx + m].val, out val);
						array2[m] = val;
					}
				}
				return;
			}
			if (record.obj is GameObject gameObject)
			{
				int num2 = record.memIdx + i++;
				gameObject.SetActive(deconMems[num2].val.prim.@bool);
			}
			else if (record.obj is UnityEngine.Component component)
			{
				int num3 = record.memIdx + i++;
				component.gameObject.SetActive(deconMems[num3].val.prim.@bool);
				if (!record.type.HasAttr<ExcludeEnabled>() && record.obj is MonoBehaviour monoBehaviour)
				{
					num3 = record.memIdx + i++;
					monoBehaviour.enabled = deconMems[num3].val.prim.@bool;
				}
			}
			FieldProperties[] fields2 = record.type.GetTypeProperties().fields;
			for (; i < record.memQty; i++)
			{
				int num4 = record.memIdx + i;
				if (deconMems[num4].key.custom || !ReconstructMemberValue(deconMems[num4].val, out val))
				{
					continue;
				}
				FieldProperties[] fields = fields2;
				foreach (FieldProperties fieldProperties2 in fields)
				{
					if (fieldProperties2.fullName == deconMems[num4].name)
					{
						try
						{
							fieldProperties2.SetObjectValue(record.obj, val);
						}
						catch (Exception exception)
						{
							UnityEngine.Debug.LogException(exception);
							UnityEngine.Debug.Log("This is likely due to trying to serialize a nullable type");
						}
						break;
					}
				}
			}
		}

		private static void SelfRecompose(BinaryReader reader, int idx, ref DeconstructedObject record)
		{
			if (!(record.obj is ISelfComposer selfComposer))
			{
				return;
			}
			for (int i = 0; i < record.memQty; i++)
			{
				int num = record.memIdx + i;
				if (deconMems[num].key.custom && ReconstructMemberValue(deconMems[num].val, out var val))
				{
					customMemberBuffer.members[deconMems[num].name] = val;
				}
			}
			selfComposer.Recompose(customMemberBuffer);
			customMemberBuffer.members.Clear();
		}

		private static bool ReconstructMemberValue(DeconstructedMember.Value decon, out object val)
		{
			val = null;
			TypeCode typeCode = (TypeCode)decon.typeCode;
			switch (typeCode)
			{
			case TypeCode.Object:
			case TypeCode.String:
				if (decon.index == -2)
				{
					return false;
				}
				if (decon.index != -1)
				{
					val = deconObjs[decon.index].obj;
				}
				break;
			default:
				val = decon.prim.Get(typeCode);
				break;
			case TypeCode.Empty:
				break;
			}
			return true;
		}

		public static void SerializePrefabInstanceDefault(BinaryWriter writer, Serializer_Prefab prefabInstance)
		{
			Transform parent = prefabInstance.transform.parent;
			string name = prefabInstance.name;
			bool activeSelf = prefabInstance.gameObject.activeSelf;
			Vector3 position = prefabInstance.transform.position;
			Quaternion rotation = prefabInstance.transform.rotation;
			Vector3 localScale = prefabInstance.transform.localScale;
			writer.Write(prefabInstance.gameObject.scene.name);
			writer.Write(parent ? parent.gameObject.GetScenePath() : "");
			writer.Write(name);
			writer.Write(activeSelf);
			writer.Write(position.x);
			writer.Write(position.y);
			writer.Write(position.z);
			writer.Write(rotation.x);
			writer.Write(rotation.y);
			writer.Write(rotation.z);
			writer.Write(rotation.w);
			writer.Write(localScale.x);
			writer.Write(localScale.y);
			writer.Write(localScale.z);
		}

		public static GameObject DeserializePrefabInstanceDefault(BinaryReader reader, GameObject prefab, bool deserializeParentPath, GameObject instance)
		{
			string text = reader.ReadString();
			string text2 = reader.ReadString();
			string text3 = reader.ReadString();
			bool active = reader.ReadBoolean();
			Vector3 position = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
			Quaternion rotation = new Quaternion(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
			Vector3 localScale = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
			if ((bool)instance)
			{
				GameObject gameObject = GameObjectFind(text, text2);
				if ((object)gameObject == null)
				{
					Scene sceneByName = SceneManager.GetSceneByName(text);
					if (sceneByName.IsValid())
					{
						SceneManager.MoveGameObjectToScene(instance, sceneByName);
					}
				}
				else
				{
					instance.transform.SetParent(gameObject.transform);
				}
				instance.name = text3;
				instance.SetActive(active);
				instance.transform.position = position;
				instance.transform.rotation = rotation;
				instance.transform.localScale = localScale;
				AddSpawnedPrefabInstance(text + "/" + text2 + "/" + text3, instance);
			}
			return instance;
		}

		private static void AddSpawnedPrefabInstance(string fullname, GameObject instance)
		{
			spawnedPrefabInstances.Add(fullname, instance);
			foreach (Transform item in instance.transform)
			{
				AddSpawnedPrefabInstance(fullname + "/" + item.name, item.gameObject);
			}
		}

		public static void SerializeGameObjectDefault(BinaryWriter writer, GameObject gameObject)
		{
			writer.Write(gameObject.scene.name);
			writer.Write(gameObject.GetScenePath());
		}

		public static void SerializeComponentDefault(BinaryWriter writer, UnityEngine.Component component)
		{
			SerializeGameObjectDefault(writer, component.gameObject);
		}

		public static GameObject DeserializeGameObjectDefault(BinaryReader reader)
		{
			string sceneName = reader.ReadString();
			string path = reader.ReadString();
			return GameObjectFind(sceneName, path);
		}

		public static UnityEngine.Component DeserializeComponentDefault(BinaryReader reader, Type type)
		{
			GameObject gameObject = DeserializeGameObjectDefault(reader);
			if ((bool)gameObject)
			{
				return gameObject.GetComponent(type);
			}
			return null;
		}

		private static bool WritePrefabInstances(BinaryWriter writer, byte order, int prefabQty)
		{
			bool result = false;
			for (int i = 0; i < prefabQty; i++)
			{
				if (deconPrefabs[i].order == order)
				{
					result = true;
					Serializer_Prefab instance = deconPrefabs[i].instance;
					string resourcePath = instance.resourcePath;
					writer.Write(resourcePath);
					TypeProperties typeProperties = instance.GetType().GetTypeProperties();
					ExternalPrefabReacquisitor attr = typeProperties.GetAttr<ExternalPrefabReacquisitor>(inherit: true);
					writer.Write(attr != null);
					if (attr != null)
					{
						writer.Write(typeProperties.assemblyQualifiedName);
						attr.Deacquire(instance, writer);
					}
					if (unityObjectSerializer != null)
					{
						unityObjectSerializer.SerializePrefabInstance(writer, instance);
					}
					else
					{
						SerializePrefabInstanceDefault(writer, instance);
					}
				}
			}
			return result;
		}

		private static void WriteObject(BinaryWriter writer, int idx)
		{
			Type type = deconObjs[idx].type;
			TypeProperties typeProperties = type.GetTypeProperties();
			object obj = deconObjs[idx].obj;
			writer.Write(typeProperties.assemblyQualifiedName);
			switch (deconObjs[idx].hint)
			{
			case 1:
				writer.Write((string)obj);
				return;
			case 2:
				writer.Write(Convert.ToInt64(obj));
				return;
			case 3:
			{
				ScriptableResource scriptableResource = (ScriptableResource)obj;
				bool flag = scriptableResource.resourcePath != null;
				writer.Write(flag);
				if (flag)
				{
					writer.Write(scriptableResource.resourcePath);
					ExternalResourceAcquisitor attr;
					if ((attr = typeProperties.GetAttr<ExternalResourceAcquisitor>(inherit: true)) != null)
					{
						attr.Deacquire(scriptableResource, type, writer);
					}
					return;
				}
				break;
			}
			case 4:
			{
				TypeProperties typeProperties3 = ((Type)obj).GetTypeProperties();
				writer.Write(typeProperties3.assemblyQualifiedName);
				return;
			}
			case 5:
			{
				FieldInfo fieldInfo = (FieldInfo)obj;
				TypeProperties typeProperties2 = fieldInfo.DeclaringType.GetTypeProperties();
				writer.Write(typeProperties2.assemblyQualifiedName);
				writer.Write(fieldInfo.Name);
				return;
			}
			}
			writer.Write(deconObjs[idx].memQty);
			switch (deconObjs[idx].hint)
			{
			case 6:
			{
				if (obj is byte[] array)
				{
					writer.Write(array.Length);
					writer.Write(array, 0, deconObjs[idx].memQty);
					return;
				}
				Array array2 = (Array)obj;
				writer.Write(array2.Length);
				if (typeProperties.cachedTypeIsPrimitive)
				{
					int num = deconObjs[idx].memQty * typeProperties.arrayType.PrimitiveSize();
					for (int i = 0; i < num; i += bufferBuffer.Length)
					{
						int count = Mathf.Min(bufferBuffer.Length, num - i);
						Buffer.BlockCopy(array2, i, bufferBuffer, 0, count);
						writer.Write(bufferBuffer, 0, count);
					}
					return;
				}
				_ = typeProperties.fields.Length;
				bool cachedTypeIsValue = typeProperties.cachedTypeIsValue;
				writer.Write(deconObjs[idx].elementSize);
				if (cachedTypeIsValue)
				{
					int num2 = deconObjs[idx].memIdx;
					for (int j = 0; j < array2.Length; j++)
					{
						for (int k = 0; k < deconObjs[idx].elementSize; k++)
						{
							writer.Write(deconMems[num2].name);
							WriteMemberValue(writer, deconMems[num2].val);
							num2++;
						}
					}
				}
				else
				{
					for (int l = 0; l < deconObjs[idx].memQty; l++)
					{
						int num3 = deconObjs[idx].memIdx + l;
						WriteMemberValue(writer, deconMems[num3].val);
						writer.Write(deconMems[num3].key.custom);
					}
				}
				return;
			}
			case 7:
			{
				GameObject gameObject = (GameObject)obj;
				if (unityObjectSerializer != null)
				{
					unityObjectSerializer.SerializeGameObject(writer, gameObject);
				}
				else
				{
					SerializeGameObjectDefault(writer, gameObject);
				}
				break;
			}
			case 8:
			{
				UnityEngine.Component component = (UnityEngine.Component)obj;
				if (unityObjectSerializer != null)
				{
					unityObjectSerializer.SerializeComponent(writer, component);
				}
				else
				{
					SerializeComponentDefault(writer, component);
				}
				break;
			}
			default:
			{
				IExternalConstructor value;
				if ((value = typeProperties.GetAttr<ExternalConstructor>()) != null)
				{
					value.Deconstruct(obj, type, writer);
				}
				else if (extraExternalConstructor.TryGetValue(type, out value))
				{
					value.Deconstruct(obj, type, writer);
				}
				else if (obj is ISelfConstructor selfConstructor)
				{
					selfConstructor.Deconstruct(writer);
				}
				break;
			}
			}
			for (int m = 0; m < deconObjs[idx].memQty; m++)
			{
				int num4 = deconObjs[idx].memIdx + m;
				writer.Write(deconMems[num4].name);
				WriteMemberValue(writer, deconMems[num4].val);
				writer.Write(deconMems[num4].key.custom);
			}
		}

		private static void WriteMemberValue(BinaryWriter writer, DeconstructedMember.Value val)
		{
			writer.Write(val.typeCode);
			TypeCode typeCode = (TypeCode)val.typeCode;
			if (typeCode != 0 && !writer.TryWrite(typeCode, val.prim))
			{
				writer.Write(val.index);
			}
		}
	}
	public class Serializer_ModelPrefab : MonoBehaviour
	{
		[ReadOnly]
		public string path;

		private void Awake()
		{
			UnityEngine.Object.DestroyImmediate(this, allowDestroyingAssets: true);
		}
	}
	public class Serializer_ModelPrefabList : ScriptableResource
	{
		private void Awake()
		{
			UnityEngine.Object.DestroyImmediate(this, allowDestroyingAssets: true);
		}
	}
	public class Serializer_Prefab : MonoBehaviour
	{
		[ReadOnly]
		[SerializeField]
		private string _resourcePath;

		public string resourcePath => _resourcePath;

		protected virtual bool requiresResourceFolder => true;
	}
}
namespace Coatsink.Common.Internal
{
	public static class HagletDynamicSupportLog
	{
		[Conditional("CS_DEBUG")]
		[Conditional("UNITY_EDITOR")]
		[Conditional("DEVELOPMENT_BUILD")]
		[Conditional("HG_DEBUG")]
		public static void StartRetainLog(ref StringBuilder log, bool force)
		{
			log = new StringBuilder(1000);
		}

		[Conditional("CS_DEBUG")]
		[Conditional("UNITY_EDITOR")]
		[Conditional("DEVELOPMENT_BUILD")]
		[Conditional("HG_DEBUG")]
		public static void PrependConsoleHeader(this StringBuilder log)
		{
			log?.Insert(0, "Building haglet dynamic support, details below...\nThis log can be hidden in Unity via the Haglet menu.\n");
		}

		[Conditional("CS_DEBUG")]
		[Conditional("UNITY_EDITOR")]
		[Conditional("DEVELOPMENT_BUILD")]
		[Conditional("HG_DEBUG")]
		public static void PrependWarningSummary(this StringBuilder log, int warningCount, HagletDynamicSupport.IteratorMethodInfo.Warning warningTypes)
		{
			if (log == null)
			{
				return;
			}
			if (warningCount == 0)
			{
				log.Insert(0, $"\nNo warnings.\n\n");
				return;
			}
			if ((warningTypes & HagletDynamicSupport.IteratorMethodInfo.Warning.UnresettableLocal) != 0)
			{
				log.Insert(0, "\n\t\tThis can be due to the variable not being assigned a value outside of a locally defined lambda.\n");
				log.Insert(0, $"\t{HagletDynamicSupport.IteratorMethodInfo.Warning.UnresettableLocal.ToString()}:\n\t\tLocal variable cannot be reset.\n\t\tResetting this routine WILL NOT affect this variable's value. ");
			}
			if ((warningTypes & HagletDynamicSupport.IteratorMethodInfo.Warning.MissingThisField) != 0)
			{
				log.Insert(0, "\n\t\tThis can be due to the method lacking any tuse of its fellow instance fields or methods.\n");
				log.Insert(0, $"\t{HagletDynamicSupport.IteratorMethodInfo.Warning.MissingThisField.ToString()}:\n\t\tNo 'this' field is present.\n\t\tThis routine will not appear to have an owner, or be able to use the co-routine mechanism,\n\t\tdespite being an instance method of a Monobehaviour subclass. ");
			}
			log.Insert(0, $"\n{warningCount} warning(s) of the following type(s):\n");
		}

		[Conditional("CS_DEBUG")]
		[Conditional("UNITY_EDITOR")]
		[Conditional("DEVELOPMENT_BUILD")]
		[Conditional("HG_DEBUG")]
		public static void PrependAssemblyLoadResult(this StringBuilder log, int cacheSize, int editorCacheSize, Exception exc)
		{
			log?.Insert(0, "\nHG_FORCE_RUNTIME_SUPPORT_REGEN defined. Dynamic support will be built now...\n");
		}

		[Conditional("CS_DEBUG")]
		[Conditional("UNITY_EDITOR")]
		[Conditional("DEVELOPMENT_BUILD")]
		[Conditional("HG_DEBUG")]
		public static void AppendServerCodeGenFail(this StringBuilder log, Type iteratorType, Exception exc)
		{
			if (log != null)
			{
				log.Append("Failed to use code-generation to create a server for '");
				log.Append(iteratorType.FullName);
				log.Append("':\n\t");
				log.Append(exc.ToString().Replace("\n", "\n\t"));
				log.Append("\n\n");
			}
		}

		[Conditional("CS_DEBUG")]
		[Conditional("UNITY_EDITOR")]
		[Conditional("DEVELOPMENT_BUILD")]
		[Conditional("HG_DEBUG")]
		public static void AppendServerCreateFail(this StringBuilder log, Type iteratorType, Exception exc)
		{
			if (log != null)
			{
				log.Append("Failed to create a server for '");
				log.Append(iteratorType.FullName);
				log.Append("':\n\t");
				log.Append(exc.ToString().Replace("\n", "\n\t"));
				log.Append("\n\n");
			}
		}

		[Conditional("CS_DEBUG")]
		[Conditional("UNITY_EDITOR")]
		[Conditional("DEVELOPMENT_BUILD")]
		[Conditional("HG_DEBUG")]
		public static void AppendCreateFromTemplateSuccess(this StringBuilder log, HagletDynamicSupport.IteratorMethodInfo method)
		{
			if (log != null)
			{
				log.Append("Created code-generation-based server for '");
				log.Append(method.iteratorType.DeclaringType.FullName);
				log.Append('.');
				log.Append(method.methodName);
				log.Append("'.\n");
			}
		}

		[Conditional("CS_DEBUG")]
		[Conditional("UNITY_EDITOR")]
		[Conditional("DEVELOPMENT_BUILD")]
		[Conditional("HG_DEBUG")]
		public static void AppendCreateFallbackSuccess(this StringBuilder log, HagletDynamicSupport.IteratorMethodInfo method)
		{
			if (log != null)
			{
				log.Append("Created reflection-based server for '");
				log.Append(method.iteratorType.DeclaringType.FullName);
				log.Append('.');
				log.Append(method.methodName);
				log.Append("'.\n");
			}
		}

		[Conditional("CS_DEBUG")]
		[Conditional("UNITY_EDITOR")]
		[Conditional("DEVELOPMENT_BUILD")]
		[Conditional("HG_DEBUG")]
		public static void AppendBlankLine(this StringBuilder log)
		{
			log?.Append('\n');
		}

		[Conditional("CS_DEBUG")]
		[Conditional("UNITY_EDITOR")]
		[Conditional("DEVELOPMENT_BUILD")]
		[Conditional("HG_DEBUG")]
		public static void Complete(this StringBuilder log, int serverCount)
		{
			if (log != null)
			{
				log.Append("Finished with ");
				log.Append(serverCount);
				log.Append(" servers.\n");
				UnityEngine.Debug.Log(log.ToString());
			}
		}
	}
}
namespace Coatsink.Common.Events
{
	public interface IPrepareEvent
	{
		Wait PrepareEvents();
	}
	[Serializable]
	public class Event
	{
		[Serializable]
		private class EventAction
		{
			public MonoBehaviour behaviour;

			public string functionName;

			[NonSerialized]
			public Action<object> action;
		}

		[SerializeField]
		private EventAction[] eventActions;

		public event Action onInvoke;

		public void PrepareInvoke()
		{
			if (eventActions == null)
			{
				eventActions = new EventAction[0];
			}
			EventAction[] array = eventActions;
			foreach (EventAction eventAction in array)
			{
				if (eventAction.behaviour == null)
				{
					continue;
				}
				MethodInfo[] methods = eventAction.behaviour.GetType().GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				foreach (MethodInfo methodInfo in methods)
				{
					if (IsValidMethod(methodInfo) && methodInfo.GetAttr<EventAttribute>().EventName == eventAction.functionName)
					{
						eventAction.action = (Action<object>)methodInfo.CreateDelegate(typeof(Action<object>), eventAction.behaviour);
					}
				}
			}
		}

		public void Invoke()
		{
			try
			{
				EventAction[] array = eventActions;
				foreach (EventAction eventAction in array)
				{
					if (eventAction.action != null && !(eventAction.behaviour == null))
					{
						eventAction.action(this);
					}
				}
				this.onInvoke?.Invoke();
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
		}

		public static bool IsValidMethod(MethodInfo methodInfo)
		{
			if (!methodInfo.HasAttr<EventAttribute>(inherit: true))
			{
				return false;
			}
			ParameterInfo[] parameters = methodInfo.GetParameters();
			if (parameters.Length != 1)
			{
				return false;
			}
			if (parameters[0].GetType() == typeof(object))
			{
				return false;
			}
			return true;
		}
	}
	public class EventAttribute : Attribute
	{
		public string EventName;
	}
}
namespace DebugCat
{
	public class CatScript : MonoBehaviour
	{
		private static CatScript _inst;

		public static CatScript Inst => _inst;

		private void Awake()
		{
			_inst = this;
			base.gameObject.SetActive(value: false);
		}

		public static void SendToCAT(string varName, float val, float lifetime = 2f)
		{
		}
	}
	public class CatWristStub : MonoBehaviour
	{
		private void OnDrawGizmosSelected()
		{
			Vector3 from = new Vector3(0f, 0f, 0f);
			Vector3 vector = new Vector3(0.05f, 0f, 0f);
			Vector3 vector2 = new Vector3(0f, 0.4f, 0f);
			Vector3 to = new Vector3(0.05f, 0.4f, 0f);
			Gizmos.color = Color.red;
			Gizmos.matrix = Matrix4x4.TRS(base.transform.position, base.transform.rotation, base.transform.localScale);
			Gizmos.DrawLine(from, vector2);
			Gizmos.DrawLine(from, vector);
			Gizmos.DrawLine(vector, to);
			Gizmos.DrawLine(vector2, to);
			Gizmos.DrawLine(new Vector3(0.1f, 0.35f), new Vector3(0.25f, 0.35f));
			Gizmos.DrawLine(new Vector3(0.175f, 0.05f), new Vector3(0.175f, 0.35f));
			Gizmos.DrawLine(new Vector3(0.3f, 0.05f), new Vector3(0.3f, 0.35f));
			Gizmos.DrawLine(new Vector3(0.3f, 0.35f), new Vector3(0.45f, 0.35f));
			Gizmos.DrawLine(new Vector3(0.3f, 0.2f), new Vector3(0.375f, 0.2f));
			Gizmos.DrawLine(new Vector3(0.3f, 0.05f), new Vector3(0.45f, 0.05f));
			Gizmos.DrawLine(new Vector3(0.5f, 0.05f), new Vector3(0.65f, 0.35f));
			Gizmos.DrawLine(new Vector3(0.5f, 0.35f), new Vector3(0.65f, 0.05f));
			Gizmos.DrawLine(new Vector3(0.7f, 0.35f), new Vector3(0.85f, 0.35f));
			Gizmos.DrawLine(new Vector3(0.775f, 0.05f), new Vector3(0.775f, 0.35f));
		}
	}
}
