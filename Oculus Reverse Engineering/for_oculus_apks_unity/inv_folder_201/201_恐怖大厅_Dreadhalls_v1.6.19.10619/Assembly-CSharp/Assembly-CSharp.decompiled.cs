#define CHECK_ENTITLEMENT
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization.Formatters.Binary;
using System.Security;
using System.Security.Permissions;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using MapBrushes;
using MapTags;
using ONSPPropagationInterface;
using ONSPPropagationInterface.Unity_Native;
using Oculus.Avatar;
using Oculus.Platform;
using Oculus.Platform.Models;
using OvrTouch.Controllers;
using Triangulator.Geometry;
using UnityEngine;
using UnityEngine.Audio;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Rendering;
using UnityEngine.UI;
using UnityEngine.XR;

[assembly: InternalsVisibleTo("Assembly-CSharp-Editor")]
[assembly: InternalsVisibleTo("Assembly-CSharp-Editor")]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("0.0.0.0")]
[module: UnverifiableCode]
public class FixedTileBorders : MonoBehaviour
{
	public float innerWidth = 0.2f;

	public float innerHeight = 0.2f;

	public float borderWidth = 0.2f;

	public float borderHeight = 0.2f;

	public float innerborderWidth = 0.2f;

	public float innerborderHeight = 0.2f;

	public float textureBorderWidth = 0.2f;

	public float textureBorderHeight = 0.2f;

	public float textureInnerBorderWidth = 0.2f;

	public float textureInnerBorderHeight = 0.2f;

	public float textureInnerWidth = 0.2f;

	public float textureInnerHeight = 0.2f;

	public float xOffset;

	public float yOffset;

	private void Start()
	{
		Mesh mesh = new Mesh();
		Vector3[] vertices = SetVertices();
		mesh.vertices = vertices;
		int[] triangles = new int[150]
		{
			0, 1, 2, 3, 2, 1, 1, 4, 3, 6,
			3, 4, 4, 5, 6, 7, 6, 5, 5, 8,
			7, 10, 7, 8, 8, 9, 10, 11, 10, 9,
			2, 3, 12, 13, 12, 3, 3, 6, 13, 16,
			13, 6, 6, 7, 16, 17, 16, 7, 7, 10,
			17, 20, 17, 10, 10, 11, 20, 21, 20, 11,
			12, 13, 14, 15, 14, 13, 13, 16, 15, 18,
			15, 16, 16, 17, 18, 19, 18, 17, 17, 20,
			19, 22, 19, 20, 20, 21, 22, 23, 22, 21,
			14, 15, 24, 25, 24, 15, 15, 18, 25, 28,
			25, 18, 18, 19, 28, 29, 28, 19, 19, 22,
			29, 32, 29, 22, 22, 23, 32, 33, 32, 23,
			24, 25, 26, 27, 26, 25, 25, 28, 27, 30,
			27, 28, 28, 29, 30, 31, 30, 29, 29, 32,
			31, 34, 31, 32, 32, 33, 34, 35, 34, 33
		};
		mesh.triangles = triangles;
		mesh.uv = new Vector2[36]
		{
			new Vector2(0f, 1f),
			new Vector2(textureBorderWidth, 1f),
			new Vector2(0f, textureBorderHeight + 2f * textureInnerHeight + textureInnerBorderHeight),
			new Vector2(textureBorderWidth, 1f - textureBorderHeight),
			new Vector2(textureBorderWidth + textureInnerWidth, 1f),
			new Vector2(textureBorderWidth + textureInnerWidth + textureInnerBorderWidth, 1f),
			new Vector2(textureBorderWidth + textureInnerWidth, 1f - textureBorderHeight),
			new Vector2(textureBorderWidth + textureInnerWidth + textureInnerBorderWidth, 1f - textureBorderHeight),
			new Vector2(textureBorderWidth + textureInnerWidth * 2f + textureInnerBorderWidth, 1f),
			new Vector2(1f, 1f),
			new Vector2(textureBorderWidth + textureInnerWidth * 2f + textureInnerBorderWidth, 1f - textureBorderHeight),
			new Vector2(1f, 1f - textureBorderHeight),
			new Vector2(0f, 1f - textureBorderHeight - textureInnerHeight),
			new Vector2(textureBorderWidth, 1f - textureBorderHeight - textureInnerHeight),
			new Vector2(0f, textureBorderHeight + textureInnerHeight),
			new Vector2(textureBorderWidth, textureBorderHeight + textureInnerHeight),
			new Vector2(textureBorderWidth + textureInnerWidth, 1f - textureBorderHeight - textureInnerHeight),
			new Vector2(textureBorderWidth + textureInnerWidth + textureInnerBorderWidth, 1f - textureBorderHeight - textureInnerHeight),
			new Vector2(textureBorderWidth + textureInnerWidth, textureBorderHeight + textureInnerHeight),
			new Vector2(textureBorderWidth + textureInnerWidth + textureInnerBorderWidth, textureBorderHeight + textureInnerHeight),
			new Vector2(textureBorderWidth + textureInnerWidth * 2f + textureInnerBorderWidth, 1f - textureBorderHeight - textureInnerHeight),
			new Vector2(1f, 1f - textureBorderHeight - textureInnerHeight),
			new Vector2(textureBorderWidth + textureInnerWidth * 2f + textureInnerBorderWidth, textureBorderHeight + textureInnerHeight),
			new Vector2(1f, 1f - textureBorderHeight - textureInnerHeight - textureInnerBorderHeight),
			new Vector2(0f, textureBorderHeight),
			new Vector2(textureBorderWidth, textureBorderHeight),
			new Vector2(0f, 0f),
			new Vector2(textureBorderWidth, 0f),
			new Vector2(textureBorderWidth + textureInnerWidth, textureBorderHeight),
			new Vector2(textureBorderWidth + textureInnerWidth + textureInnerBorderWidth, textureBorderHeight),
			new Vector2(textureBorderWidth + textureInnerWidth, 0f),
			new Vector2(textureBorderWidth + textureInnerWidth + textureInnerBorderWidth, 0f),
			new Vector2(textureBorderWidth + textureInnerWidth * 2f + textureInnerBorderWidth, textureBorderHeight),
			new Vector2(1f, textureBorderHeight),
			new Vector2(textureBorderWidth + textureInnerWidth * 2f + textureInnerBorderWidth, 0f),
			new Vector2(1f, 0f)
		};
		Vector3[] array = new Vector3[36];
		for (int i = 0; i < 36; i++)
		{
			ref Vector3 reference = ref array[i];
			reference = Vector3.forward;
		}
		mesh.normals = array;
		GetComponent<MeshFilter>().mesh = mesh;
		if ((bool)GetComponent<MeshCollider>())
		{
			GetComponent<MeshCollider>().sharedMesh = GetComponent<MeshFilter>().mesh;
		}
	}

	private void Update()
	{
	}

	private Vector3[] SetVertices()
	{
		return new Vector3[36]
		{
			new Vector3(xOffset, yOffset, 0f),
			new Vector3(borderWidth + xOffset, yOffset, 0f),
			new Vector3(xOffset, borderHeight + yOffset, 0f),
			new Vector3(borderWidth + xOffset, borderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerWidth + xOffset, yOffset, 0f),
			new Vector3(borderWidth + innerWidth + innerborderWidth + xOffset, yOffset, 0f),
			new Vector3(borderWidth + innerWidth + xOffset, borderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerWidth + innerborderWidth + xOffset, borderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerborderWidth + innerWidth * 2f + xOffset, yOffset, 0f),
			new Vector3(borderWidth * 2f + innerborderWidth + innerWidth * 2f + xOffset, yOffset, 0f),
			new Vector3(borderWidth + innerborderWidth + innerWidth * 2f + xOffset, borderHeight + yOffset, 0f),
			new Vector3(borderWidth * 2f + innerborderWidth + innerWidth * 2f + xOffset, borderHeight + yOffset, 0f),
			new Vector3(xOffset, borderHeight + innerHeight + yOffset, 0f),
			new Vector3(borderWidth + xOffset, borderHeight + innerHeight + yOffset, 0f),
			new Vector3(xOffset, borderHeight + innerHeight + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + xOffset, borderHeight + innerHeight + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerWidth + xOffset, borderHeight + innerHeight + yOffset, 0f),
			new Vector3(borderWidth + innerWidth + innerborderWidth + xOffset, borderHeight + innerHeight + yOffset, 0f),
			new Vector3(borderWidth + innerWidth + xOffset, borderHeight + innerHeight + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerWidth + innerborderWidth + xOffset, borderHeight + innerHeight + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerborderWidth + innerWidth * 2f + xOffset, borderHeight + innerHeight + yOffset, 0f),
			new Vector3(borderWidth * 2f + innerborderWidth + innerWidth * 2f + xOffset, borderHeight + innerHeight + yOffset, 0f),
			new Vector3(borderWidth + innerborderWidth + innerWidth * 2f + xOffset, borderHeight + innerHeight + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth * 2f + innerborderWidth + innerWidth * 2f + xOffset, borderHeight + innerHeight + innerborderHeight + yOffset, 0f),
			new Vector3(xOffset, borderHeight + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + xOffset, borderHeight + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(xOffset, borderHeight * 2f + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + xOffset, borderHeight * 2f + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerWidth + xOffset, borderHeight + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerWidth + innerborderWidth + xOffset, borderHeight + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerWidth + xOffset, borderHeight * 2f + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerWidth + innerborderWidth + xOffset, borderHeight * 2f + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerborderWidth + innerWidth * 2f + xOffset, borderHeight + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth * 2f + innerborderWidth + innerWidth * 2f + xOffset, borderHeight + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth + innerborderWidth + innerWidth * 2f + xOffset, borderHeight * 2f + innerHeight * 2f + innerborderHeight + yOffset, 0f),
			new Vector3(borderWidth * 2f + innerborderWidth + innerWidth * 2f + xOffset, borderHeight * 2f + innerHeight * 2f + innerborderHeight + yOffset, 0f)
		};
	}
}
public class OptionsMenuController : TimeIndependentBehaviour
{
	private TextMesh volumeValue;

	private TextMesh musicVolumeValue;

	private TextMesh languageValue;

	private UIButton3D comfortToggle;

	private UIButton3D tankModeToggle;

	private UIButton3D tutorialToggle;

	private UIButton3D touchButton;

	private bool changedTouchValues;

	private bool touchLeftHanded;

	private bool touchEnabled;

	private string[] validLanguages;

	private int languageIndex;

	private bool reposition;

	private Vector3 oldPos;

	private Quaternion oldRot;

	private void Start()
	{
		UIDreadHallsMenu component = GetComponent<UIDreadHallsMenu>();
		volumeValue = base.transform.Find("text_volume_value").GetComponent<TextMesh>();
		musicVolumeValue = base.transform.Find("text_musicvolume_value").GetComponent<TextMesh>();
		languageValue = base.transform.Find("text_language_value").GetComponent<TextMesh>();
		int num = Mathf.RoundToInt(Config.Audio().masterVolume * 10f) * 10;
		volumeValue.text = num.ToString();
		int num2 = Mathf.RoundToInt(Config.Audio().musicVolume * 10f) * 10;
		musicVolumeValue.text = num2.ToString();
		languageValue.text = Translate.Get("LANGUAGE");
		validLanguages = Translate.ListLanguages();
		string language = Translate.GetLanguage();
		languageIndex = 0;
		while (languageIndex < validLanguages.Length && !(validLanguages[languageIndex] == language))
		{
			languageIndex++;
		}
		component.GetButton("button_volume_left").SetAction(OnVolumeLeftArrow);
		component.GetButton("button_volume_right").SetAction(OnVolumeRightArrow);
		component.GetButton("button_musicvolume_left").SetAction(OnMusicVolumeLeftArrow);
		component.GetButton("button_musicvolume_right").SetAction(OnMusicVolumeRightArrow);
		component.GetButton("button_language_left").SetAction(OnLanguageLeftArrow);
		component.GetButton("button_language_right").SetAction(OnLanguageRightArrow);
		comfortToggle = component.GetButton("button_comfort");
		comfortToggle.SetAction(OnButtonComfort);
		comfortToggle.text = ((!Config.Input().comfortRotation) ? Translate.Get("MENU_NO") : Translate.Get("MENU_YES"));
		tankModeToggle = component.GetButton("button_tankmode");
		tankModeToggle.SetAction(OnButtonTankMode);
		tankModeToggle.initialText = (Config.Input().tankMode ? "MENU_NO" : "MENU_YES");
		tankModeToggle.text = Translate.Get(tankModeToggle.initialText);
		tutorialToggle = component.GetButton("button_tutorials");
		tutorialToggle.SetAction(OnButtonTutorials);
		tutorialToggle.text = ((!Config.General().tutorials) ? Translate.Get("MENU_NO") : Translate.Get("MENU_YES"));
		touchButton = component.GetButton("button_touch");
		touchButton.SetAction(OnButtonTouch);
		changedTouchValues = false;
		touchLeftHanded = Config.Input().leftHanded;
		touchEnabled = InputExt.UsingHandControllers;
		string buttonTouchTextKey = GetButtonTouchTextKey();
		touchButton.initialText = buttonTouchTextKey;
		touchButton.text = Translate.Get(buttonTouchTextKey);
		component.OnShowAction = OnShow;
		if (!GameController.Get().IsInGameScene())
		{
			component.OnHideAction = OnHide;
		}
	}

	private void OnShow()
	{
		changedTouchValues = false;
		touchLeftHanded = Config.Input().leftHanded;
		touchEnabled = InputExt.UsingHandControllers;
		string buttonTouchTextKey = GetButtonTouchTextKey();
		touchButton.initialText = buttonTouchTextKey;
		touchButton.text = Translate.Get(buttonTouchTextKey);
	}

	private void OnHide()
	{
		ApplyTouchChanges();
	}

	private new void Update()
	{
		if (reposition)
		{
			base.transform.position = oldPos;
			base.transform.rotation = oldRot;
			reposition = false;
		}
	}

	private void OnVolumeLeftArrow()
	{
		Config.Audio().masterVolume = OnButtonArrow(Config.Audio().masterVolume, volumeValue, -10);
		GameController.Get().UpdateAudioVolume();
		Config.Save();
	}

	private void OnVolumeRightArrow()
	{
		Config.Audio().masterVolume = OnButtonArrow(Config.Audio().masterVolume, volumeValue);
		GameController.Get().UpdateAudioVolume();
		Config.Save();
	}

	private void OnMusicVolumeLeftArrow()
	{
		Config.Audio().musicVolume = OnButtonArrow(Config.Audio().musicVolume, musicVolumeValue, -10);
		GameController.Get().UpdateAudioVolume();
		Config.Save();
	}

	private void OnMusicVolumeRightArrow()
	{
		Config.Audio().musicVolume = OnButtonArrow(Config.Audio().musicVolume, musicVolumeValue);
		GameController.Get().UpdateAudioVolume();
		Config.Save();
	}

	private void OnLanguageLeftArrow()
	{
		languageIndex--;
		if (languageIndex < 0)
		{
			languageIndex = validLanguages.Length - 1;
		}
		GameController.SetLanguage(validLanguages[languageIndex]);
		languageValue.text = Translate.Get("LANGUAGE");
	}

	private void OnLanguageRightArrow()
	{
		languageIndex++;
		if (languageIndex >= validLanguages.Length)
		{
			languageIndex = 0;
		}
		GameController.SetLanguage(validLanguages[languageIndex]);
		languageValue.text = Translate.Get("LANGUAGE");
	}

	private void OnButtonComfort()
	{
		Config.Input().comfortRotation = OnCheckbox(Config.Input().comfortRotation, comfortToggle);
		GameController.Get().UpdateInput();
		Config.Save();
	}

	private void OnButtonTankMode()
	{
		Config.Input().tankMode = !OnCheckbox(!Config.Input().tankMode, tankModeToggle);
		oldPos = base.transform.position;
		oldRot = base.transform.rotation;
		reposition = true;
		GameController.Get().UpdateInput();
		Config.Save();
	}

	private void OnButtonTutorials()
	{
		Config.General().tutorials = OnCheckbox(Config.General().tutorials, tutorialToggle);
		Config.Save();
	}

	public bool ApplyTouchChanges()
	{
		if (changedTouchValues)
		{
			Config.Input().leftHanded = touchLeftHanded;
			Config.Save();
			if (!GameController.Get().IsInGameScene())
			{
				Player.ResetPlayerHands();
				Debug.Log("Re-Loading Intro scene");
				UnityEngine.Application.LoadLevel("Intro");
				return true;
			}
			return true;
		}
		return false;
	}

	private void OnButtonTouch()
	{
		if (InputExt.HasHandControllers)
		{
			touchEnabled = true;
			touchLeftHanded = !touchLeftHanded;
			changedTouchValues = true;
		}
		string buttonTouchTextKey = GetButtonTouchTextKey();
		touchButton.initialText = buttonTouchTextKey;
		touchButton.text = Translate.Get(buttonTouchTextKey);
	}

	private string GetButtonTouchTextKey()
	{
		if (!InputExt.HasHandControllers)
		{
			return "MENU_OPTIONS_TOUCH_NONE";
		}
		if (!touchEnabled)
		{
			return "MENU_OPTIONS_TOUCH_DISABLED";
		}
		return (!touchLeftHanded) ? "MENU_OPTIONS_TOUCH_RH" : "MENU_OPTIONS_TOUCH_LH";
	}

	private float OnButtonArrow(float curValue, TextMesh tMesh, int step = 10)
	{
		int num = Mathf.RoundToInt(curValue * 10f) * 10;
		num = Mathf.Clamp(num + step, 0, 100);
		curValue = (float)num / 100f;
		tMesh.text = num.ToString();
		return curValue;
	}

	private int OnButtonArrow(int curValue, TextMesh tMesh, int min, int max, int step = 1)
	{
		int result = Mathf.Clamp(curValue + step, min, max);
		tMesh.text = result.ToString();
		return result;
	}

	private bool OnCheckbox(bool curValue, UIButton3D but)
	{
		curValue = !curValue;
		but.initialText = ((!curValue) ? "MENU_NO" : "MENU_YES");
		but.text = ((!curValue) ? Translate.Get("MENU_NO") : Translate.Get("MENU_YES"));
		return curValue;
	}
}
public class PauseMenuController : TimeIndependentBehaviour
{
	public UIMenuStack pauseMenuStack;

	public UICrosshair3D crosshair;

	public LocalizedTexture controlTextures;

	public GameObject controlsFramePad;

	public GameObject controlsFrameOculusGoPad;

	public GameObject controlsFrameGearVR3DOF;

	public GameObject controlsFrameOculusGo3DOF;

	public GameObject controlsFrameTouchRight;

	public GameObject controlsFrameTouchLeft;

	private UIButton3DList pauseButtons;

	private bool showing;

	private bool skipInput;

	public AntiBodyDelta antiDelta;

	private void Start()
	{
		showing = true;
		UIDreadHallsMenu menu = pauseMenuStack.GetMenu("PauseMenu");
		pauseButtons = menu.transform.Find("ButtonList").GetComponent<UIButton3DList>();
		menu.GetButton("button_resume").SetAction(OnButtonResume);
		menu.GetButton("button_controls").SetAction(OnButtonControls);
		menu.GetButton("button_options").SetAction(OnButtonOptions);
		menu.GetButton("button_back").SetAction(OnButtonBack);
		menu.SetOnBackAction(OnButtonResume, applyToHeadset: false);
		menu.SetOnHeadsetBackAction(OnButtonHome);
		UIDreadHallsMenu menu2 = pauseMenuStack.GetMenu("ControlsMenu");
		menu2.SetOnBackAction(OnBackToPauseMenu);
		UIDreadHallsMenu menu3 = pauseMenuStack.GetMenu("OptionsMenu");
		menu3.SetOnBackAction(OnOptionsBackToPauseMenu);
		menu3.GetButton("button_back").SetAction(OnOptionsBackToPauseMenu);
		controlTextures.enabled = true;
		crosshair.gameObject.SetActive(value: false);
	}

	protected override void OnEnable()
	{
		base.OnEnable();
		OVRManager.HMDUnmounted += LostFocus;
		OVRManager.HMDMounted += AcquiredFocus;
	}

	private void OnDisable()
	{
		OVRManager.HMDUnmounted -= LostFocus;
		OVRManager.HMDMounted -= AcquiredFocus;
	}

	protected new void Update()
	{
		base.Update();
		bool backButtonDown = GameController.GetBackButtonDown();
		bool buttonDown = InputExt.GetButtonDown(InputExt.Button.Start);
		if (!skipInput && buttonDown)
		{
			if (!GameController.Get().Paused && !showing)
			{
				GameController.Get().EnterPause();
			}
			else if (showing)
			{
				GameController.Get().ExitPause();
			}
		}
		if (!skipInput && backButtonDown && !GameController.Get().Paused)
		{
			GameController.Get().EnterPause();
		}
		if (GameController.Get().Paused != showing)
		{
			ShowMenu(GameController.Get().Paused);
		}
		skipInput = false;
	}

	private void LostFocus()
	{
		SetFocus(focusStatus: false);
	}

	private void AcquiredFocus()
	{
		SetFocus(focusStatus: true);
	}

	private void SetFocus(bool focusStatus)
	{
		Debug.Log((!focusStatus) ? "PMC - Application lost focus" : "PMC - Application has focus");
		if (!focusStatus && !GameController.Get().Paused)
		{
			GameController.Get().EnterPause();
		}
	}

	private void ShowMenu(bool show)
	{
		showing = show;
		if (show)
		{
			if (antiDelta != null)
			{
				antiDelta.enabled = true;
			}
			pauseMenuStack.ShowMenu("PauseMenu");
			pauseButtons.ResetButtons();
		}
		else
		{
			pauseMenuStack.CloseMenu();
			if (antiDelta != null)
			{
				antiDelta.enabled = false;
			}
		}
		crosshair.gameObject.SetActive(show);
		DarkenTutorials(show);
	}

	private void DarkenTutorials(bool darken)
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag(Tags.TutorialUI);
		for (int i = 0; i < array.Length; i++)
		{
			TextLabel component = array[i].GetComponent<TextLabel>();
			if (component != null)
			{
				component.SetDarkened(darken);
			}
		}
	}

	private void OnButtonResume()
	{
		GameController.Get().ExitPause();
		if (GameController.Get().Paused != showing)
		{
			ShowMenu(GameController.Get().Paused);
		}
		skipInput = true;
	}

	private void OnButtonControls()
	{
		if (showing)
		{
			bool active = false;
			bool active2 = false;
			bool active3 = false;
			bool active4 = !InputExt.UsingHandControllers;
			bool active5 = InputExt.UsingHandControllers && !InputExt.LeftHanded;
			bool active6 = InputExt.UsingHandControllers && InputExt.LeftHanded;
			controlsFramePad.SetActive(active);
			controlsFrameOculusGoPad.SetActive(active4);
			controlsFrameGearVR3DOF.SetActive(active2);
			controlsFrameOculusGo3DOF.SetActive(active3);
			controlsFrameTouchRight.SetActive(active5);
			controlsFrameTouchLeft.SetActive(active6);
			pauseMenuStack.ShowMenu("ControlsMenu");
		}
	}

	private void OnButtonOptions()
	{
		if (showing)
		{
			pauseMenuStack.ShowMenu("OptionsMenu");
		}
	}

	private void OnHeadsetBack()
	{
		GameController.Get().ExitGame();
	}

	private void OnBackToPauseMenu()
	{
		pauseMenuStack.ShowMenu("PauseMenu");
	}

	private void OnOptionsBackToPauseMenu()
	{
		UIDreadHallsMenu menu = pauseMenuStack.GetMenu("OptionsMenu");
		OptionsMenuController component = menu.GetComponent<OptionsMenuController>();
		if (component != null && component.ApplyTouchChanges())
		{
			pauseMenuStack.ShowMenu("Dialog").SetDialog(Translate.Get("MENU_VIDEO_CONFIRM"), Translate.Get("MENU_YES"), Translate.Get("MENU_NO"), OnConfirmBack, OnBackToPauseMenu);
		}
		else
		{
			pauseMenuStack.ShowMenu("PauseMenu");
		}
	}

	private void OnButtonBack()
	{
		if (showing)
		{
			bool flag = !GameController.Get().levelOptions.IsMetaMap();
			pauseMenuStack.ShowMenu("Dialog").SetDialog(Translate.Get((!flag) ? "MENU_GAME_CONFIRM_EXIT" : "MENU_GAME_CONFIRM_EXIT_PROGRESS"), Translate.Get("MENU_YES"), Translate.Get("MENU_NO"), OnConfirmBack, OnBackToPauseMenu);
		}
	}

	private void OnConfirmBack()
	{
		Fader component = GameObject.Find("Fader").GetComponent<Fader>();
		component.FadeOut(4f, fadeAudio: true, null, OnEndExitFade);
		pauseMenuStack.CloseMenu();
	}

	private void OnEndExitFade()
	{
		GameController.Get().ExitGame();
	}

	private void OnButtonHome()
	{
		Debug.Log("OnButtonHome");
		OVRManager.instance.ReturnToLauncher();
	}

	private void OnConfirmHome()
	{
		OVRManager.instance.ReturnToLauncher();
	}
}
public class TextMeshNormals : MonoBehaviour
{
	private TextMesh textMesh;

	private void Start()
	{
		textMesh = base.transform.GetComponent<TextMesh>();
		GetComponent<Renderer>().material.mainTexture = textMesh.font.material.mainTexture;
	}

	private void Update()
	{
		GetComponent<Renderer>().material.SetVector("Text Normal", new Vector4(0f, 0f, -1f, 1f));
	}
}
public class UIBatteryDisplay : TimeIndependentBehaviour
{
	public Gradient batteryTempGradient;

	private float batteryTemperature = 30f;

	public float batteryCharge = 1f;

	public float maxTimer = 1f;

	private float timer;

	private Vector3 initialLocalPos;

	private float initialScaleX;

	private new void Awake()
	{
		base.Awake();
		initialLocalPos = base.transform.localPosition;
		initialScaleX = base.transform.localScale.x;
	}

	protected override void Update()
	{
		base.Update();
		if (timer > maxTimer)
		{
			batteryCharge = OVRManager.batteryLevel;
			batteryTemperature = OVRManager.batteryTemperature;
			float time = Mathf.InverseLerp(30f, 45f, batteryTemperature);
			Color value = batteryTempGradient.Evaluate(time);
			GetComponent<Renderer>().material.SetColor("_Tint", value);
			Vector3 localScale = base.transform.localScale;
			localScale.x = initialScaleX * batteryCharge;
			Vector3 localPosition = base.transform.localPosition;
			localPosition.x = initialLocalPos.x - (localScale.x - initialScaleX) / 2f;
			base.transform.localScale = localScale;
			base.transform.localPosition = localPosition;
		}
		else
		{
			timer += base.deltaTime;
		}
	}
}
public class UIButton3D : TimeIndependentBehaviour
{
	private Action buttonAction = delegate
	{
	};

	protected float progressOver;

	protected float progressPressed;

	protected bool bPressendOnCoroutine;

	public float deltaOver = 4.8f;

	public float deltaPressed = 4.8f;

	private bool bManaged;

	protected UIButton3DManager manager;

	private bool bSelected;

	protected bool hasBeenPressed;

	public Collider myCollider;

	private GameObject lookDirection;

	public int layerNumber;

	protected GameObject textObject;

	public string initialText = "Button";

	protected Color textColor;

	public Color textColorOver = Color.white;

	private bool textColorIsOver;

	public bool IsManaged
	{
		get
		{
			return bManaged;
		}
		set
		{
			bManaged = value;
		}
	}

	public UIButton3DManager Manager
	{
		set
		{
			manager = value;
		}
	}

	public bool IsSelected
	{
		get
		{
			return bSelected;
		}
		set
		{
			bSelected = value;
		}
	}

	public string text
	{
		get
		{
			return textObject.GetComponent<TextMesh>().text;
		}
		set
		{
			textObject.GetComponent<TextMesh>().text = value;
		}
	}

	private void Start()
	{
		base.gameObject.tag = "UI";
	}

	protected override void Update()
	{
		base.Update();
		bool flag = false;
		lookDirection = Player.GetLook(interaction: true).gameObject;
		if ((bool)lookDirection)
		{
			int layerMask = 1 << layerNumber;
			if (Physics.Raycast(lookDirection.transform.position, lookDirection.transform.forward, out var hitInfo, 200f, layerMask) && hitInfo.collider == myCollider)
			{
				flag = true;
			}
		}
		if (flag && (bool)manager)
		{
			flag = manager.NotifyOver(this);
		}
		bool flag2 = Input.GetMouseButtonUp(0) || InputExt.GetButtonUp(InputExt.Button.Action) || InputExt.GetButtonUp(InputExt.Button.UIAction);
		bool flag3 = Input.GetMouseButton(0) || InputExt.GetButton(InputExt.Button.Action) || InputExt.GetButton(InputExt.Button.UIAction);
		if (!hasBeenPressed && (bSelected || (flag && !bManaged)))
		{
			hasBeenPressed = Input.GetMouseButtonDown(0) || InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction);
		}
		bool flag4 = hasBeenPressed;
		if (flag2 && !hasBeenPressed)
		{
			flag2 = false;
		}
		if (hasBeenPressed && !flag3)
		{
			hasBeenPressed = false;
		}
		if (!bPressendOnCoroutine && (bSelected || (flag && !bManaged)) && flag2 && flag4)
		{
			bPressendOnCoroutine = true;
			StartCoroutine(ExecutePressed());
		}
		else if (!bPressendOnCoroutine && (bSelected || (flag && !bManaged)) && flag3)
		{
			progressPressed = ((!(progressPressed + deltaPressed * base.deltaTime > 1f)) ? (progressPressed + deltaPressed * base.deltaTime) : 1f);
		}
		else if (!bPressendOnCoroutine)
		{
			progressPressed = ((!(progressPressed - deltaPressed * base.deltaTime < 0f)) ? (progressPressed - deltaPressed * base.deltaTime) : 0f);
		}
		if ((flag && !bManaged) || bSelected)
		{
			progressOver = ((!(progressOver + deltaOver * base.deltaTime > 1f)) ? (progressOver + deltaOver * base.deltaTime) : 1f);
		}
		else
		{
			progressOver = ((!(progressOver - deltaOver * base.deltaTime < 0f)) ? (progressOver - deltaOver * base.deltaTime) : 0f);
		}
		if ((flag || IsSelected) && !textColorIsOver)
		{
			SetTextColor(textColorOver);
			textColorIsOver = true;
		}
		else if (!flag && !IsSelected && textColorIsOver)
		{
			SetTextColor(textColor);
			textColorIsOver = false;
		}
	}

	public void SetAction(Action newAction)
	{
		buttonAction = newAction;
	}

	private IEnumerator ExecutePressed()
	{
		while (progressPressed < 1f)
		{
			progressPressed += deltaPressed * base.deltaTime;
			yield return null;
		}
		while (progressPressed > 0f)
		{
			progressPressed = ((!(progressPressed - deltaPressed * base.deltaTime < 0f)) ? (progressPressed - deltaPressed * base.deltaTime) : 0f);
			yield return null;
		}
		if (buttonAction != null)
		{
			buttonAction();
		}
		bPressendOnCoroutine = false;
	}

	private void SetTextColor(Color c)
	{
		float a = textObject.GetComponent<Renderer>().material.color.a;
		textObject.GetComponent<Renderer>().material.color = new Color(c.r, c.g, c.b, a);
	}

	public void RefreshText()
	{
		if (textObject != null)
		{
			text = Translate.Get(initialText);
		}
	}

	public virtual void Reset()
	{
		progressPressed = 0f;
		progressOver = 0f;
	}
}
public class UIButton3DGrid : UIButton3DManager
{
	[Serializable]
	public class Row
	{
		public List<UIButton3D> buttons = new List<UIButton3D>();
	}

	public List<Row> buttonRows;

	private int selected = -1;

	private int selectedRow = -1;

	private int lastOver = -1;

	private int lastOverRow = -1;

	private bool focusInKey;

	private bool noOver;

	private AxisEvents axisVertical = new AxisEvents("Vertical", "Vertical_btn");

	private AxisEvents axisHorizontal = new AxisEvents("Horizontal", "Horizontal_btn");

	private void Start()
	{
		for (int i = 0; i < buttonRows.Count; i++)
		{
			foreach (UIButton3D button in buttonRows[i].buttons)
			{
				button.Manager = this;
			}
		}
	}

	protected override void Update()
	{
		base.Update();
		axisVertical.Update();
		axisHorizontal.Update();
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = false;
		flag = Input.GetKeyDown(KeyCode.DownArrow) || axisVertical.GetDownButtonDown();
		flag2 = Input.GetKeyDown(KeyCode.UpArrow) || axisVertical.GetUpButtonDown();
		flag3 = Input.GetKeyDown(KeyCode.RightArrow) || axisHorizontal.GetUpButtonDown();
		flag4 = Input.GetKeyDown(KeyCode.LeftArrow) || axisHorizontal.GetDownButtonDown();
		if (selectedRow != -1 && buttonRows[selectedRow].buttons.Count > 0 && (flag3 || flag4))
		{
			flag2 = (flag = false);
		}
		if (!focusInKey && (flag || flag2 || flag3 || flag4))
		{
			focusInKey = true;
		}
		if (flag)
		{
			if (selectedRow == -1 || selectedRow >= buttonRows.Count - 1)
			{
				selectedRow = 0;
				selected = Mathf.Clamp(selected, 0, buttonRows[selectedRow].buttons.Count - 1);
				for (int i = 0; i < buttonRows.Count; i++)
				{
					for (int j = 0; j < buttonRows[i].buttons.Count; j++)
					{
						buttonRows[i].buttons[j].IsManaged = true;
						if (i == selectedRow && j == selected)
						{
							buttonRows[i].buttons[j].IsSelected = true;
						}
						else
						{
							buttonRows[i].buttons[j].IsSelected = false;
						}
					}
				}
			}
			else
			{
				buttonRows[selectedRow].buttons[selected].IsSelected = false;
				selectedRow++;
				selected = Mathf.Clamp(selected, 0, buttonRows[selectedRow].buttons.Count - 1);
				buttonRows[selectedRow].buttons[selected].IsSelected = true;
			}
		}
		else if (flag2)
		{
			if (selectedRow == -1 || selectedRow <= 0)
			{
				selectedRow = buttonRows.Count - 1;
				selected = Mathf.Clamp(selected, 0, buttonRows[selectedRow].buttons.Count - 1);
				for (int k = 0; k < buttonRows.Count; k++)
				{
					for (int l = 0; l < buttonRows[k].buttons.Count; l++)
					{
						buttonRows[k].buttons[l].IsManaged = true;
						if (k == selectedRow && l == selected)
						{
							buttonRows[k].buttons[l].IsSelected = true;
						}
						else
						{
							buttonRows[k].buttons[l].IsSelected = false;
						}
					}
				}
			}
			else
			{
				buttonRows[selectedRow].buttons[selected].IsSelected = false;
				selectedRow--;
				selected = Mathf.Clamp(selected, 0, buttonRows[selectedRow].buttons.Count - 1);
				buttonRows[selectedRow].buttons[selected].IsSelected = true;
			}
		}
		else if (flag3 && selectedRow != -1 && selected < buttonRows[selectedRow].buttons.Count - 1 && selected != -1)
		{
			buttonRows[selectedRow].buttons[selected].IsSelected = false;
			selected++;
			buttonRows[selectedRow].buttons[selected].IsSelected = true;
		}
		else if (flag4 && selectedRow != -1 && selected > 0)
		{
			buttonRows[selectedRow].buttons[selected].IsSelected = false;
			selected--;
			buttonRows[selectedRow].buttons[selected].IsSelected = true;
		}
		if (noOver)
		{
			lastOver = -1;
		}
		noOver = true;
	}

	public override bool NotifyOver(UIButton3D button)
	{
		for (int i = 0; i < buttonRows.Count; i++)
		{
			for (int j = 0; j < buttonRows[i].buttons.Count; j++)
			{
				if (buttonRows[i].buttons[j] == button)
				{
					noOver = false;
				}
				if (buttonRows[i].buttons[j] == button && (j != lastOver || i != lastOverRow))
				{
					lastOver = j;
					lastOverRow = i;
					focusInKey = false;
					selected = j;
					selectedRow = i;
					for (int k = 0; k < buttonRows.Count; k++)
					{
						foreach (UIButton3D button2 in buttonRows[k].buttons)
						{
							button2.IsManaged = false;
							button2.IsSelected = false;
						}
					}
				}
				if (buttonRows[i].buttons[j] == button && j == lastOver && i == lastOverRow && focusInKey)
				{
					return false;
				}
			}
		}
		return true;
	}

	public override void ResetButtons()
	{
		selected = -1;
		lastOver = -1;
		focusInKey = false;
		for (int i = 0; i < buttonRows.Count; i++)
		{
			for (int j = 0; j < buttonRows[i].buttons.Count; j++)
			{
				buttonRows[i].buttons[j].Reset();
			}
		}
	}
}
public class UIButton3DList : UIButton3DManager
{
	public List<UIButton3D> buttons = new List<UIButton3D>();

	public bool horizontal;

	private int selected = -1;

	private int lastOver = -1;

	private bool focusInKey;

	private bool noOver;

	private AxisEvents axisVertical = new AxisEvents("Vertical", "Vertical_btn");

	private AxisEvents axisHorizontal = new AxisEvents("Horizontal", "Horizontal_btn");

	private void Start()
	{
		foreach (UIButton3D button in buttons)
		{
			button.Manager = this;
		}
	}

	protected override void Update()
	{
		base.Update();
		axisVertical.Update();
		axisHorizontal.Update();
		bool flag = false;
		bool flag2 = false;
		if (!horizontal)
		{
			flag = Input.GetKeyDown(KeyCode.DownArrow) || axisVertical.GetDownButtonDown();
			flag2 = Input.GetKeyDown(KeyCode.UpArrow) || axisVertical.GetUpButtonDown();
		}
		else
		{
			flag = Input.GetKeyDown(KeyCode.RightArrow) || axisHorizontal.GetUpButtonDown();
			flag2 = Input.GetKeyDown(KeyCode.LeftArrow) || axisHorizontal.GetDownButtonDown();
		}
		if (!focusInKey && (flag || flag2))
		{
			focusInKey = true;
		}
		if (flag)
		{
			if (selected == -1 || selected >= buttons.Count - 1)
			{
				for (int i = 0; i < buttons.Count; i++)
				{
					buttons[i].IsManaged = true;
					if (i == 0)
					{
						buttons[i].IsSelected = true;
					}
					else
					{
						buttons[i].IsSelected = false;
					}
				}
				selected = 0;
			}
			else
			{
				buttons[selected].IsSelected = false;
				selected++;
				buttons[selected].IsSelected = true;
			}
		}
		else if (flag2)
		{
			if (selected == -1 || selected <= 0)
			{
				for (int j = 0; j < buttons.Count; j++)
				{
					buttons[j].IsManaged = true;
					if (j == buttons.Count - 1)
					{
						buttons[j].IsSelected = true;
					}
					else
					{
						buttons[j].IsSelected = false;
					}
				}
				selected = buttons.Count - 1;
			}
			else
			{
				buttons[selected].IsSelected = false;
				selected--;
				buttons[selected].IsSelected = true;
			}
		}
		if (noOver)
		{
			lastOver = -1;
		}
		noOver = true;
	}

	public void AddButton(UIButton3D button)
	{
		buttons.Add(button);
		button.Manager = this;
	}

	public override bool NotifyOver(UIButton3D button)
	{
		for (int i = 0; i < buttons.Count; i++)
		{
			if (buttons[i] == button)
			{
				noOver = false;
			}
			if (buttons[i] == button && i != lastOver)
			{
				lastOver = i;
				focusInKey = false;
				selected = i;
				foreach (UIButton3D button2 in buttons)
				{
					button2.IsManaged = false;
					button2.IsSelected = false;
				}
			}
			if (buttons[i] == button && i == lastOver && focusInKey)
			{
				return false;
			}
		}
		return true;
	}

	public override void ResetButtons()
	{
		selected = -1;
		lastOver = -1;
		focusInKey = false;
		for (int i = 0; i < buttons.Count; i++)
		{
			buttons[i].Reset();
		}
	}
}
public class UIButton3DManager : TimeIndependentBehaviour
{
	public virtual bool NotifyOver(UIButton3D button)
	{
		return true;
	}

	public virtual void ResetButtons()
	{
	}
}
public class UICamChaser : TimeIndependentBehaviour
{
	public GameObject lookDirection;

	public GameObject centerObj;

	private Vector3 centerPos;

	public bool keepCentered = true;

	public float maxAngle = 45f;

	public float desiredDistance = 2f;

	public bool recenterOnStart;

	public bool recenterOnHMDReset;

	public bool testCollisions;

	public LayerMask collisionMask;

	public bool testCollisionsSides;

	public bool testCollisionsBetweenSides;

	public bool rotateOnCollision;

	private AntiBodyDelta antiDelta;

	private void Start()
	{
		if (lookDirection == null)
		{
			lookDirection = GameObject.FindGameObjectWithTag("LookDirection");
		}
		if (centerObj == null)
		{
			centerObj = lookDirection;
		}
		centerPos = centerObj.transform.position;
		if (recenterOnStart)
		{
			StartCoroutine(Recenter_co());
		}
		antiDelta = GetComponent<AntiBodyDelta>();
	}

	protected override void Update()
	{
		base.Update();
		if (recenterOnHMDReset && GameController.Get().HasJustRecentered)
		{
			StartCoroutine(Recenter_co());
			return;
		}
		if (keepCentered)
		{
			centerPos = centerObj.transform.position;
		}
		Vector3 forward = lookDirection.transform.forward;
		Vector3 vector = -base.transform.forward;
		Vector3 vector2 = centerPos;
		forward.y = 0f;
		vector.y = 0f;
		vector2.y = 0f;
		float num = Vector3.Angle(forward, vector);
		if (Vector3.Cross(forward, vector).y < 0f)
		{
			num = 0f - num;
		}
		if (num > maxAngle || num < 0f - maxAngle)
		{
			base.transform.RotateAround(vector2, Vector3.up, (0f - num) * base.deltaTime);
		}
		Vector3 position = base.transform.position;
		position.y = 0f;
		Vector3 vector3 = vector2 + (position - vector2).normalized * desiredDistance;
		Vector3 worldPosition = vector2;
		worldPosition.y = base.transform.position.y;
		base.transform.LookAt(worldPosition);
		vector3.y = base.transform.position.y;
		if (testCollisions)
		{
			Vector3 position2 = centerObj.transform.position;
			position2.y = vector3.y;
			Vector3 vector4 = vector3 - position2;
			float magnitude = vector4.magnitude;
			vector4.Normalize();
			float num2 = 1f;
			bool flag = false;
			float num3 = magnitude + 0.2f;
			Vector3 a = base.transform.forward;
			if (Physics.Raycast(position2, vector4, out var hitInfo, magnitude + 0.2f, collisionMask))
			{
				flag = true;
				num3 = hitInfo.distance;
				a = hitInfo.normal;
			}
			bool flag2 = false;
			bool flag3 = false;
			if (testCollisionsSides)
			{
				Collider component = GetComponent<Collider>();
				if (component != null)
				{
					float num4 = component.bounds.size.x;
					BoxCollider boxCollider = component as BoxCollider;
					if (boxCollider != null)
					{
						num4 = boxCollider.size.x * 0.5f * base.transform.lossyScale.x;
					}
					Vector3 vector5 = vector3 - base.transform.right * num4 - position2;
					Vector3 vector6 = vector3 + base.transform.right * num4 - position2;
					Debug.DrawLine(position2, position2 + vector5, Color.red);
					Debug.DrawLine(position2, position2 + vector6, Color.yellow);
					if (Physics.Raycast(position2, vector5, out var hitInfo2, magnitude + 0.2f, collisionMask))
					{
						DebugExt.DrawSphere(hitInfo2.point, Color.red, 0.01f);
						flag = true;
						flag2 = true;
						if (hitInfo2.distance * 0.9f < num3)
						{
							num3 = hitInfo2.distance * 0.9f;
							a = hitInfo2.normal;
						}
					}
					if (Physics.Raycast(position2, vector6, out hitInfo2, magnitude + 0.2f, collisionMask))
					{
						DebugExt.DrawSphere(hitInfo2.point, Color.yellow, 0.01f);
						flag = true;
						flag3 = true;
						if (hitInfo2.distance * 0.9f < num3)
						{
							num3 = hitInfo2.distance * 0.9f;
							a = hitInfo2.normal;
						}
					}
					if (flag)
					{
						num2 = (num3 - 0.05f) / magnitude;
						num2 = Mathf.Clamp(num2, 0.5f, 1f);
						vector3 = position2 + vector4 * magnitude * num2;
						if (flag2 && flag3)
						{
							a = -(vector5 + vector6).normalized;
						}
						Vector3 vector7 = Vector3.Lerp(a, base.transform.forward, num2 * num2);
						if (rotateOnCollision)
						{
							base.transform.LookAt(base.transform.position + vector7);
						}
						flag = false;
					}
				}
			}
			if (flag)
			{
				num2 = (num3 - 0.05f) / magnitude;
				num2 = Mathf.Clamp(num2, 0.5f, 1f);
				vector3 = position2 + vector4 * magnitude * num2;
				Vector3 vector8 = Vector3.Lerp(a, base.transform.forward, num2 * num2);
				if (rotateOnCollision)
				{
					base.transform.LookAt(base.transform.position + vector8);
				}
			}
		}
		base.transform.position = vector3;
	}

	public void Recenter()
	{
		Vector3 vector = centerObj.transform.position + lookDirection.transform.forward * desiredDistance;
		vector.y = base.transform.position.y;
		vector = centerObj.transform.position + (vector - lookDirection.transform.position).normalized * desiredDistance;
		vector.y = base.transform.position.y;
		base.transform.position = vector;
		Vector3 position = centerObj.transform.position;
		position.y = base.transform.position.y;
		base.transform.LookAt(position);
		centerPos = centerObj.transform.position;
	}

	private IEnumerator Recenter_co()
	{
		yield return 0;
		Recenter();
	}

	private new void OnEnable()
	{
		if ((bool)antiDelta)
		{
			antiDelta.enabled = true;
		}
	}

	private void OnDisable()
	{
		if ((bool)antiDelta)
		{
			antiDelta.enabled = false;
		}
	}
}
public class UIClock : TimeIndependentBehaviour
{
	public TextMesh dateMesh;

	private void Start()
	{
		if (!dateMesh)
		{
			dateMesh = GetComponent<TextMesh>();
		}
	}

	protected override void Update()
	{
		base.Update();
		if ((bool)dateMesh)
		{
			DateTime now = DateTime.Now;
			dateMesh.text = now.ToString("HH:mm:ss");
		}
	}
}
public class UICrosshair3D : TimeIndependentBehaviour
{
	public float maxDepth = 3f;

	public float offsetFromCollision = 0.1f;

	public OVRCameraRig cameraController;

	public Transform trackedController;

	private float fadeProgress;

	public float fadeStepAmount = 0.1f;

	public bool bShow;

	public bool increaseRenderQueue;

	private void Start()
	{
		if (cameraController == null)
		{
			cameraController = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
		}
		if (InputExt.Using3DOFController && trackedController == null)
		{
			trackedController = Player.Get3DOFController();
		}
		else if (InputExt.UsingHandControllers && trackedController == null)
		{
			trackedController = Player.GetLook(interaction: true);
		}
		if (increaseRenderQueue)
		{
			GetComponent<Renderer>().material.renderQueue = 3500;
		}
	}

	protected override void Update()
	{
		base.Update();
		Vector3 vector = -base.transform.forward;
		Transform transform;
		if (InputExt.Using3DOFController)
		{
			trackedController = Player.Get3DOFController();
			transform = trackedController.transform;
		}
		else if (InputExt.UsingHandControllers)
		{
			trackedController = Player.GetLook(interaction: true);
			transform = trackedController;
		}
		else if (InputExt.UsingGamepad)
		{
			trackedController = null;
			transform = cameraController.centerEyeAnchor.transform;
		}
		else
		{
			transform = cameraController.centerEyeAnchor.transform;
		}
		Vector3 position = transform.position;
		vector = transform.forward;
		Ray ray = new Ray(position, vector);
		RaycastHit[] array = Physics.RaycastAll(ray, maxDepth);
		RaycastHit raycastHit = default(RaycastHit);
		bool flag = false;
		RaycastHit[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			RaycastHit raycastHit2 = array2[i];
			if (raycastHit2.collider.gameObject.tag == "UI" && (!flag || raycastHit.distance > raycastHit2.distance))
			{
				raycastHit = raycastHit2;
				flag = true;
			}
		}
		if (flag)
		{
			bShow = true;
			base.transform.position = raycastHit.point;
		}
		else
		{
			bShow = false;
			base.transform.position = position + vector * maxDepth;
		}
		base.transform.forward = vector;
		if (bShow && fadeProgress < 1f)
		{
			fadeProgress = ((!(fadeProgress + fadeStepAmount > 1f)) ? (fadeProgress + fadeStepAmount) : 1f);
		}
		else if (!bShow && fadeProgress > 0f)
		{
			fadeProgress = ((!(fadeProgress - fadeStepAmount < 0f)) ? (fadeProgress - fadeStepAmount) : 0f);
		}
		Color color = GetComponent<Renderer>().material.GetColor("_Tint");
		color.a = fadeProgress;
		GetComponent<Renderer>().material.SetColor("_Tint", color);
	}
}
public class UIDialog3D : TimeIndependentBehaviour
{
	private void Start()
	{
	}

	protected override void Update()
	{
		base.Update();
	}
}
public class UIDreadHallsButton : UIButton3D
{
	private Vector3 originalPosition;

	public float overDistance = 0.4f;

	public float pressedDistance = -0.1f;

	private BoxCollider boxCollider;

	public bool dontMoveCollider;

	public AudioClip soundOver;

	public AudioClip soundPressed;

	private bool bSoundOver = true;

	private bool bSoundPressed = true;

	private void Start()
	{
		originalPosition = base.transform.localPosition;
		if (myCollider == null)
		{
			myCollider = GetComponent<Collider>();
		}
		else if ((bool)(BoxCollider)myCollider)
		{
			boxCollider = (BoxCollider)myCollider;
			boxCollider.size = new Vector3(GetComponent<FixedTileBorders>().xOffset * -2f * base.transform.localScale.x, GetComponent<FixedTileBorders>().yOffset * -2f * base.transform.localScale.y, 0.2f * base.transform.localScale.z);
		}
		textObject = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("DUI/3DText"));
		textObject.transform.parent = base.transform;
		textObject.transform.localRotation = Quaternion.AngleAxis(180f, Vector3.up);
		textColor = textObject.GetComponent<Renderer>().material.color;
		base.text = Translate.Get(initialText);
		if (!GetComponent<Renderer>().enabled)
		{
			textObject.GetComponent<Renderer>().enabled = false;
		}
	}

	protected override void Update()
	{
		base.Update();
		Vector3 localPosition = default(Vector3);
		localPosition.x = originalPosition.x * base.transform.localScale.x;
		localPosition.y = originalPosition.y * base.transform.localScale.y;
		localPosition.z = originalPosition.z * base.transform.localScale.z + progressOver * overDistance * base.transform.localScale.z + progressPressed * pressedDistance * base.transform.localScale.z;
		base.transform.localPosition = localPosition;
		if ((bool)boxCollider)
		{
			Vector3 zero = Vector3.zero;
			if (dontMoveCollider)
			{
				boxCollider.center = Vector3.zero;
			}
			else
			{
				boxCollider.center = (0f - progressOver) * Vector3.forward * overDistance - progressPressed * Vector3.forward * (0f - pressedDistance);
			}
			zero.x = GetComponent<FixedTileBorders>().xOffset * -2f * base.transform.localScale.x;
			zero.y = GetComponent<FixedTileBorders>().yOffset * -2f * base.transform.localScale.y;
			zero.z = 0.2f * base.transform.localScale.z;
			boxCollider.size = zero;
		}
		textObject.transform.localPosition = Vector3.zero;
		textObject.transform.localScale = base.transform.localScale;
		GetComponent<Renderer>().material.SetFloat("_Value", progressOver);
		if (bSoundOver && progressOver > 0f)
		{
			bSoundOver = false;
			PlayClipAtPoint(soundOver, base.transform.position);
		}
		else if (!bSoundOver && progressOver == 0f)
		{
			bSoundOver = true;
		}
		if (bSoundPressed && progressPressed > 0f)
		{
			bSoundPressed = false;
			if (hasBeenPressed)
			{
				PlayClipAtPoint(soundPressed, base.transform.position);
			}
		}
		else if (!bSoundPressed && progressPressed == 0f && !hasBeenPressed)
		{
			bSoundPressed = true;
		}
	}

	public override void Reset()
	{
		progressPressed = 0f;
		progressOver = 0f;
		base.transform.localPosition = originalPosition;
	}
}
public class UIDreadHallsMainButton : UIButton3D
{
	private Vector3 originalPosition;

	private Vector3 originalPosOrnament;

	private Vector3 originalPosBack;

	public float overDistance = 0.4f;

	public float pressedDistance = -0.1f;

	public Vector3 overSeparation;

	public bool dontMoveCollider;

	public AudioClip soundOver;

	public AudioClip soundPressed;

	private bool bSoundOver = true;

	private bool bSoundPressed = true;

	public float soundVolume = 1f;

	public GameObject ornament;

	public GameObject background;

	public GameObject claws;

	public string textObjName = "DUI/3DText";

	public float textMargin;

	private void Start()
	{
		originalPosition = base.transform.position - ((!base.transform.parent) ? Vector3.zero : base.transform.parent.position);
		originalPosOrnament = ornament.transform.localPosition;
		originalPosBack = ornament.transform.localPosition;
		if (myCollider == null)
		{
			myCollider = GetComponent<Collider>();
		}
		else if ((bool)(BoxCollider)myCollider)
		{
			((BoxCollider)myCollider).size = background.GetComponent<Renderer>().bounds.size;
		}
		textObject = UnityEngine.Object.Instantiate(Resources.Load<GameObject>(textObjName), base.transform.position, base.transform.rotation);
		textObject.transform.Rotate(base.transform.up, 180f);
		textObject.GetComponent<TextMesh>().anchor = TextAnchor.MiddleLeft;
		textObject.transform.parent = base.transform;
		textColor = textObject.GetComponent<Renderer>().material.color;
		base.text = Translate.Get(initialText);
	}

	protected override void Update()
	{
		base.Update();
		Vector3 position = default(Vector3);
		position.x = ((!base.transform.parent) ? Vector3.zero : base.transform.parent.position).x + originalPosition.x * base.transform.localScale.x + progressOver * base.transform.forward.x * overDistance * base.transform.localScale.x + progressPressed * base.transform.forward.x * pressedDistance * base.transform.localScale.x;
		position.y = ((!base.transform.parent) ? Vector3.zero : base.transform.parent.position).y + originalPosition.y * base.transform.localScale.y + progressOver * base.transform.forward.y * overDistance * base.transform.localScale.y + progressPressed * base.transform.forward.y * pressedDistance * base.transform.localScale.y;
		position.z = ((!base.transform.parent) ? Vector3.zero : base.transform.parent.position).z + originalPosition.z * base.transform.localScale.z + progressOver * base.transform.forward.z * overDistance * base.transform.localScale.z + progressPressed * base.transform.forward.z * pressedDistance * base.transform.localScale.z;
		base.transform.position = position;
		Vector3 localPosition = default(Vector3);
		localPosition.x = originalPosOrnament.x + Mathf.Sin(progressOver * (float)Math.PI) * overSeparation.x * base.transform.localScale.x;
		localPosition.y = originalPosOrnament.y + Mathf.Sin(progressOver * (float)Math.PI) * overSeparation.y * base.transform.localScale.y;
		localPosition.z = originalPosOrnament.z + Mathf.Sin(progressOver * (float)Math.PI) * overSeparation.z * base.transform.localScale.z;
		ornament.transform.localPosition = localPosition;
		Vector3 localPosition2 = default(Vector3);
		localPosition2.x = originalPosBack.x + Mathf.Sin(progressOver * (float)Math.PI) * -1f * overSeparation.x * base.transform.localScale.x;
		localPosition2.y = originalPosBack.y + Mathf.Sin(progressOver * (float)Math.PI) * -1f * overSeparation.y * base.transform.localScale.y;
		localPosition2.z = originalPosBack.z + Mathf.Sin(progressOver * (float)Math.PI) * -1f * overSeparation.z * base.transform.localScale.z;
		background.transform.localPosition = localPosition2;
		if ((bool)(BoxCollider)myCollider)
		{
			Vector3 zero = Vector3.zero;
			if (dontMoveCollider)
			{
				((BoxCollider)myCollider).center = Vector3.zero;
			}
			else
			{
				((BoxCollider)myCollider).center = background.transform.localPosition - progressOver * Vector3.forward * overDistance - progressPressed * Vector3.forward * (0f - pressedDistance);
			}
			zero = background.GetComponent<Renderer>().bounds.size;
			if ((bool)base.transform.parent)
			{
				zero.x = background.GetComponent<Renderer>().bounds.size.x / base.transform.parent.localScale.x;
				zero.y = background.GetComponent<Renderer>().bounds.size.y / base.transform.parent.localScale.y;
			}
			zero.z = 0.3f * base.transform.localScale.z;
			((BoxCollider)myCollider).size = zero;
		}
		textObject.transform.position = base.transform.position + new Vector3(textMargin, 0f, 0f);
		textObject.transform.localScale = base.transform.localScale;
		background.GetComponent<Renderer>().material.SetFloat("_Value", progressOver);
		ornament.GetComponent<Renderer>().material.SetFloat("_Value", progressOver);
		claws.GetComponent<Renderer>().material.SetFloat("_Progress", Mathf.Sqrt(progressOver));
		if (bSoundOver && progressOver > 0f)
		{
			bSoundOver = false;
			PlayClipAtPoint(soundOver, base.transform.position, soundVolume);
		}
		else if (!bSoundOver && progressOver == 0f)
		{
			bSoundOver = true;
		}
		if (bSoundPressed && progressPressed > 0f)
		{
			bSoundPressed = false;
			if (hasBeenPressed)
			{
				PlayClipAtPoint(soundPressed, base.transform.position, soundVolume);
			}
		}
		else if (!bSoundPressed && progressPressed == 0f && !hasBeenPressed)
		{
			bSoundPressed = true;
		}
	}
}
public class UIDreadHallsMenu : UIMenu3D
{
	private bool bVisible = true;

	private GameObject lookDirection;

	private UICamChaser chaser;

	private bool waitOnDetect = true;

	public bool actionPressAsOnBack;

	private Action onBackAction;

	private Action onHeadsetBackAction;

	public bool receiveButtonEvents = true;

	public Action OnShowAction;

	public Action OnHideAction;

	public bool Visible
	{
		get
		{
			return bVisible;
		}
		set
		{
			bVisible = value;
			if (GetComponent<Renderer>() != null)
			{
				GetComponent<Renderer>().enabled = bVisible;
			}
			Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
			for (int i = 0; i < componentsInChildren.GetLength(0); i++)
			{
				componentsInChildren[i].enabled = bVisible;
			}
			SetCollidersEnabled(bVisible);
			if (bVisible && OnShowAction != null)
			{
				OnShowAction();
			}
			if (!bVisible && OnHideAction != null)
			{
				OnHideAction();
			}
		}
	}

	private void Start()
	{
		lookDirection = Player.GetLook(interaction: true).gameObject;
		chaser = GetComponent<UICamChaser>();
		if (GetComponent<Collider>() != null && (bool)GetComponent<FixedTileBorders>())
		{
			((BoxCollider)GetComponent<Collider>()).size = new Vector3(GetComponent<FixedTileBorders>().xOffset * -2f * base.transform.localScale.x, GetComponent<FixedTileBorders>().yOffset * -2f * base.transform.localScale.y, 0.02f * base.transform.localScale.z);
		}
		Visible = false;
	}

	private new void OnEnable()
	{
		base.OnEnable();
		waitOnDetect = true;
	}

	protected override void Update()
	{
		base.Update();
		lookDirection = Player.GetLook(interaction: true).gameObject;
		if (!waitOnDetect && receiveButtonEvents)
		{
			if (GameController.GetBackButtonDown() && onHeadsetBackAction != null)
			{
				onHeadsetBackAction();
			}
			if (InputExt.GetButtonDown(InputExt.Button.Cancel) && onBackAction != null)
			{
				onBackAction();
			}
			if (actionPressAsOnBack && (Input.GetMouseButtonUp(0) || InputExt.GetButtonUp(InputExt.Button.Action) || InputExt.GetButtonUp(InputExt.Button.UIAction)) && onBackAction != null)
			{
				onBackAction();
			}
		}
		else
		{
			waitOnDetect = false;
		}
	}

	public override void LongPress()
	{
		if (!bVisible)
		{
			float num = ((!chaser) ? 2f : chaser.desiredDistance);
			Vector3 vector = lookDirection.transform.position + lookDirection.transform.forward * num;
			vector.y = base.transform.position.y;
			vector = lookDirection.transform.position + (vector - lookDirection.transform.position).normalized * num;
			base.transform.position = vector;
			base.transform.forward = lookDirection.transform.forward;
			SetVisible();
		}
		else
		{
			SetInvisible();
		}
	}

	public override void DoubleTap()
	{
		Debug.Log("DoubleTap");
	}

	public override void ShortPress()
	{
		if (Visible)
		{
			SetInvisible();
		}
	}

	public void SetVisible()
	{
		Visible = true;
	}

	public void SetInvisible()
	{
		Visible = false;
	}

	public void FadeIn()
	{
		Animator component = GetComponent<Animator>();
		component.SetInteger("FadeState", 2);
	}

	public void FadeOut()
	{
		Animator component = GetComponent<Animator>();
		component.SetInteger("FadeState", 1);
	}

	public void SetCollidersEnabled(bool enabled)
	{
		Collider[] componentsInChildren = GetComponentsInChildren<Collider>();
		for (int i = 0; i < componentsInChildren.GetLength(0); i++)
		{
			componentsInChildren[i].enabled = enabled;
		}
	}

	public void SetOnBackAction(Action newAction, bool applyToHeadset = true)
	{
		onBackAction = newAction;
		if (applyToHeadset)
		{
			onHeadsetBackAction = newAction;
		}
	}

	public void SetOnHeadsetBackAction(Action newAction)
	{
		onHeadsetBackAction = newAction;
	}

	public UIButton3D GetButton(string name)
	{
		return base.transform.Find(name).GetComponent<UIButton3D>();
	}

	public TextMesh GetText(string name)
	{
		Transform transform = base.transform.Find("main_text");
		if (transform != null)
		{
			TextMesh component = transform.GetComponent<TextMesh>();
			if (component != null)
			{
				return component;
			}
		}
		return null;
	}

	public void SetText(string elementName, string newText)
	{
		TextMesh text = GetText(elementName);
		if (text != null)
		{
			text.text = newText;
		}
	}

	public void SetTextWrap(string elementName, string newText, float wrapLimit = 1f)
	{
		TextMesh text = GetText(elementName);
		if (text != null)
		{
			text.text = Utils.WordWrap(newText, text, wrapLimit);
		}
	}

	public void SetDialog(string text, string captionYes, string captionNo, Action onYes = null, Action onNo = null)
	{
		SetText("main_text", text);
		UIButton3D button = GetButton("button_yes");
		UIButton3D button2 = GetButton("button_no");
		if (button != null)
		{
			button.text = captionYes;
			button.SetAction(onYes);
		}
		if (button2 != null)
		{
			button2.text = captionNo;
			button2.SetAction(onNo);
		}
		SetOnBackAction(onNo);
	}
}
public class UIEscapeBehaviour : TimeIndependentBehaviour
{
	public float longPressTimer = 0.75f;

	public float doubleTapTimer = 0.25f;

	private float longPressTimerProgress;

	private float doubleTapTimerProgress;

	private bool bDoubleTapping;

	public UIMenu3D menu;

	private GameObject progressCircle;

	public float progressCircleOffset = 2f;

	private GameObject lookDirection;

	private void Start()
	{
		if (!menu)
		{
			menu = UnityEngine.Object.FindObjectOfType<UIMenu3D>();
		}
		progressCircle = UnityEngine.Object.Instantiate(Resources.Load("DUI/ProgressCircle")) as GameObject;
		lookDirection = GameObject.FindGameObjectWithTag("LookDirection");
		progressCircle.GetComponent<Renderer>().material.SetFloat("-Value", 0f);
	}

	protected override void Update()
	{
		base.Update();
		progressCircle.transform.position = lookDirection.transform.position + lookDirection.transform.forward * progressCircleOffset;
		progressCircle.transform.forward = lookDirection.transform.forward;
		progressCircle.GetComponent<Renderer>().material.SetFloat("_Value", 2f * longPressTimerProgress / longPressTimer);
		if (Input.GetKeyUp(KeyCode.Escape) || InputExt.GetButtonUp(InputExt.Button.Back))
		{
			if (longPressTimerProgress > longPressTimer)
			{
				menu.LongPress();
				doubleTapTimerProgress = 0f;
			}
			else if (bDoubleTapping)
			{
				menu.DoubleTap();
				doubleTapTimerProgress = 0f;
				bDoubleTapping = false;
			}
			else
			{
				bDoubleTapping = true;
			}
			longPressTimerProgress = 0f;
		}
		else if (Input.GetKey(KeyCode.Escape) || InputExt.GetButton(InputExt.Button.Back))
		{
			longPressTimerProgress += base.deltaTime;
		}
		if (bDoubleTapping)
		{
			if (doubleTapTimerProgress > doubleTapTimer + base.deltaTime)
			{
				doubleTapTimerProgress = 0f;
				bDoubleTapping = false;
				menu.ShortPress();
			}
			else
			{
				doubleTapTimerProgress += base.deltaTime;
			}
		}
	}
}
public class UIMenu3D : TimeIndependentBehaviour
{
	private void Start()
	{
	}

	protected override void Update()
	{
		base.Update();
	}

	public virtual void LongPress()
	{
		Debug.Log("LongPress");
	}

	public virtual void DoubleTap()
	{
		Debug.Log("DoubleTap");
	}

	public virtual void ShortPress()
	{
		Debug.Log("ShortPress");
	}
}
public class UIMenuAnimator : TimeIndependentBehaviour
{
	private float progress = 1f;

	public bool fadeIn = true;

	public float speedIn = 1f;

	public float speedOut = 1f;

	public bool animateSize = true;

	private Action onEndAnim;

	public AnimationCurve curve;

	public bool multiMaterialTexts;

	private Vector3 frameScale;

	private void Start()
	{
		frameScale = base.transform.localScale;
	}

	public void FadeIn(bool reset = true, Action endAction = null)
	{
		if (reset)
		{
			progress = 0f;
		}
		fadeIn = true;
		onEndAnim = endAction;
	}

	public void FadeOut(bool reset = true, Action endAction = null)
	{
		if (reset)
		{
			progress = 1f;
		}
		fadeIn = false;
		onEndAnim = endAction;
	}

	protected new void Update()
	{
		base.Update();
		bool flag = false;
		if (fadeIn && progress < 1f)
		{
			progress += speedIn * base.deltaTime;
			flag = true;
			if (progress >= 1f && onEndAnim != null)
			{
				onEndAnim();
			}
		}
		else if (!fadeIn && progress > 0f)
		{
			progress -= speedOut * base.deltaTime;
			flag = true;
			if (progress <= 0f && onEndAnim != null)
			{
				onEndAnim();
			}
		}
		if (flag)
		{
			progress = Mathf.Clamp01(progress);
			float alpha = progress;
			float num = EvalCurve(curve, progress);
			float num2 = num;
			float num3 = num;
			float num4 = num;
			float num5 = num;
			if (animateSize)
			{
				base.transform.localScale = new Vector3(frameScale.x * num2, frameScale.y * num3, frameScale.z);
			}
			ApplyAlpha(alpha);
		}
	}

	public void ApplyAlpha(float alpha)
	{
		if (GetComponent<Renderer>() != null)
		{
			Color color = GetComponent<Renderer>().material.GetColor("_Tint");
			color.a = alpha;
			GetComponent<Renderer>().material.SetColor("_Tint", color);
		}
		Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
		Renderer[] array = componentsInChildren;
		foreach (Renderer renderer in array)
		{
			if (renderer.material.HasProperty("_Tint"))
			{
				Color color2 = renderer.material.GetColor("_Tint");
				color2.a = alpha;
				renderer.material.SetColor("_Tint", color2);
			}
		}
		TextMesh[] componentsInChildren2 = GetComponentsInChildren<TextMesh>();
		TextMesh[] array2 = componentsInChildren2;
		foreach (TextMesh textMesh in array2)
		{
			Color color3 = textMesh.color;
			color3.a = alpha;
			textMesh.color = color3;
			if (multiMaterialTexts)
			{
				for (int k = 0; k < textMesh.GetComponent<Renderer>().materials.Length; k++)
				{
					color3 = textMesh.GetComponent<Renderer>().materials[k].color;
					color3.a = alpha;
					textMesh.GetComponent<Renderer>().materials[k].color = color3;
				}
			}
			else
			{
				color3 = textMesh.GetComponent<Renderer>().material.color;
				color3.a = alpha;
				textMesh.GetComponent<Renderer>().material.color = color3;
			}
		}
	}

	private float EvalCurve(AnimationCurve curve, float f)
	{
		float time = curve.keys[curve.length - 1].time;
		return curve.Evaluate(time * f);
	}
}
public class UIMenuStack : TimeIndependentBehaviour
{
	public UIDreadHallsMenu[] menus;

	private UIMenuAnimator[] animators;

	private int activeIdx = -1;

	private bool initClose = true;

	private List<int> toClose = new List<int>();

	public AudioClip openSound;

	public AudioClip closeSound;

	public AudioClip switchSound;

	private void Start()
	{
		animators = new UIMenuAnimator[menus.Length];
		for (int i = 0; i < menus.Length; i++)
		{
			animators[i] = menus[i].GetComponent<UIMenuAnimator>();
		}
	}

	private new void Update()
	{
		base.Update();
		if (initClose)
		{
			for (int i = 0; i < menus.Length; i++)
			{
				animators[i].ApplyAlpha(0f);
				menus[i].gameObject.SetActive(value: false);
				menus[i].receiveButtonEvents = true;
			}
			initClose = false;
		}
	}

	public UIDreadHallsMenu ShowMenu(int idx)
	{
		if (activeIdx == idx)
		{
			if (activeIdx != -1)
			{
				return menus[activeIdx];
			}
			return null;
		}
		if (activeIdx == -1 && idx != -1 && openSound != null)
		{
			PlayClipAtPoint(openSound, base.transform.position);
		}
		else if (activeIdx != -1 && idx != -1 && switchSound != null)
		{
			PlayClipAtPoint(switchSound, base.transform.position);
		}
		else if (activeIdx != -1 && idx == -1 && closeSound != null)
		{
			PlayClipAtPoint(closeSound, base.transform.position);
		}
		if (activeIdx != -1)
		{
			menus[activeIdx].receiveButtonEvents = false;
			animators[activeIdx].FadeOut(reset: false, OnEndCloseAnim);
			toClose.Add(activeIdx);
		}
		activeIdx = idx;
		if (toClose.Contains(idx))
		{
			toClose.Remove(idx);
		}
		if (activeIdx != -1)
		{
			menus[activeIdx].receiveButtonEvents = true;
			menus[activeIdx].gameObject.SetActive(value: true);
			UICamChaser component = menus[activeIdx].GetComponent<UICamChaser>();
			if (component != null)
			{
				component.Recenter();
			}
			menus[activeIdx].Visible = true;
			animators[activeIdx].FadeIn(reset: true, OnEndOpenAnim);
			return menus[activeIdx];
		}
		return null;
	}

	public UIDreadHallsMenu ShowMenu(string name)
	{
		return ShowMenu(GetMenuIdx(name));
	}

	public void CloseMenu()
	{
		ShowMenu(-1);
	}

	private void OnEndCloseAnim()
	{
		while (toClose.Count > 0)
		{
			menus[toClose[0]].gameObject.SetActive(value: false);
			toClose.RemoveAt(0);
		}
	}

	private void OnEndOpenAnim()
	{
	}

	public UIDreadHallsMenu GetCurrentMenu()
	{
		if (activeIdx == -1)
		{
			return null;
		}
		return menus[activeIdx];
	}

	private int GetMenuIdx(string name)
	{
		for (int i = 0; i < menus.Length; i++)
		{
			if (menus[i].gameObject.name == name)
			{
				return i;
			}
		}
		return -1;
	}

	public UIDreadHallsMenu GetMenu(string name)
	{
		int menuIdx = GetMenuIdx(name);
		if (menuIdx == -1)
		{
			return null;
		}
		return menus[menuIdx];
	}
}
public class UIText : TimeIndependentBehaviour
{
	public string initialText = "Text";

	private void Start()
	{
		RefreshText();
	}

	public void RefreshText()
	{
		TextMesh component = GetComponent<TextMesh>();
		if (component != null)
		{
			component.text = Translate.Get(initialText);
		}
	}
}
public class UITextLabel3D : TimeIndependentBehaviour
{
	private TextMesh textMesh;

	private MeshRenderer meshRenderer;

	public float fadeSpeed = 0.05f;

	public float fadeTarget = 1f;

	public string text
	{
		get
		{
			return textMesh.text;
		}
		set
		{
			textMesh.text = value;
		}
	}

	public Color color
	{
		get
		{
			return meshRenderer.material.color;
		}
		set
		{
			meshRenderer.material.color = color;
		}
	}

	public float alpha
	{
		get
		{
			return meshRenderer.material.color.a;
		}
		set
		{
			Color color = meshRenderer.material.color;
			color.a = Mathf.Clamp(value, 0f, 1f);
			meshRenderer.material.color = color;
		}
	}

	private void Start()
	{
		textMesh = base.gameObject.AddComponent<TextMesh>();
		meshRenderer = GetComponent<MeshRenderer>();
		if (!meshRenderer)
		{
			meshRenderer = base.gameObject.AddComponent<MeshRenderer>();
		}
		meshRenderer.material = Resources.Load<Material>("UI/Materials/FontMaterial");
		textMesh.text = "Hello <i>world</i>";
		textMesh.font = Resources.Load<Font>("UI/trebuc2");
		textMesh.anchor = TextAnchor.MiddleCenter;
	}

	protected override void Update()
	{
		base.Update();
		if (fadeTarget != alpha)
		{
			if (fadeTarget < alpha - fadeSpeed)
			{
				alpha -= fadeSpeed;
			}
			else if (fadeTarget > alpha + fadeSpeed)
			{
				alpha += fadeSpeed;
			}
			else
			{
				alpha = fadeTarget;
			}
		}
		if (Input.GetMouseButtonDown(0))
		{
			FadeIn();
		}
		else if (Input.GetMouseButtonDown(1))
		{
			FadeOut();
		}
	}

	public void FadeIn()
	{
		fadeTarget = 1f;
	}

	public void FadeOut()
	{
		fadeTarget = 0f;
	}
}
public class Torchelight : MonoBehaviour
{
	public GameObject TorchLight;

	public GameObject MainFlame;

	public GameObject BaseFlame;

	public GameObject Etincelles;

	public GameObject Fumee;

	public float MaxLightIntensity;

	public float IntensityLight;

	private void Start()
	{
		TorchLight.GetComponent<Light>().intensity = IntensityLight;
		MainFlame.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 20f;
		BaseFlame.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 15f;
		Etincelles.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 7f;
		Fumee.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 12f;
	}

	private void Update()
	{
		if (IntensityLight < 0f)
		{
			IntensityLight = 0f;
		}
		if (IntensityLight > MaxLightIntensity)
		{
			IntensityLight = MaxLightIntensity;
		}
		TorchLight.GetComponent<Light>().intensity = IntensityLight / 2f + Mathf.Lerp(IntensityLight - 0.1f, IntensityLight + 0.1f, Mathf.Cos(Time.time * 30f));
		TorchLight.GetComponent<Light>().color = new Color(Mathf.Min(IntensityLight / 1.5f, 1f), Mathf.Min(IntensityLight / 2f, 1f), 0f);
		MainFlame.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 20f;
		BaseFlame.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 15f;
		Etincelles.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 7f;
		Fumee.GetComponent<ParticleSystem>().emissionRate = IntensityLight * 12f;
	}
}
public class PoseEditHelper : MonoBehaviour
{
	public Transform poseRoot;

	private void OnDrawGizmos()
	{
		if (poseRoot != null)
		{
			DrawJoints(poseRoot);
		}
	}

	private void DrawJoints(Transform joint)
	{
		Gizmos.DrawWireSphere(joint.position, 0.005f);
		for (int i = 0; i < joint.childCount; i++)
		{
			Transform child = joint.GetChild(i);
			if (!child.name.EndsWith("_grip") && !child.name.EndsWith("hand_ignore"))
			{
				Gizmos.DrawLine(joint.position, child.position);
				DrawJoints(child);
			}
		}
	}
}
public class RemoteLoopbackManager : MonoBehaviour
{
	private class PacketLatencyPair
	{
		public byte[] PacketData;

		public float FakeLatency;
	}

	[Serializable]
	public class SimulatedLatencySettings
	{
		[Range(0f, 0.5f)]
		public float FakeLatencyMax = 0.25f;

		[Range(0f, 0.5f)]
		public float FakeLatencyMin = 0.002f;

		[Range(0f, 1f)]
		public float LatencyWeight = 0.25f;

		[Range(0f, 10f)]
		public int MaxSamples = 4;

		internal float AverageWindow;

		internal float LatencySum;

		internal LinkedList<float> LatencyValues = new LinkedList<float>();

		public float NextValue()
		{
			AverageWindow = LatencySum / (float)LatencyValues.Count;
			float num = UnityEngine.Random.Range(FakeLatencyMin, FakeLatencyMax);
			float num2 = AverageWindow * (1f - LatencyWeight) + LatencyWeight * num;
			if (LatencyValues.Count >= MaxSamples)
			{
				LatencySum -= LatencyValues.First.Value;
				LatencyValues.RemoveFirst();
			}
			LatencySum += num2;
			LatencyValues.AddLast(num2);
			return num2;
		}
	}

	public OvrAvatar LocalAvatar;

	public OvrAvatar LoopbackAvatar;

	public SimulatedLatencySettings LatencySettings = new SimulatedLatencySettings();

	private int PacketSequence;

	private LinkedList<PacketLatencyPair> packetQueue = new LinkedList<PacketLatencyPair>();

	private void Start()
	{
		LocalAvatar.RecordPackets = true;
		OvrAvatar localAvatar = LocalAvatar;
		localAvatar.PacketRecorded = (EventHandler<OvrAvatar.PacketEventArgs>)Delegate.Combine(localAvatar.PacketRecorded, new EventHandler<OvrAvatar.PacketEventArgs>(OnLocalAvatarPacketRecorded));
		float num = UnityEngine.Random.Range(LatencySettings.FakeLatencyMin, LatencySettings.FakeLatencyMax);
		LatencySettings.LatencyValues.AddFirst(num);
		LatencySettings.LatencySum += num;
	}

	private void OnLocalAvatarPacketRecorded(object sender, OvrAvatar.PacketEventArgs args)
	{
		using MemoryStream memoryStream = new MemoryStream();
		BinaryWriter binaryWriter = new BinaryWriter(memoryStream);
		if (LocalAvatar.UseSDKPackets)
		{
			uint num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetSize(args.Packet.ovrNativePacket);
			byte[] buffer = new byte[num];
			Oculus.Avatar.CAPI.ovrAvatarPacket_Write(args.Packet.ovrNativePacket, num, buffer);
			binaryWriter.Write(PacketSequence++);
			binaryWriter.Write(num);
			binaryWriter.Write(buffer);
		}
		else
		{
			binaryWriter.Write(PacketSequence++);
			args.Packet.Write(memoryStream);
		}
		SendPacketData(memoryStream.ToArray());
	}

	private void Update()
	{
		if (packetQueue.Count <= 0)
		{
			return;
		}
		List<PacketLatencyPair> list = new List<PacketLatencyPair>();
		foreach (PacketLatencyPair item in packetQueue)
		{
			item.FakeLatency -= Time.deltaTime;
			if (item.FakeLatency < 0f)
			{
				ReceivePacketData(item.PacketData);
				list.Add(item);
			}
		}
		foreach (PacketLatencyPair item2 in list)
		{
			packetQueue.Remove(item2);
		}
	}

	private void SendPacketData(byte[] data)
	{
		PacketLatencyPair packetLatencyPair = new PacketLatencyPair();
		packetLatencyPair.PacketData = data;
		packetLatencyPair.FakeLatency = LatencySettings.NextValue();
		packetQueue.AddLast(packetLatencyPair);
	}

	private void ReceivePacketData(byte[] data)
	{
		using MemoryStream memoryStream = new MemoryStream(data);
		BinaryReader binaryReader = new BinaryReader(memoryStream);
		int sequence = binaryReader.ReadInt32();
		OvrAvatarPacket packet;
		if (LoopbackAvatar.UseSDKPackets)
		{
			int count = binaryReader.ReadInt32();
			byte[] buffer = binaryReader.ReadBytes(count);
			IntPtr ovrNativePacket = Oculus.Avatar.CAPI.ovrAvatarPacket_Read((uint)data.Length, buffer);
			OvrAvatarPacket ovrAvatarPacket = new OvrAvatarPacket();
			ovrAvatarPacket.ovrNativePacket = ovrNativePacket;
			packet = ovrAvatarPacket;
		}
		else
		{
			packet = OvrAvatarPacket.Read(memoryStream);
		}
		LoopbackAvatar.GetComponent<OvrAvatarRemoteDriver>().QueuePacket(sequence, packet);
	}
}
public class P2PManager
{
	private enum MessageType : byte
	{
		Update = 1
	}

	public P2PManager()
	{
		Net.SetPeerConnectRequestCallback(PeerConnectRequestCallback);
		Net.SetConnectionStateChangedCallback(ConnectionStateChangedCallback);
	}

	public void ConnectTo(ulong userID)
	{
		if (SocialPlatformManager.MyID < userID)
		{
			Net.Connect(userID);
			SocialPlatformManager.LogOutput("P2P connect to " + userID);
		}
	}

	public void Disconnect(ulong userID)
	{
		if (userID != 0)
		{
			Net.Close(userID);
			RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(userID);
			if (remoteUser != null)
			{
				remoteUser.p2pConnectionState = PeerConnectionState.Unknown;
			}
		}
	}

	private void PeerConnectRequestCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("P2P request from " + msg.Data.ID);
		RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(msg.Data.ID);
		if (remoteUser != null)
		{
			SocialPlatformManager.LogOutput("P2P request accepted from " + msg.Data.ID);
			Net.Accept(msg.Data.ID);
		}
	}

	private void ConnectionStateChangedCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("P2P state to " + msg.Data.ID + " changed to  " + msg.Data.State);
		RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(msg.Data.ID);
		if (remoteUser != null)
		{
			remoteUser.p2pConnectionState = msg.Data.State;
			if (msg.Data.State == PeerConnectionState.Timeout && SocialPlatformManager.MyID < msg.Data.ID)
			{
				Net.Connect(msg.Data.ID);
				SocialPlatformManager.LogOutput("P2P re-connect to " + msg.Data.ID);
			}
		}
	}

	public void SendAvatarUpdate(ulong userID, Transform bodyTransform, uint sequence, byte[] avatarPacket)
	{
		byte[] array = new byte[avatarPacket.Length + 41];
		int offset = 0;
		PackByte(1, array, ref offset);
		PackULong(SocialPlatformManager.MyID, array, ref offset);
		PackFloat(bodyTransform.localPosition.x, array, ref offset);
		PackFloat(bodyTransform.localPosition.y, array, ref offset);
		PackFloat(bodyTransform.localPosition.z, array, ref offset);
		PackFloat(bodyTransform.localRotation.x, array, ref offset);
		PackFloat(bodyTransform.localRotation.y, array, ref offset);
		PackFloat(bodyTransform.localRotation.z, array, ref offset);
		PackFloat(bodyTransform.localRotation.w, array, ref offset);
		PackUInt32(sequence, array, ref offset);
		Buffer.BlockCopy(avatarPacket, 0, array, offset, avatarPacket.Length);
		Net.SendPacket(userID, array, SendPolicy.Unreliable);
	}

	public void GetRemotePackets()
	{
		Packet packet;
		while ((packet = Net.ReadPacket()) != null)
		{
			byte[] packet2 = new byte[packet.Size];
			packet.ReadBytes(packet2);
			int offset = 0;
			MessageType messageType = (MessageType)ReadByte(packet2, ref offset);
			ulong num = ReadULong(packet2, ref offset);
			RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(num);
			if (remoteUser == null)
			{
				SocialPlatformManager.LogOutput("Unknown remote player: " + num);
			}
			else if (messageType == MessageType.Update)
			{
				processAvatarPacket(remoteUser, ref packet2, ref offset);
			}
			else
			{
				SocialPlatformManager.LogOutput("Invalid packet type: " + packet.Size);
			}
		}
	}

	public void processAvatarPacket(RemotePlayer remote, ref byte[] packet, ref int offset)
	{
		if (remote != null)
		{
			remote.receivedBodyPositionPrior = remote.receivedBodyPosition;
			remote.receivedBodyPosition.x = ReadFloat(packet, ref offset);
			remote.receivedBodyPosition.y = ReadFloat(packet, ref offset);
			remote.receivedBodyPosition.z = ReadFloat(packet, ref offset);
			remote.receivedBodyRotationPrior = remote.receivedBodyRotation;
			remote.receivedBodyRotation.x = ReadFloat(packet, ref offset);
			remote.receivedBodyRotation.y = ReadFloat(packet, ref offset);
			remote.receivedBodyRotation.z = ReadFloat(packet, ref offset);
			remote.receivedBodyRotation.w = ReadFloat(packet, ref offset);
			remote.RemoteAvatar.transform.localPosition = remote.receivedBodyPosition;
			remote.RemoteAvatar.transform.localRotation = remote.receivedBodyRotation;
			int sequence = (int)ReadUInt32(packet, ref offset);
			byte[] array = new byte[packet.Length - offset];
			Buffer.BlockCopy(packet, offset, array, 0, array.Length);
			IntPtr ovrNativePacket = Oculus.Avatar.CAPI.ovrAvatarPacket_Read((uint)array.Length, array);
			OvrAvatarPacket ovrAvatarPacket = new OvrAvatarPacket();
			ovrAvatarPacket.ovrNativePacket = ovrNativePacket;
			OvrAvatarPacket packet2 = ovrAvatarPacket;
			remote.RemoteAvatar.GetComponent<OvrAvatarRemoteDriver>().QueuePacket(sequence, packet2);
		}
	}

	private void PackByte(byte b, byte[] buf, ref int offset)
	{
		buf[offset] = b;
		offset++;
	}

	private byte ReadByte(byte[] buf, ref int offset)
	{
		byte result = buf[offset];
		offset++;
		return result;
	}

	private void PackFloat(float f, byte[] buf, ref int offset)
	{
		Buffer.BlockCopy(BitConverter.GetBytes(f), 0, buf, offset, 4);
		offset += 4;
	}

	private float ReadFloat(byte[] buf, ref int offset)
	{
		float result = BitConverter.ToSingle(buf, offset);
		offset += 4;
		return result;
	}

	private void PackULong(ulong u, byte[] buf, ref int offset)
	{
		Buffer.BlockCopy(BitConverter.GetBytes(u), 0, buf, offset, 8);
		offset += 8;
	}

	private ulong ReadULong(byte[] buf, ref int offset)
	{
		ulong result = BitConverter.ToUInt64(buf, offset);
		offset += 8;
		return result;
	}

	private void PackUInt32(uint u, byte[] buf, ref int offset)
	{
		Buffer.BlockCopy(BitConverter.GetBytes(u), 0, buf, offset, 4);
		offset += 4;
	}

	private uint ReadUInt32(byte[] buf, ref int offset)
	{
		uint result = BitConverter.ToUInt32(buf, offset);
		offset += 4;
		return result;
	}
}
public class PlayerController : SocialPlatformManager
{
	public Camera spyCamera;

	private GameObject cameraRig;

	private bool showUI = true;

	public override void Awake()
	{
		base.Awake();
		cameraRig = localPlayerHead.gameObject;
	}

	public override void Start()
	{
		base.Start();
		spyCamera.enabled = false;
	}

	public override void Update()
	{
		base.Update();
		checkInput();
	}

	private void checkInput()
	{
		if (UnityEngine.Application.platform == RuntimePlatform.Android)
		{
			if (OVRInput.GetDown(OVRInput.Button.Back))
			{
				Rooms.LaunchInvitableUserFlow(roomManager.roomID);
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryTouchpad))
			{
				ToggleCamera();
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger))
			{
				ToggleUI();
			}
		}
		else
		{
			if (OVRInput.GetDown(OVRInput.Button.Three))
			{
				Rooms.LaunchInvitableUserFlow(roomManager.roomID);
			}
			if (OVRInput.GetDown(OVRInput.Button.Four))
			{
				ToggleCamera();
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryThumbstick))
			{
				ToggleUI();
			}
		}
	}

	private void ToggleCamera()
	{
		spyCamera.enabled = !spyCamera.enabled;
		localAvatar.ShowThirdPerson = !localAvatar.ShowThirdPerson;
		cameraRig.SetActive(!cameraRig.activeSelf);
	}

	private void ToggleUI()
	{
		showUI = !showUI;
		helpPanel.SetActive(showUI);
		localAvatar.ShowLeftController(showUI);
	}
}
public class RemotePlayer
{
	public ulong remoteUserID;

	public bool stillInRoom;

	public PeerConnectionState p2pConnectionState;

	public PeerConnectionState voipConnectionState;

	public OvrAvatar RemoteAvatar;

	public Vector3 receivedBodyPosition;

	public Vector3 receivedBodyPositionPrior;

	public Quaternion receivedBodyRotation;

	public Quaternion receivedBodyRotationPrior;

	public VoipAudioSourceHiLevel voipSource;
}
public class RoomManager
{
	public ulong roomID;

	private ulong invitedRoomID;

	private bool amIServer;

	private bool startupDone;

	public RoomManager()
	{
		amIServer = false;
		startupDone = false;
		Rooms.SetRoomInviteAcceptedNotificationCallback(AcceptingInviteCallback);
		Rooms.SetUpdateNotificationCallback(RoomUpdateCallback);
	}

	private void AcceptingInviteCallback(Message<string> msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
			return;
		}
		SocialPlatformManager.LogOutput("Launched Invite to join Room: " + msg.Data);
		invitedRoomID = Convert.ToUInt64(msg.GetString());
		if (startupDone)
		{
			CheckForInvite();
		}
	}

	public bool CheckForInvite()
	{
		startupDone = true;
		if (invitedRoomID != 0)
		{
			JoinExistingRoom(invitedRoomID);
			return true;
		}
		return false;
	}

	public void CreateRoom()
	{
		Rooms.CreateAndJoinPrivate(RoomJoinPolicy.FriendsOfOwner, 4u, subscribeToUpdates: true).OnComplete(CreateAndJoinPrivateRoomCallback);
	}

	private void CreateAndJoinPrivateRoomCallback(Message<Oculus.Platform.Models.Room> msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
			return;
		}
		roomID = msg.Data.ID;
		if (msg.Data.OwnerOptional != null && msg.Data.OwnerOptional.ID == SocialPlatformManager.MyID)
		{
			amIServer = true;
		}
		else
		{
			amIServer = false;
		}
		SocialPlatformManager.TransitionToState(SocialPlatformManager.State.WAITING_IN_A_ROOM);
		SocialPlatformManager.SetFloorColorForState(amIServer);
	}

	private void OnLaunchInviteWorkflowComplete(Message msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
		}
	}

	public void JoinExistingRoom(ulong roomID)
	{
		SocialPlatformManager.TransitionToState(SocialPlatformManager.State.JOINING_A_ROOM);
		Rooms.Join(roomID, subscribeToUpdates: true).OnComplete(JoinRoomCallback);
	}

	private void JoinRoomCallback(Message<Oculus.Platform.Models.Room> msg)
	{
		if (!msg.IsError)
		{
			string text = ((msg.Data.OwnerOptional == null) ? "null" : msg.Data.OwnerOptional.OculusID);
			int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
			SocialPlatformManager.LogOutput("Joined Room " + msg.Data.ID + " owner: " + text + " count: " + num);
			roomID = msg.Data.ID;
			ProcessRoomData(msg);
		}
	}

	private void RoomUpdateCallback(Message<Oculus.Platform.Models.Room> msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
			return;
		}
		string text = ((msg.Data.OwnerOptional == null) ? "null" : msg.Data.OwnerOptional.OculusID);
		int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
		SocialPlatformManager.LogOutput("Room Update " + msg.Data.ID + " owner: " + text + " count: " + num);
		ProcessRoomData(msg);
	}

	public void LeaveCurrentRoom()
	{
		if (roomID != 0)
		{
			Rooms.Leave(roomID);
			roomID = 0uL;
		}
		SocialPlatformManager.TransitionToState(SocialPlatformManager.State.LEAVING_A_ROOM);
	}

	private void ProcessRoomData(Message<Oculus.Platform.Models.Room> msg)
	{
		if (msg.Data.OwnerOptional != null && msg.Data.OwnerOptional.ID == SocialPlatformManager.MyID)
		{
			amIServer = true;
		}
		else
		{
			amIServer = false;
		}
		if (msg.Data.UsersOptional != null && msg.Data.UsersOptional.Count == 1)
		{
			SocialPlatformManager.TransitionToState(SocialPlatformManager.State.WAITING_IN_A_ROOM);
		}
		else
		{
			SocialPlatformManager.TransitionToState(SocialPlatformManager.State.CONNECTED_IN_A_ROOM);
		}
		SocialPlatformManager.MarkAllRemoteUsersAsNotInRoom();
		if (msg.Data.UsersOptional != null)
		{
			foreach (User item in msg.Data.UsersOptional)
			{
				if (item.ID != SocialPlatformManager.MyID)
				{
					if (!SocialPlatformManager.IsUserInRoom(item.ID))
					{
						SocialPlatformManager.AddRemoteUser(item.ID);
					}
					else
					{
						SocialPlatformManager.MarkRemoteUserInRoom(item.ID);
					}
				}
			}
		}
		SocialPlatformManager.ForgetRemoteUsersNotInRoom();
		SocialPlatformManager.SetFloorColorForState(amIServer);
	}
}
public class SocialPlatformManager : MonoBehaviour
{
	public enum State
	{
		INITIALIZING,
		CHECKING_LAUNCH_STATE,
		CREATING_A_ROOM,
		WAITING_IN_A_ROOM,
		JOINING_A_ROOM,
		CONNECTED_IN_A_ROOM,
		LEAVING_A_ROOM,
		SHUTDOWN
	}

	private static readonly Vector3 START_ROTATION_ONE = new Vector3(0f, 180f, 0f);

	private static readonly Vector3 START_POSITION_ONE = new Vector3(0f, 4f, 5f);

	private static readonly Vector3 START_ROTATION_TWO = new Vector3(0f, 0f, 0f);

	private static readonly Vector3 START_POSITION_TWO = new Vector3(0f, 4f, -5f);

	private static readonly Vector3 START_ROTATION_THREE = new Vector3(0f, 270f, 0f);

	private static readonly Vector3 START_POSITION_THREE = new Vector3(5f, 4f, 0f);

	private static readonly Vector3 START_ROTATION_FOUR = new Vector3(0f, 90f, 0f);

	private static readonly Vector3 START_POSITION_FOUR = new Vector3(-5f, 4f, 0f);

	private static readonly Color BLACK = new Color(0f, 0f, 0f);

	private static readonly Color WHITE = new Color(1f, 1f, 1f);

	private static readonly Color CYAN = new Color(0f, 1f, 1f);

	private static readonly Color BLUE = new Color(0f, 0f, 1f);

	private static readonly Color GREEN = new Color(0f, 1f, 0f);

	public Oculus.Platform.CAPI.FilterCallback micFilterDelegate = MicFilter;

	private float voiceCurrent;

	private uint packetSequence;

	public OvrAvatar localAvatarPrefab;

	public OvrAvatar remoteAvatarPrefab;

	public GameObject helpPanel;

	protected MeshRenderer helpMesh;

	public Material riftMaterial;

	public Material gearMaterial;

	protected OvrAvatar localAvatar;

	protected GameObject localTrackingSpace;

	protected GameObject localPlayerHead;

	protected Dictionary<ulong, RemotePlayer> remoteUsers = new Dictionary<ulong, RemotePlayer>();

	public GameObject roomSphere;

	protected MeshRenderer sphereMesh;

	public GameObject roomFloor;

	protected MeshRenderer floorMesh;

	protected State currentState;

	protected static SocialPlatformManager s_instance = null;

	protected RoomManager roomManager;

	protected P2PManager p2pManager;

	protected VoipManager voipManager;

	protected ulong myID;

	protected string myOculusID;

	public static readonly float VOIP_SCALE = 2f;

	public static State CurrentState => s_instance.currentState;

	public static ulong MyID
	{
		get
		{
			if (s_instance != null)
			{
				return s_instance.myID;
			}
			return 0uL;
		}
	}

	public static string MyOculusID
	{
		get
		{
			if (s_instance != null && s_instance.myOculusID != null)
			{
				return s_instance.myOculusID;
			}
			return string.Empty;
		}
	}

	public virtual void Update()
	{
		p2pManager.GetRemotePackets();
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in remoteUsers)
		{
			float voiceAmplitude = Mathf.Clamp(remoteUser.Value.voipSource.peakAmplitude * VOIP_SCALE, 0f, 1f);
			remoteUser.Value.RemoteAvatar.VoiceAmplitude = voiceAmplitude;
		}
		if (localAvatar != null)
		{
			localAvatar.VoiceAmplitude = Mathf.Clamp(voiceCurrent * VOIP_SCALE, 0f, 1f);
		}
	}

	public virtual void Awake()
	{
		LogOutputLine("Start Log.");
		helpMesh = helpPanel.GetComponent<MeshRenderer>();
		sphereMesh = roomSphere.GetComponent<MeshRenderer>();
		floorMesh = roomFloor.GetComponent<MeshRenderer>();
		localTrackingSpace = base.transform.Find("OVRCameraRig/TrackingSpace").gameObject;
		localPlayerHead = base.transform.Find("OVRCameraRig/TrackingSpace/CenterEyeAnchor").gameObject;
		if (s_instance != null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		s_instance = this;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		TransitionToState(State.INITIALIZING);
		Core.Initialize();
		roomManager = new RoomManager();
		p2pManager = new P2PManager();
		voipManager = new VoipManager();
	}

	public virtual void Start()
	{
		Entitlements.IsUserEntitledToApplication().OnComplete(IsEntitledCallback);
		Request.RunCallbacks();
	}

	private void IsEntitledCallback(Message msg)
	{
		if (msg.IsError)
		{
			TerminateWithError(msg);
			return;
		}
		Users.GetLoggedInUser().OnComplete(GetLoggedInUserCallback);
		Request.RunCallbacks();
	}

	private void GetLoggedInUserCallback(Message<User> msg)
	{
		if (msg.IsError)
		{
			TerminateWithError(msg);
			return;
		}
		myID = msg.Data.ID;
		myOculusID = msg.Data.OculusID;
		localAvatar = UnityEngine.Object.Instantiate(localAvatarPrefab);
		localTrackingSpace = base.transform.Find("OVRCameraRig/TrackingSpace").gameObject;
		localAvatar.transform.SetParent(localTrackingSpace.transform, worldPositionStays: false);
		localAvatar.transform.localPosition = new Vector3(0f, 0f, 0f);
		localAvatar.transform.localRotation = Quaternion.identity;
		if (UnityEngine.Application.platform == RuntimePlatform.Android)
		{
			helpPanel.transform.SetParent(localAvatar.transform.Find("body"), worldPositionStays: false);
			helpPanel.transform.localPosition = new Vector3(0f, 1f, 1f);
			helpMesh.material = gearMaterial;
		}
		else
		{
			helpPanel.transform.SetParent(localAvatar.transform.Find("hand_left"), worldPositionStays: false);
			helpPanel.transform.localPosition = new Vector3(0f, 0.2f, 0.2f);
			helpMesh.material = riftMaterial;
		}
		localAvatar.oculusUserID = myID.ToString();
		localAvatar.RecordPackets = true;
		OvrAvatar ovrAvatar = localAvatar;
		ovrAvatar.PacketRecorded = (EventHandler<OvrAvatar.PacketEventArgs>)Delegate.Combine(ovrAvatar.PacketRecorded, new EventHandler<OvrAvatar.PacketEventArgs>(OnLocalAvatarPacketRecorded));
		localAvatar.EnableMouthVertexAnimation = true;
		Quaternion identity = Quaternion.identity;
		switch (UnityEngine.Random.Range(0, 4))
		{
		case 0:
			identity.eulerAngles = START_ROTATION_ONE;
			base.transform.localPosition = START_POSITION_ONE;
			base.transform.localRotation = identity;
			break;
		case 1:
			identity.eulerAngles = START_ROTATION_TWO;
			base.transform.localPosition = START_POSITION_TWO;
			base.transform.localRotation = identity;
			break;
		case 2:
			identity.eulerAngles = START_ROTATION_THREE;
			base.transform.localPosition = START_POSITION_THREE;
			base.transform.localRotation = identity;
			break;
		default:
			identity.eulerAngles = START_ROTATION_FOUR;
			base.transform.localPosition = START_POSITION_FOUR;
			base.transform.localRotation = identity;
			break;
		}
		TransitionToState(State.CHECKING_LAUNCH_STATE);
		if (!roomManager.CheckForInvite())
		{
			LogOutput("No invite on launch, looking for a friend to join.");
			Users.GetLoggedInUserFriendsAndRooms().OnComplete(GetLoggedInUserFriendsAndRoomsCallback);
		}
		Voip.SetMicrophoneFilterCallback(micFilterDelegate);
	}

	private void GetLoggedInUserFriendsAndRoomsCallback(Message<UserAndRoomList> msg)
	{
		if (msg.IsError)
		{
			return;
		}
		foreach (UserAndRoom datum in msg.Data)
		{
			if (datum.User == null || datum.RoomOptional == null || datum.RoomOptional.IsMembershipLocked || datum.RoomOptional.Joinability != RoomJoinability.CanJoin || datum.RoomOptional.JoinPolicy == RoomJoinPolicy.None)
			{
				continue;
			}
			LogOutput("Trying to join room " + datum.RoomOptional.ID + ", friend " + datum.User.OculusID);
			roomManager.JoinExistingRoom(datum.RoomOptional.ID);
			return;
		}
		LogOutput("No friend to join. Creating my own room.");
		roomManager.CreateRoom();
		TransitionToState(State.CREATING_A_ROOM);
	}

	public void OnLocalAvatarPacketRecorded(object sender, OvrAvatar.PacketEventArgs args)
	{
		uint num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetSize(args.Packet.ovrNativePacket);
		byte[] array = new byte[num];
		Oculus.Avatar.CAPI.ovrAvatarPacket_Write(args.Packet.ovrNativePacket, num, array);
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in remoteUsers)
		{
			p2pManager.SendAvatarUpdate(remoteUser.Key, localAvatar.transform, packetSequence, array);
		}
		packetSequence++;
	}

	public void OnApplicationQuit()
	{
		roomManager.LeaveCurrentRoom();
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in remoteUsers)
		{
			p2pManager.Disconnect(remoteUser.Key);
			voipManager.Disconnect(remoteUser.Key);
		}
		LogOutputLine("End Log.");
	}

	public void AddUser(ulong userID, ref RemotePlayer remoteUser)
	{
		remoteUsers.Add(userID, remoteUser);
	}

	public void LogOutputLine(string line)
	{
		Debug.Log(Time.time + ": " + line);
	}

	public static void TerminateWithError(Message msg)
	{
		s_instance.LogOutputLine("Error: " + msg.GetError().Message);
		UnityEngine.Application.Quit();
	}

	public static void TransitionToState(State newState)
	{
		if ((bool)s_instance)
		{
			s_instance.LogOutputLine(string.Concat("State ", s_instance.currentState, " -> ", newState));
		}
		if ((bool)s_instance && s_instance.currentState != newState)
		{
			s_instance.currentState = newState;
			if (newState == State.SHUTDOWN)
			{
				s_instance.OnApplicationQuit();
			}
		}
		SetSphereColorForState();
	}

	private static void SetSphereColorForState()
	{
		switch (s_instance.currentState)
		{
		case State.INITIALIZING:
		case State.SHUTDOWN:
			s_instance.sphereMesh.material.color = BLACK;
			break;
		case State.WAITING_IN_A_ROOM:
			s_instance.sphereMesh.material.color = WHITE;
			break;
		case State.CONNECTED_IN_A_ROOM:
			s_instance.sphereMesh.material.color = CYAN;
			break;
		case State.CHECKING_LAUNCH_STATE:
		case State.CREATING_A_ROOM:
		case State.JOINING_A_ROOM:
		case State.LEAVING_A_ROOM:
			break;
		}
	}

	public static void SetFloorColorForState(bool host)
	{
		if (host)
		{
			s_instance.floorMesh.material.color = BLUE;
		}
		else
		{
			s_instance.floorMesh.material.color = GREEN;
		}
	}

	public static void MarkAllRemoteUsersAsNotInRoom()
	{
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in s_instance.remoteUsers)
		{
			remoteUser.Value.stillInRoom = false;
		}
	}

	public static void MarkRemoteUserInRoom(ulong userID)
	{
		RemotePlayer value = new RemotePlayer();
		if (s_instance.remoteUsers.TryGetValue(userID, out value))
		{
			value.stillInRoom = true;
		}
	}

	public static void ForgetRemoteUsersNotInRoom()
	{
		List<ulong> list = new List<ulong>();
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in s_instance.remoteUsers)
		{
			if (!remoteUser.Value.stillInRoom)
			{
				list.Add(remoteUser.Key);
			}
		}
		foreach (ulong item in list)
		{
			RemoveRemoteUser(item);
		}
	}

	public static void LogOutput(string line)
	{
		s_instance.LogOutputLine(Time.time + ": " + line);
	}

	public static bool IsUserInRoom(ulong userID)
	{
		return s_instance.remoteUsers.ContainsKey(userID);
	}

	public static void AddRemoteUser(ulong userID)
	{
		RemotePlayer remoteUser = new RemotePlayer();
		remoteUser.RemoteAvatar = UnityEngine.Object.Instantiate(s_instance.remoteAvatarPrefab);
		remoteUser.RemoteAvatar.oculusUserID = userID.ToString();
		remoteUser.RemoteAvatar.ShowThirdPerson = true;
		remoteUser.RemoteAvatar.EnableMouthVertexAnimation = true;
		remoteUser.p2pConnectionState = PeerConnectionState.Unknown;
		remoteUser.voipConnectionState = PeerConnectionState.Unknown;
		remoteUser.stillInRoom = true;
		remoteUser.remoteUserID = userID;
		s_instance.AddUser(userID, ref remoteUser);
		s_instance.p2pManager.ConnectTo(userID);
		s_instance.voipManager.ConnectTo(userID);
		remoteUser.voipSource = remoteUser.RemoteAvatar.gameObject.AddComponent<VoipAudioSourceHiLevel>();
		remoteUser.voipSource.senderID = userID;
		s_instance.LogOutputLine("Adding User " + userID);
	}

	public static void RemoveRemoteUser(ulong userID)
	{
		RemotePlayer value = new RemotePlayer();
		if (s_instance.remoteUsers.TryGetValue(userID, out value))
		{
			UnityEngine.Object.Destroy(value.RemoteAvatar.GetComponent<VoipAudioSourceHiLevel>(), 0f);
			UnityEngine.Object.Destroy(value.RemoteAvatar.gameObject, 0f);
			s_instance.remoteUsers.Remove(userID);
			s_instance.LogOutputLine("Removing User " + userID);
		}
	}

	public void UpdateVoiceData(short[] pcmData)
	{
		float num = 0f;
		float[] array = new float[pcmData.Length];
		for (int i = 0; i < pcmData.Length; i++)
		{
			float num2 = (array[i] = (float)pcmData[i] / 32767f);
			if (num2 > num)
			{
				num = num2;
			}
		}
		voiceCurrent = num;
	}

	public static void MicFilter(short[] pcmData, UIntPtr pcmDataLength, int frequency, int numChannels)
	{
		s_instance.UpdateVoiceData(pcmData);
	}

	public static RemotePlayer GetRemoteUser(ulong userID)
	{
		RemotePlayer value = new RemotePlayer();
		if (s_instance.remoteUsers.TryGetValue(userID, out value))
		{
			return value;
		}
		return null;
	}
}
public class VoipManager
{
	public VoipManager()
	{
		Voip.SetVoipConnectRequestCallback(VoipConnectRequestCallback);
		Voip.SetVoipStateChangeCallback(VoipStateChangedCallback);
	}

	public void ConnectTo(ulong userID)
	{
		if (SocialPlatformManager.MyID < userID)
		{
			Voip.Start(userID);
			SocialPlatformManager.LogOutput("Voip connect to " + userID);
		}
	}

	public void Disconnect(ulong userID)
	{
		if (userID != 0)
		{
			Voip.Stop(userID);
			RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(userID);
			if (remoteUser != null)
			{
				remoteUser.voipConnectionState = PeerConnectionState.Unknown;
			}
		}
	}

	private void VoipConnectRequestCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("Voip request from " + msg.Data.ID);
		RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(msg.Data.ID);
		if (remoteUser != null)
		{
			SocialPlatformManager.LogOutput("Voip request accepted from " + msg.Data.ID);
			Voip.Accept(msg.Data.ID);
		}
	}

	private void VoipStateChangedCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("Voip state to " + msg.Data.ID + " changed to  " + msg.Data.State);
		RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(msg.Data.ID);
		if (remoteUser != null)
		{
			remoteUser.voipConnectionState = msg.Data.State;
			if (msg.Data.State == PeerConnectionState.Timeout && SocialPlatformManager.MyID < msg.Data.ID)
			{
				Voip.Start(msg.Data.ID);
				SocialPlatformManager.LogOutput("Voip re-connect to " + msg.Data.ID);
			}
		}
	}
}
[Serializable]
public class AvatarLayer
{
	public int layerIndex;
}
[Serializable]
public class PacketRecordSettings
{
	internal bool RecordingFrames;

	public float UpdateRate = 1f / 30f;

	internal float AccumulatedTime;
}
public class OvrAvatar : MonoBehaviour
{
	public class PacketEventArgs : EventArgs
	{
		public readonly OvrAvatarPacket Packet;

		public PacketEventArgs(OvrAvatarPacket packet)
		{
			Packet = packet;
		}
	}

	public enum HandType
	{
		Right,
		Left,
		Max
	}

	public enum HandJoint
	{
		HandBase,
		IndexBase,
		IndexTip,
		ThumbBase,
		ThumbTip,
		Max
	}

	public OvrAvatarMaterialManager DefaultBodyMaterialManager;

	public OvrAvatarMaterialManager DefaultHandMaterialManager;

	public OvrAvatarDriver Driver;

	public OvrAvatarBase Base;

	public OvrAvatarBody Body;

	public OvrAvatarTouchController ControllerLeft;

	public OvrAvatarTouchController ControllerRight;

	public OvrAvatarHand HandLeft;

	public OvrAvatarHand HandRight;

	public bool RecordPackets;

	public bool UseSDKPackets = true;

	public bool StartWithControllers;

	public AvatarLayer FirstPersonLayer;

	public AvatarLayer ThirdPersonLayer;

	public bool ShowFirstPerson = true;

	public bool ShowThirdPerson;

	public ovrAvatarCapabilities Capabilities = ovrAvatarCapabilities.All;

	public Shader SurfaceShader;

	public Shader SurfaceShaderSelfOccluding;

	public Shader SurfaceShaderPBS;

	public Shader SurfaceShaderPBSV2Single;

	public Shader SurfaceShaderPBSV2Combined;

	public Shader SurfaceShaderPBSV2Simple;

	public Shader SurfaceShaderPBSV2Loading;

	private int renderPartCount;

	private bool showLeftController;

	private bool showRightController;

	private List<float[]> voiceUpdates = new List<float[]>();

	public string oculusUserID;

	internal ulong oculusUserIDInternal;

	private bool CombineMeshes = true;

	private bool ForceMobileTextureFormat;

	private bool WaitingForCombinedMesh;

	public IntPtr sdkAvatar = IntPtr.Zero;

	private HashSet<ulong> assetLoadingIds = new HashSet<ulong>();

	private Dictionary<string, OvrAvatarComponent> trackedComponents = new Dictionary<string, OvrAvatarComponent>();

	private UnityEvent AssetsDoneLoading = new UnityEvent();

	private bool assetsFinishedLoading;

	public Transform LeftHandCustomPose;

	public Transform RightHandCustomPose;

	private Transform cachedLeftHandCustomPose;

	private Transform[] cachedCustomLeftHandJoints;

	private ovrAvatarTransform[] cachedLeftHandTransforms;

	private Transform cachedRightHandCustomPose;

	private Transform[] cachedCustomRightHandJoints;

	private ovrAvatarTransform[] cachedRightHandTransforms;

	private Vector4 clothingAlphaOffset = new Vector4(0f, 0f, 0f, 1f);

	private ulong clothingAlphaTexture;

	public PacketRecordSettings PacketSettings = new PacketRecordSettings();

	private OvrAvatarPacket CurrentUnityPacket;

	private static string[,] HandJoints = new string[2, 5]
	{
		{ "hands:r_hand_world", "hands:r_hand_world/hands:b_r_hand/hands:b_r_index1", "hands:r_hand_world/hands:b_r_hand/hands:b_r_index1/hands:b_r_index2/hands:b_r_index3/hands:b_r_index_ignore", "hands:r_hand_world/hands:b_r_hand/hands:b_r_thumb1/hands:b_r_thumb2", "hands:r_hand_world/hands:b_r_hand/hands:b_r_thumb1/hands:b_r_thumb2/hands:b_r_thumb3/hands:b_r_thumb_ignore" },
		{ "hands:l_hand_world", "hands:l_hand_world/hands:b_l_hand/hands:b_l_index1", "hands:l_hand_world/hands:b_l_hand/hands:b_l_index1/hands:b_l_index2/hands:b_l_index3/hands:b_l_index_ignore", "hands:l_hand_world/hands:b_l_hand/hands:b_l_thumb1/hands:b_l_thumb2", "hands:l_hand_world/hands:b_l_hand/hands:b_l_thumb1/hands:b_l_thumb2/hands:b_l_thumb3/hands:b_l_thumb_ignore" }
	};

	internal ovrAvatarAssetLevelOfDetail LevelOfDetail = ovrAvatarAssetLevelOfDetail.Medium;

	public EventHandler<PacketEventArgs> PacketRecorded;

	private static Vector3 MOUTH_POSITION_OFFSET = new Vector3(0f, -0.018f, 0.1051f);

	private static string VOICE_PROPERTY = "_Voice";

	private static string MOUTH_POSITION_PROPERTY = "_MouthPosition";

	private static string MOUTH_DIRECTION_PROPERTY = "_MouthDirection";

	private static string MOUTH_SCALE_PROPERTY = "_MouthEffectScale";

	private static float MOUTH_SCALE_GLOBAL = 0.007f;

	private static float MOUTH_MAX_GLOBAL = 0.007f;

	private static string NECK_JONT = "root_JNT/body_JNT/chest_JNT/neckBase_JNT/neck_JNT";

	public float VoiceAmplitude;

	public bool EnableMouthVertexAnimation;

	private void OnDestroy()
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_Destroy(sdkAvatar);
		}
	}

	public void AssetLoadedCallback(OvrAvatarAsset asset)
	{
		assetLoadingIds.Remove(asset.assetID);
	}

	public void CombinedMeshLoadedCallback(IntPtr assetPtr)
	{
		if (WaitingForCombinedMesh)
		{
			ulong[] array = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshIDs(assetPtr);
			ulong[] array2 = array;
			foreach (ulong item in array2)
			{
				assetLoadingIds.Remove(item);
			}
			Oculus.Avatar.CAPI.ovrAvatar_GetCombinedMeshAlphaData(sdkAvatar, ref clothingAlphaTexture, ref clothingAlphaOffset);
			WaitingForCombinedMesh = false;
		}
	}

	private void AddAvatarComponent(GameObject componentObject, ovrAvatarComponent component)
	{
		OvrAvatarComponent ovrAvatarComponent2 = componentObject.AddComponent<OvrAvatarComponent>();
		trackedComponents.Add(component.name, ovrAvatarComponent2);
		if (ovrAvatarComponent2.name == "body")
		{
			ovrAvatarComponent2.ClothingAlphaOffset = clothingAlphaOffset;
			ovrAvatarComponent2.ClothingAlphaTexture = clothingAlphaTexture;
		}
		AddRenderParts(ovrAvatarComponent2, component, componentObject.transform);
	}

	private OvrAvatarSkinnedMeshRenderComponent AddSkinnedMeshRenderComponent(GameObject gameObject, ovrAvatarRenderPart_SkinnedMeshRender skinnedMeshRender)
	{
		OvrAvatarSkinnedMeshRenderComponent ovrAvatarSkinnedMeshRenderComponent = gameObject.AddComponent<OvrAvatarSkinnedMeshRenderComponent>();
		ovrAvatarSkinnedMeshRenderComponent.Initialize(skinnedMeshRender, SurfaceShader, SurfaceShaderSelfOccluding, ThirdPersonLayer.layerIndex, FirstPersonLayer.layerIndex, renderPartCount++);
		return ovrAvatarSkinnedMeshRenderComponent;
	}

	private OvrAvatarSkinnedMeshRenderPBSComponent AddSkinnedMeshRenderPBSComponent(GameObject gameObject, ovrAvatarRenderPart_SkinnedMeshRenderPBS skinnedMeshRenderPBS)
	{
		OvrAvatarSkinnedMeshRenderPBSComponent ovrAvatarSkinnedMeshRenderPBSComponent = gameObject.AddComponent<OvrAvatarSkinnedMeshRenderPBSComponent>();
		ovrAvatarSkinnedMeshRenderPBSComponent.Initialize(skinnedMeshRenderPBS, SurfaceShaderPBS, ThirdPersonLayer.layerIndex, FirstPersonLayer.layerIndex, renderPartCount++);
		return ovrAvatarSkinnedMeshRenderPBSComponent;
	}

	private OvrAvatarSkinnedMeshPBSV2RenderComponent AddSkinnedMeshRenderPBSV2Component(IntPtr renderPart, GameObject gameObject, ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2 skinnedMeshRenderPBSV2, OvrAvatarMaterialManager materialManager)
	{
		OvrAvatarSkinnedMeshPBSV2RenderComponent ovrAvatarSkinnedMeshPBSV2RenderComponent = gameObject.AddComponent<OvrAvatarSkinnedMeshPBSV2RenderComponent>();
		ovrAvatarSkinnedMeshPBSV2RenderComponent.Initialize(renderPart, skinnedMeshRenderPBSV2, materialManager, ThirdPersonLayer.layerIndex, FirstPersonLayer.layerIndex, renderPartCount++, gameObject.name.Contains("body") && CombineMeshes, LevelOfDetail);
		return ovrAvatarSkinnedMeshPBSV2RenderComponent;
	}

	private OvrAvatarProjectorRenderComponent AddProjectorRenderComponent(GameObject gameObject, ovrAvatarRenderPart_ProjectorRender projectorRender)
	{
		ovrAvatarComponent ovrAvatarComponent2 = Oculus.Avatar.CAPI.ovrAvatarComponent_Get(sdkAvatar, projectorRender.componentIndex);
		if (trackedComponents.TryGetValue(ovrAvatarComponent2.name, out var value) && projectorRender.renderPartIndex < value.RenderParts.Count)
		{
			OvrAvatarRenderComponent target = value.RenderParts[(int)projectorRender.renderPartIndex];
			OvrAvatarProjectorRenderComponent ovrAvatarProjectorRenderComponent = gameObject.AddComponent<OvrAvatarProjectorRenderComponent>();
			ovrAvatarProjectorRenderComponent.InitializeProjectorRender(projectorRender, SurfaceShader, target);
			return ovrAvatarProjectorRenderComponent;
		}
		return null;
	}

	public static IntPtr GetRenderPart(ovrAvatarComponent component, uint renderPartIndex)
	{
		long num = Marshal.SizeOf(typeof(IntPtr)) * renderPartIndex;
		IntPtr ptr = new IntPtr(component.renderParts.ToInt64() + num);
		return (IntPtr)Marshal.PtrToStructure(ptr, typeof(IntPtr));
	}

	private void UpdateAvatarComponent(ovrAvatarComponent component)
	{
		if (!trackedComponents.TryGetValue(component.name, out var value))
		{
			throw new Exception($"trackedComponents didn't have {component.name}");
		}
		value.UpdateAvatar(component, this);
	}

	private static string GetRenderPartName(ovrAvatarComponent component, uint renderPartIndex)
	{
		return component.name + "_renderPart_" + (int)renderPartIndex;
	}

	internal static void ConvertTransform(ovrAvatarTransform transform, Transform target)
	{
		Vector3 position = transform.position;
		position.z = 0f - position.z;
		Quaternion orientation = transform.orientation;
		orientation.x = 0f - orientation.x;
		orientation.y = 0f - orientation.y;
		target.localPosition = position;
		target.localRotation = orientation;
		target.localScale = transform.scale;
	}

	public static ovrAvatarTransform CreateOvrAvatarTransform(Vector3 position, Quaternion orientation)
	{
		ovrAvatarTransform result = default(ovrAvatarTransform);
		result.position = new Vector3(position.x, position.y, 0f - position.z);
		result.orientation = new Quaternion(0f - orientation.x, 0f - orientation.y, orientation.z, orientation.w);
		result.scale = Vector3.one;
		return result;
	}

	private void RemoveAvatarComponent(string name)
	{
		trackedComponents.TryGetValue(name, out var value);
		UnityEngine.Object.Destroy(value.gameObject);
		trackedComponents.Remove(name);
	}

	private void UpdateSDKAvatarUnityState()
	{
		uint num = Oculus.Avatar.CAPI.ovrAvatarComponent_Count(sdkAvatar);
		HashSet<string> hashSet = new HashSet<string>();
		for (uint num2 = 0u; num2 < num; num2++)
		{
			IntPtr intPtr = Oculus.Avatar.CAPI.ovrAvatarComponent_Get_Native(sdkAvatar, num2);
			ovrAvatarComponent component = (ovrAvatarComponent)Marshal.PtrToStructure(intPtr, typeof(ovrAvatarComponent));
			hashSet.Add(component.name);
			if (!trackedComponents.ContainsKey(component.name))
			{
				GameObject gameObject = null;
				Type type = null;
				if ((Capabilities & ovrAvatarCapabilities.Base) != 0)
				{
					ovrAvatarBaseComponent? ovrAvatarBaseComponent2 = Oculus.Avatar.CAPI.ovrAvatarPose_GetBaseComponent(sdkAvatar);
					if (ovrAvatarBaseComponent2.HasValue && intPtr == ovrAvatarBaseComponent2.Value.renderComponent)
					{
						type = typeof(OvrAvatarBase);
						if (Base != null)
						{
							gameObject = Base.gameObject;
						}
					}
				}
				if (type == null && (Capabilities & ovrAvatarCapabilities.Body) != 0)
				{
					ovrAvatarBodyComponent? ovrAvatarBodyComponent2 = Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(sdkAvatar);
					if (ovrAvatarBodyComponent2.HasValue && intPtr == ovrAvatarBodyComponent2.Value.renderComponent)
					{
						type = typeof(OvrAvatarBody);
						if (Body != null)
						{
							gameObject = Body.gameObject;
						}
					}
				}
				if (type == null && (Capabilities & ovrAvatarCapabilities.Hands) != 0)
				{
					ovrAvatarControllerComponent? ovrAvatarControllerComponent2 = Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftControllerComponent(sdkAvatar);
					if (type == null && ovrAvatarControllerComponent2.HasValue && intPtr == ovrAvatarControllerComponent2.Value.renderComponent)
					{
						type = typeof(OvrAvatarTouchController);
						if (ControllerLeft != null)
						{
							gameObject = ControllerLeft.gameObject;
						}
					}
					ovrAvatarControllerComponent2 = Oculus.Avatar.CAPI.ovrAvatarPose_GetRightControllerComponent(sdkAvatar);
					if (type == null && ovrAvatarControllerComponent2.HasValue && intPtr == ovrAvatarControllerComponent2.Value.renderComponent)
					{
						type = typeof(OvrAvatarTouchController);
						if (ControllerRight != null)
						{
							gameObject = ControllerRight.gameObject;
						}
					}
					ovrAvatarHandComponent? ovrAvatarHandComponent2 = Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftHandComponent(sdkAvatar);
					if (type == null && ovrAvatarHandComponent2.HasValue && intPtr == ovrAvatarHandComponent2.Value.renderComponent)
					{
						type = typeof(OvrAvatarHand);
						if (HandLeft != null)
						{
							gameObject = HandLeft.gameObject;
						}
					}
					ovrAvatarHandComponent2 = Oculus.Avatar.CAPI.ovrAvatarPose_GetRightHandComponent(sdkAvatar);
					if (type == null && ovrAvatarHandComponent2.HasValue && intPtr == ovrAvatarHandComponent2.Value.renderComponent)
					{
						type = typeof(OvrAvatarHand);
						if (HandRight != null)
						{
							gameObject = HandRight.gameObject;
						}
					}
				}
				if (gameObject == null && type == null)
				{
					gameObject = new GameObject();
					gameObject.name = component.name;
					gameObject.transform.SetParent(base.transform);
				}
				if (gameObject != null)
				{
					AddAvatarComponent(gameObject, component);
				}
			}
			UpdateAvatarComponent(component);
		}
		HashSet<string> hashSet2 = new HashSet<string>(trackedComponents.Keys);
		hashSet2.ExceptWith(hashSet);
		foreach (string item in hashSet2)
		{
			RemoveAvatarComponent(item);
		}
		UpdateVoiceBehavior();
	}

	private void UpdateCustomPoses()
	{
		if (UpdatePoseRoot(LeftHandCustomPose, ref cachedLeftHandCustomPose, ref cachedCustomLeftHandJoints, ref cachedLeftHandTransforms) && cachedLeftHandCustomPose == null && sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetLeftHandGesture(sdkAvatar, ovrAvatarHandGesture.Default);
		}
		if (UpdatePoseRoot(RightHandCustomPose, ref cachedRightHandCustomPose, ref cachedCustomRightHandJoints, ref cachedRightHandTransforms) && cachedRightHandCustomPose == null && sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetRightHandGesture(sdkAvatar, ovrAvatarHandGesture.Default);
		}
		if (sdkAvatar != IntPtr.Zero)
		{
			if (cachedLeftHandCustomPose != null && UpdateTransforms(cachedCustomLeftHandJoints, cachedLeftHandTransforms))
			{
				Oculus.Avatar.CAPI.ovrAvatar_SetLeftHandCustomGesture(sdkAvatar, (uint)cachedLeftHandTransforms.Length, cachedLeftHandTransforms);
			}
			if (cachedRightHandCustomPose != null && UpdateTransforms(cachedCustomRightHandJoints, cachedRightHandTransforms))
			{
				Oculus.Avatar.CAPI.ovrAvatar_SetRightHandCustomGesture(sdkAvatar, (uint)cachedRightHandTransforms.Length, cachedRightHandTransforms);
			}
		}
	}

	private static bool UpdatePoseRoot(Transform poseRoot, ref Transform cachedPoseRoot, ref Transform[] cachedPoseJoints, ref ovrAvatarTransform[] transforms)
	{
		if (poseRoot == cachedPoseRoot)
		{
			return false;
		}
		if (!poseRoot)
		{
			cachedPoseRoot = null;
			cachedPoseJoints = null;
			transforms = null;
		}
		else
		{
			List<Transform> list = new List<Transform>();
			OrderJoints(poseRoot, list);
			cachedPoseRoot = poseRoot;
			cachedPoseJoints = list.ToArray();
			transforms = new ovrAvatarTransform[list.Count];
		}
		return true;
	}

	private static bool UpdateTransforms(Transform[] joints, ovrAvatarTransform[] transforms)
	{
		bool result = false;
		for (int i = 0; i < joints.Length; i++)
		{
			Transform transform = joints[i];
			ovrAvatarTransform ovrAvatarTransform2 = CreateOvrAvatarTransform(transform.localPosition, transform.localRotation);
			if (ovrAvatarTransform2.position != transforms[i].position || ovrAvatarTransform2.orientation != transforms[i].orientation)
			{
				transforms[i] = ovrAvatarTransform2;
				result = true;
			}
		}
		return result;
	}

	private static void OrderJoints(Transform transform, List<Transform> joints)
	{
		joints.Add(transform);
		for (int i = 0; i < transform.childCount; i++)
		{
			Transform child = transform.GetChild(i);
			OrderJoints(child, joints);
		}
	}

	private void AvatarSpecificationCallback(IntPtr avatarSpecification)
	{
		Capabilities &= ~ovrAvatarCapabilities.BodyTilt;
		sdkAvatar = Oculus.Avatar.CAPI.ovrAvatar_Create(avatarSpecification, Capabilities);
		ShowLeftController(showLeftController);
		ShowRightController(showRightController);
		uint num = Oculus.Avatar.CAPI.ovrAvatar_GetReferencedAssetCount(sdkAvatar);
		for (uint num2 = 0u; num2 < num; num2++)
		{
			ulong num3 = Oculus.Avatar.CAPI.ovrAvatar_GetReferencedAsset(sdkAvatar, num2);
			if (OvrAvatarSDKManager.Instance.GetAsset(num3) == null)
			{
				OvrAvatarSDKManager.Instance.BeginLoadingAsset(num3, LevelOfDetail, AssetLoadedCallback);
				assetLoadingIds.Add(num3);
			}
		}
		if (CombineMeshes)
		{
			OvrAvatarSDKManager.Instance.RegisterCombinedMeshCallback(sdkAvatar, CombinedMeshLoadedCallback);
		}
	}

	private void Start()
	{
		try
		{
			oculusUserIDInternal = ulong.Parse(oculusUserID);
		}
		catch (Exception)
		{
			oculusUserIDInternal = 0uL;
		}
		ShowLeftController(StartWithControllers);
		ShowRightController(StartWithControllers);
		OvrAvatarSDKManager.Instance.RequestAvatarSpecification(oculusUserIDInternal, AvatarSpecificationCallback, CombineMeshes, LevelOfDetail, ForceMobileTextureFormat);
		WaitingForCombinedMesh = CombineMeshes;
		Driver.Mode = ((!UseSDKPackets) ? OvrAvatarDriver.PacketMode.Unity : OvrAvatarDriver.PacketMode.SDK);
	}

	private void Update()
	{
		if (sdkAvatar == IntPtr.Zero)
		{
			return;
		}
		if (Driver != null)
		{
			Driver.UpdateTransforms(sdkAvatar);
			foreach (float[] voiceUpdate in voiceUpdates)
			{
				Oculus.Avatar.CAPI.ovrAvatarPose_UpdateVoiceVisualization(sdkAvatar, voiceUpdate);
			}
			voiceUpdates.Clear();
			Oculus.Avatar.CAPI.ovrAvatarPose_Finalize(sdkAvatar, Time.deltaTime);
		}
		if (RecordPackets)
		{
			RecordFrame();
		}
		if (assetLoadingIds.Count == 0)
		{
			UpdateSDKAvatarUnityState();
			UpdateCustomPoses();
			if (!assetsFinishedLoading)
			{
				AssetsDoneLoading.Invoke();
				assetsFinishedLoading = true;
			}
		}
	}

	public static ovrAvatarHandInputState CreateInputState(ovrAvatarTransform transform, OvrAvatarDriver.ControllerPose pose)
	{
		ovrAvatarHandInputState result = default(ovrAvatarHandInputState);
		result.transform = transform;
		result.buttonMask = pose.buttons;
		result.touchMask = pose.touches;
		result.joystickX = pose.joystickPosition.x;
		result.joystickY = pose.joystickPosition.y;
		result.indexTrigger = pose.indexTrigger;
		result.handTrigger = pose.handTrigger;
		result.isActive = pose.isActive;
		return result;
	}

	public void ShowControllers(bool show)
	{
		ShowLeftController(show);
		ShowRightController(show);
	}

	public void ShowLeftController(bool show)
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetLeftControllerVisibility(sdkAvatar, show);
		}
		showLeftController = show;
	}

	public void ShowRightController(bool show)
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetRightControllerVisibility(sdkAvatar, show);
		}
		showRightController = show;
	}

	public void UpdateVoiceVisualization(float[] voiceSamples)
	{
		voiceUpdates.Add(voiceSamples);
	}

	private void RecordFrame()
	{
		if (UseSDKPackets)
		{
			RecordSDKFrame();
		}
		else
		{
			RecordUnityFrame();
		}
	}

	private void RecordUnityFrame()
	{
		float num = Time.deltaTime;
		OvrAvatarDriver.PoseFrame currentPose = Driver.GetCurrentPose();
		if (CurrentUnityPacket == null)
		{
			CurrentUnityPacket = new OvrAvatarPacket(currentPose);
			num = 0f;
		}
		float num2 = 0f;
		while (num2 < num)
		{
			float num3 = num - num2;
			float num4 = PacketSettings.UpdateRate - CurrentUnityPacket.Duration;
			if (num3 < num4)
			{
				CurrentUnityPacket.AddFrame(currentPose, num3);
				num2 += num3;
				continue;
			}
			OvrAvatarDriver.PoseFrame finalFrame = CurrentUnityPacket.FinalFrame;
			OvrAvatarDriver.PoseFrame b = currentPose;
			float t = num4 / num3;
			OvrAvatarDriver.PoseFrame poseFrame = OvrAvatarDriver.PoseFrame.Interpolate(finalFrame, b, t);
			CurrentUnityPacket.AddFrame(poseFrame, num4);
			num2 += num4;
			if (PacketRecorded != null)
			{
				PacketRecorded(this, new PacketEventArgs(CurrentUnityPacket));
			}
			CurrentUnityPacket = new OvrAvatarPacket(poseFrame);
		}
	}

	private void RecordSDKFrame()
	{
		if (sdkAvatar == IntPtr.Zero)
		{
			return;
		}
		if (!PacketSettings.RecordingFrames)
		{
			Oculus.Avatar.CAPI.ovrAvatarPacket_BeginRecording(sdkAvatar);
			PacketSettings.AccumulatedTime = 0f;
			PacketSettings.RecordingFrames = true;
		}
		PacketSettings.AccumulatedTime += Time.deltaTime;
		if (PacketSettings.AccumulatedTime >= PacketSettings.UpdateRate)
		{
			PacketSettings.AccumulatedTime = 0f;
			IntPtr intPtr = Oculus.Avatar.CAPI.ovrAvatarPacket_EndRecording(sdkAvatar);
			Oculus.Avatar.CAPI.ovrAvatarPacket_BeginRecording(sdkAvatar);
			if (PacketRecorded != null)
			{
				PacketRecorded(this, new PacketEventArgs(new OvrAvatarPacket
				{
					ovrNativePacket = intPtr
				}));
			}
			Oculus.Avatar.CAPI.ovrAvatarPacket_Free(intPtr);
		}
	}

	private void AddRenderParts(OvrAvatarComponent ovrComponent, ovrAvatarComponent component, Transform parent)
	{
		for (uint num = 0u; num < component.renderPartCount; num++)
		{
			GameObject gameObject = new GameObject();
			gameObject.name = GetRenderPartName(component, num);
			gameObject.transform.SetParent(parent);
			IntPtr renderPart = GetRenderPart(component, num);
			ovrAvatarRenderPartType ovrAvatarRenderPartType2 = Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetType(renderPart);
			OvrAvatarRenderComponent item;
			switch (ovrAvatarRenderPartType2)
			{
			case ovrAvatarRenderPartType.SkinnedMeshRender:
				item = AddSkinnedMeshRenderComponent(gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetSkinnedMeshRender(renderPart));
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS:
				item = AddSkinnedMeshRenderPBSComponent(gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetSkinnedMeshRenderPBS(renderPart));
				break;
			case ovrAvatarRenderPartType.ProjectorRender:
				item = AddProjectorRenderComponent(gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetProjectorRender(renderPart));
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2:
			{
				OvrAvatarMaterialManager materialManager = null;
				if (ovrComponent.name == "body")
				{
					materialManager = DefaultBodyMaterialManager;
				}
				else if (ovrComponent.name.Contains("hand"))
				{
					materialManager = DefaultHandMaterialManager;
				}
				item = AddSkinnedMeshRenderPBSV2Component(renderPart, gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2(renderPart), materialManager);
				break;
			}
			default:
				throw new NotImplementedException($"Unsupported render part type: {ovrAvatarRenderPartType2.ToString()}");
			}
			ovrComponent.RenderParts.Add(item);
		}
	}

	public void RefreshBodyParts()
	{
		if (!trackedComponents.TryGetValue("body", out var value) || !(Body != null))
		{
			return;
		}
		foreach (OvrAvatarRenderComponent renderPart in value.RenderParts)
		{
			UnityEngine.Object.Destroy(renderPart.gameObject);
		}
		value.RenderParts.Clear();
		ovrAvatarBodyComponent? ovrAvatarBodyComponent2 = Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(sdkAvatar);
		if (ovrAvatarBodyComponent2.HasValue)
		{
			ovrAvatarComponent component = (ovrAvatarComponent)Marshal.PtrToStructure(ovrAvatarBodyComponent2.Value.renderComponent, typeof(ovrAvatarComponent));
			AddRenderParts(value, component, Body.gameObject.transform);
			return;
		}
		throw new Exception("Destroyed the body component, but didn't find a new one in the SDK");
	}

	public ovrAvatarBodyComponent? GetBodyComponent()
	{
		return Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(sdkAvatar);
	}

	public Transform GetHandTransform(HandType hand, HandJoint joint)
	{
		if (hand >= HandType.Max || joint >= HandJoint.Max)
		{
			return null;
		}
		OvrAvatarHand ovrAvatarHand = ((hand != HandType.Left) ? HandRight : HandLeft);
		if (ovrAvatarHand != null)
		{
			OvrAvatarComponent component = ovrAvatarHand.GetComponent<OvrAvatarComponent>();
			if (component != null && component.RenderParts.Count > 0)
			{
				OvrAvatarRenderComponent ovrAvatarRenderComponent = component.RenderParts[0];
				return ovrAvatarRenderComponent.transform.Find(HandJoints[(int)hand, (int)joint]);
			}
		}
		return null;
	}

	public void GetPointingDirection(HandType hand, ref Vector3 forward, ref Vector3 up)
	{
		Transform handTransform = GetHandTransform(hand, HandJoint.HandBase);
		if (handTransform != null)
		{
			forward = handTransform.forward;
			up = handTransform.up;
		}
	}

	public Transform GetMouthTransform()
	{
		if (trackedComponents.TryGetValue("voice", out var value) && value.RenderParts.Count > 0)
		{
			return value.RenderParts[0].transform;
		}
		return null;
	}

	private void UpdateVoiceBehavior()
	{
		if (EnableMouthVertexAnimation && trackedComponents.TryGetValue("body", out var value))
		{
			VoiceAmplitude = Mathf.Clamp(VoiceAmplitude, 0f, 1f);
			if (value.RenderParts.Count > 0)
			{
				Material sharedMaterial = value.RenderParts[0].mesh.sharedMaterial;
				Transform transform = value.RenderParts[0].mesh.transform.Find(NECK_JONT);
				Vector3 vector = transform.TransformPoint(Vector3.up) - transform.position;
				sharedMaterial.SetFloat(MOUTH_SCALE_PROPERTY, vector.magnitude);
				sharedMaterial.SetFloat(VOICE_PROPERTY, Mathf.Min(vector.magnitude * MOUTH_MAX_GLOBAL, vector.magnitude * VoiceAmplitude * MOUTH_SCALE_GLOBAL));
				sharedMaterial.SetVector(MOUTH_POSITION_PROPERTY, transform.TransformPoint(MOUTH_POSITION_OFFSET));
				sharedMaterial.SetVector(MOUTH_DIRECTION_PROPERTY, transform.up);
			}
		}
	}
}
public class OvrAvatarAsset
{
	public ulong assetID;
}
public class OvrAvatarAssetMesh : OvrAvatarAsset
{
	public Mesh mesh;

	private ovrAvatarSkinnedMeshPose skinnedBindPose;

	public string[] jointNames;

	public OvrAvatarAssetMesh(ulong _assetId, IntPtr asset, ovrAvatarAssetType meshType)
	{
		assetID = _assetId;
		mesh = new Mesh();
		mesh.name = "Procedural Geometry for asset " + _assetId;
		switch (meshType)
		{
		case ovrAvatarAssetType.Mesh:
		{
			ovrAvatarMeshAssetData ovrAvatarMeshAssetData2 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset);
			long num9 = ovrAvatarMeshAssetData2.vertexCount;
			Vector3[] array9 = new Vector3[num9];
			Vector3[] array10 = new Vector3[num9];
			Vector4[] array11 = new Vector4[num9];
			Vector2[] array12 = new Vector2[num9];
			Color[] array13 = new Color[num9];
			BoneWeight[] array14 = new BoneWeight[num9];
			long num10 = Marshal.SizeOf(typeof(ovrAvatarMeshVertex));
			long num11 = ovrAvatarMeshAssetData2.vertexBuffer.ToInt64();
			for (long num12 = 0L; num12 < num9; num12++)
			{
				long num13 = num10 * num12;
				ovrAvatarMeshVertex ovrAvatarMeshVertex2 = (ovrAvatarMeshVertex)Marshal.PtrToStructure(new IntPtr(num11 + num13), typeof(ovrAvatarMeshVertex));
				ref Vector3 reference6 = ref array9[num12];
				reference6 = new Vector3(ovrAvatarMeshVertex2.x, ovrAvatarMeshVertex2.y, 0f - ovrAvatarMeshVertex2.z);
				ref Vector3 reference7 = ref array10[num12];
				reference7 = new Vector3(ovrAvatarMeshVertex2.nx, ovrAvatarMeshVertex2.ny, 0f - ovrAvatarMeshVertex2.nz);
				ref Vector4 reference8 = ref array11[num12];
				reference8 = new Vector4(ovrAvatarMeshVertex2.tx, ovrAvatarMeshVertex2.ty, 0f - ovrAvatarMeshVertex2.tz, ovrAvatarMeshVertex2.tw);
				ref Vector2 reference9 = ref array12[num12];
				reference9 = new Vector2(ovrAvatarMeshVertex2.u, ovrAvatarMeshVertex2.v);
				ref Color reference10 = ref array13[num12];
				reference10 = new Color(0f, 0f, 0f, 1f);
				array14[num12].boneIndex0 = ovrAvatarMeshVertex2.blendIndices[0];
				array14[num12].boneIndex1 = ovrAvatarMeshVertex2.blendIndices[1];
				array14[num12].boneIndex2 = ovrAvatarMeshVertex2.blendIndices[2];
				array14[num12].boneIndex3 = ovrAvatarMeshVertex2.blendIndices[3];
				array14[num12].weight0 = ovrAvatarMeshVertex2.blendWeights[0];
				array14[num12].weight1 = ovrAvatarMeshVertex2.blendWeights[1];
				array14[num12].weight2 = ovrAvatarMeshVertex2.blendWeights[2];
				array14[num12].weight3 = ovrAvatarMeshVertex2.blendWeights[3];
			}
			mesh.vertices = array9;
			mesh.normals = array10;
			mesh.uv = array12;
			mesh.tangents = array11;
			mesh.boneWeights = array14;
			mesh.colors = array13;
			skinnedBindPose = ovrAvatarMeshAssetData2.skinnedBindPose;
			ulong num14 = ovrAvatarMeshAssetData2.indexCount;
			short[] array15 = new short[num14];
			IntPtr indexBuffer2 = ovrAvatarMeshAssetData2.indexBuffer;
			Marshal.Copy(indexBuffer2, array15, 0, (int)num14);
			int[] array16 = new int[num14];
			for (ulong num15 = 0uL; num15 < num14; num15 += 3)
			{
				array16[num15 + 2] = array15[num15];
				array16[num15 + 1] = array15[num15 + 1];
				array16[num15] = array15[num15 + 2];
			}
			mesh.triangles = array16;
			uint jointCount2 = skinnedBindPose.jointCount;
			jointNames = new string[jointCount2];
			for (uint num16 = 0u; num16 < jointCount2; num16++)
			{
				jointNames[num16] = Marshal.PtrToStringAnsi(skinnedBindPose.jointNames[num16]);
			}
			break;
		}
		case ovrAvatarAssetType.CombinedMesh:
		{
			ovrAvatarMeshAssetDataV2 ovrAvatarMeshAssetDataV3 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset);
			long num = ovrAvatarMeshAssetDataV3.vertexCount;
			Vector3[] array = new Vector3[num];
			Vector3[] array2 = new Vector3[num];
			Vector4[] array3 = new Vector4[num];
			Vector2[] array4 = new Vector2[num];
			Color[] array5 = new Color[num];
			BoneWeight[] array6 = new BoneWeight[num];
			long num2 = Marshal.SizeOf(typeof(ovrAvatarMeshVertexV2));
			long num3 = ovrAvatarMeshAssetDataV3.vertexBuffer.ToInt64();
			for (long num4 = 0L; num4 < num; num4++)
			{
				long num5 = num2 * num4;
				ovrAvatarMeshVertexV2 ovrAvatarMeshVertexV3 = (ovrAvatarMeshVertexV2)Marshal.PtrToStructure(new IntPtr(num3 + num5), typeof(ovrAvatarMeshVertexV2));
				ref Vector3 reference = ref array[num4];
				reference = new Vector3(ovrAvatarMeshVertexV3.x, ovrAvatarMeshVertexV3.y, 0f - ovrAvatarMeshVertexV3.z);
				ref Vector3 reference2 = ref array2[num4];
				reference2 = new Vector3(ovrAvatarMeshVertexV3.nx, ovrAvatarMeshVertexV3.ny, 0f - ovrAvatarMeshVertexV3.nz);
				ref Vector4 reference3 = ref array3[num4];
				reference3 = new Vector4(ovrAvatarMeshVertexV3.tx, ovrAvatarMeshVertexV3.ty, 0f - ovrAvatarMeshVertexV3.tz, ovrAvatarMeshVertexV3.tw);
				ref Vector2 reference4 = ref array4[num4];
				reference4 = new Vector2(ovrAvatarMeshVertexV3.u, ovrAvatarMeshVertexV3.v);
				ref Color reference5 = ref array5[num4];
				reference5 = new Color(ovrAvatarMeshVertexV3.r, ovrAvatarMeshVertexV3.g, ovrAvatarMeshVertexV3.b, ovrAvatarMeshVertexV3.a);
				array6[num4].boneIndex0 = ovrAvatarMeshVertexV3.blendIndices[0];
				array6[num4].boneIndex1 = ovrAvatarMeshVertexV3.blendIndices[1];
				array6[num4].boneIndex2 = ovrAvatarMeshVertexV3.blendIndices[2];
				array6[num4].boneIndex3 = ovrAvatarMeshVertexV3.blendIndices[3];
				array6[num4].weight0 = ovrAvatarMeshVertexV3.blendWeights[0];
				array6[num4].weight1 = ovrAvatarMeshVertexV3.blendWeights[1];
				array6[num4].weight2 = ovrAvatarMeshVertexV3.blendWeights[2];
				array6[num4].weight3 = ovrAvatarMeshVertexV3.blendWeights[3];
			}
			mesh.vertices = array;
			mesh.normals = array2;
			mesh.uv = array4;
			mesh.tangents = array3;
			mesh.boneWeights = array6;
			mesh.colors = array5;
			skinnedBindPose = ovrAvatarMeshAssetDataV3.skinnedBindPose;
			ulong num6 = ovrAvatarMeshAssetDataV3.indexCount;
			short[] array7 = new short[num6];
			IntPtr indexBuffer = ovrAvatarMeshAssetDataV3.indexBuffer;
			Marshal.Copy(indexBuffer, array7, 0, (int)num6);
			int[] array8 = new int[num6];
			for (ulong num7 = 0uL; num7 < num6; num7 += 3)
			{
				array8[num7 + 2] = array7[num7];
				array8[num7 + 1] = array7[num7 + 1];
				array8[num7] = array7[num7 + 2];
			}
			mesh.triangles = array8;
			uint jointCount = skinnedBindPose.jointCount;
			jointNames = new string[jointCount];
			for (uint num8 = 0u; num8 < jointCount; num8++)
			{
				jointNames[num8] = Marshal.PtrToStringAnsi(skinnedBindPose.jointNames[num8]);
			}
			break;
		}
		default:
			throw new Exception("Bad Mesh Asset Type");
		}
	}

	public SkinnedMeshRenderer CreateSkinnedMeshRendererOnObject(GameObject target)
	{
		SkinnedMeshRenderer skinnedMeshRenderer = target.AddComponent<SkinnedMeshRenderer>();
		skinnedMeshRenderer.sharedMesh = mesh;
		mesh.name = "AvatarMesh_" + assetID;
		uint jointCount = skinnedBindPose.jointCount;
		GameObject[] array = new GameObject[jointCount];
		Transform[] array2 = new Transform[jointCount];
		Matrix4x4[] array3 = new Matrix4x4[jointCount];
		for (uint num = 0u; num < jointCount; num++)
		{
			array[num] = new GameObject();
			array2[num] = array[num].transform;
			array[num].name = jointNames[num];
			int num2 = skinnedBindPose.jointParents[num];
			if (num2 == -1)
			{
				array[num].transform.parent = skinnedMeshRenderer.transform;
				skinnedMeshRenderer.rootBone = array[num].transform;
			}
			else
			{
				array[num].transform.parent = array[num2].transform;
			}
			Vector3 position = skinnedBindPose.jointTransform[num].position;
			position.z = 0f - position.z;
			array[num].transform.localPosition = position;
			Quaternion orientation = skinnedBindPose.jointTransform[num].orientation;
			orientation.x = 0f - orientation.x;
			orientation.y = 0f - orientation.y;
			array[num].transform.localRotation = orientation;
			array[num].transform.localScale = skinnedBindPose.jointTransform[num].scale;
			ref Matrix4x4 reference = ref array3[num];
			reference = array[num].transform.worldToLocalMatrix * skinnedMeshRenderer.transform.localToWorldMatrix;
		}
		skinnedMeshRenderer.bones = array2;
		mesh.bindposes = array3;
		return skinnedMeshRenderer;
	}
}
public class OvrAvatarAssetTexture : OvrAvatarAsset
{
	public Texture2D texture;

	private const int ASTCHeaderSize = 16;

	public OvrAvatarAssetTexture(ulong _assetId, IntPtr asset)
	{
		assetID = _assetId;
		ovrAvatarTextureAssetData ovrAvatarTextureAssetData2 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetTextureData(asset);
		IntPtr data = ovrAvatarTextureAssetData2.textureData;
		int num = (int)ovrAvatarTextureAssetData2.textureDataSize;
		TextureFormat format;
		switch (ovrAvatarTextureAssetData2.format)
		{
		case ovrAvatarTextureFormat.RGB24:
			format = TextureFormat.RGB24;
			break;
		case ovrAvatarTextureFormat.DXT1:
			format = TextureFormat.DXT1;
			break;
		case ovrAvatarTextureFormat.DXT5:
			format = TextureFormat.DXT5;
			break;
		case ovrAvatarTextureFormat.ASTC_RGB_6x6:
			format = TextureFormat.ASTC_RGB_6x6;
			data = new IntPtr(data.ToInt64() + 16);
			num -= 16;
			break;
		case ovrAvatarTextureFormat.ASTC_RGB_6x6_MIPMAPS:
			format = TextureFormat.ASTC_RGB_6x6;
			break;
		default:
			throw new NotImplementedException($"Unsupported texture format {ovrAvatarTextureAssetData2.format.ToString()}");
		}
		texture = new Texture2D((int)ovrAvatarTextureAssetData2.sizeX, (int)ovrAvatarTextureAssetData2.sizeY, format, ovrAvatarTextureAssetData2.mipCount > 1, (QualitySettings.activeColorSpace != 0) ? true : false);
		texture.LoadRawTextureData(data, num);
		texture.Apply(updateMipmaps: true, makeNoLongerReadable: false);
	}
}
public class OvrAvatarBase : MonoBehaviour
{
}
public class OvrAvatarBody : MonoBehaviour
{
	public virtual void UpdatePose(float voiceAmplitude)
	{
	}
}
public class OvrAvatarComponent : MonoBehaviour
{
	public static readonly string[] LayerKeywords = new string[9] { "LAYERS_0", "LAYERS_1", "LAYERS_2", "LAYERS_3", "LAYERS_4", "LAYERS_5", "LAYERS_6", "LAYERS_7", "LAYERS_8" };

	public static readonly string[] LayerSampleModeParameters = new string[8] { "_LayerSampleMode0", "_LayerSampleMode1", "_LayerSampleMode2", "_LayerSampleMode3", "_LayerSampleMode4", "_LayerSampleMode5", "_LayerSampleMode6", "_LayerSampleMode7" };

	public static readonly string[] LayerBlendModeParameters = new string[8] { "_LayerBlendMode0", "_LayerBlendMode1", "_LayerBlendMode2", "_LayerBlendMode3", "_LayerBlendMode4", "_LayerBlendMode5", "_LayerBlendMode6", "_LayerBlendMode7" };

	public static readonly string[] LayerMaskTypeParameters = new string[8] { "_LayerMaskType0", "_LayerMaskType1", "_LayerMaskType2", "_LayerMaskType3", "_LayerMaskType4", "_LayerMaskType5", "_LayerMaskType6", "_LayerMaskType7" };

	public static readonly string[] LayerColorParameters = new string[8] { "_LayerColor0", "_LayerColor1", "_LayerColor2", "_LayerColor3", "_LayerColor4", "_LayerColor5", "_LayerColor6", "_LayerColor7" };

	public static readonly string[] LayerSurfaceParameters = new string[8] { "_LayerSurface0", "_LayerSurface1", "_LayerSurface2", "_LayerSurface3", "_LayerSurface4", "_LayerSurface5", "_LayerSurface6", "_LayerSurface7" };

	public static readonly string[] LayerSampleParametersParameters = new string[8] { "_LayerSampleParameters0", "_LayerSampleParameters1", "_LayerSampleParameters2", "_LayerSampleParameters3", "_LayerSampleParameters4", "_LayerSampleParameters5", "_LayerSampleParameters6", "_LayerSampleParameters7" };

	public static readonly string[] LayerMaskParametersParameters = new string[8] { "_LayerMaskParameters0", "_LayerMaskParameters1", "_LayerMaskParameters2", "_LayerMaskParameters3", "_LayerMaskParameters4", "_LayerMaskParameters5", "_LayerMaskParameters6", "_LayerMaskParameters7" };

	public static readonly string[] LayerMaskAxisParameters = new string[8] { "_LayerMaskAxis0", "_LayerMaskAxis1", "_LayerMaskAxis2", "_LayerMaskAxis3", "_LayerMaskAxis4", "_LayerMaskAxis5", "_LayerMaskAxis6", "_LayerMaskAxis7" };

	private Dictionary<Material, ovrAvatarMaterialState> materialStates = new Dictionary<Material, ovrAvatarMaterialState>();

	public List<OvrAvatarRenderComponent> RenderParts = new List<OvrAvatarRenderComponent>();

	private bool DrawSkeleton;

	private bool FirstMaterialUpdate = true;

	public ulong ClothingAlphaTexture;

	public Vector4 ClothingAlphaOffset;

	public void UpdateAvatar(ovrAvatarComponent component, OvrAvatar avatar)
	{
		OvrAvatar.ConvertTransform(component.transform, base.transform);
		for (uint num = 0u; num < component.renderPartCount && RenderParts.Count > num; num++)
		{
			OvrAvatarRenderComponent ovrAvatarRenderComponent = RenderParts[(int)num];
			IntPtr renderPart = OvrAvatar.GetRenderPart(component, num);
			switch (Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetType(renderPart))
			{
			case ovrAvatarRenderPartType.SkinnedMeshRender:
				((OvrAvatarSkinnedMeshRenderComponent)ovrAvatarRenderComponent).UpdateSkinnedMeshRender(this, avatar, renderPart);
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS:
				((OvrAvatarSkinnedMeshRenderPBSComponent)ovrAvatarRenderComponent).UpdateSkinnedMeshRenderPBS(avatar, renderPart, ovrAvatarRenderComponent.mesh.sharedMaterial);
				break;
			case ovrAvatarRenderPartType.ProjectorRender:
				((OvrAvatarProjectorRenderComponent)ovrAvatarRenderComponent).UpdateProjectorRender(this, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetProjectorRender(renderPart));
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2:
				((OvrAvatarSkinnedMeshPBSV2RenderComponent)ovrAvatarRenderComponent).UpdateSkinnedMeshRender(this, avatar, renderPart);
				break;
			}
		}
	}

	protected void UpdateActive(OvrAvatar avatar, ovrAvatarVisibilityFlags mask)
	{
		bool flag = avatar.ShowFirstPerson && (mask & ovrAvatarVisibilityFlags.FirstPerson) != 0;
		flag |= avatar.ShowThirdPerson && (mask & ovrAvatarVisibilityFlags.ThirdPerson) != 0;
		base.gameObject.SetActive(flag);
	}

	public void UpdateAvatarMaterial(Material mat, ovrAvatarMaterialState matState)
	{
		mat.SetColor("_BaseColor", matState.baseColor);
		mat.SetInt("_BaseMaskType", (int)matState.baseMaskType);
		mat.SetVector("_BaseMaskParameters", matState.baseMaskParameters);
		mat.SetVector("_BaseMaskAxis", matState.baseMaskAxis);
		if (matState.alphaMaskTextureID != 0)
		{
			mat.SetTexture("_AlphaMask", GetLoadedTexture(matState.alphaMaskTextureID));
			mat.SetTextureScale("_AlphaMask", new Vector2(matState.alphaMaskScaleOffset.x, matState.alphaMaskScaleOffset.y));
			mat.SetTextureOffset("_AlphaMask", new Vector2(matState.alphaMaskScaleOffset.z, matState.alphaMaskScaleOffset.w));
		}
		if (ClothingAlphaTexture != 0)
		{
			mat.EnableKeyword("VERTALPHA_ON");
			mat.SetTexture("_AlphaMask2", GetLoadedTexture(ClothingAlphaTexture));
			mat.SetTextureScale("_AlphaMask2", new Vector2(ClothingAlphaOffset.x, ClothingAlphaOffset.y));
			mat.SetTextureOffset("_AlphaMask2", new Vector2(ClothingAlphaOffset.z, ClothingAlphaOffset.w));
		}
		if (matState.normalMapTextureID != 0)
		{
			mat.EnableKeyword("NORMAL_MAP_ON");
			mat.SetTexture("_NormalMap", GetLoadedTexture(matState.normalMapTextureID));
			mat.SetTextureScale("_NormalMap", new Vector2(matState.normalMapScaleOffset.x, matState.normalMapScaleOffset.y));
			mat.SetTextureOffset("_NormalMap", new Vector2(matState.normalMapScaleOffset.z, matState.normalMapScaleOffset.w));
		}
		if (matState.parallaxMapTextureID != 0)
		{
			mat.SetTexture("_ParallaxMap", GetLoadedTexture(matState.parallaxMapTextureID));
			mat.SetTextureScale("_ParallaxMap", new Vector2(matState.parallaxMapScaleOffset.x, matState.parallaxMapScaleOffset.y));
			mat.SetTextureOffset("_ParallaxMap", new Vector2(matState.parallaxMapScaleOffset.z, matState.parallaxMapScaleOffset.w));
		}
		if (matState.roughnessMapTextureID != 0)
		{
			mat.EnableKeyword("ROUGHNESS_ON");
			mat.SetTexture("_RoughnessMap", GetLoadedTexture(matState.roughnessMapTextureID));
			mat.SetTextureScale("_RoughnessMap", new Vector2(matState.roughnessMapScaleOffset.x, matState.roughnessMapScaleOffset.y));
			mat.SetTextureOffset("_RoughnessMap", new Vector2(matState.roughnessMapScaleOffset.z, matState.roughnessMapScaleOffset.w));
		}
		mat.EnableKeyword(LayerKeywords[matState.layerCount]);
		for (ulong num = 0uL; num < matState.layerCount; num++)
		{
			ovrAvatarMaterialLayerState ovrAvatarMaterialLayerState2 = matState.layers[num];
			mat.SetInt(LayerSampleModeParameters[num], (int)ovrAvatarMaterialLayerState2.sampleMode);
			mat.SetInt(LayerBlendModeParameters[num], (int)ovrAvatarMaterialLayerState2.blendMode);
			mat.SetInt(LayerMaskTypeParameters[num], (int)ovrAvatarMaterialLayerState2.maskType);
			mat.SetColor(LayerColorParameters[num], ovrAvatarMaterialLayerState2.layerColor);
			if (ovrAvatarMaterialLayerState2.sampleMode != 0)
			{
				string text = LayerSurfaceParameters[num];
				mat.SetTexture(text, GetLoadedTexture(ovrAvatarMaterialLayerState2.sampleTexture));
				mat.SetTextureScale(text, new Vector2(ovrAvatarMaterialLayerState2.sampleScaleOffset.x, ovrAvatarMaterialLayerState2.sampleScaleOffset.y));
				mat.SetTextureOffset(text, new Vector2(ovrAvatarMaterialLayerState2.sampleScaleOffset.z, ovrAvatarMaterialLayerState2.sampleScaleOffset.w));
			}
			if (ovrAvatarMaterialLayerState2.sampleMode == ovrAvatarMaterialLayerSampleMode.Parallax)
			{
				mat.EnableKeyword("PARALLAX_ON");
			}
			mat.SetColor(LayerSampleParametersParameters[num], ovrAvatarMaterialLayerState2.sampleParameters);
			mat.SetColor(LayerMaskParametersParameters[num], ovrAvatarMaterialLayerState2.maskParameters);
			mat.SetColor(LayerMaskAxisParameters[num], ovrAvatarMaterialLayerState2.maskAxis);
		}
		materialStates[mat] = matState;
	}

	public static Texture2D GetLoadedTexture(ulong assetId)
	{
		return ((OvrAvatarAssetTexture)OvrAvatarSDKManager.Instance.GetAsset(assetId))?.texture;
	}
}
public abstract class OvrAvatarDriver : MonoBehaviour
{
	public enum PacketMode
	{
		SDK,
		Unity
	}

	public struct ControllerPose
	{
		public ovrAvatarButton buttons;

		public ovrAvatarTouch touches;

		public Vector2 joystickPosition;

		public float indexTrigger;

		public float handTrigger;

		public bool isActive;

		public static ControllerPose Interpolate(ControllerPose a, ControllerPose b, float t)
		{
			ControllerPose result = default(ControllerPose);
			result.buttons = ((!(t < 0.5f)) ? b.buttons : a.buttons);
			result.touches = ((!(t < 0.5f)) ? b.touches : a.touches);
			result.joystickPosition = Vector2.Lerp(a.joystickPosition, b.joystickPosition, t);
			result.indexTrigger = Mathf.Lerp(a.indexTrigger, b.indexTrigger, t);
			result.handTrigger = Mathf.Lerp(a.handTrigger, b.handTrigger, t);
			result.isActive = ((!(t < 0.5f)) ? b.isActive : a.isActive);
			return result;
		}
	}

	public struct PoseFrame
	{
		public Vector3 headPosition;

		public Quaternion headRotation;

		public Vector3 handLeftPosition;

		public Quaternion handLeftRotation;

		public Vector3 handRightPosition;

		public Quaternion handRightRotation;

		public float voiceAmplitude;

		public ControllerPose controllerLeftPose;

		public ControllerPose controllerRightPose;

		public static PoseFrame Interpolate(PoseFrame a, PoseFrame b, float t)
		{
			PoseFrame result = default(PoseFrame);
			result.headPosition = Vector3.Lerp(a.headPosition, b.headPosition, t);
			result.headRotation = Quaternion.Slerp(a.headRotation, b.headRotation, t);
			result.handLeftPosition = Vector3.Lerp(a.handLeftPosition, b.handLeftPosition, t);
			result.handLeftRotation = Quaternion.Slerp(a.handLeftRotation, b.handLeftRotation, t);
			result.handRightPosition = Vector3.Lerp(a.handRightPosition, b.handRightPosition, t);
			result.handRightRotation = Quaternion.Slerp(a.handRightRotation, b.handRightRotation, t);
			result.voiceAmplitude = Mathf.Lerp(a.voiceAmplitude, b.voiceAmplitude, t);
			result.controllerLeftPose = ControllerPose.Interpolate(a.controllerLeftPose, b.controllerLeftPose, t);
			result.controllerRightPose = ControllerPose.Interpolate(a.controllerRightPose, b.controllerRightPose, t);
			return result;
		}
	}

	public PacketMode Mode;

	protected PoseFrame CurrentPose;

	public PoseFrame GetCurrentPose()
	{
		return CurrentPose;
	}

	public abstract void UpdateTransforms(IntPtr sdkAvatar);

	protected void UpdateTransformsFromPose(IntPtr sdkAvatar)
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			ovrAvatarTransform headPose = OvrAvatar.CreateOvrAvatarTransform(CurrentPose.headPosition, CurrentPose.headRotation);
			ovrAvatarHandInputState inputStateLeft = OvrAvatar.CreateInputState(OvrAvatar.CreateOvrAvatarTransform(CurrentPose.handLeftPosition, CurrentPose.handLeftRotation), CurrentPose.controllerLeftPose);
			ovrAvatarHandInputState inputStateRight = OvrAvatar.CreateInputState(OvrAvatar.CreateOvrAvatarTransform(CurrentPose.handRightPosition, CurrentPose.handRightRotation), CurrentPose.controllerRightPose);
			Oculus.Avatar.CAPI.ovrAvatarPose_UpdateBody(sdkAvatar, headPose);
			if (GetIsTrackedRemote())
			{
				Oculus.Avatar.CAPI.ovrAvatarPose_UpdateSDK3DofHands(sdkAvatar, inputStateLeft, inputStateRight, GetRemoteControllerType());
			}
			else
			{
				Oculus.Avatar.CAPI.ovrAvatarPose_UpdateHands(sdkAvatar, inputStateLeft, inputStateRight);
			}
		}
	}

	public static bool GetIsTrackedRemote()
	{
		return OVRInput.IsControllerConnected(OVRInput.Controller.RTrackedRemote) || OVRInput.IsControllerConnected(OVRInput.Controller.LTrackedRemote);
	}

	private ovrAvatarControllerType GetRemoteControllerType()
	{
		return (!(OVRPlugin.productName == "Oculus Go")) ? ovrAvatarControllerType.Malibu : ovrAvatarControllerType.Go;
	}
}
public class OvrAvatarHand : MonoBehaviour
{
}
public class OvrAvatarLocalDriver : OvrAvatarDriver
{
	private float voiceAmplitude;

	private ControllerPose GetMalibuControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = (OVRInput.Get(OVRInput.Touch.PrimaryTouchpad) ? ovrAvatarTouch.One : ((ovrAvatarTouch)0));
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, controller);
		result.indexTrigger = 0f;
		result.handTrigger = 0f;
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private ControllerPose GetControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.One, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		if (OVRInput.Get(OVRInput.Button.Two, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Two;
		}
		if (OVRInput.Get(OVRInput.Button.Start, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Three;
		}
		if (OVRInput.Get(OVRInput.Button.PrimaryThumbstick, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Joystick;
		}
		ovrAvatarTouch ovrAvatarTouch2 = (ovrAvatarTouch)0;
		if (OVRInput.Get(OVRInput.Touch.One, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.One;
		}
		if (OVRInput.Get(OVRInput.Touch.Two, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Two;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbstick, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Joystick;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbRest, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbRest;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Index;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Pointing;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbUp;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = ovrAvatarTouch2;
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, controller);
		result.indexTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, controller);
		result.handTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, controller);
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private void CalculateCurrentPose()
	{
		Vector3 localPosition = InputTracking.GetLocalPosition(XRNode.CenterEye);
		if (OvrAvatarDriver.GetIsTrackedRemote())
		{
			CurrentPose = new PoseFrame
			{
				voiceAmplitude = voiceAmplitude,
				headPosition = localPosition,
				headRotation = InputTracking.GetLocalRotation(XRNode.CenterEye),
				handLeftPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.LTrackedRemote),
				handLeftRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.LTrackedRemote),
				handRightPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTrackedRemote),
				handRightRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTrackedRemote),
				controllerLeftPose = GetMalibuControllerPose(OVRInput.Controller.LTrackedRemote),
				controllerRightPose = GetMalibuControllerPose(OVRInput.Controller.RTrackedRemote)
			};
		}
		else
		{
			CurrentPose = new PoseFrame
			{
				voiceAmplitude = voiceAmplitude,
				headPosition = localPosition,
				headRotation = InputTracking.GetLocalRotation(XRNode.CenterEye),
				handLeftPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.LTouch),
				handLeftRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.LTouch),
				handRightPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTouch),
				handRightRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTouch),
				controllerLeftPose = GetControllerPose(OVRInput.Controller.LTouch),
				controllerRightPose = GetControllerPose(OVRInput.Controller.RTouch)
			};
		}
	}

	public override void UpdateTransforms(IntPtr sdkAvatar)
	{
		CalculateCurrentPose();
		UpdateTransformsFromPose(sdkAvatar);
	}
}
namespace Oculus.Avatar
{
	public static class AvatarLogger
	{
		public const string LogAvatar = "[Avatars] - ";

		public const string Tab = "    ";

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_BASIC")]
		public static void Log(string logMsg)
		{
			Debug.Log("[Avatars] - " + logMsg);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_BASIC")]
		public static void Log(string logMsg, UnityEngine.Object context)
		{
			Debug.Log("[Avatars] - " + logMsg, context);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_WARNING")]
		public static void LogWarning(string logMsg)
		{
			Debug.LogWarning("[Avatars] - " + logMsg);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_ERROR")]
		public static void LogError(string logMsg)
		{
			Debug.LogError("[Avatars] - " + logMsg);
		}
	}
}
public class OvrAvatarMaterialManager : MonoBehaviour
{
	public enum TextureType
	{
		DiffuseTextures,
		NormalMaps,
		RoughnessMaps,
		Count
	}

	[Serializable]
	public struct AvatarComponentMaterialProperties
	{
		public ovrAvatarBodyPartType TypeIndex;

		public Color Color;

		public Texture2D[] Textures;

		[Range(0f, 1f)]
		public float DiffuseIntensity;

		[Range(0f, 10f)]
		public float RimIntensity;

		[Range(0f, 1f)]
		public float BacklightIntensity;

		[Range(0f, 1f)]
		public float ReflectionIntensity;
	}

	[Serializable]
	public struct AvatarTextureArrayProperties
	{
		public Texture2D[] Textures;

		public Texture2DArray TextureArray;
	}

	[Serializable]
	public struct AvatarMaterialPropertyBlock
	{
		public Vector4[] Colors;

		public float[] DiffuseIntensities;

		public float[] RimIntensities;

		public float[] BacklightIntensities;

		public float[] ReflectionIntensities;
	}

	[Serializable]
	public class AvatarMaterialConfig
	{
		public AvatarComponentMaterialProperties[] ComponentMaterialProperties;

		public AvatarMaterialPropertyBlock MaterialPropertyBlock;
	}

	public Texture2D[] DiffuseFallbacks;

	public Texture2D[] NormalFallbacks;

	private Renderer TargetRenderer;

	private AvatarTextureArrayProperties[] TextureArrays;

	private OvrAvatarTextureCopyManager TextureCopyManager;

	private readonly string[] TextureTypeToShaderProperties = new string[3] { "_MainTex", "_NormalMap", "_RoughnessMap" };

	public Color[] BodyColorTints;

	public List<ReflectionProbeBlendInfo> ReflectionProbes = new List<ReflectionProbeBlendInfo>();

	public AvatarMaterialConfig LocalAvatarConfig;

	public AvatarMaterialConfig DefaultAvatarConfig;

	private AvatarMaterialPropertyBlock LocalAvatarMaterialPropertyBlock;

	public static int RENDER_QUEUE = 3640;

	public static string AVATAR_SHADER_COMBINED = "OvrAvatar/Avatar_Mobile_CombinedMesh";

	public static string AVATAR_SHADER_LOADER = "OvrAvatar/Avatar_Mobile_Loader";

	public static string AVATAR_SHADER_MAINTEX = "_MainTex";

	public static string AVATAR_SHADER_NORMALMAP = "_NormalMap";

	public static string AVATAR_SHADER_ROUGHNESSMAP = "_RoughnessMap";

	public static string AVATAR_SHADER_COLOR = "_BaseColor";

	public static string AVATAR_SHADER_DIFFUSEINTENSITY = "_DiffuseIntensity";

	public static string AVATAR_SHADER_RIMINTENSITY = "_RimIntensity";

	public static string AVATAR_SHADER_BACKLIGHTINTENSITY = "_BacklightIntensity";

	public static string AVATAR_SHADER_REFLECTIONINTENSITY = "_ReflectionIntensity";

	public static string AVATAR_SHADER_CUBEMAP = "_Cubemap";

	public static string AVATAR_SHADER_ALPHA = "_Alpha";

	public static string AVATAR_SHADER_LOADING_DIMMER = "_LoadingDimmer";

	private const float LOADING_ANIMATION_AMPLITUDE = 0.5f;

	private const float LOADING_ANIMATION_PERIOD = 0.35f;

	private const float LOADING_ANIMATION_CURVE_SCALE = 0.25f;

	private const float LOADING_ANIMATION_DIMMER_MIN = 0.3f;

	private void Awake()
	{
		TextureCopyManager = base.gameObject.AddComponent<OvrAvatarTextureCopyManager>();
	}

	public void CreateTextureArrays()
	{
		for (int i = 0; i < 5; i++)
		{
			LocalAvatarConfig.ComponentMaterialProperties[i].Textures = new Texture2D[3];
			DefaultAvatarConfig.ComponentMaterialProperties[i].Textures = new Texture2D[3];
		}
		TextureArrays = new AvatarTextureArrayProperties[3];
	}

	public void SetRenderer(Renderer renderer)
	{
		TargetRenderer = renderer;
		TargetRenderer.GetClosestReflectionProbes(ReflectionProbes);
	}

	public void OnCombinedMeshReady()
	{
		InitTextureArrays();
		SetMaterialPropertyBlock();
		StartCoroutine(RunLoadingAnimation());
	}

	public void InitTextureArrays()
	{
		AvatarComponentMaterialProperties avatarComponentMaterialProperties = LocalAvatarConfig.ComponentMaterialProperties[0];
		for (int i = 0; i < TextureArrays.Length && i < avatarComponentMaterialProperties.Textures.Length; i++)
		{
			TextureArrays[i].TextureArray = new Texture2DArray(avatarComponentMaterialProperties.Textures[0].height, avatarComponentMaterialProperties.Textures[0].width, LocalAvatarConfig.ComponentMaterialProperties.Length, avatarComponentMaterialProperties.Textures[0].format, mipmap: true, (QualitySettings.activeColorSpace != 0) ? true : false)
			{
				filterMode = FilterMode.Trilinear
			};
			TextureArrays[i].Textures = new Texture2D[LocalAvatarConfig.ComponentMaterialProperties.Length];
			for (int j = 0; j < LocalAvatarConfig.ComponentMaterialProperties.Length; j++)
			{
				TextureArrays[i].Textures[j] = LocalAvatarConfig.ComponentMaterialProperties[j].Textures[i];
			}
			ProcessTexturesWithMips(TextureArrays[i].Textures, avatarComponentMaterialProperties.Textures[i].height, TextureArrays[i].TextureArray);
		}
	}

	private void ProcessTexturesWithMips(Texture2D[] textures, int texArrayResolution, Texture2DArray texArray)
	{
		for (int i = 0; i < textures.Length; i++)
		{
			int num = texArrayResolution;
			int num2 = textures[i].mipmapCount - 1;
			for (int num3 = num2; num3 >= 0; num3--)
			{
				int mipSize = texArrayResolution / num;
				TextureCopyManager.CopyTexture(textures[i], texArray, num3, mipSize, i);
				num /= 2;
			}
		}
	}

	private void SetMaterialPropertyBlock()
	{
		if (TargetRenderer != null)
		{
			for (int i = 0; i < LocalAvatarConfig.ComponentMaterialProperties.Length; i++)
			{
				ref Vector4 reference = ref LocalAvatarConfig.MaterialPropertyBlock.Colors[i];
				reference = LocalAvatarConfig.ComponentMaterialProperties[i].Color;
				LocalAvatarConfig.MaterialPropertyBlock.DiffuseIntensities[i] = LocalAvatarConfig.ComponentMaterialProperties[i].DiffuseIntensity;
				LocalAvatarConfig.MaterialPropertyBlock.RimIntensities[i] = LocalAvatarConfig.ComponentMaterialProperties[i].RimIntensity;
				LocalAvatarConfig.MaterialPropertyBlock.BacklightIntensities[i] = LocalAvatarConfig.ComponentMaterialProperties[i].BacklightIntensity;
				LocalAvatarConfig.MaterialPropertyBlock.ReflectionIntensities[i] = LocalAvatarConfig.ComponentMaterialProperties[i].ReflectionIntensity;
			}
		}
	}

	private void ApplyMaterialPropertyBlock()
	{
		MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
		materialPropertyBlock.SetVectorArray(AVATAR_SHADER_COLOR, LocalAvatarConfig.MaterialPropertyBlock.Colors);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_DIFFUSEINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.DiffuseIntensities);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_RIMINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.RimIntensities);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_BACKLIGHTINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.BacklightIntensities);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_REFLECTIONINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.ReflectionIntensities);
		TargetRenderer.GetClosestReflectionProbes(ReflectionProbes);
		if (ReflectionProbes != null && ReflectionProbes.Count > 0 && ReflectionProbes[0].probe.texture != null)
		{
			materialPropertyBlock.SetTexture(AVATAR_SHADER_CUBEMAP, ReflectionProbes[0].probe.texture);
		}
		for (int i = 0; i < TextureArrays.Length; i++)
		{
			materialPropertyBlock.SetTexture(TextureTypeToShaderProperties[i], TextureArrays[i].TextureArray);
		}
		TargetRenderer.SetPropertyBlock(materialPropertyBlock);
	}

	public static ovrAvatarBodyPartType GetComponentType(string objectName)
	{
		if (objectName.Contains("0"))
		{
			return ovrAvatarBodyPartType.Body;
		}
		if (objectName.Contains("1"))
		{
			return ovrAvatarBodyPartType.Clothing;
		}
		if (objectName.Contains("2"))
		{
			return ovrAvatarBodyPartType.Eyewear;
		}
		if (objectName.Contains("3"))
		{
			return ovrAvatarBodyPartType.Hair;
		}
		if (objectName.Contains("4"))
		{
			return ovrAvatarBodyPartType.Beard;
		}
		return ovrAvatarBodyPartType.Count;
	}

	public void ValidateTextures()
	{
		AvatarComponentMaterialProperties[] componentMaterialProperties = LocalAvatarConfig.ComponentMaterialProperties;
		int[] array = new int[3];
		TextureFormat[] array2 = new TextureFormat[3];
		for (int i = 0; i < componentMaterialProperties.Length; i++)
		{
			for (int j = 0; j < componentMaterialProperties[i].Textures.Length; j++)
			{
				if (componentMaterialProperties[i].Textures[j] == null)
				{
					string text = componentMaterialProperties[i].TypeIndex.ToString();
					TextureType textureType = (TextureType)j;
					throw new Exception(text + "Invalid: " + textureType);
				}
				array[j] = componentMaterialProperties[i].Textures[j].height;
				array2[j] = componentMaterialProperties[i].Textures[j].format;
			}
		}
		for (int k = 0; k < 3; k++)
		{
			for (int l = 1; l < componentMaterialProperties.Length; l++)
			{
				if (componentMaterialProperties[l - 1].Textures[k].height != componentMaterialProperties[l].Textures[k].height)
				{
					object[] obj = new object[8]
					{
						componentMaterialProperties[l].TypeIndex.ToString(),
						" Mismatching Resolutions: ",
						null,
						null,
						null,
						null,
						null,
						null
					};
					TextureType textureType2 = (TextureType)k;
					obj[2] = textureType2.ToString();
					obj[3] = " ";
					obj[4] = componentMaterialProperties[l - 1].Textures[k].height;
					obj[5] = " vs ";
					obj[6] = componentMaterialProperties[l].Textures[k].height;
					obj[7] = " Ensure you are using ASTC texture compression on Android or turn off CombineMeshes";
					throw new Exception(string.Concat(obj));
				}
				if (componentMaterialProperties[l - 1].Textures[k].format != componentMaterialProperties[l].Textures[k].format)
				{
					string text2 = componentMaterialProperties[l].TypeIndex.ToString();
					TextureType textureType3 = (TextureType)k;
					throw new Exception(text2 + " Mismatching Formats: " + textureType3.ToString() + " Ensure you are using ASTC texture compression on Android or turn off CombineMeshes");
				}
			}
		}
	}

	private IEnumerator RunLoadingAnimation()
	{
		int renderQueue2 = TargetRenderer.sharedMaterial.renderQueue;
		TargetRenderer.sharedMaterial.shader = Shader.Find(AVATAR_SHADER_LOADER);
		TargetRenderer.sharedMaterial.renderQueue = renderQueue2;
		TargetRenderer.sharedMaterial.SetColor(AVATAR_SHADER_COLOR, Color.white);
		while (TextureCopyManager.GetTextureCount() > 0)
		{
			float distance = (0.5f * Mathf.Sin(Time.timeSinceLevelLoad / 0.35f) + 0.5f) * 0.25f + 0.3f;
			TargetRenderer.sharedMaterial.SetFloat(AVATAR_SHADER_LOADING_DIMMER, distance);
			yield return null;
		}
		renderQueue2 = TargetRenderer.sharedMaterial.renderQueue;
		TargetRenderer.sharedMaterial.SetFloat(AVATAR_SHADER_LOADING_DIMMER, 1f);
		TargetRenderer.sharedMaterial.shader = Shader.Find(AVATAR_SHADER_COMBINED);
		TargetRenderer.sharedMaterial.renderQueue = renderQueue2;
		ApplyMaterialPropertyBlock();
	}
}
public class OvrAvatarMeshInstance : MonoBehaviour
{
	private HashSet<ulong> AssetsToLoad;

	public ulong MeshID;

	private ulong MaterialID;

	private ulong FadeTextureID;

	public ovrAvatarBodyPartType MeshType;

	public ovrAvatarMaterialState MaterialState;

	private MeshFilter Mesh;

	private MeshRenderer MeshInstance;

	public void AssetLoadedCallback(OvrAvatarAsset asset)
	{
		AssetsToLoad.Remove(asset.assetID);
		HandleAssetAvailable(asset);
		if (AssetsToLoad.Count <= 0)
		{
			UpdateMaterial();
		}
	}

	public void SetMeshAssets(ulong fadeTexture, ulong meshID, ulong materialID, ovrAvatarBodyPartType type)
	{
		MaterialID = materialID;
		MeshID = meshID;
		FadeTextureID = fadeTexture;
		MeshType = type;
		AssetsToLoad = new HashSet<ulong>();
		RequestAsset(meshID);
		RequestAsset(materialID);
		RequestAsset(fadeTexture);
	}

	private void HandleAssetAvailable(OvrAvatarAsset asset)
	{
		if (asset.assetID == MeshID)
		{
			Mesh = base.gameObject.AddComponent<MeshFilter>();
			MeshInstance = base.gameObject.AddComponent<MeshRenderer>();
			MeshInstance.shadowCastingMode = ShadowCastingMode.Off;
			Mesh.sharedMesh = ((OvrAvatarAssetMesh)asset).mesh;
			Material material = new Material(Shader.Find("OvrAvatar/AvatarSurfaceShaderSelfOccluding"));
			MeshInstance.material = material;
		}
		if (asset.assetID == MaterialID)
		{
			MaterialState = ((OvrAvatarAssetMaterial)asset).material;
			MaterialState.alphaMaskTextureID = FadeTextureID;
			RequestMaterialTextures();
		}
	}

	public void ChangeMaterial(ulong assetID)
	{
		MaterialID = assetID;
		RequestAsset(MaterialID);
	}

	private void RequestAsset(ulong assetID)
	{
		if (assetID != 0)
		{
			OvrAvatarAsset asset = OvrAvatarSDKManager.Instance.GetAsset(assetID);
			if (asset == null)
			{
				OvrAvatarSDKManager.Instance.BeginLoadingAsset(assetID, ovrAvatarAssetLevelOfDetail.Medium, AssetLoadedCallback);
				AssetsToLoad.Add(assetID);
			}
			else
			{
				HandleAssetAvailable(asset);
			}
		}
	}

	private void RequestMaterialTextures()
	{
		RequestAsset(MaterialState.normalMapTextureID);
		RequestAsset(MaterialState.parallaxMapTextureID);
		RequestAsset(MaterialState.roughnessMapTextureID);
		for (int i = 0; i < MaterialState.layerCount; i++)
		{
			RequestAsset(MaterialState.layers[i].sampleTexture);
		}
	}

	public void SetActive(bool active)
	{
		base.gameObject.SetActive(active);
		if (active)
		{
			UpdateMaterial();
		}
	}

	private void UpdateMaterial()
	{
		if (MeshInstance == null || MaterialID == 0)
		{
			return;
		}
		Material material = MeshInstance.material;
		ovrAvatarMaterialState materialState = MaterialState;
		material.SetColor("_BaseColor", materialState.baseColor);
		material.SetInt("_BaseMaskType", (int)materialState.baseMaskType);
		material.SetVector("_BaseMaskParameters", materialState.baseMaskParameters);
		material.SetVector("_BaseMaskAxis", materialState.baseMaskAxis);
		if (materialState.alphaMaskTextureID != 0)
		{
			material.SetTexture("_AlphaMask", OvrAvatarComponent.GetLoadedTexture(materialState.alphaMaskTextureID));
			material.SetTextureScale("_AlphaMask", new Vector2(materialState.alphaMaskScaleOffset.x, materialState.alphaMaskScaleOffset.y));
			material.SetTextureOffset("_AlphaMask", new Vector2(materialState.alphaMaskScaleOffset.z, materialState.alphaMaskScaleOffset.w));
		}
		if (materialState.normalMapTextureID != 0)
		{
			material.EnableKeyword("NORMAL_MAP_ON");
			material.SetTexture("_NormalMap", OvrAvatarComponent.GetLoadedTexture(materialState.normalMapTextureID));
			material.SetTextureScale("_NormalMap", new Vector2(materialState.normalMapScaleOffset.x, materialState.normalMapScaleOffset.y));
			material.SetTextureOffset("_NormalMap", new Vector2(materialState.normalMapScaleOffset.z, materialState.normalMapScaleOffset.w));
		}
		if (materialState.parallaxMapTextureID != 0)
		{
			material.SetTexture("_ParallaxMap", OvrAvatarComponent.GetLoadedTexture(materialState.parallaxMapTextureID));
			material.SetTextureScale("_ParallaxMap", new Vector2(materialState.parallaxMapScaleOffset.x, materialState.parallaxMapScaleOffset.y));
			material.SetTextureOffset("_ParallaxMap", new Vector2(materialState.parallaxMapScaleOffset.z, materialState.parallaxMapScaleOffset.w));
		}
		if (materialState.roughnessMapTextureID != 0)
		{
			material.EnableKeyword("ROUGHNESS_ON");
			material.SetTexture("_RoughnessMap", OvrAvatarComponent.GetLoadedTexture(materialState.roughnessMapTextureID));
			material.SetTextureScale("_RoughnessMap", new Vector2(materialState.roughnessMapScaleOffset.x, materialState.roughnessMapScaleOffset.y));
			material.SetTextureOffset("_RoughnessMap", new Vector2(materialState.roughnessMapScaleOffset.z, materialState.roughnessMapScaleOffset.w));
		}
		material.EnableKeyword(OvrAvatarComponent.LayerKeywords[materialState.layerCount]);
		for (ulong num = 0uL; num < materialState.layerCount; num++)
		{
			ovrAvatarMaterialLayerState ovrAvatarMaterialLayerState2 = materialState.layers[num];
			material.SetInt(OvrAvatarComponent.LayerSampleModeParameters[num], (int)ovrAvatarMaterialLayerState2.sampleMode);
			material.SetInt(OvrAvatarComponent.LayerBlendModeParameters[num], (int)ovrAvatarMaterialLayerState2.blendMode);
			material.SetInt(OvrAvatarComponent.LayerMaskTypeParameters[num], (int)ovrAvatarMaterialLayerState2.maskType);
			material.SetColor(OvrAvatarComponent.LayerColorParameters[num], ovrAvatarMaterialLayerState2.layerColor);
			if (ovrAvatarMaterialLayerState2.sampleMode != 0)
			{
				string text = OvrAvatarComponent.LayerSurfaceParameters[num];
				material.SetTexture(text, OvrAvatarComponent.GetLoadedTexture(ovrAvatarMaterialLayerState2.sampleTexture));
				material.SetTextureScale(text, new Vector2(ovrAvatarMaterialLayerState2.sampleScaleOffset.x, ovrAvatarMaterialLayerState2.sampleScaleOffset.y));
				material.SetTextureOffset(text, new Vector2(ovrAvatarMaterialLayerState2.sampleScaleOffset.z, ovrAvatarMaterialLayerState2.sampleScaleOffset.w));
			}
			if (ovrAvatarMaterialLayerState2.sampleMode == ovrAvatarMaterialLayerSampleMode.Parallax)
			{
				material.EnableKeyword("PARALLAX_ON");
			}
			material.SetColor(OvrAvatarComponent.LayerSampleParametersParameters[num], ovrAvatarMaterialLayerState2.sampleParameters);
			material.SetColor(OvrAvatarComponent.LayerMaskParametersParameters[num], ovrAvatarMaterialLayerState2.maskParameters);
			material.SetColor(OvrAvatarComponent.LayerMaskAxisParameters[num], ovrAvatarMaterialLayerState2.maskAxis);
		}
	}
}
public class OvrAvatarPacket
{
	public IntPtr ovrNativePacket = IntPtr.Zero;

	private List<float> frameTimes = new List<float>();

	private List<OvrAvatarDriver.PoseFrame> frames = new List<OvrAvatarDriver.PoseFrame>();

	private List<byte[]> encodedAudioPackets = new List<byte[]>();

	public float Duration => frameTimes[frameTimes.Count - 1];

	public OvrAvatarDriver.PoseFrame FinalFrame => frames[frames.Count - 1];

	public OvrAvatarPacket()
	{
	}

	public OvrAvatarPacket(OvrAvatarDriver.PoseFrame initialPose)
	{
		frameTimes.Add(0f);
		frames.Add(initialPose);
	}

	private OvrAvatarPacket(List<float> frameTimes, List<OvrAvatarDriver.PoseFrame> frames, List<byte[]> audioPackets)
	{
		this.frameTimes = frameTimes;
		this.frames = frames;
	}

	public void AddFrame(OvrAvatarDriver.PoseFrame frame, float deltaSeconds)
	{
		frameTimes.Add(Duration + deltaSeconds);
		frames.Add(frame);
	}

	public OvrAvatarDriver.PoseFrame GetPoseFrame(float seconds)
	{
		if (frames.Count == 1)
		{
			return frames[0];
		}
		int i;
		for (i = 1; i < frameTimes.Count && frameTimes[i] < seconds; i++)
		{
		}
		OvrAvatarDriver.PoseFrame a = frames[i - 1];
		OvrAvatarDriver.PoseFrame b = frames[i];
		float num = frameTimes[i - 1];
		float num2 = frameTimes[i];
		float t = (seconds - num) / (num2 - num);
		return OvrAvatarDriver.PoseFrame.Interpolate(a, b, t);
	}

	public static OvrAvatarPacket Read(Stream stream)
	{
		BinaryReader binaryReader = new BinaryReader(stream);
		int num = binaryReader.ReadInt32();
		List<float> list = new List<float>(num);
		for (int i = 0; i < num; i++)
		{
			list.Add(binaryReader.ReadSingle());
		}
		List<OvrAvatarDriver.PoseFrame> list2 = new List<OvrAvatarDriver.PoseFrame>(num);
		for (int j = 0; j < num; j++)
		{
			list2.Add(binaryReader.ReadPoseFrame());
		}
		int num2 = binaryReader.ReadInt32();
		List<byte[]> list3 = new List<byte[]>(num2);
		for (int k = 0; k < num2; k++)
		{
			int count = binaryReader.ReadInt32();
			byte[] item = binaryReader.ReadBytes(count);
			list3.Add(item);
		}
		return new OvrAvatarPacket(list, list2, list3);
	}

	public void Write(Stream stream)
	{
		BinaryWriter binaryWriter = new BinaryWriter(stream);
		int count = frameTimes.Count;
		binaryWriter.Write(count);
		for (int i = 0; i < count; i++)
		{
			binaryWriter.Write(frameTimes[i]);
		}
		for (int j = 0; j < count; j++)
		{
			OvrAvatarDriver.PoseFrame frame = frames[j];
			binaryWriter.Write(frame);
		}
		int count2 = encodedAudioPackets.Count;
		binaryWriter.Write(count2);
		for (int k = 0; k < count2; k++)
		{
			byte[] array = encodedAudioPackets[k];
			binaryWriter.Write(array.Length);
			binaryWriter.Write(array);
		}
	}
}
internal static class BinaryWriterExtensions
{
	public static void Write(this BinaryWriter writer, OvrAvatarDriver.PoseFrame frame)
	{
		writer.Write(frame.headPosition);
		writer.Write(frame.headRotation);
		writer.Write(frame.handLeftPosition);
		writer.Write(frame.handLeftRotation);
		writer.Write(frame.handRightPosition);
		writer.Write(frame.handRightRotation);
		writer.Write(frame.voiceAmplitude);
		writer.Write(frame.controllerLeftPose);
		writer.Write(frame.controllerRightPose);
	}

	public static void Write(this BinaryWriter writer, Vector3 vec3)
	{
		writer.Write(vec3.x);
		writer.Write(vec3.y);
		writer.Write(vec3.z);
	}

	public static void Write(this BinaryWriter writer, Vector2 vec2)
	{
		writer.Write(vec2.x);
		writer.Write(vec2.y);
	}

	public static void Write(this BinaryWriter writer, Quaternion quat)
	{
		writer.Write(quat.x);
		writer.Write(quat.y);
		writer.Write(quat.z);
		writer.Write(quat.w);
	}

	public static void Write(this BinaryWriter writer, OvrAvatarDriver.ControllerPose pose)
	{
		writer.Write((uint)pose.buttons);
		writer.Write((uint)pose.touches);
		writer.Write(pose.joystickPosition);
		writer.Write(pose.indexTrigger);
		writer.Write(pose.handTrigger);
		writer.Write(pose.isActive);
	}
}
internal static class BinaryReaderExtensions
{
	public static OvrAvatarDriver.PoseFrame ReadPoseFrame(this BinaryReader reader)
	{
		OvrAvatarDriver.PoseFrame result = default(OvrAvatarDriver.PoseFrame);
		result.headPosition = reader.ReadVector3();
		result.headRotation = reader.ReadQuaternion();
		result.handLeftPosition = reader.ReadVector3();
		result.handLeftRotation = reader.ReadQuaternion();
		result.handRightPosition = reader.ReadVector3();
		result.handRightRotation = reader.ReadQuaternion();
		result.voiceAmplitude = reader.ReadSingle();
		result.controllerLeftPose = reader.ReadControllerPose();
		result.controllerRightPose = reader.ReadControllerPose();
		return result;
	}

	public static Vector2 ReadVector2(this BinaryReader reader)
	{
		Vector2 result = default(Vector2);
		result.x = reader.ReadSingle();
		result.y = reader.ReadSingle();
		return result;
	}

	public static Vector3 ReadVector3(this BinaryReader reader)
	{
		Vector3 result = default(Vector3);
		result.x = reader.ReadSingle();
		result.y = reader.ReadSingle();
		result.z = reader.ReadSingle();
		return result;
	}

	public static Quaternion ReadQuaternion(this BinaryReader reader)
	{
		Quaternion result = default(Quaternion);
		result.x = reader.ReadSingle();
		result.y = reader.ReadSingle();
		result.z = reader.ReadSingle();
		result.w = reader.ReadSingle();
		return result;
	}

	public static OvrAvatarDriver.ControllerPose ReadControllerPose(this BinaryReader reader)
	{
		OvrAvatarDriver.ControllerPose result = default(OvrAvatarDriver.ControllerPose);
		result.buttons = (ovrAvatarButton)reader.ReadUInt32();
		result.touches = (ovrAvatarTouch)reader.ReadUInt32();
		result.joystickPosition = reader.ReadVector2();
		result.indexTrigger = reader.ReadSingle();
		result.handTrigger = reader.ReadSingle();
		result.isActive = reader.ReadBoolean();
		return result;
	}
}
public class OvrAvatarProjectorRenderComponent : OvrAvatarRenderComponent
{
	private Material material;

	internal void InitializeProjectorRender(ovrAvatarRenderPart_ProjectorRender render, Shader shader, OvrAvatarRenderComponent target)
	{
		if (shader == null)
		{
			shader = Shader.Find("OvrAvatar/AvatarSurfaceShader");
		}
		material = CreateAvatarMaterial(base.gameObject.name + "_projector", shader);
		material.EnableKeyword("PROJECTOR_ON");
		Renderer component = target.GetComponent<Renderer>();
		if (component != null)
		{
			List<Material> list = new List<Material>(component.sharedMaterials);
			list.Add(material);
			component.sharedMaterials = list.ToArray();
		}
	}

	internal void UpdateProjectorRender(OvrAvatarComponent component, ovrAvatarRenderPart_ProjectorRender render)
	{
		OvrAvatar.ConvertTransform(render.localTransform, base.transform);
		material.SetMatrix("_ProjectorWorldToLocal", base.transform.worldToLocalMatrix);
		component.UpdateAvatarMaterial(material, render.materialState);
	}

	private void OnDrawGizmos()
	{
		Vector3 from = base.transform.localToWorldMatrix.MultiplyPoint(new Vector3(-1f, -1f, -1f));
		Vector3 vector = base.transform.localToWorldMatrix.MultiplyPoint(new Vector3(1f, -1f, -1f));
		Vector3 vector2 = base.transform.localToWorldMatrix.MultiplyPoint(new Vector3(-1f, 1f, -1f));
		Vector3 vector3 = base.transform.localToWorldMatrix.MultiplyPoint(new Vector3(1f, 1f, -1f));
		Vector3 vector4 = base.transform.localToWorldMatrix.MultiplyPoint(new Vector3(-1f, -1f, 1f));
		Vector3 vector5 = base.transform.localToWorldMatrix.MultiplyPoint(new Vector3(1f, -1f, 1f));
		Vector3 vector6 = base.transform.localToWorldMatrix.MultiplyPoint(new Vector3(-1f, 1f, 1f));
		Vector3 to = base.transform.localToWorldMatrix.MultiplyPoint(new Vector3(1f, 1f, 1f));
		Gizmos.color = Color.gray;
		Gizmos.DrawLine(from, vector);
		Gizmos.DrawLine(from, vector2);
		Gizmos.DrawLine(vector2, vector3);
		Gizmos.DrawLine(vector, vector3);
		Gizmos.DrawLine(from, vector4);
		Gizmos.DrawLine(vector, vector5);
		Gizmos.DrawLine(vector2, vector6);
		Gizmos.DrawLine(vector3, to);
		Gizmos.DrawLine(vector4, vector5);
		Gizmos.DrawLine(vector4, vector6);
		Gizmos.DrawLine(vector6, to);
		Gizmos.DrawLine(vector5, to);
	}
}
public class OvrAvatarRemoteDriver : OvrAvatarDriver
{
	private Queue<OvrAvatarPacket> packetQueue = new Queue<OvrAvatarPacket>();

	private IntPtr CurrentSDKPacket = IntPtr.Zero;

	private float CurrentPacketTime;

	private const int MinPacketQueue = 1;

	private const int MaxPacketQueue = 4;

	private int CurrentSequence = -1;

	private bool isStreaming;

	private OvrAvatarPacket currentPacket;

	public void QueuePacket(int sequence, OvrAvatarPacket packet)
	{
		if (sequence > CurrentSequence)
		{
			CurrentSequence = sequence;
			packetQueue.Enqueue(packet);
		}
	}

	public override void UpdateTransforms(IntPtr sdkAvatar)
	{
		switch (Mode)
		{
		case PacketMode.SDK:
			UpdateFromSDKPacket(sdkAvatar);
			break;
		case PacketMode.Unity:
			UpdateFromUnityPacket(sdkAvatar);
			break;
		}
	}

	private void UpdateFromSDKPacket(IntPtr sdkAvatar)
	{
		if (CurrentSDKPacket == IntPtr.Zero && packetQueue.Count >= 1)
		{
			CurrentSDKPacket = packetQueue.Dequeue().ovrNativePacket;
		}
		if (!(CurrentSDKPacket != IntPtr.Zero))
		{
			return;
		}
		float num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetDurationSeconds(CurrentSDKPacket);
		Oculus.Avatar.CAPI.ovrAvatar_UpdatePoseFromPacket(sdkAvatar, CurrentSDKPacket, Mathf.Min(num, CurrentPacketTime));
		CurrentPacketTime += Time.deltaTime;
		if (CurrentPacketTime > num)
		{
			Oculus.Avatar.CAPI.ovrAvatarPacket_Free(CurrentSDKPacket);
			CurrentSDKPacket = IntPtr.Zero;
			CurrentPacketTime -= num;
			while (packetQueue.Count > 4)
			{
				packetQueue.Dequeue();
			}
		}
	}

	private void UpdateFromUnityPacket(IntPtr sdkAvatar)
	{
		if (!isStreaming && packetQueue.Count > 1)
		{
			currentPacket = packetQueue.Dequeue();
			isStreaming = true;
		}
		if (!isStreaming)
		{
			return;
		}
		CurrentPacketTime += Time.deltaTime;
		while (CurrentPacketTime > currentPacket.Duration)
		{
			if (packetQueue.Count == 0)
			{
				CurrentPose = currentPacket.FinalFrame;
				CurrentPacketTime = 0f;
				currentPacket = null;
				isStreaming = false;
				return;
			}
			while (packetQueue.Count > 4)
			{
				packetQueue.Dequeue();
			}
			CurrentPacketTime -= currentPacket.Duration;
			currentPacket = packetQueue.Dequeue();
		}
		CurrentPose = currentPacket.GetPoseFrame(CurrentPacketTime);
		UpdateTransformsFromPose(sdkAvatar);
	}
}
public class OvrAvatarRenderComponent : MonoBehaviour
{
	private bool firstSkinnedUpdate = true;

	public SkinnedMeshRenderer mesh;

	public Transform[] bones;

	protected void UpdateActive(OvrAvatar avatar, ovrAvatarVisibilityFlags mask)
	{
		bool flag = avatar.ShowFirstPerson && (mask & ovrAvatarVisibilityFlags.FirstPerson) != 0;
		flag |= avatar.ShowThirdPerson && (mask & ovrAvatarVisibilityFlags.ThirdPerson) != 0;
		base.gameObject.SetActive(flag);
	}

	protected SkinnedMeshRenderer CreateSkinnedMesh(ulong assetID, ovrAvatarVisibilityFlags visibilityMask, int thirdPersonLayer, int firstPersonLayer, int sortingOrder)
	{
		OvrAvatarAssetMesh ovrAvatarAssetMesh = (OvrAvatarAssetMesh)OvrAvatarSDKManager.Instance.GetAsset(assetID);
		if (ovrAvatarAssetMesh == null)
		{
			throw new Exception("Couldn't find mesh for asset " + assetID);
		}
		if ((visibilityMask & ovrAvatarVisibilityFlags.ThirdPerson) != 0)
		{
			base.gameObject.layer = thirdPersonLayer;
		}
		else
		{
			base.gameObject.layer = firstPersonLayer;
		}
		SkinnedMeshRenderer skinnedMeshRenderer = ovrAvatarAssetMesh.CreateSkinnedMeshRendererOnObject(base.gameObject);
		skinnedMeshRenderer.quality = SkinQuality.Bone4;
		skinnedMeshRenderer.sortingOrder = sortingOrder;
		skinnedMeshRenderer.updateWhenOffscreen = true;
		if ((visibilityMask & ovrAvatarVisibilityFlags.SelfOccluding) == 0)
		{
			skinnedMeshRenderer.shadowCastingMode = ShadowCastingMode.Off;
		}
		return skinnedMeshRenderer;
	}

	protected void UpdateSkinnedMesh(OvrAvatar avatar, Transform[] bones, ovrAvatarTransform localTransform, ovrAvatarVisibilityFlags visibilityMask, IntPtr renderPart)
	{
		UpdateActive(avatar, visibilityMask);
		OvrAvatar.ConvertTransform(localTransform, base.transform);
		ovrAvatarRenderPartType ovrAvatarRenderPartType2 = Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetType(renderPart);
		ulong num = ovrAvatarRenderPartType2 switch
		{
			ovrAvatarRenderPartType.SkinnedMeshRender => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetDirtyJoints(renderPart), 
			ovrAvatarRenderPartType.SkinnedMeshRenderPBS => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetDirtyJoints(renderPart), 
			ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2 => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetDirtyJoints(renderPart), 
			_ => throw new Exception("Unhandled render part type: " + ovrAvatarRenderPartType2), 
		};
		for (uint num2 = 0u; num2 < 64; num2++)
		{
			ulong num3 = (ulong)(1L << (int)num2);
			if ((firstSkinnedUpdate && num2 < bones.Length) || (num3 & num) != 0)
			{
				Transform target = bones[num2];
				OvrAvatar.ConvertTransform(ovrAvatarRenderPartType2 switch
				{
					ovrAvatarRenderPartType.SkinnedMeshRender => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetJointTransform(renderPart, num2), 
					ovrAvatarRenderPartType.SkinnedMeshRenderPBS => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetJointTransform(renderPart, num2), 
					ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2 => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetJointTransform(renderPart, num2), 
					_ => throw new Exception("Unhandled render part type: " + ovrAvatarRenderPartType2), 
				}, target);
			}
		}
		firstSkinnedUpdate = false;
	}

	protected Material CreateAvatarMaterial(string name, Shader shader)
	{
		if (shader == null)
		{
			throw new Exception("No shader provided for avatar material.");
		}
		Material material = new Material(shader);
		material.name = name;
		return material;
	}
}
[Flags]
public enum ovrAvatarCapabilities
{
	Body = 1,
	Hands = 2,
	Base = 4,
	BodyTilt = 0x10,
	All = -1
}
public enum ovrAvatarMessageType
{
	AvatarSpecification,
	AssetLoaded,
	Count
}
public struct ovrAvatarMessage_AvatarSpecification
{
	public IntPtr avatarSpec;

	public ulong oculusUserID;
}
public struct ovrAvatarMessage_AssetLoaded
{
	public ulong assetID;

	public IntPtr asset;
}
public enum ovrAvatarAssetType
{
	Mesh,
	Texture,
	Pose,
	Material,
	CombinedMesh,
	PBSMaterial,
	Count
}
public struct ovrAvatarMeshVertex
{
	public float x;

	public float y;

	public float z;

	public float nx;

	public float ny;

	public float nz;

	public float tx;

	public float ty;

	public float tz;

	public float tw;

	public float u;

	public float v;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public byte[] blendIndices;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public float[] blendWeights;
}
public struct ovrAvatarMeshVertexV2
{
	public float x;

	public float y;

	public float z;

	public float nx;

	public float ny;

	public float nz;

	public float tx;

	public float ty;

	public float tz;

	public float tw;

	public float u;

	public float v;

	public float r;

	public float g;

	public float b;

	public float a;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public byte[] blendIndices;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public float[] blendWeights;
}
public struct ovrAvatarMeshAssetData
{
	public uint vertexCount;

	public IntPtr vertexBuffer;

	public uint indexCount;

	public IntPtr indexBuffer;

	public ovrAvatarSkinnedMeshPose skinnedBindPose;
}
public struct ovrAvatarMeshAssetDataV2
{
	public uint vertexCount;

	public IntPtr vertexBuffer;

	public uint indexCount;

	public IntPtr indexBuffer;

	public ovrAvatarSkinnedMeshPose skinnedBindPose;
}
public enum ovrAvatarTextureFormat
{
	RGB24,
	DXT1,
	DXT5,
	ASTC_RGB_6x6,
	ASTC_RGB_6x6_MIPMAPS,
	Count
}
public struct ovrAvatarTextureAssetData
{
	public ovrAvatarTextureFormat format;

	public uint sizeX;

	public uint sizeY;

	public uint mipCount;

	public ulong textureDataSize;

	public IntPtr textureData;
}
public enum ovrAvatarRenderPartType
{
	SkinnedMeshRender,
	SkinnedMeshRenderPBS,
	ProjectorRender,
	SkinnedMeshRenderPBS_V2,
	Count
}
public struct ovrAvatarTransform
{
	public Vector3 position;

	public Quaternion orientation;

	public Vector3 scale;
}
[Flags]
public enum ovrAvatarButton
{
	One = 1,
	Two = 2,
	Three = 4,
	Joystick = 8
}
[Flags]
public enum ovrAvatarTouch
{
	One = 1,
	Two = 2,
	Joystick = 4,
	ThumbRest = 8,
	Index = 0x10,
	Pointing = 0x40,
	ThumbUp = 0x80
}
public struct ovrAvatarHandInputState
{
	public ovrAvatarTransform transform;

	public ovrAvatarButton buttonMask;

	public ovrAvatarTouch touchMask;

	public float joystickX;

	public float joystickY;

	public float indexTrigger;

	public float handTrigger;

	[MarshalAs(UnmanagedType.I1)]
	public bool isActive;
}
public struct ovrAvatarComponent
{
	public ovrAvatarTransform transform;

	public uint renderPartCount;

	public IntPtr renderParts;

	[MarshalAs(UnmanagedType.LPStr)]
	public string name;
}
public struct ovrAvatarBaseComponent
{
	public Vector3 basePosition;

	public IntPtr renderComponent;
}
public struct ovrAvatarBodyComponent
{
	public ovrAvatarTransform leftEyeTransform;

	public ovrAvatarTransform rightEyeTransform;

	public ovrAvatarTransform centerEyeTransform;

	public IntPtr renderComponent;
}
public struct ovrAvatarControllerComponent
{
	public ovrAvatarHandInputState inputState;

	public IntPtr renderComponent;
}
public struct ovrAvatarHandComponent
{
	public ovrAvatarHandInputState inputState;

	public IntPtr renderComponent;
}
public enum ovrAvatarMaterialLayerBlendMode
{
	Add,
	Multiply,
	Count
}
public enum ovrAvatarMaterialLayerSampleMode
{
	Color,
	Texture,
	TextureSingleChannel,
	Parallax,
	Count
}
public enum ovrAvatarMaterialMaskType
{
	None,
	Positional,
	ViewReflection,
	Fresnel,
	Pulse,
	Count
}
public enum ovrAvatarControllerType
{
	Touch,
	Malibu,
	Go,
	Count
}
public enum ovrAvatarAssetLevelOfDetail
{
	Lowest = 1,
	Medium = 3,
	Highest = 5
}
public enum ovrAvatarLookAndFeelVersion
{
	Unknown = -1,
	One,
	Two
}
public struct ovrAvatarMaterialLayerState
{
	public ovrAvatarMaterialLayerBlendMode blendMode;

	public ovrAvatarMaterialLayerSampleMode sampleMode;

	public ovrAvatarMaterialMaskType maskType;

	public Vector4 layerColor;

	public Vector4 sampleParameters;

	public ulong sampleTexture;

	public Vector4 sampleScaleOffset;

	public Vector4 maskParameters;

	public Vector4 maskAxis;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		return a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarMaterialLayerState ovrAvatarMaterialLayerState2))
		{
			return false;
		}
		if (blendMode != ovrAvatarMaterialLayerState2.blendMode)
		{
			return false;
		}
		if (sampleMode != ovrAvatarMaterialLayerState2.sampleMode)
		{
			return false;
		}
		if (maskType != ovrAvatarMaterialLayerState2.maskType)
		{
			return false;
		}
		if (!VectorEquals(layerColor, ovrAvatarMaterialLayerState2.layerColor))
		{
			return false;
		}
		if (!VectorEquals(sampleParameters, ovrAvatarMaterialLayerState2.sampleParameters))
		{
			return false;
		}
		if (sampleTexture != ovrAvatarMaterialLayerState2.sampleTexture)
		{
			return false;
		}
		if (!VectorEquals(sampleScaleOffset, ovrAvatarMaterialLayerState2.sampleScaleOffset))
		{
			return false;
		}
		if (!VectorEquals(maskParameters, ovrAvatarMaterialLayerState2.maskParameters))
		{
			return false;
		}
		if (!VectorEquals(maskAxis, ovrAvatarMaterialLayerState2.maskAxis))
		{
			return false;
		}
		return true;
	}

	public override int GetHashCode()
	{
		return blendMode.GetHashCode() ^ sampleMode.GetHashCode() ^ maskType.GetHashCode() ^ layerColor.GetHashCode() ^ sampleParameters.GetHashCode() ^ sampleTexture.GetHashCode() ^ sampleScaleOffset.GetHashCode() ^ maskParameters.GetHashCode() ^ maskAxis.GetHashCode();
	}
}
public struct ovrAvatarMaterialState
{
	public Vector4 baseColor;

	public ovrAvatarMaterialMaskType baseMaskType;

	public Vector4 baseMaskParameters;

	public Vector4 baseMaskAxis;

	public ovrAvatarMaterialLayerSampleMode sampleMode;

	public ulong alphaMaskTextureID;

	public Vector4 alphaMaskScaleOffset;

	public ulong normalMapTextureID;

	public Vector4 normalMapScaleOffset;

	public ulong parallaxMapTextureID;

	public Vector4 parallaxMapScaleOffset;

	public ulong roughnessMapTextureID;

	public Vector4 roughnessMapScaleOffset;

	public uint layerCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
	public ovrAvatarMaterialLayerState[] layers;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		return a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarMaterialState ovrAvatarMaterialState2))
		{
			return false;
		}
		if (!VectorEquals(baseColor, ovrAvatarMaterialState2.baseColor))
		{
			return false;
		}
		if (baseMaskType != ovrAvatarMaterialState2.baseMaskType)
		{
			return false;
		}
		if (!VectorEquals(baseMaskParameters, ovrAvatarMaterialState2.baseMaskParameters))
		{
			return false;
		}
		if (!VectorEquals(baseMaskAxis, ovrAvatarMaterialState2.baseMaskAxis))
		{
			return false;
		}
		if (sampleMode != ovrAvatarMaterialState2.sampleMode)
		{
			return false;
		}
		if (alphaMaskTextureID != ovrAvatarMaterialState2.alphaMaskTextureID)
		{
			return false;
		}
		if (!VectorEquals(alphaMaskScaleOffset, ovrAvatarMaterialState2.alphaMaskScaleOffset))
		{
			return false;
		}
		if (normalMapTextureID != ovrAvatarMaterialState2.normalMapTextureID)
		{
			return false;
		}
		if (!VectorEquals(normalMapScaleOffset, ovrAvatarMaterialState2.normalMapScaleOffset))
		{
			return false;
		}
		if (parallaxMapTextureID != ovrAvatarMaterialState2.parallaxMapTextureID)
		{
			return false;
		}
		if (!VectorEquals(parallaxMapScaleOffset, ovrAvatarMaterialState2.parallaxMapScaleOffset))
		{
			return false;
		}
		if (roughnessMapTextureID != ovrAvatarMaterialState2.roughnessMapTextureID)
		{
			return false;
		}
		if (!VectorEquals(roughnessMapScaleOffset, ovrAvatarMaterialState2.roughnessMapScaleOffset))
		{
			return false;
		}
		if (layerCount != ovrAvatarMaterialState2.layerCount)
		{
			return false;
		}
		for (int i = 0; i < layerCount; i++)
		{
			if (!layers[i].Equals(ovrAvatarMaterialState2.layers[i]))
			{
				return false;
			}
		}
		return true;
	}

	public override int GetHashCode()
	{
		int num = 0;
		num ^= baseColor.GetHashCode();
		num ^= baseMaskType.GetHashCode();
		num ^= baseMaskParameters.GetHashCode();
		num ^= baseMaskAxis.GetHashCode();
		num ^= sampleMode.GetHashCode();
		num ^= alphaMaskTextureID.GetHashCode();
		num ^= alphaMaskScaleOffset.GetHashCode();
		num ^= normalMapTextureID.GetHashCode();
		num ^= normalMapScaleOffset.GetHashCode();
		num ^= parallaxMapTextureID.GetHashCode();
		num ^= parallaxMapScaleOffset.GetHashCode();
		num ^= roughnessMapTextureID.GetHashCode();
		num ^= roughnessMapScaleOffset.GetHashCode();
		num ^= layerCount.GetHashCode();
		for (int i = 0; i < layerCount; i++)
		{
			num ^= layers[i].GetHashCode();
		}
		return num;
	}
}
public struct ovrAvatarPBSMaterialState
{
	public Vector4 baseColor;

	public ulong albedoTextureID;

	public Vector4 albedoMultiplier;

	public ulong metallicnessTextureID;

	public float glossinessScale;

	public ulong normalTextureID;

	public ulong heightTextureID;

	public ulong occlusionTextureID;

	public ulong emissionTextureID;

	public Vector4 emissionMultiplier;

	public ulong detailMaskTextureID;

	public ulong detailAlbedoTextureID;

	public ulong detailNormalTextureID;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		return a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarPBSMaterialState ovrAvatarPBSMaterialState2))
		{
			return false;
		}
		if (!VectorEquals(baseColor, ovrAvatarPBSMaterialState2.baseColor))
		{
			return false;
		}
		if (albedoTextureID != ovrAvatarPBSMaterialState2.albedoTextureID)
		{
			return false;
		}
		if (!VectorEquals(albedoMultiplier, ovrAvatarPBSMaterialState2.albedoMultiplier))
		{
			return false;
		}
		if (metallicnessTextureID != ovrAvatarPBSMaterialState2.metallicnessTextureID)
		{
			return false;
		}
		if (glossinessScale != ovrAvatarPBSMaterialState2.glossinessScale)
		{
			return false;
		}
		if (normalTextureID != ovrAvatarPBSMaterialState2.normalTextureID)
		{
			return false;
		}
		if (heightTextureID != ovrAvatarPBSMaterialState2.heightTextureID)
		{
			return false;
		}
		if (occlusionTextureID != ovrAvatarPBSMaterialState2.occlusionTextureID)
		{
			return false;
		}
		if (emissionTextureID != ovrAvatarPBSMaterialState2.emissionTextureID)
		{
			return false;
		}
		if (!VectorEquals(emissionMultiplier, ovrAvatarPBSMaterialState2.emissionMultiplier))
		{
			return false;
		}
		if (detailMaskTextureID != ovrAvatarPBSMaterialState2.detailMaskTextureID)
		{
			return false;
		}
		if (detailAlbedoTextureID != ovrAvatarPBSMaterialState2.detailAlbedoTextureID)
		{
			return false;
		}
		if (detailNormalTextureID != ovrAvatarPBSMaterialState2.detailNormalTextureID)
		{
			return false;
		}
		return true;
	}

	public override int GetHashCode()
	{
		return baseColor.GetHashCode() ^ albedoTextureID.GetHashCode() ^ albedoMultiplier.GetHashCode() ^ metallicnessTextureID.GetHashCode() ^ glossinessScale.GetHashCode() ^ normalTextureID.GetHashCode() ^ heightTextureID.GetHashCode() ^ occlusionTextureID.GetHashCode() ^ emissionTextureID.GetHashCode() ^ emissionMultiplier.GetHashCode() ^ detailMaskTextureID.GetHashCode() ^ detailAlbedoTextureID.GetHashCode() ^ detailNormalTextureID.GetHashCode();
	}
}
public class OvrAvatarAssetMaterial : OvrAvatarAsset
{
	public ovrAvatarMaterialState material;

	public OvrAvatarAssetMaterial(ulong id, IntPtr mat)
	{
		assetID = id;
		material = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMaterialState(mat);
	}
}
public struct ovrAvatarSkinnedMeshPose
{
	public uint jointCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public ovrAvatarTransform[] jointTransform;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public int[] jointParents;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public IntPtr[] jointNames;
}
[Flags]
public enum ovrAvatarVisibilityFlags
{
	FirstPerson = 1,
	ThirdPerson = 2,
	SelfOccluding = 4
}
public struct ovrAvatarRenderPart_SkinnedMeshRender
{
	public ovrAvatarTransform localTransform;

	public ovrAvatarVisibilityFlags visibilityMask;

	public ulong meshAssetID;

	public ovrAvatarMaterialState materialState;

	public ovrAvatarSkinnedMeshPose skinnedPose;
}
public struct ovrAvatarRenderPart_SkinnedMeshRenderPBS
{
	public ovrAvatarTransform localTransform;

	public ovrAvatarVisibilityFlags visibilityMask;

	public ulong meshAssetID;

	public ulong albedoTextureAssetID;

	public ulong surfaceTextureAssetID;

	public ovrAvatarSkinnedMeshPose skinnedPose;
}
public struct ovrAvatarRenderPart_ProjectorRender
{
	public ovrAvatarTransform localTransform;

	public uint componentIndex;

	public uint renderPartIndex;

	public ovrAvatarMaterialState materialState;
}
public struct ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2
{
	public ovrAvatarTransform localTransform;

	public ovrAvatarVisibilityFlags visibilityMask;

	public ulong meshAssetID;

	public ovrAvatarPBSMaterialState materialState;

	public ovrAvatarSkinnedMeshPose skinnedPose;
}
public enum ovrAvatarHandGesture
{
	Default,
	GripSphere,
	GripCube,
	Count
}
public enum ovrAvatarBodyPartType
{
	Body,
	Clothing,
	Eyewear,
	Hair,
	Beard,
	Count
}
namespace Oculus.Avatar
{
	public class CAPI
	{
		private const string LibFile = "ovravatarloader";

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_InitializeAndroidUnity(string appID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_Shutdown();

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarMessage_Pop();

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarMessageType ovrAvatarMessage_GetType(IntPtr msg);

		public static ovrAvatarMessage_AvatarSpecification ovrAvatarMessage_GetAvatarSpecification(IntPtr msg)
		{
			IntPtr ptr = ovrAvatarMessage_GetAvatarSpecification_Native(msg);
			return (ovrAvatarMessage_AvatarSpecification)Marshal.PtrToStructure(ptr, typeof(ovrAvatarMessage_AvatarSpecification));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarMessage_GetAvatarSpecification")]
		private static extern IntPtr ovrAvatarMessage_GetAvatarSpecification_Native(IntPtr msg);

		public static ovrAvatarMessage_AssetLoaded ovrAvatarMessage_GetAssetLoaded(IntPtr msg)
		{
			IntPtr ptr = ovrAvatarMessage_GetAssetLoaded_Native(msg);
			return (ovrAvatarMessage_AssetLoaded)Marshal.PtrToStructure(ptr, typeof(ovrAvatarMessage_AssetLoaded));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarMessage_GetAssetLoaded")]
		private static extern IntPtr ovrAvatarMessage_GetAssetLoaded_Native(IntPtr msg);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarMessage_Free(IntPtr msg);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarSpecificationRequest_Create(ulong userID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_Destroy(IntPtr specificationRequest);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetCombineMeshes(IntPtr specificationRequest, bool useCombinedMesh);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetLookAndFeelVersion(IntPtr specificationRequest, ovrAvatarLookAndFeelVersion version);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetLevelOfDetail(IntPtr specificationRequest, ovrAvatarAssetLevelOfDetail lod);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RequestAvatarSpecification(ulong userID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RequestAvatarSpecificationFromSpecRequest(IntPtr specificationRequest);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatar_Create(IntPtr avatarSpecification, ovrAvatarCapabilities capabilities);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_Destroy(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_UpdateBody(IntPtr avatar, ovrAvatarTransform headPose);

		public static void ovrAvatarPose_UpdateVoiceVisualization(IntPtr avatar, float[] pcmData)
		{
			ovrAvatarPose_UpdateVoiceVisualization_Native(avatar, (uint)pcmData.Length, pcmData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_UpdateVoiceVisualization")]
		private static extern void ovrAvatarPose_UpdateVoiceVisualization_Native(IntPtr avatar, uint pcmDataSize, [In] float[] pcmData);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_UpdateHands(IntPtr avatar, ovrAvatarHandInputState inputStateLeft, ovrAvatarHandInputState inputStateRight);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_Update3DofHands(IntPtr avatar, IntPtr inputStateLeft, IntPtr inputStateRight, ovrAvatarControllerType type);

		public static void ovrAvatarPose_UpdateSDK3DofHands(IntPtr avatar, ovrAvatarHandInputState inputStateLeft, ovrAvatarHandInputState inputStateRight, ovrAvatarControllerType type)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(inputStateLeft));
			IntPtr intPtr2 = Marshal.AllocHGlobal(Marshal.SizeOf(inputStateRight));
			Marshal.StructureToPtr(inputStateLeft, intPtr, fDeleteOld: false);
			Marshal.StructureToPtr(inputStateRight, intPtr2, fDeleteOld: false);
			ovrAvatar_SetLeftControllerVisibility(avatar, show: true);
			ovrAvatar_SetRightControllerVisibility(avatar, show: true);
			ovrAvatar_SetLeftHandVisibility(avatar, show: true);
			ovrAvatar_SetRightHandVisibility(avatar, show: true);
			ovrAvatarPose_Update3DofHands(avatar, intPtr, intPtr2, type);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_Finalize(IntPtr avatar, float elapsedSeconds);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftControllerVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightControllerVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftHandVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightHandVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarComponent_Count(IntPtr avatar);

		public static ovrAvatarComponent ovrAvatarComponent_Get(IntPtr avatar, uint index)
		{
			IntPtr ptr = ovrAvatarComponent_Get_Native(avatar, index);
			return (ovrAvatarComponent)Marshal.PtrToStructure(ptr, typeof(ovrAvatarComponent));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarComponent_Get")]
		public static extern IntPtr ovrAvatarComponent_Get_Native(IntPtr avatar, uint index);

		public static ovrAvatarBaseComponent? ovrAvatarPose_GetBaseComponent(IntPtr avatar)
		{
			IntPtr intPtr = ovrAvatarPose_GetBaseComponent_Native(avatar);
			return (!(intPtr == IntPtr.Zero)) ? new ovrAvatarBaseComponent?((ovrAvatarBaseComponent)Marshal.PtrToStructure(intPtr, typeof(ovrAvatarBaseComponent))) : null;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetBaseComponent")]
		private static extern IntPtr ovrAvatarPose_GetBaseComponent_Native(IntPtr avatar);

		public static ovrAvatarBodyComponent? ovrAvatarPose_GetBodyComponent(IntPtr avatar)
		{
			IntPtr intPtr = ovrAvatarPose_GetBodyComponent_Native(avatar);
			return (!(intPtr == IntPtr.Zero)) ? new ovrAvatarBodyComponent?((ovrAvatarBodyComponent)Marshal.PtrToStructure(intPtr, typeof(ovrAvatarBodyComponent))) : null;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetBodyComponent")]
		private static extern IntPtr ovrAvatarPose_GetBodyComponent_Native(IntPtr avatar);

		public static ovrAvatarControllerComponent? ovrAvatarPose_GetLeftControllerComponent(IntPtr avatar)
		{
			IntPtr intPtr = ovrAvatarPose_GetLeftControllerComponent_Native(avatar);
			return (!(intPtr == IntPtr.Zero)) ? new ovrAvatarControllerComponent?((ovrAvatarControllerComponent)Marshal.PtrToStructure(intPtr, typeof(ovrAvatarControllerComponent))) : null;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetLeftControllerComponent")]
		private static extern IntPtr ovrAvatarPose_GetLeftControllerComponent_Native(IntPtr avatar);

		public static ovrAvatarControllerComponent? ovrAvatarPose_GetRightControllerComponent(IntPtr avatar)
		{
			IntPtr intPtr = ovrAvatarPose_GetRightControllerComponent_Native(avatar);
			return (!(intPtr == IntPtr.Zero)) ? new ovrAvatarControllerComponent?((ovrAvatarControllerComponent)Marshal.PtrToStructure(intPtr, typeof(ovrAvatarControllerComponent))) : null;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetRightControllerComponent")]
		private static extern IntPtr ovrAvatarPose_GetRightControllerComponent_Native(IntPtr avatar);

		public static ovrAvatarHandComponent? ovrAvatarPose_GetLeftHandComponent(IntPtr avatar)
		{
			IntPtr intPtr = ovrAvatarPose_GetLeftHandComponent_Native(avatar);
			return (!(intPtr == IntPtr.Zero)) ? new ovrAvatarHandComponent?((ovrAvatarHandComponent)Marshal.PtrToStructure(intPtr, typeof(ovrAvatarHandComponent))) : null;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetLeftHandComponent")]
		private static extern IntPtr ovrAvatarPose_GetLeftHandComponent_Native(IntPtr avatar);

		public static ovrAvatarHandComponent? ovrAvatarPose_GetRightHandComponent(IntPtr avatar)
		{
			IntPtr intPtr = ovrAvatarPose_GetRightHandComponent_Native(avatar);
			return (!(intPtr == IntPtr.Zero)) ? new ovrAvatarHandComponent?((ovrAvatarHandComponent)Marshal.PtrToStructure(intPtr, typeof(ovrAvatarHandComponent))) : null;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetRightHandComponent")]
		private static extern IntPtr ovrAvatarPose_GetRightHandComponent_Native(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarAsset_BeginLoading(ulong assetID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarAsset_BeginLoadingLOD(ulong assetId, ovrAvatarAssetLevelOfDetail lod);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarAssetType ovrAvatarAsset_GetType(IntPtr assetHandle);

		public static ovrAvatarMeshAssetData ovrAvatarAsset_GetMeshData(IntPtr assetPtr)
		{
			IntPtr ptr = ovrAvatarAsset_GetMeshData_Native(assetPtr);
			return (ovrAvatarMeshAssetData)Marshal.PtrToStructure(ptr, typeof(ovrAvatarMeshAssetData));
		}

		public static ovrAvatarMeshAssetDataV2 ovrAvatarAsset_GetCombinedMeshData(IntPtr assetPtr)
		{
			IntPtr ptr = ovrAvatarAsset_GetCombinedMeshData_Native(assetPtr);
			return (ovrAvatarMeshAssetDataV2)Marshal.PtrToStructure(ptr, typeof(ovrAvatarMeshAssetDataV2));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetCombinedMeshData")]
		private static extern IntPtr ovrAvatarAsset_GetCombinedMeshData_Native(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetMeshData")]
		private static extern IntPtr ovrAvatarAsset_GetMeshData_Native(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarAsset_GetAvatar(IntPtr assetHandle);

		public static ulong[] ovrAvatarAsset_GetCombinedMeshIDs(IntPtr assetHandle)
		{
			uint num = 0u;
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(num));
			IntPtr ptr = ovrAvatarAsset_GetCombinedMeshIDs_Native(assetHandle, intPtr);
			num = (uint)Marshal.PtrToStructure(intPtr, typeof(uint));
			ulong[] array = new ulong[num];
			for (int i = 0; i < num; i++)
			{
				array[i] = (ulong)Marshal.ReadInt64(ptr, i * Marshal.SizeOf(typeof(ulong)));
			}
			return array;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetCombinedMeshIDs")]
		public static extern IntPtr ovrAvatarAsset_GetCombinedMeshIDs_Native(IntPtr assetHandle, IntPtr count);

		public static void ovrAvatar_GetCombinedMeshAlphaData(IntPtr avatar, ref ulong textureID, ref Vector4 offset)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ulong)));
			IntPtr intPtr2 = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Vector4)));
			ovrAvatar_GetCombinedMeshAlphaData_Native(avatar, intPtr, intPtr2);
			textureID = (ulong)Marshal.PtrToStructure(intPtr, typeof(ulong));
			offset = (Vector4)Marshal.PtrToStructure(intPtr2, typeof(Vector4));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetCombinedMeshAlphaData")]
		public static extern IntPtr ovrAvatar_GetCombinedMeshAlphaData_Native(IntPtr avatar, IntPtr textureIDPtr, IntPtr offsetPtr);

		public static ovrAvatarTextureAssetData ovrAvatarAsset_GetTextureData(IntPtr assetPtr)
		{
			IntPtr ptr = ovrAvatarAsset_GetTextureData_Native(assetPtr);
			return (ovrAvatarTextureAssetData)Marshal.PtrToStructure(ptr, typeof(ovrAvatarTextureAssetData));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetTextureData")]
		private static extern IntPtr ovrAvatarAsset_GetTextureData_Native(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetMaterialData")]
		private static extern IntPtr ovrAvatarAsset_GetMaterialData_Native(IntPtr assetPtr);

		public static ovrAvatarMaterialState ovrAvatarAsset_GetMaterialState(IntPtr assetPtr)
		{
			IntPtr ptr = ovrAvatarAsset_GetMaterialData_Native(assetPtr);
			return (ovrAvatarMaterialState)Marshal.PtrToStructure(ptr, typeof(ovrAvatarMaterialState));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarRenderPartType ovrAvatarRenderPart_GetType(IntPtr renderPart);

		public static ovrAvatarRenderPart_SkinnedMeshRender ovrAvatarRenderPart_GetSkinnedMeshRender(IntPtr renderPart)
		{
			IntPtr ptr = ovrAvatarRenderPart_GetSkinnedMeshRender_Native(renderPart);
			return (ovrAvatarRenderPart_SkinnedMeshRender)Marshal.PtrToStructure(ptr, typeof(ovrAvatarRenderPart_SkinnedMeshRender));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetSkinnedMeshRender")]
		private static extern IntPtr ovrAvatarRenderPart_GetSkinnedMeshRender_Native(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRender_GetTransform(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBS_GetTransform(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBSV2_GetTransform(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarVisibilityFlags ovrAvatarSkinnedMeshRender_GetVisibilityMask(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarSkinnedMeshRender_MaterialStateChanged(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarSkinnedMeshRenderPBSV2_MaterialStateChanged(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarVisibilityFlags ovrAvatarSkinnedMeshRenderPBS_GetVisibilityMask(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarVisibilityFlags ovrAvatarSkinnedMeshRenderPBSV2_GetVisibilityMask(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarMaterialState ovrAvatarSkinnedMeshRender_GetMaterialState(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarPBSMaterialState ovrAvatarSkinnedMeshRenderPBSV2_GetPBSMaterialState(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRender_GetDirtyJoints(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBS_GetDirtyJoints(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBSV2_GetDirtyJoints(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRender_GetJointTransform(IntPtr renderPart, uint jointIndex);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBS_GetJointTransform(IntPtr renderPart, uint jointIndex);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBSV2_GetJointTransform(IntPtr renderPart, uint jointIndex);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBS_GetAlbedoTextureAssetID(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBS_GetSurfaceTextureAssetID(IntPtr renderPart);

		public static ovrAvatarRenderPart_SkinnedMeshRenderPBS ovrAvatarRenderPart_GetSkinnedMeshRenderPBS(IntPtr renderPart)
		{
			IntPtr ptr = ovrAvatarRenderPart_GetSkinnedMeshRenderPBS_Native(renderPart);
			return (ovrAvatarRenderPart_SkinnedMeshRenderPBS)Marshal.PtrToStructure(ptr, typeof(ovrAvatarRenderPart_SkinnedMeshRenderPBS));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetSkinnedMeshRenderPBS")]
		private static extern IntPtr ovrAvatarRenderPart_GetSkinnedMeshRenderPBS_Native(IntPtr renderPart);

		public static ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2 ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2(IntPtr renderPart)
		{
			IntPtr ptr = ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2_Native(renderPart);
			return (ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2)Marshal.PtrToStructure(ptr, typeof(ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2")]
		private static extern IntPtr ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2_Native(IntPtr renderPart);

		public static ovrAvatarRenderPart_ProjectorRender ovrAvatarRenderPart_GetProjectorRender(IntPtr renderPart)
		{
			IntPtr ptr = ovrAvatarRenderPart_GetProjectorRender_Native(renderPart);
			return (ovrAvatarRenderPart_ProjectorRender)Marshal.PtrToStructure(ptr, typeof(ovrAvatarRenderPart_ProjectorRender));
		}

		public static ovrAvatarPBSMaterialState[] ovrAvatar_GetBodyPBSMaterialStates(IntPtr renderPart)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(uint)));
			IntPtr intPtr2 = ovrAvatar_GetBodyPBSMaterialStates_Native(renderPart, intPtr);
			uint num = (uint)Marshal.ReadInt32(intPtr);
			ovrAvatarPBSMaterialState[] array = new ovrAvatarPBSMaterialState[num];
			for (int i = 0; i < array.Length; i++)
			{
				IntPtr ptr = new IntPtr(intPtr2.ToInt64() + i * Marshal.SizeOf(typeof(ovrAvatarPBSMaterialState)));
				ref ovrAvatarPBSMaterialState reference = ref array[i];
				reference = (ovrAvatarPBSMaterialState)Marshal.PtrToStructure(ptr, typeof(ovrAvatarPBSMaterialState));
			}
			return array;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetBodyPBSMaterialStates")]
		private static extern IntPtr ovrAvatar_GetBodyPBSMaterialStates_Native(IntPtr avatar, IntPtr count);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetProjectorRender")]
		private static extern IntPtr ovrAvatarRenderPart_GetProjectorRender_Native(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatar_GetReferencedAssetCount(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatar_GetReferencedAsset(IntPtr avatar, uint index);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftHandGesture(IntPtr avatar, ovrAvatarHandGesture gesture);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightHandGesture(IntPtr avatar, ovrAvatarHandGesture gesture);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftHandCustomGesture(IntPtr avatar, uint jointCount, [In] ovrAvatarTransform[] customJointTransforms);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightHandCustomGesture(IntPtr avatar, uint jointCount, [In] ovrAvatarTransform[] customJointTransforms);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_UpdatePoseFromPacket(IntPtr avatar, IntPtr packet, float secondsFromStart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPacket_BeginRecording(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarPacket_EndRecording(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarPacket_GetSize(IntPtr packet);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrAvatarPacket_GetDurationSeconds(IntPtr packet);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPacket_Free(IntPtr packet);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarPacket_Write(IntPtr packet, uint bufferSize, [Out] byte[] buffer);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarPacket_Read(uint bufferSize, [In] byte[] buffer);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		private static extern void ovrAvatar_SetInternalForceASTCTextures(bool value);

		public static void ovrAvatar_SetForceASTCTextures(bool value)
		{
			ovrAvatar_SetInternalForceASTCTextures(value);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetFallbackLookAndFeelVersion(IntPtr specificationRequest, ovrAvatarLookAndFeelVersion version);
	}
}
public delegate void specificationCallback(IntPtr specification);
public delegate void assetLoadedCallback(OvrAvatarAsset asset);
public delegate void combinedMeshLoadedCallback(IntPtr asset);
public class OvrAvatarSDKManager : MonoBehaviour
{
	private static OvrAvatarSDKManager _instance;

	private Dictionary<ulong, HashSet<specificationCallback>> specificationCallbacks;

	private Dictionary<ulong, HashSet<assetLoadedCallback>> assetLoadedCallbacks;

	private Dictionary<IntPtr, combinedMeshLoadedCallback> combinedMeshLoadedCallbacks;

	private Dictionary<ulong, OvrAvatarAsset> assetCache;

	public static OvrAvatarSDKManager Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = UnityEngine.Object.FindObjectOfType<OvrAvatarSDKManager>();
				if (_instance == null)
				{
					GameObject gameObject = new GameObject("OvrAvatarSDKManager");
					_instance = gameObject.AddComponent<OvrAvatarSDKManager>();
					_instance.Initialize();
				}
			}
			return _instance;
		}
	}

	private void Initialize()
	{
		string text = OvrAvatarSettings.GearAppID;
		if (text == string.Empty)
		{
			text = "0";
		}
		Oculus.Avatar.CAPI.ovrAvatar_InitializeAndroidUnity(text);
		specificationCallbacks = new Dictionary<ulong, HashSet<specificationCallback>>();
		assetLoadedCallbacks = new Dictionary<ulong, HashSet<assetLoadedCallback>>();
		combinedMeshLoadedCallbacks = new Dictionary<IntPtr, combinedMeshLoadedCallback>();
		assetCache = new Dictionary<ulong, OvrAvatarAsset>();
	}

	private void OnDestroy()
	{
		Oculus.Avatar.CAPI.ovrAvatar_Shutdown();
	}

	private void Update()
	{
		IntPtr intPtr = Oculus.Avatar.CAPI.ovrAvatarMessage_Pop();
		if (intPtr == IntPtr.Zero)
		{
			return;
		}
		ovrAvatarMessageType ovrAvatarMessageType2 = Oculus.Avatar.CAPI.ovrAvatarMessage_GetType(intPtr);
		switch (ovrAvatarMessageType2)
		{
		case ovrAvatarMessageType.AssetLoaded:
		{
			ovrAvatarMessage_AssetLoaded ovrAvatarMessage_AssetLoaded2 = Oculus.Avatar.CAPI.ovrAvatarMessage_GetAssetLoaded(intPtr);
			IntPtr asset = ovrAvatarMessage_AssetLoaded2.asset;
			ulong assetID = ovrAvatarMessage_AssetLoaded2.assetID;
			ovrAvatarAssetType ovrAvatarAssetType2 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetType(asset);
			IntPtr key = IntPtr.Zero;
			OvrAvatarAsset ovrAvatarAsset;
			switch (ovrAvatarAssetType2)
			{
			case ovrAvatarAssetType.Mesh:
				ovrAvatarAsset = new OvrAvatarAssetMesh(assetID, asset, ovrAvatarAssetType.Mesh);
				break;
			case ovrAvatarAssetType.Texture:
				ovrAvatarAsset = new OvrAvatarAssetTexture(assetID, asset);
				break;
			case ovrAvatarAssetType.Material:
				ovrAvatarAsset = new OvrAvatarAssetMaterial(assetID, asset);
				break;
			case ovrAvatarAssetType.CombinedMesh:
				key = Oculus.Avatar.CAPI.ovrAvatarAsset_GetAvatar(asset);
				ovrAvatarAsset = new OvrAvatarAssetMesh(assetID, asset, ovrAvatarAssetType.CombinedMesh);
				break;
			default:
				throw new NotImplementedException($"Unsupported asset type format {ovrAvatarAssetType2.ToString()}");
			}
			if (ovrAvatarAssetType2 == ovrAvatarAssetType.CombinedMesh)
			{
				if (!assetCache.ContainsKey(assetID))
				{
					assetCache.Add(assetID, ovrAvatarAsset);
				}
				if (combinedMeshLoadedCallbacks.TryGetValue(key, out var value2))
				{
					value2(asset);
					combinedMeshLoadedCallbacks.Remove(key);
				}
			}
			else
			{
				if (!assetLoadedCallbacks.TryGetValue(ovrAvatarMessage_AssetLoaded2.assetID, out var value3))
				{
					break;
				}
				assetCache.Add(assetID, ovrAvatarAsset);
				foreach (assetLoadedCallback item in value3)
				{
					item(ovrAvatarAsset);
				}
				assetLoadedCallbacks.Remove(ovrAvatarMessage_AssetLoaded2.assetID);
			}
			break;
		}
		case ovrAvatarMessageType.AvatarSpecification:
		{
			ovrAvatarMessage_AvatarSpecification ovrAvatarMessage_AvatarSpecification2 = Oculus.Avatar.CAPI.ovrAvatarMessage_GetAvatarSpecification(intPtr);
			if (!specificationCallbacks.TryGetValue(ovrAvatarMessage_AvatarSpecification2.oculusUserID, out var value))
			{
				break;
			}
			foreach (specificationCallback item2 in value)
			{
				item2(ovrAvatarMessage_AvatarSpecification2.avatarSpec);
			}
			specificationCallbacks.Remove(ovrAvatarMessage_AvatarSpecification2.oculusUserID);
			break;
		}
		default:
			throw new NotImplementedException("Unhandled ovrAvatarMessageType: " + ovrAvatarMessageType2);
		}
		Oculus.Avatar.CAPI.ovrAvatarMessage_Free(intPtr);
	}

	public void RequestAvatarSpecification(ulong userId, specificationCallback callback, bool useCombinedMesh, ovrAvatarAssetLevelOfDetail lod, bool forceMobileTextureFormat)
	{
		Oculus.Avatar.CAPI.ovrAvatar_SetForceASTCTextures(forceMobileTextureFormat);
		if (!specificationCallbacks.TryGetValue(userId, out var value))
		{
			value = new HashSet<specificationCallback>();
			specificationCallbacks.Add(userId, value);
			IntPtr specificationRequest = Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_Create(userId);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetLookAndFeelVersion(specificationRequest, ovrAvatarLookAndFeelVersion.Two);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetFallbackLookAndFeelVersion(specificationRequest, ovrAvatarLookAndFeelVersion.One);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetLevelOfDetail(specificationRequest, lod);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetCombineMeshes(specificationRequest, useCombinedMesh);
			Oculus.Avatar.CAPI.ovrAvatar_RequestAvatarSpecificationFromSpecRequest(specificationRequest);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_Destroy(specificationRequest);
		}
		value.Add(callback);
	}

	public void BeginLoadingAsset(ulong assetId, ovrAvatarAssetLevelOfDetail lod, assetLoadedCallback callback)
	{
		if (!assetLoadedCallbacks.TryGetValue(assetId, out var value))
		{
			value = new HashSet<assetLoadedCallback>();
			assetLoadedCallbacks.Add(assetId, value);
		}
		Oculus.Avatar.CAPI.ovrAvatarAsset_BeginLoadingLOD(assetId, lod);
		value.Add(callback);
	}

	public void RegisterCombinedMeshCallback(IntPtr sdkAvatar, combinedMeshLoadedCallback callback)
	{
		if (!combinedMeshLoadedCallbacks.TryGetValue(sdkAvatar, out var _))
		{
			combinedMeshLoadedCallbacks.Add(sdkAvatar, callback);
			return;
		}
		throw new Exception("Adding second combind mesh callback for same avatar");
	}

	public OvrAvatarAsset GetAsset(ulong assetId)
	{
		if (assetCache.TryGetValue(assetId, out var value))
		{
			return value;
		}
		return null;
	}
}
public sealed class OvrAvatarSettings : ScriptableObject
{
	private static OvrAvatarSettings instance;

	[SerializeField]
	private string ovrAppID = string.Empty;

	[SerializeField]
	private string ovrGearAppID = string.Empty;

	public static string AppID
	{
		get
		{
			return Instance.ovrAppID;
		}
		set
		{
			Instance.ovrAppID = value;
		}
	}

	public static string GearAppID
	{
		get
		{
			return Instance.ovrGearAppID;
		}
		set
		{
			Instance.ovrGearAppID = value;
		}
	}

	public static OvrAvatarSettings Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<OvrAvatarSettings>("OvrAvatarSettings");
				if (instance == null)
				{
					instance = ScriptableObject.CreateInstance<OvrAvatarSettings>();
				}
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}
}
public class OvrAvatarSkinnedMeshRenderComponent : OvrAvatarRenderComponent
{
	private Shader surface;

	private Shader surfaceSelfOccluding;

	private bool previouslyActive;

	internal void Initialize(ovrAvatarRenderPart_SkinnedMeshRender skinnedMeshRender, Shader surface, Shader surfaceSelfOccluding, int thirdPersonLayer, int firstPersonLayer, int sortOrder)
	{
		this.surfaceSelfOccluding = ((!(surfaceSelfOccluding != null)) ? Shader.Find("OvrAvatar/AvatarSurfaceShaderSelfOccluding") : surfaceSelfOccluding);
		this.surface = ((!(surface != null)) ? Shader.Find("OvrAvatar/AvatarSurfaceShader") : surface);
		mesh = CreateSkinnedMesh(skinnedMeshRender.meshAssetID, skinnedMeshRender.visibilityMask, thirdPersonLayer, firstPersonLayer, sortOrder);
		bones = mesh.bones;
		UpdateMeshMaterial(skinnedMeshRender.visibilityMask, mesh);
	}

	public void UpdateSkinnedMeshRender(OvrAvatarComponent component, OvrAvatar avatar, IntPtr renderPart)
	{
		ovrAvatarVisibilityFlags visibilityMask = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetVisibilityMask(renderPart);
		ovrAvatarTransform localTransform = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetTransform(renderPart);
		UpdateSkinnedMesh(avatar, bones, localTransform, visibilityMask, renderPart);
		UpdateMeshMaterial(visibilityMask, mesh);
		bool activeSelf = base.gameObject.activeSelf;
		if (mesh != null && (Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_MaterialStateChanged(renderPart) || (!previouslyActive && activeSelf)))
		{
			ovrAvatarMaterialState matState = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetMaterialState(renderPart);
			component.UpdateAvatarMaterial(mesh.sharedMaterial, matState);
		}
		previouslyActive = activeSelf;
	}

	private void UpdateMeshMaterial(ovrAvatarVisibilityFlags visibilityMask, SkinnedMeshRenderer rootMesh)
	{
		Shader shader = (((visibilityMask & ovrAvatarVisibilityFlags.SelfOccluding) == 0) ? surface : surfaceSelfOccluding);
		if (rootMesh.sharedMaterial == null || rootMesh.sharedMaterial.shader != shader)
		{
			rootMesh.sharedMaterial = CreateAvatarMaterial(base.gameObject.name + "_material", shader);
		}
	}
}
public class OvrAvatarSkinnedMeshRenderPBSComponent : OvrAvatarRenderComponent
{
	internal void Initialize(ovrAvatarRenderPart_SkinnedMeshRenderPBS skinnedMeshRenderPBS, Shader shader, int thirdPersonLayer, int firstPersonLayer, int sortOrder)
	{
		if (shader == null)
		{
			shader = Shader.Find("OvrAvatar/AvatarSurfaceShaderPBS");
		}
		mesh = CreateSkinnedMesh(skinnedMeshRenderPBS.meshAssetID, skinnedMeshRenderPBS.visibilityMask, thirdPersonLayer, firstPersonLayer, sortOrder);
		mesh.sharedMaterial = CreateAvatarMaterial(base.gameObject.name + "_material", shader);
		bones = mesh.bones;
	}

	internal void UpdateSkinnedMeshRenderPBS(OvrAvatar avatar, IntPtr renderPart, Material mat)
	{
		ovrAvatarVisibilityFlags visibilityMask = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetVisibilityMask(renderPart);
		ovrAvatarTransform localTransform = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetTransform(renderPart);
		UpdateSkinnedMesh(avatar, bones, localTransform, visibilityMask, renderPart);
		ulong assetId = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetAlbedoTextureAssetID(renderPart);
		ulong assetId2 = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetSurfaceTextureAssetID(renderPart);
		mat.SetTexture("_Albedo", OvrAvatarComponent.GetLoadedTexture(assetId));
		mat.SetTexture("_Surface", OvrAvatarComponent.GetLoadedTexture(assetId2));
	}
}
public class OvrAvatarSkinnedMeshPBSV2RenderComponent : OvrAvatarRenderComponent
{
	public OvrAvatarMaterialManager AvatarMaterialManager;

	private bool PreviouslyActive;

	private bool IsCombinedMaterial;

	internal void Initialize(IntPtr renderPart, ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2 skinnedMeshRender, OvrAvatarMaterialManager materialManager, int thirdPersonLayer, int firstPersonLayer, int sortOrder, bool isCombinedMaterial, ovrAvatarAssetLevelOfDetail lod)
	{
		AvatarMaterialManager = materialManager;
		IsCombinedMaterial = isCombinedMaterial;
		mesh = CreateSkinnedMesh(skinnedMeshRender.meshAssetID, skinnedMeshRender.visibilityMask, thirdPersonLayer, firstPersonLayer, sortOrder);
		string text = "OvrAvatar/Avatar_Mobile_SingleComponent";
		Shader shader = ((!IsCombinedMaterial) ? Shader.Find(text) : Shader.Find("OvrAvatar/Avatar_Mobile_CombinedMesh"));
		mesh.sharedMaterial = CreateAvatarMaterial(base.gameObject.name + "_material", shader);
		mesh.sharedMaterial.renderQueue = OvrAvatarMaterialManager.RENDER_QUEUE;
		bones = mesh.bones;
		if (IsCombinedMaterial)
		{
			AvatarMaterialManager.SetRenderer(mesh);
			InitializeCombinedMaterial(renderPart, (int)(lod - 1));
			AvatarMaterialManager.OnCombinedMeshReady();
		}
	}

	public void UpdateSkinnedMeshRender(OvrAvatarComponent component, OvrAvatar avatar, IntPtr renderPart)
	{
		ovrAvatarVisibilityFlags visibilityMask = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetVisibilityMask(renderPart);
		ovrAvatarTransform localTransform = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetTransform(renderPart);
		UpdateSkinnedMesh(avatar, bones, localTransform, visibilityMask, renderPart);
		bool activeSelf = base.gameObject.activeSelf;
		if (mesh != null && !PreviouslyActive && activeSelf && !IsCombinedMaterial)
		{
			InitializeSingleComponentMaterial(renderPart, (int)(avatar.LevelOfDetail - 1));
		}
		PreviouslyActive = activeSelf;
	}

	private void InitializeSingleComponentMaterial(IntPtr renderPart, int lodIndex)
	{
		ovrAvatarPBSMaterialState ovrAvatarPBSMaterialState2 = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetPBSMaterialState(renderPart);
		int componentType = (int)OvrAvatarMaterialManager.GetComponentType(base.gameObject.name);
		OvrAvatarMaterialManager.AvatarComponentMaterialProperties[] componentMaterialProperties = AvatarMaterialManager.DefaultAvatarConfig.ComponentMaterialProperties;
		Texture2D texture2D = OvrAvatarComponent.GetLoadedTexture(ovrAvatarPBSMaterialState2.albedoTextureID);
		Texture2D texture2D2 = OvrAvatarComponent.GetLoadedTexture(ovrAvatarPBSMaterialState2.normalTextureID);
		Texture2D texture2D3 = OvrAvatarComponent.GetLoadedTexture(ovrAvatarPBSMaterialState2.metallicnessTextureID);
		if (texture2D == null)
		{
			texture2D = AvatarMaterialManager.DiffuseFallbacks[lodIndex];
		}
		if (texture2D2 == null)
		{
			texture2D2 = AvatarMaterialManager.NormalFallbacks[lodIndex];
		}
		if (texture2D3 == null)
		{
			texture2D3 = AvatarMaterialManager.DiffuseFallbacks[lodIndex];
		}
		mesh.sharedMaterial.SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_MAINTEX, texture2D);
		mesh.sharedMaterial.SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_NORMALMAP, texture2D2);
		mesh.sharedMaterial.SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_ROUGHNESSMAP, texture2D3);
		mesh.sharedMaterial.SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_COLOR, ovrAvatarPBSMaterialState2.albedoMultiplier);
		mesh.sharedMaterial.SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_DIFFUSEINTENSITY, componentMaterialProperties[componentType].DiffuseIntensity);
		mesh.sharedMaterial.SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_RIMINTENSITY, componentMaterialProperties[componentType].RimIntensity);
		mesh.sharedMaterial.SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_BACKLIGHTINTENSITY, componentMaterialProperties[componentType].BacklightIntensity);
		mesh.sharedMaterial.SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_REFLECTIONINTENSITY, componentMaterialProperties[componentType].ReflectionIntensity);
		mesh.GetClosestReflectionProbes(AvatarMaterialManager.ReflectionProbes);
		if (AvatarMaterialManager.ReflectionProbes != null && AvatarMaterialManager.ReflectionProbes.Count > 0)
		{
			mesh.sharedMaterial.SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_CUBEMAP, AvatarMaterialManager.ReflectionProbes[0].probe.texture);
		}
		mesh.sharedMaterial.EnableKeyword("PBR_LIGHTING_ON");
	}

	private void InitializeCombinedMaterial(IntPtr renderPart, int lodIndex)
	{
		ovrAvatarPBSMaterialState[] array = Oculus.Avatar.CAPI.ovrAvatar_GetBodyPBSMaterialStates(renderPart);
		if (array.Length == 5)
		{
			AvatarMaterialManager.CreateTextureArrays();
			AvatarMaterialManager.LocalAvatarConfig = AvatarMaterialManager.DefaultAvatarConfig;
			OvrAvatarMaterialManager.AvatarComponentMaterialProperties[] componentMaterialProperties = AvatarMaterialManager.LocalAvatarConfig.ComponentMaterialProperties;
			for (int i = 0; i < array.Length; i++)
			{
				componentMaterialProperties[i].TypeIndex = (ovrAvatarBodyPartType)i;
				componentMaterialProperties[i].Color = array[i].albedoMultiplier;
				Texture2D loadedTexture = OvrAvatarComponent.GetLoadedTexture(array[i].albedoTextureID);
				Texture2D loadedTexture2 = OvrAvatarComponent.GetLoadedTexture(array[i].normalTextureID);
				Texture2D loadedTexture3 = OvrAvatarComponent.GetLoadedTexture(array[i].metallicnessTextureID);
				componentMaterialProperties[i].Textures[0] = ((!(loadedTexture == null)) ? loadedTexture : AvatarMaterialManager.DiffuseFallbacks[lodIndex]);
				componentMaterialProperties[i].Textures[1] = ((!(loadedTexture2 == null)) ? loadedTexture2 : AvatarMaterialManager.NormalFallbacks[lodIndex]);
				componentMaterialProperties[i].Textures[2] = ((!(loadedTexture3 == null)) ? loadedTexture3 : AvatarMaterialManager.DiffuseFallbacks[lodIndex]);
			}
			AvatarMaterialManager.ValidateTextures();
		}
	}
}
public class OvrAvatarTextureCopyManager : MonoBehaviour
{
	private struct CopyTextureParams
	{
		public Texture Src;

		public Texture Dst;

		public int Mip;

		public int SrcSize;

		public int DstElement;

		public CopyTextureParams(Texture src, Texture dst, int mip, int srcSize, int dstElement)
		{
			Src = src;
			Dst = dst;
			Mip = mip;
			SrcSize = srcSize;
			DstElement = dstElement;
		}
	}

	private const int TEXTURES_TO_COPY_QUEUE_CAPACITY = 256;

	private Queue<CopyTextureParams> texturesToCopy;

	public OvrAvatarTextureCopyManager()
	{
		texturesToCopy = new Queue<CopyTextureParams>(256);
	}

	public void Update()
	{
		if (texturesToCopy.Count != 0)
		{
			CopyTextureParams copyTextureParams;
			lock (texturesToCopy)
			{
				copyTextureParams = texturesToCopy.Dequeue();
			}
			StartCoroutine(CopyTextureCoroutine(copyTextureParams));
		}
	}

	public int GetTextureCount()
	{
		return texturesToCopy.Count;
	}

	public void CopyTexture(Texture src, Texture dst, int mipLevel, int mipSize, int dstElement, bool useQueue = true)
	{
		bool flag = false;
		CopyTextureParams copyTextureParams = new CopyTextureParams(src, dst, mipLevel, mipSize, dstElement);
		if (useQueue)
		{
			lock (texturesToCopy)
			{
				if (texturesToCopy.Count < 256)
				{
					texturesToCopy.Enqueue(copyTextureParams);
					flag = true;
				}
			}
		}
		else
		{
			CopyTexture(copyTextureParams);
		}
		if (!flag)
		{
			CopyTexture(copyTextureParams);
		}
	}

	private IEnumerator CopyTextureCoroutine(CopyTextureParams copyTextureParams)
	{
		yield return new WaitForEndOfFrame();
		Graphics.CopyTexture(copyTextureParams.Src, 0, copyTextureParams.Mip, 0, 0, copyTextureParams.SrcSize, copyTextureParams.SrcSize, copyTextureParams.Dst, copyTextureParams.DstElement, copyTextureParams.Mip, 0, 0);
	}

	private void CopyTexture(CopyTextureParams copyTextureParams)
	{
		Graphics.CopyTexture(copyTextureParams.Src, 0, copyTextureParams.Mip, 0, 0, copyTextureParams.SrcSize, copyTextureParams.SrcSize, copyTextureParams.Dst, copyTextureParams.DstElement, copyTextureParams.Mip, 0, 0);
	}
}
public class OvrAvatarTouchController : MonoBehaviour
{
}
namespace Oculus.Platform.Samples.EntitlementCheck
{
	public class EntitlementCheck : MonoBehaviour
	{
		public bool exitAppOnFailure = true;

		[CompilerGenerated]
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private static Action m_UserFailedEntitlementCheck;

		[CompilerGenerated]
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private static Action m_UserPassedEntitlementCheck;

		public static event Action UserFailedEntitlementCheck
		{
			add
			{
				Action action = EntitlementCheck.m_UserFailedEntitlementCheck;
				Action action2;
				do
				{
					action2 = action;
					action = Interlocked.CompareExchange(ref EntitlementCheck.m_UserFailedEntitlementCheck, (Action)Delegate.Combine(action2, value), action);
				}
				while (action != action2);
			}
			remove
			{
				Action action = EntitlementCheck.m_UserFailedEntitlementCheck;
				Action action2;
				do
				{
					action2 = action;
					action = Interlocked.CompareExchange(ref EntitlementCheck.m_UserFailedEntitlementCheck, (Action)Delegate.Remove(action2, value), action);
				}
				while (action != action2);
			}
		}

		public static event Action UserPassedEntitlementCheck
		{
			add
			{
				Action action = EntitlementCheck.m_UserPassedEntitlementCheck;
				Action action2;
				do
				{
					action2 = action;
					action = Interlocked.CompareExchange(ref EntitlementCheck.m_UserPassedEntitlementCheck, (Action)Delegate.Combine(action2, value), action);
				}
				while (action != action2);
			}
			remove
			{
				Action action = EntitlementCheck.m_UserPassedEntitlementCheck;
				Action action2;
				do
				{
					action2 = action;
					action = Interlocked.CompareExchange(ref EntitlementCheck.m_UserPassedEntitlementCheck, (Action)Delegate.Remove(action2, value), action);
				}
				while (action != action2);
			}
		}

		private void Start()
		{
			try
			{
				if (!Core.IsInitialized())
				{
					Core.Initialize();
				}
				Entitlements.IsUserEntitledToApplication().OnComplete(EntitlementCheckCallback);
			}
			catch
			{
				HandleEntitlementCheckResult(result: false);
			}
		}

		private void EntitlementCheckCallback(Message msg)
		{
			HandleEntitlementCheckResult(!msg.IsError);
		}

		private void HandleEntitlementCheckResult(bool result)
		{
			if (result)
			{
				Debug.Log("Oculus user entitlement check successful.");
				try
				{
					if (EntitlementCheck.UserPassedEntitlementCheck != null)
					{
						EntitlementCheck.UserPassedEntitlementCheck();
					}
					return;
				}
				catch
				{
					Debug.LogError("Suppressed exception in app-provided UserPassedEntitlementCheck() event handler.");
					return;
				}
			}
			try
			{
				if (EntitlementCheck.UserFailedEntitlementCheck != null)
				{
					EntitlementCheck.UserFailedEntitlementCheck();
				}
			}
			catch
			{
				Debug.LogError("Suppressed exception in app-provided UserFailedEntitlementCheck() event handler.");
			}
			if (exitAppOnFailure)
			{
				Debug.LogError("Oculus user entitlement check failed. Exiting now.");
				UnityEngine.Application.Quit();
			}
			else
			{
				Debug.LogError("Oculus user entitlement check failed.");
			}
		}
	}
}
namespace Oculus.Platform.Samples.NetChat
{
	internal enum states
	{
		NOT_INIT,
		IDLE,
		REQUEST_FIND,
		FINDING_ROOM,
		REQUEST_CREATE,
		REQUEST_JOIN,
		REQUEST_LEAVE,
		IN_EMPTY_ROOM,
		IN_FULL_ROOM
	}
	public static class Constants
	{
		public const int BUFFER_SIZE = 512;

		public const string BOUT_POOL = "bout_pool";

		public const string FILTER_POOL = "filter_pool";
	}
	public class chatPacket
	{
		public int packetID { get; set; }

		public string textString { get; set; }

		public byte[] Serialize()
		{
			using MemoryStream memoryStream = new MemoryStream();
			using (BinaryWriter binaryWriter = new BinaryWriter(memoryStream))
			{
				if (textString.Length > 512)
				{
					textString = textString.Substring(0, 511);
				}
				binaryWriter.Write(packetID);
				binaryWriter.Write(textString.ToCharArray());
				binaryWriter.Write('\0');
			}
			return memoryStream.ToArray();
		}

		public static chatPacket Deserialize(byte[] data)
		{
			chatPacket chatPacket2 = new chatPacket();
			using MemoryStream input = new MemoryStream(data);
			using BinaryReader binaryReader = new BinaryReader(input);
			chatPacket2.packetID = binaryReader.ReadInt32();
			chatPacket2.textString = Encoding.Default.GetString(binaryReader.ReadBytes(512));
			return chatPacket2;
		}
	}
	public class DataEntry : MonoBehaviour
	{
		public Text dataOutput;

		private states currentState;

		private User localUser;

		private User remoteUser;

		private Oculus.Platform.Models.Room currentRoom;

		private int lastPacketID;

		private bool ratedMatchStarted;

		private void Start()
		{
			currentState = states.NOT_INIT;
			localUser = null;
			remoteUser = null;
			currentRoom = null;
			lastPacketID = 0;
			ratedMatchStarted = false;
			Core.Initialize();
			Rooms.SetUpdateNotificationCallback(updateRoom);
			Matchmaking.SetMatchFoundNotificationCallback(foundMatch);
			checkEntitlement();
		}

		private void Update()
		{
			string text = GetComponent<InputField>().text;
			if (Input.GetKey(KeyCode.Return))
			{
				if (text != string.Empty)
				{
					SubmitCommand(text);
				}
				GetComponent<InputField>().text = string.Empty;
			}
			processNetPackets();
			Request.RunCallbacks();
		}

		private void SubmitCommand(string command)
		{
			string[] array = command.Split('!');
			if (array.Length <= 0)
			{
				return;
			}
			switch (array[0])
			{
			case "c":
				requestCreateRoom();
				break;
			case "d":
				requestCreateFilterRoom();
				break;
			case "f":
				requestFindMatch();
				break;
			case "g":
				requestFindRoom();
				break;
			case "i":
				requestFindFilteredRoom();
				break;
			case "s":
				if (array.Length > 1)
				{
					sendChat(array[1]);
				}
				break;
			case "l":
				requestLeaveRoom();
				break;
			case "1":
				requestStartRatedMatch();
				break;
			case "2":
				requestReportResults();
				break;
			default:
				printOutputLine("Invalid Command");
				break;
			}
		}

		private void printOutputLine(string newLine)
		{
			dataOutput.text = "> " + newLine + Environment.NewLine + dataOutput.text;
		}

		private void checkEntitlement()
		{
			Entitlements.IsUserEntitledToApplication().OnComplete(getEntitlementCallback);
		}

		private void getEntitlementCallback(Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("You are entitled to use this app.");
				Users.GetLoggedInUser().OnComplete(init);
			}
			else
			{
				printOutputLine("You are NOT entitled to use this app.");
			}
		}

		private void init(Message<User> msg)
		{
			if (!msg.IsError)
			{
				User data = msg.Data;
				localUser = data;
				currentState = states.IDLE;
			}
			else
			{
				printOutputLine("Received get current user error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
				Users.GetLoggedInUser().OnComplete(init);
				currentState = states.NOT_INIT;
			}
		}

		private void requestCreateRoom()
		{
			switch (currentState)
			{
			case states.NOT_INIT:
				printOutputLine("The app has not initialized properly and we don't know your userID.");
				break;
			case states.IDLE:
				printOutputLine("Trying to create a matchmaking room");
				Matchmaking.CreateAndEnqueueRoom("filter_pool", 8u, subscribeToUpdates: true).OnComplete(createRoomResponse);
				currentState = states.REQUEST_CREATE;
				break;
			case states.REQUEST_FIND:
				printOutputLine("You have already made a request to find a room.  Please wait for that request to complete.");
				break;
			case states.FINDING_ROOM:
				printOutputLine("You have already currently looking for a room.  Please wait for the match to be made.");
				break;
			case states.REQUEST_JOIN:
				printOutputLine("We are currently trying to join a room.  Please wait to see if we can join it.");
				break;
			case states.REQUEST_LEAVE:
				printOutputLine("We are currently trying to leave a room.  Please wait to see if we can leave it.");
				break;
			case states.REQUEST_CREATE:
				printOutputLine("You have already requested a matchmaking room to be created.  Please wait for the room to be made.");
				break;
			case states.IN_EMPTY_ROOM:
				printOutputLine("You have already in a matchmaking room.  Please wait for an opponent to join.");
				break;
			case states.IN_FULL_ROOM:
				printOutputLine("You have already in a match.");
				break;
			default:
				printOutputLine("You have hit an unknown state.");
				break;
			}
		}

		private void createRoomResponse(Message<MatchmakingEnqueueResultAndRoom> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received create matchmaking room success");
				printOutputLine("RoomID: " + (currentRoom = msg.Data.Room).ID);
				currentState = states.IN_EMPTY_ROOM;
			}
			else
			{
				printOutputLine("Received create matchmaking room Error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
				printOutputLine("You can only create a matchmaking room for pools of mode Room.  Make sure you have an appropriate pool setup on the Developer portal.\n");
				currentState = states.IDLE;
			}
		}

		private void requestCreateFilterRoom()
		{
			switch (currentState)
			{
			case states.NOT_INIT:
				printOutputLine("The app has not initialized properly and we don't know your userID.\n");
				break;
			case states.IDLE:
			{
				printOutputLine("Trying to create a matchmaking room");
				Matchmaking.CustomQuery customQuery = new Matchmaking.CustomQuery();
				customQuery.criteria = null;
				customQuery.data = new Dictionary<string, object>();
				customQuery.data.Add("game_type_name", "CTF");
				customQuery.data.Add("map_name", "Really_Big_Map");
				Matchmaking.CreateAndEnqueueRoom("filter_pool", 8u, subscribeToUpdates: true, customQuery).OnComplete(createRoomResponse);
				currentState = states.REQUEST_CREATE;
				break;
			}
			case states.REQUEST_FIND:
				printOutputLine("You have already made a request to find a room.  Please wait for that request to complete.\n");
				break;
			case states.FINDING_ROOM:
				printOutputLine("You have already currently looking for a room.  Please wait for the match to be made.\n");
				break;
			case states.REQUEST_JOIN:
				printOutputLine("We are currently trying to join a room.  Please wait to see if we can join it.\n");
				break;
			case states.REQUEST_LEAVE:
				printOutputLine("We are currently trying to leave a room.  Please wait to see if we can leave it.\n");
				break;
			case states.REQUEST_CREATE:
				printOutputLine("You have already requested a matchmaking room to be created.  Please wait for the room to be made.\n");
				break;
			case states.IN_EMPTY_ROOM:
				printOutputLine("You have already in a matchmaking room.  Please wait for an opponent to join.\n");
				break;
			case states.IN_FULL_ROOM:
				printOutputLine("You have already in a match.\n");
				break;
			default:
				printOutputLine("You have hit an unknown state.\n");
				break;
			}
		}

		private void requestFindRoom()
		{
			switch (currentState)
			{
			case states.NOT_INIT:
				printOutputLine("The app has not initialized properly and we don't know your userID.");
				break;
			case states.IDLE:
				printOutputLine("\nTrying to find a matchmaking room\n");
				Matchmaking.Enqueue("filter_pool").OnComplete(searchingStarted);
				currentState = states.REQUEST_FIND;
				break;
			case states.REQUEST_FIND:
				printOutputLine("You have already made a request to find a room.  Please wait for that request to complete.");
				break;
			case states.FINDING_ROOM:
				printOutputLine("You have already currently looking for a room.  Please wait for the match to be made.");
				break;
			case states.REQUEST_JOIN:
				printOutputLine("We are currently trying to join a room.  Please wait to see if we can join it.");
				break;
			case states.REQUEST_LEAVE:
				printOutputLine("We are currently trying to leave a room.  Please wait to see if we can leave it.");
				break;
			case states.REQUEST_CREATE:
				printOutputLine("You have already requested a matchmaking room to be created.  Please wait for the room to be made.");
				break;
			case states.IN_EMPTY_ROOM:
				printOutputLine("You have already in a matchmaking room.  Please wait for an opponent to join.");
				break;
			case states.IN_FULL_ROOM:
				printOutputLine("You have already in a match.");
				break;
			default:
				printOutputLine("You have hit an unknown state.");
				break;
			}
		}

		private void requestFindFilteredRoom()
		{
			switch (currentState)
			{
			case states.NOT_INIT:
				printOutputLine("The app has not initialized properly and we don't know your userID.");
				break;
			case states.IDLE:
			{
				printOutputLine("Trying to find a matchmaking room");
				Matchmaking.CustomQuery customQuery = new Matchmaking.CustomQuery();
				Matchmaking.CustomQuery.Criterion[] array = new Matchmaking.CustomQuery.Criterion[2];
				array[0].key = "map";
				array[0].importance = MatchmakingCriterionImportance.Required;
				array[0].parameters = new Dictionary<string, object>();
				array[0].parameters.Add("map_param_1", "Really_Big_Map");
				array[0].parameters.Add("map_param_2", "Big_Map");
				array[1].key = "game_type";
				array[1].importance = MatchmakingCriterionImportance.Required;
				array[1].parameters = new Dictionary<string, object>();
				array[1].parameters.Add("game_type_param", "CTF");
				customQuery.criteria = array;
				customQuery.data = null;
				Matchmaking.Enqueue("filter_pool", customQuery);
				currentState = states.REQUEST_FIND;
				break;
			}
			case states.REQUEST_FIND:
				printOutputLine("You have already made a request to find a room.  Please wait for that request to complete.");
				break;
			case states.FINDING_ROOM:
				printOutputLine("You have already currently looking for a room.  Please wait for the match to be made.");
				break;
			case states.REQUEST_JOIN:
				printOutputLine("We are currently trying to join a room.  Please wait to see if we can join it.");
				break;
			case states.REQUEST_LEAVE:
				printOutputLine("We are currently trying to leave a room.  Please wait to see if we can leave it.");
				break;
			case states.REQUEST_CREATE:
				printOutputLine("You have already requested a matchmaking room to be created.  Please wait for the room to be made.");
				break;
			case states.IN_EMPTY_ROOM:
				printOutputLine("You have already in a matchmaking room.  Please wait for an opponent to join.");
				break;
			case states.IN_FULL_ROOM:
				printOutputLine("You have already in a match.");
				break;
			default:
				printOutputLine("You have hit an unknown state.");
				break;
			}
		}

		private void foundMatch(Message<Oculus.Platform.Models.Room> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received find match success. We are now going to request to join the room.");
				Oculus.Platform.Models.Room data = msg.Data;
				Rooms.Join(data.ID, subscribeToUpdates: true).OnComplete(joinRoomResponse);
				currentState = states.REQUEST_JOIN;
			}
			else
			{
				printOutputLine("Received find match error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
				currentState = states.IDLE;
			}
		}

		private void joinRoomResponse(Message<Oculus.Platform.Models.Room> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received join room success.");
				currentRoom = msg.Data;
				currentState = states.IN_EMPTY_ROOM;
				if (currentRoom.UsersOptional == null)
				{
					return;
				}
				{
					foreach (User item in currentRoom.UsersOptional)
					{
						if (item.ID != localUser.ID)
						{
							remoteUser = item;
							currentState = states.IN_FULL_ROOM;
						}
					}
					return;
				}
			}
			printOutputLine("Received join room error");
			printOutputLine("It's possible the room filled up before you could join it.");
			Error error = msg.GetError();
			printOutputLine("Error: " + error.Message);
			currentState = states.IDLE;
		}

		private void requestFindMatch()
		{
			switch (currentState)
			{
			case states.NOT_INIT:
				printOutputLine("The app has not initialized properly and we don't know your userID.");
				break;
			case states.IDLE:
				printOutputLine("Trying to find a matchmaking room");
				Matchmaking.Enqueue("bout_pool").OnComplete(searchingStarted);
				currentState = states.REQUEST_FIND;
				break;
			case states.REQUEST_FIND:
				printOutputLine("You have already made a request to find a room.  Please wait for that request to complete.");
				break;
			case states.FINDING_ROOM:
				printOutputLine("You have already currently looking for a room.  Please wait for the match to be made.");
				break;
			case states.REQUEST_JOIN:
				printOutputLine("We are currently trying to join a room.  Please wait to see if we can join it.");
				break;
			case states.REQUEST_LEAVE:
				printOutputLine("We are currently trying to leave a room.  Please wait to see if we can leave it.");
				break;
			case states.REQUEST_CREATE:
				printOutputLine("You have already requested a matchmaking room to be created.  Please wait for the room to be made.");
				break;
			case states.IN_EMPTY_ROOM:
				printOutputLine("You have already in a matchmaking room.  Please wait for an opponent to join.");
				break;
			case states.IN_FULL_ROOM:
				printOutputLine("You have already in a match.");
				break;
			default:
				printOutputLine("You have hit an unknown state.");
				break;
			}
		}

		private void searchingStarted(Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Searching for a match successfully started");
				currentState = states.REQUEST_FIND;
			}
			else
			{
				printOutputLine("Searching for a match error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void updateRoom(Message<Oculus.Platform.Models.Room> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received room update notification");
				Oculus.Platform.Models.Room data = msg.Data;
				if (currentState == states.IN_EMPTY_ROOM)
				{
					if (data.UsersOptional == null)
					{
						return;
					}
					{
						foreach (User item in data.UsersOptional)
						{
							if (item.ID != localUser.ID)
							{
								remoteUser = item;
								currentState = states.IN_FULL_ROOM;
							}
						}
						return;
					}
				}
				if (data.UsersOptional != null && data.UsersOptional.Count == 1)
				{
					printOutputLine("User ID: " + remoteUser.ID + "has left");
					remoteUser = null;
					currentState = states.IN_EMPTY_ROOM;
				}
			}
			else
			{
				printOutputLine("Received room update error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void sendChat(string chatMessage)
		{
			switch (currentState)
			{
			case states.NOT_INIT:
				printOutputLine("The app has not initialized properly and we don't know your userID.");
				break;
			case states.IDLE:
			case states.REQUEST_FIND:
			case states.FINDING_ROOM:
			case states.REQUEST_CREATE:
			case states.REQUEST_JOIN:
			case states.REQUEST_LEAVE:
			case states.IN_EMPTY_ROOM:
				printOutputLine("You need to be in a room with another player to send a message.");
				break;
			case states.IN_FULL_ROOM:
			{
				chatPacket chatPacket2 = new chatPacket();
				lastPacketID++;
				chatPacket2.packetID = lastPacketID;
				chatPacket2.textString = chatMessage;
				Net.SendPacket(remoteUser.ID, chatPacket2.Serialize(), SendPolicy.Reliable);
				break;
			}
			default:
				printOutputLine("You have hit an unknown state.");
				break;
			}
		}

		private void processNetPackets()
		{
			for (Packet packet = Net.ReadPacket(); packet != null; packet = Net.ReadPacket())
			{
				byte[] array = new byte[packet.Size];
				packet.ReadBytes(array);
				chatPacket chatPacket2 = chatPacket.Deserialize(array);
				printOutputLine("Chat Text: " + chatPacket2.textString.ToString());
				printOutputLine("Received Packet from UserID: " + packet.SenderID);
				printOutputLine("Received Packet ID: " + chatPacket2.packetID);
			}
		}

		private void requestLeaveRoom()
		{
			switch (currentState)
			{
			case states.NOT_INIT:
				printOutputLine("The app has not initialized properly and we don't know your userID.");
				break;
			case states.IDLE:
			case states.REQUEST_FIND:
			case states.FINDING_ROOM:
			case states.REQUEST_CREATE:
			case states.REQUEST_JOIN:
				printOutputLine("You are currently not in a room to leave.");
				break;
			case states.REQUEST_LEAVE:
				printOutputLine("We are currently trying to leave a room.  Please wait to see if we can leave it.");
				break;
			case states.IN_EMPTY_ROOM:
			case states.IN_FULL_ROOM:
				printOutputLine("Trying to leave room.");
				Rooms.Leave(currentRoom.ID).OnComplete(leaveRoomResponse);
				break;
			default:
				printOutputLine("You have hit an unknown state.");
				break;
			}
		}

		private void leaveRoomResponse(Message<Oculus.Platform.Models.Room> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("We were able to leave the room");
				currentRoom = null;
				remoteUser = null;
				currentState = states.IDLE;
			}
			else
			{
				printOutputLine("Leave room error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void requestStartRatedMatch()
		{
			switch (currentState)
			{
			case states.NOT_INIT:
				printOutputLine("The app has not initialized properly and we don't know your userID.");
				break;
			case states.IDLE:
			case states.REQUEST_FIND:
			case states.FINDING_ROOM:
			case states.REQUEST_CREATE:
			case states.REQUEST_JOIN:
			case states.REQUEST_LEAVE:
			case states.IN_EMPTY_ROOM:
				printOutputLine("You need to be in a room with another player to start a rated match.");
				break;
			case states.IN_FULL_ROOM:
				printOutputLine("Trying to start a rated match.  This call should be made once a rated match begins so we will be able to submit results after the game is done.");
				Matchmaking.StartMatch(currentRoom.ID).OnComplete(startRatedMatchResponse);
				break;
			default:
				printOutputLine("You have hit an unknown state.");
				break;
			}
		}

		private void startRatedMatchResponse(Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Started a rated match");
				ratedMatchStarted = true;
			}
			else
			{
				Error error = msg.GetError();
				printOutputLine("Received starting rated match failure: " + error.Message);
				printOutputLine("Your matchmaking pool needs to have a skill pool associated with it to play rated matches");
			}
		}

		private void requestReportResults()
		{
			switch (currentState)
			{
			case states.NOT_INIT:
				printOutputLine("The app has not initialized properly and we don't know your userID.");
				break;
			case states.IDLE:
			case states.REQUEST_FIND:
			case states.FINDING_ROOM:
			case states.REQUEST_CREATE:
			case states.REQUEST_JOIN:
			case states.REQUEST_LEAVE:
				printOutputLine("You need to be in a room with another player to report results on a rated match.");
				break;
			case states.IN_EMPTY_ROOM:
			case states.IN_FULL_ROOM:
				if (ratedMatchStarted)
				{
					printOutputLine("Submitting rated match results.");
					Dictionary<string, int> dictionary = new Dictionary<string, int>();
					dictionary.Add(localUser.ID.ToString(), 1);
					dictionary.Add(remoteUser.ID.ToString(), 2);
					Matchmaking.ReportResultsInsecure(currentRoom.ID, dictionary).OnComplete(reportResultsResponse);
				}
				else
				{
					printOutputLine("You can't report results unless you've already started a rated match");
				}
				break;
			default:
				printOutputLine("You have hit an unknown state.");
				break;
			}
		}

		private void reportResultsResponse(Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Rated match results reported. Now attempting to leave room.");
				ratedMatchStarted = false;
				requestLeaveRoom();
			}
			else
			{
				Error error = msg.GetError();
				printOutputLine("Received reporting rated match failure: " + error.Message);
			}
		}
	}
}
namespace Oculus.Platform.Samples.SimplePlatformSample
{
	public class DataEntry : MonoBehaviour
	{
		public Text dataOutput;

		private void Start()
		{
			Core.Initialize();
			checkEntitlement();
		}

		private void Update()
		{
			string text = GetComponent<InputField>().text;
			if (Input.GetKey(KeyCode.Return))
			{
				if (text != string.Empty)
				{
					SubmitCommand(text);
				}
				GetComponent<InputField>().text = string.Empty;
			}
			Request.RunCallbacks();
		}

		private void SubmitCommand(string command)
		{
			string[] array = command.Split(' ');
			if (array.Length <= 0)
			{
				return;
			}
			switch (array[0])
			{
			case "p":
				if (array.Length > 2)
				{
					createAndJoinPrivateRoom(array[1], array[2]);
				}
				break;
			case "c":
				getCurrentRoom();
				break;
			case "g":
				if (array.Length > 1)
				{
					getRoom(array[1]);
				}
				break;
			case "j":
				if (array.Length > 1)
				{
					joinRoom(array[1]);
				}
				break;
			case "l":
				if (array.Length > 1)
				{
					leaveRoom(array[1]);
				}
				break;
			case "k":
				if (array.Length > 2)
				{
					kickUser(array[1], array[2]);
				}
				break;
			case "m":
				getLoggedInUser();
				break;
			case "u":
				if (array.Length > 1)
				{
					getUser(array[1]);
				}
				break;
			case "d":
				getLoggedInFriends();
				break;
			case "i":
				getInvitableUsers();
				break;
			case "o":
				if (array.Length > 2)
				{
					inviteUser(array[1], array[2]);
				}
				break;
			case "s":
				if (array.Length > 2)
				{
					setRoomDescription(array[1], array[2]);
				}
				break;
			case "w":
				if (array.Length > 3)
				{
					updateRoomDataStore(array[1], array[2], array[3]);
				}
				break;
			case "n":
				getUserNonce();
				break;
			case "e":
				checkEntitlement();
				break;
			case "a":
				if (array.Length > 1)
				{
					getAchievementDefinition(array[1]);
				}
				break;
			case "b":
				if (array.Length > 1)
				{
					getAchievementProgress(array[1]);
				}
				break;
			case "3":
				if (array.Length > 1)
				{
					unlockAchievement(array[1]);
				}
				break;
			case "4":
				if (array.Length > 2)
				{
					addCountAchievement(array[1], array[2]);
				}
				break;
			case "5":
				if (array.Length > 2)
				{
					addFieldsAchievement(array[1], array[2]);
				}
				break;
			case "1":
				if (array.Length > 2)
				{
					writeLeaderboardEntry(array[1], array[2]);
				}
				break;
			case "2":
				if (array.Length > 1)
				{
					getLeaderboardEntries(array[1]);
				}
				break;
			default:
				printOutputLine("Invalid Command");
				break;
			}
		}

		private void getLeaderboardEntries(string leaderboardName)
		{
			Leaderboards.GetEntries(leaderboardName, 10, LeaderboardFilterType.None, LeaderboardStartAt.Top).OnComplete(leaderboardGetCallback);
		}

		private void writeLeaderboardEntry(string leaderboardName, string value)
		{
			byte[] extraData = new byte[4] { 84, 101, 115, 116 };
			Leaderboards.WriteEntry(leaderboardName, Convert.ToInt32(value), extraData).OnComplete(leaderboardWriteCallback);
		}

		private void addFieldsAchievement(string achievementName, string fields)
		{
			Achievements.AddFields(achievementName, fields).OnComplete(achievementFieldsCallback);
		}

		private void addCountAchievement(string achievementName, string count)
		{
			Achievements.AddCount(achievementName, Convert.ToUInt64(count)).OnComplete(achievementCountCallback);
		}

		private void unlockAchievement(string achievementName)
		{
			Achievements.Unlock(achievementName).OnComplete(achievementUnlockCallback);
		}

		private void getAchievementProgress(string achievementName)
		{
			Achievements.GetProgressByName(new string[1] { achievementName }).OnComplete(achievementProgressCallback);
		}

		private void getAchievementDefinition(string achievementName)
		{
			Achievements.GetDefinitionsByName(new string[1] { achievementName }).OnComplete(achievementDefinitionCallback);
		}

		private void checkEntitlement()
		{
			Entitlements.IsUserEntitledToApplication().OnComplete(getEntitlementCallback);
		}

		private void getUserNonce()
		{
			printOutputLine("Trying to get user nonce");
			Users.GetUserProof().OnComplete(userProofCallback);
		}

		private void createAndJoinPrivateRoom(string joinPolicy, string maxUsers)
		{
			printOutputLine("Trying to create and join private room");
			Rooms.CreateAndJoinPrivate((RoomJoinPolicy)Convert.ToUInt32(joinPolicy), Convert.ToUInt32(maxUsers)).OnComplete(createAndJoinPrivateRoomCallback);
		}

		private void getCurrentRoom()
		{
			printOutputLine("Trying to get current room");
			Rooms.GetCurrent().OnComplete(getCurrentRoomCallback);
		}

		private void getRoom(string roomID)
		{
			printOutputLine("Trying to get room " + roomID);
			Rooms.Get(Convert.ToUInt64(roomID)).OnComplete(getCurrentRoomCallback);
		}

		private void joinRoom(string roomID)
		{
			printOutputLine("Trying to join room " + roomID);
			Rooms.Join(Convert.ToUInt64(roomID), subscribeToUpdates: true).OnComplete(joinRoomCallback);
		}

		private void leaveRoom(string roomID)
		{
			printOutputLine("Trying to leave room " + roomID);
			Rooms.Leave(Convert.ToUInt64(roomID)).OnComplete(leaveRoomCallback);
		}

		private void kickUser(string roomID, string userID)
		{
			printOutputLine("Trying to kick user " + userID + " from room " + roomID);
			Rooms.KickUser(Convert.ToUInt64(roomID), Convert.ToUInt64(userID), 10).OnComplete(getCurrentRoomCallback);
		}

		private void getLoggedInUser()
		{
			printOutputLine("Trying to get currently logged in user");
			Users.GetLoggedInUser().OnComplete(getUserCallback);
		}

		private void getUser(string userID)
		{
			printOutputLine("Trying to get user " + userID);
			Users.Get(Convert.ToUInt64(userID)).OnComplete(getUserCallback);
		}

		private void getLoggedInFriends()
		{
			printOutputLine("Trying to get friends of logged in user");
			Users.GetLoggedInUserFriends().OnComplete(getFriendsCallback);
		}

		private void getInvitableUsers()
		{
			printOutputLine("Trying to get invitable users");
			Rooms.GetInvitableUsers().OnComplete(getInvitableUsersCallback);
		}

		private void inviteUser(string roomID, string inviteToken)
		{
			printOutputLine("Trying to invite token " + inviteToken + " to room " + roomID);
			Rooms.InviteUser(Convert.ToUInt64(roomID), inviteToken).OnComplete(inviteUserCallback);
		}

		private void setRoomDescription(string roomID, string description)
		{
			printOutputLine("Trying to set description " + description + " to room " + roomID);
			Rooms.SetDescription(Convert.ToUInt64(roomID), description).OnComplete(getCurrentRoomCallback);
		}

		private void updateRoomDataStore(string roomID, string key, string value)
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			dictionary.Add(key, value);
			printOutputLine("Trying to set k=" + key + " v=" + value + " for room " + roomID);
			Rooms.UpdateDataStore(Convert.ToUInt64(roomID), dictionary).OnComplete(getCurrentRoomCallback);
		}

		private void printOutputLine(string newLine)
		{
			dataOutput.text = "> " + newLine + Environment.NewLine + dataOutput.text;
		}

		private void outputRoomDetails(Oculus.Platform.Models.Room room)
		{
			printOutputLine("Room ID: " + room.ID + ", AppID: " + room.ApplicationID + ", Description: " + room.Description);
			int num = ((room.UsersOptional != null) ? room.UsersOptional.Count : 0);
			printOutputLine("MaxUsers: " + room.MaxUsers.ToString() + " Users in room: " + num);
			if (room.OwnerOptional != null)
			{
				printOutputLine("Room owner: " + room.OwnerOptional.ID + " " + room.OwnerOptional.OculusID);
			}
			printOutputLine("Join Policy: " + room.JoinPolicy);
			printOutputLine("Room Type: " + room.Type);
			Message.MessageType.Matchmaking_Enqueue.GetHashCode();
		}

		private void outputUserArray(UserList users)
		{
			foreach (User user in users)
			{
				printOutputLine("User: " + user.ID + " " + user.OculusID + " " + user.Presence + " " + user.InviteToken);
			}
		}

		private void userProofCallback(Message<UserProof> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received user nonce generation success");
				UserProof data = msg.Data;
				printOutputLine("Nonce: " + data.Value);
			}
			else
			{
				printOutputLine("Received user nonce generation error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void getEntitlementCallback(Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("You are entitled to use this app.");
			}
			else
			{
				printOutputLine("You are NOT entitled to use this app.");
			}
		}

		private void leaderboardGetCallback(Message<LeaderboardEntryList> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Leaderboard entry get success.");
				LeaderboardEntryList data = msg.Data;
				{
					foreach (LeaderboardEntry item in data)
					{
						printOutputLine(item.Rank + ". " + item.User.OculusID + " " + item.Score + " " + item.Timestamp);
					}
					return;
				}
			}
			printOutputLine("Received leaderboard get error");
			Error error = msg.GetError();
			printOutputLine("Error: " + error.Message);
		}

		private void leaderboardWriteCallback(Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Leaderboard entry write success.");
				Message<bool> message = (Message<bool>)msg;
				if (message.Data)
				{
					printOutputLine("Score updated.");
				}
				else
				{
					printOutputLine("Score NOT updated.");
				}
			}
			else
			{
				printOutputLine("Received leaderboard write error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void achievementFieldsCallback(Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Achievement fields added.");
				return;
			}
			printOutputLine("Received achievement fields add error");
			Error error = msg.GetError();
			printOutputLine("Error: " + error.Message);
		}

		private void achievementCountCallback(Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Achievement count added.");
				return;
			}
			printOutputLine("Received achievement count add error");
			Error error = msg.GetError();
			printOutputLine("Error: " + error.Message);
		}

		private void achievementUnlockCallback(Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Achievement unlocked");
				return;
			}
			printOutputLine("Received achievement unlock error");
			Error error = msg.GetError();
			printOutputLine("Error: " + error.Message);
		}

		private void achievementProgressCallback(Message<AchievementProgressList> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received achievement progress success");
				AchievementProgressList achievementProgressList = msg.GetAchievementProgressList();
				{
					foreach (AchievementProgress item in achievementProgressList)
					{
						if (item.IsUnlocked)
						{
							printOutputLine("Achievement Unlocked");
						}
						else
						{
							printOutputLine("Achievement Locked");
						}
						printOutputLine("Current Bitfield: " + item.Bitfield.ToString());
						printOutputLine("Current Count: " + item.Count);
					}
					return;
				}
			}
			printOutputLine("Received achievement progress error");
			Error error = msg.GetError();
			printOutputLine("Error: " + error.Message);
		}

		private void achievementDefinitionCallback(Message<AchievementDefinitionList> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received achievement definitions success");
				AchievementDefinitionList achievementDefinitions = msg.GetAchievementDefinitions();
				{
					foreach (AchievementDefinition item in achievementDefinitions)
					{
						switch (item.Type)
						{
						case AchievementType.Simple:
							printOutputLine("Achievement Type: Simple");
							break;
						case AchievementType.Bitfield:
							printOutputLine("Achievement Type: Bitfield");
							printOutputLine("Bitfield Length: " + item.BitfieldLength);
							printOutputLine("Target: " + item.Target);
							break;
						case AchievementType.Count:
							printOutputLine("Achievement Type: Count");
							printOutputLine("Target: " + item.Target);
							break;
						default:
							printOutputLine("Achievement Type: Unknown");
							break;
						}
					}
					return;
				}
			}
			printOutputLine("Received achievement definitions error");
			Error error = msg.GetError();
			printOutputLine("Error: " + error.Message);
		}

		private void createAndJoinPrivateRoomCallback(Message<Oculus.Platform.Models.Room> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received create and join room success");
				outputRoomDetails(msg.Data);
			}
			else
			{
				printOutputLine("Received create and join room error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void getCurrentRoomCallback(Message<Oculus.Platform.Models.Room> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received get room success");
				outputRoomDetails(msg.Data);
			}
			else
			{
				printOutputLine("Received get room error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void joinRoomCallback(Message<Oculus.Platform.Models.Room> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received join room success");
				outputRoomDetails(msg.Data);
			}
			else
			{
				printOutputLine("Received join room error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void leaveRoomCallback(Message<Oculus.Platform.Models.Room> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received leave room success");
				outputRoomDetails(msg.Data);
			}
			else
			{
				printOutputLine("Received leave room error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void getUserCallback(Message<User> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received get user success");
				User data = msg.Data;
				printOutputLine("User: " + data.ID + " " + data.OculusID + " " + data.Presence + " " + data.InviteToken);
			}
			else
			{
				printOutputLine("Received get user error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void getFriendsCallback(Message<UserList> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received get friends success");
				UserList data = msg.Data;
				outputUserArray(data);
			}
			else
			{
				printOutputLine("Received get friends error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void getInvitableUsersCallback(Message<UserList> msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received get invitable users success");
				UserList data = msg.Data;
				outputUserArray(data);
			}
			else
			{
				printOutputLine("Received get invitable users error");
				Error error = msg.GetError();
				printOutputLine("Error: " + error.Message);
			}
		}

		private void inviteUserCallback(Message msg)
		{
			if (!msg.IsError)
			{
				printOutputLine("Received invite user success");
				return;
			}
			printOutputLine("Received invite user error");
			Error error = msg.GetError();
			printOutputLine("Error: " + error.Message);
		}
	}
}
namespace Oculus.Platform.Samples.VrBoardGame
{
	public class BoardPosition : MonoBehaviour
	{
		[SerializeField]
		[Range(0f, 2f)]
		public int x;

		[SerializeField]
		[Range(0f, 2f)]
		public int y;
	}
	public class EyeCamera : MonoBehaviour
	{
		[SerializeField]
		private EventSystem m_eventSystem;

		[SerializeField]
		private GameController m_gameController;

		[SerializeField]
		private SphereCollider m_gazeTracker;

		private Button m_currentButton;

		private GamePiece m_currentPiece;

		private BoardPosition m_boardPosition;

		private void Update()
		{
			Button button = null;
			GamePiece gamePiece = null;
			BoardPosition boardPosition = null;
			if (Physics.Raycast(base.transform.position, base.transform.forward, out var hitInfo, 50f))
			{
				button = hitInfo.collider.GetComponent<Button>();
				gamePiece = hitInfo.collider.GetComponent<GamePiece>();
				boardPosition = hitInfo.collider.GetComponent<BoardPosition>();
			}
			if (m_currentButton != button)
			{
				if (m_eventSystem != null)
				{
					m_eventSystem.SetSelectedGameObject(null);
				}
				m_currentButton = button;
				if (m_currentButton != null)
				{
					m_currentButton.Select();
				}
			}
			if (m_currentPiece != gamePiece)
			{
				if (m_currentPiece != null)
				{
					m_gameController.StoppedLookingAtPiece();
				}
				m_currentPiece = gamePiece;
				if (m_currentPiece != null)
				{
					m_gameController.StartedLookingAtPiece(m_currentPiece);
				}
			}
			if (m_boardPosition != boardPosition)
			{
				m_boardPosition = boardPosition;
				if (m_boardPosition != null)
				{
					m_gameController.StartedLookingAtPosition(m_boardPosition);
				}
			}
			if (hitInfo.collider == m_gazeTracker)
			{
				m_gameController.ClearProposedMove();
			}
			if (Input.GetButton("Fire2"))
			{
				float axis = Input.GetAxis("Mouse Y");
				float axis2 = Input.GetAxis("Mouse X");
				base.transform.rotation *= Quaternion.AngleAxis(axis2, Vector3.up);
				base.transform.rotation *= Quaternion.AngleAxis(0f - axis, Vector3.right);
				Vector3 eulerAngles = base.transform.eulerAngles;
				eulerAngles.z = 0f;
				base.transform.eulerAngles = eulerAngles;
			}
		}
	}
	public class GameBoard : MonoBehaviour
	{
		private struct PositionInfo
		{
			public GameObject piece;

			public int pieceOwner;

			public int powerPieceOwner;
		}

		public const int LENGTH_X = 3;

		public const int LENGTH_Y = 3;

		public const int MAX_PLAYERS = 2;

		[SerializeField]
		private Color[] m_playerColors = new Color[2];

		[SerializeField]
		private Color m_proposedMoveColor;

		private int[] m_scores = new int[2];

		[SerializeField]
		private BoardPosition[] m_positions = new BoardPosition[9];

		private readonly PositionInfo[,] m_pieces = new PositionInfo[3, 3];

		public void Reset()
		{
			for (int i = 0; i < 3; i++)
			{
				for (int j = 0; j < 3; j++)
				{
					if (m_pieces[i, j].piece != null)
					{
						UnityEngine.Object.Destroy(m_pieces[i, j].piece);
						m_pieces[i, j].piece = null;
						m_pieces[i, j].pieceOwner = -1;
						m_pieces[i, j].powerPieceOwner = -1;
					}
				}
			}
		}

		public bool IsFull()
		{
			for (int i = 0; i < 3; i++)
			{
				for (int j = 0; j < 3; j++)
				{
					if (m_pieces[i, j].piece == null)
					{
						return false;
					}
				}
			}
			return true;
		}

		public bool CanPlayerMoveToPostion(int x, int y)
		{
			return m_pieces[x, y].piece == null;
		}

		public bool CanPlayerPowerUpPosition(int x, int y)
		{
			return m_pieces[x, y].piece != null;
		}

		public void AddPiece(int player, GameObject prefab, int x, int y)
		{
			BoardPosition boardPosition = m_positions[x * 3 + y];
			GamePiece gamePiece = Create(prefab, boardPosition.gameObject, boardPosition, Vector3.zero);
			gamePiece.GetComponent<Renderer>().material.color = m_playerColors[player];
			m_pieces[x, y].piece = gamePiece.gameObject;
			m_pieces[x, y].pieceOwner = player;
			m_pieces[x, y].powerPieceOwner = -1;
			UpdateScores();
		}

		public GamePiece AddProposedPiece(GameObject prefab, BoardPosition pos)
		{
			GamePiece gamePiece = Create(prefab, pos.gameObject, pos, Vector3.zero);
			gamePiece.GetComponent<Renderer>().material.color = m_proposedMoveColor;
			return gamePiece;
		}

		public void AddPowerPiece(int player, GameObject prefab, int x, int y)
		{
			GamePiece gamePiece = Create(prefab, m_pieces[x, y].piece, m_positions[x * 3 + y], 0.2f * Vector3.up);
			gamePiece.GetComponent<Renderer>().material.color = m_playerColors[player];
			m_pieces[x, y].powerPieceOwner = player;
			UpdateScores();
		}

		public GamePiece AddProposedPowerPiece(GameObject prefab, BoardPosition pos)
		{
			GamePiece gamePiece = Create(prefab, m_pieces[pos.x, pos.y].piece, pos, 0.2f * Vector3.up);
			gamePiece.GetComponent<Renderer>().material.color = m_proposedMoveColor;
			return gamePiece;
		}

		private GamePiece Create(GameObject prefab, GameObject parent, BoardPosition pos, Vector3 off)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(prefab, parent.transform);
			gameObject.transform.position = parent.transform.position + off;
			gameObject.GetComponent<GamePiece>().Position = pos;
			return gameObject.GetComponent<GamePiece>();
		}

		public int GetPlayerScore(int player)
		{
			return m_scores[player];
		}

		private void UpdateScores()
		{
			for (int i = 0; i < 2; i++)
			{
				m_scores[i] = 0;
			}
			for (int j = 0; j < 3; j++)
			{
				for (int k = 0; k < 3; k++)
				{
					if (!(m_pieces[j, k].piece != null))
					{
						continue;
					}
					m_scores[m_pieces[j, k].pieceOwner] += 10;
					if (m_pieces[j, k].powerPieceOwner < 0)
					{
						continue;
					}
					for (int l = j - 1; l <= j + 1; l++)
					{
						for (int m = k - 1; m <= k + 1; m++)
						{
							if (l >= 0 && m >= 0 && l < 3 && m < 3)
							{
								int num = ((m_pieces[j, k].pieceOwner != m_pieces[j, k].powerPieceOwner) ? (-10) : 10);
								m_scores[m_pieces[j, k].powerPieceOwner] += num;
							}
						}
					}
				}
			}
		}
	}
	public class GameController : MonoBehaviour
	{
		private enum GameState
		{
			None,
			PracticingMyTurn,
			PracticingAiTurn,
			OnlineMatchMyTurn,
			OnlineMatchRemoteTurn
		}

		[SerializeField]
		private MatchmakingManager m_matchmaking;

		[SerializeField]
		private GameBoard m_board;

		[SerializeField]
		private GamePiece m_pieceA;

		[SerializeField]
		private GamePiece m_pieceB;

		[SerializeField]
		private GamePiece m_powerPiece;

		[SerializeField]
		private Color m_unusableColor;

		[SerializeField]
		private Color m_unselectedColor;

		[SerializeField]
		private Color m_selectedColor;

		[SerializeField]
		private Color m_highlightedColor;

		[SerializeField]
		private Text m_ballCountText;

		[SerializeField]
		private Text m_player0Text;

		[SerializeField]
		private Text m_player1Text;

		private GameState m_state;

		private GamePiece m_interestedPiece;

		private GamePiece m_selectedPiece;

		private GamePiece m_proposedPiece;

		private uint m_powerBallcount;

		private string m_opponentName;

		private void Start()
		{
			TransitionToState(GameState.None);
			UpdateScores();
		}

		private void Update()
		{
			PerFrameStateUpdate();
		}

		private void TransitionToState(GameState state)
		{
			m_state = state;
			UpdateGamePieceColors();
		}

		private void TransitionToNextState()
		{
			if (!m_board.IsFull())
			{
				switch (m_state)
				{
				case GameState.PracticingAiTurn:
					TransitionToState(GameState.PracticingMyTurn);
					break;
				case GameState.PracticingMyTurn:
					TransitionToState(GameState.PracticingAiTurn);
					break;
				case GameState.OnlineMatchRemoteTurn:
					TransitionToState(GameState.OnlineMatchMyTurn);
					break;
				case GameState.OnlineMatchMyTurn:
					TransitionToState(GameState.OnlineMatchRemoteTurn);
					break;
				}
			}
			else
			{
				GameState state = m_state;
				if (state == GameState.OnlineMatchRemoteTurn || state == GameState.OnlineMatchMyTurn)
				{
					m_matchmaking.EndMatch(m_board.GetPlayerScore(0), m_board.GetPlayerScore(1));
				}
				TransitionToState(GameState.None);
			}
		}

		private void PerFrameStateUpdate()
		{
			switch (m_state)
			{
			case GameState.PracticingAiTurn:
				if (UnityEngine.Random.Range(1, 100) < 3)
				{
					MakeAIMove(1);
				}
				break;
			case GameState.PracticingMyTurn:
			case GameState.OnlineMatchMyTurn:
				if (Input.GetButton("Fire1"))
				{
					TrySelectPiece();
					TryPlacePiece();
				}
				break;
			}
		}

		public void PracticeButtonPressed()
		{
			m_opponentName = "* AI *";
			GameState state = m_state;
			if (state == GameState.OnlineMatchMyTurn || state == GameState.OnlineMatchRemoteTurn)
			{
				m_matchmaking.EndMatch(m_board.GetPlayerScore(0), m_board.GetPlayerScore(1));
			}
			m_board.Reset();
			if (UnityEngine.Random.Range(0, 2) == 1)
			{
				TransitionToState(GameState.PracticingMyTurn);
			}
			else
			{
				TransitionToState(GameState.PracticingAiTurn);
			}
			UpdateScores();
		}

		private void MakeAIMove(int player)
		{
			bool flag = false;
			int num = UnityEngine.Random.Range(0, 2);
			int num2 = UnityEngine.Random.Range(0, 2);
			for (int i = 0; i < 3; i++)
			{
				if (flag)
				{
					break;
				}
				for (int j = 0; j < 3; j++)
				{
					if (flag)
					{
						break;
					}
					int x = (num + i) % 3;
					int y = (num2 + j) % 3;
					if (m_board.CanPlayerMoveToPostion(x, y))
					{
						GamePiece gamePiece = ((UnityEngine.Random.Range(0, 2) != 0) ? m_pieceB : m_pieceA);
						m_board.AddPiece(player, gamePiece.Prefab, x, y);
						flag = true;
					}
					else if (m_board.CanPlayerPowerUpPosition(x, y) && UnityEngine.Random.Range(0, 8) < 2)
					{
						m_board.AddPowerPiece(player, m_powerPiece.Prefab, x, y);
						flag = true;
					}
				}
			}
			if (flag)
			{
				UpdateScores();
				TransitionToNextState();
			}
		}

		public void StartOnlineMatch(string opponentName, bool localUserGoesFirst)
		{
			m_board.Reset();
			m_opponentName = opponentName;
			if (localUserGoesFirst)
			{
				TransitionToState(GameState.OnlineMatchMyTurn);
			}
			else
			{
				TransitionToState(GameState.OnlineMatchRemoteTurn);
			}
			UpdateScores();
		}

		public void MakeRemoteMove(GamePiece.Piece piece, int x, int y)
		{
			GameObject prefab = m_pieceA.PrefabFor(piece);
			if (piece == GamePiece.Piece.PowerBall)
			{
				m_board.AddPowerPiece(1, prefab, x, y);
			}
			else
			{
				m_board.AddPiece(1, prefab, x, y);
			}
			UpdateScores();
		}

		public void MarkRemoteTurnComplete()
		{
			if (m_state == GameState.OnlineMatchRemoteTurn)
			{
				TransitionToNextState();
			}
		}

		public void RemoteMatchEnded()
		{
			m_matchmaking.EndMatch(m_board.GetPlayerScore(0), m_board.GetPlayerScore(1));
		}

		public void StartedLookingAtPiece(GamePiece piece)
		{
			m_interestedPiece = piece;
			UpdateGamePieceColors();
		}

		public void StoppedLookingAtPiece()
		{
			m_interestedPiece = null;
			UpdateGamePieceColors();
		}

		public void StartedLookingAtPosition(BoardPosition position)
		{
			if (m_state != GameState.OnlineMatchMyTurn && m_state != GameState.PracticingMyTurn)
			{
				return;
			}
			GamePiece gamePiece = null;
			if ((m_selectedPiece == m_pieceA || m_selectedPiece == m_pieceB) && m_board.CanPlayerMoveToPostion(position.x, position.y))
			{
				gamePiece = m_board.AddProposedPiece(m_selectedPiece.Prefab, position);
			}
			else if (m_selectedPiece == m_powerPiece && m_board.CanPlayerPowerUpPosition(position.x, position.y))
			{
				gamePiece = m_board.AddProposedPowerPiece(m_selectedPiece.Prefab, position);
			}
			if (gamePiece != null)
			{
				if (m_proposedPiece != null)
				{
					UnityEngine.Object.Destroy(m_proposedPiece.gameObject);
				}
				m_proposedPiece = gamePiece;
			}
		}

		public void ClearProposedMove()
		{
			if (m_proposedPiece != null)
			{
				UnityEngine.Object.Destroy(m_proposedPiece.gameObject);
			}
		}

		public void TrySelectPiece()
		{
			if (m_interestedPiece == m_pieceA || m_interestedPiece == m_pieceB)
			{
				m_selectedPiece = m_interestedPiece;
			}
			else if (m_interestedPiece == m_powerPiece && (m_powerBallcount != 0 || m_state == GameState.PracticingMyTurn))
			{
				m_selectedPiece = m_interestedPiece;
			}
			UpdateGamePieceColors();
		}

		public void TryPlacePiece()
		{
			if (!(m_proposedPiece == null))
			{
				BoardPosition position = m_proposedPiece.Position;
				switch (m_proposedPiece.Type)
				{
				case GamePiece.Piece.A:
				case GamePiece.Piece.B:
					m_board.AddPiece(0, m_proposedPiece.Prefab, position.x, position.y);
					break;
				case GamePiece.Piece.PowerBall:
					m_board.AddPowerPiece(0, m_proposedPiece.Prefab, position.x, position.y);
					break;
				}
				UnityEngine.Object.Destroy(m_proposedPiece.gameObject);
				if (m_state == GameState.OnlineMatchMyTurn)
				{
					m_matchmaking.SendLocalMove(m_proposedPiece.Type, position.x, position.y);
				}
				UpdateScores();
				TransitionToNextState();
			}
		}

		public void QuitButtonPressed()
		{
			UnityEngine.Application.Quit();
		}

		public void AddPowerballs(uint count)
		{
			m_powerBallcount += count;
			m_ballCountText.text = "x" + m_powerBallcount;
		}

		private void UpdateScores()
		{
			m_player0Text.text = $"{PlatformManager.MyOculusID}\n\n{m_board.GetPlayerScore(0)}";
			m_player1Text.text = $"{m_opponentName}\n\n{m_board.GetPlayerScore(1)}";
		}

		private void UpdateGamePieceColors()
		{
			switch (m_state)
			{
			case GameState.None:
			case GameState.PracticingAiTurn:
			case GameState.OnlineMatchRemoteTurn:
				m_pieceA.GetComponent<Renderer>().material.color = m_unusableColor;
				m_pieceB.GetComponent<Renderer>().material.color = m_unusableColor;
				m_powerPiece.GetComponent<Renderer>().material.color = m_unusableColor;
				if (m_proposedPiece != null)
				{
					UnityEngine.Object.Destroy(m_proposedPiece.gameObject);
				}
				break;
			case GameState.PracticingMyTurn:
			case GameState.OnlineMatchMyTurn:
				m_pieceA.GetComponent<Renderer>().material.color = m_unselectedColor;
				m_pieceB.GetComponent<Renderer>().material.color = m_unselectedColor;
				m_powerPiece.GetComponent<Renderer>().material.color = m_unselectedColor;
				if (m_interestedPiece == m_pieceA || m_interestedPiece == m_pieceB || m_interestedPiece == m_powerPiece)
				{
					m_interestedPiece.GetComponent<Renderer>().material.color = m_highlightedColor;
				}
				if (m_selectedPiece != null)
				{
					m_selectedPiece.GetComponent<Renderer>().material.color = m_selectedColor;
				}
				break;
			}
		}
	}
	public class GamePiece : MonoBehaviour
	{
		public enum Piece
		{
			A,
			B,
			PowerBall
		}

		[SerializeField]
		private Piece m_type;

		[SerializeField]
		private GameObject m_prefabA;

		[SerializeField]
		private GameObject m_prefabB;

		[SerializeField]
		private GameObject m_prefabPower;

		private BoardPosition m_position;

		public Piece Type => m_type;

		public BoardPosition Position
		{
			get
			{
				return m_position;
			}
			set
			{
				m_position = value;
			}
		}

		public GameObject Prefab => m_type switch
		{
			Piece.A => m_prefabA, 
			Piece.B => m_prefabB, 
			_ => m_prefabPower, 
		};

		public GameObject PrefabFor(Piece p)
		{
			return p switch
			{
				Piece.A => m_prefabA, 
				Piece.B => m_prefabB, 
				_ => m_prefabPower, 
			};
		}
	}
	public class IAPManager : MonoBehaviour
	{
		[SerializeField]
		private GameController m_gameController;

		[SerializeField]
		private Text m_priceText;

		private const string CONSUMABLE_1 = "PowerballPack1";

		private void Start()
		{
			FetchProductPrices();
			FetchPurchasedProducts();
		}

		public void FetchProductPrices()
		{
			string[] skus = new string[1] { "PowerballPack1" };
			IAP.GetProductsBySKU(skus).OnComplete(GetProductsBySKUCallback);
		}

		private void GetProductsBySKUCallback(Message<ProductList> msg)
		{
			if (msg.IsError)
			{
				PlatformManager.TerminateWithError(msg);
				return;
			}
			foreach (Product product in msg.GetProductList())
			{
				Debug.LogFormat("Product: sku:{0} name:{1} price:{2}", product.Sku, product.Name, product.FormattedPrice);
				if (product.Sku == "PowerballPack1")
				{
					m_priceText.text = product.FormattedPrice;
				}
			}
		}

		public void FetchPurchasedProducts()
		{
			IAP.GetViewerPurchases().OnComplete(GetViewerPurchasesCallback);
		}

		private void GetViewerPurchasesCallback(Message<PurchaseList> msg)
		{
			if (msg.IsError)
			{
				PlatformManager.TerminateWithError(msg);
				return;
			}
			foreach (Purchase purchase in msg.GetPurchaseList())
			{
				Debug.LogFormat("Purchased: sku:{0} granttime:{1} id:{2}", purchase.Sku, purchase.GrantTime, purchase.ID);
			}
		}

		public void BuyPowerBallsPressed()
		{
			IAP.LaunchCheckoutFlow("PowerballPack1").OnComplete(LaunchCheckoutFlowCallback);
		}

		private void LaunchCheckoutFlowCallback(Message<Purchase> msg)
		{
			if (msg.IsError)
			{
				PlatformManager.TerminateWithError(msg);
				return;
			}
			Purchase purchase = msg.GetPurchase();
			Debug.Log("purchased " + purchase.Sku);
			m_gameController.AddPowerballs(3u);
		}
	}
	public class MatchmakingManager : MonoBehaviour
	{
		private enum MatchRoomState
		{
			None,
			Queued,
			Configuring,
			MyTurn,
			RemoteTurn
		}

		[SerializeField]
		private GameController m_gameController;

		[SerializeField]
		private Text m_matchButtonText;

		[SerializeField]
		private Text m_infoText;

		private const string POOL = "VR_BOARD_GAME_POOL";

		private ulong m_matchRoom;

		private User m_remotePlayer;

		private float m_lastUpdateTime;

		private const float POLL_FREQUENCY = 30f;

		private MatchRoomState m_state;

		private void Start()
		{
			Matchmaking.SetMatchFoundNotificationCallback(MatchFoundCallback);
			Rooms.SetUpdateNotificationCallback(MatchmakingRoomUpdateCallback);
			TransitionToState(MatchRoomState.None);
		}

		private void Update()
		{
			MatchRoomState state = m_state;
			if ((state == MatchRoomState.Configuring || state == MatchRoomState.MyTurn || state == MatchRoomState.RemoteTurn) && 30f < Time.time - m_lastUpdateTime)
			{
				Debug.Log("Polling Room");
				m_lastUpdateTime = Time.time;
				Rooms.Get(m_matchRoom).OnComplete(MatchmakingRoomUpdateCallback);
			}
		}

		public void MatchButtonPressed()
		{
			if (m_state == MatchRoomState.None)
			{
				TransitionToState(MatchRoomState.Queued);
			}
			else
			{
				TransitionToState(MatchRoomState.None);
			}
		}

		public void EndMatch(int localScore, int remoteScore)
		{
			MatchRoomState state = m_state;
			if (state == MatchRoomState.MyTurn || state == MatchRoomState.RemoteTurn)
			{
				string key = PlatformManager.MyID.ToString();
				string key2 = m_remotePlayer.ID.ToString();
				Dictionary<string, int> dictionary = new Dictionary<string, int>();
				if (localScore > remoteScore)
				{
					dictionary[key] = 1;
					dictionary[key2] = 2;
				}
				else if (localScore < remoteScore)
				{
					dictionary[key] = 2;
					dictionary[key2] = 1;
				}
				else
				{
					dictionary[key] = 1;
					dictionary[key2] = 1;
				}
				Matchmaking.ReportResultsInsecure(m_matchRoom, dictionary).OnComplete(GenericErrorCheckCallback);
			}
			TransitionToState(MatchRoomState.None);
		}

		private void OnApplicationQuit()
		{
			Matchmaking.Cancel();
			if (m_matchRoom != 0)
			{
				Rooms.Leave(m_matchRoom);
			}
		}

		private void TransitionToState(MatchRoomState state)
		{
			MatchRoomState state2 = m_state;
			m_state = state;
			switch (m_state)
			{
			case MatchRoomState.None:
				m_matchButtonText.text = "Find Match";
				m_remotePlayer = null;
				Matchmaking.Cancel();
				if (m_matchRoom != 0)
				{
					Rooms.Leave(m_matchRoom);
					m_matchRoom = 0uL;
				}
				break;
			case MatchRoomState.Queued:
				m_matchButtonText.text = "Leave Queue";
				Matchmaking.Enqueue2("VR_BOARD_GAME_POOL").OnComplete(MatchmakingEnqueueCallback);
				break;
			case MatchRoomState.Configuring:
				m_matchButtonText.text = "Cancel Match";
				break;
			case MatchRoomState.MyTurn:
			case MatchRoomState.RemoteTurn:
				m_matchButtonText.text = "Cancel Match";
				break;
			}
		}

		private void MatchmakingEnqueueCallback(Message untyped_msg)
		{
			if (untyped_msg.IsError)
			{
				Debug.Log(untyped_msg.GetError().Message);
				TransitionToState(MatchRoomState.None);
				return;
			}
			Message<MatchmakingEnqueueResult> message = (Message<MatchmakingEnqueueResult>)untyped_msg;
			MatchmakingEnqueueResult data = message.Data;
			m_infoText.text = $"Avg Wait Time: {data.AverageWait}s\nMax Expected Wait: {data.MaxExpectedWait}s\nIn Last Hour: {data.MatchesInLastHourCount}\nRecent Percentage: {data.RecentMatchPercentage}%";
		}

		private void MatchFoundCallback(Message<Oculus.Platform.Models.Room> msg)
		{
			if (msg.IsError)
			{
				Debug.Log(msg.GetError().Message);
				TransitionToState(MatchRoomState.None);
			}
			else if (m_state == MatchRoomState.Queued)
			{
				Matchmaking.JoinRoom(msg.Data.ID, subscribeToUpdates: true).OnComplete(MatchmakingJoinRoomCallback);
				m_matchRoom = msg.Data.ID;
			}
		}

		private void MatchmakingJoinRoomCallback(Message<Oculus.Platform.Models.Room> msg)
		{
			if (msg.IsError)
			{
				Debug.Log(msg.GetError().Message);
				TransitionToState(MatchRoomState.None);
			}
			else if (m_state == MatchRoomState.Queued)
			{
				int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
				Debug.Log("Match room joined: " + m_matchRoom + " count: " + num);
				TransitionToState(MatchRoomState.Configuring);
				if (msg.Data.UsersOptional != null && msg.Data.UsersOptional.Count == 2)
				{
					ProcessRoomData(msg.Data);
				}
			}
		}

		private void MatchmakingRoomUpdateCallback(Message<Oculus.Platform.Models.Room> msg)
		{
			if (msg.IsError)
			{
				Debug.Log(msg.GetError().Message);
				TransitionToState(MatchRoomState.None);
				return;
			}
			string text = ((msg.Data.OwnerOptional == null) ? string.Empty : msg.Data.OwnerOptional.OculusID);
			int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
			Debug.LogFormat("Room Update {0}\n  Owner {1}\n  User Count {2}\n  Datastore Count {3}\n", msg.Data.ID, text, num, msg.Data.DataStore.Count);
			if (msg.Data.ID != m_matchRoom)
			{
				Debug.Log("Unexpected room update from: " + msg.Data.ID);
			}
			else
			{
				ProcessRoomData(msg.Data);
			}
		}

		private void ProcessRoomData(Oculus.Platform.Models.Room room)
		{
			m_lastUpdateTime = Time.time;
			if (m_state == MatchRoomState.Configuring)
			{
				if (room.UsersOptional != null)
				{
					foreach (User item in room.UsersOptional)
					{
						if (PlatformManager.MyID != item.ID)
						{
							Debug.Log("Found remote user: " + item.OculusID);
							m_remotePlayer = item;
							break;
						}
					}
				}
				if (m_remotePlayer == null)
				{
					return;
				}
				bool flag = DoesLocalUserGoFirst();
				TransitionToState((!flag) ? MatchRoomState.RemoteTurn : MatchRoomState.MyTurn);
				Matchmaking.StartMatch(m_matchRoom).OnComplete(GenericErrorCheckCallback);
				m_gameController.StartOnlineMatch(m_remotePlayer.OculusID, flag);
			}
			if (m_state == MatchRoomState.RemoteTurn && room.DataStore.ContainsKey(m_remotePlayer.OculusID) && room.DataStore[m_remotePlayer.OculusID] != string.Empty)
			{
				ProcessRemoteMove(room.DataStore[m_remotePlayer.OculusID]);
				TransitionToState(MatchRoomState.MyTurn);
			}
			if (m_state == MatchRoomState.MyTurn && room.OwnerOptional != null && room.OwnerOptional.ID == PlatformManager.MyID)
			{
				m_gameController.MarkRemoteTurnComplete();
			}
			if (room.UsersOptional == null || (room.UsersOptional != null && room.UsersOptional.Count != 2))
			{
				Debug.Log("Other user quit the room");
				m_gameController.RemoteMatchEnded();
			}
		}

		private void ProcessRemoteMove(string moveString)
		{
			Debug.Log("Processing remote move string: " + moveString);
			string[] array = moveString.Split(':');
			GamePiece.Piece piece = (GamePiece.Piece)Enum.Parse(typeof(GamePiece.Piece), array[0]);
			int num = int.Parse(array[1]);
			int num2 = int.Parse(array[2]);
			num = 2 - num;
			num2 = 2 - num2;
			m_gameController.MakeRemoteMove(piece, num, num2);
		}

		public void SendLocalMove(GamePiece.Piece piece, int boardX, int boardY)
		{
			string text = $"{piece.ToString()}:{boardX}:{boardY}";
			Debug.Log("Sending move: " + text);
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			dictionary[PlatformManager.MyOculusID] = text;
			dictionary[m_remotePlayer.OculusID] = string.Empty;
			Rooms.UpdateDataStore(m_matchRoom, dictionary).OnComplete(UpdateDataStoreCallback);
			TransitionToState(MatchRoomState.RemoteTurn);
		}

		private void UpdateDataStoreCallback(Message<Oculus.Platform.Models.Room> msg)
		{
			if (m_state == MatchRoomState.RemoteTurn)
			{
				Rooms.UpdateOwner(m_matchRoom, m_remotePlayer.ID);
			}
		}

		private bool DoesLocalUserGoFirst()
		{
			if (m_matchRoom % 2 == 0)
			{
				return PlatformManager.MyID < m_remotePlayer.ID;
			}
			return PlatformManager.MyID > m_remotePlayer.ID;
		}

		private void GenericErrorCheckCallback(Message msg)
		{
			if (msg.IsError)
			{
				Debug.Log(msg.GetError().Message);
				TransitionToState(MatchRoomState.None);
			}
		}
	}
	public class PlatformManager : MonoBehaviour
	{
		private static PlatformManager s_instance;

		private ulong m_myID;

		private string m_myOculusID;

		public static ulong MyID
		{
			get
			{
				if (s_instance != null)
				{
					return s_instance.m_myID;
				}
				return 0uL;
			}
		}

		public static string MyOculusID
		{
			get
			{
				if (s_instance != null && s_instance.m_myOculusID != null)
				{
					return s_instance.m_myOculusID;
				}
				return string.Empty;
			}
		}

		private void Awake()
		{
			if (s_instance != null)
			{
				UnityEngine.Object.Destroy(base.gameObject);
				return;
			}
			s_instance = this;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			Core.Initialize();
		}

		private void Start()
		{
			Entitlements.IsUserEntitledToApplication().OnComplete(IsEntitledCallback);
		}

		private void IsEntitledCallback(Message msg)
		{
			if (msg.IsError)
			{
				TerminateWithError(msg);
			}
			else
			{
				Users.GetLoggedInUser().OnComplete(GetLoggedInUserCallback);
			}
		}

		private void GetLoggedInUserCallback(Message<User> msg)
		{
			if (msg.IsError)
			{
				TerminateWithError(msg);
				return;
			}
			m_myID = msg.Data.ID;
			m_myOculusID = msg.Data.OculusID;
			Debug.Log(" I am " + m_myOculusID);
		}

		public static void TerminateWithError(Message msg)
		{
			Debug.Log("Error: " + msg.GetError().Message);
			UnityEngine.Application.Quit();
		}
	}
}
namespace Oculus.Platform.Samples.VrHoops
{
	public class AchievementsManager
	{
		private const string LIKES_TO_WIN = "LIKES_TO_WIN";

		private bool m_likesToWinUnlocked;

		public bool LikesToWin => m_likesToWinUnlocked;

		public void CheckForAchievmentUpdates()
		{
			Achievements.GetProgressByName(new string[1] { "LIKES_TO_WIN" }).OnComplete(delegate(Message<AchievementProgressList> msg)
			{
				foreach (AchievementProgress datum in msg.Data)
				{
					if (datum.Name == "LIKES_TO_WIN")
					{
						m_likesToWinUnlocked = datum.IsUnlocked;
					}
				}
			});
		}

		public void RecordWinForLocalUser()
		{
			Achievements.AddCount("LIKES_TO_WIN", 1uL);
			CheckForAchievmentUpdates();
		}
	}
	public class AIPlayer : Player
	{
		private void FixedUpdate()
		{
			if (base.HasBall)
			{
				if (UnityEngine.Random.Range(0f, 1f) < 0.03f)
				{
					ShootBall();
				}
			}
			else
			{
				CheckSpawnBall();
			}
		}
	}
	public class BallEjector : MonoBehaviour
	{
	}
	public class Camera2DController : MonoBehaviour
	{
		private void Update()
		{
			if (Input.GetButton("Fire2"))
			{
				float axis = Input.GetAxis("Mouse Y");
				float axis2 = Input.GetAxis("Mouse X");
				base.transform.rotation *= Quaternion.AngleAxis(axis2, Vector3.up);
				base.transform.rotation *= Quaternion.AngleAxis(0f - axis, Vector3.right);
				Vector3 eulerAngles = base.transform.eulerAngles;
				eulerAngles.z = 0f;
				base.transform.eulerAngles = eulerAngles;
			}
		}
	}
	public class DetectBasket : MonoBehaviour
	{
		private enum BasketPhase
		{
			NONE,
			TOP,
			BOTH,
			BOTTOM
		}

		private BasketPhase m_phase;

		private Player m_owningPlayer;

		public Player Player
		{
			set
			{
				m_owningPlayer = value;
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			if (other.gameObject.name == "Basket Top" && m_phase == BasketPhase.NONE)
			{
				m_phase = BasketPhase.TOP;
			}
			else if (other.gameObject.name == "Basket Bottom" && m_phase == BasketPhase.TOP)
			{
				m_phase = BasketPhase.BOTH;
			}
			else
			{
				m_phase = BasketPhase.NONE;
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (other.gameObject.name == "Basket Top" && m_phase == BasketPhase.BOTH)
			{
				m_phase = BasketPhase.BOTTOM;
			}
			else if (other.gameObject.name == "Basket Bottom" && m_phase == BasketPhase.BOTTOM)
			{
				m_phase = BasketPhase.NONE;
				PlatformManager.State currentState = PlatformManager.CurrentState;
				if ((currentState == PlatformManager.State.PLAYING_A_LOCAL_MATCH || currentState == PlatformManager.State.PLAYING_A_NETWORKED_MATCH) && (bool)m_owningPlayer)
				{
					m_owningPlayer.Score += 2u;
				}
			}
			else
			{
				m_phase = BasketPhase.NONE;
			}
		}
	}
	public class FlyText : MonoBehaviour
	{
		private const float LIFESPAN = 3f;

		private readonly Vector3 m_movePerFrame = 0.5f * Vector3.up;

		private float m_eol;

		private void Start()
		{
			m_eol = Time.time + 3f;
			GetComponent<Text>().CrossFadeColor(Color.black, 5.1000004f, ignoreTimeScale: false, useAlpha: true);
		}

		private void Update()
		{
			if (Time.time < m_eol)
			{
				base.transform.localPosition += m_movePerFrame;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
	public class GoalMover : MonoBehaviour
	{
		[SerializeField]
		private float MAX_OFFSET = 2f;

		[SerializeField]
		private float m_speed = 0.005f;

		private const float MOVE_TOLERANCE = 0.1f;

		private Vector3 m_expectedPosition;

		private Vector3 m_moveDirection;

		private Vector3 m_nextMoveDirection;

		public Vector3 ExpectedPosition
		{
			get
			{
				return m_expectedPosition;
			}
			set
			{
				m_expectedPosition = value;
			}
		}

		public Vector3 MoveDirection
		{
			get
			{
				return m_moveDirection;
			}
			set
			{
				m_moveDirection = value;
			}
		}

		public Vector3 NextMoveDirection
		{
			get
			{
				return m_nextMoveDirection;
			}
			set
			{
				m_nextMoveDirection = value;
			}
		}

		private void Start()
		{
			ExpectedPosition = base.transform.localPosition;
			m_moveDirection.x = UnityEngine.Random.Range(-1f, 1f);
			m_moveDirection.y = UnityEngine.Random.Range(-1f, 1f);
			m_moveDirection = Vector3.ClampMagnitude(m_moveDirection, m_speed);
			m_nextMoveDirection.x = (0f - Mathf.Sign(m_moveDirection.x)) * UnityEngine.Random.Range(0f, 1f);
			m_nextMoveDirection.y = (0f - Mathf.Sign(m_moveDirection.y)) * UnityEngine.Random.Range(0f, 1f);
			m_nextMoveDirection = Vector3.ClampMagnitude(m_nextMoveDirection, m_speed);
		}

		private void FixedUpdate()
		{
			base.transform.localPosition += MoveDirection;
			ExpectedPosition += MoveDirection;
			Vector3 vector = ExpectedPosition - base.transform.localPosition;
			vector = Vector3.ClampMagnitude(vector, 0.1f);
			base.transform.localPosition += vector;
			if (base.transform.localPosition.sqrMagnitude > MAX_OFFSET * MAX_OFFSET)
			{
				base.transform.localPosition = Vector3.ClampMagnitude(base.transform.localPosition, MAX_OFFSET);
				ExpectedPosition = base.transform.localPosition;
				MoveDirection = NextMoveDirection;
				m_nextMoveDirection.x = (0f - Mathf.Sign(m_moveDirection.x)) * UnityEngine.Random.Range(0f, 1f);
				m_nextMoveDirection.y = (0f - Mathf.Sign(m_moveDirection.y)) * UnityEngine.Random.Range(0f, 1f);
				m_nextMoveDirection = Vector3.ClampMagnitude(m_nextMoveDirection, m_speed);
			}
		}
	}
	public class LeaderboardManager
	{
		public delegate void OnMostWinsLeaderboardUpdated(SortedDictionary<int, LeaderboardEntry> entries);

		public delegate void OnHighScoreLeaderboardUpdated(SortedDictionary<int, LeaderboardEntry> entries);

		private const string MOST_MATCHES_WON = "MOST_MATCHES_WON";

		private const string HIGHEST_MATCH_SCORE = "HIGHEST_MATCH_SCORE";

		private const int TOP_N_COUNT = 5;

		private const float LEADERBOARD_POLL_FREQ = 30f;

		private float m_nextCheckTime;

		private volatile SortedDictionary<int, LeaderboardEntry> m_mostWins;

		private bool m_foundLocalUserMostWinsEntry;

		private long m_numWins;

		private OnMostWinsLeaderboardUpdated m_mostWinsCallback;

		private volatile SortedDictionary<int, LeaderboardEntry> m_highScores;

		private bool m_foundLocalUserHighScore;

		private OnHighScoreLeaderboardUpdated m_highScoreCallback;

		public OnMostWinsLeaderboardUpdated MostWinsLeaderboardUpdatedCallback
		{
			set
			{
				m_mostWinsCallback = value;
			}
		}

		public OnHighScoreLeaderboardUpdated HighScoreLeaderboardUpdatedCallback
		{
			set
			{
				m_highScoreCallback = value;
			}
		}

		public void CheckForUpdates()
		{
			if (Time.time >= m_nextCheckTime && PlatformManager.CurrentState == PlatformManager.State.WAITING_TO_PRACTICE_OR_MATCHMAKE)
			{
				m_nextCheckTime = Time.time + 30f;
				QueryMostWinsLeaderboard();
				QueryHighScoreLeaderboard();
			}
		}

		private void QueryMostWinsLeaderboard()
		{
			if (m_mostWins == null)
			{
				m_mostWins = new SortedDictionary<int, LeaderboardEntry>();
				m_foundLocalUserMostWinsEntry = false;
				Leaderboards.GetEntries("MOST_MATCHES_WON", 5, LeaderboardFilterType.None, LeaderboardStartAt.Top).OnComplete(MostWinsGetEntriesCallback);
			}
		}

		private void MostWinsGetEntriesCallback(Message<LeaderboardEntryList> msg)
		{
			if (!msg.IsError)
			{
				foreach (LeaderboardEntry datum in msg.Data)
				{
					m_mostWins[datum.Rank] = datum;
					if (datum.User.ID == PlatformManager.MyID)
					{
						m_foundLocalUserMostWinsEntry = true;
						m_numWins = datum.Score;
					}
				}
				if (msg.Data.HasNextPage)
				{
					Leaderboards.GetNextEntries(msg.Data).OnComplete(MostWinsGetEntriesCallback);
					return;
				}
				if (!m_foundLocalUserMostWinsEntry)
				{
					Leaderboards.GetEntries("MOST_MATCHES_WON", 1, LeaderboardFilterType.None, LeaderboardStartAt.CenteredOnViewer).OnComplete(MostWinsGetEntriesCallback);
					return;
				}
			}
			if (m_mostWinsCallback != null)
			{
				m_mostWinsCallback(m_mostWins);
			}
			m_mostWins = null;
		}

		private void QueryHighScoreLeaderboard()
		{
			if (m_highScores == null)
			{
				m_highScores = new SortedDictionary<int, LeaderboardEntry>();
				m_foundLocalUserHighScore = false;
				Leaderboards.GetEntries("HIGHEST_MATCH_SCORE", 5, LeaderboardFilterType.None, LeaderboardStartAt.Top).OnComplete(HighestScoreGetEntriesCallback);
			}
		}

		private void HighestScoreGetEntriesCallback(Message<LeaderboardEntryList> msg)
		{
			if (!msg.IsError)
			{
				foreach (LeaderboardEntry datum in msg.Data)
				{
					m_highScores[datum.Rank] = datum;
					if (datum.User.ID == PlatformManager.MyID)
					{
						m_foundLocalUserHighScore = true;
					}
				}
				if (msg.Data.HasNextPage)
				{
					Leaderboards.GetNextEntries(msg.Data).OnComplete(HighestScoreGetEntriesCallback);
					return;
				}
				if (!m_foundLocalUserHighScore)
				{
					Leaderboards.GetEntries("HIGHEST_MATCH_SCORE", 1, LeaderboardFilterType.None, LeaderboardStartAt.CenteredOnViewer).OnComplete(HighestScoreGetEntriesCallback);
					return;
				}
			}
			if (m_highScoreCallback != null)
			{
				m_highScoreCallback(m_highScores);
			}
			m_highScores = null;
		}

		public void SubmitMatchScores(bool wonMatch, uint score)
		{
			if (wonMatch)
			{
				m_numWins++;
				Leaderboards.WriteEntry("MOST_MATCHES_WON", m_numWins);
			}
			if (score != 0)
			{
				Leaderboards.WriteEntry("HIGHEST_MATCH_SCORE", score);
			}
		}
	}
	public class LocalPlayer : Player
	{
		public override uint Score
		{
			set
			{
				base.Score = value;
				if (PlatformManager.CurrentState == PlatformManager.State.PLAYING_A_NETWORKED_MATCH)
				{
					PlatformManager.P2P.SendScoreUpdate(base.Score);
				}
			}
		}

		private void Update()
		{
			GameObject gameObject = null;
			if (base.HasBall)
			{
				if (Input.GetButton("Fire1") || Input.GetKey(KeyCode.Space))
				{
					gameObject = ShootBall();
				}
			}
			else
			{
				gameObject = CheckSpawnBall();
			}
			if ((bool)gameObject && PlatformManager.CurrentState == PlatformManager.State.PLAYING_A_NETWORKED_MATCH)
			{
				PlatformManager.P2P.AddNetworkBall(gameObject);
			}
		}
	}
	public class MatchController : MonoBehaviour
	{
		private enum State
		{
			UNKNOWN,
			NONE,
			WAITING_TO_START_PRACTICE,
			PRACTICING,
			VIEWING_RESULTS_PRACTICE,
			WAITING_FOR_MATCH,
			WAITING_TO_SETUP_MATCH,
			PLAYING_MATCH,
			VIEWING_MATCH_RESULTS
		}

		[SerializeField]
		private Text m_timerText;

		[SerializeField]
		private Camera m_camera;

		[SerializeField]
		private Transform m_idleCameraTransform;

		[SerializeField]
		private Text m_matchmakeButtonText;

		[SerializeField]
		private PlayerArea[] m_playerAreas = new PlayerArea[3];

		[SerializeField]
		private uint PRACTICE_WARMUP_TIME = 5u;

		[SerializeField]
		private uint MATCH_WARMUP_TIME = 30u;

		[SerializeField]
		private uint MATCH_TIME = 20u;

		[SerializeField]
		private uint MATCH_COOLDOWN_TIME = 10u;

		[SerializeField]
		private GameObject m_mostWinsLeaderboard;

		[SerializeField]
		private GameObject m_highestScoresLeaderboard;

		[SerializeField]
		private GameObject m_leaderboardEntryPrefab;

		[SerializeField]
		private GameObject m_flytext;

		private State m_currentState;

		private float m_nextStateTransitionTime;

		private int m_localSlot;

		public float MatchStartTime
		{
			get
			{
				State currentState = m_currentState;
				if (currentState == State.WAITING_TO_START_PRACTICE || currentState == State.WAITING_TO_SETUP_MATCH)
				{
					return m_nextStateTransitionTime;
				}
				return 0f;
			}
			private set
			{
				m_nextStateTransitionTime = value;
			}
		}

		private void Start()
		{
			PlatformManager.Matchmaking.EnqueueResultCallback = OnMatchFoundCallback;
			PlatformManager.Matchmaking.MatchPlayerAddedCallback = MatchPlayerAddedCallback;
			PlatformManager.P2P.StartTimeOfferCallback = StartTimeOfferCallback;
			PlatformManager.Leaderboards.MostWinsLeaderboardUpdatedCallback = MostWinsLeaderboardCallback;
			PlatformManager.Leaderboards.HighScoreLeaderboardUpdatedCallback = HighestScoreLeaderboardCallback;
			TransitionToState(State.NONE);
		}

		private void Update()
		{
			UpdateCheckForNextTimedTransition();
			UpdateMatchTimer();
		}

		private void TransitionToState(State newState)
		{
			Debug.LogFormat("MatchController State {0} -> {1}", m_currentState, newState);
			if (m_currentState != newState)
			{
				State currentState = m_currentState;
				m_currentState = newState;
				switch (newState)
				{
				case State.NONE:
					SetupForIdle();
					MoveCameraToIdlePosition();
					PlatformManager.TransitionToState(PlatformManager.State.WAITING_TO_PRACTICE_OR_MATCHMAKE);
					m_matchmakeButtonText.text = "Play Online";
					break;
				case State.WAITING_TO_START_PRACTICE:
					SetupForPractice();
					MoveCameraToMatchPosition();
					PlatformManager.TransitionToState(PlatformManager.State.MATCH_TRANSITION);
					m_nextStateTransitionTime = Time.time + (float)PRACTICE_WARMUP_TIME;
					break;
				case State.PRACTICING:
					PlatformManager.TransitionToState(PlatformManager.State.PLAYING_A_LOCAL_MATCH);
					m_nextStateTransitionTime = Time.time + (float)MATCH_TIME;
					break;
				case State.VIEWING_RESULTS_PRACTICE:
					PlatformManager.TransitionToState(PlatformManager.State.MATCH_TRANSITION);
					m_nextStateTransitionTime = Time.time + (float)MATCH_COOLDOWN_TIME;
					m_timerText.text = "0:00.00";
					break;
				case State.WAITING_FOR_MATCH:
					PlatformManager.TransitionToState(PlatformManager.State.MATCH_TRANSITION);
					m_matchmakeButtonText.text = "Cancel";
					break;
				case State.WAITING_TO_SETUP_MATCH:
					m_nextStateTransitionTime = Time.time + (float)MATCH_WARMUP_TIME;
					break;
				case State.PLAYING_MATCH:
					PlatformManager.TransitionToState(PlatformManager.State.PLAYING_A_NETWORKED_MATCH);
					m_nextStateTransitionTime = Time.time + (float)MATCH_TIME;
					break;
				case State.VIEWING_MATCH_RESULTS:
					PlatformManager.TransitionToState(PlatformManager.State.MATCH_TRANSITION);
					m_nextStateTransitionTime = Time.time + (float)MATCH_COOLDOWN_TIME;
					m_timerText.text = "0:00.00";
					CalculateMatchResults();
					break;
				}
			}
		}

		private void UpdateCheckForNextTimedTransition()
		{
			if (m_currentState != State.NONE && Time.time >= m_nextStateTransitionTime)
			{
				switch (m_currentState)
				{
				case State.WAITING_TO_START_PRACTICE:
					TransitionToState(State.PRACTICING);
					break;
				case State.PRACTICING:
					TransitionToState(State.VIEWING_RESULTS_PRACTICE);
					break;
				case State.VIEWING_RESULTS_PRACTICE:
					TransitionToState(State.NONE);
					break;
				case State.WAITING_TO_SETUP_MATCH:
					TransitionToState(State.PLAYING_MATCH);
					break;
				case State.PLAYING_MATCH:
					TransitionToState(State.VIEWING_MATCH_RESULTS);
					break;
				case State.VIEWING_MATCH_RESULTS:
					PlatformManager.Matchmaking.EndMatch();
					TransitionToState(State.NONE);
					break;
				case State.WAITING_FOR_MATCH:
					break;
				}
			}
		}

		private void UpdateMatchTimer()
		{
			if (Time.time <= m_nextStateTransitionTime)
			{
				switch (m_currentState)
				{
				case State.WAITING_TO_START_PRACTICE:
				case State.WAITING_TO_SETUP_MATCH:
					m_timerText.text = $"{Mathf.Ceil(Time.time - MatchStartTime):0}";
					break;
				case State.PRACTICING:
				case State.PLAYING_MATCH:
				{
					float num = m_nextStateTransitionTime - Time.time;
					m_timerText.text = $"{Mathf.Floor(num / 60f):#0}:{Mathf.Floor(num) % 60f:#00}.{Mathf.Floor(num * 100f) % 100f:00}";
					break;
				}
				case State.VIEWING_RESULTS_PRACTICE:
				case State.WAITING_FOR_MATCH:
					break;
				}
			}
		}

		private void SetupForIdle()
		{
			for (int i = 0; i < m_playerAreas.Length; i++)
			{
				m_playerAreas[i].SetupForPlayer<AIPlayer>("* AI *");
			}
		}

		private void SetupForPractice()
		{
			m_localSlot = UnityEngine.Random.Range(0, m_playerAreas.Length - 1);
			for (int i = 0; i < m_playerAreas.Length; i++)
			{
				if (i == m_localSlot)
				{
					m_playerAreas[i].SetupForPlayer<LocalPlayer>(PlatformManager.MyOculusID);
				}
				else
				{
					m_playerAreas[i].SetupForPlayer<AIPlayer>("* AI *");
				}
			}
		}

		private Player MatchPlayerAddedCallback(int slot, User user)
		{
			Player result = null;
			if (m_currentState == State.WAITING_TO_SETUP_MATCH && slot < m_playerAreas.Length)
			{
				if (user.ID == PlatformManager.MyID)
				{
					LocalPlayer localPlayer = m_playerAreas[slot].SetupForPlayer<LocalPlayer>(user.OculusID);
					MoveCameraToMatchPosition();
					result = localPlayer;
					m_localSlot = slot;
				}
				else
				{
					RemotePlayer remotePlayer = m_playerAreas[slot].SetupForPlayer<RemotePlayer>(user.OculusID);
					remotePlayer.User = user;
					result = remotePlayer;
				}
			}
			return result;
		}

		private void MoveCameraToIdlePosition()
		{
			BallEjector componentInChildren = m_camera.gameObject.GetComponentInChildren<BallEjector>();
			if ((bool)componentInChildren)
			{
				componentInChildren.transform.SetParent(m_camera.transform.parent, worldPositionStays: false);
				m_camera.transform.SetParent(m_idleCameraTransform, worldPositionStays: false);
			}
		}

		private void MoveCameraToMatchPosition()
		{
			PlayerArea[] playerAreas = m_playerAreas;
			foreach (PlayerArea playerArea in playerAreas)
			{
				LocalPlayer componentInChildren = playerArea.GetComponentInChildren<LocalPlayer>();
				if ((bool)componentInChildren)
				{
					BallEjector componentInChildren2 = componentInChildren.GetComponentInChildren<BallEjector>();
					m_camera.transform.SetParent(componentInChildren.transform, worldPositionStays: false);
					componentInChildren2.transform.SetParent(m_camera.transform, worldPositionStays: false);
					break;
				}
			}
			DisplayAchievementFlytext();
		}

		public void StartPracticeMatch()
		{
			if (m_currentState == State.NONE)
			{
				TransitionToState(State.WAITING_TO_START_PRACTICE);
			}
		}

		public void PlayOnlineOrCancel()
		{
			Debug.Log("Play online or Cancel");
			if (m_currentState == State.NONE)
			{
				PlatformManager.Matchmaking.QueueForMatch();
				TransitionToState(State.WAITING_FOR_MATCH);
			}
			else if (m_currentState == State.WAITING_FOR_MATCH)
			{
				PlatformManager.Matchmaking.LeaveQueue();
				TransitionToState(State.NONE);
			}
		}

		private void OnMatchFoundCallback(bool success)
		{
			if (success)
			{
				TransitionToState(State.WAITING_TO_SETUP_MATCH);
			}
			else
			{
				TransitionToState(State.NONE);
			}
		}

		private float StartTimeOfferCallback(float remoteTime)
		{
			if (m_currentState == State.WAITING_TO_SETUP_MATCH && remoteTime > MatchStartTime && remoteTime - 60f < MatchStartTime)
			{
				Debug.Log("Moving Start time by " + (remoteTime - MatchStartTime));
				MatchStartTime = remoteTime;
			}
			return MatchStartTime;
		}

		private void MostWinsLeaderboardCallback(SortedDictionary<int, LeaderboardEntry> entries)
		{
			foreach (Transform item in m_mostWinsLeaderboard.transform)
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
			foreach (LeaderboardEntry value in entries.Values)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(m_leaderboardEntryPrefab);
				gameObject.transform.SetParent(m_mostWinsLeaderboard.transform, worldPositionStays: false);
				gameObject.GetComponent<Text>().text = $"{value.Rank} - {value.User.OculusID} - {value.Score}";
			}
		}

		private void HighestScoreLeaderboardCallback(SortedDictionary<int, LeaderboardEntry> entries)
		{
			foreach (Transform item in m_highestScoresLeaderboard.transform)
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
			foreach (LeaderboardEntry value in entries.Values)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(m_leaderboardEntryPrefab);
				gameObject.transform.SetParent(m_highestScoresLeaderboard.transform, worldPositionStays: false);
				gameObject.GetComponent<Text>().text = $"{value.Rank} - {value.User.OculusID} - {value.Score}";
			}
		}

		private void CalculateMatchResults()
		{
			LocalPlayer localPlayer = null;
			RemotePlayer remotePlayer = null;
			PlayerArea[] playerAreas = m_playerAreas;
			foreach (PlayerArea playerArea in playerAreas)
			{
				if (playerArea.Player is LocalPlayer)
				{
					localPlayer = playerArea.Player as LocalPlayer;
				}
				else if (playerArea.Player is RemotePlayer && (remotePlayer == null || playerArea.Player.Score > remotePlayer.Score))
				{
					remotePlayer = playerArea.Player as RemotePlayer;
				}
			}
			if ((bool)localPlayer && (bool)remotePlayer)
			{
				bool flag = localPlayer.Score > remotePlayer.Score;
				PlatformManager.Leaderboards.SubmitMatchScores(flag, localPlayer.Score);
				if (flag)
				{
					PlatformManager.Achievements.RecordWinForLocalUser();
				}
			}
		}

		private void DisplayAchievementFlytext()
		{
			if (PlatformManager.Achievements.LikesToWin)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(m_flytext);
				gameObject.GetComponent<Text>().text = "Likes to Win!";
				gameObject.transform.position = Vector3.up * 40f;
				gameObject.transform.SetParent(m_playerAreas[m_localSlot].NameText.transform, worldPositionStays: false);
			}
		}
	}
	public class MatchmakingManager
	{
		public delegate void OnEnqueueResult(bool successful);

		public delegate Player OnMatchPlayerAdded(int slot, User user);

		private const string NORMAL_POOL = "NORMAL_QUICKMATCH";

		private ulong m_matchRoom;

		private readonly Dictionary<ulong, User> m_remotePlayers;

		private OnEnqueueResult m_enqueueCallback;

		private OnMatchPlayerAdded m_playerCallback;

		public OnEnqueueResult EnqueueResultCallback
		{
			private get
			{
				return m_enqueueCallback;
			}
			set
			{
				m_enqueueCallback = value;
			}
		}

		public OnMatchPlayerAdded MatchPlayerAddedCallback
		{
			private get
			{
				return m_playerCallback;
			}
			set
			{
				m_playerCallback = value;
			}
		}

		public MatchmakingManager()
		{
			m_remotePlayers = new Dictionary<ulong, User>();
			Matchmaking.SetMatchFoundNotificationCallback(MatchFoundCallback);
			Rooms.SetUpdateNotificationCallback(MatchmakingRoomUpdateCallback);
		}

		public void QueueForMatch()
		{
			Matchmaking.Enqueue("NORMAL_QUICKMATCH").OnComplete(MatchmakingEnqueueCallback);
		}

		private void MatchmakingEnqueueCallback(Message msg)
		{
			if (msg.IsError)
			{
				Debug.Log(msg.GetError().Message);
				EnqueueResultCallback(successful: false);
			}
		}

		private void MatchFoundCallback(Message<Oculus.Platform.Models.Room> msg)
		{
			m_matchRoom = msg.Data.ID;
			Matchmaking.JoinRoom(msg.Data.ID, subscribeToUpdates: true).OnComplete(MatchmakingJoinRoomCallback);
		}

		private void MatchmakingJoinRoomCallback(Message<Oculus.Platform.Models.Room> msg)
		{
			if (msg.IsError)
			{
				Debug.Log(msg.GetError().Message);
				EnqueueResultCallback(successful: false);
				return;
			}
			Debug.Log("Match found and room joined " + m_matchRoom);
			EnqueueResultCallback(successful: true);
			int num = 0;
			if (msg.Data.UsersOptional == null)
			{
				return;
			}
			foreach (User item in msg.Data.UsersOptional)
			{
				Player player = MatchPlayerAddedCallback(num++, item);
				if (PlatformManager.MyID != item.ID)
				{
					m_remotePlayers[item.ID] = item;
					PlatformManager.P2P.AddRemotePlayer(player as RemotePlayer);
				}
			}
		}

		private void MatchmakingRoomUpdateCallback(Message<Oculus.Platform.Models.Room> msg)
		{
			if (msg.IsError)
			{
				PlatformManager.TerminateWithError(msg);
			}
			else
			{
				if (msg.Data.ID != m_matchRoom || msg.Data.UsersOptional == null)
				{
					return;
				}
				foreach (User item in msg.Data.UsersOptional)
				{
					if (PlatformManager.MyID != item.ID && !m_remotePlayers.ContainsKey(item.ID))
					{
						m_remotePlayers[item.ID] = item;
						Player player = MatchPlayerAddedCallback(m_remotePlayers.Count, item);
						PlatformManager.P2P.AddRemotePlayer(player as RemotePlayer);
					}
				}
			}
		}

		public void EndMatch()
		{
			if (m_matchRoom != 0)
			{
				Rooms.Leave(m_matchRoom);
				m_remotePlayers.Clear();
				PlatformManager.P2P.DisconnectAll();
				m_matchRoom = 0uL;
			}
		}

		public void LeaveQueue()
		{
			Matchmaking.Cancel();
			EndMatch();
		}
	}
	public class P2PManager
	{
		private class RemotePlayerData
		{
			public PeerConnectionState state;

			public RemotePlayer player;

			public float remoteTimeOffset;

			public float lastReceivedBallsTime;

			public readonly Dictionary<int, P2PNetworkBall> activeBalls = new Dictionary<int, P2PNetworkBall>();
		}

		public delegate float StartTimeOffer(float remoteTime);

		private readonly Dictionary<ulong, RemotePlayerData> m_remotePlayers = new Dictionary<ulong, RemotePlayerData>();

		private float m_timeForNextBallUpdate;

		private const byte TIME_SYNC_MESSAGE = 1;

		private const uint TIME_SYNC_MESSAGE_SIZE = 5u;

		private const int TIME_SYNC_MESSAGE_COUNT = 7;

		private const byte START_TIME_MESSAGE = 2;

		private const uint START_TIME_MESSAGE_SIZE = 5u;

		private const byte BACKBOARD_UPDATE_MESSAGE = 3;

		private const uint BACKBOARD_UPDATE_MESSAGE_SIZE = 41u;

		private const byte LOCAL_BALLS_UPDATE_MESSAGE = 4;

		private const uint LOCAL_BALLS_UPDATE_MESSATE_SIZE_MAX = 353u;

		private const float LOCAL_BALLS_UPDATE_DELAY = 0.1f;

		private const byte SCORE_UPDATE_MESSAGE = 5;

		private const uint SCORE_UPDATE_MESSAGE_SIZE = 5u;

		private readonly Dictionary<int, P2PNetworkBall> m_localBalls = new Dictionary<int, P2PNetworkBall>();

		private readonly byte[] readBuffer = new byte[353];

		private readonly Dictionary<ulong, List<float>> m_remoteSyncTimeCache = new Dictionary<ulong, List<float>>();

		private readonly Dictionary<ulong, float> m_remoteSentTimeCache = new Dictionary<ulong, float>();

		private StartTimeOffer m_startTimeOfferCallback;

		public StartTimeOffer StartTimeOfferCallback
		{
			private get
			{
				return m_startTimeOfferCallback;
			}
			set
			{
				m_startTimeOfferCallback = value;
			}
		}

		public P2PManager()
		{
			Net.SetPeerConnectRequestCallback(PeerConnectRequestCallback);
			Net.SetConnectionStateChangedCallback(ConnectionStateChangedCallback);
		}

		public void UpdateNetwork()
		{
			if (m_remotePlayers.Count == 0)
			{
				return;
			}
			Packet packet;
			while ((packet = Net.ReadPacket()) != null)
			{
				if (m_remotePlayers.ContainsKey(packet.SenderID))
				{
					packet.ReadBytes(readBuffer);
					switch (readBuffer[0])
					{
					case 1:
						ReadTimeSyncMessage(packet.SenderID, readBuffer);
						break;
					case 2:
						ReceiveMatchStartTimeOffer(packet.SenderID, readBuffer);
						break;
					case 3:
						ReceiveBackboardUpdate(packet.SenderID, readBuffer);
						break;
					case 4:
						ReceiveBallTransforms(packet.SenderID, readBuffer, packet.Size);
						break;
					case 5:
						ReceiveScoredUpdate(packet.SenderID, readBuffer);
						break;
					}
				}
			}
			if (Time.time >= m_timeForNextBallUpdate && m_localBalls.Count > 0)
			{
				SendLocalBallTransforms();
			}
		}

		public void AddRemotePlayer(RemotePlayer player)
		{
			if (!m_remotePlayers.ContainsKey(player.ID))
			{
				m_remotePlayers[player.ID] = new RemotePlayerData();
				m_remotePlayers[player.ID].state = PeerConnectionState.Unknown;
				m_remotePlayers[player.ID].player = player;
				if (PlatformManager.MyID < player.ID)
				{
					Debug.Log("P2P Try Connect to: " + player.ID);
					Net.Connect(player.ID);
				}
			}
		}

		public void DisconnectAll()
		{
			foreach (ulong key in m_remotePlayers.Keys)
			{
				Net.Close(key);
			}
			m_remotePlayers.Clear();
		}

		private void PeerConnectRequestCallback(Message<NetworkingPeer> msg)
		{
			if (m_remotePlayers.ContainsKey(msg.Data.ID))
			{
				Debug.LogFormat("P2P Accepting Connection request from {0}", msg.Data.ID);
				Net.Accept(msg.Data.ID);
			}
			else
			{
				Debug.LogFormat("P2P Ignoring unauthorized Connection request from {0}", msg.Data.ID);
			}
		}

		private void ConnectionStateChangedCallback(Message<NetworkingPeer> msg)
		{
			Debug.LogFormat("P2P {0} Connection state changed to {1}", msg.Data.ID, msg.Data.State);
			if (!m_remotePlayers.ContainsKey(msg.Data.ID))
			{
				return;
			}
			m_remotePlayers[msg.Data.ID].state = msg.Data.State;
			switch (msg.Data.State)
			{
			case PeerConnectionState.Connected:
				if (PlatformManager.MyID < msg.Data.ID)
				{
					SendTimeSyncMessage(msg.Data.ID);
				}
				break;
			case PeerConnectionState.Timeout:
				if (PlatformManager.MyID < msg.Data.ID)
				{
					Net.Connect(msg.Data.ID);
				}
				break;
			case PeerConnectionState.Closed:
				m_remotePlayers.Remove(msg.Data.ID);
				break;
			}
		}

		private void SendTimeSyncMessage(ulong remoteID)
		{
			if (!m_remoteSyncTimeCache.ContainsKey(remoteID))
			{
				m_remoteSyncTimeCache[remoteID] = new List<float>();
			}
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			m_remoteSentTimeCache[remoteID] = realtimeSinceStartup;
			byte[] array = new byte[5] { 1, 0, 0, 0, 0 };
			int offset = 1;
			PackFloat(realtimeSinceStartup, array, ref offset);
			Net.SendPacket(remoteID, array, SendPolicy.Reliable);
		}

		private void ReadTimeSyncMessage(ulong remoteID, byte[] msg)
		{
			if (!m_remoteSentTimeCache.ContainsKey(remoteID))
			{
				SendTimeSyncMessage(remoteID);
				return;
			}
			int offset = 1;
			float num = UnpackFloat(msg, ref offset);
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			float num2 = (realtimeSinceStartup - m_remoteSentTimeCache[remoteID]) / 2f;
			float item = realtimeSinceStartup - (num + num2);
			m_remoteSyncTimeCache[remoteID].Add(item);
			if (m_remoteSyncTimeCache[remoteID].Count < 7)
			{
				SendTimeSyncMessage(remoteID);
				return;
			}
			if (PlatformManager.MyID < remoteID)
			{
				SendTimeSyncMessage(remoteID);
			}
			m_remoteSyncTimeCache[remoteID].Sort();
			float num3 = m_remoteSyncTimeCache[remoteID][3];
			double num4 = 0.0;
			foreach (float item2 in m_remoteSyncTimeCache[remoteID])
			{
				num4 += (double)item2;
			}
			num4 /= 7.0;
			double num5 = 0.0;
			foreach (float item3 in m_remoteSyncTimeCache[remoteID])
			{
				num5 += (num4 - (double)item3) * (num4 - (double)item3);
			}
			num5 = Math.Sqrt(num5) / 7.0;
			num4 = 0.0;
			int num6 = 0;
			foreach (float item4 in m_remoteSyncTimeCache[remoteID])
			{
				if ((double)Math.Abs(item4 - num3) < num5)
				{
					num4 += (double)item4;
					num6++;
				}
			}
			num4 /= (double)num6;
			Debug.LogFormat("Time offset to {0} is {1}", remoteID, num4);
			m_remoteSyncTimeCache.Remove(remoteID);
			m_remoteSentTimeCache.Remove(remoteID);
			m_remotePlayers[remoteID].remoteTimeOffset = (float)num4;
			OfferMatchStartTime();
		}

		private float ShiftRemoteTime(ulong remoteID, float remoteTime)
		{
			if (m_remotePlayers.ContainsKey(remoteID))
			{
				return remoteTime + m_remotePlayers[remoteID].remoteTimeOffset;
			}
			return remoteTime;
		}

		private void OfferMatchStartTime()
		{
			byte[] array = new byte[5] { 2, 0, 0, 0, 0 };
			int offset = 1;
			PackFloat(StartTimeOfferCallback(0f), array, ref offset);
			foreach (ulong key in m_remotePlayers.Keys)
			{
				if (m_remotePlayers[key].state == PeerConnectionState.Connected)
				{
					Net.SendPacket(key, array, SendPolicy.Reliable);
				}
			}
		}

		private void ReceiveMatchStartTimeOffer(ulong remoteID, byte[] msg)
		{
			int offset = 1;
			float remoteTime = UnpackTime(remoteID, msg, ref offset);
			StartTimeOfferCallback(remoteTime);
		}

		public void SendBackboardUpdate(float time, Vector3 pos, Vector3 moveDir, Vector3 nextMoveDir)
		{
			byte[] array = new byte[41];
			array[0] = 3;
			int offset = 1;
			PackFloat(time, array, ref offset);
			PackVector3(pos, array, ref offset);
			PackVector3(moveDir, array, ref offset);
			PackVector3(nextMoveDir, array, ref offset);
			foreach (KeyValuePair<ulong, RemotePlayerData> remotePlayer in m_remotePlayers)
			{
				if (remotePlayer.Value.state == PeerConnectionState.Connected)
				{
					Net.SendPacket(remotePlayer.Key, array, SendPolicy.Reliable);
				}
			}
		}

		private void ReceiveBackboardUpdate(ulong remoteID, byte[] msg)
		{
			int offset = 1;
			float remoteTime = UnpackTime(remoteID, msg, ref offset);
			Vector3 pos = UnpackVector3(msg, ref offset);
			Vector3 moveDir = UnpackVector3(msg, ref offset);
			Vector3 nextMoveDir = UnpackVector3(msg, ref offset);
			P2PNetworkGoal goal = m_remotePlayers[remoteID].player.Goal;
			goal.RemoteBackboardUpdate(remoteTime, pos, moveDir, nextMoveDir);
		}

		public void AddNetworkBall(GameObject ball)
		{
			m_localBalls[ball.GetInstanceID()] = ball.AddComponent<P2PNetworkBall>();
		}

		public void RemoveNetworkBall(GameObject ball)
		{
			m_localBalls.Remove(ball.GetInstanceID());
		}

		private void SendLocalBallTransforms()
		{
			m_timeForNextBallUpdate = Time.time + 0.1f;
			int num = 5 + m_localBalls.Count * 29;
			byte[] array = new byte[num];
			array[0] = 4;
			int offset = 1;
			PackFloat(Time.realtimeSinceStartup, array, ref offset);
			foreach (P2PNetworkBall value in m_localBalls.Values)
			{
				PackBool(value.IsHeld(), array, ref offset);
				PackInt32(value.gameObject.GetInstanceID(), array, ref offset);
				PackVector3(value.transform.localPosition, array, ref offset);
				PackVector3(value.velocity, array, ref offset);
			}
			foreach (KeyValuePair<ulong, RemotePlayerData> remotePlayer in m_remotePlayers)
			{
				if (remotePlayer.Value.state == PeerConnectionState.Connected)
				{
					Net.SendPacket(remotePlayer.Key, array, SendPolicy.Unreliable);
				}
			}
		}

		private void ReceiveBallTransforms(ulong remoteID, byte[] msg, ulong msgLength)
		{
			int offset = 1;
			float num = UnpackTime(remoteID, msg, ref offset);
			if (num < m_remotePlayers[remoteID].lastReceivedBallsTime)
			{
				return;
			}
			m_remotePlayers[remoteID].lastReceivedBallsTime = num;
			while (offset != (int)msgLength)
			{
				bool isHeld = UnpackBool(msg, ref offset);
				int key = UnpackInt32(msg, ref offset);
				Vector3 pos = UnpackVector3(msg, ref offset);
				Vector3 vel = UnpackVector3(msg, ref offset);
				if (!m_remotePlayers[remoteID].activeBalls.ContainsKey(key))
				{
					P2PNetworkBall p2PNetworkBall = m_remotePlayers[remoteID].player.CreateBall().AddComponent<P2PNetworkBall>();
					p2PNetworkBall.transform.SetParent(m_remotePlayers[remoteID].player.transform.parent);
					m_remotePlayers[remoteID].activeBalls[key] = p2PNetworkBall;
				}
				P2PNetworkBall p2PNetworkBall2 = m_remotePlayers[remoteID].activeBalls[key];
				if ((bool)p2PNetworkBall2)
				{
					p2PNetworkBall2.ProcessRemoteUpdate(num, isHeld, pos, vel);
				}
			}
		}

		public void SendScoreUpdate(uint score)
		{
			byte[] array = new byte[5] { 5, 0, 0, 0, 0 };
			int offset = 1;
			PackUint32(score, array, ref offset);
			foreach (KeyValuePair<ulong, RemotePlayerData> remotePlayer in m_remotePlayers)
			{
				if (remotePlayer.Value.state == PeerConnectionState.Connected)
				{
					Net.SendPacket(remotePlayer.Key, array, SendPolicy.Reliable);
				}
			}
		}

		private void ReceiveScoredUpdate(ulong remoteID, byte[] msg)
		{
			int offset = 1;
			uint score = UnpackUint32(msg, ref offset);
			m_remotePlayers[remoteID].player.ReceiveRemoteScore(score);
		}

		private void PackVector3(Vector3 vec, byte[] buf, ref int offset)
		{
			PackFloat(vec.x, buf, ref offset);
			PackFloat(vec.y, buf, ref offset);
			PackFloat(vec.z, buf, ref offset);
		}

		private Vector3 UnpackVector3(byte[] buf, ref int offset)
		{
			Vector3 result = default(Vector3);
			result.x = UnpackFloat(buf, ref offset);
			result.y = UnpackFloat(buf, ref offset);
			result.z = UnpackFloat(buf, ref offset);
			return result;
		}

		private void PackQuaternion(Quaternion quat, byte[] buf, ref int offset)
		{
			PackFloat(quat.x, buf, ref offset);
			PackFloat(quat.y, buf, ref offset);
			PackFloat(quat.z, buf, ref offset);
			PackFloat(quat.w, buf, ref offset);
		}

		private void PackFloat(float value, byte[] buf, ref int offset)
		{
			Buffer.BlockCopy(BitConverter.GetBytes(value), 0, buf, offset, 4);
			offset += 4;
		}

		private float UnpackFloat(byte[] buf, ref int offset)
		{
			float result = BitConverter.ToSingle(buf, offset);
			offset += 4;
			return result;
		}

		private float UnpackTime(ulong remoteID, byte[] buf, ref int offset)
		{
			return ShiftRemoteTime(remoteID, UnpackFloat(buf, ref offset));
		}

		private void PackInt32(int value, byte[] buf, ref int offset)
		{
			Buffer.BlockCopy(BitConverter.GetBytes(value), 0, buf, offset, 4);
			offset += 4;
		}

		private int UnpackInt32(byte[] buf, ref int offset)
		{
			int result = BitConverter.ToInt32(buf, offset);
			offset += 4;
			return result;
		}

		private void PackUint32(uint value, byte[] buf, ref int offset)
		{
			Buffer.BlockCopy(BitConverter.GetBytes(value), 0, buf, offset, 4);
			offset += 4;
		}

		private uint UnpackUint32(byte[] buf, ref int offset)
		{
			uint result = BitConverter.ToUInt32(buf, offset);
			offset += 4;
			return result;
		}

		private void PackBool(bool value, byte[] buf, ref int offset)
		{
			buf[offset++] = (byte)(value ? 1u : 0u);
		}

		private bool UnpackBool(byte[] buf, ref int offset)
		{
			return buf[offset++] != 0;
		}
	}
	public class P2PNetworkBall : MonoBehaviour
	{
		private float lastCollisionTime;

		private Rigidbody rigidBody;

		public Vector3 velocity => rigidBody.velocity;

		private void Awake()
		{
			rigidBody = base.gameObject.GetComponent<Rigidbody>();
		}

		public bool IsHeld()
		{
			return !rigidBody.useGravity;
		}

		public void ProcessRemoteUpdate(float remoteTime, bool isHeld, Vector3 pos, Vector3 vel)
		{
			if (isHeld)
			{
				base.transform.localPosition = pos;
			}
			else if (lastCollisionTime < remoteTime)
			{
				float time = Time.realtimeSinceStartup - remoteTime;
				base.transform.localPosition = estimatePosition(pos, vel, time);
				rigidBody.velocity = estimateVelocity(vel, time);
				if (IsHeld())
				{
					rigidBody.useGravity = true;
					rigidBody.detectCollisions = true;
				}
			}
		}

		private Vector3 estimatePosition(Vector3 startPosition, Vector3 startVelocty, float time)
		{
			return startPosition + startVelocty * time + 0.5f * Physics.gravity * time * time;
		}

		private Vector3 estimateVelocity(Vector3 startVelocity, float time)
		{
			return startVelocity + Physics.gravity * time * Mathf.Clamp01(1f - rigidBody.drag * time);
		}

		private void OnCollisionEnter(Collision collision)
		{
			lastCollisionTime = Time.realtimeSinceStartup;
		}

		private void OnDestroy()
		{
			PlatformManager.P2P.RemoveNetworkBall(base.gameObject);
		}
	}
	public class P2PNetworkGoal : MonoBehaviour
	{
		private GoalMover m_goal;

		private Vector3 m_lastSentMoveDirection;

		private bool m_sendUpdates;

		public bool SendUpdates
		{
			set
			{
				m_sendUpdates = value;
			}
		}

		private void Awake()
		{
			m_goal = base.gameObject.GetComponent<GoalMover>();
		}

		private void FixedUpdate()
		{
			if (m_sendUpdates && m_goal.MoveDirection != m_lastSentMoveDirection)
			{
				SendBackboardUpdate();
			}
		}

		public void SendBackboardUpdate()
		{
			m_lastSentMoveDirection = m_goal.MoveDirection;
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			PlatformManager.P2P.SendBackboardUpdate(realtimeSinceStartup, base.transform.localPosition, m_goal.MoveDirection, m_goal.NextMoveDirection);
		}

		public void RemoteBackboardUpdate(float remoteTime, Vector3 pos, Vector3 moveDir, Vector3 nextMoveDir)
		{
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			float f = (realtimeSinceStartup - remoteTime) / Time.fixedDeltaTime;
			m_goal.ExpectedPosition = pos + Mathf.Round(f) * moveDir;
			m_goal.MoveDirection = moveDir;
			m_goal.NextMoveDirection = nextMoveDir;
		}
	}
	public class PlatformManager : MonoBehaviour
	{
		public enum State
		{
			INITIALIZING,
			WAITING_TO_PRACTICE_OR_MATCHMAKE,
			MATCH_TRANSITION,
			PLAYING_A_LOCAL_MATCH,
			PLAYING_A_NETWORKED_MATCH
		}

		private static PlatformManager s_instance;

		private MatchmakingManager m_matchmaking;

		private P2PManager m_p2p;

		private LeaderboardManager m_leaderboards;

		private AchievementsManager m_achievements;

		private State m_currentState;

		private ulong m_myID;

		private string m_myOculusID;

		public static MatchmakingManager Matchmaking => s_instance.m_matchmaking;

		public static P2PManager P2P => s_instance.m_p2p;

		public static LeaderboardManager Leaderboards => s_instance.m_leaderboards;

		public static AchievementsManager Achievements => s_instance.m_achievements;

		public static State CurrentState => s_instance.m_currentState;

		public static ulong MyID
		{
			get
			{
				if (s_instance != null)
				{
					return s_instance.m_myID;
				}
				return 0uL;
			}
		}

		public static string MyOculusID
		{
			get
			{
				if (s_instance != null && s_instance.m_myOculusID != null)
				{
					return s_instance.m_myOculusID;
				}
				return string.Empty;
			}
		}

		private void Update()
		{
			m_p2p.UpdateNetwork();
			m_leaderboards.CheckForUpdates();
		}

		private void Awake()
		{
			if (s_instance != null)
			{
				UnityEngine.Object.Destroy(base.gameObject);
				return;
			}
			s_instance = this;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			Core.Initialize();
			m_matchmaking = new MatchmakingManager();
			m_p2p = new P2PManager();
			m_leaderboards = new LeaderboardManager();
			m_achievements = new AchievementsManager();
		}

		private void Start()
		{
			Entitlements.IsUserEntitledToApplication().OnComplete(IsEntitledCallback);
		}

		private void IsEntitledCallback(Message msg)
		{
			if (msg.IsError)
			{
				TerminateWithError(msg);
			}
			else
			{
				Users.GetLoggedInUser().OnComplete(GetLoggedInUserCallback);
			}
		}

		private void GetLoggedInUserCallback(Message<User> msg)
		{
			if (msg.IsError)
			{
				TerminateWithError(msg);
				return;
			}
			m_myID = msg.Data.ID;
			m_myOculusID = msg.Data.OculusID;
			TransitionToState(State.WAITING_TO_PRACTICE_OR_MATCHMAKE);
			Achievements.CheckForAchievmentUpdates();
		}

		public static void TerminateWithError(Message msg)
		{
			Debug.Log("Error: " + msg.GetError().Message);
			UnityEngine.Application.Quit();
		}

		public void QuitButtonPressed()
		{
			UnityEngine.Application.Quit();
		}

		private void OnApplicationQuit()
		{
			Matchmaking.LeaveQueue();
		}

		public static void TransitionToState(State newState)
		{
			if ((bool)s_instance && s_instance.m_currentState != newState)
			{
				s_instance.m_currentState = newState;
			}
		}
	}
	public abstract class Player : MonoBehaviour
	{
		public const uint MAX_BALLS = 6u;

		private const float INITIAL_FORCE = 870f;

		private const float RESPAWN_SECONDS = 2f;

		private uint m_score;

		private Text m_scoreUI;

		private GameObject m_ballPrefab;

		private BallEjector m_ballEjector;

		private Queue<GameObject> m_balls = new Queue<GameObject>();

		private GameObject m_heldBall;

		private float m_nextSpawnTime;

		public virtual uint Score
		{
			get
			{
				return m_score;
			}
			set
			{
				m_score = value;
				if ((bool)m_scoreUI)
				{
					m_scoreUI.text = m_score.ToString();
				}
			}
		}

		public GameObject BallPrefab
		{
			set
			{
				m_ballPrefab = value;
			}
		}

		protected bool HasBall => m_heldBall != null;

		private void Start()
		{
			m_ballEjector = base.transform.GetComponentInChildren<BallEjector>();
			m_scoreUI = base.transform.parent.GetComponentInChildren<Text>();
			m_scoreUI.text = "0";
		}

		public GameObject CreateBall()
		{
			if ((long)m_balls.Count >= 6L)
			{
				UnityEngine.Object.Destroy(m_balls.Dequeue());
			}
			GameObject gameObject = UnityEngine.Object.Instantiate(m_ballPrefab);
			m_balls.Enqueue(gameObject);
			gameObject.transform.position = m_ballEjector.transform.position;
			gameObject.transform.SetParent(m_ballEjector.transform, worldPositionStays: true);
			gameObject.GetComponent<Rigidbody>().useGravity = false;
			gameObject.GetComponent<Rigidbody>().detectCollisions = false;
			gameObject.GetComponent<DetectBasket>().Player = this;
			return gameObject;
		}

		protected GameObject CheckSpawnBall()
		{
			PlatformManager.State currentState = PlatformManager.CurrentState;
			if ((currentState == PlatformManager.State.WAITING_TO_PRACTICE_OR_MATCHMAKE || currentState == PlatformManager.State.PLAYING_A_LOCAL_MATCH || currentState == PlatformManager.State.PLAYING_A_NETWORKED_MATCH) && Time.time >= m_nextSpawnTime && !HasBall)
			{
				m_heldBall = CreateBall();
				return m_heldBall;
			}
			return null;
		}

		protected GameObject ShootBall()
		{
			GameObject heldBall = m_heldBall;
			m_heldBall = null;
			heldBall.GetComponent<Rigidbody>().useGravity = true;
			heldBall.GetComponent<Rigidbody>().detectCollisions = true;
			heldBall.GetComponent<Rigidbody>().AddForce(m_ballEjector.transform.forward * 870f, ForceMode.Acceleration);
			heldBall.transform.SetParent(base.transform.parent, worldPositionStays: true);
			m_nextSpawnTime = Time.time + 2f;
			return heldBall;
		}

		private void OnDestroy()
		{
			foreach (GameObject ball in m_balls)
			{
				UnityEngine.Object.Destroy(ball);
			}
		}
	}
	public class PlayerArea : MonoBehaviour
	{
		[SerializeField]
		private GameObject m_ballPrefab;

		private GameObject m_playerHead;

		private Text m_nameText;

		private P2PNetworkGoal m_p2pGoal;

		public Player Player => m_playerHead.GetComponent<Player>();

		public Text NameText => m_nameText;

		private void Awake()
		{
			m_playerHead = base.gameObject.transform.Find("Player Head").gameObject;
			m_nameText = base.gameObject.GetComponentsInChildren<Text>()[1];
			m_p2pGoal = base.gameObject.GetComponentInChildren<P2PNetworkGoal>();
		}

		public T SetupForPlayer<T>(string name) where T : Player
		{
			Player component = m_playerHead.GetComponent<Player>();
			if ((bool)component)
			{
				UnityEngine.Object.Destroy(component);
			}
			T val = m_playerHead.AddComponent<T>();
			val.BallPrefab = m_ballPrefab;
			m_nameText.text = name;
			if (val is RemotePlayer)
			{
				(val as RemotePlayer).Goal = m_p2pGoal;
				m_p2pGoal.SendUpdates = false;
			}
			else if (val is LocalPlayer)
			{
				m_p2pGoal.SendUpdates = true;
			}
			else
			{
				m_p2pGoal.SendUpdates = false;
			}
			return val;
		}
	}
	public class RemotePlayer : Player
	{
		private User m_user;

		private P2PNetworkGoal m_goal;

		public User User
		{
			set
			{
				m_user = value;
			}
		}

		public ulong ID => m_user.ID;

		public P2PNetworkGoal Goal
		{
			get
			{
				return m_goal;
			}
			set
			{
				m_goal = value;
			}
		}

		public override uint Score
		{
			set
			{
			}
		}

		public void ReceiveRemoteScore(uint score)
		{
			base.Score = score;
		}
	}
	public class VREyeRaycaster : MonoBehaviour
	{
		[SerializeField]
		private EventSystem m_eventSystem;

		private Button m_currentButton;

		private void Update()
		{
			Button button = null;
			if (Physics.Raycast(base.transform.position, base.transform.forward, out var hitInfo, 50f))
			{
				button = hitInfo.collider.GetComponent<Button>();
			}
			if (button != null)
			{
				if (m_currentButton != button)
				{
					m_currentButton = button;
					m_currentButton.Select();
				}
			}
			else if (m_currentButton != null)
			{
				m_currentButton = null;
				if (m_eventSystem != null)
				{
					m_eventSystem.SetSelectedGameObject(null);
				}
			}
		}
	}
}
namespace Oculus.Platform.Samples.VrVoiceChat
{
	public class P2PManager
	{
		private static readonly float UPDATE_DELAY = 0.1f;

		private ulong m_remoteID;

		private PeerConnectionState m_state;

		private float m_timeForNextUpdate;

		private static readonly byte PACKET_SIZE = 29;

		private static readonly byte PACKET_FORMAT;

		private readonly byte[] sendTransformBuffer = new byte[PACKET_SIZE];

		private readonly byte[] receiveTransformBuffer = new byte[PACKET_SIZE];

		private Vector3 receivedPosition;

		private Vector3 receivedPositionPrior;

		private Quaternion receivedRotation;

		private Quaternion receivedRotationPrior;

		private float receivedTime;

		public bool Connected => m_state == PeerConnectionState.Connected;

		public bool ShouldSendHeadUpdate => Time.time >= m_timeForNextUpdate && m_state == PeerConnectionState.Connected;

		public P2PManager(Transform initialHeadTransform)
		{
			receivedPositionPrior = (receivedPosition = initialHeadTransform.localPosition);
			receivedRotationPrior = (receivedRotation = initialHeadTransform.localRotation);
			Net.SetPeerConnectRequestCallback(PeerConnectRequestCallback);
			Net.SetConnectionStateChangedCallback(ConnectionStateChangedCallback);
		}

		public void ConnectTo(ulong userID)
		{
			m_remoteID = userID;
			if (PlatformManager.MyID < userID)
			{
				Net.Connect(userID);
			}
		}

		public void Disconnect()
		{
			if (m_remoteID != 0)
			{
				Net.Close(m_remoteID);
				m_remoteID = 0uL;
				m_state = PeerConnectionState.Unknown;
			}
		}

		private void PeerConnectRequestCallback(Message<NetworkingPeer> msg)
		{
			Debug.LogFormat("Connection request from {0}, authorized is {1}", msg.Data.ID, m_remoteID);
			if (msg.Data.ID == m_remoteID)
			{
				Net.Accept(msg.Data.ID);
			}
		}

		private void ConnectionStateChangedCallback(Message<NetworkingPeer> msg)
		{
			Debug.LogFormat("Connection state to {0} changed to {1}", msg.Data.ID, msg.Data.State);
			if (msg.Data.ID == m_remoteID)
			{
				m_state = msg.Data.State;
				if (m_state == PeerConnectionState.Timeout && PlatformManager.MyID < m_remoteID)
				{
					Net.Connect(m_remoteID);
				}
			}
			PlatformManager.SetBackgroundColorForState();
		}

		public void SendHeadTransform(Transform headTransform)
		{
			m_timeForNextUpdate = Time.time + UPDATE_DELAY;
			sendTransformBuffer[0] = PACKET_FORMAT;
			int offset = 1;
			PackFloat(headTransform.localPosition.x, sendTransformBuffer, ref offset);
			PackFloat(headTransform.localPosition.y, sendTransformBuffer, ref offset);
			PackFloat(headTransform.localPosition.z, sendTransformBuffer, ref offset);
			PackFloat(headTransform.localRotation.x, sendTransformBuffer, ref offset);
			PackFloat(headTransform.localRotation.y, sendTransformBuffer, ref offset);
			PackFloat(headTransform.localRotation.z, sendTransformBuffer, ref offset);
			PackFloat(headTransform.localRotation.w, sendTransformBuffer, ref offset);
			Net.SendPacket(m_remoteID, sendTransformBuffer, SendPolicy.Unreliable);
		}

		private void PackFloat(float f, byte[] buf, ref int offset)
		{
			Buffer.BlockCopy(BitConverter.GetBytes(f), 0, buf, offset, 4);
			offset += 4;
		}

		public void GetRemoteHeadTransform(Transform headTransform)
		{
			bool flag = false;
			Packet packet;
			while ((packet = Net.ReadPacket()) != null)
			{
				if (packet.Size != PACKET_SIZE)
				{
					Debug.Log("Invalid packet size: " + packet.Size);
					continue;
				}
				packet.ReadBytes(receiveTransformBuffer);
				if (receiveTransformBuffer[0] != PACKET_FORMAT)
				{
					Debug.Log("Invalid packet type: " + packet.Size);
				}
				else
				{
					flag = true;
				}
			}
			if (flag)
			{
				receivedPositionPrior = receivedPosition;
				receivedPosition.x = BitConverter.ToSingle(receiveTransformBuffer, 1);
				receivedPosition.y = BitConverter.ToSingle(receiveTransformBuffer, 5);
				receivedPosition.z = BitConverter.ToSingle(receiveTransformBuffer, 9);
				receivedRotationPrior = receivedRotation;
				receivedRotation.x = BitConverter.ToSingle(receiveTransformBuffer, 13);
				receivedRotation.y = BitConverter.ToSingle(receiveTransformBuffer, 17) * -1f;
				receivedRotation.z = BitConverter.ToSingle(receiveTransformBuffer, 21);
				receivedRotation.w = BitConverter.ToSingle(receiveTransformBuffer, 25) * -1f;
				receivedTime = Time.time;
			}
			float t = Math.Min(Time.time - receivedTime, UPDATE_DELAY) / UPDATE_DELAY;
			headTransform.localPosition = Vector3.Lerp(receivedPositionPrior, receivedPosition, t);
			headTransform.localRotation = Quaternion.Slerp(receivedRotationPrior, receivedRotation, t);
		}
	}
	public class PlatformManager : MonoBehaviour
	{
		public enum State
		{
			INITIALIZING,
			WAITING_TO_CALL_OR_ANSWER,
			WAITING_FOR_ANSWER,
			CONNECTED_IN_A_ROOM,
			HANGUP
		}

		[SerializeField]
		private GameObject m_invitesList;

		[SerializeField]
		private GameObject m_invitePrefab;

		[SerializeField]
		private Camera m_camera;

		[SerializeField]
		private GameObject m_remoteHead;

		private State m_currentState;

		private static PlatformManager s_instance;

		private RoomManager m_roomManager;

		private P2PManager m_p2pManager;

		private VoipManager m_voipManager;

		private ulong m_myID;

		private string m_myOculusID;

		public static State CurrentState => s_instance.m_currentState;

		public static ulong MyID
		{
			get
			{
				if (s_instance != null)
				{
					return s_instance.m_myID;
				}
				return 0uL;
			}
		}

		public static string MyOculusID
		{
			get
			{
				if (s_instance != null && s_instance.m_myOculusID != null)
				{
					return s_instance.m_myOculusID;
				}
				return string.Empty;
			}
		}

		private void Update()
		{
			if (m_roomManager.ShouldPollInviteList)
			{
				m_roomManager.UpdateActiveInvitesList();
			}
			if (m_p2pManager.ShouldSendHeadUpdate)
			{
				m_p2pManager.SendHeadTransform(m_camera.transform);
			}
			m_p2pManager.GetRemoteHeadTransform(m_remoteHead.transform);
		}

		private void Awake()
		{
			if (s_instance != null)
			{
				UnityEngine.Object.Destroy(base.gameObject);
				return;
			}
			s_instance = this;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			TransitionToState(State.INITIALIZING);
			Core.Initialize();
			m_roomManager = new RoomManager();
			m_p2pManager = new P2PManager(m_remoteHead.transform);
			m_voipManager = new VoipManager(m_remoteHead);
		}

		private void Start()
		{
			Entitlements.IsUserEntitledToApplication().OnComplete(IsEntitledCallback);
		}

		private void IsEntitledCallback(Message msg)
		{
			if (msg.IsError)
			{
				TerminateWithError(msg);
			}
			else
			{
				Users.GetLoggedInUser().OnComplete(GetLoggedInUserCallback);
			}
		}

		private void GetLoggedInUserCallback(Message<User> msg)
		{
			if (msg.IsError)
			{
				TerminateWithError(msg);
				return;
			}
			m_myID = msg.Data.ID;
			m_myOculusID = msg.Data.OculusID;
			TransitionToState(State.WAITING_TO_CALL_OR_ANSWER);
			m_roomManager.CheckForLaunchInvite();
		}

		private void OnApplicationQuit()
		{
			m_roomManager.LeaveCurrentRoom();
			m_p2pManager.Disconnect();
			m_voipManager.Disconnect();
		}

		public static void TerminateWithError(Message msg)
		{
			Debug.Log("Error: " + msg.GetError().Message);
			UnityEngine.Application.Quit();
		}

		public void CallFriendOnClick()
		{
			if (CurrentState == State.WAITING_TO_CALL_OR_ANSWER)
			{
				m_roomManager.CreateRoomAndLaunchInviteMenu();
			}
		}

		public void HangupOnClick()
		{
			m_roomManager.LeaveCurrentRoom();
		}

		public void QuitOnClick()
		{
			UnityEngine.Application.Quit();
		}

		public static void AnswerCallOnClick(ulong roomID)
		{
			if ((bool)s_instance)
			{
				s_instance.m_roomManager.JoinExistingRoom(roomID);
			}
		}

		public static void TransitionToState(State newState)
		{
			Debug.LogFormat("State {0} -> {1}", s_instance.m_currentState, newState);
			if ((bool)s_instance && s_instance.m_currentState != newState)
			{
				s_instance.m_currentState = newState;
				switch (newState)
				{
				case State.HANGUP:
					s_instance.m_roomManager.LeaveCurrentRoom();
					s_instance.m_p2pManager.Disconnect();
					s_instance.m_voipManager.Disconnect();
					break;
				case State.CONNECTED_IN_A_ROOM:
					s_instance.m_p2pManager.ConnectTo(s_instance.m_roomManager.RemoteUserID);
					s_instance.m_voipManager.ConnectTo(s_instance.m_roomManager.RemoteUserID);
					break;
				}
			}
			SetBackgroundColorForState();
		}

		public static void SetBackgroundColorForState()
		{
			switch (s_instance.m_currentState)
			{
			case State.INITIALIZING:
			case State.HANGUP:
				s_instance.m_camera.backgroundColor = Color.black;
				break;
			case State.WAITING_TO_CALL_OR_ANSWER:
				s_instance.m_camera.backgroundColor = new Color(0f, 0f, 0.3f);
				break;
			case State.WAITING_FOR_ANSWER:
				s_instance.m_camera.backgroundColor = new Color(0f, 0f, 0.6f);
				break;
			case State.CONNECTED_IN_A_ROOM:
			{
				float r = ((!s_instance.m_p2pManager.Connected) ? 0f : 1f);
				float g = ((!s_instance.m_voipManager.Connected) ? 0f : 1f);
				s_instance.m_camera.backgroundColor = new Color(r, g, 1f);
				break;
			}
			}
		}

		public static void SetActiveInvites(List<RoomManager.Invite> invites)
		{
			if (!s_instance || !s_instance.m_invitesList || !s_instance.m_invitePrefab)
			{
				return;
			}
			foreach (Transform item in s_instance.m_invitesList.transform)
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
			foreach (RoomManager.Invite invite in invites)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(s_instance.m_invitePrefab);
				gameObject.GetComponentInChildren<Text>().text = invite.OwnerID;
				gameObject.name = invite.RoomID.ToString();
				gameObject.GetComponent<Button>().onClick.AddListener(delegate
				{
					AnswerCallOnClick(invite.RoomID);
				});
				gameObject.transform.SetParent(s_instance.m_invitesList.transform, worldPositionStays: false);
			}
		}
	}
	public class RoomManager
	{
		public struct Invite
		{
			public readonly ulong RoomID;

			public readonly string OwnerID;

			public Invite(ulong roomID, string owner)
			{
				RoomID = roomID;
				OwnerID = owner;
			}
		}

		private ulong m_roomID;

		private User m_remoteUser;

		private static readonly float INVITE_POLL_FREQ_SECONDS = 5f;

		private float m_nextPollTime;

		private HashSet<ulong> m_pendingRoomRequests;

		private List<Invite> m_invites;

		public ulong RemoteUserID => (m_remoteUser == null) ? 0 : m_remoteUser.ID;

		public string RemoteOculusID => (m_remoteUser == null) ? string.Empty : m_remoteUser.OculusID;

		public bool ShouldPollInviteList => m_pendingRoomRequests == null && Time.time >= m_nextPollTime;

		public RoomManager()
		{
			Rooms.SetRoomInviteAcceptedNotificationCallback(LaunchedFromAcceptingInviteCallback);
			Rooms.SetUpdateNotificationCallback(RoomUpdateCallback);
		}

		private void LaunchedFromAcceptingInviteCallback(Message<string> msg)
		{
			if (msg.IsError)
			{
				PlatformManager.TerminateWithError(msg);
				return;
			}
			Debug.Log("Launched Invite to join Room: " + msg.Data);
			m_roomID = Convert.ToUInt64(msg.GetString());
		}

		public bool CheckForLaunchInvite()
		{
			if (m_roomID != 0)
			{
				JoinExistingRoom(m_roomID);
				return true;
			}
			return false;
		}

		public void CreateRoomAndLaunchInviteMenu()
		{
			Rooms.CreateAndJoinPrivate(RoomJoinPolicy.InvitedUsers, 2u, subscribeToUpdates: true).OnComplete(CreateAndJoinPrivateRoomCallback);
		}

		private void CreateAndJoinPrivateRoomCallback(Message<Oculus.Platform.Models.Room> msg)
		{
			if (msg.IsError)
			{
				PlatformManager.TerminateWithError(msg);
				return;
			}
			m_roomID = msg.Data.ID;
			m_remoteUser = null;
			PlatformManager.TransitionToState(PlatformManager.State.WAITING_FOR_ANSWER);
			Rooms.LaunchInvitableUserFlow(m_roomID).OnComplete(OnLaunchInviteWorkflowComplete);
		}

		private void OnLaunchInviteWorkflowComplete(Message msg)
		{
			if (msg.IsError)
			{
				PlatformManager.TerminateWithError(msg);
			}
		}

		public void UpdateActiveInvitesList()
		{
			m_nextPollTime = Time.time + INVITE_POLL_FREQ_SECONDS;
			m_pendingRoomRequests = new HashSet<ulong>();
			m_invites = new List<Invite>();
			Notifications.GetRoomInviteNotifications().OnComplete(GetRoomInviteNotificationsCallback);
		}

		private void GetRoomInviteNotificationsCallback(Message msg_untyped)
		{
			Message<RoomInviteNotificationList> message = (Message<RoomInviteNotificationList>)msg_untyped;
			if (message.IsError)
			{
				PlatformManager.TerminateWithError(message);
				return;
			}
			foreach (RoomInviteNotification datum in message.Data)
			{
				m_pendingRoomRequests.Add(datum.RoomID);
				Rooms.Get(datum.RoomID).OnComplete(GetRoomInfoCallback);
			}
			if (message.Data.Count == 0)
			{
				m_pendingRoomRequests = null;
				PlatformManager.SetActiveInvites(m_invites);
			}
		}

		private void GetRoomInfoCallback(Message<Oculus.Platform.Models.Room> msg)
		{
			if (msg.IsError)
			{
				PlatformManager.TerminateWithError(msg);
				return;
			}
			if (msg.Data.OwnerOptional != null)
			{
				Invite item = new Invite(msg.Data.ID, msg.Data.OwnerOptional.OculusID);
				m_pendingRoomRequests.Remove(item.RoomID);
				if (msg.Data.UsersOptional != null && msg.Data.UsersOptional.Count == 1)
				{
					m_invites.Add(item);
				}
			}
			if (m_pendingRoomRequests.Count == 0)
			{
				m_pendingRoomRequests = null;
				PlatformManager.SetActiveInvites(m_invites);
			}
		}

		public void JoinExistingRoom(ulong roomID)
		{
			Rooms.Join(roomID, subscribeToUpdates: true).OnComplete(JoinRoomCallback);
		}

		private void JoinRoomCallback(Message<Oculus.Platform.Models.Room> msg)
		{
			if (msg.IsError)
			{
				return;
			}
			string text = ((msg.Data.OwnerOptional == null) ? string.Empty : msg.Data.OwnerOptional.OculusID);
			int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
			Debug.LogFormat("Joined room: {0} owner: {1} count: ", msg.Data.ID, text, num);
			m_roomID = msg.Data.ID;
			if (msg.Data.UsersOptional == null || msg.Data.UsersOptional.Count != 2)
			{
				PlatformManager.TransitionToState(PlatformManager.State.HANGUP);
			}
			else
			{
				foreach (User item in msg.Data.UsersOptional)
				{
					if (item.ID != PlatformManager.MyID)
					{
						m_remoteUser = item;
					}
				}
				PlatformManager.TransitionToState(PlatformManager.State.CONNECTED_IN_A_ROOM);
			}
			m_nextPollTime = Time.time;
		}

		private void RoomUpdateCallback(Message<Oculus.Platform.Models.Room> msg)
		{
			if (msg.IsError)
			{
				PlatformManager.TerminateWithError(msg);
				return;
			}
			string text = ((msg.Data.OwnerOptional == null) ? string.Empty : msg.Data.OwnerOptional.OculusID);
			int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
			Debug.LogFormat("Room {0} Update: {1} owner: {2} count: ", msg.Data.ID, text, num);
			if (msg.Data.UsersOptional == null || msg.Data.UsersOptional.Count != 2)
			{
				PlatformManager.TransitionToState(PlatformManager.State.HANGUP);
				return;
			}
			foreach (User item in msg.Data.UsersOptional)
			{
				if (item.ID != PlatformManager.MyID)
				{
					m_remoteUser = item;
				}
			}
			PlatformManager.TransitionToState(PlatformManager.State.CONNECTED_IN_A_ROOM);
		}

		public void LeaveCurrentRoom()
		{
			if (m_roomID != 0)
			{
				Rooms.Leave(m_roomID);
				m_roomID = 0uL;
				m_remoteUser = null;
			}
			PlatformManager.TransitionToState(PlatformManager.State.WAITING_TO_CALL_OR_ANSWER);
		}
	}
	public class VoipManager
	{
		private ulong m_remoteID;

		private PeerConnectionState m_state;

		private readonly GameObject m_remoteHead;

		public bool Connected => m_state == PeerConnectionState.Connected;

		public VoipManager(GameObject remoteHead)
		{
			m_remoteHead = remoteHead;
			Voip.SetVoipConnectRequestCallback(VoipConnectRequestCallback);
			Voip.SetVoipStateChangeCallback(VoipStateChangedCallback);
		}

		public void ConnectTo(ulong userID)
		{
			m_remoteID = userID;
			VoipAudioSourceHiLevel voipAudioSourceHiLevel = m_remoteHead.AddComponent<VoipAudioSourceHiLevel>();
			voipAudioSourceHiLevel.senderID = userID;
			if (PlatformManager.MyID < m_remoteID)
			{
				Voip.Start(userID);
			}
		}

		public void Disconnect()
		{
			if (m_remoteID != 0)
			{
				Voip.Stop(m_remoteID);
				UnityEngine.Object.Destroy(m_remoteHead.GetComponent<VoipAudioSourceHiLevel>(), 0f);
				m_remoteID = 0uL;
				m_state = PeerConnectionState.Unknown;
			}
		}

		private void VoipConnectRequestCallback(Message<NetworkingPeer> msg)
		{
			Debug.LogFormat("Voip request from {0}, authorized is {1}", msg.Data.ID, m_remoteID);
			if (msg.Data.ID == m_remoteID)
			{
				Voip.Accept(msg.Data.ID);
			}
		}

		private void VoipStateChangedCallback(Message<NetworkingPeer> msg)
		{
			Debug.LogFormat("Voip state to {0} changed to {1}", msg.Data.ID, msg.Data.State);
			if (msg.Data.ID == m_remoteID)
			{
				m_state = msg.Data.State;
				if (m_state == PeerConnectionState.Timeout && PlatformManager.MyID < m_remoteID)
				{
					Voip.Start(m_remoteID);
				}
			}
			PlatformManager.SetBackgroundColorForState();
		}
	}
	public class VREyeRaycaster : MonoBehaviour
	{
		[SerializeField]
		private EventSystem m_eventSystem;

		private Button m_currentButton;

		private void Update()
		{
			Button button = null;
			if (Physics.Raycast(base.transform.position, base.transform.forward, out var hitInfo, 50f))
			{
				button = hitInfo.collider.GetComponent<Button>();
			}
			if (button != null)
			{
				if (m_currentButton != button)
				{
					m_currentButton = button;
					m_currentButton.Select();
				}
			}
			else if (m_currentButton != null)
			{
				m_currentButton = null;
				if (m_eventSystem != null)
				{
					m_eventSystem.SetSelectedGameObject(null);
				}
			}
		}
	}
}
namespace Oculus.Platform
{
	public class AbuseReportOptions
	{
		private IntPtr Handle;

		public AbuseReportOptions()
		{
			Handle = CAPI.ovr_AbuseReportOptions_Create();
		}

		public void SetPreventPeopleChooser(bool value)
		{
			CAPI.ovr_AbuseReportOptions_SetPreventPeopleChooser(Handle, value);
		}

		public void SetReportType(AbuseReportType value)
		{
			CAPI.ovr_AbuseReportOptions_SetReportType(Handle, value);
		}

		public static explicit operator IntPtr(AbuseReportOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~AbuseReportOptions()
		{
			CAPI.ovr_AbuseReportOptions_Destroy(Handle);
		}
	}
	public enum AbuseReportType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("OBJECT")]
		Object,
		[Description("USER")]
		User
	}
	public enum AchievementType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SIMPLE")]
		Simple,
		[Description("BITFIELD")]
		Bitfield,
		[Description("COUNT")]
		Count
	}
	public class AndroidPlatform
	{
		public bool Initialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			return CAPI.ovr_UnityInitWrapper(appId);
		}

		public Request<PlatformInitialize> AsyncInitialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			return new Request<PlatformInitialize>(CAPI.ovr_UnityInitWrapperAsynchronous(appId));
		}
	}
	public class ApplicationOptions
	{
		private IntPtr Handle;

		public ApplicationOptions()
		{
			Handle = CAPI.ovr_ApplicationOptions_Create();
		}

		public void SetDeeplinkMessage(string value)
		{
			CAPI.ovr_ApplicationOptions_SetDeeplinkMessage(Handle, value);
		}

		public static explicit operator IntPtr(ApplicationOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~ApplicationOptions()
		{
			CAPI.ovr_ApplicationOptions_Destroy(Handle);
		}
	}
}
public class BufferedAudioStream
{
	private const bool VerboseLogging = false;

	private AudioSource audio;

	private float[] audioBuffer;

	private int writePos;

	private const float bufferLengthSeconds = 0.25f;

	private const int sampleRate = 48000;

	private const int bufferSize = 12000;

	private const float playbackDelayTimeSeconds = 0.05f;

	private float playbackDelayRemaining;

	private float remainingBufferTime;

	public BufferedAudioStream(AudioSource audio)
	{
		audioBuffer = new float[12000];
		this.audio = audio;
		audio.loop = true;
		audio.clip = AudioClip.Create(string.Empty, 12000, 1, 48000, stream: false);
		Stop();
	}

	public void Update()
	{
		if (remainingBufferTime > 0f)
		{
			if (!audio.isPlaying && remainingBufferTime > 0.05f)
			{
				playbackDelayRemaining -= Time.deltaTime;
				if (playbackDelayRemaining <= 0f)
				{
					audio.Play();
				}
			}
			if (audio.isPlaying)
			{
				remainingBufferTime -= Time.deltaTime;
				if (remainingBufferTime < 0f)
				{
					remainingBufferTime = 0f;
				}
			}
		}
		if (remainingBufferTime <= 0f)
		{
			if (audio.isPlaying)
			{
				Debug.Log("Buffer empty, stopping " + DateTime.Now);
				Stop();
			}
			else if (writePos != 0)
			{
				Debug.LogError("writePos non zero while not playing, how did this happen?");
			}
		}
	}

	private void Stop()
	{
		audio.Stop();
		audio.time = 0f;
		writePos = 0;
		playbackDelayRemaining = 0.05f;
	}

	public void AddData(float[] samples)
	{
		int num = samples.Length;
		if (writePos > audioBuffer.Length)
		{
			throw new Exception();
		}
		do
		{
			int num2 = num;
			int num3 = audioBuffer.Length - writePos;
			if (num2 > num3)
			{
				num2 = num3;
			}
			Array.Copy(samples, 0, audioBuffer, writePos, num2);
			num -= num2;
			writePos += num2;
			if (writePos > audioBuffer.Length)
			{
				throw new Exception();
			}
			if (writePos == audioBuffer.Length)
			{
				writePos = 0;
			}
		}
		while (num > 0);
		remainingBufferTime += (float)samples.Length / 48000f;
		audio.clip.SetData(audioBuffer, 0);
	}
}
namespace Oculus.Platform
{
	public static class Callback
	{
		private class RequestCallback
		{
			private Message.Callback messageCallback;

			public RequestCallback()
			{
			}

			public RequestCallback(Message.Callback callback)
			{
				messageCallback = callback;
			}

			public virtual void HandleMessage(Message msg)
			{
				if (messageCallback != null)
				{
					messageCallback(msg);
				}
			}
		}

		private sealed class RequestCallback<T> : RequestCallback
		{
			private Message<T>.Callback callback;

			public RequestCallback(Message<T>.Callback callback)
			{
				this.callback = callback;
			}

			public override void HandleMessage(Message msg)
			{
				if (callback != null)
				{
					if (!hasRegisteredRoomInviteNotificationHandler && msg.Type == Message.MessageType.Notification_Room_InviteAccepted)
					{
						pendingRoomInviteNotifications.Add(msg);
					}
					else if (msg is Message<T>)
					{
						callback((Message<T>)msg);
					}
					else
					{
						Debug.LogError("Unable to handle message: " + msg.GetType());
					}
				}
			}
		}

		private static Dictionary<ulong, RequestCallback> requestIDsToCallbacks = new Dictionary<ulong, RequestCallback>();

		private static Dictionary<Message.MessageType, RequestCallback> notificationCallbacks = new Dictionary<Message.MessageType, RequestCallback>();

		private static bool hasRegisteredRoomInviteNotificationHandler = false;

		private static List<Message> pendingRoomInviteNotifications = new List<Message>();

		internal static void SetNotificationCallback<T>(Message.MessageType type, Message<T>.Callback callback)
		{
			if (callback == null)
			{
				throw new Exception("Cannot provide a null notification callback.");
			}
			notificationCallbacks[type] = new RequestCallback<T>(callback);
			if (type == Message.MessageType.Notification_Room_InviteAccepted)
			{
				FlushRoomInviteNotificationQueue();
			}
		}

		internal static void SetNotificationCallback(Message.MessageType type, Message.Callback callback)
		{
			if (callback == null)
			{
				throw new Exception("Cannot provide a null notification callback.");
			}
			notificationCallbacks[type] = new RequestCallback(callback);
		}

		internal static void OnComplete<T>(Request<T> request, Message<T>.Callback callback)
		{
			requestIDsToCallbacks[request.RequestID] = new RequestCallback<T>(callback);
		}

		internal static void OnComplete(Request request, Message.Callback callback)
		{
			requestIDsToCallbacks[request.RequestID] = new RequestCallback(callback);
		}

		internal static void RunCallbacks()
		{
			while (true)
			{
				Message message = Message.PopMessage();
				if (message == null)
				{
					break;
				}
				HandleMessage(message);
			}
		}

		internal static void RunLimitedCallbacks(uint limit)
		{
			for (int i = 0; i < limit; i++)
			{
				Message message = Message.PopMessage();
				if (message == null)
				{
					break;
				}
				HandleMessage(message);
			}
		}

		private static void FlushRoomInviteNotificationQueue()
		{
			hasRegisteredRoomInviteNotificationHandler = true;
			foreach (Message pendingRoomInviteNotification in pendingRoomInviteNotifications)
			{
				HandleMessage(pendingRoomInviteNotification);
			}
			pendingRoomInviteNotifications.Clear();
		}

		private static void HandleMessage(Message msg)
		{
			if (requestIDsToCallbacks.TryGetValue(msg.RequestID, out var value))
			{
				try
				{
					value.HandleMessage(msg);
					return;
				}
				finally
				{
					requestIDsToCallbacks.Remove(msg.RequestID);
				}
			}
			if (notificationCallbacks.TryGetValue(msg.Type, out value))
			{
				value.HandleMessage(msg);
			}
		}
	}
	public class CallbackRunner : MonoBehaviour
	{
		public bool IsPersistantBetweenSceneLoads = true;

		[DllImport("ovrplatformloader")]
		private static extern void ovr_UnityResetTestPlatform();

		private void Awake()
		{
			CallbackRunner callbackRunner = UnityEngine.Object.FindObjectOfType<CallbackRunner>();
			if (callbackRunner != this)
			{
				Debug.LogWarning("You only need one instance of CallbackRunner");
			}
			if (IsPersistantBetweenSceneLoads)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		private void Update()
		{
			Request.RunCallbacks();
		}

		private void OnDestroy()
		{
		}
	}
	public class CAPI
	{
		public struct ovrKeyValuePair
		{
			public string key_;

			private KeyValuePairType valueType_;

			public string stringValue_;

			public int intValue_;

			public double doubleValue_;

			public ovrKeyValuePair(string key, string value)
			{
				key_ = key;
				valueType_ = KeyValuePairType.String;
				stringValue_ = value;
				intValue_ = 0;
				doubleValue_ = 0.0;
			}

			public ovrKeyValuePair(string key, int value)
			{
				key_ = key;
				valueType_ = KeyValuePairType.Int;
				intValue_ = value;
				stringValue_ = null;
				doubleValue_ = 0.0;
			}

			public ovrKeyValuePair(string key, double value)
			{
				key_ = key;
				valueType_ = KeyValuePairType.Double;
				doubleValue_ = value;
				stringValue_ = null;
				intValue_ = 0;
			}
		}

		public struct ovrMatchmakingCriterion
		{
			public string key_;

			public MatchmakingCriterionImportance importance_;

			public IntPtr parameterArray;

			public uint parameterArrayCount;

			public ovrMatchmakingCriterion(string key, MatchmakingCriterionImportance importance)
			{
				key_ = key;
				importance_ = importance;
				parameterArray = IntPtr.Zero;
				parameterArrayCount = 0u;
			}
		}

		public struct ovrMatchmakingCustomQueryData
		{
			public IntPtr dataArray;

			public uint dataArrayCount;

			public IntPtr criterionArray;

			public uint criterionArrayCount;
		}

		public struct OculusInitParams
		{
			public int sType;

			public string email;

			public string password;

			public ulong appId;

			public string uriPrefixOverride;
		}

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void FilterCallback([In][Out][MarshalAs(UnmanagedType.LPArray, SizeConst = 480)] short[] pcmData, UIntPtr pcmDataLength, int frequency, int numChannels);

		public const string DLL_NAME = "ovrplatformloader";

		private static UTF8Encoding nativeStringEncoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);

		public const int VoipFilterBufferSize = 480;

		public static IntPtr ArrayOfStructsToIntPtr(Array ar)
		{
			int num = 0;
			for (int i = 0; i < ar.Length; i++)
			{
				num += Marshal.SizeOf(ar.GetValue(i));
			}
			IntPtr intPtr = Marshal.AllocHGlobal(num);
			IntPtr intPtr2 = intPtr;
			for (int j = 0; j < ar.Length; j++)
			{
				Marshal.StructureToPtr(ar.GetValue(j), intPtr2, fDeleteOld: false);
				intPtr2 = (IntPtr)((long)intPtr2 + Marshal.SizeOf(ar.GetValue(j)));
			}
			return intPtr;
		}

		public static ovrKeyValuePair[] DictionaryToOVRKeyValuePairs(Dictionary<string, object> dict)
		{
			if (dict == null || dict.Count == 0)
			{
				return null;
			}
			ovrKeyValuePair[] array = new ovrKeyValuePair[dict.Count];
			int num = 0;
			foreach (KeyValuePair<string, object> item in dict)
			{
				if (item.Value.GetType() == typeof(int))
				{
					ref ovrKeyValuePair reference = ref array[num];
					reference = new ovrKeyValuePair(item.Key, (int)item.Value);
				}
				else if (item.Value.GetType() == typeof(string))
				{
					ref ovrKeyValuePair reference2 = ref array[num];
					reference2 = new ovrKeyValuePair(item.Key, (string)item.Value);
				}
				else
				{
					if (item.Value.GetType() != typeof(double))
					{
						throw new Exception("Only int, double or string are allowed types in CustomQuery.data");
					}
					ref ovrKeyValuePair reference3 = ref array[num];
					reference3 = new ovrKeyValuePair(item.Key, (double)item.Value);
				}
				num++;
			}
			return array;
		}

		public static byte[] IntPtrToByteArray(IntPtr data, ulong size)
		{
			byte[] array = new byte[size];
			Marshal.Copy(data, array, 0, (int)size);
			return array;
		}

		public static Dictionary<string, string> DataStoreFromNative(IntPtr pointer)
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			int num = (int)(uint)ovr_DataStore_GetNumKeys(pointer);
			for (int i = 0; i < num; i++)
			{
				string key = ovr_DataStore_GetKey(pointer, i);
				dictionary[key] = ovr_DataStore_GetValue(pointer, key);
			}
			return dictionary;
		}

		public static string StringFromNative(IntPtr pointer)
		{
			if (pointer == IntPtr.Zero)
			{
				return null;
			}
			int nativeStringLengthNotIncludingNullTerminator = GetNativeStringLengthNotIncludingNullTerminator(pointer);
			byte[] array = new byte[nativeStringLengthNotIncludingNullTerminator];
			Marshal.Copy(pointer, array, 0, nativeStringLengthNotIncludingNullTerminator);
			return nativeStringEncoding.GetString(array);
		}

		public static int GetNativeStringLengthNotIncludingNullTerminator(IntPtr pointer)
		{
			int i;
			for (i = 0; Marshal.ReadByte(pointer, i) != 0; i++)
			{
			}
			return i;
		}

		public static DateTime DateTimeFromNative(ulong seconds_since_the_one_true_epoch)
		{
			return new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(seconds_since_the_one_true_epoch).ToLocalTime();
		}

		public static byte[] BlobFromNative(uint size, IntPtr pointer)
		{
			byte[] array = new byte[size];
			for (int i = 0; i < (int)size; i++)
			{
				array[i] = Marshal.ReadByte(pointer, i);
			}
			return array;
		}

		public static byte[] FiledataFromNative(uint size, IntPtr pointer)
		{
			byte[] array = new byte[size];
			Marshal.Copy(pointer, array, 0, (int)size);
			return array;
		}

		public static IntPtr StringToNative(string s)
		{
			if (s == null)
			{
				throw new Exception("StringFromNative: null argument");
			}
			int byteCount = nativeStringEncoding.GetByteCount(s);
			byte[] array = new byte[byteCount + 1];
			nativeStringEncoding.GetBytes(s, 0, s.Length, array, 0);
			IntPtr intPtr = Marshal.AllocCoTaskMem(byteCount + 1);
			Marshal.Copy(array, 0, intPtr, byteCount + 1);
			return intPtr;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UnityInitWrapper(string appId);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UnityInitGlobals(IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_UnityInitWrapperAsynchronous(string appId);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UnityInitWrapperStandalone(string accessToken, IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Platform_InitializeStandaloneOculus(ref OculusInitParams init);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PlatformInitializeWithAccessToken(ulong appId, string accessToken);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UnityInitWrapperWindows(string appId, IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_UnityInitWrapperWindowsAsynchronous(string appId, IntPtr loggingCB);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_SetDeveloperAccessToken(string accessToken);

		public static string ovr_GetLoggedInUserLocale()
		{
			return StringFromNative(ovr_GetLoggedInUserLocale_Native());
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_GetLoggedInUserLocale")]
		private static extern IntPtr ovr_GetLoggedInUserLocale_Native();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_PopMessage();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_FreeMessage(IntPtr message);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_NetworkingPeer_GetSendPolicy(IntPtr networkingPeer);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Voip_CreateEncoder();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_DestroyEncoder(IntPtr encoder);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Voip_CreateDecoder();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_DestroyDecoder(IntPtr decoder);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipDecoder_Decode(IntPtr obj, byte[] compressedData, ulong compressedSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Microphone_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_Destroy(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetSystemVoipPassthrough(bool passthrough);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetSystemVoipMicrophoneMuted(VoipMuteState muted);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UnityResetTestPlatform();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_HTTP_GetWithMessageType(string url, int messageType);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_CrashApplication();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetMicrophoneFilterCallback(FilterCallback cb);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetMicrophoneFilterCallbackWithFixedSizeBuffer(FilterCallback cb, UIntPtr bufferSizeElements);

		public static void LogNewEvent(string eventName, Dictionary<string, string> values)
		{
			IntPtr intPtr = StringToNative(eventName);
			int num = values?.Count ?? 0;
			IntPtr[] array = new IntPtr[num * 2];
			if (num > 0)
			{
				int num2 = 0;
				foreach (KeyValuePair<string, string> value in values)
				{
					ref IntPtr reference = ref array[num2 * 2];
					reference = StringToNative(value.Key);
					ref IntPtr reference2 = ref array[num2 * 2 + 1];
					reference2 = StringToNative(value.Value);
					num2++;
				}
			}
			ovr_Log_NewEvent(intPtr, array, (UIntPtr)(ulong)num);
			Marshal.FreeCoTaskMem(intPtr);
			IntPtr[] array2 = array;
			foreach (IntPtr ptr in array2)
			{
				Marshal.FreeCoTaskMem(ptr);
			}
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Log_NewEvent(IntPtr eventName, IntPtr[] values, UIntPtr length);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_ApplicationLifecycle_GetLaunchDetails();

		public static ulong ovr_HTTP_StartTransfer(string url, ovrKeyValuePair[] headers)
		{
			IntPtr intPtr = StringToNative(url);
			UIntPtr numItems = (UIntPtr)(ulong)headers.Length;
			ulong result = ovr_HTTP_StartTransfer_Native(intPtr, headers, numItems);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_StartTransfer")]
		private static extern ulong ovr_HTTP_StartTransfer_Native(IntPtr url, ovrKeyValuePair[] headers, UIntPtr numItems);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_HTTP_Write(ulong transferId, byte[] bytes, UIntPtr length);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_HTTP_WriteEOM(ulong transferId);

		public static string ovr_Message_GetStringForJavascript(IntPtr message)
		{
			return StringFromNative(ovr_Message_GetStringForJavascript_Native(message));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Message_GetStringForJavascript")]
		private static extern IntPtr ovr_Message_GetStringForJavascript_Native(IntPtr message);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_Accept(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_AcceptForCurrentRoom();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_Close(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_CloseForCurrentRoom();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Net_Connect(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_IsConnected(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Net_Ping(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Net_ReadPacket();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_SendPacket(ulong userID, UIntPtr length, byte[] bytes, SendPolicy policy);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Net_SendPacketToCurrentRoom(UIntPtr length, byte[] bytes, SendPolicy policy);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_Party_PluginGetSharedMemHandle();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipMuteState ovr_Party_PluginGetVoipMicrophoneMuted();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Party_PluginGetVoipPassthrough();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemVoipStatus ovr_Party_PluginGetVoipStatus();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_Accept(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipDtxState ovr_Voip_GetIsConnectionUsingDtx(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipBitrate ovr_Voip_GetLocalBitrate(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetOutputBufferMaxSize();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCM(ulong senderID, short[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMFloat(ulong senderID, float[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMSize(ulong senderID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMWithTimestamp(ulong senderID, short[] outputBuffer, UIntPtr outputBufferNumElements, uint[] timestamp);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Voip_GetPCMWithTimestampFloat(ulong senderID, float[] outputBuffer, UIntPtr outputBufferNumElements, uint[] timestamp);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipBitrate ovr_Voip_GetRemoteBitrate(ulong peerID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Voip_GetSyncTimestamp(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_Voip_GetSyncTimestampDifference(uint lhs, uint rhs);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipMuteState ovr_Voip_GetSystemVoipMicrophoneMuted();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemVoipStatus ovr_Voip_GetSystemVoipStatus();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetMicrophoneMuted(VoipMuteState state);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetNewConnectionOptions(IntPtr voipOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_SetOutputSampleRate(VoipSampleRate rate);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_Start(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Voip_Stop(ulong userID);

		public static ulong ovr_Achievements_AddCount(string name, ulong count)
		{
			IntPtr intPtr = StringToNative(name);
			ulong result = ovr_Achievements_AddCount_Native(intPtr, count);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Achievements_AddCount")]
		private static extern ulong ovr_Achievements_AddCount_Native(IntPtr name, ulong count);

		public static ulong ovr_Achievements_AddFields(string name, string fields)
		{
			IntPtr intPtr = StringToNative(name);
			IntPtr intPtr2 = StringToNative(fields);
			ulong result = ovr_Achievements_AddFields_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Achievements_AddFields")]
		private static extern ulong ovr_Achievements_AddFields_Native(IntPtr name, IntPtr fields);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetAllDefinitions();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetAllProgress();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetDefinitionsByName(string[] names, int count);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Achievements_GetProgressByName(string[] names, int count);

		public static ulong ovr_Achievements_Unlock(string name)
		{
			IntPtr intPtr = StringToNative(name);
			ulong result = ovr_Achievements_Unlock_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Achievements_Unlock")]
		private static extern ulong ovr_Achievements_Unlock_Native(IntPtr name);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_ExecuteCoordinatedLaunch(ulong appID, ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_GetInstalledApplications();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_GetVersion();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_LaunchOtherApp(ulong appID, IntPtr deeplink_options);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_ApplicationLifecycle_GetRegisteredPIDs();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_ApplicationLifecycle_GetSessionKey();

		public static ulong ovr_ApplicationLifecycle_RegisterSessionKey(string sessionKey)
		{
			IntPtr intPtr = StringToNative(sessionKey);
			ulong result = ovr_ApplicationLifecycle_RegisterSessionKey_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationLifecycle_RegisterSessionKey")]
		private static extern ulong ovr_ApplicationLifecycle_RegisterSessionKey_Native(IntPtr sessionKey);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_Delete(ulong assetFileID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_DeleteById(ulong assetFileID);

		public static ulong ovr_AssetFile_DeleteByName(string assetFileName)
		{
			IntPtr intPtr = StringToNative(assetFileName);
			ulong result = ovr_AssetFile_DeleteByName_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFile_DeleteByName")]
		private static extern ulong ovr_AssetFile_DeleteByName_Native(IntPtr assetFileName);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_Download(ulong assetFileID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_DownloadById(ulong assetFileID);

		public static ulong ovr_AssetFile_DownloadByName(string assetFileName)
		{
			IntPtr intPtr = StringToNative(assetFileName);
			ulong result = ovr_AssetFile_DownloadByName_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFile_DownloadByName")]
		private static extern ulong ovr_AssetFile_DownloadByName_Native(IntPtr assetFileName);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_DownloadCancel(ulong assetFileID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_DownloadCancelById(ulong assetFileID);

		public static ulong ovr_AssetFile_DownloadCancelByName(string assetFileName)
		{
			IntPtr intPtr = StringToNative(assetFileName);
			ulong result = ovr_AssetFile_DownloadCancelByName_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFile_DownloadCancelByName")]
		private static extern ulong ovr_AssetFile_DownloadCancelByName_Native(IntPtr assetFileName);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_GetList();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_Status(ulong assetFileID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFile_StatusById(ulong assetFileID);

		public static ulong ovr_AssetFile_StatusByName(string assetFileName)
		{
			IntPtr intPtr = StringToNative(assetFileName);
			ulong result = ovr_AssetFile_StatusByName_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFile_StatusByName")]
		private static extern ulong ovr_AssetFile_StatusByName_Native(IntPtr assetFileName);

		public static ulong ovr_Avatar_UpdateMetaData(string avatarMetaData, string imageFilePath)
		{
			IntPtr intPtr = StringToNative(avatarMetaData);
			IntPtr intPtr2 = StringToNative(imageFilePath);
			ulong result = ovr_Avatar_UpdateMetaData_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Avatar_UpdateMetaData")]
		private static extern ulong ovr_Avatar_UpdateMetaData_Native(IntPtr avatarMetaData, IntPtr imageFilePath);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Cal_FinalizeApplication(ulong groupingObject, ulong[] userIDs, int numUserIDs, ulong finalized_application_ID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Cal_GetSuggestedApplications(ulong groupingObject, ulong[] userIDs, int numUserIDs);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Cal_ProposeApplication(ulong groupingObject, ulong[] userIDs, int numUserIDs, ulong proposed_application_ID);

		public static ulong ovr_CloudStorage_Delete(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_Delete_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_Delete")]
		private static extern ulong ovr_CloudStorage_Delete_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_Load(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_Load_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_Load")]
		private static extern ulong ovr_CloudStorage_Load_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_LoadBucketMetadata(string bucket)
		{
			IntPtr intPtr = StringToNative(bucket);
			ulong result = ovr_CloudStorage_LoadBucketMetadata_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadBucketMetadata")]
		private static extern ulong ovr_CloudStorage_LoadBucketMetadata_Native(IntPtr bucket);

		public static ulong ovr_CloudStorage_LoadConflictMetadata(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_LoadConflictMetadata_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadConflictMetadata")]
		private static extern ulong ovr_CloudStorage_LoadConflictMetadata_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_LoadHandle(string handle)
		{
			IntPtr intPtr = StringToNative(handle);
			ulong result = ovr_CloudStorage_LoadHandle_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadHandle")]
		private static extern ulong ovr_CloudStorage_LoadHandle_Native(IntPtr handle);

		public static ulong ovr_CloudStorage_LoadMetadata(string bucket, string key)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			ulong result = ovr_CloudStorage_LoadMetadata_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_LoadMetadata")]
		private static extern ulong ovr_CloudStorage_LoadMetadata_Native(IntPtr bucket, IntPtr key);

		public static ulong ovr_CloudStorage_ResolveKeepLocal(string bucket, string key, string remoteHandle)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			IntPtr intPtr3 = StringToNative(remoteHandle);
			ulong result = ovr_CloudStorage_ResolveKeepLocal_Native(intPtr, intPtr2, intPtr3);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_ResolveKeepLocal")]
		private static extern ulong ovr_CloudStorage_ResolveKeepLocal_Native(IntPtr bucket, IntPtr key, IntPtr remoteHandle);

		public static ulong ovr_CloudStorage_ResolveKeepRemote(string bucket, string key, string remoteHandle)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			IntPtr intPtr3 = StringToNative(remoteHandle);
			ulong result = ovr_CloudStorage_ResolveKeepRemote_Native(intPtr, intPtr2, intPtr3);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_ResolveKeepRemote")]
		private static extern ulong ovr_CloudStorage_ResolveKeepRemote_Native(IntPtr bucket, IntPtr key, IntPtr remoteHandle);

		public static ulong ovr_CloudStorage_Save(string bucket, string key, byte[] data, uint dataSize, long counter, string extraData)
		{
			IntPtr intPtr = StringToNative(bucket);
			IntPtr intPtr2 = StringToNative(key);
			IntPtr intPtr3 = StringToNative(extraData);
			ulong result = ovr_CloudStorage_Save_Native(intPtr, intPtr2, data, dataSize, counter, intPtr3);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage_Save")]
		private static extern ulong ovr_CloudStorage_Save_Native(IntPtr bucket, IntPtr key, byte[] data, uint dataSize, long counter, IntPtr extraData);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CloudStorage2_GetUserDirectoryPath();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Entitlement_GetIsViewerEntitled();

		public static ulong ovr_GraphAPI_Get(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_GraphAPI_Get_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_GraphAPI_Get")]
		private static extern ulong ovr_GraphAPI_Get_Native(IntPtr url);

		public static ulong ovr_GraphAPI_Post(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_GraphAPI_Post_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_GraphAPI_Post")]
		private static extern ulong ovr_GraphAPI_Post_Native(IntPtr url);

		public static ulong ovr_HTTP_Get(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_HTTP_Get_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_Get")]
		private static extern ulong ovr_HTTP_Get_Native(IntPtr url);

		public static ulong ovr_HTTP_GetToFile(string url, string diskFile)
		{
			IntPtr intPtr = StringToNative(url);
			IntPtr intPtr2 = StringToNative(diskFile);
			ulong result = ovr_HTTP_GetToFile_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_GetToFile")]
		private static extern ulong ovr_HTTP_GetToFile_Native(IntPtr url, IntPtr diskFile);

		public static ulong ovr_HTTP_MultiPartPost(string url, string filepath_param_name, string filepath, string access_token, ovrKeyValuePair[] post_params)
		{
			IntPtr intPtr = StringToNative(url);
			IntPtr intPtr2 = StringToNative(filepath_param_name);
			IntPtr intPtr3 = StringToNative(filepath);
			IntPtr intPtr4 = StringToNative(access_token);
			UIntPtr numItems = (UIntPtr)(ulong)post_params.Length;
			ulong result = ovr_HTTP_MultiPartPost_Native(intPtr, intPtr2, intPtr3, intPtr4, post_params, numItems);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			Marshal.FreeCoTaskMem(intPtr3);
			Marshal.FreeCoTaskMem(intPtr4);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_MultiPartPost")]
		private static extern ulong ovr_HTTP_MultiPartPost_Native(IntPtr url, IntPtr filepath_param_name, IntPtr filepath, IntPtr access_token, ovrKeyValuePair[] post_params, UIntPtr numItems);

		public static ulong ovr_HTTP_Post(string url)
		{
			IntPtr intPtr = StringToNative(url);
			ulong result = ovr_HTTP_Post_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_HTTP_Post")]
		private static extern ulong ovr_HTTP_Post_Native(IntPtr url);

		public static ulong ovr_IAP_ConsumePurchase(string sku)
		{
			IntPtr intPtr = StringToNative(sku);
			ulong result = ovr_IAP_ConsumePurchase_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_IAP_ConsumePurchase")]
		private static extern ulong ovr_IAP_ConsumePurchase_Native(IntPtr sku);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_IAP_GetProductsBySKU(string[] skus, int count);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_IAP_GetViewerPurchases();

		public static ulong ovr_IAP_LaunchCheckoutFlow(string sku)
		{
			IntPtr intPtr = StringToNative(sku);
			ulong result = ovr_IAP_LaunchCheckoutFlow_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_IAP_LaunchCheckoutFlow")]
		private static extern ulong ovr_IAP_LaunchCheckoutFlow_Native(IntPtr sku);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LanguagePack_GetCurrent();

		public static ulong ovr_LanguagePack_SetCurrent(string tag)
		{
			IntPtr intPtr = StringToNative(tag);
			ulong result = ovr_LanguagePack_SetCurrent_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LanguagePack_SetCurrent")]
		private static extern ulong ovr_LanguagePack_SetCurrent_Native(IntPtr tag);

		public static ulong ovr_Leaderboard_GetEntries(string leaderboardName, int limit, LeaderboardFilterType filter, LeaderboardStartAt startAt)
		{
			IntPtr intPtr = StringToNative(leaderboardName);
			ulong result = ovr_Leaderboard_GetEntries_Native(intPtr, limit, filter, startAt);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Leaderboard_GetEntries")]
		private static extern ulong ovr_Leaderboard_GetEntries_Native(IntPtr leaderboardName, int limit, LeaderboardFilterType filter, LeaderboardStartAt startAt);

		public static ulong ovr_Leaderboard_GetEntriesAfterRank(string leaderboardName, int limit, ulong afterRank)
		{
			IntPtr intPtr = StringToNative(leaderboardName);
			ulong result = ovr_Leaderboard_GetEntriesAfterRank_Native(intPtr, limit, afterRank);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Leaderboard_GetEntriesAfterRank")]
		private static extern ulong ovr_Leaderboard_GetEntriesAfterRank_Native(IntPtr leaderboardName, int limit, ulong afterRank);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Leaderboard_GetNextEntries(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Leaderboard_GetPreviousEntries(IntPtr handle);

		public static ulong ovr_Leaderboard_WriteEntry(string leaderboardName, long score, byte[] extraData, uint extraDataLength, bool forceUpdate)
		{
			IntPtr intPtr = StringToNative(leaderboardName);
			ulong result = ovr_Leaderboard_WriteEntry_Native(intPtr, score, extraData, extraDataLength, forceUpdate);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Leaderboard_WriteEntry")]
		private static extern ulong ovr_Leaderboard_WriteEntry_Native(IntPtr leaderboardName, long score, byte[] extraData, uint extraDataLength, bool forceUpdate);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_GetStatus();

		public static ulong ovr_Livestreaming_IsAllowedForApplication(string packageName)
		{
			IntPtr intPtr = StringToNative(packageName);
			ulong result = ovr_Livestreaming_IsAllowedForApplication_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Livestreaming_IsAllowedForApplication")]
		private static extern ulong ovr_Livestreaming_IsAllowedForApplication_Native(IntPtr packageName);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_PauseStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_ResumeStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_StartPartyStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_StartStream(LivestreamingAudience audience, LivestreamingMicrophoneStatus micStatus);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_StopPartyStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_StopStream();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_UpdateCommentsOverlayVisibility(bool isVisible);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Livestreaming_UpdateMicStatus(LivestreamingMicrophoneStatus micStatus);

		public static ulong ovr_Matchmaking_Browse(string pool, IntPtr customQueryData)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Browse_Native(intPtr, customQueryData);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Browse")]
		private static extern ulong ovr_Matchmaking_Browse_Native(IntPtr pool, IntPtr customQueryData);

		public static ulong ovr_Matchmaking_Browse2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Browse2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Browse2")]
		private static extern ulong ovr_Matchmaking_Browse2_Native(IntPtr pool, IntPtr matchmakingOptions);

		public static ulong ovr_Matchmaking_Cancel(string pool, string requestHash)
		{
			IntPtr intPtr = StringToNative(pool);
			IntPtr intPtr2 = StringToNative(requestHash);
			ulong result = ovr_Matchmaking_Cancel_Native(intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Cancel")]
		private static extern ulong ovr_Matchmaking_Cancel_Native(IntPtr pool, IntPtr requestHash);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_Cancel2();

		public static ulong ovr_Matchmaking_CreateAndEnqueueRoom(string pool, uint maxUsers, bool subscribeToUpdates, IntPtr customQueryData)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateAndEnqueueRoom_Native(intPtr, maxUsers, subscribeToUpdates, customQueryData);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateAndEnqueueRoom")]
		private static extern ulong ovr_Matchmaking_CreateAndEnqueueRoom_Native(IntPtr pool, uint maxUsers, bool subscribeToUpdates, IntPtr customQueryData);

		public static ulong ovr_Matchmaking_CreateAndEnqueueRoom2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateAndEnqueueRoom2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateAndEnqueueRoom2")]
		private static extern ulong ovr_Matchmaking_CreateAndEnqueueRoom2_Native(IntPtr pool, IntPtr matchmakingOptions);

		public static ulong ovr_Matchmaking_CreateRoom(string pool, uint maxUsers, bool subscribeToUpdates)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateRoom_Native(intPtr, maxUsers, subscribeToUpdates);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateRoom")]
		private static extern ulong ovr_Matchmaking_CreateRoom_Native(IntPtr pool, uint maxUsers, bool subscribeToUpdates);

		public static ulong ovr_Matchmaking_CreateRoom2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_CreateRoom2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_CreateRoom2")]
		private static extern ulong ovr_Matchmaking_CreateRoom2_Native(IntPtr pool, IntPtr matchmakingOptions);

		public static ulong ovr_Matchmaking_Enqueue(string pool, IntPtr customQueryData)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Enqueue_Native(intPtr, customQueryData);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Enqueue")]
		private static extern ulong ovr_Matchmaking_Enqueue_Native(IntPtr pool, IntPtr customQueryData);

		public static ulong ovr_Matchmaking_Enqueue2(string pool, IntPtr matchmakingOptions)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_Enqueue2_Native(intPtr, matchmakingOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_Enqueue2")]
		private static extern ulong ovr_Matchmaking_Enqueue2_Native(IntPtr pool, IntPtr matchmakingOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_EnqueueRoom(ulong roomID, IntPtr customQueryData);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_EnqueueRoom2(ulong roomID, IntPtr matchmakingOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_GetAdminSnapshot();

		public static ulong ovr_Matchmaking_GetStats(string pool, uint maxLevel, MatchmakingStatApproach approach)
		{
			IntPtr intPtr = StringToNative(pool);
			ulong result = ovr_Matchmaking_GetStats_Native(intPtr, maxLevel, approach);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_GetStats")]
		private static extern ulong ovr_Matchmaking_GetStats_Native(IntPtr pool, uint maxLevel, MatchmakingStatApproach approach);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_JoinRoom(ulong roomID, bool subscribeToUpdates);

		public static ulong ovr_Matchmaking_ReportResultInsecure(ulong roomID, ovrKeyValuePair[] data)
		{
			UIntPtr numItems = (UIntPtr)(ulong)data.Length;
			return ovr_Matchmaking_ReportResultInsecure_Native(roomID, data, numItems);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Matchmaking_ReportResultInsecure")]
		private static extern ulong ovr_Matchmaking_ReportResultInsecure_Native(ulong roomID, ovrKeyValuePair[] data, UIntPtr numItems);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Matchmaking_StartMatch(ulong roomID);

		public static ulong ovr_Media_ShareToFacebook(string postTextSuggestion, string filePath, MediaContentType contentType)
		{
			IntPtr intPtr = StringToNative(postTextSuggestion);
			IntPtr intPtr2 = StringToNative(filePath);
			ulong result = ovr_Media_ShareToFacebook_Native(intPtr, intPtr2, contentType);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Media_ShareToFacebook")]
		private static extern ulong ovr_Media_ShareToFacebook_Native(IntPtr postTextSuggestion, IntPtr filePath, MediaContentType contentType);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Notification_GetRoomInvites();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Notification_MarkAsRead(ulong notificationID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GatherInApplication(ulong partyID, ulong appID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Get(ulong partyID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GetCurrent();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GetCurrentForUser(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Invite(ulong partyID, ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Join(ulong partyID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_Leave(ulong partyID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_CreateAndJoinPrivate(RoomJoinPolicy joinPolicy, uint maxUsers, bool subscribeToUpdates);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_CreateAndJoinPrivate2(RoomJoinPolicy joinPolicy, uint maxUsers, IntPtr roomOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Get(ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetCurrent();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetCurrentForUser(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetInvitableUsers();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetInvitableUsers2(IntPtr roomOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetModeratedRooms();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetSocialRooms(ulong appID);

		public static ulong ovr_Room_InviteUser(ulong roomID, string inviteToken)
		{
			IntPtr intPtr = StringToNative(inviteToken);
			ulong result = ovr_Room_InviteUser_Native(roomID, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_InviteUser")]
		private static extern ulong ovr_Room_InviteUser_Native(ulong roomID, IntPtr inviteToken);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Join(ulong roomID, bool subscribeToUpdates);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Join2(ulong roomID, IntPtr roomOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_KickUser(ulong roomID, ulong userID, int kickDurationSeconds);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_LaunchInvitableUserFlow(ulong roomID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_Leave(ulong roomID);

		public static ulong ovr_Room_SetDescription(ulong roomID, string description)
		{
			IntPtr intPtr = StringToNative(description);
			ulong result = ovr_Room_SetDescription_Native(roomID, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_SetDescription")]
		private static extern ulong ovr_Room_SetDescription_Native(ulong roomID, IntPtr description);

		public static ulong ovr_Room_UpdateDataStore(ulong roomID, ovrKeyValuePair[] data)
		{
			UIntPtr numItems = (UIntPtr)(ulong)data.Length;
			return ovr_Room_UpdateDataStore_Native(roomID, data, numItems);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_UpdateDataStore")]
		private static extern ulong ovr_Room_UpdateDataStore_Native(ulong roomID, ovrKeyValuePair[] data, UIntPtr numItems);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdateMembershipLockStatus(ulong roomID, RoomMembershipLockStatus membershipLockStatus);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdateOwner(ulong roomID, ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_UpdatePrivateRoomJoinPolicy(ulong roomID, RoomJoinPolicy newJoinPolicy);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_SystemPermissions_GetStatus(PermissionType permType);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_SystemPermissions_LaunchDeeplink(PermissionType permType);

		public static ulong ovr_User_CancelRecordingForReportFlow(string recordingUUID)
		{
			IntPtr intPtr = StringToNative(recordingUUID);
			ulong result = ovr_User_CancelRecordingForReportFlow_Native(intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_CancelRecordingForReportFlow")]
		private static extern ulong ovr_User_CancelRecordingForReportFlow_Native(IntPtr recordingUUID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_Get(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetAccessToken();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLinkedAccounts(IntPtr userOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUser();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUserFriends();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUserFriendsAndRooms();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetLoggedInUserRecentlyMetUsersAndRooms(IntPtr userOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetOrgScopedID(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetSdkAccounts();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetUserProof();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchBlockFlow(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchFriendRequestFlow(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchProfile(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchReportFlow(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchReportFlow2(ulong optionalUserID, IntPtr abuseReportOptions);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_LaunchUnblockFlow(ulong userID);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_NewEntitledTestUser();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_NewTestUser();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_NewTestUserFriends();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_StartRecordingForReportFlow();

		public static ulong ovr_User_StopRecordingAndLaunchReportFlow(ulong optionalUserID, string optionalRecordingUUID)
		{
			IntPtr intPtr = StringToNative(optionalRecordingUUID);
			ulong result = ovr_User_StopRecordingAndLaunchReportFlow_Native(optionalUserID, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_StopRecordingAndLaunchReportFlow")]
		private static extern ulong ovr_User_StopRecordingAndLaunchReportFlow_Native(ulong optionalUserID, IntPtr optionalRecordingUUID);

		public static ulong ovr_User_StopRecordingAndLaunchReportFlow2(ulong optionalUserID, string optionalRecordingUUID, IntPtr abuseReportOptions)
		{
			IntPtr intPtr = StringToNative(optionalRecordingUUID);
			ulong result = ovr_User_StopRecordingAndLaunchReportFlow2_Native(optionalUserID, intPtr, abuseReportOptions);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_StopRecordingAndLaunchReportFlow2")]
		private static extern ulong ovr_User_StopRecordingAndLaunchReportFlow2_Native(ulong optionalUserID, IntPtr optionalRecordingUUID, IntPtr abuseReportOptions);

		public static ulong ovr_User_TestUserCreateDeviceManifest(string deviceID, ulong[] appIDs, int numAppIDs)
		{
			IntPtr intPtr = StringToNative(deviceID);
			ulong result = ovr_User_TestUserCreateDeviceManifest_Native(intPtr, appIDs, numAppIDs);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_TestUserCreateDeviceManifest")]
		private static extern ulong ovr_User_TestUserCreateDeviceManifest_Native(IntPtr deviceID, ulong[] appIDs, int numAppIDs);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Voip_SetSystemVoipSuppressed(bool suppressed);

		public static string ovr_AbuseReportRecording_GetRecordingUuid(IntPtr obj)
		{
			return StringFromNative(ovr_AbuseReportRecording_GetRecordingUuid_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AbuseReportRecording_GetRecordingUuid")]
		private static extern IntPtr ovr_AbuseReportRecording_GetRecordingUuid_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_AchievementDefinition_GetBitfieldLength(IntPtr obj);

		public static string ovr_AchievementDefinition_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementDefinition_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementDefinition_GetName")]
		private static extern IntPtr ovr_AchievementDefinition_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AchievementDefinition_GetTarget(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern AchievementType ovr_AchievementDefinition_GetType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AchievementDefinitionArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_AchievementDefinitionArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementDefinitionArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementDefinitionArray_GetNextUrl")]
		private static extern IntPtr ovr_AchievementDefinitionArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_AchievementDefinitionArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementDefinitionArray_HasNextPage(IntPtr obj);

		public static string ovr_AchievementProgress_GetBitfield(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementProgress_GetBitfield_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgress_GetBitfield")]
		private static extern IntPtr ovr_AchievementProgress_GetBitfield_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AchievementProgress_GetCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementProgress_GetIsUnlocked(IntPtr obj);

		public static string ovr_AchievementProgress_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementProgress_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgress_GetName")]
		private static extern IntPtr ovr_AchievementProgress_GetName_Native(IntPtr obj);

		public static DateTime ovr_AchievementProgress_GetUnlockTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_AchievementProgress_GetUnlockTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgress_GetUnlockTime")]
		private static extern ulong ovr_AchievementProgress_GetUnlockTime_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AchievementProgressArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_AchievementProgressArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementProgressArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementProgressArray_GetNextUrl")]
		private static extern IntPtr ovr_AchievementProgressArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_AchievementProgressArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementProgressArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AchievementUpdate_GetJustUnlocked(IntPtr obj);

		public static string ovr_AchievementUpdate_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_AchievementUpdate_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AchievementUpdate_GetName")]
		private static extern IntPtr ovr_AchievementUpdate_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Application_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_ApplicationVersion_GetCurrentCode(IntPtr obj);

		public static string ovr_ApplicationVersion_GetCurrentName(IntPtr obj)
		{
			return StringFromNative(ovr_ApplicationVersion_GetCurrentName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationVersion_GetCurrentName")]
		private static extern IntPtr ovr_ApplicationVersion_GetCurrentName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_ApplicationVersion_GetLatestCode(IntPtr obj);

		public static string ovr_ApplicationVersion_GetLatestName(IntPtr obj)
		{
			return StringFromNative(ovr_ApplicationVersion_GetLatestName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationVersion_GetLatestName")]
		private static extern IntPtr ovr_ApplicationVersion_GetLatestName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetDetails_GetAssetId(IntPtr obj);

		public static string ovr_AssetDetails_GetAssetType(IntPtr obj)
		{
			return StringFromNative(ovr_AssetDetails_GetAssetType_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetDetails_GetAssetType")]
		private static extern IntPtr ovr_AssetDetails_GetAssetType_Native(IntPtr obj);

		public static string ovr_AssetDetails_GetDownloadStatus(IntPtr obj)
		{
			return StringFromNative(ovr_AssetDetails_GetDownloadStatus_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetDetails_GetDownloadStatus")]
		private static extern IntPtr ovr_AssetDetails_GetDownloadStatus_Native(IntPtr obj);

		public static string ovr_AssetDetails_GetFilepath(IntPtr obj)
		{
			return StringFromNative(ovr_AssetDetails_GetFilepath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetDetails_GetFilepath")]
		private static extern IntPtr ovr_AssetDetails_GetFilepath_Native(IntPtr obj);

		public static string ovr_AssetDetails_GetIapStatus(IntPtr obj)
		{
			return StringFromNative(ovr_AssetDetails_GetIapStatus_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetDetails_GetIapStatus")]
		private static extern IntPtr ovr_AssetDetails_GetIapStatus_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AssetDetails_GetLanguage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AssetDetailsArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_AssetDetailsArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDeleteResult_GetAssetFileId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDeleteResult_GetAssetId(IntPtr obj);

		public static string ovr_AssetFileDeleteResult_GetFilepath(IntPtr obj)
		{
			return StringFromNative(ovr_AssetFileDeleteResult_GetFilepath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFileDeleteResult_GetFilepath")]
		private static extern IntPtr ovr_AssetFileDeleteResult_GetFilepath_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AssetFileDeleteResult_GetSuccess(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadCancelResult_GetAssetFileId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadCancelResult_GetAssetId(IntPtr obj);

		public static string ovr_AssetFileDownloadCancelResult_GetFilepath(IntPtr obj)
		{
			return StringFromNative(ovr_AssetFileDownloadCancelResult_GetFilepath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFileDownloadCancelResult_GetFilepath")]
		private static extern IntPtr ovr_AssetFileDownloadCancelResult_GetFilepath_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AssetFileDownloadCancelResult_GetSuccess(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadResult_GetAssetId(IntPtr obj);

		public static string ovr_AssetFileDownloadResult_GetFilepath(IntPtr obj)
		{
			return StringFromNative(ovr_AssetFileDownloadResult_GetFilepath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_AssetFileDownloadResult_GetFilepath")]
		private static extern IntPtr ovr_AssetFileDownloadResult_GetFilepath_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadUpdate_GetAssetFileId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_AssetFileDownloadUpdate_GetAssetId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_AssetFileDownloadUpdate_GetBytesTotal(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_AssetFileDownloadUpdate_GetBytesTransferred(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_AssetFileDownloadUpdate_GetCompleted(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_CalApplicationFinalized_GetCountdownMS(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CalApplicationFinalized_GetID(IntPtr obj);

		public static string ovr_CalApplicationFinalized_GetLaunchDetails(IntPtr obj)
		{
			return StringFromNative(ovr_CalApplicationFinalized_GetLaunchDetails_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CalApplicationFinalized_GetLaunchDetails")]
		private static extern IntPtr ovr_CalApplicationFinalized_GetLaunchDetails_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CalApplicationProposed_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CalApplicationSuggestion_GetID(IntPtr obj);

		public static string ovr_CalApplicationSuggestion_GetSocialContext(IntPtr obj)
		{
			return StringFromNative(ovr_CalApplicationSuggestion_GetSocialContext_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CalApplicationSuggestion_GetSocialContext")]
		private static extern IntPtr ovr_CalApplicationSuggestion_GetSocialContext_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CalApplicationSuggestionArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_CalApplicationSuggestionArray_GetSize(IntPtr obj);

		public static string ovr_CloudStorage2UserDirectoryPathResponse_GetPath(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorage2UserDirectoryPathResponse_GetPath_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorage2UserDirectoryPathResponse_GetPath")]
		private static extern IntPtr ovr_CloudStorage2UserDirectoryPathResponse_GetPath_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CloudStorageConflictMetadata_GetLocal(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CloudStorageConflictMetadata_GetRemote(IntPtr obj);

		public static string ovr_CloudStorageData_GetBucket(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageData_GetBucket_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageData_GetBucket")]
		private static extern IntPtr ovr_CloudStorageData_GetBucket_Native(IntPtr obj);

		public static byte[] ovr_CloudStorageData_GetData(IntPtr obj)
		{
			return FiledataFromNative(ovr_CloudStorageData_GetDataSize(obj), ovr_CloudStorageData_GetData_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageData_GetData")]
		private static extern IntPtr ovr_CloudStorageData_GetData_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_CloudStorageData_GetDataSize(IntPtr obj);

		public static string ovr_CloudStorageData_GetKey(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageData_GetKey_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageData_GetKey")]
		private static extern IntPtr ovr_CloudStorageData_GetKey_Native(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetBucket(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetBucket_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetBucket")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetBucket_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_CloudStorageMetadata_GetCounter(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_CloudStorageMetadata_GetDataSize(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetExtraData(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetExtraData_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetExtraData")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetExtraData_Native(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetKey(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetKey_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetKey")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetKey_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_CloudStorageMetadata_GetSaveTime(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern CloudStorageDataStatus ovr_CloudStorageMetadata_GetStatus(IntPtr obj);

		public static string ovr_CloudStorageMetadata_GetVersionHandle(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadata_GetVersionHandle_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadata_GetVersionHandle")]
		private static extern IntPtr ovr_CloudStorageMetadata_GetVersionHandle_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_CloudStorageMetadataArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_CloudStorageMetadataArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageMetadataArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageMetadataArray_GetNextUrl")]
		private static extern IntPtr ovr_CloudStorageMetadataArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_CloudStorageMetadataArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_CloudStorageMetadataArray_HasNextPage(IntPtr obj);

		public static string ovr_CloudStorageUpdateResponse_GetBucket(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageUpdateResponse_GetBucket_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageUpdateResponse_GetBucket")]
		private static extern IntPtr ovr_CloudStorageUpdateResponse_GetBucket_Native(IntPtr obj);

		public static string ovr_CloudStorageUpdateResponse_GetKey(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageUpdateResponse_GetKey_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageUpdateResponse_GetKey")]
		private static extern IntPtr ovr_CloudStorageUpdateResponse_GetKey_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern CloudStorageUpdateStatus ovr_CloudStorageUpdateResponse_GetStatus(IntPtr obj);

		public static string ovr_CloudStorageUpdateResponse_GetVersionHandle(IntPtr obj)
		{
			return StringFromNative(ovr_CloudStorageUpdateResponse_GetVersionHandle_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_CloudStorageUpdateResponse_GetVersionHandle")]
		private static extern IntPtr ovr_CloudStorageUpdateResponse_GetVersionHandle_Native(IntPtr obj);

		public static uint ovr_DataStore_Contains(IntPtr obj, string key)
		{
			IntPtr intPtr = StringToNative(key);
			uint result = ovr_DataStore_Contains_Native(obj, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DataStore_Contains")]
		private static extern uint ovr_DataStore_Contains_Native(IntPtr obj, IntPtr key);

		public static string ovr_DataStore_GetKey(IntPtr obj, int index)
		{
			return StringFromNative(ovr_DataStore_GetKey_Native(obj, index));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DataStore_GetKey")]
		private static extern IntPtr ovr_DataStore_GetKey_Native(IntPtr obj, int index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_DataStore_GetNumKeys(IntPtr obj);

		public static string ovr_DataStore_GetValue(IntPtr obj, string key)
		{
			IntPtr intPtr = StringToNative(key);
			string result = StringFromNative(ovr_DataStore_GetValue_Native(obj, intPtr));
			Marshal.FreeCoTaskMem(intPtr);
			return result;
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_DataStore_GetValue")]
		private static extern IntPtr ovr_DataStore_GetValue_Native(IntPtr obj, IntPtr key);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_Error_GetCode(IntPtr obj);

		public static string ovr_Error_GetDisplayableMessage(IntPtr obj)
		{
			return StringFromNative(ovr_Error_GetDisplayableMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Error_GetDisplayableMessage")]
		private static extern IntPtr ovr_Error_GetDisplayableMessage_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_Error_GetHttpCode(IntPtr obj);

		public static string ovr_Error_GetMessage(IntPtr obj)
		{
			return StringFromNative(ovr_Error_GetMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Error_GetMessage")]
		private static extern IntPtr ovr_Error_GetMessage_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_HttpTransferUpdate_GetBytes(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_HttpTransferUpdate_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_HttpTransferUpdate_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_HttpTransferUpdate_IsCompleted(IntPtr obj);

		public static string ovr_InstalledApplication_GetApplicationId(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetApplicationId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetApplicationId")]
		private static extern IntPtr ovr_InstalledApplication_GetApplicationId_Native(IntPtr obj);

		public static string ovr_InstalledApplication_GetPackageName(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetPackageName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetPackageName")]
		private static extern IntPtr ovr_InstalledApplication_GetPackageName_Native(IntPtr obj);

		public static string ovr_InstalledApplication_GetStatus(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetStatus_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetStatus")]
		private static extern IntPtr ovr_InstalledApplication_GetStatus_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_InstalledApplication_GetVersionCode(IntPtr obj);

		public static string ovr_InstalledApplication_GetVersionName(IntPtr obj)
		{
			return StringFromNative(ovr_InstalledApplication_GetVersionName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_InstalledApplication_GetVersionName")]
		private static extern IntPtr ovr_InstalledApplication_GetVersionName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_InstalledApplicationArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_InstalledApplicationArray_GetSize(IntPtr obj);

		public static string ovr_LanguagePackInfo_GetEnglishName(IntPtr obj)
		{
			return StringFromNative(ovr_LanguagePackInfo_GetEnglishName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LanguagePackInfo_GetEnglishName")]
		private static extern IntPtr ovr_LanguagePackInfo_GetEnglishName_Native(IntPtr obj);

		public static string ovr_LanguagePackInfo_GetNativeName(IntPtr obj)
		{
			return StringFromNative(ovr_LanguagePackInfo_GetNativeName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LanguagePackInfo_GetNativeName")]
		private static extern IntPtr ovr_LanguagePackInfo_GetNativeName_Native(IntPtr obj);

		public static string ovr_LanguagePackInfo_GetTag(IntPtr obj)
		{
			return StringFromNative(ovr_LanguagePackInfo_GetTag_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LanguagePackInfo_GetTag")]
		private static extern IntPtr ovr_LanguagePackInfo_GetTag_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchBlockFlowResult_GetDidBlock(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchBlockFlowResult_GetDidCancel(IntPtr obj);

		public static string ovr_LaunchDetails_GetDeeplinkMessage(IntPtr obj)
		{
			return StringFromNative(ovr_LaunchDetails_GetDeeplinkMessage_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LaunchDetails_GetDeeplinkMessage")]
		private static extern IntPtr ovr_LaunchDetails_GetDeeplinkMessage_Native(IntPtr obj);

		public static string ovr_LaunchDetails_GetLaunchSource(IntPtr obj)
		{
			return StringFromNative(ovr_LaunchDetails_GetLaunchSource_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LaunchDetails_GetLaunchSource")]
		private static extern IntPtr ovr_LaunchDetails_GetLaunchSource_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern LaunchType ovr_LaunchDetails_GetLaunchType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LaunchDetails_GetRoomID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LaunchDetails_GetUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchFriendRequestFlowResult_GetDidCancel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchFriendRequestFlowResult_GetDidSendRequest(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchReportFlowResult_GetDidCancel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LaunchReportFlowResult_GetUserReportId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchUnblockFlowResult_GetDidCancel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LaunchUnblockFlowResult_GetDidUnblock(IntPtr obj);

		public static byte[] ovr_LeaderboardEntry_GetExtraData(IntPtr obj)
		{
			return BlobFromNative(ovr_LeaderboardEntry_GetExtraDataLength(obj), ovr_LeaderboardEntry_GetExtraData_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntry_GetExtraData")]
		private static extern IntPtr ovr_LeaderboardEntry_GetExtraData_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_LeaderboardEntry_GetExtraDataLength(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LeaderboardEntry_GetRank(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern long ovr_LeaderboardEntry_GetScore(IntPtr obj);

		public static DateTime ovr_LeaderboardEntry_GetTimestamp(IntPtr obj)
		{
			return DateTimeFromNative(ovr_LeaderboardEntry_GetTimestamp_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntry_GetTimestamp")]
		private static extern ulong ovr_LeaderboardEntry_GetTimestamp_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LeaderboardEntry_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LeaderboardEntryArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_LeaderboardEntryArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_LeaderboardEntryArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntryArray_GetNextUrl")]
		private static extern IntPtr ovr_LeaderboardEntryArray_GetNextUrl_Native(IntPtr obj);

		public static string ovr_LeaderboardEntryArray_GetPreviousUrl(IntPtr obj)
		{
			return StringFromNative(ovr_LeaderboardEntryArray_GetPreviousUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LeaderboardEntryArray_GetPreviousUrl")]
		private static extern IntPtr ovr_LeaderboardEntryArray_GetPreviousUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_LeaderboardEntryArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_LeaderboardEntryArray_GetTotalCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LeaderboardEntryArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LeaderboardEntryArray_HasPreviousPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LeaderboardUpdateStatus_GetDidUpdate(IntPtr obj);

		public static string ovr_LinkedAccount_GetAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_LinkedAccount_GetAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LinkedAccount_GetAccessToken")]
		private static extern IntPtr ovr_LinkedAccount_GetAccessToken_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ServiceProvider ovr_LinkedAccount_GetServiceProvider(IntPtr obj);

		public static string ovr_LinkedAccount_GetUserId(IntPtr obj)
		{
			return StringFromNative(ovr_LinkedAccount_GetUserId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LinkedAccount_GetUserId")]
		private static extern IntPtr ovr_LinkedAccount_GetUserId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_LinkedAccountArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_LinkedAccountArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingApplicationStatus_GetStreamingEnabled(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern LivestreamingStartStatus ovr_LivestreamingStartResult_GetStreamingResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetCommentsVisible(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetIsPaused(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetLivestreamingEnabled(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LivestreamingStatus_GetLivestreamingType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_LivestreamingStatus_GetMicEnabled(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LivestreamingVideoStats_GetCommentCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ovr_LivestreamingVideoStats_GetReactionCount(IntPtr obj);

		public static string ovr_LivestreamingVideoStats_GetTotalViews(IntPtr obj)
		{
			return StringFromNative(ovr_LivestreamingVideoStats_GetTotalViews_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_LivestreamingVideoStats_GetTotalViews")]
		private static extern IntPtr ovr_LivestreamingVideoStats_GetTotalViews_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingAdminSnapshot_GetCandidates(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshot_GetMyCurrentThreshold(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_MatchmakingAdminSnapshotCandidate_GetCanMatch(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshotCandidate_GetMyTotalScore(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshotCandidate_GetTheirCurrentThreshold(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern double ovr_MatchmakingAdminSnapshotCandidate_GetTheirTotalScore(IntPtr obj);

		public static string ovr_MatchmakingAdminSnapshotCandidate_GetTraceId(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingAdminSnapshotCandidate_GetTraceId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingAdminSnapshotCandidate_GetTraceId")]
		private static extern IntPtr ovr_MatchmakingAdminSnapshotCandidate_GetTraceId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingAdminSnapshotCandidateArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingAdminSnapshotCandidateArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingBrowseResult_GetEnqueueResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingBrowseResult_GetRooms(IntPtr obj);

		public static string ovr_MatchmakingCandidate_GetEntryHash(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingCandidate_GetEntryHash_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingCandidate_GetEntryHash")]
		private static extern IntPtr ovr_MatchmakingCandidate_GetEntryHash_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_MatchmakingCandidate_GetUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingCandidateArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_MatchmakingCandidateArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingCandidateArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingCandidateArray_GetNextUrl")]
		private static extern IntPtr ovr_MatchmakingCandidateArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingCandidateArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_MatchmakingCandidateArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueueResult_GetAdminSnapshot(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetAverageWait(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetMatchesInLastHourCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetMaxExpectedWait(IntPtr obj);

		public static string ovr_MatchmakingEnqueueResult_GetPool(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingEnqueueResult_GetPool_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingEnqueueResult_GetPool")]
		private static extern IntPtr ovr_MatchmakingEnqueueResult_GetPool_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueueResult_GetRecentMatchPercentage(IntPtr obj);

		public static string ovr_MatchmakingEnqueueResult_GetRequestHash(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingEnqueueResult_GetRequestHash_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingEnqueueResult_GetRequestHash")]
		private static extern IntPtr ovr_MatchmakingEnqueueResult_GetRequestHash_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueueResultAndRoom_GetMatchmakingEnqueueResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueueResultAndRoom_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_MatchmakingEnqueuedUser_GetAdditionalUserID(IntPtr obj, uint index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingEnqueuedUser_GetAdditionalUserIDsSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueuedUser_GetCustomData(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueuedUser_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingEnqueuedUserArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingEnqueuedUserArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_MatchmakingNotification_GetAddedByUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingNotification_GetRoom(IntPtr obj);

		public static string ovr_MatchmakingNotification_GetTraceId(IntPtr obj)
		{
			return StringFromNative(ovr_MatchmakingNotification_GetTraceId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingNotification_GetTraceId")]
		private static extern IntPtr ovr_MatchmakingNotification_GetTraceId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingRoom_GetPingTime(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingRoom_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_MatchmakingRoom_HasPingTime(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingRoomArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_MatchmakingRoomArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetDrawCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetLossCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetSkillLevel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_MatchmakingStats_GetWinCount(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAbuseReportRecording(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAchievementDefinitionArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAchievementProgressArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAchievementUpdate(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetApplicationVersion(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetDetails(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetDetailsArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetFileDeleteResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetFileDownloadCancelResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetFileDownloadResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetAssetFileDownloadUpdate(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCalApplicationFinalized(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCalApplicationProposed(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCalApplicationSuggestionArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageConflictMetadata(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageData(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageMetadata(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageMetadataArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetCloudStorageUpdateResponse(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetError(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetHttpTransferUpdate(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetInstalledApplicationArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLaunchBlockFlowResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLaunchFriendRequestFlowResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLaunchReportFlowResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLaunchUnblockFlowResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLeaderboardEntryArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLeaderboardUpdateStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLinkedAccountArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingApplicationStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingStartResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetLivestreamingVideoStats(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingAdminSnapshot(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingBrowseResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingEnqueueResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingEnqueueResultAndRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingRoomArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetMatchmakingStats(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetNativeMessage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetNetworkingPeer(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetOrgScopedID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetParty(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPartyID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPidArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPingResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPlatformInitialize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetProductArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPurchase(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetPurchaseArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Message_GetRequestID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoomArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoomInviteNotification(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetRoomInviteNotificationArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetSdkAccountArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetShareMediaResult(IntPtr obj);

		public static string ovr_Message_GetString(IntPtr obj)
		{
			return StringFromNative(ovr_Message_GetString_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Message_GetString")]
		private static extern IntPtr ovr_Message_GetString_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetSystemPermission(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetSystemVoipState(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern Message.MessageType ovr_Message_GetType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserAndRoomArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserProof(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Message_GetUserReportID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Message_IsError(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetNumSamplesAvailable(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetOutputBufferMaxSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetPCM(IntPtr obj, short[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_GetPCMFloat(IntPtr obj, float[] outputBuffer, UIntPtr outputBufferNumElements);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Microphone_ReadData(IntPtr obj, float[] outputBuffer, UIntPtr outputBufferSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_SetAcceptableRecordingDelayHint(IntPtr obj, UIntPtr delayMs);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_Start(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Microphone_Stop(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_NetworkingPeer_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern PeerConnectionState ovr_NetworkingPeer_GetState(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_OrgScopedID_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_Packet_Free(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Packet_GetBytes(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SendPolicy ovr_Packet_GetSendPolicy(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Packet_GetSenderID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_Packet_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Party_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetInvitedUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetLeader(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Party_GetUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PartyID_GetID(IntPtr obj);

		public static string ovr_Pid_GetId(IntPtr obj)
		{
			return StringFromNative(ovr_Pid_GetId_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Pid_GetId")]
		private static extern IntPtr ovr_Pid_GetId_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_PidArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_PidArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PingResult_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_PingResult_GetPingTimeUsec(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_PingResult_IsTimeout(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern PlatformInitializeResult ovr_PlatformInitialize_GetResult(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Price_GetAmountInHundredths(IntPtr obj);

		public static string ovr_Price_GetCurrency(IntPtr obj)
		{
			return StringFromNative(ovr_Price_GetCurrency_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Price_GetCurrency")]
		private static extern IntPtr ovr_Price_GetCurrency_Native(IntPtr obj);

		public static string ovr_Price_GetFormatted(IntPtr obj)
		{
			return StringFromNative(ovr_Price_GetFormatted_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Price_GetFormatted")]
		private static extern IntPtr ovr_Price_GetFormatted_Native(IntPtr obj);

		public static string ovr_Product_GetDescription(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetDescription_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetDescription")]
		private static extern IntPtr ovr_Product_GetDescription_Native(IntPtr obj);

		public static string ovr_Product_GetFormattedPrice(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetFormattedPrice_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetFormattedPrice")]
		private static extern IntPtr ovr_Product_GetFormattedPrice_Native(IntPtr obj);

		public static string ovr_Product_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetName")]
		private static extern IntPtr ovr_Product_GetName_Native(IntPtr obj);

		public static string ovr_Product_GetSKU(IntPtr obj)
		{
			return StringFromNative(ovr_Product_GetSKU_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Product_GetSKU")]
		private static extern IntPtr ovr_Product_GetSKU_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_ProductArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_ProductArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_ProductArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ProductArray_GetNextUrl")]
		private static extern IntPtr ovr_ProductArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_ProductArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_ProductArray_HasNextPage(IntPtr obj);

		public static DateTime ovr_Purchase_GetExpirationTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_Purchase_GetExpirationTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Purchase_GetExpirationTime")]
		private static extern ulong ovr_Purchase_GetExpirationTime_Native(IntPtr obj);

		public static DateTime ovr_Purchase_GetGrantTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_Purchase_GetGrantTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Purchase_GetGrantTime")]
		private static extern ulong ovr_Purchase_GetGrantTime_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Purchase_GetPurchaseID(IntPtr obj);

		public static string ovr_Purchase_GetSKU(IntPtr obj)
		{
			return StringFromNative(ovr_Purchase_GetSKU_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Purchase_GetSKU")]
		private static extern IntPtr ovr_Purchase_GetSKU_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_PurchaseArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_PurchaseArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_PurchaseArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_PurchaseArray_GetNextUrl")]
		private static extern IntPtr ovr_PurchaseArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_PurchaseArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_PurchaseArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetApplicationID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetDataStore(IntPtr obj);

		public static string ovr_Room_GetDescription(IntPtr obj)
		{
			return StringFromNative(ovr_Room_GetDescription_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_GetDescription")]
		private static extern IntPtr ovr_Room_GetDescription_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_Room_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetInvitedUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_Room_GetIsMembershipLocked(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern RoomJoinPolicy ovr_Room_GetJoinPolicy(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern RoomJoinability ovr_Room_GetJoinability(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetMatchedUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Room_GetMaxUsers(IntPtr obj);

		public static string ovr_Room_GetName(IntPtr obj)
		{
			return StringFromNative(ovr_Room_GetName_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_Room_GetName")]
		private static extern IntPtr ovr_Room_GetName_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetOwner(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern RoomType ovr_Room_GetType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_Room_GetUsers(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovr_Room_GetVersion(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RoomArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_RoomArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_RoomArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomArray_GetNextUrl")]
		private static extern IntPtr ovr_RoomArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_RoomArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_RoomArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RoomInviteNotification_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RoomInviteNotification_GetRoomID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_RoomInviteNotification_GetSenderID(IntPtr obj);

		public static DateTime ovr_RoomInviteNotification_GetSentTime(IntPtr obj)
		{
			return DateTimeFromNative(ovr_RoomInviteNotification_GetSentTime_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomInviteNotification_GetSentTime")]
		private static extern ulong ovr_RoomInviteNotification_GetSentTime_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RoomInviteNotificationArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_RoomInviteNotificationArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_RoomInviteNotificationArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomInviteNotificationArray_GetNextUrl")]
		private static extern IntPtr ovr_RoomInviteNotificationArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_RoomInviteNotificationArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_RoomInviteNotificationArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SdkAccountType ovr_SdkAccount_GetAccountType(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_SdkAccount_GetUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_SdkAccountArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_SdkAccountArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ShareMediaStatus ovr_ShareMediaResult_GetStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_SystemPermission_GetHasPermission(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern PermissionGrantStatus ovr_SystemPermission_GetPermissionGrantStatus(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern VoipMuteState ovr_SystemVoipState_GetMicrophoneMuted(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern SystemVoipStatus ovr_SystemVoipState_GetStatus(IntPtr obj);

		public static string ovr_TestUser_GetAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_TestUser_GetAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUser_GetAccessToken")]
		private static extern IntPtr ovr_TestUser_GetAccessToken_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_TestUser_GetAppAccessArray(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_TestUser_GetFbAppAccessArray(IntPtr obj);

		public static string ovr_TestUser_GetFriendAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_TestUser_GetFriendAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUser_GetFriendAccessToken")]
		private static extern IntPtr ovr_TestUser_GetFriendAccessToken_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_TestUser_GetFriendAppAccessArray(IntPtr obj);

		public static string ovr_TestUser_GetUserAlias(IntPtr obj)
		{
			return StringFromNative(ovr_TestUser_GetUserAlias_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUser_GetUserAlias")]
		private static extern IntPtr ovr_TestUser_GetUserAlias_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUser_GetUserFbid(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUser_GetUserId(IntPtr obj);

		public static string ovr_TestUserAppAccess_GetAccessToken(IntPtr obj)
		{
			return StringFromNative(ovr_TestUserAppAccess_GetAccessToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_TestUserAppAccess_GetAccessToken")]
		private static extern IntPtr ovr_TestUserAppAccess_GetAccessToken_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUserAppAccess_GetAppId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_TestUserAppAccess_GetUserId(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_TestUserAppAccessArray_GetElement(IntPtr obj, UIntPtr index);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_TestUserAppAccessArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_User_GetID(IntPtr obj);

		public static string ovr_User_GetImageUrl(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetImageUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetImageUrl")]
		private static extern IntPtr ovr_User_GetImageUrl_Native(IntPtr obj);

		public static string ovr_User_GetInviteToken(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetInviteToken_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetInviteToken")]
		private static extern IntPtr ovr_User_GetInviteToken_Native(IntPtr obj);

		public static string ovr_User_GetOculusID(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetOculusID_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetOculusID")]
		private static extern IntPtr ovr_User_GetOculusID_Native(IntPtr obj);

		public static string ovr_User_GetPresence(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetPresence_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetPresence")]
		private static extern IntPtr ovr_User_GetPresence_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UserPresenceStatus ovr_User_GetPresenceStatus(IntPtr obj);

		public static string ovr_User_GetSmallImageUrl(IntPtr obj)
		{
			return StringFromNative(ovr_User_GetSmallImageUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_User_GetSmallImageUrl")]
		private static extern IntPtr ovr_User_GetSmallImageUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserAndRoom_GetRoom(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserAndRoom_GetUser(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserAndRoomArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_UserAndRoomArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_UserAndRoomArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_UserAndRoomArray_GetNextUrl")]
		private static extern IntPtr ovr_UserAndRoomArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_UserAndRoomArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UserAndRoomArray_HasNextPage(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserArray_GetElement(IntPtr obj, UIntPtr index);

		public static string ovr_UserArray_GetNextUrl(IntPtr obj)
		{
			return StringFromNative(ovr_UserArray_GetNextUrl_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_UserArray_GetNextUrl")]
		private static extern IntPtr ovr_UserArray_GetNextUrl_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_UserArray_GetSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UserArray_HasNextPage(IntPtr obj);

		public static string ovr_UserProof_GetNonce(IntPtr obj)
		{
			return StringFromNative(ovr_UserProof_GetNonce_Native(obj));
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_UserProof_GetNonce")]
		private static extern IntPtr ovr_UserProof_GetNonce_Native(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovr_UserReportID_GetDidCancel(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovr_UserReportID_GetID(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipDecoder_Decode(IntPtr obj, byte[] compressedData, UIntPtr compressedSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_VoipDecoder_GetDecodedPCM(IntPtr obj, float[] outputBuffer, UIntPtr outputBufferSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipEncoder_AddPCM(IntPtr obj, float[] inputData, uint inputSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_VoipEncoder_GetCompressedData(IntPtr obj, byte[] outputBuffer, UIntPtr intputSize);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr ovr_VoipEncoder_GetCompressedDataSize(IntPtr obj);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_AbuseReportOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_AbuseReportOptions_Destroy(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_AbuseReportOptions_SetPreventPeopleChooser(IntPtr handle, bool value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_AbuseReportOptions_SetReportType(IntPtr handle, AbuseReportType value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_ApplicationOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_ApplicationOptions_Destroy(IntPtr handle);

		public static void ovr_ApplicationOptions_SetDeeplinkMessage(IntPtr handle, string value)
		{
			IntPtr intPtr = StringToNative(value);
			ovr_ApplicationOptions_SetDeeplinkMessage_Native(handle, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_ApplicationOptions_SetDeeplinkMessage")]
		private static extern void ovr_ApplicationOptions_SetDeeplinkMessage_Native(IntPtr handle, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_MatchmakingOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_Destroy(IntPtr handle);

		public static void ovr_MatchmakingOptions_SetCreateRoomDataStoreString(IntPtr handle, string key, string value)
		{
			IntPtr intPtr = StringToNative(key);
			IntPtr intPtr2 = StringToNative(value);
			ovr_MatchmakingOptions_SetCreateRoomDataStoreString_Native(handle, intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetCreateRoomDataStoreString")]
		private static extern void ovr_MatchmakingOptions_SetCreateRoomDataStoreString_Native(IntPtr handle, IntPtr key, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_ClearCreateRoomDataStore(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_SetCreateRoomJoinPolicy(IntPtr handle, RoomJoinPolicy value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_SetCreateRoomMaxUsers(IntPtr handle, uint value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_AddEnqueueAdditionalUser(IntPtr handle, ulong value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_ClearEnqueueAdditionalUsers(IntPtr handle);

		public static void ovr_MatchmakingOptions_SetEnqueueDataSettingsInt(IntPtr handle, string key, int value)
		{
			IntPtr intPtr = StringToNative(key);
			ovr_MatchmakingOptions_SetEnqueueDataSettingsInt_Native(handle, intPtr, value);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueDataSettingsInt")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueDataSettingsInt_Native(IntPtr handle, IntPtr key, int value);

		public static void ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble(IntPtr handle, string key, double value)
		{
			IntPtr intPtr = StringToNative(key);
			ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble_Native(handle, intPtr, value);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble_Native(IntPtr handle, IntPtr key, double value);

		public static void ovr_MatchmakingOptions_SetEnqueueDataSettingsString(IntPtr handle, string key, string value)
		{
			IntPtr intPtr = StringToNative(key);
			IntPtr intPtr2 = StringToNative(value);
			ovr_MatchmakingOptions_SetEnqueueDataSettingsString_Native(handle, intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueDataSettingsString")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueDataSettingsString_Native(IntPtr handle, IntPtr key, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_ClearEnqueueDataSettings(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_MatchmakingOptions_SetEnqueueIsDebug(IntPtr handle, bool value);

		public static void ovr_MatchmakingOptions_SetEnqueueQueryKey(IntPtr handle, string value)
		{
			IntPtr intPtr = StringToNative(value);
			ovr_MatchmakingOptions_SetEnqueueQueryKey_Native(handle, intPtr);
			Marshal.FreeCoTaskMem(intPtr);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_MatchmakingOptions_SetEnqueueQueryKey")]
		private static extern void ovr_MatchmakingOptions_SetEnqueueQueryKey_Native(IntPtr handle, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_RoomOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_Destroy(IntPtr handle);

		public static void ovr_RoomOptions_SetDataStoreString(IntPtr handle, string key, string value)
		{
			IntPtr intPtr = StringToNative(key);
			IntPtr intPtr2 = StringToNative(value);
			ovr_RoomOptions_SetDataStoreString_Native(handle, intPtr, intPtr2);
			Marshal.FreeCoTaskMem(intPtr);
			Marshal.FreeCoTaskMem(intPtr2);
		}

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovr_RoomOptions_SetDataStoreString")]
		private static extern void ovr_RoomOptions_SetDataStoreString_Native(IntPtr handle, IntPtr key, IntPtr value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_ClearDataStore(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetExcludeRecentlyMet(IntPtr handle, bool value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetMaxUserResults(IntPtr handle, uint value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetOrdering(IntPtr handle, UserOrdering value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetRecentlyMetTimeWindow(IntPtr handle, TimeWindow value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetRoomId(IntPtr handle, ulong value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_RoomOptions_SetTurnOffUpdates(IntPtr handle, bool value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_UserOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_Destroy(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_SetMaxUsers(IntPtr handle, uint value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_AddServiceProvider(IntPtr handle, ServiceProvider value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_ClearServiceProviders(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_UserOptions_SetTimeWindow(IntPtr handle, TimeWindow value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovr_VoipOptions_Create();

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipOptions_Destroy(IntPtr handle);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipOptions_SetBitrateForNewConnections(IntPtr handle, VoipBitrate value);

		[DllImport("ovrplatformloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovr_VoipOptions_SetCreateNewConnectionUseDtx(IntPtr handle, VoipDtxState value);
	}
	public enum CloudStorageDataStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("IN_SYNC")]
		InSync,
		[Description("NEEDS_DOWNLOAD")]
		NeedsDownload,
		[Description("REMOTE_DOWNLOADING")]
		RemoteDownloading,
		[Description("NEEDS_UPLOAD")]
		NeedsUpload,
		[Description("LOCAL_UPLOADING")]
		LocalUploading,
		[Description("IN_CONFLICT")]
		InConflict
	}
	public enum CloudStorageUpdateStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("OK")]
		Ok,
		[Description("BETTER_VERSION_STORED")]
		BetterVersionStored,
		[Description("MANUAL_MERGE_REQUIRED")]
		ManualMergeRequired
	}
	public interface IMicrophone
	{
		void Start();

		void Stop();

		float[] Update();
	}
	public interface IVoipPCMSource
	{
		int GetPCM(float[] dest, int length);

		void SetSenderID(ulong senderID);

		void Update();

		int PeekSizeElements();
	}
	public enum KeyValuePairType
	{
		[Description("STRING")]
		String,
		[Description("INTEGER")]
		Int,
		[Description("DOUBLE")]
		Double,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum LaunchType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("NORMAL")]
		Normal,
		[Description("INVITE")]
		Invite,
		[Description("COORDINATED")]
		Coordinated,
		[Description("DEEPLINK")]
		Deeplink
	}
	public enum LeaderboardFilterType
	{
		[Description("NONE")]
		None,
		[Description("FRIENDS")]
		Friends,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum LeaderboardStartAt
	{
		[Description("TOP")]
		Top,
		[Description("CENTERED_ON_VIEWER")]
		CenteredOnViewer,
		[Description("CENTERED_ON_VIEWER_OR_TOP")]
		CenteredOnViewerOrTop,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum LivestreamingAudience
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("PUBLIC")]
		Public,
		[Description("FRIENDS")]
		Friends,
		[Description("ONLY_ME")]
		OnlyMe
	}
	public enum LivestreamingMicrophoneStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MICROPHONE_ON")]
		MicrophoneOn,
		[Description("MICROPHONE_OFF")]
		MicrophoneOff
	}
	public enum LivestreamingStartStatus
	{
		[Description("SUCCESS")]
		Success = 1,
		[Description("UNKNOWN")]
		Unknown = 0,
		[Description("NO_PACKAGE_SET")]
		NoPackageSet = -1,
		[Description("NO_FB_CONNECT")]
		NoFbConnect = -2,
		[Description("NO_SESSION_ID")]
		NoSessionId = -3,
		[Description("MISSING_PARAMETERS")]
		MissingParameters = -4
	}
	public enum MatchmakingCriterionImportance
	{
		[Description("REQUIRED")]
		Required,
		[Description("HIGH")]
		High,
		[Description("MEDIUM")]
		Medium,
		[Description("LOW")]
		Low,
		[Description("UNKNOWN")]
		Unknown
	}
	public class MatchmakingOptions
	{
		private IntPtr Handle;

		public MatchmakingOptions()
		{
			Handle = CAPI.ovr_MatchmakingOptions_Create();
		}

		public void SetCreateRoomDataStore(string key, string value)
		{
			CAPI.ovr_MatchmakingOptions_SetCreateRoomDataStoreString(Handle, key, value);
		}

		public void ClearCreateRoomDataStore()
		{
			CAPI.ovr_MatchmakingOptions_ClearCreateRoomDataStore(Handle);
		}

		public void SetCreateRoomJoinPolicy(RoomJoinPolicy value)
		{
			CAPI.ovr_MatchmakingOptions_SetCreateRoomJoinPolicy(Handle, value);
		}

		public void SetCreateRoomMaxUsers(uint value)
		{
			CAPI.ovr_MatchmakingOptions_SetCreateRoomMaxUsers(Handle, value);
		}

		public void AddEnqueueAdditionalUser(ulong userID)
		{
			CAPI.ovr_MatchmakingOptions_AddEnqueueAdditionalUser(Handle, userID);
		}

		public void ClearEnqueueAdditionalUsers()
		{
			CAPI.ovr_MatchmakingOptions_ClearEnqueueAdditionalUsers(Handle);
		}

		public void SetEnqueueDataSettings(string key, int value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueDataSettingsInt(Handle, key, value);
		}

		public void SetEnqueueDataSettings(string key, double value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueDataSettingsDouble(Handle, key, value);
		}

		public void SetEnqueueDataSettings(string key, string value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueDataSettingsString(Handle, key, value);
		}

		public void ClearEnqueueDataSettings()
		{
			CAPI.ovr_MatchmakingOptions_ClearEnqueueDataSettings(Handle);
		}

		public void SetEnqueueIsDebug(bool value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueIsDebug(Handle, value);
		}

		public void SetEnqueueQueryKey(string value)
		{
			CAPI.ovr_MatchmakingOptions_SetEnqueueQueryKey(Handle, value);
		}

		public static explicit operator IntPtr(MatchmakingOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~MatchmakingOptions()
		{
			CAPI.ovr_MatchmakingOptions_Destroy(Handle);
		}
	}
	public enum MatchmakingStatApproach
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("TRAILING")]
		Trailing,
		[Description("SWINGY")]
		Swingy
	}
	public enum MediaContentType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("PHOTO")]
		Photo
	}
	public abstract class Message<T> : Message
	{
		public new delegate void Callback(Message<T> message);

		private T data;

		public T Data => data;

		public Message(IntPtr c_message)
			: base(c_message)
		{
			if (!base.IsError)
			{
				data = GetDataFromMessage(c_message);
			}
		}

		protected abstract T GetDataFromMessage(IntPtr c_message);
	}
	public class Message
	{
		public delegate void Callback(Message message);

		public enum MessageType : uint
		{
			Unknown = 0u,
			Achievements_AddCount = 65495601u,
			Achievements_AddFields = 346693929u,
			Achievements_GetAllDefinitions = 64177549u,
			Achievements_GetAllProgress = 1335877149u,
			Achievements_GetDefinitionsByName = 1653670332u,
			Achievements_GetNextAchievementDefinitionArrayPage = 712888917u,
			Achievements_GetNextAchievementProgressArrayPage = 792913703u,
			Achievements_GetProgressByName = 354837425u,
			Achievements_Unlock = 1497156573u,
			ApplicationLifecycle_GetRegisteredPIDs = 82169698u,
			ApplicationLifecycle_GetSessionKey = 984570141u,
			ApplicationLifecycle_RegisterSessionKey = 1303818232u,
			Application_GetVersion = 1751583246u,
			Application_LaunchOtherApp = 1424151032u,
			AssetFile_Delete = 1834842246u,
			AssetFile_DeleteById = 1525206354u,
			AssetFile_DeleteByName = 1108001231u,
			AssetFile_Download = 289710021u,
			AssetFile_DownloadById = 755009938u,
			AssetFile_DownloadByName = 1664536314u,
			AssetFile_DownloadCancel = 134927303u,
			AssetFile_DownloadCancelById = 1365611796u,
			AssetFile_DownloadCancelByName = 1147858170u,
			AssetFile_GetList = 1258057588u,
			AssetFile_Status = 47394656u,
			AssetFile_StatusById = 1570069816u,
			AssetFile_StatusByName = 1104140880u,
			CloudStorage_Delete = 685393261u,
			CloudStorage_GetNextCloudStorageMetadataArrayPage = 1544004335u,
			CloudStorage_Load = 1082420033u,
			CloudStorage_LoadBucketMetadata = 1931977997u,
			CloudStorage_LoadConflictMetadata = 1146770162u,
			CloudStorage_LoadHandle = 845863478u,
			CloudStorage_LoadMetadata = 65446546u,
			CloudStorage_ResolveKeepLocal = 811109637u,
			CloudStorage_ResolveKeepRemote = 1965400838u,
			CloudStorage_Save = 1270570030u,
			Entitlement_GetIsViewerEntitled = 409688241u,
			IAP_ConsumePurchase = 532378329u,
			IAP_GetNextProductArrayPage = 467225263u,
			IAP_GetNextPurchaseArrayPage = 1196886677u,
			IAP_GetProductsBySKU = 2124073717u,
			IAP_GetViewerPurchases = 974095385u,
			IAP_LaunchCheckoutFlow = 1067126029u,
			LanguagePack_GetCurrent = 529592533u,
			LanguagePack_SetCurrent = 1531952096u,
			Leaderboard_GetEntries = 1572030284u,
			Leaderboard_GetEntriesAfterRank = 406293487u,
			Leaderboard_GetNextEntries = 1310751961u,
			Leaderboard_GetPreviousEntries = 1224858304u,
			Leaderboard_WriteEntry = 293587198u,
			Livestreaming_GetStatus = 1218079125u,
			Livestreaming_PauseStream = 916223619u,
			Livestreaming_ResumeStream = 575827343u,
			Matchmaking_Browse = 509948616u,
			Matchmaking_Browse2 = 1715641947u,
			Matchmaking_Cancel = 543705519u,
			Matchmaking_Cancel2 = 285117908u,
			Matchmaking_CreateAndEnqueueRoom = 1615617480u,
			Matchmaking_CreateAndEnqueueRoom2 = 693889755u,
			Matchmaking_CreateRoom = 54203178u,
			Matchmaking_CreateRoom2 = 1231922052u,
			Matchmaking_Enqueue = 1086418033u,
			Matchmaking_Enqueue2 = 303174325u,
			Matchmaking_EnqueueRoom = 1888108644u,
			Matchmaking_EnqueueRoom2 = 1428741028u,
			Matchmaking_GetAdminSnapshot = 1008820116u,
			Matchmaking_GetStats = 1123849272u,
			Matchmaking_JoinRoom = 1295177725u,
			Matchmaking_ReportResultInsecure = 439800205u,
			Matchmaking_StartMatch = 1154746693u,
			Media_ShareToFacebook = 14912239u,
			Notification_GetNextRoomInviteNotificationArrayPage = 102890359u,
			Notification_GetRoomInvites = 1871801234u,
			Notification_MarkAsRead = 1903319523u,
			Party_GetCurrent = 1200830304u,
			Room_CreateAndJoinPrivate = 1977017207u,
			Room_CreateAndJoinPrivate2 = 1513775683u,
			Room_Get = 1704628152u,
			Room_GetCurrent = 161916164u,
			Room_GetCurrentForUser = 234887141u,
			Room_GetInvitableUsers = 506615698u,
			Room_GetInvitableUsers2 = 1330899120u,
			Room_GetModeratedRooms = 159645047u,
			Room_GetNextRoomArrayPage = 1317239238u,
			Room_InviteUser = 1093266451u,
			Room_Join = 382373641u,
			Room_Join2 = 1303059522u,
			Room_KickUser = 1233344310u,
			Room_LaunchInvitableUserFlow = 843047539u,
			Room_Leave = 1916281973u,
			Room_SetDescription = 809796911u,
			Room_UpdateDataStore = 40779816u,
			Room_UpdateMembershipLockStatus = 923514796u,
			Room_UpdateOwner = 850803997u,
			Room_UpdatePrivateRoomJoinPolicy = 289473179u,
			User_Get = 1808768583u,
			User_GetAccessToken = 111696574u,
			User_GetLoggedInUser = 1131361373u,
			User_GetLoggedInUserFriends = 1484532365u,
			User_GetLoggedInUserFriendsAndRooms = 1585908615u,
			User_GetLoggedInUserRecentlyMetUsersAndRooms = 694139440u,
			User_GetNextUserAndRoomArrayPage = 2143146719u,
			User_GetNextUserArrayPage = 645723971u,
			User_GetOrgScopedID = 418426907u,
			User_GetSdkAccounts = 1733454467u,
			User_GetUserProof = 578880643u,
			User_LaunchFriendRequestFlow = 151303576u,
			User_LaunchProfile = 171537047u,
			Voip_SetSystemVoipSuppressed = 1161808298u,
			Notification_ApplicationLifecycle_LaunchIntentChanged = 78859427u,
			Notification_AssetFile_DownloadUpdate = 803015885u,
			Notification_Cal_FinalizeApplication = 1963741337u,
			Notification_Cal_ProposeApplication = 779375093u,
			Notification_HTTP_Transfer = 2111073839u,
			Notification_Livestreaming_StatusChange = 575101294u,
			Notification_Matchmaking_MatchFound = 197393623u,
			Notification_Networking_ConnectionStateChange = 1577243802u,
			Notification_Networking_PeerConnectRequest = 1295114959u,
			Notification_Networking_PingResult = 1360343058u,
			Notification_Room_InviteAccepted = 1829794225u,
			Notification_Room_InviteReceived = 1783209300u,
			Notification_Room_RoomUpdate = 1626094639u,
			Notification_Voip_ConnectRequest = 908343318u,
			Notification_Voip_StateChange = 888120928u,
			Notification_Voip_SystemVoipState = 1490179237u,
			Platform_InitializeWithAccessToken = 896085803u,
			Platform_InitializeStandaloneOculus = 1375260172u,
			Platform_InitializeAndroidAsynchronous = 450037684u,
			Platform_InitializeWindowsAsynchronous = 1839708815u
		}

		internal delegate Message ExtraMessageTypesHandler(IntPtr messageHandle, MessageType message_type);

		private MessageType type;

		private ulong requestID;

		private Error error;

		public MessageType Type => type;

		public bool IsError => error != null;

		public ulong RequestID => requestID;

		internal static ExtraMessageTypesHandler HandleExtraMessageTypes { private get; set; }

		public Message(IntPtr c_message)
		{
			type = CAPI.ovr_Message_GetType(c_message);
			bool flag = CAPI.ovr_Message_IsError(c_message);
			requestID = CAPI.ovr_Message_GetRequestID(c_message);
			if (flag)
			{
				IntPtr obj = CAPI.ovr_Message_GetError(c_message);
				error = new Error(CAPI.ovr_Error_GetCode(obj), CAPI.ovr_Error_GetMessage(obj), CAPI.ovr_Error_GetHttpCode(obj));
			}
			else if (Core.LogMessages)
			{
				string text = CAPI.ovr_Message_GetString(c_message);
				if (text != null)
				{
					Debug.Log(text);
				}
				else
				{
					Debug.Log($"null message string {c_message}");
				}
			}
		}

		~Message()
		{
		}

		public virtual Error GetError()
		{
			return error;
		}

		public virtual PingResult GetPingResult()
		{
			return null;
		}

		public virtual NetworkingPeer GetNetworkingPeer()
		{
			return null;
		}

		public virtual HttpTransferUpdate GetHttpTransferUpdate()
		{
			return null;
		}

		public virtual PlatformInitialize GetPlatformInitialize()
		{
			return null;
		}

		public virtual AbuseReportRecording GetAbuseReportRecording()
		{
			return null;
		}

		public virtual AchievementDefinitionList GetAchievementDefinitions()
		{
			return null;
		}

		public virtual AchievementProgressList GetAchievementProgressList()
		{
			return null;
		}

		public virtual AchievementUpdate GetAchievementUpdate()
		{
			return null;
		}

		public virtual ApplicationVersion GetApplicationVersion()
		{
			return null;
		}

		public virtual AssetDetails GetAssetDetails()
		{
			return null;
		}

		public virtual AssetDetailsList GetAssetDetailsList()
		{
			return null;
		}

		public virtual AssetFileDeleteResult GetAssetFileDeleteResult()
		{
			return null;
		}

		public virtual AssetFileDownloadCancelResult GetAssetFileDownloadCancelResult()
		{
			return null;
		}

		public virtual AssetFileDownloadResult GetAssetFileDownloadResult()
		{
			return null;
		}

		public virtual AssetFileDownloadUpdate GetAssetFileDownloadUpdate()
		{
			return null;
		}

		public virtual CalApplicationFinalized GetCalApplicationFinalized()
		{
			return null;
		}

		public virtual CalApplicationProposed GetCalApplicationProposed()
		{
			return null;
		}

		public virtual CalApplicationSuggestionList GetCalApplicationSuggestionList()
		{
			return null;
		}

		public virtual CloudStorageConflictMetadata GetCloudStorageConflictMetadata()
		{
			return null;
		}

		public virtual CloudStorageData GetCloudStorageData()
		{
			return null;
		}

		public virtual CloudStorageMetadata GetCloudStorageMetadata()
		{
			return null;
		}

		public virtual CloudStorageMetadataList GetCloudStorageMetadataList()
		{
			return null;
		}

		public virtual CloudStorageUpdateResponse GetCloudStorageUpdateResponse()
		{
			return null;
		}

		public virtual InstalledApplicationList GetInstalledApplicationList()
		{
			return null;
		}

		public virtual LaunchBlockFlowResult GetLaunchBlockFlowResult()
		{
			return null;
		}

		public virtual LaunchFriendRequestFlowResult GetLaunchFriendRequestFlowResult()
		{
			return null;
		}

		public virtual LaunchReportFlowResult GetLaunchReportFlowResult()
		{
			return null;
		}

		public virtual LaunchUnblockFlowResult GetLaunchUnblockFlowResult()
		{
			return null;
		}

		public virtual bool GetLeaderboardDidUpdate()
		{
			return false;
		}

		public virtual LeaderboardEntryList GetLeaderboardEntryList()
		{
			return null;
		}

		public virtual LinkedAccountList GetLinkedAccountList()
		{
			return null;
		}

		public virtual LivestreamingApplicationStatus GetLivestreamingApplicationStatus()
		{
			return null;
		}

		public virtual LivestreamingStartResult GetLivestreamingStartResult()
		{
			return null;
		}

		public virtual LivestreamingStatus GetLivestreamingStatus()
		{
			return null;
		}

		public virtual LivestreamingVideoStats GetLivestreamingVideoStats()
		{
			return null;
		}

		public virtual MatchmakingAdminSnapshot GetMatchmakingAdminSnapshot()
		{
			return null;
		}

		public virtual MatchmakingBrowseResult GetMatchmakingBrowseResult()
		{
			return null;
		}

		public virtual MatchmakingEnqueueResult GetMatchmakingEnqueueResult()
		{
			return null;
		}

		public virtual MatchmakingEnqueueResultAndRoom GetMatchmakingEnqueueResultAndRoom()
		{
			return null;
		}

		public virtual MatchmakingStats GetMatchmakingStats()
		{
			return null;
		}

		public virtual OrgScopedID GetOrgScopedID()
		{
			return null;
		}

		public virtual Party GetParty()
		{
			return null;
		}

		public virtual PartyID GetPartyID()
		{
			return null;
		}

		public virtual PidList GetPidList()
		{
			return null;
		}

		public virtual ProductList GetProductList()
		{
			return null;
		}

		public virtual Purchase GetPurchase()
		{
			return null;
		}

		public virtual PurchaseList GetPurchaseList()
		{
			return null;
		}

		public virtual Oculus.Platform.Models.Room GetRoom()
		{
			return null;
		}

		public virtual RoomInviteNotification GetRoomInviteNotification()
		{
			return null;
		}

		public virtual RoomInviteNotificationList GetRoomInviteNotificationList()
		{
			return null;
		}

		public virtual RoomList GetRoomList()
		{
			return null;
		}

		public virtual SdkAccountList GetSdkAccountList()
		{
			return null;
		}

		public virtual ShareMediaResult GetShareMediaResult()
		{
			return null;
		}

		public virtual string GetString()
		{
			return null;
		}

		public virtual SystemPermission GetSystemPermission()
		{
			return null;
		}

		public virtual SystemVoipState GetSystemVoipState()
		{
			return null;
		}

		public virtual User GetUser()
		{
			return null;
		}

		public virtual UserAndRoomList GetUserAndRoomList()
		{
			return null;
		}

		public virtual UserList GetUserList()
		{
			return null;
		}

		public virtual UserProof GetUserProof()
		{
			return null;
		}

		public virtual UserReportID GetUserReportID()
		{
			return null;
		}

		internal static Message ParseMessageHandle(IntPtr messageHandle)
		{
			if (messageHandle.ToInt64() == 0)
			{
				return null;
			}
			Message message = null;
			MessageType messageType = CAPI.ovr_Message_GetType(messageHandle);
			switch (messageType)
			{
			case MessageType.Achievements_GetAllDefinitions:
			case MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			case MessageType.Achievements_GetDefinitionsByName:
				message = new MessageWithAchievementDefinitions(messageHandle);
				break;
			case MessageType.Achievements_GetProgressByName:
			case MessageType.Achievements_GetNextAchievementProgressArrayPage:
			case MessageType.Achievements_GetAllProgress:
				message = new MessageWithAchievementProgressList(messageHandle);
				break;
			case MessageType.Achievements_AddCount:
			case MessageType.Achievements_AddFields:
			case MessageType.Achievements_Unlock:
				message = new MessageWithAchievementUpdate(messageHandle);
				break;
			case MessageType.Application_GetVersion:
				message = new MessageWithApplicationVersion(messageHandle);
				break;
			case MessageType.AssetFile_Status:
			case MessageType.LanguagePack_GetCurrent:
			case MessageType.AssetFile_StatusByName:
			case MessageType.AssetFile_StatusById:
				message = new MessageWithAssetDetails(messageHandle);
				break;
			case MessageType.AssetFile_GetList:
				message = new MessageWithAssetDetailsList(messageHandle);
				break;
			case MessageType.AssetFile_DeleteByName:
			case MessageType.AssetFile_DeleteById:
			case MessageType.AssetFile_Delete:
				message = new MessageWithAssetFileDeleteResult(messageHandle);
				break;
			case MessageType.AssetFile_DownloadCancel:
			case MessageType.AssetFile_DownloadCancelByName:
			case MessageType.AssetFile_DownloadCancelById:
				message = new MessageWithAssetFileDownloadCancelResult(messageHandle);
				break;
			case MessageType.AssetFile_Download:
			case MessageType.AssetFile_DownloadById:
			case MessageType.LanguagePack_SetCurrent:
			case MessageType.AssetFile_DownloadByName:
				message = new MessageWithAssetFileDownloadResult(messageHandle);
				break;
			case MessageType.Notification_AssetFile_DownloadUpdate:
				message = new MessageWithAssetFileDownloadUpdate(messageHandle);
				break;
			case MessageType.Notification_Cal_FinalizeApplication:
				message = new MessageWithCalApplicationFinalized(messageHandle);
				break;
			case MessageType.Notification_Cal_ProposeApplication:
				message = new MessageWithCalApplicationProposed(messageHandle);
				break;
			case MessageType.CloudStorage_LoadConflictMetadata:
				message = new MessageWithCloudStorageConflictMetadata(messageHandle);
				break;
			case MessageType.CloudStorage_LoadHandle:
			case MessageType.CloudStorage_Load:
				message = new MessageWithCloudStorageData(messageHandle);
				break;
			case MessageType.CloudStorage_LoadMetadata:
				message = new MessageWithCloudStorageMetadataUnderLocal(messageHandle);
				break;
			case MessageType.CloudStorage_GetNextCloudStorageMetadataArrayPage:
			case MessageType.CloudStorage_LoadBucketMetadata:
				message = new MessageWithCloudStorageMetadataList(messageHandle);
				break;
			case MessageType.CloudStorage_Delete:
			case MessageType.CloudStorage_ResolveKeepLocal:
			case MessageType.CloudStorage_Save:
			case MessageType.CloudStorage_ResolveKeepRemote:
				message = new MessageWithCloudStorageUpdateResponse(messageHandle);
				break;
			case MessageType.User_LaunchProfile:
			case MessageType.Matchmaking_Cancel2:
			case MessageType.Entitlement_GetIsViewerEntitled:
			case MessageType.Matchmaking_ReportResultInsecure:
			case MessageType.IAP_ConsumePurchase:
			case MessageType.Matchmaking_Cancel:
			case MessageType.Room_LaunchInvitableUserFlow:
			case MessageType.Room_UpdateOwner:
			case MessageType.Matchmaking_StartMatch:
			case MessageType.ApplicationLifecycle_RegisterSessionKey:
			case MessageType.Notification_MarkAsRead:
				message = new Message(messageHandle);
				break;
			case MessageType.User_LaunchFriendRequestFlow:
				message = new MessageWithLaunchFriendRequestFlowResult(messageHandle);
				break;
			case MessageType.Leaderboard_GetEntriesAfterRank:
			case MessageType.Leaderboard_GetPreviousEntries:
			case MessageType.Leaderboard_GetNextEntries:
			case MessageType.Leaderboard_GetEntries:
				message = new MessageWithLeaderboardEntryList(messageHandle);
				break;
			case MessageType.Leaderboard_WriteEntry:
				message = new MessageWithLeaderboardDidUpdate(messageHandle);
				break;
			case MessageType.Notification_Livestreaming_StatusChange:
			case MessageType.Livestreaming_ResumeStream:
			case MessageType.Livestreaming_PauseStream:
			case MessageType.Livestreaming_GetStatus:
				message = new MessageWithLivestreamingStatus(messageHandle);
				break;
			case MessageType.Matchmaking_GetAdminSnapshot:
				message = new MessageWithMatchmakingAdminSnapshot(messageHandle);
				break;
			case MessageType.Matchmaking_Browse:
			case MessageType.Matchmaking_Browse2:
				message = new MessageWithMatchmakingBrowseResult(messageHandle);
				break;
			case MessageType.Matchmaking_Enqueue2:
			case MessageType.Matchmaking_Enqueue:
			case MessageType.Matchmaking_EnqueueRoom2:
			case MessageType.Matchmaking_EnqueueRoom:
				message = new MessageWithMatchmakingEnqueueResult(messageHandle);
				break;
			case MessageType.Matchmaking_CreateAndEnqueueRoom2:
			case MessageType.Matchmaking_CreateAndEnqueueRoom:
				message = new MessageWithMatchmakingEnqueueResultAndRoom(messageHandle);
				break;
			case MessageType.Matchmaking_GetStats:
				message = new MessageWithMatchmakingStatsUnderMatchmakingStats(messageHandle);
				break;
			case MessageType.User_GetOrgScopedID:
				message = new MessageWithOrgScopedID(messageHandle);
				break;
			case MessageType.Party_GetCurrent:
				message = new MessageWithPartyUnderCurrentParty(messageHandle);
				break;
			case MessageType.ApplicationLifecycle_GetRegisteredPIDs:
				message = new MessageWithPidList(messageHandle);
				break;
			case MessageType.IAP_GetNextProductArrayPage:
			case MessageType.IAP_GetProductsBySKU:
				message = new MessageWithProductList(messageHandle);
				break;
			case MessageType.IAP_LaunchCheckoutFlow:
				message = new MessageWithPurchase(messageHandle);
				break;
			case MessageType.IAP_GetViewerPurchases:
			case MessageType.IAP_GetNextPurchaseArrayPage:
				message = new MessageWithPurchaseList(messageHandle);
				break;
			case MessageType.Room_Get:
				message = new MessageWithRoom(messageHandle);
				break;
			case MessageType.Room_GetCurrent:
			case MessageType.Room_GetCurrentForUser:
				message = new MessageWithRoomUnderCurrentRoom(messageHandle);
				break;
			case MessageType.Room_UpdateDataStore:
			case MessageType.Matchmaking_CreateRoom:
			case MessageType.Room_UpdatePrivateRoomJoinPolicy:
			case MessageType.Room_Join:
			case MessageType.Room_SetDescription:
			case MessageType.Room_UpdateMembershipLockStatus:
			case MessageType.Room_InviteUser:
			case MessageType.Matchmaking_CreateRoom2:
			case MessageType.Room_KickUser:
			case MessageType.Matchmaking_JoinRoom:
			case MessageType.Room_Join2:
			case MessageType.Room_CreateAndJoinPrivate2:
			case MessageType.Notification_Room_RoomUpdate:
			case MessageType.Room_Leave:
			case MessageType.Room_CreateAndJoinPrivate:
				message = new MessageWithRoomUnderViewerRoom(messageHandle);
				break;
			case MessageType.Room_GetModeratedRooms:
			case MessageType.Room_GetNextRoomArrayPage:
				message = new MessageWithRoomList(messageHandle);
				break;
			case MessageType.Notification_Room_InviteReceived:
				message = new MessageWithRoomInviteNotification(messageHandle);
				break;
			case MessageType.Notification_GetNextRoomInviteNotificationArrayPage:
			case MessageType.Notification_GetRoomInvites:
				message = new MessageWithRoomInviteNotificationList(messageHandle);
				break;
			case MessageType.User_GetSdkAccounts:
				message = new MessageWithSdkAccountList(messageHandle);
				break;
			case MessageType.Media_ShareToFacebook:
				message = new MessageWithShareMediaResult(messageHandle);
				break;
			case MessageType.Notification_ApplicationLifecycle_LaunchIntentChanged:
			case MessageType.User_GetAccessToken:
			case MessageType.ApplicationLifecycle_GetSessionKey:
			case MessageType.Application_LaunchOtherApp:
			case MessageType.Notification_Room_InviteAccepted:
				message = new MessageWithString(messageHandle);
				break;
			case MessageType.Voip_SetSystemVoipSuppressed:
				message = new MessageWithSystemVoipState(messageHandle);
				break;
			case MessageType.User_GetLoggedInUser:
			case MessageType.User_Get:
				message = new MessageWithUser(messageHandle);
				break;
			case MessageType.User_GetLoggedInUserRecentlyMetUsersAndRooms:
			case MessageType.User_GetLoggedInUserFriendsAndRooms:
			case MessageType.User_GetNextUserAndRoomArrayPage:
				message = new MessageWithUserAndRoomList(messageHandle);
				break;
			case MessageType.Room_GetInvitableUsers:
			case MessageType.User_GetNextUserArrayPage:
			case MessageType.Room_GetInvitableUsers2:
			case MessageType.User_GetLoggedInUserFriends:
				message = new MessageWithUserList(messageHandle);
				break;
			case MessageType.User_GetUserProof:
				message = new MessageWithUserProof(messageHandle);
				break;
			case MessageType.Notification_Networking_PeerConnectRequest:
			case MessageType.Notification_Networking_ConnectionStateChange:
				message = new MessageWithNetworkingPeer(messageHandle);
				break;
			case MessageType.Notification_Networking_PingResult:
				message = new MessageWithPingResult(messageHandle);
				break;
			case MessageType.Notification_Matchmaking_MatchFound:
				message = new MessageWithMatchmakingNotification(messageHandle);
				break;
			case MessageType.Notification_Voip_StateChange:
			case MessageType.Notification_Voip_ConnectRequest:
				message = new MessageWithNetworkingPeer(messageHandle);
				break;
			case MessageType.Notification_Voip_SystemVoipState:
				message = new MessageWithSystemVoipState(messageHandle);
				break;
			case MessageType.Notification_HTTP_Transfer:
				message = new MessageWithHttpTransferUpdate(messageHandle);
				break;
			case MessageType.Platform_InitializeAndroidAsynchronous:
			case MessageType.Platform_InitializeWithAccessToken:
			case MessageType.Platform_InitializeStandaloneOculus:
			case MessageType.Platform_InitializeWindowsAsynchronous:
				message = new MessageWithPlatformInitialize(messageHandle);
				break;
			default:
				message = PlatformInternal.ParseMessageHandle(messageHandle, messageType);
				if (message == null)
				{
					Debug.LogError($"Unrecognized message type {messageType}\n");
				}
				break;
			}
			return message;
		}

		public static Message PopMessage()
		{
			if (!Core.IsInitialized())
			{
				return null;
			}
			IntPtr intPtr = CAPI.ovr_PopMessage();
			Message result = ParseMessageHandle(intPtr);
			CAPI.ovr_FreeMessage(intPtr);
			return result;
		}
	}
	public class MessageWithAbuseReportRecording : Message<AbuseReportRecording>
	{
		public MessageWithAbuseReportRecording(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AbuseReportRecording GetAbuseReportRecording()
		{
			return base.Data;
		}

		protected override AbuseReportRecording GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAbuseReportRecording(obj);
			return new AbuseReportRecording(o);
		}
	}
	public class MessageWithAchievementDefinitions : Message<AchievementDefinitionList>
	{
		public MessageWithAchievementDefinitions(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AchievementDefinitionList GetAchievementDefinitions()
		{
			return base.Data;
		}

		protected override AchievementDefinitionList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetAchievementDefinitionArray(obj);
			return new AchievementDefinitionList(a);
		}
	}
	public class MessageWithAchievementProgressList : Message<AchievementProgressList>
	{
		public MessageWithAchievementProgressList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AchievementProgressList GetAchievementProgressList()
		{
			return base.Data;
		}

		protected override AchievementProgressList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetAchievementProgressArray(obj);
			return new AchievementProgressList(a);
		}
	}
	public class MessageWithAchievementUpdate : Message<AchievementUpdate>
	{
		public MessageWithAchievementUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AchievementUpdate GetAchievementUpdate()
		{
			return base.Data;
		}

		protected override AchievementUpdate GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAchievementUpdate(obj);
			return new AchievementUpdate(o);
		}
	}
	public class MessageWithApplicationVersion : Message<ApplicationVersion>
	{
		public MessageWithApplicationVersion(IntPtr c_message)
			: base(c_message)
		{
		}

		public override ApplicationVersion GetApplicationVersion()
		{
			return base.Data;
		}

		protected override ApplicationVersion GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetApplicationVersion(obj);
			return new ApplicationVersion(o);
		}
	}
	public class MessageWithAssetDetails : Message<AssetDetails>
	{
		public MessageWithAssetDetails(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetDetails GetAssetDetails()
		{
			return base.Data;
		}

		protected override AssetDetails GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAssetDetails(obj);
			return new AssetDetails(o);
		}
	}
	public class MessageWithAssetDetailsList : Message<AssetDetailsList>
	{
		public MessageWithAssetDetailsList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetDetailsList GetAssetDetailsList()
		{
			return base.Data;
		}

		protected override AssetDetailsList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetAssetDetailsArray(obj);
			return new AssetDetailsList(a);
		}
	}
	public class MessageWithAssetFileDeleteResult : Message<AssetFileDeleteResult>
	{
		public MessageWithAssetFileDeleteResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetFileDeleteResult GetAssetFileDeleteResult()
		{
			return base.Data;
		}

		protected override AssetFileDeleteResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAssetFileDeleteResult(obj);
			return new AssetFileDeleteResult(o);
		}
	}
	public class MessageWithAssetFileDownloadCancelResult : Message<AssetFileDownloadCancelResult>
	{
		public MessageWithAssetFileDownloadCancelResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetFileDownloadCancelResult GetAssetFileDownloadCancelResult()
		{
			return base.Data;
		}

		protected override AssetFileDownloadCancelResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAssetFileDownloadCancelResult(obj);
			return new AssetFileDownloadCancelResult(o);
		}
	}
	public class MessageWithAssetFileDownloadResult : Message<AssetFileDownloadResult>
	{
		public MessageWithAssetFileDownloadResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetFileDownloadResult GetAssetFileDownloadResult()
		{
			return base.Data;
		}

		protected override AssetFileDownloadResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAssetFileDownloadResult(obj);
			return new AssetFileDownloadResult(o);
		}
	}
	public class MessageWithAssetFileDownloadUpdate : Message<AssetFileDownloadUpdate>
	{
		public MessageWithAssetFileDownloadUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override AssetFileDownloadUpdate GetAssetFileDownloadUpdate()
		{
			return base.Data;
		}

		protected override AssetFileDownloadUpdate GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetAssetFileDownloadUpdate(obj);
			return new AssetFileDownloadUpdate(o);
		}
	}
	public class MessageWithCalApplicationFinalized : Message<CalApplicationFinalized>
	{
		public MessageWithCalApplicationFinalized(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CalApplicationFinalized GetCalApplicationFinalized()
		{
			return base.Data;
		}

		protected override CalApplicationFinalized GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCalApplicationFinalized(obj);
			return new CalApplicationFinalized(o);
		}
	}
	public class MessageWithCalApplicationProposed : Message<CalApplicationProposed>
	{
		public MessageWithCalApplicationProposed(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CalApplicationProposed GetCalApplicationProposed()
		{
			return base.Data;
		}

		protected override CalApplicationProposed GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCalApplicationProposed(obj);
			return new CalApplicationProposed(o);
		}
	}
	public class MessageWithCalApplicationSuggestionList : Message<CalApplicationSuggestionList>
	{
		public MessageWithCalApplicationSuggestionList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CalApplicationSuggestionList GetCalApplicationSuggestionList()
		{
			return base.Data;
		}

		protected override CalApplicationSuggestionList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetCalApplicationSuggestionArray(obj);
			return new CalApplicationSuggestionList(a);
		}
	}
	public class MessageWithCloudStorageConflictMetadata : Message<CloudStorageConflictMetadata>
	{
		public MessageWithCloudStorageConflictMetadata(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageConflictMetadata GetCloudStorageConflictMetadata()
		{
			return base.Data;
		}

		protected override CloudStorageConflictMetadata GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCloudStorageConflictMetadata(obj);
			return new CloudStorageConflictMetadata(o);
		}
	}
	public class MessageWithCloudStorageData : Message<CloudStorageData>
	{
		public MessageWithCloudStorageData(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageData GetCloudStorageData()
		{
			return base.Data;
		}

		protected override CloudStorageData GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCloudStorageData(obj);
			return new CloudStorageData(o);
		}
	}
	public class MessageWithCloudStorageMetadataUnderLocal : Message<CloudStorageMetadata>
	{
		public MessageWithCloudStorageMetadataUnderLocal(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageMetadata GetCloudStorageMetadata()
		{
			return base.Data;
		}

		protected override CloudStorageMetadata GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCloudStorageMetadata(obj);
			return new CloudStorageMetadata(o);
		}
	}
	public class MessageWithCloudStorageMetadataList : Message<CloudStorageMetadataList>
	{
		public MessageWithCloudStorageMetadataList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageMetadataList GetCloudStorageMetadataList()
		{
			return base.Data;
		}

		protected override CloudStorageMetadataList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetCloudStorageMetadataArray(obj);
			return new CloudStorageMetadataList(a);
		}
	}
	public class MessageWithCloudStorageUpdateResponse : Message<CloudStorageUpdateResponse>
	{
		public MessageWithCloudStorageUpdateResponse(IntPtr c_message)
			: base(c_message)
		{
		}

		public override CloudStorageUpdateResponse GetCloudStorageUpdateResponse()
		{
			return base.Data;
		}

		protected override CloudStorageUpdateResponse GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetCloudStorageUpdateResponse(obj);
			return new CloudStorageUpdateResponse(o);
		}
	}
	public class MessageWithInstalledApplicationList : Message<InstalledApplicationList>
	{
		public MessageWithInstalledApplicationList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override InstalledApplicationList GetInstalledApplicationList()
		{
			return base.Data;
		}

		protected override InstalledApplicationList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetInstalledApplicationArray(obj);
			return new InstalledApplicationList(a);
		}
	}
	public class MessageWithLaunchBlockFlowResult : Message<LaunchBlockFlowResult>
	{
		public MessageWithLaunchBlockFlowResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LaunchBlockFlowResult GetLaunchBlockFlowResult()
		{
			return base.Data;
		}

		protected override LaunchBlockFlowResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLaunchBlockFlowResult(obj);
			return new LaunchBlockFlowResult(o);
		}
	}
	public class MessageWithLaunchFriendRequestFlowResult : Message<LaunchFriendRequestFlowResult>
	{
		public MessageWithLaunchFriendRequestFlowResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LaunchFriendRequestFlowResult GetLaunchFriendRequestFlowResult()
		{
			return base.Data;
		}

		protected override LaunchFriendRequestFlowResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLaunchFriendRequestFlowResult(obj);
			return new LaunchFriendRequestFlowResult(o);
		}
	}
	public class MessageWithLaunchReportFlowResult : Message<LaunchReportFlowResult>
	{
		public MessageWithLaunchReportFlowResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LaunchReportFlowResult GetLaunchReportFlowResult()
		{
			return base.Data;
		}

		protected override LaunchReportFlowResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLaunchReportFlowResult(obj);
			return new LaunchReportFlowResult(o);
		}
	}
	public class MessageWithLaunchUnblockFlowResult : Message<LaunchUnblockFlowResult>
	{
		public MessageWithLaunchUnblockFlowResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LaunchUnblockFlowResult GetLaunchUnblockFlowResult()
		{
			return base.Data;
		}

		protected override LaunchUnblockFlowResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLaunchUnblockFlowResult(obj);
			return new LaunchUnblockFlowResult(o);
		}
	}
	public class MessageWithLeaderboardEntryList : Message<LeaderboardEntryList>
	{
		public MessageWithLeaderboardEntryList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LeaderboardEntryList GetLeaderboardEntryList()
		{
			return base.Data;
		}

		protected override LeaderboardEntryList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetLeaderboardEntryArray(obj);
			return new LeaderboardEntryList(a);
		}
	}
	public class MessageWithLinkedAccountList : Message<LinkedAccountList>
	{
		public MessageWithLinkedAccountList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LinkedAccountList GetLinkedAccountList()
		{
			return base.Data;
		}

		protected override LinkedAccountList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetLinkedAccountArray(obj);
			return new LinkedAccountList(a);
		}
	}
	public class MessageWithLivestreamingApplicationStatus : Message<LivestreamingApplicationStatus>
	{
		public MessageWithLivestreamingApplicationStatus(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingApplicationStatus GetLivestreamingApplicationStatus()
		{
			return base.Data;
		}

		protected override LivestreamingApplicationStatus GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLivestreamingApplicationStatus(obj);
			return new LivestreamingApplicationStatus(o);
		}
	}
	public class MessageWithLivestreamingStartResult : Message<LivestreamingStartResult>
	{
		public MessageWithLivestreamingStartResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingStartResult GetLivestreamingStartResult()
		{
			return base.Data;
		}

		protected override LivestreamingStartResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLivestreamingStartResult(obj);
			return new LivestreamingStartResult(o);
		}
	}
	public class MessageWithLivestreamingStatus : Message<LivestreamingStatus>
	{
		public MessageWithLivestreamingStatus(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingStatus GetLivestreamingStatus()
		{
			return base.Data;
		}

		protected override LivestreamingStatus GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLivestreamingStatus(obj);
			return new LivestreamingStatus(o);
		}
	}
	public class MessageWithLivestreamingVideoStats : Message<LivestreamingVideoStats>
	{
		public MessageWithLivestreamingVideoStats(IntPtr c_message)
			: base(c_message)
		{
		}

		public override LivestreamingVideoStats GetLivestreamingVideoStats()
		{
			return base.Data;
		}

		protected override LivestreamingVideoStats GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetLivestreamingVideoStats(obj);
			return new LivestreamingVideoStats(o);
		}
	}
	public class MessageWithMatchmakingAdminSnapshot : Message<MatchmakingAdminSnapshot>
	{
		public MessageWithMatchmakingAdminSnapshot(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingAdminSnapshot GetMatchmakingAdminSnapshot()
		{
			return base.Data;
		}

		protected override MatchmakingAdminSnapshot GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingAdminSnapshot(obj);
			return new MatchmakingAdminSnapshot(o);
		}
	}
	public class MessageWithMatchmakingEnqueueResult : Message<MatchmakingEnqueueResult>
	{
		public MessageWithMatchmakingEnqueueResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingEnqueueResult GetMatchmakingEnqueueResult()
		{
			return base.Data;
		}

		protected override MatchmakingEnqueueResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingEnqueueResult(obj);
			return new MatchmakingEnqueueResult(o);
		}
	}
	public class MessageWithMatchmakingEnqueueResultAndRoom : Message<MatchmakingEnqueueResultAndRoom>
	{
		public MessageWithMatchmakingEnqueueResultAndRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingEnqueueResultAndRoom GetMatchmakingEnqueueResultAndRoom()
		{
			return base.Data;
		}

		protected override MatchmakingEnqueueResultAndRoom GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingEnqueueResultAndRoom(obj);
			return new MatchmakingEnqueueResultAndRoom(o);
		}
	}
	public class MessageWithMatchmakingStatsUnderMatchmakingStats : Message<MatchmakingStats>
	{
		public MessageWithMatchmakingStatsUnderMatchmakingStats(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingStats GetMatchmakingStats()
		{
			return base.Data;
		}

		protected override MatchmakingStats GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingStats(obj);
			return new MatchmakingStats(o);
		}
	}
	public class MessageWithOrgScopedID : Message<OrgScopedID>
	{
		public MessageWithOrgScopedID(IntPtr c_message)
			: base(c_message)
		{
		}

		public override OrgScopedID GetOrgScopedID()
		{
			return base.Data;
		}

		protected override OrgScopedID GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetOrgScopedID(obj);
			return new OrgScopedID(o);
		}
	}
	public class MessageWithParty : Message<Party>
	{
		public MessageWithParty(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Party GetParty()
		{
			return base.Data;
		}

		protected override Party GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetParty(obj);
			return new Party(o);
		}
	}
	public class MessageWithPartyUnderCurrentParty : Message<Party>
	{
		public MessageWithPartyUnderCurrentParty(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Party GetParty()
		{
			return base.Data;
		}

		protected override Party GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetParty(obj);
			return new Party(o);
		}
	}
	public class MessageWithPartyID : Message<PartyID>
	{
		public MessageWithPartyID(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PartyID GetPartyID()
		{
			return base.Data;
		}

		protected override PartyID GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetPartyID(obj);
			return new PartyID(o);
		}
	}
	public class MessageWithPidList : Message<PidList>
	{
		public MessageWithPidList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PidList GetPidList()
		{
			return base.Data;
		}

		protected override PidList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetPidArray(obj);
			return new PidList(a);
		}
	}
	public class MessageWithProductList : Message<ProductList>
	{
		public MessageWithProductList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override ProductList GetProductList()
		{
			return base.Data;
		}

		protected override ProductList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetProductArray(obj);
			return new ProductList(a);
		}
	}
	public class MessageWithPurchase : Message<Purchase>
	{
		public MessageWithPurchase(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Purchase GetPurchase()
		{
			return base.Data;
		}

		protected override Purchase GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetPurchase(obj);
			return new Purchase(o);
		}
	}
	public class MessageWithPurchaseList : Message<PurchaseList>
	{
		public MessageWithPurchaseList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PurchaseList GetPurchaseList()
		{
			return base.Data;
		}

		protected override PurchaseList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetPurchaseArray(obj);
			return new PurchaseList(a);
		}
	}
	public class MessageWithRoom : Message<Oculus.Platform.Models.Room>
	{
		public MessageWithRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Oculus.Platform.Models.Room GetRoom()
		{
			return base.Data;
		}

		protected override Oculus.Platform.Models.Room GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoom(obj);
			return new Oculus.Platform.Models.Room(o);
		}
	}
	public class MessageWithRoomUnderCurrentRoom : Message<Oculus.Platform.Models.Room>
	{
		public MessageWithRoomUnderCurrentRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Oculus.Platform.Models.Room GetRoom()
		{
			return base.Data;
		}

		protected override Oculus.Platform.Models.Room GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoom(obj);
			return new Oculus.Platform.Models.Room(o);
		}
	}
	public class MessageWithRoomUnderViewerRoom : Message<Oculus.Platform.Models.Room>
	{
		public MessageWithRoomUnderViewerRoom(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Oculus.Platform.Models.Room GetRoom()
		{
			return base.Data;
		}

		protected override Oculus.Platform.Models.Room GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoom(obj);
			return new Oculus.Platform.Models.Room(o);
		}
	}
	public class MessageWithRoomList : Message<RoomList>
	{
		public MessageWithRoomList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override RoomList GetRoomList()
		{
			return base.Data;
		}

		protected override RoomList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetRoomArray(obj);
			return new RoomList(a);
		}
	}
	public class MessageWithRoomInviteNotification : Message<RoomInviteNotification>
	{
		public MessageWithRoomInviteNotification(IntPtr c_message)
			: base(c_message)
		{
		}

		public override RoomInviteNotification GetRoomInviteNotification()
		{
			return base.Data;
		}

		protected override RoomInviteNotification GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoomInviteNotification(obj);
			return new RoomInviteNotification(o);
		}
	}
	public class MessageWithRoomInviteNotificationList : Message<RoomInviteNotificationList>
	{
		public MessageWithRoomInviteNotificationList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override RoomInviteNotificationList GetRoomInviteNotificationList()
		{
			return base.Data;
		}

		protected override RoomInviteNotificationList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetRoomInviteNotificationArray(obj);
			return new RoomInviteNotificationList(a);
		}
	}
	public class MessageWithSdkAccountList : Message<SdkAccountList>
	{
		public MessageWithSdkAccountList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override SdkAccountList GetSdkAccountList()
		{
			return base.Data;
		}

		protected override SdkAccountList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetSdkAccountArray(obj);
			return new SdkAccountList(a);
		}
	}
	public class MessageWithShareMediaResult : Message<ShareMediaResult>
	{
		public MessageWithShareMediaResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override ShareMediaResult GetShareMediaResult()
		{
			return base.Data;
		}

		protected override ShareMediaResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetShareMediaResult(obj);
			return new ShareMediaResult(o);
		}
	}
	public class MessageWithString : Message<string>
	{
		public MessageWithString(IntPtr c_message)
			: base(c_message)
		{
		}

		public override string GetString()
		{
			return base.Data;
		}

		protected override string GetDataFromMessage(IntPtr c_message)
		{
			return CAPI.ovr_Message_GetString(c_message);
		}
	}
	public class MessageWithSystemPermission : Message<SystemPermission>
	{
		public MessageWithSystemPermission(IntPtr c_message)
			: base(c_message)
		{
		}

		public override SystemPermission GetSystemPermission()
		{
			return base.Data;
		}

		protected override SystemPermission GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetSystemPermission(obj);
			return new SystemPermission(o);
		}
	}
	public class MessageWithSystemVoipState : Message<SystemVoipState>
	{
		public MessageWithSystemVoipState(IntPtr c_message)
			: base(c_message)
		{
		}

		public override SystemVoipState GetSystemVoipState()
		{
			return base.Data;
		}

		protected override SystemVoipState GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetSystemVoipState(obj);
			return new SystemVoipState(o);
		}
	}
	public class MessageWithUser : Message<User>
	{
		public MessageWithUser(IntPtr c_message)
			: base(c_message)
		{
		}

		public override User GetUser()
		{
			return base.Data;
		}

		protected override User GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetUser(obj);
			return new User(o);
		}
	}
	public class MessageWithUserAndRoomList : Message<UserAndRoomList>
	{
		public MessageWithUserAndRoomList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserAndRoomList GetUserAndRoomList()
		{
			return base.Data;
		}

		protected override UserAndRoomList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetUserAndRoomArray(obj);
			return new UserAndRoomList(a);
		}
	}
	public class MessageWithUserList : Message<UserList>
	{
		public MessageWithUserList(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserList GetUserList()
		{
			return base.Data;
		}

		protected override UserList GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr a = CAPI.ovr_Message_GetUserArray(obj);
			return new UserList(a);
		}
	}
	public class MessageWithUserProof : Message<UserProof>
	{
		public MessageWithUserProof(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserProof GetUserProof()
		{
			return base.Data;
		}

		protected override UserProof GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetUserProof(obj);
			return new UserProof(o);
		}
	}
	public class MessageWithUserReportID : Message<UserReportID>
	{
		public MessageWithUserReportID(IntPtr c_message)
			: base(c_message)
		{
		}

		public override UserReportID GetUserReportID()
		{
			return base.Data;
		}

		protected override UserReportID GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetUserReportID(obj);
			return new UserReportID(o);
		}
	}
	public class MessageWithNetworkingPeer : Message<NetworkingPeer>
	{
		public MessageWithNetworkingPeer(IntPtr c_message)
			: base(c_message)
		{
		}

		public override NetworkingPeer GetNetworkingPeer()
		{
			return base.Data;
		}

		protected override NetworkingPeer GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNetworkingPeer(c_message);
			return new NetworkingPeer(CAPI.ovr_NetworkingPeer_GetID(obj), CAPI.ovr_NetworkingPeer_GetState(obj));
		}
	}
	public class MessageWithPingResult : Message<PingResult>
	{
		public MessageWithPingResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PingResult GetPingResult()
		{
			return base.Data;
		}

		protected override PingResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetPingResult(c_message);
			bool flag = CAPI.ovr_PingResult_IsTimeout(obj);
			return new PingResult(CAPI.ovr_PingResult_GetID(obj), (!flag) ? new ulong?(CAPI.ovr_PingResult_GetPingTimeUsec(obj)) : null);
		}
	}
	public class MessageWithLeaderboardDidUpdate : Message<bool>
	{
		public MessageWithLeaderboardDidUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override bool GetLeaderboardDidUpdate()
		{
			return base.Data;
		}

		protected override bool GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr obj2 = CAPI.ovr_Message_GetLeaderboardUpdateStatus(obj);
			return CAPI.ovr_LeaderboardUpdateStatus_GetDidUpdate(obj2);
		}
	}
	public class MessageWithMatchmakingNotification : Message<Oculus.Platform.Models.Room>
	{
		public MessageWithMatchmakingNotification(IntPtr c_message)
			: base(c_message)
		{
		}

		public override Oculus.Platform.Models.Room GetRoom()
		{
			return base.Data;
		}

		protected override Oculus.Platform.Models.Room GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetRoom(obj);
			return new Oculus.Platform.Models.Room(o);
		}
	}
	public class MessageWithMatchmakingBrowseResult : Message<MatchmakingBrowseResult>
	{
		public MessageWithMatchmakingBrowseResult(IntPtr c_message)
			: base(c_message)
		{
		}

		public override MatchmakingEnqueueResult GetMatchmakingEnqueueResult()
		{
			return base.Data.EnqueueResult;
		}

		public override RoomList GetRoomList()
		{
			return base.Data.Rooms;
		}

		protected override MatchmakingBrowseResult GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetMatchmakingBrowseResult(obj);
			return new MatchmakingBrowseResult(o);
		}
	}
	public class MessageWithHttpTransferUpdate : Message<HttpTransferUpdate>
	{
		public MessageWithHttpTransferUpdate(IntPtr c_message)
			: base(c_message)
		{
		}

		public override HttpTransferUpdate GetHttpTransferUpdate()
		{
			return base.Data;
		}

		protected override HttpTransferUpdate GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetHttpTransferUpdate(obj);
			return new HttpTransferUpdate(o);
		}
	}
	public class MessageWithPlatformInitialize : Message<PlatformInitialize>
	{
		public MessageWithPlatformInitialize(IntPtr c_message)
			: base(c_message)
		{
		}

		public override PlatformInitialize GetPlatformInitialize()
		{
			return base.Data;
		}

		protected override PlatformInitialize GetDataFromMessage(IntPtr c_message)
		{
			IntPtr obj = CAPI.ovr_Message_GetNativeMessage(c_message);
			IntPtr o = CAPI.ovr_Message_GetPlatformInitialize(obj);
			return new PlatformInitialize(o);
		}
	}
}
namespace Oculus.Platform.Models
{
	public class AbuseReportRecording
	{
		public readonly string RecordingUuid;

		public AbuseReportRecording(IntPtr o)
		{
			RecordingUuid = CAPI.ovr_AbuseReportRecording_GetRecordingUuid(o);
		}
	}
	public class AchievementDefinition
	{
		public readonly AchievementType Type;

		public readonly string Name;

		public readonly uint BitfieldLength;

		public readonly ulong Target;

		public AchievementDefinition(IntPtr o)
		{
			Type = CAPI.ovr_AchievementDefinition_GetType(o);
			Name = CAPI.ovr_AchievementDefinition_GetName(o);
			BitfieldLength = CAPI.ovr_AchievementDefinition_GetBitfieldLength(o);
			Target = CAPI.ovr_AchievementDefinition_GetTarget(o);
		}
	}
	public class AchievementDefinitionList : DeserializableList<AchievementDefinition>
	{
		public AchievementDefinitionList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_AchievementDefinitionArray_GetSize(a);
			_Data = new List<AchievementDefinition>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new AchievementDefinition(CAPI.ovr_AchievementDefinitionArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_AchievementDefinitionArray_GetNextUrl(a);
		}
	}
	public class AchievementProgress
	{
		public readonly string Bitfield;

		public readonly ulong Count;

		public readonly bool IsUnlocked;

		public readonly string Name;

		public readonly DateTime UnlockTime;

		public AchievementProgress(IntPtr o)
		{
			Bitfield = CAPI.ovr_AchievementProgress_GetBitfield(o);
			Count = CAPI.ovr_AchievementProgress_GetCount(o);
			IsUnlocked = CAPI.ovr_AchievementProgress_GetIsUnlocked(o);
			Name = CAPI.ovr_AchievementProgress_GetName(o);
			UnlockTime = CAPI.ovr_AchievementProgress_GetUnlockTime(o);
		}
	}
	public class AchievementProgressList : DeserializableList<AchievementProgress>
	{
		public AchievementProgressList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_AchievementProgressArray_GetSize(a);
			_Data = new List<AchievementProgress>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new AchievementProgress(CAPI.ovr_AchievementProgressArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_AchievementProgressArray_GetNextUrl(a);
		}
	}
	public class AchievementUpdate
	{
		public readonly bool JustUnlocked;

		public readonly string Name;

		public AchievementUpdate(IntPtr o)
		{
			JustUnlocked = CAPI.ovr_AchievementUpdate_GetJustUnlocked(o);
			Name = CAPI.ovr_AchievementUpdate_GetName(o);
		}
	}
	public class ApplicationVersion
	{
		public readonly int CurrentCode;

		public readonly string CurrentName;

		public readonly int LatestCode;

		public readonly string LatestName;

		public ApplicationVersion(IntPtr o)
		{
			CurrentCode = CAPI.ovr_ApplicationVersion_GetCurrentCode(o);
			CurrentName = CAPI.ovr_ApplicationVersion_GetCurrentName(o);
			LatestCode = CAPI.ovr_ApplicationVersion_GetLatestCode(o);
			LatestName = CAPI.ovr_ApplicationVersion_GetLatestName(o);
		}
	}
	public class AssetDetails
	{
		public readonly ulong AssetId;

		public readonly string AssetType;

		public readonly string DownloadStatus;

		public readonly string Filepath;

		public readonly string IapStatus;

		public readonly LanguagePackInfo LanguageOptional;

		[Obsolete("Deprecated in favor of LanguageOptional")]
		public readonly LanguagePackInfo Language;

		public AssetDetails(IntPtr o)
		{
			AssetId = CAPI.ovr_AssetDetails_GetAssetId(o);
			AssetType = CAPI.ovr_AssetDetails_GetAssetType(o);
			DownloadStatus = CAPI.ovr_AssetDetails_GetDownloadStatus(o);
			Filepath = CAPI.ovr_AssetDetails_GetFilepath(o);
			IapStatus = CAPI.ovr_AssetDetails_GetIapStatus(o);
			IntPtr intPtr = CAPI.ovr_AssetDetails_GetLanguage(o);
			Language = new LanguagePackInfo(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				LanguageOptional = null;
			}
			else
			{
				LanguageOptional = Language;
			}
		}
	}
	public class AssetDetailsList : DeserializableList<AssetDetails>
	{
		public AssetDetailsList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_AssetDetailsArray_GetSize(a);
			_Data = new List<AssetDetails>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new AssetDetails(CAPI.ovr_AssetDetailsArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class AssetFileDeleteResult
	{
		public readonly ulong AssetFileId;

		public readonly ulong AssetId;

		public readonly string Filepath;

		public readonly bool Success;

		public AssetFileDeleteResult(IntPtr o)
		{
			AssetFileId = CAPI.ovr_AssetFileDeleteResult_GetAssetFileId(o);
			AssetId = CAPI.ovr_AssetFileDeleteResult_GetAssetId(o);
			Filepath = CAPI.ovr_AssetFileDeleteResult_GetFilepath(o);
			Success = CAPI.ovr_AssetFileDeleteResult_GetSuccess(o);
		}
	}
	public class AssetFileDownloadCancelResult
	{
		public readonly ulong AssetFileId;

		public readonly ulong AssetId;

		public readonly string Filepath;

		public readonly bool Success;

		public AssetFileDownloadCancelResult(IntPtr o)
		{
			AssetFileId = CAPI.ovr_AssetFileDownloadCancelResult_GetAssetFileId(o);
			AssetId = CAPI.ovr_AssetFileDownloadCancelResult_GetAssetId(o);
			Filepath = CAPI.ovr_AssetFileDownloadCancelResult_GetFilepath(o);
			Success = CAPI.ovr_AssetFileDownloadCancelResult_GetSuccess(o);
		}
	}
	public class AssetFileDownloadResult
	{
		public readonly ulong AssetId;

		public readonly string Filepath;

		public AssetFileDownloadResult(IntPtr o)
		{
			AssetId = CAPI.ovr_AssetFileDownloadResult_GetAssetId(o);
			Filepath = CAPI.ovr_AssetFileDownloadResult_GetFilepath(o);
		}
	}
	public class AssetFileDownloadUpdate
	{
		public readonly ulong AssetFileId;

		public readonly ulong AssetId;

		public readonly uint BytesTotal;

		public readonly int BytesTransferred;

		public readonly bool Completed;

		public AssetFileDownloadUpdate(IntPtr o)
		{
			AssetFileId = CAPI.ovr_AssetFileDownloadUpdate_GetAssetFileId(o);
			AssetId = CAPI.ovr_AssetFileDownloadUpdate_GetAssetId(o);
			BytesTotal = CAPI.ovr_AssetFileDownloadUpdate_GetBytesTotal(o);
			BytesTransferred = CAPI.ovr_AssetFileDownloadUpdate_GetBytesTransferred(o);
			Completed = CAPI.ovr_AssetFileDownloadUpdate_GetCompleted(o);
		}
	}
	public class CalApplicationFinalized
	{
		public readonly int CountdownMS;

		public readonly ulong ID;

		public readonly string LaunchDetails;

		public CalApplicationFinalized(IntPtr o)
		{
			CountdownMS = CAPI.ovr_CalApplicationFinalized_GetCountdownMS(o);
			ID = CAPI.ovr_CalApplicationFinalized_GetID(o);
			LaunchDetails = CAPI.ovr_CalApplicationFinalized_GetLaunchDetails(o);
		}
	}
	public class CalApplicationProposed
	{
		public readonly ulong ID;

		public CalApplicationProposed(IntPtr o)
		{
			ID = CAPI.ovr_CalApplicationProposed_GetID(o);
		}
	}
	public class CalApplicationSuggestion
	{
		public readonly ulong ID;

		public readonly string SocialContext;

		public CalApplicationSuggestion(IntPtr o)
		{
			ID = CAPI.ovr_CalApplicationSuggestion_GetID(o);
			SocialContext = CAPI.ovr_CalApplicationSuggestion_GetSocialContext(o);
		}
	}
	public class CalApplicationSuggestionList : DeserializableList<CalApplicationSuggestion>
	{
		public CalApplicationSuggestionList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_CalApplicationSuggestionArray_GetSize(a);
			_Data = new List<CalApplicationSuggestion>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new CalApplicationSuggestion(CAPI.ovr_CalApplicationSuggestionArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class CloudStorageConflictMetadata
	{
		public readonly CloudStorageMetadata Local;

		public readonly CloudStorageMetadata Remote;

		public CloudStorageConflictMetadata(IntPtr o)
		{
			Local = new CloudStorageMetadata(CAPI.ovr_CloudStorageConflictMetadata_GetLocal(o));
			Remote = new CloudStorageMetadata(CAPI.ovr_CloudStorageConflictMetadata_GetRemote(o));
		}
	}
	public class CloudStorageData
	{
		public readonly string Bucket;

		public readonly byte[] Data;

		public readonly uint DataSize;

		public readonly string Key;

		public CloudStorageData(IntPtr o)
		{
			Bucket = CAPI.ovr_CloudStorageData_GetBucket(o);
			Data = CAPI.ovr_CloudStorageData_GetData(o);
			DataSize = CAPI.ovr_CloudStorageData_GetDataSize(o);
			Key = CAPI.ovr_CloudStorageData_GetKey(o);
		}
	}
	public class CloudStorageMetadata
	{
		public readonly string Bucket;

		public readonly long Counter;

		public readonly uint DataSize;

		public readonly string ExtraData;

		public readonly string Key;

		public readonly ulong SaveTime;

		public readonly CloudStorageDataStatus Status;

		public readonly string VersionHandle;

		public CloudStorageMetadata(IntPtr o)
		{
			Bucket = CAPI.ovr_CloudStorageMetadata_GetBucket(o);
			Counter = CAPI.ovr_CloudStorageMetadata_GetCounter(o);
			DataSize = CAPI.ovr_CloudStorageMetadata_GetDataSize(o);
			ExtraData = CAPI.ovr_CloudStorageMetadata_GetExtraData(o);
			Key = CAPI.ovr_CloudStorageMetadata_GetKey(o);
			SaveTime = CAPI.ovr_CloudStorageMetadata_GetSaveTime(o);
			Status = CAPI.ovr_CloudStorageMetadata_GetStatus(o);
			VersionHandle = CAPI.ovr_CloudStorageMetadata_GetVersionHandle(o);
		}
	}
	public class CloudStorageMetadataList : DeserializableList<CloudStorageMetadata>
	{
		public CloudStorageMetadataList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_CloudStorageMetadataArray_GetSize(a);
			_Data = new List<CloudStorageMetadata>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new CloudStorageMetadata(CAPI.ovr_CloudStorageMetadataArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_CloudStorageMetadataArray_GetNextUrl(a);
		}
	}
	public class CloudStorageUpdateResponse
	{
		public readonly string Bucket;

		public readonly string Key;

		public readonly CloudStorageUpdateStatus Status;

		public readonly string VersionHandle;

		public CloudStorageUpdateResponse(IntPtr o)
		{
			Bucket = CAPI.ovr_CloudStorageUpdateResponse_GetBucket(o);
			Key = CAPI.ovr_CloudStorageUpdateResponse_GetKey(o);
			Status = CAPI.ovr_CloudStorageUpdateResponse_GetStatus(o);
			VersionHandle = CAPI.ovr_CloudStorageUpdateResponse_GetVersionHandle(o);
		}
	}
	public class DeserializableList<T> : IList<T>, IEnumerable, ICollection<T>, IEnumerable<T>
	{
		protected List<T> _Data;

		protected string _NextUrl;

		protected string _PreviousUrl;

		bool ICollection<T>.IsReadOnly => ((ICollection<T>)_Data).IsReadOnly;

		public int Count => _Data.Count;

		public T this[int index]
		{
			get
			{
				return _Data[index];
			}
			set
			{
				_Data[index] = value;
			}
		}

		[Obsolete("Use IList interface on the DeserializableList object instead.", false)]
		public List<T> Data => _Data;

		public bool HasNextPage => !string.IsNullOrEmpty(NextUrl);

		public bool HasPreviousPage => !string.IsNullOrEmpty(PreviousUrl);

		public string NextUrl => _NextUrl;

		public string PreviousUrl => _PreviousUrl;

		public int IndexOf(T obj)
		{
			return _Data.IndexOf(obj);
		}

		public void Add(T item)
		{
			_Data.Add(item);
		}

		public void Clear()
		{
			_Data.Clear();
		}

		public bool Contains(T item)
		{
			return _Data.Contains(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			_Data.CopyTo(array, arrayIndex);
		}

		public IEnumerator<T> GetEnumerator()
		{
			return _Data.GetEnumerator();
		}

		public void Insert(int index, T item)
		{
			_Data.Insert(index, item);
		}

		public bool Remove(T item)
		{
			return _Data.Remove(item);
		}

		public void RemoveAt(int index)
		{
			_Data.RemoveAt(index);
		}

		private IEnumerator GetEnumerator1()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator1();
		}
	}
	public class Error
	{
		public readonly int Code;

		public readonly int HttpCode;

		public readonly string Message;

		public Error(int code, string message, int httpCode)
		{
			Message = message;
			Code = code;
			HttpCode = httpCode;
		}
	}
	public class HttpTransferUpdate
	{
		public readonly ulong ID;

		public readonly byte[] Payload;

		public readonly bool IsCompleted;

		public HttpTransferUpdate(IntPtr o)
		{
			ID = CAPI.ovr_HttpTransferUpdate_GetID(o);
			IsCompleted = CAPI.ovr_HttpTransferUpdate_IsCompleted(o);
			long num = (long)(ulong)CAPI.ovr_HttpTransferUpdate_GetSize(o);
			Payload = new byte[num];
			Marshal.Copy(CAPI.ovr_Packet_GetBytes(o), Payload, 0, (int)num);
		}
	}
	public class InstalledApplication
	{
		public readonly string ApplicationId;

		public readonly string PackageName;

		public readonly string Status;

		public readonly int VersionCode;

		public readonly string VersionName;

		public InstalledApplication(IntPtr o)
		{
			ApplicationId = CAPI.ovr_InstalledApplication_GetApplicationId(o);
			PackageName = CAPI.ovr_InstalledApplication_GetPackageName(o);
			Status = CAPI.ovr_InstalledApplication_GetStatus(o);
			VersionCode = CAPI.ovr_InstalledApplication_GetVersionCode(o);
			VersionName = CAPI.ovr_InstalledApplication_GetVersionName(o);
		}
	}
	public class InstalledApplicationList : DeserializableList<InstalledApplication>
	{
		public InstalledApplicationList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_InstalledApplicationArray_GetSize(a);
			_Data = new List<InstalledApplication>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new InstalledApplication(CAPI.ovr_InstalledApplicationArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class LanguagePackInfo
	{
		public readonly string EnglishName;

		public readonly string NativeName;

		public readonly string Tag;

		public LanguagePackInfo(IntPtr o)
		{
			EnglishName = CAPI.ovr_LanguagePackInfo_GetEnglishName(o);
			NativeName = CAPI.ovr_LanguagePackInfo_GetNativeName(o);
			Tag = CAPI.ovr_LanguagePackInfo_GetTag(o);
		}
	}
	public class LaunchBlockFlowResult
	{
		public readonly bool DidBlock;

		public readonly bool DidCancel;

		public LaunchBlockFlowResult(IntPtr o)
		{
			DidBlock = CAPI.ovr_LaunchBlockFlowResult_GetDidBlock(o);
			DidCancel = CAPI.ovr_LaunchBlockFlowResult_GetDidCancel(o);
		}
	}
	public class LaunchDetails
	{
		public readonly string DeeplinkMessage;

		public readonly string LaunchSource;

		public readonly LaunchType LaunchType;

		public readonly ulong RoomID;

		public readonly UserList UsersOptional;

		[Obsolete("Deprecated in favor of UsersOptional")]
		public readonly UserList Users;

		public LaunchDetails(IntPtr o)
		{
			DeeplinkMessage = CAPI.ovr_LaunchDetails_GetDeeplinkMessage(o);
			LaunchSource = CAPI.ovr_LaunchDetails_GetLaunchSource(o);
			LaunchType = CAPI.ovr_LaunchDetails_GetLaunchType(o);
			RoomID = CAPI.ovr_LaunchDetails_GetRoomID(o);
			IntPtr intPtr = CAPI.ovr_LaunchDetails_GetUsers(o);
			Users = new UserList(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				UsersOptional = null;
			}
			else
			{
				UsersOptional = Users;
			}
		}
	}
	public class LaunchFriendRequestFlowResult
	{
		public readonly bool DidCancel;

		public readonly bool DidSendRequest;

		public LaunchFriendRequestFlowResult(IntPtr o)
		{
			DidCancel = CAPI.ovr_LaunchFriendRequestFlowResult_GetDidCancel(o);
			DidSendRequest = CAPI.ovr_LaunchFriendRequestFlowResult_GetDidSendRequest(o);
		}
	}
	public class LaunchReportFlowResult
	{
		public readonly bool DidCancel;

		public readonly ulong UserReportId;

		public LaunchReportFlowResult(IntPtr o)
		{
			DidCancel = CAPI.ovr_LaunchReportFlowResult_GetDidCancel(o);
			UserReportId = CAPI.ovr_LaunchReportFlowResult_GetUserReportId(o);
		}
	}
	public class LaunchUnblockFlowResult
	{
		public readonly bool DidCancel;

		public readonly bool DidUnblock;

		public LaunchUnblockFlowResult(IntPtr o)
		{
			DidCancel = CAPI.ovr_LaunchUnblockFlowResult_GetDidCancel(o);
			DidUnblock = CAPI.ovr_LaunchUnblockFlowResult_GetDidUnblock(o);
		}
	}
	public class LeaderboardEntry
	{
		public readonly byte[] ExtraData;

		public readonly int Rank;

		public readonly long Score;

		public readonly DateTime Timestamp;

		public readonly User User;

		public LeaderboardEntry(IntPtr o)
		{
			ExtraData = CAPI.ovr_LeaderboardEntry_GetExtraData(o);
			Rank = CAPI.ovr_LeaderboardEntry_GetRank(o);
			Score = CAPI.ovr_LeaderboardEntry_GetScore(o);
			Timestamp = CAPI.ovr_LeaderboardEntry_GetTimestamp(o);
			User = new User(CAPI.ovr_LeaderboardEntry_GetUser(o));
		}
	}
	public class LeaderboardEntryList : DeserializableList<LeaderboardEntry>
	{
		public readonly ulong TotalCount;

		public LeaderboardEntryList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_LeaderboardEntryArray_GetSize(a);
			_Data = new List<LeaderboardEntry>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new LeaderboardEntry(CAPI.ovr_LeaderboardEntryArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			TotalCount = CAPI.ovr_LeaderboardEntryArray_GetTotalCount(a);
			_PreviousUrl = CAPI.ovr_LeaderboardEntryArray_GetPreviousUrl(a);
			_NextUrl = CAPI.ovr_LeaderboardEntryArray_GetNextUrl(a);
		}
	}
	public class LinkedAccount
	{
		public readonly string AccessToken;

		public readonly ServiceProvider ServiceProvider;

		public readonly string UserId;

		public LinkedAccount(IntPtr o)
		{
			AccessToken = CAPI.ovr_LinkedAccount_GetAccessToken(o);
			ServiceProvider = CAPI.ovr_LinkedAccount_GetServiceProvider(o);
			UserId = CAPI.ovr_LinkedAccount_GetUserId(o);
		}
	}
	public class LinkedAccountList : DeserializableList<LinkedAccount>
	{
		public LinkedAccountList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_LinkedAccountArray_GetSize(a);
			_Data = new List<LinkedAccount>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new LinkedAccount(CAPI.ovr_LinkedAccountArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class LivestreamingApplicationStatus
	{
		public readonly bool StreamingEnabled;

		public LivestreamingApplicationStatus(IntPtr o)
		{
			StreamingEnabled = CAPI.ovr_LivestreamingApplicationStatus_GetStreamingEnabled(o);
		}
	}
	public class LivestreamingStartResult
	{
		public readonly LivestreamingStartStatus StreamingResult;

		public LivestreamingStartResult(IntPtr o)
		{
			StreamingResult = CAPI.ovr_LivestreamingStartResult_GetStreamingResult(o);
		}
	}
	public class LivestreamingStatus
	{
		public readonly bool CommentsVisible;

		public readonly bool IsPaused;

		public readonly bool LivestreamingEnabled;

		public readonly int LivestreamingType;

		public readonly bool MicEnabled;

		public LivestreamingStatus(IntPtr o)
		{
			CommentsVisible = CAPI.ovr_LivestreamingStatus_GetCommentsVisible(o);
			IsPaused = CAPI.ovr_LivestreamingStatus_GetIsPaused(o);
			LivestreamingEnabled = CAPI.ovr_LivestreamingStatus_GetLivestreamingEnabled(o);
			LivestreamingType = CAPI.ovr_LivestreamingStatus_GetLivestreamingType(o);
			MicEnabled = CAPI.ovr_LivestreamingStatus_GetMicEnabled(o);
		}
	}
	public class LivestreamingVideoStats
	{
		public readonly int CommentCount;

		public readonly int ReactionCount;

		public readonly string TotalViews;

		public LivestreamingVideoStats(IntPtr o)
		{
			CommentCount = CAPI.ovr_LivestreamingVideoStats_GetCommentCount(o);
			ReactionCount = CAPI.ovr_LivestreamingVideoStats_GetReactionCount(o);
			TotalViews = CAPI.ovr_LivestreamingVideoStats_GetTotalViews(o);
		}
	}
	public class MatchmakingAdminSnapshot
	{
		public readonly MatchmakingAdminSnapshotCandidateList Candidates;

		public readonly double MyCurrentThreshold;

		public MatchmakingAdminSnapshot(IntPtr o)
		{
			Candidates = new MatchmakingAdminSnapshotCandidateList(CAPI.ovr_MatchmakingAdminSnapshot_GetCandidates(o));
			MyCurrentThreshold = CAPI.ovr_MatchmakingAdminSnapshot_GetMyCurrentThreshold(o);
		}
	}
	public class MatchmakingAdminSnapshotCandidate
	{
		public readonly bool CanMatch;

		public readonly double MyTotalScore;

		public readonly double TheirCurrentThreshold;

		public readonly double TheirTotalScore;

		public readonly string TraceId;

		public MatchmakingAdminSnapshotCandidate(IntPtr o)
		{
			CanMatch = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetCanMatch(o);
			MyTotalScore = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetMyTotalScore(o);
			TheirCurrentThreshold = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetTheirCurrentThreshold(o);
			TheirTotalScore = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetTheirTotalScore(o);
			TraceId = CAPI.ovr_MatchmakingAdminSnapshotCandidate_GetTraceId(o);
		}
	}
	public class MatchmakingAdminSnapshotCandidateList : DeserializableList<MatchmakingAdminSnapshotCandidate>
	{
		public MatchmakingAdminSnapshotCandidateList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_MatchmakingAdminSnapshotCandidateArray_GetSize(a);
			_Data = new List<MatchmakingAdminSnapshotCandidate>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new MatchmakingAdminSnapshotCandidate(CAPI.ovr_MatchmakingAdminSnapshotCandidateArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class MatchmakingBrowseResult
	{
		public readonly MatchmakingEnqueueResult EnqueueResult;

		public readonly RoomList Rooms;

		public MatchmakingBrowseResult(IntPtr o)
		{
			EnqueueResult = new MatchmakingEnqueueResult(CAPI.ovr_MatchmakingBrowseResult_GetEnqueueResult(o));
			Rooms = new RoomList(CAPI.ovr_MatchmakingBrowseResult_GetRooms(o));
		}
	}
	public class MatchmakingEnqueuedUser
	{
		public readonly Dictionary<string, string> CustomData;

		public readonly User UserOptional;

		[Obsolete("Deprecated in favor of UserOptional")]
		public readonly User User;

		public MatchmakingEnqueuedUser(IntPtr o)
		{
			CustomData = CAPI.DataStoreFromNative(CAPI.ovr_MatchmakingEnqueuedUser_GetCustomData(o));
			IntPtr intPtr = CAPI.ovr_MatchmakingEnqueuedUser_GetUser(o);
			User = new User(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				UserOptional = null;
			}
			else
			{
				UserOptional = User;
			}
		}
	}
	public class MatchmakingEnqueuedUserList : DeserializableList<MatchmakingEnqueuedUser>
	{
		public MatchmakingEnqueuedUserList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_MatchmakingEnqueuedUserArray_GetSize(a);
			_Data = new List<MatchmakingEnqueuedUser>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new MatchmakingEnqueuedUser(CAPI.ovr_MatchmakingEnqueuedUserArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class MatchmakingEnqueueResult
	{
		public readonly MatchmakingAdminSnapshot AdminSnapshotOptional;

		[Obsolete("Deprecated in favor of AdminSnapshotOptional")]
		public readonly MatchmakingAdminSnapshot AdminSnapshot;

		public readonly uint AverageWait;

		public readonly uint MatchesInLastHourCount;

		public readonly uint MaxExpectedWait;

		public readonly string Pool;

		public readonly uint RecentMatchPercentage;

		public readonly string RequestHash;

		public MatchmakingEnqueueResult(IntPtr o)
		{
			IntPtr intPtr = CAPI.ovr_MatchmakingEnqueueResult_GetAdminSnapshot(o);
			AdminSnapshot = new MatchmakingAdminSnapshot(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				AdminSnapshotOptional = null;
			}
			else
			{
				AdminSnapshotOptional = AdminSnapshot;
			}
			AverageWait = CAPI.ovr_MatchmakingEnqueueResult_GetAverageWait(o);
			MatchesInLastHourCount = CAPI.ovr_MatchmakingEnqueueResult_GetMatchesInLastHourCount(o);
			MaxExpectedWait = CAPI.ovr_MatchmakingEnqueueResult_GetMaxExpectedWait(o);
			Pool = CAPI.ovr_MatchmakingEnqueueResult_GetPool(o);
			RecentMatchPercentage = CAPI.ovr_MatchmakingEnqueueResult_GetRecentMatchPercentage(o);
			RequestHash = CAPI.ovr_MatchmakingEnqueueResult_GetRequestHash(o);
		}
	}
	public class MatchmakingEnqueueResultAndRoom
	{
		public readonly MatchmakingEnqueueResult MatchmakingEnqueueResult;

		public readonly Room Room;

		public MatchmakingEnqueueResultAndRoom(IntPtr o)
		{
			MatchmakingEnqueueResult = new MatchmakingEnqueueResult(CAPI.ovr_MatchmakingEnqueueResultAndRoom_GetMatchmakingEnqueueResult(o));
			Room = new Room(CAPI.ovr_MatchmakingEnqueueResultAndRoom_GetRoom(o));
		}
	}
	public class MatchmakingStats
	{
		public readonly uint DrawCount;

		public readonly uint LossCount;

		public readonly uint SkillLevel;

		public readonly uint WinCount;

		public MatchmakingStats(IntPtr o)
		{
			DrawCount = CAPI.ovr_MatchmakingStats_GetDrawCount(o);
			LossCount = CAPI.ovr_MatchmakingStats_GetLossCount(o);
			SkillLevel = CAPI.ovr_MatchmakingStats_GetSkillLevel(o);
			WinCount = CAPI.ovr_MatchmakingStats_GetWinCount(o);
		}
	}
	public class NetworkingPeer
	{
		public ulong ID { get; private set; }

		public PeerConnectionState State { get; private set; }

		public NetworkingPeer(ulong id, PeerConnectionState state)
		{
			ID = id;
			State = state;
		}
	}
	public class OrgScopedID
	{
		public readonly ulong ID;

		public OrgScopedID(IntPtr o)
		{
			ID = CAPI.ovr_OrgScopedID_GetID(o);
		}
	}
	public class Party
	{
		public readonly ulong ID;

		public readonly UserList InvitedUsersOptional;

		[Obsolete("Deprecated in favor of InvitedUsersOptional")]
		public readonly UserList InvitedUsers;

		public readonly User LeaderOptional;

		[Obsolete("Deprecated in favor of LeaderOptional")]
		public readonly User Leader;

		public readonly Room RoomOptional;

		[Obsolete("Deprecated in favor of RoomOptional")]
		public readonly Room Room;

		public readonly UserList UsersOptional;

		[Obsolete("Deprecated in favor of UsersOptional")]
		public readonly UserList Users;

		public Party(IntPtr o)
		{
			ID = CAPI.ovr_Party_GetID(o);
			IntPtr intPtr = CAPI.ovr_Party_GetInvitedUsers(o);
			InvitedUsers = new UserList(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				InvitedUsersOptional = null;
			}
			else
			{
				InvitedUsersOptional = InvitedUsers;
			}
			IntPtr intPtr2 = CAPI.ovr_Party_GetLeader(o);
			Leader = new User(intPtr2);
			if (intPtr2 == IntPtr.Zero)
			{
				LeaderOptional = null;
			}
			else
			{
				LeaderOptional = Leader;
			}
			IntPtr intPtr3 = CAPI.ovr_Party_GetRoom(o);
			Room = new Room(intPtr3);
			if (intPtr3 == IntPtr.Zero)
			{
				RoomOptional = null;
			}
			else
			{
				RoomOptional = Room;
			}
			IntPtr intPtr4 = CAPI.ovr_Party_GetUsers(o);
			Users = new UserList(intPtr4);
			if (intPtr4 == IntPtr.Zero)
			{
				UsersOptional = null;
			}
			else
			{
				UsersOptional = Users;
			}
		}
	}
	public class PartyID
	{
		public readonly ulong ID;

		public PartyID(IntPtr o)
		{
			ID = CAPI.ovr_PartyID_GetID(o);
		}
	}
	public class Pid
	{
		public readonly string Id;

		public Pid(IntPtr o)
		{
			Id = CAPI.ovr_Pid_GetId(o);
		}
	}
	public class PidList : DeserializableList<Pid>
	{
		public PidList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_PidArray_GetSize(a);
			_Data = new List<Pid>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Pid(CAPI.ovr_PidArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class PingResult
	{
		private ulong? pingTimeUsec;

		public ulong ID { get; private set; }

		public ulong PingTimeUsec => (!pingTimeUsec.HasValue) ? 0 : pingTimeUsec.Value;

		public bool IsTimeout => !pingTimeUsec.HasValue;

		public PingResult(ulong id, ulong? pingTimeUsec)
		{
			ID = id;
			this.pingTimeUsec = pingTimeUsec;
		}
	}
	public class PlatformInitialize
	{
		public readonly PlatformInitializeResult Result;

		public PlatformInitialize(IntPtr o)
		{
			Result = CAPI.ovr_PlatformInitialize_GetResult(o);
		}
	}
	public class Product
	{
		public readonly string Description;

		public readonly string FormattedPrice;

		public readonly string Name;

		public readonly string Sku;

		public Product(IntPtr o)
		{
			Description = CAPI.ovr_Product_GetDescription(o);
			FormattedPrice = CAPI.ovr_Product_GetFormattedPrice(o);
			Name = CAPI.ovr_Product_GetName(o);
			Sku = CAPI.ovr_Product_GetSKU(o);
		}
	}
	public class ProductList : DeserializableList<Product>
	{
		public ProductList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_ProductArray_GetSize(a);
			_Data = new List<Product>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Product(CAPI.ovr_ProductArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_ProductArray_GetNextUrl(a);
		}
	}
	public class Purchase
	{
		public readonly DateTime ExpirationTime;

		public readonly DateTime GrantTime;

		public readonly ulong ID;

		public readonly string Sku;

		public Purchase(IntPtr o)
		{
			ExpirationTime = CAPI.ovr_Purchase_GetExpirationTime(o);
			GrantTime = CAPI.ovr_Purchase_GetGrantTime(o);
			ID = CAPI.ovr_Purchase_GetPurchaseID(o);
			Sku = CAPI.ovr_Purchase_GetSKU(o);
		}
	}
	public class PurchaseList : DeserializableList<Purchase>
	{
		public PurchaseList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_PurchaseArray_GetSize(a);
			_Data = new List<Purchase>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Purchase(CAPI.ovr_PurchaseArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_PurchaseArray_GetNextUrl(a);
		}
	}
	public class Room
	{
		public readonly ulong ApplicationID;

		public readonly Dictionary<string, string> DataStore;

		public readonly string Description;

		public readonly ulong ID;

		public readonly UserList InvitedUsersOptional;

		[Obsolete("Deprecated in favor of InvitedUsersOptional")]
		public readonly UserList InvitedUsers;

		public readonly bool IsMembershipLocked;

		public readonly RoomJoinPolicy JoinPolicy;

		public readonly RoomJoinability Joinability;

		public readonly MatchmakingEnqueuedUserList MatchedUsersOptional;

		[Obsolete("Deprecated in favor of MatchedUsersOptional")]
		public readonly MatchmakingEnqueuedUserList MatchedUsers;

		public readonly uint MaxUsers;

		public readonly string Name;

		public readonly User OwnerOptional;

		[Obsolete("Deprecated in favor of OwnerOptional")]
		public readonly User Owner;

		public readonly RoomType Type;

		public readonly UserList UsersOptional;

		[Obsolete("Deprecated in favor of UsersOptional")]
		public readonly UserList Users;

		public readonly uint Version;

		public Room(IntPtr o)
		{
			ApplicationID = CAPI.ovr_Room_GetApplicationID(o);
			DataStore = CAPI.DataStoreFromNative(CAPI.ovr_Room_GetDataStore(o));
			Description = CAPI.ovr_Room_GetDescription(o);
			ID = CAPI.ovr_Room_GetID(o);
			IntPtr intPtr = CAPI.ovr_Room_GetInvitedUsers(o);
			InvitedUsers = new UserList(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				InvitedUsersOptional = null;
			}
			else
			{
				InvitedUsersOptional = InvitedUsers;
			}
			IsMembershipLocked = CAPI.ovr_Room_GetIsMembershipLocked(o);
			JoinPolicy = CAPI.ovr_Room_GetJoinPolicy(o);
			Joinability = CAPI.ovr_Room_GetJoinability(o);
			IntPtr intPtr2 = CAPI.ovr_Room_GetMatchedUsers(o);
			MatchedUsers = new MatchmakingEnqueuedUserList(intPtr2);
			if (intPtr2 == IntPtr.Zero)
			{
				MatchedUsersOptional = null;
			}
			else
			{
				MatchedUsersOptional = MatchedUsers;
			}
			MaxUsers = CAPI.ovr_Room_GetMaxUsers(o);
			Name = CAPI.ovr_Room_GetName(o);
			IntPtr intPtr3 = CAPI.ovr_Room_GetOwner(o);
			Owner = new User(intPtr3);
			if (intPtr3 == IntPtr.Zero)
			{
				OwnerOptional = null;
			}
			else
			{
				OwnerOptional = Owner;
			}
			Type = CAPI.ovr_Room_GetType(o);
			IntPtr intPtr4 = CAPI.ovr_Room_GetUsers(o);
			Users = new UserList(intPtr4);
			if (intPtr4 == IntPtr.Zero)
			{
				UsersOptional = null;
			}
			else
			{
				UsersOptional = Users;
			}
			Version = CAPI.ovr_Room_GetVersion(o);
		}
	}
	public class RoomList : DeserializableList<Room>
	{
		public RoomList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_RoomArray_GetSize(a);
			_Data = new List<Room>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new Room(CAPI.ovr_RoomArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_RoomArray_GetNextUrl(a);
		}
	}
	public class RoomInviteNotification
	{
		public readonly ulong ID;

		public readonly ulong RoomID;

		public readonly ulong SenderID;

		public readonly DateTime SentTime;

		public RoomInviteNotification(IntPtr o)
		{
			ID = CAPI.ovr_RoomInviteNotification_GetID(o);
			RoomID = CAPI.ovr_RoomInviteNotification_GetRoomID(o);
			SenderID = CAPI.ovr_RoomInviteNotification_GetSenderID(o);
			SentTime = CAPI.ovr_RoomInviteNotification_GetSentTime(o);
		}
	}
	public class RoomInviteNotificationList : DeserializableList<RoomInviteNotification>
	{
		public RoomInviteNotificationList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_RoomInviteNotificationArray_GetSize(a);
			_Data = new List<RoomInviteNotification>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new RoomInviteNotification(CAPI.ovr_RoomInviteNotificationArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_RoomInviteNotificationArray_GetNextUrl(a);
		}
	}
	public class SdkAccount
	{
		public readonly SdkAccountType AccountType;

		public readonly ulong UserId;

		public SdkAccount(IntPtr o)
		{
			AccountType = CAPI.ovr_SdkAccount_GetAccountType(o);
			UserId = CAPI.ovr_SdkAccount_GetUserId(o);
		}
	}
	public class SdkAccountList : DeserializableList<SdkAccount>
	{
		public SdkAccountList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_SdkAccountArray_GetSize(a);
			_Data = new List<SdkAccount>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new SdkAccount(CAPI.ovr_SdkAccountArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
		}
	}
	public class ShareMediaResult
	{
		public readonly ShareMediaStatus Status;

		public ShareMediaResult(IntPtr o)
		{
			Status = CAPI.ovr_ShareMediaResult_GetStatus(o);
		}
	}
	public class SystemPermission
	{
		public readonly bool HasPermission;

		public readonly PermissionGrantStatus PermissionGrantStatus;

		public SystemPermission(IntPtr o)
		{
			HasPermission = CAPI.ovr_SystemPermission_GetHasPermission(o);
			PermissionGrantStatus = CAPI.ovr_SystemPermission_GetPermissionGrantStatus(o);
		}
	}
	public class SystemVoipState
	{
		public readonly VoipMuteState MicrophoneMuted;

		public readonly SystemVoipStatus Status;

		public SystemVoipState(IntPtr o)
		{
			MicrophoneMuted = CAPI.ovr_SystemVoipState_GetMicrophoneMuted(o);
			Status = CAPI.ovr_SystemVoipState_GetStatus(o);
		}
	}
	public class User
	{
		public readonly ulong ID;

		public readonly string ImageURL;

		public readonly string InviteToken;

		public readonly string OculusID;

		public readonly string Presence;

		public readonly UserPresenceStatus PresenceStatus;

		public readonly string SmallImageUrl;

		public User(IntPtr o)
		{
			ID = CAPI.ovr_User_GetID(o);
			ImageURL = CAPI.ovr_User_GetImageUrl(o);
			InviteToken = CAPI.ovr_User_GetInviteToken(o);
			OculusID = CAPI.ovr_User_GetOculusID(o);
			Presence = CAPI.ovr_User_GetPresence(o);
			PresenceStatus = CAPI.ovr_User_GetPresenceStatus(o);
			SmallImageUrl = CAPI.ovr_User_GetSmallImageUrl(o);
		}
	}
	public class UserList : DeserializableList<User>
	{
		public UserList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_UserArray_GetSize(a);
			_Data = new List<User>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new User(CAPI.ovr_UserArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_UserArray_GetNextUrl(a);
		}
	}
	public class UserAndRoom
	{
		public readonly Room RoomOptional;

		[Obsolete("Deprecated in favor of RoomOptional")]
		public readonly Room Room;

		public readonly User User;

		public UserAndRoom(IntPtr o)
		{
			IntPtr intPtr = CAPI.ovr_UserAndRoom_GetRoom(o);
			Room = new Room(intPtr);
			if (intPtr == IntPtr.Zero)
			{
				RoomOptional = null;
			}
			else
			{
				RoomOptional = Room;
			}
			User = new User(CAPI.ovr_UserAndRoom_GetUser(o));
		}
	}
	public class UserAndRoomList : DeserializableList<UserAndRoom>
	{
		public UserAndRoomList(IntPtr a)
		{
			int num = (int)(uint)CAPI.ovr_UserAndRoomArray_GetSize(a);
			_Data = new List<UserAndRoom>(num);
			for (int i = 0; i < num; i++)
			{
				_Data.Add(new UserAndRoom(CAPI.ovr_UserAndRoomArray_GetElement(a, (UIntPtr)(ulong)i)));
			}
			_NextUrl = CAPI.ovr_UserAndRoomArray_GetNextUrl(a);
		}
	}
	public class UserProof
	{
		public readonly string Value;

		public UserProof(IntPtr o)
		{
			Value = CAPI.ovr_UserProof_GetNonce(o);
		}
	}
	public class UserReportID
	{
		public readonly bool DidCancel;

		public readonly ulong ID;

		public UserReportID(IntPtr o)
		{
			DidCancel = CAPI.ovr_UserReportID_GetDidCancel(o);
			ID = CAPI.ovr_UserReportID_GetID(o);
		}
	}
}
namespace Oculus.Platform
{
	public sealed class Packet : IDisposable
	{
		private readonly ulong size;

		private readonly IntPtr packetHandle;

		public ulong SenderID => CAPI.ovr_Packet_GetSenderID(packetHandle);

		public ulong Size => size;

		public SendPolicy Policy => CAPI.ovr_Packet_GetSendPolicy(packetHandle);

		public Packet(IntPtr packetHandle)
		{
			this.packetHandle = packetHandle;
			size = (ulong)CAPI.ovr_Packet_GetSize(packetHandle);
		}

		public ulong ReadBytes(byte[] destination)
		{
			if ((ulong)destination.LongLength < size)
			{
				throw new ArgumentException($"Destination array was not big enough to hold {size} bytes");
			}
			Marshal.Copy(CAPI.ovr_Packet_GetBytes(packetHandle), destination, 0, (int)size);
			return size;
		}

		~Packet()
		{
			Dispose();
		}

		public void Dispose()
		{
			CAPI.ovr_Packet_Free(packetHandle);
			GC.SuppressFinalize(this);
		}
	}
	public enum PeerConnectionState
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("CONNECTED")]
		Connected,
		[Description("TIMEOUT")]
		Timeout,
		[Description("CLOSED")]
		Closed
	}
	public enum PermissionGrantStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("GRANTED")]
		Granted,
		[Description("DENIED")]
		Denied,
		[Description("BLOCKED")]
		Blocked
	}
	public enum PermissionType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MICROPHONE")]
		Microphone,
		[Description("WRITE_EXTERNAL_STORAGE")]
		WriteExternalStorage
	}
	public sealed class Core
	{
		private static bool IsPlatformInitialized;

		public static bool LogMessages;

		public static bool IsInitialized()
		{
			return IsPlatformInitialized;
		}

		internal static void ForceInitialized()
		{
			IsPlatformInitialized = true;
		}

		private static string getAppID(string appId = null)
		{
			string appIDFromConfig = GetAppIDFromConfig();
			if (string.IsNullOrEmpty(appId))
			{
				if (string.IsNullOrEmpty(appIDFromConfig))
				{
					throw new UnityException("Update your app id by selecting 'Oculus Platform' -> 'Edit Settings'");
				}
				appId = appIDFromConfig;
			}
			else if (!string.IsNullOrEmpty(appIDFromConfig))
			{
				Debug.LogWarningFormat("The 'Oculus App Id ({0})' field in 'Oculus Platform/Edit Settings' is being overridden by the App Id ({1}) that you passed in to Platform.Core.Initialize.  You should only specify this in one place.  We recommend the menu location.", appIDFromConfig, appId);
			}
			return appId;
		}

		public static Request<PlatformInitialize> AsyncInitialize(string appId = null)
		{
			appId = getAppID(appId);
			Request<PlatformInitialize> request;
			if (UnityEngine.Application.isEditor && PlatformSettings.UseStandalonePlatform)
			{
				StandalonePlatform standalonePlatform = new StandalonePlatform();
				request = standalonePlatform.InitializeInEditor();
			}
			else if (UnityEngine.Application.platform == RuntimePlatform.WindowsEditor || UnityEngine.Application.platform == RuntimePlatform.WindowsPlayer)
			{
				WindowsPlatform windowsPlatform = new WindowsPlatform();
				request = windowsPlatform.AsyncInitialize(appId);
			}
			else
			{
				if (UnityEngine.Application.platform != RuntimePlatform.Android)
				{
					throw new NotImplementedException("Oculus platform is not implemented on this platform yet.");
				}
				AndroidPlatform androidPlatform = new AndroidPlatform();
				request = androidPlatform.AsyncInitialize(appId);
			}
			IsPlatformInitialized = request != null;
			if (!IsPlatformInitialized)
			{
				throw new UnityException("Oculus Platform failed to initialize.");
			}
			if (LogMessages)
			{
				Debug.LogWarning("Oculus.Platform.Core.LogMessages is set to true. This will cause extra heap allocations, and should not be used outside of testing and debugging.");
			}
			new GameObject("Oculus.Platform.CallbackRunner").AddComponent<CallbackRunner>();
			return request;
		}

		public static void Initialize(string appId = null)
		{
			appId = getAppID(appId);
			if (UnityEngine.Application.isEditor && PlatformSettings.UseStandalonePlatform)
			{
				StandalonePlatform standalonePlatform = new StandalonePlatform();
				IsPlatformInitialized = standalonePlatform.InitializeInEditor() != null;
			}
			else if (UnityEngine.Application.platform == RuntimePlatform.WindowsEditor || UnityEngine.Application.platform == RuntimePlatform.WindowsPlayer)
			{
				WindowsPlatform windowsPlatform = new WindowsPlatform();
				IsPlatformInitialized = windowsPlatform.Initialize(appId);
			}
			else
			{
				if (UnityEngine.Application.platform != RuntimePlatform.Android)
				{
					throw new NotImplementedException("Oculus platform is not implemented on this platform yet.");
				}
				AndroidPlatform androidPlatform = new AndroidPlatform();
				IsPlatformInitialized = androidPlatform.Initialize(appId);
			}
			if (!IsPlatformInitialized)
			{
				throw new UnityException("Oculus Platform failed to initialize.");
			}
			if (LogMessages)
			{
				Debug.LogWarning("Oculus.Platform.Core.LogMessages is set to true. This will cause extra heap allocations, and should not be used outside of testing and debugging.");
			}
			new GameObject("Oculus.Platform.CallbackRunner").AddComponent<CallbackRunner>();
		}

		private static string GetAppIDFromConfig()
		{
			if (UnityEngine.Application.platform == RuntimePlatform.Android)
			{
				return PlatformSettings.MobileAppID;
			}
			return PlatformSettings.AppID;
		}
	}
	public static class ApplicationLifecycle
	{
		public static LaunchDetails GetLaunchDetails()
		{
			return new LaunchDetails(CAPI.ovr_ApplicationLifecycle_GetLaunchDetails());
		}
	}
	public static class Rooms
	{
		public static Request<Oculus.Platform.Models.Room> UpdateDataStore(ulong roomID, Dictionary<string, string> data)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovrKeyValuePair[] array = new CAPI.ovrKeyValuePair[data.Count];
				int num = 0;
				foreach (KeyValuePair<string, string> datum in data)
				{
					ref CAPI.ovrKeyValuePair reference = ref array[num++];
					reference = new CAPI.ovrKeyValuePair(datum.Key, datum.Value);
				}
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_UpdateDataStore(roomID, array));
			}
			return null;
		}

		[Obsolete("Deprecated in favor of SetRoomInviteAcceptedNotificationCallback")]
		public static void SetRoomInviteNotificationCallback(Message<string>.Callback callback)
		{
			SetRoomInviteAcceptedNotificationCallback(callback);
		}

		public static Request<Oculus.Platform.Models.Room> CreateAndJoinPrivate(RoomJoinPolicy joinPolicy, uint maxUsers, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_CreateAndJoinPrivate(joinPolicy, maxUsers, subscribeToUpdates));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> CreateAndJoinPrivate2(RoomJoinPolicy joinPolicy, uint maxUsers, RoomOptions roomOptions)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_CreateAndJoinPrivate2(joinPolicy, maxUsers, (IntPtr)roomOptions));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> Get(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_Get(roomID));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> GetCurrent()
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_GetCurrent());
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> GetCurrentForUser(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_GetCurrentForUser(userID));
			}
			return null;
		}

		public static Request<UserList> GetInvitableUsers()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_Room_GetInvitableUsers());
			}
			return null;
		}

		public static Request<UserList> GetInvitableUsers2(RoomOptions roomOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_Room_GetInvitableUsers2((IntPtr)roomOptions));
			}
			return null;
		}

		public static Request<RoomList> GetModeratedRooms()
		{
			if (Core.IsInitialized())
			{
				return new Request<RoomList>(CAPI.ovr_Room_GetModeratedRooms());
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> InviteUser(ulong roomID, string inviteToken)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_InviteUser(roomID, inviteToken));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> Join(ulong roomID, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_Join(roomID, subscribeToUpdates));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> Join2(ulong roomID, RoomOptions roomOptions)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_Join2(roomID, (IntPtr)roomOptions));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> KickUser(ulong roomID, ulong userID, int kickDurationSeconds)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_KickUser(roomID, userID, kickDurationSeconds));
			}
			return null;
		}

		public static Request LaunchInvitableUserFlow(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Room_LaunchInvitableUserFlow(roomID));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> Leave(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_Leave(roomID));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> SetDescription(ulong roomID, string description)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_SetDescription(roomID, description));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> UpdateMembershipLockStatus(ulong roomID, RoomMembershipLockStatus membershipLockStatus)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_UpdateMembershipLockStatus(roomID, membershipLockStatus));
			}
			return null;
		}

		public static Request UpdateOwner(ulong roomID, ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Room_UpdateOwner(roomID, userID));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> UpdatePrivateRoomJoinPolicy(ulong roomID, RoomJoinPolicy newJoinPolicy)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Room_UpdatePrivateRoomJoinPolicy(roomID, newJoinPolicy));
			}
			return null;
		}

		public static void SetRoomInviteAcceptedNotificationCallback(Message<string>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Room_InviteAccepted, callback);
		}

		public static void SetRoomInviteReceivedNotificationCallback(Message<RoomInviteNotification>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Room_InviteReceived, callback);
		}

		public static void SetUpdateNotificationCallback(Message<Oculus.Platform.Models.Room>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Room_RoomUpdate, callback);
		}

		public static Request<RoomList> GetNextRoomListPage(RoomList list)
		{
			if (!list.HasNextPage)
			{
				Debug.LogWarning("Oculus.Platform.GetNextRoomListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<RoomList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1317239238));
			}
			return null;
		}
	}
	public static class Matchmaking
	{
		public class CustomQuery
		{
			public struct Criterion
			{
				public string key;

				public MatchmakingCriterionImportance importance;

				public Dictionary<string, object> parameters;

				public Criterion(string key_, MatchmakingCriterionImportance importance_)
				{
					key = key_;
					importance = importance_;
					parameters = null;
				}
			}

			public Dictionary<string, object> data;

			public Criterion[] criteria;

			public IntPtr ToUnmanaged()
			{
				CAPI.ovrMatchmakingCustomQueryData ovrMatchmakingCustomQueryData = default(CAPI.ovrMatchmakingCustomQueryData);
				if (criteria != null && criteria.Length > 0)
				{
					ovrMatchmakingCustomQueryData.criterionArrayCount = (uint)criteria.Length;
					CAPI.ovrMatchmakingCriterion[] array = new CAPI.ovrMatchmakingCriterion[criteria.Length];
					for (int i = 0; i < criteria.Length; i++)
					{
						array[i].importance_ = criteria[i].importance;
						array[i].key_ = criteria[i].key;
						if (criteria[i].parameters != null && criteria[i].parameters.Count > 0)
						{
							array[i].parameterArrayCount = (uint)criteria[i].parameters.Count;
							array[i].parameterArray = CAPI.ArrayOfStructsToIntPtr(CAPI.DictionaryToOVRKeyValuePairs(criteria[i].parameters));
						}
						else
						{
							array[i].parameterArrayCount = 0u;
							array[i].parameterArray = IntPtr.Zero;
						}
					}
					ovrMatchmakingCustomQueryData.criterionArray = CAPI.ArrayOfStructsToIntPtr(array);
				}
				else
				{
					ovrMatchmakingCustomQueryData.criterionArrayCount = 0u;
					ovrMatchmakingCustomQueryData.criterionArray = IntPtr.Zero;
				}
				if (data != null && data.Count > 0)
				{
					ovrMatchmakingCustomQueryData.dataArrayCount = (uint)data.Count;
					ovrMatchmakingCustomQueryData.dataArray = CAPI.ArrayOfStructsToIntPtr(CAPI.DictionaryToOVRKeyValuePairs(data));
				}
				else
				{
					ovrMatchmakingCustomQueryData.dataArrayCount = 0u;
					ovrMatchmakingCustomQueryData.dataArray = IntPtr.Zero;
				}
				IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(ovrMatchmakingCustomQueryData));
				Marshal.StructureToPtr(ovrMatchmakingCustomQueryData, intPtr, fDeleteOld: true);
				return intPtr;
			}
		}

		public static Request ReportResultsInsecure(ulong roomID, Dictionary<string, int> data)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovrKeyValuePair[] array = new CAPI.ovrKeyValuePair[data.Count];
				int num = 0;
				foreach (KeyValuePair<string, int> datum in data)
				{
					ref CAPI.ovrKeyValuePair reference = ref array[num++];
					reference = new CAPI.ovrKeyValuePair(datum.Key, datum.Value);
				}
				return new Request(CAPI.ovr_Matchmaking_ReportResultInsecure(roomID, array));
			}
			return null;
		}

		public static Request<MatchmakingStats> GetStats(string pool, uint maxLevel, MatchmakingStatApproach approach = MatchmakingStatApproach.Trailing)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingStats>(CAPI.ovr_Matchmaking_GetStats(pool, maxLevel, approach));
			}
			return null;
		}

		public static Request<MatchmakingBrowseResult> Browse(string pool, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingBrowseResult>(CAPI.ovr_Matchmaking_Browse(pool, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingBrowseResult> Browse2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingBrowseResult>(CAPI.ovr_Matchmaking_Browse2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request Cancel(string pool, string requestHash)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_Cancel(pool, requestHash));
			}
			return null;
		}

		public static Request Cancel()
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_Cancel2());
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResultAndRoom> CreateAndEnqueueRoom(string pool, uint maxUsers, bool subscribeToUpdates = false, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResultAndRoom>(CAPI.ovr_Matchmaking_CreateAndEnqueueRoom(pool, maxUsers, subscribeToUpdates, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResultAndRoom> CreateAndEnqueueRoom2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResultAndRoom>(CAPI.ovr_Matchmaking_CreateAndEnqueueRoom2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> CreateRoom(string pool, uint maxUsers, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Matchmaking_CreateRoom(pool, maxUsers, subscribeToUpdates));
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> CreateRoom2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Matchmaking_CreateRoom2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> Enqueue(string pool, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_Enqueue(pool, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> Enqueue2(string pool, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_Enqueue2(pool, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> EnqueueRoom(ulong roomID, CustomQuery customQueryData = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_EnqueueRoom(roomID, customQueryData?.ToUnmanaged() ?? IntPtr.Zero));
			}
			return null;
		}

		public static Request<MatchmakingEnqueueResult> EnqueueRoom2(ulong roomID, MatchmakingOptions matchmakingOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingEnqueueResult>(CAPI.ovr_Matchmaking_EnqueueRoom2(roomID, (IntPtr)matchmakingOptions));
			}
			return null;
		}

		public static Request<MatchmakingAdminSnapshot> GetAdminSnapshot()
		{
			if (Core.IsInitialized())
			{
				return new Request<MatchmakingAdminSnapshot>(CAPI.ovr_Matchmaking_GetAdminSnapshot());
			}
			return null;
		}

		public static Request<Oculus.Platform.Models.Room> JoinRoom(ulong roomID, bool subscribeToUpdates = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<Oculus.Platform.Models.Room>(CAPI.ovr_Matchmaking_JoinRoom(roomID, subscribeToUpdates));
			}
			return null;
		}

		public static Request StartMatch(ulong roomID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Matchmaking_StartMatch(roomID));
			}
			return null;
		}

		public static void SetMatchFoundNotificationCallback(Message<Oculus.Platform.Models.Room>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Matchmaking_MatchFound, callback);
		}
	}
	public static class Net
	{
		public static Packet ReadPacket()
		{
			if (!Core.IsInitialized())
			{
				return null;
			}
			IntPtr intPtr = CAPI.ovr_Net_ReadPacket();
			if (intPtr == IntPtr.Zero)
			{
				return null;
			}
			return new Packet(intPtr);
		}

		public static bool SendPacket(ulong userID, byte[] bytes, SendPolicy policy)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_SendPacket(userID, (UIntPtr)(ulong)bytes.Length, bytes, policy);
			}
			return false;
		}

		public static void Connect(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_Connect(userID);
			}
		}

		public static void Accept(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_Accept(userID);
			}
		}

		public static void Close(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_Close(userID);
			}
		}

		public static bool IsConnected(ulong userID)
		{
			return Core.IsInitialized() && CAPI.ovr_Net_IsConnected(userID);
		}

		public static bool SendPacketToCurrentRoom(byte[] bytes, SendPolicy policy)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_SendPacketToCurrentRoom((UIntPtr)(ulong)bytes.Length, bytes, policy);
			}
			return false;
		}

		public static bool AcceptForCurrentRoom()
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Net_AcceptForCurrentRoom();
			}
			return false;
		}

		public static void CloseForCurrentRoom()
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Net_CloseForCurrentRoom();
			}
		}

		public static Request<PingResult> Ping(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<PingResult>(CAPI.ovr_Net_Ping(userID));
			}
			return null;
		}

		public static void SetConnectionStateChangedCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Networking_ConnectionStateChange, callback);
		}

		public static void SetPeerConnectRequestCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Networking_PeerConnectRequest, callback);
		}

		public static void SetPingResultNotificationCallback(Message<PingResult>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Networking_PingResult, callback);
		}
	}
	public static class Leaderboards
	{
		public static Request<LeaderboardEntryList> GetNextEntries(LeaderboardEntryList list)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1310751961));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetPreviousEntries(LeaderboardEntryList list)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_HTTP_GetWithMessageType(list.PreviousUrl, 1224858304));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetEntries(string leaderboardName, int limit, LeaderboardFilterType filter, LeaderboardStartAt startAt)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_Leaderboard_GetEntries(leaderboardName, limit, filter, startAt));
			}
			return null;
		}

		public static Request<LeaderboardEntryList> GetEntriesAfterRank(string leaderboardName, int limit, ulong afterRank)
		{
			if (Core.IsInitialized())
			{
				return new Request<LeaderboardEntryList>(CAPI.ovr_Leaderboard_GetEntriesAfterRank(leaderboardName, limit, afterRank));
			}
			return null;
		}

		public static Request<bool> WriteEntry(string leaderboardName, long score, byte[] extraData = null, bool forceUpdate = false)
		{
			if (Core.IsInitialized())
			{
				return new Request<bool>(CAPI.ovr_Leaderboard_WriteEntry(leaderboardName, score, extraData, (extraData != null) ? ((uint)extraData.Length) : 0u, forceUpdate));
			}
			return null;
		}
	}
	public static class Voip
	{
		public static void Start(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_Start(userID);
			}
		}

		public static void Accept(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_Accept(userID);
			}
		}

		public static void Stop(ulong userID)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_Stop(userID);
			}
		}

		public static void SetMicrophoneFilterCallback(CAPI.FilterCallback callback)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_SetMicrophoneFilterCallbackWithFixedSizeBuffer(callback, (UIntPtr)480uL);
			}
		}

		public static void SetMicrophoneMuted(VoipMuteState state)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_SetMicrophoneMuted(state);
			}
		}

		public static VoipMuteState GetSystemVoipMicrophoneMuted()
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetSystemVoipMicrophoneMuted();
			}
			return VoipMuteState.Unknown;
		}

		public static SystemVoipStatus GetSystemVoipStatus()
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetSystemVoipStatus();
			}
			return SystemVoipStatus.Unknown;
		}

		public static VoipDtxState GetIsConnectionUsingDtx(ulong peerID)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetIsConnectionUsingDtx(peerID);
			}
			return VoipDtxState.Unknown;
		}

		public static VoipBitrate GetLocalBitrate(ulong peerID)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetLocalBitrate(peerID);
			}
			return VoipBitrate.Unknown;
		}

		public static VoipBitrate GetRemoteBitrate(ulong peerID)
		{
			if (Core.IsInitialized())
			{
				return CAPI.ovr_Voip_GetRemoteBitrate(peerID);
			}
			return VoipBitrate.Unknown;
		}

		public static void SetNewConnectionOptions(VoipOptions voipOptions)
		{
			if (Core.IsInitialized())
			{
				CAPI.ovr_Voip_SetNewConnectionOptions((IntPtr)voipOptions);
			}
		}

		public static Request<SystemVoipState> SetSystemVoipSuppressed(bool suppressed)
		{
			if (Core.IsInitialized())
			{
				return new Request<SystemVoipState>(CAPI.ovr_Voip_SetSystemVoipSuppressed(suppressed));
			}
			return null;
		}

		public static void SetVoipConnectRequestCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Voip_ConnectRequest, callback);
		}

		public static void SetVoipStateChangeCallback(Message<NetworkingPeer>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Voip_StateChange, callback);
		}

		public static void SetSystemVoipStateNotificationCallback(Message<SystemVoipState>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Voip_SystemVoipState, callback);
		}
	}
	public static class Achievements
	{
		public static Request<AchievementUpdate> AddCount(string name, ulong count)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementUpdate>(CAPI.ovr_Achievements_AddCount(name, count));
			}
			return null;
		}

		public static Request<AchievementUpdate> AddFields(string name, string fields)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementUpdate>(CAPI.ovr_Achievements_AddFields(name, fields));
			}
			return null;
		}

		public static Request<AchievementDefinitionList> GetAllDefinitions()
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementDefinitionList>(CAPI.ovr_Achievements_GetAllDefinitions());
			}
			return null;
		}

		public static Request<AchievementProgressList> GetAllProgress()
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementProgressList>(CAPI.ovr_Achievements_GetAllProgress());
			}
			return null;
		}

		public static Request<AchievementDefinitionList> GetDefinitionsByName(string[] names)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementDefinitionList>(CAPI.ovr_Achievements_GetDefinitionsByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Request<AchievementProgressList> GetProgressByName(string[] names)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementProgressList>(CAPI.ovr_Achievements_GetProgressByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Request<AchievementUpdate> Unlock(string name)
		{
			if (Core.IsInitialized())
			{
				return new Request<AchievementUpdate>(CAPI.ovr_Achievements_Unlock(name));
			}
			return null;
		}

		public static Request<AchievementDefinitionList> GetNextAchievementDefinitionListPage(AchievementDefinitionList list)
		{
			if (!list.HasNextPage)
			{
				Debug.LogWarning("Oculus.Platform.GetNextAchievementDefinitionListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<AchievementDefinitionList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 712888917));
			}
			return null;
		}

		public static Request<AchievementProgressList> GetNextAchievementProgressListPage(AchievementProgressList list)
		{
			if (!list.HasNextPage)
			{
				Debug.LogWarning("Oculus.Platform.GetNextAchievementProgressListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<AchievementProgressList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 792913703));
			}
			return null;
		}
	}
	public static class Application
	{
		public static Request<ApplicationVersion> GetVersion()
		{
			if (Core.IsInitialized())
			{
				return new Request<ApplicationVersion>(CAPI.ovr_Application_GetVersion());
			}
			return null;
		}

		public static Request<string> LaunchOtherApp(ulong appID, ApplicationOptions deeplink_options = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<string>(CAPI.ovr_Application_LaunchOtherApp(appID, (IntPtr)deeplink_options));
			}
			return null;
		}
	}
	public static class AssetFile
	{
		public static Request<AssetFileDeleteResult> Delete(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDeleteResult>(CAPI.ovr_AssetFile_Delete(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDeleteResult> DeleteById(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDeleteResult>(CAPI.ovr_AssetFile_DeleteById(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDeleteResult> DeleteByName(string assetFileName)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDeleteResult>(CAPI.ovr_AssetFile_DeleteByName(assetFileName));
			}
			return null;
		}

		public static Request<AssetFileDownloadResult> Download(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadResult>(CAPI.ovr_AssetFile_Download(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDownloadResult> DownloadById(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadResult>(CAPI.ovr_AssetFile_DownloadById(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDownloadResult> DownloadByName(string assetFileName)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadResult>(CAPI.ovr_AssetFile_DownloadByName(assetFileName));
			}
			return null;
		}

		public static Request<AssetFileDownloadCancelResult> DownloadCancel(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadCancelResult>(CAPI.ovr_AssetFile_DownloadCancel(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDownloadCancelResult> DownloadCancelById(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadCancelResult>(CAPI.ovr_AssetFile_DownloadCancelById(assetFileID));
			}
			return null;
		}

		public static Request<AssetFileDownloadCancelResult> DownloadCancelByName(string assetFileName)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadCancelResult>(CAPI.ovr_AssetFile_DownloadCancelByName(assetFileName));
			}
			return null;
		}

		public static Request<AssetDetailsList> GetList()
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetailsList>(CAPI.ovr_AssetFile_GetList());
			}
			return null;
		}

		public static Request<AssetDetails> Status(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetails>(CAPI.ovr_AssetFile_Status(assetFileID));
			}
			return null;
		}

		public static Request<AssetDetails> StatusById(ulong assetFileID)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetails>(CAPI.ovr_AssetFile_StatusById(assetFileID));
			}
			return null;
		}

		public static Request<AssetDetails> StatusByName(string assetFileName)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetails>(CAPI.ovr_AssetFile_StatusByName(assetFileName));
			}
			return null;
		}

		public static void SetDownloadUpdateNotificationCallback(Message<AssetFileDownloadUpdate>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_AssetFile_DownloadUpdate, callback);
		}
	}
	public static class Avatar
	{
	}
	public static class Cal
	{
	}
	public static class CloudStorage
	{
		public static Request<CloudStorageUpdateResponse> Delete(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_Delete(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageData> Load(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageData>(CAPI.ovr_CloudStorage_Load(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageMetadataList> LoadBucketMetadata(string bucket)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageMetadataList>(CAPI.ovr_CloudStorage_LoadBucketMetadata(bucket));
			}
			return null;
		}

		public static Request<CloudStorageConflictMetadata> LoadConflictMetadata(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageConflictMetadata>(CAPI.ovr_CloudStorage_LoadConflictMetadata(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageData> LoadHandle(string handle)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageData>(CAPI.ovr_CloudStorage_LoadHandle(handle));
			}
			return null;
		}

		public static Request<CloudStorageMetadata> LoadMetadata(string bucket, string key)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageMetadata>(CAPI.ovr_CloudStorage_LoadMetadata(bucket, key));
			}
			return null;
		}

		public static Request<CloudStorageUpdateResponse> ResolveKeepLocal(string bucket, string key, string remoteHandle)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_ResolveKeepLocal(bucket, key, remoteHandle));
			}
			return null;
		}

		public static Request<CloudStorageUpdateResponse> ResolveKeepRemote(string bucket, string key, string remoteHandle)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_ResolveKeepRemote(bucket, key, remoteHandle));
			}
			return null;
		}

		public static Request<CloudStorageUpdateResponse> Save(string bucket, string key, byte[] data, long counter, string extraData)
		{
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageUpdateResponse>(CAPI.ovr_CloudStorage_Save(bucket, key, data, (data != null) ? ((uint)data.Length) : 0u, counter, extraData));
			}
			return null;
		}

		public static Request<CloudStorageMetadataList> GetNextCloudStorageMetadataListPage(CloudStorageMetadataList list)
		{
			if (!list.HasNextPage)
			{
				Debug.LogWarning("Oculus.Platform.GetNextCloudStorageMetadataListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<CloudStorageMetadataList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1544004335));
			}
			return null;
		}
	}
	public static class CloudStorage2
	{
	}
	public static class Entitlements
	{
		public static Request IsUserEntitledToApplication()
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Entitlement_GetIsViewerEntitled());
			}
			return null;
		}
	}
	public static class GraphAPI
	{
	}
	public static class HTTP
	{
	}
	public static class IAP
	{
		public static Request ConsumePurchase(string sku)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_IAP_ConsumePurchase(sku));
			}
			return null;
		}

		public static Request<ProductList> GetProductsBySKU(string[] skus)
		{
			if (Core.IsInitialized())
			{
				return new Request<ProductList>(CAPI.ovr_IAP_GetProductsBySKU(skus, (skus != null) ? skus.Length : 0));
			}
			return null;
		}

		public static Request<PurchaseList> GetViewerPurchases()
		{
			if (Core.IsInitialized())
			{
				return new Request<PurchaseList>(CAPI.ovr_IAP_GetViewerPurchases());
			}
			return null;
		}

		public static Request<Purchase> LaunchCheckoutFlow(string sku)
		{
			if (Core.IsInitialized())
			{
				if (UnityEngine.Application.isEditor)
				{
					throw new NotImplementedException("LaunchCheckoutFlow() is not implemented in the editor yet.");
				}
				return new Request<Purchase>(CAPI.ovr_IAP_LaunchCheckoutFlow(sku));
			}
			return null;
		}

		public static Request<ProductList> GetNextProductListPage(ProductList list)
		{
			if (!list.HasNextPage)
			{
				Debug.LogWarning("Oculus.Platform.GetNextProductListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<ProductList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 467225263));
			}
			return null;
		}

		public static Request<PurchaseList> GetNextPurchaseListPage(PurchaseList list)
		{
			if (!list.HasNextPage)
			{
				Debug.LogWarning("Oculus.Platform.GetNextPurchaseListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<PurchaseList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 1196886677));
			}
			return null;
		}
	}
	public static class LanguagePack
	{
		public static Request<AssetDetails> GetCurrent()
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetDetails>(CAPI.ovr_LanguagePack_GetCurrent());
			}
			return null;
		}

		public static Request<AssetFileDownloadResult> SetCurrent(string tag)
		{
			if (Core.IsInitialized())
			{
				return new Request<AssetFileDownloadResult>(CAPI.ovr_LanguagePack_SetCurrent(tag));
			}
			return null;
		}
	}
	public static class Livestreaming
	{
		public static Request<LivestreamingStatus> GetStatus()
		{
			if (Core.IsInitialized())
			{
				return new Request<LivestreamingStatus>(CAPI.ovr_Livestreaming_GetStatus());
			}
			return null;
		}

		public static Request<LivestreamingStatus> PauseStream()
		{
			if (Core.IsInitialized())
			{
				return new Request<LivestreamingStatus>(CAPI.ovr_Livestreaming_PauseStream());
			}
			return null;
		}

		public static Request<LivestreamingStatus> ResumeStream()
		{
			if (Core.IsInitialized())
			{
				return new Request<LivestreamingStatus>(CAPI.ovr_Livestreaming_ResumeStream());
			}
			return null;
		}

		public static void SetStatusUpdateNotificationCallback(Message<LivestreamingStatus>.Callback callback)
		{
			Callback.SetNotificationCallback(Message.MessageType.Notification_Livestreaming_StatusChange, callback);
		}
	}
	public static class Media
	{
		public static Request<ShareMediaResult> ShareToFacebook(string postTextSuggestion, string filePath, MediaContentType contentType)
		{
			if (Core.IsInitialized())
			{
				return new Request<ShareMediaResult>(CAPI.ovr_Media_ShareToFacebook(postTextSuggestion, filePath, contentType));
			}
			return null;
		}
	}
	public static class Notifications
	{
		public static Request<RoomInviteNotificationList> GetRoomInviteNotifications()
		{
			if (Core.IsInitialized())
			{
				return new Request<RoomInviteNotificationList>(CAPI.ovr_Notification_GetRoomInvites());
			}
			return null;
		}

		public static Request MarkAsRead(ulong notificationID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_Notification_MarkAsRead(notificationID));
			}
			return null;
		}

		public static Request<RoomInviteNotificationList> GetNextRoomInviteNotificationListPage(RoomInviteNotificationList list)
		{
			if (!list.HasNextPage)
			{
				Debug.LogWarning("Oculus.Platform.GetNextRoomInviteNotificationListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<RoomInviteNotificationList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 102890359));
			}
			return null;
		}
	}
	public static class Parties
	{
		public static Request<Party> GetCurrent()
		{
			if (Core.IsInitialized())
			{
				return new Request<Party>(CAPI.ovr_Party_GetCurrent());
			}
			return null;
		}
	}
	public static class Users
	{
		public static Request<User> Get(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<User>(CAPI.ovr_User_Get(userID));
			}
			return null;
		}

		public static Request<string> GetAccessToken()
		{
			if (Core.IsInitialized())
			{
				return new Request<string>(CAPI.ovr_User_GetAccessToken());
			}
			return null;
		}

		public static Request<User> GetLoggedInUser()
		{
			if (Core.IsInitialized())
			{
				return new Request<User>(CAPI.ovr_User_GetLoggedInUser());
			}
			return null;
		}

		public static Request<UserList> GetLoggedInUserFriends()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_User_GetLoggedInUserFriends());
			}
			return null;
		}

		public static Request<UserAndRoomList> GetLoggedInUserFriendsAndRooms()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserAndRoomList>(CAPI.ovr_User_GetLoggedInUserFriendsAndRooms());
			}
			return null;
		}

		public static Request<UserAndRoomList> GetLoggedInUserRecentlyMetUsersAndRooms(UserOptions userOptions = null)
		{
			if (Core.IsInitialized())
			{
				return new Request<UserAndRoomList>(CAPI.ovr_User_GetLoggedInUserRecentlyMetUsersAndRooms((IntPtr)userOptions));
			}
			return null;
		}

		public static Request<OrgScopedID> GetOrgScopedID(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<OrgScopedID>(CAPI.ovr_User_GetOrgScopedID(userID));
			}
			return null;
		}

		public static Request<SdkAccountList> GetSdkAccounts()
		{
			if (Core.IsInitialized())
			{
				return new Request<SdkAccountList>(CAPI.ovr_User_GetSdkAccounts());
			}
			return null;
		}

		public static Request<UserProof> GetUserProof()
		{
			if (Core.IsInitialized())
			{
				return new Request<UserProof>(CAPI.ovr_User_GetUserProof());
			}
			return null;
		}

		public static Request<LaunchFriendRequestFlowResult> LaunchFriendRequestFlow(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request<LaunchFriendRequestFlowResult>(CAPI.ovr_User_LaunchFriendRequestFlow(userID));
			}
			return null;
		}

		public static Request LaunchProfile(ulong userID)
		{
			if (Core.IsInitialized())
			{
				return new Request(CAPI.ovr_User_LaunchProfile(userID));
			}
			return null;
		}

		public static Request<UserAndRoomList> GetNextUserAndRoomListPage(UserAndRoomList list)
		{
			if (!list.HasNextPage)
			{
				Debug.LogWarning("Oculus.Platform.GetNextUserAndRoomListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<UserAndRoomList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 2143146719));
			}
			return null;
		}

		public static Request<UserList> GetNextUserListPage(UserList list)
		{
			if (!list.HasNextPage)
			{
				Debug.LogWarning("Oculus.Platform.GetNextUserListPage: List has no next page");
				return null;
			}
			if (Core.IsInitialized())
			{
				return new Request<UserList>(CAPI.ovr_HTTP_GetWithMessageType(list.NextUrl, 645723971));
			}
			return null;
		}
	}
	public enum PlatformInitializeResult
	{
		[Description("SUCCESS")]
		Success = 0,
		[Description("UNINITIALIZED")]
		Uninitialized = -1,
		[Description("PRE_LOADED")]
		PreLoaded = -2,
		[Description("FILE_INVALID")]
		FileInvalid = -3,
		[Description("SIGNATURE_INVALID")]
		SignatureInvalid = -4,
		[Description("UNABLE_TO_VERIFY")]
		UnableToVerify = -5,
		[Description("VERSION_MISMATCH")]
		VersionMismatch = -6,
		[Description("UNKNOWN")]
		Unknown = -7,
		[Description("INVALID_CREDENTIALS")]
		InvalidCredentials = -8,
		[Description("NOT_ENTITLED")]
		NotEntitled = -9
	}
	public static class PlatformInternal
	{
		public enum MessageTypeInternal : uint
		{
			Application_ExecuteCoordinatedLaunch = 645772532u,
			Application_GetInstalledApplications = 1376744524u,
			Avatar_UpdateMetaData = 2077219214u,
			Cal_FinalizeApplication = 497667029u,
			Cal_GetSuggestedApplications = 1450209301u,
			Cal_ProposeApplication = 1317270237u,
			CloudStorage2_GetUserDirectoryPath = 1990471406u,
			GraphAPI_Get = 822018158u,
			GraphAPI_Post = 1990567876u,
			HTTP_Get = 1874211363u,
			HTTP_GetToFile = 1317133401u,
			HTTP_MultiPartPost = 1480774160u,
			HTTP_Post = 1798743375u,
			Livestreaming_IsAllowedForApplication = 191729014u,
			Livestreaming_StartPartyStream = 2066701532u,
			Livestreaming_StartStream = 1343932350u,
			Livestreaming_StopPartyStream = 661065560u,
			Livestreaming_StopStream = 1155796426u,
			Livestreaming_UpdateCommentsOverlayVisibility = 528318516u,
			Livestreaming_UpdateMicStatus = 475495815u,
			Party_Create = 450042703u,
			Party_GatherInApplication = 1921499523u,
			Party_Get = 1586058173u,
			Party_GetCurrentForUser = 1489764138u,
			Party_Invite = 901104867u,
			Party_Join = 1744993395u,
			Party_Leave = 848430801u,
			Room_CreateOrUpdateAndJoinNamed = 2089683601u,
			Room_GetNamedRooms = 125660812u,
			Room_GetSocialRooms = 1636310390u,
			SystemPermissions_GetStatus = 493497353u,
			SystemPermissions_LaunchDeeplink = 442139697u,
			User_CancelRecordingForReportFlow = 65065289u,
			User_GetLinkedAccounts = 1469314134u,
			User_LaunchBlockFlow = 1876305192u,
			User_LaunchReportFlow = 1449304081u,
			User_LaunchReportFlow2 = 2139314275u,
			User_LaunchUnblockFlow = 346172055u,
			User_NewEntitledTestUser = 292822787u,
			User_NewTestUser = 921194380u,
			User_NewTestUserFriends = 517416647u,
			User_StartRecordingForReportFlow = 1819161571u,
			User_StopRecordingAndLaunchReportFlow = 1618513035u,
			User_StopRecordingAndLaunchReportFlow2 = 432190251u,
			User_TestUserCreateDeviceManifest = 1701884605u
		}

		public static class HTTP
		{
			public static void SetHttpTransferUpdateCallback(Message<HttpTransferUpdate>.Callback callback)
			{
				Callback.SetNotificationCallback(Message.MessageType.Notification_HTTP_Transfer, callback);
			}
		}

		public static void CrashApplication()
		{
			CAPI.ovr_CrashApplication();
		}

		internal static Message ParseMessageHandle(IntPtr messageHandle, Message.MessageType messageType)
		{
			Message result = null;
			switch ((MessageTypeInternal)messageType)
			{
			case MessageTypeInternal.User_StartRecordingForReportFlow:
				result = new MessageWithAbuseReportRecording(messageHandle);
				break;
			case MessageTypeInternal.Cal_FinalizeApplication:
				result = new MessageWithCalApplicationFinalized(messageHandle);
				break;
			case MessageTypeInternal.Cal_GetSuggestedApplications:
				result = new MessageWithCalApplicationSuggestionList(messageHandle);
				break;
			case MessageTypeInternal.User_CancelRecordingForReportFlow:
			case MessageTypeInternal.Livestreaming_UpdateMicStatus:
			case MessageTypeInternal.Application_ExecuteCoordinatedLaunch:
			case MessageTypeInternal.Livestreaming_StopPartyStream:
			case MessageTypeInternal.Party_Leave:
			case MessageTypeInternal.Cal_ProposeApplication:
			case MessageTypeInternal.User_TestUserCreateDeviceManifest:
				result = new Message(messageHandle);
				break;
			case MessageTypeInternal.Application_GetInstalledApplications:
				result = new MessageWithInstalledApplicationList(messageHandle);
				break;
			case MessageTypeInternal.User_LaunchBlockFlow:
				result = new MessageWithLaunchBlockFlowResult(messageHandle);
				break;
			case MessageTypeInternal.User_LaunchReportFlow2:
				result = new MessageWithLaunchReportFlowResult(messageHandle);
				break;
			case MessageTypeInternal.User_LaunchUnblockFlow:
				result = new MessageWithLaunchUnblockFlowResult(messageHandle);
				break;
			case MessageTypeInternal.User_GetLinkedAccounts:
				result = new MessageWithLinkedAccountList(messageHandle);
				break;
			case MessageTypeInternal.Livestreaming_IsAllowedForApplication:
				result = new MessageWithLivestreamingApplicationStatus(messageHandle);
				break;
			case MessageTypeInternal.Livestreaming_StartStream:
			case MessageTypeInternal.Livestreaming_StartPartyStream:
				result = new MessageWithLivestreamingStartResult(messageHandle);
				break;
			case MessageTypeInternal.Livestreaming_UpdateCommentsOverlayVisibility:
				result = new MessageWithLivestreamingStatus(messageHandle);
				break;
			case MessageTypeInternal.Livestreaming_StopStream:
				result = new MessageWithLivestreamingVideoStats(messageHandle);
				break;
			case MessageTypeInternal.Party_Get:
				result = new MessageWithParty(messageHandle);
				break;
			case MessageTypeInternal.Party_GetCurrentForUser:
				result = new MessageWithPartyUnderCurrentParty(messageHandle);
				break;
			case MessageTypeInternal.Party_Create:
			case MessageTypeInternal.Party_Invite:
			case MessageTypeInternal.Party_Join:
			case MessageTypeInternal.Party_GatherInApplication:
				result = new MessageWithPartyID(messageHandle);
				break;
			case MessageTypeInternal.Room_CreateOrUpdateAndJoinNamed:
				result = new MessageWithRoomUnderViewerRoom(messageHandle);
				break;
			case MessageTypeInternal.Room_GetNamedRooms:
			case MessageTypeInternal.Room_GetSocialRooms:
				result = new MessageWithRoomList(messageHandle);
				break;
			case MessageTypeInternal.User_NewEntitledTestUser:
			case MessageTypeInternal.User_NewTestUserFriends:
			case MessageTypeInternal.GraphAPI_Get:
			case MessageTypeInternal.User_NewTestUser:
			case MessageTypeInternal.HTTP_GetToFile:
			case MessageTypeInternal.HTTP_MultiPartPost:
			case MessageTypeInternal.HTTP_Post:
			case MessageTypeInternal.HTTP_Get:
			case MessageTypeInternal.CloudStorage2_GetUserDirectoryPath:
			case MessageTypeInternal.GraphAPI_Post:
			case MessageTypeInternal.Avatar_UpdateMetaData:
				result = new MessageWithString(messageHandle);
				break;
			case MessageTypeInternal.SystemPermissions_LaunchDeeplink:
			case MessageTypeInternal.SystemPermissions_GetStatus:
				result = new MessageWithSystemPermission(messageHandle);
				break;
			case MessageTypeInternal.User_StopRecordingAndLaunchReportFlow2:
			case MessageTypeInternal.User_LaunchReportFlow:
			case MessageTypeInternal.User_StopRecordingAndLaunchReportFlow:
				result = new MessageWithUserReportID(messageHandle);
				break;
			}
			return result;
		}
	}
	public sealed class PlatformSettings : ScriptableObject
	{
		[SerializeField]
		private string ovrAppID = string.Empty;

		[SerializeField]
		private string ovrMobileAppID = string.Empty;

		[SerializeField]
		private bool ovrUseStandalonePlatform = true;

		[SerializeField]
		private bool ovrEnableARM64Support;

		private static PlatformSettings instance;

		public static string AppID
		{
			get
			{
				return Instance.ovrAppID;
			}
			set
			{
				Instance.ovrAppID = value;
			}
		}

		public static string MobileAppID
		{
			get
			{
				return Instance.ovrMobileAppID;
			}
			set
			{
				Instance.ovrMobileAppID = value;
			}
		}

		public static bool UseStandalonePlatform
		{
			get
			{
				return Instance.ovrUseStandalonePlatform;
			}
			set
			{
				Instance.ovrUseStandalonePlatform = value;
			}
		}

		public static bool EnableARM64Support
		{
			get
			{
				return Instance.ovrEnableARM64Support;
			}
			set
			{
				Instance.ovrEnableARM64Support = value;
			}
		}

		public static PlatformSettings Instance
		{
			get
			{
				if (instance == null)
				{
					instance = Resources.Load<PlatformSettings>("OculusPlatformSettings");
					if (instance == null)
					{
						instance = ScriptableObject.CreateInstance<PlatformSettings>();
					}
				}
				return instance;
			}
			set
			{
				instance = value;
			}
		}
	}
	public sealed class Request<T> : Request
	{
		public Request(ulong requestID)
			: base(requestID)
		{
		}

		public Request<T> OnComplete(Message<T>.Callback callback)
		{
			Callback.OnComplete(this, callback);
			return this;
		}
	}
	public class Request
	{
		public ulong RequestID { get; set; }

		public Request(ulong requestID)
		{
			RequestID = requestID;
		}

		public Request OnComplete(Message.Callback callback)
		{
			Callback.OnComplete(this, callback);
			return this;
		}

		public static void RunCallbacks(uint limit = 0u)
		{
			if (limit == 0)
			{
				Callback.RunCallbacks();
			}
			else
			{
				Callback.RunLimitedCallbacks(limit);
			}
		}
	}
	public enum RoomJoinability
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ARE_IN")]
		AreIn,
		[Description("ARE_KICKED")]
		AreKicked,
		[Description("CAN_JOIN")]
		CanJoin,
		[Description("IS_FULL")]
		IsFull,
		[Description("NO_VIEWER")]
		NoViewer,
		[Description("POLICY_PREVENTS")]
		PolicyPrevents
	}
	public enum RoomJoinPolicy
	{
		[Description("NONE")]
		None,
		[Description("EVERYONE")]
		Everyone,
		[Description("FRIENDS_OF_MEMBERS")]
		FriendsOfMembers,
		[Description("FRIENDS_OF_OWNER")]
		FriendsOfOwner,
		[Description("INVITED_USERS")]
		InvitedUsers,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum RoomMembershipLockStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("LOCK")]
		Lock,
		[Description("UNLOCK")]
		Unlock
	}
	public class RoomOptions
	{
		private IntPtr Handle;

		public RoomOptions()
		{
			Handle = CAPI.ovr_RoomOptions_Create();
		}

		public void SetDataStore(string key, string value)
		{
			CAPI.ovr_RoomOptions_SetDataStoreString(Handle, key, value);
		}

		public void ClearDataStore()
		{
			CAPI.ovr_RoomOptions_ClearDataStore(Handle);
		}

		public void SetExcludeRecentlyMet(bool value)
		{
			CAPI.ovr_RoomOptions_SetExcludeRecentlyMet(Handle, value);
		}

		public void SetMaxUserResults(uint value)
		{
			CAPI.ovr_RoomOptions_SetMaxUserResults(Handle, value);
		}

		public void SetOrdering(UserOrdering value)
		{
			CAPI.ovr_RoomOptions_SetOrdering(Handle, value);
		}

		public void SetRecentlyMetTimeWindow(TimeWindow value)
		{
			CAPI.ovr_RoomOptions_SetRecentlyMetTimeWindow(Handle, value);
		}

		public void SetRoomId(ulong value)
		{
			CAPI.ovr_RoomOptions_SetRoomId(Handle, value);
		}

		public void SetTurnOffUpdates(bool value)
		{
			CAPI.ovr_RoomOptions_SetTurnOffUpdates(Handle, value);
		}

		public static explicit operator IntPtr(RoomOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~RoomOptions()
		{
			CAPI.ovr_RoomOptions_Destroy(Handle);
		}
	}
	public enum RoomType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MATCHMAKING")]
		Matchmaking,
		[Description("MODERATED")]
		Moderated,
		[Description("PRIVATE")]
		Private,
		[Description("SOLO")]
		Solo
	}
	public enum SdkAccountType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("OCULUS")]
		Oculus,
		[Description("FACEBOOK_GAMEROOM")]
		FacebookGameroom
	}
	public enum SendPolicy
	{
		[Description("UNRELIABLE")]
		Unreliable,
		[Description("RELIABLE")]
		Reliable,
		[Description("UNKNOWN")]
		Unknown
	}
	public enum ServiceProvider
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("DROPBOX")]
		Dropbox,
		[Description("FACEBOOK")]
		Facebook,
		[Description("GOOGLE")]
		Google,
		[Description("INSTAGRAM")]
		Instagram,
		[Description("REMOTE_MEDIA")]
		RemoteMedia
	}
	public enum ShareMediaStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SHARED")]
		Shared,
		[Description("CANCELED")]
		Canceled
	}
	public sealed class StandalonePlatform
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void UnityLogDelegate(IntPtr tag, IntPtr msg);

		public Request<PlatformInitialize> InitializeInEditor()
		{
			if (string.IsNullOrEmpty(PlatformSettings.MobileAppID))
			{
				throw new UnityException("Update your App ID by selecting 'Oculus Platform' -> 'Edit Settings'");
			}
			string mobileAppID = PlatformSettings.MobileAppID;
			if (string.IsNullOrEmpty(StandalonePlatformSettings.OculusPlatformTestUserAccessToken))
			{
				throw new UnityException("Update your standalone credentials by selecting 'Oculus Platform' -> 'Edit Settings'");
			}
			string oculusPlatformTestUserAccessToken = StandalonePlatformSettings.OculusPlatformTestUserAccessToken;
			CAPI.ovr_UnityResetTestPlatform();
			CAPI.ovr_UnityInitGlobals(IntPtr.Zero);
			return new Request<PlatformInitialize>(CAPI.ovr_PlatformInitializeWithAccessToken(ulong.Parse(mobileAppID), oculusPlatformTestUserAccessToken));
		}
	}
	public sealed class StandalonePlatformSettings
	{
		public static string OculusPlatformTestUserEmail
		{
			get
			{
				return string.Empty;
			}
			set
			{
			}
		}

		public static string OculusPlatformTestUserPassword
		{
			get
			{
				return string.Empty;
			}
			set
			{
			}
		}

		public static string OculusPlatformTestUserAccessToken
		{
			get
			{
				return string.Empty;
			}
			set
			{
			}
		}
	}
	public enum SystemVoipStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("UNAVAILABLE")]
		Unavailable,
		[Description("SUPPRESSED")]
		Suppressed,
		[Description("ACTIVE")]
		Active
	}
	public enum TimeWindow
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ONE_HOUR")]
		OneHour,
		[Description("ONE_DAY")]
		OneDay,
		[Description("ONE_WEEK")]
		OneWeek,
		[Description("THIRTY_DAYS")]
		ThirtyDays,
		[Description("NINETY_DAYS")]
		NinetyDays
	}
	public class UserOptions
	{
		private IntPtr Handle;

		public UserOptions()
		{
			Handle = CAPI.ovr_UserOptions_Create();
		}

		public void SetMaxUsers(uint value)
		{
			CAPI.ovr_UserOptions_SetMaxUsers(Handle, value);
		}

		public void AddServiceProvider(ServiceProvider value)
		{
			CAPI.ovr_UserOptions_AddServiceProvider(Handle, value);
		}

		public void ClearServiceProviders()
		{
			CAPI.ovr_UserOptions_ClearServiceProviders(Handle);
		}

		public void SetTimeWindow(TimeWindow value)
		{
			CAPI.ovr_UserOptions_SetTimeWindow(Handle, value);
		}

		public static explicit operator IntPtr(UserOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~UserOptions()
		{
			CAPI.ovr_UserOptions_Destroy(Handle);
		}
	}
	public enum UserOrdering
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("NONE")]
		None,
		[Description("PRESENCE_ALPHABETICAL")]
		PresenceAlphabetical
	}
	public enum UserPresenceStatus
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ONLINE")]
		Online,
		[Description("OFFLINE")]
		Offline
	}
	public class VoipAudioSourceHiLevel : MonoBehaviour
	{
		public class FilterReadDelegate : MonoBehaviour
		{
			public VoipAudioSourceHiLevel parent;

			private float[] scratchBuffer;

			private void Awake()
			{
				int num = (int)(uint)CAPI.ovr_Voip_GetOutputBufferMaxSize();
				scratchBuffer = new float[num];
			}

			private void OnAudioFilterRead(float[] data, int channels)
			{
				int num = data.Length / channels;
				int num2 = num;
				if (num2 > scratchBuffer.Length)
				{
					Array.Clear(data, 0, data.Length);
					throw new Exception($"Audio system tried to pull {num} bytes, max voip internal ring buffer size {scratchBuffer.Length}");
				}
				int num3 = parent.pcmSource.PeekSizeElements();
				if (num3 < num2)
				{
					if (verboseLogging)
					{
						Debug.LogFormat("Voip starved! Want {0}, but only have {1} available", num2, num3);
					}
					return;
				}
				int pCM = parent.pcmSource.GetPCM(scratchBuffer, num2);
				if (pCM < num2)
				{
					Debug.LogWarningFormat("GetPCM() returned {0} samples, expected {1}", pCM, num2);
					return;
				}
				int num4 = 0;
				float num5 = -1f;
				for (int i = 0; i < num; i++)
				{
					float num6 = scratchBuffer[i];
					for (int j = 0; j < channels; j++)
					{
						data[num4++] = num6;
						if (num6 > num5)
						{
							num5 = num6;
						}
					}
				}
				parent.peakAmplitude = num5;
			}
		}

		private int initialPlaybackDelayMS;

		public AudioSource audioSource;

		public float peakAmplitude;

		protected IVoipPCMSource pcmSource;

		private static int audioSystemPlaybackFrequency;

		private static bool verboseLogging;

		public ulong senderID
		{
			set
			{
				pcmSource.SetSenderID(value);
			}
		}

		protected void Stop()
		{
		}

		private VoipSampleRate SampleRateToEnum(int rate)
		{
			return rate switch
			{
				48000 => VoipSampleRate.HZ48000, 
				44100 => VoipSampleRate.HZ44100, 
				24000 => VoipSampleRate.HZ24000, 
				_ => VoipSampleRate.Unknown, 
			};
		}

		protected void Awake()
		{
			CreatePCMSource();
			if (audioSource == null)
			{
				audioSource = base.gameObject.AddComponent<AudioSource>();
			}
			audioSource.gameObject.AddComponent<FilterReadDelegate>();
			FilterReadDelegate component = audioSource.gameObject.GetComponent<FilterReadDelegate>();
			component.parent = this;
			initialPlaybackDelayMS = 40;
			audioSystemPlaybackFrequency = AudioSettings.outputSampleRate;
			CAPI.ovr_Voip_SetOutputSampleRate(SampleRateToEnum(audioSystemPlaybackFrequency));
			if (verboseLogging)
			{
				Debug.LogFormat("freq {0}", audioSystemPlaybackFrequency);
			}
		}

		private void Start()
		{
			audioSource.Stop();
		}

		protected virtual void CreatePCMSource()
		{
			pcmSource = new VoipPCMSourceNative();
		}

		protected static int MSToElements(int ms)
		{
			return ms * audioSystemPlaybackFrequency / 1000;
		}

		private void Update()
		{
			pcmSource.Update();
			if (!audioSource.isPlaying && pcmSource.PeekSizeElements() >= MSToElements(initialPlaybackDelayMS))
			{
				if (verboseLogging)
				{
					Debug.LogFormat("buffered {0} elements, starting playback", pcmSource.PeekSizeElements());
				}
				audioSource.Play();
			}
		}
	}
	public enum VoipBitrate
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("B16000")]
		B16000,
		[Description("B24000")]
		B24000,
		[Description("B32000")]
		B32000,
		[Description("B64000")]
		B64000,
		[Description("B96000")]
		B96000,
		[Description("B128000")]
		B128000
	}
	public enum VoipDtxState
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("ENABLED")]
		Enabled,
		[Description("DISABLED")]
		Disabled
	}
	public enum VoipMuteState
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("MUTED")]
		Muted,
		[Description("UNMUTED")]
		Unmuted
	}
	public class VoipOptions
	{
		private IntPtr Handle;

		public VoipOptions()
		{
			Handle = CAPI.ovr_VoipOptions_Create();
		}

		public void SetBitrateForNewConnections(VoipBitrate value)
		{
			CAPI.ovr_VoipOptions_SetBitrateForNewConnections(Handle, value);
		}

		public void SetCreateNewConnectionUseDtx(VoipDtxState value)
		{
			CAPI.ovr_VoipOptions_SetCreateNewConnectionUseDtx(Handle, value);
		}

		public static explicit operator IntPtr(VoipOptions options)
		{
			return options?.Handle ?? IntPtr.Zero;
		}

		~VoipOptions()
		{
			CAPI.ovr_VoipOptions_Destroy(Handle);
		}
	}
	public class VoipPCMSourceNative : IVoipPCMSource
	{
		private ulong senderID;

		public int GetPCM(float[] dest, int length)
		{
			return (int)(uint)CAPI.ovr_Voip_GetPCMFloat(senderID, dest, (UIntPtr)(ulong)length);
		}

		public void SetSenderID(ulong senderID)
		{
			this.senderID = senderID;
		}

		public int PeekSizeElements()
		{
			return (int)(uint)CAPI.ovr_Voip_GetPCMSize(senderID);
		}

		public void Update()
		{
		}
	}
	public enum VoipSampleRate
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("HZ24000")]
		HZ24000,
		[Description("HZ44100")]
		HZ44100,
		[Description("HZ48000")]
		HZ48000
	}
	public class WindowsPlatform
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void UnityLogDelegate(IntPtr tag, IntPtr msg);

		private void CPPLogCallback(IntPtr tag, IntPtr message)
		{
			Debug.Log($"{Marshal.PtrToStringAnsi(tag)}: {Marshal.PtrToStringAnsi(message)}");
		}

		private IntPtr getCallbackPointer()
		{
			return IntPtr.Zero;
		}

		public bool Initialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			CAPI.ovr_UnityInitWrapperWindows(appId, getCallbackPointer());
			return true;
		}

		public Request<PlatformInitialize> AsyncInitialize(string appId)
		{
			if (string.IsNullOrEmpty(appId))
			{
				throw new UnityException("AppID must not be null or empty");
			}
			return new Request<PlatformInitialize>(CAPI.ovr_UnityInitWrapperWindowsAsynchronous(appId, getCallbackPointer()));
		}
	}
}
[AddComponentMenu("Camera-Control/Mouse Look")]
public class MouseLook : MonoBehaviour
{
	public enum RotationAxes
	{
		MouseXAndY,
		MouseX,
		MouseY
	}

	public RotationAxes axes;

	public float sensitivityX = 15f;

	public float sensitivityY = 15f;

	public float minimumX = -360f;

	public float maximumX = 360f;

	public float minimumY = -60f;

	public float maximumY = 60f;

	private float rotationY;

	private void Update()
	{
		if (axes == RotationAxes.MouseXAndY)
		{
			float y = base.transform.localEulerAngles.y + Input.GetAxis("Mouse X") * sensitivityX;
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
			base.transform.localEulerAngles = new Vector3(0f - rotationY, y, 0f);
		}
		else if (axes == RotationAxes.MouseX)
		{
			base.transform.Rotate(0f, Input.GetAxis("Mouse X") * sensitivityX, 0f);
		}
		else
		{
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
			base.transform.localEulerAngles = new Vector3(0f - rotationY, base.transform.localEulerAngles.y, 0f);
		}
	}

	private void Start()
	{
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
	}
}
public struct ReflectionSnapshot
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;
}
public class ONSPReflectionZone : MonoBehaviour
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;

	private static Stack<ReflectionSnapshot> snapshotList = new Stack<ReflectionSnapshot>();

	private static ReflectionSnapshot currentSnapshot = default(ReflectionSnapshot);

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PushCurrentMixerShapshot();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PopCurrentMixerSnapshot();
		}
	}

	private bool CheckForAudioListener(GameObject gameObject)
	{
		AudioListener componentInChildren = gameObject.GetComponentInChildren<AudioListener>();
		if (componentInChildren != null)
		{
			return true;
		}
		return false;
	}

	private void PushCurrentMixerShapshot()
	{
		ReflectionSnapshot t = currentSnapshot;
		snapshotList.Push(t);
		SetReflectionValues();
	}

	private void PopCurrentMixerSnapshot()
	{
		ReflectionSnapshot mss = snapshotList.Pop();
		SetReflectionValues(ref mss);
	}

	private void SetReflectionValues()
	{
		if (mixerSnapshot != null)
		{
			Debug.Log("Setting off snapshot " + mixerSnapshot.name);
			mixerSnapshot.TransitionTo(fadeTime);
			currentSnapshot.mixerSnapshot = mixerSnapshot;
			currentSnapshot.fadeTime = fadeTime;
		}
		else
		{
			Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}

	private void SetReflectionValues(ref ReflectionSnapshot mss)
	{
		if (mss.mixerSnapshot != null)
		{
			Debug.Log("Setting off snapshot " + mss.mixerSnapshot.name);
			mss.mixerSnapshot.TransitionTo(mss.fadeTime);
			currentSnapshot.mixerSnapshot = mss.mixerSnapshot;
			currentSnapshot.fadeTime = mss.fadeTime;
		}
		else
		{
			Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}
}
public class OculusSpatializerUnity : MonoBehaviour
{
	public delegate void AudioRaycastCallback(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data);

	public LayerMask layerMask = -1;

	public bool visualizeRoom = true;

	private bool roomVisualizationInitialized;

	public int raysPerSecond = 256;

	public float roomInterpSpeed = 0.9f;

	public float maxWallDistance = 50f;

	public int rayCacheSize = 512;

	public bool dynamicReflectionsEnabled = true;

	private AudioRaycastCallback _raycastCallback;

	private float particleSize = 0.2f;

	private float particleOffset = 0.1f;

	private GameObject room;

	private Renderer[] wallRenderer = new Renderer[6];

	private float[] dims = new float[3] { 1f, 1f, 1f };

	private float[] coefs = new float[6];

	private const int HIT_COUNT = 2048;

	private Vector3[] points = new Vector3[2048];

	private Vector3[] normals = new Vector3[2048];

	private ParticleSystem sys;

	private ParticleSystem.Particle[] particles = new ParticleSystem.Particle[2048];

	private static LayerMask gLayerMask = -1;

	private const string strOSP = "AudioPluginOculusSpatializer";

	private static Vector3 swapHandedness(Vector3 vec)
	{
		return new Vector3(vec.x, vec.y, 0f - vec.z);
	}

	private static void AudioRaycast(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data)
	{
		point = Vector3.zero;
		normal = Vector3.zero;
		if (Physics.Raycast(swapHandedness(origin), swapHandedness(direction), out var hitInfo, 1000f, gLayerMask.value))
		{
			point = swapHandedness(hitInfo.point);
			normal = swapHandedness(hitInfo.normal);
		}
	}

	private void Start()
	{
		_raycastCallback = AudioRaycast;
		OSP_Unity_AssignRaycastCallback(_raycastCallback, IntPtr.Zero);
	}

	private void OnDestroy()
	{
		OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
	}

	private void Update()
	{
		if (dynamicReflectionsEnabled)
		{
			OSP_Unity_AssignRaycastCallback(_raycastCallback, IntPtr.Zero);
		}
		else
		{
			OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
		}
		OSP_Unity_SetDynamicRoomRaysPerSecond(raysPerSecond);
		OSP_Unity_SetDynamicRoomInterpSpeed(roomInterpSpeed);
		OSP_Unity_SetDynamicRoomMaxWallDistance(maxWallDistance);
		OSP_Unity_SetDynamicRoomRaysRayCacheSize(rayCacheSize);
		gLayerMask = layerMask;
		OSP_Unity_UpdateRoomModel(1f);
		if (!visualizeRoom)
		{
			return;
		}
		if (!roomVisualizationInitialized)
		{
			inititalizeRoomVisualization();
			roomVisualizationInitialized = true;
		}
		OSP_Unity_GetRoomDimensions(dims, coefs, out var position);
		position.z *= -1f;
		Vector3 vector = new Vector3(dims[0], dims[1], dims[2]);
		float sqrMagnitude = vector.sqrMagnitude;
		if (!float.IsNaN(sqrMagnitude) && 0f < sqrMagnitude && sqrMagnitude < 1000000f)
		{
			base.transform.localScale = vector * 0.999f;
		}
		base.transform.position = position;
		OSP_Unity_GetRaycastHits(points, normals, 2048);
		for (int i = 0; i < 2048; i++)
		{
			if (points[i] == Vector3.zero)
			{
				points[i].y = -10000f;
			}
			points[i].z *= -1f;
			normals[i].z *= -1f;
			particles[i].position = points[i] + normals[i] * particleOffset;
			if (normals[i] != Vector3.zero)
			{
				particles[i].rotation3D = Quaternion.LookRotation(normals[i]).eulerAngles;
			}
			particles[i].startSize = particleSize;
			particles[i].startColor = new Color(0.8156863f, 0.14901961f, 58f / 85f, 1f);
		}
		for (int j = 0; j < 6; j++)
		{
			Color value = Color.Lerp(Color.red, Color.green, coefs[j]);
			wallRenderer[j].material.SetColor("_TintColor", value);
		}
		sys.SetParticles(particles, particles.Length);
	}

	private void inititalizeRoomVisualization()
	{
		Debug.Log("Oculus Audio dynamic room estimation visualization enabled");
		base.transform.position = Vector3.zero;
		GameObject gameObject = new GameObject("DecalManager");
		gameObject.transform.parent = base.transform;
		sys = gameObject.AddComponent<ParticleSystem>();
		ParticleSystem.MainModule main = sys.main;
		main.simulationSpace = ParticleSystemSimulationSpace.World;
		main.loop = false;
		main.playOnAwake = false;
		ParticleSystem.EmissionModule emission = sys.emission;
		emission.enabled = false;
		ParticleSystem.ShapeModule shape = sys.shape;
		shape.enabled = false;
		ParticleSystemRenderer component = sys.GetComponent<ParticleSystemRenderer>();
		component.renderMode = ParticleSystemRenderMode.Mesh;
		component.material.shader = Shader.Find("Particles/Additive");
		Texture2D texture2D = new Texture2D(64, 64);
		for (int i = 0; i < 32; i++)
		{
			for (int j = 0; j < 32; j++)
			{
				float num = 32 - i;
				float num2 = 32 - j;
				float num3 = Mathf.Sqrt(num * num + num2 * num2);
				float num4 = 2f * num3 / 32f;
				float a = ((!(num3 < 32f)) ? 0f : Mathf.Clamp01(Mathf.Sin((float)Math.PI * 2f * num4)));
				Color color = new Color(1f, 1f, 1f, a);
				texture2D.SetPixel(i, j, color);
				texture2D.SetPixel(64 - i, j, color);
				texture2D.SetPixel(i, 64 - j, color);
				texture2D.SetPixel(64 - i, 64 - j, color);
			}
		}
		texture2D.Apply();
		component.material.mainTexture = texture2D;
		Mesh mesh = new Mesh();
		mesh.name = "ParticleQuad";
		mesh.vertices = new Vector3[4]
		{
			new Vector3(-0.5f, -0.5f, 0f),
			new Vector3(0.5f, -0.5f, 0f),
			new Vector3(0.5f, 0.5f, 0f),
			new Vector3(-0.5f, 0.5f, 0f)
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(1f, 0f)
		};
		mesh.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
		mesh.RecalculateNormals();
		component.mesh = mesh;
		sys.Emit(2048);
		room = new GameObject("RoomVisualizer");
		room.transform.parent = base.transform;
		room.transform.localPosition = Vector3.zero;
		Texture2D texture2D2 = new Texture2D(32, 32);
		Color color2 = new Color(0f, 0f, 0f, 0f);
		for (int k = 0; k < 32; k++)
		{
			for (int l = 0; l < 32; l++)
			{
				texture2D2.SetPixel(k, l, color2);
			}
		}
		for (int m = 0; m < 32; m++)
		{
			Color color3 = Color.white * 0.125f;
			texture2D2.SetPixel(8, m, color3);
			texture2D2.SetPixel(m, 8, color3);
			texture2D2.SetPixel(24, m, color3);
			texture2D2.SetPixel(m, 24, color3);
			color3 *= 2f;
			texture2D2.SetPixel(16, m, color3);
			texture2D2.SetPixel(m, 16, color3);
			color3 *= 2f;
			texture2D2.SetPixel(0, m, color3);
			texture2D2.SetPixel(m, 0, color3);
		}
		texture2D2.Apply();
		for (int n = 0; n < 6; n++)
		{
			Mesh mesh2 = new Mesh();
			mesh2.name = "Plane" + n;
			Vector3[] array = new Vector3[4];
			int num5 = n / 2;
			int num6 = ((n % 2 == 0) ? 1 : (-1));
			for (int num7 = 0; num7 < 4; num7++)
			{
				array[num7][num5] = (float)num6 * 0.5f;
				array[num7][(num5 + 1) % 3] = 0.5f * (float)((num7 == 1 || num7 == 2) ? 1 : (-1));
				array[num7][(num5 + 2) % 3] = 0.5f * (float)((num7 == 2 || num7 == 3) ? 1 : (-1));
			}
			mesh2.vertices = array;
			mesh2.uv = new Vector2[4]
			{
				new Vector2(0f, 0f),
				new Vector2(0f, 1f),
				new Vector2(1f, 1f),
				new Vector2(1f, 0f)
			};
			mesh2.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
			mesh2.RecalculateNormals();
			GameObject gameObject2 = new GameObject("Wall_" + n);
			gameObject2.AddComponent<MeshFilter>().mesh = mesh2;
			MeshRenderer meshRenderer = gameObject2.AddComponent<MeshRenderer>();
			wallRenderer[n] = meshRenderer;
			meshRenderer.material.shader = Shader.Find("Particles/Additive");
			meshRenderer.material.mainTexture = texture2D2;
			meshRenderer.material.mainTextureScale = new Vector2(8f, 8f);
			gameObject2.transform.parent = room.transform;
			room.transform.localPosition = Vector3.zero;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(MulticastDelegate callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(IntPtr callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysPerSecond(int RaysPerSecond);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomInterpSpeed(float InterpSpeed);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomMaxWallDistance(float MaxWallDistance);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysRayCacheSize(int RayCacheSize);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_UpdateRoomModel(float wetLevel);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRoomDimensions(float[] roomDimensions, float[] reflectionsCoefs, out Vector3 position);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRaycastHits(Vector3[] points, Vector3[] normals, int length);
}
public class ONSPAmbisonicsNative : MonoBehaviour
{
	public enum ovrAmbisonicsNativeStatus
	{
		Uninitialized = -1,
		NotEnabled,
		Success,
		StreamError,
		ProcessError,
		MaxStatValue
	}

	private static int numFOAChannels = 4;

	private static int paramVSpeakerMode = 6;

	private static int paramAmbiStat = 7;

	private ovrAmbisonicsNativeStatus currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;

	[SerializeField]
	private bool useVirtualSpeakers;

	public bool UseVirtualSpeakers
	{
		get
		{
			return useVirtualSpeakers;
		}
		set
		{
			useVirtualSpeakers = value;
		}
	}

	private void OnEnable()
	{
		AudioSource component = GetComponent<AudioSource>();
		currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;
		if (component == null)
		{
			Debug.Log("Ambisonic ERROR: AudioSource does not exist.");
			return;
		}
		if (component.spatialize)
		{
			Debug.Log("Ambisonic WARNING: Turning spatialize field off for Ambisonic sources.");
			component.spatialize = false;
		}
		if (component.clip == null)
		{
			Debug.Log("Ambisonic ERROR: AudioSource does not contain an audio clip.");
		}
		else if (component.clip.channels != numFOAChannels)
		{
			Debug.Log("Ambisonic ERROR: AudioSource clip does not have correct number of channels.");
		}
	}

	private void Update()
	{
		AudioSource component = GetComponent<AudioSource>();
		if (component == null)
		{
			return;
		}
		if (useVirtualSpeakers)
		{
			component.SetAmbisonicDecoderFloat(paramVSpeakerMode, 1f);
		}
		else
		{
			component.SetAmbisonicDecoderFloat(paramVSpeakerMode, 0f);
		}
		float value = 0f;
		component.GetAmbisonicDecoderFloat(paramAmbiStat, out value);
		ovrAmbisonicsNativeStatus ovrAmbisonicsNativeStatus = (ovrAmbisonicsNativeStatus)value;
		if (ovrAmbisonicsNativeStatus != currentStatus)
		{
			switch (ovrAmbisonicsNativeStatus)
			{
			case ovrAmbisonicsNativeStatus.NotEnabled:
				Debug.Log("Ambisonic Native: Ambisonic not enabled on clip. Check clip field and turn it on");
				break;
			case ovrAmbisonicsNativeStatus.Uninitialized:
				Debug.Log("Ambisonic Native: Stream uninitialized");
				break;
			case ovrAmbisonicsNativeStatus.Success:
				Debug.Log("Ambisonic Native: Stream successfully initialized and playing/playable");
				break;
			case ovrAmbisonicsNativeStatus.StreamError:
				Debug.Log("Ambisonic Native WARNING: Stream error (bad input format?)");
				break;
			case ovrAmbisonicsNativeStatus.ProcessError:
				Debug.Log("Ambisonic Native WARNING: Stream process error (check default speaker setup)");
				break;
			}
		}
		currentStatus = ovrAmbisonicsNativeStatus;
	}
}
public class ONSPAudioSource : MonoBehaviour
{
	private enum Parameters
	{
		P_GAIN,
		P_USEINVSQR,
		P_NEAR,
		P_FAR,
		P_RADIUS,
		P_DISABLE_RFL,
		P_VSPEAKERMODE,
		P_AMBISTAT,
		P_READONLY_GLOBAL_RFL_ENABLED,
		P_READONLY_NUM_VOICES,
		P_SENDLEVEL,
		P_NUM
	}

	public const string strONSPS = "AudioPluginOculusSpatializer";

	[SerializeField]
	private bool enableSpatialization = true;

	[SerializeField]
	private float gain;

	[SerializeField]
	private bool useInvSqr;

	[SerializeField]
	private float near = 1f;

	[SerializeField]
	private float far = 10f;

	[SerializeField]
	private float volumetricRadius;

	[SerializeField]
	private float reverbSend;

	[SerializeField]
	private bool enableRfl;

	private static ONSPAudioSource RoomReflectionGizmoAS;

	public bool EnableSpatialization
	{
		get
		{
			return enableSpatialization;
		}
		set
		{
			enableSpatialization = value;
		}
	}

	public float Gain
	{
		get
		{
			return gain;
		}
		set
		{
			gain = Mathf.Clamp(value, 0f, 24f);
		}
	}

	public bool UseInvSqr
	{
		get
		{
			return useInvSqr;
		}
		set
		{
			useInvSqr = value;
		}
	}

	public float Near
	{
		get
		{
			return near;
		}
		set
		{
			near = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float Far
	{
		get
		{
			return far;
		}
		set
		{
			far = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float VolumetricRadius
	{
		get
		{
			return volumetricRadius;
		}
		set
		{
			volumetricRadius = Mathf.Clamp(value, 0f, 1000f);
		}
	}

	public float ReverbSend
	{
		get
		{
			return reverbSend;
		}
		set
		{
			reverbSend = Mathf.Clamp(value, -60f, 20f);
		}
	}

	public bool EnableRfl
	{
		get
		{
			return enableRfl;
		}
		set
		{
			enableRfl = value;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetGlobalRoomReflectionValues(ref bool reflOn, ref bool reverbOn, ref float width, ref float height, ref float length);

	private void Awake()
	{
		AudioSource source = GetComponent<AudioSource>();
		SetParameters(ref source);
	}

	private void Start()
	{
	}

	private void Update()
	{
		AudioSource source = GetComponent<AudioSource>();
		if (!UnityEngine.Application.isPlaying || AudioListener.pause || !source.isPlaying || !source.isActiveAndEnabled)
		{
			source.spatialize = false;
		}
		else
		{
			SetParameters(ref source);
		}
	}

	public void SetParameters(ref AudioSource source)
	{
		source.spatialize = enableSpatialization;
		source.SetSpatializerFloat(0, gain);
		if (useInvSqr)
		{
			source.SetSpatializerFloat(1, 1f);
		}
		else
		{
			source.SetSpatializerFloat(1, 0f);
		}
		source.SetSpatializerFloat(2, near);
		source.SetSpatializerFloat(3, far);
		source.SetSpatializerFloat(4, volumetricRadius);
		if (enableRfl)
		{
			source.SetSpatializerFloat(5, 0f);
		}
		else
		{
			source.SetSpatializerFloat(5, 1f);
		}
		source.SetSpatializerFloat(10, reverbSend);
	}

	private void OnDrawGizmos()
	{
		if (RoomReflectionGizmoAS == null)
		{
			RoomReflectionGizmoAS = this;
		}
		Color color = default(Color);
		color.r = 1f;
		color.g = 0.5f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, Near);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Near);
		color.r = 1f;
		color.g = 0f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = Color.red;
		Gizmos.DrawWireSphere(base.transform.position, Far);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Far);
		color.r = 1f;
		color.g = 0f;
		color.b = 1f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, VolumetricRadius);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, VolumetricRadius);
		if (RoomReflectionGizmoAS == this)
		{
			bool reflOn = false;
			bool reverbOn = false;
			float width = 1f;
			float height = 1f;
			float length = 1f;
			ONSP_GetGlobalRoomReflectionValues(ref reflOn, ref reverbOn, ref width, ref height, ref length);
			if (Camera.main != null && reflOn)
			{
				color = (Gizmos.color = ((!reverbOn) ? Color.cyan : Color.white));
				Gizmos.DrawWireCube(Camera.main.transform.position, new Vector3(width, height, length));
				color.a = 0.1f;
				Gizmos.color = color;
				Gizmos.DrawCube(Camera.main.transform.position, new Vector3(width, height, length));
			}
		}
	}

	private void OnDestroy()
	{
		if (RoomReflectionGizmoAS == this)
		{
			RoomReflectionGizmoAS = null;
		}
	}
}
public class ONSPProfiler : MonoBehaviour
{
	public bool profilerEnabled;

	private const int DEFAULT_PORT = 2121;

	public int port = 2121;

	public const string strONSPS = "AudioPluginOculusSpatializer";

	private void Start()
	{
		UnityEngine.Application.runInBackground = true;
	}

	private void Update()
	{
		if (port < 0 || port > 65535)
		{
			port = 2121;
		}
		ONSP_SetProfilerPort(port);
		ONSP_SetProfilerEnabled(profilerEnabled);
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerEnabled(bool enabled);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerPort(int port);
}
public class ONSPPropagationGeometry : MonoBehaviour
{
	private struct MeshMaterial
	{
		public MeshFilter meshFilter;

		public ONSPPropagationMaterial[] materials;
	}

	private struct TerrainMaterial
	{
		public Terrain terrain;

		public ONSPPropagationMaterial[] materials;
	}

	public string filePathRelative;

	public bool fileEnabled;

	public bool includeChildMeshes = true;

	private IntPtr geometryHandle = IntPtr.Zero;

	public static int OSPSuccess;

	private static int terrainDecimation = 4;

	public string filePath => UnityEngine.Application.streamingAssetsPath + "/" + filePathRelative;

	private void Awake()
	{
		CreatePropagationGeometry();
	}

	private void CreatePropagationGeometry()
	{
		AudioConfiguration configuration = AudioSettings.GetConfiguration();
		if (PropIFace.CreateAudioGeometry(out geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to create geometry handle");
		}
		if (filePath != null && filePath.Length != 0 && fileEnabled && UnityEngine.Application.isPlaying)
		{
			if (!ReadFile())
			{
				Debug.Log("Failed to read file, attempting to regenerate audio geometry");
				UploadGeometry();
			}
		}
		else
		{
			UploadGeometry();
		}
	}

	private void Update()
	{
		if (!(geometryHandle == IntPtr.Zero))
		{
			Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
			float[] matrix4x = new float[16]
			{
				localToWorldMatrix[0, 0],
				localToWorldMatrix[1, 0],
				0f - localToWorldMatrix[2, 0],
				localToWorldMatrix[3, 0],
				localToWorldMatrix[0, 1],
				localToWorldMatrix[1, 1],
				0f - localToWorldMatrix[2, 1],
				localToWorldMatrix[3, 1],
				localToWorldMatrix[0, 2],
				localToWorldMatrix[1, 2],
				0f - localToWorldMatrix[2, 2],
				localToWorldMatrix[3, 2],
				localToWorldMatrix[0, 3],
				localToWorldMatrix[1, 3],
				0f - localToWorldMatrix[2, 3],
				localToWorldMatrix[3, 3]
			};
			PropIFace.AudioGeometrySetTransform(geometryHandle, matrix4x);
		}
	}

	private void OnDestroy()
	{
		if (geometryHandle != IntPtr.Zero && PropIFace.DestroyAudioGeometry(geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to destroy geometry");
		}
		geometryHandle = IntPtr.Zero;
	}

	private static void traverseMeshHierarchy(GameObject obj, ONSPPropagationMaterial[] currentMaterials, bool includeChildren, List<MeshMaterial> meshMaterials, List<TerrainMaterial> terrainMaterials, bool ignoreStatic)
	{
		if (!obj.activeInHierarchy)
		{
			return;
		}
		MeshFilter[] components = obj.GetComponents<MeshFilter>();
		Terrain[] components2 = obj.GetComponents<Terrain>();
		ONSPPropagationMaterial[] components3 = obj.GetComponents<ONSPPropagationMaterial>();
		if (components3 != null && components3.Length > 0)
		{
			int num = components3.Length;
			if (currentMaterials != null)
			{
				num = Math.Max(num, currentMaterials.Length);
			}
			ONSPPropagationMaterial[] array = new ONSPPropagationMaterial[num];
			if (currentMaterials != null)
			{
				for (int i = components3.Length; i < num; i++)
				{
					array[i] = currentMaterials[i];
				}
			}
			currentMaterials = array;
			for (int j = 0; j < components3.Length; j++)
			{
				currentMaterials[j] = components3[j];
			}
		}
		MeshFilter[] array2 = components;
		foreach (MeshFilter meshFilter in array2)
		{
			Mesh sharedMesh = meshFilter.sharedMesh;
			if (!(sharedMesh == null))
			{
				if (ignoreStatic && !sharedMesh.isReadable)
				{
					Debug.Log("Mesh: " + meshFilter.gameObject.name + " not readable, cannot be static.");
					continue;
				}
				MeshMaterial item = default(MeshMaterial);
				item.meshFilter = meshFilter;
				item.materials = currentMaterials;
				meshMaterials.Add(item);
			}
		}
		Terrain[] array3 = components2;
		foreach (Terrain terrain in array3)
		{
			TerrainMaterial item2 = default(TerrainMaterial);
			item2.terrain = terrain;
			item2.materials = currentMaterials;
			terrainMaterials.Add(item2);
		}
		if (!includeChildren)
		{
			return;
		}
		foreach (Transform item3 in obj.transform)
		{
			if (item3.GetComponent<ONSPPropagationGeometry>() == null)
			{
				traverseMeshHierarchy(item3.gameObject, currentMaterials, includeChildren, meshMaterials, terrainMaterials, ignoreStatic);
			}
		}
	}

	private int uploadMesh(IntPtr geometryHandle, GameObject meshObject, Matrix4x4 worldToLocal, bool ignoreStatic)
	{
		List<MeshMaterial> list = new List<MeshMaterial>();
		List<TerrainMaterial> list2 = new List<TerrainMaterial>();
		traverseMeshHierarchy(meshObject, null, includeChildMeshes, list, list2, ignoreStatic);
		int num = 0;
		uint num2 = 0u;
		int num3 = 0;
		int num4 = 0;
		foreach (MeshMaterial item in list)
		{
			Mesh sharedMesh = item.meshFilter.sharedMesh;
			num4 += sharedMesh.subMeshCount;
			num += sharedMesh.vertexCount;
			for (int i = 0; i < sharedMesh.subMeshCount; i++)
			{
				MeshTopology topology = sharedMesh.GetTopology(i);
				if (topology == MeshTopology.Triangles || topology == MeshTopology.Quads)
				{
					uint indexCount = sharedMesh.GetIndexCount(i);
					num2 += indexCount;
					switch (topology)
					{
					case MeshTopology.Triangles:
						num3 += (int)indexCount / 3;
						break;
					case MeshTopology.Quads:
						num3 += (int)indexCount / 4;
						break;
					}
				}
			}
		}
		foreach (TerrainMaterial item2 in list2)
		{
			TerrainData terrainData = item2.terrain.terrainData;
			int heightmapWidth = terrainData.heightmapWidth;
			int heightmapHeight = terrainData.heightmapHeight;
			int num5 = (heightmapWidth - 1) / terrainDecimation + 1;
			int num6 = (heightmapHeight - 1) / terrainDecimation + 1;
			int num7 = num5 * num6;
			int num8 = (num5 - 1) * (num6 - 1) * 6;
			num4++;
			num += num7;
			num2 += (uint)num8;
			num3 += num8 / 3;
		}
		List<Vector3> list3 = new List<Vector3>();
		List<int> list4 = new List<int>();
		MeshGroup[] array = new MeshGroup[num4];
		float[] array2 = new float[num * 3];
		int[] array3 = new int[num2];
		int num9 = 0;
		int num10 = 0;
		int num11 = 0;
		foreach (MeshMaterial item3 in list)
		{
			MeshFilter meshFilter = item3.meshFilter;
			Mesh sharedMesh2 = meshFilter.sharedMesh;
			Matrix4x4 matrix4x = worldToLocal * meshFilter.gameObject.transform.localToWorldMatrix;
			list3.Clear();
			sharedMesh2.GetVertices(list3);
			int count = list3.Count;
			for (int j = 0; j < count; j++)
			{
				Vector3 vector = matrix4x.MultiplyPoint3x4(list3[j]);
				int num12 = (num9 + j) * 3;
				array2[num12] = vector.x;
				array2[num12 + 1] = vector.y;
				array2[num12 + 2] = vector.z;
			}
			for (int k = 0; k < sharedMesh2.subMeshCount; k++)
			{
				MeshTopology topology2 = sharedMesh2.GetTopology(k);
				if (topology2 != 0 && topology2 != MeshTopology.Quads)
				{
					continue;
				}
				list4.Clear();
				sharedMesh2.GetIndices(list4, k);
				int count2 = list4.Count;
				for (int l = 0; l < count2; l++)
				{
					array3[num10 + l] = list4[l] + num9;
				}
				switch (topology2)
				{
				case MeshTopology.Triangles:
					array[num11 + k].faceType = FaceType.TRIANGLES;
					array[num11 + k].faceCount = (UIntPtr)(ulong)(count2 / 3);
					break;
				case MeshTopology.Quads:
					array[num11 + k].faceType = FaceType.QUADS;
					array[num11 + k].faceCount = (UIntPtr)(ulong)(count2 / 4);
					break;
				}
				array[num11 + k].indexOffset = (UIntPtr)(ulong)num10;
				if (item3.materials != null && item3.materials.Length != 0)
				{
					int num13 = k;
					if (num13 >= item3.materials.Length)
					{
						num13 = item3.materials.Length - 1;
					}
					item3.materials[num13].StartInternal();
					array[num11 + k].material = item3.materials[num13].materialHandle;
				}
				else
				{
					array[num11 + k].material = IntPtr.Zero;
				}
				num10 += count2;
			}
			num9 += count;
			num11 += sharedMesh2.subMeshCount;
		}
		foreach (TerrainMaterial item4 in list2)
		{
			TerrainData terrainData2 = item4.terrain.terrainData;
			Matrix4x4 matrix4x2 = worldToLocal * item4.terrain.gameObject.transform.localToWorldMatrix;
			int heightmapWidth2 = terrainData2.heightmapWidth;
			int heightmapHeight2 = terrainData2.heightmapHeight;
			float[,] heights = terrainData2.GetHeights(0, 0, heightmapWidth2, heightmapHeight2);
			Vector3 size = terrainData2.size;
			size = new Vector3(size.x / (float)(heightmapWidth2 - 1) * (float)terrainDecimation, size.y, size.z / (float)(heightmapHeight2 - 1) * (float)terrainDecimation);
			int num14 = (heightmapWidth2 - 1) / terrainDecimation + 1;
			int num15 = (heightmapHeight2 - 1) / terrainDecimation + 1;
			int num16 = num14 * num15;
			int num17 = (num14 - 1) * (num15 - 1) * 2;
			array[num11].faceType = FaceType.TRIANGLES;
			array[num11].faceCount = (UIntPtr)(ulong)num17;
			array[num11].indexOffset = (UIntPtr)(ulong)num10;
			if (item4.materials != null && 0 < item4.materials.Length)
			{
				item4.materials[0].StartInternal();
				array[num11].material = item4.materials[0].materialHandle;
			}
			else
			{
				array[num11].material = IntPtr.Zero;
			}
			for (int m = 0; m < num15; m++)
			{
				for (int n = 0; n < num14; n++)
				{
					int num18 = (num9 + m * num14 + n) * 3;
					Vector3 vector2 = matrix4x2.MultiplyPoint3x4(Vector3.Scale(size, new Vector3(m, heights[n * terrainDecimation, m * terrainDecimation], n)));
					array2[num18] = vector2.x;
					array2[num18 + 1] = vector2.y;
					array2[num18 + 2] = vector2.z;
				}
			}
			for (int num19 = 0; num19 < num15 - 1; num19++)
			{
				for (int num20 = 0; num20 < num14 - 1; num20++)
				{
					array3[num10] = num9 + num19 * num14 + num20;
					array3[num10 + 1] = num9 + (num19 + 1) * num14 + num20;
					array3[num10 + 2] = num9 + num19 * num14 + num20 + 1;
					array3[num10 + 3] = num9 + (num19 + 1) * num14 + num20;
					array3[num10 + 4] = num9 + (num19 + 1) * num14 + num20 + 1;
					array3[num10 + 5] = num9 + num19 * num14 + num20 + 1;
					num10 += 6;
				}
			}
			num9 += num16;
			num11++;
		}
		return PropIFace.AudioGeometryUploadMeshArrays(geometryHandle, array2, num, array3, array3.Length, array, array.Length);
	}

	public void UploadGeometry()
	{
		if (uploadMesh(geometryHandle, base.gameObject, base.gameObject.transform.worldToLocalMatrix, ignoreStatic: true) != OSPSuccess)
		{
			throw new Exception("Unable to upload audio mesh geometry");
		}
	}

	public bool ReadFile()
	{
		if (filePath == null || filePath.Length == 0)
		{
			Debug.Log("Invalid mesh file path");
			return false;
		}
		if (PropIFace.AudioGeometryReadMeshFile(geometryHandle, filePath) != OSPSuccess)
		{
			Debug.Log("Error reading mesh file " + filePath);
			return false;
		}
		return true;
	}
}
namespace ONSPPropagationInterface
{
	public enum FaceType : uint
	{
		TRIANGLES,
		QUADS
	}
	public enum MaterialProperty : uint
	{
		ABSORPTION,
		TRANSMISSION,
		SCATTERING
	}
	[StructLayout(0, Pack = 1)]
	public struct MeshGroup
	{
		public UIntPtr indexOffset;

		public UIntPtr faceCount;

		[MarshalAs(UnmanagedType.U4)]
		public FaceType faceType;

		public IntPtr material;
	}
	public enum ovrAudioScalarType : uint
	{
		Int8,
		UInt8,
		Int16,
		UInt16,
		Int32,
		UInt32,
		Int64,
		UInt64,
		Float16,
		Float32,
		Float64
	}
	public class ClientType
	{
		public const uint OVRA_CLIENT_TYPE_NATIVE = 0u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2016 = 1u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2017_1 = 2u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2017_2 = 3u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2018_1 = 4u;

		public const uint OVRA_CLIENT_TYPE_FMOD = 5u;

		public const uint OVRA_CLIENT_TYPE_UNITY = 6u;

		public const uint OVRA_CLIENT_TYPE_UE4 = 7u;

		public const uint OVRA_CLIENT_TYPE_VST = 8u;

		public const uint OVRA_CLIENT_TYPE_AAX = 9u;

		public const uint OVRA_CLIENT_TYPE_TEST = 10u;

		public const uint OVRA_CLIENT_TYPE_OTHER = 11u;

		public const uint OVRA_CLIENT_TYPE_WWISE_UNKNOWN = 12u;
	}
}
namespace ONSPPropagationInterface.Unity_Native
{
	public class PropIFace
	{
		private static IntPtr context_ = IntPtr.Zero;

		public const string strOSPS = "AudioPluginOculusSpatializer";

		private static IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 6u);
				}
				return context_;
			}
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public static int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public static int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public static int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public static int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public static int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public static int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public static int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public static int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public static int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public static int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public static int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public static int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public static int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public static int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}
}
namespace ONSPPropagationInterface.Wwise
{
	public class PropIFace
	{
		private static IntPtr context_ = IntPtr.Zero;

		public const string strOSPS = "OculusSpatializerWwise";

		private static IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 12u);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public static int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public static int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public static int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public static int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public static int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public static int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public static int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public static int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public static int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public static int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public static int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public static int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public static int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public static int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}
}
namespace ONSPPropagationInterface.FMOD
{
	public class PropIFace
	{
		private static IntPtr context_ = IntPtr.Zero;

		public const string strOSPS = "OculusSpatializerFMOD";

		private static IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 5u);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public static int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public static int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public static int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public static int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public static int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public static int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public static int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public static int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public static int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public static int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public static int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public static int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public static int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public static int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}
}
public sealed class ONSPPropagationMaterial : MonoBehaviour
{
	public enum Preset
	{
		Custom,
		AcousticTile,
		Brick,
		BrickPainted,
		Carpet,
		CarpetHeavy,
		CarpetHeavyPadded,
		CeramicTile,
		Concrete,
		ConcreteRough,
		ConcreteBlock,
		ConcreteBlockPainted,
		Curtain,
		Foliage,
		Glass,
		GlassHeavy,
		Grass,
		Gravel,
		GypsumBoard,
		PlasterOnBrick,
		PlasterOnConcreteBlock,
		Soil,
		SoundProof,
		Snow,
		Steel,
		Water,
		WoodThin,
		WoodThick,
		WoodFloor,
		WoodOnConcrete
	}

	[Serializable]
	public sealed class Point
	{
		public float frequency;

		public float data;

		public Point(float frequency = 0f, float data = 0f)
		{
			this.frequency = frequency;
			this.data = data;
		}

		public static implicit operator Point(Vector2 v)
		{
			return new Point(v.x, v.y);
		}

		public static implicit operator Vector2(Point point)
		{
			return new Vector2(point.frequency, point.data);
		}
	}

	[Serializable]
	public sealed class Spectrum
	{
		public int selection = int.MaxValue;

		public List<Point> points = new List<Point>();

		public float this[float f]
		{
			get
			{
				if (points.Count > 0)
				{
					Point point = new Point(float.MinValue);
					Point point2 = new Point(float.MaxValue);
					foreach (Point point3 in points)
					{
						if (point3.frequency < f)
						{
							if (point3.frequency > point.frequency)
							{
								point = point3;
							}
						}
						else if (point3.frequency < point2.frequency)
						{
							point2 = point3;
						}
					}
					if (point.frequency == float.MinValue)
					{
						point.data = points.OrderBy((Point p) => p.frequency).First().data;
					}
					if (point2.frequency == float.MaxValue)
					{
						point2.data = points.OrderBy((Point p) => p.frequency).Last().data;
					}
					return point.data + (f - point.frequency) * (point2.data - point.data) / (point2.frequency - point.frequency);
				}
				return 0f;
			}
		}
	}

	public IntPtr materialHandle = IntPtr.Zero;

	[Tooltip("Absorption")]
	public Spectrum absorption = new Spectrum();

	[Tooltip("Transmission")]
	public Spectrum transmission = new Spectrum();

	[Tooltip("Scattering")]
	public Spectrum scattering = new Spectrum();

	[SerializeField]
	private Preset preset_;

	public Preset preset
	{
		get
		{
			return preset_;
		}
		set
		{
			SetPreset(value);
			preset_ = value;
		}
	}

	private void Start()
	{
		StartInternal();
	}

	public void StartInternal()
	{
		if (!(materialHandle != IntPtr.Zero))
		{
			if (PropIFace.CreateAudioMaterial(out materialHandle) != ONSPPropagationGeometry.OSPSuccess)
			{
				throw new Exception("Unable to create internal audio material");
			}
			UploadMaterial();
		}
	}

	private void OnDestroy()
	{
		DestroyInternal();
	}

	public void DestroyInternal()
	{
		if (materialHandle != IntPtr.Zero)
		{
			PropIFace.DestroyAudioMaterial(materialHandle);
			materialHandle = IntPtr.Zero;
		}
	}

	public void UploadMaterial()
	{
		if (materialHandle == IntPtr.Zero)
		{
			return;
		}
		PropIFace.AudioMaterialReset(materialHandle, MaterialProperty.ABSORPTION);
		foreach (Point point in absorption.points)
		{
			PropIFace.AudioMaterialSetFrequency(materialHandle, MaterialProperty.ABSORPTION, point.frequency, point.data);
		}
		PropIFace.AudioMaterialReset(materialHandle, MaterialProperty.TRANSMISSION);
		foreach (Point point2 in transmission.points)
		{
			PropIFace.AudioMaterialSetFrequency(materialHandle, MaterialProperty.TRANSMISSION, point2.frequency, point2.data);
		}
		PropIFace.AudioMaterialReset(materialHandle, MaterialProperty.SCATTERING);
		foreach (Point point3 in scattering.points)
		{
			PropIFace.AudioMaterialSetFrequency(materialHandle, MaterialProperty.SCATTERING, point3.frequency, point3.data);
		}
	}

	public void SetPreset(Preset preset)
	{
		ONSPPropagationMaterial material = this;
		switch (preset)
		{
		case Preset.AcousticTile:
			AcousticTile(ref material);
			break;
		case Preset.Brick:
			Brick(ref material);
			break;
		case Preset.BrickPainted:
			BrickPainted(ref material);
			break;
		case Preset.Carpet:
			Carpet(ref material);
			break;
		case Preset.CarpetHeavy:
			CarpetHeavy(ref material);
			break;
		case Preset.CarpetHeavyPadded:
			CarpetHeavyPadded(ref material);
			break;
		case Preset.CeramicTile:
			CeramicTile(ref material);
			break;
		case Preset.Concrete:
			Concrete(ref material);
			break;
		case Preset.ConcreteRough:
			ConcreteRough(ref material);
			break;
		case Preset.ConcreteBlock:
			ConcreteBlock(ref material);
			break;
		case Preset.ConcreteBlockPainted:
			ConcreteBlockPainted(ref material);
			break;
		case Preset.Curtain:
			Curtain(ref material);
			break;
		case Preset.Foliage:
			Foliage(ref material);
			break;
		case Preset.Glass:
			Glass(ref material);
			break;
		case Preset.GlassHeavy:
			GlassHeavy(ref material);
			break;
		case Preset.Grass:
			Grass(ref material);
			break;
		case Preset.Gravel:
			Gravel(ref material);
			break;
		case Preset.GypsumBoard:
			GypsumBoard(ref material);
			break;
		case Preset.PlasterOnBrick:
			PlasterOnBrick(ref material);
			break;
		case Preset.PlasterOnConcreteBlock:
			PlasterOnConcreteBlock(ref material);
			break;
		case Preset.Soil:
			Soil(ref material);
			break;
		case Preset.SoundProof:
			SoundProof(ref material);
			break;
		case Preset.Snow:
			Snow(ref material);
			break;
		case Preset.Steel:
			Steel(ref material);
			break;
		case Preset.Water:
			Water(ref material);
			break;
		case Preset.WoodThin:
			WoodThin(ref material);
			break;
		case Preset.WoodThick:
			WoodThick(ref material);
			break;
		case Preset.WoodFloor:
			WoodFloor(ref material);
			break;
		case Preset.WoodOnConcrete:
			WoodOnConcrete(ref material);
			break;
		case Preset.Custom:
			break;
		}
	}

	private static void AcousticTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.5f),
			new Point(250f, 0.7f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.5f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.04f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.005f),
			new Point(4000f, 0.002f)
		};
	}

	private static void Brick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.02f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void BrickPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.2f),
			new Point(4000f, 0.25f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void Carpet(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.05f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.45f),
			new Point(4000f, 0.65f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.06f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.37f),
			new Point(2000f, 0.48f),
			new Point(4000f, 0.63f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavyPadded(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.08f),
			new Point(250f, 0.24f),
			new Point(500f, 0.57f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.71f),
			new Point(4000f, 0.73f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CeramicTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.01f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.16f),
			new Point(2000f, 0.18f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void Concrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteRough(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.08f),
			new Point(4000f, 0.1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.36f),
			new Point(250f, 0.44f),
			new Point(500f, 0.31f),
			new Point(1000f, 0.29f),
			new Point(2000f, 0.39f),
			new Point(4000f, 0.21f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.4f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void ConcreteBlockPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.05f),
			new Point(500f, 0.06f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.09f),
			new Point(4000f, 0.08f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.13f),
			new Point(1000f, 0.15f),
			new Point(2000f, 0.16f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Curtain(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.07f),
			new Point(250f, 0.31f),
			new Point(500f, 0.49f),
			new Point(1000f, 0.75f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.3f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.39f),
			new Point(500f, 0.21f),
			new Point(1000f, 0.14f),
			new Point(2000f, 0.079f),
			new Point(4000f, 0.045f)
		};
	}

	private static void Foliage(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.06f),
			new Point(500f, 0.11f),
			new Point(1000f, 0.17f),
			new Point(2000f, 0.27f),
			new Point(4000f, 0.31f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.8f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.9f),
			new Point(250f, 0.9f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.8f),
			new Point(2000f, 0.5f),
			new Point(4000f, 0.3f)
		};
	}

	private static void Glass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.35f),
			new Point(250f, 0.25f),
			new Point(500f, 0.18f),
			new Point(1000f, 0.12f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.125f),
			new Point(250f, 0.089f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.022f),
			new Point(4000f, 0.079f)
		};
	}

	private static void GlassHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.18f),
			new Point(250f, 0.06f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.056f),
			new Point(250f, 0.039f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.032f),
			new Point(4000f, 0.014f)
		};
	}

	private static void Grass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.11f),
			new Point(250f, 0.26f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.92f),
			new Point(4000f, 0.99f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.3f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Gravel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.6f),
			new Point(500f, 0.65f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.75f),
			new Point(4000f, 0.8f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void GypsumBoard(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.29f),
			new Point(250f, 0.1f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.09f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.0125f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0025f),
			new Point(2000f, 0.0013f),
			new Point(4000f, 0.0032f)
		};
	}

	private static void PlasterOnBrick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.04f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void PlasterOnConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.12f),
			new Point(250f, 0.09f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.04f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Soil(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.25f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.55f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.2f),
			new Point(500f, 0.25f),
			new Point(1000f, 0.4f),
			new Point(2000f, 0.55f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void SoundProof(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(1000f, 1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(1000f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Snow(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.45f),
			new Point(250f, 0.75f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.95f),
			new Point(2000f, 0.95f),
			new Point(4000f, 0.95f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.75f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Steel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.1f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.2f),
			new Point(500f, 0.17f),
			new Point(1000f, 0.089f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.0056f)
		};
	}

	private static void Water(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.03f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.015f),
			new Point(4000f, 0.01f)
		};
	}

	private static void WoodThin(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.21f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.08f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.06f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.125f),
			new Point(500f, 0.079f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.05f)
		};
	}

	private static void WoodThick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.19f),
			new Point(250f, 0.14f),
			new Point(500f, 0.09f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.028f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.011f),
			new Point(4000f, 0.0071f)
		};
	}

	private static void WoodFloor(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.11f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.071f),
			new Point(250f, 0.025f),
			new Point(500f, 0.0158f),
			new Point(1000f, 0.0056f),
			new Point(2000f, 0.0035f),
			new Point(4000f, 0.0016f)
		};
	}

	private static void WoodOnConcrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.04f),
			new Point(250f, 0.04f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}
}
public class ONSPVersion : MonoBehaviour
{
	public const string strONSPS = "AudioPluginOculusSpatializer";

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetVersion(ref int Major, ref int Minor, ref int Patch);

	private void Awake()
	{
		int Major = 0;
		int Minor = 0;
		int Patch = 0;
		ONSP_GetVersion(ref Major, ref Minor, ref Patch);
		string message = $"ONSP Version: {Major:F0}.{Minor:F0}.{Patch:F0}";
		Debug.Log(message);
	}

	private void Start()
	{
	}

	private void Update()
	{
	}
}
[RequireComponent(typeof(CharacterController))]
public class OVRPlayerController : MonoBehaviour
{
	protected CharacterController Controller;

	protected OVRCameraRig CameraController;

	public float Acceleration = 0.1f;

	public float Damping = 0.15f;

	public float BackAndSideDampen = 0.5f;

	public float JumpForce = 0.3f;

	public float RotationAmount = 1.5f;

	public float GravityModifier = 0.379f;

	public float GamepadRotateFactor = 1.5f;

	private float MoveScale = 1f;

	private Vector3 MoveThrottle = Vector3.zero;

	private float FallSpeed;

	public bool updateRotationFromHMD = true;

	private Quaternion OrientationOffset = Quaternion.identity;

	private float YRotation;

	private float XRotation;

	protected Transform DirXform;

	private float MoveScaleMultiplier = 2f;

	private float RotationScaleMultiplierPad = 1f;

	private float RotationScaleMultiplierMouse = 1f;

	private bool SkipMouseRotation;

	private bool HaltUpdateMovement;

	public float lastThrottleSpeed;

	private float RotationRatchet = 30f;

	private bool prevHatLeft;

	private bool prevHatRight;

	private float leftHatTimer;

	private float rightHatTimer;

	public Vector3 adjustBodyMove = Vector3.zero;

	public bool adjustBodyToggle;

	public Vector3 actualBodyMove = Vector3.zero;

	private bool controllerGrounded;

	public Transform moveReferenceObject;

	private static float sDeltaRotationOld;

	public void Awake()
	{
		Controller = base.gameObject.GetComponent<CharacterController>();
		if (Controller == null)
		{
			Debug.LogWarning("OVRPlayerController: No CharacterController attached.");
		}
		OVRCameraRig[] componentsInChildren = base.gameObject.GetComponentsInChildren<OVRCameraRig>();
		if (componentsInChildren.Length == 0)
		{
			Debug.LogWarning("OVRPlayerController: No OVRCameraController attached.");
		}
		else if (componentsInChildren.Length > 1)
		{
			Debug.LogWarning("OVRPlayerController: More then 1 OVRCameraController attached.");
		}
		else
		{
			CameraController = componentsInChildren[0];
		}
		DirXform = null;
		Transform[] componentsInChildren2 = base.gameObject.GetComponentsInChildren<Transform>();
		for (int i = 0; i < componentsInChildren2.Length; i++)
		{
			if (componentsInChildren2[i].name == "ForwardDirection")
			{
				DirXform = componentsInChildren2[i];
				break;
			}
		}
		if (DirXform == null)
		{
			Debug.LogWarning("OVRPlayerController: ForwardDirection game object not found. Do not use.");
		}
		Vector3 localPosition = CameraController.trackingSpace.localPosition;
		localPosition.z = OVRManager.profile.eyeDepth;
		CameraController.trackingSpace.localPosition = localPosition;
	}

	public void Start()
	{
		InitializeInputs();
		SetCameras();
	}

	public void Update()
	{
		UpdateMovement();
		Vector3 zero = Vector3.zero;
		float num = 60f;
		float num2 = 1f + Damping * num * Time.deltaTime;
		MoveThrottle.x /= num2;
		MoveThrottle.y = ((!(MoveThrottle.y > 0f)) ? MoveThrottle.y : (MoveThrottle.y / num2));
		MoveThrottle.z /= num2;
		zero += MoveThrottle * num * Time.deltaTime;
		if (Controller.isGrounded && FallSpeed <= 0f)
		{
			FallSpeed = Physics.gravity.y * (GravityModifier * 0.002f);
		}
		else
		{
			FallSpeed += Physics.gravity.y * (GravityModifier * 0.002f) * num * Time.deltaTime;
		}
		zero.y += FallSpeed * num * Time.deltaTime;
		float num3 = 0f;
		if (Controller.isGrounded && MoveThrottle.y <= 0.001f)
		{
			num3 = Mathf.Max(Controller.stepOffset, new Vector3(zero.x, 0f, zero.z).magnitude);
			zero -= num3 * Vector3.up;
		}
		Vector3 vector = Vector3.Scale(Controller.transform.localPosition + zero, new Vector3(1f, 0f, 1f));
		bool flag = false;
		Vector3 position = base.transform.position;
		Controller.Move(zero);
		if (zero.y <= 0f && base.transform.position.y > position.y + 0.2f)
		{
			base.transform.position = position;
		}
		else
		{
			float magnitude = zero.ToGround().magnitude;
			float magnitude2 = (base.transform.position - position).ToGround().magnitude;
			if (magnitude2 > 0.01f && (double)magnitude2 > (double)magnitude * 1.5)
			{
				flag = true;
			}
		}
		Vector3 vector2 = Vector3.Scale(Controller.transform.localPosition, new Vector3(1f, 0f, 1f));
		if (vector != vector2 && !flag)
		{
			MoveThrottle += (vector2 - vector) / (num * Time.deltaTime);
		}
		controllerGrounded = Controller.isGrounded;
		if (adjustBodyToggle && !GameController.Get().Paused)
		{
			Vector3 position2 = base.transform.position;
			Controller.Move(adjustBodyMove);
			Vector3 vector3 = (actualBodyMove = (base.transform.position - position2).ToGround());
			CameraController.trackingSpace.transform.position -= vector3;
			adjustBodyMove = Vector3.zero;
		}
		UpdatePlayerForwardDirTransform();
	}

	public virtual void UpdateMovement()
	{
		if (HaltUpdateMovement)
		{
			return;
		}
		float num = 60f;
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = false;
		MoveScale = 1f;
		if (Input.GetKey(KeyCode.W))
		{
			flag = true;
		}
		if (Input.GetKey(KeyCode.A))
		{
			flag2 = true;
		}
		if (Input.GetKey(KeyCode.S))
		{
			flag4 = true;
		}
		if (Input.GetKey(KeyCode.D))
		{
			flag3 = true;
		}
		if (Input.GetKey(KeyCode.UpArrow))
		{
			flag = true;
		}
		if (Input.GetKey(KeyCode.LeftArrow))
		{
			flag2 = true;
		}
		if (Input.GetKey(KeyCode.DownArrow))
		{
			flag4 = true;
		}
		if (Input.GetKey(KeyCode.RightArrow))
		{
			flag3 = true;
		}
		float y = InputExt.GetAxisPad(InputExt.Axis2D.Dpad).y;
		if (y <= -1f)
		{
			flag = true;
		}
		if (y >= 1f)
		{
			flag4 = true;
		}
		if (InputExt.Using3DOFController && InputExt.touchpadStatus.Click && InputExt.touchpadStatus.isTouching && InputExt.touchpadStatus.touchPos == InputExt.TouchpadStatus.TouchPosition.UP)
		{
			flag = true;
		}
		if ((flag && flag2) || (flag && flag3) || (flag4 && flag2) || (flag4 && flag3))
		{
			MoveScale = 0.70710677f;
		}
		if (!controllerGrounded)
		{
			MoveScale = 0f;
		}
		MoveScale *= num * Time.deltaTime;
		float num2 = Acceleration * 0.1f * MoveScale * MoveScaleMultiplier;
		if (DirXform != null)
		{
			if (moveReferenceObject == null)
			{
				if (flag)
				{
					MoveThrottle += DirXform.TransformDirection(Vector3.forward * num2 * base.transform.lossyScale.z);
				}
				if (flag4)
				{
					MoveThrottle += DirXform.TransformDirection(Vector3.back * num2 * base.transform.lossyScale.z) * BackAndSideDampen;
				}
				if (flag2)
				{
					MoveThrottle += DirXform.TransformDirection(Vector3.left * num2 * base.transform.lossyScale.x) * BackAndSideDampen;
				}
				if (flag3)
				{
					MoveThrottle += DirXform.TransformDirection(Vector3.right * num2 * base.transform.lossyScale.x) * BackAndSideDampen;
				}
			}
			else
			{
				Vector3 vector = moveReferenceObject.forward;
				if (vector.x == 0f && vector.y == 0f)
				{
					vector = moveReferenceObject.up;
				}
				vector.y = 0f;
				vector.Normalize();
				if (InputExt.IsOculusGo && CameraController != null)
				{
					Transform centerEyeAnchor = CameraController.centerEyeAnchor;
					Vector3 vector2 = centerEyeAnchor.forward;
					if (vector2.x == 0f && vector2.y == 0f)
					{
						vector2 = centerEyeAnchor.up;
					}
					vector2.y = 0f;
					vector2.Normalize();
					vector = 0.8f * vector + 0.2f * vector2;
				}
				Vector3 vector3 = Vector3.Cross(Vector3.up, vector);
				if (flag)
				{
					MoveThrottle += vector * num2;
				}
				if (flag4)
				{
					MoveThrottle -= vector * num2 * BackAndSideDampen;
				}
				if (flag2)
				{
					MoveThrottle -= vector3 * num2 * BackAndSideDampen;
				}
				if (flag3)
				{
					MoveThrottle += vector3 * num2 * BackAndSideDampen;
				}
			}
		}
		float num3 = num * Time.deltaTime * RotationAmount * RotationScaleMultiplierMouse;
		float num4 = num * Time.deltaTime * RotationAmount * RotationScaleMultiplierPad;
		if (Input.GetKey(KeyCode.Q))
		{
			YRotation -= num4 * 0.5f;
		}
		if (Input.GetKey(KeyCode.E))
		{
			YRotation += num4 * 0.5f;
		}
		float num5 = 0f;
		if (!SkipMouseRotation)
		{
			num5 = Input.GetAxis("Mouse X") * num3 * 3.25f;
		}
		float num6 = sDeltaRotationOld * 0f + num5 * 1f;
		YRotation += num6;
		sDeltaRotationOld = num6;
		num2 = num * Time.deltaTime * Acceleration * 0.1f * MoveScale * MoveScaleMultiplier;
		if (DirXform != null)
		{
			float y2 = InputExt.GetAxisPad(InputExt.Axis2D.LeftThumbstick).y;
			float x = InputExt.GetAxisPad(InputExt.Axis2D.LeftThumbstick).x;
			if (moveReferenceObject == null)
			{
				if (y2 > 0f)
				{
					MoveThrottle += y2 * DirXform.TransformDirection(Vector3.forward * num2);
				}
				if (y2 < 0f)
				{
					MoveThrottle += Mathf.Abs(y2) * DirXform.TransformDirection(Vector3.back * num2) * BackAndSideDampen;
				}
				if (x < 0f)
				{
					MoveThrottle += Mathf.Abs(x) * DirXform.TransformDirection(Vector3.left * num2) * BackAndSideDampen;
				}
				if (x > 0f)
				{
					MoveThrottle += x * DirXform.TransformDirection(Vector3.right * num2) * BackAndSideDampen;
				}
			}
			else
			{
				Vector3 vector4 = moveReferenceObject.forward;
				if (vector4.x == 0f && vector4.y == 0f)
				{
					vector4 = moveReferenceObject.up;
				}
				vector4.y = 0f;
				vector4.Normalize();
				Vector3 vector5 = Vector3.Cross(Vector3.up, vector4);
				if (y2 > 0f)
				{
					MoveThrottle += y2 * vector4 * num2;
				}
				if (y2 < 0f)
				{
					MoveThrottle -= Mathf.Abs(y2) * vector4 * num2 * BackAndSideDampen;
				}
				if (x < 0f)
				{
					MoveThrottle -= Mathf.Abs(x) * vector5 * num2 * BackAndSideDampen;
				}
				if (x > 0f)
				{
					MoveThrottle += x * vector5 * num2 * BackAndSideDampen;
				}
			}
		}
		lastThrottleSpeed = MoveThrottle.magnitude;
		float x2 = InputExt.GetAxisPad(InputExt.Axis2D.RightThumbstick).x;
		float num7 = 0f;
		YRotation += x2 * num4 * GamepadRotateFactor;
		XRotation += num7 * num4 * GamepadRotateFactor;
		SetCameras();
	}

	public virtual void UpdatePlayerForwardDirTransform()
	{
		if (DirXform != null && CameraController != null)
		{
			Quaternion identity = Quaternion.identity;
			if (updateRotationFromHMD)
			{
				Transform centerEyeAnchor = CameraController.centerEyeAnchor;
				float y = centerEyeAnchor.rotation.eulerAngles.y;
				DirXform.rotation = Quaternion.Euler(0f, y, 0f);
			}
			else
			{
				float y2 = DirXform.rotation.eulerAngles.y;
				Vector3 eulerAngles = CameraController.transform.rotation.eulerAngles;
				eulerAngles.y = y2;
				CameraController.transform.rotation = Quaternion.Euler(eulerAngles);
			}
		}
	}

	public bool Jump()
	{
		if (!controllerGrounded)
		{
			return false;
		}
		MoveThrottle += new Vector3(0f, JumpForce, 0f);
		return true;
	}

	public void Stop()
	{
		Controller.Move(Vector3.zero);
		MoveThrottle = Vector3.zero;
		FallSpeed = 0f;
	}

	public void InitializeInputs()
	{
		OrientationOffset = base.transform.rotation;
		YRotation = OrientationOffset.eulerAngles.y;
	}

	public void SetCameras()
	{
		if (CameraController != null)
		{
			Vector3 eulerAngles = CameraController.transform.rotation.eulerAngles;
			eulerAngles.y = YRotation;
			CameraController.transform.rotation = Quaternion.Euler(eulerAngles);
		}
	}

	public void GetMoveScaleMultiplier(ref float moveScaleMultiplier)
	{
		moveScaleMultiplier = MoveScaleMultiplier;
	}

	public void SetMoveScaleMultiplier(float moveScaleMultiplier)
	{
		MoveScaleMultiplier = moveScaleMultiplier;
	}

	public void GetRotationScaleMultiplierMouse(ref float rotationScaleMultiplier)
	{
		rotationScaleMultiplier = RotationScaleMultiplierMouse;
	}

	public void SetRotationScaleMultiplierMouse(float rotationScaleMultiplier)
	{
		RotationScaleMultiplierMouse = rotationScaleMultiplier;
	}

	public void GetRotationScaleMultiplierPad(ref float rotationScaleMultiplier)
	{
		rotationScaleMultiplier = RotationScaleMultiplierPad;
	}

	public void SetRotationScaleMultiplierPad(float rotationScaleMultiplier)
	{
		RotationScaleMultiplierPad = rotationScaleMultiplier;
	}

	public void GetRotationScaleMultiplier(ref float rotationScaleMultiplier)
	{
		rotationScaleMultiplier = RotationScaleMultiplierMouse;
	}

	public void SetRotationScaleMultiplier(float rotationScaleMultiplier)
	{
		RotationScaleMultiplierMouse = rotationScaleMultiplier;
		RotationScaleMultiplierPad = rotationScaleMultiplier;
	}

	public void GetSkipMouseRotation(ref bool skipMouseRotation)
	{
		skipMouseRotation = SkipMouseRotation;
	}

	public void SetSkipMouseRotation(bool skipMouseRotation)
	{
		SkipMouseRotation = skipMouseRotation;
	}

	public void GetHaltUpdateMovement(ref bool haltUpdateMovement)
	{
		haltUpdateMovement = HaltUpdateMovement;
	}

	public void SetHaltUpdateMovement(bool haltUpdateMovement)
	{
		HaltUpdateMovement = haltUpdateMovement;
	}

	public void ResetOrientation()
	{
		YRotation = 0f;
		XRotation = 0f;
	}

	public void GetYRotation(ref float rot)
	{
		rot = YRotation;
	}

	public void SetYRotation(float rot)
	{
		YRotation = rot;
	}
}
namespace OvrTouch.Controllers
{
	public enum HandednessId
	{
		Left,
		Right
	}
	public class TrackedController : MonoBehaviour
	{
		private static class Const
		{
			public const float TriggerDebounceTime = 0.05f;

			public const float ThumbDebounceTime = 0.15f;
		}

		[SerializeField]
		private HandednessId m_handedness;

		[SerializeField]
		private Transform m_trackedTransform;

		private bool m_initialized;

		private OVRInput.Controller m_controllerType;

		private bool m_point;

		private bool m_thumbsUp;

		private float m_lastPoint = -1f;

		private float m_lastNonPoint = -1f;

		private float m_lastThumb = -1f;

		private float m_lastNonThumb = -1f;

		private float m_hapticDuration = -1f;

		private float m_hapticStartTime = -1f;

		public HandednessId Handedness => m_handedness;

		public bool IsLeft => m_handedness == HandednessId.Left;

		public bool IsPoint => false;

		public bool IsThumbsUp => false;

		public bool Button1 => OVRInput.Get(OVRInput.Button.One, m_controllerType);

		public bool Button2 => OVRInput.Get(OVRInput.Button.Two, m_controllerType);

		public bool ButtonJoystick => OVRInput.Get(OVRInput.Button.PrimaryThumbstick, m_controllerType);

		public float Trigger => OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, m_controllerType);

		public float GripTrigger => OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controllerType);

		public Vector2 Joystick => OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, m_controllerType);

		public static TrackedController FindOrCreate(HandednessId handedness)
		{
			TrackedController[] array = UnityEngine.Object.FindObjectsOfType<TrackedController>();
			TrackedController[] array2 = array;
			foreach (TrackedController trackedController in array2)
			{
				if (trackedController.Handedness == handedness)
				{
					return trackedController;
				}
			}
			GameObject gameObject = new GameObject("TrackedController");
			TrackedController trackedController2 = gameObject.AddComponent<TrackedController>();
			Transform trackedTransform = null;
			OVRCameraRig oVRCameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
			if (oVRCameraRig != null)
			{
				trackedTransform = ((handedness != 0) ? oVRCameraRig.rightHandAnchor : oVRCameraRig.leftHandAnchor);
			}
			trackedController2.Initialize(handedness, trackedTransform);
			return trackedController2;
		}

		public void PlayHapticEvent(float frequency, float amplitude, float duration)
		{
			m_hapticStartTime = Time.realtimeSinceStartup;
			m_hapticDuration = duration;
			OVRInput.SetControllerVibration(frequency, amplitude, m_controllerType);
		}

		private void Awake()
		{
			if (m_trackedTransform != null)
			{
				Initialize(m_handedness, m_trackedTransform);
			}
		}

		private void LateUpdate()
		{
			if (m_trackedTransform != null)
			{
				base.transform.position = m_trackedTransform.position;
				base.transform.rotation = m_trackedTransform.rotation;
			}
			float num = Time.realtimeSinceStartup - m_hapticStartTime;
			if (num >= m_hapticDuration)
			{
				OVRInput.SetControllerVibration(0f, 0f, m_controllerType);
			}
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			bool flag = false;
			if (flag)
			{
				m_lastPoint = realtimeSinceStartup;
			}
			else
			{
				m_lastNonPoint = realtimeSinceStartup;
			}
			bool flag2 = false;
			if (flag2)
			{
				m_lastThumb = realtimeSinceStartup;
			}
			else
			{
				m_lastNonThumb = realtimeSinceStartup;
			}
			if (flag != IsPoint && ((flag && realtimeSinceStartup - m_lastNonPoint > 0.05f) || (!flag && realtimeSinceStartup - m_lastPoint > 0.05f)))
			{
				m_point = flag;
			}
			if (flag2 != IsThumbsUp && ((flag2 && realtimeSinceStartup - m_lastNonThumb > 0.15f) || (!flag2 && realtimeSinceStartup - m_lastThumb > 0.15f)))
			{
				m_thumbsUp = flag2;
			}
		}

		private void Initialize(HandednessId handedness, Transform trackedTransform)
		{
			if (!m_initialized)
			{
				m_handedness = handedness;
				m_controllerType = ((m_handedness == HandednessId.Left) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
				if (trackedTransform != null)
				{
					m_trackedTransform = trackedTransform;
					base.transform.position = m_trackedTransform.position;
					base.transform.rotation = m_trackedTransform.rotation;
				}
				m_initialized = true;
			}
		}
	}
}
namespace OvrTouch.Hands
{
	public enum HandPoseId
	{
		Default,
		Generic,
		PingPongBall
	}
	public enum HandPoseAttachType
	{
		None,
		Snap,
		SnapPosition
	}
	public class HandPose : MonoBehaviour
	{
		[SerializeField]
		private bool m_allowPointing;

		[SerializeField]
		private bool m_allowThumbsUp;

		[SerializeField]
		private HandPoseId m_poseId;

		[SerializeField]
		private HandPoseAttachType m_attachType;

		public bool AllowPointing => m_allowPointing;

		public bool AllowThumbsUp => m_allowThumbsUp;

		public HandPoseId PoseId => m_poseId;

		public HandPoseAttachType AttachType => m_attachType;
	}
}
public class GUIView : MonoBehaviour
{
	private float progress;

	private bool muted;

	private int score;

	private string playername = "Noname";

	private const string PROGRESS_KEY = "Progress";

	private const string MUTED_KEY = "IsSoundMuted";

	private const string SCORE_KEY = "Highscore";

	private const string PLAYERNAME_KEY = "PlayerName";

	private void Start()
	{
		RefreshData();
	}

	private void Update()
	{
		if (Input.anyKeyDown)
		{
			RefreshData();
		}
	}

	private void OnGUI()
	{
		int num = 450;
		int num2 = 400;
		GUILayout.BeginArea(new Rect(Screen.width / 2 - num / 2, Screen.height / 2 - num2 / 2, num, num2));
		GUILayout.BeginVertical();
		string text = "Unfortunately, this will take a a few seconds. This is due Unity working different on a Mac :(";
		GUILayout.TextArea(string.Format("Instructions: {0} 1) Open the Advanced PlayerPrefs Window and dock it somewhere. {0} 2) Change the values in the scene using the gui widgets. {0} 3) Go back to the Advanced PlayerPrefs Window and click the refresh button. " + ((UnityEngine.Application.platform != 0) ? string.Empty : text) + " {0} 4) Observe that the values in the Advanced PlayerPrefs Window has changed to your scene input. {0}{0} 5) Now in the Advanced PlayerPrefs Window, change the values and save those changes {0} 6) Go give the scene focus by clicking in the sceneview. {0} 7) Watch the gui values update to your changes", Environment.NewLine));
		GUILayout.Space(12f);
		GUILayout.Label("Progress: " + (int)progress + "%");
		float a = GUILayout.HorizontalSlider(progress, 0f, 100f);
		if (!Mathf.Approximately(a, progress))
		{
			progress = a;
			SaveData();
		}
		GUILayout.Space(12f);
		bool flag = GUILayout.Toggle(muted, "Is Audio Muted?");
		if (flag != muted)
		{
			muted = flag;
			SaveData();
		}
		GUILayout.Space(12f);
		GUILayout.Label("Highscore: " + score);
		GUILayout.Space(12f);
		GUILayout.Label("Playername");
		string text2 = GUILayout.TextField(playername);
		if (text2 != playername)
		{
			playername = text2;
			SaveData();
		}
		GUILayout.EndVertical();
		GUILayout.EndArea();
	}

	public void RefreshData()
	{
		progress = PlayerPrefs.GetFloat("Progress", 100f);
		muted = PlayerPrefs.GetString("IsSoundMuted", "true") == "true";
		score = PlayerPrefs.GetInt("Highscore", 123);
		playername = PlayerPrefs.GetString("PlayerName", "Noname");
	}

	public void SaveData()
	{
		PlayerPrefs.SetFloat("Progress", progress);
		PlayerPrefs.SetString("IsSoundMuted", (!muted) ? "false" : "true");
		PlayerPrefs.SetInt("Highscore", score);
		PlayerPrefs.SetString("PlayerName", playername);
	}
}
public class CameraController : MonoBehaviour
{
	public List<Camera> Cameras = new List<Camera>();

	private int m_CurrentIndex;

	public void Awake()
	{
		for (int i = 0; i < Cameras.Count; i++)
		{
			Cameras[i].enabled = false;
			if (i == m_CurrentIndex)
			{
				Cameras[i].enabled = true;
			}
		}
	}

	private void OnGUI()
	{
		if (!GUI.Button(new Rect((float)Screen.width / 2.3f, (float)Screen.height / 1.15f, 150f, 40f), "NEXT"))
		{
			return;
		}
		m_CurrentIndex++;
		if (m_CurrentIndex >= Cameras.Count)
		{
			m_CurrentIndex = 0;
		}
		for (int i = 0; i < Cameras.Count; i++)
		{
			Cameras[i].enabled = false;
			if (i == m_CurrentIndex)
			{
				Cameras[i].enabled = true;
			}
		}
	}
}
public class Cleanup : MonoBehaviour
{
	public float TimeBeforeCleanup;

	private void Awake()
	{
		StartCoroutine(CleanupObject());
	}

	public IEnumerator CleanupObject()
	{
		yield return new WaitForSeconds(TimeBeforeCleanup);
		UnityEngine.Object.DestroyObject(base.gameObject);
	}
}
[RequireComponent(typeof(AudioSource))]
public class Lightning : MonoBehaviour
{
	public Light TargetLight;

	public bool Enabled;

	public float MinWaitTime;

	public float MaxWaitTime;

	public AudioSource Sound;

	public void Awake()
	{
		if (!(TargetLight == null) && Enabled)
		{
			StartCoroutine(PlayLightning());
		}
	}

	private IEnumerator PlayLightning()
	{
		while (Enabled)
		{
			yield return new WaitForSeconds(UnityEngine.Random.Range(MinWaitTime, MaxWaitTime));
			TargetLight.intensity = 0f;
			if (Sound != null)
			{
				Sound.Play();
			}
			while (TargetLight.intensity < 0.3f)
			{
				TargetLight.intensity = Mathf.Lerp(TargetLight.intensity, 0.4f, Time.deltaTime * 15f);
				yield return new WaitForSeconds(0f);
			}
			while (TargetLight.intensity > 0f)
			{
				TargetLight.intensity = Mathf.Lerp(TargetLight.intensity, -0.1f, Time.deltaTime * 3f);
				yield return new WaitForSeconds(0f);
			}
			TargetLight.intensity = 0f;
		}
	}
}
public class PlayEffect : MonoBehaviour
{
	public GameObject Effect;

	public Transform Node;

	public float OverrideTime;

	private float m_Time;

	public void Awake()
	{
		m_Time = Time.time;
	}

	private void Update()
	{
		if (Effect == null)
		{
			return;
		}
		if (OverrideTime > 0f)
		{
			if (Time.time >= m_Time + OverrideTime)
			{
				UnityEngine.Object.Instantiate(Effect, Node.position, Node.rotation);
				m_Time = Time.time;
			}
		}
		else if (Time.time >= m_Time + 1.5f)
		{
			UnityEngine.Object.Instantiate(Effect, Node.position, Node.rotation);
			m_Time = Time.time;
		}
	}
}
public class Visual : MonoBehaviour
{
	public float DontChangeThis;

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = new Color(1f, 1f, 1f, 0.5f);
		Gizmos.DrawCube(base.transform.position, new Vector3(15f, DontChangeThis, 15f));
	}
}
namespace DCM
{
	public class DrawCallMinimizer : MonoBehaviour
	{
		[SerializeField]
		private DrawCallMinimizerInfo _textureAtlasProperties = new DrawCallMinimizerInfo();

		[SerializeField]
		private bool destroyOriginalGameObject;

		public const string VERSION = "2.0";

		public DrawCallMinimizerInfo textureAtlasProperties
		{
			get
			{
				return _textureAtlasProperties;
			}
			set
			{
				_textureAtlasProperties = value;
			}
		}

		private void Start()
		{
			MeshFilter[] componentsInChildren = GetComponentsInChildren<MeshFilter>();
			Matrix4x4 worldToLocalMatrix = base.transform.worldToLocalMatrix;
			Dictionary<string, Dictionary<Material, List<MeshInstance>>> allMeshesAndMaterials = new Dictionary<string, Dictionary<Material, List<MeshInstance>>>();
			OrganizeObjects(componentsInChildren, worldToLocalMatrix, allMeshesAndMaterials);
			CreateBatchedObjects(allMeshesAndMaterials);
			if (destroyOriginalGameObject)
			{
				UnityEngine.Object.Destroy(base.gameObject);
				return;
			}
			MeshFilter[] array = componentsInChildren;
			foreach (MeshFilter obj in array)
			{
				UnityEngine.Object.Destroy(obj);
			}
			Renderer[] componentsInChildren2 = GetComponentsInChildren<Renderer>();
			foreach (Renderer renderer in componentsInChildren2)
			{
				renderer.enabled = false;
			}
			UnityEngine.Object.Destroy(this);
		}

		private static void OrganizeObjects(MeshFilter[] filters, Matrix4x4 myTransform, IDictionary<string, Dictionary<Material, List<MeshInstance>>> allMeshesAndMaterials)
		{
			for (int i = 0; i < filters.Length; i++)
			{
				Renderer component = filters[i].GetComponent<Renderer>();
				MeshInstance item = default(MeshInstance);
				item.mesh = filters[i].mesh;
				if (component != null && component.enabled && item.mesh != null)
				{
					item.transform = myTransform * filters[i].transform.localToWorldMatrix;
					Material[] sharedMaterials = component.sharedMaterials;
					for (int j = 0; j < sharedMaterials.Length; j++)
					{
						ConfirmDictionaryKeys(allMeshesAndMaterials, sharedMaterials[j]);
						item.subMeshIndex = Mathf.Min(j, item.mesh.subMeshCount - 1);
						allMeshesAndMaterials[sharedMaterials[j].shader.ToString()][sharedMaterials[j]].Add(item);
					}
				}
			}
		}

		private static void ConfirmDictionaryKeys(IDictionary<string, Dictionary<Material, List<MeshInstance>>> allMeshesAndMaterials, Material mat)
		{
			if (!allMeshesAndMaterials.ContainsKey(mat.shader.ToString()))
			{
				allMeshesAndMaterials.Add(mat.shader.ToString(), new Dictionary<Material, List<MeshInstance>>());
			}
			if (!allMeshesAndMaterials[mat.shader.ToString()].ContainsKey(mat))
			{
				allMeshesAndMaterials[mat.shader.ToString()].Add(mat, new List<MeshInstance>());
			}
		}

		private void CreateBatchedObjects(IDictionary<string, Dictionary<Material, List<MeshInstance>>> allMeshesAndMaterials)
		{
			foreach (KeyValuePair<string, Dictionary<Material, List<MeshInstance>>> allMeshesAndMaterial in allMeshesAndMaterials)
			{
				List<Material> combines = new List<Material>(allMeshesAndMaterial.Value.Keys);
				TextureCombineOutput textureCombineOutput = TextureCombineUtility.Combine(combines, _textureAtlasProperties);
				if (textureCombineOutput == null || textureCombineOutput.texturePositions == null)
				{
					continue;
				}
				List<MeshInstance> list = new List<MeshInstance>();
				foreach (KeyValuePair<Material, List<MeshInstance>> item in allMeshesAndMaterial.Value)
				{
					TexturePosition referenceTexturePosition = GetReferenceTexturePosition(textureCombineOutput.texturePositions, item.Key.mainTexture.name);
					for (int i = 0; i < item.Value.Count; i++)
					{
						OffsetUvs(item.Value[i].mesh, referenceTexturePosition.position);
						list.Add(item.Value[i]);
					}
				}
				IList<Mesh> list2 = MeshCombineUtility.Combine(list);
				GameObject gameObject = new GameObject("Combined " + base.gameObject.name + " " + allMeshesAndMaterial.Key + " Mesh Parent");
				gameObject.transform.position = base.transform.position;
				gameObject.transform.rotation = base.transform.rotation;
				for (int j = 0; j < list2.Count; j++)
				{
					GameObject gameObject2 = new GameObject("Combined " + base.gameObject.name + " Mesh");
					gameObject2.transform.parent = gameObject.transform;
					gameObject2.tag = base.gameObject.tag;
					gameObject2.layer = base.gameObject.layer;
					gameObject2.transform.localScale = Vector3.one;
					gameObject2.transform.localRotation = Quaternion.identity;
					gameObject2.transform.localPosition = Vector3.zero;
					MeshFilter meshFilter = gameObject2.AddComponent<MeshFilter>();
					gameObject2.AddComponent<MeshRenderer>().sharedMaterial = textureCombineOutput.combinedMaterial;
					meshFilter.mesh = list2[j];
				}
			}
		}

		private static TexturePosition GetReferenceTexturePosition(IList<TexturePosition> textureUVPositions, string textureName)
		{
			TexturePosition result = textureUVPositions[0];
			for (int i = 0; i < textureUVPositions.Count; i++)
			{
				if (textureName.Length == textureUVPositions[i].textures[0].name.Length && textureName == textureUVPositions[i].textures[0].name)
				{
					result = textureUVPositions[i];
					break;
				}
			}
			return result;
		}

		private static void OffsetUvs(Mesh modifiedMesh, Rect referencedTexturePosition)
		{
			Vector2[] uv = modifiedMesh.uv;
			for (int i = 0; i < uv.Length; i++)
			{
				uv[i].x = referencedTexturePosition.x + uv[i].x * referencedTexturePosition.width;
				uv[i].y = referencedTexturePosition.y + uv[i].y * referencedTexturePosition.height;
			}
			modifiedMesh.uv = uv;
			uv = modifiedMesh.uv2;
			for (int j = 0; j < uv.Length; j++)
			{
				uv[j].x = referencedTexturePosition.x + uv[j].x * referencedTexturePosition.width;
				uv[j].y = referencedTexturePosition.y + uv[j].y * referencedTexturePosition.height;
			}
			modifiedMesh.uv2 = uv;
		}
	}
	[Serializable]
	public enum CommonShaderProperties
	{
		_MainTex,
		_BumpMap,
		_Cube,
		_DecalTex,
		_Detail,
		_ParallaxMap,
		Other
	}
	[Serializable]
	public class DrawCallMinimizerInfo
	{
		[SerializeField]
		private int _anisoLevel = 1;

		[SerializeField]
		private bool _readableTexture;

		[SerializeField]
		private FilterMode _filterMode = FilterMode.Bilinear;

		[SerializeField]
		private bool _ignoreTransparency;

		[SerializeField]
		private TextureWrapMode _wrapMode = TextureWrapMode.Clamp;

		[SerializeField]
		private List<ShaderProperties> _shaderPropertiesToLookFor = new List<ShaderProperties>
		{
			new ShaderProperties(normal: false, "_MainTex"),
			new ShaderProperties(normal: true, "_BumpMap"),
			new ShaderProperties(normal: false, "_Cube"),
			new ShaderProperties(normal: false, "_DecalTex"),
			new ShaderProperties(normal: false, "_Detail"),
			new ShaderProperties(normal: false, "_ParallaxMap")
		};

		[SerializeField]
		private int _maxTextureSize = 2048;

		[SerializeField]
		private int _padding;

		public int anisoLevel
		{
			get
			{
				return _anisoLevel;
			}
			set
			{
				_anisoLevel = value;
			}
		}

		public bool readableTexture
		{
			get
			{
				return _readableTexture;
			}
			set
			{
				_readableTexture = value;
			}
		}

		public FilterMode filterMode
		{
			get
			{
				return _filterMode;
			}
			set
			{
				_filterMode = value;
			}
		}

		public bool ignoreTransparency
		{
			get
			{
				return _ignoreTransparency;
			}
			set
			{
				_ignoreTransparency = value;
			}
		}

		public TextureWrapMode wrapMode
		{
			get
			{
				return _wrapMode;
			}
			set
			{
				_wrapMode = value;
			}
		}

		public IList<ShaderProperties> shaderPropertiesToLookFor
		{
			get
			{
				return _shaderPropertiesToLookFor;
			}
			set
			{
				_shaderPropertiesToLookFor = (List<ShaderProperties>)value;
			}
		}

		public int maxTextureSize
		{
			get
			{
				return _maxTextureSize;
			}
			set
			{
				_maxTextureSize = value;
			}
		}

		public int padding
		{
			get
			{
				return _padding;
			}
			set
			{
				_padding = value;
			}
		}
	}
	public static class MatrixExtension
	{
		public static Vector3 GetScale(this Matrix4x4 mat)
		{
			return new Vector3(Vector3.Magnitude(new Vector3(mat.m00, mat.m01, mat.m02)), Vector3.Magnitude(new Vector3(mat.m10, mat.m11, mat.m12)), Vector3.Magnitude(new Vector3(mat.m20, mat.m21, mat.m22)));
		}

		public static float GetDeterminant(this Matrix4x4 mat)
		{
			return mat.m00 * mat.m11 * mat.m22 + mat.m01 * mat.m12 * mat.m20 + mat.m02 * mat.m10 * mat.m21 - mat.m02 * mat.m11 * mat.m20 - mat.m01 * mat.m10 * mat.m22 - mat.m00 * mat.m12 * mat.m21;
		}
	}
	public static class MeshCombineUtility
	{
		public static IList<Mesh> Combine(IList<MeshInstance> combines)
		{
			return Combine(combines, 65000);
		}

		public static IList<Mesh> Combine(IList<MeshInstance> combines, int maximumVertices)
		{
			float num = 0f;
			int num2 = 0;
			for (int i = 0; i < combines.Count; i++)
			{
				if (combines[i].mesh != null)
				{
					num += (float)combines[i].mesh.vertexCount;
					num2 += combines[i].mesh.triangles.Length;
				}
			}
			int j = 0;
			int num3 = Mathf.CeilToInt(num / (float)maximumVertices);
			int num4 = (int)(num / (float)num3);
			List<Mesh> list = new List<Mesh>();
			for (int k = 1; k <= num3; k++)
			{
				List<Vector3> list2 = new List<Vector3>(num4);
				List<Vector3> list3 = new List<Vector3>(num4);
				List<Vector4> list4 = new List<Vector4>(num4);
				List<Vector2> list5 = new List<Vector2>(num4);
				List<Vector2> list6 = new List<Vector2>(num4);
				List<Color> list7 = new List<Color>(num4);
				List<int> list8 = new List<int>(num2 / num3);
				int num5 = 0;
				for (; j < combines.Count; j++)
				{
					if (num5 > num4)
					{
						break;
					}
					if (!(combines[j].mesh != null))
					{
						continue;
					}
					Matrix4x4 transform = combines[j].transform;
					Copy(combines[j].mesh.vertices, list2, combines[j].transform);
					transform = transform.inverse.transpose;
					if (combines[j].mesh.normals.Length != combines[j].mesh.vertexCount)
					{
						combines[j].mesh.RecalculateNormals();
					}
					CopyNormal(combines[j].mesh.normals, list3, transform);
					if (combines[j].mesh.tangents.Length != combines[j].mesh.vertexCount)
					{
						CalculateTangents(combines[j].mesh);
					}
					CopyTangents(combines[j].mesh.tangents, list4, transform);
					Copy(combines[j].mesh.uv, list5);
					if (combines[j].mesh.uv2.Length == combines[j].mesh.vertexCount)
					{
						Copy(combines[j].mesh.uv2, list6);
					}
					else
					{
						Vector2 zero = Vector2.zero;
						for (int l = 0; l < combines[j].mesh.vertexCount; l++)
						{
							list6.Add(zero);
						}
					}
					if (combines[j].mesh.colors.Length == combines[j].mesh.vertexCount)
					{
						CopyColors(combines[j].mesh.colors, list7);
					}
					else
					{
						Color white = Color.white;
						for (int m = 0; m < combines[j].mesh.vertexCount; m++)
						{
							list7.Add(white);
						}
					}
					CopyTriangles(combines[j].mesh.triangles, list8, num5, combines[j].transform.GetDeterminant() < 0f);
					num5 += combines[j].mesh.vertexCount;
				}
				Mesh mesh = new Mesh();
				mesh.name = "Combined Mesh";
				mesh.vertices = list2.ToArray();
				mesh.normals = list3.ToArray();
				mesh.colors = list7.ToArray();
				mesh.uv = list5.ToArray();
				mesh.uv2 = list6.ToArray();
				mesh.tangents = list4.ToArray();
				mesh.triangles = list8.ToArray();
				list.Add(mesh);
			}
			return list.ToArray();
		}

		private static void Copy(Vector3[] src, ICollection<Vector3> dst, Matrix4x4 transform)
		{
			for (int i = 0; i < src.Length; i++)
			{
				dst.Add(transform.MultiplyPoint(src[i]));
			}
		}

		private static void CopyNormal(Vector3[] src, ICollection<Vector3> dst, Matrix4x4 transform)
		{
			for (int i = 0; i < src.Length; i++)
			{
				dst.Add(transform.MultiplyVector(src[i]).normalized);
			}
		}

		private static void Copy(Vector2[] src, ICollection<Vector2> dst)
		{
			for (int i = 0; i < src.Length; i++)
			{
				dst.Add(src[i]);
			}
		}

		private static void CopyColors(Color[] src, ICollection<Color> dst)
		{
			for (int i = 0; i < src.Length; i++)
			{
				dst.Add(src[i]);
			}
		}

		private static void CopyTangents(Vector4[] src, ICollection<Vector4> dst, Matrix4x4 transform)
		{
			for (int i = 0; i < src.Length; i++)
			{
				Vector4 vector = src[i];
				Vector3 vector2 = new Vector3(vector.x, vector.y, vector.z);
				vector2 = transform.MultiplyVector(vector2).normalized;
				dst.Add(new Vector4(vector2.x, vector2.y, vector2.z, vector.w));
			}
		}

		private static void CopyTriangles(int[] src, ICollection<int> dst, int vertexOffset, bool isNegativeScale)
		{
			if (isNegativeScale)
			{
				for (int i = 0; i < src.Length; i += 3)
				{
					dst.Add(src[i] + vertexOffset);
					dst.Add(src[i + 2] + vertexOffset);
					dst.Add(src[i + 1] + vertexOffset);
				}
			}
			else
			{
				for (int j = 0; j < src.Length; j++)
				{
					dst.Add(src[j] + vertexOffset);
				}
			}
		}

		private static void CalculateTangents(Mesh mesh)
		{
			int vertexCount = mesh.vertexCount;
			Vector3[] vertices = mesh.vertices;
			Vector3[] normals = mesh.normals;
			Vector2[] uv = mesh.uv;
			int[] triangles = mesh.triangles;
			int num = triangles.Length / 3;
			Vector4[] array = new Vector4[vertexCount];
			Vector3[] array2 = new Vector3[vertexCount];
			Vector3[] array3 = new Vector3[vertexCount];
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				int num3 = triangles[num2];
				int num4 = triangles[num2 + 1];
				int num5 = triangles[num2 + 2];
				Vector3 vector = vertices[num3];
				Vector3 vector2 = vertices[num4];
				Vector3 vector3 = vertices[num5];
				Vector2 vector4 = uv[num3];
				Vector2 vector5 = uv[num4];
				Vector2 vector6 = uv[num5];
				float num6 = vector2.x - vector.x;
				float num7 = vector3.x - vector.x;
				float num8 = vector2.y - vector.y;
				float num9 = vector3.y - vector.y;
				float num10 = vector2.z - vector.z;
				float num11 = vector3.z - vector.z;
				float num12 = vector5.x - vector4.x;
				float num13 = vector6.x - vector4.x;
				float num14 = vector5.y - vector4.y;
				float num15 = vector6.y - vector4.y;
				float num16 = 1f / (num12 * num15 - num13 * num14);
				Vector3 vector7 = new Vector3((num15 * num6 - num14 * num7) * num16, (num15 * num8 - num14 * num9) * num16, (num15 * num10 - num14 * num11) * num16);
				Vector3 vector8 = new Vector3((num12 * num7 - num13 * num6) * num16, (num12 * num9 - num13 * num8) * num16, (num12 * num11 - num13 * num10) * num16);
				array2[num3] += vector7;
				array2[num4] += vector7;
				array2[num5] += vector7;
				array3[num3] += vector8;
				array3[num4] += vector8;
				array3[num5] += vector8;
				num2 += 3;
			}
			for (int j = 0; j < vertexCount; j++)
			{
				Vector3 normal = normals[j];
				Vector3 tangent = array2[j];
				Vector3.OrthoNormalize(ref normal, ref tangent);
				array[j].x = tangent.x;
				array[j].y = tangent.y;
				array[j].z = tangent.z;
				array[j].w = ((!(Vector3.Dot(Vector3.Cross(normal, tangent), array3[j]) < 0f)) ? 1f : (-1f));
			}
			mesh.tangents = array;
		}
	}
	public class MeshExporter
	{
		public static string MeshToString(Mesh m)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("g Exported Mesh " + m.name + " \n");
			Matrix4x4 matrix4x = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, new Vector3(-1f, 1f, 1f));
			Vector3[] vertices = m.vertices;
			foreach (Vector3 point in vertices)
			{
				Vector3 vector = matrix4x.MultiplyPoint(point);
				stringBuilder.Append($"v {vector.x} {vector.y} {vector.z}\n");
			}
			stringBuilder.Append("\n");
			Vector3[] normals = m.normals;
			foreach (Vector3 vector2 in normals)
			{
				Vector3 vector3 = matrix4x.MultiplyVector(vector2);
				stringBuilder.Append($"vn {vector3.x} {vector3.y} {vector3.z}\n");
			}
			stringBuilder.Append("\n");
			Vector2[] uv = m.uv;
			for (int k = 0; k < uv.Length; k++)
			{
				Vector2 vector4 = uv[k];
				stringBuilder.Append($"vt {vector4.x} {vector4.y}\n");
			}
			stringBuilder.Append("\n");
			Vector2[] uv2 = m.uv2;
			for (int l = 0; l < uv2.Length; l++)
			{
				Vector2 vector5 = uv2[l];
				stringBuilder.Append($"vt1 {vector5.x} {vector5.y}\n");
			}
			stringBuilder.Append("\n");
			Vector2[] uv3 = m.uv2;
			for (int n = 0; n < uv3.Length; n++)
			{
				Vector2 vector6 = uv3[n];
				stringBuilder.Append($"vt2 {vector6.x} {vector6.y}\n");
			}
			stringBuilder.Append("\n");
			Color[] colors = m.colors;
			for (int num = 0; num < colors.Length; num++)
			{
				Color color = colors[num];
				stringBuilder.Append($"vc {color.r} {color.g} {color.b} {color.a}\n");
			}
			for (int num2 = 0; num2 < m.triangles.Length; num2 += 3)
			{
				stringBuilder.Append(string.Format("f {0}/{0}/{0} {1}/{1}/{1} {2}/{2}/{2}\n", m.triangles[num2] + 1, m.triangles[num2 + 2] + 1, m.triangles[num2 + 1] + 1));
			}
			return stringBuilder.ToString();
		}

		public static void MeshToFile(Mesh m, string filename)
		{
			try
			{
				using StreamWriter streamWriter = new StreamWriter(filename);
				streamWriter.WriteLine(MeshToString(m));
			}
			catch (Exception ex)
			{
				Debug.LogError(ex.Message);
			}
		}
	}
	public struct MeshInstance
	{
		[SerializeField]
		private Mesh _mesh;

		[SerializeField]
		private int _subMeshIndex;

		[SerializeField]
		private Matrix4x4 _transform;

		public Mesh mesh
		{
			get
			{
				return _mesh;
			}
			set
			{
				_mesh = value;
			}
		}

		public int subMeshIndex
		{
			get
			{
				return _subMeshIndex;
			}
			set
			{
				_subMeshIndex = value;
			}
		}

		public Matrix4x4 transform
		{
			get
			{
				return _transform;
			}
			set
			{
				_transform = value;
			}
		}
	}
	[Serializable]
	public class ShaderProperties
	{
		[SerializeField]
		private bool _markAsNormal;

		[SerializeField]
		private string _propertyName;

		public bool markAsNormal
		{
			get
			{
				return _markAsNormal;
			}
			set
			{
				_markAsNormal = value;
			}
		}

		public string propertyName
		{
			get
			{
				return _propertyName;
			}
			set
			{
				_propertyName = value;
			}
		}

		public ShaderProperties(bool normal, string name)
		{
			_markAsNormal = normal;
			_propertyName = name;
		}
	}
	public class TextureCombineOutput
	{
		[SerializeField]
		private Material _combinedMaterial;

		[SerializeField]
		private TexturePosition[] _texturePositions;

		public Material combinedMaterial
		{
			get
			{
				return _combinedMaterial;
			}
			set
			{
				_combinedMaterial = value;
			}
		}

		public TexturePosition[] texturePositions
		{
			get
			{
				return _texturePositions;
			}
			set
			{
				_texturePositions = value;
			}
		}
	}
	public static class TextureCombineUtility
	{
		private static Texture2D _defaultTexture;

		public static Texture2D defaultTexture
		{
			get
			{
				if (_defaultTexture == null)
				{
					_defaultTexture = new Texture2D(32, 32, TextureFormat.RGB24, mipmap: false);
					Color[] array = new Color[1024];
					Color white = Color.white;
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = white;
					}
					_defaultTexture.SetPixels(array);
					_defaultTexture.Apply();
				}
				return _defaultTexture;
			}
		}

		public static TextureCombineOutput Combine(IList<Material> combines, DrawCallMinimizerInfo atlasInfo)
		{
			if (atlasInfo == null || atlasInfo.shaderPropertiesToLookFor == null || atlasInfo.shaderPropertiesToLookFor.Count <= 0)
			{
				Debug.LogError("You need to enter some shader properties to look for into Atlas Info. Cannot combine with 0 properties");
				return null;
			}
			TextureCombineOutput textureCombineOutput = new TextureCombineOutput();
			IList<ShaderProperties> shaderProperties = GetShaderProperties(combines, atlasInfo);
			for (int i = 0; i < combines.Count; i++)
			{
				FillInNullMainTexture(combines[i]);
				for (int j = 0; j < shaderProperties.Count; j++)
				{
					FillInNulls(combines[i], shaderProperties[j]);
				}
			}
			textureCombineOutput.texturePositions = SetTexturePositions(combines, shaderProperties);
			Texture2D texture2D = new Texture2D(atlasInfo.maxTextureSize, atlasInfo.maxTextureSize, (!atlasInfo.ignoreTransparency || shaderProperties[0].markAsNormal) ? TextureFormat.ARGB32 : TextureFormat.RGB24, mipmap: true);
			Rect[] array = PackOriginalTexture(textureCombineOutput.texturePositions, texture2D, atlasInfo);
			if (array != null)
			{
				Material material = new Material(combines[0]);
				material.SetTexture(shaderProperties[0].propertyName, texture2D);
				for (int k = 1; k < shaderProperties.Count; k++)
				{
					Texture2D value = PackAdditionalTexture(GetTexturesAsArray(textureCombineOutput.texturePositions, k), texture2D.width, texture2D.height, atlasInfo, array, shaderProperties[k].markAsNormal);
					material.SetTexture(shaderProperties[k].propertyName, value);
				}
				textureCombineOutput.combinedMaterial = material;
				return textureCombineOutput;
			}
			Debug.LogError("There was some sort of issue while trying to pack the textures...");
			return null;
		}

		private static void FillInNulls(Material mat, ShaderProperties property)
		{
			if (mat.HasProperty(property.propertyName) && mat.GetTexture(property.propertyName) == null)
			{
				mat.SetTexture(property.propertyName, defaultTexture);
			}
		}

		private static void FillInNullMainTexture(Material mat)
		{
			if (mat.mainTexture == null)
			{
				mat.mainTexture = defaultTexture;
			}
		}

		public static TextureCombineOutput Combine(IList<Material> combines, DrawCallMinimizerInfo atlasInfo, bool readableOveride)
		{
			atlasInfo.readableTexture = readableOveride;
			return Combine(combines, atlasInfo);
		}

		private static IList<ShaderProperties> GetShaderProperties(IList<Material> combines, DrawCallMinimizerInfo atlasInfo)
		{
			return GetShaderProperties(combines[0], atlasInfo);
		}

		public static IList<ShaderProperties> GetShaderProperties(Material material, DrawCallMinimizerInfo atlasInfo)
		{
			List<ShaderProperties> list = new List<ShaderProperties>();
			for (int i = 0; i < atlasInfo.shaderPropertiesToLookFor.Count; i++)
			{
				if (material.HasProperty(atlasInfo.shaderPropertiesToLookFor[i].propertyName))
				{
					list.Add(atlasInfo.shaderPropertiesToLookFor[i]);
				}
			}
			return list.AsReadOnly();
		}

		private static Texture2D[] GetTexturesAsArray(IList<TexturePosition> texturePositions, int index)
		{
			if (texturePositions == null || texturePositions.Count == 0)
			{
				Debug.LogError("No TexturePositions exist in list passed to GetTexturesAsArray. Exiting out of batching operation... Check to see that objects being batched are not missing textures");
				return null;
			}
			if (texturePositions[0].textures == null || texturePositions[0].textures.Count == 0)
			{
				Debug.LogError("Could not find textures to batch during GetTexturesAsArray. Exiting out of batching operation... Check to see that objects being batched are not missing textures");
				return null;
			}
			if (index < 0 || index >= texturePositions[0].textures.Count)
			{
				Debug.LogError("Index passed into GetTexturesAsArray is out of bounds...Not quite sure how that could have happened, double check that your textures are set properly on your objects, and if they are, email johnjrpurdy@gmail.com with the Debug.Log output and what you are trying to do");
				return null;
			}
			Texture2D[] array = new Texture2D[texturePositions.Count];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = texturePositions[i].textures[index];
			}
			return array;
		}

		private static TexturePosition[] SetTexturePositions(IList<Material> combines, IList<ShaderProperties> properties)
		{
			TexturePosition[] array = new TexturePosition[combines.Count];
			for (int i = 0; i < combines.Count; i++)
			{
				TexturePosition texturePosition = default(TexturePosition);
				texturePosition.textures = new List<Texture2D>(properties.Count);
				for (int j = 0; j < properties.Count; j++)
				{
					if (combines[i].GetTexture(properties[j].propertyName) == null)
					{
						Debug.LogError("Cannot combine textures when using Unity's default material texture");
						return null;
					}
					texturePosition.textures.Add(combines[i].GetTexture(properties[j].propertyName) as Texture2D);
				}
				array[i] = texturePosition;
			}
			return array;
		}

		private static Rect[] PackOriginalTexture(TexturePosition[] texturePositions, Texture2D textureAtlas, DrawCallMinimizerInfo atlasInfo)
		{
			textureAtlas.anisoLevel = atlasInfo.anisoLevel;
			textureAtlas.filterMode = atlasInfo.filterMode;
			textureAtlas.wrapMode = atlasInfo.wrapMode;
			Rect[] array = textureAtlas.PackTextures(GetTexturesAsArray(texturePositions, 0), atlasInfo.padding, atlasInfo.maxTextureSize, !atlasInfo.readableTexture);
			for (int i = 0; i < texturePositions.Length; i++)
			{
				texturePositions[i].position = array[i];
			}
			return array;
		}

		private static Texture2D PackAdditionalTexture(IList<Texture2D> textures, int textureWidth, int textureHeight, DrawCallMinimizerInfo atlasInfo, IList<Rect> UVs, bool markAsNormal)
		{
			Texture2D texture2D = new Texture2D(textureWidth, textureHeight, (!atlasInfo.ignoreTransparency || markAsNormal) ? TextureFormat.ARGB32 : TextureFormat.RGB24, mipmap: true);
			texture2D.anisoLevel = atlasInfo.anisoLevel;
			texture2D.filterMode = atlasInfo.filterMode;
			texture2D.wrapMode = atlasInfo.wrapMode;
			for (int i = 0; i < textures.Count; i++)
			{
				if (!Mathf.Approximately(textures[i].width, (float)textureWidth * UVs[i].width) || !Mathf.Approximately(textures[i].height, (float)textureHeight * UVs[i].height))
				{
					textures[i] = ScaleTexture(textures[i], (int)(UVs[i].width * (float)textureWidth), (int)(UVs[i].height * (float)textureHeight));
				}
				try
				{
					texture2D.SetPixels((int)(UVs[i].x * (float)textureWidth), (int)((float)textureHeight * UVs[i].y), (int)(UVs[i].width * (float)textureWidth), (int)((float)textureHeight * UVs[i].height), textures[i].GetPixels());
				}
				catch (Exception exception)
				{
					Debug.LogException(exception);
					return null;
				}
			}
			texture2D.Apply(updateMipmaps: true, !atlasInfo.readableTexture);
			return texture2D;
		}

		private static Texture2D ScaleTexture(Texture2D oldTexture, int width, int height)
		{
			Color[] pixels = oldTexture.GetPixels();
			Color[] array = new Color[width * height];
			float num = 1f / ((float)width / (float)(oldTexture.width - 1));
			float num2 = 1f / ((float)height / (float)(oldTexture.height - 1));
			int width2 = oldTexture.width;
			for (int i = 0; i < height; i++)
			{
				int num3 = Mathf.FloorToInt((float)i * num2);
				int num4 = num3 * width2;
				int num5 = (num3 + 1) * width2;
				int num6 = i * width;
				for (int j = 0; j < width; j++)
				{
					int num7 = Mathf.FloorToInt((float)j * num);
					float v = (float)j * num - (float)num7;
					ref Color reference = ref array[num6 + j];
					reference = ColorLerpUnclamped(ColorLerpUnclamped(pixels[num4 + num7], pixels[num4 + num7 + 1], v), ColorLerpUnclamped(pixels[num5 + num7], pixels[num5 + num7 + 1], v), (float)i * num2 - (float)num3);
				}
			}
			Texture2D texture2D = new Texture2D(width, height, oldTexture.format, mipmap: false);
			texture2D.SetPixels(array);
			texture2D.Apply();
			return texture2D;
		}

		private static Color ColorLerpUnclamped(Color color1, Color color2, float v)
		{
			return new Color(color1.r + (color2.r - color1.r) * v, color1.g + (color2.g - color1.g) * v, color1.b + (color2.b - color1.b) * v, color1.a + (color2.a - color1.a) * v);
		}
	}
	public struct TexturePosition
	{
		[SerializeField]
		private List<Texture2D> _textures;

		[SerializeField]
		private Rect _position;

		public IList<Texture2D> textures
		{
			get
			{
				return _textures;
			}
			set
			{
				_textures = (List<Texture2D>)value;
			}
		}

		public Rect position
		{
			get
			{
				return _position;
			}
			set
			{
				_position = value;
			}
		}
	}
}
namespace DCM.Old
{
	[Serializable]
	[Obsolete("This Class is obsolete")]
	public class ShaderProperties
	{
		public bool markAsNormal;

		public string propertyName;

		public ShaderProperties(bool normal, string name)
		{
			markAsNormal = normal;
			propertyName = name;
		}
	}
	[Serializable]
	[Obsolete("This Class is obsolete")]
	public class TextureAtlasInfo
	{
		public int anisoLevel;

		public bool compressTexturesInMemory;

		public FilterMode filterMode;

		public bool ignoreAlpha;

		public TextureWrapMode wrapMode;

		public ShaderProperties[] shaderPropertiesToLookFor;

		public TextureAtlasInfo()
		{
			anisoLevel = 1;
			compressTexturesInMemory = true;
			filterMode = FilterMode.Trilinear;
			ignoreAlpha = true;
			wrapMode = TextureWrapMode.Clamp;
			shaderPropertiesToLookFor = new ShaderProperties[6]
			{
				new ShaderProperties(normal: false, "_MainTex"),
				new ShaderProperties(normal: true, "_BumpMap"),
				new ShaderProperties(normal: false, "_Cube"),
				new ShaderProperties(normal: false, "_DecalTex"),
				new ShaderProperties(normal: false, "_Detail"),
				new ShaderProperties(normal: false, "_ParallaxMap")
			};
		}
	}
	[Obsolete("This Class is obsolete")]
	public class MeshCombineUtility
	{
		public struct MeshInstance
		{
			public Mesh mesh;

			public int subMeshIndex;

			public Matrix4x4 transform;
		}

		public static Mesh[] Combine(MeshInstance[] combines)
		{
			int num = 0;
			int num2 = 0;
			for (int i = 0; i < combines.Length; i++)
			{
				if (combines[i].mesh != null)
				{
					num += combines[i].mesh.vertexCount;
					num2 += combines[i].mesh.GetTriangles(combines[i].subMeshIndex).Length;
				}
			}
			int j = 0;
			int num3 = Mathf.CeilToInt((float)num / 60000f);
			int num4 = num / num3;
			List<Mesh> list = new List<Mesh>();
			for (int k = 1; k <= num3; k++)
			{
				List<Vector3> list2 = new List<Vector3>(num4);
				List<Vector3> list3 = new List<Vector3>(num4);
				List<Vector4> list4 = new List<Vector4>(num4);
				List<Vector2> list5 = new List<Vector2>(num4);
				List<Vector2> list6 = new List<Vector2>(num4);
				List<Vector2> list7 = new List<Vector2>(num4);
				List<Color> list8 = new List<Color>(num4);
				List<int> list9 = new List<int>(num2 / num3);
				int num5 = 0;
				for (; j < combines.Length; j++)
				{
					if (num5 > num4)
					{
						break;
					}
					if (!(combines[j].mesh != null))
					{
						continue;
					}
					Copy(combines[j].mesh.vertices, list2, combines[j].transform);
					Matrix4x4 transform = combines[j].transform;
					transform = transform.inverse.transpose;
					CopyNormal(combines[j].mesh.normals, list3, transform);
					CopyTangents(combines[j].mesh.tangents, list4, transform);
					Copy(combines[j].mesh.uv, list5);
					Copy(combines[j].mesh.uv2, list6);
					Copy(combines[j].mesh.uv2, list7);
					if (combines[j].mesh.colors.Length == combines[j].mesh.vertexCount)
					{
						CopyColors(combines[j].mesh.colors, list8);
					}
					else
					{
						Color[] array = new Color[combines[j].mesh.vertexCount];
						for (int l = 0; l < array.Length; l++)
						{
							ref Color reference = ref array[l];
							reference = Color.white;
						}
						CopyColors(array, list8);
					}
					CopyTriangles(combines[j].mesh.GetTriangles(combines[j].subMeshIndex), list9, num5);
					num5 += combines[j].mesh.vertexCount;
				}
				Mesh mesh = new Mesh();
				mesh.name = "Combined Mesh";
				mesh.vertices = list2.ToArray();
				mesh.normals = list3.ToArray();
				mesh.colors = list8.ToArray();
				mesh.uv = list5.ToArray();
				mesh.uv2 = list6.ToArray();
				mesh.uv2 = list7.ToArray();
				mesh.tangents = list4.ToArray();
				mesh.triangles = list9.ToArray();
				list.Add(mesh);
			}
			return list.ToArray();
		}

		private static void Copy(Vector3[] src, List<Vector3> dst, Matrix4x4 transform)
		{
			for (int i = 0; i < src.Length; i++)
			{
				dst.Add(transform.MultiplyPoint(src[i]));
			}
		}

		private static void CopyNormal(Vector3[] src, List<Vector3> dst, Matrix4x4 transform)
		{
			for (int i = 0; i < src.Length; i++)
			{
				dst.Add(transform.MultiplyVector(src[i]).normalized);
			}
		}

		private static void Copy(Vector2[] src, List<Vector2> dst)
		{
			for (int i = 0; i < src.Length; i++)
			{
				dst.Add(src[i]);
			}
		}

		private static void CopyColors(Color[] src, List<Color> dst)
		{
			for (int i = 0; i < src.Length; i++)
			{
				dst.Add(src[i]);
			}
		}

		private static void CopyTangents(Vector4[] src, List<Vector4> dst, Matrix4x4 transform)
		{
			for (int i = 0; i < src.Length; i++)
			{
				Vector4 vector = src[i];
				Vector3 vector2 = new Vector3(vector.x, vector.y, vector.z);
				vector2 = transform.MultiplyVector(vector2).normalized;
				dst.Add(new Vector4(vector2.x, vector2.y, vector2.z, vector.w));
			}
		}

		private static void CopyTriangles(int[] src, List<int> dst, int vertexOffset)
		{
			for (int i = 0; i < src.Length; i++)
			{
				dst.Add(src[i] + vertexOffset);
			}
		}
	}
	[Obsolete("This Class is obsolete")]
	[AddComponentMenu("Mesh/Optimized Combine Children")]
	public class OptimizedCombineChildren : MonoBehaviour
	{
		public TextureAtlasInfo textureAtlasProperties;

		private void Start()
		{
			MeshFilter[] componentsInChildren = GetComponentsInChildren<MeshFilter>();
			Matrix4x4 worldToLocalMatrix = base.transform.worldToLocalMatrix;
			Dictionary<string, Dictionary<Material, List<MeshCombineUtility.MeshInstance>>> dictionary = new Dictionary<string, Dictionary<Material, List<MeshCombineUtility.MeshInstance>>>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				Renderer component = componentsInChildren[i].GetComponent<Renderer>();
				MeshCombineUtility.MeshInstance item = default(MeshCombineUtility.MeshInstance);
				item.mesh = componentsInChildren[i].mesh;
				if (!(component != null) || !component.enabled || !(item.mesh != null))
				{
					continue;
				}
				item.transform = worldToLocalMatrix * componentsInChildren[i].transform.localToWorldMatrix;
				Material[] sharedMaterials = component.sharedMaterials;
				for (int j = 0; j < sharedMaterials.Length; j++)
				{
					item.subMeshIndex = Math.Min(j, item.mesh.subMeshCount - 1);
					if (!dictionary.ContainsKey(sharedMaterials[j].shader.ToString()))
					{
						dictionary.Add(sharedMaterials[j].shader.ToString(), new Dictionary<Material, List<MeshCombineUtility.MeshInstance>>());
					}
					if (!dictionary[sharedMaterials[j].shader.ToString()].ContainsKey(sharedMaterials[j]))
					{
						dictionary[sharedMaterials[j].shader.ToString()].Add(sharedMaterials[j], new List<MeshCombineUtility.MeshInstance>());
					}
					dictionary[sharedMaterials[j].shader.ToString()][sharedMaterials[j]].Add(item);
				}
			}
			foreach (KeyValuePair<string, Dictionary<Material, List<MeshCombineUtility.MeshInstance>>> item2 in dictionary)
			{
				Material[] array = new Material[item2.Value.Keys.Count];
				int num = 0;
				foreach (KeyValuePair<Material, List<MeshCombineUtility.MeshInstance>> item3 in item2.Value)
				{
					array[num] = item3.Key;
					num++;
				}
				TextureCombineUtility.TexturePosition[] texturePositions;
				Material material = TextureCombineUtility.combine(array, out texturePositions, textureAtlasProperties);
				if (texturePositions == null)
				{
					continue;
				}
				List<MeshCombineUtility.MeshInstance> list = new List<MeshCombineUtility.MeshInstance>();
				foreach (KeyValuePair<Material, List<MeshCombineUtility.MeshInstance>> item4 in item2.Value)
				{
					TextureCombineUtility.TexturePosition texturePosition = texturePositions[0];
					for (int k = 0; k < texturePositions.Length; k++)
					{
						if (item4.Key.mainTexture.name == texturePositions[k].textures[0].name)
						{
							texturePosition = texturePositions[k];
							break;
						}
					}
					for (int l = 0; l < item4.Value.Count; l++)
					{
						Vector2[] uv = item4.Value[l].mesh.uv;
						for (int m = 0; m < uv.Length; m++)
						{
							uv[m].x = texturePosition.position.x + uv[m].x * texturePosition.position.width;
							uv[m].y = texturePosition.position.y + uv[m].y * texturePosition.position.height;
						}
						item4.Value[l].mesh.uv = uv;
						uv = item4.Value[l].mesh.uv2;
						for (int n = 0; n < uv.Length; n++)
						{
							uv[n].x = texturePosition.position.x + uv[n].x * texturePosition.position.width;
							uv[n].y = texturePosition.position.y + uv[n].y * texturePosition.position.height;
						}
						item4.Value[l].mesh.uv2 = uv;
						uv = item4.Value[l].mesh.uv2;
						for (int num2 = 0; num2 < uv.Length; num2++)
						{
							uv[num2].x = texturePosition.position.x + uv[num2].x * texturePosition.position.width;
							uv[num2].y = texturePosition.position.y + uv[num2].y * texturePosition.position.height;
						}
						item4.Value[l].mesh.uv2 = uv;
						list.Add(item4.Value[l]);
					}
				}
				Material sharedMaterial = material;
				Mesh[] array2 = MeshCombineUtility.Combine(list.ToArray());
				GameObject gameObject = new GameObject("Combined " + base.gameObject.name + " " + item2.Key + " Mesh Parent");
				gameObject.transform.position = base.transform.position;
				gameObject.transform.rotation = base.transform.rotation;
				for (int num3 = 0; num3 < array2.Length; num3++)
				{
					GameObject gameObject2 = new GameObject("Combined " + base.gameObject.name + " Mesh");
					gameObject2.transform.parent = gameObject.transform;
					gameObject2.tag = base.gameObject.tag;
					gameObject2.layer = base.gameObject.layer;
					gameObject2.transform.localScale = Vector3.one;
					gameObject2.transform.localRotation = Quaternion.identity;
					gameObject2.transform.localPosition = Vector3.zero;
					MeshFilter meshFilter = gameObject2.AddComponent<MeshFilter>();
					gameObject2.AddComponent<MeshRenderer>();
					gameObject2.GetComponent<Renderer>().sharedMaterial = sharedMaterial;
					meshFilter.mesh = array2[num3];
				}
			}
			MeshFilter[] array3 = componentsInChildren;
			foreach (MeshFilter obj in array3)
			{
				UnityEngine.Object.Destroy(obj);
			}
			Renderer[] componentsInChildren2 = GetComponentsInChildren<Renderer>();
			foreach (Renderer renderer in componentsInChildren2)
			{
				renderer.enabled = false;
			}
		}
	}
	[Obsolete("This Class is obsolete")]
	public class TextureCombineUtility
	{
		public struct TexturePosition
		{
			public Texture2D[] textures;

			public Rect position;
		}

		public static Material combine(Material[] combines, out TexturePosition[] texturePositions, TextureAtlasInfo atlasInfo)
		{
			if (atlasInfo == null)
			{
				Debug.LogError("atlasInfo is null. Try removing and reattaching combine children component");
				texturePositions = null;
				return null;
			}
			if (atlasInfo.shaderPropertiesToLookFor.Length <= 0)
			{
				Debug.LogError("You need to enter some shader properties to look for into Atlas Info. Cannot combine with 0 properties");
				texturePositions = null;
				return null;
			}
			List<ShaderProperties> list = new List<ShaderProperties>();
			for (int i = 0; i < atlasInfo.shaderPropertiesToLookFor.Length; i++)
			{
				if (combines[0].HasProperty(atlasInfo.shaderPropertiesToLookFor[i].propertyName))
				{
					list.Add(atlasInfo.shaderPropertiesToLookFor[i]);
				}
			}
			texturePositions = new TexturePosition[combines.Length];
			for (int j = 0; j < combines.Length; j++)
			{
				TexturePosition texturePosition = default(TexturePosition);
				texturePosition.textures = new Texture2D[list.Count];
				for (int k = 0; k < list.Count; k++)
				{
					if (combines[j].GetTexture(list[k].propertyName) == null)
					{
						Debug.LogError("Cannot combine textures when using Unity's default material texture");
						texturePositions = null;
						return null;
					}
					texturePosition.textures[k] = UnityEngine.Object.Instantiate(combines[j].GetTexture(list[k].propertyName)) as Texture2D;
					texturePosition.textures[k].name = texturePosition.textures[k].name.Remove(texturePosition.textures[k].name.IndexOf("(Clone)", StringComparison.Ordinal));
				}
				texturePositions[j] = texturePosition;
			}
			textureQuickSort(texturePositions, 0, texturePositions.Length - 1);
			for (int l = 0; l < texturePositions.Length; l++)
			{
				for (int m = 1; m < texturePositions[l].textures.Length; m++)
				{
					texturePositions[l].textures[m] = scaleTexture(texturePositions[l].textures[m], texturePositions[l].textures[0].width, texturePositions[l].textures[0].height);
				}
			}
			ref Rect position = ref texturePositions[0].position;
			float num = 0f;
			texturePositions[0].position.y = num;
			position.x = num;
			texturePositions[0].position.width = texturePositions[0].textures[0].width;
			texturePositions[0].position.height = texturePositions[0].textures[0].height;
			int num2 = texturePositions[0].textures[0].height;
			int num3 = texturePositions[0].textures[0].width;
			int num4 = num3;
			int num5 = 0;
			bool flag = true;
			for (int n = 1; n < texturePositions.Length; n++)
			{
				texturePositions[n].position.x = num4;
				texturePositions[n].position.y = num5;
				texturePositions[n].position.width = texturePositions[n].textures[0].width;
				texturePositions[n].position.height = texturePositions[n].textures[0].height;
				if (flag)
				{
					if (num4 + texturePositions[n].textures[0].width > num3)
					{
						num3 = num4 + texturePositions[n].textures[0].width;
					}
					num5 += texturePositions[n].textures[0].height;
					if (num5 >= num2)
					{
						flag = false;
						num2 = num5;
						num5 = num2;
						num4 = 0;
					}
				}
				else
				{
					if (num5 + texturePositions[n].textures[0].height > num2)
					{
						num2 = num5 + texturePositions[n].textures[0].height;
					}
					num4 += texturePositions[n].textures[0].width;
					if (num4 >= num3)
					{
						flag = true;
						num3 = num4;
						num4 = num3;
						num5 = 0;
					}
				}
			}
			if (num2 > num3)
			{
				num3 = num2;
			}
			else
			{
				num2 = num3;
			}
			float num6 = 1f / (float)num2;
			Material material = new Material(combines[0]);
			for (int num7 = 0; num7 < list.Count; num7++)
			{
				Texture2D texture2D = new Texture2D(num3, num2, (!atlasInfo.ignoreAlpha || list[num7].markAsNormal) ? TextureFormat.ARGB32 : TextureFormat.RGB24, mipmap: true);
				texture2D.anisoLevel = atlasInfo.anisoLevel;
				texture2D.filterMode = atlasInfo.filterMode;
				texture2D.wrapMode = atlasInfo.wrapMode;
				for (int num8 = 0; num8 < texturePositions.Length; num8++)
				{
					texture2D.SetPixels((int)texturePositions[num8].position.x, (int)texturePositions[num8].position.y, texturePositions[num8].textures[num7].width, texturePositions[num8].textures[num7].height, texturePositions[num8].textures[num7].GetPixels());
				}
				texture2D.Apply();
				if (atlasInfo.compressTexturesInMemory)
				{
					texture2D.Compress(highQuality: true);
				}
				material.SetTexture(list[num7].propertyName, texture2D);
			}
			for (int num9 = 0; num9 < texturePositions.Length; num9++)
			{
				texturePositions[num9].position.x = texturePositions[num9].position.x * num6;
				texturePositions[num9].position.y = texturePositions[num9].position.y * num6;
				texturePositions[num9].position.width = texturePositions[num9].position.width * num6;
				texturePositions[num9].position.height = texturePositions[num9].position.height * num6;
			}
			return material;
		}

		private static void textureQuickSort(TexturePosition[] textures, int low, int high)
		{
			if (low < high)
			{
				int num = partition(textures, low, high);
				textureQuickSort(textures, low, num - 1);
				textureQuickSort(textures, num + 1, high);
			}
		}

		private static int partition(TexturePosition[] texturePositions, int low, int high)
		{
			int num = low;
			TexturePosition texturePosition = texturePositions[num];
			for (int i = low + 1; i <= high; i++)
			{
				if (texturePositions[i].textures[0].height > texturePosition.textures[0].height)
				{
					num++;
					swap(texturePositions, num, i);
				}
			}
			swap(texturePositions, low, num);
			return num;
		}

		private static void swap(TexturePosition[] textures, int i, int j)
		{
			TexturePosition texturePosition = textures[i];
			ref TexturePosition reference = ref textures[i];
			reference = textures[j];
			textures[j] = texturePosition;
		}

		private static Texture2D scaleTexture(Texture2D oldTexture, int width, int height)
		{
			Color[] pixels = oldTexture.GetPixels();
			Color[] array = new Color[width * height];
			float num = 1f / ((float)width / (float)(oldTexture.width - 1));
			float num2 = 1f / ((float)height / (float)(oldTexture.height - 1));
			int width2 = oldTexture.width;
			for (int i = 0; i < height; i++)
			{
				int num3 = Mathf.FloorToInt((float)i * num2);
				int num4 = num3 * width2;
				int num5 = (num3 + 1) * width2;
				int num6 = i * width;
				for (int j = 0; j < width; j++)
				{
					int num7 = Mathf.FloorToInt((float)j * num);
					float v = (float)j * num - (float)num7;
					ref Color reference = ref array[num6 + j];
					reference = colorLerpUnclamped(colorLerpUnclamped(pixels[num4 + num7], pixels[num4 + num7 + 1], v), colorLerpUnclamped(pixels[num5 + num7], pixels[num5 + num7 + 1], v), (float)i * num2 - (float)num3);
				}
			}
			Texture2D texture2D = new Texture2D(width, height, oldTexture.format, mipmap: false);
			texture2D.SetPixels(array);
			texture2D.Apply();
			return texture2D;
		}

		private static Color colorLerpUnclamped(Color color1, Color color2, float v)
		{
			return new Color(color1.r + (color2.r - color1.r) * v, color1.g + (color2.g - color1.g) * v, color1.b + (color2.b - color1.b) * v, color1.a + (color2.a - color1.a) * v);
		}
	}
}
public class IOCcam : MonoBehaviour
{
	public LayerMask layerMsk;

	public string iocTag;

	public int samples;

	public float raysFov;

	public bool preCullCheck;

	public float viewDistance;

	public int hideDelay;

	public bool realtimeShadows;

	public float lod1Distance;

	public float lod2Distance;

	public float lodMargin;

	private RaycastHit hit;

	private Ray r;

	private int layerMask;

	private IOClod l;

	private int haltonIndex;

	private float[] hx;

	private float[] hy;

	private int pixels;

	private Camera cam;

	private Camera rayCaster;

	private void Awake()
	{
		cam = GetComponent<Camera>();
		hit = default(RaycastHit);
		if (viewDistance == 0f)
		{
			viewDistance = 100f;
		}
		cam.farClipPlane = viewDistance;
		haltonIndex = 0;
		if (GetComponent<SphereCollider>() == null)
		{
			SphereCollider sphereCollider = base.gameObject.AddComponent<SphereCollider>();
			sphereCollider.radius = 1f;
			sphereCollider.isTrigger = true;
		}
	}

	private void Start()
	{
		pixels = Mathf.FloorToInt((float)(Screen.width * Screen.height) / 4f);
		hx = new float[pixels];
		hy = new float[pixels];
		for (int i = 0; i < pixels; i++)
		{
			hx[i] = HaltonSequence(i, 2);
			hy[i] = HaltonSequence(i, 3);
		}
		UnityEngine.Object[] array = UnityEngine.Object.FindObjectsOfType(typeof(GameObject));
		for (int j = 0; j < array.Length; j++)
		{
			GameObject gameObject = (GameObject)array[j];
			if (gameObject.tag == iocTag && gameObject.GetComponent<IOClod>() == null)
			{
				gameObject.AddComponent<IOClod>();
			}
		}
		GameObject gameObject2 = new GameObject("RayCaster");
		gameObject2.transform.Translate(base.transform.position);
		gameObject2.transform.rotation = base.transform.rotation;
		rayCaster = gameObject2.AddComponent<Camera>();
		rayCaster.enabled = false;
		rayCaster.clearFlags = CameraClearFlags.Nothing;
		rayCaster.cullingMask = 0;
		rayCaster.aspect = cam.aspect;
		rayCaster.nearClipPlane = cam.nearClipPlane;
		rayCaster.farClipPlane = cam.farClipPlane;
		rayCaster.fieldOfView = raysFov;
		gameObject2.transform.parent = base.transform;
	}

	private void Update()
	{
		for (int i = 0; i <= samples; i++)
		{
			r = rayCaster.ViewportPointToRay(new Vector3(hx[haltonIndex], hy[haltonIndex], 0f));
			haltonIndex++;
			if (haltonIndex >= pixels)
			{
				haltonIndex = 0;
			}
			if (Physics.Raycast(r, out hit, viewDistance, layerMsk.value))
			{
				if ((bool)(l = hit.transform.GetComponent<IOClod>()))
				{
					l.UnHide(hit);
				}
				else if ((bool)(l = hit.transform.parent.GetComponent<IOClod>()))
				{
					l.UnHide(hit);
				}
			}
		}
	}

	private float HaltonSequence(int index, int b)
	{
		float num = 0f;
		float num2 = 1f / (float)b;
		int num3 = index;
		while (num3 > 0)
		{
			num += num2 * (float)(num3 % b);
			num3 = Mathf.FloorToInt(num3 / b);
			num2 /= (float)b;
		}
		return num;
	}
}
public class IOClod : MonoBehaviour
{
	public float Lod1;

	public float Lod2;

	public float LodMargin;

	public bool LodOnly;

	private Vector3 hitPoint;

	private float lod_1;

	private float lod_2;

	private float lodMargin;

	private bool realtimeShadows;

	private IOCcam iocCam;

	private int counter;

	private Renderer[] rs0;

	private Renderer[] rs1;

	private Renderer[] rs2;

	private Renderer[] rs;

	private bool hidden;

	private int currentLod;

	private float prevDist;

	private float distOffset;

	private int lods;

	private float dt;

	private float hitTimeOffset;

	private float prevHitTime;

	private bool sleeping;

	private Shader shInvisible;

	private Shader[][] sh;

	private Shader[][] sh0;

	private float distanceFromCam;

	private float shadowDistance;

	private int frameInterval;

	private RaycastHit h;

	private Ray r;

	private bool visible;

	private void Awake()
	{
		shadowDistance = QualitySettings.shadowDistance * 2f;
		iocCam = Camera.main.GetComponent<IOCcam>();
		if (iocCam == null)
		{
			base.enabled = false;
			return;
		}
		prevDist = 0f;
		prevHitTime = Time.time;
		sleeping = true;
		h = default(RaycastHit);
	}

	private void Start()
	{
		UpdateValues();
		if ((bool)base.transform.Find("Lod_0"))
		{
			lods = 1;
			rs0 = base.transform.Find("Lod_0").GetComponentsInChildren<Renderer>(includeInactive: false);
			sh0 = new Shader[rs0.Length][];
			for (int i = 0; i < rs0.Length; i++)
			{
				sh0[i] = new Shader[rs0[i].materials.Length];
				for (int j = 0; j < rs0[i].materials.Length; j++)
				{
					sh0[i][j] = rs0[i].materials[j].shader;
				}
			}
			if ((bool)base.transform.Find("Lod_1"))
			{
				lods++;
				rs1 = base.transform.Find("Lod_1").GetComponentsInChildren<Renderer>(includeInactive: false);
				if ((bool)base.transform.Find("Lod_2"))
				{
					lods++;
					rs2 = base.transform.Find("Lod_2").GetComponentsInChildren<Renderer>(includeInactive: false);
				}
			}
		}
		else
		{
			lods = 0;
		}
		rs = GetComponentsInChildren<Renderer>(includeInactive: false);
		sh = new Shader[rs.Length][];
		for (int k = 0; k < rs.Length; k++)
		{
			sh[k] = new Shader[rs[k].materials.Length];
			for (int l = 0; l < rs[k].materials.Length; l++)
			{
				sh[k][l] = rs[k].materials[l].shader;
			}
		}
		shInvisible = Shader.Find("Custom/Invisible");
		Initialize();
	}

	public void Initialize()
	{
		if (iocCam.enabled)
		{
			HideAll();
			return;
		}
		base.enabled = false;
		ShowLod(1f);
	}

	private void Update()
	{
		frameInterval = Time.frameCount % 4;
		if (frameInterval == 0)
		{
			switch (LodOnly)
			{
			case false:
				if (hidden || Time.frameCount - counter <= iocCam.hideDelay)
				{
					break;
				}
				switch (currentLod)
				{
				case 0:
					visible = rs0[0].isVisible;
					break;
				case 1:
					visible = rs1[0].isVisible;
					break;
				case 2:
					visible = rs2[0].isVisible;
					break;
				default:
					visible = rs[0].isVisible;
					break;
				}
				if (iocCam.preCullCheck && visible)
				{
					Vector3 vector = base.transform.localToWorldMatrix.MultiplyPoint(hitPoint);
					r = new Ray(vector, iocCam.transform.position - vector);
					if (Physics.Raycast(r, out h, iocCam.viewDistance))
					{
						if (h.transform.tag != iocCam.tag)
						{
							Hide();
						}
						else
						{
							counter = Time.frameCount;
						}
					}
				}
				else
				{
					Hide();
				}
				break;
			case true:
				if (!sleeping && Time.frameCount - counter > iocCam.hideDelay)
				{
					ShowLod(3000f);
					sleeping = true;
				}
				break;
			}
		}
		else
		{
			if (!realtimeShadows || frameInterval != 2)
			{
				return;
			}
			distanceFromCam = Vector3.Distance(base.transform.position, iocCam.transform.position);
			if (!hidden)
			{
				return;
			}
			if (lods == 0)
			{
				if (distanceFromCam > shadowDistance)
				{
					if (!rs[0].enabled)
					{
						return;
					}
					for (int i = 0; i < rs.Length; i++)
					{
						rs[i].enabled = false;
						for (int j = 0; j < rs[i].materials.Length; j++)
						{
							rs[i].materials[j].shader = sh[i][j];
						}
					}
				}
				else
				{
					if (rs[0].enabled)
					{
						return;
					}
					for (int k = 0; k < rs.Length; k++)
					{
						Material[] materials = rs[k].materials;
						foreach (Material material in materials)
						{
							material.shader = shInvisible;
						}
						rs[k].enabled = true;
					}
				}
			}
			else if (distanceFromCam > shadowDistance)
			{
				if (!rs0[0].enabled)
				{
					return;
				}
				for (int m = 0; m < rs0.Length; m++)
				{
					rs0[m].enabled = false;
					for (int n = 0; n < rs0[m].materials.Length; n++)
					{
						rs0[m].materials[n].shader = sh0[m][n];
					}
				}
			}
			else
			{
				if (rs0[0].enabled)
				{
					return;
				}
				for (int num = 0; num < rs0.Length; num++)
				{
					Material[] materials2 = rs0[num].materials;
					foreach (Material material2 in materials2)
					{
						material2.shader = shInvisible;
					}
					rs0[num].enabled = true;
				}
			}
		}
	}

	public void UpdateValues()
	{
		if (Lod1 != 0f)
		{
			lod_1 = Lod1;
		}
		else
		{
			lod_1 = iocCam.lod1Distance;
		}
		if (Lod2 != 0f)
		{
			lod_2 = Lod2;
		}
		else
		{
			lod_2 = iocCam.lod2Distance;
		}
		if (LodMargin != 0f)
		{
			lodMargin = LodMargin;
		}
		else
		{
			lodMargin = iocCam.lodMargin;
		}
		realtimeShadows = iocCam.realtimeShadows;
	}

	public void UnHide(RaycastHit h)
	{
		counter = Time.frameCount;
		hitPoint = base.transform.worldToLocalMatrix.MultiplyPoint(h.point);
		if (hidden)
		{
			hidden = false;
			ShowLod(h.distance);
		}
		else if (lods > 0)
		{
			distOffset = prevDist - h.distance;
			hitTimeOffset = Time.time - prevHitTime;
			prevHitTime = Time.time;
			if ((Mathf.Abs(distOffset) > lodMargin) | (hitTimeOffset > 1f))
			{
				ShowLod(h.distance);
				prevDist = h.distance;
				sleeping = false;
			}
		}
	}

	public void ShowLod(float d)
	{
		int num = 0;
		switch (lods)
		{
		case 0:
			currentLod = -1;
			break;
		case 2:
			if (d < lod_1)
			{
				currentLod = 0;
			}
			else
			{
				currentLod = 1;
			}
			break;
		case 3:
			if (d < lod_1)
			{
				currentLod = 0;
			}
			else if ((d > lod_1) & (d < lod_2))
			{
				currentLod = 1;
			}
			else
			{
				currentLod = 2;
			}
			break;
		}
		switch (currentLod)
		{
		case 0:
			if (!LodOnly && rs0[0].enabled)
			{
				for (num = 0; num < rs0.Length; num++)
				{
					for (int k = 0; k < rs0[num].materials.Length; k++)
					{
						rs0[num].materials[k].shader = sh0[num][k];
					}
				}
			}
			else
			{
				for (num = 0; num < rs0.Length; num++)
				{
					rs0[num].enabled = true;
				}
			}
			for (num = 0; num < rs1.Length; num++)
			{
				rs1[num].enabled = false;
			}
			if (lods == 3)
			{
				for (num = 0; num < rs2.Length; num++)
				{
					rs2[num].enabled = false;
				}
			}
			return;
		case 1:
			for (num = 0; num < rs1.Length; num++)
			{
				rs1[num].enabled = true;
			}
			for (num = 0; num < rs0.Length; num++)
			{
				rs0[num].enabled = false;
				if (!LodOnly && realtimeShadows)
				{
					for (int i = 0; i < rs0[num].materials.Length; i++)
					{
						rs0[num].materials[i].shader = sh0[num][i];
					}
				}
			}
			if (lods == 3)
			{
				for (num = 0; num < rs2.Length; num++)
				{
					rs2[num].enabled = false;
				}
			}
			return;
		case 2:
			for (num = 0; num < rs2.Length; num++)
			{
				rs2[num].enabled = true;
			}
			for (num = 0; num < rs0.Length; num++)
			{
				rs0[num].enabled = false;
				if (!LodOnly && realtimeShadows)
				{
					for (int j = 0; j < rs0[num].materials.Length; j++)
					{
						rs0[num].materials[j].shader = sh0[num][j];
					}
				}
			}
			for (num = 0; num < rs1.Length; num++)
			{
				rs1[num].enabled = false;
			}
			return;
		}
		if (!LodOnly && rs[0].enabled)
		{
			for (num = 0; num < rs.Length; num++)
			{
				for (int l = 0; l < rs[num].materials.Length; l++)
				{
					rs[num].materials[l].shader = sh[num][l];
				}
			}
		}
		else
		{
			for (num = 0; num < rs.Length; num++)
			{
				rs[num].enabled = true;
			}
		}
	}

	public void Hide()
	{
		int num = 0;
		hidden = true;
		switch (currentLod)
		{
		case 0:
			if (realtimeShadows && distanceFromCam <= shadowDistance)
			{
				for (num = 0; num < rs0.Length; num++)
				{
					Material[] materials = rs0[num].materials;
					foreach (Material material in materials)
					{
						material.shader = shInvisible;
					}
				}
			}
			else
			{
				for (num = 0; num < rs0.Length; num++)
				{
					rs0[num].enabled = false;
				}
			}
			return;
		case 1:
			for (num = 0; num < rs1.Length; num++)
			{
				rs1[num].enabled = false;
			}
			return;
		case 2:
			for (num = 0; num < rs2.Length; num++)
			{
				rs2[num].enabled = false;
			}
			return;
		}
		if (realtimeShadows && distanceFromCam <= shadowDistance)
		{
			for (num = 0; num < rs.Length; num++)
			{
				Material[] materials2 = rs[num].materials;
				foreach (Material material2 in materials2)
				{
					material2.shader = shInvisible;
				}
			}
		}
		else
		{
			for (num = 0; num < rs.Length; num++)
			{
				rs[num].enabled = false;
			}
		}
	}

	public void HideAll()
	{
		int num = 0;
		switch (LodOnly)
		{
		case false:
			hidden = true;
			if (lods == 0 && rs != null)
			{
				for (num = 0; num < rs.Length; num++)
				{
					rs[num].enabled = false;
					if (realtimeShadows)
					{
						for (int i = 0; i < rs[num].materials.Length; i++)
						{
							rs[num].materials[i].shader = sh[num][i];
						}
					}
				}
				break;
			}
			for (num = 0; num < rs0.Length; num++)
			{
				rs0[num].enabled = false;
				if (realtimeShadows)
				{
					for (int j = 0; j < rs0[num].materials.Length; j++)
					{
						rs0[num].materials[j].shader = sh0[num][j];
					}
				}
			}
			for (num = 0; num < rs1.Length; num++)
			{
				rs1[num].enabled = false;
			}
			if (rs2 != null)
			{
				for (num = 0; num < rs2.Length; num++)
				{
					rs2[num].enabled = false;
				}
			}
			break;
		case true:
			prevHitTime -= 3f;
			ShowLod(3000f);
			break;
		}
	}
}
public class IOChud : MonoBehaviour
{
	private Texture2D Icon;

	private bool iocActive;

	private IOCcam ioc;

	private bool realtimeShadows;

	private bool hud;

	private bool dirty;

	private void Awake()
	{
		Icon = (Texture2D)Resources.Load("Icon");
		hud = false;
		dirty = false;
	}

	private void Start()
	{
		ioc = Camera.main.transform.GetComponent<IOCcam>();
		iocActive = ioc.enabled;
	}

	private void Update()
	{
		if (Input.GetKeyUp(KeyCode.I))
		{
			iocActive = !iocActive;
			ToggleIOC();
		}
		if (Input.GetKeyUp(KeyCode.Escape))
		{
			ToggleHUD();
		}
		if (Input.GetMouseButtonUp(0) && dirty)
		{
			ToggleIOC();
			dirty = false;
		}
	}

	private void OnGUI()
	{
		GUI.Label(new Rect(25f, 10f, 360f, 20f), "Press 'i' to toggle InstantOC - Press 'Esc' to toggle HUD");
		if (hud)
		{
			GUI.Label(new Rect(25f, 35f, 320f, 20f), "Samples");
			ioc.samples = Mathf.RoundToInt(GUI.HorizontalSlider(new Rect(25f, 55f, 150f, 20f), ioc.samples, 10f, 1500f));
			GUI.Label(new Rect(180f, 50f, 50f, 20f), ioc.samples.ToString());
			GUI.Label(new Rect(25f, 65f, 320f, 20f), "Hide delay");
			ioc.hideDelay = Mathf.RoundToInt(GUI.HorizontalSlider(new Rect(25f, 85f, 150f, 20f), ioc.hideDelay, 10f, 300f));
			GUI.Label(new Rect(180f, 80f, 50f, 20f), ioc.hideDelay.ToString());
			GUI.Label(new Rect(25f, 95f, 320f, 20f), "View Distance");
			ioc.viewDistance = Mathf.RoundToInt(GUI.HorizontalSlider(new Rect(25f, 115f, 150f, 20f), ioc.viewDistance, 100f, 3000f));
			GUI.Label(new Rect(180f, 110f, 50f, 20f), ioc.viewDistance.ToString());
			GUI.Label(new Rect(25f, 125f, 320f, 20f), "Lod 1");
			ioc.lod1Distance = Mathf.Round(GUI.HorizontalSlider(new Rect(25f, 145f, 150f, 20f), ioc.lod1Distance, 10f, 300f));
			GUI.Label(new Rect(180f, 140f, 50f, 20f), ioc.lod1Distance.ToString());
			GUI.Label(new Rect(25f, 155f, 320f, 20f), "Lod 2");
			ioc.lod2Distance = Mathf.Round(GUI.HorizontalSlider(new Rect(25f, 175f, 150f, 20f), ioc.lod2Distance, 10f, 600f));
			GUI.Label(new Rect(180f, 170f, 50f, 20f), ioc.lod2Distance.ToString());
			GUI.Label(new Rect(25f, 185f, 320f, 20f), "Lod margin");
			ioc.lodMargin = Mathf.Round(GUI.HorizontalSlider(new Rect(25f, 205f, 150f, 20f), ioc.lodMargin, 1f, 100f));
			GUI.Label(new Rect(180f, 200f, 50f, 20f), ioc.lodMargin.ToString());
		}
		if (iocActive)
		{
			GUI.Label(new Rect((float)Screen.width - 74f, 10f, 64f, 64f), Icon);
		}
		if (GUI.changed)
		{
			dirty = true;
		}
	}

	private void ToggleHUD()
	{
		hud = !hud;
		try
		{
			ioc.GetComponent<MouseLook>().enabled = !ioc.GetComponent<MouseLook>().enabled;
			ioc.transform.parent.GetComponent<MouseLook>().enabled = !ioc.transform.parent.GetComponent<MouseLook>().enabled;
		}
		catch
		{
		}
	}

	private void ToggleIOC()
	{
		ioc.enabled = iocActive;
		GameObject[] array = UnityEngine.Object.FindObjectsOfType(typeof(GameObject)) as GameObject[];
		GameObject[] array2 = array;
		foreach (GameObject gameObject in array2)
		{
			IOClod component = gameObject.GetComponent<IOClod>();
			if (component != null)
			{
				switch (iocActive)
				{
				case true:
					component.UpdateValues();
					component.Initialize();
					component.enabled = true;
					break;
				case false:
					component.enabled = false;
					component.UpdateValues();
					component.Initialize();
					break;
				}
			}
		}
	}
}
public class iTween : MonoBehaviour
{
	private delegate float EasingFunction(float start, float end, float value);

	private delegate void ApplyTween();

	public enum EaseType
	{
		easeInQuad,
		easeOutQuad,
		easeInOutQuad,
		easeInCubic,
		easeOutCubic,
		easeInOutCubic,
		easeInQuart,
		easeOutQuart,
		easeInOutQuart,
		easeInQuint,
		easeOutQuint,
		easeInOutQuint,
		easeInSine,
		easeOutSine,
		easeInOutSine,
		easeInExpo,
		easeOutExpo,
		easeInOutExpo,
		easeInCirc,
		easeOutCirc,
		easeInOutCirc,
		linear,
		spring,
		easeInBounce,
		easeOutBounce,
		easeInOutBounce,
		easeInBack,
		easeOutBack,
		easeInOutBack,
		easeInElastic,
		easeOutElastic,
		easeInOutElastic,
		punch
	}

	public enum LoopType
	{
		none,
		loop,
		pingPong
	}

	public enum NamedValueColor
	{
		_Color,
		_SpecColor,
		_Emission,
		_ReflectColor
	}

	public static class Defaults
	{
		public static float time = 1f;

		public static float delay = 0f;

		public static NamedValueColor namedColorValue = NamedValueColor._Color;

		public static LoopType loopType = LoopType.none;

		public static EaseType easeType = EaseType.easeOutExpo;

		public static float lookSpeed = 3f;

		public static bool isLocal = false;

		public static Space space = Space.Self;

		public static bool orientToPath = false;

		public static Color color = Color.white;

		public static float updateTimePercentage = 0.05f;

		public static float updateTime = 1f * updateTimePercentage;

		public static int cameraFadeDepth = 999999;

		public static float lookAhead = 0.05f;

		public static bool useRealTime = false;

		public static Vector3 up = Vector3.up;
	}

	private class CRSpline
	{
		public Vector3[] pts;

		public CRSpline(params Vector3[] pts)
		{
			this.pts = new Vector3[pts.Length];
			Array.Copy(pts, this.pts, pts.Length);
		}

		public Vector3 Interp(float t)
		{
			int num = pts.Length - 3;
			int num2 = Mathf.Min(Mathf.FloorToInt(t * (float)num), num - 1);
			float num3 = t * (float)num - (float)num2;
			Vector3 vector = pts[num2];
			Vector3 vector2 = pts[num2 + 1];
			Vector3 vector3 = pts[num2 + 2];
			Vector3 vector4 = pts[num2 + 3];
			return 0.5f * ((-vector + 3f * vector2 - 3f * vector3 + vector4) * (num3 * num3 * num3) + (2f * vector - 5f * vector2 + 4f * vector3 - vector4) * (num3 * num3) + (-vector + vector3) * num3 + 2f * vector2);
		}
	}

	public static ArrayList tweens = new ArrayList();

	private static GameObject cameraFade;

	public string id;

	public string type;

	public string method;

	public EaseType easeType;

	public float time;

	public float delay;

	public LoopType loopType;

	public bool isRunning;

	public bool isPaused;

	public string _name;

	private float runningTime;

	private float percentage;

	private float delayStarted;

	private bool kinematic;

	private bool isLocal;

	private bool loop;

	private bool reverse;

	private bool wasPaused;

	private bool physics;

	private Hashtable tweenArguments;

	private Space space;

	private EasingFunction ease;

	private ApplyTween apply;

	private AudioSource audioSource;

	private Vector3[] vector3s;

	private Vector2[] vector2s;

	private Color[,] colors;

	private float[] floats;

	private Rect[] rects;

	private CRSpline path;

	private Vector3 preUpdate;

	private Vector3 postUpdate;

	private NamedValueColor namedcolorvalue;

	private float lastRealTime;

	private bool useRealTime;

	public static void Init(GameObject target)
	{
		MoveBy(target, Vector3.zero, 0f);
	}

	public static void CameraFadeFrom(float amount, float time)
	{
		if ((bool)cameraFade)
		{
			CameraFadeFrom(Hash("amount", amount, "time", time));
		}
		else
		{
			Debug.LogError("iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.");
		}
	}

	public static void CameraFadeFrom(Hashtable args)
	{
		if ((bool)cameraFade)
		{
			ColorFrom(cameraFade, args);
		}
		else
		{
			Debug.LogError("iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.");
		}
	}

	public static void CameraFadeTo(float amount, float time)
	{
		if ((bool)cameraFade)
		{
			CameraFadeTo(Hash("amount", amount, "time", time));
		}
		else
		{
			Debug.LogError("iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.");
		}
	}

	public static void CameraFadeTo(Hashtable args)
	{
		if ((bool)cameraFade)
		{
			ColorTo(cameraFade, args);
		}
		else
		{
			Debug.LogError("iTween Error: You must first add a camera fade object with CameraFadeAdd() before atttempting to use camera fading.");
		}
	}

	public static void ValueTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (!args.Contains("onupdate") || !args.Contains("from") || !args.Contains("to"))
		{
			Debug.LogError("iTween Error: ValueTo() requires an 'onupdate' callback function and a 'from' and 'to' property.  The supplied 'onupdate' callback must accept a single argument that is the same type as the supplied 'from' and 'to' properties!");
			return;
		}
		args["type"] = "value";
		if (args["from"].GetType() == typeof(Vector2))
		{
			args["method"] = "vector2";
		}
		else if (args["from"].GetType() == typeof(Vector3))
		{
			args["method"] = "vector3";
		}
		else if (args["from"].GetType() == typeof(Rect))
		{
			args["method"] = "rect";
		}
		else if (args["from"].GetType() == typeof(float))
		{
			args["method"] = "float";
		}
		else
		{
			if (args["from"].GetType() != typeof(Color))
			{
				Debug.LogError("iTween Error: ValueTo() only works with interpolating Vector3s, Vector2s, floats, ints, Rects and Colors!");
				return;
			}
			args["method"] = "color";
		}
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		Launch(target, args);
	}

	public static void FadeFrom(GameObject target, float alpha, float time)
	{
		FadeFrom(target, Hash("alpha", alpha, "time", time));
	}

	public static void FadeFrom(GameObject target, Hashtable args)
	{
		ColorFrom(target, args);
	}

	public static void FadeTo(GameObject target, float alpha, float time)
	{
		FadeTo(target, Hash("alpha", alpha, "time", time));
	}

	public static void FadeTo(GameObject target, Hashtable args)
	{
		ColorTo(target, args);
	}

	public static void ColorFrom(GameObject target, Color color, float time)
	{
		ColorFrom(target, Hash("color", color, "time", time));
	}

	public static void ColorFrom(GameObject target, Hashtable args)
	{
		Color color = default(Color);
		Color color2 = default(Color);
		args = CleanArgs(args);
		if (!args.Contains("includechildren") || (bool)args["includechildren"])
		{
			foreach (Transform item in target.transform)
			{
				Hashtable hashtable = (Hashtable)args.Clone();
				hashtable["ischild"] = true;
				ColorFrom(item.gameObject, hashtable);
			}
		}
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		if ((bool)target.GetComponent(typeof(GUITexture)))
		{
			color2 = (color = target.GetComponent<GUITexture>().color);
		}
		else if ((bool)target.GetComponent(typeof(GUIText)))
		{
			color2 = (color = target.GetComponent<GUIText>().material.color);
		}
		else if ((bool)target.GetComponent<Renderer>())
		{
			color2 = (color = target.GetComponent<Renderer>().material.color);
		}
		else if ((bool)target.GetComponent<Light>())
		{
			color2 = (color = target.GetComponent<Light>().color);
		}
		if (args.Contains("color"))
		{
			color = (Color)args["color"];
		}
		else
		{
			if (args.Contains("r"))
			{
				color.r = (float)args["r"];
			}
			if (args.Contains("g"))
			{
				color.g = (float)args["g"];
			}
			if (args.Contains("b"))
			{
				color.b = (float)args["b"];
			}
			if (args.Contains("a"))
			{
				color.a = (float)args["a"];
			}
		}
		if (args.Contains("amount"))
		{
			color.a = (float)args["amount"];
			args.Remove("amount");
		}
		else if (args.Contains("alpha"))
		{
			color.a = (float)args["alpha"];
			args.Remove("alpha");
		}
		if ((bool)target.GetComponent(typeof(GUITexture)))
		{
			target.GetComponent<GUITexture>().color = color;
		}
		else if ((bool)target.GetComponent(typeof(GUIText)))
		{
			target.GetComponent<GUIText>().material.color = color;
		}
		else if ((bool)target.GetComponent<Renderer>())
		{
			target.GetComponent<Renderer>().material.color = color;
		}
		else if ((bool)target.GetComponent<Light>())
		{
			target.GetComponent<Light>().color = color;
		}
		args["color"] = color2;
		args["type"] = "color";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void ColorTo(GameObject target, Color color, float time)
	{
		ColorTo(target, Hash("color", color, "time", time));
	}

	public static void ColorTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (!args.Contains("includechildren") || (bool)args["includechildren"])
		{
			foreach (Transform item in target.transform)
			{
				Hashtable hashtable = (Hashtable)args.Clone();
				hashtable["ischild"] = true;
				ColorTo(item.gameObject, hashtable);
			}
		}
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		args["type"] = "color";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void AudioFrom(GameObject target, float volume, float pitch, float time)
	{
		AudioFrom(target, Hash("volume", volume, "pitch", pitch, "time", time));
	}

	public static void AudioFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		AudioSource audioSource;
		if (args.Contains("audiosource"))
		{
			audioSource = (AudioSource)args["audiosource"];
		}
		else
		{
			if (!target.GetComponent(typeof(AudioSource)))
			{
				Debug.LogError("iTween Error: AudioFrom requires an AudioSource.");
				return;
			}
			audioSource = target.GetComponent<AudioSource>();
		}
		Vector2 vector = default(Vector2);
		Vector2 vector2 = default(Vector2);
		vector.x = (vector2.x = audioSource.volume);
		vector.y = (vector2.y = audioSource.pitch);
		if (args.Contains("volume"))
		{
			vector2.x = (float)args["volume"];
		}
		if (args.Contains("pitch"))
		{
			vector2.y = (float)args["pitch"];
		}
		audioSource.volume = vector2.x;
		audioSource.pitch = vector2.y;
		args["volume"] = vector.x;
		args["pitch"] = vector.y;
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		args["type"] = "audio";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void AudioTo(GameObject target, float volume, float pitch, float time)
	{
		AudioTo(target, Hash("volume", volume, "pitch", pitch, "time", time));
	}

	public static void AudioTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (!args.Contains("easetype"))
		{
			args.Add("easetype", EaseType.linear);
		}
		args["type"] = "audio";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void Stab(GameObject target, AudioClip audioclip, float delay)
	{
		Stab(target, Hash("audioclip", audioclip, "delay", delay));
	}

	public static void Stab(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "stab";
		Launch(target, args);
	}

	public static void LookFrom(GameObject target, Vector3 looktarget, float time)
	{
		LookFrom(target, Hash("looktarget", looktarget, "time", time));
	}

	public static void LookFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		Vector3 eulerAngles = target.transform.eulerAngles;
		if (args["looktarget"].GetType() == typeof(Transform))
		{
			Transform obj = target.transform;
			Transform target2 = (Transform)args["looktarget"];
			Vector3? vector = (Vector3?)args["up"];
			obj.LookAt(target2, (!vector.HasValue) ? Defaults.up : vector.Value);
		}
		else if (args["looktarget"].GetType() == typeof(Vector3))
		{
			Transform obj2 = target.transform;
			Vector3 worldPosition = (Vector3)args["looktarget"];
			Vector3? vector2 = (Vector3?)args["up"];
			obj2.LookAt(worldPosition, (!vector2.HasValue) ? Defaults.up : vector2.Value);
		}
		if (args.Contains("axis"))
		{
			Vector3 eulerAngles2 = target.transform.eulerAngles;
			switch ((string)args["axis"])
			{
			case "x":
				eulerAngles2.y = eulerAngles.y;
				eulerAngles2.z = eulerAngles.z;
				break;
			case "y":
				eulerAngles2.x = eulerAngles.x;
				eulerAngles2.z = eulerAngles.z;
				break;
			case "z":
				eulerAngles2.x = eulerAngles.x;
				eulerAngles2.y = eulerAngles.y;
				break;
			}
			target.transform.eulerAngles = eulerAngles2;
		}
		args["rotation"] = eulerAngles;
		args["type"] = "rotate";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void LookTo(GameObject target, Vector3 looktarget, float time)
	{
		LookTo(target, Hash("looktarget", looktarget, "time", time));
	}

	public static void LookTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("looktarget") && args["looktarget"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["looktarget"];
			args["position"] = new Vector3(transform.position.x, transform.position.y, transform.position.z);
			args["rotation"] = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, transform.eulerAngles.z);
		}
		args["type"] = "look";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void MoveTo(GameObject target, Vector3 position, float time)
	{
		MoveTo(target, Hash("position", position, "time", time));
	}

	public static void MoveTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("position") && args["position"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["position"];
			args["position"] = new Vector3(transform.position.x, transform.position.y, transform.position.z);
			args["rotation"] = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, transform.eulerAngles.z);
			args["scale"] = new Vector3(transform.localScale.x, transform.localScale.y, transform.localScale.z);
		}
		args["type"] = "move";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void MoveFrom(GameObject target, Vector3 position, float time)
	{
		MoveFrom(target, Hash("position", position, "time", time));
	}

	public static void MoveFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		bool flag = ((!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]));
		if (args.Contains("path"))
		{
			Vector3[] array2;
			if (args["path"].GetType() == typeof(Vector3[]))
			{
				Vector3[] array = (Vector3[])args["path"];
				array2 = new Vector3[array.Length];
				Array.Copy(array, array2, array.Length);
			}
			else
			{
				Transform[] array3 = (Transform[])args["path"];
				array2 = new Vector3[array3.Length];
				for (int i = 0; i < array3.Length; i++)
				{
					ref Vector3 reference = ref array2[i];
					reference = array3[i].position;
				}
			}
			if (array2[array2.Length - 1] != target.transform.position)
			{
				Vector3[] array4 = new Vector3[array2.Length + 1];
				Array.Copy(array2, array4, array2.Length);
				if (flag)
				{
					ref Vector3 reference2 = ref array4[array4.Length - 1];
					reference2 = target.transform.localPosition;
					target.transform.localPosition = array4[0];
				}
				else
				{
					ref Vector3 reference3 = ref array4[array4.Length - 1];
					reference3 = target.transform.position;
					target.transform.position = array4[0];
				}
				args["path"] = array4;
			}
			else
			{
				if (flag)
				{
					target.transform.localPosition = array2[0];
				}
				else
				{
					target.transform.position = array2[0];
				}
				args["path"] = array2;
			}
		}
		else
		{
			Vector3 vector;
			Vector3 vector2 = ((!flag) ? (vector = target.transform.position) : (vector = target.transform.localPosition));
			if (args.Contains("position"))
			{
				if (args["position"].GetType() == typeof(Transform))
				{
					Transform transform = (Transform)args["position"];
					vector = transform.position;
				}
				else if (args["position"].GetType() == typeof(Vector3))
				{
					vector = (Vector3)args["position"];
				}
			}
			else
			{
				if (args.Contains("x"))
				{
					vector.x = (float)args["x"];
				}
				if (args.Contains("y"))
				{
					vector.y = (float)args["y"];
				}
				if (args.Contains("z"))
				{
					vector.z = (float)args["z"];
				}
			}
			if (flag)
			{
				target.transform.localPosition = vector;
			}
			else
			{
				target.transform.position = vector;
			}
			args["position"] = vector2;
		}
		args["type"] = "move";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void MoveAdd(GameObject target, Vector3 amount, float time)
	{
		MoveAdd(target, Hash("amount", amount, "time", time));
	}

	public static void MoveAdd(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "move";
		args["method"] = "add";
		Launch(target, args);
	}

	public static void MoveBy(GameObject target, Vector3 amount, float time)
	{
		MoveBy(target, Hash("amount", amount, "time", time));
	}

	public static void MoveBy(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "move";
		args["method"] = "by";
		Launch(target, args);
	}

	public static void ScaleTo(GameObject target, Vector3 scale, float time)
	{
		ScaleTo(target, Hash("scale", scale, "time", time));
	}

	public static void ScaleTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("scale") && args["scale"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["scale"];
			args["position"] = new Vector3(transform.position.x, transform.position.y, transform.position.z);
			args["rotation"] = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, transform.eulerAngles.z);
			args["scale"] = new Vector3(transform.localScale.x, transform.localScale.y, transform.localScale.z);
		}
		args["type"] = "scale";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void ScaleFrom(GameObject target, Vector3 scale, float time)
	{
		ScaleFrom(target, Hash("scale", scale, "time", time));
	}

	public static void ScaleFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		Vector3 localScale;
		Vector3 vector = (localScale = target.transform.localScale);
		if (args.Contains("scale"))
		{
			if (args["scale"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["scale"];
				localScale = transform.localScale;
			}
			else if (args["scale"].GetType() == typeof(Vector3))
			{
				localScale = (Vector3)args["scale"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				localScale.x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				localScale.y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				localScale.z = (float)args["z"];
			}
		}
		target.transform.localScale = localScale;
		args["scale"] = vector;
		args["type"] = "scale";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void ScaleAdd(GameObject target, Vector3 amount, float time)
	{
		ScaleAdd(target, Hash("amount", amount, "time", time));
	}

	public static void ScaleAdd(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "scale";
		args["method"] = "add";
		Launch(target, args);
	}

	public static void ScaleBy(GameObject target, Vector3 amount, float time)
	{
		ScaleBy(target, Hash("amount", amount, "time", time));
	}

	public static void ScaleBy(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "scale";
		args["method"] = "by";
		Launch(target, args);
	}

	public static void RotateTo(GameObject target, Vector3 rotation, float time)
	{
		RotateTo(target, Hash("rotation", rotation, "time", time));
	}

	public static void RotateTo(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		if (args.Contains("rotation") && args["rotation"].GetType() == typeof(Transform))
		{
			Transform transform = (Transform)args["rotation"];
			args["position"] = new Vector3(transform.position.x, transform.position.y, transform.position.z);
			args["rotation"] = new Vector3(transform.eulerAngles.x, transform.eulerAngles.y, transform.eulerAngles.z);
			args["scale"] = new Vector3(transform.localScale.x, transform.localScale.y, transform.localScale.z);
		}
		args["type"] = "rotate";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void RotateFrom(GameObject target, Vector3 rotation, float time)
	{
		RotateFrom(target, Hash("rotation", rotation, "time", time));
	}

	public static void RotateFrom(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		bool flag = ((!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]));
		Vector3 vector;
		Vector3 vector2 = ((!flag) ? (vector = target.transform.eulerAngles) : (vector = target.transform.localEulerAngles));
		if (args.Contains("rotation"))
		{
			if (args["rotation"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["rotation"];
				vector = transform.eulerAngles;
			}
			else if (args["rotation"].GetType() == typeof(Vector3))
			{
				vector = (Vector3)args["rotation"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				vector.x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				vector.y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				vector.z = (float)args["z"];
			}
		}
		if (flag)
		{
			target.transform.localEulerAngles = vector;
		}
		else
		{
			target.transform.eulerAngles = vector;
		}
		args["rotation"] = vector2;
		args["type"] = "rotate";
		args["method"] = "to";
		Launch(target, args);
	}

	public static void RotateAdd(GameObject target, Vector3 amount, float time)
	{
		RotateAdd(target, Hash("amount", amount, "time", time));
	}

	public static void RotateAdd(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "rotate";
		args["method"] = "add";
		Launch(target, args);
	}

	public static void RotateBy(GameObject target, Vector3 amount, float time)
	{
		RotateBy(target, Hash("amount", amount, "time", time));
	}

	public static void RotateBy(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "rotate";
		args["method"] = "by";
		Launch(target, args);
	}

	public static void ShakePosition(GameObject target, Vector3 amount, float time)
	{
		ShakePosition(target, Hash("amount", amount, "time", time));
	}

	public static void ShakePosition(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "shake";
		args["method"] = "position";
		Launch(target, args);
	}

	public static void ShakeScale(GameObject target, Vector3 amount, float time)
	{
		ShakeScale(target, Hash("amount", amount, "time", time));
	}

	public static void ShakeScale(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "shake";
		args["method"] = "scale";
		Launch(target, args);
	}

	public static void ShakeRotation(GameObject target, Vector3 amount, float time)
	{
		ShakeRotation(target, Hash("amount", amount, "time", time));
	}

	public static void ShakeRotation(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "shake";
		args["method"] = "rotation";
		Launch(target, args);
	}

	public static void PunchPosition(GameObject target, Vector3 amount, float time)
	{
		PunchPosition(target, Hash("amount", amount, "time", time));
	}

	public static void PunchPosition(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "punch";
		args["method"] = "position";
		args["easetype"] = EaseType.punch;
		Launch(target, args);
	}

	public static void PunchRotation(GameObject target, Vector3 amount, float time)
	{
		PunchRotation(target, Hash("amount", amount, "time", time));
	}

	public static void PunchRotation(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "punch";
		args["method"] = "rotation";
		args["easetype"] = EaseType.punch;
		Launch(target, args);
	}

	public static void PunchScale(GameObject target, Vector3 amount, float time)
	{
		PunchScale(target, Hash("amount", amount, "time", time));
	}

	public static void PunchScale(GameObject target, Hashtable args)
	{
		args = CleanArgs(args);
		args["type"] = "punch";
		args["method"] = "scale";
		args["easetype"] = EaseType.punch;
		Launch(target, args);
	}

	private void GenerateTargets()
	{
		switch (type)
		{
		case "value":
			switch (method)
			{
			case "float":
				GenerateFloatTargets();
				apply = ApplyFloatTargets;
				break;
			case "vector2":
				GenerateVector2Targets();
				apply = ApplyVector2Targets;
				break;
			case "vector3":
				GenerateVector3Targets();
				apply = ApplyVector3Targets;
				break;
			case "color":
				GenerateColorTargets();
				apply = ApplyColorTargets;
				break;
			case "rect":
				GenerateRectTargets();
				apply = ApplyRectTargets;
				break;
			}
			break;
		case "color":
		{
			string text2 = method;
			if (text2 != null && text2 == "to")
			{
				GenerateColorToTargets();
				apply = ApplyColorToTargets;
			}
			break;
		}
		case "audio":
		{
			string text3 = method;
			if (text3 != null && text3 == "to")
			{
				GenerateAudioToTargets();
				apply = ApplyAudioToTargets;
			}
			break;
		}
		case "move":
			switch (method)
			{
			case "to":
				if (tweenArguments.Contains("path"))
				{
					GenerateMoveToPathTargets();
					apply = ApplyMoveToPathTargets;
				}
				else
				{
					GenerateMoveToTargets();
					apply = ApplyMoveToTargets;
				}
				break;
			case "by":
			case "add":
				GenerateMoveByTargets();
				apply = ApplyMoveByTargets;
				break;
			}
			break;
		case "scale":
			switch (method)
			{
			case "to":
				GenerateScaleToTargets();
				apply = ApplyScaleToTargets;
				break;
			case "by":
				GenerateScaleByTargets();
				apply = ApplyScaleToTargets;
				break;
			case "add":
				GenerateScaleAddTargets();
				apply = ApplyScaleToTargets;
				break;
			}
			break;
		case "rotate":
			switch (method)
			{
			case "to":
				GenerateRotateToTargets();
				apply = ApplyRotateToTargets;
				break;
			case "add":
				GenerateRotateAddTargets();
				apply = ApplyRotateAddTargets;
				break;
			case "by":
				GenerateRotateByTargets();
				apply = ApplyRotateAddTargets;
				break;
			}
			break;
		case "shake":
			switch (method)
			{
			case "position":
				GenerateShakePositionTargets();
				apply = ApplyShakePositionTargets;
				break;
			case "scale":
				GenerateShakeScaleTargets();
				apply = ApplyShakeScaleTargets;
				break;
			case "rotation":
				GenerateShakeRotationTargets();
				apply = ApplyShakeRotationTargets;
				break;
			}
			break;
		case "punch":
			switch (method)
			{
			case "position":
				GeneratePunchPositionTargets();
				apply = ApplyPunchPositionTargets;
				break;
			case "rotation":
				GeneratePunchRotationTargets();
				apply = ApplyPunchRotationTargets;
				break;
			case "scale":
				GeneratePunchScaleTargets();
				apply = ApplyPunchScaleTargets;
				break;
			}
			break;
		case "look":
		{
			string text = method;
			if (text != null && text == "to")
			{
				GenerateLookToTargets();
				apply = ApplyLookToTargets;
			}
			break;
		}
		case "stab":
			GenerateStabTargets();
			apply = ApplyStabTargets;
			break;
		}
	}

	private void GenerateRectTargets()
	{
		rects = new Rect[3];
		ref Rect reference = ref rects[0];
		reference = (Rect)tweenArguments["from"];
		ref Rect reference2 = ref rects[1];
		reference2 = (Rect)tweenArguments["to"];
	}

	private void GenerateColorTargets()
	{
		colors = new Color[1, 3];
		ref Color reference = ref colors[0, 0];
		reference = (Color)tweenArguments["from"];
		ref Color reference2 = ref colors[0, 1];
		reference2 = (Color)tweenArguments["to"];
	}

	private void GenerateVector3Targets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		reference = (Vector3)tweenArguments["from"];
		ref Vector3 reference2 = ref vector3s[1];
		reference2 = (Vector3)tweenArguments["to"];
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateVector2Targets()
	{
		vector2s = new Vector2[3];
		ref Vector2 reference = ref vector2s[0];
		reference = (Vector2)tweenArguments["from"];
		ref Vector2 reference2 = ref vector2s[1];
		reference2 = (Vector2)tweenArguments["to"];
		if (tweenArguments.Contains("speed"))
		{
			Vector3 a = new Vector3(vector2s[0].x, vector2s[0].y, 0f);
			Vector3 b = new Vector3(vector2s[1].x, vector2s[1].y, 0f);
			float num = Math.Abs(Vector3.Distance(a, b));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateFloatTargets()
	{
		floats = new float[3];
		floats[0] = (float)tweenArguments["from"];
		floats[1] = (float)tweenArguments["to"];
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(floats[0] - floats[1]);
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateColorToTargets()
	{
		if ((bool)GetComponent(typeof(GUITexture)))
		{
			colors = new Color[1, 3];
			ref Color reference = ref colors[0, 0];
			ref Color reference2 = ref colors[0, 1];
			reference = (reference2 = GetComponent<GUITexture>().color);
		}
		else if ((bool)GetComponent(typeof(GUIText)))
		{
			colors = new Color[1, 3];
			ref Color reference3 = ref colors[0, 0];
			ref Color reference4 = ref colors[0, 1];
			reference3 = (reference4 = GetComponent<GUIText>().material.color);
		}
		else if ((bool)GetComponent<Renderer>())
		{
			colors = new Color[GetComponent<Renderer>().materials.Length, 3];
			for (int i = 0; i < GetComponent<Renderer>().materials.Length; i++)
			{
				ref Color reference5 = ref colors[i, 0];
				reference5 = GetComponent<Renderer>().materials[i].GetColor(namedcolorvalue.ToString());
				ref Color reference6 = ref colors[i, 1];
				reference6 = GetComponent<Renderer>().materials[i].GetColor(namedcolorvalue.ToString());
			}
		}
		else if ((bool)GetComponent<Light>())
		{
			colors = new Color[1, 3];
			ref Color reference7 = ref colors[0, 0];
			ref Color reference8 = ref colors[0, 1];
			reference7 = (reference8 = GetComponent<Light>().color);
		}
		else
		{
			colors = new Color[1, 3];
		}
		if (tweenArguments.Contains("color"))
		{
			for (int j = 0; j < colors.GetLength(0); j++)
			{
				ref Color reference9 = ref colors[j, 1];
				reference9 = (Color)tweenArguments["color"];
			}
		}
		else
		{
			if (tweenArguments.Contains("r"))
			{
				for (int k = 0; k < colors.GetLength(0); k++)
				{
					colors[k, 1].r = (float)tweenArguments["r"];
				}
			}
			if (tweenArguments.Contains("g"))
			{
				for (int l = 0; l < colors.GetLength(0); l++)
				{
					colors[l, 1].g = (float)tweenArguments["g"];
				}
			}
			if (tweenArguments.Contains("b"))
			{
				for (int m = 0; m < colors.GetLength(0); m++)
				{
					colors[m, 1].b = (float)tweenArguments["b"];
				}
			}
			if (tweenArguments.Contains("a"))
			{
				for (int n = 0; n < colors.GetLength(0); n++)
				{
					colors[n, 1].a = (float)tweenArguments["a"];
				}
			}
		}
		if (tweenArguments.Contains("amount"))
		{
			for (int num = 0; num < colors.GetLength(0); num++)
			{
				colors[num, 1].a = (float)tweenArguments["amount"];
			}
		}
		else if (tweenArguments.Contains("alpha"))
		{
			for (int num2 = 0; num2 < colors.GetLength(0); num2++)
			{
				colors[num2, 1].a = (float)tweenArguments["alpha"];
			}
		}
	}

	private void GenerateAudioToTargets()
	{
		vector2s = new Vector2[3];
		if (tweenArguments.Contains("audiosource"))
		{
			audioSource = (AudioSource)tweenArguments["audiosource"];
		}
		else if ((bool)GetComponent(typeof(AudioSource)))
		{
			audioSource = GetComponent<AudioSource>();
		}
		else
		{
			Debug.LogError("iTween Error: AudioTo requires an AudioSource.");
			Dispose();
		}
		ref Vector2 reference = ref vector2s[0];
		ref Vector2 reference2 = ref vector2s[1];
		reference = (reference2 = new Vector2(audioSource.volume, audioSource.pitch));
		if (tweenArguments.Contains("volume"))
		{
			vector2s[1].x = (float)tweenArguments["volume"];
		}
		if (tweenArguments.Contains("pitch"))
		{
			vector2s[1].y = (float)tweenArguments["pitch"];
		}
	}

	private void GenerateStabTargets()
	{
		if (tweenArguments.Contains("audiosource"))
		{
			audioSource = (AudioSource)tweenArguments["audiosource"];
		}
		else if ((bool)GetComponent(typeof(AudioSource)))
		{
			audioSource = GetComponent<AudioSource>();
		}
		else
		{
			base.gameObject.AddComponent(typeof(AudioSource));
			audioSource = GetComponent<AudioSource>();
			audioSource.playOnAwake = false;
		}
		audioSource.clip = (AudioClip)tweenArguments["audioclip"];
		if (tweenArguments.Contains("pitch"))
		{
			audioSource.pitch = (float)tweenArguments["pitch"];
		}
		if (tweenArguments.Contains("volume"))
		{
			audioSource.volume = (float)tweenArguments["volume"];
		}
		time = audioSource.clip.length / audioSource.pitch;
	}

	private void GenerateLookToTargets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		reference = base.transform.eulerAngles;
		if (tweenArguments.Contains("looktarget"))
		{
			if (tweenArguments["looktarget"].GetType() == typeof(Transform))
			{
				Transform obj = base.transform;
				Transform target = (Transform)tweenArguments["looktarget"];
				Vector3? vector = (Vector3?)tweenArguments["up"];
				obj.LookAt(target, (!vector.HasValue) ? Defaults.up : vector.Value);
			}
			else if (tweenArguments["looktarget"].GetType() == typeof(Vector3))
			{
				Transform obj2 = base.transform;
				Vector3 worldPosition = (Vector3)tweenArguments["looktarget"];
				Vector3? vector2 = (Vector3?)tweenArguments["up"];
				obj2.LookAt(worldPosition, (!vector2.HasValue) ? Defaults.up : vector2.Value);
			}
		}
		else
		{
			Debug.LogError("iTween Error: LookTo needs a 'looktarget' property!");
			Dispose();
		}
		ref Vector3 reference2 = ref vector3s[1];
		reference2 = base.transform.eulerAngles;
		base.transform.eulerAngles = vector3s[0];
		if (tweenArguments.Contains("axis"))
		{
			switch ((string)tweenArguments["axis"])
			{
			case "x":
				vector3s[1].y = vector3s[0].y;
				vector3s[1].z = vector3s[0].z;
				break;
			case "y":
				vector3s[1].x = vector3s[0].x;
				vector3s[1].z = vector3s[0].z;
				break;
			case "z":
				vector3s[1].x = vector3s[0].x;
				vector3s[1].y = vector3s[0].y;
				break;
			}
		}
		ref Vector3 reference3 = ref vector3s[1];
		reference3 = new Vector3(clerp(vector3s[0].x, vector3s[1].x, 1f), clerp(vector3s[0].y, vector3s[1].y, 1f), clerp(vector3s[0].z, vector3s[1].z, 1f));
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateMoveToPathTargets()
	{
		Vector3[] array2;
		if (tweenArguments["path"].GetType() == typeof(Vector3[]))
		{
			Vector3[] array = (Vector3[])tweenArguments["path"];
			if (array.Length == 1)
			{
				Debug.LogError("iTween Error: Attempting a path movement with MoveTo requires an array of more than 1 entry!");
				Dispose();
			}
			array2 = new Vector3[array.Length];
			Array.Copy(array, array2, array.Length);
		}
		else
		{
			Transform[] array3 = (Transform[])tweenArguments["path"];
			if (array3.Length == 1)
			{
				Debug.LogError("iTween Error: Attempting a path movement with MoveTo requires an array of more than 1 entry!");
				Dispose();
			}
			array2 = new Vector3[array3.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				ref Vector3 reference = ref array2[i];
				reference = array3[i].position;
			}
		}
		bool flag;
		int num;
		if (base.transform.position != array2[0])
		{
			if (!tweenArguments.Contains("movetopath") || (bool)tweenArguments["movetopath"])
			{
				flag = true;
				num = 3;
			}
			else
			{
				flag = false;
				num = 2;
			}
		}
		else
		{
			flag = false;
			num = 2;
		}
		vector3s = new Vector3[array2.Length + num];
		if (flag)
		{
			ref Vector3 reference2 = ref vector3s[1];
			reference2 = base.transform.position;
			num = 2;
		}
		else
		{
			num = 1;
		}
		Array.Copy(array2, 0, vector3s, num, array2.Length);
		ref Vector3 reference3 = ref vector3s[0];
		reference3 = vector3s[1] + (vector3s[1] - vector3s[2]);
		ref Vector3 reference4 = ref vector3s[vector3s.Length - 1];
		reference4 = vector3s[vector3s.Length - 2] + (vector3s[vector3s.Length - 2] - vector3s[vector3s.Length - 3]);
		if (vector3s[1] == vector3s[vector3s.Length - 2])
		{
			Vector3[] array4 = new Vector3[vector3s.Length];
			Array.Copy(vector3s, array4, vector3s.Length);
			ref Vector3 reference5 = ref array4[0];
			reference5 = array4[array4.Length - 3];
			ref Vector3 reference6 = ref array4[array4.Length - 1];
			reference6 = array4[2];
			vector3s = new Vector3[array4.Length];
			Array.Copy(array4, vector3s, array4.Length);
		}
		path = new CRSpline(vector3s);
		if (tweenArguments.Contains("speed"))
		{
			float num2 = PathLength(vector3s);
			time = num2 / (float)tweenArguments["speed"];
		}
	}

	private void GenerateMoveToTargets()
	{
		vector3s = new Vector3[3];
		if (isLocal)
		{
			ref Vector3 reference = ref vector3s[0];
			ref Vector3 reference2 = ref vector3s[1];
			reference = (reference2 = base.transform.localPosition);
		}
		else
		{
			ref Vector3 reference3 = ref vector3s[0];
			ref Vector3 reference4 = ref vector3s[1];
			reference3 = (reference4 = base.transform.position);
		}
		if (tweenArguments.Contains("position"))
		{
			if (tweenArguments["position"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)tweenArguments["position"];
				ref Vector3 reference5 = ref vector3s[1];
				reference5 = transform.position;
			}
			else if (tweenArguments["position"].GetType() == typeof(Vector3))
			{
				ref Vector3 reference6 = ref vector3s[1];
				reference6 = (Vector3)tweenArguments["position"];
			}
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("orienttopath") && (bool)tweenArguments["orienttopath"])
		{
			tweenArguments["looktarget"] = vector3s[1];
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateMoveByTargets()
	{
		vector3s = new Vector3[6];
		ref Vector3 reference = ref vector3s[4];
		reference = base.transform.eulerAngles;
		ref Vector3 reference2 = ref vector3s[0];
		ref Vector3 reference3 = ref vector3s[1];
		ref Vector3 reference4 = ref vector3s[3];
		reference2 = (reference3 = (reference4 = base.transform.position));
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference5 = ref vector3s[1];
			reference5 = vector3s[0] + (Vector3)tweenArguments["amount"];
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = vector3s[0].x + (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = vector3s[0].y + (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = vector3s[0].z + (float)tweenArguments["z"];
			}
		}
		base.transform.Translate(vector3s[1], space);
		ref Vector3 reference6 = ref vector3s[5];
		reference6 = base.transform.position;
		base.transform.position = vector3s[0];
		if (tweenArguments.Contains("orienttopath") && (bool)tweenArguments["orienttopath"])
		{
			tweenArguments["looktarget"] = vector3s[1];
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateScaleToTargets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		ref Vector3 reference2 = ref vector3s[1];
		reference = (reference2 = base.transform.localScale);
		if (tweenArguments.Contains("scale"))
		{
			if (tweenArguments["scale"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)tweenArguments["scale"];
				ref Vector3 reference3 = ref vector3s[1];
				reference3 = transform.localScale;
			}
			else if (tweenArguments["scale"].GetType() == typeof(Vector3))
			{
				ref Vector3 reference4 = ref vector3s[1];
				reference4 = (Vector3)tweenArguments["scale"];
			}
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateScaleByTargets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		ref Vector3 reference2 = ref vector3s[1];
		reference = (reference2 = base.transform.localScale);
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference3 = ref vector3s[1];
			reference3 = Vector3.Scale(vector3s[1], (Vector3)tweenArguments["amount"]);
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x *= (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y *= (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z *= (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateScaleAddTargets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		ref Vector3 reference2 = ref vector3s[1];
		reference = (reference2 = base.transform.localScale);
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] += (Vector3)tweenArguments["amount"];
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x += (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y += (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z += (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateRotateToTargets()
	{
		vector3s = new Vector3[3];
		if (isLocal)
		{
			ref Vector3 reference = ref vector3s[0];
			ref Vector3 reference2 = ref vector3s[1];
			reference = (reference2 = base.transform.localEulerAngles);
		}
		else
		{
			ref Vector3 reference3 = ref vector3s[0];
			ref Vector3 reference4 = ref vector3s[1];
			reference3 = (reference4 = base.transform.eulerAngles);
		}
		if (tweenArguments.Contains("rotation"))
		{
			if (tweenArguments["rotation"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)tweenArguments["rotation"];
				ref Vector3 reference5 = ref vector3s[1];
				reference5 = transform.eulerAngles;
			}
			else if (tweenArguments["rotation"].GetType() == typeof(Vector3))
			{
				ref Vector3 reference6 = ref vector3s[1];
				reference6 = (Vector3)tweenArguments["rotation"];
			}
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x = (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y = (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z = (float)tweenArguments["z"];
			}
		}
		ref Vector3 reference7 = ref vector3s[1];
		reference7 = new Vector3(clerp(vector3s[0].x, vector3s[1].x, 1f), clerp(vector3s[0].y, vector3s[1].y, 1f), clerp(vector3s[0].z, vector3s[1].z, 1f));
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateRotateAddTargets()
	{
		vector3s = new Vector3[5];
		ref Vector3 reference = ref vector3s[0];
		ref Vector3 reference2 = ref vector3s[1];
		ref Vector3 reference3 = ref vector3s[3];
		reference = (reference2 = (reference3 = base.transform.eulerAngles));
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] += (Vector3)tweenArguments["amount"];
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x += (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y += (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z += (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateRotateByTargets()
	{
		vector3s = new Vector3[4];
		ref Vector3 reference = ref vector3s[0];
		ref Vector3 reference2 = ref vector3s[1];
		ref Vector3 reference3 = ref vector3s[3];
		reference = (reference2 = (reference3 = base.transform.eulerAngles));
		if (tweenArguments.Contains("amount"))
		{
			vector3s[1] += Vector3.Scale((Vector3)tweenArguments["amount"], new Vector3(360f, 360f, 360f));
		}
		else
		{
			if (tweenArguments.Contains("x"))
			{
				vector3s[1].x += 360f * (float)tweenArguments["x"];
			}
			if (tweenArguments.Contains("y"))
			{
				vector3s[1].y += 360f * (float)tweenArguments["y"];
			}
			if (tweenArguments.Contains("z"))
			{
				vector3s[1].z += 360f * (float)tweenArguments["z"];
			}
		}
		if (tweenArguments.Contains("speed"))
		{
			float num = Math.Abs(Vector3.Distance(vector3s[0], vector3s[1]));
			time = num / (float)tweenArguments["speed"];
		}
	}

	private void GenerateShakePositionTargets()
	{
		vector3s = new Vector3[4];
		ref Vector3 reference = ref vector3s[3];
		reference = base.transform.eulerAngles;
		ref Vector3 reference2 = ref vector3s[0];
		reference2 = base.transform.position;
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference3 = ref vector3s[1];
			reference3 = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GenerateShakeScaleTargets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		reference = base.transform.localScale;
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference2 = ref vector3s[1];
			reference2 = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GenerateShakeRotationTargets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		reference = base.transform.eulerAngles;
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference2 = ref vector3s[1];
			reference2 = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GeneratePunchPositionTargets()
	{
		vector3s = new Vector3[5];
		ref Vector3 reference = ref vector3s[4];
		reference = base.transform.eulerAngles;
		ref Vector3 reference2 = ref vector3s[0];
		reference2 = base.transform.position;
		ref Vector3 reference3 = ref vector3s[1];
		ref Vector3 reference4 = ref vector3s[3];
		reference3 = (reference4 = Vector3.zero);
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference5 = ref vector3s[1];
			reference5 = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GeneratePunchRotationTargets()
	{
		vector3s = new Vector3[4];
		ref Vector3 reference = ref vector3s[0];
		reference = base.transform.eulerAngles;
		ref Vector3 reference2 = ref vector3s[1];
		ref Vector3 reference3 = ref vector3s[3];
		reference2 = (reference3 = Vector3.zero);
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference4 = ref vector3s[1];
			reference4 = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void GeneratePunchScaleTargets()
	{
		vector3s = new Vector3[3];
		ref Vector3 reference = ref vector3s[0];
		reference = base.transform.localScale;
		ref Vector3 reference2 = ref vector3s[1];
		reference2 = Vector3.zero;
		if (tweenArguments.Contains("amount"))
		{
			ref Vector3 reference3 = ref vector3s[1];
			reference3 = (Vector3)tweenArguments["amount"];
			return;
		}
		if (tweenArguments.Contains("x"))
		{
			vector3s[1].x = (float)tweenArguments["x"];
		}
		if (tweenArguments.Contains("y"))
		{
			vector3s[1].y = (float)tweenArguments["y"];
		}
		if (tweenArguments.Contains("z"))
		{
			vector3s[1].z = (float)tweenArguments["z"];
		}
	}

	private void ApplyRectTargets()
	{
		rects[2].x = ease(rects[0].x, rects[1].x, percentage);
		rects[2].y = ease(rects[0].y, rects[1].y, percentage);
		rects[2].width = ease(rects[0].width, rects[1].width, percentage);
		rects[2].height = ease(rects[0].height, rects[1].height, percentage);
		tweenArguments["onupdateparams"] = rects[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = rects[1];
		}
	}

	private void ApplyColorTargets()
	{
		colors[0, 2].r = ease(colors[0, 0].r, colors[0, 1].r, percentage);
		colors[0, 2].g = ease(colors[0, 0].g, colors[0, 1].g, percentage);
		colors[0, 2].b = ease(colors[0, 0].b, colors[0, 1].b, percentage);
		colors[0, 2].a = ease(colors[0, 0].a, colors[0, 1].a, percentage);
		tweenArguments["onupdateparams"] = colors[0, 2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = colors[0, 1];
		}
	}

	private void ApplyVector3Targets()
	{
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		tweenArguments["onupdateparams"] = vector3s[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = vector3s[1];
		}
	}

	private void ApplyVector2Targets()
	{
		vector2s[2].x = ease(vector2s[0].x, vector2s[1].x, percentage);
		vector2s[2].y = ease(vector2s[0].y, vector2s[1].y, percentage);
		tweenArguments["onupdateparams"] = vector2s[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = vector2s[1];
		}
	}

	private void ApplyFloatTargets()
	{
		floats[2] = ease(floats[0], floats[1], percentage);
		tweenArguments["onupdateparams"] = floats[2];
		if (percentage == 1f)
		{
			tweenArguments["onupdateparams"] = floats[1];
		}
	}

	private void ApplyColorToTargets()
	{
		for (int i = 0; i < colors.GetLength(0); i++)
		{
			colors[i, 2].r = ease(colors[i, 0].r, colors[i, 1].r, percentage);
			colors[i, 2].g = ease(colors[i, 0].g, colors[i, 1].g, percentage);
			colors[i, 2].b = ease(colors[i, 0].b, colors[i, 1].b, percentage);
			colors[i, 2].a = ease(colors[i, 0].a, colors[i, 1].a, percentage);
		}
		if ((bool)GetComponent(typeof(GUITexture)))
		{
			GetComponent<GUITexture>().color = colors[0, 2];
		}
		else if ((bool)GetComponent(typeof(GUIText)))
		{
			GetComponent<GUIText>().material.color = colors[0, 2];
		}
		else if ((bool)GetComponent<Renderer>())
		{
			for (int j = 0; j < colors.GetLength(0); j++)
			{
				GetComponent<Renderer>().materials[j].SetColor(namedcolorvalue.ToString(), colors[j, 2]);
			}
		}
		else if ((bool)GetComponent<Light>())
		{
			GetComponent<Light>().color = colors[0, 2];
		}
		if (percentage != 1f)
		{
			return;
		}
		if ((bool)GetComponent(typeof(GUITexture)))
		{
			GetComponent<GUITexture>().color = colors[0, 1];
		}
		else if ((bool)GetComponent(typeof(GUIText)))
		{
			GetComponent<GUIText>().material.color = colors[0, 1];
		}
		else if ((bool)GetComponent<Renderer>())
		{
			for (int k = 0; k < colors.GetLength(0); k++)
			{
				GetComponent<Renderer>().materials[k].SetColor(namedcolorvalue.ToString(), colors[k, 1]);
			}
		}
		else if ((bool)GetComponent<Light>())
		{
			GetComponent<Light>().color = colors[0, 1];
		}
	}

	private void ApplyAudioToTargets()
	{
		vector2s[2].x = ease(vector2s[0].x, vector2s[1].x, percentage);
		vector2s[2].y = ease(vector2s[0].y, vector2s[1].y, percentage);
		audioSource.volume = vector2s[2].x;
		audioSource.pitch = vector2s[2].y;
		if (percentage == 1f)
		{
			audioSource.volume = vector2s[1].x;
			audioSource.pitch = vector2s[1].y;
		}
	}

	private void ApplyStabTargets()
	{
	}

	private void ApplyMoveToPathTargets()
	{
		preUpdate = base.transform.position;
		float value = ease(0f, 1f, percentage);
		if (isLocal)
		{
			base.transform.localPosition = path.Interp(Mathf.Clamp(value, 0f, 1f));
		}
		else
		{
			base.transform.position = path.Interp(Mathf.Clamp(value, 0f, 1f));
		}
		if (tweenArguments.Contains("orienttopath") && (bool)tweenArguments["orienttopath"])
		{
			float num = ((!tweenArguments.Contains("lookahead")) ? Defaults.lookAhead : ((float)tweenArguments["lookahead"]));
			float value2 = ease(0f, 1f, Mathf.Min(1f, percentage + num));
			tweenArguments["looktarget"] = path.Interp(Mathf.Clamp(value2, 0f, 1f));
		}
		postUpdate = base.transform.position;
		if (physics)
		{
			base.transform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyMoveToTargets()
	{
		preUpdate = base.transform.position;
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		if (isLocal)
		{
			base.transform.localPosition = vector3s[2];
		}
		else
		{
			base.transform.position = vector3s[2];
		}
		if (percentage == 1f)
		{
			if (isLocal)
			{
				base.transform.localPosition = vector3s[1];
			}
			else
			{
				base.transform.position = vector3s[1];
			}
		}
		postUpdate = base.transform.position;
		if (physics)
		{
			base.transform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyMoveByTargets()
	{
		preUpdate = base.transform.position;
		Vector3 eulerAngles = default(Vector3);
		if (tweenArguments.Contains("looktarget"))
		{
			eulerAngles = base.transform.eulerAngles;
			base.transform.eulerAngles = vector3s[4];
		}
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		base.transform.Translate(vector3s[2] - vector3s[3], space);
		ref Vector3 reference = ref vector3s[3];
		reference = vector3s[2];
		if (tweenArguments.Contains("looktarget"))
		{
			base.transform.eulerAngles = eulerAngles;
		}
		postUpdate = base.transform.position;
		if (physics)
		{
			base.transform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyScaleToTargets()
	{
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		base.transform.localScale = vector3s[2];
		if (percentage == 1f)
		{
			base.transform.localScale = vector3s[1];
		}
	}

	private void ApplyLookToTargets()
	{
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		if (isLocal)
		{
			base.transform.localRotation = Quaternion.Euler(vector3s[2]);
		}
		else
		{
			base.transform.rotation = Quaternion.Euler(vector3s[2]);
		}
	}

	private void ApplyRotateToTargets()
	{
		preUpdate = base.transform.eulerAngles;
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		if (isLocal)
		{
			base.transform.localRotation = Quaternion.Euler(vector3s[2]);
		}
		else
		{
			base.transform.rotation = Quaternion.Euler(vector3s[2]);
		}
		if (percentage == 1f)
		{
			if (isLocal)
			{
				base.transform.localRotation = Quaternion.Euler(vector3s[1]);
			}
			else
			{
				base.transform.rotation = Quaternion.Euler(vector3s[1]);
			}
		}
		postUpdate = base.transform.eulerAngles;
		if (physics)
		{
			base.transform.eulerAngles = preUpdate;
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyRotateAddTargets()
	{
		preUpdate = base.transform.eulerAngles;
		vector3s[2].x = ease(vector3s[0].x, vector3s[1].x, percentage);
		vector3s[2].y = ease(vector3s[0].y, vector3s[1].y, percentage);
		vector3s[2].z = ease(vector3s[0].z, vector3s[1].z, percentage);
		base.transform.Rotate(vector3s[2] - vector3s[3], space);
		ref Vector3 reference = ref vector3s[3];
		reference = vector3s[2];
		postUpdate = base.transform.eulerAngles;
		if (physics)
		{
			base.transform.eulerAngles = preUpdate;
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyShakePositionTargets()
	{
		if (isLocal)
		{
			preUpdate = base.transform.localPosition;
		}
		else
		{
			preUpdate = base.transform.position;
		}
		Vector3 eulerAngles = default(Vector3);
		if (tweenArguments.Contains("looktarget"))
		{
			eulerAngles = base.transform.eulerAngles;
			base.transform.eulerAngles = vector3s[3];
		}
		if (percentage == 0f)
		{
			base.transform.Translate(vector3s[1], space);
		}
		if (isLocal)
		{
			base.transform.localPosition = vector3s[0];
		}
		else
		{
			base.transform.position = vector3s[0];
		}
		float num = 1f - percentage;
		vector3s[2].x = UnityEngine.Random.Range((0f - vector3s[1].x) * num, vector3s[1].x * num);
		vector3s[2].y = UnityEngine.Random.Range((0f - vector3s[1].y) * num, vector3s[1].y * num);
		vector3s[2].z = UnityEngine.Random.Range((0f - vector3s[1].z) * num, vector3s[1].z * num);
		if (isLocal)
		{
			base.transform.localPosition += vector3s[2];
		}
		else
		{
			base.transform.position += vector3s[2];
		}
		if (tweenArguments.Contains("looktarget"))
		{
			base.transform.eulerAngles = eulerAngles;
		}
		postUpdate = base.transform.position;
		if (physics)
		{
			base.transform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyShakeScaleTargets()
	{
		if (percentage == 0f)
		{
			base.transform.localScale = vector3s[1];
		}
		base.transform.localScale = vector3s[0];
		float num = 1f - percentage;
		vector3s[2].x = UnityEngine.Random.Range((0f - vector3s[1].x) * num, vector3s[1].x * num);
		vector3s[2].y = UnityEngine.Random.Range((0f - vector3s[1].y) * num, vector3s[1].y * num);
		vector3s[2].z = UnityEngine.Random.Range((0f - vector3s[1].z) * num, vector3s[1].z * num);
		base.transform.localScale += vector3s[2];
	}

	private void ApplyShakeRotationTargets()
	{
		preUpdate = base.transform.eulerAngles;
		if (percentage == 0f)
		{
			base.transform.Rotate(vector3s[1], space);
		}
		base.transform.eulerAngles = vector3s[0];
		float num = 1f - percentage;
		vector3s[2].x = UnityEngine.Random.Range((0f - vector3s[1].x) * num, vector3s[1].x * num);
		vector3s[2].y = UnityEngine.Random.Range((0f - vector3s[1].y) * num, vector3s[1].y * num);
		vector3s[2].z = UnityEngine.Random.Range((0f - vector3s[1].z) * num, vector3s[1].z * num);
		base.transform.Rotate(vector3s[2], space);
		postUpdate = base.transform.eulerAngles;
		if (physics)
		{
			base.transform.eulerAngles = preUpdate;
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyPunchPositionTargets()
	{
		preUpdate = base.transform.position;
		Vector3 eulerAngles = default(Vector3);
		if (tweenArguments.Contains("looktarget"))
		{
			eulerAngles = base.transform.eulerAngles;
			base.transform.eulerAngles = vector3s[4];
		}
		if (vector3s[1].x > 0f)
		{
			vector3s[2].x = punch(vector3s[1].x, percentage);
		}
		else if (vector3s[1].x < 0f)
		{
			vector3s[2].x = 0f - punch(Mathf.Abs(vector3s[1].x), percentage);
		}
		if (vector3s[1].y > 0f)
		{
			vector3s[2].y = punch(vector3s[1].y, percentage);
		}
		else if (vector3s[1].y < 0f)
		{
			vector3s[2].y = 0f - punch(Mathf.Abs(vector3s[1].y), percentage);
		}
		if (vector3s[1].z > 0f)
		{
			vector3s[2].z = punch(vector3s[1].z, percentage);
		}
		else if (vector3s[1].z < 0f)
		{
			vector3s[2].z = 0f - punch(Mathf.Abs(vector3s[1].z), percentage);
		}
		base.transform.Translate(vector3s[2] - vector3s[3], space);
		ref Vector3 reference = ref vector3s[3];
		reference = vector3s[2];
		if (tweenArguments.Contains("looktarget"))
		{
			base.transform.eulerAngles = eulerAngles;
		}
		postUpdate = base.transform.position;
		if (physics)
		{
			base.transform.position = preUpdate;
			GetComponent<Rigidbody>().MovePosition(postUpdate);
		}
	}

	private void ApplyPunchRotationTargets()
	{
		preUpdate = base.transform.eulerAngles;
		if (vector3s[1].x > 0f)
		{
			vector3s[2].x = punch(vector3s[1].x, percentage);
		}
		else if (vector3s[1].x < 0f)
		{
			vector3s[2].x = 0f - punch(Mathf.Abs(vector3s[1].x), percentage);
		}
		if (vector3s[1].y > 0f)
		{
			vector3s[2].y = punch(vector3s[1].y, percentage);
		}
		else if (vector3s[1].y < 0f)
		{
			vector3s[2].y = 0f - punch(Mathf.Abs(vector3s[1].y), percentage);
		}
		if (vector3s[1].z > 0f)
		{
			vector3s[2].z = punch(vector3s[1].z, percentage);
		}
		else if (vector3s[1].z < 0f)
		{
			vector3s[2].z = 0f - punch(Mathf.Abs(vector3s[1].z), percentage);
		}
		base.transform.Rotate(vector3s[2] - vector3s[3], space);
		ref Vector3 reference = ref vector3s[3];
		reference = vector3s[2];
		postUpdate = base.transform.eulerAngles;
		if (physics)
		{
			base.transform.eulerAngles = preUpdate;
			GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(postUpdate));
		}
	}

	private void ApplyPunchScaleTargets()
	{
		if (vector3s[1].x > 0f)
		{
			vector3s[2].x = punch(vector3s[1].x, percentage);
		}
		else if (vector3s[1].x < 0f)
		{
			vector3s[2].x = 0f - punch(Mathf.Abs(vector3s[1].x), percentage);
		}
		if (vector3s[1].y > 0f)
		{
			vector3s[2].y = punch(vector3s[1].y, percentage);
		}
		else if (vector3s[1].y < 0f)
		{
			vector3s[2].y = 0f - punch(Mathf.Abs(vector3s[1].y), percentage);
		}
		if (vector3s[1].z > 0f)
		{
			vector3s[2].z = punch(vector3s[1].z, percentage);
		}
		else if (vector3s[1].z < 0f)
		{
			vector3s[2].z = 0f - punch(Mathf.Abs(vector3s[1].z), percentage);
		}
		base.transform.localScale = vector3s[0] + vector3s[2];
	}

	private IEnumerator TweenDelay()
	{
		delayStarted = Time.time;
		yield return new WaitForSeconds(delay);
		if (wasPaused)
		{
			wasPaused = false;
			TweenStart();
		}
	}

	private void TweenStart()
	{
		CallBack("onstart");
		if (!loop)
		{
			ConflictCheck();
			GenerateTargets();
		}
		if (type == "stab")
		{
			audioSource.PlayOneShot(audioSource.clip);
		}
		if (type == "move" || type == "scale" || type == "rotate" || type == "punch" || type == "shake" || type == "curve" || type == "look")
		{
			EnableKinematic();
		}
		isRunning = true;
	}

	private IEnumerator TweenRestart()
	{
		if (delay > 0f)
		{
			delayStarted = Time.time;
			yield return new WaitForSeconds(delay);
		}
		loop = true;
		TweenStart();
	}

	private void TweenUpdate()
	{
		apply();
		CallBack("onupdate");
		UpdatePercentage();
	}

	private void TweenComplete()
	{
		isRunning = false;
		if (percentage > 0.5f)
		{
			percentage = 1f;
		}
		else
		{
			percentage = 0f;
		}
		apply();
		if (type == "value")
		{
			CallBack("onupdate");
		}
		if (loopType == LoopType.none)
		{
			Dispose();
		}
		else
		{
			TweenLoop();
		}
		CallBack("oncomplete");
	}

	private void TweenLoop()
	{
		DisableKinematic();
		switch (loopType)
		{
		case LoopType.loop:
			percentage = 0f;
			runningTime = 0f;
			apply();
			StartCoroutine("TweenRestart");
			break;
		case LoopType.pingPong:
			reverse = !reverse;
			runningTime = 0f;
			StartCoroutine("TweenRestart");
			break;
		}
	}

	public static Rect RectUpdate(Rect currentValue, Rect targetValue, float speed)
	{
		return new Rect(FloatUpdate(currentValue.x, targetValue.x, speed), FloatUpdate(currentValue.y, targetValue.y, speed), FloatUpdate(currentValue.width, targetValue.width, speed), FloatUpdate(currentValue.height, targetValue.height, speed));
	}

	public static Vector3 Vector3Update(Vector3 currentValue, Vector3 targetValue, float speed)
	{
		Vector3 vector = targetValue - currentValue;
		currentValue += vector * speed * Time.deltaTime;
		return currentValue;
	}

	public static Vector2 Vector2Update(Vector2 currentValue, Vector2 targetValue, float speed)
	{
		Vector2 vector = targetValue - currentValue;
		currentValue += vector * speed * Time.deltaTime;
		return currentValue;
	}

	public static float FloatUpdate(float currentValue, float targetValue, float speed)
	{
		float num = targetValue - currentValue;
		currentValue += num * speed * Time.deltaTime;
		return currentValue;
	}

	public static void FadeUpdate(GameObject target, Hashtable args)
	{
		args["a"] = args["alpha"];
		ColorUpdate(target, args);
	}

	public static void FadeUpdate(GameObject target, float alpha, float time)
	{
		FadeUpdate(target, Hash("alpha", alpha, "time", time));
	}

	public static void ColorUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Color[] array = new Color[4];
		if (!args.Contains("includechildren") || (bool)args["includechildren"])
		{
			foreach (Transform item in target.transform)
			{
				ColorUpdate(item.gameObject, args);
			}
		}
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		if ((bool)target.GetComponent(typeof(GUITexture)))
		{
			ref Color reference = ref array[0];
			ref Color reference2 = ref array[1];
			reference = (reference2 = target.GetComponent<GUITexture>().color);
		}
		else if ((bool)target.GetComponent(typeof(GUIText)))
		{
			ref Color reference3 = ref array[0];
			ref Color reference4 = ref array[1];
			reference3 = (reference4 = target.GetComponent<GUIText>().material.color);
		}
		else if ((bool)target.GetComponent<Renderer>())
		{
			ref Color reference5 = ref array[0];
			ref Color reference6 = ref array[1];
			reference5 = (reference6 = target.GetComponent<Renderer>().material.color);
		}
		else if ((bool)target.GetComponent<Light>())
		{
			ref Color reference7 = ref array[0];
			ref Color reference8 = ref array[1];
			reference7 = (reference8 = target.GetComponent<Light>().color);
		}
		if (args.Contains("color"))
		{
			ref Color reference9 = ref array[1];
			reference9 = (Color)args["color"];
		}
		else
		{
			if (args.Contains("r"))
			{
				array[1].r = (float)args["r"];
			}
			if (args.Contains("g"))
			{
				array[1].g = (float)args["g"];
			}
			if (args.Contains("b"))
			{
				array[1].b = (float)args["b"];
			}
			if (args.Contains("a"))
			{
				array[1].a = (float)args["a"];
			}
		}
		array[3].r = Mathf.SmoothDamp(array[0].r, array[1].r, ref array[2].r, num);
		array[3].g = Mathf.SmoothDamp(array[0].g, array[1].g, ref array[2].g, num);
		array[3].b = Mathf.SmoothDamp(array[0].b, array[1].b, ref array[2].b, num);
		array[3].a = Mathf.SmoothDamp(array[0].a, array[1].a, ref array[2].a, num);
		if ((bool)target.GetComponent(typeof(GUITexture)))
		{
			target.GetComponent<GUITexture>().color = array[3];
		}
		else if ((bool)target.GetComponent(typeof(GUIText)))
		{
			target.GetComponent<GUIText>().material.color = array[3];
		}
		else if ((bool)target.GetComponent<Renderer>())
		{
			target.GetComponent<Renderer>().material.color = array[3];
		}
		else if ((bool)target.GetComponent<Light>())
		{
			target.GetComponent<Light>().color = array[3];
		}
	}

	public static void ColorUpdate(GameObject target, Color color, float time)
	{
		ColorUpdate(target, Hash("color", color, "time", time));
	}

	public static void AudioUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector2[] array = new Vector2[4];
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		AudioSource audioSource;
		if (args.Contains("audiosource"))
		{
			audioSource = (AudioSource)args["audiosource"];
		}
		else
		{
			if (!target.GetComponent(typeof(AudioSource)))
			{
				Debug.LogError("iTween Error: AudioUpdate requires an AudioSource.");
				return;
			}
			audioSource = target.GetComponent<AudioSource>();
		}
		ref Vector2 reference = ref array[0];
		ref Vector2 reference2 = ref array[1];
		reference = (reference2 = new Vector2(audioSource.volume, audioSource.pitch));
		if (args.Contains("volume"))
		{
			array[1].x = (float)args["volume"];
		}
		if (args.Contains("pitch"))
		{
			array[1].y = (float)args["pitch"];
		}
		array[3].x = Mathf.SmoothDampAngle(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDampAngle(array[0].y, array[1].y, ref array[2].y, num);
		audioSource.volume = array[3].x;
		audioSource.pitch = array[3].y;
	}

	public static void AudioUpdate(GameObject target, float volume, float pitch, float time)
	{
		AudioUpdate(target, Hash("volume", volume, "pitch", pitch, "time", time));
	}

	public static void RotateUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[4];
		Vector3 eulerAngles = target.transform.eulerAngles;
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		bool flag = ((!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]));
		if (flag)
		{
			ref Vector3 reference = ref array[0];
			reference = target.transform.localEulerAngles;
		}
		else
		{
			ref Vector3 reference2 = ref array[0];
			reference2 = target.transform.eulerAngles;
		}
		if (args.Contains("rotation"))
		{
			if (args["rotation"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["rotation"];
				ref Vector3 reference3 = ref array[1];
				reference3 = transform.eulerAngles;
			}
			else if (args["rotation"].GetType() == typeof(Vector3))
			{
				ref Vector3 reference4 = ref array[1];
				reference4 = (Vector3)args["rotation"];
			}
		}
		array[3].x = Mathf.SmoothDampAngle(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDampAngle(array[0].y, array[1].y, ref array[2].y, num);
		array[3].z = Mathf.SmoothDampAngle(array[0].z, array[1].z, ref array[2].z, num);
		if (flag)
		{
			target.transform.localEulerAngles = array[3];
		}
		else
		{
			target.transform.eulerAngles = array[3];
		}
		if (target.GetComponent<Rigidbody>() != null)
		{
			Vector3 eulerAngles2 = target.transform.eulerAngles;
			target.transform.eulerAngles = eulerAngles;
			target.GetComponent<Rigidbody>().MoveRotation(Quaternion.Euler(eulerAngles2));
		}
	}

	public static void RotateUpdate(GameObject target, Vector3 rotation, float time)
	{
		RotateUpdate(target, Hash("rotation", rotation, "time", time));
	}

	public static void ScaleUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[4];
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		ref Vector3 reference = ref array[0];
		ref Vector3 reference2 = ref array[1];
		reference = (reference2 = target.transform.localScale);
		if (args.Contains("scale"))
		{
			if (args["scale"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["scale"];
				ref Vector3 reference3 = ref array[1];
				reference3 = transform.localScale;
			}
			else if (args["scale"].GetType() == typeof(Vector3))
			{
				ref Vector3 reference4 = ref array[1];
				reference4 = (Vector3)args["scale"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				array[1].x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				array[1].y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				array[1].z = (float)args["z"];
			}
		}
		array[3].x = Mathf.SmoothDamp(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDamp(array[0].y, array[1].y, ref array[2].y, num);
		array[3].z = Mathf.SmoothDamp(array[0].z, array[1].z, ref array[2].z, num);
		target.transform.localScale = array[3];
	}

	public static void ScaleUpdate(GameObject target, Vector3 scale, float time)
	{
		ScaleUpdate(target, Hash("scale", scale, "time", time));
	}

	public static void MoveUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[4];
		Vector3 position = target.transform.position;
		float num;
		if (args.Contains("time"))
		{
			num = (float)args["time"];
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		bool flag = ((!args.Contains("islocal")) ? Defaults.isLocal : ((bool)args["islocal"]));
		if (flag)
		{
			ref Vector3 reference = ref array[0];
			ref Vector3 reference2 = ref array[1];
			reference = (reference2 = target.transform.localPosition);
		}
		else
		{
			ref Vector3 reference3 = ref array[0];
			ref Vector3 reference4 = ref array[1];
			reference3 = (reference4 = target.transform.position);
		}
		if (args.Contains("position"))
		{
			if (args["position"].GetType() == typeof(Transform))
			{
				Transform transform = (Transform)args["position"];
				ref Vector3 reference5 = ref array[1];
				reference5 = transform.position;
			}
			else if (args["position"].GetType() == typeof(Vector3))
			{
				ref Vector3 reference6 = ref array[1];
				reference6 = (Vector3)args["position"];
			}
		}
		else
		{
			if (args.Contains("x"))
			{
				array[1].x = (float)args["x"];
			}
			if (args.Contains("y"))
			{
				array[1].y = (float)args["y"];
			}
			if (args.Contains("z"))
			{
				array[1].z = (float)args["z"];
			}
		}
		array[3].x = Mathf.SmoothDamp(array[0].x, array[1].x, ref array[2].x, num);
		array[3].y = Mathf.SmoothDamp(array[0].y, array[1].y, ref array[2].y, num);
		array[3].z = Mathf.SmoothDamp(array[0].z, array[1].z, ref array[2].z, num);
		if (args.Contains("orienttopath") && (bool)args["orienttopath"])
		{
			args["looktarget"] = array[3];
		}
		if (args.Contains("looktarget"))
		{
			LookUpdate(target, args);
		}
		if (flag)
		{
			target.transform.localPosition = array[3];
		}
		else
		{
			target.transform.position = array[3];
		}
		if (target.GetComponent<Rigidbody>() != null)
		{
			Vector3 position2 = target.transform.position;
			target.transform.position = position;
			target.GetComponent<Rigidbody>().MovePosition(position2);
		}
	}

	public static void MoveUpdate(GameObject target, Vector3 position, float time)
	{
		MoveUpdate(target, Hash("position", position, "time", time));
	}

	public static void LookUpdate(GameObject target, Hashtable args)
	{
		CleanArgs(args);
		Vector3[] array = new Vector3[5];
		float num;
		if (args.Contains("looktime"))
		{
			num = (float)args["looktime"];
			num *= Defaults.updateTimePercentage;
		}
		else if (args.Contains("time"))
		{
			num = (float)args["time"] * 0.15f;
			num *= Defaults.updateTimePercentage;
		}
		else
		{
			num = Defaults.updateTime;
		}
		ref Vector3 reference = ref array[0];
		reference = target.transform.eulerAngles;
		if (args.Contains("looktarget"))
		{
			if (args["looktarget"].GetType() == typeof(Transform))
			{
				Transform obj = target.transform;
				Transform target2 = (Transform)args["looktarget"];
				Vector3? vector = (Vector3?)args["up"];
				obj.LookAt(target2, (!vector.HasValue) ? Defaults.up : vector.Value);
			}
			else if (args["looktarget"].GetType() == typeof(Vector3))
			{
				Transform obj2 = target.transform;
				Vector3 worldPosition = (Vector3)args["looktarget"];
				Vector3? vector2 = (Vector3?)args["up"];
				obj2.LookAt(worldPosition, (!vector2.HasValue) ? Defaults.up : vector2.Value);
			}
			ref Vector3 reference2 = ref array[1];
			reference2 = target.transform.eulerAngles;
			target.transform.eulerAngles = array[0];
			array[3].x = Mathf.SmoothDampAngle(array[0].x, array[1].x, ref array[2].x, num);
			array[3].y = Mathf.SmoothDampAngle(array[0].y, array[1].y, ref array[2].y, num);
			array[3].z = Mathf.SmoothDampAngle(array[0].z, array[1].z, ref array[2].z, num);
			target.transform.eulerAngles = array[3];
			if (args.Contains("axis"))
			{
				ref Vector3 reference3 = ref array[4];
				reference3 = target.transform.eulerAngles;
				switch ((string)args["axis"])
				{
				case "x":
					array[4].y = array[0].y;
					array[4].z = array[0].z;
					break;
				case "y":
					array[4].x = array[0].x;
					array[4].z = array[0].z;
					break;
				case "z":
					array[4].x = array[0].x;
					array[4].y = array[0].y;
					break;
				}
				target.transform.eulerAngles = array[4];
			}
		}
		else
		{
			Debug.LogError("iTween Error: LookUpdate needs a 'looktarget' property!");
		}
	}

	public static void LookUpdate(GameObject target, Vector3 looktarget, float time)
	{
		LookUpdate(target, Hash("looktarget", looktarget, "time", time));
	}

	public static float PathLength(Transform[] path)
	{
		Vector3[] array = new Vector3[path.Length];
		float num = 0f;
		for (int i = 0; i < path.Length; i++)
		{
			ref Vector3 reference = ref array[i];
			reference = path[i].position;
		}
		Vector3[] pts = PathControlPointGenerator(array);
		Vector3 a = Interp(pts, 0f);
		int num2 = path.Length * 20;
		for (int j = 1; j <= num2; j++)
		{
			float t = (float)j / (float)num2;
			Vector3 vector = Interp(pts, t);
			num += Vector3.Distance(a, vector);
			a = vector;
		}
		return num;
	}

	public static float PathLength(Vector3[] path)
	{
		float num = 0f;
		Vector3[] pts = PathControlPointGenerator(path);
		Vector3 a = Interp(pts, 0f);
		int num2 = path.Length * 20;
		for (int i = 1; i <= num2; i++)
		{
			float t = (float)i / (float)num2;
			Vector3 vector = Interp(pts, t);
			num += Vector3.Distance(a, vector);
			a = vector;
		}
		return num;
	}

	public static Texture2D CameraTexture(Color color)
	{
		Texture2D texture2D = new Texture2D(Screen.width, Screen.height, TextureFormat.ARGB32, mipmap: false);
		Color[] array = new Color[Screen.width * Screen.height];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = color;
		}
		texture2D.SetPixels(array);
		texture2D.Apply();
		return texture2D;
	}

	public static void PutOnPath(GameObject target, Vector3[] path, float percent)
	{
		target.transform.position = Interp(PathControlPointGenerator(path), percent);
	}

	public static void PutOnPath(Transform target, Vector3[] path, float percent)
	{
		target.position = Interp(PathControlPointGenerator(path), percent);
	}

	public static void PutOnPath(GameObject target, Transform[] path, float percent)
	{
		Vector3[] array = new Vector3[path.Length];
		for (int i = 0; i < path.Length; i++)
		{
			ref Vector3 reference = ref array[i];
			reference = path[i].position;
		}
		target.transform.position = Interp(PathControlPointGenerator(array), percent);
	}

	public static void PutOnPath(Transform target, Transform[] path, float percent)
	{
		Vector3[] array = new Vector3[path.Length];
		for (int i = 0; i < path.Length; i++)
		{
			ref Vector3 reference = ref array[i];
			reference = path[i].position;
		}
		target.position = Interp(PathControlPointGenerator(array), percent);
	}

	public static Vector3 PointOnPath(Transform[] path, float percent)
	{
		Vector3[] array = new Vector3[path.Length];
		for (int i = 0; i < path.Length; i++)
		{
			ref Vector3 reference = ref array[i];
			reference = path[i].position;
		}
		return Interp(PathControlPointGenerator(array), percent);
	}

	public static void DrawLine(Vector3[] line)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, Defaults.color, "gizmos");
		}
	}

	public static void DrawLine(Vector3[] line, Color color)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, color, "gizmos");
		}
	}

	public static void DrawLine(Transform[] line)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = line[i].position;
			}
			DrawLineHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawLine(Transform[] line, Color color)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = line[i].position;
			}
			DrawLineHelper(array, color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Vector3[] line)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, Defaults.color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Vector3[] line, Color color)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Transform[] line)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = line[i].position;
			}
			DrawLineHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawLineGizmos(Transform[] line, Color color)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = line[i].position;
			}
			DrawLineHelper(array, color, "gizmos");
		}
	}

	public static void DrawLineHandles(Vector3[] line)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, Defaults.color, "handles");
		}
	}

	public static void DrawLineHandles(Vector3[] line, Color color)
	{
		if (line.Length > 0)
		{
			DrawLineHelper(line, color, "handles");
		}
	}

	public static void DrawLineHandles(Transform[] line)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = line[i].position;
			}
			DrawLineHelper(array, Defaults.color, "handles");
		}
	}

	public static void DrawLineHandles(Transform[] line, Color color)
	{
		if (line.Length > 0)
		{
			Vector3[] array = new Vector3[line.Length];
			for (int i = 0; i < line.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = line[i].position;
			}
			DrawLineHelper(array, color, "handles");
		}
	}

	public static Vector3 PointOnPath(Vector3[] path, float percent)
	{
		return Interp(PathControlPointGenerator(path), percent);
	}

	public static void DrawPath(Vector3[] path)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, Defaults.color, "gizmos");
		}
	}

	public static void DrawPath(Vector3[] path, Color color)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, color, "gizmos");
		}
	}

	public static void DrawPath(Transform[] path)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = path[i].position;
			}
			DrawPathHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawPath(Transform[] path, Color color)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = path[i].position;
			}
			DrawPathHelper(array, color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Vector3[] path)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, Defaults.color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Vector3[] path, Color color)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Transform[] path)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = path[i].position;
			}
			DrawPathHelper(array, Defaults.color, "gizmos");
		}
	}

	public static void DrawPathGizmos(Transform[] path, Color color)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = path[i].position;
			}
			DrawPathHelper(array, color, "gizmos");
		}
	}

	public static void DrawPathHandles(Vector3[] path)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, Defaults.color, "handles");
		}
	}

	public static void DrawPathHandles(Vector3[] path, Color color)
	{
		if (path.Length > 0)
		{
			DrawPathHelper(path, color, "handles");
		}
	}

	public static void DrawPathHandles(Transform[] path)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = path[i].position;
			}
			DrawPathHelper(array, Defaults.color, "handles");
		}
	}

	public static void DrawPathHandles(Transform[] path, Color color)
	{
		if (path.Length > 0)
		{
			Vector3[] array = new Vector3[path.Length];
			for (int i = 0; i < path.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = path[i].position;
			}
			DrawPathHelper(array, color, "handles");
		}
	}

	public static void CameraFadeDepth(int depth)
	{
		if ((bool)cameraFade)
		{
			cameraFade.transform.position = new Vector3(cameraFade.transform.position.x, cameraFade.transform.position.y, depth);
		}
	}

	public static void CameraFadeDestroy()
	{
		if ((bool)cameraFade)
		{
			UnityEngine.Object.Destroy(cameraFade);
		}
	}

	public static void CameraFadeSwap(Texture2D texture)
	{
		if ((bool)cameraFade)
		{
			cameraFade.GetComponent<GUITexture>().texture = texture;
		}
	}

	public static GameObject CameraFadeAdd(Texture2D texture, int depth)
	{
		if ((bool)cameraFade)
		{
			return null;
		}
		cameraFade = new GameObject("iTween Camera Fade");
		cameraFade.transform.position = new Vector3(0.5f, 0.5f, depth);
		cameraFade.AddComponent<GUITexture>();
		cameraFade.GetComponent<GUITexture>().texture = texture;
		cameraFade.GetComponent<GUITexture>().color = new Color(0.5f, 0.5f, 0.5f, 0f);
		return cameraFade;
	}

	public static GameObject CameraFadeAdd(Texture2D texture)
	{
		if ((bool)cameraFade)
		{
			return null;
		}
		cameraFade = new GameObject("iTween Camera Fade");
		cameraFade.transform.position = new Vector3(0.5f, 0.5f, Defaults.cameraFadeDepth);
		cameraFade.AddComponent<GUITexture>();
		cameraFade.GetComponent<GUITexture>().texture = texture;
		cameraFade.GetComponent<GUITexture>().color = new Color(0.5f, 0.5f, 0.5f, 0f);
		return cameraFade;
	}

	public static GameObject CameraFadeAdd()
	{
		if ((bool)cameraFade)
		{
			return null;
		}
		cameraFade = new GameObject("iTween Camera Fade");
		cameraFade.transform.position = new Vector3(0.5f, 0.5f, Defaults.cameraFadeDepth);
		cameraFade.AddComponent<GUITexture>();
		cameraFade.GetComponent<GUITexture>().texture = CameraTexture(Color.black);
		cameraFade.GetComponent<GUITexture>().color = new Color(0.5f, 0.5f, 0.5f, 0f);
		return cameraFade;
	}

	public static void Resume(GameObject target)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			iTween2.enabled = true;
		}
	}

	public static void Resume(GameObject target, bool includechildren)
	{
		Resume(target);
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Resume(item.gameObject, includechildren: true);
		}
	}

	public static void Resume(GameObject target, string type)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			string text = iTween2.type + iTween2.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				iTween2.enabled = true;
			}
		}
	}

	public static void Resume(GameObject target, string type, bool includechildren)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			string text = iTween2.type + iTween2.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				iTween2.enabled = true;
			}
		}
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Resume(item.gameObject, type, includechildren: true);
		}
	}

	public static void Resume()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			GameObject target = (GameObject)hashtable["target"];
			Resume(target);
		}
	}

	public static void Resume(string type)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			GameObject value = (GameObject)hashtable["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			Resume((GameObject)arrayList[j], type);
		}
	}

	public static void Pause(GameObject target)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			if (iTween2.delay > 0f)
			{
				iTween2.delay -= Time.time - iTween2.delayStarted;
				iTween2.StopCoroutine("TweenDelay");
			}
			iTween2.isPaused = true;
			iTween2.enabled = false;
		}
	}

	public static void Pause(GameObject target, bool includechildren)
	{
		Pause(target);
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Pause(item.gameObject, includechildren: true);
		}
	}

	public static void Pause(GameObject target, string type)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			string text = iTween2.type + iTween2.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				if (iTween2.delay > 0f)
				{
					iTween2.delay -= Time.time - iTween2.delayStarted;
					iTween2.StopCoroutine("TweenDelay");
				}
				iTween2.isPaused = true;
				iTween2.enabled = false;
			}
		}
	}

	public static void Pause(GameObject target, string type, bool includechildren)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			string text = iTween2.type + iTween2.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				if (iTween2.delay > 0f)
				{
					iTween2.delay -= Time.time - iTween2.delayStarted;
					iTween2.StopCoroutine("TweenDelay");
				}
				iTween2.isPaused = true;
				iTween2.enabled = false;
			}
		}
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Pause(item.gameObject, type, includechildren: true);
		}
	}

	public static void Pause()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			GameObject target = (GameObject)hashtable["target"];
			Pause(target);
		}
	}

	public static void Pause(string type)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			GameObject value = (GameObject)hashtable["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			Pause((GameObject)arrayList[j], type);
		}
	}

	public static int Count()
	{
		return tweens.Count;
	}

	public static int Count(string type)
	{
		int num = 0;
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			string text = (string)hashtable["type"] + (string)hashtable["method"];
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				num++;
			}
		}
		return num;
	}

	public static int Count(GameObject target)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		return components.Length;
	}

	public static int Count(GameObject target, string type)
	{
		int num = 0;
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			string text = iTween2.type + iTween2.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				num++;
			}
		}
		return num;
	}

	public static void Stop()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			GameObject target = (GameObject)hashtable["target"];
			Stop(target);
		}
		tweens.Clear();
	}

	public static void Stop(string type)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			GameObject value = (GameObject)hashtable["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			Stop((GameObject)arrayList[j], type);
		}
	}

	public static void StopByName(string name)
	{
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			GameObject value = (GameObject)hashtable["target"];
			arrayList.Insert(arrayList.Count, value);
		}
		for (int j = 0; j < arrayList.Count; j++)
		{
			StopByName((GameObject)arrayList[j], name);
		}
	}

	public static void Stop(GameObject target)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			iTween2.Dispose();
		}
	}

	public static void Stop(GameObject target, bool includechildren)
	{
		Stop(target);
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Stop(item.gameObject, includechildren: true);
		}
	}

	public static void Stop(GameObject target, string type)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			string text = iTween2.type + iTween2.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				iTween2.Dispose();
			}
		}
	}

	public static void StopByName(GameObject target, string name)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			if (iTween2._name == name)
			{
				iTween2.Dispose();
			}
		}
	}

	public static void Stop(GameObject target, string type, bool includechildren)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			string text = iTween2.type + iTween2.method;
			text = text.Substring(0, type.Length);
			if (text.ToLower() == type.ToLower())
			{
				iTween2.Dispose();
			}
		}
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			Stop(item.gameObject, type, includechildren: true);
		}
	}

	public static void StopByName(GameObject target, string name, bool includechildren)
	{
		Component[] components = target.GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			if (iTween2._name == name)
			{
				iTween2.Dispose();
			}
		}
		if (!includechildren)
		{
			return;
		}
		foreach (Transform item in target.transform)
		{
			StopByName(item.gameObject, name, includechildren: true);
		}
	}

	public static Hashtable Hash(params object[] args)
	{
		Hashtable hashtable = new Hashtable(args.Length / 2);
		if (args.Length % 2 != 0)
		{
			Debug.LogError("Tween Error: Hash requires an even number of arguments!");
			return null;
		}
		for (int i = 0; i < args.Length - 1; i += 2)
		{
			hashtable.Add(args[i], args[i + 1]);
		}
		return hashtable;
	}

	private void Awake()
	{
		RetrieveArgs();
		lastRealTime = Time.realtimeSinceStartup;
	}

	private IEnumerator Start()
	{
		if (delay > 0f)
		{
			yield return StartCoroutine("TweenDelay");
		}
		TweenStart();
	}

	private void Update()
	{
		if (!isRunning || physics)
		{
			return;
		}
		if (!reverse)
		{
			if (percentage < 1f)
			{
				TweenUpdate();
			}
			else
			{
				TweenComplete();
			}
		}
		else if (percentage > 0f)
		{
			TweenUpdate();
		}
		else
		{
			TweenComplete();
		}
	}

	private void FixedUpdate()
	{
		if (!isRunning || !physics)
		{
			return;
		}
		if (!reverse)
		{
			if (percentage < 1f)
			{
				TweenUpdate();
			}
			else
			{
				TweenComplete();
			}
		}
		else if (percentage > 0f)
		{
			TweenUpdate();
		}
		else
		{
			TweenComplete();
		}
	}

	private void LateUpdate()
	{
		if (tweenArguments.Contains("looktarget") && isRunning && (type == "move" || type == "shake" || type == "punch"))
		{
			LookUpdate(base.gameObject, tweenArguments);
		}
	}

	private void OnEnable()
	{
		if (isRunning)
		{
			EnableKinematic();
		}
		if (isPaused)
		{
			isPaused = false;
			if (delay > 0f)
			{
				wasPaused = true;
				ResumeDelay();
			}
		}
	}

	private void OnDisable()
	{
		DisableKinematic();
	}

	private static void DrawLineHelper(Vector3[] line, Color color, string method)
	{
		Gizmos.color = color;
		for (int i = 0; i < line.Length - 1; i++)
		{
			if (method == "gizmos")
			{
				Gizmos.DrawLine(line[i], line[i + 1]);
			}
			else if (method == "handles")
			{
				Debug.LogError("iTween Error: Drawing a line with Handles is temporarily disabled because of compatability issues with Unity 2.6!");
			}
		}
	}

	private static void DrawPathHelper(Vector3[] path, Color color, string method)
	{
		Vector3[] pts = PathControlPointGenerator(path);
		Vector3 to = Interp(pts, 0f);
		Gizmos.color = color;
		int num = path.Length * 20;
		for (int i = 1; i <= num; i++)
		{
			float t = (float)i / (float)num;
			Vector3 vector = Interp(pts, t);
			if (method == "gizmos")
			{
				Gizmos.DrawLine(vector, to);
			}
			else if (method == "handles")
			{
				Debug.LogError("iTween Error: Drawing a path with Handles is temporarily disabled because of compatability issues with Unity 2.6!");
			}
			to = vector;
		}
	}

	private static Vector3[] PathControlPointGenerator(Vector3[] path)
	{
		int num = 2;
		Vector3[] array = new Vector3[path.Length + num];
		Array.Copy(path, 0, array, 1, path.Length);
		ref Vector3 reference = ref array[0];
		reference = array[1] + (array[1] - array[2]);
		ref Vector3 reference2 = ref array[array.Length - 1];
		reference2 = array[array.Length - 2] + (array[array.Length - 2] - array[array.Length - 3]);
		if (array[1] == array[array.Length - 2])
		{
			Vector3[] array2 = new Vector3[array.Length];
			Array.Copy(array, array2, array.Length);
			ref Vector3 reference3 = ref array2[0];
			reference3 = array2[array2.Length - 3];
			ref Vector3 reference4 = ref array2[array2.Length - 1];
			reference4 = array2[2];
			array = new Vector3[array2.Length];
			Array.Copy(array2, array, array2.Length);
		}
		return array;
	}

	private static Vector3 Interp(Vector3[] pts, float t)
	{
		int num = pts.Length - 3;
		int num2 = Mathf.Min(Mathf.FloorToInt(t * (float)num), num - 1);
		float num3 = t * (float)num - (float)num2;
		Vector3 vector = pts[num2];
		Vector3 vector2 = pts[num2 + 1];
		Vector3 vector3 = pts[num2 + 2];
		Vector3 vector4 = pts[num2 + 3];
		return 0.5f * ((-vector + 3f * vector2 - 3f * vector3 + vector4) * (num3 * num3 * num3) + (2f * vector - 5f * vector2 + 4f * vector3 - vector4) * (num3 * num3) + (-vector + vector3) * num3 + 2f * vector2);
	}

	private static void Launch(GameObject target, Hashtable args)
	{
		if (!args.Contains("id"))
		{
			args["id"] = GenerateID();
		}
		if (!args.Contains("target"))
		{
			args["target"] = target;
		}
		tweens.Insert(0, args);
		target.AddComponent<iTween>();
	}

	private static Hashtable CleanArgs(Hashtable args)
	{
		Hashtable hashtable = new Hashtable(args.Count);
		Hashtable hashtable2 = new Hashtable(args.Count);
		foreach (DictionaryEntry arg in args)
		{
			hashtable.Add(arg.Key, arg.Value);
		}
		foreach (DictionaryEntry item in hashtable)
		{
			if (item.Value.GetType() == typeof(int))
			{
				int num = (int)item.Value;
				float num2 = num;
				args[item.Key] = num2;
			}
			if (item.Value.GetType() == typeof(double))
			{
				double num3 = (double)item.Value;
				float num4 = (float)num3;
				args[item.Key] = num4;
			}
		}
		foreach (DictionaryEntry arg2 in args)
		{
			hashtable2.Add(arg2.Key.ToString().ToLower(), arg2.Value);
		}
		args = hashtable2;
		return args;
	}

	private static string GenerateID()
	{
		int num = 15;
		char[] array = new char[61]
		{
			'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
			'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
			'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D',
			'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
			'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
			'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7',
			'8'
		};
		int max = array.Length - 1;
		string text = string.Empty;
		for (int i = 0; i < num; i++)
		{
			text += array[(int)Mathf.Floor(UnityEngine.Random.Range(0, max))];
		}
		return text;
	}

	private void RetrieveArgs()
	{
		foreach (Hashtable tween in tweens)
		{
			if ((GameObject)tween["target"] == base.gameObject)
			{
				tweenArguments = tween;
				break;
			}
		}
		id = (string)tweenArguments["id"];
		type = (string)tweenArguments["type"];
		_name = (string)tweenArguments["name"];
		method = (string)tweenArguments["method"];
		if (tweenArguments.Contains("time"))
		{
			time = (float)tweenArguments["time"];
		}
		else
		{
			time = Defaults.time;
		}
		if (GetComponent<Rigidbody>() != null)
		{
			physics = true;
		}
		if (tweenArguments.Contains("delay"))
		{
			delay = (float)tweenArguments["delay"];
		}
		else
		{
			delay = Defaults.delay;
		}
		if (tweenArguments.Contains("namedcolorvalue"))
		{
			if (tweenArguments["namedcolorvalue"].GetType() == typeof(NamedValueColor))
			{
				namedcolorvalue = (NamedValueColor)tweenArguments["namedcolorvalue"];
			}
			else
			{
				try
				{
					namedcolorvalue = (NamedValueColor)Enum.Parse(typeof(NamedValueColor), (string)tweenArguments["namedcolorvalue"], ignoreCase: true);
				}
				catch
				{
					Debug.LogWarning("iTween: Unsupported namedcolorvalue supplied! Default will be used.");
					namedcolorvalue = NamedValueColor._Color;
				}
			}
		}
		else
		{
			namedcolorvalue = Defaults.namedColorValue;
		}
		if (tweenArguments.Contains("looptype"))
		{
			if (tweenArguments["looptype"].GetType() == typeof(LoopType))
			{
				loopType = (LoopType)tweenArguments["looptype"];
			}
			else
			{
				try
				{
					loopType = (LoopType)Enum.Parse(typeof(LoopType), (string)tweenArguments["looptype"], ignoreCase: true);
				}
				catch
				{
					Debug.LogWarning("iTween: Unsupported loopType supplied! Default will be used.");
					loopType = LoopType.none;
				}
			}
		}
		else
		{
			loopType = LoopType.none;
		}
		if (tweenArguments.Contains("easetype"))
		{
			if (tweenArguments["easetype"].GetType() == typeof(EaseType))
			{
				easeType = (EaseType)tweenArguments["easetype"];
			}
			else
			{
				try
				{
					easeType = (EaseType)Enum.Parse(typeof(EaseType), (string)tweenArguments["easetype"], ignoreCase: true);
				}
				catch
				{
					Debug.LogWarning("iTween: Unsupported easeType supplied! Default will be used.");
					easeType = Defaults.easeType;
				}
			}
		}
		else
		{
			easeType = Defaults.easeType;
		}
		if (tweenArguments.Contains("space"))
		{
			if (tweenArguments["space"].GetType() == typeof(Space))
			{
				space = (Space)tweenArguments["space"];
			}
			else
			{
				try
				{
					space = (Space)Enum.Parse(typeof(Space), (string)tweenArguments["space"], ignoreCase: true);
				}
				catch
				{
					Debug.LogWarning("iTween: Unsupported space supplied! Default will be used.");
					space = Defaults.space;
				}
			}
		}
		else
		{
			space = Defaults.space;
		}
		if (tweenArguments.Contains("islocal"))
		{
			isLocal = (bool)tweenArguments["islocal"];
		}
		else
		{
			isLocal = Defaults.isLocal;
		}
		if (tweenArguments.Contains("ignoretimescale"))
		{
			useRealTime = (bool)tweenArguments["ignoretimescale"];
		}
		else
		{
			useRealTime = Defaults.useRealTime;
		}
		GetEasingFunction();
	}

	private void GetEasingFunction()
	{
		switch (easeType)
		{
		case EaseType.easeInQuad:
			ease = easeInQuad;
			break;
		case EaseType.easeOutQuad:
			ease = easeOutQuad;
			break;
		case EaseType.easeInOutQuad:
			ease = easeInOutQuad;
			break;
		case EaseType.easeInCubic:
			ease = easeInCubic;
			break;
		case EaseType.easeOutCubic:
			ease = easeOutCubic;
			break;
		case EaseType.easeInOutCubic:
			ease = easeInOutCubic;
			break;
		case EaseType.easeInQuart:
			ease = easeInQuart;
			break;
		case EaseType.easeOutQuart:
			ease = easeOutQuart;
			break;
		case EaseType.easeInOutQuart:
			ease = easeInOutQuart;
			break;
		case EaseType.easeInQuint:
			ease = easeInQuint;
			break;
		case EaseType.easeOutQuint:
			ease = easeOutQuint;
			break;
		case EaseType.easeInOutQuint:
			ease = easeInOutQuint;
			break;
		case EaseType.easeInSine:
			ease = easeInSine;
			break;
		case EaseType.easeOutSine:
			ease = easeOutSine;
			break;
		case EaseType.easeInOutSine:
			ease = easeInOutSine;
			break;
		case EaseType.easeInExpo:
			ease = easeInExpo;
			break;
		case EaseType.easeOutExpo:
			ease = easeOutExpo;
			break;
		case EaseType.easeInOutExpo:
			ease = easeInOutExpo;
			break;
		case EaseType.easeInCirc:
			ease = easeInCirc;
			break;
		case EaseType.easeOutCirc:
			ease = easeOutCirc;
			break;
		case EaseType.easeInOutCirc:
			ease = easeInOutCirc;
			break;
		case EaseType.linear:
			ease = linear;
			break;
		case EaseType.spring:
			ease = spring;
			break;
		case EaseType.easeInBounce:
			ease = easeInBounce;
			break;
		case EaseType.easeOutBounce:
			ease = easeOutBounce;
			break;
		case EaseType.easeInOutBounce:
			ease = easeInOutBounce;
			break;
		case EaseType.easeInBack:
			ease = easeInBack;
			break;
		case EaseType.easeOutBack:
			ease = easeOutBack;
			break;
		case EaseType.easeInOutBack:
			ease = easeInOutBack;
			break;
		case EaseType.easeInElastic:
			ease = easeInElastic;
			break;
		case EaseType.easeOutElastic:
			ease = easeOutElastic;
			break;
		case EaseType.easeInOutElastic:
			ease = easeInOutElastic;
			break;
		}
	}

	private void UpdatePercentage()
	{
		if (useRealTime)
		{
			runningTime += Time.realtimeSinceStartup - lastRealTime;
		}
		else
		{
			runningTime += Time.deltaTime;
		}
		if (reverse)
		{
			percentage = 1f - runningTime / time;
		}
		else
		{
			percentage = runningTime / time;
		}
		lastRealTime = Time.realtimeSinceStartup;
	}

	private void CallBack(string callbackType)
	{
		if (tweenArguments.Contains(callbackType) && !tweenArguments.Contains("ischild"))
		{
			GameObject gameObject = ((!tweenArguments.Contains(callbackType + "target")) ? base.gameObject : ((GameObject)tweenArguments[callbackType + "target"]));
			if (tweenArguments[callbackType].GetType() == typeof(string))
			{
				gameObject.SendMessage((string)tweenArguments[callbackType], tweenArguments[callbackType + "params"], SendMessageOptions.DontRequireReceiver);
				return;
			}
			Debug.LogError("iTween Error: Callback method references must be passed as a String!");
			UnityEngine.Object.Destroy(this);
		}
	}

	private void Dispose()
	{
		for (int i = 0; i < tweens.Count; i++)
		{
			Hashtable hashtable = (Hashtable)tweens[i];
			if ((string)hashtable["id"] == id)
			{
				tweens.RemoveAt(i);
				break;
			}
		}
		UnityEngine.Object.Destroy(this);
	}

	private void ConflictCheck()
	{
		Component[] components = GetComponents(typeof(iTween));
		Component[] array = components;
		for (int i = 0; i < array.Length; i++)
		{
			iTween iTween2 = (iTween)array[i];
			if (iTween2.type == "value")
			{
				break;
			}
			if (!iTween2.isRunning || !(iTween2.type == type))
			{
				continue;
			}
			if (iTween2.method != method)
			{
				break;
			}
			if (iTween2.tweenArguments.Count != tweenArguments.Count)
			{
				iTween2.Dispose();
				break;
			}
			foreach (DictionaryEntry tweenArgument in tweenArguments)
			{
				if (!iTween2.tweenArguments.Contains(tweenArgument.Key))
				{
					iTween2.Dispose();
					return;
				}
				if (!iTween2.tweenArguments[tweenArgument.Key].Equals(tweenArguments[tweenArgument.Key]) && (string)tweenArgument.Key != "id")
				{
					iTween2.Dispose();
					return;
				}
			}
			Dispose();
		}
	}

	private void EnableKinematic()
	{
	}

	private void DisableKinematic()
	{
	}

	private void ResumeDelay()
	{
		StartCoroutine("TweenDelay");
	}

	private float linear(float start, float end, float value)
	{
		return Mathf.Lerp(start, end, value);
	}

	private float clerp(float start, float end, float value)
	{
		float num = 0f;
		float num2 = 360f;
		float num3 = Mathf.Abs((num2 - num) / 2f);
		float num4 = 0f;
		float num5 = 0f;
		if (end - start < 0f - num3)
		{
			num5 = (num2 - start + end) * value;
			return start + num5;
		}
		if (end - start > num3)
		{
			num5 = (0f - (num2 - end + start)) * value;
			return start + num5;
		}
		return start + (end - start) * value;
	}

	private float spring(float start, float end, float value)
	{
		value = Mathf.Clamp01(value);
		value = (Mathf.Sin(value * (float)Math.PI * (0.2f + 2.5f * value * value * value)) * Mathf.Pow(1f - value, 2.2f) + value) * (1f + 1.2f * (1f - value));
		return start + (end - start) * value;
	}

	private float easeInQuad(float start, float end, float value)
	{
		end -= start;
		return end * value * value + start;
	}

	private float easeOutQuad(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * value * (value - 2f) + start;
	}

	private float easeInOutQuad(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end / 2f * value * value + start;
		}
		value -= 1f;
		return (0f - end) / 2f * (value * (value - 2f) - 1f) + start;
	}

	private float easeInCubic(float start, float end, float value)
	{
		end -= start;
		return end * value * value * value + start;
	}

	private float easeOutCubic(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return end * (value * value * value + 1f) + start;
	}

	private float easeInOutCubic(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end / 2f * value * value * value + start;
		}
		value -= 2f;
		return end / 2f * (value * value * value + 2f) + start;
	}

	private float easeInQuart(float start, float end, float value)
	{
		end -= start;
		return end * value * value * value * value + start;
	}

	private float easeOutQuart(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return (0f - end) * (value * value * value * value - 1f) + start;
	}

	private float easeInOutQuart(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end / 2f * value * value * value * value + start;
		}
		value -= 2f;
		return (0f - end) / 2f * (value * value * value * value - 2f) + start;
	}

	private float easeInQuint(float start, float end, float value)
	{
		end -= start;
		return end * value * value * value * value * value + start;
	}

	private float easeOutQuint(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return end * (value * value * value * value * value + 1f) + start;
	}

	private float easeInOutQuint(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end / 2f * value * value * value * value * value + start;
		}
		value -= 2f;
		return end / 2f * (value * value * value * value * value + 2f) + start;
	}

	private float easeInSine(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * Mathf.Cos(value / 1f * ((float)Math.PI / 2f)) + end + start;
	}

	private float easeOutSine(float start, float end, float value)
	{
		end -= start;
		return end * Mathf.Sin(value / 1f * ((float)Math.PI / 2f)) + start;
	}

	private float easeInOutSine(float start, float end, float value)
	{
		end -= start;
		return (0f - end) / 2f * (Mathf.Cos((float)Math.PI * value / 1f) - 1f) + start;
	}

	private float easeInExpo(float start, float end, float value)
	{
		end -= start;
		return end * Mathf.Pow(2f, 10f * (value / 1f - 1f)) + start;
	}

	private float easeOutExpo(float start, float end, float value)
	{
		end -= start;
		return end * (0f - Mathf.Pow(2f, -10f * value / 1f) + 1f) + start;
	}

	private float easeInOutExpo(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end / 2f * Mathf.Pow(2f, 10f * (value - 1f)) + start;
		}
		value -= 1f;
		return end / 2f * (0f - Mathf.Pow(2f, -10f * value) + 2f) + start;
	}

	private float easeInCirc(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * (Mathf.Sqrt(1f - value * value) - 1f) + start;
	}

	private float easeOutCirc(float start, float end, float value)
	{
		value -= 1f;
		end -= start;
		return end * Mathf.Sqrt(1f - value * value) + start;
	}

	private float easeInOutCirc(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return (0f - end) / 2f * (Mathf.Sqrt(1f - value * value) - 1f) + start;
		}
		value -= 2f;
		return end / 2f * (Mathf.Sqrt(1f - value * value) + 1f) + start;
	}

	private float easeInBounce(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		return end - easeOutBounce(0f, end, num - value) + start;
	}

	private float easeOutBounce(float start, float end, float value)
	{
		value /= 1f;
		end -= start;
		if (value < 0.36363637f)
		{
			return end * (7.5625f * value * value) + start;
		}
		if (value < 0.72727275f)
		{
			value -= 0.54545456f;
			return end * (7.5625f * value * value + 0.75f) + start;
		}
		if ((double)value < 0.9090909090909091)
		{
			value -= 0.8181818f;
			return end * (7.5625f * value * value + 0.9375f) + start;
		}
		value -= 21f / 22f;
		return end * (7.5625f * value * value + 63f / 64f) + start;
	}

	private float easeInOutBounce(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		if (value < num / 2f)
		{
			return easeInBounce(0f, end, value * 2f) * 0.5f + start;
		}
		return easeOutBounce(0f, end, value * 2f - num) * 0.5f + end * 0.5f + start;
	}

	private float easeInBack(float start, float end, float value)
	{
		end -= start;
		value /= 1f;
		float num = 1.70158f;
		return end * value * value * ((num + 1f) * value - num) + start;
	}

	private float easeOutBack(float start, float end, float value)
	{
		float num = 1.70158f;
		end -= start;
		value = value / 1f - 1f;
		return end * (value * value * ((num + 1f) * value + num) + 1f) + start;
	}

	private float easeInOutBack(float start, float end, float value)
	{
		float num = 1.70158f;
		end -= start;
		value /= 0.5f;
		if (value < 1f)
		{
			num *= 1.525f;
			return end / 2f * (value * value * ((num + 1f) * value - num)) + start;
		}
		value -= 2f;
		num *= 1.525f;
		return end / 2f * (value * value * ((num + 1f) * value + num) + 2f) + start;
	}

	private float punch(float amplitude, float value)
	{
		float num = 9f;
		if (value == 0f)
		{
			return 0f;
		}
		if (value == 1f)
		{
			return 0f;
		}
		float num2 = 0.3f;
		num = num2 / ((float)Math.PI * 2f) * Mathf.Asin(0f);
		return amplitude * Mathf.Pow(2f, -10f * value) * Mathf.Sin((value * 1f - num) * ((float)Math.PI * 2f) / num2);
	}

	private float easeInElastic(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		float num4 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		if (num4 == 0f || num4 < Mathf.Abs(end))
		{
			num4 = end;
			num3 = num2 / 4f;
		}
		else
		{
			num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
		}
		return 0f - num4 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) + start;
	}

	private float easeOutElastic(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		float num4 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		if (num4 == 0f || num4 < Mathf.Abs(end))
		{
			num4 = end;
			num3 = num2 / 4f;
		}
		else
		{
			num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
		}
		return num4 * Mathf.Pow(2f, -10f * value) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) + end + start;
	}

	private float easeInOutElastic(float start, float end, float value)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f;
		float num3 = 0f;
		float num4 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num / 2f) == 2f)
		{
			return start + end;
		}
		if (num4 == 0f || num4 < Mathf.Abs(end))
		{
			num4 = end;
			num3 = num2 / 4f;
		}
		else
		{
			num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
		}
		if (value < 1f)
		{
			return -0.5f * (num4 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2)) + start;
		}
		return num4 * Mathf.Pow(2f, -10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) * 0.5f + end + start;
	}
}
public static class iT
{
	public static class CameraFadeFrom
	{
		public const string amount = "amount";

		public const string time = "time";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class CameraFadeTo
	{
		public const string amount = "amount";

		public const string time = "time";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class ValueTo
	{
		public const string from = "from";

		public const string to = "to";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class FadeFrom
	{
		public const string alpha = "alpha";

		public const string amount = "amount";

		public const string includechildren = "includechildren";

		public const string time = "time";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class FadeTo
	{
		public const string alpha = "alpha";

		public const string amount = "amount";

		public const string includechildren = "includechildren";

		public const string time = "time";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class ColorFrom
	{
		public const string color = "color";

		public const string r = "r";

		public const string g = "g";

		public const string b = "b";

		public const string a = "a";

		public const string namedcolorvalue = "namedcolorvalue";

		public const string includechildren = "includechildren";

		public const string time = "time";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class ColorTo
	{
		public const string color = "color";

		public const string r = "r";

		public const string g = "g";

		public const string b = "b";

		public const string a = "a";

		public const string namedcolorvalue = "namedcolorvalue";

		public const string includechildren = "includechildren";

		public const string time = "time";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class AudioFrom
	{
		public const string audiosource = "audiosource";

		public const string volume = "volume";

		public const string pitch = "pitch";

		public const string time = "time";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class AudioTo
	{
		public const string audiosource = "audiosource";

		public const string volume = "volume";

		public const string pitch = "pitch";

		public const string time = "time";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class Stab
	{
		public const string audioclip = "audioclip";

		public const string audiosource = "audiosource";

		public const string volume = "volume";

		public const string pitch = "pitch";

		public const string delay = "delay";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class LookFrom
	{
		public const string looktarget = "looktarget";

		public const string axis = "axis";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class LookTo
	{
		public const string looktarget = "looktarget";

		public const string axis = "axis";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class MoveTo
	{
		public const string position = "position";

		public const string path = "path";

		public const string movetopath = "movetopath";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string orienttopath = "orienttopath";

		public const string looktarget = "looktarget";

		public const string looktime = "looktime";

		public const string lookahead = "lookahead";

		public const string axis = "axis";

		public const string islocal = "islocal";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class MoveFrom
	{
		public const string position = "position";

		public const string path = "path";

		public const string movetopath = "movetopath";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string orienttopath = "orienttopath";

		public const string looktarget = "looktarget";

		public const string looktime = "looktime";

		public const string lookahead = "lookahead";

		public const string islocal = "islocal";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class MoveAdd
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string orienttopath = "orienttopath";

		public const string looktarget = "looktarget";

		public const string looktime = "looktime";

		public const string axis = "axis";

		public const string space = "space";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class MoveBy
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string orienttopath = "orienttopath";

		public const string looktarget = "looktarget";

		public const string looktime = "looktime";

		public const string axis = "axis";

		public const string space = "space";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class ScaleTo
	{
		public const string scale = "scale";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class ScaleFrom
	{
		public const string scale = "scale";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class ScaleAdd
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class ScaleBy
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class RotateTo
	{
		public const string rotation = "rotation";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string islocal = "islocal";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class RotateFrom
	{
		public const string rotation = "rotation";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string islocal = "islocal";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class RotateAdd
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string space = "space";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class RotateBy
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string space = "space";

		public const string islocal = "islocal";

		public const string time = "time";

		public const string speed = "speed";

		public const string delay = "delay";

		public const string easetype = "easetype";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class ShakePosition
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string space = "space";

		public const string orienttopath = "orienttopath";

		public const string looktarget = "looktarget";

		public const string looktime = "looktime";

		public const string time = "time";

		public const string delay = "delay";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class ShakeScale
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string time = "time";

		public const string delay = "delay";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class ShakeRotation
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string space = "space";

		public const string time = "time";

		public const string delay = "delay";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class PunchPosition
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string space = "space";

		public const string looktarget = "looktarget";

		public const string looktime = "looktime";

		public const string time = "time";

		public const string delay = "delay";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class PunchRotation
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string space = "space";

		public const string time = "time";

		public const string delay = "delay";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class PunchScale
	{
		public const string amount = "amount";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string time = "time";

		public const string delay = "delay";

		public const string looptype = "looptype";

		public const string onstart = "onstart";

		public const string onstarttarget = "onstarttarget";

		public const string onstartparams = "onstartparams";

		public const string onupdate = "onupdate";

		public const string onupdatetarget = "onupdatetarget";

		public const string onupdateparams = "onupdateparams";

		public const string oncomplete = "oncomplete";

		public const string oncompletetarget = "oncompletetarget";

		public const string oncompleteparams = "oncompleteparams";
	}

	public static class FadeUpdate
	{
		public const string alpha = "alpha";

		public const string includechildren = "includechildren";

		public const string time = "time";
	}

	public static class ColorUpdate
	{
		public const string color = "color";

		public const string r = "r";

		public const string g = "g";

		public const string b = "b";

		public const string a = "a";

		public const string namedcolorvalue = "namedcolorvalue";

		public const string includechildren = "includechildren";

		public const string time = "time";
	}

	public static class AudioUpdate
	{
		public const string audiosource = "audiosource";

		public const string volume = "volume";

		public const string pitch = "pitch";

		public const string time = "time";
	}

	public static class RotateUpdate
	{
		public const string rotation = "rotation";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string islocal = "islocal";

		public const string time = "time";
	}

	public static class ScaleUpdate
	{
		public const string scale = "scale";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string time = "time";
	}

	public static class MoveUpdate
	{
		public const string position = "position";

		public const string x = "x";

		public const string y = "y";

		public const string z = "z";

		public const string time = "time";

		public const string islocal = "islocal";

		public const string orienttopath = "orienttopath";

		public const string looktarget = "looktarget";

		public const string looktime = "looktime";

		public const string axis = "axis";
	}

	public static class LookUpdate
	{
		public const string looktarget = "looktarget";

		public const string axis = "axis";

		public const string time = "time";
	}
}
public class MoveSample : MonoBehaviour
{
	private void Start()
	{
		iTween.MoveBy(base.gameObject, iTween.Hash("x", 2, "easeType", "easeInOutExpo", "loopType", "pingPong", "delay", 0.1));
	}
}
public class RotateSample : MonoBehaviour
{
	private void Start()
	{
		iTween.RotateBy(base.gameObject, iTween.Hash("x", 0.25, "easeType", "easeInOutBack", "loopType", "pingPong", "delay", 0.4));
	}
}
public class SampleInfo : MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("iTween can spin, shake, punch, move, handle audio, fade color and transparency \nand much more with each task needing only one line of code.");
		GUILayout.BeginHorizontal();
		GUILayout.Label("iTween works with C#, JavaScript and Boo. For full documentation and examples visit:");
		if (GUILayout.Button("http://itween.pixelplacement.com"))
		{
			UnityEngine.Application.OpenURL("http://itween.pixelplacement.com");
		}
		GUILayout.EndHorizontal();
	}
}
[ExecuteInEditMode]
public class EffectScaler : MonoBehaviour
{
}
public class EffectLightsFade : MonoBehaviour
{
	public float totalTime;

	public float fadeInTime;

	public float fadeOutTime;

	private Light dynamicLight;

	private void Awake()
	{
		dynamicLight = GetComponent<Light>();
		if (!(dynamicLight != null))
		{
			return;
		}
		float intensity = dynamicLight.intensity;
		Animation component = GetComponent<Animation>();
		if (!(component == null))
		{
			return;
		}
		base.gameObject.AddComponent<Animation>();
		if (fadeInTime < 0f)
		{
			fadeInTime = 0f;
		}
		if (fadeInTime > totalTime)
		{
			fadeInTime = totalTime;
		}
		if (fadeOutTime < 0f)
		{
			fadeOutTime = 0f;
		}
		if (fadeOutTime > totalTime)
		{
			fadeOutTime = totalTime;
		}
		if (fadeInTime + fadeOutTime > totalTime)
		{
			fadeInTime = 0f;
		}
		List<Keyframe> list = new List<Keyframe>();
		if (fadeInTime != 0f)
		{
			AnimationCurve animationCurve = AnimationCurve.Linear(0f, 0f, fadeInTime, intensity);
			list.Add(animationCurve[0]);
			list.Add(animationCurve[1]);
		}
		if (fadeOutTime != 0f)
		{
			AnimationCurve animationCurve2 = AnimationCurve.Linear(totalTime - fadeOutTime, intensity, totalTime, 0f);
			if (fadeInTime == 0f || fadeInTime != totalTime - fadeOutTime)
			{
				list.Add(animationCurve2[0]);
			}
			else
			{
				Keyframe value = list[1];
				value.outTangent = animationCurve2[0].outTangent;
				list[1] = value;
			}
			list.Add(animationCurve2[1]);
		}
		AnimationCurve curve = new AnimationCurve(list.ToArray());
		AnimationClip animationClip = new AnimationClip();
		animationClip.SetCurve(string.Empty, typeof(Light), "m_Intensity", curve);
		GetComponent<Animation>().clip = animationClip;
		GetComponent<Animation>().clip.name = "light_fade";
		base.gameObject.SetActive(value: false);
		base.gameObject.SetActive(value: true);
	}

	private void Update()
	{
		Animation component = GetComponent<Animation>();
		if ((bool)component && !component.isPlaying && (bool)dynamicLight)
		{
			dynamicLight.enabled = false;
		}
	}

	private void OnEnable()
	{
		if ((bool)dynamicLight)
		{
			dynamicLight.enabled = true;
		}
	}

	private void Reset()
	{
		totalTime = 1f;
		fadeInTime = 0f;
		fadeOutTime = 1f;
	}
}
public class EffectNWayMotion : MonoBehaviour
{
	public int DirectionWay = 8;

	public Transform WayChild;

	public bool UseSpreadDirection;

	public int SpreadAngle = 120;

	public float StopEffectsTime;

	private GameObject effectRoot;

	private void CreateWayMotion()
	{
		if (WayChild == null)
		{
			Debug.Log("WayChild is Null!");
			return;
		}
		if (StopEffectsTime > 0f)
		{
			StopCoroutine("StopEffects");
			StartCoroutine(StopEffects(StopEffectsTime));
		}
		if (effectRoot == null)
		{
			effectRoot = new GameObject();
			effectRoot.name = "effectRoot(clone)";
			effectRoot.transform.parent = base.transform;
		}
		float num = 0f;
		if (!UseSpreadDirection)
		{
			WayChild.gameObject.SetActive(value: true);
			num = 360 / DirectionWay;
			for (int i = 1; i < DirectionWay; i++)
			{
				Quaternion rotation = Quaternion.Euler(new Vector3(0f, base.transform.localEulerAngles.y + num * (float)i, 0f));
				Transform transform = UnityEngine.Object.Instantiate(WayChild, base.transform.position, rotation);
				transform.parent = effectRoot.transform;
			}
			return;
		}
		WayChild.gameObject.SetActive(value: false);
		num = SpreadAngle / DirectionWay;
		for (int j = 0; j < DirectionWay; j++)
		{
			float num2 = 0f;
			if (DirectionWay % 2 == 0)
			{
				num2 = num / 2f;
			}
			Quaternion rotation2 = Quaternion.Euler(new Vector3(0f, base.transform.localEulerAngles.y + num2 + num * (float)(-DirectionWay / 2 + j), 0f));
			Transform transform2 = UnityEngine.Object.Instantiate(WayChild, base.transform.position, rotation2);
			transform2.parent = effectRoot.transform;
			transform2.gameObject.SetActive(value: true);
		}
	}

	private void OnEnable()
	{
		CreateWayMotion();
	}

	private void OnDisable()
	{
		if (effectRoot != null)
		{
			UnityEngine.Object.Destroy(effectRoot);
		}
	}

	private IEnumerator StopEffects(float waitTime)
	{
		yield return new WaitForSeconds(waitTime);
		WayChild.gameObject.SetActive(value: false);
		effectRoot.gameObject.SetActive(value: false);
		OnDisable();
	}
}
public class EffectPlay : MonoBehaviour
{
	public Transform surround_point;

	public Transform ground;

	public Transform[] effects = new Transform[1];

	private int effectIndex;

	private int goIndex;

	private int fpsNumber;

	private float repeatTime = 4f;

	private float timer;

	private float fpsTimer;

	private Transform effect;

	private float fps;

	private float fpsTotal;

	private bool isRepeat = true;

	private string effectName;

	private void Start()
	{
		InitEffect();
	}

	private void OnGUI()
	{
		GUILayout.Label("Effect Name : " + effectName.Replace("(Clone)", string.Empty));
		GUILayout.Label("Effect Index : " + effectIndex);
		GUILayout.Label("Total Effects : " + effects.Length);
		GUILayout.BeginHorizontal();
		if (GUILayout.Button("Go Effect Index", GUILayout.Width(120f)))
		{
			if (goIndex == effectIndex || goIndex < 0 || goIndex >= effects.Length)
			{
				return;
			}
			if (effect != null)
			{
				UnityEngine.Object.Destroy(effect.gameObject);
			}
			effectIndex = goIndex;
			InitEffect();
		}
		GUILayout.Label(" ==> ", GUILayout.Width(30f));
		goIndex = int.Parse(GUILayout.TextField(goIndex.ToString(), GUILayout.MaxWidth(50f)));
		GUILayout.EndHorizontal();
		GUILayout.BeginHorizontal();
		GUILayout.Label("Repeat Time : ", GUILayout.MaxWidth(85f));
		repeatTime = float.Parse(GUILayout.TextField(repeatTime.ToString(), GUILayout.MaxWidth(50f)));
		GUILayout.EndHorizontal();
		if (GUILayout.Button("Show/Hide Ground", GUILayout.Width(120f)) && ground != null)
		{
			ground.gameObject.SetActive(!ground.gameObject.activeSelf);
		}
		GUILayout.Space(6f);
		if (GUILayout.Button("Previous Effect", GUILayout.Width(120f)))
		{
			if (effect != null)
			{
				UnityEngine.Object.Destroy(effect.gameObject);
			}
			effectIndex--;
			if (effectIndex < 0)
			{
				effectIndex = effects.Length - 1;
			}
			InitEffect();
		}
		else if (GUILayout.Button("Next Effect", GUILayout.Width(120f)))
		{
			if (effect != null)
			{
				UnityEngine.Object.Destroy(effect.gameObject);
			}
			effectIndex++;
			if (effectIndex >= effects.Length)
			{
				effectIndex = 0;
			}
			InitEffect();
		}
		GUILayout.Space(6f);
		GUILayout.Label("fps = " + fps);
	}

	private void Update()
	{
		if (timer >= repeatTime && isRepeat)
		{
			if (effect != null)
			{
				effect.gameObject.SetActive(value: false);
				StartCoroutine(DelayActive(effect.gameObject));
			}
			timer = 0f;
		}
		else
		{
			timer += Time.deltaTime;
		}
		if (Time.time > fpsTimer)
		{
			fps = fpsTotal / (float)fpsNumber;
			fpsTimer = Time.time + 0.5f;
		}
		else
		{
			fpsTotal += 1f / Time.deltaTime;
			fpsNumber++;
		}
	}

	private void InitEffect()
	{
		effect = null;
		effect = effects[effectIndex];
		if (effect != null)
		{
			effect = UnityEngine.Object.Instantiate(effect);
			effect.gameObject.SetActive(value: true);
		}
		if (effectIndex >= 8 && effectIndex <= 28)
		{
			if (surround_point != null)
			{
				effect.parent = surround_point;
				if (effectIndex >= 8 && effectIndex <= 12)
				{
					effect.localPosition = new Vector3(0f, effect.localPosition.y, 0f);
				}
				else
				{
					effect.localPosition = Vector3.zero;
				}
				isRepeat = false;
			}
		}
		else if ((effectIndex >= 22 && effectIndex <= 24) || effectIndex >= 47)
		{
			isRepeat = false;
		}
		else
		{
			isRepeat = true;
		}
		if (effectIndex >= 38 && effectIndex <= 42)
		{
			effect.localEulerAngles = new Vector3(0f, -45f, 0f);
		}
		timer = 0f;
		effectName = effect.name;
	}

	private IEnumerator DelayActive(GameObject effect)
	{
		yield return new WaitForSeconds(0.1f);
		if (effect != null)
		{
			effect.SetActive(value: true);
		}
	}
}
[RequireComponent(typeof(LineRenderer))]
public class LineRenderContrl : MonoBehaviour
{
	public Transform Target;

	public Vector3 TargetOffset;

	public float TexMoverTotalTime = 1f;

	public float TexSheetTotalTime = 1f;

	public int TexSheetCount = 1;

	public int TexTilingVector = -1;

	public bool TexSheetRandom;

	public bool TexAutoDistanceDiv;

	public float TexDistanceDivValue = 4f;

	private LineRenderer lineRer;

	private GameObject lineRerTarget;

	private Material mat;

	private Vector2 texOffset;

	private float[] sheetCoordinates;

	private float timerMover;

	private float timerSheet;

	private int sheetIndex;

	private int texMoverVector = 1;

	private int texAutoDistDiv = 1;

	private void Awake()
	{
		lineRer = GetComponent<LineRenderer>();
		lineRer.SetVertexCount(2);
		lineRer.SetPosition(0, Vector3.zero);
		lineRer.useWorldSpace = false;
		mat = lineRer.materials[0];
		if ((bool)mat)
		{
			sheetCoordinates = new float[TexSheetCount];
			for (int i = 0; i < sheetCoordinates.Length; i++)
			{
				sheetCoordinates[i] = ((float)i + 1f) / (float)TexSheetCount;
			}
			mat.SetTextureScale("_MainTex", new Vector2(TexTilingVector, 1f / (float)TexSheetCount));
			lineRerTarget = new GameObject("lineRerTarget");
			lineRerTarget.transform.parent = base.transform;
		}
	}

	private void Update()
	{
		LineRenderer lineRenderer = lineRer;
		if ((bool)Target)
		{
			Transform transform = lineRerTarget.transform;
			transform.position = Target.position;
			lineRenderer.SetPosition(1, transform.localPosition + TargetOffset);
			if (TexAutoDistanceDiv)
			{
				float num = Vector3.Distance(transform.position, base.transform.position);
				if (num > TexDistanceDivValue)
				{
					texAutoDistDiv = (int)(num / TexDistanceDivValue);
				}
				else
				{
					texAutoDistDiv = 1;
				}
			}
		}
		Material material = mat;
		if (!material)
		{
			return;
		}
		if (timerMover >= TexMoverTotalTime)
		{
			timerMover = 0f;
			texOffset.x = 0f;
		}
		else
		{
			texOffset.x += (float)texMoverVector * Time.deltaTime / TexMoverTotalTime;
		}
		if (timerSheet >= TexSheetTotalTime / (float)TexSheetCount)
		{
			timerSheet = 0f;
			if (!TexSheetRandom)
			{
				if (sheetIndex == sheetCoordinates.Length)
				{
					sheetIndex = 0;
				}
				texOffset.y = sheetCoordinates[sheetIndex];
				sheetIndex++;
			}
			else
			{
				texOffset.y = sheetCoordinates[UnityEngine.Random.Range(0, sheetCoordinates.Length)];
			}
			material.SetTextureScale("_MainTex", new Vector2(TexTilingVector * texAutoDistDiv, 1f / (float)TexSheetCount));
		}
		else
		{
			timerSheet += Time.deltaTime;
		}
		material.SetTextureOffset("_MainTex", texOffset);
	}
}
public class SplineComponent : MonoBehaviour
{
	[Serializable]
	public class SplineComponentSegment
	{
		public Vector3 m_startpos;

		public Vector3 m_endpos;

		public float m_startlen;

		public float m_endlen;

		public SplineComponentSegment[] m_subsegments;
	}

	[Serializable]
	public class SplineComponentPoint
	{
		public Vector3 m_point;

		public Vector3 m_control1;

		public Vector3 m_control2;

		public BaseSpline.SplinePointType m_type;

		public SplineComponentPoint(Vector3 p, Vector3 c1, Vector3 c2, BaseSpline.SplinePointType t)
		{
			m_point = p;
			m_control1 = c1;
			m_control2 = c2;
			m_type = t;
		}
	}

	public List<SplineComponentPoint> m_points = new List<SplineComponentPoint>();

	[SerializeField]
	private int m_numsteps = 4;

	[SerializeField]
	private BaseSpline.SplineWrapMode m_wrapmode;

	[SerializeField]
	private float m_length;

	[SerializeField]
	private SplineComponentSegment[] m_segments;

	public int InterpolationSteps
	{
		get
		{
			return m_numsteps;
		}
		set
		{
			if (m_numsteps <= 0)
			{
				throw new ArgumentOutOfRangeException();
			}
			m_numsteps = value;
		}
	}

	public SplineComponentSegment[] Segments => m_segments;

	public float Length => m_length;

	public BaseSpline.SplineWrapMode WrapMode
	{
		get
		{
			return m_wrapmode;
		}
		set
		{
			m_wrapmode = value;
		}
	}

	public void AppendPoint(Vector3 pos, BaseSpline.SplinePointType type, Vector3 cp1, Vector3 cp2)
	{
		m_points.Add(new SplineComponentPoint(pos, cp1, cp2, type));
	}

	public void RemoveLastPoint()
	{
		m_points.RemoveAt(m_points.Count - 1);
	}

	public void RemoveAllPoints()
	{
		m_points.Clear();
	}

	public void ReversePoints()
	{
		m_points.Reverse();
		for (int i = 0; i < m_points.Count; i++)
		{
			Vector3 control = m_points[i].m_control1;
			m_points[i].m_control1 = m_points[i].m_control2;
			m_points[i].m_control2 = control;
		}
	}

	public void InsertPoint(int idx, Vector3 pos, BaseSpline.SplinePointType type, Vector3 cp1, Vector3 cp2)
	{
		if (idx < 0 || idx > m_points.Count)
		{
			throw new IndexOutOfRangeException();
		}
		m_points.Insert(idx, new SplineComponentPoint(pos, cp1, cp2, type));
	}

	public void Build()
	{
		SplineComponentPoint splineComponentPoint = null;
		SplineComponentPoint splineComponentPoint2 = null;
		SplineComponentPoint splineComponentPoint3 = null;
		if (m_points.Count < 2)
		{
			m_segments = null;
			m_length = 0f;
			return;
		}
		int num = ((m_wrapmode != BaseSpline.SplineWrapMode.Loop) ? (m_points.Count - 1) : m_points.Count);
		int i;
		for (i = 0; i < m_points.Count; i++)
		{
			splineComponentPoint = m_points[i];
			switch (splineComponentPoint.m_type)
			{
			case BaseSpline.SplinePointType.Corner:
				splineComponentPoint.m_control1 = Vector3.zero;
				splineComponentPoint.m_control2 = Vector3.zero;
				break;
			case BaseSpline.SplinePointType.Bezier:
				splineComponentPoint.m_control2 = -splineComponentPoint.m_control1;
				break;
			case BaseSpline.SplinePointType.Smooth:
				if (m_wrapmode == BaseSpline.SplineWrapMode.Loop)
				{
					int index;
					int index2;
					if (i == 0)
					{
						index = i + 1;
						index2 = m_points.Count - 1;
					}
					else if (i == m_points.Count - 1)
					{
						index = 0;
						index2 = i - 1;
					}
					else
					{
						index = i + 1;
						index2 = i - 1;
					}
					splineComponentPoint2 = m_points[index];
					splineComponentPoint3 = m_points[index2];
					splineComponentPoint.m_control2 = -(splineComponentPoint3.m_point - splineComponentPoint2.m_point) * 0.25f;
					splineComponentPoint.m_control1 = -splineComponentPoint.m_control2;
				}
				else if (i == 0)
				{
					splineComponentPoint.m_control1 = Vector3.zero;
					splineComponentPoint.m_control2 = Vector3.zero;
				}
				else if (i == m_points.Count - 1)
				{
					splineComponentPoint.m_control1 = Vector3.zero;
					splineComponentPoint.m_control2 = Vector3.zero;
				}
				else
				{
					int index = i + 1;
					int index2 = i - 1;
					splineComponentPoint2 = m_points[index];
					splineComponentPoint3 = m_points[index2];
					splineComponentPoint.m_control2 = -(splineComponentPoint3.m_point - splineComponentPoint2.m_point) * 0.25f;
					splineComponentPoint.m_control1 = -splineComponentPoint.m_control2;
				}
				break;
			}
		}
		m_segments = new SplineComponentSegment[num];
		m_length = 0f;
		i = 0;
		int num2 = 0;
		for (; i < m_points.Count; i++)
		{
			splineComponentPoint2 = m_points[i];
			if (i > 0)
			{
				m_segments[num2] = new SplineComponentSegment();
				BuildSegment(m_segments[num2], splineComponentPoint, splineComponentPoint2);
				num2++;
			}
			splineComponentPoint = splineComponentPoint2;
		}
		if (m_wrapmode == BaseSpline.SplineWrapMode.Loop)
		{
			splineComponentPoint2 = m_points[0];
			m_segments[num2] = new SplineComponentSegment();
			BuildSegment(m_segments[num2], splineComponentPoint, splineComponentPoint2);
		}
	}

	private void BuildSegment(SplineComponentSegment ss, SplineComponentPoint spt1, SplineComponentPoint spt2)
	{
		ss.m_startpos = spt1.m_point;
		ss.m_endpos = spt2.m_point;
		ss.m_startlen = m_length;
		if (spt1.m_type == BaseSpline.SplinePointType.Corner && spt2.m_type == BaseSpline.SplinePointType.Corner)
		{
			ss.m_subsegments = null;
			m_length += (ss.m_endpos - ss.m_startpos).magnitude;
		}
		else
		{
			ss.m_subsegments = new SplineComponentSegment[m_numsteps];
			for (int i = 0; i < m_numsteps; i++)
			{
				SplineComponentSegment splineComponentSegment = new SplineComponentSegment();
				splineComponentSegment.m_subsegments = null;
				splineComponentSegment.m_startlen = m_length;
				splineComponentSegment.m_startpos = GetBezierPoint(spt1, spt2, i);
				splineComponentSegment.m_endpos = GetBezierPoint(spt1, spt2, i + 1);
				m_length += (splineComponentSegment.m_endpos - splineComponentSegment.m_startpos).magnitude;
				splineComponentSegment.m_endlen = m_length;
				ss.m_subsegments[i] = splineComponentSegment;
			}
		}
		ss.m_endlen = m_length;
	}

	private Vector3 GetBezierPoint(SplineComponentPoint spt1, SplineComponentPoint spt2, int segidx)
	{
		Vector3 zero = Vector3.zero;
		if (segidx == 0)
		{
			return spt1.m_point;
		}
		if (segidx == m_numsteps)
		{
			return spt2.m_point;
		}
		Vector3 vector = spt1.m_point + spt1.m_control2;
		Vector3 vector2 = spt2.m_point + spt2.m_control1;
		float num = (float)segidx / (float)m_numsteps;
		float num2 = 1f - num;
		return num2 * num2 * num2 * spt1.m_point + 3f * num2 * num2 * num * vector + 3f * num2 * num * num * vector2 + num * num * num * spt2.m_point;
	}

	private void OnDrawGizmosSelected()
	{
		DrawGizmos(Color.red, new Color(1f, 0.5f, 0.5f, 1f));
	}

	private void OnDrawGizmos()
	{
		DrawGizmos(Color.white, Color.white);
	}

	public void DrawGizmos(Color color1, Color color2)
	{
		Gizmos.matrix = base.transform.localToWorldMatrix;
		if (m_segments == null)
		{
			return;
		}
		SplineComponentSegment splineComponentSegment = null;
		SplineComponentSegment splineComponentSegment2 = null;
		for (int i = 0; i < m_segments.Length; i++)
		{
			splineComponentSegment = m_segments[i];
			if (splineComponentSegment.m_subsegments == null || splineComponentSegment.m_subsegments.Length == 0)
			{
				Gizmos.color = color1;
				Gizmos.DrawLine(splineComponentSegment.m_startpos, splineComponentSegment.m_endpos);
				continue;
			}
			for (int j = 0; j < splineComponentSegment.m_subsegments.Length; j++)
			{
				if (j % 2 == 0)
				{
					Gizmos.color = color1;
				}
				else
				{
					Gizmos.color = color2;
				}
				splineComponentSegment2 = splineComponentSegment.m_subsegments[j];
				Gizmos.DrawLine(splineComponentSegment2.m_startpos, splineComponentSegment2.m_endpos);
			}
		}
	}

	public Vector3 GetPosition(float pos)
	{
		Vector3 point = Vector3.zero;
		SplineComponentSegment splineComponentSegment = null;
		bool flag = false;
		SplineComponentSegment[] ssarr = m_segments;
		if (m_segments != null)
		{
			pos = SplineUtil.WrapPosition(m_wrapmode, pos, m_length);
			if (pos <= 0f)
			{
				point = m_segments[0].m_startpos;
			}
			else if (pos >= m_length)
			{
				point = m_segments[m_segments.Length - 1].m_endpos;
			}
			else
			{
				while (!flag)
				{
					splineComponentSegment = FindSegment(ssarr, pos);
					if (splineComponentSegment.m_subsegments == null || splineComponentSegment.m_subsegments.Length == 0)
					{
						flag = true;
					}
					else
					{
						ssarr = splineComponentSegment.m_subsegments;
					}
				}
				float num = splineComponentSegment.m_endlen - splineComponentSegment.m_startlen;
				if (num == 0f)
				{
					point = splineComponentSegment.m_endpos;
				}
				else
				{
					float num2 = (pos - splineComponentSegment.m_startlen) / num;
					point = splineComponentSegment.m_startpos + (splineComponentSegment.m_endpos - splineComponentSegment.m_startpos) * num2;
				}
			}
		}
		return base.transform.localToWorldMatrix.MultiplyPoint(point);
	}

	private SplineComponentSegment FindSegment(SplineComponentSegment[] ssarr, float pos)
	{
		SplineComponentSegment result = null;
		for (int i = 0; i < ssarr.Length; i++)
		{
			if (pos > ssarr[i].m_startlen && pos <= ssarr[i].m_endlen)
			{
				result = ssarr[i];
				break;
			}
		}
		return result;
	}
}
public class SplineTest : MonoBehaviour
{
	public SplineComponent m_spline;

	public float m_position;

	public float m_speed = 1f;

	private void Update()
	{
		m_position += m_speed * Time.deltaTime;
		base.transform.position = m_spline.GetPosition(m_position);
	}
}
public abstract class BaseSpline
{
	public enum UniSplineType
	{
		CatmullRom,
		Hermite,
		KochanekBartels
	}

	public enum SplineWrapMode
	{
		Once,
		Repeat,
		PingPong,
		Loop
	}

	public enum SplinePointType
	{
		Corner,
		Smooth,
		Bezier,
		BezierCorner
	}

	public enum SplineSegmentType
	{
		Linear,
		Curve
	}

	public enum SplineReparamType
	{
		None,
		Simple,
		RungeKutta
	}

	public class SplineIterator
	{
		private Transform m_transform;

		private BaseSpline m_spline;

		private int m_segidx;

		private int m_startidx;

		private int m_endidx;

		private bool m_reverse;

		private bool m_back;

		private bool m_onceout;

		private float m_segpos;

		internal SplineIterator(BaseSpline spline, bool reverse, int startidx, int endidx)
		{
			m_spline = spline;
			m_reverse = reverse;
			m_startidx = Mathf.Min(startidx, endidx);
			m_endidx = Mathf.Max(startidx, endidx);
			Reset();
		}

		public void SetTransform(Transform trnsfrm)
		{
			m_transform = trnsfrm;
		}

		public Vector3 GetPosition()
		{
			if (m_transform != null)
			{
				return m_transform.localToWorldMatrix.MultiplyPoint(m_spline.GetPosition(m_segidx, m_segpos));
			}
			return m_spline.GetPosition(m_segidx, m_segpos);
		}

		public Vector3 GetTangent()
		{
			if (m_transform != null)
			{
				if (m_reverse)
				{
					return m_transform.localRotation * -m_spline.GetTangent(m_segidx, m_segpos);
				}
				return m_transform.localRotation * m_spline.GetTangent(m_segidx, m_segpos);
			}
			if (m_reverse)
			{
				return -m_spline.GetTangent(m_segidx, m_segpos);
			}
			return m_spline.GetTangent(m_segidx, m_segpos);
		}

		public Vector3 GetNormal()
		{
			if (m_transform != null)
			{
				return m_transform.localRotation * m_spline.GetNormal(m_segidx, m_segpos);
			}
			return m_spline.GetNormal(m_segidx, m_segpos);
		}

		public bool IsOnceOut()
		{
			return m_onceout;
		}

		public void Reset()
		{
			if (m_reverse)
			{
				SetToEnd();
			}
			else
			{
				SetToStart();
			}
			m_back = false;
			m_onceout = false;
		}

		public void SetOffset(float offset)
		{
			offset = SplineUtil.WrapPosition(m_spline.WrapMode, offset, m_spline.Length);
			m_segidx = m_spline.FindSegment(offset);
			m_segpos = offset - m_spline.GetSegmentStartLength(m_segidx);
		}

		public float GetOffset()
		{
			return m_spline.GetSegmentStartLength(m_segidx) + m_segpos;
		}

		public void SetOffsetPercent(float offset)
		{
			offset = SplineUtil.WrapPosition(m_spline.WrapMode, offset, m_spline.Length);
			m_segidx = m_spline.FindSegment(offset * m_spline.Length);
			m_segpos = offset - m_spline.GetSegmentStartLength(m_segidx);
		}

		public float GetOffsetPercent()
		{
			if (m_reverse)
			{
				return 1f - (m_spline.GetSegmentStartLength(m_segidx) + m_segpos) / m_spline.Length;
			}
			return (m_spline.GetSegmentStartLength(m_segidx) + m_segpos) / m_spline.Length;
		}

		public void Iterate(float length)
		{
			bool flag = false;
			bool flag2 = false;
			if (m_reverse)
			{
				length = 0f - length;
			}
			if (length < 0f)
			{
				flag2 = !m_back;
				length = 0f - length;
			}
			else
			{
				flag2 = m_back;
			}
			if (flag2)
			{
				while (m_segpos - length < 0f && !flag)
				{
					length -= m_segpos;
					if (m_segidx - 1 < m_startidx)
					{
						switch (m_spline.WrapMode)
						{
						case SplineWrapMode.Loop:
							SetToEnd();
							break;
						case SplineWrapMode.Once:
							SetToStart();
							flag = true;
							m_onceout = true;
							break;
						case SplineWrapMode.Repeat:
							SetToEnd();
							break;
						case SplineWrapMode.PingPong:
							SetToStart();
							m_back = !m_back;
							flag = true;
							break;
						}
					}
					else
					{
						m_segidx--;
						m_segpos = m_spline.GetSegmentLength(m_segidx);
					}
				}
				if (!flag)
				{
					m_segpos -= length;
				}
				return;
			}
			while (m_segpos + length > m_spline.GetSegmentLength(m_segidx) && !flag)
			{
				length -= m_spline.GetSegmentLength(m_segidx) - m_segpos;
				if (m_segidx + 1 >= m_endidx)
				{
					switch (m_spline.m_wrapmode)
					{
					case SplineWrapMode.Loop:
						SetToStart();
						break;
					case SplineWrapMode.Once:
						SetToEnd();
						flag = true;
						m_onceout = true;
						break;
					case SplineWrapMode.Repeat:
						SetToStart();
						break;
					case SplineWrapMode.PingPong:
						SetToEnd();
						m_back = !m_back;
						flag = true;
						break;
					}
				}
				else
				{
					m_segidx++;
					m_segpos = 0f;
				}
			}
			if (!flag)
			{
				m_segpos += length;
			}
		}

		private void SetToStart()
		{
			m_segidx = m_startidx;
			m_segpos = 0f;
		}

		private void SetToEnd()
		{
			m_segidx = m_endidx - 1;
			m_segpos = m_spline.GetSegmentLength(m_segidx);
		}
	}

	[SerializeField]
	protected SplineWrapMode m_wrapmode;

	[SerializeField]
	protected float m_length;

	[SerializeField]
	protected int m_stepcount = 8;

	[SerializeField]
	protected SplineReparamType m_reparam;

	protected int m_buildnum;

	public int BuildNum => m_buildnum;

	public float Length => m_length;

	public SplineWrapMode WrapMode
	{
		get
		{
			return m_wrapmode;
		}
		set
		{
			m_wrapmode = value;
		}
	}

	public int StepCount
	{
		get
		{
			return m_stepcount;
		}
		set
		{
			if (value > 1)
			{
				m_stepcount = value;
			}
		}
	}

	public SplineReparamType ReparamType
	{
		get
		{
			return m_reparam;
		}
		set
		{
			m_reparam = value;
		}
	}

	public abstract void Build();

	public abstract int GetPointCount();

	public abstract int GetSegmentCount();

	protected abstract float GetSegmentLength(int segidx);

	protected abstract float GetSegmentStartLength(int segidx);

	protected abstract float GetSegmentEndLength(int segidx);

	protected abstract int FindSegment(float offset);

	protected abstract Vector3 GetDrawPosition(int segidx, float segpos);

	protected abstract Vector3 GetPosition(int segidx, float segpos);

	protected abstract Vector3 GetTangent(int segidx, float segpos);

	protected abstract Vector3 GetNormal(int segidx, float segpos);

	public SplineIterator GetIterator()
	{
		return new SplineIterator(this, reverse: false, 0, GetSegmentCount());
	}

	public SplineIterator GetReverseIterator()
	{
		return new SplineIterator(this, reverse: true, 0, GetSegmentCount());
	}

	public SplineIterator GetPartialIterator(int startidx, int endidx)
	{
		return new SplineIterator(this, reverse: false, startidx, endidx);
	}

	public SplineIterator GetPartialReverseIterator(int startidx, int endidx)
	{
		return new SplineIterator(this, reverse: true, startidx, endidx);
	}

	public Vector3[] GenerateDrawPoints(int divs)
	{
		int segmentCount = GetSegmentCount();
		int num = 0;
		Vector3[] array = new Vector3[segmentCount * divs + 1];
		float num2 = 1f / (float)divs;
		ref Vector3 reference = ref array[num];
		reference = GetDrawPosition(0, 0f);
		num++;
		for (int i = 0; i < segmentCount; i++)
		{
			for (int j = 1; j < divs + 1; j++)
			{
				ref Vector3 reference2 = ref array[num];
				reference2 = GetDrawPosition(i, (float)j * num2);
				num++;
			}
		}
		return array;
	}
}
[Serializable]
public class BezierSpline : BaseSpline
{
	public class EditHelper
	{
		private BezierSpline m_spline;

		private int m_idx = -1;

		private int m_selidx = -1;

		private int m_selcpidx = -1;

		public BezierSplinePoint Point
		{
			get
			{
				return m_spline.m_points[m_idx];
			}
			set
			{
				m_spline.m_points[m_idx] = value;
			}
		}

		public BezierSplinePoint SelectedPoint
		{
			get
			{
				return m_spline.m_points[m_selidx];
			}
			set
			{
				m_spline.m_points[m_selidx] = value;
			}
		}

		public bool Selected
		{
			get
			{
				return m_idx == m_selidx;
			}
			set
			{
				if (value)
				{
					m_selidx = m_idx;
				}
				else
				{
					m_selidx = -1;
				}
				m_selcpidx = -1;
			}
		}

		public bool ControlPoint1Selected
		{
			get
			{
				return m_selcpidx == 0;
			}
			set
			{
				if (value)
				{
					m_selcpidx = 0;
				}
				else
				{
					m_selcpidx = -1;
				}
			}
		}

		public bool ControlPoint2Selected
		{
			get
			{
				return m_selcpidx == 1;
			}
			set
			{
				if (value)
				{
					m_selcpidx = 1;
				}
				else
				{
					m_selcpidx = -1;
				}
			}
		}

		public bool ControlPointsVisible
		{
			get
			{
				if (m_selidx == -1)
				{
					return false;
				}
				return m_spline.m_points[m_selidx].m_type == SplinePointType.Bezier || m_spline.m_points[m_selidx].m_type == SplinePointType.BezierCorner;
			}
		}

		public bool SomethingSelected => m_selidx != -1;

		public int Index => m_idx;

		public int SelectedIndex => m_selidx;

		internal EditHelper(BezierSpline spline)
		{
			m_spline = spline;
		}

		public bool MoveNext()
		{
			m_idx++;
			if (m_idx < m_spline.m_points.Count)
			{
				return true;
			}
			return false;
		}

		public void Reset()
		{
			m_idx = -1;
		}

		public void AppendPoint()
		{
			if (m_spline.m_points.Count == 0)
			{
				m_spline.AppendPoint(Vector3.zero, SplinePointType.Corner, Vector3.zero, Vector3.zero);
			}
			else
			{
				m_spline.AppendPoint(m_spline.m_points[m_spline.m_points.Count - 1].m_point + Vector3.right, SplinePointType.Corner, Vector3.zero, Vector3.zero);
			}
			m_selidx = m_spline.m_points.Count - 1;
		}

		public void InsertBefore()
		{
			if (m_spline.m_points.Count == 1)
			{
				m_spline.InsertPoint(0, m_spline.m_points[m_spline.m_points.Count - 1].m_point + Vector3.right, SplinePointType.Corner, Vector3.zero, Vector3.zero);
				return;
			}
			int selidx = m_selidx;
			m_selidx--;
			if (m_selidx < 0)
			{
				m_selidx = m_spline.m_points.Count - 1;
			}
			m_spline.InsertPoint(selidx, (m_spline.m_points[m_selidx].m_point + m_spline.m_points[selidx].m_point) * 0.5f, SplinePointType.Corner, Vector3.zero, Vector3.zero);
			m_selidx = selidx;
		}

		public void InsertAfter()
		{
			if (m_spline.m_points.Count == 1)
			{
				m_spline.InsertPoint(0, m_spline.m_points[m_spline.m_points.Count - 1].m_point + Vector3.right, SplinePointType.Corner, Vector3.zero, Vector3.zero);
				return;
			}
			int selidx = m_selidx;
			m_selidx++;
			if (m_selidx == m_spline.m_points.Count)
			{
				m_selidx = m_spline.m_points.Count - 1;
			}
			m_spline.InsertPoint(m_selidx, (m_spline.m_points[m_selidx].m_point + m_spline.m_points[selidx].m_point) * 0.5f, SplinePointType.Corner, Vector3.zero, Vector3.zero);
		}

		public void Remove()
		{
			m_spline.m_points.RemoveAt(m_selidx);
			if (m_selidx >= m_spline.m_points.Count)
			{
				m_selidx = m_spline.m_points.Count - 1;
			}
		}

		public void RemoveLast()
		{
			if (m_spline.m_points.Count > 0)
			{
				m_spline.RemoveLastPoint();
			}
			if (m_selidx >= m_spline.m_points.Count)
			{
				m_selidx = m_spline.m_points.Count - 1;
			}
		}

		public void SelectFirst()
		{
			if (m_spline.m_points.Count > 0)
			{
				m_selidx = 0;
			}
			else
			{
				m_selidx = -1;
			}
		}

		public void SelectNext()
		{
			if (m_selidx < m_spline.m_points.Count - 1)
			{
				m_selidx++;
			}
			else
			{
				m_selidx = 0;
			}
		}

		public void SelectPrev()
		{
			if (m_selidx > 0)
			{
				m_selidx--;
			}
			else
			{
				m_selidx = m_spline.m_points.Count - 1;
			}
		}
	}

	[Serializable]
	public class BezierSplineSegment
	{
		public Vector3 m_startpos;

		public Vector3 m_endpos;

		public Vector3 m_startctrl;

		public Vector3 m_endctrl;

		public float m_startlen;

		public float m_endlen;

		public float m_length;

		public SplineSegmentType m_type;

		public float[] m_params;

		public float[] m_precomps;
	}

	[Serializable]
	public class BezierSplinePoint
	{
		public Vector3 m_point;

		public Vector3 m_prevctrl;

		public Vector3 m_nextctrl;

		public SplinePointType m_type;

		public BezierSplinePoint(Vector3 p, Vector3 c1, Vector3 c2, SplinePointType t)
		{
			m_point = p;
			m_prevctrl = c1;
			m_nextctrl = c2;
			m_type = t;
		}
	}

	public List<BezierSplinePoint> m_points = new List<BezierSplinePoint>();

	[SerializeField]
	private BezierSplineSegment[] m_segments;

	[SerializeField]
	private float m_precompdiv = 1f;

	public void AppendPoint(Vector3 pos, SplinePointType type, Vector3 cp1, Vector3 cp2)
	{
		m_points.Add(new BezierSplinePoint(pos, cp1, cp2, type));
	}

	public void RemoveLastPoint()
	{
		m_points.RemoveAt(m_points.Count - 1);
	}

	public void RemoveAllPoints()
	{
		m_points.Clear();
	}

	public void ReversePoints()
	{
		m_points.Reverse();
		for (int i = 0; i < m_points.Count; i++)
		{
			Vector3 nextctrl = m_points[i].m_nextctrl;
			m_points[i].m_nextctrl = m_points[i].m_prevctrl;
			m_points[i].m_prevctrl = nextctrl;
		}
	}

	public void InsertPoint(int idx, Vector3 pos, SplinePointType type, Vector3 cp1, Vector3 cp2)
	{
		if (idx < 0 || idx > m_points.Count)
		{
			throw new IndexOutOfRangeException();
		}
		m_points.Insert(idx, new BezierSplinePoint(pos, cp1, cp2, type));
	}

	public override void Build()
	{
		if (m_points.Count < 2)
		{
			m_segments = null;
			m_length = 0f;
			return;
		}
		int num = ((m_wrapmode != SplineWrapMode.Loop) ? (m_points.Count - 1) : m_points.Count);
		m_segments = new BezierSplineSegment[num];
		m_length = 0f;
		int i = 0;
		if (m_wrapmode == SplineWrapMode.Loop)
		{
			for (; i < num; i++)
			{
				BezierSplinePoint pp = m_points[SplineUtil.WrapIndex(i - 1, m_points.Count)];
				BezierSplinePoint sp = m_points[SplineUtil.WrapIndex(i, m_points.Count)];
				BezierSplinePoint ep = m_points[SplineUtil.WrapIndex(i + 1, m_points.Count)];
				BezierSplinePoint np = m_points[SplineUtil.WrapIndex(i + 2, m_points.Count)];
				m_segments[i] = new BezierSplineSegment();
				BuildSegment(m_segments[i], pp, sp, ep, np);
			}
		}
		else
		{
			for (; i < num; i++)
			{
				BezierSplinePoint pp = m_points[SplineUtil.ClampIndex(i - 1, m_points.Count)];
				BezierSplinePoint sp = m_points[SplineUtil.ClampIndex(i, m_points.Count)];
				BezierSplinePoint ep = m_points[SplineUtil.ClampIndex(i + 1, m_points.Count)];
				BezierSplinePoint np = m_points[SplineUtil.ClampIndex(i + 2, m_points.Count)];
				m_segments[i] = new BezierSplineSegment();
				BuildSegment(m_segments[i], pp, sp, ep, np);
			}
		}
		m_buildnum++;
	}

	private void BuildSegment(BezierSplineSegment ss, BezierSplinePoint pp, BezierSplinePoint sp, BezierSplinePoint ep, BezierSplinePoint np)
	{
		PreparePoint(pp, sp, ep);
		PreparePoint(sp, ep, np);
		ss.m_startpos = sp.m_point;
		ss.m_endpos = ep.m_point;
		ss.m_startctrl = ss.m_startpos + sp.m_nextctrl;
		ss.m_endctrl = ss.m_endpos + ep.m_prevctrl;
		if (sp.m_type == SplinePointType.Corner && ep.m_type == SplinePointType.Corner)
		{
			ss.m_type = SplineSegmentType.Linear;
		}
		else
		{
			ss.m_type = SplineSegmentType.Curve;
		}
		ss.m_startlen = m_length;
		float length = GetLength(ss);
		m_length += length;
		ss.m_length = length;
		ss.m_endlen = m_length;
		switch (m_reparam)
		{
		case SplineReparamType.None:
			ss.m_params = null;
			ss.m_precomps = null;
			break;
		case SplineReparamType.Simple:
		{
			m_precompdiv = 1f / (float)m_stepcount;
			float num3 = 0f;
			float num4 = 0f;
			ss.m_params = new float[m_stepcount + 1];
			ss.m_precomps = new float[m_stepcount + 1];
			for (int j = 1; j < m_stepcount + 1; j++)
			{
				Vector3 position = GetPosition(ss, num3);
				num3 += m_precompdiv;
				Vector3 position2 = GetPosition(ss, num3);
				num4 += (position2 - position).magnitude;
				ss.m_precomps[j] = num4 / length;
				ss.m_params[j] = num3;
			}
			ss.m_params[0] = 0f;
			ss.m_params[m_stepcount] = 1f;
			ss.m_precomps[0] = 0f;
			ss.m_precomps[m_stepcount] = 1f;
			m_precompdiv = 1f / (float)m_stepcount;
			break;
		}
		case SplineReparamType.RungeKutta:
		{
			float num = length / (float)m_stepcount;
			float num2 = 0f;
			ss.m_params = new float[m_stepcount + 1];
			ss.m_precomps = new float[m_stepcount + 1];
			for (int i = 0; i < m_stepcount + 1; i++)
			{
				ss.m_params[i] = GetReparamRungeKutta(ss, num2);
				ss.m_precomps[i] = num2 / length;
				num2 += num;
			}
			ss.m_params[0] = 0f;
			ss.m_params[m_stepcount] = 1f;
			ss.m_precomps[0] = 0f;
			ss.m_precomps[m_stepcount] = 1f;
			m_precompdiv = 1f / (float)m_stepcount;
			break;
		}
		}
	}

	private void PreparePoint(BezierSplinePoint pp, BezierSplinePoint pt, BezierSplinePoint np)
	{
		switch (pt.m_type)
		{
		case SplinePointType.Bezier:
			pt.m_nextctrl = -pt.m_prevctrl;
			break;
		case SplinePointType.Smooth:
			pt.m_prevctrl = -0.25f * (np.m_point - pp.m_point);
			pt.m_nextctrl = -0.25f * (pp.m_point - np.m_point);
			break;
		case SplinePointType.Corner:
			pt.m_prevctrl = Vector3.zero;
			pt.m_nextctrl = Vector3.zero;
			break;
		case SplinePointType.BezierCorner:
			break;
		}
	}

	private float GetLength(BezierSplineSegment ss)
	{
		switch (ss.m_type)
		{
		case SplineSegmentType.Linear:
			return (ss.m_endpos - ss.m_startpos).magnitude;
		case SplineSegmentType.Curve:
		{
			float num = 0f;
			float num2 = 0f;
			float num3 = 1f / (float)m_stepcount;
			int i = 0;
			Vector3 vector = ss.m_startpos;
			for (; i < m_stepcount; i++)
			{
				num2 += num3;
				Vector3 position = GetPosition(ss, num2);
				num += (position - vector).magnitude;
				vector = position;
			}
			return num;
		}
		default:
			return 0f;
		}
	}

	public Vector3 GetPosition(BezierSplineSegment ss, float t)
	{
		switch (ss.m_type)
		{
		case SplineSegmentType.Linear:
			return ss.m_startpos + (ss.m_endpos - ss.m_startpos) * t;
		case SplineSegmentType.Curve:
		{
			float num = 1f - t;
			float num2 = num * num;
			float num3 = t * t;
			return ss.m_startpos * num * num2 + ss.m_startctrl * 3f * num2 * t + ss.m_endctrl * 3f * num * num3 + ss.m_endpos * num3 * t;
		}
		default:
			return Vector3.zero;
		}
	}

	public Vector3 GetTangent(BezierSplineSegment ss, float t)
	{
		switch (ss.m_type)
		{
		case SplineSegmentType.Linear:
			return ss.m_endpos - ss.m_startpos;
		case SplineSegmentType.Curve:
		{
			float num = 1f - t;
			float num2 = num * num;
			float num3 = t * t;
			return ss.m_startpos * -3f * num2 + ss.m_startctrl * (-6f * num * t + 3f * num2) + ss.m_endctrl * (6f * num * t - 3f * num3) + ss.m_endpos * 3f * num3;
		}
		default:
			return Vector3.zero;
		}
	}

	private Vector3 GetNormal(BezierSplineSegment ss, float t)
	{
		return ss.m_type switch
		{
			SplineSegmentType.Linear => Vector3.zero, 
			SplineSegmentType.Curve => -6f * (ss.m_startpos * (1f - t) + ss.m_startctrl * (2f - 3f * t) + 3f * ss.m_endctrl * t - ss.m_endctrl - ss.m_endpos * t), 
			_ => Vector3.zero, 
		};
	}

	private float GetReparamRungeKutta(BezierSplineSegment ss, float u)
	{
		float num = 0f;
		float num2 = u / (float)m_stepcount;
		for (int i = 1; i <= m_stepcount; i++)
		{
			float magnitude = GetTangent(ss, num).magnitude;
			float num3;
			float num4;
			float num5;
			float num6;
			if (magnitude == 0f)
			{
				num3 = 0f;
				num4 = 0f;
				num5 = 0f;
				num6 = 0f;
			}
			else
			{
				num3 = num2 / GetTangent(ss, num).magnitude;
				num4 = num2 / GetTangent(ss, num + num3 * 0.5f).magnitude;
				num5 = num2 / GetTangent(ss, num + num4 * 0.5f).magnitude;
				num6 = num2 / GetTangent(ss, num + num5).magnitude;
			}
			num += (num3 + 2f * (num4 + num5) + num6) * (1f / 6f);
		}
		return num;
	}

	private float GetReparam(BezierSplineSegment ss, float u)
	{
		if (u <= 0f)
		{
			return 0f;
		}
		if (u >= 1f)
		{
			return 1f;
		}
		switch (m_reparam)
		{
		case SplineReparamType.RungeKutta:
		{
			int num2 = (int)(u * (float)m_stepcount);
			float t2 = (u - ss.m_precomps[num2]) / m_precompdiv;
			return Mathf.Lerp(ss.m_params[num2], ss.m_params[num2 + 1], t2);
		}
		case SplineReparamType.Simple:
		{
			int num = 0;
			for (int i = 1; i < m_stepcount + 1; i++)
			{
				if (ss.m_precomps[i] > u)
				{
					num = i - 1;
					break;
				}
			}
			float t = (u - ss.m_precomps[num]) / (ss.m_precomps[num + 1] - ss.m_precomps[num]);
			return Mathf.Lerp(ss.m_params[num], ss.m_params[num + 1], t);
		}
		default:
			return 0f;
		}
	}

	public override int GetPointCount()
	{
		return m_points.Count;
	}

	public override int GetSegmentCount()
	{
		if (m_segments != null)
		{
			return m_segments.Length;
		}
		return 0;
	}

	protected override float GetSegmentLength(int segidx)
	{
		return m_segments[segidx].m_length;
	}

	protected override float GetSegmentStartLength(int segidx)
	{
		return m_segments[segidx].m_startlen;
	}

	protected override float GetSegmentEndLength(int segidx)
	{
		return m_segments[segidx].m_endlen;
	}

	protected override int FindSegment(float offset)
	{
		for (int i = 0; i < m_segments.Length; i++)
		{
			if (m_segments[i].m_startlen <= offset && m_segments[i].m_endlen > offset)
			{
				return i;
			}
		}
		return m_segments.Length - 1;
	}

	protected override Vector3 GetDrawPosition(int segidx, float t)
	{
		BezierSplineSegment ss = m_segments[segidx];
		return GetPosition(ss, t);
	}

	protected override Vector3 GetPosition(int segidx, float segpos)
	{
		BezierSplineSegment bezierSplineSegment = m_segments[segidx];
		if (m_reparam == SplineReparamType.None)
		{
			return GetPosition(bezierSplineSegment, segpos / bezierSplineSegment.m_length);
		}
		return GetPosition(bezierSplineSegment, GetReparam(bezierSplineSegment, segpos / bezierSplineSegment.m_length));
	}

	protected override Vector3 GetTangent(int segidx, float segpos)
	{
		BezierSplineSegment bezierSplineSegment = m_segments[segidx];
		if (m_reparam == SplineReparamType.None)
		{
			return GetTangent(bezierSplineSegment, segpos / bezierSplineSegment.m_length);
		}
		return GetTangent(bezierSplineSegment, GetReparam(bezierSplineSegment, segpos / bezierSplineSegment.m_length));
	}

	protected override Vector3 GetNormal(int segidx, float segpos)
	{
		BezierSplineSegment bezierSplineSegment = m_segments[segidx];
		if (m_reparam == SplineReparamType.None)
		{
			return GetNormal(bezierSplineSegment, segpos / bezierSplineSegment.m_length);
		}
		return GetNormal(bezierSplineSegment, GetReparam(bezierSplineSegment, segpos / bezierSplineSegment.m_length));
	}

	public EditHelper GetEditHelper()
	{
		return new EditHelper(this);
	}
}
public class BezierSplineComponent : MonoBehaviour
{
	[SerializeField]
	private BezierSpline m_spline = new BezierSpline();

	private int m_buildnum = -1;

	private Vector3[] m_drawcache;

	public BezierSpline Spline => m_spline;

	private void OnDrawGizmosSelected()
	{
		DrawGizmos(Color.red);
	}

	private void OnDrawGizmos()
	{
		DrawGizmos(Color.white);
	}

	private void DrawGizmos(Color color)
	{
		int buildNum = m_spline.BuildNum;
		if (m_spline.GetSegmentCount() <= 0)
		{
			return;
		}
		if (m_buildnum != buildNum)
		{
			m_drawcache = m_spline.GenerateDrawPoints(16);
			m_buildnum = buildNum;
		}
		if (m_drawcache == null)
		{
			return;
		}
		Gizmos.matrix = base.transform.localToWorldMatrix;
		Gizmos.color = color;
		Vector3 from = Vector3.zero;
		Vector3 zero = Vector3.zero;
		for (int i = 0; i < m_drawcache.Length; i++)
		{
			zero = m_drawcache[i];
			if (i != 0)
			{
				Gizmos.DrawLine(from, zero);
			}
			from = zero;
		}
	}
}
public class BezierSplinePartialTest : MonoBehaviour
{
	public BezierSplineComponent m_spline;

	public float m_speed = 1f;

	public Vector3 m_up = Vector3.up;

	private BaseSpline.SplineIterator m_iter;

	private void Awake()
	{
		m_iter = m_spline.Spline.GetPartialIterator(0, 1);
		m_iter.SetTransform(m_spline.transform);
	}

	private void Update()
	{
		m_iter.Iterate(m_speed * Time.deltaTime);
		Vector3 position = base.transform.position;
		base.transform.position = m_iter.GetPosition();
		base.transform.rotation = Quaternion.LookRotation(m_iter.GetTangent(), m_up);
	}
}
public class BezierSplineTest : MonoBehaviour
{
	public BezierSplineComponent m_spline;

	public float m_speed = 1f;

	public float m_curspeed;

	public Vector3 m_up = Vector3.up;

	private BaseSpline.SplineIterator m_iter;

	private void Awake()
	{
		m_iter = m_spline.Spline.GetIterator();
		m_iter.SetTransform(m_spline.transform);
	}

	private void Update()
	{
		m_iter.Iterate(m_speed * Time.deltaTime);
		Vector3 position = base.transform.position;
		base.transform.position = m_iter.GetPosition();
		base.transform.rotation = Quaternion.LookRotation(m_iter.GetTangent(), m_up);
		m_curspeed = (base.transform.position - position).magnitude / Time.deltaTime;
	}
}
public static class Ease
{
	public enum Easing
	{
		Linear,
		InQuad,
		OutQuad,
		InOutQuad,
		OutInQuad,
		InCubic,
		OutCubic,
		InOutCubic,
		OutInCubic,
		InQuart,
		OutQuart,
		InOutQuart,
		OutInQuart,
		InQuint,
		OutQuint,
		InOutQuint,
		OutInQuint,
		InSin,
		OutSin,
		InOutSin,
		OutInSin,
		InExp,
		OutExp,
		InOutExp,
		OutInExp,
		InCirc,
		OutCirc,
		InOutCirc,
		OutInCirc,
		InElastic,
		OutElastic,
		InOutElastic,
		OutInElastic,
		InBounce,
		OutBounce,
		InOutBounce,
		OutInBounce,
		InBack,
		OutBack,
		InOutBack,
		OutInBack
	}

	public static float EaseByType(Easing e, float start, float end, float t)
	{
		return e switch
		{
			Easing.Linear => Linear(start, end, t), 
			Easing.InQuad => InQuad(start, end, t), 
			Easing.OutQuad => OutQuad(start, end, t), 
			Easing.InOutQuad => InOutQuad(start, end, t), 
			Easing.OutInQuad => OutInQuad(start, end, t), 
			Easing.InCubic => InCubic(start, end, t), 
			Easing.OutCubic => OutCubic(start, end, t), 
			Easing.InOutCubic => InOutCubic(start, end, t), 
			Easing.OutInCubic => OutInCubic(start, end, t), 
			Easing.InQuart => InQuart(start, end, t), 
			Easing.OutQuart => OutQuart(start, end, t), 
			Easing.InOutQuart => InOutQuart(start, end, t), 
			Easing.OutInQuart => OutInQuart(start, end, t), 
			Easing.InQuint => InQuint(start, end, t), 
			Easing.OutQuint => OutQuint(start, end, t), 
			Easing.InOutQuint => InOutQuint(start, end, t), 
			Easing.OutInQuint => OutInQuint(start, end, t), 
			Easing.InSin => InSin(start, end, t), 
			Easing.OutSin => OutSin(start, end, t), 
			Easing.InOutSin => InOutSin(start, end, t), 
			Easing.OutInSin => OutInSin(start, end, t), 
			Easing.InExp => InExp(start, end, t), 
			Easing.OutExp => OutExp(start, end, t), 
			Easing.InOutExp => InOutExp(start, end, t), 
			Easing.OutInExp => OutInExp(start, end, t), 
			Easing.InCirc => InCirc(start, end, t), 
			Easing.OutCirc => OutCirc(start, end, t), 
			Easing.InOutCirc => InOutCirc(start, end, t), 
			Easing.OutInCirc => OutInCirc(start, end, t), 
			Easing.InElastic => InElastic(start, end, t), 
			Easing.OutElastic => OutElastic(start, end, t), 
			Easing.InOutElastic => InOutElastic(start, end, t), 
			Easing.OutInElastic => OutInElastic(start, end, t), 
			Easing.InBounce => InBounce(start, end, t), 
			Easing.OutBounce => OutBounce(start, end, t), 
			Easing.InOutBounce => InOutBounce(start, end, t), 
			Easing.OutInBounce => OutInBounce(start, end, t), 
			Easing.InBack => InBack(start, end, t), 
			Easing.OutBack => OutBack(start, end, t), 
			Easing.InOutBack => InOutBack(start, end, t), 
			Easing.OutInBack => OutInBack(start, end, t), 
			_ => 0f, 
		};
	}

	public static float Linear(float start, float end, float t)
	{
		return t * (end - start) + start;
	}

	public static float InQuad(float start, float end, float t)
	{
		return t * t * (end - start) + start;
	}

	public static float OutQuad(float start, float end, float t)
	{
		return (0f - t * (t - 2f)) * (end - start) + start;
	}

	public static float InOutQuad(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * (end - start) + start;
		}
		t -= 1f;
		return -0.5f * (t * (t - 2f) - 1f) * (end - start) + start;
	}

	public static float OutInQuad(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return (-0.5f * (t * (t - 2f) - 1f) - 0.5f) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * t * t + 0.5f) * (end - start) + start;
	}

	public static float InCubic(float start, float end, float t)
	{
		return t * t * t * (end - start) + start;
	}

	public static float OutCubic(float start, float end, float t)
	{
		t -= 1f;
		return (t * t * t + 1f) * (end - start) + start;
	}

	public static float InOutCubic(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * t * (end - start) + start;
		}
		t -= 2f;
		return 0.5f * (t * t * t + 2f) * (end - start) + start;
	}

	public static float OutInCubic(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return (0.5f * (t * t * t + 2f) - 0.5f) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * t * t * t + 0.5f) * (end - start) + start;
	}

	public static float InQuart(float start, float end, float t)
	{
		return t * t * t * t * (end - start) + start;
	}

	public static float OutQuart(float start, float end, float t)
	{
		t -= 1f;
		return (0f - (t * t * t * t - 1f)) * (end - start) + start;
	}

	public static float InOutQuart(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * t * t * (end - start) + start;
		}
		t -= 2f;
		return -0.5f * (t * t * t * t - 2f) * (end - start) + start;
	}

	public static float OutInQuart(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return (-0.5f * t * t * t * t + 0.5f) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * t * t * t * t + 0.5f) * (end - start) + start;
	}

	public static float InQuint(float start, float end, float t)
	{
		return t * t * t * t * t * (end - start) + start;
	}

	public static float OutQuint(float start, float end, float t)
	{
		t -= 1f;
		return (t * t * t * t * t + 1f) * (end - start) + start;
	}

	public static float InOutQuint(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * t * t * t * (end - start) + start;
		}
		t -= 2f;
		return (0.5f * t * t * t * t * t + 1f) * (end - start) + start;
	}

	public static float OutInQuint(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return (0.5f * (t * t * t * t * t) + 0.5f) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * t * t * t * t * t + 0.5f) * (end - start) + start;
	}

	public static float InSin(float start, float end, float t)
	{
		return (0f - Mathf.Cos(t * (float)Math.PI * 0.5f)) * (end - start) + end;
	}

	public static float OutSin(float start, float end, float t)
	{
		return Mathf.Sin(t * (float)Math.PI * 0.5f) * (end - start) + start;
	}

	public static float InOutSin(float start, float end, float t)
	{
		return (-0.5f * Mathf.Cos(t * (float)Math.PI) + 0.5f) * (end - start) + start;
	}

	public static float OutInSin(float start, float end, float t)
	{
		return (t - (-0.5f * Mathf.Cos(t * (float)Math.PI) + 0.5f - t)) * (end - start) + start;
	}

	public static float InExp(float start, float end, float t)
	{
		return Mathf.Pow(2f, 10f * (t - 1f)) * (end - start) + start;
	}

	public static float OutExp(float start, float end, float t)
	{
		return (1f - Mathf.Pow(2f, -10f * t)) * (end - start) + start;
	}

	public static float InOutExp(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * Mathf.Pow(2f, 10f * (t - 1f)) * (end - start) + start;
		}
		t -= 1f;
		return 0.5f * (2f - Mathf.Pow(2f, -10f * t)) * (end - start) + start;
	}

	public static float OutInExp(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return (0.5f * (2f - Mathf.Pow(2f, -10f * t)) - 0.5f) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * Mathf.Pow(2f, 10f * (t - 1f)) + 0.5f) * (end - start) + start;
	}

	public static float InCirc(float start, float end, float t)
	{
		return (0f - (Mathf.Sqrt(1f - t * t) - 1f)) * (end - start) + start;
	}

	public static float OutCirc(float start, float end, float t)
	{
		t -= 1f;
		return Mathf.Sqrt(1f - t * t) * (end - start) + start;
	}

	public static float InOutCirc(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return -0.5f * (Mathf.Sqrt(1f - t * t) - 1f) * (end - start) + start;
		}
		t -= 2f;
		return 0.5f * (Mathf.Sqrt(1f - t * t) + 1f) * (end - start) + start;
	}

	public static float OutInCirc(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return 0.5f * Mathf.Sqrt(1f - t * t) * (end - start) + start;
		}
		t -= 1f;
		return (-0.5f * Mathf.Sqrt(1f - t * t) + 1f) * (end - start) + start;
	}

	public static float InElastic(float start, float end, float t)
	{
		float num = 0.3f;
		float num2 = 0.075f;
		t -= 1f;
		return (0f - Mathf.Pow(2f, 10f * t)) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) * (end - start) + start;
	}

	public static float OutElastic(float start, float end, float t)
	{
		float num = 0.3f;
		float num2 = 0.075f;
		return Mathf.Pow(2f, -10f * t) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) * (end - start) + end;
	}

	public static float InOutElastic(float start, float end, float t)
	{
		float num = 0.3f;
		float num2 = 0.075f;
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return -0.5f * Mathf.Pow(2f, 10f * t) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) * (end - start) + start;
		}
		t -= 1f;
		return 0.5f * Mathf.Pow(2f, -10f * t) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) * (end - start) + end;
	}

	public static float OutInElastic(float start, float end, float t)
	{
		float num = 0.3f;
		float num2 = 0.075f;
		t *= 2f;
		if (t < 1f)
		{
			return (0.5f * Mathf.Pow(2f, -10f * t) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) - 0.5f) * (end - start) + end;
		}
		t -= 2f;
		return (-0.5f * Mathf.Pow(2f, 10f * t) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) + 0.5f) * (end - start) + start;
	}

	public static float InBounce(float start, float end, float t)
	{
		t = 1f - t;
		if (t < 0.36363637f)
		{
			return (-7.5625f * t * t + 1f) * (end - start) + start;
		}
		if (t < 0.72727275f)
		{
			t -= 0.54545456f;
			return (-7.5625f * t * t - 0.75f + 1f) * (end - start) + start;
		}
		if (t < 0.90909094f)
		{
			t -= 0.8181818f;
			return (-7.5625f * t * t - 0.9375f + 1f) * (end - start) + start;
		}
		t -= 21f / 22f;
		return (-7.5625f * t * t - 63f / 64f + 1f) * (end - start) + start;
	}

	public static float OutBounce(float start, float end, float t)
	{
		if (t < 0.36363637f)
		{
			return 7.5625f * t * t * (end - start) + start;
		}
		if (t < 0.72727275f)
		{
			t -= 0.54545456f;
			return (7.5625f * t * t + 0.75f) * (end - start) + start;
		}
		if (t < 0.90909094f)
		{
			t -= 0.8181818f;
			return (7.5625f * t * t + 0.9375f) * (end - start) + start;
		}
		t -= 21f / 22f;
		return (7.5625f * t * t + 63f / 64f) * (end - start) + start;
	}

	public static float InOutBounce(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t = 1f - t;
			if (t < 0.36363637f)
			{
				return (-3.78125f * t * t + 0.5f) * (end - start) + start;
			}
			if (t < 0.72727275f)
			{
				t -= 0.54545456f;
				return (-0.5f * (7.5625f * t * t + 0.75f) + 0.5f) * (end - start) + start;
			}
			if (t < 0.90909094f)
			{
				t -= 0.8181818f;
				return (-0.5f * (7.5625f * t * t + 0.9375f) + 0.5f) * (end - start) + start;
			}
			t -= 21f / 22f;
			return (-0.5f * (7.5625f * t * t + 63f / 64f) + 0.5f) * (end - start) + start;
		}
		t -= 1f;
		if (t < 0.36363637f)
		{
			return (3.78125f * t * t + 0.5f) * (end - start) + start;
		}
		if (t < 0.72727275f)
		{
			t -= 0.54545456f;
			return (0.5f * (7.5625f * t * t + 0.75f) + 0.5f) * (end - start) + start;
		}
		if (t < 0.90909094f)
		{
			t -= 0.8181818f;
			return (0.5f * (7.5625f * t * t + 0.9375f) + 0.5f) * (end - start) + start;
		}
		t -= 21f / 22f;
		return (0.5f * (7.5625f * t * t + 63f / 64f) + 0.5f) * (end - start) + start;
	}

	public static float OutInBounce(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			if (t < 0.36363637f)
			{
				return 3.78125f * t * t * (end - start) + start;
			}
			if (t < 0.72727275f)
			{
				t -= 0.54545456f;
				return 0.5f * (7.5625f * t * t + 0.75f) * (end - start) + start;
			}
			if (t < 0.90909094f)
			{
				t -= 0.8181818f;
				return 0.5f * (7.5625f * t * t + 0.9375f) * (end - start) + start;
			}
			t -= 21f / 22f;
			return 0.5f * (7.5625f * t * t + 63f / 64f) * (end - start) + start;
		}
		t = 2f - t;
		if (t < 0.36363637f)
		{
			return (-3.78125f * t * t + 1f) * (end - start) + start;
		}
		if (t < 0.72727275f)
		{
			t -= 0.54545456f;
			return (-0.5f * (7.5625f * t * t + 0.75f) + 1f) * (end - start) + start;
		}
		if (t < 0.90909094f)
		{
			t -= 0.8181818f;
			return (-0.5f * (7.5625f * t * t + 0.9375f) + 1f) * (end - start) + start;
		}
		t -= 21f / 22f;
		return (-0.5f * (7.5625f * t * t + 63f / 64f) + 1f) * (end - start) + start;
	}

	public static float InBack(float start, float end, float t)
	{
		return t * t * (2.70158f * t - 1.70158f) * (end - start) + start;
	}

	public static float OutBack(float start, float end, float t)
	{
		t -= 1f;
		return (1f - t * t * (-2.70158f * t - 1.70158f)) * (end - start) + start;
	}

	public static float InOutBack(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * (2.70158f * t - 1.70158f) * (end - start) + start;
		}
		t -= 2f;
		return (1f - 0.5f * t * t * (-2.70158f * t - 1.70158f)) * (end - start) + start;
	}

	public static float OutInBack(float start, float end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return (0.5f - 0.5f * t * t * (-2.70158f * t - 1.70158f)) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * t * t * (2.70158f * t - 1.70158f) + 0.5f) * (end - start) + start;
	}

	public static Vector3 EaseByType(Easing e, Vector3 start, Vector3 end, float t)
	{
		return e switch
		{
			Easing.Linear => Linear(start, end, t), 
			Easing.InQuad => InQuad(start, end, t), 
			Easing.OutQuad => OutQuad(start, end, t), 
			Easing.InOutQuad => InOutQuad(start, end, t), 
			Easing.OutInQuad => OutInQuad(start, end, t), 
			Easing.InCubic => InCubic(start, end, t), 
			Easing.OutCubic => OutCubic(start, end, t), 
			Easing.InOutCubic => InOutCubic(start, end, t), 
			Easing.OutInCubic => OutInCubic(start, end, t), 
			Easing.InQuart => InQuart(start, end, t), 
			Easing.OutQuart => OutQuart(start, end, t), 
			Easing.InOutQuart => InOutQuart(start, end, t), 
			Easing.OutInQuart => OutInQuart(start, end, t), 
			Easing.InQuint => InQuint(start, end, t), 
			Easing.OutQuint => OutQuint(start, end, t), 
			Easing.InOutQuint => InOutQuint(start, end, t), 
			Easing.OutInQuint => OutInQuint(start, end, t), 
			Easing.InSin => InSin(start, end, t), 
			Easing.OutSin => OutSin(start, end, t), 
			Easing.InOutSin => InOutSin(start, end, t), 
			Easing.OutInSin => OutInSin(start, end, t), 
			Easing.InExp => InExp(start, end, t), 
			Easing.OutExp => OutExp(start, end, t), 
			Easing.InOutExp => InOutExp(start, end, t), 
			Easing.OutInExp => OutInExp(start, end, t), 
			Easing.InCirc => InCirc(start, end, t), 
			Easing.OutCirc => OutCirc(start, end, t), 
			Easing.InOutCirc => InOutCirc(start, end, t), 
			Easing.OutInCirc => OutInCirc(start, end, t), 
			Easing.InElastic => InElastic(start, end, t), 
			Easing.OutElastic => OutElastic(start, end, t), 
			Easing.InOutElastic => InOutElastic(start, end, t), 
			Easing.OutInElastic => OutInElastic(start, end, t), 
			Easing.InBounce => InBounce(start, end, t), 
			Easing.OutBounce => OutBounce(start, end, t), 
			Easing.InOutBounce => InOutBounce(start, end, t), 
			Easing.OutInBounce => OutInBounce(start, end, t), 
			Easing.InBack => InBack(start, end, t), 
			Easing.OutBack => OutBack(start, end, t), 
			Easing.InOutBack => InOutBack(start, end, t), 
			Easing.OutInBack => OutInBack(start, end, t), 
			_ => Vector3.zero, 
		};
	}

	public static Vector3 Linear(Vector3 start, Vector3 end, float t)
	{
		return t * (end - start) + start;
	}

	public static Vector3 InQuad(Vector3 start, Vector3 end, float t)
	{
		return t * t * (end - start) + start;
	}

	public static Vector3 OutQuad(Vector3 start, Vector3 end, float t)
	{
		return (0f - t * (t - 2f)) * (end - start) + start;
	}

	public static Vector3 InOutQuad(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * (end - start) + start;
		}
		t -= 1f;
		return -0.5f * (t * (t - 2f) - 1f) * (end - start) + start;
	}

	public static Vector3 OutInQuad(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return (-0.5f * (t * (t - 2f) - 1f) - 0.5f) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * t * t + 0.5f) * (end - start) + start;
	}

	public static Vector3 InCubic(Vector3 start, Vector3 end, float t)
	{
		return t * t * t * (end - start) + start;
	}

	public static Vector3 OutCubic(Vector3 start, Vector3 end, float t)
	{
		t -= 1f;
		return (t * t * t + 1f) * (end - start) + start;
	}

	public static Vector3 InOutCubic(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * t * (end - start) + start;
		}
		t -= 2f;
		return 0.5f * (t * t * t + 2f) * (end - start) + start;
	}

	public static Vector3 OutInCubic(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return (0.5f * (t * t * t + 2f) - 0.5f) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * t * t * t + 0.5f) * (end - start) + start;
	}

	public static Vector3 InQuart(Vector3 start, Vector3 end, float t)
	{
		return t * t * t * t * (end - start) + start;
	}

	public static Vector3 OutQuart(Vector3 start, Vector3 end, float t)
	{
		t -= 1f;
		return (0f - (t * t * t * t - 1f)) * (end - start) + start;
	}

	public static Vector3 InOutQuart(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * t * t * (end - start) + start;
		}
		t -= 2f;
		return -0.5f * (t * t * t * t - 2f) * (end - start) + start;
	}

	public static Vector3 OutInQuart(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return (-0.5f * t * t * t * t + 0.5f) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * t * t * t * t + 0.5f) * (end - start) + start;
	}

	public static Vector3 InQuint(Vector3 start, Vector3 end, float t)
	{
		return t * t * t * t * t * (end - start) + start;
	}

	public static Vector3 OutQuint(Vector3 start, Vector3 end, float t)
	{
		t -= 1f;
		return (t * t * t * t * t + 1f) * (end - start) + start;
	}

	public static Vector3 InOutQuint(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * t * t * t * (end - start) + start;
		}
		t -= 2f;
		return (0.5f * t * t * t * t * t + 1f) * (end - start) + start;
	}

	public static Vector3 OutInQuint(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return (0.5f * (t * t * t * t * t) + 0.5f) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * t * t * t * t * t + 0.5f) * (end - start) + start;
	}

	public static Vector3 InSin(Vector3 start, Vector3 end, float t)
	{
		return (0f - Mathf.Cos(t * (float)Math.PI * 0.5f)) * (end - start) + end;
	}

	public static Vector3 OutSin(Vector3 start, Vector3 end, float t)
	{
		return Mathf.Sin(t * (float)Math.PI * 0.5f) * (end - start) + start;
	}

	public static Vector3 InOutSin(Vector3 start, Vector3 end, float t)
	{
		return (-0.5f * Mathf.Cos(t * (float)Math.PI) + 0.5f) * (end - start) + start;
	}

	public static Vector3 OutInSin(Vector3 start, Vector3 end, float t)
	{
		return (t - (-0.5f * Mathf.Cos(t * (float)Math.PI) + 0.5f - t)) * (end - start) + start;
	}

	public static Vector3 InExp(Vector3 start, Vector3 end, float t)
	{
		return Mathf.Pow(2f, 10f * (t - 1f)) * (end - start) + start;
	}

	public static Vector3 OutExp(Vector3 start, Vector3 end, float t)
	{
		return (1f - Mathf.Pow(2f, -10f * t)) * (end - start) + start;
	}

	public static Vector3 InOutExp(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * Mathf.Pow(2f, 10f * (t - 1f)) * (end - start) + start;
		}
		t -= 1f;
		return 0.5f * (2f - Mathf.Pow(2f, -10f * t)) * (end - start) + start;
	}

	public static Vector3 OutInExp(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return (0.5f * (2f - Mathf.Pow(2f, -10f * t)) - 0.5f) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * Mathf.Pow(2f, 10f * (t - 1f)) + 0.5f) * (end - start) + start;
	}

	public static Vector3 InCirc(Vector3 start, Vector3 end, float t)
	{
		return (0f - (Mathf.Sqrt(1f - t * t) - 1f)) * (end - start) + start;
	}

	public static Vector3 OutCirc(Vector3 start, Vector3 end, float t)
	{
		t -= 1f;
		return Mathf.Sqrt(1f - t * t) * (end - start) + start;
	}

	public static Vector3 InOutCirc(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return -0.5f * (Mathf.Sqrt(1f - t * t) - 1f) * (end - start) + start;
		}
		t -= 2f;
		return 0.5f * (Mathf.Sqrt(1f - t * t) + 1f) * (end - start) + start;
	}

	public static Vector3 OutInCirc(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return 0.5f * Mathf.Sqrt(1f - t * t) * (end - start) + start;
		}
		t -= 1f;
		return (-0.5f * Mathf.Sqrt(1f - t * t) + 1f) * (end - start) + start;
	}

	public static Vector3 InElastic(Vector3 start, Vector3 end, float t)
	{
		float num = 0.3f;
		float num2 = 0.075f;
		t -= 1f;
		return (0f - Mathf.Pow(2f, 10f * t)) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) * (end - start) + start;
	}

	public static Vector3 OutElastic(Vector3 start, Vector3 end, float t)
	{
		float num = 0.3f;
		float num2 = 0.075f;
		return Mathf.Pow(2f, -10f * t) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) * (end - start) + end;
	}

	public static Vector3 InOutElastic(Vector3 start, Vector3 end, float t)
	{
		float num = 0.3f;
		float num2 = 0.075f;
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return -0.5f * Mathf.Pow(2f, 10f * t) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) * (end - start) + start;
		}
		t -= 1f;
		return 0.5f * Mathf.Pow(2f, -10f * t) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) * (end - start) + end;
	}

	public static Vector3 OutInElastic(Vector3 start, Vector3 end, float t)
	{
		float num = 0.3f;
		float num2 = 0.075f;
		t *= 2f;
		if (t < 1f)
		{
			return (0.5f * Mathf.Pow(2f, -10f * t) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) - 0.5f) * (end - start) + end;
		}
		t -= 2f;
		return (-0.5f * Mathf.Pow(2f, 10f * t) * Mathf.Sin((t - num2) * ((float)Math.PI * 2f) / num) + 0.5f) * (end - start) + start;
	}

	public static Vector3 InBounce(Vector3 start, Vector3 end, float t)
	{
		t = 1f - t;
		if (t < 0.36363637f)
		{
			return (-7.5625f * t * t + 1f) * (end - start) + start;
		}
		if (t < 0.72727275f)
		{
			t -= 0.54545456f;
			return (-7.5625f * t * t - 0.75f + 1f) * (end - start) + start;
		}
		if (t < 0.90909094f)
		{
			t -= 0.8181818f;
			return (-7.5625f * t * t - 0.9375f + 1f) * (end - start) + start;
		}
		t -= 21f / 22f;
		return (-7.5625f * t * t - 63f / 64f + 1f) * (end - start) + start;
	}

	public static Vector3 OutBounce(Vector3 start, Vector3 end, float t)
	{
		if (t < 0.36363637f)
		{
			return 7.5625f * t * t * (end - start) + start;
		}
		if (t < 0.72727275f)
		{
			t -= 0.54545456f;
			return (7.5625f * t * t + 0.75f) * (end - start) + start;
		}
		if (t < 0.90909094f)
		{
			t -= 0.8181818f;
			return (7.5625f * t * t + 0.9375f) * (end - start) + start;
		}
		t -= 21f / 22f;
		return (7.5625f * t * t + 63f / 64f) * (end - start) + start;
	}

	public static Vector3 InOutBounce(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t = 1f - t;
			if (t < 0.36363637f)
			{
				return (-3.78125f * t * t + 0.5f) * (end - start) + start;
			}
			if (t < 0.72727275f)
			{
				t -= 0.54545456f;
				return (-0.5f * (7.5625f * t * t + 0.75f) + 0.5f) * (end - start) + start;
			}
			if (t < 0.90909094f)
			{
				t -= 0.8181818f;
				return (-0.5f * (7.5625f * t * t + 0.9375f) + 0.5f) * (end - start) + start;
			}
			t -= 21f / 22f;
			return (-0.5f * (7.5625f * t * t + 63f / 64f) + 0.5f) * (end - start) + start;
		}
		t -= 1f;
		if (t < 0.36363637f)
		{
			return (3.78125f * t * t + 0.5f) * (end - start) + start;
		}
		if (t < 0.72727275f)
		{
			t -= 0.54545456f;
			return (0.5f * (7.5625f * t * t + 0.75f) + 0.5f) * (end - start) + start;
		}
		if (t < 0.90909094f)
		{
			t -= 0.8181818f;
			return (0.5f * (7.5625f * t * t + 0.9375f) + 0.5f) * (end - start) + start;
		}
		t -= 21f / 22f;
		return (0.5f * (7.5625f * t * t + 63f / 64f) + 0.5f) * (end - start) + start;
	}

	public static Vector3 OutInBounce(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			if (t < 0.36363637f)
			{
				return 3.78125f * t * t * (end - start) + start;
			}
			if (t < 0.72727275f)
			{
				t -= 0.54545456f;
				return 0.5f * (7.5625f * t * t + 0.75f) * (end - start) + start;
			}
			if (t < 0.90909094f)
			{
				t -= 0.8181818f;
				return 0.5f * (7.5625f * t * t + 0.9375f) * (end - start) + start;
			}
			t -= 21f / 22f;
			return 0.5f * (7.5625f * t * t + 63f / 64f) * (end - start) + start;
		}
		t = 2f - t;
		if (t < 0.36363637f)
		{
			return (-3.78125f * t * t + 1f) * (end - start) + start;
		}
		if (t < 0.72727275f)
		{
			t -= 0.54545456f;
			return (-0.5f * (7.5625f * t * t + 0.75f) + 1f) * (end - start) + start;
		}
		if (t < 0.90909094f)
		{
			t -= 0.8181818f;
			return (-0.5f * (7.5625f * t * t + 0.9375f) + 1f) * (end - start) + start;
		}
		t -= 21f / 22f;
		return (-0.5f * (7.5625f * t * t + 63f / 64f) + 1f) * (end - start) + start;
	}

	public static Vector3 InBack(Vector3 start, Vector3 end, float t)
	{
		return t * t * (2.70158f * t - 1.70158f) * (end - start) + start;
	}

	public static Vector3 OutBack(Vector3 start, Vector3 end, float t)
	{
		t -= 1f;
		return (1f - t * t * (-2.70158f * t - 1.70158f)) * (end - start) + start;
	}

	public static Vector3 InOutBack(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * (2.70158f * t - 1.70158f) * (end - start) + start;
		}
		t -= 2f;
		return (1f - 0.5f * t * t * (-2.70158f * t - 1.70158f)) * (end - start) + start;
	}

	public static Vector3 OutInBack(Vector3 start, Vector3 end, float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			t -= 1f;
			return (0.5f - 0.5f * t * t * (-2.70158f * t - 1.70158f)) * (end - start) + start;
		}
		t -= 1f;
		return (0.5f * t * t * (2.70158f * t - 1.70158f) + 0.5f) * (end - start) + start;
	}
}
public class SplineUtil
{
	public static int ClampIndex(int idx, int len)
	{
		if (idx < 0)
		{
			idx = 0;
		}
		else if (idx > len - 1)
		{
			idx = len - 1;
		}
		return idx;
	}

	public static int WrapIndex(int idx, int len)
	{
		if (idx < 0)
		{
			idx = len + idx % len;
		}
		else if (idx >= len - 1)
		{
			idx %= len;
		}
		return idx;
	}

	public static float WrapPosition(BaseSpline.SplineWrapMode wrapmode, float pos, float len)
	{
		switch (wrapmode)
		{
		case BaseSpline.SplineWrapMode.Loop:
			if (pos < 0f)
			{
				int num3 = (int)((0f - pos) / len) + 1;
				pos += (float)num3 * len;
			}
			else if (pos >= len)
			{
				int num4 = (int)(pos / len);
				pos -= (float)num4 * len;
			}
			break;
		case BaseSpline.SplineWrapMode.PingPong:
			if (pos < 0f)
			{
				int num5 = (int)((0f - pos) / len) + 1;
				pos = ((num5 % 2 != 0) ? (len - (pos + (float)num5 * len)) : (pos + (float)num5 * len));
			}
			else if (pos >= len)
			{
				int num6 = (int)(pos / len);
				pos = ((num6 % 2 != 0) ? (len - (pos - (float)num6 * len)) : (pos - (float)num6 * len));
			}
			break;
		case BaseSpline.SplineWrapMode.Repeat:
			if (pos < 0f)
			{
				int num = (int)((0f - pos) / len) + 1;
				pos += (float)num * len;
			}
			else if (pos >= len)
			{
				int num2 = (int)(pos / len);
				pos -= (float)num2 * len;
			}
			break;
		case BaseSpline.SplineWrapMode.Once:
			if (pos < 0f)
			{
				pos = 0f;
			}
			else if (pos > len)
			{
				pos = len;
			}
			break;
		}
		return pos;
	}
}
[Serializable]
public class UniSpline : BaseSpline
{
	public class EditHelper
	{
		private UniSpline m_spline;

		private int m_idx = -1;

		private int m_selidx = -1;

		public Vector3 Point
		{
			get
			{
				return m_spline.m_points[m_idx];
			}
			set
			{
				m_spline.m_points[m_idx] = value;
			}
		}

		public Vector3 SelectedPoint
		{
			get
			{
				return m_spline.m_points[m_selidx];
			}
			set
			{
				m_spline.m_points[m_selidx] = value;
			}
		}

		public bool Selected
		{
			get
			{
				return m_idx == m_selidx;
			}
			set
			{
				if (value)
				{
					m_selidx = m_idx;
				}
				else
				{
					m_selidx = -1;
				}
			}
		}

		public bool SomethingSelected => m_selidx != -1;

		public int Index => m_idx;

		public int SelectedIndex => m_selidx;

		internal EditHelper(UniSpline spline)
		{
			m_spline = spline;
		}

		public bool MoveNext()
		{
			m_idx++;
			if (m_idx < m_spline.m_points.Count)
			{
				return true;
			}
			return false;
		}

		public void Reset()
		{
			m_idx = -1;
		}

		public void AppendPoint()
		{
			if (m_spline.m_points.Count == 0)
			{
				m_spline.AppendPoint(Vector3.zero);
			}
			else
			{
				m_spline.AppendPoint(m_spline.m_points[m_spline.m_points.Count - 1] + Vector3.right);
			}
			m_selidx = m_spline.m_points.Count - 1;
		}

		public void InsertBefore()
		{
			if (m_spline.m_points.Count == 1)
			{
				m_spline.InsertPoint(0, m_spline.m_points[m_spline.m_points.Count - 1] + Vector3.right);
				return;
			}
			int selidx = m_selidx;
			m_selidx--;
			if (m_selidx < 0)
			{
				m_selidx = m_spline.m_points.Count - 1;
			}
			m_spline.InsertPoint(selidx, (m_spline.m_points[m_selidx] + m_spline.m_points[selidx]) * 0.5f);
			m_selidx = selidx;
		}

		public void InsertAfter()
		{
			if (m_spline.m_points.Count == 1)
			{
				m_spline.InsertPoint(0, m_spline.m_points[m_spline.m_points.Count - 1] + Vector3.right);
				return;
			}
			int selidx = m_selidx;
			m_selidx++;
			if (m_selidx == m_spline.m_points.Count)
			{
				m_selidx = m_spline.m_points.Count - 1;
			}
			m_spline.InsertPoint(m_selidx, (m_spline.m_points[m_selidx] + m_spline.m_points[selidx]) * 0.5f);
		}

		public void Remove()
		{
			m_spline.m_points.RemoveAt(m_selidx);
			if (m_selidx >= m_spline.m_points.Count)
			{
				m_selidx = m_spline.m_points.Count - 1;
			}
		}

		public void RemoveLast()
		{
			if (m_spline.m_points.Count > 0)
			{
				m_spline.RemoveLastPoint();
			}
			if (m_selidx >= m_spline.m_points.Count)
			{
				m_selidx = m_spline.m_points.Count - 1;
			}
		}

		public void SelectFirst()
		{
			if (m_spline.m_points.Count > 0)
			{
				m_selidx = 0;
			}
			else
			{
				m_selidx = -1;
			}
		}

		public void SelectNext()
		{
			if (m_selidx < m_spline.m_points.Count - 1)
			{
				m_selidx++;
			}
			else
			{
				m_selidx = 0;
			}
		}

		public void SelectPrev()
		{
			if (m_selidx > 0)
			{
				m_selidx--;
			}
			else
			{
				m_selidx = m_spline.m_points.Count - 1;
			}
		}
	}

	[Serializable]
	public class UniSplineSegment
	{
		public Vector3 m_startpos;

		public Vector3 m_startctrl;

		public Vector3 m_endctrl;

		public Vector3 m_endpos;

		public float m_startlen;

		public float m_endlen;

		public float m_length;

		public float[] m_params;

		public float[] m_precomps;
	}

	[SerializeField]
	private UniSplineType m_type;

	[SerializeField]
	private List<Vector3> m_points = new List<Vector3>();

	[SerializeField]
	private UniSplineSegment[] m_segments;

	[SerializeField]
	private float m_bias;

	[SerializeField]
	private float m_tension;

	[SerializeField]
	private float m_continuity;

	[SerializeField]
	private float m_precompdiv = 1f;

	public UniSplineType SplineType
	{
		get
		{
			return m_type;
		}
		set
		{
			m_type = value;
		}
	}

	public float Bias
	{
		get
		{
			return m_bias;
		}
		set
		{
			if (value < -1f)
			{
				m_bias = -1f;
			}
			else if (value > 1f)
			{
				m_bias = 1f;
			}
			else
			{
				m_bias = value;
			}
		}
	}

	public float Continuity
	{
		get
		{
			return m_continuity;
		}
		set
		{
			if (value < -1f)
			{
				m_continuity = -1f;
			}
			else if (value > 1f)
			{
				m_continuity = 1f;
			}
			else
			{
				m_continuity = value;
			}
		}
	}

	public float Tension
	{
		get
		{
			return m_tension;
		}
		set
		{
			if (value < -1f)
			{
				m_tension = -1f;
			}
			else if (value > 1f)
			{
				m_tension = 1f;
			}
			else
			{
				m_tension = value;
			}
		}
	}

	public void AppendPoint(Vector3 pos)
	{
		m_points.Add(pos);
	}

	public void RemoveLastPoint()
	{
		m_points.RemoveAt(m_points.Count - 1);
	}

	public void RemoveAllPoints()
	{
		m_points.Clear();
	}

	public void ReversePoints()
	{
		m_points.Reverse();
	}

	public void InsertPoint(int idx, Vector3 pos)
	{
		if (idx < 0 || idx > m_points.Count)
		{
			throw new IndexOutOfRangeException();
		}
		m_points.Insert(idx, pos);
	}

	public override void Build()
	{
		Vector3 zero = Vector3.zero;
		Vector3 zero2 = Vector3.zero;
		Vector3 zero3 = Vector3.zero;
		Vector3 zero4 = Vector3.zero;
		if (m_points.Count < 2)
		{
			m_segments = null;
			m_length = 0f;
			return;
		}
		int num = ((m_wrapmode != SplineWrapMode.Loop) ? (m_points.Count - 1) : m_points.Count);
		m_segments = new UniSplineSegment[num];
		m_length = 0f;
		int i = 0;
		if (m_wrapmode == SplineWrapMode.Loop)
		{
			for (; i < num; i++)
			{
				zero = m_points[SplineUtil.WrapIndex(i, m_points.Count)];
				zero2 = m_points[SplineUtil.WrapIndex(i - 1, m_points.Count)];
				zero3 = m_points[SplineUtil.WrapIndex(i + 2, m_points.Count)];
				zero4 = m_points[SplineUtil.WrapIndex(i + 1, m_points.Count)];
				m_segments[i] = new UniSplineSegment();
				BuildSegment(m_segments[i], zero, zero2, zero3, zero4);
			}
		}
		else
		{
			for (; i < num; i++)
			{
				zero = m_points[SplineUtil.ClampIndex(i, m_points.Count)];
				zero2 = m_points[SplineUtil.ClampIndex(i - 1, m_points.Count)];
				zero3 = m_points[SplineUtil.ClampIndex(i + 2, m_points.Count)];
				zero4 = m_points[SplineUtil.ClampIndex(i + 1, m_points.Count)];
				m_segments[i] = new UniSplineSegment();
				BuildSegment(m_segments[i], zero, zero2, zero3, zero4);
			}
		}
		m_buildnum++;
	}

	private void BuildSegment(UniSplineSegment ss, Vector3 sp, Vector3 sc, Vector3 ec, Vector3 ep)
	{
		ss.m_startpos = sp;
		ss.m_endpos = ep;
		switch (m_type)
		{
		case UniSplineType.CatmullRom:
			ss.m_startctrl = sc;
			ss.m_endctrl = ec;
			break;
		case UniSplineType.Hermite:
		{
			float num5 = (1f - m_tension) * 0.5f;
			float num6 = (1f + m_bias) * num5;
			float num7 = (1f - m_bias) * num5;
			ss.m_startctrl = (sp - sc) * num6 + (ep - sp) * num7;
			ss.m_endctrl = (ep - sp) * num6 + (ec - ep) * num7;
			break;
		}
		case UniSplineType.KochanekBartels:
		{
			float num = (1f - m_tension) * (1f + m_bias) * (1f + m_continuity) * 0.5f;
			float num2 = (1f - m_tension) * (1f - m_bias) * (1f - m_continuity) * 0.5f;
			float num3 = (1f - m_tension) * (1f + m_bias) * (1f - m_continuity) * 0.5f;
			float num4 = (1f - m_tension) * (1f - m_bias) * (1f + m_continuity) * 0.5f;
			ss.m_startctrl = num * (sp - sc) + num2 * (ep - sp);
			ss.m_endctrl = num3 * (ep - sp) + num4 * (ec - ep);
			break;
		}
		}
		ss.m_startlen = m_length;
		float length = GetLength(ss);
		m_length += length;
		ss.m_length = length;
		ss.m_endlen = m_length;
		switch (m_reparam)
		{
		case SplineReparamType.None:
			ss.m_params = null;
			ss.m_precomps = null;
			break;
		case SplineReparamType.Simple:
		{
			m_precompdiv = 1f / (float)m_stepcount;
			float num10 = 0f;
			float num11 = 0f;
			ss.m_params = new float[m_stepcount + 1];
			ss.m_precomps = new float[m_stepcount + 1];
			for (int j = 1; j < m_stepcount + 1; j++)
			{
				Vector3 position = GetPosition(ss, num10);
				num10 += m_precompdiv;
				Vector3 position2 = GetPosition(ss, num10);
				num11 += (position2 - position).magnitude;
				ss.m_precomps[j] = num11 / length;
				ss.m_params[j] = num10;
			}
			ss.m_params[0] = 0f;
			ss.m_params[m_stepcount] = 1f;
			ss.m_precomps[0] = 0f;
			ss.m_precomps[m_stepcount] = 1f;
			m_precompdiv = 1f / (float)m_stepcount;
			break;
		}
		case SplineReparamType.RungeKutta:
		{
			float num8 = length / (float)m_stepcount;
			float num9 = 0f;
			ss.m_params = new float[m_stepcount + 1];
			ss.m_precomps = new float[m_stepcount + 1];
			for (int i = 0; i < m_stepcount + 1; i++)
			{
				ss.m_params[i] = GetReparamRungeKutta(ss, num9);
				ss.m_precomps[i] = num9 / length;
				num9 += num8;
			}
			ss.m_params[0] = 0f;
			ss.m_params[m_stepcount] = 1f;
			ss.m_precomps[0] = 0f;
			ss.m_precomps[m_stepcount] = 1f;
			m_precompdiv = 1f / (float)m_stepcount;
			break;
		}
		}
	}

	private float GetLength(UniSplineSegment ss)
	{
		float num = 0f;
		float num2 = 0f;
		float num3 = 1f / (float)m_stepcount;
		int i = 0;
		Vector3 vector = ss.m_startpos;
		for (; i < m_stepcount; i++)
		{
			num2 += num3;
			Vector3 position = GetPosition(ss, num2);
			num += (position - vector).magnitude;
			vector = position;
		}
		return num;
	}

	private Vector3 GetPosition(UniSplineSegment ss, float t)
	{
		switch (m_type)
		{
		case UniSplineType.CatmullRom:
		{
			float num5 = t * t;
			float num6 = num5 * t;
			return ss.m_startpos * (1.5f * num6 - 2.5f * num5 + 1f) + ss.m_startctrl * (-0.5f * num6 + num5 - 0.5f * t) + ss.m_endctrl * (0.5f * num6 - 0.5f * num5) + ss.m_endpos * (-1.5f * num6 + 2f * num5 + 0.5f * t);
		}
		case UniSplineType.Hermite:
		{
			float num3 = t * t;
			float num4 = num3 * t;
			return ss.m_startpos * (2f * num4 - 3f * num3 + 1f) + ss.m_startctrl * (num4 - 2f * num3 + t) + ss.m_endctrl * (num4 - num3) + ss.m_endpos * (-2f * num4 + 3f * num3);
		}
		case UniSplineType.KochanekBartels:
		{
			float num = t * t;
			float num2 = num * t;
			return ss.m_startpos * (2f * num2 - 3f * num + 1f) + ss.m_startctrl * (num2 - 2f * num + t) + ss.m_endctrl * (num2 - num) + ss.m_endpos * (-2f * num2 + 3f * num);
		}
		default:
			return Vector3.zero;
		}
	}

	private Vector3 GetTangent(UniSplineSegment ss, float t)
	{
		switch (m_type)
		{
		case UniSplineType.CatmullRom:
		{
			float num3 = t * t;
			return ss.m_startpos * (4.5f * t - 5f) * t + ss.m_startctrl * (-1.5f * num3 + 2f * t - 0.5f) + ss.m_endctrl * (1.5f * t - 1f) * t + ss.m_endpos * (-4.5f * num3 + 4f * t + 0.5f);
		}
		case UniSplineType.Hermite:
		{
			float num2 = t * t;
			return ss.m_startpos * (6f * num2 - 6f * t) + ss.m_startctrl * (3f * num2 - 4f * t + 1f) + ss.m_endctrl * (3f * num2 - 2f * t) + ss.m_endpos * (-6f * num2 + 6f * t);
		}
		case UniSplineType.KochanekBartels:
		{
			float num = t * t;
			return ss.m_startpos * (6f * num - 6f * t) + ss.m_startctrl * (3f * num - 4f * t + 1f) + ss.m_endctrl * (3f * num - 2f * t) + ss.m_endpos * (-6f * num + 6f * t);
		}
		default:
			return Vector3.zero;
		}
	}

	private Vector3 GetNormal(UniSplineSegment ss, float t)
	{
		return m_type switch
		{
			UniSplineType.CatmullRom => ss.m_startpos * (9f * t - 5f) - ss.m_startctrl * (2f - 3f * t) + 9f * ss.m_endpos * t + 3f * ss.m_endctrl * t + 4f * ss.m_endpos - ss.m_endctrl, 
			UniSplineType.Hermite => ss.m_startpos * (12f * t - 6f) + ss.m_startctrl * (6f * t - 4f) + ss.m_endctrl * (6f * t - 2f) + ss.m_endpos * (-12f * t + 6f), 
			UniSplineType.KochanekBartels => ss.m_startpos * (12f * t - 6f) + ss.m_startctrl * (6f * t - 4f) + ss.m_endctrl * (6f * t - 2f) + ss.m_endpos * (-12f * t + 6f), 
			_ => Vector3.zero, 
		};
	}

	private float GetReparamRungeKutta(UniSplineSegment ss, float u)
	{
		float num = 0f;
		float num2 = u / (float)m_stepcount;
		for (int i = 1; i <= m_stepcount; i++)
		{
			float magnitude = GetTangent(ss, num).magnitude;
			float num3;
			float num4;
			float num5;
			float num6;
			if (magnitude == 0f)
			{
				num3 = 0f;
				num4 = 0f;
				num5 = 0f;
				num6 = 0f;
			}
			else
			{
				num3 = num2 / GetTangent(ss, num).magnitude;
				num4 = num2 / GetTangent(ss, num + num3 * 0.5f).magnitude;
				num5 = num2 / GetTangent(ss, num + num4 * 0.5f).magnitude;
				num6 = num2 / GetTangent(ss, num + num5).magnitude;
			}
			num += (num3 + 2f * (num4 + num5) + num6) * (1f / 6f);
		}
		return num;
	}

	private float GetReparam(UniSplineSegment ss, float u)
	{
		if (u <= 0f)
		{
			return 0f;
		}
		if (u >= 1f)
		{
			return 1f;
		}
		switch (m_reparam)
		{
		case SplineReparamType.RungeKutta:
		{
			int num2 = (int)(u * (float)m_stepcount);
			float t2 = (u - ss.m_precomps[num2]) / m_precompdiv;
			return Mathf.Lerp(ss.m_params[num2], ss.m_params[num2 + 1], t2);
		}
		case SplineReparamType.Simple:
		{
			int num = 0;
			for (int i = 1; i < m_stepcount + 1; i++)
			{
				if (ss.m_precomps[i] > u)
				{
					num = i - 1;
					break;
				}
			}
			float t = (u - ss.m_precomps[num]) / (ss.m_precomps[num + 1] - ss.m_precomps[num]);
			return Mathf.Lerp(ss.m_params[num], ss.m_params[num + 1], t);
		}
		default:
			return 0f;
		}
	}

	public override int GetPointCount()
	{
		return m_points.Count;
	}

	public override int GetSegmentCount()
	{
		if (m_segments != null)
		{
			return m_segments.Length;
		}
		return 0;
	}

	protected override float GetSegmentLength(int segidx)
	{
		return m_segments[segidx].m_length;
	}

	protected override float GetSegmentStartLength(int segidx)
	{
		return m_segments[segidx].m_startlen;
	}

	protected override float GetSegmentEndLength(int segidx)
	{
		return m_segments[segidx].m_endlen;
	}

	protected override int FindSegment(float offset)
	{
		for (int i = 0; i < m_segments.Length; i++)
		{
			if (m_segments[i].m_startlen <= offset && m_segments[i].m_endlen > offset)
			{
				return i;
			}
		}
		return m_segments.Length - 1;
	}

	protected override Vector3 GetDrawPosition(int segidx, float t)
	{
		UniSplineSegment ss = m_segments[segidx];
		return GetPosition(ss, t);
	}

	protected override Vector3 GetPosition(int segidx, float segpos)
	{
		UniSplineSegment uniSplineSegment = m_segments[segidx];
		if (m_reparam == SplineReparamType.None)
		{
			return GetPosition(uniSplineSegment, segpos / uniSplineSegment.m_length);
		}
		return GetPosition(uniSplineSegment, GetReparam(uniSplineSegment, segpos / uniSplineSegment.m_length));
	}

	protected override Vector3 GetTangent(int segidx, float segpos)
	{
		UniSplineSegment uniSplineSegment = m_segments[segidx];
		if (m_reparam == SplineReparamType.None)
		{
			return GetTangent(uniSplineSegment, segpos / uniSplineSegment.m_length);
		}
		return GetTangent(uniSplineSegment, GetReparam(uniSplineSegment, segpos / uniSplineSegment.m_length));
	}

	protected override Vector3 GetNormal(int segidx, float segpos)
	{
		UniSplineSegment uniSplineSegment = m_segments[segidx];
		if (m_reparam == SplineReparamType.None)
		{
			return GetNormal(uniSplineSegment, segpos / uniSplineSegment.m_length);
		}
		return GetNormal(uniSplineSegment, GetReparam(uniSplineSegment, segpos / uniSplineSegment.m_length));
	}

	public EditHelper GetEditHelper()
	{
		return new EditHelper(this);
	}
}
public class UniSplineComponent : MonoBehaviour
{
	[SerializeField]
	private UniSpline m_spline = new UniSpline();

	private int m_buildnum = -1;

	private Vector3[] m_drawcache;

	public UniSpline Spline => m_spline;

	private void OnDrawGizmosSelected()
	{
		DrawGizmos(Color.red);
	}

	private void OnDrawGizmos()
	{
		DrawGizmos(Color.white);
	}

	public void DrawGizmos(Color color)
	{
		int buildNum = m_spline.BuildNum;
		if (m_spline.GetSegmentCount() <= 0)
		{
			return;
		}
		if (m_buildnum != buildNum)
		{
			m_drawcache = m_spline.GenerateDrawPoints(16);
			m_buildnum = buildNum;
		}
		if (m_drawcache == null)
		{
			return;
		}
		Gizmos.matrix = base.transform.localToWorldMatrix;
		Gizmos.color = color;
		Vector3 from = Vector3.zero;
		Vector3 zero = Vector3.zero;
		for (int i = 0; i < m_drawcache.Length; i++)
		{
			zero = m_drawcache[i];
			if (i != 0)
			{
				Gizmos.DrawLine(from, zero);
			}
			from = zero;
		}
	}
}
public class UniSplineTest : MonoBehaviour
{
	public UniSplineComponent m_spline;

	public float m_speed = 1f;

	public float m_curspeed;

	public float m_position;

	public Vector3 m_up = Vector3.up;

	public Ease.Easing m_easing;

	private BaseSpline.SplineIterator m_iter;

	private void Awake()
	{
		m_iter = m_spline.Spline.GetIterator();
		m_iter.SetTransform(m_spline.transform);
	}

	private void Update()
	{
		m_position += m_speed * Time.deltaTime;
		m_iter.SetOffset(Ease.EaseByType(m_easing, 0f, m_spline.Spline.Length, m_position / m_spline.Spline.Length));
		Vector3 position = base.transform.position;
		base.transform.position = m_iter.GetPosition();
		base.transform.rotation = Quaternion.LookRotation(m_iter.GetTangent(), m_up);
		m_curspeed = (base.transform.position - position).magnitude / Time.deltaTime;
	}
}
public class BlackoutScreen : MonoBehaviour
{
	public int waitFrames = 1;

	public bool disableOnWaitFrames = true;

	private int curFrames;

	public Color fadeColor = new Color(0f, 0f, 0f, 1f);

	private Material fadeMaterial;

	private void Awake()
	{
		curFrames = 0;
		fadeMaterial = new Material(Shader.Find("Oculus/Unlit Transparent Color"));
		fadeMaterial.color = fadeColor;
	}

	private void OnDestroy()
	{
		if (fadeMaterial != null)
		{
			UnityEngine.Object.Destroy(fadeMaterial);
		}
	}

	private void Update()
	{
		if (disableOnWaitFrames && curFrames > waitFrames)
		{
			base.enabled = false;
			disableOnWaitFrames = false;
		}
	}

	private void OnPostRender()
	{
		if (disableOnWaitFrames)
		{
			curFrames++;
		}
		fadeMaterial.SetPass(0);
		GL.PushMatrix();
		GL.LoadOrtho();
		GL.Color(fadeMaterial.color);
		GL.Begin(7);
		GL.Vertex3(0f, 0f, -12f);
		GL.Vertex3(0f, 1f, -12f);
		GL.Vertex3(1f, 1f, -12f);
		GL.Vertex3(1f, 0f, -12f);
		GL.End();
		GL.PopMatrix();
	}

	public void SetColor(Color color)
	{
		fadeColor = color;
		fadeMaterial.color = color;
	}
}
public class ClearMemory : MonoBehaviour
{
	private static List<Texture> runtimeTextures = new List<Texture>();

	private static List<Material> runtimeMaterials = new List<Material>();

	private void Awake()
	{
		Clear();
		UnityEngine.Object.Destroy(this);
	}

	public static void Clear()
	{
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		for (int i = 0; i < runtimeMaterials.Count; i++)
		{
			UnityEngine.Object.Destroy(runtimeMaterials[i]);
		}
		runtimeMaterials.Clear();
		for (int j = 0; j < runtimeTextures.Count; j++)
		{
			UnityEngine.Object.Destroy(runtimeTextures[j]);
		}
		runtimeTextures.Clear();
		TextureAtlas.Clear();
		Map.Clear();
		AmbientManager.Clear();
		Jukebox.Clear();
		VisibilityProbeManager.Clear();
		VisibilityProbe.Clear();
		CollectableSpawn.Clear();
		PlayerStats.Clear();
		MapChunk.Clear();
		Player.Clear();
		GameController.Clear();
		Pathfinder.Clear();
		Debug.Log("Allocated memory before collect:" + GC.GetTotalMemory(forceFullCollection: false));
		GC.Collect();
		Debug.Log("Allocated memory after collect:" + GC.GetTotalMemory(forceFullCollection: true));
		Debug.Log("Time - ClearMemory " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
	}

	public static void AddRuntimeTexture(Texture tex)
	{
		runtimeTextures.Add(tex);
	}

	public static void AddRuntimeMaterial(Material mat)
	{
		runtimeMaterials.Add(mat);
	}
}
public class ClockMode
{
	public enum Mode
	{
		Standard,
		High,
		Low,
		CPUIntensive,
		GPUIntensive,
		PowerSave
	}

	private static Mode currentMode = Mode.PowerSave;

	public static void Set(Mode mode)
	{
		if (mode != currentMode)
		{
			currentMode = mode;
			Debug.Log("ClockMode: " + mode);
			switch (mode)
			{
			case Mode.Standard:
				OVRManager.cpuLevel = 3;
				OVRManager.gpuLevel = 2;
				break;
			case Mode.High:
				OVRManager.cpuLevel = 3;
				OVRManager.gpuLevel = 2;
				break;
			case Mode.Low:
				OVRManager.cpuLevel = 1;
				OVRManager.gpuLevel = 2;
				break;
			case Mode.CPUIntensive:
				OVRManager.cpuLevel = 3;
				OVRManager.gpuLevel = 1;
				break;
			case Mode.GPUIntensive:
				OVRManager.cpuLevel = 1;
				OVRManager.gpuLevel = 3;
				break;
			case Mode.PowerSave:
				OVRManager.cpuLevel = 0;
				OVRManager.gpuLevel = 0;
				break;
			}
		}
	}
}
public class Config
{
	[Serializable]
	public class GeneralCfg
	{
		public string language = string.Empty;

		public bool tutorials = true;

		public bool oracleSubtitles = true;

		public bool endingCredits;

		public bool randomModeUnlocked;

		public void Serialize(string key)
		{
			PlayerPrefs.SetString(key + ".language", language);
			PlayerPrefs.SetInt(key + ".tutorials", tutorials ? 1 : 0);
			PlayerPrefs.SetInt(key + ".endingCredits", endingCredits ? 1 : 0);
			PlayerPrefs.SetInt(key + ".randomModeUnlocked", randomModeUnlocked ? 1 : 0);
		}

		public void Deserialize(string key)
		{
			language = PlayerPrefs.GetString(key + ".language", language);
			tutorials = PlayerPrefs.GetInt(key + ".tutorials", tutorials ? 1 : 0) == 1;
			endingCredits = PlayerPrefs.GetInt(key + ".endingCredits", endingCredits ? 1 : 0) == 1;
			randomModeUnlocked = PlayerPrefs.GetInt(key + ".randomModeUnlocked", randomModeUnlocked ? 1 : 0) == 1;
		}
	}

	[Serializable]
	public class VideoCfg
	{
		public void Serialize(string key)
		{
		}

		public void Deserialize(string key)
		{
		}
	}

	[Serializable]
	public class InputCfg
	{
		public float mouseSensitivity = 0.75f;

		public float gamepadSensitivity = 1.25f;

		public bool comfortRotation = true;

		public bool tankMode;

		public int rotationSpeed = 3;

		public bool leftHanded;

		public void Serialize(string key)
		{
			PlayerPrefs.SetInt(key + ".comfortRotation", comfortRotation ? 1 : 0);
			PlayerPrefs.SetInt(key + ".rotationSpeed", rotationSpeed);
			PlayerPrefs.SetInt(key + ".tankMode", tankMode ? 1 : 0);
			PlayerPrefs.SetInt(key + ".leftHanded", leftHanded ? 1 : 0);
		}

		public void Deserialize(string key)
		{
			comfortRotation = PlayerPrefs.GetInt(key + ".comfortRotation", comfortRotation ? 1 : 0) == 1;
			rotationSpeed = PlayerPrefs.GetInt(key + ".rotationSpeed", rotationSpeed);
			tankMode = PlayerPrefs.GetInt(key + ".tankMode", tankMode ? 1 : 0) == 1;
			leftHanded = PlayerPrefs.GetInt(key + ".leftHanded", leftHanded ? 1 : 0) == 1;
		}
	}

	[Serializable]
	public class AudioCfg
	{
		public float masterVolume = 1f;

		public float musicVolume = 1f;

		public void Serialize(string key)
		{
			PlayerPrefs.SetFloat(key + ".masterVolume", masterVolume);
			PlayerPrefs.SetFloat(key + ".musicVolume", musicVolume);
		}

		public void Deserialize(string key)
		{
			masterVolume = PlayerPrefs.GetFloat(key + ".masterVolume", masterVolume);
			musicVolume = PlayerPrefs.GetFloat(key + ".musicVolume", musicVolume);
		}
	}

	private static Config instance;

	private GeneralCfg general;

	private VideoCfg video;

	private InputCfg input;

	private AudioCfg audio;

	private Config()
	{
		general = new GeneralCfg();
		video = new VideoCfg();
		input = new InputCfg();
		audio = new AudioCfg();
	}

	public static Config Get()
	{
		if (instance == null)
		{
			instance = new Config();
		}
		return instance;
	}

	public static void Reset()
	{
		instance = null;
	}

	public static GeneralCfg General()
	{
		return Get().general;
	}

	public static VideoCfg Video()
	{
		return Get().video;
	}

	public static InputCfg Input()
	{
		return Get().input;
	}

	public static AudioCfg Audio()
	{
		return Get().audio;
	}

	public static void Load()
	{
		Config config = Get();
		config.general.Deserialize("GeneralCfg");
		config.video.Deserialize("VideoCfg");
		config.input.Deserialize("InputCfg");
		config.audio.Deserialize("AudioCfg");
	}

	public static void Save()
	{
		Config config = Get();
		config.general.Serialize("GeneralCfg");
		config.video.Serialize("VideoCfg");
		config.input.Serialize("InputCfg");
		config.audio.Serialize("AudioCfg");
	}
}
public class AnimStepSounds : MonoBehaviour
{
	public AudioClip[] sounds;

	public float minDistance = 1f;

	public float maxDistance = 15f;

	public float spread;

	public bool logarithmic = true;

	public bool playing = true;

	private int soundIndex;

	public void PlayStepSound()
	{
		if (playing)
		{
			Utils.PlayClipAt(sounds[soundIndex], base.transform.position, minDistance, maxDistance, spread, (!logarithmic) ? AudioRolloffMode.Linear : AudioRolloffMode.Logarithmic);
			int num = soundIndex;
			do
			{
				soundIndex = UnityEngine.Random.Range(0, sounds.Length);
			}
			while (soundIndex == num && sounds.Length > 1);
		}
	}
}
public class AnimWarper : MonoBehaviour
{
	private class BoneState
	{
		public Transform transform;

		public int depth;

		public Vector3 deltaPos;

		public Vector3 deltaScale;

		public Vector3 startPos;

		public Quaternion startRot;

		public BoneState(Transform bone, int boneDepth)
		{
			transform = bone;
			depth = boneDepth;
			deltaPos = Vector3.zero;
			deltaScale = Vector3.one;
			startPos = bone.localPosition;
			startRot = bone.localRotation;
		}

		public void AddPos(Vector3 delta)
		{
			deltaPos += delta;
		}

		public void AddScale(float scale)
		{
			deltaScale *= scale;
		}

		public void AddScale(Vector3 scale)
		{
			deltaScale = new Vector3(deltaScale.x * scale.x, deltaScale.y * scale.y, deltaScale.z * scale.z);
		}
	}

	public Transform head;

	public Transform root;

	public Renderer bodyRenderer;

	public Renderer eyesRenderer;

	private Dictionary<int, BoneState> bonesDict;

	public Transform[] warpWave;

	private List<Transform>[] warpWaveBones;

	[Range(0f, 1f)]
	public float warpIntensity = 1f;

	public Transform[] warpScale;

	private List<Transform>[] warpScaleBones;

	[Range(0f, 1f)]
	public float scaleIntensity = 1f;

	public Vector3 curveDirection = new Vector3(0f, 0f, -1f);

	[Range(0f, 1f)]
	public float curveIntensity = 1f;

	[Range(0f, 1f)]
	public float headTracking;

	[Range(0f, 1f)]
	public float verticalCollapse;

	private CapsuleCollider capCollider;

	private float capsuleHeight;

	private Vector3 capsuleCenter;

	public float minColliderFactor = 0.6f;

	private float waiter = 5f;

	private bool inited;

	private void Start()
	{
		bodyRenderer.enabled = false;
		if (eyesRenderer != null)
		{
			eyesRenderer.enabled = false;
		}
		capCollider = GetComponent<CapsuleCollider>();
		if (capCollider != null)
		{
			capsuleHeight = capCollider.height;
			capsuleCenter = capCollider.center;
		}
	}

	private void AddBonesToDict(Transform bone, int depth = 0)
	{
		bonesDict[bone.GetInstanceID()] = new BoneState(bone, depth);
		for (int i = 0; i < bone.childCount; i++)
		{
			AddBonesToDict(bone.GetChild(i).transform, depth + 1);
		}
	}

	private void AddBonesToList(Transform bone, List<Transform> list)
	{
		list.Add(bone);
		for (int i = 0; i < bone.childCount; i++)
		{
			AddBonesToList(bone.GetChild(i).transform, list);
		}
	}

	private void Update()
	{
		if (!inited)
		{
			inited = true;
			bonesDict = new Dictionary<int, BoneState>();
			AddBonesToDict(root);
			warpWaveBones = new List<Transform>[warpWave.Length];
			for (int i = 0; i < warpWave.Length; i++)
			{
				warpWaveBones[i] = new List<Transform>();
				AddBonesToList(warpWave[i], warpWaveBones[i]);
			}
			warpScaleBones = new List<Transform>[warpScale.Length];
			for (int j = 0; j < warpScale.Length; j++)
			{
				warpScaleBones[j] = new List<Transform>();
				AddBonesToList(warpScale[j], warpScaleBones[j]);
			}
			bodyRenderer.enabled = true;
			if (eyesRenderer != null)
			{
				eyesRenderer.enabled = true;
			}
		}
		else
		{
			if (waiter > 0f)
			{
				waiter -= Time.deltaTime;
			}
			ApplyVerticalCollapse();
		}
	}

	private void LateUpdate()
	{
		if (!inited)
		{
			return;
		}
		ApplyWarpWave();
		ApplyWarpScale();
		ApplyCurve();
		foreach (BoneState value in bonesDict.Values)
		{
			value.transform.localPosition = value.startPos + value.deltaPos;
			value.transform.localScale = value.deltaScale;
			value.deltaPos = Vector3.zero;
			value.deltaScale = Vector3.one;
		}
		Vector3 forward = Player.GetCenterEye() - head.position;
		forward.Normalize();
		Quaternion b = Quaternion.LookRotation(forward, base.transform.up) * Quaternion.Euler(0f, -90f, -90f);
		head.rotation = Quaternion.Slerp(GetBone(head).transform.rotation, b, headTracking);
	}

	private void OnDisable()
	{
	}

	private void ApplyWarpWave()
	{
		for (int i = 0; i < warpWaveBones.Length; i++)
		{
			for (int j = 0; j < warpWaveBones[i].Count; j++)
			{
				int num = (j + 1) * (i + 1);
				float num2 = Mathf.PerlinNoise(num, Time.time * 0.25f) * 2f - 1f;
				float num3 = Mathf.PerlinNoise(num, Time.time * 0.25f + 1.5f) * 2f - 1f;
				float num4 = Mathf.PerlinNoise(num, Time.time * 0.25f + 2f) * 2f - 1f;
				GetBone(warpWaveBones[i][j]).AddPos(new Vector3(num2 * 0.1f, num3 * 0.1f, num4 * 0.1f) * warpIntensity);
			}
		}
	}

	private void ApplyWarpScale()
	{
		for (int i = 0; i < warpScaleBones.Length; i++)
		{
			for (int j = 0; j < warpScaleBones[i].Count; j++)
			{
				int num = (j + 1) * (i + 1);
				float num2 = Mathf.PerlinNoise(num, Time.time * 0.15f) * 2f - 1f;
				float num3 = Mathf.PerlinNoise(num, Time.time * 0.15f + 1.5f) * 2f - 1f;
				float num4 = Mathf.PerlinNoise(num, Time.time * 0.15f + 2f) * 2f - 1f;
				GetBone(warpScaleBones[i][j]).AddScale(Vector3.one + new Vector3(num2 * 0.05f * scaleIntensity, num3 * 0.05f * scaleIntensity, num4 * 0.05f * scaleIntensity));
			}
		}
	}

	private void ApplyCurve()
	{
		Vector3 vec = curveDirection;
		vec = vec.ToGround();
		vec.Normalize();
		foreach (BoneState value in bonesDict.Values)
		{
			float num = Mathf.Abs(value.transform.position.y - base.transform.position.y);
			float num2 = Mathf.Clamp01(num - 0.15f);
			Vector3 direction = vec * Mathf.Sin(num * 0.25f) * curveIntensity * 0.16f * num2;
			direction = value.transform.InverseTransformDirection(direction);
			value.AddPos(direction);
		}
	}

	public void ApplyVerticalCollapse()
	{
		Material material = bodyRenderer.material;
		material.SetFloat("_CollapseShift", Mathf.Lerp(0f, 2.5f, Interpolate.EaseInOut(verticalCollapse)));
		material.SetFloat("_RimIntensity", Mathf.Lerp(0.02f, 0f, verticalCollapse));
		material.SetFloat("_WarpCenter", Mathf.Clamp01(verticalCollapse * 2f));
		if (eyesRenderer != null)
		{
			eyesRenderer.enabled = verticalCollapse <= 0.05f;
		}
		if (capCollider != null)
		{
			float num = Mathf.Clamp(verticalCollapse, 0f, 1f - minColliderFactor);
			capCollider.height = capsuleHeight * (1f - num);
			capCollider.center = Vector3.Lerp(capsuleCenter, Vector3.zero, num);
			capCollider.enabled = (minColliderFactor > 0f && capCollider.height > 0.2f) || capCollider.height > 1f;
		}
	}

	private BoneState GetBone(Transform bone)
	{
		return bonesDict[bone.GetInstanceID()];
	}
}
public class Bat : MonoBehaviour
{
	public Room room;

	public float displacementMin = 1f;

	public float displacementMax = 4f;

	public float speedMin = 0.3f;

	public float speedMax = 0.5f;

	public float controlInitMin = 15f;

	public float controlInitMax = 18f;

	public float controlEndMin = -9f;

	public float controlEndMax = -2f;

	public float minWait;

	public float maxWait = 0.6f;

	private Vector3 initPos;

	private Vector3 endPos;

	private Vector3 controlPointInit;

	private Vector3 controlPointEnd;

	private float progress;

	private float speed;

	private float wait;

	private static List<Point> pitCandidates = new List<Point>();

	private static List<Point> shaftCandidates = new List<Point>();

	private static Room candidatesRoom;

	private void Start()
	{
		if (room == null)
		{
			room = Map.Get().At(base.transform.position).Room;
			if (room == null)
			{
				UnityEngine.Object.Destroy(base.gameObject);
				return;
			}
		}
		if (candidatesRoom != room)
		{
			pitCandidates.Clear();
			shaftCandidates.Clear();
			candidatesRoom = room;
			for (int i = room.Start.Y; i < room.Start.Y + room.Size.Y; i++)
			{
				for (int j = room.Start.X; j < room.Start.X + room.Size.X; j++)
				{
					Cell cell = Map.Get().At(j, i);
					if (cell.Room == room)
					{
						if (cell.IsPit())
						{
							pitCandidates.Add(new Point(j, i));
						}
						if (cell.CeilingShaft)
						{
							shaftCandidates.Add(new Point(j, i));
						}
					}
				}
			}
		}
		if (pitCandidates.Count == 0 || shaftCandidates.Count == 0)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		Point cellPos = RandomExt.Choice(pitCandidates);
		Point cellPos2 = RandomExt.Choice(shaftCandidates);
		initPos = Map.Get().CellToWorld(cellPos) - Vector3.up * 13.5f;
		Vector2 vector = UnityEngine.Random.insideUnitCircle * 1.5f / 2f;
		initPos.x += vector.x;
		initPos.z += vector.y;
		endPos = Map.Get().CellToWorld(cellPos2) + Vector3.up * 13.5f;
		vector = UnityEngine.Random.insideUnitCircle * 1.5f / 2f;
		endPos.x += vector.x;
		endPos.z += vector.y;
		float num = UnityEngine.Random.Range(controlInitMin, controlInitMax);
		float num2 = UnityEngine.Random.Range(controlEndMin, controlEndMax);
		controlPointInit = Map.Get().CellToWorld(cellPos) + Vector3.up * num;
		controlPointEnd = Map.Get().CellToWorld(cellPos2) + Vector3.up * num2;
		base.transform.position = initPos;
		progress = 0f;
		speed = UnityEngine.Random.Range(speedMin, speedMax);
		wait = UnityEngine.Random.Range(minWait, maxWait);
	}

	private void Update()
	{
		if (wait > 0f)
		{
			wait -= Time.deltaTime;
			if (wait > 0f)
			{
				return;
			}
			GetComponent<Animation>().Rewind();
			if (UnityEngine.Random.value <= 0.3f)
			{
				GetComponent<AudioSource>().Play();
			}
		}
		progress += Time.deltaTime * speed;
		if (progress > 1f)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		Vector3 position = base.transform.position;
		Vector3 vector = Interpolate.Bezier(initPos, controlPointInit, controlPointEnd, endPos, progress);
		Vector3 vector2 = vector - position;
		vector2.Normalize();
		base.transform.position = vector;
		base.transform.rotation = Quaternion.LookRotation(-vector2, Vector3.up);
	}
}
public class BellyLight : MonoBehaviour
{
	public Renderer bodyRenderer;

	public Light pointLight;

	public float lightLevel;

	public float lightRate = 0.1f;

	private Material bodyMaterial;

	private float maxEmission;

	private float maxLightIntensity;

	private float levelTarget;

	private void Start()
	{
		bodyMaterial = bodyRenderer.material;
		maxEmission = bodyMaterial.GetFloat("_EmissionIntensity");
		maxLightIntensity = pointLight.intensity;
	}

	private void Update()
	{
		bodyMaterial.SetFloat("_EmissionIntensity", maxEmission * lightLevel);
		pointLight.intensity = maxLightIntensity * lightLevel;
		if (lightLevel >= levelTarget)
		{
			lightLevel -= lightRate * Time.deltaTime;
			levelTarget = 0f;
		}
		else
		{
			lightLevel += lightRate * 5f * Time.deltaTime;
		}
		lightLevel = Mathf.Clamp01(lightLevel);
	}

	public void AddLight()
	{
		levelTarget = 1f;
	}
}
public class CreatureCounter : MonoBehaviour
{
	public enum CreatureType
	{
		Floater,
		Gargoyle,
		Ghost,
		LightEater,
		Shadow
	}

	public CreatureType creatureType;

	private Point lastPos;

	private Room lastRoom;

	private void Start()
	{
		lastPos = new Point(0, 0);
		lastRoom = null;
	}

	private void Update()
	{
		Point point = Map.Get().WorldToCell(base.transform.position);
		if (!(point != lastPos))
		{
			return;
		}
		Room room = ((!Map.Get().InRange(point)) ? null : Map.Get().At(point).Room);
		if (room != lastRoom)
		{
			if (lastRoom != null)
			{
				lastRoom.creatures.Remove(this);
			}
			room?.creatures.Add(this);
			lastRoom = room;
		}
		lastPos = point;
	}

	private void OnDestroy()
	{
		if (lastRoom != null)
		{
			lastRoom.creatures.Remove(this);
		}
	}

	public static int GetInRoom(Room room)
	{
		return room.creatures.Count;
	}

	public static int GetInRoom(Point pos)
	{
		Room room = Map.Get().At(pos).Room;
		if (room != null)
		{
			return GetInRoom(room);
		}
		return 0;
	}

	public static int GetInRoom(Room room, CreatureType ctype)
	{
		int num = 0;
		for (int i = 0; i < room.creatures.Count; i++)
		{
			if (room.creatures[i].creatureType == ctype)
			{
				num++;
			}
		}
		return num;
	}

	public static int GetInRoom(Point pos, CreatureType ctype)
	{
		Room room = Map.Get().At(pos).Room;
		if (room != null)
		{
			return GetInRoom(room, ctype);
		}
		return 0;
	}
}
public class CreatureVisibility : MonoBehaviour
{
	public bool autoHide;

	public bool showOnPlayerRoom;

	public bool showOnAdjacent;

	public List<Component> disableComponentsOnHidden;

	public List<GameObject> disableObjsOnHidden;

	private bool isHidden;

	public bool Hidden
	{
		get
		{
			return isHidden;
		}
		set
		{
			SetHidden(value);
		}
	}

	private void Update()
	{
		if (autoHide)
		{
			bool flag = !CheckVisibilize();
			if (isHidden != flag)
			{
				SetHidden(flag);
			}
		}
	}

	public void SetHidden(bool hidden)
	{
		isHidden = hidden;
		foreach (MonoBehaviour item in disableComponentsOnHidden)
		{
			item.enabled = !hidden;
		}
		foreach (GameObject item2 in disableObjsOnHidden)
		{
			item2.SetActive(!hidden);
		}
		GetComponent<Collider>().enabled = !hidden;
	}

	public bool CheckVisibilize()
	{
		Point curCell = Map.Get().WorldToCell(base.transform.position);
		return CheckVisibilize(curCell);
	}

	public bool CheckVisibilize(Point curCell)
	{
		if (!showOnAdjacent && MapChunk.At(curCell).Visible)
		{
			return true;
		}
		if (showOnAdjacent && MapChunk.CheckCellNextToVisible(curCell))
		{
			return true;
		}
		if (showOnPlayerRoom)
		{
			Room room = Map.Get().At(curCell).Room;
			if (room != null && room.PlayerInside)
			{
				return true;
			}
			if (showOnAdjacent)
			{
				for (int i = curCell.Y - 1; i <= curCell.Y + 1; i += 2)
				{
					Room room2 = Map.Get().At(curCell.X, i).Room;
					if (room2 != null && room2.PlayerInside)
					{
						return true;
					}
				}
				for (int j = curCell.X - 1; j <= curCell.X + 1; j += 2)
				{
					Room room3 = Map.Get().At(j, curCell.Y).Room;
					if (room3 != null && room3.PlayerInside)
					{
						return true;
					}
				}
			}
		}
		return false;
	}
}
public class Eyes : FSMComponent<Eyes.States>
{
	public enum States
	{
		Closed,
		LookAhead,
		LookAtPlayer
	}

	public Transform leftEye;

	public Transform rightEye;

	public Transform[] linkedObjs;

	public float closeSpeed = 2f;

	public float openSpeed = 2f;

	public float lookPlayerSpeed = 2f;

	public bool invertedStart;

	public float lookHeightOffset;

	private Quaternion lookAhead;

	private Quaternion lookBehind;

	private Transform playerTarget;

	public void SetClosed()
	{
		base.State = States.Closed;
	}

	public void SetLookAhead()
	{
		base.State = States.LookAhead;
	}

	public void SetLookAtPlayer()
	{
		base.State = States.LookAtPlayer;
	}

	private void Start()
	{
		lookAhead = leftEye.localRotation;
		lookBehind = Quaternion.Inverse(lookAhead);
		if (invertedStart)
		{
			lookBehind = lookAhead * Quaternion.AngleAxis(181f, new Vector3(0f, 0f, 1f));
		}
		playerTarget = Player.GetLook();
		Init(States.Closed);
	}

	private void Closed_Update()
	{
		SetBothRotations(lookBehind, closeSpeed);
	}

	private void LookAhead_Update()
	{
		SetBothRotations(lookAhead, openSpeed);
	}

	private void LookAtPlayer_Update()
	{
		Vector3 target = playerTarget.position + Vector3.up * lookHeightOffset;
		RotateEyeTowards(leftEye, target, lookPlayerSpeed);
		RotateEyeTowards(rightEye, target, lookPlayerSpeed);
		RotateLinkedTowards(target, lookPlayerSpeed);
	}

	private void SetBothRotations(Quaternion targetRot, float speed)
	{
		leftEye.localRotation = Interpolate.Slerp(leftEye.localRotation, targetRot, Time.deltaTime * speed);
		rightEye.localRotation = Interpolate.Slerp(rightEye.localRotation, targetRot, Time.deltaTime * speed);
		for (int i = 0; i < linkedObjs.Length; i++)
		{
			linkedObjs[i].localRotation = Interpolate.Slerp(linkedObjs[i].localRotation, targetRot, Time.deltaTime * speed);
		}
	}

	private void RotateEyeTowards(Transform eye, Vector3 target, float speed)
	{
		Vector3 forward = target - eye.position;
		forward.Normalize();
		Quaternion to = Quaternion.LookRotation(forward, -Vector3.up) * Quaternion.AngleAxis(90f, Vector3.up);
		eye.rotation = Interpolate.Slerp(eye.rotation, to, Time.deltaTime * speed);
	}

	private void RotateLinkedTowards(Vector3 target, float speed)
	{
		for (int i = 0; i < linkedObjs.Length; i++)
		{
			Vector3 forward = target - linkedObjs[i].position;
			forward.Normalize();
			Quaternion to = Quaternion.LookRotation(forward, -Vector3.up) * Quaternion.AngleAxis(90f, Vector3.up);
			linkedObjs[i].rotation = Interpolate.Slerp(linkedObjs[i].rotation, to, Time.deltaTime * speed);
		}
	}
}
public class Floater : FSMComponent<Floater.States>
{
	public enum States
	{
		StalkRoom,
		Patrol,
		AngryLook,
		Attack,
		WaitWell,
		RaiseWell
	}

	public float floatHeight = 1.9f;

	public float patrolSpeed = 1f;

	public float patrolTurnSpeed = 1f;

	private float patrolProgress;

	private Vector3 patrolOrigin;

	private float patrolProgressRot;

	private Quaternion patrolOriginRot;

	public Room room;

	private CreatureVisibility cVisibility;

	private PathWalker pathWalker;

	private Eyes eyes;

	private Jaw jaw;

	private CapsuleCollider capCollider;

	private RandomSounds randomSounds;

	private SoundLoop screechSound;

	public AudioSource attackSound;

	private GameObject player;

	private Transform playerLook;

	private VisibilityProbe probe;

	private float timer;

	private float cooldownTimer;

	private bool waiting;

	private Vector3 targetPos;

	private float detectedMotion;

	private Vector3 lastPlayerPos;

	private Quaternion lastPlayerRot;

	private Vector3 lastLeftHandPos;

	private Vector3 lastRightHandPos;

	private Quaternion lastLeftHandRot;

	private Quaternion lastRightHandRot;

	private float playerEvadedCooldown;

	private bool firstTimeSeen = true;

	public Light spotLight;

	private List<int> listOrder = new List<int>();

	private int detectMotionFrame;

	private void Start()
	{
		player = Player.Get();
		playerLook = Player.GetLook();
		pathWalker = GetComponent<PathWalker>();
		pathWalker.canFloat = true;
		cVisibility = GetComponent<CreatureVisibility>();
		eyes = GetComponent<Eyes>();
		jaw = GetComponent<Jaw>();
		capCollider = GetComponent<CapsuleCollider>();
		randomSounds = GetComponent<RandomSounds>();
		screechSound = GetComponent<SoundLoop>();
		screechSound.targetVolume = 0f;
		firstTimeSeen = true;
		if (room != null)
		{
			Init(States.StalkRoom);
		}
		else
		{
			Init(States.WaitWell);
		}
	}

	private void StalkRoom_Enter()
	{
		randomSounds.Playing = false;
		int num = 0;
		while (num++ < 30)
		{
			Point randomPoint = room.GetRandomPoint(central: true);
			if (Map.Get().At(randomPoint).IsVisible() || Map.Get().At(randomPoint).Occupied)
			{
				continue;
			}
			if (Map.Get().Tags.GetStyle(Map.Get().mapStyles, randomPoint).arched)
			{
				Cell cell = Map.Get().At(randomPoint);
				bool flag = cell.CheckAdjacency(AdjacencyCode.LeftCenter) && cell.CheckAdjacency(AdjacencyCode.RightCenter);
				flag |= cell.CheckAdjacency(AdjacencyCode.CenterTop) && cell.CheckAdjacency(AdjacencyCode.CenterBottom);
				flag |= cell.CheckAdjacency(AdjacencyCode.LeftCenter) && cell.CheckAdjacency(AdjacencyCode.CenterTop) && cell.CheckAdjacency(AdjacencyCode.RightBottom);
				flag |= cell.CheckAdjacency(AdjacencyCode.CenterTop) && cell.CheckAdjacency(AdjacencyCode.RightCenter) && cell.CheckAdjacency(AdjacencyCode.LeftBottom);
				flag |= cell.CheckAdjacency(AdjacencyCode.LeftTop) && cell.CheckAdjacency(AdjacencyCode.RightCenter) && cell.CheckAdjacency(AdjacencyCode.CenterBottom);
				if (flag | (cell.CheckAdjacency(AdjacencyCode.LeftCenter) && cell.CheckAdjacency(AdjacencyCode.RightTop) && cell.CheckAdjacency(AdjacencyCode.CenterBottom)))
				{
					continue;
				}
			}
			base.transform.position = Map.Get().CellToWorld(randomPoint) + Vector3.up * floatHeight;
			base.transform.rotation = Quaternion.AngleAxis(UnityEngine.Random.Range(0, 360), Vector3.up);
			probe = Map.Get().At(randomPoint).Probe;
			eyes.SetClosed();
			jaw.targetOpenPos = 0f;
			timer = 0f;
			waiting = false;
			room.HasLocalEnemy = true;
			return;
		}
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private void StalkRoom_Update()
	{
		if (waiting)
		{
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				base.State = States.Patrol;
				if (IsPlayerVisible())
				{
					SpookSounds.Get().PlayScare();
				}
			}
		}
		else if (room.PlayerInside && probe.IsVisible)
		{
			waiting = true;
			timer = ((!firstTimeSeen) ? UnityEngine.Random.Range(2f, 4.5f) : UnityEngine.Random.Range(3f, 9f));
			randomSounds.Playing = true;
			firstTimeSeen = false;
		}
		base.transform.position = new Vector3(base.transform.position.x, floatHeight + GetFloatBobbing(), base.transform.position.z);
	}

	private IEnumerator ShowTutorial_co(string textCode)
	{
		yield return new WaitForSeconds(3f);
		if (Config.General().tutorials)
		{
			Tutorial.Get().ShowTextForTime(Translate.Get(textCode), 5f);
		}
	}

	private void Patrol_Enter()
	{
		eyes.SetLookAhead();
		jaw.targetOpenPos = 0f;
		probe = null;
		waiting = true;
		timer = UnityEngine.Random.Range(1f, 4f);
		cooldownTimer = 6f;
		DetectMotion(forceUpdate: true);
		detectedMotion = 0f;
		randomSounds.Playing = true;
		if (!Tutorial.HasBeenShownBefore("TUTO_FLOATER", add: true) && (room.PlayerInside || Map.Get().At(base.transform.position).IsVisible()))
		{
			StartCoroutine(ShowTutorial_co("TUTO_FLOATER"));
		}
	}

	private void Patrol_Update()
	{
		bool flag = IsPlayerVisible();
		if (flag)
		{
			eyes.SetLookAtPlayer();
			if (playerEvadedCooldown > 0f)
			{
				playerEvadedCooldown -= Time.deltaTime;
			}
		}
		else
		{
			eyes.SetLookAhead();
			Room room = Map.Get().At(Player.GetPos()).Room;
			if (room != this.room)
			{
				playerEvadedCooldown = 4f;
			}
		}
		if (this.room.PlayerInside || Map.Get().At(base.transform.position).IsVisible())
		{
			Jukebox.Get().SetTension();
			FearEffect.Get().Scare();
			cooldownTimer = 6f;
		}
		else
		{
			cooldownTimer -= Time.deltaTime;
			if (cooldownTimer <= 0f)
			{
				base.State = States.StalkRoom;
				return;
			}
		}
		if (waiting)
		{
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				waiting = false;
				targetPos = GetPatrolTarget();
				patrolProgress = 0f;
				patrolProgressRot = 0f;
				patrolOrigin = base.transform.position;
				patrolOriginRot = base.transform.rotation;
				if ((targetPos - base.transform.position).sqrMagnitude <= 0.09f)
				{
					waiting = true;
					timer = 1f;
				}
			}
		}
		else if (patrolProgressRot < 1f)
		{
			patrolProgressRot = LookAtSmooth(patrolOriginRot, targetPos, patrolProgressRot, patrolTurnSpeed);
		}
		else
		{
			patrolProgress = MoveSmooth(targetPos, patrolOrigin, patrolProgress, patrolSpeed);
			if (patrolProgress >= 1f)
			{
				waiting = true;
				timer = UnityEngine.Random.Range(2f, 5f);
			}
		}
		base.transform.position = new Vector3(base.transform.position.x, floatHeight + GetFloatBobbing(), base.transform.position.z);
		float num = DetectMotion();
		if (num >= 0.5f && flag)
		{
			base.State = States.AngryLook;
		}
		else if (!flag)
		{
			detectedMotion = 0f;
		}
	}

	private void AngryLook_Enter()
	{
		waiting = true;
		if (detectedMotion >= 1f)
		{
			timer = UnityEngine.Random.Range(1f, 3f);
		}
		else
		{
			timer = UnityEngine.Random.Range(1f, 6f);
		}
		screechSound.targetVolume = 0f;
	}

	private void AngryLook_Update()
	{
		bool flag = IsPlayerVisible();
		if (flag)
		{
			eyes.SetLookAtPlayer();
			if (playerEvadedCooldown > 0f)
			{
				playerEvadedCooldown -= Time.deltaTime;
			}
		}
		else
		{
			eyes.SetLookAhead();
		}
		Jukebox.Get().SetTension();
		FearEffect.Get().Scare();
		screechSound.targetVolume = 1f;
		pathWalker.LookAt(playerLook.position, patrolTurnSpeed * 6f);
		if (detectedMotion < 1f)
		{
			jaw.targetOpenPos = 0.3f;
			DetectMotion();
			if (detectedMotion >= 1f && flag && playerEvadedCooldown <= 0f)
			{
				base.State = States.Attack;
			}
		}
		else
		{
			jaw.targetOpenPos = 1f;
		}
		base.transform.position = new Vector3(base.transform.position.x, floatHeight + GetFloatBobbing(), base.transform.position.z);
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			screechSound.targetVolume = 0f;
			if (detectedMotion >= 1f && playerEvadedCooldown <= 0f)
			{
				base.State = States.Attack;
				return;
			}
			detectedMotion = 0f;
			base.State = States.Patrol;
		}
	}

	private void Attack_Enter()
	{
		SpookSounds.Get().PlayScare(intense: true);
		attackSound.Play();
		pathWalker.Reset();
		pathWalker.ClearPath();
		pathWalker.radiusFactor = 0.4f;
		eyes.SetClosed();
	}

	private void Attack_Update()
	{
		Jukebox.Get().SetTension();
		FearEffect.Get().Scare();
		jaw.targetOpenPos = 1f;
		Vector3 vector = (targetPos = playerLook.position - Vector3.up * (capCollider.height / 2f - 0.25f));
		bool flag = false;
		if (pathWalker.CheckLineOfWalkToPlayer(vector))
		{
			targetPos = vector;
			pathWalker.ClearPath();
			flag = true;
		}
		else
		{
			if (pathWalker.CanSetPath(updateTimeout: true))
			{
				Point closestWalkable = Map.Get().GetClosestWalkable(vector);
				pathWalker.SetPath(closestWalkable, PathWalker.CheckTraversalFloater, PathWalker.GetTraversalCost);
			}
			targetPos = pathWalker.GetNextNode();
			targetPos.y = playerLook.position.y - (capCollider.height / 2f - 0.25f);
		}
		Point originPos = Map.Get().WorldToCell(base.transform.position);
		Vector3 vector2 = (targetPos - base.transform.position).GroundNormalize();
		Point destPos = Map.Get().WorldToCell(base.transform.position + vector2 * 1.5f);
		Door doorBetweenTiles = Map.Get().GetDoorBetweenTiles(originPos, destPos);
		if ((bool)doorBetweenTiles && !doorBetweenTiles.IsOpen)
		{
			doorBetweenTiles.Bash();
			doorBetweenTiles.OpenFast(base.transform);
		}
		Vector3 vector3 = targetPos - base.transform.position;
		vector3.Normalize();
		if (flag)
		{
			targetPos -= vector3 * capCollider.radius * 1.2f;
		}
		if (flag && (targetPos - base.transform.position).sqrMagnitude <= 0.040000003f)
		{
			Player.GetController().ApplyAttack(2f, "GAMEOVER_FLOATER");
		}
		else if ((vector - base.transform.position).sqrMagnitudeGround() <= 0.09f)
		{
			Player.GetController().ApplyAttack(2f, "GAMEOVER_FLOATER");
		}
		else
		{
			if (!flag && (targetPos - base.transform.position).sqrMagnitudeGround() <= 0.0225f)
			{
				pathWalker.AdvanceNode();
			}
			base.transform.position += vector3 * Time.deltaTime * patrolSpeed * 20f;
		}
		pathWalker.LookAt(targetPos, patrolTurnSpeed * 20f);
	}

	private void WaitWell_Enter()
	{
		base.transform.rotation = Quaternion.AngleAxis(UnityEngine.Random.Range(0, 360), Vector3.up);
		room = Map.Get().At(base.transform.position).Room;
		if (room != null)
		{
			room.HasLocalEnemy = true;
		}
		probe = Map.Get().At(base.transform.position).Probe;
		eyes.SetClosed();
		jaw.targetOpenPos = 0f;
		timer = 0f;
		waiting = false;
		randomSounds.Playing = false;
	}

	private void WaitWell_Update()
	{
		if (waiting)
		{
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				if (room.PlayerInside)
				{
					base.State = States.RaiseWell;
				}
				else
				{
					waiting = false;
				}
			}
		}
		else if (room.PlayerInside)
		{
			waiting = true;
			if (room.Template.size == RoomTemplate.SizeType.Small)
			{
				timer = UnityEngine.Random.Range(1f, 3f);
			}
			else if (room.Template.size == RoomTemplate.SizeType.Medium)
			{
				timer = UnityEngine.Random.Range(1f, 7f);
			}
			else
			{
				timer = UnityEngine.Random.Range(1f, 11f);
			}
		}
	}

	private void RaiseWell_Enter()
	{
		patrolOrigin = base.transform.position;
		patrolProgress = 0f;
		targetPos = patrolOrigin;
		targetPos.y = floatHeight;
		randomSounds.Playing = true;
	}

	private void RaiseWell_Update()
	{
		targetPos.y = floatHeight + GetFloatBobbing();
		patrolProgress = MoveSmooth(targetPos, patrolOrigin, patrolProgress, patrolSpeed * 0.7f);
		if (patrolProgress >= 1f)
		{
			base.State = States.Patrol;
			if (IsPlayerVisible())
			{
				SpookSounds.Get().PlayScare();
			}
		}
	}

	private bool IsPlayerVisible()
	{
		return Utils.IsPlayerVisible(base.transform, 85f, checkOnlyAngle: false, (!(playerEvadedCooldown > 0f)) ? 8f : 4f);
	}

	private Vector3 GetPatrolTarget()
	{
		List<Point> listValidPos = room.GetListValidPos();
		listOrder.Clear();
		for (int i = 0; i < listValidPos.Count; i++)
		{
			listOrder.Add(i);
		}
		listOrder.Shuffle();
		Point point = Map.Get().WorldToCell(base.transform.position);
		for (int j = 0; j < listOrder.Count; j++)
		{
			Point point2 = listValidPos[listOrder[j]];
			if (!(point2 == point))
			{
				Vector3 result = Map.Get().CellToWorld(point2) + Vector3.up * floatHeight;
				if (pathWalker.CheckLineOfWalk(base.transform.position - Vector3.up + Vector3.up * capCollider.height / 2f, result, checkNoPlayer: true))
				{
					return result;
				}
			}
		}
		return base.transform.position;
	}

	private float MoveSmooth(Vector3 target, Vector3 origin, float progress, float speed)
	{
		progress += speed * Time.deltaTime;
		if (progress >= 1f)
		{
			progress = 1f;
		}
		base.transform.position = Interpolate.EaseInOut(origin, target, progress);
		return progress;
	}

	private float LookAtSmooth(Quaternion rotOriginal, Vector3 pos, float progress, float turnSpeed)
	{
		progress += turnSpeed * Time.deltaTime;
		if (progress >= 1f)
		{
			progress = 1f;
		}
		Vector3 forward = Vector3Ext.GroundVector(pos, base.transform.position);
		forward.Normalize();
		Quaternion to = Quaternion.LookRotation(forward, Vector3.up);
		base.transform.rotation = Interpolate.Slerp(rotOriginal, to, Interpolate.EaseInOut(progress));
		return progress;
	}

	private float DetectMotion(bool forceUpdate = false)
	{
		if (detectMotionFrame == 0 || forceUpdate)
		{
			float num = 1f;
			float num2 = 1f;
			if (!Map.Get().At(base.transform.position).IsVisible())
			{
				num *= 0.4f;
				num2 *= 0.2f;
			}
			detectedMotion -= Time.deltaTime * 20f * 0.15f;
			Vector3 position = player.transform.position;
			Quaternion rotation = playerLook.rotation;
			detectedMotion += GetObjectMotion(lastPlayerPos, lastPlayerRot, position, rotation, 0.0016f, 4f, num, num2);
			if (InputExt.UsingHandControllers)
			{
				Vector3 localPosition = Player.GetLeftHandTransform().localPosition;
				Quaternion localRotation = Player.GetLeftHandTransform().localRotation;
				Vector3 localPosition2 = Player.GetRightHandTransform().localPosition;
				Quaternion localRotation2 = Player.GetLeftHandTransform().localRotation;
				detectedMotion += GetObjectMotion(lastLeftHandPos, lastLeftHandRot, localPosition, localRotation, 0.0001f, 8f, num * 0.75f, num2 * 0.5f) * 0.5f;
				detectedMotion += GetObjectMotion(lastRightHandPos, lastRightHandRot, localPosition2, localRotation2, 0.0001f, 8f, num * 0.75f, num2 * 0.5f) * 0.5f;
				lastLeftHandPos = localPosition;
				lastLeftHandRot = localRotation;
				lastRightHandPos = localPosition2;
				lastRightHandRot = localRotation2;
			}
			detectedMotion = Mathf.Clamp01(detectedMotion);
			lastPlayerPos = position;
			lastPlayerRot = rotation;
		}
		detectMotionFrame++;
		if (detectMotionFrame >= 20)
		{
			detectMotionFrame = 0;
		}
		return detectedMotion;
	}

	private static float GetObjectMotion(Vector3 lastPos, Quaternion lastRot, Vector3 newPos, Quaternion newRot, float minTranslateSq, float minRotate, float rateMovement, float rateRotation)
	{
		float num = 0f;
		Vector3 vector = newPos - lastPos;
		float num2 = Mathf.Abs(Quaternion.Angle(newRot, lastRot));
		if (vector.sqrMagnitude >= minTranslateSq)
		{
			num += 1.5f * rateMovement * Time.deltaTime * 20f;
		}
		if (num2 >= minRotate)
		{
			num += 0.9f * rateRotation * Time.deltaTime * 20f;
		}
		return num;
	}

	private float GetFloatBobbing()
	{
		return Mathf.Cos(Time.realtimeSinceStartup * 0.5f) * 0.075f;
	}

	public static Floater SpawnInRandomRoom(Floater floaterPrefab)
	{
		int num = 0;
		while (num++ < 50)
		{
			Room room = RandomExt.Choice(Map.Get().Rooms);
			if (!room.Safe && !room.PlayerInside && room.floaters.Count == 0 && room.Template.size != 0)
			{
				Floater floater = UnityEngine.Object.Instantiate(floaterPrefab);
				floater.room = room;
				room.floaters.Add(floater);
				return floater;
			}
		}
		return null;
	}

	public static Floater SpawnInWell(Transform spawnPos, Floater floaterPrefab)
	{
		Floater floater = UnityEngine.Object.Instantiate(floaterPrefab, spawnPos.transform.position, Quaternion.identity);
		Map.Get().At(spawnPos.position).Room.floaters.Add(floater);
		return floater;
	}
}
public class GargoyleBehaviour : MonoBehaviour
{
	public bool Standing;

	public bool Discovered;

	public bool CanMove;

	public Renderer ModelRenderer;

	public VisibilityProbe LocalProbe;

	public PlayerGameController player;

	public AnimationClip[] standingPoses;

	public AnimationClip[] crouchingPoses;

	public AnimationClip[] walkingPoses;

	public AnimationClip[] attackPoses;

	private Vector3 LastPosition;

	private bool PlayScare;

	private bool DecidedScare;

	private bool IncreaseMoves;

	private int NumMoves;

	private float ChangePositionTimer;

	private Vector3 InitPosition;

	private Quaternion InitRotation;

	private Transform InitParent;

	public Transform HeadModel;

	public float TurnHeadTime = 6f;

	private float TurnTime;

	private Quaternion LastRotation;

	private bool CanTurn;

	private bool TurnedHead;

	private Pathfinder pathfinder;

	private List<Vector3> path;

	private LayerMask sightMask;

	private bool updateLookAt = true;

	private bool firstAttack = true;

	private void Start()
	{
		Standing = true;
		Discovered = false;
		CanMove = false;
		LocalProbe = Map.Get().At(base.transform.position).Probe;
		player = Player.GetController();
		ModelRenderer = GetComponentInChildren<Renderer>();
		LastPosition = base.transform.position;
		InitParent = base.transform.parent;
		InitPosition = base.transform.position;
		InitRotation = base.transform.rotation;
		TurnTime = TurnHeadTime;
		CanTurn = false;
		TurnedHead = false;
		PlayScare = false;
		DecidedScare = false;
		NumMoves = 0;
		pathfinder = Pathfinder.Get();
		path = new List<Vector3>();
		sightMask = LayerMaskExtensions.NamesToMask("StaticGeometry", "Prop");
		AnimationClip[] arrItems = standingPoses;
		if (CheckLowCeiling())
		{
			arrItems = crouchingPoses;
		}
		string animation = RandomExt.Choice(arrItems).name;
		GetComponent<Animation>().Play(animation);
		GetComponent<Animation>().Sample();
		GetComponent<Animation>().Stop();
		Room room = Map.Get().At(base.transform.position).Room;
		if (room != null && room.Safe)
		{
			base.enabled = false;
		}
	}

	private void Update()
	{
		float sqrMagnitude = (Player.GetPos() - base.transform.position).sqrMagnitude;
		if (!Discovered)
		{
			if (LocalProbe.IsVisible && sqrMagnitude <= 36f)
			{
				if (!Discovered && UnityEngine.Random.value < 0.3f)
				{
					Jukebox.Get().PlaySilence();
				}
				Discovered = true;
				CanMove = true;
			}
			return;
		}
		if (!ModelRenderer.isVisible)
		{
			if (sqrMagnitude >= 225f)
			{
				ResetToInit();
				return;
			}
			if (CanMove && ChangePosition())
			{
				if (!DecidedScare)
				{
					if (Standing)
					{
						PlayScare = true;
					}
					else
					{
						PlayScare = UnityEngine.Random.value < 0.6f;
					}
					float value = UnityEngine.Random.value;
					if (((NumMoves == 0 && value < 0.3f) || (NumMoves == 1 && value < 0.7f) || (NumMoves == 2 && value < 0.8f) || NumMoves >= 3 || !firstAttack) && (Player.GetPos() - base.transform.position).sqrMagnitude <= 5.76f)
					{
						StartCoroutine(TryAttack());
					}
				}
				DecidedScare = true;
				Standing = false;
				IncreaseMoves = true;
			}
			if (!Standing && updateLookAt)
			{
				base.transform.LookAt(new Vector3(Player.GetPos().x, 0f, Player.GetPos().z));
			}
			TurnTime = TurnHeadTime;
			CanTurn = UnityEngine.Random.value < 0.6f;
			TurnedHead = false;
			return;
		}
		CanMove = true;
		LastPosition = base.transform.position;
		ChangePositionTimer = 0f;
		if (LocalProbe.IsVisible && Utils.CheckBoundsInFrustrum(GetComponent<Collider>().bounds))
		{
			if (PlayScare)
			{
				player.GetComponent<SpookSounds>().PlayScare();
			}
			PlayScare = false;
			DecidedScare = false;
			if (IncreaseMoves)
			{
				NumMoves++;
			}
			IncreaseMoves = false;
		}
	}

	private void LateUpdate()
	{
		if (Discovered && ModelRenderer.isVisible && (CanTurn || TurnedHead))
		{
			if (CanTurn)
			{
				Transform transform = GameObject.FindWithTag(Tags.MainCamera).transform;
				Vector3 vector = LastRotation * new Vector3(-1f, 0f, 0f);
				vector.y = 0f;
				Vector3 dir = transform.transform.position - HeadModel.position;
				float sqrMagnitude = dir.sqrMagnitude;
				dir.y = 0f;
				float num = Vector3.Dot(vector, dir.normalized);
				Debug.DrawRay(HeadModel.position, vector, Color.red);
				Debug.DrawRay(HeadModel.position, dir, Color.yellow);
				if (sqrMagnitude <= 6.25f && num >= 0.2f)
				{
					TurnTime -= Time.deltaTime;
					if (TurnTime <= 0f)
					{
						Vector3 fromDirection = transform.position - HeadModel.position;
						fromDirection.y = 0f;
						fromDirection.Normalize();
						vector.y = 0f;
						vector.Normalize();
						Quaternion b = HeadModel.rotation * Quaternion.FromToRotation(fromDirection, vector);
						HeadModel.rotation = Quaternion.Slerp(LastRotation, b, Time.deltaTime * 50.1f);
						TurnedHead = true;
						if (num >= 0.85f)
						{
							CanTurn = false;
						}
					}
				}
			}
			else
			{
				HeadModel.rotation = LastRotation;
			}
		}
		LastRotation = HeadModel.rotation;
	}

	private bool ChangePosition()
	{
		if (ChangePositionTimer > 0f)
		{
			ChangePositionTimer -= Time.deltaTime;
			return false;
		}
		ChangePositionTimer = 0.2f;
		base.transform.parent = null;
		float min = 0.3f;
		float max = 0.6f;
		Room room = Map.Get().At(LastPosition).Room;
		Vector3 vector = Player.GetPos() - LastPosition;
		vector.y = 0f;
		if (vector.sqrMagnitude >= 100f)
		{
			CanMove = false;
		}
		else if (vector.sqrMagnitude < 4f)
		{
			if (Standing)
			{
				return false;
			}
			return true;
		}
		bool flag = false;
		Point point = default(Point);
		bool flag2 = CheckCanSeePlayer();
		Vector3 vector2 = Player.GetPos();
		if (flag2)
		{
			if (Standing || UnityEngine.Random.value <= 0.2f)
			{
				min = 0.1f;
				max = 0.3f;
			}
			else if (NumMoves >= 1 && (NumMoves < 3 || UnityEngine.Random.value <= 0.5f))
			{
				min = 0.4f;
				max = 0.8f;
			}
			else if (NumMoves >= 3)
			{
				min = 0.8f;
				max = 0.9f;
			}
			Debug.DrawLine(LastPosition, LastPosition + Vector3.up * 2f, Color.blue, 5f);
			for (int i = 0; i < 10; i++)
			{
				if (flag)
				{
					break;
				}
				float num = UnityEngine.Random.Range(min, max);
				Vector3 vector3 = vector * num;
				Vector3 vector4 = LastPosition + vector3;
				Vector2 vector5 = UnityEngine.Random.insideUnitCircle * UnityEngine.Random.Range(0f, 1f);
				Vector3 vWorldPos = vector4 + new Vector3(vector5.x, 0f, vector5.y);
				Point point2 = Map.Get().WorldToCell(vWorldPos);
				if (CheckCellIsValidToMove(point2, room))
				{
					flag = true;
					point = point2;
					updateLookAt = true;
				}
			}
		}
		else
		{
			if (Standing || UnityEngine.Random.value <= 0.3f)
			{
				min = 0.1f;
				max = 0.5f;
			}
			else if (NumMoves >= 1)
			{
				min = 0.5f;
				max = 0.8f;
			}
			path.Clear();
			Pathfinder.Query query = pathfinder.AddQuery(Map.Get().WorldToCell(LastPosition), Map.Get().WorldToCell(Player.GetPos()), null, PathWalker.CheckTraversal, PathWalker.GetTraversalCost, null, 0.5f);
			if (pathfinder.RunAStar(query))
			{
				if (query.State == Pathfinder.Query.EState.Success)
				{
					foreach (Point item in query.Path)
					{
						path.Add(Map.Get().CellToWorld(item.X, item.Y));
					}
				}
				pathfinder.FreeQuery(query);
			}
			for (int j = 1; j < path.Count; j++)
			{
				DebugExt.DrawPoint(path[j], Color.green, 0.7f, 5f);
				Debug.DrawLine(path[j - 1], path[j], Color.green, 5f);
			}
			if (path.Count > 1)
			{
				for (int k = 0; k < 10; k++)
				{
					if (flag)
					{
						break;
					}
					int value = (int)((float)path.Count * 100f * UnityEngine.Random.Range(min, max)) / 100;
					value = Mathf.Clamp(value, 0, path.Count - 1);
					Vector3 vector6 = path[value];
					Debug.DrawLine(vector6, vector6 + Vector3.up, Color.yellow, 5f);
					Point point3 = Map.Get().WorldToCell(vector6);
					if (CheckCellIsValidToMove(point3, room))
					{
						flag = true;
						point = point3;
						updateLookAt = false;
						if (value < path.Count - 1)
						{
							vector2 = path[value + 1];
						}
					}
				}
			}
		}
		if (flag)
		{
			Cell cell = Map.Get().At(base.transform.position);
			Cell cell2 = Map.Get().At(InitPosition);
			if (cell.Occupied && cell != cell2)
			{
				cell.Occupied = false;
			}
			Cell cell3 = Map.Get().At(point);
			Vector3 zero = Vector3.zero;
			if (cell3.CheckAdjacency(AdjacencyCode.LeftCenter))
			{
				zero += new Vector3(0.25f, 0f, 0f);
			}
			if (cell3.CheckAdjacency(AdjacencyCode.RightCenter))
			{
				zero += new Vector3(-0.25f, 0f, 0f);
			}
			if (cell3.CheckAdjacency(AdjacencyCode.CenterTop))
			{
				zero += new Vector3(0f, 0f, -0.25f);
			}
			if (cell3.CheckAdjacency(AdjacencyCode.CenterBottom))
			{
				zero += new Vector3(0f, 0f, 0.25f);
			}
			Vector3 position = Map.Get().CellToWorld(point) + zero;
			position.y = Map.Get().FloorHeight(position);
			base.transform.position = position;
			base.transform.LookAt(new Vector3(vector2.x, 0f, vector2.z));
			cell3.Occupied = true;
			LocalProbe = cell3.Probe;
			GetComponent<Animation>().Play(RandomExt.Choice(walkingPoses).name);
			GetComponent<Animation>().Sample();
			GetComponent<Animation>().Stop();
			return true;
		}
		return false;
	}

	private bool CheckCanSeePlayer()
	{
		if (MapLoS.LineOfWalk(LastPosition, Player.GetPos(), canTraverseCorners: true))
		{
			Vector3 direction = Player.GetPos() - LastPosition;
			direction.y = 0f;
			float magnitude = direction.magnitude;
			direction /= magnitude;
			if (!Physics.SphereCast(LastPosition + Vector3.up, 0.4f, direction, out var _, magnitude, sightMask))
			{
				return true;
			}
		}
		return false;
	}

	private bool CheckCellIsValidToMove(Point cellPos, Room curRoom)
	{
		Cell cell = Map.Get().At(cellPos);
		if (cell.Occupied || cell.Room != curRoom || !cell.Probe || cell.Probe.IsVisible || player.IsInExitPath(cellPos) || Map.Get().IsReservedDoor(cellPos))
		{
			return false;
		}
		if (Map.Get().At(cellPos.X - 1, cellPos.Y).IsDoor || Map.Get().At(cellPos.X, cellPos.Y).IsDoor || Map.Get().At(cellPos.X, cellPos.Y - 1).IsDoor || Map.Get().At(cellPos.X, cellPos.Y + 1).IsDoor)
		{
			return false;
		}
		Point pos = new Point(cellPos.X - 1, cellPos.Y + 1);
		Point pos2 = new Point(cellPos.X + 1, cellPos.Y + 1);
		Point pos3 = new Point(cellPos.X - 1, cellPos.Y - 1);
		Point pos4 = new Point(cellPos.X + 1, cellPos.Y - 1);
		if (Map.Get().At(pos).Door != null)
		{
			return false;
		}
		if (Map.Get().At(pos2).Door != null)
		{
			return false;
		}
		if (Map.Get().At(pos3).Door != null)
		{
			return false;
		}
		if (Map.Get().At(pos4).Door != null)
		{
			return false;
		}
		return true;
	}

	private IEnumerator TryAttack()
	{
		yield return new WaitForSeconds(UnityEngine.Random.Range(0.25f, 0.75f));
		if ((!ModelRenderer.isVisible || !LocalProbe.IsVisible) && CanMove)
		{
			Cell cell = Map.Get().At(Player.GetPos());
			Cell cell2 = Map.Get().At(base.transform.position);
			if (cell.Room == cell2.Room && (Player.GetPos() - base.transform.position).sqrMagnitude <= 5.76f)
			{
				float value = UnityEngine.Random.value;
				bool flag = !firstAttack || (NumMoves == 1 && value < 0.35f) || (NumMoves == 2 && value < 0.7f) || (NumMoves > 2 && value < 0.9f);
				player.GetComponent<PlayerGameController>().ApplyAttack((!flag) ? 0.9f : 2f, "GAMEOVER_GARGOYLE");
				GetComponent<Animation>().Play(RandomExt.Choice(attackPoses).name);
				GetComponent<Animation>().Sample();
				GetComponent<Animation>().Stop();
				firstAttack = false;
			}
		}
	}

	private void ResetToInit()
	{
		Cell cell = Map.Get().At(base.transform.position);
		Cell cell2 = Map.Get().At(InitPosition);
		if (cell.Occupied && cell != cell2)
		{
			cell.Occupied = false;
		}
		if ((bool)InitParent)
		{
			base.transform.parent = InitParent;
		}
		base.transform.position = InitPosition;
		base.transform.rotation = InitRotation;
		LastPosition = base.transform.position;
		Standing = true;
		Discovered = false;
		CanMove = false;
		LocalProbe = Map.Get().At(base.transform.position).Probe;
		CanTurn = false;
		TurnedHead = false;
		PlayScare = false;
		DecidedScare = false;
		NumMoves = 0;
		firstAttack = true;
		AnimationClip[] arrItems = standingPoses;
		if (CheckLowCeiling())
		{
			arrItems = crouchingPoses;
		}
		GetComponent<Animation>().Play(RandomExt.Choice(arrItems).name);
		GetComponent<Animation>().Sample();
		GetComponent<Animation>().Stop();
	}

	private bool CheckLowCeiling()
	{
		MapStyle style = Map.Get().Tags.GetStyle(Map.Get().mapStyles, Map.Get().WorldToCell(base.transform.position));
		if (style.ceilingHeight <= 3.4f || Map.Get().At(base.transform.position).GetNumAdjacentWallsNoCorners() >= 3)
		{
			return true;
		}
		if (style.arched)
		{
			Cell cell = Map.Get().At(base.transform.position);
			if ((cell.CheckAdjacency(AdjacencyCode.LeftCenter) && cell.CheckAdjacency(AdjacencyCode.RightCenter)) || (cell.CheckAdjacency(AdjacencyCode.CenterTop) && cell.CheckAdjacency(AdjacencyCode.CenterBottom)))
			{
				return true;
			}
		}
		return false;
	}
}
public class Ghost : MonoBehaviour
{
	private enum EState
	{
		Hidden,
		Discovered,
		StareDown,
		Crying,
		Scream,
		Chase,
		ChaseStretchIn,
		ChaseStretchOut,
		Attack,
		VisionDisappear,
		VisionScare,
		Vanish,
		Appear
	}

	public AudioClip[] SpawnSounds;

	public AudioClip ScreamSound;

	public AudioClip VisionScareSound;

	public AudioClip[] distortSounds;

	public GameObject disappearEffect;

	public RandomSounds AngrySounds;

	public RandomSounds DiscoveredSounds;

	public float ChaseSpeed = 1.5f;

	public float ChaseTurnSpeed = 3f;

	public float ChaseTimeout = 20f;

	public bool isVision;

	public bool isAngryAppear;

	public bool canStretch;

	private bool isCrying;

	private bool isTutorial;

	public Transform vanishPoint;

	public Renderer bodyRenderer;

	public Renderer headRenderer;

	public ShadowCloud shadowCloudPrefab;

	private GhostSpawner GhostSpawner;

	private VisibilityProbe LocalProbe;

	private GameObject player;

	private SpookSounds SpookSounds;

	private Animation meshAnimation;

	private Material bodyVanishMat;

	private Material headVanishMat;

	private CapsuleCollider collider;

	private float colliderRadius;

	private EState State;

	private float TimeOut;

	private float DiscoveredAwareness;

	private float MinDiscovered;

	private bool WasLooking;

	private PathWalker pathWalker;

	private bool rotatingAnim;

	private Vector3 stretchOrigin;

	private Vector3 stretchDest;

	private float stretchFactor;

	private const float stretchInSpeed = 4.7f;

	private const float stretchOutSpeed = 1.6f;

	private bool visionScare;

	private AudioSource visionScream;

	private const float vanishTimeout = 0.3f;

	private void Awake()
	{
		canStretch = GameController.Get().levelOptions.ghostCanStretch && UnityEngine.Random.value <= 0.5f;
	}

	private void Start()
	{
		base.transform.position = new Vector3(base.transform.position.x, Map.Get().FloorHeight(base.transform.position), base.transform.position.z);
		meshAnimation = base.transform.GetComponentInChildren<Animation>();
		LocalProbe = Map.Get().At(base.transform.position).Probe;
		player = Player.Get();
		SpookSounds = player.GetComponent<SpookSounds>();
		GhostSpawner = GameController.Get().GetComponent<GhostSpawner>();
		pathWalker = GetComponent<PathWalker>();
		pathWalker.doorForceChance = 0.25f;
		pathWalker.onBlockedByDoor = OnBlockedByDoor;
		pathWalker.applyFloorNoise = true;
		collider = GetComponent<CapsuleCollider>();
		colliderRadius = collider.radius;
		collider.radius = 1.25f * colliderRadius;
		if (!isAngryAppear)
		{
			InitHidden();
		}
		else
		{
			InitAppear();
		}
	}

	private void Update()
	{
		switch (State)
		{
		case EState.Hidden:
			UpdateHidden();
			break;
		case EState.Discovered:
			UpdateDiscovered();
			break;
		case EState.Crying:
			UpdateCrying();
			break;
		case EState.StareDown:
			UpdateStareDown();
			break;
		case EState.Scream:
			UpdateScream();
			break;
		case EState.Chase:
			UpdateChase();
			break;
		case EState.ChaseStretchIn:
			UpdateChaseStretchIn();
			break;
		case EState.ChaseStretchOut:
			UpdateChaseStretchOut();
			break;
		case EState.Attack:
			UpdateAttack();
			break;
		case EState.VisionDisappear:
			UpdateVisionDisappear();
			break;
		case EState.VisionScare:
			UpdateVisionScare();
			break;
		case EState.Vanish:
			UpdateVanish();
			break;
		case EState.Appear:
			UpdateAppear();
			break;
		}
	}

	private void InitHidden()
	{
		State = EState.Hidden;
		TimeOut = 16f;
		AngrySounds.Playing = false;
		DiscoveredSounds.Playing = false;
		MinDiscovered = ((!(UnityEngine.Random.value < 0.3f)) ? 0f : 0.9f);
		if (!Tutorial.HasBeenShownBefore("TUTO_GHOSTGIRL", add: false) && Config.General().tutorials)
		{
			MinDiscovered = 0f;
			isTutorial = true;
		}
		if (UnityEngine.Random.value <= 0.7f)
		{
			AudioSource.PlayClipAtPoint(RandomExt.Choice(SpawnSounds), base.transform.position);
		}
		if (!isTutorial && UnityEngine.Random.value <= 0.35f)
		{
			MinDiscovered = UnityEngine.Random.Range(0.8f, 1.2f);
			meshAnimation.Play("Idle02");
			isCrying = true;
		}
	}

	private void UpdateHidden()
	{
		GetPlayerPos(out var vToPlayer, out var fPlayerDistSq);
		LookAway(vToPlayer, MinDiscovered);
		if (LocalProbe.IsVisible && fPlayerDistSq <= 36f)
		{
			InitDiscovered();
			return;
		}
		TimeOut -= Time.deltaTime;
		if (TimeOut <= 0f)
		{
			GhostSpawner.OnDisappear(this);
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void InitDiscovered()
	{
		State = EState.Discovered;
		GhostSpawner.OnDiscovered();
		TimeOut = UnityEngine.Random.Range(10f, 20f);
		DiscoveredAwareness = MinDiscovered;
		rotatingAnim = false;
		WasLooking = false;
		AngrySounds.Playing = false;
		DiscoveredSounds.Playing = true;
		float value = UnityEngine.Random.value;
		if (value < 0.3f)
		{
			SpookSounds.PlayScare();
		}
		else
		{
			FearEffect.Get().Scare(jumpScare: true);
		}
		if (value < 0.5f)
		{
			Jukebox.Get().PlaySilence();
		}
		GetPlayerPos(out var vToPlayer, out var _);
		LookAway(vToPlayer, DiscoveredAwareness);
		if (!Tutorial.HasBeenShownBefore("TUTO_GHOSTGIRL", add: true))
		{
			StartCoroutine(ShowTutorial_co("TUTO_GHOSTGIRL"));
		}
		if (isCrying)
		{
			State = EState.Crying;
		}
	}

	private void UpdateDiscovered()
	{
		GetPlayerPos(out var vToPlayer, out var fPlayerDistSq);
		LookAway(vToPlayer, DiscoveredAwareness);
		if (!LocalProbe.IsVisible && fPlayerDistSq >= 16f)
		{
			TimeOut -= Time.deltaTime;
			if (TimeOut <= 0f)
			{
				GhostSpawner.OnDisappear(this);
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
		else if (LocalProbe.IsVisible)
		{
			GhostSpawner.OnDiscovered();
		}
		bool flag = (WasLooking = GetIsPlayerLooking(vToPlayer));
		if (flag)
		{
			DiscoveredAwareness += Time.deltaTime * ((!isTutorial) ? 0.35f : 0.15f);
		}
		DiscoveredAwareness = Mathf.Clamp(DiscoveredAwareness, MinDiscovered, 1f);
		if (DiscoveredAwareness >= 0.3f)
		{
			Jukebox.Get().PlaySilence();
		}
		if (!flag && rotatingAnim)
		{
			meshAnimation.CrossFade("Idle01", 0.6f);
			rotatingAnim = false;
		}
		else if (flag && !rotatingAnim)
		{
			Vector3 normalized = vToPlayer.normalized;
			Vector2 vector = -base.transform.forward.GroundNormalize();
			float y = Vector3.Cross(normalized, vector).y;
			if (y < 0f)
			{
				meshAnimation.CrossFade("TurnRightNoRot", 0.3f);
			}
			else
			{
				meshAnimation.CrossFade("TurnLeftNoRot", 0.3f);
			}
			rotatingAnim = true;
		}
		if (DiscoveredAwareness >= 1f)
		{
			if (UnityEngine.Random.value <= 0.4f)
			{
				InitStareDown();
			}
			else
			{
				InitScream();
			}
		}
	}

	private void UpdateCrying()
	{
		GetPlayerPos(out var vToPlayer, out var _);
		if (!LocalProbe.IsVisible)
		{
			TimeOut -= Time.deltaTime;
			if (TimeOut <= 0f)
			{
				GhostSpawner.OnDisappear(this);
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
		else if (LocalProbe.IsVisible)
		{
			GhostSpawner.OnDiscovered();
			if (DiscoveredAwareness >= 0.3f)
			{
				Jukebox.Get().PlaySilence();
				FearEffect.Get().Scare();
				Jukebox.Get().SetScreech(10f);
			}
		}
		if (WasLooking = GetIsPlayerLooking(vToPlayer))
		{
			DiscoveredAwareness += Time.deltaTime * ((!isTutorial) ? 0.2f : 0.15f);
		}
		else
		{
			DiscoveredAwareness -= Time.deltaTime * 0.05f;
		}
		DiscoveredAwareness = Mathf.Clamp(DiscoveredAwareness, MinDiscovered, 1f);
		if (DiscoveredAwareness >= 1f)
		{
			if (isVision || UnityEngine.Random.value <= 0.3f)
			{
				InitVanish();
			}
			else
			{
				InitScream();
			}
		}
	}

	private void InitStareDown()
	{
		State = EState.StareDown;
		meshAnimation.CrossFade("Idle01", 0.6f);
		TimeOut = UnityEngine.Random.Range(4f, 6f);
	}

	private void UpdateStareDown()
	{
		GetPlayerPos(out var vToPlayer, out var _);
		LookAway(vToPlayer, 1f);
		FearEffect.Get().Scare();
		Jukebox.Get().SetScreech(10f);
		TimeOut -= Time.deltaTime;
		if (TimeOut <= 0f)
		{
			if (isVision && UnityEngine.Random.value <= 0.4f)
			{
				InitVanish();
			}
			else
			{
				InitScream();
			}
		}
	}

	private void InitScream()
	{
		State = EState.Scream;
		meshAnimation.CrossFade("Scream", 0.2f);
		TimeOut = meshAnimation.GetComponent<Animation>()["Scream"].length - 0.4f;
		SpookSounds.PlayScare(intense: true);
		if (!isVision)
		{
			Jukebox.Get().SetIntense();
		}
		GhostSpawner.OnDiscovered();
		DiscoveredSounds.Playing = false;
		AudioSource.PlayClipAtPoint(ScreamSound, base.transform.position + Vector3.up);
	}

	private void UpdateScream()
	{
		GetPlayerPos(out var vToPlayer, out var _);
		LookAway(vToPlayer, 1f);
		TimeOut -= Time.deltaTime;
		if (TimeOut <= 0f)
		{
			if (isVision)
			{
				InitVanish();
			}
			else
			{
				InitChase();
			}
		}
	}

	private void InitChase()
	{
		State = EState.Chase;
		meshAnimation.CrossFade("Walk", 0.4f);
		pathWalker.Reset();
		pathWalker.ClearPath();
		AngrySounds.Playing = true;
		DiscoveredSounds.Playing = false;
		TimeOut = 0f;
		collider.radius = colliderRadius;
	}

	private void UpdateChase()
	{
		Jukebox.Get().SetIntense();
		GhostSpawner.OnDiscovered();
		Vector3 vToPlayer;
		float fPlayerDistSq;
		Vector3 playerPos = GetPlayerPos(out vToPlayer, out fPlayerDistSq);
		float num = colliderRadius + player.GetComponent<CharacterController>().radius + 0.3f;
		if (fPlayerDistSq <= num * num)
		{
			InitAttack();
			return;
		}
		if (pathWalker.CheckLineOfWalkToPlayer(playerPos))
		{
			pathWalker.MoveTowards(playerPos, ChaseSpeed, ChaseTurnSpeed);
			pathWalker.ClearPath();
			if (canStretch && fPlayerDistSq >= 4f && UnityEngine.Random.value <= 0.0015f)
			{
				InitChaseStretch();
			}
		}
		else
		{
			if (pathWalker.CanSetPath(updateTimeout: true))
			{
				Point closestWalkable = Map.Get().GetClosestWalkable(playerPos);
				pathWalker.SetPath(closestWalkable, CheckTraversal, GetTraversalCost);
			}
			pathWalker.FollowPath(ChaseSpeed, ChaseTurnSpeed, openDoorForce: true);
		}
		bool flag = false;
		if (Physics.Raycast(base.transform.position + Vector3.up, vToPlayer, out var hitInfo, 10f))
		{
			flag = hitInfo.collider.gameObject == player;
		}
		if (!flag)
		{
			TimeOut += Time.deltaTime;
			if (TimeOut >= ChaseTimeout && !meshAnimation.GetComponentInChildren<SkinnedMeshRenderer>().GetComponent<Renderer>().isVisible)
			{
				GhostSpawner.OnDisappear(this);
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
		else
		{
			TimeOut = 0f;
		}
	}

	private void OnBlockedByDoor(Door door)
	{
		GhostSpawner.OnDisappear(this);
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private void InitChaseStretch()
	{
		Vector3 groundPos = Player.GetGroundPos();
		Vector3 toPosGround = Player.GetToPosGround(base.transform.position);
		Vector3 vector = (toPosGround /= 2f);
		Vector3 normalized = vector.normalized;
		float magnitude = vector.magnitude;
		float num = ((!(UnityEngine.Random.value <= 0.7f)) ? 4f : 2f);
		if (magnitude > num)
		{
			vector = normalized * num;
		}
		stretchOrigin = base.transform.position.ToGround();
		stretchDest = stretchOrigin + vector;
		SetStretchVector(-normalized);
		stretchFactor = 0f;
		if (Map.Get().At(stretchOrigin).IsVisible() || Map.Get().At(stretchDest).IsVisible() || UnityEngine.Random.value <= 0.5f)
		{
			AudioSource.PlayClipAtPoint(RandomExt.Choice(distortSounds), base.transform.position + Vector3.up);
		}
		State = EState.ChaseStretchIn;
	}

	private void UpdateChaseStretchIn()
	{
		stretchFactor = Mathf.Clamp01(stretchFactor + Time.deltaTime * 4.7f);
		float num = Interpolate.EaseOut(stretchFactor);
		Vector3 position = Vector3.Lerp(stretchOrigin, stretchDest, num);
		position.y = Map.Get().FloorHeight(position);
		base.transform.position = position;
		SetStretchFactor((stretchDest - stretchOrigin).magnitude * num);
		SetDistortFactor((0f - num) * 0.15f);
		if (stretchFactor >= 1f)
		{
			State = EState.ChaseStretchOut;
		}
		pathWalker.LookAt(Player.GetPos(), ChaseTurnSpeed * 2f);
	}

	private void UpdateChaseStretchOut()
	{
		stretchFactor = Mathf.Clamp01(stretchFactor - Time.deltaTime * 1.6f);
		float num = Interpolate.EaseOut(stretchFactor);
		SetStretchFactor((stretchDest - stretchOrigin).magnitude * num);
		float num2 = Interpolate.EaseOut(Mathf.Clamp01(stretchFactor * 2f - 1f));
		SetDistortFactor((0f - num2) * 0.15f);
		if (stretchFactor <= 0f)
		{
			State = EState.Chase;
		}
		pathWalker.LookAt(Player.GetPos(), ChaseTurnSpeed);
	}

	private void InitAttack()
	{
		State = EState.Attack;
		meshAnimation.CrossFade("Attack", 0.4f);
		TimeOut = meshAnimation.GetComponent<Animation>()["Attack"].length;
		GhostSpawner.OnDiscovered();
	}

	private void UpdateAttack()
	{
		GetPlayerPos(out var vToPlayer, out var _);
		LookAway(vToPlayer, 1f);
		TimeOut -= Time.deltaTime;
		if (TimeOut <= 0f)
		{
			InitChase();
		}
	}

	private void DoAttack()
	{
		Vector3 vector = Player.GetPos() - base.transform.position;
		vector.y = 0f;
		if (vector.sqrMagnitude <= 4f)
		{
			player.GetComponent<PlayerGameController>().ApplyAttack(1.9f, "GAMEOVER_GHOST");
		}
	}

	private void InitVision()
	{
		State = EState.VisionDisappear;
		GhostSpawner.OnDiscovered();
		TimeOut = UnityEngine.Random.Range(1.5f, 2.5f);
		AngrySounds.Playing = false;
		DiscoveredSounds.Playing = false;
		visionScare = UnityEngine.Random.value <= 0.4f;
		visionScream = null;
		float value = UnityEngine.Random.value;
		if (value < 0.3f)
		{
			SpookSounds.PlayScare();
		}
		else
		{
			FearEffect.Get().Scare(jumpScare: true);
		}
		if (value < 0.5f)
		{
			Jukebox.Get().PlaySilence();
		}
	}

	private void UpdateVisionDisappear()
	{
		GhostSpawner.OnDiscovered();
		GetPlayerPos(out var vToPlayer, out var _);
		LookAway(vToPlayer, 0f);
		TimeOut -= Time.deltaTime;
		if (TimeOut <= 0.1f && !disappearEffect.activeSelf)
		{
			disappearEffect.SetActive(value: true);
			disappearEffect.transform.parent = null;
		}
		if (TimeOut <= 0f)
		{
			if (visionScare)
			{
				InitVisionScare();
			}
			else
			{
				InitVanish();
			}
		}
	}

	private void InitVisionScare()
	{
		State = EState.VisionScare;
		TimeOut = 0.3f;
		meshAnimation.Stop();
		meshAnimation.Play("Scream");
		meshAnimation["Scream"].time = meshAnimation["Scream"].length - 0.4f - 0.2f;
		visionScream = Utils.PlayClipAt(VisionScareSound, base.transform.position);
	}

	private void UpdateVisionScare()
	{
		GhostSpawner.OnDiscovered();
		GetPlayerPos(out var vToPlayer, out var _);
		LookAway(vToPlayer, 1f);
		TimeOut -= Time.deltaTime;
		if (TimeOut <= 0f)
		{
			InitVanish();
		}
	}

	private Vector3 InitVanish()
	{
		State = EState.Vanish;
		TimeOut = 0.3f;
		bodyVanishMat = bodyRenderer.material;
		headVanishMat = headRenderer.material;
		Vector4 vector = vanishPoint.transform.position;
		vector.w = 1f;
		bodyVanishMat.SetVector("_DisappearPoint", vector);
		headVanishMat.SetVector("_DisappearPoint", vector);
		ShadowCloud shadowCloud = UnityEngine.Object.Instantiate(shadowCloudPrefab, vector, Quaternion.identity);
		shadowCloud.initWait = 0.1f;
		if ((bool)visionScream)
		{
			visionScream.transform.parent = shadowCloud.transform;
		}
		return vanishPoint.transform.position;
	}

	private void UpdateVanish()
	{
		TimeOut -= Time.deltaTime;
		float value = Mathf.Clamp01((0.3f - TimeOut) / 0.3f);
		bodyVanishMat.SetFloat("_DisappearFactor", value);
		headVanishMat.SetFloat("_DisappearFactor", value);
		if (TimeOut <= 0f)
		{
			if (!Tutorial.HasBeenShownBefore("TUTO_GHOSTGIRL", add: true) && Config.General().tutorials)
			{
				Tutorial.Get().ShowTextForTime(Translate.Get("TUTO_GHOSTGIRL"), 5f);
			}
			GhostSpawner.OnDisappear(this);
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void InitAppear()
	{
		State = EState.Appear;
		TimeOut = 0.3f;
		AngrySounds.Playing = false;
		DiscoveredSounds.Playing = false;
		MinDiscovered = 0.9f;
		DiscoveredAwareness = 1f;
		bodyVanishMat = bodyRenderer.material;
		headVanishMat = headRenderer.material;
		Vector4 value = vanishPoint.transform.position;
		value.w = 1f;
		bodyVanishMat.SetVector("_DisappearPoint", value);
		headVanishMat.SetVector("_DisappearPoint", value);
		bodyVanishMat.SetFloat("_DisappearFactor", 1f);
		headVanishMat.SetFloat("_DisappearFactor", 1f);
	}

	private void UpdateAppear()
	{
		TimeOut -= Time.deltaTime;
		float value = 1f - Mathf.Clamp01((0.3f - TimeOut) / 0.3f);
		bodyVanishMat.SetFloat("_DisappearFactor", value);
		headVanishMat.SetFloat("_DisappearFactor", value);
		if (TimeOut <= 0f)
		{
			InitScream();
		}
	}

	private void LookAway(Vector3 vToPlayer, float factor)
	{
		vToPlayer.Normalize();
		Quaternion quaternion = Quaternion.LookRotation(-vToPlayer, Vector3.up);
		float angle = 180f * factor;
		Quaternion quaternion2 = Quaternion.AngleAxis(angle, Vector3.up);
		base.transform.rotation = quaternion * quaternion2;
	}

	private Vector3 GetPlayerPos(out Vector3 vToPlayer, out float fPlayerDistSq)
	{
		Vector3 groundPos = Player.GetGroundPos();
		vToPlayer = groundPos - base.transform.position;
		fPlayerDistSq = vToPlayer.sqrMagnitude;
		return groundPos;
	}

	private bool GetIsPlayerLooking(Vector3 vToPlayer)
	{
		bool result = false;
		if (LocalProbe.IsVisible)
		{
			Vector3 forward = GameObject.FindWithTag(Tags.LookDirection).transform.forward;
			forward.GroundNormalize();
			float num = Vector3.Angle(forward, -vToPlayer.normalized);
			if (((!WasLooking && num < 35f) || (WasLooking && num < 45f)) && Utils.IsPlayerVisible(base.transform, float.MaxValue, checkOnlyAngle: false, 20f, 1f))
			{
				result = true;
			}
		}
		return result;
	}

	public static float GetTraversalCost(Point from, Point end, object movementDesc)
	{
		Map map = Map.Get();
		if (from.X < 0 || from.X >= map.Width || from.Y < 0 || from.Y >= map.Height || end.X < 0 || end.X >= map.Width || end.Y < 0 || end.Y >= map.Height)
		{
			return float.MaxValue;
		}
		if (map.At(end).IsBehindDoor != 0 && ((from.X == end.X && from.Y == end.Y + 1 && map.At(end).IsBehindDoor == AdjacencyCode.CenterBottom) || (from.X == end.X && from.Y == end.Y - 1 && map.At(end).IsBehindDoor == AdjacencyCode.CenterTop) || (from.Y == end.Y && from.X == end.X - 1 && map.At(end).IsBehindDoor == AdjacencyCode.LeftCenter) || (from.Y == end.Y && from.X == end.X + 1 && map.At(end).IsBehindDoor == AdjacencyCode.RightCenter)))
		{
			return 8f;
		}
		return 1f;
	}

	public static bool CheckTraversal(Point from, Point end, object movementDesc)
	{
		Map map = Map.Get();
		if (from.X <= 0 || from.X >= map.Width - 1 || from.Y <= 0 || from.Y >= map.Height - 1 || end.X <= 0 || end.X >= map.Width - 1 || end.Y <= 0 || end.Y >= map.Height - 1)
		{
			return false;
		}
		Cell cell = map.At(end.X, end.Y);
		if (!cell.CanWalk() || (cell.Occupied && cell.Room != null && cell.Door == null && !cell.IsDoor))
		{
			return false;
		}
		if (from.X != end.X && from.Y != end.Y)
		{
			return false;
		}
		return true;
	}

	public bool IsHidden()
	{
		return State == EState.Hidden;
	}

	public void OnGhostDiscovered()
	{
		if (IsHidden())
		{
			TimeOut = 0f;
		}
	}

	private IEnumerator ShowTutorial_co(string textCode)
	{
		yield return new WaitForSeconds(0.25f);
		if (Config.General().tutorials)
		{
			Tutorial.Get().ShowTextForTime(Translate.Get(textCode), 5f);
		}
	}

	private void SetStretchVector(Vector3 v)
	{
		Renderer[] array = new Renderer[2] { bodyRenderer, headRenderer };
		for (int i = 0; i < 1; i++)
		{
			Transform rootBone = array[i].GetComponent<SkinnedMeshRenderer>().rootBone;
			v = rootBone.transform.InverseTransformDirection(v);
			Vector4 value = new Vector4(v.x, v.y, v.z, 0f);
			for (int j = 0; j < array[i].materials.Length; j++)
			{
				array[i].materials[j].SetVector("_StretchVector", value);
			}
		}
	}

	private void SetStretchFactor(float f)
	{
		Renderer[] array = new Renderer[2] { bodyRenderer, headRenderer };
		for (int i = 0; i < 1; i++)
		{
			for (int j = 0; j < array[i].materials.Length; j++)
			{
				array[i].materials[j].SetFloat("_StretchFactor", f);
			}
		}
	}

	private void SetDistortFactor(float f)
	{
		Renderer[] array = new Renderer[2] { bodyRenderer, headRenderer };
		for (int i = 0; i < array.Length; i++)
		{
			array[i].material.SetFloat("_DistortFactor", f);
		}
	}
}
public class GhostPointing : FSMComponent<GhostPointing.States>
{
	public enum States
	{
		Hidden,
		Pointing,
		Vanish
	}

	public Animator animator;

	public GameObject disappearEffect;

	public Transform vanishPoint;

	public Renderer[] renderers;

	private List<Material> renderMaterials;

	public ShadowCloud shadowCloudPrefab;

	public Vector3 shadowCloudTarget;

	public Transform tutorialPlace;

	private VisibilityProbe localProbe;

	private float TimeOut;

	private const float vanishTimeout = 0.3f;

	private void Start()
	{
		localProbe = Map.Get().At(base.transform.position).Probe;
		renderMaterials = new List<Material>();
		renderMaterials.Clear();
		for (int i = 0; i < renderers.Length; i++)
		{
			for (int j = 0; j < renderers[i].materials.Length; j++)
			{
				renderMaterials.Add(renderers[i].materials[j]);
			}
		}
		if (GameController.Get().gameState.checkPoint != 0)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		Init(States.Hidden);
	}

	private void Hidden_Enter()
	{
		animator.speed = 0f;
	}

	private void Hidden_Update()
	{
		if (localProbe != null && localProbe.IsVisible)
		{
			base.State = States.Pointing;
		}
	}

	private void Pointing_Enter()
	{
		animator.speed = 1f;
		TimeOut = 9f;
		FearEffect.Get().Scare();
		RandomSounds component = GetComponent<RandomSounds>();
		component.Playing = true;
	}

	private void Pointing_Update()
	{
		Jukebox.Get().SetTension();
		TimeOut -= Time.deltaTime;
		if (TimeOut <= 0f)
		{
			base.State = States.Vanish;
			return;
		}
		float sqrMagnitude = (Player.GetGroundPos() - base.transform.position.ToGround()).sqrMagnitude;
		if (sqrMagnitude <= 9f)
		{
			base.State = States.Vanish;
		}
	}

	private void Vanish_Enter()
	{
		TimeOut = 0.3f;
		Vector4 vector = vanishPoint.transform.position;
		vector.w = 1f;
		for (int i = 0; i < renderMaterials.Count; i++)
		{
			renderMaterials[i].SetVector("_DisappearPoint", vector);
		}
		ShadowCloud shadowCloud = UnityEngine.Object.Instantiate(shadowCloudPrefab, vector, Quaternion.identity);
		shadowCloud.ForceTargetPath(Map.Get().WorldToCell(shadowCloudTarget));
		shadowCloud.initWait = 0.1f;
		RandomSounds component = GetComponent<RandomSounds>();
		component.Playing = false;
	}

	private void Vanish_Update()
	{
		TimeOut -= Time.deltaTime;
		float value = Mathf.Clamp01((0.3f - TimeOut) / 0.3f);
		for (int i = 0; i < renderMaterials.Count; i++)
		{
			renderMaterials[i].SetFloat("_DisappearFactor", value);
		}
		if (TimeOut <= 0f)
		{
			ShowTutorial();
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void ShowTutorial()
	{
		TextLabel textLabel = Tutorial.ShowInPlace("TUTO_META_COLLECTOR", Vector3.zero, Quaternion.identity, tutorialPlace, 1f, facePlayer: true);
		if ((bool)textLabel)
		{
			textLabel.gameObject.AddComponent<DistanceDestroyer>();
		}
	}
}
public class GhostSpawner : MonoBehaviour
{
	public GameObject GhostPrefab;

	public float MinWaitShort = 7f;

	public float MaxWaitShort = 25f;

	public float MinWaitLong = 30f;

	public float MaxWaitLong = 90f;

	public float MinDistance = 3f;

	public float MaxDistance = 9f;

	public bool canSpawn = true;

	private float WaitFactor;

	private bool CoolDown;

	private VisibilityProbe[] Spawns;

	private Ghost CurrentPhantom;

	private bool ghostCreatures = true;

	private bool ghostVisions;

	private void Start()
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag(Tags.GhostSpawn);
		Spawns = new VisibilityProbe[array.Length];
		for (int i = 0; i < array.Length; i++)
		{
			Spawns[i] = array[i].GetComponent<VisibilityProbe>();
		}
		WaitFactor = 1f;
		CoolDown = false;
		LevelOptions levelOptions = GameController.Get().levelOptions;
		ghostCreatures = levelOptions.ghosts;
		ghostVisions = levelOptions.ghostVisions;
		if (ghostCreatures || ghostVisions)
		{
			float num = UnityEngine.Random.Range(levelOptions.ghostsMinDelay, levelOptions.ghostsMaxDelay);
			if (num > 0f)
			{
				StartCoroutine(DelayedEnable_co(num));
			}
			StartCoroutine(TrySpawn());
		}
	}

	public void OnDiscovered()
	{
		WaitFactor = UnityEngine.Random.Range(1.5f, 2.5f);
		if (ghostVisions && !ghostCreatures)
		{
			WaitFactor = UnityEngine.Random.Range(1f, 1.5f);
		}
		CoolDown = true;
		GameObject[] array = GameObject.FindGameObjectsWithTag(Tags.Ghost);
		for (int i = 0; i < array.Length; i++)
		{
			Ghost component = array[i].GetComponent<Ghost>();
			if (component != null)
			{
				component.OnGhostDiscovered();
			}
		}
	}

	public void OnDisappear(Ghost ghost)
	{
		if (ghost == CurrentPhantom)
		{
			CurrentPhantom = null;
		}
	}

	private IEnumerator TrySpawn()
	{
		bool bFirst = true;
		while (true)
		{
			if (!canSpawn)
			{
				yield return new WaitForSeconds(5f);
				continue;
			}
			bool bWaitShort = !bFirst && UnityEngine.Random.value < 0.3f;
			bFirst = false;
			float maxWait = ((!bWaitShort) ? MaxWaitLong : MaxWaitShort);
			float minWait2 = ((!bWaitShort) ? MinWaitLong : MinWaitShort);
			maxWait *= WaitFactor;
			minWait2 *= WaitFactor;
			float nextWait = UnityEngine.Random.Range(minWait2, maxWait);
			yield return new WaitForSeconds(nextWait);
			if (CoolDown)
			{
				CoolDown = false;
				continue;
			}
			WaitFactor *= 0.85f;
			WaitFactor = Mathf.Clamp(WaitFactor, 0.1f, 1f);
			if ((bool)CurrentPhantom && CurrentPhantom.IsHidden())
			{
				UnityEngine.Object.Destroy(CurrentPhantom.gameObject);
				CurrentPhantom = null;
			}
			CurrentPhantom = Spawn();
		}
	}

	public Ghost Spawn()
	{
		PlayerGameController controller = Player.GetController();
		Vector3 groundPos = Player.GetGroundPos();
		Vector3 forward = GameObject.FindWithTag(Tags.LookDirection).transform.forward;
		forward.y = 0f;
		forward.Normalize();
		GameObject[] array = GameObject.FindGameObjectsWithTag(Tags.Ghost);
		List<VisibilityProbe> list = new List<VisibilityProbe>();
		VisibilityProbe[] spawns = Spawns;
		foreach (VisibilityProbe visibilityProbe in spawns)
		{
			if (visibilityProbe.IsVisible)
			{
				continue;
			}
			Vector3 to = visibilityProbe.transform.position - groundPos;
			float sqrMagnitude = to.sqrMagnitude;
			if (!(sqrMagnitude <= MaxDistance * MaxDistance) || !(sqrMagnitude >= MinDistance * MinDistance))
			{
				continue;
			}
			to.Normalize();
			float num = Vector3.Angle(forward, to);
			if (!(num < 100f) && (!(sqrMagnitude <= MaxDistance * 0.75f * (MaxDistance * 0.75f)) || !(sqrMagnitude >= MinDistance / 2f * (MinDistance / 2f))))
			{
				continue;
			}
			bool flag = false;
			int num2 = 0;
			while (!flag && num2 < array.Length)
			{
				float sqrMagnitude2 = (array[num2].transform.position - visibilityProbe.transform.position).sqrMagnitude;
				if (sqrMagnitude2 <= 49f)
				{
					flag = true;
				}
				num2++;
			}
			Point pos = Map.Get().WorldToCell(visibilityProbe.transform.position);
			Cell cell = Map.Get().At(pos);
			if (!cell.Occupied && (cell.Room == null || !cell.Room.HasLocalEnemy) && CreatureCounter.GetInRoom(pos) <= 0 && !flag && !controller.IsInExitPath(Map.Get().WorldToCell(visibilityProbe.transform.position)))
			{
				list.Add(visibilityProbe);
			}
		}
		if (list.Count > 0)
		{
			VisibilityProbe visibilityProbe2 = RandomExt.Choice(list);
			GameObject gameObject = UnityEngine.Object.Instantiate(GhostPrefab, visibilityProbe2.transform.position, Quaternion.identity);
			Ghost component = gameObject.GetComponent<Ghost>();
			if (!ghostCreatures && ghostVisions)
			{
				component.isVision = true;
			}
			else if (ghostCreatures && !ghostVisions)
			{
				component.isVision = false;
			}
			else if (ghostCreatures && ghostVisions)
			{
				component.isVision = UnityEngine.Random.value <= 0.2f;
			}
			if (GameController.Get().levelOptions.ghostCanStretch)
			{
				component.canStretch = UnityEngine.Random.value <= 0.7f;
			}
			return component;
		}
		return null;
	}

	private IEnumerator DelayedEnable_co(float delayTime)
	{
		canSpawn = false;
		yield return new WaitForSeconds(delayTime);
		canSpawn = true;
	}
}
public class Jaw : MonoBehaviour
{
	public Transform jawBone;

	public float maxOpenAngle = 10f;

	private float initAngle;

	public float targetOpenPos;

	private float openPos;

	public float speed = 2f;

	private void Start()
	{
		initAngle = jawBone.localRotation.eulerAngles.z;
		targetOpenPos = (openPos = 0f);
	}

	private void Update()
	{
		openPos = Interpolate.Approach(openPos, targetOpenPos, Time.deltaTime * speed);
		Vector3 eulerAngles = jawBone.transform.localRotation.eulerAngles;
		eulerAngles.z = Interpolate.Clerp(initAngle, initAngle + maxOpenAngle, openPos);
		jawBone.transform.localRotation = Quaternion.Euler(eulerAngles);
	}

	public float GetOpenPos()
	{
		return openPos;
	}
}
[RequireComponent(typeof(Light))]
public class LightEatEffect : MonoBehaviour
{
	public Transform target;

	public float displacementMin = 0.1f;

	public float displacementMax = 0.6f;

	public float speed = 0.5f;

	public float factor;

	public LensFlare flare;

	private Vector3 initPos;

	private Vector3 controlPointInit;

	private Vector3 controlPointEnd;

	private bool extinguishing;

	private void Start()
	{
		if (target == null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		Vector3 position = target.position;
		initPos = base.transform.position;
		Vector3 vector = position - initPos;
		float magnitude = vector.magnitude;
		vector.Normalize();
		Vector3 vector2 = Vector3.Cross(vector, Vector3.up);
		Vector3 vector3 = Vector3.Cross(vector2, vector);
		Vector3 vector4 = UnityEngine.Random.Range(-1f, 1f) * vector2 + UnityEngine.Random.Range(-1f, 1f) * vector3;
		vector4.Normalize();
		controlPointInit = initPos + vector * magnitude * UnityEngine.Random.Range(0.1f, 0.25f) + vector4 * UnityEngine.Random.Range(displacementMin, displacementMax);
		controlPointEnd = initPos + vector * magnitude * UnityEngine.Random.Range(0.75f, 0.9f) + vector4 * UnityEngine.Random.Range(displacementMin / 3f, displacementMax / 3f);
		factor = 0f;
		flare.color = GetComponent<Light>().color;
		flare.brightness = 0f;
		extinguishing = false;
	}

	private void Update()
	{
		Vector3 position = target.position;
		Vector3 position2 = Interpolate.Bezier(initPos, controlPointInit, controlPointEnd, position, factor);
		base.transform.position = position2;
		factor += speed * Time.deltaTime;
		factor = Mathf.Clamp01(factor);
		flare.brightness = Mathf.Lerp(flare.brightness, GetComponent<Light>().intensity / 2f, 2f * Time.deltaTime);
		if (factor >= 1f || extinguishing)
		{
			GetComponent<Light>().intensity -= GetComponent<Light>().intensity * 2.55f * Time.deltaTime;
			if (GetComponent<Light>().intensity <= 0.1f)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}

	public void Extinguish()
	{
		extinguishing = true;
	}
}
public class LightEater : FSMComponent<LightEater.States>
{
	public enum States
	{
		HiddenWait,
		HiddenPatrol,
		Patrol,
		Sniff,
		SniffPlayer,
		WalkToLight,
		EatLight,
		Scream,
		Chase,
		Attack,
		SearchPlayer,
		Cooldown,
		StalkRoom
	}

	public float hiddenWalkSpeed = 1f;

	public float hiddenTurnSpeed = 1f;

	public float walkSpeed = 1f;

	public float walkTurnSpeed = 1f;

	public AudioClip[] reactSounds;

	public AudioClip[] screamSounds;

	public RandomSounds patrolSounds;

	public RandomSounds angrySounds;

	public RandomSounds searchSounds;

	private AnimStepSounds animStepSounds;

	public float chaseSpeed = 2f;

	public float chaseTurnSpeed = 2f;

	public float chaseTimeout = 5f;

	public float searchTimeoutMin = 8f;

	public float searchTimeoutMax = 12f;

	public float searchMaxAngle = 40f;

	public float searchMinDist = 0.5f;

	public float searchMaxDist = 2f;

	public float searchAbandonDistance = 24f;

	public float cooldownMinTime = 10f;

	public float cooldownMaxTime = 60f;

	public Room stalkRoom;

	private CreatureVisibility cVisibility;

	public LightEatEffect transitionLightPrefab;

	public Transform lightEndTarget;

	public ParticleSystem eatParticles;

	private GameObject player;

	private TorchFuel playerTorch;

	private SpookSounds spookSounds;

	private Animator animator;

	private BellyLight bellyLight;

	public float aggroLevel;

	private float timer;

	private float timer2;

	private float searchTimer;

	private bool needsCooldown;

	private bool destroyOnCooldown;

	private float timesChased;

	private float detectionFactor = 1f;

	private PathWalker pathWalker;

	private InteractiveLightEx targetLight;

	private LightEatEffect transitionLightFX;

	private void Start()
	{
		player = Player.Get();
		playerTorch = GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchFuel>();
		spookSounds = player.GetComponent<SpookSounds>();
		pathWalker = GetComponent<PathWalker>();
		pathWalker.applyFloorNoise = true;
		animator = GetComponent<Animator>();
		bellyLight = GetComponent<BellyLight>();
		cVisibility = GetComponent<CreatureVisibility>();
		animStepSounds = GetComponent<AnimStepSounds>();
		if (stalkRoom != null)
		{
			Init(States.StalkRoom);
		}
		else if (searchTimer > 1f)
		{
			Init(States.SearchPlayer);
			angrySounds.PlayNow();
		}
		else
		{
			Init(States.HiddenPatrol);
		}
	}

	protected override void Update()
	{
		animator.SetFloat("Speed", 0f);
		pathWalker.applyFloorNoise = !cVisibility.Hidden;
		base.Update();
	}

	private void HiddenPatrol_Enter()
	{
		pathWalker.Reset();
		cVisibility.SetHidden(hidden: true);
		patrolSounds.Playing = true;
		angrySounds.Playing = false;
		searchSounds.Playing = false;
		animStepSounds.playing = false;
		float num = Mathf.Max(0.1f, timesChased * 0.7f);
		if (UnityEngine.Random.value < num)
		{
			needsCooldown = true;
		}
	}

	private void HiddenPatrol_Update()
	{
		if (cVisibility.CheckVisibilize())
		{
			base.State = States.Patrol;
			return;
		}
		if (needsCooldown)
		{
			base.State = States.Cooldown;
			return;
		}
		if (pathWalker.CanSetPath(updateTimeout: true))
		{
			Point patrolTarget = GetPatrolTarget();
			pathWalker.SetPath(patrolTarget, CheckTraversal_Hidden, GetTraversalCost_Hidden);
		}
		if (pathWalker.FollowPath(hiddenWalkSpeed, hiddenTurnSpeed, openDoorForce: false, ignoreDoors: true))
		{
			base.State = States.HiddenWait;
		}
	}

	private float GetTraversalCost_Hidden(Point from, Point end, object movementDesc)
	{
		Map map = Map.Get();
		if (from.X < 0 || from.X >= map.Width || from.Y < 0 || from.Y >= map.Height || end.X < 0 || end.X >= map.Width || end.Y < 0 || end.Y >= map.Height)
		{
			return float.MaxValue;
		}
		return 1f;
	}

	private bool CheckTraversal_Hidden(Point from, Point end, object movementDesc)
	{
		Map map = Map.Get();
		if (from.X <= 0 || from.X >= map.Width - 1 || from.Y <= 0 || from.Y >= map.Height - 1 || end.X <= 0 || end.X >= map.Width - 1 || end.Y <= 0 || end.Y >= map.Height - 1)
		{
			return false;
		}
		Cell cell = map.At(end.X, end.Y);
		if (!cell.CanWalk() || (cell.Occupied && cell.Room != null && cell.Door == null && !cell.IsDoor))
		{
			return false;
		}
		if (from.X != end.X && from.Y != end.Y)
		{
			return false;
		}
		return true;
	}

	private void HiddenWait_Enter()
	{
		timer = UnityEngine.Random.Range(2f, 8f);
		cVisibility.SetHidden(hidden: true);
	}

	private void HiddenWait_Update()
	{
		if (cVisibility.CheckVisibilize())
		{
			base.State = States.Sniff;
			return;
		}
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.HiddenPatrol;
		}
	}

	private void Patrol_Enter()
	{
		pathWalker.Reset();
		cVisibility.SetHidden(hidden: false);
		patrolSounds.Playing = true;
		angrySounds.Playing = false;
		searchSounds.Playing = false;
		animStepSounds.playing = true;
	}

	private void Patrol_Update()
	{
		if (!cVisibility.CheckVisibilize())
		{
			base.State = States.HiddenPatrol;
			return;
		}
		SetTensionIfVisible();
		if (pathWalker.CanSetPath(updateTimeout: true))
		{
			Point patrolTarget = GetPatrolTarget();
			pathWalker.SetPath(patrolTarget);
		}
		if (pathWalker.FollowPath(walkSpeed, walkTurnSpeed))
		{
			base.State = States.Sniff;
		}
		else if (UpdateAggro())
		{
			base.State = States.Scream;
		}
		else if (aggroLevel >= 0.5f)
		{
			AudioSource.PlayClipAtPoint(RandomExt.Choice(reactSounds), base.transform.position + Vector3.up);
			base.State = States.SniffPlayer;
		}
	}

	private void Sniff_Enter()
	{
		timer = UnityEngine.Random.Range(2f, 8f);
		cVisibility.SetHidden(hidden: false);
		patrolSounds.Playing = true;
		angrySounds.Playing = false;
		searchSounds.Playing = false;
		animStepSounds.playing = false;
	}

	private void Sniff_Update()
	{
		SetTensionIfVisible();
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			Point pos = Map.Get().WorldToCell(base.transform.position);
			List<InteractiveLightEx> list = new List<InteractiveLightEx>();
			Room room = Map.Get().At(pos).Room;
			if (room != null)
			{
				foreach (InteractiveLightEx light in room.lights)
				{
					if (light.lightOn && !light.invulnerable)
					{
						list.Add(light);
					}
				}
			}
			if (list.Count == 0)
			{
				base.State = States.HiddenPatrol;
			}
			else
			{
				targetLight = RandomExt.Choice(list);
				base.State = States.WalkToLight;
			}
		}
		if (UpdateAggro())
		{
			base.State = States.Scream;
		}
	}

	private void SniffPlayer_Enter()
	{
		timer = UnityEngine.Random.Range(2f, 8f);
		cVisibility.SetHidden(hidden: false);
		patrolSounds.Playing = false;
		angrySounds.Playing = false;
		searchSounds.Playing = true;
		animStepSounds.playing = true;
		timesChased += 0.3f;
	}

	private void SniffPlayer_Update()
	{
		FearEffect.Get().Scare();
		SetTensionIfVisible();
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			if (searchTimer > 0f)
			{
				base.State = States.SearchPlayer;
			}
			else
			{
				detectionFactor = 1f;
				base.State = States.Patrol;
			}
		}
		if (UpdateAggro())
		{
			detectionFactor = 1f;
			base.State = States.Scream;
		}
	}

	private void WalkToLight_Enter()
	{
		pathWalker.Reset();
		cVisibility.SetHidden(hidden: false);
		patrolSounds.Playing = true;
		angrySounds.Playing = false;
		searchSounds.Playing = false;
		animStepSounds.playing = true;
	}

	private void WalkToLight_Update()
	{
		if (!cVisibility.CheckVisibilize())
		{
			base.State = States.HiddenPatrol;
			return;
		}
		SetTensionIfVisible();
		if (Vector3Ext.GroundVector(base.transform.position, targetLight.transform.position).sqrMagnitude <= 0.25f)
		{
			base.State = States.EatLight;
		}
		else if (pathWalker.CanSetPath(updateTimeout: true))
		{
			Point point = Map.Get().WorldToCell(base.transform.position);
			Point lightPos = Map.Get().WorldToCell(targetLight.transform.position);
			Point lightEatTarget = GetLightEatTarget(lightPos);
			if (point == lightEatTarget)
			{
				base.State = States.EatLight;
			}
			else if (!pathWalker.SetPath(lightEatTarget))
			{
				base.State = States.Patrol;
			}
		}
		if (pathWalker.FollowPath(walkSpeed, walkTurnSpeed))
		{
			base.State = States.EatLight;
		}
		if (UpdateAggro())
		{
			base.State = States.Scream;
		}
	}

	private void EatLight_Enter()
	{
		cVisibility.SetHidden(hidden: false);
		patrolSounds.Playing = false;
		angrySounds.Playing = false;
		searchSounds.Playing = false;
		animStepSounds.playing = true;
		SetParticles(enabled: true);
		timer = 6.6f;
		timer2 = 1f;
		transitionLightFX = null;
	}

	private void EatLight_Update()
	{
		SetTensionIfVisible();
		animator.SetBool("EatLight", value: true);
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Sniff;
			SetParticles(enabled: false);
			return;
		}
		timer2 -= Time.deltaTime;
		if (timer2 <= 0f)
		{
			timer2 = 60f;
			transitionLightFX = UnityEngine.Object.Instantiate(transitionLightPrefab);
			transitionLightFX.target = lightEndTarget;
			Light component = transitionLightFX.GetComponent<Light>();
			Light light = targetLight.GetLight();
			component.range = light.range;
			component.color = light.color;
			component.intensity = light.intensity;
			component.shadows = light.shadows;
			component.shadowStrength = light.shadowStrength;
			component.shadowSoftness = light.shadowSoftness;
			component.shadowSoftnessFade = light.shadowSoftnessFade;
			component.shadowBias = light.shadowBias;
			component.cullingMask = light.cullingMask;
			component.transform.position = light.transform.position;
			component.enabled = true;
			targetLight.TurnOff(fast: true);
		}
		LookAt(targetLight.transform.position, walkTurnSpeed);
		if (UpdateAggro())
		{
			if (transitionLightFX != null)
			{
				transitionLightFX.Extinguish();
				transitionLightFX = null;
			}
			base.State = States.Scream;
		}
	}

	private void EatLight_Exit()
	{
		animator.SetBool("EatLight", value: false);
		SetParticles(enabled: false);
		targetLight = null;
		transitionLightFX = null;
	}

	private void Scream_Enter()
	{
		animator.SetBool("ReactToPlayer", value: true);
		timer = 3.23f;
		AudioSource.PlayClipAtPoint(RandomExt.Choice(screamSounds), base.transform.position + Vector3.up);
		patrolSounds.Playing = false;
		angrySounds.Playing = true;
		searchSounds.Playing = false;
		animStepSounds.playing = true;
		spookSounds.PlayScare(intense: true);
		Jukebox.Get().SetIntense();
	}

	private void Scream_Update()
	{
		Jukebox.Get().SetIntense();
		LookAt(Player.GetPos(), chaseTurnSpeed);
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Chase;
		}
	}

	private void Scream_Exit()
	{
		animator.SetBool("ReactToPlayer", value: false);
	}

	private void Chase_Enter()
	{
		pathWalker.Reset();
		pathWalker.ClearPath();
		timer = chaseTimeout;
		timesChased += 1f;
		patrolSounds.Playing = false;
		angrySounds.Playing = true;
		searchSounds.Playing = false;
		animStepSounds.playing = true;
	}

	private void Chase_Update()
	{
		Jukebox.Get().SetIntense();
		FearEffect.Get().Scare();
		Vector3 groundPos = Player.GetGroundPos();
		float sqrMagnitude = Player.GetToPosGround(base.transform.position).sqrMagnitude;
		float num = GetComponent<CapsuleCollider>().radius + player.GetComponent<CharacterController>().radius + 0.5f;
		if (sqrMagnitude <= num * num)
		{
			base.State = States.Attack;
			return;
		}
		if (pathWalker.CheckLineOfWalkToPlayer(groundPos))
		{
			pathWalker.MoveTowards(groundPos, chaseSpeed, chaseTurnSpeed);
			pathWalker.ClearPath();
		}
		else
		{
			if (pathWalker.CanSetPath(updateTimeout: true))
			{
				Point closestWalkable = Map.Get().GetClosestWalkable(groundPos);
				pathWalker.SetPath(closestWalkable);
			}
			if (pathWalker.FollowPath(chaseSpeed, chaseTurnSpeed, openDoorForce: true))
			{
				pathWalker.ClearPath();
			}
		}
		if (CheckPlayerInLoS())
		{
			timer = chaseTimeout;
			return;
		}
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			SetSearchTimer();
			base.State = States.SearchPlayer;
		}
	}

	private void Chase_Exit()
	{
		pathWalker.ClearPath();
	}

	private void Attack_Enter()
	{
		animator.SetBool("AttackPlayer", value: true);
		timer = 1.4f;
		timesChased += 5f;
	}

	private void Attack_Update()
	{
		LookAt(Player.GetPos(), chaseTurnSpeed);
		timer -= Time.deltaTime;
		if (timer < 0f)
		{
			base.State = States.Chase;
		}
	}

	private void Attack_Exit()
	{
		animator.SetBool("AttackPlayer", value: false);
	}

	public void DoAttack()
	{
		if (Vector3Ext.GroundVector(Player.GetPos(), base.transform.position).sqrMagnitude <= 4f)
		{
			player.GetComponent<PlayerGameController>().ApplyAttack(0.6f, "GAMEOVER_LIGHTEATER");
		}
	}

	private void SearchPlayer_Enter()
	{
		pathWalker.Reset();
		pathWalker.ClearPath();
		timesChased += 0.3f;
		detectionFactor = 0.5f;
		cVisibility.SetHidden(hidden: false);
		patrolSounds.Playing = false;
		angrySounds.Playing = false;
		searchSounds.Playing = true;
		animStepSounds.playing = true;
		Tutorial.Get().DoTutorialLight();
	}

	private void SearchPlayer_Update()
	{
		Jukebox.Get().SetTension();
		searchTimer -= Time.deltaTime;
		if (searchTimer <= 0f)
		{
			base.State = States.SniffPlayer;
			return;
		}
		if (Vector3Ext.GroundVector(Player.GetPos(), base.transform.position).sqrMagnitude >= searchAbandonDistance * searchAbandonDistance)
		{
			searchTimer = 0f;
			base.State = States.SniffPlayer;
			return;
		}
		if (pathWalker.CanSetPath(updateTimeout: true))
		{
			Point searchTarget = GetSearchTarget();
			if (searchTarget == Map.Get().WorldToCell(base.transform.position))
			{
				searchTimer = 0f;
				base.State = States.Patrol;
				return;
			}
			pathWalker.SetPath(searchTarget);
		}
		if (pathWalker.FollowPath(walkSpeed, walkTurnSpeed))
		{
			Room room = Map.Get().At(base.transform.position).Room;
			if (room != null && room.PlayerInside)
			{
				searchTimer /= 2f;
			}
			base.State = States.SniffPlayer;
		}
		else if (UpdateAggro())
		{
			detectionFactor = 1f;
			base.State = States.Scream;
		}
		else if (aggroLevel >= 0.5f)
		{
			AudioSource.PlayClipAtPoint(RandomExt.Choice(reactSounds), base.transform.position + Vector3.up);
			base.State = States.SniffPlayer;
		}
	}

	private void Cooldown_Enter()
	{
		cVisibility.SetHidden(hidden: true);
		patrolSounds.Playing = false;
		angrySounds.Playing = false;
		searchSounds.Playing = false;
		animStepSounds.playing = false;
		pathWalker.Reset();
		pathWalker.ClearPath();
		timer = UnityEngine.Random.Range(cooldownMinTime, cooldownMaxTime);
		TeleportRandomRoom();
		if (destroyOnCooldown)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void Cooldown_Update()
	{
		timer -= Time.deltaTime;
		if (timer <= 0f && !cVisibility.CheckVisibilize())
		{
			base.State = States.HiddenPatrol;
		}
	}

	private void Cooldown_Exit()
	{
		needsCooldown = false;
		timesChased = 0f;
	}

	private void StalkRoom_Enter()
	{
		Point randomPoint = stalkRoom.GetRandomPoint(central: true);
		if (randomPoint.X != -1 && randomPoint.Y != -1)
		{
			Vector3 vector = Map.Get().CellToWorld(randomPoint);
			base.transform.position = vector + Vector3.up * Map.Get().FloorHeight(vector);
		}
		patrolSounds.Playing = true;
		angrySounds.Playing = false;
		searchSounds.Playing = false;
		animStepSounds.playing = false;
	}

	private void StalkRoom_Update()
	{
		if (GetComponent<Collider>().enabled && !cVisibility.CheckVisibilize())
		{
			cVisibility.SetHidden(hidden: true);
		}
		else if (!GetComponent<Collider>().enabled && cVisibility.CheckVisibilize())
		{
			cVisibility.SetHidden(hidden: false);
		}
		if (Map.Get().At(base.transform.position).IsVisible())
		{
			AudioSource.PlayClipAtPoint(RandomExt.Choice(reactSounds), base.transform.position + Vector3.up);
			base.State = States.SniffPlayer;
		}
	}

	private void StalkRoom_Exit()
	{
		stalkRoom = null;
	}

	private Point GetPatrolTarget()
	{
		Vector3 position = base.transform.position;
		Room room = Map.Get().At(position).Room;
		Point point = new Point(-1, -1);
		int num = 5;
		do
		{
			List<Tuple<Point, Room, float>> list = new List<Tuple<Point, Room, float>>();
			foreach (Room room2 in Map.Get().Rooms)
			{
				if (room2 != room && !room2.Safe)
				{
					Point randomPoint = room2.GetRandomPoint(central: true);
					if (randomPoint.X != -1 && randomPoint.Y != -1)
					{
						float sqrMagnitude = (Map.Get().CellToWorld(randomPoint) - position).sqrMagnitude;
						list.Add(new Tuple<Point, Room, float>(randomPoint, room2, sqrMagnitude));
					}
				}
			}
			list.Sort((Tuple<Point, Room, float> p1, Tuple<Point, Room, float> p2) => (p1.Item3 < p2.Item3) ? (-1) : ((p1.Item3 > p2.Item3) ? 1 : 0));
			point = list[UnityEngine.Random.Range(0, Mathf.Min(3, list.Count))].Item1;
		}
		while ((point.X == -1 || point.Y == -1) && num-- > 0);
		return point;
	}

	private Point GetLightEatTarget(Point lightPos)
	{
		if (!Map.IsBlockedToEnemy(Map.Get().At(lightPos)))
		{
			return lightPos;
		}
		Point point = lightPos;
		int num = 4;
		for (int i = lightPos.X - 1; i <= lightPos.X + 1; i++)
		{
			Point point2 = new Point(i, lightPos.Y);
			if (!Map.IsBlockedToEnemy(Map.Get().At(point2)))
			{
				int numAdjacentWalls = Map.Get().At(point2).GetNumAdjacentWalls();
				if (numAdjacentWalls < num)
				{
					point = point2;
					num = numAdjacentWalls;
				}
			}
		}
		for (int j = lightPos.Y - 1; j <= lightPos.Y + 1; j++)
		{
			Point point3 = new Point(lightPos.X, j);
			if (!Map.IsBlockedToEnemy(Map.Get().At(point3)))
			{
				int numAdjacentWalls2 = Map.Get().At(point3).GetNumAdjacentWalls();
				if (numAdjacentWalls2 < num)
				{
					point = point3;
					num = numAdjacentWalls2;
				}
			}
		}
		if (point == lightPos)
		{
			point = Map.Get().GetClosestWalkable(lightPos);
		}
		return point;
	}

	private Point GetSearchTarget()
	{
		Vector3 vector = Vector3Ext.GroundVector(base.transform.position);
		Vector3 groundPos = Player.GetGroundPos();
		Vector3 vector2 = groundPos - vector;
		float magnitude = vector2.magnitude;
		vector2 /= magnitude;
		int num = 10;
		Vector3 vector3 = vector;
		while (num-- > 0)
		{
			float y = UnityEngine.Random.value * searchMaxAngle - searchMaxAngle / 2f;
			Vector3 vector4 = Quaternion.Euler(0f, y, 0f) * vector2;
			float num2 = UnityEngine.Random.Range(searchMinDist, searchMaxDist);
			num2 *= magnitude;
			vector3 = vector + vector4 * num2;
			Point point = Map.Get().WorldToCell(vector3);
			Cell cell = Map.Get().At(point);
			if (cell != null && cell.CanWalk() && (!cell.Occupied || cell.Room == null || !(cell.Door == null) || cell.IsDoor) && (Map.Get().CellToWorld(point) - groundPos).sqrMagnitude >= 9f)
			{
				return point;
			}
		}
		return Map.Get().WorldToCell(vector);
	}

	private bool UpdateAggro()
	{
		float num = -0.2f;
		bool flag = false;
		Point point = Map.Get().WorldToCell(base.transform.position);
		float sqrMagnitude = Vector3Ext.GroundVector(Player.GetPos(), base.transform.position).sqrMagnitude;
		if (sqrMagnitude <= 225f)
		{
			bool flag2 = Utils.IsPlayerVisible(base.transform, float.MaxValue, checkOnlyAngle: false, 20f, 1f);
			flag = flag2;
			bool flag3 = playerTorch.IsLightOn();
			bool burning = playerTorch.burning;
			if (sqrMagnitude <= 1.44f)
			{
				num = ((!flag3) ? (num + 1.5f * detectionFactor) : (num + 30f * detectionFactor));
			}
			else if (sqrMagnitude <= 3.0625f)
			{
				num = (burning ? (num + 20f * detectionFactor) : ((!flag3) ? (num + 0.5f * detectionFactor) : (num + 2f * detectionFactor)));
			}
			else if (sqrMagnitude <= 9f)
			{
				if (burning)
				{
					num += 0.9f * detectionFactor;
				}
				else if (flag3)
				{
					num += 0.4f * detectionFactor;
				}
				else
				{
					Room room = Map.Get().At(Player.GetPos()).Room;
					if (room == null || room.Template.size != 0)
					{
						num += 0.3f * detectionFactor;
					}
				}
			}
			else if (sqrMagnitude <= 36f)
			{
				if (burning)
				{
					num += 0.9f * detectionFactor;
				}
				else if (flag3)
				{
					num += 0.4f * detectionFactor;
				}
			}
		}
		aggroLevel += Time.deltaTime * num;
		aggroLevel = Mathf.Clamp01(aggroLevel);
		return aggroLevel >= 1f && flag;
	}

	private void SetTensionIfVisible(bool scareEffect = true)
	{
		Point point = Map.Get().WorldToCell(base.transform.position);
		if (point.X < 0 || point.Y < 0 || point.X >= Map.Get().Width || point.Y >= Map.Get().Height)
		{
			base.State = States.Cooldown;
			return;
		}
		bool flag = false;
		Cell cell = Map.Get().At(base.transform.position);
		flag = cell.IsVisible();
		if (!flag && cell.Room != null)
		{
			flag = cell.Room.PlayerInside;
		}
		if (flag)
		{
			Jukebox.Get().SetTension();
			if (scareEffect)
			{
				FearEffect.Get().Scare();
			}
		}
	}

	public void TeleportRandomRoom()
	{
		Vector3 position = base.transform.position;
		Room room = Map.Get().At(position).Room;
		Point point = new Point(-1, -1);
		int num = 5;
		do
		{
			List<Tuple<Point, Room, float>> list = new List<Tuple<Point, Room, float>>();
			foreach (Room room2 in Map.Get().Rooms)
			{
				if (room2 != room && !room2.Safe)
				{
					Point randomPoint = room2.GetRandomPoint(central: true);
					if (randomPoint.X != -1 && randomPoint.Y != -1 && !cVisibility.CheckVisibilize(randomPoint))
					{
						float sqrMagnitude = (Map.Get().CellToWorld(randomPoint) - position).sqrMagnitude;
						list.Add(new Tuple<Point, Room, float>(randomPoint, room2, sqrMagnitude));
					}
				}
			}
			list.Sort((Tuple<Point, Room, float> p1, Tuple<Point, Room, float> p2) => (p1.Item3 < p2.Item3) ? (-1) : ((p1.Item3 > p2.Item3) ? 1 : 0));
			point = list[UnityEngine.Random.Range(0, Mathf.Min(5, list.Count))].Item1;
		}
		while ((point.X == -1 || point.Y == -1) && num-- > 0);
		if (point.X != -1 && point.Y != -1)
		{
			Vector3 vector = Map.Get().CellToWorld(point);
			base.transform.position = vector + Vector3.up * Map.Get().FloorHeight(vector);
		}
	}

	public void SetStalk(Room room)
	{
		stalkRoom = room;
	}

	private bool CheckPlayerInLoS()
	{
		Vector3 vector = Vector3Ext.GroundVector(Player.GetPos()) + Vector3.up;
		Vector3 direction = vector - base.transform.position + Vector3.up;
		if (direction.sqrMagnitude > 256f)
		{
			return false;
		}
		float magnitude = direction.magnitude;
		direction /= magnitude;
		if (Physics.Raycast(base.transform.position + Vector3.up, direction, out var hitInfo, magnitude))
		{
			return hitInfo.collider.gameObject == player.gameObject;
		}
		return false;
	}

	private void SetParticles(bool enabled)
	{
		ParticleSystem[] componentsInChildren = eatParticles.GetComponentsInChildren<ParticleSystem>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].enableEmission = enabled;
		}
		eatParticles.enableEmission = enabled;
	}

	private void LookAt(Vector3 pos, float turnSpeed)
	{
		Vector3 forward = Vector3Ext.GroundVector(pos, base.transform.position);
		forward.Normalize();
		base.transform.rotation = Quaternion.Slerp(base.transform.rotation, Quaternion.LookRotation(forward, Vector3.up), Time.deltaTime * turnSpeed);
	}

	private void SetSearchTimer()
	{
		searchTimer = RandomExt.GaussianRange(searchTimeoutMin, searchTimeoutMax);
	}

	public static LightEater SpawnNextToRoom(Room room)
	{
		MapBuilder component = GameObject.FindWithTag(Tags.GameController).GetComponent<MapBuilder>();
		LightEater lightEaterPrefab = component.lightEaterPrefab;
		Point randomPoint = room.GetRandomPoint(central: true);
		Point point = randomPoint;
		List<Point> list = new List<Point>();
		List<Point> list2 = new List<Point>();
		list2.Add(randomPoint);
		while (list2.Count > 0)
		{
			int index = UnityEngine.Random.Range(0, list2.Count);
			Point curTile = list2[index];
			list2.RemoveAt(index);
			if (list.Exists((Point e) => e == curTile))
			{
				continue;
			}
			list.Add(curTile);
			Cell cell = Map.Get().At(curTile);
			if (cell != null && cell.CanWalk() && (!cell.Occupied || cell.Room == null || !(cell.Door == null) || cell.IsDoor))
			{
				if (cell.Room != room && !cell.IsVisible())
				{
					point = curTile;
					break;
				}
				list2.Add(new Point(curTile.X - 1, curTile.Y));
				list2.Add(new Point(curTile.X + 1, curTile.Y));
				list2.Add(new Point(curTile.X, curTile.Y - 1));
				list2.Add(new Point(curTile.X, curTile.Y + 1));
			}
		}
		if (point == randomPoint)
		{
			return null;
		}
		LightEater lightEater = UnityEngine.Object.Instantiate(lightEaterPrefab, Map.Get().CellToWorld(point), Quaternion.identity);
		lightEater.destroyOnCooldown = true;
		lightEater.SetSearchTimer();
		lightEater.State = States.SearchPlayer;
		return lightEater;
	}

	public static LightEater SpawnNextToPlayer(bool destroy = true, bool setInSearch = true)
	{
		MapBuilder component = GameObject.FindWithTag(Tags.GameController).GetComponent<MapBuilder>();
		LightEater lightEaterPrefab = component.lightEaterPrefab;
		Vector3 pos = Player.GetPos();
		Point point = Map.Get().WorldToCell(pos);
		Point point2 = point;
		Room room = Map.Get().At(point).Room;
		List<Point> list = new List<Point>();
		List<Point> list2 = new List<Point>();
		list2.Add(point);
		while (list2.Count > 0)
		{
			int index = UnityEngine.Random.Range(0, list2.Count);
			Point curTile = list2[index];
			list2.RemoveAt(index);
			if (list.Exists((Point e) => e == curTile))
			{
				continue;
			}
			list.Add(curTile);
			Cell cell = Map.Get().At(curTile);
			if (cell != null && cell.CanWalk())
			{
				if ((!cell.Occupied || cell.Room == null || !(cell.Door == null) || cell.IsDoor) && !cell.IsVisible() && (cell.Room != room || room == null) && (Map.Get().CellToWorld(curTile) - pos).sqrMagnitude > 64f && !cell.CheckLoS(Player.GetCenterEye()))
				{
					point2 = curTile;
					break;
				}
				list2.Add(new Point(curTile.X - 1, curTile.Y));
				list2.Add(new Point(curTile.X + 1, curTile.Y));
				list2.Add(new Point(curTile.X, curTile.Y - 1));
				list2.Add(new Point(curTile.X, curTile.Y + 1));
			}
		}
		if (point2 == point)
		{
			return null;
		}
		Pathfinder pathfinder = Pathfinder.Get();
		Pathfinder.Query query = pathfinder.AddQuery(point2, point, null, PathWalker.CheckTraversal, PathWalker.GetTraversalCost, null, 0.5f);
		if (pathfinder.RunAStar(query))
		{
			if (query.State != Pathfinder.Query.EState.Success)
			{
				pathfinder.FreeQuery(query);
				return null;
			}
			pathfinder.FreeQuery(query);
		}
		LightEater lightEater = UnityEngine.Object.Instantiate(lightEaterPrefab, Map.Get().CellToWorld(point2), Quaternion.identity);
		lightEater.destroyOnCooldown = destroy;
		if (setInSearch)
		{
			lightEater.SetSearchTimer();
			lightEater.searchTimer = 10f;
		}
		return lightEater;
	}
}
public class MusicMoodSetter : MonoBehaviour
{
	public bool tension;

	public bool intense;

	public bool fear;

	public bool setIfSameRoom = true;

	public float updateRate = 0.25f;

	private void Start()
	{
		StartCoroutine(Update_co());
	}

	private IEnumerator Update_co()
	{
		while (true)
		{
			if (intense || tension || fear)
			{
				Cell cell = Map.Get().At(base.transform.position);
				bool flag = cell.IsVisible();
				if (!setIfSameRoom && cell.Room != null)
				{
					flag |= cell.Room.PlayerInside;
				}
				if (flag)
				{
					if (intense)
					{
						Jukebox.Get().SetIntense();
					}
					else if (tension)
					{
						Jukebox.Get().SetTension();
					}
					if (fear)
					{
						FearEffect.Get().Scare();
					}
				}
			}
			yield return new WaitForSeconds(updateRate);
		}
	}
}
public class NavGraph : MonoBehaviour
{
	public GameObject NodePrefab;

	public List<Transform> SpawnPositions;

	public List<NavNode> Nodes;

	private Queue<NavNode> nodeQueue;

	private Dictionary<string, Pair<bool, NavNode>> visitedNodes;

	private Stack<NavNode> pathStack;

	private void Awake()
	{
		SpawnPositions = new List<Transform>();
		Nodes = new List<NavNode>();
		for (int i = 0; i < 2; i++)
		{
			for (int j = i; j < Map.Get().Height - 1; j += 2)
			{
				for (int k = i; k < Map.Get().Width - 1; k += 2)
				{
					Cell cell = Map.Get().At(k, j);
					Cell cell2 = Map.Get().At(k + 1, j);
					Cell cell3 = Map.Get().At(k, j + 1);
					Cell cell4 = Map.Get().At(k + 1, j + 1);
					if (cell.IsClear() && (!cell.Occupied || cell.IsDoor || cell.IsCorridor()) && cell.IsNextToDoor == AdjacencyCode.Clear && cell2.IsClear() && (!cell2.Occupied || cell2.IsDoor || cell2.IsCorridor()) && cell2.IsNextToDoor == AdjacencyCode.Clear && cell3.IsClear() && (!cell3.Occupied || cell3.IsDoor || cell3.IsCorridor()) && cell3.IsNextToDoor == AdjacencyCode.Clear && cell4.IsClear() && (!cell4.Occupied || cell4.IsDoor || cell4.IsCorridor()) && cell4.IsNextToDoor == AdjacencyCode.Clear)
					{
						Vector3 localPosition = Map.Get().CellToWorld(k, j) + new Vector3(Map.Get().TileSize.x, 0f, 0f - Map.Get().TileSize.y) / 2f;
						GameObject gameObject = UnityEngine.Object.Instantiate(NodePrefab);
						gameObject.name = "NavNode_" + k + "_" + j;
						gameObject.transform.parent = base.transform;
						gameObject.transform.localPosition = localPosition;
						NavNode component = gameObject.GetComponent<NavNode>();
						if (component != null)
						{
							Nodes.Add(component);
						}
						if (cell.IsCorridor())
						{
							SpawnPositions.Add(gameObject.transform);
						}
					}
				}
			}
		}
	}

	public bool SearchPath(NavNode from, NavNode to, Queue<NavNode> outPath)
	{
		outPath.Clear();
		if (nodeQueue == null)
		{
			nodeQueue = new Queue<NavNode>();
		}
		nodeQueue.Clear();
		if (visitedNodes == null)
		{
			visitedNodes = new Dictionary<string, Pair<bool, NavNode>>();
		}
		visitedNodes.Clear();
		nodeQueue.Enqueue(from);
		visitedNodes[from.name] = new Pair<bool, NavNode>(first: true, null);
		while (nodeQueue.Count > 0)
		{
			NavNode navNode = nodeQueue.Dequeue();
			if (navNode == to)
			{
				if (pathStack == null)
				{
					pathStack = new Stack<NavNode>();
				}
				pathStack.Clear();
				while (navNode != null)
				{
					pathStack.Push(navNode);
					navNode = visitedNodes[navNode.name].Second;
				}
				outPath.Clear();
				foreach (NavNode item in pathStack)
				{
					outPath.Enqueue(item);
				}
				return true;
			}
			foreach (NavNode neighbour in navNode.Neighbours)
			{
				if (!visitedNodes.ContainsKey(neighbour.name))
				{
					nodeQueue.Enqueue(neighbour);
					visitedNodes[neighbour.name] = new Pair<bool, NavNode>(first: true, navNode);
				}
			}
		}
		return false;
	}

	public NavNode GetClosestNode(Vector3 point)
	{
		NavNode navNode = null;
		float num = float.MaxValue;
		for (int i = 0; i < Nodes.Count; i++)
		{
			NavNode navNode2 = Nodes[i];
			float sqrMagnitude = (navNode2.transform.position - point).sqrMagnitude;
			if (sqrMagnitude < num)
			{
				navNode = navNode2;
				num = sqrMagnitude;
			}
		}
		if (!navNode)
		{
			return null;
		}
		return navNode;
	}
}
public class NavNode : MonoBehaviour
{
	public List<NavNode> Neighbours;

	public int nodeGroup = -1;

	private bool initialized;

	private void Awake()
	{
		Neighbours = new List<NavNode>();
		initialized = false;
	}

	private void Start()
	{
		if (!initialized)
		{
			InitNeighbours();
		}
	}

	private void InitNeighbours()
	{
		initialized = true;
		Collider[] array = Physics.OverlapSphere(base.transform.position, Map.Get().TileSize.x * 1.2f);
		Collider[] array2 = array;
		foreach (Collider collider in array2)
		{
			NavNode component = collider.GetComponent<NavNode>();
			if (component != null && component != this)
			{
				Neighbours.Add(component);
			}
		}
	}

	public int SetGroup(int group)
	{
		if (nodeGroup != group)
		{
			if (!initialized)
			{
				InitNeighbours();
			}
			nodeGroup = group;
			int num = 1;
			for (int i = 0; i < Neighbours.Count; i++)
			{
				num += Neighbours[i].SetGroup(group);
			}
			return num;
		}
		return 0;
	}
}
public class PathWalker : MonoBehaviour
{
	public delegate void OnBlockedByDoor(Door door);

	public Pathfinder pathfinder;

	public List<Vector3> path;

	private List<Vector3> tempPath;

	public float pathTimeout;

	public bool waitingDoor;

	public float doorTimeout;

	public float doorForceChance = 1f;

	public bool doorForceFast;

	public OnBlockedByDoor onBlockedByDoor;

	public bool canFloat;

	public Animator animator;

	public float radiusFactor = 1.1f;

	private LayerMask sightMask;

	public float nodeRange = 0.5f;

	private float nodeRangeSq;

	public float backwardsNodeRange = 0.5f;

	private float backwardsNodeRangeSq;

	public bool applyFloorNoise;

	private void Awake()
	{
		nodeRangeSq = nodeRange * nodeRange;
		if (backwardsNodeRange <= 0f)
		{
			backwardsNodeRange = nodeRange;
		}
		backwardsNodeRangeSq = backwardsNodeRange * backwardsNodeRange;
		path = new List<Vector3>();
		tempPath = new List<Vector3>();
		pathfinder = Pathfinder.Get();
		pathTimeout = 0f;
		if (animator == null)
		{
			animator = GetComponent<Animator>();
		}
		sightMask = LayerMaskExtensions.NamesToMask("StaticGeometry", "Prop", "Default", "Creature");
	}

	public void Reset()
	{
		pathTimeout = 0f;
		waitingDoor = false;
	}

	public void ClearPath()
	{
		path.Clear();
	}

	public bool SetPath(Point target, Pathfinder.CheckTraversalHandler checkTraversal = null, Pathfinder.GetCostHandler traversalCost = null)
	{
		if (target.X != -1 && target.Y != -1)
		{
			if (!BuildPath(path, target, checkTraversal, traversalCost))
			{
				pathTimeout = 2f;
				return false;
			}
			pathTimeout = 0f;
			return true;
		}
		pathTimeout = 0.1f;
		return false;
	}

	public bool BuildPath(List<Vector3> pathRef, Point target, Pathfinder.CheckTraversalHandler checkTraversal, Pathfinder.GetCostHandler traversalCost)
	{
		if (checkTraversal == null)
		{
			checkTraversal = ((!canFloat) ? new Pathfinder.CheckTraversalHandler(CheckTraversal) : new Pathfinder.CheckTraversalHandler(CheckTraversalFloater));
		}
		if (traversalCost == null)
		{
			traversalCost = GetTraversalCost;
		}
		Vector3 vWorldPos = GetPos().ToGround();
		Pathfinder.Query query = pathfinder.AddQuery(Map.Get().WorldToCell(vWorldPos), target, null, checkTraversal, traversalCost, null, 0.5f);
		if (pathfinder.RunAStar(query))
		{
			if (query.State == Pathfinder.Query.EState.Success)
			{
				foreach (Point item in query.Path)
				{
					path.Add(Map.Get().CellToWorld(item.X, item.Y));
				}
				OptimizePath();
			}
			pathfinder.FreeQuery(query);
			return true;
		}
		return false;
	}

	public bool FollowPath(float speed, float turnSpeed, bool openDoorForce = false, bool ignoreDoors = false)
	{
		Vector3 vector = GetPos().ToGround();
		Vector3 vector2 = GetPos();
		if (path.Count != 0)
		{
			Vector3 vector3 = vector;
			if (path.Count >= 1 && CheckNodeInRange(path[0], vector))
			{
				path.RemoveAt(0);
			}
			foreach (Vector3 item in path)
			{
				vector3 = item;
			}
			if (path.Count == 0)
			{
				return true;
			}
			vector2 = path[0].ToGround();
		}
		bool flag = true;
		if ((vector2 - GetPos()).sqrMagnitude <= 3.2399998f)
		{
			Door doorBetweenTiles = Map.Get().GetDoorBetweenTiles(Map.Get().WorldToCell(GetPos()), Map.Get().WorldToCell(vector2));
			if ((bool)doorBetweenTiles && (!doorBetweenTiles.IsOpen || waitingDoor))
			{
				flag = false;
				if (!waitingDoor)
				{
					waitingDoor = true;
					if (openDoorForce)
					{
						bool flag2 = true;
						VisibilityProbe probe = Map.Get().At(base.transform.position).Probe;
						if (probe != null)
						{
							flag2 = !probe.IsVisible;
						}
						if (UnityEngine.Random.value < doorForceChance || !flag2)
						{
							if (doorForceFast)
							{
								doorBetweenTiles.Bash();
								doorBetweenTiles.OpenFast(base.transform);
								doorTimeout = 0f;
							}
							else
							{
								doorBetweenTiles.PlayBashAndOpen(bDoOpen: true, base.transform);
								doorTimeout = 2f;
							}
						}
						else
						{
							doorBetweenTiles.PlayBashAndOpen(bDoOpen: false, base.transform);
							if (onBlockedByDoor != null)
							{
								onBlockedByDoor(doorBetweenTiles);
							}
						}
					}
					else
					{
						doorBetweenTiles.Open(base.transform);
						doorTimeout = 2.5f;
					}
				}
				else
				{
					doorTimeout -= Time.deltaTime;
					if (doorTimeout <= 0f && doorBetweenTiles.IsOpen)
					{
						waitingDoor = false;
					}
				}
			}
			else
			{
				waitingDoor = false;
			}
		}
		if (vector2 != vector && flag && MoveTowards(vector2, vector, speed, turnSpeed))
		{
			if (path.Count > 0)
			{
				path.RemoveAt(0);
			}
			if (path.Count == 0)
			{
				return true;
			}
		}
		return false;
	}

	public bool CanSetPath(bool updateTimeout = false)
	{
		if (path.Count == 0 && pathTimeout <= 0f)
		{
			return true;
		}
		if (updateTimeout && pathTimeout > 0f)
		{
			pathTimeout -= Time.deltaTime;
		}
		return false;
	}

	public Vector3 GetNextNode(bool advanceNodes = true)
	{
		Vector3 vector = GetPos().ToGround();
		Vector3 result = GetPos();
		if (path.Count != 0)
		{
			Vector3 vector2 = vector;
			if (path.Count >= 1 && advanceNodes && CheckNodeInRange(path[0], vector))
			{
				path.RemoveAt(0);
			}
			foreach (Vector3 item in path)
			{
				vector2 = item;
			}
			if (path.Count != 0)
			{
				result = path[0].ToGround();
			}
		}
		return result;
	}

	public bool AdvanceNode()
	{
		if (path.Count > 0)
		{
			path.RemoveAt(0);
		}
		if (path.Count == 0)
		{
			return true;
		}
		return false;
	}

	public bool CheckLineOfWalk(Vector3 targetPos, bool checkNoPlayer = false)
	{
		return CheckLineOfWalk(GetPos(), targetPos, checkNoPlayer);
	}

	public bool CheckLineOfWalk(Vector3 pos, Vector3 targetPos, bool checkNoPlayer = false)
	{
		if (MapLoS.LineOfWalk(pos, targetPos, canTraverseCorners: false, checkNoPlayer, canFloat))
		{
			Vector3 direction = targetPos - pos;
			direction.y = 0f;
			float magnitude = direction.magnitude;
			direction /= magnitude;
			if (!Physics.SphereCast(pos + Vector3.up, GetComponent<CapsuleCollider>().radius * radiusFactor, direction, out var _, (targetPos - pos).magnitude, sightMask))
			{
				return true;
			}
		}
		return false;
	}

	public bool CheckLineOfWalkToPlayer(Vector3 playerPos)
	{
		Vector3 pos = GetPos();
		if (!CheckLineOfWalk(pos, playerPos))
		{
			Point point = Map.Get().WorldToCell(pos);
			Point point2 = Map.Get().WorldToCell(playerPos);
			if (Mathf.Abs(point.X - point2.X) <= 1 && Mathf.Abs(point.Y - point2.Y) <= 1)
			{
				bool flag = true;
				if (Mathf.Abs(point.X - point2.X) == 1 && Mathf.Abs(point.Y - point2.Y) == 1)
				{
					Point point3 = new Point(Mathf.Min(point.X, point2.X), Mathf.Min(point.Y, point2.Y));
					Point point4 = new Point(Mathf.Min(point.X, point2.X), Mathf.Max(point.Y, point2.Y));
					Point point5 = new Point(Mathf.Max(point.X, point2.X), Mathf.Min(point.Y, point2.Y));
					Point point6 = new Point(Mathf.Max(point.X, point2.X), Mathf.Max(point.Y, point2.Y));
					if (!canFloat)
					{
						flag = (Map.Get().At(point3).CanWalk() && !Map.Get().At(point3).Occupied) || point3 == point2 || point3 == point;
						flag &= (Map.Get().At(point4).CanWalk() && !Map.Get().At(point4).Occupied) || point4 == point2 || point4 == point;
						flag &= (Map.Get().At(point5).CanWalk() && !Map.Get().At(point5).Occupied) || point5 == point2 || point5 == point;
						flag &= (Map.Get().At(point6).CanWalk() && !Map.Get().At(point6).Occupied) || point6 == point2 || point6 == point;
					}
					else
					{
						flag = (Map.Get().At(point3).CanWalk() && (!Map.Get().At(point3).Occupied || Map.Get().At(point3).CanFloatOver)) || point3 == point2 || point3 == point;
						flag &= (Map.Get().At(point4).CanWalk() && (!Map.Get().At(point4).Occupied || Map.Get().At(point4).CanFloatOver)) || point4 == point2 || point4 == point;
						flag &= (Map.Get().At(point5).CanWalk() && (!Map.Get().At(point5).Occupied || Map.Get().At(point5).CanFloatOver)) || point5 == point2 || point5 == point;
						flag &= (Map.Get().At(point6).CanWalk() && (!Map.Get().At(point6).Occupied || Map.Get().At(point6).CanFloatOver)) || point6 == point2 || point6 == point;
					}
				}
				if (flag && !Map.Get().At(point).IsDoor && Map.Get().At(point).Door == null && !Map.Get().At(point2).IsDoor)
				{
					return true;
				}
			}
			return false;
		}
		return true;
	}

	public void LookAt(Vector3 pos, float turnSpeed)
	{
		Vector3 vector = Vector3Ext.GroundVector(pos, GetPos());
		if (!(vector == Vector3.zero))
		{
			vector.Normalize();
			SetRot(Quaternion.Slerp(GetRot(), Quaternion.LookRotation(vector, Vector3.up), Time.deltaTime * turnSpeed));
		}
	}

	public bool MoveTowards(Vector3 vTarget, float speed, float turnSpeed)
	{
		vTarget = vTarget.ToGround();
		Vector3 vector = GetPos().ToGround();
		Debug.DrawLine(vector + Vector3.up, vTarget + Vector3.up, Color.cyan);
		return MoveTowards(vTarget, vector, speed, turnSpeed);
	}

	public bool MoveTowards(Vector3 vTarget, Vector3 curPos, float speed, float turnSpeed)
	{
		Vector3 vector = vTarget - curPos;
		vector.Normalize();
		SetPos(GetPos() + vector * Time.deltaTime * speed);
		LookAt(vTarget, turnSpeed);
		if (animator != null)
		{
			animator.SetFloat("Speed", speed);
		}
		return CheckNodeInRange(vTarget, curPos);
	}

	public static float GetTraversalCost(Point from, Point end, object movementDesc)
	{
		Map map = Map.Get();
		if (from.X < 0 || from.X >= map.Width || from.Y < 0 || from.Y >= map.Height || end.X < 0 || end.X >= map.Width || end.Y < 0 || end.Y >= map.Height)
		{
			return float.MaxValue;
		}
		if (map.At(end).IsBehindDoor != 0 && ((from.X == end.X && from.Y == end.Y + 1 && map.At(end).IsBehindDoor == AdjacencyCode.CenterBottom) || (from.X == end.X && from.Y == end.Y - 1 && map.At(end).IsBehindDoor == AdjacencyCode.CenterTop) || (from.Y == end.Y && from.X == end.X - 1 && map.At(end).IsBehindDoor == AdjacencyCode.LeftCenter) || (from.Y == end.Y && from.X == end.X + 1 && map.At(end).IsBehindDoor == AdjacencyCode.RightCenter)))
		{
			return 8f;
		}
		return 1f;
	}

	public static float GetTraversalCostIgnoreBehindDoors(Point from, Point end, object movementDesc)
	{
		Map map = Map.Get();
		if (from.X < 0 || from.X >= map.Width || from.Y < 0 || from.Y >= map.Height || end.X < 0 || end.X >= map.Width || end.Y < 0 || end.Y >= map.Height)
		{
			return float.MaxValue;
		}
		return 1f;
	}

	public static bool CheckTraversal(Point from, Point end, object movementDesc)
	{
		Map map = Map.Get();
		if (from.X <= 0 || from.X >= map.Width - 1 || from.Y <= 0 || from.Y >= map.Height - 1 || end.X <= 0 || end.X >= map.Width - 1 || end.Y <= 0 || end.Y >= map.Height - 1)
		{
			return false;
		}
		Cell cell = map.At(end.X, end.Y);
		if (!cell.CanWalk() || (cell.Occupied && cell.Room != null && cell.Door == null && !cell.IsDoor))
		{
			return false;
		}
		if (from.X != end.X && from.Y != end.Y)
		{
			return false;
		}
		return true;
	}

	public static bool CheckTraversalFloater(Point from, Point end, object movementDesc)
	{
		Map map = Map.Get();
		if (from.X <= 0 || from.X >= map.Width - 1 || from.Y <= 0 || from.Y >= map.Height - 1 || end.X <= 0 || end.X >= map.Width - 1 || end.Y <= 0 || end.Y >= map.Height - 1)
		{
			return false;
		}
		Cell cell = map.At(end.X, end.Y);
		if (!cell.CanWalk() || (cell.Occupied && !cell.CanFloatOver && cell.Room != null && cell.Door == null && !cell.IsDoor))
		{
			return false;
		}
		if (from.X != end.X && from.Y != end.Y)
		{
			return false;
		}
		return true;
	}

	protected virtual Vector3 GetPos()
	{
		return base.transform.position;
	}

	protected virtual void SetPos(Vector3 position)
	{
		if (applyFloorNoise)
		{
			base.transform.position = new Vector3(position.x, Map.Get().FloorHeight(position), position.z);
		}
		else
		{
			base.transform.position = position;
		}
	}

	protected virtual Quaternion GetRot()
	{
		return base.transform.rotation;
	}

	protected virtual void SetRot(Quaternion rotation)
	{
		base.transform.rotation = rotation;
	}

	private void OptimizePath()
	{
		tempPath.Clear();
		if (path.Count <= 2)
		{
			return;
		}
		tempPath.Add(path[0]);
		int num = 1;
		int num2 = 0;
		while (num < path.Count)
		{
			if (num - num2 < 5 && CheckLineOfWalk(path[num2], path[num]))
			{
				if (num == path.Count - 1)
				{
					num2 = num;
					tempPath.Add(path[num]);
				}
				num++;
				continue;
			}
			num2 = num - 1;
			tempPath.Add(path[num - 1]);
			if (num == path.Count - 1)
			{
				tempPath.Add(path[num]);
			}
			num++;
		}
		List<Vector3> list = path;
		path = tempPath;
		tempPath = list;
	}

	private bool CheckNodeInRange(Vector3 target, Vector3 curPos)
	{
		Vector3 vector = target - curPos;
		float num = vector.sqrMagnitudeGround();
		if (num <= nodeRangeSq)
		{
			return true;
		}
		if (Vector3.Dot(base.transform.forward, vector) < 0f)
		{
			return num <= backwardsNodeRangeSq;
		}
		return false;
	}
}
public class PathWalkerStopMotion : PathWalker
{
	public StopMotionAnimator stopMotion;

	protected override Vector3 GetPos()
	{
		return stopMotion.position;
	}

	protected override void SetPos(Vector3 position)
	{
		stopMotion.position = position;
	}

	protected override Quaternion GetRot()
	{
		return stopMotion.rotation;
	}

	protected override void SetRot(Quaternion rotation)
	{
		stopMotion.rotation = rotation;
	}
}
public class Prowler : MonoBehaviour
{
	private enum EState
	{
		Prowling,
		Angry,
		Chasing,
		Attacking,
		CoolDown
	}

	public float WalkSpeed = 1f;

	public float WalkTurnSpeed = 1f;

	public float ChaseSpeed = 2f;

	public float ChaseTurnSpeed = 2f;

	public RandomSounds BreathSounds;

	public RandomSounds AngrySounds;

	public float SightDistance = 8f;

	public float SightFOV = 55f;

	public float AttackDistance = 0.15f;

	public AudioClip AngryRoar;

	public string animWalk = "ProwlEv";

	public string animReaction = "Idle_standing";

	public string animIdle = "Idle_standing";

	public string animRun = "gallop";

	public string animAttack = "AttackEv";

	private EState State;

	private Animation meshAnimation;

	private float TimeOut;

	private NavGraph NavGraph;

	private CreatureVisibility visibility;

	private NavNode NextNode;

	private NavNode LastNode;

	private float NextBreath;

	private bool TargetInView;

	private Transform Target;

	private Vector3 LastTargetPosition;

	private NavNode TargetNode;

	private Queue<NavNode> PathToTarget;

	private float MinDistanceToTarget;

	private bool playScareCue = true;

	private float timeInChase;

	private float loseInterest;

	private bool playerMagnet;

	private float standardColliderRadius;

	private float timeInAttack;

	private bool reactivateOnVisible;

	private static List<int> usedSpawns = new List<int>();

	private void Start()
	{
		meshAnimation = base.transform.GetComponentInChildren<Animation>();
		visibility = GetComponent<CreatureVisibility>();
		NavGraph = GameObject.FindWithTag(Tags.NavGraph).GetComponent<NavGraph>();
		standardColliderRadius = GetComponent<CapsuleCollider>().radius;
		PathToTarget = new Queue<NavNode>();
		InitProwling();
	}

	private void Update()
	{
		Transform transform = CheckPlayerInView();
		TargetInView = transform != null;
		if (TargetInView)
		{
			Target = transform;
			LastTargetPosition = transform.position;
		}
		if (loseInterest > 0f)
		{
			loseInterest -= Time.deltaTime;
		}
		if (State == EState.Prowling)
		{
			UpdateProwling();
		}
		else if (State == EState.Angry)
		{
			UpdateAngry();
		}
		else if (State == EState.Chasing)
		{
			UpdateChase();
		}
		else if (State == EState.Attacking)
		{
			UpdateAttack();
		}
		else if (State == EState.CoolDown)
		{
			UpdateCoolDown();
		}
	}

	private void InitProwling()
	{
		State = EState.Prowling;
		meshAnimation.CrossFade(animWalk);
		Collider[] array = Physics.OverlapSphere(base.transform.position, Map.Get().TileSize.x * 0.5f);
		Collider[] array2 = array;
		foreach (Collider collider in array2)
		{
			NavNode component = collider.GetComponent<NavNode>();
			if (component != null)
			{
				NextNode = (LastNode = component);
				break;
			}
		}
		AngrySounds.Playing = false;
		BreathSounds.Playing = true;
		playScareCue = true;
	}

	private void UpdateProwling()
	{
		if ((NextNode.transform.position - base.transform.position).sqrMagnitudeGround() <= 0.25f)
		{
			NavNode nextNode = NextNode;
			float value = UnityEngine.Random.value;
			bool flag = visibility.Hidden && value <= 0.05f;
			bool flag2 = !flag && visibility.Hidden && value <= 0.125f;
			if (flag)
			{
				NextNode = LastNode;
			}
			else if (flag2)
			{
				InitCoolDown(UnityEngine.Random.Range(4f, 14f), activateVisible: true);
			}
			else if (NextNode.Neighbours.Count > 0)
			{
				List<Pair<NavNode, int>> list = new List<Pair<NavNode, int>>();
				foreach (NavNode neighbour in nextNode.Neighbours)
				{
					if (!(neighbour == LastNode) || nextNode.Neighbours.Count <= 1)
					{
						int second = 100;
						Vector3 rhs = neighbour.transform.position - nextNode.transform.position;
						rhs.Normalize();
						float num = Vector3.Dot(base.transform.forward, rhs);
						if (num < -0.1f)
						{
							second = 1;
						}
						list.Add(new Pair<NavNode, int>(neighbour, second));
					}
				}
				NextNode = RandomExt.WeightedChoice(list);
			}
			LastNode = nextNode;
		}
		Vector3 vector = NextNode.transform.position - base.transform.position;
		vector.Normalize();
		Vector3 position = base.transform.position + vector * Time.deltaTime * WalkSpeed;
		if (!visibility.Hidden)
		{
			position.y = Map.Get().FloorHeight(position);
		}
		base.transform.position = position;
		base.transform.rotation = Quaternion.Slerp(base.transform.rotation, Quaternion.LookRotation(vector, Vector3.up), Time.deltaTime * WalkTurnSpeed);
		if (TargetInView)
		{
			InitAngry();
		}
	}

	private void InitAngry()
	{
		State = EState.Angry;
		meshAnimation.CrossFade(animReaction);
		TimeOut = 2f;
		MinDistanceToTarget = standardColliderRadius + Target.GetComponent<CharacterController>().radius + AttackDistance;
		AudioSource.PlayClipAtPoint(AngryRoar, base.transform.position);
		if (playScareCue)
		{
			Target.GetComponent<SpookSounds>().PlayScare(intense: true);
			playScareCue = false;
		}
		Jukebox.Get().SetIntense();
	}

	private void UpdateAngry()
	{
		Vector3 vec = LastTargetPosition - base.transform.position;
		vec = vec.GroundNormalize();
		base.transform.rotation = Quaternion.Slerp(base.transform.rotation, Quaternion.LookRotation(vec, Vector3.up), Time.deltaTime * WalkTurnSpeed);
		TimeOut -= Time.deltaTime;
		if (TimeOut <= 0f)
		{
			InitChase();
		}
	}

	private void InitChase()
	{
		State = EState.Chasing;
		meshAnimation.CrossFade(animRun);
		TargetNode = null;
		AngrySounds.Playing = true;
		BreathSounds.Playing = false;
		timeInChase = 0f;
	}

	private void UpdateChase()
	{
		Jukebox.Get().SetIntense();
		timeInChase += Time.deltaTime;
		NavNode closestNode = NavGraph.GetClosestNode(LastTargetPosition);
		if (TargetNode == null || closestNode.name != TargetNode.name)
		{
			TargetNode = closestNode;
			if (!NavGraph.SearchPath(NextNode, TargetNode, PathToTarget))
			{
				if (timeInChase <= 0.5f)
				{
					loseInterest = 6f;
				}
				InitAttack();
				return;
			}
			PathToTarget.Enqueue(closestNode);
			NextNode = PathToTarget.Dequeue();
		}
		if ((NextNode.transform.position - base.transform.position).sqrMagnitude <= 0.25f)
		{
			LastNode = NextNode;
			if (PathToTarget.Count <= 0)
			{
				if (timeInChase <= 0.5f)
				{
					loseInterest = 6f;
				}
				InitAttack();
				return;
			}
			NextNode = PathToTarget.Dequeue();
		}
		Vector3 vector = NextNode.transform.position - base.transform.position;
		vector.Normalize();
		Vector3 position = base.transform.position + vector * Time.deltaTime * ChaseSpeed;
		if (!visibility.Hidden)
		{
			position.y = Map.Get().FloorHeight(position);
		}
		base.transform.position = position;
		base.transform.rotation = Quaternion.Slerp(base.transform.rotation, Quaternion.LookRotation(vector.GroundNormalize(), Vector3.up), Time.deltaTime * ChaseTurnSpeed);
		Vector3 vector2 = Target.position - base.transform.position;
		vector2.y = 0f;
		if (vector2.sqrMagnitudeGround() <= MinDistanceToTarget * MinDistanceToTarget)
		{
			vector2.Normalize();
			Vector3 position2 = Target.position - vector2 * MinDistanceToTarget;
			position2.y = Map.Get().FloorHeight(position2);
			base.transform.position = position2;
			if (timeInChase <= 0.5f)
			{
				loseInterest = 6f;
			}
			InitAttack();
		}
		if (PathToTarget.Count <= 0)
		{
			return;
		}
		foreach (NavNode item in PathToTarget)
		{
			Debug.DrawLine(item.transform.position, item.transform.position + Vector3.up * 3f, Color.red);
		}
	}

	private void InitAttack()
	{
		State = EState.Attacking;
		if (CheckPlayerInView(bIgnoreFOV: true) == null && visibility.Hidden)
		{
			InitCoolDown(6f, activateVisible: true);
		}
		meshAnimation.CrossFade(animAttack);
		CapsuleCollider component = GetComponent<CapsuleCollider>();
		component.radius = Target.GetComponent<CharacterController>().radius + AttackDistance;
		component.height *= 2f;
		timeInAttack = 0f;
		playerMagnet = true;
	}

	private void UpdateAttack()
	{
		Vector3 vector = Target.position - base.transform.position;
		vector.y = 0f;
		if (!TargetInView && visibility.Hidden)
		{
			CapsuleCollider component = GetComponent<CapsuleCollider>();
			component.radius = standardColliderRadius;
			component.height /= 2f;
			InitCoolDown(6f, activateVisible: true);
			return;
		}
		if (vector.sqrMagnitude <= 9f)
		{
			Jukebox.Get().SetIntense();
			vector.Normalize();
			Vector3 vector2 = Target.position - vector * MinDistanceToTarget;
			vector2.y = Map.Get().FloorHeight(vector2);
			float num = Vector3.Dot(base.transform.forward, (vector2 - base.transform.position).GroundNormalize());
			if (num >= 0.7f && playerMagnet)
			{
				base.transform.position = vector2;
				Player.GetController().ForceTired();
			}
			base.transform.rotation = Quaternion.Slerp(base.transform.rotation, Quaternion.LookRotation(vector.GroundNormalize(), Vector3.up), Time.deltaTime * ChaseTurnSpeed);
		}
		else
		{
			base.transform.rotation = Quaternion.Slerp(base.transform.rotation, Quaternion.LookRotation(vector.GroundNormalize(), Vector3.up), Time.deltaTime * ChaseTurnSpeed);
		}
		timeInAttack += Time.deltaTime;
		if (!(timeInAttack >= 4f))
		{
			return;
		}
		CapsuleCollider component2 = GetComponent<CapsuleCollider>();
		component2.radius = standardColliderRadius;
		component2.height /= 2f;
		playerMagnet = false;
		if (loseInterest > 0f)
		{
			if (visibility.Hidden)
			{
				InitCoolDown(6f, activateVisible: true);
			}
			else
			{
				InitProwling();
			}
		}
		else
		{
			InitAngry();
		}
	}

	private void DoAttack()
	{
		Vector3 vector = Target.position - base.transform.position;
		vector.y = 0f;
		if (vector.sqrMagnitude <= 9f)
		{
			Target.GetComponent<PlayerGameController>().ApplyAttack(2f, "GAMEOVER_PROWLER");
		}
	}

	private void SetPlayerMagnet(bool active)
	{
		playerMagnet = active;
	}

	private void InitCoolDown(float duration = 6f, bool activateVisible = false)
	{
		State = EState.CoolDown;
		meshAnimation.CrossFade(animIdle);
		reactivateOnVisible = activateVisible;
		TimeOut = duration;
		AngrySounds.Playing = false;
		BreathSounds.Playing = false;
	}

	private void UpdateCoolDown()
	{
		TimeOut -= Time.deltaTime;
		if (TargetInView || CheckVisible())
		{
			InitAngry();
		}
		else if (TimeOut < 0f)
		{
			if (visibility.Hidden && UnityEngine.Random.value <= 0.65f && GetSpawnPoint(out var vSpawn, NavGraph, checkVisibility: true))
			{
				base.transform.position = vSpawn;
			}
			InitProwling();
		}
		else if (reactivateOnVisible && !visibility.Hidden)
		{
			InitProwling();
		}
	}

	private Transform CheckPlayerInView(bool bIgnoreFOV = false)
	{
		if (loseInterest > 0f)
		{
			return null;
		}
		float num = SightDistance * ((State != 0) ? 2f : 1f);
		if (!bIgnoreFOV)
		{
			Quaternion quaternion = Quaternion.AngleAxis(SightFOV / 2f, Vector3.up);
			Quaternion quaternion2 = Quaternion.AngleAxis((0f - SightFOV) / 2f, Vector3.up);
			Vector3 vector = quaternion * base.transform.forward;
			Vector3 vector2 = quaternion2 * base.transform.forward;
			Debug.DrawLine(base.transform.position, base.transform.position + vector * num, Color.magenta);
			Debug.DrawLine(base.transform.position, base.transform.position + vector2 * num, Color.magenta);
			Debug.DrawLine(base.transform.position + vector * num, base.transform.position + vector2 * num, Color.magenta);
		}
		Vector3 pos = Player.GetPos();
		Vector3 rhs = pos - base.transform.position;
		float sqrMagnitude = rhs.sqrMagnitude;
		if (sqrMagnitude <= num * num)
		{
			rhs.Normalize();
			float num2 = Vector3.Dot(base.transform.forward, rhs);
			float num3 = Mathf.Cos((float)Math.PI / 180f * SightFOV / 2f);
			if ((bIgnoreFOV || num2 > num3 || sqrMagnitude <= 16f) && (!Physics.Linecast(base.transform.position + Vector3.up, pos + Vector3.up, out var hitInfo) || hitInfo.collider.gameObject.CompareTag(Tags.Player) || hitInfo.collider.gameObject == base.gameObject))
			{
				return Player.Get().transform;
			}
		}
		return null;
	}

	private bool CheckVisible()
	{
		VisibilityProbe probe = Map.Get().At(base.transform.position).Probe;
		if (probe != null && probe.IsVisible)
		{
			return true;
		}
		probe = Map.Get().At(base.transform.position + base.transform.forward).Probe;
		if (probe != null && probe.IsVisible)
		{
			return true;
		}
		probe = Map.Get().At(base.transform.position - base.transform.forward).Probe;
		if (probe != null && probe.IsVisible)
		{
			return true;
		}
		return false;
	}

	private static bool GetSpawnPoint(out Vector3 vSpawn, NavGraph navGraph, bool checkVisibility = false)
	{
		usedSpawns.Clear();
		int num = 10;
		while (num-- > 0)
		{
			int num2 = UnityEngine.Random.Range(0, navGraph.SpawnPositions.Count);
			if (!usedSpawns.Contains(num2))
			{
				usedSpawns.Add(num2);
				vSpawn = navGraph.SpawnPositions[num2].position;
				if (!checkVisibility || !MapChunk.At(Map.Get().WorldToCell(vSpawn)).Visible)
				{
					return true;
				}
			}
		}
		vSpawn = Vector3.zero;
		return false;
	}
}
public class ShadowChaser : FSMComponent<ShadowChaser.States>
{
	public enum States
	{
		Hidden,
		Raise_Idle,
		Raise,
		Idle,
		Idle_Distort,
		Chase_Stretch_In,
		Chase_Stretch_Out,
		Go_Under_Door,
		Disappearing,
		Destroying
	}

	private VisibilityProbe probe;

	private Transform playerLook;

	private AnimWarper animWarper;

	private Animator animator;

	private PathWalker pathWalker;

	private CreatureVisibility cVisibility;

	public ParticleSystem groundSmoke;

	public Material solidMaterial;

	public Material transparentMaterial;

	private bool hasTransparentMaterial = true;

	private float materialAlpha = 1f;

	public bool raiseFast;

	public bool isVision;

	public bool isAngry;

	public bool superAggressive;

	private bool discovered;

	public float chaseSpeed = 1f;

	public float chaseTurnSpeed = 1f;

	private Vector3 stretchOrigin;

	private Vector3 stretchDest;

	private float stretchFactor;

	private const float stretchInSpeed = 4.7f;

	private const float stretchOutSpeed = 1.6f;

	private Vector3 originalCurveDir;

	private Vector3 newCurveDir;

	private float originalCurveIntensity;

	private float newCurveIntensity;

	private float originalNarrowFactor;

	private float newNarrowFactor;

	private const float timeFactor = 0.5f;

	private float timeIdle;

	public AudioSource chaseSound;

	public AudioClip[] chaseSoundClips;

	public AudioClip[] distortClips;

	public SoundLoop raiseSound;

	public SoundLoop whisperSound;

	private MusicMoodSetter moodSetter;

	private float timer;

	private void Start()
	{
		probe = Map.Get().At(base.transform.position).Probe;
		playerLook = Player.GetLook();
		animWarper = GetComponent<AnimWarper>();
		animator = GetComponent<Animator>();
		pathWalker = GetComponent<PathWalker>();
		cVisibility = GetComponent<CreatureVisibility>();
		moodSetter = GetComponent<MusicMoodSetter>();
		Init(States.Hidden);
	}

	private void Hidden_Enter()
	{
		raiseFast = false;
		if (isAngry)
		{
			raiseFast = true;
		}
		float value = UnityEngine.Random.value;
		animWarper.curveDirection = GetNewCurveDir(base.transform.position);
		LookAtPlayer();
		timer = UnityEngine.Random.Range(8f, 16f);
		if (!probe.IsVisible && value <= 0.5f)
		{
			animWarper.verticalCollapse = 0f;
			base.State = States.Idle;
			SetBodyAlpha(1f);
		}
		else if (!probe.IsVisible && value <= 0.8f)
		{
			animWarper.verticalCollapse = 1f - UnityEngine.Random.Range(0.3f, 0.5f);
			SetBodyAlpha(1f);
		}
		else
		{
			SetBodyAlpha(0f);
		}
		Room room = Map.Get().At(base.transform.position).Room;
		if (room != null && room.PlayerInside)
		{
			value = UnityEngine.Random.value;
			if (value <= 0.2f)
			{
				Jukebox.Get().PlaySilence();
			}
			else if (value <= 0.4f && !superAggressive)
			{
				moodSetter.tension = true;
			}
		}
	}

	private void Hidden_Update()
	{
		if (probe.IsVisible)
		{
			if (UnityEngine.Random.value <= 0.7f && !raiseFast)
			{
				base.State = States.Raise_Idle;
			}
			else
			{
				base.State = States.Raise;
			}
			return;
		}
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Disappearing;
		}
	}

	private void Raise_Idle_Enter()
	{
		timer = UnityEngine.Random.Range(1.5f, 3.5f) * 0.5f;
	}

	private void Raise_Idle_Update()
	{
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Raise;
		}
		AddBodyAlpha(Time.deltaTime * 0.15f);
		animator.speed = 1f - animWarper.verticalCollapse;
		UpdateHeadTracking();
	}

	private void Raise_Enter()
	{
		groundSmoke.enableEmission = false;
		if (discovered || UnityEngine.Random.value <= 0.6f)
		{
			raiseSound.targetVolume = 1f;
		}
		whisperSound.targetVolume = 0f;
	}

	private void Raise_Update()
	{
		float num = 0.1f * ((!raiseFast) ? 1.5f : 2f) * ((!superAggressive) ? 1f : 2f);
		animWarper.verticalCollapse -= Time.deltaTime * num;
		animWarper.verticalCollapse = Mathf.Clamp01(animWarper.verticalCollapse);
		if (animWarper.verticalCollapse <= 0f)
		{
			base.State = States.Idle;
		}
		AddBodyAlpha(Time.deltaTime * 0.25f * ((!raiseFast) ? 1f : 2f) * ((!superAggressive) ? 1f : 2f));
		animator.speed = 1f - animWarper.verticalCollapse;
		UpdateHeadTracking();
		if (UpdateDiscovered())
		{
			raiseSound.targetVolume = 1f;
		}
	}

	private void Raise_Exit()
	{
		raiseSound.targetVolume = 0f;
	}

	private void Idle_Enter()
	{
		groundSmoke.enableEmission = false;
		timer = UnityEngine.Random.Range(2f, 4f) * 0.5f;
		animator.speed = 1f;
		whisperSound.targetVolume = ((!(UnityEngine.Random.value <= 0.75f)) ? 0f : 1f);
		if (!superAggressive)
		{
			moodSetter.tension = true;
		}
		timeIdle = 0f;
	}

	private void Idle_Update()
	{
		bool flag = false;
		bool hidden = cVisibility.Hidden;
		timer -= Time.deltaTime;
		timeIdle += Time.deltaTime;
		if (timer <= 0f)
		{
			float value = UnityEngine.Random.value;
			if (!isAngry && !isVision)
			{
				Cell cell = Map.Get().At(base.transform.position);
				flag = !hidden && IsPlayerVisible();
				bool flag2 = cell.Room != null && cell.Room.PlayerInside;
				if (value <= 0.1f || (!flag && !flag2 && timeIdle > 15f))
				{
					base.State = States.Disappearing;
				}
				else if (value <= 0.4f && flag && discovered)
				{
					base.State = States.Chase_Stretch_In;
				}
				else if (value <= 0.6f && cell.IsVisible())
				{
					base.State = States.Idle_Distort;
				}
				else
				{
					timer = UnityEngine.Random.Range(2f, 6f) * 0.5f;
					whisperSound.targetVolume = ((!(UnityEngine.Random.value <= 0.65f)) ? 0f : 1f);
				}
			}
			else if (isAngry && !superAggressive)
			{
				if (hidden && value <= 0.4f)
				{
					base.State = States.Disappearing;
				}
				else if (value <= 0.05f)
				{
					base.State = States.Disappearing;
				}
				else if (value <= 0.25f)
				{
					base.State = States.Idle_Distort;
				}
				else if (value <= 0.85f)
				{
					base.State = States.Chase_Stretch_In;
				}
				else
				{
					timer = UnityEngine.Random.Range(1f, 3f) * 0.5f;
					whisperSound.targetVolume = ((!(UnityEngine.Random.value <= 0.65f)) ? 0f : 1f);
				}
			}
			else if (isAngry && superAggressive)
			{
				if (value <= 0.25f)
				{
					base.State = States.Idle_Distort;
				}
				else if (value <= 0.85f)
				{
					base.State = States.Chase_Stretch_In;
				}
				else
				{
					timer = UnityEngine.Random.Range(0.5f, 1.5f) * 0.5f;
					whisperSound.targetVolume = ((!(UnityEngine.Random.value <= 0.65f)) ? 0f : 1f);
				}
			}
			else if (isVision)
			{
				Cell cell2 = Map.Get().At(base.transform.position);
				flag = !hidden && IsPlayerVisible();
				if (value <= 0.4f)
				{
					base.State = States.Disappearing;
				}
				else if (value <= 0.6f && cell2.IsVisible())
				{
					base.State = States.Idle_Distort;
				}
				else
				{
					timer = UnityEngine.Random.Range(1f, 4f);
					whisperSound.targetVolume = ((!(UnityEngine.Random.value <= 0.65f)) ? 0f : 1f);
				}
			}
		}
		UpdateHeadTracking(flag);
		UpdateDiscovered();
	}

	private void Idle_Distort_Enter()
	{
		stretchFactor = 0f;
		animator.speed = 1f;
		originalCurveDir = animWarper.curveDirection;
		if (UnityEngine.Random.value <= 0.5f)
		{
			newCurveDir = GetNewCurveDir(base.transform.position);
		}
		else
		{
			newCurveDir = originalCurveDir;
		}
		chaseSound.Stop();
		chaseSound.clip = RandomExt.Choice(distortClips);
		chaseSound.Play();
	}

	private void Idle_Distort_Update()
	{
		stretchFactor = Mathf.Clamp01(stretchFactor + Time.deltaTime * 4.7f);
		float t = Interpolate.EaseOut(stretchFactor);
		float num = stretchFactor * 2f;
		if (num > 1f)
		{
			num = 2f - num;
		}
		num = Interpolate.EaseOut(Mathf.Clamp01(num));
		animWarper.bodyRenderer.material.SetFloat("_DistortFactor", num * 0.45f + Mathf.PerlinNoise(0f, Time.time * 20f) * num * 0.1f);
		animWarper.curveDirection = Vector3.Slerp(originalCurveDir, newCurveDir, t);
		animWarper.verticalCollapse -= Time.deltaTime * 3f;
		animWarper.verticalCollapse = Mathf.Clamp01(animWarper.verticalCollapse);
		if (stretchFactor >= 1f)
		{
			base.State = States.Idle;
		}
		pathWalker.LookAt(Player.GetPos(), chaseTurnSpeed * 20f);
	}

	private void Chase_Stretch_In_Enter()
	{
		pathWalker.Reset();
		pathWalker.ClearPath();
		Vector3 groundPos = Player.GetGroundPos();
		Vector3 toPosGround = Player.GetToPosGround(base.transform.position);
		Vector3 vector = Vector3.zero;
		if (pathWalker.CheckLineOfWalkToPlayer(groundPos))
		{
			vector = toPosGround;
			if (!isAngry)
			{
				vector /= 2f;
			}
		}
		else
		{
			Point closestWalkable = Map.Get().GetClosestWalkable(groundPos);
			if (pathWalker.SetPath(closestWalkable))
			{
				if (cVisibility.Hidden && isAngry && UnityEngine.Random.value <= 0.7f)
				{
					for (int num = pathWalker.path.Count - 1; num > 0; num--)
					{
						Vector3 vector2 = pathWalker.path[num];
						if (!Map.Get().At(vector2).IsVisible())
						{
							base.transform.position = Map.Get().CellToWorld(Map.Get().WorldToCell(vector2));
							base.State = States.Idle;
							return;
						}
					}
				}
				bool flag = false;
				for (int i = 0; i < pathWalker.path.Count; i++)
				{
					if (flag)
					{
						break;
					}
					Vector3 vector3 = pathWalker.path[i];
					if (Map.Get().At(vector3).DoorSide != 0)
					{
						vector3 = Map.Get().CellToWorld(Map.Get().WorldToCell(vector3));
					}
					vector = (vector3 - base.transform.position).ToGround();
					if (vector.sqrMagnitude >= 0.36f)
					{
						flag = true;
					}
				}
				if (!flag)
				{
					vector = toPosGround;
				}
				pathWalker.ClearPath();
			}
			else
			{
				base.State = States.Idle;
			}
		}
		Vector3 normalized = vector.normalized;
		float magnitude = vector.magnitude;
		float num2 = ((!isAngry) ? 2f : ((!(UnityEngine.Random.value <= 0.7f)) ? 4f : 2f));
		if (magnitude > num2)
		{
			vector = normalized * num2;
		}
		stretchOrigin = base.transform.position.ToGround();
		stretchDest = stretchOrigin + vector;
		SetStretchVector(-normalized);
		stretchFactor = 0f;
		originalCurveDir = animWarper.curveDirection;
		newCurveDir = GetNewCurveDir(stretchDest);
		bool flag2 = CheckNarrow(stretchDest);
		originalNarrowFactor = animator.GetFloat("Narrow");
		newNarrowFactor = ((!flag2) ? 0f : 1f);
		originalCurveIntensity = animWarper.curveIntensity;
		newCurveIntensity = ((!flag2) ? UnityEngine.Random.Range(0.7f, 1f) : UnityEngine.Random.Range(0.2f, 0.5f));
		Door doorBetweenTiles = Map.Get().GetDoorBetweenTiles(Map.Get().WorldToCell(stretchOrigin), Map.Get().WorldToCell(stretchDest));
		if (doorBetweenTiles != null && !doorBetweenTiles.IsOpen)
		{
			base.State = States.Go_Under_Door;
		}
		else if (!cVisibility.Hidden || Map.Get().At(stretchOrigin).IsVisible() || Map.Get().At(stretchDest).IsVisible() || UnityEngine.Random.value <= 0.5f)
		{
			chaseSound.Stop();
			chaseSound.clip = RandomExt.Choice(chaseSoundClips);
			chaseSound.Play();
		}
		isAngry = isAngry || UnityEngine.Random.value <= 0.6f;
	}

	private void Chase_Stretch_In_Update()
	{
		stretchFactor = Mathf.Clamp01(stretchFactor + Time.deltaTime * 4.7f);
		float num = Interpolate.EaseOut(stretchFactor);
		Vector3 position = Vector3.Lerp(stretchOrigin, stretchDest, num);
		base.transform.position = position;
		SetStretchFactor((stretchDest - stretchOrigin).magnitude * num);
		animWarper.bodyRenderer.material.SetFloat("_DistortFactor", num * 0.45f + Mathf.PerlinNoise(0f, Time.time * 20f) * num * 0.1f);
		animWarper.curveDirection = Vector3.Slerp(originalCurveDir, newCurveDir, num);
		animator.SetFloat("Narrow", Mathf.Lerp(originalNarrowFactor, newNarrowFactor, num));
		animWarper.curveIntensity = Mathf.Lerp(originalCurveIntensity, newCurveIntensity, num);
		if (stretchFactor >= 1f)
		{
			base.State = States.Chase_Stretch_Out;
		}
		pathWalker.LookAt(Player.GetPos(), chaseTurnSpeed * 2f);
		if ((Player.GroundPos - base.transform.position.ToGround()).sqrMagnitude <= 0.80999994f)
		{
			Player.GetController().ApplyAttack(2f, "GAMEOVER_SHADOW", 6f);
		}
	}

	private void Chase_Stretch_Out_Update()
	{
		stretchFactor = Mathf.Clamp01(stretchFactor - Time.deltaTime * 1.6f);
		float num = Interpolate.EaseOut(stretchFactor);
		SetStretchFactor((stretchDest - stretchOrigin).magnitude * num);
		float num2 = Interpolate.EaseOut(Mathf.Clamp01(stretchFactor * 2f - 1f));
		animWarper.bodyRenderer.material.SetFloat("_DistortFactor", num2 * 0.45f + Mathf.PerlinNoise(0f, Time.time * 20f) * num2 * 0.1f);
		if (stretchFactor <= 0f)
		{
			base.State = States.Idle;
		}
		pathWalker.LookAt(Player.GetPos(), chaseTurnSpeed);
	}

	private void Go_Under_Door_Enter()
	{
		stretchDest = Map.Get().CellToWorld(Map.Get().WorldToCell(stretchDest));
		animWarper.verticalCollapse = 1f;
		groundSmoke.enableEmission = true;
		animator.speed = 1f - animWarper.verticalCollapse;
		stretchFactor = 0f;
		raiseFast = true;
		whisperSound.targetVolume = 0f;
	}

	private void Go_Under_Door_Update()
	{
		stretchFactor = Mathf.Clamp01(stretchFactor + Time.deltaTime * 0.25f);
		float t = Interpolate.EaseInOut(stretchFactor);
		Vector3 position = Vector3.Lerp(stretchOrigin, stretchDest, t);
		base.transform.position = position;
		pathWalker.LookAt(Player.GetPos(), chaseTurnSpeed * 2f);
		animator.SetFloat("Narrow", Mathf.Lerp(originalNarrowFactor, newNarrowFactor, t));
		animWarper.curveIntensity = Mathf.Lerp(originalCurveIntensity, newCurveIntensity, t);
		if (stretchFactor >= 1f)
		{
			base.State = States.Raise;
		}
	}

	private void Disappearing_Enter()
	{
		groundSmoke.enableEmission = true;
		if (!cVisibility.Hidden)
		{
			raiseSound.targetVolume = 1f;
		}
		whisperSound.targetVolume = 0f;
		moodSetter.tension = false;
		animWarper.minColliderFactor = 0f;
	}

	private void Disappearing_Update()
	{
		float verticalCollapse = animWarper.verticalCollapse;
		animWarper.verticalCollapse += Time.deltaTime * 0.05f;
		animWarper.verticalCollapse = Mathf.Clamp01(animWarper.verticalCollapse);
		if (verticalCollapse <= 0.4f && animWarper.verticalCollapse > 0.4f && UnityEngine.Random.value <= 0.15f && !cVisibility.Hidden)
		{
			base.State = States.Idle_Distort;
		}
		else if (animWarper.verticalCollapse >= 1f)
		{
			base.State = States.Destroying;
		}
		animator.speed = 1f - animWarper.verticalCollapse;
	}

	private void Disappearing_Exit()
	{
		raiseSound.targetVolume = 0f;
		groundSmoke.enableEmission = false;
		animWarper.minColliderFactor = 0.6f;
	}

	private void Destroying_Enter()
	{
		groundSmoke.enableEmission = false;
		animWarper.minColliderFactor = 0f;
	}

	private void Destroying_Update()
	{
		if (AddBodyAlpha((0f - Time.deltaTime) * 0.5f) <= 0f && groundSmoke.particleCount <= 0)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private Vector3 LookAtPlayer()
	{
		Vector3 vector = Vector3Ext.GroundVector(playerLook.position, base.transform.position);
		vector.Normalize();
		Quaternion rotation = Quaternion.LookRotation(vector, Vector3.up);
		base.transform.rotation = rotation;
		return vector;
	}

	private Vector3 GetNewCurveDir(Vector3 refPosition)
	{
		Vector3 result = originalCurveDir;
		Cell cell = Map.Get().At(refPosition);
		for (int i = 0; i < 8; i++)
		{
			Vector2 insideUnitCircle = UnityEngine.Random.insideUnitCircle;
			Vector3 vector = new Vector3(insideUnitCircle.x, 0f, insideUnitCircle.y);
			bool flag = true;
			if ((Mathf.Abs(vector.x) > Mathf.Abs(vector.z)) ? ((!(vector.x > 0f)) ? (!cell.CheckAdjacency(AdjacencyCode.LeftCenter)) : (!cell.CheckAdjacency(AdjacencyCode.RightCenter))) : ((!(vector.z > 0f)) ? (!cell.CheckAdjacency(AdjacencyCode.CenterBottom)) : (!cell.CheckAdjacency(AdjacencyCode.CenterTop))))
			{
				result = vector;
				break;
			}
		}
		return result;
	}

	private void SetBodyAlpha(float alpha)
	{
		materialAlpha = alpha;
		if (alpha >= 1f && hasTransparentMaterial)
		{
			SetBodyMaterial(solidMaterial);
			hasTransparentMaterial = false;
		}
		else if (alpha < 1f && !hasTransparentMaterial)
		{
			SetBodyMaterial(transparentMaterial);
			hasTransparentMaterial = true;
		}
		Material material = animWarper.bodyRenderer.material;
		material.SetFloat("_Alpha", alpha);
	}

	private float AddBodyAlpha(float deltaAlpha)
	{
		float num = Mathf.Clamp01(materialAlpha + deltaAlpha);
		SetBodyAlpha(num);
		return num;
	}

	private void SetBodyMaterial(Material newMat)
	{
		animWarper.bodyRenderer.material = newMat;
		animWarper.ApplyVerticalCollapse();
	}

	private void SetStretchVector(Vector3 v)
	{
		Transform rootBone = animWarper.bodyRenderer.GetComponent<SkinnedMeshRenderer>().rootBone;
		v = rootBone.transform.InverseTransformDirection(v);
		animWarper.bodyRenderer.material.SetVector("_StretchVector", new Vector4(v.x, v.y, v.z, 0f));
	}

	private void SetStretchFactor(float f)
	{
		animWarper.bodyRenderer.material.SetFloat("_StretchFactor", f);
	}

	private void UpdateHeadTracking(bool playerVisible = false)
	{
		animWarper.headTracking = Interpolate.Approach(animWarper.headTracking, (!playerVisible && !IsPlayerInFront()) ? 0f : 1f, Time.deltaTime * 2f);
	}

	private bool UpdateDiscovered()
	{
		if (!discovered && animWarper.verticalCollapse <= 0.7f && Map.Get().At(base.transform.position).IsVisible())
		{
			discovered = true;
			FearEffect.Get().Scare(jumpScare: true);
			GameController.Get().GetComponent<ShadowFolkManager>().OnChaserDiscovered();
			return true;
		}
		return false;
	}

	private bool IsPlayerVisible()
	{
		return Utils.IsPlayerVisible(base.transform, 190f, checkOnlyAngle: false, 16f, 1f);
	}

	private bool IsPlayerInFront()
	{
		return Utils.IsPlayerVisible(base.transform, 85f, checkOnlyAngle: true, 16f, 1f);
	}

	private bool CheckNarrow(Vector3 pos)
	{
		Cell cell = Map.Get().At(pos);
		return (cell.CheckAdjacency(AdjacencyCode.RightCenter) && cell.CheckAdjacency(AdjacencyCode.LeftCenter)) || (cell.CheckAdjacency(AdjacencyCode.CenterTop) && cell.CheckAdjacency(AdjacencyCode.CenterBottom));
	}
}
public class ShadowCloud : MonoBehaviour
{
	public bool disappearing;

	private float floatingHeight;

	private List<Vector3> path = new List<Vector3>();

	private int idxPath;

	private float interpolationFactor;

	public float speed = 1f;

	public float initWait;

	public ParticleSystem[] trailParticles;

	private void Start()
	{
		floatingHeight = base.transform.position.y;
		if ((path == null || path.Count == 0) && !FindTargetPos(path))
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		for (int i = 0; i < trailParticles.Length; i++)
		{
			trailParticles[i].enableEmission = true;
		}
	}

	private void Update()
	{
		if (initWait > 0f)
		{
			initWait -= Time.deltaTime;
		}
		else if (!disappearing)
		{
			Vector3 vP = ((idxPath != 0) ? path[idxPath - 1] : path[0]);
			Vector3 vP2 = path[idxPath];
			Vector3 vP3 = path[idxPath + 1];
			Vector3 vP4 = ((idxPath != path.Count - 2) ? path[idxPath + 2] : path[idxPath + 1]);
			interpolationFactor = Mathf.Clamp01(interpolationFactor + Time.deltaTime * speed);
			base.transform.position = Interpolate.CatmullRom(vP, vP2, vP3, vP4, interpolationFactor);
			if (!(interpolationFactor >= 1f))
			{
				return;
			}
			interpolationFactor = 0f;
			idxPath++;
			if (idxPath == path.Count - 1)
			{
				disappearing = true;
				for (int i = 0; i < trailParticles.Length; i++)
				{
					trailParticles[i].enableEmission = false;
				}
				UnityEngine.Object.Destroy(base.gameObject, 5f);
			}
		}
		else
		{
			GetComponent<AudioSource>().volume -= Time.deltaTime / 4f;
		}
	}

	private bool FindTargetPos(List<Vector3> outputList)
	{
		outputList.Clear();
		Vector3 pos = Player.GetPos();
		Point point = Map.Get().WorldToCell(base.transform.position);
		Point despawnPos = point;
		List<Point> list = new List<Point>();
		List<Point> list2 = new List<Point>();
		list2.Add(point);
		while (list2.Count > 0)
		{
			int index = UnityEngine.Random.Range(0, list2.Count);
			Point curTile = list2[index];
			list2.RemoveAt(index);
			if (list.Exists((Point e) => e == curTile))
			{
				continue;
			}
			list.Add(curTile);
			Cell cell = Map.Get().At(curTile);
			if (cell == null || !cell.CanWalk())
			{
				continue;
			}
			if ((!cell.Occupied || cell.Room == null || !(cell.Door == null) || cell.IsDoor) && !cell.IsVisible() && !cell.IsDiscovered())
			{
				Debug.DrawLine(Map.Get().CellToWorld(curTile), Map.Get().CellToWorld(curTile) + Vector3.up, Color.yellow, 3f);
				if ((Map.Get().CellToWorld(curTile) - pos).sqrMagnitude > 100f && !cell.CheckLoS(Player.GetCenterEye()))
				{
					Debug.DrawLine(Map.Get().CellToWorld(curTile), Map.Get().CellToWorld(curTile) + Vector3.up * 1.5f, Color.green, 3f);
					despawnPos = curTile;
					break;
				}
			}
			else
			{
				Debug.DrawLine(Map.Get().CellToWorld(curTile), Map.Get().CellToWorld(curTile) + Vector3.up, Color.red, 3f);
			}
			list2.Add(new Point(curTile.X - 1, curTile.Y));
			list2.Add(new Point(curTile.X + 1, curTile.Y));
			list2.Add(new Point(curTile.X, curTile.Y - 1));
			list2.Add(new Point(curTile.X, curTile.Y + 1));
		}
		if (SetTargetPath(despawnPos, outputList))
		{
			return true;
		}
		return false;
	}

	public bool ForceTargetPath(Point despawnPos)
	{
		floatingHeight = base.transform.position.y;
		return SetTargetPath(despawnPos, path);
	}

	private bool SetTargetPath(Point despawnPos, List<Vector3> outputList)
	{
		Point end = Map.Get().WorldToCell(base.transform.position);
		Pathfinder pathfinder = Pathfinder.Get();
		Pathfinder.Query query = pathfinder.AddQuery(despawnPos, end, null, PathWalker.CheckTraversal, PathWalker.GetTraversalCost, null, 0.5f);
		if (pathfinder.RunAStar(query))
		{
			if (query.State == Pathfinder.Query.EState.Success)
			{
				outputList.Add(base.transform.position);
				for (int num = query.Path.Count - 1; num >= 0; num--)
				{
					Vector3 item = Map.Get().CellToWorld(query.Path[num]);
					item += Vector3.up * floatingHeight;
					item += Vector3.up * UnityEngine.Random.Range(-0.4f, 0.4f);
					outputList.Add(item);
				}
				pathfinder.FreeQuery(query);
				return true;
			}
			pathfinder.FreeQuery(query);
		}
		return false;
	}
}
public class ShadowFolkManager : MonoBehaviour
{
	public GameObject[] shadowWatchers;

	public int watcherSpawnRange = 4;

	private float MinWaitWatcherShort = 7f;

	private float MaxWaitWatcherShort = 25f;

	private float MinWaitWatcherLong = 30f;

	private float MaxWaitWatcherLong = 90f;

	public ShadowChaser shadowChaser;

	public int chaserSpawnRange = 6;

	public bool chaserVisions;

	public bool chaserCreatures;

	private float MinWaitChaserShort = 7f;

	private float MaxWaitChaserShort = 25f;

	private float MinWaitChaserLong = 40f;

	private float MaxWaitChaserLong = 130f;

	private float chaserWaitFactor = 1f;

	public bool canSpawnWatchers = true;

	public bool canSpawnChasers = true;

	private void Start()
	{
		LevelOptions levelOptions = GameController.Get().levelOptions;
		if (levelOptions.shadowWatchers)
		{
			float num = UnityEngine.Random.Range(levelOptions.shadowWatchersMinDelay, levelOptions.shadowWatchersMaxDelay);
			if (num > 0f)
			{
				StartCoroutine(DelayedEnableWatchers_co(num));
			}
			StartCoroutine(SpawnWatchers_co());
		}
		chaserCreatures = levelOptions.shadowChasers;
		chaserVisions = levelOptions.shadowChasersVisions;
		if (chaserCreatures || chaserVisions)
		{
			float num2 = UnityEngine.Random.Range(levelOptions.shadowChasersMinDelay, levelOptions.shadowChasersMaxDelay);
			if (num2 > 0f)
			{
				StartCoroutine(DelayedEnableChasers_co(num2));
			}
			StartCoroutine(SpawnChasers_co());
		}
	}

	private IEnumerator SpawnWatchers_co()
	{
		bool bFirst = true;
		while (true)
		{
			if (!canSpawnWatchers)
			{
				yield return new WaitForSeconds(5f);
				continue;
			}
			bool bWaitShort = !bFirst && UnityEngine.Random.value < 0.3f;
			bFirst = false;
			float maxWait = ((!bWaitShort) ? MaxWaitWatcherLong : MaxWaitWatcherShort);
			float minWait = ((!bWaitShort) ? MinWaitWatcherLong : MinWaitWatcherShort);
			float nextWait = UnityEngine.Random.Range(minWait, maxWait);
			yield return new WaitForSeconds(nextWait);
			SpawnWatcher();
		}
	}

	private IEnumerator SpawnChasers_co()
	{
		bool bFirst = true;
		while (true)
		{
			if (!canSpawnChasers)
			{
				yield return new WaitForSeconds(5f);
				continue;
			}
			bool bWaitShort = !bFirst && UnityEngine.Random.value < 0.3f;
			bFirst = false;
			float maxWait = ((!bWaitShort) ? MaxWaitChaserLong : MaxWaitChaserShort);
			float minWait2 = ((!bWaitShort) ? MinWaitChaserLong : MinWaitChaserShort);
			maxWait *= chaserWaitFactor;
			minWait2 *= chaserWaitFactor;
			chaserWaitFactor *= 0.85f;
			chaserWaitFactor = Mathf.Clamp(chaserWaitFactor, 0.1f, 1.5f);
			float nextWait = UnityEngine.Random.Range(minWait2, maxWait);
			yield return new WaitForSeconds(nextWait);
			if (canSpawnChasers)
			{
				bool isVision = false;
				if (chaserVisions && chaserCreatures)
				{
					isVision = UnityEngine.Random.value <= 0.3f;
				}
				else if (chaserVisions)
				{
					isVision = true;
				}
				SpawnChaser(isVision);
			}
		}
	}

	public void OnChaserDiscovered()
	{
		chaserWaitFactor = UnityEngine.Random.Range(1.25f, 2f);
		if (chaserVisions && !chaserCreatures)
		{
			chaserWaitFactor = UnityEngine.Random.Range(1.5f, 1.75f);
		}
		StartCoroutine(DelayedEnableChasers_co(UnityEngine.Random.Range(20f, 60f)));
		StartCoroutine(DelayedEnableWatchers_co(UnityEngine.Random.Range(15f, 30f)));
	}

	public GameObject SpawnWatcher()
	{
		if (Player.IsSafe())
		{
			return null;
		}
		Transform transform = GameObject.FindWithTag(Tags.LookDirection).transform;
		Vector3 groundPos = Player.GetGroundPos();
		Point point = Map.Get().WorldToCell(groundPos);
		List<Pair<Point, int>> list = new List<Pair<Point, int>>();
		for (int i = point.Y - watcherSpawnRange; i <= point.Y + watcherSpawnRange; i++)
		{
			for (int j = point.X - watcherSpawnRange; j <= point.X + watcherSpawnRange; j++)
			{
				if (!Map.Get().InRange(j, i))
				{
					continue;
				}
				Cell cell = Map.Get().At(j, i);
				if (cell.Occupied || !cell.IsClear() || !cell.Probe || cell.IsVisible() || cell.Room == null || cell.Room.Safe || !cell.CheckLoS(transform.position))
				{
					continue;
				}
				int numAdjacentWalls = cell.GetNumAdjacentWalls();
				int num = Math.Abs(j - point.X) + Math.Abs(i - point.Y);
				if (num == 0)
				{
					continue;
				}
				int second = 10;
				if (numAdjacentWalls > 1 || cell.IsDoor || cell.DoorSide != 0)
				{
					second = 60;
				}
				else if (numAdjacentWalls == 1)
				{
					second = 20;
				}
				if (num <= 2)
				{
					second = 5;
					Vector3 vec = Map.Get().CellToWorld(j, i) - groundPos;
					if (vec.sqrMagnitudeGround() <= 1.21f)
					{
						continue;
					}
				}
				list.Add(new Pair<Point, int>(new Point(j, i), second));
			}
		}
		if (list.Count == 0)
		{
			return null;
		}
		Point cellPos = RandomExt.WeightedChoice(list);
		Vector3 vector = Map.Get().CellToWorld(cellPos);
		Vector3 forward = groundPos - vector;
		forward.Normalize();
		return UnityEngine.Object.Instantiate(shadowWatchers[0], vector, Quaternion.LookRotation(forward));
	}

	public GameObject SpawnChaser(bool isVision = false)
	{
		if (Player.IsSafe())
		{
			return null;
		}
		Transform transform = GameObject.FindWithTag(Tags.LookDirection).transform;
		Vector3 groundPos = Player.GetGroundPos();
		Point point = Map.Get().WorldToCell(groundPos);
		List<Pair<Point, int>> list = new List<Pair<Point, int>>();
		for (int i = point.Y - chaserSpawnRange; i <= point.Y + chaserSpawnRange; i++)
		{
			for (int j = point.X - chaserSpawnRange; j <= point.X + chaserSpawnRange; j++)
			{
				if (!Map.Get().InRange(j, i))
				{
					continue;
				}
				Point pos = new Point(j, i);
				Cell cell = Map.Get().At(j, i);
				if (cell.Occupied || !cell.IsClear() || !cell.Probe || (cell.Room != null && cell.Room.Safe) || (cell.Room != null && cell.Room.HasLocalEnemy))
				{
					continue;
				}
				int inRoom = CreatureCounter.GetInRoom(pos);
				if (inRoom > 0)
				{
					int inRoom2 = CreatureCounter.GetInRoom(pos, CreatureCounter.CreatureType.Shadow);
					inRoom -= inRoom2;
					if (inRoom2 > 1 || inRoom > 0)
					{
						continue;
					}
				}
				if (cell.IsDoor || Map.Get().IsReservedDoor(pos))
				{
					continue;
				}
				bool flag = cell.CheckLoS(transform.position);
				if (!flag && UnityEngine.Random.value <= 0.5f)
				{
					continue;
				}
				int numAdjacentWalls = cell.GetNumAdjacentWalls();
				int num = Math.Abs(j - point.X) + Math.Abs(i - point.Y);
				if (num == 0)
				{
					continue;
				}
				int num2 = 0;
				if (cell.Room != null && cell.Room.PlayerInside)
				{
					num2 += 60;
				}
				if (cell.IsVisible())
				{
					num2 += 40;
				}
				else if (flag)
				{
					num2 += 20;
				}
				if (numAdjacentWalls == 0)
				{
					num2 = 10;
				}
				if (num <= 2)
				{
					num2 -= 10;
					Vector3 vec = Map.Get().CellToWorld(j, i) - groundPos;
					if (vec.sqrMagnitudeGround() <= 1.21f)
					{
						continue;
					}
				}
				list.Add(new Pair<Point, int>(new Point(j, i), num2));
			}
		}
		if (list.Count == 0)
		{
			return null;
		}
		Point cellPos = RandomExt.WeightedChoice(list);
		Vector3 position = Map.Get().CellToWorld(cellPos);
		ShadowChaser shadowChaser = UnityEngine.Object.Instantiate(this.shadowChaser, position, Quaternion.identity);
		shadowChaser.isVision = isVision;
		return shadowChaser.gameObject;
	}

	private IEnumerator DelayedEnableWatchers_co(float delayTime)
	{
		canSpawnWatchers = false;
		yield return new WaitForSeconds(delayTime);
		canSpawnWatchers = true;
	}

	private IEnumerator DelayedEnableChasers_co(float delayTime)
	{
		canSpawnChasers = false;
		yield return new WaitForSeconds(delayTime);
		canSpawnChasers = true;
	}
}
public class ShadowWatcher : FSMComponent<ShadowWatcher.States>
{
	public enum States
	{
		Hidden,
		InPeriphery,
		InFullView,
		Disappearing,
		Destroying
	}

	public SpookEvent lightFlicker;

	private VisibilityProbe probe;

	private Transform playerLook;

	private SpookSounds spookSounds;

	private RandomSounds randomSounds;

	private ParticleSystem[] particles;

	public Renderer body;

	public Renderer eyes;

	public Animator animator;

	[Range(0f, 1f)]
	public float narrowFactor;

	private bool longDisappear;

	private bool soundOnStart;

	private float timer;

	public bool infiniteTimer;

	private void Start()
	{
		Init(States.Hidden);
	}

	private void Hidden_Enter()
	{
		probe = Map.Get().At(base.transform.position).Probe;
		playerLook = Player.GetLook();
		randomSounds = GetComponent<RandomSounds>();
		spookSounds = Player.GetComponent<SpookSounds>();
		particles = GetComponentsInChildren<ParticleSystem>();
		if (body == null)
		{
			body = base.transform.Find("shadowfolk_body").GetComponent<Renderer>();
		}
		if (eyes == null)
		{
			eyes = base.transform.Find("shadowfolk_eyes").GetComponent<Renderer>();
		}
		longDisappear = UnityEngine.Random.value <= 0.3f;
		soundOnStart = UnityEngine.Random.value <= 0.3f;
		if (soundOnStart)
		{
			randomSounds.PlayNow();
		}
		else
		{
			randomSounds.Playing = false;
		}
		if (UnityEngine.Random.value <= 0.4f)
		{
			Jukebox.Get().PlaySilence();
		}
		timer = UnityEngine.Random.Range(8f, 16f);
		if ((bool)animator)
		{
			animator.SetFloat("Narrow", narrowFactor);
		}
	}

	private void Hidden_Update()
	{
		LookAtPlayer();
		if (probe.IsVisible)
		{
			base.State = States.InPeriphery;
		}
		else if (!infiniteTimer)
		{
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				base.State = States.Disappearing;
			}
		}
	}

	private void InPeriphery_Enter()
	{
		if (UnityEngine.Random.value <= 0.3f)
		{
			base.State = States.Disappearing;
		}
		randomSounds.Playing = true;
		if (!soundOnStart && UnityEngine.Random.value <= 0.5f)
		{
			randomSounds.PlayNow();
		}
	}

	private void InPeriphery_Update()
	{
		Vector3 vector = LookAtPlayer();
		if (!probe.IsVisible)
		{
			base.State = States.Disappearing;
			return;
		}
		Vector3 forward = playerLook.forward;
		forward.Normalize();
		float num = Vector3.Angle(forward, -vector);
		if (num < 35f)
		{
			base.State = States.InFullView;
		}
	}

	private void InFullView_Enter()
	{
		if (UnityEngine.Random.value <= 0.3f)
		{
			timer = UnityEngine.Random.Range(2f, 4f);
			SpookManager.Get().PlayEvent(lightFlicker);
			longDisappear = true;
			eyes.enabled = false;
			spookSounds.PlayScare();
		}
		else
		{
			timer = UnityEngine.Random.Range(0.1f, 2f);
			if (UnityEngine.Random.value <= 0.5f)
			{
				spookSounds.PlayScare();
			}
			else
			{
				FearEffect.Get().Scare(jumpScare: true);
			}
		}
	}

	private void InFullView_Update()
	{
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Disappearing;
		}
	}

	private void Disappearing_Enter()
	{
		randomSounds.Playing = false;
		eyes.enabled = false;
		for (int i = 0; i < particles.Length; i++)
		{
			particles[i].enableEmission = false;
		}
	}

	private void Disappearing_Update()
	{
		float @float = body.material.GetFloat("_Alpha");
		@float -= 2f * Time.deltaTime;
		body.material.SetFloat("_Alpha", @float);
		int num = 0;
		for (int i = 0; i < particles.Length; i++)
		{
			num += particles[i].particleCount;
			if (!longDisappear)
			{
			}
		}
		if (num == 0)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private Vector3 LookAtPlayer()
	{
		Vector3 vector = Vector3Ext.GroundVector(playerLook.position, base.transform.position);
		vector.Normalize();
		Quaternion rotation = Quaternion.LookRotation(vector, Vector3.up);
		base.transform.rotation = rotation;
		return vector;
	}
}
public class SoundLoop : MonoBehaviour
{
	public AudioSource source;

	public float targetVolume;

	private float curVolume;

	private void Start()
	{
		curVolume = source.volume;
		source.volume = targetVolume;
		if (targetVolume <= 0f && source.isPlaying)
		{
			source.Stop();
		}
		else if (targetVolume > 0f && !source.isPlaying)
		{
			source.Play();
		}
	}

	private void Update()
	{
		source.volume = Interpolate.Approach(source.volume, targetVolume, Time.deltaTime * 3f);
		if (!source.isPlaying && source.volume > 0.01f)
		{
			source.Play();
		}
		else if (source.isPlaying && source.volume <= 0.01f)
		{
			source.Stop();
		}
	}
}
public class StopMotionAnimator : MonoBehaviour
{
	public float framesPerSecond = 15f;

	private float timeLastFrame;

	private Animation meshAnimation;

	private AnimationState currentAnim;

	private AnimationState prevAnim;

	private float fadeLength;

	private float fadeTime;

	public Vector3 position;

	public Quaternion rotation;

	public bool controlPosition = true;

	public void Play(string animName)
	{
		currentAnim.enabled = false;
		currentAnim.weight = 0f;
		currentAnim = meshAnimation[animName];
		currentAnim.time = 0f;
		currentAnim.weight = 1f;
	}

	public void CrossFade(string animName, float fadeLength)
	{
		prevAnim = currentAnim;
		prevAnim.weight = 1f;
		currentAnim = meshAnimation[animName];
		currentAnim.time = 0f;
		currentAnim.weight = 0f;
		this.fadeLength = fadeLength;
		fadeTime = 0f;
	}

	private void Awake()
	{
		meshAnimation = base.transform.GetComponentInChildren<Animation>();
		currentAnim = meshAnimation[meshAnimation.clip.name];
		meshAnimation.Stop();
	}

	private void Start()
	{
		position = base.transform.position;
		rotation = base.transform.rotation;
	}

	private void Update()
	{
		if (currentAnim != null)
		{
			currentAnim.time += Time.deltaTime;
		}
		if (prevAnim != null)
		{
			prevAnim.time += Time.deltaTime;
			fadeTime += Time.deltaTime;
			if (fadeTime >= fadeLength)
			{
				currentAnim.weight = 1f;
				prevAnim = null;
			}
			else
			{
				currentAnim.weight = Mathf.Lerp(0f, 1f, fadeTime / fadeLength);
				prevAnim.weight = Mathf.Lerp(1f, 0f, fadeTime / fadeLength);
			}
		}
		timeLastFrame += Time.deltaTime;
		float num = 1f / framesPerSecond;
		if (timeLastFrame >= num)
		{
			timeLastFrame -= num;
			if (currentAnim != null)
			{
				currentAnim.enabled = true;
			}
			if (prevAnim != null)
			{
				prevAnim.enabled = true;
			}
			meshAnimation.Sample();
			if (currentAnim != null)
			{
				currentAnim.enabled = false;
			}
			if (prevAnim != null)
			{
				prevAnim.enabled = false;
			}
			if (controlPosition)
			{
				base.transform.position = position;
				base.transform.rotation = rotation;
			}
		}
	}
}
public class AfterBuild : MonoBehaviour
{
	private static AfterBuild instance;

	public ShadowWatcher shadowWatcher;

	public Transform doorOpenTrigger;

	public Transform doorCloseTrigger;

	public Transform gateTrigger;

	public Transform monsterTrigger;

	public Transform batsTrigger;

	public Transform ghostViewCover;

	public static AfterBuild Get()
	{
		if (instance == null)
		{
			instance = GameObject.Find("GameController").GetComponent<AfterBuild>();
		}
		return instance;
	}

	public void Awake()
	{
		instance = this;
	}

	public void DoBuild()
	{
		Debug.Log("AfterBuild - DoBuild");
		SpawnShadow();
		SpawnDoorTriggers();
		SpawnGateTrigger();
		SpawnTrigger(monsterTrigger, 18, 52);
		SpawnTrigger(batsTrigger, 36, 16);
		TurnLightsOn();
		UnityEngine.Object.Instantiate(ghostViewCover, new Vector3(33f, 1.75f, -15.75f), Quaternion.identity);
		Debug.Log("AfterBuild - DoBuild end");
	}

	private void SpawnShadow()
	{
		Point cellPos = new Point(23, 11);
		Vector3 position = Map.Get().CellToWorld(cellPos);
		ShadowWatcher shadowWatcher = UnityEngine.Object.Instantiate(rotation: Quaternion.LookRotation(new Vector3(0f, 0f, 1f)), original: this.shadowWatcher, position: position);
		shadowWatcher.infiniteTimer = true;
	}

	private void SpawnDoorTriggers()
	{
		UnityEngine.Object.Instantiate(doorOpenTrigger, Map.Get().CellToWorld(10, 12), Quaternion.identity);
		UnityEngine.Object.Instantiate(doorCloseTrigger, new Vector3(16.7f, 0f, -25.2f), Quaternion.Euler(0f, 300f, 0f));
	}

	private void SpawnGateTrigger()
	{
		UnityEngine.Object.Instantiate(gateTrigger, new Vector3(47.03f, 0f, -13.79f), Quaternion.Euler(0f, 270f, 0f));
	}

	private void SpawnTrigger(Transform trigger, int tileX, int tileY)
	{
		UnityEngine.Object.Instantiate(trigger, Map.Get().CellToWorld(tileX, tileY), Quaternion.identity);
	}

	private void TurnLightsOn()
	{
		Room[] array = new Room[2]
		{
			Map.Get().At(27, 7).Room,
			Map.Get().At(24, 7).Room
		};
		Room[] array2 = array;
		foreach (Room room in array2)
		{
			foreach (PropInfo prop in room.props)
			{
				InteractiveLightEx componentInChildren = prop.GetComponentInChildren<InteractiveLightEx>();
				if (componentInChildren != null)
				{
					componentInChildren.lightOn = true;
					componentInChildren.invulnerable = true;
					componentInChildren.endlessFuel = true;
				}
			}
		}
	}

	public static void AdjustSpawnRotation(Transform spawnPoint, float increment = 45f)
	{
		float y = spawnPoint.transform.localRotation.eulerAngles.y;
		List<float> list = new List<float>();
		float num = float.MaxValue;
		float y2 = y;
		for (float num2 = 0f; num2 < 360f; num2 += increment)
		{
			float num3 = Mathf.Abs(Mathf.DeltaAngle(y, num2));
			if (num3 < num)
			{
				num = num3;
				y2 = num2;
			}
		}
		Vector3 eulerAngles = spawnPoint.transform.localRotation.eulerAngles;
		Quaternion localRotation = Quaternion.Euler(eulerAngles.x, y2, eulerAngles.z);
		spawnPoint.transform.localRotation = localRotation;
	}
}
public class ColorCorrectionDbg : MonoBehaviour
{
	public Texture2D[] textures;

	public int index;

	private ColorCorrectionLut clut;

	private void Start()
	{
		index = 0;
		clut = GetComponent<ColorCorrectionLut>();
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.F5))
		{
			index = (index - 1) % textures.Length;
			if (index < 0)
			{
				index = textures.Length - 1;
			}
			SetLUT();
		}
		if (Input.GetKeyDown(KeyCode.F6))
		{
			index = (index + 1) % textures.Length;
			SetLUT();
		}
	}

	private void SetLUT()
	{
		Texture2D texture2D = textures[index];
		clut.Convert(texture2D, texture2D.name);
		Tutorial.Get().ShowTextForTime("Color grading: " + texture2D.name, 3f);
	}
}
public class DemoTimeout : MonoBehaviour
{
	public int timeRemaining = 180;

	public bool spawnMonster = true;

	public LightEater monster;

	private void Start()
	{
		StopCoroutine("Timeout_co");
		StartCoroutine("Timeout_co");
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Alpha1))
		{
			timeRemaining = 60;
			StopCoroutine("Timeout_co");
			StartCoroutine("Timeout_co");
			Tutorial.Get().ShowTextForTime("1 minute left", 5f);
		}
		if (Input.GetKeyDown(KeyCode.Alpha2))
		{
			timeRemaining = 120;
			StopCoroutine("Timeout_co");
			StartCoroutine("Timeout_co");
			Tutorial.Get().ShowTextForTime("2 minutes left", 5f);
		}
		if (Input.GetKeyDown(KeyCode.Alpha3))
		{
			timeRemaining = 180;
			StopCoroutine("Timeout_co");
			StartCoroutine("Timeout_co");
			Tutorial.Get().ShowTextForTime("3 minutes left", 5f);
		}
		if (Input.GetKeyDown(KeyCode.Alpha0))
		{
			timeRemaining = 0;
			StopCoroutine("Timeout_co");
			Tutorial.Get().ShowTextForTime("No timeout", 5f);
		}
		if (monster != null)
		{
			float sqrMagnitude = (Player.GetGroundPos() - monster.transform.position.ToGround()).sqrMagnitude;
			if (sqrMagnitude <= 4f)
			{
				Debug.Log("Demo Timeout - Ending level by monster proximity");
				GameController.Get().EndLevel(win: true);
				StopCoroutine("Timeout_co");
				base.enabled = false;
			}
		}
	}

	private IEnumerator Timeout_co()
	{
		yield return new WaitForSeconds(timeRemaining - 20);
		Debug.Log("Demo Timeout - Spawning monster");
		float secsWasted = 0f;
		while (monster == null && secsWasted < 17f)
		{
			monster = LightEater.SpawnNextToPlayer();
			if (monster != null)
			{
				break;
			}
			secsWasted += 3f;
			yield return new WaitForSeconds(3f);
		}
		yield return new WaitForSeconds(20f - secsWasted);
		Debug.Log("Demo Timeout - Ending level");
		GameController.Get().EndLevel(win: true);
	}

	public void Stop()
	{
		StopAllCoroutines();
	}
}
[RequireComponent(typeof(Trigger))]
public class DemoTriggerBats : MonoBehaviour
{
	public Bat batPrefab;

	public int numBats = 64;

	public AudioClip deepSound;

	public void OnTrigger(PlayerGameController player)
	{
		StartCoroutine(Trigger_co());
	}

	private IEnumerator Trigger_co()
	{
		Vector3 vDirection = Vector3.down;
		vDirection *= 20f;
		Utils.PlayClipAt(pos: base.transform.position + vDirection, clip: deepSound, minDistance: 70f, maxDistance: 100f);
		yield return new WaitForSeconds(1.5f);
		Transform playerPos = Player.Get().transform;
		Vector3 curPos = Player.GetGroundPos();
		for (int i = 0; i < numBats; i++)
		{
			UnityEngine.Object.Instantiate(batPrefab, curPos, playerPos.rotation);
		}
	}
}
[RequireComponent(typeof(Trigger))]
public class DemoTriggerDoorClose : MonoBehaviour
{
	public string doorName = "Door_5";

	public void OnTrigger(PlayerGameController player)
	{
		Door component = GameObject.Find(doorName).GetComponent<Door>();
		component.CloseFastWithWind();
	}
}
[RequireComponent(typeof(Trigger))]
public class DemoTriggerDoorOpen : MonoBehaviour
{
	public string doorName = "Door_2";

	public void OnTrigger(PlayerGameController player)
	{
		Door component = GameObject.Find(doorName).GetComponent<Door>();
		component.OpenWithCreak(player.transform);
	}
}
[RequireComponent(typeof(Trigger))]
public class DemoTriggerGate : MonoBehaviour
{
	private MechGate gate;

	private void Start()
	{
		Room room = Map.Get().At(base.transform.position).Room;
		foreach (PropInfo prop in room.props)
		{
			gate = prop.GetComponentInChildren<MechGate>();
			if (gate != null)
			{
				break;
			}
		}
		if (gate == null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		Serializer.Add(this, OnSerialize, OnDeserialize);
	}

	private void OnSerialize(BinaryWriter writer)
	{
		writer.Write(GetComponent<Collider>().enabled);
	}

	private void OnDeserialize(BinaryReader reader)
	{
		GetComponent<Collider>().enabled = reader.ReadBoolean();
	}

	public void OnTrigger(PlayerGameController player)
	{
		if (gate.progressOpen >= 0.9f)
		{
			gate.speed = 4f;
			gate.SetProgress(0.62f);
			FearEffect.Get().Scare(jumpScare: true);
		}
	}
}
[RequireComponent(typeof(Trigger))]
public class DemoTriggerMonster : MonoBehaviour
{
	public void OnTrigger(PlayerGameController player)
	{
		DemoTimeout component = GameController.Get().GetComponent<DemoTimeout>();
		if (component != null && component.monster == null)
		{
			component.monster = LightEater.SpawnNextToPlayer();
		}
	}
}
public class AmbientManager : TimeIndependentBehaviour
{
	private static AmbientManager instance;

	public bool drawDebug;

	public ParticleSystem[] dustEffect;

	public List<AmbientStyle> ambientStyles;

	public AmbientStyle curAmbient;

	private AmbientStyle lastAmbient;

	public string defaultAmbientName = "default";

	private AmbientStyle defaultAmbient;

	public bool updateFromPosition = true;

	private Transform playerPosition;

	private TorchLight playerTorch;

	private Light playerTorchLight;

	private Light playerMapLight;

	private OVRCameraRig ovrCamController;

	private Camera[] playerCameras;

	private float maxSeeingDistance = 60f;

	private bool dustEnabled;

	private bool dustEmission;

	private float interpolation;

	private float interpolationTime;

	private float ambientFactor = 0.5f;

	public static float configIntensity = 1f;

	public static float configRange = 1.4f;

	public AmbientStyle Style
	{
		get
		{
			return curAmbient;
		}
		set
		{
			SetStyle(value);
		}
	}

	public static AmbientManager Get()
	{
		if (instance == null)
		{
			instance = GameObject.Find("AmbientManager").GetComponent<AmbientManager>();
		}
		return instance;
	}

	public static void Clear()
	{
		instance = null;
	}

	protected new void Awake()
	{
		base.Awake();
		instance = this;
		interpolation = (interpolationTime = 1f);
		defaultAmbient = ambientStyles[0];
	}

	public void SetStyle(AmbientStyle style, float time = 2f)
	{
		if (style == null)
		{
			style = defaultAmbient;
		}
		if (!(style == curAmbient))
		{
			lastAmbient = curAmbient;
			curAmbient = style;
			if (time > 0f)
			{
				interpolation = 0f;
				interpolationTime = time;
			}
			else
			{
				interpolation = (interpolationTime = 1f);
			}
			Jukebox.Get().SetBaseMood((!(style.ambientTrack != string.Empty)) ? "ambience" : style.ambientTrack);
		}
	}

	public void SetStyle(string name, float time = 2f)
	{
		AmbientStyle style = GetStyle(name);
		if (style != null)
		{
			SetStyle(style, time);
		}
	}

	public AmbientStyle GetStyle(string name)
	{
		foreach (AmbientStyle ambientStyle in ambientStyles)
		{
			if (ambientStyle.styleName == name)
			{
				return ambientStyle;
			}
		}
		return null;
	}

	private void Start()
	{
		defaultAmbient = GetStyle(defaultAmbientName);
		if (!defaultAmbient)
		{
			defaultAmbient = ambientStyles[0];
		}
		lastAmbient = (curAmbient = defaultAmbient);
		playerPosition = Player.Get().transform;
		GameObject gameObject = GameObject.FindWithTag(Tags.PlayerTorch);
		if ((bool)gameObject)
		{
			playerTorchLight = gameObject.GetComponent<Light>();
			playerTorch = gameObject.GetComponent<TorchLight>();
			playerMapLight = gameObject.transform.Find("MapLight").GetComponent<Light>();
		}
		ResetPlayerCameras();
		if (updateFromPosition)
		{
			SetStyle(Map.Get().At(playerPosition.position).Ambient);
		}
	}

	public void ResetPlayerCameras()
	{
		ovrCamController = playerPosition.gameObject.GetComponentInChildren<OVRCameraRig>();
		playerCameras = Utils.GetPlayerCameras().ToArray();
	}

	protected new void Update()
	{
		base.Update();
		if (updateFromPosition)
		{
			SetStyle(Map.Get().At(playerPosition.position).Ambient);
		}
		interpolation = Mathf.Clamp(interpolation + base.deltaTime, 0f, interpolationTime);
		UpdateRenderSettings();
	}

	public void UpdateRenderSettings(bool editMode = false)
	{
		float t = Mathf.Clamp01(interpolation / interpolationTime);
		if (lastAmbient == null)
		{
			lastAmbient = curAmbient;
		}
		float to = 0.5f;
		float to2 = 1f;
		if (GameController.Get().Paused)
		{
			to2 = 0.1f;
			to = 0f;
		}
		TorchLight.globalFactor = Interpolate.Approach(TorchLight.globalFactor, to2, base.deltaTime * 4f);
		ambientFactor = Interpolate.Approach(ambientFactor, to, base.deltaTime * 2f);
		Vector4[] shaderConstants = curAmbient.SHLighting.GetShaderConstants();
		Vector4[] shaderConstants2 = lastAmbient.SHLighting.GetShaderConstants();
		Shader.SetGlobalVector("_DirAmbient_SHAr", Vector4.Lerp(shaderConstants2[0], shaderConstants[0], t));
		Shader.SetGlobalVector("_DirAmbient_SHAg", Vector4.Lerp(shaderConstants2[1], shaderConstants[1], t));
		Shader.SetGlobalVector("_DirAmbient_SHAb", Vector4.Lerp(shaderConstants2[2], shaderConstants[2], t));
		Shader.SetGlobalVector("_DirAmbient_SHBr", Vector4.Lerp(shaderConstants2[3], shaderConstants[3], t));
		Shader.SetGlobalVector("_DirAmbient_SHBg", Vector4.Lerp(shaderConstants2[4], shaderConstants[4], t));
		Shader.SetGlobalVector("_DirAmbient_SHBb", Vector4.Lerp(shaderConstants2[5], shaderConstants[5], t));
		Shader.SetGlobalVector("_DirAmbient_SHC", Vector4.Lerp(shaderConstants2[6], shaderConstants[6], t));
		Shader.SetGlobalFloat("_DirAmbient_Factor", ambientFactor);
		Color color = Color.Lerp(lastAmbient.fogColor, curAmbient.fogColor, t);
		color.a = 1f;
		RenderSettings.fogColor = color;
		RenderSettings.fogStartDistance = Mathf.Lerp(lastAmbient.fogStart, curAmbient.fogStart, t);
		float num2 = (RenderSettings.fogEndDistance = Mathf.Lerp(lastAmbient.fogEnd, curAmbient.fogEnd, t));
		if (playerCameras != null && ovrCamController != null)
		{
			for (int i = 0; i < playerCameras.Length; i++)
			{
				playerCameras[i].backgroundColor = color;
			}
			ovrCamController.leftEyeCamera.backgroundColor = color;
			ovrCamController.rightEyeCamera.backgroundColor = color;
		}
		if (playerTorch != null)
		{
			playerTorch.factor2 = Mathf.Lerp(lastAmbient.playerTorchIntensity, curAmbient.playerTorchIntensity, t) * configIntensity;
			playerTorch.range = Mathf.Lerp(lastAmbient.playerTorchRange, curAmbient.playerTorchRange, t) * configRange;
			playerTorchLight.color = Color.Lerp(lastAmbient.playerTorchColor, curAmbient.playerTorchColor, t);
			playerMapLight.color = playerTorchLight.color;
			playerTorch.SetSlaveLightFactor(0, Mathf.Lerp(lastAmbient.playerMapLightFactor, curAmbient.playerMapLightFactor, t) * configIntensity);
			if (editMode)
			{
				playerTorch.Update();
			}
		}
		maxSeeingDistance = 60f;
		if (num2 >= 1f)
		{
			maxSeeingDistance = Mathf.Min(maxSeeingDistance, num2);
		}
		maxSeeingDistance = Mathf.Min(maxSeeingDistance, playerTorch.range * 1.5f);
		if (dustEmission != curAmbient.dustParticles)
		{
			for (int j = 0; j < dustEffect.Length; j++)
			{
				dustEffect[j].enableEmission = curAmbient.dustParticles;
			}
			dustEmission = curAmbient.dustParticles;
		}
		if (curAmbient.dustParticles && !dustEnabled)
		{
			for (int k = 0; k < dustEffect.Length; k++)
			{
				dustEffect[k].gameObject.SetActive(value: true);
			}
			dustEnabled = true;
		}
		else
		{
			if (curAmbient.dustParticles || !dustEnabled)
			{
				return;
			}
			int num3 = 0;
			for (int l = 0; l < dustEffect.Length; l++)
			{
				num3 += dustEffect[l].particleCount;
			}
			if (num3 == 0)
			{
				for (int m = 0; m < dustEffect.Length; m++)
				{
					dustEffect[m].gameObject.SetActive(value: false);
				}
				dustEnabled = false;
			}
		}
	}

	public float GetMaxSeeingDistance()
	{
		return maxSeeingDistance;
	}

	public void OnDrawGizmosSelected()
	{
		if (Map.Get() == null || !drawDebug)
		{
			return;
		}
		for (int i = 0; i < Map.Get().Height; i++)
		{
			for (int j = 0; j < Map.Get().Height; j++)
			{
				AmbientStyle ambient = Map.Get().At(j, i).Ambient;
				if (ambient != null && ambient != defaultAmbient)
				{
					float num2;
					float num;
					float num3 = (num2 = (num = 0f));
					num3 += ambient.ambientX.r;
					num2 += ambient.ambientX.g;
					num += ambient.ambientX.b;
					num3 += ambient.ambientXNeg.r;
					num2 += ambient.ambientXNeg.g;
					num += ambient.ambientXNeg.b;
					num3 += ambient.ambientY.r;
					num2 += ambient.ambientY.g;
					num += ambient.ambientY.b;
					num3 += ambient.ambientYNeg.r;
					num2 += ambient.ambientYNeg.g;
					num += ambient.ambientYNeg.b;
					num3 += ambient.ambientZ.r;
					num2 += ambient.ambientZ.g;
					num += ambient.ambientZ.b;
					num3 += ambient.ambientZNeg.r;
					num2 += ambient.ambientZNeg.g;
					num += ambient.ambientZNeg.b;
					Color color = new Color(num3 / 6f, num2 / 6f, num / 6f, 0.5f);
					Gizmos.color = color;
					Gizmos.DrawCube(Map.Get().CellToWorld(j, i) + Vector3.up * 1.5f, new Vector3(1.5f, 3f, 1.5f));
				}
			}
		}
	}

	public float GetFogDistance()
	{
		if (RenderSettings.fogMode == FogMode.Linear)
		{
			return RenderSettings.fogEndDistance;
		}
		if (RenderSettings.fogMode == FogMode.Exponential && RenderSettings.fogDensity > 0f)
		{
			return Mathf.Log(526.3158f) / RenderSettings.fogDensity;
		}
		if (RenderSettings.fogMode == FogMode.ExponentialSquared && RenderSettings.fogDensity > 0f)
		{
			return Mathf.Sqrt(Mathf.Log(526.3158f)) / RenderSettings.fogDensity;
		}
		return float.MaxValue;
	}
}
public class AmbientStyle : ScriptableObject
{
	public string styleName;

	public Quaternion directionalRot;

	public Color directionalColor;

	public float directionalIntensity;

	public Color ambientX;

	public Color ambientXNeg;

	public Color ambientY;

	public Color ambientYNeg;

	public Color ambientZ;

	public Color ambientZNeg;

	public float ambientIntensity;

	public bool isHub;

	public Color fogColor;

	public float fogStart;

	public float fogEnd;

	public Color playerTorchColor;

	public float playerTorchRange;

	public float playerTorchIntensity;

	public float playerMapLightFactor = 1f;

	public string ambientTrack;

	public bool dustParticles;

	private SHLighting shLighting;

	public SHLighting SHLighting => shLighting;

	protected virtual void OnEnable()
	{
		shLighting = new SHLighting();
		ComputeSH();
	}

	public void ComputeSH()
	{
		shLighting.Clear();
		shLighting.AddDirectionalLight(ambientX, new Vector3(1f, 0f, 0f), ambientIntensity);
		shLighting.AddDirectionalLight(ambientXNeg, new Vector3(-1f, 0f, 0f), ambientIntensity);
		shLighting.AddDirectionalLight(ambientY, new Vector3(0f, 1f, 0f), ambientIntensity);
		shLighting.AddDirectionalLight(ambientYNeg, new Vector3(0f, -1f, 0f), ambientIntensity);
		shLighting.AddDirectionalLight(ambientZ, new Vector3(0f, 0f, 1f), ambientIntensity);
		shLighting.AddDirectionalLight(ambientZNeg, new Vector3(0f, 0f, -1f), ambientIntensity);
		shLighting.UpdateShaderConstants();
	}

	public void Clone(AmbientStyle original)
	{
		directionalRot = original.directionalRot;
		directionalColor = original.directionalColor;
		directionalIntensity = original.directionalIntensity;
		ambientX = original.ambientX;
		ambientXNeg = original.ambientXNeg;
		ambientY = original.ambientY;
		ambientYNeg = original.ambientYNeg;
		ambientZ = original.ambientZ;
		ambientZNeg = original.ambientZNeg;
		ambientIntensity = original.ambientIntensity;
		fogColor = original.fogColor;
		fogStart = original.fogStart;
		fogEnd = original.fogEnd;
		playerTorchColor = original.playerTorchColor;
		playerTorchRange = original.playerTorchRange;
		playerTorchIntensity = original.playerTorchIntensity;
		playerMapLightFactor = original.playerMapLightFactor;
		isHub = original.isHub;
	}
}
[ExecuteInEditMode]
public class AmbientTest : MonoBehaviour
{
	public Color lightX;

	public Color lightXNeg;

	public Color lightY;

	public Color lightYNeg;

	public Color lightZ;

	public Color lightZNeg;

	public float intensity = 1f;

	private void Start()
	{
		base.gameObject.transform.parent = null;
	}

	private void Update()
	{
		Shader.SetGlobalFloat("_DirAmbient_Intensity", intensity);
		Shader.SetGlobalColor("_DirAmbient_X", lightX);
		Shader.SetGlobalColor("_DirAmbient_X_Neg", lightXNeg);
		Shader.SetGlobalColor("_DirAmbient_Y", lightY);
		Shader.SetGlobalColor("_DirAmbient_Y_Neg", lightYNeg);
		Shader.SetGlobalColor("_DirAmbient_Z", lightZ);
		Shader.SetGlobalColor("_DirAmbient_Z_Neg", lightZNeg);
	}
}
[Serializable]
public class SHLighting
{
	public float[] coefficients = new float[27];

	private Vector4[] constants = new Vector4[7];

	public void Clear()
	{
		for (int i = 0; i < 27; i++)
		{
			coefficients[i] = 0f;
		}
	}

	public void AddAmbientLight(Color color)
	{
		float num = 3.5449078f;
		coefficients[0] += color.r * num;
		coefficients[1] += color.g * num;
		coefficients[2] += color.b * num;
	}

	public void AddDirectionalLight(Color color, Vector3 direction, float intensity)
	{
		float num = 0.2820948f;
		float num2 = 0.48860252f;
		float num3 = 1.0925485f;
		float num4 = 0.9461747f;
		float num5 = 0.54627424f;
		float num6 = 1f / 3f;
		float[] array = new float[9]
		{
			num,
			(0f - direction.y) * num2,
			direction.z * num2,
			(0f - direction.x) * num2,
			direction.x * direction.y * num3,
			(0f - direction.y) * direction.z * num3,
			(direction.z * direction.z - num6) * num4,
			(0f - direction.x) * direction.z * num3,
			(direction.x * direction.x - direction.y * direction.y) * num5
		};
		float num7 = 2.956793f;
		intensity *= 2f;
		float num8 = color.r * intensity * num7;
		float num9 = color.g * intensity * num7;
		float num10 = color.b * intensity * num7;
		for (int i = 0; i < 9; i++)
		{
			float num11 = array[i];
			coefficients[3 * i] += num11 * num8;
			coefficients[3 * i + 1] += num11 * num9;
			coefficients[3 * i + 2] += num11 * num10;
		}
	}

	public void AddPointLight(Color color, Vector3 position, float range, float intensity, Vector3 probePos)
	{
		Vector3 vector = position - probePos;
		float num = 1f / (1f + 25f * vector.sqrMagnitude / range * range);
		AddDirectionalLight(color, vector.normalized, intensity * num);
	}

	public Vector4[] GetShaderConstants()
	{
		return constants;
	}

	public void UpdateShaderConstants()
	{
		float num = Mathf.Sqrt((float)Math.PI);
		float num2 = 1f / (2f * num);
		float num3 = Mathf.Sqrt(3f) / (3f * num);
		float num4 = Mathf.Sqrt(15f) / (8f * num);
		float num5 = Mathf.Sqrt(5f) / (16f * num);
		float num6 = 0.5f * num4;
		for (int i = 0; i < 3; i++)
		{
			constants[i].x = (0f - num3) * coefficients[i + 9];
			constants[i].y = (0f - num3) * coefficients[i + 3];
			constants[i].z = num3 * coefficients[i + 6];
			constants[i].w = num2 * coefficients[i] - num5 * coefficients[i + 18];
		}
		for (int j = 0; j < 3; j++)
		{
			constants[j + 3].x = num4 * coefficients[j + 12];
			constants[j + 3].y = (0f - num4) * coefficients[j + 15];
			constants[j + 3].z = 3f * num5 * coefficients[j + 18];
			constants[j + 3].w = (0f - num4) * coefficients[j + 21];
		}
		constants[6].x = num6 * coefficients[24];
		constants[6].y = num6 * coefficients[25];
		constants[6].z = num6 * coefficients[26];
		constants[6].w = 1f;
	}
}
public class DisableOnPause : MonoBehaviour
{
	public List<GameObject> targetObjs;

	private bool[] prevEnabled;

	private bool isPaused;

	private void Start()
	{
		if (targetObjs == null)
		{
			targetObjs = new List<GameObject>();
		}
	}

	private void Update()
	{
		if (targetObjs.Count == 0)
		{
			return;
		}
		if (prevEnabled == null || prevEnabled.Length != targetObjs.Count)
		{
			prevEnabled = new bool[targetObjs.Count];
		}
		if (!isPaused && GameController.Get().wasJustPaused)
		{
			isPaused = true;
			for (int i = 0; i < targetObjs.Count; i++)
			{
				if (targetObjs[i] != null)
				{
					prevEnabled[i] = targetObjs[i].activeSelf;
					if (prevEnabled[i])
					{
						targetObjs[i].SetActive(value: false);
					}
				}
			}
		}
		else
		{
			if (!isPaused || GameController.Get().Paused)
			{
				return;
			}
			isPaused = false;
			for (int j = 0; j < targetObjs.Count; j++)
			{
				if (targetObjs[j] != null && prevEnabled[j])
				{
					targetObjs[j].SetActive(value: true);
				}
			}
		}
	}
}
public class HighlightEffect : MonoBehaviour
{
	private class CachedRenderer
	{
		private List<Material> originalMaterials;

		private Renderer rend;

		public CachedRenderer(Renderer rend)
		{
			this.rend = rend;
			originalMaterials = new List<Material>();
			originalMaterials.AddRange(rend.sharedMaterials);
		}

		public void Restore()
		{
			rend.sharedMaterials = originalMaterials.ToArray();
		}

		public void AddMaterial(Material newMat)
		{
			Material[] array = new Material[rend.sharedMaterials.Length + 1];
			for (int i = 0; i < rend.sharedMaterials.Length; i++)
			{
				array[i] = rend.sharedMaterials[i];
			}
			array[array.Length - 1] = newMat;
			rend.sharedMaterials = array;
		}
	}

	public Material highlightMaterial;

	private bool destroyMaterial;

	private bool state;

	private float curValue;

	private float targetValue;

	private float fadeSpeed = 4f;

	private List<CachedRenderer> cachedRenderers;

	private void Start()
	{
		if (highlightMaterial == null)
		{
			highlightMaterial = UnityEngine.Object.Instantiate(Resources.Load<Material>("Materials/highlight"));
			destroyMaterial = true;
		}
		cachedRenderers = new List<CachedRenderer>();
		MeshRenderer[] componentsInChildren = GetComponentsInChildren<MeshRenderer>();
		MeshRenderer[] array = componentsInChildren;
		foreach (MeshRenderer rend in array)
		{
			cachedRenderers.Add(new CachedRenderer(rend));
		}
	}

	private void Update()
	{
		if (state)
		{
			curValue = Mathf.Lerp(curValue, targetValue, Time.deltaTime * fadeSpeed);
			if (targetValue <= 0f && curValue <= 0.01f)
			{
				TurnOff();
			}
			else
			{
				highlightMaterial.SetFloat("_Intensity", curValue);
			}
		}
	}

	private void OnDestroy()
	{
		if (destroyMaterial)
		{
			UnityEngine.Object.DestroyImmediate(highlightMaterial);
		}
	}

	private void TurnOff()
	{
		state = false;
		curValue = (targetValue = 0f);
		foreach (CachedRenderer cachedRenderer in cachedRenderers)
		{
			cachedRenderer.Restore();
		}
	}

	public void FadeOut()
	{
		targetValue = 0f;
	}

	private void TurnOn()
	{
		targetValue = 1f;
		if (state)
		{
			return;
		}
		state = true;
		foreach (CachedRenderer cachedRenderer in cachedRenderers)
		{
			cachedRenderer.AddMaterial(highlightMaterial);
		}
	}

	public void FadeIn()
	{
		TurnOn();
	}
}
[ExecuteInEditMode]
public class Monochromize : ImageEffectBase
{
	[Range(0f, 1f)]
	public float intensity;

	public float brightnessFactor = 1f;

	protected override void OnDisable()
	{
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		base.material.SetFloat("_Intensity", intensity);
		base.material.SetFloat("_BrightnessFactor", brightnessFactor);
		Graphics.Blit(source, destination, base.material);
	}
}
public class SetCamera2World : MonoBehaviour
{
	private Camera camera;

	private void Start()
	{
		camera = GetComponent<Camera>();
	}

	private void OnPreCull()
	{
		Shader.SetGlobalMatrix("_Camera2World", camera.cameraToWorldMatrix);
	}
}
public class EndingController : FSMComponent<EndingController.States>
{
	public enum States
	{
		InitDelay,
		Credits,
		CreditsEnd,
		Final
	}

	public UIDreadHallsMenu creditsMenu;

	private UIMenuAnimator creditsMenuAnimator;

	private float creditsTimeout;

	private int creditsIndex;

	private bool canContinue;

	private const float creditsShowTime = 7f;

	private void Start()
	{
		GC.Collect();
		Config.General().endingCredits = true;
		Config.General().randomModeUnlocked = true;
		Config.Save();
		creditsMenuAnimator = creditsMenu.GetComponent<UIMenuAnimator>();
		creditsMenuAnimator.ApplyAlpha(0f);
		Init(States.InitDelay);
	}

	private new void Update()
	{
		base.Update();
		ExitOnBack();
	}

	private void InitDelay_Enter()
	{
		creditsTimeout = 3f;
	}

	private void InitDelay_Update()
	{
		creditsTimeout -= Time.deltaTime;
		if (creditsTimeout <= 0f)
		{
			base.State = States.Credits;
		}
	}

	private void Credits_Enter()
	{
		creditsMenu.gameObject.SetActive(value: true);
		creditsMenu.Visible = true;
		creditsMenu.SetCollidersEnabled(enabled: true);
		creditsMenuAnimator.FadeIn();
		SetText(Translate.Get("MENU_ENDING_TITLE"));
		creditsIndex = 0;
		creditsTimeout = 7f;
	}

	private void Credits_Update()
	{
		creditsTimeout -= Time.deltaTime;
		if (creditsTimeout <= 0f)
		{
			canContinue = false;
			creditsMenuAnimator.FadeOut(reset: false, OnEndCreditsSectionFade);
		}
	}

	private void SetText(string txt)
	{
		string newText = "<material=1>" + txt + "</material>";
		creditsMenu.SetText("main_text", newText);
	}

	private void OnEndCreditsSectionFade()
	{
		string creditsString = GetCreditsString(creditsIndex);
		if (creditsString != string.Empty)
		{
			SetText(creditsString);
			creditsMenuAnimator.FadeIn();
			creditsIndex++;
			creditsTimeout = 7f;
			canContinue = true;
		}
		else
		{
			base.State = States.CreditsEnd;
		}
	}

	private string GetCreditsString(int idx)
	{
		string key = "MENU_CREDITS_SECTION_" + idx;
		if (!Translate.Check(key))
		{
			return string.Empty;
		}
		return Translate.Get(key);
	}

	private void CreditsEnd_Enter()
	{
		creditsTimeout = 12f;
		SetText(Translate.GetForInput("MENU_ENDING_EXIT"));
		creditsMenuAnimator.FadeIn();
	}

	private void OnEndCredits()
	{
		creditsMenu.gameObject.SetActive(value: false);
	}

	private void ExitOnBack()
	{
		if (InputExt.GetButtonDown(InputExt.Button.Cancel) || GameController.GetBackButtonDown() || InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction))
		{
			GameController.Get().fader.SetColor(Color.black);
			GameController.Get().EndLevel();
		}
	}
}
public class ErrorMessage : MonoBehaviour
{
	public static string displayText = string.Empty;

	public TextLabel textLabel;

	private bool fading;

	public static void Display(string text, string errorMsgScene = "ErrorMessage")
	{
		displayText = text;
		UnityEngine.Application.LoadLevel(errorMsgScene);
	}

	private void Start()
	{
		textLabel.Text = displayText;
		textLabel.FadeIn();
	}

	private void Update()
	{
		bool flag = InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.Back) || Input.GetButtonDown("Fire1") || Input.anyKeyDown || Input.GetKeyDown(KeyCode.Escape) || Input.GetButtonDown("Cancel") || Utils.IsAnyButtonDown() || InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction) || InputExt.GetButtonDown(InputExt.Button.Cancel);
		if (!fading && flag)
		{
			Exit_OnEndFade();
		}
	}

	private void Exit_OnEndFade()
	{
		OVRManager.instance.ReturnToLauncher();
	}
}
public class Fader : TimeIndependentBehaviour
{
	public Texture2D FadeTexture;

	public float FromOpacity;

	public float ToOpacity = 1f;

	public float Speed = 1f;

	public bool FadeAudio;

	public GameObject Listener;

	private float Progress;

	private Material material;

	private Action onEndDelegate;

	public void FadeOut(float speed = 1f, bool fadeAudio = false, GameObject listener = null, Action onEnd = null)
	{
		FromOpacity = 0f;
		ToOpacity = 1f;
		Speed = speed;
		Progress = 0f;
		FadeAudio = fadeAudio;
		Listener = listener;
		onEndDelegate = onEnd;
	}

	public void FadeIn(float speed = 1f, bool fadeAudio = false, GameObject listener = null, Action onEnd = null)
	{
		FromOpacity = 1f;
		ToOpacity = 0f;
		Speed = speed;
		Progress = 0f;
		FadeAudio = fadeAudio;
		Listener = listener;
		onEndDelegate = onEnd;
	}

	private new void Awake()
	{
		base.Awake();
		material = GetComponent<Renderer>().material;
		material.color = GetCurColor();
		GetComponent<Renderer>().enabled = material.color.a >= 0.01f;
	}

	private void Start()
	{
		Progress = 0f;
	}

	private new void Update()
	{
		base.Update();
		bool flag = Progress >= 1f;
		Progress += base.deltaTime * Speed;
		Progress = Mathf.Clamp01(Progress);
		if (FadeAudio && GameController.Get() != null)
		{
			AudioListener.volume = Mathf.Lerp(ToOpacity * Config.Audio().masterVolume * GameController.Get().VolumeMultiplier, FromOpacity * Config.Audio().masterVolume * GameController.Get().VolumeMultiplier, Progress);
		}
		material.color = GetCurColor();
		GetComponent<Renderer>().enabled = material.color.a >= 0.01f;
		if (flag)
		{
			if ((bool)Listener)
			{
				Listener.SendMessage("OnEndFade", this);
				Listener = null;
			}
			if (onEndDelegate != null)
			{
				onEndDelegate();
				onEndDelegate = null;
			}
		}
	}

	private Color GetCurColor()
	{
		float a = Mathf.Lerp(FromOpacity, ToOpacity, Progress);
		return new Color(material.color.r, material.color.g, material.color.b, a);
	}

	public void SetColor(Color color)
	{
		material.color = new Color(color.r, color.g, color.b, material.color.a);
	}

	public void ForceAlpha(float val)
	{
		material.color = new Color(material.color.r, material.color.g, material.color.b, val);
		GetComponent<Renderer>().enabled = material.color.a >= 0.01f;
	}
}
public class AnimEvents : MonoBehaviour
{
	public AudioClip[] Sounds;

	public float MinDistance = 1f;

	public float MaxDistance = 15f;

	public float Spread;

	public bool Logarithmic = true;

	private void PlaySound(int index)
	{
		if (index >= 0 && index < Sounds.Length)
		{
			Utils.PlayClipAt(Sounds[index], base.transform.position, MinDistance, MaxDistance, Spread, (!Logarithmic) ? AudioRolloffMode.Linear : AudioRolloffMode.Logarithmic);
		}
	}

	private void PerformAttack()
	{
		Debug.Log("AnimEvents: PerformAttack()");
		SendMessageUpwards("DoAttack");
	}

	private void SetPlayerMagnetOn()
	{
		SendMessageUpwards("SetPlayerMagnet", true);
	}

	private void SetPlayerMagnetOff()
	{
		SendMessageUpwards("SetPlayerMagnet", false);
	}
}
public class DbgUtils
{
	[Conditional("UNITY_EDITOR")]
	public static void Assert(bool condition)
	{
		if (!condition)
		{
			throw new Exception();
		}
	}
}
namespace Prison
{
	public class DiamondSquare
	{
		public static float[] Generate(int size, System.Random rgen)
		{
			return Generate(size, rgen, 400f, 2f);
		}

		public static float[] Generate(int size, System.Random rgen, float range, float hardness)
		{
			float[] map = new float[size * size];
			int num = size - 1;
			map[size * 0] = 128f;
			map[size * 0 + (size - 1)] = 128f;
			map[size * (size - 1)] = 128f;
			map[size * (size - 1) + (size - 1)] = 128f;
			while (num > 1)
			{
				for (int i = 0; i < size - 1; i += num)
				{
					for (int j = 0; j < size - 1; j += num)
					{
						Point center = new Point(i + num / 2, j + num / 2);
						ComputeColor(center, new Point[4]
						{
							new Point(i, j),
							new Point(i + num, j),
							new Point(i, j + num),
							new Point(i + num, j + num)
						}, range, ref map, size, rgen);
					}
				}
				for (int k = 0; k < size - 1; k += num)
				{
					for (int l = 0; l < size - 1; l += num)
					{
						int num2 = num / 2;
						Point center2 = new Point(k + num2, l);
						Point center3 = new Point(k, l + num2);
						ComputeColor(center2, new Point[4]
						{
							new Point(center2.X - num2, center2.Y),
							new Point(center2.X, center2.Y - num2),
							new Point(center2.X + num2, center2.Y),
							new Point(center2.X, center2.Y + num2)
						}, range, ref map, size, rgen);
						ComputeColor(center3, new Point[4]
						{
							new Point(center3.X - num2, center3.Y),
							new Point(center3.X, center3.Y - num2),
							new Point(center3.X + num2, center3.Y),
							new Point(center3.X, center3.Y + num2)
						}, range, ref map, size, rgen);
					}
				}
				range /= hardness;
				num /= 2;
			}
			return map;
		}

		private static void ComputeColor(Point center, Point[] points, float range, ref float[] map, int size, System.Random rgen)
		{
			float num = 0f;
			for (int i = 0; i < 4; i++)
			{
				if (points[i].X < 0)
				{
					points[i].X += size - 1;
				}
				else if (points[i].X >= size)
				{
					points[i].X -= size - 1;
				}
				if (points[i].Y < 0)
				{
					points[i].Y += size - 1;
				}
				else if (points[i].Y >= size)
				{
					points[i].Y -= size - 1;
				}
				num += map[size * points[i].Y + points[i].X];
			}
			num /= 4f;
			num += (float)rgen.NextDouble() * range - range / 2f;
			num = Mathf.Clamp(num, 0f, 255f);
			map[size * center.Y + center.X] = num;
			if (center.X == 0)
			{
				map[size * center.Y + (size - 1)] = num;
			}
			else if (center.X == size - 1)
			{
				map[size * center.Y] = num;
			}
			if (center.Y == 0)
			{
				map[size * (size - 1) + center.X] = num;
			}
			else if (center.Y == size - 1)
			{
				map[size * 0 + center.X] = num;
			}
		}
	}
}
public static class ColorExt
{
	public static Vector3 ToVector3_RGB(this Color color)
	{
		return new Vector3(color.r, color.g, color.b);
	}

	public static Vector4 ToVector4_RGBA(this Color color)
	{
		return new Vector4(color.r, color.g, color.b, color.a);
	}

	public static Vector4 ToVector4_ARGB(this Color color)
	{
		return new Vector4(color.a, color.r, color.g, color.b);
	}

	public static float Luminance(this Color color)
	{
		Vector3 rhs = new Vector3(0.22f, 0.707f, 0.071f);
		Vector3 lhs = color.ToVector3_RGB();
		return Vector3.Dot(lhs, rhs);
	}

	public static float LuminanceAlpha(this Color color)
	{
		Vector3 rhs = new Vector3(0.22f, 0.707f, 0.071f);
		Vector3 lhs = color.ToVector3_RGB();
		lhs.x *= color.a;
		lhs.y *= color.a;
		lhs.z *= color.a;
		return Vector3.Dot(lhs, rhs);
	}

	public static Color FromValue(uint value)
	{
		Color result = default(Color);
		result.r = 0.003921569f * (float)(int)(byte)(value >> 16);
		result.g = 0.003921569f * (float)(int)(byte)(value >> 8);
		result.b = 0.003921569f * (float)(int)(byte)(value >> 0);
		result.a = 0.003921569f * (float)(int)(byte)(value >> 24);
		return result;
	}

	public static string ToHex(this Color color)
	{
		Color32 color2 = color;
		return color2.a.ToString("X2") + color2.r.ToString("X2") + color2.g.ToString("X2") + color2.b.ToString("X2");
	}

	public static Color FromHexString(string hex)
	{
		byte a = byte.Parse(hex.Substring(0, 2), NumberStyles.HexNumber);
		byte r = byte.Parse(hex.Substring(2, 2), NumberStyles.HexNumber);
		byte g = byte.Parse(hex.Substring(4, 2), NumberStyles.HexNumber);
		byte b = byte.Parse(hex.Substring(6, 2), NumberStyles.HexNumber);
		return new Color32(r, g, b, a);
	}

	public static Color WithAlpha(this Color color, float newAlpha)
	{
		return new Color(color.r, color.g, color.b, newAlpha);
	}
}
public static class DebugExt
{
	public static void DrawCube(Vector3 pos, Color col, Vector3 scale, float duration = 0f)
	{
		Vector3 vector = scale * 0.5f;
		Vector3[] array = new Vector3[8]
		{
			pos + new Vector3(vector.x, vector.y, vector.z),
			pos + new Vector3(0f - vector.x, vector.y, vector.z),
			pos + new Vector3(0f - vector.x, 0f - vector.y, vector.z),
			pos + new Vector3(vector.x, 0f - vector.y, vector.z),
			pos + new Vector3(vector.x, vector.y, 0f - vector.z),
			pos + new Vector3(0f - vector.x, vector.y, 0f - vector.z),
			pos + new Vector3(0f - vector.x, 0f - vector.y, 0f - vector.z),
			pos + new Vector3(vector.x, 0f - vector.y, 0f - vector.z)
		};
		Debug.DrawLine(array[0], array[1], col, duration);
		Debug.DrawLine(array[1], array[2], col, duration);
		Debug.DrawLine(array[2], array[3], col, duration);
		Debug.DrawLine(array[3], array[0], col, duration);
		Debug.DrawLine(array[4], array[5], col, duration);
		Debug.DrawLine(array[5], array[6], col, duration);
		Debug.DrawLine(array[6], array[7], col, duration);
		Debug.DrawLine(array[7], array[4], col, duration);
		Debug.DrawLine(array[0], array[4], col, duration);
		Debug.DrawLine(array[1], array[5], col, duration);
		Debug.DrawLine(array[2], array[6], col, duration);
		Debug.DrawLine(array[3], array[7], col, duration);
	}

	public static void DrawRect(Rect rect, Color col, float duration = 0f)
	{
		Vector3 pos = new Vector3(rect.x + rect.width / 2f, rect.y + rect.height / 2f, 0f);
		Vector3 scale = new Vector3(rect.width, rect.height, 0f);
		DrawRect(pos, col, scale, duration);
	}

	public static void DrawRect(Vector3 pos, Color col, Vector3 scale, float duration = 0f)
	{
		Vector3 vector = scale * 0.5f;
		Vector3[] array = new Vector3[4]
		{
			pos + new Vector3(vector.x, vector.y, vector.z),
			pos + new Vector3(0f - vector.x, vector.y, vector.z),
			pos + new Vector3(0f - vector.x, 0f - vector.y, vector.z),
			pos + new Vector3(vector.x, 0f - vector.y, vector.z)
		};
		Debug.DrawLine(array[0], array[1], col, duration);
		Debug.DrawLine(array[1], array[2], col, duration);
		Debug.DrawLine(array[2], array[3], col, duration);
		Debug.DrawLine(array[3], array[0], col, duration);
	}

	public static void DrawPoint(Vector3 pos, Color col, float scale, float duration = 0f)
	{
		Vector3[] array = new Vector3[6]
		{
			pos + Vector3.up * scale,
			pos - Vector3.up * scale,
			pos + Vector3.right * scale,
			pos - Vector3.right * scale,
			pos + Vector3.forward * scale,
			pos - Vector3.forward * scale
		};
		Debug.DrawLine(array[0], array[1], col, duration);
		Debug.DrawLine(array[2], array[3], col, duration);
		Debug.DrawLine(array[4], array[5], col, duration);
	}

	public static void DrawSphere(Vector3 pos, Color col, float radius = 1f, float duration = 0f)
	{
		float num = (float)Math.PI / 30f;
		Vector3 vector = Vector3.zero;
		for (float num2 = 0f; num2 <= (float)Math.PI * 2f + num / 2f; num2 += num)
		{
			Vector3 vector2 = new Vector3(radius * Mathf.Cos(num2), radius * Mathf.Sin(num2), 0f);
			vector2 += pos;
			if (vector != Vector3.zero)
			{
				Debug.DrawLine(vector, vector2, col, duration);
			}
			vector = vector2;
		}
		vector = Vector3.zero;
		for (float num3 = 0f; num3 <= (float)Math.PI * 2f + num / 2f; num3 += num)
		{
			Vector3 vector3 = new Vector3(radius * Mathf.Cos(num3), 0f, radius * Mathf.Sin(num3));
			vector3 += pos;
			if (vector != Vector3.zero)
			{
				Debug.DrawLine(vector, vector3, col, duration);
			}
			vector = vector3;
		}
		vector = Vector3.zero;
		for (float num4 = 0f; num4 <= (float)Math.PI * 2f + num / 2f; num4 += num)
		{
			Vector3 vector4 = new Vector3(0f, radius * Mathf.Cos(num4), radius * Mathf.Sin(num4));
			vector4 += pos;
			if (vector != Vector3.zero)
			{
				Debug.DrawLine(vector, vector4, col, duration);
			}
			vector = vector4;
		}
	}
}
public static class LayerMaskExtensions
{
	public static LayerMask Create(params string[] layerNames)
	{
		return NamesToMask(layerNames);
	}

	public static LayerMask Create(params int[] layerNumbers)
	{
		return LayerNumbersToMask(layerNumbers);
	}

	public static LayerMask NamesToMask(params string[] layerNames)
	{
		LayerMask layerMask = 0;
		foreach (string layerName in layerNames)
		{
			layerMask = (int)layerMask | (1 << LayerMask.NameToLayer(layerName));
		}
		return layerMask;
	}

	public static LayerMask LayerNumbersToMask(params int[] layerNumbers)
	{
		LayerMask layerMask = 0;
		foreach (int num in layerNumbers)
		{
			layerMask = (int)layerMask | (1 << num);
		}
		return layerMask;
	}

	public static LayerMask Inverse(this LayerMask original)
	{
		return ~(int)original;
	}

	public static LayerMask AddToMask(this LayerMask original, params string[] layerNames)
	{
		return (int)original | (int)NamesToMask(layerNames);
	}

	public static LayerMask RemoveFromMask(this LayerMask original, params string[] layerNames)
	{
		LayerMask layerMask = ~(int)original;
		return ~((int)layerMask | (int)NamesToMask(layerNames));
	}

	public static string[] MaskToNames(this LayerMask original)
	{
		List<string> list = new List<string>();
		for (int i = 0; i < 32; i++)
		{
			int num = 1 << i;
			if (((int)original & num) == num)
			{
				string text = LayerMask.LayerToName(i);
				if (!string.IsNullOrEmpty(text))
				{
					list.Add(text);
				}
			}
		}
		return list.ToArray();
	}

	public static string MaskToString(this LayerMask original)
	{
		return original.MaskToString(", ");
	}

	public static string MaskToString(this LayerMask original, string delimiter)
	{
		return string.Join(delimiter, original.MaskToNames());
	}
}
public static class ListExtensions
{
	public static void Reverse_NoHeapAlloc<T>(this List<T> list)
	{
		int count = list.Count;
		for (int i = 0; i < count / 2; i++)
		{
			T value = list[i];
			list[i] = list[count - i - 1];
			list[count - i - 1] = value;
		}
	}

	public static int GetOrderIndependentHashCode<T>(this List<T> list)
	{
		int num = 0;
		foreach (T item in list)
		{
			num ^= EqualityComparer<T>.Default.GetHashCode(item);
		}
		return num;
	}

	public static void AddIfNotInside<T>(this List<T> list, T item)
	{
		if (!list.Contains(item))
		{
			list.Add(item);
		}
	}

	public static void Shuffle<T>(this List<T> list)
	{
		int num = list.Count;
		while (num > 1)
		{
			num--;
			int index = UnityEngine.Random.Range(0, num + 1);
			T value = list[index];
			list[index] = list[num];
			list[num] = value;
		}
	}
}
public class StringBuilderEx
{
	public StringBuilder Builder;

	public StringBuilderEx(int capacity)
	{
		Builder = new StringBuilder(capacity);
		InitInnerStr();
	}

	public StringBuilderEx(int capacity, int maxCapacity)
	{
		Builder = new StringBuilder(capacity, maxCapacity);
		InitInnerStr();
	}

	private void InitInnerStr()
	{
	}

	public StringBuilder Get()
	{
		return Builder;
	}

	public override string ToString()
	{
		return Builder.ToString();
	}
}
public static class StringBuilderExtensions
{
	private static readonly char[] ms_digits = new char[16]
	{
		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
		'A', 'B', 'C', 'D', 'E', 'F'
	};

	private static readonly uint ms_default_decimal_places = 5u;

	private static readonly char ms_default_pad_char = '0';

	public static StringBuilder ConcatFormat<A>(this StringBuilder string_builder, string format_string, A arg1) where A : IConvertible
	{
		return string_builder.ConcatFormat(format_string, arg1, 0, 0, 0);
	}

	public static StringBuilder ConcatFormat<A, B>(this StringBuilder string_builder, string format_string, A arg1, B arg2) where A : IConvertible where B : IConvertible
	{
		return string_builder.ConcatFormat(format_string, arg1, arg2, 0, 0);
	}

	public static StringBuilder ConcatFormat<A, B, C>(this StringBuilder string_builder, string format_string, A arg1, B arg2, C arg3) where A : IConvertible where B : IConvertible where C : IConvertible
	{
		return string_builder.ConcatFormat(format_string, arg1, arg2, arg3, 0);
	}

	public static StringBuilder ConcatFormat<A, B, C, D>(this StringBuilder string_builder, string format_string, A arg1, B arg2, C arg3, D arg4) where A : IConvertible where B : IConvertible where C : IConvertible where D : IConvertible
	{
		int num = 0;
		for (int i = 0; i < format_string.Length; i++)
		{
			if (format_string[i] != '{')
			{
				continue;
			}
			if (num < i)
			{
				string_builder.Append(format_string, num, i - num);
			}
			uint base_value = 10u;
			uint num2 = 0u;
			uint num3 = 5u;
			i++;
			char c = format_string[i];
			if (c == '{')
			{
				string_builder.Append('{');
				i++;
			}
			else
			{
				i++;
				if (format_string[i] == ':')
				{
					i++;
					while (format_string[i] == '0')
					{
						i++;
						num2++;
					}
					if (format_string[i] == 'X')
					{
						i++;
						base_value = 16u;
						if (format_string[i] >= '0' && format_string[i] <= '9')
						{
							num2 = (uint)(format_string[i] - 48);
							i++;
						}
					}
					else if (format_string[i] == '.')
					{
						i++;
						num3 = 0u;
						while (format_string[i] == '0')
						{
							i++;
							num3++;
						}
					}
				}
				for (; format_string[i] != '}'; i++)
				{
				}
				switch (c)
				{
				case '0':
					string_builder.ConcatFormatValue(arg1, num2, base_value, num3);
					break;
				case '1':
					string_builder.ConcatFormatValue(arg2, num2, base_value, num3);
					break;
				case '2':
					string_builder.ConcatFormatValue(arg3, num2, base_value, num3);
					break;
				case '3':
					string_builder.ConcatFormatValue(arg4, num2, base_value, num3);
					break;
				}
			}
			num = i + 1;
		}
		if (num < format_string.Length)
		{
			string_builder.Append(format_string, num, format_string.Length - num);
		}
		return string_builder;
	}

	private static void ConcatFormatValue<T>(this StringBuilder string_builder, T arg, uint padding, uint base_value, uint decimal_places) where T : IConvertible
	{
		switch (arg.GetTypeCode())
		{
		case TypeCode.UInt32:
			string_builder.Concat(arg.ToUInt32(NumberFormatInfo.CurrentInfo), padding, '0', base_value);
			break;
		case TypeCode.Int32:
			string_builder.Concat(arg.ToInt32(NumberFormatInfo.CurrentInfo), padding, '0', base_value);
			break;
		case TypeCode.Single:
			string_builder.Concat(arg.ToSingle(NumberFormatInfo.CurrentInfo), decimal_places, padding, '0');
			break;
		case TypeCode.String:
			string_builder.Append(Convert.ToString(arg));
			break;
		}
	}

	public static StringBuilder Concat(this StringBuilder string_builder, uint uint_val, uint pad_amount, char pad_char, uint base_val)
	{
		uint num = 0u;
		uint num2 = uint_val;
		do
		{
			num2 /= base_val;
			num++;
		}
		while (num2 != 0);
		string_builder.Append(pad_char, (int)Math.Max(pad_amount, num));
		int num3 = string_builder.Length;
		while (num != 0)
		{
			num3--;
			string_builder[num3] = ms_digits[uint_val % base_val];
			uint_val /= base_val;
			num--;
		}
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, uint uint_val)
	{
		string_builder.Concat(uint_val, 0u, ms_default_pad_char, 10u);
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, uint uint_val, uint pad_amount)
	{
		string_builder.Concat(uint_val, pad_amount, ms_default_pad_char, 10u);
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, uint uint_val, uint pad_amount, char pad_char)
	{
		string_builder.Concat(uint_val, pad_amount, pad_char, 10u);
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, int int_val, uint pad_amount, char pad_char, uint base_val)
	{
		if (int_val < 0)
		{
			string_builder.Append('-');
			uint uint_val = (uint)(-1 - int_val + 1);
			string_builder.Concat(uint_val, pad_amount, pad_char, base_val);
		}
		else
		{
			string_builder.Concat((uint)int_val, pad_amount, pad_char, base_val);
		}
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, int int_val)
	{
		string_builder.Concat(int_val, 0u, ms_default_pad_char, 10u);
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, int int_val, uint pad_amount)
	{
		string_builder.Concat(int_val, pad_amount, ms_default_pad_char, 10u);
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, int int_val, uint pad_amount, char pad_char)
	{
		string_builder.Concat(int_val, pad_amount, pad_char, 10u);
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, float float_val, uint decimal_places, uint pad_amount, char pad_char)
	{
		if (decimal_places == 0)
		{
			int int_val = ((!(float_val >= 0f)) ? ((int)(float_val - 0.5f)) : ((int)(float_val + 0.5f)));
			string_builder.Concat(int_val, pad_amount, pad_char, 10u);
		}
		else
		{
			int num = (int)float_val;
			string_builder.Concat(num, pad_amount, pad_char, 10u);
			string_builder.Append('.');
			float num2 = Math.Abs(float_val - (float)num);
			do
			{
				num2 *= 10f;
				decimal_places--;
			}
			while (decimal_places != 0);
			num2 += 0.5f;
			string_builder.Concat((uint)num2, 0u, '0', 10u);
		}
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, float float_val)
	{
		string_builder.Concat(float_val, ms_default_decimal_places, 0u, ms_default_pad_char);
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, float float_val, uint decimal_places)
	{
		string_builder.Concat(float_val, decimal_places, 0u, ms_default_pad_char);
		return string_builder;
	}

	public static StringBuilder Concat(this StringBuilder string_builder, float float_val, uint decimal_places, uint pad_amount)
	{
		string_builder.Concat(float_val, decimal_places, pad_amount, ms_default_pad_char);
		return string_builder;
	}
}
public static class TextureExt
{
	public static void SaveToFile(this Texture2D texture, string filename)
	{
		byte[] array = texture.EncodeToPNG();
		FileStream fileStream = File.OpenWrite(UnityEngine.Application.dataPath + "/" + filename);
		fileStream.Write(array, 0, array.Length);
		fileStream.Close();
	}
}
public static class Vector3Ext
{
	public static Vector3 ToGround(this Vector3 vec)
	{
		Vector3 result = vec;
		result.y = 0f;
		return result;
	}

	public static Vector3 GroundNormalize(this Vector3 vec)
	{
		vec.y = 0f;
		vec.Normalize();
		return vec;
	}

	public static float magnitudeGround(this Vector3 vec)
	{
		return GroundVector(vec).magnitude;
	}

	public static float sqrMagnitudeGround(this Vector3 vec)
	{
		return GroundVector(vec).sqrMagnitude;
	}

	public static Vector3 GroundVector(Vector3 vec)
	{
		return new Vector3(vec.x, 0f, vec.z);
	}

	public static Vector3 GroundVector(Vector3 to, Vector3 from)
	{
		Vector3 vec = to - from;
		return vec.ToGround();
	}

	public static Vector3 Approach(this Vector3 vec, Vector3 to, float speed)
	{
		return vec + (to - vec) * speed;
	}

	public static Vector3 MajorAxis(this Vector3 vec)
	{
		float num = Mathf.Abs(vec.x);
		float num2 = Mathf.Abs(vec.y);
		float num3 = Mathf.Abs(vec.z);
		if (num > num2 && num > num3)
		{
			return new Vector3(1f, 0f, 0f) * Mathf.Sign(vec.x);
		}
		if (num2 > num && num2 > num3)
		{
			return new Vector3(0f, 1f, 0f) * Mathf.Sign(vec.y);
		}
		return new Vector3(0f, 0f, 1f) * Mathf.Sign(vec.z);
	}
}
public class FSM<T> where T : IComparable
{
	public class StateInfo
	{
		public Action Enter;

		public Action Exit;

		public Action Update;

		public Action FixedUpdate;

		public Action LateUpdate;

		public Action OnTimer;

		public StateInfo()
		{
			Enter = Nop;
			Exit = Nop;
			Update = Nop;
			FixedUpdate = Nop;
			LateUpdate = Nop;
			OnTimer = Nop;
		}

		public static void Nop()
		{
		}
	}

	private Dictionary<T, StateInfo> states = new Dictionary<T, StateInfo>();

	private T currentState = default(T);

	private StateInfo currentInfo;

	private float timer;

	private bool timerActive;

	public StateInfo this[T state]
	{
		get
		{
			if (states.TryGetValue(state, out var value))
			{
				return value;
			}
			value = new StateInfo();
			states[state] = value;
			return value;
		}
		set
		{
			states[state] = value;
		}
	}

	public T State
	{
		get
		{
			return currentState;
		}
		set
		{
			SetState(value);
		}
	}

	public FSM(object owner)
	{
		states.Clear();
		T[] array = (T[])Enum.GetValues(typeof(T));
		foreach (T state in array)
		{
			this[state] = new StateInfo();
			Action action = FindDelegate(owner, state, "Enter");
			if (action != null)
			{
				this[state].Enter = action;
			}
			action = FindDelegate(owner, state, "Exit");
			if (action != null)
			{
				this[state].Exit = action;
			}
			action = FindDelegate(owner, state, "Update");
			if (action != null)
			{
				this[state].Update = action;
			}
			action = FindDelegate(owner, state, "FixedUpdate");
			if (action != null)
			{
				this[state].FixedUpdate = action;
			}
			action = FindDelegate(owner, state, "LateUpdate");
			if (action != null)
			{
				this[state].LateUpdate = action;
			}
			action = FindDelegate(owner, state, "OnTimer");
			if (action != null)
			{
				this[state].OnTimer = action;
			}
		}
	}

	public void Clear()
	{
		states.Clear();
		currentInfo = null;
		ClearTimer();
	}

	public void ClearTimer()
	{
		timer = 0f;
		timerActive = false;
	}

	public void SetTimer(float time)
	{
		timer = time;
		timerActive = true;
	}

	public void Init(T initState)
	{
		currentState = initState;
		states.TryGetValue(currentState, out currentInfo);
		OnEnter();
	}

	private void SetState(T newState)
	{
		if (newState.CompareTo(currentState) != 0)
		{
			OnExit();
			currentState = newState;
			ClearTimer();
			states.TryGetValue(currentState, out currentInfo);
			OnEnter();
		}
	}

	private Action FindDelegate(object owner, T state, string type)
	{
		string name = state.ToString() + "_" + type;
		MethodInfo method = owner.GetType().GetMethod(name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.InvokeMethod);
		if (method != null)
		{
			return Delegate.CreateDelegate(typeof(Action), owner, method) as Action;
		}
		return null;
	}

	private void OnEnter()
	{
		if (currentInfo != null)
		{
			currentInfo.Enter();
		}
	}

	private void OnExit()
	{
		if (currentInfo != null)
		{
			currentInfo.Exit();
		}
	}

	public void Update()
	{
		if (currentInfo != null)
		{
			currentInfo.Update();
		}
		if (timerActive)
		{
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				ClearTimer();
				OnTimer();
			}
		}
	}

	public void FixedUpdate()
	{
		if (currentInfo != null)
		{
			currentInfo.FixedUpdate();
		}
	}

	public void LateUpdate()
	{
		if (currentInfo != null)
		{
			currentInfo.LateUpdate();
		}
	}

	public void OnTimer()
	{
		if (currentInfo != null)
		{
			currentInfo.OnTimer();
		}
	}
}
public class FSMComponent<T> : MonoBehaviour where T : IComparable
{
	protected FSM<T> fsm;

	public string curState;

	public T State
	{
		get
		{
			return fsm.State;
		}
		set
		{
			fsm.State = value;
		}
	}

	protected virtual void Awake()
	{
		fsm = new FSM<T>(this);
	}

	protected void Init(T startState)
	{
		fsm.Init(startState);
	}

	protected virtual void Update()
	{
		fsm.Update();
	}

	protected virtual void FixedUpdate()
	{
		fsm.FixedUpdate();
	}

	protected virtual void LateUpdate()
	{
		fsm.LateUpdate();
	}

	protected void ClearTimer()
	{
		fsm.ClearTimer();
	}

	protected void SetTimer(float time)
	{
		fsm.SetTimer(time);
	}
}
public class FSMTest : FSMComponent<FSMTest.States>
{
	public enum States
	{
		StateOne,
		StateTwo,
		StateThree
	}

	public void Start()
	{
		Init(States.StateOne);
	}

	private void StateOne_Enter()
	{
	}

	private void StateOne_Update()
	{
		base.State = States.StateThree;
	}

	private void StateOne_Exit()
	{
	}

	private void StateTwo_Enter()
	{
	}

	private void StateTwo_Update()
	{
	}

	private void StateTwo_Exit()
	{
	}
}
public class TimeIdependentFSMComponent<T> : TimeIndependentBehaviour where T : IComparable
{
	protected FSM<T> fsm;

	public string curState;

	public T State
	{
		get
		{
			return fsm.State;
		}
		set
		{
			fsm.State = value;
		}
	}

	protected override void Awake()
	{
		base.Awake();
		fsm = new FSM<T>(this);
	}

	protected void Init(T startState)
	{
		fsm.Init(startState);
	}

	protected override void Update()
	{
		base.Update();
		fsm.Update();
	}

	protected virtual void FixedUpdate()
	{
		fsm.FixedUpdate();
	}

	protected virtual void LateUpdate()
	{
		fsm.LateUpdate();
	}

	protected void ClearTimer()
	{
		fsm.ClearTimer();
	}

	protected void SetTimer(float time)
	{
		fsm.SetTimer(time);
	}
}
public class Interpolate
{
	public static float Lerp(float from, float to, float t)
	{
		return from + t * (to - from);
	}

	public static Vector3 Lerp(Vector3 from, Vector3 to, float t)
	{
		return Vector3.Lerp(from, to, t);
	}

	public static Vector2 Lerp(Vector2 from, Vector2 to, float t)
	{
		return Vector2.Lerp(from, to, t);
	}

	public static Color Lerp(Color from, Color to, float t)
	{
		return Color.Lerp(from, to, t);
	}

	public static float SmoothStep(float t)
	{
		return t * t * (3f - 2f * t);
	}

	public static float SmoothStep(float from, float to, float t)
	{
		return Lerp(from, to, SmoothStep(t));
	}

	public static Vector3 SmoothStep(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, SmoothStep(t));
	}

	public static Vector2 SmoothStep(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, SmoothStep(t));
	}

	public static Color SmoothStep(Color from, Color to, float t)
	{
		return Lerp(from, to, SmoothStep(t));
	}

	public static float EaseIn(float t)
	{
		return t * t;
	}

	public static float EaseOut(float t)
	{
		return 0f - t * (t - 2f);
	}

	public static float EaseInOut(float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t;
		}
		t -= 1f;
		return -0.5f * (t * (t - 2f) - 1f);
	}

	public static float EaseIn(float from, float to, float t)
	{
		return Lerp(from, to, EaseIn(t));
	}

	public static float EaseOut(float from, float to, float t)
	{
		return Lerp(from, to, EaseOut(t));
	}

	public static float EaseInOut(float from, float to, float t)
	{
		return Lerp(from, to, EaseInOut(t));
	}

	public static Vector3 EaseIn(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseIn(t));
	}

	public static Vector3 EaseOut(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseOut(t));
	}

	public static Vector3 EaseInOut(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInOut(t));
	}

	public static Vector2 EaseIn(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseIn(t));
	}

	public static Vector2 EaseOut(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseOut(t));
	}

	public static Vector2 EaseInOut(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInOut(t));
	}

	public static Color EaseIn(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseIn(t));
	}

	public static Color EaseOut(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseOut(t));
	}

	public static Color EaseInOut(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInOut(t));
	}

	public static float EaseInCubic(float t)
	{
		return t * t * t;
	}

	public static float EaseOutCubic(float t)
	{
		t -= 1f;
		return t * t * t + 1f;
	}

	public static float EaseInOutCubic(float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * t;
		}
		t -= 2f;
		return 0.5f * (t * t * t + 2f);
	}

	public static float EaseInCubic(float from, float to, float t)
	{
		return Lerp(from, to, EaseInCubic(t));
	}

	public static float EaseOutCubic(float from, float to, float t)
	{
		return Lerp(from, to, EaseOutCubic(t));
	}

	public static float EaseInOutCubic(float from, float to, float t)
	{
		return Lerp(from, to, EaseInOutCubic(t));
	}

	public static Vector3 EaseInCubic(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInCubic(t));
	}

	public static Vector3 EaseOutCubic(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseOutCubic(t));
	}

	public static Vector3 EaseInOutCubic(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInOutCubic(t));
	}

	public static Vector2 EaseInCubic(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInCubic(t));
	}

	public static Vector2 EaseOutCubic(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseOutCubic(t));
	}

	public static Vector2 EaseInOutCubic(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInOutCubic(t));
	}

	public static Color EaseInCubic(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInCubic(t));
	}

	public static Color EaseOutCubic(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseOutCubic(t));
	}

	public static Color EaseInOutCubic(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInOutCubic(t));
	}

	public static float EaseInQuart(float t)
	{
		return t * t * t * t;
	}

	public static float EaseOutQuart(float t)
	{
		t -= 1f;
		return 0f - (t * t * t * t - 1f);
	}

	public static float EaseInOutQuart(float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * t * t;
		}
		t -= 2f;
		return -0.5f * (t * t * t * t - 2f);
	}

	public static float EaseInQuart(float from, float to, float t)
	{
		return Lerp(from, to, EaseInQuart(t));
	}

	public static float EaseOutQuart(float from, float to, float t)
	{
		return Lerp(from, to, EaseOutQuart(t));
	}

	public static float EaseInOutQuart(float from, float to, float t)
	{
		return Lerp(from, to, EaseInOutQuart(t));
	}

	public static Vector3 EaseInQuart(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInQuart(t));
	}

	public static Vector3 EaseOutQuart(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseOutQuart(t));
	}

	public static Vector3 EaseInOutQuart(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInOutQuart(t));
	}

	public static Vector2 EaseInQuart(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInQuart(t));
	}

	public static Vector2 EaseOutQuart(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseOutQuart(t));
	}

	public static Vector2 EaseInOutQuart(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInOutQuart(t));
	}

	public static Color EaseInQuart(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInQuart(t));
	}

	public static Color EaseOutQuart(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseOutQuart(t));
	}

	public static Color EaseInOutQuart(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInOutQuart(t));
	}

	public static float EaseInQuintic(float t)
	{
		return t * t * t * t * t;
	}

	public static float EaseOutQuintic(float t)
	{
		t -= 1f;
		return t * t * t * t * t + 1f;
	}

	public static float EaseInOutQuintic(float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return 0.5f * t * t * t * t * t;
		}
		t -= 2f;
		return 0.5f * (t * t * t * t * t + 2f);
	}

	public static float EaseInQuintic(float from, float to, float t)
	{
		return Lerp(from, to, EaseInQuintic(t));
	}

	public static float EaseOutQuintic(float from, float to, float t)
	{
		return Lerp(from, to, EaseOutQuintic(t));
	}

	public static float EaseInOutQuintic(float from, float to, float t)
	{
		return Lerp(from, to, EaseInOutQuintic(t));
	}

	public static Vector3 EaseInQuintic(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInQuintic(t));
	}

	public static Vector3 EaseOutQuintic(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseOutQuintic(t));
	}

	public static Vector3 EaseInOutQuintic(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInOutQuintic(t));
	}

	public static Vector2 EaseInQuintic(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInQuintic(t));
	}

	public static Vector2 EaseOutQuintic(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseOutQuintic(t));
	}

	public static Vector2 EaseInOutQuintic(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInOutQuintic(t));
	}

	public static Color EaseInQuintic(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInQuintic(t));
	}

	public static Color EaseOutQuintic(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseOutQuintic(t));
	}

	public static Color EaseInOutQuintic(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInOutQuintic(t));
	}

	public static float EaseInSine(float t)
	{
		return 1f - Mathf.Cos(t * (float)Math.PI / 2f);
	}

	public static float EaseOutSine(float t)
	{
		return Mathf.Sin(t * (float)Math.PI / 2f);
	}

	public static float EaseInOutSine(float t)
	{
		return -0.5f * (Mathf.Cos(t * (float)Math.PI) - 1f);
	}

	public static float EaseInSine(float from, float to, float t)
	{
		return Lerp(from, to, EaseInSine(t));
	}

	public static float EaseOutSine(float from, float to, float t)
	{
		return Lerp(from, to, EaseOutSine(t));
	}

	public static float EaseInOutSine(float from, float to, float t)
	{
		return Lerp(from, to, EaseInOutSine(t));
	}

	public static Vector3 EaseInSine(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInSine(t));
	}

	public static Vector3 EaseOutSine(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseOutSine(t));
	}

	public static Vector3 EaseInOutSine(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInOutSine(t));
	}

	public static Vector2 EaseInSine(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInSine(t));
	}

	public static Vector2 EaseOutSine(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseOutSine(t));
	}

	public static Vector2 EaseInOutSine(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInOutSine(t));
	}

	public static Color EaseInSine(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInSine(t));
	}

	public static Color EaseOutSine(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseOutSine(t));
	}

	public static Color EaseInOutSine(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInOutSine(t));
	}

	public static float EaseInCircular(float t)
	{
		return 0f - (Mathf.Sqrt(1f - t * t) - 1f);
	}

	public static float EaseOutCircular(float t)
	{
		t -= 1f;
		return Mathf.Sqrt(1f - t * t);
	}

	public static float EaseInOutCircular(float t)
	{
		t *= 2f;
		if (t < 1f)
		{
			return -0.5f * (Mathf.Sqrt(1f - t * t) - 1f);
		}
		t -= 2f;
		return 0.5f * (Mathf.Sqrt(1f - t * t) + 1f);
	}

	public static float EaseInCircular(float from, float to, float t)
	{
		return Lerp(from, to, EaseInCircular(t));
	}

	public static float EaseOutCircular(float from, float to, float t)
	{
		return Lerp(from, to, EaseOutCircular(t));
	}

	public static float EaseInOutCircular(float from, float to, float t)
	{
		return Lerp(from, to, EaseInOutCircular(t));
	}

	public static Vector3 EaseInCircular(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInCircular(t));
	}

	public static Vector3 EaseOutCircular(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseOutCircular(t));
	}

	public static Vector3 EaseInOutCircular(Vector3 from, Vector3 to, float t)
	{
		return Lerp(from, to, EaseInOutCircular(t));
	}

	public static Vector2 EaseInCircular(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInCircular(t));
	}

	public static Vector2 EaseOutCircular(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseOutCircular(t));
	}

	public static Vector2 EaseInOutCircular(Vector2 from, Vector2 to, float t)
	{
		return Lerp(from, to, EaseInOutCircular(t));
	}

	public static Color EaseInCircular(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInCircular(t));
	}

	public static Color EaseOutCircular(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseOutCircular(t));
	}

	public static Color EaseInOutCircular(Color from, Color to, float t)
	{
		return Lerp(from, to, EaseInOutCircular(t));
	}

	public static Vector2 Slerp(Vector2 from, Vector2 to, float t)
	{
		if (from == to)
		{
			return from;
		}
		float value = Vector2.Dot(from, to);
		value = Mathf.Clamp(value, -0.999f, 1f);
		float num = Mathf.Acos(value);
		if (num == 0f)
		{
			return from;
		}
		double num2 = Mathf.Sin(num);
		return (float)((double)Mathf.Sin((1f - t) * num) / num2) * from + (float)((double)Mathf.Sin(t * num) / num2) * to;
	}

	public static Vector3 Slerp(Vector3 from, Vector3 to, float t)
	{
		return Vector3.Slerp(from, to, t);
	}

	public static Quaternion Slerp(Quaternion from, Quaternion to, float t)
	{
		return Quaternion.Slerp(from, to, t);
	}

	public static float Approach(float current, float to, float speed)
	{
		return Lerp(current, to, speed);
	}

	public static Vector3 Approach(Vector3 current, Vector3 to, float speed)
	{
		return Vector3.Lerp(current, to, speed);
	}

	public static Vector2 Approach(Vector2 current, Vector2 to, float speed)
	{
		return Vector2.Lerp(current, to, speed);
	}

	public static Color Approach(Color current, Color to, float speed)
	{
		return Color.Lerp(current, to, speed);
	}

	public static float ApproachExp(float actual, float to, float speed)
	{
		return actual + (to - actual) * speed;
	}

	public static Vector3 ApproachExp(Vector3 actual, Vector3 to, float speed)
	{
		return actual + (to - actual) * speed;
	}

	public static Vector2 ApproachExp(Vector2 actual, Vector2 to, float speed)
	{
		return actual + (to - actual) * speed;
	}

	public static Color ApproachExp(Color actual, Color to, float speed)
	{
		return actual + (to - actual) * speed;
	}

	public static Vector3 Bezier(Vector3 vP1, Vector3 vP2, Vector3 vP3, Vector3 vP4, float t)
	{
		float num = 1f - t;
		float num2 = t * t;
		float num3 = num * num;
		float num4 = num2 * t;
		float num5 = 3f * num2 * num;
		float num6 = 3f * t * num3;
		float num7 = num3 * num;
		return num7 * vP1 + num6 * vP2 + num5 * vP3 + num4 * vP4;
	}

	public static Vector3 CatmullRom(Vector3 vP0, Vector3 vP1, Vector3 vP2, Vector3 vP3, float t)
	{
		return 0.5f * (2f * vP1 + (-vP0 + vP2) * t + (2f * vP0 - 5f * vP1 + 4f * vP2 - vP3) * t * t + (-vP0 + 3f * vP1 - 3f * vP2 + vP3) * t * t * t);
	}

	public static float Hermite(float start, float end, float value)
	{
		return Mathf.Lerp(start, end, value * value * (3f - 2f * value));
	}

	public static float Sinerp(float start, float end, float value)
	{
		return Mathf.Lerp(start, end, Mathf.Sin(value * (float)Math.PI * 0.5f));
	}

	public static float Coserp(float start, float end, float value)
	{
		return Mathf.Lerp(start, end, 1f - Mathf.Cos(value * (float)Math.PI * 0.5f));
	}

	public static float Berp(float start, float end, float value)
	{
		value = Mathf.Clamp01(value);
		value = (Mathf.Sin(value * (float)Math.PI * (0.2f + 2.5f * value * value * value)) * Mathf.Pow(1f - value, 2.2f) + value) * (1f + 1.2f * (1f - value));
		return start + (end - start) * value;
	}

	public static float Bounce(float x)
	{
		return Mathf.Abs(Mathf.Sin(6.28f * (x + 1f) * (x + 1f)) * (1f - x));
	}

	public static float Clerp(float start, float end, float value)
	{
		float num = 0f;
		float num2 = 360f;
		float num3 = Mathf.Abs((num2 - num) / 2f);
		float num4 = 0f;
		float num5 = 0f;
		if (end - start < 0f - num3)
		{
			num5 = (num2 - start + end) * value;
			return start + num5;
		}
		if (end - start > num3)
		{
			num5 = (0f - (num2 - end + start)) * value;
			return start + num5;
		}
		return start + (end - start) * value;
	}
}
public class LinearBlur
{
	private float _rSum;

	private float _gSum;

	private float _bSum;

	private Texture2D _sourceImage;

	private int _sourceWidth;

	private int _sourceHeight;

	private int _windowSize;

	public Texture2D Blur(Texture2D image, int radius, int iterations)
	{
		_windowSize = radius * 2 + 1;
		_sourceWidth = image.width;
		_sourceHeight = image.height;
		Texture2D texture2D = image;
		for (int i = 0; i < iterations; i++)
		{
			texture2D = OneDimensialBlur(texture2D, radius, horizontal: true);
			texture2D = OneDimensialBlur(texture2D, radius, horizontal: false);
		}
		return texture2D;
	}

	private Texture2D OneDimensialBlur(Texture2D image, int radius, bool horizontal)
	{
		_sourceImage = image;
		Texture2D texture2D = new Texture2D(image.width, image.height, image.format, mipmap: false);
		if (horizontal)
		{
			for (int i = 0; i < _sourceHeight; i++)
			{
				ResetSum();
				for (int j = 0; j < _sourceWidth; j++)
				{
					if (j == 0)
					{
						for (int k = radius * -1; k <= radius; k++)
						{
							AddPixel(GetPixelWithXCheck(k, i));
						}
					}
					else
					{
						Color pixelWithXCheck = GetPixelWithXCheck(j - radius - 1, i);
						Color pixelWithXCheck2 = GetPixelWithXCheck(j + radius, i);
						SubstPixel(pixelWithXCheck);
						AddPixel(pixelWithXCheck2);
					}
					texture2D.SetPixel(j, i, CalcPixelFromSum());
				}
			}
		}
		else
		{
			for (int l = 0; l < _sourceWidth; l++)
			{
				ResetSum();
				for (int m = 0; m < _sourceHeight; m++)
				{
					if (m == 0)
					{
						for (int n = radius * -1; n <= radius; n++)
						{
							AddPixel(GetPixelWithYCheck(l, n));
						}
					}
					else
					{
						Color pixelWithYCheck = GetPixelWithYCheck(l, m - radius - 1);
						Color pixelWithYCheck2 = GetPixelWithYCheck(l, m + radius);
						SubstPixel(pixelWithYCheck);
						AddPixel(pixelWithYCheck2);
					}
					texture2D.SetPixel(l, m, CalcPixelFromSum());
				}
			}
		}
		texture2D.Apply();
		return texture2D;
	}

	private Color GetPixelWithXCheck(int x, int y)
	{
		if (x <= 0)
		{
			return _sourceImage.GetPixel(0, y);
		}
		if (x >= _sourceWidth)
		{
			return _sourceImage.GetPixel(_sourceWidth - 1, y);
		}
		return _sourceImage.GetPixel(x, y);
	}

	private Color GetPixelWithYCheck(int x, int y)
	{
		if (y <= 0)
		{
			return _sourceImage.GetPixel(x, 0);
		}
		if (y >= _sourceHeight)
		{
			return _sourceImage.GetPixel(x, _sourceHeight - 1);
		}
		return _sourceImage.GetPixel(x, y);
	}

	private void AddPixel(Color pixel)
	{
		_rSum += pixel.r;
		_gSum += pixel.g;
		_bSum += pixel.b;
	}

	private void SubstPixel(Color pixel)
	{
		_rSum -= pixel.r;
		_gSum -= pixel.g;
		_bSum -= pixel.b;
	}

	private void ResetSum()
	{
		_rSum = 0f;
		_gSum = 0f;
		_bSum = 0f;
	}

	private Color CalcPixelFromSum()
	{
		return new Color(_rSum / (float)_windowSize, _gSum / (float)_windowSize, _bSum / (float)_windowSize);
	}
}
public class LinkedPrefab : MonoBehaviour
{
	public GameObject prefab;

	private void Awake()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(prefab);
		gameObject.transform.parent = base.transform.parent;
		gameObject.transform.position = base.transform.position;
		gameObject.transform.rotation = base.transform.rotation;
		gameObject.name = base.gameObject.name;
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class LSystem<T> where T : new()
{
	public struct Symbol
	{
		public Action<int, LSeq> rule;

		public T leaf;

		public bool hasValidLeaf;

		public Symbol(Action<int, LSeq> rule)
		{
			this.rule = rule;
			leaf = new T();
			hasValidLeaf = false;
		}

		public Symbol(T leaf)
		{
			rule = null;
			this.leaf = leaf;
			hasValidLeaf = true;
		}

		public bool IsRule()
		{
			return rule != null;
		}

		public bool IsTerminal()
		{
			return rule == null && hasValidLeaf;
		}

		public bool IsEmpty()
		{
			return rule == null && !hasValidLeaf;
		}

		public void ApplyRule(int capacity, LSeq seq)
		{
			rule(capacity, seq);
		}
	}

	public class LSeq
	{
		public List<Symbol> symbols;

		public LSeq()
		{
			symbols = new List<Symbol>();
		}

		public void Add(Symbol symbol)
		{
			symbols.Add(symbol);
		}

		public void Add(T leafSymbol)
		{
			symbols.Add(new Symbol(leafSymbol));
		}

		public void Add(Action<int, LSeq> ruleSymbol)
		{
			symbols.Add(new Symbol(ruleSymbol));
		}

		public int GetTerminalLength()
		{
			int num = 0;
			for (int i = 0; i < symbols.Count; i++)
			{
				if (symbols[i].IsTerminal())
				{
					num++;
				}
			}
			return num;
		}

		public void Expand(int idx, LSeq newSymbols)
		{
			symbols.RemoveAt(idx);
			for (int num = newSymbols.symbols.Count - 1; num >= 0; num--)
			{
				symbols.Insert(idx, newSymbols.symbols[num]);
			}
		}

		public List<T> Resolve()
		{
			List<T> list = new List<T>();
			for (int i = 0; i < symbols.Count; i++)
			{
				if (symbols[i].IsTerminal())
				{
					list.Add(symbols[i].leaf);
				}
			}
			return list;
		}
	}

	public List<T> Process(int capacity)
	{
		LSeq lSeq = new LSeq();
		Axiom(capacity, lSeq);
		List<Pair<int, LSeq>> list = new List<Pair<int, LSeq>>();
		bool flag = true;
		while (flag && capacity > lSeq.GetTerminalLength())
		{
			int num = 0;
			flag = false;
			int capacity2 = capacity - lSeq.GetTerminalLength();
			for (int i = 0; i < lSeq.symbols.Count; i++)
			{
				if (lSeq.symbols[i].IsRule())
				{
					if (num >= list.Count)
					{
						list.Add(new Pair<int, LSeq>(-1, new LSeq()));
					}
					list[num] = new Pair<int, LSeq>(i, list[num].Second);
					list[num].Second.symbols.Clear();
					lSeq.symbols[i].ApplyRule(capacity2, list[num].Second);
					num++;
					flag = true;
				}
			}
			for (int j = 0; j < num; j++)
			{
				lSeq.Expand(list[j].First, list[j].Second);
			}
		}
		return lSeq.Resolve();
	}

	public virtual void Axiom(int capacity, LSeq seq)
	{
	}

	protected Symbol Delay(Symbol delayed)
	{
		Action<int, LSeq> rule = delegate(int capacity, LSeq seq)
		{
			seq.Add(delayed);
		};
		return new Symbol(rule);
	}

	protected Symbol Delay(Action<int, LSeq> ruleSymbol)
	{
		return Delay(new Symbol(ruleSymbol));
	}

	protected Symbol Delay(T leafSymbol)
	{
		return Delay(new Symbol(leafSymbol));
	}

	protected void Choose(params Action[] options)
	{
		int num = UnityEngine.Random.Range(0, options.Length);
		options[num]();
	}

	public virtual string GetName()
	{
		return GetType().Name;
	}
}
public class TestGrammar : LSystem<char>
{
	public override void Axiom(int capacity, LSeq seq)
	{
		if (capacity <= 4)
		{
			seq.Add(H);
			return;
		}
		seq.Add('A');
		seq.Add('A');
		seq.Add('B');
		seq.Add(Delay(Axiom));
	}

	public void H(int capacity, LSeq seq)
	{
		if (capacity >= 1)
		{
			seq.Add('A');
			seq.Add(Delay(H));
		}
	}

	public void G(int capacity, LSeq seq)
	{
		if (capacity >= 1)
		{
			Choose(delegate
			{
				seq.Add('A');
			}, delegate
			{
				seq.Add('C');
			});
			seq.Add(Delay(G));
		}
	}
}
public class Pathfinder
{
	public class Node : IComparable<Node>
	{
		public enum EDirection
		{
			None,
			North,
			NorthEast,
			East,
			SouthEast,
			South,
			SouthWest,
			West,
			NorthWest
		}

		public Point Pos;

		public Node Parent;

		public float CostToNode;

		public float TotalCost;

		public bool InOpen;

		public bool InClosed;

		public EDirection LastDirection;

		public int CompareTo(Node tNode)
		{
			if (TotalCost < tNode.TotalCost)
			{
				return -1;
			}
			if (TotalCost > tNode.TotalCost)
			{
				return 1;
			}
			return 0;
		}

		public static EDirection ComputeDirection(Point prev, Point next)
		{
			Point point = new Point(next.X - prev.X, next.Y - prev.Y);
			if (point.X == 0 && point.Y < 0)
			{
				return EDirection.North;
			}
			if (point.X > 0 && point.Y < 0)
			{
				return EDirection.NorthEast;
			}
			if (point.X > 0 && point.Y == 0)
			{
				return EDirection.East;
			}
			if (point.X > 0 && point.Y > 0)
			{
				return EDirection.SouthEast;
			}
			if (point.X == 0 && point.Y > 0)
			{
				return EDirection.South;
			}
			if (point.X < 0 && point.Y > 0)
			{
				return EDirection.SouthWest;
			}
			if (point.X < 0 && point.Y == 0)
			{
				return EDirection.West;
			}
			if (point.X < 0 && point.Y < 0)
			{
				return EDirection.NorthWest;
			}
			return EDirection.None;
		}
	}

	public delegate float GetCostHandler(Point init, Point end, object movementDesc);

	public delegate bool CheckTraversalHandler(Point from, Point end, object movementDesc);

	public class Query
	{
		public enum EState
		{
			Pending,
			Running,
			Success,
			Failure
		}

		private Pathfinder Owner;

		public Point Init;

		public Point End;

		public EState State;

		public List<Point> Path;

		public object MovementDesc;

		public int numUpdates;

		public GetCostHandler EstimateCost;

		public GetCostHandler TraversalCost;

		public CheckTraversalHandler CheckTraversal;

		public float ChangeDirectionCost;

		public Query(Pathfinder owner)
		{
			Owner = owner;
			Path = new List<Point>(50);
			EstimateCost = (TraversalCost = null);
			CheckTraversal = null;
			ChangeDirectionCost = 0f;
			numUpdates = 0;
		}

		public void Initialize(Point init, Point end, object movementDesc, CheckTraversalHandler checkTraversal, GetCostHandler traversalCost, GetCostHandler estimateCost, float changeDirectionCost)
		{
			Init = init;
			End = end;
			State = EState.Pending;
			MovementDesc = movementDesc;
			CheckTraversal = checkTraversal;
			TraversalCost = traversalCost;
			EstimateCost = estimateCost;
			Path.Clear();
			ChangeDirectionCost = changeDirectionCost;
			numUpdates = 0;
		}

		public void Initialize(Point init, Point end, object movementDesc)
		{
			Initialize(init, end, movementDesc, null, null, null, 0f);
		}

		public void Initialize(Point init, Point end, object movementDesc, CheckTraversalHandler checkTraversal)
		{
			Initialize(init, end, movementDesc, checkTraversal, null, null, 0f);
		}

		public bool IsFinished()
		{
			return State == EState.Success || State == EState.Failure;
		}

		public bool IsSuccess()
		{
			return State == EState.Success;
		}

		public void Free()
		{
			Owner.FreeQuery(this);
		}
	}

	private static Pathfinder instance;

	public int iterationLimit = 120;

	private List<Node> m_CachedNodes = new List<Node>(1500);

	private int m_NextNode;

	private Dictionary<Point, Node> m_ActiveNodes = new Dictionary<Point, Node>(1500);

	private BinaryHeap<Node> m_OpenList = new BinaryHeap<Node>();

	private Queue<Query> m_PendingQueries = new Queue<Query>(16);

	private Query m_ActiveQuery;

	private GetCostHandler EstimateCostDelegate;

	private GetCostHandler TraversalCostDelegate;

	private CheckTraversalHandler CheckTraversalDelegate;

	private List<Query> m_listFreeQueries = new List<Query>(16);

	public Pathfinder(int iterationLimit = 120)
	{
		EstimateCostDelegate = DefaultEstimateCost;
		TraversalCostDelegate = DefaultGetTraversalCost;
		CheckTraversalDelegate = DefaultCheckTraversal;
		this.iterationLimit = iterationLimit;
	}

	public static Pathfinder Get()
	{
		if (instance == null)
		{
			instance = new Pathfinder();
		}
		return instance;
	}

	public static void Clear()
	{
		instance = null;
	}

	public Query AddQuery(Point init, Point end, object movementDesc, CheckTraversalHandler checkTraversal, GetCostHandler traversalCost, GetCostHandler estimateCost, float changeDirectionCost)
	{
		Query query = null;
		if (m_listFreeQueries.Count > 0)
		{
			query = m_listFreeQueries[0];
			m_listFreeQueries.RemoveAt(0);
		}
		else
		{
			query = new Query(this);
		}
		query.Initialize(init, end, movementDesc, checkTraversal, traversalCost, estimateCost, changeDirectionCost);
		m_PendingQueries.Enqueue(query);
		return query;
	}

	public Query AddQuery(Point init, Point end, object movementDesc, CheckTraversalHandler checkTraversal)
	{
		return AddQuery(init, end, movementDesc, checkTraversal, null, null, 0f);
	}

	public Query AddQuery(Point init, Point end, object movementDesc)
	{
		return AddQuery(init, end, movementDesc, null, null, null, 0f);
	}

	private Node AddNode(Point pos)
	{
		Node node = null;
		if (m_NextNode < m_CachedNodes.Count)
		{
			node = m_CachedNodes[m_NextNode++];
		}
		else
		{
			node = new Node();
			m_CachedNodes.Add(node);
			m_NextNode++;
		}
		node.Pos = pos;
		node.Parent = null;
		node.CostToNode = 0f;
		node.TotalCost = 0f;
		node.InOpen = false;
		node.InClosed = false;
		m_ActiveNodes[pos] = node;
		return node;
	}

	private void AddToOpen(Node tNode)
	{
		tNode.InOpen = true;
		m_OpenList.Push(tNode);
	}

	public float DefaultEstimateCost(Point init, Point end, object movementDesc)
	{
		return (new Vector2(init.X, init.Y) - new Vector2(end.X, end.Y)).magnitude;
	}

	public float DefaultGetTraversalCost(Point from, Point end, object movementDesc)
	{
		return (new Vector2(end.X, end.Y) - new Vector2(from.X, from.Y)).magnitude;
	}

	public bool DefaultCheckTraversal(Point from, Point end, object movementDesc)
	{
		return true;
	}

	public void Update()
	{
		if (m_ActiveQuery == null && m_PendingQueries.Count > 0)
		{
			m_ActiveQuery = m_PendingQueries.Dequeue();
		}
		if (m_ActiveQuery != null)
		{
			m_ActiveQuery.numUpdates++;
			if (RunAStar(m_ActiveQuery, iterationLimit))
			{
				m_ActiveQuery = null;
			}
		}
	}

	public bool RunAStar(Query query)
	{
		return RunAStar(query, int.MaxValue);
	}

	public bool RunAStar(Query query, int iterationLimit)
	{
		if (query.IsFinished())
		{
			return true;
		}
		if (query.State == Query.EState.Pending)
		{
			query.State = Query.EState.Running;
			m_NextNode = 0;
			m_ActiveNodes.Clear();
			m_OpenList.Clear();
			if (query.EstimateCost == null)
			{
				query.EstimateCost = EstimateCostDelegate;
			}
			if (query.TraversalCost == null)
			{
				query.TraversalCost = TraversalCostDelegate;
			}
			if (query.CheckTraversal == null)
			{
				query.CheckTraversal = CheckTraversalDelegate;
			}
			Node node = AddNode(query.Init);
			node.CostToNode = 0f;
			node.TotalCost = query.EstimateCost(query.Init, query.End, query.MovementDesc);
			node.Parent = null;
			AddToOpen(node);
		}
		for (int i = 0; i < iterationLimit; i++)
		{
			if (m_OpenList.Count == 0)
			{
				query.State = Query.EState.Failure;
				m_NextNode = 0;
				m_ActiveNodes.Clear();
				m_OpenList.Clear();
				return true;
			}
			Node node2 = m_OpenList.Pop();
			node2.InOpen = false;
			if (node2.Pos == query.End)
			{
				query.State = Query.EState.Success;
				query.Path.Clear();
				for (Node node3 = node2; node3 != null; node3 = node3.Parent)
				{
					query.Path.Insert(0, node3.Pos);
				}
				m_NextNode = 0;
				m_ActiveNodes.Clear();
				m_OpenList.Clear();
				return true;
			}
			for (int j = node2.Pos.X - 1; j <= node2.Pos.X + 1; j++)
			{
				for (int k = node2.Pos.Y - 1; k <= node2.Pos.Y + 1; k++)
				{
					Point point = new Point(j, k);
					if (node2.Pos == point || !query.CheckTraversal(node2.Pos, point, query.MovementDesc))
					{
						continue;
					}
					Node.EDirection eDirection = Node.ComputeDirection(node2.Pos, point);
					float num = node2.CostToNode + query.TraversalCost(node2.Pos, point, query.MovementDesc);
					if (eDirection != node2.LastDirection)
					{
						num += query.ChangeDirectionCost;
					}
					Node value = null;
					if (m_ActiveNodes.TryGetValue(point, out value))
					{
						if (value.CostToNode <= num)
						{
							continue;
						}
					}
					else
					{
						value = AddNode(point);
					}
					value.Parent = node2;
					value.CostToNode = num;
					value.TotalCost = num + query.EstimateCost(value.Pos, query.End, query.MovementDesc);
					value.InClosed = false;
					value.LastDirection = eDirection;
					if (value.InOpen)
					{
						int index = m_OpenList.IndexOf(value);
						m_OpenList.SiftUp(index);
					}
					else
					{
						AddToOpen(value);
					}
				}
			}
			node2.InClosed = true;
		}
		return false;
	}

	public void FreeQuery(Query query)
	{
		m_listFreeQueries.Add(query);
	}
}
public class Permutator
{
	private int Hits;

	private int SeqLength;

	private int InitWait;

	private int MaxStreak;

	private List<bool> Sequence;

	public bool Next
	{
		get
		{
			if (Sequence.Count == 0)
			{
				GenerateSequence();
			}
			bool result = Sequence[0];
			Sequence.RemoveAt(0);
			return result;
		}
	}

	public Permutator(int hits, int seqLength, int initWait = 0)
	{
		Hits = hits;
		SeqLength = seqLength;
		InitWait = initWait;
		if (SeqLength - InitWait < Hits)
		{
			Hits = SeqLength - InitWait;
		}
		Sequence = new List<bool>();
		GenerateSequence();
	}

	public bool PeekNext()
	{
		if (Sequence.Count == 0)
		{
			GenerateSequence();
		}
		return Sequence[0];
	}

	private void GenerateSequence()
	{
		for (int i = 0; i < SeqLength; i++)
		{
			Sequence.Add(item: false);
		}
		for (int j = 0; j < Hits; j++)
		{
			int index;
			do
			{
				index = UnityEngine.Random.Range(InitWait, SeqLength);
			}
			while (Sequence[index]);
			Sequence[index] = true;
		}
	}
}
[AddComponentMenu("Rendering/SetRenderQueue")]
public class SetRenderQueue : MonoBehaviour
{
	[SerializeField]
	protected int[] m_queues = new int[1] { 2020 };

	protected void Awake()
	{
		Material[] materials = GetComponent<Renderer>().materials;
		for (int i = 0; i < materials.Length && i < m_queues.Length; i++)
		{
			materials[i].renderQueue += m_queues[i];
		}
	}
}
public class Singleton : MonoBehaviour
{
	protected static Singleton instance;

	protected void Awake()
	{
		if (instance != null && instance != this)
		{
			UnityEngine.Object.DestroyImmediate(base.gameObject);
			return;
		}
		instance = this;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}
}
public class TimeIndependentAnimation : TimeIndependentBehaviour
{
	public bool playOnStart;

	public string playOnStartStateName;

	private AnimationState currentState;

	private Action currentCompletionHandler;

	private float elapsedTime;

	private bool playing;

	private void Start()
	{
		if (playOnStart)
		{
			Play(playOnStartStateName);
		}
	}

	protected override void Update()
	{
		base.Update();
		if (!playing)
		{
			return;
		}
		elapsedTime += base.deltaTime;
		currentState.normalizedTime = elapsedTime / currentState.length;
		if (elapsedTime >= currentState.length)
		{
			playing = false;
			if (currentState.wrapMode == WrapMode.Loop)
			{
				Play(currentState.name);
			}
			else if (currentCompletionHandler != null)
			{
				currentCompletionHandler();
			}
		}
	}

	public void Play(string stateName, Action completionHandler = null)
	{
		elapsedTime = 0f;
		currentState = GetComponent<Animation>()[stateName];
		currentState.normalizedTime = 0f;
		currentState.enabled = true;
		currentState.weight = 1f;
		currentCompletionHandler = completionHandler;
		playing = true;
	}
}
public class TimeIndependentBehaviour : MonoBehaviour
{
	public bool pausable;

	private float previousTimeSinceStartup;

	public float deltaTime { get; private set; }

	protected virtual void Awake()
	{
		previousTimeSinceStartup = Time.realtimeSinceStartup;
	}

	protected virtual void OnEnable()
	{
		previousTimeSinceStartup = Time.realtimeSinceStartup;
	}

	protected virtual void Update()
	{
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		deltaTime = Mathf.Clamp(realtimeSinceStartup - previousTimeSinceStartup, 0f, 0.33333f);
		previousTimeSinceStartup = realtimeSinceStartup;
		if (deltaTime < 0f)
		{
			deltaTime = 0f;
		}
		if (pausable && GameController.Get().Paused)
		{
			deltaTime = 0f;
		}
	}

	public IEnumerator TimeIndependentWaitForSeconds(float seconds)
	{
		for (float elapsedTime = 0f; elapsedTime < seconds; elapsedTime += deltaTime)
		{
			yield return null;
		}
	}

	protected void PlayClipAtPoint(AudioClip clip, Vector3 pos)
	{
		float timeScale = Time.timeScale;
		bool flag = timeScale == 0f;
		if (flag)
		{
			Time.timeScale = 1f;
		}
		AudioSource.PlayClipAtPoint(clip, pos);
		if (flag)
		{
			Time.timeScale = timeScale;
		}
	}

	protected void PlayClipAtPoint(AudioClip clip, Vector3 pos, float volume)
	{
		float timeScale = Time.timeScale;
		bool flag = timeScale == 0f;
		if (flag)
		{
			Time.timeScale = 1f;
		}
		AudioSource.PlayClipAtPoint(clip, pos, volume);
		if (flag)
		{
			Time.timeScale = timeScale;
		}
	}

	protected void UpdateTimeSinceStartup()
	{
		previousTimeSinceStartup = Time.realtimeSinceStartup;
	}
}
public class TimeIndependentParticleSystem : TimeIndependentBehaviour
{
	protected override void Update()
	{
		base.Update();
		GetComponent<ParticleSystem>().Simulate(base.deltaTime, withChildren: true, restart: false);
	}
}
public class Translate
{
	private static Translate instance;

	private Dictionary<string, Dictionary<string, string>> langTables;

	private Dictionary<string, string> curTable;

	private string curLangIndex = string.Empty;

	private Translate()
	{
		langTables = new Dictionary<string, Dictionary<string, string>>();
	}

	public static Translate Instance()
	{
		if (instance == null)
		{
			instance = new Translate();
		}
		return instance;
	}

	public static void LoadBaseFolder(string basePath)
	{
		Translate translate = Instance();
		SystemLanguage[] array = (SystemLanguage[])Enum.GetValues(typeof(SystemLanguage));
		for (int i = 0; i < array.Length; i++)
		{
			SystemLanguage systemLanguage = array[i];
			string text = systemLanguage.ToString().ToLower();
			translate.LoadFolder(basePath + "/" + text, text);
		}
		translate.curLangIndex = "english";
		translate.curTable = translate.langTables["english"];
	}

	private bool LoadFolder(string path, string langName = "english")
	{
		TextAsset[] array = Resources.LoadAll<TextAsset>(path);
		if (array.Length == 0)
		{
			return false;
		}
		if (!langTables.TryGetValue(langName, out var value))
		{
			value = new Dictionary<string, string>();
			langTables[langName] = value;
		}
		TextAsset[] array2 = array;
		foreach (TextAsset textAsset in array2)
		{
			ProcessFile(textAsset, value);
		}
		return true;
	}

	private void ProcessFile(TextAsset textAsset, Dictionary<string, string> langTable)
	{
		StringReader stringReader = new StringReader(textAsset.text);
		char[] trimChars = new char[2] { ' ', '\t' };
		string text;
		while ((text = stringReader.ReadLine()) != null)
		{
			text = text.TrimEnd(trimChars);
			if (text.Length >= 2 && text[0] == '"')
			{
				int num = text.IndexOf('"', 1);
				string key = text.Substring(1, num - 1);
				int num2 = text.IndexOf('"', num + 1);
				string str = text.Substring(num2 + 1, text.Length - 1 - (num2 + 1));
				str = Regex.Unescape(str);
				langTable[key] = str;
			}
		}
	}

	public static bool SetLanguage(string index)
	{
		if (Instance().langTables.ContainsKey(index))
		{
			Instance().curLangIndex = index;
			Instance().curTable = Instance().langTables[index];
			return true;
		}
		return false;
	}

	public static string GetLanguage()
	{
		return Instance().curLangIndex;
	}

	public static void SetSystemLanguage()
	{
		SystemLanguage systemLanguage = UnityEngine.Application.systemLanguage;
		string language = systemLanguage.ToString().ToLower();
		if (systemLanguage == SystemLanguage.ChineseTraditional || systemLanguage == SystemLanguage.ChineseSimplified)
		{
			language = "chinese";
		}
		SetLanguage(language);
	}

	public static string[] ListLanguages()
	{
		Dictionary<string, Dictionary<string, string>>.KeyCollection keys = Instance().langTables.Keys;
		string[] array = new string[keys.Count];
		int num = 0;
		foreach (string item in keys)
		{
			array[num++] = item;
		}
		return array;
	}

	public static string Get(string key)
	{
		Translate translate = Instance();
		if (translate.curTable == null)
		{
			return "[[NO LANGUAGE SELECTED]]";
		}
		if (!translate.curTable.TryGetValue(key, out var value))
		{
			return "[[" + key + "]]";
		}
		return value;
	}

	public static string GetOrKey(string key)
	{
		return Get(key);
	}

	public static string GetForInput(string key)
	{
		if (InputExt.UsingHandControllers)
		{
			bool leftHanded = InputExt.LeftHanded;
			string key2 = key + "_TOUCH" + ((!leftHanded) ? "_RIGHT" : "_LEFT");
			if (Check(key2))
			{
				return Get(key2);
			}
			key2 = key + "_TOUCH";
			if (Check(key2))
			{
				return Get(key2);
			}
		}
		else if (InputExt.Using3DOFController)
		{
			string key3 = key + "_3DOF";
			if (Check(key3))
			{
				return Get(key3);
			}
		}
		return GetOrKey(key);
	}

	public static string GetOrEnglish(string key)
	{
		Translate translate = Instance();
		if (translate.curTable == null)
		{
			return "[[NO LANGUAGE SELECTED]]";
		}
		if (!translate.curTable.TryGetValue(key, out var value) && !translate.langTables["english"].TryGetValue(key, out value))
		{
			return "[[" + key + "]]";
		}
		return value;
	}

	public static bool Check(string key)
	{
		Translate translate = Instance();
		return translate.curTable.ContainsKey(key);
	}
}
public class BinaryHeap<T> where T : IComparable<T>
{
	private List<T> m_Elements = new List<T>();

	public int Count => m_Elements.Count;

	public void Clear()
	{
		m_Elements.Clear();
	}

	public void Push(T item)
	{
		m_Elements.Add(item);
		SiftUp(m_Elements.Count - 1);
	}

	public T Peek()
	{
		return m_Elements[0];
	}

	public T Pop()
	{
		T result = m_Elements[0];
		m_Elements[0] = m_Elements[m_Elements.Count - 1];
		m_Elements.RemoveAt(m_Elements.Count - 1);
		SiftDown(0);
		return result;
	}

	public int IndexOf(T item)
	{
		return m_Elements.IndexOf(item);
	}

	public void SiftUp(int index)
	{
		while (index != 0 && m_Elements[index].CompareTo(m_Elements[index / 2]) < 0)
		{
			T value = m_Elements[index];
			m_Elements[index] = m_Elements[index / 2];
			m_Elements[index / 2] = value;
			index /= 2;
		}
	}

	public void SiftDown(int indexSwap)
	{
		while (true)
		{
			int num = indexSwap;
			if (2 * num + 1 <= m_Elements.Count - 1)
			{
				if (m_Elements[num * 2].CompareTo(m_Elements[num]) < 0)
				{
					indexSwap = num * 2;
				}
				if (m_Elements[num * 2 + 1].CompareTo(m_Elements[indexSwap]) < 0)
				{
					indexSwap = num * 2 + 1;
				}
			}
			else if (2 * num <= m_Elements.Count - 1 && m_Elements[num * 2].CompareTo(m_Elements[num]) < 0)
			{
				indexSwap = num * 2;
			}
			if (num == indexSwap)
			{
				break;
			}
			T value = m_Elements[num];
			m_Elements[num] = m_Elements[indexSwap];
			m_Elements[indexSwap] = value;
		}
	}
}
[Serializable]
public class CPoint : IEquatable<CPoint>
{
	public int X;

	public int Y;

	public static CPoint Zero => new CPoint(0, 0);

	public CPoint(int x, int y)
	{
		X = x;
		Y = y;
	}

	public CPoint(Point point)
	{
		X = point.X;
		Y = point.Y;
	}

	public static bool operator !=(CPoint a, CPoint b)
	{
		return a.X != b.X || a.Y != b.Y;
	}

	public static bool operator ==(CPoint a, CPoint b)
	{
		return a.X == b.X && a.Y == b.Y;
	}

	public override bool Equals(object obj)
	{
		if (obj is CPoint)
		{
			return Equals((CPoint)obj);
		}
		return false;
	}

	public bool Equals(CPoint other)
	{
		return X == other.X && Y == other.Y;
	}

	public override int GetHashCode()
	{
		int num = 17;
		num = num * 23 + X.GetHashCode();
		return num * 23 + Y.GetHashCode();
	}

	public static CPoint operator +(CPoint p1, CPoint p2)
	{
		return new CPoint(p1.X + p2.X, p1.Y + p2.Y);
	}

	public static CPoint operator -(CPoint p1, CPoint p2)
	{
		return new CPoint(p1.X - p2.X, p1.Y - p2.Y);
	}

	public static CPoint operator /(CPoint p1, int v)
	{
		return new CPoint(p1.X / v, p1.Y / v);
	}

	public static CPoint operator *(CPoint p1, int v)
	{
		return new CPoint(p1.X * v, p1.Y * v);
	}

	public void Set(CPoint point)
	{
		X = point.X;
		Y = point.Y;
	}

	public void Set(Point point)
	{
		X = point.X;
		Y = point.Y;
	}

	public Point ToPoint()
	{
		return new Point(X, Y);
	}
}
public struct IntRect
{
	private int _xMin;

	private int _xMax;

	private int _yMin;

	private int _yMax;

	public int bottom => _yMax;

	public int height
	{
		get
		{
			return _yMax - _yMin;
		}
		set
		{
			_yMax = _yMin + value;
		}
	}

	public int left => _xMin;

	public int right => _xMax;

	public int top => _yMin;

	public int width
	{
		get
		{
			return _xMax - _xMin;
		}
		set
		{
			_xMax = _xMin + value;
		}
	}

	public int x
	{
		get
		{
			return _xMin;
		}
		set
		{
			_xMin = value;
		}
	}

	public int xMax
	{
		get
		{
			return _xMax;
		}
		set
		{
			_xMax = value;
		}
	}

	public int xMin
	{
		get
		{
			return _xMin;
		}
		set
		{
			_xMin = value;
		}
	}

	public int y
	{
		get
		{
			return _yMin;
		}
		set
		{
			_yMin = value;
		}
	}

	public int yMax
	{
		get
		{
			return _yMax;
		}
		set
		{
			_yMax = value;
		}
	}

	public int yMin
	{
		get
		{
			return _yMin;
		}
		set
		{
			_yMin = value;
		}
	}

	public IntRect(IntRect source)
	{
		_xMin = source.xMin;
		_xMax = source.xMax;
		_yMin = source.yMin;
		_yMax = source.yMax;
	}

	public IntRect(int left, int top, int width, int height)
	{
		_xMin = left;
		_yMin = top;
		_xMax = left + width;
		_yMax = top + height;
	}

	public static bool operator !=(IntRect lhs, IntRect rhs)
	{
		return lhs.xMin != rhs.xMin || lhs.yMin != rhs.yMin || lhs.xMax != rhs.xMax || lhs.yMax != rhs.yMax;
	}

	public static bool operator ==(IntRect lhs, IntRect rhs)
	{
		return lhs.xMin == rhs.xMin && lhs.yMin == rhs.yMin && lhs.xMax == rhs.xMax && lhs.yMax == rhs.yMax;
	}

	public bool Contains(Point point)
	{
		return point.X >= _xMin && point.X < _xMax && point.Y >= _yMin && point.Y < _yMax;
	}

	public override bool Equals(object other)
	{
		if (other is IntRect)
		{
			return (IntRect)other == this;
		}
		return false;
	}

	public override int GetHashCode()
	{
		int num = 17;
		num = num * 23 + _xMin.GetHashCode();
		num = num * 23 + _yMin.GetHashCode();
		num = num * 23 + _xMax.GetHashCode();
		return num * 23 + _yMax.GetHashCode();
	}

	public void Set(int left, int top, int width, int height)
	{
		_xMin = left;
		_yMin = top;
		_xMax = left + width;
		_yMax = top + height;
	}

	public override string ToString()
	{
		return "(" + _xMin + ", " + _yMin + ", " + width + ", " + height + ")";
	}
}
public struct Pair<T, U>
{
	public T First;

	public U Second;

	public Pair(T first, U second)
	{
		First = first;
		Second = second;
	}
}
public struct Point : IEquatable<Point>
{
	public int X;

	public int Y;

	public static Point Zero => new Point(0, 0);

	public Point(int x, int y)
	{
		X = x;
		Y = y;
	}

	public Point(CPoint cp)
	{
		X = cp.X;
		Y = cp.Y;
	}

	public static bool operator !=(Point a, Point b)
	{
		return a.X != b.X || a.Y != b.Y;
	}

	public static bool operator ==(Point a, Point b)
	{
		return a.X == b.X && a.Y == b.Y;
	}

	public override bool Equals(object obj)
	{
		if (obj is Point)
		{
			return Equals((Point)obj);
		}
		return false;
	}

	public bool Equals(Point other)
	{
		return X == other.X && Y == other.Y;
	}

	public override int GetHashCode()
	{
		int num = 17;
		num = num * 23 + X.GetHashCode();
		return num * 23 + Y.GetHashCode();
	}

	public static Point operator +(Point p1, Point p2)
	{
		return new Point(p1.X + p2.X, p1.Y + p2.Y);
	}

	public static Point operator -(Point p1, Point p2)
	{
		return new Point(p1.X - p2.X, p1.Y - p2.Y);
	}

	public static Point operator /(Point p1, int v)
	{
		return new Point(p1.X / v, p1.Y / v);
	}

	public static Point operator *(Point p1, int v)
	{
		return new Point(p1.X * v, p1.Y * v);
	}

	public float DistanceSq()
	{
		int num = Mathf.Abs(X);
		int num2 = Mathf.Abs(Y);
		return num * num + num2 * num2;
	}
}
public class Pool<T> where T : class, new()
{
	private List<T> items;

	private List<bool> availability;

	public Pool()
	{
		items = new List<T>();
		availability = new List<bool>();
	}

	public Pool(int capacity)
	{
		items = new List<T>(capacity);
		availability = new List<bool>(capacity);
		for (int i = 0; i < capacity; i++)
		{
			items.Add(new T());
			availability.Add(item: true);
		}
	}

	public T Get()
	{
		for (int i = 0; i < items.Count; i++)
		{
			if (availability[i])
			{
				availability[i] = false;
				return items[i];
			}
		}
		T val = new T();
		items.Add(val);
		availability.Add(item: false);
		return val;
	}

	public void Free(T item)
	{
		for (int i = 0; i < items.Count; i++)
		{
			if (items[i] == item)
			{
				availability[i] = true;
				break;
			}
		}
	}
}
namespace System
{
	public class Tuple<TItem1, TItem2>
	{
		public TItem1 Item1 { get; private set; }

		public TItem2 Item2 { get; private set; }

		public Tuple(TItem1 item1, TItem2 item2)
		{
			Item1 = item1;
			Item2 = item2;
		}

		public override bool Equals(object obj)
		{
			if (obj is Tuple<TItem1, TItem2>)
			{
				Tuple<TItem1, TItem2> tuple = (Tuple<TItem1, TItem2>)obj;
				return object.Equals(Item1, tuple.Item1) && object.Equals(Item2, tuple.Item2);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return ((Item1 != null) ? Item1.GetHashCode() : 0) ^ ((Item2 != null) ? Item2.GetHashCode() : 0);
		}

		public static bool operator ==(Tuple<TItem1, TItem2> left, Tuple<TItem1, TItem2> right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(Tuple<TItem1, TItem2> left, Tuple<TItem1, TItem2> right)
		{
			return !left.Equals(right);
		}
	}
	public class Tuple<TItem1, TItem2, TItem3>
	{
		public TItem1 Item1 { get; private set; }

		public TItem2 Item2 { get; private set; }

		public TItem3 Item3 { get; private set; }

		public Tuple(TItem1 item1, TItem2 item2, TItem3 item3)
		{
			Item1 = item1;
			Item2 = item2;
			Item3 = item3;
		}

		public override bool Equals(object obj)
		{
			if (obj is Tuple<TItem1, TItem2, TItem3>)
			{
				Tuple<TItem1, TItem2, TItem3> tuple = (Tuple<TItem1, TItem2, TItem3>)obj;
				return object.Equals(Item1, tuple.Item1) && object.Equals(Item2, tuple.Item2) && object.Equals(Item3, tuple.Item3);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return ((Item1 != null) ? Item1.GetHashCode() : 0) ^ ((Item2 != null) ? Item2.GetHashCode() : 0) ^ ((Item3 != null) ? Item3.GetHashCode() : 0);
		}

		public static bool operator ==(Tuple<TItem1, TItem2, TItem3> left, Tuple<TItem1, TItem2, TItem3> right)
		{
			return left.Equals(right);
		}

		public static bool operator ==(Tuple<TItem1, TItem2, TItem3> left, object right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(Tuple<TItem1, TItem2, TItem3> left, Tuple<TItem1, TItem2, TItem3> right)
		{
			return !left.Equals(right);
		}

		public static bool operator !=(Tuple<TItem1, TItem2, TItem3> left, object right)
		{
			return !left.Equals(right);
		}
	}
}
public class GameController : MonoBehaviour
{
	private static GameController instance;

	private static bool isFirstLoad = true;

	private bool firstUpdate = true;

	public bool UsingGamepad;

	public bool Win;

	public TextMesh debugText;

	public GameObject testObj;

	public LevelOptions levelOptions;

	public static LevelOptions nextOptions;

	public GameState gameState;

	private bool inGameScene;

	public Serializer serializer;

	public Fader fader;

	public Fader faderWin;

	public ClockMode.Mode clockMode;

	private bool needsRecenter;

	private bool paused;

	public bool wasJustPaused;

	private bool justRecentered;

	private float volumeMultiplier = 1f;

	private bool wasRightHanded;

	private float dpadAdjustTimer;

	private string gameOverText = string.Empty;

	private static bool checkedEntitlement;

	public bool Paused => paused;

	public bool HasJustRecentered => justRecentered;

	public float VolumeMultiplier
	{
		get
		{
			return volumeMultiplier;
		}
		set
		{
			if (volumeMultiplier != value)
			{
				volumeMultiplier = value;
				AudioListener.volume = Config.Audio().masterVolume * volumeMultiplier;
			}
		}
	}

	public bool IsInGameScene()
	{
		return inGameScene;
	}

	public static GameController Get()
	{
		return instance;
	}

	public static void Clear()
	{
		instance = null;
	}

	private void Awake()
	{
		Debug.Log("Starting Game Controller");
		instance = this;
		string[] joystickNames = Input.GetJoystickNames();
		Debug.Log("GameController - Loading config");
		Config.Load();
		InitializeTexts();
		AudioListener.volume = Config.Audio().masterVolume * volumeMultiplier;
		CheckEntitlement();
		serializer = new Serializer();
		gameState = GameState.Get();
		UsingGamepad = joystickNames.Length > 0;
		Cursor.visible = false;
		Screen.lockCursor = true;
		Screen.sleepTimeout = -1;
		MapBuilder component = GetComponent<MapBuilder>();
		if (component != null)
		{
			if (nextOptions != null)
			{
				levelOptions = nextOptions;
				nextOptions = null;
			}
			component.generatorType = levelOptions.generatorType;
			component.levelOptions = levelOptions;
		}
		inGameScene = component != null;
		Win = false;
		Time.timeScale = 1f;
		ClockMode.Set(clockMode);
		Debug.Log("GameController - DebugAwake");
		DebugAwake();
		Debug.Log("GameController - End Awake");
	}

	private void DebugAwake()
	{
		GetComponent<Screenshot>().enabled = false;
	}

	public static void InitializeTexts()
	{
		Debug.Log("GameController - Loading translate tables");
		Translate.LoadBaseFolder("Text");
		if (Config.General().language == string.Empty)
		{
			Translate.SetSystemLanguage();
			Config.General().language = Translate.GetLanguage();
			Config.Save();
		}
		else
		{
			Translate.SetLanguage(Config.General().language);
		}
	}

	private void Start()
	{
		Debug.Log("GameController - Start");
		if (isFirstLoad)
		{
			Debug.Log("First Load ResetOVROrientation");
			ResetOVROrientation();
		}
		if (isFirstLoad)
		{
			Debug.Log("Setting Foveated Rendering to: Low");
			OVRManager.tiledMultiResLevel = OVRManager.TiledMultiResLevel.LMSLow;
		}
		isFirstLoad = false;
		InputExt.ResetLeftHanded();
		UpdateInput(forceUpdate: true);
		if (InputExt.HasHandControllers)
		{
			InputExt.ResetLeftHanded();
		}
		Debug.Log("GameController - End Start");
	}

	private void LogHandler(string message, string stacktrace, LogType type)
	{
		if (type == LogType.Error || type == LogType.Exception)
		{
			StackTrace stackTrace = new StackTrace(1, fNeedFileInfo: true);
			Debug.Log("-+- STACK TRACE -+-\n" + stackTrace.ToString());
			using StreamWriter streamWriter = new StreamWriter("stack_trace.txt");
			streamWriter.WriteLine(message);
			streamWriter.WriteLine("------");
			streamWriter.WriteLine(stacktrace);
			streamWriter.WriteLine("--- STACK TRACE ---");
			streamWriter.WriteLine(StackTraceUtility.ExtractStackTrace());
			streamWriter.WriteLine("------");
			streamWriter.Write(stackTrace.ToString());
		}
	}

	private void OnEnable()
	{
		OVRManager.HMDUnmounted += LostFocus;
		OVRManager.HMDMounted += AcquiredFocus;
	}

	private void OnDisable()
	{
		OVRManager.HMDUnmounted -= LostFocus;
		OVRManager.HMDMounted -= AcquiredFocus;
		UnityEngine.Application.RegisterLogCallback(null);
	}

	private void Update()
	{
		if (firstUpdate)
		{
			firstUpdate = false;
			InputExt.ResetLeftHanded();
		}
		justRecentered = false;
		if (needsRecenter)
		{
			Debug.Log("Auto-recenter");
			ResetOVROrientation();
			needsRecenter = false;
		}
		if (Input.GetKeyDown(KeyCode.F11))
		{
			Screen.fullScreen = !Screen.fullScreen;
		}
		if (GetBackButtonDown() && UnityEngine.Application.loadedLevelName == "Intro")
		{
			IntroMenuController component = GetComponent<IntroMenuController>();
			if ((bool)component)
			{
				component.OnBackButton();
			}
			else
			{
				ExitGame();
			}
		}
		if (Input.GetMouseButtonDown(0))
		{
			Screen.lockCursor = true;
		}
		if (InputExt.Using3DOFController && ((wasRightHanded && !InputExt.RightHanded) || (!wasRightHanded && InputExt.RightHanded)))
		{
			UpdateInput();
		}
		if (!paused)
		{
			wasJustPaused = false;
		}
	}

	public void ResetOVROrientation()
	{
		OVRManager.display.RecenterPose();
		justRecentered = true;
		Recenterer recenterer = Recenterer.Get();
		if (recenterer != null)
		{
			recenterer.Recenter();
		}
		else
		{
			Debug.LogError("Recenterer instance invalid!");
		}
	}

	public void EnterPause()
	{
		if (!paused || !(Time.timeScale <= 0f))
		{
			paused = true;
			wasJustPaused = true;
			Time.timeScale = 0f;
		}
	}

	public void ExitPause()
	{
		paused = false;
		wasJustPaused = true;
		Time.timeScale = 1f;
	}

	private void LostFocus()
	{
		SetFocus(focusStatus: false);
	}

	private void AcquiredFocus()
	{
		SetFocus(focusStatus: true);
	}

	private void OnApplicationPause(bool pauseStatus)
	{
		Debug.Log((!pauseStatus) ? "Application resumed" : "Application paused");
	}

	private void SetFocus(bool focusStatus)
	{
		Debug.Log((!focusStatus) ? "GC - Focus lost - Paused" : "GC - Focus acquired");
		if (!focusStatus)
		{
			AudioListener.volume = 0f;
		}
		else
		{
			Get().UpdateAudioVolume();
		}
	}

	public void ExitGame()
	{
		if (UnityEngine.Application.loadedLevelName == "Intro")
		{
			Debug.Log("Closing Application");
			OVRManager.instance.ReturnToLauncher();
		}
		else
		{
			Tutorial.Get().Save();
			Debug.Log("Loading Intro scene");
			UnityEngine.Application.LoadLevel("Intro");
		}
	}

	[Conditional("DH_DEBUG")]
	private void DebugUpdate()
	{
		if (Input.GetKeyDown(KeyCode.R) && (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl)))
		{
			Loader.LoadLevel("Dungeon");
			return;
		}
		if (Input.GetKeyDown(KeyCode.F9))
		{
			Loader.LoadLevel("Dungeon");
			return;
		}
		if (Input.GetKeyDown(KeyCode.R))
		{
			GameObject gameObject = GameObject.FindWithTag(Tags.Minimap);
			if ((bool)gameObject)
			{
				gameObject.GetComponent<Minimap>().ResetMask(1f);
			}
		}
		if (Input.GetKeyDown(KeyCode.F1) || Input.GetButtonDown("Select"))
		{
		}
		if (Input.GetKeyDown(KeyCode.Q))
		{
			GameObject gameObject2 = GameObject.FindWithTag(Tags.PlayerTorch);
			gameObject2.GetComponent<TorchFuel>().AddFuel(50f);
		}
		if (Input.GetKeyDown(KeyCode.V))
		{
		}
		if (Input.GetKeyDown(KeyCode.T))
		{
			TiltPeek componentInChildren = Player.Get().GetComponentInChildren<TiltPeek>();
			if (componentInChildren != null)
			{
				componentInChildren.SetToStart();
				componentInChildren.enabled = !componentInChildren.enabled;
			}
		}
	}

	[Conditional("DH_DEBUG")]
	private void DebugTest()
	{
	}

	public void UpdateAudioVolume()
	{
		AudioListener.volume = Config.Audio().masterVolume * volumeMultiplier;
		if ((bool)Jukebox.Get())
		{
			Jukebox.Get().volume = Config.Audio().musicVolume;
		}
		GameObject gameObject = GameObject.Find("Music");
		if (gameObject != null)
		{
			MusicVolume component = gameObject.GetComponent<MusicVolume>();
			if ((bool)component)
			{
				component.UpdateVolume();
			}
		}
	}

	public void UpdateInput(bool forceUpdate = false)
	{
		if (forceUpdate)
		{
			OVRInput.Update();
		}
		InputExt.Get().lockedActiveController = UnityEngine.Application.loadedLevelName != "Intro";
		if (InputExt.Using3DOFController)
		{
			wasRightHanded = InputExt.RightHanded;
		}
		GameObject gameObject = GameObject.FindGameObjectWithTag(Tags.Player);
		if (!(gameObject != null))
		{
			return;
		}
		gameObject.GetComponent<RatchetRotation>().IsActive = Config.Input().comfortRotation;
		if (InputExt.Using3DOFController)
		{
			gameObject.GetComponent<OVRPlayerController>().moveReferenceObject = Player.GetLook(interaction: true);
		}
		else if (InputExt.UsingHandControllers)
		{
			gameObject.GetComponent<OVRPlayerController>().moveReferenceObject = Player.GetLeftHandTransform();
		}
		OVRPlayerController component = Player.GetComponent<OVRPlayerController>();
		bool flag = component.moveReferenceObject != null;
		if (flag != Config.Input().tankMode)
		{
			Debug.Log("Tank Mode: " + ((!flag) ? "OFF" : "ON"));
			if (Config.Input().tankMode && InputExt.UsingHandControllers)
			{
				component.moveReferenceObject = Player.GetLeftHandTransform();
			}
			else
			{
				component.moveReferenceObject = null;
			}
		}
	}

	[Conditional("DH_DEBUG")]
	private void ToggleVR()
	{
		OVRManager.display.RecenterPose();
		GameObject gameObject = Player.Get();
		OVRCameraRig component = gameObject.transform.Find("OVRCameraController").GetComponent<OVRCameraRig>();
		GameObject gameObject2 = component.rightEyeAnchor.gameObject;
		GameObject gameObject3 = component.leftEyeAnchor.gameObject;
		GameObject gameObject4 = component.centerEyeAnchor.gameObject;
		GameObject gameObject5 = gameObject4.transform.Find("Camera").gameObject;
		GameObject gameObject6 = gameObject4.transform.Find("LookDirection").gameObject;
		GameObject gameObject7 = gameObject.transform.Find("ForwardDirection").gameObject;
		SmoothMouseLook component2 = gameObject6.GetComponent<SmoothMouseLook>();
		SmoothMouseLook component3 = gameObject7.GetComponent<SmoothMouseLook>();
		gameObject5.SetActive(!gameObject5.activeSelf);
		gameObject5.GetComponent<Camera>().enabled = !gameObject5.GetComponent<Camera>().enabled;
		component2.enabled = !component2.enabled;
		component3.enabled = !component3.enabled;
		gameObject2.GetComponent<Camera>().enabled = !gameObject2.GetComponent<Camera>().enabled;
		gameObject3.GetComponent<Camera>().enabled = !gameObject3.GetComponent<Camera>().enabled;
		component.GetComponent<OVRManager>().enabled = !component.GetComponent<OVRManager>().enabled;
		component.enabled = !component.enabled;
		if (gameObject != null)
		{
			OVRPlayerController component4 = gameObject.GetComponent<OVRPlayerController>();
			if (component4 != null)
			{
				component4.updateRotationFromHMD = !component4.updateRotationFromHMD;
			}
		}
		if (!component.enabled)
		{
			component.centerEyeAnchor.transform.localPosition = Vector3.zero;
			component.centerEyeAnchor.transform.localRotation = Quaternion.identity;
			component.leftEyeAnchor.transform.localPosition = component.centerEyeAnchor.transform.localPosition;
			component.leftEyeAnchor.transform.localRotation = component.centerEyeAnchor.transform.localRotation;
			component.rightEyeAnchor.transform.localPosition = component.centerEyeAnchor.transform.localPosition;
			component.rightEyeAnchor.transform.localRotation = component.centerEyeAnchor.transform.localRotation;
		}
		AmbientManager.Get().ResetPlayerCameras();
		gameObject.GetComponent<FearEffect>().Start();
	}

	public void EndLevel(bool win = false)
	{
		gameOverText = string.Empty;
		Win = win;
		Fader fader = ((!win) ? this.fader : faderWin);
		fader.FadeOut((!win) ? 4f : 1f, fadeAudio: true, base.gameObject);
	}

	public void ShowGameOver(string text)
	{
		gameOverText = text;
		Tutorial.Get().Save();
		fader.FadeOut(4f, fadeAudio: true, base.gameObject);
	}

	public void OnEndFade(Fader fader)
	{
		if (!(UnityEngine.Application.loadedLevelName == "Intro"))
		{
			AudioListener.volume = Config.Audio().masterVolume * volumeMultiplier;
			if (levelOptions != null && levelOptions.isRandomMode)
			{
				UnityEngine.Application.LoadLevel("BriefingRandomMap");
			}
			else if (gameOverText == string.Empty)
			{
				UnityEngine.Application.LoadLevel("Intro");
			}
			else
			{
				GameOver.Display(gameOverText, (!levelOptions.isDemo) ? string.Empty : "Intro");
			}
		}
	}

	public void EnterHub(bool saveCheckpoint = false)
	{
		if (saveCheckpoint)
		{
			GameState.Get().checkPoint++;
			Get().SaveGame(overwriteMap: false);
			Tutorial.Get().Save();
		}
		fader.FadeOut(2f, fadeAudio: true, null, OnEndFadeEnterHub);
	}

	private void OnEndFadeEnterHub()
	{
		LevelOptions metaLevelOptions = LevelOptions.GetMetaLevelOptions(GameState.Get().metaMap);
		nextOptions = metaLevelOptions;
		Loader.LoadLevel("Dungeon");
	}

	public void SaveGame(bool overwriteMap = true, string gameName = "SavedGame_00")
	{
		serializer.SaveGame(gameName, overwriteMap);
	}

	public bool LoadGame(string gameName = "SavedGame_00")
	{
		return serializer.LoadGame(gameName);
	}

	public void NewGame(string gameName = "SavedGame_00", bool liteVersion = false)
	{
		GameState.Get().Reset();
		GameState.Get().liteVersion = liteVersion;
		serializer = new Serializer();
		serializer.SaveGame(gameName, overwriteMap: false, refreshData: false);
		Tutorial.ResetAndSave();
		serializer.LoadGame(gameName);
	}

	public bool CheckGame(string gameName = "SavedGame_00")
	{
		return GameState.Check(gameName);
	}

	public void StartDemo()
	{
		GameState.Get().Reset();
		serializer = new Serializer();
		serializer.SaveGame("SavedGame_00", overwriteMap: false, refreshData: false);
		Tutorial.ResetAndSave();
		fader.FadeOut(4f, fadeAudio: true, null, StartDemo_OnEndFade);
	}

	private void StartDemo_OnEndFade()
	{
		LevelOptions byName = LevelOptions.GetByName("demo");
		nextOptions = byName;
		Loader.LoadLevel("Dungeon");
	}

	public void StartRandomMap()
	{
		Fader component = GameObject.Find("Fader").GetComponent<Fader>();
		component.FadeOut(4f, fadeAudio: true, null, StartRandomMap_OnEndFade);
	}

	private void StartRandomMap_OnEndFade()
	{
		GameState.Get().SetRandomMode();
		LevelOptions randomFromFolder = LevelOptionsList.GetRandomFromFolder("random");
		randomFromFolder.isRandomMode = true;
		nextOptions = randomFromFolder;
		Loader.LoadLevel("Dungeon");
	}

	public static bool GetBackButtonDown()
	{
		return InputExt.BackButtonDown;
	}

	public static void SetLanguage(string langIndex, bool saveConfig = true)
	{
		if (!Translate.SetLanguage(langIndex))
		{
			return;
		}
		if (saveConfig)
		{
			Config.General().language = Translate.GetLanguage();
			Config.Save();
		}
		if (UnityEngine.Application.loadedLevelName == "Dungeon")
		{
			UIText[] componentsInChildren = Player.Get().GetComponentsInChildren<UIText>(includeInactive: true);
			UIText[] array = componentsInChildren;
			foreach (UIText uIText in array)
			{
				uIText.RefreshText();
			}
			UIButton3D[] componentsInChildren2 = Player.Get().GetComponentsInChildren<UIButton3D>(includeInactive: true);
			UIButton3D[] array2 = componentsInChildren2;
			foreach (UIButton3D uIButton3D in array2)
			{
				uIButton3D.RefreshText();
			}
			LocalizedTexture[] componentsInChildren3 = Player.Get().GetComponentsInChildren<LocalizedTexture>(includeInactive: true);
			LocalizedTexture[] array3 = componentsInChildren3;
			foreach (LocalizedTexture localizedTexture in array3)
			{
				localizedTexture.RefreshTextures();
			}
		}
		else
		{
			if (!(UnityEngine.Application.loadedLevelName == "Intro"))
			{
				return;
			}
			GameObject[] array4 = new GameObject[2]
			{
				GameObject.Find("UI"),
				GameObject.Find("OptionsContainer")
			};
			foreach (GameObject gameObject in array4)
			{
				UIText[] componentsInChildren4 = gameObject.GetComponentsInChildren<UIText>(includeInactive: true);
				UIText[] array5 = componentsInChildren4;
				foreach (UIText uIText2 in array5)
				{
					uIText2.RefreshText();
				}
				UIButton3D[] componentsInChildren5 = gameObject.GetComponentsInChildren<UIButton3D>(includeInactive: true);
				UIButton3D[] array6 = componentsInChildren5;
				foreach (UIButton3D uIButton3D2 in array6)
				{
					uIButton3D2.RefreshText();
				}
				LocalizedTexture[] componentsInChildren6 = gameObject.GetComponentsInChildren<LocalizedTexture>(includeInactive: true);
				LocalizedTexture[] array7 = componentsInChildren6;
				foreach (LocalizedTexture localizedTexture2 in array7)
				{
					localizedTexture2.RefreshTextures();
				}
			}
		}
	}

	[Conditional("CHECK_ENTITLEMENT")]
	private void CheckEntitlement()
	{
		if (!checkedEntitlement)
		{
			Core.AsyncInitialize();
			Entitlements.IsUserEntitledToApplication().OnComplete(CheckEntitlement_OnComplete);
		}
	}

	private void CheckEntitlement_OnComplete(Message msg)
	{
		if (msg.IsError)
		{
			Debug.LogError("Entitlement check failed - Displaying error message");
			Debug.LogError(msg.GetError().Message);
			ErrorMessage.Display(Translate.Get("ENTITLEMENT_FAILED"));
		}
		else
		{
			Debug.Log("Entitlement check passed");
		}
		checkedEntitlement = true;
	}

	[Conditional("DH_DEBUG")]
	public void DebugText(string text, Vector3 vPos, Vector3 vForwards, float time = 0f)
	{
		TextMesh textMesh = UnityEngine.Object.Instantiate(debugText, vPos, Quaternion.LookRotation(vForwards));
		textMesh.text = text;
		if (time > 0f)
		{
			UnityEngine.Object.Destroy(textMesh.gameObject, time);
		}
	}
}
public class GameOver : MonoBehaviour
{
	public static string displayTextCode = "GAMEOVER_DEFAULT";

	public static string nextLevel = "Intro";

	public TextLabel textLabel;

	private bool fading;

	public static void Display(string textCode, string level, string gameOverLevel = "GameOver")
	{
		displayTextCode = textCode;
		nextLevel = level;
		UnityEngine.Application.LoadLevel(gameOverLevel);
	}

	private void Start()
	{
		string text = Translate.GetForInput(displayTextCode) + "\n\n" + Translate.GetForInput("GAMEOVER_CONTINUE");
		textLabel.Text = text;
		textLabel.FadeIn();
	}

	private void Update()
	{
		if (!fading && (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction)))
		{
			fading = true;
			textLabel.FadeOut();
			if (nextLevel != null && nextLevel != string.Empty)
			{
				Fader component = GameObject.Find("Fader").GetComponent<Fader>();
				component.FadeOut(2f, fadeAudio: true, null, LoadNextLevel_OnEndFade);
			}
			else
			{
				GameController.Get().LoadGame();
			}
		}
	}

	private void LoadNextLevel_OnEndFade()
	{
		Loader.LoadLevel(nextLevel);
	}
}
[Serializable]
public class GameState
{
	private static GameState instance;

	public string versionCode;

	public bool liteVersion;

	public int metaMap;

	public int checkPoint;

	public int[] inventory;

	public float fuel;

	public int lampDescriptions;

	public List<string> oracleTags;

	public int oracleNumAsked;

	public List<string> playerNotes;

	public int lockpicsUsedSuccesfully;

	public float[] minimap;

	public List<string> objectsIds;

	public List<string> objectsData;

	public List<string> removedObjs;

	public GameState()
	{
		Reset();
	}

	public static GameState Get()
	{
		if (instance == null)
		{
			instance = new GameState();
		}
		return instance;
	}

	public void Reset()
	{
		versionCode = GlobalParams.savegameVersion;
		liteVersion = false;
		metaMap = 1;
		checkPoint = 0;
		inventory = new int[Enum.GetNames(typeof(Collectable.EItemType)).Length];
		for (int i = 0; i < inventory.Length; i++)
		{
			inventory[i] = 0;
		}
		fuel = 0.75f;
		lampDescriptions = 3;
		oracleTags = new List<string>();
		oracleNumAsked = 0;
		playerNotes = new List<string>();
		lockpicsUsedSuccesfully = 0;
		minimap = null;
		objectsIds = new List<string>();
		objectsData = new List<string>();
		removedObjs = new List<string>();
	}

	public void SetRandomMode()
	{
		Reset();
		fuel = 0.6f;
		lampDescriptions = 0;
		lockpicsUsedSuccesfully = 5;
	}

	public void SetCheckpoint(int metaMap, int checkPoint)
	{
		this.metaMap = metaMap;
		this.checkPoint = checkPoint;
	}

	public void Refresh(bool overwriteMap = true)
	{
		Inventory component = GameObject.FindWithTag(Tags.Inventory).GetComponent<Inventory>();
		SetInventory(component);
		TorchFuel component2 = GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchFuel>();
		fuel = component2.Fuel;
		if (overwriteMap)
		{
			Minimap component3 = GameObject.FindWithTag(Tags.Minimap).GetComponent<Minimap>();
			component3.Serialize(this);
		}
	}

	public void SetInventory(Inventory inv)
	{
		inventory = CopyInventory(inv.NumItems, inventory);
	}

	public void GetInventory(Inventory inv)
	{
		inv.NumItems = CopyInventory(inventory, inv.NumItems);
	}

	private static int[] CopyInventory(int[] source, int[] dest)
	{
		if (dest.Length != source.Length)
		{
			dest = new int[source.Length];
		}
		for (int i = 0; i < source.Length; i++)
		{
			dest[i] = source[i];
		}
		return dest;
	}

	public static bool Load(string gameName = "SavedGame_00")
	{
		GameState defaultValue = new GameState();
		defaultValue = Serializer.DeserializeObject(gameName, defaultValue);
		if (defaultValue.versionCode == GlobalParams.savegameVersion)
		{
			instance = defaultValue;
			return true;
		}
		return false;
	}

	public static void Save(string gameName = "SavedGame_00")
	{
		Serializer.SerializeObject(instance, gameName);
		PlayerPrefs.SetString(gameName + "_version", GlobalParams.savegameVersion);
	}

	public static bool Check(string gameName = "SavedGame_00")
	{
		if (PlayerPrefs.HasKey(gameName))
		{
			string key = gameName + "_version";
			if (PlayerPrefs.HasKey(key))
			{
				return GlobalParams.savegameVersion == PlayerPrefs.GetString(key);
			}
		}
		return false;
	}

	public static void Delete(string gameName = "SavedGame_00")
	{
		PlayerPrefs.DeleteKey(gameName);
		PlayerPrefs.DeleteKey(gameName + "_version");
	}
}
public class GlobalParams : MonoBehaviour
{
	[Serializable]
	public class LightParams
	{
		public float fuelDuration = 180f;

		public float fuelConsumption = 0.05f;
	}

	private static GlobalParams instance;

	public LightParams lightParams;

	public static string savegameVersion = "DHGS_0_14";

	public static string tutorialStateVersion = "DHTS_0_4";

	public static float touchControllersDistanceFactor = 0.8f;

	private void Awake()
	{
		instance = this;
	}

	public static GlobalParams Get()
	{
		return instance;
	}
}
public class InputExt : TimeIndependentBehaviour
{
	public class TouchpadStatus
	{
		public enum TouchPosition
		{
			UP,
			DOWN,
			NONE
		}

		public enum SwipeDir
		{
			LEFT,
			RIGHT
		}

		public bool isTouching;

		public TouchPosition touchPos;

		public bool isSwiping;

		public SwipeDir swipeDir;

		public Vector2 touchDelta;

		public Vector2 v2touch;

		public bool Click;

		public bool ClickDown;

		public bool ClickUp;

		public bool DoubleClick;

		public bool ClickBottom;

		public bool ClickBottomDown;

		public bool ClickBottomUp;

		private float lastClickTime;

		private float catchTime = 0.25f;

		private Vector2 lastTouchVector = Vector2.zero;

		public void Update(OVRInput.Controller controller)
		{
			Vector2 vector = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, controller);
			if (OVRInput.GetDown(OVRInput.Touch.PrimaryTouchpad, controller))
			{
				v2touch = vector;
				isSwiping = false;
			}
			if (OVRInput.Get(OVRInput.Touch.PrimaryTouchpad, controller))
			{
				isTouching = true;
				lastTouchVector = vector;
				if (vector.y > 0f)
				{
					touchPos = TouchPosition.UP;
				}
				else
				{
					touchPos = TouchPosition.DOWN;
				}
			}
			else
			{
				isTouching = false;
				touchPos = TouchPosition.NONE;
				touchDelta = v2touch - lastTouchVector;
				bool flag = Mathf.Abs(touchDelta.x) > 0.6f;
				if (touchDelta.x < 0f && flag)
				{
					swipeDir = SwipeDir.RIGHT;
					isSwiping = true;
				}
				else if (touchDelta.x > 0f && flag)
				{
					swipeDir = SwipeDir.LEFT;
					isSwiping = true;
				}
				v2touch = lastTouchVector;
			}
			if (OVRInput.Get(OVRInput.Touch.PrimaryTouchpad, controller) && touchPos == TouchPosition.DOWN)
			{
				if (OVRInput.GetDown(OVRInput.Button.PrimaryTouchpad, controller))
				{
					ClickBottomDown = true;
				}
				else
				{
					ClickBottomDown = false;
				}
				if (OVRInput.Get(OVRInput.Button.PrimaryTouchpad, controller))
				{
					ClickBottom = true;
				}
				else
				{
					ClickBottom = false;
				}
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryTouchpad, controller))
			{
				ClickDown = true;
				if (Time.time - lastClickTime < catchTime)
				{
					DoubleClick = true;
				}
				else
				{
					DoubleClick = false;
				}
				lastClickTime = Time.time;
			}
			else
			{
				ClickDown = false;
			}
			if (OVRInput.Get(OVRInput.Button.PrimaryTouchpad, controller))
			{
				Click = true;
			}
			else
			{
				Click = false;
			}
			if (OVRInput.GetUp(OVRInput.Button.PrimaryTouchpad, controller))
			{
				ClickUp = true;
				DoubleClick = false;
				if (touchPos == TouchPosition.DOWN)
				{
					ClickBottomUp = true;
				}
			}
			else
			{
				ClickUp = false;
				ClickBottomUp = false;
			}
		}
	}

	public enum Button
	{
		Action,
		Inventory,
		Cancel,
		Light,
		Start,
		Select,
		Lockpick,
		HideMap,
		Submit,
		ResetTracking,
		UIAction,
		Back
	}

	public enum Axis2D
	{
		LeftThumbstick,
		RightThumbstick,
		Dpad
	}

	public enum Axis1D
	{
		LeftTrigger,
		RightTrigger
	}

	private static InputExt instance = null;

	public static bool _HasGamepad = false;

	private float gamepadCheckTime;

	public bool justLostGamepad;

	private static bool _Has3DOFController = false;

	public static OVRInput.Controller controller3DOFIndex = OVRInput.Controller.None;

	private static bool _isOculusGo;

	public static bool _HasHandControllers = false;

	public static OVRInput.Controller controllerHandLeftIndex = OVRInput.Controller.None;

	public static OVRInput.Controller controllerHandRightIndex = OVRInput.Controller.None;

	private static bool _HandControllerLeftHanded = false;

	public static bool BackButtonDown = false;

	private static bool activeControllerIs3DOF = false;

	private static bool activeControllerIsHand = false;

	public bool lockedActiveController;

	public static TouchpadStatus touchpadStatus = new TouchpadStatus();

	public static bool HasGamepad
	{
		get
		{
			instance.CheckControllers();
			return _HasGamepad;
		}
	}

	public static bool UsingGamepad
	{
		get
		{
			instance.CheckControllers();
			return _HasGamepad && !activeControllerIs3DOF;
		}
	}

	public static bool Has3DOFController
	{
		get
		{
			instance.CheckControllers();
			return _Has3DOFController;
		}
	}

	public static bool Using3DOFController
	{
		get
		{
			Get().CheckControllers();
			return _Has3DOFController && activeControllerIs3DOF;
		}
	}

	public static bool LeftHanded => controller3DOFIndex == OVRInput.Controller.LTrackedRemote || (UsingHandControllers && _HandControllerLeftHanded);

	public static bool RightHanded => controller3DOFIndex == OVRInput.Controller.RTrackedRemote || (UsingHandControllers && !_HandControllerLeftHanded);

	public static bool IsOculusGo => _isOculusGo;

	public static bool HasHandControllers
	{
		get
		{
			instance.CheckControllers();
			return _HasHandControllers;
		}
	}

	public static bool UsingHandControllers
	{
		get
		{
			Get().CheckControllers();
			return _HasHandControllers && activeControllerIsHand;
		}
	}

	public static InputExt Get()
	{
		if (instance == null)
		{
			GameObject gameObject = new GameObject("_InputExt(dynamic)");
			instance = gameObject.AddComponent<InputExt>();
		}
		return instance;
	}

	private new void Awake()
	{
		if (instance != null && instance != this)
		{
			UnityEngine.Object.Destroy(instance);
		}
		instance = this;
		OVRInput.Update();
		int num = 0;
		string[] joystickNames = Input.GetJoystickNames();
		for (int i = 0; i < joystickNames.Length; i++)
		{
			Debug.Log(joystickNames[i]);
			num += ((joystickNames[i].Length > 0) ? 1 : 0);
		}
	}

	private new void OnEnable()
	{
		OVRInput.Update();
		CheckControllers();
		_isOculusGo = OVRPlugin.productName == "Oculus Go";
	}

	public static void ResetLeftHanded()
	{
		_HandControllerLeftHanded = Config.Input().leftHanded;
	}

	private void CheckControllers()
	{
		if (!(Time.realtimeSinceStartup - instance.gamepadCheckTime >= 2.5f))
		{
			return;
		}
		instance.gamepadCheckTime = Time.realtimeSinceStartup;
		OVRInput.Controller connectedControllers = OVRInput.GetConnectedControllers();
		bool hasGamepad = _HasGamepad;
		bool flag = (connectedControllers & OVRInput.Controller.Gamepad) != 0;
		if (_HasGamepad != flag)
		{
			Debug.Log((!flag) ? "InputExt - Gamepad controller lost" : "InputExt - Detected gamepad controller");
			if (!flag)
			{
				instance.justLostGamepad = true;
			}
		}
		_HasGamepad = flag;
		if (!_HasGamepad && hasGamepad != _HasGamepad)
		{
			Input.ResetInputAxes();
		}
		bool hasHandControllers = _HasHandControllers;
		OVRInput.Controller controller = controllerHandLeftIndex;
		OVRInput.Controller controller2 = controllerHandRightIndex;
		controllerHandRightIndex = connectedControllers & OVRInput.Controller.RTouch;
		controllerHandLeftIndex = connectedControllers & OVRInput.Controller.LTouch;
		bool flag2 = controllerHandRightIndex != 0 || controllerHandLeftIndex != OVRInput.Controller.None;
		if (_HasHandControllers != flag2)
		{
			Debug.Log((!flag2) ? "InputExt - Hand controllers lost" : ("InputExt - Detected Hand controllers. Left: " + controllerHandLeftIndex.ToString() + " Right: " + controllerHandRightIndex));
		}
		_HasHandControllers = flag2;
		if (!_HasHandControllers)
		{
			bool has3DOFController = _Has3DOFController;
			OVRInput.Controller controller3 = controller3DOFIndex;
			controller3DOFIndex = connectedControllers & (OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote);
			bool flag3 = controller3DOFIndex != OVRInput.Controller.None;
			if (_Has3DOFController != flag3 || controller3 != controller3DOFIndex)
			{
				Debug.Log((!flag3) ? "InputExt - 3DOF controller lost" : ("InputExt - Detected 3DOF controller " + controller3DOFIndex));
			}
			_Has3DOFController = flag3;
		}
		if (!lockedActiveController)
		{
			OVRInput.Controller activeController = OVRInput.GetActiveController();
			if (_HasHandControllers)
			{
				activeControllerIsHand = true;
			}
			else if (_Has3DOFController && activeController == controller3DOFIndex)
			{
				activeControllerIs3DOF = true;
			}
			else
			{
				activeControllerIs3DOF = false;
			}
		}
	}

	private new void Update()
	{
		base.Update();
		CheckControllers();
		if (justLostGamepad)
		{
			justLostGamepad = false;
		}
		if (Using3DOFController)
		{
			touchpadStatus.Update(OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote);
		}
		else if (!UsingHandControllers)
		{
		}
		BackButtonDown = false;
		if (OVRInput.GetDown(OVRInput.Button.Back))
		{
			BackButtonDown |= true;
		}
	}

	public static bool GetButton(Button btn)
	{
		bool flag = false;
		if (UsingHandControllers)
		{
			return GetHandControllersBtn(btn);
		}
		if (Using3DOFController)
		{
			return Get3DOFBtn(btn);
		}
		return OVRInput.Get(GetGamepadBtnIndex(btn), OVRInput.Controller.Gamepad);
	}

	public static bool GetButtonDown(Button btn)
	{
		bool flag = false;
		if (UsingHandControllers)
		{
			return GetHandControllersBtnDown(btn);
		}
		if (Using3DOFController)
		{
			return Get3DOFBtnDown(btn);
		}
		return OVRInput.GetDown(GetGamepadBtnIndex(btn), OVRInput.Controller.Gamepad);
	}

	public static bool GetButtonUp(Button btn)
	{
		bool flag = false;
		if (UsingHandControllers)
		{
			return GetHandControllersBtnUp(btn);
		}
		if (Using3DOFController)
		{
			return Get3DOFBtnUp(btn);
		}
		return OVRInput.GetUp(GetGamepadBtnIndex(btn), OVRInput.Controller.Gamepad);
	}

	private static OVRInput.Button GetGamepadBtnIndex(Button btn)
	{
		return btn switch
		{
			Button.Action => OVRInput.Button.One, 
			Button.UIAction => OVRInput.Button.One, 
			Button.Inventory => OVRInput.Button.Four, 
			Button.Cancel => OVRInput.Button.Two, 
			Button.Light => OVRInput.Button.Three, 
			Button.Start => OVRInput.Button.Start, 
			Button.Select => OVRInput.Button.Start, 
			Button.Lockpick => OVRInput.Button.PrimaryShoulder, 
			Button.HideMap => OVRInput.Button.PrimaryShoulder, 
			Button.Submit => OVRInput.Button.One, 
			Button.Back => OVRInput.Button.Back, 
			Button.ResetTracking => OVRInput.Button.Back, 
			_ => OVRInput.Button.None, 
		};
	}

	private static bool Get3DOFBtn(Button btn)
	{
		return btn switch
		{
			Button.Action => OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote), 
			Button.UIAction => OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote) || touchpadStatus.Click, 
			Button.Inventory => touchpadStatus.ClickBottom, 
			Button.Cancel => OVRInput.Get(OVRInput.Button.Back, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote), 
			Button.Submit => touchpadStatus.Click, 
			_ => false, 
		};
	}

	private static bool Get3DOFBtnDown(Button btn)
	{
		return btn switch
		{
			Button.Action => OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote), 
			Button.UIAction => OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote) || touchpadStatus.ClickDown, 
			Button.Inventory => touchpadStatus.ClickBottomDown, 
			Button.Cancel => OVRInput.GetDown(OVRInput.Button.Back, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote), 
			Button.Submit => touchpadStatus.ClickDown, 
			_ => false, 
		};
	}

	private static bool Get3DOFBtnUp(Button btn)
	{
		switch (btn)
		{
		case Button.Action:
			return OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote);
		case Button.UIAction:
			return OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote) || touchpadStatus.ClickUp;
		case Button.Inventory:
			return touchpadStatus.ClickBottomUp;
		case Button.Cancel:
		case Button.Start:
			return OVRInput.GetUp(OVRInput.Button.Back, OVRInput.Controller.LTrackedRemote | OVRInput.Controller.RTrackedRemote);
		case Button.Submit:
			return touchpadStatus.ClickUp;
		case Button.Back:
			return OVRInput.GetUp(OVRInput.Button.Back);
		default:
			return false;
		}
	}

	private static bool GetHandControllersBtn(Button btn)
	{
		if (!LeftHanded)
		{
			return btn switch
			{
				Button.Action => OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.RTouch), 
				Button.UIAction => OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.RTouch), 
				Button.Light => OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.LTouch), 
				Button.Inventory => OVRInput.Get(OVRInput.Button.One, OVRInput.Controller.LTouch), 
				Button.Cancel => OVRInput.Get(OVRInput.Button.Back, OVRInput.Controller.Touch), 
				Button.Submit => OVRInput.Get(OVRInput.Button.One, OVRInput.Controller.RTouch), 
				Button.HideMap => OVRInput.Get(OVRInput.Button.One, OVRInput.Controller.RTouch), 
				Button.Start => OVRInput.Get(OVRInput.Button.Start), 
				_ => false, 
			};
		}
		return btn switch
		{
			Button.Action => OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.LTouch), 
			Button.UIAction => OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.LTouch), 
			Button.Light => OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.RTouch), 
			Button.Inventory => OVRInput.Get(OVRInput.Button.One, OVRInput.Controller.RTouch), 
			Button.Cancel => OVRInput.Get(OVRInput.Button.Back, OVRInput.Controller.Touch) || OVRInput.Get(OVRInput.Button.Two, OVRInput.Controller.RTouch), 
			Button.Submit => OVRInput.Get(OVRInput.Button.One, OVRInput.Controller.LTouch), 
			Button.HideMap => OVRInput.Get(OVRInput.Button.One, OVRInput.Controller.LTouch), 
			Button.Start => OVRInput.Get(OVRInput.Button.Start), 
			_ => false, 
		};
	}

	private static bool GetHandControllersBtnDown(Button btn)
	{
		if (!LeftHanded)
		{
			return btn switch
			{
				Button.Action => OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.RTouch), 
				Button.UIAction => OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.RTouch), 
				Button.Light => OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.LTouch), 
				Button.Inventory => OVRInput.GetDown(OVRInput.Button.One, OVRInput.Controller.LTouch), 
				Button.Cancel => OVRInput.GetDown(OVRInput.Button.Back, OVRInput.Controller.Touch) || OVRInput.GetDown(OVRInput.Button.Two, OVRInput.Controller.RTouch), 
				Button.Submit => OVRInput.GetDown(OVRInput.Button.One, OVRInput.Controller.RTouch), 
				Button.HideMap => OVRInput.GetDown(OVRInput.Button.One, OVRInput.Controller.RTouch), 
				Button.Start => OVRInput.GetDown(OVRInput.Button.Start), 
				_ => false, 
			};
		}
		return btn switch
		{
			Button.Action => OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.LTouch), 
			Button.UIAction => OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.LTouch), 
			Button.Light => OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.RTouch), 
			Button.Inventory => OVRInput.GetDown(OVRInput.Button.One, OVRInput.Controller.RTouch), 
			Button.Cancel => OVRInput.GetDown(OVRInput.Button.Back, OVRInput.Controller.Touch) || OVRInput.GetDown(OVRInput.Button.Two, OVRInput.Controller.RTouch), 
			Button.Submit => OVRInput.GetDown(OVRInput.Button.One, OVRInput.Controller.LTouch), 
			Button.HideMap => OVRInput.GetDown(OVRInput.Button.One, OVRInput.Controller.LTouch), 
			Button.Start => OVRInput.GetDown(OVRInput.Button.Start), 
			_ => false, 
		};
	}

	private static bool GetHandControllersBtnUp(Button btn)
	{
		if (!LeftHanded)
		{
			return btn switch
			{
				Button.Action => OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.RTouch), 
				Button.UIAction => OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.RTouch), 
				Button.Light => OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.LTouch), 
				Button.Inventory => OVRInput.GetUp(OVRInput.Button.One, OVRInput.Controller.LTouch), 
				Button.Start => OVRInput.GetUp(OVRInput.Button.Start), 
				Button.Cancel => OVRInput.GetUp(OVRInput.Button.Back, OVRInput.Controller.Touch) || OVRInput.GetUp(OVRInput.Button.Two, OVRInput.Controller.RTouch), 
				Button.Submit => OVRInput.GetUp(OVRInput.Button.One, OVRInput.Controller.RTouch), 
				Button.HideMap => OVRInput.GetUp(OVRInput.Button.One, OVRInput.Controller.RTouch), 
				_ => false, 
			};
		}
		return btn switch
		{
			Button.Action => OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.LTouch), 
			Button.UIAction => OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.LTouch), 
			Button.Light => OVRInput.GetUp(OVRInput.Button.PrimaryIndexTrigger, OVRInput.Controller.RTouch), 
			Button.Inventory => OVRInput.GetUp(OVRInput.Button.One, OVRInput.Controller.RTouch), 
			Button.Start => OVRInput.GetDown(OVRInput.Button.Start), 
			Button.Cancel => OVRInput.GetUp(OVRInput.Button.Back, OVRInput.Controller.Touch), 
			Button.Submit => OVRInput.GetUp(OVRInput.Button.One, OVRInput.Controller.LTouch), 
			Button.HideMap => OVRInput.GetUp(OVRInput.Button.One, OVRInput.Controller.LTouch), 
			_ => false, 
		};
	}

	private static string GetUnityBtn(Button btn)
	{
		switch (btn)
		{
		case Button.Action:
		case Button.UIAction:
			return "Fire1";
		case Button.Inventory:
			return "Inventory";
		case Button.Cancel:
			return "Cancel";
		case Button.Light:
			return "Light";
		case Button.Start:
			return "Start";
		case Button.Select:
			return "Select";
		case Button.Lockpick:
			return "Lockpick";
		case Button.HideMap:
			return "HideMap";
		case Button.Submit:
			return "Submit";
		case Button.ResetTracking:
			return "ResetTracking";
		default:
			return string.Empty;
		}
	}

	public static bool GetRunButton()
	{
		if (UsingHandControllers)
		{
			return OVRInput.Get(OVRInput.Button.PrimaryHandTrigger, OVRInput.Controller.RTouch) || OVRInput.Get(OVRInput.Button.PrimaryHandTrigger, OVRInput.Controller.LTouch);
		}
		if (Using3DOFController)
		{
			return touchpadStatus.DoubleClick;
		}
		return OVRInput.Get(OVRInput.Button.SecondaryShoulder, OVRInput.Controller.Gamepad) || OVRInput.Get(OVRInput.Axis1D.SecondaryIndexTrigger, OVRInput.Controller.Gamepad) > 0.2f;
	}

	public static Vector2 GetAxisPad(Axis2D axis)
	{
		if (!UsingGamepad && !UsingHandControllers)
		{
			return Vector2.zero;
		}
		if (axis == Axis2D.Dpad)
		{
			Vector2 zero = Vector2.zero;
			zero.x += ((!OVRInput.Get(OVRInput.Button.DpadLeft, OVRInput.Controller.Gamepad)) ? 0f : (-1f));
			zero.x += ((!OVRInput.Get(OVRInput.Button.DpadRight, OVRInput.Controller.Gamepad)) ? 0f : 1f);
			zero.y += ((!OVRInput.Get(OVRInput.Button.DpadUp, OVRInput.Controller.Gamepad)) ? 0f : (-1f));
			zero.y += ((!OVRInput.Get(OVRInput.Button.DpadDown, OVRInput.Controller.Gamepad)) ? 0f : 1f);
			return zero;
		}
		OVRInput.Axis2D virtualMask = OVRInput.Axis2D.None;
		switch (axis)
		{
		case Axis2D.LeftThumbstick:
			virtualMask = OVRInput.Axis2D.PrimaryThumbstick;
			break;
		case Axis2D.RightThumbstick:
			virtualMask = OVRInput.Axis2D.SecondaryThumbstick;
			break;
		}
		return OVRInput.Get(virtualMask, (!UsingHandControllers) ? OVRInput.Controller.Gamepad : OVRInput.Controller.Touch);
	}

	public static float GetAxisPad(Axis1D axis)
	{
		if (!UsingGamepad && !UsingHandControllers)
		{
			return 0f;
		}
		OVRInput.Axis1D virtualMask = OVRInput.Axis1D.None;
		switch (axis)
		{
		case Axis1D.LeftTrigger:
			virtualMask = OVRInput.Axis1D.PrimaryIndexTrigger;
			break;
		case Axis1D.RightTrigger:
			virtualMask = OVRInput.Axis1D.SecondaryIndexTrigger;
			break;
		}
		return OVRInput.Get(virtualMask, (!UsingHandControllers) ? OVRInput.Controller.Gamepad : OVRInput.Controller.Touch);
	}

	public static Vector2 GetAxisPadRatchet(Axis2D axis)
	{
		if (!UsingGamepad && !UsingHandControllers)
		{
			return Vector2.zero;
		}
		OVRInput.Axis2D virtualMask = OVRInput.Axis2D.None;
		switch (axis)
		{
		case Axis2D.LeftThumbstick:
			virtualMask = OVRInput.Axis2D.PrimaryThumbstick;
			break;
		case Axis2D.RightThumbstick:
			virtualMask = OVRInput.Axis2D.SecondaryThumbstick;
			break;
		}
		return OVRInput.Get(virtualMask, (!UsingHandControllers) ? OVRInput.Controller.Gamepad : OVRInput.Controller.Touch);
	}
}
public class IntroMenuController : FSMComponent<IntroMenuController.States>
{
	public enum States
	{
		Logo,
		Menu,
		ConfirmOverwrite,
		Disclaimer,
		Credits,
		Controls,
		Fading,
		Options,
		ConfirmRandomMode,
		ControllerCheck
	}

	public Renderer logoRenderer;

	public Renderer controlsKeyboard;

	public Renderer controlsPad;

	public Renderer controlsOculusGoPad;

	public Renderer controlsGearVR3DOF;

	public Renderer controlsOculusGo3DOF;

	public Renderer controlsTouchRight;

	public Renderer controlsTouchLeft;

	public Renderer continueKeyboard;

	public Renderer continuePad;

	public Renderer continueGearVR3DOF;

	public Renderer continueOculusgo3DOF;

	public Renderer continueTouch;

	public UIDreadHallsMenu mainMenu;

	private UIMenuAnimator mainMenuAnimator;

	public UIDreadHallsMenu dialogMenu;

	private UIMenuAnimator dialogMenuAnimator;

	public UIDreadHallsMenu disclaimerMenu;

	private UIMenuAnimator disclaimerMenuAnimator;

	public UIDreadHallsMenu creditsMenu;

	private UIMenuAnimator creditsMenuAnimator;

	public UIDreadHallsMenu optionsMenu;

	private UIMenuAnimator optionsMenuAnimator;

	public UIDreadHallsMenu noControllerMenu;

	private UIMenuAnimator noControllerMenuAnimator;

	public UICrosshair3D crosshairFar;

	public UICrosshair3D crosshairNear;

	private Fader fader;

	public float FadeInSpeed = 0.6f;

	public float FadeOutSpeed = 0.6f;

	private bool menuActive;

	private bool dialogActive;

	private bool disclaimerActive;

	private float disclaimerTimeout;

	private float creditsTimeout;

	private int creditsIndex;

	private bool fast;

	private bool canContinue;

	private bool hasSaveGame;

	private bool enterDemo;

	private bool enterLite;

	private bool randomMapMode;

	private const float creditsShowTime = 6f;

	private void Start()
	{
		fader = GameObject.Find("Fader").GetComponent<Fader>();
		mainMenuAnimator = mainMenu.GetComponent<UIMenuAnimator>();
		mainMenuAnimator.ApplyAlpha(0f);
		dialogMenuAnimator = dialogMenu.GetComponent<UIMenuAnimator>();
		dialogMenuAnimator.ApplyAlpha(0f);
		disclaimerMenuAnimator = disclaimerMenu.GetComponent<UIMenuAnimator>();
		disclaimerMenuAnimator.ApplyAlpha(0f);
		creditsMenuAnimator = creditsMenu.GetComponent<UIMenuAnimator>();
		creditsMenuAnimator.ApplyAlpha(0f);
		optionsMenuAnimator = optionsMenu.GetComponent<UIMenuAnimator>();
		optionsMenuAnimator.ApplyAlpha(0f);
		noControllerMenuAnimator = noControllerMenu.GetComponent<UIMenuAnimator>();
		noControllerMenuAnimator.ApplyAlpha(0f);
		hasSaveGame = GameController.Get().CheckGame();
		UIButton3D button = GetButton("button_continue");
		if (!hasSaveGame && button != null)
		{
			button.gameObject.SetActive(value: false);
		}
		else if (button != null)
		{
			button.SetAction(OnButton_Continue);
		}
		UIButton3D button2 = GetButton("button_new");
		if (button2 != null)
		{
			button2.SetAction(OnButton_New);
		}
		UIButton3D button3 = GetButton("button_exit");
		if (button3 != null)
		{
			button3.SetAction(OnButton_Exit);
		}
		UIButton3D button4 = GetButton("button_demo");
		if (button4 != null)
		{
			button4.SetAction(OnButton_Demo);
		}
		UIButton3D button5 = GetButton("button_lite");
		if (button5 != null)
		{
			button5.SetAction(OnButton_Lite);
		}
		UIButton3D button6 = GetButton("button_random");
		if (button6 != null)
		{
			button6.SetAction(OnButton_RandomMap);
		}
		UIButton3D button7 = GetButton("button_options");
		if (button7 != null)
		{
			button7.SetAction(OnButton_Options);
		}
		UIButton3D button8 = GetButton("button_credits");
		if (button8 != null)
		{
			button8.SetAction(OnButton_Credits);
		}
		Init(States.Logo);
	}

	private void Logo_Enter()
	{
		fast = false;
		mainMenu.gameObject.SetActive(value: false);
		dialogMenuAnimator.gameObject.SetActive(value: false);
		disclaimerMenuAnimator.gameObject.SetActive(value: false);
		creditsMenuAnimator.gameObject.SetActive(value: false);
		optionsMenuAnimator.gameObject.SetActive(value: false);
		noControllerMenuAnimator.gameObject.SetActive(value: false);
		crosshairFar.gameObject.SetActive(value: false);
		crosshairNear.gameObject.SetActive(value: false);
		StartCoroutine(Logo_co());
	}

	private IEnumerator Logo_co()
	{
		if (!fast)
		{
			yield return new WaitForSeconds(3f);
		}
		yield return StartCoroutine(FadeIn(logoRenderer));
		if (!fast)
		{
			yield return new WaitForSeconds(3f);
		}
		yield return StartCoroutine(FadeOut(logoRenderer));
		base.State = States.ControllerCheck;
	}

	private void Logo_Update()
	{
		if (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction))
		{
			fast = true;
		}
	}

	private void Logo_Exit()
	{
		fast = false;
	}

	private void Menu_Enter()
	{
		mainMenu.gameObject.SetActive(value: true);
		mainMenu.Visible = true;
		mainMenu.SetCollidersEnabled(enabled: true);
		mainMenuAnimator.FadeIn();
		menuActive = true;
		crosshairFar.gameObject.SetActive(value: true);
	}

	private void Menu_Exit()
	{
		mainMenuAnimator.FadeOut(reset: false, OnEndMenuFade);
		mainMenu.SetCollidersEnabled(enabled: false);
	}

	private void OnEndMenuFade()
	{
		mainMenu.gameObject.SetActive(value: false);
	}

	private void OnButton_Continue()
	{
		if (menuActive)
		{
			Debug.Log("OnButton_Continue");
			GameController.Get().LoadGame();
			menuActive = false;
		}
	}

	private void OnButton_New()
	{
		if (menuActive)
		{
			Debug.Log("OnButton_New");
			if (hasSaveGame)
			{
				base.State = States.ConfirmOverwrite;
			}
			else
			{
				base.State = States.Disclaimer;
			}
			menuActive = false;
		}
	}

	private void OnButton_Exit()
	{
		if (menuActive)
		{
			Debug.Log("OnButton_Exit");
			OVRManager.instance.ReturnToLauncher();
		}
	}

	private void OnButton_Demo()
	{
		if (menuActive)
		{
			Debug.Log("OnButton_Demo");
			menuActive = false;
			base.State = States.Disclaimer;
			enterDemo = true;
		}
	}

	private void OnButton_Lite()
	{
		if (menuActive)
		{
			Debug.Log("OnButton_Lite");
			menuActive = false;
			base.State = States.Disclaimer;
			enterDemo = false;
			enterLite = true;
		}
	}

	private void OnButton_Options()
	{
		if (menuActive)
		{
			Debug.Log("OnButton_Options");
			menuActive = false;
			base.State = States.Options;
		}
	}

	private void OnButton_RandomMap()
	{
		if (menuActive)
		{
			Debug.Log("OnButton_RandomMap");
			menuActive = false;
			if (!Config.General().randomModeUnlocked)
			{
				base.State = States.ConfirmRandomMode;
				return;
			}
			randomMapMode = true;
			base.State = States.Controls;
		}
	}

	private void OnButton_Credits()
	{
		if (menuActive)
		{
			Debug.Log("OnButton_Credits");
			menuActive = false;
			if (!Config.General().endingCredits)
			{
				base.State = States.Credits;
				return;
			}
			Fader component = GameObject.Find("Fader").GetComponent<Fader>();
			component.SetColor(Color.white);
			component.FadeOut(2f, fadeAudio: true, null, OnEndFade_EndingCredits);
		}
	}

	public void OnEndFade_EndingCredits()
	{
		Loader.nextScene = "Ending";
		UnityEngine.Application.LoadLevel("LoadingEnd");
	}

	private void ConfirmOverwrite_Enter()
	{
		dialogMenu.gameObject.SetActive(value: true);
		dialogMenu.Visible = true;
		dialogMenu.SetCollidersEnabled(enabled: true);
		dialogMenuAnimator.FadeIn();
		dialogActive = true;
		dialogMenu.SetDialog(Translate.Get("MENU_INTRO_OVERWRITE"), Translate.Get("MENU_YES"), Translate.Get("MENU_NO"), OnConfirmOverwrite_Yes, OnConfirmOverwrite_No);
		crosshairFar.gameObject.SetActive(value: true);
	}

	private void ConfirmOverwrite_Exit()
	{
		dialogMenuAnimator.FadeOut(reset: false, OnEndDialogFade);
		dialogMenu.SetCollidersEnabled(enabled: false);
	}

	private void OnEndDialogFade()
	{
		dialogMenu.gameObject.SetActive(value: false);
	}

	private void OnConfirmOverwrite_Yes()
	{
		if (dialogActive)
		{
			base.State = States.Disclaimer;
			dialogActive = false;
		}
	}

	private void OnConfirmOverwrite_No()
	{
		if (dialogActive)
		{
			base.State = States.Menu;
			dialogActive = false;
		}
	}

	private void ConfirmRandomMode_Enter()
	{
		dialogMenu.gameObject.SetActive(value: true);
		dialogMenu.Visible = true;
		dialogMenu.SetCollidersEnabled(enabled: true);
		dialogMenuAnimator.FadeIn();
		dialogActive = true;
		dialogMenu.SetDialog(Translate.Get("MENU_INTRO_RANDOM_SPOILERS"), Translate.Get("MENU_INTRO_RANDOM_YES"), Translate.Get("MENU_INTRO_RANDOM_NO"), OnConfirmRandomMode_Yes, OnConfirmRandomMode_No);
		crosshairFar.gameObject.SetActive(value: true);
	}

	private void ConfirmRandomMode_Exit()
	{
		dialogMenuAnimator.FadeOut(reset: false, OnEndDialogFade);
		dialogMenu.SetCollidersEnabled(enabled: false);
	}

	private void OnConfirmRandomMode_Yes()
	{
		if (dialogActive)
		{
			Config.General().randomModeUnlocked = true;
			Config.Save();
			randomMapMode = true;
			base.State = States.Disclaimer;
			dialogActive = false;
		}
	}

	private void OnConfirmRandomMode_No()
	{
		if (dialogActive)
		{
			base.State = States.Menu;
			dialogActive = false;
		}
	}

	private void Disclaimer_Enter()
	{
		disclaimerMenu.gameObject.SetActive(value: true);
		disclaimerMenu.Visible = true;
		disclaimerMenu.SetCollidersEnabled(enabled: true);
		disclaimerMenuAnimator.FadeIn();
		disclaimerActive = true;
		disclaimerMenu.SetText("main_text", Translate.Get("MENU_INTRO_DISCLAIMER"));
		disclaimerTimeout = 8f;
		crosshairFar.gameObject.SetActive(value: false);
	}

	private void Disclaimer_Exit()
	{
		disclaimerMenuAnimator.FadeOut(reset: false, OnEndDisclaimerFade);
		disclaimerMenu.SetCollidersEnabled(enabled: false);
		canContinue = false;
	}

	private void Disclaimer_Update()
	{
		disclaimerTimeout -= Time.deltaTime;
		if (disclaimerTimeout <= 0f || (canContinue && (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction))))
		{
			base.State = States.Controls;
		}
		if (!canContinue && disclaimerTimeout <= 6f)
		{
			canContinue = true;
		}
	}

	private void OnEndDisclaimerFade()
	{
		disclaimerMenu.gameObject.SetActive(value: false);
	}

	private void ControllerCheck_Enter()
	{
		if (!HasValidController())
		{
			noControllerMenu.gameObject.SetActive(value: true);
			noControllerMenu.Visible = true;
			noControllerMenu.SetCollidersEnabled(enabled: true);
			noControllerMenuAnimator.FadeIn();
			noControllerMenu.SetText("main_text", Translate.Get("GAMEPAD_LOST") + "\n\n" + Translate.Get("GAMEPAD_LOST_TIP"));
			crosshairFar.gameObject.SetActive(value: false);
		}
	}

	private void ControllerCheck_Exit()
	{
		noControllerMenu.gameObject.SetActive(value: false);
		noControllerMenu.SetCollidersEnabled(enabled: false);
		canContinue = true;
	}

	private void ControllerCheck_Update()
	{
		if (HasValidController())
		{
			base.State = States.Menu;
		}
	}

	private bool HasValidController()
	{
		return InputExt.HasHandControllers || InputExt.Has3DOFController || InputExt.HasGamepad;
	}

	private void Credits_Enter()
	{
		creditsMenu.gameObject.SetActive(value: true);
		creditsMenu.Visible = true;
		creditsMenu.SetCollidersEnabled(enabled: true);
		creditsMenuAnimator.FadeIn();
		creditsMenu.SetText("main_text", GetCreditsString(0));
		creditsTimeout = 6f;
		creditsIndex = 1;
		crosshairFar.gameObject.SetActive(value: false);
		canContinue = true;
	}

	private void Credits_Exit()
	{
		creditsMenu.gameObject.SetActive(value: false);
		creditsMenu.SetCollidersEnabled(enabled: false);
	}

	private void Credits_Update()
	{
		creditsTimeout -= Time.deltaTime;
		if (canContinue && (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction) || InputExt.GetButtonDown(InputExt.Button.Cancel) || GameController.GetBackButtonDown()))
		{
			canContinue = false;
			creditsMenuAnimator.FadeOut(reset: false, OnEndCreditsFade);
		}
		else if (canContinue && creditsTimeout <= 0f)
		{
			canContinue = false;
			creditsMenuAnimator.FadeOut(reset: false, OnEndCreditsSectionFade);
		}
	}

	private void OnEndCreditsFade()
	{
		base.State = States.Menu;
	}

	private void OnEndCreditsSectionFade()
	{
		string creditsString = GetCreditsString(creditsIndex);
		if (creditsString != string.Empty)
		{
			creditsMenu.SetText("main_text", creditsString);
			creditsMenuAnimator.FadeIn();
			creditsIndex++;
			creditsTimeout = 6f;
			canContinue = true;
		}
		else
		{
			base.State = States.Menu;
		}
	}

	private string GetCreditsString(int idx)
	{
		string key = "MENU_CREDITS_SECTION_" + idx;
		if (!Translate.Check(key))
		{
			return string.Empty;
		}
		return Translate.Get(key);
	}

	private void Controls_Enter()
	{
		canContinue = true;
		fast = false;
		crosshairFar.gameObject.SetActive(value: false);
		InputExt.Get().lockedActiveController = true;
		StartCoroutine(Controls_co());
	}

	private IEnumerator Controls_co()
	{
		Renderer toFade3 = controlsOculusGoPad;
		if (InputExt.UsingHandControllers)
		{
			toFade3 = ((!InputExt.LeftHanded) ? controlsTouchRight : controlsTouchLeft);
		}
		StartCoroutine(FadeIn(toFade3));
		yield return new WaitForSeconds(4f);
		toFade3 = continueTouch;
		toFade3 = ((!InputExt.UsingHandControllers) ? continuePad : continueTouch);
		StartCoroutine(FadeIn(toFade3));
	}

	private void Controls_Update()
	{
		bool flag = InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction);
		if (InputExt.UsingHandControllers)
		{
			flag |= InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.Light);
		}
		if (canContinue && flag)
		{
			canContinue = false;
			if (!enterDemo && !randomMapMode)
			{
				GameController.Get().NewGame("SavedGame_00", enterLite);
			}
			else if (randomMapMode)
			{
				GameController.Get().StartRandomMap();
			}
			else if (enterDemo)
			{
				GameController.Get().StartDemo();
				GameState.Get().Reset();
			}
		}
	}

	private void Controls_Exit()
	{
	}

	private void Options_Enter()
	{
		optionsMenu.gameObject.SetActive(value: true);
		optionsMenu.Visible = true;
		optionsMenu.SetCollidersEnabled(enabled: true);
		optionsMenu.GetButton("button_back").SetAction(OnOptions_Back);
		optionsMenuAnimator.FadeIn();
		crosshairFar.gameObject.SetActive(value: false);
		crosshairNear.gameObject.SetActive(value: true);
		dialogActive = true;
	}

	private void Options_Exit()
	{
		optionsMenuAnimator.FadeOut(reset: false, OnEndOptionsFade);
		optionsMenu.SetCollidersEnabled(enabled: false);
		crosshairNear.gameObject.SetActive(value: false);
	}

	private void OnEndOptionsFade()
	{
		optionsMenu.Visible = false;
		optionsMenu.gameObject.SetActive(value: false);
	}

	private void OnOptions_Back()
	{
		if (dialogActive)
		{
			base.State = States.Menu;
			dialogActive = false;
		}
	}

	public void OnBackButton()
	{
		if (base.State == States.Options)
		{
			OnOptions_Back();
		}
		else if (base.State == States.ConfirmOverwrite)
		{
			OnConfirmOverwrite_No();
		}
		else
		{
			GameController.Get().ExitGame();
		}
	}

	private IEnumerator FadeIn(Renderer renderer)
	{
		renderer.enabled = true;
		Color cInit = renderer.material.color;
		cInit.a = 0f;
		renderer.material.color = cInit;
		while (renderer.material.color.a < 1f)
		{
			Color c = renderer.material.color;
			c.a = Mathf.Clamp(c.a + FadeInSpeed * Time.deltaTime * ((!fast) ? 1f : 10f), 0f, 1f);
			renderer.material.color = c;
			yield return new WaitForEndOfFrame();
		}
	}

	private IEnumerator FadeOut(Renderer renderer)
	{
		while (renderer.material.color.a > 0f)
		{
			Color c = renderer.material.color;
			c.a = Mathf.Clamp(c.a - FadeOutSpeed * Time.deltaTime * ((!fast) ? 1f : 10f), 0f, 1f);
			renderer.material.color = c;
			yield return new WaitForEndOfFrame();
		}
		renderer.enabled = false;
	}

	private UIButton3D GetButton(string name)
	{
		Transform transform = mainMenu.transform.Find(name);
		if (transform == null)
		{
			return null;
		}
		return transform.GetComponent<UIDreadHallsMainButton>();
	}
}
public class Chest : MonoBehaviour
{
	public Transform TopCover;

	public bool IsOpen;

	public List<GameObject> ItemSpawns;

	public GameObject unlock;

	public Renderer tableMesh;

	private static Permutator EmptySeq;

	private bool firstUpdate = true;

	private TextLabel tutorialText;

	private bool checkTutorial;

	private Room room;

	private void Start()
	{
		if (EmptySeq == null)
		{
			EmptySeq = new Permutator(3, 10, 1);
		}
		IsOpen = false;
		tableMesh.enabled = false;
		float z = base.transform.localScale.z;
		if (z < 1f)
		{
			float num = 1f / z;
			unlock.transform.localScale = new Vector3(unlock.transform.localScale.x * num, unlock.transform.localScale.y, unlock.transform.localScale.z);
		}
	}

	private void Open()
	{
		IsOpen = true;
		tableMesh.enabled = true;
		if (!EmptySeq.Next)
		{
			int num = UnityEngine.Random.Range(1, 4);
			for (int i = 0; i < num; i++)
			{
				int index = UnityEngine.Random.Range(0, ItemSpawns.Count);
				GameObject gameObject = ItemSpawns[index];
				ItemSpawns.RemoveAt(index);
				gameObject.SetActive(value: true);
			}
		}
		TopCover.GetComponent<Collider>().enabled = false;
		if (tutorialText != null)
		{
			tutorialText.FadeOut(4f, disableOnFadeOut: true, destroyOnFadeOut: true);
			tutorialText = null;
		}
	}

	private void Update()
	{
		if (IsOpen)
		{
			Quaternion b = Quaternion.Euler(0f, 0f, 52f);
			TopCover.localRotation = Quaternion.Slerp(TopCover.localRotation, b, Time.deltaTime);
			float num = Quaternion.Angle(TopCover.localRotation, b);
			if (num <= 0.01f)
			{
				base.enabled = false;
			}
		}
		else if (checkTutorial && room != null && room.PlayerInside && Config.General().tutorials)
		{
			float num2 = (Player.GetGroundPos() - base.transform.position).sqrMagnitudeGround();
			if (num2 <= 6.25f)
			{
				ShowTutorial("TUTO_CHEST");
				checkTutorial = false;
			}
		}
		if (firstUpdate)
		{
			checkTutorial = Config.General().tutorials && !Tutorial.HasBeenShownBefore("TUTO_CHEST", add: false);
			room = Map.Get().At(base.transform.position).Room;
			firstUpdate = false;
		}
	}

	private void ShowTutorial(string tutoCode)
	{
		Vector3 localPos = base.transform.position + Vector3.up * 1.2f;
		Quaternion localRot = Quaternion.AngleAxis(25f, base.transform.forward) * Quaternion.LookRotation(-base.transform.right, Vector3.up);
		tutorialText = Tutorial.ShowInPlace(tutoCode, localPos, localRot);
	}
}
public class Collectable : InteractionListener
{
	public enum EItemType
	{
		Oil,
		Potion,
		Lamp,
		Coin,
		Note,
		Lockpick,
		Meta01,
		Meta02,
		Meta03,
		Meta04,
		Undefined
	}

	public EItemType itemType;

	public AudioClip pickupSound;

	private bool isExamining;

	private bool isMoving;

	private Inventory playerInventory;

	private MinimapPosition minimapPos;

	private Vector3 deltaCenter;

	public float examineDistance = 0.6f;

	private bool listenEndExamining;

	private TextLabel tutorialText;

	private Transform initParent;

	private TextLabel highlightTutorialText;

	private List<GameObject> objectsToNotify;

	private List<Collectable> enableWhenPicked;

	public Collectable pickAfter;

	private static bool alreadyPickedUp;

	private new void Awake()
	{
		base.Awake();
		enableWhenPicked = new List<Collectable>();
	}

	private new void Start()
	{
		base.Start();
		isMoving = false;
		initParent = base.transform.parent;
		Serializer.Add(this, OnSerialize, OnDeserialize);
		PlayerStats.Get().AddItem();
		if (pickAfter != null)
		{
			pickAfter.enableWhenPicked.Add(this);
			GetComponent<Collider>().enabled = false;
		}
	}

	private void OnSerialize(BinaryWriter writer)
	{
	}

	private void OnDeserialize(BinaryReader reader)
	{
	}

	private new void Update()
	{
		base.Update();
		if (isMoving)
		{
			PickUp_Update();
		}
		else if (isExamining)
		{
			Examine_Update();
		}
	}

	private void LateUpdate()
	{
		alreadyPickedUp = false;
	}

	private void Examine(string textCode)
	{
		isExamining = true;
		isMoving = false;
		listenEndExamining = false;
		GetComponent<Collider>().enabled = false;
		playerInventory = GameObject.FindWithTag(Tags.Inventory).GetComponent<Inventory>();
		minimapPos = GameObject.FindWithTag(Tags.Minimap).GetComponent<MinimapPosition>();
		playerInventory.Reorient();
		base.transform.parent = playerInventory.transform;
		float num = 0f;
		Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
		deltaCenter = Vector3.zero;
		if (componentsInChildren.Length > 0)
		{
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				deltaCenter += componentsInChildren[i].bounds.center;
				if (componentsInChildren[i].bounds.extents.y > num)
				{
					num = componentsInChildren[i].bounds.extents.y;
				}
			}
			deltaCenter /= (float)componentsInChildren.Length;
			deltaCenter = base.transform.InverseTransformPoint(deltaCenter);
		}
		Vector3 vector = playerInventory.transform.forward * examineDistance + playerInventory.transform.up * 0.15f;
		Vector3 vector2 = Vector3.forward * examineDistance;
		vector2.y = vector.y;
		tutorialText = Tutorial.ShowInPlace(textCode, vector2, Quaternion.Euler(0f, 0f, 0f), playerInventory.transform);
		tutorialText.transform.localScale = new Vector3(0.5f, 0.5f, 0.5f);
		float y = tutorialText.GetComponent<Renderer>().bounds.extents.y;
		vector2.y = vector.y + num + y + 0.15f;
		tutorialText.transform.localPosition = vector2;
		Vector3 eulerAngles = tutorialText.transform.rotation.eulerAngles;
		tutorialText.transform.rotation = Quaternion.Euler(0f, eulerAngles.y, 0f);
		Player.GetController().BlockMovement(blockRotation: false);
		playerInventory.Block();
	}

	private void Examine_Update()
	{
		Vector3 vector = base.transform.TransformPoint(deltaCenter) - base.transform.position;
		Vector3 b = playerInventory.transform.position + playerInventory.transform.forward * examineDistance + playerInventory.transform.up * 0.15f;
		base.transform.position = Vector3.Lerp(base.transform.position + vector, b, Time.deltaTime * 4f) - vector;
		float angle = 57.29578f * Time.deltaTime * 0.5f;
		Vector3 axis = base.transform.TransformDirection(new Vector3(0f, 1f, 0f));
		base.transform.RotateAround(base.transform.position + vector, axis, angle);
		minimapPos.Hide = true;
		if (listenEndExamining && (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.Cancel) || InputExt.GetButtonDown(InputExt.Button.Inventory)))
		{
			tutorialText.FadeOut(4f, disableOnFadeOut: true, destroyOnFadeOut: true);
			Player.GetController().UnblockMovement(unBlockRotation: false);
			playerInventory.Unblock();
			base.transform.parent = null;
			PickUp();
		}
		else if (!listenEndExamining)
		{
			listenEndExamining = true;
		}
	}

	private void PickUp()
	{
		isMoving = true;
		isExamining = false;
		GetComponent<Collider>().enabled = false;
		AudioSource.PlayClipAtPoint(pickupSound, base.transform.position);
		if (itemType == EItemType.Note)
		{
			PlayerNotes component = GameObject.FindWithTag(Tags.PlayerNotes).GetComponent<PlayerNotes>();
			if ((bool)component)
			{
				component.SetPreShowNote();
			}
		}
		if (enableWhenPicked != null)
		{
			for (int i = 0; i < enableWhenPicked.Count; i++)
			{
				enableWhenPicked[i].OnTopColledted();
			}
		}
	}

	private void PickUp_Update()
	{
		Vector3 vector = Player.GetLook().position - Vector3.up * 0.5f;
		Vector3 vector2 = vector - base.transform.position;
		if (vector2.sqrMagnitude <= 0.01f)
		{
			Inventory componentInChildren = Player.Get().GetComponentInChildren<Inventory>();
			componentInChildren.AddItem(itemType);
			if (itemType == EItemType.Note)
			{
				componentInChildren.UseItem(itemType);
			}
			Serializer.Remove(this);
			if (InputExt.UsingHandControllers)
			{
				Player.GetActionHand().PlayHapticCollect();
			}
			if (objectsToNotify != null)
			{
				for (int i = 0; i < objectsToNotify.Count; i++)
				{
					objectsToNotify[i].SendMessage("OnColledted", this, SendMessageOptions.DontRequireReceiver);
				}
			}
			PlayerStats.Get().AddCollectedItem();
			UnityEngine.Object.Destroy(base.gameObject);
		}
		else
		{
			float num = vector2.magnitude / 2f;
			num = 1f / num;
			base.transform.position = base.transform.position + vector2.normalized * num * Time.deltaTime * 2f;
		}
	}

	protected override bool OnInteraction()
	{
		if (itemType == EItemType.Note)
		{
			PlayerNotes component = GameObject.FindWithTag(Tags.PlayerNotes).GetComponent<PlayerNotes>();
			if ((bool)component && component.IsShowingNote)
			{
				return false;
			}
		}
		if (Player.GetInventory().IsBlocked())
		{
			return false;
		}
		if (alreadyPickedUp)
		{
			return false;
		}
		canInteract = false;
		alreadyPickedUp = true;
		string textCode = ("TUTO_ITEM_" + itemType).ToUpper();
		if (!Tutorial.HasBeenShownBefore(textCode, add: false))
		{
			Examine(textCode);
		}
		else
		{
			PickUp();
		}
		if (highlightTutorialText != null)
		{
			highlightTutorialText.FadeOut(4f, disableOnFadeOut: true, destroyOnFadeOut: true);
			highlightTutorialText = null;
		}
		return true;
	}

	protected override void OnHighlight()
	{
		if (!Tutorial.Get().tutoState.tutorialCollect)
		{
			Tutorial.Get().tutoState.tutorialCollect = true;
			Vector3 vector = base.transform.position + Vector3.up * 0.45f;
			Vector3 vector2 = (Player.GetCenterEye() - vector).GroundNormalize();
			Quaternion localRot = Quaternion.LookRotation(-vector2, Vector3.up);
			highlightTutorialText = Tutorial.ShowInPlace("TUTO_COLLECT", vector, localRot);
		}
	}

	public void NotifyOnPickUp(GameObject obj)
	{
		if (objectsToNotify == null)
		{
			objectsToNotify = new List<GameObject>();
		}
		objectsToNotify.Add(obj);
	}

	public void OnTopColledted()
	{
		GetComponent<Collider>().enabled = true;
	}
}
public class CollectableGroup : MonoBehaviour
{
	public List<Collectable.EItemType> spawnItems;

	private int idx;

	private void Awake()
	{
		if (spawnItems != null)
		{
			CollectableSpawnController component = GameObject.FindWithTag(Tags.GameController).GetComponent<CollectableSpawnController>();
			component.AddSpawnGroup(this);
			idx = 0;
		}
	}

	public Collectable.EItemType GetNext()
	{
		if (idx >= spawnItems.Count)
		{
			return Collectable.EItemType.Undefined;
		}
		Collectable.EItemType result = spawnItems[idx];
		idx++;
		return result;
	}
}
public class CollectableOld : MonoBehaviour
{
	public enum EItemType
	{
		Oil,
		Potion,
		Coin,
		Note
	}

	public EItemType ItemType;

	public float PickupDistance = 1.5f;

	public AudioClip PickupSound;

	public LayerMask LayerMask;

	private Transform PlayerLook;

	private bool IsMoving;

	private void Start()
	{
		PlayerLook = Player.GetLook();
		IsMoving = false;
	}

	private void Update()
	{
		if (!IsMoving)
		{
			Vector3 vector = PlayerLook.position - base.transform.position;
			vector.y = 0f;
			if (vector.sqrMagnitude <= PickupDistance * PickupDistance && Physics.Raycast(PlayerLook.position, PlayerLook.forward, out var hitInfo, PickupDistance, LayerMask) && hitInfo.collider == GetComponent<Collider>())
			{
				IsMoving = true;
				GetComponent<Collider>().enabled = false;
			}
			return;
		}
		Vector3 vector2 = PlayerLook.position - Vector3.up * 0.5f;
		Vector3 vector3 = vector2 - base.transform.position;
		if (vector3.sqrMagnitude <= 0.01f)
		{
			AudioSource.PlayClipAtPoint(PickupSound, base.transform.position);
			UnityEngine.Object.Destroy(base.gameObject);
		}
		else
		{
			float num = vector3.magnitude / 2f;
			num = 1f / num;
			base.transform.position = base.transform.position + vector3.normalized * num * Time.deltaTime * 2f;
		}
	}
}
public class CollectableSpawn : MonoBehaviour
{
	public float SpawnProbability = 0.8f;

	public float distanceFactor = 1f;

	public float radiusFactor = 1f;

	public bool parentToParent;

	private static CollectableSpawnController controller;

	private GameObject prefab;

	private void Awake()
	{
		if (!controller)
		{
			controller = GameObject.FindWithTag(Tags.GameController).GetComponent<CollectableSpawnController>();
		}
	}

	private void Start()
	{
		bool fromGroup = false;
		if ((bool)controller)
		{
			prefab = controller.GetCollectable(base.transform.position, out fromGroup);
		}
		if ((bool)prefab)
		{
			if (!fromGroup)
			{
				bool flag = false;
				Point point = Map.Get().WorldToCell(base.transform.position);
				for (int i = point.Y - 1; i <= point.Y + 1; i++)
				{
					if (flag)
					{
						break;
					}
					for (int j = point.X - 1; j <= point.X + 1; j++)
					{
						if (flag)
						{
							break;
						}
						if (j != point.X || i != point.Y)
						{
							Cell cell = Map.Get().At(j, i);
							if (cell.CanWalk() && !cell.Occupied)
							{
								flag = true;
							}
						}
					}
				}
				if (!flag)
				{
					UnityEngine.Object.Destroy(base.gameObject);
					return;
				}
			}
			GameObject gameObject = UnityEngine.Object.Instantiate(prefab, Vector3.zero, Quaternion.identity);
			if (parentToParent)
			{
				gameObject.transform.parent = base.transform.parent.parent;
			}
			else
			{
				gameObject.transform.parent = base.transform.parent;
			}
			gameObject.transform.position = base.transform.position - Vector3.up * (GetComponent<Renderer>().bounds.size.y / 2f);
			gameObject.transform.rotation = base.transform.rotation;
			if (distanceFactor != 1f)
			{
				Collectable component = gameObject.GetComponent<Collectable>();
				if (component != null)
				{
					component.distance *= distanceFactor;
				}
			}
			if (radiusFactor != 1f)
			{
				SphereCollider component2 = gameObject.GetComponent<SphereCollider>();
				if (component2 != null)
				{
					component2.radius *= radiusFactor;
				}
			}
		}
		UnityEngine.Object.Destroy(base.gameObject);
	}

	public static void Clear()
	{
		controller = null;
	}

	private void OnDrawGizmos()
	{
		CollectableSpawnController component = controller;
		if (!component)
		{
			component = GameObject.FindWithTag(Tags.GameController).GetComponent<CollectableSpawnController>();
		}
		if (!component)
		{
			return;
		}
		GameObject[] array = new GameObject[5];
		Quaternion[] array2 = new Quaternion[5];
		array[0] = component.OilPrefabs[0];
		array[1] = component.LockpickPrefabs[0];
		array[2] = component.NotesPrefabs[0];
		array[3] = component.TreasuryPrefabs[0];
		array[4] = component.TreasuryPrefabs[1];
		Matrix4x4 matrix4x = default(Matrix4x4);
		matrix4x.SetTRS(base.transform.position, base.transform.rotation, Vector3.one);
		for (int i = 0; i < array.Length; i++)
		{
			MeshFilter[] componentsInChildren = array[i].GetComponentsInChildren<MeshFilter>(includeInactive: true);
			for (int j = 0; j < componentsInChildren.Length; j++)
			{
				Mesh sharedMesh = componentsInChildren[j].sharedMesh;
				Matrix4x4 matrix4x2 = matrix4x;
				Vector3 localPosition = componentsInChildren[j].transform.localPosition;
				localPosition -= Vector3.up * (GetComponent<Renderer>().bounds.size.y / 2f);
				Quaternion localRotation = componentsInChildren[j].transform.localRotation;
				localPosition = matrix4x2.MultiplyPoint(localPosition);
				Quaternion quaternion = Quaternion.LookRotation(matrix4x2.GetColumn(2), matrix4x2.GetColumn(1));
				if (sharedMesh != null)
				{
					Matrix4x4 matrix = default(Matrix4x4);
					matrix.SetTRS(localPosition, quaternion * localRotation, componentsInChildren[j].transform.localScale);
					Graphics.DrawMeshNow(sharedMesh, matrix);
					Gizmos.color = new Color(0f, 0f, 0f, 0f);
					Gizmos.DrawCube(sharedMesh.bounds.center, sharedMesh.bounds.size);
				}
			}
		}
	}
}
public class CollectableSpawnController : MonoBehaviour
{
	public GameObject[] TreasuryPrefabs;

	public GameObject[] LockpickPrefabs;

	public GameObject[] OilPrefabs;

	public GameObject[] NotesPrefabs;

	public float SpawnProbability = 0.8f;

	public float ProbTreasury = 0.5f;

	public float ProbLockpick;

	public float ProbOil = 0.4f;

	public float ProbNote = 0.1f;

	public float RandomModeProbTreasury = 0.5f;

	public float RandomModeProbLockpick;

	public float RandomModeProbOil = 0.4f;

	public float RandomModeProbNote = 0.1f;

	public int TotalTreasury;

	public int TotalLockpicks;

	public int TotalOil;

	public int TotalNotes;

	private Dictionary<Point, CollectableGroup> collectableGroups = new Dictionary<Point, CollectableGroup>();

	private System.Random randomGen;

	private void Awake()
	{
		if (GameController.Get().levelOptions.isDemo)
		{
			ProbTreasury = 0.42000002f;
			ProbLockpick = 0f;
			ProbOil = 0.58000004f;
			ProbNote = 0f;
		}
		else if (GameController.Get().levelOptions.isRandomMode)
		{
			ProbTreasury = RandomModeProbTreasury;
			ProbLockpick = RandomModeProbLockpick;
			ProbOil = RandomModeProbOil;
			ProbNote = RandomModeProbNote;
		}
		else if (GameController.Get().levelOptions.generatorType != 0)
		{
			ProbTreasury = 0.24f;
			ProbLockpick = 0.285f;
			ProbOil = 0.325f;
			ProbNote = 0.15f;
		}
		randomGen = new System.Random(UnityEngine.Random.Range(0, 32000));
	}

	public GameObject GetCollectable(Vector3 pos, out bool fromGroup)
	{
		GameObject result = null;
		Collectable.EItemType eItemType = Collectable.EItemType.Undefined;
		Point point = Map.Get().WorldToCell(pos);
		if (collectableGroups.TryGetValue(point, out var value))
		{
			eItemType = value.GetNext();
			fromGroup = true;
			if (eItemType == Collectable.EItemType.Undefined)
			{
				return null;
			}
		}
		fromGroup = false;
		float num = 1f;
		Room room = Map.Get().At(point).Room;
		if (room != null && !room.IsSpawnRoom && room.IsDeadEnd)
		{
			num = ((room.Template.size != 0) ? 1.15f : 1.5f);
		}
		if (eItemType == Collectable.EItemType.Undefined && (float)randomGen.NextDouble() < SpawnProbability * GameController.Get().levelOptions.collectableSpawnFactor * num)
		{
			GameObject[] array = null;
			float num2 = (float)randomGen.NextDouble();
			if (num2 <= ProbTreasury)
			{
				array = TreasuryPrefabs;
				TotalTreasury++;
			}
			else if (num2 <= ProbTreasury + ProbOil)
			{
				array = OilPrefabs;
				TotalOil++;
			}
			else if (num2 <= ProbTreasury + ProbOil + ProbLockpick)
			{
				array = LockpickPrefabs;
				TotalLockpicks++;
			}
			else
			{
				array = NotesPrefabs;
				TotalNotes++;
			}
			result = array[randomGen.Next(0, array.Length)];
		}
		else if (eItemType != Collectable.EItemType.Undefined)
		{
			GameObject[] array2 = null;
			switch (eItemType)
			{
			case Collectable.EItemType.Coin:
				array2 = TreasuryPrefabs;
				TotalTreasury++;
				break;
			case Collectable.EItemType.Oil:
				array2 = OilPrefabs;
				TotalOil++;
				break;
			case Collectable.EItemType.Lockpick:
				array2 = LockpickPrefabs;
				TotalLockpicks++;
				break;
			case Collectable.EItemType.Note:
				array2 = NotesPrefabs;
				TotalNotes++;
				break;
			default:
				return null;
			}
			result = array2[randomGen.Next(0, array2.Length)];
		}
		return result;
	}

	public void AddSpawnGroup(CollectableGroup group)
	{
		Point key = Map.Get().WorldToCell(group.transform.position);
		collectableGroups[key] = group;
	}
}
public class FadeOnEyeClip : MonoBehaviour
{
	public float clipRange = 0.3f;

	public float falloffRange = 0.1f;

	private Vector3 deltaCenter;

	private List<Material> materials;

	private Transform[] playerEyes;

	private void Start()
	{
		Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
		deltaCenter = Vector3.zero;
		materials = new List<Material>();
		if (componentsInChildren.Length > 0)
		{
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				deltaCenter += componentsInChildren[i].bounds.center;
				for (int j = 0; j < componentsInChildren[i].materials.Length; j++)
				{
					materials.Add(componentsInChildren[i].materials[j]);
				}
			}
			deltaCenter /= (float)componentsInChildren.Length;
			deltaCenter = base.transform.InverseTransformPoint(deltaCenter);
		}
		playerEyes = new Transform[2];
		OVRCameraRig component = Player.Get().transform.Find("OVRCameraController").GetComponent<OVRCameraRig>();
		playerEyes[0] = component.leftEyeAnchor;
		playerEyes[1] = component.rightEyeAnchor;
	}

	private void Update()
	{
		float num = 1f;
		Vector3 vector = base.transform.position + deltaCenter;
		float num2 = clipRange + falloffRange;
		for (int i = 0; i < playerEyes.Length; i++)
		{
			float sqrMagnitude = (playerEyes[i].position - vector).sqrMagnitude;
			if (sqrMagnitude <= num2 * num2)
			{
				if (sqrMagnitude <= clipRange * clipRange)
				{
					num = 0f;
					continue;
				}
				float num3 = Mathf.Sqrt(sqrMagnitude);
				float value = (num3 - clipRange) / falloffRange;
				num = Mathf.Min(num, Mathf.Clamp01(value));
			}
		}
		for (int j = 0; j < materials.Count; j++)
		{
			materials[j].SetFloat("_Fade", num);
		}
		DebugExt.DrawPoint(vector, Color.blue, 0.1f);
		DebugExt.DrawSphere(vector, Color.blue, clipRange);
	}
}
public class Inventory : MonoBehaviour
{
	[Serializable]
	public class ItemProxyInfo
	{
		public bool grabbable;

		public float scaleFactor = 1f;

		public Vector3 posDelta = Vector3.zero;
	}

	public int[] NumItems;

	public List<GameObject> ItemPrefabs;

	public List<string> ItemLabels;

	public List<ItemProxyInfo> ItemProxyInfos;

	public GameObject optionsItemPrefab;

	public string optionsItemLabel;

	public float DisplayArcDistance = 1f;

	public float HighlightArcDistance = 0.6f;

	public float DisplayArcAngle = 100f;

	private float currentArcAngle;

	public GameObject LabelPrefab;

	public LayerMask LayerMask;

	public bool checkCollisions;

	public LayerMask CollisionLayerMask;

	public AudioClip OpenSound;

	public AudioClip CloseSound;

	public AudioClip HightlightSound;

	private bool Showing;

	private int blocked;

	private bool unblockWhenClosed;

	private List<GameObject> ItemInstances;

	private List<Vector3> ItemPositions;

	private List<string> ItemTexts;

	private List<int> ItemTypes;

	private GameObject HighlightedItem;

	private GameObject LastHighlightedItem;

	private GameObject HighlightedLabel;

	private Material lampMaterial;

	private GameObject HighlightCoolDownItem;

	private float HighlightCoolDown;

	private Transform ForwardDirection;

	private Transform LookDirection;

	private MinimapPosition MinimapPos;

	public AntiBodyDelta antiDelta;

	private Collider[] colliderBuffer = new Collider[12];

	private void Start()
	{
		NumItems = new int[Enum.GetNames(typeof(Collectable.EItemType)).Length];
		GameState.Get().GetInventory(this);
		if (GameController.Get().levelOptions.isDemo)
		{
			NumItems[0] = 1;
		}
		else if (GameController.Get().levelOptions.isRandomMode)
		{
			NumItems[0] = 1;
		}
		NumItems[2] = 1;
		ItemInstances = new List<GameObject>();
		ItemPositions = new List<Vector3>();
		Showing = false;
		blocked = 0;
		HighlightedItem = null;
		LastHighlightedItem = null;
		HighlightCoolDownItem = null;
		ForwardDirection = GameObject.FindWithTag(Tags.ForwardDirection).transform;
		LookDirection = Player.GetLook(interaction: true);
		MinimapPos = GameObject.FindWithTag(Tags.Minimap).GetComponent<MinimapPosition>();
		HighlightedLabel = UnityEngine.Object.Instantiate(LabelPrefab);
		HighlightedLabel.transform.parent = base.transform;
		HighlightedLabel.GetComponent<Renderer>().enabled = false;
		currentArcAngle = DisplayArcAngle;
		lampMaterial = null;
		if (antiDelta != null)
		{
			antiDelta.enabled = true;
			antiDelta.enabled = false;
		}
	}

	private void Update()
	{
		bool flag = false;
		flag = ((!Showing) ? (InputExt.GetButtonDown(InputExt.Button.Inventory) && blocked == 0) : (InputExt.GetButton(InputExt.Button.Inventory) && blocked == 0));
		LookDirection = Player.GetLook(interaction: true);
		if (!Showing && flag)
		{
			Showing = true;
			HighlightCoolDownItem = null;
			List<Tuple<GameObject, string, int>> list = BuildItemList();
			if (list.Count == 0)
			{
				Showing = false;
			}
			else
			{
				ItemTexts = new List<string>(list.Count);
				ItemTypes = new List<int>(list.Count);
				Reorient(enableAntiDelta: true);
				float num = currentArcAngle / (float)(list.Count + 1);
				float num2 = (0f - currentArcAngle) / 2f;
				for (int i = 0; i < list.Count; i++)
				{
					float angle = num2 + num * (float)(i + 1);
					Quaternion quaternion = Quaternion.AngleAxis(angle, Vector3.up);
					Vector3 vector = Vector3.forward * DisplayArcDistance;
					vector = quaternion * vector;
					bool flag2 = list[i].Item3 == 2;
					GameObject gameObject = UnityEngine.Object.Instantiate(list[i].Item1);
					gameObject.transform.parent = base.transform;
					gameObject.transform.localPosition = Vector3.zero + Vector3.down * 0.25f;
					if (flag2)
					{
						lampMaterial = gameObject.transform.Find("lantern_body").GetComponent<Renderer>().materials[1];
						lampMaterial.SetFloat("_Level", Player.GetTorchFuel().GetFuelLevelNormalized());
						lampMaterial.SetFloat("_EmissionIntensity", (!Player.GetTorchFuel().lightOn) ? 0.3f : 1f);
					}
					if (InputExt.Using3DOFController || InputExt.UsingHandControllers)
					{
						SphereCollider[] componentsInChildren = gameObject.GetComponentsInChildren<SphereCollider>();
						SphereCollider[] array = componentsInChildren;
						foreach (SphereCollider sphereCollider in array)
						{
							sphereCollider.center += Vector3.down * 0.025f;
							sphereCollider.radius += 0.05f;
						}
					}
					Collectable[] componentsInChildren2 = GetComponentsInChildren<Collectable>();
					Collectable[] array2 = componentsInChildren2;
					foreach (Collectable collectable in array2)
					{
						collectable.enabled = false;
					}
					ItemInstances.Add(gameObject);
					ItemPositions.Add(vector);
					ItemTexts.Add(list[i].Item2);
					ItemTypes.Add(list[i].Item3);
				}
				AudioSource.PlayClipAtPoint(OpenSound, base.transform.position);
			}
		}
		if (Showing)
		{
			if (flag)
			{
				GameObject highlightedItem = GetHighlightedItem();
				if ((bool)highlightedItem && highlightedItem != HighlightedItem)
				{
					AudioSource.PlayClipAtPoint(HightlightSound, highlightedItem.transform.position);
				}
				if ((bool)HighlightedItem && highlightedItem != HighlightedItem)
				{
					HighlightCoolDownItem = HighlightedItem;
					HighlightCoolDown = 0.4f;
				}
				HighlightedItem = highlightedItem;
				if (InputExt.UsingHandControllers && InputExt.GetButtonDown(InputExt.Button.Action) && (bool)HighlightedItem)
				{
					int index = 0;
					for (int l = 0; l < ItemInstances.Count; l++)
					{
						if (ItemInstances[l] == HighlightedItem)
						{
							index = l;
						}
					}
					if (ItemTypes[index] == -1)
					{
						OpenOptionsMenu();
					}
					else
					{
						ItemProxyInfo itemProxyInfo = ItemProxyInfos[ItemTypes[index]];
						if (itemProxyInfo.grabbable)
						{
							AudioSource.PlayClipAtPoint(CloseSound, base.transform.position);
							Block();
							Block();
							unblockWhenClosed = true;
							InventoryHandProxy.Create(HighlightedItem, (Collectable.EItemType)ItemTypes[index], itemProxyInfo.scaleFactor, itemProxyInfo.posDelta);
							HighlightedItem = null;
							flag = false;
						}
					}
				}
			}
			else
			{
				if (InputExt.GetButtonUp(InputExt.Button.Inventory) && !IsBlocked())
				{
					AudioSource.PlayClipAtPoint(CloseSound, base.transform.position);
					if ((bool)HighlightedItem && !InputExt.UsingHandControllers)
					{
						int index2 = 0;
						for (int m = 0; m < ItemInstances.Count; m++)
						{
							if (ItemInstances[m] == HighlightedItem)
							{
								index2 = m;
							}
						}
						if (ItemTypes[index2] == -1)
						{
							OpenOptionsMenu();
						}
						else
						{
							UseItem((Collectable.EItemType)ItemTypes[index2]);
						}
					}
				}
				HighlightedItem = null;
			}
			if (checkCollisions)
			{
				Vector3 direction = base.transform.forward * DisplayArcDistance;
				float magnitude = direction.magnitude;
				direction.Normalize();
				float t = 1f;
				if (Physics.Raycast(base.transform.position, direction, out var hitInfo, magnitude, CollisionLayerMask))
				{
					t = hitInfo.distance / magnitude;
					t = Mathf.Clamp01((t - 0.5f) * 2f);
				}
				currentArcAngle = Mathf.Lerp(DisplayArcAngle * 1.5f, DisplayArcAngle, t);
			}
			if (lampMaterial != null)
			{
				lampMaterial.SetFloat("_Level", Player.GetTorchFuel().GetFuelLevelNormalized());
				lampMaterial.SetFloat("_EmissionIntensity", (!Player.GetTorchFuel().lightOn) ? 0.3f : 1f);
			}
			bool flag3 = false;
			for (int n = 0; n < ItemInstances.Count; n++)
			{
				if (flag)
				{
					ItemPositions[n] = GetItemPosition(n, ItemInstances[n] == HighlightedItem);
				}
				else
				{
					ItemPositions[n] = Vector3.zero + Vector3.down * 0.25f;
				}
				Vector3 vector2 = ItemPositions[n] - ItemInstances[n].transform.localPosition;
				ItemInstances[n].transform.localPosition += vector2 * Time.deltaTime * ((!flag) ? 8f : 4f);
				ItemInstances[n].transform.localRotation *= Quaternion.Euler(0f, 57.29578f * Time.deltaTime * 0.5f, 0f);
				if (!flag && vector2.sqrMagnitude <= 0.0001f)
				{
					flag3 = true;
				}
			}
			if (HighlightedItem != null)
			{
				HighlightedLabel.GetComponent<Renderer>().enabled = true;
				HighlightedLabel.transform.localPosition = HighlightedItem.transform.localPosition - Vector3.up * 0.05f;
				Vector3 vector3 = -HighlightedLabel.transform.localPosition;
				vector3.Normalize();
				HighlightedLabel.transform.localPosition += vector3 * 0.1f;
				HighlightedLabel.transform.localRotation = Quaternion.LookRotation(-HighlightedLabel.transform.localPosition, Vector3.up) * Quaternion.AngleAxis(180f, Vector3.up);
				Color color = HighlightedLabel.GetComponent<Renderer>().material.color;
				float a = Mathf.Clamp(color.a + Time.deltaTime * 2.5f, 0f, 1f);
				if (LastHighlightedItem != HighlightedItem)
				{
					a = 0f;
					int index3 = 0;
					for (int num3 = 0; num3 < ItemInstances.Count; num3++)
					{
						if (ItemInstances[num3] == HighlightedItem)
						{
							index3 = num3;
						}
					}
					HighlightedLabel.GetComponent<TextLabel>().Text = ItemTexts[index3];
					if (ItemTypes[index3] == 2)
					{
						LampSwing componentInChildren = HighlightedItem.GetComponentInChildren<LampSwing>();
						if ((bool)componentInChildren)
						{
							componentInChildren.ResetAngles(componentInChildren.maxAngle * 0.5f);
						}
					}
					for (int num4 = 0; num4 < ItemInstances.Count; num4++)
					{
						if (ItemInstances[num4] == LastHighlightedItem && ItemTypes[num4] == 2)
						{
							LampSwing componentInChildren2 = LastHighlightedItem.GetComponentInChildren<LampSwing>();
							if ((bool)componentInChildren2)
							{
								componentInChildren2.ResetAngles(componentInChildren2.maxAngle * 0.5f);
							}
						}
					}
				}
				color.a = a;
				HighlightedLabel.GetComponent<Renderer>().material.color = color;
				LastHighlightedItem = HighlightedItem;
			}
			else
			{
				Color color2 = HighlightedLabel.GetComponent<Renderer>().material.color;
				float num5 = (color2.a = Mathf.Clamp(color2.a - Time.deltaTime * 4f, 0f, 1f));
				HighlightedLabel.GetComponent<Renderer>().material.color = color2;
				if (num5 <= 0f)
				{
					HighlightedLabel.GetComponent<Renderer>().enabled = false;
				}
				for (int num6 = 0; num6 < ItemInstances.Count; num6++)
				{
					if (ItemInstances[num6] == LastHighlightedItem && ItemTypes[num6] == 2)
					{
						LampSwing componentInChildren3 = LastHighlightedItem.GetComponentInChildren<LampSwing>();
						if ((bool)componentInChildren3)
						{
							componentInChildren3.ResetAngles(componentInChildren3.maxAngle * 0.5f);
						}
					}
				}
				LastHighlightedItem = null;
			}
			if (flag3)
			{
				foreach (GameObject itemInstance in ItemInstances)
				{
					UnityEngine.Object.Destroy(itemInstance);
				}
				ItemInstances.Clear();
				ItemPositions.Clear();
				Showing = false;
				lampMaterial = null;
				if (antiDelta != null)
				{
					antiDelta.enabled = false;
				}
			}
			if ((bool)HighlightCoolDownItem)
			{
				HighlightCoolDown -= Time.deltaTime;
				if (HighlightCoolDown <= 0f)
				{
					HighlightCoolDownItem = null;
					HighlightCoolDown = 0f;
				}
			}
		}
		if (flag)
		{
			MinimapPos.Hide = true;
		}
		if (!Showing && unblockWhenClosed)
		{
			Unblock();
			unblockWhenClosed = false;
		}
	}

	private void OpenOptionsMenu()
	{
		StartCoroutine(OpenOptionsMenu_co());
	}

	private IEnumerator OpenOptionsMenu_co()
	{
		Block();
		yield return new WaitForSeconds(0.6f);
		GameController.Get().EnterPause();
		Unblock();
	}

	public void Reorient(bool enableAntiDelta = false)
	{
		Vector3 toDirection = Player.GetLook().forward.GroundNormalize();
		Vector3 forward = base.transform.forward;
		forward.y = 0f;
		forward.Normalize();
		base.transform.rotation = Quaternion.FromToRotation(forward, toDirection) * base.transform.rotation;
		if (antiDelta != null && enableAntiDelta)
		{
			antiDelta.enabled = true;
		}
	}

	private Vector3 GetItemPosition(int index, bool highlighted = false)
	{
		float num = currentArcAngle / (float)(ItemInstances.Count + 1);
		float num2 = (0f - currentArcAngle) / 2f;
		float angle = num2 + num * (float)(index + 1);
		Quaternion quaternion = Quaternion.AngleAxis(angle, Vector3.up);
		Vector3 vector = Vector3.forward * ((!highlighted) ? DisplayArcDistance : HighlightArcDistance);
		if (!highlighted)
		{
			vector += Vector3.up * 0.06f;
		}
		else
		{
			vector += Vector3.up * 0.16f;
		}
		vector = quaternion * vector;
		if (checkCollisions)
		{
			Vector3 vector2 = base.transform.TransformPoint(vector);
			Vector3 position = vector2;
			Vector3 normalized = (vector2 - base.transform.position).normalized;
			float num3 = 0.16f;
			float num4 = vector.magnitude + num3;
			float num5 = 0f;
			if (Physics.Raycast(base.transform.position, normalized, out var hitInfo, num4, CollisionLayerMask))
			{
				position = base.transform.position + normalized * (hitInfo.distance - num3);
				num5 = Mathf.Clamp01(1f - (hitInfo.distance / num4 - 0.5f) * 2f);
			}
			position = base.transform.InverseTransformPoint(position);
			if (num5 > 0f)
			{
				bool flag = false;
				bool flag2 = false;
				if (ItemInstances.Count % 2 == 0)
				{
					flag = index < ItemInstances.Count / 2;
					flag2 = !flag;
				}
				else
				{
					flag = index < ItemInstances.Count / 2;
					flag2 = index > ItemInstances.Count / 2;
				}
				Vector3 vector3 = ((!flag) ? Vector3.right : (-Vector3.right));
				if (flag || flag2)
				{
					vector3 *= num5 * 0.05f;
					position += vector3;
				}
			}
			return position;
		}
		return vector;
	}

	private GameObject GetHighlightedItem()
	{
		if (Physics.Raycast(LookDirection.transform.position, LookDirection.forward, out var hitInfo, DisplayArcDistance * 1.5f, LayerMask))
		{
			foreach (GameObject itemInstance in ItemInstances)
			{
				if ((itemInstance == hitInfo.collider.gameObject || (hitInfo.collider.transform.parent != null && itemInstance == hitInfo.collider.transform.parent.gameObject)) && itemInstance != HighlightCoolDownItem)
				{
					return itemInstance;
				}
			}
		}
		else if (InputExt.UsingHandControllers)
		{
			foreach (GameObject itemInstance2 in ItemInstances)
			{
				SphereCollider component = itemInstance2.GetComponent<SphereCollider>();
				if (component == null && itemInstance2.transform.parent != null)
				{
					component = itemInstance2.transform.parent.GetComponent<SphereCollider>();
				}
				if (component != null)
				{
					float sqrMagnitude = (LookDirection.transform.position - component.transform.localToWorldMatrix.MultiplyPoint(component.center)).sqrMagnitude;
					if (sqrMagnitude <= component.radius * component.radius)
					{
						return itemInstance2;
					}
				}
			}
		}
		return null;
	}

	private List<Tuple<GameObject, string, int>> BuildItemList()
	{
		List<Tuple<GameObject, string, int>> list = new List<Tuple<GameObject, string, int>>();
		for (int i = 0; i < NumItems.Length; i++)
		{
			Collectable.EItemType eItemType = (Collectable.EItemType)i;
			if (eItemType == Collectable.EItemType.Lamp)
			{
				if (!InputExt.UsingHandControllers)
				{
					string descriptionText = Player.GetTorchFuel().GetDescriptionText();
					list.Add(new Tuple<GameObject, string, int>(ItemPrefabs[i], descriptionText, i));
				}
			}
			else if (NumItems[i] > 0)
			{
				string text = ItemLabels[i];
				if (NumItems[i] == 1)
				{
					text += "_1";
				}
				string item = string.Format(Translate.Get(text), NumItems[i]);
				list.Add(new Tuple<GameObject, string, int>(ItemPrefabs[i], item, i));
			}
		}
		if (optionsItemPrefab != null && (InputExt.Using3DOFController || InputExt.UsingHandControllers))
		{
			string item2 = Translate.Get(optionsItemLabel);
			list.Add(new Tuple<GameObject, string, int>(optionsItemPrefab, item2, -1));
		}
		return list;
	}

	public void AddItem(Collectable.EItemType eType, int iPicked = 1)
	{
		NumItems[(int)eType] += iPicked;
	}

	public bool ConsumeItem(Collectable.EItemType eType, int iToUse = 1)
	{
		if (NumItems[(int)eType] >= iToUse)
		{
			NumItems[(int)eType] -= iToUse;
			return true;
		}
		return false;
	}

	public int GetNumItems(Collectable.EItemType eType)
	{
		return NumItems[(int)eType];
	}

	public void UseItem(Collectable.EItemType eType, bool block = true)
	{
		switch (eType)
		{
		case Collectable.EItemType.Oil:
			if (NumItems[(int)eType] > 0)
			{
				NumItems[(int)eType]--;
				UseOil(block);
			}
			break;
		case Collectable.EItemType.Note:
			if (NumItems[(int)eType] > 0)
			{
				NumItems[(int)eType]--;
				UseNote(block);
			}
			break;
		case Collectable.EItemType.Lockpick:
			if (NumItems[(int)eType] > 0 && (InputExt.Using3DOFController || InputExt.UsingHandControllers) && Unlockable.UseLockpick())
			{
				NumItems[(int)eType]--;
			}
			break;
		case Collectable.EItemType.Lamp:
			if (InputExt.Using3DOFController || InputExt.UsingHandControllers)
			{
				UseLamp(block);
			}
			break;
		case Collectable.EItemType.Potion:
		case Collectable.EItemType.Coin:
			break;
		}
	}

	public void Block()
	{
		blocked++;
		if (antiDelta != null)
		{
			antiDelta.enabled = true;
		}
	}

	public void Unblock()
	{
		blocked--;
		if (antiDelta != null)
		{
			antiDelta.enabled = false;
		}
	}

	public bool IsBlocked()
	{
		return blocked > 0;
	}

	private void UseOil(bool block = true)
	{
		GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchFuel>().AddFuel();
		if (block)
		{
			unblockWhenClosed = true;
			Block();
		}
	}

	private void UseNote(bool block = true)
	{
		GameObject.FindWithTag(Tags.PlayerNotes).GetComponent<PlayerNotes>().ShowNote();
		if (block)
		{
			unblockWhenClosed = true;
			Block();
		}
	}

	private void UseLamp(bool block = true)
	{
		GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchFuel>().ToggleLight();
		if (block)
		{
			unblockWhenClosed = true;
			Block();
		}
	}

	public bool HasMetaItems()
	{
		for (int i = 6; i < NumItems.Length; i++)
		{
			if (NumItems[i] > 0)
			{
				return true;
			}
		}
		return false;
	}

	public GameObject GetItemPrefab(Collectable.EItemType itemType)
	{
		return ItemPrefabs[(int)itemType];
	}
}
public class InventoryHandProxy : FSMComponent<InventoryHandProxy.States>
{
	public enum States
	{
		Carried,
		Release,
		UseDisappear
	}

	public Collectable.EItemType itemType;

	private PlayerHand hand;

	private Transform handTransform;

	private Vector3 targetScale;

	private Vector3 targetPosDelta;

	private LayerMask layerMask;

	private bool isInReceptor;

	private Collider[] colliderBuffer = new Collider[4];

	private InventoryHandReceptor targetReceptor;

	private void Start()
	{
		hand = Player.GetActionHand();
		handTransform = Player.GetActionHandTransform();
		hand.IsVisible = false;
		layerMask = LayerMaskExtensions.Create("PlayerHandReceptor");
		base.transform.parent = Player.Get().transform;
		Init(States.Carried);
	}

	private void Carried_Enter()
	{
		if (Config.General().tutorials)
		{
			if (itemType == Collectable.EItemType.Oil && !Tutorial.HasBeenShownBefore("TUTO_PROXY_TOUCH_OIL", add: true))
			{
				Tutorial.Get().ShowTextForTime(Translate.Get("TUTO_PROXY_TOUCH_OIL"), 5f);
			}
			else if (itemType == Collectable.EItemType.Lockpick && Unlockable.waitingForProxyTutorial != null)
			{
				Unlockable.waitingForProxyTutorial.ShowProxyLockpickTutorial();
			}
		}
	}

	private void Carried_Update()
	{
		if (base.transform.parent != handTransform)
		{
			Vector3 vector = handTransform.position + targetPosDelta;
			base.transform.position = Interpolate.ApproachExp(base.transform.position, vector, Time.deltaTime * 20f);
			if ((base.transform.position - vector).sqrMagnitude <= 0.0004f)
			{
				base.transform.parent = handTransform;
			}
		}
		base.transform.localScale = Interpolate.ApproachExp(base.transform.localScale, targetScale * ((!isInReceptor) ? 1f : 0.9f), Time.deltaTime * 10f);
		int num = Physics.OverlapSphereNonAlloc(base.transform.position, 0.05f, colliderBuffer, layerMask, QueryTriggerInteraction.Collide);
		InventoryHandReceptor inventoryHandReceptor = null;
		for (int i = 0; i < num; i++)
		{
			InventoryHandReceptor component = colliderBuffer[i].GetComponent<InventoryHandReceptor>();
			if (component != null && component.acceptedItemType == itemType)
			{
				inventoryHandReceptor = component;
				if (!isInReceptor)
				{
					isInReceptor = true;
				}
				hand.PlayPositionalHaptic(colliderBuffer[i].transform.position, (colliderBuffer[i] as SphereCollider).radius, 0.2f, 0.4f, 0.05f, 0.15f);
				break;
			}
		}
		if (inventoryHandReceptor == null)
		{
			isInReceptor = false;
		}
		if (InputExt.GetButtonUp(InputExt.Button.Action))
		{
			hand.IsVisible = true;
			Player.GetInventory().Unblock();
			if (isInReceptor)
			{
				inventoryHandReceptor.UseItem(this);
				targetReceptor = inventoryHandReceptor;
				base.State = States.UseDisappear;
			}
			else
			{
				base.State = States.Release;
			}
		}
	}

	private void Release_Enter()
	{
		base.transform.parent = Player.Get().transform;
	}

	private void Release_Update()
	{
		Vector3 vector = Player.GetLook().position - Vector3.up * 0.5f;
		Vector3 vector2 = vector - base.transform.position;
		if (vector2.sqrMagnitude <= 0.01f)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			base.enabled = false;
		}
		else
		{
			float num = vector2.magnitude / 2f;
			num = 1f / num;
			base.transform.position = base.transform.position + vector2.normalized * num * Time.deltaTime * 1f;
		}
	}

	private void UseDisappear_Enter()
	{
		base.transform.parent = null;
	}

	private void UseDisappear_Update()
	{
		Vector3 position = targetReceptor.transform.position;
		Vector3 vector = position - base.transform.position;
		if (vector.sqrMagnitude <= 0.01f)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			base.enabled = false;
		}
		else
		{
			float num = vector.magnitude / 2f;
			num = 1f / num;
			base.transform.position = base.transform.position + vector.normalized * num * Time.deltaTime * 1f;
		}
		base.transform.localScale = Interpolate.ApproachExp(base.transform.localScale, Vector3.zero, Time.deltaTime);
	}

	public static InventoryHandProxy Create(GameObject inventoryItem, Collectable.EItemType itemType, float scaleFactor, Vector3 posDelta)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(inventoryItem, null);
		gameObject.transform.position = inventoryItem.transform.position;
		gameObject.transform.rotation = inventoryItem.transform.rotation;
		InventoryHandProxy inventoryHandProxy = gameObject.AddComponent<InventoryHandProxy>();
		inventoryHandProxy.itemType = itemType;
		inventoryHandProxy.targetScale = inventoryItem.transform.localScale * scaleFactor;
		inventoryHandProxy.targetPosDelta = posDelta;
		inventoryItem.SetActive(value: false);
		return inventoryHandProxy;
	}
}
public class InventoryHandReceptor : MonoBehaviour
{
	public Collectable.EItemType acceptedItemType;

	public AudioClip hapticsClip;

	public void UseItem(InventoryHandProxy handProxy)
	{
		if (handProxy.itemType != acceptedItemType)
		{
			return;
		}
		switch (acceptedItemType)
		{
		case Collectable.EItemType.Oil:
			Player.GetInventory().UseItem(acceptedItemType, block: false);
			break;
		case Collectable.EItemType.Lockpick:
			if (Player.GetInventory().ConsumeItem(acceptedItemType))
			{
				GameObject gameObject2 = base.gameObject;
				if (base.transform.parent != null)
				{
					gameObject2 = base.transform.parent.gameObject;
				}
				gameObject2.SendMessage("OnUseHandLockpick", handProxy.gameObject, SendMessageOptions.DontRequireReceiver);
			}
			break;
		case Collectable.EItemType.Meta01:
		{
			GameObject gameObject = base.gameObject;
			if (base.transform.parent != null)
			{
				gameObject = base.transform.parent.gameObject;
			}
			gameObject.SendMessage("Unlock");
			break;
		}
		}
	}

	public OVRHapticsClip GetHaptics(int channel = 1)
	{
		if (hapticsClip == null)
		{
			return null;
		}
		return new OVRHapticsClip(hapticsClip, channel);
	}
}
[RequireComponent(typeof(HingeJoint))]
public class LampAnchorFix : TimeIndependentBehaviour
{
	private HingeJoint joint;

	private void Start()
	{
		joint = GetComponent<HingeJoint>();
	}

	private new void Update()
	{
		base.Update();
		Transform transform = joint.connectedBody.transform;
		Vector3 position = transform.position;
		Vector3 vector = transform.TransformVector(joint.connectedAnchor);
		position += vector;
		position -= joint.anchor;
		base.transform.position = position;
		if (GameController.Get().Paused)
		{
			float y = transform.rotation.eulerAngles.y;
			Vector3 eulerAngles = base.transform.rotation.eulerAngles;
			base.transform.rotation = Quaternion.Euler(eulerAngles.x, y, eulerAngles.z);
		}
	}
}
public class LampHandHandle : MonoBehaviour
{
	private void Update()
	{
		float y = Quaternion.LookRotation(base.transform.parent.forward, Vector3.up).eulerAngles.y;
		base.transform.rotation = Quaternion.Euler(0f, y, 0f);
	}
}
[RequireComponent(typeof(HingeJoint))]
public class LampHandWalkSwing : TimeIndependentBehaviour
{
	public float period = 0.8f;

	public float velocity = 10f;

	public float force = 1f;

	public float walkSpeedThreshold = 0.2f;

	public float runSpeedThreshold = 0.2f;

	public float periodRun = 0.8f;

	public float velocityRun = 10f;

	public float forceRun = 1f;

	private HingeJoint joint;

	private Vector3 lastSpeed;

	private Vector3 lastPosition;

	private float timer;

	private void Start()
	{
		joint = GetComponent<HingeJoint>();
		lastPosition = Player.Get().transform.position;
	}

	private new void Update()
	{
		base.Update();
		Vector3 position = Player.Get().transform.position;
		float num = (position - lastPosition).magnitudeGround() / base.deltaTime;
		if (num < walkSpeedThreshold)
		{
			joint.useMotor = false;
			timer = 0f;
		}
		else
		{
			bool flag = num >= runSpeedThreshold;
			if (flag)
			{
				timer = Mathf.Clamp(timer, 0f - periodRun, periodRun);
			}
			bool flag2 = false;
			if (timer >= 0f)
			{
				timer -= Time.deltaTime;
				if (timer < 0f)
				{
					flag2 = true;
				}
			}
			else
			{
				timer += Time.deltaTime;
				if (timer > 0f)
				{
					flag2 = true;
				}
			}
			if (flag2)
			{
				JointMotor motor = joint.motor;
				motor.freeSpin = true;
				motor.targetVelocity = ((!(timer > 0f)) ? (-1f) : 1f) * ((!flag) ? velocity : velocityRun);
				motor.force = ((!flag) ? force : forceRun);
				joint.motor = motor;
				joint.useMotor = true;
				timer = ((!(timer > 0f)) ? (-1f) : 1f);
				timer *= ((!flag) ? period : periodRun);
			}
		}
		lastPosition = position;
	}
}
public class LampSwing : MonoBehaviour
{
	private float progress;

	private bool moveUp = true;

	public float speed = 1f;

	private int fastMode;

	public float energyFactor = 0.5f;

	public float maxAngle = 15f;

	private float curMaxAngle;

	private Quaternion rotDown;

	private Quaternion rotUp;

	private void Start()
	{
		curMaxAngle = maxAngle;
		RecomputeAngles();
	}

	private void Update()
	{
		progress += ((!moveUp) ? (-1f) : 1f) * speed * ((fastMode <= 0) ? 1f : 1.5f) * Time.deltaTime;
		if (progress >= 1f && moveUp)
		{
			curMaxAngle *= energyFactor;
			RecomputeAngles(recomputeUp: false);
			moveUp = false;
			if (fastMode > 0)
			{
				fastMode--;
			}
		}
		else if (progress <= 0f && !moveUp)
		{
			curMaxAngle *= energyFactor;
			RecomputeAngles(recomputeUp: true, recomputeDown: false);
			moveUp = true;
			if (fastMode > 0)
			{
				fastMode--;
			}
		}
		progress = Mathf.Clamp(progress, 0f, 1f);
		float t = Interpolate.EaseInOut(progress);
		base.transform.localRotation = Quaternion.Slerp(rotDown, rotUp, t);
	}

	public void ResetAngles(float newMaxAngle = 15f)
	{
		curMaxAngle = Mathf.Max(curMaxAngle, newMaxAngle / energyFactor);
		fastMode = 2;
	}

	private void RecomputeAngles(bool recomputeUp = true, bool recomputeDown = true)
	{
		if (recomputeUp)
		{
			rotUp = Quaternion.AngleAxis(curMaxAngle, Vector3.right);
		}
		if (recomputeDown)
		{
			rotDown = Quaternion.AngleAxis(0f - curMaxAngle, Vector3.right);
		}
	}
}
public class RandomMaterials : MonoBehaviour
{
	public Renderer[] renderers;

	public Material[] materials;

	private void Start()
	{
		Material material = RandomExt.Choice(materials);
		Renderer[] array = renderers;
		foreach (Renderer renderer in array)
		{
			renderer.material = material;
		}
	}
}
public class Jukebox : MonoBehaviour
{
	[Serializable]
	public class Mood
	{
		[Serializable]
		public class Song
		{
			public AudioClip clip;

			public float baseVolume = 1f;

			public bool loop;
		}

		public string name;

		public float volume = 1f;

		public float silenceFreq;

		public float silenceMinTime = 5f;

		public float silenceMaxTime = 20f;

		public float timeoutMin = 4f;

		public float timeoutMax = 9f;

		public bool canFirstBeSilence = true;

		public Song[] songs;

		private int lastSong = -1;

		public Song ChooseSong(bool canChooseSilence = true)
		{
			if (canChooseSilence && lastSong != -1 && UnityEngine.Random.value < silenceFreq)
			{
				lastSong = -1;
				return null;
			}
			int num;
			do
			{
				num = UnityEngine.Random.Range(0, songs.Length);
			}
			while (num == lastSong && songs.Length > 1);
			lastSong = num;
			return songs[num];
		}

		public Song GetCurrentSong()
		{
			if (lastSong < 0 || lastSong >= songs.Length)
			{
				return null;
			}
			return songs[lastSong];
		}

		public void SetSilence()
		{
			lastSong = -1;
		}
	}

	public Mood[] moods;

	public AudioSource channelExit;

	public AudioSource channelEnter;

	public AudioSource screechSound;

	private float exitTime = float.MaxValue;

	private float enterTime = float.MaxValue;

	public float volume = 1f;

	private Mood baseMood;

	private Mood enterMood;

	private Mood exitMood;

	private float activeTimeout;

	public float screechTimeout;

	private string wantedMood = string.Empty;

	private static Jukebox instance;

	public static Jukebox Get()
	{
		return instance;
	}

	public static void Clear()
	{
		instance = null;
	}

	private void Awake()
	{
		instance = this;
	}

	private void Start()
	{
		Debug.Log("Jukebox - Start");
		volume = Config.Audio().musicVolume;
		SetBaseMood("ambience");
		Debug.Log("Jukebox - Start end");
	}

	public void SetBaseMood(string moodName)
	{
		if (baseMood != null && baseMood.name == moodName)
		{
			return;
		}
		Mood mood = baseMood;
		Mood mood2 = SearchMood(moodName);
		if (mood2 != null)
		{
			baseMood = mood2;
			if (mood == enterMood)
			{
				SwapMoods();
				SetEnterMood(mood2);
			}
			else if (mood == exitMood)
			{
				SetExitMood(mood2);
			}
		}
	}

	private void SetActiveMood(string moodName, bool setAsWanted = true)
	{
		if (setAsWanted)
		{
			wantedMood = moodName;
			return;
		}
		if (enterMood != null && enterMood.name != moodName)
		{
			Mood mood = SearchMood(moodName);
			if (mood == null)
			{
				return;
			}
			SwapMoods();
			SetEnterMood(mood);
		}
		activeTimeout = UnityEngine.Random.Range(enterMood.timeoutMin, enterMood.timeoutMax);
	}

	public void SetIntense()
	{
		SetActiveMood("intense");
		screechTimeout = 10f;
	}

	public void SetTension()
	{
		SetActiveMood("tension");
	}

	public void SetScreech(float screech)
	{
		screechTimeout = screech;
	}

	private void SetSilence()
	{
		Mood mood = enterMood;
		if (mood != null && mood == baseMood)
		{
			mood.SetSilence();
			enterTime = RandomExt.GaussianRange(mood.silenceMinTime, mood.silenceMaxTime);
		}
	}

	public void PlaySilence(float min, float max)
	{
		if (!(enterMood.name == "intense"))
		{
			Mood mood = enterMood;
			if (mood != null && mood == baseMood)
			{
				mood.SetSilence();
				enterTime = UnityEngine.Random.Range(min, max);
			}
		}
	}

	public void PlaySilence()
	{
		PlaySilence(5f, 20f);
	}

	private void SwapMoods()
	{
		AudioSource audioSource = channelEnter;
		channelEnter = channelExit;
		channelExit = audioSource;
		float num = enterTime;
		enterTime = exitTime;
		exitTime = num;
	}

	private void SetExitMood(Mood mood)
	{
		if (channelExit.volume <= 0.1f)
		{
			exitMood = mood;
			Mood.Song song = mood.ChooseSong(canChooseSilence: false);
			exitTime = SetSongInChannel(channelExit, song);
		}
	}

	private void SetEnterMood(Mood mood)
	{
		enterMood = mood;
		if (mood == null)
		{
			return;
		}
		Mood.Song song = mood.ChooseSong(mood.canFirstBeSilence);
		if (song != null && song.clip == channelEnter.clip && channelEnter.volume >= 0.01f)
		{
			if (!channelEnter.isPlaying)
			{
				channelEnter.Play();
			}
			return;
		}
		if (song == null)
		{
			SetSilence();
		}
		else
		{
			enterTime = SetSongInChannel(channelEnter, song);
		}
		channelEnter.volume = 0f;
	}

	private Mood SearchMood(string moodName)
	{
		Mood[] array = moods;
		foreach (Mood mood in array)
		{
			if (mood.name == moodName)
			{
				return mood;
			}
		}
		return null;
	}

	private float SetSongInChannel(AudioSource channel, Mood.Song song)
	{
		if (channel.isPlaying)
		{
			channel.Stop();
		}
		channel.clip = song.clip;
		channel.loop = song.loop;
		channel.Play();
		return song.clip.length;
	}

	private void Update()
	{
		if (wantedMood != string.Empty)
		{
			SetActiveMood(wantedMood, setAsWanted: false);
			wantedMood = string.Empty;
		}
		float b = 0f;
		float b2 = 0f;
		if (enterMood != null)
		{
			Mood.Song currentSong = enterMood.GetCurrentSong();
			b = ((currentSong == null) ? 0f : (volume * enterMood.volume * currentSong.baseVolume));
		}
		channelEnter.volume = Mathf.Lerp(channelEnter.volume, b, Time.deltaTime);
		channelExit.volume = Mathf.Lerp(channelExit.volume, b2, Time.deltaTime);
		if (enterMood != baseMood)
		{
			activeTimeout -= Time.deltaTime;
			if (activeTimeout <= 0f)
			{
				SwapMoods();
				SetEnterMood(baseMood);
			}
		}
		if (enterMood != null)
		{
			enterTime -= Time.deltaTime;
			if (enterTime <= 0f)
			{
				Mood.Song song = enterMood.ChooseSong();
				if (song == null)
				{
					SetSilence();
				}
				else
				{
					enterTime = SetSongInChannel(channelEnter, song);
				}
			}
		}
		if (channelExit.isPlaying && !channelExit.loop)
		{
			exitTime -= Time.deltaTime;
			if (exitTime <= 0f)
			{
				Mood.Song song2 = enterMood.ChooseSong(canChooseSilence: false);
				exitTime = SetSongInChannel(channelExit, song2);
			}
		}
		if (screechTimeout > 0f || screechSound.isPlaying)
		{
			if (screechTimeout > 0f && !screechSound.isPlaying)
			{
				screechSound.Play();
			}
			screechTimeout -= Time.deltaTime;
			float b3 = ((!(screechTimeout <= 0f)) ? 1f : 0f);
			screechSound.volume = Mathf.Lerp(screechSound.volume, b3, Time.deltaTime);
			if (screechSound.volume <= 0.01f && screechTimeout <= 0f)
			{
				screechSound.Stop();
			}
		}
	}
}
public class LevelOptions : ScriptableObject
{
	[Serializable]
	public class AmbientOptions
	{
		[Range(0f, 5f)]
		public float weight = 1f;

		public AmbientSelector ambientDefault = new AmbientSelector();

		public AmbientSelector ambientRoom = new AmbientSelector();

		public AmbientSelector ambientLarge = new AmbientSelector("defaultFar");

		public AmbientSelector ambientHub = new AmbientSelector("defaultHub");

		public AmbientOptions()
		{
			weight = 1f;
			ambientDefault = new AmbientSelector();
			ambientRoom = new AmbientSelector();
			ambientLarge = new AmbientSelector("defaultFar");
			ambientHub = new AmbientSelector("defaultHub");
		}
	}

	[Serializable]
	public class StyleOptions
	{
		[Range(0f, 5f)]
		public float weight = 1f;

		public MapStyleSelectorList roomSmall;

		public MapStyleSelectorList roomMedium;

		public MapStyleSelectorList roomLarge;

		public MapStyleSelectorList roomHub;

		public MapStyleSelectorList corridorNarrow;

		public MapStyleSelectorList corridorLarge;

		public StyleOptions()
		{
			weight = 1f;
		}
	}

	public string tag = "dungeon";

	public MapBuilder.GeneratorType generatorType;

	public int serializeID;

	public bool isDemo;

	public bool isRandomMode;

	public AmbientOptions[] ambientOptions;

	public StyleOptions[] styleOptions;

	public GameObject[] doorPrefabs;

	public GameObject exitPrefab;

	public GameObject exitCollectablePrefab;

	public float collectableSpawnFactor = 1f;

	public string playerNotesGroup = "01";

	public bool ghosts = true;

	public bool ghostVisions;

	public bool ghostCanStretch;

	public float ghostsMinDelay;

	public float ghostsMaxDelay;

	public bool shadowWatchers = true;

	public float shadowWatchersMinDelay;

	public float shadowWatchersMaxDelay;

	public bool shadowChasers;

	public bool shadowChasersVisions;

	public float shadowChasersMinDelay;

	public float shadowChasersMaxDelay;

	public int maxProwlers = 2;

	public float prowlersMinDelay;

	public float prowlersMaxDelay;

	public int maxLightEaters = 3;

	public float lightEatersMinDelay;

	public float lightEatersMaxDelay;

	public bool spawnNextToPlayer;

	public bool gargoyles = true;

	public int maxFloaters = 2;

	public float floatersMinDelay;

	public float floatersMaxDelay;

	public bool safeMap;

	public string[] startTexts;

	public bool maskNone = true;

	public bool maskSmall;

	public bool maskMedium;

	public bool maskOShaped;

	public bool maskCross;

	public bool maskFortress;

	public bool maskTShaped;

	public bool maskUShaped;

	public string[] seeds;

	public AmbientOptions GetAmbientOptions()
	{
		if (ambientOptions.Length > 1)
		{
			List<Pair<AmbientOptions, float>> list = new List<Pair<AmbientOptions, float>>();
			for (int i = 0; i < ambientOptions.Length; i++)
			{
				list.Add(new Pair<AmbientOptions, float>(ambientOptions[i], ambientOptions[i].weight));
			}
			return RandomExt.WeightedChoice(list);
		}
		if (ambientOptions.Length == 1)
		{
			return ambientOptions[0];
		}
		return null;
	}

	public static LevelOptions GetMetaLevelOptions(int metaMapIdx = 1)
	{
		string path = "LevelOptions/meta_" + metaMapIdx.ToString("D2");
		return Resources.Load<LevelOptions>(path);
	}

	public bool IsMetaMap()
	{
		return generatorType != MapBuilder.GeneratorType.Default;
	}

	public static LevelOptions GetByName(string loName)
	{
		string path = "LevelOptions/" + loName;
		return Resources.Load<LevelOptions>(path);
	}

	public string GetStartText()
	{
		if (startTexts == null || startTexts.Length == 0)
		{
			return string.Empty;
		}
		return Translate.Get(RandomExt.Choice(startTexts));
	}
}
[Serializable]
public class MapStyleSelector
{
	public MapStyle style;
}
[Serializable]
public class MapStyleSelectorList
{
	public MapStyleSelector[] list;

	public bool IsValid()
	{
		return list.Length > 0;
	}

	public string GetStyle()
	{
		return RandomExt.Choice(list).style.name;
	}
}
[Serializable]
public class AmbientSelector
{
	public string ambient;

	public AmbientSelector(string def = "default")
	{
		ambient = def;
	}
}
public class LevelOptionsList : ScriptableObject
{
	public string[] levelOptions;

	public LevelOptions GetRandom()
	{
		string path = RandomExt.Choice(levelOptions);
		return Resources.Load<LevelOptions>(path);
	}

	public static LevelOptions GetRandomFromFolder(string folder)
	{
		string path = "LevelOptions/" + folder + "/_list";
		LevelOptionsList levelOptionsList = Resources.Load<LevelOptionsList>(path);
		if (levelOptionsList == null)
		{
			return null;
		}
		return levelOptionsList.GetRandom();
	}
}
public class Loader : MonoBehaviour
{
	public static string nextScene = "Intro";

	public ShaderVariantCollection shaderWarmUp;

	private void Start()
	{
		StartCoroutine(SceneLoad_co(nextScene));
	}

	private IEnumerator SceneLoad_co(string sceneName)
	{
		yield return 0;
		yield return 0;
		if (shaderWarmUp != null && !shaderWarmUp.isWarmedUp)
		{
			yield return new WaitForEndOfFrame();
			yield return new WaitForEndOfFrame();
			yield return new WaitForSeconds(2f);
			Debug.Log("Warming up shaders");
			shaderWarmUp.WarmUp();
		}
		yield return 0;
		Debug.Log("Loading: " + sceneName);
		float startTime = Time.realtimeSinceStartup;
		yield return UnityEngine.Application.LoadLevelAsync(sceneName);
	}

	public static void LoadLevel(string levelName)
	{
		nextScene = levelName;
		UnityEngine.Application.LoadLevel("Loading");
	}
}
public class AtlasProp : MonoBehaviour
{
	public bool noAtlas;

	public bool tiling;
}
[Serializable]
public enum CellType
{
	Rock,
	Room,
	Perimeter,
	EntranceMark,
	Door,
	Corridor,
	Blocked,
	Spawn,
	Pit,
	Shaft,
	PitShaft
}
public enum AdjacencyCode
{
	Clear = 0,
	LeftTop = 1,
	CenterTop = 2,
	RightTop = 4,
	LeftCenter = 8,
	RightCenter = 0x10,
	LeftBottom = 0x20,
	CenterBottom = 0x40,
	RightBottom = 0x80
}
public class Cell
{
	public CellType Type;

	public Room Room;

	public Door Door;

	public byte adjacency;

	public byte adjacencyPit;

	public byte adjacencyShaft;

	public byte adjacencyDoor;

	public bool Occupied;

	public bool CanFloatOver;

	public bool IsDoor;

	public AdjacencyCode IsBehindDoor;

	public AdjacencyCode IsNextToDoor;

	public bool CeilingShaft;

	public AdjacencyCode DoorSide;

	public VisibilityProbe Probe;

	public VisibilityProbe Spawn;

	public AmbientStyle Ambient;

	public float floorHeight;

	private static List<Light> lightList = new List<Light>();

	public Cell(CellType type)
	{
		Type = type;
		Room = null;
		Door = null;
		DoorSide = AdjacencyCode.Clear;
		Probe = null;
		Spawn = null;
		Occupied = true;
		Occupied = !IsClear();
		IsDoor = false;
		CanFloatOver = false;
		IsBehindDoor = AdjacencyCode.Clear;
		IsNextToDoor = AdjacencyCode.Clear;
		CeilingShaft = false;
		Ambient = null;
		floorHeight = 0f;
	}

	public void Set(CellType type)
	{
		Type = type;
		Occupied = !IsClear();
	}

	public CellType Get()
	{
		return Type;
	}

	public bool IsClear()
	{
		return Type == CellType.Room || Type == CellType.Corridor || Type == CellType.Spawn;
	}

	public bool CanWalk()
	{
		return IsClear() || Type == CellType.Door;
	}

	public bool CanTunnel()
	{
		return Type != CellType.Blocked && Type != CellType.Perimeter && Type != CellType.Pit;
	}

	public bool IsCorridor()
	{
		return IsClear() && Room == null;
	}

	public bool IsPit()
	{
		return Type == CellType.Pit;
	}

	public bool IsClearOrPit()
	{
		return IsClear() || IsPit();
	}

	public bool IsTransparent()
	{
		return !Occupied || IsClear() || IsPit();
	}

	public bool CheckAdjacency(byte adjMask)
	{
		return (adjacency & adjMask) == adjMask;
	}

	public bool CheckAdjacency(AdjacencyCode adjMask)
	{
		return (adjacency & (byte)adjMask) == (byte)adjMask;
	}

	public bool CheckAdjacencyPit(byte adjMask)
	{
		return (adjacencyPit & adjMask) == adjMask;
	}

	public bool CheckAdjacencyPit(AdjacencyCode adjMask)
	{
		return (adjacencyPit & (byte)adjMask) == (byte)adjMask;
	}

	public bool CheckAdjacencyCeiling(byte adjMask)
	{
		return ((adjacency | adjacencyShaft | adjacencyDoor) & adjMask) == adjMask;
	}

	public bool CheckAdjacencyCeiling(AdjacencyCode adjMask)
	{
		return ((adjacency | adjacencyShaft | adjacencyDoor) & (byte)adjMask) == (byte)adjMask;
	}

	public bool CheckAdjacencyClear(byte adjMask)
	{
		return (adjacency & adjMask) == 0;
	}

	public bool CheckAdjacencyClear(AdjacencyCode adjMask)
	{
		return (adjacency & (byte)adjMask) == 0;
	}

	public bool CheckAdjacencyClearPit(byte adjMask)
	{
		return (adjacencyPit & adjMask) == 0;
	}

	public bool CheckAdjacencyClearPit(AdjacencyCode adjMask)
	{
		return (adjacencyPit & (byte)adjMask) == 0;
	}

	public bool CheckAdjacencyClearCeiling(byte adjMask)
	{
		return ((adjacency | adjacencyShaft | adjacencyDoor) & adjMask) == 0;
	}

	public bool CheckAdjacencyClearCeiling(AdjacencyCode adjMask)
	{
		return ((adjacency | adjacencyShaft | adjacencyDoor) & (byte)adjMask) == 0;
	}

	public static bool CheckAdjacency(byte adjacency, byte adjMask)
	{
		return (adjacency & adjMask) == adjMask;
	}

	public static bool CheckAdjacency(byte adjacency, AdjacencyCode adjMask)
	{
		return (adjacency & (byte)adjMask) == (byte)adjMask;
	}

	public static bool CheckAdjacencyClear(byte adjacency, byte adjMask)
	{
		return (adjacency & adjMask) == 0;
	}

	public static bool CheckAdjacencyClear(byte adjacency, AdjacencyCode adjMask)
	{
		return (adjacency & (byte)adjMask) == 0;
	}

	public int GetNumAdjacentWalls()
	{
		return Utils.NumberOfSetBits(adjacency);
	}

	public int GetNumAdjacentWallsNoCorners()
	{
		int num = 0;
		num += (CheckAdjacency(AdjacencyCode.LeftCenter) ? 1 : 0);
		num += (CheckAdjacency(AdjacencyCode.RightCenter) ? 1 : 0);
		num += (CheckAdjacency(AdjacencyCode.CenterTop) ? 1 : 0);
		return num + (CheckAdjacency(AdjacencyCode.CenterBottom) ? 1 : 0);
	}

	public bool IsVisible()
	{
		if (!Probe)
		{
			return false;
		}
		return Probe.IsVisible;
	}

	public bool IsDiscovered()
	{
		if (!Probe)
		{
			return false;
		}
		return Probe.Discovered;
	}

	public bool CheckLoS(Vector3 cameraPos, int numRays = 1)
	{
		if (!Probe)
		{
			return false;
		}
		return Probe.CheckLoS(cameraPos, numRays);
	}

	public static float GetLightLevel(Point cellPos, bool addPlayerLight = false)
	{
		GetAffectingLights(cellPos, addPlayerLight);
		Color black = Color.black;
		float num = 0f;
		for (int i = 0; i < lightList.Count; i++)
		{
			Light light = lightList[i];
			float range = light.range;
			float num2 = (Map.Get().CellToWorld(cellPos) + Vector3.up * 1.5f - light.transform.position).magnitude / range;
			float num3 = 1f / (1f + 25f * num2 * num2);
			num3 *= light.intensity;
			num += num3;
			Color color = light.color * num3;
			black += color;
		}
		return black.Luminance();
	}

	public static List<Light> GetAffectingLights(Point cellPos, bool addPlayerLight = false)
	{
		lightList.Clear();
		MapChunk mapChunk = MapChunk.At(cellPos);
		for (int i = 0; i < mapChunk.lights.Count; i++)
		{
			if (mapChunk.lights[i].enabled && mapChunk.lights[i].gameObject.activeSelf)
			{
				LightFOV component = mapChunk.lights[i].GetComponent<LightFOV>();
				if ((bool)component && component.CellInFOV(cellPos))
				{
					lightList.Add(mapChunk.lights[i]);
				}
			}
		}
		for (int j = 0; j < mapChunk.linkedChunks.Count; j++)
		{
			MapChunk mapChunk2 = mapChunk.linkedChunks[j];
			for (int k = 0; k < mapChunk2.lights.Count; k++)
			{
				if (mapChunk2.lights[k].enabled && mapChunk2.lights[k].gameObject.activeSelf)
				{
					LightFOV component2 = mapChunk2.lights[k].GetComponent<LightFOV>();
					if ((bool)component2 && component2.CellInFOV(cellPos))
					{
						lightList.Add(mapChunk2.lights[k]);
					}
				}
			}
		}
		if (addPlayerLight)
		{
			GameObject gameObject = GameObject.FindWithTag(Tags.PlayerTorch);
			if ((bool)gameObject && (bool)gameObject.GetComponent<Light>() && gameObject.GetComponent<Light>().enabled)
			{
				VisibilityProbe probe = Map.Get().At(cellPos).Probe;
				if ((bool)probe && probe.IsVisible)
				{
					lightList.Add(gameObject.GetComponent<Light>());
				}
			}
		}
		return lightList;
	}
}
public class ChunkMesh
{
	public static void BuildMeshes(GameObject staticGeometryContainer)
	{
		for (int i = 0; i < MapChunk.chunkMap.Length; i++)
		{
			for (int j = 0; j < MapChunk.chunkMap[i].Length; j++)
			{
				Combine(j, i, staticGeometryContainer);
			}
		}
	}

	private static void Combine(int chunkX, int chunkY, GameObject staticGeometryContainer)
	{
		MapChunk mapChunk = MapChunk.chunkMap[chunkY][chunkX];
		Dictionary<Material, List<CombineInstance>> dictionary = new Dictionary<Material, List<CombineInstance>>();
		for (int i = 0; i < mapChunk.toCombine.Count; i++)
		{
			Renderer component = mapChunk.toCombine[i].GetComponent<Renderer>();
			if (component == null)
			{
				continue;
			}
			Material[] sharedMaterials = component.sharedMaterials;
			foreach (Material material in sharedMaterials)
			{
				if (material != null && !dictionary.ContainsKey(material))
				{
					dictionary.Add(material, new List<CombineInstance>());
				}
			}
		}
		for (int k = 0; k < mapChunk.toCombine.Count; k++)
		{
			MeshFilter meshFilter = mapChunk.toCombine[k];
			if (!(meshFilter != null) || !(meshFilter.mesh != null))
			{
				continue;
			}
			Material[] sharedMaterials2 = meshFilter.GetComponent<Renderer>().sharedMaterials;
			for (int l = 0; l < Mathf.Min(meshFilter.mesh.subMeshCount, sharedMaterials2.Length); l++)
			{
				Material material2 = sharedMaterials2[l];
				if (material2 != null)
				{
					CombineInstance item = default(CombineInstance);
					item.mesh = meshFilter.mesh;
					item.transform = meshFilter.transform.localToWorldMatrix;
					item.subMeshIndex = l;
					dictionary[material2].Add(item);
				}
			}
		}
		foreach (Material key in dictionary.Keys)
		{
			GameObject gameObject = new GameObject("_combined_" + chunkX + "_" + chunkY + "_" + key.name);
			gameObject.transform.parent = staticGeometryContainer.transform;
			gameObject.isStatic = true;
			MeshFilter meshFilter2 = gameObject.AddComponent<MeshFilter>();
			meshFilter2.mesh.CombineMeshes(dictionary[key].ToArray(), mergeSubMeshes: true, useMatrices: true);
			meshFilter2.mesh.RecalculateBounds();
			MeshRenderer meshRenderer = gameObject.GetComponent<MeshRenderer>();
			if (meshRenderer == null)
			{
				meshRenderer = gameObject.AddComponent<MeshRenderer>();
			}
			meshRenderer.material = key;
			mapChunk.AddGeometry(gameObject);
		}
		for (int m = 0; m < mapChunk.toCombine.Count; m++)
		{
			GameObject gameObject2 = mapChunk.toCombine[m].gameObject;
			UnityEngine.Object.Destroy(mapChunk.toCombine[m].GetComponent<Renderer>());
			UnityEngine.Object.Destroy(mapChunk.toCombine[m]);
			gameObject2.isStatic = true;
		}
	}

	private static void PaintColors(Mesh mesh, Texture2D hubHeatMap)
	{
		Color[] array = new Color[mesh.vertices.Length];
		for (int i = 0; i < array.Length; i++)
		{
			Vector3 vector = mesh.vertices[i];
			Vector2 vector2 = new Vector2(vector.x / 64f, 1f - (0f - vector.z) / 64f);
			Color color = new Color(1f, 1f, 1f);
			array[i] = color;
		}
		mesh.colors = array;
	}
}
public class CustomGenerator : GBGenerator
{
	protected List<Tuple<RoomTemplate, Point, int>> roomList;

	protected List<Tuple<int, int, bool>> listConnections;

	protected int startRoom;

	protected int exitRoom;

	protected string mainStyle = "dungeon";

	public CustomGenerator()
	{
		roomList = new List<Tuple<RoomTemplate, Point, int>>();
		listConnections = new List<Tuple<int, int, bool>>();
	}

	protected virtual void DefineMap()
	{
		if (1 == 0)
		{
			AddRoom("m01", 12, 8);
			AddRoom("s01", 4, 4);
			AddRoom("s04", 4, 24);
			AddRoom("s02", 20, 2);
			AddRoom("s03", 24, 10);
			AddRoom("testRoom2", 26, 18);
			AddRoom("m01", 36, 10);
			AddCorridor(0, 1);
			AddCorridor(1, 2);
			AddCorridor(3, 4);
			AddCorridor(2, 5);
			AddCorridor(5, 6, isDouble: true);
			startRoom = 5;
			exitRoom = 1;
		}
		else
		{
			AddRoom("e3s01", 2, 8);
			AddRoom("e3m01", 8, 14);
			AddRoom("e3m02", 18, 6);
			AddRoom("e3m03", 26, 6);
			AddRoom("e3l01", 32, 14);
			AddRoom("e3h01", 8, 20);
			AddRoom("e3s05", 8, 50);
			AddCorridor(0, 1);
			AddCorridor(2, 1);
			AddCorridor(2, 3);
			AddCorridor(3, 4, isDouble: true);
			AddCorridor(4, 5);
			AddCorridor(5, 6);
			startRoom = 0;
			exitRoom = 6;
		}
	}

	public virtual void AfterGeneration()
	{
	}

	public virtual void AfterBuild()
	{
	}

	protected int AddRoom(string name, int x, int y, bool isStart = false, bool isExit = false)
	{
		RoomTemplate roomTemplate = RoomTemplate.FindByName(name);
		if (roomTemplate == null)
		{
			Debug.LogError("Invalid room template: " + name);
			return -1;
		}
		int item = (isStart ? 1 : (isExit ? 2 : 0));
		roomList.Add(new Tuple<RoomTemplate, Point, int>(roomTemplate, new Point(x, y), item));
		return roomList.Count - 1;
	}

	protected void AddCorridor(int from, int to, bool isDouble = false)
	{
		listConnections.Add(new Tuple<int, int, bool>(from, to, isDouble));
	}

	protected void RemoveDoor(Point doorPos)
	{
		DoorPositions.Remove(doorPos);
		EntrancePositions.Add(doorPos);
	}

	public override Map Generate(int w, int h, Texture2D texOut, bool checkDoubleCorridors = true, bool checkRoomConnections = true)
	{
		CellMap = new Cell[Options.Height][];
		for (int i = 0; i < Options.Height; i++)
		{
			CellMap[i] = new Cell[Options.Width];
			for (int j = 0; j < Options.Width; j++)
			{
				CellMap[i][j] = new Cell(CellType.Rock);
			}
		}
		Rooms = new List<Room>();
		PropPositions = new List<RoomTemplate.PropMarker>();
		DoorPositions = new List<Point>();
		EntrancePositions = new List<Point>();
		FogPositions = new List<Point>();
		FakeDoubleEntrances = new List<Point>();
		DebugPoints = new List<Pair<Point, Color>>();
		Tags = new Manager(Options.Width, Options.Height);
		mainStyle = Options.mainTag;
		DefineMap();
		Tags.Set(MapTags.Group.Main, mainStyle, new IntRect(0, 0, w, h));
		ApplyMask();
		GenCustomRooms();
		GenerateConnections();
		Room room = Rooms[startRoom];
		Point pointInRoom = GetPointInRoom(room);
		bool flag = false;
		RoomTemplate.PropMarker propMarker;
		do
		{
			propMarker = RandomExt.Choice(PropPositions);
			flag = true;
			Room room2 = CellMap[propMarker.pos.Y][propMarker.pos.X].Room;
			flag = room2 == Rooms[exitRoom];
		}
		while (propMarker.width != 1 || propMarker.height != 1 || !flag);
		CellMap[pointInRoom.Y][pointInRoom.X].Set(CellType.Spawn);
		room.Safe = true;
		room.IsSpawnRoom = true;
		Point exitPosition = propMarker.pos.ToPoint();
		CleanMapCells();
		List<Point> list = new List<Point>();
		int[] arrItems = new int[6] { 0, 1, 1, 1, 2, 2 };
		int num = RandomExt.Choice(arrItems);
		for (int k = 0; k < num; k++)
		{
			if (list.Count <= 0)
			{
				break;
			}
			int index = UnityEngine.Random.Range(0, list.Count);
			FogPositions.Add(list[index]);
			list.RemoveAt(index);
		}
		AfterGeneration();
		Map map = new Map(Options.Width, Options.Height, CellMap, Rooms, PropPositions, DoorPositions, EntrancePositions, FogPositions, Tags);
		map.ExitPosition = exitPosition;
		map.PrintToTexture(texOut);
		return map;
	}

	private void GenCustomRooms()
	{
		for (int i = 0; i < roomList.Count; i++)
		{
			Room room = RoomTemplate.PlaceRoomTemplated(this, i, roomList[i].Item2, roomList[i].Item1);
			if (room != null)
			{
				if (roomList[i].Item3 != 0)
				{
					room.Safe = true;
				}
				if (room.Template.size == RoomTemplate.SizeType.Hub)
				{
					room.Safe = true;
				}
				Rooms.Add(room);
			}
			else
			{
				Debug.LogError("Could not create room #" + i);
			}
		}
		foreach (Room room2 in Rooms)
		{
			string[] tags = ((room2.Template.size == RoomTemplate.SizeType.Large) ? new string[2] { "room", "large" } : ((room2.Template.size == RoomTemplate.SizeType.Medium) ? new string[2] { "room", "medium" } : ((room2.Template.size == RoomTemplate.SizeType.Small) ? new string[2] { "room", "small" } : ((room2.Template.size != RoomTemplate.SizeType.Hub) ? new string[1] { "room" } : new string[2] { "room", "hub" }))));
			for (int j = room2.Start.Y; j < room2.Start.Y + room2.Size.Y; j++)
			{
				for (int k = room2.Start.X; k < room2.Start.X + room2.Size.X; k++)
				{
					Cell cell = CellMap[j][k];
					if (cell.Room == room2)
					{
						if (room2.Template.size == RoomTemplate.SizeType.Large)
						{
							cell.Ambient = AmbientManager.Get().GetStyle(Options.ambientLarge);
						}
						else if (room2.Template.size == RoomTemplate.SizeType.Hub)
						{
							cell.Ambient = AmbientManager.Get().GetStyle(Options.ambientHub);
						}
						else
						{
							cell.Ambient = AmbientManager.Get().GetStyle(Options.ambientRoom);
						}
						Tags.Set(MapTags.Group.Style, tags, new Point(k, j));
					}
				}
			}
		}
	}

	private void GenerateConnections()
	{
		List<Tuple<Point, Point, bool>> list = new List<Tuple<Point, Point, bool>>();
		for (int i = 0; i < listConnections.Count; i++)
		{
			int item = listConnections[i].Item1;
			int item2 = listConnections[i].Item2;
			Room room = Rooms[item];
			Room room2 = Rooms[item2];
			bool flag = false;
			bool isDouble = listConnections[i].Item3;
			Point doorPos = new Point(0, 0);
			if (isDouble && !GetDoubleDoorInRoom(room, out doorPos))
			{
				isDouble = false;
			}
			if (!isDouble)
			{
				doorPos = GetDoorInRoom(room, out isDouble);
			}
			int num = 0;
			while (!flag)
			{
				num++;
				Point doorPos2 = doorPos;
				if (isDouble)
				{
					flag = GetClosestDoubleDoorInRoom(room2, out doorPos2, doorPos);
					if (!flag && num > 3)
					{
						isDouble = false;
					}
				}
				else
				{
					doorPos2 = GetDoorInRoom(room2, out var _);
					flag = true;
				}
				if (flag)
				{
					list.Add(new Tuple<Point, Point, bool>(doorPos, doorPos2, isDouble));
				}
			}
		}
		int iNumDoubleCorridors = 0;
		TunnelEdges(list, out iNumDoubleCorridors, alwaysSetStyle: true);
	}

	protected void SetSeed(uint seed)
	{
		UnityEngine.Random.seed = (int)seed;
		string text = $"{seed:X}";
		GameController.Get().GetComponent<MapBuilder>().seed = text;
		Debug.Log("Forced seed to: " + text);
	}
}
public class FloorNoise
{
	public static void AddFloorNoise(Map map, GameObject[][] floorPieces, MapBuilder mapBuilder)
	{
		for (int i = 0; i < map.Height; i++)
		{
			for (int j = 0; j < map.Width; j++)
			{
				if (!(floorPieces[i][j] != null))
				{
					continue;
				}
				MapStyle style = Map.Get().Tags.GetStyle(mapBuilder.mapStyles, new Point(j, i));
				if (style.floorNoise)
				{
					MeshFilter meshFilter = floorPieces[i][j].GetComponent<MeshFilter>();
					if (!meshFilter)
					{
						meshFilter = floorPieces[i][j].GetComponentInChildren<MeshFilter>();
					}
					if ((bool)meshFilter)
					{
						AddNoise(meshFilter, map, j, i, style, mapBuilder);
					}
				}
			}
		}
	}

	public static void AddCeilingNoise(Map map, GameObject[][] ceilingPieces, MapBuilder mapBuilder)
	{
		for (int i = 0; i < map.Height; i++)
		{
			for (int j = 0; j < map.Width; j++)
			{
				if (!(ceilingPieces[i][j] != null))
				{
					continue;
				}
				MapStyle style = Map.Get().Tags.GetStyle(mapBuilder.mapStyles, new Point(j, i));
				if (!style.ceilingNoise)
				{
					continue;
				}
				MeshFilter meshFilter = ceilingPieces[i][j].GetComponent<MeshFilter>();
				if (!meshFilter)
				{
					meshFilter = ceilingPieces[i][j].GetComponentInChildren<MeshFilter>();
				}
				if ((bool)meshFilter)
				{
					AdjacencyCode adjMask = (AdjacencyCode)255;
					if (map.At(j, i).CheckAdjacencyClearCeiling(adjMask))
					{
						AddNoise(meshFilter, map, j, i, style, mapBuilder, ceiling: true);
					}
				}
			}
		}
	}

	private static void AddNoise(MeshFilter meshFilter, Map map, int xPos, int yPos, MapStyle style, MapBuilder mapBuilder, bool ceiling = false)
	{
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = false;
		bool flag5 = false;
		bool flag6 = false;
		bool flag7 = false;
		bool flag8 = false;
		if (!ceiling)
		{
			Point point = new Point(xPos, yPos - 1);
			if (map.At(point).IsClear())
			{
				MapStyle style2 = Map.Get().Tags.GetStyle(mapBuilder.mapStyles, point);
				flag2 = !style2.floorNoise;
			}
			else if (map.At(point).IsPit())
			{
				flag2 = true;
			}
			Point point2 = new Point(xPos, yPos + 1);
			if (map.At(point2).IsClear())
			{
				MapStyle style3 = Map.Get().Tags.GetStyle(mapBuilder.mapStyles, point2);
				flag = !style3.floorNoise;
			}
			else if (map.At(point2).IsPit())
			{
				flag = true;
			}
			Point point3 = new Point(xPos - 1, yPos);
			if (map.At(point3).IsClear())
			{
				MapStyle style4 = Map.Get().Tags.GetStyle(mapBuilder.mapStyles, point3);
				flag3 = !style4.floorNoise;
			}
			else if (map.At(point3).IsPit())
			{
				flag3 = true;
			}
			Point point4 = new Point(xPos + 1, yPos);
			if (map.At(point4).IsClear())
			{
				MapStyle style5 = Map.Get().Tags.GetStyle(mapBuilder.mapStyles, point4);
				flag4 = !style5.floorNoise;
			}
			else if (map.At(point4).IsPit())
			{
				flag4 = true;
			}
			Point point5 = new Point(xPos - 1, yPos - 1);
			if (map.At(point5).IsClear())
			{
				MapStyle style6 = Map.Get().Tags.GetStyle(mapBuilder.mapStyles, point5);
				flag7 = !style6.floorNoise;
			}
			else if (map.At(point5).IsPit())
			{
				flag7 = true;
			}
			Point point6 = new Point(xPos + 1, yPos - 1);
			if (map.At(point6).IsClear())
			{
				MapStyle style7 = Map.Get().Tags.GetStyle(mapBuilder.mapStyles, point6);
				flag8 = !style7.floorNoise;
			}
			else if (map.At(point6).IsPit())
			{
				flag8 = true;
			}
			Point point7 = new Point(xPos - 1, yPos + 1);
			if (map.At(point7).IsClear())
			{
				MapStyle style8 = Map.Get().Tags.GetStyle(mapBuilder.mapStyles, point7);
				flag5 = !style8.floorNoise;
			}
			else if (map.At(point7).IsPit())
			{
				flag5 = true;
			}
			Point point8 = new Point(xPos + 1, yPos + 1);
			if (map.At(point8).IsClear())
			{
				MapStyle style9 = Map.Get().Tags.GetStyle(mapBuilder.mapStyles, point8);
				flag6 = !style9.floorNoise;
			}
			else if (map.At(point8).IsPit())
			{
				flag6 = true;
			}
		}
		if (ceiling)
		{
			AdjacencyCode adjMask = (AdjacencyCode)255;
			flag2 = !map.At(xPos, yPos - 1).CheckAdjacencyClearCeiling(adjMask);
			flag = !map.At(xPos, yPos + 1).CheckAdjacencyClearCeiling(adjMask);
			flag3 = !map.At(xPos - 1, yPos).CheckAdjacencyClearCeiling(adjMask);
			flag4 = !map.At(xPos + 1, yPos).CheckAdjacencyClearCeiling(adjMask);
			flag7 = !map.At(xPos - 1, yPos - 1).CheckAdjacencyClearCeiling(adjMask);
			flag8 = !map.At(xPos + 1, yPos - 1).CheckAdjacencyClearCeiling(adjMask);
			flag5 = !map.At(xPos - 1, yPos + 1).CheckAdjacencyClearCeiling(adjMask);
			flag6 = !map.At(xPos + 1, yPos + 1).CheckAdjacencyClearCeiling(adjMask);
		}
		bool flag9 = false;
		bool flag10 = false;
		bool flag11 = false;
		bool flag12 = false;
		bool flag13 = false;
		bool flag14 = false;
		bool flag15 = false;
		bool flag16 = false;
		if (!ceiling)
		{
			Cell cell = map.At(xPos, yPos);
			flag9 = cell.CheckAdjacency(AdjacencyCode.CenterBottom);
			flag10 = cell.CheckAdjacency(AdjacencyCode.CenterTop);
			flag11 = cell.CheckAdjacency(AdjacencyCode.LeftCenter);
			flag12 = cell.CheckAdjacency(AdjacencyCode.RightCenter);
			flag13 = cell.CheckAdjacency(AdjacencyCode.LeftBottom);
			flag14 = cell.CheckAdjacency(AdjacencyCode.RightBottom);
			flag15 = cell.CheckAdjacency(AdjacencyCode.LeftTop);
			flag16 = cell.CheckAdjacency(AdjacencyCode.RightTop);
		}
		Vector3 position = meshFilter.transform.position;
		Mesh mesh = meshFilter.mesh;
		Vector3[] vertices = mesh.vertices;
		Vector3 vector = meshFilter.transform.InverseTransformDirection(Vector3.up);
		if (ceiling)
		{
			vector = -vector;
		}
		float z = (position + new Vector3(0f, 0f, -1f) * 0.7f).z;
		float z2 = (position + new Vector3(0f, 0f, 1f) * 0.7f).z;
		float x = (position + new Vector3(-1f, 0f, 0f) * 0.7f).x;
		float x2 = (position + new Vector3(1f, 0f, 0f) * 0.7f).x;
		float num = 0f;
		for (int i = 0; i < vertices.Length; i++)
		{
			Vector3 vector2 = vertices[i];
			Vector3 vector3 = meshFilter.transform.TransformPoint(vertices[i]);
			float num2 = 0f;
			if (!ceiling)
			{
				num2 = (Mathf.Sin(vector3.x * 1f) + 1f) * 0.5f * 0.06f + (Mathf.Cos(vector3.z * 2f) + 1f) * 0.5f * 0.05f;
				num2 += (Mathf.Sin(vector3.x * 500f) + 1f) * 0.5f * 0.05f + (Mathf.Cos(vector3.z * 1000f) + 1f) * 0.5f * 0.02f;
			}
			else
			{
				num2 = Mathf.Sin(5f + vector3.x * 2f) * 0.06f + Mathf.Cos(2f + vector3.z * 1f) * 0.05f;
				num2 += Mathf.Sin(1f + vector3.x * 1000f) * 0.05f + Mathf.Cos(0.9f + vector3.z * 500f) * 0.02f;
			}
			if (flag9 && vector3.z <= z)
			{
				num2 += 0.1f;
			}
			else if (flag10 && vector3.z >= z2)
			{
				num2 += 0.1f;
			}
			else if (flag11 && vector3.x <= x)
			{
				num2 += 0.1f;
			}
			else if (flag12 && vector3.x >= x2)
			{
				num2 += 0.1f;
			}
			else if (flag13 && vector3.z <= z && vector3.x <= x)
			{
				num2 += 0.1f;
			}
			else if (flag14 && vector3.z <= z && vector3.x >= x2)
			{
				num2 += 0.1f;
			}
			else if (flag15 && vector3.z >= z2 && vector3.x <= x)
			{
				num2 += 0.1f;
			}
			else if (flag16 && vector3.z >= z2 && vector3.x >= x2)
			{
				num2 += 0.1f;
			}
			if (flag && vector3.z <= z)
			{
				num2 = 0f;
			}
			if (flag2 && vector3.z >= z2)
			{
				num2 = 0f;
			}
			if (flag3 && vector3.x <= x)
			{
				num2 = 0f;
			}
			if (flag4 && vector3.x >= x2)
			{
				num2 = 0f;
			}
			if (flag5 && vector3.z <= z && vector3.x <= x)
			{
				num2 = 0f;
			}
			if (flag6 && vector3.z <= z && vector3.x >= x2)
			{
				num2 = 0f;
			}
			if (flag7 && vector3.z >= z2 && vector3.x <= x)
			{
				num2 = 0f;
			}
			if (flag8 && vector3.z >= z2 && vector3.x >= x2)
			{
				num2 = 0f;
			}
			num += num2;
			ref Vector3 reference = ref vertices[i];
			reference = vector2 + vector * num2;
		}
		mesh.vertices = vertices;
		if (!ceiling)
		{
			map.At(xPos, yPos).floorHeight = num / (float)vertices.Length;
		}
	}

	public static bool CollapseEdge(MeshFilter meshFilter, Vector3 edge)
	{
		return false;
	}
}
public class ShadowCastFOV
{
	public static void Scan(Map map, Point sourcePos, float distance, Action<Map, Cell, Point> callback)
	{
		ExploreTile(map, map.At(sourcePos), sourcePos, callback);
		for (int i = 1; i < 9; i++)
		{
			RecursiveScan(map, sourcePos, distance, 1, i, 1f, 0f, callback);
		}
	}

	private static void RecursiveScan(Map map, Point sourcePos, float distance, int iDepth, int iOctant, float fStartSlope, float fEndSlope, Action<Map, Cell, Point> callback)
	{
		Point point = new Point(0, 0);
		Vector2 vEntityPos = new Vector2((float)sourcePos.X * map.TileSize.x + map.TileSize.x / 2f, (float)sourcePos.Y * map.TileSize.y + map.TileSize.y / 2f);
		float fMaxDistSq = distance * distance;
		Point point2 = new Point(0, 0);
		bool bInvert = false;
		Point point3 = new Point(0, 0);
		Vector2 vector = new Vector2(0f, 0f);
		Vector2 vector2 = new Vector2(0f, 0f);
		bool flag = false;
		float num = 1f;
		switch (iOctant)
		{
		case 1:
			bInvert = false;
			point2 = new Point(-1, 0);
			vector = new Vector2(-0.5f, 0.5f);
			vector2 = new Vector2(-0.5f, -0.5f);
			num = 1f;
			flag = false;
			point3 = new Point(1, 0);
			point.Y = sourcePos.Y - iDepth;
			point.X = sourcePos.X - (int)(fStartSlope * (float)iDepth);
			break;
		case 2:
			bInvert = false;
			point2 = new Point(1, 0);
			vector = new Vector2(0.5f, 0.5f);
			vector2 = new Vector2(0.5f, -0.5f);
			num = -1f;
			flag = true;
			point3 = new Point(-1, 0);
			point.Y = sourcePos.Y - iDepth;
			point.X = sourcePos.X + (int)(fStartSlope * (float)iDepth);
			break;
		case 3:
			bInvert = true;
			point2 = new Point(0, -1);
			vector = new Vector2(-0.5f, -0.5f);
			vector2 = new Vector2(0.5f, -0.5f);
			num = -1f;
			flag = true;
			point3 = new Point(0, 1);
			point.X = sourcePos.X + iDepth;
			point.Y = sourcePos.Y - (int)(fStartSlope * (float)iDepth);
			break;
		case 4:
			bInvert = true;
			point2 = new Point(0, 1);
			vector = new Vector2(-0.5f, 0.5f);
			vector2 = new Vector2(0.5f, 0.5f);
			num = 1f;
			flag = false;
			point3 = new Point(0, -1);
			point.X = sourcePos.X + iDepth;
			point.Y = sourcePos.Y + (int)(fStartSlope * (float)iDepth);
			break;
		case 5:
			bInvert = false;
			point2 = new Point(1, 0);
			vector = new Vector2(0.5f, -0.5f);
			vector2 = new Vector2(0.5f, 0.5f);
			num = 1f;
			flag = false;
			point3 = new Point(-1, 0);
			point.Y = sourcePos.Y + iDepth;
			point.X = sourcePos.X + (int)(fStartSlope * (float)iDepth);
			break;
		case 6:
			bInvert = false;
			point2 = new Point(-1, 0);
			vector = new Vector2(-0.5f, -0.5f);
			vector2 = new Vector2(-0.5f, 0.5f);
			num = -1f;
			flag = true;
			point3 = new Point(1, 0);
			point.Y = sourcePos.Y + iDepth;
			point.X = sourcePos.X - (int)(fStartSlope * (float)iDepth);
			break;
		case 7:
			bInvert = true;
			point2 = new Point(0, 1);
			vector = new Vector2(0.5f, 0.5f);
			vector2 = new Vector2(-0.5f, 0.5f);
			num = -1f;
			flag = true;
			point3 = new Point(0, -1);
			point.X = sourcePos.X - iDepth;
			point.Y = sourcePos.Y + (int)(fStartSlope * (float)iDepth);
			break;
		case 8:
			bInvert = true;
			point2 = new Point(0, -1);
			vector = new Vector2(0.5f, -0.5f);
			vector2 = new Vector2(-0.5f, -0.5f);
			num = 1f;
			flag = false;
			point3 = new Point(0, 1);
			point.X = sourcePos.X - iDepth;
			point.Y = sourcePos.Y - (int)(fStartSlope * (float)iDepth);
			break;
		}
		if (Map.Get().InRange(point))
		{
			while (num * Utils.GetSlope(point.X, point.Y, sourcePos.X, sourcePos.Y, bInvert) >= num * fEndSlope)
			{
				if (CheckTileVisible(map, point, vEntityPos, fMaxDistSq, out var _))
				{
					Cell cell = ((!map.InRange(point)) ? null : map.At(point));
					Point point4 = new Point(point.X + point2.X, point.Y + point2.Y);
					Cell cell2 = ((!map.InRange(point4)) ? null : map.At(point4));
					if (cell == null || !cell.IsTransparent())
					{
						if (cell2 != null && cell2.IsTransparent())
						{
							RecursiveScan(map, sourcePos, distance, iDepth + 1, iOctant, fStartSlope, Utils.GetSlope((float)point.X + vector.x, (float)point.Y + vector.y, sourcePos.X, sourcePos.Y, bInvert), callback);
						}
					}
					else
					{
						if (cell2 == null || !cell2.IsTransparent())
						{
							fStartSlope = Utils.GetSlope((float)point.X + vector2.x, (float)point.Y + vector2.y, sourcePos.X, sourcePos.Y, bInvert);
							fStartSlope = ((!flag) ? fStartSlope : (0f - fStartSlope));
						}
						ExploreTile(map, cell, point, callback);
					}
				}
				point.X += point3.X;
				point.Y += point3.Y;
			}
			point.X -= point3.X;
			point.Y -= point3.Y;
		}
		if (CheckTileVisible(map, point, vEntityPos, fMaxDistSq, out var _))
		{
			Cell cell3 = map.At(point);
			if (cell3.IsTransparent())
			{
				RecursiveScan(map, sourcePos, distance, iDepth + 1, iOctant, fStartSlope, fEndSlope, callback);
			}
		}
	}

	private static bool CheckTileVisible(Map map, Point tPoint, Vector2 vEntityPos, float fMaxDistSq, out float fTileDistSq)
	{
		Vector2 vector = new Vector2((float)tPoint.X * map.TileSize.x + map.TileSize.x / 2f, (float)tPoint.Y * map.TileSize.y + map.TileSize.y / 2f);
		fTileDistSq = (vector - vEntityPos).sqrMagnitude;
		return map.InRange(tPoint) && fTileDistSq <= fMaxDistSq;
	}

	public static void ExploreTile(Map map, Cell tTile, Point tPos, Action<Map, Cell, Point> callback)
	{
		callback(map, tTile, tPos);
	}
}
public class PermissiveFOV
{
	private struct Line
	{
		public int xi;

		public int yi;

		public int xf;

		public int yf;

		public Line(int xi, int yi, int xf, int yf)
		{
			this.xi = xi;
			this.yi = yi;
			this.xf = xf;
			this.yf = yf;
		}

		public int dx()
		{
			return xf - xi;
		}

		public int dy()
		{
			return yf - yi;
		}

		public bool isBelow(int x, int y)
		{
			return relativeSlope(x, y) > 0;
		}

		public bool isBelow(Point pos)
		{
			return isBelow(pos.X, pos.Y);
		}

		public bool isBelowOrCollinear(int x, int y)
		{
			return relativeSlope(x, y) >= 0;
		}

		public bool isBelowOrCollinear(Point pos)
		{
			return isBelowOrCollinear(pos.X, pos.Y);
		}

		public bool isAbove(int x, int y)
		{
			return relativeSlope(x, y) < 0;
		}

		public bool isAbove(Point pos)
		{
			return isAbove(pos.X, pos.Y);
		}

		public bool isAboveOrCollinear(int x, int y)
		{
			return relativeSlope(x, y) <= 0;
		}

		public bool isAboveOrCollinear(Point pos)
		{
			return isAboveOrCollinear(pos.X, pos.Y);
		}

		public bool isCollinear(int x, int y)
		{
			return relativeSlope(x, y) == 0;
		}

		public bool isCollinear(Point pos)
		{
			return isCollinear(pos.X, pos.Y);
		}

		public bool isCollinear(Line line)
		{
			return isCollinear(line.xi, line.yi) && isCollinear(line.xf, line.yf);
		}

		public int relativeSlope(int x, int y)
		{
			return dy() * (xf - x) - dx() * (yf - y);
		}
	}

	private class ViewBump
	{
		public int x;

		public int y;

		public ViewBump parent;

		public int refs;

		public static Pool<ViewBump> pool = new Pool<ViewBump>();

		public void Init(int x, int y, ViewBump parent)
		{
			this.x = x;
			this.y = y;
			this.parent = parent;
			refs = 0;
			if (parent != null)
			{
				parent.refs++;
			}
		}

		public ViewBump Clone()
		{
			ViewBump viewBump = pool.Get();
			viewBump.Init(x, y, parent);
			return viewBump;
		}

		public void Free()
		{
			if (parent != null)
			{
				parent.refs--;
				if (parent.refs == 0)
				{
					parent.Free();
				}
			}
			parent = null;
			pool.Free(this);
		}
	}

	private class View
	{
		public Line shallowLine;

		public Line steepLine;

		public ViewBump shallowBump;

		public ViewBump steepBump;

		public static Pool<View> pool = new Pool<View>();

		public void Init(Line shallow, Line steep)
		{
			shallowLine = shallow;
			steepLine = steep;
			shallowBump = null;
			steepBump = null;
		}

		public View Clone()
		{
			View view = pool.Get();
			view.Init(shallowLine, steepLine);
			view.shallowBump = ((shallowBump == null) ? null : shallowBump.Clone());
			view.steepBump = ((steepBump == null) ? null : steepBump.Clone());
			return view;
		}

		public void Free()
		{
			if (shallowBump != null)
			{
				shallowBump.Free();
			}
			if (steepBump != null)
			{
				steepBump.Free();
			}
			shallowBump = (steepBump = null);
			pool.Free(this);
		}
	}

	public static Action<Map, Cell, Point> callback;

	private static List<View> activeViews = new List<View>();

	public static void Scan(Map map, Point sourcePos, int radius)
	{
		sourcePos = TransformCoord(map, sourcePos);
		ExploreTile(map, sourcePos);
		int extentX = ((sourcePos.X >= radius) ? radius : sourcePos.X);
		int extentX2 = ((map.Width - sourcePos.X - 1 >= radius) ? radius : (map.Width - sourcePos.X - 1));
		int extentY = ((sourcePos.Y >= radius) ? radius : sourcePos.Y);
		int extentY2 = ((map.Height - sourcePos.Y >= radius) ? radius : (map.Height - sourcePos.Y - 1));
		CheckQuadrant(map, sourcePos, 1, 1, extentX2, extentY2);
		CheckQuadrant(map, sourcePos, 1, -1, extentX2, extentY);
		CheckQuadrant(map, sourcePos, -1, -1, extentX, extentY);
		CheckQuadrant(map, sourcePos, -1, 1, extentX, extentY2);
	}

	private static void CheckQuadrant(Map map, Point sourcePos, int deltaX, int deltaY, int extentX, int extentY)
	{
		activeViews.Clear();
		Line shallow = new Line(0, 1, extentX, 0);
		Line steep = new Line(1, 0, 0, extentY);
		View view = View.pool.Get();
		view.Init(shallow, steep);
		activeViews.Add(view);
		int num = 0;
		int num2 = extentX + extentY;
		for (int i = 1; i != num2 + 1; i++)
		{
			if (activeViews.Count <= 0)
			{
				break;
			}
			int num3 = 0;
			int num4 = i;
			num3 = ((0 <= i - extentX) ? (i - extentX) : 0);
			num4 = ((i >= extentY) ? extentY : i);
			for (int j = num3; j != num4 + 1; j++)
			{
				if (num >= activeViews.Count)
				{
					break;
				}
				int x = i - j;
				int y = j;
				VisitCoord(map, sourcePos, x, y, deltaX, deltaY, num, activeViews);
			}
		}
		for (int k = 0; k < activeViews.Count; k++)
		{
			activeViews[k].Free();
		}
		activeViews.Clear();
	}

	private static void VisitCoord(Map map, Point sourcePos, int x, int y, int deltaX, int deltaY, int viewIndex, List<View> activeViews)
	{
		Point pos = new Point(x, y + 1);
		Point pos2 = new Point(x + 1, y);
		while (viewIndex < activeViews.Count && activeViews[viewIndex].steepLine.isBelowOrCollinear(pos2))
		{
			viewIndex++;
		}
		if (viewIndex == activeViews.Count || activeViews[viewIndex].shallowLine.isAboveOrCollinear(pos))
		{
			return;
		}
		bool flag = false;
		int num = x * deltaX;
		int num2 = y * deltaY;
		Point tPos = new Point(sourcePos.X + num, sourcePos.Y + num2);
		ExploreTile(map, tPos);
		if (!CheckBlocked(map, tPos))
		{
			return;
		}
		if (activeViews[viewIndex].shallowLine.isAbove(pos2) && activeViews[viewIndex].steepLine.isBelow(pos))
		{
			activeViews[viewIndex].Free();
			activeViews.RemoveAt(viewIndex);
			return;
		}
		if (activeViews[viewIndex].shallowLine.isAbove(pos2))
		{
			AddShallowBump(pos, activeViews, viewIndex);
			CheckView(activeViews, viewIndex);
			return;
		}
		if (activeViews[viewIndex].steepLine.isBelow(pos))
		{
			AddSteepBump(pos2, activeViews, viewIndex);
			CheckView(activeViews, viewIndex);
			return;
		}
		int num3 = viewIndex;
		viewIndex++;
		int num4 = viewIndex;
		activeViews.Insert(num3, activeViews[num3].Clone());
		AddSteepBump(pos2, activeViews, num3);
		if (!CheckView(activeViews, num3))
		{
			viewIndex--;
			num4--;
		}
		AddShallowBump(pos, activeViews, num4);
		CheckView(activeViews, num4);
	}

	private static void AddShallowBump(Point pos, List<View> activeViews, int viewIndex)
	{
		activeViews[viewIndex].shallowLine.xf = pos.X;
		activeViews[viewIndex].shallowLine.yf = pos.Y;
		ViewBump viewBump = ViewBump.pool.Get();
		viewBump.Init(pos.X, pos.Y, activeViews[viewIndex].shallowBump);
		activeViews[viewIndex].shallowBump = viewBump;
		for (ViewBump viewBump2 = activeViews[viewIndex].steepBump; viewBump2 != null; viewBump2 = viewBump2.parent)
		{
			if (activeViews[viewIndex].shallowLine.isAbove(viewBump2.x, viewBump2.y))
			{
				activeViews[viewIndex].shallowLine.xi = viewBump2.x;
				activeViews[viewIndex].shallowLine.yi = viewBump2.y;
			}
		}
	}

	private static void AddSteepBump(Point pos, List<View> activeViews, int viewIndex)
	{
		activeViews[viewIndex].steepLine.xf = pos.X;
		activeViews[viewIndex].steepLine.yf = pos.Y;
		ViewBump viewBump = ViewBump.pool.Get();
		viewBump.Init(pos.X, pos.Y, activeViews[viewIndex].steepBump);
		activeViews[viewIndex].steepBump = viewBump;
		for (ViewBump viewBump2 = activeViews[viewIndex].shallowBump; viewBump2 != null; viewBump2 = viewBump2.parent)
		{
			if (activeViews[viewIndex].steepLine.isBelow(viewBump2.x, viewBump2.y))
			{
				activeViews[viewIndex].steepLine.xi = viewBump2.x;
				activeViews[viewIndex].steepLine.yi = viewBump2.y;
			}
		}
	}

	private static bool CheckView(List<View> activeViews, int viewIndex)
	{
		View view = activeViews[viewIndex];
		if (view.shallowLine.isCollinear(view.steepLine) && (view.shallowLine.isCollinear(0, 1) || view.shallowLine.isCollinear(1, 0)))
		{
			activeViews[viewIndex].Free();
			activeViews.RemoveAt(viewIndex);
			return false;
		}
		return true;
	}

	private static void ExploreTile(Map map, Point tPos)
	{
		tPos = TransformCoord(map, tPos);
		Cell arg = map.At(tPos);
		callback(map, arg, tPos);
	}

	private static bool CheckBlocked(Map map, Point tPos)
	{
		tPos = TransformCoord(map, tPos);
		Cell cell = map.At(tPos);
		return !cell.IsTransparent();
	}

	private static Point TransformCoord(Map map, Point pos)
	{
		return new Point(pos.X, map.Height - 1 - pos.Y);
	}
}
public class GBGenerator : MapGenerator
{
	public class MapOptions
	{
		public int Width;

		public int Height;

		public int RoomMin;

		public int RoomMax;

		public float PropClutter;

		public float DoorClutter;

		public int EdgeConnectivity;

		public MapStyle[] styles;

		public string mainTag;

		public string ambientDefault;

		public string ambientRoom;

		public string ambientLarge;

		public string ambientHub;

		public LevelOptions.StyleOptions styleOptions;

		public bool maskNone;

		public bool maskSmall;

		public bool maskMedium;

		public bool maskOShaped;

		public bool maskCross;

		public bool maskFortress;

		public bool maskTShaped;

		public bool maskUShaped;

		public RoomTemplate testRoom;

		public MapOptions(int width, int height)
		{
			Width = width;
			Height = height;
			RoomMin = 3;
			RoomMax = 10;
			PropClutter = 0.8f;
			DoorClutter = 0.6f;
			EdgeConnectivity = 3;
			testRoom = null;
			maskNone = true;
			maskSmall = (maskMedium = (maskOShaped = (maskCross = (maskFortress = (maskTShaped = (maskUShaped = false))))));
			mainTag = "dungeon";
			ambientDefault = "default";
			ambientRoom = "default";
			ambientLarge = "defaultFar";
			ambientHub = "defaultHub";
			styleOptions = null;
		}
	}

	private class CMask : List<Vector4>
	{
		public CMask(float fX, float fY, float fW, float fH)
		{
			Add(new Vector4(fX, fY, fW, fH));
		}

		public CMask Push(float fX, float fY, float fW, float fH)
		{
			Add(new Vector4(fX, fY, fW, fH));
			return this;
		}
	}

	public class SEdge : Tuple<int, int, float>
	{
		public SEdge(int start, int end, float fDist)
			: base(start, end, fDist)
		{
		}

		public int CompareTo(SEdge obj)
		{
			return base.Item3.CompareTo(obj.Item3);
		}
	}

	public Cell[][] CellMap;

	public List<Room> Rooms;

	public List<RoomTemplate.PropMarker> PropPositions;

	public List<Point> DoorPositions;

	public List<Point> EntrancePositions;

	public List<Point> FogPositions;

	public List<Point> FakeDoubleEntrances;

	public List<Pair<Point, Color>> DebugPoints;

	public Manager Tags;

	public MapOptions Options;

	public override Map Generate(int w, int h, Texture2D texOut, bool checkDoubleCorridors = true, bool checkRoomConnections = true)
	{
		Debug.Log("Generating new cellmap...");
		CellMap = new Cell[Options.Height][];
		for (int i = 0; i < Options.Height; i++)
		{
			CellMap[i] = new Cell[Options.Width];
			for (int j = 0; j < Options.Width; j++)
			{
				CellMap[i][j] = new Cell(CellType.Rock);
			}
		}
		Rooms = new List<Room>();
		PropPositions = new List<RoomTemplate.PropMarker>();
		DoorPositions = new List<Point>();
		EntrancePositions = new List<Point>();
		FogPositions = new List<Point>();
		FakeDoubleEntrances = new List<Point>();
		DebugPoints = new List<Pair<Point, Color>>();
		Tags = new Manager(Options.Width, Options.Height);
		Tags.Set(MapTags.Group.Main, Options.mainTag, new IntRect(0, 0, w, h));
		if (Options.styleOptions != null)
		{
			LevelOptions.StyleOptions styleOptions = Options.styleOptions;
			if (styleOptions.roomSmall.IsValid())
			{
				SetStyle(new string[3] { Options.mainTag, "room", "small" }, styleOptions.roomSmall.GetStyle());
			}
			if (styleOptions.roomMedium.IsValid())
			{
				SetStyle(new string[3] { Options.mainTag, "room", "medium" }, styleOptions.roomMedium.GetStyle());
			}
			if (styleOptions.roomLarge.IsValid())
			{
				SetStyle(new string[3] { Options.mainTag, "room", "large" }, styleOptions.roomLarge.GetStyle());
			}
			if (styleOptions.roomHub.IsValid())
			{
				SetStyle(new string[3] { Options.mainTag, "room", "hub" }, styleOptions.roomHub.GetStyle());
			}
			if (styleOptions.corridorNarrow.IsValid())
			{
				SetStyle(new string[3] { Options.mainTag, "corridor", "narrow" }, styleOptions.corridorNarrow.GetStyle());
			}
			if (styleOptions.corridorLarge.IsValid())
			{
				SetStyle(new string[3] { Options.mainTag, "corridor", "large" }, styleOptions.corridorLarge.GetStyle());
			}
		}
		ApplyMask();
		bool flag = Options.testRoom != null;
		if (!flag)
		{
			GenTemplatedRooms();
		}
		else
		{
			GenTestRoom(Options.testRoom);
		}
		int iNumDoubleCorridors = 0;
		ConnectRooms(out iNumDoubleCorridors);
		if (!flag && checkDoubleCorridors && iNumDoubleCorridors < 2)
		{
			return null;
		}
		foreach (Point fakeDoubleEntrance in FakeDoubleEntrances)
		{
			if (CellMap[fakeDoubleEntrance.Y][fakeDoubleEntrance.X].Get() != CellType.Door)
			{
				continue;
			}
			int num = 0;
			int num2 = 0;
			for (int k = fakeDoubleEntrance.Y - 1; k <= fakeDoubleEntrance.Y + 1; k++)
			{
				for (int l = fakeDoubleEntrance.X - 1; l <= fakeDoubleEntrance.X + 1; l++)
				{
					if ((l != fakeDoubleEntrance.X || k != fakeDoubleEntrance.Y) && CellMap[k][l].Get() == CellType.Door)
					{
						num++;
					}
					if ((l == fakeDoubleEntrance.X || k == fakeDoubleEntrance.Y) && (l != fakeDoubleEntrance.X || k != fakeDoubleEntrance.Y))
					{
						CellType cellType = CellMap[k][l].Get();
						if (cellType == CellType.Corridor || cellType == CellType.Room || cellType == CellType.Door)
						{
							num2++;
						}
					}
				}
			}
			if (num != 0 && (num2 < 2 || num2 >= 3))
			{
				CellMap[fakeDoubleEntrance.Y][fakeDoubleEntrance.X].Set(CellType.Perimeter);
			}
		}
		FixCorridorWraps();
		if (CheckCorridorBugs())
		{
			Debug.Log("Found continuity gaps in corridor junctions - Discarding cellmap...");
			return null;
		}
		bool flag2 = false;
		List<string> list = new List<string>();
		list.Add(Options.mainTag);
		list.Add("corridor");
		list.Add("large");
		MapStyle style = Tags.GetStyle(Options.styles, list);
		list = new List<string>();
		list.Add(Options.mainTag);
		list.Add("corridor");
		list.Add("narrow");
		MapStyle style2 = Tags.GetStyle(Options.styles, list);
		for (int m = 0; m < Options.Height; m++)
		{
			for (int n = 0; n < Options.Width; n++)
			{
				if (CellMap[m][n].Get() != CellType.Door)
				{
					continue;
				}
				bool flag3 = CellMap[m + 1][n].Get() == CellType.Door;
				if (CellMap[m][n + 1].Get() == CellType.Door)
				{
					if (CellMap[m + 1][n].IsClear() && !CellMap[m + 1][n + 1].IsClear())
					{
						CellMap[m][n + 1].Set(CellType.Perimeter);
						flag2 = true;
					}
					if (CellMap[m - 1][n].IsClear() && !CellMap[m - 1][n + 1].IsClear())
					{
						CellMap[m][n + 1].Set(CellType.Perimeter);
						flag2 = true;
					}
					if (CellMap[m + 1][n].IsClear() && CellMap[m + 1][n + 1].IsClear() && CellMap[m + 1][n + 1].Room == null && Tags.GetStyle(Options.styles, new Point(n + 1, m + 1)) == style2)
					{
						Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(n, m + 1));
						Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(n + 1, m + 1));
						flag2 = true;
					}
					if (CellMap[m - 1][n].IsClear() && CellMap[m - 1][n + 1].IsClear() && CellMap[m - 1][n + 1].Room == null && Tags.GetStyle(Options.styles, new Point(n + 1, m - 1)) == style2)
					{
						Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(n, m - 1));
						Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(n + 1, m - 1));
						flag2 = true;
					}
				}
				if (flag3)
				{
					if (CellMap[m][n + 1].IsClear() && !CellMap[m + 1][n + 1].IsClear())
					{
						CellMap[m + 1][n].Set(CellType.Perimeter);
						flag2 = true;
					}
					if (CellMap[m][n - 1].IsClear() && !CellMap[m + 1][n - 1].IsClear())
					{
						CellMap[m + 1][n].Set(CellType.Perimeter);
						flag2 = true;
					}
					if (CellMap[m][n - 1].IsClear() && CellMap[m + 1][n - 1].IsClear() && CellMap[m + 1][n - 1].Room == null && Tags.GetStyle(Options.styles, new Point(n - 1, m + 1)) == style2)
					{
						Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(n - 1, m));
						Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(n - 1, m + 1));
						flag2 = true;
					}
					if (CellMap[m][n + 1].IsClear() && CellMap[m + 1][n + 1].IsClear() && CellMap[m + 1][n + 1].Room == null && Tags.GetStyle(Options.styles, new Point(n + 1, m + 1)) == style2)
					{
						Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(n + 1, m));
						Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(n + 1, m + 1));
						flag2 = true;
					}
				}
			}
		}
		if (flag2)
		{
			FixCorridorWraps(1);
		}
		CleanMapCells();
		MarkDoorsInRooms();
		List<Point> list2 = new List<Point>();
		foreach (Room room in Rooms)
		{
			list2.Add(GetPointInRoom(room));
		}
		int[] arrItems = new int[10] { 0, 1, 1, 1, 2, 2, 2, 2, 3, 4 };
		int num3 = RandomExt.Choice(arrItems);
		if (flag)
		{
			num3 = 0;
		}
		for (int num4 = 0; num4 < num3; num4++)
		{
			if (list2.Count <= 0)
			{
				break;
			}
			int index = UnityEngine.Random.Range(0, list2.Count);
			FogPositions.Add(list2[index]);
			list2.RemoveAt(index);
		}
		MapGraph mapGraph = new MapGraph();
		mapGraph.CreateFromMap(CellMap, Options.Width, Options.Height, Rooms, EntrancePositions, DoorPositions);
		if (!mapGraph.CheckConnected())
		{
			Debug.Log("Map graph is not connected - Discarding cellmap...");
			return null;
		}
		if (checkRoomConnections)
		{
			foreach (Room room2 in Rooms)
			{
				int minConnections = room2.Template.flags.minConnections;
				if (minConnections > 1 && mapGraph.GetNumConnections(room2) < minConnections)
				{
					Debug.Log("Insufficient connections in room: " + room2.Template.name);
					return null;
				}
			}
		}
		mapGraph.ComputeDeadEndWeights();
		foreach (Room room3 in Rooms)
		{
			room3.IsDeadEnd = room3.Template.size != RoomTemplate.SizeType.Hub && mapGraph.GetDeadEndWeight(room3) >= 20f;
		}
		foreach (Room room4 in Rooms)
		{
			RoomTemplate.PlaceRoomProps(this, room4);
		}
		if (!SetSpawnAndExit(out var _, out var exitPoint))
		{
			return null;
		}
		MarkProps();
		Map map = new Map(Options.Width, Options.Height, CellMap, Rooms, PropPositions, DoorPositions, EntrancePositions, FogPositions, Tags);
		map.ExitPosition = exitPoint;
		map.graph = mapGraph;
		map.PrintToTexture(texOut);
		return map;
	}

	protected void ApplyMask()
	{
		List<Pair<CMask, int>> list = new List<Pair<CMask, int>>();
		if (Options.maskNone)
		{
			list.Add(new Pair<CMask, int>(new CMask(0f, 0f, 0f, 0f), 5));
		}
		if (Options.maskSmall)
		{
			list.Add(new Pair<CMask, int>(new CMask(0f, 0f, 1f, 0.1f).Push(0f, 0.9f, 1f, 0.1f).Push(0f, 0f, 0.1f, 1f).Push(0.9f, 0f, 0.1f, 1f), 1));
		}
		if (Options.maskMedium)
		{
			list.Add(new Pair<CMask, int>(new CMask(0f, 0f, 1f, 0.05f).Push(0f, 0.95f, 1f, 0.05f).Push(0f, 0f, 0.05f, 1f).Push(0.95f, 0f, 0.05f, 1f), 1));
		}
		if (Options.maskOShaped)
		{
			list.Add(new Pair<CMask, int>(new CMask(0.3f, 0.3f, 0.4f, 0.4f), 1));
		}
		if (Options.maskCross)
		{
			list.Add(new Pair<CMask, int>(new CMask(0f, 0f, 0.3f, 0.3f).Push(0.7f, 0f, 0.3f, 0.3f).Push(0f, 0.7f, 0.3f, 0.3f).Push(0.7f, 0.7f, 0.3f, 0.3f), 1));
		}
		if (Options.maskFortress)
		{
			list.Add(new Pair<CMask, int>(new CMask(0.375f, 0f, 0.25f, 0.25f).Push(0.375f, 0.75f, 0.25f, 0.25f).Push(0f, 0.375f, 0.25f, 0.25f).Push(0.75f, 0.375f, 0.25f, 0.25f), 1));
		}
		if (Options.maskTShaped)
		{
			list.Add(new Pair<CMask, int>(new CMask(0f, 0.5f, 0.3f, 0.5f).Push(0.7f, 0.5f, 0.3f, 0.5f), 1));
			list.Add(new Pair<CMask, int>(new CMask(0f, 0f, 0.3f, 0.5f).Push(0.7f, 0f, 0.3f, 0.5f), 1));
			list.Add(new Pair<CMask, int>(new CMask(0.5f, 0f, 0.5f, 0.3f).Push(0.5f, 0.7f, 0.5f, 0.3f), 1));
			list.Add(new Pair<CMask, int>(new CMask(0f, 0f, 0.5f, 0.3f).Push(0f, 0.7f, 0.5f, 0.3f), 1));
		}
		if (Options.maskUShaped)
		{
			list.Add(new Pair<CMask, int>(new CMask(0.3f, 0f, 0.4f, 0.6f), 1));
			list.Add(new Pair<CMask, int>(new CMask(0.3f, 0.4f, 0.4f, 0.6f), 1));
			list.Add(new Pair<CMask, int>(new CMask(0.4f, 0.3f, 0.6f, 0.4f), 1));
			list.Add(new Pair<CMask, int>(new CMask(0f, 0.3f, 0.6f, 0.4f), 1));
		}
		CMask cMask = RandomExt.WeightedChoice(list);
		foreach (Vector4 item in cMask)
		{
			IntRect blocked = new IntRect((int)(item.x * (float)Options.Width), (int)(item.y * (float)Options.Height), (int)(item.z * (float)Options.Width), (int)(item.w * (float)Options.Height));
			SetBlocked(blocked);
		}
	}

	protected bool SetBlocked(IntRect blockRect)
	{
		for (int i = blockRect.top; i < blockRect.bottom; i++)
		{
			for (int j = blockRect.left; j < blockRect.right; j++)
			{
				if (i >= 0 && i < Options.Height && j >= 0 && j < Options.Width)
				{
					CellMap[i][j].Set(CellType.Blocked);
				}
			}
		}
		return true;
	}

	private void GenTemplatedRooms()
	{
		float num = Options.Width * Options.Height;
		float num2 = Options.RoomMax * Options.RoomMax;
		float num3 = num / num2;
		int num4 = (int)num3;
		List<string> list = new List<string>();
		list.Add(Options.mainTag);
		list.Add("room");
		list.Add("hub");
		MapStyle style = Tags.GetStyle(Options.styles, list);
		List<RoomTemplate> list2 = new List<RoomTemplate>();
		for (int i = 0; i < RoomTemplate.hubTemplates.Count; i++)
		{
			RoomTemplate roomTemplate = RoomTemplate.hubTemplates[i];
			if (roomTemplate.flags.CheckStyle(style))
			{
				list2.Add(roomTemplate);
			}
		}
		if (list2.Count > 0)
		{
			RoomTemplate roomTemplate2 = RandomExt.Choice(list2);
			for (int j = 0; j < 10; j++)
			{
				int num5 = RandomExt.RandInt(1, Options.Width - 2 - roomTemplate2.width);
				int num6 = RandomExt.RandInt(1, Options.Height - 2 - roomTemplate2.height);
				if (num5 % 2 == 1)
				{
					num5++;
				}
				if (num6 % 2 == 1)
				{
					num6++;
				}
				Room room = RoomTemplate.PlaceRoomTemplated(this, Rooms.Count, new Point(num5, num6), roomTemplate2, placeProps: false);
				if (room != null)
				{
					room.Safe = true;
					Rooms.Add(room);
					AddTunnelBlockers(room);
					break;
				}
			}
		}
		list[2] = "small";
		MapStyle style2 = Tags.GetStyle(Options.styles, list);
		list[2] = "medium";
		MapStyle style3 = Tags.GetStyle(Options.styles, list);
		list[2] = "large";
		MapStyle style4 = Tags.GetStyle(Options.styles, list);
		for (int k = 0; k < num4; k++)
		{
			int num7 = RandomExt.RandInt(Options.RoomMin / 2, Options.RoomMax / 2);
			int num8 = RandomExt.RandInt(Options.RoomMin / 2, Options.RoomMax / 2);
			num7 = num7 * 2 + 1;
			num8 = num8 * 2 + 1;
			int num9 = RandomExt.RandInt(1, Options.Width - 2 - num7);
			int num10 = RandomExt.RandInt(1, Options.Height - 2 - num8);
			if (num9 % 2 == 1)
			{
				num9++;
			}
			if (num10 % 2 == 1)
			{
				num10++;
			}
			for (int l = 0; l < 10; l++)
			{
				Room room2 = RoomTemplate.PlaceRoomTemplated(this, Rooms.Count, new Point(num9, num10), style2, style3, style4, placeProps: false);
				if (room2 != null)
				{
					Rooms.Add(room2);
					break;
				}
			}
		}
		foreach (Room room3 in Rooms)
		{
			string[] tags = ((room3.Template.size == RoomTemplate.SizeType.Large) ? new string[2] { "room", "large" } : ((room3.Template.size == RoomTemplate.SizeType.Medium) ? new string[2] { "room", "medium" } : ((room3.Template.size == RoomTemplate.SizeType.Small) ? new string[2] { "room", "small" } : ((room3.Template.size != RoomTemplate.SizeType.Hub) ? new string[1] { "room" } : new string[2] { "room", "hub" }))));
			for (int m = room3.Start.Y; m < room3.Start.Y + room3.Size.Y; m++)
			{
				for (int n = room3.Start.X; n < room3.Start.X + room3.Size.X; n++)
				{
					Cell cell = CellMap[m][n];
					if (cell.Room == room3 && cell.Type != CellType.Door && cell.Type != CellType.EntranceMark && cell.Type != CellType.Perimeter)
					{
						if (room3.Template.size == RoomTemplate.SizeType.Large)
						{
							cell.Ambient = AmbientManager.Get().GetStyle(Options.ambientLarge);
						}
						else if (room3.Template.size == RoomTemplate.SizeType.Hub)
						{
							cell.Ambient = AmbientManager.Get().GetStyle(Options.ambientHub);
						}
						else
						{
							cell.Ambient = AmbientManager.Get().GetStyle(Options.ambientRoom);
						}
						Tags.Set(MapTags.Group.Style, tags, new Point(n, m));
					}
				}
			}
		}
	}

	private void GenTestRoom(RoomTemplate roomTemplate)
	{
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < 10; i++)
		{
			num = (Options.Width - roomTemplate.width) / 2 - 1;
			num2 = (Options.Height - roomTemplate.height) / 2 - 1;
			if (num % 2 == 1)
			{
				num++;
			}
			if (num2 % 2 == 1)
			{
				num2++;
			}
			Room room = RoomTemplate.PlaceRoomTemplated(this, Rooms.Count, new Point(num, num2), roomTemplate, placeProps: false);
			if (room != null)
			{
				Rooms.Add(room);
				break;
			}
		}
		List<RoomTemplate> list = new List<RoomTemplate>();
		for (int j = 0; j < RoomTemplate.roomTemplates.Count; j++)
		{
			RoomTemplate roomTemplate2 = RoomTemplate.roomTemplates[j];
			if (roomTemplate2.flags.canBeSafe && roomTemplate2.size == RoomTemplate.SizeType.Small)
			{
				list.Add(roomTemplate2);
			}
		}
		Point[] array = new Point[2]
		{
			new Point(Mathf.Max(num - 8, 0), num2),
			new Point(Mathf.Max(num - 8, 0), Mathf.Min(num2 + 8, Options.Height - 4))
		};
		for (int k = 0; k < 2; k++)
		{
			int num3 = array[k].X;
			int num4 = array[k].Y;
			if (num3 % 2 == 1)
			{
				num3++;
			}
			if (num4 % 2 == 1)
			{
				num4++;
			}
			for (int l = 0; l < 30; l++)
			{
				RoomTemplate template = list[UnityEngine.Random.Range(0, list.Count)];
				Room room2 = RoomTemplate.PlaceRoomTemplated(this, Rooms.Count, new Point(num3, num4), template, placeProps: false);
				if (room2 != null)
				{
					Rooms.Add(room2);
					break;
				}
			}
		}
		foreach (Room room3 in Rooms)
		{
			string[] tags = ((room3.Template.size == RoomTemplate.SizeType.Large) ? new string[2] { "room", "large" } : ((room3.Template.size == RoomTemplate.SizeType.Medium) ? new string[2] { "room", "medium" } : ((room3.Template.size == RoomTemplate.SizeType.Small) ? new string[2] { "room", "small" } : ((room3.Template.size != RoomTemplate.SizeType.Hub) ? new string[1] { "room" } : new string[2] { "room", "hub" }))));
			for (int m = room3.Start.Y; m < room3.Start.Y + room3.Size.Y; m++)
			{
				for (int n = room3.Start.X; n < room3.Start.X + room3.Size.X; n++)
				{
					Cell cell = CellMap[m][n];
					if (cell.Room == room3)
					{
						if (room3.Template.size == RoomTemplate.SizeType.Large)
						{
							cell.Ambient = AmbientManager.Get().GetStyle(Options.ambientLarge);
						}
						else if (room3.Template.size == RoomTemplate.SizeType.Hub)
						{
							cell.Ambient = AmbientManager.Get().GetStyle(Options.ambientHub);
						}
						else
						{
							cell.Ambient = AmbientManager.Get().GetStyle(Options.ambientRoom);
						}
						Tags.Set(MapTags.Group.Style, tags, new Point(n, m));
					}
				}
			}
		}
	}

	protected void ConnectRooms(out int iNumDoubleCorridors)
	{
		iNumDoubleCorridors = 0;
		List<Room> list = new List<Room>();
		List<Room> list2 = new List<Room>();
		foreach (Room room3 in Rooms)
		{
			list2.Add(room3);
		}
		List<Tuple<Point, Point, bool>> list3 = new List<Tuple<Point, Point, bool>>();
		while (list2.Count > 0)
		{
			Room room = RandomExt.Choice(list2);
			list2.Remove(room);
			Room room2 = null;
			bool flag = list.Count == 0;
			int num = 0;
			bool isDouble;
			Point doorInRoom = GetDoorInRoom(room, out isDouble);
			while (!flag)
			{
				num++;
				room2 = RandomExt.Choice(list);
				Point doorPos = doorInRoom;
				if (isDouble)
				{
					flag = GetDoubleDoorInRoom(room2, out doorPos);
					if (!flag && num > 3)
					{
						isDouble = false;
					}
				}
				else
				{
					doorPos = GetDoorInRoom(room2, out var _);
					flag = true;
				}
				if (flag)
				{
					list3.Add(new Tuple<Point, Point, bool>(doorInRoom, doorPos, isDouble));
				}
			}
			list.Add(room);
		}
		TunnelEdges(list3, out iNumDoubleCorridors);
	}

	protected void TunnelEdges(List<Tuple<Point, Point, bool>> edgesFinal, out int iNumDoubleCorridors, bool alwaysSetStyle = false)
	{
		iNumDoubleCorridors = 0;
		Pathfinder pathfinder = new Pathfinder();
		foreach (Tuple<Point, Point, bool> item3 in edgesFinal)
		{
			Point item = item3.Item1;
			Point item2 = item3.Item2;
			if (!item3.Item3)
			{
				Tunnel(item, item2, alwaysSetStyle);
				continue;
			}
			item.X /= 2;
			item.Y /= 2;
			item2.X /= 2;
			item2.Y /= 2;
			Pathfinder.Query query = pathfinder.AddQuery(item, item2, null, TunnelCheckTraversalDouble, TunnelGetTraversalCostDouble, null, 0.5f);
			if (!pathfinder.RunAStar(query))
			{
				continue;
			}
			if (!query.IsSuccess())
			{
				pathfinder.FreeQuery(query);
				item = item3.Item1;
				item2 = item3.Item2;
				Tunnel(item, item2, alwaysSetStyle);
				continue;
			}
			query.Path.Add(item);
			query.Path.Add(item2);
			foreach (Point item4 in query.Path)
			{
				for (int i = item4.Y * 2; i <= item4.Y * 2 + 1; i++)
				{
					for (int j = item4.X * 2; j <= item4.X * 2 + 1; j++)
					{
						if (CellMap[i][j].Get() == CellType.EntranceMark || CellMap[i][j].Get() == CellType.Door)
						{
							CellMap[i][j].Set(CellType.Door);
							Tags.AddException(MapTags.Group.Style, new Point(j, i));
							Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(j, i));
							FakeDoubleEntrances.Remove(new Point(j, i));
						}
						else if (CellMap[i][j].Get() != CellType.Corridor && CellMap[i][j].Get() != CellType.Door && CellMap[i][j].Get() != CellType.Pit && CellMap[i][j].Room == null)
						{
							CellMap[i][j].Set(CellType.Corridor);
							Tags.AddException(MapTags.Group.Style, new Point(j, i));
							Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(j, i));
						}
						if (CellMap[i][j].Room == null)
						{
							Tags.SetVariation('A', new Point(j, i));
							Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(j, i));
						}
					}
				}
			}
			pathfinder.FreeQuery(query);
			iNumDoubleCorridors++;
		}
	}

	protected void Tunnel(Point start, Point end, bool alwaysSetStyle = false)
	{
		Pathfinder pathfinder = new Pathfinder();
		Pathfinder.Query query = pathfinder.AddQuery(start, end, null, TunnelCheckTraversal, TunnelGetTraversalCost, null, 0.5f);
		if (!pathfinder.RunAStar(query))
		{
			return;
		}
		List<string> list = new List<string>();
		list.Add(Options.mainTag);
		list.Add("corridor");
		list.Add("large");
		MapStyle style = Tags.GetStyle(Options.styles, list);
		Point point = new Point(0, 0);
		if (query.Path.Count >= 2)
		{
			point = new Point(query.Path[1].X - query.Path[0].X, query.Path[1].Y - query.Path[0].Y);
		}
		int num = 0;
		int num2 = 0;
		bool flag = false;
		for (int i = 0; i < query.Path.Count; i++)
		{
			Point point2 = query.Path[i];
			Point point3 = query.Path[num2];
			Point point4 = new Point(point2.X - point3.X, point2.Y - point3.Y);
			bool flag2 = point2 == end;
			if (i == num)
			{
				point4 = point;
			}
			if (point4 != point || flag2 || CellMap[point2.Y][point2.X].Get() == CellType.Corridor)
			{
				if (flag2)
				{
					num2 = i;
					point3 = point2;
				}
				Point point5 = query.Path[num];
				MapStyle style2 = Tags.GetStyle(Options.styles, point5);
				MapBrush mapBrush = style2.ChooseCorridorBrush();
				if (point5 != point3)
				{
					List<char> list2 = null;
					try
					{
						list2 = mapBrush.Grammar.Process(num2 - num + 1);
					}
					catch (Exception)
					{
						Debug.LogError("Key not found: " + mapBrush.id + " " + style2.styleName);
					}
					for (int j = num; j <= num2; j++)
					{
						if (CellMap[point2.Y][point2.X].Room == null)
						{
							Point tile = query.Path[j];
							Tags.SetVariation(list2[j - num], tile);
						}
					}
				}
				num = num2;
			}
			if (CellMap[point2.Y][point2.X].Get() == CellType.EntranceMark)
			{
				if (!flag)
				{
					if (alwaysSetStyle || !Tags.HasStyleSet(point2) || Tags.GetStyle(Options.styles, point2) != style)
					{
						Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "narrow" }, point2);
					}
					CellMap[point2.Y][point2.X].Set(CellType.Door);
					Vector3 vector = new Vector3(1.5f * (float)point2.X + 0.75f, 0f, -1.5f * (float)point2.Y - 0.75f);
					if (CellMap[point2.Y][point2.X + 1].Get() == CellType.EntranceMark && CellMap[point2.Y][point2.X + 1].Room == CellMap[point2.Y][point2.X].Room && (i < 1 || query.Path[i - 1] != new Point(point2.X + 1, point2.Y)) && (i > query.Path.Count - 2 || query.Path[i + 1] != new Point(point2.X + 1, point2.Y)))
					{
						FakeDoubleEntrances.AddIfNotInside(new Point(point2.X + 1, point2.Y));
					}
					if (CellMap[point2.Y][point2.X - 1].Get() == CellType.EntranceMark && CellMap[point2.Y][point2.X - 1].Room == CellMap[point2.Y][point2.X].Room && (i < 1 || query.Path[i - 1] != new Point(point2.X - 1, point2.Y)) && (i > query.Path.Count - 2 || query.Path[i + 1] != new Point(point2.X - 1, point2.Y)))
					{
						FakeDoubleEntrances.AddIfNotInside(new Point(point2.X - 1, point2.Y));
					}
					if (CellMap[point2.Y + 1][point2.X].Get() == CellType.EntranceMark && CellMap[point2.Y + 1][point2.X].Room == CellMap[point2.Y][point2.X].Room && (i < 1 || query.Path[i - 1] != new Point(point2.X, point2.Y + 1)) && (i > query.Path.Count - 2 || query.Path[i + 1] != new Point(point2.X, point2.Y + 1)))
					{
						FakeDoubleEntrances.AddIfNotInside(new Point(point2.X, point2.Y + 1));
					}
					if (CellMap[point2.Y - 1][point2.X].Get() == CellType.EntranceMark && CellMap[point2.Y - 1][point2.X].Room == CellMap[point2.Y][point2.X].Room && (i < 1 || query.Path[i - 1] != new Point(point2.X, point2.Y - 1)) && (i > query.Path.Count - 2 || query.Path[i + 1] != new Point(point2.X, point2.Y - 1)))
					{
						FakeDoubleEntrances.AddIfNotInside(new Point(point2.X, point2.Y - 1));
					}
					if (i == 1)
					{
						FakeDoubleEntrances.Remove(point2);
					}
				}
				if (!flag && i > 0 && i >= query.Path.Count - 2)
				{
					flag = true;
				}
			}
			else if (CellMap[point2.Y][point2.X].Get() != CellType.Corridor && CellMap[point2.Y][point2.X].Get() != CellType.Door && CellMap[point2.Y][point2.X].Get() != CellType.Pit)
			{
				CellMap[point2.Y][point2.X].Set(CellType.Corridor);
				if (CellMap[point2.Y][point2.X].Room == null)
				{
					Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "narrow" }, point2);
				}
			}
			num2 = i;
			point = point4;
		}
		pathfinder.FreeQuery(query);
	}

	protected Point GetDoorInRoom(Room room, out bool isDouble)
	{
		List<CPoint> doors = room.Template.doors;
		List<CPoint> doubleDoors = room.Template.doubleDoors;
		if (doors.Count == 0 && doubleDoors.Count == 0)
		{
			Debug.LogError("Room doesn't have any doors: " + room.Template.name);
			Debug.Break();
		}
		int num = RandomExt.RandInt(0, doors.Count + doubleDoors.Count - 1);
		if (num < doors.Count)
		{
			isDouble = false;
			return doors[num].ToPoint() + room.Start;
		}
		isDouble = true;
		num -= doors.Count;
		return doubleDoors[num].ToPoint() + room.Start;
	}

	protected bool GetDoubleDoorInRoom(Room room, out Point doorPos)
	{
		List<CPoint> doors = room.Template.doors;
		List<CPoint> doubleDoors = room.Template.doubleDoors;
		if (doubleDoors.Count == 0)
		{
			doorPos = RandomExt.Choice(doors).ToPoint() + room.Start;
			return false;
		}
		doorPos = RandomExt.Choice(doubleDoors).ToPoint() + room.Start;
		return true;
	}

	protected bool GetClosestDoubleDoorInRoom(Room room, out Point doorPos, Point refPoint)
	{
		List<CPoint> doors = room.Template.doors;
		List<CPoint> doubleDoors = room.Template.doubleDoors;
		if (doubleDoors.Count == 0)
		{
			float num = float.MaxValue;
			int index = 0;
			for (int i = 0; i < doors.Count; i++)
			{
				float num2 = (doors[i].ToPoint() + room.Start - refPoint).DistanceSq();
				if (num2 < num)
				{
					num = num2;
					index = i;
				}
			}
			doorPos = doors[index].ToPoint() + room.Start;
			return false;
		}
		float num3 = float.MaxValue;
		int index2 = 0;
		for (int j = 0; j < doubleDoors.Count; j++)
		{
			float num4 = (doubleDoors[j].ToPoint() + room.Start - refPoint).DistanceSq();
			if (num4 < num3)
			{
				num3 = num4;
				index2 = j;
			}
		}
		doorPos = doubleDoors[index2].ToPoint() + room.Start;
		return true;
	}

	protected Point GetPointInRoom(Room room)
	{
		List<Point> list = new List<Point>();
		for (int i = room.Start.Y; i < room.Start.Y + room.Size.Y; i++)
		{
			for (int j = room.Start.X; j < room.Start.X + room.Size.X; j++)
			{
				Point item = new Point(j, i);
				if (item.Y > 0 && item.Y < Options.Height - 1 && item.X > 0 && item.X < Options.Width - 1 && CellMap[item.Y][item.X].IsClear() && CellMap[item.Y - 1][item.X].IsClearOrPit() && CellMap[item.Y + 1][item.X].IsClearOrPit() && CellMap[item.Y][item.X - 1].IsClearOrPit() && CellMap[item.Y][item.X + 1].IsClearOrPit())
				{
					list.Add(item);
				}
			}
		}
		if (list.Count == 0)
		{
			Debug.LogError("No hay posiciones validas en la habitacion");
			return new Point(0, 0);
		}
		return RandomExt.Choice(list);
	}

	protected Point GetCentralPointInRoom(Room room)
	{
		List<Point> list = new List<Point>();
		List<Point> list2 = new List<Point>();
		for (int i = room.Start.Y; i < room.Start.Y + room.Size.Y; i++)
		{
			for (int j = room.Start.X; j < room.Start.X + room.Size.X; j++)
			{
				Point item = new Point(j, i);
				if (item.Y <= 0 || item.Y >= Options.Height - 1 || item.X <= 0 || item.X >= Options.Width - 1 || !CellMap[item.Y][item.X].IsClear() || !CellMap[item.Y - 1][item.X].IsClearOrPit() || !CellMap[item.Y + 1][item.X].IsClearOrPit() || !CellMap[item.Y][item.X - 1].IsClearOrPit() || !CellMap[item.Y][item.X + 1].IsClearOrPit())
				{
					continue;
				}
				list.Add(item);
				int num = 0;
				for (int k = item.Y - 1; k <= item.Y + 1; k++)
				{
					if (num != 0)
					{
						break;
					}
					for (int l = item.X - 1; l <= item.X + 1; l++)
					{
						if (num != 0)
						{
							break;
						}
						if ((l != item.X || k != item.Y) && k > 0 && k < Options.Height - 1 && l > 0 && l < Options.Width - 1 && !CellMap[k][l].IsClear())
						{
							num++;
						}
					}
				}
				if (num == 0)
				{
					list2.Add(item);
				}
			}
		}
		if (list.Count == 0)
		{
			Debug.LogError("No hay posiciones validas en la habitacion");
			return new Point(0, 0);
		}
		if (list2.Count > 0)
		{
			return RandomExt.Choice(list2);
		}
		return RandomExt.Choice(list);
	}

	public float TunnelGetTraversalCost(Point from, Point end, object movementDesc)
	{
		if (from.X < 0 || from.X >= Options.Width || from.Y < 0 || from.Y >= Options.Height || end.X < 0 || end.X >= Options.Width || end.Y < 0 || end.Y >= Options.Height)
		{
			return float.MaxValue;
		}
		switch (CellMap[end.Y][end.X].Get())
		{
		case CellType.Perimeter:
			return float.MaxValue;
		case CellType.EntranceMark:
		case CellType.Door:
			return 0.5f;
		case CellType.Room:
			return 0.5f;
		case CellType.Corridor:
			return 0.3f;
		default:
			return 1.5f;
		}
	}

	public bool TunnelCheckTraversal(Point from, Point end, object movementDesc)
	{
		if (from.X <= 0 || from.X >= Options.Width - 1 || from.Y <= 0 || from.Y >= Options.Height - 1 || end.X <= 0 || end.X >= Options.Width - 1 || end.Y <= 0 || end.Y >= Options.Height - 1)
		{
			return false;
		}
		if (!CellMap[end.Y][end.X].CanTunnel())
		{
			return false;
		}
		if (from.X != end.X && from.Y != end.Y)
		{
			return false;
		}
		return true;
	}

	public float TunnelGetTraversalCostDouble(Point from, Point end, object movementDesc)
	{
		float num = 0f;
		for (int i = end.Y * 2; i <= end.Y * 2 + 1; i++)
		{
			for (int j = end.X * 2; j <= end.X * 2 + 1; j++)
			{
				num += TunnelGetTraversalCost(new Point(from.X * 2, from.Y * 2), new Point(j, i), movementDesc);
			}
		}
		return num / 4f;
	}

	public bool TunnelCheckTraversalDouble(Point from, Point end, object movementDesc)
	{
		Point point = new Point(from.X * 2, from.Y * 2);
		Point point2 = new Point(end.X * 2, end.Y * 2);
		if (point.X <= 0 || point.X + 1 >= Options.Width - 1 || point.Y <= 0 || point.Y + 1 >= Options.Height - 1 || point2.X <= 0 || point2.X + 1 >= Options.Width - 1 || point2.Y <= 0 || point2.Y + 1 >= Options.Height - 1)
		{
			return false;
		}
		if (!CellMap[point2.Y][point2.X].CanTunnel() || !CellMap[point2.Y][point2.X + 1].CanTunnel() || !CellMap[point2.Y + 1][point2.X].CanTunnel() || !CellMap[point2.Y + 1][point2.X + 1].CanTunnel())
		{
			return false;
		}
		if (from.X != end.X && from.Y != end.Y)
		{
			return false;
		}
		return true;
	}

	private void AddTunnelBlockers(Room room)
	{
		for (int i = room.Start.Y; i < room.Start.Y + room.Size.Y; i++)
		{
			for (int j = room.Start.X; j < room.Start.X + room.Size.X; j++)
			{
				if (CellMap[i][j].Type != CellType.EntranceMark)
				{
					continue;
				}
				int num = 2;
				Point point = new Point(0, 0);
				if (CellMap[i][j - 1].Type == CellType.Rock)
				{
					point.X = -1;
				}
				else if (CellMap[i][j + 1].Type == CellType.Rock)
				{
					point.X = 1;
				}
				else if (CellMap[i - 1][j].Type == CellType.Rock)
				{
					point.Y = -1;
				}
				else if (CellMap[i + 1][j].Type == CellType.Rock)
				{
					point.Y = 1;
				}
				if (point.X != 0 || point.Y != 0)
				{
					Point point2 = new Point(j, i) + point * UnityEngine.Random.Range(2, 3);
					if (point2.X > 0 && point2.X < Options.Width && point2.Y > 0 && point2.Y < Options.Height && CellMap[point2.Y][point2.X].Type == CellType.Rock)
					{
						CellMap[point2.Y][point2.X].Set(CellType.Perimeter);
					}
				}
			}
		}
	}

	protected bool SetSpawnAndExit(out Point spawnPoint, out Point exitPoint)
	{
		spawnPoint = default(Point);
		exitPoint = default(Point);
		List<Tuple<Room, Point, RoomTemplate.PropMarker>> list = new List<Tuple<Room, Point, RoomTemplate.PropMarker>>();
		for (int i = 0; i < 6; i++)
		{
			List<Room> list2 = new List<Room>();
			foreach (Room room3 in Rooms)
			{
				if (room3.Template.flags.canBeSafe && room3.Template != Options.testRoom && !room3.IsHorror && !room3.IsWellLayout)
				{
					list2.Add(room3);
				}
			}
			if (list2.Count < 2)
			{
				return false;
			}
			Room room = RandomExt.Choice(list2);
			Point centralPointInRoom = GetCentralPointInRoom(room);
			bool flag = false;
			RoomTemplate.PropMarker propMarker;
			do
			{
				propMarker = RandomExt.Choice(PropPositions);
				flag = propMarker.exitMarker != OptionFlag.No;
				if (!flag)
				{
					continue;
				}
				Room room2 = CellMap[propMarker.pos.Y][propMarker.pos.X].Room;
				if (room2 != null)
				{
					flag = room2.Template.size == RoomTemplate.SizeType.Small && room2.Template != Options.testRoom && !room2.IsWellLayout;
					if (flag)
					{
						int num = 0;
						num += ((!CellMap[propMarker.pos.Y][propMarker.pos.X - 1].IsClearOrPit()) ? 1 : 0);
						num += ((!CellMap[propMarker.pos.Y][propMarker.pos.X + 1].IsClearOrPit()) ? 1 : 0);
						num += ((!CellMap[propMarker.pos.Y - 1][propMarker.pos.X].IsClearOrPit()) ? 1 : 0);
						num += ((!CellMap[propMarker.pos.Y + 1][propMarker.pos.X].IsClearOrPit()) ? 1 : 0);
						flag = num > 0;
					}
				}
			}
			while (propMarker.width != 1 || propMarker.height != 1 || !flag);
			list.Add(new Tuple<Room, Point, RoomTemplate.PropMarker>(room, centralPointInRoom, propMarker));
		}
		int num2 = 0;
		Tuple<Room, Point, RoomTemplate.PropMarker> tuple = list[0];
		foreach (Tuple<Room, Point, RoomTemplate.PropMarker> item in list)
		{
			if (!CheckSolutionPath(item.Item2, item.Item3.pos.ToPoint(), out var iLength))
			{
				return false;
			}
			if (iLength > num2)
			{
				num2 = iLength;
				tuple = item;
			}
		}
		if (num2 < 60 && Options.testRoom == null)
		{
			return false;
		}
		CellMap[tuple.Item2.Y][tuple.Item2.X].Set(CellType.Spawn);
		tuple.Item1.Safe = true;
		tuple.Item1.IsSpawnRoom = true;
		RoomTemplate.PropMarker propMarker2 = new RoomTemplate.PropMarker(tuple.Item3.pos, tuple.Item3);
		propMarker2.exitMarker = OptionFlag.Yes;
		PropPositions.Remove(tuple.Item3);
		ProcessExitRoom(propMarker2);
		PropPositions.Add(propMarker2);
		spawnPoint = tuple.Item2;
		exitPoint = tuple.Item3.pos.ToPoint();
		return true;
	}

	protected bool CheckSolutionPath(Point start, Point end, out int iLength)
	{
		iLength = 0;
		Pathfinder pathfinder = new Pathfinder();
		Pathfinder.Query query = pathfinder.AddQuery(start, end, null, SolutionCheckTraversal, SolutionGetTraversalCost, null, 0.5f);
		if (pathfinder.RunAStar(query))
		{
			query.Path.Add(start);
			query.Path.Add(end);
			iLength = query.Path.Count;
			pathfinder.FreeQuery(query);
			return true;
		}
		return false;
	}

	protected float SolutionGetTraversalCost(Point from, Point end, object movementDesc)
	{
		if (from.X < 0 || from.X >= Options.Width || from.Y < 0 || from.Y >= Options.Height || end.X < 0 || end.X >= Options.Width || end.Y < 0 || end.Y >= Options.Height)
		{
			return float.MaxValue;
		}
		return 1f;
	}

	protected bool SolutionCheckTraversal(Point from, Point end, object movementDesc)
	{
		if (from.X <= 0 || from.X >= Options.Width - 1 || from.Y <= 0 || from.Y >= Options.Height - 1 || end.X <= 0 || end.X >= Options.Width - 1 || end.Y <= 0 || end.Y >= Options.Height - 1)
		{
			return false;
		}
		if (!CellMap[end.Y][end.X].CanWalk())
		{
			return false;
		}
		if (from.X != end.X && from.Y != end.Y)
		{
			return false;
		}
		return true;
	}

	protected void CleanMapCells()
	{
		List<string> list = new List<string>();
		list.Add(Options.mainTag);
		list.Add("corridor");
		list.Add("large");
		MapStyle style = Tags.GetStyle(Options.styles, list);
		for (int i = 0; i < Options.Height; i++)
		{
			for (int j = 0; j < Options.Width; j++)
			{
				switch (CellMap[i][j].Get())
				{
				case CellType.Perimeter:
					CellMap[i][j].Set(CellType.Rock);
					break;
				case CellType.EntranceMark:
					CellMap[i][j].Set(CellType.Rock);
					break;
				case CellType.Door:
				{
					bool flag = true;
					if (i <= 0 || i >= Options.Height - 1 || j <= 0 || j >= Options.Width - 1)
					{
						flag = false;
					}
					else if ((!CellMap[i - 1][j].IsClear() || !CellMap[i + 1][j].IsClear() || CellMap[i][j - 1].IsClear() || CellMap[i][j + 1].IsClear()) && (CellMap[i - 1][j].IsClear() || CellMap[i + 1][j].IsClear() || !CellMap[i][j - 1].IsClear() || !CellMap[i][j + 1].IsClear()))
					{
						flag = false;
					}
					if (flag)
					{
						CellMap[i][j].Set(CellType.Room);
						bool flag2 = CellMap[i + 1][j].Get() == CellType.Door;
						bool flag3 = CellMap[i][j + 1].Get() == CellType.Door;
						if (flag3)
						{
							CellMap[i][j + 1].Set(CellType.Room);
							CellMap[i][j + 1].Occupied = true;
							CellMap[i][j + 1].IsDoor = true;
						}
						else if (flag2)
						{
							CellMap[i + 1][j].Set(CellType.Room);
							CellMap[i + 1][j].Occupied = true;
							CellMap[i + 1][j].IsDoor = true;
						}
						if (UnityEngine.Random.value < Options.DoorClutter && !flag3 && !flag2)
						{
							DoorPositions.Add(new Point(j, i));
						}
						else
						{
							EntrancePositions.Add(new Point(j, i));
							if (flag3)
							{
								EntrancePositions.Add(new Point(j + 1, i));
							}
							else if (flag2)
							{
								EntrancePositions.Add(new Point(j, i + 1));
							}
						}
					}
					else
					{
						CellMap[i][j].Set(CellType.Rock);
						bool flag4 = CellMap[i + 1][j].Get() == CellType.Door;
						if (CellMap[i][j + 1].Get() == CellType.Door && Tags.GetStyle(Options.styles, new Point(j + 1, i)) == style)
						{
							Tags.AddException(MapTags.Group.Style, new Point(j + 1, i));
							Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "narrow" }, new Point(j + 1, i));
						}
						if (flag4 && Tags.GetStyle(Options.styles, new Point(j, i + 1)) == style)
						{
							Tags.AddException(MapTags.Group.Style, new Point(j, i + 1));
							Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "narrow" }, new Point(j, i + 1));
						}
					}
					CellMap[i][j].Occupied = true;
					CellMap[i][j].IsDoor = true;
					break;
				}
				case CellType.Corridor:
					CellMap[i][j].Set(CellType.Room);
					CellMap[i][j].Occupied = CellMap[i][j].Room == null;
					break;
				}
			}
		}
		MarkProps();
	}

	private void MarkProps()
	{
		foreach (RoomTemplate.PropMarker propPosition in PropPositions)
		{
			for (int i = 0; i < propPosition.height; i++)
			{
				for (int j = 0; j < propPosition.width; j++)
				{
					CellMap[propPosition.pos.Y + i][propPosition.pos.X + j].Occupied = true;
				}
			}
		}
	}

	private void FixCorridorWraps(int maxCycles = 2)
	{
		List<string> list = new List<string>();
		list.Add(Options.mainTag);
		list.Add("corridor");
		list.Add("large");
		MapStyle style = Tags.GetStyle(Options.styles, list);
		list = new List<string>();
		list.Add(Options.mainTag);
		list.Add("corridor");
		list.Add("narrow");
		MapStyle style2 = Tags.GetStyle(Options.styles, list);
		bool flag = false;
		for (int i = 0; i < maxCycles; i++)
		{
			if (i > 0 && !flag)
			{
				continue;
			}
			flag = false;
			for (int j = 0; j < Options.Height; j++)
			{
				for (int k = 0; k < Options.Width; k++)
				{
					if (CellMap[j][k].Get() != CellType.Corridor || CellMap[j][k].Room != null)
					{
						continue;
					}
					bool flag2 = false;
					MapStyle style3 = Tags.GetStyle(Options.styles, new Point(k, j));
					if (style3 != style)
					{
						if (CellMap[j + 1][k].Get() == CellType.Corridor && Tags.GetStyle(Options.styles, new Point(k, j + 1)) == style && (CellMap[j + 1][k + 1].IsClear() || CellMap[j][k - 1].IsClear()) && (CellMap[j + 1][k - 1].IsClear() || CellMap[j][k + 1].IsClear()))
						{
							flag2 |= CellMap[j][k - 1].Get() == CellType.Corridor || CellMap[j][k + 1].Get() == CellType.Corridor;
						}
						if (CellMap[j - 1][k].Get() == CellType.Corridor && Tags.GetStyle(Options.styles, new Point(k, j - 1)) == style && (CellMap[j - 1][k + 1].IsClear() || CellMap[j][k - 1].IsClear()) && (CellMap[j - 1][k - 1].IsClear() || CellMap[j][k + 1].IsClear()))
						{
							flag2 |= CellMap[j][k - 1].Get() == CellType.Corridor || CellMap[j][k + 1].Get() == CellType.Corridor;
						}
						if (CellMap[j][k + 1].Get() == CellType.Corridor && Tags.GetStyle(Options.styles, new Point(k + 1, j)) == style && (CellMap[j - 1][k + 1].IsClear() || CellMap[j + 1][k].IsClear()) && (CellMap[j + 1][k + 1].IsClear() || CellMap[j - 1][k].IsClear()))
						{
							flag2 |= CellMap[j - 1][k].Get() == CellType.Corridor || CellMap[j + 1][k].Get() == CellType.Corridor;
						}
						if (CellMap[j][k - 1].Get() == CellType.Corridor && Tags.GetStyle(Options.styles, new Point(k - 1, j)) == style && (CellMap[j - 1][k - 1].IsClear() || CellMap[j + 1][k].IsClear()) && (CellMap[j + 1][k - 1].IsClear() || CellMap[j - 1][k].IsClear()))
						{
							flag2 |= CellMap[j - 1][k].Get() == CellType.Corridor || CellMap[j + 1][k].Get() == CellType.Corridor;
						}
					}
					if (flag2)
					{
						Tags.AddException(MapTags.Group.Style, new Point(k, j));
						Tags.Set(MapTags.Group.Style, new string[2] { "corridor", "large" }, new Point(k, j));
						flag = true;
					}
				}
			}
		}
	}

	protected bool CheckCorridorBugs()
	{
		List<string> list = new List<string>();
		list.Add(Options.mainTag);
		list.Add("corridor");
		list.Add("large");
		MapStyle style = Tags.GetStyle(Options.styles, list);
		for (int i = 0; i < Options.Height; i++)
		{
			for (int j = 0; j < Options.Width; j++)
			{
				if (CellMap[i][j].Type == CellType.Corridor)
				{
					MapStyle style2 = Tags.GetStyle(Options.styles, new Point(j, i));
					if (style2 == style && CellMap[i - 1][j].Type == CellType.Corridor && Tags.GetStyle(Options.styles, new Point(j, i - 1)) == style && CellMap[i + 1][j].Type == CellType.Corridor && Tags.GetStyle(Options.styles, new Point(j, i + 1)) == style && CellMap[i][j - 1].Type == CellType.Corridor && Tags.GetStyle(Options.styles, new Point(j - 1, i)) == style && CellMap[i][j + 1].Type == CellType.Corridor && Tags.GetStyle(Options.styles, new Point(j + 1, i)) == style && ((CellMap[i - 1][j - 1].Type != CellType.Corridor && CellMap[i + 1][j + 1].Type != CellType.Corridor) || (CellMap[i + 1][j - 1].Type != CellType.Corridor && CellMap[i - 1][j + 1].Type != CellType.Corridor)))
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	protected void MarkDoorsInRooms()
	{
		for (int i = 0; i < DoorPositions.Count; i++)
		{
			Cell cell = CellMap[DoorPositions[i].Y][DoorPositions[i].X];
			if (cell.Room != null)
			{
				cell.Room.doors.Add(DoorPositions[i]);
			}
		}
		for (int j = 0; j < EntrancePositions.Count; j++)
		{
			Cell cell2 = CellMap[EntrancePositions[j].Y][EntrancePositions[j].X];
			if (cell2.Room != null)
			{
				cell2.Room.entrances.Add(EntrancePositions[j]);
			}
		}
	}

	private void ProcessExitRoom(RoomTemplate.PropMarker newExitProp)
	{
		Point point = new Point(newExitProp.pos.X, newExitProp.pos.Y);
		Cell cell = CellMap[point.Y][point.X];
		Room room = cell.Room;
		Point point2 = point + new Point(-1, 0);
		Point point3 = point + new Point(1, 0);
		Point point4 = point + new Point(0, -1);
		Point point5 = point + new Point(0, 1);
		Cell cell2 = CellMap[point2.Y][point2.X];
		Cell cell3 = CellMap[point3.Y][point3.X];
		Cell cell4 = CellMap[point4.Y][point4.X];
		Cell cell5 = CellMap[point5.Y][point5.X];
		bool flag = cell2.IsClear();
		bool flag2 = cell3.IsClear();
		bool flag3 = cell4.IsClear();
		bool flag4 = cell5.IsClear();
		bool flag5 = cell2.IsClear() && !CheckDoorAdjacent(point2, room);
		bool flag6 = cell3.IsClear() && !CheckDoorAdjacent(point3, room);
		bool flag7 = cell4.IsClear() && !CheckDoorAdjacent(point4, room);
		bool flag8 = cell5.IsClear() && !CheckDoorAdjacent(point5, room);
		Point point6 = point;
		Point point7 = point6;
		bool flag9 = false;
		if (!cell2.IsClear() && !flag9)
		{
			if (!flag3 || !flag4)
			{
				if (!flag7 && flag8)
				{
					point6 = point5;
				}
				else if (flag7 && !flag8)
				{
					point6 = point4;
				}
			}
			point7 = point6 + new Point(1, 0);
			flag9 = point6 != point;
		}
		if (!cell3.IsClear() && !flag9)
		{
			if (!flag3 || !flag4)
			{
				if (!flag7 && flag8)
				{
					point6 = point5;
				}
				else if (flag7 && !flag8)
				{
					point6 = point4;
				}
			}
			point7 = point6 + new Point(-1, 0);
			flag9 = point6 != point;
		}
		if (!cell4.IsClear() && !flag9)
		{
			if (!flag || !flag2)
			{
				if (!flag5 && flag6)
				{
					point6 = point3;
				}
				else if (flag5 && !flag6)
				{
					point6 = point2;
				}
			}
			point7 = point6 + new Point(0, 1);
			flag9 = point6 != point;
		}
		if (!cell5.IsClear() && !flag9)
		{
			if (!flag || !flag2)
			{
				if (!flag5 && flag6)
				{
					point6 = point3;
				}
				else if (flag5 && !flag6)
				{
					point6 = point2;
				}
			}
			point7 = point6 + new Point(0, -1);
			flag9 = point6 != point;
		}
		newExitProp.pos.Set(point6);
		Tags.SetVariation('A', point6);
		for (int i = 0; i < PropPositions.Count; i++)
		{
			RoomTemplate.PropMarker propMarker = PropPositions[i];
			if (CellMap[propMarker.pos.Y][propMarker.pos.X].Room == room)
			{
				if (propMarker.pos.X <= point6.X && propMarker.pos.X + propMarker.width - 1 >= point6.X && propMarker.pos.Y <= point6.Y && propMarker.pos.Y + propMarker.height - 1 >= point6.Y)
				{
					PropPositions.RemoveAt(i);
					i--;
				}
				else if (propMarker.pos.X <= point7.X && propMarker.pos.X + propMarker.width - 1 >= point7.X && propMarker.pos.Y <= point7.Y && propMarker.pos.Y + propMarker.height - 1 >= point7.Y)
				{
					PropPositions.RemoveAt(i);
					i--;
				}
			}
		}
		RoomTemplate.PropMarker propMarker2 = new RoomTemplate.PropMarker(new CPoint(point7), newExitProp);
		propMarker2.exitMarker = OptionFlag.No;
		propMarker2.exitCollectable = OptionFlag.Yes;
		PropPositions.Add(propMarker2);
		room.IsExitRoom = true;
		room.Safe = true;
	}

	private bool CheckDoorAdjacent(Point pos, Room r)
	{
		for (int i = pos.Y - 1; i <= pos.Y + 1; i++)
		{
			for (int j = pos.X - 1; j <= pos.X + 1; j++)
			{
				CellType type = CellMap[i][j].Type;
				if (type == CellType.EntranceMark || type == CellType.Door)
				{
					return true;
				}
				for (int k = 0; k < r.doors.Count; k++)
				{
					if (r.doors[k].X == j && r.doors[k].Y == i)
					{
						return true;
					}
				}
				for (int l = 0; l < r.entrances.Count; l++)
				{
					if (r.entrances[l].X == j && r.entrances[l].Y == i)
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	protected void SetStyle(string[] tags, string styleName)
	{
		Tags.SetStyle(tags, MapStyle.FindByName(Options.styles, styleName));
	}

	[Conditional("DH_DEBUG")]
	public void DrawDebugPoints()
	{
		foreach (Pair<Point, Color> debugPoint in DebugPoints)
		{
			Point first = debugPoint.First;
			DebugExt.DrawPoint(new Vector3((float)first.X * 1.5f + 0.75f, 0.5f, (float)(-first.Y) * 1.5f - 0.75f), debugPoint.Second, 0.5f, 20f);
		}
	}
}
public class LightFOV : MonoBehaviour
{
	public Light lightSource;

	public List<MapChunk> fovArea;

	private TileArea tileArea;

	private void Start()
	{
		if (lightSource == null)
		{
			lightSource = GetComponent<Light>();
		}
		if (lightSource == null)
		{
			UnityEngine.Object.Destroy(this);
			return;
		}
		fovArea = new List<MapChunk>();
		tileArea = new TileArea();
		Point sourcePos = Map.Get().WorldToCell(base.transform.position);
		ShadowCastFOV.Scan(Map.Get(), sourcePos, lightSource.range, ExploreFOVTile);
		MapChunk.At(sourcePos.X, sourcePos.Y).AddLight(lightSource);
		MapChunk.Link(fovArea);
	}

	private void ExploreFOVTile(Map map, Cell cell, Point pos)
	{
		if (Map.Get().At(pos).IsTransparent())
		{
			MapChunk chunk = MapChunk.At(pos.X, pos.Y);
			if (!fovArea.Exists((MapChunk e) => e == chunk))
			{
				fovArea.Add(chunk);
			}
			tileArea.Add(pos);
		}
		if (cell != null)
		{
			if (pos.X > 0)
			{
				ExploreFOVTile(map, null, new Point(pos.X - 1, pos.Y));
			}
			if (pos.X < map.Width - 1)
			{
				ExploreFOVTile(map, null, new Point(pos.X + 1, pos.Y));
			}
			if (pos.Y > 0)
			{
				ExploreFOVTile(map, null, new Point(pos.X, pos.Y - 1));
			}
			if (pos.Y < map.Height - 1)
			{
				ExploreFOVTile(map, null, new Point(pos.X, pos.Y + 1));
			}
		}
	}

	public bool CellInFOV(Point cellPos)
	{
		return tileArea.IsInside(cellPos);
	}

	private void OnDrawGizmosSelected()
	{
		foreach (MapChunk item in fovArea)
		{
			item.DebugRender(lightSource.color);
		}
	}
}
public class Map
{
	public int Width;

	public int Height;

	public Cell[][] CellMap;

	public List<Room> Rooms;

	public List<RoomTemplate.PropMarker> PropPositions;

	public List<Point> DoorPositions;

	public List<Point> EntrancePositions;

	public List<Point> FogPositions;

	public Vector2 TileSize;

	public Point ExitPosition;

	public Manager Tags;

	public MapStyle[] mapStyles;

	public MapGraph graph;

	public Texture2D hubHeatMap;

	private static Map instance;

	private Point[] closestTileLeftOrder = new Point[8]
	{
		new Point(-1, 0),
		new Point(0, 1),
		new Point(0, -1),
		new Point(1, 0),
		new Point(-1, -1),
		new Point(-1, 1),
		new Point(1, -1),
		new Point(1, 1)
	};

	private Point[] closestTileRightOrder = new Point[8]
	{
		new Point(1, 0),
		new Point(0, 1),
		new Point(0, -1),
		new Point(-1, 0),
		new Point(1, -1),
		new Point(1, 1),
		new Point(-1, -1),
		new Point(-1, 1)
	};

	private Point[] closestTileUpOrder = new Point[8]
	{
		new Point(0, -1),
		new Point(1, 0),
		new Point(-1, 0),
		new Point(0, 1),
		new Point(-1, -1),
		new Point(1, -1),
		new Point(-1, 1),
		new Point(1, 1)
	};

	private Point[] closestTileDownOrder = new Point[8]
	{
		new Point(0, 1),
		new Point(1, 0),
		new Point(-1, 0),
		new Point(0, -1),
		new Point(-1, 1),
		new Point(1, 1),
		new Point(-1, -1),
		new Point(1, -1)
	};

	public Map(int w, int h, Cell[][] cellMap, List<Room> rooms, List<RoomTemplate.PropMarker> propPositions, List<Point> doorPositions, List<Point> entrancePositions, List<Point> fogPositions, Manager tags)
	{
		Width = w;
		Height = h;
		CellMap = cellMap;
		Rooms = rooms;
		PropPositions = propPositions;
		DoorPositions = doorPositions;
		EntrancePositions = entrancePositions;
		FogPositions = fogPositions;
		Tags = tags;
		instance = this;
		for (int i = 0; i < Height; i++)
		{
			for (int j = 0; j < Width; j++)
			{
				Cell cell = At(j, i);
				cell.adjacency = ComputeAdjacency(new Point(j, i));
				if (cell.IsPit())
				{
					cell.adjacencyPit = ComputeAdjacency(new Point(j, i), pit: true);
				}
				else
				{
					cell.adjacencyPit = 0;
				}
				cell.adjacencyShaft = ComputeAdjacency(new Point(j, i), pit: false, shaft: true);
				cell.adjacencyDoor = ComputeAdjacency(new Point(j, i), pit: false, shaft: false, door: true);
			}
		}
	}

	public static Map Get()
	{
		return instance;
	}

	public static void Clear()
	{
		instance = null;
	}

	public Cell At(Point pos)
	{
		if (!InRange(pos))
		{
			return null;
		}
		return CellMap[pos.Y][pos.X];
	}

	public Cell At(int x, int y)
	{
		if (!InRange(x, y))
		{
			return null;
		}
		return CellMap[y][x];
	}

	public Cell At(Vector3 vWPos)
	{
		Point tilePos = WorldToCell(vWPos);
		if (!InRange(tilePos))
		{
			return null;
		}
		return CellMap[tilePos.Y][tilePos.X];
	}

	public Point WorldToCell(Vector3 vWorldPos)
	{
		return new Point((int)(vWorldPos.x / TileSize.x), (int)((0f - vWorldPos.z) / TileSize.y));
	}

	public Vector2 WorldToCellFloat(Vector3 vWorldPos)
	{
		return new Vector2(vWorldPos.x / TileSize.x, (0f - vWorldPos.z) / TileSize.y);
	}

	public Vector3 CellToWorld(int x, int y)
	{
		return new Vector3((float)x * TileSize.x + TileSize.x / 2f, 0f, (float)(-y) * TileSize.y - TileSize.y / 2f);
	}

	public Vector3 CellToWorld(Point cellPos)
	{
		return CellToWorld(cellPos.X, cellPos.Y);
	}

	public bool InRange(Point tilePos)
	{
		return InRange(tilePos.X, tilePos.Y);
	}

	public bool InRange(int x, int y)
	{
		return x >= 0 && x < Width && y >= 0 && y < Height;
	}

	public Point GetClosestWalkable(Point cellPos)
	{
		return GetClosestWalkable(CellToWorld(cellPos));
	}

	public Point GetClosestWalkable(Vector3 pos)
	{
		Point point = WorldToCell(pos);
		if (!IsBlockedToEnemy(At(point)))
		{
			return point;
		}
		Vector3 vector = (pos - CellToWorld(point)).ToGround().MajorAxis();
		Point[] array = closestTileLeftOrder;
		if (vector.x >= 1f)
		{
			array = closestTileRightOrder;
		}
		else if (vector.x <= -1f)
		{
			array = closestTileLeftOrder;
		}
		else if (vector.z >= 1f)
		{
			array = closestTileUpOrder;
		}
		else if (vector.z <= -1f)
		{
			array = closestTileDownOrder;
		}
		for (int i = 0; i < array.Length; i++)
		{
			Point point2 = point + array[i];
			if (!IsBlockedToEnemy(At(point2)))
			{
				return point2;
			}
		}
		return point;
	}

	public static bool IsBlockedToEnemy(Cell cell)
	{
		return !cell.CanWalk() || (cell.Occupied && cell.Room != null && cell.Door == null && !cell.IsDoor);
	}

	public Door GetDoorBetweenTiles(Point originPos, Point destPos)
	{
		Cell cell = At(originPos);
		Cell cell2 = At(destPos);
		if (originPos == destPos)
		{
			return null;
		}
		Door result = null;
		AdjacencyCode adjacencyCode = AdjacencyCode.Clear;
		AdjacencyCode adjacencyCode2 = AdjacencyCode.Clear;
		if (originPos.Y == destPos.Y)
		{
			if (originPos.X == destPos.X - 1)
			{
				adjacencyCode = AdjacencyCode.RightCenter;
				adjacencyCode2 = AdjacencyCode.LeftCenter;
			}
			else if (originPos.X == destPos.X + 1)
			{
				adjacencyCode = AdjacencyCode.LeftCenter;
				adjacencyCode2 = AdjacencyCode.RightCenter;
			}
		}
		else if (originPos.X == destPos.X)
		{
			if (originPos.Y == destPos.Y - 1)
			{
				adjacencyCode = AdjacencyCode.CenterBottom;
				adjacencyCode2 = AdjacencyCode.CenterTop;
			}
			else if (originPos.Y == destPos.Y + 1)
			{
				adjacencyCode = AdjacencyCode.CenterTop;
				adjacencyCode2 = AdjacencyCode.CenterBottom;
			}
		}
		if ((bool)cell.Door && cell.DoorSide == adjacencyCode)
		{
			result = cell.Door;
		}
		else if ((bool)cell2.Door && cell2.DoorSide == adjacencyCode2)
		{
			result = cell2.Door;
		}
		return result;
	}

	public bool IsReservedDoor(Point pos)
	{
		if (pos.X < 2 || pos.X >= Width - 2 || pos.Y < 2 || pos.Y >= Height - 2)
		{
			return false;
		}
		Cell cell = Get().At(pos);
		if (cell.IsClear() && cell.Room != null)
		{
			bool isDoor = cell.IsDoor;
			isDoor |= Get().At(pos.X - 1, pos.Y).IsDoor;
			isDoor |= Get().At(pos.X + 1, pos.Y).IsDoor;
			isDoor |= Get().At(pos.X, pos.Y - 1).IsDoor;
			isDoor |= Get().At(pos.X, pos.Y + 1).IsDoor;
			isDoor |= Get().At(pos.X - 2, pos.Y).IsDoor && !Get().At(pos.X - 1, pos.Y - 1).IsClear() && !Get().At(pos.X - 1, pos.Y + 1).IsClear();
			isDoor |= Get().At(pos.X + 2, pos.Y).IsDoor && !Get().At(pos.X + 1, pos.Y - 1).IsClear() && !Get().At(pos.X + 1, pos.Y + 1).IsClear();
			isDoor |= Get().At(pos.X, pos.Y - 2).IsDoor && !Get().At(pos.X - 1, pos.Y - 1).IsClear() && !Get().At(pos.X + 1, pos.Y - 1).IsClear();
			return isDoor | (Get().At(pos.X, pos.Y + 2).IsDoor && !Get().At(pos.X - 1, pos.Y + 1).IsClear() && !Get().At(pos.X + 1, pos.Y + 1).IsClear());
		}
		return false;
	}

	public static Point WalkDirection(Point origin, AdjacencyCode dir, int steps = 1)
	{
		Point result = origin;
		for (int i = 0; i < steps; i++)
		{
			switch (dir)
			{
			case AdjacencyCode.LeftTop:
				result += new Point(-1, -1);
				break;
			case AdjacencyCode.CenterTop:
				result += new Point(0, -1);
				break;
			case AdjacencyCode.RightTop:
				result += new Point(1, -1);
				break;
			case AdjacencyCode.LeftCenter:
				result += new Point(-1, 0);
				break;
			case AdjacencyCode.RightCenter:
				result += new Point(1, 0);
				break;
			case AdjacencyCode.LeftBottom:
				result += new Point(-1, 1);
				break;
			case AdjacencyCode.CenterBottom:
				result += new Point(0, 1);
				break;
			case AdjacencyCode.RightBottom:
				result += new Point(1, 1);
				break;
			}
		}
		return result;
	}

	private byte ComputeAdjacency(Point cellPos, bool pit = false, bool shaft = false, bool door = false)
	{
		int num = 0;
		int num2 = 1;
		bool ceilingShaft = At(cellPos).CeilingShaft;
		bool isDoor = At(cellPos).IsDoor;
		for (int i = cellPos.Y - 1; i <= cellPos.Y + 1; i++)
		{
			for (int j = cellPos.X - 1; j <= cellPos.X + 1; j++)
			{
				if (j == cellPos.X && i == cellPos.Y)
				{
					continue;
				}
				if (j >= 0 && j < Width && i >= 0 && i < Height)
				{
					Cell cell = At(j, i);
					if (!pit && !shaft && !door && !cell.IsClearOrPit())
					{
						num |= num2;
					}
					if (pit && !cell.IsPit())
					{
						num |= num2;
					}
					if (shaft && ceilingShaft != cell.CeilingShaft)
					{
						num |= num2;
					}
					if (door)
					{
						bool isDoor2 = cell.IsDoor;
						if (isDoor != isDoor2)
						{
							num |= num2;
						}
					}
				}
				else
				{
					num |= num2;
				}
				num2 *= 2;
			}
		}
		return (byte)num;
	}

	public float FloorHeight(Vector3 position)
	{
		Point point = WorldToCell(position);
		if (point.X > 0 && point.Y > 0 && point.X < Width - 1 && point.Y < Height - 1)
		{
			return 0f;
		}
		return 0f;
	}

	public void PrintToTexture(Texture2D texOut)
	{
		for (int i = 0; i < texOut.height; i++)
		{
			for (int j = 0; j < texOut.width; j++)
			{
				texOut.SetPixel(j, i, Color.black);
			}
		}
		int num = (texOut.width - Width) / 2;
		int num2 = (texOut.height - Height) / 2;
		for (int k = 0; k < Height; k++)
		{
			int y = num2 + (Height - 1 - k);
			for (int l = 0; l < Width; l++)
			{
				switch (CellMap[k][l].Get())
				{
				case CellType.Rock:
					texOut.SetPixel(num + l, y, Color.black);
					break;
				case CellType.Room:
					texOut.SetPixel(num + l, y, Color.white);
					break;
				case CellType.Perimeter:
					texOut.SetPixel(num + l, y, Color.blue);
					break;
				case CellType.Door:
					texOut.SetPixel(num + l, y, Color.white);
					break;
				case CellType.EntranceMark:
					texOut.SetPixel(num + l, y, Color.white);
					break;
				case CellType.Corridor:
					texOut.SetPixel(num + l, y, Color.white);
					break;
				case CellType.Blocked:
					texOut.SetPixel(num + l, y, Color.black);
					break;
				case CellType.Spawn:
					texOut.SetPixel(num + l, y, Color.white);
					break;
				default:
					texOut.SetPixel(num + l, y, Color.red);
					break;
				}
			}
		}
		texOut.Apply();
	}

	public void PrintHUBHeatmap()
	{
		hubHeatMap = new Texture2D(Width, Height, TextureFormat.RGBA32, mipmap: false);
		hubHeatMap.wrapMode = TextureWrapMode.Clamp;
		for (int i = 0; i < hubHeatMap.height; i++)
		{
			for (int j = 0; j < hubHeatMap.width; j++)
			{
				hubHeatMap.SetPixel(j, i, Color.black);
			}
		}
		Room room = null;
		for (int k = 0; k < Rooms.Count; k++)
		{
			if (Rooms[k].Template.size == RoomTemplate.SizeType.Hub)
			{
				room = Rooms[k];
				break;
			}
		}
		int num = (hubHeatMap.width - Width) / 2;
		int num2 = (hubHeatMap.height - Height) / 2;
		for (int l = 0; l < Height; l++)
		{
			int y = num2 + (Height - 1 - l);
			for (int m = 0; m < Width; m++)
			{
				Cell cell = CellMap[l][m];
				if (cell.Room == room && cell.Type != 0)
				{
					hubHeatMap.SetPixel(num + m, y, Color.white);
				}
			}
		}
		LinearBlur linearBlur = new LinearBlur();
		hubHeatMap = linearBlur.Blur(hubHeatMap, 2, 1);
		hubHeatMap.Apply();
	}
}
public class MapBrushesList : Dictionary<string, LSystem<char>>
{
	private static MapBrushesList instance;

	private MapBrushesList()
	{
		instance = this;
		AddBrush(new BasicA());
		AddBrush(new CorIntervalAB());
		AddBrush(new CorIntervalAC());
		AddBrush(new FullArches());
		AddBrush(new FullSegment());
		AddBrush(new FullSegment('D', 'E', 'F'));
		AddBrush(new RandomAABC());
	}

	public static MapBrushesList Get()
	{
		if (instance == null)
		{
			instance = new MapBrushesList();
		}
		return instance;
	}

	public void AddBrush(LSystem<char> brush)
	{
		Add(brush.GetName(), brush);
	}

	public string GetPreview(string name, int length = 16)
	{
		LSystem<char> lSystem = base[name];
		if (lSystem != null)
		{
			List<char> list = lSystem.Process(length);
			StringBuilder stringBuilder = new StringBuilder();
			foreach (char item in list)
			{
				stringBuilder.Append(item);
			}
			stringBuilder.Append(" : ");
			stringBuilder.Append(name);
			return stringBuilder.ToString();
		}
		return string.Empty;
	}
}
[Serializable]
public class MapBrush
{
	public string id = "BasicA";

	public LSystem<char> Grammar => MapBrushesList.Get()[id];

	public string GetPreview(string name, int length = 16)
	{
		return MapBrushesList.Get().GetPreview(id, length);
	}
}
namespace MapBrushes
{
	public class BasicA : LSystem<char>
	{
		public override void Axiom(int capacity, LSeq seq)
		{
			if (capacity >= 1)
			{
				seq.Add('A');
				seq.Add(Delay(Axiom));
			}
		}
	}
	public class CorIntervalAB : LSystem<char>
	{
		private char cA = 'A';

		private char cB = 'A';

		public CorIntervalAB(char cA = 'A', char cB = 'B')
		{
			this.cA = cA;
			this.cB = cB;
		}

		public override void Axiom(int capacity, LSeq seq)
		{
			if (capacity <= 4)
			{
				seq.Add(End);
				return;
			}
			seq.Add(cA);
			seq.Add(cA);
			seq.Add(cB);
			seq.Add(Delay(Axiom));
		}

		public void End(int capacity, LSeq seq)
		{
			if (capacity >= 1)
			{
				seq.Add(cA);
				seq.Add(Delay(End));
			}
		}

		public override string GetName()
		{
			return "CorInterval" + cA + cB;
		}
	}
	public class CorIntervalAC : CorIntervalAB
	{
		public CorIntervalAC()
			: base('A', 'C')
		{
		}
	}
	public class FullArches : LSystem<char>
	{
		public override void Axiom(int capacity, LSeq seq)
		{
			if (capacity < 2)
			{
				seq.Add('A');
				return;
			}
			seq.Add('A');
			seq.Add(Arch);
			seq.Add('A');
		}

		public void Arch(int capacity, LSeq seq)
		{
			if (capacity >= 2)
			{
				seq.Add('B');
				seq.Add('C');
				seq.Add(Arch);
			}
			else
			{
				seq.Add('A');
			}
		}
	}
	public class FullSegment : LSystem<char>
	{
		private char cA = 'A';

		private char cStart = 'B';

		private char cMiddle = 'C';

		private char cEnd = 'D';

		public FullSegment(char cStart = 'B', char cMiddle = 'C', char cEnd = 'D')
		{
			this.cStart = cStart;
			this.cMiddle = cMiddle;
			this.cEnd = cEnd;
		}

		public override void Axiom(int capacity, LSeq seq)
		{
			if (capacity < 2)
			{
				seq.Add(cA);
				return;
			}
			seq.Add(cA);
			seq.Add(SegmentWrapper);
			seq.Add(cA);
		}

		public void SegmentWrapper(int capacity, LSeq seq)
		{
			if (capacity < 2)
			{
				seq.Add(cA);
				return;
			}
			seq.Add(cA);
			seq.Add(Segment);
			seq.Add(cA);
		}

		public void Segment(int capacity, LSeq seq)
		{
			if (capacity >= 2)
			{
				seq.Add(cStart);
				seq.Add(Middle);
				seq.Add(cEnd);
			}
			else
			{
				seq.Add(cA);
			}
		}

		public void Middle(int capacity, LSeq seq)
		{
			seq.Add(cMiddle);
			seq.Add(Middle);
		}

		public override string GetName()
		{
			return GetType().Name + "_" + cStart + cMiddle + cEnd;
		}
	}
	public class RandomAABC : LSystem<char>
	{
		public override void Axiom(int capacity, LSeq seq)
		{
			if (capacity >= 1)
			{
				switch (UnityEngine.Random.Range(0, 7))
				{
				case 0:
					seq.Add('B');
					break;
				case 1:
					seq.Add('C');
					break;
				default:
					seq.Add('A');
					break;
				}
				seq.Add(Delay(Axiom));
			}
		}
	}
}
public class MapBuilder : MonoBehaviour
{
	public enum GeneratorType
	{
		Default,
		Meta01,
		Meta02,
		Meta03,
		Meta04,
		Demo
	}

	private struct EdgeCollapse
	{
		public Vector3 edge;

		public Point tile;
	}

	private struct SWallInfo
	{
		public bool bWallLeft;

		public bool bWallRight;

		public bool bWallUp;

		public bool bWallDown;

		public bool bHasWall;

		public int GetNumWalls()
		{
			return (bWallLeft ? 1 : 0) + (bWallRight ? 1 : 0) + (bWallUp ? 1 : 0) + (bWallDown ? 1 : 0);
		}

		public bool IsInCorner()
		{
			return (bWallLeft && (bWallUp || bWallDown)) || (bWallRight && (bWallUp || bWallDown)) || (bWallUp && (bWallLeft || bWallRight)) || (bWallDown && (bWallLeft || bWallRight));
		}
	}

	private struct SPropMargins
	{
		public int marginLeft;

		public int marginTop;

		public int marginRight;

		public int marginBottom;

		public SPropMargins(int left = 0, int top = 0, int right = 0, int bottom = 0)
		{
			marginLeft = left;
			marginTop = top;
			marginRight = right;
			marginBottom = bottom;
		}
	}

	private class DeferredMiniTransition
	{
		public Point cellPos;

		public AdjacencyCode transCode;

		public DeferredMiniTransition(Point pos, AdjacencyCode code)
		{
			cellPos = pos;
			transCode = code;
		}
	}

	public Texture2D levelMap;

	public GameObject wallPrefab;

	public GameObject floorPrefab;

	public GameObject ceilingPrefab;

	private Map map;

	public MapStyle[] mapStyles;

	public int currentStyle;

	public LevelOptions levelOptions;

	public GameObject visibilityProbePrefab;

	public GameObject chunkPrefab;

	public LayerMask cullMask;

	public GameObject ghostSpawnPrefab;

	public GameObject[] genericProps;

	public GameObject[] lightProps;

	public GameObject[] horrorProps;

	public GameObject[] treasuryProps;

	public GameObject[] doorPrefabs;

	public GameObject exitPrefab;

	public GameObject fogPrefab;

	private Dictionary<Point, List<GameObject>> indexGenericProps;

	private Dictionary<Point, List<GameObject>> indexLightProps;

	private Dictionary<Point, List<GameObject>> indexHorrorProps;

	private Dictionary<Point, List<GameObject>> indexTreasuryProps;

	private Dictionary<GameObject, int> propCount;

	private List<Point> reservedNoProp;

	public GameObject prowlerPrefab;

	public LightEater lightEaterPrefab;

	public Floater floaterPrefab;

	public Bat batPrefab;

	public string seed;

	public GeneratorType generatorType;

	private GBGenerator customGenerator;

	public MetaMapAfterBuild_01 meta01AfterBuild;

	public MetaMapAfterBuild_02 meta02AfterBuild;

	public MetaMapAfterBuild_03 meta03AfterBuild;

	public MetaMapAfterBuild_04 meta04AfterBuild;

	public RoomTemplate testRoom;

	public List<Texture2D> allTexs;

	private GameObject mapGeometry;

	private GameObject visibilityProbes;

	private GameObject ghostSpawns;

	private GameObject wallContainer;

	private GameObject ceiling;

	private GameObject floor;

	private bool PlacedLightSafe;

	private LayerMask geometryLayer;

	private LayerMask propLayer;

	private LayerMask[] staticLayers;

	private Quaternion rotLWallLeft = Quaternion.Euler(-90f, 90f, 0f);

	private Quaternion rotLWallRight = Quaternion.Euler(-90f, -90f, 0f);

	private Quaternion rotLWallTop = Quaternion.Euler(-90f, 180f, 0f);

	private Quaternion rotLWallBottom = Quaternion.Euler(-90f, 0f, 0f);

	private Quaternion rotInCornerLeftTop = Quaternion.Euler(-90f, 180f, 0f);

	private Quaternion rotInCornerRightTop = Quaternion.Euler(-90f, -90f, 0f);

	private Quaternion rotInCornerLeftBottom = Quaternion.Euler(-90f, 90f, 0f);

	private Quaternion rotInCornerRightBottom = Quaternion.Euler(-90f, 0f, 0f);

	private Quaternion rotOutCornerLeftTop = Quaternion.Euler(-90f, 180f, 0f);

	private Quaternion rotOutCornerRightTop = Quaternion.Euler(-90f, -90f, 0f);

	private Quaternion rotOutCornerLeftBottom = Quaternion.Euler(-90f, 90f, 0f);

	private Quaternion rotOutCornerRightBottom = Quaternion.Euler(-90f, 0f, 0f);

	private Quaternion rotSmSingleV = Quaternion.Euler(-90f, 0f, 0f);

	private Quaternion rotSmSingleVHor = Quaternion.Euler(-90f, 0f, 0f);

	private Quaternion rotSmSingleVVer = Quaternion.Euler(-90f, 90f, 0f);

	private Quaternion rotSmSingleH = Quaternion.Euler(-90f, 90f, 0f);

	private Quaternion rotSmCornerLeftTop = Quaternion.Euler(-90f, 0f, 0f);

	private Quaternion rotSmCornerRightTop = Quaternion.Euler(-90f, 270f, 0f);

	private Quaternion rotSmCornerRightBottom = Quaternion.Euler(-90f, 180f, 0f);

	private Quaternion rotSmCornerLeftBottom = Quaternion.Euler(-90f, 90f, 0f);

	private Quaternion rotSmTCrossTop = Quaternion.Euler(-90f, 0f, 0f);

	private Quaternion rotSmTCrossLeft = Quaternion.Euler(-90f, -90f, 0f);

	private Quaternion rotSmTCrossRight = Quaternion.Euler(-90f, 90f, 0f);

	private Quaternion rotSmTCrossBottom = Quaternion.Euler(-90f, 180f, 0f);

	private Quaternion rotSmDeadendTop = Quaternion.Euler(-90f, 0f, 0f);

	private Quaternion rotSmDeadendLeft = Quaternion.Euler(-90f, -90f, 0f);

	private Quaternion rotSmDeadendRight = Quaternion.Euler(-90f, 90f, 0f);

	private Quaternion rotSmDeadendBottom = Quaternion.Euler(-90f, 180f, 0f);

	private byte[][] ceilingMiniTransitions;

	private List<EdgeCollapse> edgeCollapses;

	public bool drawGraph;

	public Texture2D hubHeatMap;

	private static List<GameObject> tempWallList;

	private void Awake()
	{
		Debug.Log("MapBuilder - Reloading room templates");
		RoomTemplate.ReloadRoomTemplates();
		if (levelOptions.seeds != null && levelOptions.seeds.Length >= 1)
		{
			UnityEngine.Random.seed = UnityEngine.Random.seed;
			seed = RandomExt.Choice(levelOptions.seeds);
		}
		if (seed != string.Empty)
		{
			UnityEngine.Random.seed = int.Parse(seed, NumberStyles.HexNumber);
		}
		else
		{
			UnityEngine.Random.seed = UnityEngine.Random.seed;
		}
		int num = UnityEngine.Random.seed;
		string text = $"{num:X}";
		Debug.Log("Seed: " + text);
		seed = text;
		Debug.Log("MapBuilder - Generating map");
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		Map map = GenerateGB();
		Debug.Log("Time - GenerateGB: " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		Generate(map);
		Debug.Log("Time - Generate: " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		if (map.graph != null)
		{
			if (map.graph.CheckConnected())
			{
				Debug.Log("Graph is connected");
			}
			else
			{
				Debug.LogError("Graph is NOT connected");
			}
		}
		if (testRoom != null)
		{
			GetComponent<GhostSpawner>().enabled = false;
		}
		Debug.Log("MapBuilder - Awake end");
		if (customGenerator != null && generatorType != 0)
		{
			(customGenerator as CustomGenerator).AfterBuild();
		}
		if (generatorType == GeneratorType.Meta01)
		{
			MetaMapAfterBuild_01 metaMapAfterBuild_ = UnityEngine.Object.Instantiate(meta01AfterBuild);
			metaMapAfterBuild_.DoBuild();
		}
		else if (generatorType == GeneratorType.Meta02)
		{
			MetaMapAfterBuild_02 metaMapAfterBuild_2 = UnityEngine.Object.Instantiate(meta02AfterBuild);
			metaMapAfterBuild_2.DoBuild();
		}
		else if (generatorType == GeneratorType.Meta03)
		{
			MetaMapAfterBuild_03 metaMapAfterBuild_3 = UnityEngine.Object.Instantiate(meta03AfterBuild);
			metaMapAfterBuild_3.DoBuild();
		}
		else if (generatorType == GeneratorType.Meta04)
		{
			MetaMapAfterBuild_04 metaMapAfterBuild_4 = UnityEngine.Object.Instantiate(meta04AfterBuild);
			metaMapAfterBuild_4.DoBuild();
		}
	}

	public void Update()
	{
	}

	public GameObject Generate(Map newMap, bool positionPlayer = true)
	{
		map = newMap;
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		Debug.Log("MapBuilder - Building map");
		map.mapStyles = mapStyles;
		geometryLayer = LayerMask.NameToLayer("StaticGeometry");
		propLayer = LayerMask.NameToLayer("Prop");
		staticLayers = new LayerMask[3];
		ref LayerMask reference = ref staticLayers[0];
		reference = geometryLayer;
		ref LayerMask reference2 = ref staticLayers[1];
		reference2 = propLayer;
		ref LayerMask reference3 = ref staticLayers[2];
		reference3 = LayerMask.NameToLayer("MapHider");
		newMap.PrintHUBHeatmap();
		hubHeatMap = newMap.hubHeatMap;
		GameObject[] array = doorPrefabs;
		if (levelOptions.doorPrefabs != null && levelOptions.doorPrefabs.Length > 0)
		{
			array = levelOptions.doorPrefabs;
		}
		propCount = new Dictionary<GameObject, int>();
		mapGeometry = new GameObject("MapGeometry");
		reservedNoProp = new List<Point>();
		GameObject gameObject = new GameObject("StaticGeometry");
		gameObject.transform.parent = mapGeometry.transform;
		wallContainer = new GameObject("Walls");
		wallContainer.transform.parent = gameObject.transform;
		wallContainer.isStatic = true;
		wallContainer.layer = geometryLayer;
		ceiling = new GameObject("Ceiling");
		ceiling.transform.parent = gameObject.transform;
		ceiling.transform.localPosition = new Vector3(0f, 0f, 0f);
		ceiling.isStatic = true;
		ceiling.layer = geometryLayer;
		floor = new GameObject("Floor");
		floor.transform.parent = gameObject.transform;
		floor.isStatic = true;
		floor.layer = geometryLayer;
		visibilityProbes = new GameObject("VisibilityProbes");
		ghostSpawns = new GameObject("GhostSpawns");
		Vector3 vector = Vector3.zero;
		int width = map.Width;
		int height = map.Height;
		Vector2 vector2 = new Vector2(1.5f, 1.5f);
		map.TileSize = vector2;
		float num = 0f;
		float x = map.TileSize.x;
		Debug.Log("Time - Generate::Init " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		byte[][] array2 = new byte[map.Height][];
		for (int i = 0; i < map.Height; i++)
		{
			array2[i] = new byte[map.Width];
			for (int j = 0; j < map.Width; j++)
			{
				array2[i][j] = byte.MaxValue;
			}
		}
		ceilingMiniTransitions = new byte[map.Height][];
		for (int k = 0; k < map.Height; k++)
		{
			ceilingMiniTransitions[k] = new byte[map.Width];
			for (int l = 0; l < map.Width; l++)
			{
				ceilingMiniTransitions[k][l] = 0;
			}
		}
		List<DeferredMiniTransition> list = new List<DeferredMiniTransition>();
		edgeCollapses = new List<EdgeCollapse>();
		GameObject[][] array3 = new GameObject[map.Height][];
		GameObject[][] array4 = new GameObject[map.Height][];
		for (int m = 0; m < map.Height; m++)
		{
			array3[m] = new GameObject[map.Width];
			array4[m] = new GameObject[map.Width];
			for (int n = 0; n < map.Width; n++)
			{
				array3[m][n] = null;
				array4[m][n] = null;
			}
		}
		Debug.Log("Time - Generate::InitArrays " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		List<Pair<Point, AdjacencyCode>> list2 = new List<Pair<Point, AdjacencyCode>>();
		List<string> list3 = new List<string>();
		list3.Add(levelOptions.tag);
		list3.Add("corridor");
		list3.Add("narrow");
		MapStyle style = map.Tags.GetStyle(map.mapStyles, list3);
		for (int num2 = 0; num2 < map.Height; num2++)
		{
			for (int num3 = 0; num3 < map.Width; num3++)
			{
				Cell cell = Map.Get().At(num3, num2);
				int numAdjacentWallsNoCorners = cell.GetNumAdjacentWallsNoCorners();
				if (!cell.IsCorridor() || map.EntrancePositions.Contains(new Point(num3, num2)))
				{
					continue;
				}
				MapStyle style2 = Map.Get().Tags.GetStyle(mapStyles, new Point(num3, num2));
				Point point = new Point(num3 - 1, num2);
				Cell cell2 = Map.Get().At(point);
				if (cell2.IsClear())
				{
					MapStyle style3 = Map.Get().Tags.GetStyle(mapStyles, point);
					if (style3 != style2)
					{
						int numAdjacentWallsNoCorners2 = Map.Get().At(point).GetNumAdjacentWallsNoCorners();
						AdjacencyCode second = AdjacencyCode.RightCenter;
						bool flag = numAdjacentWallsNoCorners2 < numAdjacentWallsNoCorners;
						if (numAdjacentWallsNoCorners2 == numAdjacentWallsNoCorners)
						{
							flag = style2 == style;
						}
						if (flag)
						{
							point = new Point(num3, num2);
							second = AdjacencyCode.LeftCenter;
						}
						list2.AddIfNotInside(new Pair<Point, AdjacencyCode>(point, second));
					}
				}
				Point point2 = new Point(num3 + 1, num2);
				Cell cell3 = Map.Get().At(point2);
				if (cell3.IsClear())
				{
					MapStyle style4 = Map.Get().Tags.GetStyle(mapStyles, point2);
					if (style4 != style2)
					{
						int numAdjacentWallsNoCorners3 = Map.Get().At(point2).GetNumAdjacentWallsNoCorners();
						AdjacencyCode second2 = AdjacencyCode.LeftCenter;
						bool flag2 = numAdjacentWallsNoCorners3 < numAdjacentWallsNoCorners;
						if (numAdjacentWallsNoCorners3 == numAdjacentWallsNoCorners)
						{
							flag2 = style2 == style;
						}
						if (flag2)
						{
							point2 = new Point(num3, num2);
							second2 = AdjacencyCode.RightCenter;
						}
						list2.AddIfNotInside(new Pair<Point, AdjacencyCode>(point2, second2));
					}
				}
				Point point3 = new Point(num3, num2 - 1);
				Cell cell4 = Map.Get().At(point3);
				if (cell4.IsClear())
				{
					MapStyle style5 = Map.Get().Tags.GetStyle(mapStyles, point3);
					if (style5 != style2)
					{
						int numAdjacentWallsNoCorners4 = Map.Get().At(point3).GetNumAdjacentWallsNoCorners();
						AdjacencyCode second3 = AdjacencyCode.CenterBottom;
						bool flag3 = numAdjacentWallsNoCorners4 < numAdjacentWallsNoCorners;
						if (numAdjacentWallsNoCorners4 == numAdjacentWallsNoCorners)
						{
							flag3 = style2 == style;
						}
						if (flag3)
						{
							point3 = new Point(num3, num2);
							second3 = AdjacencyCode.CenterTop;
						}
						list2.AddIfNotInside(new Pair<Point, AdjacencyCode>(point3, second3));
					}
				}
				Point point4 = new Point(num3, num2 + 1);
				Cell cell5 = Map.Get().At(point4);
				if (!cell5.IsClear())
				{
					continue;
				}
				MapStyle style6 = Map.Get().Tags.GetStyle(mapStyles, point4);
				if (style6 != style2)
				{
					int numAdjacentWallsNoCorners5 = Map.Get().At(point4).GetNumAdjacentWallsNoCorners();
					AdjacencyCode second4 = AdjacencyCode.CenterTop;
					bool flag4 = numAdjacentWallsNoCorners5 < numAdjacentWallsNoCorners;
					if (numAdjacentWallsNoCorners5 == numAdjacentWallsNoCorners)
					{
						flag4 = style2 == style;
					}
					if (flag4)
					{
						point4 = new Point(num3, num2);
						second4 = AdjacencyCode.CenterBottom;
					}
					list2.AddIfNotInside(new Pair<Point, AdjacencyCode>(point4, second4));
				}
			}
		}
		Debug.Log("Time - Generate::ExtraEntrances " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		Debug.Log("MapBuilder - Creating chunks");
		MapChunk.InitChunks(chunkPrefab, mapGeometry.transform);
		Debug.Log("Time - Generate::InitChunks " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		Debug.Log("MapBuilder - Creating geometry");
		bool flag5 = false;
		bool flag6 = false;
		List<GameObject> listWalls = new List<GameObject>();
		for (int num4 = 0; num4 < width; num4++)
		{
			for (int num5 = 0; num5 < height; num5++)
			{
				Cell cell6 = map.CellMap[num5][num4];
				MapChunk mapChunk = MapChunk.At(num4, num5);
				MapStyle style7 = Map.Get().Tags.GetStyle(mapStyles, new Point(num4, num5));
				int num6 = Map.Get().Tags.GetVariation(new Point(num4, num5));
				if (num6 >= style7.lWallPrefabs.Length)
				{
					num6 = 0;
				}
				if (cell6.IsClearOrPit())
				{
					if (cell6.Type == CellType.Spawn)
					{
						vector = new Vector3((float)num4 * vector2.x + vector2.x / 2f, 1.05f, (float)(-num5) * vector2.y - vector2.y / 2f);
					}
					if (!cell6.Occupied || cell6.IsClear())
					{
						GameObject gameObject2 = UnityEngine.Object.Instantiate(visibilityProbePrefab);
						gameObject2.name = "Probe_" + num4 + "_" + num5;
						gameObject2.transform.parent = visibilityProbes.transform;
						Vector3 localPosition = new Vector3((float)num4 * vector2.x, 0f, (float)(-num5) * vector2.y);
						localPosition += new Vector3(vector2.x / 2f, 0f, (0f - vector2.y) / 2f);
						gameObject2.transform.localPosition = localPosition;
						cell6.Probe = gameObject2.GetComponent<VisibilityProbe>();
						mapChunk.probeList.Add(cell6.Probe);
						if (num4 % 4 == 0)
						{
							int num7 = num4 - 1;
							if (num7 >= 0)
							{
								MapChunk.At(num7, num5).probeList.Add(cell6.Probe);
							}
						}
						else if (num4 % 4 == 3)
						{
							int num8 = num4 + 1;
							if (num8 < width)
							{
								MapChunk.At(num8, num5).probeList.Add(cell6.Probe);
							}
						}
						if (num5 % 4 == 0)
						{
							int num9 = num5 - 1;
							if (num9 >= 0)
							{
								MapChunk.At(num4, num9).probeList.Add(cell6.Probe);
							}
						}
						else if (num5 % 4 == 3)
						{
							int num10 = num5 + 1;
							if (num10 < height)
							{
								MapChunk.At(num4, num10).probeList.Add(cell6.Probe);
							}
						}
					}
					if (((!cell6.Occupied && cell6.IsClear()) || cell6.IsCorridor()) && (cell6.Room == null || !cell6.Room.Safe) && UnityEngine.Random.value < 0.2f)
					{
						GameObject gameObject3 = UnityEngine.Object.Instantiate(ghostSpawnPrefab);
						gameObject3.name = "spawn_" + num4 + "_" + num5;
						gameObject3.transform.parent = ghostSpawns.transform;
						Vector3 localPosition2 = new Vector3((float)num4 * vector2.x, 0f, (float)(-num5) * vector2.y);
						localPosition2 += new Vector3(vector2.x / 2f, 0f, (0f - vector2.y) / 2f);
						gameObject3.transform.localPosition = localPosition2;
						cell6.Spawn = gameObject3.GetComponent<VisibilityProbe>();
					}
					BuildWalls(num4, num5, cell6.adjacency, style7, mapChunk, num6, x, "WallSection", 0f, listWalls);
					if (cell6.IsPit())
					{
						BuildPitWalls(num4, num5, cell6, style7, mapChunk, x);
					}
					if (cell6.CeilingShaft)
					{
						BuildShaftWalls(num4, num5, cell6, style7, mapChunk, x);
					}
					if (!cell6.CeilingShaft)
					{
						GameObject gameObject4 = null;
						Quaternion localRotation = Quaternion.Euler(-90f, 0f, 0f);
						AdjacencyCode adjacencyCode = AdjacencyCode.Clear;
						if (cell6.CheckAdjacencyClearCeiling((AdjacencyCode)255))
						{
							gameObject4 = style7.ceilingPrefabs.lgSinglePrefab;
							if (style7.ceilingPrefabs.alignToRoomDirection)
							{
								Room room = cell6.Room;
								if (room != null)
								{
									localRotation = ((room.Template.flags.ceilingHint == RoomTemplate.Flags.CeilingHint.Horizontal) ? rotSmSingleVHor : ((room.Template.flags.ceilingHint == RoomTemplate.Flags.CeilingHint.Vertical) ? rotSmSingleVVer : ((room.Template.height <= room.Template.width) ? rotSmSingleVHor : rotSmSingleVVer)));
								}
							}
						}
						else if ((cell6.CheckAdjacencyCeiling(AdjacencyCode.LeftCenter) || cell6.CheckAdjacencyCeiling((AdjacencyCode)33)) && cell6.CheckAdjacencyClearCeiling((AdjacencyCode)214))
						{
							gameObject4 = style7.ceilingPrefabs.lgLWallPrefab;
							localRotation = rotLWallLeft;
							adjacencyCode |= AdjacencyCode.LeftCenter;
						}
						else if ((cell6.CheckAdjacencyCeiling(AdjacencyCode.RightCenter) || cell6.CheckAdjacencyCeiling((AdjacencyCode)132)) && cell6.CheckAdjacencyClearCeiling((AdjacencyCode)107))
						{
							gameObject4 = style7.ceilingPrefabs.lgLWallPrefab;
							localRotation = rotLWallRight;
							adjacencyCode |= AdjacencyCode.RightCenter;
						}
						else if ((cell6.CheckAdjacencyCeiling(AdjacencyCode.CenterTop) || cell6.CheckAdjacencyCeiling((AdjacencyCode)5)) && cell6.CheckAdjacencyClearCeiling((AdjacencyCode)248))
						{
							gameObject4 = style7.ceilingPrefabs.lgLWallPrefab;
							localRotation = rotLWallTop;
							adjacencyCode |= AdjacencyCode.CenterTop;
						}
						else if ((cell6.CheckAdjacencyCeiling(AdjacencyCode.CenterBottom) || cell6.CheckAdjacencyCeiling((AdjacencyCode)160)) && cell6.CheckAdjacencyClearCeiling((AdjacencyCode)31))
						{
							gameObject4 = style7.ceilingPrefabs.lgLWallPrefab;
							localRotation = rotLWallBottom;
							adjacencyCode |= AdjacencyCode.CenterBottom;
						}
						else if ((cell6.CheckAdjacencyCeiling((AdjacencyCode)10) || cell6.CheckAdjacencyCeiling((AdjacencyCode)37) || cell6.CheckAdjacencyCeiling((AdjacencyCode)12) || cell6.CheckAdjacencyCeiling((AdjacencyCode)34)) && cell6.CheckAdjacencyClearCeiling((AdjacencyCode)208))
						{
							gameObject4 = style7.ceilingPrefabs.lgInCornerPrefab;
							localRotation = rotInCornerLeftBottom;
							adjacencyCode |= AdjacencyCode.LeftCenter;
							adjacencyCode |= AdjacencyCode.CenterTop;
						}
						else if ((cell6.CheckAdjacencyCeiling((AdjacencyCode)18) || cell6.CheckAdjacencyCeiling((AdjacencyCode)133) || cell6.CheckAdjacencyCeiling((AdjacencyCode)17) || cell6.CheckAdjacencyCeiling((AdjacencyCode)130)) && cell6.CheckAdjacencyClearCeiling((AdjacencyCode)104))
						{
							gameObject4 = style7.ceilingPrefabs.lgInCornerPrefab;
							localRotation = rotInCornerLeftTop;
							adjacencyCode |= AdjacencyCode.RightCenter;
							adjacencyCode |= AdjacencyCode.CenterTop;
						}
						else if ((cell6.CheckAdjacencyCeiling((AdjacencyCode)72) || cell6.CheckAdjacencyCeiling((AdjacencyCode)161) || cell6.CheckAdjacencyCeiling((AdjacencyCode)136) || cell6.CheckAdjacencyCeiling((AdjacencyCode)65)) && cell6.CheckAdjacencyClearCeiling((AdjacencyCode)22))
						{
							gameObject4 = style7.ceilingPrefabs.lgInCornerPrefab;
							localRotation = rotInCornerRightBottom;
							adjacencyCode |= AdjacencyCode.LeftCenter;
							adjacencyCode |= AdjacencyCode.CenterBottom;
						}
						else if ((cell6.CheckAdjacencyCeiling((AdjacencyCode)80) || cell6.CheckAdjacencyCeiling((AdjacencyCode)164) || cell6.CheckAdjacencyCeiling((AdjacencyCode)48) || cell6.CheckAdjacencyCeiling((AdjacencyCode)68)) && cell6.CheckAdjacencyClearCeiling((AdjacencyCode)11))
						{
							gameObject4 = style7.ceilingPrefabs.lgInCornerPrefab;
							localRotation = rotInCornerRightTop;
							adjacencyCode |= AdjacencyCode.RightCenter;
							adjacencyCode |= AdjacencyCode.CenterBottom;
						}
						else if (cell6.adjacency == 1)
						{
							gameObject4 = style7.ceilingPrefabs.lgOutCornerPrefab;
							localRotation = rotOutCornerLeftTop;
						}
						else if (cell6.adjacency == 4)
						{
							gameObject4 = style7.ceilingPrefabs.lgOutCornerPrefab;
							localRotation = rotOutCornerRightTop;
						}
						else if (cell6.adjacency == 32)
						{
							gameObject4 = style7.ceilingPrefabs.lgOutCornerPrefab;
							localRotation = rotOutCornerLeftBottom;
						}
						else if (cell6.adjacency == 128)
						{
							gameObject4 = style7.ceilingPrefabs.lgOutCornerPrefab;
							localRotation = rotOutCornerRightBottom;
						}
						else
						{
							array2[num5][num4] = 0;
						}
						flag6 = flag6 || style7.ceilingNoise;
						if (gameObject4 != null)
						{
							if (style7.ceilingPrefabs.noRotate)
							{
								localRotation = rotSmSingleV;
							}
							GameObject gameObject5 = UnityEngine.Object.Instantiate(gameObject4, Vector3.zero, Quaternion.identity);
							gameObject5.name = "Ceiling_" + num4 + "_" + num5;
							gameObject5.transform.parent = ceiling.transform;
							float y = style7.ceilingHeight - 3.5f;
							gameObject5.transform.localPosition = new Vector3((float)num4 * x + x / 2f, y, (float)(-num5) * x - x / 2f);
							gameObject5.transform.localRotation = localRotation;
							gameObject5.layer = geometryLayer;
							gameObject5.tag = Tags.MapGeometry;
							mapChunk.AddToCombine(gameObject5);
							StripNonStatic(gameObject5.transform, mapGeometry.transform);
							array3[num5][num4] = gameObject5;
						}
						else
						{
							array2[num5][num4] = 0;
						}
						if (!cell6.IsDoor && adjacencyCode != 0 && style7.arched)
						{
							GameObject ceilingTransitionPrefab = style7.GetCeilingTransitionPrefab();
							float transitionHOffset = style7.transitionHOffset;
							if (Cell.CheckAdjacency((byte)adjacencyCode, AdjacencyCode.RightCenter) && !cell6.CheckAdjacency(AdjacencyCode.RightCenter))
							{
								list.Add(new DeferredMiniTransition(new Point(num4, num5), AdjacencyCode.RightCenter));
							}
							if (Cell.CheckAdjacency((byte)adjacencyCode, AdjacencyCode.LeftCenter) && !cell6.CheckAdjacency(AdjacencyCode.LeftCenter))
							{
								list.Add(new DeferredMiniTransition(new Point(num4, num5), AdjacencyCode.LeftCenter));
							}
							if (Cell.CheckAdjacency((byte)adjacencyCode, AdjacencyCode.CenterTop) && !cell6.CheckAdjacency(AdjacencyCode.CenterTop))
							{
								list.Add(new DeferredMiniTransition(new Point(num4, num5), AdjacencyCode.CenterTop));
							}
							if (Cell.CheckAdjacency((byte)adjacencyCode, AdjacencyCode.CenterBottom) && !cell6.CheckAdjacency(AdjacencyCode.CenterBottom))
							{
								list.Add(new DeferredMiniTransition(new Point(num4, num5), AdjacencyCode.CenterBottom));
							}
						}
					}
					if (!cell6.IsPit())
					{
						GameObject gameObject6 = UnityEngine.Object.Instantiate(style7.floorPrefab, Vector3.zero, Quaternion.identity);
						gameObject6.name = "Floor_" + num4 + "_" + num5;
						gameObject6.transform.parent = floor.transform;
						gameObject6.transform.localPosition = new Vector3((float)num4 * x + x / 2f, 0f, (float)(-num5) * x - x / 2f);
						gameObject6.transform.localRotation = Quaternion.Euler(-90f, 0f, 0f);
						gameObject6.layer = geometryLayer;
						if (gameObject6.tag.Length == 0 || gameObject6.tag == Tags.Untagged)
						{
							gameObject6.tag = Tags.MapGeometry;
						}
						mapChunk.AddToCombine(gameObject6);
						StripNonStatic(gameObject6.transform, mapGeometry.transform);
						array4[num5][num4] = gameObject6;
						flag5 = flag5 || style7.floorNoise;
					}
					continue;
				}
				bool flag7 = true;
				if (!cell6.CheckAdjacency((AdjacencyCode)90) && !cell6.IsPit())
				{
					GameObject gameObject7 = UnityEngine.Object.Instantiate(wallPrefab, Vector3.zero, Quaternion.identity);
					gameObject7.name = "WallSection_" + num4 + "_" + num5;
					gameObject7.transform.parent = wallContainer.transform;
					ProceduralCube component = gameObject7.GetComponent<ProceduralCube>();
					component.Rebuild();
					gameObject7.transform.localPosition = new Vector3((float)num4 * Map.Get().TileSize.x, 0f, (float)(-num5) * Map.Get().TileSize.y - Map.Get().TileSize.y);
					if (component.fSizeY > num)
					{
						num = component.fSizeY;
					}
				}
			}
		}
		Debug.Log("Time - Generate::Main geometry " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		Debug.Log("MapBuilder - Creating ceiling (2nd pass)");
		for (int num11 = 0; num11 < map.Height; num11++)
		{
			for (int num12 = 0; num12 < map.Width; num12++)
			{
				if (array2[num11][num12] != 0)
				{
					continue;
				}
				int num13 = 0;
				int num14 = 1;
				MapStyle style8 = Map.Get().Tags.GetStyle(mapStyles, new Point(num12, num11));
				for (int num15 = num11 - 1; num15 <= num11 + 1; num15++)
				{
					for (int num16 = num12 - 1; num16 <= num12 + 1; num16++)
					{
						if (num16 == num12 && num15 == num11)
						{
							continue;
						}
						if (num16 >= 0 && num16 < map.Width && num15 >= 0 && num15 < map.Height)
						{
							if (array2[num15][num16] == byte.MaxValue)
							{
								num13 |= num14;
							}
							else
							{
								MapStyle style9 = Map.Get().Tags.GetStyle(mapStyles, new Point(num16, num15));
								if (style9 != style8)
								{
									num13 |= num14;
								}
							}
						}
						else
						{
							num13 |= num14;
						}
						num14 *= 2;
					}
				}
				if (num13 == 255)
				{
					num13 = 0;
				}
				array2[num11][num12] = (byte)num13;
			}
		}
		for (int num17 = 0; num17 < width; num17++)
		{
			for (int num18 = 0; num18 < height; num18++)
			{
				Cell cell7 = map.CellMap[num18][num17];
				MapChunk mapChunk2 = MapChunk.At(num17, num18);
				GameObject gameObject8 = null;
				MapStyle style10 = Map.Get().Tags.GetStyle(mapStyles, new Point(num17, num18));
				byte b = array2[num18][num17];
				if (!cell7.IsClear() || b == byte.MaxValue)
				{
					continue;
				}
				Quaternion localRotation2 = rotSmSingleV;
				if (Cell.CheckAdjacency(b, (AdjacencyCode)90))
				{
					gameObject8 = style10.ceilingPrefabs.smSinglePrefab;
				}
				else if (Cell.CheckAdjacency(b, (AdjacencyCode)24) && Cell.CheckAdjacencyClear(b, (AdjacencyCode)66))
				{
					gameObject8 = style10.ceilingPrefabs.smLWallPrefab;
				}
				else if (Cell.CheckAdjacency(b, (AdjacencyCode)66) && Cell.CheckAdjacencyClear(b, (AdjacencyCode)24))
				{
					gameObject8 = style10.ceilingPrefabs.smLWallPrefab;
					if (style10.ceilingPrefabs.alignPieces)
					{
						localRotation2 = rotSmSingleH;
					}
				}
				else if (Cell.CheckAdjacency(b, (AdjacencyCode)26) && Cell.CheckAdjacencyClear(b, AdjacencyCode.CenterBottom))
				{
					gameObject8 = style10.ceilingPrefabs.smDeadendPrefab;
					localRotation2 = rotSmDeadendTop;
				}
				else if (Cell.CheckAdjacency(b, (AdjacencyCode)88) && Cell.CheckAdjacencyClear(b, AdjacencyCode.CenterTop))
				{
					gameObject8 = style10.ceilingPrefabs.smDeadendPrefab;
					localRotation2 = rotSmDeadendBottom;
				}
				else if (Cell.CheckAdjacency(b, (AdjacencyCode)74) && Cell.CheckAdjacencyClear(b, AdjacencyCode.RightCenter))
				{
					gameObject8 = style10.ceilingPrefabs.smDeadendPrefab;
					localRotation2 = rotSmDeadendLeft;
				}
				else if (Cell.CheckAdjacency(b, (AdjacencyCode)82) && Cell.CheckAdjacencyClear(b, AdjacencyCode.LeftCenter))
				{
					gameObject8 = style10.ceilingPrefabs.smDeadendPrefab;
					localRotation2 = rotSmDeadendRight;
				}
				else if (Cell.CheckAdjacency(b, (AdjacencyCode)50))
				{
					gameObject8 = style10.ceilingPrefabs.smCornerPrefab;
					localRotation2 = rotSmCornerLeftTop;
				}
				else if (Cell.CheckAdjacency(b, (AdjacencyCode)138))
				{
					gameObject8 = style10.ceilingPrefabs.smCornerPrefab;
					localRotation2 = rotSmCornerRightTop;
				}
				else if (Cell.CheckAdjacency(b, (AdjacencyCode)81))
				{
					gameObject8 = style10.ceilingPrefabs.smCornerPrefab;
					localRotation2 = rotSmCornerLeftBottom;
				}
				else if (Cell.CheckAdjacency(b, (AdjacencyCode)76))
				{
					gameObject8 = style10.ceilingPrefabs.smCornerPrefab;
					localRotation2 = rotSmCornerRightBottom;
				}
				else if (Cell.CheckAdjacency(b, AdjacencyCode.CenterTop) && Cell.CheckAdjacencyClear(b, (AdjacencyCode)88))
				{
					gameObject8 = style10.ceilingPrefabs.smTIntersectionPrefab;
					localRotation2 = rotSmTCrossTop;
				}
				else if (Cell.CheckAdjacency(b, AdjacencyCode.CenterBottom) && Cell.CheckAdjacencyClear(b, (AdjacencyCode)26))
				{
					gameObject8 = style10.ceilingPrefabs.smTIntersectionPrefab;
					localRotation2 = rotSmTCrossBottom;
				}
				else if (Cell.CheckAdjacency(b, AdjacencyCode.LeftCenter) && Cell.CheckAdjacencyClear(b, (AdjacencyCode)82))
				{
					gameObject8 = style10.ceilingPrefabs.smTIntersectionPrefab;
					localRotation2 = rotSmTCrossLeft;
				}
				else if (!Cell.CheckAdjacency(b, AdjacencyCode.RightCenter) || !Cell.CheckAdjacencyClear(b, (AdjacencyCode)74))
				{
					gameObject8 = ((!Cell.CheckAdjacency(b, (AdjacencyCode)165) || !Cell.CheckAdjacencyClear(b, (AdjacencyCode)90)) ? style10.ceilingPrefabs.smSinglePrefab : style10.ceilingPrefabs.sm4IntersectionPrefab);
				}
				else
				{
					gameObject8 = style10.ceilingPrefabs.smTIntersectionPrefab;
					localRotation2 = rotSmTCrossRight;
				}
				if (gameObject8 != null)
				{
					if (style10.ceilingPrefabs.noRotate)
					{
						localRotation2 = rotSmSingleV;
					}
					GameObject gameObject9 = UnityEngine.Object.Instantiate(gameObject8, Vector3.zero, Quaternion.identity);
					gameObject9.name = "Ceiling_" + num17 + "_" + num18;
					gameObject9.transform.parent = ceiling.transform;
					float y2 = style10.ceilingHeight - 3.5f;
					gameObject9.transform.localPosition = new Vector3((float)num17 * x + x / 2f, y2, (float)(-num18) * x - x / 2f);
					gameObject9.transform.localRotation = localRotation2;
					gameObject9.layer = geometryLayer;
					gameObject9.tag = Tags.MapGeometry;
					mapChunk2.AddToCombine(gameObject9);
					StripNonStatic(gameObject9.transform, mapGeometry.transform);
					array3[num18][num17] = gameObject9;
				}
			}
		}
		Debug.Log("Time - Generate::Ceiling 2nd pass " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		Debug.Log("MapBuilder - Adding doors");
		for (int num19 = 0; num19 < map.DoorPositions.Count; num19++)
		{
			Point point5 = map.DoorPositions[num19];
			GameObject gameObject10 = array[UnityEngine.Random.Range(0, array.Length)];
			if (!GetEntrancePositioning(point5, out var vPos, out var vLookAt, out var doorSide, gameObject10))
			{
				continue;
			}
			GameObject gameObject11 = UnityEngine.Object.Instantiate(gameObject10, Vector3.zero, Quaternion.LookRotation(vLookAt) * Quaternion.AngleAxis(-90f, Vector3.up));
			gameObject11.transform.parent = mapGeometry.transform;
			gameObject11.transform.localPosition = vPos;
			gameObject11.name = "Door_" + num19;
			map.CellMap[point5.Y][point5.X].Door = gameObject11.GetComponent<Door>();
			map.CellMap[point5.Y][point5.X].DoorSide = doorSide;
			MapChunk.AddGeometry(gameObject11, new Point(point5.X - 1, point5.Y - 1), 3, 3);
			Unlockable componentInChildren = gameObject11.GetComponentInChildren<Unlockable>();
			if (UnityEngine.Random.value < 0.8f)
			{
				componentInChildren.InitLocked();
				if (UnityEngine.Random.value < 0.2f)
				{
					componentInChildren.PlaySilence = true;
				}
			}
			else
			{
				componentInChildren.Locked = false;
			}
			AddDoorFrame(point5, doorSide, hasDoor: true, mapStyles, wallContainer);
		}
		foreach (Point entrancePosition in map.EntrancePositions)
		{
			if (GetEntrancePositioning(entrancePosition, out var _, out var _, out var doorSide2, null))
			{
				AddDoorFrame(entrancePosition, doorSide2, hasDoor: false, mapStyles, wallContainer);
			}
		}
		foreach (Pair<Point, AdjacencyCode> item2 in list2)
		{
			Point first = item2.First;
			AdjacencyCode second5 = item2.Second;
			AddDoorFrame(first, second5, hasDoor: false, mapStyles, wallContainer);
		}
		for (int num20 = 0; num20 < map.Height; num20++)
		{
			for (int num21 = 0; num21 < map.Width; num21++)
			{
				if (map.At(num21, num20).Room == null)
				{
					continue;
				}
				Point point6 = new Point(num21 - 1, num20 + 1);
				Point point7 = new Point(num21 + 1, num20 + 1);
				Point point8 = new Point(num21 - 1, num20 - 1);
				Point point9 = new Point(num21 + 1, num20 - 1);
				AdjacencyCode adjacencyCode2 = AdjacencyCode.Clear;
				if (adjacencyCode2 == AdjacencyCode.Clear && Map.Get().InRange(point6) && map.At(point6).DoorSide == AdjacencyCode.RightCenter)
				{
					adjacencyCode2 = AdjacencyCode.CenterBottom;
				}
				if (adjacencyCode2 == AdjacencyCode.Clear && Map.Get().InRange(point7) && map.At(point7).DoorSide == AdjacencyCode.CenterTop)
				{
					adjacencyCode2 = AdjacencyCode.RightCenter;
				}
				if (adjacencyCode2 == AdjacencyCode.Clear && Map.Get().InRange(point8) && map.At(point8).DoorSide == AdjacencyCode.CenterBottom)
				{
					adjacencyCode2 = AdjacencyCode.LeftCenter;
				}
				if (adjacencyCode2 == AdjacencyCode.Clear && Map.Get().InRange(point9) && map.At(point9).DoorSide == AdjacencyCode.LeftCenter)
				{
					adjacencyCode2 = AdjacencyCode.CenterTop;
				}
				AdjacencyCode adjacencyCode3 = map.At(num21, num20).IsNextToDoor;
				if (adjacencyCode3 == AdjacencyCode.Clear && adjacencyCode2 != 0)
				{
					adjacencyCode3 = adjacencyCode2;
				}
				if (adjacencyCode2 == AdjacencyCode.Clear && adjacencyCode3 == AdjacencyCode.Clear)
				{
					if (adjacencyCode3 == AdjacencyCode.Clear && Map.Get().InRange(point6) && map.At(point6).DoorSide == AdjacencyCode.CenterTop)
					{
						adjacencyCode3 = AdjacencyCode.LeftCenter;
						if (Map.Get().InRange(num21, num20 - 1))
						{
							map.At(num21, num20 - 1).IsNextToDoor = adjacencyCode3;
						}
					}
					if (adjacencyCode3 == AdjacencyCode.Clear && Map.Get().InRange(point7) && map.At(point7).DoorSide == AdjacencyCode.LeftCenter)
					{
						adjacencyCode3 = AdjacencyCode.CenterBottom;
						if (Map.Get().InRange(num21 - 1, num20))
						{
							map.At(num21 - 1, num20).IsNextToDoor = adjacencyCode3;
						}
					}
					if (adjacencyCode3 == AdjacencyCode.Clear && Map.Get().InRange(point8) && map.At(point8).DoorSide == AdjacencyCode.RightCenter)
					{
						adjacencyCode3 = AdjacencyCode.CenterTop;
						if (Map.Get().InRange(num21 + 1, num20))
						{
							map.At(num21 + 1, num20).IsNextToDoor = adjacencyCode3;
						}
					}
					if (adjacencyCode3 == AdjacencyCode.Clear && Map.Get().InRange(point9) && map.At(point9).DoorSide == AdjacencyCode.CenterBottom)
					{
						adjacencyCode3 = AdjacencyCode.RightCenter;
						if (Map.Get().InRange(num21, num20 + 1))
						{
							map.At(num21, num20 + 1).IsNextToDoor = adjacencyCode3;
						}
					}
				}
				map.At(num21, num20).IsBehindDoor = adjacencyCode2;
				map.At(num21, num20).IsNextToDoor = adjacencyCode3;
			}
		}
		foreach (DeferredMiniTransition item3 in list)
		{
			Point cellPos = item3.cellPos;
			int x2 = cellPos.X;
			int y3 = cellPos.Y;
			Cell cell8 = map.CellMap[y3][x2];
			MapStyle style11 = Map.Get().Tags.GetStyle(mapStyles, cellPos);
			GameObject ceilingTransitionPrefab2 = style11.GetCeilingTransitionPrefab();
			float transitionHOffset2 = style11.transitionHOffset;
			float transHeight = style11.ceilingHeight - 1.0999999f;
			if (item3.transCode == AdjacencyCode.RightCenter && Cell.CheckAdjacencyClear(ceilingMiniTransitions[y3][x2], AdjacencyCode.RightCenter))
			{
				AddCeilingTransition(new Point(x2, y3), AdjacencyCode.RightCenter, ceilingTransitionPrefab2, transHeight, transitionHOffset2, 0f);
			}
			if (item3.transCode == AdjacencyCode.LeftCenter && Cell.CheckAdjacencyClear(ceilingMiniTransitions[y3][x2 - 1], AdjacencyCode.RightCenter))
			{
				AddCeilingTransition(new Point(x2, y3), AdjacencyCode.LeftCenter, ceilingTransitionPrefab2, transHeight, transitionHOffset2, 0f);
			}
			if (item3.transCode == AdjacencyCode.CenterTop && Cell.CheckAdjacencyClear(ceilingMiniTransitions[y3 - 1][x2], AdjacencyCode.CenterBottom))
			{
				AddCeilingTransition(new Point(x2, y3), AdjacencyCode.CenterTop, ceilingTransitionPrefab2, transHeight, transitionHOffset2, 0f);
			}
			if (item3.transCode == AdjacencyCode.CenterBottom && Cell.CheckAdjacencyClear(ceilingMiniTransitions[y3][x2], AdjacencyCode.CenterBottom))
			{
				AddCeilingTransition(new Point(x2, y3), AdjacencyCode.CenterBottom, ceilingTransitionPrefab2, transHeight, transitionHOffset2, 0f);
			}
		}
		list.Clear();
		ceilingMiniTransitions = null;
		Debug.Log("Time - Generate::Doors " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		Debug.Log("Time - Generate::Geometry Atlas " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		Debug.Log("MapBuilder - Adding props");
		indexGenericProps = ProcessPropPrefabs(genericProps, vector2);
		indexHorrorProps = ProcessPropPrefabs(horrorProps, vector2);
		indexLightProps = ProcessPropPrefabs(lightProps, vector2);
		indexTreasuryProps = ProcessPropPrefabs(treasuryProps, vector2);
		PlacedLightSafe = false;
		Dictionary<int, PropInfo> propGroups = new Dictionary<int, PropInfo>();
		Debug.Log("Time - Generate::ProcessPropPrefabs " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		List<GameObject> list4 = new List<GameObject>();
		System.Random random = new System.Random(UnityEngine.Random.seed);
		SWallInfo wallInfo = default(SWallInfo);
		foreach (RoomTemplate.PropMarker propPosition in map.PropPositions)
		{
			Point tile = propPosition.pos.ToPoint();
			Room room2 = map.CellMap[tile.Y][tile.X].Room;
			bool flag8 = false;
			int num22 = 0;
			while (!flag8 && num22 < reservedNoProp.Count)
			{
				if (propPosition.IsPositionInside(reservedNoProp[num22]))
				{
					flag8 = true;
				}
				num22++;
			}
			if (flag8)
			{
				continue;
			}
			wallInfo.bWallLeft = !map.CellMap[tile.Y][tile.X - 1].IsClearOrPit();
			wallInfo.bWallRight = !map.CellMap[tile.Y][tile.X + propPosition.width].IsClearOrPit();
			wallInfo.bWallUp = !map.CellMap[tile.Y - 1][tile.X].IsClearOrPit();
			wallInfo.bWallDown = !map.CellMap[tile.Y + propPosition.height][tile.X].IsClearOrPit();
			wallInfo.bHasWall = wallInfo.bWallLeft || wallInfo.bWallRight || wallInfo.bWallUp || wallInfo.bWallDown;
			bool bRotate = false;
			PropInfo propInfo;
			GameObject gameObject12 = SelectPropPrefab(propPosition, room2, wallInfo, out propInfo, out bRotate, propGroups);
			if (!gameObject12)
			{
				continue;
			}
			bool removeFloor = propInfo.removeFloor;
			bool removeCeiling = propInfo.removeCeiling;
			bool hanging = propInfo.hanging;
			bool ignoreWallMargin = propInfo.ignoreWallMargin;
			bool wallProp = propInfo.WallProp;
			Vector3 localPosition3 = new Vector3((float)tile.X * vector2.x, 0f, (float)(-tile.Y) * vector2.y);
			localPosition3 += new Vector3(vector2.x / 2f, 0f, (0f - vector2.y) / 2f);
			if (flag5 && !hanging && !wallProp && !ignoreWallMargin && !removeFloor && !propInfo.isRockColumnBottom)
			{
				MapStyle style12 = Map.Get().Tags.GetStyle(mapStyles, tile);
				if (style12.floorNoise)
				{
					localPosition3.y += 0.06f;
				}
			}
			Vector3 propDirection = GetPropDirection(propPosition, wallInfo);
			Vector3 zero = Vector3.zero;
			float num23 = 0f;
			float num24 = 0f;
			float num25 = 0f;
			float num26 = 0f;
			if (!ignoreWallMargin && (propPosition.width == 1 || propPosition.height == 1))
			{
				bool bWallLeft = wallInfo.bWallLeft;
				bool bWallRight = wallInfo.bWallRight;
				bool bWallUp = wallInfo.bWallUp;
				bool bWallDown = wallInfo.bWallDown;
				bool flag9 = !map.CellMap[tile.Y - 1][tile.X - 1].IsClearOrPit();
				bool flag10 = !map.CellMap[tile.Y - 1][tile.X + propPosition.width].IsClearOrPit();
				bool flag11 = !map.CellMap[tile.Y + propPosition.height][tile.X - 1].IsClearOrPit();
				bool flag12 = !map.CellMap[tile.Y + propPosition.height][tile.X + propPosition.width].IsClearOrPit();
				bool flag13 = wallInfo.GetNumWalls() >= 3;
				bool flag14 = !wallInfo.bWallLeft && map.CellMap[tile.Y][tile.X - 1].Occupied;
				bool flag15 = !wallInfo.bWallRight && map.CellMap[tile.Y][tile.X + 1].Occupied;
				bool flag16 = !wallInfo.bWallUp && map.CellMap[tile.Y - 1][tile.X].Occupied;
				bool flag17 = !wallInfo.bWallDown && map.CellMap[tile.Y + 1][tile.X].Occupied;
				if (bWallLeft)
				{
					bool flag18 = wallInfo.bWallLeft && (wallInfo.bWallUp || wallInfo.bWallDown);
					bool flag19 = (!flag9 || !flag11) && !flag13;
					bool flag20 = (!flag9 || !flag11) && flag13 && propPosition.height == 1;
					MapStyle style13 = Map.Get().Tags.GetStyle(mapStyles, tile);
					float num27 = style13.propMargin + ((!flag18) ? 0f : style13.propMarginInCorner);
					if (flag20 && !flag19 && !propInfo.ignoreOutCornerLatMargin)
					{
						num27 += style13.propMarginOutCornerLat;
					}
					if (flag15 && !bWallRight)
					{
						num27 *= 0.5f;
					}
					num23 += num27;
					num27 += ((!flag19) ? 0f : style13.propMarginOutCorner) * ((!flag15 || bWallRight) ? 1f : 0.5f);
					zero.x += num27;
				}
				else if (propInfo.notInNarrowDeadend && flag13)
				{
					zero.x += Map.Get().Tags.GetStyle(mapStyles, tile).propMargin;
				}
				if (bWallRight)
				{
					bool flag21 = wallInfo.bWallRight && (wallInfo.bWallUp || wallInfo.bWallDown);
					bool flag22 = (!flag10 || !flag12) && !flag13;
					bool flag23 = (!flag10 || !flag12) && flag13 && propPosition.height == 1;
					MapStyle style14 = Map.Get().Tags.GetStyle(mapStyles, new Point(tile.X + propPosition.width - 1, tile.Y));
					float num28 = style14.propMargin + ((!flag21) ? 0f : style14.propMarginInCorner);
					if (flag23 && !flag22 && !propInfo.ignoreOutCornerLatMargin)
					{
						num28 += style14.propMarginOutCornerLat;
					}
					if (flag14 && !bWallLeft)
					{
						num28 *= 0.5f;
					}
					num24 = num23 - num28;
					num23 += num28;
					num28 += ((!flag22) ? 0f : style14.propMarginOutCorner) * ((!flag14 || bWallLeft) ? 1f : 0.5f);
					zero.x -= num28;
				}
				else if (propInfo.notInNarrowDeadend && flag13)
				{
					zero.x -= Map.Get().Tags.GetStyle(mapStyles, tile).propMargin;
				}
				if (bWallUp)
				{
					bool flag24 = wallInfo.bWallUp && (wallInfo.bWallLeft || wallInfo.bWallRight);
					bool flag25 = (!flag9 || !flag10) && !flag13;
					bool flag26 = (!flag9 || !flag10) && flag13 && propPosition.width == 1;
					MapStyle style15 = Map.Get().Tags.GetStyle(mapStyles, tile);
					float num29 = style15.propMargin + ((!flag24) ? 0f : style15.propMarginInCorner);
					if (flag26 && !flag25 && !propInfo.ignoreOutCornerLatMargin)
					{
						num29 += style15.propMarginOutCornerLat;
					}
					if (flag17 && !bWallDown)
					{
						num29 *= 0.5f;
					}
					num25 += num29;
					num29 += ((!flag25) ? 0f : style15.propMarginOutCorner) * ((!flag17 || bWallDown) ? 1f : 0.5f);
					zero.z -= num29;
				}
				else if (propInfo.notInNarrowDeadend && flag13)
				{
					zero.z -= Map.Get().Tags.GetStyle(mapStyles, tile).propMargin;
				}
				if (bWallDown)
				{
					bool flag27 = wallInfo.bWallDown && (wallInfo.bWallLeft || wallInfo.bWallRight);
					bool flag28 = (!flag11 || !flag12) && !flag13;
					bool flag29 = (!flag11 || !flag12) && flag13 && propPosition.width == 1;
					MapStyle style16 = Map.Get().Tags.GetStyle(mapStyles, new Point(tile.X, tile.Y + propPosition.height - 1));
					float num30 = style16.propMargin + ((!flag27) ? 0f : style16.propMarginInCorner);
					if (flag29 && !flag28 && !propInfo.ignoreOutCornerLatMargin)
					{
						num30 += style16.propMarginOutCornerLat;
					}
					if (flag16 && !bWallUp)
					{
						num30 *= 0.5f;
					}
					num26 = num25 - num30;
					num25 += num30;
					num30 += ((!flag28) ? 0f : style16.propMarginOutCorner) * ((!flag16 || bWallUp) ? 1f : 0.5f);
					zero.z += num30;
				}
				else if (propInfo.notInNarrowDeadend && flag13)
				{
					zero.z += Map.Get().Tags.GetStyle(mapStyles, tile).propMargin;
				}
				zero *= propInfo.wallMarginFactor;
				num23 *= propInfo.wallMarginFactor;
				num25 *= propInfo.wallMarginFactor;
				num24 *= propInfo.wallMarginFactor;
				num26 *= propInfo.wallMarginFactor;
				if ((bWallLeft && bWallRight) || (bWallLeft && flag15) || (bWallRight && flag14))
				{
					float num31 = num23;
					num23 = (1.5f * (float)propPosition.width - num23) / (1.5f * (float)propPosition.width);
					num23 = (1f + num23) / 2f;
				}
				else
				{
					num23 = (num24 = 0f);
				}
				if ((bWallDown && bWallUp) || (bWallDown && flag16) || (bWallUp && flag17))
				{
					float num32 = num25;
					num25 = (1.5f * (float)propPosition.height - num25) / (1.5f * (float)propPosition.height);
					num25 = (1f + num25) / 2f;
				}
				else
				{
					num25 = (num26 = 0f);
				}
			}
			AdjacencyCode adjacencyCode4 = AdjacencyCode.Clear;
			for (int num33 = propPosition.pos.Y; num33 < propPosition.pos.Y + propPosition.height; num33++)
			{
				for (int num34 = propPosition.pos.X; num34 < propPosition.pos.X + propPosition.width; num34++)
				{
					if (map.CellMap[num33][num34].IsNextToDoor != 0)
					{
						adjacencyCode4 |= map.CellMap[num33][num34].IsNextToDoor;
					}
				}
			}
			if (adjacencyCode4 != 0)
			{
				if ((adjacencyCode4 & AdjacencyCode.LeftCenter) != 0)
				{
					zero.x = Mathf.Max(zero.x, -0.22f);
				}
				if ((adjacencyCode4 & AdjacencyCode.RightCenter) != 0)
				{
					zero.x = Mathf.Min(zero.x, 0.22f);
				}
				if ((adjacencyCode4 & AdjacencyCode.CenterTop) != 0)
				{
					zero.z = Mathf.Min(zero.z, 0.22f);
				}
				if ((adjacencyCode4 & AdjacencyCode.CenterBottom) != 0)
				{
					zero.z = Mathf.Max(zero.z, -0.22f);
				}
			}
			bool skipIfInCorner = false;
			float latFactor = 1f;
			float pushOutCornerDelta = propInfo.GetPushOutCornerDelta(Map.Get().Tags.GetStyle(mapStyles, tile).styleName, out skipIfInCorner, out latFactor);
			if (wallInfo.IsInCorner())
			{
				if (skipIfInCorner)
				{
					continue;
				}
			}
			else
			{
				latFactor = 1f;
			}
			if (propInfo.applyLateralMargins)
			{
				float num35 = Vector3.Dot(zero, propDirection);
				zero -= num35 * propDirection;
				zero *= latFactor;
			}
			if ((pushOutCornerDelta > 0.001f || pushOutCornerDelta < 0.001f) && wallInfo.GetNumWalls() < 3)
			{
				bool flag30 = !map.CellMap[tile.Y - 1][tile.X - 1].IsClearOrPit();
				bool flag31 = !map.CellMap[tile.Y - 1][tile.X + propPosition.width].IsClearOrPit();
				bool flag32 = !map.CellMap[tile.Y + propPosition.height][tile.X - 1].IsClearOrPit();
				bool flag33 = !map.CellMap[tile.Y + propPosition.height][tile.X + propPosition.width].IsClearOrPit();
				if (propDirection.x >= 0.9f && wallInfo.bWallLeft && (!flag30 || !flag32))
				{
					zero.x += pushOutCornerDelta;
				}
				else if (propDirection.x <= -0.9f && wallInfo.bWallRight && (!flag31 || !flag33))
				{
					zero.x -= pushOutCornerDelta;
				}
				else if (propDirection.z <= -0.9f && wallInfo.bWallUp && (!flag30 || !flag31))
				{
					zero.z -= pushOutCornerDelta;
				}
				else if (propDirection.z >= 0.9f && wallInfo.bWallDown && (!flag32 || !flag33))
				{
					zero.z += pushOutCornerDelta;
				}
			}
			GameObject gameObject13 = UnityEngine.Object.Instantiate(gameObject12);
			gameObject13.name = gameObject12.name + "_" + room2.props.Count;
			if (propPosition.width == 1 && propPosition.height == 1)
			{
				gameObject13.transform.rotation = Quaternion.LookRotation(propDirection) * Quaternion.AngleAxis(-90f, Vector3.up);
				if (wallProp)
				{
					Vector3 wallDecoDeltaVector = propInfo.GetWallDecoDeltaVector(Map.Get().Tags.GetStyle(mapStyles, tile).styleName);
					wallDecoDeltaVector = Quaternion.LookRotation(propDirection) * Quaternion.AngleAxis(180f, Vector3.up) * wallDecoDeltaVector;
					zero += wallDecoDeltaVector;
				}
			}
			else
			{
				if (bRotate)
				{
					gameObject13.transform.rotation = Quaternion.AngleAxis(90f, Vector3.up);
					if (propInfo.SizeX > 1 && propInfo.SizeY > 1)
					{
						int num36 = propInfo.SizeY - 1;
						localPosition3 += Vector3.right * vector2.x * num36;
					}
				}
				bool flag34 = propPosition.width >= propPosition.height;
				bool flag35 = propPosition.direction != 0 && propPosition.direction != RoomTemplate.PropMarker.Direction.Down && propPosition.direction != RoomTemplate.PropMarker.Direction.Left;
				if (((flag34 && wallInfo.bWallDown) || (!flag34 && wallInfo.bWallLeft) || flag35) && propPosition.width != propPosition.height && (propPosition.width == 1 || propPosition.height == 1))
				{
					int num37 = ((!flag34) ? (propPosition.height - 1) : (propPosition.width - 1));
					gameObject13.transform.rotation *= Quaternion.AngleAxis(180f, Vector3.up);
					localPosition3 += -gameObject13.transform.right * vector2.x * num37;
				}
			}
			if (hanging)
			{
				MapStyle style17 = Map.Get().Tags.GetStyle(mapStyles, propPosition.pos.ToPoint());
				localPosition3.y = style17.ceilingHeight + style17.hangingOffset;
			}
			localPosition3 += zero;
			localPosition3.x += propPosition.deltaOffset.x;
			localPosition3.z -= propPosition.deltaOffset.y;
			if (gameObject13.layer == (int)propLayer)
			{
				gameObject13.transform.parent = gameObject.transform;
			}
			else
			{
				gameObject13.transform.parent = mapGeometry.transform;
			}
			gameObject13.transform.localPosition = localPosition3;
			bool flag36 = propInfo.SizeX == 1 && propInfo.SizeY == 1;
			if (propInfo.squeeze && num23 > 0f)
			{
				gameObject13.transform.localScale = new Vector3(gameObject13.transform.localScale.x * ((!flag36) ? num23 : 1f), gameObject13.transform.localScale.y, gameObject13.transform.localScale.z * ((!flag36) ? 1f : num23));
				if (!flag36)
				{
					Vector3 vector3 = gameObject13.transform.TransformDirection(Vector3.right);
					gameObject13.transform.localPosition += vector3 * (1.5f - 1.5f * num23) / 2f;
					gameObject13.transform.localPosition -= vector3 * num24 * num23 * 0.5f;
				}
			}
			if (propInfo.squeeze && num25 > 0f)
			{
				gameObject13.transform.localScale = new Vector3(gameObject13.transform.localScale.x * ((!flag36) ? num25 : 1f), gameObject13.transform.localScale.y, gameObject13.transform.localScale.z * ((!flag36) ? 1f : num25));
				if (!flag36)
				{
					Vector3 vector4 = gameObject13.transform.TransformDirection(Vector3.right);
					gameObject13.transform.localPosition += vector4 * (1.5f - 1.5f * num25) / 2f;
					gameObject13.transform.localPosition -= vector4 * num26 * num25 * 0.5f;
				}
			}
			PropInfo component2 = gameObject13.GetComponent<PropInfo>();
			room2.props.Add(component2);
			if (component2.castsLight)
			{
				room2.numLightcasters++;
			}
			if (component2.isGargoyle)
			{
				room2.gargoyles.Add(gameObject13);
			}
			if (component2.keepFrontClear || component2.isGargoyle)
			{
				Point item = map.WorldToCell(gameObject13.transform.position + propDirection * 1.5f);
				reservedNoProp.Add(item);
			}
			if (component2.makeRoomSafe)
			{
				room2.Safe = true;
			}
			if (component2.maxInMap > 0)
			{
				int value = 0;
				propCount.TryGetValue(gameObject12, out value);
				propCount[gameObject12] = value + 1;
			}
			if (component2.addVerticalOffset)
			{
				float y4 = (float)(random.NextDouble() * 0.025);
				gameObject13.transform.localPosition += new Vector3(0f, y4, 0f);
			}
			list4.Add(gameObject13);
			MapChunk.AddGeometry(gameObject13, propPosition.pos.ToPoint(), propPosition.width, propPosition.height, cullMask);
			if (gameObject13.layer == (int)propLayer)
			{
				StripNonStatic(gameObject13.transform, mapGeometry.transform);
			}
			if (removeFloor || removeCeiling)
			{
				for (int num38 = propPosition.pos.Y; num38 < propPosition.pos.Y + propPosition.height; num38++)
				{
					for (int num39 = propPosition.pos.X; num39 < propPosition.pos.X + propPosition.width; num39++)
					{
						MapChunk mapChunk3 = MapChunk.At(num39, num38);
						if (removeFloor && array4[num38][num39] != null)
						{
							mapChunk3.RemoveGeometry(array4[num38][num39], removeFromCombineList: true);
							UnityEngine.Object.Destroy(array4[num38][num39]);
							array4[num38][num39] = null;
						}
						if (removeCeiling && array3[num38][num39] != null)
						{
							mapChunk3.RemoveGeometry(array3[num38][num39], removeFromCombineList: true);
							UnityEngine.Object.Destroy(array3[num38][num39]);
							array3[num38][num39] = null;
						}
					}
				}
			}
			if (propInfo.canWalkThrough)
			{
				for (int num40 = propPosition.pos.Y; num40 < propPosition.pos.Y + propPosition.height; num40++)
				{
					for (int num41 = propPosition.pos.X; num41 < propPosition.pos.X + propPosition.width; num41++)
					{
						Map.Get().At(num41, num40).Occupied = !Map.Get().At(num41, num40).IsClear();
					}
				}
			}
			if (propInfo.canFloatOver)
			{
				for (int num42 = propPosition.pos.Y; num42 < propPosition.pos.Y + propPosition.height; num42++)
				{
					for (int num43 = propPosition.pos.X; num43 < propPosition.pos.X + propPosition.width; num43++)
					{
						Map.Get().At(num43, num42).CanFloatOver = true;
					}
				}
			}
			gameObject13.GetComponent<PropInfo>().PropMarker = propPosition;
		}
		Debug.Log("Time - Generate::Props " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		Debug.Log("Time - Generate::Props Atlas " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		for (int num44 = 0; num44 < width; num44++)
		{
			for (int num45 = 0; num45 < height; num45++)
			{
				Cell cell9 = map.CellMap[num45][num44];
				if (cell9.IsClear() && ((!cell9.Occupied && cell9.IsClear()) || cell9.IsCorridor()) && (cell9.Room == null || !cell9.Room.Safe) && UnityEngine.Random.value < 0.2f && !(map.CellMap[num45][num44 - 1].Door != null) && !(map.CellMap[num45][num44 + 1].Door != null) && !(map.CellMap[num45 - 1][num44].Door != null) && !(map.CellMap[num45 + 1][num44].Door != null))
				{
					GameObject gameObject14 = UnityEngine.Object.Instantiate(ghostSpawnPrefab);
					gameObject14.name = "spawn_" + num44 + "_" + num45;
					gameObject14.transform.parent = ghostSpawns.transform;
					Vector3 localPosition4 = new Vector3((float)num44 * vector2.x, 0f, (float)(-num45) * vector2.y);
					localPosition4 += new Vector3(vector2.x / 2f, 0f, (0f - vector2.y) / 2f);
					gameObject14.transform.localPosition = localPosition4;
					cell9.Spawn = gameObject14.GetComponent<VisibilityProbe>();
				}
			}
		}
		Debug.Log("Time - Generate::Spawners " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		realtimeSinceStartup = Time.realtimeSinceStartup;
		if (flag5)
		{
			FloorNoise.AddFloorNoise(map, array4, this);
		}
		if (flag6)
		{
			FloorNoise.AddCeilingNoise(map, array3, this);
		}
		for (int num46 = 0; num46 < edgeCollapses.Count; num46++)
		{
			Vector3 vector5 = map.CellToWorld(edgeCollapses[num46].tile);
			List<MeshFilter> toCombine = MapChunk.At(edgeCollapses[num46].tile).toCombine;
			for (int num47 = 0; num47 < toCombine.Count; num47++)
			{
				MeshFilter meshFilter = toCombine[num47];
				float sqrMagnitude = (meshFilter.transform.position - vector5).sqrMagnitude;
				if (sqrMagnitude <= 0.5625f && Utils.IsAncestor(toCombine[num47].transform, wallContainer.transform))
				{
					FloorNoise.CollapseEdge(meshFilter, edgeCollapses[num46].edge);
				}
			}
			Debug.DrawLine(edgeCollapses[num46].edge, edgeCollapses[num46].edge + Vector3.up * 3f, Color.red, 5f);
			Vector3 vector6 = map.CellToWorld(edgeCollapses[num46].tile);
			Debug.DrawLine(vector6, vector6 + Vector3.up, Color.red, 5f);
		}
		Debug.Log("MapBuilder - Combining static meshes");
		ChunkMesh.BuildMeshes(gameObject);
		StaticBatchingUtility.Combine(gameObject);
		tempWallList = null;
		Debug.Log("Time - Generate::Combine geometry " + (Time.realtimeSinceStartup - realtimeSinceStartup).ToString("F2"));
		for (int num48 = 0; num48 < map.Rooms.Count; num48++)
		{
			map.Rooms[num48].BuildValidPosLists();
		}
		realtimeSinceStartup = Time.realtimeSinceStartup;
		Debug.Log("MapBuilder - Positioning player");
		GameObject gameObject15 = Player.Get();
		if ((bool)gameObject15 && positionPlayer)
		{
			gameObject15.transform.position = vector;
			Point pos = Map.Get().WorldToCell(vector);
			Room room3 = Map.Get().At(pos).Room;
			if (room3 != null && (room3.doors.Count > 0 || room3.entrances.Count > 0))
			{
				Point cellPos2 = ((room3.doors.Count <= 0) ? room3.entrances[0] : room3.doors[0]);
				Vector3 vec = (Map.Get().CellToWorld(cellPos2) - vector).GroundNormalize();
				gameObject15.transform.rotation = Quaternion.LookRotation(vec.MajorAxis(), Vector3.up);
			}
			else
			{
				bool flag37 = !Map.Get().At(pos.X - 1, pos.Y).IsClear() || !Map.Get().At(pos.X - 2, pos.Y).IsClear();
				bool flag38 = !Map.Get().At(pos.X + 1, pos.Y).IsClear() || !Map.Get().At(pos.X + 2, pos.Y).IsClear();
				bool flag39 = !Map.Get().At(pos.X, pos.Y - 1).IsClear() || !Map.Get().At(pos.X, pos.Y - 2).IsClear();
				bool flag40 = !Map.Get().At(pos.X, pos.Y + 1).IsClear() || !Map.Get().At(pos.X, pos.Y + 2).IsClear();
				if (!flag37 || !flag38 || !flag39 || !flag40)
				{
					Vector3 forward = Vector3.right;
					if (!flag37)
					{
						forward = new Vector3(-1f, 0f, 0f);
					}
					else if (!flag38)
					{
						forward = new Vector3(1f, 0f, 0f);
					}
					else if (!flag39)
					{
						forward = new Vector3(0f, 0f, 1f);
					}
					else if (!flag40)
					{
						forward = new Vector3(0f, 0f, -1f);
					}
					gameObject15.transform.rotation = Quaternion.LookRotation(forward, Vector3.up);
				}
			}
		}
		Debug.Log("MapBuilder - Map succesfully generated");
		GC.Collect();
		return mapGeometry;
	}

	private GameObject SelectPropPrefab(RoomTemplate.PropMarker prop, Room room, SWallInfo wallInfo, out PropInfo propInfo, out bool bRotate, Dictionary<int, PropInfo> propGroups)
	{
		GameObject gameObject = null;
		GameObject gameObject2 = null;
		propInfo = null;
		bRotate = false;
		if (prop.exitMarker == OptionFlag.Yes)
		{
			gameObject = ((!(levelOptions.exitPrefab != null)) ? exitPrefab : levelOptions.exitPrefab);
			propInfo = gameObject.GetComponent<PropInfo>();
			gameObject2 = gameObject;
		}
		else if (prop.exitCollectable == OptionFlag.Yes)
		{
			gameObject = levelOptions.exitCollectablePrefab;
			if (!gameObject)
			{
				return null;
			}
			propInfo = gameObject.GetComponent<PropInfo>();
			gameObject2 = gameObject;
		}
		else if (prop.propInfo != null)
		{
			gameObject = prop.propInfo.gameObject;
			propInfo = gameObject.GetComponent<PropInfo>();
			if (new Point(Mathf.Max(prop.width, prop.height), Mathf.Min(prop.width, prop.height)).X != prop.width)
			{
				bRotate = true;
			}
			gameObject2 = gameObject;
			if (propInfo.minCeilingHeight > 0.5f && propInfo.minCeilingHeight > Map.Get().Tags.GetStyle(mapStyles, prop.pos.ToPoint()).ceilingHeight)
			{
				return null;
			}
		}
		else
		{
			Point key = new Point(Mathf.Max(prop.width, prop.height), Mathf.Min(prop.width, prop.height));
			int num = 7;
			if (room.IsDeadEnd && !room.IsSpawnRoom && !room.IsExitRoom)
			{
				num = 15;
			}
			for (int i = 0; i < num; i++)
			{
				bool flag = false;
				float value = UnityEngine.Random.value;
				Dictionary<Point, List<GameObject>> dictionary;
				if (room != null && room.Safe)
				{
					bool flag2 = prop.lightCaster != OptionFlag.No;
					flag2 &= room.numLightcasters <= room.Template.flags.maxLightcasters;
					if (PlacedLightSafe || !flag2 || !flag2)
					{
						dictionary = (((!(value < 0.1f) || !flag2) && prop.lightCaster != OptionFlag.Yes) ? indexGenericProps : indexLightProps);
					}
					else
					{
						dictionary = indexLightProps;
						flag = true;
					}
				}
				else
				{
					float num2 = 0.03f;
					float num3 = 0.4f;
					bool flag3 = false;
					if (room.IsDeadEnd && (room.Template.size == RoomTemplate.SizeType.Small || room.Template.size == RoomTemplate.SizeType.Medium) && !room.IsSpawnRoom && !room.IsExitRoom)
					{
						num3 = 0.2f;
						flag3 = true;
					}
					bool flag4 = prop.lightCaster != OptionFlag.No;
					flag4 &= room.numLightcasters <= room.Template.flags.maxLightcasters;
					dictionary = ((flag3 && value <= 0.4f) ? indexTreasuryProps : (((!(value < num2) || !flag4) && prop.lightCaster != OptionFlag.Yes) ? (((!(value <= num3) || prop.horror == OptionFlag.No) && prop.horror != OptionFlag.Yes) ? indexGenericProps : indexHorrorProps) : indexLightProps));
				}
				if (!dictionary.ContainsKey(key))
				{
					continue;
				}
				List<GameObject> list = dictionary[key];
				gameObject = list[UnityEngine.Random.Range(0, list.Count)];
				propInfo = gameObject.GetComponent<PropInfo>();
				if (prop.groupIndex != -1)
				{
					int key2 = room.Id * 1000 + prop.groupIndex;
					PropInfo value2 = null;
					if (propGroups.TryGetValue(key2, out value2))
					{
						propInfo = value2;
						gameObject = propInfo.gameObject;
					}
					else
					{
						propGroups.Add(key2, propInfo);
					}
				}
				if ((bool)propInfo)
				{
					MapStyle style = Map.Get().Tags.GetStyle(mapStyles, prop.pos.ToPoint());
					if (propInfo.disabledProp || (propInfo.WallProp && !wallInfo.bHasWall) || (propInfo.WallProp && prop.wallProp == OptionFlag.No) || (propInfo.standAlone && wallInfo.bHasWall))
					{
						continue;
					}
					if (key.X != prop.width)
					{
						bRotate = true;
					}
					if ((propInfo.isGargoyle && !levelOptions.gargoyles) || (propInfo.isGargoyle && room.IsExitRoom) || (!propInfo.canPlaceInSpawnRoom && room.IsSpawnRoom))
					{
						continue;
					}
					if (propInfo.notBehindDoor)
					{
						Point point = new Point(prop.pos.X - 1, prop.pos.Y + 1);
						Point point2 = new Point(prop.pos.X + 1, prop.pos.Y + 1);
						Point point3 = new Point(prop.pos.X - 1, prop.pos.Y - 1);
						Point point4 = new Point(prop.pos.X + 1, prop.pos.Y - 1);
						bool flag5 = false;
						if (!flag5 && Map.Get().InRange(point))
						{
							flag5 = Map.Get().At(point).Door != null;
						}
						if (!flag5 && Map.Get().InRange(point2))
						{
							flag5 = Map.Get().At(point2).Door != null;
						}
						if (!flag5 && Map.Get().InRange(point3))
						{
							flag5 = Map.Get().At(point3).Door != null;
						}
						if (!flag5 && Map.Get().InRange(point4))
						{
							flag5 = Map.Get().At(point4).Door != null;
						}
						if (!flag5)
						{
							Point exitPosition = Map.Get().ExitPosition;
							flag5 = exitPosition == new Point(prop.pos.X - 1, prop.pos.Y) || exitPosition == new Point(prop.pos.X + 1, prop.pos.Y) || exitPosition == new Point(prop.pos.X, prop.pos.Y - 1) || exitPosition == new Point(prop.pos.X, prop.pos.Y + 1);
						}
						if (flag5)
						{
							continue;
						}
					}
					if (propInfo.WallProp && !style.allowWallPropsInCorners)
					{
						Cell cell = Map.Get().At(prop.pos.ToPoint());
						if (cell.GetNumAdjacentWallsNoCorners() > 1)
						{
							continue;
						}
					}
					if (wallInfo.bHasWall)
					{
						int wallSkipMax = propInfo.GetWallSkipMax(style.styleName);
						if (wallSkipMax >= 0 && wallInfo.GetNumWalls() > wallSkipMax)
						{
							continue;
						}
					}
					if (propInfo.minCeilingHeight > 0.5f && propInfo.minCeilingHeight > style.ceilingHeight)
					{
						continue;
					}
					if (propInfo.notInDeadend || propInfo.notInNarrowDeadend || propInfo.requireHighCeiling)
					{
						Cell cell2 = Map.Get().At(prop.pos.ToPoint());
						if (cell2.GetNumAdjacentWallsNoCorners() == 3 && (propInfo.notInDeadend || (propInfo.notInNarrowDeadend && style.hasNarrowDeadends) || (propInfo.requireHighCeiling && style.arched && style.ceilingHeight <= 3.5f)))
						{
							continue;
						}
						if ((propInfo.notInNarrowDeadend || propInfo.requireHighCeiling) && style.arched)
						{
							bool flag6 = cell2.CheckAdjacency(AdjacencyCode.LeftCenter) && cell2.CheckAdjacency(AdjacencyCode.RightCenter);
							flag6 |= cell2.CheckAdjacency(AdjacencyCode.CenterTop) && cell2.CheckAdjacency(AdjacencyCode.CenterBottom);
							flag6 |= cell2.CheckAdjacency(AdjacencyCode.LeftCenter) && cell2.CheckAdjacency(AdjacencyCode.CenterTop) && cell2.CheckAdjacency(AdjacencyCode.RightBottom);
							flag6 |= cell2.CheckAdjacency(AdjacencyCode.CenterTop) && cell2.CheckAdjacency(AdjacencyCode.RightCenter) && cell2.CheckAdjacency(AdjacencyCode.LeftBottom);
							flag6 |= cell2.CheckAdjacency(AdjacencyCode.LeftTop) && cell2.CheckAdjacency(AdjacencyCode.RightCenter) && cell2.CheckAdjacency(AdjacencyCode.CenterBottom);
							if (flag6 | (cell2.CheckAdjacency(AdjacencyCode.LeftCenter) && cell2.CheckAdjacency(AdjacencyCode.RightTop) && cell2.CheckAdjacency(AdjacencyCode.CenterBottom)))
							{
								continue;
							}
						}
					}
					if ((propInfo.notInHubInCorner && room.Template.size == RoomTemplate.SizeType.Hub && Map.Get().At(prop.pos.ToPoint()).GetNumAdjacentWallsNoCorners() > 1) || (propInfo.hanging && Map.Get().At(prop.pos.ToPoint()).CeilingShaft) || (propInfo.isRockColumnBottom && !style.allowRockColumnsBottom) || (propInfo.isRockColumnTop && !style.allowRockColumnsTop))
					{
						continue;
					}
					if (propInfo.maxInRoom > 0)
					{
						int num4 = 0;
						for (int j = 0; j < room.props.Count; j++)
						{
							if (propInfo.name == room.props[j].name)
							{
								num4++;
							}
						}
						if (num4 >= propInfo.maxInRoom)
						{
							continue;
						}
					}
					if (propInfo.maxInMap > 0)
					{
						int value3 = 0;
						propCount.TryGetValue(gameObject, out value3);
						if (value3 >= propInfo.maxInMap)
						{
							continue;
						}
					}
					if ((propInfo.requireStyleTag != string.Empty && style.GetMainTag() != propInfo.requireStyleTag) || (propInfo.disableInRandomMode && levelOptions.isRandomMode) || (!propInfo.roomSmall && room != null && room.Template.size == RoomTemplate.SizeType.Small) || (!propInfo.roomMedium && room != null && room.Template.size == RoomTemplate.SizeType.Medium) || (!propInfo.roomLarge && room != null && room.Template.size == RoomTemplate.SizeType.Large) || (!propInfo.roomHub && room != null && room.Template.size == RoomTemplate.SizeType.Hub))
					{
						continue;
					}
					if (propInfo.marginTop != 0 || propInfo.marginBottom != 0 || propInfo.marginLeft != 0 || propInfo.marginRight != 0)
					{
						RoomTemplate.PropMarker.Direction direction = ResolvePropDirection(prop, wallInfo);
						SPropMargins sPropMargins = default(SPropMargins);
						if (propInfo.SizeX == propInfo.SizeY && propInfo.SizeX == 1)
						{
							switch (direction)
							{
							case RoomTemplate.PropMarker.Direction.Right:
								sPropMargins = new SPropMargins(propInfo.marginLeft, propInfo.marginTop, propInfo.marginRight, propInfo.marginBottom);
								break;
							case RoomTemplate.PropMarker.Direction.Left:
								sPropMargins = new SPropMargins(propInfo.marginRight, propInfo.marginBottom, propInfo.marginLeft, propInfo.marginTop);
								break;
							case RoomTemplate.PropMarker.Direction.Down:
								sPropMargins = new SPropMargins(propInfo.marginBottom, propInfo.marginLeft, propInfo.marginTop, propInfo.marginRight);
								break;
							case RoomTemplate.PropMarker.Direction.Up:
								sPropMargins = new SPropMargins(propInfo.marginTop, propInfo.marginRight, propInfo.marginBottom, propInfo.marginLeft);
								break;
							}
						}
						else
						{
							switch (direction)
							{
							case RoomTemplate.PropMarker.Direction.Right:
								sPropMargins = new SPropMargins(propInfo.marginBottom, propInfo.marginLeft, propInfo.marginTop, propInfo.marginRight);
								break;
							case RoomTemplate.PropMarker.Direction.Left:
								sPropMargins = new SPropMargins(propInfo.marginTop, propInfo.marginRight, propInfo.marginBottom, propInfo.marginTop);
								break;
							case RoomTemplate.PropMarker.Direction.Down:
								sPropMargins = new SPropMargins(propInfo.marginRight, propInfo.marginBottom, propInfo.marginLeft, propInfo.marginTop);
								break;
							case RoomTemplate.PropMarker.Direction.Up:
								sPropMargins = new SPropMargins(propInfo.marginLeft, propInfo.marginTop, propInfo.marginRight, propInfo.marginBottom);
								break;
							}
						}
						bool flag7 = true;
						int num5 = -sPropMargins.marginTop;
						while (flag7 && num5 < prop.height + sPropMargins.marginBottom)
						{
							int num6 = -sPropMargins.marginLeft;
							while (flag7 && num6 < prop.width + sPropMargins.marginRight)
							{
								if (num6 < 0 || num6 >= prop.width || num5 < 0 || num5 >= prop.height)
								{
									Cell cell3 = map.At(prop.pos.X + num6, prop.pos.Y + num5);
									if (cell3 == null)
									{
										flag7 = false;
									}
									else if (!cell3.IsTransparent())
									{
										flag7 = false;
									}
								}
								num6++;
							}
							num5++;
						}
						if (!flag7)
						{
							continue;
						}
					}
					gameObject2 = gameObject;
				}
				if (flag)
				{
					PlacedLightSafe = true;
				}
				break;
			}
		}
		if (!gameObject2)
		{
			Debug.Log("Could not find a proper prop for (" + prop.width + ", " + prop.height + ")");
		}
		return gameObject2;
	}

	private Vector3 GetPropDirection(RoomTemplate.PropMarker prop, SWallInfo wallInfo)
	{
		RoomTemplate.PropMarker.Direction direction = ResolvePropDirection(prop, wallInfo);
		Vector3 result = new Vector3(0f, 0f, 1f);
		switch (direction)
		{
		case RoomTemplate.PropMarker.Direction.Down:
			result = new Vector3(0f, 0f, -1f);
			break;
		case RoomTemplate.PropMarker.Direction.Up:
			result = new Vector3(0f, 0f, 1f);
			break;
		case RoomTemplate.PropMarker.Direction.Right:
			result = new Vector3(1f, 0f, 0f);
			break;
		case RoomTemplate.PropMarker.Direction.Left:
			result = new Vector3(-1f, 0f, 0f);
			break;
		}
		return result;
	}

	private RoomTemplate.PropMarker.Direction ResolvePropDirection(RoomTemplate.PropMarker prop, SWallInfo wallInfo)
	{
		RoomTemplate.PropMarker.Direction direction = prop.direction;
		if (direction == RoomTemplate.PropMarker.Direction.Auto)
		{
			direction = ((wallInfo.bWallLeft && !wallInfo.bWallRight) ? RoomTemplate.PropMarker.Direction.Right : ((!wallInfo.bWallLeft && wallInfo.bWallRight) ? RoomTemplate.PropMarker.Direction.Left : ((!wallInfo.bWallUp || wallInfo.bWallDown) ? RoomTemplate.PropMarker.Direction.Up : RoomTemplate.PropMarker.Direction.Down)));
		}
		return direction;
	}

	private void BuildWalls(int x, int z, byte adjacency, MapStyle curStyle, MapChunk chunk, int variation, float fTileSize, string prefix = "WallSection", float yOffset = 0f, List<GameObject> listWalls = null)
	{
		listWalls?.Clear();
		if (Cell.CheckAdjacency(adjacency, AdjacencyCode.LeftCenter) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)66))
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(curStyle.lWallPrefabs[variation], Vector3.zero, Quaternion.identity);
			gameObject.name = prefix + "_lw_" + x + "_" + z;
			gameObject.transform.parent = wallContainer.transform;
			gameObject.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject.transform.localRotation = rotLWallLeft;
			gameObject.layer = geometryLayer;
			gameObject.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject);
			StripNonStatic(gameObject.transform, mapGeometry.transform);
			listWalls?.Add(gameObject);
		}
		if (Cell.CheckAdjacency(adjacency, AdjacencyCode.RightCenter) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)66))
		{
			GameObject gameObject2 = UnityEngine.Object.Instantiate(curStyle.lWallPrefabs[variation], Vector3.zero, Quaternion.identity);
			gameObject2.name = prefix + "_rw_" + x + "_" + z;
			gameObject2.transform.parent = wallContainer.transform;
			gameObject2.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject2.transform.localRotation = rotLWallRight;
			gameObject2.layer = geometryLayer;
			gameObject2.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject2);
			StripNonStatic(gameObject2.transform, mapGeometry.transform);
			listWalls?.Add(gameObject2);
		}
		if (Cell.CheckAdjacency(adjacency, AdjacencyCode.CenterTop) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)24))
		{
			GameObject gameObject3 = UnityEngine.Object.Instantiate(curStyle.lWallPrefabs[variation], Vector3.zero, Quaternion.identity);
			gameObject3.name = prefix + "_tw_" + x + "_" + z;
			gameObject3.transform.parent = wallContainer.transform;
			gameObject3.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject3.transform.localRotation = rotLWallTop;
			gameObject3.layer = geometryLayer;
			gameObject3.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject3);
			StripNonStatic(gameObject3.transform, mapGeometry.transform);
			listWalls?.Add(gameObject3);
		}
		if (Cell.CheckAdjacency(adjacency, AdjacencyCode.CenterBottom) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)24))
		{
			GameObject gameObject4 = UnityEngine.Object.Instantiate(curStyle.lWallPrefabs[variation], Vector3.zero, Quaternion.identity);
			gameObject4.name = prefix + "_bw_" + x + "_" + z;
			gameObject4.transform.parent = wallContainer.transform;
			gameObject4.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject4.transform.localRotation = rotLWallBottom;
			gameObject4.layer = geometryLayer;
			gameObject4.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject4);
			StripNonStatic(gameObject4.transform, mapGeometry.transform);
			listWalls?.Add(gameObject4);
		}
		if (Cell.CheckAdjacency(adjacency, (AdjacencyCode)10) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)80))
		{
			GameObject gameObject5 = UnityEngine.Object.Instantiate(curStyle.inCornerPrefab, Vector3.zero, Quaternion.identity);
			gameObject5.name = prefix + "_ic_lt_" + x + "_" + z;
			gameObject5.transform.parent = wallContainer.transform;
			gameObject5.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject5.transform.localRotation = rotInCornerLeftTop;
			gameObject5.layer = geometryLayer;
			gameObject5.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject5);
			StripNonStatic(gameObject5.transform, mapGeometry.transform);
			listWalls?.Add(gameObject5);
		}
		if (Cell.CheckAdjacency(adjacency, (AdjacencyCode)18) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)72))
		{
			GameObject gameObject6 = UnityEngine.Object.Instantiate(curStyle.inCornerPrefab, Vector3.zero, Quaternion.identity);
			gameObject6.name = prefix + "_ic_rt_" + x + "_" + z;
			gameObject6.transform.parent = wallContainer.transform;
			gameObject6.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject6.transform.localRotation = rotInCornerRightTop;
			gameObject6.layer = geometryLayer;
			gameObject6.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject6);
			StripNonStatic(gameObject6.transform, mapGeometry.transform);
			listWalls?.Add(gameObject6);
		}
		if (Cell.CheckAdjacency(adjacency, (AdjacencyCode)72) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)18))
		{
			GameObject gameObject7 = UnityEngine.Object.Instantiate(curStyle.inCornerPrefab, Vector3.zero, Quaternion.identity);
			gameObject7.name = prefix + "_ic_lb_" + x + "_" + z;
			gameObject7.transform.parent = wallContainer.transform;
			gameObject7.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject7.transform.localRotation = rotInCornerLeftBottom;
			gameObject7.layer = geometryLayer;
			gameObject7.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject7);
			StripNonStatic(gameObject7.transform, mapGeometry.transform);
			listWalls?.Add(gameObject7);
		}
		if (Cell.CheckAdjacency(adjacency, (AdjacencyCode)80) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)10))
		{
			GameObject gameObject8 = UnityEngine.Object.Instantiate(curStyle.inCornerPrefab, Vector3.zero, Quaternion.identity);
			gameObject8.name = prefix + "_ic_rb_" + x + "_" + z;
			gameObject8.transform.parent = wallContainer.transform;
			gameObject8.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject8.transform.localRotation = rotInCornerRightBottom;
			gameObject8.layer = geometryLayer;
			gameObject8.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject8);
			StripNonStatic(gameObject8.transform, mapGeometry.transform);
			listWalls?.Add(gameObject8);
		}
		if (Cell.CheckAdjacency(adjacency, AdjacencyCode.LeftTop) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)10))
		{
			GameObject gameObject9 = CheckDoorInOutCorner(x, z, AdjacencyCode.LeftTop, curStyle);
			if (gameObject9 != null)
			{
				GameObject gameObject10 = UnityEngine.Object.Instantiate(gameObject9, Vector3.zero, Quaternion.identity);
				gameObject10.name = prefix + "_oc_lt_" + x + "_" + z;
				gameObject10.transform.parent = wallContainer.transform;
				gameObject10.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
				gameObject10.transform.localRotation = rotOutCornerLeftTop;
				gameObject10.layer = geometryLayer;
				gameObject10.tag = Tags.MapGeometry;
				chunk.AddToCombine(gameObject10);
				StripNonStatic(gameObject10.transform, mapGeometry.transform);
				listWalls?.Add(gameObject10);
			}
		}
		if (Cell.CheckAdjacency(adjacency, AdjacencyCode.RightTop) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)18))
		{
			GameObject gameObject11 = CheckDoorInOutCorner(x, z, AdjacencyCode.RightTop, curStyle);
			if (gameObject11 != null)
			{
				GameObject gameObject12 = UnityEngine.Object.Instantiate(gameObject11, Vector3.zero, Quaternion.identity);
				gameObject12.name = prefix + "_oc_rt_" + x + "_" + z;
				gameObject12.transform.parent = wallContainer.transform;
				gameObject12.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
				gameObject12.transform.localRotation = rotOutCornerRightTop;
				gameObject12.layer = geometryLayer;
				gameObject12.tag = Tags.MapGeometry;
				chunk.AddToCombine(gameObject12);
				StripNonStatic(gameObject12.transform, mapGeometry.transform);
				listWalls?.Add(gameObject12);
			}
		}
		if (Cell.CheckAdjacency(adjacency, AdjacencyCode.LeftBottom) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)72))
		{
			GameObject gameObject13 = CheckDoorInOutCorner(x, z, AdjacencyCode.LeftBottom, curStyle);
			if (gameObject13 != null)
			{
				GameObject gameObject14 = UnityEngine.Object.Instantiate(gameObject13, Vector3.zero, Quaternion.identity);
				gameObject14.name = prefix + "_oc_lb_" + x + "_" + z;
				gameObject14.transform.parent = wallContainer.transform;
				gameObject14.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
				gameObject14.transform.localRotation = rotOutCornerLeftBottom;
				gameObject14.layer = geometryLayer;
				gameObject14.tag = Tags.MapGeometry;
				chunk.AddToCombine(gameObject14);
				StripNonStatic(gameObject14.transform, mapGeometry.transform);
				listWalls?.Add(gameObject14);
			}
		}
		if (Cell.CheckAdjacency(adjacency, AdjacencyCode.RightBottom) && Cell.CheckAdjacencyClear(adjacency, (AdjacencyCode)80))
		{
			GameObject gameObject15 = CheckDoorInOutCorner(x, z, AdjacencyCode.RightBottom, curStyle);
			if (gameObject15 != null)
			{
				GameObject gameObject16 = UnityEngine.Object.Instantiate(gameObject15, Vector3.zero, Quaternion.identity);
				gameObject16.name = prefix + "_oc_rb_" + x + "_" + z;
				gameObject16.transform.parent = wallContainer.transform;
				gameObject16.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
				gameObject16.transform.localRotation = rotOutCornerRightBottom;
				gameObject16.layer = geometryLayer;
				gameObject16.tag = Tags.MapGeometry;
				chunk.AddToCombine(gameObject16);
				StripNonStatic(gameObject16.transform, mapGeometry.transform);
				listWalls?.Add(gameObject16);
			}
		}
		if (Cell.CheckAdjacency(adjacency, (AdjacencyCode)74) && Cell.CheckAdjacencyClear(adjacency, AdjacencyCode.RightCenter))
		{
			GameObject gameObject17 = UnityEngine.Object.Instantiate(curStyle.deadendPrefab, Vector3.zero, Quaternion.identity);
			gameObject17.name = prefix + "_dl_" + x + "_" + z;
			gameObject17.transform.parent = wallContainer.transform;
			gameObject17.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject17.transform.localRotation = Quaternion.Euler(-90f, 90f, 0f);
			gameObject17.layer = geometryLayer;
			gameObject17.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject17);
			StripNonStatic(gameObject17.transform, mapGeometry.transform);
			listWalls?.Add(gameObject17);
		}
		if (Cell.CheckAdjacency(adjacency, (AdjacencyCode)82) && Cell.CheckAdjacencyClear(adjacency, AdjacencyCode.LeftCenter))
		{
			GameObject gameObject18 = UnityEngine.Object.Instantiate(curStyle.deadendPrefab, Vector3.zero, Quaternion.identity);
			gameObject18.name = prefix + "_dr_" + x + "_" + z;
			gameObject18.transform.parent = wallContainer.transform;
			gameObject18.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject18.transform.localRotation = Quaternion.Euler(-90f, -90f, 0f);
			gameObject18.layer = geometryLayer;
			gameObject18.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject18);
			StripNonStatic(gameObject18.transform, mapGeometry.transform);
			listWalls?.Add(gameObject18);
		}
		if (Cell.CheckAdjacency(adjacency, (AdjacencyCode)26) && Cell.CheckAdjacencyClear(adjacency, AdjacencyCode.CenterBottom))
		{
			GameObject gameObject19 = UnityEngine.Object.Instantiate(curStyle.deadendPrefab, Vector3.zero, Quaternion.identity);
			gameObject19.name = prefix + "_dt_" + x + "_" + z;
			gameObject19.transform.parent = wallContainer.transform;
			gameObject19.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject19.transform.localRotation = Quaternion.Euler(-90f, 180f, 0f);
			gameObject19.layer = geometryLayer;
			gameObject19.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject19);
			StripNonStatic(gameObject19.transform, mapGeometry.transform);
			listWalls?.Add(gameObject19);
		}
		if (Cell.CheckAdjacency(adjacency, (AdjacencyCode)88) && Cell.CheckAdjacencyClear(adjacency, AdjacencyCode.CenterTop))
		{
			GameObject gameObject20 = UnityEngine.Object.Instantiate(curStyle.deadendPrefab, Vector3.zero, Quaternion.identity);
			gameObject20.name = prefix + "_db_" + x + "_" + z;
			gameObject20.transform.parent = wallContainer.transform;
			gameObject20.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, yOffset, (float)(-z) * fTileSize - fTileSize / 2f);
			gameObject20.transform.localRotation = Quaternion.Euler(-90f, 0f, 0f);
			gameObject20.layer = geometryLayer;
			gameObject20.tag = Tags.MapGeometry;
			chunk.AddToCombine(gameObject20);
			StripNonStatic(gameObject20.transform, mapGeometry.transform);
			listWalls?.Add(gameObject20);
		}
	}

	private void BuildPitWalls(int x, int z, Cell cell, MapStyle roomStyle, MapChunk chunk, float fTileSize)
	{
		MapStyle mapStyle = roomStyle.pitStyle;
		if (!mapStyle)
		{
			mapStyle = roomStyle;
		}
		float num = 0f - mapStyle.ceilingHeight;
		BuildWalls(x, z, cell.adjacencyPit, mapStyle, chunk, 0, fTileSize, "WallSectionPit", num);
		GameObject gameObject = UnityEngine.Object.Instantiate(mapStyle.floorPrefab, Vector3.zero, Quaternion.identity);
		gameObject.name = "Floor_" + x + "_" + z;
		gameObject.transform.parent = floor.transform;
		gameObject.transform.localPosition = new Vector3((float)x * fTileSize + fTileSize / 2f, num, (float)(-z) * fTileSize - fTileSize / 2f);
		gameObject.transform.localRotation = Quaternion.Euler(-90f, 0f, 0f);
		gameObject.layer = geometryLayer;
		if (gameObject.tag.Length == 0 || gameObject.tag == Tags.Untagged)
		{
			gameObject.tag = Tags.MapGeometry;
		}
		chunk.AddToCombine(gameObject);
		StripNonStatic(gameObject.transform, mapGeometry.transform);
	}

	private void BuildShaftWalls(int x, int z, Cell cell, MapStyle roomStyle, MapChunk chunk, float fTileSize)
	{
		if (tempWallList == null)
		{
			tempWallList = new List<GameObject>();
		}
		MapStyle mapStyle = roomStyle.shaftSyle;
		if (!mapStyle)
		{
			mapStyle = roomStyle;
		}
		float num = roomStyle.ceilingHeight - 0.15f;
		if (roomStyle.arched)
		{
			num -= 1f;
		}
		BuildWalls(x, z, cell.adjacencyShaft, mapStyle, chunk, 0, fTileSize, "WallSectionShaft", num, tempWallList);
		foreach (GameObject tempWall in tempWallList)
		{
			Renderer[] componentsInChildren = tempWall.GetComponentsInChildren<Renderer>();
			Renderer[] array = componentsInChildren;
			foreach (Renderer renderer in array)
			{
				Material[] sharedMaterials = renderer.sharedMaterials;
				foreach (Material material in sharedMaterials)
				{
					if (material.HasProperty("_PitOffset"))
					{
						material.SetFloat("_PitOffset", num);
					}
				}
			}
		}
	}

	private void StripNonStatic(Transform obj, Transform newContainer)
	{
		for (int i = 0; i < obj.childCount; i++)
		{
			Transform child = obj.GetChild(i);
			bool flag = false;
			int layer = child.gameObject.layer;
			int num = 0;
			while (!flag && num < staticLayers.Length)
			{
				if (layer == (int)staticLayers[num])
				{
					flag = true;
				}
				num++;
			}
			if (!flag)
			{
				child.transform.parent = newContainer;
				i--;
			}
		}
	}

	private GameObject CheckDoorInOutCorner(int x, int z, AdjacencyCode dirCode, MapStyle curStyle)
	{
		if (map.CellMap[z][x].Room != null && (curStyle.removeOutCornersInDoor || curStyle.doorOutCornerPrefab != null))
		{
			Point point;
			Point point2;
			switch (dirCode)
			{
			case AdjacencyCode.RightTop:
				point = new Point(x + 1, z);
				point2 = new Point(x, z - 1);
				break;
			case AdjacencyCode.RightBottom:
				point = new Point(x + 1, z);
				point2 = new Point(x, z + 1);
				break;
			case AdjacencyCode.LeftTop:
				point = new Point(x - 1, z);
				point2 = new Point(x, z - 1);
				break;
			case AdjacencyCode.LeftBottom:
				point = new Point(x - 1, z);
				point2 = new Point(x, z + 1);
				break;
			default:
				return null;
			}
			for (int i = 0; i < map.DoorPositions.Count; i++)
			{
				if (map.DoorPositions[i] == point || map.DoorPositions[i] == point2)
				{
					if (curStyle.removeOutCornersInDoor)
					{
						return null;
					}
					if (curStyle.doorOutCornerPrefab != null)
					{
						return curStyle.doorOutCornerPrefab;
					}
				}
			}
		}
		return curStyle.outCornerPrefab;
	}

	private bool GetEntrancePositioning(Point entrancePos, out Vector3 vPos, out Vector3 vLookAt, out AdjacencyCode doorSide, GameObject doorPrefab)
	{
		vPos = new Vector3((float)entrancePos.X * Map.Get().TileSize.x, 0f, (float)(-entrancePos.Y) * Map.Get().TileSize.y);
		vPos += new Vector3(Map.Get().TileSize.x / 2f, 0f, (0f - Map.Get().TileSize.y) / 2f);
		bool flag = !Map.Get().CellMap[entrancePos.Y][entrancePos.X - 1].IsClear();
		bool flag2 = !Map.Get().CellMap[entrancePos.Y][entrancePos.X + 1].IsClear();
		bool flag3 = !Map.Get().CellMap[entrancePos.Y - 1][entrancePos.X].IsClear();
		bool flag4 = !Map.Get().CellMap[entrancePos.Y + 1][entrancePos.X].IsClear();
		float doorInset = Map.Get().Tags.GetStyle(mapStyles, entrancePos).doorInset;
		doorSide = AdjacencyCode.Clear;
		vLookAt = Vector3.zero;
		if (!flag && !flag2)
		{
			vLookAt = new Vector3(1f, 0f, 0f);
			if (Map.Get().At(entrancePos.X - 1, entrancePos.Y).Room != null)
			{
				doorSide = AdjacencyCode.LeftCenter;
				doorInset = GetDoorInset(entrancePos, doorSide, doorPrefab);
				vPos.x -= Map.Get().TileSize.x / 2f - doorInset;
				vLookAt = new Vector3(-1f, 0f, 0f);
			}
			else
			{
				doorSide = AdjacencyCode.RightCenter;
				doorInset = GetDoorInset(entrancePos, doorSide, doorPrefab);
				vPos.x += Map.Get().TileSize.x / 2f - doorInset;
				vLookAt = new Vector3(1f, 0f, 0f);
			}
		}
		else
		{
			if (flag3 || flag4)
			{
				return false;
			}
			vLookAt = new Vector3(0f, 0f, -1f);
			if (Map.Get().At(entrancePos.X, entrancePos.Y + 1).Room != null)
			{
				doorSide = AdjacencyCode.CenterBottom;
				doorInset = GetDoorInset(entrancePos, doorSide, doorPrefab);
				vPos.z -= Map.Get().TileSize.x / 2f - doorInset;
				vLookAt = new Vector3(0f, 0f, -1f);
			}
			else
			{
				doorSide = AdjacencyCode.CenterTop;
				doorInset = GetDoorInset(entrancePos, doorSide, doorPrefab);
				vPos.z += Map.Get().TileSize.x / 2f - doorInset;
				vLookAt = new Vector3(0f, 0f, 1f);
			}
		}
		return true;
	}

	private float GetDoorInset(Point entrancePos, AdjacencyCode doorSide, GameObject doorPrefab)
	{
		Point tile = Map.WalkDirection(entrancePos, doorSide);
		MapStyle style = Map.Get().Tags.GetStyle(mapStyles, tile);
		float doorInset = style.doorInset;
		if (doorPrefab != null && style.doorInsets.Count > 0)
		{
			string text = doorPrefab.name;
			for (int i = 0; i < style.doorInsets.Count; i++)
			{
				if (style.doorInsets[i].doorType == text)
				{
					return style.doorInsets[i].inset;
				}
			}
		}
		return doorInset;
	}

	private void AddDoorFrame(Point cellPos, AdjacencyCode side, bool hasDoor, MapStyle[] mapStyles, GameObject wallContainer)
	{
		Point point = cellPos;
		Cell cell = Map.Get().At(cellPos);
		MapStyle style = Map.Get().Tags.GetStyle(mapStyles, point);
		Point point2 = Map.WalkDirection(point, side);
		Cell cell2 = Map.Get().At(point2);
		MapStyle style2 = Map.Get().Tags.GetStyle(mapStyles, point2);
		bool flag = style2.arched && style2.ceilingHeight <= 3.5f;
		bool flag2 = style.arched && style.ceilingHeight <= 3.5f;
		if (!hasDoor && style == style2)
		{
			return;
		}
		float x = Map.Get().TileSize.x;
		if (hasDoor || style.ceilingHeight != style2.ceilingHeight || flag2 != flag)
		{
			bool flag3 = (hasDoor || style.ceilingHeight < 3.5f || flag2) && style2.ceilingHeight > 2.5f;
			bool flag4 = (hasDoor || style2.ceilingHeight < 3.5f || flag) && style.ceilingHeight > 2.5f;
			bool flag5 = !hasDoor && style.ceilingHeight <= 3.5f && style2.ceilingHeight > 3.5f;
			bool flag6 = !hasDoor && style2.ceilingHeight <= 3.5f && style.ceilingHeight > 3.5f;
			if (!flag3 && flag4 && style2.ceilingHeight > 2.5f)
			{
				flag5 = false;
				flag3 = true;
			}
			if (!flag4 && flag3 && style.ceilingHeight > 2.5f)
			{
				flag6 = false;
				flag4 = true;
			}
			if (!hasDoor && !flag3 && !flag4 && !flag5 && !flag6 && style.ceilingHeight != style2.ceilingHeight)
			{
				if (style.ceilingHeight > 3.5f && style2.ceilingHeight > 3.5f)
				{
					flag5 = (flag6 = true);
				}
				else
				{
					flag3 = (flag4 = true);
				}
			}
			GameObject gameObject = (flag3 ? style2.doorFrame25Prefab : ((!flag5) ? null : style2.doorFrame35Prefab));
			if ((bool)gameObject)
			{
				GameObject gameObject2 = UnityEngine.Object.Instantiate(gameObject, Vector3.zero, Quaternion.identity);
				gameObject2.name = "WallSection_dframe_" + point2.X + "_" + point2.Y;
				gameObject2.transform.parent = wallContainer.transform;
				gameObject2.transform.localPosition = new Vector3((float)point2.X * x + x / 2f, 0f, (float)(-point2.Y) * x - x / 2f);
				switch (side)
				{
				case AdjacencyCode.LeftCenter:
					gameObject2.transform.localRotation = rotLWallRight;
					break;
				case AdjacencyCode.RightCenter:
					gameObject2.transform.localRotation = rotLWallLeft;
					break;
				case AdjacencyCode.CenterTop:
					gameObject2.transform.localRotation = rotLWallBottom;
					break;
				case AdjacencyCode.CenterBottom:
					gameObject2.transform.localRotation = rotLWallTop;
					break;
				}
				gameObject2.layer = geometryLayer;
				gameObject2.tag = Tags.MapGeometry;
				MapChunk.At(point2.X, point2.Y).AddToCombine(gameObject2);
			}
			GameObject gameObject3 = (flag4 ? style.doorFrame25Prefab : ((!flag6) ? null : style.doorFrame35Prefab));
			if ((bool)gameObject3)
			{
				GameObject gameObject4 = UnityEngine.Object.Instantiate(gameObject3, Vector3.zero, Quaternion.identity);
				gameObject4.name = "WallSection_dframe_" + point.X + "_" + point.Y;
				gameObject4.transform.parent = wallContainer.transform;
				float num = 0.1f;
				Vector3 vector = Vector3.zero;
				switch (side)
				{
				case AdjacencyCode.LeftCenter:
					gameObject4.transform.localRotation = rotLWallLeft;
					vector = new Vector3(1f, 0f, 0f);
					break;
				case AdjacencyCode.RightCenter:
					gameObject4.transform.localRotation = rotLWallRight;
					vector = new Vector3(-1f, 0f, 0f);
					break;
				case AdjacencyCode.CenterTop:
					gameObject4.transform.localRotation = rotLWallTop;
					vector = new Vector3(0f, 0f, -1f);
					break;
				case AdjacencyCode.CenterBottom:
					gameObject4.transform.localRotation = rotLWallBottom;
					vector = new Vector3(0f, 0f, 1f);
					break;
				}
				gameObject4.transform.localPosition = new Vector3((float)point.X * x + x / 2f, 0f, (float)(-point.Y) * x - x / 2f) + vector * num;
				if (style.offsetDoorFrame)
				{
					gameObject4.transform.localPosition += Vector3.up * 0.005f;
				}
				gameObject4.layer = geometryLayer;
				gameObject4.tag = Tags.MapGeometry;
				MapChunk.At(point.X, point.Y).AddToCombine(gameObject4);
			}
			if (!hasDoor && (flag3 || flag5 || flag4 || flag6))
			{
				GameObject topTransitionPrefab = style2.topTransitionPrefab;
				float transHeight = 3.5f;
				if (flag4 || flag3)
				{
					transHeight = 2.4f;
				}
				else if (flag6 || flag5)
				{
					transHeight = 3.4f;
				}
				float transHOffset = Mathf.Min(style.transitionHOffset, style2.transitionHOffset);
				AddCeilingTransition(point, side, topTransitionPrefab, transHeight, transHOffset, style.transitionOutOffset);
			}
		}
		if (hasDoor)
		{
			switch (side)
			{
			case AdjacencyCode.LeftCenter:
				ceilingMiniTransitions[cellPos.Y][cellPos.X - 1] |= 16;
				break;
			case AdjacencyCode.RightCenter:
				ceilingMiniTransitions[cellPos.Y][cellPos.X] |= 16;
				break;
			case AdjacencyCode.CenterTop:
				ceilingMiniTransitions[cellPos.Y - 1][cellPos.X] |= 64;
				break;
			case AdjacencyCode.CenterBottom:
				ceilingMiniTransitions[cellPos.Y][cellPos.X] |= 64;
				break;
			}
		}
		int num2 = 0;
		if (!hasDoor && style != style2)
		{
			bool flag7 = false;
			bool flag8 = false;
			Quaternion identity = Quaternion.identity;
			Quaternion identity2 = Quaternion.identity;
			if (point.X > point2.X)
			{
				if (cell.CheckAdjacency(AdjacencyCode.CenterTop) && cell2.CheckAdjacency(AdjacencyCode.CenterTop))
				{
					flag8 = true;
				}
				if (cell.CheckAdjacency(AdjacencyCode.CenterBottom) && cell2.CheckAdjacency(AdjacencyCode.CenterBottom))
				{
					flag7 = true;
				}
				identity = rotOutCornerLeftBottom;
				identity2 = rotOutCornerLeftTop;
			}
			else if (point.X < point2.X)
			{
				if (cell.CheckAdjacency(AdjacencyCode.CenterTop) && cell2.CheckAdjacency(AdjacencyCode.CenterTop))
				{
					flag7 = true;
				}
				if (cell.CheckAdjacency(AdjacencyCode.CenterBottom) && cell2.CheckAdjacency(AdjacencyCode.CenterBottom))
				{
					flag8 = true;
				}
				identity = rotOutCornerRightTop;
				identity2 = rotOutCornerRightBottom;
			}
			else if (point.Y > point2.Y)
			{
				if (cell.CheckAdjacency(AdjacencyCode.LeftCenter) && cell2.CheckAdjacency(AdjacencyCode.LeftCenter))
				{
					flag7 = true;
				}
				if (cell.CheckAdjacency(AdjacencyCode.RightCenter) && cell2.CheckAdjacency(AdjacencyCode.RightCenter))
				{
					flag8 = true;
				}
				identity = rotOutCornerLeftTop;
				identity2 = rotOutCornerRightTop;
			}
			else if (point.Y < point2.Y)
			{
				if (cell.CheckAdjacency(AdjacencyCode.LeftCenter) && cell2.CheckAdjacency(AdjacencyCode.LeftCenter))
				{
					flag8 = true;
				}
				if (cell.CheckAdjacency(AdjacencyCode.RightCenter) && cell2.CheckAdjacency(AdjacencyCode.RightCenter))
				{
					flag7 = true;
				}
				identity = rotOutCornerRightBottom;
				identity2 = rotOutCornerLeftBottom;
			}
			GameObject outCornerPrefab = style2.outCornerPrefab;
			if (!outCornerPrefab)
			{
				outCornerPrefab = style.outCornerPrefab;
			}
			if (outCornerPrefab != null && flag7)
			{
				GameObject gameObject5 = UnityEngine.Object.Instantiate(outCornerPrefab, Vector3.zero, Quaternion.identity);
				gameObject5.name = "WallSection_trans_left_" + point.X + "_" + point.Y;
				gameObject5.transform.parent = wallContainer.transform;
				gameObject5.transform.localPosition = new Vector3((float)point.X * x + x / 2f, 0f, (float)(-point.Y) * x - x / 2f);
				gameObject5.transform.localRotation = identity;
				gameObject5.layer = geometryLayer;
				gameObject5.tag = Tags.MapGeometry;
				MapChunk.At(point.X, point.Y).AddToCombine(gameObject5);
				num2++;
			}
			if (outCornerPrefab != null && flag8)
			{
				GameObject gameObject6 = UnityEngine.Object.Instantiate(outCornerPrefab, Vector3.zero, Quaternion.identity);
				gameObject6.name = "WallSection_trans_right_" + point.X + "_" + point.Y;
				gameObject6.transform.parent = wallContainer.transform;
				gameObject6.transform.localPosition = new Vector3((float)point.X * x + x / 2f, 0f, (float)(-point.Y) * x - x / 2f);
				gameObject6.transform.localRotation = identity2;
				gameObject6.layer = geometryLayer;
				gameObject6.tag = Tags.MapGeometry;
				MapChunk.At(point.X, point.Y).AddToCombine(gameObject6);
				num2++;
			}
		}
		if (style != style2 && style.collapseEdges != style2.collapseEdges && (style.collapseEdges || style2.collapseEdges) && num2 == 0)
		{
			Point point3 = ((!style.collapseEdges) ? point2 : point);
			if (map.At(point3).GetNumAdjacentWallsNoCorners() >= 2)
			{
				Vector3 vector2 = new Vector3((float)point.X * x + x / 2f, 0f, (float)(-point.Y) * x - x / 2f);
				Vector3 vector3 = new Vector3((float)point2.X * x + x / 2f, 0f, (float)(-point2.Y) * x - x / 2f);
				Vector3 vector4 = (vector3 - vector2).MajorAxis();
				Vector3 vector5 = (vector2 + vector3) / 2f;
				Vector3 vector6 = vector4;
				vector6 = ((!(vector4.x >= 1f) && !(vector4.x <= -1f)) ? new Vector3(1f, 0f, 0f) : new Vector3(0f, 0f, 1f));
				EdgeCollapse item = default(EdgeCollapse);
				item.edge = vector5 + vector6 * x / 2f;
				item.tile = point3;
				EdgeCollapse item2 = default(EdgeCollapse);
				item2.edge = vector5 - vector6 * x / 2f;
				item2.tile = point3;
				edgeCollapses.Add(item);
				edgeCollapses.Add(item2);
			}
		}
		if (num2 < 2)
		{
			AddWallCaps(style, point, point2);
			AddWallCaps(style2, point2, point);
		}
	}

	private void AddWallCaps(MapStyle style, Point insidePos, Point outsidePos)
	{
		if (style.lWallCapLeft == null || style.lWallCapRight == null)
		{
			return;
		}
		AdjacencyCode adjacencyCode = AdjacencyCode.Clear;
		Point point;
		Point point2;
		if (insidePos.X == outsidePos.X)
		{
			if (insidePos.Y < outsidePos.Y)
			{
				point = insidePos + new Point(1, 0);
				point2 = insidePos + new Point(-1, 0);
				adjacencyCode = AdjacencyCode.CenterBottom;
			}
			else
			{
				point = insidePos + new Point(-1, 0);
				point2 = insidePos + new Point(1, 0);
				adjacencyCode = AdjacencyCode.CenterTop;
			}
		}
		else if (insidePos.X < outsidePos.X)
		{
			point = insidePos + new Point(0, -1);
			point2 = insidePos + new Point(0, 1);
			adjacencyCode = AdjacencyCode.RightCenter;
		}
		else
		{
			point = insidePos + new Point(0, 1);
			point2 = insidePos + new Point(0, -1);
			adjacencyCode = AdjacencyCode.LeftCenter;
		}
		for (int i = 0; i < 2; i++)
		{
			Point point3 = ((i != 0) ? point2 : point);
			if (map.At(point3).IsClearOrPit() && map.At(point3).CheckAdjacency(adjacencyCode))
			{
				Quaternion identity = Quaternion.identity;
				switch (adjacencyCode)
				{
				case AdjacencyCode.CenterBottom:
					identity = rotLWallBottom;
					break;
				case AdjacencyCode.CenterTop:
					identity = rotLWallTop;
					break;
				case AdjacencyCode.LeftCenter:
					identity = rotLWallLeft;
					break;
				case AdjacencyCode.RightCenter:
					identity = rotLWallRight;
					break;
				}
				float x = Map.Get().TileSize.x;
				GameObject gameObject = UnityEngine.Object.Instantiate((i != 0) ? style.lWallCapRight : style.lWallCapLeft, Vector3.zero, Quaternion.identity);
				gameObject.name = "WallCap_" + point3.X + "_" + point3.Y;
				gameObject.transform.parent = wallContainer.transform;
				gameObject.transform.localPosition = new Vector3((float)point3.X * x + x / 2f, 0f, (float)(-point3.Y) * x - x / 2f);
				gameObject.transform.localRotation = identity;
				gameObject.layer = geometryLayer;
				gameObject.tag = Tags.MapGeometry;
				MapChunk.At(insidePos.X, insidePos.Y).AddToCombine(gameObject);
				Vector3 vector = Map.Get().CellToWorld(point3);
				Debug.DrawLine(vector, vector + Vector3.up, Color.blue, 5f);
			}
		}
	}

	private GameObject AddCeilingTransition(Point cellPos, AdjacencyCode side, GameObject transitionPrefab, float transHeight = 2.4f, float transHOffset = 0f, float offsetAmount = 0.05f)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(transitionPrefab, Vector3.zero, Quaternion.identity);
		gameObject.name = "WallSection_trans_top_" + cellPos.X + "_" + cellPos.Y;
		gameObject.transform.parent = wallContainer.transform;
		float x = Map.Get().TileSize.x;
		Vector3 vector = Vector3.zero;
		switch (side)
		{
		case AdjacencyCode.LeftCenter:
			gameObject.transform.localRotation = rotLWallLeft;
			vector = new Vector3(1f, 0f, 0f);
			ceilingMiniTransitions[cellPos.Y][cellPos.X - 1] |= 16;
			break;
		case AdjacencyCode.RightCenter:
			gameObject.transform.localRotation = rotLWallRight;
			vector = new Vector3(-1f, 0f, 0f);
			ceilingMiniTransitions[cellPos.Y][cellPos.X] |= 16;
			break;
		case AdjacencyCode.CenterTop:
			gameObject.transform.localRotation = rotLWallTop;
			vector = new Vector3(0f, 0f, -1f);
			ceilingMiniTransitions[cellPos.Y - 1][cellPos.X] |= 64;
			break;
		case AdjacencyCode.CenterBottom:
			gameObject.transform.localRotation = rotLWallBottom;
			vector = new Vector3(0f, 0f, 1f);
			ceilingMiniTransitions[cellPos.Y][cellPos.X] |= 64;
			break;
		}
		gameObject.transform.localPosition = new Vector3((float)cellPos.X * x + x / 2f, 0f, (float)(-cellPos.Y) * x - x / 2f) + vector * offsetAmount + new Vector3(0f, transHeight + transHOffset, 0f);
		gameObject.layer = geometryLayer;
		gameObject.tag = Tags.MapGeometry;
		MapChunk.At(cellPos.X, cellPos.Y).AddToCombine(gameObject);
		return gameObject;
	}

	private void ListStaticGeometry(GameObject root, ref List<GameObject> staticGeometry)
	{
		Transform transform = root.transform;
		for (int i = 0; i < transform.childCount; i++)
		{
			GameObject gameObject = transform.GetChild(i).gameObject;
			if (gameObject.isStatic)
			{
				staticGeometry.Add(gameObject);
			}
			else
			{
				ListStaticGeometry(gameObject, ref staticGeometry);
			}
		}
	}

	public Map GenerateGB()
	{
		Texture2D texture2D = new Texture2D(128, 128, TextureFormat.RGBA32, mipmap: false);
		ClearMemory.AddRuntimeTexture(texture2D);
		texture2D.filterMode = FilterMode.Point;
		texture2D.wrapMode = TextureWrapMode.Clamp;
		GBGenerator gBGenerator = new GBGenerator();
		if (generatorType == GeneratorType.Meta01)
		{
			gBGenerator = (customGenerator = new MetaMapGenerator_01());
		}
		else if (generatorType == GeneratorType.Meta02)
		{
			gBGenerator = (customGenerator = new MetaMapGenerator_02());
		}
		else if (generatorType == GeneratorType.Meta03)
		{
			gBGenerator = (customGenerator = new MetaMapGenerator_03());
		}
		else if (generatorType == GeneratorType.Meta04)
		{
			gBGenerator = (customGenerator = new MetaMapGenerator_04());
		}
		else if (generatorType == GeneratorType.Demo)
		{
			gBGenerator = (customGenerator = new CustomGenerator());
		}
		gBGenerator.Options = new GBGenerator.MapOptions(64, 64);
		gBGenerator.Options.styles = mapStyles;
		gBGenerator.Options.mainTag = levelOptions.tag;
		LevelOptions.AmbientOptions ambientOptions = levelOptions.GetAmbientOptions();
		if (ambientOptions != null)
		{
			gBGenerator.Options.ambientDefault = ambientOptions.ambientDefault.ambient;
			gBGenerator.Options.ambientRoom = ambientOptions.ambientRoom.ambient;
			gBGenerator.Options.ambientLarge = ambientOptions.ambientLarge.ambient;
			gBGenerator.Options.ambientHub = ambientOptions.ambientHub.ambient;
			AmbientManager.Get().defaultAmbientName = gBGenerator.Options.ambientDefault;
		}
		gBGenerator.Options.testRoom = testRoom;
		gBGenerator.Options.maskNone = levelOptions.maskNone;
		gBGenerator.Options.maskSmall = levelOptions.maskSmall;
		gBGenerator.Options.maskMedium = levelOptions.maskMedium;
		gBGenerator.Options.maskOShaped = levelOptions.maskOShaped;
		gBGenerator.Options.maskCross = levelOptions.maskCross;
		gBGenerator.Options.maskFortress = levelOptions.maskFortress;
		gBGenerator.Options.maskTShaped = levelOptions.maskTShaped;
		gBGenerator.Options.maskUShaped = levelOptions.maskUShaped;
		if (levelOptions.styleOptions.Length > 0)
		{
			List<Pair<LevelOptions.StyleOptions, float>> list = new List<Pair<LevelOptions.StyleOptions, float>>();
			for (int i = 0; i < levelOptions.styleOptions.Length; i++)
			{
				list.Add(new Pair<LevelOptions.StyleOptions, float>(levelOptions.styleOptions[i], levelOptions.styleOptions[i].weight));
			}
			gBGenerator.Options.styleOptions = RandomExt.WeightedChoice(list);
		}
		Map map;
		for (map = null; map == null; map = gBGenerator.Generate(64, 64, texture2D))
		{
		}
		GameObject.FindWithTag(Tags.Minimap).GetComponent<Renderer>().sharedMaterial.SetTexture("_LevelMap", texture2D);
		levelMap = texture2D;
		return map;
	}

	private void Start()
	{
		if (testRoom != null)
		{
			return;
		}
		NavGraph component = GameObject.FindWithTag(Tags.NavGraph).GetComponent<NavGraph>();
		if ((bool)component && component.SpawnPositions.Count > 0)
		{
			int a = Mathf.Max(1, component.SpawnPositions.Count / 30);
			a = Mathf.Min(a, levelOptions.maxProwlers);
			if (a > 0)
			{
				float num = UnityEngine.Random.Range(levelOptions.prowlersMinDelay, levelOptions.prowlersMaxDelay);
				if (num > 0f)
				{
					StartCoroutine(DelayedSpawnProwlers_co(component, a, num));
				}
				else
				{
					SpawnProwlers(component, a);
				}
			}
		}
		int num2 = UnityEngine.Random.Range(1, 5) + UnityEngine.Random.Range(1, 5);
		int a2 = Mathf.RoundToInt((float)num2 / 4f);
		a2 = Mathf.Min(a2, levelOptions.maxLightEaters);
		if (a2 > 0)
		{
			float num3 = UnityEngine.Random.Range(levelOptions.lightEatersMinDelay, levelOptions.lightEatersMaxDelay);
			if (num3 > 0f)
			{
				StartCoroutine(DelayedSpawnLightEaters_co(a2, num3));
			}
			else
			{
				SpawnLightEaters(a2);
			}
		}
		int num4 = UnityEngine.Random.Range(1, 5) + UnityEngine.Random.Range(1, 5);
		int a3 = Mathf.RoundToInt((float)num4 / 3f);
		a3 = Mathf.Min(a3, levelOptions.maxFloaters);
		if (a3 > 0)
		{
			float num5 = UnityEngine.Random.Range(levelOptions.floatersMinDelay, levelOptions.floatersMaxDelay);
			if (num5 > 0f)
			{
				StartCoroutine(DelayedSpawnFloaters_co(a3, num5));
			}
			else
			{
				SpawnFloaters(a3);
			}
		}
	}

	private void SpawnLightEaters(int numEaters, bool checkVisibility = false, bool nearby = false)
	{
		for (int i = 0; i < numEaters; i++)
		{
			int num = 10;
			while (num-- > 0)
			{
				if (i == 0 && nearby)
				{
					LightEater.SpawnNextToPlayer(destroy: false, UnityEngine.Random.value < 0.3f);
					break;
				}
				Room room = RandomExt.Choice(Map.Get().Rooms);
				if (room.Safe || room.IsExitRoom || (checkVisibility && room.PlayerInside))
				{
					continue;
				}
				Point randomPoint = room.GetRandomPoint(central: true);
				if (checkVisibility && Map.Get().At(randomPoint).IsVisible())
				{
					continue;
				}
				LightEater lightEater = UnityEngine.Object.Instantiate(lightEaterPrefab, Map.Get().CellToWorld(randomPoint), Quaternion.identity);
				lightEater.gameObject.name = "LightEater_" + i;
				if (i != 0 && UnityEngine.Random.value <= 0.5f && (!checkVisibility || !room.PlayerEverEntered))
				{
					lightEater.SetStalk(room);
				}
				break;
			}
		}
	}

	private IEnumerator DelayedSpawnLightEaters_co(int numEaters, float delayTime)
	{
		if (numEaters > 0)
		{
			LightEater eater = UnityEngine.Object.Instantiate(lightEaterPrefab, Vector3.zero, Quaternion.identity);
			eater.enabled = false;
			eater.GetComponent<CreatureVisibility>().enabled = false;
			eater.gameObject.name = "LightEater_prewarm";
			yield return null;
			UnityEngine.Object.Destroy(eater.gameObject);
		}
		yield return new WaitForSeconds(delayTime);
		SpawnLightEaters(numEaters, checkVisibility: true, levelOptions.spawnNextToPlayer);
	}

	private void SpawnProwlers(NavGraph navGraph, int numProwlers, bool checkVisibility = false)
	{
		List<int> list = new List<int>();
		for (int i = 0; i < numProwlers; i++)
		{
			int num = 10;
			while (num-- > 0)
			{
				int num2 = UnityEngine.Random.Range(0, navGraph.SpawnPositions.Count);
				if (!list.Contains(num2))
				{
					list.Add(num2);
					Vector3 position = navGraph.SpawnPositions[num2].position;
					if (!checkVisibility || !MapChunk.At(Map.Get().WorldToCell(position)).Visible)
					{
						GameObject gameObject = UnityEngine.Object.Instantiate(prowlerPrefab, position, Quaternion.identity);
						gameObject.name = "Prowler_" + i;
						break;
					}
				}
			}
		}
	}

	private IEnumerator DelayedSpawnProwlers_co(NavGraph navGraph, int numProwlers, float delayTime)
	{
		if (numProwlers > 0)
		{
			Prowler prowler = UnityEngine.Object.Instantiate(prowlerPrefab, Vector3.zero, Quaternion.identity).GetComponent<Prowler>();
			prowler.enabled = false;
			prowler.GetComponent<CreatureVisibility>().enabled = false;
			prowler.gameObject.name = "Prowler_prewarm";
			yield return null;
			UnityEngine.Object.Destroy(prowler.gameObject);
		}
		yield return new WaitForSeconds(delayTime);
		SpawnProwlers(navGraph, numProwlers, checkVisibility: true);
	}

	private void RecursiveRemoveSpawn(List<NavNode> validSpawns, NavNode node)
	{
		if (validSpawns.Contains(node))
		{
			validSpawns.Remove(node);
			for (int i = 0; i < node.Neighbours.Count; i++)
			{
				RecursiveRemoveSpawn(validSpawns, node.Neighbours[i]);
			}
		}
	}

	private void SpawnFloaters(int numFloaters)
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag(Tags.FloaterSpawn);
		List<Transform> list = new List<Transform>();
		for (int i = 0; i < array.Length; i++)
		{
			Cell cell = Map.Get().At(array[i].transform.position);
			Room room = cell.Room;
			if (cell.GetNumAdjacentWallsNoCorners() < 3 && room != null && !room.Safe && room.floaters.Count == 0)
			{
				list.Add(array[i].transform);
			}
		}
		list.Shuffle();
		for (int j = 0; j < numFloaters; j++)
		{
			Floater floater = null;
			if (list.Count > 0 && UnityEngine.Random.value <= 1f)
			{
				do
				{
					Room room2 = Map.Get().At(list[0].position).Room;
					if (room2.floaters.Count == 0)
					{
						floater = Floater.SpawnInWell(list[0], floaterPrefab);
					}
					list.RemoveAt(0);
				}
				while (floater == null && list.Count > 0);
			}
			if (floater == null)
			{
				floater = Floater.SpawnInRandomRoom(floaterPrefab);
			}
			if (floater != null)
			{
				floater.name = "Floater_" + j;
			}
		}
	}

	private IEnumerator DelayedSpawnFloaters_co(int numFloaters, float delayTime)
	{
		yield return new WaitForSeconds(delayTime);
		SpawnFloaters(numFloaters);
	}

	public void SpawnBats(Room room)
	{
		StartCoroutine(SpawnBats_co());
	}

	private IEnumerator SpawnBats_co()
	{
		yield return new WaitForSeconds(4f + UnityEngine.Random.Range(3f, 6f));
		if (UnityEngine.Random.value <= 0.7f)
		{
			SpookSounds.Get().PlayDeepPitSound();
			yield return new WaitForSeconds(1.5f);
		}
		Bat batPrefab = GameController.Get().GetComponent<MapBuilder>().batPrefab;
		Transform playerPos = Player.Get().transform;
		Vector3 curPos = Player.GetGroundPos();
		for (int i = 0; i < 64; i++)
		{
			UnityEngine.Object.Instantiate(batPrefab, curPos, playerPos.rotation);
		}
		yield return new WaitForSeconds(1f);
		FearEffect.Get().Scare(jumpScare: true);
	}

	private Dictionary<Point, List<GameObject>> ProcessPropPrefabs(GameObject[] propPrefabs, Vector2 vTileSize)
	{
		Dictionary<Point, List<GameObject>> dictionary = new Dictionary<Point, List<GameObject>>();
		foreach (GameObject gameObject in propPrefabs)
		{
			PropInfo component = gameObject.GetComponent<PropInfo>();
			Point point;
			if (component == null)
			{
				Bounds bounds = ((!gameObject.GetComponent<Renderer>()) ? gameObject.GetComponent<Collider>().bounds : gameObject.GetComponent<Renderer>().bounds);
				float x = bounds.size.x;
				float z = bounds.size.z;
				point = new Point((int)(x / vTileSize.x), (int)(z / vTileSize.y));
				x -= (float)point.X * vTileSize.x;
				z -= (float)point.Y * vTileSize.y;
				if (x >= 0.3f * vTileSize.x)
				{
					point.X++;
				}
				if (z >= 0.3f * vTileSize.y)
				{
					point.Y++;
				}
			}
			else
			{
				point = new Point(component.SizeX, component.SizeY);
			}
			Point key = new Point(Mathf.Max(point.X, point.Y), Mathf.Min(point.X, point.Y));
			if (!dictionary.ContainsKey(key))
			{
				dictionary[key] = new List<GameObject>();
			}
			dictionary[key].Add(gameObject);
		}
		return dictionary;
	}
}
public class MapChunk : MonoBehaviour
{
	public static MapChunk[][] chunkMap;

	public const int chunkSize = 4;

	public static Dictionary<Renderer, int> rendererStateMap;

	public List<VisibilityProbe> probeList;

	public List<Renderer> renderers;

	public List<Light> lights;

	public List<MapChunk> linkedChunks;

	public List<MeshFilter> toCombine;

	private bool visible;

	public bool nextState;

	private float timeVisible;

	public bool Visible
	{
		get
		{
			return visible;
		}
		set
		{
			nextState = value;
		}
	}

	public static void InitChunks(GameObject chunkPrefab, Transform mapGeometry)
	{
		GameObject gameObject = new GameObject("Chunks");
		gameObject.transform.parent = mapGeometry;
		gameObject.isStatic = true;
		int num = (int)Math.Ceiling((decimal)Map.Get().Width / 4m);
		int num2 = (int)Math.Ceiling((decimal)Map.Get().Height / 4m);
		chunkMap = new MapChunk[num2][];
		for (int i = 0; i < num2; i++)
		{
			chunkMap[i] = new MapChunk[num];
			for (int j = 0; j < num; j++)
			{
				GameObject gameObject2 = UnityEngine.Object.Instantiate(chunkPrefab);
				gameObject2.name = "MapChunk_" + j + "_" + i;
				gameObject2.transform.localPosition = Map.Get().CellToWorld(j * 4, i * 4);
				gameObject2.transform.parent = gameObject.transform;
				chunkMap[i][j] = gameObject2.GetComponent<MapChunk>();
			}
		}
		rendererStateMap = new Dictionary<Renderer, int>();
	}

	public static void Clear()
	{
		chunkMap = null;
		rendererStateMap = null;
	}

	public static MapChunk At(int xCell, int yCell)
	{
		return chunkMap[yCell / 4][xCell / 4];
	}

	public static MapChunk At(Point cellPos)
	{
		return At(cellPos.X, cellPos.Y);
	}

	public void AddToCombine(GameObject obj)
	{
		obj.isStatic = false;
		MeshFilter component = obj.GetComponent<MeshFilter>();
		if (component != null)
		{
			toCombine.Add(component);
		}
		for (int i = 0; i < obj.transform.childCount; i++)
		{
			AddToCombine(obj.transform.GetChild(i).gameObject);
		}
	}

	public void AddGeometry(GameObject obj, bool addTracker = true)
	{
		if ((bool)obj.GetComponent<Renderer>())
		{
			renderers.Add(obj.GetComponent<Renderer>());
			if (visible)
			{
				IncVisibilityCount(obj.GetComponent<Renderer>());
			}
			else
			{
				obj.GetComponent<Renderer>().enabled = false;
			}
		}
		if ((bool)obj.GetComponent<Light>())
		{
			ProcessLight(obj);
		}
		if (addTracker && !obj.isStatic)
		{
			OcclusionTracker.AddToTracker(obj, this);
		}
		for (int i = 0; i < obj.transform.childCount; i++)
		{
			AddGeometry(obj.transform.GetChild(i).gameObject);
		}
	}

	public void AddGeometry(GameObject obj, LayerMask mask, bool addTracker = true, bool tryCombineMesh = false)
	{
		if (!Utils.IsInLayerMask(obj, mask))
		{
			return;
		}
		bool flag = false;
		if ((bool)obj.GetComponent<Renderer>())
		{
			if (obj.isStatic && tryCombineMesh)
			{
				MeshFilter component = obj.GetComponent<MeshFilter>();
				if (component != null)
				{
					toCombine.Add(component);
					flag = true;
				}
			}
			if (!flag)
			{
				renderers.Add(obj.GetComponent<Renderer>());
				if (visible)
				{
					IncVisibilityCount(obj.GetComponent<Renderer>());
				}
				else
				{
					obj.GetComponent<Renderer>().enabled = false;
				}
			}
		}
		if ((bool)obj.GetComponent<Light>())
		{
			ProcessLight(obj);
		}
		if (addTracker && !obj.isStatic && !flag)
		{
			OcclusionTracker.AddToTracker(obj, this);
		}
		for (int i = 0; i < obj.transform.childCount; i++)
		{
			AddGeometry(obj.transform.GetChild(i).gameObject, mask, addTracker: true, tryCombineMesh);
		}
	}

	public static void AddGeometry(GameObject obj, Point pos, int width, int height)
	{
		int num = pos.X / 4;
		int num2 = pos.Y / 4;
		int num3 = (pos.X + width - 1) / 4;
		int num4 = (pos.Y + height - 1) / 4;
		for (int i = num2; i <= num4; i++)
		{
			for (int j = num; j <= num3; j++)
			{
				chunkMap[i][j].AddGeometry(obj);
			}
		}
	}

	public static void AddGeometry(GameObject obj, Point pos, int width, int height, LayerMask mask)
	{
		int num = pos.X / 4;
		int num2 = pos.Y / 4;
		int num3 = (pos.X + width - 1) / 4;
		int num4 = (pos.Y + height - 1) / 4;
		if (num == num3 && num2 == num4)
		{
			chunkMap[num2][num].AddGeometry(obj, mask, addTracker: true, tryCombineMesh: true);
			return;
		}
		for (int i = num2; i <= num4; i++)
		{
			for (int j = num; j <= num3; j++)
			{
				chunkMap[i][j].AddGeometry(obj, mask);
			}
		}
	}

	public void AddLight(Light light)
	{
		lights.Add(light);
	}

	private void ProcessLight(GameObject obj)
	{
		if (obj.GetComponent<LightFOV>() == null)
		{
			obj.AddComponent<LightFOV>();
		}
		Room room = Map.Get().At(obj.transform.position).Room;
		if (room != null && (room.Template.size == RoomTemplate.SizeType.Hub || obj.GetComponent<Light>().range >= 3f) && obj.GetComponent<RoomAmbientLight>() == null)
		{
			obj.AddComponent<RoomAmbientLight>();
		}
	}

	public static void Link(List<MapChunk> chunks)
	{
		for (int num = chunks.Count - 1; num > 0; num--)
		{
			MapChunk mapChunk = chunks[num];
			for (int num2 = num - 1; num2 >= 0; num2--)
			{
				MapChunk mapChunk2 = chunks[num2];
				mapChunk.Link(mapChunk2);
				mapChunk2.Link(mapChunk);
			}
		}
	}

	private void Link(MapChunk other)
	{
	}

	public void RemoveGeometry(GameObject obj, bool removeFromCombineList = false, bool checkVisibilityCount = false)
	{
		if ((bool)obj.GetComponent<Renderer>())
		{
			renderers.Remove(obj.GetComponent<Renderer>());
		}
		if (checkVisibilityCount && visible)
		{
			IncVisibilityCount(obj.GetComponent<Renderer>(), -1);
		}
		if (removeFromCombineList)
		{
			MeshFilter component = obj.GetComponent<MeshFilter>();
			if (component != null)
			{
				toCombine.Remove(component);
			}
		}
		for (int i = 0; i < obj.transform.childCount; i++)
		{
			RemoveGeometry(obj.transform.GetChild(i).gameObject, removeFromCombineList);
		}
	}

	private void Awake()
	{
		nextState = false;
		visible = true;
		timeVisible = -1f;
	}

	public void DoUpdate()
	{
		if (visible && timeVisible > 0f)
		{
			timeVisible -= Time.fixedDeltaTime;
		}
		if (!visible || timeVisible <= 0f)
		{
			for (int i = 0; i < linkedChunks.Count; i++)
			{
				if (nextState)
				{
					linkedChunks[i].nextState = true;
				}
				else if (linkedChunks[i].nextState)
				{
					nextState = true;
				}
			}
			if (nextState != visible)
			{
				visible = nextState;
				for (int j = 0; j < renderers.Count; j++)
				{
					int value = 0;
					value = ((!rendererStateMap.TryGetValue(renderers[j], out value)) ? (visible ? 1 : 0) : ((!visible) ? (value - 1) : (value + 1)));
					rendererStateMap[renderers[j]] = value;
					if (value == 0 || value == 1)
					{
						renderers[j].enabled = value > 0;
					}
				}
				for (int k = 0; k < lights.Count; k++)
				{
					lights[k].enabled = visible;
				}
			}
			if (visible)
			{
				timeVisible = 0.5f;
			}
		}
		nextState = false;
	}

	[Conditional("UNITY_EDITOR")]
	public void Visibilize()
	{
		Visible = true;
		for (int i = 0; i < renderers.Count; i++)
		{
			renderers[i].enabled = true;
		}
		for (int j = 0; j < lights.Count; j++)
		{
			lights[j].enabled = true;
		}
	}

	public static int GetRendererVisibilityCount(Renderer renderer)
	{
		int value = 0;
		if (rendererStateMap == null)
		{
			return 0;
		}
		rendererStateMap.TryGetValue(renderer, out value);
		return value;
	}

	private static void IncVisibilityCount(Renderer renderer, int delta = 1)
	{
		int value = 0;
		rendererStateMap.TryGetValue(renderer, out value);
		rendererStateMap[renderer] = value + delta;
	}

	private void OnDrawGizmosSelected()
	{
		DebugRender((!visible) ? Color.yellow : Color.red);
	}

	public void DebugRender(Color color)
	{
		float num = 4f * Map.Get().TileSize.x;
		DebugExt.DrawCube(base.transform.position - new Vector3(Map.Get().TileSize.x / 2f, 0f, (0f - Map.Get().TileSize.x) / 2f) + new Vector3(num / 2f, 1.75f, (0f - num) / 2f), color, new Vector3(num, 3.5f, num));
	}

	public static bool CheckCellNextToVisible(Point cellPos)
	{
		MapChunk mapChunk = At(cellPos);
		if (mapChunk.Visible)
		{
			return true;
		}
		for (int i = cellPos.Y - 1; i <= cellPos.Y + 1; i += 2)
		{
			mapChunk = At(cellPos.X, i);
			if (mapChunk.Visible)
			{
				return true;
			}
		}
		for (int j = cellPos.X - 1; j <= cellPos.X + 1; j += 2)
		{
			mapChunk = At(j, cellPos.Y);
			if (mapChunk.Visible)
			{
				return true;
			}
		}
		return false;
	}
}
public abstract class MapGenerator
{
	public MapGenerator()
	{
	}

	public abstract Map Generate(int w, int h, Texture2D texOut, bool checkDoubleCorridors = true, bool checkRoomConnections = true);
}
public class MapGraph
{
	public class Node
	{
		public Room room;

		public Point pos;

		public List<Node> edges;

		public List<float> edgesCost;

		public bool doubleCorridor;

		public Node(Point p, Room r = null)
		{
			pos = p;
			room = r;
			edges = new List<Node>();
			edgesCost = new List<float>();
			doubleCorridor = false;
		}

		public void AddEdge(Node n)
		{
			if (!edges.Contains(n))
			{
				float num = Mathf.Abs(n.pos.X - pos.X) + Mathf.Abs(n.pos.Y - pos.Y);
				num *= 1.5f;
				edges.Add(n);
				edgesCost.Add(num);
			}
		}

		public override bool Equals(object obj)
		{
			Node node = (Node)obj;
			return node.pos.X == pos.X && node.pos.Y == pos.Y;
		}
	}

	private class MapInfo
	{
		public Cell[][] CellMap;

		public int Width;

		public int Height;

		public List<Room> rooms;

		public List<Point> entrancePositions;

		public List<Point> doorPositions;

		public Cell At(Point pos)
		{
			if (!InRange(pos))
			{
				return null;
			}
			return CellMap[pos.Y][pos.X];
		}

		public Cell At(int x, int y)
		{
			if (!InRange(x, y))
			{
				return null;
			}
			return CellMap[y][x];
		}

		private bool InRange(Point tilePos)
		{
			return InRange(tilePos.X, tilePos.Y);
		}

		private bool InRange(int x, int y)
		{
			return x >= 0 && x < Width && y >= 0 && y < Height;
		}
	}

	public List<Node> nodes = new List<Node>();

	private Dictionary<Room, Node> dictRooms = new Dictionary<Room, Node>();

	private Dictionary<Point, Node> dictPoints = new Dictionary<Point, Node>();

	private List<Point> open = new List<Point>();

	private bool[][] explored;

	private Dictionary<Room, float> deadendWeights;

	public void CreateFromMap(Cell[][] CellMap, int width, int height, List<Room> rooms, List<Point> entrancePositions, List<Point> doorPositions)
	{
		MapInfo mapInfo = new MapInfo();
		mapInfo.CellMap = CellMap;
		mapInfo.Width = width;
		mapInfo.Height = height;
		mapInfo.rooms = rooms;
		mapInfo.entrancePositions = entrancePositions;
		mapInfo.doorPositions = doorPositions;
		CreateFromMap(mapInfo);
	}

	private void CreateFromMap(MapInfo map)
	{
		nodes.Clear();
		dictRooms.Clear();
		dictPoints.Clear();
		open.Clear();
		explored = new bool[map.Height][];
		for (int i = 0; i < map.Height; i++)
		{
			explored[i] = new bool[map.Width];
		}
		foreach (Room room in map.rooms)
		{
			Point p = room.Start + room.Size / 2;
			Node node = new Node(p, room);
			nodes.Add(node);
			dictRooms[room] = node;
		}
		List<Point> list = new List<Point>();
		list.AddRange(map.entrancePositions);
		list.AddRange(map.doorPositions);
		foreach (Point item in list)
		{
			if (dictPoints.TryGetValue(item, out var value))
			{
				continue;
			}
			Node value2 = null;
			dictPoints.TryGetValue(new Point(item.X - 1, item.Y), out value2);
			if (value2 == null)
			{
				dictPoints.TryGetValue(new Point(item.X, item.Y - 1), out value2);
			}
			if (value2 != null && value2.room == null)
			{
				value2.doubleCorridor = true;
				explored[item.Y][item.X] = true;
				continue;
			}
			value = new Node(item);
			nodes.Add(value);
			open.Add(item);
			dictPoints[item] = value;
			Cell cell = map.At(item);
			if (cell.Room != null)
			{
				Node node2 = dictRooms[cell.Room];
				value.AddEdge(node2);
				node2.AddEdge(value);
			}
		}
		Node[] array = new Node[8];
		while (open.Count > 0)
		{
			Point point = open[0];
			open.RemoveAt(0);
			if (explored[point.Y][point.X])
			{
				continue;
			}
			explored[point.Y][point.X] = true;
			Cell cell2 = map.At(point);
			if (!cell2.CanWalk() || !dictPoints.TryGetValue(point, out var value3))
			{
				continue;
			}
			if (value3.doubleCorridor)
			{
				point = value3.pos;
				explored[point.Y][point.X] = true;
				explored[point.Y][point.X + 1] = true;
				explored[point.Y + 1][point.X] = true;
				explored[point.Y + 1][point.X + 1] = true;
			}
			if (!value3.doubleCorridor)
			{
				array[0] = Explore(map, new Point(point.X - 1, point.Y));
				array[1] = Explore(map, new Point(point.X + 1, point.Y));
				array[2] = Explore(map, new Point(point.X, point.Y - 1));
				array[3] = Explore(map, new Point(point.X, point.Y + 1));
			}
			else
			{
				array[0] = Explore(map, new Point(point.X - 1, point.Y));
				array[1] = Explore(map, new Point(point.X - 1, point.Y + 1));
				array[2] = Explore(map, new Point(point.X, point.Y - 1));
				array[3] = Explore(map, new Point(point.X + 1, point.Y - 1));
				array[4] = Explore(map, new Point(point.X + 2, point.Y));
				array[5] = Explore(map, new Point(point.X + 2, point.Y + 1));
				array[6] = Explore(map, new Point(point.X, point.Y + 2));
				array[7] = Explore(map, new Point(point.X + 1, point.Y + 2));
			}
			int num = ((!value3.doubleCorridor) ? 4 : 8);
			for (int j = 0; j < num; j++)
			{
				Node node3 = array[j];
				if (node3 != null)
				{
					value3.AddEdge(node3);
					node3.AddEdge(value3);
				}
			}
		}
	}

	private Node Explore(MapInfo map, Point pos)
	{
		Cell cell = map.At(pos);
		if (!cell.CanWalk())
		{
			return null;
		}
		bool flag = IsDoubleCorridor(map, pos);
		if (flag)
		{
			pos = MapToDouble(pos);
		}
		Node value = null;
		if (dictPoints.TryGetValue(pos, out value))
		{
			return value;
		}
		if (cell.Room != null)
		{
			return dictRooms[cell.Room];
		}
		if (explored[pos.Y][pos.X])
		{
			return null;
		}
		bool flag2 = false;
		bool flag3;
		bool flag4;
		bool flag5;
		bool flag6;
		if (!flag)
		{
			flag3 = map.At(pos.X, pos.Y - 1).CanWalk();
			flag4 = map.At(pos.X, pos.Y + 1).CanWalk();
			flag5 = map.At(pos.X - 1, pos.Y).CanWalk();
			flag6 = map.At(pos.X + 1, pos.Y).CanWalk();
		}
		else
		{
			flag3 = map.At(pos.X, pos.Y - 1).CanWalk() || map.At(pos.X + 1, pos.Y - 1).CanWalk();
			flag4 = map.At(pos.X, pos.Y + 2).CanWalk() || map.At(pos.X + 1, pos.Y + 2).CanWalk();
			flag5 = map.At(pos.X - 1, pos.Y).CanWalk() || map.At(pos.X - 1, pos.Y + 1).CanWalk();
			flag6 = map.At(pos.X + 2, pos.Y).CanWalk() || map.At(pos.X + 2, pos.Y + 1).CanWalk();
		}
		if ((flag5 && flag6 && flag4) || (flag5 && flag3 && flag4) || (flag3 && flag6 && flag4) || (flag5 && flag3 && flag6))
		{
			flag2 = true;
		}
		if (flag2)
		{
			Node node = new Node(pos);
			node.doubleCorridor = flag;
			nodes.Add(node);
			dictPoints[pos] = node;
			open.Add(pos);
			return node;
		}
		explored[pos.Y][pos.X] = true;
		if (flag)
		{
			explored[pos.Y][pos.X + 1] = true;
			explored[pos.Y + 1][pos.X] = true;
			explored[pos.Y + 1][pos.X + 1] = true;
		}
		Node[] array = new Node[8];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = null;
		}
		if (!flag)
		{
			if (!explored[pos.Y][pos.X - 1])
			{
				array[0] = Explore(map, new Point(pos.X - 1, pos.Y));
			}
			if (!explored[pos.Y][pos.X + 1])
			{
				array[1] = Explore(map, new Point(pos.X + 1, pos.Y));
			}
			if (!explored[pos.Y - 1][pos.X])
			{
				array[2] = Explore(map, new Point(pos.X, pos.Y - 1));
			}
			if (!explored[pos.Y + 1][pos.X])
			{
				array[3] = Explore(map, new Point(pos.X, pos.Y + 1));
			}
		}
		else
		{
			if (!explored[pos.Y][pos.X - 1])
			{
				array[0] = Explore(map, new Point(pos.X - 1, pos.Y));
			}
			if (!explored[pos.Y + 1][pos.X + 1])
			{
				array[1] = Explore(map, new Point(pos.X - 1, pos.Y + 1));
			}
			if (!explored[pos.Y - 1][pos.X])
			{
				array[2] = Explore(map, new Point(pos.X, pos.Y - 1));
			}
			if (!explored[pos.Y - 1][pos.X + 1])
			{
				array[3] = Explore(map, new Point(pos.X + 1, pos.Y - 1));
			}
			if (!explored[pos.Y][pos.X + 2])
			{
				array[4] = Explore(map, new Point(pos.X + 2, pos.Y));
			}
			if (!explored[pos.Y + 1][pos.X + 2])
			{
				array[5] = Explore(map, new Point(pos.X + 2, pos.Y + 1));
			}
			if (!explored[pos.Y + 2][pos.X])
			{
				array[6] = Explore(map, new Point(pos.X, pos.Y + 2));
			}
			if (!explored[pos.Y + 2][pos.X + 1])
			{
				array[7] = Explore(map, new Point(pos.X + 1, pos.Y + 2));
			}
		}
		for (int j = 0; j < array.Length; j++)
		{
			if (array[j] != null)
			{
				return array[j];
			}
		}
		return null;
	}

	private Point MapToDouble(Point pos)
	{
		return new Point(2 * (pos.X / 2), 2 * (pos.Y / 2));
	}

	private bool IsDoubleCorridor(MapInfo map, Point pos)
	{
		Point pos2 = MapToDouble(pos);
		Cell cell = map.At(pos2);
		Cell cell2 = map.At(pos2.X + 1, pos2.Y);
		Cell cell3 = map.At(pos2.X, pos2.Y + 1);
		Cell cell4 = map.At(pos2.X + 1, pos2.Y + 1);
		if (cell.CanWalk() && cell2.CanWalk() && cell3.CanWalk() && cell4.CanWalk())
		{
			return true;
		}
		return false;
	}

	public bool CheckConnected()
	{
		if (nodes.Count == 0)
		{
			return false;
		}
		List<Node> list = new List<Node>();
		List<Node> list2 = new List<Node>();
		list2.Add(nodes[0]);
		while (list2.Count > 0)
		{
			Node node = list2[0];
			list2.RemoveAt(0);
			if (list.Contains(node))
			{
				continue;
			}
			list.Add(node);
			foreach (Node edge in node.edges)
			{
				if (!list2.Contains(edge))
				{
					list2.Add(edge);
				}
			}
		}
		return list.Count == nodes.Count;
	}

	public void ComputeDeadEndWeights()
	{
		deadendWeights = new Dictionary<Room, float>();
		List<Node> list = new List<Node>();
		foreach (Room key in dictRooms.Keys)
		{
			Node node = dictRooms[key];
			float num = 0f;
			Node node2 = node;
			list.Clear();
			while (node2 != null)
			{
				list.Add(node2);
				int num2 = 0;
				int index = -1;
				for (int i = 0; i < node2.edges.Count; i++)
				{
					if (!list.Contains(node2.edges[i]))
					{
						num2++;
						if (num2 == 1)
						{
							index = i;
						}
					}
				}
				if (node2.room != null && node2.room != key)
				{
					node2 = null;
				}
				else if (num2 == 1)
				{
					num += node2.edgesCost[index];
					node2 = node2.edges[index];
				}
				else
				{
					node2 = null;
				}
			}
			deadendWeights[key] = num;
		}
	}

	public float GetDeadEndWeight(Room r)
	{
		float value = 0f;
		deadendWeights.TryGetValue(r, out value);
		return value;
	}

	public int GetNumConnections(Room r)
	{
		if (dictRooms.TryGetValue(r, out var value))
		{
			return value.edges.Count;
		}
		return 0;
	}

	[Conditional("DH_DEBUG")]
	public void DebugDraw(float height = 0.5f, float duration = 0f, bool applyDeadends = false)
	{
		foreach (Node node in nodes)
		{
			Vector3 vector = Map.Get().CellToWorld(node.pos) + Vector3.up * height;
			if (applyDeadends && node.room != null)
			{
				vector += Vector3.up * deadendWeights[node.room];
			}
			Color col = Color.red;
			if (node.room != null)
			{
				col = Color.blue;
				if (node.room.IsDeadEnd)
				{
					col = Color.green;
				}
			}
			DebugExt.DrawSphere(vector, col, 1f, duration);
			foreach (Node edge in node.edges)
			{
				Vector3 end = Map.Get().CellToWorld(edge.pos) + Vector3.up * height;
				if (applyDeadends && edge.room != null)
				{
					end += Vector3.up * deadendWeights[edge.room];
				}
				Debug.DrawLine(vector, end, Color.red, duration);
			}
		}
	}
}
public class MapLoS
{
	public static bool LineOfWalk(Vector3 from, Vector3 to, bool canTraverseCorners = false, bool checkNoPlayer = false, bool canFloat = false)
	{
		return LineOfSight(Map.Get().WorldToCell(from), Map.Get().WorldToCell(to), canTraverseCorners, bWalk: true, checkNoPlayer, canFloat);
	}

	public static bool LineOfWalk(Point from, Point to, bool canTraverseCorners = false, bool checkNoPlayer = false, bool canFloat = false)
	{
		return LineOfSight(from, to, canTraverseCorners, bWalk: true, checkNoPlayer, canFloat);
	}

	public static bool LineOfSight(Point from, Point to, bool canTraverseCorners, bool bWalk, bool checkNoPlayer, bool canFloat)
	{
		Map map = Map.Get();
		int num = Mathf.Abs(to.X - from.X);
		int num2 = Mathf.Abs(to.Y - from.Y);
		Point point = from;
		Point point2 = from;
		int num3 = 1 + num + num2;
		int num4 = ((to.X > from.X) ? 1 : (-1));
		int num5 = ((to.Y > from.Y) ? 1 : (-1));
		int num6 = num - num2;
		num *= 2;
		num2 *= 2;
		Point point3 = new Point(0, 0);
		if (checkNoPlayer)
		{
			point3 = Map.Get().WorldToCell(Player.GetPos());
			if (point3 == from)
			{
				point3 = new Point(0, 0);
			}
		}
		while (num3 > 0)
		{
			num3--;
			Cell cell = map.At(point);
			if (cell == null)
			{
				return false;
			}
			if (bWalk && (!cell.CanWalk() || (cell.Occupied && (!canFloat || !cell.CanFloatOver) && cell.Room != null)))
			{
				if (point != from)
				{
					return false;
				}
			}
			else if (!bWalk && !cell.IsTransparent() && point != from)
			{
				return false;
			}
			if (!canTraverseCorners && bWalk)
			{
				if (point2.X != point.X && point2.Y != point.Y && (!map.At(new Point(point2.X, point.Y)).CanWalk() || !map.At(new Point(point.X, point2.Y)).CanWalk()))
				{
					return false;
				}
				if ((to.X > point.X && !map.At(new Point(point.X + 1, point.Y)).CanWalk()) || (to.X < point.X && !map.At(new Point(point.X - 1, point.Y)).CanWalk()) || (to.Y > point.Y && !map.At(new Point(point.X, point.Y + 1)).CanWalk()) || (to.Y < point.Y && !map.At(new Point(point.X, point.Y - 1)).CanWalk()))
				{
					return false;
				}
			}
			else if (!canTraverseCorners && !bWalk)
			{
				if (point2.X != point.X && point2.Y != point.Y && (!map.At(new Point(point2.X, point.Y)).IsTransparent() || !map.At(new Point(point.X, point2.Y)).IsTransparent()))
				{
					return false;
				}
				if ((to.X > point.X && !map.At(new Point(point.X + 1, point.Y)).CanWalk()) || (to.X < point.X && !map.At(new Point(point.X - 1, point.Y)).CanWalk()) || (to.Y > point.Y && !map.At(new Point(point.X, point.Y + 1)).CanWalk()) || (to.Y < point.Y && !map.At(new Point(point.X, point.Y - 1)).CanWalk()))
				{
					return false;
				}
			}
			if (checkNoPlayer && point == point3)
			{
				return false;
			}
			point2 = point;
			if (num6 > 0)
			{
				point.X += num4;
				num6 -= num2;
			}
			else
			{
				point.Y += num5;
				num6 += num;
			}
		}
		return true;
	}
}
public class MapStyle : ScriptableObject
{
	[Serializable]
	public class DoorInset
	{
		public string doorType;

		public float inset;

		public DoorInset(string dType, float amount)
		{
			doorType = dType;
			inset = amount;
		}
	}

	public string styleName;

	public float ceilingHeight;

	public float hangingOffset;

	public bool arched;

	public string tags;

	[NonSerialized]
	public string[] tagList;

	[Range(0f, 25f)]
	public float weight = 1f;

	public GameObject floorPrefab;

	public string floorStepSound = "default";

	public GameObject[] lWallPrefabs;

	public GameObject lWallCapLeft;

	public GameObject lWallCapRight;

	public GameObject doorFrame25Prefab;

	public GameObject doorFrame35Prefab;

	public bool offsetDoorFrame;

	public GameObject outCornerPrefab;

	public GameObject inCornerPrefab;

	public GameObject deadendPrefab;

	public CeilingPrefabs ceilingPrefabs;

	public GameObject topTransitionPrefab;

	public GameObject ceilingTransitionPrefab;

	public float transitionHOffset;

	public float transitionOutOffset = 0.05f;

	public bool removeOutCornersInDoor;

	public GameObject doorOutCornerPrefab;

	public float doorInset = 0.06f;

	public List<DoorInset> doorInsets;

	public float propMargin;

	public float propMarginInCorner;

	public float propMarginOutCorner;

	public float propMarginOutCornerLat;

	public bool allowWallPropsInCorners = true;

	public bool hasNarrowDeadends;

	public bool allowRockColumnsBottom;

	public bool allowRockColumnsTop;

	public List<MapBrushWeight> corridorBrushes;

	public List<MapBrushWeight> roomWallBrushes;

	public MapStyle pitStyle;

	public MapStyle shaftSyle;

	public bool floorNoise;

	public bool ceilingNoise;

	public bool collapseEdges;

	public void OnEnable()
	{
		tagList = tags.Split(',');
	}

	public static MapStyle FindForTags(MapStyle[] styles, List<string> tags)
	{
		if (styles.Length == 0)
		{
			return null;
		}
		List<MapStyle> list = new List<MapStyle>();
		foreach (MapStyle mapStyle in styles)
		{
			if (mapStyle.tagList == null)
			{
				mapStyle.tagList = mapStyle.tags.Split(',');
			}
			int num = Mathf.Min(mapStyle.tagList.Length, tags.Count);
			bool flag = true;
			int num2 = 0;
			while (flag && num2 < num)
			{
				flag = tags[num2] == mapStyle.tagList[num2];
				num2++;
			}
			if (flag)
			{
				list.Add(mapStyle);
			}
		}
		if (list.Count > 0)
		{
			return ChooseStyle(list);
		}
		return styles[0];
	}

	private static MapStyle ChooseStyle(List<MapStyle> styles)
	{
		if (styles.Count == 0)
		{
			return null;
		}
		if (styles.Count == 1)
		{
			return styles[0];
		}
		float num = 0f;
		foreach (MapStyle style in styles)
		{
			num += style.weight;
		}
		float num2 = UnityEngine.Random.Range(0f, num);
		foreach (MapStyle style2 in styles)
		{
			if (style2.weight > num2)
			{
				return style2;
			}
			num2 -= style2.weight;
		}
		return styles[styles.Count - 1];
	}

	public static MapStyle FindByName(MapStyle[] styles, string styleName)
	{
		for (int i = 0; i < styles.Length; i++)
		{
			if (styles[i].styleName == styleName)
			{
				return styles[i];
			}
		}
		Debug.LogError("Invalid MapStyle: " + styleName);
		return null;
	}

	public MapBrush ChooseCorridorBrush()
	{
		return ChooseBrush(corridorBrushes);
	}

	public MapBrush ChooseRoomWallBrush()
	{
		return ChooseBrush(roomWallBrushes);
	}

	private static MapBrush ChooseBrush(List<MapBrushWeight> brushes)
	{
		if (brushes.Count == 0)
		{
			return null;
		}
		if (brushes.Count == 1)
		{
			return brushes[0].brush;
		}
		float num = 0f;
		foreach (MapBrushWeight brush in brushes)
		{
			num += brush.weight;
		}
		float num2 = UnityEngine.Random.Range(0f, num);
		foreach (MapBrushWeight brush2 in brushes)
		{
			if (brush2.weight > num2)
			{
				return brush2.brush;
			}
			num2 -= brush2.weight;
		}
		return brushes[brushes.Count - 1].brush;
	}

	public GameObject GetCeilingTransitionPrefab()
	{
		if (ceilingTransitionPrefab != null)
		{
			return ceilingTransitionPrefab;
		}
		return topTransitionPrefab;
	}

	public string GetMainTag()
	{
		if (tagList.Length > 0)
		{
			return tagList[0];
		}
		return string.Empty;
	}
}
[Serializable]
public class CeilingPrefabs
{
	public GameObject smSinglePrefab;

	public GameObject smLWallPrefab;

	public GameObject smDeadendPrefab;

	public GameObject smCornerPrefab;

	public GameObject smTIntersectionPrefab;

	public GameObject sm4IntersectionPrefab;

	public GameObject lgSinglePrefab;

	public GameObject lgLWallPrefab;

	public GameObject lgOutCornerPrefab;

	public GameObject lgInCornerPrefab;

	public bool alignPieces;

	public bool noRotate;

	public bool alignToRoomDirection;
}
[Serializable]
public class MapBrushWeight
{
	public MapBrush brush;

	[Range(0f, 10f)]
	public float weight = 1f;
}
namespace MapTags
{
	internal class MapTagArea
	{
		public string[] tags;

		public TileArea area;

		public MapTagArea(string[] tags)
		{
			this.tags = tags;
			area = new TileArea();
		}

		public bool CheckTags(string[] tags)
		{
			foreach (string text in tags)
			{
				bool flag = false;
				for (int j = 0; j < this.tags.Length; j++)
				{
					if (flag)
					{
						break;
					}
					if (this.tags[j] == text)
					{
						flag = true;
					}
				}
				if (!flag)
				{
					return false;
				}
			}
			return true;
		}

		public void AddException(Point tile)
		{
			area.AddException(tile);
		}
	}
	internal class MapTagGroup
	{
		public List<MapTagArea> tagAreas;

		public MapTagGroup()
		{
			tagAreas = new List<MapTagArea>();
		}

		public void Set(string[] tags, IntRect rect)
		{
			for (int i = 0; i < tagAreas.Count; i++)
			{
				if (tagAreas[i].CheckTags(tags))
				{
					tagAreas[i].area.Add(rect);
					return;
				}
			}
			MapTagArea mapTagArea = new MapTagArea(tags);
			mapTagArea.area.Add(rect);
			tagAreas.Add(mapTagArea);
		}

		public void Set(string[] tags, Point tile)
		{
			Set(tags, new IntRect(tile.X, tile.Y, 1, 1));
		}

		public void AddException(string[] tags, Point tile)
		{
			for (int i = 0; i < tagAreas.Count; i++)
			{
				if (tagAreas[i].CheckTags(tags))
				{
					tagAreas[i].area.AddException(tile);
					break;
				}
			}
		}

		public bool GetTags(Point tile, List<string> tags)
		{
			for (int num = tagAreas.Count - 1; num >= 0; num--)
			{
				if (tagAreas[num].area.IsInside(tile))
				{
					tags.AddRange(tagAreas[num].tags);
					return true;
				}
			}
			return false;
		}
	}
	public enum Group
	{
		Main,
		Style,
		Substyle
	}
	public class Manager
	{
		private Dictionary<Group, MapTagGroup> tagGroups;

		private Dictionary<int, MapStyle> styleCache;

		private byte[][] variationMap;

		private List<string> tagsTemp;

		public Manager(int width, int height)
		{
			tagGroups = new Dictionary<Group, MapTagGroup>();
			tagGroups[Group.Main] = new MapTagGroup();
			tagGroups[Group.Style] = new MapTagGroup();
			tagGroups[Group.Substyle] = new MapTagGroup();
			styleCache = new Dictionary<int, MapStyle>();
			tagsTemp = new List<string>();
			variationMap = new byte[height][];
			for (int i = 0; i < height; i++)
			{
				variationMap[i] = new byte[width];
				for (int j = 0; j < width; j++)
				{
					variationMap[i][j] = 0;
				}
			}
		}

		public void Set(Group type, string[] tags, IntRect rect)
		{
			MapTagGroup value = null;
			if (!tagGroups.TryGetValue(type, out value))
			{
				value = new MapTagGroup();
				tagGroups[type] = value;
			}
			value.Set(tags, rect);
		}

		public void Set(Group type, string[] tags, Point tile)
		{
			Set(type, tags, new IntRect(tile.X, tile.Y, 1, 1));
		}

		public void Set(Group type, string tag, IntRect rect)
		{
			Set(type, new string[1] { tag }, rect);
		}

		public void Set(Group type, string tag, Point tile)
		{
			Set(type, new string[1] { tag }, new IntRect(tile.X, tile.Y, 1, 1));
		}

		public void SetVariation(char variation, Point tile)
		{
			variationMap[tile.Y][tile.X] = (byte)(variation - 65);
		}

		public MapStyle GetStyle(MapStyle[] styles, Point tile)
		{
			GetTags(tile, tagsTemp);
			return GetStyle(styles, tagsTemp);
		}

		public bool HasStyleSet(Point tile)
		{
			GetTags(tile, tagsTemp);
			return tagsTemp.Count > 1;
		}

		public MapStyle GetStyle(MapStyle[] styles, List<string> tags)
		{
			int orderIndependentHashCode = tags.GetOrderIndependentHashCode();
			MapStyle value = null;
			if (!styleCache.TryGetValue(orderIndependentHashCode, out value))
			{
				value = MapStyle.FindForTags(styles, tags);
				styleCache[orderIndependentHashCode] = value;
			}
			return value;
		}

		public void SetStyle(List<string> tags, MapStyle style)
		{
			int orderIndependentHashCode = tags.GetOrderIndependentHashCode();
			styleCache[orderIndependentHashCode] = style;
		}

		public void SetStyle(string[] tags, MapStyle style)
		{
			List<string> tags2 = new List<string>(tags);
			SetStyle(tags2, style);
		}

		public byte GetVariation(Point tile)
		{
			return variationMap[tile.Y][tile.X];
		}

		private void GetTags(Point tile, List<string> tags)
		{
			tags.Clear();
			tagGroups[Group.Main].GetTags(tile, tags);
			tagGroups[Group.Style].GetTags(tile, tags);
			tagGroups[Group.Substyle].GetTags(tile, tags);
		}

		private void AddException(Group type, string[] tags, Point tile)
		{
			MapTagGroup value = null;
			if (tagGroups.TryGetValue(type, out value))
			{
				value.AddException(tags, tile);
			}
		}

		public void AddException(Group type, Point tile)
		{
			MapTagGroup value = null;
			if (tagGroups.TryGetValue(type, out value))
			{
				List<string> list = new List<string>();
				value.GetTags(tile, list);
				if (list.Count > 0)
				{
					value.AddException(list.ToArray(), tile);
				}
			}
		}
	}
}
public class OcclusionManager : MonoBehaviour
{
	public Transform player;

	public bool activeOcclusion = true;

	private void Start()
	{
		activeOcclusion = true;
		if (player == null)
		{
			player = Player.Get().transform;
		}
		PermissiveFOV.callback = ExploreTile;
	}

	private void Update()
	{
		if (activeOcclusion)
		{
			float maxSeeingDistance = AmbientManager.Get().GetMaxSeeingDistance();
			PermissiveFOV.Scan(Map.Get(), Map.Get().WorldToCell(player.position), (int)(maxSeeingDistance / Map.Get().TileSize.x) + 1);
		}
		else
		{
			for (int i = 0; i < MapChunk.chunkMap.Length; i++)
			{
				for (int j = 0; j < MapChunk.chunkMap[i].Length; j++)
				{
					MapChunk.chunkMap[i][j].Visible = true;
				}
			}
		}
		for (int k = 0; k < MapChunk.chunkMap.Length; k++)
		{
			for (int l = 0; l < MapChunk.chunkMap[k].Length; l++)
			{
				MapChunk mapChunk = MapChunk.chunkMap[k][l];
				if (mapChunk.nextState || mapChunk.Visible)
				{
					mapChunk.DoUpdate();
				}
			}
		}
	}

	[Conditional("UNITY_EDITOR")]
	public void VisibilizeAll()
	{
		for (int i = 0; i < MapChunk.chunkMap.Length; i++)
		{
			for (int j = 0; j < MapChunk.chunkMap[i].Length; j++)
			{
			}
		}
	}

	public static void ExploreTile(Map map, Cell tTile, Point tPos)
	{
		MapChunk.At(tPos.X, tPos.Y).Visible = true;
	}
}
public class OcclusionTracker : OcclusionTrackerStatic
{
	public bool trackPosition;

	private Point lastCell;

	private new void Start()
	{
		base.Start();
		if (trackPosition)
		{
			lastCell = Map.Get().WorldToCell(base.transform.position);
		}
	}

	private void Update()
	{
		if (!trackPosition || chunks.Count != 1)
		{
			return;
		}
		Point point = Map.Get().WorldToCell(base.transform.position);
		if (point != lastCell)
		{
			lastCell = point;
			MapChunk mapChunk = MapChunk.At(point);
			if (mapChunk != chunks[0])
			{
				chunks[0].RemoveGeometry(base.gameObject, removeFromCombineList: false, checkVisibilityCount: true);
				mapChunk.AddGeometry(base.gameObject, addTracker: false);
				chunks[0] = mapChunk;
			}
		}
	}

	public static void AddToTracker(GameObject obj, MapChunk chunk)
	{
		OcclusionTrackerStatic occlusionTrackerStatic = obj.GetComponent<OcclusionTrackerStatic>();
		if (occlusionTrackerStatic == null)
		{
			occlusionTrackerStatic = obj.AddComponent<OcclusionTrackerStatic>();
		}
		if (occlusionTrackerStatic.margin == 0)
		{
			occlusionTrackerStatic.AddChunk(chunk);
			occlusionTrackerStatic.addOnStart = false;
		}
	}
}
public class OcclusionTrackerStatic : MonoBehaviour
{
	public bool addOnStart = true;

	public int margin;

	protected List<MapChunk> chunks;

	protected void Start()
	{
		if (addOnStart)
		{
			if (margin == 0)
			{
				MapChunk mapChunk = MapChunk.At(Map.Get().WorldToCell(base.transform.position));
				mapChunk.AddGeometry(base.gameObject, addTracker: false);
				AddChunk(mapChunk);
			}
			else
			{
				Point point = Map.Get().WorldToCell(base.transform.position);
				MapChunk.AddGeometry(pos: new Point(point.X - margin, point.Y + margin), obj: base.gameObject, width: margin * 2 + 1, height: margin * 2 + 1);
			}
		}
		addOnStart = false;
	}

	private void OnDestroy()
	{
		if (chunks != null)
		{
			for (int i = 0; i < chunks.Count; i++)
			{
				chunks[i].RemoveGeometry(base.gameObject);
			}
		}
	}

	public void AddChunk(MapChunk chunk)
	{
		if (chunks == null)
		{
			chunks = new List<MapChunk>();
		}
		chunks.Add(chunk);
	}
}
public class Room
{
	public delegate void RoomCallback(Room room);

	public int Id;

	public Point Start;

	public Point Size;

	public RoomTemplate Template;

	public bool Safe;

	public bool IsSpawnRoom;

	public bool IsExitRoom;

	public bool IsHorror;

	public bool IsWellLayout;

	public List<PropInfo> props;

	public List<InteractiveLightEx> lights;

	public int numLightcasters;

	public List<GameObject> gargoyles;

	public List<Floater> floaters;

	public List<CreatureCounter> creatures;

	public bool hasBats;

	public List<Point> doors;

	public List<Point> entrances;

	public RoomCallback OnEnter;

	public RoomCallback OnFirstEnter;

	public RoomCallback OnExit;

	private bool playerEverEntered;

	private bool playerInside;

	public bool IsDeadEnd;

	public bool HasLocalEnemy;

	private List<Point> listValidPos;

	private List<Point> listValidCentralPos;

	public bool PlayerEverEntered => playerEverEntered;

	public bool PlayerInside => playerInside;

	public Room(int roomID, int StartX, int StartY, int SizeX, int SizeY, RoomTemplate template)
	{
		Id = roomID;
		Start = new Point(StartX, StartY);
		Size = new Point(SizeX, SizeY);
		Template = template;
		Safe = false;
		IsSpawnRoom = false;
		IsExitRoom = false;
		IsHorror = false;
		IsWellLayout = false;
		IsDeadEnd = false;
		HasLocalEnemy = false;
		props = new List<PropInfo>();
		lights = new List<InteractiveLightEx>();
		gargoyles = new List<GameObject>();
		floaters = new List<Floater>();
		creatures = new List<CreatureCounter>();
		doors = new List<Point>();
		entrances = new List<Point>();
	}

	public void PlayerEnter()
	{
		playerInside = true;
		if (!playerEverEntered && OnFirstEnter != null)
		{
			OnFirstEnter(this);
		}
		playerEverEntered = true;
		if (OnEnter != null)
		{
			OnEnter(this);
		}
		if (hasBats)
		{
			GameController.Get().GetComponent<MapBuilder>().SpawnBats(this);
			hasBats = false;
		}
	}

	public void PlayerExit()
	{
		playerInside = false;
		if (OnExit != null)
		{
			OnExit(this);
		}
	}

	public void BuildValidPosLists()
	{
		if (listValidPos != null && listValidCentralPos != null)
		{
			return;
		}
		listValidPos = new List<Point>();
		listValidCentralPos = new List<Point>();
		for (int i = Start.Y; i < Start.Y + Size.Y; i++)
		{
			for (int j = Start.X; j < Start.X + Size.X; j++)
			{
				Point point = new Point(j, i);
				if (point.Y > 0 && point.Y < Map.Get().Height - 1 && point.X > 0 && point.X < Map.Get().Width - 1 && Map.Get().At(point.X, point.Y).IsClear() && Map.Get().At(point.X, point.Y).Room == this && !Map.Get().At(point.X, point.Y).IsDoor)
				{
					listValidPos.Add(point);
					if (Map.Get().At(point.X, point.Y - 1).IsClearOrPit() && Map.Get().At(point.X, point.Y + 1).IsClearOrPit() && Map.Get().At(point.X - 1, point.Y).IsClearOrPit() && Map.Get().At(point.X + 1, point.Y).IsClearOrPit() && Map.Get().At(point).GetNumAdjacentWalls() == 0)
					{
						listValidCentralPos.Add(point);
					}
				}
			}
		}
	}

	public Point GetRandomPoint(bool central = false)
	{
		if (listValidPos == null || listValidCentralPos == null)
		{
			BuildValidPosLists();
		}
		if (listValidPos.Count == 0)
		{
			Debug.LogError("No valid positions inside the room");
		}
		if (central && listValidCentralPos.Count > 0)
		{
			return RandomExt.Choice(listValidCentralPos);
		}
		return RandomExt.Choice(listValidPos);
	}

	public List<Point> GetListValidPos()
	{
		if (listValidPos == null)
		{
			GetRandomPoint();
		}
		return listValidPos;
	}

	public List<Point> GetListValidCentralPos()
	{
		if (listValidCentralPos == null)
		{
			GetRandomPoint();
		}
		return listValidCentralPos;
	}
}
public enum OptionFlag
{
	Any,
	Yes,
	No
}
public class RoomTemplate : ScriptableObject
{
	public enum SizeType
	{
		Small,
		Medium,
		Large,
		Hub
	}

	[Serializable]
	public class Flags
	{
		public enum CeilingHint
		{
			None,
			Horizontal,
			Vertical
		}

		public bool canBeSafe;

		public int maxLightcasters = 2;

		public bool enableBats;

		public ClockMode.Mode clockMode;

		public int minConnections;

		public bool dungeonStyle = true;

		public bool templeStyle = true;

		public bool catacombStyle = true;

		public CeilingHint ceilingHint;

		public bool CheckStyle(MapStyle style)
		{
			if (!dungeonStyle && style.GetMainTag() == "dungeon")
			{
				return false;
			}
			if (!templeStyle && style.GetMainTag() == "temple")
			{
				return false;
			}
			if (!catacombStyle && style.GetMainTag() == "catacomb")
			{
				return false;
			}
			return true;
		}
	}

	[Serializable]
	public class PropMarker
	{
		public enum Direction
		{
			Auto,
			Right,
			Down,
			Left,
			Up
		}

		public CPoint pos;

		public int width;

		public int height;

		public PropInfo propInfo;

		public bool propArea;

		public int groupIndex = -1;

		public Direction direction;

		public Vector2 deltaOffset;

		public float probability = 0.8f;

		public OptionFlag exitMarker;

		public OptionFlag exitCollectable;

		public OptionFlag lightCaster;

		public OptionFlag standAlone;

		public OptionFlag important;

		public OptionFlag generic;

		public OptionFlag horror;

		public OptionFlag container;

		public OptionFlag tall;

		public OptionFlag wallProp;

		public List<string> tags;

		public PropMarker(CPoint pos, PropMarker from)
		{
			this.pos = pos;
			width = from.width;
			height = from.height;
			propInfo = from.propInfo;
			propArea = from.propArea;
			groupIndex = from.groupIndex;
			direction = from.direction;
			deltaOffset = from.deltaOffset;
			probability = from.probability;
			exitMarker = from.exitMarker;
			exitCollectable = from.exitCollectable;
			lightCaster = from.lightCaster;
			standAlone = from.standAlone;
			important = from.important;
			generic = from.generic;
			horror = from.horror;
			container = from.container;
			tall = from.tall;
			wallProp = from.wallProp;
			if (from.tags != null)
			{
				tags = new List<string>();
				for (int i = 0; i < from.tags.Count; i++)
				{
					tags.Add(from.tags[i]);
				}
			}
			else
			{
				tags = null;
			}
		}

		public void RotateCW()
		{
			int num = width;
			width = height;
			height = num;
			if (direction != 0)
			{
				direction++;
				if (direction > Direction.Up)
				{
					direction = Direction.Right;
				}
			}
		}

		public void RotateCCW()
		{
			int num = width;
			width = height;
			height = num;
			if (direction != 0)
			{
				direction--;
				if (direction <= Direction.Auto)
				{
					direction = Direction.Up;
				}
			}
		}

		public bool IsPositionInside(Point posCheck)
		{
			return posCheck.X >= pos.X && posCheck.X < pos.X + width && posCheck.Y >= pos.Y && posCheck.Y < pos.Y + width;
		}
	}

	[Serializable]
	public class Layout
	{
		[Serializable]
		public class Flags
		{
			public OptionFlag safe;

			public OptionFlag horror;
		}

		public string name;

		public bool ignore;

		[Range(0f, 10f)]
		public float weight = 1f;

		[Range(0f, 1f)]
		public float propClutter = 1f;

		public List<PropMarker> props;

		public Flags flags;

		public Layout()
		{
			name = string.Empty;
			flags = new Flags();
			props = new List<PropMarker>();
		}
	}

	public int width;

	public int height;

	public bool ignore;

	[Range(0f, 10f)]
	public float weight = 1f;

	public SizeType size;

	public Flags flags;

	public CellType[] baseLayout;

	public List<CPoint> doors;

	public List<CPoint> doubleDoors;

	public List<Layout> layouts;

	public static List<RoomTemplate> roomTemplates;

	public static List<RoomTemplate> hubTemplates;

	public static List<RoomTemplate> ignoredTemplates;

	public void Reset(int w, int h)
	{
		width = w;
		height = h;
		baseLayout = new CellType[h * w];
		for (int i = 0; i < h * w; i++)
		{
			baseLayout[i] = CellType.Rock;
		}
		doors = new List<CPoint>();
		doubleDoors = new List<CPoint>();
		layouts = new List<Layout>();
		flags = new Flags();
		flags.canBeSafe = false;
		size = SizeType.Small;
		base.name = string.Empty;
	}

	public CellType At(int x, int y)
	{
		return baseLayout[y * width + x];
	}

	public CellType At(Point pos)
	{
		return At(pos.X, pos.Y);
	}

	public void Set(int x, int y, CellType type)
	{
		baseLayout[y * width + x] = type;
	}

	public void Set(Point pos, CellType type)
	{
		Set(pos.X, pos.Y, type);
	}

	public static bool ReloadRoomTemplates(string templatesPath = "RoomTemplates")
	{
		RoomTemplate[] array = Resources.LoadAll<RoomTemplate>("RoomTemplates");
		roomTemplates = new List<RoomTemplate>();
		hubTemplates = new List<RoomTemplate>();
		ignoredTemplates = new List<RoomTemplate>();
		RoomTemplate[] array2 = array;
		foreach (RoomTemplate roomTemplate in array2)
		{
			if (roomTemplate.ignore)
			{
				ignoredTemplates.Add(roomTemplate);
			}
			else if (roomTemplate.size == SizeType.Hub)
			{
				hubTemplates.Add(roomTemplate);
			}
			else
			{
				roomTemplates.Add(roomTemplate);
			}
		}
		return true;
	}

	public static Room PlaceRoomTemplated(GBGenerator gen, int roomID, Point roomPos, RoomTemplate template = null, bool placeProps = true)
	{
		if (template == null)
		{
			template = RandomExt.Choice(roomTemplates);
		}
		return template.PlaceRoom(gen, roomID, roomPos, placeProps);
	}

	public static Room PlaceRoomTemplated(GBGenerator gen, int roomID, Point roomPos, MapStyle smallStyle = null, MapStyle mediumStyle = null, MapStyle largeStyle = null, bool placeProps = true)
	{
		RoomTemplate roomTemplate = null;
		int num = 100;
		while (num > 0 && roomTemplate == null)
		{
			num--;
			roomTemplate = RandomExt.Choice(roomTemplates);
			if (roomTemplate.size == SizeType.Small && !roomTemplate.flags.CheckStyle(smallStyle))
			{
				roomTemplate = null;
			}
			else if (roomTemplate.size == SizeType.Medium && !roomTemplate.flags.CheckStyle(mediumStyle))
			{
				roomTemplate = null;
			}
			else if (roomTemplate.size == SizeType.Large && !roomTemplate.flags.CheckStyle(largeStyle))
			{
				roomTemplate = null;
			}
		}
		if (roomTemplate == null)
		{
			return null;
		}
		return roomTemplate.PlaceRoom(gen, roomID, roomPos, placeProps);
	}

	public static RoomTemplate FindByName(string templateName)
	{
		for (int i = 0; i < ignoredTemplates.Count; i++)
		{
			if (ignoredTemplates[i].name == templateName)
			{
				return ignoredTemplates[i];
			}
		}
		for (int j = 0; j < roomTemplates.Count; j++)
		{
			if (roomTemplates[j].name == templateName)
			{
				return roomTemplates[j];
			}
		}
		for (int k = 0; k < hubTemplates.Count; k++)
		{
			if (hubTemplates[k].name == templateName)
			{
				return hubTemplates[k];
			}
		}
		return null;
	}

	public Room PlaceRoom(GBGenerator gen, int roomID, Point roomPos, bool placeProps = true)
	{
		Room room = new Room(roomID, roomPos.X, roomPos.Y, width, height, this);
		IntRect intRect = new IntRect(roomPos.X, roomPos.Y, width, height);
		if (intRect.left < 0 || intRect.right >= gen.Options.Width || intRect.top < 0 || intRect.bottom >= gen.Options.Height)
		{
			return null;
		}
		for (int i = intRect.top; i < intRect.bottom; i++)
		{
			for (int j = intRect.left; j < intRect.right; j++)
			{
				CellType cellType = gen.CellMap[i][j].Get();
				if (cellType == CellType.Room || cellType == CellType.Perimeter || cellType == CellType.Blocked)
				{
					return null;
				}
			}
		}
		for (int k = 0; k < height; k++)
		{
			for (int l = 0; l < width; l++)
			{
				CellType cellType2 = At(l, k);
				gen.CellMap[k + roomPos.Y][l + roomPos.X].Set(cellType2);
				if (cellType2 != 0)
				{
					gen.CellMap[k + roomPos.Y][l + roomPos.X].Room = room;
				}
				switch (cellType2)
				{
				case CellType.Shaft:
					gen.CellMap[k + roomPos.Y][l + roomPos.X].Set(CellType.Room);
					gen.CellMap[k + roomPos.Y][l + roomPos.X].CeilingShaft = true;
					break;
				case CellType.PitShaft:
					gen.CellMap[k + roomPos.Y][l + roomPos.X].Set(CellType.Pit);
					gen.CellMap[k + roomPos.Y][l + roomPos.X].CeilingShaft = true;
					break;
				}
			}
		}
		if (placeProps)
		{
			PlaceRoomProps(gen, room);
		}
		return room;
	}

	public static void PlaceRoomProps(GBGenerator gen, Room room)
	{
		RoomTemplate template = room.Template;
		Point start = room.Start;
		List<Pair<Layout, float>> list = new List<Pair<Layout, float>>();
		for (int i = 0; i < template.layouts.Count; i++)
		{
			if (!template.layouts[i].ignore)
			{
				list.Add(new Pair<Layout, float>(template.layouts[i], template.layouts[i].weight));
			}
		}
		Layout layout = RandomExt.WeightedChoice(list);
		float num = 1f;
		if (room.IsDeadEnd)
		{
			num = ((room.Template.size != 0) ? 1.5f : 2f);
		}
		foreach (PropMarker prop in layout.props)
		{
			float num2 = prop.probability * layout.propClutter * num;
			if (!(prop.propInfo == null) || !(UnityEngine.Random.value > num2))
			{
				gen.PropPositions.Add(new PropMarker(new CPoint(prop.pos.X + start.X, prop.pos.Y + start.Y), prop));
			}
		}
		if (layout.flags.horror == OptionFlag.Yes)
		{
			room.IsHorror = true;
		}
		if (layout.name == "well" || layout.name == "Well")
		{
			room.IsWellLayout = true;
		}
		if (template.flags.enableBats && UnityEngine.Random.value <= 0.4f)
		{
			room.hasBats = true;
		}
	}
}
public class TextureAtlas
{
	private static Dictionary<Shader, List<List<Material>>> dictShaderMats = new Dictionary<Shader, List<List<Material>>>();

	private static Dictionary<Material, Material> newMaterials = new Dictionary<Material, Material>();

	private static Dictionary<Material, Rect> newUVs = new Dictionary<Material, Rect>();

	public static void TestAtlas(Texture2D atlasTest, GameObject mapGeometry, Renderer atlasTestRenderer)
	{
		atlasTest = new Texture2D(4096, 4096);
		List<Texture2D> list = new List<Texture2D>();
		Renderer[] componentsInChildren = mapGeometry.GetComponentsInChildren<Renderer>();
		Renderer[] array = componentsInChildren;
		foreach (Renderer renderer in array)
		{
			Material[] sharedMaterials = renderer.sharedMaterials;
			foreach (Material material in sharedMaterials)
			{
				Texture2D texture2D = material.mainTexture as Texture2D;
				if (texture2D != null && !list.Contains(texture2D))
				{
					list.Add(texture2D);
				}
			}
		}
		Rect[] array2 = atlasTest.PackTextures(list.ToArray(), 0, 4096);
		atlasTestRenderer.material.mainTexture = atlasTest;
	}

	public static void BuildAtlas(GameObject[] geometry, out List<Texture2D> allTexs, bool remapTiling, float minRatio = 0f, List<Texture2D> atlasTexturesOut = null, List<Material> atlasMaterialsOut = null, List<Mesh> atlasMeshesOut = null, List<MeshFilter> atlasFiltersOut = null)
	{
		allTexs = null;
		if (geometry.Length == 0)
		{
			return;
		}
		List<MeshFilter> list = new List<MeshFilter>();
		for (int i = 0; i < geometry.Length; i++)
		{
			AtlasProp component = geometry[i].GetComponent<AtlasProp>();
			if (!(component != null) || !component.noAtlas)
			{
				list.AddRange(geometry[i].GetComponentsInChildren<MeshFilter>(includeInactive: true));
			}
		}
		BuildAtlas(list, out allTexs, remapTiling, minRatio, atlasTexturesOut, atlasMaterialsOut, atlasMeshesOut, atlasFiltersOut);
	}

	public static void BuildAtlas(List<MeshFilter> filters, out List<Texture2D> allTexs, bool remapTiling, float minRatio = 0f, List<Texture2D> atlasTexturesOut = null, List<Material> atlasMaterialsOut = null, List<Mesh> atlasMeshesOut = null, List<MeshFilter> atlasFiltersOut = null)
	{
		allTexs = null;
		dictShaderMats.Clear();
		newMaterials.Clear();
		newUVs.Clear();
		if (filters.Count == 0)
		{
			return;
		}
		AtlasProp[] array = new AtlasProp[filters.Count];
		List<MeshFilter> list = new List<MeshFilter>();
		for (int i = 0; i < filters.Count; i++)
		{
			Renderer component = filters[i].GetComponent<Renderer>();
			if (component == null)
			{
				continue;
			}
			array[i] = filters[i].GetComponent<AtlasProp>();
			if (array[i] != null)
			{
				if (array[i].noAtlas)
				{
					continue;
				}
				if (array[i].tiling != remapTiling)
				{
					list.Add(filters[i]);
					continue;
				}
			}
			Material[] sharedMaterials = component.sharedMaterials;
			Material[] array2 = sharedMaterials;
			foreach (Material material in array2)
			{
				if (material.shader != null && material.mainTexture != null && material.mainTextureOffset == Vector2.zero && material.mainTextureScale == new Vector2(1f, 1f))
				{
					Shader shader = material.shader;
					if (dictShaderMats.ContainsKey(shader))
					{
						dictShaderMats[shader][0].Add(material);
						continue;
					}
					List<Material> list2 = new List<Material>();
					list2.Add(material);
					List<List<Material>> list3 = new List<List<Material>>();
					list3.Add(list2);
					dictShaderMats[shader] = list3;
				}
			}
		}
		foreach (Shader key in dictShaderMats.Keys)
		{
			for (int k = 0; k < dictShaderMats[key].Count; k++)
			{
				float num = 0f;
				List<Material> list4 = dictShaderMats[key][k];
				Dictionary<Texture, Rect> dictionary = new Dictionary<Texture, Rect>();
				List<Material> list5 = new List<Material>();
				List<Material> list6 = new List<Material>();
				Material material2 = new Material(key);
				material2.CopyPropertiesFromMaterial(list4[0]);
				if (atlasMaterialsOut == null)
				{
					ClearMemory.AddRuntimeMaterial(material2);
				}
				else
				{
					atlasMaterialsOut.Add(material2);
				}
				allTexs = new List<Texture2D>();
				for (int l = 0; l < list4.Count; l++)
				{
					Texture2D texture2D = list4[l].mainTexture as Texture2D;
					if (!(texture2D != null))
					{
						continue;
					}
					bool flag = false;
					if (!allTexs.Contains(texture2D))
					{
						float num2 = num + (float)(texture2D.width * texture2D.height);
						float num3 = 16777216f / num2;
						if (num3 >= minRatio)
						{
							allTexs.Add(texture2D);
							if (remapTiling)
							{
								if (!TexturePacker.CheckPack(allTexs.ToArray(), 4096, extraSize: true))
								{
									allTexs.RemoveAt(allTexs.Count - 1);
								}
								else
								{
									num = num2;
									flag = true;
								}
							}
							else
							{
								num = num2;
								flag = true;
							}
						}
					}
					else
					{
						flag = true;
					}
					if (flag)
					{
						newMaterials[list4[l]] = material2;
						list6.Add(list4[l]);
					}
					else
					{
						list5.Add(list4[l]);
					}
				}
				if (list5.Count > 0)
				{
					List<Material> list7 = null;
					if (k + 1 >= dictShaderMats[key].Count)
					{
						list7 = new List<Material>();
						dictShaderMats[key].Add(list7);
					}
					else
					{
						list7 = dictShaderMats[key][k + 1];
					}
					list7.AddRange(list5);
				}
				Rect[] array3 = null;
				Texture2D packTexture;
				if (remapTiling)
				{
					array3 = TexturePacker.Pack(out packTexture, allTexs.ToArray(), 4096, extraSize: true, atlasTexturesOut == null);
				}
				else
				{
					packTexture = new Texture2D(4096, 4096);
					array3 = packTexture.PackTextures(allTexs.ToArray(), 0, 4096, atlasTexturesOut == null);
				}
				if (atlasTexturesOut != null)
				{
					atlasTexturesOut.Add(packTexture);
				}
				else
				{
					ClearMemory.AddRuntimeTexture(packTexture);
				}
				if (array3 == null)
				{
					Debug.LogError("Insufficient space in the atlas texture!");
					return;
				}
				float num4 = packTexture.width * packTexture.height;
				Debug.Log("PackRatio: " + num4 / num + " (" + packTexture.width + "x" + packTexture.height + ") - " + allTexs.Count + " texs");
				for (int m = 0; m < allTexs.Count; m++)
				{
					dictionary[allTexs[m]] = array3[m];
				}
				material2.mainTexture = packTexture;
				for (int n = 0; n < list6.Count; n++)
				{
					newUVs[list6[n]] = dictionary[list6[n].mainTexture];
				}
			}
		}
		for (int num5 = 0; num5 < filters.Count; num5++)
		{
			Renderer component2 = filters[num5].GetComponent<Renderer>();
			if (component2 == null || (array[num5] != null && array[num5].noAtlas) || (array[num5] != null && array[num5].tiling && !remapTiling))
			{
				continue;
			}
			Material[] sharedMaterials2 = component2.sharedMaterials;
			Mesh mesh = filters[num5].mesh;
			atlasMeshesOut?.Add(mesh);
			atlasFiltersOut?.Add(filters[num5]);
			int subMeshCount = mesh.subMeshCount;
			Vector2[] array4 = mesh.uv;
			Vector2[] array5 = mesh.uv2;
			Vector2[] array6 = null;
			if (remapTiling)
			{
				array6 = new Vector2[array4.Length];
				array4.CopyTo(array6, 0);
			}
			Color[] array7 = mesh.colors;
			Vector3[] array8 = mesh.vertices;
			Vector3[] array9 = mesh.normals;
			int[][] array10 = new int[mesh.subMeshCount][];
			if (subMeshCount != sharedMaterials2.Length)
			{
				Debug.LogError("numSubMeshes != materials.Length");
			}
			int[] array11 = new int[mesh.uv.Length];
			for (int num6 = 0; num6 < array11.Length; num6++)
			{
				array11[num6] = 1000;
			}
			for (int num7 = 0; num7 < subMeshCount; num7++)
			{
				if (!newUVs.ContainsKey(sharedMaterials2[num7]))
				{
					continue;
				}
				Rect rect = newUVs[sharedMaterials2[num7]];
				array10[num7] = mesh.GetTriangles(num7);
				int[] array12 = array10[num7];
				List<Pair<int, Point>> list8 = new List<Pair<int, Point>>();
				if (remapTiling)
				{
					for (int num8 = 0; num8 < array12.Length / 3; num8++)
					{
						bool flag2 = false;
						Point[] array13 = new Point[3];
						for (int num9 = 0; num9 < 3; num9++)
						{
							ref Point reference = ref array13[num9];
							reference = new Point(0, 0);
							int num10 = array12[num8 * 3 + num9];
							if (flag2 || array11[num10] < num7)
							{
								flag2 = true;
							}
							else if (!float.IsPositiveInfinity(array4[num10].x) && !float.IsNegativeInfinity(array4[num10].x) && !float.IsPositiveInfinity(array4[num10].y) && !float.IsNegativeInfinity(array4[num10].y))
							{
								while (array4[num10].x + (float)array13[num9].X >= 1.5f)
								{
									array13[num9].X--;
								}
								while (array4[num10].x + (float)array13[num9].X < -0.5f)
								{
									array13[num9].X++;
								}
								while (array4[num10].y + (float)array13[num9].Y >= 1.5f)
								{
									array13[num9].Y--;
								}
								while (array4[num10].y + (float)array13[num9].Y < -0.5f)
								{
									array13[num9].Y++;
								}
							}
						}
						if (flag2)
						{
							list8.Add(new Pair<int, Point>(num8, new Point(0, 0)));
						}
						else if (array13[0] != array13[1] || array13[1] != array13[2])
						{
							Point second = array13[0];
							if (second.X == 0 && array13[1].X != 0)
							{
								second.X = array13[1].X;
							}
							if (second.X == 0 && array13[2].X != 0)
							{
								second.X = array13[2].X;
							}
							if (second.Y == 0 && array13[1].Y != 0)
							{
								second.Y = array13[1].Y;
							}
							if (second.Y == 0 && array13[2].Y != 0)
							{
								second.Y = array13[2].Y;
							}
							list8.Add(new Pair<int, Point>(num8, second));
						}
					}
					int num11 = array4.Length;
					int num12 = list8.Count * 3;
					if (num12 > 0)
					{
						Vector3[] array14 = new Vector3[num11 + num12];
						Color[] array15 = new Color[num11 + num12];
						Vector3[] array16 = new Vector3[num11 + num12];
						Vector2[] array17 = new Vector2[num11 + num12];
						Vector2[] array18 = new Vector2[num11 + num12];
						array8.CopyTo(array14, 0);
						array9.CopyTo(array16, 0);
						array4.CopyTo(array17, 0);
						array5.CopyTo(array18, 0);
						array7.CopyTo(array15, 0);
						array4 = array17;
						array5 = array18;
						array7 = array15;
						array8 = array14;
						array9 = array16;
					}
					for (int num13 = 0; num13 < list8.Count; num13++)
					{
						for (int num14 = 0; num14 < 3; num14++)
						{
							int num15 = array12[list8[num13].First * 3 + num14];
							int num16 = num11 + num14;
							ref Vector3 reference2 = ref array8[num16];
							reference2 = array8[num15];
							ref Color reference3 = ref array7[num16];
							reference3 = array7[num15];
							ref Vector3 reference4 = ref array9[num16];
							reference4 = array9[num15];
							ref Vector2 reference5 = ref array4[num16];
							reference5 = array4[num15];
							if (array11[num15] < num7)
							{
								ref Vector2 reference6 = ref array4[num16];
								reference6 = array6[num15];
							}
							array4[num16].x += list8[num13].Second.X;
							array4[num16].y += list8[num13].Second.Y;
							ref Vector2 reference7 = ref array5[num16];
							reference7 = array5[num15];
						}
						int num17 = list8[num13].First * 3;
						array12[num17] = num11;
						array12[num17 + 1] = num11 + 1;
						array12[num17 + 2] = num11 + 2;
						num11 += 3;
					}
				}
				bool[] array19 = new bool[array4.Length];
				for (int num18 = 0; num18 < array19.Length; num18++)
				{
					array19[num18] = false;
				}
				foreach (int num20 in array12)
				{
					if (array19[num20])
					{
						continue;
					}
					if (remapTiling && !float.IsPositiveInfinity(array4[num20].x) && !float.IsNegativeInfinity(array4[num20].x) && !float.IsPositiveInfinity(array4[num20].y) && !float.IsNegativeInfinity(array4[num20].y))
					{
						while (array4[num20].x >= 1.5f)
						{
							array4[num20].x -= 1f;
						}
						while (array4[num20].x < -0.5f)
						{
							array4[num20].x += 1f;
						}
						while (array4[num20].y >= 1.5f)
						{
							array4[num20].y -= 1f;
						}
						while (array4[num20].y < -0.5f)
						{
							array4[num20].y += 1f;
						}
					}
					ref Vector2 reference8 = ref array4[num20];
					reference8 = new Vector2(array4[num20].x * rect.width + rect.x, array4[num20].y * rect.height + rect.y);
					if (num20 < array11.Length)
					{
						array11[num20] = num7;
					}
					array19[num20] = true;
				}
				sharedMaterials2[num7] = newMaterials[sharedMaterials2[num7]];
			}
			if (atlasMaterialsOut == null || atlasFiltersOut != null)
			{
				component2.sharedMaterials = sharedMaterials2;
			}
			if (remapTiling)
			{
				if (array8 != null)
				{
					mesh.vertices = array8;
				}
				if (array9 != null)
				{
					mesh.normals = array9;
				}
				mesh.colors = array7;
				if (array5 != null)
				{
					mesh.uv2 = array5;
				}
			}
			mesh.uv = array4;
			if (remapTiling)
			{
				for (int num21 = 0; num21 < mesh.subMeshCount; num21++)
				{
					mesh.SetTriangles(array10[num21], num21);
				}
			}
		}
		if (list.Count > 0)
		{
			BuildAtlas(list, out allTexs, !remapTiling, minRatio, atlasTexturesOut, atlasMaterialsOut, atlasMeshesOut, atlasFiltersOut);
		}
	}

	public static void SetSimpleMaterials(GameObject obj)
	{
		MeshFilter[] componentsInChildren = obj.GetComponentsInChildren<MeshFilter>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			Renderer component = componentsInChildren[i].GetComponent<Renderer>();
			if (component == null)
			{
				continue;
			}
			Material[] sharedMaterials = component.sharedMaterials;
			Material[] array = sharedMaterials;
			foreach (Material material in array)
			{
				if (material.shader != null && material.mainTexture != null)
				{
					material.shader = Shader.Find("Mobile/Diffuse");
				}
			}
		}
	}

	public static void SetTexturesReadable(List<GameObject> objs, out List<Texture2D> allTexs)
	{
		allTexs = new List<Texture2D>();
		dictShaderMats.Clear();
		newMaterials.Clear();
		newUVs.Clear();
		List<MeshFilter> list = new List<MeshFilter>();
		for (int i = 0; i < objs.Count; i++)
		{
			list.AddRange(objs[i].GetComponentsInChildren<MeshFilter>(includeInactive: true));
		}
		for (int j = 0; j < list.Count; j++)
		{
			Renderer component = list[j].GetComponent<Renderer>();
			if (component == null)
			{
				continue;
			}
			Material[] sharedMaterials = component.sharedMaterials;
			Material[] array = sharedMaterials;
			foreach (Material material in array)
			{
				if (material.shader != null && material.mainTexture != null && material.mainTextureOffset == Vector2.zero && material.mainTextureScale == new Vector2(1f, 1f))
				{
					Shader shader = material.shader;
					if (dictShaderMats.ContainsKey(shader))
					{
						dictShaderMats[shader][0].Add(material);
						continue;
					}
					List<Material> list2 = new List<Material>();
					list2.Add(material);
					List<List<Material>> list3 = new List<List<Material>>();
					list3.Add(list2);
					dictShaderMats[shader] = list3;
				}
			}
		}
		foreach (Shader key in dictShaderMats.Keys)
		{
			List<Material> list4 = dictShaderMats[key][0];
			Dictionary<Texture, Rect> dictionary = new Dictionary<Texture, Rect>();
			for (int l = 0; l < list4.Count; l++)
			{
				Texture2D texture2D = list4[l].mainTexture as Texture2D;
				if (texture2D != null && !allTexs.Contains(texture2D))
				{
					allTexs.Add(texture2D);
				}
			}
		}
	}

	public static void Clear()
	{
		dictShaderMats = new Dictionary<Shader, List<List<Material>>>();
		newMaterials = new Dictionary<Material, Material>();
		newUVs = new Dictionary<Material, Rect>();
	}
}
public class TexturePacker
{
	private class TextureMarker
	{
		public Texture2D texture;

		public int width;

		public int height;
	}

	private class Node
	{
		public Node childLeft;

		public Node childRight;

		public IntRect coords;

		public TextureMarker imageTex;

		public Node()
		{
		}

		public Node(int w, int h)
		{
			coords = new IntRect(0, 0, w, h);
		}

		public Node Insert(TextureMarker img)
		{
			if (childLeft != null || childRight != null)
			{
				Node node = childLeft.Insert(img);
				if (node != null)
				{
					return node;
				}
				return childRight.Insert(img);
			}
			if (imageTex != null)
			{
				return null;
			}
			if (coords.width < img.width || coords.height < img.height)
			{
				return null;
			}
			if (coords.width == img.width && coords.height == img.height)
			{
				imageTex = img;
				return this;
			}
			childLeft = new Node();
			childRight = new Node();
			int num = coords.width - img.width;
			int num2 = coords.height - img.height;
			if (num > num2)
			{
				childLeft.coords = new IntRect(coords.left, coords.top, img.width, coords.height);
				childRight.coords = new IntRect(coords.left + img.width, coords.top, coords.width - img.width, coords.height);
			}
			else
			{
				childLeft.coords = new IntRect(coords.left, coords.top, coords.width, img.height);
				childRight.coords = new IntRect(coords.left, coords.top + img.height, coords.width, coords.height - img.height);
			}
			return childLeft.Insert(img);
		}
	}

	public static Rect[] Pack(out Texture2D packTexture, Texture2D[] images, int maxSize = 4096, bool extraSize = false, bool makeNoLongerReadable = true)
	{
		packTexture = null;
		int sizeW;
		int sizeH;
		IntRect[] intRects;
		TextureMarker[] array = PackRects(images, maxSize, extraSize, out sizeW, out sizeH, out intRects);
		packTexture = new Texture2D(sizeW, sizeH, TextureFormat.ARGB32, mipmap: true);
		packTexture.wrapMode = TextureWrapMode.Clamp;
		packTexture.filterMode = FilterMode.Bilinear;
		for (int i = 0; i < images.Length; i++)
		{
			int num = 0;
			if (!extraSize)
			{
				Color[] pixels = images[i].GetPixels(num);
				packTexture.SetPixels(intRects[i].x >> num, intRects[i].y >> num, intRects[i].width >> num, intRects[i].height >> num, pixels, num);
				continue;
			}
			Pair<IntRect, IntRect>[] array2 = new Pair<IntRect, IntRect>[9];
			IntRect first = new IntRect(0, 0, images[i].width, images[i].height);
			IntRect second = new IntRect(intRects[i].x + intRects[i].width / 4, intRects[i].y + intRects[i].height / 4, images[i].width, images[i].height);
			array2[4].First = first;
			array2[4].Second = second;
			int num2 = first.width / 2;
			int num3 = first.height / 2;
			int width = first.width;
			int height = first.height;
			array2[0].First = new IntRect(first.right - num2, first.bottom - num3, num2, num3);
			array2[0].Second = new IntRect(second.left - num2, second.top - num3, num2, num3);
			array2[1].First = new IntRect(0, num3, width, num3);
			array2[1].Second = new IntRect(second.left, second.top - num3, width, num3);
			array2[2].First = new IntRect(0, first.bottom - num3, num2, num3);
			array2[2].Second = new IntRect(second.right, second.top - num3, num2, num3);
			array2[3].First = new IntRect(first.right - num2, 0, num2, height);
			array2[3].Second = new IntRect(second.left - num2, second.top, num2, height);
			array2[5].First = new IntRect(0, 0, num2, height);
			array2[5].Second = new IntRect(second.right, second.top, num2, height);
			array2[6].First = new IntRect(first.right - num2, 0, num2, num3);
			array2[6].Second = new IntRect(second.left - num2, second.bottom, num2, num3);
			array2[7].First = new IntRect(0, 0, width, num3);
			array2[7].Second = new IntRect(second.left, second.bottom, width, num3);
			array2[8].First = new IntRect(0, 0, num2, num3);
			array2[8].Second = new IntRect(second.right, second.bottom, num2, num3);
			for (int j = 0; j < 9; j++)
			{
				Color[] pixels2 = images[i].GetPixels(array2[j].First.x, array2[j].First.y, array2[j].First.width, array2[j].First.height);
				packTexture.SetPixels(array2[j].Second.x, array2[j].Second.y, array2[j].Second.width, array2[j].Second.height, pixels2, num);
			}
		}
		packTexture.Apply(updateMipmaps: true, makeNoLongerReadable);
		Rect[] array3 = new Rect[images.Length];
		for (int k = 0; k < intRects.Length; k++)
		{
			if (extraSize)
			{
				ref Rect reference = ref array3[k];
				reference = new Rect((float)(intRects[k].left + intRects[k].width / 4) / (float)sizeW, (float)(intRects[k].top + intRects[k].height / 4) / (float)sizeH, (float)(intRects[k].width / 2) / (float)sizeW, (float)(intRects[k].height / 2) / (float)sizeH);
			}
			else
			{
				ref Rect reference2 = ref array3[k];
				reference2 = new Rect((float)intRects[k].left / (float)sizeW, (float)intRects[k].top / (float)sizeH, (float)intRects[k].width / (float)sizeW, (float)intRects[k].height / (float)sizeH);
			}
		}
		return array3;
	}

	public static bool CheckPack(Texture2D[] images, int maxSize = 4096, bool extraSize = false)
	{
		if (PackRects(images, maxSize, extraSize, out var _, out var _, out var _) == null)
		{
			return false;
		}
		return true;
	}

	private static TextureMarker[] PackRects(Texture2D[] images, int maxSize, bool extraSize, out int sizeW, out int sizeH, out IntRect[] intRects)
	{
		TextureMarker[] array = new TextureMarker[images.Length];
		sizeW = 0;
		sizeH = 0;
		for (int i = 0; i < images.Length; i++)
		{
			array[i] = new TextureMarker();
			array[i].texture = images[i];
			array[i].width = images[i].width * ((!extraSize) ? 1 : 2);
			array[i].height = images[i].height * ((!extraSize) ? 1 : 2);
			sizeW = Mathf.Max(sizeW, array[i].width);
			sizeH = Mathf.Max(sizeH, array[i].height);
		}
		intRects = new IntRect[images.Length];
		bool flag = false;
		while (!flag && sizeW <= maxSize && sizeH <= maxSize)
		{
			flag = true;
			Node node = new Node(sizeW, sizeH);
			for (int j = 0; j < images.Length; j++)
			{
				Node node2 = node.Insert(array[j]);
				if (node2 == null)
				{
					flag = false;
					if (sizeW <= sizeH)
					{
						sizeW *= 2;
					}
					else
					{
						sizeH *= 2;
					}
					break;
				}
				ref IntRect reference = ref intRects[j];
				reference = node2.coords;
			}
		}
		if (!flag)
		{
			return null;
		}
		return array;
	}
}
public class Trigger : MonoBehaviour
{
	public bool singleUse = true;

	public int countdown;

	public virtual void OnActivate(PlayerGameController player)
	{
		if (countdown > 0)
		{
			countdown--;
			return;
		}
		if (singleUse)
		{
			GetComponent<Collider>().enabled = false;
		}
		SendMessage("OnTrigger", player);
	}
}
public class VisibilityProbe : MonoBehaviour
{
	public bool IsVisible;

	public bool Discovered;

	private static Camera[] Cameras;

	public const float farDist = 20f;

	public LayerMask RayMask;

	public MapChunk chunk;

	private float timer;

	private float lastTimeChange;

	private bool flicking;

	public Bounds bounds;

	public bool addToStats = true;

	public int probeIndex;

	private static int probeCount;

	private void Start()
	{
		if (Cameras == null)
		{
			GameObject[] array = GameObject.FindGameObjectsWithTag(Tags.MainCamera);
			Cameras = new Camera[array.Length];
			for (int i = 0; i < array.Length; i++)
			{
				Cameras[i] = array[i].GetComponent<Camera>();
			}
		}
		chunk = MapChunk.At(Map.Get().WorldToCell(base.transform.position));
		if (GetComponent<Collider>() != null)
		{
			GetComponent<Collider>().enabled = false;
		}
		bounds.center = new Vector3(base.transform.position.x, bounds.center.y, base.transform.position.z);
		probeIndex = probeCount;
		probeCount++;
		VisibilityProbeManager.Get().AddProbe(this);
		if (addToStats)
		{
			PlayerStats.Get().AddProbe();
		}
	}

	public static void Clear()
	{
		Cameras = null;
	}

	public void CheckVisibility(Plane[][] frustumPlanes, Vector3 camPos)
	{
		if (timer > 0f)
		{
			timer -= Time.deltaTime;
		}
		lastTimeChange += Time.deltaTime;
		bool flag = timer > 0f;
		if (!flag && chunk.Visible)
		{
			float sqrMagnitude = (camPos - base.transform.position).sqrMagnitude;
			if (sqrMagnitude <= 400f)
			{
				bool flag2 = false;
				int num = 0;
				while (!flag2 && num < frustumPlanes.Length)
				{
					Plane[] planes = frustumPlanes[num];
					if (GeometryUtility.TestPlanesAABB(planes, bounds))
					{
						flag2 = true;
					}
					num++;
				}
				if (flag2 && CheckLoS(camPos))
				{
					flag = true;
					timer = ((!flicking) ? 0.15f : 0.55f);
				}
			}
		}
		if (IsVisible != flag)
		{
			if (lastTimeChange <= 0.3f)
			{
				flicking = true;
			}
			else
			{
				flicking = false;
			}
			lastTimeChange = 0f;
		}
		IsVisible = flag;
		if (!Discovered && IsVisible)
		{
			Discovered = true;
			if (addToStats)
			{
				PlayerStats.Get().AddDiscovered(Map.Get().WorldToCell(base.transform.position));
			}
		}
	}

	public bool CheckLoS(Vector3 cameraPos, int numRays = 1)
	{
		for (int i = 0; i < numRays; i++)
		{
			Vector3 position = base.transform.position;
			position.y += UnityEngine.Random.Range(0.2f, 3.3f);
			position.x += UnityEngine.Random.Range((0f - Map.Get().TileSize.x) / 2f, Map.Get().TileSize.x / 2f);
			position.z += UnityEngine.Random.Range((0f - Map.Get().TileSize.y) / 2f, Map.Get().TileSize.y / 2f);
			Vector3 direction = position - cameraPos;
			float magnitude = direction.magnitude;
			direction /= magnitude;
			if (!Physics.Raycast(cameraPos, direction, out var _, magnitude, RayMask))
			{
				return true;
			}
		}
		return false;
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.green;
		Gizmos.DrawWireCube(bounds.center, bounds.size);
	}
}
public class VisibilityProbeManager : MonoBehaviour
{
	private static VisibilityProbeManager instance;

	private List<VisibilityProbe> listProbes;

	private int numProbes;

	private Camera[] cameras;

	private Plane[][] frustumPlanes;

	private int curUpdateGroup;

	public int updateGroups = 4;

	public static VisibilityProbeManager Get()
	{
		return instance;
	}

	public static void Clear()
	{
		instance = null;
	}

	private void Awake()
	{
		instance = this;
		listProbes = new List<VisibilityProbe>();
	}

	private void Start()
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag(Tags.MainCamera);
		cameras = new Camera[array.Length];
		for (int i = 0; i < array.Length; i++)
		{
			cameras[i] = array[i].GetComponent<Camera>();
		}
		frustumPlanes = new Plane[cameras.Length][];
	}

	private void Update()
	{
		for (int i = 0; i < cameras.Length; i++)
		{
			frustumPlanes[i] = GeometryUtility.CalculateFrustumPlanes(cameras[i]);
		}
		Vector3 centerEye = Player.GetCenterEye();
		for (int j = 0; j < listProbes.Count; j++)
		{
			VisibilityProbe visibilityProbe = listProbes[j];
			if (visibilityProbe.probeIndex % updateGroups == curUpdateGroup)
			{
				visibilityProbe.CheckVisibility(frustumPlanes, centerEye);
			}
		}
		curUpdateGroup++;
		if (curUpdateGroup >= updateGroups)
		{
			curUpdateGroup = 0;
		}
	}

	public void AddProbe(VisibilityProbe probe)
	{
		MapChunk chunk = probe.chunk;
		listProbes.Add(probe);
		numProbes++;
	}
}
[RequireComponent(typeof(Trigger))]
public class Checkpoint : MonoBehaviour
{
	public int setCheckpoint;

	public bool incrementCheckpoint;

	public bool setMetaMap;

	public int metaMap = 1;

	private void Start()
	{
		if (GameState.Get().checkPoint >= setCheckpoint && (!setMetaMap || GameState.Get().metaMap == metaMap))
		{
			GetComponent<Collider>().enabled = false;
		}
	}

	public void OnTrigger(PlayerGameController player)
	{
		if (incrementCheckpoint)
		{
			MetaProgress.Get().ActivateNext(Vector3.zero, save: false, 0f);
			GameState.Get().checkPoint++;
		}
		else
		{
			GameState.Get().checkPoint = setCheckpoint;
			MetaProgress.Get().nextToOpen = setCheckpoint;
		}
		if (setMetaMap)
		{
			GameState.Get().metaMap = metaMap;
		}
		GameController.Get().SaveGame();
		Tutorial.Get().Save();
	}
}
[RequireComponent(typeof(Trigger))]
public class EndGameTrigger : MonoBehaviour
{
	public string endingScene = "Ending";

	public void OnTrigger(PlayerGameController player)
	{
		Fader component = GameObject.Find("Fader").GetComponent<Fader>();
		component.SetColor(Color.white);
		component.FadeOut(2f, fadeAudio: true, base.gameObject);
	}

	public void OnEndFade(Fader fader)
	{
		Loader.nextScene = endingScene;
		UnityEngine.Application.LoadLevel("LoadingEnd");
	}
}
[RequireComponent(typeof(Trigger))]
public class EndLiteDemoTrigger : MonoBehaviour
{
	public void OnTrigger(PlayerGameController player)
	{
		Fader component = GameObject.Find("Fader").GetComponent<Fader>();
		component.FadeOut(2f, fadeAudio: true, base.gameObject);
	}

	public void OnEndFade(Fader fader)
	{
		GameOver.Display("END_LITE_DEMO", "Intro", "EndLiteDemo");
	}
}
public class EndMetaProgress : FSMComponent<EndMetaProgress.States>
{
	public enum States
	{
		Disabled,
		FirstPillarOn,
		SecondPillarOn
	}

	public Transform exitPortal;

	public EndGameTrigger endTrigger;

	public bool spawnCreatures = true;

	public Transform[] shadowChaserSpawns;

	public Transform ghostSpawn;

	private Pillar pillarLeft;

	private Pillar pillarRight;

	private bool pillarLeftOn;

	private bool pillarRightOn;

	public GameObject portalOpenFX;

	public AudioSource portalLoopSound;

	public AudioSource portarOpenSound;

	private void Start()
	{
		MetaProgress.Get().onActivateNext = OnActivateNext;
		pillarLeft = GameObject.Find("Obelisk_4").GetComponent<Pillar>();
		pillarRight = GameObject.Find("Obelisk_3").GetComponent<Pillar>();
		Init(States.Disabled);
	}

	private void Disabled_Enter()
	{
		exitPortal.gameObject.SetActive(value: false);
		endTrigger.gameObject.SetActive(value: false);
		pillarLeftOn = (pillarRightOn = false);
	}

	private void FirstPillarOn_Enter()
	{
		Pillar closestPillar = GetClosestPillar(Player.GetGroundPos());
		if (closestPillar == pillarLeft)
		{
			pillarLeftOn = true;
			pillarLeft.ActivateEffects();
			Debug.Log("Left Pillar Activated");
		}
		else
		{
			pillarRightOn = true;
			pillarRight.ActivateEffects();
			Debug.Log("Right Pillar Activated");
		}
		Player.GetComponent<SpookSounds>().forceShadowSounds = true;
	}

	private void SecondPillarOn_Enter()
	{
		if (pillarLeftOn)
		{
			pillarRightOn = true;
			pillarRight.ActivateEffects();
			Debug.Log("Right Pillar Activated");
		}
		else
		{
			pillarLeftOn = true;
			pillarLeft.ActivateEffects();
			Debug.Log("Left Pillar Activated");
		}
		StartCoroutine(ActivatePortal_co());
	}

	public void OnActivateNext(Vector3 spawnPos, float delayOpen, bool save, float delaySave)
	{
		StartCoroutine(OnActivateNext_co(spawnPos, delayOpen));
	}

	private IEnumerator OnActivateNext_co(Vector3 spawnPos, float delay = 1f)
	{
		yield return new WaitForSeconds(delay);
		if (base.State == States.Disabled)
		{
			base.State = States.FirstPillarOn;
		}
		else if (base.State == States.FirstPillarOn)
		{
			base.State = States.SecondPillarOn;
		}
	}

	private IEnumerator ActivatePortal_co()
	{
		pillarLeft.ActivateLightning(portalOpenFX.transform);
		pillarRight.ActivateLightning(portalOpenFX.transform);
		portalLoopSound.enabled = true;
		yield return new WaitForSeconds(0.5f);
		portarOpenSound.enabled = true;
		portalOpenFX.SetActive(value: true);
		yield return new WaitForSeconds(0.8f);
		exitPortal.gameObject.SetActive(value: true);
		endTrigger.gameObject.SetActive(value: true);
		StartCoroutine(ScalePortalSize_co());
		if (spawnCreatures)
		{
			yield return new WaitForSeconds(2f);
			SpawnGhost();
			yield return new WaitForSeconds(6f);
			SpawnShadows();
		}
	}

	private IEnumerator ScalePortalSize_co()
	{
		Transform sph = exitPortal.GetChild(0);
		Vector3 curScale = sph.localScale;
		sph.localScale = Vector3.zero;
		float progress = 0f;
		while (progress <= 1f)
		{
			yield return 0;
			progress += Time.deltaTime;
			sph.localScale = Interpolate.EaseOutCubic(Vector3.zero, curScale, progress);
		}
	}

	private void SpawnShadows()
	{
		ShadowChaser shadowChaser = GameController.Get().GetComponent<ShadowFolkManager>().shadowChaser;
		for (int i = 0; i < shadowChaserSpawns.Length; i++)
		{
			ShadowChaser shadowChaser2 = UnityEngine.Object.Instantiate(shadowChaser, shadowChaserSpawns[i].position, shadowChaserSpawns[i].rotation);
			shadowChaser2.isVision = false;
			shadowChaser2.isAngry = true;
			shadowChaser2.superAggressive = true;
		}
	}

	private void SpawnGhost()
	{
		Ghost component = GameController.Get().GetComponent<GhostSpawner>().GhostPrefab.GetComponent<Ghost>();
		Ghost ghost = UnityEngine.Object.Instantiate(component, ghostSpawn.position, ghostSpawn.rotation);
		ghost.isAngryAppear = true;
		ghost.isVision = false;
		ghost.canStretch = true;
	}

	private Pillar GetClosestPillar(Vector3 pos)
	{
		float sqrMagnitude = (pillarLeft.transform.position - pos).sqrMagnitude;
		float sqrMagnitude2 = (pillarRight.transform.position - pos).sqrMagnitude;
		if (sqrMagnitude < sqrMagnitude2)
		{
			return pillarLeft;
		}
		return pillarRight;
	}
}
[RequireComponent(typeof(Trigger))]
public class EnterLevelTrigger : MonoBehaviour
{
	public LevelOptions[] levelOptions;

	public void OnTrigger(PlayerGameController player)
	{
		Fader component = GameObject.Find("Fader").GetComponent<Fader>();
		component.FadeOut(2f, fadeAudio: true, base.gameObject);
	}

	public void OnEndFade(Fader fader)
	{
		LevelOptions nextOptions = RandomExt.Choice(levelOptions);
		GameController.nextOptions = nextOptions;
		GameState.Get().Refresh(overwriteMap: false);
		Loader.LoadLevel("Dungeon");
	}
}
public class MetaMapAfterBuild_01 : MonoBehaviour
{
	public GameObject triggers;

	public void DoBuild()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(triggers, Vector3.zero, Quaternion.identity);
		bool flag = GameController.Get().levelOptions.serializeID == GameState.Get().metaMap;
		int num = 0;
		if (flag)
		{
			num = GameState.Get().checkPoint;
		}
		Transform transform = gameObject.transform.Find("spawn_" + num);
		if (transform != null)
		{
			if (InputExt.Using3DOFController)
			{
				AfterBuild.AdjustSpawnRotation(transform);
			}
			Transform transform2 = Player.Get().transform;
			Vector3 position = transform.transform.position;
			position.y = transform2.position.y;
			Vector3 forward = transform.transform.forward.GroundNormalize();
			transform2.position = position;
			transform2.rotation = Quaternion.LookRotation(forward, Vector3.up);
		}
		if (GameController.Get().gameState.liteVersion)
		{
			for (char c = 'B'; c <= 'D'; c = (char)(c + 1))
			{
				GameObject gameObject2 = GameObject.Find("exit" + c);
				if (gameObject2 != null)
				{
					EnterLevelTrigger component = gameObject2.GetComponent<EnterLevelTrigger>();
					if ((bool)component)
					{
						UnityEngine.Object.Destroy(component);
					}
					gameObject2.AddComponent<EndLiteDemoTrigger>();
				}
			}
			GameObject gameObject3 = GameObject.Find("exitA");
			EnterLevelTrigger component2 = gameObject3.GetComponent<EnterLevelTrigger>();
			component2.levelOptions[0] = Resources.Load<LevelOptions>("LevelOptions/01_A_Lite");
		}
		if (flag)
		{
			Minimap component3 = GameObject.FindWithTag(Tags.Minimap).GetComponent<Minimap>();
			component3.loadFromSavegame = true;
		}
		if (flag)
		{
			StartCoroutine(DeserializeObjs_co());
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private IEnumerator DeserializeObjs_co()
	{
		yield return 0;
		GameController.Get().serializer.DeserializeRegisteredObjs();
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class MetaMapAfterBuild_02 : MonoBehaviour
{
	public GameObject triggers;

	public void DoBuild()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(triggers, Vector3.zero, Quaternion.identity);
		bool flag = GameController.Get().levelOptions.serializeID == GameState.Get().metaMap;
		int num = 0;
		if (flag)
		{
			num = GameState.Get().checkPoint;
		}
		Transform transform = gameObject.transform.Find("spawn_" + num);
		if (transform != null)
		{
			if (InputExt.Using3DOFController)
			{
				AfterBuild.AdjustSpawnRotation(transform);
			}
			Transform transform2 = Player.Get().transform;
			Vector3 position = transform.transform.position;
			position.y = transform2.position.y;
			Vector3 forward = transform.transform.forward.GroundNormalize();
			transform2.position = position;
			transform2.rotation = Quaternion.LookRotation(forward, Vector3.up);
		}
		if (flag)
		{
			Minimap component = GameObject.FindWithTag(Tags.Minimap).GetComponent<Minimap>();
			component.loadFromSavegame = true;
		}
		if (flag)
		{
			StartCoroutine(DeserializeObjs_co());
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private IEnumerator DeserializeObjs_co()
	{
		yield return 0;
		GameController.Get().serializer.DeserializeRegisteredObjs();
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class MetaMapAfterBuild_03 : MonoBehaviour
{
	public GameObject triggers;

	public void DoBuild()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(triggers, Vector3.zero, Quaternion.identity);
		bool flag = GameController.Get().levelOptions.serializeID == GameState.Get().metaMap;
		int num = 0;
		if (flag)
		{
			num = GameState.Get().checkPoint;
		}
		Transform transform = gameObject.transform.Find("spawn_" + num);
		if (transform != null)
		{
			if (InputExt.Using3DOFController)
			{
				AfterBuild.AdjustSpawnRotation(transform);
			}
			Transform transform2 = Player.Get().transform;
			Vector3 position = transform.transform.position;
			position.y = transform2.position.y;
			Vector3 forward = transform.transform.forward.GroundNormalize();
			transform2.position = position;
			transform2.rotation = Quaternion.LookRotation(forward, Vector3.up);
		}
		if (flag)
		{
			Minimap component = GameObject.FindWithTag(Tags.Minimap).GetComponent<Minimap>();
			component.loadFromSavegame = true;
		}
		if (flag)
		{
			StartCoroutine(DeserializeObjs_co());
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private IEnumerator DeserializeObjs_co()
	{
		yield return 0;
		GameController.Get().serializer.DeserializeRegisteredObjs();
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class MetaMapAfterBuild_04 : MonoBehaviour
{
	public GameObject triggers;

	public void DoBuild()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(triggers, Vector3.zero, Quaternion.identity);
		bool flag = GameController.Get().levelOptions.serializeID == GameState.Get().metaMap;
		int num = 0;
		if (flag)
		{
			num = GameState.Get().checkPoint;
		}
		Transform transform = gameObject.transform.Find("spawn_" + num);
		if (transform != null)
		{
			if (InputExt.Using3DOFController)
			{
				AfterBuild.AdjustSpawnRotation(transform);
			}
			Transform transform2 = Player.Get().transform;
			Vector3 position = transform.transform.position;
			position.y = transform2.position.y;
			Vector3 forward = transform.transform.forward.GroundNormalize();
			transform2.position = position;
			transform2.rotation = Quaternion.LookRotation(forward, Vector3.up);
		}
		if (flag)
		{
			Minimap component = GameObject.FindWithTag(Tags.Minimap).GetComponent<Minimap>();
			component.loadFromSavegame = true;
		}
		if (flag)
		{
			StartCoroutine(DeserializeObjs_co());
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private IEnumerator DeserializeObjs_co()
	{
		yield return 0;
		GameController.Get().serializer.DeserializeRegisteredObjs();
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class MetaMapGenerator_01 : CustomGenerator
{
	protected override void DefineMap()
	{
		SetSeed(2393353562u);
		SetStyle(new string[3] { "dungeon", "room", "small" }, "tunnel_flat_reduced");
		SetStyle(new string[3] { "dungeon", "room", "medium" }, "tunnel_arched_reduced");
		SetStyle(new string[3] { "dungeon", "room", "large" }, "tunnel_arched_reduced");
		SetStyle(new string[3] { "dungeon", "room", "hub" }, "tunnel_high_arched_medium");
		SetStyle(new string[3] { "dungeon", "corridor", "narrow" }, "living_quarters");
		SetStyle(new string[3] { "dungeon", "corridor", "large" }, "tunnel_flat_reduced");
		int from = AddRoom("_meta_01_A", 12, 40);
		int to = AddRoom("_meta_01_B", 12, 34);
		int to2 = AddRoom("_meta_01_C", 20, 36);
		int num = AddRoom("_meta_01_D", 20, 30);
		int to3 = AddRoom("_meta_01_HUB", 26, 18);
		int from2 = AddRoom("_meta_01_exit_A", 18, 18);
		int from3 = AddRoom("_meta_01_exit_B", 30, 12);
		int from4 = AddRoom("_meta_01_exit_C", 42, 18);
		int from5 = AddRoom("_meta_01_exit_D", 30, 34);
		int from6 = AddRoom("_meta_01_E", 38, 30);
		AddCorridor(num, to3);
		AddCorridor(from, to);
		AddCorridor(from, to2);
		AddCorridor(from, num);
		AddCorridor(from2, to3, isDouble: true);
		AddCorridor(from3, to3, isDouble: true);
		AddCorridor(from4, to3, isDouble: true);
		AddCorridor(from5, to3, isDouble: true);
		AddCorridor(from6, to3);
		startRoom = from;
		exitRoom = from6;
		Options.DoorClutter = 1f;
	}

	public override void AfterGeneration()
	{
		RemoveDoor(new Point(38, 27));
		RemoveDoor(new Point(44, 33));
	}

	public override void AfterBuild()
	{
		Map.Get().At(17, 42).Door.SetLocked();
		Map.Get().At(20, 40).Door.SetLocked(locked: false);
		Map.Get().At(20, 32).Door.SetLocked();
		Map.Get().At(26, 27).Door.SetLocked(locked: false);
		Map.Get().At(18, 36).Door.SetLocked();
		Unlockable componentInChildren = Map.Get().At(18, 36).Door.GetComponentInChildren<Unlockable>();
		if (componentInChildren != null)
		{
			componentInChildren.skipTutorialIfTouch = true;
		}
		FixRenderQueue("MapGeometry/01carpet_14");
		FixRenderQueue("MapGeometry/01carpet_12");
	}

	private void FixRenderQueue(string objName)
	{
		GameObject gameObject = GameObject.Find(objName);
		if (gameObject != null)
		{
			Renderer component = gameObject.transform.GetChild(0).gameObject.GetComponent<Renderer>();
			component.material.renderQueue--;
		}
	}
}
public class MetaMapGenerator_02 : CustomGenerator
{
	protected override void DefineMap()
	{
		SetSeed(2506340222u);
		SetStyle(new string[3] { "dungeon", "room", "small" }, "temple_arched");
		SetStyle(new string[3] { "dungeon", "room", "medium" }, "temple_room");
		SetStyle(new string[3] { "dungeon", "room", "large" }, "temple_room");
		SetStyle(new string[3] { "dungeon", "room", "hub" }, "tunnel_high_arched_medium2");
		SetStyle(new string[3] { "dungeon", "corridor", "narrow" }, "temple_room");
		SetStyle(new string[3] { "dungeon", "corridor", "large" }, "temple_arched");
		SetStyle(new string[3] { "catacomb", "corridor", "narrow" }, "catacomb_narrow");
		SetStyle(new string[3] { "catacomb", "room", "small" }, "catacomb");
		int from = AddRoom("_meta_02_A", 8, 36);
		int num = AddRoom("_meta_02_B", 20, 34);
		int to = AddRoom("_meta_02_HUB", 26, 18);
		int from2 = AddRoom("_meta_01_exit_A", 16, 14);
		int from3 = AddRoom("_meta_01_exit_B", 34, 12);
		int from4 = AddRoom("_meta_01_exit_C", 44, 14);
		AddCorridor(from, num);
		AddCorridor(num, to);
		AddCorridor(from2, to, isDouble: true);
		AddCorridor(from3, to);
		AddCorridor(from4, to, isDouble: true);
		startRoom = from;
		exitRoom = num;
		Options.DoorClutter = 1f;
	}

	public override void AfterGeneration()
	{
		for (int i = 17; i <= 20; i++)
		{
			Tags.Set(MapTags.Group.Main, "catacomb", new Point(33, i));
		}
		for (int j = 33; j <= 36; j++)
		{
			Tags.Set(MapTags.Group.Main, "catacomb", new Point(j, 17));
		}
		for (int k = 10; k <= 17; k++)
		{
			for (int l = 36; l <= 40; l++)
			{
				Tags.Set(MapTags.Group.Main, "catacomb", new Point(l, k));
			}
		}
		RemoveDoor(new Point(33, 20));
		RemoveDoor(new Point(36, 16));
	}

	public override void AfterBuild()
	{
	}
}
public class MetaMapGenerator_03 : CustomGenerator
{
	protected override void DefineMap()
	{
		SetSeed(1844614888u);
		SetStyle(new string[3] { "catacomb", "room", "small" }, "oldbrick_reduced_dirtground");
		SetStyle(new string[3] { "catacomb", "room", "medium" }, "catacomb");
		SetStyle(new string[3] { "catacomb", "room", "large" }, "catacomb");
		SetStyle(new string[3] { "catacomb", "room", "hub" }, "catacomb_high");
		SetStyle(new string[3] { "catacomb", "corridor", "narrow" }, "catacomb_narrow");
		SetStyle(new string[3] { "catacomb", "corridor", "large" }, "catacomb_corridor_large");
		int from = AddRoom("_meta_03_A", 8, 12);
		int to = AddRoom("_meta_03_B", 20, 8);
		int to2 = AddRoom("_meta_03_C", 19, 15);
		int to3 = AddRoom("_meta_03_D", 22, 20);
		int num = AddRoom("_meta_03_HUB", 34, 24);
		int from2 = AddRoom("_meta_01_exit_C", 44, 18);
		int from3 = AddRoom("_meta_01_exit_D", 42, 44);
		int from4 = AddRoom("_meta_01_exit_C", 50, 22);
		AddCorridor(from, to3);
		AddCorridor(from, to);
		AddCorridor(from, to2);
		AddCorridor(num, to2);
		AddCorridor(from2, num);
		AddCorridor(from3, num);
		AddCorridor(from4, num);
		startRoom = from;
		exitRoom = to;
		Options.DoorClutter = 1f;
	}

	public override void AfterGeneration()
	{
		RemoveDoor(new Point(40, 38));
		RemoveDoor(new Point(41, 24));
		RemoveDoor(new Point(46, 29));
		RemoveDoor(new Point(44, 23));
		RemoveDoor(new Point(44, 44));
		RemoveDoor(new Point(50, 27));
		RemoveDoor(new Point(25, 29));
	}

	public override void AfterBuild()
	{
		Map.Get().At(34, 31).Door.SetLocked(locked: false);
	}
}
public class MetaMapGenerator_04 : CustomGenerator
{
	protected override void DefineMap()
	{
		SetSeed(1091075578u);
		SetStyle(new string[3] { "dungeon", "room", "small" }, "catacomb");
		SetStyle(new string[3] { "dungeon", "room", "medium" }, "temple_room");
		SetStyle(new string[3] { "dungeon", "room", "large" }, "temple_room");
		SetStyle(new string[3] { "dungeon", "room", "hub" }, "tunnel_high_arched");
		SetStyle(new string[3] { "dungeon", "corridor", "narrow" }, "catacomb_narrow");
		SetStyle(new string[3] { "dungeon", "corridor", "large" }, "temple_arched");
		int num = 12;
		int num2 = AddRoom("_meta_04_A", 8, 32 + num);
		int to = AddRoom("_meta_04_B", 14, 24 + num);
		int from = AddRoom("_meta_04_C", 14, 38 + num);
		int to2 = AddRoom("_meta_01_exit_C", 30, 38 + num);
		int from2 = AddRoom("_meta_04_HUB", 22, 6);
		AddCorridor(from, to2);
		AddCorridor(from, num2);
		AddCorridor(num2, to, isDouble: true);
		AddCorridor(from2, to, isDouble: true);
		startRoom = from;
		exitRoom = to;
		Options.DoorClutter = 1f;
	}

	public override void AfterGeneration()
	{
		RemoveDoor(new Point(19, 53));
		RemoveDoor(new Point(10, 50));
		RemoveDoor(new Point(14, 52));
	}

	public override void AfterBuild()
	{
	}
}
public class MetaOnCollectItem : MonoBehaviour
{
	public string itemName;

	public Transform tutorialPlace;

	public string tutorialText;

	private TextLabel tutorialLabel;

	private void Start()
	{
		StartCoroutine(Start_co());
	}

	private IEnumerator Start_co()
	{
		yield return 0;
		GameObject item = GameObject.Find(itemName);
		if (!item)
		{
			UnityEngine.Object.Destroy(this);
			yield break;
		}
		Collectable component = item.GetComponent<Collectable>();
		if (!component)
		{
			UnityEngine.Object.Destroy(this);
		}
		else
		{
			component.NotifyOnPickUp(base.gameObject);
		}
	}

	private void OnColledted(Collectable collectable)
	{
		tutorialLabel = Tutorial.ShowInPlace(tutorialText, Vector3.zero, Quaternion.identity, tutorialPlace, 4f, facePlayer: true);
		if (tutorialLabel != null)
		{
			StartCoroutine(Update_co());
		}
	}

	private IEnumerator Update_co()
	{
		int curProgress = MetaProgress.Get().nextToOpen;
		while (curProgress == MetaProgress.Get().nextToOpen)
		{
			yield return new WaitForSeconds(0.25f);
		}
		tutorialLabel.FadeOut(4f, disableOnFadeOut: true, destroyOnFadeOut: true);
		tutorialLabel = null;
	}
}
public class MetaProgress : MonoBehaviour
{
	public delegate void OnActivateNext(Vector3 spawnPos, float delayOpen, bool save, float delaySave);

	public string[] gateNames;

	public UniSplineComponent[] paths;

	public UniSplineFollower pathFollowerPrefab;

	public int nextToOpen;

	public bool closeLastActorIfNull;

	private List<MechActor> actors;

	public Dictionary<MechActor, UniSplineComponent> splinesByActors;

	public OnActivateNext onActivateNext;

	private static MetaProgress instance;

	public static MetaProgress Get()
	{
		return instance;
	}

	private void Awake()
	{
		instance = this;
	}

	private void Start()
	{
		int num = 0;
		actors = new List<MechActor>();
		splinesByActors = new Dictionary<MechActor, UniSplineComponent>();
		for (int i = 0; i < gateNames.Length; i++)
		{
			if (gateNames[i] == string.Empty)
			{
				actors.Add(null);
				continue;
			}
			GameObject gameObject = GameObject.Find(gateNames[i]);
			if (gameObject == null)
			{
				Debug.LogError("Gate object not found: " + gateNames[i]);
				actors.Add(null);
				continue;
			}
			MechGate component = gameObject.GetComponent<MechGate>();
			actors.Add(component);
			if (num < paths.Length)
			{
				splinesByActors[component] = paths[num];
				num++;
			}
		}
		nextToOpen = 0;
		Serializer.Add(this, OnSerialize, OnDeserialize);
	}

	private void OnSerialize(BinaryWriter writer)
	{
	}

	private void OnDeserialize(BinaryReader reader)
	{
		int checkPoint = GameState.Get().checkPoint;
		nextToOpen = checkPoint;
		if (actors.Count == 0)
		{
			return;
		}
		for (int i = 0; i < nextToOpen; i++)
		{
			if (actors[i] != null)
			{
				actors[i].SetProgress(1f, instantaneous: true);
			}
			else if (closeLastActorIfNull && i > 0 && actors[i - 1] != null)
			{
				actors[i - 1].SetProgress(0f, instantaneous: true);
			}
		}
	}

	public void ActivateNext(Vector3 spawnPos, float delayOpen = 1f, float delaySave = 2f)
	{
		if (onActivateNext != null)
		{
			onActivateNext(spawnPos, delayOpen, save: true, delaySave);
		}
		else
		{
			StartCoroutine(ActivateNext_co(spawnPos, delayOpen, save: true, delaySave));
		}
	}

	public void ActivateNext(Vector3 spawnPos, bool save, float delayOpen = 1f, float delaySave = 2f)
	{
		if (onActivateNext != null)
		{
			onActivateNext(spawnPos, delayOpen, save, delaySave);
		}
		else
		{
			StartCoroutine(ActivateNext_co(spawnPos, delayOpen, save, delaySave));
		}
	}

	private IEnumerator ActivateNext_co(Vector3 spawnPos, float delayOpen = 1f, bool save = true, float delaySave = 2f)
	{
		if (nextToOpen >= actors.Count)
		{
			yield break;
		}
		if (actors[nextToOpen] != null)
		{
			if (spawnPos != Vector3.zero)
			{
				UniSplineComponent uniSplineComponent = splinesByActors[actors[nextToOpen]];
				if (uniSplineComponent != null && pathFollowerPrefab != null)
				{
					UniSplineFollower uniSplineFollower = UnityEngine.Object.Instantiate(pathFollowerPrefab, spawnPos, Quaternion.identity);
					uniSplineFollower.splineComp = uniSplineComponent;
				}
			}
			yield return new WaitForSeconds(delayOpen);
			actors[nextToOpen].SetProgress();
		}
		else if (closeLastActorIfNull && nextToOpen > 0)
		{
			yield return new WaitForSeconds(delayOpen);
			if (actors[nextToOpen - 1] != null)
			{
				actors[nextToOpen - 1].SetProgress(0f);
			}
		}
		else
		{
			yield return new WaitForSeconds(delayOpen);
		}
		nextToOpen++;
		yield return new WaitForSeconds(delaySave);
		if (save)
		{
			GameState.Get().checkPoint++;
			GameController.Get().SaveGame();
			Tutorial.Get().Save();
		}
	}
}
public class MetaUnlocker : ProgressInteraction
{
	public bool unlocked;

	public AudioClip unlockSound;

	public GameObject[] unlockPrefabs;

	public GameObject[] unlockEnableObjs;

	public Transform unlockSpawnPoint;

	public Collectable.EItemType requiredItem;

	private ParticleSystem[] particles;

	private Inventory inventory;

	private new void Start()
	{
		base.Start();
		particles = GetComponentsInChildren<ParticleSystem>();
		if (!unlocked)
		{
			SetParticlesEmission(enabled: false);
		}
		else
		{
			SetParticlesEmission(enabled: true);
		}
		inventory = GameObject.FindWithTag(Tags.Inventory).GetComponent<Inventory>();
		Serializer.Add(this, OnSerialize, OnDeserialize);
	}

	private void OnSerialize(BinaryWriter writer)
	{
		writer.Write(unlocked);
	}

	private void OnDeserialize(BinaryReader reader)
	{
		bool flag = reader.ReadBoolean();
		if (flag && !unlocked)
		{
			unlocked = flag;
			SetParticlesEmission(enabled: true);
			for (int i = 0; i < unlockEnableObjs.Length; i++)
			{
				unlockEnableObjs[i].gameObject.SetActive(value: true);
			}
		}
	}

	private new void Update()
	{
		base.Update();
		needsProgress = !unlocked && inventory.NumItems[(int)requiredItem] > 0;
		if (InputExt.UsingHandControllers)
		{
			needsProgress = false;
		}
	}

	protected override void OnFinishProgress()
	{
		Unlock();
	}

	public void Unlock()
	{
		if (!unlocked && inventory.ConsumeItem(requiredItem))
		{
			unlocked = true;
			SetParticlesEmission(enabled: true);
			for (int i = 0; i < unlockEnableObjs.Length; i++)
			{
				unlockEnableObjs[i].gameObject.SetActive(value: true);
			}
			if ((bool)unlockSound)
			{
				AudioSource.PlayClipAtPoint(unlockSound, unlockSpawnPoint.position);
			}
			for (int j = 0; j < unlockPrefabs.Length; j++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(unlockPrefabs[j]);
				gameObject.transform.position = unlockSpawnPoint.position;
			}
			MetaProgress.Get().ActivateNext(unlockSpawnPoint.position);
		}
	}

	private void SetParticlesEmission(bool enabled)
	{
		for (int i = 0; i < particles.Length; i++)
		{
			particles[i].enableEmission = enabled;
		}
	}
}
[RequireComponent(typeof(Trigger))]
public class OilTutorialTrigger : MonoBehaviour
{
	public bool require3DOF;

	public bool requireTouch;

	public void OnTrigger(PlayerGameController player)
	{
		if ((require3DOF && !InputExt.Using3DOFController) || (requireTouch && !InputExt.UsingHandControllers))
		{
			base.enabled = false;
			return;
		}
		if (Config.General().tutorials)
		{
			Tutorial.Get().ForceTutorialOil();
		}
		base.enabled = false;
	}
}
[RequireComponent(typeof(Trigger))]
public class TutorialTrigger : MonoBehaviour
{
	public string tutorialString;

	public float showTime = 5f;

	public bool require3DOF;

	public bool requireTouch;

	public bool checkStringExists;

	public void OnTrigger(PlayerGameController player)
	{
		if (require3DOF && !InputExt.Using3DOFController)
		{
			base.enabled = false;
			return;
		}
		if (requireTouch && !InputExt.UsingHandControllers)
		{
			base.enabled = false;
			return;
		}
		if (Config.General().tutorials && !Tutorial.HasBeenShownBefore(tutorialString, add: true) && (!checkStringExists || Translate.Check(tutorialString)))
		{
			Tutorial.Get().ShowTextForTime(Translate.GetForInput(tutorialString), showTime);
		}
		base.enabled = false;
	}
}
public class UniSplineFollower : MonoBehaviour
{
	public UniSplineComponent splineComp;

	public bool addStartingPosition;

	private BaseSpline.SplineIterator splineIter;

	public Ease.Easing m_easing;

	public bool destroyOnEnd = true;

	private float progress;

	public float speed = 1f;

	private void Start()
	{
		if (addStartingPosition)
		{
			splineComp.Spline.InsertPoint(0, base.transform.position - splineComp.transform.position);
			splineComp.Spline.Build();
		}
		splineIter = splineComp.Spline.GetIterator();
		splineIter.SetTransform(splineComp.transform);
	}

	private void Update()
	{
		progress += speed * Time.deltaTime;
		splineIter.SetOffset(Ease.EaseByType(m_easing, 0f, splineComp.Spline.Length, progress / splineComp.Spline.Length));
		base.transform.position = splineIter.GetPosition();
		if (destroyOnEnd && progress >= splineComp.Spline.Length)
		{
			UnityEngine.Object.Destroy(base.gameObject, 5f);
			base.enabled = false;
		}
	}
}
[RequireComponent(typeof(Trigger))]
public class WalkTutorialTrigger : MonoBehaviour
{
	public string tutorialString;

	public float waitTime;

	public void OnTrigger(PlayerGameController player)
	{
		if (Config.General().tutorials && Translate.Check(tutorialString) && (InputExt.Using3DOFController || InputExt.UsingHandControllers))
		{
			StartCoroutine(Tutorial_co());
		}
		base.enabled = false;
	}

	private IEnumerator Tutorial_co()
	{
		yield return new WaitForSeconds(waitTime);
		Vector3 playerPos = Player.GetPos();
		TextLabel tutorialLabel = Tutorial.ShowInPlace(tutorialString, Vector3.zero, Quaternion.identity, base.transform, 1f);
		if ((bool)tutorialLabel)
		{
			tutorialLabel.gameObject.AddComponent<DistanceDestroyer>();
			while ((Player.GetPos() - playerPos).sqrMagnitudeGround() <= 0.25f)
			{
				yield return 0;
			}
			tutorialLabel.FadeOut(4f, disableOnFadeOut: true, destroyOnFadeOut: true);
		}
	}
}
public class Minimap : MonoBehaviour
{
	private Texture2D Mask;

	private Point LastCell;

	private Transform player;

	public float reductionFactor = 1f;

	private float mapTexSize;

	public bool loadFromSavegame;

	private Renderer renderer;

	private void Start()
	{
		player = Player.Get().transform;
		LastCell = new Point(0, 0);
		renderer = GetComponent<Renderer>();
		Mask = (Texture2D)renderer.sharedMaterials[0].GetTexture("_LevelMap");
		mapTexSize = 0.5f * reductionFactor;
		float num = 1f / reductionFactor;
		float num2 = (1f - 0.5f * num) / 2f;
		renderer.sharedMaterials[0].SetTextureOffset("_LevelMap", new Vector2(num2, num2));
		renderer.sharedMaterials[0].SetTextureScale("_LevelMap", new Vector2(0.5f * num, 0.5f * num));
		ResetMask();
		if (loadFromSavegame)
		{
			Deserialize(GameState.Get().minimap);
		}
		PlayerStats.Get().SetMinimap(Mask);
	}

	private void Update()
	{
		Point point = Map.Get().WorldToCell(base.transform.position);
		if (point != LastCell)
		{
			UpdateMask(point);
			LastCell = point;
		}
		UpdateMarker();
		if (renderer.enabled && GameController.Get().Paused)
		{
			renderer.enabled = false;
		}
		else if (!renderer.enabled && !GameController.Get().Paused)
		{
			renderer.enabled = true;
		}
	}

	public void ResetMask(float fVisibility = 0f)
	{
		for (int i = 0; i < Mask.height; i++)
		{
			for (int j = 0; j < Mask.width; j++)
			{
				Color pixel = Mask.GetPixel(j, i);
				pixel.a = fVisibility;
				Mask.SetPixel(j, i, pixel);
			}
		}
		Mask.Apply();
	}

	private void UpdateMask(Point cellPos)
	{
		int width = Map.Get().Width;
		int height = Map.Get().Height;
		int num = (Mask.width - width) / 2;
		int num2 = (Mask.height - height) / 2;
		Vector3 vector = Map.Get().CellToWorld(cellPos);
		for (int i = cellPos.Y - 10; i <= cellPos.Y + 10; i++)
		{
			if (i <= 0 || i >= Map.Get().Height - 1)
			{
				continue;
			}
			for (int j = cellPos.X - 10; j <= cellPos.X + 10; j++)
			{
				if (j > 0 && j < Map.Get().Width - 1)
				{
					Point point = new Point(num + j, num2 + (height - 1 - i));
					Color pixel = Mask.GetPixel(point.X, point.Y);
					float magnitude = (Map.Get().CellToWorld(j, i) - vector).magnitude;
					pixel.a = Mathf.Max(pixel.a, Mathf.Lerp(0.4f, 0f, magnitude / 10f));
					Cell cell = Map.Get().At(j, i);
					if (cell.IsDiscovered())
					{
						pixel.a = Mathf.Max(pixel.a, Mathf.Lerp(1f, 0f, magnitude / 10f));
					}
					Mask.SetPixel(point.X, point.Y, pixel);
				}
			}
		}
		Mask.Apply();
	}

	private void UpdateMarker()
	{
		Point point = Map.Get().WorldToCell(player.position);
		float num = renderer.sharedMaterials[0].GetTextureScale("_Marker").x / 64f * reductionFactor;
		float num2 = (float)(-point.X) * num + 0.5f * num;
		float num3 = (float)(-(63 - point.Y)) * num + 0.5f * num;
		num2 -= (64f - reductionFactor * 64f) * 0.5f * num;
		num3 -= (64f - reductionFactor * 64f) * 0.5f * num;
		renderer.sharedMaterials[0].SetTextureOffset("_Marker", new Vector2(num2, num3));
	}

	public void Serialize(GameState gameState)
	{
		gameState.minimap = Serialize();
	}

	public void Deserialize(GameState gameState)
	{
		Deserialize(gameState.minimap);
	}

	private float[] Serialize()
	{
		int width = Map.Get().Width;
		int height = Map.Get().Height;
		int num = (Mask.width - width) / 2;
		int num2 = (Mask.height - height) / 2;
		float[] array = new float[width * height];
		for (int i = 0; i < height; i++)
		{
			for (int j = 0; j < width; j++)
			{
				int num3 = i * width + j;
				Point point = new Point(num + j, num2 + (height - 1 - i));
				float num4 = Mask.GetPixel(point.X, point.Y).a;
				Cell cell = Map.Get().At(j, i);
				if (cell.IsDiscovered() && num4 > 0f)
				{
					num4 = 0f - num4;
				}
				array[num3] = num4;
			}
		}
		return array;
	}

	private void Deserialize(float[] state)
	{
		if (state == null || state.Length == 0)
		{
			ResetMask();
			return;
		}
		int width = Map.Get().Width;
		int height = Map.Get().Height;
		int num = (Mask.width - width) / 2;
		int num2 = (Mask.height - height) / 2;
		for (int i = 0; i < height; i++)
		{
			for (int j = 0; j < width; j++)
			{
				int num3 = i * width + j;
				Point point = new Point(num + j, num2 + (height - 1 - i));
				float num4 = state[num3];
				if (num4 < 0f)
				{
					num4 = 0f - num4;
					Cell cell = Map.Get().At(j, i);
					if (cell.Probe != null)
					{
						cell.Probe.Discovered = true;
					}
				}
				Color pixel = Mask.GetPixel(point.X, point.Y);
				pixel.a = num4;
				Mask.SetPixel(point.X, point.Y, pixel);
			}
		}
		Mask.Apply();
	}
}
public class MinimapHandController : MonoBehaviour
{
	public PlayerHand hand;

	public Transform minimapAnchor;

	private Vector3 visibleScale;

	private Vector3 visiblePosition;

	private Vector3 hiddenPosition;

	private void Start()
	{
		visibleScale = base.transform.localScale;
		visiblePosition = base.transform.localPosition;
		hiddenPosition = base.transform.parent.InverseTransformPoint(minimapAnchor.position);
	}

	private void Update()
	{
		bool flag = !InputExt.GetButton(InputExt.Button.HideMap);
		base.transform.localScale = Interpolate.Approach(base.transform.localScale, (!flag) ? visibleScale : Vector3.zero, Time.deltaTime * 2f * 7f);
		base.transform.localPosition = Interpolate.Approach(base.transform.localPosition, (!flag) ? visiblePosition : hiddenPosition, Time.deltaTime * 2f * 7f);
		hand.mapLocked = !flag;
	}
}
public class MinimapHider : MonoBehaviour
{
	public float HideFactor = 1f;
}
public class MinimapPosition : MonoBehaviour
{
	public Transform LookDirection;

	private Transform _LookDirection;

	public float MinLookAngle = 30f;

	public float MaxLookAngle = 45f;

	public float MinMapAngle = 28.5f;

	public float MaxMapAngle = 49f;

	public float HideMapAngle = 79f;

	public float MapDistance = 0.52f;

	public float MapFrontAngle;

	public LayerMask HiderMask;

	public LayerMask CloseHiderMask;

	public bool checkClipping;

	public LayerMask ClippingMask;

	public float ClippingDistance;

	public bool Hide;

	public bool Minimize;

	public bool IsFolded = true;

	public float FoldedMinLookAngle;

	public float FoldedMaxLookAngle;

	public float FoldedMinMapAngle;

	public float FoldedMaxMapAngle;

	public float FoldLimitMax;

	public float FoldLimitMin;

	public LayerMask CollisionMask;

	public Transform colliderLeft;

	public Transform colliderRight;

	public Transform colliderLeftUp;

	public Transform colliderRightUp;

	private float MinLookCos;

	private float MaxLookCos;

	private float FoldedMinLookCos;

	private float FoldedMaxLookCos;

	private float FoldLimitMinCos;

	private float FoldLimitMaxCos;

	private float MapHiddenFrontAngle;

	private float maxAngle = 1f;

	private Vector3 startScale;

	public float MinLook3DOFAngle = 30f;

	public float MaxLook3DOFAngle = 30f;

	public float FoldedMinLook3DOFAngle;

	public float FoldedMaxLook3DOFAngle;

	private float MinLook3DOFCos;

	private float MaxLook3DOFCos;

	private float FoldedMinLook3DOFCos;

	private float FoldedMaxLook3DOFCos;

	private void Start()
	{
		MinLookCos = Mathf.Cos(MinLookAngle * ((float)Math.PI / 180f));
		MaxLookCos = Mathf.Cos(MaxLookAngle * ((float)Math.PI / 180f));
		FoldedMinLookCos = Mathf.Cos(FoldedMinLookAngle * ((float)Math.PI / 180f));
		FoldedMaxLookCos = Mathf.Cos(FoldedMaxLookAngle * ((float)Math.PI / 180f));
		FoldLimitMinCos = Mathf.Cos(FoldLimitMin * ((float)Math.PI / 180f));
		FoldLimitMaxCos = Mathf.Cos(FoldLimitMax * ((float)Math.PI / 180f));
		MapHiddenFrontAngle = base.transform.localEulerAngles.x;
		IsFolded = true;
		startScale = base.transform.localScale;
		_LookDirection = LookDirection;
		if (InputExt.Using3DOFController)
		{
			_LookDirection = Player.GetLook(interaction: true);
			MinLook3DOFCos = Mathf.Cos(MinLook3DOFAngle * ((float)Math.PI / 180f));
			MaxLook3DOFCos = Mathf.Cos(MaxLook3DOFAngle * ((float)Math.PI / 180f));
			FoldedMinLook3DOFCos = Mathf.Cos(FoldedMinLook3DOFAngle * ((float)Math.PI / 180f));
			FoldedMaxLook3DOFCos = Mathf.Cos(FoldedMaxLook3DOFAngle * ((float)Math.PI / 180f));
		}
	}

	private void Update()
	{
		if (InputExt.Using3DOFController)
		{
			_LookDirection = Player.GetLook(interaction: true);
		}
		Vector3 rhs = Vector3.Cross(_LookDirection.forward, _LookDirection.up);
		Vector3 rhs2 = Vector3.Cross(Vector3.up, rhs);
		rhs2.Normalize();
		float num = Vector3.Dot(_LookDirection.forward, rhs2);
		if (num <= FoldLimitMaxCos)
		{
			IsFolded = false;
		}
		else if (num >= FoldLimitMinCos)
		{
			IsFolded = true;
		}
		float num2 = ((!IsFolded) ? MinLookCos : FoldedMinLookCos);
		float num3 = ((!IsFolded) ? MaxLookCos : FoldedMaxLookCos);
		float b = ((!IsFolded) ? MinMapAngle : FoldedMinMapAngle);
		float a = ((!IsFolded) ? MaxMapAngle : FoldedMaxMapAngle);
		float t = Mathf.Clamp((num - num2) / (num3 - num2), 0f, 1f);
		if (InputExt.Using3DOFController)
		{
			float minLook3DOFCos = MinLook3DOFCos;
			float maxLook3DOFCos = MaxLook3DOFCos;
			b = MinMapAngle;
			a = FoldedMaxMapAngle;
			t = Mathf.Clamp((num - minLook3DOFCos) / (maxLook3DOFCos - minLook3DOFCos), 0f, 1f);
			if (_LookDirection.forward.y < 0f)
			{
				t = 0f;
			}
		}
		else if (_LookDirection.forward.y > 0f)
		{
			t = 0f;
		}
		bool flag = CheckHider();
		float angle = (flag ? HideMapAngle : Mathf.LerpAngle(a, b, t));
		Vector3 vector = Vector3.forward * MapDistance;
		vector = Quaternion.AngleAxis(angle, Vector3.right) * vector;
		float x = (flag ? MapHiddenFrontAngle : Mathf.LerpAngle(MapHiddenFrontAngle, MapFrontAngle, t));
		Vector3 localEulerAngles = base.transform.localEulerAngles;
		localEulerAngles.x = x;
		base.transform.localEulerAngles = localEulerAngles;
		base.transform.localPosition = Vector3.Slerp(base.transform.localPosition, vector, Time.deltaTime * 4f);
		base.transform.localScale = Interpolate.Approach(base.transform.localScale, (!Minimize) ? startScale : Vector3.zero, Time.deltaTime * 7f);
		Hide = false;
		Minimize = false;
	}

	private bool CheckHider()
	{
		if (Hide)
		{
			return true;
		}
		if (InputExt.GetButton(InputExt.Button.HideMap))
		{
			return true;
		}
		Vector3 position = LookDirection.transform.position;
		Vector3 forward = LookDirection.transform.forward;
		if (Physics.Raycast(position, forward, out var hitInfo, 3f, HiderMask))
		{
			MinimapHider[] components = hitInfo.collider.gameObject.GetComponents<MinimapHider>();
			if (components.Length != 0)
			{
				return true;
			}
			if ((CloseHiderMask.value & (1 << hitInfo.collider.gameObject.layer)) != 0)
			{
				float sqrMagnitude = (hitInfo.point - position).sqrMagnitude;
				if (sqrMagnitude <= 4f)
				{
					return true;
				}
			}
		}
		if (Physics.Raycast(position + forward * 3f, -forward, out hitInfo, 3f, HiderMask))
		{
			MinimapHider[] components2 = hitInfo.collider.gameObject.GetComponents<MinimapHider>();
			if (components2.Length != 0)
			{
				return true;
			}
			if ((CloseHiderMask.value & (1 << hitInfo.collider.gameObject.layer)) != 0)
			{
				float sqrMagnitude2 = (hitInfo.point - position).sqrMagnitude;
				if (sqrMagnitude2 <= 4f)
				{
					return true;
				}
			}
		}
		if (checkClipping)
		{
			float num = 0.07f;
			float num2 = 0.13f;
			Vector3 vector = base.transform.parent.position + Vector3.up * num;
			if (Physics.Raycast(vector, base.transform.parent.forward, ClippingDistance, ClippingMask))
			{
				return true;
			}
			if (Physics.Raycast(vector + base.transform.parent.right * 0.18f, base.transform.parent.forward, ClippingDistance, ClippingMask))
			{
				return true;
			}
			if (Physics.Raycast(vector - base.transform.parent.right * 0.18f, base.transform.parent.forward, ClippingDistance, ClippingMask))
			{
				return true;
			}
			Vector3 vector2 = base.transform.parent.position + Vector3.up * num2;
			Vector3 start = vector2 - base.transform.parent.right * 0.18f + base.transform.parent.forward * ClippingDistance;
			Vector3 end = vector2 + base.transform.parent.right * 0.18f + base.transform.parent.forward * ClippingDistance;
			if (Physics.Linecast(start, end, ClippingMask))
			{
				return true;
			}
		}
		return false;
	}

	private float CheckMaxAngle(float curAngle)
	{
		if (Physics.Linecast(colliderLeft.position, colliderRight.position, out var hitInfo, CollisionMask))
		{
			if ((CollisionMask.value & (1 << hitInfo.collider.gameObject.layer)) != 0)
			{
				return maxAngle + 0.2f;
			}
		}
		else if (Physics.Linecast(colliderLeftUp.position, colliderRightUp.position, out hitInfo, CollisionMask) && (CollisionMask.value & (1 << hitInfo.collider.gameObject.layer)) != 0)
		{
			return maxAngle;
		}
		return curAngle;
	}
}
public class MinimapStats : MonoBehaviour
{
	private Texture2D Mask;

	private Texture2D RecentProbes;

	public float reductionFactor = 1f;

	private float mapTexSize;

	private void Start()
	{
		Mask = PlayerStats.stats.levelMap;
		GetComponent<Renderer>().material.SetTexture("_LevelMap", Mask);
		mapTexSize = 0.5f * reductionFactor;
		float num = 1f / reductionFactor;
		float num2 = (1f - 0.5f * num) / 2f;
		GetComponent<Renderer>().material.SetTextureOffset("_LevelMap", new Vector2(num2, num2));
		GetComponent<Renderer>().material.SetTextureScale("_LevelMap", new Vector2(0.5f * num, 0.5f * num));
		RecentProbes = new Texture2D(128, 128, TextureFormat.RGBA32, mipmap: false);
		ClearMemory.AddRuntimeTexture(RecentProbes);
		RecentProbes.filterMode = FilterMode.Point;
		RecentProbes.wrapMode = TextureWrapMode.Clamp;
		GetComponent<Renderer>().material.SetTexture("_RecentProbes", RecentProbes);
		ResetProbes();
		ResetMask();
	}

	private void Update()
	{
		UpdateProbes();
	}

	public void ResetMask(float fVisibility = 0f)
	{
		for (int i = 0; i < Mask.height; i++)
		{
			for (int j = 0; j < Mask.width; j++)
			{
				Color pixel = Mask.GetPixel(j, i);
				pixel.a = fVisibility;
				Mask.SetPixel(j, i, pixel);
			}
		}
		Mask.Apply();
	}

	private void UpdateMask(Point cellPos)
	{
		int num = 64;
		int num2 = 64;
		int num3 = (Mask.width - num) / 2;
		int num4 = (Mask.height - num2) / 2;
		Vector3 vector = CellToWorld(cellPos);
		for (int i = cellPos.Y - 10; i <= cellPos.Y + 10; i++)
		{
			if (i <= 0 || i >= num2 - 1)
			{
				continue;
			}
			for (int j = cellPos.X - 10; j <= cellPos.X + 10; j++)
			{
				if (j > 0 && j < num - 1)
				{
					Point point = new Point(num3 + j, num4 + (num2 - 1 - i));
					Color pixel = Mask.GetPixel(point.X, point.Y);
					float magnitude = (CellToWorld(new Point(j, i)) - vector).magnitude;
					pixel.a = Mathf.Max(pixel.a, Mathf.Lerp(0.4f, 0f, magnitude / 10f));
					Mask.SetPixel(point.X, point.Y, pixel);
				}
			}
		}
		Mask.Apply();
	}

	private Vector3 CellToWorld(Point pos)
	{
		return new Vector3((float)pos.X * 1.5f + 0.75f, 0f, (float)(-pos.Y) * 1.5f - 0.75f);
	}

	private void UpdateMarker(Point markerPos)
	{
		float num = GetComponent<Renderer>().material.GetTextureScale("_Marker").x / 64f * reductionFactor;
		float num2 = (float)(-markerPos.X) * num + 0.5f * num;
		float num3 = (float)(-(63 - markerPos.Y)) * num + 0.5f * num;
		num2 -= (64f - reductionFactor * 64f) * 0.5f * num;
		num3 -= (64f - reductionFactor * 64f) * 0.5f * num;
		GetComponent<Renderer>().material.SetTextureOffset("_Marker", new Vector2(num2, num3));
	}

	public void SetPlayerPos(Point cellPos)
	{
		UpdateMask(cellPos);
		UpdateMarker(cellPos);
	}

	private void ResetProbes()
	{
		for (int i = 0; i < RecentProbes.height; i++)
		{
			for (int j = 0; j < RecentProbes.width; j++)
			{
				RecentProbes.SetPixel(j, i, new Color(0f, 0f, 0f, 0f));
			}
		}
		RecentProbes.Apply();
	}

	public void MarkProbe(int x, int y)
	{
		int num = 64;
		int num2 = 64;
		int num3 = (RecentProbes.width - num) / 2;
		int num4 = (RecentProbes.height - num2) / 2;
		Point point = new Point(num3 + x, num4 + (num2 - 1 - y));
		RecentProbes.SetPixel(point.X, point.Y, new Color(1f, 1f, 1f, 1f));
	}

	public void ApplyProbes()
	{
		RecentProbes.Apply();
	}

	private void UpdateProbes()
	{
		int num = 64;
		int num2 = 64;
		int num3 = (Mask.width - num) / 2;
		int num4 = (Mask.height - num2) / 2;
		Color b = new Color(0f, 0f, 0f, 0f);
		float t = 5f * Time.deltaTime;
		for (int i = 0; i < num2; i++)
		{
			for (int j = 0; j < num; j++)
			{
				Point point = new Point(num3 + j, num4 + (num2 - 1 - i));
				Color pixel = RecentProbes.GetPixel(point.X, point.Y);
				pixel = Color.Lerp(pixel, b, t);
				RecentProbes.SetPixel(point.X, point.Y, pixel);
			}
		}
		RecentProbes.Apply();
	}
}
[RequireComponent(typeof(AudioSource))]
public class MusicVolume : MonoBehaviour
{
	private float baseVolume;

	public float Volume
	{
		get
		{
			return baseVolume;
		}
		set
		{
			baseVolume = value;
			UpdateVolume();
		}
	}

	private void Start()
	{
		baseVolume = GetComponent<AudioSource>().volume;
		UpdateVolume();
	}

	public void UpdateVolume()
	{
		GetComponent<AudioSource>().volume = baseVolume * Config.Audio().musicVolume;
	}
}
[RequireComponent(typeof(InteractionListener))]
public class Book : FSMComponent<Book.States>
{
	public enum States
	{
		Idle,
		PickedUp,
		Reading,
		PageFlip,
		PageFlipBack,
		Closing,
		Returning
	}

	public float posForward = 0.5f;

	public float posUp = 0.5f;

	public float pickedUpRotX = 62f;

	public float pickedUpRotY;

	public float pickedUpRotZ = -90f;

	public Animation anim;

	public AudioClip pickUpSound;

	public AudioClip leaveSound;

	public AudioClip pageFlipSound;

	public PageFlip pageLeft;

	public PageFlip pageRight;

	public PageFlip pageFlip;

	public GUIStyle textStyle;

	public GUIStyle titleStyle;

	public Texture2D[] pagesTest;

	private static RenderTexture[] pages;

	public BookDesc bookDesc;

	private int updatePagesFrom = -1;

	private int pageOffset;

	private InteractionListener listener;

	private Inventory playerInventory;

	private MinimapPosition minimapPos;

	private Vector3 originalPos;

	private Quaternion originalRot;

	private Transform oldParent;

	private float timer;

	private void Start()
	{
		Init(States.Idle);
		listener = GetComponent<InteractionListener>();
		originalPos = base.transform.position;
		originalRot = base.transform.rotation;
		oldParent = null;
		if (pages == null)
		{
			pages = new RenderTexture[4];
			for (int i = 0; i < pages.Length; i++)
			{
				pages[i] = new RenderTexture(512, 512, 24);
			}
		}
		if (!bookDesc)
		{
			BookDesc[] arrItems = Resources.LoadAll<BookDesc>("BookDescs");
			bookDesc = RandomExt.Choice(arrItems);
		}
		bookDesc.Initialize(this);
	}

	private void Idle_Exit()
	{
		playerInventory = GameObject.FindWithTag(Tags.Inventory).GetComponent<Inventory>();
		minimapPos = GameObject.FindWithTag(Tags.Minimap).GetComponent<MinimapPosition>();
		listener.canInteract = false;
		playerInventory.Reorient();
		oldParent = base.transform.parent;
		base.transform.parent = playerInventory.transform;
		anim.Play("Book_Open2");
		timer = anim["Book_Open2"].length - 0.3f;
		Player.GetComponent<PlayerGameController>().BlockMovement(blockRotation: false);
		playerInventory.Block();
		if (pickUpSound != null)
		{
			AudioSource.PlayClipAtPoint(pickUpSound, base.transform.position);
		}
		if (!GameController.Get().UsingGamepad)
		{
			GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchFuel>().btnEnabled = false;
		}
	}

	private void PickedUp_Enter()
	{
		pageLeft.gameObject.SetActive(value: true);
		pageRight.gameObject.SetActive(value: true);
		pageFlip.gameObject.SetActive(value: true);
		updatePagesFrom = 0;
		pageOffset = 0;
		pageLeft.SetPageBack(pages[0]);
		pageFlip.SetPageFront(pages[1]);
		pageFlip.SetPageBack(pages[2]);
		pageRight.SetPageFront(pages[3]);
	}

	private void PickedUp_Update()
	{
		Vector3 b = playerInventory.transform.position + playerInventory.transform.forward * posForward + playerInventory.transform.up * posUp;
		base.transform.position = Vector3.Lerp(base.transform.position, b, Time.deltaTime * 4f);
		Quaternion quaternion = Quaternion.Euler(pickedUpRotX, pickedUpRotY, pickedUpRotZ);
		quaternion = playerInventory.transform.rotation * quaternion;
		base.transform.rotation = Quaternion.Slerp(base.transform.rotation, quaternion, Time.deltaTime * 4f);
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Reading;
		}
		minimapPos.Hide = true;
		if (Input.GetButtonDown("Cancel") || Input.GetButtonDown("Inventory"))
		{
			base.State = States.Closing;
		}
	}

	private void Reading_Update()
	{
		minimapPos.Hide = true;
		if (Input.GetButtonDown("Inventory"))
		{
			base.State = States.Closing;
		}
		if (Input.GetButtonDown("Fire1") || Input.GetButtonDown("NextPage"))
		{
			if (CanFlipPage())
			{
				base.State = States.PageFlip;
			}
			else
			{
				base.State = States.Closing;
			}
		}
		else if ((!GameController.Get().UsingGamepad && Input.GetButtonDown("Cancel")) || Input.GetButtonDown("PrevPage"))
		{
			if (pageOffset > 0)
			{
				base.State = States.PageFlipBack;
			}
			else
			{
				base.State = States.Closing;
			}
		}
		else if (GameController.Get().UsingGamepad && Input.GetButtonDown("Cancel"))
		{
			base.State = States.Closing;
		}
	}

	private void PageFlip_Enter()
	{
		timer = pageFlip.Flip();
		pageRight.SetPageFront(pages[3]);
		if ((bool)pageFlipSound)
		{
			AudioSource.PlayClipAtPoint(pageFlipSound, base.transform.position);
		}
	}

	private void PageFlip_Update()
	{
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Reading;
		}
	}

	private void PageFlip_Exit()
	{
		pageLeft.SetPageBack(pageFlip.GetPageBack());
		pageFlip.SetPageFront(pageRight.GetPageFront());
		pageFlip.Reset();
		Texture texture = pages[0];
		Texture texture2 = pages[1];
		for (int i = 0; i < pages.Length - 2; i++)
		{
			pages[i] = pages[i + 2];
		}
		pages[pages.Length - 2] = (RenderTexture)texture;
		pages[pages.Length - 1] = (RenderTexture)texture2;
		pageFlip.SetPageBack(pages[2]);
		updatePagesFrom = pages.Length - 2;
		pageOffset += 2;
	}

	private void PageFlipBack_Enter()
	{
		updatePagesFrom = 0;
		pageOffset -= 2;
		pageLeft.SetPageBack(pages[0]);
		pageFlip.SetPageFront(pages[1]);
		pageFlip.SetPageBack(pages[2]);
		pageRight.SetPageFront(pages[3]);
		timer = pageFlip.Flip(invert: true);
		if ((bool)pageFlipSound)
		{
			AudioSource.PlayClipAtPoint(pageFlipSound, base.transform.position);
		}
	}

	private void PageFlipBack_Update()
	{
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Reading;
		}
	}

	private void PageFlipBack_Exit()
	{
		pageRight.SetPageFront(pageFlip.GetPageFront());
		pageFlip.Reset();
	}

	private void Closing_Enter()
	{
		Player.GetController().UnblockMovement(unBlockRotation: false);
		playerInventory.Unblock();
		base.transform.parent = oldParent;
		if (leaveSound != null)
		{
			AudioSource.PlayClipAtPoint(leaveSound, base.transform.position);
		}
		anim.Play("Book_Close2");
		timer = 0.9f;
	}

	private void Closing_Update()
	{
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Returning;
		}
	}

	private void Closing_Exit()
	{
		pageLeft.gameObject.SetActive(value: false);
		pageRight.gameObject.SetActive(value: false);
		pageFlip.gameObject.SetActive(value: false);
		if (!GameController.Get().UsingGamepad)
		{
			GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchFuel>().btnEnabled = true;
		}
	}

	private void Returning_Update()
	{
		Vector3 vector = Vector3.Lerp(base.transform.position, originalPos, Time.deltaTime * 2f);
		base.transform.position = vector;
		Quaternion quaternion = Quaternion.Slerp(base.transform.rotation, originalRot, Time.deltaTime * 3f);
		base.transform.rotation = quaternion;
		float num = Quaternion.Angle(quaternion, originalRot);
		if ((vector - originalPos).sqrMagnitude <= 1.0000001E-06f && num <= 1f)
		{
			base.State = States.Idle;
		}
	}

	private void Returning_Exit()
	{
		listener.canInteract = true;
	}

	public void OnPlayerInteraction(InteractionListener listener)
	{
		this.listener = listener;
		if (base.State == States.Idle)
		{
			base.State = States.PickedUp;
		}
	}

	private void OnGUI()
	{
		if (updatePagesFrom < 0 || updatePagesFrom >= pages.Length || Event.current.type != EventType.Repaint)
		{
			return;
		}
		for (int i = updatePagesFrom; i < pages.Length; i++)
		{
			int num = pageOffset + i;
			int num2 = 0;
			BookDesc.BookSection bookSection = bookDesc.sections[num2];
			while (num >= bookSection.firstPage + bookSection.Pages && num2 < bookDesc.sections.Length - 1)
			{
				bookSection = bookDesc.sections[++num2];
			}
			num -= bookSection.firstPage;
			string textPage = ((num >= bookSection.textPages.Length) ? string.Empty : bookSection.textPages[num]);
			FillPageContents(pages[i], textPage, bookSection.image, (bookSection.type != BookDesc.BookSection.SectionType.Title) ? textStyle : titleStyle);
		}
		updatePagesFrom = pages.Length;
	}

	private bool CanFlipPage()
	{
		BookDesc.BookSection bookSection = bookDesc.sections[bookDesc.sections.Length - 1];
		int num = bookSection.firstPage + bookSection.Pages;
		return pageOffset + 2 < num;
	}

	private void FillPageContents(RenderTexture page, string textPage, Texture image, GUIStyle style)
	{
		RenderTexture active = RenderTexture.active;
		Matrix4x4 matrix = GUI.matrix;
		Font font = GUI.skin.font;
		float x = (float)Screen.width / 512f;
		float y = (float)Screen.height / 512f;
		GUI.matrix = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, new Vector3(x, y, 1f));
		RenderTexture.active = page;
		GL.Clear(clearDepth: false, clearColor: true, new Color(0f, 0f, 0f, 0f));
		if (image != null)
		{
			GUI.Box(new Rect(0f, 0f, 512f, 512f), image);
		}
		GUI.Box(new Rect(0f, 0f, 512f, 512f), textPage, style);
		RenderTexture.active = active;
		GUI.matrix = matrix;
		GUI.skin.font = font;
	}
}
public class BookDesc : ScriptableObject
{
	[Serializable]
	public class BookSection
	{
		public enum SectionType
		{
			Content,
			Title,
			BlankPage
		}

		public SectionType type;

		public string fullTextId = "BOOK_TEST";

		public Texture image;

		[NonSerialized]
		public string[] textPages;

		[NonSerialized]
		public int firstPage;

		public int Pages => textPages.Length;
	}

	public BookSection[] sections;

	[NonSerialized]
	public bool initialized;

	public void Initialize(Book book)
	{
		if (initialized)
		{
			return;
		}
		int num = 0;
		BookSection[] array = sections;
		foreach (BookSection bookSection in array)
		{
			bookSection.firstPage = num;
			if (bookSection.type == BookSection.SectionType.BlankPage)
			{
				bookSection.textPages = new string[1];
			}
			else
			{
				SplitTextContent(bookSection, book);
			}
			num += bookSection.Pages;
		}
		initialized = true;
	}

	private void SplitTextContent(BookSection section, Book book)
	{
		string text = Translate.Get(section.fullTextId);
		GUIStyle gUIStyle = ((section.type != BookSection.SectionType.Title) ? book.textStyle : book.titleStyle);
		float num = gUIStyle.CalcHeight(new GUIContent(text), 512f);
		int num2 = Mathf.CeilToInt(num / 512f);
		num += (float)(num2 * (gUIStyle.padding.top + gUIStyle.padding.bottom));
		num2 = Mathf.CeilToInt(num / 512f);
		section.textPages = new string[num2];
		int num3 = 0;
		for (int i = 0; i < num2 - 1; i++)
		{
			while (i > 0 && num3 < text.Length && text[num3] == '\n')
			{
				num3++;
			}
			int num4 = num3;
			while (num4 < text.Length)
			{
				int num5 = num4;
				int j;
				for (j = num5; j < text.Length && text[j] != ' ' && text[j] != '\n'; j++)
				{
				}
				string text2 = text.Substring(num5, j - num5 + 1);
				string text3 = section.textPages[i] + text2;
				float num6 = gUIStyle.CalcHeight(new GUIContent(text3), 512f);
				if (num6 <= 512f)
				{
					section.textPages[i] = text3;
					num4 = j + 1;
					continue;
				}
				break;
			}
			num3 = num4;
		}
		if (section.textPages.Length >= 1)
		{
			section.textPages[section.textPages.Length - 1] = text.Substring(num3, text.Length - num3);
		}
	}
}
public class DistanceDestroyer : MonoBehaviour
{
	public float primeDistance = 2.5f;

	public float destructionDistance = 3.5f;

	public float destructionDistanceMax = 15f;

	private bool primed;

	private void Update()
	{
		float sqrMagnitude = (Player.GetGroundPos() - base.transform.position.ToGround()).sqrMagnitude;
		if (!primed && sqrMagnitude <= primeDistance * primeDistance)
		{
			primed = true;
		}
		else if (primed && sqrMagnitude >= destructionDistance * destructionDistance)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		else if (sqrMagnitude >= destructionDistanceMax * destructionDistanceMax)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class Door : MonoBehaviour
{
	public float OpenDistance = 2f;

	public bool IsOpen;

	public bool IsDestroyed;

	private bool invertedOpen;

	private bool ignoreInteractions;

	public Transform playerLook;

	public AudioClip OpenSound;

	public AudioClip CloseSound;

	private bool playSoundOnClose;

	public GameObject BashEffect;

	public GameObject BashSmallEffect;

	public AudioClip BashScream;

	public AudioClip BashDestroy;

	public AudioClip CreakSound;

	public GameObject WindEffect;

	private Collider safetyCollider;

	private Transform doorObj;

	private bool inCollisionOpen;

	private bool playerContact;

	private BoxCollider mainCollider;

	private Animation animation;

	private void Start()
	{
		IsOpen = false;
		playerLook = Player.GetLook();
		invertedOpen = false;
		safetyCollider = null;
		animation = GetComponent<Animation>();
		ignoreInteractions = false;
		playSoundOnClose = false;
		doorObj = base.transform.Find("wall_02_c/door_01_c");
		Serializer.Add(this, OnSerialize, OnDeserialize);
	}

	private void OnSerialize(BinaryWriter writer)
	{
		writer.Write(IsOpen);
		writer.Write(invertedOpen);
		bool value = false;
		Unlockable componentInChildren = base.gameObject.GetComponentInChildren<Unlockable>();
		if (componentInChildren != null)
		{
			value = componentInChildren.Locked;
		}
		writer.Write(value);
	}

	private void OnDeserialize(BinaryReader reader)
	{
		bool flag = reader.ReadBoolean();
		bool flag2 = reader.ReadBoolean();
		bool locked = reader.ReadBoolean();
		if (flag && !IsOpen)
		{
			string text = ((!flag2) ? "DoorAnimOpen" : "DoorAnimOpen_Inv");
			animation.Play(text);
			animation[text].normalizedTime = 0.9f;
			if (safetyCollider != null)
			{
				safetyCollider.enabled = false;
			}
		}
		IsOpen = flag;
		invertedOpen = flag2;
		Unlockable componentInChildren = base.gameObject.GetComponentInChildren<Unlockable>();
		if (componentInChildren != null)
		{
			componentInChildren.Locked = locked;
		}
	}

	public void OnCollision(GameObject obj, bool isPlayer = false, bool isFront = true, BoxCollider collider = null)
	{
		if (isPlayer)
		{
			playerContact = true;
		}
		if (!IsOpen && animation.isPlaying && (!isPlayer || ((isFront || !invertedOpen) && (!isFront || invertedOpen))))
		{
			playSoundOnClose = false;
			IsOpen = true;
			animation.Stop();
			ignoreInteractions = true;
			bool flag = false;
			if (isPlayer)
			{
				flag = Player.GetController().isRunning;
			}
			if (collider != null)
			{
				mainCollider = collider;
				mainCollider.size = new Vector3(mainCollider.size.x, mainCollider.size.y, mainCollider.size.z * 0.5f);
			}
			inCollisionOpen = true;
		}
	}

	private void FixedUpdate()
	{
		if (inCollisionOpen)
		{
			float y = doorObj.localRotation.eulerAngles.y;
			float num = ((!invertedOpen) ? 84.02932f : 275.97067f);
			float num2 = Interpolate.Approach(y, num, Time.deltaTime * 10f);
			bool flag = Mathf.Abs(num - num2) <= 0.5f;
			doorObj.localEulerAngles = new Vector3(doorObj.localRotation.eulerAngles.x, num2, doorObj.localRotation.eulerAngles.z);
			if (flag)
			{
				inCollisionOpen = false;
			}
		}
		if (!inCollisionOpen && !playerContact && (ignoreInteractions || mainCollider != null))
		{
			if (mainCollider != null)
			{
				mainCollider.size = new Vector3(mainCollider.size.x, mainCollider.size.y, mainCollider.size.z * 2f);
				mainCollider = null;
			}
			ignoreInteractions = false;
		}
		playerContact = false;
	}

	private void SetState(bool bOpen, bool sound = true, Transform actor = null)
	{
		if (bOpen == IsOpen)
		{
			return;
		}
		IsOpen = bOpen;
		if (bOpen)
		{
			invertedOpen = actor != null && !IsInFront(actor.position);
			animation.Play((!invertedOpen) ? "DoorAnimOpen" : "DoorAnimOpen_Inv");
			if (safetyCollider != null)
			{
				safetyCollider.enabled = false;
			}
			if (sound)
			{
				AudioSource.PlayClipAtPoint(OpenSound, base.transform.position + Vector3.up);
			}
		}
		else
		{
			animation.Play((!invertedOpen) ? "DoorAnimClose" : "DoorAnimClose_Inv");
			playSoundOnClose = sound;
		}
	}

	public void PlaySoundClose()
	{
		if (playSoundOnClose)
		{
			AudioSource.PlayClipAtPoint(CloseSound, base.transform.position + Vector3.up);
		}
		playSoundOnClose = false;
	}

	public void OnEndCloseAnimation()
	{
		if (safetyCollider != null)
		{
			safetyCollider.enabled = true;
		}
	}

	public void Open(Transform actor = null)
	{
		if (UnityEngine.Random.value <= 0.05f && !Player.IsSafe() && Player.Get().transform == actor)
		{
			OpenAndCloseFast(actor);
			return;
		}
		Unlockable componentInChildren = base.gameObject.GetComponentInChildren<Unlockable>();
		if (componentInChildren != null)
		{
			componentInChildren.Locked = false;
		}
		SetState(bOpen: true, sound: true, actor);
	}

	public void Close()
	{
		SetState(bOpen: false);
	}

	public void Toggle(Transform actor = null)
	{
		if (!animation.isPlaying && !ignoreInteractions)
		{
			SetState(!IsOpen, sound: true, actor);
		}
	}

	public void Bash(bool small = false)
	{
		Vector3 toPosGround = Player.GetToPosGround(base.transform.position);
		toPosGround.Normalize();
		GameObject obj = UnityEngine.Object.Instantiate(rotation: Quaternion.LookRotation((!(Vector3.Dot(toPosGround, base.transform.right) < Vector3.Dot(toPosGround, -base.transform.right))) ? base.transform.right : (-base.transform.right), Vector3.up), original: (!small) ? BashEffect : BashSmallEffect, position: base.transform.position + Vector3.up * 1.3f);
		UnityEngine.Object.Destroy(obj, 3f);
	}

	public void PlayBashWithMonster()
	{
		StartCoroutine(BashWithMonster());
	}

	private IEnumerator BashWithMonster()
	{
		Bash();
		yield return new WaitForSeconds(0.1f);
		AudioSource.PlayClipAtPoint(BashScream, base.transform.position + Vector3.up);
		yield return new WaitForSeconds(0.2f);
		Bash();
	}

	public void PlayBashAndDestroy(bool bDoDestroy = true)
	{
		StartCoroutine(BashAndDestroy(bDoDestroy));
	}

	private IEnumerator BashAndDestroy(bool bDoDestroy)
	{
		Bash();
		yield return new WaitForSeconds(0.8f);
		Bash();
		yield return new WaitForSeconds(0.4f);
		Bash();
		yield return new WaitForSeconds(0.8f);
		Bash();
		if (bDoDestroy)
		{
			yield return new WaitForSeconds(1.1f);
			Bash();
			AudioSource.PlayClipAtPoint(BashDestroy, base.transform.position + Vector3.up);
			Transform doorObj = base.transform.Find("wall_02_c/door_01_c");
			UnityEngine.Object.Destroy(doorObj.gameObject);
			IsOpen = true;
			IsDestroyed = true;
			if (safetyCollider != null)
			{
				safetyCollider.enabled = false;
			}
		}
	}

	public void PlayBashAndOpen(bool bDoOpen = true, Transform actor = null)
	{
		StartCoroutine(BashAndOpen(bDoOpen, actor));
	}

	private IEnumerator BashAndOpen(bool bDoOpen, Transform actor)
	{
		Bash();
		yield return new WaitForSeconds(0.8f);
		Bash();
		yield return new WaitForSeconds(0.4f);
		Bash();
		yield return new WaitForSeconds(0.8f);
		Bash();
		if (bDoOpen)
		{
			OpenFast(actor);
		}
	}

	public void Creak()
	{
		if (IsOpen && !invertedOpen)
		{
			animation.Play((!invertedOpen) ? "DoorAnimCreak" : "DoorAnimCreak_Inv");
			AudioSource.PlayClipAtPoint(CreakSound, base.transform.position);
		}
	}

	public void OpenWithCreak(Transform actor = null)
	{
		if (IsOpen)
		{
			return;
		}
		Unlockable componentInChildren = base.gameObject.GetComponentInChildren<Unlockable>();
		if (componentInChildren != null)
		{
			if (componentInChildren.IsTutorial)
			{
				return;
			}
			componentInChildren.Locked = false;
		}
		IsOpen = true;
		invertedOpen = actor != null && !IsInFront(actor.position);
		animation.Play((!invertedOpen) ? "DoorAnimOpenSlow" : "DoorAnimOpenSlow_Inv");
		AudioSource.PlayClipAtPoint(CreakSound, base.transform.position);
		if (safetyCollider != null)
		{
			safetyCollider.enabled = false;
		}
	}

	public void OpenFast(Transform actor = null)
	{
		if (!IsOpen)
		{
			Unlockable componentInChildren = base.gameObject.GetComponentInChildren<Unlockable>();
			if (componentInChildren != null)
			{
				componentInChildren.Locked = false;
			}
			IsOpen = true;
			invertedOpen = actor != null && !IsInFront(actor.position);
			animation.Play((!invertedOpen) ? "DoorAnimOpenForce" : "DoorAnimOpenForce_Inv");
			if (safetyCollider != null)
			{
				safetyCollider.enabled = false;
			}
		}
	}

	public void CloseFast()
	{
		if (IsOpen)
		{
			animation.Stop();
			playSoundOnClose = false;
			IsOpen = false;
			Transform transform = base.transform.Find("wall_02_c/door_01_c");
			iTween.RotateTo(transform.gameObject, iTween.Hash("y", 0f, "islocal", true, "speed", 100f, "easetype", iTween.EaseType.easeInCubic, "oncomplete", "CloseFast_End", "oncompletetarget", base.gameObject));
		}
	}

	private void CloseFast_End()
	{
		Bash(small: true);
	}

	public void OpenAndCloseFast(Transform actor)
	{
		StartCoroutine(OpenAndCloseFast_co(actor));
	}

	private IEnumerator OpenAndCloseFast_co(Transform actor)
	{
		SetState(bOpen: true, sound: true, actor);
		AddWind();
		yield return new WaitForSeconds(1.2f);
		if (UnityEngine.Random.value <= 0.2f)
		{
			GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchLight>().FlickerOut(turnOff: true);
		}
		else if (UnityEngine.Random.value <= 0.8f)
		{
			GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchLight>().FlickerOut();
		}
		CloseFast();
	}

	public void CloseFastWithWind()
	{
		StartCoroutine(CloseFastWithWind_co());
	}

	private IEnumerator CloseFastWithWind_co()
	{
		AddWind();
		yield return new WaitForSeconds(0.5f);
		CloseFast();
	}

	public void OpenWithWind(Transform actor = null)
	{
		StartCoroutine(OpenWithWind_co(actor));
	}

	private IEnumerator OpenWithWind_co(Transform actor)
	{
		Unlockable unlockable = base.gameObject.GetComponentInChildren<Unlockable>();
		if (unlockable != null)
		{
			if (unlockable.IsTutorial)
			{
				yield break;
			}
			unlockable.Locked = false;
		}
		AddWind(reverse: true);
		yield return new WaitForSeconds(0.5f);
		SetState(bOpen: true, sound: false, actor);
	}

	public void SetLocked(bool locked = true, Unlockable.Difficulty difLevel = Unlockable.Difficulty.Uninitialized)
	{
		Unlockable componentInChildren = base.gameObject.GetComponentInChildren<Unlockable>();
		if (componentInChildren != null)
		{
			if (componentInChildren.difficultyLevel == Unlockable.Difficulty.Uninitialized)
			{
				componentInChildren.InitLocked(difLevel);
			}
			componentInChildren.Locked = locked;
		}
	}

	private void AddWind(bool reverse = false)
	{
		Vector3 vector = base.transform.right;
		if (reverse)
		{
			vector = -vector;
		}
		UnityEngine.Object.Instantiate(WindEffect, base.transform.position - vector * 2.5f + Vector3.up * 0.5f, Quaternion.LookRotation(vector, Vector3.up));
	}

	public bool IsInFront(Vector3 objPos)
	{
		Vector3 right = base.transform.right;
		Vector3 vec = objPos - base.transform.position;
		vec = vec.GroundNormalize();
		float num = Vector3.Dot(right, vec);
		return num >= 0f;
	}
}
public class DoorCollision : MonoBehaviour
{
	public Door parentDoor;

	public bool buildTrigger = true;

	private BoxCollider mainCollider;

	private BoxCollider triggerColliderFront;

	private BoxCollider triggerColliderBack;

	private void Start()
	{
		Transform parent = base.transform;
		while (parent != null && parentDoor == null)
		{
			parentDoor = parent.GetComponent<Door>();
			parent = parent.parent;
		}
		if (parentDoor == null)
		{
			base.enabled = false;
		}
		else if (buildTrigger)
		{
			BuildTriggerCollider();
		}
	}

	public void OnPlayerCollision(GameObject obj, Collider trigger)
	{
		parentDoor.OnCollision(obj, isPlayer: true, trigger == triggerColliderFront, mainCollider);
	}

	private void OnCollisionEnter(Collision collision)
	{
		parentDoor.OnCollision(collision.gameObject);
	}

	private void OnCollisionStay(Collision collision)
	{
		if (collision.gameObject != Player.Get())
		{
			parentDoor.OnCollision(collision.gameObject);
		}
	}

	private void OnTriggerStay(Collider other)
	{
		if (other.gameObject.CompareTag(Tags.Ghost) || other.gameObject.CompareTag(Tags.Creature))
		{
			parentDoor.OnCollision(other.gameObject);
		}
	}

	private void BuildTriggerCollider()
	{
		GameObject gameObject = new GameObject();
		gameObject.name = "DoorTrigger";
		gameObject.tag = Tags.DoorTrigger;
		gameObject.layer = LayerMask.NameToLayer("Ignore Raycast");
		gameObject.transform.parent = base.transform;
		gameObject.transform.localPosition = Vector3.zero;
		gameObject.transform.localRotation = Quaternion.identity;
		mainCollider = GetComponent<BoxCollider>();
		triggerColliderFront = gameObject.AddComponent<BoxCollider>();
		triggerColliderFront.isTrigger = true;
		triggerColliderFront.center = mainCollider.center;
		triggerColliderFront.size = new Vector3(mainCollider.size.x + 0.05f, mainCollider.size.y, mainCollider.size.z * 3f);
		triggerColliderBack = gameObject.AddComponent<BoxCollider>();
		triggerColliderBack.isTrigger = true;
		triggerColliderBack.center = mainCollider.center;
		triggerColliderBack.size = triggerColliderFront.size;
		triggerColliderFront.center += new Vector3(-0.05f, 0f, triggerColliderFront.size.z / 2f);
		triggerColliderBack.center += new Vector3(-0.05f, 0f, (0f - triggerColliderBack.size.z) / 2f);
		Rigidbody rigidbody = gameObject.AddComponent<Rigidbody>();
		rigidbody.isKinematic = true;
		rigidbody.interpolation = RigidbodyInterpolation.Interpolate;
		DoorCollision doorCollision = gameObject.AddComponent<DoorCollision>();
		doorCollision.parentDoor = parentDoor;
		doorCollision.buildTrigger = false;
	}
}
[RequireComponent(typeof(InteractionListener))]
public class Examinable : FSMComponent<Examinable.States>
{
	public enum States
	{
		Idle,
		PickedUp,
		Returning
	}

	public float highlightDistance = 0.6f;

	public AudioClip pickUpSound;

	public AudioClip leaveSound;

	public string textID;

	public TextLabel descLabelPrefab;

	private InteractionListener listener;

	private Inventory playerInventory;

	private MinimapPosition minimapPos;

	private Vector3 originalPos;

	private Quaternion originalRot;

	private Transform oldParent;

	private Vector3 deltaCenter;

	private static TextLabel textLabel;

	private string descriptionText;

	private void Start()
	{
		Init(States.Idle);
		listener = GetComponent<InteractionListener>();
		originalPos = base.transform.position;
		originalRot = base.transform.rotation;
		oldParent = null;
		deltaCenter = Vector3.zero;
		textLabel = null;
		int num = 0;
		string text = textID;
		text.ToUpper();
		while (Translate.Check("OBJ_" + text + "_" + num))
		{
			num++;
		}
		if (num >= 1)
		{
			int num2 = UnityEngine.Random.Range(0, num);
			text = "OBJ_" + textID + "_" + num2;
			text.ToUpper();
			descriptionText = Translate.Get(text);
		}
	}

	private void PickedUp_Enter()
	{
		playerInventory = GameObject.FindWithTag(Tags.Inventory).GetComponent<Inventory>();
		minimapPos = GameObject.FindWithTag(Tags.Minimap).GetComponent<MinimapPosition>();
		listener.canInteract = false;
		playerInventory.Reorient();
		oldParent = base.transform.parent;
		base.transform.parent = playerInventory.transform;
		if (textLabel == null)
		{
			textLabel = UnityEngine.Object.Instantiate(descLabelPrefab);
			textLabel.transform.parent = playerInventory.transform;
		}
		else
		{
			textLabel.gameObject.SetActive(value: true);
		}
		textLabel.Text = descriptionText;
		Vector3 vector = playerInventory.transform.position + playerInventory.transform.forward * highlightDistance + playerInventory.transform.up * 0.4f;
		textLabel.transform.position = vector;
		textLabel.FadeInDelayed(2f, 0.45f);
		Vector3 position = Player.GetLook().position;
		Vector3 forward = position - vector;
		forward.Normalize();
		Quaternion quaternion = Quaternion.LookRotation(forward, Vector3.up);
		Quaternion quaternion2 = Quaternion.AngleAxis(90f, Vector3.right);
		textLabel.transform.rotation = quaternion * quaternion2;
		Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
		deltaCenter = Vector3.zero;
		if (componentsInChildren.Length > 0)
		{
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				deltaCenter += componentsInChildren[i].bounds.center;
			}
			deltaCenter /= (float)componentsInChildren.Length;
			deltaCenter = base.transform.InverseTransformPoint(deltaCenter);
		}
		Player.GetController().BlockMovement(blockRotation: false);
		playerInventory.Block();
		if (pickUpSound != null)
		{
			AudioSource.PlayClipAtPoint(pickUpSound, base.transform.position);
		}
	}

	private void PickedUp_Update()
	{
		Vector3 vector = base.transform.TransformPoint(deltaCenter) - base.transform.position;
		Vector3 b = playerInventory.transform.position + playerInventory.transform.forward * highlightDistance + playerInventory.transform.up * 0.15f;
		base.transform.position = Vector3.Lerp(base.transform.position + vector, b, Time.deltaTime * 4f) - vector;
		float num = 0f;
		float num2 = 0f;
		num = Input.GetAxis("Horizontal") * 140f * Time.deltaTime;
		num2 = Input.GetAxis("Vertical") * 140f * Time.deltaTime;
		Vector3 axis = playerInventory.transform.TransformDirection(new Vector3(1f, 0f, 0f));
		Vector3 axis2 = base.transform.TransformDirection(new Vector3(0f, 1f, 0f));
		base.transform.RotateAround(base.transform.position + vector, axis2, num);
		base.transform.RotateAround(base.transform.position + vector, axis, num2);
		minimapPos.Hide = true;
		if (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.Cancel) || InputExt.GetButtonDown(InputExt.Button.Inventory))
		{
			base.State = States.Returning;
		}
	}

	private void PickedUp_Exit()
	{
		textLabel.FadeOut(8f, disableOnFadeOut: true);
		Player.GetController().UnblockMovement(unBlockRotation: false);
		playerInventory.Unblock();
		base.transform.parent = oldParent;
		if (leaveSound != null)
		{
			AudioSource.PlayClipAtPoint(leaveSound, base.transform.position);
		}
	}

	private void Returning_Update()
	{
		Vector3 vector = Vector3.Lerp(base.transform.position, originalPos, Time.deltaTime * 4f);
		base.transform.position = vector;
		Quaternion quaternion = Quaternion.Slerp(base.transform.rotation, originalRot, Time.deltaTime * 6f);
		base.transform.rotation = quaternion;
		float num = Quaternion.Angle(quaternion, originalRot);
		if ((vector - originalPos).sqrMagnitude <= 1.0000001E-06f && num <= 1f)
		{
			base.State = States.Idle;
		}
	}

	private void Returning_Exit()
	{
		listener.canInteract = true;
	}

	public void OnPlayerInteraction(InteractionListener listener)
	{
		this.listener = listener;
		if (base.State == States.Idle)
		{
			base.State = States.PickedUp;
		}
	}
}
public class ExitDoor : MonoBehaviour
{
	public Light exitLight;

	public Collider exitTrigger;

	public AudioClip openSound;

	public string openAnim = "DoorAnimOpen_Inv";

	private Inventory inventory;

	private LayerMask playerMask;

	private void Start()
	{
		exitLight.enabled = false;
		exitTrigger.enabled = false;
		inventory = Player.Get().GetComponentInChildren<Inventory>();
		playerMask = LayerMaskExtensions.NamesToMask("Player");
		StartCoroutine(Wait_co());
	}

	private IEnumerator Wait_co()
	{
		do
		{
			yield return new WaitForSeconds(0.2f);
		}
		while (!inventory.HasMetaItems());
		exitLight.enabled = true;
		exitTrigger.enabled = true;
		GetComponent<Animation>().Play(openAnim);
		if (openSound != null)
		{
			AudioSource.PlayClipAtPoint(openSound, exitLight.transform.position);
		}
		Map.Get().At(base.transform.position).Occupied = true;
		float targetIntensity = exitLight.intensity;
		exitLight.intensity = 0f;
		float progress = 0f;
		bool pausedDoor = false;
		while (progress <= 1f)
		{
			if (progress >= 0.35f && !pausedDoor)
			{
				pausedDoor = true;
				if (!CheckDoorClear())
				{
					StartCoroutine(Pause_Anim());
				}
			}
			progress = Mathf.Clamp01(progress + Time.deltaTime * 0.5f);
			exitLight.intensity = Interpolate.EaseInOut(0f, targetIntensity, progress);
			yield return 0;
		}
	}

	private IEnumerator Pause_Anim()
	{
		GetComponent<Animation>()[openAnim].speed = 0f;
		bool isClear = false;
		while (!isClear)
		{
			isClear = CheckDoorClear();
			yield return new WaitForSeconds(0.2f);
		}
		GetComponent<Animation>()[openAnim].speed = 1f;
	}

	private bool CheckDoorClear()
	{
		Point point = Map.Get().WorldToCell(Player.Get().transform.position);
		Point point2 = Map.Get().WorldToCell(base.transform.position);
		bool flag = point != point2;
		if (flag)
		{
			flag = Physics.OverlapSphere(base.transform.position, 1f, playerMask).Length == 0;
			DebugExt.DrawSphere(base.transform.position, Color.red, 1f, 0.2f);
		}
		return flag;
	}
}
public class FrightLight : MonoBehaviour
{
	private VisibilityProbe probe;

	private Transform playerLook;

	private bool triggered;

	private float maxIntensity;

	private float currentIntensity;

	private void Start()
	{
		GetComponent<Light>().enabled = false;
		maxIntensity = GetComponent<Light>().intensity;
		GetComponent<Light>().intensity = 0f;
		playerLook = GameObject.FindWithTag(Tags.LookDirection).transform;
		probe = Map.Get().At(base.transform.position).Probe;
	}

	private void Update()
	{
		if (!triggered && probe.IsVisible)
		{
			Vector3 forward = playerLook.forward;
			forward.Normalize();
			Vector3 down = Vector3.down;
			down.Normalize();
			float num = Vector3.Angle(forward, down);
			if (num <= 45f && Vector3Ext.GroundVector(playerLook.position, base.transform.position).sqrMagnitude <= 0.36f && (!Physics.Linecast(playerLook.position, base.transform.position, out var hitInfo) || Utils.IsAncestor(base.transform, hitInfo.collider.transform)))
			{
				triggered = true;
				GetComponent<Light>().enabled = true;
				StartCoroutine(Fright_co());
			}
		}
		if (GetComponent<Light>().enabled)
		{
			GetComponent<Light>().intensity = Interpolate.Approach(GetComponent<Light>().intensity, currentIntensity, Time.deltaTime * 4f);
		}
	}

	private IEnumerator Fright_co()
	{
		yield return new WaitForSeconds(1.2f);
		currentIntensity = maxIntensity;
		SpookSounds spooks = Player.GetComponent<SpookSounds>();
		spooks.PlayScare();
		yield return new WaitForSeconds(1f);
		currentIntensity = 0f;
	}
}
public class HighlightTest : MonoBehaviour
{
}
public class InteractionListener : MonoBehaviour
{
	public bool highlight = true;

	public HighlightEffect highlightFX;

	public Color highlightColor1 = new Color(1f, 0.92f, 0.016f, 1f);

	public Color highlightColor2 = new Color(1f, 0.92f, 0.116f, 0.5f);

	public float highlightFreq = 0.55f;

	public bool singleUse;

	public float distance = 1.5f;

	public LayerMask layerMask;

	private bool visible = true;

	protected Transform playerLook;

	private Vector3 colliderCenter;

	private bool selected;

	private Color curHighlightColor;

	public bool canInteract = true;

	private static Collider[] cachedColliders = new Collider[8];

	protected void Awake()
	{
		if (highlight && highlightFX == null)
		{
			highlightFX = base.gameObject.AddComponent<HighlightEffect>();
		}
		curHighlightColor = new Color(highlightColor1.r, highlightColor1.g, highlightColor1.b, 0f);
		layerMask = LayerMaskExtensions.Create("Default", "TransparentFX", "LightCaster", "Collectable", "Prop", "StaticGeometry");
	}

	protected void Start()
	{
		Collider componentInChildren = GetComponentInChildren<Collider>();
		if (componentInChildren != null)
		{
			colliderCenter = componentInChildren.bounds.center;
		}
		else
		{
			colliderCenter = base.transform.position;
		}
		colliderCenter -= base.transform.position;
	}

	protected void Update()
	{
		if (!visible)
		{
			return;
		}
		playerLook = Player.GetLook(interaction: true);
		Vector3 vector = playerLook.position - (base.transform.position + colliderCenter);
		bool flag = false;
		if (canInteract && vector.sqrMagnitude <= distance * distance)
		{
			Collider component = GetComponent<Collider>();
			bool flag2 = false;
			if (Physics.Raycast(playerLook.position, playerLook.forward, out var hitInfo, distance, layerMask) && (hitInfo.collider == component || hitInfo.collider.transform.parent == base.transform))
			{
				flag2 = true;
			}
			else
			{
				int num = Physics.OverlapSphereNonAlloc(playerLook.position, 0.02f, cachedColliders, layerMask);
				for (int i = 0; i < num; i++)
				{
					if (cachedColliders[i] == component || cachedColliders[i].transform.parent == base.transform)
					{
						flag2 = true;
						break;
					}
				}
			}
			if (flag2)
			{
				flag = true;
				Player.GetMinimapPos().Hide = true;
				OnHighlight();
			}
		}
		if ((bool)highlightFX)
		{
			if (flag)
			{
				Color b = Color.Lerp(highlightColor1, highlightColor2, 0.5f * Mathf.Sin(Time.realtimeSinceStartup * highlightFreq * (float)Math.PI * 2f) + 0.5f);
				Color color = Color.Lerp(curHighlightColor, b, Time.deltaTime * 8f);
				curHighlightColor = color;
				highlightFX.FadeIn();
			}
			else
			{
				highlightFX.FadeOut();
			}
		}
		if (flag)
		{
			if (InputExt.GetButtonDown(InputExt.Button.Action) && OnInteraction() && singleUse)
			{
				canInteract = false;
			}
		}
		else if (selected && (bool)highlightFX)
		{
			highlightFX.FadeOut();
		}
		selected = flag;
	}

	private void OnBecameVisible()
	{
		visible = true;
	}

	private void OnBecameInvisible()
	{
		visible = false;
		if ((bool)highlightFX)
		{
			highlightFX.FadeOut();
			curHighlightColor = new Color(highlightColor1.r, highlightColor1.g, highlightColor1.b, 0f);
		}
	}

	protected virtual bool OnInteraction()
	{
		base.gameObject.SendMessage("OnPlayerInteraction", this, SendMessageOptions.DontRequireReceiver);
		return true;
	}

	protected virtual void OnHighlight()
	{
	}
}
public class InteractiveLightEx : ProgressInteraction
{
	public bool lightOn = true;

	public AudioClip lightSound;

	private TorchLight torchLight;

	private ParticleSystem[] particles;

	public bool endlessFuel;

	public float fuelTime;

	public bool invulnerable;

	public Renderer[] illuminatedRenderers;

	private List<Pair<Material, float>> illuminatedMaterials;

	private new void Start()
	{
		base.Start();
		torchLight = GetComponentInChildren<TorchLight>();
		particles = GetComponentsInChildren<ParticleSystem>();
		if (!torchLight)
		{
			Debug.LogError("No TorchLight component in InteractiveLight!");
			UnityEngine.Object.Destroy(this);
			return;
		}
		illuminatedMaterials = new List<Pair<Material, float>>();
		for (int i = 0; i < illuminatedRenderers.Length; i++)
		{
			Material[] materials = illuminatedRenderers[i].materials;
			foreach (Material material in materials)
			{
				if (material.HasProperty("_EmissionIntensity"))
				{
					illuminatedMaterials.Add(new Pair<Material, float>(material, material.GetFloat("_EmissionIntensity")));
				}
			}
		}
		Room room = Map.Get().At(base.transform.position).Room;
		if (room != null)
		{
			if (room.Safe)
			{
				lightOn = UnityEngine.Random.value <= 0.9f;
			}
			else
			{
				lightOn = UnityEngine.Random.value <= 0.35f;
			}
			room.lights.Add(this);
		}
		else
		{
			lightOn = UnityEngine.Random.value <= 0.025f;
		}
		if (invulnerable)
		{
			lightOn = true;
		}
		PropInfo component = GetComponent<PropInfo>();
		if (component != null && component.CheckTag("on"))
		{
			lightOn = true;
		}
		else if (component != null && component.CheckTag("off"))
		{
			lightOn = false;
		}
		if (!lightOn)
		{
			torchLight.factor = 0f;
			SetParticlesEmission(enabled: false);
			endlessFuel = false;
		}
		else
		{
			torchLight.factor = 1f;
			SetParticlesEmission(enabled: true);
			endlessFuel = true;
		}
		fuelTime = 0f;
	}

	private new void Update()
	{
		base.Update();
		if (!endlessFuel && !invulnerable)
		{
			fuelTime -= Time.deltaTime;
			if (fuelTime <= 0f)
			{
				TurnOff();
			}
		}
		needsProgress = !lightOn;
		torchLight.factor = iTween.FloatUpdate(torchLight.factor, (!lightOn) ? 0f : 1f, 0.5f);
		for (int i = 0; i < illuminatedMaterials.Count; i++)
		{
			Material first = illuminatedMaterials[i].First;
			float second = illuminatedMaterials[i].Second;
			float @float = first.GetFloat("_EmissionIntensity");
			@float += ((!lightOn) ? (-0.25f) : 2f) * Time.deltaTime;
			@float = Mathf.Clamp(@float, 0f, second);
			first.SetFloat("_EmissionIntensity", @float);
		}
	}

	protected override void OnFinishProgress()
	{
		TurnOn(perpetual: false);
	}

	public void TurnOn(bool perpetual = true, bool sound = true)
	{
		lightOn = true;
		SetParticlesEmission(enabled: true);
		if (sound && lightSound != null)
		{
			AudioSource.PlayClipAtPoint(lightSound, torchLight.transform.position);
		}
		if (perpetual)
		{
			perpetual = true;
			fuelTime = 0f;
		}
		else
		{
			perpetual = false;
			fuelTime = GlobalParams.Get().lightParams.fuelDuration;
		}
	}

	public void TurnOff(bool fast = false)
	{
		lightOn = false;
		fuelTime = 0f;
		endlessFuel = false;
		SetParticlesEmission(enabled: false);
		if (fast)
		{
			torchLight.factor = 0f;
		}
	}

	private void OnLightTurnOff(TorchLight tlight)
	{
		TurnOff();
	}

	public void FlickerOut(bool turnOff = false)
	{
		if (lightOn)
		{
			torchLight.FlickerOut(turnOff && !invulnerable, base.gameObject);
		}
	}

	private void SetParticlesEmission(bool enabled)
	{
		for (int i = 0; i < particles.Length; i++)
		{
			particles[i].enableEmission = enabled;
		}
	}

	public TorchLight GetTorchLight()
	{
		return torchLight;
	}

	public Light GetLight()
	{
		return torchLight.GetComponent<Light>();
	}
}
public class KillTrigger : PlayerCollision
{
	public override void OnPlayerCollision(GameObject player)
	{
		player.GetComponent<PlayerGameController>().ApplyAttack(100f, "GAMEOVER_PIT");
	}
}
public class MechActor : MonoBehaviour
{
	public virtual void SetProgress(float progress = 1f, bool instantaneous = false, bool playAudio = true)
	{
	}

	public bool CheckTag(string tag)
	{
		PropInfo component = GetComponent<PropInfo>();
		if (component != null)
		{
			return component.CheckTag(tag);
		}
		return false;
	}
}
public class MechChain : InteractionListener
{
	public bool currentState;

	public float speed = 3f;

	public Transform chainObj;

	public float yDelta;

	private Vector3 offPos;

	private Vector3 onPos;

	public List<MechActor> actors;

	public bool addRoomActors = true;

	public AudioClip useClip;

	private new void Start()
	{
		base.Start();
		offPos = chainObj.localPosition;
		onPos = offPos + Vector3.up * yDelta;
		if (actors == null)
		{
			actors = new List<MechActor>();
		}
		if (addRoomActors)
		{
			List<string> tags = GetComponent<PropInfo>().GetTags();
			Room room = Map.Get().At(base.transform.position).Room;
			if (room != null)
			{
				foreach (PropInfo prop in room.props)
				{
					MechActor component = prop.GetComponent<MechActor>();
					if (!(component != null))
					{
						continue;
					}
					bool flag = true;
					if (tags != null && tags.Count > 0)
					{
						flag = false;
						foreach (string item in tags)
						{
							flag |= component.CheckTag(item);
						}
					}
					if (flag)
					{
						actors.Add(component);
					}
				}
			}
		}
		Serializer.Add(this, OnSerialize, OnDeserialize);
	}

	private void OnSerialize(BinaryWriter writer)
	{
		writer.Write(currentState);
		writer.Write(canInteract);
	}

	private void OnDeserialize(BinaryReader reader)
	{
		bool flag = reader.ReadBoolean();
		canInteract = reader.ReadBoolean();
		if (flag == currentState)
		{
			return;
		}
		foreach (MechActor actor in actors)
		{
			actor.SetProgress((!flag) ? 0f : 1f);
		}
		currentState = flag;
	}

	private new void Update()
	{
		base.Update();
		Vector3 to = ((!currentState) ? offPos : onPos);
		chainObj.localPosition = Interpolate.Approach(chainObj.localPosition, to, Time.deltaTime * speed);
	}

	protected override bool OnInteraction()
	{
		currentState = !currentState;
		foreach (MechActor actor in actors)
		{
			actor.SetProgress((!currentState) ? 0f : 1f);
		}
		GetComponentInChildren<AudioSource>().PlayOneShot(useClip);
		return true;
	}
}
public class MechGate : MechActor
{
	public Transform gate;

	public Vector3 closedPos;

	public Vector3 openPos;

	public float speed = 1f;

	public float progressOpen;

	public AudioClip moveClip;

	public AudioClip fallClip;

	private AudioSource audioSource;

	public bool blockTiles = true;

	private Collider collider;

	public bool disableColliderIfOpen;

	private RoomTemplate.PropMarker propMarker;

	private void Start()
	{
		audioSource = GetComponentInChildren<AudioSource>();
		propMarker = GetComponent<PropInfo>().PropMarker;
		collider = GetComponentInChildren<Collider>();
	}

	private void Update()
	{
		Vector3 to = Interpolate.EaseInOut(closedPos, openPos, progressOpen);
		gate.localPosition = Interpolate.Approach(gate.localPosition, to, Time.deltaTime * speed);
	}

	public override void SetProgress(float progress = 1f, bool instantaneous = false, bool playAudio = true)
	{
		if (progress <= 0f || progress >= 1f)
		{
			if (!instantaneous && playAudio)
			{
				audioSource.PlayOneShot(moveClip);
			}
			SetTilesBlocked(progress <= 0f);
		}
		else if (progress < progressOpen && !instantaneous && playAudio)
		{
			audioSource.PlayOneShot(fallClip);
		}
		progressOpen = progress;
		if (instantaneous)
		{
			gate.localPosition = Interpolate.EaseInOut(closedPos, openPos, progressOpen);
		}
	}

	private void SetTilesBlocked(bool blocked)
	{
		if (disableColliderIfOpen)
		{
			collider.enabled = blocked;
		}
		if (!blockTiles)
		{
			return;
		}
		for (int i = propMarker.pos.Y; i < propMarker.pos.Y + propMarker.height; i++)
		{
			for (int j = propMarker.pos.X; j < propMarker.pos.X + propMarker.width; j++)
			{
				Map.Get().At(j, i).Occupied = blocked;
			}
		}
	}
}
public class MechLever : InteractionListener
{
	public bool currentState;

	public float speed = 3f;

	public Transform rotatingObject;

	public float rotAmount = -90f;

	private Quaternion onRot;

	private Quaternion offRot;

	public List<MechActor> actors;

	public bool addRoomActors = true;

	public AudioClip useClip;

	private new void Start()
	{
		base.Start();
		offRot = rotatingObject.localRotation;
		onRot = offRot * Quaternion.AngleAxis(rotAmount, new Vector3(0f, 0f, 1f));
		if (currentState)
		{
			Quaternion quaternion = onRot;
			onRot = offRot;
			offRot = quaternion;
		}
		if (actors == null)
		{
			actors = new List<MechActor>();
		}
		if (addRoomActors)
		{
			List<string> tags = GetComponent<PropInfo>().GetTags();
			Room room = Map.Get().At(base.transform.position).Room;
			if (room != null)
			{
				foreach (PropInfo prop in room.props)
				{
					MechActor component = prop.GetComponent<MechActor>();
					if (!(component != null))
					{
						continue;
					}
					bool flag = true;
					if (tags != null && tags.Count > 0)
					{
						flag = false;
						foreach (string item in tags)
						{
							flag |= component.CheckTag(item);
						}
					}
					if (flag)
					{
						actors.Add(component);
					}
				}
			}
		}
		Serializer.Add(this, OnSerialize, OnDeserialize);
	}

	private void OnSerialize(BinaryWriter writer)
	{
		writer.Write(currentState);
		writer.Write(canInteract);
	}

	private void OnDeserialize(BinaryReader reader)
	{
		bool flag = reader.ReadBoolean();
		canInteract = reader.ReadBoolean();
		if (flag == currentState)
		{
			return;
		}
		foreach (MechActor actor in actors)
		{
			actor.SetProgress((!flag) ? 0f : 1f);
		}
		currentState = flag;
	}

	private new void Update()
	{
		base.Update();
		Quaternion b = ((!currentState) ? offRot : onRot);
		rotatingObject.localRotation = Quaternion.Slerp(rotatingObject.localRotation, b, Time.fixedDeltaTime * speed);
	}

	protected override bool OnInteraction()
	{
		currentState = !currentState;
		foreach (MechActor actor in actors)
		{
			actor.SetProgress((!currentState) ? 0f : 1f);
		}
		GetComponentInChildren<AudioSource>().PlayOneShot(useClip);
		return true;
	}
}
public class MechTileBlocker : MechActor
{
	public float progressOpen;

	private RoomTemplate.PropMarker propMarker;

	private void Start()
	{
		propMarker = GetComponent<PropInfo>().PropMarker;
		SetTilesBlocked(progressOpen <= 0f);
	}

	public override void SetProgress(float progress = 1f, bool instantaneous = false, bool playAudio = true)
	{
		progressOpen = progress;
		if (progress <= 0f || progress >= 1f)
		{
			SetTilesBlocked(progress <= 0f);
		}
	}

	private void SetTilesBlocked(bool blocked)
	{
		for (int i = propMarker.pos.Y; i < propMarker.pos.Y + propMarker.height; i++)
		{
			for (int j = propMarker.pos.X; j < propMarker.pos.X + propMarker.width; j++)
			{
				Map.Get().At(j, i).Occupied = blocked;
			}
		}
	}
}
public class MechWheel : ProgressInteraction
{
	public List<MechActor> actors;

	public bool addRoomActors = true;

	public Transform wheelObj;

	public float deltaAngle;

	public float speed = 1f;

	private Quaternion offRot;

	private Quaternion onRot;

	public AudioSource turnSound;

	public AudioClip mainSound;

	public AudioClip releaseSound;

	public AudioClip finishSound;

	private float curProgress;

	private new void Start()
	{
		base.Start();
		offRot = wheelObj.localRotation;
		onRot = offRot * Quaternion.AngleAxis(deltaAngle, new Vector3(-1f, 0f, 0f));
		if (actors == null)
		{
			actors = new List<MechActor>();
		}
		if (addRoomActors)
		{
			List<string> tags = GetComponent<PropInfo>().GetTags();
			Room room = Map.Get().At(base.transform.position).Room;
			if (room != null)
			{
				foreach (PropInfo prop in room.props)
				{
					MechActor component = prop.GetComponent<MechActor>();
					if (!(component != null))
					{
						continue;
					}
					bool flag = true;
					if (tags != null && tags.Count > 0)
					{
						flag = false;
						foreach (string item in tags)
						{
							flag |= component.CheckTag(item);
						}
					}
					if (flag)
					{
						actors.Add(component);
					}
				}
			}
		}
		Serializer.Add(this, OnSerialize, OnDeserialize);
	}

	private void OnSerialize(BinaryWriter writer)
	{
		writer.Write(needsProgress);
		writer.Write((double)curProgress);
	}

	private void OnDeserialize(BinaryReader reader)
	{
		needsProgress = reader.ReadBoolean();
		curProgress = (float)reader.ReadDouble();
	}

	private new void Update()
	{
		base.Update();
		Quaternion b = Quaternion.Slerp(offRot, onRot, curProgress);
		wheelObj.localRotation = Quaternion.Slerp(wheelObj.localRotation, b, Time.deltaTime * speed);
		if (!IsInteracting() && turnSound.isPlaying)
		{
			float num = Mathf.Abs(Quaternion.Angle(wheelObj.localRotation, offRot));
			if (num <= 15f)
			{
				turnSound.Stop();
			}
		}
	}

	protected override void OnStartProgress()
	{
		turnSound.clip = mainSound;
		turnSound.Play();
	}

	protected override void OnFinishProgress()
	{
		turnSound.Stop();
		curProgress = 1f;
		AudioSource.PlayClipAtPoint(finishSound, wheelObj.position);
		foreach (MechActor actor in actors)
		{
			actor.SetProgress(curProgress, instantaneous: false, playAudio: false);
		}
	}

	protected override void OnProgress(float progress)
	{
		curProgress = progress;
		foreach (MechActor actor in actors)
		{
			actor.SetProgress(curProgress, instantaneous: false, playAudio: false);
		}
	}

	protected override void OnCancelProgress()
	{
		turnSound.Stop();
		turnSound.clip = releaseSound;
		turnSound.Play();
		curProgress = 0f;
		foreach (MechActor actor in actors)
		{
			actor.SetProgress(curProgress, instantaneous: false, playAudio: false);
		}
	}
}
[ExecuteInEditMode]
public class MeshMorpher : MonoBehaviour
{
	public Mesh fromMesh;

	public Mesh toMesh;

	public float factor;

	private Mesh mesh;

	public float Factor
	{
		get
		{
			return factor;
		}
		set
		{
			SetMesh(value);
		}
	}

	private void Awake()
	{
		if (!(fromMesh == null) && !(toMesh == null))
		{
			MeshFilter component = GetComponent<MeshFilter>();
			component.sharedMesh = fromMesh;
			mesh = component.mesh;
		}
	}

	private void Update()
	{
		SetMesh(factor);
	}

	private void SetMesh(float newFactor)
	{
		if (!(fromMesh == null) && !(toMesh == null))
		{
			factor = newFactor;
			Vector3[] vertices = fromMesh.vertices;
			Vector3[] vertices2 = toMesh.vertices;
			Vector3[] array = new Vector3[mesh.vertexCount];
			for (int i = 0; i < array.Length; i++)
			{
				ref Vector3 reference = ref array[i];
				reference = Vector3.Lerp(vertices[i], vertices2[i], factor);
			}
			mesh.vertices = array;
			mesh.RecalculateBounds();
		}
	}
}
public class Oracle : FSMComponent<Oracle.States>
{
	public enum States
	{
		Asleep,
		AsleepClosed,
		Prompt,
		WaitQuestion,
		Replying,
		Closed
	}

	public bool startClosed;

	public AudioSource voiceSource;

	public AudioSource coverSource;

	public AudioClip spectralTone;

	public Transform headObj;

	public Collider coverCollider;

	private Eyes eyes;

	private GameObject player;

	private Transform playerLook;

	private Inventory inventory;

	private VisibilityProbe probe;

	private float timer;

	private bool waiting;

	private int coinPrice;

	private bool pricePaid;

	private bool hasEverSpoken;

	private bool instantClose;

	public string[] promptIDs;

	public AudioClip coverOpen;

	public AudioClip coverClose;

	public OracleQuestions questionDB;

	private List<string> questionIDs;

	private string selectedQuestionID;

	public UIMenuStack dialogMenus;

	private void Start()
	{
		player = Player.Get();
		playerLook = Player.GetLook();
		eyes = GetComponent<Eyes>();
		probe = Map.Get().At(base.transform.position).Probe;
		InitUI();
		Serializer.Add(this, OnSerialize, OnDeserialize);
		if (startClosed)
		{
			Init(States.AsleepClosed);
		}
		else
		{
			Init(States.Asleep);
		}
	}

	private void OnSerialize(BinaryWriter writer)
	{
		writer.Write(coinPrice);
		writer.Write(pricePaid);
		writer.Write(base.State == States.Closed);
		writer.Write(hasEverSpoken);
	}

	private void OnDeserialize(BinaryReader reader)
	{
		coinPrice = reader.ReadInt32();
		pricePaid = reader.ReadBoolean();
		if (reader.ReadBoolean())
		{
			instantClose = true;
			base.State = States.Closed;
		}
		hasEverSpoken = reader.ReadBoolean();
	}

	private void Asleep_Enter()
	{
		eyes.SetClosed();
		dialogMenus.CloseMenu();
		waiting = false;
		if (coverCollider != null)
		{
			coverCollider.enabled = false;
		}
		Player.GetCrosshair().gameObject.SetActive(value: false);
	}

	private void Asleep_Update()
	{
		if (!waiting && probe.IsVisible && PlayerInRange())
		{
			waiting = true;
			timer = UnityEngine.Random.Range(1, 4);
		}
		else
		{
			if (!waiting)
			{
				return;
			}
			timer -= Time.deltaTime;
			if (timer <= 0f)
			{
				if (!pricePaid)
				{
					base.State = States.Prompt;
				}
				else
				{
					base.State = States.WaitQuestion;
				}
			}
		}
	}

	private void AsleepClosed_Enter()
	{
		eyes.SetClosed();
		GetComponent<Animation>().Play("CloseCover");
		dialogMenus.CloseMenu();
		waiting = false;
		if (coverCollider != null)
		{
			coverCollider.enabled = true;
		}
		Player.GetCrosshair().gameObject.SetActive(value: false);
	}

	private void AsleepClosed_Exit()
	{
		GetComponent<Animation>().Play("OpenCover");
		coverSource.Stop();
		coverSource.clip = coverOpen;
		coverSource.Play();
	}

	public void OpenCover()
	{
		if (base.State == States.AsleepClosed)
		{
			base.State = States.Asleep;
			if (coverCollider != null)
			{
				coverCollider.enabled = false;
			}
		}
	}

	private void Prompt_Enter()
	{
		inventory = Player.GetComponentInChildren<Inventory>();
		string idClip = RandomExt.Choice(promptIDs);
		AudioClip soundClip = OracleQuestions.GetSoundClip(idClip);
		voiceSource.clip = soundClip;
		timer = UnityEngine.Random.Range(1f, 3f);
		voiceSource.PlayDelayed(timer);
		coinPrice = GetPrice();
		ShowUIPromptPay(coinPrice, timer);
		timer += soundClip.length + 1f;
		AudioSource.PlayClipAtPoint(spectralTone, playerLook.position);
		if (GameController.Get().gameState.oracleNumAsked == 0 && !hasEverSpoken)
		{
			FearEffect.Get().Scare(jumpScare: true);
		}
		hasEverSpoken = true;
	}

	private void Prompt_Update()
	{
		UpdateEyes();
		if (CheckBackToSleep())
		{
			base.State = States.Asleep;
		}
	}

	private void Prompt_Exit()
	{
		StopAllCoroutines();
		dialogMenus.GetMenu("PromptPay").GetComponent<UIMenuAnimator>().animateSize = false;
	}

	private void Prompt_OnPay()
	{
		inventory.ConsumeItem(Collectable.EItemType.Coin, coinPrice);
		pricePaid = true;
		base.State = States.WaitQuestion;
	}

	private void WaitQuestion_Enter()
	{
		questionIDs = new List<string>();
		questionDB.SelectQuestions(questionIDs, GameController.Get().gameState.oracleTags);
		ShowUIQuestions();
	}

	private void WaitQuestion_Update()
	{
		UpdateEyes();
		if (CheckBackToSleep())
		{
			base.State = States.Asleep;
		}
	}

	private void WaitQuestion_OnSelect(int indexQuestion)
	{
		selectedQuestionID = questionIDs[indexQuestion];
		base.State = States.Replying;
	}

	private void Replying_Enter()
	{
		ShowUISubtitle(selectedQuestionID);
		questionDB.AskQuestion(selectedQuestionID, GameController.Get().gameState.oracleTags);
		GameController.Get().gameState.oracleNumAsked++;
		AudioClip soundClip = OracleQuestions.GetSoundClip(selectedQuestionID);
		timer = UnityEngine.Random.Range(0.1f, 0.5f);
		if (soundClip == null)
		{
			Debug.LogError("Missing Oracle audio file: " + selectedQuestionID);
			return;
		}
		voiceSource.clip = soundClip;
		voiceSource.PlayDelayed(timer);
		timer += soundClip.length + 1.5f;
	}

	private void Replying_Update()
	{
		UpdateEyes();
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Closed;
		}
	}

	private void Replying_Exit()
	{
		dialogMenus.CloseMenu();
	}

	private void Closed_Enter()
	{
		eyes.SetClosed();
		waiting = true;
		timer = UnityEngine.Random.Range(1.5f, 3f);
		dialogMenus.CloseMenu();
		Player.GetCrosshair().gameObject.SetActive(value: false);
		if (instantClose)
		{
			waiting = false;
			GetComponent<Animation>().Play("CloseCover");
			GetComponent<Animation>()["CloseCover"].normalizedTime = 1f;
			GetComponent<Animation>().Sample();
			if (coverCollider != null)
			{
				coverCollider.enabled = true;
			}
			instantClose = false;
		}
	}

	private void Closed_Update()
	{
		if (!waiting)
		{
			return;
		}
		timer -= Time.deltaTime;
		if (!(timer <= 0f))
		{
			return;
		}
		bool flag = false;
		if (coverCollider != null)
		{
			if ((Player.GetGroundPos() - coverCollider.transform.position.ToGround()).sqrMagnitude >= 1.44f)
			{
				flag = true;
			}
		}
		else
		{
			flag = true;
		}
		if (flag)
		{
			waiting = false;
			GetComponent<Animation>().Play("CloseCover");
			coverSource.Stop();
			coverSource.clip = coverClose;
			coverSource.Play();
			if (coverCollider != null)
			{
				coverCollider.enabled = true;
			}
		}
	}

	private void Closed_Exit()
	{
		GetComponent<Animation>().Play("OpenCover");
		coverSource.Stop();
		coverSource.clip = coverOpen;
		coverSource.Play();
	}

	private bool CheckBackToSleep()
	{
		return !PlayerInRange(asleep: false) || (!probe.IsVisible && (playerLook.transform.position - base.transform.position).sqrMagnitudeGround() >= 6.25f);
	}

	private bool PlayerInRange(bool asleep = true)
	{
		float num = ((!asleep) ? 60f : 45f);
		float num2 = ((!asleep) ? 3f : 2.5f);
		float angleToPoint = GetAngleToPoint(playerLook.transform.position, headObj);
		if (Mathf.Abs(angleToPoint) <= num)
		{
			Vector3 position = playerLook.position;
			Vector3 direction = position - base.transform.position;
			if (direction.sqrMagnitude > num2 * num2)
			{
				return false;
			}
			float magnitude = direction.magnitude;
			direction /= magnitude;
			if (Physics.Raycast(base.transform.position, direction, out var hitInfo, magnitude))
			{
				return hitInfo.collider.gameObject == player.gameObject;
			}
		}
		return false;
	}

	private float GetAngleToPoint(Vector3 targetPoint, Transform refTransform)
	{
		Vector3 vec = targetPoint - refTransform.position;
		vec = vec.GroundNormalize();
		return Vector3.Angle(refTransform.right, vec);
	}

	private float UpdateEyes()
	{
		float angleToPoint = GetAngleToPoint(playerLook.transform.position, headObj);
		if (Mathf.Abs(angleToPoint) <= 65f)
		{
			eyes.SetLookAtPlayer();
		}
		else
		{
			eyes.SetLookAhead();
		}
		return angleToPoint;
	}

	private int GetPrice()
	{
		int oracleNumAsked = GameController.Get().gameState.oracleNumAsked;
		return Mathf.Min(4, Mathf.Max(2, Mathf.CeilToInt((float)oracleNumAsked / 1.25f)));
	}

	private void InitUI()
	{
		UIDreadHallsMenu menu = dialogMenus.GetMenu("SelectQuestion");
		menu.GetButton("button_question_0").SetAction(UIQuestions_Select0);
		menu.GetButton("button_question_1").SetAction(UIQuestions_Select1);
		menu.GetButton("button_question_2").SetAction(UIQuestions_Select2);
	}

	private void ShowUIPromptPay(int coins, float timer = 0f)
	{
		int numItems = inventory.GetNumItems(Collectable.EItemType.Coin);
		bool flag = numItems >= coins;
		string newText = ((!flag) ? string.Format(Translate.Get("ORACLE_PROMPT_PAY_NOCOINS"), coins) : string.Format(Translate.Get("ORACLE_PROMPT_PAY"), numItems));
		UIDreadHallsMenu menu = dialogMenus.GetMenu("PromptPay");
		menu.SetText("main_text", newText);
		UIButton3D button = menu.GetButton("button_pay");
		button.text = string.Format(Translate.Get("ORACLE_PROMPT_PAY_BTN"), coins);
		button.SetAction(Prompt_OnPay);
		button.gameObject.SetActive(flag);
		UIMenuAnimator component = menu.GetComponent<UIMenuAnimator>();
		component.ApplyAlpha(0f);
		component.animateSize = true;
		StartCoroutine(ShowUIPromptPay_co(timer));
		Player.GetCrosshair().gameObject.SetActive(value: true);
	}

	private IEnumerator ShowUIPromptPay_co(float waitTime)
	{
		yield return new WaitForSeconds(waitTime);
		dialogMenus.ShowMenu("PromptPay");
	}

	private void ShowUIQuestions()
	{
		UIDreadHallsMenu menu = dialogMenus.GetMenu("SelectQuestion");
		for (int i = 0; i < 3; i++)
		{
			UIButton3D button = menu.GetButton("button_question_" + i);
			if (questionIDs.Count > i)
			{
				button.text = OracleQuestions.GetText(questionIDs[i]);
				button.gameObject.SetActive(value: true);
			}
			else
			{
				button.gameObject.SetActive(value: false);
			}
		}
		dialogMenus.ShowMenu("SelectQuestion");
		dialogMenus.GetMenu("SelectQuestion").SetText("main_text", Translate.Get("ORACLE_SELECT_QUESTION"));
		Player.GetCrosshair().gameObject.SetActive(value: true);
	}

	private void UIQuestions_Select0()
	{
		WaitQuestion_OnSelect(0);
	}

	private void UIQuestions_Select1()
	{
		WaitQuestion_OnSelect(1);
	}

	private void UIQuestions_Select2()
	{
		WaitQuestion_OnSelect(2);
	}

	private void ShowUISubtitle(string questionID)
	{
		if (Config.General().oracleSubtitles)
		{
			UIDreadHallsMenu menu = dialogMenus.GetMenu("SubtitleFrame");
			string replyText = OracleQuestions.GetReplyText(questionID);
			dialogMenus.ShowMenu("SubtitleFrame");
			menu.SetTextWrap("main_text", replyText, 0.3f);
		}
		else
		{
			dialogMenus.CloseMenu();
		}
		Player.GetCrosshair().gameObject.SetActive(value: false);
	}
}
public class OracleQuestions : ScriptableObject
{
	[Serializable]
	public class Question
	{
		public string id;

		public List<string> conditionTags;

		public bool CheckValid(List<string> checkTags)
		{
			for (int i = 0; i < checkTags.Count; i++)
			{
				if (checkTags[i] == id)
				{
					return false;
				}
			}
			for (int j = 0; j < conditionTags.Count; j++)
			{
				bool flag = false;
				if (conditionTags[j] == "EMPTY" && checkTags.Count == 0)
				{
					flag = true;
				}
				for (int k = 0; k < checkTags.Count; k++)
				{
					if (flag)
					{
						break;
					}
					if (checkTags[k] == conditionTags[j])
					{
						flag = true;
					}
				}
				if (!flag)
				{
					return false;
				}
			}
			if (id == "PLACE_HUB")
			{
				return GameController.Get().levelOptions.IsMetaMap() && GameController.Get().gameState.metaMap == 1;
			}
			return true;
		}
	}

	public Question[] questions;

	public void AskQuestion(string idQuestion, List<string> conditionTags)
	{
		for (int i = 0; i < questions.Length; i++)
		{
			if (questions[i].id == idQuestion)
			{
				if (conditionTags.Count == 0)
				{
					conditionTags.Add("ASKED_1");
				}
				conditionTags.Add(idQuestion);
				break;
			}
		}
	}

	public int SelectQuestions(List<string> outQuestions, List<string> conditionTags, int numQuestions = 3)
	{
		outQuestions.Clear();
		for (int i = 0; i < questions.Length; i++)
		{
			if (questions[i].CheckValid(conditionTags))
			{
				outQuestions.Add(questions[i].id);
			}
		}
		while (outQuestions.Count > numQuestions)
		{
			int index = UnityEngine.Random.Range(0, outQuestions.Count);
			outQuestions[index] = outQuestions[outQuestions.Count - 1];
			outQuestions.RemoveAt(outQuestions.Count - 1);
		}
		return outQuestions.Count;
	}

	public static string GetText(string idQuestion)
	{
		return Translate.Get("ORACLE_QUESTION_" + idQuestion);
	}

	public static string GetReplyText(string idQuestion)
	{
		return Translate.Get("ORACLE_QUESTION_REPLY_" + idQuestion);
	}

	public static AudioClip GetSoundClip(string idClip)
	{
		string language = Translate.GetLanguage();
		AudioClip audioClip = LoadClip(idClip, language);
		if (audioClip == null)
		{
			audioClip = LoadClip(idClip);
		}
		return audioClip;
	}

	private static AudioClip LoadClip(string idClip, string language = "english")
	{
		return Resources.Load<AudioClip>("Oracle/" + language + "/" + idClip);
	}
}
public class PageFlip : MonoBehaviour
{
	[Range(0f, 1f)]
	public float scaleX = 1f;

	[Range(0f, 1f)]
	public float scaleY = 1f;

	public float initRotation = 90f;

	public float endRotation = 270f;

	[Range(0f, 1f)]
	public float rotRatio;

	[Range(0f, 90f)]
	public float theta;

	public float apex;

	public Renderer[] pageRenderers;

	private float initTheta;

	private float initApex;

	private void Start()
	{
		Renderer[] array = pageRenderers;
		foreach (Renderer renderer in array)
		{
			renderer.material.SetFloat("_ScaleX", scaleX);
			renderer.material.SetFloat("_ScaleY", scaleY);
		}
		initTheta = theta;
		initApex = apex;
	}

	private void Update()
	{
		float f = theta * ((float)Math.PI / 180f);
		float value = Mathf.Sin(f);
		float value2 = Mathf.Cos(f);
		Renderer[] array = pageRenderers;
		foreach (Renderer renderer in array)
		{
			renderer.material.SetFloat("_SinTheta", value);
			renderer.material.SetFloat("_CosTheta", value2);
			renderer.material.SetFloat("_Apex", apex);
		}
		Quaternion a = Quaternion.Euler(0f, -180f, initRotation);
		Quaternion b = Quaternion.Euler(0f, -180f, endRotation);
		base.transform.localRotation = Quaternion.Slerp(a, b, rotRatio);
	}

	public float Flip(bool invert = false)
	{
		string animation = ((!invert) ? "Book_PageFlip" : "Book_PageFlip_Inv");
		GetComponent<Animation>().Play(animation);
		Renderer[] array = pageRenderers;
		foreach (Renderer renderer in array)
		{
			renderer.material.SetFloat("_FlipDir", (!invert) ? 1f : (-1f));
		}
		return GetComponent<Animation>()[animation].length;
	}

	public void Reset()
	{
		GetComponent<Animation>().Stop();
		rotRatio = 0f;
		theta = initTheta;
		apex = initApex;
	}

	public void SetPageFront(Texture texture)
	{
		if (pageRenderers != null && pageRenderers.Length >= 1)
		{
			pageRenderers[0].material.SetTexture("_ContentTex", texture);
		}
	}

	public void SetPageBack(Texture texture)
	{
		if (pageRenderers != null && pageRenderers.Length >= 2)
		{
			pageRenderers[1].material.SetTexture("_ContentTex", texture);
		}
	}

	public Texture GetPageFront()
	{
		if (pageRenderers != null && pageRenderers.Length >= 1)
		{
			return pageRenderers[0].material.GetTexture("_ContentTex");
		}
		return null;
	}

	public Texture GetPageBack()
	{
		if (pageRenderers != null && pageRenderers.Length >= 2)
		{
			return pageRenderers[1].material.GetTexture("_ContentTex");
		}
		return null;
	}
}
public class Pillar : MonoBehaviour
{
	private ParticleSystem[] particles;

	public LineRenderContrl lightningFX;

	public AudioSource soundLoop;

	private void Start()
	{
		particles = GetComponentsInChildren<ParticleSystem>();
		SetParticlesEmission(enabled: false);
	}

	public void ActivateEffects()
	{
		SetParticlesEmission(enabled: true);
		soundLoop.enabled = true;
	}

	public void ActivateLightning(Transform target)
	{
		lightningFX.Target = target;
		lightningFX.gameObject.SetActive(value: true);
		soundLoop.enabled = false;
	}

	private void SetParticlesEmission(bool enabled)
	{
		for (int i = 0; i < particles.Length; i++)
		{
			particles[i].enableEmission = enabled;
		}
	}
}
public class PlayerNotes : MonoBehaviour
{
	public AudioClip PaperSound;

	public List<string> noteNames;

	private Dictionary<string, List<string>> notesDict;

	private bool showingNote;

	private bool preShowingNote;

	private TextLabel textLabel;

	public UICamChaser camChaser;

	public float minShowingTime = 0.5f;

	private float minShowTimer;

	private bool hidingForInventory;

	public bool IsShowingNote => showingNote || preShowingNote;

	private void Start()
	{
		textLabel = GetComponent<TextLabel>();
		textLabel.HideText();
		camChaser.enabled = false;
		notesDict = new Dictionary<string, List<string>>();
		foreach (string noteName in noteNames)
		{
			string[] array = noteName.Split('_');
			string key = string.Empty;
			if (array.Length >= 2)
			{
				key = array[0];
			}
			if (!notesDict.ContainsKey(key))
			{
				notesDict[key] = new List<string>();
			}
			if (!GameController.Get().gameState.playerNotes.Contains(noteName))
			{
				notesDict[key].Add(noteName);
			}
		}
	}

	private void Update()
	{
		if (!showingNote)
		{
			return;
		}
		if (minShowTimer > 0f)
		{
			minShowTimer -= Time.deltaTime;
		}
		if (minShowTimer <= 0f && (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.Cancel)) && !hidingForInventory)
		{
			AudioSource.PlayClipAtPoint(PaperSound, base.transform.position);
			textLabel.FadeOut();
			showingNote = false;
			camChaser.enabled = false;
			Player.GetController().UnblockMovement(unBlockRotation: false);
		}
		Player.GetMinimapPos().Hide = true;
		if (InputExt.GetButton(InputExt.Button.Inventory))
		{
			if (!hidingForInventory)
			{
				hidingForInventory = true;
				textLabel.FadeOut(8f);
			}
		}
		else if (hidingForInventory)
		{
			hidingForInventory = false;
			textLabel.FadeIn(8f);
		}
	}

	public void ShowNote()
	{
		preShowingNote = false;
		if (showingNote)
		{
			Player.GetController().UnblockMovement(unBlockRotation: false);
		}
		string text = GameController.Get().levelOptions.playerNotesGroup;
		if (!notesDict.ContainsKey(text) || notesDict[text].Count == 0)
		{
			text = string.Empty;
		}
		int index = UnityEngine.Random.Range(0, notesDict[text].Count);
		if (text.StartsWith("META"))
		{
			index = 0;
		}
		string text2 = Translate.Get("PLAYERNOTE_" + notesDict[text][index]);
		if (text != string.Empty)
		{
			GameController.Get().gameState.playerNotes.Add(notesDict[text][index]);
			notesDict[text].RemoveAt(index);
		}
		textLabel.Text = text2;
		textLabel.FadeIn();
		AudioSource.PlayClipAtPoint(PaperSound, base.transform.position);
		showingNote = true;
		minShowTimer = minShowingTime;
		camChaser.enabled = true;
		camChaser.Recenter();
		Player.GetController().BlockMovement(blockRotation: false);
		hidingForInventory = false;
	}

	public void SetPreShowNote()
	{
		preShowingNote = true;
	}
}
[RequireComponent(typeof(BoxCollider))]
[RequireComponent(typeof(MeshFilter))]
[RequireComponent(typeof(MeshRenderer))]
public class ProceduralCube : MonoBehaviour
{
	public float fSizeX = 1f;

	public float fSizeY = 1f;

	public float fSizeZ = 1f;

	public float fTileU = 1f;

	public float fTileV = 1f;

	public void Rebuild()
	{
		GetComponent<BoxCollider>().size = new Vector3(fSizeX, fSizeY, fSizeZ);
		GetComponent<BoxCollider>().center = new Vector3(fSizeX / 2f, fSizeY / 2f, fSizeZ / 2f);
	}
}
public class ProgressInteraction : MonoBehaviour
{
	public bool needsProgress = true;

	public bool canInteractAfter;

	public float duration;

	public float UIDistance = 0.146f;

	public Vector3 UIPosOffset = Vector3.zero;

	public float UIScale = 1f;

	public float distance = 1.5f;

	private float maxPlayerDistance;

	public LayerMask layerMask;

	public bool reorientToPlayer = true;

	public GameObject iconPrefab;

	public GameObject progressPrefab;

	public bool highlight = true;

	protected HighlightEffect highlightFX;

	public Color highlightColor1 = new Color(1f, 0.92f, 0.016f, 1f);

	public Color highlightColor2 = new Color(1f, 0.92f, 0.116f, 0.5f);

	public float highlightFreq = 0.55f;

	private bool interacting;

	private float progress;

	protected Transform playerLook;

	private MinimapPosition minimapPos;

	private GameObject interactionIcon;

	private GameObject progressIcon;

	private AudioSource interactionSound;

	private bool visible = true;

	public Collider interactionCollider;

	private Vector3 colliderCenter;

	private bool selected;

	private Color curHighlightColor;

	private DisableOnPause disableOnPause;

	protected void Awake()
	{
		if (highlight)
		{
			highlightFX = base.gameObject.GetComponent<HighlightEffect>();
			if (!highlightFX)
			{
				highlightFX = base.gameObject.AddComponent<HighlightEffect>();
			}
		}
		curHighlightColor = new Color(highlightColor1.r, highlightColor1.g, highlightColor1.b, 0f);
		layerMask = LayerMaskExtensions.Create("Default", "TransparentFX", "LightCaster", "Collectable", "Prop", "StaticGeometry");
		minimapPos = GameObject.FindWithTag(Tags.Minimap).GetComponent<MinimapPosition>();
		interactionIcon = null;
		progressIcon = null;
		interacting = false;
		progress = 0f;
		interactionSound = GetComponent<AudioSource>();
		disableOnPause = GetComponent<DisableOnPause>();
		if (disableOnPause == null)
		{
			disableOnPause = base.gameObject.AddComponent<DisableOnPause>();
		}
	}

	protected void Start()
	{
		if (interactionCollider == null)
		{
			interactionCollider = GetComponentInChildren<Collider>();
		}
		if (interactionCollider != null)
		{
			colliderCenter = interactionCollider.bounds.center;
		}
		else
		{
			colliderCenter = base.transform.position;
		}
	}

	protected void Update()
	{
		if (!visible && !interacting)
		{
			return;
		}
		playerLook = Player.GetLook(interaction: true);
		Vector3 vector = playerLook.position - colliderCenter;
		bool flag = false;
		if ((needsProgress || canInteractAfter) && vector.sqrMagnitude <= distance * distance && Physics.Raycast(playerLook.position, playerLook.forward, out var hitInfo, distance, layerMask) && (hitInfo.collider == interactionCollider || hitInfo.collider.transform.parent == base.transform))
		{
			flag = true;
			minimapPos.Hide = true;
		}
		if ((bool)highlightFX)
		{
			if (flag)
			{
				Color b = Color.Lerp(highlightColor1, highlightColor2, 0.5f * Mathf.Sin(Time.realtimeSinceStartup * highlightFreq * (float)Math.PI * 2f) + 0.5f);
				Color color = Color.Lerp(curHighlightColor, b, Time.deltaTime * 8f);
				curHighlightColor = color;
				highlightFX.FadeIn();
			}
			else
			{
				highlightFX.FadeOut();
			}
		}
		if (flag && needsProgress && !interactionIcon)
		{
			Vector3 vector2 = colliderCenter + UIPosOffset;
			Vector3 vector3 = Player.GetGroundPos() + Vector3.up * 1.8f;
			Vector3 vector4 = vector3 - vector2;
			vector4.Normalize();
			float num = Vector3.Dot(base.transform.forward, vector4);
			Vector3 position = vector2 + vector4 * UIDistance;
			Quaternion quaternion = Quaternion.LookRotation(vector4);
			interactionIcon = UnityEngine.Object.Instantiate(iconPrefab, Vector3.zero, Quaternion.identity);
			interactionIcon.transform.parent = base.transform;
			interactionIcon.transform.position = position;
			interactionIcon.transform.rotation = quaternion;
			progressIcon = UnityEngine.Object.Instantiate(progressPrefab, Vector3.zero, Quaternion.identity);
			progressIcon.transform.parent = base.transform;
			progressIcon.transform.position = position;
			progressIcon.transform.rotation = quaternion * Quaternion.Euler(0f, -90f, 270f);
			progressIcon.GetComponent<Renderer>().material.SetFloat("_Cutoff", 1f);
			interactionIcon.transform.localScale = Vector3.zero;
			progressIcon.transform.localScale = Vector3.zero;
			maxPlayerDistance = Mathf.Max(distance, (Player.GetGroundPos() - base.transform.position.ToGround()).magnitude);
			disableOnPause.targetObjs.Add(interactionIcon);
			disableOnPause.targetObjs.Add(progressIcon);
		}
		if (!interacting && flag && InputExt.GetButtonDown(InputExt.Button.Action))
		{
			if (needsProgress)
			{
				interacting = true;
				progress = 0f;
				if ((bool)interactionSound)
				{
					interactionSound.Play(0uL);
				}
				OnStartProgress();
			}
			else if (canInteractAfter)
			{
				OnSimpleInteraction();
			}
		}
		if (interacting)
		{
			if (InputExt.GetButton(InputExt.Button.Action))
			{
				progress += Time.deltaTime / duration;
				progress = Mathf.Clamp(progress, 0f, 1f);
				if (progress >= 1f)
				{
					interacting = false;
					needsProgress = false;
					if ((bool)interactionSound)
					{
						interactionSound.Stop();
					}
					OnFinishProgress();
				}
				OnProgress(progress);
			}
			else
			{
				if ((bool)interactionSound)
				{
					interactionSound.Stop();
				}
				interacting = false;
				OnCancelProgress();
			}
			ShowProgress(progress);
		}
		if (!interacting && needsProgress && progress > 0f)
		{
			progress -= Time.deltaTime / 0.3f;
			progress = Mathf.Clamp(progress, 0f, 1f);
			ShowProgress(progress);
		}
		bool flag2 = (flag && needsProgress) || interacting;
		if (interacting)
		{
			float sqrMagnitude = (Player.GetGroundPos() - base.transform.position.ToGround()).sqrMagnitude;
			if (sqrMagnitude > maxPlayerDistance * maxPlayerDistance)
			{
				flag2 = false;
				if ((bool)interactionSound)
				{
					interactionSound.Stop();
				}
				interacting = false;
				OnCancelProgress();
			}
		}
		if (flag2)
		{
			interactionIcon.transform.localScale = Vector3.Slerp(interactionIcon.transform.localScale, UIScale * Vector3.one, Time.deltaTime * 10f);
			progressIcon.transform.localScale = Vector3.Slerp(progressIcon.transform.localScale, new Vector3(0.06f, 0.06f, 0.06f) * UIScale, Time.deltaTime * 10f);
			if (reorientToPlayer)
			{
				RepositionIcons(interactionIcon.transform, progressIcon.transform);
			}
		}
		else if ((bool)interactionIcon)
		{
			interactionIcon.transform.localScale = Vector3.Lerp(interactionIcon.transform.localScale, Vector3.zero, Time.deltaTime * 7.5f);
			progressIcon.transform.localScale = Vector3.Lerp(progressIcon.transform.localScale, Vector3.zero, Time.deltaTime * 7.5f);
			if (interactionIcon.transform.localScale.x <= 0.05f)
			{
				UnityEngine.Object.Destroy(interactionIcon);
				UnityEngine.Object.Destroy(progressIcon);
				interactionIcon = null;
				progressIcon = null;
				disableOnPause.targetObjs.Clear();
			}
		}
		if (!flag && selected && (bool)highlightFX)
		{
			highlightFX.FadeOut();
		}
		selected = flag;
	}

	protected virtual void OnSimpleInteraction()
	{
	}

	protected virtual void OnStartProgress()
	{
	}

	protected virtual void OnProgress(float progress)
	{
	}

	protected virtual void OnCancelProgress()
	{
	}

	protected virtual void OnFinishProgress()
	{
	}

	private void ShowProgress(float progress)
	{
		if ((bool)progressIcon)
		{
			progressIcon.GetComponent<Renderer>().material.SetFloat("_Cutoff", 1f - progress * 0.58f);
		}
	}

	private void RepositionIcons(Transform interactionIcon, Transform progressIcon)
	{
		Vector3 vector = colliderCenter + UIPosOffset;
		Vector3 vector2 = Player.GetGroundPos() + Vector3.up * 1.8f;
		Vector3 vector3 = vector2 - vector;
		vector3.Normalize();
		float num = Vector3.Dot(base.transform.forward, vector3);
		float magnitude = (Player.CenterEye - vector).magnitude;
		float num2 = Mathf.Min(UIDistance, magnitude - 0.2f);
		Vector3 position = vector + vector3 * num2;
		Quaternion quaternion = Quaternion.LookRotation(vector3);
		interactionIcon.position = position;
		interactionIcon.rotation = quaternion;
		progressIcon.transform.position = position;
		progressIcon.transform.rotation = quaternion * Quaternion.Euler(0f, -90f, 270f);
	}

	public float GetProgress()
	{
		return progress;
	}

	public bool IsInteracting()
	{
		return interacting;
	}

	private void OnBecameVisible()
	{
		visible = true;
	}

	private void OnBecameInvisible()
	{
		visible = false;
		if ((bool)highlightFX)
		{
			highlightFX.FadeOut();
			curHighlightColor = new Color(highlightColor1.r, highlightColor1.g, highlightColor1.b, 0f);
		}
	}
}
public class PropInfo : MonoBehaviour
{
	[Serializable]
	public class WallDecoDelta
	{
		public string wallStyle;

		public Vector3 delta;

		public WallDecoDelta(string style, Vector3 d)
		{
			wallStyle = style;
			delta = d;
		}
	}

	[Serializable]
	public class PushOutCornerDelta
	{
		public string wallStyle;

		public float delta;

		public bool skipIfInCorner;

		public float latFactorIfInCorner = 1f;

		public PushOutCornerDelta(string style, float d = 0f)
		{
			wallStyle = style;
			delta = d;
			skipIfInCorner = false;
			latFactorIfInCorner = 1f;
		}
	}

	[Serializable]
	public class WallSkipConditions
	{
		public string wallStyle;

		public int maxWalls;

		public WallSkipConditions(string style, int max = 1)
		{
			wallStyle = style;
			maxWalls = max;
		}
	}

	public static bool stagingMode;

	public bool disabledProp;

	public int SizeX = 1;

	public int SizeY = 1;

	public int marginTop;

	public int marginBottom;

	public int marginLeft;

	public int marginRight;

	public bool keepFrontClear;

	public bool WallProp;

	public bool removeFloor;

	public bool removeCeiling;

	public bool hanging;

	public bool ignoreWallMargin;

	public bool ignoreOutCornerLatMargin = true;

	public bool applyLateralMargins;

	public float wallMarginFactor = 1f;

	public bool squeeze;

	public bool standAlone;

	public bool canWalkThrough;

	public bool canFloatOver;

	public bool castsLight;

	public bool isGargoyle;

	public bool makeRoomSafe;

	public bool canPlaceInSpawnRoom = true;

	public bool requireHighCeiling;

	public float minCeilingHeight;

	public bool disableInRandomMode;

	public bool addVerticalOffset;

	public bool notBehindDoor;

	public bool notInDeadend;

	public bool notInNarrowDeadend;

	public bool notInHubInCorner;

	public bool isRockColumnBottom;

	public bool isRockColumnTop;

	public int maxInRoom;

	public int maxInMap;

	public string requireStyleTag = string.Empty;

	public bool roomSmall = true;

	public bool roomMedium = true;

	public bool roomLarge = true;

	public bool roomHub = true;

	public List<WallDecoDelta> wallDecoDeltas;

	public List<PushOutCornerDelta> pushOutCornerDeltas;

	public List<WallSkipConditions> wallSkipConditions;

	private RoomTemplate.PropMarker propMarker;

	public RoomTemplate.PropMarker PropMarker
	{
		get
		{
			return propMarker;
		}
		set
		{
			propMarker = value;
		}
	}

	public bool CheckTag(string tag)
	{
		if (propMarker != null && propMarker.tags != null)
		{
			List<string> tags = propMarker.tags;
			for (int i = 0; i < tags.Count; i++)
			{
				if (tags[i] == tag)
				{
					return true;
				}
			}
		}
		return false;
	}

	public List<string> GetTags()
	{
		if (propMarker != null)
		{
			return propMarker.tags;
		}
		return null;
	}

	public WallDecoDelta GetWallDecoDelta(string styleName)
	{
		for (int i = 0; i < wallDecoDeltas.Count; i++)
		{
			if (wallDecoDeltas[i].wallStyle == styleName)
			{
				return wallDecoDeltas[i];
			}
		}
		return null;
	}

	public Vector3 GetWallDecoDeltaVector(string styleName)
	{
		for (int i = 0; i < wallDecoDeltas.Count; i++)
		{
			if (wallDecoDeltas[i].wallStyle == styleName)
			{
				return wallDecoDeltas[i].delta;
			}
		}
		return Vector3.zero;
	}

	public float GetPushOutCornerDelta(string styleName, out bool skipIfInCorner, out float latFactor)
	{
		for (int i = 0; i < pushOutCornerDeltas.Count; i++)
		{
			if (pushOutCornerDeltas[i].wallStyle == styleName)
			{
				skipIfInCorner = pushOutCornerDeltas[i].skipIfInCorner;
				latFactor = 1f - pushOutCornerDeltas[i].latFactorIfInCorner;
				return pushOutCornerDeltas[i].delta;
			}
		}
		skipIfInCorner = false;
		latFactor = 1f;
		return 0f;
	}

	public int GetWallSkipMax(string styleName)
	{
		for (int i = 0; i < wallSkipConditions.Count; i++)
		{
			if (wallSkipConditions[i].wallStyle == styleName)
			{
				return wallSkipConditions[i].maxWalls;
			}
		}
		return -1;
	}

	private void OnDrawGizmos()
	{
		if (!stagingMode)
		{
			return;
		}
		float num = 1.5f;
		Color color = new Color(0.3f, 0.3f, 0.7f);
		Color color2 = new Color(0.8f, 0.8f, 0.9f);
		for (int i = 0; i < SizeY; i++)
		{
			for (int j = 0; j < SizeX; j++)
			{
				Vector3 center = base.transform.position + new Vector3(num * (float)j, 0f, (0f - num) * (float)i);
				Gizmos.color = (((j + i) % 2 != 0) ? color2 : color);
				Gizmos.DrawCube(center, new Vector3(1.5f, 0f, 1.5f));
			}
		}
		Vector3 size = new Vector3(num * (float)SizeX, 3.5f, num * (float)SizeY);
		Vector3 vector = base.transform.position - new Vector3(num / 2f, 0f, (0f - num) / 2f);
		if (hanging)
		{
			vector.y -= 3.5f;
		}
		Gizmos.color = Color.blue;
		Gizmos.DrawWireCube(vector + new Vector3(size.x / 2f, size.y / 2f, (0f - size.z) / 2f), size);
		Color color3 = new Color(0.7f, 0.3f, 0.3f);
		Color color4 = new Color(0.9f, 0.6f, 0.6f);
		for (int k = -marginTop; k < SizeY + marginBottom; k++)
		{
			for (int l = -marginLeft; l < SizeX + marginRight; l++)
			{
				if (l < 0 || l >= SizeX || k < 0 || k >= SizeY)
				{
					Vector3 center2 = base.transform.position + new Vector3(num * (float)l, 0f, (0f - num) * (float)k);
					Gizmos.color = (((l + k) % 2 != 0) ? color4 : color3);
					Gizmos.DrawCube(center2, new Vector3(1.5f, 0f, 1.5f));
				}
			}
		}
		Gizmos.color = Color.blue;
		if (WallProp)
		{
			Vector3 vector2 = Vector3.right;
			Vector3 vector3 = Vector3.forward;
			if (SizeX > 1 && SizeY == 1)
			{
				vector2 = -Vector3.forward;
				vector3 = Vector3.right;
			}
			Vector3 vector4 = vector + new Vector3(size.x + 0.25f, 0f, (0f - size.z) / 2f);
			if (vector2 != Vector3.right)
			{
				vector4 = vector + new Vector3(size.x / 2f, 0f, 0f - size.z - 0.25f);
			}
			Vector3 from = vector4 + vector2 * 0.7f;
			Vector3 vector5 = vector4 + vector3 * 0.5f;
			Vector3 to = vector4 - vector3 * 0.5f;
			Gizmos.DrawLine(from, vector5);
			Gizmos.DrawLine(from, to);
			Gizmos.DrawLine(vector5, to);
		}
	}
}
public class RetractMetaPodium : MonoBehaviour
{
	private Inventory inventory;

	private bool isDown;

	public ParticleSystem particleSystem;

	public AudioClip moveSound;

	private void Start()
	{
		inventory = Player.Get().GetComponentInChildren<Inventory>();
		if ((bool)particleSystem)
		{
			particleSystem.enableEmission = false;
		}
		StartCoroutine(Wait_co());
		Serializer.Add(this, OnSerialize, OnDeserialize);
	}

	private void OnSerialize(BinaryWriter writer)
	{
		writer.Write(isDown);
	}

	private void OnDeserialize(BinaryReader reader)
	{
		isDown = reader.ReadBoolean();
	}

	private IEnumerator Wait_co()
	{
		do
		{
			yield return new WaitForSeconds(0.2f);
		}
		while (!inventory.HasMetaItems() && !isDown);
		GetComponent<Animation>().Play("RetractPodium");
		if ((bool)particleSystem && !isDown)
		{
			particleSystem.enableEmission = true;
			if ((bool)moveSound)
			{
				AudioSource.PlayClipAtPoint(moveSound, particleSystem.transform.position);
			}
		}
		isDown = true;
		float length = GetComponent<Animation>()["RetractPodium"].length;
		yield return new WaitForSeconds(length);
		if ((bool)particleSystem)
		{
			particleSystem.enableEmission = false;
		}
		BoxCollider hiderCollider = GetComponent<BoxCollider>();
		if (hiderCollider != null)
		{
			hiderCollider.enabled = false;
		}
	}
}
public class RoomAmbientLight : MonoBehaviour
{
	private Room room;

	private TorchLight tLight;

	private bool lightActive;

	private float initRange;

	public float inactiveRange = 0.5f;

	public float hubRange = 1f;

	public float hubIntensity = 1f;

	private void Start()
	{
		room = Map.Get().At(base.transform.position).Room;
		if (room == null)
		{
			UnityEngine.Object.Destroy(this);
			return;
		}
		GetComponent<Light>().shadows = LightShadows.None;
		Room obj = room;
		obj.OnEnter = (Room.RoomCallback)Delegate.Combine(obj.OnEnter, new Room.RoomCallback(OnPlayerEnterRoom));
		Room obj2 = room;
		obj2.OnExit = (Room.RoomCallback)Delegate.Combine(obj2.OnExit, new Room.RoomCallback(OnPlayerExitRoom));
		initRange = GetComponent<Light>().range;
		inactiveRange = Mathf.Min(initRange, inactiveRange);
		tLight = GetComponent<TorchLight>();
		if (room.Template.size == RoomTemplate.SizeType.Hub)
		{
			initRange *= hubRange;
			inactiveRange *= hubRange;
			if (tLight != null)
			{
				tLight.minIntensity *= hubIntensity;
				tLight.maxIntensity *= hubIntensity;
			}
		}
		if (tLight != null)
		{
			tLight.range = inactiveRange;
		}
		GetComponent<Light>().range = inactiveRange;
	}

	private void Update()
	{
		if (GetComponent<Light>().enabled)
		{
			GetComponent<Light>().range = Mathf.Lerp(GetComponent<Light>().range, (!lightActive) ? inactiveRange : initRange, Time.deltaTime * 0.25f);
			if (tLight != null)
			{
				tLight.range = GetComponent<Light>().range;
			}
		}
	}

	private void OnPlayerEnterRoom(Room room)
	{
		lightActive = true;
	}

	private void OnPlayerExitRoom(Room room)
	{
		lightActive = false;
	}
}
[RequireComponent(typeof(Light))]
public class TorchLight : MonoBehaviour
{
	public float minIntensity = 0.6f;

	public float maxIntensity = 1f;

	public float factor = 1f;

	public float factor2 = 1f;

	private float innerFactor = 1f;

	private float innerFactorTarget = 1f;

	private float innerFactorSpeed = 20f;

	private float minFactorFlicker = 1f;

	public float range;

	public float rangeFactor = 1f;

	public static float globalFactor = 1f;

	public Light[] slaveLights;

	private float[] slaveLightFactors;

	private float random;

	private float flickerOilTime;

	private void Start()
	{
		random = UnityEngine.Random.Range(0f, 65535f);
		innerFactor = 1f;
		range = GetComponent<Light>().range;
		if (slaveLights != null)
		{
			slaveLightFactors = new float[slaveLights.Length];
			for (int i = 0; i < slaveLightFactors.Length; i++)
			{
				slaveLightFactors[i] = 1f;
			}
		}
	}

	public void Update()
	{
		float t = Mathf.PerlinNoise(random, Time.time);
		innerFactor = Mathf.Lerp(innerFactor, innerFactorTarget, Time.deltaTime * innerFactorSpeed);
		GetComponent<Light>().intensity = Mathf.Lerp(minIntensity * factor * factor2 * innerFactor * globalFactor * minFactorFlicker, maxIntensity * factor * factor2 * innerFactor * globalFactor, t) * 2f;
		GetComponent<Light>().range = range * rangeFactor;
		if (slaveLights != null)
		{
			for (int i = 0; i < slaveLights.Length; i++)
			{
				slaveLights[i].intensity = Mathf.Lerp(minIntensity * factor * factor2 * innerFactor * globalFactor * minFactorFlicker * slaveLightFactors[i], maxIntensity * factor * factor2 * innerFactor * globalFactor * slaveLightFactors[i], t) * 2f;
			}
		}
		if (flickerOilTime > 0f)
		{
			flickerOilTime -= Time.deltaTime;
			minFactorFlicker = Mathf.Lerp(minFactorFlicker, 0.15f, Time.deltaTime * 5f);
		}
		else if (minFactorFlicker < 1f)
		{
			minFactorFlicker = Mathf.Clamp01(minFactorFlicker + Time.deltaTime * 0.2f);
		}
	}

	public void SetSlaveLightFactor(int idx, float f)
	{
		if (idx < slaveLightFactors.Length)
		{
			slaveLightFactors[idx] = f;
		}
	}

	public float GetSlaveLightFactor(int idx)
	{
		if (idx < slaveLightFactors.Length)
		{
			return slaveLightFactors[idx];
		}
		return 0f;
	}

	public void FlickerOut(bool turnOff = false, GameObject originRef = null)
	{
		StartCoroutine(FlickerOut_co(turnOff, originRef));
	}

	private IEnumerator FlickerOut_co(bool turnOff = false, GameObject originRef = null)
	{
		innerFactorTarget = 1f;
		innerFactorSpeed = 200f;
		float startTime = Time.time;
		float duration = 3f;
		if (originRef == null)
		{
			originRef = base.gameObject;
		}
		ParticleSystem[] particles = originRef.GetComponentsInChildren<ParticleSystem>();
		while (Time.time - startTime <= duration)
		{
			innerFactorTarget = Mathf.PerlinNoise(random / 2f, Time.time) - 0.25f;
			innerFactorTarget = Mathf.Clamp(innerFactorTarget, 0f, 1f);
			ParticleSystem[] array = particles;
			foreach (ParticleSystem particleSystem in array)
			{
				particleSystem.enableEmission = innerFactorTarget > 0f;
			}
			yield return new WaitForSeconds(0.025f);
		}
		if (!turnOff)
		{
			innerFactorTarget = 1f;
			innerFactorSpeed = 1f;
			ParticleSystem[] array2 = particles;
			foreach (ParticleSystem particleSystem2 in array2)
			{
				particleSystem2.enableEmission = true;
			}
		}
		else
		{
			originRef.SendMessage("OnLightTurnOff", this, SendMessageOptions.DontRequireReceiver);
			innerFactorTarget = 1f;
			innerFactorSpeed = 1f;
		}
	}

	public void FlickerOil(float time = 6f)
	{
		flickerOilTime = time;
	}

	public void StopFlickerOil(bool endFlicker = false)
	{
		flickerOilTime = 0f;
		if (endFlicker)
		{
			minFactorFlicker = 1f;
		}
	}
}
public class Unlockable : MonoBehaviour
{
	public enum Difficulty
	{
		Very_Easy,
		Easy,
		Medium,
		Hard,
		Very_Hard,
		Uninitialized
	}

	public bool Locked = true;

	public Difficulty difficultyLevel = Difficulty.Uninitialized;

	public float Strength = 1f;

	public bool PlaySilence;

	public float UIDistance = 0.146f;

	public float OpenDistance = 2f;

	private float maxPlayerDistance;

	public LayerMask layerMask;

	public bool CanToggle = true;

	public bool CanBash;

	public GameObject Door;

	public GameObject LockPrefab;

	public GameObject[] LockPrefabs;

	public GameObject ProgressPrefab;

	public GameObject WedgePregab;

	public AudioClip UnlockSound;

	private bool Picking;

	private float Progress;

	private float BaseProgress;

	private float BashProgress;

	private static Permutator BashChance;

	public bool OnlyForwardDirection;

	private Transform playerLook;

	private Transform playerView;

	private GameObject LockIcon;

	private GameObject ProgressIcon;

	private Vector3 vLocalPos;

	private float fCosForward;

	private AudioSource PickingSound;

	private HighlightEffect highlight;

	private Transform upperWedge;

	private Transform lowerWedge;

	[Range(0f, 0.5f)]
	public float upperWedgeDist = 0.22f;

	[Range(0f, 0.5f)]
	public float lowerWedgeDist = 0.148f;

	private const float wedgeDepth = 0.001f;

	[Range(0f, 360f)]
	public float upperWedgeAngle;

	[Range(0f, 360f)]
	public float lowerWedgeAngle;

	private float upperWedgeAngleTarget;

	private float lowerWedgeAngleTarget;

	private bool upperWedgeCanMove;

	private bool lowerWedgeCanMove = true;

	private bool canUseLockpick;

	private float lockpickTimer;

	private float wedgeMoveFactor = 1f;

	private float failTimer;

	public GameObject lockpickPrefab;

	public AudioClip lockpickSuccessSound;

	public AudioClip lockpickFailSound;

	private TextLabel tutoLabel;

	private bool firstLockpickTutorial;

	private bool hardLockpickTutorial;

	private bool hardLockpickTutorial2;

	private bool showTutoArrows;

	private DisableOnPause disableOnPause;

	public static Unlockable activeUnlockable;

	public static Unlockable waitingForProxyTutorial;

	public bool skipTutorialIfTouch;

	private float previousTouchRoll;

	public bool IsTutorial => firstLockpickTutorial || hardLockpickTutorial || hardLockpickTutorial2 || tutoLabel != null;

	private void Start()
	{
		playerLook = Player.GetLook(interaction: true);
		playerView = Player.GetLook();
		layerMask = LayerMaskExtensions.Create("Default", "TransparentFX", "LightCaster", "Collectable", "Prop", "StaticGeometry");
		LockIcon = null;
		ProgressIcon = null;
		Picking = false;
		Progress = 0f;
		BaseProgress = 0f;
		PickingSound = GetComponent<AudioSource>();
		BashProgress = 1000f;
		if (BashChance == null)
		{
			BashChance = new Permutator(1, 10, 3);
		}
		highlight = base.transform.parent.GetComponentInChildren<HighlightEffect>();
		if (difficultyLevel == Difficulty.Uninitialized)
		{
			InitLocked();
		}
		disableOnPause = GetComponent<DisableOnPause>();
		if (disableOnPause == null)
		{
			disableOnPause = base.gameObject.AddComponent<DisableOnPause>();
		}
		activeUnlockable = null;
		waitingForProxyTutorial = null;
	}

	public void InitLocked(Difficulty dif = Difficulty.Uninitialized)
	{
		Locked = true;
		if (dif == Difficulty.Uninitialized)
		{
			float value = UnityEngine.Random.value;
			if (value < 0.1f)
			{
				difficultyLevel = Difficulty.Very_Easy;
			}
			else if (value < 0.3f)
			{
				difficultyLevel = Difficulty.Easy;
			}
			else if (value < 0.85f)
			{
				difficultyLevel = Difficulty.Medium;
			}
			else if (value < 0.95f)
			{
				difficultyLevel = Difficulty.Hard;
			}
			else
			{
				difficultyLevel = Difficulty.Very_Hard;
			}
		}
		else
		{
			difficultyLevel = dif;
		}
		float min = 0.5f;
		float max = 1f;
		switch (difficultyLevel)
		{
		case Difficulty.Very_Easy:
			min = 0.5f;
			max = 0.75f;
			break;
		case Difficulty.Easy:
			min = 0.75f;
			max = 1.5f;
			break;
		case Difficulty.Medium:
			min = 1.5f;
			max = 2.5f;
			break;
		case Difficulty.Hard:
			min = 3f;
			max = 4f;
			break;
		case Difficulty.Very_Hard:
			min = 5f;
			max = 6f;
			break;
		}
		Strength = UnityEngine.Random.Range(min, max);
	}

	private void Update()
	{
		bool flag = false;
		playerLook = Player.GetLook(interaction: true);
		bool flag2 = false;
		Vector3 vector = playerLook.position - base.transform.position;
		Vector3 vector2 = playerView.position - base.transform.position;
		if ((bool)playerLook && vector.sqrMagnitude <= 25f)
		{
			float num = ((!InputExt.UsingHandControllers) ? 1f : GlobalParams.touchControllersDistanceFactor);
			if (Physics.Raycast(playerLook.position, playerLook.forward, out var hitInfo, OpenDistance * num, layerMask) && base.transform.IsChildOf(hitInfo.collider.transform))
			{
				flag2 = true;
			}
		}
		bool flag3 = false;
		if (OnlyForwardDirection && flag2)
		{
			Vector3 rhs = vector2.ToGround();
			Vector3 lhs = base.transform.forward.ToGround();
			rhs.Normalize();
			lhs.Normalize();
			if (Vector3.Dot(lhs, rhs) < 0f)
			{
				flag2 = false;
				flag3 = true;
			}
		}
		if (failTimer > 0f)
		{
			failTimer -= Time.deltaTime;
			flag2 = false;
		}
		if (highlight != null)
		{
			if (flag2 && (Locked || CanToggle))
			{
				highlight.FadeIn();
			}
			else
			{
				highlight.FadeOut();
			}
		}
		if (Locked && flag2)
		{
			activeUnlockable = this;
		}
		else if (activeUnlockable == this)
		{
			activeUnlockable = null;
		}
		if (showTutoArrows)
		{
			Player.GetController().ShowTutoArrows(flag2);
		}
		if (Locked && flag2 && !LockIcon)
		{
			Vector3 vector3 = new Vector3(0f, 0f, 1f);
			vector2.Normalize();
			fCosForward = Vector3.Dot(base.transform.forward, vector2);
			vLocalPos = vector3 * UIDistance * ((!(fCosForward < 0f)) ? 1f : (-1f));
			LockIcon = UnityEngine.Object.Instantiate(LockPrefabs[(int)difficultyLevel], Vector3.zero, Quaternion.identity);
			LockIcon.transform.parent = base.transform;
			LockIcon.transform.localPosition = vLocalPos;
			LockIcon.transform.localRotation = Quaternion.identity;
			ProgressIcon = UnityEngine.Object.Instantiate(ProgressPrefab, Vector3.zero, Quaternion.identity);
			ProgressIcon.transform.parent = base.transform;
			ProgressIcon.transform.localPosition = vLocalPos;
			ProgressIcon.transform.localRotation = Quaternion.Euler(0f, (!(fCosForward < 0f)) ? (-90f) : 90f, 270f);
			if (fCosForward < 0f)
			{
				LockIcon.transform.localRotation *= Quaternion.Euler(0f, 180f, 0f);
			}
			ProgressIcon.GetComponent<Renderer>().material.SetFloat("_Cutoff", 1f);
			LockIcon.transform.localScale = Vector3.zero;
			ProgressIcon.transform.localScale = Vector3.zero;
			LockIcon.transform.localPosition += Vector3.down * 0.05f;
			disableOnPause.targetObjs.Add(LockIcon);
			disableOnPause.targetObjs.Add(ProgressIcon);
			canUseLockpick = Player.GetInventory().GetNumItems(Collectable.EItemType.Lockpick) >= 1;
			lockpickTimer = 0f;
			if (GameController.Get().gameState.lockpicsUsedSuccesfully < 10)
			{
				upperWedgeCanMove = true;
				lowerWedgeCanMove = false;
			}
			else
			{
				upperWedgeCanMove = true;
				lowerWedgeCanMove = UnityEngine.Random.value <= 0.3f;
			}
			lowerWedgeCanMove = false;
			if (!tutoLabel && ((!InputExt.Using3DOFController && !InputExt.UsingHandControllers) || !skipTutorialIfTouch))
			{
				tutoLabel = Tutorial.ShowInPlace("TUTO_UNLOCK_1", vLocalPos + new Vector3(0f, 0.32f, 0f), Quaternion.Euler(0f, (!(fCosForward < 0f)) ? 180f : 0f, 0f), base.transform);
				if ((bool)tutoLabel && (InputExt.Using3DOFController || InputExt.UsingHandControllers))
				{
					Player.GetController().ShowTutoArrows();
					showTutoArrows = true;
				}
				if (!tutoLabel && canUseLockpick)
				{
					tutoLabel = Tutorial.ShowInPlace("TUTO_UNLOCK_2", vLocalPos + new Vector3(0f, 0.32f, 0f), Quaternion.Euler(0f, (!(fCosForward < 0f)) ? 180f : 0f, 0f), base.transform);
					if ((bool)tutoLabel)
					{
						lowerWedgeCanMove = (upperWedgeCanMove = false);
						firstLockpickTutorial = true;
						wedgeMoveFactor = 0f;
						if (InputExt.UsingHandControllers)
						{
							waitingForProxyTutorial = this;
						}
					}
					else if (!InputExt.Using3DOFController && !InputExt.UsingHandControllers)
					{
						tutoLabel = Tutorial.ShowInPlace("TUTO_UNLOCK_3", vLocalPos + new Vector3(0f, 0.32f, 0f), Quaternion.Euler(0f, (!(fCosForward < 0f)) ? 180f : 0f, 0f), base.transform);
						if ((bool)tutoLabel)
						{
							upperWedgeCanMove = true;
							lowerWedgeCanMove = false;
							wedgeMoveFactor = 0.65f;
							hardLockpickTutorial = true;
						}
					}
				}
			}
			if (InputExt.Using3DOFController || InputExt.UsingHandControllers)
			{
				canUseLockpick = false;
				upperWedgeCanMove = false;
				lowerWedgeCanMove = false;
			}
			upperWedge = UnityEngine.Object.Instantiate(WedgePregab).transform;
			lowerWedge = UnityEngine.Object.Instantiate(WedgePregab).transform;
			lowerWedgeAngle = UnityEngine.Random.Range(5f, 175f);
			upperWedgeAngle = UnityEngine.Random.Range(5f, 175f);
			lowerWedgeAngleTarget = UnityEngine.Random.Range(0f, 180f);
			upperWedgeAngleTarget = UnityEngine.Random.Range(0f, 180f);
			if (!upperWedgeCanMove)
			{
				upperWedgeAngle = (upperWedgeAngleTarget = 90f);
			}
			if (!lowerWedgeCanMove)
			{
				lowerWedgeAngle = (lowerWedgeAngleTarget = 90f);
			}
			lowerWedge.transform.parent = base.transform;
			lowerWedge.transform.localPosition = vLocalPos + new Vector3(0f, lowerWedgeDist, 0.001f * ((!(fCosForward < 0f)) ? 1f : (-1f)));
			lowerWedge.transform.localRotation = Quaternion.Euler(0f, (!(fCosForward < 0f)) ? 180f : 0f, (lowerWedgeAngle - 90f) * ((!(fCosForward > 0f)) ? 1f : (-1f)));
			lowerWedge.GetComponent<Renderer>().material.color = lowerWedge.GetComponent<Renderer>().material.color.WithAlpha(0f);
			upperWedge.transform.parent = base.transform;
			upperWedge.transform.localPosition = vLocalPos + new Vector3(0f, upperWedgeDist, 0.001f * ((!(fCosForward < 0f)) ? 1f : (-1f)));
			upperWedge.transform.localRotation = Quaternion.Euler(0f, (!(fCosForward < 0f)) ? 180f : 0f, (upperWedgeAngle - 90f + 180f) * ((!(fCosForward > 0f)) ? 1f : (-1f)));
			upperWedge.GetComponent<Renderer>().material.color = upperWedge.GetComponent<Renderer>().material.color.WithAlpha(0f);
			maxPlayerDistance = Mathf.Max(OpenDistance, (Player.GetGroundPos() - base.transform.position.ToGround()).magnitude);
			disableOnPause.targetObjs.Add(upperWedge.gameObject);
			disableOnPause.targetObjs.Add(lowerWedge.gameObject);
		}
		bool flag4 = InputExt.GetButton(InputExt.Button.Action);
		if (InputExt.UsingHandControllers && !Player.GetActionHand().IsVisible)
		{
			flag4 = false;
		}
		if (!Picking && flag2 && flag4 && !firstLockpickTutorial)
		{
			if (Locked)
			{
				Picking = true;
				Progress = 0f;
				PickingSound.Play(0uL);
				if (PlaySilence)
				{
					Jukebox.Get().PlaySilence();
				}
				Wiggler component = LockIcon.GetComponent<Wiggler>();
				if (component != null)
				{
					component.enabled = true;
				}
				if (InputExt.Using3DOFController || InputExt.UsingHandControllers)
				{
					StartTouchPickingProgress();
				}
				if (CanBash && BashProgress > 1f)
				{
					bool flag5 = BashChance.Next;
					if (GameController.Get().levelOptions.safeMap)
					{
						flag5 = false;
					}
					Room room = Map.Get().At(base.transform.position).Room;
					if (room != null && room.Safe)
					{
						flag5 = false;
					}
					if (!flag5)
					{
						CanBash = false;
					}
					else
					{
						if (Strength <= 0.9f)
						{
							Strength = UnityEngine.Random.Range(1f, 2.5f);
						}
						BashProgress = UnityEngine.Random.Range(0.3f, 0.7f);
					}
				}
			}
			else if (CanToggle && InputExt.GetButtonDown(InputExt.Button.Action) && !GameController.Get().wasJustPaused)
			{
				Door.SendMessage("Toggle", Player.Get().transform);
			}
		}
		if (Picking)
		{
			if (InputExt.GetButton(InputExt.Button.Action))
			{
				float num2 = BaseProgress + Progress;
				if (InputExt.Using3DOFController || InputExt.UsingHandControllers)
				{
					float touchDeltaProgress = GetTouchDeltaProgress();
					Progress += touchDeltaProgress;
					ApplyTouchHaptics();
				}
				else
				{
					Progress += Time.deltaTime / (2.5f * Strength);
				}
				Progress = Mathf.Clamp(Progress, 0f, 1f - BaseProgress);
				if ((double)(BaseProgress + Progress) + 0.001 >= 1.0)
				{
					PickingOpen();
				}
				if (CanBash && num2 <= BashProgress && BaseProgress + Progress > BashProgress)
				{
					Door.SendMessage("PlayBashWithMonster");
					CanBash = false;
				}
			}
			else
			{
				PickingSound.Stop();
				Picking = false;
			}
			ShowProgress(BaseProgress + Progress);
			if (!Picking)
			{
				Wiggler component2 = LockIcon.GetComponent<Wiggler>();
				if (component2 != null)
				{
					component2.enabled = false;
				}
			}
		}
		if (!Picking && Locked && BaseProgress + Progress > 0f)
		{
			Progress -= Time.deltaTime / 0.3f;
			Progress = Mathf.Clamp(Progress, 0f, 1f - BaseProgress);
			ShowProgress(BaseProgress + Progress);
		}
		flag = (flag2 && Locked) || Picking;
		if (Picking)
		{
			float sqrMagnitude = (Player.GetGroundPos() - base.transform.position.ToGround()).sqrMagnitude;
			if (sqrMagnitude > maxPlayerDistance * maxPlayerDistance || flag3)
			{
				flag = false;
				PickingSound.Stop();
				Picking = false;
			}
		}
		if (flag)
		{
			LockIcon.transform.localScale = Vector3.Slerp(LockIcon.transform.localScale, Vector3.one, Time.deltaTime * 10f);
			ProgressIcon.transform.localScale = Vector3.Slerp(ProgressIcon.transform.localScale, new Vector3(0.06f, 0.06f, 0.06f), Time.deltaTime * 10f);
			Player.GetMinimapPos().Hide = true;
			UpdateWedges();
			if (canUseLockpick && InputExt.GetButtonDown(InputExt.Button.Lockpick))
			{
				if (Player.GetInventory().ConsumeItem(Collectable.EItemType.Lockpick))
				{
					if (lockpickTimer > 0f)
					{
						BaseProgress += 1.5f / Strength;
						BaseProgress = Mathf.Clamp(BaseProgress, 0f, 0.95f);
						lockpickTimer = 0f;
						if ((bool)lockpickSuccessSound)
						{
							AudioSource.PlayClipAtPoint(lockpickSuccessSound, base.transform.position);
						}
						PlayLockpickFade();
						if (firstLockpickTutorial)
						{
							firstLockpickTutorial = false;
							if ((bool)tutoLabel)
							{
								tutoLabel.Text = Translate.GetForInput("TUTO_UNLOCK_2b");
							}
						}
						if (hardLockpickTutorial)
						{
							hardLockpickTutorial = false;
							hardLockpickTutorial2 = true;
							if ((bool)tutoLabel)
							{
								tutoLabel.Text = Translate.GetForInput("TUTO_UNLOCK_3b");
							}
						}
						GameController.Get().gameState.lockpicsUsedSuccesfully++;
					}
					else
					{
						BaseProgress = 0f;
						Progress = 0f;
						if ((bool)lockpickFailSound)
						{
							AudioSource.PlayClipAtPoint(lockpickFailSound, base.transform.position);
						}
						PlayLockpickFade(failed: true);
						failTimer = 0.25f;
						PickingSound.Stop();
						Picking = false;
						if (firstLockpickTutorial)
						{
							firstLockpickTutorial = false;
						}
						if (hardLockpickTutorial)
						{
							hardLockpickTutorial = false;
							hardLockpickTutorial2 = true;
							if ((bool)tutoLabel)
							{
								if (Player.GetInventory().GetNumItems(Collectable.EItemType.Lockpick) >= 1)
								{
									tutoLabel.Text = Translate.GetForInput("TUTO_UNLOCK_3b");
								}
								else
								{
									tutoLabel.Text = Translate.GetForInput("TUTO_UNLOCK_3c");
								}
							}
						}
						else if (hardLockpickTutorial2 && Player.GetInventory().GetNumItems(Collectable.EItemType.Lockpick) <= 0)
						{
							hardLockpickTutorial2 = false;
							if ((bool)tutoLabel)
							{
								tutoLabel.Text = Translate.GetForInput("TUTO_UNLOCK_3d");
							}
						}
					}
					Progress = Mathf.Clamp(Progress, 0f, 1f - BaseProgress);
					ShowProgress(BaseProgress + Progress);
				}
				canUseLockpick = Player.GetInventory().GetNumItems(Collectable.EItemType.Lockpick) >= 1;
			}
		}
		else if ((bool)LockIcon)
		{
			LockIcon.transform.localScale = Vector3.Lerp(LockIcon.transform.localScale, Vector3.zero, Time.deltaTime * 7.5f);
			ProgressIcon.transform.localScale = Vector3.Lerp(ProgressIcon.transform.localScale, Vector3.zero, Time.deltaTime * 7.5f);
			upperWedge.transform.localScale = Vector3.Lerp(upperWedge.transform.localScale, Vector3.zero, Time.deltaTime * 7.5f);
			lowerWedge.transform.localScale = Vector3.Lerp(lowerWedge.transform.localScale, Vector3.zero, Time.deltaTime * 7.5f);
			Color b = upperWedge.GetComponent<Renderer>().material.color.WithAlpha(0f);
			upperWedge.GetComponent<Renderer>().material.color = Color.Lerp(upperWedge.GetComponent<Renderer>().material.color, b, Time.deltaTime * 20f);
			lowerWedge.GetComponent<Renderer>().material.color = Color.Lerp(lowerWedge.GetComponent<Renderer>().material.color, b, Time.deltaTime * 20f);
			if (LockIcon.transform.localScale.x <= 0.05f)
			{
				UnityEngine.Object.Destroy(LockIcon);
				UnityEngine.Object.Destroy(ProgressIcon);
				UnityEngine.Object.Destroy(upperWedge.gameObject);
				UnityEngine.Object.Destroy(lowerWedge.gameObject);
				LockIcon = null;
				ProgressIcon = null;
				upperWedge = null;
				lowerWedge = null;
				disableOnPause.targetObjs.Clear();
			}
		}
		if (!Locked && (bool)tutoLabel)
		{
			tutoLabel.FadeOut(4f, disableOnFadeOut: true, destroyOnFadeOut: true);
			tutoLabel = null;
			if (InputExt.Using3DOFController || InputExt.UsingHandControllers)
			{
				Player.GetController().ShowTutoArrows(visible: false);
				showTutoArrows = false;
			}
		}
	}

	private void PickingOpen()
	{
		Picking = false;
		Locked = false;
		PickingSound.Stop();
		if (InputExt.UsingHandControllers)
		{
			Player.GetActionHand().PlayHapticUnlock();
		}
		AudioSource.PlayClipAtPoint(UnlockSound, base.transform.position);
		Door.SendMessage("Open", Player.Get().transform);
		if ((bool)tutoLabel)
		{
			tutoLabel.FadeOut(4f, disableOnFadeOut: true, destroyOnFadeOut: true);
			tutoLabel = null;
		}
		if (InputExt.Using3DOFController || InputExt.UsingHandControllers)
		{
			Player.GetController().ShowTutoArrows(visible: false);
			showTutoArrows = false;
		}
	}

	private void ShowProgress(float progress)
	{
		if ((bool)ProgressIcon)
		{
			ProgressIcon.GetComponent<Renderer>().material.SetFloat("_Cutoff", 1f - progress * 0.58f);
		}
	}

	private void UpdateWedges()
	{
		float num = 50f;
		if (difficultyLevel <= Difficulty.Easy)
		{
			num = 40f;
		}
		else if (difficultyLevel >= Difficulty.Hard)
		{
			num = 60f;
		}
		num *= wedgeMoveFactor;
		if (upperWedgeCanMove)
		{
			bool flag = upperWedgeAngle < upperWedgeAngleTarget;
			upperWedgeAngle += num * Time.deltaTime * ((!(upperWedgeAngleTarget > upperWedgeAngle)) ? (-1f) : 1f);
			upperWedgeAngle = Mathf.Clamp(upperWedgeAngle, 0f, 180f);
			if (upperWedgeAngle < upperWedgeAngleTarget != flag)
			{
				float num2 = ((difficultyLevel > Difficulty.Medium) ? 15f : 25f);
				int num3 = 5;
				while (num3 > 0 && Mathf.Abs(upperWedgeAngleTarget - upperWedgeAngle) <= num2)
				{
					upperWedgeAngleTarget = UnityEngine.Random.Range(0f, 180f);
					num3--;
				}
			}
		}
		if (lowerWedgeCanMove)
		{
			bool flag2 = lowerWedgeAngle < lowerWedgeAngleTarget;
			lowerWedgeAngle += num * Time.deltaTime * ((!(lowerWedgeAngleTarget > lowerWedgeAngle)) ? (-1f) : 1f);
			lowerWedgeAngle = Mathf.Clamp(lowerWedgeAngle, 0f, 180f);
			if (lowerWedgeAngle < lowerWedgeAngleTarget != flag2)
			{
				float num4 = ((difficultyLevel > Difficulty.Medium) ? 15f : 25f);
				int num5 = 5;
				while (num5 > 0 && Mathf.Abs(lowerWedgeAngleTarget - lowerWedgeAngle) <= num4)
				{
					lowerWedgeAngleTarget = UnityEngine.Random.Range(0f, 180f);
					num5--;
				}
			}
		}
		upperWedge.transform.localScale = Vector3.Slerp(upperWedge.transform.localScale, new Vector3(0.05f, 0.05f, 0.05f), Time.deltaTime * 10f);
		lowerWedge.transform.localScale = Vector3.Slerp(lowerWedge.transform.localScale, new Vector3(0.05f, 0.05f, 0.05f), Time.deltaTime * 10f);
		Color to = ((!canUseLockpick) ? upperWedge.GetComponent<Renderer>().material.color.WithAlpha(0f) : upperWedge.GetComponent<Renderer>().material.color.WithAlpha(1f));
		upperWedge.GetComponent<Renderer>().material.color = Interpolate.EaseInOut(upperWedge.GetComponent<Renderer>().material.color, to, Time.deltaTime * 20f);
		lowerWedge.GetComponent<Renderer>().material.color = Interpolate.EaseInOut(lowerWedge.GetComponent<Renderer>().material.color, to, Time.deltaTime * 20f);
		lowerWedge.transform.localPosition = vLocalPos + new Vector3(Mathf.Cos(lowerWedgeAngle * ((float)Math.PI / 180f)) * lowerWedgeDist, Mathf.Sin(lowerWedgeAngle * ((float)Math.PI / 180f)) * lowerWedgeDist, 0.001f * ((!(fCosForward < 0f)) ? 1f : (-1f)));
		upperWedge.transform.localPosition = vLocalPos + new Vector3(Mathf.Cos(upperWedgeAngle * ((float)Math.PI / 180f)) * upperWedgeDist, Mathf.Sin(upperWedgeAngle * ((float)Math.PI / 180f)) * upperWedgeDist, 0.001f * ((!(fCosForward < 0f)) ? 1f : (-1f)));
		lowerWedge.transform.localRotation = Quaternion.Euler(0f, (!(fCosForward < 0f)) ? 180f : 0f, (lowerWedgeAngle - 90f) * ((!(fCosForward > 0f)) ? 1f : (-1f)));
		upperWedge.transform.localRotation = Quaternion.Euler(0f, (!(fCosForward < 0f)) ? 180f : 0f, (upperWedgeAngle - 90f + 180f) * ((!(fCosForward > 0f)) ? 1f : (-1f)));
		float num6 = 3f;
		float num7 = Mathf.Abs(upperWedgeAngle - lowerWedgeAngle);
		bool flag3 = num7 <= num6;
		float @float = upperWedge.GetComponent<Renderer>().material.GetFloat("_LitProgress");
		@float = ((!flag3) ? Interpolate.Approach(@float, 0f, Time.deltaTime * 5f) : 1f);
		upperWedge.GetComponent<Renderer>().material.SetFloat("_LitProgress", @float);
		lowerWedge.GetComponent<Renderer>().material.SetFloat("_LitProgress", @float);
		if (flag3)
		{
			float num8 = 0.1f;
			num8 += 0.1f;
			if (difficultyLevel <= Difficulty.Very_Easy)
			{
				lockpickTimer = 0.2f + num8;
			}
			else if (difficultyLevel <= Difficulty.Medium)
			{
				lockpickTimer = 0.1f + num8;
			}
			else
			{
				lockpickTimer = 0.1f + num8;
			}
		}
		else if (lockpickTimer > 0f)
		{
			lockpickTimer -= Time.deltaTime;
		}
	}

	private void PlayLockpickFade(bool failed = false)
	{
		Vector3 vector = LockIcon.transform.position - LockIcon.transform.up * 0.25f;
		Vector3 position = Player.GetInventory().transform.position;
		GameObject gameObject = UnityEngine.Object.Instantiate(lockpickPrefab, vector, Quaternion.identity);
		gameObject.transform.parent = base.transform;
		gameObject.transform.localRotation = Quaternion.Euler(40f, 90f, -90f);
		gameObject.transform.parent = null;
		gameObject.transform.position = position;
		gameObject.GetComponent<Collider>().enabled = false;
		StartCoroutine(PlayLockpickFade_co(gameObject, position, vector));
	}

	private IEnumerator PlayLockpickFade_co(GameObject lockpick, Vector3 initPos, Vector3 targetPos)
	{
		float t = 0f;
		Renderer rend = lockpick.GetComponentInChildren<Renderer>();
		for (; t <= 1.5f; t += Time.deltaTime * 1.4f)
		{
			Vector3 newPos = Interpolate.EaseOutCubic(initPos, targetPos, Mathf.Clamp01(t));
			lockpick.transform.position = newPos;
			float alpha = Interpolate.EaseOutCubic(1f, 0f, Mathf.Clamp01(t - 0.2f));
			rend.material.color = new Color(1f, 1f, 1f, alpha);
			yield return new WaitForEndOfFrame();
		}
		UnityEngine.Object.Destroy(lockpick.gameObject);
	}

	private float GetTouchDeltaProgress()
	{
		Transform transform = ((!InputExt.UsingHandControllers) ? Player.Get3DOFController() : Player.GetActionHandTransform());
		float z = transform.localRotation.eulerAngles.z;
		float num = Mathf.Abs(Mathf.DeltaAngle(previousTouchRoll, z));
		previousTouchRoll = z;
		return num * (0.135f * Time.deltaTime / (Strength * 1.5f));
	}

	private void StartTouchPickingProgress()
	{
		Transform transform = ((!InputExt.UsingHandControllers) ? Player.Get3DOFController() : Player.GetActionHandTransform());
		previousTouchRoll = transform.localRotation.eulerAngles.z;
	}

	private void ApplyTouchHaptics()
	{
		float z = Player.GetActionHandTransform().localRotation.eulerAngles.z;
		float num = Mathf.PerlinNoise(z / 36f, 0f);
		if (num < 0.6f)
		{
			num = 0f;
		}
		float t = Mathf.PerlinNoise(z / 36f, 0.5f);
		float freq = Interpolate.Lerp(0.15f, 0.3f, t);
		Player.GetActionHand().PlayHaptic(freq, num * 0.5f, 1f / 60f);
	}

	public static bool UseLockpick()
	{
		if (activeUnlockable == null)
		{
			return false;
		}
		activeUnlockable.BaseProgress = Mathf.Max(activeUnlockable.BaseProgress, 0.95f);
		if ((bool)activeUnlockable.lockpickSuccessSound)
		{
			AudioSource.PlayClipAtPoint(activeUnlockable.lockpickSuccessSound, activeUnlockable.transform.position);
		}
		GameController.Get().gameState.lockpicsUsedSuccesfully++;
		if (activeUnlockable.firstLockpickTutorial)
		{
			activeUnlockable.firstLockpickTutorial = false;
			if ((bool)activeUnlockable.tutoLabel)
			{
				activeUnlockable.tutoLabel.Text = Translate.GetForInput("TUTO_UNLOCK_2b");
			}
		}
		return true;
	}

	private void OnUseHandLockpick(GameObject lockpick)
	{
		Unlockable unlockable = activeUnlockable;
		activeUnlockable = this;
		UseLockpick();
		activeUnlockable = unlockable;
	}

	public void ShowProxyLockpickTutorial()
	{
		if (firstLockpickTutorial && (bool)tutoLabel)
		{
			tutoLabel.Text = Translate.GetForInput("TUTO_UNLOCK_2_PROXY");
			waitingForProxyTutorial = null;
		}
	}
}
public class Wiggler : MonoBehaviour
{
	public Vector3 range;

	public float wiggleTime = 0.2f;

	private Vector3 initPos;

	private float timeToWiggle;

	private void Start()
	{
		initPos = base.transform.localPosition;
	}

	private void Update()
	{
		timeToWiggle += Time.deltaTime;
		if (timeToWiggle >= wiggleTime)
		{
			Vector3 vector = new Vector3(UnityEngine.Random.Range(0f - range.x, range.x), UnityEngine.Random.Range(0f - range.y, range.y), UnityEngine.Random.Range(0f - range.z, range.z));
			base.transform.localPosition = initPos + vector;
			timeToWiggle -= wiggleTime;
		}
	}

	private void OnDisable()
	{
		base.transform.localPosition = initPos;
	}
}
public class AdjustBodyToCamera : MonoBehaviour
{
	public OVRPlayerController playerController;

	public AntiBodyDelta[] antiDeltas;

	private void Start()
	{
		if (InputExt.UsingHandControllers)
		{
			playerController.adjustBodyToggle = true;
		}
	}

	private void Update()
	{
		if (!InputExt.UsingHandControllers || GameController.Get().Paused)
		{
			return;
		}
		Vector3 centerEye = Player.GetCenterEye();
		Vector3 vector = (centerEye - base.transform.position).ToGround();
		if (!(vector != Vector3.zero))
		{
			return;
		}
		playerController.adjustBodyMove = vector;
		playerController.adjustBodyToggle = true;
		for (int i = 0; i < antiDeltas.Length; i++)
		{
			if (antiDeltas[i].enabled)
			{
				antiDeltas[i].AddDelta(playerController.actualBodyMove);
			}
			else
			{
				antiDeltas[i].delta = Vector3.zero;
			}
		}
	}
}
public class AntiBodyDelta : MonoBehaviour
{
	public Vector3 delta = Vector3.zero;

	private Vector3 originalPos;

	private bool hasOriginalPos;

	private Vector3 lastPos;

	private Vector3 targetPos;

	private void Start()
	{
	}

	private void Update()
	{
		if (InputExt.UsingHandControllers)
		{
			base.transform.position -= delta;
			delta = Vector3.zero;
		}
	}

	private void OnEnable()
	{
		if (!hasOriginalPos)
		{
			originalPos = base.transform.localPosition;
			hasOriginalPos = true;
		}
		else if (InputExt.UsingHandControllers)
		{
			base.transform.localPosition = originalPos;
		}
		delta = Vector3.zero;
		lastPos = base.transform.position;
		targetPos = lastPos;
	}

	private void OnDisable()
	{
		delta = Vector3.zero;
	}

	public void AddDelta(Vector3 newDelta)
	{
		delta += newDelta;
	}
}
public class CameraClip : MonoBehaviour
{
	public Vector3 centerPos;

	public float colliderRadius = 0.05f;

	public Vector3 currentPos;

	public LayerMask collisionMask;

	private void Update()
	{
		Vector3 vector = base.transform.TransformPoint(centerPos);
		Vector3 vector2 = base.transform.TransformPoint(currentPos);
		Vector3 vector3 = Clip(vector, vector2, colliderRadius, collisionMask);
		Debug.DrawLine(vector, vector3, Color.green);
		Debug.DrawLine(vector3, vector2, Color.blue);
		DebugExt.DrawSphere(vector3, Color.red, colliderRadius);
	}

	public static Vector3 Clip(Vector3 origin, Vector3 curPos, float radius, LayerMask mask)
	{
		Vector3 vector = curPos - origin;
		float magnitude = vector.magnitude;
		vector /= magnitude;
		if (Physics.Raycast(origin, vector, out var hitInfo, (int)mask))
		{
			float magnitude2 = (hitInfo.point - origin).magnitude;
			float num = magnitude2 - radius;
			if (num < magnitude)
			{
				return origin + vector * num;
			}
		}
		return curPos;
	}
}
public class CameraClipTester : MonoBehaviour
{
	public Vector3 centerPos;

	public float colliderRadius = 0.05f;

	public Vector3 currentPos;

	public LayerMask collisionMask;

	private void Update()
	{
		Vector3 vector = base.transform.TransformPoint(centerPos);
		Vector3 vector2 = base.transform.TransformPoint(currentPos);
		Vector3 vector3 = Clip(vector, vector2, colliderRadius, collisionMask);
		Debug.DrawLine(vector, vector3, Color.green);
		Debug.DrawLine(vector3, vector2, Color.blue);
		DebugExt.DrawSphere(vector3, Color.red, colliderRadius);
	}

	public static Vector3 Clip(Vector3 origin, Vector3 curPos, float radius, LayerMask mask)
	{
		Vector3 vector = curPos - origin;
		float magnitude = vector.magnitude;
		vector /= magnitude;
		if (Physics.Raycast(origin, vector, out var hitInfo, (int)mask))
		{
			float magnitude2 = (hitInfo.point - origin).magnitude;
			float num = magnitude2 - radius;
			if (num < magnitude)
			{
				return origin + vector * num;
			}
		}
		return curPos;
	}
}
public class CenterIPD : MonoBehaviour
{
	private void Start()
	{
		Vector3 localPosition = base.transform.localPosition;
		float ipd = OVRManager.profile.ipd;
		localPosition.x -= ipd * 0.5f;
		base.transform.localPosition = localPosition;
	}
}
public class ControllerModel : MonoBehaviour
{
	public GameObject m_modelGearVrController;

	public GameObject m_modelOculusGoController;

	public OVRInput.Controller m_controller;

	private bool m_prevControllerConnected;

	private bool m_prevControllerConnectedCached;

	private void Start()
	{
	}

	private void Update()
	{
		bool flag = InputExt.Using3DOFController && ((InputExt.RightHanded && m_controller == OVRInput.Controller.RTrackedRemote) || (!InputExt.RightHanded && m_controller == OVRInput.Controller.LTrackedRemote));
		if (flag != m_prevControllerConnected || !m_prevControllerConnectedCached)
		{
			m_modelOculusGoController.SetActive(flag && InputExt.IsOculusGo);
			m_modelGearVrController.SetActive(flag && !InputExt.IsOculusGo);
			m_prevControllerConnected = flag;
			m_prevControllerConnectedCached = true;
		}
		if (flag)
		{
		}
	}
}
public class EyeClip : MonoBehaviour
{
	public Transform originRef;

	public LayerMask collisionMask;

	public float clippingFactor;

	public LayerMask closeClipMask;

	public float closeClipDistance = 0.15f;

	private LayerMask hiderMask;

	private LayerMask hiderMaskClose;

	private static RaycastHit[] hitResults;

	private void Start()
	{
		hiderMask = collisionMask.Inverse();
		hiderMaskClose = closeClipMask.Inverse();
		hitResults = new RaycastHit[32];
	}

	private void Update()
	{
		Vector3 localPosition = GetComponent<Camera>().transform.localPosition;
		Vector3 position = base.transform.position;
		Vector3 position2 = originRef.position;
		clippingFactor = 0f;
		Vector3 vector = Clip(position2, position, 0.1f, collisionMask, hiderMask, out clippingFactor);
	}

	public static Vector3 Clip(Vector3 origin, Vector3 curPos, float radius, LayerMask mask, LayerMask hiderMask, out float clippingFactor)
	{
		clippingFactor = 0f;
		Vector3 vector = curPos - origin;
		float magnitude = vector.magnitude;
		vector /= magnitude;
		int num = Physics.RaycastNonAlloc(origin, vector, hitResults, magnitude + radius * 2f, mask, QueryTriggerInteraction.Ignore);
		for (int i = 0; i < num; i++)
		{
			RaycastHit raycastHit = hitResults[i];
			if ((hiderMask.value & (1 << raycastHit.collider.gameObject.layer)) != 0)
			{
				continue;
			}
			float magnitude2 = (raycastHit.point - origin).magnitude;
			float num2 = magnitude2 - radius;
			if (num2 < magnitude)
			{
				clippingFactor = 1f;
				return origin + vector * num2;
			}
			if (num2 - magnitude <= 0.2f)
			{
				float num3 = Mathf.Lerp(1f, 0f, (num2 - magnitude) / 0.2f);
				num3 *= num3;
				if (num3 > clippingFactor)
				{
					clippingFactor = num3;
				}
			}
		}
		return curPos;
	}

	public static void CloseClip(Vector3 origin, Vector3 direction, float minDist, float maxDist, LayerMask mask, LayerMask hiderMask, out float clipFactor)
	{
		clipFactor = 0f;
		if (Physics.Raycast(origin, direction, out var hitInfo, (int)mask) && (hiderMask.value & (1 << hitInfo.collider.gameObject.layer)) == 0)
		{
			float magnitude = (hitInfo.point - origin).magnitude;
			if (magnitude <= minDist)
			{
				clipFactor = 1f;
			}
			else if (magnitude > minDist && magnitude <= maxDist)
			{
				clipFactor = Mathf.Lerp(1f, 0f, (magnitude - minDist) / (maxDist - minDist));
			}
		}
	}
}
public class FearEffect : MonoBehaviour
{
	public AudioClip[] shortGasps;

	public AudioSource scaredBreathing;

	public Monochromize[] monoEffects;

	public float maxMonoIntensity = 1f;

	public float maxBreathingVolume = 0.4f;

	public float scareTime = 5f;

	public float volumeSpeedIn = 0.5f;

	public float volumeSpeedOut = 0.5f;

	public float monoSpeedIn = 0.5f;

	public float monoSpeedOut = 0.5f;

	private static FearEffect instance;

	public bool inTension;

	private float tensionTimer;

	private float monoIntensity;

	private float breathingVol;

	private void Awake()
	{
		instance = this;
	}

	public static FearEffect Get()
	{
		return instance;
	}

	public void Start()
	{
		inTension = false;
		tensionTimer = 0f;
		scaredBreathing.Stop();
		monoIntensity = 0f;
		breathingVol = 0f;
		monoEffects = new Monochromize[0];
	}

	private void Update()
	{
		float b = 0f;
		float b2 = 0f;
		if (inTension)
		{
			b = maxBreathingVolume;
			b2 = maxMonoIntensity;
			tensionTimer -= Time.deltaTime;
			if (tensionTimer <= 0f)
			{
				inTension = false;
			}
		}
		float num = ((!inTension) ? volumeSpeedOut : volumeSpeedIn);
		float num2 = ((!inTension) ? monoSpeedOut : monoSpeedIn);
		breathingVol = Mathf.Lerp(breathingVol, b, Time.deltaTime * num);
		monoIntensity = Mathf.Lerp(monoIntensity, b2, Time.deltaTime * num2);
		scaredBreathing.volume = breathingVol;
		if (breathingVol > 0f && !scaredBreathing.isPlaying)
		{
			scaredBreathing.Play();
		}
		else if (breathingVol <= 0.01f && scaredBreathing.isPlaying)
		{
			scaredBreathing.Stop();
		}
		for (int i = 0; i < monoEffects.Length; i++)
		{
			Monochromize monochromize = monoEffects[i];
			if (monochromize.enabled != monoIntensity > 0.01f)
			{
				monochromize.enabled = monoIntensity > 0.01f;
			}
			monochromize.intensity = monoIntensity;
			monochromize.brightnessFactor = 1.2f;
		}
	}

	public void Scare(bool jumpScare = false)
	{
		if (!jumpScare)
		{
			inTension = true;
			tensionTimer = Mathf.Max(tensionTimer, scareTime);
			return;
		}
		AudioSource.PlayClipAtPoint(RandomExt.Choice(shortGasps), base.transform.position);
		if (inTension)
		{
			breathingVol = 0f;
		}
	}
}
public class NeckTracker : MonoBehaviour
{
	public OVRCameraRig ovrCamera;

	private void Update()
	{
		Vector3 position = ovrCamera.trackerAnchor.position;
		base.transform.localPosition = position;
	}
}
public class PauseSphere : TimeIndependentBehaviour
{
	private float factor;

	private Vector3 origScale;

	private Material material;

	private void Start()
	{
		origScale = base.transform.localScale;
		material = GetComponent<Renderer>().material;
	}

	protected override void Update()
	{
		base.Update();
		if (GameController.Get().Paused)
		{
			factor += base.deltaTime * 2f;
		}
		else
		{
			factor -= base.deltaTime * 2f;
		}
		factor = Mathf.Clamp01(factor);
		float num = Interpolate.EaseInOutCubic(0f, 1f, factor);
		base.transform.localScale = new Vector3(origScale.x * num, origScale.y, origScale.z * num);
		material.SetFloat("_Opacity", num);
		GetComponent<Renderer>().enabled = num != 0f;
	}
}
public class Player
{
	private static GameObject playerRef;

	private static Transform playerLook;

	private static Transform playerRightHandTransform;

	private static Transform playerLeftHandTransform;

	private static PlayerHand playerRightHand;

	private static PlayerHand playerLeftHand;

	private static Transform playerActionHandTransform;

	private static Transform playerLampHandTransform;

	private static PlayerHand playerActionHand;

	private static PlayerHand playerLampHand;

	private static Transform playerHandLook;

	private static Transform playerForwardDir;

	private static MinimapPosition playerMinimapPos;

	private static Inventory playerInventory;

	private static UICrosshair3D crosshair;

	private static TorchFuel playerTorchFuel;

	public static PlayerGameController Controller => Get().GetComponent<PlayerGameController>();

	public static Transform Look => GetLook();

	public static Vector3 LookDir => GetLook().forward;

	public static Vector3 CenterEye => GetLook().position;

	public static Transform ForwardDirection => GetForwardDirection();

	public static Vector3 Pos => Vector3Ext.GroundVector(Get().transform.position);

	public static Vector3 GroundPos => Vector3Ext.GroundVector(Get().transform.position);

	private static void SetPlayerRef()
	{
		playerRef = GameObject.FindWithTag(Tags.Player);
	}

	private static void SetPlayerLookRef()
	{
		playerLook = GameObject.FindWithTag(Tags.LookDirection).transform;
	}

	private static void SetPlayerHandsRefs()
	{
		playerRightHandTransform = GameObject.FindWithTag(Tags.RightHand).transform;
		playerLeftHandTransform = GameObject.FindWithTag(Tags.LeftHand).transform;
		playerLeftHand = playerLeftHandTransform.GetComponentInChildren<PlayerHand>();
		playerRightHand = playerRightHandTransform.GetComponentInChildren<PlayerHand>();
		if (InputExt.HasHandControllers)
		{
			playerActionHandTransform = ((!InputExt.LeftHanded) ? playerRightHandTransform : playerLeftHandTransform);
			playerLampHandTransform = ((!InputExt.LeftHanded) ? playerLeftHandTransform : playerRightHandTransform);
			playerActionHand = ((!InputExt.LeftHanded) ? playerRightHand : playerLeftHand);
			playerLampHand = ((!InputExt.LeftHanded) ? playerLeftHand : playerRightHand);
		}
	}

	public static void ResetPlayerHands()
	{
		playerLeftHandTransform = (playerRightHandTransform = null);
		playerLeftHand = (playerRightHand = null);
		playerActionHandTransform = (playerLampHandTransform = null);
		playerActionHand = (playerLampHand = null);
	}

	private static void SetPlayerHandsLookRefs()
	{
		Transform transform = GameObject.FindWithTag(Tags.LeftHandLook).transform;
		Transform transform2 = GameObject.FindWithTag(Tags.RightHandLook).transform;
		playerHandLook = ((!InputExt.LeftHanded) ? transform2 : transform);
	}

	private static void SetPlayerForwardDirRef()
	{
		playerForwardDir = GameObject.FindWithTag(Tags.ForwardDirection).transform;
	}

	private static void SetPlayerMinimapPosRef()
	{
		playerMinimapPos = GameObject.FindWithTag(Tags.Minimap).GetComponent<MinimapPosition>();
	}

	private static void SetPlayerInventory()
	{
		playerInventory = GameObject.FindWithTag(Tags.Inventory).GetComponent<Inventory>();
	}

	private static void SetPlayerCrosshair()
	{
		crosshair = Get().transform.Find("Crosshair").GetComponent<UICrosshair3D>();
	}

	private static void SetPlayerTorchFuel()
	{
		playerTorchFuel = GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchFuel>();
	}

	public static GameObject Get()
	{
		if (!playerRef)
		{
			SetPlayerRef();
		}
		return playerRef;
	}

	public static PlayerGameController GetController()
	{
		return Get().GetComponent<PlayerGameController>();
	}

	public static T GetComponent<T>() where T : Component
	{
		return Get().GetComponent<T>();
	}

	public static T GetComponentInChildren<T>() where T : Component
	{
		return Get().GetComponentInChildren<T>();
	}

	public static Transform GetLook(bool interaction = false)
	{
		if (!playerLook)
		{
			SetPlayerLookRef();
		}
		if (interaction && InputExt.Using3DOFController)
		{
			if (!playerRightHand && !playerLeftHand)
			{
				SetPlayerHandsRefs();
			}
			return (!InputExt.RightHanded) ? playerLeftHandTransform : playerRightHandTransform;
		}
		if (interaction && InputExt.UsingHandControllers)
		{
			if (!playerHandLook)
			{
				SetPlayerHandsLookRefs();
			}
			return playerHandLook;
		}
		return playerLook;
	}

	public static Vector3 GetLookDir()
	{
		return GetLook().forward;
	}

	public static Vector3 GetCenterEye()
	{
		return GetLook().position;
	}

	public static Transform Get3DOFController()
	{
		if (InputExt.Using3DOFController)
		{
			if (!playerRightHand && !playerLeftHand)
			{
				SetPlayerHandsRefs();
			}
			return (!InputExt.RightHanded) ? playerLeftHandTransform : playerRightHandTransform;
		}
		return null;
	}

	public static Transform GetLeftHandTransform()
	{
		if (!playerLeftHandTransform)
		{
			SetPlayerHandsRefs();
		}
		return playerLeftHandTransform;
	}

	public static Transform GetRightHandTransform()
	{
		if (!playerRightHandTransform)
		{
			SetPlayerHandsRefs();
		}
		return playerRightHandTransform;
	}

	public static PlayerHand GetLeftHand()
	{
		if (!InputExt.UsingHandControllers)
		{
			return null;
		}
		if (!playerLeftHand)
		{
			SetPlayerHandsRefs();
		}
		return playerLeftHand;
	}

	public static PlayerHand GetRightHand()
	{
		if (!InputExt.UsingHandControllers)
		{
			return null;
		}
		if (!playerRightHand)
		{
			SetPlayerHandsRefs();
		}
		return playerRightHand;
	}

	public static Transform GetActionHandTransform()
	{
		if (!InputExt.UsingHandControllers)
		{
			return null;
		}
		if (!playerActionHandTransform)
		{
			SetPlayerHandsRefs();
		}
		return playerActionHandTransform;
	}

	public static Transform GetLampHandTransform()
	{
		if (!InputExt.UsingHandControllers)
		{
			return null;
		}
		if (!playerLampHandTransform)
		{
			SetPlayerHandsRefs();
		}
		return playerLampHandTransform;
	}

	public static PlayerHand GetActionHand()
	{
		if (!InputExt.UsingHandControllers)
		{
			return null;
		}
		if (!playerActionHand)
		{
			SetPlayerHandsRefs();
		}
		return playerActionHand;
	}

	public static PlayerHand GetLampHand()
	{
		if (!InputExt.UsingHandControllers)
		{
			return null;
		}
		if (!playerLampHand)
		{
			SetPlayerHandsRefs();
		}
		return playerLampHand;
	}

	public static MinimapPosition GetMinimapPos()
	{
		if (!playerMinimapPos)
		{
			SetPlayerMinimapPosRef();
		}
		return playerMinimapPos;
	}

	public static Inventory GetInventory()
	{
		if (!playerInventory)
		{
			SetPlayerInventory();
		}
		return playerInventory;
	}

	public static UICrosshair3D GetCrosshair()
	{
		if (!crosshair)
		{
			SetPlayerCrosshair();
		}
		return crosshair;
	}

	public static TorchFuel GetTorchFuel()
	{
		if (!playerTorchFuel)
		{
			SetPlayerTorchFuel();
		}
		return playerTorchFuel;
	}

	public static Transform GetForwardDirection()
	{
		if (!playerForwardDir)
		{
			SetPlayerForwardDirRef();
		}
		return playerForwardDir;
	}

	public static Vector3 GetPos()
	{
		return Vector3Ext.GroundVector(Get().transform.position);
	}

	public static Vector3 GetGroundPos()
	{
		return Vector3Ext.GroundVector(Get().transform.position);
	}

	public static Vector3 GetToPos(Vector3 from)
	{
		return GetPos() - from;
	}

	public static Vector3 GetToPosGround(Vector3 from)
	{
		return Vector3Ext.GroundVector(GetPos(), from);
	}

	public static bool IsSafe()
	{
		if (GameController.Get().levelOptions.safeMap)
		{
			return true;
		}
		Room room = Map.Get().At(GetPos()).Room;
		if (room != null && room.Safe)
		{
			return true;
		}
		return false;
	}

	public static void Clear()
	{
		playerRef = null;
		playerLook = null;
		playerForwardDir = null;
		playerMinimapPos = null;
		playerInventory = null;
	}
}
public class PlayerCollision : MonoBehaviour
{
	public virtual void OnPlayerCollision(GameObject player)
	{
	}
}
[RequireComponent(typeof(OVRPlayerController))]
public class PlayerGameController : MonoBehaviour
{
	public float WalkSpeed = 1f;

	public float RunSpeedFactor = 2f;

	public float RotationSpeed = 1f;

	public float StaminaConsumptionRate = 0.1f;

	public float StaminaRegenRate = 0.4f;

	public float StaminaTiredRegenRate = 0.2f;

	public float ScaredStaminaConsumptionMultiplier = 0.5f;

	public float TiredSpeedFactor = 0.7f;

	public float RunCooldown = 0.5f;

	private float runCooldownTimer;

	public AudioSource HeavyBreathSound;

	public float HeavyBreathMaxVolume = 1f;

	private float Health;

	public float HealthRegenRate = 0.2f;

	public Texture2D HurtTexture;

	public AudioClip HurtSlashSound;

	public AudioClip HurtSound;

	private Fader hurtEffect;

	private OVRPlayerController OVRController;

	private float Stamina;

	private bool Tired;

	private int movementBlocked;

	private int rotationBlocked;

	public bool isRunning;

	public List<Point> PathToExit;

	public Point CurrentCell;

	private Pathfinder Pathfinder;

	private Pathfinder.Query pathQuery;

	private FearEffect fearEffect;

	private EyeClip[] clipEyes;

	public Texture2D clipTexture;

	private AudioLowPassFilter lowPassFilter;

	public Renderer clipFader;

	public GameObject tutoArrowsLeft;

	public GameObject tutoArrowsRight;

	public GameObject[] handObjects;

	private void Start()
	{
		Debug.Log("PlayerGameController - Start");
		OVRController = GetComponent<OVRPlayerController>();
		OVRController.SetMoveScaleMultiplier(WalkSpeed);
		OVRController.SetRotationScaleMultiplierMouse(RotationSpeed * Config.Input().mouseSensitivity);
		OVRController.SetRotationScaleMultiplierPad(RotationSpeed * Config.Input().gamepadSensitivity);
		OVRController.SetSkipMouseRotation(skipMouseRotation: true);
		fearEffect = GetComponent<FearEffect>();
		clipEyes = GetComponentsInChildren<EyeClip>();
		lowPassFilter = GetComponentInChildren<AudioLowPassFilter>();
		hurtEffect = GameObject.Find("HurtEffect").GetComponent<Fader>();
		Stamina = 1f;
		Tired = false;
		movementBlocked = 0;
		rotationBlocked = 0;
		Health = 1f;
		PathToExit = new List<Point>();
		CurrentCell = new Point(0, 0);
		Pathfinder = new Pathfinder(60);
		UpdateHandObjects();
		Debug.Log("PlayerGameController - End Start");
	}

	private void Update()
	{
		float walkSpeed = WalkSpeed;
		float num = RotationSpeed;
		isRunning = OVRController.lastThrottleSpeed > 0.035f;
		if (InputExt.GetRunButton())
		{
			walkSpeed *= RunSpeedFactor;
			float num2 = ((!fearEffect.inTension) ? 1f : ScaredStaminaConsumptionMultiplier);
			if (!Tired && isRunning)
			{
				Stamina -= StaminaConsumptionRate * num2 * Time.deltaTime;
			}
			else
			{
				Stamina += StaminaTiredRegenRate * Time.deltaTime;
			}
			if (Stamina <= 0f && !Tired)
			{
				Tired = true;
			}
			Player.GetMinimapPos().Hide = true;
			Player.GetMinimapPos().Minimize = true;
			runCooldownTimer = 0f;
		}
		else
		{
			walkSpeed *= 1f;
			if (runCooldownTimer > RunCooldown)
			{
				Stamina += ((!Tired) ? StaminaRegenRate : StaminaTiredRegenRate) * Time.deltaTime;
			}
			else
			{
				runCooldownTimer += Time.deltaTime;
			}
		}
		Stamina = Mathf.Clamp(Stamina, 0f, 1f);
		if (Tired)
		{
			walkSpeed = Mathf.Min(walkSpeed, WalkSpeed * TiredSpeedFactor);
			if (Stamina >= 1f)
			{
				Tired = false;
			}
		}
		else if (Health <= 0.5f)
		{
			walkSpeed = Mathf.Min(walkSpeed, WalkSpeed * TiredSpeedFactor);
		}
		float num3 = 1f - Mathf.Clamp(Stamina / 0.6f, 0f, 1f);
		HeavyBreathSound.volume = Mathf.Lerp(HeavyBreathSound.volume, num3 * HeavyBreathMaxVolume, Time.deltaTime * 3f);
		if (GameController.Get().Paused)
		{
			HeavyBreathSound.volume = 0f;
		}
		float num4 = 0f;
		EyeClip[] array = clipEyes;
		foreach (EyeClip eyeClip in array)
		{
			num4 = Mathf.Max(num4, eyeClip.clippingFactor);
		}
		clipFader.enabled = num4 > 0f;
		clipFader.material.color = new Color(1f, 1f, 1f, num4);
		GameController.Get().VolumeMultiplier = Mathf.Lerp(1f, 0.5f, num4);
		if (Health < 1f && Health > 0f)
		{
			Health += HealthRegenRate * Time.deltaTime;
			Health = Mathf.Clamp(Health, 0f, 1f);
		}
		if (Health <= 0f || movementBlocked > 0)
		{
			walkSpeed = 0f;
		}
		if (Health <= 0f || rotationBlocked > 0)
		{
			num = 0f;
		}
		OVRController.SetMoveScaleMultiplier(walkSpeed);
		OVRController.SetRotationScaleMultiplierMouse(num * Config.Input().mouseSensitivity);
		OVRController.SetRotationScaleMultiplierPad(num * Config.Input().gamepadSensitivity);
		Point point = Map.Get().WorldToCell(base.transform.position);
		if (point != CurrentCell)
		{
			Room room = Map.Get().At(CurrentCell).Room;
			Room room2 = Map.Get().At(point).Room;
			CurrentCell = point;
			if (room != room2)
			{
				room?.PlayerExit();
				if (room2 != null)
				{
					room2.PlayerEnter();
					ClockMode.Set(room2.Template.flags.clockMode);
				}
				else
				{
					ClockMode.Set(ClockMode.Mode.Standard);
				}
			}
			ComputePathToExit();
		}
		UpdatePathfinder();
	}

	private void UpdateHandObjects()
	{
		bool using3DOFController = InputExt.Using3DOFController;
		for (int i = 0; i < handObjects.Length; i++)
		{
			if (handObjects[i].activeSelf != using3DOFController)
			{
				handObjects[i].SetActive(using3DOFController);
			}
		}
	}

	public void ApplyAttack(float fDamage = 0.8f, string gameOverText = "GAMEOVER_DEFAULT", float fadeInSpeed = 1.5f)
	{
		if (!(Health <= 0f))
		{
			Health -= fDamage;
			AudioSource.PlayClipAtPoint(HurtSlashSound, base.transform.position);
			AudioSource.PlayClipAtPoint(HurtSound, base.transform.position);
			hurtEffect.FadeIn(fadeInSpeed);
			if (Health <= 0f)
			{
				PlayerStats.Get().AddDeath();
				GameController.Get().ShowGameOver(gameOverText);
			}
		}
	}

	public void AddHealth(float amount = 1f)
	{
		Health += amount;
	}

	public void ForceTired()
	{
		Tired = true;
		Stamina = 0f;
	}

	public bool IsInExitPath(Point position)
	{
		foreach (Point item in PathToExit)
		{
			if (item == position)
			{
				return true;
			}
		}
		return false;
	}

	private void ComputePathToExit()
	{
		Point exitPosition = Map.Get().ExitPosition;
		Point closestWalkable = Map.Get().GetClosestWalkable(base.transform.position);
		pathQuery = Pathfinder.AddQuery(closestWalkable, exitPosition, null, CheckTraversal, GetTraversalCost, null, 0.5f);
	}

	private void UpdatePathfinder()
	{
		if (pathQuery == null)
		{
			return;
		}
		Pathfinder.Update();
		if (!pathQuery.IsFinished())
		{
			return;
		}
		if (pathQuery.IsSuccess())
		{
			PathToExit.Clear();
			for (int i = 0; i < pathQuery.Path.Count; i++)
			{
				PathToExit.Add(pathQuery.Path[i]);
			}
		}
		else
		{
			Point point = Map.Get().WorldToCell(base.transform.position);
			if (PathToExit.Count == 0 || PathToExit[0] != point)
			{
				PathToExit.Insert(0, point);
			}
		}
		Pathfinder.FreeQuery(pathQuery);
		pathQuery = null;
	}

	private float GetTraversalCost(Point from, Point end, object movementDesc)
	{
		Map map = Map.Get();
		if (from.X < 0 || from.X >= map.Width || from.Y < 0 || from.Y >= map.Height || end.X < 0 || end.X >= map.Width || end.Y < 0 || end.Y >= map.Height)
		{
			return float.MaxValue;
		}
		return 1f;
	}

	private bool CheckTraversal(Point from, Point end, object movementDesc)
	{
		Map map = Map.Get();
		if (from.X <= 0 || from.X >= map.Width - 1 || from.Y <= 0 || from.Y >= map.Height - 1 || end.X <= 0 || end.X >= map.Width - 1 || end.Y <= 0 || end.Y >= map.Height - 1)
		{
			return false;
		}
		Cell cell = map.At(end.X, end.Y);
		if (map.ExitPosition == end)
		{
			return true;
		}
		if (!cell.CanWalk() || (cell.Occupied && cell.Room != null && cell.Door == null && !cell.IsDoor))
		{
			return false;
		}
		if (from.X != end.X && from.Y != end.Y)
		{
			return false;
		}
		return true;
	}

	public void BlockMovement(bool blockRotation = true)
	{
		movementBlocked++;
		if (blockRotation)
		{
			rotationBlocked++;
		}
	}

	public void UnblockMovement(bool unBlockRotation = true)
	{
		movementBlocked--;
		if (unBlockRotation)
		{
			rotationBlocked--;
		}
	}

	public void BlockRotation()
	{
		rotationBlocked++;
	}

	public void UnBlockRotation()
	{
		rotationBlocked--;
	}

	private void OnControllerColliderHit(ControllerColliderHit hit)
	{
		GameObject gameObject = hit.collider.gameObject;
		if (movementBlocked > 0)
		{
			return;
		}
		if (gameObject.CompareTag(Tags.Exit))
		{
			PlayerStats.Get().AddWin();
			if (GameController.Get().levelOptions.isDemo)
			{
				GameController.Get().EndLevel(win: true);
			}
			else if (GameController.Get().levelOptions.isRandomMode)
			{
				GameController.Get().EndLevel();
			}
			else
			{
				GameController.Get().EnterHub(saveCheckpoint: true);
			}
			BlockMovement();
			hit.collider.enabled = false;
		}
		else if (gameObject.CompareTag(Tags.PlayerTrigger))
		{
			PlayerCollision component = gameObject.GetComponent<PlayerCollision>();
			if ((bool)component)
			{
				component.OnPlayerCollision(base.gameObject);
			}
		}
		else if (gameObject.CompareTag(Tags.DoorTrigger))
		{
			DoorCollision component2 = gameObject.GetComponent<DoorCollision>();
			if ((bool)component2)
			{
				component2.OnPlayerCollision(base.gameObject, hit.collider);
			}
		}
	}

	private void OnTriggerEnter(Collider trigger)
	{
		if (trigger.CompareTag(Tags.PlayerTrigger))
		{
			Trigger component = trigger.GetComponent<Trigger>();
			if (component != null)
			{
				component.OnActivate(this);
			}
		}
		else if (trigger.CompareTag(Tags.Exit))
		{
			if (movementBlocked <= 0)
			{
				PlayerStats.Get().AddWin();
				if (GameController.Get().levelOptions.isDemo)
				{
					GameController.Get().EndLevel(win: true);
				}
				else if (GameController.Get().levelOptions.isRandomMode)
				{
					GameController.Get().EndLevel();
				}
				else
				{
					GameController.Get().EnterHub(saveCheckpoint: true);
				}
				BlockMovement();
			}
		}
		else if (trigger.CompareTag(Tags.DoorTrigger))
		{
			DoorCollision component2 = trigger.transform.parent.GetComponent<DoorCollision>();
			if ((bool)component2)
			{
				component2.OnPlayerCollision(base.gameObject, trigger);
			}
		}
	}

	private void OnTriggerStay(Collider trigger)
	{
		if (trigger.CompareTag(Tags.DoorTrigger))
		{
			DoorCollision component = trigger.transform.parent.GetComponent<DoorCollision>();
			if ((bool)component)
			{
				component.OnPlayerCollision(base.gameObject, trigger);
			}
		}
	}

	[Conditional("DH_DEBUG")]
	public void TeleportToExitRoom()
	{
		Room room = Map.Get().At(Map.Get().ExitPosition).Room;
		if (room != null)
		{
			Point randomPoint = room.GetRandomPoint();
			Vector3 vector = Map.Get().CellToWorld(randomPoint).ToGround();
			base.transform.position = vector + Vector3.up * base.transform.position.y;
		}
	}

	public void ShowTutoArrows(bool visible = true)
	{
		if (InputExt.Using3DOFController || InputExt.UsingHandControllers)
		{
			GameObject gameObject = ((!InputExt.RightHanded) ? tutoArrowsLeft : tutoArrowsRight);
			if (gameObject != null)
			{
				gameObject.SetActive(visible);
			}
		}
	}
}
public class PlayerHand : TimeIndependentBehaviour
{
	private static class Const
	{
		public const string AnimLayerNamePoint = "Point Layer";

		public const string AnimLayerNameThumb = "Thumb Layer";

		public const string AnimParamNameFlex = "Flex";

		public const string AnimParamNamePose = "Pose";

		public const float HapticOverlapAmplitude = 0.25f;

		public const float HapticOverlapFrequency = 320f;

		public const float HapticOverlapDuration = 0.05f;

		public const float InputRateChange = 20f;

		public static readonly Vector3 LeftHandPosition = new Vector3(-0.0252f, -0.0174f, -0.038f);

		public static readonly Quaternion LeftHandRotation = Quaternion.Euler(10.844f, -13.027f, 74.278f);

		public static readonly Vector3 RightHandPosition = new Vector3(0.0252f, -0.0174f, -0.038f);

		public static readonly Quaternion RightHandRotation = Quaternion.Euler(10.844f, 13.027f, -74.278f);

		public const float ThreshCollisionFlex = 0.96f;

		public const float ThreshGrabBegin = 0.55f;

		public const float ThreshGrabEnd = 0.35f;

		public const float ThreshThrowSpeed = 1f;
	}

	public bool isRightHand;

	public Animator animator;

	public Transform meshRoot;

	private int animLayerIndexThumb = -1;

	private int animLayerIndexPoint = -1;

	private int animLayerIndexFlex = -1;

	private int animLayerIndexPose = -1;

	private float flex;

	private float point;

	private float thumbsUp;

	public bool IsVisible = true;

	private float visibility;

	private Renderer[] renderers;

	private List<Material> materials;

	private TrackedController trackedController;

	public bool lampLocked;

	public bool mapLocked;

	public GameObject tutoArrows;

	private void Start()
	{
		animLayerIndexPoint = animator.GetLayerIndex("Point Layer");
		animLayerIndexThumb = animator.GetLayerIndex("Thumb Layer");
		animLayerIndexFlex = Animator.StringToHash("Flex");
		animLayerIndexPose = Animator.StringToHash("Pose");
		base.transform.localPosition = ((!isRightHand) ? Const.LeftHandPosition : Const.RightHandPosition);
		base.transform.localRotation = ((!isRightHand) ? Const.LeftHandRotation : Const.RightHandRotation);
		trackedController = TrackedController.FindOrCreate(isRightHand ? HandednessId.Right : HandednessId.Left);
	}

	private new void Update()
	{
		base.Update();
		if (materials == null)
		{
			materials = new List<Material>();
			renderers = GetComponentsInChildren<Renderer>();
			Renderer[] array = renderers;
			foreach (Renderer renderer in array)
			{
				materials.Add(renderer.material);
			}
		}
		visibility = Interpolate.Approach(visibility, (!IsVisible) ? 0f : 1f, base.deltaTime * 10f);
		for (int j = 0; j < materials.Count; j++)
		{
			materials[j].SetFloat("_Fade", visibility);
		}
		if ((!IsVisible && visibility <= 0.01f) || (IsVisible && visibility > 0.01f))
		{
			for (int k = 0; k < renderers.Length; k++)
			{
				renderers[k].enabled = IsVisible;
			}
		}
		float num = flex;
		flex = GetInputFlex();
		point = InputValueRateChange(GetInputPoint(), point);
		thumbsUp = InputValueRateChange(GetInputThumbsUp(), thumbsUp);
		int value = 0;
		animator.SetInteger(animLayerIndexPose, value);
		animator.SetFloat(animLayerIndexFlex, flex);
		animator.SetLayerWeight(animLayerIndexPoint, point);
		animator.SetLayerWeight(animLayerIndexThumb, thumbsUp);
		if (lampLocked)
		{
			Quaternion rotation = base.transform.parent.rotation;
			float y = rotation.eulerAngles.y;
			float x = rotation.eulerAngles.x;
			base.transform.rotation = Quaternion.Euler(x, y, 0f);
		}
	}

	private float GetInputFlex()
	{
		if (mapLocked)
		{
			return 0.4f;
		}
		return (!lampLocked) ? Mathf.Max(trackedController.GripTrigger, trackedController.Trigger) : 1f;
	}

	private bool GetInputPoint()
	{
		if (lampLocked || mapLocked)
		{
			return false;
		}
		return trackedController.IsPoint;
	}

	private bool GetInputThumbsUp()
	{
		if (lampLocked || mapLocked)
		{
			return false;
		}
		return trackedController.IsThumbsUp;
	}

	private float InputValueRateChange(bool isDown, float value)
	{
		float num = base.deltaTime * 20f;
		float num2 = ((!isDown) ? (-1f) : 1f);
		return Mathf.Clamp01(value + num * num2);
	}

	public void ShowTutoArrows(bool visible = true)
	{
		if (tutoArrows != null)
		{
			tutoArrows.SetActive(visible);
		}
	}

	public void PlayHaptic(float freq, float amplitude, float duration)
	{
		trackedController.PlayHapticEvent(freq, amplitude, duration);
	}

	public void PlayHapticSelect()
	{
		trackedController.PlayHapticEvent(0.1f, 0.2f, 0.1f);
	}

	public void PlayHapticCollect()
	{
		trackedController.PlayHapticEvent(0.2f, 0.2f, 0.025f);
	}

	public void PlayHapticUnlock()
	{
		trackedController.PlayHapticEvent(0.125f, 0.5f, 0.1f);
	}

	public void PlayHapticInInteractionArea()
	{
		trackedController.PlayHapticEvent(0.3f, 0.4f, 0.035f);
	}

	public void PlayHapticClip(AudioClip hapticClip)
	{
		OVRHapticsClip clip = new OVRHapticsClip(hapticClip);
		if (isRightHand)
		{
			OVRHaptics.RightChannel.Preempt(clip);
		}
		else
		{
			OVRHaptics.LeftChannel.Preempt(clip);
		}
	}

	public void PlayPositionalHaptic(Vector3 origin, float radius, float maxFreq = 1f, float maxAmplitude = 1f, float minFreq = 0f, float minAmplitude = 0f)
	{
		float magnitude = (base.transform.position - origin).magnitude;
		float t = (radius - magnitude) / radius;
		trackedController.PlayHapticEvent(Interpolate.Lerp(minFreq, maxFreq, t), Interpolate.Lerp(minAmplitude, maxAmplitude, t), 1f / 60f);
	}
}
public class PlayerStats : MonoBehaviour
{
	public class Stats
	{
		public class Event
		{
			public enum EventType
			{
				Position,
				Collect,
				Die,
				Win
			}

			public EventType eventType;

			public uint timeTick;

			public Point position;

			public Event(EventType evType, uint curTime, Point curPos)
			{
				eventType = evType;
				timeTick = curTime;
				position = curPos;
			}
		}

		public int totalItems;

		public int collectedItems;

		public List<Event> events;

		public uint[][] discoveredTiles;

		public int totalProbes;

		public int discoveredProbes;

		public Texture2D levelMap;

		public bool resultWin;

		public uint totalTime;

		public Stats()
		{
			events = new List<Event>();
			events.Capacity = 1024;
			totalItems = (collectedItems = 0);
			totalProbes = (discoveredProbes = 0);
			discoveredTiles = new uint[64][];
			for (int i = 0; i < 64; i++)
			{
				discoveredTiles[i] = new uint[64];
				for (int j = 0; j < 64; j++)
				{
					discoveredTiles[i][j] = uint.MaxValue;
				}
			}
			levelMap = null;
			resultWin = false;
			totalTime = 0u;
		}

		public void AddEvent(Event.EventType evType, uint curTime, Point curPos)
		{
			Event item = new Event(evType, curTime, curPos);
			events.Add(item);
		}
	}

	private static PlayerStats instance;

	public static Stats stats;

	public bool recordStats;

	public uint curTimeTick;

	private float timeCounter;

	public Point lastPos;

	public Point curPos;

	public float curOrientation;

	public static PlayerStats Get()
	{
		return instance;
	}

	public static void Clear()
	{
		instance = null;
		stats = null;
	}

	private void Awake()
	{
		instance = this;
		recordStats = GameController.Get().levelOptions.isRandomMode;
		if (recordStats)
		{
			stats = new Stats();
		}
		else
		{
			stats = null;
			base.enabled = false;
		}
		curTimeTick = 0u;
		timeCounter = 0f;
		lastPos = new Point(0, 0);
		curPos = Map.Get().WorldToCell(base.transform.position);
		curOrientation = base.transform.rotation.eulerAngles.z;
	}

	private void Update()
	{
		bool flag = false;
		timeCounter += Time.deltaTime;
		if (timeCounter >= 0.1f)
		{
			curTimeTick++;
			timeCounter -= 0.1f;
			flag = true;
			stats.totalTime = curTimeTick;
		}
		curPos = Map.Get().WorldToCell(base.transform.position);
		curOrientation = Player.GetForwardDirection().rotation.eulerAngles.y;
		if (curPos != lastPos)
		{
			stats.AddEvent(Stats.Event.EventType.Position, curTimeTick, curPos);
			lastPos = curPos;
		}
	}

	public void SetMinimap(Texture2D levelMap)
	{
		if (recordStats)
		{
			stats.levelMap = levelMap;
		}
	}

	public void AddItem()
	{
		if (recordStats)
		{
			stats.totalItems++;
		}
	}

	public void AddCollectedItem()
	{
		if (recordStats)
		{
			stats.collectedItems++;
			stats.AddEvent(Stats.Event.EventType.Collect, curTimeTick, curPos);
		}
	}

	public void AddProbe()
	{
		if (recordStats)
		{
			stats.totalProbes++;
		}
	}

	public void AddDiscovered(Point tile)
	{
		if (recordStats && stats.discoveredTiles[tile.Y][tile.X] == uint.MaxValue)
		{
			stats.discoveredProbes++;
			stats.discoveredTiles[tile.Y][tile.X] = curTimeTick;
		}
	}

	public void AddDeath()
	{
		if (recordStats)
		{
			stats.AddEvent(Stats.Event.EventType.Position, curTimeTick, curPos);
			stats.AddEvent(Stats.Event.EventType.Die, curTimeTick, curPos);
			stats.resultWin = false;
			stats.totalTime = curTimeTick;
			base.enabled = false;
		}
	}

	public void AddWin()
	{
		if (recordStats)
		{
			stats.AddEvent(Stats.Event.EventType.Position, curTimeTick, curPos);
			stats.AddEvent(Stats.Event.EventType.Win, curTimeTick, curPos);
			stats.resultWin = true;
			stats.totalTime = curTimeTick;
			base.enabled = false;
		}
	}
}
public class RatchetRotation : MonoBehaviour
{
	public enum RotationType
	{
		Immediate,
		ApproachFast,
		Approach,
		Linear
	}

	public OVRPlayerController playerController;

	public OVRCameraRig cameraController;

	public float rotationAmount = 45f;

	public float rotationAmount3DOF = 45f;

	public float rotationTimer = 0.35f;

	private float baseRotationAmount;

	private bool isActive;

	public RotationType rotationType;

	public string axisName = "Right_X_Axis";

	private bool prevLeft;

	private bool prevRight;

	private float leftTimer;

	private float rightTimer;

	private float rotDeltaTarget;

	public bool snapToAxis;

	public float snapMargin = 8f;

	[Range(0f, 1f)]
	public float activationPoint = 0.9f;

	[Range(0f, 1f)]
	public float endActivationPoint = 0.1f;

	public bool IsActive
	{
		get
		{
			return isActive;
		}
		set
		{
			if (value != isActive)
			{
				isActive = value;
				if (isActive)
				{
					baseRotationAmount = playerController.RotationAmount;
					playerController.RotationAmount = 0f;
				}
				else
				{
					playerController.RotationAmount = baseRotationAmount;
				}
			}
		}
	}

	private void Start()
	{
		if (!playerController)
		{
			playerController = GetComponent<OVRPlayerController>();
		}
		if (!cameraController)
		{
			cameraController = Player.Get().GetComponentInChildren<OVRCameraRig>();
		}
		baseRotationAmount = Mathf.Max(playerController.RotationAmount, baseRotationAmount);
		if (Config.Input().comfortRotation)
		{
			IsActive = true;
		}
	}

	private void Update()
	{
		float num = ((!isActive) ? 0f : InputExt.GetAxisPadRatchet(InputExt.Axis2D.RightThumbstick).x);
		float num2 = InputExt.GetAxisPad(InputExt.Axis2D.Dpad).x;
		float num3 = rotationAmount;
		InputExt.TouchpadStatus touchpadStatus = null;
		if (InputExt.Using3DOFController)
		{
			touchpadStatus = InputExt.touchpadStatus;
		}
		if (touchpadStatus != null)
		{
			float num4 = 0f;
			if (touchpadStatus.isSwiping)
			{
				if (touchpadStatus.swipeDir == InputExt.TouchpadStatus.SwipeDir.LEFT)
				{
					num4 = -1f;
				}
				else if (touchpadStatus.swipeDir == InputExt.TouchpadStatus.SwipeDir.RIGHT)
				{
					num4 = 1f;
				}
				touchpadStatus.isSwiping = false;
			}
			num2 = num4;
			num3 = rotationAmount3DOF;
		}
		float num5 = 0f;
		bool flag = false;
		if (num <= 0f - (1f - endActivationPoint) || num2 <= 0f - activationPoint)
		{
			flag = true;
			leftTimer -= Time.deltaTime;
		}
		else
		{
			leftTimer = 0f;
		}
		if (flag && (!prevLeft || leftTimer <= 0f))
		{
			num5 -= num3;
			leftTimer = rotationTimer;
		}
		prevLeft = flag;
		bool flag2 = false;
		if (num >= 1f - endActivationPoint || num2 >= activationPoint)
		{
			flag2 = true;
			rightTimer -= Time.deltaTime;
		}
		else
		{
			rightTimer = 0f;
		}
		if (flag2 && (!prevRight || rightTimer <= 0f))
		{
			num5 += num3;
			rightTimer = rotationTimer;
		}
		prevRight = flag2;
		rotDeltaTarget += num5;
		float rot = 0f;
		playerController.GetYRotation(ref rot);
		if (snapToAxis)
		{
			float num6 = rot;
			float num7 = rot + rotDeltaTarget + base.transform.rotation.eulerAngles.y;
			while (num7 > 360f)
			{
				num7 -= 360f;
				num6 -= 360f;
			}
			while (num7 < -360f)
			{
				num7 += 360f;
				num6 += 360f;
			}
			for (int i = 0; i <= 4; i++)
			{
				float num8 = 90f * (float)i;
				if (Mathf.Abs(num7 - num8) <= snapMargin)
				{
					rotDeltaTarget = num8 - num6 - base.transform.rotation.eulerAngles.y;
					break;
				}
			}
		}
		float num9 = 0f;
		if (rotationType == RotationType.Immediate)
		{
			num9 = rotDeltaTarget;
			rotDeltaTarget = 0f;
		}
		else if (rotationType == RotationType.ApproachFast)
		{
			num9 = rotDeltaTarget * Time.deltaTime * 40f;
			rotDeltaTarget -= num9;
		}
		else if (rotationType == RotationType.Approach)
		{
			num9 = rotDeltaTarget * Time.deltaTime * 20f;
			rotDeltaTarget -= num9;
		}
		else if (rotationType == RotationType.Linear)
		{
			float num10 = Mathf.Abs(rotDeltaTarget);
			if (num10 >= 0.01f)
			{
				num9 = Mathf.Clamp(Time.deltaTime * 2f, 0f, num10);
				num9 *= ((!(rotDeltaTarget > 0f)) ? (-1f) : 1f);
				rotDeltaTarget -= num9;
			}
			num9 = rotDeltaTarget * Time.deltaTime * 20f;
			rotDeltaTarget -= num9;
		}
		playerController.SetYRotation(rot + num9);
	}
}
public class RotationGrid : MonoBehaviour
{
	public float maxOpacity = 1f;

	private Material gridMaterial;

	private Color gridColor;

	private float targetOpacity;

	public float fadeInSpeed = 1f;

	public float fadeOutSpeed = 1f;

	private void Start()
	{
		gridMaterial = GetComponent<Renderer>().material;
		gridColor = gridMaterial.color;
		gridColor.a = 0f;
		gridMaterial.color = gridColor;
	}

	private void LateUpdate()
	{
		gridColor.a = Interpolate.Lerp(gridColor.a, targetOpacity, (!(targetOpacity >= 1f)) ? (Time.deltaTime * fadeOutSpeed) : (Time.deltaTime * fadeInSpeed));
		gridMaterial.color = gridColor;
		if (targetOpacity >= 0.1f && !GetComponent<Renderer>().enabled)
		{
			GetComponent<Renderer>().enabled = true;
		}
		else if (targetOpacity <= 0.1f && gridColor.a <= 0.05f && GetComponent<Renderer>().enabled)
		{
			GetComponent<Renderer>().enabled = false;
		}
	}

	public void ShowGrid()
	{
		targetOpacity = 1f;
	}
}
public class SetCameraProps : MonoBehaviour
{
	public Color background = Color.black;

	public float near = 0.15f;

	public float far = 1000f;

	private void Start()
	{
		OVRCameraRig component = base.gameObject.GetComponent<OVRCameraRig>();
		if ((bool)component)
		{
			component.leftEyeCamera.backgroundColor = background;
			component.leftEyeCamera.nearClipPlane = near;
			component.leftEyeCamera.farClipPlane = far;
			component.rightEyeCamera.backgroundColor = background;
			component.rightEyeCamera.nearClipPlane = near;
			component.rightEyeCamera.farClipPlane = far;
		}
	}
}
public class SetHandControls : MonoBehaviour
{
	public Transform leftHand;

	public Transform rightHand;

	public Transform lanternBody;

	public Transform lanternPivot;

	public Transform minimap;

	public float minimapScaleFactor = 1f;

	private Material lampMaterial;

	private bool usingHandControls;

	private void Start()
	{
		if (!InputExt.UsingHandControllers)
		{
			leftHand.gameObject.SetActive(value: false);
			rightHand.gameObject.SetActive(value: false);
		}
		else
		{
			ConfigureForHandControls();
		}
	}

	private void Update()
	{
		if (usingHandControls && lampMaterial != null)
		{
			lampMaterial.SetFloat("_Level", Player.GetTorchFuel().GetFuelLevelNormalized());
			lampMaterial.SetFloat("_EmissionIntensity", (!Player.GetTorchFuel().lightOn) ? 0.3f : 1f);
		}
		else if (InputExt.UsingHandControllers)
		{
			ConfigureForHandControls();
		}
	}

	private void ConfigureForHandControls()
	{
		usingHandControls = true;
		leftHand.gameObject.SetActive(value: true);
		rightHand.gameObject.SetActive(value: true);
		if (lanternBody != null)
		{
			lanternBody.transform.parent = base.transform;
			lampMaterial = lanternBody.GetComponent<Renderer>().materials[1];
			GameObject gameObject = GameObject.FindWithTag(Tags.PlayerTorch);
			gameObject.transform.parent = lanternBody.transform;
			gameObject.transform.localPosition = new Vector3(0f, -0.08f, 0f);
			gameObject.transform.localRotation = Quaternion.identity;
			if (InputExt.LeftHanded)
			{
				Player.GetLeftHand().lampLocked = false;
				Player.GetRightHand().lampLocked = true;
				Vector3 localPosition = lanternPivot.localPosition;
				localPosition.x = 0f - localPosition.x;
				Quaternion localRotation = lanternPivot.localRotation;
				lanternPivot.parent = rightHand;
				lanternPivot.localPosition = localPosition;
				lanternPivot.localRotation = localRotation;
			}
		}
		if (minimap != null)
		{
			Transform transform = minimap.Find("hand_anchor");
			if (transform == null)
			{
				transform = minimap;
			}
			minimap.GetComponent<MinimapPosition>().enabled = false;
			minimap.localScale *= minimapScaleFactor;
			if (InputExt.LeftHanded)
			{
				minimap.parent = leftHand;
				Vector3 localPosition2 = transform.localPosition;
				localPosition2.x = 0f - localPosition2.x;
				transform.localPosition = localPosition2;
				Vector3 eulerAngles = transform.localRotation.eulerAngles;
				transform.localRotation = Quaternion.Euler(eulerAngles.x, eulerAngles.y, (0f - eulerAngles.z) * 2f);
			}
			else
			{
				minimap.parent = rightHand;
			}
			Vector3 localPosition3 = transform.localPosition;
			localPosition3.Scale(minimap.localScale);
			minimap.localPosition = localPosition3;
			minimap.localRotation = transform.localRotation;
			MinimapHandController minimapHandController = minimap.gameObject.AddComponent<MinimapHandController>();
			minimapHandController.hand = ((!InputExt.LeftHanded) ? Player.GetRightHand() : Player.GetLeftHand());
			minimapHandController.minimapAnchor = transform;
			Material[] materials = minimap.GetComponent<Renderer>().materials;
			for (int i = 0; i < materials.Length; i++)
			{
				materials[i].renderQueue += 2020;
			}
		}
	}
}
public class SetImageEffects : MonoBehaviour
{
	public bool addSSAO = true;

	public bool addGrayscale;

	public bool addMonochromize = true;

	public bool addHighlight = true;

	public bool addOVRLensCorrection = true;

	public bool addAntiAliasing = true;

	public Material OVRLensCorrectionMaterial;

	public Material OVRLensCorrectionMaterial_CA;

	public Material OVRLensCorrectionMaterial_MeshDistort;

	public Shader ssaoShader;

	public Shader aa_SSAA;

	public Shader aa_DLAA;

	public Shader aa_NFAA;

	public Shader aa_FXAAPreset2;

	public Shader aa_FXAAPreset3;

	public Shader aa_FXAAII;

	public Shader aa_FXAAIII;

	public Shader grayscaleShader;

	public Shader monochromizeShader;

	private void Awake()
	{
		Debug.Log("SetImageEffects - Initializing");
		if (addSSAO)
		{
			AddSSAO();
		}
		if (addGrayscale)
		{
			AddGrayscale();
		}
		if (addMonochromize)
		{
			AddMonochromize();
		}
		if (addHighlight)
		{
			AddHightlight();
		}
		AddOVRLens();
		if (addAntiAliasing)
		{
			AddAA();
		}
		Debug.Log("SetImageEffects - Done");
	}

	private void AddOVRLens()
	{
	}

	private void AddSSAO()
	{
		Debug.Log("SetImageEffects - AddSSAO");
		SSAOEffect sSAOEffect = base.gameObject.AddComponent<SSAOEffect>();
		sSAOEffect.m_Radius = 0.4f;
		sSAOEffect.m_SampleCount = SSAOEffect.SSAOSamples.Medium;
		sSAOEffect.m_OcclusionIntensity = 1.5f;
		sSAOEffect.m_Blur = 2;
		sSAOEffect.m_Downsampling = 2;
		sSAOEffect.m_OcclusionAttenuation = 1f;
		sSAOEffect.m_MinZ = 0.01f;
		Debug.Log("SetImageEffects - AddSSAO done");
	}

	private void AddAA()
	{
		Debug.Log("SetImageEffects - AddAA");
		AntialiasingAsPostEffect antialiasingAsPostEffect = base.gameObject.AddComponent<AntialiasingAsPostEffect>();
		antialiasingAsPostEffect.ssaaShader = aa_SSAA;
		antialiasingAsPostEffect.dlaaShader = aa_DLAA;
		antialiasingAsPostEffect.nfaaShader = aa_NFAA;
		antialiasingAsPostEffect.shaderFXAAPreset2 = aa_FXAAPreset2;
		antialiasingAsPostEffect.shaderFXAAPreset3 = aa_FXAAPreset3;
		antialiasingAsPostEffect.shaderFXAAII = aa_FXAAII;
		antialiasingAsPostEffect.shaderFXAAIII = aa_FXAAIII;
		antialiasingAsPostEffect.mode = AAMode.FXAA1PresetA;
		Debug.Log("SetImageEffects - AddAA done");
	}

	private void AddGrayscale()
	{
		Debug.Log("SetImageEffects - AddGrayscale");
		GrayscaleEffect grayscaleEffect = base.gameObject.AddComponent<GrayscaleEffect>();
		grayscaleEffect.shader = grayscaleShader;
		Debug.Log("SetImageEffects - AddGrayscale done");
	}

	private void AddHightlight()
	{
	}

	private void AddMonochromize()
	{
		Debug.Log("SetImageEffects - AddMonochromize");
		Monochromize monochromize = base.gameObject.AddComponent<Monochromize>();
		monochromize.intensity = 0f;
		monochromize.shader = monochromizeShader;
		monochromize.enabled = false;
		Debug.Log("SetImageEffects - AddMonochromize done");
	}
}
[AddComponentMenu("Camera-Control/Smooth Mouse Look")]
public class SmoothMouseLook : MonoBehaviour
{
	public enum RotationAxes
	{
		MouseXAndY,
		MouseX,
		MouseY
	}

	public RotationAxes axes;

	public float sensitivityX = 15f;

	public float sensitivityY = 15f;

	public float minimumX = -360f;

	public float maximumX = 360f;

	public float minimumY = -60f;

	public float maximumY = 60f;

	private float rotationX;

	private float rotationY;

	private List<float> rotArrayX = new List<float>();

	private float rotAverageX;

	private List<float> rotArrayY = new List<float>();

	private float rotAverageY;

	public float frameCounter = 20f;

	private Quaternion originalRotation;

	private void Update()
	{
		if (axes == RotationAxes.MouseXAndY)
		{
			rotAverageY = 0f;
			rotAverageX = 0f;
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationX += Input.GetAxis("Mouse X") * sensitivityX;
			rotArrayY.Add(rotationY);
			rotArrayX.Add(rotationX);
			if ((float)rotArrayY.Count >= frameCounter)
			{
				rotArrayY.RemoveAt(0);
			}
			if ((float)rotArrayX.Count >= frameCounter)
			{
				rotArrayX.RemoveAt(0);
			}
			for (int i = 0; i < rotArrayY.Count; i++)
			{
				rotAverageY += rotArrayY[i];
			}
			for (int j = 0; j < rotArrayX.Count; j++)
			{
				rotAverageX += rotArrayX[j];
			}
			rotAverageY /= rotArrayY.Count;
			rotAverageX /= rotArrayX.Count;
			rotAverageY = ClampAngle(rotAverageY, minimumY, maximumY);
			rotAverageX = ClampAngle(rotAverageX, minimumX, maximumX);
			Quaternion quaternion = Quaternion.AngleAxis(rotAverageY, Vector3.left);
			Quaternion quaternion2 = Quaternion.AngleAxis(rotAverageX, Vector3.up);
			base.transform.localRotation = originalRotation * quaternion2 * quaternion;
		}
		else if (axes == RotationAxes.MouseX)
		{
			rotAverageX = 0f;
			rotationX += Input.GetAxis("Mouse X") * sensitivityX;
			rotArrayX.Add(rotationX);
			if ((float)rotArrayX.Count >= frameCounter)
			{
				rotArrayX.RemoveAt(0);
			}
			for (int k = 0; k < rotArrayX.Count; k++)
			{
				rotAverageX += rotArrayX[k];
			}
			rotAverageX /= rotArrayX.Count;
			rotAverageX = ClampAngle(rotAverageX, minimumX, maximumX);
			Quaternion quaternion3 = Quaternion.AngleAxis(rotAverageX, Vector3.up);
			base.transform.localRotation = originalRotation * quaternion3;
		}
		else
		{
			rotAverageY = 0f;
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotArrayY.Add(rotationY);
			if ((float)rotArrayY.Count >= frameCounter)
			{
				rotArrayY.RemoveAt(0);
			}
			for (int l = 0; l < rotArrayY.Count; l++)
			{
				rotAverageY += rotArrayY[l];
			}
			rotAverageY /= rotArrayY.Count;
			rotAverageY = ClampAngle(rotAverageY, minimumY, maximumY);
			Quaternion quaternion4 = Quaternion.AngleAxis(rotAverageY, Vector3.left);
			base.transform.localRotation = originalRotation * quaternion4;
		}
	}

	private void Start()
	{
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
		originalRotation = base.transform.localRotation;
	}

	public static float ClampAngle(float angle, float min, float max)
	{
		angle %= 360f;
		if (angle >= -360f && angle <= 360f)
		{
			if (angle < -360f)
			{
				angle += 360f;
			}
			if (angle > 360f)
			{
				angle -= 360f;
			}
		}
		return Mathf.Clamp(angle, min, max);
	}
}
[RequireComponent(typeof(AudioSource))]
public class SpookSounds : MonoBehaviour
{
	private static SpookSounds instance;

	public AudioClip[] naturalSounds;

	public AudioClip[] ghostSounds;

	public AudioClip[] ghostWhisperSounds;

	public AudioClip[] monsterSounds;

	public float naturalWeight = 1f;

	public float ghostWeight = 0.5f;

	public float ghostWhispersWeight = 0.2f;

	public float monsterWeight = 0.5f;

	public AudioClip[] Scares;

	public AudioClip[] IntenseScares;

	public float SilenceProbability = 0.3f;

	public float ShortWaitMin = 4f;

	public float ShortWaitMax = 8f;

	public float MediumWaitMin = 8f;

	public float MediumWaitMax = 16f;

	public float LongWaitMin = 20f;

	public float LongWaitMax = 40f;

	public float MinDistance = 5f;

	public float MaxDistance = 20f;

	public float ScareCooldown = 30f;

	public float ScareIntenseCooldown = 8f;

	public AudioClip[] DeepSounds;

	public float deepWaitMin = 40f;

	public float deepWaitMax = 180f;

	public bool forceShadowSounds;

	private float LastWait;

	private float LastScare;

	private float LastScareIntense;

	public static SpookSounds Get()
	{
		return instance;
	}

	private void Awake()
	{
		instance = this;
	}

	private void Start()
	{
		StartCoroutine(PlaySpookSound());
		StartCoroutine(PlayDeepSounds());
	}

	private void Update()
	{
		if (LastScare > 0f)
		{
			LastScare -= Time.deltaTime;
		}
		if (LastScareIntense > 0f)
		{
			LastScareIntense -= Time.deltaTime;
		}
	}

	private IEnumerator PlaySpookSound()
	{
		bool bFirstTime = true;
		while (true)
		{
			float fType = UnityEngine.Random.value;
			float nextWait = ((fType < 0.2f) ? UnityEngine.Random.Range(ShortWaitMin, ShortWaitMax) : ((!(fType <= 0.6f)) ? UnityEngine.Random.Range(LongWaitMin, LongWaitMax) : UnityEngine.Random.Range(MediumWaitMin, MediumWaitMax)));
			if (UnityEngine.Random.value < SilenceProbability)
			{
				nextWait = Mathf.Min(nextWait, LastWait / 2f);
			}
			else if (!bFirstTime)
			{
				LevelOptions levelOptions = GameController.Get().levelOptions;
				_ = naturalSounds;
				float num = naturalWeight;
				float num2 = 0.2f * ghostWeight;
				if (levelOptions.shadowWatchers || levelOptions.ghostVisions || levelOptions.ghosts || levelOptions.shadowChasers || levelOptions.shadowChasersVisions)
				{
					num2 = 0.5f * ghostWeight;
					if (levelOptions.ghosts || levelOptions.shadowChasers)
					{
						num2 = ghostWeight;
					}
				}
				if (forceShadowSounds)
				{
					num2 = ghostWeight * 2f;
				}
				float num3 = 0.2f * monsterWeight;
				if (levelOptions.maxFloaters > 0 || levelOptions.maxLightEaters > 0 || levelOptions.maxProwlers > 0)
				{
					num3 = 0.5f * monsterWeight;
					if (levelOptions.maxLightEaters > 0 || levelOptions.maxProwlers > 0)
					{
						num3 = monsterWeight;
					}
				}
				bool flag = false;
				float num4 = num + num2 + num3;
				num /= num4;
				num2 /= num4;
				_ = num3 / num4;
				float value = UnityEngine.Random.value;
				AudioClip[] array;
				if (value <= num)
				{
					array = naturalSounds;
				}
				else if (value <= num + num2)
				{
					if (UnityEngine.Random.value <= ghostWhispersWeight)
					{
						array = ghostWhisperSounds;
						flag = true;
					}
					else
					{
						array = ghostSounds;
					}
				}
				else
				{
					array = monsterSounds;
				}
				AudioClip clip = array[UnityEngine.Random.Range(0, array.Length)];
				Vector2 insideUnitCircle = UnityEngine.Random.insideUnitCircle;
				insideUnitCircle *= UnityEngine.Random.Range(MinDistance, MaxDistance);
				Vector3 position = base.transform.position + new Vector3(insideUnitCircle.x, 0f, insideUnitCircle.y);
				if (!flag)
				{
					AudioSource.PlayClipAtPoint(clip, position);
				}
				else
				{
					AudioSource.PlayClipAtPoint(clip, Player.GetLook().position);
				}
			}
			LastWait = nextWait;
			bFirstTime = false;
			yield return new WaitForSeconds(nextWait);
		}
	}

	private IEnumerator PlayDeepSounds()
	{
		while (true)
		{
			float nextWait = UnityEngine.Random.Range(deepWaitMin, deepWaitMax);
			yield return new WaitForSeconds(nextWait);
			LevelOptions lOptions = GameController.Get().levelOptions;
			Room curRoom = Map.Get().At(Player.Pos).Room;
			if (!lOptions.safeMap && (curRoom == null || !curRoom.Safe))
			{
				AudioClip clip = DeepSounds[UnityEngine.Random.Range(0, DeepSounds.Length)];
				Vector3 insideUnitSphere = UnityEngine.Random.insideUnitSphere;
				insideUnitSphere *= UnityEngine.Random.Range(40f, 100f);
				Vector3 pos = base.transform.position + insideUnitSphere;
				Utils.PlayClipAt(clip, pos, 70f, 100f);
			}
		}
	}

	public void PlayDeepPitSound()
	{
		Vector3 pos = Player.GetPos();
		Vector3 down = Vector3.down;
		down *= 20f;
		Vector3 pos2 = pos + down;
		AudioClip clip = DeepSounds[UnityEngine.Random.Range(0, DeepSounds.Length)];
		Utils.PlayClipAt(clip, pos2, 70f, 100f);
	}

	public void PlayScare(bool intense = false)
	{
		if (LastScare <= 0f || (intense && LastScareIntense <= 0f))
		{
			LastScare = ScareCooldown;
			AudioClip clip;
			if (!intense)
			{
				clip = Scares[UnityEngine.Random.Range(0, Scares.Length)];
			}
			else
			{
				clip = IntenseScares[UnityEngine.Random.Range(0, IntenseScares.Length)];
				LastScareIntense = ScareIntenseCooldown;
			}
			AudioSource.PlayClipAtPoint(clip, base.transform.position);
		}
		FearEffect.Get().Scare(jumpScare: true);
	}
}
public class StepSounds : MonoBehaviour
{
	[Serializable]
	public class StepTypeCollection
	{
		public string name;

		public AudioClip[] sounds;
	}

	public StepTypeCollection[] soundsList;

	private Dictionary<string, AudioClip[]> soundsDict;

	private AudioClip[] curSounds;

	private int SoundIndex;

	private int FootIndex;

	public float SoundInterval = 50f;

	private float MovementSpeed;

	private Vector3 lastPosition;

	private float soundDistance;

	private Point lastCell;

	private void Start()
	{
		soundsDict = new Dictionary<string, AudioClip[]>();
		for (int i = 0; i < soundsList.Length; i++)
		{
			soundsDict[soundsList[i].name] = soundsList[i].sounds;
		}
		curSounds = soundsDict["default"];
		lastPosition = base.transform.position;
		soundDistance = SoundInterval;
		lastCell = Map.Get().WorldToCell(lastPosition);
	}

	private void Update()
	{
		Point point = Map.Get().WorldToCell(base.transform.position);
		if (point != lastCell)
		{
			lastCell = point;
			SetGroundType(Map.Get().Tags.GetStyle(Map.Get().mapStyles, point).floorStepSound);
		}
		if (curSounds.Length < 2)
		{
			return;
		}
		Vector3 position = base.transform.position;
		MovementSpeed = (position - lastPosition).ToGround().magnitude / (1f / 60f);
		lastPosition = position;
		if (MovementSpeed == 0f)
		{
			soundDistance = SoundInterval;
			return;
		}
		soundDistance -= MovementSpeed;
		if (soundDistance <= 0f)
		{
			soundDistance = SoundInterval;
			Vector3 vector = base.transform.position + base.transform.right * 0.1f * ((FootIndex++ % 2 == 0) ? 1 : (-1));
			int soundIndex = SoundIndex;
			do
			{
				SoundIndex = UnityEngine.Random.Range(0, curSounds.Length);
			}
			while (SoundIndex == soundIndex);
			GetComponent<AudioSource>().Stop();
			GetComponent<AudioSource>().clip = curSounds[SoundIndex];
			GetComponent<AudioSource>().Play();
		}
	}

	public void SetGroundType(string gtype)
	{
		if (!soundsDict.TryGetValue(gtype, out curSounds))
		{
			curSounds = soundsDict["default"];
		}
	}
}
public class TextLabel : TimeIndependentBehaviour
{
	[Serializable]
	public class SubstituteFont
	{
		public string language;

		public Font font;

		public Material fontMaterial;

		public int fontSize;
	}

	public string InitText;

	private string _Text;

	public GUIStyle Style;

	public bool wordWrap;

	public float wrapLimit = 1.9f;

	public bool AnimateOpen;

	private float fTargetWidth;

	private bool AnimationStarted;

	private RenderTexture LabelRenderTexture;

	private TextMesh textMesh;

	private Renderer backgroundRenderer;

	public float backgroundHeightFactor = 2.692998f;

	private Vector3 backgroundStartScale;

	private bool IsUpdated;

	private bool fading;

	private float targetFade = 1f;

	private float fadeSpeed = 4f;

	private bool disableOnFadeOut;

	private bool destroyOnFadeOut;

	public Color textColor = Color.white;

	private Color tempTextColor;

	private Color[] tempMatColors;

	private bool isDarkened;

	public bool noDarken;

	public SubstituteFont[] substituteFonts;

	public string Text
	{
		get
		{
			return _Text;
		}
		set
		{
			_Text = value;
			IsUpdated = false;
			if (wordWrap)
			{
				_Text = WordWrap(_Text);
			}
			int num = GetComponent<Renderer>().materials.Length;
			if (num > 1)
			{
				textMesh.text = "<material=" + (num - 1) + ">" + _Text + "</material>";
			}
			else
			{
				textMesh.text = _Text;
			}
		}
	}

	private new void Awake()
	{
		base.Awake();
		textMesh = GetComponent<TextMesh>();
		if (substituteFonts != null)
		{
			SubstituteFont substituteFont = null;
			for (int i = 0; i < substituteFonts.Length; i++)
			{
				if (substituteFont != null)
				{
					break;
				}
				if (substituteFonts[i].language == Translate.GetLanguage())
				{
					substituteFont = substituteFonts[i];
				}
			}
			if (substituteFont != null)
			{
				textMesh.font = substituteFont.font;
				textMesh.fontSize = substituteFont.fontSize;
				Renderer component = GetComponent<Renderer>();
				Material[] array = new Material[component.materials.Length];
				for (int j = 0; j < component.materials.Length; j++)
				{
					array[j] = component.materials[j];
				}
				array[array.Length - 1] = substituteFont.fontMaterial;
				component.materials = array;
			}
		}
		Transform transform = base.transform.Find("background");
		if (transform != null)
		{
			backgroundRenderer = transform.GetComponent<Renderer>();
			backgroundRenderer.enabled = false;
			backgroundStartScale = backgroundRenderer.transform.localScale;
		}
		IsUpdated = false;
		Text = InitText;
		AnimationStarted = false;
		if (AnimateOpen)
		{
			GetComponent<Renderer>().enabled = false;
		}
		targetFade = 1f;
		disableOnFadeOut = false;
		destroyOnFadeOut = false;
		if (textMesh != null)
		{
			textMesh.color = new Color(textMesh.color.r, textMesh.color.g, textMesh.color.b, 0f);
		}
		if (backgroundRenderer != null)
		{
			backgroundRenderer.material.color = new Color(1f, 1f, 1f, 0f);
		}
	}

	private new void Update()
	{
		base.Update();
		if (isDarkened)
		{
			return;
		}
		if (AnimateOpen)
		{
			if (!AnimationStarted && IsUpdated)
			{
				AnimationStarted = true;
				Vector3 localScale = base.transform.localScale;
				localScale.x = 0.0001f;
				base.transform.localScale = localScale;
				GetComponent<Renderer>().enabled = true;
				if (backgroundRenderer != null)
				{
					backgroundRenderer.enabled = true;
				}
			}
			else if (AnimationStarted)
			{
				float num = fTargetWidth - base.transform.localScale.x;
				Vector3 localScale2 = base.transform.localScale;
				localScale2.x += num * 5f * base.deltaTime;
				base.transform.localScale = localScale2;
			}
		}
		if (!fading && !isDarkened)
		{
			textMesh.color = new Color(textColor.r, textColor.g, textColor.b, (!IsUpdated) ? 0f : 1f);
		}
		if (GetComponent<Renderer>().enabled && fading)
		{
			float num2 = Mathf.Lerp(textMesh.color.a, targetFade, base.deltaTime * fadeSpeed);
			textMesh.color = new Color(textColor.r, textColor.g, textColor.b, num2);
			if (GetComponent<Renderer>().materials.Length >= 2)
			{
				for (int i = 0; i < GetComponent<Renderer>().materials.Length; i++)
				{
					GetComponent<Renderer>().materials[i].color = new Color(textColor.r, textColor.g, textColor.b, num2);
				}
			}
			if (backgroundRenderer != null)
			{
				backgroundRenderer.material.color = textMesh.color;
			}
			if (targetFade <= 0f && num2 <= 0.26f)
			{
				GetComponent<Renderer>().enabled = false;
				if (backgroundRenderer != null)
				{
					backgroundRenderer.enabled = false;
				}
				if (disableOnFadeOut)
				{
					base.gameObject.SetActive(value: false);
				}
				if (destroyOnFadeOut)
				{
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
		}
		if (!IsUpdated)
		{
			if (backgroundRenderer != null)
			{
				Vector3 vector = GetComponent<Renderer>().bounds.extents * 2f;
				float num3 = Mathf.Sqrt(vector.x * vector.x + vector.z * vector.z);
				float y = vector.y;
				Vector3 localScale3 = backgroundStartScale;
				localScale3.y = y * backgroundHeightFactor;
				backgroundRenderer.transform.localScale = localScale3;
			}
			IsUpdated = true;
		}
	}

	public void Close()
	{
		if (AnimateOpen)
		{
			fTargetWidth = 0f;
			UnityEngine.Object.Destroy(base.gameObject, 1f);
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	public void FadeIn(float fadeSpeed = 4f)
	{
		textMesh.color = new Color(1f, 1f, 1f, 0f);
		targetFade = 1f;
		this.fadeSpeed = fadeSpeed;
		GetComponent<Renderer>().enabled = true;
		if (backgroundRenderer != null)
		{
			backgroundRenderer.enabled = true;
			backgroundRenderer.material.color = textMesh.color;
		}
		if (GetComponent<Renderer>().materials.Length >= 2)
		{
			for (int i = 0; i < GetComponent<Renderer>().materials.Length; i++)
			{
				GetComponent<Renderer>().materials[i].color = new Color(1f, 1f, 1f, 0f);
			}
		}
		disableOnFadeOut = false;
		destroyOnFadeOut = false;
		fading = true;
	}

	public void FadeOut(float fadeSpeed = 4f, bool disableOnFadeOut = false, bool destroyOnFadeOut = false)
	{
		targetFade = 0f;
		this.fadeSpeed = fadeSpeed;
		this.disableOnFadeOut = disableOnFadeOut;
		this.destroyOnFadeOut = destroyOnFadeOut;
		fading = true;
	}

	public void FadeInDelayed(float fadeSpeed = 4f, float delay = 1f)
	{
		textMesh.color = new Color(1f, 1f, 1f, 0f);
		GetComponent<Renderer>().enabled = false;
		if (backgroundRenderer != null)
		{
			backgroundRenderer.enabled = true;
			backgroundRenderer.material.color = textMesh.color;
		}
		fading = false;
		StartCoroutine(FadeInDelayed_co(fadeSpeed, delay));
	}

	private IEnumerator FadeInDelayed_co(float fadeSpeed = 4f, float delay = 1f)
	{
		yield return new WaitForSeconds(delay);
		if (!fading)
		{
			FadeIn(fadeSpeed);
		}
	}

	public void ShowText(string text)
	{
		Text = text;
		GetComponent<Renderer>().enabled = true;
		if (backgroundRenderer != null)
		{
			backgroundRenderer.enabled = true;
			Color color = textMesh.color;
			color.a = 1f;
			backgroundRenderer.material.color = color;
		}
	}

	public void HideText()
	{
		GetComponent<Renderer>().enabled = false;
		if (backgroundRenderer != null)
		{
			backgroundRenderer.enabled = false;
		}
	}

	private string WordWrap(string sourceStr)
	{
		return Utils.WordWrap(sourceStr, textMesh, wrapLimit);
	}

	public void SetDarkened(bool darken)
	{
		if (noDarken)
		{
			return;
		}
		if (!isDarkened && darken)
		{
			tempTextColor = textColor;
			textColor.a = 0f;
			isDarkened = darken;
			textMesh.color = textColor;
			Renderer component = GetComponent<Renderer>();
			int num = component.materials.Length;
			tempMatColors = new Color[num];
			for (int i = 0; i < num; i++)
			{
				ref Color reference = ref tempMatColors[i];
				reference = component.materials[i].color;
				component.materials[i].color = component.materials[i].color.WithAlpha(0f);
			}
		}
		else if (isDarkened && !darken)
		{
			textColor = tempTextColor;
			isDarkened = darken;
			textMesh.color = textColor;
			Renderer component2 = GetComponent<Renderer>();
			int num2 = component2.materials.Length;
			for (int j = 0; j < num2; j++)
			{
				component2.materials[j].color = tempMatColors[j];
			}
		}
	}
}
public class TiltPeek : MonoBehaviour
{
	public Transform LookDir;

	public float PeekDistance = 0.1f;

	public float MinAngle = 8f;

	public float MaxAngle = 45f;

	private Vector3 StartNeckPos;

	private OVRCameraRig[] CameraController;

	private void Start()
	{
		CameraController = base.transform.GetComponents<OVRCameraRig>();
		StartNeckPos = CameraController[0].trackerAnchor.position;
	}

	private void Update()
	{
		float value = Vector3.Angle(LookDir.right, base.transform.right);
		Vector3 lhs = Vector3.Cross(LookDir.right, base.transform.right);
		bool flag = Vector3.Dot(lhs, base.transform.forward) > 0f;
		float t = (Mathf.Clamp(value, MinAngle, MaxAngle) - MinAngle) / (MaxAngle - MinAngle);
		float num = Mathf.Lerp(0f, PeekDistance, t) * ((!flag) ? (-1f) : 1f);
		for (int i = 0; i < CameraController.Length; i++)
		{
			CameraController[0].trackerAnchor.position = StartNeckPos + base.transform.right * num;
		}
	}

	public void SetToStart()
	{
		for (int i = 0; i < CameraController.Length; i++)
		{
			CameraController[0].trackerAnchor.position = StartNeckPos;
		}
	}
}
[RequireComponent(typeof(TorchLight))]
public class TorchFuel : MonoBehaviour
{
	private TorchLight torch;

	public bool lightOn = true;

	public float Fuel = 1f;

	public float FuelConsumption = 0.01f;

	public float NormalIntensity = 1f;

	public float LowIntensity = 0.3f;

	public float LowRangeFactor = 0.375f;

	public float HighBurnIntensity = 2f;

	public float LightSpeed = 0.5f;

	public float LightToggleSpeed = 4f;

	public float LightBurnSpeed = 2f;

	public float LightBurnTime = 0.3f;

	public float BurnFuelConsumptionRate = 4f;

	private float lightCurSpeed;

	private float lightBtnTime;

	public bool burning;

	public bool btnEnabled = true;

	public AudioClip FuelSound;

	public AudioClip OnSound;

	public AudioClip OffSound;

	private AudioSource burningSound;

	private void Start()
	{
		torch = GetComponent<TorchLight>();
		lightOn = true;
		lightCurSpeed = LightSpeed;
		lightBtnTime = 0f;
		burning = false;
		burningSound = GetComponent<AudioSource>();
		Fuel = GameState.Get().fuel;
	}

	private void Update()
	{
		float fuel = Fuel;
		if (lightOn)
		{
			Fuel -= ((!burning) ? 1f : BurnFuelConsumptionRate) * FuelConsumption * Time.deltaTime;
		}
		float b = ((!lightOn) ? LowIntensity : ((!burning) ? NormalIntensity : HighBurnIntensity));
		float b2 = ((!lightOn) ? LowRangeFactor : 1f);
		if (lightOn && Fuel <= 0f)
		{
			b = LowIntensity;
			b2 = LowRangeFactor;
			Fuel = 0f;
			burning = false;
			torch.StopFlickerOil();
		}
		else if (lightOn && ((fuel >= 0.15f && Fuel < 0.15f) || (fuel >= 0.1f && Fuel < 0.1f) || (fuel >= 0.06f && Fuel < 0.06f) || (fuel >= 0.03f && Fuel < 0.03f)))
		{
			torch.FlickerOil();
		}
		torch.factor = Mathf.Lerp(torch.factor, b, Time.deltaTime * lightCurSpeed);
		torch.rangeFactor = Mathf.Lerp(torch.rangeFactor, b2, Time.deltaTime * lightCurSpeed);
		if (lightOn && !burning && torch.factor >= NormalIntensity - 0.01f && torch.factor <= NormalIntensity + 0.5f)
		{
			lightCurSpeed = LightSpeed;
		}
		else if (lightOn && burning)
		{
			lightCurSpeed = LightBurnSpeed;
		}
		else if (!lightOn && torch.factor <= LowIntensity + 0.01f)
		{
			lightCurSpeed = LightSpeed;
		}
		if (btnEnabled && InputExt.GetButtonDown(InputExt.Button.Light))
		{
			ToggleLight();
		}
		UpdateBurningSound();
	}

	public void ToggleLight()
	{
		if (lightOn)
		{
			lightOn = false;
			lightCurSpeed = LightToggleSpeed;
			AudioSource.PlayClipAtPoint(OffSound, base.transform.position);
			if (Config.General().tutorials && !Tutorial.HasBeenShownBefore("TUTO_LIGHT_REENABLE", add: true))
			{
				Tutorial.Get().ShowTextForTime(Translate.GetForInput("TUTO_LIGHT_REENABLE"), 4f);
			}
		}
		else if (Fuel > 0f)
		{
			lightOn = !lightOn;
			lightCurSpeed = LightToggleSpeed;
			AudioSource.PlayClipAtPoint(OnSound, base.transform.position);
		}
	}

	private void UpdateBurningSound()
	{
		if (burning)
		{
			if (!burningSound.isPlaying)
			{
				burningSound.volume = 0f;
				burningSound.Play();
			}
			burningSound.volume = Mathf.Lerp(burningSound.volume, 1f, Time.deltaTime * 4f);
		}
		else
		{
			burningSound.volume = Mathf.Lerp(burningSound.volume, 0f, Time.deltaTime * 2f);
			if (burningSound.volume <= 0.1f)
			{
				burningSound.Stop();
			}
		}
	}

	public void AddFuel(float fuel = 1f)
	{
		Fuel += fuel;
		torch.factor = HighBurnIntensity;
		torch.StopFlickerOil(endFlicker: true);
		AudioSource.PlayClipAtPoint(FuelSound, base.transform.position);
		if (!lightOn)
		{
			lightOn = true;
			lightCurSpeed = LightSpeed;
		}
	}

	public bool RemoveFuel(float fuel = 1f, bool removeOnlyIfEnough = false)
	{
		bool flag = Fuel >= fuel;
		if (flag || !removeOnlyIfEnough)
		{
			Fuel -= fuel;
			if (Fuel <= 0f)
			{
				Fuel = 0f;
			}
		}
		return flag;
	}

	private void OnLightTurnOff(TorchLight tlight)
	{
		lightOn = false;
		lightCurSpeed = LightToggleSpeed;
		lightBtnTime = 0f;
		burning = false;
	}

	public float GetFuelLevelNormalized()
	{
		return Mathf.Clamp01(Fuel / 1.3f);
	}

	public string GetDescriptionText()
	{
		string text = Translate.Get("INV_LAMP_0");
		if (lightOn)
		{
			if (GameController.Get().gameState.lampDescriptions > 0)
			{
				GameController.Get().gameState.lampDescriptions--;
			}
			else if (UnityEngine.Random.value > 0.4f)
			{
				int num = UnityEngine.Random.Range(1, 16);
				string key = "INV_LAMP_" + num;
				text = Translate.Get(key);
			}
		}
		float fuelLevelNormalized = GetFuelLevelNormalized();
		string empty = string.Empty;
		empty = ((fuelLevelNormalized <= 0f) ? Translate.Get("INV_LAMP_LEVEL_0") : ((fuelLevelNormalized <= 0.2f) ? Translate.Get("INV_LAMP_LEVEL_1") : ((fuelLevelNormalized <= 0.6f) ? Translate.Get("INV_LAMP_LEVEL_2") : ((!(fuelLevelNormalized <= 0.9f)) ? Translate.Get("INV_LAMP_LEVEL_4") : Translate.Get("INV_LAMP_LEVEL_3")))));
		return text + "\n" + empty;
	}

	public bool IsLightOn()
	{
		return lightOn && Fuel > 0f;
	}
}
public class TutoLockArrows : TimeIndependentBehaviour
{
	public float rotSpeed = 1f;

	public float rotAmount = 60f;

	public float flipflopTime = 1f;

	public AnimationCurve scaleCurve;

	public float scaleSpeed = 1f;

	private float timer;

	private Quaternion rotTarget;

	private float scaleFactor;

	private void Start()
	{
		base.transform.localScale = Vector3.zero;
	}

	private new void Update()
	{
		base.Update();
		timer -= base.deltaTime;
		if (timer <= 0f)
		{
			base.transform.Rotate(0f, 180f, 0f);
			rotTarget = Quaternion.Euler(base.transform.localRotation.eulerAngles + new Vector3(0f, 0f, rotAmount));
			timer = flipflopTime;
		}
		base.transform.localRotation = Quaternion.Lerp(base.transform.localRotation, rotTarget, base.deltaTime * rotSpeed);
		scaleFactor = Mathf.Clamp01(scaleFactor + base.deltaTime * scaleSpeed);
		if (GameController.Get().Paused)
		{
			scaleFactor = 0f;
		}
		float num = scaleCurve.Evaluate(scaleFactor);
		base.transform.localScale = Vector3.one * num;
	}
}
public class Tutorial : MonoBehaviour
{
	[Serializable]
	public class TutorialState
	{
		public string versionCode;

		public List<string> tutorialStrings;

		public bool tutorialCollect;

		public TutorialState()
		{
			Reset();
		}

		public void Reset()
		{
			versionCode = GlobalParams.tutorialStateVersion;
			tutorialStrings = new List<string>();
			tutorialCollect = false;
		}

		public static TutorialState Load(string stateName = "Tutorials_00")
		{
			TutorialState defaultValue = new TutorialState();
			defaultValue = Serializer.DeserializeObject(stateName, defaultValue);
			if (defaultValue.versionCode == GlobalParams.tutorialStateVersion)
			{
				return defaultValue;
			}
			return null;
		}

		public void Save(string gameName = "Tutorials_00")
		{
			Serializer.SerializeObject(this, gameName);
		}
	}

	private static Tutorial instance;

	private TextLabel TLabel;

	private static bool ShowTutorialOil = true;

	private static bool ShowTutorialLight = true;

	public bool showDemoText;

	public TextLabel inPlacePrefab;

	public TutorialState tutoState;

	private bool forceTutorialOil;

	public static Tutorial Get()
	{
		return instance;
	}

	private void Start()
	{
		instance = this;
		TLabel = GetComponent<TextLabel>();
		tutoState = TutorialState.Load();
		if (tutoState == null)
		{
			tutoState = new TutorialState();
		}
		if (ShowTutorialOil)
		{
			StartCoroutine(DoTutorialOil_co());
		}
		if (GameController.Get().levelOptions.isDemo)
		{
			ShowTutorialLight = false;
			showDemoText = true;
		}
		string startText = GameController.Get().levelOptions.GetStartText();
		if (startText != string.Empty && Config.General().tutorials)
		{
			ShowTextForTime(startText, 6f);
		}
	}

	private IEnumerator DoTutorialOil_co()
	{
		TorchFuel playerTorch = GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchFuel>();
		if (showDemoText)
		{
			yield return new WaitForSeconds(4f);
			ShowTutorialText(Translate.Get("TUTO_DEMO"));
			yield return new WaitForSeconds(4f);
			HideTutorialText();
		}
		while (playerTorch.Fuel > 0f && !forceTutorialOil)
		{
			yield return new WaitForSeconds(1f);
		}
		Inventory inventory = GameObject.FindWithTag(Tags.Inventory).GetComponent<Inventory>();
		while (inventory.NumItems[0] <= 0)
		{
			yield return new WaitForSeconds(1f);
		}
		if ((playerTorch.Fuel <= 0f || forceTutorialOil) && inventory.NumItems[0] > 0)
		{
			ShowTutorialText(Translate.GetForInput("TUTO_OIL_1"));
		}
		float curOil = playerTorch.Fuel;
		float fTime2 = Time.time;
		while ((playerTorch.Fuel <= curOil || forceTutorialOil) && Time.time - fTime2 < 4f)
		{
			yield return new WaitForEndOfFrame();
		}
		if (playerTorch.Fuel <= curOil && inventory.NumItems[0] > 0)
		{
			ShowTutorialText(Translate.GetForInput("TUTO_OIL_2"));
		}
		fTime2 = Time.time;
		while (playerTorch.Fuel <= curOil && Time.time - fTime2 < 20f)
		{
			yield return new WaitForEndOfFrame();
		}
		HideTutorialText();
		ShowTutorialOil = false;
	}

	public void ForceTutorialOil()
	{
		forceTutorialOil = true;
	}

	public void DoTutorialLight()
	{
		if (ShowTutorialLight)
		{
			StartCoroutine(DoTutorialLight_co());
		}
	}

	private IEnumerator DoTutorialLight_co()
	{
		TorchFuel playerTorch = GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchFuel>();
		if (playerTorch.lightOn)
		{
			ShowTutorialText(Translate.GetForInput("TUTO_LIGHT_1"));
		}
		ShowTutorialLight = false;
		float fTime = Time.time;
		while (playerTorch.lightOn && Time.time - fTime < 8f)
		{
			yield return new WaitForEndOfFrame();
		}
		HideTutorialText();
	}

	public void ShowTextForTime(string text, float time)
	{
		StopCoroutine("ShowTextForTime_co");
		StartCoroutine(ShowTextForTime_co(text, time));
	}

	private IEnumerator ShowTextForTime_co(string text, float time)
	{
		TLabel.ShowText(text);
		yield return new WaitForSeconds(time);
		HideTutorialText();
	}

	private void ShowTutorialText(string text)
	{
		if (Config.General().tutorials)
		{
			TLabel.ShowText(text);
		}
	}

	private void HideTutorialText()
	{
		TLabel.HideText();
	}

	public static bool HasBeenShownBefore(string textCode, bool add)
	{
		if (!Config.General().tutorials)
		{
			return true;
		}
		GameState gameState = GameController.Get().gameState;
		if (Get().tutoState.tutorialStrings.Contains(textCode))
		{
			return true;
		}
		if (add)
		{
			Get().tutoState.tutorialStrings.Add(textCode);
		}
		return false;
	}

	public static TextLabel ShowInPlace(string textCode, Vector3 localPos, Quaternion localRot, Transform parent = null, float fadeSpeed = 4f, bool facePlayer = false)
	{
		if (!Config.General().tutorials || HasBeenShownBefore(textCode, add: true))
		{
			return null;
		}
		string forInput = Translate.GetForInput(textCode);
		TextLabel textLabel = UnityEngine.Object.Instantiate(Get().inPlacePrefab);
		if ((bool)parent)
		{
			textLabel.transform.parent = parent;
		}
		textLabel.transform.localPosition = localPos;
		textLabel.transform.localRotation = localRot;
		textLabel.Text = forInput;
		textLabel.FadeIn(fadeSpeed);
		if (facePlayer)
		{
			LookAtTarget lookAtTarget = textLabel.gameObject.AddComponent<LookAtTarget>();
			lookAtTarget.target = Player.GetLook();
			lookAtTarget.inverted = true;
			lookAtTarget.maxAngle = 40f;
		}
		return textLabel;
	}

	public static void ResetAndSave(string stateName = "Tutorials_00")
	{
		TutorialState tutorialState = new TutorialState();
		tutorialState.Reset();
		tutorialState.Save(stateName);
	}

	public void Save(string stateName = "Tutorials_00")
	{
		tutoState.Save(stateName);
	}
}
public class RandomSounds : MonoBehaviour
{
	public AudioClip[] Sounds;

	public float IntervalMin = 8f;

	public float IntervalMax = 40f;

	public float MinDistance = 0.8f;

	public float MaxDistance = 16f;

	public float Spread;

	public bool Playing = true;

	public bool PlayInmediate;

	public bool muteSoundsIfFar;

	public float highDistance;

	public float highDistanceChance;

	private void Start()
	{
		StartCoroutine(PlaySound());
	}

	public void PlayNow()
	{
		AudioClip clip = Sounds[UnityEngine.Random.Range(0, Sounds.Length)];
		float maxDistance = MaxDistance;
		if (highDistanceChance >= 0.05f)
		{
			float value = UnityEngine.Random.value;
			if (value <= highDistanceChance)
			{
				maxDistance = highDistance;
			}
		}
		Utils.PlayClipAt(clip, base.transform.position, MinDistance, maxDistance, Spread);
	}

	private IEnumerator PlaySound()
	{
		bool playFirst = PlayInmediate;
		while (true)
		{
			float nextSound = UnityEngine.Random.Range(IntervalMin, IntervalMax);
			if (!playFirst)
			{
				yield return new WaitForSeconds(nextSound);
			}
			playFirst = false;
			if (Playing)
			{
				PlayNow();
			}
		}
	}
}
public class Recenterer : MonoBehaviour
{
	private static Recenterer instance;

	public bool recenterOnLoad;

	public bool recenterOnFirstFrame;

	private bool firstUpdate = true;

	public static Recenterer Get()
	{
		return instance;
	}

	public static void Clear()
	{
		instance = null;
	}

	private void Awake()
	{
		instance = this;
	}

	private void Start()
	{
		if (recenterOnLoad)
		{
			Recenter();
		}
	}

	private void Update()
	{
		if (firstUpdate)
		{
			firstUpdate = false;
			if (recenterOnFirstFrame)
			{
				Recenter();
			}
		}
	}

	public void Recenter()
	{
	}
}
public class Screenshot : MonoBehaviour
{
	public string folder = "%TEMP%\\";

	public int supersize = 1;

	private int iNumber;

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.P))
		{
			Debug.Log("Imprimiendo screenshot en: \"" + folder + "Screenshot" + iNumber + ".png\"");
			ScreenCapture.CaptureScreenshot(folder + "Screenshot" + iNumber + ".png", supersize);
			iNumber++;
		}
	}
}
public class Intro : MonoBehaviour
{
	public Renderer[] IntroGamepad;

	public Renderer[] IntroKeyboard;

	public float FadeInSpeed = 0.6f;

	public float FadeOutSpeed = 0.6f;

	private bool CanContinue;

	private void Start()
	{
		Renderer[] introSeq = ((!GameController.Get().UsingGamepad) ? IntroKeyboard : IntroGamepad);
		CanContinue = false;
		StartCoroutine(IntroSequence(introSeq));
	}

	private IEnumerator IntroSequence(Renderer[] introSeq)
	{
		CanContinue = true;
		yield return new WaitForSeconds(3f);
		StartCoroutine(FadeIn(introSeq[0]));
		yield return new WaitForSeconds(6f);
		StartCoroutine(FadeOut(introSeq[0]));
		StartCoroutine(FadeIn(introSeq[1]));
		yield return new WaitForSeconds(4f);
		StartCoroutine(FadeIn(introSeq[2]));
	}

	private IEnumerator IntroSequenceDev(Renderer[] introSeq)
	{
		CanContinue = true;
		yield return new WaitForSeconds(3f);
		StartCoroutine(FadeIn(introSeq[0]));
		yield return new WaitForSeconds(6f);
		StartCoroutine(FadeOut(introSeq[0]));
		StartCoroutine(FadeIn(introSeq[1]));
	}

	private IEnumerator FadeIn(Renderer renderer)
	{
		while (renderer.material.color.a < 1f)
		{
			Color c = renderer.material.color;
			c.a = Mathf.Clamp(c.a + FadeInSpeed * Time.deltaTime, 0f, 1f);
			renderer.material.color = c;
			yield return new WaitForEndOfFrame();
		}
	}

	private IEnumerator FadeOut(Renderer renderer)
	{
		while (renderer.material.color.a > 0f)
		{
			Color c = renderer.material.color;
			c.a = Mathf.Clamp(c.a - FadeOutSpeed * Time.deltaTime, 0f, 1f);
			renderer.material.color = c;
			yield return new WaitForEndOfFrame();
		}
	}

	private void Update()
	{
		if (CanContinue && (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction)))
		{
			CanContinue = false;
			Fader component = GameObject.Find("Fader").GetComponent<Fader>();
			component.FadeOut(1f, fadeAudio: true, base.gameObject);
		}
	}

	public void OnEndFade(Fader fader)
	{
		AudioListener.volume = Config.Audio().masterVolume;
		Debug.Log("Loading level: Dungeon");
		Loader.LoadLevel("Dungeon");
	}
}
public class Outro : MonoBehaviour
{
	public TextLabel CreditsLabel1;

	public TextLabel CreditsLabel2;

	public float FadeInSpeed = 0.6f;

	public float FadeOutSpeed = 0.6f;

	private void Start()
	{
		StartCoroutine(OutroSequence());
	}

	private IEnumerator OutroSequence()
	{
		CreditsLabel1.Text = "Design & Development:\n\nSergio Hidalgo";
		StartCoroutine(FadeIn(CreditsLabel1.GetComponent<Renderer>()));
		yield return new WaitForSeconds(8f);
		CreditsLabel2.Text = "Uses models and textures from:\n\nUnity Asset Store\nVeleran\nwww.myfreetextures.com";
		StartCoroutine(FadeOut(CreditsLabel1.GetComponent<Renderer>()));
		StartCoroutine(FadeIn(CreditsLabel2.GetComponent<Renderer>()));
		yield return new WaitForSeconds(6f);
		string sSound5 = "Uses sound and music from:\n\nwww.freesound.org\n";
		sSound5 += "Unfa, Rthtsdf, CGEffex, Solid80,\n";
		sSound5 += "Wolfsinger, Sea Fury, TheGoliath, Yottasounds,\n";
		sSound5 += "ssPatchen, Timmy-h123, Primejunt, Under7dude,\n";
		sSound5 += "Mitchelk, Suonho, Snaginneb, Qubodup\n";
		CreditsLabel1.Text = sSound5;
		StartCoroutine(FadeOut(CreditsLabel2.GetComponent<Renderer>()));
		StartCoroutine(FadeIn(CreditsLabel1.GetComponent<Renderer>()));
		yield return new WaitForSeconds(7f);
		CreditsLabel2.Text = "Thanks for playing.";
		StartCoroutine(FadeOut(CreditsLabel1.GetComponent<Renderer>()));
		StartCoroutine(FadeIn(CreditsLabel2.GetComponent<Renderer>()));
		yield return new WaitForSeconds(6f);
		StartCoroutine(FadeOut(CreditsLabel2.GetComponent<Renderer>()));
		yield return new WaitForSeconds(2f);
		Fader fader = GameObject.Find("Fader").GetComponent<Fader>();
		fader.FadeOut(1f, fadeAudio: false, base.gameObject);
	}

	private IEnumerator FadeIn(Renderer renderer)
	{
		while (renderer.material.color.a < 1f)
		{
			Color c = renderer.material.color;
			c.a = Mathf.Clamp(c.a + FadeInSpeed * Time.deltaTime, 0f, 1f);
			renderer.material.color = c;
			yield return new WaitForEndOfFrame();
		}
	}

	private IEnumerator FadeOut(Renderer renderer)
	{
		while (renderer.material.color.a > 0f)
		{
			Color c = renderer.material.color;
			c.a = Mathf.Clamp(c.a - FadeOutSpeed * Time.deltaTime, 0f, 1f);
			renderer.material.color = c;
			yield return new WaitForEndOfFrame();
		}
	}

	private void Update()
	{
		if (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction))
		{
			Fader component = GameObject.Find("Fader").GetComponent<Fader>();
			component.FadeOut(1f, fadeAudio: false, base.gameObject);
		}
	}

	public void OnEndFade(Fader fader)
	{
		UnityEngine.Application.LoadLevel("Intro");
	}
}
public class Serializer
{
	public delegate void OnSerialize(BinaryWriter writer);

	public delegate void OnDeserialize(BinaryReader reader);

	private int serialIdx;

	private Dictionary<string, Tuple<Component, OnSerialize, OnDeserialize>> registeredObjs = new Dictionary<string, Tuple<Component, OnSerialize, OnDeserialize>>();

	private Dictionary<Component, string> objToKey = new Dictionary<Component, string>();

	private List<string> removedObjs = new List<string>();

	public static void Add(Component obj, OnSerialize onSerialize, OnDeserialize onDeserialize)
	{
		if (GameController.Get().levelOptions.serializeID != 0)
		{
			Serializer serializer = GameController.Get().serializer;
			Tuple<Component, OnSerialize, OnDeserialize> value = new Tuple<Component, OnSerialize, OnDeserialize>(obj, onSerialize, onDeserialize);
			string text = obj.name + "-" + serializer.serialIdx;
			serializer.serialIdx++;
			serializer.objToKey[obj] = text;
			if (serializer.removedObjs.Contains(text))
			{
				UnityEngine.Object.Destroy(obj.gameObject);
				serializer.registeredObjs.Remove(text);
			}
			else
			{
				serializer.registeredObjs[text] = value;
			}
		}
	}

	public static void Remove(Component obj)
	{
		if (GameController.Get().levelOptions.serializeID != 0)
		{
			Serializer serializer = GameController.Get().serializer;
			string text = serializer.objToKey[obj];
			serializer.removedObjs.Add(text);
			serializer.registeredObjs.Remove(text);
		}
	}

	public void SaveGame(string gameName = "SavedGame_00", bool overwriteMap = true, bool refreshData = true)
	{
		Debug.Log("Saving game " + gameName);
		if (refreshData)
		{
			GameState.Get().Refresh(overwriteMap);
		}
		if (overwriteMap)
		{
			List<string> list = new List<string>();
			List<string> list2 = new List<string>();
			foreach (string key in registeredObjs.Keys)
			{
				MemoryStream memoryStream = new MemoryStream();
				BinaryWriter writer = new BinaryWriter(memoryStream);
				registeredObjs[key].Item2(writer);
				string item = Convert.ToBase64String(memoryStream.GetBuffer());
				list.Add(key);
				list2.Add(item);
			}
			GameState.Get().objectsIds = list;
			GameState.Get().objectsData = list2;
			GameState.Get().removedObjs = removedObjs;
		}
		GameState.Save(gameName);
	}

	public bool LoadGame(string gameName = "SavedGame_00")
	{
		Debug.Log("Loading game " + gameName);
		if (GameState.Get().liteVersion)
		{
			Debug.Log("Game tagged as LITE version");
		}
		if (!GameState.Load(gameName))
		{
			Debug.LogError("Error loading game " + gameName + " - Incorrect version");
			return false;
		}
		Fader component = GameObject.Find("Fader").GetComponent<Fader>();
		component.FadeOut(4f, fadeAudio: true, null, LoadGame_OnEndFade);
		return true;
	}

	private void LoadGame_OnEndFade()
	{
		LevelOptions metaLevelOptions = LevelOptions.GetMetaLevelOptions(GameState.Get().metaMap);
		GameController.nextOptions = metaLevelOptions;
		Loader.LoadLevel("Dungeon");
	}

	public void DeserializeRegisteredObjs()
	{
		List<string> objectsIds = GameState.Get().objectsIds;
		List<string> objectsData = GameState.Get().objectsData;
		for (int i = 0; i < objectsIds.Count; i++)
		{
			string key = objectsIds[i];
			if (registeredObjs.TryGetValue(key, out var value))
			{
				MemoryStream input = new MemoryStream(Convert.FromBase64String(objectsData[i]));
				BinaryReader reader = new BinaryReader(input);
				value.Item3(reader);
			}
		}
		removedObjs = new List<string>();
		for (int j = 0; j < GameState.Get().removedObjs.Count; j++)
		{
			removedObjs.Add(GameState.Get().removedObjs[j]);
			string key2 = GameState.Get().removedObjs[j];
			if (registeredObjs.TryGetValue(key2, out var value2))
			{
				UnityEngine.Object.Destroy(value2.Item1.gameObject);
				registeredObjs.Remove(key2);
			}
		}
	}

	public static void SerializeObject(object obj, string key)
	{
		BinaryFormatter binaryFormatter = new BinaryFormatter();
		MemoryStream memoryStream = new MemoryStream();
		binaryFormatter.Serialize(memoryStream, obj);
		PlayerPrefs.SetString(key, Convert.ToBase64String(memoryStream.GetBuffer()));
	}

	public static T DeserializeObject<T>(string key, T defaultValue = null) where T : class
	{
		string @string = PlayerPrefs.GetString(key);
		if (@string != string.Empty)
		{
			BinaryFormatter binaryFormatter = new BinaryFormatter();
			MemoryStream serializationStream = new MemoryStream(Convert.FromBase64String(@string));
			return binaryFormatter.Deserialize(serializationStream) as T;
		}
		return defaultValue;
	}
}
namespace SpookEvents
{
	public class DoorCreak : SpookEvent
	{
		public bool withWind;

		public float maxRange = 15f;

		private List<Door> candidates;

		protected override void OnEnable()
		{
			base.OnEnable();
			candidates = new List<Door>();
		}

		public override bool CheckConditions()
		{
			if (GameController.Get().levelOptions.IsMetaMap())
			{
				return false;
			}
			candidates.Clear();
			Transform look = Player.GetLook();
			Point currentCell = Player.GetController().CurrentCell;
			Vector3 vector = Map.Get().CellToWorld(currentCell);
			int num = Mathf.CeilToInt(maxRange / Map.Get().TileSize.x);
			for (int i = currentCell.Y - num / 2; i <= currentCell.Y + num / 2; i++)
			{
				for (int j = currentCell.X - num / 2; j <= currentCell.X + num / 2; j++)
				{
					if (!Map.Get().InRange(j, i))
					{
						continue;
					}
					Door door = Map.Get().At(j, i).Door;
					if ((bool)door && !door.IsDestroyed)
					{
						Vector3 vector2 = Vector3Ext.GroundVector(door.transform.position);
						if ((vector - vector2).sqrMagnitude <= maxRange * maxRange && Map.Get().At(j, i).CheckLoS(look.position))
						{
							candidates.Add(door);
						}
					}
				}
			}
			return candidates.Count > 0;
		}

		public override void Play(SpookManager owner)
		{
			if (candidates.Count != 0)
			{
				Door door = RandomExt.Choice(candidates);
				bool flag = !door.IsOpen;
				if (flag && withWind)
				{
					door.OpenWithWind();
				}
				else if (flag)
				{
					door.OpenWithCreak();
				}
				else if (!flag && withWind && !Player.IsSafe())
				{
					door.CloseFastWithWind();
				}
				else if (!flag)
				{
					door.Creak();
				}
			}
		}
	}
	public class LightFlicker : SpookEvent
	{
		public bool turnOff;

		public float range = 8f;

		public GameObject windEffect;

		public LayerMask layer;

		private List<InteractiveLightEx> lights;

		protected override void OnEnable()
		{
			base.OnEnable();
			lights = new List<InteractiveLightEx>();
		}

		public override bool CheckConditions()
		{
			return true;
		}

		public override void Play(SpookManager owner)
		{
			owner.StartCoroutine(Play_co());
		}

		private IEnumerator Play_co()
		{
			TorchLight torch = GameObject.FindWithTag(Tags.PlayerTorch).GetComponent<TorchLight>();
			Vector3 torchPos = torch.transform.position;
			Vector3 playerLook = Vector3Ext.GroundVector(Player.GetLookDir());
			playerLook.Normalize();
			if ((bool)windEffect)
			{
				Vector3 vector = playerLook;
				Vector3 position = torchPos + vector * 2.5f;
				for (int i = 0; i < 5; i++)
				{
					Vector3 vector2 = new Vector3(UnityEngine.Random.Range(-1f, 1f), 0f, UnityEngine.Random.Range(-1f, 1f));
					vector2.Normalize();
					Vector3 vector3 = torchPos + vector2 * UnityEngine.Random.Range(2f, 3f);
					if (Map.Get().At(vector3).CheckLoS(torchPos))
					{
						vector = vector2;
						position = vector3;
						break;
					}
				}
				UnityEngine.Object.Instantiate(windEffect, position, Quaternion.LookRotation(-vector, Vector3.up));
			}
			yield return new WaitForSeconds(0.5f);
			lights.Clear();
			Collider[] colliders = Physics.OverlapSphere(torchPos, range, layer);
			Collider[] array = colliders;
			foreach (Collider collider in array)
			{
				InteractiveLightEx component = collider.GetComponent<InteractiveLightEx>();
				if (!component)
				{
					component = collider.transform.parent.GetComponent<InteractiveLightEx>();
				}
				if ((bool)component && component.lightOn)
				{
					lights.Add(component);
				}
			}
			foreach (InteractiveLightEx light in lights)
			{
				light.FlickerOut(turnOff);
			}
			torch.FlickerOut();
		}
	}
}
public class SpookEvent : ScriptableObject
{
	[Range(0f, 5f)]
	public float weight = 1f;

	protected virtual void OnEnable()
	{
	}

	public virtual bool CheckConditions()
	{
		return true;
	}

	public virtual void Play(SpookManager owner)
	{
	}
}
namespace SpookEvents
{
	public class SpookEventTest1 : SpookEvent
	{
		public float testA = 20f;
	}
	public class SpookEventTest2 : SpookEvent
	{
		public string sTest = "foobar";
	}
}
public class SpookManager : MonoBehaviour
{
	private static SpookManager instance;

	public SpookEvent[] lowIntensityEvents;

	public SpookEvent[] midIntensityEvents;

	public SpookEvent[] highIntensityEvents;

	private List<SpookEvent> skipList;

	private void Awake()
	{
		skipList = new List<SpookEvent>();
		instance = this;
		StartCoroutine(SpawnEvents_co());
	}

	public static SpookManager Get()
	{
		return instance;
	}

	private IEnumerator SpawnEvents_co()
	{
		bool bFirst = true;
		while (true)
		{
			bool bWaitShort = !bFirst && UnityEngine.Random.value < 0.3f;
			bFirst = false;
			float maxWait = ((!bWaitShort) ? 90f : 50f);
			float minWait = ((!bWaitShort) ? 50f : 14f);
			float nextWait = UnityEngine.Random.Range(minWait, maxWait);
			yield return new WaitForSeconds(nextWait);
			if (UnityEngine.Random.value <= 0.5f)
			{
				bool flag = Player.IsSafe();
				float value = UnityEngine.Random.value;
				if (flag || value <= 0.7f)
				{
					PlayLowIntensity();
				}
				else if (value <= 0.9f)
				{
					PlayMidIntensity();
				}
				else
				{
					PlayHighIntensity();
				}
			}
		}
	}

	public bool PlayLowIntensity()
	{
		return PlayEvent(lowIntensityEvents);
	}

	public bool PlayMidIntensity()
	{
		return PlayEvent(midIntensityEvents);
	}

	public bool PlayHighIntensity()
	{
		return PlayEvent(highIntensityEvents);
	}

	private bool PlayEvent(SpookEvent[] list)
	{
		if (list.Length == 0)
		{
			return false;
		}
		skipList.Clear();
		SpookEvent spookEvent = null;
		while (spookEvent == null && skipList.Count < list.Length)
		{
			SpookEvent spookEvent2 = ChooseRandom(list, skipList);
			if ((bool)spookEvent2 && spookEvent2.CheckConditions())
			{
				spookEvent = spookEvent2;
			}
			else
			{
				skipList.Add(spookEvent2);
			}
		}
		if ((bool)spookEvent)
		{
			spookEvent.Play(this);
			return true;
		}
		return false;
	}

	private SpookEvent ChooseRandom(SpookEvent[] list, List<SpookEvent> skip)
	{
		float num = 0f;
		foreach (SpookEvent spookEvent in list)
		{
			if (!skip.Contains(spookEvent))
			{
				num += spookEvent.weight;
			}
		}
		float num2 = UnityEngine.Random.Range(0f, num);
		foreach (SpookEvent spookEvent2 in list)
		{
			if (!skip.Contains(spookEvent2))
			{
				if (spookEvent2.weight > num2)
				{
					return spookEvent2;
				}
				num2 -= spookEvent2.weight;
			}
		}
		return null;
	}

	public bool PlayEvent(SpookEvent spook)
	{
		if (spook.CheckConditions())
		{
			spook.Play(this);
			return true;
		}
		return false;
	}
}
public class StatsBriefing : FSMComponent<StatsBriefing.States>
{
	public enum States
	{
		FadeIn,
		Counting,
		Finished
	}

	public TextLabel textLabel;

	public TextLabel textDataLabel;

	public TextLabel textTitle;

	public TextLabel textContinue;

	private bool fading;

	public Fader fader;

	public MinimapStats minimap;

	public Color colorSuccess;

	public Color colorFailure;

	private float timer;

	private uint tickCounter;

	private int discoveredProbes;

	private uint lastProbesCount;

	private int collectedItems;

	private int nextEvent;

	private PlayerStats.Stats stats;

	private void Start()
	{
		stats = PlayerStats.stats;
		if (stats == null)
		{
			stats = new PlayerStats.Stats();
		}
		string text = Translate.Get("MENU_BRIEFING_TIME") + "\n" + Translate.Get("MENU_BRIEFING_EXPLORED") + "\n" + Translate.Get("MENU_BRIEFING_ITEMS");
		textLabel.Text = text;
		textLabel.FadeIn();
		textDataLabel.Text = string.Empty;
		textDataLabel.FadeIn();
		textTitle.Text = ((!stats.resultWin) ? Translate.Get("MENU_BRIEFING_FAILURE") : Translate.Get("MENU_BRIEFING_SUCCESS"));
		textTitle.textColor = ((!stats.resultWin) ? colorFailure : colorSuccess);
		textContinue.Text = Translate.GetForInput("MENU_BRIEFING_CONTINUE") + "\n\n" + Translate.GetForInput("MENU_BRIEFING_EXIT");
		Init(States.FadeIn);
	}

	private void FadeIn_Enter()
	{
		textLabel.FadeIn();
		textDataLabel.FadeIn();
		timer = 1f;
		if (stats.events.Count > 0)
		{
			minimap.SetPlayerPos(stats.events[0].position);
		}
	}

	private void FadeIn_Update()
	{
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			base.State = States.Counting;
		}
	}

	private void Counting_Enter()
	{
		tickCounter = 0u;
		timer = 0f;
		discoveredProbes = 0;
		collectedItems = 0;
	}

	private void Counting_Update()
	{
		bool flag = false;
		timer += Time.deltaTime;
		if (timer >= 0.1f)
		{
			timer -= 0.1f;
			uint totalTime = stats.totalTime;
			tickCounter += 10u;
			if (tickCounter > totalTime)
			{
				flag = true;
			}
			UpdateStats(tickCounter);
		}
		if (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction) || InputExt.GetButtonDown(InputExt.Button.Cancel) || InputExt.BackButtonDown)
		{
			flag = true;
		}
		if (flag)
		{
			base.State = States.Finished;
		}
	}

	private void Finished_Enter()
	{
		textTitle.FadeIn();
		textContinue.FadeIn();
		UpdateStats(stats.totalTime);
		ShowStatsData(stats.totalTime, stats.discoveredProbes, stats.totalProbes, stats.collectedItems, stats.totalItems);
	}

	private void Finished_Update()
	{
		if (!fading && (InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction)))
		{
			fading = true;
			GameController.Get().StartRandomMap();
		}
		else if (!fading && (InputExt.GetButtonDown(InputExt.Button.Cancel) || InputExt.BackButtonDown))
		{
			fading = true;
			fader.FadeOut(4f, fadeAudio: true, null, Exit_OnEndFade);
		}
	}

	private void Exit_OnEndFade()
	{
		GameController.Get().ExitGame();
	}

	private void UpdateStats(uint tick)
	{
		bool flag = false;
		bool flag2 = true;
		while (nextEvent < stats.events.Count && stats.events[nextEvent].timeTick <= tick)
		{
			flag = true;
			PlayerStats.Stats.Event @event = stats.events[nextEvent];
			nextEvent++;
			if (@event.eventType == PlayerStats.Stats.Event.EventType.Collect)
			{
				collectedItems++;
			}
			else if (@event.eventType == PlayerStats.Stats.Event.EventType.Position)
			{
				minimap.SetPlayerPos(@event.position);
			}
		}
		if (flag2)
		{
			flag = true;
			for (int i = 0; i < 64; i++)
			{
				for (int j = 0; j < 64; j++)
				{
					uint num = stats.discoveredTiles[i][j];
					if (num < tick && num >= lastProbesCount)
					{
						discoveredProbes++;
						minimap.MarkProbe(j, i);
					}
				}
			}
			minimap.ApplyProbes();
			lastProbesCount = tickCounter;
		}
		if (flag)
		{
			ShowStatsData(tickCounter, discoveredProbes, stats.totalProbes, collectedItems, stats.totalItems);
		}
	}

	private void ShowStatsData(uint time, int discoveredProbes, int totalProbes, int collectedItems, int totalItems)
	{
		totalProbes = Mathf.Max(discoveredProbes, totalProbes);
		totalItems = Mathf.Max(collectedItems, totalItems);
		float num = (float)discoveredProbes / (float)totalProbes * 100f;
		float num2 = 0f;
		if (totalItems != 0)
		{
			num2 = (float)collectedItems / (float)totalItems * 100f;
		}
		string text = ParseTime(time);
		string text2 = text;
		text = text2 + "\n" + (int)num + "%";
		text2 = text;
		text = text2 + "\n" + (int)num2 + "% (" + collectedItems + "/" + totalItems + ")";
		textDataLabel.Text = text;
	}

	private string ParseTime(uint time)
	{
		uint num = time / 600;
		uint num2 = time - num * 60 * 10;
		uint num3 = num2 / 10;
		num2 -= num3 * 10;
		uint num4 = num2;
		if (num != 0)
		{
			return string.Format(Translate.Get("MENU_BRIEFING_TIME_MINS"), num, num3);
		}
		return string.Format(Translate.Get("MENU_BRIEFING_TIME_SECS"), num3);
	}
}
public class Tags
{
	public static string Untagged = "Untagged";

	public static string Player = "Player";

	public static string GameController = "GameController";

	public static string LookDirection = "LookDirection";

	public static string MainCamera = "MainCamera";

	public static string NavGraph = "NavGraph";

	public static string NavNode = "NavNode";

	public static string Minimap = "Minimap";

	public static string ForwardDirection = "ForwardDirection";

	public static string GhostSpawn = "GhostSpawn";

	public static string PlayerTorch = "PlayerTorch";

	public static string PlayerNotes = "PlayerNotes";

	public static string Inventory = "Inventory";

	public static string Exit = "Exit";

	public static string Ghost = "Ghost";

	public static string MapGeometry = "MapGeometry";

	public static string Door = "Door";

	public static string PlayerTrigger = "PlayerTrigger";

	public static string FloaterSpawn = "FloaterSpawn";

	public static string UI = "UI";

	public static string TutorialUI = "TutorialUI";

	public static string DoorTrigger = "DoorTrigger";

	public static string Creature = "Creature";

	public static string LeftHand = "LeftHand";

	public static string RightHand = "RightHand";

	public static string LeftHandLook = "LeftHandLook";

	public static string RightHandLook = "RightHandLook";

	public static bool IsPlayer(string tag)
	{
		return tag == Player;
	}
}
public class TemplateMap : MonoBehaviour
{
	public delegate Texture GetPropMarkerTextureDelegate(RoomTemplate.PropMarker marker, TemplateMap tmap);

	[Serializable]
	public class PropMarkerPrototype
	{
		public string name;

		public Sprite propSprite;

		public RoomTemplate.PropMarker propMarker;
	}

	public int width = 10;

	public int height = 10;

	[NonSerialized]
	public Point markerPos;

	[NonSerialized]
	public bool showMarker;

	[NonSerialized]
	public Point originPos;

	[NonSerialized]
	public bool showOrigin;

	[NonSerialized]
	public int editLayout = -1;

	[NonSerialized]
	public RoomTemplate.PropMarker overProp;

	[NonSerialized]
	public RoomTemplate.PropMarker selectedProp;

	[NonSerialized]
	public SpriteRenderer[][] cells;

	public Sprite emptySprite;

	public Sprite wallSprite;

	public Sprite groundSprite;

	public Sprite doorSprite;

	public Sprite pitSprite;

	public Sprite pitShaftSprite;

	public Sprite shaftSprite;

	public Sprite propAnySprite;

	public Sprite propOtherSprite;

	public Sprite propLightSprite;

	public Sprite propImportantSprite;

	public Sprite propHorrorSprite;

	public Sprite propTallSprite;

	public Sprite propAreaSprite;

	public GetPropMarkerTextureDelegate getPropMarkerTexture;

	public List<PropMarkerPrototype> propPrototypes;

	[NonSerialized]
	public RoomTemplate roomTemplate;

	private void Awake()
	{
		cells = null;
		foreach (Transform item in base.gameObject.transform)
		{
			UnityEngine.Object.Destroy(item.gameObject);
		}
		Debug.Log("Awoken");
	}

	private void OnDrawGizmosSelected()
	{
		Vector3 position = base.transform.position;
		if (roomTemplate == null || string.IsNullOrEmpty(roomTemplate.name))
		{
			return;
		}
		Gizmos.color = Color.grey;
		Gizmos.color = Color.black;
		Gizmos.DrawLine(position, position + new Vector3(width, 0f, 0f));
		Gizmos.DrawLine(position, position + new Vector3(0f, -height, 0f));
		Gizmos.DrawLine(position + new Vector3(width, 0f, 0f), position + new Vector3(width, -height, 0f));
		Gizmos.DrawLine(position + new Vector3(0f, -height, 0f), position + new Vector3(width, -height, 0f));
		Gizmos.color = new Color(21f / 85f, 21f / 85f, 21f / 85f);
		for (int i = 1; i < width; i++)
		{
			Gizmos.DrawLine(position + new Vector3(i, 0f, 0f), position + new Vector3(i, -height, 0f));
		}
		for (int j = 1; j < height; j++)
		{
			Gizmos.DrawLine(position + new Vector3(0f, -j, 0f), position + new Vector3(width, -j, 0f));
		}
		foreach (CPoint doubleDoor in roomTemplate.doubleDoors)
		{
			bool flag = roomTemplate.At(doubleDoor.X + 1, doubleDoor.Y) == CellType.EntranceMark;
			Vector3 vector = new Vector3((float)doubleDoor.X + 0.5f, (float)(-doubleDoor.Y) - 0.5f, 0f) + ((!flag) ? new Vector3(0f, -0.5f, 0f) : new Vector3(0.5f, 0f, 0f));
			Vector3 size = ((!flag) ? new Vector3(1f, 2f, 1f) : new Vector3(2f, 1f, 1f));
			Gizmos.color = new Color(0.44f, 0.88f, 0.38f);
			if (doubleDoor.X % 2 != 0 || doubleDoor.Y % 2 != 0)
			{
				Gizmos.color = new Color(0.88f, 0.1f, 0.14f, 0.5f);
				Gizmos.DrawCube(position + vector, size);
				Gizmos.color = new Color(0.88f, 0.44f, 0.38f);
			}
			Gizmos.DrawWireCube(position + vector, size);
		}
		int num = editLayout;
		if (num >= 0 && num < roomTemplate.layouts.Count)
		{
			foreach (RoomTemplate.PropMarker prop in roomTemplate.layouts[num].props)
			{
				Vector3 vector2 = new Vector3((float)prop.pos.X + (float)prop.width / 2f, (float)(-prop.pos.Y) - (float)prop.height / 2f, 0f);
				Gizmos.color = GetPropMarkerColor(prop);
				Gizmos.DrawCube(position + vector2, new Vector3(prop.width, prop.height, 1f));
				Texture propMarkerTexture = GetPropMarkerTexture(prop);
				if (propMarkerTexture != null)
				{
					Gizmos.DrawGUITexture(new Rect(prop.pos.X, -prop.pos.Y, prop.width, -prop.height), GetPropMarkerTexture(prop));
				}
				if (prop == selectedProp)
				{
					Gizmos.color = (((int)(Time.realtimeSinceStartup * 4f) % 2 != 0) ? Color.yellow : Color.white);
					Gizmos.DrawWireCube(position + vector2, new Vector3(prop.width, prop.height, 1f));
				}
				if (prop == overProp)
				{
					Gizmos.color = Color.red;
					Gizmos.DrawWireCube(position + vector2, new Vector3(prop.width, prop.height, 1f));
				}
				if ((prop == selectedProp || prop == overProp) && prop.direction != 0)
				{
					bool flag2 = prop.direction == RoomTemplate.PropMarker.Direction.Right;
					bool flag3 = prop.direction == RoomTemplate.PropMarker.Direction.Left;
					bool flag4 = prop.direction == RoomTemplate.PropMarker.Direction.Up;
					bool flag5 = prop.direction == RoomTemplate.PropMarker.Direction.Down;
					Vector3 vector3 = position + vector2;
					if (flag2)
					{
						vector3 += new Vector3((float)prop.width / 2f + 0.1f, 0f, 0f);
					}
					else if (flag3)
					{
						vector3 -= new Vector3((float)prop.width / 2f + 0.1f, 0f, 0f);
					}
					else if (flag4)
					{
						vector3 += new Vector3(0f, (float)prop.height / 2f + 0.1f, 0f);
					}
					else if (flag5)
					{
						vector3 -= new Vector3(0f, (float)prop.height / 2f + 0.1f, 0f);
					}
					Vector3 vector4 = new Vector3(0f, 1f, 0f) * 0.2f;
					Vector3 vector5 = new Vector3(1f, 0f, 0f) * 0.3f;
					Quaternion quaternion = Quaternion.identity;
					if (flag4)
					{
						quaternion = Quaternion.AngleAxis(90f, new Vector3(0f, 0f, 1f));
					}
					else if (flag3)
					{
						quaternion = Quaternion.AngleAxis(180f, new Vector3(0f, 0f, 1f));
					}
					else if (flag5)
					{
						quaternion = Quaternion.AngleAxis(-90f, new Vector3(0f, 0f, 1f));
					}
					vector4 = quaternion * vector4;
					vector5 = quaternion * vector5;
					Gizmos.DrawLine(vector3 + vector4, vector3 - vector4);
					Gizmos.DrawLine(vector3 + vector4, vector3 + vector5);
					Gizmos.DrawLine(vector3 - vector4, vector3 + vector5);
				}
			}
		}
		if (showMarker)
		{
			Gizmos.color = Color.red;
			Vector3 vector6 = new Vector3((float)markerPos.X + 0.5f, (float)(-markerPos.Y) - 0.5f, 0f);
			Gizmos.DrawWireCube(position + vector6, new Vector3(1f, 1f, 1f) * 1f);
		}
		if (showOrigin)
		{
			Gizmos.color = Color.blue;
			Vector3 vector7 = new Vector3((float)originPos.X + 0.5f, (float)(-originPos.Y) - 0.5f, 0f);
			Gizmos.DrawWireCube(position + vector7, new Vector3(1f, 1f, 1f) * 1f);
			Vector3 from = new Vector3(Mathf.Min(originPos.X, markerPos.X), -Mathf.Min(originPos.Y, markerPos.Y));
			Vector3 vector8 = new Vector3(Mathf.Max(originPos.X, markerPos.X), -Mathf.Min(originPos.Y, markerPos.Y));
			Vector3 vector9 = new Vector3(Mathf.Min(originPos.X, markerPos.X), -Mathf.Max(originPos.Y, markerPos.Y));
			Vector3 to = new Vector3(Mathf.Max(originPos.X, markerPos.X), -Mathf.Max(originPos.Y, markerPos.Y));
			from += new Vector3(position.x + 0.5f, position.y - 0.5f, 0f);
			vector8 += new Vector3(position.x + 0.5f, position.y - 0.5f, 0f);
			vector9 += new Vector3(position.x + 0.5f, position.y - 0.5f, 0f);
			to += new Vector3(position.x + 0.5f, position.y - 0.5f, 0f);
			Gizmos.DrawLine(from, vector8);
			Gizmos.DrawLine(vector9, to);
			Gizmos.DrawLine(from, vector9);
			Gizmos.DrawLine(vector8, to);
		}
	}

	public void Reset(int w, int h, bool createRoom = true)
	{
		width = w;
		height = h;
		if (cells != null)
		{
			for (int i = 0; i < cells.Length; i++)
			{
				for (int j = 0; j < cells[i].Length; j++)
				{
					UnityEngine.Object.DestroyImmediate(cells[i][j].gameObject);
				}
			}
		}
		List<GameObject> list = new List<GameObject>();
		foreach (Transform item in base.gameObject.transform)
		{
			list.Add(item.gameObject);
		}
		foreach (GameObject item2 in list)
		{
			UnityEngine.Object.DestroyImmediate(item2);
		}
		cells = new SpriteRenderer[height][];
		for (int k = 0; k < height; k++)
		{
			cells[k] = new SpriteRenderer[width];
			for (int l = 0; l < width; l++)
			{
				GameObject gameObject = new GameObject();
				gameObject.name = string.Empty + l + "," + k;
				gameObject.transform.parent = base.transform;
				gameObject.transform.localPosition = new Vector3(l, -k, 0f);
				gameObject.hideFlags = HideFlags.HideAndDontSave | HideFlags.HideInInspector;
				gameObject.AddComponent<TemplateMapTile>();
				SpriteRenderer spriteRenderer = gameObject.AddComponent<SpriteRenderer>();
				spriteRenderer.sprite = emptySprite;
				cells[k][l] = spriteRenderer;
			}
		}
		if (createRoom)
		{
			roomTemplate = ScriptableObject.CreateInstance<RoomTemplate>();
			roomTemplate.Reset(width, height);
		}
		UpdateDoors();
		Refresh();
		GetComponent<BoxCollider2D>().size = new Vector2(width, height);
		GetComponent<BoxCollider2D>().offset = new Vector2((float)width / 2f, (float)(-height) / 2f);
	}

	public void Load(RoomTemplate newRoom)
	{
		roomTemplate = newRoom;
		Reset(newRoom.width, newRoom.height, createRoom: false);
	}

	public void Refresh()
	{
		if (!roomTemplate)
		{
			GetComponent<BoxCollider2D>().size = new Vector2(10f, 10f);
			GetComponent<BoxCollider2D>().offset = new Vector2(5f, -5f);
			return;
		}
		for (int i = 0; i < height; i++)
		{
			for (int j = 0; j < width; j++)
			{
				Refresh(new Point(j, i));
			}
		}
	}

	public void Refresh(Point pos)
	{
		if ((bool)roomTemplate)
		{
			Sprite sprite = emptySprite;
			switch (roomTemplate.At(pos))
			{
			case CellType.Perimeter:
			case CellType.Blocked:
				sprite = wallSprite;
				break;
			case CellType.EntranceMark:
			case CellType.Door:
				sprite = doorSprite;
				break;
			case CellType.Room:
				sprite = groundSprite;
				break;
			case CellType.Pit:
				sprite = pitSprite;
				break;
			case CellType.Shaft:
				sprite = shaftSprite;
				break;
			case CellType.PitShaft:
				sprite = pitShaftSprite;
				break;
			}
			cells[pos.Y][pos.X].sprite = sprite;
		}
	}

	public void PaintBase(Point pos, Sprite spr)
	{
		if ((bool)roomTemplate)
		{
			CellType type = CellType.Rock;
			if (spr == emptySprite)
			{
				type = CellType.Rock;
			}
			else if (spr == wallSprite)
			{
				type = CellType.Perimeter;
			}
			else if (spr == groundSprite)
			{
				type = CellType.Room;
			}
			else if (spr == doorSprite)
			{
				type = CellType.EntranceMark;
			}
			else if (spr == pitSprite)
			{
				type = CellType.Pit;
			}
			else if (spr == pitShaftSprite)
			{
				type = CellType.PitShaft;
			}
			else if (spr == shaftSprite)
			{
				type = CellType.Shaft;
			}
			roomTemplate.Set(pos, type);
			UpdateDoors();
			Refresh(pos);
		}
	}

	public void Resize(int newWidth, int newHeight)
	{
		if (!roomTemplate)
		{
			return;
		}
		int num = roomTemplate.width;
		int num2 = roomTemplate.height;
		CellType[] baseLayout = roomTemplate.baseLayout;
		roomTemplate.width = newWidth;
		roomTemplate.height = newHeight;
		roomTemplate.baseLayout = new CellType[newHeight * newWidth];
		for (int i = 0; i < newHeight; i++)
		{
			for (int j = 0; j < newWidth; j++)
			{
				if (i < num2 && j < num)
				{
					roomTemplate.Set(j, i, baseLayout[i * num + j]);
				}
				else
				{
					roomTemplate.Set(j, i, CellType.Rock);
				}
			}
		}
		foreach (RoomTemplate.Layout layout in roomTemplate.layouts)
		{
			for (int k = 0; k < layout.props.Count; k++)
			{
				if (layout.props[k].pos.X >= newWidth || layout.props[k].pos.Y >= newHeight)
				{
					layout.props.RemoveAt(k--);
				}
			}
		}
		Reset(newWidth, newHeight, createRoom: false);
	}

	public void Displace(int deltaX, int deltaY)
	{
		if (!roomTemplate)
		{
			return;
		}
		CellType[] baseLayout = roomTemplate.baseLayout;
		roomTemplate.baseLayout = new CellType[roomTemplate.height * roomTemplate.width];
		for (int i = 0; i < roomTemplate.height; i++)
		{
			for (int j = 0; j < roomTemplate.width; j++)
			{
				CellType type = CellType.Rock;
				int num = j - deltaX;
				int num2 = i - deltaY;
				if (num >= 0 && num < roomTemplate.width && num2 >= 0 && num2 < roomTemplate.height)
				{
					type = baseLayout[num2 * roomTemplate.width + num];
				}
				roomTemplate.Set(j, i, type);
			}
		}
		foreach (RoomTemplate.Layout layout in roomTemplate.layouts)
		{
			for (int k = 0; k < layout.props.Count; k++)
			{
				layout.props[k].pos = new CPoint(layout.props[k].pos.X + deltaX, layout.props[k].pos.Y + deltaY);
				if (layout.props[k].pos.X <= 0 || layout.props[k].pos.X + layout.props[k].width - 1 >= roomTemplate.width || layout.props[k].pos.Y <= 0 || layout.props[k].pos.Y + layout.props[k].height - 1 >= roomTemplate.height)
				{
					layout.props.RemoveAt(k--);
				}
			}
		}
		UpdateDoors();
		Refresh();
	}

	public void TrimSpace()
	{
		IntRect boundingBox = GetBoundingBox();
		Debug.Log("Bounding Box: " + boundingBox);
		int num = boundingBox.left - boundingBox.left % 2;
		int num2 = boundingBox.top - boundingBox.top % 2;
		int num3 = boundingBox.width + (boundingBox.left - num);
		int num4 = boundingBox.height + (boundingBox.top - num2);
		if (num3 % 2 != 0)
		{
			num3++;
		}
		if (num4 % 2 != 0)
		{
			num4++;
		}
		Displace(-num, -num2);
		Resize(num3, num4);
		Refresh();
	}

	public IntRect GetBoundingBox()
	{
		int num = width;
		int num2 = 0;
		int num3 = height;
		int num4 = 0;
		for (int i = 0; i < height; i++)
		{
			for (int j = 0; j < width; j++)
			{
				if (roomTemplate.At(j, i) != 0)
				{
					num = Mathf.Min(num, j);
					num2 = Mathf.Max(num2, j);
					num3 = Mathf.Min(num3, i);
					num4 = Mathf.Max(num4, i);
				}
			}
		}
		num2++;
		num4++;
		return new IntRect(num, num3, num2 - num + 1, num4 - num3 + 1);
	}

	public void UpdateDoors()
	{
		roomTemplate.doors = new List<CPoint>();
		roomTemplate.doubleDoors = new List<CPoint>();
		for (int i = 0; i < roomTemplate.height; i++)
		{
			for (int j = 0; j < roomTemplate.width; j++)
			{
				if (roomTemplate.At(j, i) != CellType.EntranceMark)
				{
					continue;
				}
				CPoint item = new CPoint(j - 1, i);
				CPoint item2 = new CPoint(j, i - 1);
				if (!roomTemplate.doubleDoors.Contains(item) && !roomTemplate.doubleDoors.Contains(item2))
				{
					roomTemplate.doors.Add(new CPoint(j, i));
					if ((j + 1 < roomTemplate.width && roomTemplate.At(j + 1, i) == CellType.EntranceMark) || (i + 1 < roomTemplate.height && roomTemplate.At(j, i + 1) == CellType.EntranceMark))
					{
						roomTemplate.doubleDoors.Add(new CPoint(j, i));
					}
				}
			}
		}
	}

	public void AddLayout()
	{
		roomTemplate.layouts.Add(new RoomTemplate.Layout());
	}

	public void CloneLayout()
	{
		RoomTemplate.Layout layout = roomTemplate.layouts[editLayout];
		RoomTemplate.Layout layout2 = new RoomTemplate.Layout();
		foreach (RoomTemplate.PropMarker prop in layout.props)
		{
			layout2.props.Add(new RoomTemplate.PropMarker(prop.pos, prop));
		}
		roomTemplate.layouts.Add(layout2);
	}

	public void RemoveLayout()
	{
		if (editLayout >= 0 && editLayout < roomTemplate.layouts.Count)
		{
			roomTemplate.layouts.RemoveAt(editLayout);
			editLayout--;
		}
	}

	public RoomTemplate.PropMarker AddProp(PropMarkerPrototype prototype)
	{
		return AddProp(prototype.propMarker);
	}

	public RoomTemplate.PropMarker AddProp(RoomTemplate.PropMarker protoMarker)
	{
		RoomTemplate.PropMarker propMarker = new RoomTemplate.PropMarker(new CPoint(markerPos), protoMarker);
		roomTemplate.layouts[editLayout].props.Add(propMarker);
		return propMarker;
	}

	public void RemoveProp(RoomTemplate.PropMarker marker)
	{
		roomTemplate.layouts[editLayout].props.Remove(marker);
	}

	public Color GetPropMarkerColor(RoomTemplate.PropMarker marker)
	{
		if (marker.groupIndex == -1 || marker.propInfo != null)
		{
			return new Color(0f, 0f, 0f, 0.2f);
		}
		Color propGroupColor = GetPropGroupColor(marker.groupIndex);
		propGroupColor.a = 0.4f;
		return propGroupColor;
	}

	public Color GetPropGroupColor(int groupIdx)
	{
		return groupIdx switch
		{
			0 => ColorExt.FromValue(4282240061u), 
			1 => ColorExt.FromValue(4284727039u), 
			2 => ColorExt.FromValue(4294961535u), 
			3 => ColorExt.FromValue(4294934399u), 
			4 => ColorExt.FromValue(4288774143u), 
			5 => ColorExt.FromValue(4290090496u), 
			_ => Color.white, 
		};
	}

	public Texture GetPropMarkerTexture(RoomTemplate.PropMarker marker)
	{
		if (getPropMarkerTexture != null)
		{
			return getPropMarkerTexture(marker, this);
		}
		return propAnySprite.texture;
	}
}
public class TemplateMapTile : MonoBehaviour
{
}
[ExecuteInEditMode]
public class TestLoS : MonoBehaviour
{
	public Transform target;

	private void Awake()
	{
		target = Player.Get().transform;
	}

	private void OnDrawGizmos()
	{
		Vector3 vector = base.transform.position.ToGround();
		Vector3 vector2 = target.position.ToGround();
		Gizmos.color = ((!MapLoS.LineOfWalk(vector, vector2)) ? Color.red : Color.green);
		Gizmos.DrawLine(vector + Vector3.up, vector2 + Vector3.up);
	}
}
public class TestReload : MonoBehaviour
{
	private void Update()
	{
		if (Input.GetButton("Fire1"))
		{
			GC.Collect();
			string loadedLevelName = UnityEngine.Application.loadedLevelName;
			UnityEngine.Application.LoadLevel(loadedLevelName);
		}
	}
}
public class TestRecenter : MonoBehaviour
{
	private void Update()
	{
		if ((OVRInput.GetDown(OVRInput.Button.PrimaryThumbstick) && OVRInput.Get(OVRInput.Button.SecondaryThumbstick)) || (OVRInput.Get(OVRInput.Button.PrimaryThumbstick) && OVRInput.GetDown(OVRInput.Button.SecondaryThumbstick)))
		{
			GameController.Get().ResetOVROrientation();
		}
	}
}
public class LocalizedTexture : MonoBehaviour
{
	public string[] keywords;

	public string[] textureNames;

	private void Start()
	{
		RefreshTextures();
	}

	public void RefreshTextures()
	{
		Material material = GetComponent<Renderer>().material;
		if (keywords.Length == 0 && textureNames.Length >= 1)
		{
			material.mainTexture = GetLocalizedTexture(textureNames[0]);
		}
		else if (keywords.Length > 0 && keywords.Length <= textureNames.Length)
		{
			for (int i = 0; i < keywords.Length; i++)
			{
				material.SetTexture(keywords[i], GetLocalizedTexture(textureNames[i]));
			}
		}
	}

	private Texture GetLocalizedTexture(string texName)
	{
		string language = Translate.GetLanguage();
		Texture texture = Resources.Load<Texture>("LocalizedTextures/" + language + "/" + texName);
		if (texture == null)
		{
			texture = Resources.Load<Texture>("LocalizedTextures/english/" + texName);
		}
		return texture;
	}
}
public class LostFocusOverlay : MonoBehaviour
{
	private Renderer[] renderers;

	private void Awake()
	{
		renderers = GetComponentsInChildren<Renderer>(includeInactive: true);
		Renderer[] array = renderers;
		foreach (Renderer renderer in array)
		{
			renderer.enabled = false;
		}
	}

	private void OnApplicationFocus(bool focusStatus)
	{
		Debug.Log((!focusStatus) ? "Hiding Lost Focus Overlay" : "Showing Lost Focus Overlay");
		if (!focusStatus)
		{
			Renderer[] array = renderers;
			foreach (Renderer renderer in array)
			{
				renderer.enabled = true;
			}
		}
		else
		{
			Renderer[] array2 = renderers;
			foreach (Renderer renderer2 in array2)
			{
				renderer2.enabled = false;
			}
		}
	}
}
public class NotificationOverlay : TimeIndependentBehaviour
{
	private static NotificationOverlay instance;

	private TextLabel TLabel;

	private float timer;

	private bool showing;

	private void Start()
	{
		instance = this;
		TLabel = GetComponent<TextLabel>();
		timer = 0f;
		showing = false;
	}

	private new void Update()
	{
		base.Update();
		if (showing)
		{
			timer -= base.deltaTime;
			if (timer <= 0f)
			{
				TLabel.HideText();
				showing = false;
			}
		}
	}

	public void ShowText(string text, float time)
	{
		timer = time;
		showing = true;
		TLabel.ShowText(text);
	}

	public static void Show(string text, float time = 3f)
	{
		if (instance != null)
		{
			instance.ShowText(text, time);
		}
	}

	public static void Clear()
	{
		instance = null;
	}
}
public class PauseMenu : UIMenu
{
	protected new void Update()
	{
		base.Update();
		if (GameController.Get().Paused != IsShowing())
		{
			ShowMenu(GameController.Get().Paused);
		}
	}

	protected override void OnShow()
	{
		Quaternion localRotation = Player.ForwardDirection.localRotation;
		base.transform.parent.localRotation = localRotation;
	}

	protected override void OnButton(string btnName, UIButton button)
	{
		if (btnName == "btnResume")
		{
			GameController.Get().ExitPause();
		}
		else if (btnName == "btnExit")
		{
			GameController.Get().ExitGame();
		}
	}

	protected override void OnCancel()
	{
		GameController.Get().ExitPause();
	}
}
[RequireComponent(typeof(TextLabel))]
public class UIButton : UILabel
{
}
[RequireComponent(typeof(TextLabel))]
public class UILabel : MonoBehaviour
{
	public string caption = string.Empty;

	private TextLabel textLabel;

	public string Caption
	{
		get
		{
			return caption;
		}
		set
		{
			caption = value;
			textLabel.Text = caption;
		}
	}

	private void Awake()
	{
		textLabel = GetComponent<TextLabel>();
		caption = Translate.Get(caption);
		textLabel.Text = caption;
		textLabel.InitText = caption;
		GetComponent<Renderer>().material.renderQueue += 10;
	}
}
public class UIMenu : TimeIndependentBehaviour
{
	public UIButton[] buttonList;

	public bool animated = true;

	public AudioClip showSound;

	public AudioClip hideSound;

	public AudioClip switchSound;

	public AudioClip selectSound;

	private Vector3[] btnStartScales;

	private int selected;

	private bool showing;

	private float factor;

	private AxisEvents axisVertical = new AxisEvents("Vertical", "Vertical_btn");

	private void Start()
	{
		btnStartScales = new Vector3[buttonList.Length];
		for (int i = 0; i < buttonList.Length; i++)
		{
			ref Vector3 reference = ref btnStartScales[i];
			reference = buttonList[i].transform.localScale;
		}
	}

	protected new void Update()
	{
		base.Update();
		axisVertical.Update();
		if (!showing && !animated)
		{
			return;
		}
		if (animated)
		{
			float num = factor;
			if (showing)
			{
				factor += base.deltaTime * 1.5f;
			}
			else
			{
				factor -= base.deltaTime * 1.5f;
			}
			factor = Mathf.Clamp01(factor);
			float x = Interpolate.EaseInOutCubic(0f, 1f, factor);
			base.transform.localScale = new Vector3(x, 1f, 1f);
			if (!showing && factor <= 0.01f && num > 0.01f)
			{
				ShowRenderers(show: false);
			}
		}
		if (!showing)
		{
			return;
		}
		bool flag = Input.GetKeyDown(KeyCode.DownArrow) || axisVertical.GetDownButtonDown();
		bool flag2 = Input.GetKeyDown(KeyCode.UpArrow) || axisVertical.GetUpButtonDown();
		bool flag3 = InputExt.GetButtonDown(InputExt.Button.Action) || InputExt.GetButtonDown(InputExt.Button.UIAction) || Input.GetKeyDown(KeyCode.Return);
		bool flag4 = InputExt.GetButtonDown(InputExt.Button.Cancel) || GameController.GetBackButtonDown();
		if (flag && selected < buttonList.Length - 1)
		{
			selected = (selected + 1) % buttonList.Length;
			if ((bool)switchSound)
			{
				Utils.PlayClipAt(switchSound, base.transform.position);
			}
		}
		if (flag2 && selected > 0)
		{
			selected = (selected - 1) % buttonList.Length;
			if ((bool)switchSound)
			{
				Utils.PlayClipAt(switchSound, base.transform.position);
			}
		}
		if (flag3)
		{
			if ((bool)selectSound)
			{
				Utils.PlayClipAt(selectSound, base.transform.position);
			}
			OnButton(buttonList[selected].name, buttonList[selected]);
		}
		if (flag4)
		{
			OnCancel();
		}
		for (int i = 0; i < buttonList.Length; i++)
		{
			Vector3 to = btnStartScales[i];
			if (selected == i)
			{
				to.x *= 1.25f;
				to.z *= 1.25f;
			}
			buttonList[i].transform.localScale = Interpolate.Approach(buttonList[i].transform.localScale, to, base.deltaTime * 7f);
		}
	}

	public void ShowMenu(bool show = true)
	{
		if (showing == show)
		{
			return;
		}
		if (!animated || show)
		{
			ShowRenderers(show);
		}
		showing = show;
		if (show)
		{
			selected = 0;
			if ((bool)showSound)
			{
				Utils.PlayClipAt(showSound, base.transform.position);
			}
			OnShow();
		}
		else
		{
			if ((bool)hideSound)
			{
				Utils.PlayClipAt(hideSound, base.transform.position);
			}
			OnHide();
		}
	}

	public void HideMenu()
	{
		ShowMenu(show: false);
	}

	public bool IsShowing()
	{
		return showing;
	}

	private void ShowRenderers(bool show = true)
	{
		Renderer[] componentsInChildren = base.gameObject.GetComponentsInChildren<Renderer>();
		Renderer[] array = componentsInChildren;
		foreach (Renderer renderer in array)
		{
			renderer.enabled = show;
		}
	}

	protected virtual void OnShow()
	{
	}

	protected virtual void OnHide()
	{
	}

	protected virtual void OnButton(string btnName, UIButton button)
	{
	}

	protected virtual void OnCancel()
	{
	}
}
public class AnimTest : MonoBehaviour
{
	public string animName;

	private void Start()
	{
		GetComponent<Animation>().CrossFade(animName);
	}
}
public class AxisEvents
{
	private string axisName;

	private string axisSubstitute;

	private bool downPressed;

	private bool upPressed;

	private bool downJustPressed;

	private bool upJustPressed;

	private bool downJustReleased;

	private bool upJustReleased;

	public AxisEvents(string axisName, string axisSubstitute = "")
	{
		this.axisName = axisName;
		this.axisSubstitute = axisSubstitute;
		downPressed = false;
		upPressed = false;
		downJustPressed = (downJustReleased = false);
		upJustPressed = (upJustReleased = false);
	}

	public bool GetUpButtonDown()
	{
		return upJustPressed;
	}

	public bool GetUpButtonUp()
	{
		return upJustReleased;
	}

	public bool GetUpButton()
	{
		return upPressed;
	}

	public bool GetDownButtonDown()
	{
		return downJustPressed;
	}

	public bool GetDownButtonUp()
	{
		return downJustReleased;
	}

	public bool GetDownButton()
	{
		return downPressed;
	}

	public void Update()
	{
		downJustPressed = (downJustReleased = false);
		upJustPressed = (upJustReleased = false);
		float axisRaw = Input.GetAxisRaw(axisName);
		if (axisRaw < -0.5f)
		{
			if (!downPressed)
			{
				downPressed = true;
				downJustPressed = true;
			}
			if (upPressed)
			{
				upPressed = false;
				upJustReleased = true;
			}
		}
		else if (axisRaw > 0.5f)
		{
			if (downPressed)
			{
				downPressed = false;
				downJustReleased = true;
			}
			if (!upPressed)
			{
				upPressed = true;
				upJustPressed = true;
			}
		}
		else if (axisRaw >= -0.5f && axisRaw <= 0.5f)
		{
			if (downPressed)
			{
				downPressed = false;
				downJustReleased = true;
			}
			if (upPressed)
			{
				upPressed = false;
				upJustReleased = true;
			}
		}
	}
}
namespace Triangulator
{
	public class Delauney
	{
		public static List<Triangle> Triangulate(List<Triangulator.Geometry.Point> Vertex)
		{
			int count = Vertex.Count;
			if (count < 3)
			{
				throw new ArgumentException("Need at least three vertices for triangulation");
			}
			int num = 4 * count;
			double x = Vertex[0].X;
			double y = Vertex[0].Y;
			double num2 = x;
			double num3 = y;
			for (int i = 1; i < count; i++)
			{
				if (Vertex[i].X < x)
				{
					x = Vertex[i].X;
				}
				if (Vertex[i].X > num2)
				{
					num2 = Vertex[i].X;
				}
				if (Vertex[i].Y < y)
				{
					y = Vertex[i].Y;
				}
				if (Vertex[i].Y > num3)
				{
					num3 = Vertex[i].Y;
				}
			}
			double num4 = num2 - x;
			double num5 = num3 - y;
			double num6 = ((!(num4 > num5)) ? num5 : num4);
			double num7 = (num2 + x) * 0.5;
			double num8 = (num3 + y) * 0.5;
			Vertex.Add(new Triangulator.Geometry.Point(num7 - 2.0 * num6, num8 - num6));
			Vertex.Add(new Triangulator.Geometry.Point(num7, num8 + 2.0 * num6));
			Vertex.Add(new Triangulator.Geometry.Point(num7 + 2.0 * num6, num8 - num6));
			List<Triangle> list = new List<Triangle>();
			list.Add(new Triangle(count, count + 1, count + 2));
			for (int j = 0; j < count; j++)
			{
				List<Edge> list2 = new List<Edge>();
				for (int k = 0; k < list.Count; k++)
				{
					if (InCircle(Vertex[j], Vertex[list[k].p1], Vertex[list[k].p2], Vertex[list[k].p3]))
					{
						list2.Add(new Edge(list[k].p1, list[k].p2));
						list2.Add(new Edge(list[k].p2, list[k].p3));
						list2.Add(new Edge(list[k].p3, list[k].p1));
						list.RemoveAt(k);
						k--;
					}
				}
				if (j >= count)
				{
					continue;
				}
				for (int num9 = list2.Count - 2; num9 >= 0; num9--)
				{
					for (int num10 = list2.Count - 1; num10 >= num9 + 1; num10--)
					{
						if (list2[num9].Equals(list2[num10]))
						{
							list2.RemoveAt(num10);
							list2.RemoveAt(num9);
							num10--;
						}
					}
				}
				for (int l = 0; l < list2.Count; l++)
				{
					if (list.Count >= num)
					{
						return list;
					}
					list.Add(new Triangle(list2[l].p1, list2[l].p2, j));
				}
				list2.Clear();
				list2 = null;
			}
			for (int num11 = list.Count - 1; num11 >= 0; num11--)
			{
				if (list[num11].p1 >= count || list[num11].p2 >= count || list[num11].p3 >= count)
				{
					list.RemoveAt(num11);
				}
			}
			Vertex.RemoveAt(Vertex.Count - 1);
			Vertex.RemoveAt(Vertex.Count - 1);
			Vertex.RemoveAt(Vertex.Count - 1);
			list.TrimExcess();
			return list;
		}

		public static void TriangulateEdges(List<Point> points, List<Pair<int, int>> edges)
		{
			edges.Clear();
			List<Triangulator.Geometry.Point> list = new List<Triangulator.Geometry.Point>(points.Count);
			foreach (Point point in points)
			{
				list.Add(new Triangulator.Geometry.Point(point.X, point.Y));
			}
			List<Triangle> list2 = Triangulate(list);
			foreach (Triangle item4 in list2)
			{
				Pair<int, int> item = new Pair<int, int>(Math.Min(item4.p1, item4.p2), Math.Max(item4.p1, item4.p2));
				Pair<int, int> item2 = new Pair<int, int>(Math.Min(item4.p1, item4.p3), Math.Max(item4.p1, item4.p3));
				Pair<int, int> item3 = new Pair<int, int>(Math.Min(item4.p2, item4.p3), Math.Max(item4.p2, item4.p3));
				if (!edges.Contains(item))
				{
					edges.Add(item);
				}
				if (!edges.Contains(item2))
				{
					edges.Add(item2);
				}
				if (!edges.Contains(item3))
				{
					edges.Add(item3);
				}
			}
		}

		private static bool InCircle(Triangulator.Geometry.Point p, Triangulator.Geometry.Point p1, Triangulator.Geometry.Point p2, Triangulator.Geometry.Point p3)
		{
			if (Math.Abs(p1.Y - p2.Y) < double.Epsilon && Math.Abs(p2.Y - p3.Y) < double.Epsilon)
			{
				return false;
			}
			double num4;
			double num5;
			if (Math.Abs(p2.Y - p1.Y) < double.Epsilon)
			{
				double num = (0.0 - (p3.X - p2.X)) / (p3.Y - p2.Y);
				double num2 = (p2.X + p3.X) * 0.5;
				double num3 = (p2.Y + p3.Y) * 0.5;
				num4 = (p2.X + p1.X) * 0.5;
				num5 = num * (num4 - num2) + num3;
			}
			else if (Math.Abs(p3.Y - p2.Y) < double.Epsilon)
			{
				double num6 = (0.0 - (p2.X - p1.X)) / (p2.Y - p1.Y);
				double num7 = (p1.X + p2.X) * 0.5;
				double num8 = (p1.Y + p2.Y) * 0.5;
				num4 = (p3.X + p2.X) * 0.5;
				num5 = num6 * (num4 - num7) + num8;
			}
			else
			{
				double num6 = (0.0 - (p2.X - p1.X)) / (p2.Y - p1.Y);
				double num = (0.0 - (p3.X - p2.X)) / (p3.Y - p2.Y);
				double num7 = (p1.X + p2.X) * 0.5;
				double num2 = (p2.X + p3.X) * 0.5;
				double num8 = (p1.Y + p2.Y) * 0.5;
				double num3 = (p2.Y + p3.Y) * 0.5;
				num4 = (num6 * num7 - num * num2 + num3 - num8) / (num6 - num);
				num5 = num6 * (num4 - num7) + num8;
			}
			double num9 = p2.X - num4;
			double num10 = p2.Y - num5;
			double num11 = num9 * num9 + num10 * num10;
			num9 = p.X - num4;
			num10 = p.Y - num5;
			double num12 = num9 * num9 + num10 * num10;
			return num12 <= num11;
		}
	}
}
namespace Triangulator.Geometry
{
	public class Edge : IEquatable<Edge>
	{
		public int p1;

		public int p2;

		public Edge(int point1, int point2)
		{
			p1 = point1;
			p2 = point2;
		}

		public Edge()
			: this(0, 0)
		{
		}

		public bool Equals(Edge other)
		{
			return (p1 == other.p2 && p2 == other.p1) || (p1 == other.p1 && p2 == other.p2);
		}
	}
	public class Point
	{
		protected double _X;

		protected double _Y;

		public double X
		{
			get
			{
				return _X;
			}
			set
			{
				_X = value;
			}
		}

		public double Y
		{
			get
			{
				return _Y;
			}
			set
			{
				_Y = value;
			}
		}

		public Point(double x, double y)
		{
			_X = x;
			_Y = y;
		}

		public bool Equals2D(Point other)
		{
			return X == other.X && Y == other.Y;
		}
	}
	public class Point<T> : Point
	{
		private T _attr;

		public T Attribute
		{
			get
			{
				return _attr;
			}
			set
			{
				_attr = value;
			}
		}

		public Point(double x, double y, T attribute)
			: base(x, y)
		{
			_attr = attribute;
		}

		public Point(double x, double y)
			: this(x, y, default(T))
		{
		}
	}
	public struct Triangle
	{
		public int p1;

		public int p2;

		public int p3;

		public Triangle(int point1, int point2, int point3)
		{
			p1 = point1;
			p2 = point2;
			p3 = point3;
		}
	}
}
public class FPSCounter : MonoBehaviour
{
	public TextMesh textMesh;

	public bool showFPS;

	public KeyCode toggleFPSKey = KeyCode.F;

	public string toggleFPSButton = string.Empty;

	private float counter;

	private int frames;

	private float fps;

	private float lastTime;

	private float accum;

	private void Start()
	{
		UnityEngine.Object.Destroy(base.gameObject);
		lastTime = Time.realtimeSinceStartup;
	}

	public void LateUpdate()
	{
		if ((toggleFPSKey != 0 && Input.GetKeyDown(toggleFPSKey)) || (toggleFPSButton.Length > 0 && Input.GetButtonDown(toggleFPSButton)))
		{
			showFPS = !showFPS;
		}
		GetComponent<Renderer>().enabled = showFPS;
		float num = Time.realtimeSinceStartup - lastTime;
		counter += num;
		frames++;
		accum += 1f / num;
		if (counter >= 1f)
		{
			fps = accum / (float)frames;
			counter = 0f;
			frames = 0;
			accum = 0f;
			textMesh.text = fps.ToString("0.0") + " FPS";
		}
		lastTime = Time.realtimeSinceStartup;
	}
}
[RequireComponent(typeof(Camera))]
public class FrustumRenderer : MonoBehaviour
{
	private Camera camera;

	private void Start()
	{
		camera = GetComponent<Camera>();
	}

	private void Update()
	{
		Plane[] camPlanes = GeometryUtility.CalculateFrustumPlanes(camera);
		DrawFrustum(camPlanes);
	}

	public static void DrawFrustumOVR(bool leftEye)
	{
		OVRPlugin.Frustumf eyeFrustum = OVRPlugin.GetEyeFrustum((!leftEye) ? OVRPlugin.Eye.Right : OVRPlugin.Eye.Left);
		float num = 0.1f;
		float num2 = 60f;
		float f = eyeFrustum.fovX * 0.5f;
		float f2 = eyeFrustum.fovY * 0.5f;
		float num3 = Mathf.Sin(f);
		float num4 = Mathf.Sin(f2);
		OVRCameraRig componentInChildren = Player.GetComponentInChildren<OVRCameraRig>();
		Transform transform = ((!leftEye) ? componentInChildren.rightEyeAnchor : componentInChildren.leftEyeAnchor);
		Vector3 zero = Vector3.zero;
		Vector3 position = new Vector3(num3 * num2, num4 * num2, num2);
		Vector3 position2 = new Vector3(num3 * num2, (0f - num4) * num2, num2);
		Vector3 position3 = new Vector3((0f - num3) * num2, num4 * num2, num2);
		Vector3 position4 = new Vector3((0f - num3) * num2, (0f - num4) * num2, num2);
		Vector3 position5 = new Vector3(num3 * num, num4 * num, num);
		Vector3 position6 = new Vector3(num3 * num, (0f - num4) * num, num);
		Vector3 position7 = new Vector3((0f - num3) * num, num4 * num, num);
		Vector3 position8 = new Vector3((0f - num3) * num, (0f - num4) * num, num);
		zero = transform.TransformPoint(zero);
		position3 = transform.TransformPoint(position3);
		position = transform.TransformPoint(position);
		position4 = transform.TransformPoint(position4);
		position2 = transform.TransformPoint(position2);
		position7 = transform.TransformPoint(position7);
		position5 = transform.TransformPoint(position5);
		position8 = transform.TransformPoint(position8);
		position6 = transform.TransformPoint(position6);
		DrawFrustum(new Plane[6]
		{
			new Plane(zero, position3, position4),
			new Plane(zero, position2, position),
			new Plane(zero, position4, position2),
			new Plane(zero, position, position3),
			new Plane(position5, position7, position8),
			new Plane(position3, position, position2)
		});
	}

	public static void DrawFrustum(Plane[] camPlanes)
	{
		Vector3[] array = new Vector3[4];
		Vector3[] array2 = new Vector3[4];
		Plane plane = camPlanes[1];
		ref Plane reference = ref camPlanes[1];
		reference = camPlanes[2];
		camPlanes[2] = plane;
		for (int i = 0; i < 4; i++)
		{
			ref Vector3 reference2 = ref array[i];
			reference2 = Plane3Intersect(camPlanes[4], camPlanes[i], camPlanes[(i + 1) % 4]);
			ref Vector3 reference3 = ref array2[i];
			reference3 = Plane3Intersect(camPlanes[5], camPlanes[i], camPlanes[(i + 1) % 4]);
		}
		for (int j = 0; j < 4; j++)
		{
			Debug.DrawLine(array[j], array[(j + 1) % 4], Color.red, Time.deltaTime, depthTest: true);
			Debug.DrawLine(array2[j], array2[(j + 1) % 4], Color.blue, Time.deltaTime, depthTest: true);
			Debug.DrawLine(array[j], array2[j], Color.green, Time.deltaTime, depthTest: true);
		}
	}

	private static Vector3 Plane3Intersect(Plane p1, Plane p2, Plane p3)
	{
		return ((0f - p1.distance) * Vector3.Cross(p2.normal, p3.normal) + (0f - p2.distance) * Vector3.Cross(p3.normal, p1.normal) + (0f - p3.distance) * Vector3.Cross(p1.normal, p2.normal)) / Vector3.Dot(p1.normal, Vector3.Cross(p2.normal, p3.normal));
	}
}
public class LookAtTarget : MonoBehaviour
{
	public Transform target;

	public bool inverted;

	public float maxAngle;

	private void Start()
	{
		if (target == null)
		{
			target = GameObject.FindWithTag(Tags.ForwardDirection).transform;
		}
	}

	private void Update()
	{
		if (!(target != null))
		{
			return;
		}
		Vector3 vector = Vector3Ext.GroundVector(target.position, base.transform.position);
		if (inverted)
		{
			vector = -vector;
		}
		vector.Normalize();
		if (maxAngle <= 0f)
		{
			Quaternion rotation = Quaternion.LookRotation(vector, Vector3.up);
			base.transform.rotation = rotation;
			return;
		}
		Vector3 normalized = base.transform.forward.ToGround().normalized;
		float num = Vector3.SignedAngle(normalized, vector, Vector3.up);
		if (Mathf.Abs(num) > maxAngle)
		{
			num = ((!(num > 0f)) ? (num + maxAngle) : (num - maxAngle));
			base.transform.Rotate(Vector3.up, num);
		}
	}
}
public class ObjExporter
{
	public static string MeshToString(MeshFilter mf)
	{
		Mesh mesh = mf.mesh;
		Material[] sharedMaterials = mf.GetComponent<Renderer>().sharedMaterials;
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append("g ").Append(mf.name).Append("\n");
		Vector3[] vertices = mesh.vertices;
		for (int i = 0; i < vertices.Length; i++)
		{
			Vector3 vector = vertices[i];
			stringBuilder.Append($"v {vector.x} {vector.y} {vector.z}\n");
		}
		stringBuilder.Append("\n");
		Vector3[] normals = mesh.normals;
		for (int j = 0; j < normals.Length; j++)
		{
			Vector3 vector2 = normals[j];
			stringBuilder.Append($"vn {vector2.x} {vector2.y} {vector2.z}\n");
		}
		stringBuilder.Append("\n");
		Vector2[] uv = mesh.uv;
		for (int k = 0; k < uv.Length; k++)
		{
			Vector3 vector3 = uv[k];
			stringBuilder.Append($"vt {vector3.x} {vector3.y}\n");
		}
		for (int l = 0; l < mesh.subMeshCount; l++)
		{
			stringBuilder.Append("\n");
			stringBuilder.Append("usemtl ").Append(sharedMaterials[l].name).Append("\n");
			stringBuilder.Append("usemap ").Append(sharedMaterials[l].name).Append("\n");
			int[] triangles = mesh.GetTriangles(l);
			for (int m = 0; m < triangles.Length; m += 3)
			{
				stringBuilder.Append(string.Format("f {0}/{0}/{0} {1}/{1}/{1} {2}/{2}/{2}\n", triangles[m] + 1, triangles[m + 1] + 1, triangles[m + 2] + 1));
			}
		}
		return stringBuilder.ToString();
	}

	public static void MeshToFile(MeshFilter mf, string filename)
	{
		using StreamWriter streamWriter = new StreamWriter(filename);
		streamWriter.Write(MeshToString(mf));
	}
}
public class ParticleDie : MonoBehaviour
{
	private ParticleSystem particles;

	private void Start()
	{
		particles = GetComponent<ParticleSystem>();
	}

	private void Update()
	{
		if (!particles.IsAlive(withChildren: true))
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public static class RandomExt
{
	public static int RandInt(int min, int max)
	{
		return UnityEngine.Random.Range(min, max + 1);
	}

	public static int RandInt(int max)
	{
		return RandInt(0, max);
	}

	public static T Choice<T>(List<T> arrItems)
	{
		return arrItems[UnityEngine.Random.Range(0, arrItems.Count)];
	}

	public static T Choice<T>(T[] arrItems)
	{
		return arrItems[UnityEngine.Random.Range(0, arrItems.Length)];
	}

	public static T WeightedChoice<T>(List<Pair<T, int>> arrItems)
	{
		if (arrItems.Count == 0)
		{
			return default(T);
		}
		if (arrItems.Count == 1)
		{
			return arrItems[0].First;
		}
		int num = 0;
		foreach (Pair<T, int> arrItem in arrItems)
		{
			num += arrItem.Second;
		}
		int num2 = UnityEngine.Random.Range(0, num);
		foreach (Pair<T, int> arrItem2 in arrItems)
		{
			if (arrItem2.Second > num2)
			{
				return arrItem2.First;
			}
			num2 -= arrItem2.Second;
		}
		return arrItems[arrItems.Count - 1].First;
	}

	public static T WeightedChoice<T>(List<Pair<T, float>> arrItems)
	{
		if (arrItems.Count == 0)
		{
			return default(T);
		}
		float num = 0f;
		foreach (Pair<T, float> arrItem in arrItems)
		{
			num += arrItem.Second;
		}
		float num2 = UnityEngine.Random.Range(0f, num);
		foreach (Pair<T, float> arrItem2 in arrItems)
		{
			if (arrItem2.Second > num2)
			{
				return arrItem2.First;
			}
			num2 -= arrItem2.Second;
		}
		return arrItems[arrItems.Count - 1].First;
	}

	public static float Gaussian(float avg = 0f, float stdDev = 1f)
	{
		float num;
		float num3;
		do
		{
			num = 2f * UnityEngine.Random.value - 1f;
			float num2 = 2f * UnityEngine.Random.value - 1f;
			num3 = num * num + num2 * num2;
		}
		while (num3 >= 1f);
		float num4 = Mathf.Sqrt(-2f * Mathf.Log(num3) / num3);
		num4 = num * num4;
		return num4 * stdDev + avg;
	}

	public static float GaussianRange(float min, float max)
	{
		float num = (min + max) / 2f;
		float num2 = (max - num) / 3f;
		float num3;
		do
		{
			num3 = Gaussian(num, num2);
		}
		while (Mathf.Abs(num3 - num) > 3f * num2);
		return num3;
	}
}
public class TileArea
{
	public List<IntRect> rectangles = new List<IntRect>();

	public List<Point> exceptions = new List<Point>();

	public TileArea()
	{
	}

	public TileArea(IntRect rect)
	{
		Add(rect);
	}

	public void Add(IntRect rect)
	{
		if (rect.width == 1 && rect.height == 1 && exceptions.Count > 0)
		{
			Point item = new Point(rect.x, rect.y);
			if (exceptions.Contains(item))
			{
				exceptions.Remove(item);
			}
		}
		for (int i = 0; i < rectangles.Count; i++)
		{
			if (TryJoin(rectangles[i], rect, out var result))
			{
				rectangles.RemoveAt(i);
				Add(result);
				return;
			}
		}
		rectangles.Add(rect);
	}

	public void Add(Point point)
	{
		if (exceptions.Contains(point))
		{
			exceptions.Remove(point);
		}
		Add(new IntRect(point.X, point.Y, 1, 1));
	}

	public void AddException(Point point)
	{
		exceptions.Add(point);
	}

	public bool IsInside(int x, int y)
	{
		return IsInside(new Point(x, y));
	}

	public bool IsInside(Point point)
	{
		foreach (IntRect rectangle in rectangles)
		{
			if (rectangle.Contains(point) && !exceptions.Contains(point))
			{
				return true;
			}
		}
		return false;
	}

	public Point RandomPoint()
	{
		int index = UnityEngine.Random.Range(0, rectangles.Count);
		return new Point(UnityEngine.Random.Range(rectangles[index].x, rectangles[index].xMax), UnityEngine.Random.Range(rectangles[index].y, rectangles[index].yMax));
	}

	private bool TryJoin(IntRect r1, IntRect r2, out IntRect result)
	{
		result = r1;
		int num = Mathf.Min(r1.left, r2.left);
		int num2 = Mathf.Max(r1.left, r2.left);
		int num3 = Mathf.Min(r1.right, r2.right);
		int num4 = Mathf.Max(r1.right, r2.right);
		int num5 = Mathf.Min(r1.top, r2.top);
		int num6 = Mathf.Max(r1.top, r2.top);
		int num7 = Mathf.Min(r1.bottom, r2.bottom);
		int num8 = Mathf.Max(r1.bottom, r2.bottom);
		if ((num3 == num2 && num5 == num6 && num7 == num8) || (num7 == num6 && num == num2 && num3 == num4))
		{
			result = new IntRect(num, num5, num4 - num, num8 - num5);
			return true;
		}
		return false;
	}
}
public class Utils
{
	public static Vector2 Slerp(Vector2 from, Vector2 to, float f)
	{
		if (from == to)
		{
			return from;
		}
		float value = Vector2.Dot(from, to);
		value = Mathf.Clamp(value, -0.999f, 1f);
		double num = Math.Acos(value);
		if (num == 0.0)
		{
			return from;
		}
		double num2 = Math.Sin(num);
		return (float)(Math.Sin((double)(1f - f) * num) / num2) * from + (float)(Math.Sin((double)f * num) / num2) * to;
	}

	public static bool IntersectCircleRectangle(Vector2 circleCenter, float circleRadius, Rect rect)
	{
		Vector2 zero = Vector2.zero;
		zero.x = Mathf.Clamp(circleCenter.x, rect.x, rect.xMax);
		zero.y = Mathf.Clamp(circleCenter.y, rect.y, rect.yMax);
		float num = (circleCenter - zero).SqrMagnitude();
		return num < circleRadius * circleRadius;
	}

	public static Vector2 ProjectPointOnSegment(Vector2 vPoint, Vector2 vStart, Vector2 vEnd)
	{
		float f;
		return ProjectPointOnSegment(vPoint, vStart, vEnd, out f);
	}

	public static Vector2 ProjectPointOnSegment(Vector2 vPoint, Vector2 vStart, Vector2 vEnd, out float f)
	{
		Vector2 vector = vEnd - vStart;
		float num = vector.SqrMagnitude();
		f = Vector2.Dot(vector, vPoint - vStart) / num;
		if (f <= 0f)
		{
			return vStart;
		}
		if (f >= 1f)
		{
			return vEnd;
		}
		return vStart + f * vector;
	}

	public static int ClosestSegmentInPath(List<Vector2> path, Vector2 vPoint)
	{
		Vector2 vProjection;
		float f;
		return ClosestSegmentInPath(path, vPoint, out vProjection, out f);
	}

	public static int ClosestSegmentInPath(List<Vector2> path, Vector2 vPoint, out Vector2 vProjection)
	{
		float f;
		return ClosestSegmentInPath(path, vPoint, out vProjection, out f);
	}

	public static int ClosestSegmentInPath(List<Vector2> path, Vector2 vPoint, out float f)
	{
		Vector2 vProjection;
		return ClosestSegmentInPath(path, vPoint, out vProjection, out f);
	}

	public static int ClosestSegmentInPath(List<Vector2> path, Vector2 vPoint, out Vector2 vProjection, out float f)
	{
		vProjection = vPoint;
		f = 0f;
		if (path.Count < 2)
		{
			return 0;
		}
		float num = float.MaxValue;
		int result = 0;
		for (int i = 0; i < path.Count - 1; i++)
		{
			Vector2 vStart = path[i];
			Vector2 vEnd = path[i + 1];
			float f2;
			Vector2 vector = ProjectPointOnSegment(vPoint, vStart, vEnd, out f2);
			float num2 = (vPoint - vector).SqrMagnitude();
			if (num2 <= num)
			{
				result = i;
				num = num2;
				f = f2;
				vProjection = vector;
			}
		}
		return result;
	}

	public static float DistanceToSegmentSq(Vector2 vPoint, Vector2 vStart, Vector2 vEnd)
	{
		float f;
		Vector2 vector = ProjectPointOnSegment(vPoint, vStart, vEnd, out f);
		return (vPoint - vector).SqrMagnitude();
	}

	public static float GetSlope(float fX1, float fY1, float fX2, float fY2)
	{
		return (fX1 - fX2) / (fY1 - fY2);
	}

	public static float GetSlopeInv(float fX1, float fY1, float fX2, float fY2)
	{
		return (fY1 - fY2) / (fX1 - fX2);
	}

	public static float GetSlope(float fX1, float fY1, float fX2, float fY2, bool bInvert)
	{
		if (bInvert)
		{
			return GetSlopeInv(fX1, fY1, fX2, fY2);
		}
		return GetSlope(fX1, fY1, fX2, fY2);
	}

	public static bool SegmentIntersect(ref Vector2 vStart, ref Vector2 vEnd, ref Vector2 vStart2, ref Vector2 vEnd2, out Vector2 vIntersection)
	{
		vIntersection = Vector2.zero;
		Vector2 vector = vEnd - vStart;
		Vector2 vector2 = vEnd2 - vStart2;
		float num = vector.x * vector2.y - vector.y * vector2.x;
		if (num == 0f)
		{
			return false;
		}
		Vector2 vector3 = vStart2 - vStart;
		float num2 = vector3.x * vector2.y - vector3.y * vector2.x;
		num2 /= num;
		if (num2 < 0f || num2 > 1f)
		{
			return false;
		}
		float num3 = vector3.x * vector.y - vector3.y * vector.x;
		num3 /= num;
		if (num3 < 0f || num3 > 1f)
		{
			return false;
		}
		vector.x *= num2;
		vector.y *= num2;
		vIntersection = vStart + vector;
		return true;
	}

	public static bool SegmentIntersect(ref Vector2 vStart, ref Vector2 vEnd, ref Vector2 vStart2, ref Vector2 vEnd2, ref Vector2 vS, out Vector2 vIntersection)
	{
		vIntersection = Vector2.zero;
		Vector2 vector = vEnd - vStart;
		float num = vector.x * vS.y - vector.y * vS.x;
		if (num == 0f)
		{
			return false;
		}
		Vector2 vector2 = vStart2 - vStart;
		float num2 = vector2.x * vS.y - vector2.y * vS.x;
		num2 /= num;
		if (num2 < 0f || num2 > 1f)
		{
			return false;
		}
		float num3 = vector2.x * vector.y - vector2.y * vector.x;
		num3 /= num;
		if (num3 < 0f || num3 > 1f)
		{
			return false;
		}
		vector.x *= num2;
		vector.y *= num2;
		vIntersection = vStart + vector;
		return true;
	}

	public static bool CheckBoundsInFrustrum(Bounds bounds)
	{
		Camera[] componentsInChildren = Player.Get().GetComponentsInChildren<Camera>();
		Camera[] array = componentsInChildren;
		foreach (Camera camera in array)
		{
			Plane[] planes = GeometryUtility.CalculateFrustumPlanes(camera);
			if (GeometryUtility.TestPlanesAABB(planes, bounds))
			{
				return true;
			}
		}
		return false;
	}

	public static List<Camera> GetPlayerCameras()
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag(Tags.MainCamera);
		List<Camera> list = new List<Camera>();
		for (int i = 0; i < array.Length; i++)
		{
			list.AddRange(array[i].GetComponents<Camera>());
		}
		return list;
	}

	public static AudioSource PlayClipAt(AudioClip clip, Vector3 pos, float minDistance = 1f, float maxDistance = 500f, float spread = 0f, AudioRolloffMode rolloffMode = AudioRolloffMode.Logarithmic)
	{
		GameObject gameObject = new GameObject("TempAudio");
		gameObject.transform.position = pos;
		AudioSource audioSource = gameObject.AddComponent<AudioSource>();
		audioSource.clip = clip;
		audioSource.spatialBlend = 1f;
		audioSource.rolloffMode = rolloffMode;
		audioSource.minDistance = minDistance;
		audioSource.maxDistance = maxDistance;
		audioSource.spread = spread;
		audioSource.Play();
		UnityEngine.Object.Destroy(gameObject, clip.length);
		return audioSource;
	}

	public static bool IsInLayerMask(GameObject obj, LayerMask layerMask)
	{
		int num = 1 << obj.layer;
		if ((layerMask.value & num) > 0)
		{
			return true;
		}
		return false;
	}

	public static int NumberOfSetBits(int i)
	{
		i -= (i >> 1) & 0x55555555;
		i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
		return ((i + (i >> 4)) & 0xF0F0F0F) * 16843009 >> 24;
	}

	public static void GetTypesInNamespace(List<Type> list, string nameSpace)
	{
		list.Clear();
		Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
		Assembly[] array = assemblies;
		foreach (Assembly assembly in array)
		{
			list.AddRange((from t in assembly.GetTypes()
				where string.Equals(t.Namespace, nameSpace, StringComparison.Ordinal)
				select t).ToArray());
		}
	}

	public static Vector3 BezierInterpolate(Vector3 vP1, Vector3 vP2, Vector3 vP3, Vector3 vP4, float param)
	{
		float num = 1f - param;
		float num2 = param * param;
		float num3 = num * num;
		float num4 = num2 * param;
		float num5 = 3f * num2 * num;
		float num6 = 3f * param * num3;
		float num7 = num3 * num;
		return num7 * vP1 + num6 * vP2 + num5 * vP3 + num4 * vP4;
	}

	public static bool IsAncestor(Transform obj, Transform parent)
	{
		Transform parent2 = obj.parent;
		while (parent2 != null)
		{
			if (parent2 == parent)
			{
				return true;
			}
			parent2 = parent2.parent;
		}
		return false;
	}

	public static string WordWrap(string sourceStr, TextMesh textMesh, float wrapLimit)
	{
		if (Translate.GetLanguage() == "chinese")
		{
			return WordWrapPattern(sourceStr, textMesh, wrapLimit, "(?<=[ ，。])");
		}
		if (Translate.GetLanguage() == "japanese")
		{
			return WordWrapPattern(sourceStr, textMesh, wrapLimit, "(?<=[ ,・、。])", canSplitParts: true);
		}
		Quaternion rotation = textMesh.transform.rotation;
		textMesh.transform.rotation = Quaternion.identity;
		string text = string.Empty;
		textMesh.text = string.Empty;
		string[] array = sourceStr.Split(' ');
		for (int i = 0; i < array.Length; i++)
		{
			textMesh.text = textMesh.text + array[i] + " ";
			if (textMesh.GetComponent<Renderer>().bounds.extents.x > wrapLimit)
			{
				textMesh.text = text.TrimEnd() + Environment.NewLine + array[i] + " ";
			}
			text = textMesh.text;
		}
		textMesh.transform.rotation = rotation;
		return text;
	}

	public static string WordWrapPattern(string sourceStr, TextMesh textMesh, float wrapLimit, string pattern, bool canSplitParts = false)
	{
		Quaternion rotation = textMesh.transform.rotation;
		textMesh.transform.rotation = Quaternion.identity;
		string text = string.Empty;
		textMesh.text = string.Empty;
		string[] array = Regex.Split(sourceStr, pattern);
		for (int i = 0; i < array.Length; i++)
		{
			float x = textMesh.GetComponent<Renderer>().bounds.extents.x;
			textMesh.text += array[i];
			float x2 = textMesh.GetComponent<Renderer>().bounds.extents.x;
			if (x2 > wrapLimit)
			{
				if (canSplitParts && x2 - x > wrapLimit)
				{
					float num = (x2 - x) / (float)array[i].Length;
					int num2 = Mathf.FloorToInt(wrapLimit / num);
					string text2 = array[i].Substring(0, num2);
					string text3 = array[i].Substring(num2, array[i].Length - num2);
					textMesh.text = text.TrimEnd() + Environment.NewLine + text2 + Environment.NewLine + text3;
				}
				else
				{
					textMesh.text = text.TrimEnd() + Environment.NewLine + array[i];
				}
			}
			text = textMesh.text;
		}
		textMesh.transform.rotation = rotation;
		return text;
	}

	public static bool IsPlayerVisible(Transform enemyTransform, float maxAngle = 85f, bool checkOnlyAngle = false, float maxDistance = 16f, float yDelta = 0f)
	{
		float angleToPoint = GetAngleToPoint(enemyTransform, Player.GetPos());
		if (Mathf.Abs(angleToPoint) <= maxAngle)
		{
			if (checkOnlyAngle)
			{
				return true;
			}
			Vector3 position = Player.GetLook().position;
			Vector3 direction = position - (enemyTransform.position + Vector3.up * yDelta);
			if (direction.sqrMagnitude > maxDistance * maxDistance)
			{
				return false;
			}
			float magnitude = direction.magnitude;
			direction /= magnitude;
			if (Physics.Raycast(enemyTransform.position + Vector3.up * yDelta, direction, out var hitInfo, magnitude))
			{
				return hitInfo.collider.gameObject == Player.Get();
			}
			return true;
		}
		return false;
	}

	public static float GetAngleToPoint(Transform refTransform, Vector3 targetPoint)
	{
		Vector3 vec = targetPoint - refTransform.position;
		vec = vec.GroundNormalize();
		return Vector3.Angle(refTransform.forward, vec);
	}

	public static bool IsAnyButtonDown()
	{
		if (Input.GetKey(KeyCode.Joystick1Button0) || Input.GetKey(KeyCode.Joystick1Button1) || Input.GetKey(KeyCode.Joystick1Button2) || Input.GetKey(KeyCode.Joystick1Button3) || Input.GetKey(KeyCode.Joystick1Button4) || Input.GetKey(KeyCode.Joystick1Button5) || Input.GetKey(KeyCode.Joystick1Button6) || Input.GetKey(KeyCode.Joystick1Button7) || Input.GetKey(KeyCode.Joystick1Button8) || Input.GetKey(KeyCode.Joystick1Button9))
		{
			return true;
		}
		return false;
	}
}
public class WarmUp : MonoBehaviour
{
	public GameObject[] toInstantiate;

	private int frameCounter;

	private void Awake()
	{
		GetComponent<MeshRenderer>().enabled = true;
		for (int i = 0; i < toInstantiate.Length; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(toInstantiate[i]);
			gameObject.transform.parent = base.transform;
			gameObject.transform.localPosition = Vector3.zero;
		}
	}

	private void Start()
	{
		GameObject gameObject = GameObject.FindWithTag(Tags.MainCamera);
		if (gameObject != null)
		{
			base.transform.position = gameObject.transform.position + gameObject.transform.forward * 7f;
		}
	}

	private void Update()
	{
		frameCounter++;
		if (frameCounter > 3)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
